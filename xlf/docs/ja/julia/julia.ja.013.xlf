<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="0ac236a3ea7a0e9ead5326f9e44c423dc78ebc26" translate="yes" xml:space="preserve">
          <source>Tests whether a character is a lowercase letter. A character is classified as lowercase if it belongs to Unicode category Ll, Letter: Lowercase.</source>
          <target state="translated">文字が小文字であるかどうかをテストします。文字が Unicode カテゴリ Ll,Letter に属している場合、その文字は小文字として分類されます。小文字。</target>
        </trans-unit>
        <trans-unit id="91cdaf6d3cfe470a11194162162137ec98b73f57" translate="yes" xml:space="preserve">
          <source>Tests whether a character is an uppercase letter. A character is classified as uppercase if it belongs to Unicode category Lu, Letter: Uppercase, or Lt, Letter: Titlecase.</source>
          <target state="translated">文字が大文字かどうかを判定します。文字が Unicode カテゴリ Lu,Letter に属している場合、大文字に分類されます。Uppercase、または Lt,Letter.タイトルケースに属している場合に大文字に分類されます。</target>
        </trans-unit>
        <trans-unit id="45909810023531a635329b57dc9f15acb810e806" translate="yes" xml:space="preserve">
          <source>Tests whether a character is any whitespace character. Includes ASCII characters '\t', '\n', '\v', '\f', '\r', and ' ', Latin-1 character U+0085, and characters in Unicode category Zs.</source>
          <target state="translated">文字が任意の空白文字であるかどうかをテストする。ASCII文字'\t','\n','\v','\f','\r',and ' ',Latin-1 character U+0085,and characters in Unicode category Zsを含む。</target>
        </trans-unit>
        <trans-unit id="b0a4dc18e63052a8e4b050ac6060b42fea1cafaa" translate="yes" xml:space="preserve">
          <source>Tests whether a character is numeric. A character is classified as numeric if it belongs to the Unicode general category Number, i.e. a character whose category code begins with 'N'.</source>
          <target state="translated">文字が数値であるかどうかを調べます。キ ャ ラ ク タ が Unicode 一般カ テ ゴ リ 番号に属す る 場合、 すなわち、 カ テ ゴ リ コ ー ド が 「N」 で始ま る キ ャ ラ ク タ の場合、 キ ャ ラ ク タ は数値 と し て分類 さ れます。</target>
        </trans-unit>
        <trans-unit id="982f0addad2d0da939982a5caca6283ccb1d7eb4" translate="yes" xml:space="preserve">
          <source>Tests whether a character is printable, including spaces, but not a control character.</source>
          <target state="translated">文字がスペースを含めて印刷可能かどうかをテストしますが、制御文字ではありません。</target>
        </trans-unit>
        <trans-unit id="e49525a9628b3bad0a6106685a8ac5eeac97a7e1" translate="yes" xml:space="preserve">
          <source>Tests whether a global variable or object field is defined. The arguments can be a module and a symbol or a composite object and field name (as a symbol) or index.</source>
          <target state="translated">グローバル変数またはオブジェクトフィールドが定義されているかどうかをテストします。引数には、モジュールとシンボル、または複合オブジェクトとフィールド名(シンボルとして)、またはインデックスを指定できます。</target>
        </trans-unit>
        <trans-unit id="b292cfab7944ffbf6199920c5349913e95d9eeb7" translate="yes" xml:space="preserve">
          <source>Tests whether variable &lt;code&gt;s&lt;/code&gt; is defined in the current scope.</source>
          <target state="translated">変数 &lt;code&gt;s&lt;/code&gt; が現在のスコープで定義されているかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="109f7c2f219315f947611c43c343d61302c960d4" translate="yes" xml:space="preserve">
          <source>Text I/O</source>
          <target state="translated">テキスト入出力</target>
        </trans-unit>
        <trans-unit id="ea824a563aca9df06f453afa8aed6e59740fd02e" translate="yes" xml:space="preserve">
          <source>Text from external sources, such as quotations from books or websites, can be quoted using &lt;code&gt;&amp;gt;&lt;/code&gt; characters prepended to each line of the quote as follows.</source>
          <target state="translated">本やウェブサイトからの引用などの外部ソースからのテキストは、次のように引用の各行の前に付加される &lt;code&gt;&amp;gt;&lt;/code&gt; 文字を使用して引用できます。</target>
        </trans-unit>
        <trans-unit id="fbe2b75f7fbda9be349dabaf963a9b88611d5493" translate="yes" xml:space="preserve">
          <source>That is really all there is to using promotions. The rest is just a matter of clever application, the most typical &quot;clever&quot; application being the definition of catch-all methods for numeric operations like the arithmetic operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;. Here are some of the catch-all method definitions given in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt;&lt;code&gt;promotion.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">プロモーションを使用するには、これですべてです。残りは、賢いアプリケーションの問題にすぎません。最も一般的な「賢い」アプリケーションは、算術演算子 &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;-&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; および &lt;code&gt;/&lt;/code&gt; のような数値演算のキャッチオールメソッドの定義です。次に、&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt; &lt;code&gt;promotion.jl&lt;/code&gt; で&lt;/a&gt;指定されたキャッチオールメソッドの定義の一部を示します。</target>
        </trans-unit>
        <trans-unit id="a55180ee0e35250f4a5e86928557c4ebfc2a5b49" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;fdot(x)&lt;/code&gt; is ten times faster and allocates 1/6 the memory of &lt;code&gt;f(x)&lt;/code&gt;, because each &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; operation in &lt;code&gt;f(x)&lt;/code&gt; allocates a new temporary array and executes in a separate loop. (Of course, if you just do &lt;code&gt;f.(x)&lt;/code&gt; then it is as fast as &lt;code&gt;fdot(x)&lt;/code&gt; in this example, but in many contexts it is more convenient to just sprinkle some dots in your expressions rather than defining a separate function for each vectorized operation.)</source>
          <target state="translated">すなわち、 &lt;code&gt;fdot(x)&lt;/code&gt; 10倍高速と割り当ての1/6メモリで &lt;code&gt;f(x)&lt;/code&gt; がそれぞれので、 &lt;code&gt;*&lt;/code&gt; と &lt;code&gt;+&lt;/code&gt; の動作 &lt;code&gt;f(x)&lt;/code&gt; 別のループに新たな一時配列と実行を割り当てます。（もちろん、 &lt;code&gt;f.(x)&lt;/code&gt; だけを実行すると、この例では &lt;code&gt;fdot(x)&lt;/code&gt; と同じくらい高速ですが、多くのコンテキストでは、式にいくつかのドットを散布する方が、別の関数を定義するよりも便利です各ベクトル化された操作。）</target>
        </trans-unit>
        <trans-unit id="96ae6d125bf587e76e862ea35e250d9a1dd1ac01" translate="yes" xml:space="preserve">
          <source>That is, &lt;code&gt;maxintfloat&lt;/code&gt; returns the smallest positive integer-valued floating-point number &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;n+1&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; exactly representable in the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">つまり、 &lt;code&gt;maxintfloat&lt;/code&gt; は、 &lt;code&gt;n+1&lt;/code&gt; が型 &lt;code&gt;T&lt;/code&gt; で正確に表現&lt;em&gt;できない&lt;/em&gt;ように、最小の正の整数値の浮動小数点数 &lt;code&gt;n&lt;/code&gt; を返します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5135aa1a424ac6b5ea53a127625ebc585292c35c" translate="yes" xml:space="preserve">
          <source>That is, in the first call, the expression &lt;code&gt;:(1 == 1.0)&lt;/code&gt; is spliced into the test condition slot, while the value of &lt;code&gt;string(:(1 == 1.0))&lt;/code&gt; is spliced into the assertion message slot. The entire expression, thus constructed, is placed into the syntax tree where the &lt;code&gt;@assert&lt;/code&gt; macro call occurs. Then at execution time, if the test expression evaluates to true, then &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; is returned, whereas if the test is false, an error is raised indicating the asserted expression that was false. Notice that it would not be possible to write this as a function, since only the &lt;em&gt;value&lt;/em&gt; of the condition is available and it would be impossible to display the expression that computed it in the error message.</source>
          <target state="translated">つまり、最初の呼び出しでは、式 &lt;code&gt;:(1 == 1.0)&lt;/code&gt; がテスト条件スロットにスプライスされ、 &lt;code&gt;string(:(1 == 1.0))&lt;/code&gt; の値がアサーションメッセージスロットにスプライスされます。このようにして構築された式全体が、 &lt;code&gt;@assert&lt;/code&gt; マクロ呼び出しが発生する構文ツリーに配置されます。次に、実行時に、テスト式がtrueと評価された場合は&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;も返されませんが、テストがfalseの場合は、アサートされた式がfalseであることを示すエラーが発生します。条件の&lt;em&gt;値&lt;/em&gt;のみが使用可能であり、それを計算した式をエラーメッセージに表示することができないため、これを関数として記述することはできません。</target>
        </trans-unit>
        <trans-unit id="a5c2c27899b95213132fa8a21acc33667eaa425d" translate="yes" xml:space="preserve">
          <source>That is, write:</source>
          <target state="translated">つまり、書くこと。</target>
        </trans-unit>
        <trans-unit id="d78e12b42ebbdc9ccff0d1ee38bf8bf79ad2272d" translate="yes" xml:space="preserve">
          <source>That may seem confusing, given that the hour (12) is not divisible by 10. The reason that &lt;code&gt;2016-07-17T12:00:00&lt;/code&gt; was chosen is that it is 17,676,660 hours after &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt;, and 17,676,660 is divisible by 10.</source>
          <target state="translated">時間（12）が10で割り切れない場合、混乱するかもしれません。2016-07-17T12 &lt;code&gt;2016-07-17T12:00:00&lt;/code&gt; が選択されたのは、それが &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; から17,676,660時間後であり、 17,676,660は10で割り切れます。</target>
        </trans-unit>
        <trans-unit id="8eac926841ffd7462f202ab5376273deeb8cd2ba" translate="yes" xml:space="preserve">
          <source>That's all. This macro says that the literal contents of the string literal &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; should be passed to the &lt;code&gt;@r_str&lt;/code&gt; macro and the result of that expansion should be placed in the syntax tree where the string literal occurs. In other words, the expression &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; is equivalent to placing the following object directly into the syntax tree:</source>
          <target state="translated">それで全部です。このマクロは、文字列リテラル &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; のリテラル内容を &lt;code&gt;@r_str&lt;/code&gt; マクロに渡し、その展開の結果を構文ツリーに配置する必要があることを示しています。発生します。つまり、式 &lt;code&gt;r&quot;^\s*(?:#|$)&quot;&lt;/code&gt; は、次のオブジェクトを構文ツリーに直接配置することと同じです。</target>
        </trans-unit>
        <trans-unit id="ececc5f47222691560cc9e3bee59dad9b3d640dc" translate="yes" xml:space="preserve">
          <source>The &quot;splat&quot; operator, &lt;code&gt;...&lt;/code&gt;, represents a sequence of arguments. &lt;code&gt;...&lt;/code&gt; can be used in function definitions, to indicate that the function accepts an arbitrary number of arguments. &lt;code&gt;...&lt;/code&gt; can also be used to apply a function to a sequence of arguments.</source>
          <target state="translated">&quot;splat&quot;演算子 &lt;code&gt;...&lt;/code&gt; は、引数のシーケンスを表します。 &lt;code&gt;...&lt;/code&gt; 関数定義で使用して、関数が任意の数の引数を受け入れることを示すことができます。 &lt;code&gt;...&lt;/code&gt; は、引数のシーケンスに関数を適用するためにも使用できます。</target>
        </trans-unit>
        <trans-unit id="6e87b92b09ff210cf587ecb8ad71387d805a3837" translate="yes" xml:space="preserve">
          <source>The 32-bit byte-order-mark indicates the native byte order of the host machine. Little-endian machines will contain the value &lt;code&gt;0x04030201&lt;/code&gt;. Big-endian machines will contain the value &lt;code&gt;0x01020304&lt;/code&gt;.</source>
          <target state="translated">32ビットのバイトオーダーマークは、ホストマシンのネイティブのバイトオーダーを示します。リトルエンディアンマシンには、値 &lt;code&gt;0x04030201&lt;/code&gt; が含まれます。ビッグエンディアンのマシンには、値 &lt;code&gt;0x01020304&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="bc0d418f0a58caa5e7b5119be0993120b5604ac3" translate="yes" xml:space="preserve">
          <source>The 32-bit floating-point literal expression &lt;code&gt;1.5f22&lt;/code&gt; could be interpreted as the numeric literal &lt;code&gt;1.5&lt;/code&gt; multiplied by the variable &lt;code&gt;f22&lt;/code&gt;.</source>
          <target state="translated">32ビット浮動小数点リテラル式 &lt;code&gt;1.5f22&lt;/code&gt; は数値リテラルとして解釈することができた &lt;code&gt;1.5&lt;/code&gt; 変数を乗じ &lt;code&gt;f22&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0554b963c33c05a019079c25e9e8af324781e9db" translate="yes" xml:space="preserve">
          <source>The 5 allocations seen are from running the &lt;code&gt;@time&lt;/code&gt; macro itself in global scope. If we instead run the timing in a function, we can see that indeed no allocations are performed:</source>
          <target state="translated">表示される5つの割り当ては、 &lt;code&gt;@time&lt;/code&gt; マクロ自体をグローバルスコープで実行した場合のものです。代わりに関数でタイミングを実行すると、実際には割り当てが実行されないことがわかります。</target>
        </trans-unit>
        <trans-unit id="7dea49356c38a6636e3d8df6877285b62b149f3f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.CoreLogging.shouldlog&quot;&gt;&lt;code&gt;Logging.shouldlog&lt;/code&gt;&lt;/a&gt; function is called with the current logger, taking some minimal information (level, module, group, id) which can be computed statically. Most usefully, &lt;code&gt;shouldlog&lt;/code&gt; is passed an event &lt;code&gt;id&lt;/code&gt; which can be used to discard events early based on a cached predicate.</source>
          <target state="translated">&lt;a href=&quot;#Base.CoreLogging.shouldlog&quot;&gt; &lt;code&gt;Logging.shouldlog&lt;/code&gt; の&lt;/a&gt;関数を静的に計算することができるいくつかの最小限の情報（レベル、モジュール、グループID）を取って、現在のロガーと呼ばれます。最も便利なのは、 &lt;code&gt;shouldlog&lt;/code&gt; にイベント &lt;code&gt;id&lt;/code&gt; が渡されることです。これを使用して、キャッシュされた述語に基づいてイベントを早期に破棄できます。</target>
        </trans-unit>
        <trans-unit id="9817feb15ee575eea4a8ff720d63067615a333e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; types implements arbitrary-precision floating point and integer arithmetic, respectively. For &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; the &lt;a href=&quot;https://www.mpfr.org/&quot;&gt;GNU MPFR library&lt;/a&gt; is used, and for &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; the &lt;a href=&quot;https://gmplib.org&quot;&gt;GNU Multiple Precision Arithmetic Library (GMP)&lt;/a&gt; is used.</source>
          <target state="translated">&lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;種類の器具はそれぞれ、浮動小数点整数算術演算精度を任意。以下のために&lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://www.mpfr.org/&quot;&gt; GNU MPFRライブラリが&lt;/a&gt;使用されている、とのため&lt;a href=&quot;#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://gmplib.org&quot;&gt; GNU多重精度演算ライブラリ（GMP）が&lt;/a&gt;使用されています。</target>
        </trans-unit>
        <trans-unit id="ad3f2b7adf33af93573e441a9559f7a7900079c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display&lt;/code&gt;&lt;/a&gt; functions ultimately call &lt;code&gt;show&lt;/code&gt; in order to write an object &lt;code&gt;x&lt;/code&gt; as a given &lt;code&gt;mime&lt;/code&gt; type to a given I/O stream &lt;code&gt;io&lt;/code&gt; (usually a memory buffer), if possible. In order to provide a rich multimedia representation of a user-defined type &lt;code&gt;T&lt;/code&gt;, it is only necessary to define a new &lt;code&gt;show&lt;/code&gt; method for &lt;code&gt;T&lt;/code&gt;, via: &lt;code&gt;show(io, ::MIME&quot;mime&quot;, x::T) = ...&lt;/code&gt;, where &lt;code&gt;mime&lt;/code&gt; is a MIME-type string and the function body calls &lt;a href=&quot;#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; (or similar) to write that representation of &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;io&lt;/code&gt;. (Note that the &lt;code&gt;MIME&quot;&quot;&lt;/code&gt; notation only supports literal strings; to construct &lt;code&gt;MIME&lt;/code&gt; types in a more flexible manner use &lt;code&gt;MIME{Symbol(&quot;&quot;)}&lt;/code&gt;.)</source>
          <target state="translated">&lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display&lt;/code&gt; &lt;/a&gt;機能最終的コール &lt;code&gt;show&lt;/code&gt; オブジェクト書き込むために &lt;code&gt;x&lt;/code&gt; 所与として &lt;code&gt;mime&lt;/code&gt; 所与のI / Oストリームにタイプ &lt;code&gt;io&lt;/code&gt; 可能であれば、（通常はメモリバッファ）。ユーザー定義型 &lt;code&gt;T&lt;/code&gt; のリッチマルチメディア表現を提供するために必要なのは、 &lt;code&gt;T&lt;/code&gt; の新しい &lt;code&gt;show&lt;/code&gt; メソッドを定義することだけです。これには、 &lt;code&gt;show(io, ::MIME&quot;mime&quot;, x::T) = ...&lt;/code&gt; ここで、 &lt;code&gt;mime&lt;/code&gt; MIME型の文字列であり、関数本体は、コール&lt;a href=&quot;#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;の表現書き込むこと（または類似の）を &lt;code&gt;x&lt;/code&gt; とし &lt;code&gt;io&lt;/code&gt; 。 （ &lt;code&gt;MIME&quot;&quot;&lt;/code&gt; 注意してください&quot;&quot;表記はリテラル文字列のみをサポートします。より柔軟な方法で &lt;code&gt;MIME&lt;/code&gt; タイプを構築するには、 &lt;code&gt;MIME{Symbol(&quot;&quot;)}&lt;/code&gt; ます。）</target>
        </trans-unit>
        <trans-unit id="5436a7d5a656260665ad063d5ab1e6eff72c987d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Base.Rounding.RoundingMode&quot;&gt;&lt;code&gt;RoundingMode&lt;/code&gt;&lt;/a&gt;&lt;code&gt;r&lt;/code&gt; controls the direction of the rounding; the default is &lt;a href=&quot;#Base.Rounding.RoundNearest&quot;&gt;&lt;code&gt;RoundNearest&lt;/code&gt;&lt;/a&gt;, which rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer. Note that &lt;code&gt;round&lt;/code&gt; may give incorrect results if the global rounding mode is changed (see &lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt;&lt;code&gt;rounding&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#Base.Rounding.RoundingMode&quot;&gt; &lt;code&gt;RoundingMode&lt;/code&gt; の&lt;/a&gt; &lt;code&gt;r&lt;/code&gt; 丸めの方向を制御します。デフォルトは&lt;a href=&quot;#Base.Rounding.RoundNearest&quot;&gt; &lt;code&gt;RoundNearest&lt;/code&gt; で&lt;/a&gt;、これは最も近い整数に丸められ、Ties（0.5の小数値）は最も近い偶数の整数に丸められます。グローバル丸めモードが変更された場合、 &lt;code&gt;round&lt;/code&gt; は誤った結果をもたらす可能性があることに注意してください（&lt;a href=&quot;../numbers/index#Base.Rounding.rounding&quot;&gt; &lt;code&gt;rounding&lt;/code&gt; を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="36e18d121f5a838cc6709524d85e5f444560cd8e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Dates.dayname&quot;&gt;&lt;code&gt;dayname&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.monthname&quot;&gt;&lt;code&gt;monthname&lt;/code&gt;&lt;/a&gt; methods can also take an optional &lt;code&gt;locale&lt;/code&gt; keyword that can be used to return the name of the day or month of the year for other languages/locales. There are also versions of these functions returning the abbreviated names, namely &lt;a href=&quot;#Dates.dayabbr&quot;&gt;&lt;code&gt;dayabbr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.monthabbr&quot;&gt;&lt;code&gt;monthabbr&lt;/code&gt;&lt;/a&gt;. First the mapping is loaded into the &lt;code&gt;LOCALES&lt;/code&gt; variable:</source>
          <target state="translated">&lt;a href=&quot;#Dates.dayname&quot;&gt; &lt;code&gt;dayname&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#Dates.monthname&quot;&gt; &lt;code&gt;monthname&lt;/code&gt; &lt;/a&gt;方法も取ることができ、オプションの &lt;code&gt;locale&lt;/code&gt; のキーワード他の言語/ロケールの年の日または月の名前を返すために使用することができます。これらの関数には、省略名、つまり&lt;a href=&quot;#Dates.dayabbr&quot;&gt; &lt;code&gt;dayabbr&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#Dates.monthabbr&quot;&gt; &lt;code&gt;monthabbr&lt;/code&gt; を&lt;/a&gt;返すバージョンもあります。最初に、マッピングが &lt;code&gt;LOCALES&lt;/code&gt; 変数に読み込まれます。</target>
        </trans-unit>
        <trans-unit id="b0ea31c9b36eaba5425ec694eab3ed041d8c9eef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Logging.Logging&quot;&gt;&lt;code&gt;Logging&lt;/code&gt;&lt;/a&gt; module provides a way to record the history and progress of a computation as a log of events. Events are created by inserting a logging statement into the source code, for example:</source>
          <target state="translated">&lt;a href=&quot;#Logging.Logging&quot;&gt; &lt;code&gt;Logging&lt;/code&gt; &lt;/a&gt;モジュールは、イベントのログとして計算の歴史と進歩を記録する方法を提供します。イベントは、ログステートメントをソースコードに挿入することで作成されます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="3b0d2cdace4e12d15a4692bf023ef78f32612455" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#Rounding-functions-1&quot;&gt;Rounding functions&lt;/a&gt; take a type &lt;code&gt;T&lt;/code&gt; as an optional argument. For example, &lt;code&gt;round(Int,x)&lt;/code&gt; is a shorthand for &lt;code&gt;Int(round(x))&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Rounding-functions-1&quot;&gt;丸め関数は、&lt;/a&gt;型取り &lt;code&gt;T&lt;/code&gt; をオプションの引数として。たとえば、 &lt;code&gt;round(Int,x)&lt;/code&gt; は &lt;code&gt;Int(round(x))&lt;/code&gt; の省略形です。</target>
        </trans-unit>
        <trans-unit id="5eb87235a3e582308fdae141ff9f8e2932202086" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; function is often a handy way to construct sparse arrays. For example, to construct a sparse matrix we can input a vector &lt;code&gt;I&lt;/code&gt; of row indices, a vector &lt;code&gt;J&lt;/code&gt; of column indices, and a vector &lt;code&gt;V&lt;/code&gt; of stored values (this is also known as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29&quot;&gt;COO (coordinate) format&lt;/a&gt;). &lt;code&gt;sparse(I,J,V)&lt;/code&gt; then constructs a sparse matrix such that &lt;code&gt;S[I[k], J[k]] = V[k]&lt;/code&gt;. The equivalent sparse vector constructor is &lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt;&lt;code&gt;sparsevec&lt;/code&gt;&lt;/a&gt;, which takes the (row) index vector &lt;code&gt;I&lt;/code&gt; and the vector &lt;code&gt;V&lt;/code&gt; with the stored values and constructs a sparse vector &lt;code&gt;R&lt;/code&gt; such that &lt;code&gt;R[I[k]] = V[k]&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt;機能は、多くの場合、スパース配列を構築するための便利な方法です。たとえば、スパース行列を作成する &lt;code&gt;I&lt;/code&gt; は、行インデックスのベクトルI、列インデックスのベクトル &lt;code&gt;J&lt;/code&gt; 、および格納された値のベクトル &lt;code&gt;V&lt;/code&gt; （これは&lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Coordinate_list_.28COO.29&quot;&gt;COO（座標）形式&lt;/a&gt;とも呼ばれます）を入力できます。 &lt;code&gt;sparse(I,J,V)&lt;/code&gt; 、次に &lt;code&gt;S[I[k], J[k]] = V[k]&lt;/code&gt; ようなスパース行列を作成します。同等のスパースベクトルコンストラクターは&lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt; &lt;code&gt;sparsevec&lt;/code&gt; です&lt;/a&gt;。これは、（行）インデックスベクトル &lt;code&gt;I&lt;/code&gt; とベクトル &lt;code&gt;V&lt;/code&gt; を格納された値で受け取り、 &lt;code&gt;R[I[k]] = V[k]&lt;/code&gt; ようなスパースベクトル &lt;code&gt;R&lt;/code&gt; を構築します。</target>
        </trans-unit>
        <trans-unit id="1ce4dd4aa2504c940aa48ceeab07c53ca96b6449" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt;&lt;code&gt;@eval&lt;/code&gt;&lt;/a&gt; macro rewrites this call to be precisely equivalent to the above longer versions. For longer blocks of generated code, the expression argument given to &lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt;&lt;code&gt;@eval&lt;/code&gt;&lt;/a&gt; can be a block:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt; &lt;code&gt;@eval&lt;/code&gt; &lt;/a&gt;マクロは、上記長いバージョンと正確に同等であることがこの呼び出しを書き換えます。生成されたコードのより長いブロックの場合、&lt;a href=&quot;../../base/base/index#Base.@eval&quot;&gt; &lt;code&gt;@eval&lt;/code&gt; &lt;/a&gt;与えられる式の引数はブロックになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="38ef0a3b168bd74d25880aec3b78cf19271d94b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.Enums.@enum&quot;&gt;&lt;code&gt;@enum&lt;/code&gt;&lt;/a&gt; macro makes use of &lt;code&gt;@__doc__&lt;/code&gt; to allow for documenting &lt;a href=&quot;../../base/base/index#Base.Enums.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;s. Examining its definition should serve as an example of how to use &lt;code&gt;@__doc__&lt;/code&gt; correctly.</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.Enums.@enum&quot;&gt; &lt;code&gt;@enum&lt;/code&gt; の&lt;/a&gt;マクロが使用可能 &lt;code&gt;@__doc__&lt;/code&gt; 文書化を可能にするために、&lt;a href=&quot;../../base/base/index#Base.Enums.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt;秒。その定義を調べることは、 &lt;code&gt;@__doc__&lt;/code&gt; 正しく使用する方法の例として役立つはずです。</target>
        </trans-unit>
        <trans-unit id="acfadefe2bb6121d5e848cbd0b9afe7e8768d52d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; function is used to produce an &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt; that interrupts the normal flow of control.</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.error&quot;&gt; &lt;code&gt;error&lt;/code&gt; &lt;/a&gt;関数が生成するために使用される&lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; &lt;/a&gt;制御の通常の流れを遮断します。</target>
        </trans-unit>
        <trans-unit id="fd385b6cfaa8837c37589622c3c706028ad36f1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.isless&quot;&gt;&lt;code&gt;isless&lt;/code&gt;&lt;/a&gt; operator is another exception: &lt;code&gt;missing&lt;/code&gt; is considered as greater than any other value. This operator is used by &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;, which therefore places &lt;code&gt;missing&lt;/code&gt; values after all other values.</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.isless&quot;&gt; &lt;code&gt;isless&lt;/code&gt; &lt;/a&gt;オペレータは、別の例外です： &lt;code&gt;missing&lt;/code&gt; 他の値よりも大きいと考えられています。この演算子は&lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;によって使用されるため、 &lt;code&gt;missing&lt;/code&gt; 値は他のすべての値の後に配置されます。</target>
        </trans-unit>
        <trans-unit id="4d17e67e8157d57768d314d2878bcbffb2b8fe95" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax&lt;/code&gt;&lt;/a&gt; functions also apply to floating-point types:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax&lt;/code&gt; &lt;/a&gt;機能は、浮動小数点型に適用されます。</target>
        </trans-unit>
        <trans-unit id="de73ba08a71f852e7d2733fa6dfed62a7f72340d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; function confirms that the &quot;two&quot; constructed instances of &lt;code&gt;NoFields&lt;/code&gt; are actually one and the same. Singleton types are described in further detail &lt;a href=&quot;#man-singleton-types-1&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt;の「2」構築のインスタンスという機能を確認 &lt;code&gt;NoFields&lt;/code&gt; は、実際には1と同じです。シングルトンタイプについては、&lt;a href=&quot;#man-singleton-types-1&quot;&gt;以下で&lt;/a&gt;詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="d77ec66ab2077f795aecb0927e53656b9c9cc945" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; constructor takes any number of arguments and creates a new symbol by concatenating their string representations together:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt;コンストラクタは、任意の数の引数を取り、一緒にその文字列表現を連結することによって、新しいシンボルを作成します。</target>
        </trans-unit>
        <trans-unit id="414514dfacecedf70ecbd06d5fef52f6a37552e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt;&lt;code&gt;isa&lt;/code&gt;&lt;/a&gt; function tests if an object is of a given type and returns true or false:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt; &lt;code&gt;isa&lt;/code&gt; &lt;/a&gt;オブジェクトが指定されたタイプであり、trueまたはfalseを返す場合、機能テスト：</target>
        </trans-unit>
        <trans-unit id="bf1b3d1c04844d76b7ef3cb166b81958a1f65c08" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; function</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt;機能</target>
        </trans-unit>
        <trans-unit id="b96dfc29471c7f4e7faf38271fb34f184e922afa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#Core.typeof&quot;&gt;&lt;code&gt;typeof&lt;/code&gt;&lt;/a&gt; function, already used throughout the manual in examples, returns the type of its argument. Since, as noted above, types are objects, they also have types, and we can ask what their types are:</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Core.typeof&quot;&gt; &lt;code&gt;typeof&lt;/code&gt; 演算を&lt;/a&gt;既に実施例でマニュアルで使用される関数は、その引数の型を返します。上記のように、タイプはオブジェクトなので、タイプもあり、タイプを尋ねることができます。</target>
        </trans-unit>
        <trans-unit id="0d827a86b6df88cc411d1f3d30cdcddabf2bc33a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/base/index#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; keyword supports the same syntax as &lt;a href=&quot;../../base/base/index#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt;, but only operates on a single name at a time. It does not add modules to be searched the way &lt;code&gt;using&lt;/code&gt; does. &lt;code&gt;import&lt;/code&gt; also differs from &lt;code&gt;using&lt;/code&gt; in that functions imported using &lt;code&gt;import&lt;/code&gt; can be extended with new methods.</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;キーワードは、同じ構文をサポートして&lt;a href=&quot;../../base/base/index#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt;ますが、一度に単一の名前で動作します。 &lt;code&gt;using&lt;/code&gt; する方法で検索されるモジュールを追加しません。 &lt;code&gt;import&lt;/code&gt; は、インポートを使用して &lt;code&gt;import&lt;/code&gt; された関数を新しいメソッドで拡張できるという点でも、 &lt;code&gt;using&lt;/code&gt; とは異なります。</target>
        </trans-unit>
        <trans-unit id="ec874bb7238b430b76f31f6a2f70602d5cd36c3f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/c/index#Base.Cstring&quot;&gt;&lt;code&gt;Cstring&lt;/code&gt;&lt;/a&gt; type is essentially a synonym for &lt;code&gt;Ptr{UInt8}&lt;/code&gt;, except the conversion to &lt;code&gt;Cstring&lt;/code&gt; throws an error if the Julia string contains any embedded NUL characters (which would cause the string to be silently truncated if the C routine treats NUL as the terminator). If you are passing a &lt;code&gt;char*&lt;/code&gt; to a C routine that does not assume NUL termination (e.g. because you pass an explicit string length), or if you know for certain that your Julia string does not contain NUL and want to skip the check, you can use &lt;code&gt;Ptr{UInt8}&lt;/code&gt; as the argument type. &lt;code&gt;Cstring&lt;/code&gt; can also be used as the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; return type, but in that case it obviously does not introduce any extra checks and is only meant to improve readability of the call.</source>
          <target state="translated">&lt;a href=&quot;../../base/c/index#Base.Cstring&quot;&gt; &lt;code&gt;Cstring&lt;/code&gt; &lt;/a&gt;タイプは、本質的に同義である &lt;code&gt;Ptr{UInt8}&lt;/code&gt; への変換を除き、 &lt;code&gt;Cstring&lt;/code&gt; ジュリア列が（Cルーチン扱いターミネーターとしてNUL場合列がサイレントトランケートさせるであろう）は、任意の埋め込みNUL文字を含む場合はエラーをスロー。あなたは合格している場合は &lt;code&gt;char*&lt;/code&gt; NUL終端を想定していないCルーチンに（明示的な文字列の長さを渡す例えばので）、またはあなたのジュリア文字列が、あなたをNULが含まれているし、チェックをスキップしたくないことを確かに知っていれば引数の型として &lt;code&gt;Ptr{UInt8}&lt;/code&gt; を使用できます。 &lt;code&gt;Cstring&lt;/code&gt; は&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;としても使用できます 戻り値の型ですが、その場合、追加のチェックは明らかに導入されず、呼び出しの可読性を向上させることのみを目的としています。</target>
        </trans-unit>
        <trans-unit id="3fe5df294c64ae2bc17b6c645704bd7bc62ca16b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;Base.filter&lt;/code&gt;&lt;/a&gt; method can be used to obtain all valid dates/moments in a specified range:</source>
          <target state="translated">&lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;Base.filter&lt;/code&gt; の&lt;/a&gt;メソッドは、指定された範囲内のすべての有効な日付/瞬間を得るために使用することができます。</target>
        </trans-unit>
        <trans-unit id="32116ae8c0495cf49f4c9c66e837a3e4255f5c44" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/io-network/index#Base.dump&quot;&gt;&lt;code&gt;dump&lt;/code&gt;&lt;/a&gt; function provides indented and annotated display of &lt;code&gt;Expr&lt;/code&gt; objects:</source>
          <target state="translated">&lt;a href=&quot;../../base/io-network/index#Base.dump&quot;&gt; &lt;code&gt;dump&lt;/code&gt; &lt;/a&gt;機能はのインデントと注釈を付けディスプレイ提供 &lt;code&gt;Expr&lt;/code&gt; オブジェクトを：</target>
        </trans-unit>
        <trans-unit id="63e3ea8e88f5b981ca22a0c9f75818db8e88281d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/multi-threading/index#Base.@threadcall&quot;&gt;&lt;code&gt;@threadcall&lt;/code&gt;&lt;/a&gt; macro addresses scenarios where we do not want a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to block the main Julia event loop. It schedules a C function for execution in a separate thread. A threadpool with a default size of 4 is used for this. The size of the threadpool is controlled via environment variable &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt;. While waiting for a free thread, and during function execution once a thread is available, the requesting task (on the main Julia event loop) yields to other tasks. Note that &lt;code&gt;@threadcall&lt;/code&gt; does not return till the execution is complete. From a user point of view, it is therefore a blocking call like other Julia APIs.</source>
          <target state="translated">&lt;a href=&quot;../../base/multi-threading/index#Base.@threadcall&quot;&gt; &lt;code&gt;@threadcall&lt;/code&gt; &lt;/a&gt;我々は望んでいないマクロアドレスシナリオ&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; が&lt;/a&gt;メインジュリアのイベントループを遮断するために。別のスレッドで実行するC関数をスケジュールします。これには、デフォルトのサイズが4のスレッドプールが使用されます。 &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt; プールのサイズは、環境変数UV_THREADPOOL_SIZEによって制御されます。フリースレッドを待機している間、および関数の実行中にスレッドが利用可能になると、（メインのJuliaイベントループで）要求しているタスクが他のタスクに譲ります。注意 &lt;code&gt;@threadcall&lt;/code&gt; は、実行が完了するまで戻りません。したがって、ユーザーの観点からは、他のJulia APIと同様にブロッキング呼び出しになります。</target>
        </trans-unit>
        <trans-unit id="9980cd05996241c9e77ece29af3cb2e812c97a73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt; type is a direct child type of &lt;code&gt;Any&lt;/code&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; is its child. In turn, &lt;code&gt;Real&lt;/code&gt; has two children (it has more, but only two are shown here; we'll get to the others later): &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.AbstractFloat&quot;&gt;&lt;code&gt;AbstractFloat&lt;/code&gt;&lt;/a&gt;, separating the world into representations of integers and representations of real numbers. Representations of real numbers include, of course, floating-point types, but also include other types, such as rationals. Hence, &lt;code&gt;AbstractFloat&lt;/code&gt; is a proper subtype of &lt;code&gt;Real&lt;/code&gt;, including only floating-point representations of real numbers. Integers are further subdivided into &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt;&lt;code&gt;Signed&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt;&lt;code&gt;Unsigned&lt;/code&gt;&lt;/a&gt; varieties.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; &lt;/a&gt;タイプは、直接の子タイプで &lt;code&gt;Any&lt;/code&gt; 、そして&lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;その子です。次に、 &lt;code&gt;Real&lt;/code&gt; には2つの子があります（2つしかありませんが、ここでは2つしか表示されていません。後で他の子に移動します）：&lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/numbers/index#Core.AbstractFloat&quot;&gt; &lt;code&gt;AbstractFloat&lt;/code&gt; は&lt;/a&gt;、整数の表現と実数の表現に世界を分離します。実数の表現にはもちろん浮動小数点型が含まれますが、有理数などの他の型も含まれます。したがって、 &lt;code&gt;AbstractFloat&lt;/code&gt; は &lt;code&gt;Real&lt;/code&gt; の適切なサブタイプであり、実数の浮動小数点表現のみを含みます。整数はさらに&lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt; &lt;code&gt;Unsigned&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt; &lt;code&gt;Signed&lt;/code&gt; &lt;/a&gt;と符号なしに分けられます 品種。</target>
        </trans-unit>
        <trans-unit id="a61c350b843f41f66bd6a94fb06646bf09f7c269" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; method is called asynchronously in a separate task. The termination of this task signals that all requested workers have been launched. Hence the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; function MUST exit as soon as all the requested workers have been launched.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt;方法は、別のタスクで非同期と呼ばれています。このタスクの終了は、要求されたすべてのワーカーが起動されたことを示します。したがって、要求されたすべてのワーカーが起動されるとすぐに、&lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt;関数が終了する必要があります。</target>
        </trans-unit>
        <trans-unit id="e5928b30867a053dbff6206d1bc20c56f14e738b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; method takes the following arguments:</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt;方法は、以下の引数を取ります。</target>
        </trans-unit>
        <trans-unit id="7b33ac485b0a3f8ebfda5064c9e3efc2a8bcfdcf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;literal numeric coefficient notation&lt;/a&gt; does not work when constructing a complex number from variables. Instead, the multiplication must be explicitly written out:</source>
          <target state="translated">&lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;リテラル数値係数の表記は、&lt;/a&gt;変数から複素数を構築するときに動作しません。代わりに、乗算を明示的に書き出す必要があります。</target>
        </trans-unit>
        <trans-unit id="275af0000e44bc521cd56c3026533fc5cd78a5de" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../strings/index#man-concatenation-1&quot;&gt;main argument&lt;/a&gt; against &lt;code&gt;+&lt;/code&gt; is that string concatenation is not commutative, while &lt;code&gt;+&lt;/code&gt; is generally used as a commutative operator. While the Julia community recognizes that other languages use different operators and &lt;code&gt;*&lt;/code&gt; may be unfamiliar for some users, it communicates certain algebraic properties.</source>
          <target state="translated">&lt;a href=&quot;../strings/index#man-concatenation-1&quot;&gt;メイン引数&lt;/a&gt;に対して &lt;code&gt;+&lt;/code&gt; はながら、文字列の連結は、可換ではないということである &lt;code&gt;+&lt;/code&gt; は一般可換演算子として使用されます。Juliaコミュニティは、他の言語が異なる演算子を使用し、一部のユーザーにとって &lt;code&gt;*&lt;/code&gt; に慣れていない場合があることを認識していますが、特定の代数的特性を伝えています。</target>
        </trans-unit>
        <trans-unit id="c14035985c996abe00f4042cc746b4176aab2201" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/JuliaData/DataFrames.jl&quot;&gt;DataFrames package&lt;/a&gt; provides data frames.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/JuliaData/DataFrames.jl&quot;&gt;データフレームパッケージには、&lt;/a&gt;データフレームを提供します。</target>
        </trans-unit>
        <trans-unit id="e3ebf2c6b9c4eb22391edbc55310df1678b26195" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/MikeInnes/Traceur.jl&quot;&gt;Traceur&lt;/a&gt; package can help you find common performance problems in your code.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/MikeInnes/Traceur.jl&quot;&gt;Traceurの&lt;/a&gt;パッケージには、あなたのコードで一般的なパフォーマンスの問題を見つけることができます。</target>
        </trans-unit>
        <trans-unit id="09270743df4b19bd666f57937fe0296a7b3d369a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.gnu.org/software/gsl/&quot;&gt;GNU Scientific Library&lt;/a&gt; (here assumed to be accessible through &lt;code&gt;:libgsl&lt;/code&gt;) defines an opaque pointer, &lt;code&gt;gsl_permutation *&lt;/code&gt;, as the return type of the C function &lt;code&gt;gsl_permutation_alloc&lt;/code&gt;. As user code never has to look inside the &lt;code&gt;gsl_permutation&lt;/code&gt; struct, the corresponding Julia wrapper simply needs a new type declaration, &lt;code&gt;gsl_permutation&lt;/code&gt;, that has no internal fields and whose sole purpose is to be placed in the type parameter of a &lt;code&gt;Ptr&lt;/code&gt; type. The return type of the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; is declared as &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, since the memory allocated and pointed to by &lt;code&gt;output_ptr&lt;/code&gt; is controlled by C (and not Julia).</source>
          <target state="translated">&lt;a href=&quot;https://www.gnu.org/software/gsl/&quot;&gt;GNU科学的ライブラリ&lt;/a&gt;（ここを介してアクセス可能であると仮定する &lt;code&gt;:libgsl&lt;/code&gt; ）不透明ポインタ、定義 &lt;code&gt;gsl_permutation *&lt;/code&gt; を C関数の戻り型として、 &lt;code&gt;gsl_permutation_alloc&lt;/code&gt; 。ユーザーコードは &lt;code&gt;gsl_permutation&lt;/code&gt; 構造体の内部を調べる必要がないため、対応するJuliaラッパーは、内部フィールドを持たず、その唯一の目的が &lt;code&gt;Ptr&lt;/code&gt; 型の型パラメーターに配置される新しい型宣言 &lt;code&gt;gsl_permutation&lt;/code&gt; を必要とします。&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;の戻り値の型は &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt; として宣言されます。これは、output_ptrによってメモリが割り当てられ、ポイントされるため &lt;code&gt;output_ptr&lt;/code&gt; （Juliaではなく）Cによって制御されます。</target>
        </trans-unit>
        <trans-unit id="72ea3eda7ce888d73eff517a4ef953491525adf7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; syntax is deprecated, use the &lt;code&gt;Ref{T}&lt;/code&gt; argument type instead.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; 構文は廃止され、使用 &lt;code&gt;Ref{T}&lt;/code&gt; 代わりに引数の型を。</target>
        </trans-unit>
        <trans-unit id="ff8eac00092307ddc7d1e59e50812b91cc8012ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;:&lt;/code&gt; operator in general means &quot;is a subtype of&quot;, and, used in declarations like this, declares the right-hand type to be an immediate supertype of the newly declared type. It can also be used in expressions as a subtype operator which returns &lt;code&gt;true&lt;/code&gt; when its left operand is a subtype of its right operand:</source>
          <target state="translated">&lt;code&gt;&amp;lt;:&lt;/code&gt; 一般的な手段でオペレータは「のサブタイプである」、そして、このような宣言で使用され、右側のタイプが新たに宣言された型の直接のスーパータイプであることを宣言します。左のオペランドが右のオペランドのサブタイプで &lt;code&gt;true&lt;/code&gt; 場合にtrueを返すサブタイプ演算子として式で使用することもできます。</target>
        </trans-unit>
        <trans-unit id="462f03c3cade5b2449ca60ca2d04cc3130736218" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; delimiter can be used to separate command-line arguments intended for the script file from arguments intended for Julia:</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; 区切り文字は、ジュリアのために意図された引数からスクリプトファイルを対象とし、別のコマンドライン引数に使用することができます。</target>
        </trans-unit>
        <trans-unit id="396147a6b9dfacff46d28874aadee188884bc052" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;2x + y&lt;/code&gt; definition is only used in the first case, while the &lt;code&gt;2x - y&lt;/code&gt; definition is used in the others. No automatic casting or conversion of function arguments is ever performed: all conversion in Julia is non-magical and completely explicit. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt;, however, shows how clever application of sufficiently advanced technology can be indistinguishable from magic. &lt;a href=&quot;#footnote-Clarke61&quot;&gt;[Clarke61]&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;2x + y&lt;/code&gt; ながら定義は、最初の場合にのみ使用され &lt;code&gt;2x - y&lt;/code&gt; 定義は、他で使用されています。関数の引数の自動キャストや変換は実行されません。ジュリアでのすべての変換は魔法ではなく、完全に明示的です。ただし、&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt;は、十分に高度なテクノロジーの賢い適用が魔法と区別がつかない場合があることを示しています。&lt;a href=&quot;#footnote-Clarke61&quot;&gt;[Clarke61]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="702c47148e007cd263dc6deb6727c14f26afb82e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;::&lt;/code&gt; operator can be used to attach type annotations to expressions and variables in programs. There are two primary reasons to do this:</source>
          <target state="translated">&lt;code&gt;::&lt;/code&gt; 演算子はプログラムで表現し、変数に型注釈を付けるために使用することができます。これを行う主な理由は2つあります。</target>
        </trans-unit>
        <trans-unit id="a4ee1c478f2612aec54bd174690fa6ea35ddb91f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:&lt;/code&gt; character has two syntactic purposes in Julia. The first form creates a &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;, an &lt;a href=&quot;https://en.wikipedia.org/wiki/String_interning&quot;&gt;interned string&lt;/a&gt; used as one building-block of expressions:</source>
          <target state="translated">&lt;code&gt;:&lt;/code&gt; 文字がジュリアに2つの構文的な目的を持っています。最初のフォームが作成&lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;https://en.wikipedia.org/wiki/String_interning&quot;&gt;インターン文字列&lt;/a&gt;表現の一ビルディングブロックとして使用します。</target>
        </trans-unit>
        <trans-unit id="48c311a5c224de0110d74a449183e9149c5a0fa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@assert&lt;/code&gt; macro makes great use of splicing into quoted expressions to simplify the manipulation of expressions inside the macro body.</source>
          <target state="translated">&lt;code&gt;@assert&lt;/code&gt; マクロは、マクロ本体内の式の操作を簡素化するために引用された表現へのスプライシングの偉大な使用しています。</target>
        </trans-unit>
        <trans-unit id="801ed9019f04c0f8f529dacee5be7631d5e276fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@boundscheck&lt;/code&gt; annotation allows you, as a library writer, to opt-in to allowing &lt;em&gt;other code&lt;/em&gt; to remove your bounds checks with &lt;a href=&quot;#Base.@inbounds&quot;&gt;&lt;code&gt;@inbounds&lt;/code&gt;&lt;/a&gt;. As noted there, the caller must verify&amp;mdash;using information they can access&amp;mdash;that their accesses are valid before using &lt;code&gt;@inbounds&lt;/code&gt;. For indexing into your &lt;a href=&quot;../arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt; subclasses, for example, this involves checking the indices against its &lt;a href=&quot;../arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;. Therefore, &lt;code&gt;@boundscheck&lt;/code&gt; annotations should only be added to a &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt; implementation after you are certain its behavior is correct.</source>
          <target state="translated">&lt;code&gt;@boundscheck&lt;/code&gt; の注釈は、あなたがオプトインできるように、ライブラリー作家として、可能にする&lt;em&gt;他のコード&lt;/em&gt;を使用して境界チェックを削除する&lt;a href=&quot;#Base.@inbounds&quot;&gt; &lt;code&gt;@inbounds&lt;/code&gt; を&lt;/a&gt;。そこに記載されているように、呼び出し元は、 &lt;code&gt;@inbounds&lt;/code&gt; を使用する前に、アクセスできる情報を使用して、アクセスが有効であることを確認する必要があります。たとえば、&lt;a href=&quot;../arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt;サブクラスにインデックスを付ける場合、これには、&lt;a href=&quot;../arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt;に対するインデックスのチェックが含まれます。したがって、 &lt;code&gt;@boundscheck&lt;/code&gt; アノテーションは&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;またはsetindexにのみ追加する必要があります&lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;動作が正しいことを確認した後の実装。</target>
        </trans-unit>
        <trans-unit id="8d04719fe4369bb879f4c27763dea9901ff5736f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@doc&lt;/code&gt; macro associates its first argument with its second in a per-module dictionary called &lt;code&gt;META&lt;/code&gt;. By default, documentation is expected to be written in Markdown, and the &lt;code&gt;doc&quot;&quot;&lt;/code&gt; string macro simply creates an object representing the Markdown content. In the future it is likely to do more advanced things such as allowing for relative image or link paths.</source>
          <target state="translated">&lt;code&gt;@doc&lt;/code&gt; のマクロと呼ばれるモジュールごとの辞書にその第二との最初の引数を関連付け &lt;code&gt;META&lt;/code&gt; 。デフォルトでは、ドキュメントはMarkdownで記述されることが想定されており、 &lt;code&gt;doc&quot;&quot;&lt;/code&gt; 文字列マクロはMarkdownコンテンツを表すオブジェクトを作成するだけです。将来的には、相対的な画像やリンクのパスを許可するなど、より高度なことを行う可能性があります。</target>
        </trans-unit>
        <trans-unit id="3901521653150d23278fa27f787a9dbcf11d8111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@simd&lt;/code&gt; does not assert by default that the loop is completely free of loop-carried memory dependencies, which is an assumption that can easily be violated in generic code. If you are writing non-generic code, you can use &lt;code&gt;@simd ivdep for ... end&lt;/code&gt; to also assert that:</source>
          <target state="translated">&lt;code&gt;@simd&lt;/code&gt; はループが簡単に汎用コードに違反することができます仮定であるループ運搬のメモリー依存関係の完全に自由であることをデフォルトでアサートされません。一般的でないコードを記述している場合は、 &lt;code&gt;@simd ivdep for ... end&lt;/code&gt; を使用して、次のことも表明できます。</target>
        </trans-unit>
        <trans-unit id="22755b36a58e8494f0fc686a468ea1d881c82d08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@test f(args...) key=val...&lt;/code&gt; form is equivalent to writing &lt;code&gt;@test f(args..., key=val...)&lt;/code&gt; which can be useful when the expression is a call using infix syntax such as approximate comparisons:</source>
          <target state="translated">&lt;code&gt;@test f(args...) key=val...&lt;/code&gt; フォームが書き込みに相当する &lt;code&gt;@test f(args..., key=val...)&lt;/code&gt; 式は中置構文を使用してコールされた場合に有用であり得ますおおよその比較など：</target>
        </trans-unit>
        <trans-unit id="16c63b805f73cc977b60037a10997e30bb4b9947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@test_broken f(args...) key=val...&lt;/code&gt; form works as for the &lt;code&gt;@test&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;@test_broken f(args...) key=val...&lt;/code&gt; 形態は用として機能 &lt;code&gt;@test&lt;/code&gt; マクロ。</target>
        </trans-unit>
        <trans-unit id="abdc5ad65294f55eba9140a8f0b4f4933db8d022" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@test_skip f(args...) key=val...&lt;/code&gt; form works as for the &lt;code&gt;@test&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;@test_skip f(args...) key=val...&lt;/code&gt; 形態は用として機能 &lt;code&gt;@test&lt;/code&gt; マクロ。</target>
        </trans-unit>
        <trans-unit id="8d32bc610a43028740032f0894a8d5b65d4647e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@testset&lt;/code&gt; macro can be used to group tests into &lt;em&gt;sets&lt;/em&gt;. All the tests in a test set will be run, and at the end of the test set a summary will be printed. If any of the tests failed, or could not be evaluated due to an error, the test set will then throw a &lt;code&gt;TestSetException&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@testset&lt;/code&gt; のマクロは、グループ内のテストに使用することができる&lt;em&gt;セット&lt;/em&gt;。テストセット内のすべてのテストが実行され、テストセットの最後に概要が出力されます。いずれかのテストが失敗した場合、またはエラーが原因で評価できなかった場合、テストセットは &lt;code&gt;TestSetException&lt;/code&gt; をスローします。</target>
        </trans-unit>
        <trans-unit id="6e1109eb4b0b82fe1adad014b7f4cf1b1315fb09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@threadcall&lt;/code&gt; macro is called in the same way as &lt;a href=&quot;../c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; but does the work in a different thread. This is useful when you want to call a blocking C function without causing the main &lt;code&gt;julia&lt;/code&gt; thread to become blocked. Concurrency is limited by size of the libuv thread pool, which defaults to 4 threads but can be increased by setting the &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt; environment variable and restarting the &lt;code&gt;julia&lt;/code&gt; process.</source>
          <target state="translated">&lt;code&gt;@threadcall&lt;/code&gt; のマクロは、同じように呼ばれている&lt;a href=&quot;../c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;が、別のスレッドで作業を行います。これは、メインの &lt;code&gt;julia&lt;/code&gt; スレッドをブロックせずに、ブロッキングC関数を呼び出したい場合に役立ちます。同時実行は、4つのスレッドをデフォルトlibuvスレッドプールのサイズによって制限されますが、設定することによって増大させることができる &lt;code&gt;UV_THREADPOOL_SIZE&lt;/code&gt; の環境変数を再起動すると、 &lt;code&gt;julia&lt;/code&gt; プロセスを。</target>
        </trans-unit>
        <trans-unit id="be390301ffbdbbfe0c2a21aa488c727a5bb08d3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@threads&lt;/code&gt; Macro</source>
          <target state="translated">&lt;code&gt;@threads&lt;/code&gt; マクロ</target>
        </trans-unit>
        <trans-unit id="3926862dd6a57d44f61884e7fbb13c9a98fc27be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@views&lt;/code&gt; macro only affects &lt;code&gt;array[...]&lt;/code&gt; expressions that appear explicitly in the given &lt;code&gt;expression&lt;/code&gt;, not array slicing that occurs in functions called by that code.</source>
          <target state="translated">&lt;code&gt;@views&lt;/code&gt; のマクロのみ影響を及ぼす &lt;code&gt;array[...]&lt;/code&gt; 所与の中で明示的に表示される式 &lt;code&gt;expression&lt;/code&gt; 、そのコードによって呼び出される関数で発生しない配列スライス。</target>
        </trans-unit>
        <trans-unit id="f1624bacdb2ea72aa9e204c460f79dbfffe8ac6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AbstractArray&lt;/code&gt; type includes anything vaguely array-like, and implementations of it might be quite different from conventional arrays. For example, elements might be computed on request rather than stored. However, any concrete &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; type should generally implement at least &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size(A)&lt;/code&gt;&lt;/a&gt; (returning an &lt;code&gt;Int&lt;/code&gt; tuple), &lt;code&gt;getindex(A,i)&lt;/code&gt; and &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex(A,i1,...,iN)&lt;/code&gt;&lt;/a&gt;; mutable arrays should also implement &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;. It is recommended that these operations have nearly constant time complexity, or technically &amp;Otilde;(1) complexity, as otherwise some array functions may be unexpectedly slow. Concrete types should also typically provide a &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar(A,T=eltype(A),dims=size(A))&lt;/code&gt;&lt;/a&gt; method, which is used to allocate a similar array for &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; and other out-of-place operations. No matter how an &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; is represented internally, &lt;code&gt;T&lt;/code&gt; is the type of object returned by &lt;em&gt;integer&lt;/em&gt; indexing (&lt;code&gt;A[1, ..., 1]&lt;/code&gt;, when &lt;code&gt;A&lt;/code&gt; is not empty) and &lt;code&gt;N&lt;/code&gt; should be the length of the tuple returned by &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;. For more details on defining custom &lt;code&gt;AbstractArray&lt;/code&gt; implementations, see the &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;array interface guide in the interfaces chapter&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;AbstractArray&lt;/code&gt; タイプは漠然とアレイのようなものを含み、それの実装は、従来の配列とは全く異なるかもしれません。たとえば、要素は格納されるのではなく、要求に応じて計算される場合があります。ただし、具体的な &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; 型は通常、少なくとも&lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size(A)&lt;/code&gt; &lt;/a&gt;（ &lt;code&gt;Int&lt;/code&gt; タプルを返す）、 &lt;code&gt;getindex(A,i)&lt;/code&gt; および&lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex(A,i1,...,iN)&lt;/code&gt; &lt;/a&gt;実装する必要があります。可変配列は&lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;も実装する必要があります！。これらの操作は、ほぼ一定の時間の複雑さ、または技術的に&amp;Otilde;（1）の複雑さを持つことをお勧めします。そうしないと、一部の配列関数が予期せず遅くなる可能性があります。具象タイプも、通常、&lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar(A,T=eltype(A),dims=size(A))&lt;/code&gt; &lt;/a&gt;メソッド。これは、&lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;やその他のアウトオブプレース操作に類似の配列を割り当てるために使用されます。 &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; が内部的にどのように表現されていても、 &lt;code&gt;T&lt;/code&gt; は&lt;em&gt;整数&lt;/em&gt;インデックス（ &lt;code&gt;A[1, ..., 1]&lt;/code&gt; 、 &lt;code&gt;A&lt;/code&gt; が空でない場合）によって返されるオブジェクトのタイプであり、 &lt;code&gt;N&lt;/code&gt; は&lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt;によって返されるタプル。カスタム &lt;code&gt;AbstractArray&lt;/code&gt; 実装の定義の詳細について&lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;は、インターフェイスの章の配列インターフェイスガイドを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a1a42131bfca003806ea94dc4875800e91fc9149" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AbstractChar&lt;/code&gt; type is the supertype of all character implementations in Julia. A character represents a Unicode code point, and can be converted to an integer via the &lt;a href=&quot;#Base.codepoint&quot;&gt;&lt;code&gt;codepoint&lt;/code&gt;&lt;/a&gt; function in order to obtain the numerical value of the code point, or constructed from the same integer. These numerical values determine how characters are compared with &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt;, for example. New &lt;code&gt;T &amp;lt;: AbstractChar&lt;/code&gt; types should define a &lt;code&gt;codepoint(::T)&lt;/code&gt; method and a &lt;code&gt;T(::UInt32)&lt;/code&gt; constructor, at minimum.</source>
          <target state="translated">&lt;code&gt;AbstractChar&lt;/code&gt; のタイプはジュリア内のすべての文字の実装のスーパータイプです。文字はUnicodeコードポイントを表し、コードポイントの数値を取得するために&lt;a href=&quot;#Base.codepoint&quot;&gt; &lt;code&gt;codepoint&lt;/code&gt; &lt;/a&gt;関数を介して整数に変換するか、同じ整数から構成できます。これらの数値は、たとえば、文字が &lt;code&gt;&amp;lt;&lt;/code&gt; および &lt;code&gt;==&lt;/code&gt; と比較される方法を決定します。新しい &lt;code&gt;T &amp;lt;: AbstractChar&lt;/code&gt; 型は、少なくとも &lt;code&gt;codepoint(::T)&lt;/code&gt; メソッドと &lt;code&gt;T(::UInt32)&lt;/code&gt; コンストラクタを定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="1c7306a482beca890d3fe61802010a334de7540c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ConfigEntry&lt;/code&gt; would look like the following:</source>
          <target state="translated">&lt;code&gt;ConfigEntry&lt;/code&gt; は、次のようになります。</target>
        </trans-unit>
        <trans-unit id="ba9c45997f3e5b0258d17d45edce07e2353ce6d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dates&lt;/code&gt; module approach tries to follow the simple principle of trying to change as little as possible when doing &lt;a href=&quot;#Dates.Period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; arithmetic. This approach is also often known as &lt;em&gt;calendrical&lt;/em&gt; arithmetic or what you would probably guess if someone were to ask you the same calculation in a conversation. Why all the fuss about this? Let's take a classic example: add 1 month to January 31st, 2014. What's the answer? Javascript will say &lt;a href=&quot;https://markhneedham.com/blog/2009/01/07/javascript-add-a-month-to-a-date/&quot;&gt;March 3&lt;/a&gt; (assumes 31 days). PHP says &lt;a href=&quot;https://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-while-not-exceeding-the-last-day-of-the-month&quot;&gt;March 2&lt;/a&gt; (assumes 30 days). The fact is, there is no right answer. In the &lt;code&gt;Dates&lt;/code&gt; module, it gives the result of February 28th. How does it figure that out? I like to think of the classic 7-7-7 gambling game in casinos.</source>
          <target state="translated">&lt;code&gt;Dates&lt;/code&gt; モジュールアプローチはやったときにできるだけ変更しようとの単純な原理に従おうと&lt;a href=&quot;#Dates.Period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt;計算を。このアプローチは、しばしば&lt;em&gt;カレンディカル&lt;/em&gt;算術とも呼ばれます。会話で同じ計算を誰かに尋ねられたとしたら、おそらくあなたが推測すると思います。なぜこれについてすべての大騒ぎですか？古典的な例を見てみましょう：1か月を2014年1月31日に追加します。答えは何ですか？ JavaScriptは&lt;a href=&quot;https://markhneedham.com/blog/2009/01/07/javascript-add-a-month-to-a-date/&quot;&gt;3月3日&lt;/a&gt;と表示します（31日と想定）。 PHPは&lt;a href=&quot;https://stackoverflow.com/questions/5760262/php-adding-months-to-a-date-while-not-exceeding-the-last-day-of-the-month&quot;&gt;3月2日&lt;/a&gt;と述べています（30日と想定）。実際、正解はありません。で &lt;code&gt;Dates&lt;/code&gt; モジュールは、2月28日の結果を提供します。それはどのようにしてわかりますか？私はカジノでの古典的な7-7-7ギャンブルゲームについて考えたいと思います。</target>
        </trans-unit>
        <trans-unit id="f3b7289c36cdd40212d2c06b1045bb17b9239ebc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dates&lt;/code&gt; module provides the &lt;em&gt;adjuster&lt;/em&gt; API through several convenient methods that aid in simply and succinctly expressing temporal rules. The first group of adjuster methods deal with the first and last of weeks, months, quarters, and years. They each take a single &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt; as input and return or &lt;em&gt;adjust to&lt;/em&gt; the first or last of the desired period relative to the input.</source>
          <target state="translated">&lt;code&gt;Dates&lt;/code&gt; モジュールが提供&lt;em&gt;されたアジャスタ&lt;/em&gt;簡単かつ簡潔に時間的ルールを表現するのに役立つことを、いくつかの便利なメソッドを介してAPIを。調整メソッドの最初のグループは、週、月、四半期、および年の最初と最後を扱います。それぞれが入力として単一の&lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt;を取り、入力に関連する目的の期間の最初または最後に戻るか、&lt;em&gt;調整し&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="822dabd74f61866145ac5d6c2a28ae2c68643b5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dates&lt;/code&gt; module provides two types for working with dates: &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;, representing day and millisecond precision, respectively; both are subtypes of the abstract &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt;. The motivation for distinct types is simple: some operations are much simpler, both in terms of code and mental reasoning, when the complexities of greater precision don't have to be dealt with. For example, since the &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; type only resolves to the precision of a single date (i.e. no hours, minutes, or seconds), normal considerations for time zones, daylight savings/summer time, and leap seconds are unnecessary and avoided.</source>
          <target state="translated">&lt;code&gt;Dates&lt;/code&gt; モジュールは、日付を操作するための2つのタイプを提供します。それぞれ、日付とミリ秒の精度を表す&lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;です。どちらも抽象&lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; の&lt;/a&gt;サブタイプです。特殊な型の動機は単純です。より高い精度の複雑さを処理する必要がない場合、一部の操作はコードと精神的推論の両方の点ではるかに単純です。たとえば、&lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;タイプは単一の日付の精度（つまり、時間、分、秒なし）にのみ解決されるため、タイムゾーン、夏時間/夏時間、うるう秒に関する通常の考慮事項は不要であり、回避されます。</target>
        </trans-unit>
        <trans-unit id="47e6ad22d3652de8f0079c299b50b93cf7e90cb5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Docs&lt;/code&gt; module provides the &lt;code&gt;@doc&lt;/code&gt; macro which can be used to set and retrieve documentation metadata for Julia objects.</source>
          <target state="translated">&lt;code&gt;Docs&lt;/code&gt; モジュールが提供 &lt;code&gt;@doc&lt;/code&gt; のセットに使用され、ジュリア・オブジェクトのドキュメントのメタデータを取得することができますマクロを。</target>
        </trans-unit>
        <trans-unit id="21bb014706065802683533ccfbc183fd2f75ab09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GitHash&lt;/code&gt; of the target object of &lt;code&gt;tag&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tag&lt;/code&gt; のターゲットオブジェクトの &lt;code&gt;GitHash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e3fa0171d91b22777ce2dc8384f8c21045a536e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JL_GC_POP&lt;/code&gt; call releases the references established by the previous &lt;code&gt;JL_GC_PUSH&lt;/code&gt;. Note that &lt;code&gt;JL_GC_PUSH&lt;/code&gt; stores references on the C stack, so it must be exactly paired with a &lt;code&gt;JL_GC_POP&lt;/code&gt; before the scope is exited. That is, before the function returns, or control flow otherwise leaves the block in which the &lt;code&gt;JL_GC_PUSH&lt;/code&gt; was invoked.</source>
          <target state="translated">&lt;code&gt;JL_GC_POP&lt;/code&gt; の呼び出しは、以前によって確立されたリファレンスリリース &lt;code&gt;JL_GC_PUSH&lt;/code&gt; を。 &lt;code&gt;JL_GC_PUSH&lt;/code&gt; はCスタックに参照を格納するため、スコープを終了する前に、 &lt;code&gt;JL_GC_POP&lt;/code&gt; と正確にペアにする必要があることに注意してください。つまり、関数が戻る前、または制御フローが &lt;code&gt;JL_GC_PUSH&lt;/code&gt; が呼び出されたブロックをそのままにします。</target>
        </trans-unit>
        <trans-unit id="3b348f9eede2ca6e62ca6337bddb047633174b17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; environment variable is used to populate the global Julia &lt;a href=&quot;../../base/constants/index#Base.DEPOT_PATH&quot;&gt;&lt;code&gt;DEPOT_PATH&lt;/code&gt;&lt;/a&gt; variable, which controls where the package manager, as well as Julia's code loading mechanisms, look for package registries, installed packages, named environments, repo clones, cached compiled package images, and configuration files.</source>
          <target state="translated">&lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; の環境変数は、グローバルジュリア移入するために使用されている&lt;a href=&quot;../../base/constants/index#Base.DEPOT_PATH&quot;&gt; &lt;code&gt;DEPOT_PATH&lt;/code&gt; の&lt;/a&gt;変数、コントロールパッケージマネージャだけでなく、ジュリアのコードローディングメカニズム、パッケージレジストリの外観、環境という名前のインストールパッケージ、レポのクローンは、コンパイル済みのパッケージ画像、およびコンフィギュレーションをキャッシュされたがファイル。</target>
        </trans-unit>
        <trans-unit id="69afeb6e2b2ee8e42ee83f53cc80115effd30019" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; environment variable is used to populate the global Julia &lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt;&lt;code&gt;LOAD_PATH&lt;/code&gt;&lt;/a&gt; variable, which determines which packages can be loaded via &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;using&lt;/code&gt; (see &lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;Code Loading&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; の環境変数は、グローバルジュリア移入するために使用されている&lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt; &lt;code&gt;LOAD_PATH&lt;/code&gt; の&lt;/a&gt;パッケージが経由してロードすることができ決定変数、 &lt;code&gt;import&lt;/code&gt; 及び &lt;code&gt;using&lt;/code&gt; （参照&lt;a href=&quot;../code-loading/index#Code-Loading-1&quot;&gt;コードの読み込みを&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="34bade2917d4a413edb80c43d8efdb3c090b4bcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Profile&lt;/code&gt; module provides tools to help developers improve the performance of their code. When used, it takes measurements on running code, and produces output that helps you understand how much time is spent on individual line(s). The most common usage is to identify &quot;bottlenecks&quot; as targets for optimization.</source>
          <target state="translated">&lt;code&gt;Profile&lt;/code&gt; モジュールは、開発者がコードのパフォーマンスを改善するためのツールを提供しています。使用すると、実行中のコードの測定が行われ、個々の行に費やされた時間を理解するのに役立つ出力が生成されます。最も一般的な使用法は、「ボトルネック」を最適化のターゲットとして識別することです。</target>
        </trans-unit>
        <trans-unit id="dee6516fb82f5277170e1ea0a8d04d1ed4092fd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pub&lt;/code&gt; package is in the user depot, where packages installed by the user live. These are only available to the user who installed them.</source>
          <target state="translated">&lt;code&gt;Pub&lt;/code&gt; パッケージは、パッケージがライブユーザーがインストールしたユーザーデポ、です。これらは、それらをインストールしたユーザーのみが使用できます。</target>
        </trans-unit>
        <trans-unit id="a8c1397c7dbb153add27fc9553cd4c77cee5bc54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Regex()&lt;/code&gt; constructor may be used to create a valid regex string programmatically. This permits using the contents of string variables and other string operations when constructing the regex string. Any of the regex codes above can be used within the single string argument to &lt;code&gt;Regex()&lt;/code&gt;. Here are some examples:</source>
          <target state="translated">&lt;code&gt;Regex()&lt;/code&gt; コンストラクタは、プログラムで有効な正規表現文字列を作成するために使用することができます。これにより、正規表現文字列を作成するときに、文字列変数の内容とその他の文字列操作を使用できます。上記の正規表現コードはいずれも、 &lt;code&gt;Regex()&lt;/code&gt; の単一の文字列引数内で使用できます。ここではいくつかの例を示します。</target>
        </trans-unit>
        <trans-unit id="73ca6d3bf4c447b201b63ae9bba284f7ce5a10d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;StackTraces&lt;/code&gt; module provides simple stack traces that are both human readable and easy to use programmatically.</source>
          <target state="translated">&lt;code&gt;StackTraces&lt;/code&gt; モジュールは、両方の人間が読めると、プログラムで使いやすいシンプルなスタックトレースを提供します。</target>
        </trans-unit>
        <trans-unit id="c7aa3a52368467c889b31b4e2156567453a420c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Test&lt;/code&gt; module provides simple &lt;em&gt;unit testing&lt;/em&gt; functionality. Unit testing is a way to see if your code is correct by checking that the results are what you expect. It can be helpful to ensure your code still works after you make changes, and can be used when developing as a way of specifying the behaviors your code should have when complete.</source>
          <target state="translated">&lt;code&gt;Test&lt;/code&gt; モジュールは、単純な提供&lt;em&gt;ユニットテスト&lt;/em&gt;機能を。ユニットテストは、結果が期待どおりであることを確認して、コードが正しいかどうかを確認する方法です。変更を加えた後もコードが機能することを確認すると役立ちます。また、開発時にコードが完了する必要のある動作を指定する方法として使用できます。</target>
        </trans-unit>
        <trans-unit id="3a54216422a2392050b1e4b2adcb38fe041e32d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UTInstant&lt;/code&gt; represents a machine timeline based on UT time (1 day = one revolution of the earth). The &lt;code&gt;T&lt;/code&gt; is a &lt;code&gt;Period&lt;/code&gt; parameter that indicates the resolution or precision of the instant.</source>
          <target state="translated">&lt;code&gt;UTInstant&lt;/code&gt; は、 UTの時間（地球=一周1日）に基づいて、マシンタイムラインを表します。 &lt;code&gt;T&lt;/code&gt; は、ある &lt;code&gt;Period&lt;/code&gt; インスタントの解像度または精度を示すパラメータ。</target>
        </trans-unit>
        <trans-unit id="f172eb4712d1e651ca4443a247edaddae0c02ffc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UnitRange&lt;/code&gt;&lt;code&gt;irange&lt;/code&gt; specifies indices of the sorted eigenvalues to search for.</source>
          <target state="translated">&lt;code&gt;UnitRange&lt;/code&gt; &lt;code&gt;irange&lt;/code&gt; を検索するソートされた固有値の指定インデックス。</target>
        </trans-unit>
        <trans-unit id="ec153c629332b5ec9f45e8c540e2078292ed5e2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;/code&gt; character should be escaped appropriately if the text is embedded in a Julia source code, for example, &lt;code&gt;&quot;``\\LaTeX`` syntax in a docstring.&quot;&lt;/code&gt;, since it is interpreted as a string literal. Alternatively, in order to avoid escaping, it is possible to use the &lt;code&gt;raw&lt;/code&gt; string macro together with the &lt;code&gt;@doc&lt;/code&gt; macro:</source>
          <target state="translated">&lt;code&gt;\&lt;/code&gt; テキストがジュリアのソースコードに埋め込まれている場合、文字が適切にエスケープする必要があり、例えば、 &lt;code&gt;&quot;``\\LaTeX`` syntax in a docstring.&quot;&lt;/code&gt; 、文字列リテラルとして解釈されるため。または、エスケープを回避するために、 &lt;code&gt;@doc&lt;/code&gt; マクロと一緒に &lt;code&gt;raw&lt;/code&gt; 文字列マクロを使用することができます。</target>
        </trans-unit>
        <trans-unit id="81508e7a2286289f4f9b4e988f086408435f8b86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;/code&gt; operation here performs the linear solution. The left-division operator is pretty powerful and it's easy to write compact, readable code that is flexible enough to solve all sorts of systems of linear equations.</source>
          <target state="translated">ここの &lt;code&gt;\&lt;/code&gt; 演算は線形解を実行します。左除算演算子は非常に強力で、あらゆる種類の線形方程式を解くのに十分な柔軟性を備えたコンパクトで読みやすいコードを簡単に作成できます。</target>
        </trans-unit>
        <trans-unit id="70fe69b8656c0c45fea00d261b4a1573767bfc08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;abstract type&lt;/code&gt; keyword introduces a new abstract type, whose name is given by &lt;code&gt;&amp;laquo;name&amp;raquo;&lt;/code&gt;. This name can be optionally followed by &lt;code&gt;&amp;lt;:&lt;/code&gt; and an already-existing type, indicating that the newly declared abstract type is a subtype of this &quot;parent&quot; type.</source>
          <target state="translated">&lt;code&gt;abstract type&lt;/code&gt; キーワードは、名前によって指定され、新たな抽象型、紹介 &lt;code&gt;&amp;laquo;name&amp;raquo;&lt;/code&gt; 。この名前の後にはオプションで &lt;code&gt;&amp;lt;:&lt;/code&gt; と既存のタイプを続けることができ、新しく宣言された抽象タイプがこの「親」タイプのサブタイプであることを示します。</target>
        </trans-unit>
        <trans-unit id="2f9421706ce1251dd1a3a86cb4c9ef2ac4b3c269" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;allowed_types&lt;/code&gt; contains a bitmask of &lt;code&gt;LibGit2.Consts.GIT_CREDTYPE&lt;/code&gt; values specifying which authentication methods should be attempted.</source>
          <target state="translated">&lt;code&gt;allowed_types&lt;/code&gt; はのビットマスクが含ま &lt;code&gt;LibGit2.Consts.GIT_CREDTYPE&lt;/code&gt; の認証方式が試行されるべき規定値を。</target>
        </trans-unit>
        <trans-unit id="8b06ca131e63337ccd916fd14f532e8185770099" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;atol&lt;/code&gt; and &lt;code&gt;rtol&lt;/code&gt; keyword arguments requires at least Julia 1.1. In Julia 1.0 &lt;code&gt;rtol&lt;/code&gt; is available as a positional argument, but this will be deprecated in Julia 2.0.</source>
          <target state="translated">&lt;code&gt;atol&lt;/code&gt; と &lt;code&gt;rtol&lt;/code&gt; キーワード引数は、少なくともジュリア1.1が必要です。Julia 1.0 &lt;code&gt;rtol&lt;/code&gt; 、位置引数としてrtolを使用できますが、これはJulia 2.0で廃止される予定です。</target>
        </trans-unit>
        <trans-unit id="7a8f8106813dc53840cdd36136d9eb3701004f27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;base&lt;/code&gt; argument is a pointer to an array of length &lt;code&gt;nmemb&lt;/code&gt;, with elements of &lt;code&gt;size&lt;/code&gt; bytes each. &lt;code&gt;compare&lt;/code&gt; is a callback function which takes pointers to two elements &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; and returns an integer less/greater than zero if &lt;code&gt;a&lt;/code&gt; should appear before/after &lt;code&gt;b&lt;/code&gt; (or zero if any order is permitted). Now, suppose that we have a 1d array &lt;code&gt;A&lt;/code&gt; of values in Julia that we want to sort using the &lt;code&gt;qsort&lt;/code&gt; function (rather than Julia's built-in &lt;code&gt;sort&lt;/code&gt; function). Before we worry about calling &lt;code&gt;qsort&lt;/code&gt; and passing arguments, we need to write a comparison function that works for some arbitrary objects (which define &lt;code&gt;&amp;lt;&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 引数は、長さの配列へのポインタである &lt;code&gt;nmemb&lt;/code&gt; 個の要素を持つ、 &lt;code&gt;size&lt;/code&gt; 各バイト。 &lt;code&gt;compare&lt;/code&gt; 二つの要素へのポインタをとり、コールバック関数であり、そして &lt;code&gt;b&lt;/code&gt; 場合戻る整数ゼロより小さい/大きい前に表示されるはず/後の &lt;code&gt;b&lt;/code&gt; （またはゼロ任意の順序が許可されている場合）。ここで、（Juliaの組み込みの &lt;code&gt;sort&lt;/code&gt; 関数ではなく） &lt;code&gt;qsort&lt;/code&gt; 関数を使用してソートしたいJuliaの値の1D配列 &lt;code&gt;A&lt;/code&gt; があるとします。 &lt;code&gt;qsort&lt;/code&gt; の呼び出しを心配する前に &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 引数を渡すには、任意のオブジェクト（ &lt;code&gt;&amp;lt;&lt;/code&gt; を定義する）で機能する比較関数を作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="2208a0a1e673c387c0482cabd9f5481f4d468aa8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;baseline&lt;/code&gt; is the tree to be used for comparison to the working directory and index; defaults to HEAD.</source>
          <target state="translated">&lt;code&gt;baseline&lt;/code&gt; 作業ディレクトリとインデックスとの比較のために使用される木です。デフォルトはHEADです。</target>
        </trans-unit>
        <trans-unit id="29b441ac8e59d2fd60c5cee59a3c67db4265556f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chnl&lt;/code&gt; object can be explicitly closed independent of task termination. Terminating tasks have no effect on already closed &lt;code&gt;Channel&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;chnl&lt;/code&gt; オブジェクトは、明示的にタスク終了とは独立して閉じることができます。タスクを終了しても、すでに閉じている &lt;code&gt;Channel&lt;/code&gt; オブジェクトには影響しません。</target>
        </trans-unit>
        <trans-unit id="efa868ba15d4c70e293eebe72c9574ee9fe6fe35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; declaration should only be used in global scope on globals. It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. If a global variable will not change, adding a &lt;code&gt;const&lt;/code&gt; declaration solves this performance problem.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 宣言はグローバルにグローバルスコープで使用する必要があります。グローバル変数を含むコードをコンパイラーが最適化することは困難です。グローバル変数の値（またはタイプ）はほとんどいつでも変更される可能性があるためです。グローバル変数が変更されない場合、 &lt;code&gt;const&lt;/code&gt; 宣言を追加すると、このパフォーマンスの問題が解決します。</target>
        </trans-unit>
        <trans-unit id="58b4a67ce4add4334b6cfa9f5f2082d426131b2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;convert&lt;/code&gt; function generally takes two arguments: the first is a type object and the second is a value to convert to that type. The returned value is the value converted to an instance of given type. The simplest way to understand this function is to see it in action:</source>
          <target state="translated">通常、 &lt;code&gt;convert&lt;/code&gt; 関数は2つの引数を取ります。1つ目は型オブジェクトで、2つ目はその型に変換する値です。戻り値は、指定されたタイプのインスタンスに変換された値です。この関数を理解する最も簡単な方法は、この関数の動作を確認することです。</target>
        </trans-unit>
        <trans-unit id="e7cb3fc07af13ab851df995a0b91fc4d68f51c39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;current&lt;/code&gt; status object may be a &lt;code&gt;StatStruct&lt;/code&gt;, an &lt;code&gt;EOFError&lt;/code&gt; (indicating the timeout elapsed), or some other &lt;code&gt;Exception&lt;/code&gt; subtype (if the &lt;code&gt;stat&lt;/code&gt; operation failed - for example, if the path does not exist).</source>
          <target state="translated">&lt;code&gt;current&lt;/code&gt; 状態オブジェクトであってもよい &lt;code&gt;StatStruct&lt;/code&gt; 、 &lt;code&gt;EOFError&lt;/code&gt; （タイムアウト経過を示す）、またはいくつかの他の &lt;code&gt;Exception&lt;/code&gt; （IFサブタイプ &lt;code&gt;stat&lt;/code&gt; -例えば、パスが存在しない場合、操作が失敗しました）。</target>
        </trans-unit>
        <trans-unit id="940a17c26916de1b6351b6066b3e6217426d4df2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dest&lt;/code&gt; array must be distinct from the &lt;code&gt;src&lt;/code&gt; array (they cannot alias each other).</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 配列は異なるものでなければなりません &lt;code&gt;src&lt;/code&gt; 配列（それらできない互いにエイリアス）。</target>
        </trans-unit>
        <trans-unit id="611e9863b6fe56ca0563d7d25daad5883ed6f0ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dir&lt;/code&gt; keyword argument can be used to specify a working directory for the command.</source>
          <target state="translated">&lt;code&gt;dir&lt;/code&gt; キーワード引数は、コマンドの作業ディレクトリを指定するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="a4bff47d996768873bcc39999935a98007b3cec4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do x&lt;/code&gt; syntax creates an anonymous function with argument &lt;code&gt;x&lt;/code&gt; and passes it as the first argument to &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;. Similarly, &lt;code&gt;do a,b&lt;/code&gt; would create a two-argument anonymous function, and a plain &lt;code&gt;do&lt;/code&gt; would declare that what follows is an anonymous function of the form &lt;code&gt;() -&amp;gt; ...&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;do x&lt;/code&gt; 構文は引数に無名関数を作成し &lt;code&gt;x&lt;/code&gt; との最初の引数として渡し&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;。同様に、 &lt;code&gt;do a,b&lt;/code&gt; は2つの引数を持つ無名関数を作成し、単純な &lt;code&gt;do&lt;/code&gt; は次の形式が &lt;code&gt;() -&amp;gt; ...&lt;/code&gt; 無名関数であることを宣言します。</target>
        </trans-unit>
        <trans-unit id="38f76b197c154b053fc67ebe8a0b86d9c54ffd48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;elseif&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks are optional, and as many &lt;code&gt;elseif&lt;/code&gt; blocks as desired can be used. The condition expressions in the &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elseif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; construct are evaluated until the first one evaluates to &lt;code&gt;true&lt;/code&gt;, after which the associated block is evaluated, and no further condition expressions or blocks are evaluated.</source>
          <target state="translated">&lt;code&gt;elseif&lt;/code&gt; と &lt;code&gt;else&lt;/code&gt; のブロックは、オプション、および多くのようです &lt;code&gt;elseif&lt;/code&gt; を必要に応じてブロックを使用することができます。条件式 &lt;code&gt;if&lt;/code&gt; - &lt;code&gt;elseif&lt;/code&gt; - &lt;code&gt;else&lt;/code&gt; 構築物に最初に評価されるまで評価され &lt;code&gt;true&lt;/code&gt; 関連するブロックが評価された後、およびさらなる条件式またはブロックが評価されていません。</target>
        </trans-unit>
        <trans-unit id="dabea74759059aade9a04e98141814de885b1362" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt; where the logging macro occurs in the source code.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; および &lt;code&gt;line&lt;/code&gt; ログマクロはソースコードで発生します。</target>
        </trans-unit>
        <trans-unit id="baef46876dcf6509194a8000268158d1d7c2494a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt; loop makes common repeated evaluation idioms easier to write. Since counting up and down like the above &lt;code&gt;while&lt;/code&gt; loop does is so common, it can be expressed more concisely with a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ループは、書き込みに共通の繰り返し評価イディオムが容易になります。上記の &lt;code&gt;while&lt;/code&gt; ループのようにカウントアップとカウントダウンは非常に一般的である &lt;code&gt;for&lt;/code&gt; 、forループでより簡潔に表現できます。</target>
        </trans-unit>
        <trans-unit id="ee6a3346a6698b43646ee623779b34ee8b0963c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grow&lt;/code&gt; keyword argument specifies whether the disk file should be grown to accommodate the requested size of array (if the total file size is &amp;lt; requested array size). Write privileges are required to grow the file.</source>
          <target state="translated">&lt;code&gt;grow&lt;/code&gt; ディスクファイル（合計ファイルサイズは&amp;lt;配列のサイズを要求された場合）、配列の要求されたサイズに対応するために成長する必要があるかどうかのキーワード引数の指定を。ファイルを拡張するには、書き込み権限が必要です。</target>
        </trans-unit>
        <trans-unit id="944e976cee83757342402d268820319c708e7f02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hello&lt;/code&gt; is the output of the &lt;code&gt;echo&lt;/code&gt; command, sent to &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;. The run method itself returns &lt;code&gt;nothing&lt;/code&gt;, and throws an &lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt; if the external command fails to run successfully.</source>
          <target state="translated">&lt;code&gt;hello&lt;/code&gt; の出力である &lt;code&gt;echo&lt;/code&gt; に送信されるコマンド、&lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;。runメソッド自体は &lt;code&gt;nothing&lt;/code&gt; 返さず、外部コマンドの実行に失敗した場合は&lt;a href=&quot;../../base/base/index#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; &lt;/a&gt;をスローします。</target>
        </trans-unit>
        <trans-unit id="3728644266a88dfcc97848c625f08a3fe62768b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ipv6only&lt;/code&gt; parameter disables dual stack mode. If &lt;code&gt;ipv6only=true&lt;/code&gt;, only an IPv6 stack is created.</source>
          <target state="translated">&lt;code&gt;ipv6only&lt;/code&gt; パラメータは、デュアルスタックモードを無効にします。 &lt;code&gt;ipv6only=true&lt;/code&gt; の場合、IPv6スタックのみが作成されます。</target>
        </trans-unit>
        <trans-unit id="9131ac4a45cc03434a2d1d252e0b9eb47948d016" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;k&lt;/code&gt;th diagonal of a matrix, as a vector.</source>
          <target state="translated">ベクトルとしての、行列の &lt;code&gt;k&lt;/code&gt; 番目の対角。</target>
        </trans-unit>
        <trans-unit id="586747034b4744d9048e093e3d358be130046659" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;let&lt;/code&gt; block creates a new variable &lt;code&gt;r&lt;/code&gt; whose scope is only the inner function. The second technique recovers full language performance in the presence of captured variables. Note that this is a rapidly evolving aspect of the compiler, and it is likely that future releases will not require this degree of programmer annotation to attain performance. In the mean time, some user-contributed packages like &lt;a href=&quot;https://github.com/c42f/FastClosures.jl&quot;&gt;FastClosures&lt;/a&gt; automate the insertion of &lt;code&gt;let&lt;/code&gt; statements as in &lt;code&gt;abmult3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; ブロックは、新しい変数を作成し、 &lt;code&gt;r&lt;/code&gt; をその範囲のみ内部機能です。2番目の手法は、キャプチャされた変数が存在する場合に完全な言語パフォーマンスを回復します。これはコンパイラーの急速に進化している側面であり、将来のリリースでは、パフォーマンスを達成するためにこの程度のプログラマーの注釈が不要になる可能性が高いことに注意してください。平均時間では、のようないくつかのユーザーが投稿したパッケージ&lt;a href=&quot;https://github.com/c42f/FastClosures.jl&quot;&gt;FastClosuresは、&lt;/a&gt;挿入の自動化 &lt;code&gt;let&lt;/code&gt; のようなステートメントを &lt;code&gt;abmult3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="404db33b1806403679f9afdc7e45d8ad145e7ae6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;local&lt;/code&gt; and &lt;code&gt;global&lt;/code&gt; keywords can also be applied to destructuring assignments, e.g. &lt;code&gt;local x, y = 1, 2&lt;/code&gt;. In this case the keyword affects all listed variables.</source>
          <target state="translated">&lt;code&gt;local&lt;/code&gt; および &lt;code&gt;global&lt;/code&gt; キーワードはまた、例えば、割り当てを構造化代入を適用することができる &lt;code&gt;local x, y = 1, 2&lt;/code&gt; 。この場合、キーワードはリストされたすべての変数に影響します。</target>
        </trans-unit>
        <trans-unit id="b4e455fac98bba78f84dcce75d6fd177f25053bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loopback&lt;/code&gt; keyword argument dictates whether loopback addresses are included.</source>
          <target state="translated">&lt;code&gt;loopback&lt;/code&gt; ループバックアドレスが含まれているかどうかをキーワード引数のおもむきます。</target>
        </trans-unit>
        <trans-unit id="43f03591f994b72dda2b585d5125cc1a285cbfab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; in which the logging macro was expanded.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; のログマクロが展開されました。</target>
        </trans-unit>
        <trans-unit id="4522c3b2f49470689410e3676d64813c5ddeff60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt;-norm is defined as</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; のように定義されるノルム</target>
        </trans-unit>
        <trans-unit id="98b88a0b1c328d1e6bd27b342609d1fb54652c60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;promote&lt;/code&gt; function converts all its arguments to a common type &amp;ndash; in this case &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. With this method definition, the &lt;code&gt;Point&lt;/code&gt; constructor promotes its arguments the same way that numeric operators like &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt; do, and works for all kinds of real numbers:</source>
          <target state="translated">&lt;code&gt;promote&lt;/code&gt; この場合-関数変換の一般的なタイプのすべての引数&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;。このメソッド定義では、 &lt;code&gt;Point&lt;/code&gt; コンストラクターは&lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; の&lt;/a&gt;ような数値演算子と同じ方法で引数を昇格し、あらゆる種類の実数に対して機能します。</target>
        </trans-unit>
        <trans-unit id="8297e1ed549bbae968b6d4d9056ddd08eaa6ab7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;promote_rule&lt;/code&gt; function is used as a building block to define a second function called &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt;, which, given any number of type objects, returns the common type to which those values, as arguments to &lt;code&gt;promote&lt;/code&gt; should be promoted. Thus, if one wants to know, in absence of actual values, what type a collection of values of certain types would promote to, one can use &lt;code&gt;promote_type&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;promote_rule&lt;/code&gt; の関数が呼び出される第二の機能を定義するためのビルディングブロックとして使用される&lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt;、型オブジェクトの任意の数の所与、引数として、これらの値に共通の型を返す &lt;code&gt;promote&lt;/code&gt; 促進されるべきです。したがって、実際の値がない場合に、特定のタイプの値のコレクションが昇格するタイプを知りたい場合は、 &lt;code&gt;promote_type&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="3b692555ebed7ff435cd42db277bcbc90f0f6b5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r&quot;...&quot;&lt;/code&gt; literal is constructed without interpolation and unescaping (except for quotation mark &lt;code&gt;&quot;&lt;/code&gt; which still has to be escaped). Here is an example showing the difference from standard string literals:</source>
          <target state="translated">&lt;code&gt;r&quot;...&quot;&lt;/code&gt; リテラルは、（引用符を除く補間およびエスケープ解除せずに構成されている &lt;code&gt;&quot;&lt;/code&gt; まだエスケープされなければならない）。ここで標準文字列リテラルからの差を示す例であります：</target>
        </trans-unit>
        <trans-unit id="2a6072b422e59a959f8b81bd76474b677710288a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; Keyword</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; キーワード</target>
        </trans-unit>
        <trans-unit id="fbd3a71fad13cb9858c23c4a3ef4f996112c52ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;same_type_numeric&lt;/code&gt; function behaves much like the &lt;code&gt;same_type&lt;/code&gt; function defined above, but is only defined for pairs of numbers.</source>
          <target state="translated">&lt;code&gt;same_type_numeric&lt;/code&gt; 機能はかなりのように振る舞う &lt;code&gt;same_type&lt;/code&gt; の上記で定義された機能が、わずか数のペアのために定義されています。</target>
        </trans-unit>
        <trans-unit id="9fab5a03f87c103ae23a4670919e1023dea2f659" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shared&lt;/code&gt; keyword argument specifies whether the resulting &lt;code&gt;Array&lt;/code&gt; and changes made to it will be visible to other processes mapping the same file.</source>
          <target state="translated">&lt;code&gt;shared&lt;/code&gt; 得られたかどうかをキーワード引数で指定 &lt;code&gt;Array&lt;/code&gt; 、それに作られ、変更が同じファイルをマッピングする他のプロセスに表示されます。</target>
        </trans-unit>
        <trans-unit id="0931d123977915d4a1d899bba2683bbb5d1cf496" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shred&lt;/code&gt; keyword controls whether sensitive information in the payload credential field should be destroyed. Should only be set to &lt;code&gt;false&lt;/code&gt; during testing.</source>
          <target state="translated">&lt;code&gt;shred&lt;/code&gt; ペイロード資格分野での機密情報が破壊されるべきかどうかのキーワードを制御します。テスト中のみ &lt;code&gt;false&lt;/code&gt; に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="fe58d87c8dd555b134b1d599492862c038b6d10f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; object may be anything, and should be chosen appropriately for each iterable type. See the &lt;a href=&quot;../../manual/interfaces/index#man-interface-iteration-1&quot;&gt;manual section on the iteration interface&lt;/a&gt; for more details about defining a custom iterable type.</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; オブジェクトは何であってもよく、各反復可能タイプに対して適切に選択されるべきです。カスタム反復可能型の定義の詳細については&lt;a href=&quot;../../manual/interfaces/index#man-interface-iteration-1&quot;&gt;、反復インターフェース&lt;/a&gt;の手動セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="197a5a1cfcc6bf414db454749ace6bc6b46270e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;transcode&lt;/code&gt; function succeeds as long as the input data can be reasonably represented in the target encoding; it always succeeds for conversions between UTF-XX encodings, even for invalid Unicode data.</source>
          <target state="translated">&lt;code&gt;transcode&lt;/code&gt; 機能は、長い入力データが合理的に目標符号で表現できるほど成功します。無効なUnicodeデータであっても、UTF-XXエンコーディング間の変換は常に成功します。</target>
        </trans-unit>
        <trans-unit id="25bce1e285bcf1b8934e0d8620acac52150b4abc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try/catch&lt;/code&gt; statement</source>
          <target state="translated">&lt;code&gt;try/catch&lt;/code&gt; の声明</target>
        </trans-unit>
        <trans-unit id="c2c1155010a79df372e519698f4e8f431ee252c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;try/catch&lt;/code&gt; statement allows for &lt;code&gt;Exception&lt;/code&gt;s to be tested for, and for the graceful handling of things that may ordinarily break your application. For example, in the below code the function for square root would normally throw an exception. By placing a &lt;code&gt;try/catch&lt;/code&gt; block around it we can mitigate that here. You may choose how you wish to handle this exception, whether logging it, return a placeholder value or as in the case below where we just printed out a statement. One thing to think about when deciding how to handle unexpected situations is that using a &lt;code&gt;try/catch&lt;/code&gt; block is much slower than using conditional branching to handle those situations. Below there are more examples of handling exceptions with a &lt;code&gt;try/catch&lt;/code&gt; block:</source>
          <target state="translated">&lt;code&gt;try/catch&lt;/code&gt; の文は、することができます &lt;code&gt;Exception&lt;/code&gt; のためにテストすると、通常はアプリケーションを壊すことがあり、物事の優雅な取り扱いのために。たとえば、以下のコードでは、平方根の関数は通常例外をスローします。その周りに &lt;code&gt;try/catch&lt;/code&gt; ブロックを配置することで、ここでそれを軽減できます。ロギングするか、プレースホルダー値を返すか、またはステートメントを出力した以下の場合のように、この例外の処理方法を選択できます。予期しない状況の処理方法を決定する際に考慮すべきことの1つは、 &lt;code&gt;try/catch&lt;/code&gt; ブロックを使用すると、条件分岐を使用してそれらの状況を処理するよりもはるかに遅くなることです。以下は、 &lt;code&gt;try/catch&lt;/code&gt; を使用した例外処理の例です。 ブロック：</target>
        </trans-unit>
        <trans-unit id="8de2b2884ad5c0d59519c41370d411d31e17c8aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed on the pointer &lt;code&gt;p&lt;/code&gt; to ensure that it is valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.</source>
          <target state="translated">この関数の &lt;code&gt;unsafe&lt;/code&gt; 接頭辞は、ポインター &lt;code&gt;p&lt;/code&gt; が有効であることを確認するための検証が行われないことを示します。Cと同じように、誤った使い方をすると、プログラムが破損またはセグメンテーション違反になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="1ad1cf514621d9bd7509c63edb01e709a946f374" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed on the pointer &lt;code&gt;p&lt;/code&gt; to ensure that it is valid. Incorrect usage may segfault your program or return garbage answers, in the same manner as C.</source>
          <target state="translated">この関数の &lt;code&gt;unsafe&lt;/code&gt; 接頭辞は、ポインター &lt;code&gt;p&lt;/code&gt; が有効であることを確認するための検証が行われないことを示します。Cと同様に、誤った使い方をすると、プログラムがセグメンテーション違反になったり、ガベージアンサーが返されたりすることがあります。</target>
        </trans-unit>
        <trans-unit id="ffd2fc5d018bc4147802a9ab69acc1302211d9d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed on the pointers &lt;code&gt;dest&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; to ensure that they are valid. Incorrect usage may corrupt or segfault your program, in the same manner as C.</source>
          <target state="translated">この関数の &lt;code&gt;unsafe&lt;/code&gt; 接頭辞は、ポインター &lt;code&gt;dest&lt;/code&gt; と &lt;code&gt;src&lt;/code&gt; が有効であることを確認するための検証が行われないことを示しています。Cと同じように、誤った使い方をすると、プログラムが破損またはセグメンテーション違反になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="c545e57ea20b7dee78b3ead6faf2e0dd60dec4ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that no validation is performed to ensure that N is inbounds on either array. Incorrect usage may corrupt or segfault your program, in the same manner as C.</source>
          <target state="translated">この関数の &lt;code&gt;unsafe&lt;/code&gt; 接頭辞は、Nがいずれかの配列のインバウンドであることを確認する検証が実行されないことを示します。Cと同じように、誤った使い方をすると、プログラムが破損またはセグメンテーション違反になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="f4d657f988d9e3352165918f5b958ddc6e9310c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unsafe&lt;/code&gt; prefix on this function indicates that using the result of this function after the &lt;code&gt;x&lt;/code&gt; argument to this function is no longer accessible to the program may cause undefined behavior, including program corruption or segfaults, at any later time.</source>
          <target state="translated">この関数の &lt;code&gt;unsafe&lt;/code&gt; 接頭辞は、この関数への &lt;code&gt;x&lt;/code&gt; 引数がプログラムにアクセスできなくなった後にこの関数の結果を使用すると、後でプログラムの破損やセグメンテーション違反などの未定義の動作が発生する可能性があることを示します。</target>
        </trans-unit>
        <trans-unit id="1f00bb06127cf74d0a7a977235b45b41a807deea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;userdata&lt;/code&gt; field is used to store information for each worker by external managers.</source>
          <target state="translated">&lt;code&gt;userdata&lt;/code&gt; フィールドは、外部の管理者が各作業者のための情報を格納するために使用されます。</target>
        </trans-unit>
        <trans-unit id="ea1c59c30ca45a88d468b07114183bcee1a4d149" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;where&lt;/code&gt; keyword creates a type that is an iterated union of other types, over all values of some variable. For example &lt;code&gt;Vector{T} where T&amp;lt;:Real&lt;/code&gt; includes all &lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt;&lt;code&gt;Vector&lt;/code&gt;&lt;/a&gt;s where the element type is some kind of &lt;code&gt;Real&lt;/code&gt; number.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; キーワードがいくつかの変数のすべての値の上に、他のタイプの反復労働組合である型を作成します。たとえば、 &lt;code&gt;Vector{T} where T&amp;lt;:Real&lt;/code&gt; は、要素タイプが何らかの &lt;code&gt;Real&lt;/code&gt; であるすべての&lt;a href=&quot;../arrays/index#Base.Vector&quot;&gt; &lt;code&gt;Vector&lt;/code&gt; が&lt;/a&gt;含まれます。</target>
        </trans-unit>
        <trans-unit id="e2963a52dada4be3a4b826619d947c135b0ff9a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;where&lt;/code&gt; keyword itself can be nested inside a more complex declaration. For example, consider the two types created by the following declarations:</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; キーワード自体は、より複雑な宣言の中にネストすることができます。たとえば、次の宣言によって作成された2つのタイプについて考えてみます。</target>
        </trans-unit>
        <trans-unit id="998cd2a7738c69cc615469e2df80e3038aa7e4db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; loop evaluates the condition expression (&lt;code&gt;i &amp;lt;= 5&lt;/code&gt; in this case), and as long it remains &lt;code&gt;true&lt;/code&gt;, keeps also evaluating the body of the &lt;code&gt;while&lt;/code&gt; loop. If the condition expression is &lt;code&gt;false&lt;/code&gt; when the &lt;code&gt;while&lt;/code&gt; loop is first reached, the body is never evaluated.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; ループは、条件式（評価 &lt;code&gt;i &amp;lt;= 5&lt;/code&gt; この場合は）、それが残っている限り &lt;code&gt;true&lt;/code&gt; 、また、本体評価維持 &lt;code&gt;while&lt;/code&gt; ループします。 &lt;code&gt;while&lt;/code&gt; ループに最初に到達したときに条件式が &lt;code&gt;false&lt;/code&gt; の場合、本体は評価されません。</target>
        </trans-unit>
        <trans-unit id="c9eac2e060f4090d788f5a1733519b89ab4b4ae0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;binomial coefficient&lt;/em&gt;$\binom{n}{k}$, being the coefficient of the $k$th term in the polynomial expansion of $(1+x)^n$.</source>
          <target state="translated">&lt;em&gt;二項係数&lt;/em&gt; $ \ binom {n}は{K} $、$ K $の係数番目$の多項式展開における項（1 + X）^ N $です。</target>
        </trans-unit>
        <trans-unit id="5f58dd4e346415c12b8a2bde13968a9b1deff1c2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;log level&lt;/em&gt; is a broad category for the message that is used for early filtering. There are several standard levels of type &lt;a href=&quot;#Base.CoreLogging.LogLevel&quot;&gt;&lt;code&gt;LogLevel&lt;/code&gt;&lt;/a&gt;; user-defined levels are also possible.</source>
          <target state="translated">&lt;em&gt;ログレベルは&lt;/em&gt;初期のフィルタリングに使用されるメッセージのための広いカテゴリーです。タイプ&lt;a href=&quot;#Base.CoreLogging.LogLevel&quot;&gt; &lt;code&gt;LogLevel&lt;/code&gt; に&lt;/a&gt;はいくつかの標準レベルがあります。ユーザー定義のレベルも可能です。</target>
        </trans-unit>
        <trans-unit id="31fe1c7ad22ee14f0705951a3acf51f247460513" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;message&lt;/em&gt; is an object describing the event. By convention &lt;code&gt;AbstractString&lt;/code&gt;s passed as messages are assumed to be in markdown format. Other types will be displayed using &lt;code&gt;show(io,mime,obj)&lt;/code&gt; according to the display capabilities of the installed logger.</source>
          <target state="translated">&lt;em&gt;メッセージは、&lt;/em&gt;イベントを記述するオブジェクトです。慣例により、メッセージとして渡される &lt;code&gt;AbstractString&lt;/code&gt; は、マークダウン形式であると見なされます。その他のタイプは、インストールされているロガーの表示機能に従って &lt;code&gt;show(io,mime,obj)&lt;/code&gt; を使用して表示されます。</target>
        </trans-unit>
        <trans-unit id="ff35386d12b40dc9ba6f11aed8e1486efcf6f63b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;primary environment&lt;/em&gt;&amp;mdash;i.e. the first environment in a stack&amp;mdash;is faithfully embedded in a stacked environment. The full dependency graph of the first environment in a stack is guaranteed to be included intact in the stacked environment including the same versions of all dependencies.</source>
          <target state="translated">&lt;em&gt;プライマリ環境&lt;/em&gt;における最初の環境-ie忠実積層環境に埋め込まれたスタックが-れます。スタック内の最初の環境の完全な依存関係グラフは、すべての依存関係の同じバージョンを含むスタック環境にそのまま含まれることが保証されています。</target>
        </trans-unit>
        <trans-unit id="f56a5c0b72490015a89e1c362931e81a9ffdc753" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;scope&lt;/em&gt; of a variable is the region of code within which a variable is visible. Variable scoping helps avoid variable naming conflicts. The concept is intuitive: two functions can both have arguments called &lt;code&gt;x&lt;/code&gt; without the two &lt;code&gt;x&lt;/code&gt;'s referring to the same thing. Similarly, there are many other cases where different blocks of code can use the same name without referring to the same thing. The rules for when the same variable name does or doesn't refer to the same thing are called scope rules; this section spells them out in detail.</source>
          <target state="translated">変数の&lt;em&gt;スコープ&lt;/em&gt;は、変数が表示されるコードの領域です。変数のスコープは、変数の名前の競合を回避するのに役立ちます。概念は直感的です。2つの関数が両方とも &lt;code&gt;x&lt;/code&gt; と呼ばれる引数を持つことができ、2つの &lt;code&gt;x&lt;/code&gt; は同じものを参照しません。同様に、コードの異なるブロックが同じものを参照せずに同じ名前を使用できるケースは他にもたくさんあります。同じ変数名が同じものを参照する場合と参照しない場合の規則は、スコープ規則と呼ばれます。このセクションでは、それらについて詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="e823801b39157cff5d7794c3183a7d1989add808" translate="yes" xml:space="preserve">
          <source>The API for 1) is quite functional, but is relatively recent so it may still have to evolve in subsequent releases of the &lt;code&gt;Random&lt;/code&gt; module. For example, it's typically sufficient to implement one &lt;code&gt;rand&lt;/code&gt; method in order to have all other usual methods work automatically.</source>
          <target state="translated">1）のAPIは非常に機能的ですが、比較的最近のものであるため、 &lt;code&gt;Random&lt;/code&gt; モジュールの後続のリリースで引き続き進化する​​必要があります。たとえば、他のすべての通常のメソッドを自動的に動作させるには、通常、1つの &lt;code&gt;rand&lt;/code&gt; メソッドを実装するだけで十分です。</target>
        </trans-unit>
        <trans-unit id="8ab319b5b160e68efa740a64380d05f1be87039a" translate="yes" xml:space="preserve">
          <source>The API for 2) is still rudimentary, and may require more work than strictly necessary from the implementor, in order to support usual types of generated values.</source>
          <target state="translated">2)の API はまだ初歩的なものであり、通常の生成される値の型をサポートするためには、実装者に必要以上の作業が必要になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="2f9630cea145272914a5264c86a31f652e4069fa" translate="yes" xml:space="preserve">
          <source>The API is not clearly defined yet, but as a rule of thumb:</source>
          <target state="translated">APIはまだ明確に定義されていませんが、経験則としては</target>
        </trans-unit>
        <trans-unit id="a2cac855dd1e1320bc002428689d4b74c6a1a9ec" translate="yes" xml:space="preserve">
          <source>The ASCII string &quot;DATA&quot; corresponds to the bytes 68, 65, 84, 65. &lt;code&gt;\xff&lt;/code&gt; produces the single byte 255. The Unicode escape &lt;code&gt;\u2200&lt;/code&gt; is encoded in UTF-8 as the three bytes 226, 136, 128. Note that the resulting byte array does not correspond to a valid UTF-8 string:</source>
          <target state="translated">ASCII文字列「DATA」は、バイト &lt;code&gt;\xff&lt;/code&gt; 対応します。\ xffは1バイト255を生成します。Unicodeエスケープ &lt;code&gt;\u2200&lt;/code&gt; は、UTF-8で3バイト226、136、128としてエンコードされます。結果のバイト配列は有効なUTF-8文字列に対応していません：</target>
        </trans-unit>
        <trans-unit id="39a538bac8d2eeb537bfbc18fea41895f84fba1e" translate="yes" xml:space="preserve">
          <source>The C &lt;code&gt;getenv&lt;/code&gt; function indicates an error by returning &lt;code&gt;NULL&lt;/code&gt;, but other standard C functions indicate errors in various different ways, including by returning -1, 0, 1 and other special values. This wrapper throws an exception clearly indicating the problem if the caller tries to get a non-existent environment variable:</source>
          <target state="translated">Cの &lt;code&gt;getenv&lt;/code&gt; 関数は &lt;code&gt;NULL&lt;/code&gt; を返すことでエラーを示しますが、他の標準のC関数は、-1、0、1などの特殊な値を返すなど、さまざまな方法でエラーを示します。このラッパーは、呼び出し元が存在しない環境変数を取得しようとすると、問題を明確に示す例外をスローします。</target>
        </trans-unit>
        <trans-unit id="bb0be6121167f43ded0796e444ece3ab2ece1c9f" translate="yes" xml:space="preserve">
          <source>The C function wrapped returns an integer error code; the results of the actual evaluation of the Bessel J function populate the Julia array &lt;code&gt;result_array&lt;/code&gt;. This variable can only be used with corresponding input type declaration &lt;code&gt;Ref{Cdouble}&lt;/code&gt;, since its memory is allocated and managed by Julia, not C. The implicit call to &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert(Ref{Cdouble}, result_array)&lt;/code&gt;&lt;/a&gt; unpacks the Julia pointer to a Julia array data structure into a form understandable by C.</source>
          <target state="translated">ラップされたC関数は整数のエラーコードを返します。Bessel J関数の実際の評価結果は、Julia配列 &lt;code&gt;result_array&lt;/code&gt; に入力されます。この変数は、対応する入力タイプ宣言 &lt;code&gt;Ref{Cdouble}&lt;/code&gt; でのみ使用できます。これは、そのメモリがCではなくJuliaによって割り当てられ、管理されるためです&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert(Ref{Cdouble}, result_array)&lt;/code&gt; &lt;/a&gt;への暗黙の呼び出しは、JuliaポインターをJulia配列データ構造をCが理解できる形式に</target>
        </trans-unit>
        <trans-unit id="e369993cdb5fa6e70590fdbba6d637a46744b422" translate="yes" xml:space="preserve">
          <source>The C null pointer constant, sometimes used when calling external code.</source>
          <target state="translated">C の NULL ポインタ定数で、外部コードを呼び出す際に使用されることがあります。</target>
        </trans-unit>
        <trans-unit id="1266dcff3400e720f05ea76935c60007b496fe2d" translate="yes" xml:space="preserve">
          <source>The Darwin kernel descends from BSD, which means that &lt;code&gt;Sys.isbsd()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; on macOS systems. To exclude macOS from a predicate, use &lt;code&gt;Sys.isbsd() &amp;amp;&amp;amp; !Sys.isapple()&lt;/code&gt;.</source>
          <target state="translated">DarwinカーネルはBSDの &lt;code&gt;Sys.isbsd()&lt;/code&gt; です。つまり、macOSシステムではSys.isbsd（）が &lt;code&gt;true&lt;/code&gt; です。述語からmacOSを除外するには、 &lt;code&gt;Sys.isbsd() &amp;amp;&amp;amp; !Sys.isapple()&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="6d062d595ac22ed3de2b1695d4234bbdd4c8970f" translate="yes" xml:space="preserve">
          <source>The Examples folder &lt;code&gt;clustermanager/simple&lt;/code&gt; is an example that shows a simple implementation using UNIX domain sockets for cluster setup.</source>
          <target state="translated">Examplesフォルダー &lt;code&gt;clustermanager/simple&lt;/code&gt; は、クラスターのセットアップにUNIXドメインソケットを使用した簡単な実装を示す例です。</target>
        </trans-unit>
        <trans-unit id="47538569b998ba670f072a1e4a838d9065a41d8f" translate="yes" xml:space="preserve">
          <source>The GC can be allowed to deallocate a variable by removing the reference to it from &lt;code&gt;refs&lt;/code&gt; using the function &lt;code&gt;delete!&lt;/code&gt;, provided that no other reference to the variable is kept anywhere:</source>
          <target state="translated">GCから、それへの参照を削除することによって、変数の割当てを解除させることができる &lt;code&gt;refs&lt;/code&gt; 機能使用して &lt;code&gt;delete!&lt;/code&gt; 、ただし、変数への他の参照がどこにも保持されない場合：</target>
        </trans-unit>
        <trans-unit id="9114ec3ce1d9b68ea428c28233e88219f98a90cb" translate="yes" xml:space="preserve">
          <source>The GC can only run when Julia objects are allocated. Calls like &lt;code&gt;jl_box_float64&lt;/code&gt; perform allocation, and allocation might also happen at any point in running Julia code. However, it is generally safe to use pointers in between &lt;code&gt;jl_...&lt;/code&gt; calls. But in order to make sure that values can survive &lt;code&gt;jl_...&lt;/code&gt; calls, we have to tell Julia that we hold a reference to a Julia value. This can be done using the &lt;code&gt;JL_GC_PUSH&lt;/code&gt; macros:</source>
          <target state="translated">GCは、Juliaオブジェクトが割り当てられている場合にのみ実行できます。 &lt;code&gt;jl_box_float64&lt;/code&gt; のような呼び出しが割り当てを実行し、Juliaコードの実行中の任意の時点で割り当てが発生する可能性もあります。ただし、 &lt;code&gt;jl_...&lt;/code&gt; 呼び出しの間にポインターを使用することは一般的に安全です。しかし、値が &lt;code&gt;jl_...&lt;/code&gt; 呼び出しを乗り切ることができることを確認するために、Julia値への参照を保持していることをJuliaに通知する必要があります。これは、 &lt;code&gt;JL_GC_PUSH&lt;/code&gt; マクロを使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="4c26097947d8e62d93e95f7bb8a753aa81198a0d" translate="yes" xml:space="preserve">
          <source>The Julia REPL</source>
          <target state="translated">ジュリアのレプリ</target>
        </trans-unit>
        <trans-unit id="966cbe6fa0ef45947b54d91f086e0f21369273f7" translate="yes" xml:space="preserve">
          <source>The Julia REPL makes great use of key bindings. Several control-key bindings were already introduced above (&lt;code&gt;^D&lt;/code&gt; to exit, &lt;code&gt;^R&lt;/code&gt; and &lt;code&gt;^S&lt;/code&gt; for searching), but there are many more. In addition to the control-key, there are also meta-key bindings. These vary more by platform, but most terminals default to using alt- or option- held down with a key to send the meta-key (or can be configured to do so).</source>
          <target state="translated">Julia REPLはキー割り当てをうまく利用しています。いくつかのコントロールキーバインディングはすでに上で紹介されています（終了するには &lt;code&gt;^R&lt;/code&gt; &lt;code&gt;^D&lt;/code&gt; 、検索には^ Rおよび &lt;code&gt;^S&lt;/code&gt; ）。コントロールキーに加えて、メタキーバインディングもあります。これらはプラットフォームによってさらに異なりますが、ほとんどの端末では、デフォルトでaltキーまたはoptionキーを押しながらメタキーを送信します（または送信するように構成できます）。</target>
        </trans-unit>
        <trans-unit id="78a8d27e5d46846612931d336af5427fb48eaefb" translate="yes" xml:space="preserve">
          <source>The Julia internal variable &lt;a href=&quot;../../base/constants/index#Base.Sys.WORD_SIZE&quot;&gt;&lt;code&gt;Sys.WORD_SIZE&lt;/code&gt;&lt;/a&gt; indicates whether the target system is 32-bit or 64-bit:</source>
          <target state="translated">Juliaの内部変数&lt;a href=&quot;../../base/constants/index#Base.Sys.WORD_SIZE&quot;&gt; &lt;code&gt;Sys.WORD_SIZE&lt;/code&gt; &lt;/a&gt;は、ターゲットシステムが32ビットか64ビットかを示します。</target>
        </trans-unit>
        <trans-unit id="1693b1af11374cde64dabe11066916f7ee8e88c7" translate="yes" xml:space="preserve">
          <source>The Julia process running the driver script in the example above has an &lt;code&gt;id&lt;/code&gt; equal to 1, just like a process providing an interactive prompt.</source>
          <target state="translated">上記の例でドライバースクリプトを実行しているJuliaプロセスは、対話型プロンプトを提供するプロセスと同様に、 &lt;code&gt;id&lt;/code&gt; が1です。</target>
        </trans-unit>
        <trans-unit id="aa8416476707db541c2333530ff960a4433eec90" translate="yes" xml:space="preserve">
          <source>The Julian mode</source>
          <target state="translated">ジュリアンモード</target>
        </trans-unit>
        <trans-unit id="65c675577bb25cbb84233bfad40ea840727c87ba" translate="yes" xml:space="preserve">
          <source>The LQ decomposition is the QR decomposition of &lt;code&gt;transpose(A)&lt;/code&gt;.</source>
          <target state="translated">LQ分解は、 &lt;code&gt;transpose(A)&lt;/code&gt; の QR分解です。</target>
        </trans-unit>
        <trans-unit id="b05b84454661b0ad77fcf176c57484bf1c0a4367" translate="yes" xml:space="preserve">
          <source>The LibGit2 module provides bindings to &lt;a href=&quot;https://libgit2.org/&quot;&gt;libgit2&lt;/a&gt;, a portable C library that implements core functionality for the &lt;a href=&quot;https://git-scm.com/&quot;&gt;Git&lt;/a&gt; version control system. These bindings are currently used to power Julia's package manager. It is expected that this module will eventually be moved into a separate package.</source>
          <target state="translated">LibGit2モジュールは、&lt;a href=&quot;https://git-scm.com/&quot;&gt;Git&lt;/a&gt;バージョン管理システムのコア機能を実装するポータブルCライブラリである&lt;a href=&quot;https://libgit2.org/&quot;&gt;libgit2&lt;/a&gt;へのバインディングを提供します。これらのバインディングは現在、Juliaのパッケージマネージャを強化するために使用されています。このモジュールは最終的には別のパッケージに移動される予定です。</target>
        </trans-unit>
        <trans-unit id="9bf2cc298d975bbd37b6f7fd047fb42694bf8a90" translate="yes" xml:space="preserve">
          <source>The MethodInstance containing the execution context (if it could be found).</source>
          <target state="translated">実行コンテキストを含む MethodInstance (見つけられた場合)。</target>
        </trans-unit>
        <trans-unit id="09f175ba6c5dae9885fb192f636fd6ea181b8da1" translate="yes" xml:space="preserve">
          <source>The MultiSelectMenu allows users to select many choices from a list.</source>
          <target state="translated">マルチセレクトメニューでは、リストから多くの選択肢を選択することができます。</target>
        </trans-unit>
        <trans-unit id="e79dc73e951d809603b22dcb8e0be503a1e70e20" translate="yes" xml:space="preserve">
          <source>The Perl expression needs to be in single quotes for two reasons: so that spaces don't break the expression into multiple shell words, and so that uses of Perl variables like &lt;code&gt;$|&lt;/code&gt; (yes, that's the name of a variable in Perl), don't cause interpolation. In other instances, you may want to use double quotes so that interpolation &lt;em&gt;does&lt;/em&gt; occur:</source>
          <target state="translated">Perl式は、2つの理由で単一引用符で囲む必要があります。スペースによって式が複数のシェルワードに分割されないようにするためと、 &lt;code&gt;$|&lt;/code&gt; ようなPerl変数を使用するためです。（はい、それはPerlの変数の名前です）、補間を引き起こしません。他の例では、補間&lt;em&gt;が&lt;/em&gt;行われるように二重引用符を使用したい場合が&lt;em&gt;あり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="ac56e6a222fd8496371258c1e3e6d866939f3927" translate="yes" xml:space="preserve">
          <source>The REPL has four main modes of operation. The first and most common is the Julian prompt. It is the default mode of operation; each new line initially starts with &lt;code&gt;julia&amp;gt;&lt;/code&gt;. It is here that you can enter Julia expressions. Hitting return or enter after a complete expression has been entered will evaluate the entry and show the result of the last expression.</source>
          <target state="translated">REPLには4つの主要な動作モードがあります。最初で最も一般的なのは、ユリウスプロンプトです。これはデフォルトの動作モードです。新しい各行は、最初は &lt;code&gt;julia&amp;gt;&lt;/code&gt; で始まります。ここにジュリア式を入力できます。完全な式が入力された後にReturnキーまたはEnterキーを押すと、エントリが評価され、最後の式の結果が表示されます。</target>
        </trans-unit>
        <trans-unit id="7b885d623b0799b11114ac06066f9470abd82025" translate="yes" xml:space="preserve">
          <source>The RadioMenu allows the user to select one option from the list. The &lt;code&gt;request&lt;/code&gt; function displays the interactive menu and returns the index of the selected choice. If a user presses 'q' or &lt;code&gt;ctrl-c&lt;/code&gt;, &lt;code&gt;request&lt;/code&gt; will return a &lt;code&gt;-1&lt;/code&gt;.</source>
          <target state="translated">RadioMenuを使用すると、ユーザーはリストから1つのオプションを選択できます。 &lt;code&gt;request&lt;/code&gt; 機能は、対話式メニューを表示し、選択された選択肢のインデックスを返します。ユーザーが 'q'または &lt;code&gt;ctrl-c&lt;/code&gt; を押すと、 &lt;code&gt;request&lt;/code&gt; は &lt;code&gt;-1&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="59e9b2d3e677af4a8fc2eebaa65445429cdf1c63" translate="yes" xml:space="preserve">
          <source>The Statistics module contains basic statistics functionality.</source>
          <target state="translated">Statistics モジュールには、基本的な統計機能が含まれています。</target>
        </trans-unit>
        <trans-unit id="05d7e2a5c0d018541c4ea58100e6545824bf9830" translate="yes" xml:space="preserve">
          <source>The ability to define function behavior across many combinations of argument types via &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;multiple dispatch&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;複数のディスパッチを&lt;/a&gt;介して引数タイプの多くの組み合わせにわたって関数の動作を定義する機能</target>
        </trans-unit>
        <trans-unit id="8cbecc736377010eae111d725b15330296dbcf5e" translate="yes" xml:space="preserve">
          <source>The above cross referencing is &lt;em&gt;not&lt;/em&gt; a Markdown feature, and relies on &lt;a href=&quot;https://github.com/JuliaDocs/Documenter.jl&quot;&gt;Documenter.jl&lt;/a&gt;, which is used to build base Julia's documentation.</source>
          <target state="translated">上記の相互参照はMarkdown機能では&lt;em&gt;なく&lt;/em&gt;、基本のJuliaのドキュメントの作成に使用される&lt;a href=&quot;https://github.com/JuliaDocs/Documenter.jl&quot;&gt;Documenter.jl&lt;/a&gt;に依存しています。</target>
        </trans-unit>
        <trans-unit id="96d64d7232abba83a2151348646c44806eda095b" translate="yes" xml:space="preserve">
          <source>The above mentioned functions can then be used to perform the queries:</source>
          <target state="translated">その後、上述の関数を使用してクエリを実行することができます。</target>
        </trans-unit>
        <trans-unit id="b1864a2a8cdc1de40a1915df6dd632015d943dc9" translate="yes" xml:space="preserve">
          <source>The above results are all &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values. Literal &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; values can be entered by writing an &lt;code&gt;f&lt;/code&gt; in place of &lt;code&gt;e&lt;/code&gt;:</source>
          <target state="translated">上記の結果はすべて&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;値です。リテラル&lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;値は、 &lt;code&gt;e&lt;/code&gt; の代わりに &lt;code&gt;f&lt;/code&gt; を記述することで入力できます。</target>
        </trans-unit>
        <trans-unit id="8361f38beb9f62ba5d41300ac34886cea61348b7" translate="yes" xml:space="preserve">
          <source>The above syntactic enhancements significantly reduce the visual noise incurred when writing common mathematical formulae. Note that no whitespace may come between a numeric literal coefficient and the identifier or parenthesized expression which it multiplies.</source>
          <target state="translated">上記の構文の強化により、一般的な数式を書く際に発生する視覚的なノイズが大幅に軽減されます。数値リテラル係数とそれを乗算する識別子や括弧で囲まれた式の間には空白が入ってはいけないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="60fe34a8f000c3fae237bc0700dfba4695829533" translate="yes" xml:space="preserve">
          <source>The above would transfer &lt;code&gt;foo&lt;/code&gt; only once to each worker.</source>
          <target state="translated">上記は、 &lt;code&gt;foo&lt;/code&gt; を各ワーカーに一度だけ転送します。</target>
        </trans-unit>
        <trans-unit id="b269bbaa9bb906bbb27460a932677dba11288dd6" translate="yes" xml:space="preserve">
          <source>The absolute path &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; of the REPL's history file. If &lt;code&gt;$JULIA_HISTORY&lt;/code&gt; is not set, then &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; defaults to</source>
          <target state="translated">REPLの履歴ファイルの絶対パス &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; 。 &lt;code&gt;$JULIA_HISTORY&lt;/code&gt; が設定されていない場合、 &lt;code&gt;REPL.find_hist_file()&lt;/code&gt; はデフォルトで</target>
        </trans-unit>
        <trans-unit id="3648e183f2c998051f65ea547854578d5a18dead" translate="yes" xml:space="preserve">
          <source>The absolute path of the directory containing the Julia executable, which sets the global variable &lt;a href=&quot;../../base/constants/index#Base.Sys.BINDIR&quot;&gt;&lt;code&gt;Sys.BINDIR&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;$JULIA_BINDIR&lt;/code&gt; is not set, then Julia determines the value &lt;code&gt;Sys.BINDIR&lt;/code&gt; at run-time.</source>
          <target state="translated">グローバル変数&lt;a href=&quot;../../base/constants/index#Base.Sys.BINDIR&quot;&gt; &lt;code&gt;Sys.BINDIR&lt;/code&gt; &lt;/a&gt;を設定するJulia実行可能ファイルを含むディレクトリの絶対パス。 &lt;code&gt;$JULIA_BINDIR&lt;/code&gt; が設定されていない場合、Julia は実行時に値 &lt;code&gt;Sys.BINDIR&lt;/code&gt; を決定します。</target>
        </trans-unit>
        <trans-unit id="8927a0d24697e123dd4df5a3afe112eef67df6d2" translate="yes" xml:space="preserve">
          <source>The absolute path of the shell with which Julia should execute external commands (via &lt;code&gt;Base.repl_cmd()&lt;/code&gt;). Defaults to the environment variable &lt;code&gt;$SHELL&lt;/code&gt;, and falls back to &lt;code&gt;/bin/sh&lt;/code&gt; if &lt;code&gt;$SHELL&lt;/code&gt; is unset.</source>
          <target state="translated">Juliaが（ &lt;code&gt;Base.repl_cmd()&lt;/code&gt; を介して）外部コマンドを実行するシェルの絶対パス。デフォルトは環境変数 &lt;code&gt;$SHELL&lt;/code&gt; 、 &lt;code&gt;$SHELL&lt;/code&gt; が設定されていない場合は &lt;code&gt;/bin/sh&lt;/code&gt; にフォールバックします。</target>
        </trans-unit>
        <trans-unit id="5eb992db79bc340c73f7d0c78a81caf2c5fb6b5d" translate="yes" xml:space="preserve">
          <source>The absolute value of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; の絶対値。</target>
        </trans-unit>
        <trans-unit id="8cc93eeda62c80f4972fdd152957671d0189f643" translate="yes" xml:space="preserve">
          <source>The abstract supertype of all enumerated types defined with &lt;a href=&quot;#Base.Enums.@enum&quot;&gt;&lt;code&gt;@enum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.Enums.@enum&quot;&gt; &lt;code&gt;@enum&lt;/code&gt; で&lt;/a&gt;定義されたすべての列挙型の抽象スーパータイプ。</target>
        </trans-unit>
        <trans-unit id="580f4961193cdce395b23ec3d5fef77701e0ce25" translate="yes" xml:space="preserve">
          <source>The actual body of the function is a single &lt;code&gt;leaq&lt;/code&gt; instruction, which computes the integer multiply and add at once. This is even more beneficial when &lt;code&gt;f&lt;/code&gt; gets inlined into another function:</source>
          <target state="translated">関数の実際の本体は、整数の乗算と加算を一度に計算する単一の &lt;code&gt;leaq&lt;/code&gt; 命令です。これは、 &lt;code&gt;f&lt;/code&gt; が別の関数にインライン化される場合にさらに有益です。</target>
        </trans-unit>
        <trans-unit id="b18e2a05bc75f9cb445304a890f63b9983ea2e1c" translate="yes" xml:space="preserve">
          <source>The actual definition of &lt;code&gt;@assert&lt;/code&gt; in Julia Base is more complicated. It allows the user to optionally specify their own error message, instead of just printing the failed expression. Just like in functions with a variable number of arguments (&lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt;), this is specified with an ellipses following the last argument:</source>
          <target state="translated">Julia Base での &lt;code&gt;@assert&lt;/code&gt; の実際の定義はより複雑です。これにより、ユーザーは、失敗した式を出力するだけでなく、オプションで独自のエラーメッセージを指定できます。可変数の引数を&lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;持つ関数&lt;/a&gt;（Varargs関数）と同様に、これは最後の引数に続く省略記号で指定されます。</target>
        </trans-unit>
        <trans-unit id="3249b07e810b7bf455aef815d32c41a4e16eda1a" translate="yes" xml:space="preserve">
          <source>The addition of a &lt;code&gt;Date&lt;/code&gt; with a &lt;code&gt;Time&lt;/code&gt; produces a &lt;code&gt;DateTime&lt;/code&gt;. The hour, minute, second, and millisecond parts of the &lt;code&gt;Time&lt;/code&gt; are used along with the year, month, and day of the &lt;code&gt;Date&lt;/code&gt; to create the new &lt;code&gt;DateTime&lt;/code&gt;. Non-zero microseconds or nanoseconds in the &lt;code&gt;Time&lt;/code&gt; type will result in an &lt;code&gt;InexactError&lt;/code&gt; being thrown.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; に &lt;code&gt;Time&lt;/code&gt; を追加すると、 &lt;code&gt;DateTime&lt;/code&gt; が生成されます。 &lt;code&gt;Time&lt;/code&gt; の時間、分、秒、ミリ秒の部分が、 &lt;code&gt;Date&lt;/code&gt; の年、​​月、日とともに使用され、新しい &lt;code&gt;DateTime&lt;/code&gt; が作成されます。 &lt;code&gt;Time&lt;/code&gt; 型がゼロ以外のマイクロ秒またはナノ秒の場合、 &lt;code&gt;InexactError&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="0e0f2aeb81b016f9f8ad15cc7fa177089d4b107f" translate="yes" xml:space="preserve">
          <source>The advantage is that your testing code is now contained in a module and does not use the global scope in &lt;code&gt;Main&lt;/code&gt; for definitions, which is a bit more tidy.</source>
          <target state="translated">利点は、テストコードがモジュールに含まれ、 &lt;code&gt;Main&lt;/code&gt; のグローバルスコープを定義に使用しないことです。これは少し整然としています。</target>
        </trans-unit>
        <trans-unit id="f20a70b4f6a41daccbadde162c2965a4719810ba" translate="yes" xml:space="preserve">
          <source>The algorithm returns an estimator of the generative distribution's standard deviation under the assumption that each entry of &lt;code&gt;itr&lt;/code&gt; is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating &lt;code&gt;sqrt(sum((itr .- mean(itr)).^2) / (length(itr) - 1))&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; the number of elements in &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">アルゴリズムは、 &lt;code&gt;itr&lt;/code&gt; の各エントリがその生成分布から抽出されたIID であるという仮定の下で、生成分布の標準偏差の推定量を返します。配列の場合、この計算は &lt;code&gt;sqrt(sum((itr .- mean(itr)).^2) / (length(itr) - 1))&lt;/code&gt; を計算することと同じです。場合 &lt;code&gt;corrected&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 、次いで合計がでスケーリングされた &lt;code&gt;n-1&lt;/code&gt; 和を用いてスケーリングされるのに対して、 &lt;code&gt;n&lt;/code&gt; 場合に &lt;code&gt;corrected&lt;/code&gt; され &lt;code&gt;false&lt;/code&gt; と &lt;code&gt;n&lt;/code&gt; 個の要素の数 &lt;code&gt;itr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e5d718f1e39513cb56beb2116bcad02f80b82c53" translate="yes" xml:space="preserve">
          <source>The algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of &lt;code&gt;itr&lt;/code&gt; is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)). If&lt;/code&gt;corrected&lt;code&gt;is&lt;/code&gt;true&lt;code&gt;, then the sum is scaled with&lt;/code&gt;n-1&lt;code&gt;, whereas the sum is scaled with&lt;/code&gt;n&lt;code&gt;if&lt;/code&gt;corrected&lt;code&gt;is&lt;/code&gt;false&lt;code&gt;with&lt;/code&gt;n&lt;code&gt;the number of elements in&lt;/code&gt;itr`.</source>
          <target state="translated">アルゴリズムは、 &lt;code&gt;itr&lt;/code&gt; の各エントリがその生成分布から抽出されたIID であるという仮定の下で、生成分布の分散の推定量を返します。配列の場合、この計算は &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)). If&lt;/code&gt; を計算することと同じです。場合修正が &lt;code&gt;is&lt;/code&gt; 真 &lt;code&gt;, then the sum is scaled with&lt;/code&gt; N-1個の &lt;code&gt;, whereas the sum is scaled with&lt;/code&gt; N &lt;code&gt;if&lt;/code&gt; 補正 &lt;code&gt;is&lt;/code&gt; 、偽 &lt;code&gt;with&lt;/code&gt; n個 &lt;code&gt;the number of elements in&lt;/code&gt; itr`。</target>
        </trans-unit>
        <trans-unit id="01293a961a773cd4d130208dbabeea56d0a5c61c" translate="yes" xml:space="preserve">
          <source>The algorithm returns an estimator of the generative distribution's variance under the assumption that each entry of &lt;code&gt;itr&lt;/code&gt; is an IID drawn from that generative distribution. For arrays, this computation is equivalent to calculating &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; with &lt;code&gt;n&lt;/code&gt; the number of elements in &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">アルゴリズムは、 &lt;code&gt;itr&lt;/code&gt; の各エントリがその生成分布から抽出されたIID であるという仮定の下で、生成分布の分散の推定量を返します。配列の場合、この計算は &lt;code&gt;sum((itr .- mean(itr)).^2) / (length(itr) - 1)&lt;/code&gt; を計算することと同じです。場合 &lt;code&gt;corrected&lt;/code&gt; ある &lt;code&gt;true&lt;/code&gt; 、次いで合計がでスケーリングされた &lt;code&gt;n-1&lt;/code&gt; 和を用いてスケーリングされるのに対して、 &lt;code&gt;n&lt;/code&gt; 場合に &lt;code&gt;corrected&lt;/code&gt; され &lt;code&gt;false&lt;/code&gt; と &lt;code&gt;n&lt;/code&gt; 個の要素の数 &lt;code&gt;itr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bac2877c35123766a145f522e7dfc5430f0ca77c" translate="yes" xml:space="preserve">
          <source>The analogue of extracting (or &quot;dereferencing&quot;) all elements of a cell array, e.g. in &lt;code&gt;vertcat(A{:})&lt;/code&gt; in MATLAB, is written using the splat operator in Julia, e.g. as &lt;code&gt;vcat(A...)&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;vertcat(A{:})&lt;/code&gt; セル配列のすべての要素を抽出（または「逆参照」）するのと同様に、ジュリアの &lt;code&gt;vcat(A...)&lt;/code&gt; 演算子を使用して、たとえばvcat（A ...）として記述されます。</target>
        </trans-unit>
        <trans-unit id="f3f2e21d1a797762aaea13aa49c6c7d374ab6e23" translate="yes" xml:space="preserve">
          <source>The annotation &lt;code&gt;@fastmath&lt;/code&gt; re-arranges floating point expressions, e.g. changing the order of evaluation, or assuming that certain special cases (inf, nan) cannot occur. In this case (and on this particular computer), the main difference is that the expression &lt;code&gt;1 / (2*dx)&lt;/code&gt; in the function &lt;code&gt;deriv&lt;/code&gt; is hoisted out of the loop (i.e. calculated outside the loop), as if one had written &lt;code&gt;idx = 1 / (2*dx)&lt;/code&gt;. In the loop, the expression &lt;code&gt;... / (2*dx)&lt;/code&gt; then becomes &lt;code&gt;... * idx&lt;/code&gt;, which is much faster to evaluate. Of course, both the actual optimization that is applied by the compiler as well as the resulting speedup depend very much on the hardware. You can examine the change in generated code by using Julia's &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_native&quot;&gt;&lt;code&gt;code_native&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">注釈 &lt;code&gt;@fastmath&lt;/code&gt; は、評価の順序を変更したり、特定の特殊なケース（inf、nan）が発生しないと仮定したりして、浮動小数点式を再配置します。この場合（およびこの特定のコンピューター）の主な違いは、関数 &lt;code&gt;deriv&lt;/code&gt; の式 &lt;code&gt;1 / (2*dx)&lt;/code&gt; がループの外に引き上げられる（つまり、ループの外側で計算される）かのように、 &lt;code&gt;idx = 1 / (2*dx)&lt;/code&gt; 。ループでは、式 &lt;code&gt;... / (2*dx)&lt;/code&gt; は &lt;code&gt;... * idx&lt;/code&gt; なります。、評価がはるかに高速です。もちろん、コンパイラーによって適用される実際の最適化とその結果のスピードアップは、ハードウェアに大きく依存します。Juliaの&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_native&quot;&gt; &lt;code&gt;code_native&lt;/code&gt; &lt;/a&gt;関数を使用して、生成されたコードの変更を確認できます。</target>
        </trans-unit>
        <trans-unit id="91407676de179a11323fecebc90b0b28f6220397" translate="yes" xml:space="preserve">
          <source>The application also depends on the &lt;code&gt;Pub&lt;/code&gt; package, which in turn depends on the public &lt;code&gt;Priv&lt;/code&gt; and the same &lt;code&gt;Zebra&lt;/code&gt; package that the private &lt;code&gt;Priv&lt;/code&gt; package depends on.</source>
          <target state="translated">アプリケーションは、 &lt;code&gt;Pub&lt;/code&gt; パッケージにも依存しています &lt;code&gt;Priv&lt;/code&gt; パッケージは、パブリック &lt;code&gt;Priv&lt;/code&gt; と、プライベートPrivパッケージが依存するのと同じ &lt;code&gt;Zebra&lt;/code&gt; パッケージに依存しています。</target>
        </trans-unit>
        <trans-unit id="d108508038e64416f7594e79cff0ba0d5c60ed1c" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;A&lt;/code&gt; should &lt;em&gt;not&lt;/em&gt; be a matrix. Rather, instead of matrices it should be a factorization object (e.g. produced by &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., &lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt;&lt;code&gt;lu!&lt;/code&gt;&lt;/a&gt;), and performance-critical situations requiring &lt;code&gt;ldiv!&lt;/code&gt; usually also require fine-grained control over the factorization of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">引数 &lt;code&gt;A&lt;/code&gt; は行列であって&lt;em&gt;は&lt;/em&gt;なりませ&lt;em&gt;ん&lt;/em&gt;。むしろ、行列の代わりに因子分解オブジェクト（たとえば、&lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; &lt;/a&gt;によって生成されたもの）である必要があります。この理由は、因数分解自体が高価であり、通常はメモリを割り当てるためです（ただし、&lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt; &lt;code&gt;lu!&lt;/code&gt; など&lt;/a&gt;を介してインプレースで実行することもできます）、および &lt;code&gt;ldiv!&lt;/code&gt; 通常、 &lt;code&gt;A&lt;/code&gt; の因数分解に対するきめ細かい制御も必要です。</target>
        </trans-unit>
        <trans-unit id="8ba5f6815e327ac58578c3c74637303b6ebdc780" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;B&lt;/code&gt; should &lt;em&gt;not&lt;/em&gt; be a matrix. Rather, instead of matrices it should be a factorization object (e.g. produced by &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;). The reason for this is that factorization itself is both expensive and typically allocates memory (although it can also be done in-place via, e.g., &lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt;&lt;code&gt;lu!&lt;/code&gt;&lt;/a&gt;), and performance-critical situations requiring &lt;code&gt;rdiv!&lt;/code&gt; usually also require fine-grained control over the factorization of &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">引数 &lt;code&gt;B&lt;/code&gt; は行列であって&lt;em&gt;は&lt;/em&gt;なりませ&lt;em&gt;ん&lt;/em&gt;。むしろ、行列の代わりに因子分解オブジェクト（たとえば、&lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; &lt;/a&gt;によって生成されたもの）である必要があります。これは、分解自体が高価であり、通常はメモリを割り当てるためです（ただし、&lt;a href=&quot;#LinearAlgebra.lu!&quot;&gt; &lt;code&gt;lu!&lt;/code&gt; など&lt;/a&gt;を使用してインプレースで実行することもできます）。また、 &lt;code&gt;rdiv!&lt;/code&gt; 通常、 &lt;code&gt;B&lt;/code&gt; の因数分解に対するきめ細かい制御も必要です。</target>
        </trans-unit>
        <trans-unit id="f6947ba42284e98465ca0fe899c7260684fa80d0" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;__module__&lt;/code&gt; provides information (in the form of a &lt;code&gt;Module&lt;/code&gt; object) about the expansion context of the macro invocation. This allows macros to look up contextual information, such as existing bindings, or to insert the value as an extra argument to a runtime function call doing self-reflection in the current module.</source>
          <target state="translated">引数 &lt;code&gt;__module__&lt;/code&gt; は、マクロ呼び出しの展開コンテキストに関する情報（ &lt;code&gt;Module&lt;/code&gt; オブジェクトの形式）を提供します。これにより、マクロは、既存のバインディングなどのコンテキスト情報を検索したり、現在のモジュールで自己反映を行うランタイム関数呼び出しに追加の引数として値を挿入したりできます。</target>
        </trans-unit>
        <trans-unit id="118cff9af4b8de3b0527244748b6b6cdd9ccdeb6" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;__source__&lt;/code&gt; provides information (in the form of a &lt;code&gt;LineNumberNode&lt;/code&gt; object) about the parser location of the &lt;code&gt;@&lt;/code&gt; sign from the macro invocation. This allows macros to include better error diagnostic information, and is commonly used by logging, string-parser macros, and docs, for example, as well as to implement the &lt;a href=&quot;../../base/file/index#Base.@__LINE__&quot;&gt;&lt;code&gt;@__LINE__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/file/index#Base.@__FILE__&quot;&gt;&lt;code&gt;@__FILE__&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/file/index#Base.@__DIR__&quot;&gt;&lt;code&gt;@__DIR__&lt;/code&gt;&lt;/a&gt; macros.</source>
          <target state="translated">引数 &lt;code&gt;__source__&lt;/code&gt; は、マクロ呼び出しからの &lt;code&gt;@&lt;/code&gt; 記号のパーサーの場所に関する情報（ &lt;code&gt;LineNumberNode&lt;/code&gt; オブジェクトの形式）を提供します。これにより、マクロにより適切なエラー診断情報を含めることができ、ロギング、文字列パーサーマクロ、ドキュメントなどで一般的に使用されます。また、&lt;a href=&quot;../../base/file/index#Base.@__FILE__&quot;&gt; &lt;code&gt;@__FILE__&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../base/file/index#Base.@__LINE__&quot;&gt; &lt;code&gt;@__LINE__&lt;/code&gt; &lt;/a&gt;、@__FILE__、および&lt;a href=&quot;../../base/file/index#Base.@__DIR__&quot;&gt; &lt;code&gt;@__DIR__&lt;/code&gt; &lt;/a&gt;マクロを実装することもできます。</target>
        </trans-unit>
        <trans-unit id="28332afec21b48c8f9eedddb529063711d48dde4" translate="yes" xml:space="preserve">
          <source>The argument &lt;code&gt;val&lt;/code&gt; to a function or constructor is outside the valid domain.</source>
          <target state="translated">関数またはコンストラクターへの引数 &lt;code&gt;val&lt;/code&gt; が有効なドメインの外にあります。</target>
        </trans-unit>
        <trans-unit id="c5eb1e5a4cdcda6110ebd89f0ecb14ceede7e9cb" translate="yes" xml:space="preserve">
          <source>The argument goes on the &lt;em&gt;left&lt;/em&gt; side of a matrix-matrix operation.</source>
          <target state="translated">引数は、行列-行列演算の&lt;em&gt;左側&lt;/em&gt;にあります。</target>
        </trans-unit>
        <trans-unit id="7b59a99385d1b11a2ad5b866d4ec7b5957c8ab4c" translate="yes" xml:space="preserve">
          <source>The argument goes on the &lt;em&gt;right&lt;/em&gt; side of a matrix-matrix operation.</source>
          <target state="translated">引数は、行列-行列演算の&lt;em&gt;右側&lt;/em&gt;にあります。</target>
        </trans-unit>
        <trans-unit id="884d75c174d0479198ef02863fa90299587b8335" translate="yes" xml:space="preserve">
          <source>The array data must be represented in binary format (e.g., an ASCII format like CSV cannot be supported)</source>
          <target state="translated">配列データはバイナリ形式で表現されなければなりません(例えば、CSVのようなASCII形式はサポートされません)。</target>
        </trans-unit>
        <trans-unit id="b10872dab02eb4daf575beb40c2f7b4e9635a0b7" translate="yes" xml:space="preserve">
          <source>The asserted condition did not evaluate to &lt;code&gt;true&lt;/code&gt;. Optional argument &lt;code&gt;msg&lt;/code&gt; is a descriptive error string.</source>
          <target state="translated">アサートされた条件は &lt;code&gt;true&lt;/code&gt; と評価されませんでした。オプションの引数 &lt;code&gt;msg&lt;/code&gt; は説明的なエラー文字列です。</target>
        </trans-unit>
        <trans-unit id="9ef046749eb00971a20635012815c9aa3fe8e4de" translate="yes" xml:space="preserve">
          <source>The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like &lt;code&gt;let x = x&lt;/code&gt; since the two &lt;code&gt;x&lt;/code&gt; variables are distinct and have separate storage. Here is an example where the behavior of &lt;code&gt;let&lt;/code&gt; is needed:</source>
          <target state="translated">割り当ては順番に評価され、左側の新しい変数が導入される前に、各右側がスコープで評価されます。したがって、2つの &lt;code&gt;x&lt;/code&gt; 変数は異なり、別々のストレージを持っているので、 &lt;code&gt;let x = x&lt;/code&gt; ようなものを書くのは理にかなっています。 &lt;code&gt;let&lt;/code&gt; の動作が必要な例を次に示します。</target>
        </trans-unit>
        <trans-unit id="332e2ebabecf595b9a10dedb9752fafc32737dcf" translate="yes" xml:space="preserve">
          <source>The assignments are evaluated in order, with each right-hand side evaluated in the scope before the new variable on the left-hand side has been introduced. Therefore it makes sense to write something like &lt;code&gt;let x = x&lt;/code&gt;, since the two &lt;code&gt;x&lt;/code&gt; variables are distinct and have separate storage.</source>
          <target state="translated">割り当ては順番に評価され、左側の新しい変数が導入される前に、各右側がスコープで評価されます。したがって、2つの &lt;code&gt;x&lt;/code&gt; 変数は異なり、別々のストレージを持っているので、 &lt;code&gt;let x = x&lt;/code&gt; ようなものを書くのは理にかなっています。</target>
        </trans-unit>
        <trans-unit id="cb5c5acb0ed1217a3a242c8796f09db063ffe31c" translate="yes" xml:space="preserve">
          <source>The associativity of the reduction is implementation dependent. This means that you can't use non-associative operations like &lt;code&gt;-&lt;/code&gt; because it is undefined whether &lt;code&gt;reduce(-,[1,2,3])&lt;/code&gt; should be evaluated as &lt;code&gt;(1-2)-3&lt;/code&gt; or &lt;code&gt;1-(2-3)&lt;/code&gt;. Use &lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldl&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldr&lt;/code&gt;&lt;/a&gt; instead for guaranteed left or right associativity.</source>
          <target state="translated">削減の関連性は実装に依存します。つまり、 &lt;code&gt;reduce(-,[1,2,3])&lt;/code&gt; を &lt;code&gt;(1-2)-3&lt;/code&gt; と評価するか &lt;code&gt;1-(2-3)&lt;/code&gt; と評価するかは定義されていないため、 &lt;code&gt;-&lt;/code&gt; のような非結合演算は使用できません。。左または右の結合性を保証するために、代わりに&lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldl&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldr&lt;/code&gt; を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="8e83411f941380eef1e4e97a62a5d00092492f0f" translate="yes" xml:space="preserve">
          <source>The associativity of the reduction is implementation-dependent. Additionally, some implementations may reuse the return value of &lt;code&gt;f&lt;/code&gt; for elements that appear multiple times in &lt;code&gt;itr&lt;/code&gt;. Use &lt;a href=&quot;#Base.mapfoldl-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapfoldl&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.mapfoldr-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapfoldr&lt;/code&gt;&lt;/a&gt; instead for guaranteed left or right associativity and invocation of &lt;code&gt;f&lt;/code&gt; for every value.</source>
          <target state="translated">削減の関連性は実装に依存します。さらに、実装によっては、 &lt;code&gt;itr&lt;/code&gt; に複数回出現する要素 &lt;code&gt;f&lt;/code&gt; の戻り値を再利用する場合があります。使用&lt;a href=&quot;#Base.mapfoldl-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapfoldl&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;#Base.mapfoldr-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapfoldr&lt;/code&gt; &lt;/a&gt;代わりのための保証右または左結合性との呼び出し &lt;code&gt;f&lt;/code&gt; 値ごと。</target>
        </trans-unit>
        <trans-unit id="fa2ffdac4b6b173468c64bdf00df48adef8f3782" translate="yes" xml:space="preserve">
          <source>The available color keys can be seen by typing &lt;code&gt;Base.text_colors&lt;/code&gt; in the help mode of the REPL. In addition, the integers 0 to 255 can be used as color keys for terminals with 256 color support.</source>
          <target state="translated">使用可能なカラーキーは、REPLのヘルプモードで &lt;code&gt;Base.text_colors&lt;/code&gt; と入力すると確認できます。さらに、0〜255の整数は、256色をサポートする端末のカラーキーとして使用できます。</target>
        </trans-unit>
        <trans-unit id="d6514960ce535f34b9eb969fcb1b4f9c39742102" translate="yes" xml:space="preserve">
          <source>The base Julia installation has in-built support for two types of clusters:</source>
          <target state="translated">ベースとなるJuliaのインストールでは、2種類のクラスタのサポートが組み込まれています。</target>
        </trans-unit>
        <trans-unit id="562f643f12db492fbdb1e985351909d826402fa4" translate="yes" xml:space="preserve">
          <source>The base Julia runtime provides only plain-text display, but richer displays may be enabled by loading external modules or by using graphical Julia environments (such as the IPython-based IJulia notebook).</source>
          <target state="translated">基本のJuliaランタイムはプレーンテキスト表示のみを提供していますが、外部モジュールをロードしたり、グラフィカルなJulia環境(IPythonベースのIJuliaノートブックなど)を使用することで、よりリッチな表示を可能にすることができます。</target>
        </trans-unit>
        <trans-unit id="002dc05c0d427615b628a5faca800a873b359de7" translate="yes" xml:space="preserve">
          <source>The base array type in Julia is the abstract type &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray{T,N}&lt;/code&gt;&lt;/a&gt;. It is parameterized by the number of dimensions &lt;code&gt;N&lt;/code&gt; and the element type &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;../../base/arrays/index#Base.AbstractVector&quot;&gt;&lt;code&gt;AbstractVector&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.AbstractMatrix&quot;&gt;&lt;code&gt;AbstractMatrix&lt;/code&gt;&lt;/a&gt; are aliases for the 1-d and 2-d cases. Operations on &lt;code&gt;AbstractArray&lt;/code&gt; objects are defined using higher level operators and functions, in a way that is independent of the underlying storage. These operations generally work correctly as a fallback for any specific array implementation.</source>
          <target state="translated">Juliaの基本配列型は、抽象型&lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray{T,N}&lt;/code&gt; &lt;/a&gt;です。次元数 &lt;code&gt;N&lt;/code&gt; および要素タイプ &lt;code&gt;T&lt;/code&gt; によってパラメーター化されます。&lt;a href=&quot;../../base/arrays/index#Base.AbstractVector&quot;&gt; &lt;code&gt;AbstractVector&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../base/arrays/index#Base.AbstractMatrix&quot;&gt; &lt;code&gt;AbstractMatrix&lt;/code&gt; &lt;/a&gt;は、1次元および2次元の場合のエイリアスです。 &lt;code&gt;AbstractArray&lt;/code&gt; オブジェクトの操作は、基礎となるストレージに依存しない方法で、より高いレベルの演算子と関数を使用して定義されます。これらの操作は通常、特定のアレイ実装のフォールバックとして正しく機能します。</target>
        </trans-unit>
        <trans-unit id="b29d93a344c231f0373e8777552dd842d0c0ae6b" translate="yes" xml:space="preserve">
          <source>The base library of Julia. &lt;code&gt;Base&lt;/code&gt; is a module that contains basic functionality (the contents of &lt;code&gt;base/&lt;/code&gt;). All modules implicitly contain &lt;code&gt;using Base&lt;/code&gt;, since this is needed in the vast majority of cases.</source>
          <target state="translated">ジュリアのベースライブラリ。 &lt;code&gt;Base&lt;/code&gt; は、基本的な機能（ &lt;code&gt;base/&lt;/code&gt; コンテンツ）を含むモジュールです。ほとんどの場合これが必要であるため、すべてのモジュールには &lt;code&gt;using Base&lt;/code&gt; 暗黙的に含まれています。</target>
        </trans-unit>
        <trans-unit id="f9d1c85fa2408916e8a238b5528b77d6327d21e9" translate="yes" xml:space="preserve">
          <source>The basic function for waiting for an event is &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;. Several objects implement &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;; for example, given a &lt;code&gt;Process&lt;/code&gt; object, &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; will wait for it to exit. &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; is often implicit; for example, a &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; can happen inside a call to &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; to wait for data to be available.</source>
          <target state="translated">イベントを待機するための基本的な機能は、&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;です。いくつかのオブジェクトは&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;実装しています。たとえば、 &lt;code&gt;Process&lt;/code&gt; オブジェクトが指定された場合、&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;は終了するまで待機します。&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;はしばしば暗黙的です。たとえば、&lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; の&lt;/a&gt;呼び出し内でデータが利用可能になるのを待つために&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="38afa5a3f5d12c0c2e4c45c469ff70f9f6584c66" translate="yes" xml:space="preserve">
          <source>The basic syntax is simple: any string appearing at the top-level right before an object (function, macro, type or instance) will be interpreted as documenting it (these are called &lt;em&gt;docstrings&lt;/em&gt;). Note that no blank lines or comments may intervene between a docstring and the documented object. Here is a basic example:</source>
          <target state="translated">基本的な構文は単純です。オブジェクト（関数、マクロ、タイプ、またはインスタンス）の直前のトップレベルにある文字列は、それを文書化していると解釈されます（これらは&lt;em&gt;docstrings&lt;/em&gt;と呼ばれます）。docstringとドキュメント化されたオブジェクトの間に空白行やコメントを入れないでください。基本的な例を次に示します。</target>
        </trans-unit>
        <trans-unit id="3e6788f6ee76ef14250b1c48634160dc28850751" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;missing&lt;/code&gt; values follows one basic rule: &lt;code&gt;missing&lt;/code&gt; values &lt;em&gt;propagate&lt;/em&gt; automatically when passed to standard operators and functions, in particular mathematical functions. Uncertainty about the value of one of the operands induces uncertainty about the result. In practice, this means an operation involving a &lt;code&gt;missing&lt;/code&gt; value generally returns &lt;code&gt;missing&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;missing&lt;/code&gt; 値の動作は1つの基本的なルールに従います。 &lt;code&gt;missing&lt;/code&gt; 値は、標準の演算子と関数、特に数学関数に渡されると自動的に&lt;em&gt;伝播し&lt;/em&gt;ます。オペランドの1つの値に関する不確実性は、結果に関する不確実性を引き起こします。実際には、これは関係する操作を意味 &lt;code&gt;missing&lt;/code&gt; 値は、一般的に返し &lt;code&gt;missing&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7e648e6d6c87b02acc6c1db84cf592e9a9a93a8" translate="yes" xml:space="preserve">
          <source>The behavior of the logical &quot;and&quot; operator &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt; is similar to that of the &lt;code&gt;|&lt;/code&gt; operator, with the difference that missingness does not propagate when one of the operands is &lt;code&gt;false&lt;/code&gt;. For example, when that is the case of the first operand</source>
          <target state="translated">論理的な「and」演算子&lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt;の動作は、 &lt;code&gt;|&lt;/code&gt; の動作に似ています。演算子。ただし、オペランドの1つが &lt;code&gt;false&lt;/code&gt; の場合、欠落は伝播しません。たとえば、それが第1オペランドの場合</target>
        </trans-unit>
        <trans-unit id="7b67ccc64e36fcf07f7c05aa43c8c2a633077f18" translate="yes" xml:space="preserve">
          <source>The best approach is to avoid defining &lt;em&gt;either&lt;/em&gt; of these methods: instead, rely on a generic method &lt;code&gt;-(A::AbstractArray, b)&lt;/code&gt; and make sure this method is implemented with generic calls (like &lt;code&gt;similar&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;) that do the right thing for each container type and element type &lt;em&gt;separately&lt;/em&gt;. This is just a more complex variant of the advice to &lt;a href=&quot;#man-methods-orthogonalize-1&quot;&gt;orthogonalize&lt;/a&gt; your methods.</source>
          <target state="translated">最善のアプローチは、定義を避けるためにある&lt;em&gt;いずれかの&lt;/em&gt;代わりに、一般的な方法に依存している：これらの方法のうちの &lt;code&gt;-(A::AbstractArray, b)&lt;/code&gt; と必ずこのメソッドは、（のような一般的な呼び出しで実装されていることを確認 &lt;code&gt;similar&lt;/code&gt; や &lt;code&gt;-&lt;/code&gt; ）のために正しいことを行います各コンテナタイプと要素タイプは&lt;em&gt;別々に&lt;/em&gt;。これは、メソッドを&lt;a href=&quot;#man-methods-orthogonalize-1&quot;&gt;直交化&lt;/a&gt;するためのアドバイスのより複雑な変形です。</target>
        </trans-unit>
        <trans-unit id="d958f10307af7b028b81ab80b4d640f64af23b08" translate="yes" xml:space="preserve">
          <source>The better design would be to define your call hierarchy like this:</source>
          <target state="translated">より良いデザインは、このようにコールの階層を定義することです。</target>
        </trans-unit>
        <trans-unit id="3983e66c166493bdb9b9e27ea74aedeb9d2d8cf1" translate="yes" xml:space="preserve">
          <source>The biggest advantage of &lt;code&gt;advection_shared!&lt;/code&gt; is that it minimizes traffic among the workers, allowing each to compute for an extended time on the assigned piece.</source>
          <target state="translated">&lt;code&gt;advection_shared!&lt;/code&gt; の最大の利点！ワーカー間のトラフィックを最小限に抑え、それぞれが割り当てられた部分で長時間計算できるようにすることです。</target>
        </trans-unit>
        <trans-unit id="194659e7083e920d17f0c59327a653e32e8cfe4a" translate="yes" xml:space="preserve">
          <source>The binary operator &lt;code&gt;&amp;asymp;&lt;/code&gt; is equivalent to &lt;code&gt;isapprox&lt;/code&gt; with the default arguments, and &lt;code&gt;x ≉ y&lt;/code&gt; is equivalent to &lt;code&gt;!isapprox(x,y)&lt;/code&gt;.</source>
          <target state="translated">二項演算子は、 &lt;code&gt;&amp;asymp;&lt;/code&gt; と同等です &lt;code&gt;isapprox&lt;/code&gt; デフォルト引数を持つ、および &lt;code&gt;x ≉ y&lt;/code&gt; 同等です &lt;code&gt;!isapprox(x,y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ba294c6e25bcc46b7feed1d1a73c0b3e0ef49e3" translate="yes" xml:space="preserve">
          <source>The blank lines actually have spaces on them. Fortunately, the above awkward idiom is unnecessary for iterating through the characters in a string, since you can just use the string as an iterable object, no exception handling required:</source>
          <target state="translated">空行には実際にスペースが入っています。幸いなことに、文字列の中の文字を繰り返し処理する場合には、上記のような厄介な慣用句は必要ありません。</target>
        </trans-unit>
        <trans-unit id="586252847b0a965d3d0a5b40259b311ee19d7146" translate="yes" xml:space="preserve">
          <source>The broadcast style is computed for every broadcasting operation to allow for dispatch and specialization. The actual allocation of the result array is handled by &lt;code&gt;similar&lt;/code&gt;, using the Broadcasted object as its first argument.</source>
          <target state="translated">ブロードキャストスタイルは、ディスパッチと特殊化を考慮して、すべてのブロードキャスト操作に対して計算されます。結果配列の実際の割り当ては、Broadcastedオブジェクトを最初の引数として使用して、 &lt;code&gt;similar&lt;/code&gt; に処理されます。</target>
        </trans-unit>
        <trans-unit id="5232abbd2579e189a3c4536c48fbc58adcc52edd" translate="yes" xml:space="preserve">
          <source>The built-in concrete type used for strings (and string literals) in Julia is &lt;code&gt;String&lt;/code&gt;. This supports the full range of &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt; characters via the &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt; encoding. (A &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt;&lt;code&gt;transcode&lt;/code&gt;&lt;/a&gt; function is provided to convert to/from other Unicode encodings.)</source>
          <target state="translated">Juliaで文字列（および文字列リテラル）に使用される組み込み具象型は &lt;code&gt;String&lt;/code&gt; です。これは、&lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt;エンコーディングを介してすべての&lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt;文字をサポートします。（&lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt; &lt;code&gt;transcode&lt;/code&gt; &lt;/a&gt;関数は、他のUnicodeエンコーディングとの間で変換するために提供されています。）</target>
        </trans-unit>
        <trans-unit id="dc25d16dd1aba7b0c5bea6b12ba6118124030ae4" translate="yes" xml:space="preserve">
          <source>The byte offset of field &lt;code&gt;i&lt;/code&gt; of a type relative to the data start. For example, we could use it in the following manner to summarize information about a struct:</source>
          <target state="translated">データ開始に関連するタイプのフィールド &lt;code&gt;i&lt;/code&gt; のバイトオフセット。たとえば、次のように使用して、構造体に関する情報を要約できます。</target>
        </trans-unit>
        <trans-unit id="df22a65b46868ee938e0477154f053724ad2e34c" translate="yes" xml:space="preserve">
          <source>The callback you pass to C should only execute a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;:uv_async_send&lt;/code&gt;, passing &lt;code&gt;cond.handle&lt;/code&gt; as the argument, taking care to avoid any allocations or other interactions with the Julia runtime.</source>
          <target state="translated">あなたがCに渡すコールバックにのみ実行する必要があり&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; を&lt;/a&gt;する &lt;code&gt;:uv_async_send&lt;/code&gt; 渡し、 &lt;code&gt;cond.handle&lt;/code&gt; をジュリアランタイムで任意の割り当てまたは他の相互作用を避けるように注意しながら、引数として。</target>
        </trans-unit>
        <trans-unit id="b1e65b00ae78a0300e89eb33901bc2c6dff08184" translate="yes" xml:space="preserve">
          <source>The caller must be holding the &lt;a href=&quot;#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; that owns &lt;code&gt;c&lt;/code&gt; before calling this method. The calling task will be blocked until some other task wakes it, usually by calling &lt;a href=&quot;#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt;` on the same Condition object. The lock will be atomically released when blocking (even if it was locked recursively), and will be reacquired before returning.</source>
          <target state="translated">呼び出し元は、このメソッドを呼び出す前に、 &lt;code&gt;c&lt;/code&gt; を所有する&lt;a href=&quot;#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;を保持している必要があります。呼び出しタスクは、他のタスクがそれを起こすまでブロックされます。通常は、同じConditionオブジェクトで&lt;a href=&quot;#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt;を呼び出します。ロックは（再帰的にロックされた場合でも）ブロック時にアトミックに解放され、戻る前に再取得されます。</target>
        </trans-unit>
        <trans-unit id="b9769cfc324c619140bf4882f569b4d5be45feda" translate="yes" xml:space="preserve">
          <source>The case of &lt;code&gt;rand&lt;/code&gt; is a bit more complex as we have to ensure that each thread uses non-overlapping pseudorandom number sequences. This can be simply ensured by using &lt;code&gt;Future.randjump&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;rand&lt;/code&gt; の場合は、各スレッドが重複しない疑似乱数シーケンスを使用するようにする必要があるため、少し複雑です。これは、 &lt;code&gt;Future.randjump&lt;/code&gt; 関数を使用して簡単に確認できます。</target>
        </trans-unit>
        <trans-unit id="5555fa452d0454119cd31b5aa3d13eec12b96796" translate="yes" xml:space="preserve">
          <source>The channels example from above can be modified for interprocess communication, as shown below.</source>
          <target state="translated">上記のチャンネル例は、以下に示すように、プロセス間通信のために変更することができる。</target>
        </trans-unit>
        <trans-unit id="89b722bb0d4e7814b2f6957c408ca31cc4584902" translate="yes" xml:space="preserve">
          <source>The choice of which method to execute when a function is applied is called &lt;em&gt;dispatch&lt;/em&gt;. Julia allows the dispatch process to choose which of a function's methods to call based on the number of arguments given, and on the types of all of the function's arguments. This is different than traditional object-oriented languages, where dispatch occurs based only on the first argument, which often has a special argument syntax, and is sometimes implied rather than explicitly written as an argument. &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; Using all of a function's arguments to choose which method should be invoked, rather than just the first, is known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;multiple dispatch&lt;/a&gt;. Multiple dispatch is particularly useful for mathematical code, where it makes little sense to artificially deem the operations to &quot;belong&quot; to one argument more than any of the others: does the addition operation in &lt;code&gt;x + y&lt;/code&gt; belong to &lt;code&gt;x&lt;/code&gt; any more than it does to &lt;code&gt;y&lt;/code&gt;? The implementation of a mathematical operator generally depends on the types of all of its arguments. Even beyond mathematical operations, however, multiple dispatch ends up being a powerful and convenient paradigm for structuring and organizing programs.</source>
          <target state="translated">関数が適用されるときに実行するメソッドの選択は、&lt;em&gt;ディスパッチ&lt;/em&gt;と呼ば&lt;em&gt;れ&lt;/em&gt;ます。 Juliaでは、ディスパッチプロセスで、指定された引数の数、および関数のすべての引数の型に基づいて、呼び出す関数のメソッドを選択できます。これは、ディスパッチが最初の引数にのみ基づいて行われる従来のオブジェクト指向言語とは異なります。ディスパッチは、多くの場合、特別な引数構文を持ち、引数として明示的に記述されるのではなく暗黙的に行われます。&lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;関数のすべての引数を使用して、最初のメソッドだけでなく、どのメソッドを呼び出すかを選択することを、&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiple_dispatch&quot;&gt;マルチディスパッチといいます。&lt;/a&gt;。複数のディスパッチは、人工的により他の任意の数の引数に「属する」への操作を考えると、それはほとんど意味が数学的なコードに特に有用である：で加算演算を行い &lt;code&gt;x + y&lt;/code&gt; 所属する &lt;code&gt;x&lt;/code&gt; もはやそれがよりも &lt;code&gt;y&lt;/code&gt; ？数学演算子の実装は、通常、そのすべての引数のタイプに依存します。ただし、数学的演算を超えた場合でも、複数のディスパッチはプログラムの構造化と編成のための強力で便利なパラダイムになります。</target>
        </trans-unit>
        <trans-unit id="810842d6186800c0a575092bdf409289f500ddec" translate="yes" xml:space="preserve">
          <source>The closure &lt;code&gt;x-&amp;gt;x&lt;/code&gt; carries a reference to &lt;code&gt;Foo&lt;/code&gt;, and since &lt;code&gt;Foo&lt;/code&gt; is unavailable on node 2, an &lt;code&gt;UndefVarError&lt;/code&gt; is thrown.</source>
          <target state="translated">クロージャー &lt;code&gt;x-&amp;gt;x&lt;/code&gt; には &lt;code&gt;Foo&lt;/code&gt; への参照が含まれており、ノード2では &lt;code&gt;Foo&lt;/code&gt; を使用できないため、 &lt;code&gt;UndefVarError&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="fd31f7bc6251a511018cdc2ef8ff1b65e61abb04" translate="yes" xml:space="preserve">
          <source>The cluster manager captures the &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; of each worker and makes it available to the master process.</source>
          <target state="translated">クラスターマネージャーは各ワーカーの&lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;をキャプチャし、マスタープロセスで使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="56c5bc198a3439c620845fc2e6da1bcc9a273974" translate="yes" xml:space="preserve">
          <source>The code to be called must be available as a shared library. Most C and Fortran libraries ship compiled as shared libraries already, but if you are compiling the code yourself using GCC (or Clang), you will need to use the &lt;code&gt;-shared&lt;/code&gt; and &lt;code&gt;-fPIC&lt;/code&gt; options. The machine instructions generated by Julia's JIT are the same as a native C call would be, so the resulting overhead is the same as calling a library function from C code. (Non-library function calls in both C and Julia can be inlined and thus may have even less overhead than calls to shared library functions. When both libraries and executables are generated by LLVM, it is possible to perform whole-program optimizations that can even optimize across this boundary, but Julia does not yet support that. In the future, however, it may do so, yielding even greater performance gains.)</source>
          <target state="translated">呼び出されるコードは、共有ライブラリとして使用できる必要があります。ほとんどのCおよびFortranライブラリは、すでに共有ライブラリとしてコンパイルされて出荷されますが、GCC（またはClang）を使用して自分でコードをコンパイルする場合は、 &lt;code&gt;-shared&lt;/code&gt; および &lt;code&gt;-fPIC&lt;/code&gt; を使用する必要があります。オプション。 JuliaのJITによって生成される機械語命令は、ネイティブC呼び出しと同じであるため、結果として生じるオーバーヘッドは、Cコードからライブラリー関数を呼び出す場合と同じです。 （CとJuliaの両方の非ライブラリ関数呼び出しはインライン化できるため、共有ライブラリ関数の呼び出しよりもオーバーヘッドが少なくなる可能性があります。LLVMによってライブラリと実行可能ファイルの両方が生成されると、プログラム全体の最適化を実行して、この境界を越えて最適化しますが、Juliaはまだそれをサポートしていませんが、将来的にはそうする可能性があり、パフォーマンスがさらに向上します。）</target>
        </trans-unit>
        <trans-unit id="98f830d6caf7ed0451c6b75d05afceaf2e516b19" translate="yes" xml:space="preserve">
          <source>The collection must not be empty.</source>
          <target state="translated">コレクションは空であってはなりません。</target>
        </trans-unit>
        <trans-unit id="b1b1444de74c16e81499ba99fc21db058cdbcd70" translate="yes" xml:space="preserve">
          <source>The colors used by Julia and the REPL can be customized, as well. To change the color of the Julia prompt you can add something like the following to your &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; file, which is to be placed inside your home directory:</source>
          <target state="translated">JuliaとREPLが使用する色もカスタマイズできます。Juliaプロンプトの色を変更するには、次のようなものを &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; ファイルに追加します。このファイルはホームディレクトリ内に配置されます。</target>
        </trans-unit>
        <trans-unit id="6ae3351e931cdaf68574bd5908ad25710f928fca" translate="yes" xml:space="preserve">
          <source>The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">列は1つ以上の空白で区切られていると想定されます。行末の区切り文字は &lt;code&gt;\n&lt;/code&gt; と見なされます。</target>
        </trans-unit>
        <trans-unit id="b166229d69582696f7886d8f6669f9f89c33f90c" translate="yes" xml:space="preserve">
          <source>The columns are assumed to be separated by one or more whitespaces. The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</source>
          <target state="translated">列は1つ以上の空白で区切られていると想定されます。行末の区切り文字は &lt;code&gt;\n&lt;/code&gt; と見なされます。すべてのデータが数値の場合、結果は数値配列になります。一部の要素を数値として解析できない場合、数値と文字列の異種混合配列が返されます。</target>
        </trans-unit>
        <trans-unit id="c128fcb09c50ebb22346ed7e858f0e921632da46" translate="yes" xml:space="preserve">
          <source>The combination of a high-level programming language, a first-class command abstraction, and automatic setup of pipes between processes is a powerful one. To give some sense of the complex pipelines that can be created easily, here are some more sophisticated examples, with apologies for the excessive use of Perl one-liners:</source>
          <target state="translated">高レベルのプログラミング言語、一流のコマンド抽象化、プロセス間のパイプの自動セットアップの組み合わせは強力なものです。簡単に作成できる複雑なパイプラインを理解してもらうために、ここではより洗練された例をいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="6a7191f54d1d0a0057ae059656a933d9b6a26e58" translate="yes" xml:space="preserve">
          <source>The command is never run with a shell. Instead, Julia parses the command syntax directly, appropriately interpolating variables and splitting on words as the shell would, respecting shell quoting syntax. The command is run as &lt;code&gt;julia&lt;/code&gt;'s immediate child process, using &lt;code&gt;fork&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; calls.</source>
          <target state="translated">コマンドがシェルで実行されることはありません。代わりに、Juliaはコマンド構文を直接解析し、変数を適切に補間し、シェルのように単語を分割し、シェルの引用構文を尊重します。このコマンドは、 &lt;code&gt;fork&lt;/code&gt; および &lt;code&gt;exec&lt;/code&gt; 呼び出しを使用して、 &lt;code&gt;julia&lt;/code&gt; の直接の子プロセスとして実行されます。</target>
        </trans-unit>
        <trans-unit id="4a0dcc8c9826601bed0e074d703f3ff7a640f8d1" translate="yes" xml:space="preserve">
          <source>The common idiom of using 1:n to index into an AbstractArray is not safe if the Array uses unconventional indexing, and may cause a segmentation fault if bounds checking is turned off. Use &lt;code&gt;LinearIndices(x)&lt;/code&gt; or &lt;code&gt;eachindex(x)&lt;/code&gt; instead (see also &lt;a href=&quot;https://docs.julialang.org/en/latest/devdocs/offset-arrays/&quot;&gt;offset-arrays&lt;/a&gt;).</source>
          <target state="translated">1：nを使用してAbstractArrayにインデックスを付ける一般的なイディオムは、配列が従来とは異なるインデックスを使用している場合は安全ではなく、境界チェックがオフになっているとセグメンテーション違反が発生する可能性があります。代わりに、 &lt;code&gt;LinearIndices(x)&lt;/code&gt; または &lt;code&gt;eachindex(x)&lt;/code&gt; を使用してください（&lt;a href=&quot;https://docs.julialang.org/en/latest/devdocs/offset-arrays/&quot;&gt;offset-arrays&lt;/a&gt;も参照）。</target>
        </trans-unit>
        <trans-unit id="f0451ae3f3f75dd1173ec1688aaf529347960c71" translate="yes" xml:space="preserve">
          <source>The commonly used &lt;code&gt;Int&lt;/code&gt; type corresponds to the machine integer type (&lt;code&gt;Int32&lt;/code&gt; or &lt;code&gt;Int64&lt;/code&gt;). This means it will overflow, such that &lt;code&gt;2^64 == 0&lt;/code&gt;. If you need larger values use another appropriate type, such as &lt;code&gt;Int128&lt;/code&gt;, &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; or a floating point type like &lt;code&gt;Float64&lt;/code&gt;.</source>
          <target state="translated">一般的に使用される &lt;code&gt;Int&lt;/code&gt; 型は、マシンの整数型（ &lt;code&gt;Int32&lt;/code&gt; または &lt;code&gt;Int64&lt;/code&gt; ）に対応します。つまり、 &lt;code&gt;2^64 == 0&lt;/code&gt; ようにオーバーフローします。あなたは、より大きな値が必要な場合など、他の適切な種類、使用 &lt;code&gt;Int128&lt;/code&gt; 、&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; 型&lt;/a&gt;など浮動小数点型 &lt;code&gt;Float64&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="282c5d6af8a85d4583f2090ba3bf0607d51cccb2" translate="yes" xml:space="preserve">
          <source>The compilers for many languages have an internal union construct for reasoning about types; Julia simply exposes it to the programmer. The Julia compiler is able to generate efficient code in the presence of &lt;code&gt;Union&lt;/code&gt; types with a small number of types &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;, by generating specialized code in separate branches for each possible type.</source>
          <target state="translated">多くの言語のコンパイラには、型について推論するための内部共用体構造があります。ジュリアは単にそれをプログラマーに公開します。Juliaコンパイラーは、可能な型ごとに別々のブランチで特殊なコードを生成することにより、少数の型&lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;を持つ &lt;code&gt;Union&lt;/code&gt; 型の存在下で効率的なコードを生成できます。</target>
        </trans-unit>
        <trans-unit id="d307808f74aeaa37d8dbbea9a15606c901a4cae0" translate="yes" xml:space="preserve">
          <source>The completion of fields for output from functions uses type inference, and it can only suggest fields if the function is type stable.</source>
          <target state="translated">関数から出力されるフィールドの補完は型推論を使用しており、型が安定している場合にのみフィールドを提案することができます。</target>
        </trans-unit>
        <trans-unit id="d3138fe1fc8f7174a34adb1898449525528a913c" translate="yes" xml:space="preserve">
          <source>The completion of the methods uses type inference and can therefore see if the arguments match even if the arguments are output from functions. The function needs to be type stable for the completion to be able to remove non-matching methods.</source>
          <target state="translated">メソッドの補完は型推論を利用しているため、引数が関数から出力されたものであっても、引数がマッチしているかどうかを見ることができます。補完がマッチしないメソッドを削除できるようにするためには、関数は型が安定している必要があります。</target>
        </trans-unit>
        <trans-unit id="6f83f5850ac6b62e295ec56f0e83533e7801ad37" translate="yes" xml:space="preserve">
          <source>The complexity of &lt;code&gt;rand(rng, s::Union{AbstractDict,AbstractSet})&lt;/code&gt; is linear in the length of &lt;code&gt;s&lt;/code&gt;, unless an optimized method with constant complexity is available, which is the case for &lt;code&gt;Dict&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;BitSet&lt;/code&gt;. For more than a few calls, use &lt;code&gt;rand(rng, collect(s))&lt;/code&gt; instead, or either &lt;code&gt;rand(rng, Dict(s))&lt;/code&gt; or &lt;code&gt;rand(rng, Set(s))&lt;/code&gt; as appropriate.</source>
          <target state="translated">複雑 &lt;code&gt;rand(rng, s::Union{AbstractDict,AbstractSet})&lt;/code&gt; の長さは直線的である &lt;code&gt;s&lt;/code&gt; 一定の複雑さで最適化方法は、の場合である、利用可能でない場合、 &lt;code&gt;Dict&lt;/code&gt; 、 &lt;code&gt;Set&lt;/code&gt; と &lt;code&gt;BitSet&lt;/code&gt; 。いくつかの呼び出しを超える場合は、代わりに &lt;code&gt;rand(rng, collect(s))&lt;/code&gt; 使用するか、必要 &lt;code&gt;rand(rng, Dict(s))&lt;/code&gt; または &lt;code&gt;rand(rng, Set(s))&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="311dcfe3310c4c1e71b8fdd71e07a972ef0dc132" translate="yes" xml:space="preserve">
          <source>The components of tuples can optionally be named, in which case a &lt;em&gt;named tuple&lt;/em&gt; is constructed:</source>
          <target state="translated">タプルのコンポーネントには、オプションで名前を付けることができます。その場合、&lt;em&gt;名前付きタプル&lt;/em&gt;が作成されます。</target>
        </trans-unit>
        <trans-unit id="3e9339bf8ddc8517e7daf0c8e7c807dbe19f1e27" translate="yes" xml:space="preserve">
          <source>The compressed sparse column storage makes it easy and quick to access the elements in the column of a sparse matrix, whereas accessing the sparse matrix by rows is considerably slower. Operations such as insertion of previously unstored entries one at a time in the CSC structure tend to be slow. This is because all elements of the sparse matrix that are beyond the point of insertion have to be moved one place over.</source>
          <target state="translated">圧縮された疎な列ストレージは,疎な行列の列の要素に簡単かつ迅速にアクセスできるのに対し,行単位での疎な行列へのアクセスはかなり遅くなります.以前に保存されていないエントリをCSC構造体に1つずつ挿入するような操作は,遅くなる傾向があります.これは,挿入ポイントを越えた疎な行列のすべての要素を,1つ上に移動させなければならないからです.</target>
        </trans-unit>
        <trans-unit id="8b1889cfa906d5de7f417dbba5d8a75294042a14" translate="yes" xml:space="preserve">
          <source>The concatenation functions are used so often that they have special syntax:</source>
          <target state="translated">連結関数は、特殊な構文を持つほど頻繁に使用されています。</target>
        </trans-unit>
        <trans-unit id="79be6aae51e8c401b2476f5b4f2a107a9fdc32ef" translate="yes" xml:space="preserve">
          <source>The constant pi.</source>
          <target state="translated">定数πです。</target>
        </trans-unit>
        <trans-unit id="cdd946b3bbe64931ddb3bd5e7f32f9d59fbf8fe0" translate="yes" xml:space="preserve">
          <source>The constant ℯ.</source>
          <target state="translated">定数ℯ。</target>
        </trans-unit>
        <trans-unit id="9cefd93a0c7128d9cee7f50ca451b5a8198bc929" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;RemoteChannel(f::Function, pid)()&lt;/code&gt; allows us to construct references to channels holding more than one value of a specific type. &lt;code&gt;f&lt;/code&gt; is a function executed on &lt;code&gt;pid&lt;/code&gt; and it must return an &lt;code&gt;AbstractChannel&lt;/code&gt;.</source>
          <target state="translated">コンストラクタ &lt;code&gt;RemoteChannel(f::Function, pid)()&lt;/code&gt; 使用すると、特定のタイプの複数の値を保持するチャネルへの参照を構築できます。 &lt;code&gt;f&lt;/code&gt; は &lt;code&gt;pid&lt;/code&gt; で実行される関数であり、 &lt;code&gt;AbstractChannel&lt;/code&gt; を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="76232e9ec80692ffa1332b97fa1e6fc3973cc15d" translate="yes" xml:space="preserve">
          <source>The constructor for a shared array is of the form:</source>
          <target state="translated">共有配列のコンストラクタはこの形式です。</target>
        </trans-unit>
        <trans-unit id="09f297e05974522f0c6701c3e5abf5ccf2ee32ab" translate="yes" xml:space="preserve">
          <source>The contents of each item in the list must line up with the first line of the item. In the above example the fenced code block must be indented by four spaces to align with the &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;item two&lt;/code&gt;.</source>
          <target state="translated">リスト内の各アイテムの内容は、アイテムの最初の行に合わせる必要があります。上記の例では、fencedコードブロックは、 &lt;code&gt;item two&lt;/code&gt; &lt;code&gt;i&lt;/code&gt; に合わせて4つのスペースでインデントする必要があります。</target>
        </trans-unit>
        <trans-unit id="a711e2ee96d05b52332ef79c64c2aa17ad5865e1" translate="yes" xml:space="preserve">
          <source>The cookie may be passed to the workers at startup via argument &lt;code&gt;--worker=&amp;lt;cookie&amp;gt;&lt;/code&gt;. If argument &lt;code&gt;--worker&lt;/code&gt; is specified without the cookie, the worker tries to read the cookie from its standard input (&lt;a href=&quot;../../base/io-network/index#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;). The &lt;code&gt;stdin&lt;/code&gt; is closed immediately after the cookie is retrieved.</source>
          <target state="translated">起動時に、引数 &lt;code&gt;--worker=&amp;lt;cookie&amp;gt;&lt;/code&gt; を介してCookieをワーカーに渡すことができます。引数 &lt;code&gt;--worker&lt;/code&gt; がCookieなしで指定されている場合、ワーカーはその標準入力（&lt;a href=&quot;../../base/io-network/index#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;）からCookieを読み取ろうとします。 &lt;code&gt;stdin&lt;/code&gt; クッキーが取得された直後に閉じられています。</target>
        </trans-unit>
        <trans-unit id="870af6ba603446abce307b3e8bfd11194f33f900" translate="yes" xml:space="preserve">
          <source>The core language imposes very little; Julia Base and the standard library is written in Julia itself, including primitive operations like integer arithmetic</source>
          <target state="translated">Julia Base と標準ライブラリは Julia 自体で書かれています。</target>
        </trans-unit>
        <trans-unit id="3bc4ff368fbfc76c3ff3eaa70599d7710f608522" translate="yes" xml:space="preserve">
          <source>The current logger state is looked up and the message level checked against the logger's cached minimum level, as found by calling &lt;a href=&quot;#Base.CoreLogging.min_enabled_level&quot;&gt;&lt;code&gt;Logging.min_enabled_level&lt;/code&gt;&lt;/a&gt;. This behavior can be overridden via environment variables (more on this later).</source>
          <target state="translated">&lt;a href=&quot;#Base.CoreLogging.min_enabled_level&quot;&gt; &lt;code&gt;Logging.min_enabled_level&lt;/code&gt; &lt;/a&gt;を呼び出すことで見つかるように、現在のロガー状態が検索され、メッセージレベルがロガーのキャッシュされた最小レベルと照合されます。この動作は環境変数でオーバーライドできます（これについては後で詳しく説明します）。</target>
        </trans-unit>
        <trans-unit id="3f7f546fa478be5baf73e1d9a88ce7b4f22fd7b5" translate="yes" xml:space="preserve">
          <source>The current version of Julia multiplexes all tasks onto a single OS thread. Thus, while tasks involving I/O operations benefit from parallel execution, compute bound tasks are effectively executed sequentially on a single OS thread. Future versions of Julia may support scheduling of tasks on multiple threads, in which case compute bound tasks will see benefits of parallel execution too.</source>
          <target state="translated">現在のバージョンのJuliaでは、すべてのタスクを1つのOSスレッドに多重化しています。そのため、I/O処理を含むタスクは並列実行の恩恵を受けることができますが、計算に依存したタスクは1つのOSスレッド上で効果的に順次実行されます。将来のバージョンでは、複数のスレッド上でのタスクのスケジューリングがサポートされるかもしれませんが、その場合、計算に依存したタスクも並列実行の恩恵を受けることになります。</target>
        </trans-unit>
        <trans-unit id="76aeeb5da0056ec0aaaca0d1c584f7796e1043fc" translate="yes" xml:space="preserve">
          <source>The dangers of abusing multiple dispatch (aka, more on types with values-as-parameters)</source>
          <target state="translated">複数のディスパッチを悪用する危険性 (別名、パラメータとしての値を持つ型についての詳細)</target>
        </trans-unit>
        <trans-unit id="61e6dec9a93ab50439a3df7d4ed79515ae264595" translate="yes" xml:space="preserve">
          <source>The day of month of a &lt;code&gt;Date&lt;/code&gt; or &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">月の日 &lt;code&gt;Date&lt;/code&gt; や &lt;code&gt;DateTime&lt;/code&gt; など&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="299252ee9be4ede7afdc82ba83cfa67ed6efb411" translate="yes" xml:space="preserve">
          <source>The declared types of all fields in a composite DataType &lt;code&gt;T&lt;/code&gt; as a tuple.</source>
          <target state="translated">タプルとしての複合DataType &lt;code&gt;T&lt;/code&gt; のすべてのフィールドの宣言されたタイプ。</target>
        </trans-unit>
        <trans-unit id="2ef7bb84da109de096d6179f580e39fcc330d135" translate="yes" xml:space="preserve">
          <source>The dedentation level is determined as the longest common starting sequence of spaces or tabs in all lines, excluding the line following the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; and lines containing only spaces or tabs (the line containing the closing &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; is always included). Then for all lines, excluding the text following the opening &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt;, the common starting sequence is removed (including lines containing only spaces and tabs if they start with this sequence), e.g.:</source>
          <target state="translated">くぼみレベルは、開始 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 続く行とスペースまたはタブのみを含む行を除くすべての行で、スペースまたはタブの最も一般的な開始シーケンスとして決定されます（終了 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; を含む行は常に含まれます）。次に、開始 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 続くテキストを除くすべての行について、共通の開始シーケンスが削除されます（このシーケンスで始まる場合、スペースとタブのみを含む行を含みます）。例：</target>
        </trans-unit>
        <trans-unit id="2356f962c8d3ff60eecc6a182ea052ea39664b67" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pid&lt;/code&gt; is the current process.</source>
          <target state="translated">デフォルトの &lt;code&gt;pid&lt;/code&gt; は現在のプロセスです。</target>
        </trans-unit>
        <trans-unit id="13fb2cffe54cc4ab8a1dd2c832ae7310589c0943" translate="yes" xml:space="preserve">
          <source>The default MIME type is &lt;code&gt;MIME&quot;text/plain&quot;&lt;/code&gt;. There is a fallback definition for &lt;code&gt;text/plain&lt;/code&gt; output that calls &lt;code&gt;show&lt;/code&gt; with 2 arguments. Therefore, this case should be handled by defining a 2-argument &lt;code&gt;show(io::IO, x::MyType)&lt;/code&gt; method.</source>
          <target state="translated">デフォルトのMIMEタイプは &lt;code&gt;MIME&quot;text/plain&quot;&lt;/code&gt; です。2つの引数で &lt;code&gt;show&lt;/code&gt; を呼び出す &lt;code&gt;text/plain&lt;/code&gt; 出力のフォールバック定義があります。したがって、このケースは、2つの引数を持つ &lt;code&gt;show(io::IO, x::MyType)&lt;/code&gt; メソッドを定義して処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="e57baa92c6f6a7e34ff4590072c999e03c2e6a26" translate="yes" xml:space="preserve">
          <source>The default behavior in Julia when types are omitted is to allow values to be of any type. Thus, one can write many useful Julia functions without ever explicitly using types. When additional expressiveness is needed, however, it is easy to gradually introduce explicit type annotations into previously &quot;untyped&quot; code. Adding annotations serves three primary purposes: to take advantage of Julia's powerful multiple-dispatch mechanism, to improve human readability, and to catch programmer errors.</source>
          <target state="translated">型が省略された場合のJuliaのデフォルトの動作は、任意の型の値を許可することです。したがって、明示的に型を使用しなくても、多くの有用なJulia関数を書くことができます。しかし、さらなる表現力が必要な場合には、以前に「型を使わない」コードに明示的な型のアノテーションを徐々に導入していくことが簡単にできます。注釈を追加することで、Julia の強力な多重ディスパッチ機構を利用すること、人間の可読性を向上させること、そしてプログラマのエラーを検出することです。</target>
        </trans-unit>
        <trans-unit id="d1df4775c1a0c6149628da164ef2c2add2aea3bd" translate="yes" xml:space="preserve">
          <source>The default behaviour is to remove leading whitespace and delimiters: see &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt; for precise details.</source>
          <target state="translated">デフォルトの動作では、先頭の空白と区切り文字が削除されます。詳細については、&lt;a href=&quot;#Base.Unicode.isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1c11c76e6a974f0248876da7137e97c01ffa7caf" translate="yes" xml:space="preserve">
          <source>The default behaviour is to remove trailing whitespace and delimiters: see &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt; for precise details.</source>
          <target state="translated">デフォルトの動作では、末尾の空白と区切り文字が削除されます。詳細については、&lt;a href=&quot;#Base.Unicode.isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="855bff164720a2c745d8e506987fbf1482013980" translate="yes" xml:space="preserve">
          <source>The default implementation (which uses TCP/IP sockets) is implemented as &lt;code&gt;connect(manager::ClusterManager, pid::Integer, config::WorkerConfig)&lt;/code&gt;.</source>
          <target state="translated">デフォルトの実装（TCP / IPソケットを使用）は、 &lt;code&gt;connect(manager::ClusterManager, pid::Integer, config::WorkerConfig)&lt;/code&gt; として実装されています。</target>
        </trans-unit>
        <trans-unit id="78e7fa17aefadd075c2be825658630ae2cf9c235" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;code&gt;isequal&lt;/code&gt; calls &lt;code&gt;==&lt;/code&gt;, so a type that does not involve floating-point values generally only needs to define &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isequal&lt;/code&gt; 呼び出しのデフォルト実装は &lt;code&gt;==&lt;/code&gt; なので、浮動小数点値を含まない型は、通常 &lt;code&gt;==&lt;/code&gt; を定義するだけで済みます。</target>
        </trans-unit>
        <trans-unit id="40594727e32e7ffa62fc7c197ea4f5e0449e9039" translate="yes" xml:space="preserve">
          <source>The default implementations of the above (on a &lt;code&gt;AbstractWorkerPool&lt;/code&gt;) require fields channel::Channel{Int} workers::Set{Int} where &lt;code&gt;channel&lt;/code&gt; contains free worker pids and &lt;code&gt;workers&lt;/code&gt; is the set of all workers associated with this pool.</source>
          <target state="translated">上記（上のデフォルト実装 &lt;code&gt;AbstractWorkerPool&lt;/code&gt; は）フィールドチャネル::チャンネル{}のInt労働者を必要とする::集合{}のInt &lt;code&gt;channel&lt;/code&gt; フリーワーカーのPIDと含ま &lt;code&gt;workers&lt;/code&gt; このプールに関連付けられたすべての労働者の集合です。</target>
        </trans-unit>
        <trans-unit id="90d0098a5b9857be430bc6bdbd24d7771a71aa03" translate="yes" xml:space="preserve">
          <source>The default is &lt;a href=&quot;#Base.IndexCartesian&quot;&gt;&lt;code&gt;IndexCartesian()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">デフォルトは&lt;a href=&quot;#Base.IndexCartesian&quot;&gt; &lt;code&gt;IndexCartesian()&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="939929b76e159e18d5e7761850ea7b359afa492d" translate="yes" xml:space="preserve">
          <source>The default mode used is always &lt;a href=&quot;../../base/math/index#Base.Rounding.RoundNearest&quot;&gt;&lt;code&gt;RoundNearest&lt;/code&gt;&lt;/a&gt;, which rounds to the nearest representable value, with ties rounded towards the nearest value with an even least significant bit.</source>
          <target state="translated">使用されるデフォルトのモードは常に&lt;a href=&quot;../../base/math/index#Base.Rounding.RoundNearest&quot;&gt; &lt;code&gt;RoundNearest&lt;/code&gt; で&lt;/a&gt;、これは最も近い表現可能な値に丸め、タイは最下位ビットで最も近い値に丸められます。</target>
        </trans-unit>
        <trans-unit id="bb41fa3202534d6677ac2f342e3bce0fdc60f379" translate="yes" xml:space="preserve">
          <source>The default precision (in number of bits of the significand) and rounding mode of &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; operations can be changed globally by calling &lt;a href=&quot;../../base/numbers/index#Base.MPFR.setprecision&quot;&gt;&lt;code&gt;setprecision&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;setrounding&lt;/code&gt;, and all further calculations will take these changes in account. Alternatively, the precision or the rounding can be changed only within the execution of a particular block of code by using the same functions with a &lt;code&gt;do&lt;/code&gt; block:</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;操作のデフォルトの精度（仮数のビット数）と丸めモードは、&lt;a href=&quot;../../base/numbers/index#Base.MPFR.setprecision&quot;&gt; &lt;code&gt;setprecision&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;setrounding&lt;/code&gt; を呼び出すことでグローバルに変更でき、以降のすべての計算ではこれらの変更が考慮されます。または、 &lt;code&gt;do&lt;/code&gt; ブロックで同じ関数を使用して、特定のコードブロックの実行内でのみ、精度または丸めを変更できます。</target>
        </trans-unit>
        <trans-unit id="bf260c790afbd5fd76456a214c3da2bfee6f596b" translate="yes" xml:space="preserve">
          <source>The default rounding mode. Rounds to the nearest integer, with ties (fractional values of 0.5) being rounded to the nearest even integer.</source>
          <target state="translated">デフォルトの丸めモード。最も近い整数に丸められ、タイ(0.5の端数値)は最も近い偶数に丸められます。</target>
        </trans-unit>
        <trans-unit id="a8d023ed2ec488f600d82c5f04099bb7053c6343" translate="yes" xml:space="preserve">
          <source>The default sorting algorithms are chosen on the basis that they are fast and stable, or &lt;em&gt;appear&lt;/em&gt; to be so. For numeric types indeed, &lt;code&gt;QuickSort&lt;/code&gt; is selected as it is faster and indistinguishable in this case from a stable sort (unless the array records its mutations in some way). The stability property comes at a non-negligible cost, so if you don't need it, you may want to explicitly specify your preferred algorithm, e.g. &lt;code&gt;sort!(v, alg=QuickSort)&lt;/code&gt;.</source>
          <target state="translated">デフォルトのソートアルゴリズムは、高速で安定しているか、そうであるかの&lt;em&gt;ように選択さ&lt;/em&gt;れます。確かに数値型の場合、 &lt;code&gt;QuickSort&lt;/code&gt; が選択されます。この場合、配列は何らかの方法で変異を記録する場合を除き、安定したソートとは区別がつかないため高速です。安定性プロパティは無視できないコストで提供されるため、それが必要ない場合は、たとえば &lt;code&gt;sort!(v, alg=QuickSort)&lt;/code&gt; 優先アルゴリズムを明示的に指定することができます。</target>
        </trans-unit>
        <trans-unit id="8e4b294c96581c70e29314614e72dd9c556dd867" translate="yes" xml:space="preserve">
          <source>The default type for an integer literal depends on whether the target system has a 32-bit architecture or a 64-bit architecture:</source>
          <target state="translated">整数リテラルのデフォルトの型は、ターゲットシステムが32ビットアーキテクチャか64ビットアーキテクチャかによって異なります。</target>
        </trans-unit>
        <trans-unit id="0025d7cf20de7d8585d610cdb20c478776196150" translate="yes" xml:space="preserve">
          <source>The default value (for iterators that do not define this function) is &lt;code&gt;HasLength()&lt;/code&gt;. This means that most iterators are assumed to implement &lt;a href=&quot;#Base.length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">（この関数を定義しないイテレータの）デフォルト値は &lt;code&gt;HasLength()&lt;/code&gt; です。これは、ほとんどの反復子が&lt;a href=&quot;#Base.length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt;さを実装すると想定されていることを意味します。</target>
        </trans-unit>
        <trans-unit id="ed1fec164addf150bd6fc4ed074c8bde6086195e" translate="yes" xml:space="preserve">
          <source>The default when no keywords are passed is to open files for reading only. Returns a stream for accessing the opened file.</source>
          <target state="translated">キーワードを渡さなかった場合のデフォルトは、読み込み専用のファイルを開くことになります。開いているファイルにアクセスするためのストリームを返します。</target>
        </trans-unit>
        <trans-unit id="46ad04b79597833ac2971450ca4faf1a5ac755c0" translate="yes" xml:space="preserve">
          <source>The definitive guide to floating point arithmetic is the &lt;a href=&quot;https://standards.ieee.org/standard/754-2008.html&quot;&gt;IEEE 754-2008 Standard&lt;/a&gt;; however, it is not available for free online.</source>
          <target state="translated">浮動小数点演算の決定的なガイドは、&lt;a href=&quot;https://standards.ieee.org/standard/754-2008.html&quot;&gt;IEEE 754-2008規格&lt;/a&gt;です。ただし、オンラインで無料で入手することはできません。</target>
        </trans-unit>
        <trans-unit id="c7a1e185817162d29c3ca02c640a39cf90726456" translate="yes" xml:space="preserve">
          <source>The description string accepts interpolation from the loop indices. If no description is provided, one is constructed based on the variables.</source>
          <target state="translated">記述文字列は、ループインデックスからの補間を受け付けます。記述がない場合は、変数に基づいて記述を作成します。</target>
        </trans-unit>
        <trans-unit id="b9783bd3f57cabbb7dcb6efff07a6fb2ce7cf2be" translate="yes" xml:space="preserve">
          <source>The destructuring feature can also be used within a function argument. If a function argument name is written as a tuple (e.g. &lt;code&gt;(x, y)&lt;/code&gt;) instead of just a symbol, then an assignment &lt;code&gt;(x, y) = argument&lt;/code&gt; will be inserted for you:</source>
          <target state="translated">解体機能は、関数の引数内でも使用できます。関数の引数名が単なるシンボルではなくタプル（たとえば &lt;code&gt;(x, y)&lt;/code&gt; ）として記述されている場合、代入 &lt;code&gt;(x, y) = argument&lt;/code&gt; が挿入されます。</target>
        </trans-unit>
        <trans-unit id="dca7fd4aaff137c3b5ad312f731763865f2c4777" translate="yes" xml:space="preserve">
          <source>The diagonal of the matrix &lt;code&gt;X&lt;/code&gt; is assumed to be all ones.</source>
          <target state="translated">行列 &lt;code&gt;X&lt;/code&gt; の対角要素はすべて1と見なされます。</target>
        </trans-unit>
        <trans-unit id="65475d5b108ff8d6ff4d0b451b5957edd3247c0c" translate="yes" xml:space="preserve">
          <source>The diagonal values of the matrix &lt;code&gt;X&lt;/code&gt; will be read.</source>
          <target state="translated">行列 &lt;code&gt;X&lt;/code&gt; の対角値が読み取られます。</target>
        </trans-unit>
        <trans-unit id="35294cd283107f3ea2ad299c610959761013b001" translate="yes" xml:space="preserve">
          <source>The difference in norm between a vector space and its dual arises to preserve the relationship between duality and the dot product, and the result is consistent with the operator &lt;code&gt;p&lt;/code&gt;-norm of a &lt;code&gt;1 &amp;times; n&lt;/code&gt; matrix.</source>
          <target state="translated">ベクトル空間とその双対の間のノルムの違いは、双対性と内積の間の関係を維持するために発生し、結果は &lt;code&gt;1 &amp;times; n&lt;/code&gt; 行列の演算子 &lt;code&gt;p&lt;/code&gt; -ノルムと一致します。</target>
        </trans-unit>
        <trans-unit id="fe30caaca3ec896d42d37e2680c6fbcc22f3fc58" translate="yes" xml:space="preserve">
          <source>The difference seems trivial, but in fact is quite significant due to the behavior of &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt;. In the first method, a random matrix is constructed locally, then sent to another process where it is squared. In the second method, a random matrix is both constructed and squared on another process. Therefore the second method sends much less data than the first.</source>
          <target state="translated">違いはささいなことのように見えますが、実際には&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt;の動作のために非常に重要です。最初の方法では、ランダムな行列がローカルに作成され、別のプロセスに送信されて二乗されます。2番目の方法では、ランダム行列が作成され、別のプロセスで2乗されます。したがって、2番目の方法は最初の方法よりもはるかに少ないデータを送信します。</target>
        </trans-unit>
        <trans-unit id="515d7afeaf87e8c8538070fa94ff623cdced8f10" translate="yes" xml:space="preserve">
          <source>The different prompt modes</source>
          <target state="translated">異なるプロンプトモード</target>
        </trans-unit>
        <trans-unit id="cf7712c8e857525e49eb6c6feac8d5fe578af7a4" translate="yes" xml:space="preserve">
          <source>The discussion in the preceding paragraph referred to the &quot;parser&quot;, that is, the phase of compilation that takes place when the module containing &lt;code&gt;abmult&lt;/code&gt; is first loaded, as opposed to the later phase when it is first invoked. The parser does not &quot;know&quot; that &lt;code&gt;Int&lt;/code&gt; is a fixed type, or that the statement &lt;code&gt;r = -r&lt;/code&gt; transforms an &lt;code&gt;Int&lt;/code&gt; to another &lt;code&gt;Int&lt;/code&gt;. The magic of type inference takes place in the later phase of compilation.</source>
          <target state="translated">前の段落の説明では、「パーサー」、つまり、 &lt;code&gt;abmult&lt;/code&gt; を含むモジュールが最初に呼び出された後のフェーズとは対照的に、abmultを含むモジュールが最初にロードされたときに実行されるコンパイルのフェーズについて言及しました。パーサーは、 &lt;code&gt;Int&lt;/code&gt; が固定型であること、またはステートメント &lt;code&gt;r = -r&lt;/code&gt; が &lt;code&gt;Int&lt;/code&gt; を別の &lt;code&gt;Int&lt;/code&gt; に変換することを「認識」していません。型推論の魔法は、コンパイルの後の段階で発生します。</target>
        </trans-unit>
        <trans-unit id="228846c17a2f8eda9af9e04280c4e7e004d8ecbb" translate="yes" xml:space="preserve">
          <source>The discussion of trait-based promotion provides a transition into our next design pattern: computing the output element type for a matrix operation.</source>
          <target state="translated">形質に基づいたプロモーションの議論は、次の設計パターンへの移行を提供します:行列演算の出力要素の型を計算する。</target>
        </trans-unit>
        <trans-unit id="c9eeea461d08f16f6e9e3e76a2854c7413f10de0" translate="yes" xml:space="preserve">
          <source>The distance between two adjacent representable floating-point numbers is not constant, but is smaller for smaller values and larger for larger values. In other words, the representable floating-point numbers are densest in the real number line near zero, and grow sparser exponentially as one moves farther away from zero. By definition, &lt;code&gt;eps(1.0)&lt;/code&gt; is the same as &lt;code&gt;eps(Float64)&lt;/code&gt; since &lt;code&gt;1.0&lt;/code&gt; is a 64-bit floating-point value.</source>
          <target state="translated">隣接する2つの表現可能な浮動小数点数の間の距離は一定ではありませんが、値が小さいほど小さくなり、値が大きいほど大きくなります。言い換えると、表現可能な浮動小数点数は、ゼロに近い実数線で最も密度が高く、ゼロから遠ざかるにつれて指数関数的にスパースに成長します。 &lt;code&gt;1.0&lt;/code&gt; は64ビットの浮動小数点値であるため、定義により、 &lt;code&gt;eps(1.0)&lt;/code&gt; は &lt;code&gt;eps(Float64)&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="17711720acdfc250d4da5bdf1c59e4156516b762" translate="yes" xml:space="preserve">
          <source>The distinction between inheriting global scope and nesting local scope can lead to some slight differences between functions defined in local versus global scopes for variable assignments. Consider the modification of the last example by moving &lt;code&gt;bar&lt;/code&gt; to the global scope:</source>
          <target state="translated">グローバルスコープの継承とローカルスコープの入れ子の違いにより、変数割り当てのローカルスコープとグローバルスコープで定義された関数に若干の違いが生じる可能性があります。 &lt;code&gt;bar&lt;/code&gt; をグローバルスコープに移動して、最後の例の変更を検討します。</target>
        </trans-unit>
        <trans-unit id="bcbd86bd1c455f650a19858504ec03684521d39b" translate="yes" xml:space="preserve">
          <source>The documentation is also available in PDF format: &lt;a href=&quot;https://raw.githubusercontent.com/JuliaLang/docs.julialang.org/assets/julia-1.2.0.pdf&quot;&gt;julia-1.2.0.pdf&lt;/a&gt;.</source>
          <target state="translated">ドキュメントはPDF形式でも入手できます：&lt;a href=&quot;https://raw.githubusercontent.com/JuliaLang/docs.julialang.org/assets/julia-1.2.0.pdf&quot;&gt;julia-1.2.0.pdf&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83c976d9d02fc2e4f087f2db86ac987d2cebacc0" translate="yes" xml:space="preserve">
          <source>The easiest way to learn and experiment with Julia is by starting an interactive session (also known as a read-eval-print loop or &quot;REPL&quot;) by double-clicking the Julia executable or running &lt;code&gt;julia&lt;/code&gt; from the command line:</source>
          <target state="translated">Juliaを学習して試す最も簡単な方法は、Julia実行可能ファイルをダブルクリックするか、コマンドラインから &lt;code&gt;julia&lt;/code&gt; を実行して、対話型セッション（read-eval-printループまたは &quot;REPL&quot;とも呼ばれます）を開始することです。</target>
        </trans-unit>
        <trans-unit id="2182ffaca8a0c2d19e2f394d632b220a4bda55b5" translate="yes" xml:space="preserve">
          <source>The easiest way to understand this behavior is to see an example. In the previous example, the &lt;code&gt;println&lt;/code&gt; call is shared by all three branches: the only real choice is which literal string to print. This could be written more concisely using the ternary operator. For the sake of clarity, let's try a two-way version first:</source>
          <target state="translated">この動作を理解する最も簡単な方法は、例を見ることです。前の例では、 &lt;code&gt;println&lt;/code&gt; 呼び出しは3つのブランチすべてで共有されています。実際に選択できるのは、出力するリテラル文字列だけです。これは、3項演算子を使用してより簡潔に記述できます。明確にするために、最初に双方向バージョンを試してみましょう。</target>
        </trans-unit>
        <trans-unit id="56dd1399973b5466f5b438f54aa5084eb3d4b3fd" translate="yes" xml:space="preserve">
          <source>The editor can be changed by setting &lt;code&gt;JULIA_EDITOR&lt;/code&gt;, &lt;code&gt;VISUAL&lt;/code&gt; or &lt;code&gt;EDITOR&lt;/code&gt; as an environment variable.</source>
          <target state="translated">&lt;code&gt;JULIA_EDITOR&lt;/code&gt; 、 &lt;code&gt;VISUAL&lt;/code&gt; 、または &lt;code&gt;EDITOR&lt;/code&gt; を環境変数として設定することにより、エディターを変更できます。</target>
        </trans-unit>
        <trans-unit id="8d60f89821e0be17d3c10fd641e166470b0fae98" translate="yes" xml:space="preserve">
          <source>The editor returned by &lt;code&gt;InteractiveUtils.editor()&lt;/code&gt; and used in, e.g., &lt;code&gt;InteractiveUtils.edit&lt;/code&gt;, referring to the command of the preferred editor, for instance &lt;code&gt;vim&lt;/code&gt;.</source>
          <target state="translated">エディタは、によって返さ &lt;code&gt;InteractiveUtils.editor()&lt;/code&gt; 、例えば、及びで使用 &lt;code&gt;InteractiveUtils.edit&lt;/code&gt; インスタンスのために、好適なエディタのコマンドを参照すると、 &lt;code&gt;vim&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f31493a5d545803d2bc443ac0f38b3d641d141b" translate="yes" xml:space="preserve">
          <source>The efficiency gained by being able to store &lt;code&gt;Point{Float64}&lt;/code&gt; objects with immediate values is magnified enormously in the case of arrays: an &lt;code&gt;Array{Float64}&lt;/code&gt; can be stored as a contiguous memory block of 64-bit floating-point values, whereas an &lt;code&gt;Array{Real}&lt;/code&gt; must be an array of pointers to individually allocated &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; objects &amp;ndash; which may well be &lt;a href=&quot;https://en.wikipedia.org/wiki/Object_type_%28object-oriented_programming%29#Boxing&quot;&gt;boxed&lt;/a&gt; 64-bit floating-point values, but also might be arbitrarily large, complex objects, which are declared to be implementations of the &lt;code&gt;Real&lt;/code&gt; abstract type.</source>
          <target state="translated">配列の場合、 &lt;code&gt;Point{Float64}&lt;/code&gt; オブジェクトを即時値で格納できることによって得られる効率は大幅に拡大されます &lt;code&gt;Array{Float64}&lt;/code&gt; は64ビット浮動小数点値の連続メモリブロックとして格納できますが、 &lt;code&gt;Array{Real}&lt;/code&gt; は、個別に割り当てられた&lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;オブジェクトへのポインタの配列である必要があります。これは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Object_type_%28object-oriented_programming%29#Boxing&quot;&gt;ボックス化された&lt;/a&gt; 64ビット浮動小数点値である可能性がありますが、 &lt;code&gt;Real&lt;/code&gt; 抽象型の実装であると宣言されている、任意に大きく複雑なオブジェクトである場合もあります。</target>
        </trans-unit>
        <trans-unit id="77656128da3c3e27758883f72427b834f3cb4b6e" translate="yes" xml:space="preserve">
          <source>The eigenvalues are returned in &lt;code&gt;W&lt;/code&gt; and the eigenvectors in &lt;code&gt;Z&lt;/code&gt;.</source>
          <target state="translated">固有値は &lt;code&gt;W&lt;/code&gt; で返され、固有ベクトルは &lt;code&gt;Z&lt;/code&gt; で返されます。</target>
        </trans-unit>
        <trans-unit id="709d89b2d19663c267d1c6a4862d61316a231e84" translate="yes" xml:space="preserve">
          <source>The element type of the result is chosen using promotion (see &lt;a href=&quot;../base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt;) based on the element type of &lt;code&gt;A&lt;/code&gt; and on the types of the &lt;code&gt;new&lt;/code&gt; values in pairs. If &lt;code&gt;count&lt;/code&gt; is omitted and the element type of &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;Union&lt;/code&gt;, the element type of the result will not include singleton types which are replaced with values of a different type: for example, &lt;code&gt;Union{T,Missing}&lt;/code&gt; will become &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;missing&lt;/code&gt; is replaced.</source>
          <target state="translated">結果のエレメントタイプは、 &lt;code&gt;A&lt;/code&gt; のエレメントタイプおよびペアの &lt;code&gt;new&lt;/code&gt; 値のタイプに基づいて、プロモーション（&lt;a href=&quot;../base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; を&lt;/a&gt;参照）を使用して選択されます。場合 &lt;code&gt;count&lt;/code&gt; 省略さの要素型である &lt;code&gt;A&lt;/code&gt; がある &lt;code&gt;Union&lt;/code&gt; 、結果の要素タイプは、異なるタイプの値に置き換えられるシングルトンタイプを含まない：例えば、 &lt;code&gt;Union{T,Missing}&lt;/code&gt; となるであろう &lt;code&gt;T&lt;/code&gt; の場合に &lt;code&gt;missing&lt;/code&gt; あります交換。</target>
        </trans-unit>
        <trans-unit id="14b4f332ac46b505bad4228677357909dd03b266" translate="yes" xml:space="preserve">
          <source>The element type of the tuple must be an instance of &lt;code&gt;VecElement{T}&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is a primitive type that is 1, 2, 4 or 8 bytes.</source>
          <target state="translated">タプルの要素型は、のインスタンスでなければならない &lt;code&gt;VecElement{T}&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; は 1、2、4又は8バイトであり、プリミティブ型です。</target>
        </trans-unit>
        <trans-unit id="c9296fda074d952d1c87394f1441913d330aa413" translate="yes" xml:space="preserve">
          <source>The empty (or &quot;bottom&quot;) type, written as &lt;code&gt;Union{}&lt;/code&gt; (an empty union type), is a type with no values and no subtypes (except itself). You will generally not need to use this type.</source>
          <target state="translated">&lt;code&gt;Union{}&lt;/code&gt; （空の共用体タイプ）として記述された空（または「底」）タイプは、値とサブタイプ（それ自体を除く）がないタイプです。通常、このタイプを使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="3534ea1366da3151258e1f770bb393a26a8c9156" translate="yes" xml:space="preserve">
          <source>The empty tuple (&lt;code&gt;()&lt;/code&gt;) is another form of nothingness. But, it should not really be thought of as nothing but rather a tuple of zero values.</source>
          <target state="translated">空のタプル（ &lt;code&gt;()&lt;/code&gt; ）は、無の別の形式です。しかし、それは実際にはゼロ値のタプルにすぎないと考えるべきではありません。</target>
        </trans-unit>
        <trans-unit id="f2bd3a290bc2b2f98102d89ff212080bf2528200" translate="yes" xml:space="preserve">
          <source>The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">行末の区切り文字は &lt;code&gt;\n&lt;/code&gt; と見なされます。</target>
        </trans-unit>
        <trans-unit id="13d242b1b1e933d4ec26a29014e675d01b5c3b93" translate="yes" xml:space="preserve">
          <source>The end of line delimiter is taken as &lt;code&gt;\n&lt;/code&gt;. If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</source>
          <target state="translated">行末の区切り文字は &lt;code&gt;\n&lt;/code&gt; と見なされます。すべてのデータが数値の場合、結果は数値配列になります。一部の要素を数値として解析できない場合、数値と文字列の異種混合配列が返されます。</target>
        </trans-unit>
        <trans-unit id="0c21a922512e76aea89910e75ca40814c713417b" translate="yes" xml:space="preserve">
          <source>The entries of &lt;code&gt;F.D1&lt;/code&gt; and &lt;code&gt;F.D2&lt;/code&gt; are related, as explained in the LAPACK documentation for the &lt;a href=&quot;http://www.netlib.org/lapack/lug/node36.html&quot;&gt;generalized SVD&lt;/a&gt; and the &lt;a href=&quot;http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3_8f.html&quot;&gt;xGGSVD3&lt;/a&gt; routine which is called underneath (in LAPACK 3.6.0 and newer).</source>
          <target state="translated">&lt;code&gt;F.D1&lt;/code&gt; と &lt;code&gt;F.D2&lt;/code&gt; のエントリは関連しています。&lt;a href=&quot;http://www.netlib.org/lapack/lug/node36.html&quot;&gt;一般化されたSVD&lt;/a&gt;とその下（LAPACK 3.6.0以降）で呼び出される&lt;a href=&quot;http://www.netlib.org/lapack/explore-html/d6/db3/dggsvd3_8f.html&quot;&gt;xGGSVD3&lt;/a&gt;ルーチンのLAPACKドキュメントで説明されています。</target>
        </trans-unit>
        <trans-unit id="6c6e8a6592578860941072596b3389f0e39bd834" translate="yes" xml:space="preserve">
          <source>The environment variables that Julia uses generally start with &lt;code&gt;JULIA&lt;/code&gt;. If &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.versioninfo&quot;&gt;&lt;code&gt;InteractiveUtils.versioninfo&lt;/code&gt;&lt;/a&gt; is called with the keyword &lt;code&gt;verbose=true&lt;/code&gt;, then the output will list defined environment variables relevant for Julia, including those for which &lt;code&gt;JULIA&lt;/code&gt; appears in the name.</source>
          <target state="translated">Juliaが使用する環境変数は通常、 &lt;code&gt;JULIA&lt;/code&gt; で始まります。&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.versioninfo&quot;&gt; &lt;code&gt;InteractiveUtils.versioninfo&lt;/code&gt; &lt;/a&gt;がキーワード &lt;code&gt;verbose=true&lt;/code&gt; で呼び出された場合、出力には、 &lt;code&gt;JULIA&lt;/code&gt; が名前に表示されるものを含め、Juliaに関連する定義済みの環境変数がリストされます。</target>
        </trans-unit>
        <trans-unit id="7ebc4dca8e995a281e980c9657b899d8cf0df29e" translate="yes" xml:space="preserve">
          <source>The equivalent of an &lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt; HTML tag can be written using the following syntax:</source>
          <target state="translated">&lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt; HTMLタグに相当するものは、次の構文を使用して記述できます。</target>
        </trans-unit>
        <trans-unit id="74efd542b7345e98fdaed051a7a6183a8d020db5" translate="yes" xml:space="preserve">
          <source>The example generated function &lt;code&gt;foo&lt;/code&gt; above did not do anything a normal function &lt;code&gt;foo(x) = x * x&lt;/code&gt; could not do (except printing the type on the first invocation, and incurring higher overhead). However, the power of a generated function lies in its ability to compute different quoted expressions depending on the types passed to it:</source>
          <target state="translated">上記の生成された関数 &lt;code&gt;foo&lt;/code&gt; の例は、通常の関数 &lt;code&gt;foo(x) = x * x&lt;/code&gt; が実行できないことを何もしませんでした（最初の呼び出しで型を出力し、オーバーヘッドが高くなることを除いて）。ただし、生成された関数の威力は、渡された型に応じてさまざまな引用式を計算する能力にあります。</target>
        </trans-unit>
        <trans-unit id="e119c6a2d56d3760f8ebb0ae8619e173f79b4b25" translate="yes" xml:space="preserve">
          <source>The example in the previous section glossed over the implementation details of &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt;&lt;code&gt;promote&lt;/code&gt;&lt;/a&gt;, which both operate in terms of these traits. When iterating over a matrix, such as in the implementation of &lt;code&gt;map&lt;/code&gt;, one important question is what order to use to traverse the data. When &lt;code&gt;AbstractArray&lt;/code&gt; subtypes implement the &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt;&lt;code&gt;Base.IndexStyle&lt;/code&gt;&lt;/a&gt; trait, other functions such as &lt;code&gt;map&lt;/code&gt; can dispatch on this information to pick the best algorithm (see &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;Abstract Array Interface&lt;/a&gt;). This means that each subtype does not need to implement a custom version of &lt;code&gt;map&lt;/code&gt;, since the generic definitions + trait classes will enable the system to select the fastest version. Here a toy implementation of &lt;code&gt;map&lt;/code&gt; illustrating the trait-based dispatch:</source>
          <target state="translated">前のセクションの例では、これらの特性の点で機能&lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt; &lt;code&gt;promote&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;とserveの実装の詳細について説明しました。 &lt;code&gt;map&lt;/code&gt; の実装などで行列を反復する場合、1つの重要な質問は、データをトラバースするために使用する順序です。とき &lt;code&gt;AbstractArray&lt;/code&gt; サブタイプが実装&lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt; &lt;code&gt;Base.IndexStyle&lt;/code&gt; &lt;/a&gt;特性など、他の機能 &lt;code&gt;map&lt;/code&gt; 最高のアルゴリズムを選択するために、この情報に派遣することができます（参照&lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;抽象配列インタフェースを&lt;/a&gt;）。これは、各サブタイプがカスタムバージョンの &lt;code&gt;map&lt;/code&gt; を実装する必要がないことを意味します汎用的な定義+特性クラスにより、システムは最速のバージョンを選択できるようになります。ここで、特性ベースのディスパッチを示す &lt;code&gt;map&lt;/code&gt; おもちゃの実装：</target>
        </trans-unit>
        <trans-unit id="c4e7ac687a3c1938fcc96d92a705ce561c8d3bfd" translate="yes" xml:space="preserve">
          <source>The exception is that quotation marks still must be escaped, e.g. &lt;code&gt;raw&quot;\&quot;&quot;&lt;/code&gt; is equivalent to &lt;code&gt;&quot;\&quot;&quot;&lt;/code&gt;. To make it possible to express all strings, backslashes then also must be escaped, but only when appearing right before a quote character:</source>
          <target state="translated">例外は、例えば、その重引用符はまだエスケープする必要があります &lt;code&gt;raw&quot;\&quot;&quot;&lt;/code&gt; と同等である &lt;code&gt;&quot;\&quot;&quot;&lt;/code&gt; 。すべての文字列を表現できるようにするには、バックスラッシュもエスケープする必要がありますが、引用文字の直前にある場合のみです。</target>
        </trans-unit>
        <trans-unit id="806a2c6eb838f5063922dc987163b721668d0145" translate="yes" xml:space="preserve">
          <source>The exception stack is stored on the &lt;code&gt;Task&lt;/code&gt; where the exceptions occurred. When a task fails with uncaught exceptions, &lt;code&gt;catch_stack(task)&lt;/code&gt; may be used to inspect the exception stack for that task.</source>
          <target state="translated">例外スタックは、例外が発生した &lt;code&gt;Task&lt;/code&gt; に保存されます。キャッチされない例外でタスクが失敗した場合、 &lt;code&gt;catch_stack(task)&lt;/code&gt; を使用して、そのタスクの例外スタックを検査できます。</target>
        </trans-unit>
        <trans-unit id="928c8d0396de54cd800b9aede32ea561fba936f5" translate="yes" xml:space="preserve">
          <source>The exceptions to this rule are the smallest and largest finite values (e.g. &lt;code&gt;nextfloat(-Inf)&lt;/code&gt; and &lt;code&gt;prevfloat(Inf)&lt;/code&gt; for &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;), which round to the smaller of the values.</source>
          <target state="translated">この規則の例外は、最小値と最大値の有限値（&lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; の&lt;/a&gt; &lt;code&gt;nextfloat(-Inf)&lt;/code&gt; および &lt;code&gt;prevfloat(Inf)&lt;/code&gt; など）で、これらの値の小さい方に丸められます。</target>
        </trans-unit>
        <trans-unit id="def91518b0989f4a83def2144fe01cdce215a440" translate="yes" xml:space="preserve">
          <source>The executable itself is one of</source>
          <target state="translated">実行ファイル自体は</target>
        </trans-unit>
        <trans-unit id="0db1c4486699e7de0f4ce2a483205ec8ce5f38db" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;a&lt;/code&gt;, before the &lt;code&gt;?&lt;/code&gt;, is a condition expression, and the ternary operation evaluates the expression &lt;code&gt;b&lt;/code&gt;, before the &lt;code&gt;:&lt;/code&gt;, if the condition &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; or the expression &lt;code&gt;c&lt;/code&gt;, after the &lt;code&gt;:&lt;/code&gt;, if it is &lt;code&gt;false&lt;/code&gt;. Note that the spaces around &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt; are mandatory: an expression like &lt;code&gt;a?b:c&lt;/code&gt; is not a valid ternary expression (but a newline is acceptable after both the &lt;code&gt;?&lt;/code&gt; and the &lt;code&gt;:&lt;/code&gt;).</source>
          <target state="translated">式 &lt;code&gt;a&lt;/code&gt; の前の &lt;code&gt;?&lt;/code&gt; は条件式であり、3項演算は、条件 &lt;code&gt;a&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合、 &lt;code&gt;:&lt;/code&gt; の前に式 &lt;code&gt;b&lt;/code&gt; を評価し、条件aがtrueの場合、 &lt;code&gt;:&lt;/code&gt; の後に式 &lt;code&gt;c&lt;/code&gt; を評価し &lt;code&gt;false&lt;/code&gt; 。周りのスペースに注意してください &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt; は必須 &lt;code&gt;a?b:c&lt;/code&gt; ような式は有効な3項式ではありません（ただし、 &lt;code&gt;?&lt;/code&gt; と &lt;code&gt;:&lt;/code&gt; の両方の後に改行を入れることはできます）。</target>
        </trans-unit>
        <trans-unit id="465bf593bbe53b12eb7783b96c9712a167cf8578" translate="yes" xml:space="preserve">
          <source>The expression passed to the &lt;a href=&quot;#Base.Meta.parse-Tuple%7BAbstractString,Int64%7D&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; function could not be interpreted as a valid Julia expression.</source>
          <target state="translated">&lt;a href=&quot;#Base.Meta.parse-Tuple%7BAbstractString,Int64%7D&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt;関数に渡された式は、有効なジュリア式として解釈できませんでした。</target>
        </trans-unit>
        <trans-unit id="a177c1288ef44211cc6e949df284aa83f006f7fc" translate="yes" xml:space="preserve">
          <source>The extension given by the constant &lt;code&gt;dlext&lt;/code&gt; (&lt;code&gt;.so&lt;/code&gt;, &lt;code&gt;.dll&lt;/code&gt;, or &lt;code&gt;.dylib&lt;/code&gt;) can be omitted from the &lt;code&gt;libfile&lt;/code&gt; string, as it is automatically appended if needed. If &lt;code&gt;libfile&lt;/code&gt; is not an absolute path name, then the paths in the array &lt;code&gt;DL_LOAD_PATH&lt;/code&gt; are searched for &lt;code&gt;libfile&lt;/code&gt;, followed by the system load path.</source>
          <target state="translated">定数 &lt;code&gt;dlext&lt;/code&gt; （ &lt;code&gt;.so&lt;/code&gt; 、 &lt;code&gt;.dll&lt;/code&gt; 、または &lt;code&gt;.dylib&lt;/code&gt; ）によって指定された &lt;code&gt;libfile&lt;/code&gt; は、必要に応じて自動的に追加されるため、libfile文字列から省略できます。場合 &lt;code&gt;libfile&lt;/code&gt; 絶対パス名でない場合、アレイ内のパス &lt;code&gt;DL_LOAD_PATH&lt;/code&gt; が探索される &lt;code&gt;libfile&lt;/code&gt; 、システム負荷のパスが続きます。</target>
        </trans-unit>
        <trans-unit id="36c16e65be4afc2c66cb3288c6300982f05c7ad1" translate="yes" xml:space="preserve">
          <source>The fact that the type of &lt;code&gt;m.a&lt;/code&gt; is known from &lt;code&gt;m&lt;/code&gt;'s type&amp;mdash;coupled with the fact that its type cannot change mid-function&amp;mdash;allows the compiler to generate highly-optimized code for objects like &lt;code&gt;m&lt;/code&gt; but not for objects like &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;m.a&lt;/code&gt; の型が &lt;code&gt;m&lt;/code&gt; の型からわかるという事実は、その型が関数の途中で変更できないという事実と相まって、コンパイラーは &lt;code&gt;m&lt;/code&gt; のようなオブジェクトに対して高度に最適化されたコードを生成できますが、 &lt;code&gt;t&lt;/code&gt; のようなオブジェクトに対してはできません。</target>
        </trans-unit>
        <trans-unit id="c0c52690600fcbcb99da1f62c4bac2b9e5d6f697" translate="yes" xml:space="preserve">
          <source>The fallback definition is</source>
          <target state="translated">フォールバックの定義は</target>
        </trans-unit>
        <trans-unit id="ee6beb39d94f4bf27bb085bd2200c292b19c5e9a" translate="yes" xml:space="preserve">
          <source>The fields represent:</source>
          <target state="translated">フィールドが表しています。</target>
        </trans-unit>
        <trans-unit id="c9020dd8336689ac7fec628824c2784dbf9a80fb" translate="yes" xml:space="preserve">
          <source>The file is passed via the stream argument, either as an open &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt;&lt;code&gt;IOStream&lt;/code&gt;&lt;/a&gt; or filename string. When you initialize the stream, use &lt;code&gt;&quot;r&quot;&lt;/code&gt; for a &quot;read-only&quot; array, and &lt;code&gt;&quot;w+&quot;&lt;/code&gt; to create a new array used to write values to disk.</source>
          <target state="translated">ファイルは、オープン&lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt; &lt;code&gt;IOStream&lt;/code&gt; &lt;/a&gt;またはファイル名文字列として、stream引数を介して渡されます。ストリームを初期化するとき、「読み取り専用」配列には &lt;code&gt;&quot;r&quot;&lt;/code&gt; を使用し、値をディスクに書き込むために使用される新しい配列を作成するには &lt;code&gt;&quot;w+&quot;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="689e05efadfddad191a25330c014009d3e84b447" translate="yes" xml:space="preserve">
          <source>The file-system preferred block size for the file</source>
          <target state="translated">ファイルシステムが優先するファイルのブロックサイズ</target>
        </trans-unit>
        <trans-unit id="c3038fc2cf1255c7ec1e11b0a18b74e94018430a" translate="yes" xml:space="preserve">
          <source>The final call to &lt;code&gt;qsort&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;qsort&lt;/code&gt; の最後の呼び出しは次のようになります。</target>
        </trans-unit>
        <trans-unit id="7d988c680830d3c098bed962d30d54cd701b74ad" translate="yes" xml:space="preserve">
          <source>The final problem which has still not been addressed is construction of self-referential objects, or more generally, recursive data structures. Since the fundamental difficulty may not be immediately obvious, let us briefly explain it. Consider the following recursive type declaration:</source>
          <target state="translated">最後の問題は、自己参照オブジェクト、より一般的には再帰的なデータ構造の構築である。根本的な問題はすぐには明らかではないかもしれませんので、簡単に説明しましょう。次の再帰的型宣言を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="2c490723b997dd55f5ce00727bf52c98838be748" translate="yes" xml:space="preserve">
          <source>The first &quot;important&quot; line in this output is this one:</source>
          <target state="translated">この出力の最初の「重要」な行がこの行です。</target>
        </trans-unit>
        <trans-unit id="355a754edd3ac1108f8aa47f09609e4797573a28" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;old&lt;/code&gt; is the signature of the deprecated method, the second one &lt;code&gt;new&lt;/code&gt; is the call which replaces it. &lt;code&gt;@deprecate&lt;/code&gt; exports &lt;code&gt;old&lt;/code&gt; unless the optional third argument is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">最初の引数 &lt;code&gt;old&lt;/code&gt; は非推奨のメソッドのシグネチャであり、2番目の引数 &lt;code&gt;new&lt;/code&gt; はそれを置き換える呼び出しです。 &lt;code&gt;@deprecate&lt;/code&gt; は、オプションの3番目の引数が &lt;code&gt;false&lt;/code&gt; でない限り、 &lt;code&gt;old&lt;/code&gt; エクスポートします。</target>
        </trans-unit>
        <trans-unit id="ca4a6f093dfc816b748358bcada908fd4397bf69" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; can be marked with a &lt;code&gt;$&lt;/code&gt;, in which case the return value will instead be a &lt;code&gt;struct CFunction&lt;/code&gt; which closes over the argument. You must ensure that this return object is kept alive until all uses of it are done. The contents and code at the cfunction pointer will be erased via a &lt;a href=&quot;../../base/base/index#Base.finalizer&quot;&gt;&lt;code&gt;finalizer&lt;/code&gt;&lt;/a&gt; when this reference is dropped and atexit. This is not usually needed, since this functionality is not present in C, but can be useful for dealing with ill-designed APIs which don't provide a separate closure environment parameter.</source>
          <target state="translated">&lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; &lt;/a&gt;の最初の引数は &lt;code&gt;$&lt;/code&gt; でマークすることができます。その場合、戻り値は代わりに、引数を閉じる &lt;code&gt;struct CFunction&lt;/code&gt; になります。この戻りオブジェクトは、すべての使用が終了するまで存続するようにする必要があります。この参照が削除されてatexit されると、cfunctionポインターのコンテンツとコードは&lt;a href=&quot;../../base/base/index#Base.finalizer&quot;&gt; &lt;code&gt;finalizer&lt;/code&gt; &lt;/a&gt;を介して消去されます。この機能はCにはないため、通常は必要ありませんが、個別のクロージャー環境パラメーターを提供しない、設計が不適切なAPIを処理する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="693dd527818a9b4cb2e07e46d1435896bbc1c434" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; can also be an expression evaluated at run time. In this case, the expression must evaluate to a &lt;code&gt;Ptr&lt;/code&gt;, which will be used as the address of the native function to call. This behavior occurs when the first &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; argument contains references to non-constants, such as local variables, function arguments, or non-constant globals.</source>
          <target state="translated">&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;の最初の引数は、実行時に評価される式にすることもできます。この場合、式は &lt;code&gt;Ptr&lt;/code&gt; に評価される必要があります。これは、呼び出すネイティブ関数のアドレスとして使用されます。この現象は、最初の&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;引数にローカル変数、関数引数、非定数グローバルなどの非定数への参照が含まれている場合に発生します。</target>
        </trans-unit>
        <trans-unit id="145bbc0abe5deab0a11d30eff56416193fa999ea" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;remotecall&lt;/code&gt; is the function to call. Most parallel programming in Julia does not reference specific processes or the number of processes available, but &lt;code&gt;remotecall&lt;/code&gt; is considered a low-level interface providing finer control. The second argument to &lt;code&gt;remotecall&lt;/code&gt; is the &lt;code&gt;id&lt;/code&gt; of the process that will do the work, and the remaining arguments will be passed to the function being called.</source>
          <target state="translated">&lt;code&gt;remotecall&lt;/code&gt; の最初の引数は、呼び出す関数です。Juliaのほとんどの並列プログラミングは、特定のプロセスや使用可能なプロセスの数を参照していませんが、 &lt;code&gt;remotecall&lt;/code&gt; は、より詳細な制御を提供する低レベルのインターフェイスと見なされています。 &lt;code&gt;remotecall&lt;/code&gt; の2番目の引数は、作業を実行するプロセスの &lt;code&gt;id&lt;/code&gt; であり、残りの引数は、呼び出される関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="25e1aab2d5890f1ec3fee29d387628c8119eeb0c" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;show&lt;/code&gt; can be an &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; specifying output format properties. See &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;show&lt;/code&gt; の最初の引数は、出力フォーマットプロパティを指定する&lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;です。詳細については、&lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="52b90970f0dc891c8696d7672a072123d726419a" translate="yes" xml:space="preserve">
          <source>The first call to &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt;&lt;code&gt;println&lt;/code&gt;&lt;/a&gt; is executed when &lt;a href=&quot;../../base/base/index#Base.macroexpand&quot;&gt;&lt;code&gt;macroexpand&lt;/code&gt;&lt;/a&gt; is called. The resulting expression contains &lt;em&gt;only&lt;/em&gt; the second &lt;code&gt;println&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt; &lt;code&gt;println&lt;/code&gt; &lt;/a&gt;の最初の呼び出しは、&lt;a href=&quot;../../base/base/index#Base.macroexpand&quot;&gt; &lt;code&gt;macroexpand&lt;/code&gt; &lt;/a&gt;が呼び出されたときに実行されます。結果の式に&lt;em&gt;は&lt;/em&gt;、2番目の &lt;code&gt;println&lt;/code&gt; &lt;em&gt;のみ&lt;/em&gt;が含まれます。</target>
        </trans-unit>
        <trans-unit id="8464368be55c0ee0f473e53693ff139c3f5a4a18" translate="yes" xml:space="preserve">
          <source>The first case works, because the last character &lt;code&gt;y&lt;/code&gt; and the space are one-byte characters, whereas &lt;code&gt;end-2&lt;/code&gt; indexes into the middle of the &lt;code&gt;&amp;exist;&lt;/code&gt; multibyte representation. The correct way for this case is using &lt;code&gt;prevind(s, lastindex(s), 2)&lt;/code&gt; or, if you're using that value to index into &lt;code&gt;s&lt;/code&gt; you can write &lt;code&gt;s[prevind(s, end, 2)]&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; expands to &lt;code&gt;lastindex(s)&lt;/code&gt;.</source>
          <target state="translated">最初のケースは機能します。これは、最後の文字 &lt;code&gt;y&lt;/code&gt; とスペースが1バイト文字であるのに対し、 &lt;code&gt;end-2&lt;/code&gt; は、 &lt;code&gt;&amp;exist;&lt;/code&gt; マルチバイト表現の中央にインデックスを付けるためです。この場合の正しい方法は、 &lt;code&gt;prevind(s, lastindex(s), 2)&lt;/code&gt; を使用することです。または、その値を使用して &lt;code&gt;s&lt;/code&gt; にインデックスを付ける場合は、 &lt;code&gt;s[prevind(s, end, 2)]&lt;/code&gt; と記述して &lt;code&gt;end&lt;/code&gt; を展開します。 &lt;code&gt;lastindex(s)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cae7754ed7d4e8921dc21019e00cb20a90b09dbc" translate="yes" xml:space="preserve">
          <source>The first construct is used when you need the value, but not index, of each element. In the second construct, &lt;code&gt;i&lt;/code&gt; will be an &lt;code&gt;Int&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is an array type with fast linear indexing; otherwise, it will be a &lt;code&gt;CartesianIndex&lt;/code&gt;:</source>
          <target state="translated">最初の構成は、各要素の値ではなくインデックスが必要な場合に使用されます。2番目の構成では、 &lt;code&gt;A&lt;/code&gt; が高速な線形インデックスを持つ配列型の場合、 &lt;code&gt;i&lt;/code&gt; は &lt;code&gt;Int&lt;/code&gt; になります。それ以外の場合は、 &lt;code&gt;CartesianIndex&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="1a131f32e4f6815b22742934540634fef42489da" translate="yes" xml:space="preserve">
          <source>The first entry is the &quot;user depot&quot; and should be writable by and owned by the current user. The user depot is where: registries are cloned, new package versions are installed, named environments are created and updated, package repos are cloned, newly compiled package image files are saved, log files are written, development packages are checked out by default, and global configuration data is saved. Later entries in the depot path are treated as read-only and are appropriate for registries, packages, etc. installed and managed by system administrators.</source>
          <target state="translated">最初のエントリは &quot;user depot&quot; で、現在のユーザが書き込み可能であり、所有している必要があります。レジストリの複製、新しいバージョンのパッケージのインストール、名前付き環境の作成と更新、パッケージリポジトリの複製、新しくコンパイルされたパッケージイメージファイルの保存、ログファイルの書き込み、開発パッケージのデフォルトでのチェックアウト、グローバル設定データの保存が行われます。デポパスの後のエントリは読み取り専用として扱われ、システム管理者がインストールして管理するレジストリやパッケージなどに適しています。</target>
        </trans-unit>
        <trans-unit id="006a5d47461c1a2f566eaae2f91fca6d12ba4594" translate="yes" xml:space="preserve">
          <source>The first five control flow mechanisms are standard to high-level programming languages. &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s are not so standard: they provide non-local control flow, making it possible to switch between temporarily-suspended computations. This is a powerful construct: both exception handling and cooperative multitasking are implemented in Julia using tasks. Everyday programming requires no direct usage of tasks, but certain problems can be solved much more easily by using tasks.</source>
          <target state="translated">最初の5つの制御フローメカニズムは、高水準プログラミング言語の標準です。&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;はそれほど標準的ではありません。それらは非ローカル制御フローを提供し、一時的に中断された計算を切り替えることを可能にします。これは強力な構造です。例外処理と協調マルチタスクの両方が、Juliaでタスクを使用して実装されています。日常のプログラミングではタスクを直接使用する必要はありませんが、特定の問題はタスクを使用することではるかに簡単に解決できます。</target>
        </trans-unit>
        <trans-unit id="bc720da072f28a4dbfd483b203295a21a9e3bf91" translate="yes" xml:space="preserve">
          <source>The first index</source>
          <target state="translated">最初のインデックス</target>
        </trans-unit>
        <trans-unit id="bb11ec038c2596553227120950a5afbedeee7655" translate="yes" xml:space="preserve">
          <source>The first line &amp;ndash; &lt;code&gt;struct OurRational{T&amp;lt;:Integer} &amp;lt;: Real&lt;/code&gt; &amp;ndash; declares that &lt;code&gt;OurRational&lt;/code&gt; takes one type parameter of an integer type, and is itself a real type. The field declarations &lt;code&gt;num::T&lt;/code&gt; and &lt;code&gt;den::T&lt;/code&gt; indicate that the data held in a &lt;code&gt;OurRational{T}&lt;/code&gt; object are a pair of integers of type &lt;code&gt;T&lt;/code&gt;, one representing the rational value's numerator and the other representing its denominator.</source>
          <target state="translated">1行目&amp;ndash; &lt;code&gt;struct OurRational{T&amp;lt;:Integer} &amp;lt;: Real&lt;/code&gt; &amp;ndash; &lt;code&gt;OurRational&lt;/code&gt; が整数型の型パラメーターを1つ取り、それ自体が実数型であることを宣言します。フィールド宣言 &lt;code&gt;num::T&lt;/code&gt; および &lt;code&gt;den::T&lt;/code&gt; は、 &lt;code&gt;OurRational{T}&lt;/code&gt; オブジェクトに保持されているデータが &lt;code&gt;T&lt;/code&gt; 型の整数のペアであることを示します。1つは有理値の分子を表し、もう1つはその分母を表します。</target>
        </trans-unit>
        <trans-unit id="427adf0e5c19944f265b6711e004071ffee6d958" translate="yes" xml:space="preserve">
          <source>The first line shows that 80 backtraces were taken at line 73 of &lt;code&gt;event.jl&lt;/code&gt;, but it's not that this line was &quot;expensive&quot; on its own: the third line reveals that all 80 of these backtraces were actually triggered inside its call to &lt;code&gt;eval_user_input&lt;/code&gt;, and so on. To find out which operations are actually taking the time, we need to look deeper in the call chain.</source>
          <target state="translated">80のバックトレースがのライン73で撮影したことを最初の行ショー &lt;code&gt;event.jl&lt;/code&gt; 三行目は、これらのバックトレースのすべての80が実際にその呼び出しの内部でトリガされたことが明らかになった。が、それはこの行は、独自の「高価」であったということではありません &lt;code&gt;eval_user_input&lt;/code&gt; 、等々。実際に時間がかかっている操作を見つけるには、コールチェーンをより深く調べる必要があります。</target>
        </trans-unit>
        <trans-unit id="37442d0cb92e69637999d8ebca28303617dca96e" translate="yes" xml:space="preserve">
          <source>The first method applies whenever both arguments are of the same concrete type, regardless of what type that is, while the second method acts as a catch-all, covering all other cases. Thus, overall, this defines a boolean function that checks whether its two arguments are of the same type:</source>
          <target state="translated">最初のメソッドは、両方の引数が同じ具体的な型である場合には、それがどの型であるかに関係なく適用され、2番目のメソッドはキャッチオールとして動作し、他のすべてのケースをカバーします。このように、全体的には、2つの引数が同じ型であるかどうかをチェックするブール関数を定義しています。</target>
        </trans-unit>
        <trans-unit id="babb1cbcd790c4e72ac9f6036b92d0c0da3483a5" translate="yes" xml:space="preserve">
          <source>The first rule says that promoting a rational number with any other integer type promotes to a rational type whose numerator/denominator type is the result of promotion of its numerator/denominator type with the other integer type. The second rule applies the same logic to two different types of rational numbers, resulting in a rational of the promotion of their respective numerator/denominator types. The third and final rule dictates that promoting a rational with a float results in the same type as promoting the numerator/denominator type with the float.</source>
          <target state="translated">第1の規則は、有理数を他の整数型で促進すると、分子/分母型がその分子/分母型を他の整数型で促進した結果、分子/分母型が有理型に促進されるというものです。第2の規則は、2つの異なるタイプの有理数に同じ論理を適用し、それぞれの分子/分母型の促進の結果として有理型になります。3番目の最後の規則は、floatで有理数を促進すると、floatで分子/分母型を促進するのと同じ型になることを規定しています。</target>
        </trans-unit>
        <trans-unit id="5020af03736f636ddf8f18f7a30cb8b1c77d29b4" translate="yes" xml:space="preserve">
          <source>The first thing that has to be done before calling any other Julia C function is to initialize Julia. This is done by calling &lt;code&gt;jl_init&lt;/code&gt;, which tries to automatically determine Julia's install location. If you need to specify a custom location, or specify which system image to load, use &lt;code&gt;jl_init_with_image&lt;/code&gt; instead.</source>
          <target state="translated">他のJulia C関数を呼び出す前に最初に行わなければならないことは、Juliaを初期化することです。これは、Juliaのインストール場所を自動的に決定しようとする &lt;code&gt;jl_init&lt;/code&gt; を呼び出すことによって行われます。カスタムの場所を指定する必要がある場合、またはロードするシステムイメージを指定する必要がある場合は、代わりに &lt;code&gt;jl_init_with_image&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="823f93752a3686f8e2124abf1332680955d50534" translate="yes" xml:space="preserve">
          <source>The first thing to note is that the above argument declarations are equivalent to &lt;code&gt;x::Any&lt;/code&gt; and &lt;code&gt;y::Any&lt;/code&gt;. When this function is invoked, say as &lt;code&gt;myplus(2,5)&lt;/code&gt;, the dispatcher chooses the most specific method named &lt;code&gt;myplus&lt;/code&gt; that matches the given arguments. (See &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt; for more information on multiple dispatch.)</source>
          <target state="translated">最初に注意すべきことは、上記の引数宣言は &lt;code&gt;x::Any&lt;/code&gt; および &lt;code&gt;y::Any&lt;/code&gt; と同等であることです。この関数が呼び出されると、たとえば &lt;code&gt;myplus(2,5)&lt;/code&gt; のように、ディスパッチャーは指定された引数に一致する &lt;code&gt;myplus&lt;/code&gt; という名前の最も具体的なメソッドを選択します。（複数のディスパッチの詳細については、&lt;a href=&quot;../methods/index#Methods-1&quot;&gt;メソッド&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="a6f07b43794fd555596c18f4ead21c7719a2dcd3" translate="yes" xml:space="preserve">
          <source>The first version of the code forms a string, then writes it to the file, while the second version writes values directly to the file. Also notice that in some cases string interpolation can be harder to read. Consider:</source>
          <target state="translated">最初のバージョンのコードは文字列を形成してからファイルに書き込み、2番目のバージョンは値を直接ファイルに書き込みます。また、場合によっては文字列の補間が読みにくくなることにも注意してください。次のように考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="7b79b92115c47e04b621f66bea7584e8b8cc8d6b" translate="yes" xml:space="preserve">
          <source>The floating-point literal expression &lt;code&gt;1e10&lt;/code&gt; could be interpreted as the numeric literal &lt;code&gt;1&lt;/code&gt; multiplied by the variable &lt;code&gt;e10&lt;/code&gt;, and similarly with the equivalent &lt;code&gt;E&lt;/code&gt; form.</source>
          <target state="translated">浮動小数点リテラル式 &lt;code&gt;1e10&lt;/code&gt; は、数値リテラル &lt;code&gt;1&lt;/code&gt; に変数 &lt;code&gt;e10&lt;/code&gt; を掛けたものと解釈でき、同等の &lt;code&gt;E&lt;/code&gt; 形式でも同様です。</target>
        </trans-unit>
        <trans-unit id="b8f774bd2a3cc1859a12b8ce9ea22d04daec926b" translate="yes" xml:space="preserve">
          <source>The floored quotient and modulus after division. Equivalent to &lt;code&gt;(fld(x,y), mod(x,y))&lt;/code&gt;.</source>
          <target state="translated">除算後のフロアされた商と係数。 &lt;code&gt;(fld(x,y), mod(x,y))&lt;/code&gt; 同等です。</target>
        </trans-unit>
        <trans-unit id="bc58e18ac764f385326b970e654dea814c444fa3" translate="yes" xml:space="preserve">
          <source>The folder &lt;code&gt;clustermanager/0mq&lt;/code&gt; in the &lt;a href=&quot;https://github.com/JuliaAttic/Examples&quot;&gt;Examples repository&lt;/a&gt; contains an example of using ZeroMQ to connect Julia workers in a star topology with a 0MQ broker in the middle. Note: The Julia processes are still all &lt;em&gt;logically&lt;/em&gt; connected to each other&amp;ndash;any worker can message any other worker directly without any awareness of 0MQ being used as the transport layer.</source>
          <target state="translated">フォルダ &lt;code&gt;clustermanager/0mq&lt;/code&gt; での&lt;a href=&quot;https://github.com/JuliaAttic/Examples&quot;&gt;例リポジトリには、&lt;/a&gt;途中で0MQブローカーとスタートポロジでジュリアの労働者を接続するためにZeroMQを使用する例が含まれています。注：Juliaプロセスは依然として&lt;em&gt;論理的&lt;/em&gt;に相互に接続されています。どのワーカーも、トランスポート層として使用されている0MQを意識することなく、他のワーカーに直接メッセージを送信できます。</target>
        </trans-unit>
        <trans-unit id="a25bab23609fe72a03f9f2d28cbc6e4cfaac93b5" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations&quot;&gt;arithmetic operators&lt;/a&gt; are supported on all primitive numeric types:</source>
          <target state="translated">次の&lt;a href=&quot;https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations&quot;&gt;算術演算子&lt;/a&gt;は、すべてのプリミティブ数値型でサポートされています。</target>
        </trans-unit>
        <trans-unit id="b432537d382d58fcb2012895b80fa177f57617f4" translate="yes" xml:space="preserve">
          <source>The following &lt;a href=&quot;https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators&quot;&gt;bitwise operators&lt;/a&gt; are supported on all primitive integer types:</source>
          <target state="translated">次の&lt;a href=&quot;https://en.wikipedia.org/wiki/Bitwise_operation#Bitwise_operators&quot;&gt;ビット演算子&lt;/a&gt;は、すべてのプリミティブ整数型でサポートされています。</target>
        </trans-unit>
        <trans-unit id="bc2ce27e5cd51f5b5da2d26eef20e592177e82dd" translate="yes" xml:space="preserve">
          <source>The following Julia code calls &lt;code&gt;dist&lt;/code&gt; using &lt;code&gt;ccall&lt;/code&gt;:</source>
          <target state="translated">次のJuliaコードは &lt;code&gt;ccall&lt;/code&gt; を使用して &lt;code&gt;dist&lt;/code&gt; を呼び出します：</target>
        </trans-unit>
        <trans-unit id="82ab1c7eae6116d2e86f4fd6447f19f5008f2767" translate="yes" xml:space="preserve">
          <source>The following are Julia's primitive numeric types:</source>
          <target state="translated">ジュリアの原始的な数値型は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="68261312da3f6e4277114d21e46489769870f01a" translate="yes" xml:space="preserve">
          <source>The following arguments, if any, are the actual argument values passed to the function.</source>
          <target state="translated">以下の引数がある場合は、関数に渡される実際の引数の値です。</target>
        </trans-unit>
        <trans-unit id="345825a433cae3afd4ca7643a01203ee8503ec4c" translate="yes" xml:space="preserve">
          <source>The following elements can be written either at the &quot;toplevel&quot; of a document or within another &quot;toplevel&quot; element.</source>
          <target state="translated">以下の要素は、文書の &quot;toplevel &quot;に記述するか、別の &quot;toplevel &quot;要素内に記述することができます。</target>
        </trans-unit>
        <trans-unit id="5790b1d96d0b783ee001251802dd3d3773c38e07" translate="yes" xml:space="preserve">
          <source>The following escape sequences are recognised:</source>
          <target state="translated">以下のエスケープシーケンスが認識されます。</target>
        </trans-unit>
        <trans-unit id="b2e62d45eb7d1c7cb2ac8b8faa743869642b4084" translate="yes" xml:space="preserve">
          <source>The following example computes a weighted average of the current element and its left and right neighbor along a 1-d grid. :</source>
          <target state="translated">次の例では、1次元グリッドに沿って現在の要素とその左右の隣り合う要素の加重平均を計算しています。</target>
        </trans-unit>
        <trans-unit id="07c71a4306d82cac91450f4de662495a1563cd2f" translate="yes" xml:space="preserve">
          <source>The following example computes the QR decomposition of a small section of a larger array, without creating any temporaries, and by calling the appropriate LAPACK function with the right leading dimension size and stride parameters.</source>
          <target state="translated">次の例は,テンポラリを作成せずに,適切なLAPACK関数を呼び出して,適切な先行寸法サイズとストライドパラメータを指定して,より大きな配列の小さなセクションのQR分解を計算します.</target>
        </trans-unit>
        <trans-unit id="01c45a39447b88a2e0d45df263308e82a86e4712" translate="yes" xml:space="preserve">
          <source>The following example demonstrates the major features of modules. It is not meant to be run, but is shown for illustrative purposes:</source>
          <target state="translated">以下の例は、モジュールの主な機能を示しています。これは実行することを意図したものではありませんが、説明のために示しています。</target>
        </trans-unit>
        <trans-unit id="ec34fbe859ef32bab5a71865f07de40a61bead9c" translate="yes" xml:space="preserve">
          <source>The following examples highlight execution in different tasks by returning the &lt;code&gt;objectid&lt;/code&gt; of the tasks in which the mapping function is executed.</source>
          <target state="translated">次の例では、マッピング関数が実行されるタスクの &lt;code&gt;objectid&lt;/code&gt; を返すことにより、さまざまなタスクでの実行を強調しています。</target>
        </trans-unit>
        <trans-unit id="874609aa4f87e9365e65a6b29283f60a85fb17ac" translate="yes" xml:space="preserve">
          <source>The following examples may help you interpret expressions marked as containing non-leaf types:</source>
          <target state="translated">以下の例は、非リーフ型を含むとマークされた式を解釈するのに役立つかもしれません。</target>
        </trans-unit>
        <trans-unit id="cbdf8c8b616fe2394336d97bc9a1e9b4526f4626" translate="yes" xml:space="preserve">
          <source>The following examples show the different forms.</source>
          <target state="translated">以下の例では、様々な形態を示しています。</target>
        </trans-unit>
        <trans-unit id="e0233afcec03abf55b61a44d6697627a2028159d" translate="yes" xml:space="preserve">
          <source>The following functions are available for &lt;code&gt;BunchKaufman&lt;/code&gt; objects: &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.issymmetric&quot;&gt;&lt;code&gt;issymmetric&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.ishermitian&quot;&gt;&lt;code&gt;ishermitian&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;BunchKaufman&lt;/code&gt; オブジェクトでは、次の関数を使用できます：&lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;\&lt;/code&gt; 、 &lt;code&gt;inv&lt;/code&gt; 、&lt;a href=&quot;#LinearAlgebra.issymmetric&quot;&gt; &lt;code&gt;issymmetric&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#LinearAlgebra.ishermitian&quot;&gt; &lt;code&gt;ishermitian&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="624545d56fb5f27fa75152ac7cc2635666c3e206" translate="yes" xml:space="preserve">
          <source>The following functions are available for &lt;code&gt;Eigen&lt;/code&gt; objects: &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt;&lt;code&gt;isposdef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">以下のために以下の機能が利用できます &lt;code&gt;Eigen&lt;/code&gt; オブジェクト： &lt;code&gt;inv&lt;/code&gt; 、&lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt; &lt;code&gt;isposdef&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1aea27103439af78084bb11124346f279815f32" translate="yes" xml:space="preserve">
          <source>The following functions are available for the &lt;code&gt;QR&lt;/code&gt; objects: &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;\&lt;/code&gt;. When &lt;code&gt;A&lt;/code&gt; is rectangular, &lt;code&gt;\&lt;/code&gt; will return a least squares solution and if the solution is not unique, the one with smallest norm is returned. When &lt;code&gt;A&lt;/code&gt; is not full rank, factorization with (column) pivoting is required to obtain a minimum norm solution.</source>
          <target state="translated">次の関数は、 &lt;code&gt;QR&lt;/code&gt; オブジェクトで使用できます： &lt;code&gt;inv&lt;/code&gt; 、&lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt;、および &lt;code&gt;\&lt;/code&gt; 。 &lt;code&gt;A&lt;/code&gt; が長方形の場合、 &lt;code&gt;\&lt;/code&gt; は最小二乗解を返します。解が一意でない場合は、ノルムが最小のものが返されます。 &lt;code&gt;A&lt;/code&gt; がフルランクでない場合、最小のノルム解を得るために、（列）ピボットによる因数分解が必要です。</target>
        </trans-unit>
        <trans-unit id="aabc44011e588107ac199e54e743b25f507c9ed0" translate="yes" xml:space="preserve">
          <source>The following functions are not exported:</source>
          <target state="translated">以下の関数はエクスポートされません。</target>
        </trans-unit>
        <trans-unit id="688d351a0c5736fa7ecff6e47939996801847a5a" translate="yes" xml:space="preserve">
          <source>The following language constructs call &lt;code&gt;convert&lt;/code&gt;:</source>
          <target state="translated">次の言語構成は、 &lt;code&gt;convert&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="6c5e57131238ccfda9b38e0c3969a02ae25bed8d" translate="yes" xml:space="preserve">
          <source>The following methods and types in &lt;code&gt;Base.StackTraces&lt;/code&gt; are not exported and need to be called e.g. as &lt;code&gt;StackTraces.lookup(ptr)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Base.StackTraces&lt;/code&gt; の以下のメソッドとタイプはエクスポートされないため、たとえば &lt;code&gt;StackTraces.lookup(ptr)&lt;/code&gt; として呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="427d5751feb1ea6470872d5f773b472a734eb30c" translate="yes" xml:space="preserve">
          <source>The following methods are described as &quot;unsafe&quot; because a bad pointer or type declaration can cause Julia to terminate abruptly.</source>
          <target state="translated">以下のメソッドは「安全ではない」と記述されていますが、これは悪いポインタや型宣言があるとジュリアが突然終了してしまう可能性があるからです。</target>
        </trans-unit>
        <trans-unit id="b0ebcfaf65e09f2421f1536d1962299cfa2d23fa" translate="yes" xml:space="preserve">
          <source>The following operators are supported for arrays:</source>
          <target state="translated">配列には以下の演算子がサポートされています。</target>
        </trans-unit>
        <trans-unit id="61cb6687852400c8b9d8a7c3529a66703d4cce18" translate="yes" xml:space="preserve">
          <source>The following properties are in common use:</source>
          <target state="translated">以下のような物件が一般的に使用されています。</target>
        </trans-unit>
        <trans-unit id="d1b72ce471ac18a5159131679678a4b35625017b" translate="yes" xml:space="preserve">
          <source>The following rules and examples pertain to local scopes. A newly introduced variable in a local scope cannot be referenced by a parent scope. For example, here the $z$ is not introduced into the top-level scope:</source>
          <target state="translated">以下のルールと例は、ローカル スコープに関するものです。ローカル・スコープに新しく導入された変数は、親スコープから参照することはできません。例えば、ここでは $z$ はトップレベルのスコープには導入されていません。</target>
        </trans-unit>
        <trans-unit id="b337c7ef95094018464c8f26d41814785e93faec" translate="yes" xml:space="preserve">
          <source>The following sections explain a few aspects of idiomatic Julia coding style. None of these rules are absolute; they are only suggestions to help familiarize you with the language and to help you choose among alternative designs.</source>
          <target state="translated">以下のセクションでは、イディオマティック・ジュリアのコーディング・スタイルのいくつかの側面を説明します。これらのルールはどれも絶対的なものではなく、言語に慣れ親しんだり、他のデザインの中から選択したりするのに役立つ提案に過ぎません。</target>
        </trans-unit>
        <trans-unit id="599c61734f3be9adb8efdea5a3e2879b8d0d65f5" translate="yes" xml:space="preserve">
          <source>The following table gives a correspondence between built-in methods on sparse matrices and their corresponding methods on dense matrix types. In general, methods that generate sparse matrices differ from their dense counterparts in that the resulting matrix follows the same sparsity pattern as a given sparse matrix &lt;code&gt;S&lt;/code&gt;, or that the resulting sparse matrix has density &lt;code&gt;d&lt;/code&gt;, i.e. each matrix element has a probability &lt;code&gt;d&lt;/code&gt; of being non-zero.</source>
          <target state="translated">次の表は、疎行列の組み込みメソッドと密行列タイプの対応するメソッドの対応を示しています。得られたマトリックスは、与えられた疎な行列と同じスパースパターンは以下の点で、一般的に、スパース行列を生成する方法は、その緻密な対応物とは異なる &lt;code&gt;S&lt;/code&gt; を、または得られる疎行列は、濃度たことを &lt;code&gt;d&lt;/code&gt; 、すなわち、各行列要素は確率有し &lt;code&gt;d&lt;/code&gt; であるのがゼロ以外。</target>
        </trans-unit>
        <trans-unit id="2850e916b8328a8067cb56753c2fae6f207d9a41" translate="yes" xml:space="preserve">
          <source>The following table lists Unicode characters that can be entered via tab completion of LaTeX-like abbreviations in the Julia REPL (and in various other editing environments). You can also get information on how to type a symbol by entering it in the REPL help, i.e. by typing &lt;code&gt;?&lt;/code&gt; and then entering the symbol in the REPL (e.g., by copy-paste from somewhere you saw the symbol).</source>
          <target state="translated">次の表は、Julia REPL（およびその他のさまざまな編集環境）でLaTeXのような略語のタブ補完を介して入力できるUnicode文字の一覧です。また、REPLヘルプに記号を入力する、つまり &lt;code&gt;?&lt;/code&gt; と入力することで、記号の入力方法に関する情報を取得できます。次に、REPLにシンボルを入力します（たとえば、シンボルが表示されていた場所からコピーして貼り付けます）。</target>
        </trans-unit>
        <trans-unit id="84caf0f2b4e520eb1362c7d90034a53ce384352e" translate="yes" xml:space="preserve">
          <source>The following table summarizes the types of matrix factorizations that have been implemented in Julia. Details of their associated methods can be found in the &lt;a href=&quot;#Standard-Functions-1&quot;&gt;Standard Functions&lt;/a&gt; section of the Linear Algebra documentation.</source>
          <target state="translated">次の表は、ジュリアで実装された行列分解のタイプをまとめたものです。関連するメソッドの詳細は、線形代数ドキュメンテーションの「&lt;a href=&quot;#Standard-Functions-1&quot;&gt;標準関数」&lt;/a&gt;セクションにあります。</target>
        </trans-unit>
        <trans-unit id="a5e3ae439be1705d14dc31df2b803cc4528033bf" translate="yes" xml:space="preserve">
          <source>The following tables summarize the types of special matrices that have been implemented in Julia, as well as whether hooks to various optimized methods for them in LAPACK are available.</source>
          <target state="translated">以下の表は、Juliaで実装されている特殊行列の種類と、そのためにLAPACKで最適化された様々なメソッドへのフックが利用できるかどうかをまとめたものです。</target>
        </trans-unit>
        <trans-unit id="58787cfe45db809926391f964f8c2fe50eb9c66e" translate="yes" xml:space="preserve">
          <source>The following two-word sequences are reserved: &lt;code&gt;abstract type&lt;/code&gt;, &lt;code&gt;mutable struct&lt;/code&gt;, &lt;code&gt;primitive type&lt;/code&gt;. However, you can create variables with names: &lt;code&gt;abstract&lt;/code&gt;, &lt;code&gt;mutable&lt;/code&gt;, &lt;code&gt;primitive&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">次の2ワードのシーケンスは予約されています： &lt;code&gt;abstract type&lt;/code&gt; 、 &lt;code&gt;mutable struct&lt;/code&gt; 、 &lt;code&gt;primitive type&lt;/code&gt; 。ただし、次の名前の変数を作成できます： &lt;code&gt;abstract&lt;/code&gt; 、 &lt;code&gt;mutable&lt;/code&gt; 、 &lt;code&gt;primitive&lt;/code&gt; 、および &lt;code&gt;type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c16965f50c24120006902ac240b6d5249b8840ca" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.answer_color()&lt;/code&gt; (default: normal, &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt;) that output should have at the terminal.</source>
          <target state="translated">端末での出力のフォーマット &lt;code&gt;Base.answer_color()&lt;/code&gt; （デフォルト：normal、 &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2a94f6ed982371cc454e13d3c41d22bd28f7000c" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.error_color()&lt;/code&gt; (default: light red, &lt;code&gt;&quot;\033[91m&quot;&lt;/code&gt;) that errors should have at the terminal.</source>
          <target state="translated">端末でエラーが発生するはずのフォーマット &lt;code&gt;Base.error_color()&lt;/code&gt; （デフォルト：薄い赤、 &lt;code&gt;&quot;\033[91m&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5bedb24b2b2a4f0d544b13331782037e6b751d7c" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.info_color()&lt;/code&gt; (default: cyan, &lt;code&gt;&quot;\033[36m&quot;&lt;/code&gt;) that info should have at the terminal.</source>
          <target state="translated">端末でinfoが持つべきフォーマット &lt;code&gt;Base.info_color()&lt;/code&gt; （デフォルト：cyan、 &lt;code&gt;&quot;\033[36m&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9abdd1879aac44fbed37a23e8cd8c9521c6a3a7b" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.input_color()&lt;/code&gt; (default: normal, &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt;) that input should have at the terminal.</source>
          <target state="translated">端末での入力のフォーマット &lt;code&gt;Base.input_color()&lt;/code&gt; （デフォルト：normal、 &lt;code&gt;&quot;\033[0m&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5c3246893833440c6ee277a6f4469b2f678db3a7" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.stackframe_function_color()&lt;/code&gt; (default: bold, &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt;) that function calls should have during a stack trace at the terminal.</source>
          <target state="translated">端末でのスタックトレース中に関数呼び出しが持つフォーマット &lt;code&gt;Base.stackframe_function_color()&lt;/code&gt; （デフォルト：太字、 &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="276edac3df59db618aba660c48a61b72521725f5" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.stackframe_lineinfo_color()&lt;/code&gt; (default: bold, &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt;) that line info should have during a stack trace at the terminal.</source>
          <target state="translated">端末でのスタックトレース中にライン情報が持つ必要があるフォーマット &lt;code&gt;Base.stackframe_lineinfo_color()&lt;/code&gt; （デフォルト：太字、 &lt;code&gt;&quot;\033[1m&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5a3d58af274070ed561a7473fe7be9c81a95ede6" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;Base.warn_color()&lt;/code&gt; (default: yellow, &lt;code&gt;&quot;\033[93m&quot;&lt;/code&gt;) that warnings should have at the terminal.</source>
          <target state="translated">端末で警告が必要なフォーマット &lt;code&gt;Base.warn_color()&lt;/code&gt; （デフォルト：yellow、 &lt;code&gt;&quot;\033[93m&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e430bf906d90ec3cbe26e6641c11eeda24fe35ca" translate="yes" xml:space="preserve">
          <source>The former is a single character value of type &lt;code&gt;Char&lt;/code&gt;, while the latter is a string value that happens to contain only a single character. In Julia these are very different things.</source>
          <target state="translated">前者は &lt;code&gt;Char&lt;/code&gt; 型の単一の文字値であり、後者はたまたま単一の文字のみを含む文字列値です。ジュリアでは、これらは非常に異なるものです。</target>
        </trans-unit>
        <trans-unit id="d152dae5600534a9646e1a87a36f09f36dd3ded5" translate="yes" xml:space="preserve">
          <source>The former results in a single network round-trip to every worker, while the latter results in two network calls - first by the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; and the second due to the &lt;code&gt;fetch&lt;/code&gt; (or even a &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;). The &lt;code&gt;fetch&lt;/code&gt;/&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; is also being executed serially resulting in an overall poorer performance.</source>
          <target state="translated">すべての労働者への単一のネットワーク・ラウンドトリップで、前者の結果、2つのネットワーク・コール後者結果つつ-によって最初&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt;とによる第二の &lt;code&gt;fetch&lt;/code&gt; （または&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;）。 &lt;code&gt;fetch&lt;/code&gt; / &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;、全体的な貧弱な性能が得逐次実行されています。</target>
        </trans-unit>
        <trans-unit id="d93e33c90f8c053ee253be6b3d20b4b263f781d7" translate="yes" xml:space="preserve">
          <source>The fully expanded value of &lt;code&gt;LOAD_PATH&lt;/code&gt; that is searched for projects and packages can be seen by calling the &lt;code&gt;Base.load_path()&lt;/code&gt; function.</source>
          <target state="translated">プロジェクトとパッケージを検索する &lt;code&gt;LOAD_PATH&lt;/code&gt; の完全に展開された値は、 &lt;code&gt;Base.load_path()&lt;/code&gt; 関数を呼び出すことで確認できます。</target>
        </trans-unit>
        <trans-unit id="53cd7e3be35b834ce5e0e038f9eb6daebb41c365" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;count_heads&lt;/code&gt; simply adds together &lt;code&gt;n&lt;/code&gt; random bits. Here is how we can perform some trials on two machines, and add together the results:</source>
          <target state="translated">関数 &lt;code&gt;count_heads&lt;/code&gt; は単に &lt;code&gt;n&lt;/code&gt; 個のランダムビットを加算します。2台のマシンでいくつかの試行を実行し、結果を合計する方法を次に示します。</target>
        </trans-unit>
        <trans-unit id="1a7009ac781780ee28678319854f5347c9495c13" translate="yes" xml:space="preserve">
          <source>The function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.</source>
          <target state="translated">関数呼び出しが呼び出しスタックのサイズを超えて大きくなりました。これは通常、呼び出しが無限に再帰する場合に発生します。</target>
        </trans-unit>
        <trans-unit id="da6b2e5a2ff44122d7db169754c14ee6b172e967" translate="yes" xml:space="preserve">
          <source>The function in which &lt;code&gt;@boundscheck&lt;/code&gt; is written must be inlined into its caller in order for &lt;code&gt;@inbounds&lt;/code&gt; to have effect.</source>
          <target state="translated">ここで機能 &lt;code&gt;@boundscheck&lt;/code&gt; が書かれているがために、その呼び出し元にインライン化する必要があります &lt;code&gt;@inbounds&lt;/code&gt; が効果を持っています。</target>
        </trans-unit>
        <trans-unit id="39d7cf55fabb709098be0379cf1a36954e7ad2fc" translate="yes" xml:space="preserve">
          <source>The function parameter &lt;code&gt;f&lt;/code&gt; should have following signature:</source>
          <target state="translated">関数パラメーター &lt;code&gt;f&lt;/code&gt; には、次のシグニチャーが必要です。</target>
        </trans-unit>
        <trans-unit id="c1a0f9cdfffaafbbc345f4ef6dcd681fce922423" translate="yes" xml:space="preserve">
          <source>The function reads the cookie from stdin if required, and listens on a free port (or if specified, the port in the &lt;code&gt;--bind-to&lt;/code&gt; command line option) and schedules tasks to process incoming TCP connections and requests. It also (optionally) closes stdin and redirects stderr to stdout.</source>
          <target state="translated">この関数は、必要に応じてstdinからCookieを読み取り、空きポート（または &lt;code&gt;--bind-to&lt;/code&gt; コマンドラインオプションで指定されている場合はポート）でリッスンし、着信TCP接続と要求を処理するタスクをスケジュールします。また、（オプションで）stdinを閉じ、stderrをstdoutにリダイレクトします。</target>
        </trans-unit>
        <trans-unit id="b716ab0d4ac152e4a4f9c6b1390eb5136f17d5d2" translate="yes" xml:space="preserve">
          <source>The garbage collector does not guarantee any order of finalization. That is, if &lt;code&gt;a&lt;/code&gt; contained a reference to &lt;code&gt;b&lt;/code&gt; and both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are due for garbage collection, there is no guarantee that &lt;code&gt;b&lt;/code&gt; would be finalized after &lt;code&gt;a&lt;/code&gt;. If proper finalization of &lt;code&gt;a&lt;/code&gt; depends on &lt;code&gt;b&lt;/code&gt; being valid, it must be handled in other ways.</source>
          <target state="translated">ガベージコレクターは、ファイナライズの順序を保証しません。場合すなわち、参照に含まれる &lt;code&gt;b&lt;/code&gt; の両方 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; ガベージコレクションの原因である、という保証はありません &lt;code&gt;b&lt;/code&gt; が後に確定されるだろう。適切な確定した場合に依存 &lt;code&gt;b&lt;/code&gt; 有効である、それは他の方法で処理する必要があります。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2c5ffa9d8537b10e07bd1e1cd0016a03d6887376" translate="yes" xml:space="preserve">
          <source>The garbage collector operates under the assumption that it is aware of every old-generation object pointing to a young-generation one. Any time a pointer is updated breaking that assumption, it must be signaled to the collector with the &lt;code&gt;jl_gc_wb&lt;/code&gt; (write barrier) function like so:</source>
          <target state="translated">ガベージコレクターは、若い世代のオブジェクトを指すすべての古い世代のオブジェクトを認識しているという前提の下で動作します。ポインターが更新されてその仮定が破られた場合は &lt;code&gt;jl_gc_wb&lt;/code&gt; 、次のようなjl_gc_wb（書き込みバリア）関数を使用してコレクターに通知する必要があります。</target>
        </trans-unit>
        <trans-unit id="7f907da64c464f65fc72aafc195dfebc2e4f4da6" translate="yes" xml:space="preserve">
          <source>The general syntax for assigning values in an n-dimensional array &lt;code&gt;A&lt;/code&gt; is:</source>
          <target state="translated">n次元配列 &lt;code&gt;A&lt;/code&gt; に値を割り当てる一般的な構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="7f7fec22031b950929a2be2bf28c88a4e32319b3" translate="yes" xml:space="preserve">
          <source>The general syntax for indexing into an n-dimensional array &lt;code&gt;A&lt;/code&gt; is:</source>
          <target state="translated">n次元配列 &lt;code&gt;A&lt;/code&gt; にインデックスを付ける一般的な構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="03b4ccfaa881cd16fd244ada75dc950f11a8dd7c" translate="yes" xml:space="preserve">
          <source>The general syntaxes for declaring a primitive type are:</source>
          <target state="translated">プリミティブ型を宣言するための一般的な構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="3e8b49d87c21864e9239600316a0864509f86bdd" translate="yes" xml:space="preserve">
          <source>The generalized eigenvalues are returned in &lt;code&gt;alpha&lt;/code&gt; and &lt;code&gt;beta&lt;/code&gt;. The left Schur vectors are returned in &lt;code&gt;vsl&lt;/code&gt; and the right Schur vectors are returned in &lt;code&gt;vsr&lt;/code&gt;.</source>
          <target state="translated">一般化された固有値は &lt;code&gt;alpha&lt;/code&gt; および &lt;code&gt;beta&lt;/code&gt; で返されます。左側のSchurベクトルは &lt;code&gt;vsl&lt;/code&gt; で返され、右側のSchurベクトルは &lt;code&gt;vsr&lt;/code&gt; で返されます。</target>
        </trans-unit>
        <trans-unit id="aa0ec4e7835e3ddd782c0a7070e015136b4b04a9" translate="yes" xml:space="preserve">
          <source>The global constant &lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt;&lt;code&gt;im&lt;/code&gt;&lt;/a&gt; is bound to the complex number &lt;em&gt;i&lt;/em&gt;, representing the principal square root of -1. (Using mathematicians' &lt;code&gt;i&lt;/code&gt; or engineers' &lt;code&gt;j&lt;/code&gt; for this global constant were rejected since they are such popular index variable names.) Since Julia allows numeric literals to be &lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;juxtaposed with identifiers as coefficients&lt;/a&gt;, this binding suffices to provide convenient syntax for complex numbers, similar to the traditional mathematical notation:</source>
          <target state="translated">グローバル定数&lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt; &lt;code&gt;im&lt;/code&gt; &lt;/a&gt;は複素数&lt;em&gt;iに&lt;/em&gt;束縛され、-1の主平方根を表します。（このグローバル定数に数学者の &lt;code&gt;i&lt;/code&gt; またはエンジニアの &lt;code&gt;j&lt;/code&gt; を使用することは、これらが一般的なインデックス変数名であるために拒否されました。）Juliaでは、数値リテラルを&lt;a href=&quot;../integers-and-floating-point-numbers/index#man-numeric-literal-coefficients-1&quot;&gt;識別子として係数として並置&lt;/a&gt;できるため、このバインディングは、同様に複素数に便利な構文を提供するのに十分です伝統的な数学的表記に：</target>
        </trans-unit>
        <trans-unit id="ef1d21913b7da2cd50221a9ea53be6e2ac79e4fa" translate="yes" xml:space="preserve">
          <source>The global logger may be set with &lt;a href=&quot;#Base.CoreLogging.global_logger&quot;&gt;&lt;code&gt;global_logger&lt;/code&gt;&lt;/a&gt;, and task-local loggers controlled using &lt;a href=&quot;#Base.CoreLogging.with_logger&quot;&gt;&lt;code&gt;with_logger&lt;/code&gt;&lt;/a&gt;. Newly spawned tasks inherit the logger of the parent task.</source>
          <target state="translated">グローバルロガーは&lt;a href=&quot;#Base.CoreLogging.global_logger&quot;&gt; &lt;code&gt;global_logger&lt;/code&gt; &lt;/a&gt;で設定でき、タスクローカルロガーは&lt;a href=&quot;#Base.CoreLogging.with_logger&quot;&gt; &lt;code&gt;with_logger&lt;/code&gt; &lt;/a&gt;を使用して制御できます。新しく生成されたタスクは、親タスクのロガーを継承します。</target>
        </trans-unit>
        <trans-unit id="65f673e90f9a09b859b5b51800816fab3de4b761" translate="yes" xml:space="preserve">
          <source>The global variable &lt;code&gt;Base.DATAROOTDIR&lt;/code&gt; determines a relative path from &lt;code&gt;Sys.BINDIR&lt;/code&gt; to the data directory associated with Julia. Then the path</source>
          <target state="translated">グローバル変数 &lt;code&gt;Base.DATAROOTDIR&lt;/code&gt; は、 &lt;code&gt;Sys.BINDIR&lt;/code&gt; からJuliaに関連付けられたデータディレクトリへの相対パスを決定します。次にパス</target>
        </trans-unit>
        <trans-unit id="e3bc80be4d521baacc06dd9873b328760a93de88" translate="yes" xml:space="preserve">
          <source>The golden ratio.</source>
          <target state="translated">黄金比です。</target>
        </trans-unit>
        <trans-unit id="354c17f25309f78f252b602097180cb50161163d" translate="yes" xml:space="preserve">
          <source>The group id of the file owner</source>
          <target state="translated">ファイルの所有者のグループID</target>
        </trans-unit>
        <trans-unit id="9e739954ff8de8447d1ab16a3adde7a80c985194" translate="yes" xml:space="preserve">
          <source>The hexadecimal integer literal expression &lt;code&gt;0xff&lt;/code&gt; could be interpreted as the numeric literal &lt;code&gt;0&lt;/code&gt; multiplied by the variable &lt;code&gt;xff&lt;/code&gt;.</source>
          <target state="translated">16進整数リテラル式 &lt;code&gt;0xff&lt;/code&gt; は、数値リテラル &lt;code&gt;0&lt;/code&gt; に変数 &lt;code&gt;xff&lt;/code&gt; を掛けたものとして解釈できます。</target>
        </trans-unit>
        <trans-unit id="49109aa658d7c92b2a2e148756ac4fc9b1efb6c1" translate="yes" xml:space="preserve">
          <source>The highest finite value representable by the given floating-point DataType &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">指定された浮動小数点DataType &lt;code&gt;T&lt;/code&gt; で表現できる最大の有限値。</target>
        </trans-unit>
        <trans-unit id="1c54bd6057f9e745e71a4f119d94151d139d45e8" translate="yes" xml:space="preserve">
          <source>The highest value representable by the given (real) numeric &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">指定された（実際の）数値 &lt;code&gt;DataType&lt;/code&gt; で表現できる最大値。</target>
        </trans-unit>
        <trans-unit id="3d03859ad784bc750f8658c68023988ea70e276c" translate="yes" xml:space="preserve">
          <source>The host machine must have the requisite SIMD registers. For example, the code above will not work on hosts without AVX support.</source>
          <target state="translated">ホストマシンは必要な SIMD レジスタを持っていなければなりません。例えば、上記のコードは AVX サポートのないホストでは動作しません。</target>
        </trans-unit>
        <trans-unit id="69486992100b48c68c6ad0bb1508ce13148c9067" translate="yes" xml:space="preserve">
          <source>The hour of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">時間 &lt;code&gt;Time&lt;/code&gt; として&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0ae14cb6dca4ab146e83e6f66251f24254e3bb17" translate="yes" xml:space="preserve">
          <source>The hour of day of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;としての &lt;code&gt;DateTime&lt;/code&gt; の時刻。</target>
        </trans-unit>
        <trans-unit id="7b1bfeaaafc9c1b963fac8395380b6b23cf36c72" translate="yes" xml:space="preserve">
          <source>The hour part of a DateTime as a &lt;code&gt;Hour&lt;/code&gt;.</source>
          <target state="translated">DateTimeの時間の一部 &lt;code&gt;Hour&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3215c43ad10d3da4db391c4e4892aec7413196da" translate="yes" xml:space="preserve">
          <source>The identity function. Returns its argument.</source>
          <target state="translated">ID関数です。その引数を返します。</target>
        </trans-unit>
        <trans-unit id="c738dd3a82cae47bce1402d7e9ed9b1a08ec88db" translate="yes" xml:space="preserve">
          <source>The imaginary unit &lt;code&gt;sqrt(-1)&lt;/code&gt; is represented in Julia as &lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt;&lt;code&gt;im&lt;/code&gt;&lt;/a&gt;, not &lt;code&gt;i&lt;/code&gt; or &lt;code&gt;j&lt;/code&gt; as in MATLAB.</source>
          <target state="translated">虚数単位 &lt;code&gt;sqrt(-1)&lt;/code&gt; は、Julia ではMATLABのように &lt;code&gt;i&lt;/code&gt; または &lt;code&gt;j&lt;/code&gt; ではなく、&lt;a href=&quot;../../base/numbers/index#Base.im&quot;&gt; &lt;code&gt;im&lt;/code&gt; &lt;/a&gt;として表されます。</target>
        </trans-unit>
        <trans-unit id="7823efd88570f05c6cdcdeba7b9c6d877d28d4c3" translate="yes" xml:space="preserve">
          <source>The imaginary unit.</source>
          <target state="translated">虚数の単位。</target>
        </trans-unit>
        <trans-unit id="d2f3b37cc4a76dd392140d18be234dc4fa787173" translate="yes" xml:space="preserve">
          <source>The implementation of this behavior is a &quot;world age counter&quot;. This monotonically increasing value tracks each method definition operation. This allows describing &quot;the set of method definitions visible to a given runtime environment&quot; as a single number, or &quot;world age&quot;. It also allows comparing the methods available in two worlds just by comparing their ordinal value. In the example above, we see that the &quot;current world&quot; (in which the method &lt;code&gt;newfun&lt;/code&gt; exists), is one greater than the task-local &quot;runtime world&quot; that was fixed when the execution of &lt;code&gt;tryeval&lt;/code&gt; started.</source>
          <target state="translated">この動作の実装は、「世界の年齢カウンター」です。この単調に増加する値は、各メソッド定義操作を追跡します。これにより、「特定のランタイム環境から見える一連のメソッド定義」を単一の数値、つまり「世界の年齢」として説明できます。また、序数値を比較するだけで、2つの世界で使用可能なメソッドを比較することもできます。上記の例では、「 &lt;code&gt;newfun&lt;/code&gt; メソッドが存在する」「現在の世界」が、 &lt;code&gt;tryeval&lt;/code&gt; の実行開始時に修正されたタスクローカルの「ランタイム世界」よりも1つ大きいことがわかります。</target>
        </trans-unit>
        <trans-unit id="b253e7f28529381ae2517e2dd4df05c0e78e871f" translate="yes" xml:space="preserve">
          <source>The incremental precompiled module file are created and used automatically when using &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;using&lt;/code&gt; to load a module. This will cause it to be automatically compiled the first time it is imported. Alternatively, you can manually call &lt;a href=&quot;../../base/base/index#Base.compilecache&quot;&gt;&lt;code&gt;Base.compilecache(modulename)&lt;/code&gt;&lt;/a&gt;. The resulting cache files will be stored in &lt;code&gt;DEPOT_PATH[1]/compiled/&lt;/code&gt;. Subsequently, the module is automatically recompiled upon &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; whenever any of its dependencies change; dependencies are modules it imports, the Julia build, files it includes, or explicit dependencies declared by &lt;a href=&quot;../../base/base/index#Base.include_dependency&quot;&gt;&lt;code&gt;include_dependency(path)&lt;/code&gt;&lt;/a&gt; in the module file(s).</source>
          <target state="translated">インクリメンタルプリコンパイルモジュールファイルは、 &lt;code&gt;import&lt;/code&gt; またはモジュールのロードに &lt;code&gt;using&lt;/code&gt; すると、自動的に作成および使用されます。これにより、最初にインポートされたときに自動的にコンパイルされます。または、手動で&lt;a href=&quot;../../base/base/index#Base.compilecache&quot;&gt; &lt;code&gt;Base.compilecache(modulename)&lt;/code&gt; を&lt;/a&gt;呼び出すこともできます。結果のキャッシュファイルは &lt;code&gt;DEPOT_PATH[1]/compiled/&lt;/code&gt; 保存されます。その後、モジュールは、依存関係が変更されるたびに、 &lt;code&gt;using&lt;/code&gt; または &lt;code&gt;import&lt;/code&gt; 時に自動的に再コンパイルされます。依存関係は、インポートするモジュール、Juliaビルド、それに含まれるファイル、またはモジュールファイルの&lt;a href=&quot;../../base/base/index#Base.include_dependency&quot;&gt; &lt;code&gt;include_dependency(path)&lt;/code&gt; &lt;/a&gt;によって宣言された明示的な依存関係です。</target>
        </trans-unit>
        <trans-unit id="13dd8189d32c7c1290b037751919f6e30e7f64f8" translate="yes" xml:space="preserve">
          <source>The individual components of the decomposition &lt;code&gt;F&lt;/code&gt; can be retrieved via property accessors:</source>
          <target state="translated">分解 &lt;code&gt;F&lt;/code&gt; の個々のコンポーネントは、プロパティアクセサーを介して取得できます。</target>
        </trans-unit>
        <trans-unit id="ce0913135fd9f357f77350a326cce1c8ed6fa49d" translate="yes" xml:space="preserve">
          <source>The individual components of the factorization &lt;code&gt;F&lt;/code&gt; can be accessed via &lt;code&gt;getproperty&lt;/code&gt;:</source>
          <target state="translated">因数分解 &lt;code&gt;F&lt;/code&gt; の個々のコンポーネントには、 &lt;code&gt;getproperty&lt;/code&gt; を介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="c6e01ca13a398bafdf18f4d4f60195a783a431cf" translate="yes" xml:space="preserve">
          <source>The infix form is exactly equivalent to the function application form &amp;ndash; in fact the former is parsed to produce the function call internally. This also means that you can assign and pass around operators such as &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;*&lt;/code&gt; just like you would with other function values:</source>
          <target state="translated">中置形式は、関数適用形式とまったく同じです。実際、前者は、内部的に関数呼び出しを生成するために解析されます。これは、他の関数値の場合と同じように、&lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt;や &lt;code&gt;*&lt;/code&gt; などの演算子を割り当てて渡すことができることも意味します。</target>
        </trans-unit>
        <trans-unit id="ab93d805a4e1efd3cacbdba9a517e0dc2379a9e4" translate="yes" xml:space="preserve">
          <source>The infix operation &lt;code&gt;a ⊻ b&lt;/code&gt; is a synonym for &lt;code&gt;xor(a,b)&lt;/code&gt;, and &lt;code&gt;⊻&lt;/code&gt; can be typed by tab-completing &lt;code&gt;\xor&lt;/code&gt; or &lt;code&gt;\veebar&lt;/code&gt; in the Julia REPL.</source>
          <target state="translated">中置演算 &lt;code&gt;a ⊻ b&lt;/code&gt; は &lt;code&gt;xor(a,b)&lt;/code&gt; 同義語であり、 &lt;code&gt;⊻&lt;/code&gt; はJulia REPLのタブ補完 &lt;code&gt;\xor&lt;/code&gt; または &lt;code&gt;\veebar&lt;/code&gt; で入力できます。</target>
        </trans-unit>
        <trans-unit id="e1b31695e555eb78c96b1ce43ed5d4b769be43f4" translate="yes" xml:space="preserve">
          <source>The initial Julia process, also called the &lt;code&gt;master&lt;/code&gt;, is special and has an &lt;code&gt;id&lt;/code&gt; of 1.</source>
          <target state="translated">最初のJuliaプロセスは &lt;code&gt;master&lt;/code&gt; とも呼ばれ、特別で、 &lt;code&gt;id&lt;/code&gt; は1です。</target>
        </trans-unit>
        <trans-unit id="46aabc78dd4e507670425bdb3bf204611d3ffb13" translate="yes" xml:space="preserve">
          <source>The inode number of the file</source>
          <target state="translated">ファイルのinode番号</target>
        </trans-unit>
        <trans-unit id="204c42952f2670f515bfe08f06a0ba3dd55c909a" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;n&lt;/code&gt; is passed by value, and so the function's input signature is simply declared as &lt;code&gt;(Csize_t,)&lt;/code&gt; without any &lt;code&gt;Ref&lt;/code&gt; or &lt;code&gt;Ptr&lt;/code&gt; necessary. (If the wrapper was calling a Fortran function instead, the corresponding function input signature should instead be &lt;code&gt;(Ref{Csize_t},)&lt;/code&gt;, since Fortran variables are passed by pointers.) Furthermore, &lt;code&gt;n&lt;/code&gt; can be any type that is convertible to a &lt;code&gt;Csize_t&lt;/code&gt; integer; the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; implicitly calls &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert(Csize_t, n)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">入力 &lt;code&gt;n&lt;/code&gt; は値によって渡されるため、関数の入力シグネチャは、 &lt;code&gt;(Csize_t,)&lt;/code&gt; として宣言され、 &lt;code&gt;Ref&lt;/code&gt; または &lt;code&gt;Ptr&lt;/code&gt; は必要ありません。（ラッパーがFortran関数を代わりに呼び出していた場合、Fortran変数はポインターによって渡されるため、対応する関数入力シグネチャーは &lt;code&gt;(Ref{Csize_t},)&lt;/code&gt; である必要があります。）さらに、 &lt;code&gt;n&lt;/code&gt; は &lt;code&gt;Csize_t&lt;/code&gt; 整数に変換可能な任意の型にすることができます。; &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; は、&lt;/a&gt;暗黙的に呼び出します&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert(Csize_t, n)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b8b235e73123abb02c8610a64480c17659bc5e36" translate="yes" xml:space="preserve">
          <source>The input matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; will not contain their eigenvalues after &lt;code&gt;eigvals!&lt;/code&gt; is called. They are used as workspaces.</source>
          <target state="translated">入力行列 &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; には、 &lt;code&gt;eigvals!&lt;/code&gt; 後の固有値は含まれません。と呼ばれます。ワークスペースとして使用されます。</target>
        </trans-unit>
        <trans-unit id="a25e9d14fa9f0f89dab37c152c425a3aebebbd0f" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;A&lt;/code&gt; will not contain its eigenvalues after &lt;code&gt;eigvals!&lt;/code&gt; is called on it - &lt;code&gt;A&lt;/code&gt; is used as a workspace.</source>
          <target state="translated">入力行列 &lt;code&gt;A&lt;/code&gt; には、 &lt;code&gt;eigvals!&lt;/code&gt; 後の固有値は含まれません。が呼び出されます &lt;code&gt;A&lt;/code&gt; がワークスペースとして使用されます。</target>
        </trans-unit>
        <trans-unit id="1417019c8a8204f046e43b52db1e1b8dfe779fc9" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;X&lt;/code&gt; is not transposed or conjugated.</source>
          <target state="translated">入力行列 &lt;code&gt;X&lt;/code&gt; は転置も共役もされていません。</target>
        </trans-unit>
        <trans-unit id="696317e85c44155ed1679065a21cab9ea0d94c6f" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;X&lt;/code&gt; will be conjugated and transposed.</source>
          <target state="translated">入力行列 &lt;code&gt;X&lt;/code&gt; は共役され、転置されます。</target>
        </trans-unit>
        <trans-unit id="edc49f341fce73dbc1b810339993fe819e7483f6" translate="yes" xml:space="preserve">
          <source>The input matrix &lt;code&gt;X&lt;/code&gt; will be transposed.</source>
          <target state="translated">入力行列 &lt;code&gt;X&lt;/code&gt; が転置されます。</target>
        </trans-unit>
        <trans-unit id="ce8cf57c3583cc5f6f01c812980b6d9e8e041658" translate="yes" xml:space="preserve">
          <source>The intuition behind this behavior is that &lt;code&gt;x&lt;/code&gt; is evaluated once for each &lt;code&gt;$&lt;/code&gt;: one &lt;code&gt;$&lt;/code&gt; works similarly to &lt;code&gt;eval(:x)&lt;/code&gt;, giving &lt;code&gt;x&lt;/code&gt;'s value, while two &lt;code&gt;$&lt;/code&gt;s do the equivalent of &lt;code&gt;eval(eval(:x))&lt;/code&gt;.</source>
          <target state="translated">この動作の直感は、 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;$&lt;/code&gt; ごとに1回評価されることです。1つの &lt;code&gt;$&lt;/code&gt; は &lt;code&gt;eval(:x)&lt;/code&gt; と同様に機能し、 &lt;code&gt;x&lt;/code&gt; の値を与えますが、2つの &lt;code&gt;$&lt;/code&gt; sは &lt;code&gt;eval(eval(:x))&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="9951fb03011eb6ccac99ddca5a1c8a2596a1921f" translate="yes" xml:space="preserve">
          <source>The inverse of the &lt;a href=&quot;#SparseArrays.sparse&quot;&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt;&lt;code&gt;sparsevec&lt;/code&gt;&lt;/a&gt; functions is &lt;a href=&quot;#SparseArrays.findnz&quot;&gt;&lt;code&gt;findnz&lt;/code&gt;&lt;/a&gt;, which retrieves the inputs used to create the sparse array. &lt;code&gt;findall(!iszero, x)&lt;/code&gt; returns the cartesian indices of non-zero entries in &lt;code&gt;x&lt;/code&gt; (including stored entries equal to zero).</source>
          <target state="translated">&lt;a href=&quot;#SparseArrays.sparse&quot;&gt; &lt;code&gt;sparse&lt;/code&gt; &lt;/a&gt;関数と&lt;a href=&quot;#SparseArrays.sparsevec&quot;&gt; &lt;code&gt;sparsevec&lt;/code&gt; &lt;/a&gt;関数の逆は&lt;a href=&quot;#SparseArrays.findnz&quot;&gt; &lt;code&gt;findnz&lt;/code&gt; です&lt;/a&gt;。これは、スパース配列の作成に使用される入力を取得します。 &lt;code&gt;findall(!iszero, x)&lt;/code&gt; 非ゼロエントリのデカルトインデックス戻り &lt;code&gt;x&lt;/code&gt; （記憶されたエントリを含むがゼロに等しいです）。</target>
        </trans-unit>
        <trans-unit id="08e030af941b44ba6a6057a4b8409ccf9a09fa65" translate="yes" xml:space="preserve">
          <source>The item or field is not defined for the given object.</source>
          <target state="translated">与えられたオブジェクトに対して項目またはフィールドが定義されていません。</target>
        </trans-unit>
        <trans-unit id="5978b1760bac737678645da104214e401ee6745d" translate="yes" xml:space="preserve">
          <source>The iteration space is split amongst the threads, after which each thread writes its thread ID to its assigned locations:</source>
          <target state="translated">反復空間はスレッド間で分割され、各スレッドは割り当てられた場所にスレッドIDを書き込みます。</target>
        </trans-unit>
        <trans-unit id="27814682e2f12bb813126e15aaa61e9b9ecadb0b" translate="yes" xml:space="preserve">
          <source>The keyword argument &lt;code&gt;topology&lt;/code&gt; passed to &lt;code&gt;addprocs&lt;/code&gt; is used to specify how the workers must be connected to each other:</source>
          <target state="translated">&lt;code&gt;addprocs&lt;/code&gt; に渡されるキーワード引数 &lt;code&gt;topology&lt;/code&gt; は、ワーカーを相互に接続する方法を指定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="071e1626e259689d138d5d354cd990a797f9cc76" translate="yes" xml:space="preserve">
          <source>The keyword argument is:</source>
          <target state="translated">キーワードの引数は</target>
        </trans-unit>
        <trans-unit id="b53040371261a8a003dc97b8ee4567faef82b0f5" translate="yes" xml:space="preserve">
          <source>The keyword arguments are:</source>
          <target state="translated">キーワードの引数は</target>
        </trans-unit>
        <trans-unit id="aff2628de569031caf118a1cfbb476e502ae8a02" translate="yes" xml:space="preserve">
          <source>The keyword arguments can be any combination of:</source>
          <target state="translated">キーワード引数には、以下の任意の組み合わせを指定することができます。</target>
        </trans-unit>
        <trans-unit id="88a5016b4ada3cfa1d337884f9c60b1547e662dc" translate="yes" xml:space="preserve">
          <source>The keyword arguments determine which of read and/or write status should be monitored; at least one of them must be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">キーワード引数は、読み取りまたは書き込み、あるいはその両方のステータスを監視する必要があるかどうかを決定します。少なくとも1つは &lt;code&gt;true&lt;/code&gt; に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="8c36d11485ade8e4d84f52006bfe2371bd7a3a31" translate="yes" xml:space="preserve">
          <source>The keyword debuginfo controls the amount of code metadata present in the output.</source>
          <target state="translated">キーワード debuginfo は、出力に存在するコード・メタデータの量を制御します。</target>
        </trans-unit>
        <trans-unit id="1c08fd56fd5a7ec1b4c4d5ce6e7cd9fc470d3bc9" translate="yes" xml:space="preserve">
          <source>The largest &lt;code&gt;a^n&lt;/code&gt; not greater than &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is a non-negative integer. &lt;code&gt;a&lt;/code&gt; must be greater than 1, and &lt;code&gt;x&lt;/code&gt; must not be less than 1.</source>
          <target state="translated">最大 &lt;code&gt;a^n&lt;/code&gt; よりも大きくない &lt;code&gt;x&lt;/code&gt; ここで、 &lt;code&gt;n&lt;/code&gt; 負でない整数です。 &lt;code&gt;a&lt;/code&gt; は1より大きくなければならず、 &lt;code&gt;x&lt;/code&gt; は1以上でなければなりません。</target>
        </trans-unit>
        <trans-unit id="1950191e788c00e6e81f70c06794860257be97cd" translate="yes" xml:space="preserve">
          <source>The largest consecutive integer representable in the given floating-point type &lt;code&gt;T&lt;/code&gt; that also does not exceed the maximum integer representable by the integer type &lt;code&gt;S&lt;/code&gt;. Equivalently, it is the minimum of &lt;code&gt;maxintfloat(T)&lt;/code&gt; and &lt;a href=&quot;#Base.typemax&quot;&gt;&lt;code&gt;typemax(S)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指定された浮動小数点型 &lt;code&gt;T&lt;/code&gt; で表現可能な連続する最大の整数で、整数型 &lt;code&gt;S&lt;/code&gt; で表現できる最大の整数も超えません。同様に、それは &lt;code&gt;maxintfloat(T)&lt;/code&gt; と&lt;a href=&quot;#Base.typemax&quot;&gt; &lt;code&gt;typemax(S)&lt;/code&gt; &lt;/a&gt;の最小値です。</target>
        </trans-unit>
        <trans-unit id="ecdd0c5829d6c2ebd17e2173ff4d8725a651c73f" translate="yes" xml:space="preserve">
          <source>The largest consecutive integer-valued floating-point number that is exactly represented in the given floating-point type &lt;code&gt;T&lt;/code&gt; (which defaults to &lt;code&gt;Float64&lt;/code&gt;).</source>
          <target state="translated">指定された浮動小数点型 &lt;code&gt;T&lt;/code&gt; （デフォルトは &lt;code&gt;Float64&lt;/code&gt; ）で正確に表される最大の連続する整数値の浮動小数点数。</target>
        </trans-unit>
        <trans-unit id="45d85758b569bacb3008f9cd5ec57f8b5348a342" translate="yes" xml:space="preserve">
          <source>The last argument is a boolean indicating whether Julia should take ownership of the data. If this argument is non-zero, the GC will call &lt;code&gt;free&lt;/code&gt; on the data pointer when the array is no longer referenced.</source>
          <target state="translated">最後の引数は、ジュリアがデータの所有権を取得するかどうかを示すブール値です。この引数がゼロ以外の場合、GCは、配列が参照されなくなったときにデータポインターに対して &lt;code&gt;free&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="1c54e90c8086ffbb492a0993d80791c5e4dea811" translate="yes" xml:space="preserve">
          <source>The last argument is the expression during which the object(s) will be preserved. The previous arguments are the objects to preserve.</source>
          <target state="translated">最後の引数は、オブジェクトが保存される間の式です。前の引数は保存するオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="ea0fbbe9568bcd71edf3e46185498b21db11849e" translate="yes" xml:space="preserve">
          <source>The last definition of &lt;code&gt;addone&lt;/code&gt; handles any type supporting &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; (which returns 1 in the same type as &lt;code&gt;x&lt;/code&gt;, which avoids unwanted type promotion) and the &lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt; function with those arguments. The key thing to realize is that there is &lt;em&gt;no performance penalty&lt;/em&gt; to defining &lt;em&gt;only&lt;/em&gt; the general &lt;code&gt;addone(x) = x + oneunit(x)&lt;/code&gt;, because Julia will automatically compile specialized versions as needed. For example, the first time you call &lt;code&gt;addone(12)&lt;/code&gt;, Julia will automatically compile a specialized &lt;code&gt;addone&lt;/code&gt; function for &lt;code&gt;x::Int&lt;/code&gt; arguments, with the call to &lt;code&gt;oneunit&lt;/code&gt; replaced by its inlined value &lt;code&gt;1&lt;/code&gt;. Therefore, the first three definitions of &lt;code&gt;addone&lt;/code&gt; above are completely redundant with the fourth definition.</source>
          <target state="translated">最後の定義 &lt;code&gt;addone&lt;/code&gt; のハンドル支持任意のタイプ&lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt;（同じタイプに1を返し &lt;code&gt;x&lt;/code&gt; 、不要なタイプの促進避け、）&lt;a href=&quot;../../base/math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; の&lt;/a&gt;それらの引数を持つ関数。Juliaは必要に応じて特殊なバージョンを自動的にコンパイルするため、一般的な &lt;code&gt;addone(x) = x + oneunit(x)&lt;/code&gt; &lt;em&gt;のみ&lt;/em&gt;を定義して&lt;em&gt;もパフォーマンスが低下しない&lt;/em&gt;ことを理解することが重要です。たとえば、初めて &lt;code&gt;addone(12)&lt;/code&gt; を呼び出すと、Juliaは &lt;code&gt;oneunit&lt;/code&gt; を呼び出して、 &lt;code&gt;x::Int&lt;/code&gt; 引数用の特殊な &lt;code&gt;addone&lt;/code&gt; 関数を自動的にコンパイルします。&lt;em&gt;&lt;/em&gt;インライン化された値 &lt;code&gt;1&lt;/code&gt; に置き換えられます。したがって、上記の &lt;code&gt;addone&lt;/code&gt; の最初の3つの定義は、4番目の定義と完全に重複しています。</target>
        </trans-unit>
        <trans-unit id="ce1654d58ffca436a4c577b1711a64e839d84f92" translate="yes" xml:space="preserve">
          <source>The last example shows that &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt;&lt;code&gt;occursin&lt;/code&gt;&lt;/a&gt; can also look for a character literal.</source>
          <target state="translated">最後の例は、&lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt; &lt;code&gt;occursin&lt;/code&gt; &lt;/a&gt;が文字リテラルも検索できることを示しています。</target>
        </trans-unit>
        <trans-unit id="c71585d1662e0c9426691e517fa7355c40e4926e" translate="yes" xml:space="preserve">
          <source>The last index, used in &lt;code&gt;X[end]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;X[end]&lt;/code&gt; で使用される最後のインデックス</target>
        </trans-unit>
        <trans-unit id="85a1c4b01d2974399d332fe3cfffd4d1b569afd3" translate="yes" xml:space="preserve">
          <source>The last parameter of a tuple type &lt;a href=&quot;#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; can be the special type &lt;code&gt;Vararg&lt;/code&gt;, which denotes any number of trailing elements. The type &lt;code&gt;Vararg{T,N}&lt;/code&gt; corresponds to exactly &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;Vararg{T}&lt;/code&gt; corresponds to zero or more elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;Vararg&lt;/code&gt; tuple types are used to represent the arguments accepted by varargs methods (see the section on &lt;a href=&quot;../../manual/functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt; in the manual.)</source>
          <target state="translated">タプルタイプの最後のパラメータ&lt;a href=&quot;#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt;特殊なタイプとすることができる &lt;code&gt;Vararg&lt;/code&gt; 後続要素の任意の数を表します。タイプ &lt;code&gt;Vararg{T,N}&lt;/code&gt; は、タイプ &lt;code&gt;T&lt;/code&gt; の &lt;code&gt;N&lt;/code&gt; 個の要素に対応します。 &lt;code&gt;Vararg{T}&lt;/code&gt; は、タイプ &lt;code&gt;T&lt;/code&gt; の 0個以上の要素に対応します。 &lt;code&gt;Vararg&lt;/code&gt; タプル型は、varargsメソッドが受け入れる引数を表すために使用されます（マニュアルの&lt;a href=&quot;../../manual/functions/index#Varargs-Functions-1&quot;&gt;Varargs関数&lt;/a&gt;のセクションを参照してください）。</target>
        </trans-unit>
        <trans-unit id="acef1648e92638f5fc5abaed16365a6d53367ba2" translate="yes" xml:space="preserve">
          <source>The last parameter of a tuple type can be the special type &lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt;&lt;code&gt;Vararg&lt;/code&gt;&lt;/a&gt;, which denotes any number of trailing elements:</source>
          <target state="translated">タプル型の最後のパラメーターは、任意の数の末尾要素を示す特別な型&lt;a href=&quot;../../base/base/index#Core.Vararg&quot;&gt; &lt;code&gt;Vararg&lt;/code&gt; &lt;/a&gt;にすることができます。</target>
        </trans-unit>
        <trans-unit id="1d6eefa466648c5ff477244c5653b68c2b829837" translate="yes" xml:space="preserve">
          <source>The last point is potentially surprising and thus worth noting:</source>
          <target state="translated">最後のポイントは、潜在的に驚くべきことであり、それゆえに注目すべき点である。</target>
        </trans-unit>
        <trans-unit id="e7ffcc1d6667c70bd8fd7c442814f44c7c9628ab" translate="yes" xml:space="preserve">
          <source>The last rule applies for immutable objects even if the variable binding would change, e.g.:</source>
          <target state="translated">最後のルールは、変数のバインディングが変更されても不変オブジェクトに適用されます。</target>
        </trans-unit>
        <trans-unit id="ac541895cad74a09061e0e8e7752d4412b01c909" translate="yes" xml:space="preserve">
          <source>The launching, management and networking of Julia processes into a logical cluster is done via cluster managers. A &lt;code&gt;ClusterManager&lt;/code&gt; is responsible for</source>
          <target state="translated">Juliaプロセスの起動、管理、および論理クラスターへのネットワーキングは、クラスターマネージャーを介して行われます。A &lt;code&gt;ClusterManager&lt;/code&gt; のは責任があります</target>
        </trans-unit>
        <trans-unit id="88412ce5eb2e0660d566bcac5d3d266756d5e5a6" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;s&lt;/code&gt; must be even, and the returned array has half of the length of &lt;code&gt;s&lt;/code&gt;. See also &lt;a href=&quot;#Base.hex2bytes!&quot;&gt;&lt;code&gt;hex2bytes!&lt;/code&gt;&lt;/a&gt; for an in-place version, and &lt;a href=&quot;#Base.bytes2hex&quot;&gt;&lt;code&gt;bytes2hex&lt;/code&gt;&lt;/a&gt; for the inverse.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; の長さは偶数でなければならず、返される配列の長さは &lt;code&gt;s&lt;/code&gt; の長さの半分です。&lt;a href=&quot;#Base.hex2bytes!&quot;&gt; &lt;code&gt;hex2bytes!&lt;/code&gt; &lt;/a&gt;も参照してください。インプレースバージョンの場合、およびその逆の場合は&lt;a href=&quot;#Base.bytes2hex&quot;&gt; &lt;code&gt;bytes2hex&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="82277dc04b6a3c445e6b9754a249fdcb23f3c7cf" translate="yes" xml:space="preserve">
          <source>The line number in the file containing the execution context.</source>
          <target state="translated">実行コンテキストを含むファイルの行番号。</target>
        </trans-unit>
        <trans-unit id="8e34d0276593663d51db2e1008617c96b00222ff" translate="yes" xml:space="preserve">
          <source>The location &lt;code&gt;i_1, i_2, i_3, ..., i_{n+1}&lt;/code&gt; contains the value at &lt;code&gt;A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]&lt;/code&gt;. All dimensions indexed with scalars are dropped. For example, if &lt;code&gt;J&lt;/code&gt; is an array of indices, then the result of &lt;code&gt;A[2, J, 3]&lt;/code&gt; is an array with size &lt;code&gt;size(J)&lt;/code&gt;. Its &lt;code&gt;j&lt;/code&gt;th element is populated by &lt;code&gt;A[2, J[j], 3]&lt;/code&gt;.</source>
          <target state="translated">ロケーション &lt;code&gt;i_1, i_2, i_3, ..., i_{n+1}&lt;/code&gt; は、 &lt;code&gt;A[I_1[i_1, i_2], I_2[i_3], ..., I_n[i_{n+1}]]&lt;/code&gt; の値が含まれています。スカラーで索引付けされたすべての次元が削除されます。たとえば、 &lt;code&gt;J&lt;/code&gt; がインデックスの配列である場合、 &lt;code&gt;A[2, J, 3]&lt;/code&gt; の結果はサイズ &lt;code&gt;size(J)&lt;/code&gt; の配列になります。その &lt;code&gt;j&lt;/code&gt; 番目の要素には、 &lt;code&gt;A[2, J[j], 3]&lt;/code&gt; が入力されます。</target>
        </trans-unit>
        <trans-unit id="8ba9cf6bb4f8397cc28a79b830f4f985b9ab3a34" translate="yes" xml:space="preserve">
          <source>The location information can be accessed by referencing &lt;code&gt;__source__.line&lt;/code&gt; and &lt;code&gt;__source__.file&lt;/code&gt;:</source>
          <target state="translated">ロケーション情報には、 &lt;code&gt;__source__.line&lt;/code&gt; および &lt;code&gt;__source__.file&lt;/code&gt; 参照してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="3cb51b112926a1dd81d50332e9952ca8853bb8d8" translate="yes" xml:space="preserve">
          <source>The location of both the &lt;code&gt;local&lt;/code&gt; and &lt;code&gt;global&lt;/code&gt; keywords within the scope block is irrelevant. The following is equivalent to the last example (although stylistically worse):</source>
          <target state="translated">スコープブロック内の &lt;code&gt;local&lt;/code&gt; キーワードと &lt;code&gt;global&lt;/code&gt; キーワードの両方の場所は関係ありません。以下は、前の例と同等です（ただし、スタイルが悪い）。</target>
        </trans-unit>
        <trans-unit id="98682ff20b7c08341d3c5e15b38c14b9a4d16f28" translate="yes" xml:space="preserve">
          <source>The log level provides a key against which potential log records may be filtered, before any other work is done to construct the log record data structure itself.</source>
          <target state="translated">ログ レベルは、ログ レコード データ構造自体を構築するために他の作業が行われる前に、潜在的なログ レコードをフィルタリングするためのキーを提供します。</target>
        </trans-unit>
        <trans-unit id="318d32e896560b8d7266b2f324ddc4a3093ac0b9" translate="yes" xml:space="preserve">
          <source>The loop body must be straight-line code. Therefore, &lt;a href=&quot;#Base.@inbounds&quot;&gt;&lt;code&gt;@inbounds&lt;/code&gt;&lt;/a&gt; is currently needed for all array accesses. The compiler can sometimes turn short &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt;, and &lt;code&gt;?:&lt;/code&gt; expressions into straight-line code if it is safe to evaluate all operands unconditionally. Consider using the &lt;a href=&quot;#Core.ifelse&quot;&gt;&lt;code&gt;ifelse&lt;/code&gt;&lt;/a&gt; function instead of &lt;code&gt;?:&lt;/code&gt; in the loop if it is safe to do so.</source>
          <target state="translated">ループ本体は直線コードでなければなりません。したがって、&lt;a href=&quot;#Base.@inbounds&quot;&gt; &lt;code&gt;@inbounds&lt;/code&gt; &lt;/a&gt;は現在、すべての配列アクセスに必要です。コンパイラーは &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;||&lt;/code&gt; を短くすることがあります。、および &lt;code&gt;?:&lt;/code&gt; すべてのオペランドを無条件で評価しても安全な場合は、式を直線コードに変換します。安全な場合は、ループ内で &lt;code&gt;?:&lt;/code&gt; の代わりに&lt;a href=&quot;#Core.ifelse&quot;&gt; &lt;code&gt;ifelse&lt;/code&gt; &lt;/a&gt;関数を使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="e1520d8e0dbae93326950f00e9cb69f3cae60938" translate="yes" xml:space="preserve">
          <source>The loop must be an innermost loop</source>
          <target state="translated">ループは最内周のループでなければなりません。</target>
        </trans-unit>
        <trans-unit id="1417d30bb5a87b95ed3077cbfd4cd113b702f8de" translate="yes" xml:space="preserve">
          <source>The lowest value representable by the given (real) numeric DataType &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">与えられた（実際の）数値DataType &lt;code&gt;T&lt;/code&gt; で表現可能な最小値。</target>
        </trans-unit>
        <trans-unit id="73472042c68fe0e8852a29376bec0fce0bf44289" translate="yes" xml:space="preserve">
          <source>The macro &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; generates the C-compatible function pointer for a call to a Julia function. Arguments to &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt; are as follows:</source>
          <target state="translated">マクロ&lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; &lt;/a&gt;は、Julia関数を呼び出すためのC互換の関数ポインターを生成します。&lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; の&lt;/a&gt;引数は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a90d2d040a67a205cdeab40f74d8c8876f85fbd9" translate="yes" xml:space="preserve">
          <source>The macro &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt; (or its function variant &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_warntype&quot;&gt;&lt;code&gt;code_warntype&lt;/code&gt;&lt;/a&gt;) can sometimes be helpful in diagnosing type-related problems. Here's an example:</source>
          <target state="translated">マクロ&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt;（またはその関数バリアント&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.code_warntype&quot;&gt; &lt;code&gt;code_warntype&lt;/code&gt; &lt;/a&gt;）は、タイプ関連の問題の診断に役立つことがあります。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="9e7d84ccb0a328a62c08d6f8b7389ef525b8bb84" translate="yes" xml:space="preserve">
          <source>The macro may be chained with &lt;code&gt;@test&lt;/code&gt; to also test the returned value:</source>
          <target state="translated">マクロを &lt;code&gt;@test&lt;/code&gt; とチェーンして、戻り値もテストできます。</target>
        </trans-unit>
        <trans-unit id="ee8a907ab8fbfe293b4dae0afdde54a8eeab9dd2" translate="yes" xml:space="preserve">
          <source>The main purpose of this constructor is intuitive conversion from cartesian to linear indexing:</source>
          <target state="translated">このコンストラクタの主な目的は、直観的に直交的に直交インデックスから線形インデックスに変換することです。</target>
        </trans-unit>
        <trans-unit id="525b6c6d88eda51b84031a3e53a3435af961ebe7" translate="yes" xml:space="preserve">
          <source>The master process does not listen on any port. It only connects out to the workers.</source>
          <target state="translated">マスタープロセスはどのポートもリッスンしません。ワーカーに接続するだけです。</target>
        </trans-unit>
        <trans-unit id="2ed15f9d452fe7aa2e8f8976ab10c5922bcca0ff" translate="yes" xml:space="preserve">
          <source>The master process parses this information and sets up TCP/IP connections to each worker.</source>
          <target state="translated">マスタプロセスは、この情報を解析し、各ワーカーへのTCP/IP接続を設定します。</target>
        </trans-unit>
        <trans-unit id="c61856ffa89efc2e6c1d6b663bec6b092cbe224f" translate="yes" xml:space="preserve">
          <source>The meaning of prefix &lt;code&gt;&amp;amp;&lt;/code&gt; is not quite the same as in C. In particular, any changes to the referenced variables will not be visible in Julia unless the type is mutable (declared via &lt;code&gt;mutable struct&lt;/code&gt;). However, even for immutable structs it will not cause any harm for called functions to attempt such modifications (that is, writing through the passed pointers). Moreover, &lt;code&gt;&amp;amp;&lt;/code&gt; may be used with any expression, such as &lt;code&gt;&amp;amp;0&lt;/code&gt; or &lt;code&gt;&amp;amp;f(x)&lt;/code&gt;.</source>
          <target state="translated">接頭辞 &lt;code&gt;&amp;amp;&lt;/code&gt; の意味はCの場合とまったく同じではありません。特に、参照可能な変数への変更は、タイプが変更可能でない限り（ &lt;code&gt;mutable struct&lt;/code&gt; 宣言されない限り）Juliaでは表示されません。ただし、不変の構造体であっても、呼び出された関数がそのような変更（つまり、渡されたポインタを介して書き込む）を試みても害はありません。さらに、 &lt;code&gt;&amp;amp;&lt;/code&gt; は &lt;code&gt;&amp;amp;0&lt;/code&gt; や &lt;code&gt;&amp;amp;f(x)&lt;/code&gt; などの任意の式で使用できます。</target>
        </trans-unit>
        <trans-unit id="ebdb2209b7357825841deb8a7b0ab3a885d17542" translate="yes" xml:space="preserve">
          <source>The meaning of this form is that &lt;code&gt;F(x,y,...)&lt;/code&gt; is evaluated with the variables &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, etc. taking on each value in their given list of values. Values can be specified as any iterable object, but will commonly be ranges like &lt;code&gt;1:n&lt;/code&gt; or &lt;code&gt;2:(n-1)&lt;/code&gt;, or explicit arrays of values like &lt;code&gt;[1.2, 3.4, 5.7]&lt;/code&gt;. The result is an N-d dense array with dimensions that are the concatenation of the dimensions of the variable ranges &lt;code&gt;rx&lt;/code&gt;, &lt;code&gt;ry&lt;/code&gt;, etc. and each &lt;code&gt;F(x,y,...)&lt;/code&gt; evaluation returns a scalar.</source>
          <target state="translated">この形式の意味は、 &lt;code&gt;F(x,y,...)&lt;/code&gt; が、指定された値のリストの各値をとる変数 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;y&lt;/code&gt; などで評価されることです。値は任意の反復可能なオブジェクトとして指定できますが、通常は &lt;code&gt;1:n&lt;/code&gt; や &lt;code&gt;2:(n-1)&lt;/code&gt; のような範囲、または &lt;code&gt;[1.2, 3.4, 5.7]&lt;/code&gt; ような明示的な値の配列になります。結果は、変数範囲 &lt;code&gt;rx&lt;/code&gt; 、 &lt;code&gt;ry&lt;/code&gt; などの次元の連結である次元を持つNd密配列であり、各 &lt;code&gt;F(x,y,...)&lt;/code&gt; 評価はスカラーを返します。</target>
        </trans-unit>
        <trans-unit id="094836238d056b1580750e9abbf5cfe48e515f79" translate="yes" xml:space="preserve">
          <source>The mechanism by which Julia picks default sorting algorithms is implemented via the &lt;code&gt;Base.Sort.defalg&lt;/code&gt; function. It allows a particular algorithm to be registered as the default in all sorting functions for specific arrays. For example, here are the two default methods from &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/sort.jl&quot;&gt;&lt;code&gt;sort.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Juliaがデフォルトのソートアルゴリズムを選択するメカニズムは、 &lt;code&gt;Base.Sort.defalg&lt;/code&gt; 関数を介して実装されます。特定の配列のすべてのソート関数で、特定のアルゴリズムをデフォルトとして登録できます。たとえば、&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/sort.jl&quot;&gt; &lt;code&gt;sort.jl&lt;/code&gt; の&lt;/a&gt; 2つのデフォルトメソッドは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="43db34e5821153c9a137e29694256181086c27e9" translate="yes" xml:space="preserve">
          <source>The mechanism for combining the roots, graph and paths data structures of the components of an environment stack is simple: they are merged as dictionaries, favoring earlier entries over later ones in the case of key collisions. In other words, if we have &lt;code&gt;stack = [env₁, env₂, &amp;hellip;]&lt;/code&gt; then we have:</source>
          <target state="translated">環境スタックのコンポーネントのルート、グラフ、パスのデータ構造を組み合わせるメカニズムはシンプルです。それらは辞書としてマージされ、キーの衝突が発生した場合に、後のエントリよりも前のエントリを優先します。つまり、 &lt;code&gt;stack = [env₁, env₂, &amp;hellip;]&lt;/code&gt; 場合、次のようになります。</target>
        </trans-unit>
        <trans-unit id="ec55008649a0dc54bad05f3e8bc19d30ce40563f" translate="yes" xml:space="preserve">
          <source>The mechanism for user-defined string literals is deeply, profoundly powerful. Not only are Julia's non-standard literals implemented using it, but also the command literal syntax (&lt;code&gt;`echo &quot;Hello, $person&quot;`&lt;/code&gt;) is implemented with the following innocuous-looking macro:</source>
          <target state="translated">ユーザー定義の文字列リテラルのメカニズムは、非常に強力です。Juliaの非標準リテラルはそれを使用して実装されるだけでなく、コマンドリテラル構文（ &lt;code&gt;`echo &quot;Hello, $person&quot;`&lt;/code&gt; ）も次の無害に見えるマクロで実装されます。</target>
        </trans-unit>
        <trans-unit id="bcd798f681426c31836c9fda7a95d8d4ad32f495" translate="yes" xml:space="preserve">
          <source>The memory consumption estimate is an approximate lower bound on the size of the internal structure of the object.</source>
          <target state="translated">メモリ消費量の推定値は、オブジェクトの内部構造のサイズの近似的な下限値です。</target>
        </trans-unit>
        <trans-unit id="131ca4486e37b369d3e30c30d5b64041c99a698f" translate="yes" xml:space="preserve">
          <source>The memory sharing behavior of a reshaped array is disregarded by precompilation (each view gets its own copy)</source>
          <target state="translated">リシェイプされた配列のメモリ共有動作は,コンパイル前に無視されます(各ビューは独自のコピーを取得します).</target>
        </trans-unit>
        <trans-unit id="298da21a7dd2cc02f54513ff13a66eb673f4dedf" translate="yes" xml:space="preserve">
          <source>The message log level is checked against a global minimum level (set via &lt;a href=&quot;#Base.CoreLogging.disable_logging&quot;&gt;&lt;code&gt;disable_logging&lt;/code&gt;&lt;/a&gt;). This is a crude but extremely cheap global setting.</source>
          <target state="translated">メッセージログレベルは、グローバルな最小レベル（&lt;a href=&quot;#Base.CoreLogging.disable_logging&quot;&gt; &lt;code&gt;disable_logging&lt;/code&gt; で&lt;/a&gt;設定）に対してチェックされます。これは粗雑ですが非常に安価なグローバル設定です。</target>
        </trans-unit>
        <trans-unit id="8ee1b8c607641ce31a518860743fee60270b010d" translate="yes" xml:space="preserve">
          <source>The message-processing loop waits on an &lt;code&gt;IO&lt;/code&gt; object (for example, a &lt;a href=&quot;../../stdlib/sockets/index#Sockets.TCPSocket&quot;&gt;&lt;code&gt;TCPSocket&lt;/code&gt;&lt;/a&gt; in the default implementation), reads an entire message, processes it and waits for the next one.</source>
          <target state="translated">メッセージ処理ループは、 &lt;code&gt;IO&lt;/code&gt; オブジェクト（たとえば、デフォルト実装の&lt;a href=&quot;../../stdlib/sockets/index#Sockets.TCPSocket&quot;&gt; &lt;code&gt;TCPSocket&lt;/code&gt; &lt;/a&gt;）で待機し、メッセージ全体を読み取り、メッセージを処理して、次のメッセージを待機します。</target>
        </trans-unit>
        <trans-unit id="34b07feb0bdcab65a9fbeace753dff1c13bab9a7" translate="yes" xml:space="preserve">
          <source>The method defined above adds parentheses around the call to &lt;code&gt;show&lt;/code&gt; when the precedence of the calling operator is higher than or equal to the precedence of multiplication. This check allows expressions which parse correctly without the parentheses (such as &lt;code&gt;:($a + 2)&lt;/code&gt; and &lt;code&gt;:($a == 2)&lt;/code&gt;) to omit them when printing:</source>
          <target state="translated">上記で定義されたメソッドは、呼び出しの周りに括弧を追加 &lt;code&gt;show&lt;/code&gt; 呼び出し演算子の優先度がより高くなるか、乗算の優先順位に等しいとき。このチェックにより、括弧なしで正しく解析される式（ &lt;code&gt;:($a + 2)&lt;/code&gt; や &lt;code&gt;:($a == 2)&lt;/code&gt; ）は、印刷時にそれらを省略できます。</target>
        </trans-unit>
        <trans-unit id="480991bedb511928dce09fcfa14be4d26a369c2c" translate="yes" xml:space="preserve">
          <source>The method which accepts a predicate function requires Julia 1.2 or later.</source>
          <target state="translated">述語関数を受け付けるメソッドには、Julia 1.2以降が必要です。</target>
        </trans-unit>
        <trans-unit id="f940b926f7e3b612433e90295b463c51a97504f9" translate="yes" xml:space="preserve">
          <source>The methods in &lt;code&gt;Profile&lt;/code&gt; are not exported and need to be called e.g. as &lt;code&gt;Profile.print()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Profile&lt;/code&gt; 内のメソッドはエクスポートされないため、たとえば &lt;code&gt;Profile.print()&lt;/code&gt; として呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="a65046dfbce016e3be9d63dceb54432e4f789ee8" translate="yes" xml:space="preserve">
          <source>The microsecond of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;としての &lt;code&gt;Time&lt;/code&gt; のマイクロ秒。</target>
        </trans-unit>
        <trans-unit id="f9daf874100ff7e0440c12dfc313262d02c86576" translate="yes" xml:space="preserve">
          <source>The microsecond part of a Time as a &lt;code&gt;Microsecond&lt;/code&gt;.</source>
          <target state="translated">時間のマイクロ秒の部分 &lt;code&gt;Microsecond&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0211eebcec0e70acc996cc19c6867555ed469b5e" translate="yes" xml:space="preserve">
          <source>The middle expression is only evaluated once, rather than twice as it would be if the expression were written as &lt;code&gt;v(1) &amp;lt; v(2) &amp;amp;&amp;amp; v(2) &amp;lt;= v(3)&lt;/code&gt;. However, the order of evaluations in a chained comparison is undefined. It is strongly recommended not to use expressions with side effects (such as printing) in chained comparisons. If side effects are required, the short-circuit &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator should be used explicitly (see &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;Short-Circuit Evaluation&lt;/a&gt;).</source>
          <target state="translated">真ん中の式は、式が &lt;code&gt;v(1) &amp;lt; v(2) &amp;amp;&amp;amp; v(2) &amp;lt;= v(3)&lt;/code&gt; として記述された場合のように、2回ではなく1回だけ評価されます。ただし、連鎖比較での評価の順序は定義されていません。連鎖比較では、副作用のある式（印刷など）を使用しないことを強くお勧めします。副作用が必要な場合は、短絡 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 演算子を明示的に使用する必要があります（「&lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;短絡評価&lt;/a&gt;」を参照）。</target>
        </trans-unit>
        <trans-unit id="0dd44e8ebcb71bf9c89ef76d2d2682687dc6d684" translate="yes" xml:space="preserve">
          <source>The millisecond of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;としての &lt;code&gt;DateTime&lt;/code&gt; のミリ秒。</target>
        </trans-unit>
        <trans-unit id="a912f50c335b4d49dd33d6b3bdff08954f636271" translate="yes" xml:space="preserve">
          <source>The millisecond of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;としての &lt;code&gt;Time&lt;/code&gt; のミリ秒。</target>
        </trans-unit>
        <trans-unit id="8b6a7eeee369dc2111377df37522ca806e23ee00" translate="yes" xml:space="preserve">
          <source>The millisecond part of a DateTime as a &lt;code&gt;Millisecond&lt;/code&gt;.</source>
          <target state="translated">DateTimeのミリ秒の部分 &lt;code&gt;Millisecond&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0efc4b9b581f6e3f5cda1b69fb5ed353c8f838e4" translate="yes" xml:space="preserve">
          <source>The minimum and maximum representable values of primitive numeric types such as integers are given by the &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax&lt;/code&gt;&lt;/a&gt; functions:</source>
          <target state="translated">例えば、整数などのプリミティブ数値型の最小値と最大表現可能な値は、によって与えられる&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax&lt;/code&gt; &lt;/a&gt;機能：</target>
        </trans-unit>
        <trans-unit id="85c14b13e4a83e3f641ac750e22da88ea684c364" translate="yes" xml:space="preserve">
          <source>The minute of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;としての &lt;code&gt;DateTime&lt;/code&gt; の分。</target>
        </trans-unit>
        <trans-unit id="fe1f5f0a330c1e54ad4dd4510d655f5340eec1c4" translate="yes" xml:space="preserve">
          <source>The minute of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;としての &lt;code&gt;Time&lt;/code&gt; の分。</target>
        </trans-unit>
        <trans-unit id="c946111c81e7adfe6af7b762fccd905ec8f88a87" translate="yes" xml:space="preserve">
          <source>The minute part of a DateTime as a &lt;code&gt;Minute&lt;/code&gt;.</source>
          <target state="translated">DateTimeの分の部分 &lt;code&gt;Minute&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="847c706add1091574c034eb4a9e1b16f126a1aa6" translate="yes" xml:space="preserve">
          <source>The month of a &lt;code&gt;Date&lt;/code&gt; or &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;としての &lt;code&gt;Date&lt;/code&gt; または &lt;code&gt;DateTime&lt;/code&gt; の月。</target>
        </trans-unit>
        <trans-unit id="1ffed8c4cf30ae11b37e19dbd7e317d781c6a99d" translate="yes" xml:space="preserve">
          <source>The most basic Julia workflows involve using a text editor in conjunction with the &lt;code&gt;julia&lt;/code&gt; command line. A common pattern includes the following elements:</source>
          <target state="translated">Juliaの最も基本的なワークフローでは、 &lt;code&gt;julia&lt;/code&gt; コマンドラインと組み合わせてテキストエディターを使用します。一般的なパターンには、次の要素が含まれます。</target>
        </trans-unit>
        <trans-unit id="d8d0db7f857485bf8537d6760d93ea9e3026a18d" translate="yes" xml:space="preserve">
          <source>The most commonly used kind of type in Julia is a struct, specified as a name and a set of fields.</source>
          <target state="translated">Juliaで最もよく使われる型は構造体で、名前とフィールドのセットとして指定されます。</target>
        </trans-unit>
        <trans-unit id="bd6910dc7e6ab3eb744adf6e8b4dbbd2635bda90" translate="yes" xml:space="preserve">
          <source>The most reasonable alternative to having integer arithmetic silently overflow is to do checked arithmetic everywhere, raising errors when adds, subtracts, and multiplies overflow, producing values that are not value-correct. In this &lt;a href=&quot;http://danluu.com/integer-overflow/&quot;&gt;blog post&lt;/a&gt;, Dan Luu analyzes this and finds that rather than the trivial cost that this approach should in theory have, it ends up having a substantial cost due to compilers (LLVM and GCC) not gracefully optimizing around the added overflow checks. If this improves in the future, we could consider defaulting to checked integer arithmetic in Julia, but for now, we have to live with the possibility of overflow.</source>
          <target state="translated">整数演算を暗黙的にオーバーフローさせる最も妥当な代替策は、チェック演算をどこでも実行し、オーバーフローを加算、減算、乗算するときにエラーを発生させ、値が正しくない値を生成することです。この&lt;a href=&quot;http://danluu.com/integer-overflow/&quot;&gt;ブログ投稿では&lt;/a&gt;、Dan Luuがこれを分析し、このアプローチが理論的には取るに足らないコストではなく、コンパイラー（LLVMとGCC）が追加されたオーバーフローチェックを適切に最適化していないために、かなりのコストがかかることを発見しました。これが将来的に改善される場合は、Juliaでチェックされた整数演算にデフォルト設定することを検討できますが、今のところ、オーバーフローの可能性に耐えなければなりません。</target>
        </trans-unit>
        <trans-unit id="5c96614bea2c2a0370b72e64ab597c56a3607929" translate="yes" xml:space="preserve">
          <source>The most significant departures of Julia from typical dynamic languages are:</source>
          <target state="translated">典型的な動的言語からのユリアの最も重要な出発点は、以下の通りです。</target>
        </trans-unit>
        <trans-unit id="227e81ea680d9761105bfdd7a757c011a63d4676" translate="yes" xml:space="preserve">
          <source>The most useful log pattern is a simple tuple of the form &lt;code&gt;(level,message)&lt;/code&gt;. A different number of tuple elements may be used to match other log metadata, corresponding to the arguments to passed to &lt;code&gt;AbstractLogger&lt;/code&gt; via the &lt;code&gt;handle_message&lt;/code&gt; function: &lt;code&gt;(level,message,module,group,id,file,line)&lt;/code&gt;. Elements which are present will be matched pairwise with the log record fields using &lt;code&gt;==&lt;/code&gt; by default, with the special cases that &lt;code&gt;Symbol&lt;/code&gt;s may be used for the standard log levels, and &lt;code&gt;Regex&lt;/code&gt;s in the pattern will match string or Symbol fields using &lt;code&gt;occursin&lt;/code&gt;.</source>
          <target state="translated">最も有用なログパターンは、 &lt;code&gt;(level,message)&lt;/code&gt; という形式の単純なタプルです。別の数のタプル要素を使用して、 &lt;code&gt;handle_message&lt;/code&gt; 関数を介して &lt;code&gt;AbstractLogger&lt;/code&gt; に渡される引数に対応する他のログメタデータを照合できます： &lt;code&gt;(level,message,module,group,id,file,line)&lt;/code&gt; 。存在する要素は、デフォルトで &lt;code&gt;==&lt;/code&gt; を使用してログレコードフィールドとペアで照合されます。標準のログレベルに &lt;code&gt;Symbol&lt;/code&gt; が使用される場合があり、パターン内の &lt;code&gt;Regex&lt;/code&gt; は、 &lt;code&gt;occursin&lt;/code&gt; を使用して文字列またはSymbolフィールドと照合されます。</target>
        </trans-unit>
        <trans-unit id="3b7050ead4b7f2406a51989e3a96dcd274b5c4dc" translate="yes" xml:space="preserve">
          <source>The name of &lt;code&gt;tag&lt;/code&gt; (e.g. &lt;code&gt;&quot;v0.5&quot;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;tag&lt;/code&gt; の名前（例： &lt;code&gt;&quot;v0.5&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="aac1a5f61cbf21e0f76584158e2b1aa448b0700a" translate="yes" xml:space="preserve">
          <source>The name of the function containing the execution context.</source>
          <target state="translated">実行コンテキストを含む関数の名前。</target>
        </trans-unit>
        <trans-unit id="0b15e5d3b4e9ddd6442998593016569d415621b0" translate="yes" xml:space="preserve">
          <source>The nanosecond of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;としての &lt;code&gt;Time&lt;/code&gt; のナノ秒。</target>
        </trans-unit>
        <trans-unit id="aad1073892a176543a30631fd9ae9393da61cbfc" translate="yes" xml:space="preserve">
          <source>The nanosecond part of a Time as a &lt;code&gt;Nanosecond&lt;/code&gt;.</source>
          <target state="translated">時間のナノ秒の一部 &lt;code&gt;Nanosecond&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82e0de7b0a951b098e85d827d86686abc302c514" translate="yes" xml:space="preserve">
          <source>The nature of keyword arguments makes it possible to specify the same argument more than once. For example, in the call &lt;code&gt;plot(x, y; options..., width=2)&lt;/code&gt; it is possible that the &lt;code&gt;options&lt;/code&gt; structure also contains a value for &lt;code&gt;width&lt;/code&gt;. In such a case the rightmost occurrence takes precedence; in this example, &lt;code&gt;width&lt;/code&gt; is certain to have the value &lt;code&gt;2&lt;/code&gt;. However, explicitly specifying the same keyword argument multiple times, for example &lt;code&gt;plot(x, y, width=2, width=3)&lt;/code&gt;, is not allowed and results in a syntax error.</source>
          <target state="translated">キーワード引数の性質により、同じ引数を複数回指定することが可能になります。たとえば、 &lt;code&gt;plot(x, y; options..., width=2)&lt;/code&gt; の呼び出しでは、 &lt;code&gt;options&lt;/code&gt; 構造体に &lt;code&gt;width&lt;/code&gt; の値も含まれている可能性があります。そのような場合、最も右のオカレンスが優先されます。この例では、 &lt;code&gt;width&lt;/code&gt; は確実に値 &lt;code&gt;2&lt;/code&gt; を持っています。ただし、たとえば &lt;code&gt;plot(x, y, width=2, width=3)&lt;/code&gt; など、同じキーワード引数を明示的に複数回指定することは許可されておらず、構文エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="314d66ff5662511b17e76bf3864e0515f7414401" translate="yes" xml:space="preserve">
          <source>The new dimensions may be specified either as a list of arguments or as a shape tuple. At most one dimension may be specified with a &lt;code&gt;:&lt;/code&gt;, in which case its length is computed such that its product with all the specified dimensions is equal to the length of the original array &lt;code&gt;A&lt;/code&gt;. The total number of elements must not change.</source>
          <target state="translated">新しい次元は、引数のリストまたは形状タプルとして指定できます。最大で1つの次元は &lt;code&gt;:&lt;/code&gt; で指定できます。その場合、その長さは、指定されたすべての次元の積が元の配列 &lt;code&gt;A&lt;/code&gt; の長さと等しくなるように計算されます。要素の総数は変更しないでください。</target>
        </trans-unit>
        <trans-unit id="3ec82b325e399ba219250018d4cd45bb47824912" translate="yes" xml:space="preserve">
          <source>The next example composes three functions and maps the result over an array of strings:</source>
          <target state="translated">次の例では、3 つの関数を構成し、その結果を文字列の配列にマップしています。</target>
        </trans-unit>
        <trans-unit id="0141922960db98bd617ee28c2bf6139f8261ae58" translate="yes" xml:space="preserve">
          <source>The next step is to &lt;a href=&quot;https://en.wikipedia.org/wiki/Parsing#Computer_languages&quot;&gt;parse&lt;/a&gt; each string into an object called an expression, represented by the Julia type &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">次の手順では、各文字列を&lt;a href=&quot;https://en.wikipedia.org/wiki/Parsing#Computer_languages&quot;&gt;解析&lt;/a&gt;して、Juliaタイプ&lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt;で表される式と呼ばれるオブジェクトに変換します。</target>
        </trans-unit>
        <trans-unit id="571a7acf064deadfa35e0bae63b5faada78832c9" translate="yes" xml:space="preserve">
          <source>The next step is to set up the project to find the Julia include files and the libraries. It's important to know whether the Julia installation is 32- or 64-bits. Remove any platform configuration that doesn't correspond to the Julia installation before proceeding.</source>
          <target state="translated">次のステップは、Juliaのインクルードファイルとライブラリを見つけるためにプロジェクトを設定することです。Julia のインストールが 32 ビットか 64 ビットかを知ることが重要です。先に進む前に、Julia のインストールに対応していないプラットフォームの設定を削除してください。</target>
        </trans-unit>
        <trans-unit id="87d90798d58eeb7d4e5d75a87f02bc64256ab91b" translate="yes" xml:space="preserve">
          <source>The next two higher-order methods, &lt;a href=&quot;#Dates.tonext-Tuple%7BTimeType,Int64%7D&quot;&gt;&lt;code&gt;tonext&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#Dates.toprev-Tuple%7BTimeType,Int64%7D&quot;&gt;&lt;code&gt;toprev&lt;/code&gt;&lt;/a&gt;, generalize working with temporal expressions by taking a &lt;code&gt;DateFunction&lt;/code&gt; as first argument, along with a starting &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt;. A &lt;code&gt;DateFunction&lt;/code&gt; is just a function, usually anonymous, that takes a single &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt; as input and returns a &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;true&lt;/code&gt; indicating a satisfied adjustment criterion. For example:</source>
          <target state="translated">次の二つの高次法、&lt;a href=&quot;#Dates.tonext-Tuple%7BTimeType,Int64%7D&quot;&gt; &lt;code&gt;tonext&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#Dates.toprev-Tuple%7BTimeType,Int64%7D&quot;&gt; &lt;code&gt;toprev&lt;/code&gt; &lt;/a&gt;、取ることによって、一時的な表情で作業を一般 &lt;code&gt;DateFunction&lt;/code&gt; を開始するとともに、最初の引数として&lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt;。 A &lt;code&gt;DateFunction&lt;/code&gt; は単一とる、通常、匿名だけ関数である&lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; を&lt;/a&gt;入力とし、返す&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;、 &lt;code&gt;true&lt;/code&gt; 満足調整基準を示します。例えば：</target>
        </trans-unit>
        <trans-unit id="bfdcd43295ca16b8983e8ac5f09ed7f5b30bbe1e" translate="yes" xml:space="preserve">
          <source>The next two steps (selecting the output array and implementation) are dependent upon determining a single answer for a given set of arguments. Broadcast must take all the varied types of its arguments and collapse them down to just one output array and one implementation. Broadcast calls this single answer a &quot;style.&quot; Every broadcastable object each has its own preferred style, and a promotion-like system is used to combine these styles into a single answer &amp;mdash; the &quot;destination style&quot;.</source>
          <target state="translated">次の2つのステップ（出力配列と実装の選択）は、与えられた引数のセットに対する単一の回答の決定に依存しています。Broadcastは、さまざまなタイプの引数をすべて受け取り、それらを1つの出力配列と1つの実装にまとめなければなりません。ブロードキャストでは、この単一の回答を「スタイル」と呼んでいます。ブロードキャスト可能なオブジェクトにはそれぞれ独自の優先スタイルがあり、プロモーションのようなシステムを使用して、これらのスタイルを単一の回答、つまり「宛先スタイル」に結合します。</target>
        </trans-unit>
        <trans-unit id="aa11e7d901418eb60c69c43212182dad6fd572f8" translate="yes" xml:space="preserve">
          <source>The no-equilibration, no-transpose simplification of &lt;code&gt;gesvx!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gesvx!&lt;/code&gt; の非平衡化、非転置単純化！。</target>
        </trans-unit>
        <trans-unit id="a3be6317f46ece197572e4701784f6328c75ca21" translate="yes" xml:space="preserve">
          <source>The node where the value is stored keeps track of which of the workers have a reference to it. Every time a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; or a (unfetched) &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; is serialized to a worker, the node pointed to by the reference is notified. And every time a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; or a (unfetched) &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; is garbage collected locally, the node owning the value is again notified. This is implemented in an internal cluster aware serializer. Remote references are only valid in the context of a running cluster. Serializing and deserializing references to and from regular &lt;code&gt;IO&lt;/code&gt; objects is not supported.</source>
          <target state="translated">値が格納されているノードは、どのワーカーがその値を参照しているかを追跡します。&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt;または（フェッチされていない）&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;がワーカーにシリアル化されるたびに、参照によってポイントされているノードに通知されます。また、&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt;または（フェッチされていない）&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;がローカルでガベージコレクションされるたびに、値を所有するノードに再度通知されます。これは、内部クラスター対応シリアライザーに実装されています。リモート参照は、実行中のクラスターのコンテキストでのみ有効です。通常の &lt;code&gt;IO&lt;/code&gt; オブジェクトとの間の参照のシリアル化と逆シリアル化はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="1ee269a033086fa0f88e3b8bd43c4d1005189ba4" translate="yes" xml:space="preserve">
          <source>The node which owns the value frees it once all references to it are cleared.</source>
          <target state="translated">その値を所有するノードは、その値へのすべての参照がクリアされると、その値を解放します。</target>
        </trans-unit>
        <trans-unit id="9c9581a565bb9e56cce70d93ca5c19c14a7d3c0d" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;Pointy{&amp;lt;:Real}&lt;/code&gt; can be used to express the Julia analogue of a &lt;em&gt;covariant&lt;/em&gt; type, while &lt;code&gt;Pointy{&amp;gt;:Int}&lt;/code&gt; the analogue of a &lt;em&gt;contravariant&lt;/em&gt; type, but technically these represent &lt;em&gt;sets&lt;/em&gt; of types (see &lt;a href=&quot;#UnionAll-Types-1&quot;&gt;UnionAll Types&lt;/a&gt;).</source>
          <target state="translated">表記 &lt;code&gt;Pointy{&amp;lt;:Real}&lt;/code&gt; は&lt;em&gt;共変&lt;/em&gt;タイプのジュリア類似体を表すのに使用できますが、 &lt;code&gt;Pointy{&amp;gt;:Int}&lt;/code&gt; は&lt;em&gt;反変&lt;/em&gt;タイプの類似体を表現でき&lt;em&gt;ます&lt;/em&gt;が、技術的にはこれらはタイプの&lt;em&gt;セット&lt;/em&gt;を表し&lt;em&gt;ます&lt;/em&gt;（&lt;a href=&quot;#UnionAll-Types-1&quot;&gt;UnionAllタイプを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="4d8a556b93d1842772dc7f76de931e723dfee64b" translate="yes" xml:space="preserve">
          <source>The notation &lt;code&gt;T(x)&lt;/code&gt; or &lt;code&gt;convert(T,x)&lt;/code&gt; converts &lt;code&gt;x&lt;/code&gt; to a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">表記 &lt;code&gt;T(x)&lt;/code&gt; または &lt;code&gt;convert(T,x)&lt;/code&gt; 変換は、 &lt;code&gt;x&lt;/code&gt; は型の値に &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe139a73bee792b672a69d44b859332e9c6820f5" translate="yes" xml:space="preserve">
          <source>The notifications are done via sending of &quot;tracking&quot; messages&amp;ndash;an &quot;add reference&quot; message when a reference is serialized to a different process and a &quot;delete reference&quot; message when a reference is locally garbage collected.</source>
          <target state="translated">通知は、「追跡」メッセージ（参照が別のプロセスにシリアル化された場合の「参照の追加」メッセージ）と、参照がローカルでガベージコレクションされた場合の「参照の削除」メッセージの送信によって行われます。</target>
        </trans-unit>
        <trans-unit id="2cbf1f552e1a2901fc74809693aa1d1ec7161dbc" translate="yes" xml:space="preserve">
          <source>The notion of the UT second is actually quite fundamental. There are basically two different notions of time generally accepted, one based on the physical rotation of the earth (one full rotation = 1 day), the other based on the SI second (a fixed, constant value). These are radically different! Think about it, a &quot;UT second&quot;, as defined relative to the rotation of the earth, may have a different absolute length depending on the day! Anyway, the fact that &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; are based on UT seconds is a simplifying, yet honest assumption so that things like leap seconds and all their complexity can be avoided. This basis of time is formally called &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_Time&quot;&gt;UT&lt;/a&gt; or UT1. Basing types on the UT second basically means that every minute has 60 seconds and every day has 24 hours and leads to more natural calculations when working with calendar dates.</source>
          <target state="translated">UT秒の概念は、実際には非常に基本的です。基本的に2つの異なる時間の概念が一般的に受け入れられています。1つは地球の物理的な回転に基づいており（1つは完全な回転= 1日）、もう1つはSI秒に基づいています（固定された定数値）。これらは根本的に異なります！地球の自転に関連して定義された「UT秒」は、日によって絶対長が異なる場合があります。とにかく、&lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;がUT秒に基づいているという事実は、うるう秒などの複雑さをすべて回避できるように、単純化されていますが、正直な仮定です。この時間の基準は正式には&lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_Time&quot;&gt;UT&lt;/a&gt;と呼ばれますまたはUT1。UT秒の基本型は基本的に、毎分が60秒、毎日が24時間であり、カレンダーの日付を操作するときに、より自然な計算につながります。</target>
        </trans-unit>
        <trans-unit id="abccc41a26dc7addb4c68d102fecb6865b6fa56f" translate="yes" xml:space="preserve">
          <source>The number after the name indicates how many bits of storage the type requires. Currently, only sizes that are multiples of 8 bits are supported. The &lt;a href=&quot;../numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt; declaration shows how a primitive type can be optionally declared to be a subtype of some supertype.</source>
          <target state="translated">名前の後の数字は、タイプが必要とするストレージのビット数を示します。現在、8ビットの倍数のサイズのみがサポートされています。&lt;a href=&quot;../numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;プリミティブ型は、必要に応じて、いくつかのスーパータイプのサブタイプであると宣言することができる方法を宣言示します。</target>
        </trans-unit>
        <trans-unit id="375b6efd3979207393378302c9f41c7a21121f28" translate="yes" xml:space="preserve">
          <source>The number of bits indicates how much storage the type requires and the name gives the new type a name. A primitive type can optionally be declared to be a subtype of some supertype. If a supertype is omitted, then the type defaults to having &lt;code&gt;Any&lt;/code&gt; as its immediate supertype. The declaration of &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt; above therefore means that a boolean value takes eight bits to store, and has &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; as its immediate supertype. Currently, only sizes that are multiples of 8 bits are supported. Therefore, boolean values, although they really need just a single bit, cannot be declared to be any smaller than eight bits.</source>
          <target state="translated">ビット数は、タイプに必要なストレージの量を示し、名前は新しいタイプに名前を付けます。プリミティブ型は、任意でスーパータイプのサブタイプとして宣言できます。スーパータイプを省略すると、タイプのデフォルトは、直接のスーパータイプとして &lt;code&gt;Any&lt;/code&gt; になります。したがって、上記の&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;の宣言は、ブール値を格納するために8ビットを使用し、その直接のスーパータイプとして&lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt;を持つことを意味します。現在、8ビットの倍数のサイズのみがサポートされています。したがって、ブール値は実際には1ビットのみ必要ですが、8ビット未満であると宣言することはできません。</target>
        </trans-unit>
        <trans-unit id="e47d85b6b66b2f56b7aa9e07418e7bd219677af8" translate="yes" xml:space="preserve">
          <source>The number of characters in string &lt;code&gt;s&lt;/code&gt; from indices &lt;code&gt;i&lt;/code&gt; through &lt;code&gt;j&lt;/code&gt;. This is computed as the number of code unit indices from &lt;code&gt;i&lt;/code&gt; to &lt;code&gt;j&lt;/code&gt; which are valid character indices. With only a single string argument, this computes the number of characters in the entire string. With &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; arguments it computes the number of indices between &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; inclusive that are valid indices in the string &lt;code&gt;s&lt;/code&gt;. In addition to in-bounds values, &lt;code&gt;i&lt;/code&gt; may take the out-of-bounds value &lt;code&gt;ncodeunits(s) + 1&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; may take the out-of-bounds value &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">インデックス &lt;code&gt;i&lt;/code&gt; から &lt;code&gt;j&lt;/code&gt; までの文字列 &lt;code&gt;s&lt;/code&gt; の文字数。これは、有効な文字インデックスである &lt;code&gt;i&lt;/code&gt; から &lt;code&gt;j&lt;/code&gt; までのコードユニットインデックスの数として計算されます。文字列引数が1つだけの場合、これは文字列全体の文字数を計算します。 &lt;code&gt;i&lt;/code&gt; と &lt;code&gt;j&lt;/code&gt; の引数には、間のインデックスの数を計算 &lt;code&gt;i&lt;/code&gt; と &lt;code&gt;j&lt;/code&gt; 文字列で有効な指標である包括 &lt;code&gt;s&lt;/code&gt; 。範囲外の値に加えて、 &lt;code&gt;i&lt;/code&gt; は範囲外の値 &lt;code&gt;ncodeunits(s) + 1&lt;/code&gt; を取り、 &lt;code&gt;j&lt;/code&gt; は範囲外の値を取ります。 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ad86f1d6f640919b745cf8a5f2bdcf26fd5ffb5" translate="yes" xml:space="preserve">
          <source>The number of hard links to the file</source>
          <target state="translated">ファイルへのハードリンクの数</target>
        </trans-unit>
        <trans-unit id="24a208f4a834f5901bdf25637d96fa3b819cf46a" translate="yes" xml:space="preserve">
          <source>The number of items in each dimension, if known</source>
          <target state="translated">各次元の項目数(既知の場合</target>
        </trans-unit>
        <trans-unit id="eba5aa4a440d944ee0ac4bd42c3f98d0088c8d6f" translate="yes" xml:space="preserve">
          <source>The number of items, if known</source>
          <target state="translated">アイテムの数がわかっている場合</target>
        </trans-unit>
        <trans-unit id="fd0b7f33e8f96892366bb012a5417e87ca9ea66f" translate="yes" xml:space="preserve">
          <source>The number of logical CPU cores available in the system, i.e. the number of threads that the CPU can run concurrently. Note that this is not necessarily the number of CPU cores, for example, in the presence of &lt;a href=&quot;https://en.wikipedia.org/wiki/Hyper-threading&quot;&gt;hyper-threading&lt;/a&gt;.</source>
          <target state="translated">システムで使用可能な論理CPUコアの数、つまり、CPUが同時に実行できるスレッドの数。これは、&lt;a href=&quot;https://en.wikipedia.org/wiki/Hyper-threading&quot;&gt;ハイパースレッディングが&lt;/a&gt;存在する場合など、必ずしもCPUコアの数ではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="e345fe9c2de9253c74f924ce4e5ac488569c4e0e" translate="yes" xml:space="preserve">
          <source>The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; in the worker process's environment. Relevant only when using TCP/IP as transport.</source>
          <target state="translated">新しく起動されたワーカーがマスターからの接続確立を待機する秒数は、ワーカープロセスの環境の変数 &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; で指定できます。トランスポートとしてTCP / IPを使用する場合にのみ関連します。</target>
        </trans-unit>
        <trans-unit id="401c50950c464431455634fa5427d8b16913972d" translate="yes" xml:space="preserve">
          <source>The number of such blocks allocated</source>
          <target state="translated">割り当てられたブロックの数</target>
        </trans-unit>
        <trans-unit id="e8e81fb72f02f0f0604e2587ad1458b114eaf4e4" translate="yes" xml:space="preserve">
          <source>The number of threads Julia starts up with is controlled by an environment variable called &lt;code&gt;JULIA_NUM_THREADS&lt;/code&gt;. Now, let's start up Julia with 4 threads:</source>
          <target state="translated">Juliaが起動するスレッドの数は、 &lt;code&gt;JULIA_NUM_THREADS&lt;/code&gt; と呼ばれる環境変数によって制御されます。次に、4つのスレッドでJuliaを起動します。</target>
        </trans-unit>
        <trans-unit id="d85834b4873990e0b8a9335e254e4dd1dde6aed2" translate="yes" xml:space="preserve">
          <source>The number of times a generated function is generated &lt;em&gt;might&lt;/em&gt; be only once, but it &lt;em&gt;might&lt;/em&gt; also be more often, or appear to not happen at all. As a consequence, you should &lt;em&gt;never&lt;/em&gt; write a generated function with side effects - when, and how often, the side effects occur is undefined. (This is true for macros too - and just like for macros, the use of &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; in a generated function is a sign that you're doing something the wrong way.) However, unlike macros, the runtime system cannot correctly handle a call to &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;, so it is disallowed.</source>
          <target state="translated">生成された関数が生成される回数&lt;em&gt;かもしれない&lt;/em&gt;、一度だけでよいが、それは&lt;em&gt;可能性&lt;/em&gt;もより頻繁になり、あるいはまったく起こらないように見えます。その結果、次のことを行う必要があり&lt;em&gt;決して&lt;/em&gt;、副作用が定義されていない発生し、どのくらいの頻度-副作用で生成された関数を記述していません。（これはマクロにも当てはまります。マクロと同様に、生成された関数での&lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;の使用は、何か間違った方法で実行していることを示します。）ただし、マクロとは異なり、ランタイムシステムは、&lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;なので、許可されていません。</target>
        </trans-unit>
        <trans-unit id="0ae813381c0022ace29605243aaae816db8d2b62" translate="yes" xml:space="preserve">
          <source>The object has three fields:</source>
          <target state="translated">オブジェクトには3つのフィールドがあります。</target>
        </trans-unit>
        <trans-unit id="f26db4e1766d8278e77cd687e2593b52ae02c589" translate="yes" xml:space="preserve">
          <source>The object has two fields:</source>
          <target state="translated">オブジェクトには2つのフィールドがあります。</target>
        </trans-unit>
        <trans-unit id="4d6829e15fd876880334e8233e7664c2c9a74a93" translate="yes" xml:space="preserve">
          <source>The object iterated over in a &lt;code&gt;@simd for&lt;/code&gt; loop should be a one-dimensional range. By using &lt;code&gt;@simd&lt;/code&gt;, you are asserting several properties of the loop:</source>
          <target state="translated">&lt;code&gt;@simd for&lt;/code&gt; ループで反復されるオブジェクトは、1次元の範囲である必要があります。 &lt;code&gt;@simd&lt;/code&gt; を使用すると、ループのいくつかのプロパティをアサートします。</target>
        </trans-unit>
        <trans-unit id="30a81b0cbf6e9a0a37ccae194bb527cb1e3d2158" translate="yes" xml:space="preserve">
          <source>The objects called do not have matching dimensionality. Optional argument &lt;code&gt;msg&lt;/code&gt; is a descriptive error string.</source>
          <target state="translated">呼び出されたオブジェクトは、次元が一致していません。オプションの引数 &lt;code&gt;msg&lt;/code&gt; は、説明的なエラー文字列です。</target>
        </trans-unit>
        <trans-unit id="c67a85d00391dfa4e34905a89b16c12f29c02b01" translate="yes" xml:space="preserve">
          <source>The one-line sentence should use the imperative form (&quot;Do this&quot;, &quot;Return that&quot;) instead of the third person (do not write &quot;Returns the length...&quot;) when documenting functions. It should end with a period. If the meaning of a function cannot be summarized easily, splitting it into separate composable parts could be beneficial (this should not be taken as an absolute requirement for every single case though).</source>
          <target state="translated">一行文は、関数を文書化する際には、三人称ではなく命令形(「これをする」「それを返す」)を使用します(「長さを返す」とは書かないでください)。最後はピリオドで終わるべきです。関数の意味を簡単にまとめることができない場合は、関数を分割して構成可能な部分に分割することが有益です(ただし、これはすべての場合の絶対的な要件であると考えるべきではありません)。</target>
        </trans-unit>
        <trans-unit id="b6ddf67182af91ce5f2d607a93387a34e5a2b0e5" translate="yes" xml:space="preserve">
          <source>The only exception to the use of &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; as the rounding epoch is when rounding to weeks. Rounding to the nearest week will always return a Monday (the first day of the week as specified by ISO 8601). For this reason, we use &lt;code&gt;0000-01-03T00:00:00&lt;/code&gt; (the first day of the first week of year 0000, as defined by ISO 8601) as the base when rounding to a number of weeks.</source>
          <target state="translated">丸めのエポックとしての &lt;code&gt;0000-01-01T00:00:00&lt;/code&gt; の使用の唯一の例外は、週に丸める場合です。最も近い週に丸めると、常に月曜日（ISO 8601で指定されている週の最初の日）が返されます。このため、週数を四捨五入する場合は、 &lt;code&gt;0000-01-03T00:00:00&lt;/code&gt; （ISO 8601で定義されている0000の最初の週の最初の日）を基準として使用します。</target>
        </trans-unit>
        <trans-unit id="9363f36d4f2b17a0031fe8893a1c08b698e154a6" translate="yes" xml:space="preserve">
          <source>The only explicitly disallowed names for variables are the names of built-in statements:</source>
          <target state="translated">明示的に禁止されている変数名は、組み込み文の名前だけです。</target>
        </trans-unit>
        <trans-unit id="b0a96430cabd292322cdf6d0ab2a28460461ca0e" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;=&lt;/code&gt; always returns the right-hand side, therefore:</source>
          <target state="translated">演算子 &lt;code&gt;=&lt;/code&gt; は常に右側を返すため、次のようになります。</target>
        </trans-unit>
        <trans-unit id="61c61a08879a6bdf3c24805cb6233ff2beffb8f1" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; are non-associative. &lt;code&gt;a + b + c&lt;/code&gt; is parsed as &lt;code&gt;+(a, b, c)&lt;/code&gt; not &lt;code&gt;+(+(a, b), c)&lt;/code&gt;. However, the fallback methods for &lt;code&gt;+(a, b, c, d...)&lt;/code&gt; and &lt;code&gt;*(a, b, c, d...)&lt;/code&gt; both default to left-associative evaluation.</source>
          <target state="translated">演算子 &lt;code&gt;+&lt;/code&gt; 、 &lt;code&gt;++&lt;/code&gt; 、および &lt;code&gt;*&lt;/code&gt; は関連付けられていません。 &lt;code&gt;a + b + c&lt;/code&gt; は &lt;code&gt;+(+(a, b), c)&lt;/code&gt; なく+（ &lt;code&gt;+(a, b, c)&lt;/code&gt; として解析されます。ただし、 &lt;code&gt;+(a, b, c, d...)&lt;/code&gt; および &lt;code&gt;*(a, b, c, d...)&lt;/code&gt; のフォールバックメソッドは、どちらもデフォルトで左結合評価になります。</target>
        </trans-unit>
        <trans-unit id="107f84ddc83f3132ac9e7c776c3ad804db96f800" translate="yes" xml:space="preserve">
          <source>The optimal choice of absolute (&lt;code&gt;atol&lt;/code&gt;) and relative tolerance (&lt;code&gt;rtol&lt;/code&gt;) varies both with the value of &lt;code&gt;M&lt;/code&gt; and the intended application of the pseudoinverse. The default relative tolerance is &lt;code&gt;n*ϵ&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the size of the smallest dimension of &lt;code&gt;M&lt;/code&gt;, and &lt;code&gt;ϵ&lt;/code&gt; is the &lt;a href=&quot;../dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; of the element type of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">絶対（ &lt;code&gt;atol&lt;/code&gt; ）と相対許容誤差（ &lt;code&gt;rtol&lt;/code&gt; ）の最適な選択は、 &lt;code&gt;M&lt;/code&gt; の値と疑似逆行列の目的のアプリケーションの両方によって異なります。デフォルトの相対許容誤差は &lt;code&gt;n*ϵ&lt;/code&gt; です。ここで、 &lt;code&gt;n&lt;/code&gt; は &lt;code&gt;M&lt;/code&gt; の最小寸法のサイズ、 &lt;code&gt;ϵ&lt;/code&gt; は &lt;code&gt;M&lt;/code&gt; の要素タイプの&lt;a href=&quot;../dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="a2df9f292c890ebf432c888dc85d326e28ff79fa" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;chars&lt;/code&gt; argument specifies which characters to remove: it can be a single character, or a vector or set of characters.</source>
          <target state="translated">オプションの &lt;code&gt;chars&lt;/code&gt; 引数は、削除する文字を指定します。単一の文字でも、ベクトルまたは文字のセットでもかまいません。</target>
        </trans-unit>
        <trans-unit id="58713c9681927cdb79ff5aaa798bc3500eccfa8e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;chars&lt;/code&gt; argument specifies which characters to remove: it can be a single character, vector or set of characters.</source>
          <target state="translated">オプションの &lt;code&gt;chars&lt;/code&gt; 引数は、削除する文字を指定します。単一の文字、ベクトル、または文字のセットを指定できます。</target>
        </trans-unit>
        <trans-unit id="7d04d2d866b93a37d08384445eed5a33ef5a6c88" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;esc&lt;/code&gt; argument specifies any additional characters that should also be escaped by a prepending backslash (&lt;code&gt;&quot;&lt;/code&gt; is also escaped by default in the first form).</source>
          <target state="translated">オプションの &lt;code&gt;esc&lt;/code&gt; 引数は、先頭にバックスラッシュを付けることでエスケープする必要がある追加の文字を指定します（最初の形式では、デフォルトで &lt;code&gt;&quot;&lt;/code&gt; もエスケープされます）。</target>
        </trans-unit>
        <trans-unit id="194efabb3b5dd2732e2e6600190698fedd3b0069" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;code&gt;procs&lt;/code&gt; allows specifying a subset of all processes to have execute the expression.</source>
          <target state="translated">オプションの引数 &lt;code&gt;procs&lt;/code&gt; を使用すると、すべてのプロセスのサブセットを指定して式を実行できます。</target>
        </trans-unit>
        <trans-unit id="880714bb7ddfa7f3f83801253a212b4edc50e2e9" translate="yes" xml:space="preserve">
          <source>The optional declarations string contains external functions declarations that are necessary for llvm to compile the IR string. Multiple declarations can be passed in by separating them with line breaks.</source>
          <target state="translated">オプションの宣言文字列には、llvmがIR文字列をコンパイルするために必要な外部関数の宣言が含まれています。複数の宣言を改行で区切ることで、複数の宣言を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="d319e50b1de0ad66b05495c666753f05c93c4fb2" translate="yes" xml:space="preserve">
          <source>The optional flags argument is a bitwise-or of zero or more of &lt;code&gt;RTLD_LOCAL&lt;/code&gt;, &lt;code&gt;RTLD_GLOBAL&lt;/code&gt;, &lt;code&gt;RTLD_LAZY&lt;/code&gt;, &lt;code&gt;RTLD_NOW&lt;/code&gt;, &lt;code&gt;RTLD_NODELETE&lt;/code&gt;, &lt;code&gt;RTLD_NOLOAD&lt;/code&gt;, &lt;code&gt;RTLD_DEEPBIND&lt;/code&gt;, and &lt;code&gt;RTLD_FIRST&lt;/code&gt;. These are converted to the corresponding flags of the POSIX (and/or GNU libc and/or MacOS) dlopen command, if possible, or are ignored if the specified functionality is not available on the current platform. The default flags are platform specific. On MacOS the default &lt;code&gt;dlopen&lt;/code&gt; flags are &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; while on other platforms the defaults are &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL&lt;/code&gt;. An important usage of these flags is to specify non default behavior for when the dynamic library loader binds library references to exported symbols and if the bound references are put into process local or global scope. For instance &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; allows the library's symbols to be available for usage in other shared libraries, addressing situations where there are dependencies between shared libraries.</source>
          <target state="translated">オプションのflags引数は、 &lt;code&gt;RTLD_LOCAL&lt;/code&gt; 、 &lt;code&gt;RTLD_GLOBAL&lt;/code&gt; 、 &lt;code&gt;RTLD_LAZY&lt;/code&gt; 、 &lt;code&gt;RTLD_NOW&lt;/code&gt; 、 &lt;code&gt;RTLD_NODELETE&lt;/code&gt; 、 &lt;code&gt;RTLD_NOLOAD&lt;/code&gt; 、 &lt;code&gt;RTLD_DEEPBIND&lt;/code&gt; 、および &lt;code&gt;RTLD_FIRST&lt;/code&gt; のゼロ以上のビット単位の論理和です。これらは、可能な場合、POSIX（および/またはGNU libcおよび/またはMacOS）dlopenコマンドの対応するフラグに変換されるか、指定された機能が現在のプラットフォームで使用できない場合は無視されます。デフォルトのフラグはプラットフォーム固有です。 MacOSでは、デフォルトの &lt;code&gt;dlopen&lt;/code&gt; フラグは &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; が、他のプラットフォームでは、デフォルトは &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_LOCAL&lt;/code&gt; 。これらのフラグの重要な使用法は、ダイナミックライブラリローダーがライブラリ参照をエクスポートされたシンボルにバインドするとき、およびバインドされた参照がプロセスのローカルまたはグローバルスコープに入れられる場合のデフォルト以外の動作を指定することです。たとえば、 &lt;code&gt;RTLD_LAZY|RTLD_DEEPBIND|RTLD_GLOBAL&lt;/code&gt; は、ライブラリのシンボルを他の共有ライブラリで使用できるようにし、共有ライブラリ間に依存関係がある状況に対処します。</target>
        </trans-unit>
        <trans-unit id="6852910866895c99e590be9b40672a6aa6893cd3" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;f&lt;/code&gt;. The optional &lt;code&gt;sizehint&lt;/code&gt; is a suggested size (in bytes) to allocate for the buffer used to write the string.</source>
          <target state="translated">オプションのキーワード引数 &lt;code&gt;context&lt;/code&gt; は、 &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; ペア、または &lt;code&gt;f&lt;/code&gt; に渡されるI / Oストリームに使用される属性を持つ &lt;code&gt;IO&lt;/code&gt; または&lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;オブジェクトに設定できます。オプションの &lt;code&gt;sizehint&lt;/code&gt; は、文字列の書き込みに使用されるバッファーに割り当てる推奨サイズ（バイト単位）です。</target>
        </trans-unit>
        <trans-unit id="dcac34ba486f2b65b96a033b6cb20a0748bc3d60" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">オプションのキーワード引数 &lt;code&gt;context&lt;/code&gt; は、 &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; ペア、または &lt;code&gt;show&lt;/code&gt; に渡されるI / Oストリームに属性が使用される &lt;code&gt;IO&lt;/code&gt; または&lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;オブジェクトに設定できます。</target>
        </trans-unit>
        <trans-unit id="f5605ad644c7f46c7d640d10514c1e111f9c1381" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">オプションのキーワード引数 &lt;code&gt;context&lt;/code&gt; は、 &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; ペア、または &lt;code&gt;show&lt;/code&gt; に渡されるI / Oストリームに属性が使用される &lt;code&gt;IO&lt;/code&gt; または&lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;オブジェクトに設定できます。</target>
        </trans-unit>
        <trans-unit id="b019c5488e0a6b54b72c3dc4970022b5261bd3cf" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; pair or an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;writefunc&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt;.</source>
          <target state="translated">オプションのキーワード引数 &lt;code&gt;context&lt;/code&gt; は、 &lt;code&gt;:key=&amp;gt;value&lt;/code&gt; ペア、または &lt;code&gt;writefunc&lt;/code&gt; または &lt;code&gt;write&lt;/code&gt; に渡されるI / Oストリームに使用される属性を持つ &lt;code&gt;IO&lt;/code&gt; または&lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;オブジェクトに設定できます。</target>
        </trans-unit>
        <trans-unit id="79723906c1f968e609f55475d1035da056cea38f" translate="yes" xml:space="preserve">
          <source>The optional keyword argument &lt;code&gt;context&lt;/code&gt; can be set to an &lt;code&gt;IO&lt;/code&gt; or &lt;a href=&quot;../io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; object whose attributes are used for the I/O stream passed to &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">オプションのキーワード引数 &lt;code&gt;context&lt;/code&gt; は、属性が &lt;code&gt;show&lt;/code&gt; に渡されるI / Oストリームに使用される &lt;code&gt;IO&lt;/code&gt; または&lt;a href=&quot;../io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;オブジェクトに設定できます。</target>
        </trans-unit>
        <trans-unit id="1d024d8ad27a045cd403adcafbb8a97939e2259d" translate="yes" xml:space="preserve">
          <source>The optional keyword arguments are:</source>
          <target state="translated">オプションのキーワード引数は</target>
        </trans-unit>
        <trans-unit id="7277b33c208d262f473b8b03d8c039301737232a" translate="yes" xml:space="preserve">
          <source>The optional list of &lt;code&gt;key=value&lt;/code&gt; pairs supports arbitrary user defined metadata which will be passed through to the logging backend as part of the log record. If only a &lt;code&gt;value&lt;/code&gt; expression is supplied, a key representing the expression will be generated using &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;. For example, &lt;code&gt;x&lt;/code&gt; becomes &lt;code&gt;x=x&lt;/code&gt;, and &lt;code&gt;foo(10)&lt;/code&gt; becomes &lt;code&gt;Symbol(&quot;foo(10)&quot;)=foo(10)&lt;/code&gt;. For splatting a list of key value pairs, use the normal splatting syntax, &lt;code&gt;@info &quot;blah&quot; kws...&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key=value&lt;/code&gt; ペアのオプションのリストは、ログレコードの一部としてログバックエンドに渡される任意のユーザー定義メタデータをサポートします。 &lt;code&gt;value&lt;/code&gt; 式のみが指定されている場合、式を表すキーは&lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt;を使用して生成されます。たとえば、 &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;x=x&lt;/code&gt; になり、 &lt;code&gt;foo(10)&lt;/code&gt; は &lt;code&gt;Symbol(&quot;foo(10)&quot;)=foo(10)&lt;/code&gt; になります。キーと値のペアのリストを &lt;code&gt;@info &quot;blah&quot; kws...&lt;/code&gt; するには、通常のスプラッティング構文@info &quot;blah&quot; kws ...を使用します。</target>
        </trans-unit>
        <trans-unit id="01ff66cb9afdd1acbcec4725d95eb63b3a880ae3" translate="yes" xml:space="preserve">
          <source>The optional second argument restricts the search to a particular module or function (the default is all top-level modules).</source>
          <target state="translated">オプションの2番目の引数は、検索対象を特定のモジュールまたは関数に制限します (デフォルトはすべてのトップレベルのモジュールです)。</target>
        </trans-unit>
        <trans-unit id="d7be768e27f40f1d8f5725cc3b53d8120d8d7888" translate="yes" xml:space="preserve">
          <source>The order of the output here is non-deterministic because the two &lt;code&gt;echo&lt;/code&gt; processes are started nearly simultaneously, and race to make the first write to the &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; descriptor they share with each other and the &lt;code&gt;julia&lt;/code&gt; parent process. Julia lets you pipe the output from both of these processes to another program:</source>
          <target state="translated">2つの &lt;code&gt;echo&lt;/code&gt; プロセスがほぼ同時に開始され、お互いと &lt;code&gt;julia&lt;/code&gt; 親プロセスと共有する&lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;記述子への最初の書き込みを行うために競合するため、ここでの出力の順序は非決定的です。 Juliaでは、これらのプロセスの両方からの出力を別のプログラムにパイプすることができます。</target>
        </trans-unit>
        <trans-unit id="7e6b1ba87ceb124ce09bfd4687b3d3e543a9688a" translate="yes" xml:space="preserve">
          <source>The ordinary way to index into an &lt;code&gt;N&lt;/code&gt;-dimensional array is to use exactly &lt;code&gt;N&lt;/code&gt; indices; each index selects the position(s) in its particular dimension. For example, in the three-dimensional array &lt;code&gt;A = rand(4, 3, 2)&lt;/code&gt;, &lt;code&gt;A[2, 3, 1]&lt;/code&gt; will select the number in the second row of the third column in the first &quot;page&quot; of the array. This is often referred to as &lt;em&gt;cartesian indexing&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 次元配列にインデックスを付ける通常の方法は、正確に &lt;code&gt;N&lt;/code&gt; インデックスを使用することです。各インデックスは、特定の次元の位置を選択します。たとえば、3次元配列 &lt;code&gt;A = rand(4, 3, 2)&lt;/code&gt; では、 &lt;code&gt;A[2, 3, 1]&lt;/code&gt; 2、3、1 ]は配列の最初の「ページ」の3列目の2行目の数値を選択します。これは、しばしば&lt;em&gt;デカルトインデックス&lt;/em&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="337d87d83fb3b26581b3bec9243dd5ba69ee3d14" translate="yes" xml:space="preserve">
          <source>The overflow protection may impose a perceptible performance penalty.</source>
          <target state="translated">オーバーフロー保護は、知覚可能な性能ペナルティを課すことがあります。</target>
        </trans-unit>
        <trans-unit id="01d86a00557c452d14c3435e0e6cf89aff65b0c2" translate="yes" xml:space="preserve">
          <source>The parameters to a function call do not match a valid signature. Argument &lt;code&gt;msg&lt;/code&gt; is a descriptive error string.</source>
          <target state="translated">関数呼び出しのパラメーターが有効なシグニチャーと一致しません。引数 &lt;code&gt;msg&lt;/code&gt; は説明的なエラー文字列です。</target>
        </trans-unit>
        <trans-unit id="5cd165da81710969d9eacb18af008ac2650e61e9" translate="yes" xml:space="preserve">
          <source>The path to the file containing the execution context.</source>
          <target state="translated">実行コンテキストを含むファイルへのパス。</target>
        </trans-unit>
        <trans-unit id="cd91887e0e75258a20a4164a826e358b38427c66" translate="yes" xml:space="preserve">
          <source>The paths map assigns to each package UUID-name pair, the location of that package's entry-point source file. After the identity of &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;import X&lt;/code&gt; has been resolved to a UUID via roots or graph (depending on whether it is loaded from the main project or a dependency), Julia determines what file to load to acquire &lt;code&gt;X&lt;/code&gt; by looking up &lt;code&gt;paths[uuid,:X]&lt;/code&gt; in the environment. Including this file should define a module named &lt;code&gt;X&lt;/code&gt;. Once this package is loaded, any subsequent import resolving to the same &lt;code&gt;uuid&lt;/code&gt; will create a new binding to the already-loaded package module.</source>
          <target state="translated">パスマップは、各パッケージのUUIDと名前のペア、そのパッケージのエントリポイントソースファイルの場所に割り当てます。アイデンティティ後 &lt;code&gt;X&lt;/code&gt; に &lt;code&gt;import X&lt;/code&gt; （それがメイン・プロジェクト、または依存からロードされるかどうかに応じて）、根又はグラフを介しUUIDに解決されている、ジュリアは、取得部に負荷にどのファイルを決定する &lt;code&gt;X&lt;/code&gt; 調べることによって &lt;code&gt;paths[uuid,:X]&lt;/code&gt; 環境で。このファイルを含めると、 &lt;code&gt;X&lt;/code&gt; という名前のモジュールが定義されます。このパッケージがロードされると、同じ &lt;code&gt;uuid&lt;/code&gt; に解決される後続のインポートにより、すでにロードされているパッケージモジュールへの新しいバインディングが作成されます。</target>
        </trans-unit>
        <trans-unit id="b2b8c82c38ec794200c611dc44cc4f20a1bd32a9" translate="yes" xml:space="preserve">
          <source>The pipe operator can also be used with broadcasting, as &lt;code&gt;.|&amp;gt;&lt;/code&gt;, to provide a useful combination of the chaining/piping and dot vectorization syntax (described next).</source>
          <target state="translated">パイプ演算子を &lt;code&gt;.|&amp;gt;&lt;/code&gt; ようにブロードキャストで使用して、チェーン/パイピングとドットのベクトル化構文（次に説明）の便利な組み合わせを提供することもできます。</target>
        </trans-unit>
        <trans-unit id="597af63e387a0238ac0d63febd38bda10ccc2c0b" translate="yes" xml:space="preserve">
          <source>The power of the &lt;code&gt;try/catch&lt;/code&gt; construct lies in the ability to unwind a deeply nested computation immediately to a much higher level in the stack of calling functions. There are situations where no error has occurred, but the ability to unwind the stack and pass a value to a higher level is desirable. Julia provides the &lt;a href=&quot;../../base/base/index#Base.rethrow&quot;&gt;&lt;code&gt;rethrow&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt;&lt;code&gt;catch_backtrace&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt;&lt;code&gt;Base.catch_stack&lt;/code&gt;&lt;/a&gt; functions for more advanced error handling.</source>
          <target state="translated">&lt;code&gt;try/catch&lt;/code&gt; コンストラクトの威力は、深くネストされた計算を呼び出し関数のスタック内のはるかに高いレベルにすぐに巻き戻す機能にあります。エラーは発生していませんが、スタックを巻き戻し、値をより高いレベルに渡すことができる状況が望ましいです。ジュリアは提供して&lt;a href=&quot;../../base/base/index#Base.rethrow&quot;&gt; &lt;code&gt;rethrow&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt; &lt;code&gt;catch_backtrace&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt; &lt;code&gt;Base.catch_stack&lt;/code&gt; &lt;/a&gt;より高度なエラー処理のための機能を。</target>
        </trans-unit>
        <trans-unit id="8f828dfaf86a71af5078c4fd81a7efaae2debb74" translate="yes" xml:space="preserve">
          <source>The power of the &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; construct lies in the ability to unwind a deeply nested computation immediately to a much higher level in the stack of calling functions.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; コンストラクトの威力は、深くネストされた計算を、呼び出し関数のスタックのはるかに高いレベルに即座に巻き戻す機能にあります。</target>
        </trans-unit>
        <trans-unit id="8c0dcb26b25cdb065ec42a8e6b69fc74bd648292" translate="yes" xml:space="preserve">
          <source>The precedence of numeric literal coefficients is slightly lower than that of unary operators such as negation. So &lt;code&gt;-2x&lt;/code&gt; is parsed as &lt;code&gt;(-2) * x&lt;/code&gt; and &lt;code&gt;&amp;radic;2x&lt;/code&gt; is parsed as &lt;code&gt;(&amp;radic;2) * x&lt;/code&gt;. However, numeric literal coefficients parse similarly to unary operators when combined with exponentiation. For example &lt;code&gt;2^3x&lt;/code&gt; is parsed as &lt;code&gt;2^(3x)&lt;/code&gt;, and &lt;code&gt;2x^3&lt;/code&gt; is parsed as &lt;code&gt;2*(x^3)&lt;/code&gt;.</source>
          <target state="translated">数値リテラル係数の優先順位は、否定などの単項演算子の優先順位よりわずかに低くなっています。したがって、 &lt;code&gt;-2x&lt;/code&gt; は &lt;code&gt;(-2) * x&lt;/code&gt; として解析され、 &lt;code&gt;&amp;radic;2x&lt;/code&gt; は &lt;code&gt;(&amp;radic;2) * x&lt;/code&gt; として解析されます。ただし、数値リテラル係数は、指数と組み合わせると、単項演算子と同様に解析されます。たとえば、 &lt;code&gt;2^3x&lt;/code&gt; は &lt;code&gt;2^(3x)&lt;/code&gt; として解析され、 &lt;code&gt;2x^3&lt;/code&gt; は &lt;code&gt;2*(x^3)&lt;/code&gt; として解析されます。</target>
        </trans-unit>
        <trans-unit id="8950edc0252b4e5921bc89b4f858ec39c03063d6" translate="yes" xml:space="preserve">
          <source>The precedence of numeric literal coefficients used for implicit multiplication is higher than other binary operators such as multiplication (&lt;code&gt;*&lt;/code&gt;), and division (&lt;code&gt;/&lt;/code&gt;, &lt;code&gt;\&lt;/code&gt;, and &lt;code&gt;//&lt;/code&gt;). This means, for example, that &lt;code&gt;1 / 2im&lt;/code&gt; equals &lt;code&gt;-0.5im&lt;/code&gt; and &lt;code&gt;6 // 2(2 + 1)&lt;/code&gt; equals &lt;code&gt;1 // 1&lt;/code&gt;.</source>
          <target state="translated">暗黙的な乗算に使用される数値リテラル係数の優先順位は、乗算（ &lt;code&gt;*&lt;/code&gt; ）や除算（ &lt;code&gt;/&lt;/code&gt; 、 &lt;code&gt;\&lt;/code&gt; 、 &lt;code&gt;//&lt;/code&gt; ）などの他の2項演算子よりも高くなっています。これは、たとえば、 &lt;code&gt;1 / 2im&lt;/code&gt; が &lt;code&gt;-0.5im&lt;/code&gt; に等しく、 &lt;code&gt;6 // 2(2 + 1)&lt;/code&gt; が &lt;code&gt;1 // 1&lt;/code&gt; 等しいことを意味します。</target>
        </trans-unit>
        <trans-unit id="6252a13083e6a8d33233a629a05884040274a8ff" translate="yes" xml:space="preserve">
          <source>The precedence rules are defined by binary &lt;code&gt;BroadcastStyle&lt;/code&gt; calls:</source>
          <target state="translated">優先ルールは、 &lt;code&gt;BroadcastStyle&lt;/code&gt; のバイナリ呼び出しによって定義されます。</target>
        </trans-unit>
        <trans-unit id="56837dd60f637c33dd3845553e8ea84690fc189a" translate="yes" xml:space="preserve">
          <source>The preferred style is to use instances by default, and only add methods involving &lt;code&gt;Type{MyType}&lt;/code&gt; later if they become necessary to solve some problem.</source>
          <target state="translated">推奨されるスタイルは、デフォルトでインスタンスを使用することであり、何らかの問題を解決するために必要になった場合にのみ &lt;code&gt;Type{MyType}&lt;/code&gt; に関連するメソッドを後で追加することです。</target>
        </trans-unit>
        <trans-unit id="279b514949e6ab10ca4a0b3d36a0afc9aa5e5bfd" translate="yes" xml:space="preserve">
          <source>The prefix operator &lt;code&gt;∛&lt;/code&gt; is equivalent to &lt;code&gt;cbrt&lt;/code&gt;.</source>
          <target state="translated">プレフィックス演算子は &lt;code&gt;∛&lt;/code&gt; と同等 &lt;code&gt;cbrt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93ebef4458176844838b02e2b993df5f493f0829" translate="yes" xml:space="preserve">
          <source>The primary function used to obtain a stack trace is &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">スタックトレースを取得するために使用される主な関数は、&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="e24543b8a6898ccaa9bbcf1e800fb858e73daf75" translate="yes" xml:space="preserve">
          <source>The primary use for anonymous functions is passing them to functions which take other functions as arguments. A classic example is &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, which applies a function to each value of an array and returns a new array containing the resulting values:</source>
          <target state="translated">無名関数の主な用途は、他の関数を引数として取る関数に渡すことです。典型的な例は&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;で、配列の各値に関数を適用し、結果の値を含む新しい配列を返します。</target>
        </trans-unit>
        <trans-unit id="fc2c54892fd31e8ed27deff8fd6635a872466a56" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;Priv&lt;/code&gt; depends on the &lt;code&gt;Pub&lt;/code&gt; and &lt;code&gt;Zebra&lt;/code&gt; packages.</source>
          <target state="translated">プライベート &lt;code&gt;Priv&lt;/code&gt; は、 &lt;code&gt;Pub&lt;/code&gt; および &lt;code&gt;Zebra&lt;/code&gt; パッケージに依存しています。</target>
        </trans-unit>
        <trans-unit id="8f74ae0037646d4d3ed052aa7f6f3acf520af197" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;Priv&lt;/code&gt; package is &quot;&lt;a href=&quot;https://stackoverflow.com/a/35109534&quot;&gt;vendored&lt;/a&gt;&quot; inside the &lt;code&gt;App&lt;/code&gt; repository.</source>
          <target state="translated">プライベート &lt;code&gt;Priv&lt;/code&gt; パッケージは、 &lt;code&gt;App&lt;/code&gt; リポジトリ内に「&lt;a href=&quot;https://stackoverflow.com/a/35109534&quot;&gt;ベンダー&lt;/a&gt;」されています。</target>
        </trans-unit>
        <trans-unit id="661f073fc5da6760e6d7e4ab5f75f9c8ff27e153" translate="yes" xml:space="preserve">
          <source>The problem is that now any other module that uses &lt;code&gt;Base.*&lt;/code&gt; will also see this definition. Since &lt;code&gt;Symbol&lt;/code&gt; is defined in Base and is used by other modules, this can change the behavior of unrelated code unexpectedly. There are several alternatives here, including using a different function name, or wrapping the &lt;code&gt;Symbol&lt;/code&gt;s in another type that you define.</source>
          <target state="translated">問題は、 &lt;code&gt;Base.*&lt;/code&gt; を使用する他のすべてのモジュールにもこの定義が表示されることです。以来 &lt;code&gt;Symbol&lt;/code&gt; ベースで定義され、他のモジュールによって使用され、これは予想外の無関係なコードの挙動を変更することができます。ここには、別の関数名を使用したり、定義した別のタイプで &lt;code&gt;Symbol&lt;/code&gt; をラップしたりするなど、いくつかの選択肢があります。</target>
        </trans-unit>
        <trans-unit id="285d72365829e919fd96051079cd8653575f8845" translate="yes" xml:space="preserve">
          <source>The problem is that users of this type can write &lt;code&gt;x[i]&lt;/code&gt; without realizing that the operation is unsafe, and then be susceptible to memory bugs.</source>
          <target state="translated">問題は、このタイプのユーザーは、操作が安全でないことを認識せずに &lt;code&gt;x[i]&lt;/code&gt; を記述でき、メモリバグの影響を受けやすくなることです。</target>
        </trans-unit>
        <trans-unit id="645c5293b137aedcba8417381b97d9b765e077f5" translate="yes" xml:space="preserve">
          <source>The problem is that we want &lt;code&gt;S&lt;/code&gt; to be a larger type than &lt;code&gt;T&lt;/code&gt;, so that we can sum many elements with less information loss. For example, when &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;, we would like &lt;code&gt;S&lt;/code&gt; to be &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;. Therefore we want to avoid an interface that allows the user to construct instances of the type &lt;code&gt;SummedArray{Int32,Int32}&lt;/code&gt;. One way to do this is to provide a constructor only for &lt;code&gt;SummedArray&lt;/code&gt;, but inside the &lt;code&gt;struct&lt;/code&gt; definition block to suppress generation of default constructors:</source>
          <target state="translated">問題は、 &lt;code&gt;S&lt;/code&gt; を &lt;code&gt;T&lt;/code&gt; よりも大きな型にして、多くの要素を合計して情報の損失を少なくできるようにすることです。たとえば、 &lt;code&gt;T&lt;/code&gt; が&lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; の&lt;/a&gt;場合、 &lt;code&gt;S&lt;/code&gt; を&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; に&lt;/a&gt;する必要があります。したがって、ユーザーが &lt;code&gt;SummedArray{Int32,Int32}&lt;/code&gt; 型のインスタンスを作成できるインターフェイスを避けたいと考えています。これを行う1つの方法は、 &lt;code&gt;SummedArray&lt;/code&gt; に対してのみコンストラクターを提供することですが、 &lt;code&gt;struct&lt;/code&gt; 定義ブロック内でデフォルトコンストラクターの生成を抑制します。</target>
        </trans-unit>
        <trans-unit id="fa9c416e3dd0eb96ee39260398af255d4af83ab0" translate="yes" xml:space="preserve">
          <source>The process id, &lt;code&gt;pid&lt;/code&gt;, associated with a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; identifies the process where the backing store, i.e., the backing &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; exists.</source>
          <target state="translated">&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt;に関連付けられたプロセスID &lt;code&gt;pid&lt;/code&gt; は、バッキングストア、つまりバッキング&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;が存在するプロセスを識別します。</target>
        </trans-unit>
        <trans-unit id="e5711338a1a6b237dd10b96c18908bc64ecaf369" translate="yes" xml:space="preserve">
          <source>The process was stopped by a terminal interrupt (CTRL+C).</source>
          <target state="translated">ターミナル割り込み(CTRL+C)で処理が停止しました。</target>
        </trans-unit>
        <trans-unit id="333bddf0932a24c46f8668b521deb6c3a862550f" translate="yes" xml:space="preserve">
          <source>The program name and the individual arguments in a command can be accessed and iterated over as if the command were an array of strings:</source>
          <target state="translated">プログラム名とコマンド内の個々の引数にアクセスして、あたかもコマンドが文字列の配列であるかのように反復処理することができます。</target>
        </trans-unit>
        <trans-unit id="50007e3abed58b9e198eabc930fa126c0f7f28e5" translate="yes" xml:space="preserve">
          <source>The promotion mechanism ensures that combinations of operands of different types just work:</source>
          <target state="translated">昇進のメカニズムは、異なるタイプのオペランドの組み合わせが機能することを保証します。</target>
        </trans-unit>
        <trans-unit id="970007866f1b490fa6101a3c913eb7623d70c629" translate="yes" xml:space="preserve">
          <source>The protection mode of the file</source>
          <target state="translated">ファイルの保護モード</target>
        </trans-unit>
        <trans-unit id="717c22bfef5d2282d64a55d9c60b43bea19c9cf1" translate="yes" xml:space="preserve">
          <source>The public &lt;code&gt;Priv&lt;/code&gt; and &lt;code&gt;Zebra&lt;/code&gt; packages are in the system depot, where packages installed and managed by the system administrator live. These are available to all users on the system.</source>
          <target state="translated">パブリック &lt;code&gt;Priv&lt;/code&gt; および &lt;code&gt;Zebra&lt;/code&gt; パッケージはシステムデポにあり、システム管理者がインストールおよび管理するパッケージがそこにあります。これらは、システム上のすべてのユーザーが使用できます。</target>
        </trans-unit>
        <trans-unit id="1a1630b90939dc1ab04b673570b84792ee8ae787" translate="yes" xml:space="preserve">
          <source>The public &lt;code&gt;Priv&lt;/code&gt; has no dependencies.</source>
          <target state="translated">public &lt;code&gt;Priv&lt;/code&gt; には依存関係はありません。</target>
        </trans-unit>
        <trans-unit id="3a76e9ce5367492b5b8cf13bb66130558721cade" translate="yes" xml:space="preserve">
          <source>The quotient and remainder from Euclidean division. Equivalent to &lt;code&gt;(div(x,y), rem(x,y))&lt;/code&gt; or &lt;code&gt;(x&amp;divide;y, x%y)&lt;/code&gt;.</source>
          <target state="translated">ユークリッド除算の商と剰余。 &lt;code&gt;(div(x,y), rem(x,y))&lt;/code&gt; または &lt;code&gt;(x&amp;divide;y, x%y)&lt;/code&gt; 同等です。</target>
        </trans-unit>
        <trans-unit id="c852eff7359c80d607981a449403f86f7a08aae5" translate="yes" xml:space="preserve">
          <source>The quotient from Euclidean division. Computes &lt;code&gt;x/y&lt;/code&gt;, truncated to an integer.</source>
          <target state="translated">ユークリッド除算の商。整数に切り捨てられた &lt;code&gt;x/y&lt;/code&gt; を計算します。</target>
        </trans-unit>
        <trans-unit id="b4ff83a45750ab4a00521d3b0c9044c246c68431" translate="yes" xml:space="preserve">
          <source>The rationale for this behavior is that &lt;code&gt;eps&lt;/code&gt; bounds the floating point rounding error. Under the default &lt;code&gt;RoundNearest&lt;/code&gt; rounding mode, if $y$ is a real number and $x$ is the nearest floating point number to $y$, then</source>
          <target state="translated">この動作の理論的根拠は、 &lt;code&gt;eps&lt;/code&gt; が浮動小数点の丸め誤差を制限することです。デフォルトの &lt;code&gt;RoundNearest&lt;/code&gt; 丸めモードでは、$ y $が実数で、$ x $が$ y $に最も近い浮動小数点数の場合、</target>
        </trans-unit>
        <trans-unit id="fb9190d6f027ae9e2de06d7e334ba64d5fd44e85" translate="yes" xml:space="preserve">
          <source>The reason this is important enough to have been given separate syntax is that you don't want to accidentally extend a function that you didn't know existed, because that could easily cause a bug. This is most likely to happen with a method that takes a common type like a string or integer, because both you and the other module could define a method to handle such a common type. If you use &lt;code&gt;import&lt;/code&gt;, then you'll replace the other module's implementation of &lt;code&gt;bar(s::AbstractString)&lt;/code&gt; with your new implementation, which could easily do something completely different (and break all/many future usages of the other functions in module Foo that depend on calling bar).</source>
          <target state="translated">これが個別の構文を指定するのに十分重要である理由は、簡単にバグが発生する可能性があるため、存在していない関数を誤って拡張しないようにするためです。これは、文字列や整数などの共通の型を取るメソッドで発生する可能性が最も高いです。これは、ユーザーと他のモジュールの両方がそのような共通の型を処理するメソッドを定義できるためです。 &lt;code&gt;import&lt;/code&gt; を使用する場合、他のモジュールの &lt;code&gt;bar(s::AbstractString)&lt;/code&gt; の実装を新しい実装に置き換えます。これにより、完全に異なる何かを簡単に実行できます（そして、モジュールFooの他の関数のすべての/多くの将来の使用法を壊します）呼び出しバーに依存します）。</target>
        </trans-unit>
        <trans-unit id="234a82c9299a864e20ceee7dc728fbbfc62b4ff9" translate="yes" xml:space="preserve">
          <source>The reason to allow modifying local variables of parent scopes in nested functions is to allow constructing &lt;a href=&quot;https://en.wikipedia.org/wiki/Closure_%28computer_programming%29&quot;&gt;&lt;code&gt;closures&lt;/code&gt;&lt;/a&gt; which have private state, for instance the &lt;code&gt;state&lt;/code&gt; variable in the following example:</source>
          <target state="translated">ネストされた関数で親スコープのローカル変数を変更できるようにする理由は、プライベートな状態を持つ&lt;a href=&quot;https://en.wikipedia.org/wiki/Closure_%28computer_programming%29&quot;&gt; &lt;code&gt;closures&lt;/code&gt; &lt;/a&gt;を構築できるようにするためです（たとえば、次の例の &lt;code&gt;state&lt;/code&gt; 変数）。</target>
        </trans-unit>
        <trans-unit id="d42e24ea3d0e2aa6d81b7dd3b153611807fc05f4" translate="yes" xml:space="preserve">
          <source>The reasoning is that &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; must be &lt;code&gt;false&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, regardless of the value of &lt;code&gt;b&lt;/code&gt;, and likewise, the value of &lt;code&gt;a || b&lt;/code&gt; must be true if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, regardless of the value of &lt;code&gt;b&lt;/code&gt;. Both &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; associate to the right, but &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; has higher precedence than &lt;code&gt;||&lt;/code&gt; does. It's easy to experiment with this behavior:</source>
          <target state="translated">推論は、ということです &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; なければなりません &lt;code&gt;false&lt;/code&gt; 場合で &lt;code&gt;false&lt;/code&gt; の値に関係なく、 &lt;code&gt;b&lt;/code&gt; の値が、同様に &lt;code&gt;a || b&lt;/code&gt; あれば真でなければならないで &lt;code&gt;true&lt;/code&gt; の値に関係なく、 &lt;code&gt;b&lt;/code&gt; 。 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; と &lt;code&gt;||&lt;/code&gt; の両方右に関連付けますが、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; は &lt;code&gt;||&lt;/code&gt; よりも優先されますします。この動作を試すのは簡単です： &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="179e487486d1af4b87de97016bef8d4656b4ec67" translate="yes" xml:space="preserve">
          <source>The recommended ways to iterate over a whole array are</source>
          <target state="translated">配列全体を反復処理するための推奨される方法は</target>
        </trans-unit>
        <trans-unit id="d82c055defbd84ff03cc2e56fef7d08819740213" translate="yes" xml:space="preserve">
          <source>The reduction of &lt;code&gt;x&lt;/code&gt; modulo &lt;code&gt;y&lt;/code&gt;, or equivalently, the remainder of &lt;code&gt;x&lt;/code&gt; after floored division by &lt;code&gt;y&lt;/code&gt;, i.e. &lt;code&gt;x - y*fld(x,y)&lt;/code&gt; if computed without intermediate rounding.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; を法とする &lt;code&gt;x&lt;/code&gt; の削減、または同等に、 &lt;code&gt;y&lt;/code&gt; による床除算後の &lt;code&gt;x&lt;/code&gt; の剰余、つまり中間丸めなしで計算された場合は &lt;code&gt;x - y*fld(x,y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7a083bb1a1b10ec23125171dedac6f03596ea4e" translate="yes" xml:space="preserve">
          <source>The relation defined by &lt;code&gt;isless&lt;/code&gt; is transitive, i.e., &lt;code&gt;isless(x, y) &amp;amp;&amp;amp; isless(y, z)&lt;/code&gt; implies &lt;code&gt;isless(x, z)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isless&lt;/code&gt; によって定義される関係は推移的です。つまり、 &lt;code&gt;isless(x, y) &amp;amp;&amp;amp; isless(y, z)&lt;/code&gt; &lt;code&gt;isless(x, z)&lt;/code&gt; 意味します。</target>
        </trans-unit>
        <trans-unit id="ae50d1ec149a5bb325ee3ed684413be8beb00545" translate="yes" xml:space="preserve">
          <source>The relationship between &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;F&lt;/code&gt; と &lt;code&gt;A&lt;/code&gt; の関係は</target>
        </trans-unit>
        <trans-unit id="f134ecdeee3cfa777ccd458bfed97ec72082e75e" translate="yes" xml:space="preserve">
          <source>The remote cache is maintained for the lifetime of the returned &lt;code&gt;CachingPool&lt;/code&gt; object. To clear the cache earlier, use &lt;code&gt;clear!(pool)&lt;/code&gt;.</source>
          <target state="translated">リモートキャッシュは、返された &lt;code&gt;CachingPool&lt;/code&gt; オブジェクトの存続期間中維持されます。以前にキャッシュをクリアするには、 &lt;code&gt;clear!(pool)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="df901bb294129f7627dac22ff5e80e400643c39f" translate="yes" xml:space="preserve">
          <source>The required keyword argument &lt;code&gt;var&lt;/code&gt; was not assigned in a function call.</source>
          <target state="translated">必須のキーワード引数 &lt;code&gt;var&lt;/code&gt; が関数呼び出しで割り当てられていません。</target>
        </trans-unit>
        <trans-unit id="a9f7acaee551d1164b11cacdb547b0da33902de6" translate="yes" xml:space="preserve">
          <source>The result is a pointer giving the address of the value. The value can be manipulated through this pointer using &lt;a href=&quot;../../base/c/index#Base.unsafe_load&quot;&gt;&lt;code&gt;unsafe_load&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt;&lt;code&gt;unsafe_store!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">結果は、値のアドレスを示すポインターです。この値は、&lt;a href=&quot;../../base/c/index#Base.unsafe_load&quot;&gt; &lt;code&gt;unsafe_load&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt; &lt;code&gt;unsafe_store!&lt;/code&gt; &lt;/a&gt;を使用して、このポインターを介して操作できます。。</target>
        </trans-unit>
        <trans-unit id="03cc3e3ef7a55f891b2fdc37e1dca5251bee7ee1" translate="yes" xml:space="preserve">
          <source>The result is of type &lt;code&gt;Bool&lt;/code&gt;, except when one of the operands is &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt;, in which case &lt;code&gt;missing&lt;/code&gt; is returned (&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;). For collections, &lt;code&gt;missing&lt;/code&gt; is returned if at least one of the operands contains a &lt;code&gt;missing&lt;/code&gt; value and all non-missing values are equal. Use &lt;a href=&quot;../base/index#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt; to always get a &lt;code&gt;Bool&lt;/code&gt; result.</source>
          <target state="translated">結果は &lt;code&gt;Bool&lt;/code&gt; 型ですが、オペランドの1つが&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;している場合を除きます。この場合、 &lt;code&gt;missing&lt;/code&gt; が返されます（&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;3値論理&lt;/a&gt;）。コレクションの場合、少なくとも1つのオペランドに &lt;code&gt;missing&lt;/code&gt; 値が含まれ、すべての欠損値が等しい場合、 &lt;code&gt;missing&lt;/code&gt; が返されます。&lt;a href=&quot;../base/index#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt;を使用して、常に &lt;code&gt;Bool&lt;/code&gt; 結果を取得します。</target>
        </trans-unit>
        <trans-unit id="c007650ed1d2ab98bda9d8f6e9d2a6696a562053" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;n&lt;/code&gt; iterative applications of &lt;code&gt;nextfloat&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, or &lt;code&gt;-n&lt;/code&gt; applications of &lt;code&gt;prevfloat&lt;/code&gt; if &lt;code&gt;n &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n &amp;gt;= 0&lt;/code&gt; 場合、 &lt;code&gt;nextfloat&lt;/code&gt; を &lt;code&gt;x&lt;/code&gt; に &lt;code&gt;n&lt;/code&gt; 回繰り返し適用した結果、または &lt;code&gt;n &amp;lt; 0&lt;/code&gt; 場合、 &lt;code&gt;prevfloat&lt;/code&gt; を &lt;code&gt;-n&lt;/code&gt; 回適用した結果。</target>
        </trans-unit>
        <trans-unit id="94b46c3b276e64ea98bedcc1b3f79ab9ebee8c1f" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;n&lt;/code&gt; iterative applications of &lt;code&gt;prevfloat&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, or &lt;code&gt;-n&lt;/code&gt; applications of &lt;code&gt;nextfloat&lt;/code&gt; if &lt;code&gt;n &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n &amp;gt;= 0&lt;/code&gt; 場合、 &lt;code&gt;prevfloat&lt;/code&gt; を &lt;code&gt;x&lt;/code&gt; に &lt;code&gt;n&lt;/code&gt; 回繰り返し適用した結果、または &lt;code&gt;n &amp;lt; 0&lt;/code&gt; 場合、 &lt;code&gt;nextfloat&lt;/code&gt; を &lt;code&gt;-n&lt;/code&gt; 回適用した結果。</target>
        </trans-unit>
        <trans-unit id="3b9604e81f6338ca5014cd5645d78240588116b2" translate="yes" xml:space="preserve">
          <source>The result of an expression is too large for the specified type and will cause a wraparound.</source>
          <target state="translated">式の結果が指定された型に対して大きすぎるため、回り込みが発生します。</target>
        </trans-unit>
        <trans-unit id="5e37838dee3788d25d7398516d199b796b585b2f" translate="yes" xml:space="preserve">
          <source>The result of indexing an &lt;code&gt;AbstractArray&lt;/code&gt; can itself be an array (for instance when indexing by an &lt;code&gt;AbstractRange&lt;/code&gt;). The &lt;code&gt;AbstractArray&lt;/code&gt; fallback methods use &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; to allocate an &lt;code&gt;Array&lt;/code&gt; of the appropriate size and element type, which is filled in using the basic indexing method described above. However, when implementing an array wrapper you often want the result to be wrapped as well:</source>
          <target state="translated">&lt;code&gt;AbstractArray&lt;/code&gt; のインデックス付けの結果は、それ自体が配列になる場合があります（たとえば、 &lt;code&gt;AbstractRange&lt;/code&gt; によるインデックス付けの場合）。 &lt;code&gt;AbstractArray&lt;/code&gt; 代替方法が使用&lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt;割り当てる &lt;code&gt;Array&lt;/code&gt; の基本的なインデクシング方法は、上述した使用に充填され、適切な大きさと要素タイプのを。ただし、配列ラッパーを実装する場合は、結果もラップする必要があることがよくあります。</target>
        </trans-unit>
        <trans-unit id="9dddd93bc0d8f1d83b952a56d60f4d4d4dde4922" translate="yes" xml:space="preserve">
          <source>The result will have the same sign as &lt;code&gt;y&lt;/code&gt;, and magnitude less than &lt;code&gt;abs(y)&lt;/code&gt; (with some exceptions, see note below).</source>
          <target state="translated">結果は &lt;code&gt;y&lt;/code&gt; と同じ符号を持ち、 &lt;code&gt;abs(y)&lt;/code&gt; 値はabs（y）未満になります（いくつかの例外はありますが、以下の注を参照してください）。</target>
        </trans-unit>
        <trans-unit id="f568e8a5a2b842636c272653d157a8edcd885b90" translate="yes" xml:space="preserve">
          <source>The resulting array type depends on the types of the computed elements. In order to control the type explicitly, a type can be prepended to the comprehension. For example, we could have requested the result in single precision by writing:</source>
          <target state="translated">結果として得られる配列の型は,計算された要素の型に依存します.明示的に型を制御するために,内包文の前に型を追加することができます.例えば,単精度での結果を要求するには,次のように記述します.</target>
        </trans-unit>
        <trans-unit id="ccd36a28a2ffb3965813bdc3900b2e91091344fd" translate="yes" xml:space="preserve">
          <source>The resulting container type is established by the following rules:</source>
          <target state="translated">結果として得られるコンテナタイプは、以下のルールによって確立されます。</target>
        </trans-unit>
        <trans-unit id="1fe1a92416b8011a58e509306cdd809a4d7403bb" translate="yes" xml:space="preserve">
          <source>The results are identical, and Julia's interpolation behavior mimics the shell's with some improvements due to the fact that Julia supports first-class iterable objects while most shells use strings split on spaces for this, which introduces ambiguities. When trying to port shell commands to Julia, try cut and pasting first. Since Julia shows commands to you before running them, you can easily and safely just examine its interpretation without doing any damage.</source>
          <target state="translated">結果は同じで、Julia の補間動作はシェルのものを真似していますが、Julia はファーストクラスの反復可能なオブジェクトをサポートしていますが、ほとんどのシェルはスペースで分割された文字列を使用しているため、曖昧さが生じます。シェルコマンドをJuliaに移植しようとするときは、まずカットアンドペーストを試してみてください。Julia はコマンドを実行する前にコマンドを見せてくれるので、ダメージを与えることなく、簡単かつ安全にコマンドの解釈を調べることができます。</target>
        </trans-unit>
        <trans-unit id="0e9c7956c24febdcf914d416fae3a917b2f39e3e" translate="yes" xml:space="preserve">
          <source>The return type is &lt;code&gt;Int&lt;/code&gt; for signed integers of less than system word size, and &lt;code&gt;UInt&lt;/code&gt; for unsigned integers of less than system word size. For all other arguments, a common return type is found to which all arguments are promoted.</source>
          <target state="translated">戻り値の型は、システムワードサイズ未満の符号付き整数の場合は &lt;code&gt;Int&lt;/code&gt; 、システムワードサイズ未満の符号なし整数の場合は &lt;code&gt;UInt&lt;/code&gt; です。他のすべての引数については、すべての引数がプロモートされる共通の戻り型が見つかります。</target>
        </trans-unit>
        <trans-unit id="2bdd15fbc5eeeea487e741f6815e78f1d57eeca2" translate="yes" xml:space="preserve">
          <source>The return value is a range of indices where the matching sequence is found, such that &lt;code&gt;s[findnext(x, s, i)] == x&lt;/code&gt;:</source>
          <target state="translated">戻り値は、 &lt;code&gt;s[findnext(x, s, i)] == x&lt;/code&gt; ように、一致するシーケンスが見つかったインデックスの範囲です。</target>
        </trans-unit>
        <trans-unit id="296596adaa4e2ffb872d464b197ffa89509d78f4" translate="yes" xml:space="preserve">
          <source>The return value is a range of indices where the matching sequence is found, such that &lt;code&gt;s[findprev(x, s, i)] == x&lt;/code&gt;:</source>
          <target state="translated">戻り値は、 &lt;code&gt;s[findprev(x, s, i)] == x&lt;/code&gt; ような、一致するシーケンスが見つかったインデックスの範囲です。</target>
        </trans-unit>
        <trans-unit id="9c4a1e6fb47e3491c23ed68634d665b86e2b1224" translate="yes" xml:space="preserve">
          <source>The return value will be a new object initialized to contain a copy of the contents of the referenced memory. The referenced memory can safely be freed or released.</source>
          <target state="translated">戻り値は、参照されるメモリの内容のコピーを含むように初期化された新しいオブジェクトになります。参照されたメモリは安全に解放または解放することができます。</target>
        </trans-unit>
        <trans-unit id="995e85d8c74168d9b1cb80ff9be361035188ad05" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; can be used as an iterable object in a &lt;code&gt;for&lt;/code&gt; loop, in which case the loop variable takes on all the produced values. The loop is terminated when the channel is closed.</source>
          <target state="translated">返された&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;は、 &lt;code&gt;for&lt;/code&gt; ループで反復可能なオブジェクトとして使用できます。その場合、ループ変数は生成されたすべての値を受け取ります。ループは、チャネルが閉じられると終了します。</target>
        </trans-unit>
        <trans-unit id="4905fa2086f7e7025e1f1fb3e602f0309c36c38d" translate="yes" xml:space="preserve">
          <source>The returned function is of type &lt;code&gt;Base.Fix2{typeof(==)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">返される関数は &lt;code&gt;Base.Fix2{typeof(==)}&lt;/code&gt; であり、特殊なメソッドを実装するために使用できます。</target>
        </trans-unit>
        <trans-unit id="76989de74c6183b202bef17365490bd9a3d31c70" translate="yes" xml:space="preserve">
          <source>The returned function is of type &lt;code&gt;Base.Fix2{typeof(isequal)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">返される関数は &lt;code&gt;Base.Fix2{typeof(isequal)}&lt;/code&gt; であり、特殊なメソッドを実装するために使用できます。</target>
        </trans-unit>
        <trans-unit id="f5913ac9f9933573cc3f45ba086fb826464beb36" translate="yes" xml:space="preserve">
          <source>The returned object &lt;code&gt;F&lt;/code&gt; stores the factorization in a packed format:</source>
          <target state="translated">返されたオブジェクト &lt;code&gt;F&lt;/code&gt; は、分解をパック形式で格納します。</target>
        </trans-unit>
        <trans-unit id="5b6b30b85a24f3b9aaa6b8733a6c0289157aac3b" translate="yes" xml:space="preserve">
          <source>The returned tuple must only contain either &lt;code&gt;Int&lt;/code&gt;s or &lt;code&gt;AbstractArray&lt;/code&gt;s of scalar indices that are supported by array &lt;code&gt;A&lt;/code&gt;. It will error upon encountering a novel index type that it does not know how to process.</source>
          <target state="translated">返されるタプルには、配列 &lt;code&gt;A&lt;/code&gt; でサポートされるスカラーインデックスの &lt;code&gt;Int&lt;/code&gt; または &lt;code&gt;AbstractArray&lt;/code&gt; のいずれかのみを含める必要があります。処理方法がわからない新規のインデックスタイプに遭遇するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="d9c1e00640a368c30e904f9290ae3dcb10bd1ec3" translate="yes" xml:space="preserve">
          <source>The returned value is an object with boolean fields &lt;code&gt;changed&lt;/code&gt;, &lt;code&gt;renamed&lt;/code&gt;, and &lt;code&gt;timedout&lt;/code&gt;, giving the result of watching the file.</source>
          <target state="translated">返される値は、ブールフィールドを持つオブジェクトで &lt;code&gt;changed&lt;/code&gt; 、 &lt;code&gt;renamed&lt;/code&gt; 、および &lt;code&gt;timedout&lt;/code&gt; ファイルを見ての結果を与え、。</target>
        </trans-unit>
        <trans-unit id="0aae9d904638273f671fc4e418a0190f5b8a389f" translate="yes" xml:space="preserve">
          <source>The returned value is an object with boolean fields &lt;code&gt;readable&lt;/code&gt;, &lt;code&gt;writable&lt;/code&gt;, and &lt;code&gt;timedout&lt;/code&gt;, giving the result of the polling.</source>
          <target state="translated">返される値は、ブールフィールドを持つオブジェクトで &lt;code&gt;readable&lt;/code&gt; 、 &lt;code&gt;writable&lt;/code&gt; 、と &lt;code&gt;timedout&lt;/code&gt; ポーリングの結果を与え、。</target>
        </trans-unit>
        <trans-unit id="49b2889cf141c81986b5559befd286291492017c" translate="yes" xml:space="preserve">
          <source>The returned value is an pair where the first field is the name of the changed file (if available) and the second field is an object with boolean fields &lt;code&gt;changed&lt;/code&gt;, &lt;code&gt;renamed&lt;/code&gt;, and &lt;code&gt;timedout&lt;/code&gt;, giving the event.</source>
          <target state="translated">返される値は、最初のフィールドが変更されたファイルの名前である（可能な場合）および第2のフィールドは、ブールフィールドを持つオブジェクトであるペアで &lt;code&gt;changed&lt;/code&gt; 、 &lt;code&gt;renamed&lt;/code&gt; 、及び &lt;code&gt;timedout&lt;/code&gt; イベントを与えます。</target>
        </trans-unit>
        <trans-unit id="8636f9ac58bcf28e3d16135d951b8ff3e218cbd7" translate="yes" xml:space="preserve">
          <source>The reverse operation (writing data to a &lt;code&gt;Ptr{T}&lt;/code&gt;), can be performed using &lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt;&lt;code&gt;unsafe_store!(ptr, value, [index])&lt;/code&gt;&lt;/a&gt;. Currently, this is only supported for primitive types or other pointer-free (&lt;code&gt;isbits&lt;/code&gt;) immutable struct types.</source>
          <target state="translated">逆の操作（ &lt;code&gt;Ptr{T}&lt;/code&gt; へのデータの書き込み）は、&lt;a href=&quot;../../base/c/index#Base.unsafe_store!&quot;&gt; &lt;code&gt;unsafe_store!(ptr, value, [index])&lt;/code&gt; &lt;/a&gt;を使用して実行できます。現在、これはプリミティブ型または他のポインターフリー（ &lt;code&gt;isbits&lt;/code&gt; ）不変構造体型でのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="b7d58ee9a7a86e6aad0f59e6f9ed658c820e2192" translate="yes" xml:space="preserve">
          <source>The roots, graph and paths maps of a project environment are defined as follows:</source>
          <target state="translated">プロジェクト環境のルートマップ、グラフマップ、パスマップは以下のように定義されています。</target>
        </trans-unit>
        <trans-unit id="8db1c63f81410ece76ca99d9ff0064394f7701c3" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt;, but saves space by overwriting the input &lt;code&gt;A&lt;/code&gt;, instead of creating a copy. An &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; exception is thrown if the factorization produces a number not representable by the element type of &lt;code&gt;A&lt;/code&gt;, e.g. for integer types.</source>
          <target state="translated">&lt;a href=&quot;#LinearAlgebra.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; &lt;/a&gt;と同じですが、コピーを作成する代わりに入力 &lt;code&gt;A&lt;/code&gt; を上書きすることでスペースを節約します。アン&lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; の&lt;/a&gt;因数分解は、の要素の型によって表現できない数生成する場合は、例外がスローされた &lt;code&gt;A&lt;/code&gt; 整数型用などを、。</target>
        </trans-unit>
        <trans-unit id="7ac8db3a8fce7e45f1c23cbd8542a5bd84c64ad8" translate="yes" xml:space="preserve">
          <source>The same best practices also work for container types:</source>
          <target state="translated">同じベストプラクティスは、コンテナタイプでも機能します。</target>
        </trans-unit>
        <trans-unit id="7644c0d871ce59114cf83dbd0542336b1d1077e8" translate="yes" xml:space="preserve">
          <source>The same thing can be done using recursion:</source>
          <target state="translated">再帰を使っても同じことができます。</target>
        </trans-unit>
        <trans-unit id="499f37304cc2bf38bfc1e123fdaa79c60bea1de4" translate="yes" xml:space="preserve">
          <source>The script &lt;code&gt;julia-config.jl&lt;/code&gt; was created to aid in determining what build parameters are required by a program that uses embedded Julia. This script uses the build parameters and system configuration of the particular Julia distribution it is invoked by to export the necessary compiler flags for an embedding program to interact with that distribution. This script is located in the Julia shared data directory.</source>
          <target state="translated">スクリプト &lt;code&gt;julia-config.jl&lt;/code&gt; は、埋め込まれたJuliaを使用するプログラムに必要なビルドパラメーターの決定を支援するために作成されました。このスクリプトは、それが呼び出された特定のJuliaディストリビューションのビルドパラメーターとシステム構成を使用して、埋め込みプログラムがそのディストリビューションと対話するために必要なコンパイラフラグをエクスポートします。このスクリプトは、Julia共有データディレクトリにあります。</target>
        </trans-unit>
        <trans-unit id="6f8fe32c72b2738c988d9f8c4881f931f1ba36f2" translate="yes" xml:space="preserve">
          <source>The second argument &lt;code&gt;p&lt;/code&gt; is not necessarily a part of the interface for &lt;code&gt;norm&lt;/code&gt;, i.e. a custom type may only implement &lt;code&gt;norm(A)&lt;/code&gt; without second argument.</source>
          <target state="translated">2番目の引数 &lt;code&gt;p&lt;/code&gt; は、必ずしも &lt;code&gt;norm&lt;/code&gt; のインターフェースの一部である必要はありません。つまり、カスタム型は2番目の引数なしで &lt;code&gt;norm(A)&lt;/code&gt; のみを実装できます。</target>
        </trans-unit>
        <trans-unit id="b22778842445d7f70d31b000bce7d6cc33096518" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; can optionally be a calling convention specifier (immediately preceding return type). Without any specifier, the platform-default C calling convention is used. Other supported conventions are: &lt;code&gt;stdcall&lt;/code&gt;, &lt;code&gt;cdecl&lt;/code&gt;, &lt;code&gt;fastcall&lt;/code&gt;, and &lt;code&gt;thiscall&lt;/code&gt; (no-op on 64-bit Windows). For example (from &lt;code&gt;base/libc.jl&lt;/code&gt;) we see the same &lt;code&gt;gethostname&lt;/code&gt;&lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; as above, but with the correct signature for Windows:</source>
          <target state="translated">&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;の2番目の引数は、オプションで呼び出し規約指定子（直前の戻り値の型）にすることができます。指定子がない場合は、プラットフォームのデフォルトのC呼び出し規約が使用されます。その他のサポートされている規則は、 &lt;code&gt;stdcall&lt;/code&gt; 、 &lt;code&gt;cdecl&lt;/code&gt; 、 &lt;code&gt;fastcall&lt;/code&gt; 、および &lt;code&gt;thiscall&lt;/code&gt; （64ビットWindowsでは何もしない）です。たとえば（ &lt;code&gt;base/libc.jl&lt;/code&gt; から）上記と同じ &lt;code&gt;gethostname&lt;/code&gt; &lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; が表示さ&lt;/a&gt;れますが、Windowsの正しい署名が含まれています。</target>
        </trans-unit>
        <trans-unit id="0ae8f7c6c5ae9107bf9df78309eaedb266fcdbc6" translate="yes" xml:space="preserve">
          <source>The second form is also often better style and can lead to more code reuse.</source>
          <target state="translated">また、第二形態はより良いスタイルであることが多く、より多くのコードの再利用につながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="f5a1001e237b6ff86cbef193ea1ae22360accd73" translate="yes" xml:space="preserve">
          <source>The second of a &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;としての &lt;code&gt;DateTime&lt;/code&gt; の秒。</target>
        </trans-unit>
        <trans-unit id="9d31d476948ba89a2e9e64c6b33fad2cd0a026a5" translate="yes" xml:space="preserve">
          <source>The second of a &lt;code&gt;Time&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;としての &lt;code&gt;Time&lt;/code&gt; の秒。</target>
        </trans-unit>
        <trans-unit id="325c1f846c581874b3b9e8bdbf898464d53c77a6" translate="yes" xml:space="preserve">
          <source>The second part of a DateTime as a &lt;code&gt;Second&lt;/code&gt;.</source>
          <target state="translated">DateTimeの第二部 &lt;code&gt;Second&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a3329a718673195a0538b1050837014e0187920" translate="yes" xml:space="preserve">
          <source>The second statement in the test program evaluates a Julia statement using a call to &lt;code&gt;jl_eval_string&lt;/code&gt;.</source>
          <target state="translated">テストプログラムの2番目のステートメントは、 &lt;code&gt;jl_eval_string&lt;/code&gt; の呼び出しを使用してJuliaステートメントを評価します。</target>
        </trans-unit>
        <trans-unit id="9cc4451185981f40556584c6f362b372cf0d2413" translate="yes" xml:space="preserve">
          <source>The second syntactic purpose of the &lt;code&gt;:&lt;/code&gt; character is to create expression objects without using the explicit &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; constructor. This is referred to as &lt;em&gt;quoting&lt;/em&gt;. The &lt;code&gt;:&lt;/code&gt; character, followed by paired parentheses around a single statement of Julia code, produces an &lt;code&gt;Expr&lt;/code&gt; object based on the enclosed code. Here is example of the short form used to quote an arithmetic expression:</source>
          <target state="translated">&lt;code&gt;:&lt;/code&gt; 文字の2番目の構文上の目的は、明示的な&lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt;コンストラクターを使用せずに式オブジェクトを作成することです。これは&lt;em&gt;引用&lt;/em&gt;と呼ばれます。 &lt;code&gt;:&lt;/code&gt; ジュリアコードの単一のステートメントの周りのペアに括弧が続く文字は、生産 &lt;code&gt;Expr&lt;/code&gt; 囲まれたコードに基づいてオブジェクトを。以下は、算術式を引用するために使用される短い形式の例です。</target>
        </trans-unit>
        <trans-unit id="915184092841becb822c9871efbbca52119b3359" translate="yes" xml:space="preserve">
          <source>The second version will convert &lt;code&gt;x&lt;/code&gt; to an appropriate type, instead of always the same type.</source>
          <target state="translated">2番目のバージョンは、 &lt;code&gt;x&lt;/code&gt; を常に同じ型ではなく、適切な型に変換します。</target>
        </trans-unit>
        <trans-unit id="21005babd7e775084c5d9f5bf289076cc05e5e92" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s in &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;Control Flow&lt;/a&gt; discussed the execution of multiple functions in a co-operative manner. &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;s can be quite useful to pass data between running tasks, particularly those involving I/O operations.</source>
          <target state="translated">&lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;制御フローの&lt;/a&gt;&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;のセクションでは、複数の機能の実行を協調的に説明しました。&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; は&lt;/a&gt;、実行中のタスク、特にI / O操作に関連するタスク間でデータを受け渡すのに非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="b8192d7c492df82ef09042dd5374aa1f14711d23" translate="yes" xml:space="preserve">
          <source>The shared array is valid as long as a reference to the &lt;code&gt;SharedArray&lt;/code&gt; object exists on the node which created the mapping.</source>
          <target state="translated">共有配列は、マッピングを作成したノードに &lt;code&gt;SharedArray&lt;/code&gt; オブジェクトへの参照が存在する限り有効です。</target>
        </trans-unit>
        <trans-unit id="5dc8475813b4cdc5d96eb3c4625fbd7b58d50c66" translate="yes" xml:space="preserve">
          <source>The shortest complete expression after the &lt;code&gt;$&lt;/code&gt; is taken as the expression whose value is to be interpolated into the string. Thus, you can interpolate any expression into a string using parentheses:</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; の後の最も短い完全な式は、値が文字列に補間される式と見なされます。したがって、括弧を使用して任意の式を文字列に補間できます。</target>
        </trans-unit>
        <trans-unit id="3d9f8e8412af884c31e022248ea444c48500d8b3" translate="yes" xml:space="preserve">
          <source>The simplest way to create a sparse array is to use a function equivalent to the &lt;a href=&quot;../../base/arrays/index#Base.zeros&quot;&gt;&lt;code&gt;zeros&lt;/code&gt;&lt;/a&gt; function that Julia provides for working with dense arrays. To produce a sparse array instead, you can use the same name with an &lt;code&gt;sp&lt;/code&gt; prefix:</source>
          <target state="translated">スパース配列を作成する最も簡単な方法は、ジュリアが密配列を処理するために提供する&lt;a href=&quot;../../base/arrays/index#Base.zeros&quot;&gt; &lt;code&gt;zeros&lt;/code&gt; &lt;/a&gt;関数と同等の関数を使用することです。代わりにスパース配列を作成するには、同じ名前に接頭辞 &lt;code&gt;sp&lt;/code&gt; を付けます。</target>
        </trans-unit>
        <trans-unit id="b5c1b2cacc149914d1f87944b2e673b55e75f540" translate="yes" xml:space="preserve">
          <source>The singleton instance of &lt;code&gt;Colon&lt;/code&gt; is also a function used to construct ranges; see &lt;a href=&quot;../math/index#Base.::&quot;&gt;&lt;code&gt;:&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Colon&lt;/code&gt; のシングルトンインスタンスは、範囲の構築に使用される関数でもあります。参照&lt;a href=&quot;../math/index#Base.::&quot;&gt; &lt;code&gt;:&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69dbdef625126b35b49d3d64442b9b0a176ab7d3" translate="yes" xml:space="preserve">
          <source>The singleton instance of type &lt;a href=&quot;#Base.Missing&quot;&gt;&lt;code&gt;Missing&lt;/code&gt;&lt;/a&gt; representing a missing value.</source>
          <target state="translated">欠損値を表す&lt;a href=&quot;#Base.Missing&quot;&gt; &lt;code&gt;Missing&lt;/code&gt; &lt;/a&gt;型のシングルトンインスタンス。</target>
        </trans-unit>
        <trans-unit id="d89078042c9eb6d352a7eb66e0b88b0400546bfa" translate="yes" xml:space="preserve">
          <source>The singleton instance of type &lt;a href=&quot;../base/index#Core.Nothing&quot;&gt;&lt;code&gt;Nothing&lt;/code&gt;&lt;/a&gt;, used by convention when there is no value to return (as in a C &lt;code&gt;void&lt;/code&gt; function) or when a variable or field holds no value.</source>
          <target state="translated">（C &lt;code&gt;void&lt;/code&gt; 関数のように）返す値がない場合、または変数やフィールドに値がない場合に、慣例により使用される&lt;a href=&quot;../base/index#Core.Nothing&quot;&gt; &lt;code&gt;Nothing&lt;/code&gt; &lt;/a&gt;タイプのシングルトンインスタンス。</target>
        </trans-unit>
        <trans-unit id="98c477c6e9d21cf836746a2bcff1d62c547964d7" translate="yes" xml:space="preserve">
          <source>The size (in bytes) of the file</source>
          <target state="translated">ファイルのサイズ(バイト数)</target>
        </trans-unit>
        <trans-unit id="b66123090eeef1135c4d4375118f6396f24e2b0e" translate="yes" xml:space="preserve">
          <source>The slightly odd feature of these declarations as compared to typical parametric composite types, is that the type parameter &lt;code&gt;T&lt;/code&gt; is not used in the definition of the type itself &amp;ndash; it is just an abstract tag, essentially defining an entire family of types with identical structure, differentiated only by their type parameter. Thus, &lt;code&gt;Ptr{Float64}&lt;/code&gt; and &lt;code&gt;Ptr{Int64}&lt;/code&gt; are distinct types, even though they have identical representations. And of course, all specific pointer types are subtypes of the umbrella &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr&lt;/code&gt;&lt;/a&gt; type:</source>
          <target state="translated">一般的なパラメトリック複合型と比較したこれらの宣言の少し奇妙な特徴は、型パラメーター &lt;code&gt;T&lt;/code&gt; が型自体の定義で使用されないことです。これは単なる抽象タグであり、本質的に同一の構造を持つ型のファミリー全体を定義します。タイプパラメータによってのみ区別されます。したがって、 &lt;code&gt;Ptr{Float64}&lt;/code&gt; と &lt;code&gt;Ptr{Int64}&lt;/code&gt; は、表現が同じであっても、異なる型です。そしてもちろん、すべての特定のポインター型はアンブレラ&lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr&lt;/code&gt; &lt;/a&gt;型のサブタイプです。</target>
        </trans-unit>
        <trans-unit id="b70321f704716a765747450fd9a29400a288057e" translate="yes" xml:space="preserve">
          <source>The smallest &lt;code&gt;a^n&lt;/code&gt; not less than &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is a non-negative integer. &lt;code&gt;a&lt;/code&gt; must be greater than 1, and &lt;code&gt;x&lt;/code&gt; must be greater than 0.</source>
          <target state="translated">最小 &lt;code&gt;a^n&lt;/code&gt; 以上 &lt;code&gt;x&lt;/code&gt; 、 &lt;code&gt;n&lt;/code&gt; は負でない整数です。 &lt;code&gt;a&lt;/code&gt; は1より大きく、 &lt;code&gt;x&lt;/code&gt; は0より大きくなければなりません。</target>
        </trans-unit>
        <trans-unit id="8e217f5379986c6dbb724913b9402b2744112320" translate="yes" xml:space="preserve">
          <source>The smallest in absolute value non-subnormal value representable by the given floating-point DataType &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">指定された浮動小数点DataType &lt;code&gt;T&lt;/code&gt; で表現できる非正規の絶対値の最小値。</target>
        </trans-unit>
        <trans-unit id="25349e0ef0dc3df135e9bbaceeafe9aedb6a8cb7" translate="yes" xml:space="preserve">
          <source>The so-called &quot;ternary operator&quot;, &lt;code&gt;?:&lt;/code&gt;, is closely related to the &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elseif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; syntax, but is used where a conditional choice between single expression values is required, as opposed to conditional execution of longer blocks of code. It gets its name from being the only operator in most languages taking three operands:</source>
          <target state="translated">いわゆる「三項演算子」である &lt;code&gt;?:&lt;/code&gt; は、 &lt;code&gt;if&lt;/code&gt; - &lt;code&gt;elseif&lt;/code&gt; - &lt;code&gt;else&lt;/code&gt; 構文に密接に関連していますが、より長いコードブロックの条件付き実行とは対照的に、単一の式の値間の条件付き選択が必要な場合に使用されます。これは、ほとんどの言語で3つのオペランドを取る唯一の演算子であることからその名前を得ています。</target>
        </trans-unit>
        <trans-unit id="466b5c814e2cc3e14c74b0b3d7f3038223cc5afa" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;CartesianIndex{N}&lt;/code&gt; object represents a scalar index that behaves like an &lt;code&gt;N&lt;/code&gt;-tuple of integers spanning multiple dimensions. For example:</source>
          <target state="translated">特別な &lt;code&gt;CartesianIndex{N}&lt;/code&gt; オブジェクトは、複数の次元にわたる整数の &lt;code&gt;N&lt;/code&gt; タプルのように動作するスカラーインデックスを表します。例えば：</target>
        </trans-unit>
        <trans-unit id="762a1096309b147153ae61442ac8f98b5b44d380" translate="yes" xml:space="preserve">
          <source>The specified range is partitioned and locally executed across all workers. In case an optional reducer function is specified, &lt;code&gt;@distributed&lt;/code&gt; performs local reductions on each worker with a final reduction on the calling process.</source>
          <target state="translated">指定された範囲は分割され、すべてのワーカーでローカルに実行されます。オプションのレデューサー関数が指定されている場合、 &lt;code&gt;@distributed&lt;/code&gt; は各ワーカーでローカル削減を実行し、呼び出しプロセスで最終削減を行います。</target>
        </trans-unit>
        <trans-unit id="af76c7aa8adb68998b2eccf29c56d714b4910790" translate="yes" xml:space="preserve">
          <source>The stack of current exceptions can be accessed using the experimental &lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt;&lt;code&gt;Base.catch_stack&lt;/code&gt;&lt;/a&gt; function. For example,</source>
          <target state="translated">現在の例外のスタックには、実験的な&lt;a href=&quot;../../base/base/index#Base.catch_stack&quot;&gt; &lt;code&gt;Base.catch_stack&lt;/code&gt; &lt;/a&gt;関数を使用してアクセスできます。例えば、</target>
        </trans-unit>
        <trans-unit id="b314da4796576e2f7b71a666741e2ef66714401f" translate="yes" xml:space="preserve">
          <source>The standard way to obtain a value of a certain type &lt;code&gt;T&lt;/code&gt; is to call the type's constructor, &lt;code&gt;T(x)&lt;/code&gt;. However, there are cases where it's convenient to convert a value from one type to another without the programmer asking for it explicitly. One example is assigning a value into an array: if &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;Vector{Float64}&lt;/code&gt;, the expression &lt;code&gt;A[1] = 2&lt;/code&gt; should work by automatically converting the &lt;code&gt;2&lt;/code&gt; from &lt;code&gt;Int&lt;/code&gt; to &lt;code&gt;Float64&lt;/code&gt;, and storing the result in the array. This is done via the &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">特定の型 &lt;code&gt;T&lt;/code&gt; の値を取得する標準的な方法は、型のコンストラクター &lt;code&gt;T(x)&lt;/code&gt; を呼び出すことです。ただし、プログラマーが明示的に要求しなくても、値をある型から別の型に変換すると便利な場合があります。 1つの例は、配列に値を割り当てることです &lt;code&gt;A&lt;/code&gt; が &lt;code&gt;Vector{Float64}&lt;/code&gt; 場合、式 &lt;code&gt;A[1] = 2&lt;/code&gt; は、 &lt;code&gt;2&lt;/code&gt; を &lt;code&gt;Int&lt;/code&gt; から &lt;code&gt;Float64&lt;/code&gt; に自動的に変換し、結果を配列に格納することで機能します。これは、&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;機能を介して行われます。</target>
        </trans-unit>
        <trans-unit id="09c9759ec2f73e324d46f0dc859670daa106989a" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;using BigLib: thing1, thing2&lt;/code&gt; brings just the identifiers &lt;code&gt;thing1&lt;/code&gt; and &lt;code&gt;thing2&lt;/code&gt; into scope from module &lt;code&gt;BigLib&lt;/code&gt;. If these names refer to functions, adding methods to them will not be allowed (you may only &quot;use&quot; them, not extend them).</source>
          <target state="translated">&lt;code&gt;using BigLib: thing1, thing2&lt;/code&gt; を使用するステートメント：thing1、thing2は、識別子 &lt;code&gt;thing1&lt;/code&gt; と &lt;code&gt;thing2&lt;/code&gt; をモジュール &lt;code&gt;BigLib&lt;/code&gt; のスコープに移動します。これらの名前が関数を参照している場合、それらにメソッドを追加することは許可されません（それらを「使用」するだけで、拡張することはできません）。</target>
        </trans-unit>
        <trans-unit id="495d86d0b4d05239c00e12e65404916397e09df9" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;using Lib&lt;/code&gt; means that a module called &lt;code&gt;Lib&lt;/code&gt; will be available for resolving names as needed. When a global variable is encountered that has no definition in the current module, the system will search for it among variables exported by &lt;code&gt;Lib&lt;/code&gt; and import it if it is found there. This means that all uses of that global within the current module will resolve to the definition of that variable in &lt;code&gt;Lib&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;using Lib&lt;/code&gt; を使用するステートメントは、 &lt;code&gt;Lib&lt;/code&gt; と呼ばれるモジュールが必要に応じて名前を解決するために使用できることを意味します。現在のモジュールで定義されていないグローバル変数が検出されると、システムは、 &lt;code&gt;Lib&lt;/code&gt; によってエクスポートされた変数からその変数を検索し、そこに見つかった場合はインポートします。つまり、現在のモジュール内でそのグローバルを使用すると、 &lt;code&gt;Lib&lt;/code&gt; での変数の定義に解決されます。</target>
        </trans-unit>
        <trans-unit id="e69251ee5ae969dde76ae7aecf53b32517ef054f" translate="yes" xml:space="preserve">
          <source>The stride should be unit stride.</source>
          <target state="translated">歩幅は単位歩幅とする。</target>
        </trans-unit>
        <trans-unit id="b5f6cb2eda0183a3a023b5793fbbc533b8630c5f" translate="yes" xml:space="preserve">
          <source>The strongest legacy of Lisp in the Julia language is its metaprogramming support. Like Lisp, Julia represents its own code as a data structure of the language itself. Since code is represented by objects that can be created and manipulated from within the language, it is possible for a program to transform and generate its own code. This allows sophisticated code generation without extra build steps, and also allows true Lisp-style macros operating at the level of &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;abstract syntax trees&lt;/a&gt;. In contrast, preprocessor &quot;macro&quot; systems, like that of C and C++, perform textual manipulation and substitution before any actual parsing or interpretation occurs. Because all data types and code in Julia are represented by Julia data structures, powerful &lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt; capabilities are available to explore the internals of a program and its types just like any other data.</source>
          <target state="translated">Julia言語でのLispの最も強力な遺産は、そのメタプログラミングのサポートです。 Lispと同様に、Juliaは独自のコードを言語自体のデータ構造として表します。コードは、言語内から作成および操作できるオブジェクトによって表されるため、プログラムが独自のコードを変換および生成することが可能です。これにより、追加のビルドステップなしで高度なコード生成が可能になり、&lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;抽象構文ツリーの&lt;/a&gt;レベルで動作する真のLispスタイルのマクロも可能になります。対照的に、CおよびC ++のシステムのようなプリプロセッサ「マクロ」システムは、実際の解析または解釈が行われる前に、テキストの操作と置換を実行します。 Juliaのすべてのデータ型とコードはJuliaデータ構造で表されるため、強力な&lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;リフレクション&lt;/a&gt;他のデータと同じように、プログラムの内部とそのタイプを探索する機能が利用できます。</target>
        </trans-unit>
        <trans-unit id="5e569356ccc37557b3dd3a4c9eb2b13531bfa9b1" translate="yes" xml:space="preserve">
          <source>The subdiagonal part contains the reflectors $v_i$ stored in a packed format such that &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt;.</source>
          <target state="translated">下対角部分には、 &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt; ようなパック形式で格納されたリフレクター$ v_i $が含まれています。</target>
        </trans-unit>
        <trans-unit id="c0c6aba56e3888ce8991d8adbbc0407169b7c0c0" translate="yes" xml:space="preserve">
          <source>The subdiagonal part contains the reflectors $v_i$ stored in a packed format where $v_i$ is the $i$th column of the matrix &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt;.</source>
          <target state="translated">下対角部分には、パック形式で格納されたリフレクター$ v_i $が含まれています。ここで、$ v_i $は、行列 &lt;code&gt;V = I + tril(F.factors, -1)&lt;/code&gt; の$ i $番目の列です。</target>
        </trans-unit>
        <trans-unit id="7e2a34ecc15f647be67c38e382f5d48daa6d45c2" translate="yes" xml:space="preserve">
          <source>The subscripted &lt;code&gt;rootsᵢ&lt;/code&gt;, &lt;code&gt;graphᵢ&lt;/code&gt; and &lt;code&gt;pathsᵢ&lt;/code&gt; variables correspond to the subscripted environments, &lt;code&gt;envᵢ&lt;/code&gt;, contained in &lt;code&gt;stack&lt;/code&gt;. The &lt;code&gt;reverse&lt;/code&gt; is present because &lt;code&gt;merge&lt;/code&gt; favors the last argument rather than first when there are collisions between keys in its argument dictionaries. There are a couple of noteworthy features of this design:</source>
          <target state="translated">添え字付きの &lt;code&gt;rootsᵢ&lt;/code&gt; 、 &lt;code&gt;graphᵢ&lt;/code&gt; 、 &lt;code&gt;pathsᵢ&lt;/code&gt; の変数は、 &lt;code&gt;envᵢ&lt;/code&gt; に含まれる添え字付きの環境envᵢに対応してい &lt;code&gt;stack&lt;/code&gt; 。引数ディクショナリのキー間に衝突がある場合、 &lt;code&gt;merge&lt;/code&gt; は最初ではなく最後の引数を優先するため、その &lt;code&gt;reverse&lt;/code&gt; が存在します。この設計には注目すべき機能がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="996fc71a38fd366e817f73bce0377ef4ace5919b" translate="yes" xml:space="preserve">
          <source>The subtypes of &lt;code&gt;AbstractArray&lt;/code&gt; typically implement two methods to achieve this: A method to convert the input array to a subtype of a specific &lt;code&gt;AbstractArray{T, N}&lt;/code&gt; abstract type; and a method to make a new uninitialized array with a specific element type. Sample implementations of these can be found in Julia Base. Here is a basic example usage of them, guaranteeing that &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;output&lt;/code&gt; are of the same type:</source>
          <target state="translated">&lt;code&gt;AbstractArray&lt;/code&gt; のサブタイプは通常、これを実現するために2つのメソッドを実装します。入力配列を特定の &lt;code&gt;AbstractArray{T, N}&lt;/code&gt; 抽象型のサブタイプに変換するメソッド。そして、特定の要素タイプで初期化されていない新しい配列を作成するメソッド。これらのサンプル実装はJulia Baseにあります。以下は、これらの基本的な使用例であり、 &lt;code&gt;input&lt;/code&gt; と &lt;code&gt;output&lt;/code&gt; が同じタイプであることを保証します。</target>
        </trans-unit>
        <trans-unit id="63699aa33be9f33f21d62b86441a8ff8e274be42" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;M.x = y&lt;/code&gt; does not work to assign a global in another module; global assignment is always module-local.</source>
          <target state="translated">構文 &lt;code&gt;M.x = y&lt;/code&gt; は、別のモジュールでグローバルを割り当てるようには機能しません。グローバル割り当ては常にモジュールローカルです。</target>
        </trans-unit>
        <trans-unit id="8aef45ce051e500a72b345ef2f22cdbfc5692cd9" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;[A, B, C, ...]&lt;/code&gt; constructs a 1-d array (i.e., a vector) of its arguments. If all arguments have a common &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;promotion type&lt;/a&gt; then they get converted to that type using &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">構文 &lt;code&gt;[A, B, C, ...]&lt;/code&gt; は、引数の1次元配列（つまり、ベクトル）を作成します。すべての引数に共通の&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;プロモーションタイプ&lt;/a&gt;がある場合、それらは&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;を使用してそのタイプに変換されます。</target>
        </trans-unit>
        <trans-unit id="e625bef095d2c8eb72ebaeebbec92f580bcf9df3" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;a.b = c&lt;/code&gt; calls &lt;code&gt;setproperty!(a, :b, c)&lt;/code&gt;.</source>
          <target state="translated">構文 &lt;code&gt;a.b = c&lt;/code&gt; は &lt;code&gt;setproperty!(a, :b, c)&lt;/code&gt; 呼び出します。</target>
        </trans-unit>
        <trans-unit id="bb9de73fee4d35f05a94de3650ba9db8d2743f66" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;a.b&lt;/code&gt; calls &lt;code&gt;getproperty(a, :b)&lt;/code&gt;.</source>
          <target state="translated">構文 &lt;code&gt;a.b&lt;/code&gt; は &lt;code&gt;getproperty(a, :b)&lt;/code&gt; 呼び出します。</target>
        </trans-unit>
        <trans-unit id="00608410463d33a3565dc12e2221379a6b79beb5" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;catch e&lt;/code&gt; (where &lt;code&gt;e&lt;/code&gt; is any variable) assigns the thrown exception object to the given variable within the &lt;code&gt;catch&lt;/code&gt; block.</source>
          <target state="translated">構文 &lt;code&gt;catch e&lt;/code&gt; （ &lt;code&gt;e&lt;/code&gt; は任意の変数）は、スローされた例外オブジェクトを &lt;code&gt;catch&lt;/code&gt; ブロック内の指定された変数に割り当てます。</target>
        </trans-unit>
        <trans-unit id="fbb021dba0d683eea0a7e9eec6250ba19720138f" translate="yes" xml:space="preserve">
          <source>The syntax for images is similar to the link syntax mentioned above. Prepending a &lt;code&gt;!&lt;/code&gt; character to a link will display an image from the specified URL rather than a link to it.</source>
          <target state="translated">画像の構文は、上記のリンク構文に似ています。先頭に &lt;code&gt;!&lt;/code&gt; リンクへの文字は、リンクへのリンクではなく、指定されたURLからの画像を表示します。</target>
        </trans-unit>
        <trans-unit id="4706abb51ce58ba5921e55c75731359f252d532a" translate="yes" xml:space="preserve">
          <source>The syntax of &lt;code&gt;remotecall&lt;/code&gt; is not especially convenient. The macro &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; makes things easier. It operates on an expression rather than a function, and picks where to do the operation for you:</source>
          <target state="translated">&lt;code&gt;remotecall&lt;/code&gt; の構文は特に便利ではありません。マクロ&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt;は物事を簡単にします。関数ではなく式を操作し、操作を実行する場所を選択します。</target>
        </trans-unit>
        <trans-unit id="e63059505e9b54a2aa7f6f114401eafe55571016" translate="yes" xml:space="preserve">
          <source>The syntaxes &lt;code&gt;A[end]&lt;/code&gt; and &lt;code&gt;A[end, end]&lt;/code&gt; lower to &lt;code&gt;A[lastindex(A)]&lt;/code&gt; and &lt;code&gt;A[lastindex(A, 1), lastindex(A, 2)]&lt;/code&gt;, respectively.</source>
          <target state="translated">構文 &lt;code&gt;A[end]&lt;/code&gt; と &lt;code&gt;A[end, end]&lt;/code&gt; 、それぞれ &lt;code&gt;A[lastindex(A)]&lt;/code&gt; と &lt;code&gt;A[lastindex(A, 1), lastindex(A, 2)]&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="76ff0041a09cb9e2761ca760c9e89d92dece6223" translate="yes" xml:space="preserve">
          <source>The system also generates some standard information for each event:</source>
          <target state="translated">また、イベントごとにある程度の標準的な情報を生成しています。</target>
        </trans-unit>
        <trans-unit id="1291d08b43c51644b75972a68949c78194cf4ab6" translate="yes" xml:space="preserve">
          <source>The system provides several advantages over peppering your source code with calls to &lt;code&gt;println()&lt;/code&gt;. First, it allows you to control the visibility and presentation of messages without editing the source code. For example, in contrast to the &lt;code&gt;@warn&lt;/code&gt; above</source>
          <target state="translated">システムには、 &lt;code&gt;println()&lt;/code&gt; の呼び出しでソースコードをペパーリングするよりもいくつかの利点があります。まず、ソースコードを編集せずにメッセージの表示と表示を制御できます。たとえば、上の &lt;code&gt;@warn&lt;/code&gt; とは対照的に</target>
        </trans-unit>
        <trans-unit id="35ef5183de88aa885d43235fbe1c95c14449a9c3" translate="yes" xml:space="preserve">
          <source>The tab key can also be used to substitute LaTeX math symbols with their Unicode equivalents, and get a list of LaTeX matches as well:</source>
          <target state="translated">また、タブキーはLaTeXの数学記号をUnicodeの等価物で置換したり、LaTeXにマッチしたもののリストを取得したりするのにも使えます。</target>
        </trans-unit>
        <trans-unit id="b6bb24eed2bccbd623888cb79506fd88f02fa796" translate="yes" xml:space="preserve">
          <source>The text associated with a footnote can be written anywhere within the same page as the footnote reference. The syntax used to define the footnote text is discussed in the &lt;a href=&quot;#Footnotes-1&quot;&gt;Footnotes&lt;/a&gt; section below.</source>
          <target state="translated">脚注に関連付けられたテキストは、脚注参照と同じページ内のどこにでも書くことができます。脚注テキストを定義するために使用される構文は、以下の&lt;a href=&quot;#Footnotes-1&quot;&gt;脚注&lt;/a&gt;セクションで説明されています。</target>
        </trans-unit>
        <trans-unit id="89803a19d844f78ae00674dace9498726fc7f334" translate="yes" xml:space="preserve">
          <source>The third and final kind of environment is one that combines other environments by overlaying several of them, making the packages in each available in a single composite environment. These composite environments are called &lt;em&gt;environment stacks&lt;/em&gt;. The Julia &lt;code&gt;LOAD_PATH&lt;/code&gt; global defines an environment stack&amp;mdash;the environment in which the Julia process operates. If you want your Julia process to have access only to the packages in one project or package directory, make it the only entry in &lt;code&gt;LOAD_PATH&lt;/code&gt;. It is often quite useful, however, to have access to some of your favorite tools&amp;mdash;standard libraries, profilers, debuggers, personal utilities, etc.&amp;mdash;even if they are not dependencies of the project you're working on. By adding an environment containing these tools to the load path, you immediately have access to them in top-level code without needing to add them to your project.</source>
          <target state="translated">3番目の最後の種類の環境は、いくつかの環境をオーバーレイすることによって他の環境を組み合わせ、それぞれのパッケージを単一の複合環境で使用できるようにする環境です。これらの複合環境は、&lt;em&gt;環境スタック&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt;。 Julia &lt;code&gt;LOAD_PATH&lt;/code&gt; グローバルは、環境スタック（Juliaプロセスが動作する環境）を定義します。 Juliaプロセスが1つのプロジェクトまたはパッケージディレクトリのパッケージにのみアクセスできるようにするには、それを &lt;code&gt;LOAD_PATH&lt;/code&gt; の唯一のエントリにします。。ただし、作業しているプロジェクトの依存関係でなくても、お気に入りのツール（標準ライブラリ、プロファイラー、デバッガー、個人用ユーティリティなど）にアクセスできると便利な場合があります。これらのツールを含む環境をロードパスに追加すると、プロジェクトに追加する必要なく、最上位のコードですぐにそれらにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="2e5e0709035da59f79f484697f8e3df4d573f5fc" translate="yes" xml:space="preserve">
          <source>The three kinds of types (abstract, primitive, composite) discussed in the previous sections are actually all closely related. They share the same key properties:</source>
          <target state="translated">前のセクションで説明した 3 種類の型 (抽象型、プリミティブ型、複合型)は、実際にはすべて密接に関連しています。これらのタイプは、同じキーとなるプロパティを共有しています。</target>
        </trans-unit>
        <trans-unit id="96a22cbc00a4020163f8bf8451c0cb52f4fe8ed1" translate="yes" xml:space="preserve">
          <source>The three-valued logic described above for logical operators is also used by logical functions applied to arrays. Thus, array equality tests using the &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; operator return &lt;code&gt;missing&lt;/code&gt; whenever the result cannot be determined without knowing the actual value of the &lt;code&gt;missing&lt;/code&gt; entry. In practice, this means that &lt;code&gt;missing&lt;/code&gt; is returned if all non-missing values of the compared arrays are equal, but one or both arrays contain missing values (possibly at different positions)</source>
          <target state="translated">論理演算子について上記で説明した3値論理は、配列に適用される論理関数でも使用されます。したがって、&lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt;演算子を使用した配列等価テストは、 &lt;code&gt;missing&lt;/code&gt; エントリの実際の値を知らずに結果を判別できない場合はいつでも &lt;code&gt;missing&lt;/code&gt; 返します。実際には、このことを意味 &lt;code&gt;missing&lt;/code&gt; 比較配列のすべての非欠損値が等しい場合に戻される、1つまたは両方の配列は、欠損値を含む（おそらく異なる位置で）</target>
        </trans-unit>
        <trans-unit id="7bb480c16cbf47fe55bf38e90f5861a483a884fb" translate="yes" xml:space="preserve">
          <source>The tuple must be the same size as the SIMD type. For example, a tuple representing an &lt;code&gt;__m128&lt;/code&gt; on x86 must have a size of 16 bytes.</source>
          <target state="translated">タプルは、SIMDタイプと同じサイズでなければなりません。たとえば、x86で &lt;code&gt;__m128&lt;/code&gt; を表すタプルのサイズは16バイトでなければなりません。</target>
        </trans-unit>
        <trans-unit id="d71d89013d2d694c3c90bff3726394654345117f" translate="yes" xml:space="preserve">
          <source>The two expressions constructed above &amp;ndash; by parsing and by direct construction &amp;ndash; are equivalent:</source>
          <target state="translated">上記で構築された2つの式（解析と直接構築による）は同等です。</target>
        </trans-unit>
        <trans-unit id="3b3360fde4989c6fe95a691dce2016abf50d9177" translate="yes" xml:space="preserve">
          <source>The two uses of the &lt;code&gt;...&lt;/code&gt; operator: slurping and splatting</source>
          <target state="translated">&lt;code&gt;...&lt;/code&gt; 演算子の2つの使用法：slurpingとsplatting</target>
        </trans-unit>
        <trans-unit id="b96a5c8aeea4ce2a16e47711028fe9eaf98f3763" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Point{Float64}&lt;/code&gt; is a point whose coordinates are 64-bit floating-point values, while the type &lt;code&gt;Point{AbstractString}&lt;/code&gt; is a &quot;point&quot; whose &quot;coordinates&quot; are string objects (see &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/ast/#Strings-1&quot;&gt;Strings&lt;/a&gt;).</source>
          <target state="translated">タイプ &lt;code&gt;Point{Float64}&lt;/code&gt; 座標が64ビット浮動小数点値である点で、タイプしながら &lt;code&gt;Point{AbstractString}&lt;/code&gt; 、その「座標」の文字列オブジェクト（参照されている「点」である&lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/ast/#Strings-1&quot;&gt;文字列を&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6b7369108ecd55df4b36265309c9d17ce4d10c19" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Vararg{T,N}&lt;/code&gt; corresponds to exactly &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;NTuple{N,T}&lt;/code&gt; is a convenient alias for &lt;code&gt;Tuple{Vararg{T,N}}&lt;/code&gt;, i.e. a tuple type containing exactly &lt;code&gt;N&lt;/code&gt; elements of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;Vararg{T,N}&lt;/code&gt; は、タイプ &lt;code&gt;T&lt;/code&gt; の &lt;code&gt;N&lt;/code&gt; 個の要素に対応します。 &lt;code&gt;NTuple{N,T}&lt;/code&gt; は、 &lt;code&gt;Tuple{Vararg{T,N}}&lt;/code&gt; 便利なエイリアスです。つまり、 &lt;code&gt;T&lt;/code&gt; 型のちょうど &lt;code&gt;N&lt;/code&gt; 個の要素を含むタプル型です。</target>
        </trans-unit>
        <trans-unit id="5bedae316814d6156803443fcc9c13d8c64877a4" translate="yes" xml:space="preserve">
          <source>The type annotation partially recovers lost performance due to capturing because the parser can associate a concrete type to the object in the box. Going further, if the captured variable does not need to be boxed at all (because it will not be reassigned after the closure is created), this can be indicated with &lt;code&gt;let&lt;/code&gt; blocks as follows.</source>
          <target state="translated">パーサーはボックス内のオブジェクトに具象タイプを関連付けることができるため、タイプアノテーションはキャプチャーによって失われたパフォーマンスを部分的に回復します。さらに、キャプチャされた変数をボックス化する必要がない場合（クロージャーの作成後に再割り当てされないため）、これは次のように &lt;code&gt;let&lt;/code&gt; ブロックで示すことができます。</target>
        </trans-unit>
        <trans-unit id="6fbcbd4db01a84d712a7283dfeb43aba8b033041" translate="yes" xml:space="preserve">
          <source>The type application syntax &lt;code&gt;A{B,C}&lt;/code&gt; requires &lt;code&gt;A&lt;/code&gt; to be a &lt;code&gt;UnionAll&lt;/code&gt; type, and first substitutes &lt;code&gt;B&lt;/code&gt; for the outermost type variable in &lt;code&gt;A&lt;/code&gt;. The result is expected to be another &lt;code&gt;UnionAll&lt;/code&gt; type, into which &lt;code&gt;C&lt;/code&gt; is then substituted. So &lt;code&gt;A{B,C}&lt;/code&gt; is equivalent to &lt;code&gt;A{B}{C}&lt;/code&gt;. This explains why it is possible to partially instantiate a type, as in &lt;code&gt;Array{Float64}&lt;/code&gt;: the first parameter value has been fixed, but the second still ranges over all possible values. Using explicit &lt;code&gt;where&lt;/code&gt; syntax, any subset of parameters can be fixed. For example, the type of all 1-dimensional arrays can be written as &lt;code&gt;Array{T,1} where T&lt;/code&gt;.</source>
          <target state="translated">タイプアプリケーション構文 &lt;code&gt;A{B,C}&lt;/code&gt; では、 &lt;code&gt;A&lt;/code&gt; が &lt;code&gt;UnionAll&lt;/code&gt; タイプである必要があり、最初に &lt;code&gt;A&lt;/code&gt; の最も外側のタイプ変数を &lt;code&gt;B&lt;/code&gt; に置き換えます。結果は別の &lt;code&gt;UnionAll&lt;/code&gt; 型であると予想され、その中に &lt;code&gt;C&lt;/code&gt; が代入されます。したがって、 &lt;code&gt;A{B,C}&lt;/code&gt; は &lt;code&gt;A{B}{C}&lt;/code&gt; と同等です。これは、 &lt;code&gt;Array{Float64}&lt;/code&gt; ように、型を部分的にインスタンス化できる理由を説明しています。最初のパラメーター値は修正されていますが、2番目のパラメーターは可能なすべての値の範囲です。明示的な &lt;code&gt;where&lt;/code&gt; を使用する構文では、パラメータのサブセットを修正できます。たとえば、すべての1次元配列の型は、 &lt;code&gt;Array{T,1} where T&lt;/code&gt; と書くことができます。ここでTです。</target>
        </trans-unit>
        <trans-unit id="ffb66b4dabff5050a74ff3cadfb7762c384071e4" translate="yes" xml:space="preserve">
          <source>The type arguments to &lt;code&gt;ccall&lt;/code&gt; and &lt;code&gt;@cfunction&lt;/code&gt; are evaluated statically, when the method containing the usage is defined. They therefore must take the form of a literal tuple, not a variable, and cannot reference local variables.</source>
          <target state="translated">使用法を含むメソッドが定義されている場合、 &lt;code&gt;ccall&lt;/code&gt; および &lt;code&gt;@cfunction&lt;/code&gt; の型引数は静的に評価されます。したがって、変数ではなくリテラルタプルの形式をとる必要があり、ローカル変数を参照できません。</target>
        </trans-unit>
        <trans-unit id="1a668fb8c29cba9ffa772e3e0ec9a1a70c5fa795" translate="yes" xml:space="preserve">
          <source>The type is an &lt;code&gt;Array{T,N}&lt;/code&gt; with a bits-type element of &lt;code&gt;T&lt;/code&gt; and dimension &lt;code&gt;N&lt;/code&gt; that determines how the bytes of the array are interpreted. Note that the file must be stored in binary format, and no format conversions are possible (this is a limitation of operating systems, not Julia).</source>
          <target state="translated">タイプは、 &lt;code&gt;Array{T,N}&lt;/code&gt; のビット型要素と &lt;code&gt;T&lt;/code&gt; と寸法 &lt;code&gt;N&lt;/code&gt; アレイのバイトがどのように解釈されるかを判断します。ファイルはバイナリ形式で保存する必要があり、形式の変換はできないことに注意してください（これは、Juliaではなく、オペレーティングシステムの制限です）。</target>
        </trans-unit>
        <trans-unit id="7d5dd90cb0f8495d6d15c26b83250961e3145b2f" translate="yes" xml:space="preserve">
          <source>The type of field &lt;code&gt;a&lt;/code&gt; can be readily determined from the type of &lt;code&gt;m&lt;/code&gt;, but not from the type of &lt;code&gt;t&lt;/code&gt;. Indeed, in &lt;code&gt;t&lt;/code&gt; it's possible to change the type of the field &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">フィールド &lt;code&gt;a&lt;/code&gt; のタイプは、 &lt;code&gt;m&lt;/code&gt; のタイプから容易に決定できますが、 &lt;code&gt;t&lt;/code&gt; のタイプからは決定できません。確かに、中に &lt;code&gt;t&lt;/code&gt; は、フィールドのタイプに変更することも可能です &lt;code&gt;a&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="282394fd5d6e1d690607a98e995ab7809b63cd8e" translate="yes" xml:space="preserve">
          <source>The type of object used to represent identifiers in parsed julia code (ASTs). Also often used as a name or label to identify an entity (e.g. as a dictionary key). &lt;code&gt;Symbol&lt;/code&gt;s can be entered using the &lt;code&gt;:&lt;/code&gt; quote operator:</source>
          <target state="translated">解析されたジュリアコード（AST）で識別子を表すために使用されるオブジェクトのタイプ。エンティティを識別するための名前またはラベルとしても使用されます（辞書のキーなど）。 &lt;code&gt;Symbol&lt;/code&gt; sは、 &lt;code&gt;:&lt;/code&gt; 引用演算子を使用して入力できます。</target>
        </trans-unit>
        <trans-unit id="e9d435d74348a381158dd6b8006d6bf402fcef60" translate="yes" xml:space="preserve">
          <source>The type of the admonition can be any word, but some types produce special styling, namely (in order of decreasing severity): &lt;code&gt;danger&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;/&lt;code&gt;note&lt;/code&gt;, and &lt;code&gt;tip&lt;/code&gt;.</source>
          <target state="translated">警告のタイプは任意の単語にすることができますが、一部のタイプは特別なスタイルを生成します。つまり、（重大度の高い順に）： &lt;code&gt;danger&lt;/code&gt; 、 &lt;code&gt;warning&lt;/code&gt; 、 &lt;code&gt;info&lt;/code&gt; / &lt;code&gt;note&lt;/code&gt; 、 &lt;code&gt;tip&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="95cde77f6d397a5966075de74e297cbf03487660" translate="yes" xml:space="preserve">
          <source>The type of the first argument of this method is a &lt;a href=&quot;../types/index#man-singleton-types-1&quot;&gt;singleton type&lt;/a&gt;, &lt;code&gt;Type{MyType}&lt;/code&gt;, the only instance of which is &lt;code&gt;MyType&lt;/code&gt;. Thus, this method is only invoked when the first argument is the type value &lt;code&gt;MyType&lt;/code&gt;. Notice the syntax used for the first argument: the argument name is omitted prior to the &lt;code&gt;::&lt;/code&gt; symbol, and only the type is given. This is the syntax in Julia for a function argument whose type is specified but whose value does not need to be referenced by name. In this example, since the type is a singleton, we already know its value without referring to an argument name.</source>
          <target state="translated">この方法の最初の引数の型は、&lt;a href=&quot;../types/index#man-singleton-types-1&quot;&gt;シングルトンタイプ&lt;/a&gt;、 &lt;code&gt;Type{MyType}&lt;/code&gt; であり、これの唯一のインスタンス &lt;code&gt;MyType&lt;/code&gt; 。したがって、このメソッドは、最初の引数がタイプ値 &lt;code&gt;MyType&lt;/code&gt; である場合にのみ呼び出されます。最初の引数に使用される構文に注意してください。引数名は &lt;code&gt;::&lt;/code&gt; 記号の前に省略され、型のみが指定されています。これは、タイプが指定されているが値を名前で参照する必要がない関数の引数に対するJuliaの構文です。この例では、タイプがシングルトンであるため、引数名を参照しなくてもその値はわかっています。</target>
        </trans-unit>
        <trans-unit id="3cdf4225b7d8119f12b6f1e72fd124d403b4e26b" translate="yes" xml:space="preserve">
          <source>The type of the first entry of the tuple returned by &lt;code&gt;iterate()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;iterate()&lt;/code&gt; によって返されるタプルの最初のエントリのタイプ</target>
        </trans-unit>
        <trans-unit id="5aa022df5697534e05992976fa7f76aa1feeee08" translate="yes" xml:space="preserve">
          <source>The types &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; all have identical representations: they are eight-bit chunks of memory. Since Julia's type system is nominative, however, they are not interchangeable despite having identical structure. A fundamental difference between them is that they have different supertypes: &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;'s direct supertype is &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt;'s is &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt;&lt;code&gt;Signed&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;'s is &lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt;&lt;code&gt;Unsigned&lt;/code&gt;&lt;/a&gt;. All other differences between &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; are matters of behavior &amp;ndash; the way functions are defined to act when given objects of these types as arguments. This is why a nominative type system is necessary: if structure determined type, which in turn dictates behavior, then it would be impossible to make &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt; behave any differently than &lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt;&lt;code&gt;Int8&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;型、&lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; 型&lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; 型は&lt;/a&gt;すべて同じ表現です。これらは8ビットのメモリチャンクです。ただし、Juliaの型システムは主格であるため、同じ構造を持っているにもかかわらず互換性はありません。それらの基本的な違いは、スーパータイプが異なることです&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;の直接のスーパータイプは&lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; であり&lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt; &lt;code&gt;Signed&lt;/code&gt; &lt;/a&gt;であり、&lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;../../base/numbers/index#Core.Unsigned&quot;&gt; &lt;code&gt;Unsigned&lt;/code&gt; &lt;/a&gt;です。&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; の&lt;/a&gt;その他すべての違い動作の問題&amp;ndash;これらのタイプのオブジェクトを引数として指定したときに関数が動作するように定義される方法。これが主格型システムが必要な理由です。構造が決定した型が動作を決定する場合、&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; を&lt;/a&gt;&lt;a href=&quot;../../base/numbers/index#Core.Int8&quot;&gt; &lt;code&gt;Int8&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt;と異なる動作にすることは不可能です。</target>
        </trans-unit>
        <trans-unit id="b0109db562376dbf272015811ad8745f34d0c123" translate="yes" xml:space="preserve">
          <source>The types of keyword arguments can be made explicit as follows:</source>
          <target state="translated">キーワード引数の種類は、以下のように明示することができます。</target>
        </trans-unit>
        <trans-unit id="150a26f4f49fe87245564e04ceb960fcfbaf40b2" translate="yes" xml:space="preserve">
          <source>The unary operators &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; require explicit parentheses around their argument to disambiguate them from the operator &lt;code&gt;++&lt;/code&gt;, etc. Other compositions of unary operators are parsed with right-associativity, e. g., &lt;code&gt;&amp;radic;&amp;radic;-a&lt;/code&gt; as &lt;code&gt;&amp;radic;(&amp;radic;(-a))&lt;/code&gt;.</source>
          <target state="translated">単項演算子 &lt;code&gt;+&lt;/code&gt; および &lt;code&gt;-&lt;/code&gt; は、演算子 &lt;code&gt;++&lt;/code&gt; などからそれらを明確にするために、引数の前後に明示的な括弧が必要です。単項演算子の他の構成は、右連想で解析されます。たとえば、 &lt;code&gt;&amp;radic;&amp;radic;-a&lt;/code&gt; は &lt;code&gt;&amp;radic;(&amp;radic;(-a))&lt;/code&gt; として解析されます。。</target>
        </trans-unit>
        <trans-unit id="e6715363fde6cdd7a1a24ce6e74d2c35a82ab804" translate="yes" xml:space="preserve">
          <source>The underscore &lt;code&gt;_&lt;/code&gt; can be used as digit separator:</source>
          <target state="translated">下線 &lt;code&gt;_&lt;/code&gt; は、桁区切り記号として使用できます。</target>
        </trans-unit>
        <trans-unit id="5dc9c5b98b8ad88332e71a97e793e826e1cab445" translate="yes" xml:space="preserve">
          <source>The uniform scaling operator</source>
          <target state="translated">一様なスケーリング演算子</target>
        </trans-unit>
        <trans-unit id="37b7ee86ac667d6f86c0ad3037e31cb90445aa51" translate="yes" xml:space="preserve">
          <source>The updating versions of all the binary arithmetic and bitwise operators are:</source>
          <target state="translated">すべての二進法演算子とビット演算子の更新版があります。</target>
        </trans-unit>
        <trans-unit id="1cf2be628194a336d3bbb72bed6445464a756995" translate="yes" xml:space="preserve">
          <source>The upper triangular part contains the elements of $R$, that is &lt;code&gt;R = triu(F.factors)&lt;/code&gt; for a &lt;code&gt;QR&lt;/code&gt; object &lt;code&gt;F&lt;/code&gt;.</source>
          <target state="translated">上三角部分には$ R $の要素が含まれています。つまり、 &lt;code&gt;QR&lt;/code&gt; オブジェクト &lt;code&gt;F&lt;/code&gt; の &lt;code&gt;R = triu(F.factors)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="227320fa312076c32b3808304d06cb30fbcb2399" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;$&lt;/code&gt; for expression interpolation is intentionally reminiscent of &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;string interpolation&lt;/a&gt; and &lt;a href=&quot;../running-external-programs/index#command-interpolation-1&quot;&gt;command interpolation&lt;/a&gt;. Expression interpolation allows convenient, readable programmatic construction of complex Julia expressions.</source>
          <target state="translated">式の補間に &lt;code&gt;$&lt;/code&gt; を使用することは、意図的に&lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;文字列補間&lt;/a&gt;と&lt;a href=&quot;../running-external-programs/index#command-interpolation-1&quot;&gt;コマンド補間を&lt;/a&gt;連想させるものです。式の補間により、複雑なジュリア式の便利で読みやすいプログラムによる構築が可能になります。</target>
        </trans-unit>
        <trans-unit id="414780375a6643e2453e6d8634fae95c5ade2420" translate="yes" xml:space="preserve">
          <source>The use of the &lt;a href=&quot;#return&quot;&gt;&lt;code&gt;return&lt;/code&gt;&lt;/a&gt; keyword is exactly the same as in other languages, but is often optional. A function without an explicit &lt;code&gt;return&lt;/code&gt; statement will return the last expression in the function body.</source>
          <target state="translated">&lt;a href=&quot;#return&quot;&gt; &lt;code&gt;return&lt;/code&gt; &lt;/a&gt;キーワードの使用は他の言語とまったく同じですが、多くの場合オプションです。明示的な &lt;code&gt;return&lt;/code&gt; ステートメントのない関数は、関数本体の最後の式を返します。</target>
        </trans-unit>
        <trans-unit id="a2d597104e09bc0cd5d3b4e8b871fd483fedc685" translate="yes" xml:space="preserve">
          <source>The user id of the owner of the file</source>
          <target state="translated">ファイルの所有者のユーザーID</target>
        </trans-unit>
        <trans-unit id="6c6699f50d2afb2e82521e06f95a5e242ef5260f" translate="yes" xml:space="preserve">
          <source>The usual representation of a &lt;code&gt;quote&lt;/code&gt; form in an AST is an &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; with head &lt;code&gt;:quote&lt;/code&gt;:</source>
          <target state="translated">AST での &lt;code&gt;quote&lt;/code&gt; フォームの通常の表現は、head &lt;code&gt;:quote&lt;/code&gt; を持つ&lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="35f0445ac7033162f95af7dffff6b9386fa1de30" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a&lt;/code&gt; is used to construct the expression &lt;code&gt;ex&lt;/code&gt; which applies the &lt;code&gt;+&lt;/code&gt; function to the value 1 and the variable &lt;code&gt;b&lt;/code&gt;. Note the important distinction between the way &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are used:</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; の値は、 &lt;code&gt;+&lt;/code&gt; 関数を値1と変数 &lt;code&gt;b&lt;/code&gt; に適用する式 &lt;code&gt;ex&lt;/code&gt; を作成するために使用されます。 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; の使用方法の重要な違いに注意してください。</target>
        </trans-unit>
        <trans-unit id="62de8f816c4cc9e366c76d8b6179874f1c02891f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;errno&lt;/code&gt; is only valid immediately after a &lt;code&gt;ccall&lt;/code&gt; to a C library routine that sets it. Specifically, you cannot call &lt;code&gt;errno&lt;/code&gt; at the next prompt in a REPL, because lots of code is executed between prompts.</source>
          <target state="translated">&lt;code&gt;errno&lt;/code&gt; の値は、それを設定するCライブラリルーチンへの &lt;code&gt;ccall&lt;/code&gt; の直後にのみ有効です。具体的には、REPLの次のプロンプトで &lt;code&gt;errno&lt;/code&gt; を呼び出すことはできません。これは、プロンプト間で多くのコードが実行されるためです。</target>
        </trans-unit>
        <trans-unit id="aa580957fe65ae6ff4c7a945625a32e87a3c4957" translate="yes" xml:space="preserve">
          <source>The value of the &lt;em&gt;variable&lt;/em&gt;&lt;code&gt;a&lt;/code&gt; at expression construction time is used as an immediate value in the expression. Thus, the value of &lt;code&gt;a&lt;/code&gt; when the expression is evaluated no longer matters: the value in the expression is already &lt;code&gt;1&lt;/code&gt;, independent of whatever the value of &lt;code&gt;a&lt;/code&gt; might be.</source>
          <target state="translated">式の作成時に&lt;em&gt;変数&lt;/em&gt; &lt;code&gt;a&lt;/code&gt; の値が式の即値として使用されます。このように、の値式が評価され、もはや重要ません：式の値がすでにある &lt;code&gt;1&lt;/code&gt; の値が何に依存しない、かもしれません。 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9712274625a8ada140a13908f35f8b798b923a70" translate="yes" xml:space="preserve">
          <source>The value returned by a function is the value of the last expression evaluated, which, by default, is the last expression in the body of the function definition. In the example function, &lt;code&gt;f&lt;/code&gt;, from the previous section this is the value of the expression &lt;code&gt;x + y&lt;/code&gt;. As in C and most other imperative or functional languages, the &lt;code&gt;return&lt;/code&gt; keyword causes a function to return immediately, providing an expression whose value is returned:</source>
          <target state="translated">関数によって返される値は、最後に評価された式の値です。これは、デフォルトでは、関数定義の本文の最後の式です。前のセクションの関数例 &lt;code&gt;f&lt;/code&gt; では、これは式 &lt;code&gt;x + y&lt;/code&gt; です。 Cおよび他のほとんどの命令型または関数型言語と同様に、 &lt;code&gt;return&lt;/code&gt; キーワードを指定すると、関数は即座に戻り、値が返される式を提供します。</target>
        </trans-unit>
        <trans-unit id="c36bf156fd24214b4253de2ab2fb9c5aaef1f580" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; have the same type, yet their underlying representation of data in memory is very different. Even if you stored just numeric values in field &lt;code&gt;a&lt;/code&gt;, the fact that the memory representation of a &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt; differs from a &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; also means that the CPU needs to handle them using two different kinds of instructions. Since the required information is not available in the type, such decisions have to be made at run-time. This slows performance.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; と &lt;code&gt;c&lt;/code&gt; の値は同じ型ですが、メモリ内のデータの基本的な表現は大きく異なります。フィールド &lt;code&gt;a&lt;/code&gt; に数値のみを格納した場合でも、&lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; の&lt;/a&gt;メモリ表現が&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;と異なるということは、CPUが2種類の命令を使用してそれらを処理する必要があることも意味します。必要な情報がタイプで利用できないため、そのような決定は実行時に行う必要があります。これによりパフォーマンスが低下します。</target>
        </trans-unit>
        <trans-unit id="8485dbcd7c0bda629f4ab2a94790ee6bae11f052" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt;&lt;code&gt;typemax&lt;/code&gt;&lt;/a&gt; are always of the given argument type. (The above expression uses several features that have yet to be introduced, including &lt;a href=&quot;../control-flow/index#man-loops-1&quot;&gt;for loops&lt;/a&gt;, &lt;a href=&quot;../strings/index#man-strings-1&quot;&gt;Strings&lt;/a&gt;, and &lt;a href=&quot;../metaprogramming/index#Interpolation-1&quot;&gt;Interpolation&lt;/a&gt;, but should be easy enough to understand for users with some existing programming experience.)</source>
          <target state="translated">&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/base/index#Base.typemax&quot;&gt; &lt;code&gt;typemax&lt;/code&gt; &lt;/a&gt;によって返される値は、常に指定された引数の型です。（上記の式は、&lt;a href=&quot;../control-flow/index#man-loops-1&quot;&gt;forループ&lt;/a&gt;、&lt;a href=&quot;../strings/index#man-strings-1&quot;&gt;文字列&lt;/a&gt;、および&lt;a href=&quot;../metaprogramming/index#Interpolation-1&quot;&gt;補間&lt;/a&gt;を含む、まだ導入されていないいくつかの機能を使用していますが、既存のプログラミング経験のあるユーザーにとっては十分理解しやすいはずです。）</target>
        </trans-unit>
        <trans-unit id="10056f49c16766ab5a7d038814128061f1bc2774" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;relation&lt;/code&gt; is declared inside the &lt;code&gt;if&lt;/code&gt; block, but used outside. However, when depending on this behavior, make sure all possible code paths define a value for the variable. The following change to the above function results in a runtime error</source>
          <target state="translated">変数 &lt;code&gt;relation&lt;/code&gt; は &lt;code&gt;if&lt;/code&gt; ブロック内で宣言されていますが、外部で使用されています。ただし、この動作に依存する場合は、可能なすべてのコードパスが変数の値を定義していることを確認してください。上記の関数を次のように変更すると、ランタイムエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="67a867d229f7011e541a374fedf8ebf1c9e53637" translate="yes" xml:space="preserve">
          <source>The variable bound defaults to &lt;a href=&quot;#Core.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt; if it is omitted:</source>
          <target state="translated">変数バウンドは、省略された場合、デフォルトで&lt;a href=&quot;#Core.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; に&lt;/a&gt;なります。</target>
        </trans-unit>
        <trans-unit id="e448ca292ee1dbe02f872083148deaa835508c61" translate="yes" xml:space="preserve">
          <source>The variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are bound to the first two argument values as usual, and the variable &lt;code&gt;x&lt;/code&gt; is bound to an iterable collection of the zero or more values passed to &lt;code&gt;bar&lt;/code&gt; after its first two arguments:</source>
          <target state="translated">変数 &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; は通常どおり最初の2つの引数値にバインドされ、変数 &lt;code&gt;x&lt;/code&gt; は最初の2つの引数の後に &lt;code&gt;bar&lt;/code&gt; に渡されるゼロ以上の値の反復可能なコレクションにバインドされます。</target>
        </trans-unit>
        <trans-unit id="4a9e1ff901c13ad87d154ae8aa5cd1e9d49a1456" translate="yes" xml:space="preserve">
          <source>The vast majority of functions will not take every kind of argument listed above; the numbers merely denote the precedence that should be used for any applicable arguments to a function.</source>
          <target state="translated">大多数の関数は、上記に挙げたすべての種類の引数を取るわけではありません。</target>
        </trans-unit>
        <trans-unit id="7e112d8ac7b6cbcda1facaf504ce365573c15593" translate="yes" xml:space="preserve">
          <source>The write barrier is also necessary for arrays of pointers when updating their data directly. For example:</source>
          <target state="translated">また、ポインタの配列のデータを直接更新する場合には、書き込みバリアが必要になります。例えば</target>
        </trans-unit>
        <trans-unit id="7df222412e61e0a840295167e1315d4946e8a4b5" translate="yes" xml:space="preserve">
          <source>The year of a &lt;code&gt;Date&lt;/code&gt; or &lt;code&gt;DateTime&lt;/code&gt; as an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;としての &lt;code&gt;Date&lt;/code&gt; または &lt;code&gt;DateTime&lt;/code&gt; の年。</target>
        </trans-unit>
        <trans-unit id="8d787e71667084faaf9bf03d9298e5d0d53aa7e6" translate="yes" xml:space="preserve">
          <source>Then if the environment variable &lt;code&gt;JULIA_BINDIR&lt;/code&gt; is set to &lt;code&gt;$JULIA_DIR/bin&lt;/code&gt;, the output &lt;code&gt;test&lt;/code&gt; program can be executed.</source>
          <target state="translated">次に、環境変数 &lt;code&gt;JULIA_BINDIR&lt;/code&gt; が &lt;code&gt;$JULIA_DIR/bin&lt;/code&gt; 設定されている場合、出力 &lt;code&gt;test&lt;/code&gt; プログラムを実行できます。</target>
        </trans-unit>
        <trans-unit id="4d6412317563b7f3c5f3f315499f2ccbf4c0cedb" translate="yes" xml:space="preserve">
          <source>Then navigate to the directory containing your test file (here assumed to be &lt;code&gt;&quot;runtests.jl&quot;&lt;/code&gt;) and do the following:</source>
          <target state="translated">次に、テストファイルを含むディレクトリ（ここでは &lt;code&gt;&quot;runtests.jl&quot;&lt;/code&gt; と想定）に移動し、次の操作を行います。</target>
        </trans-unit>
        <trans-unit id="37376ba231ea09d81df1a6ce675e26bfeb779597" translate="yes" xml:space="preserve">
          <source>Then the internal methods &lt;code&gt;_fA&lt;/code&gt; and &lt;code&gt;_fB&lt;/code&gt; can dispatch on &lt;code&gt;y&lt;/code&gt; without concern about ambiguities with each other with respect to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">次に、内部メソッド &lt;code&gt;_fA&lt;/code&gt; および &lt;code&gt;_fB&lt;/code&gt; は、 &lt;code&gt;x&lt;/code&gt; に関する互いのあいまいさを気にすることなく、 &lt;code&gt;y&lt;/code&gt; にディスパッチできます。</target>
        </trans-unit>
        <trans-unit id="8a87872d7de61942177513edb4dd2621b2f6b9fd" translate="yes" xml:space="preserve">
          <source>Then, replace the main() function in the project with this code:</source>
          <target state="translated">そして、プロジェクト内のmain()関数をこのコードに置き換えます。</target>
        </trans-unit>
        <trans-unit id="a59a7debbc5dd22ea37ee07cde6e2c750243ab3c" translate="yes" xml:space="preserve">
          <source>There Does Not Exist</source>
          <target state="translated">存在しない</target>
        </trans-unit>
        <trans-unit id="174782af6882dfdbfbff70b32afe8068951f600e" translate="yes" xml:space="preserve">
          <source>There Exists</source>
          <target state="translated">存在する</target>
        </trans-unit>
        <trans-unit id="f661b9bec6d9caa654535733d72b2847ffe7c84b" translate="yes" xml:space="preserve">
          <source>There also exists a macro &lt;a href=&quot;../../base/base/index#Base.@macroexpand&quot;&gt;&lt;code&gt;@macroexpand&lt;/code&gt;&lt;/a&gt; that is perhaps a bit more convenient than the &lt;code&gt;macroexpand&lt;/code&gt; function:</source>
          <target state="translated">また、おそらく &lt;code&gt;macroexpand&lt;/code&gt; 関数よりも少し便利なマクロ&lt;a href=&quot;../../base/base/index#Base.@macroexpand&quot;&gt; &lt;code&gt;@macroexpand&lt;/code&gt; &lt;/a&gt;マクロ展開が存在します。</target>
        </trans-unit>
        <trans-unit id="3ed131b34b67efd7bcdc68ef678577fe7e39a368" translate="yes" xml:space="preserve">
          <source>There are a few more methods we can extend to give Julia more information about this iterable collection. We know that the elements in a &lt;code&gt;Squares&lt;/code&gt; sequence will always be &lt;code&gt;Int&lt;/code&gt;. By extending the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; method, we can give that information to Julia and help it make more specialized code in the more complicated methods. We also know the number of elements in our sequence, so we can extend &lt;a href=&quot;../../base/collections/index#Base.length&quot;&gt;&lt;code&gt;length&lt;/code&gt;&lt;/a&gt;, too:</source>
          <target state="translated">Juliaにこの反復可能なコレクションに関する詳細情報を提供するために拡張できるメソッドがいくつかあります。 &lt;code&gt;Squares&lt;/code&gt; シーケンスの要素は常に &lt;code&gt;Int&lt;/code&gt; になることがわかっています。&lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt;メソッドを拡張することにより、その情報をJuliaに提供し、より複雑なメソッドでより専門的なコードを作成できるようにします。シーケンスの要素数もわかっているので、&lt;a href=&quot;../../base/collections/index#Base.length&quot;&gt; &lt;code&gt;length&lt;/code&gt; &lt;/a&gt;も拡張できます。</target>
        </trans-unit>
        <trans-unit id="e637cf035706fa4551de012038849a438d7502e7" translate="yes" xml:space="preserve">
          <source>There are a few noteworthy high-level features about Julia's strings:</source>
          <target state="translated">ジュリアの弦については、注目すべき高レベルの特徴がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="8f24a9d06c3582bc696ff9d33986f227daf0b74d" translate="yes" xml:space="preserve">
          <source>There are a number useful features unique to interactive work. In addition to showing the result, the REPL also binds the result to the variable &lt;code&gt;ans&lt;/code&gt;. A trailing semicolon on the line can be used as a flag to suppress showing the result.</source>
          <target state="translated">インタラクティブな作業に固有の便利な機能がいくつかあります。REPLは結果を表示するだけでなく、結果を変数 &lt;code&gt;ans&lt;/code&gt; にバインドします。行の末尾のセミコロンは、結果の表示を抑制するフラグとして使用できます。</target>
        </trans-unit>
        <trans-unit id="bd609a022f57cae38b5deceaa4789ea9e71b2150" translate="yes" xml:space="preserve">
          <source>There are also two variants with a &lt;code&gt;mime&lt;/code&gt; argument (a MIME type string, such as &lt;code&gt;&quot;image/png&quot;&lt;/code&gt;), which attempt to display &lt;code&gt;x&lt;/code&gt; using the requested MIME type &lt;em&gt;only&lt;/em&gt;, throwing a &lt;code&gt;MethodError&lt;/code&gt; if this type is not supported by either the display(s) or by &lt;code&gt;x&lt;/code&gt;. With these variants, one can also supply the &quot;raw&quot; data in the requested MIME type by passing &lt;code&gt;x::AbstractString&lt;/code&gt; (for MIME types with text-based storage, such as text/html or application/postscript) or &lt;code&gt;x::Vector{UInt8}&lt;/code&gt; (for binary MIME types).</source>
          <target state="translated">&lt;code&gt;mime&lt;/code&gt; 引数（ &lt;code&gt;&quot;image/png&quot;&lt;/code&gt; などのMIMEタイプの文字列）を持つ2つのバリアントもあります。これらは、要求されたMIMEタイプ&lt;em&gt;のみ&lt;/em&gt;を使用して &lt;code&gt;x&lt;/code&gt; を表示しようとし、このタイプがどちらのディスプレイでもサポートされていない場合に &lt;code&gt;MethodError&lt;/code&gt; をスローします（ s）または &lt;code&gt;x&lt;/code&gt; による。これらのバリアントでは、 &lt;code&gt;x::AbstractString&lt;/code&gt; （text / htmlやapplication / postscriptなどのテキストベースのストレージを持つMIMEタイプの場合）または &lt;code&gt;x::Vector{UInt8}&lt;/code&gt; を渡すことで、要求されたMIMEタイプの「生」データを提供することもできます。UInt8}（バイナリMIMEタイプの場合）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="da6a42179d7b850f29255071dd5215f3813868d7" translate="yes" xml:space="preserve">
          <source>There are currently four sorting algorithms available in base Julia:</source>
          <target state="translated">現在、Juliaベースでは4つのソートアルゴリズムが利用可能です。</target>
        </trans-unit>
        <trans-unit id="f7b934f4e2dd58131955f021068fd71f3d77a05f" translate="yes" xml:space="preserve">
          <source>There are differences between &lt;code&gt;@macroexpand&lt;/code&gt; and &lt;a href=&quot;#Base.macroexpand&quot;&gt;&lt;code&gt;macroexpand&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@macroexpand&lt;/code&gt; と&lt;a href=&quot;#Base.macroexpand&quot;&gt; &lt;code&gt;macroexpand&lt;/code&gt; に&lt;/a&gt;は違いがあります。</target>
        </trans-unit>
        <trans-unit id="04c5ce881d71fd5eb88fb1f43a2852a100537a0d" translate="yes" xml:space="preserve">
          <source>There are four general kinds of cases where constructors differ from &lt;code&gt;convert&lt;/code&gt;:</source>
          <target state="translated">コンストラクターが &lt;code&gt;convert&lt;/code&gt; と異なる一般的なケースは4つあります。</target>
        </trans-unit>
        <trans-unit id="28b7763a452b0a0124e162d0088e4f9f3b24f691" translate="yes" xml:space="preserve">
          <source>There are many more interesting things that you can measure about your program, to get a comprehensive list please read the &lt;a href=&quot;http://www.brendangregg.com/perf.html&quot;&gt;Linux perf examples page&lt;/a&gt;.</source>
          <target state="translated">プログラムについて測定できるさらに多くの興味深い事柄があり&lt;a href=&quot;http://www.brendangregg.com/perf.html&quot;&gt;ます&lt;/a&gt;。包括的なリストを取得するには、Linuxのパフォーマンス例のページをご覧ください。</target>
        </trans-unit>
        <trans-unit id="e179a904cbafe3721438ffeb346220f23d78177e" translate="yes" xml:space="preserve">
          <source>There are of course a few exceptions. For example, in &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;, the type should always come first. In &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;, the value comes before the indices so that the indices can be provided as varargs.</source>
          <target state="translated">もちろん、いくつかの例外があります。たとえば、&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;では、型が常に最初に来る必要があります。では&lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;、値がインデックスの前に来るため、インデックスを可変引数として提供できます。</target>
        </trans-unit>
        <trans-unit id="35f0957d73c0fe5b71dd1c5c8bdab57684e38edf" translate="yes" xml:space="preserve">
          <source>There are several different ways to think about this iterator wrapper:</source>
          <target state="translated">このイテレータのラッパーについては、いくつかの異なる考え方があります。</target>
        </trans-unit>
        <trans-unit id="bbb07cbd34fbfc1d048df46439a5fa70e66eefad" translate="yes" xml:space="preserve">
          <source>There are several special types to be aware of, as no other type can be defined to behave the same:</source>
          <target state="translated">同じように振る舞うタイプは他には定義できないので、いくつかの特別なタイプがあるので注意が必要です。</target>
        </trans-unit>
        <trans-unit id="89a2008a07be2d9f32034d88c362d6f0eb2082a1" translate="yes" xml:space="preserve">
          <source>There are situations when you want to construct a string or use string semantics, but the behavior of the standard string construct is not quite what is needed. For these kinds of situations, Julia provides &lt;a href=&quot;#non-standard-string-literals-1&quot;&gt;non-standard string literals&lt;/a&gt;. A non-standard string literal looks like a regular double-quoted string literal, but is immediately prefixed by an identifier, and doesn't behave quite like a normal string literal. Regular expressions, byte array literals and version number literals, as described below, are some examples of non-standard string literals. Other examples are given in the &lt;a href=&quot;../metaprogramming/index#Metaprogramming-1&quot;&gt;Metaprogramming&lt;/a&gt; section.</source>
          <target state="translated">文字列を構築したり、文字列のセマンティクスを使用したりする場合がありますが、標準の文字列構造の動作は、まったく必要なものではありません。このような状況のために、Juliaは&lt;a href=&quot;#non-standard-string-literals-1&quot;&gt;非標準の文字列リテラルを&lt;/a&gt;提供しています。非標準の文字列リテラルは、通常の二重引用符付き文字列リテラルのように見えますが、すぐに識別子が前に付けられ、通常の文字列リテラルのようには動作しません。正規表現、バイト配列リテラル、およびバージョン番号リテラルは、以下で説明するように、非標準の文字列リテラルの例です。その他の例は、&lt;a href=&quot;../metaprogramming/index#Metaprogramming-1&quot;&gt;メタプログラミングの&lt;/a&gt;セクションに記載されています。</target>
        </trans-unit>
        <trans-unit id="89cbb0c73360645fdecca6950c82515a07e71685" translate="yes" xml:space="preserve">
          <source>There are situations where it may not make sense for type parameters to range freely over all possible types. In such situations, one can constrain the range of &lt;code&gt;T&lt;/code&gt; like so:</source>
          <target state="translated">型パラメーターがすべての可能な型に自由に及ぶことが意味をなさない場合があります。このような状況では、 &lt;code&gt;T&lt;/code&gt; の範囲を次のように制限できます。</target>
        </trans-unit>
        <trans-unit id="7fd0dbd27001bbf0cf571035d6ca76de3cfc30cb" translate="yes" xml:space="preserve">
          <source>There are some functions to control the GC. In normal use cases, these should not be necessary.</source>
          <target state="translated">GC を制御するための機能がいくつかあります。通常の使用例では、これらは必要ありません。</target>
        </trans-unit>
        <trans-unit id="f09765a26c89d3ba4efc525f188b8d20fe2e6806" translate="yes" xml:space="preserve">
          <source>There are some keys which allow automatically generated log data to be overridden:</source>
          <target state="translated">自動生成されたログデータを上書きできるようにするキーがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="a452182cf4d04b3b872134735654a28996e85391" translate="yes" xml:space="preserve">
          <source>There are three important standard modules:</source>
          <target state="translated">重要な標準モジュールは3つあります。</target>
        </trans-unit>
        <trans-unit id="7aeed63be2ceefd859fdddad806d6d15b8832022" translate="yes" xml:space="preserve">
          <source>There are three logger types provided by the library. &lt;a href=&quot;#Logging.ConsoleLogger&quot;&gt;&lt;code&gt;ConsoleLogger&lt;/code&gt;&lt;/a&gt; is the default logger you see when starting the REPL. It displays events in a readable text format and tries to give simple but user friendly control over formatting and filtering. &lt;a href=&quot;#Base.CoreLogging.NullLogger&quot;&gt;&lt;code&gt;NullLogger&lt;/code&gt;&lt;/a&gt; is a convenient way to drop all messages where necessary; it is the logging equivalent of the &lt;a href=&quot;../../base/base/index#Base.devnull&quot;&gt;&lt;code&gt;devnull&lt;/code&gt;&lt;/a&gt; stream. &lt;a href=&quot;#Base.CoreLogging.SimpleLogger&quot;&gt;&lt;code&gt;SimpleLogger&lt;/code&gt;&lt;/a&gt; is a very simplistic text formatting logger, mainly useful for debugging the logging system itself.</source>
          <target state="translated">ライブラリによって提供される3つのロガータイプがあります。&lt;a href=&quot;#Logging.ConsoleLogger&quot;&gt; &lt;code&gt;ConsoleLogger&lt;/code&gt; &lt;/a&gt;は、REPLの起動時に表示されるデフォルトのロガーです。これは、読みやすいテキスト形式でイベントを表示し、書式設定とフィルタリングを簡単でユーザーフレンドリーな制御を提供しようとします。&lt;a href=&quot;#Base.CoreLogging.NullLogger&quot;&gt; &lt;code&gt;NullLogger&lt;/code&gt; &lt;/a&gt;は、必要に応じてすべてのメッセージをドロップする便利な方法です。これは、&lt;a href=&quot;../../base/base/index#Base.devnull&quot;&gt; &lt;code&gt;devnull&lt;/code&gt; &lt;/a&gt;ストリームと同等のロギングです。&lt;a href=&quot;#Base.CoreLogging.SimpleLogger&quot;&gt; &lt;code&gt;SimpleLogger&lt;/code&gt; &lt;/a&gt;は非常に単純化されたテキストフォーマットロガーで、主にロギングシステム自体のデバッグに役立ちます。</target>
        </trans-unit>
        <trans-unit id="39bf1c403bd69afc5e26a9a958d5e1ff68b86fdd" translate="yes" xml:space="preserve">
          <source>There are three possible points of return from this function, returning the values of three different expressions, depending on the values of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The &lt;code&gt;return&lt;/code&gt; on the last line could be omitted since it is the last expression.</source>
          <target state="translated">この関数から返される可能性のあるポイントは3つあり、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; の値に応じて、3つの異なる式の値を返します。最後の式は最後の式なので、最後の行の &lt;code&gt;return&lt;/code&gt; は省略できます。</target>
        </trans-unit>
        <trans-unit id="18fca925f2f77e2b65c8fdde85952641e1650d33" translate="yes" xml:space="preserve">
          <source>There are three specified standard floating-point values that do not correspond to any point on the real number line:</source>
          <target state="translated">実数線上のどの点にも対応しない浮動小数点の指定標準値が3つあります。</target>
        </trans-unit>
        <trans-unit id="2ce18266eafd4e5743ff642c71c4f327eae5b08a" translate="yes" xml:space="preserve">
          <source>There are two categories: generating values from a type (e.g. &lt;code&gt;rand(Int)&lt;/code&gt;), or from a collection (e.g. &lt;code&gt;rand(1:3)&lt;/code&gt;). The simple cases are explained first, and more advanced usage is presented later. We assume here that the choice of algorithm is independent of the RNG, so we use &lt;code&gt;AbstractRNG&lt;/code&gt; in our signatures.</source>
          <target state="translated">2つのカテゴリがあります。型から値を生成する（例： &lt;code&gt;rand(Int)&lt;/code&gt; ）、またはコレクションから値を生成する（例： &lt;code&gt;rand(1:3)&lt;/code&gt; ）。簡単なケースを最初に説明し、より高度な使用法については後で説明します。ここでは、アルゴリズムの選択はRNGから独立していると想定しているため、シグネチャでは &lt;code&gt;AbstractRNG&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="57f9b987aba6af24cda8e7334000e333dbb62bc6" translate="yes" xml:space="preserve">
          <source>There are two constructs for repeated evaluation of expressions: the &lt;code&gt;while&lt;/code&gt; loop and the &lt;code&gt;for&lt;/code&gt; loop. Here is an example of a &lt;code&gt;while&lt;/code&gt; loop:</source>
          <target state="translated">式の繰り返し評価には、 &lt;code&gt;while&lt;/code&gt; ループと &lt;code&gt;for&lt;/code&gt; ループの2つの構成があります。以下は、 &lt;code&gt;while&lt;/code&gt; ループの例です。</target>
        </trans-unit>
        <trans-unit id="5da5a1ee059f0ac2e0add637de14f3676c7deb7b" translate="yes" xml:space="preserve">
          <source>There are two different packages named &lt;code&gt;Priv&lt;/code&gt; that the application uses. It uses a private package, which is a root dependency, and a public one, which is an indirect dependency through &lt;code&gt;Pub&lt;/code&gt;. These are differentiated by their distinct UUIDs, and they have different deps:</source>
          <target state="translated">アプリケーションが使用する &lt;code&gt;Priv&lt;/code&gt; という名前の2つの異なるパッケージがあります。ルート依存関係であるプライベートパッケージと、 &lt;code&gt;Pub&lt;/code&gt; を介した間接依存関係であるパブリックパッケージを使用します。これらは異なるUUIDによって区別され、異なるdepを持っています。</target>
        </trans-unit>
        <trans-unit id="a80cf781eb3e259c907910355de5e57b87258bfc" translate="yes" xml:space="preserve">
          <source>There are two mostly orthogonal ways to extend &lt;code&gt;Random&lt;/code&gt; functionalities:</source>
          <target state="translated">&lt;code&gt;Random&lt;/code&gt; 機能を拡張するには、主に直交する2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="f15f1d9e0b0d6aa79c92366d6d55c444ac8dd9c4" translate="yes" xml:space="preserve">
          <source>There are various ways to run Julia code and provide options, similar to those available for the &lt;code&gt;perl&lt;/code&gt; and &lt;code&gt;ruby&lt;/code&gt; programs:</source>
          <target state="translated">Juliaコードを実行してオプションを提供するには、 &lt;code&gt;perl&lt;/code&gt; および &lt;code&gt;ruby&lt;/code&gt; プログラムで使用できる方法と同様のさまざまな方法があります。</target>
        </trans-unit>
        <trans-unit id="fe7ec7d12394b96c015a1c2e093208538245f475" translate="yes" xml:space="preserve">
          <source>There exists no loop-carried memory dependencies</source>
          <target state="translated">ループキャリーメモリの依存関係は存在しません。</target>
        </trans-unit>
        <trans-unit id="dbe9d20052debba9991c8dfc120934a6e59ce3f0" translate="yes" xml:space="preserve">
          <source>There is a convenient syntax for naming such types, similar to the short form of function definition syntax:</source>
          <target state="translated">このような型の命名には、関数定義構文の短縮形に似た便利な構文があります。</target>
        </trans-unit>
        <trans-unit id="e3481a52901e12b38922b7141656dfae7e68cc28" translate="yes" xml:space="preserve">
          <source>There is a second syntactic form of quoting for multiple expressions: blocks of code enclosed in &lt;code&gt;quote ... end&lt;/code&gt;.</source>
          <target state="translated">複数の式を引用する2番目の構文形式があり &lt;code&gt;quote ... end&lt;/code&gt; 囲まれたコードのブロックです。</target>
        </trans-unit>
        <trans-unit id="89fb23b7683ecb8e95311e78406e7a19ca4a906a" translate="yes" xml:space="preserve">
          <source>There is a second, more terse syntax for defining a function in Julia. The traditional function declaration syntax demonstrated above is equivalent to the following compact &quot;assignment form&quot;:</source>
          <target state="translated">Juliaには、関数を定義するための第二の、より簡潔な構文があります。上で示した伝統的な関数宣言構文は、以下のコンパクトな「代入形式」に相当します。</target>
        </trans-unit>
        <trans-unit id="b0f3efad279d61a3ae46bad7c874ec9a27487608" translate="yes" xml:space="preserve">
          <source>There is a special kind of abstract parametric type that must be mentioned here: singleton types. For each type, &lt;code&gt;T&lt;/code&gt;, the &quot;singleton type&quot; &lt;code&gt;Type{T}&lt;/code&gt; is an abstract type whose only instance is the object &lt;code&gt;T&lt;/code&gt;. Since the definition is a little difficult to parse, let's look at some examples:</source>
          <target state="translated">ここで言及しなければならない特別な種類の抽象パラメトリックタイプがあります。シングルトンタイプです。タイプ &lt;code&gt;T&lt;/code&gt; ごとに、「シングルトンタイプ」 &lt;code&gt;Type{T}&lt;/code&gt; は、オブジェクト &lt;code&gt;T&lt;/code&gt; のみがインスタンスである抽象タイプです。定義を解析するのが少し難しいので、いくつかの例を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="4edd8c08b09effa574afae30fbef7845d91eb8b4" translate="yes" xml:space="preserve">
          <source>There is also a &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; function, and a more general &lt;a href=&quot;../../base/base/index#Base.oftype&quot;&gt;&lt;code&gt;oftype(x, y)&lt;/code&gt;&lt;/a&gt; function, which returns &lt;code&gt;y&lt;/code&gt; converted to the type of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">ある&lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt;機能、より一般的な&lt;a href=&quot;../../base/base/index#Base.oftype&quot;&gt; &lt;code&gt;oftype(x, y)&lt;/code&gt; &lt;/a&gt;返す関数、 &lt;code&gt;y&lt;/code&gt; の型に変換 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="734126eef49207ddeb0d4f566a4461c7a515e501" translate="yes" xml:space="preserve">
          <source>There is also a concise syntax for nested &lt;code&gt;where&lt;/code&gt; expressions. For example, this:</source>
          <target state="translated">ネストされた &lt;code&gt;where&lt;/code&gt; 式の簡潔な構文もあります。たとえば、これ：</target>
        </trans-unit>
        <trans-unit id="3485de030aea8df4c966053791640ea9fedf8c2e" translate="yes" xml:space="preserve">
          <source>There is also a method &lt;code&gt;crc32c(io, nb, crc)&lt;/code&gt; to checksum &lt;code&gt;nb&lt;/code&gt; bytes from a stream &lt;code&gt;io&lt;/code&gt;, or &lt;code&gt;crc32c(io, crc)&lt;/code&gt; to checksum all the remaining bytes. Hence you can do &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open(crc32c, filename)&lt;/code&gt;&lt;/a&gt; to checksum an entire file, or &lt;code&gt;crc32c(seekstart(buf))&lt;/code&gt; to checksum an &lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt;&lt;code&gt;IOBuffer&lt;/code&gt;&lt;/a&gt; without calling &lt;code&gt;take!&lt;/code&gt;.</source>
          <target state="translated">ストリーム &lt;code&gt;io&lt;/code&gt; から &lt;code&gt;nb&lt;/code&gt; バイトをチェックサムするメソッド &lt;code&gt;crc32c(io, nb, crc)&lt;/code&gt; 、または残りのすべてのバイトをチェックサムする &lt;code&gt;crc32c(io, crc)&lt;/code&gt; もあります。したがって&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open(crc32c, filename)&lt;/code&gt; &lt;/a&gt;を実行してファイル全体をチェックサムするか、 &lt;code&gt;crc32c(seekstart(buf))&lt;/code&gt; を実行して&lt;a href=&quot;../../base/io-network/index#Base.IOBuffer&quot;&gt; &lt;code&gt;IOBuffer&lt;/code&gt; &lt;/a&gt;を呼び出さずにIOBufferをチェックサムすることが &lt;code&gt;take!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5507a1ebe82bf577a426867e01303c626cf9abd7" translate="yes" xml:space="preserve">
          <source>There is much more to say about how instances of composite types are created, but that discussion depends on both &lt;a href=&quot;#Parametric-Types-1&quot;&gt;Parametric Types&lt;/a&gt; and on &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;, and is sufficiently important to be addressed in its own section: &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt;.</source>
          <target state="translated">複合型のインスタンスがどのように作成されるかについては、他にも多くの説明がありますが、その説明は、&lt;a href=&quot;#Parametric-Types-1&quot;&gt;パラメトリック型&lt;/a&gt;と&lt;a href=&quot;../methods/index#Methods-1&quot;&gt;メソッドの&lt;/a&gt;両方に依存しており、独自のセクションである&lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;コンストラクタ&lt;/a&gt;で説明するのに十分重要です。</target>
        </trans-unit>
        <trans-unit id="0ae09c7d6ba8798034e4671d0b26e5b85ce05ddc" translate="yes" xml:space="preserve">
          <source>There is no division between object and non-object values: all values in Julia are true objects having a type that belongs to a single, fully connected type graph, all nodes of which are equally first-class as types.</source>
          <target state="translated">オブジェクトと非オブジェクトの間には分け隔てがありません:Juliaのすべての値は、完全に接続された単一の型グラフに属する型を持つ真のオブジェクトであり、すべてのノードは型として等しく一級品です。</target>
        </trans-unit>
        <trans-unit id="799561e1d3a80d4e278504aa2e10c84451ac9ffd" translate="yes" xml:space="preserve">
          <source>There is no invalid (NULL) &lt;code&gt;Ref&lt;/code&gt; in Julia, but a &lt;code&gt;C_NULL&lt;/code&gt; instance of &lt;code&gt;Ptr&lt;/code&gt; can be passed to a &lt;code&gt;ccall&lt;/code&gt; Ref argument.</source>
          <target state="translated">そこには無効（NULL）ではありません &lt;code&gt;Ref&lt;/code&gt; ジュリアでは、しかし、 &lt;code&gt;C_NULL&lt;/code&gt; ののインスタンス &lt;code&gt;Ptr&lt;/code&gt; に渡すことができ &lt;code&gt;ccall&lt;/code&gt; のRef引数。</target>
        </trans-unit>
        <trans-unit id="11bffac25c301a4657b1c60789201ca8aff715a3" translate="yes" xml:space="preserve">
          <source>There is no meaningful concept of a &quot;compile-time type&quot;: the only type a value has is its actual type when the program is running. This is called a &quot;run-time type&quot; in object-oriented languages where the combination of static compilation with polymorphism makes this distinction significant.</source>
          <target state="translated">コンパイル時型」という意味のある概念はありません:値が持つ型は、プログラムが実行されているときの実際の型だけです。これはオブジェクト指向言語では「ランタイム型」と呼ばれ、静的コンパイルとポリモーフィズムの組み合わせにより、この区別が重要になります。</target>
        </trans-unit>
        <trans-unit id="e3d48c4d50de4372a5a2ecbc4a1b8db9674c176e" translate="yes" xml:space="preserve">
          <source>There is no more to the implementation of &lt;code&gt;Val&lt;/code&gt; than this. Some functions in Julia's standard library accept &lt;code&gt;Val&lt;/code&gt; instances as arguments, and you can also use it to write your own functions. For example:</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; の実装はこれ以上ありません。Juliaの標準ライブラリの一部の関数は、 &lt;code&gt;Val&lt;/code&gt; インスタンスを引数として受け入れ、それを使用して独自の関数を作成することもできます。例えば：</target>
        </trans-unit>
        <trans-unit id="225dfa7c16e90d2f9982aa1b83dde6be688afb63" translate="yes" xml:space="preserve">
          <source>There is one additional special calling convention &lt;a href=&quot;../../base/c/index#Core.Intrinsics.llvmcall&quot;&gt;&lt;code&gt;llvmcall&lt;/code&gt;&lt;/a&gt;, which allows inserting calls to LLVM intrinsics directly. This can be especially useful when targeting unusual platforms such as GPGPUs. For example, for &lt;a href=&quot;http://llvm.org/docs/NVPTXUsage.html&quot;&gt;CUDA&lt;/a&gt;, we need to be able to read the thread index:</source>
          <target state="translated">LLVM組み込み関数への呼び出しを直接挿入できる、1つの特別な呼び出し規則&lt;a href=&quot;../../base/c/index#Core.Intrinsics.llvmcall&quot;&gt; &lt;code&gt;llvmcall&lt;/code&gt; &lt;/a&gt;があります。これは、GPGPUなどの特殊なプラットフォームを対象とする場合に特に役立ちます。たとえば、&lt;a href=&quot;http://llvm.org/docs/NVPTXUsage.html&quot;&gt;CUDAの&lt;/a&gt;場合、スレッドインデックスを読み取ることができる必要があります。</target>
        </trans-unit>
        <trans-unit id="982d9172cf71b589801a04a1718b7e1140ec78b8" translate="yes" xml:space="preserve">
          <source>There is only one difference, and on the surface (syntax-wise) it may seem very minor. The difference between &lt;code&gt;using&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; is that with &lt;code&gt;using&lt;/code&gt; you need to say &lt;code&gt;function Foo.bar(..&lt;/code&gt; to extend module Foo's function bar with a new method, but with &lt;code&gt;import Foo.bar&lt;/code&gt;, you only need to say &lt;code&gt;function bar(...&lt;/code&gt; and it automatically extends module Foo's function bar.</source>
          <target state="translated">違いは1つだけであり、表面的には（構文的に）非常にマイナーに見えるかもしれません。違い &lt;code&gt;using&lt;/code&gt; して &lt;code&gt;import&lt;/code&gt; でていることである &lt;code&gt;using&lt;/code&gt; 、あなたが言う必要がある &lt;code&gt;function Foo.bar(..&lt;/code&gt; 新しい方法でモジュールのFooの機能バーを拡張することではなくて &lt;code&gt;import Foo.bar&lt;/code&gt; 、あなただけ言う必要が &lt;code&gt;function bar(...&lt;/code&gt; モジュールFooの機能バーを自動的に拡張します。</target>
        </trans-unit>
        <trans-unit id="40b79a3c7d53b455d5a062d0c3faf4f4007912a3" translate="yes" xml:space="preserve">
          <source>There is some overlap between these rules since the behavior of &lt;code&gt;\x&lt;/code&gt; and octal escapes less than 0x80 (128) are covered by both of the first two rules, but here these rules agree. Together, these rules allow one to easily use ASCII characters, arbitrary byte values, and UTF-8 sequences to produce arrays of bytes. Here is an example using all three:</source>
          <target state="translated">&lt;code&gt;\x&lt;/code&gt; の動作と0x80（128）未満の8進エスケープは最初の2つの規則の両方でカバーされるため、これらの規則にはいくつかの重複がありますが、ここではこれらの規則は一致しています。これらの規則により、ASCII文字、任意のバイト値、およびUTF-8シーケンスを簡単に使用してバイトの配列を生成できます。 3つすべてを使用した例を次に示します。</target>
        </trans-unit>
        <trans-unit id="5a8e36fc8e9774033114f307d267a46fecf4de03" translate="yes" xml:space="preserve">
          <source>There is yet another case that the actual &lt;code&gt;@assert&lt;/code&gt; macro handles: what if, in addition to printing &quot;a should equal b,&quot; we wanted to print their values? One might naively try to use string interpolation in the custom message, e.g., &lt;code&gt;@assert a==b &quot;a ($a) should equal b ($b)!&quot;&lt;/code&gt;, but this won't work as expected with the above macro. Can you see why? Recall from &lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;string interpolation&lt;/a&gt; that an interpolated string is rewritten to a call to &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt;. Compare:</source>
          <target state="translated">実際の &lt;code&gt;@assert&lt;/code&gt; マクロが処理するもう1つのケースがあります。「aはbと等しい」を出力することに加えて、それらの値を出力したいとしたらどうでしょうか。たとえば、 &lt;code&gt;@assert a==b &quot;a ($a) should equal b ($b)!&quot;&lt;/code&gt; 、単純にカスタムメッセージで文字列補間を使用しようとするかもしれません。、しかしこれは上記のマクロでは期待通りに機能しません。理由が分かりますか？&lt;a href=&quot;../strings/index#string-interpolation-1&quot;&gt;文字列補間&lt;/a&gt;から、補間された文字列が&lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; の&lt;/a&gt;呼び出しに書き換えられることを思い出してください。比較：</target>
        </trans-unit>
        <trans-unit id="d3e7d0ac84e899740c4a2f0bb3ee4413427fcc34" translate="yes" xml:space="preserve">
          <source>There's also some key value pairs which have conventional meaning:</source>
          <target state="translated">また、従来の意味を持つキー値のペアもあります。</target>
        </trans-unit>
        <trans-unit id="f6f36ec125f2f895a5ef2bd1d15fb610bf42b808" translate="yes" xml:space="preserve">
          <source>Therefore</source>
          <target state="translated">Therefore</target>
        </trans-unit>
        <trans-unit id="2f243754615f97fed5cd732a70910cb99d584308" translate="yes" xml:space="preserve">
          <source>Therefore, if an &lt;code&gt;Array&lt;/code&gt; contains data in the wrong format, it will have to be explicitly converted using a call such as &lt;code&gt;trunc(Int32, a)&lt;/code&gt;.</source>
          <target state="translated">したがって、 &lt;code&gt;Array&lt;/code&gt; に誤った形式のデータが含まれている場合は、 &lt;code&gt;trunc(Int32, a)&lt;/code&gt; などの呼び出しを使用して明示的に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="db219bff6d21bdc3e30fad396993a55966a94d9d" translate="yes" xml:space="preserve">
          <source>These are all single-argument functions, with &lt;code&gt;atan&lt;/code&gt; also accepting two arguments corresponding to a traditional &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt;&lt;code&gt;atan2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">これらはすべて単一引数関数であり、 &lt;code&gt;atan&lt;/code&gt; は従来の&lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt; &lt;code&gt;atan2&lt;/code&gt; &lt;/a&gt;関数に対応する2つの引数も受け入れます。</target>
        </trans-unit>
        <trans-unit id="14803da413b77436b3c2d4357e087f5e0536c055" translate="yes" xml:space="preserve">
          <source>These are some minor points that might help in tight inner loops.</source>
          <target state="translated">これらは、タイトなインナーループに役立ちそうなマイナーなポイントです。</target>
        </trans-unit>
        <trans-unit id="f489d10be7b6a63303842ebf419258e8b767140d" translate="yes" xml:space="preserve">
          <source>These are standard system mutexes for locking critical sections of logic.</source>
          <target state="translated">これらは、ロジックの重要なセクションをロックするための標準的なシステムミューテックスです。</target>
        </trans-unit>
        <trans-unit id="d1641abea44eab3cf0ec515a65636237d8dacb4d" translate="yes" xml:space="preserve">
          <source>These building blocks are used to create the regular synchronization objects.</source>
          <target state="translated">これらのビルディングブロックは、通常の同期オブジェクトを作成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="565962f2637fab496a10fd1e88eadfa7fec7f65c" translate="yes" xml:space="preserve">
          <source>These can be intermixed to create &lt;strong&gt;a stacked environment&lt;/strong&gt;: an ordered set of project environments and package directories, overlaid to make a single composite environment. The precedence and visibility rules then combine to determine which packages are available and where they get loaded from. Julia's load path forms a stacked environment, for example.</source>
          <target state="translated">これらを混合して&lt;strong&gt;、スタック環境&lt;/strong&gt;を作成できます。単一の複合環境を作成するためにオーバーレイされた、プロジェクト環境とパッケージディレクトリの順序付けされたセットです。次に、優先順位と可視性のルールが組み合わされて、利用可能なパッケージとそれらがどこからロードされるかが決定されます。たとえば、Juliaのロードパスはスタック環境を形成します。</target>
        </trans-unit>
        <trans-unit id="ad9e158cfed42f0988f112a79734599400b1a65e" translate="yes" xml:space="preserve">
          <source>These environment each serve a different purpose:</source>
          <target state="translated">これらの環境はそれぞれ異なる目的を持っています。</target>
        </trans-unit>
        <trans-unit id="df0dd5f0a0b3669798f0ca8386e219bbefc17e9d" translate="yes" xml:space="preserve">
          <source>These environment variables only have an effect if Julia was compiled with garbage-collection debugging (that is, if &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; in the build configuration).</source>
          <target state="translated">これらの環境変数は、Juliaがガベージコレクションデバッグでコンパイルされた場合（つまり、ビルド構成で &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; が &lt;code&gt;1&lt;/code&gt; に設定されている場合）にのみ効果があります。</target>
        </trans-unit>
        <trans-unit id="de0986fe52ee36d8b5c27e28a863c7c354ad5a04" translate="yes" xml:space="preserve">
          <source>These examples are hopefully helpful to illustrate how generated functions work, both in the definition end and at the call site; however, &lt;em&gt;don't copy them&lt;/em&gt;, for the following reasons:</source>
          <target state="translated">これらの例は、生成された関数が定義の終わりと呼び出しサイトの両方でどのように機能するかを示すのに役立つと期待されます。ただし、次の理由により、&lt;em&gt;それらをコピーしない&lt;/em&gt;で&lt;em&gt;ください&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e22560ff89133b8a8d38ebe85a09966debefcae5" translate="yes" xml:space="preserve">
          <source>These functions are useful in &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;Numeric Comparisons&lt;/a&gt; to avoid overhead from unnecessary &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;type conversion&lt;/a&gt;.</source>
          <target state="translated">これらの関数は、&lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;数値比較で&lt;/a&gt;不要な&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;型変換&lt;/a&gt;によるオーバーヘッドを回避するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="901a72532a01b48c0a0b20d9a2bd0c5a053c7001" translate="yes" xml:space="preserve">
          <source>These method definitions say that in the absence of more specific rules for adding, subtracting, multiplying and dividing pairs of numeric values, promote the values to a common type and then try again. That's all there is to it: nowhere else does one ever need to worry about promotion to a common numeric type for arithmetic operations &amp;ndash; it just happens automatically. There are definitions of catch-all promotion methods for a number of other arithmetic and mathematical functions in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt;&lt;code&gt;promotion.jl&lt;/code&gt;&lt;/a&gt;, but beyond that, there are hardly any calls to &lt;code&gt;promote&lt;/code&gt; required in Julia Base. The most common usages of &lt;code&gt;promote&lt;/code&gt; occur in outer constructors methods, provided for convenience, to allow constructor calls with mixed types to delegate to an inner type with fields promoted to an appropriate common type. For example, recall that &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt;&lt;code&gt;rational.jl&lt;/code&gt;&lt;/a&gt; provides the following outer constructor method:</source>
          <target state="translated">これらのメソッドの定義では、数値のペアを加算、減算、乗算、および除算するためのより具体的なルールがない場合、値を共通の型に昇格してから再試行すると述べています。これですべてです。算術演算の一般的な数値型への昇格について心配する必要のある場所は他にありません。それは自動的に行われるだけです。内の他の算術関数と数学関数の数のためのキャッチオールプロモーションのメソッドの定義があり&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt; &lt;code&gt;promotion.jl&lt;/code&gt; は&lt;/a&gt;、それを超えて、するほとんどすべての呼び出しがある &lt;code&gt;promote&lt;/code&gt; ジュリアベースで必要が。 &lt;code&gt;promote&lt;/code&gt; の最も一般的な使用法便宜上提供されている外部コンストラクターメソッドで発生し、混合型のコンストラクター呼び出しが、適切な共通型に昇格されたフィールドを持つ内部型に委任できるようにします。たとえば、&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt; &lt;code&gt;rational.jl&lt;/code&gt; &lt;/a&gt;が次の外部コンストラクタメソッドを提供することを思い出してください。</target>
        </trans-unit>
        <trans-unit id="38c599bfc89604d7c3dd9692be93915fc155443a" translate="yes" xml:space="preserve">
          <source>These questions are answered by searching through the project environments listed in &lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt;&lt;code&gt;LOAD_PATH&lt;/code&gt;&lt;/a&gt; for project files (&lt;code&gt;Project.toml&lt;/code&gt; or &lt;code&gt;JuliaProject.toml&lt;/code&gt;), manifest files (&lt;code&gt;Manifest.toml&lt;/code&gt; or &lt;code&gt;JuliaManifest.toml&lt;/code&gt;), or folders of source files.</source>
          <target state="translated">これらの質問は、&lt;a href=&quot;../../base/constants/index#Base.LOAD_PATH&quot;&gt; &lt;code&gt;LOAD_PATH&lt;/code&gt; &lt;/a&gt;にリストされているプロジェクト環境を検索して、プロジェクトファイル（ &lt;code&gt;Project.toml&lt;/code&gt; または &lt;code&gt;JuliaProject.toml&lt;/code&gt; ）、マニフェストファイル（ &lt;code&gt;Manifest.toml&lt;/code&gt; または &lt;code&gt;JuliaManifest.toml&lt;/code&gt; ）、またはソースファイルのフォルダーを検索することで回答されます。</target>
        </trans-unit>
        <trans-unit id="9e5166e13cc42aee4b6f34ab71374c703764b19f" translate="yes" xml:space="preserve">
          <source>These rules indicate that the combination of a &lt;code&gt;SparseVecStyle&lt;/code&gt; with 0- or 1-dimensional arrays yields another &lt;code&gt;SparseVecStyle&lt;/code&gt;, that its combination with a 2-dimensional array yields a &lt;code&gt;SparseMatStyle&lt;/code&gt;, and anything of higher dimensionality falls back to the dense arbitrary-dimensional framework. These rules allow broadcasting to keep the sparse representation for operations that result in one or two dimensional outputs, but produce an &lt;code&gt;Array&lt;/code&gt; for any other dimensionality.</source>
          <target state="translated">これらのルールは、 &lt;code&gt;SparseVecStyle&lt;/code&gt; と0または1次元配列の組み合わせが別の &lt;code&gt;SparseVecStyle&lt;/code&gt; を生成すること、2次元配列との &lt;code&gt;SparseMatStyle&lt;/code&gt; 生成すること、およびより高い次元のすべてが密な任意次元フレームワークにフォールバックすることを示します。これらのルールにより、ブロードキャストは、1次元または2次元の出力をもたらす操作のスパース表現を維持しますが、他の次元の &lt;code&gt;Array&lt;/code&gt; を生成します。</target>
        </trans-unit>
        <trans-unit id="ff63dfa77616c617504be7f6834247f76c057dc5" translate="yes" xml:space="preserve">
          <source>These values are &lt;code&gt;2.0^-23&lt;/code&gt; and &lt;code&gt;2.0^-52&lt;/code&gt; as &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values, respectively. The &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; function can also take a floating-point value as an argument, and gives the absolute difference between that value and the next representable floating point value. That is, &lt;code&gt;eps(x)&lt;/code&gt; yields a value of the same type as &lt;code&gt;x&lt;/code&gt; such that &lt;code&gt;x + eps(x)&lt;/code&gt; is the next representable floating-point value larger than &lt;code&gt;x&lt;/code&gt;:</source>
          <target state="translated">これらの値は、それぞれ&lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;値として &lt;code&gt;2.0^-23&lt;/code&gt; および &lt;code&gt;2.0^-52&lt;/code&gt; です。&lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt;機能はまた、引数として浮動小数点値をとり、その値と次の表現の浮動小数点値の間の絶対差を与えることができます。すなわち、 &lt;code&gt;eps(x)&lt;/code&gt; 同じタイプの値が得られる &lt;code&gt;x&lt;/code&gt; となるように &lt;code&gt;x + eps(x)&lt;/code&gt; 、次の表現の浮動小数点値よりも大きい場合 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f33ed7c0575b9d7d40952cddc046e39e47a4df14" translate="yes" xml:space="preserve">
          <source>They are explicitly declared.</source>
          <target state="translated">それらは明示的に宣言されています。</target>
        </trans-unit>
        <trans-unit id="9da6c9effd58ab0ae90e923f7a38a897dca353b9" translate="yes" xml:space="preserve">
          <source>They have explicitly declared supertypes.</source>
          <target state="translated">彼らは明示的にスーパータイプを宣言しています。</target>
        </trans-unit>
        <trans-unit id="6e52fab1fc6f56c83a090442135c118d8a782f83" translate="yes" xml:space="preserve">
          <source>They have names.</source>
          <target state="translated">彼らには名前がある</target>
        </trans-unit>
        <trans-unit id="062847d8bdfc031c0804b383d54688583d1d3428" translate="yes" xml:space="preserve">
          <source>They may have parameters.</source>
          <target state="translated">それらはパラメータを持っているかもしれません。</target>
        </trans-unit>
        <trans-unit id="ce535b7c90d1f3779f26e6dbf670c470fd87540b" translate="yes" xml:space="preserve">
          <source>Thin Space</source>
          <target state="translated">薄い空間</target>
        </trans-unit>
        <trans-unit id="794b36899e8ad96433bb7cbe178ed7bf875ad605" translate="yes" xml:space="preserve">
          <source>This &quot;declaration&quot; behavior only occurs in specific contexts:</source>
          <target state="translated">この &quot;宣言 &quot;の動作は、特定のコンテキストでのみ発生します。</target>
        </trans-unit>
        <trans-unit id="2d8272048e9f98c6a3a33f1987ea12ed1eecadb9" translate="yes" xml:space="preserve">
          <source>This adds the numbers first, then finds the square root of the result.</source>
          <target state="translated">これは、最初に数字を足して、結果の平方根を見つけます。</target>
        </trans-unit>
        <trans-unit id="7e48b7632d07fb8a10c769f17c80cd8b54e9e2ae" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;a&lt;/code&gt; to be of any type. This can often be useful, but it does have a downside: for objects of type &lt;code&gt;MyAmbiguousType&lt;/code&gt;, the compiler will not be able to generate high-performance code. The reason is that the compiler uses the types of objects, not their values, to determine how to build code. Unfortunately, very little can be inferred about an object of type &lt;code&gt;MyAmbiguousType&lt;/code&gt;:</source>
          <target state="translated">これにより &lt;code&gt;a&lt;/code&gt; を任意のタイプにすることができます。これは多くの場合に役立ちますが、欠点があります &lt;code&gt;MyAmbiguousType&lt;/code&gt; 型のオブジェクトの場合、コンパイラーは高性能のコードを生成できません。その理由は、コンパイラーがコードの作成方法を決定するために、値ではなくオブジェクトのタイプを使用するためです。残念ながら、タイプ &lt;code&gt;MyAmbiguousType&lt;/code&gt; のオブジェクトについて推測できることはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="e2ab1e715cac0200b469eb5f929c0503f3de4aef" translate="yes" xml:space="preserve">
          <source>This allows a type assertion to be attached to any expression in-place.</source>
          <target state="translated">これにより、型アサーションを任意の式にインプレースでアタッチできるようになります。</target>
        </trans-unit>
        <trans-unit id="3f66025a332eaca14516e5e48d7273aad3164c30" translate="yes" xml:space="preserve">
          <source>This allows calls like the following to work:</source>
          <target state="translated">これにより、以下のような呼び出しが動作するようになります。</target>
        </trans-unit>
        <trans-unit id="c0d02575ed936e3b66af9d0af1e8728459d34bc3" translate="yes" xml:space="preserve">
          <source>This allows functions which operate on indices to work in combination with &lt;code&gt;skipmissing&lt;/code&gt;. This is notably the case for search and find functions, which return indices valid for the object returned by &lt;code&gt;skipmissing&lt;/code&gt; which are also the indices of the matching entries &lt;em&gt;in the parent array&lt;/em&gt;</source>
          <target state="translated">これにより、インデックスを操作する関数を &lt;code&gt;skipmissing&lt;/code&gt; と組み合わせて機能させることができます。これは特に&lt;em&gt;、親配列内の&lt;/em&gt;一致するエントリのインデックスでもある &lt;code&gt;skipmissing&lt;/code&gt; によって返されたオブジェクトに対して有効なインデックスを返す検索および検索関数の場合です。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="964d516d9978a231b3ac23253bbb246eab6f09f8" translate="yes" xml:space="preserve">
          <source>This approach works very well: the compiler can figure out that &lt;code&gt;A&lt;/code&gt; is an &lt;code&gt;Array{Float64,2}&lt;/code&gt; because it knows the type of the fill value (&lt;code&gt;5.0::Float64&lt;/code&gt;) and the dimensionality (&lt;code&gt;(3, 3)::NTuple{2,Int}&lt;/code&gt;). This implies that the compiler can generate very efficient code for any future usage of &lt;code&gt;A&lt;/code&gt; in the same function.</source>
          <target state="translated">このアプローチは非常にうまく機能します。フィル値のタイプ（ &lt;code&gt;5.0::Float64&lt;/code&gt; ）と次元数（ &lt;code&gt;(3, 3)::NTuple{2,Int}&lt;/code&gt; わかっているため、コンパイラーは &lt;code&gt;A&lt;/code&gt; が &lt;code&gt;Array{Float64,2}&lt;/code&gt; あることを理解できます。、Int}）。これは、コンパイラが同じ関数で &lt;code&gt;A&lt;/code&gt; を将来使用する場合に非常に効率的なコードを生成できることを意味します。</target>
        </trans-unit>
        <trans-unit id="65ab8a07106b1c3de72359a692edb4ea0bcec610" translate="yes" xml:space="preserve">
          <source>This argument will be evaluated at compile-time, when the containing method is defined.</source>
          <target state="translated">この引数はコンパイル時に評価されます。</target>
        </trans-unit>
        <trans-unit id="88e9b548070741ac9a8e34f0ecf3fa01c0587738" translate="yes" xml:space="preserve">
          <source>This avoids the need to continually check for &lt;code&gt;null&lt;/code&gt; values. However, not all object fields are references. Julia considers some types to be &quot;plain data&quot;, meaning all of their data is self-contained and does not reference other objects. The plain data types consist of primitive types (e.g. &lt;code&gt;Int&lt;/code&gt;) and immutable structs of other plain data types. The initial contents of a plain data type is undefined:</source>
          <target state="translated">これにより、 &lt;code&gt;null&lt;/code&gt; 値を継続的にチェックする必要がなくなります。ただし、すべてのオブジェクトフィールドが参照であるとは限りません。 Juliaは、いくつかのタイプを「プレーンデータ」と見なします。つまり、それらのデータはすべて自己完結型であり、他のオブジェクトを参照しません。プレーンデータ型は、プリミティブ型（ &lt;code&gt;Int&lt;/code&gt; など）と他のプレーンデータ型の不変の構造体で構成されます。プレーンデータタイプの初期コンテンツは未定義です。</target>
        </trans-unit>
        <trans-unit id="a32fb96b8a45f2e62ae5fc588473c2b576e96e47" translate="yes" xml:space="preserve">
          <source>This behavior is an inconvenient consequence of the requirement for type-stability. In the case of &lt;code&gt;sqrt&lt;/code&gt;, most users want &lt;code&gt;sqrt(2.0)&lt;/code&gt; to give a real number, and would be unhappy if it produced the complex number &lt;code&gt;1.4142135623730951 + 0.0im&lt;/code&gt;. One could write the &lt;code&gt;sqrt&lt;/code&gt; function to switch to a complex-valued output only when passed a negative number (which is what &lt;code&gt;sqrt&lt;/code&gt; does in some other languages), but then the result would not be &lt;a href=&quot;#man-type-stability-1&quot;&gt;type-stable&lt;/a&gt; and the &lt;code&gt;sqrt&lt;/code&gt; function would have poor performance.</source>
          <target state="translated">この動作は、型の安定性の要件による不便な結果です。 &lt;code&gt;sqrt&lt;/code&gt; の場合、ほとんどのユーザーは &lt;code&gt;sqrt(2.0)&lt;/code&gt; に実数を与えることを望んでおり、複素数 &lt;code&gt;1.4142135623730951 + 0.0im&lt;/code&gt; 生成された場合は不満です。負の数が渡されたときにのみ &lt;code&gt;sqrt&lt;/code&gt; 関数を記述して複素数値の出力に切り替えることができます（これは他の一部の言語では &lt;code&gt;sqrt&lt;/code&gt; が行うことです）。その結果、&lt;a href=&quot;#man-type-stability-1&quot;&gt;型が安定せ&lt;/a&gt;ず、 &lt;code&gt;sqrt&lt;/code&gt; 関数のパフォーマンスが低下します。 。</target>
        </trans-unit>
        <trans-unit id="df974535f8d9fdf5af581b7209a9a7d77c94fbc7" translate="yes" xml:space="preserve">
          <source>This behavior is based on the observation that when one uses unsigned hex literals for integer values, one typically is using them to represent a fixed numeric byte sequence, rather than just an integer value.</source>
          <target state="translated">この動作は、整数値に符号なし16進リテラルを使用する場合、整数値だけではなく、固定の数値バイト列を表すために使用するのが一般的であるという観察に基づいています。</target>
        </trans-unit>
        <trans-unit id="e939e0293859dfba0c56cba20185fcd5c0865911" translate="yes" xml:space="preserve">
          <source>This behavior is frequently used in Julia to form an alternative to very short &lt;code&gt;if&lt;/code&gt; statements. Instead of &lt;code&gt;if &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt;, one can write &lt;code&gt;&amp;lt;cond&amp;gt; &amp;amp;&amp;amp; &amp;lt;statement&amp;gt;&lt;/code&gt; (which could be read as: &amp;lt;cond&amp;gt; &lt;em&gt;and then&lt;/em&gt; &amp;lt;statement&amp;gt;). Similarly, instead of &lt;code&gt;if ! &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt;, one can write &lt;code&gt;&amp;lt;cond&amp;gt; || &amp;lt;statement&amp;gt;&lt;/code&gt; (which could be read as: &amp;lt;cond&amp;gt; &lt;em&gt;or else&lt;/em&gt; &amp;lt;statement&amp;gt;).</source>
          <target state="translated">この動作はJuliaで頻繁に使用され、非常に短い &lt;code&gt;if&lt;/code&gt; ステートメントの代わりに使用されます。 &lt;code&gt;if &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt; の場合の代わりに、&amp;lt;cond&amp;gt; &lt;code&gt;&amp;lt;cond&amp;gt; &amp;amp;&amp;amp; &amp;lt;statement&amp;gt;&lt;/code&gt; 書くことができます（これは、&amp;lt;cond&amp;gt;の&lt;em&gt;次に&lt;/em&gt; &amp;lt;statement&amp;gt; として読み取ることができます）。同様に、 &lt;code&gt;if ! &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end&lt;/code&gt; 代わりに！ &amp;lt;cond&amp;gt; &amp;lt;statement&amp;gt; end、 &lt;code&gt;&amp;lt;cond&amp;gt; || &amp;lt;statement&amp;gt;&lt;/code&gt; 書くことができます&amp;lt;statement&amp;gt;（これは、&amp;lt;cond&amp;gt; &lt;em&gt;または&lt;/em&gt; &amp;lt;statement&amp;gt; として読み取ることができます）。</target>
        </trans-unit>
        <trans-unit id="d466a277725d7aaf417bf4b4dabee60f49d4157d" translate="yes" xml:space="preserve">
          <source>This behavior may seem slightly odd for a normal variable, but allows for named functions &amp;ndash; which are just normal variables holding function objects &amp;ndash; to be used before they are defined. This allows functions to be defined in whatever order is intuitive and convenient, rather than forcing bottom up ordering or requiring forward declarations, as long as they are defined by the time they are actually called. As an example, here is an inefficient, mutually recursive way to test if positive integers are even or odd:</source>
          <target state="translated">この動作は、通常の変数では少し奇妙に見えるかもしれませんが、名前付き関数（関数オブジェクトを保持する通常の変数にすぎません）を、定義する前に使用できます。これにより、関数が実際に呼び出される時点で定義されている限り、ボトムアップの順序付けを強制したり、前方宣言を要求したりするのではなく、直感的で便利な任意の順序で関数を定義できます。例として、正の整数が偶数か奇数かをテストする非効率的な相互再帰的な方法を次に示します。</target>
        </trans-unit>
        <trans-unit id="3e1626f887cd8eeaf56c26ebd7e57a24196949b2" translate="yes" xml:space="preserve">
          <source>This behavior of this function varies slightly across platforms. See &lt;a href=&quot;https://nodejs.org/api/fs.html#fs_caveats&quot;&gt;https://nodejs.org/api/fs.html#fs_caveats&lt;/a&gt; for more detailed information.</source>
          <target state="translated">この関数のこの動作は、プラットフォームによって若干異なります。詳細については、&lt;a href=&quot;https://nodejs.org/api/fs.html#fs_caveats&quot;&gt;https：//nodejs.org/api/fs.html#fs_caveats&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c6ca83ad215b371ad26283d27822e70d4564ed25" translate="yes" xml:space="preserve">
          <source>This call will appear to do nothing. However, it is possible to check whether an exception was thrown:</source>
          <target state="translated">この呼び出しは何もしていないように見えます。しかし、例外が投げられたかどうかを確認することは可能です。</target>
        </trans-unit>
        <trans-unit id="3faddba8dc5ff630709111fd27507fc4b444f486" translate="yes" xml:space="preserve">
          <source>This can be expressed much more simply with &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot broadcasting&lt;/a&gt; and by combining it with a normal integer index (instead of extracting the first &lt;code&gt;page&lt;/code&gt; from &lt;code&gt;A&lt;/code&gt; as a separate step). It can even be combined with a &lt;code&gt;:&lt;/code&gt; to extract both diagonals from the two pages at the same time:</source>
          <target state="translated">これは、&lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;ドットブロードキャスト&lt;/a&gt;を使用し、通常の整数インデックスと組み合わせると（ &lt;code&gt;A&lt;/code&gt; から最初の &lt;code&gt;page&lt;/code&gt; を個別のステップとして抽出する代わりに）、はるかに簡単に表現できます。 &lt;code&gt;:&lt;/code&gt; と組み合わせて、2つのページから両方の対角線を同時に抽出することもできます。</target>
        </trans-unit>
        <trans-unit id="547aafc7ff388590993edee0cc0798c17880cfea" translate="yes" xml:space="preserve">
          <source>This can be identical to the signature present in the Julia code (like &lt;code&gt;mean(x::AbstractArray)&lt;/code&gt;), or a simplified form. Optional arguments should be represented with their default values (i.e. &lt;code&gt;f(x, y=1)&lt;/code&gt;) when possible, following the actual Julia syntax. Optional arguments which do not have a default value should be put in brackets (i.e. &lt;code&gt;f(x[, y])&lt;/code&gt; and &lt;code&gt;f(x[, y[, z]])&lt;/code&gt;). An alternative solution is to use several lines: one without optional arguments, the other(s) with them. This solution can also be used to document several related methods of a given function. When a function accepts many keyword arguments, only include a &lt;code&gt;&amp;lt;keyword arguments&amp;gt;&lt;/code&gt; placeholder in the signature (i.e. &lt;code&gt;f(x; &amp;lt;keyword arguments&amp;gt;)&lt;/code&gt;), and give the complete list under an &lt;code&gt;# Arguments&lt;/code&gt; section (see point 4 below).</source>
          <target state="translated">これは、Juliaコードに存在するシグニチャー（ &lt;code&gt;mean(x::AbstractArray)&lt;/code&gt; ）と同じにすることも、簡略化した形式にすることもできます。オプションの引数は、実際のJulia構文に従って、可能な場合はデフォルト値（つまり &lt;code&gt;f(x, y=1)&lt;/code&gt; ）で表す必要があります。デフォルト値を持たないオプションの引数は、角括弧で囲む必要があります（つまり、 &lt;code&gt;f(x[, y])&lt;/code&gt; と &lt;code&gt;f(x[, y[, z]])&lt;/code&gt; ）。別の解決策は、いくつかの行を使用することです。1つはオプションの引数なしで、もう1つはそれらを使用します。このソリューションは、特定の関数のいくつかの関連メソッドを文書化するためにも使用できます。関数が多くのキーワード引数を受け入れる場合、シグネチャには &lt;code&gt;&amp;lt;keyword arguments&amp;gt;&lt;/code&gt; プレースホルダーのみを含めます（つまり、 &lt;code&gt;f(x; &amp;lt;keyword arguments&amp;gt;)&lt;/code&gt; ）、および &lt;code&gt;# Arguments&lt;/code&gt; セクションの下に完全なリストを提供します（以下のポイント4を参照）。</target>
        </trans-unit>
        <trans-unit id="48dae0d7f0cfc247d97cdffb950575c2c53131a7" translate="yes" xml:space="preserve">
          <source>This can be remedied by passing the result of &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt;&lt;code&gt;catch_backtrace&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt;&lt;code&gt;stacktrace&lt;/code&gt;&lt;/a&gt;. Instead of returning callstack information for the current context, &lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt;&lt;code&gt;catch_backtrace&lt;/code&gt;&lt;/a&gt; returns stack information for the context of the most recent exception:</source>
          <target state="translated">これは、&lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt; &lt;code&gt;catch_backtrace&lt;/code&gt; &lt;/a&gt;の結果をstacktraceに&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.stacktrace&quot;&gt; &lt;code&gt;stacktrace&lt;/code&gt; &lt;/a&gt;ことで修正できます。現在のコンテキストの&lt;a href=&quot;../../base/base/index#Base.catch_backtrace&quot;&gt; &lt;code&gt;catch_backtrace&lt;/code&gt; &lt;/a&gt;スタック情報を返す代わりに、catch_backtraceは最新の例外のコンテキストのスタック情報を返します。</target>
        </trans-unit>
        <trans-unit id="f23915be66d58b3010247cc477edf10741516449" translate="yes" xml:space="preserve">
          <source>This can be written more concisely and efficiently as:</source>
          <target state="translated">として、より簡潔に効率的に書くことができます。</target>
        </trans-unit>
        <trans-unit id="da228c6572574c6e3edc7a497b323e67243e96a5" translate="yes" xml:space="preserve">
          <source>This can lead to race conditions if another process obtains the same file name and creates the file before you are able to. Using &lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;mktemp()&lt;/code&gt;&lt;/a&gt; is recommended instead.</source>
          <target state="translated">これにより、別のプロセスが同じファイル名を取得し、それが可能になる前にファイルを作成すると、競合状態が発生する可能性があります。代わりに&lt;a href=&quot;#Base.Filesystem.mktemp-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;mktemp()&lt;/code&gt; &lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="464b5fa1d6c0b5441a8fbbb213e02432dc783d43" translate="yes" xml:space="preserve">
          <source>This catch-all is less specific than any other possible method definition for a pair of parameter values, so it will only be called on pairs of arguments to which no other method definition applies.</source>
          <target state="translated">このキャッチオールは、パラメータ値のペアに対する他のどの可能性のあるメソッド定義よりも特異性が低いので、他のメソッド定義が適用されない引数のペアに対してのみ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="0d32190f9f82717ff7b036e591c82b7be9c20e35" translate="yes" xml:space="preserve">
          <source>This chapter covers the technical details of package loading. To install packages, use &lt;a href=&quot;../../stdlib/pkg/index#Pkg-1&quot;&gt;&lt;code&gt;Pkg&lt;/code&gt;&lt;/a&gt;, Julia's built-in package manager, to add packages to your active environment. To use packages already in your active environment, write &lt;code&gt;import X&lt;/code&gt; or &lt;code&gt;using X&lt;/code&gt;, as described in the &lt;a href=&quot;../modules/index#modules-1&quot;&gt;Modules documentation&lt;/a&gt;.</source>
          <target state="translated">この章では、パッケージのロードの技術的な詳細について説明します。パッケージをインストールするには、Juliaの組み込みパッケージマネージャーである&lt;a href=&quot;../../stdlib/pkg/index#Pkg-1&quot;&gt; &lt;code&gt;Pkg&lt;/code&gt; を&lt;/a&gt;使用して、アクティブな環境にパッケージを追加します。すでにアクティブな環境にあるパッケージを使用するには、&lt;a href=&quot;../modules/index#modules-1&quot;&gt;モジュールのドキュメントで&lt;/a&gt;説明されているように、 &lt;code&gt;import X&lt;/code&gt; または &lt;code&gt;using X&lt;/code&gt; て記述します。</target>
        </trans-unit>
        <trans-unit id="4ea11403bb989c686f5968328179e98cbaa9f269" translate="yes" xml:space="preserve">
          <source>This code will not initialize all of &lt;code&gt;a&lt;/code&gt;, since each process will have a separate copy of it. Parallel for loops like these must be avoided. Fortunately, &lt;a href=&quot;#man-shared-arrays-1&quot;&gt;Shared Arrays&lt;/a&gt; can be used to get around this limitation:</source>
          <target state="translated">このコードは、すべての初期化されません各プロセスはそれの別のコピーを持つことになりますから、。このような並列forループは避けなければなりません。さいわい、&lt;a href=&quot;#man-shared-arrays-1&quot;&gt;共有配列&lt;/a&gt;を使用してこの制限を回避できます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d51d7a463700079744f5ff1d3af6ba57fc16feaf" translate="yes" xml:space="preserve">
          <source>This construct implements the pattern of assigning iterations to multiple processes, and combining them with a specified reduction (in this case &lt;code&gt;(+)&lt;/code&gt;). The result of each iteration is taken as the value of the last expression inside the loop. The whole parallel loop expression itself evaluates to the final answer.</source>
          <target state="translated">この構成は、反復を複数のプロセスに割り当て、それらを指定されたリダクション（この場合は &lt;code&gt;(+)&lt;/code&gt; ）と組み合わせるパターンを実装します。各反復の結果は、ループ内の最後の式の値として使用されます。並列ループ式全体が評価され、最終的な回答になります。</target>
        </trans-unit>
        <trans-unit id="56c993971b23a28c699db5a6937a4a9bfd78df8b" translate="yes" xml:space="preserve">
          <source>This construction avoids the multiplication and addition operations.</source>
          <target state="translated">この構造は、掛け算や足し算の操作を避けることができます。</target>
        </trans-unit>
        <trans-unit id="aa8d7cac7cb360d58676d491242e77dac0c56e52" translate="yes" xml:space="preserve">
          <source>This constructor will be invoked by the syntax &lt;code&gt;SummedArray(a)&lt;/code&gt;. The syntax &lt;code&gt;new{T,S}&lt;/code&gt; allows specifying parameters for the type to be constructed, i.e. this call will return a &lt;code&gt;SummedArray{T,S}&lt;/code&gt;. &lt;code&gt;new{T,S}&lt;/code&gt; can be used in any constructor definition, but for convenience the parameters to &lt;code&gt;new{}&lt;/code&gt; are automatically derived from the type being constructed when possible.</source>
          <target state="translated">このコンストラクターは、構文 &lt;code&gt;SummedArray(a)&lt;/code&gt; によって呼び出されます。構文 &lt;code&gt;new{T,S}&lt;/code&gt; では、構築する型のパラメーターを指定できます。つまり、この呼び出しは &lt;code&gt;SummedArray{T,S}&lt;/code&gt; を返します。 &lt;code&gt;new{T,S}&lt;/code&gt; は、任意のコンストラクター定義で使用できますが、便宜上、 &lt;code&gt;new{}&lt;/code&gt; パラメーターは、可能な場合は構築される型から自動的に派生します。</target>
        </trans-unit>
        <trans-unit id="b7a16492f267624e6cffa44c16d2f3cbbc8fdcef" translate="yes" xml:space="preserve">
          <source>This convenience function returns an iterator which filters out &lt;code&gt;missing&lt;/code&gt; values efficiently. It can therefore be used with any function which supports iterators</source>
          <target state="translated">この便利な関数は、 &lt;code&gt;missing&lt;/code&gt; 値を効率的に除外する反復子を返します。したがって、イテレータをサポートする任意の関数で使用できます</target>
        </trans-unit>
        <trans-unit id="7839ec061c3b0d3cae9d3ceb52f6e6b0eb7552ce" translate="yes" xml:space="preserve">
          <source>This convention for ordering arrays is common in many languages like Fortran, Matlab, and R (to name a few). The alternative to column-major ordering is row-major ordering, which is the convention adopted by C and Python (&lt;code&gt;numpy&lt;/code&gt;) among other languages. Remembering the ordering of arrays can have significant performance effects when looping over arrays. A rule of thumb to keep in mind is that with column-major arrays, the first index changes most rapidly. Essentially this means that looping will be faster if the inner-most loop index is the first to appear in a slice expression.</source>
          <target state="translated">配列の順序付けに関するこの規則は、Fortran、Matlab、Rなどの多くの言語で一般的です（いくつか例を挙げます）。列優先順の代わりに行優先順があり、これは他の言語の中でCおよびPython（ &lt;code&gt;numpy&lt;/code&gt; ）で採用されている規則です。配列の順序を覚えておくと、配列をループするときにパフォーマンスに大きな影響を与える可能性があります。経験則として、列優先の配列では、最初のインデックスが最も急速に変化することを覚えておいてください。基本的に、これは、最も内側のループインデックスがスライス式に最初に現れる場合、ループがより高速になることを意味します。</target>
        </trans-unit>
        <trans-unit id="7355c6564b5fcc9846f7acd500769583417df709" translate="yes" xml:space="preserve">
          <source>This creates a 25-by-30000 &lt;code&gt;BitArray&lt;/code&gt;, linked to the file associated with stream &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">これにより、ストリーム &lt;code&gt;io&lt;/code&gt; に関連付けられたファイルにリンクされた25行30000 &lt;code&gt;BitArray&lt;/code&gt; が作成されます。</target>
        </trans-unit>
        <trans-unit id="94e825958b08717e7b2f87e178ba335682000732" translate="yes" xml:space="preserve">
          <source>This creates a function taking one argument &lt;code&gt;x&lt;/code&gt; and returning the value of the polynomial &lt;code&gt;x^2 + 2x - 1&lt;/code&gt; at that value. Notice that the result is a generic function, but with a compiler-generated name based on consecutive numbering.</source>
          <target state="translated">これは、1つの引数 &lt;code&gt;x&lt;/code&gt; を取り、その値で多項式 &lt;code&gt;x^2 + 2x - 1&lt;/code&gt; の値を返す関数を作成します。結果はジェネリック関数ですが、連続した番号付けに基づいてコンパイラが生成した名前であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c16c73de1b45daf105f01df93653955f2810669b" translate="yes" xml:space="preserve">
          <source>This declaration defines a new parametric type, &lt;code&gt;Point{T}&lt;/code&gt;, holding two &quot;coordinates&quot; of type &lt;code&gt;T&lt;/code&gt;. What, one may ask, is &lt;code&gt;T&lt;/code&gt;? Well, that's precisely the point of parametric types: it can be any type at all (or a value of any bits type, actually, although here it's clearly used as a type). &lt;code&gt;Point{Float64}&lt;/code&gt; is a concrete type equivalent to the type defined by replacing &lt;code&gt;T&lt;/code&gt; in the definition of &lt;code&gt;Point&lt;/code&gt; with &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. Thus, this single declaration actually declares an unlimited number of types: &lt;code&gt;Point{Float64}&lt;/code&gt;, &lt;code&gt;Point{AbstractString}&lt;/code&gt;, &lt;code&gt;Point{Int64}&lt;/code&gt;, etc. Each of these is now a usable concrete type:</source>
          <target state="translated">この宣言は、タイプ &lt;code&gt;T&lt;/code&gt; の 2つの「座標」を保持する新しいパラメトリックタイプ &lt;code&gt;Point{T}&lt;/code&gt; 定義します。 、一つは、何であるかを求めることができる &lt;code&gt;T&lt;/code&gt; ？まあ、それがまさにパラメトリックタイプのポイントです。これは、すべてのタイプ（または実際には任意のビットタイプの値ですが、ここではタイプとして明確に使用されています）にすることができます。 &lt;code&gt;Point{Float64}&lt;/code&gt; は、 &lt;code&gt;Point&lt;/code&gt; の定義の &lt;code&gt;T&lt;/code&gt; を&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;で置き換えることによって定義される型と同等の具象型です。したがって、この単一の宣言は、実際には無制限の数の型（ &lt;code&gt;Point{Float64}&lt;/code&gt; 、 &lt;code&gt;Point{AbstractString}&lt;/code&gt; 、 &lt;code&gt;Point{Int64}&lt;/code&gt; など）を宣言します。これらのそれぞれが使用可能な具象型になりました：</target>
        </trans-unit>
        <trans-unit id="b01b6974b06d7624ee6c363ea6ebb8266c1f09ca" translate="yes" xml:space="preserve">
          <source>This declaration has the same effect as the earlier definition of the &lt;code&gt;Foo&lt;/code&gt; type without an explicit inner constructor method. The following two types are equivalent &amp;ndash; one with a default constructor, the other with an explicit constructor:</source>
          <target state="translated">この宣言は、明示的な内部コンストラクタメソッドを持たない &lt;code&gt;Foo&lt;/code&gt; 型の以前の定義と同じ効果があります。次の2つのタイプは同等です。1つはデフォルトのコンストラクター、もう1つは明示的なコンストラクターです。</target>
        </trans-unit>
        <trans-unit id="6cae1102db29e2ef980a4d7e4e7854fb0a34c8cd" translate="yes" xml:space="preserve">
          <source>This dependency graph represented as a dictionary, looks like this:</source>
          <target state="translated">この依存関係グラフを辞書で表すと、次のようになります。</target>
        </trans-unit>
        <trans-unit id="b9aaf0a6f68d326c3813770015ef1479f59b61ec" translate="yes" xml:space="preserve">
          <source>This distinction determines which scalar indexing methods the type must define. &lt;code&gt;IndexLinear()&lt;/code&gt; arrays are simple: just define &lt;code&gt;getindex(A::ArrayType, i::Int)&lt;/code&gt;. When the array is subsequently indexed with a multidimensional set of indices, the fallback &lt;code&gt;getindex(A::AbstractArray, I...)()&lt;/code&gt; efficiently converts the indices into one linear index and then calls the above method. &lt;code&gt;IndexCartesian()&lt;/code&gt; arrays, on the other hand, require methods to be defined for each supported dimensionality with &lt;code&gt;ndims(A)&lt;/code&gt;&lt;code&gt;Int&lt;/code&gt; indices. For example, &lt;a href=&quot;../../stdlib/sparsearrays/index#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC&lt;/code&gt;&lt;/a&gt; from the &lt;code&gt;SparseArrays&lt;/code&gt; standard library module, only supports two dimensions, so it just defines &lt;code&gt;getindex(A::SparseMatrixCSC, i::Int, j::Int)&lt;/code&gt;. The same holds for &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この違いにより、型で定義する必要があるスカラーインデックス方法が決まります。 &lt;code&gt;IndexLinear()&lt;/code&gt; 配列は単純です &lt;code&gt;getindex(A::ArrayType, i::Int)&lt;/code&gt; 定義するだけです。その後、配列が多次元のインデックスセットでインデックス付けされると、フォールバック &lt;code&gt;getindex(A::AbstractArray, I...)()&lt;/code&gt; はインデックスを効率的に1つの線形インデックスに変換してから、上記のメソッドを呼び出します。一方、 &lt;code&gt;IndexCartesian()&lt;/code&gt; 配列では、 &lt;code&gt;ndims(A)&lt;/code&gt; &lt;code&gt;Int&lt;/code&gt; インデックスを使用して、サポートされている次元ごとにメソッドを定義する必要があります。たとえば、 &lt;code&gt;SparseArrays&lt;/code&gt; 標準ライブラリモジュールの&lt;a href=&quot;../../stdlib/sparsearrays/index#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC&lt;/code&gt; &lt;/a&gt;は、2つの次元のみをサポートしているため、 &lt;code&gt;getindex(A::SparseMatrixCSC, i::Int, j::Int)&lt;/code&gt; 。同じことが&lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;も当てはまります！。</target>
        </trans-unit>
        <trans-unit id="341c5e7333e9b447849339d0853fcd7d14d2830b" translate="yes" xml:space="preserve">
          <source>This does not apply to &lt;code&gt;function&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt; declarations. However, anonymous functions bound to global variables are serialized as can be seen below.</source>
          <target state="translated">これは、 &lt;code&gt;function&lt;/code&gt; または &lt;code&gt;struct&lt;/code&gt; 宣言には適用されません。ただし、以下に示すように、グローバル変数にバインドされた無名関数はシリアル化されます。</target>
        </trans-unit>
        <trans-unit id="86f9320eb728977a1d66ab43b8b74b16022a0160" translate="yes" xml:space="preserve">
          <source>This environment variable only has an effect if Julia was compiled with JIT profiling support, using either</source>
          <target state="translated">この環境変数は、Julia が JIT プロファイリングをサポートしてコンパイルされた場合にのみ有効です。</target>
        </trans-unit>
        <trans-unit id="b8ecde1ad84c7fa04736dc884f170c7012ed70ab" translate="yes" xml:space="preserve">
          <source>This environment variable only has an effect if Julia was compiled with garbage-collection debugging (that is, if &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; in the build configuration).</source>
          <target state="translated">この環境変数は、Juliaがガベージコレクションデバッグでコンパイルされた場合（つまり、ビルド構成で &lt;code&gt;WITH_GC_DEBUG_ENV&lt;/code&gt; が &lt;code&gt;1&lt;/code&gt; に設定されている場合）にのみ効果があります。</target>
        </trans-unit>
        <trans-unit id="9da7aae5652d5d79a524e4cda3f0dfe80c0acd90" translate="yes" xml:space="preserve">
          <source>This error indicates that the conditional was of the wrong type: &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; rather than the required &lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt;&lt;code&gt;Bool&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このエラーは、条件が間違ったタイプであったことを示しています：必要な&lt;a href=&quot;../../base/numbers/index#Core.Bool&quot;&gt; &lt;code&gt;Bool&lt;/code&gt; &lt;/a&gt;ではなく&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="041d6d9502e571d35122b54e3f7555ea1dca4d3a" translate="yes" xml:space="preserve">
          <source>This escaping mechanism can be used to &quot;violate&quot; hygiene when necessary, in order to introduce or manipulate user variables. For example, the following macro sets &lt;code&gt;x&lt;/code&gt; to zero in the call environment:</source>
          <target state="translated">このエスケープメカニズムは、ユーザー変数を導入または操作するために、必要に応じて衛生状態を「違反」するために使用できます。たとえば、次のマクロは、呼び出し環境で &lt;code&gt;x&lt;/code&gt; をゼロに設定します。</target>
        </trans-unit>
        <trans-unit id="9c5c328c41b593f3c08a09090fb0468199894a7b" translate="yes" xml:space="preserve">
          <source>This example demonstrates a powerful and often-used parallel programming pattern. Many iterations run independently over several processes, and then their results are combined using some function. The combination process is called a &lt;em&gt;reduction&lt;/em&gt;, since it is generally tensor-rank-reducing: a vector of numbers is reduced to a single number, or a matrix is reduced to a single row or column, etc. In code, this typically looks like the pattern &lt;code&gt;x = f(x,v[i])&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is the accumulator, &lt;code&gt;f&lt;/code&gt; is the reduction function, and the &lt;code&gt;v[i]&lt;/code&gt; are the elements being reduced. It is desirable for &lt;code&gt;f&lt;/code&gt; to be associative, so that it does not matter what order the operations are performed in.</source>
          <target state="translated">この例は、強力で頻繁に使用される並列プログラミングパターンを示しています。多くの反復は複数のプロセスで独立して実行され、その結果はいくつかの関数を使用して結合されます。組み合わせプロセスは、一般にテンソルランク&lt;em&gt;削減&lt;/em&gt;であるため、&lt;em&gt;削減&lt;/em&gt;と呼ばれます。数値のベクトルが単一の数値に削減されるか、行列が単一の行または列に削減されるなどです。コードでは、通常、次のようになります。パターン &lt;code&gt;x = f(x,v[i])&lt;/code&gt; 。ここで、 &lt;code&gt;x&lt;/code&gt; はアキュムレータ、 &lt;code&gt;f&lt;/code&gt; はリダクション関数、 &lt;code&gt;v[i]&lt;/code&gt; はリダクションされる要素です。 &lt;code&gt;f&lt;/code&gt; は連想的であることが望ましいため、演算が実行される順序は関係ありません。</target>
        </trans-unit>
        <trans-unit id="6dfb71272e9303585708d721385dced1cec06a7d" translate="yes" xml:space="preserve">
          <source>This example first allocates an array of bytes, then calls the C library function &lt;code&gt;gethostname&lt;/code&gt; to fill the array in with the hostname, takes a pointer to the hostname buffer, and converts the pointer to a Julia string, assuming that it is a NUL-terminated C string. It is common for C libraries to use this pattern of requiring the caller to allocate memory to be passed to the callee and filled in. Allocation of memory from Julia like this is generally accomplished by creating an uninitialized array and passing a pointer to its data to the C function. This is why we don't use the &lt;code&gt;Cstring&lt;/code&gt; type here: as the array is uninitialized, it could contain NUL bytes. Converting to a &lt;code&gt;Cstring&lt;/code&gt; as part of the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; checks for contained NUL bytes and could therefore throw a conversion error.</source>
          <target state="translated">この例では、最初にバイトの配列を割り当て、次にCライブラリ関数 &lt;code&gt;gethostname&lt;/code&gt; を呼び出して配列にホスト名を入力し、ホスト名バッファーへのポインターを取得して、そのポインターをJulia文字列に変換します。 C文字列。 Cライブラリでは、このパターンを使用して、呼び出し元が呼び出し先に渡されて埋められるようにメモリを割り当てる必要があります。このようなJuliaからのメモリの割り当ては、初期化されていない配列を作成し、そのデータへのポインタをC関数。これが、ここで &lt;code&gt;Cstring&lt;/code&gt; 型を使用しない理由です。配列は初期化されていないため、NULバイトを含む可能性があります。 &lt;code&gt;Cstring&lt;/code&gt; 一部としての&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;への変換 含まれているNULバイトをチェックするため、変換エラーをスローする可能性があります。</target>
        </trans-unit>
        <trans-unit id="0c1ac1e55fd925a7d22f5a60b11f3b3c1b4549bc" translate="yes" xml:space="preserve">
          <source>This example generates many subnormal numbers because the values in &lt;code&gt;a&lt;/code&gt; become an exponentially decreasing curve, which slowly flattens out over time.</source>
          <target state="translated">この例では、 &lt;code&gt;a&lt;/code&gt; の値が指数関数的に減少する曲線になり、時間とともに徐々に平坦になるため、多くの非正規数が生成されます。</target>
        </trans-unit>
        <trans-unit id="9daa7910681479c02c2c50ed435d4f90bf88e739" translate="yes" xml:space="preserve">
          <source>This example highlights the general principle that the adjacent representable floating-point numbers also have adjacent binary integer representations.</source>
          <target state="translated">この例は、隣接する表現可能な浮動小数点数が隣接する2進整数表現も持つという一般的な原理を強調しています。</target>
        </trans-unit>
        <trans-unit id="908e2e897728777e829b7f08db5b9e855ae0cc96" translate="yes" xml:space="preserve">
          <source>This example is similar to the previous one, except there are two stages of consumers, and the stages have different latency so they use a different number of parallel workers, to maintain saturated throughput.</source>
          <target state="translated">この例は前の例と似ていますが、消費者のステージが2つあり、ステージは異なるレイテンシを持っているので、飽和したスループットを維持するために異なる数の並列ワーカーを使用しています。</target>
        </trans-unit>
        <trans-unit id="547c626a1378ed0fe9150c862ad51213777da963" translate="yes" xml:space="preserve">
          <source>This example map includes three different kinds of package locations (the first and third are part of the default load path):</source>
          <target state="translated">この例のマップには、3 種類の異なるパッケージの場所が含まれています (1 番目と 3 番目はデフォルトのロードパスの一部です)。</target>
        </trans-unit>
        <trans-unit id="1a00200535ab1c13ccef86e68b0800e8609303b1" translate="yes" xml:space="preserve">
          <source>This experimental interface supports Julia's multi-threading capabilities. Types and functions described here might (and likely will) change in the future.</source>
          <target state="translated">この実験的なインターフェイスは、Julia のマルチスレッド機能をサポートしています。ここに記述されている型や機能は将来的に変更される可能性があります (そして、変更される可能性もあります)。</target>
        </trans-unit>
        <trans-unit id="57cf6614fe11299d25cdfc84dad18699d2670d90" translate="yes" xml:space="preserve">
          <source>This expression constructs a name using &lt;code&gt;string&lt;/code&gt;, then substitutes this name into a new &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; expression, which is then evaluated. Keep in mind that &lt;code&gt;eval&lt;/code&gt; only operates at the top level, so within this expression local variables will not be available (unless their values are substituted with &lt;code&gt;$&lt;/code&gt;). For this reason, &lt;code&gt;eval&lt;/code&gt; is typically only used to form top-level definitions, for example when wrapping libraries that contain many similar functions. A similar example can be constructed for &lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt;&lt;code&gt;@cfunction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この式は &lt;code&gt;string&lt;/code&gt; を使用して名前を作成し、次にこの名前を新しい&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;式に代入して、評価されます。ことを覚えておいてください &lt;code&gt;eval&lt;/code&gt; は（それらの値がで置換されていない限り、ローカル変数が使用できなくなりますので、この式の中で、唯一のトップレベルで動作 &lt;code&gt;$&lt;/code&gt; ）。このため、通常、 &lt;code&gt;eval&lt;/code&gt; はトップレベルの定義を作成する場合にのみ使用されます。たとえば、類似の関数を多く含むライブラリをラップする場合などです。&lt;a href=&quot;../../base/c/index#Base.@cfunction&quot;&gt; &lt;code&gt;@cfunction&lt;/code&gt; &lt;/a&gt;についても同様の例を作成できます。</target>
        </trans-unit>
        <trans-unit id="db9c10f7c39ed65401660ce94eeb87fdf0a1c09b" translate="yes" xml:space="preserve">
          <source>This expression invokes the &lt;code&gt;echo&lt;/code&gt; command with three words as arguments: &lt;code&gt;hello&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;code&gt;sort&lt;/code&gt;. The result is that a single line is printed: &lt;code&gt;hello | sort&lt;/code&gt;. How, then, does one construct a pipeline? Instead of using &lt;code&gt;'|'&lt;/code&gt; inside of backticks, one uses &lt;code&gt;pipeline&lt;/code&gt;:</source>
          <target state="translated">この式は、3つの単語を引数として、 &lt;code&gt;echo&lt;/code&gt; コマンドを呼び出します &lt;code&gt;hello&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; 、 &lt;code&gt;sort&lt;/code&gt; 。その結果、1行が出力されます &lt;code&gt;hello | sort&lt;/code&gt; 。では、どのようにしてパイプラインを構築するのでしょうか？ &lt;code&gt;'|'&lt;/code&gt; の代わりに バックティックの内側では、 &lt;code&gt;pipeline&lt;/code&gt; 使用します：</target>
        </trans-unit>
        <trans-unit id="d8eb7a249785528e4f915a12603e4055a737c99e" translate="yes" xml:space="preserve">
          <source>This feature is experimental and could change or disappear in future versions of Julia. Incorrect use of the &lt;code&gt;@simd&lt;/code&gt; macro may cause unexpected results.</source>
          <target state="translated">この機能は実験的なものであり、Juliaの将来のバージョンでは変更または削除される可能性があります。 &lt;code&gt;@simd&lt;/code&gt; マクロを誤って使用すると、予期しない結果が生じる可能性があります。</target>
        </trans-unit>
        <trans-unit id="d5a37ab2e3447a402ef6dae9693a9619588c5031" translate="yes" xml:space="preserve">
          <source>This feature is useful for avoiding performance &quot;gotchas&quot; that could occur if one of the assignments to a variable changed its type unexpectedly.</source>
          <target state="translated">この機能は、変数への代入の1つが予期せず型を変更した場合に発生する可能性のあるパフォーマンスの「ゲッチャン」を回避するのに便利です。</target>
        </trans-unit>
        <trans-unit id="783c0c8452e06904718657237123803cbb8eb1c2" translate="yes" xml:space="preserve">
          <source>This form is often found on method signatures.</source>
          <target state="translated">この形式は、メソッド署名によく見られます。</target>
        </trans-unit>
        <trans-unit id="cc3b7f9edb1c8e585d8a1d71b69faf0b48006d70" translate="yes" xml:space="preserve">
          <source>This format should not to be confused with the older &lt;em&gt;WY&lt;/em&gt; representation &lt;a href=&quot;#footnote-Bischof1987&quot;&gt;[Bischof1987]&lt;/a&gt;.</source>
          <target state="translated">この形式は、古い&lt;em&gt;WY&lt;/em&gt;表現&lt;a href=&quot;#footnote-Bischof1987&quot;&gt;[Bischof1987]&lt;/a&gt;と混同しないでください。</target>
        </trans-unit>
        <trans-unit id="590cd9bbe677a0c8ce068af3ae23d18c7dfa14a9" translate="yes" xml:space="preserve">
          <source>This function can be used to implement transactional semantics. Before the transaction, one records the value in &lt;code&gt;x&lt;/code&gt;. After the transaction, the new value is stored only if &lt;code&gt;x&lt;/code&gt; has not been modified in the mean time.</source>
          <target state="translated">この関数は、トランザクションセマンティクスを実装するために使用できます。トランザクションの前に、値を &lt;code&gt;x&lt;/code&gt; に記録します。トランザクション後、その間に &lt;code&gt;x&lt;/code&gt; が変更されていない場合にのみ、新しい値が保存されます。</target>
        </trans-unit>
        <trans-unit id="65b3ba291cce49f270b3e77d3c5998270ae43f60" translate="yes" xml:space="preserve">
          <source>This function computes a floating point representation of the modulus after division by numerically exact &lt;code&gt;2&amp;pi;&lt;/code&gt;, and is therefore not exactly the same as &lt;code&gt;mod(x,2&amp;pi;)&lt;/code&gt;, which would compute the modulus of &lt;code&gt;x&lt;/code&gt; relative to division by the floating-point number &lt;code&gt;2&amp;pi;&lt;/code&gt;.</source>
          <target state="translated">この関数は、数値的に正確な &lt;code&gt;2&amp;pi;&lt;/code&gt; による除算後の係数の浮動小数点表現を計算します。したがって、浮動小数点数 &lt;code&gt;2&amp;pi;&lt;/code&gt; による除算に関連して &lt;code&gt;x&lt;/code&gt; の係数を計算する &lt;code&gt;mod(x,2&amp;pi;)&lt;/code&gt; と正確に同じではありません。</target>
        </trans-unit>
        <trans-unit id="a69b876a715ff91aee9ac1dc1a1270f07d74d257" translate="yes" xml:space="preserve">
          <source>This function definition applies only to calls where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both values of type &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">この関数定義は、 &lt;code&gt;x&lt;/code&gt; と &lt;code&gt;y&lt;/code&gt; が両方とも&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;型の値である呼び出しにのみ適用されます。</target>
        </trans-unit>
        <trans-unit id="307f9d2672dc49a684aa7fe31c18fec869c44c7b" translate="yes" xml:space="preserve">
          <source>This function is &quot;unsafe&quot;. Be careful to ensure that a Julia reference to &lt;code&gt;array&lt;/code&gt; exists as long as this pointer will be used. The &lt;a href=&quot;../base/index#Base.GC.@preserve&quot;&gt;&lt;code&gt;GC.@preserve&lt;/code&gt;&lt;/a&gt; macro should be used to protect the &lt;code&gt;array&lt;/code&gt; argument from garbage collection within a given block of code.</source>
          <target state="translated">この機能は「安全ではありません」。このポインターが使用される限り、 &lt;code&gt;array&lt;/code&gt; へのJulia参照が存在するように注意してください。&lt;a href=&quot;../base/index#Base.GC.@preserve&quot;&gt; &lt;code&gt;GC.@preserve&lt;/code&gt; &lt;/a&gt;マクロは、保護するために使用されるべき &lt;code&gt;array&lt;/code&gt; コードの所与のブロック内のガベージコレクションから引数。</target>
        </trans-unit>
        <trans-unit id="1048e33a2e1de2e001c3991baed944e77c02b5fe" translate="yes" xml:space="preserve">
          <source>This function is &lt;em&gt;lazy&lt;/em&gt;; that is, it is guaranteed to return in $&amp;Theta;(1)$ time and use $&amp;Theta;(1)$ additional space, and &lt;code&gt;flt&lt;/code&gt; will not be called by an invocation of &lt;code&gt;filter&lt;/code&gt;. Calls to &lt;code&gt;flt&lt;/code&gt; will be made when iterating over the returned iterable object. These calls are not cached and repeated calls will be made when reiterating.</source>
          <target state="translated">この関数は&lt;em&gt;レイジー&lt;/em&gt;です。つまり、$&amp;Theta;（1）$時間で戻り、$&amp;Theta;（1）$の追加スペースを使用することが保証されており、 &lt;code&gt;flt&lt;/code&gt; は &lt;code&gt;filter&lt;/code&gt; の呼び出しによって呼び出されません。 &lt;code&gt;flt&lt;/code&gt; の呼び出しは、返された反復可能オブジェクトを反復するときに行われます。これらの呼び出しはキャッシュされず、繰り返すときに繰り返し呼び出しが行われます。</target>
        </trans-unit>
        <trans-unit id="f3c598eb72103944814ddd5bff7557e538bb8759" translate="yes" xml:space="preserve">
          <source>This function is available as of Julia 1.2.</source>
          <target state="translated">この機能はJulia 1.2から利用可能です。</target>
        </trans-unit>
        <trans-unit id="de757df5fb576721e27ff36bb95b8961e32a7fdd" translate="yes" xml:space="preserve">
          <source>This function is experimental in Julia 1.1 and will likely be renamed in a future release (see https://github.com/JuliaLang/julia/pull/29901).</source>
          <target state="translated">この関数は Julia 1.1 では実験的なもので、将来のリリースで名前が変更される可能性があります (https://github.com/JuliaLang/julia/pull/29901 を参照してください)。</target>
        </trans-unit>
        <trans-unit id="40e1bbd78f8e3b5f7d1147a85e5728b547b5d88f" translate="yes" xml:space="preserve">
          <source>This function is labeled &quot;unsafe&quot; because it will crash if &lt;code&gt;p&lt;/code&gt; is not a valid memory address to data of the requested length.</source>
          <target state="translated">この関数は、 &lt;code&gt;p&lt;/code&gt; が要求された長さのデータに対する有効なメモリアドレスでない場合にクラッシュするため、「安全でない」とラベル付けされています。</target>
        </trans-unit>
        <trans-unit id="82038c376053156505a04a6c869bf7122237faf2" translate="yes" xml:space="preserve">
          <source>This function is labeled &quot;unsafe&quot; because it will crash if &lt;code&gt;pointer&lt;/code&gt; is not a valid memory address to data of the requested length.</source>
          <target state="translated">この関数は、 &lt;code&gt;pointer&lt;/code&gt; が要求された長さのデータへの有効なメモリアドレスでない場合にクラッシュするため、「安全でない」とラベル付けされています。</target>
        </trans-unit>
        <trans-unit id="70c3d9d8620860cee722b6a9f452e249efef56c2" translate="yes" xml:space="preserve">
          <source>This function is part of the implementation of &lt;a href=&quot;#using&quot;&gt;&lt;code&gt;using&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt;, if a module is not already defined in &lt;code&gt;Main&lt;/code&gt;. It can also be called directly to force reloading a module, regardless of whether it has been loaded before (for example, when interactively developing libraries).</source>
          <target state="translated">モジュールが &lt;code&gt;Main&lt;/code&gt; でまだ定義されていない場合、この関数は/ &lt;a href=&quot;#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;の&lt;a href=&quot;#using&quot;&gt; &lt;code&gt;using&lt;/code&gt; &lt;/a&gt;の実装の一部です。モジュールを直接呼び出して、モジュールが以前にロードされているかどうかに関係なく、強制的に再ロードすることもできます（たとえば、インタラクティブにライブラリを開発する場合など）。</target>
        </trans-unit>
        <trans-unit id="f62aceafe3cafbddb8ce3acbb1dad94e7fdf1815" translate="yes" xml:space="preserve">
          <source>This function may not be called on immutable objects, since they do not have stable memory addresses.</source>
          <target state="translated">不変オブジェクトには安定したメモリアドレスがないため、この関数を呼び出すことはできません。</target>
        </trans-unit>
        <trans-unit id="c8d8139504e5c695799999f525f1e4ce111d803d" translate="yes" xml:space="preserve">
          <source>This function raises an error under operating systems that do not support soft symbolic links, such as Windows XP.</source>
          <target state="translated">この関数は、Windows XP などのソフトシンボリックリンクをサポートしていないオペレーティングシステムではエラーとなります。</target>
        </trans-unit>
        <trans-unit id="322c609b6865dc8c717685db96eea7836880f968" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.1.</source>
          <target state="translated">この関数には最低でも Julia 1.1 が必要です。</target>
        </trans-unit>
        <trans-unit id="a78f5bdc6ba25c6757efa254c7a5dcb1069f02e2" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.1. In Julia 1.0 it is available from the standard library &lt;code&gt;InteractiveUtils&lt;/code&gt;.</source>
          <target state="translated">この機能には少なくともJulia 1.1が必要です。Julia 1.0では、標準ライブラリ &lt;code&gt;InteractiveUtils&lt;/code&gt; から利用できます。</target>
        </trans-unit>
        <trans-unit id="5a8778ddbd4ece155922c919b7d3de7c16b4b6b0" translate="yes" xml:space="preserve">
          <source>This function requires at least Julia 1.2.</source>
          <target state="translated">この関数を使用するには、Julia 1.2以上が必要です。</target>
        </trans-unit>
        <trans-unit id="f615a9f2e5154689d2348ca6e6e212e19365dd5e" translate="yes" xml:space="preserve">
          <source>This function will always return an &lt;code&gt;Int8&lt;/code&gt; regardless of the types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. See &lt;a href=&quot;../types/index#Type-Declarations-1&quot;&gt;Type Declarations&lt;/a&gt; for more on return types.</source>
          <target state="translated">この関数は、 &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; のタイプに関係なく、常に &lt;code&gt;Int8&lt;/code&gt; を返します。戻り型の詳細については、&lt;a href=&quot;../types/index#Type-Declarations-1&quot;&gt;型宣言&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="208d7b42f568795accbdf6593a0dabeec159feae" translate="yes" xml:space="preserve">
          <source>This functionality requires at least Julia 1.1.</source>
          <target state="translated">この機能には最低でもJulia 1.1が必要です。</target>
        </trans-unit>
        <trans-unit id="d55acd278bb097e8fd9b34b3f2891bb67508ba49" translate="yes" xml:space="preserve">
          <source>This functionality requires at least Julia 1.2.</source>
          <target state="translated">この機能には最低でも Julia 1.2 が必要です。</target>
        </trans-unit>
        <trans-unit id="d794b3922c789d2d5bf428145d7b58218609a4d8" translate="yes" xml:space="preserve">
          <source>This gives an output similar to</source>
          <target state="translated">これにより、次のような出力が得られます。</target>
        </trans-unit>
        <trans-unit id="71d340087c42aeb6323d557dfd0b48fcc9885f45" translate="yes" xml:space="preserve">
          <source>This guide relies on the Pkg REPL to execute Pkg commands. For non-interactive use, we recommend the Pkg API. The Pkg API is fully documented in the &lt;a href=&quot;https://julialang.github.io/Pkg.jl/v1/api/&quot;&gt;API Reference&lt;/a&gt; section of the Pkg documentation.</source>
          <target state="translated">このガイドは、Pkgコマンドを実行するためにPkg REPLに依存しています。非インタラクティブな使用については、Pkg APIをお勧めします。Pkg APIは、Pkgドキュメントの&lt;a href=&quot;https://julialang.github.io/Pkg.jl/v1/api/&quot;&gt;APIリファレンス&lt;/a&gt;セクションに完全に記載されています。</target>
        </trans-unit>
        <trans-unit id="bcc764f3d130244febc5241a24425d0f8955d7ca" translate="yes" xml:space="preserve">
          <source>This guide should help you get started with &lt;code&gt;Pkg&lt;/code&gt;. &lt;code&gt;Pkg&lt;/code&gt; has much more to offer in terms of powerful package management, read the full manual to learn more!</source>
          <target state="translated">このガイドは、 &lt;code&gt;Pkg&lt;/code&gt; を使い始めるのに役立つはずです。 &lt;code&gt;Pkg&lt;/code&gt; には、強力なパッケージ管理の面で提供する多くの機能があります。詳細については、完全なマニュアルを読んでください！</target>
        </trans-unit>
        <trans-unit id="2e07b6f624fccfda8f96076a48a7ed08e8beca2e" translate="yes" xml:space="preserve">
          <source>This has the exact same effect as the previous definition of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">これは、以前の &lt;code&gt;foo&lt;/code&gt; の定義とまったく同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="f2a3774592faf08d584a328465b32aaef91dad38" translate="yes" xml:space="preserve">
          <source>This illustrates the default &quot;tree&quot; dump; an alternative is the &quot;flat&quot; dump, which accumulates counts independent of their nesting:</source>
          <target state="translated">これはデフォルトの &quot;tree&quot; ダンプを示しています。別の選択肢として &quot;flat&quot; ダンプがあり、これはネスティングに依存せずにカウントを蓄積します。</target>
        </trans-unit>
        <trans-unit id="acc80a0f41503dcb1b7e460050ce274ae0e83048" translate="yes" xml:space="preserve">
          <source>This imports all the symbols from &lt;code&gt;Foo&lt;/code&gt;, but only inside the module &lt;code&gt;Bar&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;Foo&lt;/code&gt; からすべてのシンボルをインポートしますが、モジュール &lt;code&gt;Bar&lt;/code&gt; 内のみです。</target>
        </trans-unit>
        <trans-unit id="48c905f3e19a8500c9e8e89a5d6b2d48b63e3fd8" translate="yes" xml:space="preserve">
          <source>This interface provides a mechanism to launch and manage Julia workers on different cluster environments. There are two types of managers present in Base: &lt;code&gt;LocalManager&lt;/code&gt;, for launching additional workers on the same host, and &lt;code&gt;SSHManager&lt;/code&gt;, for launching on remote hosts via &lt;code&gt;ssh&lt;/code&gt;. TCP/IP sockets are used to connect and transport messages between processes. It is possible for Cluster Managers to provide a different transport.</source>
          <target state="translated">このインターフェースは、さまざまなクラスター環境でJuliaワーカーを起動および管理するメカニズムを提供します。：そこマネージャの2つのタイプがベースに存在する &lt;code&gt;LocalManager&lt;/code&gt; 同じホスト上に追加の労働者を起動するため、および &lt;code&gt;SSHManager&lt;/code&gt; を介してリモート・ホスト上で起動するため、 &lt;code&gt;ssh&lt;/code&gt; 。TCP / IPソケットは、プロセス間でメッセージを接続および転送するために使用されます。Cluster Managerが別のトランスポートを提供することは可能です。</target>
        </trans-unit>
        <trans-unit id="deff481ef7abfd9c149d6a30d8b9bfb2fec2b9fb" translate="yes" xml:space="preserve">
          <source>This is a Julia wrapper around a pointer to a &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt;&lt;code&gt;git_signature&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">これは、&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_signature&quot;&gt; &lt;code&gt;git_signature&lt;/code&gt; &lt;/a&gt;オブジェクトへのポインターを囲むJuliaラッパーです。</target>
        </trans-unit>
        <trans-unit id="c422825d888738af38d09b58685510aefce5bd8f" translate="yes" xml:space="preserve">
          <source>This is a better choice than</source>
          <target state="translated">よりもこちらの方が</target>
        </trans-unit>
        <trans-unit id="85e469ae13d4f052567eb5f96057c4c8c1633d8d" translate="yes" xml:space="preserve">
          <source>This is a classic example of a single producer feeding two concurrent consumers: one &lt;code&gt;perl&lt;/code&gt; process generates lines with the numbers 0 through 5 on them, while two parallel processes consume that output, one prefixing lines with the letter &quot;A&quot;, the other with the letter &quot;B&quot;. Which consumer gets the first line is non-deterministic, but once that race has been won, the lines are consumed alternately by one process and then the other. (Setting &lt;code&gt;$|=1&lt;/code&gt; in Perl causes each print statement to flush the &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; handle, which is necessary for this example to work. Otherwise all the output is buffered and printed to the pipe at once, to be read by just one consumer process.)</source>
          <target state="translated">これは、1つのプロデューサーが2つの同時コンシューマーにフィードする典型的な例です。1つの &lt;code&gt;perl&lt;/code&gt; プロセスが0から5までの番号の行を生成し、2つの並列プロセスがその出力を消費します。文字「B」。最初の行を取得するコンシューマーは非決定的ですが、その競争に勝った後、行は1つのプロセスと別のプロセスで交互に消費されます。 （Perlで &lt;code&gt;$|=1&lt;/code&gt; 設定すると、この例が機能するために必要な&lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;ハンドルが各印刷ステートメントによってフラッシュされます。それ以外の場合は、すべての出力が一度にバッファーに入れられてパイプに出力され、1つのコンシューマープロセスだけで読み取られます。 ）</target>
        </trans-unit>
        <trans-unit id="cf79f7f6027262a30f115ab7b0f785a426cd7073" translate="yes" xml:space="preserve">
          <source>This is a common pattern seen when converting from a larger class of types to the one specific argument type that is actually supported by the algorithm:</source>
          <target state="translated">これは、より大きなクラスの型から、アルゴリズムが実際にサポートしている1つの特定の引数型に変換するときによく見られるパターンです。</target>
        </trans-unit>
        <trans-unit id="ab1f9c741287d248928e11803550091dd722085d" translate="yes" xml:space="preserve">
          <source>This is a somewhat contrived example since we could produce the same behavior more clearly by negating the condition and placing the &lt;code&gt;println&lt;/code&gt; call inside the &lt;code&gt;if&lt;/code&gt; block. In realistic usage there is more code to be evaluated after the &lt;code&gt;continue&lt;/code&gt;, and often there are multiple points from which one calls &lt;code&gt;continue&lt;/code&gt;.</source>
          <target state="translated">条件を無効にし、 &lt;code&gt;println&lt;/code&gt; 呼び出しを &lt;code&gt;if&lt;/code&gt; ブロック内に配置することで同じ動作をより明確に生成できるため、これはやや不自然な例です。現実的な使用では、 &lt;code&gt;continue&lt;/code&gt; 後に評価されるコードが多くなり、多くの場合、1つの呼び出しが &lt;code&gt;continue&lt;/code&gt; する複数のポイントがあります。</target>
        </trans-unit>
        <trans-unit id="1c9ba627d76c7cc49aeb4d6fdbc49ae25f7076ce" translate="yes" xml:space="preserve">
          <source>This is a verbose version of the &lt;code&gt;@time&lt;/code&gt; macro. It first prints the same information as &lt;code&gt;@time&lt;/code&gt;, then any non-zero memory allocation counters, and then returns the value of the expression.</source>
          <target state="translated">これは、 &lt;code&gt;@time&lt;/code&gt; マクロの詳細バージョンです。最初に &lt;code&gt;@time&lt;/code&gt; と同じ情報を出力し、次にゼロ以外のメモリ割り当てカウンターを出力してから、式の値を返します。</target>
        </trans-unit>
        <trans-unit id="3dde492bc6a0d4212d6f3ce351cddd4c3cc1560e" translate="yes" xml:space="preserve">
          <source>This is a very common pattern throughout Julia Base: a small set of required methods define an informal interface that enable many fancier behaviors. In some cases, types will want to additionally specialize those extra behaviors when they know a more efficient algorithm can be used in their specific case.</source>
          <target state="translated">これは、Julia Base 全体で非常によく見られるパターンです:必要とされる小さなメソッドのセットが非公式なインターフェイスを定義して、多くのファンシーな動作を可能にします。いくつかのケースでは、特定のケースでより効率的なアルゴリズムが使用できることがわかっている場合に、型は追加でこれらの追加の動作を特別化したいと思うでしょう。</target>
        </trans-unit>
        <trans-unit id="967704622307a1b435262f66f63c35ab2df37cdd" translate="yes" xml:space="preserve">
          <source>This is accomplished by the following definition:</source>
          <target state="translated">これは、以下の定義によって達成される。</target>
        </trans-unit>
        <trans-unit id="a064a0d086a44fbda83912ae13c4a94a63595798" translate="yes" xml:space="preserve">
          <source>This is accomplished via the following code in &lt;code&gt;base/boot.jl&lt;/code&gt;:</source>
          <target state="translated">これは、 &lt;code&gt;base/boot.jl&lt;/code&gt; の次のコードを介して行われます。</target>
        </trans-unit>
        <trans-unit id="d3583c3fe581e3e08550a563e55b3f4e249fd47f" translate="yes" xml:space="preserve">
          <source>This is also true for remotecalls on the local node as seen in the following example:</source>
          <target state="translated">これは、次の例のようにローカルノード上のリモートコールにも当てはまります。</target>
        </trans-unit>
        <trans-unit id="fa42412894f46475c32ad0f5cf96db8417157008" translate="yes" xml:space="preserve">
          <source>This is better style because &lt;code&gt;foo&lt;/code&gt; does not really accept numbers of all types; it really needs &lt;code&gt;Int&lt;/code&gt; s.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; は実際にはすべてのタイプの数を受け入れないため、これはより良いスタイルです。 &lt;code&gt;Int&lt;/code&gt; が本当に必要です。</target>
        </trans-unit>
        <trans-unit id="ac355916b9abde70111dfabfe3ce99e5f07ae086" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;const Vector = Array{T,1} where T&lt;/code&gt;. Writing &lt;code&gt;Vector{Float64}&lt;/code&gt; is equivalent to writing &lt;code&gt;Array{Float64,1}&lt;/code&gt;, and the umbrella type &lt;code&gt;Vector&lt;/code&gt; has as instances all &lt;code&gt;Array&lt;/code&gt; objects where the second parameter &amp;ndash; the number of array dimensions &amp;ndash; is 1, regardless of what the element type is. In languages where parametric types must always be specified in full, this is not especially helpful, but in Julia, this allows one to write just &lt;code&gt;Vector&lt;/code&gt; for the abstract type including all one-dimensional dense arrays of any element type.</source>
          <target state="translated">これは &lt;code&gt;const Vector = Array{T,1} where T&lt;/code&gt; と同等で、Tです。書き込み &lt;code&gt;Vector{Float64}&lt;/code&gt; 書き込みに相当する &lt;code&gt;Array{Float64,1}&lt;/code&gt; 、および傘型 &lt;code&gt;Vector&lt;/code&gt; インスタンスとして全て有する &lt;code&gt;Array&lt;/code&gt; オブジェクトをここで第二のパラメータ-配列の次元の数は、 -関係なく、要素のタイプが何であるか、1です。パラメトリックタイプを常に完全に指定する必要がある言語では、これは特に役に立ちませんが、Juliaでは、これにより、任意の要素タイプのすべての1次元の密配列を含む抽象タイプの &lt;code&gt;Vector&lt;/code&gt; のみを記述できます。</target>
        </trans-unit>
        <trans-unit id="aaca4a13507268ab605b72c529b012ba239f5cf8" translate="yes" xml:space="preserve">
          <source>This is equivalent to the uglier test &lt;code&gt;@test &amp;asymp;(&amp;pi;, 3.14, atol=0.01)&lt;/code&gt;. It is an error to supply more than one expression unless the first is a call expression and the rest are assignments (&lt;code&gt;k=v&lt;/code&gt;).</source>
          <target state="translated">これは、醜い検定 &lt;code&gt;@test &amp;asymp;(&amp;pi;, 3.14, atol=0.01)&lt;/code&gt; と同等です。最初の式が呼び出し式で、残りが代入（ &lt;code&gt;k=v&lt;/code&gt; ）でない限り、複数の式を指定するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="075cde66f62e612ace972fa5c52ba3c9977edd64" translate="yes" xml:space="preserve">
          <source>This is fine if a named function effecting the transform already exists to pass as the first argument to &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;. Often, however, a ready-to-use, named function does not exist. In these situations, the anonymous function construct allows easy creation of a single-use function object without needing a name:</source>
          <target state="translated">これは、変換に影響を与える名前付き関数がすでに存在し、&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; の&lt;/a&gt;最初の引数として渡される場合は問題ありません。ただし、すぐに使用できる名前付き関数が存在しないことがよくあります。これらの状況では、無名関数の構成により、名前を必要とせずに使い捨ての関数オブジェクトを簡単に作成できます。</target>
        </trans-unit>
        <trans-unit id="d2c04622602343797c4542bea9af2f8f42f131f2" translate="yes" xml:space="preserve">
          <source>This is happening because, while the &lt;code&gt;write&lt;/code&gt; call is synchronous, the writing of each argument yields to other tasks while waiting for that part of the I/O to complete.</source>
          <target state="translated">これは、 &lt;code&gt;write&lt;/code&gt; 呼び出しが同期している間、各引数の書き込みが、I / Oのその部分が完了するのを待つ間、他のタスクに譲るためです。</target>
        </trans-unit>
        <trans-unit id="c8a50eb2bf3cc3094e347236252e67c0ff90ae38" translate="yes" xml:space="preserve">
          <source>This is intended to be called using &lt;code&gt;do&lt;/code&gt; block syntax</source>
          <target state="translated">これは、 &lt;code&gt;do&lt;/code&gt; ブロック構文を使用して呼び出されることを意図しています</target>
        </trans-unit>
        <trans-unit id="9cdfa85f9233b8624988cb8413bc1b9a6dc03d9c" translate="yes" xml:space="preserve">
          <source>This is intended to be called using &lt;code&gt;do&lt;/code&gt; block syntax:</source>
          <target state="translated">これは、 &lt;code&gt;do&lt;/code&gt; ブロック構文を使用して呼び出すことを目的としています。</target>
        </trans-unit>
        <trans-unit id="dd320fe267c845b089f3801cdc399b59ed6ba172" translate="yes" xml:space="preserve">
          <source>This is likely a very expensive operation. Given that all other atomic operations in Julia already have acquire/release semantics, explicit fences should not be necessary in most cases.</source>
          <target state="translated">これは非常に高価な操作である可能性が高いです。Julia の他のすべてのアトミック操作が既に acquire/release セマンティクスを持っていることを考えると、ほとんどの場合、明示的なフェンスは必要ないはずです。</target>
        </trans-unit>
        <trans-unit id="4c368eefb6926a50691e6a9f9ec7714b2c918956" translate="yes" xml:space="preserve">
          <source>This is more readable and convenient and equivalent to the above string concatenation &amp;ndash; the system rewrites this apparent single string literal into the call &lt;code&gt;string(greet, &quot;, &quot;, whom, &quot;.\n&quot;)&lt;/code&gt;.</source>
          <target state="translated">これは、より読みやすく、便利で、上記の文字列連結と同等です。システムは、この単一の文字列リテラルを呼び出し &lt;code&gt;string(greet, &quot;, &quot;, whom, &quot;.\n&quot;)&lt;/code&gt; 書き換えます。</target>
        </trans-unit>
        <trans-unit id="f04a7b3a9c6223bad051fa21f901be067148fe9d" translate="yes" xml:space="preserve">
          <source>This is not needed on worker threads (&lt;code&gt;Threads.threadid() != 1&lt;/code&gt;) since the &lt;code&gt;InterruptException&lt;/code&gt; will only be delivered to the master thread. External functions that do not call julia code or julia runtime automatically disable sigint during their execution.</source>
          <target state="translated">&lt;code&gt;InterruptException&lt;/code&gt; はマスタースレッドにのみ配信されるため、ワーカースレッド（ &lt;code&gt;Threads.threadid() != 1&lt;/code&gt; ）では必要ありません。juliaコードまたはjuliaランタイムを呼び出さない外部関数は、実行中にsigintを自動的に無効にします。</target>
        </trans-unit>
        <trans-unit id="71e546fccd494df52bebb481be657d852aebe11b" translate="yes" xml:space="preserve">
          <source>This is often the right strategy; however, there are circumstances where following this advice blindly can be counterproductive. In particular, the more methods a generic function has, the more possibilities there are for ambiguities. When your method hierarchies get more complicated than this simple example, it can be worth your while to think carefully about alternative strategies.</source>
          <target state="translated">これは正しい戦略であることが多いのですが、やみくもにこのアドバイスに従うのは逆効果になる場合もあります。特に、一般的な関数が持つメソッドの数が多ければ多いほど、曖昧さの原因となる可能性が高くなります。メソッドの階層がこの単純な例よりも複雑になってきた場合は、別の戦略を慎重に考えてみる価値があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e2fa8331115c72567b8859c8f4636de4982ac69c" translate="yes" xml:space="preserve">
          <source>This is only needed if your module depends on a file that is not used via &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;. It has no effect outside of compilation.</source>
          <target state="translated">これは、モジュールが&lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; で&lt;/a&gt;使用されないファイルに依存している場合にのみ必要です。コンパイル以外では効果がありません。</target>
        </trans-unit>
        <trans-unit id="2784b134096220702383ae6c9d7a1302554b1771" translate="yes" xml:space="preserve">
          <source>This is the default comparison used by &lt;a href=&quot;../sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは、&lt;a href=&quot;../sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; で&lt;/a&gt;使用されるデフォルトの比較です。</target>
        </trans-unit>
        <trans-unit id="c85ba23a6506d2939aa5b839a013bcd606af833c" translate="yes" xml:space="preserve">
          <source>This is the list of reserved keywords in Julia: &lt;code&gt;baremodule&lt;/code&gt;, &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;elseif&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, &lt;code&gt;export&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;finally&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;global&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;import&lt;/code&gt;, &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;local&lt;/code&gt;, &lt;code&gt;macro&lt;/code&gt;, &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;quote&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;. Those keywords are not allowed to be used as variable names.</source>
          <target state="translated">これはJuliaの予約済みキーワードのリストです： &lt;code&gt;baremodule&lt;/code&gt; 、 &lt;code&gt;begin&lt;/code&gt; 、 &lt;code&gt;break&lt;/code&gt; 、 &lt;code&gt;catch&lt;/code&gt; 、 &lt;code&gt;const&lt;/code&gt; 、 &lt;code&gt;continue&lt;/code&gt; 、 &lt;code&gt;do&lt;/code&gt; 、 &lt;code&gt;else&lt;/code&gt; 、 &lt;code&gt;elseif&lt;/code&gt; 、 &lt;code&gt;end&lt;/code&gt; 、 &lt;code&gt;export&lt;/code&gt; 、 &lt;code&gt;false&lt;/code&gt; 、 &lt;code&gt;finally&lt;/code&gt; 、 &lt;code&gt;for&lt;/code&gt; 、 &lt;code&gt;function&lt;/code&gt; 、 &lt;code&gt;global&lt;/code&gt; 、 &lt;code&gt;if&lt;/code&gt; 、 &lt;code&gt;import&lt;/code&gt; 、 &lt;code&gt;let&lt;/code&gt; 、 &lt;code&gt;local&lt;/code&gt; 、 &lt;code&gt;macro&lt;/code&gt; 、 &lt;code&gt;module&lt;/code&gt; 、 &lt;code&gt;quote&lt;/code&gt; 、 &lt;code&gt;return&lt;/code&gt; 、 &lt;code&gt;struct&lt;/code&gt; 、 &lt;code&gt;true&lt;/code&gt; 、 &lt;code&gt;try&lt;/code&gt; 、 &lt;code&gt;using&lt;/code&gt; 、 &lt;code&gt;while&lt;/code&gt; 。これらのキーワードを変数名として使用することはできません。</target>
        </trans-unit>
        <trans-unit id="c90facb0407832d3445cbf12e098939b6ab30525" translate="yes" xml:space="preserve">
          <source>This is useful with the do-block syntax for more complex temporal expressions:</source>
          <target state="translated">これは、より複雑なテンポラリ式のためのdo-block構文を使用すると便利です。</target>
        </trans-unit>
        <trans-unit id="1f135ed365e0881687323b4b2b1b547c6be25fa8" translate="yes" xml:space="preserve">
          <source>This is wasteful when dimensions get large, so Julia provides &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt;, which expands singleton dimensions in array arguments to match the corresponding dimension in the other array without using extra memory, and applies the given function elementwise:</source>
          <target state="translated">これは、次元が大きくなると無駄になり、ジュリアは&lt;a href=&quot;../../base/arrays/index#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt;提供します。これは、余分なメモリを使用せずに配列引数のシングルトン次元を拡張して、他の配列の対応する次元に一致させ、特定の関数を要素ごとに適用します。</target>
        </trans-unit>
        <trans-unit id="7bd078ba5ec9612bff8795fa65ea85e0e4a4b835" translate="yes" xml:space="preserve">
          <source>This iterator is &quot;lazy&quot; in that it does not make a copy of the collection in order to reverse it; see &lt;code&gt;Base.reverse&lt;/code&gt; for an eager implementation.</source>
          <target state="translated">このイテレータは、コレクションを元に戻すためにコレクションのコピーを作成しないという点で「遅延」です。熱心な実装については、 &lt;code&gt;Base.reverse&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="668dce0079a5c7ecaeda787c6c43c4abed16e82f" translate="yes" xml:space="preserve">
          <source>This keeps things simple, while allowing the compiler to generate optimized code in all cases.</source>
          <target state="translated">これにより、コンパイラがすべてのケースで最適化されたコードを生成できるようにしながら、物事をシンプルに保つことができます。</target>
        </trans-unit>
        <trans-unit id="618a3a65c5497ca323b88a316514b70e984e986d" translate="yes" xml:space="preserve">
          <source>This kind of control flow can make it much easier to solve certain problems. In some problems, the various pieces of required work are not naturally related by function calls; there is no obvious &quot;caller&quot; or &quot;callee&quot; among the jobs that need to be done. An example is the producer-consumer problem, where one complex procedure is generating values and another complex procedure is consuming them. The consumer cannot simply call a producer function to get a value, because the producer may have more values to generate and so might not yet be ready to return. With tasks, the producer and consumer can both run as long as they need to, passing values back and forth as necessary.</source>
          <target state="translated">このような制御フローは、特定の問題をはるかに簡単に解決することができます。いくつかの問題では、必要とされる作業の様々な部分は、当然のことながら関数の呼び出しによって関連づけられていません。例えば、ある複雑なプロシージャが値を生成し、別の複雑なプロシージャが値を消費しているような、生産者と消費者の問題があります。消費者は、単にプロデューサ関数を呼び出して値を取得することはできません。タスクを使えば、プロデューサとコンシューマは必要なだけ実行し、必要に応じて値を前後に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="0a88599aaef0898fffd99491510ed87461ecc31f" translate="yes" xml:space="preserve">
          <source>This kind of definition of function behavior by dispatch is quite common &amp;ndash; idiomatic, even &amp;ndash; in Julia. Method type parameters are not restricted to being used as the types of arguments: they can be used anywhere a value would be in the signature of the function or body of the function. Here's an example where the method type parameter &lt;code&gt;T&lt;/code&gt; is used as the type parameter to the parametric type &lt;code&gt;Vector{T}&lt;/code&gt; in the method signature:</source>
          <target state="translated">このようなディスパッチによる関数の動作の定義は、ジュリアではかなり一般的です。メソッド型パラメーターは、引数の型としての使用に限定されていません。関数のシグニチャーまたは関数の本体で値が使用される場所であればどこでも使用できます。メソッドの型パラメーター &lt;code&gt;T&lt;/code&gt; がメソッドシグネチャのパラメトリックタイプ &lt;code&gt;Vector{T}&lt;/code&gt; の型パラメーターとして使用される例を次に示します。</target>
        </trans-unit>
        <trans-unit id="ec4239bc4b5dc918f448b6994ffeb011eb260c23" translate="yes" xml:space="preserve">
          <source>This kind of manipulation of variables should be used judiciously, but is occasionally quite handy.</source>
          <target state="translated">このような変数の操作は慎重に使うべきですが、たまには便利なこともあります。</target>
        </trans-unit>
        <trans-unit id="5cf1880888ac71427a2a472f83ebc4e3ee3aeac7" translate="yes" xml:space="preserve">
          <source>This last point is &lt;em&gt;very&lt;/em&gt; important: even though &lt;code&gt;Float64 &amp;lt;: Real&lt;/code&gt; we &lt;strong&gt;DO NOT&lt;/strong&gt; have &lt;code&gt;Point{Float64} &amp;lt;: Point{Real}&lt;/code&gt;.</source>
          <target state="translated">この最後のポイントは&lt;em&gt;非常に&lt;/em&gt;重要です &lt;code&gt;Float64 &amp;lt;: Real&lt;/code&gt; には &lt;code&gt;Point{Float64} &amp;lt;: Point{Real}&lt;/code&gt; &lt;strong&gt;ません&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7542405e58ae981f14134e43a96aca7f30233f49" translate="yes" xml:space="preserve">
          <source>This leverages a fallback implementation of &lt;code&gt;copyto!&lt;/code&gt; that converts the wrapper into a &lt;code&gt;Broadcasted{Nothing}&lt;/code&gt;. Consequently, specializing on &lt;code&gt;DestType&lt;/code&gt; has lower precedence than methods that specialize on &lt;code&gt;DestStyle&lt;/code&gt;.</source>
          <target state="translated">これは、 &lt;code&gt;copyto!&lt;/code&gt; のフォールバック実装を利用しています。ラッパーを &lt;code&gt;Broadcasted{Nothing}&lt;/code&gt; 変換します。したがって、上の専門 &lt;code&gt;DestType&lt;/code&gt; に特化した方法よりも低い優先順位がある &lt;code&gt;DestStyle&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="563a17c90111523e5b2f5d6e8d16952ec180646f" translate="yes" xml:space="preserve">
          <source>This loads the module &lt;code&gt;Foo&lt;/code&gt; and defines a variable &lt;code&gt;Foo&lt;/code&gt; that refers to the module, but does not import any of the other symbols from the module into the current namespace. You refer to the &lt;code&gt;Foo&lt;/code&gt; symbols by their qualified names &lt;code&gt;Foo.bar&lt;/code&gt; etc.</source>
          <target state="translated">これにより、モジュール &lt;code&gt;Foo&lt;/code&gt; が読み込まれ、モジュールを参照する変数 &lt;code&gt;Foo&lt;/code&gt; が定義されますが、モジュールから他のシンボルは現在の名前空間にインポートされません。 &lt;code&gt;Foo&lt;/code&gt; シンボルは、修飾名 &lt;code&gt;Foo.bar&lt;/code&gt; などで参照します。</target>
        </trans-unit>
        <trans-unit id="4612a42efe8a5bdd3c4138ff12dd117c4e94f8e6" translate="yes" xml:space="preserve">
          <source>This macro can be used like this:</source>
          <target state="translated">このマクロはこんな感じで使えます。</target>
        </trans-unit>
        <trans-unit id="796fb2fc91375e842873f0f25490416b48076f98" translate="yes" xml:space="preserve">
          <source>This macro takes one argument: &lt;code&gt;name&lt;/code&gt;. When &lt;code&gt;@sayhello&lt;/code&gt; is encountered, the quoted expression is &lt;em&gt;expanded&lt;/em&gt; to interpolate the value of the argument into the final expression:</source>
          <target state="translated">このマクロは1つの引数を取ります： &lt;code&gt;name&lt;/code&gt; 。とき &lt;code&gt;@sayhello&lt;/code&gt; が検出され、引用された表現がされて&lt;em&gt;拡大し&lt;/em&gt;、最終的な式に引数の値を補間します：</target>
        </trans-unit>
        <trans-unit id="99355d54955b26bda6881d3a32f0394ad662278e" translate="yes" xml:space="preserve">
          <source>This makes it easy to use an arbitrary object (here a &lt;code&gt;raw&lt;/code&gt; string) as a docstring.</source>
          <target state="translated">これにより、任意のオブジェクト（ここでは &lt;code&gt;raw&lt;/code&gt; 文字列）をdocstringとして簡単に使用できます。</target>
        </trans-unit>
        <trans-unit id="e352f04f9f33e3e34fa37d2a0e22a677123c5a98" translate="yes" xml:space="preserve">
          <source>This makes it hard to write many basic integer algorithms since a lot of common techniques depend on the fact that machine addition with overflow &lt;em&gt;is&lt;/em&gt; associative. Consider finding the midpoint between integer values &lt;code&gt;lo&lt;/code&gt; and &lt;code&gt;hi&lt;/code&gt; in Julia using the expression &lt;code&gt;(lo + hi) &amp;gt;&amp;gt;&amp;gt; 1&lt;/code&gt;:</source>
          <target state="translated">多くの一般的な手法は、オーバーフロー&lt;em&gt;を&lt;/em&gt;伴うマシンの加算&lt;em&gt;が&lt;/em&gt;結合的であるという事実に依存しているため、これは多くの基本的な整数アルゴリズムを書くことを難しくします。式 &lt;code&gt;(lo + hi) &amp;gt;&amp;gt;&amp;gt; 1&lt;/code&gt; を使用して、ジュリアの整数値 &lt;code&gt;lo&lt;/code&gt; と &lt;code&gt;hi&lt;/code&gt; の間の中点を見つけることを検討してください。</target>
        </trans-unit>
        <trans-unit id="bddf7a0f25a0e5f4299199009d8763508187037e" translate="yes" xml:space="preserve">
          <source>This makes it more clear where docstrings start and end.</source>
          <target state="translated">これにより、docstringsの開始と終了がより明確になります。</target>
        </trans-unit>
        <trans-unit id="1390ee7b9f8d0f8dd34a701e5fbadb4b8b3c9256" translate="yes" xml:space="preserve">
          <source>This makes stack trace information available programmatically for logging, error handling, and more.</source>
          <target state="translated">これにより、スタックトレース情報がロギングやエラー処理などのためにプログラムで利用できるようになります。</target>
        </trans-unit>
        <trans-unit id="118a450839bcd493b9a3323bf1931949bac102ac" translate="yes" xml:space="preserve">
          <source>This manifest file describes a possible complete dependency graph for the &lt;code&gt;App&lt;/code&gt; project:</source>
          <target state="translated">このマニフェストファイルは、 &lt;code&gt;App&lt;/code&gt; プロジェクトの考えられる完全な依存関係グラフを記述しています。</target>
        </trans-unit>
        <trans-unit id="fa9bdb6f39c12cde4099183225c25db089937837" translate="yes" xml:space="preserve">
          <source>This may sound like a strange restriction, but remember that since C is not a dynamic language like Julia, its functions can only accept argument types with a statically-known, fixed signature.</source>
          <target state="translated">これは奇妙な制限のように聞こえるかもしれませんが、C言語はJuliaのような動的言語ではないので、その関数は静的に知られた固定シグネチャを持つ引数型しか受け付けることができないことを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="ccbe0f854d08689742c5122439446d8ae7400b8b" translate="yes" xml:space="preserve">
          <source>This means that calling &lt;code&gt;f()&lt;/code&gt; is equivalent to calling &lt;code&gt;f(1,2)&lt;/code&gt;. In this case the result is &lt;code&gt;5&lt;/code&gt;, because &lt;code&gt;f(1,2)&lt;/code&gt; invokes the first method of &lt;code&gt;f&lt;/code&gt; above. However, this need not always be the case. If you define a fourth method that is more specialized for integers:</source>
          <target state="translated">つまり、 &lt;code&gt;f()&lt;/code&gt; の呼び出しは &lt;code&gt;f(1,2)&lt;/code&gt; の呼び出しと同等です。この場合、 &lt;code&gt;f(1,2)&lt;/code&gt; は上記の &lt;code&gt;f&lt;/code&gt; の最初のメソッドを呼び出すため、結果は &lt;code&gt;5&lt;/code&gt; になります。ただし、常にそうである必要はありません。整数に特化した4番目のメソッドを定義する場合：</target>
        </trans-unit>
        <trans-unit id="d91824530ea1dcad07d2ce3b7c87745b23855a91" translate="yes" xml:space="preserve">
          <source>This means that new &lt;code&gt;Number&lt;/code&gt; types only need to define constructors, since this definition will handle &lt;code&gt;convert&lt;/code&gt; for them. An identity conversion is also provided to handle the case where the argument is already of the requested type:</source>
          <target state="translated">つまり、この定義はコンストラクターの &lt;code&gt;convert&lt;/code&gt; を処理するため、新しい &lt;code&gt;Number&lt;/code&gt; 型はコンストラクターを定義するだけで済みます。引数がすでに要求されたタイプである場合を処理するために、ID変換も提供されています。</target>
        </trans-unit>
        <trans-unit id="d95d868bc45acbbf3d653adf2e5564fd580718ec" translate="yes" xml:space="preserve">
          <source>This means that rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to an even multiple of seconds, minutes, hours, or years (because the ISO 8601 specification includes a year zero) will result in a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; with an even value in that field, while rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to an even multiple of months will result in the months field having an odd value. Because both months and years may contain an irregular number of days, whether rounding to an even number of days will result in an even value in the days field is uncertain.</source>
          <target state="translated">つまり、&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;を秒、分、時間、または年の偶数倍に丸めると（ISO 8601仕様にはゼロ年が含まれるため）、&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;はそのフィールドに偶数の値を持ち、&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;は偶数に丸められます。月が複数ある場合、月フィールドの値は奇数になります。月と年の両方に不規則な日数が含まれる可能性があるため、日数を偶数に丸めると日フィールドの値が偶数になるかどうかは不確かです。</target>
        </trans-unit>
        <trans-unit id="0b1724fb3df29f491e1db30646921be60d52e085" translate="yes" xml:space="preserve">
          <source>This means we must also define a corresponding &lt;code&gt;similar&lt;/code&gt; method:</source>
          <target state="translated">つまり、対応する &lt;code&gt;similar&lt;/code&gt; メソッドも定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="8164014a03b0ed9d2a2a01cfd412eb70f3f6cf4e" translate="yes" xml:space="preserve">
          <source>This mechanism can be implemented easily by custom exception types following the way &lt;a href=&quot;../../base/base/index#Core.UndefVarError&quot;&gt;&lt;code&gt;UndefVarError&lt;/code&gt;&lt;/a&gt; is written:</source>
          <target state="translated">このメカニズムは、&lt;a href=&quot;../../base/base/index#Core.UndefVarError&quot;&gt; &lt;code&gt;UndefVarError&lt;/code&gt; の&lt;/a&gt;記述方法に従って、カスタム例外タイプによって簡単に実装できます。</target>
        </trans-unit>
        <trans-unit id="00b20545036f8cfdf164022ed01300b951b2a39d" translate="yes" xml:space="preserve">
          <source>This mechanism is also the key to how type constructors and closures (inner functions that refer to their surrounding environment) work in Julia.</source>
          <target state="translated">このメカニズムは、型のコンストラクタやクロージャ(周囲の環境を参照する内部関数)がJuliaでどのように動作するかの鍵でもあります。</target>
        </trans-unit>
        <trans-unit id="87a9a57282476dafb9bfcdbc06caa5e75c2590eb" translate="yes" xml:space="preserve">
          <source>This mechanism is of course used by the default implementation of random array generation (like in &lt;code&gt;rand(1:20, 10)&lt;/code&gt;). In order to implement this decoupling for a custom type, a helper type can be used. Going back to our &lt;code&gt;Die&lt;/code&gt; example: &lt;code&gt;rand(::Die)&lt;/code&gt; uses random generation from a range, so there is an opportunity for this optimization:</source>
          <target state="translated">このメカニズムはもちろん、ランダム配列生成のデフォルト実装で使用されます（ &lt;code&gt;rand(1:20, 10)&lt;/code&gt; ）。カスタムタイプにこの分離を実装するには、ヘルパータイプを使用できます。 &lt;code&gt;Die&lt;/code&gt; の例に戻ると、 &lt;code&gt;rand(::Die)&lt;/code&gt; は範囲からのランダム生成を使用しているため、この最適化の機会があります。</target>
        </trans-unit>
        <trans-unit id="f75a278538a1522abc6fa98d70bcb27983fcccb3" translate="yes" xml:space="preserve">
          <source>This method creates a &lt;code&gt;DateFormat&lt;/code&gt; object each time it is called. If you are parsing many date strings of the same format, consider creating a &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;DateFormat&lt;/code&gt;&lt;/a&gt; object once and using that as the second argument instead.</source>
          <target state="translated">このメソッドは、呼び出されるたびに &lt;code&gt;DateFormat&lt;/code&gt; オブジェクトを作成します。同じ形式の多くの日付文字列を解析する場合は、&lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;DateFormat&lt;/code&gt; &lt;/a&gt;オブジェクトを一度作成し、それを2番目の引数として使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="9d972e8cda3b91e650e6ff3541ce6f8b54cbae93" translate="yes" xml:space="preserve">
          <source>This method creates a &lt;code&gt;DateFormat&lt;/code&gt; object each time it is called. If you are parsing many date time strings of the same format, consider creating a &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;DateFormat&lt;/code&gt;&lt;/a&gt; object once and using that as the second argument instead.</source>
          <target state="translated">このメソッドは、呼び出されるたびに &lt;code&gt;DateFormat&lt;/code&gt; オブジェクトを作成します。同じ形式の多数の日時文字列を解析する場合は、&lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;DateFormat&lt;/code&gt; &lt;/a&gt;オブジェクトを一度作成し、それを2番目の引数として使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="cb2233a83e18eafded9574a3a241275b67521981" translate="yes" xml:space="preserve">
          <source>This method definition applies to any pair of arguments that are instances of &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;. They need not be of the same type, so long as they are each numeric values. The problem of handling disparate numeric types is delegated to the arithmetic operations in the expression &lt;code&gt;2x - y&lt;/code&gt;.</source>
          <target state="translated">このメソッド定義は、&lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; の&lt;/a&gt;インスタンスである引数のペアに適用されます。それらがそれぞれ数値である限り、それらは同じタイプである必要はありません。異なる数値型の処理の問題は、式 &lt;code&gt;2x - y&lt;/code&gt; 算術演算に委任されています。</target>
        </trans-unit>
        <trans-unit id="25be108587097965bc1d457d2798dc697b2b0387" translate="yes" xml:space="preserve">
          <source>This method is available as of Julia 1.1.</source>
          <target state="translated">この方法はJulia 1.1から利用可能です。</target>
        </trans-unit>
        <trans-unit id="7154e71f550aec85c7b6230d9f61b37f4a29ed8a" translate="yes" xml:space="preserve">
          <source>This method requires Julia 1.2 or later.</source>
          <target state="translated">この方法では、Julia 1.2以降が必要です。</target>
        </trans-unit>
        <trans-unit id="899440f2ea2fee6c702b6f89d814399868b760bc" translate="yes" xml:space="preserve">
          <source>This method requires at least Julia 1.1.</source>
          <target state="translated">この方法には少なくともJulia 1.1が必要です。</target>
        </trans-unit>
        <trans-unit id="870b2fd7cad296236db6b2acee5daac8bcbed1f1" translate="yes" xml:space="preserve">
          <source>This method requires at least Julia 1.2.</source>
          <target state="translated">このメソッドには少なくともJulia 1.2が必要です。</target>
        </trans-unit>
        <trans-unit id="df192a99d234108a172dc69e2511778133fdb5c8" translate="yes" xml:space="preserve">
          <source>This method uses the &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; function to explicitly convert &lt;code&gt;x&lt;/code&gt; to &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; and then delegates construction to the general constructor for the case where both arguments are &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;. With this method definition what was previously a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; now successfully creates a point of type &lt;code&gt;Point{Float64}&lt;/code&gt;:</source>
          <target state="translated">このメソッドは、&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;関数を使用して &lt;code&gt;x&lt;/code&gt; を明示的に&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;に変換し、両方の引数が&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;である場合に備えて、構築を汎用コンストラクターに委任します。このメソッド定義を使用して、以前は&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; で&lt;/a&gt;あったものが、 &lt;code&gt;Point{Float64}&lt;/code&gt; 型のポイントを正常に作成します。</target>
        </trans-unit>
        <trans-unit id="f6303e3b58af767dd0d1fbddaa5592d4577466dc" translate="yes" xml:space="preserve">
          <source>This might be worthwhile when either of the following are true:</source>
          <target state="translated">これは、以下のどちらかが当てはまる場合には、価値があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="caca6d3dad29a6885489c96c973507436880d558" translate="yes" xml:space="preserve">
          <source>This module defines a type &lt;code&gt;MyType&lt;/code&gt;, and two functions. Function &lt;code&gt;foo&lt;/code&gt; and type &lt;code&gt;MyType&lt;/code&gt; are exported, and so will be available for importing into other modules. Function &lt;code&gt;bar&lt;/code&gt; is private to &lt;code&gt;MyModule&lt;/code&gt;.</source>
          <target state="translated">このモジュールは、タイプ &lt;code&gt;MyType&lt;/code&gt; と2つの関数を定義します。関数 &lt;code&gt;foo&lt;/code&gt; およびタイプ &lt;code&gt;MyType&lt;/code&gt; がエクスポートされるため、他のモジュールへのインポートに使用できます。関数 &lt;code&gt;bar&lt;/code&gt; は &lt;code&gt;MyModule&lt;/code&gt; 専用です。</target>
        </trans-unit>
        <trans-unit id="e361081ac903885d30799d0af09374c26253366e" translate="yes" xml:space="preserve">
          <source>This new compact representation will be used when the passed IO stream is an &lt;code&gt;IOContext&lt;/code&gt; object with the &lt;code&gt;:compact&lt;/code&gt; property set. In particular, this is the case when printing arrays with multiple columns (where horizontal space is limited):</source>
          <target state="translated">この新しいコンパクト表現は、渡されたIOストリームが &lt;code&gt;:compact&lt;/code&gt; プロパティが設定された &lt;code&gt;IOContext&lt;/code&gt; オブジェクトである場合に使用されます。特に、これは複数の列（水平方向のスペースが限られている）の配列を印刷する場合に当てはまります。</target>
        </trans-unit>
        <trans-unit id="c9d9b11cb845e47e607c614fa51676b8589b0e20" translate="yes" xml:space="preserve">
          <source>This normalized form for a ratio of integers is unique, so equality of rational values can be tested by checking for equality of the numerator and denominator. The standardized numerator and denominator of a rational value can be extracted using the &lt;a href=&quot;../../base/math/index#Base.numerator&quot;&gt;&lt;code&gt;numerator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.denominator&quot;&gt;&lt;code&gt;denominator&lt;/code&gt;&lt;/a&gt; functions:</source>
          <target state="translated">整数の比率のこの正規化された形式は一意であるため、分子と分母が等しいかどうかをチェックすることにより、有理値の等しいかどうかをテストできます。有理値の標準化された分子と分母は、&lt;a href=&quot;../../base/math/index#Base.numerator&quot;&gt; &lt;code&gt;numerator&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/math/index#Base.denominator&quot;&gt; &lt;code&gt;denominator&lt;/code&gt; &lt;/a&gt;関数を使用して抽出できます。</target>
        </trans-unit>
        <trans-unit id="6ae131da59b641e6a04de571be058c6c357d2762" translate="yes" xml:space="preserve">
          <source>This object is NOT thread-safe. See &lt;a href=&quot;#Base.Threads.Condition&quot;&gt;&lt;code&gt;Threads.Condition&lt;/code&gt;&lt;/a&gt; for a thread-safe version.</source>
          <target state="translated">このオブジェクトはスレッドセーフではありません。スレッドセーフバージョンについては、&lt;a href=&quot;#Base.Threads.Condition&quot;&gt; &lt;code&gt;Threads.Condition&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7e4a7f18d5f3325b0b4b506c0553650e84bb55e2" translate="yes" xml:space="preserve">
          <source>This operation is intended for linear algebra usage - for general data manipulation see &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt;&lt;code&gt;permutedims&lt;/code&gt;&lt;/a&gt;, which is non-recursive.</source>
          <target state="translated">この操作は、線形代数の使用を目的としています。一般的なデータ操作については、非再帰的な&lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt; &lt;code&gt;permutedims&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="68fb902f0905ca9a9a84e0916a21520831fc7805" translate="yes" xml:space="preserve">
          <source>This operation is intended for linear algebra usage - for general data manipulation see &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt;&lt;code&gt;permutedims&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">この操作は、線形代数の使用を目的としています。一般的なデータ操作については、&lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt; &lt;code&gt;permutedims&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5890e27550178f3b3f621b391f08592d04b935ac" translate="yes" xml:space="preserve">
          <source>This operator follows IEEE semantics for floating-point numbers: &lt;code&gt;0.0 == -0.0&lt;/code&gt; and &lt;code&gt;NaN != NaN&lt;/code&gt;.</source>
          <target state="translated">この演算子は、浮動小数点数のIEEEセマンティクスに従います： &lt;code&gt;0.0 == -0.0&lt;/code&gt; および &lt;code&gt;NaN != NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f45001a85e32a4368ea2b2117472a674fb4b812d" translate="yes" xml:space="preserve">
          <source>This output tells us that &lt;code&gt;f&lt;/code&gt; is a function object with two methods. To find out what the signatures of those methods are, use the &lt;a href=&quot;../../base/base/index#Base.methods&quot;&gt;&lt;code&gt;methods&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">この出力は、 &lt;code&gt;f&lt;/code&gt; が2つのメソッドを持つ関数オブジェクトであることを示しています。これらのメソッドのシグネチャが何であるかを確認するには、&lt;a href=&quot;../../base/base/index#Base.methods&quot;&gt; &lt;code&gt;methods&lt;/code&gt; &lt;/a&gt;関数を使用します。</target>
        </trans-unit>
        <trans-unit id="27399a34acfc119b2b6802fe2da7d02ba2868aed" translate="yes" xml:space="preserve">
          <source>This pattern is implemented by defining a generic function which computes a different singleton value (or type) for each trait-set to which the function arguments may belong to. If this function is pure there is no impact on performance compared to normal dispatch.</source>
          <target state="translated">このパターンは、関数の引数が属する可能性のある形質集合ごとに異なるシングルトン値(または型)を計算する汎用関数を定義することで実装されます。この関数が純粋なものであれば、通常のディスパッチと比較してパフォーマンスに影響はありません。</target>
        </trans-unit>
        <trans-unit id="c8dd670a38453a8c5ac96a2263bb252ef6b9b2f1" translate="yes" xml:space="preserve">
          <source>This pattern is so frequent that a helper type named &lt;code&gt;Random.SamplerSimple&lt;/code&gt; is available, saving us the definition of &lt;code&gt;SamplerDie&lt;/code&gt;: we could have implemented our decoupling with:</source>
          <target state="translated">このパターンは頻繁に使用されるため、 &lt;code&gt;Random.SamplerSimple&lt;/code&gt; という名前のヘルパータイプを使用できるので、 &lt;code&gt;SamplerDie&lt;/code&gt; の定義を節約できます。</target>
        </trans-unit>
        <trans-unit id="788eade9955684aef54020e83665092b3b21d4bd" translate="yes" xml:space="preserve">
          <source>This pattern is used in several places in Julia Base. For example, see &lt;code&gt;vcat&lt;/code&gt; and &lt;code&gt;hcat&lt;/code&gt; in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/40fe264f4ffaa29b749bcf42239a89abdcbba846/base/abstractarray.jl#L1205-L1206&quot;&gt;&lt;code&gt;abstractarray.jl&lt;/code&gt;&lt;/a&gt;, or the &lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt;&lt;code&gt;fill!&lt;/code&gt;&lt;/a&gt; function, which we could have used instead of writing our own &lt;code&gt;fill_twos!&lt;/code&gt;.</source>
          <target state="translated">このパターンは、ジュリアベースのいくつかの場所で使用されています。たとえば、&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/40fe264f4ffaa29b749bcf42239a89abdcbba846/base/abstractarray.jl#L1205-L1206&quot;&gt; &lt;code&gt;abstractarray.jl&lt;/code&gt; の&lt;/a&gt; &lt;code&gt;vcat&lt;/code&gt; および &lt;code&gt;hcat&lt;/code&gt; 、または&lt;a href=&quot;../../base/arrays/index#Base.fill!&quot;&gt; &lt;code&gt;fill!&lt;/code&gt; を&lt;/a&gt;参照してください。関数、独自の &lt;code&gt;fill_twos!&lt;/code&gt; 代わりに使用できます！。</target>
        </trans-unit>
        <trans-unit id="a07692e105ddc917557be8ec34d26c6d0d0ad87f" translate="yes" xml:space="preserve">
          <source>This pipes the output of the &lt;code&gt;echo&lt;/code&gt; command to the &lt;code&gt;sort&lt;/code&gt; command. Of course, this isn't terribly interesting since there's only one line to sort, but we can certainly do much more interesting things:</source>
          <target state="translated">これは、 &lt;code&gt;echo&lt;/code&gt; コマンドの出力を &lt;code&gt;sort&lt;/code&gt; コマンドにパイプします。もちろん、並べ替える行が1行しかないので、これはそれほど興味深いことではありませんが、もっと興味深いことを実行できます。</target>
        </trans-unit>
        <trans-unit id="28745bdf70806fa587f3e325d2378a4dbc6461d5" translate="yes" xml:space="preserve">
          <source>This prints the highest five user IDs on a UNIX system. The &lt;code&gt;cut&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;tail&lt;/code&gt; commands are all spawned as immediate children of the current &lt;code&gt;julia&lt;/code&gt; process, with no intervening shell process. Julia itself does the work to setup pipes and connect file descriptors that is normally done by the shell. Since Julia does this itself, it retains better control and can do some things that shells cannot.</source>
          <target state="translated">これにより、UNIXシステムで上位5つのユーザーIDが出力されます。 &lt;code&gt;cut&lt;/code&gt; 、 &lt;code&gt;sort&lt;/code&gt; や &lt;code&gt;tail&lt;/code&gt; のコマンドは、現在のすべての直接の子として生まれたされている &lt;code&gt;julia&lt;/code&gt; 介在しないシェルプロセスで、プロセス。Julia自体がパイプをセットアップし、通常シェルによって行われるファイル記述子を接続する作業を行います。ジュリア自身がこれを行うので、より良い制御を保持し、シェルができないいくつかのことを行うことができます。</target>
        </trans-unit>
        <trans-unit id="23fa7f062adc867f3f830f4783d112980678deb3" translate="yes" xml:space="preserve">
          <source>This project file implies the following roots map, if it was represented by a Julia dictionary:</source>
          <target state="translated">このプロジェクトファイルは、Julia辞書で表現されている場合、以下のようなルーツマップを意味しています。</target>
        </trans-unit>
        <trans-unit id="abc51e24a31d52999d77393c1e2d796880b68886" translate="yes" xml:space="preserve">
          <source>This quantity is also known in the literature as the Bauer condition number, relative condition number, or componentwise relative condition number.</source>
          <target state="translated">この量は、文献ではバウアー条件数、相対条件数、または成分的相対条件数としても知られています。</target>
        </trans-unit>
        <trans-unit id="2e42070fb796891f9806f28a3d77516fa4beb07e" translate="yes" xml:space="preserve">
          <source>This regex has the first three flags enabled.</source>
          <target state="translated">この正規表現では、最初の3つのフラグが有効になっています。</target>
        </trans-unit>
        <trans-unit id="ee3fcabcdbbc8234e7f06a55081b08ead3e3a1c5" translate="yes" xml:space="preserve">
          <source>This relationship is also invariant:</source>
          <target state="translated">この関係も不変です。</target>
        </trans-unit>
        <trans-unit id="59fcc1007eeaedfc2adf51cf837dd399f227cb88" translate="yes" xml:space="preserve">
          <source>This returns a &lt;code&gt;5&amp;times;5 Bidiagonal{Float64}&lt;/code&gt;, which can now be passed to other linear algebra functions (e.g. eigensolvers) which will use specialized methods for &lt;code&gt;Bidiagonal&lt;/code&gt; types.</source>
          <target state="translated">これは &lt;code&gt;5&amp;times;5 Bidiagonal{Float64}&lt;/code&gt; 返します。これは、 &lt;code&gt;Bidiagonal&lt;/code&gt; 型に特化したメソッドを使用する他の線形代数関数（たとえば、固有ソルバー）に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="51739dfebbc5e267c6346f6dae65d7a77c8eb77b" translate="yes" xml:space="preserve">
          <source>This section describes Julia's markdown syntax, which is enabled by the Markdown standard library. The following Markdown elements are supported:</source>
          <target state="translated">このセクションでは、Markdown標準ライブラリによって有効になっているJuliaのMarkdown構文について説明します。以下のMarkdown要素がサポートされています。</target>
        </trans-unit>
        <trans-unit id="dfa63ea10e93a9723f06f6e4891ca5c36280959e" translate="yes" xml:space="preserve">
          <source>This seems obvious, because two of each of these periods still divides evenly into the next larger order period. But in the case of two months (which still divides evenly into one year), the answer may be surprising:</source>
          <target state="translated">これは明らかなようで、それぞれの期間のうちの2つはまだ次のより大きな次数の期間に均等に分割されているからです。しかし、2ヶ月(それでも1年に均等に分割されている)の場合は、意外な答えが出てくるかもしれません。</target>
        </trans-unit>
        <trans-unit id="90f8183fe3e114c60192daf58de9ecad787e8334" translate="yes" xml:space="preserve">
          <source>This sets the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;LLVM Fast-Math flags&lt;/a&gt;, and corresponds to the &lt;code&gt;-ffast-math&lt;/code&gt; option in clang. See &lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations-1&quot;&gt;the notes on performance annotations&lt;/a&gt; for more details.</source>
          <target state="translated">これは&lt;a href=&quot;http://llvm.org/docs/LangRef.html#fast-math-flags&quot;&gt;LLVM Fast-Mathフラグを&lt;/a&gt;設定し、clangの &lt;code&gt;-ffast-math&lt;/code&gt; オプションに対応します。詳細について&lt;a href=&quot;../../manual/performance-tips/index#man-performance-annotations-1&quot;&gt;は、パフォーマンスアノテーション&lt;/a&gt;に関する注意をご覧ください。</target>
        </trans-unit>
        <trans-unit id="3f1e8b5b57b03661a32579fb9fe3d14174f160bb" translate="yes" xml:space="preserve">
          <source>This setting will cause &lt;code&gt;eachindex&lt;/code&gt; iteration over a &lt;code&gt;MyArray&lt;/code&gt; to use integers. If you don't specify this trait, the default value &lt;code&gt;IndexCartesian()&lt;/code&gt; is used.</source>
          <target state="translated">この設定は、原因となります &lt;code&gt;eachindex&lt;/code&gt; にわたり反復を &lt;code&gt;MyArray&lt;/code&gt; という使用整数へ。この特性を指定しない場合、デフォルト値 &lt;code&gt;IndexCartesian()&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="dd212ee97174c1074845d2f071ed810c2eb44e14" translate="yes" xml:space="preserve">
          <source>This should be written as:</source>
          <target state="translated">と書くべきです。</target>
        </trans-unit>
        <trans-unit id="61e8d88c0f9a32cfa6a86779f848c68e25d1219f" translate="yes" xml:space="preserve">
          <source>This situation can happen only for invalid UTF-8 strings. For valid UTF-8 strings concatenation preserves all characters in strings and additivity of string lengths.</source>
          <target state="translated">こ の状況は、 無効な UTF-8 文字列に対してのみ発生 し ます。有効な UTF-8 文字列の場合、連結は文字列内のすべてのキ ャ ラ ク タ と 文字列長の加算性を保持 し ます。</target>
        </trans-unit>
        <trans-unit id="602515b8cfd836d63ad817e8e5eb0cdf75d4d344" translate="yes" xml:space="preserve">
          <source>This small handful of promotion rules, together with the type's constructors and the default &lt;code&gt;convert&lt;/code&gt; method for numbers, are sufficient to make rational numbers interoperate completely naturally with all of Julia's other numeric types &amp;ndash; integers, floating-point numbers, and complex numbers. By providing appropriate conversion methods and promotion rules in the same manner, any user-defined numeric type can interoperate just as naturally with Julia's predefined numerics.</source>
          <target state="translated">この少数のプロモーションルールは、型のコンストラクターおよび数値のデフォルトの &lt;code&gt;convert&lt;/code&gt; メソッドと共に、有理数をJuliaの他のすべての数値型（整数、浮動小数点数、複素数）と完全に自然に相互運用させるのに十分です。同じ方法で適切な変換方法とプロモーションルールを提供することにより、ユーザー定義の数値型は、Juliaの事前定義された数値と自然に同じように相互運用できます。</target>
        </trans-unit>
        <trans-unit id="62b4befadfb2df7bd237a94a52e5e887dfce736d" translate="yes" xml:space="preserve">
          <source>This sort of in-language code generation, however, using the &lt;code&gt;eval(quote(...))&lt;/code&gt; pattern, is common enough that Julia comes with a macro to abbreviate this pattern:</source>
          <target state="translated">ただし、 &lt;code&gt;eval(quote(...))&lt;/code&gt; パターンを使用したこの種の言語内コード生成は、Juliaがこのパターンを短縮するマクロを提供するのに十分一般的です。</target>
        </trans-unit>
        <trans-unit id="29761b0f52dd794108c079b8401444ddd6c7292e" translate="yes" xml:space="preserve">
          <source>This style of code presents performance challenges for the language. The parser, when translating it into lower-level instructions, substantially reorganizes the above code by extracting the inner function to a separate code block. &quot;Captured&quot; variables such as &lt;code&gt;r&lt;/code&gt; that are shared by inner functions and their enclosing scope are also extracted into a heap-allocated &quot;box&quot; accessible to both inner and outer functions because the language specifies that &lt;code&gt;r&lt;/code&gt; in the inner scope must be identical to &lt;code&gt;r&lt;/code&gt; in the outer scope even after the outer scope (or another inner function) modifies &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">このコードスタイルは、言語のパフォーマンスの課題を提示します。パーサーは、それを下位レベルの命令に変換するときに、内部関数を別のコードブロックに抽出することにより、上記のコードを実質的に再編成します。内部関数の &lt;code&gt;r&lt;/code&gt; は &lt;code&gt;r&lt;/code&gt; と同一でなければならないことを言語が指定しているため、内部関数とそれらを囲むスコープによって共有される &lt;code&gt;r&lt;/code&gt; などの「キャプチャされた」変数も、ヒープに割り当てられた「ボックス」に抽出されます。外部スコープ（または別の内部関数）が &lt;code&gt;r&lt;/code&gt; を変更した後でも、外部スコープ内。</target>
        </trans-unit>
        <trans-unit id="84f5c4c03a8a8eafdd24b33dcdffe8977865737f" translate="yes" xml:space="preserve">
          <source>This style point is especially relevant to function arguments. For example, don't declare an argument to be of type &lt;code&gt;Int&lt;/code&gt; or &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt; if it really could be any integer, expressed with the abstract type &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;. In fact, in many cases you can omit the argument type altogether, unless it is needed to disambiguate from other method definitions, since a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; will be thrown anyway if a type is passed that does not support any of the requisite operations. (This is known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Duck_typing&quot;&gt;duck typing&lt;/a&gt;.)</source>
          <target state="translated">このスタイルのポイントは、特に関数の引数に関連しています。たとえば、抽象型&lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt;で表現された整数である可能性がある場合は、引数を &lt;code&gt;Int&lt;/code&gt; または&lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt;型として宣言しないでください。実際、多くの場合、他のメソッド定義から明確にする必要がない限り、引数の型を完全に省略することができます。必要な操作をサポートしない型が渡された場合はとにかく&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;がスローされるためです。（これは&lt;a href=&quot;https://en.wikipedia.org/wiki/Duck_typing&quot;&gt;ダックタイピング&lt;/a&gt;として知られています。）</target>
        </trans-unit>
        <trans-unit id="efb1d086124f576400d48da57453f979b82b1320" translate="yes" xml:space="preserve">
          <source>This syntax is paired with the inline syntax for &lt;a href=&quot;#Footnote-references-1&quot;&gt;Footnote references&lt;/a&gt;. Make sure to read that section as well.</source>
          <target state="translated">この構文は、&lt;a href=&quot;#Footnote-references-1&quot;&gt;脚注参照の&lt;/a&gt;インライン構文と対になっています。そのセクションも必ずお読みください。</target>
        </trans-unit>
        <trans-unit id="c6d5e6bac01082ca8f7d5c92e2fcad7892b0deee" translate="yes" xml:space="preserve">
          <source>This syntax is particularly useful with the terse single-line function definition form introduced in &lt;a href=&quot;../faq/index#Functions-1&quot;&gt;Functions&lt;/a&gt;. Although it is typical, there is no requirement that &lt;code&gt;begin&lt;/code&gt; blocks be multiline or that &lt;code&gt;(;)&lt;/code&gt; chains be single-line:</source>
          <target state="translated">この構文は、&lt;a href=&quot;../faq/index#Functions-1&quot;&gt;関数で&lt;/a&gt;導入された簡潔な単一行関数定義フォームで特に役立ちます。典型的ですが、 &lt;code&gt;begin&lt;/code&gt; ブロックが複数行であったり、 &lt;code&gt;(;)&lt;/code&gt; チェーンが単一行であったりする必要はありません。</target>
        </trans-unit>
        <trans-unit id="f077087d177239939e6f396d6a624b184f2ac650" translate="yes" xml:space="preserve">
          <source>This syntax makes it easier to use functions to effectively extend the language, since calls look like normal code blocks. There are many possible uses quite different from &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, such as managing system state. For example, there is a version of &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; that runs code ensuring that the opened file is eventually closed:</source>
          <target state="translated">呼び出しは通常のコードブロックのように見えるため、この構文を使用すると、関数を使用して言語を効果的に拡張しやすくなります。システム状態の管理など、&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;とはかなり異なる多くの用途が考えられます。たとえば、開いているファイルが最終的に閉じられるようにするコードを実行する&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; の&lt;/a&gt;バージョンがあります。</target>
        </trans-unit>
        <trans-unit id="1d1ae67ce8368a39428c877f009a37b4f880a256" translate="yes" xml:space="preserve">
          <source>This table may appear to contain missing characters in the second column, or even show characters that are inconsistent with the characters as they are rendered in the Julia REPL. In these cases, users are strongly advised to check their choice of fonts in their browser and REPL environment, as there are known issues with glyphs in many fonts.</source>
          <target state="translated">この表は、第2列に欠落した文字が含まれているように見えたり、Julia REPLでレンダリングされている文字と矛盾した文字が表示されたりすることがあります。このような場合、多くのフォントにグリフの問題があることが知られているので、ユーザはブラウザとREPL環境でフォントの選択を確認することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="c89bcac53db86417f8d21a8b570dbed4f33b9ba7" translate="yes" xml:space="preserve">
          <source>This trait is generally used to select between algorithms that pre-allocate a specific type of result, and algorithms that pick a result type based on the types of yielded values.</source>
          <target state="translated">この特性は、一般的に、特定のタイプの結果を事前に割り当てるアルゴリズムと、生成された値のタイプに基づいて結果のタイプを選択するアルゴリズムの間で選択するために使用されます。</target>
        </trans-unit>
        <trans-unit id="1f0edb00527596f441fd9eb4ee2e34299adf317c" translate="yes" xml:space="preserve">
          <source>This trait is generally used to select between algorithms that pre-allocate space for their result, and algorithms that resize their result incrementally.</source>
          <target state="translated">この特性は、一般的に、結果のためにスペースを事前に確保するアルゴリズムと、結果のサイズをインクリメンタルに変更するアルゴリズムの間で選択するために使用されます。</target>
        </trans-unit>
        <trans-unit id="2b71013f6265bcf3fbfa85be77bdc79abb70d813" translate="yes" xml:space="preserve">
          <source>This trait-based approach is also present in the &lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt;&lt;code&gt;promote&lt;/code&gt;&lt;/a&gt; mechanism employed by the scalar &lt;code&gt;+&lt;/code&gt;. It uses &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt;, which returns the optimal common type to compute the operation given the two types of the operands. This makes it possible to reduce the problem of implementing every function for every pair of possible type arguments, to the much smaller problem of implementing a conversion operation from each type to a common type, plus a table of preferred pair-wise promotion rules.</source>
          <target state="translated">この特性ベースのアプローチは、スカラー &lt;code&gt;+&lt;/code&gt; によって採用される&lt;a href=&quot;../../base/base/index#Base.promote&quot;&gt; &lt;code&gt;promote&lt;/code&gt; &lt;/a&gt;メカニズムにも存在します。2つのタイプのオペランドが指定されている&lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt;、最適な共通タイプを返し、演算を計算するPromote_typeを使用します。これにより、考えられる型引数のすべてのペアに対してすべての関数を実装する問題を軽減し、各型から共通の型への変換操作を実装するというはるかに小さな問題に加えて、優先ペアワイズプロモーションルールの表を作成できます。</target>
        </trans-unit>
        <trans-unit id="c92d7110a049bc7dcfccf1f71e9a16f713393738" translate="yes" xml:space="preserve">
          <source>This type is intended for linear algebra usage - for general data manipulation see &lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt;&lt;code&gt;permutedims&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このタイプは、線形代数の使用を目的としています。一般的なデータ操作については、&lt;a href=&quot;../../base/arrays/index#Base.permutedims&quot;&gt; &lt;code&gt;permutedims&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="14576a2d3cb9e572c8640a36656bd2d6880b92e4" translate="yes" xml:space="preserve">
          <source>This type may appear innocuous enough, until one considers how to construct an instance of it. If &lt;code&gt;a&lt;/code&gt; is an instance of &lt;code&gt;SelfReferential&lt;/code&gt;, then a second instance can be created by the call:</source>
          <target state="translated">この型は、そのインスタンスの作成方法を検討するまでは、無害に見えるかもしれません。場合のインスタンスである &lt;code&gt;SelfReferential&lt;/code&gt; 、2番目のインスタンスは、呼び出しによって作成することができます。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48abfe02204852dcf9f8e73526e2ce7ae985ea01" translate="yes" xml:space="preserve">
          <source>This typically means that types for which a custom &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;isequal&lt;/code&gt; method exists must implement a corresponding &lt;code&gt;hash&lt;/code&gt; method (and vice versa). Collections typically implement &lt;code&gt;isequal&lt;/code&gt; by calling &lt;code&gt;isequal&lt;/code&gt; recursively on all contents.</source>
          <target state="translated">これは通常、カスタム &lt;code&gt;==&lt;/code&gt; または &lt;code&gt;isequal&lt;/code&gt; メソッドが存在する型は、対応する &lt;code&gt;hash&lt;/code&gt; メソッドを実装する必要があることを意味します（逆も同様です）。コレクションは、一般的に実装する &lt;code&gt;isequal&lt;/code&gt; 呼び出すことにより、 &lt;code&gt;isequal&lt;/code&gt; すべての内容を再帰的に。</target>
        </trans-unit>
        <trans-unit id="e583420152cbf4b34f9b32d8a694ae8548f399df" translate="yes" xml:space="preserve">
          <source>This will continuing tracking changes for &lt;code&gt;path&lt;/code&gt; in the background until &lt;code&gt;unwatch_folder&lt;/code&gt; is called on the same &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">これは、同じ &lt;code&gt;path&lt;/code&gt; &lt;code&gt;unwatch_folder&lt;/code&gt; が呼び出されるまで、バックグラウンドで &lt;code&gt;path&lt;/code&gt; 変更を追跡し続けます。</target>
        </trans-unit>
        <trans-unit id="f13e78aea1113a7ecb31103654e0f08522f06f04" translate="yes" xml:space="preserve">
          <source>This will create a link in the generated docs to the &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; documentation (which has more information about what this function actually does), and to the &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; documentation. It's good to include cross references to mutating/non-mutating versions of a function, or to highlight a difference between two similar-seeming functions.</source>
          <target state="translated">これにより、生成されたドキュメントに&lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt;ドキュメント（この関数が実際に行うことについての詳細が含まれています）へのリンクと、&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;ドキュメントへのリンクが作成されます。関数の変化するバージョンまたは変化しないバージョンへの相互参照を含めるか、2つの類似した関数の違いを強調することは良いことです。</target>
        </trans-unit>
        <trans-unit id="c2a99e60f54b8d446ae19455b15a099ea1107a66" translate="yes" xml:space="preserve">
          <source>This will return &lt;code&gt;(-1, 0)&lt;/code&gt;.</source>
          <target state="translated">これは &lt;code&gt;(-1, 0)&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="286660d1556fa7b595f130646ffbfab297bc669e" translate="yes" xml:space="preserve">
          <source>This will run afoul of a method that supplies default padding:</source>
          <target state="translated">これは、デフォルトのパディングを提供するメソッドに違反することになります。</target>
        </trans-unit>
        <trans-unit id="0f5b3315acf48556d7fa62b1bfb954506305c5d1" translate="yes" xml:space="preserve">
          <source>This will typically be the parent directory of &lt;code&gt;gitdir(repo)&lt;/code&gt;, but can be different in some cases: e.g. if either the &lt;code&gt;core.worktree&lt;/code&gt; configuration variable or the &lt;code&gt;GIT_WORK_TREE&lt;/code&gt; environment variable is set.</source>
          <target state="translated">これは通常 &lt;code&gt;gitdir(repo)&lt;/code&gt; の親ディレクトリになりますが、たとえば &lt;code&gt;core.worktree&lt;/code&gt; 構成変数または &lt;code&gt;GIT_WORK_TREE&lt;/code&gt; 環境変数が設定されている場合など、場合によっては異なることがあります。</target>
        </trans-unit>
        <trans-unit id="465cd08242692b4a225db05b65fef6a04fbb4c51" translate="yes" xml:space="preserve">
          <source>This works, but (as you can verify for yourself using &lt;code&gt;@code_warntype array3(5.0, 2)&lt;/code&gt;) the problem is that the output type cannot be inferred: the argument &lt;code&gt;N&lt;/code&gt; is a &lt;em&gt;value&lt;/em&gt; of type &lt;code&gt;Int&lt;/code&gt;, and type-inference does not (and cannot) predict its value in advance. This means that code using the output of this function has to be conservative, checking the type on each access of &lt;code&gt;A&lt;/code&gt;; such code will be very slow.</source>
          <target state="translated">これは機能しますが、（ &lt;code&gt;@code_warntype array3(5.0, 2)&lt;/code&gt; を使用して自分で確認できるように）問題は、出力タイプを推論できないことです：引数 &lt;code&gt;N&lt;/code&gt; はタイプ &lt;code&gt;Int&lt;/code&gt; の&lt;em&gt;値&lt;/em&gt;であり、タイプ推論は（そして事前にその値を予測することはできません。つまり、この関数の出力を使用するコードは保守的でなければならず、 &lt;code&gt;A&lt;/code&gt; の各アクセスで型をチェックします。このようなコードは非常に遅くなります。</target>
        </trans-unit>
        <trans-unit id="91dccd376458eb0eba1948b74924d4cacdf4e65c" translate="yes" xml:space="preserve">
          <source>This would provide custom showing of vectors with a specific new element type. While tempting, this should be avoided. The trouble is that users will expect a well-known type like &lt;code&gt;Vector()&lt;/code&gt; to behave in a certain way, and overly customizing its behavior can make it harder to work with.</source>
          <target state="translated">これにより、特定の新しい要素タイプを持つベクターのカスタム表示が提供されます。魅力的な間、これは避けられるべきです。問題は、 &lt;code&gt;Vector()&lt;/code&gt; のようなよく知られた型が特定の方法で動作することをユーザーが期待することであり、その動作を過度にカスタマイズすると、操作が困難になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="ad99bad1a037688795be38c39427fa0769348cbe" translate="yes" xml:space="preserve">
          <source>Though most code can be written in Julia, there are many high-quality, mature libraries for numerical computing already written in C and Fortran. To allow easy use of this existing code, Julia makes it simple and efficient to call C and Fortran functions. Julia has a &quot;no boilerplate&quot; philosophy: functions can be called directly from Julia without any &quot;glue&quot; code, code generation, or compilation &amp;ndash; even from the interactive prompt. This is accomplished just by making an appropriate call with &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; syntax, which looks like an ordinary function call.</source>
          <target state="translated">ほとんどのコードはJuliaで記述できますが、CおよびFortranで記述された数値計算用の高品質で成熟したライブラリが多数あります。この既存のコードを簡単に使用できるようにするために、JuliaはCおよびFortran関数の呼び出しを簡単かつ効率的にします。Juliaには「定型文なし」の哲学があります。関数は、「グルー」コード、コード生成、またはコンパイルなしで、Juliaから直接呼び出すことができます-対話型プロンプトからでも。これは、通常の関数呼び出しのように見える、&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;構文で適切な呼び出しを行うだけで実現できます。</target>
        </trans-unit>
        <trans-unit id="b1098d0533850d709c2eea0b6cccb4d789ad7a33" translate="yes" xml:space="preserve">
          <source>Thought Balloon</source>
          <target state="translated">思考バルーン</target>
        </trans-unit>
        <trans-unit id="e7d883028ca01a1fd0855b14863bfa7121240ec4" translate="yes" xml:space="preserve">
          <source>Thread-safety</source>
          <target state="translated">Thread-safety</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="e419e1146ddb88bafc45f8ebac6b8292c4ced05a" translate="yes" xml:space="preserve">
          <source>Threads.@threads</source>
          <target state="translated">Threads.@threads</target>
        </trans-unit>
        <trans-unit id="af0966b4fd9f2b0cc49a7865b215af5194f37f0a" translate="yes" xml:space="preserve">
          <source>Threads.Atomic</source>
          <target state="translated">Threads.Atomic</target>
        </trans-unit>
        <trans-unit id="6d681958311270ce80eaf4515832385236fe2aa7" translate="yes" xml:space="preserve">
          <source>Threads.Condition</source>
          <target state="translated">Threads.Condition</target>
        </trans-unit>
        <trans-unit id="35d529a964d25f4e3aa6ca9d1ca0ce8f4be400d6" translate="yes" xml:space="preserve">
          <source>Threads.Mutex</source>
          <target state="translated">Threads.Mutex</target>
        </trans-unit>
        <trans-unit id="fdec23601f6d79aec8f6567bbffa2c92cd56f7b8" translate="yes" xml:space="preserve">
          <source>Threads.SpinLock</source>
          <target state="translated">Threads.SpinLock</target>
        </trans-unit>
        <trans-unit id="dc252ab69b1ee919bcf5db69994a187e411ca970" translate="yes" xml:space="preserve">
          <source>Threads.atomic_add!()</source>
          <target state="translated">Threads.atomic_add!()</target>
        </trans-unit>
        <trans-unit id="0d6bade715cafd9dcdad87d2c22d90bbfc1e9bc3" translate="yes" xml:space="preserve">
          <source>Threads.atomic_and!()</source>
          <target state="translated">Threads.atomic_and!()</target>
        </trans-unit>
        <trans-unit id="fc348be87bc254a3559139ac661b72946bb39a71" translate="yes" xml:space="preserve">
          <source>Threads.atomic_cas!()</source>
          <target state="translated">Threads.atomic_cas!()</target>
        </trans-unit>
        <trans-unit id="f62c63142218283b0037fda6af5f0f3a02c2975f" translate="yes" xml:space="preserve">
          <source>Threads.atomic_fence()</source>
          <target state="translated">Threads.atomic_fence()</target>
        </trans-unit>
        <trans-unit id="4bb65236b89d5d31da9f4d8820a38668a9dbf21c" translate="yes" xml:space="preserve">
          <source>Threads.atomic_max!()</source>
          <target state="translated">Threads.atomic_max!()</target>
        </trans-unit>
        <trans-unit id="8833f2d74d5a7e5aa857580591ba695e2d6fc9b4" translate="yes" xml:space="preserve">
          <source>Threads.atomic_min!()</source>
          <target state="translated">Threads.atomic_min!()</target>
        </trans-unit>
        <trans-unit id="9d6eae92e1cf6253daf74605c345f63d354fc4f7" translate="yes" xml:space="preserve">
          <source>Threads.atomic_nand!()</source>
          <target state="translated">Threads.atomic_nand!()</target>
        </trans-unit>
        <trans-unit id="560bfbccb3de090b47f2c10c244f66c66c580494" translate="yes" xml:space="preserve">
          <source>Threads.atomic_or!()</source>
          <target state="translated">Threads.atomic_or!()</target>
        </trans-unit>
        <trans-unit id="f3e1cd9ba44ee30e82bb0904faa52cbf59c0038d" translate="yes" xml:space="preserve">
          <source>Threads.atomic_sub!()</source>
          <target state="translated">Threads.atomic_sub!()</target>
        </trans-unit>
        <trans-unit id="13028b27bde6678508d39212264589ec6a15feea" translate="yes" xml:space="preserve">
          <source>Threads.atomic_xchg!()</source>
          <target state="translated">Threads.atomic_xchg!()</target>
        </trans-unit>
        <trans-unit id="733c9373c4a5344eab540082f44fb3d0c9691c39" translate="yes" xml:space="preserve">
          <source>Threads.atomic_xor!()</source>
          <target state="translated">Threads.atomic_xor!()</target>
        </trans-unit>
        <trans-unit id="be840129016948f129890bec761377fa710398c9" translate="yes" xml:space="preserve">
          <source>Threads.nthreads()</source>
          <target state="translated">Threads.nthreads()</target>
        </trans-unit>
        <trans-unit id="a889ac57822379f233ec938a1f7a38f70d5c6296" translate="yes" xml:space="preserve">
          <source>Threads.threadid()</source>
          <target state="translated">Threads.threadid()</target>
        </trans-unit>
        <trans-unit id="0aad1c36c5f4e6d7170e1c4b0293604b8b212cfa" translate="yes" xml:space="preserve">
          <source>Three Consecutive Equals Signs</source>
          <target state="translated">三連続イコールサイン</target>
        </trans-unit>
        <trans-unit id="275c8d26b15f014b3ee22a364da92aa616ab6c12" translate="yes" xml:space="preserve">
          <source>Three Dimensional Angle</source>
          <target state="translated">三次元角度</target>
        </trans-unit>
        <trans-unit id="34c44d666ec4b94d3bbda9f288521e6aef7e833a" translate="yes" xml:space="preserve">
          <source>Three Leftwards Arrows</source>
          <target state="translated">三本の左矢印</target>
        </trans-unit>
        <trans-unit id="6845b5c6dca3f04d0fc4092b2f6f1fa8ad41c493" translate="yes" xml:space="preserve">
          <source>Three Rightwards Arrows</source>
          <target state="translated">三本の右矢印</target>
        </trans-unit>
        <trans-unit id="649300e311dc9e0d97883f25214a816938115a07" translate="yes" xml:space="preserve">
          <source>Throw a &lt;a href=&quot;#Core.TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; unless &lt;code&gt;x isa type&lt;/code&gt;. The syntax &lt;code&gt;x::type&lt;/code&gt; calls this function.</source>
          <target state="translated">&lt;code&gt;x isa type&lt;/code&gt; ない限り、&lt;a href=&quot;#Core.TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; を&lt;/a&gt;スローします。構文 &lt;code&gt;x::type&lt;/code&gt; はこの関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="714760623b81eda189caf56e00d3dd66b2ad778d" translate="yes" xml:space="preserve">
          <source>Throw an &lt;a href=&quot;#Core.AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;cond&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. Preferred syntax for writing assertions. Message &lt;code&gt;text&lt;/code&gt; is optionally displayed upon assertion failure.</source>
          <target state="translated">&lt;code&gt;cond&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; の場合、&lt;a href=&quot;#Core.AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; を&lt;/a&gt;スローします。アサーションを記述するための推奨構文。メッセージ &lt;code&gt;text&lt;/code&gt; は、アサーションの失敗時にオプションで表示されます。</target>
        </trans-unit>
        <trans-unit id="fde334b7c50e867ec42457ab4cfac34135b82f0a" translate="yes" xml:space="preserve">
          <source>Throw an error if the specified indices &lt;code&gt;I&lt;/code&gt; are not in bounds for the given array &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">指定されたインデックス &lt;code&gt;I&lt;/code&gt; が指定された配列 &lt;code&gt;A&lt;/code&gt; の境界内にない場合、エラーをスローします。</target>
        </trans-unit>
        <trans-unit id="7f0af829c424acf2aaed30a43af670830af1bf4e" translate="yes" xml:space="preserve">
          <source>Throw an object as an exception.</source>
          <target state="translated">例外としてオブジェクトをスローします。</target>
        </trans-unit>
        <trans-unit id="140ef8a807386c342270a60ed53ce02c73c18d34" translate="yes" xml:space="preserve">
          <source>Throw an object without changing the current exception backtrace. The default argument is the current exception (if called within a &lt;code&gt;catch&lt;/code&gt; block).</source>
          <target state="translated">現在の例外バックトレースを変更せずにオブジェクトをスローします。デフォルトの引数は現在の例外です（ &lt;code&gt;catch&lt;/code&gt; ブロック内で呼び出された場合）。</target>
        </trans-unit>
        <trans-unit id="580dadd5162b2d0824b14a53a53520885f69bb7a" translate="yes" xml:space="preserve">
          <source>Throwing Julia Exceptions</source>
          <target state="translated">ジュリアの例外を投げる</target>
        </trans-unit>
        <trans-unit id="b55eb9740df570160a4568c629959c237f6eace8" translate="yes" xml:space="preserve">
          <source>Thumbs Down Sign</source>
          <target state="translated">サムズダウンサイン</target>
        </trans-unit>
        <trans-unit id="605c4f2d25dae572dac0bd7100ede0e91ce19009" translate="yes" xml:space="preserve">
          <source>Thumbs Up Sign</source>
          <target state="translated">サムズアップサイン</target>
        </trans-unit>
        <trans-unit id="760c9c88e6ab4015bdda89ce2b03fc29323c09ed" translate="yes" xml:space="preserve">
          <source>Thus &lt;em&gt;lexical scope&lt;/em&gt; means that the scope of variables can be inferred from the source code alone.</source>
          <target state="translated">したがって、&lt;em&gt;字句スコープ&lt;/em&gt;は、変数のスコープをソースコードだけから推測できることを意味します。</target>
        </trans-unit>
        <trans-unit id="3c1904bf1147b9a9b4718a957b259ff3b20ed4ec" translate="yes" xml:space="preserve">
          <source>Thus global variables are only inherited for reading, not for writing:</source>
          <target state="translated">このように、グローバル変数は読み込み用にのみ継承され、書き込み用には継承されません。</target>
        </trans-unit>
        <trans-unit id="37807420ee61e708d970e7d90819e0a642c8a0c3" translate="yes" xml:space="preserve">
          <source>Thus programs should be careful referencing globals in remote calls. In fact, it is preferable to avoid them altogether if possible. If you must reference globals, consider using &lt;code&gt;let&lt;/code&gt; blocks to localize global variables.</source>
          <target state="translated">したがって、プログラムはリモート呼び出しでグローバルを注意深く参照する必要があります。実際、可能であればそれらを完全に回避することが望ましいです。グローバルを参照する必要がある場合は、 &lt;code&gt;let&lt;/code&gt; ブロックを使用してグローバル変数をローカライズすることを検討してください。</target>
        </trans-unit>
        <trans-unit id="1ec3104629ec61f45eec6025fd4920b5b97b82ff" translate="yes" xml:space="preserve">
          <source>Thus, a minimal cluster manager would need to:</source>
          <target state="translated">したがって、最小限のクラスタマネージャが必要になります。</target>
        </trans-unit>
        <trans-unit id="7b4c9299e93152df59eb2d7a356e597a287f7f91" translate="yes" xml:space="preserve">
          <source>Thus, a task executing a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; effectively prevents the Julia scheduler from executing any other tasks till the call returns. This is true for all calls into external libraries. Exceptions are calls into custom C code that call back into Julia (which may then yield) or C code that calls &lt;code&gt;jl_yield()&lt;/code&gt; (C equivalent of &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">したがって、&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;を実行するタスクは、呼び出しが戻るまでJuliaスケジューラーが他のタスクを実行するのを効果的に防ぎます。これは、外部ライブラリへのすべての呼び出しに当てはまります。例外は、JuliaにコールバックするカスタムCコードへの呼び出し（これにより、yieldが発生する可能性があります）または &lt;code&gt;jl_yield()&lt;/code&gt; を呼び出すCコード（Cが&lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt; &lt;code&gt;yield&lt;/code&gt; に&lt;/a&gt;相当）です。</target>
        </trans-unit>
        <trans-unit id="12a48793aeeeb710ac9dcc9260ed6b02480a02b9" translate="yes" xml:space="preserve">
          <source>Thus, abstract types allow programmers to write generic functions that can later be used as the default method by many combinations of concrete types. Thanks to multiple dispatch, the programmer has full control over whether the default or more specific method is used.</source>
          <target state="translated">このように、抽象型は、プログラマが後に具体的な型の多くの組み合わせによってデフォルトのメソッドとして使用されることができる汎用的な関数を書くことを可能にします。複数のディスパッチのおかげで、プログラマはデフォルトのメソッドを使用するか、より具体的なメソッドを使用するかを完全に制御することができます。</target>
        </trans-unit>
        <trans-unit id="f601caf538448fdd3302f7c350467ef72143226f" translate="yes" xml:space="preserve">
          <source>Thus, although the &lt;code&gt;⊘&lt;/code&gt; operator usually returns an instance of &lt;code&gt;OurRational&lt;/code&gt;, if either of its arguments are complex integers, it will return an instance of &lt;code&gt;Complex{OurRational}&lt;/code&gt; instead. The interested reader should consider perusing the rest of &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt;&lt;code&gt;rational.jl&lt;/code&gt;&lt;/a&gt;: it is short, self-contained, and implements an entire basic Julia type.</source>
          <target state="translated">けれども従って、 &lt;code&gt;⊘&lt;/code&gt; オペレータは通常のインスタンス戻り &lt;code&gt;OurRational&lt;/code&gt; を引数のいずれかが複素整数である場合、それはのインスタンス返され &lt;code&gt;Complex{OurRational}&lt;/code&gt; 代わりに。興味のある読者は、&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/rational.jl&quot;&gt; &lt;code&gt;rational.jl&lt;/code&gt; &lt;/a&gt;の残りの部分を熟読することを検討してください。これは短く、自己完結型で、基本的なJuliaタイプ全体を実装しています。</target>
        </trans-unit>
        <trans-unit id="626f028f772316f29a1f3bc180af9b3cc6e9feec" translate="yes" xml:space="preserve">
          <source>Thus, arithmetic with Julia integers is actually a form of &lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;modular arithmetic&lt;/a&gt;. This reflects the characteristics of the underlying arithmetic of integers as implemented on modern computers. In applications where overflow is possible, explicit checking for wraparound produced by overflow is essential; otherwise, the &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; type in &lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt; is recommended instead.</source>
          <target state="translated">したがって、ジュリア整数による算術は、実際には&lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;モジュラー算術の&lt;/a&gt;形式です。これは、現代のコンピューターに実装されている整数の基礎となる算術の特性を反映しています。オーバーフローが発生する可能性があるアプリケーションでは、オーバーフローによって生成されるラップアラウンドの明示的なチェックが不可欠です。それ以外の場合は、代わりに&lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;任意精度演算の&lt;/a&gt;&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;型をお勧めします。</target>
        </trans-unit>
        <trans-unit id="b2b83f1b321c20d701d32773b7f124c10518c979" translate="yes" xml:space="preserve">
          <source>Thus, the parser does not know that &lt;code&gt;r&lt;/code&gt; has a fixed type (&lt;code&gt;Int&lt;/code&gt;). nor that &lt;code&gt;r&lt;/code&gt; does not change value once the inner function is created (so that the box is unneeded). Therefore, the parser emits code for box that holds an object with an abstract type such as &lt;code&gt;Any&lt;/code&gt;, which requires run-time type dispatch for each occurrence of &lt;code&gt;r&lt;/code&gt;. This can be verified by applying &lt;code&gt;@code_warntype&lt;/code&gt; to the above function. Both the boxing and the run-time type dispatch can cause loss of performance.</source>
          <target state="translated">したがって、パーサーは &lt;code&gt;r&lt;/code&gt; が固定型（ &lt;code&gt;Int&lt;/code&gt; ）であることを認識していません。また、内部関数が作成されると、 &lt;code&gt;r&lt;/code&gt; は値を変更しません（ボックスが不要になるため）。したがって、パーサーは &lt;code&gt;Any&lt;/code&gt; のような抽象型のオブジェクトを保持するボックスのコードを発行します。これには、 &lt;code&gt;r&lt;/code&gt; が出現するたびにランタイム型のディスパッチが必要です。これは、上記の関数に &lt;code&gt;@code_warntype&lt;/code&gt; を適用することで確認できます。ボクシングとランタイムタイプのディスパッチの両方が、パフォーマンスの低下を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="405f79bc0440035cdbe7cdfa2f5f8191b1e769bd" translate="yes" xml:space="preserve">
          <source>Thus, use &lt;code&gt;Int&lt;/code&gt; literals when possible, with &lt;code&gt;Rational{Int}&lt;/code&gt; for literal non-integer numbers, in order to make it easier to use your code.</source>
          <target state="translated">したがって、コードを使いやすくするために、可能であれば &lt;code&gt;Int&lt;/code&gt; リテラルを使用し、 &lt;code&gt;Rational{Int}&lt;/code&gt; をリテラル非整数の数値に使用します。</target>
        </trans-unit>
        <trans-unit id="7dfa2079791005dea78a84f2b9726b0bdb6de3e2" translate="yes" xml:space="preserve">
          <source>Thus, while the implicit type parameter constructors provided by default in Julia are fairly strict, it is possible to make them behave in a more relaxed but sensible manner quite easily. Moreover, since constructors can leverage all of the power of the type system, methods, and multiple dispatch, defining sophisticated behavior is typically quite simple.</source>
          <target state="translated">このように、Juliaでデフォルトで提供されている暗黙の型パラメータのコンストラクタはかなり厳密ですが、よりリラックスした、しかし賢明な方法で簡単に動作させることができます。さらに、コンストラクタは型システム、メソッド、マルチプルディスパッチのすべての力を活用できるので、洗練された振る舞いを定義するのは一般的に非常に簡単です。</target>
        </trans-unit>
        <trans-unit id="a7677e84b6660292620566337bcfc94144911cc7" translate="yes" xml:space="preserve">
          <source>Ticket</source>
          <target state="translated">Ticket</target>
        </trans-unit>
        <trans-unit id="dd697aa8cce5c810f10070878f9d6f89c5a5937c" translate="yes" xml:space="preserve">
          <source>Tiger</source>
          <target state="translated">Tiger</target>
        </trans-unit>
        <trans-unit id="abee288b1344129c8247490b49084155f62a8492" translate="yes" xml:space="preserve">
          <source>Tiger Face</source>
          <target state="translated">虎面</target>
        </trans-unit>
        <trans-unit id="a213b01ff977ddc2b77a2851775a17888cf936a4" translate="yes" xml:space="preserve">
          <source>Tilde Operator</source>
          <target state="translated">ティルデオペレーター</target>
        </trans-unit>
        <trans-unit id="81f0f8e7286707e1e34046d94807c0c638e949b0" translate="yes" xml:space="preserve">
          <source>Tilde Operator Above Leftwards Arrow</source>
          <target state="translated">左矢印の上のティルデ演算子</target>
        </trans-unit>
        <trans-unit id="248cc81b5c32172ec329e2bbdd1480c988bb3388" translate="yes" xml:space="preserve">
          <source>Tilde Operator With Dot Above</source>
          <target state="translated">上のドットを持つティルデ オペレータ</target>
        </trans-unit>
        <trans-unit id="6835d0448d1238ede880e3906c4de76444a3efae" translate="yes" xml:space="preserve">
          <source>Tilde Operator With Rising Dots</source>
          <target state="translated">ライジングドットのティルデオペレータ</target>
        </trans-unit>
        <trans-unit id="358886c6ac36a9af9f2410bb87185645588db7c9" translate="yes" xml:space="preserve">
          <source>Time in a signature. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_time&quot;&gt;&lt;code&gt;git_time&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">署名の時間。&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_time&quot;&gt; &lt;code&gt;git_time&lt;/code&gt; &lt;/a&gt;構造体に一致します。</target>
        </trans-unit>
        <trans-unit id="a1aef662800be3b19d04a84bdbd802cb869572bc" translate="yes" xml:space="preserve">
          <source>TimeType-Period Arithmetic</source>
          <target state="translated">時間型周期演算</target>
        </trans-unit>
        <trans-unit id="9d9cec22f36fd2bb99d5fe8c4723347bec202ca5" translate="yes" xml:space="preserve">
          <source>Timer</source>
          <target state="translated">Timer</target>
        </trans-unit>
        <trans-unit id="e524304a680bc45ab65762e1df41198ad5434553" translate="yes" xml:space="preserve">
          <source>Timer()</source>
          <target state="translated">Timer()</target>
        </trans-unit>
        <trans-unit id="4e252bb0e117c9cedaeca8da5f4796af646d44a9" translate="yes" xml:space="preserve">
          <source>Timing results:</source>
          <target state="translated">タイミングの結果。</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="0d5993668385f8eefae208c8f706f8bc977fc760" translate="yes" xml:space="preserve">
          <source>Tired Face</source>
          <target state="translated">疲れた顔</target>
        </trans-unit>
        <trans-unit id="d8411edb15bb7d4ab010f7414d30f893e168d44a" translate="yes" xml:space="preserve">
          <source>To access the raw code units (bytes for UTF-8) of the encoding, you can use the &lt;a href=&quot;../../base/strings/index#Base.codeunit&quot;&gt;&lt;code&gt;codeunit(s,i)&lt;/code&gt;&lt;/a&gt; function, where the index &lt;code&gt;i&lt;/code&gt; runs consecutively from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;ncodeunits(s)&lt;/code&gt;. The &lt;a href=&quot;../../base/strings/index#Base.codeunits&quot;&gt;&lt;code&gt;codeunits(s)&lt;/code&gt;&lt;/a&gt; function returns an &lt;code&gt;AbstractVector{UInt8}&lt;/code&gt; wrapper that lets you access these raw codeunits (bytes) as an array.</source>
          <target state="translated">エンコーディングの生のコード単位（UTF-8のバイト）にアクセスするには、&lt;a href=&quot;../../base/strings/index#Base.codeunit&quot;&gt; &lt;code&gt;codeunit(s,i)&lt;/code&gt; &lt;/a&gt;関数を使用できます。ここで、インデックス &lt;code&gt;i&lt;/code&gt; は &lt;code&gt;1&lt;/code&gt; から &lt;code&gt;ncodeunits(s)&lt;/code&gt; まで連続して実行されます。&lt;a href=&quot;../../base/strings/index#Base.codeunits&quot;&gt; &lt;code&gt;codeunits(s)&lt;/code&gt; &lt;/a&gt;関数が返す &lt;code&gt;AbstractVector{UInt8}&lt;/code&gt; あなたが配列として、これらの生codeunits（バイト）にアクセスできラッパー。</target>
        </trans-unit>
        <trans-unit id="e95b1141b5118da7c6df142a7dc74b9f038403fe" translate="yes" xml:space="preserve">
          <source>To add a package, use &lt;code&gt;add&lt;/code&gt;:</source>
          <target state="translated">パッケージを追加するには、 &lt;code&gt;add&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="80d353ae44a58cccba974a5708143d72c88b86a0" translate="yes" xml:space="preserve">
          <source>To allow computations with arbitrary-precision integers and floating point numbers, Julia wraps the &lt;a href=&quot;https://gmplib.org&quot;&gt;GNU Multiple Precision Arithmetic Library (GMP)&lt;/a&gt; and the &lt;a href=&quot;https://www.mpfr.org&quot;&gt;GNU MPFR Library&lt;/a&gt;, respectively. The &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; types are available in Julia for arbitrary precision integer and floating point numbers respectively.</source>
          <target state="translated">Juliaは、任意精度の整数と浮動小数点数を使用した計算を可能にするために、それぞれ&lt;a href=&quot;https://gmplib.org&quot;&gt;GNU多重精度演算ライブラリ（GMP）&lt;/a&gt;と&lt;a href=&quot;https://www.mpfr.org&quot;&gt;GNU MPFRライブラリを&lt;/a&gt;ラップしています。&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;タイプは、任意精度の整数それぞれ浮動小数点数のためにジュリアで利用可能です。</target>
        </trans-unit>
        <trans-unit id="f92958b0eb5e7d500f4fc83e966e176ae982e7c8" translate="yes" xml:space="preserve">
          <source>To allow for the creation of incompletely initialized objects, Julia allows the &lt;a href=&quot;../../base/base/index#new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; function to be called with fewer than the number of fields that the type has, returning an object with the unspecified fields uninitialized. The inner constructor method can then use the incomplete object, finishing its initialization before returning it. Here, for example, is another attempt at defining the &lt;code&gt;SelfReferential&lt;/code&gt; type, this time using a zero-argument inner constructor returning instances having &lt;code&gt;obj&lt;/code&gt; fields pointing to themselves:</source>
          <target state="translated">不完全に初期化されたオブジェクトの作成を可能にするために、Juliaは、タイプが持つフィールドの数より少ない数で&lt;a href=&quot;../../base/base/index#new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;関数を呼び出すことができ、未指定のフィールドが初期化されていないオブジェクトを返します。次に、内部コンストラクターメソッドは不完全なオブジェクトを使用して、それを返す前に初期化を終了します。たとえば、ここでは、 &lt;code&gt;SelfReferential&lt;/code&gt; 型を定義する別の試みがあります。今回は、引数のない内部コンストラクタを使用して、 &lt;code&gt;obj&lt;/code&gt; フィールドが自分自身を指すインスタンスを返します。</target>
        </trans-unit>
        <trans-unit id="647cb570f3aba993aaa46d9c3e91117ed01a95c0" translate="yes" xml:space="preserve">
          <source>To amplify a bit further, consider the following function:</source>
          <target state="translated">もう少し増幅するには、次のような関数を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="7e940b0d75467f1279dc9099ee9a7a7226dd9aa5" translate="yes" xml:space="preserve">
          <source>To avoid even having to define a named function, you can use the &lt;code&gt;do&lt;/code&gt; syntax, which creates an anonymous function on the fly:</source>
          <target state="translated">名前付き関数を定義する必要がないようにするために、その場で無名関数を作成する &lt;code&gt;do&lt;/code&gt; 構文を使用できます。</target>
        </trans-unit>
        <trans-unit id="50dc537d704eaca673949b4e42b6c53501bae68d" translate="yes" xml:space="preserve">
          <source>To check if a regex matches a string, use &lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt;&lt;code&gt;occursin&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">正規表現が文字列と一致するかどうかを確認するには、&lt;a href=&quot;../../base/strings/index#Base.occursin&quot;&gt; &lt;code&gt;occursin&lt;/code&gt; &lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="eed84206f52f8f65140a28df43e2ff030f4f3a51" translate="yes" xml:space="preserve">
          <source>To concatenate in the first (&quot;vertical&quot;) dimension use either &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt;&lt;code&gt;vcat(x,y,z)&lt;/code&gt;&lt;/a&gt; or separate with semicolons (&lt;code&gt;[x; y; z]&lt;/code&gt;).</source>
          <target state="translated">最初の（「垂直」）次元で連結するには、&lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt; &lt;code&gt;vcat(x,y,z)&lt;/code&gt; &lt;/a&gt;またはセミコロン（ &lt;code&gt;[x; y; z]&lt;/code&gt; ）で区切ります。</target>
        </trans-unit>
        <trans-unit id="836f5fac5628ace8eede45159f560aedbc2e431e" translate="yes" xml:space="preserve">
          <source>To concatenate in the second (&quot;horizontal&quot;) dimension use either &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt;&lt;code&gt;hcat(x,y,z)&lt;/code&gt;&lt;/a&gt; or separate with spaces (&lt;code&gt;[x y z]&lt;/code&gt;).</source>
          <target state="translated">2番目（「水平」）の次元で連結するには、&lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt; &lt;code&gt;hcat(x,y,z)&lt;/code&gt; &lt;/a&gt;またはスペースで区切る（ &lt;code&gt;[x y z]&lt;/code&gt; ）のいずれかを使用します。</target>
        </trans-unit>
        <trans-unit id="c1db2888c6f2a52fec0ea3a56df9e7e662b6768f" translate="yes" xml:space="preserve">
          <source>To construct block matrices (concatenating in the first two dimensions), use either &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt;&lt;code&gt;hvcat&lt;/code&gt;&lt;/a&gt; or combine spaces and semicolons (&lt;code&gt;[a b; c d]&lt;/code&gt;).</source>
          <target state="translated">ブロックマトリックス（最初の2次元で連結）を作成するには、&lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt; &lt;code&gt;hvcat&lt;/code&gt; を&lt;/a&gt;使用するか、スペースとセミコロンを組み合わせます（ &lt;code&gt;[a b; c d]&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a141c1fb8d334654feff124c660c2fb4df2cb73d" translate="yes" xml:space="preserve">
          <source>To define a function with multiple methods, one simply defines the function multiple times, with different numbers and types of arguments. The first method definition for a function creates the function object, and subsequent method definitions add new methods to the existing function object. The most specific method definition matching the number and types of the arguments will be executed when the function is applied. Thus, the two method definitions above, taken together, define the behavior for &lt;code&gt;f&lt;/code&gt; over all pairs of instances of the abstract type &lt;code&gt;Number&lt;/code&gt; &amp;ndash; but with a different behavior specific to pairs of &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values. If one of the arguments is a 64-bit float but the other one is not, then the &lt;code&gt;f(Float64,Float64)&lt;/code&gt; method cannot be called and the more general &lt;code&gt;f(Number,Number)&lt;/code&gt; method must be used:</source>
          <target state="translated">複数のメソッドを使用して関数を定義するには、引数の数とタイプを変えて、関数を複数回定義するだけです。関数の最初のメソッド定義は関数オブジェクトを作成し、後続のメソッド定義は既存の関数オブジェクトに新しいメソッドを追加します。引数の数とタイプに一致する最も具体的なメソッド定義は、関数が適用されるときに実行されます。したがって、上記の2つのメソッド定義は、まとめて、抽象型 &lt;code&gt;Number&lt;/code&gt; のインスタンスのすべてのペアに対する &lt;code&gt;f&lt;/code&gt; の動作を定義しますが、&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;値のペアに固有の異なる動作を持ちます。引数の1つが64ビットの浮動小数点数で、もう1つの引数がそうでない場合、 &lt;code&gt;f(Float64,Float64)&lt;/code&gt; メソッドを呼び出すことはできず、より一般的な &lt;code&gt;f(Number,Number)&lt;/code&gt; メソッドを使用する必要があります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
