<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="de317509d863583987ae78748b3c0fbd35bb5918" translate="yes" xml:space="preserve">
          <source>It is common to want to create a task and schedule it right away, so the macro &lt;a href=&quot;../../base/parallel/index#Base.@async&quot;&gt;&lt;code&gt;@async&lt;/code&gt;&lt;/a&gt; is provided for that purpose &amp;ndash;- &lt;code&gt;@async x&lt;/code&gt; is equivalent to &lt;code&gt;schedule(@task x)&lt;/code&gt;.</source>
          <target state="translated">タスクを作成してすぐにスケジュールするのが一般的であるため、その目的のためにマクロ&lt;a href=&quot;../../base/parallel/index#Base.@async&quot;&gt; &lt;code&gt;@async&lt;/code&gt; &lt;/a&gt;が提供されています- &lt;code&gt;@async x&lt;/code&gt; は &lt;code&gt;schedule(@task x)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="62c8e496514b2a89c93f19599f4b3b4a2fbaa739" translate="yes" xml:space="preserve">
          <source>It is convenient to have captures returned as an array so that one can use destructuring syntax to bind them to local variables:</source>
          <target state="translated">キャプチャを配列として返すと便利なので、デストラクチャリング構文を使ってローカル変数にバインドすることができます。</target>
        </trans-unit>
        <trans-unit id="d47b317b6ddbcdcb526b152229f01524e725a05a" translate="yes" xml:space="preserve">
          <source>It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies can cause code that works correctly on one system to fail or produce indeterminate results on a different system.</source>
          <target state="translated">宣言されたCの型とJuliaでの宣言を正確に一致させることが重要です。不整合があると、あるシステムでは正しく動作していたコードが失敗したり、別のシステムでは不確定な結果になったりすることがあります。</target>
        </trans-unit>
        <trans-unit id="fed6b1dba676362bbdda7d92763627e5b989669b" translate="yes" xml:space="preserve">
          <source>It is declared inside the block of a type declaration, rather than outside of it like normal methods.</source>
          <target state="translated">通常のメソッドのように型宣言の外側ではなく、型宣言のブロック内で宣言されます。</target>
        </trans-unit>
        <trans-unit id="be90e9f486db27a87a15823d4ded324a5b8722df" translate="yes" xml:space="preserve">
          <source>It is good practice to provide as few inner constructor methods as possible: only those taking all arguments explicitly and enforcing essential error checking and transformation. Additional convenience constructor methods, supplying default values or auxiliary transformations, should be provided as outer constructors that call the inner constructors to do the heavy lifting. This separation is typically quite natural.</source>
          <target state="translated">すべての引数を明示的に取り、必須のエラーチェックと変換を強制するものだけを提供します。デフォルト値や補助的な変換を提供する便利なコンストラクタメソッドは、外側のコンストラクタとして提供し、内側のコンストラクタを呼び出して重い作業を行うようにします。この分離は一般的に非常に自然なことです。</target>
        </trans-unit>
        <trans-unit id="055af1e6d77e563e261b9cddc84477b0892ca389" translate="yes" xml:space="preserve">
          <source>It is good practice to use such special versions in comparisons (particularly, the trailing &lt;code&gt;-&lt;/code&gt; should always be used on upper bounds unless there's a good reason not to), but they must not be used as the actual version number of anything, as they are invalid in the semantic versioning scheme.</source>
          <target state="translated">比較ではこのような特別なバージョンを使用することをお勧めします（特に、後続の &lt;code&gt;-&lt;/code&gt; 正当な理由がない限り、常に上限で使用する必要があります）が、実際のバージョン番号として使用しないでください。セマンティックバージョニングスキームでは無効です。</target>
        </trans-unit>
        <trans-unit id="94f57801215f48bd353cec6fcbf15e2489fd5bd7" translate="yes" xml:space="preserve">
          <source>It is important to emphasize that macros receive their arguments as expressions, literals, or symbols. One way to explore macro arguments is to call the &lt;code&gt;show&lt;/code&gt; function within the macro body:</source>
          <target state="translated">マクロは引数を式、リテラル、またはシンボルとして受け取ることを強調することが重要です。マクロ引数を調べる1つの方法は、マクロ本体内で &lt;code&gt;show&lt;/code&gt; 関数を呼び出すことです。</target>
        </trans-unit>
        <trans-unit id="02a6b6b86295c683044f57772927ffaa28e3765b" translate="yes" xml:space="preserve">
          <source>It is important to note that &lt;em&gt;when&lt;/em&gt; an object is locally garbage collected depends on the size of the object and the current memory pressure in the system.</source>
          <target state="translated">オブジェクトがローカルでガベージコレクションされる&lt;em&gt;ときは&lt;/em&gt;、オブジェクトのサイズとシステムの現在のメモリプレッシャーに依存すること&lt;em&gt;に&lt;/em&gt;注意することが重要です。</target>
        </trans-unit>
        <trans-unit id="600388b971e8fe9fe40cf23408b11ce42cda8c10" translate="yes" xml:space="preserve">
          <source>It is in general impossible to predict which values will be old at runtime, so the write barrier must be inserted after all explicit stores. One notable exception is if the &lt;code&gt;parent&lt;/code&gt; object was just allocated and garbage collection was not run since then. Remember that most &lt;code&gt;jl_...&lt;/code&gt; functions can sometimes invoke garbage collection.</source>
          <target state="translated">実行時にどの値が古いかを予測することは一般に不可能であるため、すべての明示的なストアの後に書き込みバリアを挿入する必要があります。注目すべき例外の1つは、 &lt;code&gt;parent&lt;/code&gt; オブジェクトが割り当てられたばかりで、その後ガベージコレクションが実行されなかった場合です。ほとんどの &lt;code&gt;jl_...&lt;/code&gt; 関数はガベージコレクションを呼び出すことができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1e58853c75f92756885fe162715552efead15275" translate="yes" xml:space="preserve">
          <source>It is not permitted to modify the value of an immutable type.</source>
          <target state="translated">不変型の値を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="737fc29ba3e3878487296ae0904e3501ba8b3de3" translate="yes" xml:space="preserve">
          <source>It is not possible to violate the invariants provided by the type's constructors.</source>
          <target state="translated">型のコンストラクタが提供する不変量に違反することはできません。</target>
        </trans-unit>
        <trans-unit id="9c82744b33d4a8c920b021b98d324b0dd36c7c0d" translate="yes" xml:space="preserve">
          <source>It is often convenient to be able to write functions taking an arbitrary number of arguments. Such functions are traditionally known as &quot;varargs&quot; functions, which is short for &quot;variable number of arguments&quot;. You can define a varargs function by following the last argument with an ellipsis:</source>
          <target state="translated">任意の数の引数を取る関数を書けると便利なことがよくあります。このような関数は伝統的に &quot;varargs&quot; 関数として知られています。varargs 関数は、最後の引数の後に省略記号をつけることで定義できます。</target>
        </trans-unit>
        <trans-unit id="03d37775863d3d8aefef1deee1f9fba7a5cc77f8" translate="yes" xml:space="preserve">
          <source>It is often convenient to be able to write functions taking an arbitrary number of arguments. Such functions are traditionally known as &quot;varargs&quot; functions, which is short for &quot;variable number of arguments&quot;. You can define a varargs function by following the last positional argument with an ellipsis:</source>
          <target state="translated">任意の数の引数を取る関数を書けると便利なことがよくあります。このような関数は伝統的に &quot;varargs&quot; 関数として知られています。varargs 関数を定義するには、最後の位置の引数を省略記号で追いかけることで定義します。</target>
        </trans-unit>
        <trans-unit id="67322f4620eb4bffc38ad6db6fb50c1b9b16e04a" translate="yes" xml:space="preserve">
          <source>It is often convenient to work with data structures that may contain values of any type (arrays of type &lt;code&gt;Array{Any}&lt;/code&gt;). But, if you're using one of these structures and happen to know the type of an element, it helps to share this knowledge with the compiler:</source>
          <target state="translated">多くの場合、任意の型の値（ &lt;code&gt;Array{Any}&lt;/code&gt; 型の配列）の値を含む可能性のあるデータ構造を操作すると便利です。ただし、これらの構造の1つを使用していて、要素のタイプを知っている場合は、この知識をコンパイラーと共有すると役立ちます。</target>
        </trans-unit>
        <trans-unit id="096c719abfea35b0b455d36ba64fc9420aa68bfd" translate="yes" xml:space="preserve">
          <source>It is often possible to provide sensible default values for function arguments. This can save users from having to pass every argument on every call. For example, the function &lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt;&lt;code&gt;Date(y, [m, d])&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;Dates&lt;/code&gt; module constructs a &lt;code&gt;Date&lt;/code&gt; type for a given year &lt;code&gt;y&lt;/code&gt;, month &lt;code&gt;m&lt;/code&gt; and day &lt;code&gt;d&lt;/code&gt;. However, &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; arguments are optional and their default value is &lt;code&gt;1&lt;/code&gt;. This behavior can be expressed concisely as:</source>
          <target state="translated">多くの場合、関数の引数に適切なデフォルト値を提供することが可能です。これにより、ユーザーはすべての呼び出しですべての引数を渡す必要がなくなります。たとえば、 &lt;code&gt;Dates&lt;/code&gt; モジュールの関数&lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt; &lt;code&gt;Date(y, [m, d])&lt;/code&gt; &lt;/a&gt;は、指定された年 &lt;code&gt;y&lt;/code&gt; 、月 &lt;code&gt;m&lt;/code&gt; 、および日 &lt;code&gt;d&lt;/code&gt; の &lt;code&gt;Date&lt;/code&gt; 型を作成します。ただし、 &lt;code&gt;m&lt;/code&gt; 引数と &lt;code&gt;d&lt;/code&gt; 引数はオプションであり、デフォルト値は &lt;code&gt;1&lt;/code&gt; です。この動作は、次のように簡潔に表すことができます。</target>
        </trans-unit>
        <trans-unit id="4293de250d5dd5832be57fecdaa6e0a3c7af489c" translate="yes" xml:space="preserve">
          <source>It is possible to constrain the number of values passed as a variable argument; this will be discussed later in &lt;a href=&quot;../methods/index#Parametrically-constrained-Varargs-methods&quot;&gt;Parametrically-constrained Varargs methods&lt;/a&gt;.</source>
          <target state="translated">可変引数として渡される値の数を制限することができます。これについては、後で&lt;a href=&quot;../methods/index#Parametrically-constrained-Varargs-methods&quot;&gt;パラメトリックに制約された可変個引数メソッドで説明します&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="284677cc407d046b65013c8fed718805f3d17cb7" translate="yes" xml:space="preserve">
          <source>It is possible to constrain the number of values passed as a variable argument; this will be discussed later in &lt;a href=&quot;../methods/index#Parametrically-constrained-Varargs-methods-1&quot;&gt;Parametrically-constrained Varargs methods&lt;/a&gt;.</source>
          <target state="translated">可変引数として渡される値の数を制限することが可能です。これについては、&lt;a href=&quot;../methods/index#Parametrically-constrained-Varargs-methods-1&quot;&gt;パラメトリックに制約されたVarargsメソッドで&lt;/a&gt;後で説明します。</target>
        </trans-unit>
        <trans-unit id="a70320747de27e26b4b70f213eeadabc7679b96a" translate="yes" xml:space="preserve">
          <source>It is possible to define a set of function methods such that there is no unique most specific method applicable to some combinations of arguments:</source>
          <target state="translated">いくつかの引数の組み合わせに適用されるユニークで最も特異なメソッドが存在しないような関数メソッドのセットを定義することが可能です。</target>
        </trans-unit>
        <trans-unit id="637c214ddc147146d30043be14f7af002a6afb37" translate="yes" xml:space="preserve">
          <source>It is possible to make use of metaprogramming to assist in the creation of documentation. When using string-interpolation within the docstring you will need to use an extra &lt;code&gt;$&lt;/code&gt; as shown with &lt;code&gt;$($name)&lt;/code&gt;:</source>
          <target state="translated">ドキュメントの作成を支援するためにメタプログラミングを利用することが可能です。docstring内で文字列補間を使用する場合、 &lt;code&gt;$($name)&lt;/code&gt; 示されているように追加の &lt;code&gt;$&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="deea519c4200e4fe336ac8810c406887e0570f07" translate="yes" xml:space="preserve">
          <source>It is possible to pass Julia functions to native C functions that accept function pointer arguments. For example, to match C prototypes of the form:</source>
          <target state="translated">Julia の関数を、関数ポインタの引数を受け取るネイティブの C 関数に渡すことができます。例えば、形式のCのプロトタイプにマッチするように。</target>
        </trans-unit>
        <trans-unit id="b862a89ec67717dcb808d8174cdd3cd9cf5de933" translate="yes" xml:space="preserve">
          <source>It is possible to write definitions like the following:</source>
          <target state="translated">のように定義を書くことができます。</target>
        </trans-unit>
        <trans-unit id="079123703d5fe6500844bec9cf4fbeb95441a39c" translate="yes" xml:space="preserve">
          <source>It is recommended that subtypes &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; override the following method signature to provide more efficient implementations: &lt;code&gt;unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</source>
          <target state="translated">サブタイプ &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; は、次のメソッドシグネチャをオーバーライドして、より効率的な実装を提供することをお勧めします： &lt;code&gt;unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4972fa162a33587e78213cfd46e68a922aa11ce5" translate="yes" xml:space="preserve">
          <source>It is recommended that subtypes &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; override the following method signature to provide more efficient implementations: &lt;code&gt;unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</source>
          <target state="translated">サブタイプ &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; は、次のメソッドシグネチャをオーバーライドして、より効率的な実装を提供することをお勧めします： &lt;code&gt;unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8e657552abcb773fba2d1c58477efeff3641733f" translate="yes" xml:space="preserve">
          <source>It is recommended that the disambiguating method be defined first, since otherwise the ambiguity exists, if transiently, until the more specific method is defined.</source>
          <target state="translated">なぜなら、より具体的な方法が定義されるまでは、曖昧さは一過性のものであっても、曖昧さは存在するからです。</target>
        </trans-unit>
        <trans-unit id="3205262d1b20d05a3ec0c7f09158500e89b8710e" translate="yes" xml:space="preserve">
          <source>It is safe to execute iterations in arbitrary or overlapping order, with special consideration for reduction variables.</source>
          <target state="translated">還元変数を特別に考慮して、任意の順序や重複した順序で反復実行しても安全です。</target>
        </trans-unit>
        <trans-unit id="d10887452da1b7a8299e792daec58426383fc305" translate="yes" xml:space="preserve">
          <source>It is significant that like &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elseif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt;, the expressions before and after the &lt;code&gt;:&lt;/code&gt; are only evaluated if the condition expression evaluates to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, respectively:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; - &lt;code&gt;elseif&lt;/code&gt; - &lt;code&gt;else&lt;/code&gt; のように、条件式が &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; にそれぞれ評価される場合にのみ、 &lt;code&gt;:&lt;/code&gt; の前後の式が評価されることが重要です。</target>
        </trans-unit>
        <trans-unit id="6b7dd92481471c3be503cbed8b0ada7bae73d043" translate="yes" xml:space="preserve">
          <source>It is significantly more expensive to compute Cartesian indices from a linear index than it is to go the other way. The former operation requires division &amp;mdash; a very costly operation &amp;mdash; whereas the latter only uses multiplication and addition and is essentially free. This asymmetry means it is far more costly to use linear indexing with an &lt;code&gt;IndexCartesian&lt;/code&gt; array than it is to use Cartesian indexing with an &lt;code&gt;IndexLinear&lt;/code&gt; array.</source>
          <target state="translated">線形インデックスからデカルトインデックスを計算する方が、他の方法よりも大幅にコストがかかります。前者の演算は除算（非常にコストのかかる演算）を必要としますが、後者は乗算と加算のみを使用し、本質的に無料です。との線形インデックスを使用することがはるかにコストがかかるこれは非対称手段 &lt;code&gt;IndexCartesian&lt;/code&gt; それがでデカルトインデックスを使用するよりも、配列 &lt;code&gt;IndexLinear&lt;/code&gt; の配列。</target>
        </trans-unit>
        <trans-unit id="6abc534e54f65480aad0f619aee6267faddc4174" translate="yes" xml:space="preserve">
          <source>It is sometimes convenient to terminate the repetition of a &lt;code&gt;while&lt;/code&gt; before the test condition is falsified or stop iterating in a &lt;code&gt;for&lt;/code&gt; loop before the end of the iterable object is reached. This can be accomplished with the &lt;code&gt;break&lt;/code&gt; keyword:</source>
          <target state="translated">反復可能なオブジェクトの最後に到達する前に、テスト条件が偽造される前に &lt;code&gt;while&lt;/code&gt; 繰り返しを終了するか、 &lt;code&gt;for&lt;/code&gt; ループで反復を停止すると便利な場合があります。これは、 &lt;code&gt;break&lt;/code&gt; キーワードを使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="20dfcec28a6dd8951f574998a3986a215e74fce8" translate="yes" xml:space="preserve">
          <source>It is sometimes helpful during module development to turn off incremental precompilation. The command line flag &lt;code&gt;--compiled-modules={yes|no}&lt;/code&gt; enables you to toggle module precompilation on and off. When Julia is started with &lt;code&gt;--compiled-modules=no&lt;/code&gt; the serialized modules in the compile cache are ignored when loading modules and module dependencies. &lt;code&gt;Base.compilecache&lt;/code&gt; can still be called manually. The state of this command line flag is passed to &lt;code&gt;Pkg.build&lt;/code&gt; to disable automatic precompilation triggering when installing, updating, and explicitly building packages.</source>
          <target state="translated">モジュール開発中に増分プリコンパイルをオフにすると役立つ場合があります。コマンドラインフラグ &lt;code&gt;--compiled-modules={yes|no}&lt;/code&gt; 使用すると、モジュールのプリコンパイルのオンとオフを切り替えることができます。 Juliaを &lt;code&gt;--compiled-modules=no&lt;/code&gt; で起動すると、モジュールとモジュールの依存関係をロードするときに、コンパイルキャッシュ内のシリアル化されたモジュールが無視されます。 &lt;code&gt;Base.compilecache&lt;/code&gt; は引き続き手動で呼び出すことができます。このコマンドラインフラグの状態は &lt;code&gt;Pkg.build&lt;/code&gt; に渡され、パッケージのインストール、更新、および明示的なビルド時の自動プリコンパイルトリガーを無効にします。</target>
        </trans-unit>
        <trans-unit id="94baf48d740dae1d64cb4dabcdca4ac61d569c1b" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to close (unload) a library so that it can be reloaded. For instance, when developing C code for use with Julia, one may need to compile, call the C code from Julia, then close the library, make an edit, recompile, and load in the new changes. One can either restart Julia or use the &lt;code&gt;Libdl&lt;/code&gt; functions to manage the library explicitly, such as:</source>
          <target state="translated">ライブラリーを再ロードできるように、ライブラリーをクローズ（アンロード）すると便利な場合があります。たとえば、Juliaで使用するCコードを開発する場合、JuliaからコンパイルしてCコードを呼び出し、ライブラリを閉じ、編集を行い、再コンパイルして、新しい変更を読み込む必要があります。Juliaを再起動するか、 &lt;code&gt;Libdl&lt;/code&gt; 関数を使用してライブラリを明示的に管理できます。</target>
        </trans-unit>
        <trans-unit id="32e81dce90195c032e275e55f3bfa20c146074b3" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to perform element-by-element binary operations on arrays of different sizes, such as adding a vector to each column of a matrix. An inefficient way to do this would be to replicate the vector to the size of the matrix:</source>
          <target state="translated">異なるサイズの配列に対して,行列の各列にベクトルを追加するような,要素毎のバイナリ処理を行うことが有用な場合があります.非効率的な方法としては,行列のサイズに合わせてベクトルを複製することが挙げられます.</target>
        </trans-unit>
        <trans-unit id="58d81677369240f5f99e6de14b72f59ff777800d" translate="yes" xml:space="preserve">
          <source>It is to be noted that this is generally not an issue. It is something to be factored in only if the object is both being stored locally and modifed post the call. In such cases it may be appropriate to store a &lt;code&gt;deepcopy&lt;/code&gt; of the object.</source>
          <target state="translated">これは一般に問題ではないことに注意してください。これは、オブジェクトがローカルに保存されており、呼び出し後に変更されている場合にのみ考慮されます。そのような場合、オブジェクトの &lt;code&gt;deepcopy&lt;/code&gt; を保存するのが適切な場合があります。</target>
        </trans-unit>
        <trans-unit id="4930241b205d76b9c3d495f83abf296392db54b7" translate="yes" xml:space="preserve">
          <source>It is usually best to avoid capturing references to instances of internal metadata objects such as &lt;code&gt;Method&lt;/code&gt;, &lt;code&gt;MethodInstance&lt;/code&gt;, &lt;code&gt;MethodTable&lt;/code&gt;, &lt;code&gt;TypeMapLevel&lt;/code&gt;, &lt;code&gt;TypeMapEntry&lt;/code&gt; and fields of those objects, as this can confuse the serializer and may not lead to the outcome you desire. It is not necessarily an error to do this, but you simply need to be prepared that the system will try to copy some of these and to create a single unique instance of others.</source>
          <target state="translated">それは、次のような内部メタデータのインスタンスオブジェクトへの参照を取得する避けることが最善である &lt;code&gt;Method&lt;/code&gt; 、 &lt;code&gt;MethodInstance&lt;/code&gt; 、 &lt;code&gt;MethodTable&lt;/code&gt; 、 &lt;code&gt;TypeMapLevel&lt;/code&gt; 、 &lt;code&gt;TypeMapEntry&lt;/code&gt; これはシリアライザを混同することができますし、あなたが望む結果につながらない可能性があるため、それらのオブジェクトのフィールド。これを行うのは必ずしもエラーではありませんが、システムがこれらのいくつかをコピーして、他のインスタンスを1つだけ作成しようとする準備ができているだけです。</target>
        </trans-unit>
        <trans-unit id="b19a6924f8364edbfe868e5511ad36bcb64fff31" translate="yes" xml:space="preserve">
          <source>It is usually not much help to construct arrays like the following:</source>
          <target state="translated">以下のような配列を構築するのは、通常はあまり役に立たない。</target>
        </trans-unit>
        <trans-unit id="e4380a1b0acd2209a89981ccd04cfa0fd834aaba" translate="yes" xml:space="preserve">
          <source>It is very important that the called function does not call back into Julia, as it will segfault.</source>
          <target state="translated">呼び出された関数が Julia にコールバックしないようにすることは非常に重要です。</target>
        </trans-unit>
        <trans-unit id="334c0921872b88ab33e359bc32c0c7cf09fbdeba" translate="yes" xml:space="preserve">
          <source>It is worth emphasizing that strides are about offsets in memory rather than indexing. If you are looking to convert between linear (single-index) indexing and cartesian (multi-index) indexing, see &lt;a href=&quot;../../base/arrays/index#Base.LinearIndices&quot;&gt;&lt;code&gt;LinearIndices&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ストライドは、インデックス作成ではなく、メモリ内のオフセットに関するものであることを強調する価値があります。線形（単一インデックス）インデックスとデカルト（マルチインデックス）インデックスの間の変換を検討している場合は、&lt;a href=&quot;../../base/arrays/index#Base.LinearIndices&quot;&gt; &lt;code&gt;LinearIndices&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="805fdc406fb3dba1fb93a133c29b22878b4c87dc" translate="yes" xml:space="preserve">
          <source>It may take optional keyword arguments:</source>
          <target state="translated">オプションのキーワード引数を取ることができます。</target>
        </trans-unit>
        <trans-unit id="9d3c85b9245c7315a1b23d4e146f385ddcbfb243" translate="yes" xml:space="preserve">
          <source>It means that the type of the output is predictable from the types of the inputs. In particular, it means that the type of the output cannot vary depending on the &lt;em&gt;values&lt;/em&gt; of the inputs. The following code is &lt;em&gt;not&lt;/em&gt; type-stable:</source>
          <target state="translated">これは、出力のタイプが入力のタイプから予測可能であることを意味します。特に、入力の&lt;em&gt;値&lt;/em&gt;によって出力のタイプが変化しないことを意味します。次のコードは型安定ではあり&lt;em&gt;ません&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="c3b7dcbf1418595d94f20981812341bdb45796ab" translate="yes" xml:space="preserve">
          <source>It only makes sense to take ratios of integer values, so the parameter type &lt;code&gt;T&lt;/code&gt; is restricted to being a subtype of &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;, and a ratio of integers represents a value on the real number line, so any &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; is an instance of the &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; abstraction.</source>
          <target state="translated">整数値の比率を取ることは意味があるだけなので、パラメータータイプ &lt;code&gt;T&lt;/code&gt; は&lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; の&lt;/a&gt;サブタイプに制限され、整数の比率は実数線上の値を表すため、&lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;はすべて&lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;抽象化のインスタンスです。</target>
        </trans-unit>
        <trans-unit id="a692191dac5658d6e6f21b53ff80758c81d0148d" translate="yes" xml:space="preserve">
          <source>It provides a mutable wrapper around an iterator and its iteration state.</source>
          <target state="translated">これは、イテレータとその反復状態の周りのミューター可能なラッパーを提供します。</target>
        </trans-unit>
        <trans-unit id="1341640325353ec21dd6ae9c9b69ddf97792b73e" translate="yes" xml:space="preserve">
          <source>It returns either an &lt;code&gt;Int&lt;/code&gt; or a &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; depending on the value of its argument. Since Julia can't predict the return type of this function at compile-time, any computation that uses it must be able to cope with values of both types, which makes it hard to produce fast machine code.</source>
          <target state="translated">引数の値に応じて、 &lt;code&gt;Int&lt;/code&gt; または&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; の&lt;/a&gt;いずれかを返します。Juliaはコンパイル時にこの関数の戻り値の型を予測できないため、この関数を使用する計算では両方の型の値に対応できる必要があり、高速なマシンコードを生成するのが困難になります。</target>
        </trans-unit>
        <trans-unit id="75d07a5f3996139947136e92cd3660ed889424cf" translate="yes" xml:space="preserve">
          <source>It returns either an &lt;code&gt;Int&lt;/code&gt; or a &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; depending on the value of its argument. Since Julia can't predict the return type of this function at compile-time, any computation that uses it will have to guard against both types possibly occurring, making generation of fast machine code difficult.</source>
          <target state="translated">引数の値に応じて、 &lt;code&gt;Int&lt;/code&gt; または&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; を&lt;/a&gt;返します。Juliaはコンパイル時にこの関数の戻り値の型を予測できないため、この関数を使用する計算では両方の型が発生しないようにする必要があり、高速マシンコードの生成が困難になります。</target>
        </trans-unit>
        <trans-unit id="e13bba493365e2c5b2e76f0ae39f91eaa1b27bd1" translate="yes" xml:space="preserve">
          <source>It should however be noted that the compiler is quite efficient at optimizing away the dead branches in code written as the &lt;code&gt;mynorm&lt;/code&gt; example.</source>
          <target state="translated">ただし、コンパイラは、 &lt;code&gt;mynorm&lt;/code&gt; の例として記述されたコード内の不要なブランチを最適化するのに非常に効率的であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="429ea7fe9a07243d9d929909311d0c5286ba8da0" translate="yes" xml:space="preserve">
          <source>It turns an iterator-like abstraction into a &lt;code&gt;Channel&lt;/code&gt;-like abstraction.</source>
          <target state="translated">イテレータのような抽象化を &lt;code&gt;Channel&lt;/code&gt; ような抽象化に変えます。</target>
        </trans-unit>
        <trans-unit id="85d168e5e85b9af5b4b41b997ebf680755497e13" translate="yes" xml:space="preserve">
          <source>It's a good idea to first run the code you intend to profile at least once (unless you want to profile Julia's JIT-compiler):</source>
          <target state="translated">(JuliaのJITコンパイラをプロファイリングしたい場合を除いて)プロファイリングするコードを最初に少なくとも一度は実行することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6aa7c46c7a469a8066f30e0a6330c5f7107a8c6d" translate="yes" xml:space="preserve">
          <source>It's also possible to add cross-references to other documented functions/methods/variables within the Julia documentation itself. For example:</source>
          <target state="translated">また、Julia のドキュメント自体の中に、他のドキュメント化された関数/メソッド/変数との相互参照を追加することも可能です。例えば</target>
        </trans-unit>
        <trans-unit id="d58241f9f697434c4e06081f155d61314cbdb71e" translate="yes" xml:space="preserve">
          <source>It's an iterator that mutates to become its own rest iterator whenever an item is produced.</source>
          <target state="translated">これは、アイテムが生成されるたびに変異して自分自身のレストイテレータになるイテレータです。</target>
        </trans-unit>
        <trans-unit id="4aa36d32a2c02cf6990c1d5d08f2ca5067ed910f" translate="yes" xml:space="preserve">
          <source>It's easiest to illustrate this with an example. We can declare a generated function &lt;code&gt;foo&lt;/code&gt; as</source>
          <target state="translated">これを例で説明するのが最も簡単です。生成された関数 &lt;code&gt;foo&lt;/code&gt; を次のように宣言できます。</target>
        </trans-unit>
        <trans-unit id="7ecf0f0b27cffd70c113f40a095f8c8f53901430" translate="yes" xml:space="preserve">
          <source>It's far less clear what should happen here. Since &lt;code&gt;x + &quot;hello&quot;&lt;/code&gt; is a method error, it seems probable that the intention is for &lt;code&gt;x&lt;/code&gt; to be local to the &lt;code&gt;for&lt;/code&gt; loop. But runtime values and what methods happen to exist cannot be used to determine the scopes of variables. With the Julia &amp;le; 0.6 behavior, it's especially concerning that someone might have written the &lt;code&gt;for&lt;/code&gt; loop first, had it working just fine, but later when someone else adds a new global far away&amp;mdash;possibly in a different file&amp;mdash;the code suddenly changes meaning and either breaks noisily or, worse still, silently does the wrong thing. This kind of &lt;a href=&quot;https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)&quot;&gt;&quot;spooky action at a distance&quot;&lt;/a&gt; is something that good programming language designs should prevent.</source>
          <target state="translated">ここで何が起こるべきかははるかに明確ではありません。以来 &lt;code&gt;x + &quot;hello&quot;&lt;/code&gt; メソッドエラーがあり、ために意図がある可能性が高いようで &lt;code&gt;x&lt;/code&gt; に対してローカルである &lt;code&gt;for&lt;/code&gt; ループ。ただし、実行時の値と存在するメソッドを使用して、変数のスコープを決定することはできません。 Julia&amp;le;0.6の動作では、誰かが最初に &lt;code&gt;for&lt;/code&gt; ループを記述し、それが正常に機能していた可能性があることを特に懸念していますが、後で誰かが新しいグローバルを遠くに（おそらく別のファイルに）追加すると、コードの意味が突然変わり、騒々しく壊れるか、さらに悪いことに、静かに間違ったことをします。この種の&lt;a href=&quot;https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)&quot;&gt;「遠隔作用」&lt;/a&gt;は、優れたプログラミング言語の設計では防ぐ必要があります。</target>
        </trans-unit>
        <trans-unit id="38dda39f4395bbec3e9a522986faf60e028082c7" translate="yes" xml:space="preserve">
          <source>It's good practice when using any language/date framework to be familiar with how date-period arithmetic is handled as there are some &lt;a href=&quot;https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/&quot;&gt;tricky issues&lt;/a&gt; to deal with (though much less so for day-precision types).</source>
          <target state="translated">言語/日付フレームワークを使用する場合は、扱いが&lt;a href=&quot;https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/&quot;&gt;難しい問題&lt;/a&gt;があるため、日付と期間の算術演算の処理方法を理解することをお勧めします（ただし、日精度の型の場合はそうではありません）。</target>
        </trans-unit>
        <trans-unit id="0640f8fda4ec7bf5464b3cee97ae0f4dda5ee1e4" translate="yes" xml:space="preserve">
          <source>It's important to be aware of potentially dangerous situations such as concatenation of invalid UTF-8 strings. The resulting string may contain different characters than the input strings, and its number of characters may be lower than sum of numbers of characters of the concatenated strings, e.g.:</source>
          <target state="translated">無効なUTF-8文字列の連結など、潜在的に危険な状況に注意することが重要です。結果として得られる文字列には入力文字列とは異なる文字が含まれている可能性があり、その文字数は連結された文字列の文字数の合計よりも少ない可能性があります。</target>
        </trans-unit>
        <trans-unit id="3dbecc240e8c1b98fcd4c298d9a96ae72e276750" translate="yes" xml:space="preserve">
          <source>It's important to note that there's a very large assymmetry in the performance of these conversions. Converting a linear index to a set of cartesian indices requires dividing and taking the remainder, whereas going the other way is just multiplies and adds. In modern processors, integer division can be 10-50 times slower than multiplication. While some arrays &amp;mdash; like &lt;a href=&quot;../../base/arrays/index#Core.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; itself &amp;mdash; are implemented using a linear chunk of memory and directly use a linear index in their implementations, other arrays &amp;mdash; like &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt; &amp;mdash; need the full set of cartesian indices to do their lookup (see &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt;&lt;code&gt;IndexStyle&lt;/code&gt;&lt;/a&gt; to introspect which is which). As such, when iterating over an entire array, it's much better to iterate over &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex(A)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;1:length(A)&lt;/code&gt;. Not only will the former be much faster in cases where &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;IndexCartesian&lt;/code&gt;, but it will also support OffsetArrays, too.</source>
          <target state="translated">これらの変換のパフォーマンスには非常に大きな非対称性があることに注意することが重要です。線形インデックスをデカルトインデックスのセットに変換するには、残りの部分を除算して取得する必要がありますが、逆の方法は乗算と加算だけです。最近のプロセッサでは、整数の除算は乗算より10〜50倍遅くなることがあります。&lt;a href=&quot;../../base/arrays/index#Core.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt;自体のような一部の配列は、メモリの線形チャンクを使用して実装され、その実装では線形インデックスを直接使用しますが、&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.Diagonal&quot;&gt; &lt;code&gt;Diagonal&lt;/code&gt; の&lt;/a&gt;ような他の配列は、ルックアップを行うためにデカルトインデックスの完全なセットを必要とします（これをイントロ&lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt; &lt;code&gt;IndexStyle&lt;/code&gt; &lt;/a&gt;するにはIndexStyleを参照してください）いずれか）。そのため、配列全体を反復する場合は、代わりに&lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex(A)&lt;/code&gt; &lt;/a&gt;を反復する方がはるかに優れています。 &lt;code&gt;1:length(A)&lt;/code&gt; 。前者は &lt;code&gt;A&lt;/code&gt; が &lt;code&gt;IndexCartesian&lt;/code&gt; である場合にはるかに高速になるだけでなく、OffsetArrayもサポートします。</target>
        </trans-unit>
        <trans-unit id="2ae198b8fe13fc0c80ed5149210f17463c0121d1" translate="yes" xml:space="preserve">
          <source>It's no longer convenient to copy and paste the code from inside a function body into the REPL to debug it&amp;mdash;you have to add &lt;code&gt;global&lt;/code&gt; annotations and then remove them again to go back;</source>
          <target state="translated">関数本体の内部からコードをコピーしてREPLに貼り付けてデバッグするのはもはや便利ではありません。 &lt;code&gt;global&lt;/code&gt; アノテーションを追加してから、再度削除して元に戻す必要があります。</target>
        </trans-unit>
        <trans-unit id="53f0c889cfa216f7a561510a3ad57de629360e4b" translate="yes" xml:space="preserve">
          <source>It's now possible to get a sampler with &lt;code&gt;sp = Sampler(rng, die)&lt;/code&gt;, and use &lt;code&gt;sp&lt;/code&gt; instead of &lt;code&gt;die&lt;/code&gt; in any &lt;code&gt;rand&lt;/code&gt; call involving &lt;code&gt;rng&lt;/code&gt;. In the simplistic example above, &lt;code&gt;die&lt;/code&gt; doesn't need to be stored in &lt;code&gt;SamplerDie&lt;/code&gt; but this is often the case in practice.</source>
          <target state="translated">これは、とのサンプラーを取得できるようになりました &lt;code&gt;sp = Sampler(rng, die)&lt;/code&gt; 、および使用の &lt;code&gt;sp&lt;/code&gt; の代わりに、 &lt;code&gt;die&lt;/code&gt; いずれにおいても、 &lt;code&gt;rand&lt;/code&gt; 関与コール &lt;code&gt;rng&lt;/code&gt; 。上記の単純化した例では、 &lt;code&gt;die&lt;/code&gt; を &lt;code&gt;SamplerDie&lt;/code&gt; に格納する必要はありませんが、実際にはそうであることがよくあります。</target>
        </trans-unit>
        <trans-unit id="435e5d30b709899a41a3dc97d975e671346837d6" translate="yes" xml:space="preserve">
          <source>It's quite instructive to compare the sheer amount code generated for a simple function</source>
          <target state="translated">単純な関数のために生成されたコードの量を比較するのは非常に有益です。</target>
        </trans-unit>
        <trans-unit id="485af6f7d5c0b66af203ac099b1bf7b0eba726ba" translate="yes" xml:space="preserve">
          <source>It's worth emphasizing that &lt;code&gt;localindices&lt;/code&gt; exists purely as a convenience, and you can partition work on the array among workers any way you wish. For a &lt;code&gt;SharedArray&lt;/code&gt;, all indices should be equally fast for each worker process.</source>
          <target state="translated">&lt;code&gt;localindices&lt;/code&gt; は純粋に便利なものとして存在し、アレイ上の作業をワーカー間で任意の方法で分割できることを強調する価値があります。 &lt;code&gt;SharedArray&lt;/code&gt; 、すべてのインデックスは、各ワーカー・プロセスにも同様に高速である必要があります。</target>
        </trans-unit>
        <trans-unit id="948d6de7c32c1a31093f07d2e218322318e4b407" translate="yes" xml:space="preserve">
          <source>It's worth noting that it's extremely easy to mis-use parametric &quot;value&quot; types, including &lt;code&gt;Val&lt;/code&gt;; in unfavorable cases, you can easily end up making the performance of your code much &lt;em&gt;worse&lt;/em&gt;. In particular, you would never want to write actual code as illustrated above. For more information about the proper (and improper) uses of &lt;code&gt;Val&lt;/code&gt;, please read &lt;a href=&quot;../performance-tips/index#man-performance-value-type&quot;&gt;the more extensive discussion in the performance tips&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; を含むパラメトリックな「値」型を誤用するのは非常に簡単であることに注意してください。不利なケースでは、コードのパフォーマンスを大幅に&lt;em&gt;悪化&lt;/em&gt;させる可能性があります。特に、上記のように実際のコードを記述したくはありません。 &lt;code&gt;Val&lt;/code&gt; の適切な（および不適切な）使用法の詳細&lt;a href=&quot;../performance-tips/index#man-performance-value-type&quot;&gt;については、パフォーマンスのヒントのより広範な説明&lt;/a&gt;をお読みください。</target>
        </trans-unit>
        <trans-unit id="7d5d6404960db7e0b184fd1dfa040fb8f1124932" translate="yes" xml:space="preserve">
          <source>It's worth noting that it's extremely easy to mis-use parametric &quot;value&quot; types, including &lt;code&gt;Val&lt;/code&gt;; in unfavorable cases, you can easily end up making the performance of your code much &lt;em&gt;worse&lt;/em&gt;. In particular, you would never want to write actual code as illustrated above. For more information about the proper (and improper) uses of &lt;code&gt;Val&lt;/code&gt;, please read the more extensive discussion in &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;the performance tips&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Val&lt;/code&gt; を含むパラメトリックな「値」型を非常に誤用しやすいことは注目に値します。望ましくない場合には、コードのパフォーマンスを大幅に&lt;em&gt;悪化&lt;/em&gt;させることになります。特に、上記のように実際のコードを記述したくない場合があります。 &lt;code&gt;Val&lt;/code&gt; の適切な（および不適切な）使用方法の詳細については&lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;、パフォーマンスのヒントの&lt;/a&gt;より広範な議論をお読みください。</target>
        </trans-unit>
        <trans-unit id="3b9b0722d0d43e4d14ff92cca723a64b8e24e4f0" translate="yes" xml:space="preserve">
          <source>Italics</source>
          <target state="translated">Italics</target>
        </trans-unit>
        <trans-unit id="c218bb3261ced0b188316d903cb0484a6a43b61a" translate="yes" xml:space="preserve">
          <source>Iterable Collections</source>
          <target state="translated">反復可能なコレクション</target>
        </trans-unit>
        <trans-unit id="81a99e5d5fc07b72d6b1647c497a7c5192f69fad" translate="yes" xml:space="preserve">
          <source>Iterate over a collection &lt;code&gt;n&lt;/code&gt; elements at a time.</source>
          <target state="translated">一度に &lt;code&gt;n&lt;/code&gt; 個の要素のコレクションを反復処理します。</target>
        </trans-unit>
        <trans-unit id="7878c863963cb51356acf7ca3e8ea44be505a483" translate="yes" xml:space="preserve">
          <source>Iterated dispatch</source>
          <target state="translated">反復派遣</target>
        </trans-unit>
        <trans-unit id="42206b6c92650b3931037fd07719156176dc0314" translate="yes" xml:space="preserve">
          <source>Iterating over the &lt;code&gt;CartesianIndices&lt;/code&gt; of the &lt;code&gt;axes(::Broadcasted)&lt;/code&gt; and using indexing with the resulting &lt;code&gt;CartesianIndex&lt;/code&gt; object to compute the result.</source>
          <target state="translated">&lt;code&gt;axes(::Broadcasted)&lt;/code&gt; の &lt;code&gt;CartesianIndices&lt;/code&gt; を反復し、結果の &lt;code&gt;CartesianIndex&lt;/code&gt; オブジェクトでインデックスを使用して結果を計算します。</target>
        </trans-unit>
        <trans-unit id="a4979919b853dff1595ccf476a13a01680f6c472" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;F.S&lt;/code&gt;, &lt;code&gt;F.T&lt;/code&gt;, &lt;code&gt;F.Q&lt;/code&gt;, &lt;code&gt;F.Z&lt;/code&gt;, &lt;code&gt;F.&amp;alpha;&lt;/code&gt;, and &lt;code&gt;F.&amp;beta;&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、成分 &lt;code&gt;F.S&lt;/code&gt; 、 &lt;code&gt;F.T&lt;/code&gt; 、 &lt;code&gt;F.Q&lt;/code&gt; 、 &lt;code&gt;F.Z&lt;/code&gt; 、 &lt;code&gt;F.&amp;alpha;&lt;/code&gt; 、および &lt;code&gt;F.&amp;beta;&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="fc67e8a927f1aa6eff5ad47840e758df966f518f" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;F.T&lt;/code&gt;, &lt;code&gt;F.Z&lt;/code&gt;, and &lt;code&gt;F.values&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、コンポーネント &lt;code&gt;F.T&lt;/code&gt; 、 &lt;code&gt;F.Z&lt;/code&gt; 、および &lt;code&gt;F.values&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="f4d4ad8d2cf2c1ee9c60ddef640294bbac58cbc2" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;F.values&lt;/code&gt; and &lt;code&gt;F.vectors&lt;/code&gt;.</source>
          <target state="translated">分解を &lt;code&gt;F.values&lt;/code&gt; と、コンポーネントF.valuesと &lt;code&gt;F.vectors&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="86506020c8187a26d343a03489380c16723ff386" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;Q&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、コンポーネント &lt;code&gt;Q&lt;/code&gt; および &lt;code&gt;R&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="0eea487785d89d96fdac640a6604fc8fe54c944d" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;Q&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, and &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、コンポーネント &lt;code&gt;Q&lt;/code&gt; 、 &lt;code&gt;R&lt;/code&gt; 、および &lt;code&gt;p&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="cab411fc4fe9253bda3d235df40d5dfd6ef9668c" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;Q&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, and if extant &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、成分 &lt;code&gt;Q&lt;/code&gt; 、 &lt;code&gt;R&lt;/code&gt; 、および存在する場合は &lt;code&gt;p&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="b3b6360c2464673a0e4fb9b1ed45a041967155d6" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;S.D&lt;/code&gt;, &lt;code&gt;S.U&lt;/code&gt; or &lt;code&gt;S.L&lt;/code&gt; as appropriate given &lt;code&gt;S.uplo&lt;/code&gt;, and &lt;code&gt;S.p&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、適切な &lt;code&gt;S.uplo&lt;/code&gt; と &lt;code&gt;S.p&lt;/code&gt; 応じて、コンポーネント &lt;code&gt;S.D&lt;/code&gt; 、 &lt;code&gt;S.U&lt;/code&gt; または &lt;code&gt;S.L&lt;/code&gt; れます。</target>
        </trans-unit>
        <trans-unit id="f77bd282f84af7bfe48cdf3c4e7e8dc8c570cc8e" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;S.L&lt;/code&gt; and &lt;code&gt;S.Q&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、コンポーネント &lt;code&gt;S.L&lt;/code&gt; および &lt;code&gt;S.Q&lt;/code&gt; 生成されます。</target>
        </trans-unit>
        <trans-unit id="89ebce396ac9da86f707ddc5cfcf6229ef6143e2" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, and &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、成分 &lt;code&gt;U&lt;/code&gt; 、 &lt;code&gt;S&lt;/code&gt; 、および &lt;code&gt;V&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="c715668f8440af4b021f6c74fa32fef39d559c06" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;Q&lt;/code&gt;, &lt;code&gt;D1&lt;/code&gt;, &lt;code&gt;D2&lt;/code&gt;, and &lt;code&gt;R0&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、成分 &lt;code&gt;U&lt;/code&gt; 、 &lt;code&gt;V&lt;/code&gt; 、 &lt;code&gt;Q&lt;/code&gt; 、 &lt;code&gt;D1&lt;/code&gt; 、 &lt;code&gt;D2&lt;/code&gt; 、および &lt;code&gt;R0&lt;/code&gt; が生成されます。</target>
        </trans-unit>
        <trans-unit id="58ad8afd3ef50f0b4cdfded417b61d5f6036a1c3" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the factors &lt;code&gt;F.Q, F.H, F.&amp;mu;&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、係数 &lt;code&gt;F.Q, F.H, F.&amp;mu;&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="b09a0a43519ceb489793a2ede6c213029b86bdfc" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the factors &lt;code&gt;F.Q&lt;/code&gt; and &lt;code&gt;F.H&lt;/code&gt;.</source>
          <target state="translated">分解を繰り返すと、係数 &lt;code&gt;F.Q&lt;/code&gt; および &lt;code&gt;F.H&lt;/code&gt; 生成されます。</target>
        </trans-unit>
        <trans-unit id="f58aa126be8fea0928c97cbc1c2e33d08204701b" translate="yes" xml:space="preserve">
          <source>Iterating the factorization produces the components &lt;code&gt;F.L&lt;/code&gt;, &lt;code&gt;F.U&lt;/code&gt;, and &lt;code&gt;F.p&lt;/code&gt;.</source>
          <target state="translated">因数分解を繰り返すと、コンポーネント &lt;code&gt;F.L&lt;/code&gt; 、 &lt;code&gt;F.U&lt;/code&gt; 、および &lt;code&gt;F.p&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="ca49cf020b23404ede665f3ef9ef58b961aea893" translate="yes" xml:space="preserve">
          <source>Iteration over &lt;code&gt;NamedTuple&lt;/code&gt;s produces the &lt;em&gt;values&lt;/em&gt; without the names. (See example below.) To iterate over the name-value pairs, use the &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;NamedTuple&lt;/code&gt; の反復により、名前なしの&lt;em&gt;値が&lt;/em&gt;生成され&lt;em&gt;ます&lt;/em&gt;。（下の例を参照してください。）名前と値のペアを反復処理するには、&lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs&lt;/code&gt; &lt;/a&gt;関数を使用します。</target>
        </trans-unit>
        <trans-unit id="029d5196356372d794cb53808ecda6f8a64c6198" translate="yes" xml:space="preserve">
          <source>Iteration utilities</source>
          <target state="translated">イテレーションユーティリティ</target>
        </trans-unit>
        <trans-unit id="bc1f336bbebec9ed2484b3179ad56691be7b079d" translate="yes" xml:space="preserve">
          <source>IteratorEltype</source>
          <target state="translated">IteratorEltype</target>
        </trans-unit>
        <trans-unit id="762bcf9ad00a1c98c7dfe72f3f1da300a726ae97" translate="yes" xml:space="preserve">
          <source>IteratorSize</source>
          <target state="translated">IteratorSize</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="ade312c99a3f29ec263e6761dccc45de6d98af27" translate="yes" xml:space="preserve">
          <source>Iterators.Pairs</source>
          <target state="translated">Iterators.Pairs</target>
        </trans-unit>
        <trans-unit id="7f99860914bab93742ec0677d93601e7f754aab7" translate="yes" xml:space="preserve">
          <source>Iterators.Stateful</source>
          <target state="translated">Iterators.Stateful</target>
        </trans-unit>
        <trans-unit id="4b22c43fb78a467e966bea6e6bf82f640caa802a" translate="yes" xml:space="preserve">
          <source>Iterators.countfrom()</source>
          <target state="translated">Iterators.countfrom()</target>
        </trans-unit>
        <trans-unit id="6e9ea1a37868f81f1c387104af3ddce669dd91f6" translate="yes" xml:space="preserve">
          <source>Iterators.cycle()</source>
          <target state="translated">Iterators.cycle()</target>
        </trans-unit>
        <trans-unit id="15fc1b0f962745a0f7d6dddec1a5029f764fddf9" translate="yes" xml:space="preserve">
          <source>Iterators.drop()</source>
          <target state="translated">Iterators.drop()</target>
        </trans-unit>
        <trans-unit id="b622262f6019cdcf33dc40c2166a76e9968c2d6f" translate="yes" xml:space="preserve">
          <source>Iterators.enumerate()</source>
          <target state="translated">Iterators.enumerate()</target>
        </trans-unit>
        <trans-unit id="18c6e2577f1cb3f1df18e8349820ab2df102ed03" translate="yes" xml:space="preserve">
          <source>Iterators.filter()</source>
          <target state="translated">Iterators.filter()</target>
        </trans-unit>
        <trans-unit id="1c4406a3948ea47560dd3a48a99cedb41058481a" translate="yes" xml:space="preserve">
          <source>Iterators.flatten()</source>
          <target state="translated">Iterators.flatten()</target>
        </trans-unit>
        <trans-unit id="e6b2ae68200d1658f8b9b58b1bda15c7a94398ec" translate="yes" xml:space="preserve">
          <source>Iterators.partition()</source>
          <target state="translated">Iterators.partition()</target>
        </trans-unit>
        <trans-unit id="8d055b9ee1bc21393531304979f760c0dcaf8ed7" translate="yes" xml:space="preserve">
          <source>Iterators.product()</source>
          <target state="translated">Iterators.product()</target>
        </trans-unit>
        <trans-unit id="f82f74da2e638549fe42f2abf5e3d47275b9d6dc" translate="yes" xml:space="preserve">
          <source>Iterators.repeated()</source>
          <target state="translated">Iterators.repeated()</target>
        </trans-unit>
        <trans-unit id="d0a4aaf299b047ef88d9088cb3265b8c9ec460f8" translate="yes" xml:space="preserve">
          <source>Iterators.rest()</source>
          <target state="translated">Iterators.rest()</target>
        </trans-unit>
        <trans-unit id="78c5327cecfd4b16a167206d910e94f07f9e5a1d" translate="yes" xml:space="preserve">
          <source>Iterators.reverse()</source>
          <target state="translated">Iterators.reverse()</target>
        </trans-unit>
        <trans-unit id="1780ae66e17e617d0386e7c850f35f9a46563eec" translate="yes" xml:space="preserve">
          <source>Iterators.take()</source>
          <target state="translated">Iterators.take()</target>
        </trans-unit>
        <trans-unit id="38d733610a11317778f298c2adaafc9ed0e772f3" translate="yes" xml:space="preserve">
          <source>Iterators.zip()</source>
          <target state="translated">Iterators.zip()</target>
        </trans-unit>
        <trans-unit id="e5c9811ac9fab746e9ba97b16b953053ef624d64" translate="yes" xml:space="preserve">
          <source>IteratorsMD.CartesianIndex</source>
          <target state="translated">IteratorsMD.CartesianIndex</target>
        </trans-unit>
        <trans-unit id="dab2cf0daf838d270ad35eb4a74061238bf4a503" translate="yes" xml:space="preserve">
          <source>IteratorsMD.CartesianIndices</source>
          <target state="translated">IteratorsMD.CartesianIndices</target>
        </trans-unit>
        <trans-unit id="30ab5c44fe067198393909d62c86b0c386a162b7" translate="yes" xml:space="preserve">
          <source>Its second argument &lt;code&gt;args&lt;/code&gt; is an array of &lt;code&gt;jl_value_t*&lt;/code&gt; arguments and &lt;code&gt;nargs&lt;/code&gt; is the number of arguments.</source>
          <target state="translated">2番目の引数 &lt;code&gt;args&lt;/code&gt; は &lt;code&gt;jl_value_t*&lt;/code&gt; 引数の配列で、 &lt;code&gt;nargs&lt;/code&gt; は引数の数です。</target>
        </trans-unit>
        <trans-unit id="286bb02d594ea15955d87681e8267067be410857" translate="yes" xml:space="preserve">
          <source>Izakaya Lantern</source>
          <target state="translated">居酒屋灯籠</target>
        </trans-unit>
        <trans-unit id="2f5fc08c12a2ccfd9c859b035ca12cb9526ce0af" translate="yes" xml:space="preserve">
          <source>J R Bunch and L Kaufman, Some stable methods for calculating inertia</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="831fdbe2f742b632acf268054e5932135a416335" translate="yes" xml:space="preserve">
          <source>Jack-O-Lantern</source>
          <target state="translated">Jack-O-Lantern</target>
        </trans-unit>
        <trans-unit id="efed3690ea2243f5f1ac77cbb0987e5335440258" translate="yes" xml:space="preserve">
          <source>Jan</source>
          <target state="translated">Jan</target>
        </trans-unit>
        <trans-unit id="7a22d73d336abd6281d4dd71080220a230cb79de" translate="yes" xml:space="preserve">
          <source>January</source>
          <target state="translated">January</target>
        </trans-unit>
        <trans-unit id="ad6d155a582ef676e9240bfd2300a9eb9553e4f3" translate="yes" xml:space="preserve">
          <source>Japanese Castle</source>
          <target state="translated">日本の城</target>
        </trans-unit>
        <trans-unit id="ed8bfe0cf71057039bd166fcb8a33ed47c1d1057" translate="yes" xml:space="preserve">
          <source>Japanese Dolls</source>
          <target state="translated">雛人形</target>
        </trans-unit>
        <trans-unit id="97302784bd85c6fc3ccdcadbac4da292edfbb8ba" translate="yes" xml:space="preserve">
          <source>Japanese Goblin</source>
          <target state="translated">牙狼</target>
        </trans-unit>
        <trans-unit id="7263dbff30ade45b8568943da751abb88bf70826" translate="yes" xml:space="preserve">
          <source>Japanese Ogre</source>
          <target state="translated">倭鬼</target>
        </trans-unit>
        <trans-unit id="134fe6f595c84ed345de3ae0637be6654696bcaa" translate="yes" xml:space="preserve">
          <source>Japanese Post Office</source>
          <target state="translated">ゆうびんきょく</target>
        </trans-unit>
        <trans-unit id="0239b1f09d4f7c4b093fb50eb113f3c45f2d4d30" translate="yes" xml:space="preserve">
          <source>Japanese Symbol For Beginner</source>
          <target state="translated">初心者のための日本のシンボル</target>
        </trans-unit>
        <trans-unit id="d1e9767d8a0bd6d2bf67011d187d114cce67abb1" translate="yes" xml:space="preserve">
          <source>Jeans</source>
          <target state="translated">Jeans</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="3b3813dad3290588a2d14e75a092fcd63a072388" translate="yes" xml:space="preserve">
          <source>Join an array of &lt;code&gt;strings&lt;/code&gt; into a single string, inserting the given delimiter (if any) between adjacent strings. If &lt;code&gt;last&lt;/code&gt; is given, it will be used instead of &lt;code&gt;delim&lt;/code&gt; between the last two strings. If &lt;code&gt;io&lt;/code&gt; is given, the result is written to &lt;code&gt;io&lt;/code&gt; rather than returned as as a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strings&lt;/code&gt; の配列を1つの文字列に結合し、隣接する文字列の間に指定された区切り文字（存在する場合）を挿入します。 &lt;code&gt;last&lt;/code&gt; が指定されている場合、最後の2つの文字列の間で &lt;code&gt;delim&lt;/code&gt; の代わりに使用されます。場合は &lt;code&gt;io&lt;/code&gt; 付与され、その結果が書き込まれる &lt;code&gt;io&lt;/code&gt; としてではなくとして返さ &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76788f50771e86fe282c9d53f0b06082b3018e7d" translate="yes" xml:space="preserve">
          <source>Join an array of &lt;code&gt;strings&lt;/code&gt; into a single string, inserting the given delimiter between adjacent strings. If &lt;code&gt;last&lt;/code&gt; is given, it will be used instead of &lt;code&gt;delim&lt;/code&gt; between the last two strings. If &lt;code&gt;io&lt;/code&gt; is given, the result is written to &lt;code&gt;io&lt;/code&gt; rather than returned as as a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strings&lt;/code&gt; の配列を1つの文字列に結合し、隣接する文字列の間に指定の区切り文字を挿入します。場合は &lt;code&gt;last&lt;/code&gt; 指定され、それが代わりに使用されます &lt;code&gt;delim&lt;/code&gt; を最後の二つの文字列の間。場合は &lt;code&gt;io&lt;/code&gt; 付与され、その結果が書き込まれる &lt;code&gt;io&lt;/code&gt; としてではなくとして返さ &lt;code&gt;String&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0499501b2bb39022852369c1a09b6f3fb6fc16a6" translate="yes" xml:space="preserve">
          <source>Join path components into a full path. If some argument is an absolute path or (on Windows) has a drive specification that doesn't match the drive computed for the join of the preceding paths, then prior components are dropped.</source>
          <target state="translated">パスのコンポーネントをフルパスに結合します。引数の一部が絶対パスであったり、(Windowsでは)ドライブの指定が先行するパスの結合のために計算されたドライブと一致しない場合、先行するコンポーネントは削除されます。</target>
        </trans-unit>
        <trans-unit id="e64d664b335757ab1b0ed70dc6883a5f412be34b" translate="yes" xml:space="preserve">
          <source>Julia</source>
          <target state="translated">Julia</target>
        </trans-unit>
        <trans-unit id="34915350c4729155e12aa2a18e1437b46a254b8d" translate="yes" xml:space="preserve">
          <source>Julia 1.1</source>
          <target state="translated">ジュリア 1.1</target>
        </trans-unit>
        <trans-unit id="20d44d7c210bfc70cdc873c771c707c9f3303af5" translate="yes" xml:space="preserve">
          <source>Julia 1.2</source>
          <target state="translated">ジュリア 1.2</target>
        </trans-unit>
        <trans-unit id="8b642007f455f270d5f4ca8eeb353a9cd627fd87" translate="yes" xml:space="preserve">
          <source>Julia 1.2 Documentation</source>
          <target state="translated">Julia 1.2 ドキュメント</target>
        </trans-unit>
        <trans-unit id="735bc5320f837b1441f2cfffa31dd786468645d6" translate="yes" xml:space="preserve">
          <source>Julia 1.5 Documentation</source>
          <target state="translated">Julia 1.5 ドキュメント</target>
        </trans-unit>
        <trans-unit id="858ca45563192af10cdc21c94e7d577c6f26612b" translate="yes" xml:space="preserve">
          <source>Julia Base Type</source>
          <target state="translated">ジュリアベースタイプ</target>
        </trans-unit>
        <trans-unit id="c3d7a86babfba0e54357fb2d1ed82f5bfe9ac6bf" translate="yes" xml:space="preserve">
          <source>Julia Base contains a range of functions and macros appropriate for performing scientific and numerical computing, but is also as broad as those of many general purpose programming languages. Additional functionality is available from a growing collection of available packages. Functions are grouped by topic below.</source>
          <target state="translated">Julia Baseには、科学的計算や数値計算を行うのに適した関数やマクロが含まれていますが、多くの汎用プログラミング言語と同じくらい幅広い機能を持っています。追加機能は、利用可能なパッケージのコレクションから利用することができます。関数は以下のトピックごとにグループ化されています。</target>
        </trans-unit>
        <trans-unit id="ecea329751a7da4bad931e777e922977157ad8f8" translate="yes" xml:space="preserve">
          <source>Julia Base uses this convention throughout and contains examples of functions with both copying and modifying forms (e.g., &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;), and others which are just modifying (e.g., &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.pop!&quot;&gt;&lt;code&gt;pop!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.splice!&quot;&gt;&lt;code&gt;splice!&lt;/code&gt;&lt;/a&gt;). It is typical for such functions to also return the modified array for convenience.</source>
          <target state="translated">Julia Baseは、この規則を一貫して使用しており、フォームのコピーと変更の両方を備えた関数の例（たとえば、&lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt;）、および変更しているだけのもの（たとえば、&lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/collections/index#Base.pop!&quot;&gt; &lt;code&gt;pop!&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/collections/index#Base.splice!&quot;&gt; &lt;code&gt;splice!&lt;/code&gt; &lt;/a&gt;）を含んでいます。このような関数は、便宜上、変更された配列も返すのが一般的です。</target>
        </trans-unit>
        <trans-unit id="7694e2fcb791d9c25c404da14cf2f301a28f48ea" translate="yes" xml:space="preserve">
          <source>Julia Coroutines (Green Threading)</source>
          <target state="translated">ジュリア・コルチン(緑のスレッディング</target>
        </trans-unit>
        <trans-unit id="79e749c34e72bbae64d0f791f7a71e619f74aae2" translate="yes" xml:space="preserve">
          <source>Julia GPU man pages</source>
          <target state="translated">ジュリアGPUマンページ</target>
        </trans-unit>
        <trans-unit id="a42ee146344a47614f0b605c9369dddac1347289" translate="yes" xml:space="preserve">
          <source>Julia Releases</source>
          <target state="translated">ジュリアのリリース</target>
        </trans-unit>
        <trans-unit id="799d12425163528cdf3dbdb65e3972da06d0f30c" translate="yes" xml:space="preserve">
          <source>Julia Tasks allow suspending and resuming computations for I/O, event handling, producer-consumer processes, and similar patterns. Tasks can synchronize through operations like &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fetch&lt;/code&gt;, and communicate via &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">Julia Tasksを使用すると、I / O、イベント処理、生産者/消費者プロセス、および同様のパターンの計算を一時停止および再開できます。タスクは、&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;や &lt;code&gt;fetch&lt;/code&gt; などの操作を通じて同期し、&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;を介して通信できます。</target>
        </trans-unit>
        <trans-unit id="8d8d2a4a743981227407130fd283bf2436f883ac" translate="yes" xml:space="preserve">
          <source>Julia aims to create an unprecedented combination of ease-of-use, power, and efficiency in a single language. In addition to the above, some advantages of Julia over comparable systems include:</source>
          <target state="translated">Juliaは、使いやすさ、パワー、効率性を単一言語で実現することを目指しています。上記に加えて、同等のシステムと比較した場合のJuliaの利点としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="05d11d59ee07392ef31079bd1e459ad76c3f824e" translate="yes" xml:space="preserve">
          <source>Julia allows an optional trailing comma when that comma does not change the meaning of code. This can cause confusion among R users when indexing into arrays. For example, &lt;code&gt;x[1,]&lt;/code&gt; in R would return the first row of a matrix; in Julia, however, the comma is ignored, so &lt;code&gt;x[1,] == x[1]&lt;/code&gt;, and will return the first element. To extract a row, be sure to use &lt;code&gt;:&lt;/code&gt;, as in &lt;code&gt;x[1,:]&lt;/code&gt;.</source>
          <target state="translated">Juliaは、コンマでコードの意味が変わらない場合に、オプションの後続コンマを許可します。これにより、配列にインデックスを付けるときに、Rユーザー間で混乱が生じる可能性があります。たとえば、Rの &lt;code&gt;x[1,]&lt;/code&gt; は、行列の最初の行を返します。ただし、ジュリアでは、コンマは無視されるため、 &lt;code&gt;x[1,] == x[1]&lt;/code&gt; であり、最初の要素を返します。行を抽出するには、 &lt;code&gt;x[1,:]&lt;/code&gt; ように、必ず &lt;code&gt;:&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="c83ba6941f781ea6f95d544e9edf743cc32b5bdb" translate="yes" xml:space="preserve">
          <source>Julia also defines the types &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;UInt&lt;/code&gt;, which are aliases for the system's signed and unsigned native integer types respectively:</source>
          <target state="translated">Juliaは、 &lt;code&gt;Int&lt;/code&gt; 型と &lt;code&gt;UInt&lt;/code&gt; 型も定義します。これらは、それぞれシステムの符号付きおよび符号なしネイティブ整数型のエイリアスです。</target>
        </trans-unit>
        <trans-unit id="5b4f0844a2699d5ea273cd05f5a3f5753244a2f6" translate="yes" xml:space="preserve">
          <source>Julia also provides &lt;code&gt;*&lt;/code&gt; for string concatenation:</source>
          <target state="translated">Juliaは、文字列連結のための &lt;code&gt;*&lt;/code&gt; も提供しています。</target>
        </trans-unit>
        <trans-unit id="42a5af28aae285694adf3f30e69a77a9764131d7" translate="yes" xml:space="preserve">
          <source>Julia also provides the &lt;a href=&quot;../../base/numbers/index#Base.nextfloat&quot;&gt;&lt;code&gt;nextfloat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Base.prevfloat&quot;&gt;&lt;code&gt;prevfloat&lt;/code&gt;&lt;/a&gt; functions which return the next largest or smallest representable floating-point number to the argument respectively:</source>
          <target state="translated">Juliaは、次の最大または最小の表現可能な浮動小数点数をそれぞれ引数に返す、&lt;a href=&quot;../../base/numbers/index#Base.nextfloat&quot;&gt; &lt;code&gt;nextfloat&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../base/numbers/index#Base.prevfloat&quot;&gt; &lt;code&gt;prevfloat&lt;/code&gt; &lt;/a&gt;関数も提供します。</target>
        </trans-unit>
        <trans-unit id="06ed8be5c06d7dc93b6c0404ce3653f58e45b54f" translate="yes" xml:space="preserve">
          <source>Julia also supports &lt;a href=&quot;#man-multithreading-1&quot;&gt;experimental multi-threading&lt;/a&gt;, where execution is forked and an anonymous function is run across all threads. Known as the fork-join approach, parallel threads execute independently, and must ultimately be joined in Julia's main thread to allow serial execution to continue. Multi-threading is supported using the &lt;a href=&quot;../../base/multi-threading/index#lib-multithreading-1&quot;&gt;&lt;code&gt;Base.Threads&lt;/code&gt;&lt;/a&gt; module that is still considered experimental, as Julia is not yet fully thread-safe. In particular segfaults seem to occur during I/O operations and task switching. As an up-to-date reference, keep an eye on &lt;a href=&quot;https://github.com/JuliaLang/julia/issues?q=is%3Aopen+is%3Aissue+label%3Amultithreading&quot;&gt;the issue tracker&lt;/a&gt;. Multi-Threading should only be used if you take into consideration global variables, locks and atomics, all of which are explained later.</source>
          <target state="translated">Juliaは&lt;a href=&quot;#man-multithreading-1&quot;&gt;実験的なマルチスレッド化&lt;/a&gt;もサポートします。この場合、実行が分岐され、匿名関数がすべてのスレッドで実行されます。 fork-joinアプローチとして知られている並列スレッドは独立して実行され、最終的にJuliaのメインスレッドに参加してシリアル実行を継続する必要があります。Juliaはまだ完全にスレッドセーフではないため、マルチスレッドは、まだ実験的と見なされている&lt;a href=&quot;../../base/multi-threading/index#lib-multithreading-1&quot;&gt; &lt;code&gt;Base.Threads&lt;/code&gt; &lt;/a&gt;モジュールを使用してサポートされます。特に、segfaultは、I / O操作とタスク切り替え中に発生するようです。最新のリファレンスとして&lt;a href=&quot;https://github.com/JuliaLang/julia/issues?q=is%3Aopen+is%3Aissue+label%3Amultithreading&quot;&gt;、課題トラッカーに&lt;/a&gt;注意してください。マルチスレッディングは、グローバル変数、ロック、およびアトミックを考慮する場合にのみ使用する必要があります。これらはすべて後で説明します。</target>
        </trans-unit>
        <trans-unit id="ab93a47c44a4029660cdea5a681e67f3452b925f" translate="yes" xml:space="preserve">
          <source>Julia and C can share array data without copying. The next example will show how this works.</source>
          <target state="translated">JuliaとCはコピーせずに配列データを共有することができます。次の例では、これがどのように動作するかを示します。</target>
        </trans-unit>
        <trans-unit id="989b4bbc6cbc89a53b5cc95fd259449cc83265cf" translate="yes" xml:space="preserve">
          <source>Julia and its package ecosystem includes tools that may help you diagnose problems and improve the performance of your code:</source>
          <target state="translated">Julia とそのパッケージのエコシステムには、問題を診断してコードのパフォーマンスを向上させるのに役立つツールが含まれています。</target>
        </trans-unit>
        <trans-unit id="bb6140d98b962ed45444f6097b48c1ab7b34b758" translate="yes" xml:space="preserve">
          <source>Julia applies the following order and associativity of operations, from highest precedence to lowest:</source>
          <target state="translated">ジュリアは、優先順位の高いものから低いものまで、次のような順序と連想性を適用します。</target>
        </trans-unit>
        <trans-unit id="a2d556e852ab5ec005eba2ee374bde91855e354e" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas C/C++ arrays are row major ordered by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to C/C++ (see &lt;a href=&quot;../performance-tips/index#man-performance-column-major&quot;&gt;relevant section of Performance Tips&lt;/a&gt;).</source>
          <target state="translated">Julia配列は列メジャー（Fortran順）ですが、C / C ++配列はデフォルトで行メジャー順です。配列をループするときに最適なパフォーマンスを得るには、C / C ++に対してJuliaでループの順序を逆にする必要があります（&lt;a href=&quot;../performance-tips/index#man-performance-column-major&quot;&gt;パフォーマンスのヒントの関連セクションを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="79e54f86310ed0d0b6726cbc9118645ff3e41ba9" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas C/C++ arrays are row major ordered by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to C/C++ (see relevant section of &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;).</source>
          <target state="translated">Julia配列は列優先（Fortran順）ですが、C / C ++配列はデフォルトで行優先です。配列をループするときに最適なパフォーマンスを得るには、C / C ++に対してJuliaでループの順序を逆にする必要があります（&lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;パフォーマンスのヒントの&lt;/a&gt;関連セクションを参照）。</target>
        </trans-unit>
        <trans-unit id="c5aee379485d3e8989f69a590d396666e706c30b" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas NumPy arrays are row major (C-ordered) by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to NumPy (see &lt;a href=&quot;../performance-tips/index#man-performance-column-major&quot;&gt;relevant section of Performance Tips&lt;/a&gt;).</source>
          <target state="translated">Julia配列は列メジャー（Fortran順）ですが、NumPy配列はデフォルトで行メジャー（C順）です。配列をループするときに最適なパフォーマンスを得るには、ループの順序をNumPyに対してJuliaで逆にする必要があります（&lt;a href=&quot;../performance-tips/index#man-performance-column-major&quot;&gt;パフォーマンスのヒントの関連セクションを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="101c9a575d6ee596869371a0022ecfe27370c862" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas NumPy arrays are row major (C-ordered) by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to NumPy (see relevant section of &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;).</source>
          <target state="translated">Julia配列は列優先（Fortran順序）ですが、NumPy配列はデフォルトで行優先（C順序）です。配列をループするときに最適なパフォーマンスを得るには、ジュリアではループの順序をNumPyに対して逆にする必要があります（&lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;パフォーマンスのヒントの&lt;/a&gt;関連セクションを参照）。</target>
        </trans-unit>
        <trans-unit id="4295a55355c53bb69700ac344333d3ad56193792" translate="yes" xml:space="preserve">
          <source>Julia arrays are indexed with square brackets, &lt;code&gt;A[i,j]&lt;/code&gt;.</source>
          <target state="translated">Julia配列は、角括弧 &lt;code&gt;A[i,j]&lt;/code&gt; インデックスが付けられます。</target>
        </trans-unit>
        <trans-unit id="6ee791aabb20af6c1bfdaa172e030af0dec26574" translate="yes" xml:space="preserve">
          <source>Julia arrays are indexed with square brackets, and can have more than one dimension &lt;code&gt;A[i,j]&lt;/code&gt;. This syntax is not just syntactic sugar for a reference to a pointer or address as in C/C++. See the Julia documentation for the syntax for array construction (it has changed between versions).</source>
          <target state="translated">Julia配列は角かっこでインデックスが付けられ、複数の次元 &lt;code&gt;A[i,j]&lt;/code&gt; 持つことができます。この構文は、C / C ++のように、ポインターまたはアドレスへの参照の単なる構文糖衣ではありません。配列構築の構文については、Juliaのドキュメントを参照してください（バージョン間で変更されています）。</target>
        </trans-unit>
        <trans-unit id="4b072870337da75d87b7efdc10a5b80a2cf3a54d" translate="yes" xml:space="preserve">
          <source>Julia arrays are not copied when assigned to another variable. After &lt;code&gt;A = B&lt;/code&gt;, changing elements of &lt;code&gt;B&lt;/code&gt; will modify &lt;code&gt;A&lt;/code&gt; as well.</source>
          <target state="translated">Julia配列は、別の変数に割り当てられてもコピーされません。 &lt;code&gt;A = B&lt;/code&gt; 後、 &lt;code&gt;B&lt;/code&gt; の要素を変更すると、 &lt;code&gt;A&lt;/code&gt; も変更されます。</target>
        </trans-unit>
        <trans-unit id="ee983dec29328f6ef30dd7f19c04408b414cdba1" translate="yes" xml:space="preserve">
          <source>Julia arrays are not copied when assigned to another variable. After &lt;code&gt;A = B&lt;/code&gt;, changing elements of &lt;code&gt;B&lt;/code&gt; will modify &lt;code&gt;A&lt;/code&gt; as well. Updating operators like &lt;code&gt;+=&lt;/code&gt; do not operate in-place, they are equivalent to &lt;code&gt;A = A + B&lt;/code&gt; which rebinds the left-hand side to the result of the right-hand side expression.</source>
          <target state="translated">Julia配列は、別の変数に割り当てられてもコピーされません。 &lt;code&gt;A = B&lt;/code&gt; 後、 &lt;code&gt;B&lt;/code&gt; の要素を変更すると、 &lt;code&gt;A&lt;/code&gt; も変更されます。 &lt;code&gt;+=&lt;/code&gt; のような更新演算子はインプレースで動作しません。これらは &lt;code&gt;A = A + B&lt;/code&gt; と同等であり、左側を右側の式の結果に再バインドします。</target>
        </trans-unit>
        <trans-unit id="f8885b17b4a7f2b903bda15b50d42d46540e083d" translate="yes" xml:space="preserve">
          <source>Julia arrays are represented in C by the datatype &lt;code&gt;jl_array_t*&lt;/code&gt;. Basically, &lt;code&gt;jl_array_t&lt;/code&gt; is a struct that contains:</source>
          <target state="translated">Julia配列は、Cではデータ型 &lt;code&gt;jl_array_t*&lt;/code&gt; 表されます。基本的に、 &lt;code&gt;jl_array_t&lt;/code&gt; は以下を含む構造体です。</target>
        </trans-unit>
        <trans-unit id="f90d5ad1f221d4a17d6ad64fe11db8244636641f" translate="yes" xml:space="preserve">
          <source>Julia automatically inserts calls to the &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; function to convert each argument to the specified type. For example, the following call:</source>
          <target state="translated">Juliaは、&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt;関数への呼び出しを自動的に挿入して、各引数を指定された型に変換します。たとえば、次の呼び出し：</target>
        </trans-unit>
        <trans-unit id="94aa685212fa097b84259cd91052f6a151ab1143" translate="yes" xml:space="preserve">
          <source>Julia borrows backtick notation for commands from the shell, Perl, and Ruby. However, in Julia, writing</source>
          <target state="translated">Julia はシェル、Perl、Ruby のコマンドのバックティック記法を借用しています。しかし、Julia では</target>
        </trans-unit>
        <trans-unit id="1e4dcf624482d6017b9073977072d06f0c1e1383" translate="yes" xml:space="preserve">
          <source>Julia can be configured with a number of environment variables, set either in the usual way for each operating system, or in a portable way from within Julia. Supposing that you want to set the environment variable &lt;code&gt;JULIA_EDITOR&lt;/code&gt; to &lt;code&gt;vim&lt;/code&gt;, you can type &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;] = &quot;vim&quot;&lt;/code&gt; (for instance, in the REPL) to make this change on a case by case basis, or add the same to the user configuration file &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; in the user's home directory to have a permanent effect. The current value of the same environment variable can be determined by evaluating &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;]&lt;/code&gt;.</source>
          <target state="translated">Juliaは、オペレーティングシステムごとに通常の方法で設定するか、Julia内から移植可能な方法で設定する、いくつかの環境変数で構成できます。あなたは、環境変数を設定したいと仮定すると &lt;code&gt;JULIA_EDITOR&lt;/code&gt; に &lt;code&gt;vim&lt;/code&gt; 、次のように入力することができ &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;] = &quot;vim&quot;&lt;/code&gt; （例えば、REPLには）ケースバイケースでこの変更を行うには、またはに同じを追加ユーザーのホームディレクトリにあるユーザー設定ファイル &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; は永続的な効果を持ちます。同じ環境変数の現在の値は、 &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;]&lt;/code&gt; 評価することによって決定できます。</target>
        </trans-unit>
        <trans-unit id="25624934c68cd4d66c22470ba9dffff20f4e4703" translate="yes" xml:space="preserve">
          <source>Julia can be started in parallel mode with either the &lt;code&gt;-p&lt;/code&gt; or the &lt;code&gt;--machine-file&lt;/code&gt; options. &lt;code&gt;-p n&lt;/code&gt; will launch an additional &lt;code&gt;n&lt;/code&gt; worker processes, while &lt;code&gt;--machine-file file&lt;/code&gt; will launch a worker for each line in file &lt;code&gt;file&lt;/code&gt;. The machines defined in &lt;code&gt;file&lt;/code&gt; must be accessible via a password-less &lt;code&gt;ssh&lt;/code&gt; login, with Julia installed at the same location as the current host. Each machine definition takes the form &lt;code&gt;[count*][user@]host[:port] [bind_addr[:port]]&lt;/code&gt;. &lt;code&gt;user&lt;/code&gt; defaults to current user, &lt;code&gt;port&lt;/code&gt; to the standard ssh port. &lt;code&gt;count&lt;/code&gt; is the number of workers to spawn on the node, and defaults to 1. The optional &lt;code&gt;bind-to bind_addr[:port]&lt;/code&gt; specifies the IP address and port that other workers should use to connect to this worker.</source>
          <target state="translated">Juliaは、 &lt;code&gt;-p&lt;/code&gt; オプションまたは &lt;code&gt;--machine-file&lt;/code&gt; オプションを使用して並列モードで起動できます。 &lt;code&gt;-p n&lt;/code&gt; は追加の &lt;code&gt;n&lt;/code&gt; 個のワーカープロセスを起動し &lt;code&gt;--machine-file file&lt;/code&gt; が、-machine-file fileはファイルfileの各行のワーカーを起動し &lt;code&gt;file&lt;/code&gt; 。 &lt;code&gt;file&lt;/code&gt; 定義されたマシンは、現在のホストと同じ場所にJuliaをインストールし、パスワードなしの &lt;code&gt;ssh&lt;/code&gt; ログインでアクセスできる必要があります。各マシン定義は、 &lt;code&gt;[count*][user@]host[:port] [bind_addr[:port]]&lt;/code&gt; の形式を取ります。 &lt;code&gt;user&lt;/code&gt; デフォルトは現在のユーザー、 &lt;code&gt;port&lt;/code&gt; は標準のsshポートです。 &lt;code&gt;count&lt;/code&gt; ノードでスポーンするワーカーの数で、デフォルトは1です。オプションの &lt;code&gt;bind-to bind_addr[:port]&lt;/code&gt; は、他のワーカーがこのワーカーに接続するために使用する必要があるIPアドレスとポートを指定します。</target>
        </trans-unit>
        <trans-unit id="1aef7868e131aa3765142ca6c54c8fa0eb438e27" translate="yes" xml:space="preserve">
          <source>Julia can create substrings by indexing into strings. In R, strings must be converted into character vectors before creating substrings.</source>
          <target state="translated">Juliaは文字列にインデックスを付けることで部分文字列を作成することができます。Rでは、文字列は部分文字列を生成する前に文字ベクトルに変換されなければなりません。</target>
        </trans-unit>
        <trans-unit id="5f876f801dbf3de94a121a0fbe557fe7c2dabadb" translate="yes" xml:space="preserve">
          <source>Julia can run multiple commands in parallel:</source>
          <target state="translated">Juliaは複数のコマンドを並行して実行することができます。</target>
        </trans-unit>
        <trans-unit id="d72c9df952d8a93730d24273b050dd7a87c41b99" translate="yes" xml:space="preserve">
          <source>Julia cannot assign to the results of function calls on the left hand side of an assignment operation: you cannot write &lt;code&gt;diag(M) = fill(1, n)&lt;/code&gt;.</source>
          <target state="translated">Juliaは、割り当て操作の左側にある関数呼び出しの結果に割り当てることができません &lt;code&gt;diag(M) = fill(1, n)&lt;/code&gt; 書き込むことはできません。</target>
        </trans-unit>
        <trans-unit id="b9b5bf6c00b042abbcf8493eca58ab2e8c4ebfcf" translate="yes" xml:space="preserve">
          <source>Julia clusters are designed to be executed on already secured environments on infrastructure such as local laptops, departmental clusters, or even the cloud. This section covers network security requirements for the inbuilt &lt;code&gt;LocalManager&lt;/code&gt; and &lt;code&gt;SSHManager&lt;/code&gt;:</source>
          <target state="translated">Juliaクラスターは、ローカルラップトップ、部門別クラスター、さらにはクラウドなどのインフラストラクチャ上の既に保護された環境で実行されるように設計されています。このセクションでは、組み込みの &lt;code&gt;LocalManager&lt;/code&gt; および &lt;code&gt;SSHManager&lt;/code&gt; のネットワークセキュリティ要件について説明します。</target>
        </trans-unit>
        <trans-unit id="dbe512ceba50dc3b08408e0b7101fcd9582324dd" translate="yes" xml:space="preserve">
          <source>Julia code can throw exceptions. For example, consider:</source>
          <target state="translated">Julia のコードは例外を投げることができます。例えば、考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="d4d45a9c6d816f57f235a4b45d059535efea33d0" translate="yes" xml:space="preserve">
          <source>Julia comes with a full-featured interactive command-line REPL (read-eval-print loop) built into the &lt;code&gt;julia&lt;/code&gt; executable. In addition to allowing quick and easy evaluation of Julia statements, it has a searchable history, tab-completion, many helpful keybindings, and dedicated help and shell modes. The REPL can be started by simply calling &lt;code&gt;julia&lt;/code&gt; with no arguments or double-clicking on the executable:</source>
          <target state="translated">Juliaには、 &lt;code&gt;julia&lt;/code&gt; 実行可能ファイルに組み込まれた、フル機能のインタラクティブなコマンドラインREPL（read-eval-printループ）が付属しています。Juliaステートメントの迅速かつ簡単な評価を可能にすることに加えて、検索可能な履歴、タブ補完、多くの役立つキーバインディング、専用のヘルプおよびシェルモードがあります。REPLは、引数なしで &lt;code&gt;julia&lt;/code&gt; を呼び出すか、実行可能ファイルをダブルクリックするだけで開始できます。</target>
        </trans-unit>
        <trans-unit id="04f431b0e99b100c80ed3b37854b8baa69220c9e" translate="yes" xml:space="preserve">
          <source>Julia compiles and uses its own copy of OpenBLAS, with threads currently capped at &lt;code&gt;8&lt;/code&gt; (or the number of your cores).</source>
          <target state="translated">JuliaはOpenBLASの独自のコピーをコンパイルして使用し、スレッドの上限は現在 &lt;code&gt;8&lt;/code&gt; （またはコアの数）です。</target>
        </trans-unit>
        <trans-unit id="0463aec28ff8f6050169511f8bc7eb9f0e64fcdf" translate="yes" xml:space="preserve">
          <source>Julia constructs vectors using brackets. Julia's &lt;code&gt;[1, 2, 3]&lt;/code&gt; is the equivalent of R's &lt;code&gt;c(1, 2, 3)&lt;/code&gt;.</source>
          <target state="translated">ジュリアは角かっこを使用してベクトルを作成します。ジュリアの &lt;code&gt;[1, 2, 3]&lt;/code&gt; は、Rの &lt;code&gt;c(1, 2, 3)&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="2c3022b87e47f6ac9e21545c147897ab28a7faa7" translate="yes" xml:space="preserve">
          <source>Julia discourages populating the main namespace with functions. Most statistical functionality for Julia is found in &lt;a href=&quot;https://pkg.julialang.org/&quot;&gt;packages&lt;/a&gt; under the &lt;a href=&quot;https://github.com/JuliaStats&quot;&gt;JuliaStats organization&lt;/a&gt;. For example:</source>
          <target state="translated">Juliaは、メインの名前空間に関数を設定することを推奨していません。Juliaのほとんどの統計機能は、&lt;a href=&quot;https://github.com/JuliaStats&quot;&gt;JuliaStats組織の&lt;/a&gt;&lt;a href=&quot;https://pkg.julialang.org/&quot;&gt;パッケージにあります&lt;/a&gt;。例えば：</target>
        </trans-unit>
        <trans-unit id="4d3373777de6110679b5b20361db329af8df4ef4" translate="yes" xml:space="preserve">
          <source>Julia discourages the use of semicolons to end statements. The results of statements are not automatically printed (except at the interactive prompt), and lines of code do not need to end with semicolons. &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt;&lt;code&gt;println&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt;&lt;code&gt;@printf&lt;/code&gt;&lt;/a&gt; can be used to print specific output.</source>
          <target state="translated">ジュリアは、ステートメントを終了するためにセミコロンを使用しないようにしています。ステートメントの結果は自動的に出力されず（インタラクティブプロンプトを除く）、コード行がセミコロンで終了する必要はありません。&lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt; &lt;code&gt;println&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt; &lt;code&gt;@printf&lt;/code&gt; &lt;/a&gt;を使用して、特定の出力を印刷できます。</target>
        </trans-unit>
        <trans-unit id="04e059ffc127f6546f46c24be663b53bb5ca0e7a" translate="yes" xml:space="preserve">
          <source>Julia does not automatically grow arrays in an assignment statement. Whereas in MATLAB &lt;code&gt;a(4) = 3.2&lt;/code&gt; can create the array &lt;code&gt;a = [0 0 0 3.2]&lt;/code&gt; and &lt;code&gt;a(5) = 7&lt;/code&gt; can grow it into &lt;code&gt;a = [0 0 0 3.2 7]&lt;/code&gt;, the corresponding Julia statement &lt;code&gt;a[5] = 7&lt;/code&gt; throws an error if the length of &lt;code&gt;a&lt;/code&gt; is less than 5 or if this statement is the first use of the identifier &lt;code&gt;a&lt;/code&gt;. Julia has &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.append!&quot;&gt;&lt;code&gt;append!&lt;/code&gt;&lt;/a&gt;, which grow &lt;code&gt;Vector&lt;/code&gt;s much more efficiently than MATLAB's &lt;code&gt;a(end+1) = val&lt;/code&gt;.</source>
          <target state="translated">Juliaは、割り当てステートメントで配列を自動的に拡張しません。 MATLABでは &lt;code&gt;a(4) = 3.2&lt;/code&gt; は配列 &lt;code&gt;a = [0 0 0 3.2]&lt;/code&gt; を作成でき、 &lt;code&gt;a(5) = 7&lt;/code&gt; はそれを &lt;code&gt;a = [0 0 0 3.2 7]&lt;/code&gt; に拡張できますが、対応するJuliaステートメント &lt;code&gt;a[5] = 7&lt;/code&gt; は、 &lt;code&gt;a&lt;/code&gt; の長さが5未満の場合、またはこのステートメントが識別子 &lt;code&gt;a&lt;/code&gt; の最初の使用である場合にエラーをスローします。ジュリアが&lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt;そして&lt;a href=&quot;../../base/collections/index#Base.append!&quot;&gt; &lt;code&gt;append!&lt;/code&gt; &lt;/a&gt;、MATLABの &lt;code&gt;a(end+1) = val&lt;/code&gt; よりはるかに効率的に &lt;code&gt;Vector&lt;/code&gt; を拡張します。</target>
        </trans-unit>
        <trans-unit id="113852d54ae1eab98b745b5419ac194b68416265" translate="yes" xml:space="preserve">
          <source>Julia does not have an analog of MATLAB's &lt;code&gt;clear&lt;/code&gt; function; once a name is defined in a Julia session (technically, in module &lt;code&gt;Main&lt;/code&gt;), it is always present.</source>
          <target state="translated">Juliaには、MATLABの &lt;code&gt;clear&lt;/code&gt; 関数に類似するものはありません。名前がJuliaセッションで（技術的には &lt;code&gt;Main&lt;/code&gt; モジュールで）定義されると、常に存在します。</target>
        </trans-unit>
        <trans-unit id="976166bb189635ca72f2fa234ae3939afd751bdc" translate="yes" xml:space="preserve">
          <source>Julia does not provide &lt;code&gt;nrow&lt;/code&gt; and &lt;code&gt;ncol&lt;/code&gt;. Instead, use &lt;code&gt;size(M, 1)&lt;/code&gt; for &lt;code&gt;nrow(M)&lt;/code&gt; and &lt;code&gt;size(M, 2)&lt;/code&gt; for &lt;code&gt;ncol(M)&lt;/code&gt;.</source>
          <target state="translated">Juliaは &lt;code&gt;nrow&lt;/code&gt; と &lt;code&gt;ncol&lt;/code&gt; を提供していません。代わりに、 &lt;code&gt;nrow(M)&lt;/code&gt; には &lt;code&gt;size(M, 1)&lt;/code&gt; 、ncol（M）には &lt;code&gt;size(M, 2)&lt;/code&gt; を使用して &lt;code&gt;ncol(M)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9006bf61e6f8840d28990bf4b3458318711564d6" translate="yes" xml:space="preserve">
          <source>Julia does not require parentheses when writing &lt;code&gt;if&lt;/code&gt; statements or &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; loops: use &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; instead of &lt;code&gt;for (i in c(1, 2, 3))&lt;/code&gt; and &lt;code&gt;if i == 1&lt;/code&gt; instead of &lt;code&gt;if (i == 1)&lt;/code&gt;.</source>
          <target state="translated">Juliaは &lt;code&gt;if&lt;/code&gt; ステートメントまたは &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; ループを記述するときに括弧を必要としません。for &lt;code&gt;for (i in c(1, 2, 3))&lt;/code&gt; ではなく &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; 使用し、 &lt;code&gt;if i == 1&lt;/code&gt; の &lt;code&gt;if (i == 1)&lt;/code&gt; はif （i == 1）。</target>
        </trans-unit>
        <trans-unit id="ef86462da92aecc95d832b0a401463ce19d89f34" translate="yes" xml:space="preserve">
          <source>Julia does not require parentheses when writing &lt;code&gt;if&lt;/code&gt; statements or &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; loops: use &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; instead of &lt;code&gt;for (int i=1; i &amp;lt;= 3; i++)&lt;/code&gt; and &lt;code&gt;if i == 1&lt;/code&gt; instead of &lt;code&gt;if (i == 1)&lt;/code&gt;.</source>
          <target state="translated">Juliaは &lt;code&gt;if&lt;/code&gt; ステートメントまたは &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; ループを書くときに括弧を必要としません： &lt;code&gt;for (int i=1; i &amp;lt;= 3; i++)&lt;/code&gt; 代わりにfor &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; 使用し、 &lt;code&gt;if i == 1&lt;/code&gt; 代わりに &lt;code&gt;if (i == 1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9dab151404329caee20c7d4f7fc1cfb9d014b7b4" translate="yes" xml:space="preserve">
          <source>Julia does not require the use of semicolons to end statements. The results of expressions are not automatically printed (except at the interactive prompt, i.e. the REPL), and lines of code do not need to end with semicolons. &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt;&lt;code&gt;println&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt;&lt;code&gt;@printf&lt;/code&gt;&lt;/a&gt; can be used to print specific output. In the REPL, &lt;code&gt;;&lt;/code&gt; can be used to suppress output. &lt;code&gt;;&lt;/code&gt; also has a different meaning within &lt;code&gt;[ ]&lt;/code&gt;, something to watch out for. &lt;code&gt;;&lt;/code&gt; can be used to separate expressions on a single line, but are not strictly necessary in many cases, and are more an aid to readability.</source>
          <target state="translated">ジュリアでは、ステートメントを終了するためにセミコロンを使用する必要はありません。式の結果は自動的に出力されません（インタラクティブプロンプト（REPL）を除く）。コード行はセミコロンで終了する必要はありません。&lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt; &lt;code&gt;println&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt; &lt;code&gt;@printf&lt;/code&gt; &lt;/a&gt;を使用して、特定の出力を印刷できます。 REPLでは &lt;code&gt;;&lt;/code&gt; 出力を抑制するために使用できます。 &lt;code&gt;;&lt;/code&gt; &lt;code&gt;[ ]&lt;/code&gt; 内でも別の意味があり、注意が必要です。 &lt;code&gt;;&lt;/code&gt; 1行で式を区切るために使用できますが、多くの場合厳密に必要ではなく、読みやすくするために役立ちます。</target>
        </trans-unit>
        <trans-unit id="3aeb7f64792ed5618bd5020762501e30791645d0" translate="yes" xml:space="preserve">
          <source>Julia does not support negative indices. In particular, the last element of a list or array is indexed with &lt;code&gt;end&lt;/code&gt; in Julia, not &lt;code&gt;-1&lt;/code&gt; as in Python.</source>
          <target state="translated">ジュリアは負のインデックスをサポートしていません。特に、リストや配列の最後の要素には、Pythonのように &lt;code&gt;-1&lt;/code&gt; ではなく、ジュリアで &lt;code&gt;end&lt;/code&gt; インデックスが付けられます。</target>
        </trans-unit>
        <trans-unit id="f5ece5c5877f48513873a461f405e2da3018d04a" translate="yes" xml:space="preserve">
          <source>Julia does not support the &lt;code&gt;NULL&lt;/code&gt; type. The closest equivalent is &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;, but it behaves like a scalar value rather than like a list. Use &lt;code&gt;x === nothing&lt;/code&gt; instead of &lt;code&gt;is.null(x)&lt;/code&gt;.</source>
          <target state="translated">Juliaは &lt;code&gt;NULL&lt;/code&gt; 型をサポートしていません。最も近いものは&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;ありませんが、リストのようではなくスカラー値のように動作します。 &lt;code&gt;is.null(x)&lt;/code&gt; の代わりに &lt;code&gt;x === nothing&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="2c5112c931f9c26dffeeec5c85f5a9032e0c2b42" translate="yes" xml:space="preserve">
          <source>Julia does not treat the numbers &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; as Booleans. You cannot write &lt;code&gt;if (1)&lt;/code&gt; in Julia, because &lt;code&gt;if&lt;/code&gt; statements accept only booleans. Instead, you can write &lt;code&gt;if true&lt;/code&gt;, &lt;code&gt;if Bool(1)&lt;/code&gt;, or &lt;code&gt;if 1==1&lt;/code&gt;.</source>
          <target state="translated">ジュリアは数値 &lt;code&gt;0&lt;/code&gt; と &lt;code&gt;1&lt;/code&gt; をブール値として扱いません。あなたは書くことができない &lt;code&gt;if (1)&lt;/code&gt; ので、ジュリアで &lt;code&gt;if&lt;/code&gt; 文が唯一のブール値を受け入れます。代わりに、あなたは書くことができます &lt;code&gt;if true&lt;/code&gt; 、 &lt;code&gt;if Bool(1)&lt;/code&gt; 、または &lt;code&gt;if 1==1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5d0ea94ce19e9b69c6095b45e92d65e847fbab5" translate="yes" xml:space="preserve">
          <source>Julia doesn't require parens around conditions in &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt;. Write:</source>
          <target state="translated">ジュリアは &lt;code&gt;if&lt;/code&gt; と &lt;code&gt;while&lt;/code&gt; の条件の周りに括弧を必要としません。書く：</target>
        </trans-unit>
        <trans-unit id="c7d384a3039a9f94436def1f2e231fafa1ebc407" translate="yes" xml:space="preserve">
          <source>Julia enables package developers and users to document functions, types and other objects easily via a built-in documentation system since Julia 0.4.</source>
          <target state="translated">Julia 0.4 以降、パッケージ開発者やユーザは、組み込みのドキュメントシステムを介して、関数や型、その他のオブジェクトを簡単にドキュメント化できるようになりました。</target>
        </trans-unit>
        <trans-unit id="a610a30b8a22b7162af81fa68a40648223fcdceb" translate="yes" xml:space="preserve">
          <source>Julia encourages users to write their own types, which are easier to use than S3 or S4 objects in R. Julia's multiple dispatch system means that &lt;code&gt;table(x::TypeA)&lt;/code&gt; and &lt;code&gt;table(x::TypeB)&lt;/code&gt; act like R's &lt;code&gt;table.TypeA(x)&lt;/code&gt; and &lt;code&gt;table.TypeB(x)&lt;/code&gt;.</source>
          <target state="translated">Juliaは、ユーザーが独自の型を作成することを推奨しています。これは、RのS3またはS4オブジェクトよりも使いやすいです &lt;code&gt;table.TypeA(x)&lt;/code&gt; のマルチディスパッチシステムは、 &lt;code&gt;table(x::TypeA)&lt;/code&gt; と &lt;code&gt;table(x::TypeB)&lt;/code&gt; がRのtable.TypeA（ x）と &lt;code&gt;table.TypeB(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93dbc5f2b7cd97919b61b2ba139686426c401f37" translate="yes" xml:space="preserve">
          <source>Julia evaluates default values of function arguments every time the method is invoked, unlike in Python where the default values are evaluated only once when the function is defined. For example, the function &lt;code&gt;f(x=rand()) = x&lt;/code&gt; returns a new random number every time it is invoked without argument. On the other hand, the function &lt;code&gt;g(x=[1,2]) = push!(x,3)&lt;/code&gt; returns &lt;code&gt;[1,2,3]&lt;/code&gt; every time it is called as &lt;code&gt;g()&lt;/code&gt;.</source>
          <target state="translated">関数が定義されたときにデフォルト値が一度だけ評価されるPythonとは異なり、Juliaはメソッドが呼び出されるたびに関数引数のデフォルト値を評価します。たとえば、関数 &lt;code&gt;f(x=rand()) = x&lt;/code&gt; は、引数なしで呼び出されるたびに新しい乱数を返します。一方、関数 &lt;code&gt;g(x=[1,2]) = push!(x,3)&lt;/code&gt; は、 &lt;code&gt;g()&lt;/code&gt; として呼び出されるたびに &lt;code&gt;[1,2,3]&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="96712ad66b3fa51cd94fd25a53b3080e67ce2f4b" translate="yes" xml:space="preserve">
          <source>Julia features optional typing, multiple dispatch, and good performance, achieved using type inference and &lt;a href=&quot;https://en.wikipedia.org/wiki/Just-in-time_compilation&quot;&gt;just-in-time (JIT) compilation&lt;/a&gt;, implemented using &lt;a href=&quot;https://en.wikipedia.org/wiki/Low_Level_Virtual_Machine&quot;&gt;LLVM&lt;/a&gt;. It is multi-paradigm, combining features of imperative, functional, and object-oriented programming. Julia provides ease and expressiveness for high-level numerical computing, in the same way as languages such as R, MATLAB, and Python, but also supports general programming. To achieve this, Julia builds upon the lineage of mathematical programming languages, but also borrows much from popular dynamic languages, including &lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;Lisp&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Perl_(programming_language)&quot;&gt;Perl&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Python_(programming_language)&quot;&gt;Python&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Lua_(programming_language)&quot;&gt;Lua&lt;/a&gt;, and &lt;a href=&quot;https://en.wikipedia.org/wiki/Ruby_(programming_language)&quot;&gt;Ruby&lt;/a&gt;.</source>
          <target state="translated">Juliaは、型推論と&lt;a href=&quot;https://en.wikipedia.org/wiki/Just-in-time_compilation&quot;&gt;ジャストインタイム（JIT）コンパイル&lt;/a&gt;を使用して実現される、オプションの型指定、複数ディスパッチ、および優れたパフォーマンスを特徴とし、&lt;a href=&quot;https://en.wikipedia.org/wiki/Low_Level_Virtual_Machine&quot;&gt;LLVM&lt;/a&gt;を使用して実装されます。これは、命令型、関数型、およびオブジェクト指向プログラミングの機能を組み合わせたマルチパラダイムです。 Juliaは、R、MATLAB、Pythonなどの言語と同じように、高水準の数値計算を簡単かつ表現力豊かに提供しますが、一般的なプログラミングもサポートしています。これを実現するために、ジュリアは数学的プログラミング言語の系統を基に構築されていますが、&lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;Lisp&lt;/a&gt;、&lt;a href=&quot;https://en.wikipedia.org/wiki/Perl_(programming_language)&quot;&gt;Perl&lt;/a&gt;、&lt;a href=&quot;https://en.wikipedia.org/wiki/Python_(programming_language)&quot;&gt;Python&lt;/a&gt;、&lt;a href=&quot;https://en.wikipedia.org/wiki/Lua_(programming_language)&quot;&gt;Lua&lt;/a&gt;、&lt;a href=&quot;https://en.wikipedia.org/wiki/Ruby_(programming_language)&quot;&gt;Ruby&lt;/a&gt;などの一般的な動的言語からも多くを借りています。</target>
        </trans-unit>
        <trans-unit id="20fa6f6d170887fa888519e147a5de3f67149aab" translate="yes" xml:space="preserve">
          <source>Julia fully supports Unicode characters and strings. As &lt;a href=&quot;#man-characters&quot;&gt;discussed above&lt;/a&gt;, in character literals, Unicode code points can be represented using Unicode &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\U&lt;/code&gt; escape sequences, as well as all the standard C escape sequences. These can likewise be used to write string literals:</source>
          <target state="translated">JuliaはUnicode文字と文字列を完全にサポートしています。&lt;a href=&quot;#man-characters&quot;&gt;上述した&lt;/a&gt;、文字リテラルでは、Unicodeコードポイントは、Unicode使用して表すことができる &lt;code&gt;\u&lt;/code&gt; と &lt;code&gt;\U&lt;/code&gt; エスケープシーケンス、ならびにすべての標準Cエスケープシーケンスを。これらは同様に文字列リテラルを書くために使用できます：</target>
        </trans-unit>
        <trans-unit id="bc5383570d2537e5c864f51ec5fa00e7be9531d0" translate="yes" xml:space="preserve">
          <source>Julia fully supports Unicode characters and strings. As &lt;a href=&quot;#man-characters-1&quot;&gt;discussed above&lt;/a&gt;, in character literals, Unicode code points can be represented using Unicode &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\U&lt;/code&gt; escape sequences, as well as all the standard C escape sequences. These can likewise be used to write string literals:</source>
          <target state="translated">JuliaはUnicode文字と文字列を完全にサポートしています。&lt;a href=&quot;#man-characters-1&quot;&gt;上述した&lt;/a&gt;、文字リテラルでは、Unicodeコードポイントは、Unicode使用して表すことができる &lt;code&gt;\u&lt;/code&gt; と &lt;code&gt;\U&lt;/code&gt; エスケープシーケンス、ならびにすべての標準Cエスケープシーケンスを。同様に、これらを使用して文字列リテラルを書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="ddd78f6e5bc711118d9be3c491d9cc07a50a79b9" translate="yes" xml:space="preserve">
          <source>Julia function arguments follow a convention sometimes called &quot;pass-by-sharing&quot;, which means that values are not copied when they are passed to functions. Function arguments themselves act as new variable &lt;em&gt;bindings&lt;/em&gt; (new locations that can refer to values), but the values they refer to are identical to the passed values. Modifications to mutable values (such as &lt;code&gt;Array&lt;/code&gt;s) made within a function will be visible to the caller. This is the same behavior found in Scheme, most Lisps, Python, Ruby and Perl, among other dynamic languages.</source>
          <target state="translated">Julia関数の引数は、「共有渡し」と呼ばれることもある規則に従います。つまり、関数に渡されるときに値はコピーされません。関数の引数自体は新しい変数&lt;em&gt;バインディング&lt;/em&gt;（値を参照できる新しい場所）として機能しますが、それらが参照する値は渡された値と同じです。関数内で行われた変更可能な値（ &lt;code&gt;Array&lt;/code&gt; など）への変更は、呼び出し元に表示されます。これは、他の動的言語の中で、Scheme、ほとんどのLisp、Python、Ruby、Perlで見られる動作と同じです。</target>
        </trans-unit>
        <trans-unit id="f080283d31381a5962b780da17f950587890e071" translate="yes" xml:space="preserve">
          <source>Julia has Perl-compatible regular expressions (regexes), as provided by the &lt;a href=&quot;http://www.pcre.org/&quot;&gt;PCRE&lt;/a&gt; library (a description of the syntax can be found &lt;a href=&quot;http://www.pcre.org/current/doc/html/pcre2syntax.html&quot;&gt;here&lt;/a&gt;). Regular expressions are related to strings in two ways: the obvious connection is that regular expressions are used to find regular patterns in strings; the other connection is that regular expressions are themselves input as strings, which are parsed into a state machine that can be used to efficiently search for patterns in strings. In Julia, regular expressions are input using non-standard string literals prefixed with various identifiers beginning with &lt;code&gt;r&lt;/code&gt;. The most basic regular expression literal without any options turned on just uses &lt;code&gt;r&quot;...&quot;&lt;/code&gt;:</source>
          <target state="translated">Juliaには、&lt;a href=&quot;http://www.pcre.org/&quot;&gt;PCRE&lt;/a&gt;ライブラリによって提供されているように、Perl互換の正規表現（正規表現）があります（構文の説明は&lt;a href=&quot;http://www.pcre.org/current/doc/html/pcre2syntax.html&quot;&gt;こちらにあります&lt;/a&gt;）。正規表現は2つの方法で文字列に関連付けられています。明白な関係は、正規表現が文字列内の正規パターンを見つけるために使用されることです。もう1つの関係は、正規表現自体が文字列として入力され、文字列内のパターンを効率的に検索するために使用できる状態マシンに解析されることです。 Juliaでは、正規表現は、 &lt;code&gt;r&lt;/code&gt; で始まるさまざまな識別子が前に付いた非標準の文字列リテラルを使用して入力されます。オプションがオンになっていない最も基本的な正規表現リテラルは、 &lt;code&gt;r&quot;...&quot;&lt;/code&gt; 使用するだけです。</target>
        </trans-unit>
        <trans-unit id="1bf49a0edfd1fa830fafecd8986f8d037e52871d" translate="yes" xml:space="preserve">
          <source>Julia has a built-in data structure called a &lt;em&gt;tuple&lt;/em&gt; that is closely related to function arguments and return values. A tuple is a fixed-length container that can hold any values, but cannot be modified (it is &lt;em&gt;immutable&lt;/em&gt;). Tuples are constructed with commas and parentheses, and can be accessed via indexing:</source>
          <target state="translated">Juliaには、&lt;em&gt;タプル&lt;/em&gt;と呼ばれる組み込みのデータ構造があり、関数の引数と戻り値に密接に関連しています。タプルは、任意の値を保持できる固定長のコンテナーですが、変更することはできません（&lt;em&gt;不変です&lt;/em&gt;）。タプルはコンマと括弧で構成され、インデックスを介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="c552e8e0854f7810a14a1b85cee7a089274fe437" translate="yes" xml:space="preserve">
          <source>Julia has a rational number type to represent exact ratios of integers. Rationals are constructed using the &lt;a href=&quot;../../base/math/index#Base.://&quot;&gt;&lt;code&gt;//&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">ジュリアには、整数の正確な比率を表す有理数タイプがあります。有理数は&lt;a href=&quot;../../base/math/index#Base.://&quot;&gt; &lt;code&gt;//&lt;/code&gt; &lt;/a&gt;演算子を使用して構築されます。</target>
        </trans-unit>
        <trans-unit id="f16da71d7eefd561befb9a12573735daa1e67ea2" translate="yes" xml:space="preserve">
          <source>Julia has a special &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;dot syntax&lt;/a&gt; that converts any scalar function into a &quot;vectorized&quot; function call, and any operator into a &quot;vectorized&quot; operator, with the special property that nested &quot;dot calls&quot; are &lt;em&gt;fusing&lt;/em&gt;: they are combined at the syntax level into a single loop, without allocating temporary arrays. If you use &lt;code&gt;.=&lt;/code&gt; and similar assignment operators, the result can also be stored in-place in a pre-allocated array (see above).</source>
          <target state="translated">Juliaには、スカラー関数を「ベクトル化された」関数呼び出しに変換する特別な&lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;ドット構文&lt;/a&gt;と、ネストされた「ドット呼び出し」が&lt;em&gt;融合&lt;/em&gt;している特別なプロパティを持つ「ベクトル化された」演算子があります。これらは構文レベルで次のように結合されます。一時的な配列を割り当てない単一のループ。 &lt;code&gt;.=&lt;/code&gt; および同様の代入演算子を使用する場合、結果は事前に割り当てられた配列にインプレースで格納することもできます（上記を参照）。</target>
        </trans-unit>
        <trans-unit id="b40bd35bfba54a15cc9852aeface053edb4835d0" translate="yes" xml:space="preserve">
          <source>Julia has a special &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot syntax&lt;/a&gt; that converts any scalar function into a &quot;vectorized&quot; function call, and any operator into a &quot;vectorized&quot; operator, with the special property that nested &quot;dot calls&quot; are &lt;em&gt;fusing&lt;/em&gt;: they are combined at the syntax level into a single loop, without allocating temporary arrays. If you use &lt;code&gt;.=&lt;/code&gt; and similar assignment operators, the result can also be stored in-place in a pre-allocated array (see above).</source>
          <target state="translated">Juliaには、スカラー関数を「ベクトル化された」関数呼び出しに変換する特別な&lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;ドット構文&lt;/a&gt;と、演算子が「ベクトル化された」演算子に変換される特別なプロパティがあり、ネストされた「ドット呼び出し」が&lt;em&gt;融合し&lt;/em&gt;ます。これらは構文レベルで結合されます。一時配列を割り当てずに、単一のループ。 &lt;code&gt;.=&lt;/code&gt; および同様の代入演算子を使用する場合、結果は事前に割り当てられた配列（上記を参照）にインプレースで格納することもできます。</target>
        </trans-unit>
        <trans-unit id="d6c4ab07a2249226dfaeff8c414c6f4ecccc5db7" translate="yes" xml:space="preserve">
          <source>Julia has a specialized version of &lt;code&gt;ntuple&lt;/code&gt; that accepts a &lt;code&gt;Val{::Int}&lt;/code&gt; instance as the second parameter; by passing &lt;code&gt;N&lt;/code&gt; as a type-parameter, you make its &quot;value&quot; known to the compiler. Consequently, this version of &lt;code&gt;array3&lt;/code&gt; allows the compiler to predict the return type.</source>
          <target state="translated">Juliaには、2番目のパラメーターとして &lt;code&gt;Val{::Int}&lt;/code&gt; インスタンスを受け入れる &lt;code&gt;ntuple&lt;/code&gt; の特別バージョンがあります。型パラメーターとして &lt;code&gt;N&lt;/code&gt; を渡すことにより、その「値」をコンパイラーに認識させます。したがって、このバージョンの &lt;code&gt;array3&lt;/code&gt; を使用すると、コンパイラは戻り値の型を予測できます。</target>
        </trans-unit>
        <trans-unit id="3dbaaf5104fbb919890d9bf95a666a5ce54dc8a0" translate="yes" xml:space="preserve">
          <source>Julia has a system for promoting arguments of mathematical operators to a common type, which has been mentioned in various other sections, including &lt;a href=&quot;../integers-and-floating-point-numbers/index#Integers-and-Floating-Point-Numbers&quot;&gt;Integers and Floating-Point Numbers&lt;/a&gt;, &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt;, &lt;a href=&quot;../types/index#man-types&quot;&gt;Types&lt;/a&gt;, and &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt;. In this section, we explain how this promotion system works, as well as how to extend it to new types and apply it to functions besides built-in mathematical operators. Traditionally, programming languages fall into two camps with respect to promotion of arithmetic arguments:</source>
          <target state="translated">Juliaには、数学演算子の引数を共通の型に昇格させるシステムがあります。これは、&lt;a href=&quot;../integers-and-floating-point-numbers/index#Integers-and-Floating-Point-Numbers&quot;&gt;整数と浮動小数点数&lt;/a&gt;、&lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions&quot;&gt;数学演算と初等関数&lt;/a&gt;、&lt;a href=&quot;../types/index#man-types&quot;&gt;型&lt;/a&gt;、&lt;a href=&quot;../methods/index#Methods&quot;&gt;メソッド&lt;/a&gt;など、他のさまざまなセクションで説明されています。このセクションでは、このプロモーションシステムがどのように機能するか、および新しいタイプに拡張して、組み込みの数学演算子以外の関数に適用する方法について説明します。伝統的に、プログラミング言語は、算術引数の促進に関して2つの陣営に分類されます。</target>
        </trans-unit>
        <trans-unit id="dd0467e099e9e6d5ba4caf88a327947c41a492c3" translate="yes" xml:space="preserve">
          <source>Julia has a system for promoting arguments of mathematical operators to a common type, which has been mentioned in various other sections, including &lt;a href=&quot;../integers-and-floating-point-numbers/index#Integers-and-Floating-Point-Numbers-1&quot;&gt;Integers and Floating-Point Numbers&lt;/a&gt;, &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt;, &lt;a href=&quot;../types/index#man-types-1&quot;&gt;Types&lt;/a&gt;, and &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;. In this section, we explain how this promotion system works, as well as how to extend it to new types and apply it to functions besides built-in mathematical operators. Traditionally, programming languages fall into two camps with respect to promotion of arithmetic arguments:</source>
          <target state="translated">Juliaには、数学演算子の引数を共通の型にプロモートするシステムがあります。これは、&lt;a href=&quot;../integers-and-floating-point-numbers/index#Integers-and-Floating-Point-Numbers-1&quot;&gt;整数と浮動小数点数&lt;/a&gt;、&lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;数学演算と初等関数&lt;/a&gt;、&lt;a href=&quot;../types/index#man-types-1&quot;&gt;タイプ&lt;/a&gt;、&lt;a href=&quot;../methods/index#Methods-1&quot;&gt;メソッド&lt;/a&gt;など、他のさまざまなセクションで説明されています。このセクションでは、この昇格システムがどのように機能するか、およびそれを新しいタイプに拡張して、組み込みの算術演算子以外の関数に適用する方法について説明します。伝統的に、プログラミング言語は算術引数の促進に関して2つの陣営に分類されます。</target>
        </trans-unit>
        <trans-unit id="3580c0f9206e567ece3500a7602b2f938ef0cdc5" translate="yes" xml:space="preserve">
          <source>Julia has an enumeration type, expressed using the macro &lt;code&gt;@enum(name, value1, value2, ...)&lt;/code&gt; For example: &lt;code&gt;@enum(Fruit, banana=1, apple, pear)&lt;/code&gt;</source>
          <target state="translated">Juliaには列挙型があり、マクロ &lt;code&gt;@enum(name, value1, value2, ...)&lt;/code&gt; を使用して表現されます。例： &lt;code&gt;@enum(Fruit, banana=1, apple, pear)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e22281e2e9ddb304102a3e2035cc1b7d70261e86" translate="yes" xml:space="preserve">
          <source>Julia has an extensive, flexible API for sorting and interacting with already-sorted arrays of values. By default, Julia picks reasonable algorithms and sorts in standard ascending order:</source>
          <target state="translated">Juliaには、既にソートされた値の配列をソートして対話するための広範で柔軟なAPIが用意されています。デフォルトでは、Julia は合理的なアルゴリズムを選択し、標準的な昇順でソートします。</target>
        </trans-unit>
        <trans-unit id="bf9ed794914c3a1a76c39f0be8423b02c7aa0fa9" translate="yes" xml:space="preserve">
          <source>Julia has no line continuation syntax: if, at the end of a line, the input so far is a complete expression, it is considered done; otherwise the input continues. One way to force an expression to continue is to wrap it in parentheses.</source>
          <target state="translated">ジュリアには行の続きの構文がありません:行の終わりに、これまでの入力が完全な式であれば、それは完了したとみなされ、そうでなければ入力は続きます。式を強制的に継続させる一つの方法は、式を括弧で囲むことです。</target>
        </trans-unit>
        <trans-unit id="6e3f85fe865aed948db80d8506da1145de6fdbbe" translate="yes" xml:space="preserve">
          <source>Julia has several functions that can mutate their arguments. For example, it has both &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ジュリアには、引数を変更できるいくつかの関数があります。たとえば、&lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt;両方があります。。</target>
        </trans-unit>
        <trans-unit id="dced25e0f1eb19647f27c26102392f9de718e8bc" translate="yes" xml:space="preserve">
          <source>Julia has support for sparse vectors and &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix&quot;&gt;sparse matrices&lt;/a&gt; in the &lt;code&gt;SparseArrays&lt;/code&gt; stdlib module. Sparse arrays are arrays that contain enough zeros that storing them in a special data structure leads to savings in space and execution time, compared to dense arrays.</source>
          <target state="translated">Juliaは &lt;code&gt;SparseArrays&lt;/code&gt; stdlibモジュールでスパースベクトルと&lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix&quot;&gt;スパース行列&lt;/a&gt;をサポートしています。疎配列は、特殊なデータ構造にそれらを格納するのに十分なゼロを含む配列であり、密配列と比較して、スペースと実行時間を節約できます。</target>
        </trans-unit>
        <trans-unit id="7e110deec010cf13200f416e320f962b03651cd3" translate="yes" xml:space="preserve">
          <source>Julia has true one-dimensional arrays. Column vectors are of size &lt;code&gt;N&lt;/code&gt;, not &lt;code&gt;Nx1&lt;/code&gt;. For example, &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt;&lt;code&gt;rand(N)&lt;/code&gt;&lt;/a&gt; makes a 1-dimensional array.</source>
          <target state="translated">ジュリアには真の1次元配列があります。列ベクトルは &lt;code&gt;Nx1&lt;/code&gt; ではなく、サイズ &lt;code&gt;N&lt;/code&gt; です。たとえば、&lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt; &lt;code&gt;rand(N)&lt;/code&gt; &lt;/a&gt;は1次元配列を作成します。</target>
        </trans-unit>
        <trans-unit id="0821ee6b098b6e9c3f3f70ea62ba30df9ae8eca8" translate="yes" xml:space="preserve">
          <source>Julia has two mechanisms for loading code:</source>
          <target state="translated">Juliaにはコードをロードするための2つのメカニズムがあります。</target>
        </trans-unit>
        <trans-unit id="c7c1de145d34e5e8002d957a023c35b25d8ff0be" translate="yes" xml:space="preserve">
          <source>Julia has two right-shift operators, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; performs an arithmetic shift, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; always performs a logical shift, unlike C/C++, where the meaning of &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; depends on the type of the value being shifted.</source>
          <target state="translated">Juliaには、2つの右シフト演算子 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; があります。 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 行う算術シフトは、 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; いつもの意味C / C ++とは異なり、論理シフトを実行 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; がシフトされる値のタイプに依存します。</target>
        </trans-unit>
        <trans-unit id="a82ef00db4da7adcbac13bd1f8a38ec016519663" translate="yes" xml:space="preserve">
          <source>Julia identifiers and code excerpts should always appear between backticks &lt;code&gt;`&lt;/code&gt; to enable highlighting. Equations in the LaTeX syntax can be inserted between double backticks &lt;code&gt;``&lt;/code&gt;. Use Unicode characters rather than their LaTeX escape sequence, i.e. &lt;code&gt;``&amp;alpha; = 1``&lt;/code&gt; rather than &lt;code&gt;``\\alpha = 1``&lt;/code&gt;.</source>
          <target state="translated">ジュリア識別子とコードの抜粋は、常にバッククォートの間に表示されます &lt;code&gt;`&lt;/code&gt; ハイライト表示可能にします。LaTeX構文の方程式は、二重バッククォートの間に挿入できます &lt;code&gt;``&lt;/code&gt; 。LaTeXエスケープシーケンスではなくUnicode文字を使用します。つまり、 &lt;code&gt;``\\alpha = 1``&lt;/code&gt; ではなく &lt;code&gt;``&amp;alpha; = 1``&lt;/code&gt; 」です。</target>
        </trans-unit>
        <trans-unit id="ad9eda654d6c5b8e4f3d947e9256ba07cba9012f" translate="yes" xml:space="preserve">
          <source>Julia includes predefined types for both complex and rational numbers, and supports all the standard &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt; on them. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;Conversion and Promotion&lt;/a&gt; are defined so that operations on any combination of predefined numeric types, whether primitive or composite, behave as expected.</source>
          <target state="translated">Juliaには、複素数と有理数の両方に事前定義された型が含まれており、それらのすべての標準的な&lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions&quot;&gt;数学演算と初等関数&lt;/a&gt;をサポートしています。&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;変換と昇格&lt;/a&gt;は、プリミティブか合成かを問わず、事前定義された数値タイプの任意の組み合わせに対する操作が期待どおりに動作するように定義されています。</target>
        </trans-unit>
        <trans-unit id="556d3efaca190f2ea064a6e9ec15d293042ee9a4" translate="yes" xml:space="preserve">
          <source>Julia includes predefined types for both complex and rational numbers, and supports all the standard &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt; on them. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt; are defined so that operations on any combination of predefined numeric types, whether primitive or composite, behave as expected.</source>
          <target state="translated">Juliaには、複素数と有理数の両方に事前定義された型が含まれており、それらの標準的なすべての&lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;数学演算と基本関数&lt;/a&gt;をサポートしています。&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;変換とプロモーション&lt;/a&gt;は、プリミティブかコンポジットかにかかわらず、事前定義された数値タイプの任意の組み合わせに対する操作が期待どおりに動作するように定義されています。</target>
        </trans-unit>
        <trans-unit id="7ddd4e3aafc825251162512ccf2a33928bb02903" translate="yes" xml:space="preserve">
          <source>Julia installation is straightforward, whether using precompiled binaries or compiling from source. Download and install Julia by following the instructions at &lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https://julialang.org/downloads/&lt;/a&gt;.</source>
          <target state="translated">Juliaのインストールは、プリコンパイルされたバイナリを使用しているか、ソースからコンパイルしているかに関係なく、簡単です。&lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https://julialang.org/downloads/&lt;/a&gt;の指示に従ってJuliaをダウンロードしてインストールします。</target>
        </trans-unit>
        <trans-unit id="ebd85d8192dfa3106e5516cbab7ad06e8387fb26" translate="yes" xml:space="preserve">
          <source>Julia is careful to distinguish scalars, vectors and matrices. In R, &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;c(1)&lt;/code&gt; are the same. In Julia, they cannot be used interchangeably.</source>
          <target state="translated">ジュリアはスカラー、ベクトル、行列を注意深く区別しています。Rでは、 &lt;code&gt;1&lt;/code&gt; と &lt;code&gt;c(1)&lt;/code&gt; は同じです。ジュリアでは、それらを交換して使用することはできません。</target>
        </trans-unit>
        <trans-unit id="b86e5dd8d3107ffdd2a0b40698efdff29052007c" translate="yes" xml:space="preserve">
          <source>Julia is eagerly evaluated and does not support R-style lazy evaluation. For most users, this means that there are very few unquoted expressions or column names.</source>
          <target state="translated">Julia は熱心に評価され、R スタイルの遅延評価をサポートしていません。ほとんどのユーザにとっては、これは引用符で囲まれていない式やカラム名が非常に少ないことを意味します。</target>
        </trans-unit>
        <trans-unit id="3107ebb99f64b1456a558b1a35edcbfee43840dd" translate="yes" xml:space="preserve">
          <source>Julia is under rapid development and has an extensive test suite to verify functionality across multiple platforms. If you build Julia from source, you can run this test suite with &lt;code&gt;make test&lt;/code&gt;. In a binary install, you can run the test suite using &lt;code&gt;Base.runtests()&lt;/code&gt;.</source>
          <target state="translated">Juliaは急速に開発中であり、複数のプラットフォーム間で機能を検証するための広範なテストスイートを備えています。ソースからJuliaをビルドする場合、このテストスイートを &lt;code&gt;make test&lt;/code&gt; で実行できます。バイナリインストールでは、 &lt;code&gt;Base.runtests()&lt;/code&gt; を使用してテストスイートを実行できます。</target>
        </trans-unit>
        <trans-unit id="9746bea5d9fab2c69edf57da506dab8c4cb797c1" translate="yes" xml:space="preserve">
          <source>Julia lacks the equivalent of R's &lt;code&gt;assign&lt;/code&gt; or &lt;code&gt;get&lt;/code&gt;.</source>
          <target state="translated">Juliaには、Rの &lt;code&gt;assign&lt;/code&gt; または &lt;code&gt;get&lt;/code&gt; に相当するものがありません。</target>
        </trans-unit>
        <trans-unit id="b0362643e3d8faddbbdc08525668acd4db05eb64" translate="yes" xml:space="preserve">
          <source>Julia macros operate on parsed expressions, rather than the text of the program, which allows them to perform sophisticated transformations of Julia code. Macro names start with the &lt;code&gt;@&lt;/code&gt; character, and have both a function-like syntax, &lt;code&gt;@mymacro(arg1, arg2, arg3)&lt;/code&gt;, and a statement-like syntax, &lt;code&gt;@mymacro arg1 arg2 arg3&lt;/code&gt;. The forms are interchangeable; the function-like form is particularly useful if the macro appears within another expression, and is often clearest. The statement-like form is often used to annotate blocks, as in the distributed &lt;code&gt;for&lt;/code&gt; construct: &lt;code&gt;@distributed for i in 1:n; #= body =#; end&lt;/code&gt;. Where the end of the macro construct may be unclear, use the function-like form.</source>
          <target state="translated">Juliaマクロは、プログラムのテキストではなく、解析された式を操作するため、Juliaコードの高度な変換を実行できます。マクロ名は &lt;code&gt;@&lt;/code&gt; 文字で始まり、関数のような構文 &lt;code&gt;@mymacro(arg1, arg2, arg3)&lt;/code&gt; とステートメントのような構文 &lt;code&gt;@mymacro arg1 arg2 arg3&lt;/code&gt; の両方を持っています。フォームは交換可能です。関数のような形式は、マクロが別の式内に出現する場合に特に役立ち、多くの場合最も明確です。ステートメントのような形式は、distributed &lt;code&gt;for&lt;/code&gt; 構文のように、ブロックに注釈を付けるためによく使用されます。 &lt;code&gt;@distributed for i in 1:n; #= body =#; end&lt;/code&gt; 。マクロ構造の終わりが不明確な場合は、関数のような形式を使用してください。</target>
        </trans-unit>
        <trans-unit id="7722324abb1e33c9620fc5bb1dbd294982f5257b" translate="yes" xml:space="preserve">
          <source>Julia performs matrix transposition using the &lt;code&gt;transpose&lt;/code&gt; function and conjugated transposition using the &lt;code&gt;'&lt;/code&gt; operator or the &lt;code&gt;adjoint&lt;/code&gt; function. Julia's &lt;code&gt;transpose(A)&lt;/code&gt; is therefore equivalent to R's &lt;code&gt;t(A)&lt;/code&gt;. Additionally a non-recursive transpose in Julia is provided by the &lt;code&gt;permutedims&lt;/code&gt; function.</source>
          <target state="translated">Juliaは、 &lt;code&gt;transpose&lt;/code&gt; 関数を使用して行列転置を実行し、 &lt;code&gt;'&lt;/code&gt; 演算子または &lt;code&gt;adjoint&lt;/code&gt; 関数を使用して共役転置を実行します。したがって、Juliaの &lt;code&gt;transpose(A)&lt;/code&gt; は、Rの &lt;code&gt;t(A)&lt;/code&gt; と同等です。さらに、Juliaの非再帰的転置は、 &lt;code&gt;permutedims&lt;/code&gt; 関数によって提供されます。</target>
        </trans-unit>
        <trans-unit id="52ca89425115cf081b45ea4b026826f1b8b7932f" translate="yes" xml:space="preserve">
          <source>Julia provides &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt;, which gives the distance between &lt;code&gt;1.0&lt;/code&gt; and the next larger representable floating-point value:</source>
          <target state="translated">Juliaは&lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; を&lt;/a&gt;提供します。これは、 &lt;code&gt;1.0&lt;/code&gt; と次に大きい表現可能な浮動小数点値の間の距離を示します。</target>
        </trans-unit>
        <trans-unit id="b5151abe259ad1efc62c73fed3cdaac381488d9a" translate="yes" xml:space="preserve">
          <source>Julia provides a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; mechanism for solving this problem. A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is a waitable first-in first-out queue which can have multiple tasks reading from and writing to it.</source>
          <target state="translated">ジュリアは、この問題を解決するための&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;メカニズムを提供します。A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;待機可能な先入れ先出し待ち行列複数のタスクから読み取り、それに書き込むことができたです。</target>
        </trans-unit>
        <trans-unit id="476c4c45db4a5f4592324ce839944c2c37cd8d0a" translate="yes" xml:space="preserve">
          <source>Julia provides a broad range of primitive numeric types, and a full complement of arithmetic and bitwise operators as well as standard mathematical functions are defined over them. These map directly onto numeric types and operations that are natively supported on modern computers, thus allowing Julia to take full advantage of computational resources. Additionally, Julia provides software support for &lt;a href=&quot;#Arbitrary-Precision-Arithmetic&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt;, which can handle operations on numeric values that cannot be represented effectively in native hardware representations, but at the cost of relatively slower performance.</source>
          <target state="translated">Juliaは、幅広いプリミティブ数値タイプを提供し、算術演算子とビット演算子の完全な補完、および標準の数学関数がそれらに対して定義されています。これらは、最新のコンピューターでネイティブにサポートされている数値の型と操作に直接マップされるため、Juliaは計算リソースを最大限に活用できます。さらに、Juliaは&lt;a href=&quot;#Arbitrary-Precision-Arithmetic&quot;&gt;Arbitrary Precision Arithmeticの&lt;/a&gt;ソフトウェアサポートを提供します。これは、ネイティブハードウェア表現では効果的に表現できない数値の操作を処理できますが、パフォーマンスは比較的遅くなります。</target>
        </trans-unit>
        <trans-unit id="8d6a50d7fd1b9d32a07f2f0f7b72bc0c75328556" translate="yes" xml:space="preserve">
          <source>Julia provides a broad range of primitive numeric types, and a full complement of arithmetic and bitwise operators as well as standard mathematical functions are defined over them. These map directly onto numeric types and operations that are natively supported on modern computers, thus allowing Julia to take full advantage of computational resources. Additionally, Julia provides software support for &lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt;, which can handle operations on numeric values that cannot be represented effectively in native hardware representations, but at the cost of relatively slower performance.</source>
          <target state="translated">Juliaは、幅広いプリミティブ数値型を提供し、算術演算子とビット単位演算子の完全な補完機能、および標準の数学関数がそれらに対して定義されています。これらは、現代のコンピューターでネイティブにサポートされている数値型と演算に直接マッピングされるため、Juliaは計算リソースを最大限に活用できます。さらに、Juliaは&lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;Arbitrary Precision Arithmeticの&lt;/a&gt;ソフトウェアサポートを提供します。これにより、ネイティブのハードウェア表現では効果的に表現できない数値の演算を処理できますが、パフォーマンスは比較的低下します。</target>
        </trans-unit>
        <trans-unit id="5e01948cafe564bc35cc3886e5615297521aba0b" translate="yes" xml:space="preserve">
          <source>Julia provides a complete collection of basic arithmetic and bitwise operators across all of its numeric primitive types, as well as providing portable, efficient implementations of a comprehensive collection of standard mathematical functions.</source>
          <target state="translated">Juliaは基本的な算術演算子とビット演算子の完全なコレクションを提供し、すべての数値プリミティブ型を網羅しています。</target>
        </trans-unit>
        <trans-unit id="123ae94e81e1f4b6a65e379d812783d382dbfd58" translate="yes" xml:space="preserve">
          <source>Julia provides a comprehensive collection of mathematical functions and operators. These mathematical operations are defined over as broad a class of numerical values as permit sensible definitions, including integers, floating-point numbers, rationals, and complex numbers, wherever such definitions make sense.</source>
          <target state="translated">Juliaは数学関数と演算子の包括的なコレクションを提供しています.これらの数学的操作は,整数,浮動小数点数,合理性,複素数など,理にかなった定義が可能な範囲で,数値の広いクラスにわたって定義されています.</target>
        </trans-unit>
        <trans-unit id="07cfc6f69cd91f9494ead12f841604f628160c20" translate="yes" xml:space="preserve">
          <source>Julia provides a reserved word &lt;code&gt;do&lt;/code&gt; for rewriting this code more clearly:</source>
          <target state="translated">Juliaは、このコードをより明確に書き換えるための予約語 &lt;code&gt;do&lt;/code&gt; を提供しています。</target>
        </trans-unit>
        <trans-unit id="657c78188298a00e823c4644aeb3647f8f14a312" translate="yes" xml:space="preserve">
          <source>Julia provides a rich interface to deal with streaming I/O objects such as terminals, pipes and TCP sockets. This interface, though asynchronous at the system level, is presented in a synchronous manner to the programmer and it is usually unnecessary to think about the underlying asynchronous operation. This is achieved by making heavy use of Julia cooperative threading (&lt;a href=&quot;../control-flow/index#man-tasks&quot;&gt;coroutine&lt;/a&gt;) functionality.</source>
          <target state="translated">Juliaは、端末、パイプ、TCPソケットなどのストリーミングI / Oオブジェクトを処理するための豊富なインターフェイスを提供します。このインターフェースは、システムレベルでは非同期ですが、プログラマーに同期的に提示され、通常、基礎となる非同期操作について考える必要はありません。これは、Juliaの協調スレッド（&lt;a href=&quot;../control-flow/index#man-tasks&quot;&gt;コルーチン&lt;/a&gt;）機能を多用することで実現されます。</target>
        </trans-unit>
        <trans-unit id="eea9a879394b78dc7fcabf301d30239602afa073" translate="yes" xml:space="preserve">
          <source>Julia provides a rich interface to deal with streaming I/O objects such as terminals, pipes and TCP sockets. This interface, though asynchronous at the system level, is presented in a synchronous manner to the programmer and it is usually unnecessary to think about the underlying asynchronous operation. This is achieved by making heavy use of Julia cooperative threading (&lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;coroutine&lt;/a&gt;) functionality.</source>
          <target state="translated">Juliaは、ターミナル、パイプ、TCPソケットなどのストリーミングI / Oオブジェクトを処理するための豊富なインターフェイスを提供します。このインターフェイスは、システムレベルでは非同期ですが、同期的にプログラマに提示されるため、通常、基になる非同期操作について考える必要はありません。これは、Juliaの協調スレッド（&lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;コルーチン&lt;/a&gt;）機能を多用することで実現されます。</target>
        </trans-unit>
        <trans-unit id="abe3cae0b0fe31f45bb29933297244a39702e5dd" translate="yes" xml:space="preserve">
          <source>Julia provides a variety of control flow constructs:</source>
          <target state="translated">Juliaは様々な制御フロー構造を提供しています。</target>
        </trans-unit>
        <trans-unit id="379525ee528141070933df39d7ce42ca05dd4bf0" translate="yes" xml:space="preserve">
          <source>Julia provides additional functions to test numbers for special values, which can be useful in situations like hash key comparisons:</source>
          <target state="translated">Juliaは数値の特殊な値をテストするための関数を追加で提供しており、ハッシュキーの比較のような状況で有用です。</target>
        </trans-unit>
        <trans-unit id="e0540cb6db7126d29223e3d70501bf3d70244816" translate="yes" xml:space="preserve">
          <source>Julia provides an extremely flexible system for naming variables. Variable names are case-sensitive, and have no semantic meaning (that is, the language will not treat variables differently based on their names).</source>
          <target state="translated">Julia は変数の命名に非常に柔軟なシステムを提供しています。変数名は大文字と小文字を区別し、意味的な意味を持ちません (つまり、言語はその名前に基づいて変数を異なる扱いをしません)。</target>
        </trans-unit>
        <trans-unit id="eab744df916b515fec425ab1cfaf69348d24b932" translate="yes" xml:space="preserve">
          <source>Julia provides built-in, efficient functions to test for oddness and evenness called &lt;a href=&quot;../../base/numbers/index#Base.iseven&quot;&gt;&lt;code&gt;iseven&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Base.isodd&quot;&gt;&lt;code&gt;isodd&lt;/code&gt;&lt;/a&gt; so the above definitions should only be considered to be examples of scope, not efficient design.</source>
          <target state="translated">Juliaは、&lt;a href=&quot;../../base/numbers/index#Base.iseven&quot;&gt; &lt;code&gt;iseven&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/numbers/index#Base.isodd&quot;&gt; &lt;code&gt;isodd&lt;/code&gt; &lt;/a&gt;と呼ばれる奇数と偶数をテストするための組み込みの効率的な関数を提供しているため、上記の定義はスコープの例にすぎず、効率的な設計ではありません。</target>
        </trans-unit>
        <trans-unit id="378329d878ac43129f252ba96bb3ab40b65f2250" translate="yes" xml:space="preserve">
          <source>Julia provides functions which return literal 0 and 1 corresponding to a specified type or the type of a given variable.</source>
          <target state="translated">Juliaは、指定された型や変数の型に対応するリテラル0と1を返す関数を提供しています。</target>
        </trans-unit>
        <trans-unit id="affb7609b4adcfecba8a7c2be6b8ababed17f3bf" translate="yes" xml:space="preserve">
          <source>Julia provides support for representing missing values in the statistical sense, that is for situations where no value is available for a variable in an observation, but a valid value theoretically exists. Missing values are represented via the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object, which is the singleton instance of the type &lt;a href=&quot;../../base/base/index#Base.Missing&quot;&gt;&lt;code&gt;Missing&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;missing&lt;/code&gt; is equivalent to &lt;a href=&quot;https://en.wikipedia.org/wiki/NULL_(SQL)&quot;&gt;&lt;code&gt;NULL&lt;/code&gt; in SQL&lt;/a&gt; and &lt;a href=&quot;https://cran.r-project.org/doc/manuals/r-release/R-lang.html#NA-handling&quot;&gt;&lt;code&gt;NA&lt;/code&gt; in R&lt;/a&gt;, and behaves like them in most situations.</source>
          <target state="translated">Juliaは、統計的な意味で欠損値を表すためのサポートを提供します。つまり、観測値の変数に使用できる値はないが、理論的には有効な値が存在する場合です。欠落した値は、&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;オブジェクトを介して表されます。これは、タイプ&lt;a href=&quot;../../base/base/index#Base.Missing&quot;&gt; &lt;code&gt;Missing&lt;/code&gt; の&lt;/a&gt;シングルトンインスタンスです。 &lt;code&gt;missing&lt;/code&gt; は&lt;a href=&quot;https://en.wikipedia.org/wiki/NULL_(SQL)&quot;&gt;SQLの&lt;/a&gt; &lt;code&gt;NULL&lt;/code&gt; および&lt;a href=&quot;https://cran.r-project.org/doc/manuals/r-release/R-lang.html#NA-handling&quot;&gt;Rの&lt;/a&gt; &lt;code&gt;NA&lt;/code&gt; と同等であり、ほとんどの状況でそれらのように動作します。</target>
        </trans-unit>
        <trans-unit id="105b1a0ce6d2b2d8bfa2faba37832a7982f4eb0d" translate="yes" xml:space="preserve">
          <source>Julia provides tuples and real hash tables, but not R-style lists. When returning multiple items, you should typically use a tuple or a named tuple: instead of &lt;code&gt;list(a = 1, b = 2)&lt;/code&gt;, use &lt;code&gt;(1, 2)&lt;/code&gt; or &lt;code&gt;(a=1, b=2)&lt;/code&gt;.</source>
          <target state="translated">Juliaはタプルと実際のハッシュテーブルを提供しますが、Rスタイルのリストは提供しません。複数のアイテムを返すとき、あなたは一般的に、タプルまたは名前付きタプルを使用する必要があります。代わりの &lt;code&gt;list(a = 1, b = 2)&lt;/code&gt; 、使用 &lt;code&gt;(1, 2)&lt;/code&gt; または &lt;code&gt;(a=1, b=2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12d6b550dc7735e370a3f8c010496abe63394b14" translate="yes" xml:space="preserve">
          <source>Julia provides two in-built cluster managers:</source>
          <target state="translated">Juliaには2つのクラスタマネージャが内蔵されています。</target>
        </trans-unit>
        <trans-unit id="46d26e39331065ec318009a2e11c1e691fbfaee6" translate="yes" xml:space="preserve">
          <source>Julia requires &lt;code&gt;end&lt;/code&gt; for indexing until the last element. &lt;code&gt;x[1:]&lt;/code&gt; in Python is equivalent to &lt;code&gt;x[2:end]&lt;/code&gt; in Julia.</source>
          <target state="translated">Juliaは、最後の要素までインデックス作成を &lt;code&gt;end&lt;/code&gt; する必要があります。Pythonの &lt;code&gt;x[1:]&lt;/code&gt; は、Juliaの &lt;code&gt;x[2:end]&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="c65c2e80d135867ac3b507bcd217f7ad2507c745" translate="yes" xml:space="preserve">
          <source>Julia requires &lt;code&gt;end&lt;/code&gt; to end a block. Unlike Python, Julia has no &lt;code&gt;pass&lt;/code&gt; keyword.</source>
          <target state="translated">ジュリアはブロックを終了するために &lt;code&gt;end&lt;/code&gt; を必要とします。Pythonとは異なり、Juliaには &lt;code&gt;pass&lt;/code&gt; キーワードがありません。</target>
        </trans-unit>
        <trans-unit id="42da913aac127180e179863fc35f1ca348a1d911" translate="yes" xml:space="preserve">
          <source>Julia should load our new code. Let's test it:</source>
          <target state="translated">ジュリアは新しいコードを ロードしてくれるはずだ テストしてみよう</target>
        </trans-unit>
        <trans-unit id="50af488570ea82992b042e6982e9d5b39f404c93" translate="yes" xml:space="preserve">
          <source>Julia structures may have exactly one abstract supertype, whereas Python classes can inherit from one or more (abstract or concrete) superclasses.</source>
          <target state="translated">Juliaの構造体は1つの抽象スーパータイプを正確に持っているかもしれませんが、Pythonのクラスは1つ以上の(抽象的または具象的な)スーパークラスを継承することができます。</target>
        </trans-unit>
        <trans-unit id="b7c7299bbee239f4f34ffd5f256e5fa27242ff3f" translate="yes" xml:space="preserve">
          <source>Julia supports accessing and modifying values &lt;em&gt;atomically&lt;/em&gt;, that is, in a thread-safe way to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition&quot;&gt;race conditions&lt;/a&gt;. A value (which must be of a primitive type) can be wrapped as &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.Atomic&quot;&gt;&lt;code&gt;Threads.Atomic&lt;/code&gt;&lt;/a&gt; to indicate it must be accessed in this way. Here we can see an example:</source>
          <target state="translated">Julia は、&lt;em&gt;アトミックに&lt;/em&gt;、つまり&lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition&quot;&gt;競合状態&lt;/a&gt;を回避するためのスレッドセーフな方法で、値へのアクセスと変更をサポートしています。値（プリミティブ型である必要があります）は、この方法でアクセスする必要があることを示すために&lt;a href=&quot;../../base/multi-threading/index#Base.Threads.Atomic&quot;&gt; &lt;code&gt;Threads.Atomic&lt;/code&gt; &lt;/a&gt;としてラップできます。ここで例を見ることができます：</target>
        </trans-unit>
        <trans-unit id="b32a099891e5d6d1de5f4e3ebb7913c9c9d83a6a" translate="yes" xml:space="preserve">
          <source>Julia supports federated package management, which means that multiple independent parties can maintain both public and private packages and registries of packages, and that projects can depend on a mix of public and private packages from different registries. Packages from various registries are installed and managed using a common set of tools and workflows. The &lt;code&gt;Pkg&lt;/code&gt; package manager that ships with Julia lets you install and manage your projects' dependencies. It assists in creating and manipulating project files (which describe what other projects that your project depends on), and manifest files (which snapshot exact versions of your project's complete dependency graph).</source>
          <target state="translated">Juliaはフェデレーションパッケージ管理をサポートしています。つまり、複数の独立した当事者がパブリックパッケージとプライベートパッケージの両方とパッケージのレジストリを維持でき、プロジェクトは異なるレジストリのパブリックパッケージとプライベートパッケージの組み合わせに依存できるということです。さまざまなレジストリからのパッケージは、共通のツールとワークフローのセットを使用してインストールおよび管理されます。Juliaに同梱されている &lt;code&gt;Pkg&lt;/code&gt; パッケージマネージャーを使用すると、プロジェクトの依存関係をインストールおよび管理できます。プロジェクトファイル（プロジェクトが依存する他のプロジェクトを記述する）とマニフェストファイル（プロジェクトの完全な依存関係グラフの正確なバージョンをスナップショットする）の作成と操作を支援します。</target>
        </trans-unit>
        <trans-unit id="3e86dc9fbf230d572664966d4794a26de9273668" translate="yes" xml:space="preserve">
          <source>Julia supports parallel loops using the &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.@threads&quot;&gt;&lt;code&gt;Threads.@threads&lt;/code&gt;&lt;/a&gt; macro. This macro is affixed in front of a &lt;code&gt;for&lt;/code&gt; loop to indicate to Julia that the loop is a multi-threaded region:</source>
          <target state="translated">Juliaは、&lt;a href=&quot;../../base/multi-threading/index#Base.Threads.@threads&quot;&gt; &lt;code&gt;Threads.@threads&lt;/code&gt; &lt;/a&gt;マクロを使用して並列ループをサポートします。このマクロは &lt;code&gt;for&lt;/code&gt; ループの前に付けられ、ループがマルチスレッド領域であることをJuliaに示します。</target>
        </trans-unit>
        <trans-unit id="a5283fbcd3917bac5a655bc39180ded4c3af822e" translate="yes" xml:space="preserve">
          <source>Julia supports three forms of numerical conversion, which differ in their handling of inexact conversions.</source>
          <target state="translated">Juliaは3つの形式の数値変換をサポートしており、不正確な変換の扱いが異なります。</target>
        </trans-unit>
        <trans-unit id="8cd4a62b540f64bfcf5a4bbfe0bf9740f9b0515a" translate="yes" xml:space="preserve">
          <source>Julia supports three main categories of features for concurrent and parallel programming:</source>
          <target state="translated">Juliaは、並行プログラミングと並列プログラミングのために、主に3つのカテゴリーの機能をサポートしています。</target>
        </trans-unit>
        <trans-unit id="58e2d62c4e474d2e3cdad1aedacbc766563cd1d6" translate="yes" xml:space="preserve">
          <source>Julia uses 1-based indexing for arrays by default, and it can also handle arbitrary &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/offset-arrays/#man-custom-indices&quot;&gt;index offsets&lt;/a&gt;.</source>
          <target state="translated">Juliaは、デフォルトで配列に1ベースのインデックスを使用し、任意の&lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/offset-arrays/#man-custom-indices&quot;&gt;インデックスオフセットを&lt;/a&gt;処理することもできます。</target>
        </trans-unit>
        <trans-unit id="ab0cbf25806d0b9c5fc2aa6aef5c6cef44171513" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_%28computer_science%29#Lexical_scoping_vs._dynamic_scoping&quot;&gt;lexical scoping&lt;/a&gt;, meaning that a function's scope does not inherit from its caller's scope, but from the scope in which the function was defined. For example, in the following code the &lt;code&gt;x&lt;/code&gt; inside &lt;code&gt;foo&lt;/code&gt; refers to the &lt;code&gt;x&lt;/code&gt; in the global scope of its module &lt;code&gt;Bar&lt;/code&gt;:</source>
          <target state="translated">Juliaは&lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_%28computer_science%29#Lexical_scoping_vs._dynamic_scoping&quot;&gt;字句スコープを&lt;/a&gt;使用します。つまり、関数のスコープは呼び出し元のスコープから継承されず、関数が定義されたスコープから継承されます。例えば、次のコードに &lt;code&gt;x&lt;/code&gt; 内部 &lt;code&gt;foo&lt;/code&gt; が指す &lt;code&gt;x&lt;/code&gt; そのモジュールのグローバルスコープの &lt;code&gt;Bar&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c3c73ac079b0c4f92a7cd6345869462d4c4c72df" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;code&gt;end&lt;/code&gt; to denote the end of conditional blocks, like &lt;code&gt;if&lt;/code&gt;, loop blocks, like &lt;code&gt;while&lt;/code&gt;/ &lt;code&gt;for&lt;/code&gt;, and functions. In lieu of the one-line &lt;code&gt;if ( cond ) statement&lt;/code&gt;, Julia allows statements of the form &lt;code&gt;if cond; statement; end&lt;/code&gt;, &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; and &lt;code&gt;!cond || statement&lt;/code&gt;. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt;, because of the operator precedence.</source>
          <target state="translated">Juliaは、 &lt;code&gt;if&lt;/code&gt; のような条件付きブロック、 &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; のようなループブロック、および関数の &lt;code&gt;end&lt;/code&gt; を示すためにendを使用します。 1行の &lt;code&gt;if ( cond ) statement&lt;/code&gt; 代わりに、ジュリアは &lt;code&gt;if cond; statement; end&lt;/code&gt; という形式のステートメントを許可します。ステートメント; end、 &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; および &lt;code&gt;!cond || statement&lt;/code&gt; 。後の2つの構文の代入ステートメントは、演算子の優先順位のため、括弧で明示的にラップする必要があります &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt; 例：cond &amp;amp;&amp;amp;（x = value））。</target>
        </trans-unit>
        <trans-unit id="0cabc05bc6f900c3729476582490d063a944c3f3" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;code&gt;end&lt;/code&gt; to denote the end of conditional blocks, like &lt;code&gt;if&lt;/code&gt;, loop blocks, like &lt;code&gt;while&lt;/code&gt;/ &lt;code&gt;for&lt;/code&gt;, and functions. In lieu of the one-line &lt;code&gt;if ( cond ) statement&lt;/code&gt;, Julia allows statements of the form &lt;code&gt;if cond; statement; end&lt;/code&gt;, &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; and &lt;code&gt;!cond || statement&lt;/code&gt;. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt;.</source>
          <target state="translated">Juliaは、 &lt;code&gt;if&lt;/code&gt; のような条件付きブロック、 &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; のようなループブロック、および関数の &lt;code&gt;end&lt;/code&gt; を示すためにendを使用します。 1行の &lt;code&gt;if ( cond ) statement&lt;/code&gt; 代わりに、ジュリアは &lt;code&gt;if cond; statement; end&lt;/code&gt; という形式のステートメントを許可します。ステートメント; end、 &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; および &lt;code&gt;!cond || statement&lt;/code&gt; 。後者の2つの構文の代入ステートメントは、括弧で明示的にラップする必要があります &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt; 例：cond &amp;amp;&amp;amp;（x = value））。</target>
        </trans-unit>
        <trans-unit id="07096f6426ddf7d6431c3e711ca9f0c89cf1dd4d" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;code&gt;nothing&lt;/code&gt; of type &lt;code&gt;Nothing&lt;/code&gt; to represent a null value, whereas Python uses &lt;code&gt;None&lt;/code&gt; of type &lt;code&gt;NoneType&lt;/code&gt;.</source>
          <target state="translated">Juliaはnull値を表すために &lt;code&gt;Nothing&lt;/code&gt; 型の何も使用し &lt;code&gt;nothing&lt;/code&gt; が、Pythonは &lt;code&gt;NoneType&lt;/code&gt; 型の &lt;code&gt;None&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="c1da921baa95047321b954687696b91e15a78b61" translate="yes" xml:space="preserve">
          <source>Julia uses machine arithmetic for integer computations. This means that the range of &lt;code&gt;Int&lt;/code&gt; values is bounded and wraps around at either end so that adding, subtracting and multiplying integers can overflow or underflow, leading to some results that can be unsettling at first:</source>
          <target state="translated">Juliaは整数計算に機械演算を使用します。これは、 &lt;code&gt;Int&lt;/code&gt; 値の範囲が制限され、両端で折り返されるため、整数の加算、減算、乗算がオーバーフローまたはアンダーフローし、最初は不安定になる可能性がある結果が生じることを意味します。</target>
        </trans-unit>
        <trans-unit id="89c53eee9d134c8dd587da06fe96b8ba48e316ee" translate="yes" xml:space="preserve">
          <source>Julia uses the UTF-8 encoding by default, and support for new encodings can be added by packages. For example, the &lt;a href=&quot;https://github.com/JuliaStrings/LegacyStrings.jl&quot;&gt;LegacyStrings.jl&lt;/a&gt; package implements &lt;code&gt;UTF16String&lt;/code&gt; and &lt;code&gt;UTF32String&lt;/code&gt; types. Additional discussion of other encodings and how to implement support for them is beyond the scope of this document for the time being. For further discussion of UTF-8 encoding issues, see the section below on &lt;a href=&quot;#man-byte-array-literals&quot;&gt;byte array literals&lt;/a&gt;. The &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt;&lt;code&gt;transcode&lt;/code&gt;&lt;/a&gt; function is provided to convert data between the various UTF-xx encodings, primarily for working with external data and libraries.</source>
          <target state="translated">JuliaはデフォルトでUTF-8エンコーディングを使用し、新しいエンコーディングのサポートをパッケージで追加できます。例えば、&lt;a href=&quot;https://github.com/JuliaStrings/LegacyStrings.jl&quot;&gt;LegacyStrings.jl&lt;/a&gt;パッケージの実装は &lt;code&gt;UTF16String&lt;/code&gt; と &lt;code&gt;UTF32String&lt;/code&gt; 種類を。他のエンコーディングとそれらのサポートを実装する方法についての追加の説明は、当面はこのドキュメントの範囲を超えています。 UTF-8エンコーディングの問題の詳細については、&lt;a href=&quot;#man-byte-array-literals&quot;&gt;バイト配列リテラル&lt;/a&gt;に関する以下のセクションを参照してください。&lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt; &lt;code&gt;transcode&lt;/code&gt; &lt;/a&gt;機能は、主に外部のデータやライブラリを操作するための、様々なUTF-xxのエンコーディングの間でデータを変換するために設けられています。</target>
        </trans-unit>
        <trans-unit id="51011bd7d0e6585180df272ca646802fbeb44e3f" translate="yes" xml:space="preserve">
          <source>Julia uses the UTF-8 encoding by default, and support for new encodings can be added by packages. For example, the &lt;a href=&quot;https://github.com/JuliaStrings/LegacyStrings.jl&quot;&gt;LegacyStrings.jl&lt;/a&gt; package implements &lt;code&gt;UTF16String&lt;/code&gt; and &lt;code&gt;UTF32String&lt;/code&gt; types. Additional discussion of other encodings and how to implement support for them is beyond the scope of this document for the time being. For further discussion of UTF-8 encoding issues, see the section below on &lt;a href=&quot;#man-byte-array-literals-1&quot;&gt;byte array literals&lt;/a&gt;. The &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt;&lt;code&gt;transcode&lt;/code&gt;&lt;/a&gt; function is provided to convert data between the various UTF-xx encodings, primarily for working with external data and libraries.</source>
          <target state="translated">JuliaはデフォルトでUTF-8エンコーディングを使用し、新しいエンコーディングのサポートをパッケージで追加できます。たとえば、&lt;a href=&quot;https://github.com/JuliaStrings/LegacyStrings.jl&quot;&gt;LegacyStrings.jl&lt;/a&gt;パッケージは &lt;code&gt;UTF16String&lt;/code&gt; および &lt;code&gt;UTF32String&lt;/code&gt; タイプを実装します。他のエンコーディングとそれらのサポートを実装する方法の追加の説明は、当面このドキュメントの範囲を超えています。 UTF-8エンコーディングの問題の詳細については、&lt;a href=&quot;#man-byte-array-literals-1&quot;&gt;バイト配列リテラル&lt;/a&gt;に関する以下のセクションを参照してください。&lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt; &lt;code&gt;transcode&lt;/code&gt; &lt;/a&gt;機能は、主に外部のデータやライブラリを操作するための、様々なUTF-xxのエンコーディングの間でデータを変換するために設けられています。</target>
        </trans-unit>
        <trans-unit id="5e0e9c6a66c5fa559fda71e594a3ae5240a6637e" translate="yes" xml:space="preserve">
          <source>Julia uses the first of these that exists to try to load the public &lt;code&gt;Priv&lt;/code&gt; package from the file &lt;code&gt;packages/Priv/HDKrT/src/Priv.jl&lt;/code&gt; in the depot where it was found.</source>
          <target state="translated">Juliaはこれらの最初のものを使用して、見つかったデポ内のファイル &lt;code&gt;packages/Priv/HDKrT/src/Priv.jl&lt;/code&gt; からパブリック &lt;code&gt;Priv&lt;/code&gt; パッケージをロードしようとします。</target>
        </trans-unit>
        <trans-unit id="30edeef56ee9d985332259b8e62139e00973bd46" translate="yes" xml:space="preserve">
          <source>Julia uses your system's locale and language settings to determine which characters can be printed as-is and which must be output using the generic, escaped &lt;code&gt;\u&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; input forms. In addition to these Unicode escape forms, all of &lt;a href=&quot;https://en.wikipedia.org/wiki/C_syntax#Backslash_escapes&quot;&gt;C's traditional escaped input forms&lt;/a&gt; can also be used:</source>
          <target state="translated">Juliaはシステムのロケールと言語の設定を使用して、そのまま印刷できる文字と、汎用のエスケープされた &lt;code&gt;\u&lt;/code&gt; または &lt;code&gt;\U&lt;/code&gt; 入力フォームを使用して出力する必要がある文字を決定します。これらのUnicodeエスケープフォームに加えて、&lt;a href=&quot;https://en.wikipedia.org/wiki/C_syntax#Backslash_escapes&quot;&gt;Cの従来のエスケープされた入力フォーム&lt;/a&gt;もすべて使用できます。</target>
        </trans-unit>
        <trans-unit id="bd0dc71ebce3799f196e4c40689f527bedaa69fb" translate="yes" xml:space="preserve">
          <source>Julia values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller.</source>
          <target state="translated">ユリアの値は、関数に代入されたり渡されたりしてもコピーされません。関数が配列を変更した場合、その変更は呼び出し元に表示されます。</target>
        </trans-unit>
        <trans-unit id="7ac4008d58382151203baf7753fcd45089959029" translate="yes" xml:space="preserve">
          <source>Julia values are not copied when passed to a function. If a function modifies an array, the changes will be visible in the caller.</source>
          <target state="translated">ユリアの値は関数に渡されてもコピーされません。関数が配列を変更した場合、その変更は呼び出し元に表示されます。</target>
        </trans-unit>
        <trans-unit id="8837407288696b8f56b310a5e7e527268f191a69" translate="yes" xml:space="preserve">
          <source>Julia will even let you redefine built-in constants and functions if needed (although this is not recommended to avoid potential confusions):</source>
          <target state="translated">必要に応じて、Juliaは組み込みの定数や関数を再定義することもできます(ただし、混乱を避けるためにはこれは推奨されません)。</target>
        </trans-unit>
        <trans-unit id="bbfd1a84071c3afc3da5111c8fd03dbd6cb9cfcf" translate="yes" xml:space="preserve">
          <source>Julia workers must NOT be started with &lt;code&gt;--worker&lt;/code&gt;. Starting with &lt;code&gt;--worker&lt;/code&gt; will result in the newly launched workers defaulting to the TCP/IP socket transport implementation.</source>
          <target state="translated">Juliaワーカーは &lt;code&gt;--worker&lt;/code&gt; で始めてはいけません。 &lt;code&gt;--worker&lt;/code&gt; で開始すると、新しく起動されたワーカーがデフォルトでTCP / IPソケットトランスポート実装に設定されます。</target>
        </trans-unit>
        <trans-unit id="d2e71f463c75ed1f922e909db643a6a01be0bb01" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; takes the function first, then its arguments, unlike &lt;code&gt;lapply(&amp;lt;structure&amp;gt;, function, ...)&lt;/code&gt; in R. Similarly Julia's equivalent of &lt;code&gt;apply(X, MARGIN, FUN, ...)&lt;/code&gt; in R is &lt;a href=&quot;../../base/arrays/index#Base.mapslices&quot;&gt;&lt;code&gt;mapslices&lt;/code&gt;&lt;/a&gt; where the function is the first argument.</source>
          <target state="translated">Juliaの&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;は、 &lt;code&gt;lapply(&amp;lt;structure&amp;gt;, function, ...)&lt;/code&gt; とは異なり、最初に関数を取り、次に引数を受け取ります。同様に、Rの &lt;code&gt;apply(X, MARGIN, FUN, ...)&lt;/code&gt; に相当するJulia は、関数が&lt;a href=&quot;../../base/arrays/index#Base.mapslices&quot;&gt; &lt;code&gt;mapslices&lt;/code&gt; &lt;/a&gt;であることを示します。最初の引数です。</target>
        </trans-unit>
        <trans-unit id="f5bb002ee0de69716a37fbfcd112bddd1aed44f5" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt;&lt;code&gt;maximum&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt;&lt;code&gt;minimum&lt;/code&gt;&lt;/a&gt; are different from their counterparts in R. They all accept an optional keyword argument &lt;code&gt;dims&lt;/code&gt;, which indicates the dimensions, over which the operation is carried out. For instance, let &lt;code&gt;A = [1 2; 3 4]&lt;/code&gt; in Julia and &lt;code&gt;B &amp;lt;- rbind(c(1,2),c(3,4))&lt;/code&gt; be the same matrix in R. Then &lt;code&gt;sum(A)&lt;/code&gt; gives the same result as &lt;code&gt;sum(B)&lt;/code&gt;, but &lt;code&gt;sum(A, dims=1)&lt;/code&gt; is a row vector containing the sum over each column and &lt;code&gt;sum(A, dims=2)&lt;/code&gt; is a column vector containing the sum over each row. This contrasts to the behavior of R, where separate &lt;code&gt;colSums(B)&lt;/code&gt; and &lt;code&gt;rowSums(B)&lt;/code&gt; functions provide these functionalities. If the &lt;code&gt;dims&lt;/code&gt; keyword argument is a vector, then it specifies all the dimensions over which the sum is performed, while retaining the dimensions of the summed array, e.g. &lt;code&gt;sum(A, dims=(1,2)) == hcat(10)&lt;/code&gt;. It should be noted that there is no error checking regarding the second argument.</source>
          <target state="translated">Juliaの&lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt; &lt;code&gt;maximum&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt; &lt;code&gt;minimum&lt;/code&gt; &lt;/a&gt;は、Rの対応するものとは異なります。これらはすべて、操作が実行される次元を示すオプションのキーワード引数 &lt;code&gt;dims&lt;/code&gt; を受け入れます。たとえば、 &lt;code&gt;A = [1 2; 3 4]&lt;/code&gt; Juliaでは、 &lt;code&gt;B &amp;lt;- rbind(c(1,2),c(3,4))&lt;/code&gt; はRの同じ行列になります。次に、 &lt;code&gt;sum(A)&lt;/code&gt; は &lt;code&gt;sum(B)&lt;/code&gt; と同じ結果になりますが、 &lt;code&gt;sum(A, dims=1)&lt;/code&gt; は各列の合計を含む行ベクトルで、 &lt;code&gt;sum(A, dims=2)&lt;/code&gt; は各行の合計を含む列ベクトルです。これは、Rの動作とは対照的です。 &lt;code&gt;colSums(B)&lt;/code&gt; および &lt;code&gt;rowSums(B)&lt;/code&gt; 関数は、これらの機能を提供します。 &lt;code&gt;dims&lt;/code&gt; キーワード引数がベクトルの場合、合計された配列の次元を保持しながら、合計が実行されるすべての次元を指定します。例： &lt;code&gt;sum(A, dims=(1,2)) == hcat(10)&lt;/code&gt; 。2番目の引数に関するエラーチェックはありません。</target>
        </trans-unit>
        <trans-unit id="fa67fe88be62afc80adeb10ce9e92a9b5f6f9cf4" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt; are the equivalent of &lt;code&gt;pmax&lt;/code&gt; and &lt;code&gt;pmin&lt;/code&gt; respectively in R, but both arguments need to have the same dimensions. While &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt;&lt;code&gt;maximum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt;&lt;code&gt;minimum&lt;/code&gt;&lt;/a&gt; replace &lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; in R, there are important differences.</source>
          <target state="translated">Juliaの&lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/math/index#Base.min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt;は、それぞれRの &lt;code&gt;pmax&lt;/code&gt; と &lt;code&gt;pmin&lt;/code&gt; に相当しますが、両方の引数は同じ次元でなければなりません。一方で&lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt; &lt;code&gt;maximum&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt; &lt;code&gt;minimum&lt;/code&gt; &lt;/a&gt;置き換える &lt;code&gt;max&lt;/code&gt; と &lt;code&gt;min&lt;/code&gt; Rで、重要な違いがあります。</target>
        </trans-unit>
        <trans-unit id="948bcc3b1298520e6e2ce90508494e37d41ff33b" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; is designed for the case where each function call does a large amount of work. In contrast, &lt;code&gt;@distributed for&lt;/code&gt; can handle situations where each iteration is tiny, perhaps merely summing two numbers. Only worker processes are used by both &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;@distributed for&lt;/code&gt; for the parallel computation. In case of &lt;code&gt;@distributed for&lt;/code&gt;, the final reduction is done on the calling process.</source>
          <target state="translated">Juliaの&lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt;は、各関数呼び出しが大量の作業を行う場合のために設計されています。対照的に、 &lt;code&gt;@distributed for&lt;/code&gt; は、各反復がわずかで、おそらく2つの数値を合計するだけの状況を処理できます。ワーカープロセスのみが、並列計算のために&lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;@distributed for&lt;/code&gt; 両方で使用されます。以下の場合 &lt;code&gt;@distributed for&lt;/code&gt; 、最終減速は呼び出し元のプロセスで行われます。</target>
        </trans-unit>
        <trans-unit id="1dee74c8ab40f9a1e425f6d177c82bc6b08fa25e" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diag&quot;&gt;&lt;code&gt;diag&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diagm&quot;&gt;&lt;code&gt;diagm&lt;/code&gt;&lt;/a&gt; are not like R's.</source>
          <target state="translated">ジュリアの&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diag&quot;&gt; &lt;code&gt;diag&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diagm&quot;&gt; &lt;code&gt;diagm&lt;/code&gt; &lt;/a&gt;は、R のダイアグとは異なります。</target>
        </trans-unit>
        <trans-unit id="05bb4ea25c67464af30f3b1789a99b7d0ce690d4" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt; returns singular values as a vector instead of as a dense diagonal matrix.</source>
          <target state="translated">Juliaの&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt;は、特異値を密な対角行列ではなくベクトルとして返します。</target>
        </trans-unit>
        <trans-unit id="aa13bfca9375abd93cb6c7683cece63cd5fd2582" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;*&lt;/code&gt; operator can perform matrix multiplication, unlike in R. If &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are matrices, then &lt;code&gt;A * B&lt;/code&gt; denotes a matrix multiplication in Julia, equivalent to R's &lt;code&gt;A %*% B&lt;/code&gt;. In R, this same notation would perform an element-wise (Hadamard) product. To get the element-wise multiplication operation, you need to write &lt;code&gt;A .* B&lt;/code&gt; in Julia.</source>
          <target state="translated">Juliaの &lt;code&gt;*&lt;/code&gt; 演算子は、Rとは異なり、行列の乗算を実行できます &lt;code&gt;A&lt;/code&gt; と &lt;code&gt;B&lt;/code&gt; が行列の場合、 &lt;code&gt;A * B&lt;/code&gt; はJuliaでの行列の乗算を示し、Rの &lt;code&gt;A %*% B&lt;/code&gt; と同等です。Rでは、この同じ表記は要素ごとの（アダマール）積を実行します。要素ごとの乗算演算を取得するには、Juliaで &lt;code&gt;A .* B&lt;/code&gt; と記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="eb6c182bb057e6aaee719738d353d529a33805be" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;-&amp;gt;&lt;/code&gt; creates an anonymous function, it does not access a member via a pointer.</source>
          <target state="translated">Juliaの &lt;code&gt;-&amp;gt;&lt;/code&gt; は無名関数を作成し、ポインターを介してメンバーにアクセスしません。</target>
        </trans-unit>
        <trans-unit id="0862128440ff742c36348e2d0db0ca8e8f8925ae" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;-&amp;gt;&lt;/code&gt; creates an anonymous function.</source>
          <target state="translated">Juliaの &lt;code&gt;-&amp;gt;&lt;/code&gt; は無名関数を作成します。</target>
        </trans-unit>
        <trans-unit id="5ae5cdad8a8956ce245f1722cb08571c8a10bd0f" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;Char&lt;/code&gt; type is 32 bits, which is not the same as the wide character type (&lt;code&gt;wchar_t&lt;/code&gt; or &lt;code&gt;wint_t&lt;/code&gt;) on all platforms.</source>
          <target state="translated">Juliaの &lt;code&gt;Char&lt;/code&gt; 型は32ビットであり、すべてのプラットフォームでワイド文字型（ &lt;code&gt;wchar_t&lt;/code&gt; または &lt;code&gt;wint_t&lt;/code&gt; ）と同じではありません。</target>
        </trans-unit>
        <trans-unit id="b385c4d6332873c3dcd00293c1c25f1adc3ec233" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;^&lt;/code&gt; is exponentiation (pow), not bitwise XOR as in C/C++ (use &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;, in Julia)</source>
          <target state="translated">ジュリアの &lt;code&gt;^&lt;/code&gt; は指数（pow）であり、C / C ++のようなビット単位のXORではありません（ジュリアでは&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; を&lt;/a&gt;使用します）</target>
        </trans-unit>
        <trans-unit id="b992e2bb2c187c81d565dd2576257e75a4ff2ac1" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, etc. blocks are terminated by the &lt;code&gt;end&lt;/code&gt; keyword. Indentation level is not significant as it is in Python.</source>
          <target state="translated">Juliaの &lt;code&gt;for&lt;/code&gt; 、 &lt;code&gt;if&lt;/code&gt; 、 &lt;code&gt;while&lt;/code&gt; などのブロックは、 &lt;code&gt;end&lt;/code&gt; キーワードで終了します。Pythonと同様、インデントレベルは重要ではありません。</target>
        </trans-unit>
        <trans-unit id="4f389c4a1d318e9dd00a0e8de7e401cb98f80629" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, etc. blocks are terminated by the &lt;code&gt;end&lt;/code&gt; keyword. Indentation level is not significant as it is in Python. Unlike Python, Julia has no &lt;code&gt;pass&lt;/code&gt; keyword.</source>
          <target state="translated">Juliaの &lt;code&gt;for&lt;/code&gt; 、 &lt;code&gt;if&lt;/code&gt; 、 &lt;code&gt;while&lt;/code&gt; などのブロックは、 &lt;code&gt;end&lt;/code&gt; キーワードで終了します。 Pythonの場合のように、インデントレベルは重要ではありません。 Pythonとは異なり、Juliaには &lt;code&gt;pass&lt;/code&gt; キーワードがありません。</target>
        </trans-unit>
        <trans-unit id="4a5e37d3fa53f0bf640b0dba96a1ab8faecfac9f" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;struct&lt;/code&gt;s do not support dynamically adding fields at runtime, unlike MATLAB's &lt;code&gt;class&lt;/code&gt;es. Instead, use a &lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt;&lt;code&gt;Dict&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Juliaの &lt;code&gt;struct&lt;/code&gt; は、MATLABの &lt;code&gt;class&lt;/code&gt; es とは異なり、実行時にフィールドを動的に追加することをサポートしていません。代わりに、&lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt; &lt;code&gt;Dict&lt;/code&gt; を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="f4b03ee02a08f7deb55748f11f6cdeb8e4ae72ba" translate="yes" xml:space="preserve">
          <source>Julia's REPL keybindings may be fully customized to a user's preferences by passing a dictionary to &lt;code&gt;REPL.setup_interface&lt;/code&gt;. The keys of this dictionary may be characters or strings. The key &lt;code&gt;'*'&lt;/code&gt; refers to the default action. Control plus character &lt;code&gt;x&lt;/code&gt; bindings are indicated with &lt;code&gt;&quot;^x&quot;&lt;/code&gt;. Meta plus &lt;code&gt;x&lt;/code&gt; can be written &lt;code&gt;&quot;\\M-x&quot;&lt;/code&gt; or &lt;code&gt;&quot;\ex&quot;&lt;/code&gt;, and Control plus &lt;code&gt;x&lt;/code&gt; can be written &lt;code&gt;&quot;\\C-x&quot;&lt;/code&gt; or &lt;code&gt;&quot;^x&quot;&lt;/code&gt;. The values of the custom keymap must be &lt;code&gt;nothing&lt;/code&gt; (indicating that the input should be ignored) or functions that accept the signature &lt;code&gt;(PromptState, AbstractREPL, Char)&lt;/code&gt;. The &lt;code&gt;REPL.setup_interface&lt;/code&gt; function must be called before the REPL is initialized, by registering the operation with &lt;a href=&quot;#Base.atreplinit&quot;&gt;&lt;code&gt;atreplinit&lt;/code&gt;&lt;/a&gt; . For example, to bind the up and down arrow keys to move through history without prefix search, one could put the following code in &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">JuliaのREPLキーバインディングは、辞書を &lt;code&gt;REPL.setup_interface&lt;/code&gt; に渡すことにより、ユーザーの好みに合わせて完全にカスタマイズできます。この辞書のキーは、文字または文字列です。キー &lt;code&gt;'*'&lt;/code&gt; はデフォルトのアクションを示します。コントロールと文字 &lt;code&gt;x&lt;/code&gt; のバインディングは、 &lt;code&gt;&quot;^x&quot;&lt;/code&gt; 示されます。メタプラス &lt;code&gt;x&lt;/code&gt; は書くことができる &lt;code&gt;&quot;\\M-x&quot;&lt;/code&gt; または &lt;code&gt;&quot;\ex&quot;&lt;/code&gt; 、およびコントロールプラス &lt;code&gt;x&lt;/code&gt; は書き込むことができ &lt;code&gt;&quot;\\C-x&quot;&lt;/code&gt; または &lt;code&gt;&quot;^x&quot;&lt;/code&gt; 。カスタムキーマップの値は、 &lt;code&gt;nothing&lt;/code&gt; （入力を無視する必要があることを示す）か、署名を受け入れる関数 &lt;code&gt;(PromptState, AbstractREPL, Char)&lt;/code&gt; 。 &lt;code&gt;REPL.setup_interface&lt;/code&gt; のREPLを使用して操作を登録することにより、初期化される前に、関数が呼び出さなければなりません&lt;a href=&quot;#Base.atreplinit&quot;&gt; &lt;code&gt;atreplinit&lt;/code&gt; &lt;/a&gt;。たとえば、上矢印キーと下矢印キーをバインドしてプレフィックス検索なしで履歴を移動するには、次のコードを &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; 配置します。</target>
        </trans-unit>
        <trans-unit id="eb62051205cdc85bbd2ca3341a23ca3df8234a6b" translate="yes" xml:space="preserve">
          <source>Julia's REPL keybindings may be fully customized to a user's preferences by passing a dictionary to &lt;code&gt;REPL.setup_interface&lt;/code&gt;. The keys of this dictionary may be characters or strings. The key &lt;code&gt;'*'&lt;/code&gt; refers to the default action. Control plus character &lt;code&gt;x&lt;/code&gt; bindings are indicated with &lt;code&gt;&quot;^x&quot;&lt;/code&gt;. Meta plus &lt;code&gt;x&lt;/code&gt; can be written &lt;code&gt;&quot;\\Mx&quot;&lt;/code&gt;. The values of the custom keymap must be &lt;code&gt;nothing&lt;/code&gt; (indicating that the input should be ignored) or functions that accept the signature &lt;code&gt;(PromptState, AbstractREPL, Char)&lt;/code&gt;. The &lt;code&gt;REPL.setup_interface&lt;/code&gt; function must be called before the REPL is initialized, by registering the operation with &lt;a href=&quot;#Base.atreplinit&quot;&gt;&lt;code&gt;atreplinit&lt;/code&gt;&lt;/a&gt; . For example, to bind the up and down arrow keys to move through history without prefix search, one could put the following code in &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">JuliaのREPLキーバインドは、辞書を &lt;code&gt;REPL.setup_interface&lt;/code&gt; に渡すことにより、ユーザーの設定に完全にカスタマイズできます。この辞書のキーは、文字または文字列です。キー &lt;code&gt;'*'&lt;/code&gt; はデフォルトのアクションを示します。コントロールと文字 &lt;code&gt;x&lt;/code&gt; バインディングは &lt;code&gt;&quot;^x&quot;&lt;/code&gt; 示されます。メタプラス &lt;code&gt;x&lt;/code&gt; は &lt;code&gt;&quot;\\Mx&quot;&lt;/code&gt; と書くことができます。カスタムキーマップの値は、 &lt;code&gt;nothing&lt;/code&gt; （入力を無視する必要があることを示す）か、署名を受け入れる関数 &lt;code&gt;(PromptState, AbstractREPL, Char)&lt;/code&gt; なければなりません。 &lt;code&gt;REPL.setup_interface&lt;/code&gt; の REPLが初期化される前に、この関数は使用して操作を登録することで、呼び出されなければなりません&lt;a href=&quot;#Base.atreplinit&quot;&gt; &lt;code&gt;atreplinit&lt;/code&gt; &lt;/a&gt;。たとえば、上矢印キーと下矢印キーをバインドして、プレフィックス検索なしで履歴を移動するには、次のコードを &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="5dfc06368777a16cdc231cc0f47af0adaed5f388" translate="yes" xml:space="preserve">
          <source>Julia's advantage is that good performance is not limited to a small subset of &amp;ldquo;built-in&amp;rdquo; types and operations, and one can write high-level type-generic code that works on arbitrary user-defined types while remaining fast and memory-efficient. Types in languages like Python simply don't provide enough information to the compiler for similar capabilities, so as soon as you used those languages as a Julia front-end you would be stuck.</source>
          <target state="translated">Juliaの利点は、優れたパフォーマンスが「組み込み」型と操作の小さなサブセットに限定されず、高速でメモリ効率を維持しながら、任意のユーザー定義型で機能する高レベルの型ジェネリックコードを記述できることです。Pythonのような言語の型は、同様の機能のためにコンパイラーに十分な情報を提供しないため、それらの言語をJuliaフロントエンドとして使用するとすぐに行き詰まります。</target>
        </trans-unit>
        <trans-unit id="ff3f30910627d9bc09b7bdaeca1a62844f17b994" translate="yes" xml:space="preserve">
          <source>Julia's base library has a an internal &lt;code&gt;sub2ind&lt;/code&gt; function to calculate a linear index into an n-dimensional array, based on a set of n multilinear indices - in other words, to calculate the index &lt;code&gt;i&lt;/code&gt; that can be used to index into an array &lt;code&gt;A&lt;/code&gt; using &lt;code&gt;A[i]&lt;/code&gt;, instead of &lt;code&gt;A[x,y,z,...]&lt;/code&gt;. One possible implementation is the following:</source>
          <target state="translated">ジュリアの基本ライブラリは、内部有する &lt;code&gt;sub2ind&lt;/code&gt; のセットに基づいて、n次元アレイ、nは多重線形インデックスに線形指数を計算する機能を-インデックスを計算するために、換言すれば、 &lt;code&gt;i&lt;/code&gt; 配列へのインデックスに使用することができる &lt;code&gt;A&lt;/code&gt; 使用 &lt;code&gt;A[i]&lt;/code&gt; 、 &lt;code&gt;A[x,y,z,...]&lt;/code&gt; ではなく。可能な実装の1つは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c2b028dd5553cdb221b0a0e50311b3fadf26a8fa" translate="yes" xml:space="preserve">
          <source>Julia's base library has an internal &lt;code&gt;sub2ind&lt;/code&gt; function to calculate a linear index into an n-dimensional array, based on a set of n multilinear indices - in other words, to calculate the index &lt;code&gt;i&lt;/code&gt; that can be used to index into an array &lt;code&gt;A&lt;/code&gt; using &lt;code&gt;A[i]&lt;/code&gt;, instead of &lt;code&gt;A[x,y,z,...]&lt;/code&gt;. One possible implementation is the following:</source>
          <target state="translated">Juliaのベースライブラリには、n個の多重線形インデックスのセットに基づいてn次元配列への線形インデックスを計算する内部 &lt;code&gt;sub2ind&lt;/code&gt; 関数があります。つまり、 &lt;code&gt;A&lt;/code&gt; を使用して配列Aにインデックスを付けるために使用できるインデックス &lt;code&gt;i&lt;/code&gt; を計算します &lt;code&gt;A[i]&lt;/code&gt; 、 &lt;code&gt;A[x,y,z,...]&lt;/code&gt; 代わりに。考えられる実装の1つは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a8c2555d21a070c01d642324e7f2023f9aae7e60" translate="yes" xml:space="preserve">
          <source>Julia's compiler specializes code for argument types at function boundaries, so in the original implementation it does not know the type of &lt;code&gt;a&lt;/code&gt; during the loop (since it is chosen randomly). Therefore the second version is generally faster since the inner loop can be recompiled as part of &lt;code&gt;fill_twos!&lt;/code&gt; for different types of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Juliaのコンパイラは、関数の境界での引数の型のコードを特殊化しているため、元の実装では、ループ中に &lt;code&gt;a&lt;/code&gt; の型がわかりません（ランダムに選択されるため）。したがって、2番目のバージョンは、内部ループを &lt;code&gt;fill_twos!&lt;/code&gt; 一部として再コンパイルできるため、一般的に高速です。さまざまなタイプのため。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="33f4b2b5366e275dc9d4f8493361eee0738216e2" translate="yes" xml:space="preserve">
          <source>Julia's implementation of message passing is different from other environments such as MPI &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;. Communication in Julia is generally &quot;one-sided&quot;, meaning that the programmer needs to explicitly manage only one process in a two-process operation. Furthermore, these operations typically do not look like &quot;message send&quot; and &quot;message receive&quot; but rather resemble higher-level operations like calls to user functions.</source>
          <target state="translated">Juliaのメッセージパッシングの実装は、MPI &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;などの他の環境とは異なります。 Juliaでの通信は、一般に「片側」です。つまり、プログラマーは、2つのプロセスの操作で1つのプロセスのみを明示的に管理する必要があります。さらに、これらの操作は通常「メッセージ送信」や「メッセージ受信」のようには見えませんが、ユーザー関数の呼び出しなどの高レベルの操作に似ています。</target>
        </trans-unit>
        <trans-unit id="6c32163901432dfb93ac8223e9799a51677fe0b8" translate="yes" xml:space="preserve">
          <source>Julia's implementation of message passing is different from other environments such as MPI&lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Communication in Julia is generally &quot;one-sided&quot;, meaning that the programmer needs to explicitly manage only one process in a two-process operation. Furthermore, these operations typically do not look like &quot;message send&quot; and &quot;message receive&quot; but rather resemble higher-level operations like calls to user functions.</source>
          <target state="translated">Juliaのメッセージパッシングの実装は、MPI &lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;などの他の環境とは異なります。Juliaでの通信は一般に「一方的な」ものです。つまり、プログラマーは2つのプロセス操作で1つのプロセスのみを明示的に管理する必要があります。さらに、これらの操作は通常、「メッセージ送信」や「メッセージ受信」のようには見えませんが、ユーザー関数の呼び出しなどの高レベルの操作に似ています。</target>
        </trans-unit>
        <trans-unit id="2d95266cdef29852b478ae12f711e31b88ca02d5" translate="yes" xml:space="preserve">
          <source>Julia's internal indexing machinery will automatically (and invisibly) convert all indexing operations into the preferred style. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.</source>
          <target state="translated">Juliaの内部のインデックス作成機構は、すべてのインデックス作成操作を自動的に(そして目に見えないように)好みのスタイルに変換します。これにより、明示的なメソッドが提供されていない場合でも、ユーザは任意のインデキシングスタイルを使用して配列の要素にアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="e29a0ad9426578653cfa0a913517c4cd61d66687" translate="yes" xml:space="preserve">
          <source>Julia's internal indexing machinery will automatically (and invisibly) recompute all indexing operations into the preferred style. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.</source>
          <target state="translated">Juliaの内部のインデックス作成機構は、すべてのインデックス作成操作を自動的に(そして目に見えないように)好みのスタイルに再計算します。これにより、明示的なメソッドが提供されていない場合でも、ユーザは任意のインデキシングスタイルを使用して配列の要素にアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="63b1a2fb20181eebd075a05851e2cc85e0131235" translate="yes" xml:space="preserve">
          <source>Julia's macro expander solves these problems in the following way. First, variables within a macro result are classified as either local or global. A variable is considered local if it is assigned to (and not declared global), declared local, or used as a function argument name. Otherwise, it is considered global. Local variables are then renamed to be unique (using the &lt;a href=&quot;../../base/base/index#Base.gensym&quot;&gt;&lt;code&gt;gensym&lt;/code&gt;&lt;/a&gt; function, which generates new symbols), and global variables are resolved within the macro definition environment. Therefore both of the above concerns are handled; the macro's locals will not conflict with any user variables, and &lt;code&gt;time&lt;/code&gt; and &lt;code&gt;println&lt;/code&gt; will refer to the Julia Base definitions.</source>
          <target state="translated">Juliaのマクロエキスパンダーは、次の方法でこれらの問題を解決します。まず、マクロ結果内の変数は、ローカルまたはグローバルのいずれかに分類されます。変数が割り当てられている（グローバルとして宣言されていない）、ローカルとして宣言されている、または関数の引数名として使用されている場合、その変数はローカルと見なされます。それ以外の場合は、グローバルと見なされます。次に、ローカル変数の名前が一意になるように（新しいシンボルを生成する&lt;a href=&quot;../../base/base/index#Base.gensym&quot;&gt; &lt;code&gt;gensym&lt;/code&gt; &lt;/a&gt;関数を使用して）変更され、グローバル変数はマクロ定義環境内で解決されます。したがって、上記の懸念の両方が処理されます。マクロのローカル変数はユーザー変数と競合せず、 &lt;code&gt;time&lt;/code&gt; および &lt;code&gt;println&lt;/code&gt; はJulia Base定義を参照します。</target>
        </trans-unit>
        <trans-unit id="86edf724d95c13484ea1286ad4816e866d0db9af" translate="yes" xml:space="preserve">
          <source>Julia's markdown supports interpolation in a very similar way to basic string literals, with the difference that it will store the object itself in the Markdown tree (as opposed to converting it to a string). When the Markdown content is rendered the usual &lt;code&gt;show&lt;/code&gt; methods will be called, and these can be overridden as usual. This design allows the Markdown to be extended with arbitrarily complex features (such as references) without cluttering the basic syntax.</source>
          <target state="translated">Juliaのマークダウンは、基本的な文字列リテラルと非常によく似た方法で補間をサポートしていますが、オブジェクト自体を（文字列に変換するのではなく）マークダウンツリーに格納する点が異なります。Markdownコンテンツがレンダリングされると、通常の &lt;code&gt;show&lt;/code&gt; メソッドが呼び出され、これらは通常どおりオーバーライドできます。この設計により、基本的な構文を乱雑にすることなく、Markdownを任意に複雑な機能（参照など）で拡張できます。</target>
        </trans-unit>
        <trans-unit id="f193759d498fbc023e5548ecbd3efb90a55de4f4" translate="yes" xml:space="preserve">
          <source>Julia's method polymorphism is one of its most powerful features, yet exploiting this power can pose design challenges. In particular, in more complex method hierarchies it is not uncommon for &lt;a href=&quot;#man-ambiguities&quot;&gt;ambiguities&lt;/a&gt; to arise.</source>
          <target state="translated">ジュリアのメソッドポリモーフィズムは、その最も強力な機能の1つですが、この能力を活用すると、設計上の課題が生じる可能性があります。特に、より複雑なメソッド階層では、&lt;a href=&quot;#man-ambiguities&quot;&gt;あいまいさ&lt;/a&gt;が生じることは珍しくありません。</target>
        </trans-unit>
        <trans-unit id="0901cb4cceb0fa7182b9eca38ef424535bdbefb3" translate="yes" xml:space="preserve">
          <source>Julia's method polymorphism is one of its most powerful features, yet exploiting this power can pose design challenges. In particular, in more complex method hierarchies it is not uncommon for &lt;a href=&quot;#man-ambiguities-1&quot;&gt;ambiguities&lt;/a&gt; to arise.</source>
          <target state="translated">ジュリアのメソッドのポリモーフィズムは、その最も強力な機能の1つですが、この力を利用すると、設計上の課題が発生する可能性があります。特に、より複雑なメソッド階層では、&lt;a href=&quot;#man-ambiguities-1&quot;&gt;あいまいさ&lt;/a&gt;が発生することは珍しくありません。</target>
        </trans-unit>
        <trans-unit id="23f2c84d6fee04af47b767e6d6e002d54d481014" translate="yes" xml:space="preserve">
          <source>Julia's multidimensional arrays are stored in memory in column-major order. Here is some code that creates a 2D array and accesses its properties:</source>
          <target state="translated">ジュリアの多次元配列は、メモリにカラム・メジャー順に格納されます。ここでは、2次元配列を作成し、そのプロパティにアクセスするコードをいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="5f52e87d6645fc0ed7cad30b976ecccc50cc320e" translate="yes" xml:space="preserve">
          <source>Julia's parallel programming platform uses &lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;Tasks (aka Coroutines)&lt;/a&gt; to switch among multiple computations. To express an order of execution between lightweight threads communication primitives are necessary. Julia offers &lt;code&gt;Channel(func::Function, ctype=Any, csize=0, taskref=nothing)&lt;/code&gt; that creates a new task from &lt;code&gt;func&lt;/code&gt;, binds it to a new channel of type &lt;code&gt;ctype&lt;/code&gt; and size &lt;code&gt;csize&lt;/code&gt; and schedule the task. &lt;code&gt;Channels&lt;/code&gt; can serve as a way to communicate between tasks, as &lt;code&gt;Channel{T}(sz::Int)&lt;/code&gt; creates a buffered channel of type &lt;code&gt;T&lt;/code&gt; and size &lt;code&gt;sz&lt;/code&gt;. Whenever code performs a communication operation like &lt;code&gt;fetch&lt;/code&gt; or &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;, the current task is suspended and a scheduler picks another task to run. A task is restarted when the event it is waiting for completes.</source>
          <target state="translated">Juliaの並列プログラミングプラットフォームは、&lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;タスク（別名コルーチン）&lt;/a&gt;を使用して複数の計算を切り替えます。軽量スレッド間の実行順序を表現するには、通信プリミティブが必要です。 Juliaは、 &lt;code&gt;func&lt;/code&gt; から新しいタスクを作成し、それをタイプ &lt;code&gt;ctype&lt;/code&gt; およびサイズ &lt;code&gt;csize&lt;/code&gt; の新しいチャネルにバインドしてタスクをスケジュールする &lt;code&gt;Channel(func::Function, ctype=Any, csize=0, taskref=nothing)&lt;/code&gt; を提供しています。 &lt;code&gt;Channels&lt;/code&gt; のように、タスク間で通信する方法として役立つことができる &lt;code&gt;Channel{T}(sz::Int)&lt;/code&gt; タイプの緩衝チャネル作成 &lt;code&gt;T&lt;/code&gt; およびサイズ &lt;code&gt;sz&lt;/code&gt; 。コードが &lt;code&gt;fetch&lt;/code&gt; や&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;、現在のタスクは一時停止され、スケジューラは実行する別のタスクを選択します。タスクは、待機しているイベントが完了すると再開されます。</target>
        </trans-unit>
        <trans-unit id="8fbc199e2173262fbbf9a789a4bc09af6495b0ec" translate="yes" xml:space="preserve">
          <source>Julia's promotion system makes arithmetic operations on mixtures of argument types &quot;just work&quot; naturally and automatically. See &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;Conversion and Promotion&lt;/a&gt; for details of the promotion system.</source>
          <target state="translated">ジュリアのプロモーションシステムは、引数タイプの混合に対する算術演算を自然かつ自動的に「正しく機能」させます。参照&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;変換と振興を&lt;/a&gt;推進システムの詳細については。</target>
        </trans-unit>
        <trans-unit id="b466bf8ce3736bba15b2ecdae9872de461ea3a56" translate="yes" xml:space="preserve">
          <source>Julia's promotion system makes arithmetic operations on mixtures of argument types &quot;just work&quot; naturally and automatically. See &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt; for details of the promotion system.</source>
          <target state="translated">ジュリアの昇格システムは、引数の型の混合に対する算術演算を自然にそして自動的に「そのまま」機能させます。参照&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;変換と振興を&lt;/a&gt;推進システムの詳細については。</target>
        </trans-unit>
        <trans-unit id="34b8049f71f2dca17e15f3a691f349cd09ad4d7f" translate="yes" xml:space="preserve">
          <source>Julia's range indexing has the format of &lt;code&gt;x[start:step:stop]&lt;/code&gt;, whereas Python's format is &lt;code&gt;x[start:(stop+1):step]&lt;/code&gt;. Hence, &lt;code&gt;x[0:10:2]&lt;/code&gt; in Python is equivalent to &lt;code&gt;x[1:2:10]&lt;/code&gt; in Julia. Similarly, &lt;code&gt;x[::-1]&lt;/code&gt; in Python, which refers to the reversed array, is equivalent to &lt;code&gt;x[end:-1:1]&lt;/code&gt; in Julia.</source>
          <target state="translated">Juliaの範囲インデックスの形式は &lt;code&gt;x[start:step:stop]&lt;/code&gt; ですが、Pythonの形式は &lt;code&gt;x[start:(stop+1):step]&lt;/code&gt; です。したがって、Pythonの &lt;code&gt;x[0:10:2]&lt;/code&gt; は、Juliaの &lt;code&gt;x[1:2:10]&lt;/code&gt; と同等です。同様に、Pythonの &lt;code&gt;x[::-1]&lt;/code&gt; は、逆配列を参照し、Juliaの &lt;code&gt;x[end:-1:1]&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="4c3a6166fa4f354bffc12e579d7219f7b110624c" translate="yes" xml:space="preserve">
          <source>Julia's single quotes enclose characters, not strings.</source>
          <target state="translated">ジュリアのシングルクォートは文字列ではなく文字を囲んでいます。</target>
        </trans-unit>
        <trans-unit id="5826232507a46053a3ad6eca3433bcfcdddedfd4" translate="yes" xml:space="preserve">
          <source>Julia's slice indexing includes the last element, unlike in Python. &lt;code&gt;a[2:3]&lt;/code&gt; in Julia is &lt;code&gt;a[1:3]&lt;/code&gt; in Python.</source>
          <target state="translated">Juliaのスライスインデックスには、Pythonとは異なり、最後の要素が含まれます。 &lt;code&gt;a[2:3]&lt;/code&gt; ジュリアでは、 &lt;code&gt;a[1:3]&lt;/code&gt; Pythonで。</target>
        </trans-unit>
        <trans-unit id="d3f2b1b2df721c7080cd008996870d53e3376216" translate="yes" xml:space="preserve">
          <source>Julia's type system is designed to be powerful and expressive, yet clear, intuitive and unobtrusive. Many Julia programmers may never feel the need to write code that explicitly uses types. Some kinds of programming, however, become clearer, simpler, faster and more robust with declared types.</source>
          <target state="translated">Julia の型システムは、パワフルで表現力がありながらも、明確で直感的で控えめな設計になっています。多くのJuliaプログラマは、明示的に型を使用するコードを書く必要性を感じないかもしれません。しかし、ある種のプログラミングでは、宣言された型を使うことで、より明確に、よりシンプルに、より速く、より堅牢になります。</target>
        </trans-unit>
        <trans-unit id="328e404443e1e3ee36bbd28ef0bec3925e10b36e" translate="yes" xml:space="preserve">
          <source>Julia's type system is dynamic, but gains some of the advantages of static type systems by making it possible to indicate that certain values are of specific types. This can be of great assistance in generating efficient code, but even more significantly, it allows method dispatch on the types of function arguments to be deeply integrated with the language. Method dispatch is explored in detail in &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt;, but is rooted in the type system presented here.</source>
          <target state="translated">Juliaの型システムは動的ですが、特定の値が特定の型であることを示すことができるため、静的型システムのいくつかの利点が得られます。これは、効率的なコードを生成するのに非常に役立ちますが、さらに重要なことに、関数の引数のタイプに対するメソッドディスパッチを言語と深く統合することができます。メソッドディスパッチについては、&lt;a href=&quot;../methods/index#Methods&quot;&gt;メソッド&lt;/a&gt;で詳しく説明していますが、ここに示す型システムに基づいています。</target>
        </trans-unit>
        <trans-unit id="2601bca815fd3b23be75d3eb7a5f70824d2baba0" translate="yes" xml:space="preserve">
          <source>Julia's type system is dynamic, but gains some of the advantages of static type systems by making it possible to indicate that certain values are of specific types. This can be of great assistance in generating efficient code, but even more significantly, it allows method dispatch on the types of function arguments to be deeply integrated with the language. Method dispatch is explored in detail in &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;, but is rooted in the type system presented here.</source>
          <target state="translated">Juliaの型システムは動的ですが、特定の値が特定の型であることを示すことを可能にすることで、静的型システムのいくつかの利点を獲得します。これは効率的なコードの生成に非常に役立ちますが、さらに重要なことに、関数の引数の型に対するメソッドディスパッチを言語と深く統合することができます。メソッドのディスパッチについては、「&lt;a href=&quot;../methods/index#Methods-1&quot;&gt;メソッド」&lt;/a&gt;で詳しく説明していますが、ここで紹介する型システムに基づいています。</target>
        </trans-unit>
        <trans-unit id="452075601195cf61defe5474343bae547d7dc931" translate="yes" xml:space="preserve">
          <source>Julia's updating operators (e.g. &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, ...) are &lt;em&gt;not in-place&lt;/em&gt; whereas NumPy's are. This means &lt;code&gt;A = [1, 1]; B = A; B += [3, 3]&lt;/code&gt; doesn't change values in &lt;code&gt;A&lt;/code&gt;, it rather rebinds the name &lt;code&gt;B&lt;/code&gt; to the result of the right-hand side &lt;code&gt;B = B + 3&lt;/code&gt;, which is a new array. For in-place operation, use &lt;code&gt;B .+= 3&lt;/code&gt; (see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators&quot;&gt;dot operators&lt;/a&gt;), explicit loops, or &lt;code&gt;InplaceOps.jl&lt;/code&gt;.</source>
          <target state="translated">Juliaの更新演算子（たとえば、 &lt;code&gt;+=&lt;/code&gt; 、 &lt;code&gt;-=&lt;/code&gt; 、...）は&lt;em&gt;インプレースで&lt;/em&gt;はあり&lt;em&gt;ませんが&lt;/em&gt;、NumPyの更新演算子&lt;em&gt;はインプレース&lt;/em&gt;です。これは、 &lt;code&gt;A = [1, 1]; B = A; B += [3, 3]&lt;/code&gt; 意味します。 B = A; B + = [3、3]は &lt;code&gt;A&lt;/code&gt; の値を変更せず、名前 &lt;code&gt;B&lt;/code&gt; を右側の &lt;code&gt;B = B + 3&lt;/code&gt; の結果に再バインドします。これは新しい配列です。インプレース操作の場合は、 &lt;code&gt;B .+= 3&lt;/code&gt; （&lt;a href=&quot;../mathematical-operations/index#man-dot-operators&quot;&gt;ドット演算子&lt;/a&gt;も参照）、明示的なループ、または &lt;code&gt;InplaceOps.jl&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="060a807b9436918cd4c19176ffcd9bf4c0ffdec4" translate="yes" xml:space="preserve">
          <source>Julia's updating operators (e.g. &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, ...) are &lt;em&gt;not in-place&lt;/em&gt; whereas NumPy's are. This means &lt;code&gt;A = [1, 1]; B = A; B += [3, 3]&lt;/code&gt; doesn't change values in &lt;code&gt;A&lt;/code&gt;, it rather rebinds the name &lt;code&gt;B&lt;/code&gt; to the result of the right-hand side &lt;code&gt;B = B + 3&lt;/code&gt;, which is a new array. For in-place operation, use &lt;code&gt;B .+= 3&lt;/code&gt; (see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;dot operators&lt;/a&gt;), explicit loops, or &lt;code&gt;InplaceOps.jl&lt;/code&gt;.</source>
          <target state="translated">Juliaの更新演算子（例： &lt;code&gt;+=&lt;/code&gt; 、 &lt;code&gt;-=&lt;/code&gt; 、...）は&lt;em&gt;インプレースで&lt;/em&gt;はあり&lt;em&gt;ませんが&lt;/em&gt;、NumPy &lt;em&gt;はインプレース&lt;/em&gt;です。つまり、 &lt;code&gt;A = [1, 1]; B = A; B += [3, 3]&lt;/code&gt; は &lt;code&gt;A&lt;/code&gt; の値を変更せず、名前 &lt;code&gt;B&lt;/code&gt; を右側の &lt;code&gt;B = B + 3&lt;/code&gt; の結果に再バインドします。これは新しい配列です。インプレース操作の場合は、 &lt;code&gt;B .+= 3&lt;/code&gt; （&lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;ドット演算子&lt;/a&gt;も参照）、明示的なループ、または &lt;code&gt;InplaceOps.jl&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="bd01ffb3135bea5db94d9c0cd4c8376ed4d4ff72" translate="yes" xml:space="preserve">
          <source>Julia, like most technical computing languages, provides a first-class array implementation. Most technical computing languages pay a lot of attention to their array implementation at the expense of other containers. Julia does not treat arrays in any special way. The array library is implemented almost completely in Julia itself, and derives its performance from the compiler, just like any other code written in Julia. As such, it's also possible to define custom array types by inheriting from &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../interfaces/index#man-interface-array&quot;&gt;manual section on the AbstractArray interface&lt;/a&gt; for more details on implementing a custom array type.</source>
          <target state="translated">Juliaは、ほとんどの技術的なコンピューティング言語と同様に、ファーストクラスの配列実装を提供します。ほとんどのテクニカルコンピューティング言語は、他のコンテナを犠牲にして、配列の実装に多くの注意を払っています。 Juliaは、配列を特別な方法で処理しません。配列ライブラリはJulia自体にほぼ完全に実装されており、Juliaで記述された他のコードと同様に、コンパイラからパフォーマンスを引き出します。そのため、&lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt;から継承してカスタム配列型を定義することもできます。カスタム配列型の実装の詳細については&lt;a href=&quot;../interfaces/index#man-interface-array&quot;&gt;、AbstractArrayインターフェイス&lt;/a&gt;のマニュアルセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="29157447971e1b4b6b81d91fd76c285c2b275482" translate="yes" xml:space="preserve">
          <source>Julia, like most technical computing languages, provides a first-class array implementation. Most technical computing languages pay a lot of attention to their array implementation at the expense of other containers. Julia does not treat arrays in any special way. The array library is implemented almost completely in Julia itself, and derives its performance from the compiler, just like any other code written in Julia. As such, it's also possible to define custom array types by inheriting from &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;manual section on the AbstractArray interface&lt;/a&gt; for more details on implementing a custom array type.</source>
          <target state="translated">ジュリアは、ほとんどの技術計算言語と同様に、ファーストクラスの配列実装を提供します。ほとんどの技術計算言語は、他のコンテナーを犠牲にして、配列の実装に多くの注意を払っています。 Juliaは配列を特別な方法で扱いません。配列ライブラリはJulia自体にほぼ完全に実装されており、Juliaで作成された他のコードと同様に、コンパイラーからそのパフォーマンスを引き出します。そのため、&lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt;から継承することにより、カスタム配列タイプを定義することもできます。カスタム配列型の実装の詳細については&lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;、AbstractArrayインターフェイス&lt;/a&gt;のマニュアルセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="88d1577dcc4f245ab6ce133765fe78bb8913aa7f" translate="yes" xml:space="preserve">
          <source>Jupiter</source>
          <target state="translated">Jupiter</target>
        </trans-unit>
        <trans-unit id="baa896b33786524acff2009a8d27bd6b3009cef2" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;^R&lt;/code&gt; is a reverse search, &lt;code&gt;^S&lt;/code&gt; is a forward search, with the prompt &lt;code&gt;(i-search)`':&lt;/code&gt;. The two may be used in conjunction with each other to move through the previous or next matching results, respectively.</source>
          <target state="translated">同じように &lt;code&gt;^R&lt;/code&gt; 逆探索で、 &lt;code&gt;^S&lt;/code&gt; プロンプトで前方検索、である &lt;code&gt;(i-search)`':&lt;/code&gt; 。2つを互いに組み合わせて使用​​して、それぞれ前または次のマッチング結果を移動できます。</target>
        </trans-unit>
        <trans-unit id="9365c41bee7315e2eb3ab59d3b982ca7ca4bb4b9" translate="yes" xml:space="preserve">
          <source>Just as help mode is useful for quick access to documentation, another common task is to use the system shell to execute system commands. Just as &lt;code&gt;?&lt;/code&gt; entered help mode when at the beginning of the line, a semicolon (&lt;code&gt;;&lt;/code&gt;) will enter the shell mode. And it can be exited by pressing backspace at the beginning of the line.</source>
          <target state="translated">ヘルプモードがドキュメントへの迅速なアクセスに役立つのと同様に、別の一般的なタスクは、システムシェルを使用してシステムコマンドを実行することです。と同じように &lt;code&gt;?&lt;/code&gt; 行の先頭でセミコロン（ &lt;code&gt;;&lt;/code&gt; ）がシェルモードに入ると、ヘルプモードに入ります。また、行の先頭でバックスペースを押すと終了できます。</target>
        </trans-unit>
        <trans-unit id="456f4e9fab32e1339e01f38c693667415e6a7374" translate="yes" xml:space="preserve">
          <source>Just as in &lt;a href=&quot;#man-array-indexing&quot;&gt;Indexing&lt;/a&gt;, the &lt;code&gt;end&lt;/code&gt; keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the array being assigned into. Indexed assignment syntax without the &lt;code&gt;end&lt;/code&gt; keyword is equivalent to a call to &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">ちょうどのように&lt;a href=&quot;#man-array-indexing&quot;&gt;索引付け&lt;/a&gt;、 &lt;code&gt;end&lt;/code&gt; に割り当てられている配列のサイズによって決定されるようなキーワードは、索引付け括弧内に各次元の最後のインデックスを表すために使用されてもよいです。 &lt;code&gt;end&lt;/code&gt; キーワードのないインデックス付き代入構文は、&lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;呼び出しと同等です。：</target>
        </trans-unit>
        <trans-unit id="e330a59e23d168a0ce147528d526c6c70e235165" translate="yes" xml:space="preserve">
          <source>Just as in &lt;a href=&quot;#man-array-indexing-1&quot;&gt;Indexing&lt;/a&gt;, the &lt;code&gt;end&lt;/code&gt; keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the array being assigned into. Indexed assignment syntax without the &lt;code&gt;end&lt;/code&gt; keyword is equivalent to a call to &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">ちょうどのように&lt;a href=&quot;#man-array-indexing-1&quot;&gt;索引付け&lt;/a&gt;、 &lt;code&gt;end&lt;/code&gt; に割り当てられている配列のサイズによって決定されるようなキーワードは、索引付け括弧内に各次元の最後のインデックスを表すために使用されてもよいです。 &lt;code&gt;end&lt;/code&gt; キーワードなしのインデックス付き割り当て構文は、&lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;呼び出しと同等です。：</target>
        </trans-unit>
        <trans-unit id="129fdfb9651f86a9c5a6d204baf7fd51a6f897e9" translate="yes" xml:space="preserve">
          <source>Just as text output is performed by &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; and user-defined types can indicate their textual representation by overloading &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt;, Julia provides a standardized mechanism for rich multimedia output (such as images, formatted text, or even audio and video), consisting of three parts:</source>
          <target state="translated">テキスト出力が&lt;a href=&quot;#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;によって実行され、ユーザー定義タイプが&lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt;をオーバーロードすることによってテキスト表現を示すことができるのと同じように、Juliaは3つの部分で構成されるリッチマルチメディア出力（画像、フォーマットされたテキスト、オーディオやビデオなど）のための標準化されたメカニズムを提供します：</target>
        </trans-unit>
        <trans-unit id="03d45fce37a205fcf4faeb89d82409711b9d7cca" translate="yes" xml:space="preserve">
          <source>Just as text output is performed by &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; and user-defined types can indicate their textual representation by overloading &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt;, Julia provides a standardized mechanism for rich multimedia output (such as images, formatted text, or even audio and video), consisting of three parts:</source>
          <target state="translated">テキスト出力が&lt;a href=&quot;#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;によって実行され、ユーザー定義タイプが&lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; の&lt;/a&gt;オーバーロードによってテキスト表現を示すことができるのと同様に、Juliaは、3つの部分で構成されるリッチマルチメディア出力（画像、フォーマットされたテキスト、さらにはオーディオとビデオなど）の標準化されたメカニズムを提供します：</target>
        </trans-unit>
        <trans-unit id="45c6961e570c4d224922a2a92f75eca4d8e9afac" translate="yes" xml:space="preserve">
          <source>Just as you can put subtype constraints on type parameters in type declarations (see &lt;a href=&quot;../types/index#Parametric-Types&quot;&gt;Parametric Types&lt;/a&gt;), you can also constrain type parameters of methods:</source>
          <target state="translated">型宣言の型パラメーターにサブ型制約を設定できるのと同じように（&lt;a href=&quot;../types/index#Parametric-Types&quot;&gt;パラメトリック型を&lt;/a&gt;参照）、メソッドの型パラメーターを制約することもできます。</target>
        </trans-unit>
        <trans-unit id="f31418705dc05a56f9681110f63d545eb15e8a22" translate="yes" xml:space="preserve">
          <source>Just as you can put subtype constraints on type parameters in type declarations (see &lt;a href=&quot;../types/index#Parametric-Types-1&quot;&gt;Parametric Types&lt;/a&gt;), you can also constrain type parameters of methods:</source>
          <target state="translated">型宣言の型パラメーターにサブタイプ制約を設定できるのと同じように（&lt;a href=&quot;../types/index#Parametric-Types-1&quot;&gt;パラメトリック型を&lt;/a&gt;参照）、メソッドの型パラメーターを制約することもできます。</target>
        </trans-unit>
        <trans-unit id="3a5b8319210d6e829092640e9c9931c8b6b93159" translate="yes" xml:space="preserve">
          <source>Just like condition expressions used in &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;elseif&lt;/code&gt; or the ternary operator, the operands of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; must be boolean values (&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;). Using a non-boolean value anywhere except for the last entry in a conditional chain is an error:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 、 &lt;code&gt;elseif&lt;/code&gt; 、または三項演算子で使用される条件式と同様に、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; または &lt;code&gt;||&lt;/code&gt; のオペランド ブール値（ &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; ）でなければなりません。条件チェーンの最後のエントリ以外の場所でブール値以外の値を使用すると、エラーになります。</target>
        </trans-unit>
        <trans-unit id="89b905a2ec6630efe24e67a128976a957febd0eb" translate="yes" xml:space="preserve">
          <source>Juxtaposed literal coefficient syntax may conflict with two numeric literal syntaxes: hexadecimal integer literals and engineering notation for floating-point literals. Here are some situations where syntactic conflicts arise:</source>
          <target state="translated">並置リテラル係数構文は、2つの数値リテラル構文(16進整数リテラルと浮動小数点リテラルの工学的表記法)と競合することがあります。ここでは、構文上の競合が発生する状況をいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="9ec40672083b66df6ef7fbca9db99f5cc01dc9d5" translate="yes" xml:space="preserve">
          <source>Keep in mind that some Julia features are not currently supported by CUDAnative.jl &lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt; , especially some functions like &lt;code&gt;sin&lt;/code&gt; will need to be replaced with &lt;code&gt;CUDAnative.sin&lt;/code&gt;(cc: @maleadt).</source>
          <target state="translated">Juliaの一部の機能は現在CUDAnative.jl &lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;でサポートされていないことに注意してください。特に、 &lt;code&gt;sin&lt;/code&gt; などの一部の関数は &lt;code&gt;CUDAnative.sin&lt;/code&gt; （cc：@maleadt）で置き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="ed1dc2aa59f2bcc19af822ca3015689f0776b65a" translate="yes" xml:space="preserve">
          <source>Keep in mind that some Julia features are not currently supported by CUDAnative.jl&lt;sup&gt;&lt;a href=&quot;#footnote-2&quot; id=&quot;citeref-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; , especially some functions like &lt;code&gt;sin&lt;/code&gt; will need to be replaced with &lt;code&gt;CUDAnative.sin&lt;/code&gt;(cc: @maleadt).</source>
          <target state="translated">一部のJulia機能は現在CUDAnative.jl &lt;sup&gt;&lt;a href=&quot;#footnote-2&quot; id=&quot;citeref-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;でサポートされていないことに注意して&lt;sup&gt;ください&lt;/sup&gt;。特に、 &lt;code&gt;sin&lt;/code&gt; などの一部の関数は &lt;code&gt;CUDAnative.sin&lt;/code&gt; （cc：@maleadt）に置き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="2f019ec46ab9548a295fae40fb32bbf280932bb8" translate="yes" xml:space="preserve">
          <source>Key bindings</source>
          <target state="translated">キーバインディング</target>
        </trans-unit>
        <trans-unit id="74018238351de8a4b5f41ef51f98e3f2c94d5837" translate="yes" xml:space="preserve">
          <source>KeyError</source>
          <target state="translated">KeyError</target>
        </trans-unit>
        <trans-unit id="23f6f8047d85e8db9b2a5eaadf76de7dfe565d74" translate="yes" xml:space="preserve">
          <source>Keybinding</source>
          <target state="translated">Keybinding</target>
        </trans-unit>
        <trans-unit id="59ba1e5a90c9cfee0b263032ac6574298fc3c42e" translate="yes" xml:space="preserve">
          <source>Keycap Ten</source>
          <target state="translated">キーキャップテン</target>
        </trans-unit>
        <trans-unit id="a3926e039fd753c472f6e172496fda0574369261" translate="yes" xml:space="preserve">
          <source>Keyword</source>
          <target state="translated">Keyword</target>
        </trans-unit>
        <trans-unit id="db32172db3cd21ae36313d815fba0dd39bd7127a" translate="yes" xml:space="preserve">
          <source>Keyword Arguments</source>
          <target state="translated">キーワード引数</target>
        </trans-unit>
        <trans-unit id="37a1398f40ad5a5758f3118ecb2e0028c1f656ac" translate="yes" xml:space="preserve">
          <source>Keyword argument &lt;code&gt;debuginfo&lt;/code&gt; may be one of &lt;code&gt;:source&lt;/code&gt; or &lt;code&gt;:none&lt;/code&gt; (default), to specify the verbosity of code comments.</source>
          <target state="translated">キーワード引数 &lt;code&gt;debuginfo&lt;/code&gt; は、コードコメントの詳細度を指定するために、 &lt;code&gt;:source&lt;/code&gt; または &lt;code&gt;:none&lt;/code&gt; （デフォルト）のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="64ff3dfa226c767a3f6429283e3a4ecc260532b6" translate="yes" xml:space="preserve">
          <source>Keyword argument &lt;code&gt;init&lt;/code&gt; is added in Julia 1.5.</source>
          <target state="translated">キーワード引数 &lt;code&gt;init&lt;/code&gt; はJulia1.5で追加されました。</target>
        </trans-unit>
        <trans-unit id="4eec148d4683d6a5be8244fa8544e4bc73995042" translate="yes" xml:space="preserve">
          <source>Keyword argument &lt;code&gt;lazy=true|false&lt;/code&gt; only affects &lt;code&gt;topology&lt;/code&gt; option &lt;code&gt;:all_to_all&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt;, the cluster starts off with the master connected to all workers. Specific worker-worker connections are established at the first remote invocation between two workers. This helps in reducing initial resources allocated for intra-cluster communication. Connections are setup depending on the runtime requirements of a parallel program. Default value for &lt;code&gt;lazy&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">キーワード引数 &lt;code&gt;lazy=true|false&lt;/code&gt; は、 &lt;code&gt;topology&lt;/code&gt; オプション &lt;code&gt;:all_to_all&lt;/code&gt; にのみ影響します。場合は &lt;code&gt;true&lt;/code&gt; 、クラスタは、すべての労働者に接続されたマスタから始まり。2つのワーカー間の最初のリモート呼び出しで、特定のワーカー-ワーカー接続が確立されます。これにより、クラスター内通信に割り当てられる初期リソースを削減できます。接続は、並列プログラムのランタイム要件に応じて設定されます。 &lt;code&gt;lazy&lt;/code&gt; のデフォルト値は &lt;code&gt;true&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a85841ebcc4fbb3f6bb0af53f5f74a1d1107441b" translate="yes" xml:space="preserve">
          <source>Keyword argument default values are evaluated only when necessary (when a corresponding keyword argument is not passed), and in left-to-right order. Therefore default expressions may refer to prior keyword arguments.</source>
          <target state="translated">キーワード引数のデフォルト値は、必要な場合にのみ(対応するキーワード引数が渡されていない場合)、左から右の順に評価されます。そのため、デフォルト式は、それ以前のキーワード引数を参照することがあります。</target>
        </trans-unit>
        <trans-unit id="cd222673b8a5eeb28c17fea40269820af080e4d5" translate="yes" xml:space="preserve">
          <source>Keyword arguments behave quite differently from ordinary positional arguments. In particular, they do not participate in method dispatch. Methods are dispatched based only on positional arguments, with keyword arguments processed after the matching method is identified.</source>
          <target state="translated">キーワード引数は、通常の位置引数とは全く異なる振る舞いをします。特に、キーワード引数はメソッドのディスパッチには参加しません。メソッドは位置引数のみに基づいてディスパッチされ、キーワード引数はマッチするメソッドが特定された後に処理されます。</target>
        </trans-unit>
        <trans-unit id="a802505edaa907c65ced69e373b2128c6752ff80" translate="yes" xml:space="preserve">
          <source>Keyword arguments can also be used in varargs functions:</source>
          <target state="translated">キーワード引数は varargs 関数でも使用できます。</target>
        </trans-unit>
        <trans-unit id="e1f80b2c92c551f95f3994cdc90a44e035d56013" translate="yes" xml:space="preserve">
          <source>Keyword arguments, if any, are passed through to &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">キーワード引数があれば、それが &lt;code&gt;f&lt;/code&gt; に渡されます。</target>
        </trans-unit>
        <trans-unit id="b8804a97595c6605af997f797488e9f7a887cea7" translate="yes" xml:space="preserve">
          <source>Keyword arguments:</source>
          <target state="translated">キーワード引数。</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="e42f478ffbc394a252424af959d3abd0a98e41e6" translate="yes" xml:space="preserve">
          <source>Keywords are also displayed in the suggested methods after &lt;code&gt;;&lt;/code&gt;, see below line where &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;keepempty&lt;/code&gt; are keyword arguments:</source>
          <target state="translated">キーワードは、提案されたメソッドの後にも表示され &lt;code&gt;;&lt;/code&gt; 、以下の行を参照してください。ここで、 &lt;code&gt;limit&lt;/code&gt; および &lt;code&gt;keepempty&lt;/code&gt; はキーワード引数です。</target>
        </trans-unit>
        <trans-unit id="924acc699e5835f0f13e0c55c14fdfbfa6ba40d8" translate="yes" xml:space="preserve">
          <source>Kimono</source>
          <target state="translated">Kimono</target>
        </trans-unit>
        <trans-unit id="4dbc43957024c86f07374b147dcca5a43c62318b" translate="yes" xml:space="preserve">
          <source>Kiss</source>
          <target state="translated">Kiss</target>
        </trans-unit>
        <trans-unit id="23d1162dbd548a5b7ebb3cb6c2092223a1165283" translate="yes" xml:space="preserve">
          <source>Kiss Mark</source>
          <target state="translated">キスマーク</target>
        </trans-unit>
        <trans-unit id="bc19b3dfb9379c314c1b8e3bb9dc5e6a2b26f09b" translate="yes" xml:space="preserve">
          <source>Kissing Cat Face With Closed Eyes</source>
          <target state="translated">目を閉じたままキスをする猫の顔</target>
        </trans-unit>
        <trans-unit id="b58aa4e85bf24740360e2d6b347305a564dca4a1" translate="yes" xml:space="preserve">
          <source>Kissing Face</source>
          <target state="translated">キス顔</target>
        </trans-unit>
        <trans-unit id="2fe6ec1bfe77e7354379b52c0bee899a96c21add" translate="yes" xml:space="preserve">
          <source>Kissing Face With Closed Eyes</source>
          <target state="translated">目を閉じたままのキス顔</target>
        </trans-unit>
        <trans-unit id="fcaff6a193904e107dc7d4aa4f3190493c405457" translate="yes" xml:space="preserve">
          <source>Kissing Face With Smiling Eyes</source>
          <target state="translated">笑顔でキスをする顔</target>
        </trans-unit>
        <trans-unit id="74ae77190d30e9483b1024a2bf19d64715a77757" translate="yes" xml:space="preserve">
          <source>Koala</source>
          <target state="translated">Koala</target>
        </trans-unit>
        <trans-unit id="9afe7e71a0cd3f5b45d3038779f47e6ab11c4a9d" translate="yes" xml:space="preserve">
          <source>Konstantinos Konstantinides and Kung Yao, &quot;Statistical analysis of effective singular values in matrix rank determination&quot;, IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. &lt;a href=&quot;https://doi.org/10.1109/29.1585&quot;&gt;doi:10.1109/29.1585&lt;/a&gt;</source>
          <target state="translated">Konstantinos KonstantinidesおよびKung Yao、「行列ランクの決定における有効な特異値の統計分析」、IEEE Transactions on Acoustics、Speech and Signal Processing、36（5）、1988、757-763。&lt;a href=&quot;https://doi.org/10.1109/29.1585&quot;&gt;doi：10.1109 / 29.1585&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4a94c6e095d242bfd65b4080bf588284c946f8c" translate="yes" xml:space="preserve">
          <source>Kronecker tensor product of two vectors or two matrices.</source>
          <target state="translated">2つのベクトルまたは2つの行列のクロネッカーテンソル積。</target>
        </trans-unit>
        <trans-unit id="cf9e7dcbce935737e3132c8567095e62b32e357d" translate="yes" xml:space="preserve">
          <source>LAPACK</source>
          <target state="translated">LAPACK</target>
        </trans-unit>
        <trans-unit id="d4e9710203cf5806e211a4382bda892c104cc46d" translate="yes" xml:space="preserve">
          <source>LAPACK Functions</source>
          <target state="translated">ラパック機能</target>
        </trans-unit>
        <trans-unit id="d12a2cf0b16bda2d0e8799f01c41ee6d60d4d6a5" translate="yes" xml:space="preserve">
          <source>LAPACK functions</source>
          <target state="translated">ラパック機能</target>
        </trans-unit>
        <trans-unit id="a7f1b6f39a46d5337c0aad867bbe073b5b049053" translate="yes" xml:space="preserve">
          <source>LDL(T) factorization</source>
          <target state="translated">LDL(T)因数分解</target>
        </trans-unit>
        <trans-unit id="b4aff6bdb4998cc3553c7001845a94833e9f4e43" translate="yes" xml:space="preserve">
          <source>LDLt (see &lt;a href=&quot;#LinearAlgebra.ldlt&quot;&gt;&lt;code&gt;ldlt&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">LDLt（参照&lt;a href=&quot;#LinearAlgebra.ldlt&quot;&gt; &lt;code&gt;ldlt&lt;/code&gt; を&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="26214decf703290192f10270d6b0b515c7511762" translate="yes" xml:space="preserve">
          <source>LLVM Interface</source>
          <target state="translated">LLVMインタフェース</target>
        </trans-unit>
        <trans-unit id="f5f4f14ed2c38473c6c2d9123249c93ff3ece227" translate="yes" xml:space="preserve">
          <source>LOAD_PATH</source>
          <target state="translated">LOAD_PATH</target>
        </trans-unit>
        <trans-unit id="160e7ef90659bedaf209eec44edbbe3caf988121" translate="yes" xml:space="preserve">
          <source>LU (see &lt;a href=&quot;#LinearAlgebra.lu&quot;&gt;&lt;code&gt;lu&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">LU（&lt;a href=&quot;#LinearAlgebra.lu&quot;&gt; &lt;code&gt;lu&lt;/code&gt; を&lt;/a&gt;参照）</target>
        </trans-unit>
        <trans-unit id="23dbe335a346e4f78af48a087f0c1292440d8cc7" translate="yes" xml:space="preserve">
          <source>LU factorization</source>
          <target state="translated">LU因数分解</target>
        </trans-unit>
        <trans-unit id="a905567226043f1b393e816a77aec998343c78b4" translate="yes" xml:space="preserve">
          <source>LU factorization for &lt;a href=&quot;#LinearAlgebra.Tridiagonal&quot;&gt;&lt;code&gt;Tridiagonal&lt;/code&gt;&lt;/a&gt; matrices</source>
          <target state="translated">&lt;a href=&quot;#LinearAlgebra.Tridiagonal&quot;&gt; &lt;code&gt;Tridiagonal&lt;/code&gt; &lt;/a&gt;行列のLU分解</target>
        </trans-unit>
        <trans-unit id="366152a7d098555665a4453404d639ac8b476b7a" translate="yes" xml:space="preserve">
          <source>Labels a statement with the symbolic label &lt;code&gt;name&lt;/code&gt;. The label marks the end-point of an unconditional jump with &lt;a href=&quot;#Base.@goto&quot;&gt;&lt;code&gt;@goto name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ステートメントに記号ラベル &lt;code&gt;name&lt;/code&gt; ます。ラベルは、無条件ジャンプの終了点を&lt;a href=&quot;#Base.@goto&quot;&gt; &lt;code&gt;@goto name&lt;/code&gt; &lt;/a&gt;でマークします。</target>
        </trans-unit>
        <trans-unit id="ff8f52e27fbdf435514705d351e8d01e3dd57b73" translate="yes" xml:space="preserve">
          <source>Lady Beetle</source>
          <target state="translated">レディビートル</target>
        </trans-unit>
        <trans-unit id="4dee08e75e78fb7f2ea26537626acf062390bc00" translate="yes" xml:space="preserve">
          <source>Large $\LaTeX$ equations that do not fit inline within a paragraph may be written as display equations using a fenced code block with the &quot;language&quot; &lt;code&gt;math&lt;/code&gt; as in the example below.</source>
          <target state="translated">段落内にインラインで収まらない大きな$ \ LaTeX $方程式は、以下の例のように「言語」 &lt;code&gt;math&lt;/code&gt; を使用したフェンス付きコードブロックを使用して、表示方程式として記述できます。</target>
        </trans-unit>
        <trans-unit id="8f95211a940e3d08b42c29bbf9dbc496ccfe208b" translate="yes" xml:space="preserve">
          <source>Large Blue Circle</source>
          <target state="translated">大きなブルーの円</target>
        </trans-unit>
        <trans-unit id="68e7dfd86e1bad5177b243cce59909605d2d63ff" translate="yes" xml:space="preserve">
          <source>Large Blue Diamond</source>
          <target state="translated">大粒のブルーダイヤモンド</target>
        </trans-unit>
        <trans-unit id="1489faea46cdb0a914888faa83aaccbf1a1018b6" translate="yes" xml:space="preserve">
          <source>Large Circle</source>
          <target state="translated">ラージサークル</target>
        </trans-unit>
        <trans-unit id="47d39efcf737a8cb7cff31b45c3eae3b9768a070" translate="yes" xml:space="preserve">
          <source>Large Down Tack</source>
          <target state="translated">ラージダウンタック</target>
        </trans-unit>
        <trans-unit id="19d1a6d4bde006ab21ff3b1a9ce0c5b1f656efbe" translate="yes" xml:space="preserve">
          <source>Large Orange Diamond</source>
          <target state="translated">ラージオレンジダイヤモンド</target>
        </trans-unit>
        <trans-unit id="2be06620aa858eeb1cfd65e452ba545d7194c263" translate="yes" xml:space="preserve">
          <source>Large Red Circle</source>
          <target state="translated">大赤丸</target>
        </trans-unit>
        <trans-unit id="93780c9bf758bfc5b064c94682265b362eac13d6" translate="yes" xml:space="preserve">
          <source>Large Up Tack</source>
          <target state="translated">ラージアップタック</target>
        </trans-unit>
        <trans-unit id="c567cf1fe685a9b85ba876a5fdec9645963ce55b" translate="yes" xml:space="preserve">
          <source>Large modules can take several seconds to load because executing all of the statements in a module often involves compiling a large amount of code. Julia creates precompiled caches of the module to reduce this time.</source>
          <target state="translated">大規模なモジュールは、モジュール内のすべてのステートメントを実行すると大量のコードをコンパイルする必要があるため、ロードに数秒かかることがあります。Julia はこの時間を短縮するためにモジュールのコンパイル済みキャッシュを作成します。</target>
        </trans-unit>
        <trans-unit id="836cd86751bc175f6a1c3513d9545f0269900a32" translate="yes" xml:space="preserve">
          <source>Larger Than</source>
          <target state="translated">より大きい</target>
        </trans-unit>
        <trans-unit id="8fc4e576fc574f75bb7c600973def67858d8bb40" translate="yes" xml:space="preserve">
          <source>Larger Than Or Equal To</source>
          <target state="translated">以上</target>
        </trans-unit>
        <trans-unit id="d737eee8172d65bba64271f9c8b335b8b815d284" translate="yes" xml:space="preserve">
          <source>Larger integer literals that cannot be represented using only 32 bits but can be represented in 64 bits always create 64-bit integers, regardless of the system type:</source>
          <target state="translated">32 ビットだけでは表現できないが 64 ビットで表現できる大きな整数リテラルは、システムの型に関係なく常に 64 ビットの整数を作成します。</target>
        </trans-unit>
        <trans-unit id="2c5201c8ea16b6383c4f6c269ee86f7c5d37bb84" translate="yes" xml:space="preserve">
          <source>Largest integer less than or equal to &lt;code&gt;x/y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x/y&lt;/code&gt; 以下の最大の整数。</target>
        </trans-unit>
        <trans-unit id="b1b42ea4b0b1e511fffb01ce016fa0bdcff72dd5" translate="yes" xml:space="preserve">
          <source>Largest integer less than or equal to &lt;code&gt;x/y&lt;/code&gt;. Equivalent to &lt;code&gt;div(x, y, RoundDown)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x/y&lt;/code&gt; 以下の最大の整数。相当 &lt;code&gt;div(x, y, RoundDown)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45e54723a9bf0cd3ba0bd2155ce7b7bac5bfafd9" translate="yes" xml:space="preserve">
          <source>Largest value</source>
          <target state="translated">最大値</target>
        </trans-unit>
        <trans-unit id="af72fbc94064a4c9a0a644731e497dc5dc7beff9" translate="yes" xml:space="preserve">
          <source>Last Quarter Moon</source>
          <target state="translated">ラストクォータームーン</target>
        </trans-unit>
        <trans-unit id="4d7f319a09451056e084d65cad158f125e2020cc" translate="yes" xml:space="preserve">
          <source>Last Quarter Moon Symbol</source>
          <target state="translated">ラストクォータームーンのシンボル</target>
        </trans-unit>
        <trans-unit id="a7b4069351f71ce4f08da44121a5414042cbca4b" translate="yes" xml:space="preserve">
          <source>Last Quarter Moon With Face</source>
          <target state="translated">顔のある最後の四半期の月</target>
        </trans-unit>
        <trans-unit id="18cf37d7758974150aba5efc169a132701c98591" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter A With Ring Above / Latin Capital Letter A Ring</source>
          <target state="translated">ラテン文字の大文字のAとリングの上に/ラテン文字の大文字のAリング</target>
        </trans-unit>
        <trans-unit id="387186c7a8fff866e6fbacb8a7a99c078e963118" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Ae / Latin Capital Letter A E</source>
          <target state="translated">ラテン語の大文字 Ae/ラテン語の大文字 A E</target>
        </trans-unit>
        <trans-unit id="f2c0864bdd70eeadaffc0e4bf8122d6178ff53bb" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter D With Stroke / Latin Capital Letter D Bar</source>
          <target state="translated">ラテン語の大文字Dとストローク/ラテン語の大文字Dバー</target>
        </trans-unit>
        <trans-unit id="18ee11f5dfc96b5ea1e522af1744aced409d9ff1" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Eng</source>
          <target state="translated">ラテンキャピタルレターエンゲージ</target>
        </trans-unit>
        <trans-unit id="7e38029cb2d0c6ce87bf45f5170886022a280556" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Eth</source>
          <target state="translated">ラテンキャピタルレター エチオピア</target>
        </trans-unit>
        <trans-unit id="261b92b2c69498043ebd035666aae447dd5fc40c" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter L With Stroke / Latin Capital Letter L Slash</source>
          <target state="translated">ラテン語の大文字Lとストローク/ラテン語の大文字Lスラッシュ</target>
        </trans-unit>
        <trans-unit id="81f5aedd8e8fccac1ab8a6bc67c43be5b7c7e7f6" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter O With Stroke / Latin Capital Letter O Slash</source>
          <target state="translated">ラテン文字の大文字のOとストローク/ラテン文字の大文字のOスラッシュ</target>
        </trans-unit>
        <trans-unit id="3e1d1bce5c9a11240957721f8ef29a635e048ab3" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Thorn</source>
          <target state="translated">ラテンキャピタルレターソーン</target>
        </trans-unit>
        <trans-unit id="4b4cf2ef98d43801be6875ab83c9e3c993eddbbb" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Z With Stroke / Latin Capital Letter Z Bar</source>
          <target state="translated">ラテン語の大文字Zとストローク/ラテン語の大文字Zバー</target>
        </trans-unit>
        <trans-unit id="5ae3e818634045d7a9130d2b676f3527521e0150" translate="yes" xml:space="preserve">
          <source>Latin Capital Ligature Oe / Latin Capital Letter O E</source>
          <target state="translated">ラテンキャピタル リガチャー Oe/ラテンキャピタル レター O E</target>
        </trans-unit>
        <trans-unit id="957520bb4ae3c78ec831bd317cdfd85081025ee6" translate="yes" xml:space="preserve">
          <source>Latin Letter Alveolar Click / Latin Letter Pipe Double Bar</source>
          <target state="translated">ラテン文字歯槽骨クリック/ラテン文字パイプダブルバー</target>
        </trans-unit>
        <trans-unit id="43073b60cf8171df59d1497357356aa7115c7db3" translate="yes" xml:space="preserve">
          <source>Latin Letter Glottal Stop</source>
          <target state="translated">ラテン文字グロタールストップ</target>
        </trans-unit>
        <trans-unit id="fc36244b6362ae3e3d6d20e2d335c02a7af88997" translate="yes" xml:space="preserve">
          <source>Latin Letter Inverted Glottal Stop</source>
          <target state="translated">ラテン文字反転グロタールストップ</target>
        </trans-unit>
        <trans-unit id="680f41038e731ff5fdc7bf24ce99313a70d99990" translate="yes" xml:space="preserve">
          <source>Latin Letter Pharyngeal Voiced Fricative / Latin Letter Reversed Glottal Stop</source>
          <target state="translated">ラテン文字の咽頭ヴォイスド・フリカティヴ/ラテン文字の逆口唇ストップ</target>
        </trans-unit>
        <trans-unit id="7e9e2bfa072cd28ac12f89b807c22a2d9b6b5f07" translate="yes" xml:space="preserve">
          <source>Latin Small Letter A With Ring Above / Latin Small Letter A Ring</source>
          <target state="translated">ラテン語の小さな文字Aの上にリングが付いている/ラテン語の小さな文字Aリング</target>
        </trans-unit>
        <trans-unit id="aeaa4f1f1687667c2f5fc22a10bca6a0268c7e52" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Ae / Latin Small Letter A E</source>
          <target state="translated">ラテン語のスモールレターAe/ラテン語のスモールレターA E</target>
        </trans-unit>
        <trans-unit id="bd81bee974151364620b17177c4955612e0e03fa" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Closed Omega</source>
          <target state="translated">ラテンスモールレター クローズドオメガ</target>
        </trans-unit>
        <trans-unit id="c4abfd40c74b3eb74040658788c6847cb7128777" translate="yes" xml:space="preserve">
          <source>Latin Small Letter D With Stroke / Latin Small Letter D Bar</source>
          <target state="translated">ラテン語のスモールレターDとストローク/ラテン語のスモールレターDバー</target>
        </trans-unit>
        <trans-unit id="79664c84e38ddc705c095d22df17f6ba110cb657" translate="yes" xml:space="preserve">
          <source>Latin Small Letter D With Tail / Latin Small Letter D Retroflex Hook</source>
          <target state="translated">ラテンスモールレターD テール付き/ラテンスモールレターD レトロフレックスフック</target>
        </trans-unit>
        <trans-unit id="0bae965510de34e4507ca1c9f6442e6f063065a8" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Dezh Digraph / Latin Small Letter D Yogh</source>
          <target state="translated">ラテン語の小文字Dezh Digraph/ラテン語の小文字D Yogh</target>
        </trans-unit>
        <trans-unit id="93c7ebd3f43b49c98f8c0737391432699e082aa6" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Dotless I</source>
          <target state="translated">ラテン語の小文字ドットレスI</target>
        </trans-unit>
        <trans-unit id="0639f709a04d29a7d92f491504f4b15becbc375e" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Dotless J</source>
          <target state="translated">ラテンスモールレタードットレスJ</target>
        </trans-unit>
        <trans-unit id="cf365327a81aadb5e405df4d0f48b32472c24b2e" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Eng</source>
          <target state="translated">ラテン語のスモールレターエンゲージ</target>
        </trans-unit>
        <trans-unit id="93c2ec38cecdf8e443b85db5de563a216ffd9d34" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Esh</source>
          <target state="translated">ラテン語の小文字エッシュ</target>
        </trans-unit>
        <trans-unit id="2e8a26241b482f37e00adb250b979246ca85beea" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Eth</source>
          <target state="translated">ラテン語の小さな文字 エチオピア語</target>
        </trans-unit>
        <trans-unit id="40104027bfc2f3a58be7509f94be97c17e39f2f9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Ezh / Latin Small Letter Yogh</source>
          <target state="translated">ラテン語の小文字Ezh/ラテン語の小文字Yogh</target>
        </trans-unit>
        <trans-unit id="f9e515806fd1b60b14e5fc8f3af7f90ac6e9364a" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Gamma</source>
          <target state="translated">ラテン語の小文字ガンマ</target>
        </trans-unit>
        <trans-unit id="97085caf81a24ef927fdc386fc6b04e27e1f72b9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter H With Stroke / Latin Small Letter H Bar</source>
          <target state="translated">ラテン語の小さな文字Hとストローク/ラテン語の小さな文字Hバー</target>
        </trans-unit>
        <trans-unit id="399d282443390fef914db664bba2883747b928af" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Hv / Latin Small Letter H V</source>
          <target state="translated">ラテン語のスモールレターHv/ラテン語のスモールレターH V</target>
        </trans-unit>
        <trans-unit id="2422e4f11c03b366715aa80ec860fc60eae0c461" translate="yes" xml:space="preserve">
          <source>Latin Small Letter L With Belt / Latin Small Letter L Belt</source>
          <target state="translated">ベルト付きラテンスモールレターL/ラテンスモールレターLベルト</target>
        </trans-unit>
        <trans-unit id="82d31c79255d3b522eb37fa11b7bb67ebf6d75a1" translate="yes" xml:space="preserve">
          <source>Latin Small Letter L With Retroflex Hook / Latin Small Letter L Retroflex Hook</source>
          <target state="translated">ラテンスモールレターL レトロフレックスフック付き/ラテンスモールレターL レトロフレックスフック</target>
        </trans-unit>
        <trans-unit id="432e37bd3e31540f66f1af3dfdcfd97516ca52f9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter L With Stroke / Latin Small Letter L Slash</source>
          <target state="translated">ラテン語のスモールレターLとストローク/ラテン語のスモールレターLスラッシュ</target>
        </trans-unit>
        <trans-unit id="c6dc1b09cb591ac95922c661ff9481278d4d2de7" translate="yes" xml:space="preserve">
          <source>Latin Small Letter M With Hook / Latin Small Letter M Hook</source>
          <target state="translated">ラテンスモールレターM フック付き/ラテンスモールレターM フック</target>
        </trans-unit>
        <trans-unit id="0218525707cb4bb564235a036cc2842ec67b0748" translate="yes" xml:space="preserve">
          <source>Latin Small Letter N With Left Hook / Latin Small Letter N Hook</source>
          <target state="translated">左フック付きラテンスモールレターN/ラテンスモールレターNフック</target>
        </trans-unit>
        <trans-unit id="b20690f24cf5bf99ca0c7018eee110ebe0e15a04" translate="yes" xml:space="preserve">
          <source>Latin Small Letter N With Long Right Leg</source>
          <target state="translated">ラテン語の小さな文字Nと長い右足</target>
        </trans-unit>
        <trans-unit id="31ec66aaa00a79d775f1c857d59f5c7a74247d09" translate="yes" xml:space="preserve">
          <source>Latin Small Letter N With Retroflex Hook / Latin Small Letter N Retroflex Hook</source>
          <target state="translated">ラテンスモールレターN ウィズ レトロフレックスフック/ラテンスモールレターN レトロフレックスフック</target>
        </trans-unit>
        <trans-unit id="7874ede875d3c7ae94e73df07ed062477861ae44" translate="yes" xml:space="preserve">
          <source>Latin Small Letter O With Stroke / Latin Small Letter O Slash</source>
          <target state="translated">ラテン語のスモールレターOとストローク/ラテン語のスモールレターOスラッシュ</target>
        </trans-unit>
        <trans-unit id="07add9523a52497c0c262c0382ad46de39eb16bd" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Open O</source>
          <target state="translated">ラテン語の小文字オープンオー</target>
        </trans-unit>
        <trans-unit id="1b7b0f5e96e58726dfbb7a30f8602204b9a71f82" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Phi</source>
          <target state="translated">ラテン語の小さな文字ファイ</target>
        </trans-unit>
        <trans-unit id="ff12afa374c372c8fc23589cff50c4ee6f2f6cde" translate="yes" xml:space="preserve">
          <source>Latin Small Letter R With Fishhook / Latin Small Letter Fishhook R</source>
          <target state="translated">フィッシュフック付きラテンスモールレターR/ラテンスモールレターフィッシュフックR</target>
        </trans-unit>
        <trans-unit id="591234998559d2fb9e34782769a6a85e552ca14a" translate="yes" xml:space="preserve">
          <source>Latin Small Letter R With Long Leg</source>
          <target state="translated">ラテン語の小さな文字Rと長い足</target>
        </trans-unit>
        <trans-unit id="c1a50f7f5584c407c2b721281ea3abe4e34d13d4" translate="yes" xml:space="preserve">
          <source>Latin Small Letter R With Tail / Latin Small Letter R Hook</source>
          <target state="translated">ラテンスモールレターR ウィズ テール/ラテンスモールレターRフック</target>
        </trans-unit>
        <trans-unit id="ef19cd34955161980d339367d254aafdd02b4cb7" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Rams Horn / Latin Small Letter Baby Gamma</source>
          <target state="translated">ラテンスモールレター ラムズホーン/ラテンスモールレター ベビーガンマ</target>
        </trans-unit>
        <trans-unit id="bf1d74257f1f62e2e52e3dc8b76fe85f6a2c3e96" translate="yes" xml:space="preserve">
          <source>Latin Small Letter S With Hook / Latin Small Letter S Hook</source>
          <target state="translated">ラテン語のスモールレターS フック付き/ラテン語のスモールレターS フック</target>
        </trans-unit>
        <trans-unit id="f17b9219c1288784e62e066762b90b3f1e0e55a8" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Schwa</source>
          <target state="translated">ラテン語のスモールレターシュワ</target>
        </trans-unit>
        <trans-unit id="19e904077d5fb0771a0c4bf22aebcb8d18879d02" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Sharp S</source>
          <target state="translated">ラテン語の小文字シャープS</target>
        </trans-unit>
        <trans-unit id="4e3c130c920943099dd727660677e4cfb89ea723" translate="yes" xml:space="preserve">
          <source>Latin Small Letter T With Retroflex Hook / Latin Small Letter T Retroflex Hook</source>
          <target state="translated">ラテンスモールレターT(レトロフレックスフック付き)/ラテンスモールレターTレトロフレックスフック</target>
        </trans-unit>
        <trans-unit id="b4aa5dce4f194d4f86cea8db7ef720a452c10472" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Tesh Digraph / Latin Small Letter T Esh</source>
          <target state="translated">ラテン語の小文字Teshディグラフ/ラテン語の小文字T Esh</target>
        </trans-unit>
        <trans-unit id="9a88a6a40f3264cff644fc36d6ea39b7e80dee4b" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Thorn</source>
          <target state="translated">ラテン語の小文字のとげ</target>
        </trans-unit>
        <trans-unit id="206fdfa3558c503d9e843533aa39ca8750c5100a" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned A</source>
          <target state="translated">ラテン語の小さな文字がAになった</target>
        </trans-unit>
        <trans-unit id="44391e675633f27178e360e38182fb1c89dcc786" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned Alpha / Latin Small Letter Turned Script A</source>
          <target state="translated">ラテン語の小文字がアルファになった/ラテン語の小文字がスクリプトAになった</target>
        </trans-unit>
        <trans-unit id="a45dfaa69d6b3db6daa54b07a19c0a16bc93f9c4" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned H</source>
          <target state="translated">ラテン語の小さな文字がHになった</target>
        </trans-unit>
        <trans-unit id="d0a8378f24aaa4a7fd08ad76eab02d85f9db34c3" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned K</source>
          <target state="translated">ラテン語の小字ターンK</target>
        </trans-unit>
        <trans-unit id="f60605b6d90f4154d38bac9031c2a73d3e7fb2fd" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned M</source>
          <target state="translated">ラテン系小文字ターンドM</target>
        </trans-unit>
        <trans-unit id="80870744996553dd1a355c5c68035612071c93d5" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned M With Long Leg</source>
          <target state="translated">ラテンの小さな手紙は長い足でMを回した</target>
        </trans-unit>
        <trans-unit id="4e330127b9bd74c3ac0ed39785e51192a2a6804b" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned R</source>
          <target state="translated">ラテン語の小さな文字がRになった</target>
        </trans-unit>
        <trans-unit id="7f2283c2045b7461f57d11ba1b67518361b943d3" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned R With Hook / Latin Small Letter Turned R Hook</source>
          <target state="translated">ラテン語の小さな手紙はフック付きのRを回した/ラテン語の小さな手紙はRフックを回した</target>
        </trans-unit>
        <trans-unit id="78ca75233c25b210f82d0fa683b1e829340273d9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned R With Long Leg</source>
          <target state="translated">ラテン語の小さな文字は、長い足でRを回した</target>
        </trans-unit>
        <trans-unit id="b693ad995bba90f1295c3eb3fa51e43c784b64eb" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned T</source>
          <target state="translated">ラテン語の小さな文字がT字になった</target>
        </trans-unit>
        <trans-unit id="5209a0d49366580ead3e1dad9d6ff2475775f51f" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned V</source>
          <target state="translated">ラテン語の小さな文字がV字になった</target>
        </trans-unit>
        <trans-unit id="450f985cc65d78122edf815571e08094f13be358" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned W</source>
          <target state="translated">ラテン語の小文字ターンドW</target>
        </trans-unit>
        <trans-unit id="d4b68356f1e5f3312b5bc8059eb8f75757a7c22d" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned Y</source>
          <target state="translated">ラテン語の小字ターンY</target>
        </trans-unit>
        <trans-unit id="1c50afa8247e2b596bb5484c0bdf31af4356cb8d" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Upsilon</source>
          <target state="translated">ラテン語の小文字アップシロン</target>
        </trans-unit>
        <trans-unit id="cf80e9e2586cd62109287c1d07560fe914a80d16" translate="yes" xml:space="preserve">
          <source>Latin Small Letter V With Hook / Latin Small Letter Script V</source>
          <target state="translated">フック付きラテンスモールレターV/ラテンスモールレタースクリプトV</target>
        </trans-unit>
        <trans-unit id="6a5f81b7b582dc216e4c1f24b62d26cf5af68967" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Z With Retroflex Hook / Latin Small Letter Z Retroflex Hook</source>
          <target state="translated">ラテンスモールレターZ レトロフレックスフック付き/ラテンスモールレターZ レトロフレックスフック</target>
        </trans-unit>
        <trans-unit id="e2c17f6ce613463c3e30d1a4aed82bceb3d0bf26" translate="yes" xml:space="preserve">
          <source>Latin Small Ligature Oe / Latin Small Letter O E</source>
          <target state="translated">ラテンスモールリガチャーOe/ラテンスモールレターO E</target>
        </trans-unit>
        <trans-unit id="ab095c443113e11acf431c2bb30a86ce8ce57bb6" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter A</source>
          <target state="translated">ラテン語の下付き小文字A</target>
        </trans-unit>
        <trans-unit id="fff77fcf01dc719ec1ab77e81e213e93b8d0115a" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter E</source>
          <target state="translated">ラテン語の添え字小文字E</target>
        </trans-unit>
        <trans-unit id="363c386941760c298d65628800930f8354b1c700" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter H</source>
          <target state="translated">ラテン語の添え字小文字H</target>
        </trans-unit>
        <trans-unit id="982401be038720a241d1e68deecf4cf7746b55ab" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter I</source>
          <target state="translated">ラテン語の添え字小文字I</target>
        </trans-unit>
        <trans-unit id="f36b34411ebc69050abaa08db12014b29b018b19" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter J</source>
          <target state="translated">ラテン語の下付き小文字J</target>
        </trans-unit>
        <trans-unit id="5d9192cce944b6338e9e19cf0e5aff75bc6458e0" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter K</source>
          <target state="translated">ラテン語の添え字小文字K</target>
        </trans-unit>
        <trans-unit id="98e7def8db7a6c66ec697114dd36225f86e432d0" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter L</source>
          <target state="translated">ラテン語の下付き小文字L</target>
        </trans-unit>
        <trans-unit id="c88fe2a6e8d4931c9b29a2de9c39672213e2a09e" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter M</source>
          <target state="translated">ラテン語の添え字小文字M</target>
        </trans-unit>
        <trans-unit id="09020dd38fd21fc2f0e9c9b2f5cd4719b876181a" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter N</source>
          <target state="translated">ラテン語の添え字小文字N</target>
        </trans-unit>
        <trans-unit id="bf874a171794f22663d7decf77255804ee48a4b5" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter O</source>
          <target state="translated">ラテン語の添え字小文字O</target>
        </trans-unit>
        <trans-unit id="2f2d68aab8bef5631b7658f2f25cb157fe1312d8" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter P</source>
          <target state="translated">ラテン語の添え字小文字P</target>
        </trans-unit>
        <trans-unit id="6ae5998c63d2b847c715037212f1596e577e11d8" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter R</source>
          <target state="translated">ラテン語の下付き小文字R</target>
        </trans-unit>
        <trans-unit id="cbfb24f449387bbaf3bab5247af9c1ad7c5a2e87" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter S</source>
          <target state="translated">ラテン語の下付き小文字S</target>
        </trans-unit>
        <trans-unit id="54984068e00469db35d3a41626ebb9a634073396" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter Schwa</source>
          <target state="translated">ラテン語の下付き小字シュワ</target>
        </trans-unit>
        <trans-unit id="24e9ea8cb7bc17431bfd5069bebcda4cd2e0d7f4" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter T</source>
          <target state="translated">ラテン語の下付き小文字T</target>
        </trans-unit>
        <trans-unit id="c11091f07852038d224bf6a198262288070ac4af" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter U</source>
          <target state="translated">ラテン語の下付き小文字U</target>
        </trans-unit>
        <trans-unit id="59e0fc501529d38b3e42a1402845967ae6868b9c" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter V</source>
          <target state="translated">ラテン語の下付き小文字V</target>
        </trans-unit>
        <trans-unit id="87def54837d4f750a3ac2cc91c670222eecf573b" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter X</source>
          <target state="translated">ラテン語の下付き小文字X</target>
        </trans-unit>
        <trans-unit id="96f66def5d4a8c399dd4712422d81130f5b17cc9" translate="yes" xml:space="preserve">
          <source>Launches worker processes via the specified cluster manager.</source>
          <target state="translated">指定されたクラスタマネージャを介してワーカープロセスを起動します。</target>
        </trans-unit>
        <trans-unit id="230ffdc98fdacb0f873a14dccabfdda12422305b" translate="yes" xml:space="preserve">
          <source>Launches workers using the in-built &lt;code&gt;LocalManager&lt;/code&gt; which only launches workers on the local host. This can be used to take advantage of multiple cores. &lt;code&gt;addprocs(4)&lt;/code&gt; will add 4 processes on the local machine. If &lt;code&gt;restrict&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, binding is restricted to &lt;code&gt;127.0.0.1&lt;/code&gt;. Keyword args &lt;code&gt;dir&lt;/code&gt;, &lt;code&gt;exename&lt;/code&gt;, &lt;code&gt;exeflags&lt;/code&gt;, &lt;code&gt;topology&lt;/code&gt;, &lt;code&gt;lazy&lt;/code&gt; and &lt;code&gt;enable_threaded_blas&lt;/code&gt; have the same effect as documented for &lt;code&gt;addprocs(machines)&lt;/code&gt;.</source>
          <target state="translated">ローカルホストでのみワーカーを起動する組み込みの &lt;code&gt;LocalManager&lt;/code&gt; を使用してワーカーを起動します。これは、複数のコアを利用するために使用できます。 &lt;code&gt;addprocs(4)&lt;/code&gt; は、ローカルマシンに4つのプロセスを追加します。場合は &lt;code&gt;restrict&lt;/code&gt; され &lt;code&gt;true&lt;/code&gt; 、結合はに制限されている &lt;code&gt;127.0.0.1&lt;/code&gt; 。キーワードargs &lt;code&gt;dir&lt;/code&gt; 、 &lt;code&gt;exename&lt;/code&gt; 、 &lt;code&gt;exeflags&lt;/code&gt; 、 &lt;code&gt;topology&lt;/code&gt; 、 &lt;code&gt;lazy&lt;/code&gt; および &lt;code&gt;enable_threaded_blas&lt;/code&gt; は、 &lt;code&gt;addprocs(machines)&lt;/code&gt; で説明されているのと同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="5651fa0fd68350a3db0e0ce46acc644a6f99f032" translate="yes" xml:space="preserve">
          <source>Lazy adjoint (conjugate transposition) (also postfix &lt;code&gt;'&lt;/code&gt;). Note that &lt;code&gt;adjoint&lt;/code&gt; is applied recursively to elements.</source>
          <target state="translated">遅延随伴（共役転置）（後置 &lt;code&gt;'&lt;/code&gt; も）。 &lt;code&gt;adjoint&lt;/code&gt; は要素に再帰的に適用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1a484bd65bd99903b9e6433e56a7ce5feb1a88b4" translate="yes" xml:space="preserve">
          <source>Lazy adjoint (conjugate transposition). Note that &lt;code&gt;adjoint&lt;/code&gt; is applied recursively to elements.</source>
          <target state="translated">怠惰な随伴（共役転置）。 &lt;code&gt;adjoint&lt;/code&gt; は要素に再帰的に適用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4dabe105e2961d8642efb76e1ebd7539fca5122b" translate="yes" xml:space="preserve">
          <source>Lazy transpose. Mutating the returned object should appropriately mutate &lt;code&gt;A&lt;/code&gt;. Often, but not always, yields &lt;code&gt;Transpose(A)&lt;/code&gt;, where &lt;code&gt;Transpose&lt;/code&gt; is a lazy transpose wrapper. Note that this operation is recursive.</source>
          <target state="translated">遅延転置。返されたオブジェクトを変更すると、 &lt;code&gt;A&lt;/code&gt; が適切に変更されます。多くの場合、常にではありませんが、 &lt;code&gt;Transpose(A)&lt;/code&gt; が生成されます。ここで、 &lt;code&gt;Transpose&lt;/code&gt; は遅延転置ラッパーです。この操作は再帰的であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="52790bab6c96ca4ca79f6c9dcbc5f04f90742a02" translate="yes" xml:space="preserve">
          <source>Lazy wrapper type for a transpose view of the underlying linear algebra object, usually an &lt;code&gt;AbstractVector&lt;/code&gt;/&lt;code&gt;AbstractMatrix&lt;/code&gt;, but also some &lt;code&gt;Factorization&lt;/code&gt;, for instance. Usually, the &lt;code&gt;Transpose&lt;/code&gt; constructor should not be called directly, use &lt;a href=&quot;#Base.transpose&quot;&gt;&lt;code&gt;transpose&lt;/code&gt;&lt;/a&gt; instead. To materialize the view use &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">基になる線形代数オブジェクトの転置ビューのレイジーラッパータイプ。通常は &lt;code&gt;AbstractVector&lt;/code&gt; / &lt;code&gt;AbstractMatrix&lt;/code&gt; ですが、たとえば、いくつかの &lt;code&gt;Factorization&lt;/code&gt; もあります。通常、 &lt;code&gt;Transpose&lt;/code&gt; コンストラクターを直接呼び出すことはできません。代わりに&lt;a href=&quot;#Base.transpose&quot;&gt; &lt;code&gt;transpose&lt;/code&gt; を&lt;/a&gt;使用してください。ビューを具体化するには、&lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="ea87c3f92c6c2a81bda14868b1fa3651e1788be6" translate="yes" xml:space="preserve">
          <source>Lazy wrapper type for an adjoint view of the underlying linear algebra object, usually an &lt;code&gt;AbstractVector&lt;/code&gt;/&lt;code&gt;AbstractMatrix&lt;/code&gt;, but also some &lt;code&gt;Factorization&lt;/code&gt;, for instance. Usually, the &lt;code&gt;Adjoint&lt;/code&gt; constructor should not be called directly, use &lt;a href=&quot;#Base.adjoint&quot;&gt;&lt;code&gt;adjoint&lt;/code&gt;&lt;/a&gt; instead. To materialize the view use &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">基になる線形代数オブジェクトの随伴ビューのレイジーラッパータイプ。通常は &lt;code&gt;AbstractVector&lt;/code&gt; / &lt;code&gt;AbstractMatrix&lt;/code&gt; ですが、たとえば、いくつかの &lt;code&gt;Factorization&lt;/code&gt; もあります。通常、 &lt;code&gt;Adjoint&lt;/code&gt; コンストラクタは直接呼び出さないでください。代わりに&lt;a href=&quot;#Base.adjoint&quot;&gt; &lt;code&gt;adjoint&lt;/code&gt; を&lt;/a&gt;使用してください。ビューを具体化するには、&lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="c31303ce475bc8493699e997a666b0db70d41d90" translate="yes" xml:space="preserve">
          <source>Leaf Fluttering In Wind</source>
          <target state="translated">風になびく葉っぱ</target>
        </trans-unit>
        <trans-unit id="22d214839b787ba0cbf83b35c8637e398eb00b60" translate="yes" xml:space="preserve">
          <source>Least common (non-negative) multiple.</source>
          <target state="translated">最小公倍数(非負)。</target>
        </trans-unit>
        <trans-unit id="df7cd86f236b8cca642b834576ccdcaabf497db7" translate="yes" xml:space="preserve">
          <source>Least common (non-negative) multiple. The arguments may be integer and rational numbers.</source>
          <target state="translated">最小公約数(非負)の倍数。引数には整数と有理数を指定することができます。</target>
        </trans-unit>
        <trans-unit id="1aa2f31ee7ccbdf2fc8c6c567cdca2fb29dac2a6" translate="yes" xml:space="preserve">
          <source>Ledger</source>
          <target state="translated">Ledger</target>
        </trans-unit>
        <trans-unit id="8ae1c34bd37fad49cc5f8e02da648a78e89c3ed8" translate="yes" xml:space="preserve">
          <source>Left</source>
          <target state="translated">Left</target>
        </trans-unit>
        <trans-unit id="75d0899e95136f2da4eac284be2b987384e5c533" translate="yes" xml:space="preserve">
          <source>Left Arrow With Circled Plus</source>
          <target state="translated">左矢印に加えて丸で囲んだ</target>
        </trans-unit>
        <trans-unit id="72aee17ac3f066d41059e365fe7ffff8c87f2b40" translate="yes" xml:space="preserve">
          <source>Left Arrow With Small Circle</source>
          <target state="translated">小さな円で左矢印</target>
        </trans-unit>
        <trans-unit id="e4186034491319e4fea56b94c110018858b681a3" translate="yes" xml:space="preserve">
          <source>Left Barb Down Right Barb Down Harpoon</source>
          <target state="translated">左バーブダウン 右バーブダウン ハープーン</target>
        </trans-unit>
        <trans-unit id="ae21e1eb75451dd870d85a61a1cfa6bc8df2ba78" translate="yes" xml:space="preserve">
          <source>Left Barb Down Right Barb Up Harpoon</source>
          <target state="translated">左バーブダウン 右バーブアップ ハープーン</target>
        </trans-unit>
        <trans-unit id="bcae4f39e04c712debc4107f48695498ba926272" translate="yes" xml:space="preserve">
          <source>Left Barb Up Right Barb Down Harpoon</source>
          <target state="translated">左バーブアップ 右バーブダウン ハープーン</target>
        </trans-unit>
        <trans-unit id="f15664f5c11100645f7ec0fc503d10e242c811c4" translate="yes" xml:space="preserve">
          <source>Left Barb Up Right Barb Up Harpoon</source>
          <target state="translated">左バーブアップ 右バーブアップ ハープーン</target>
        </trans-unit>
        <trans-unit id="a3c4bf704acbb06ce3404e8185007c7d40dd50dc" translate="yes" xml:space="preserve">
          <source>Left Ceiling</source>
          <target state="translated">左天井</target>
        </trans-unit>
        <trans-unit id="72a9f53c8c863fcc58b749c2d802910b9dd69204" translate="yes" xml:space="preserve">
          <source>Left Double Quotation Mark / Double Turned Comma Quotation Mark</source>
          <target state="translated">左二重引用符/二重反転コンマ引用符</target>
        </trans-unit>
        <trans-unit id="33ab45e60f973d03d477e320c9c21d10102209f2" translate="yes" xml:space="preserve">
          <source>Left Floor</source>
          <target state="translated">左階</target>
        </trans-unit>
        <trans-unit id="acdcba05803275d77a8ff9d944d257c2f355cc32" translate="yes" xml:space="preserve">
          <source>Left Half Black Circle</source>
          <target state="translated">左半分黒丸</target>
        </trans-unit>
        <trans-unit id="98f2260c432833cdcda74a0d3fd1bcf7149895fd" translate="yes" xml:space="preserve">
          <source>Left Half Block</source>
          <target state="translated">左ハーフブロック</target>
        </trans-unit>
        <trans-unit id="b2d1cb4617e2395b9bcddfaba836b4ff2e6e68a3" translate="yes" xml:space="preserve">
          <source>Left Luggage</source>
          <target state="translated">左の荷物</target>
        </trans-unit>
        <trans-unit id="6fc8b4239d1345e60f61ab6561b7d80a0e196edc" translate="yes" xml:space="preserve">
          <source>Left Normal Factor Semidirect Product</source>
          <target state="translated">左法線因子半間接積</target>
        </trans-unit>
        <trans-unit id="a759ee17e030c9538e681ee56e56b5128b9fcd58" translate="yes" xml:space="preserve">
          <source>Left Outer Join</source>
          <target state="translated">左外結合</target>
        </trans-unit>
        <trans-unit id="bea5ba9ebfbff15c8175b8c30772408ad172251f" translate="yes" xml:space="preserve">
          <source>Left Right Arrow</source>
          <target state="translated">左右矢印</target>
        </trans-unit>
        <trans-unit id="92b57eec514e84ae8d71456c14f7cff82b10a548" translate="yes" xml:space="preserve">
          <source>Left Right Arrow Through Small Circle</source>
          <target state="translated">小さな円を通って左右矢印</target>
        </trans-unit>
        <trans-unit id="8f9b98c29f15c9b6eaf2eadce9578f5dc5b96041" translate="yes" xml:space="preserve">
          <source>Left Right Arrow With Double Vertical Stroke</source>
          <target state="translated">ダブル垂直ストロークの左右矢印</target>
        </trans-unit>
        <trans-unit id="09fe21e697a5fa104980be3384a847b808e4d81a" translate="yes" xml:space="preserve">
          <source>Left Right Arrow With Stroke</source>
          <target state="translated">ストローク付き左右矢印</target>
        </trans-unit>
        <trans-unit id="c3c516b47151666dadcf1dd0a1b3b7ab23f3f3ab" translate="yes" xml:space="preserve">
          <source>Left Right Arrow With Vertical Stroke</source>
          <target state="translated">垂直方向のストロークを持つ左右矢印</target>
        </trans-unit>
        <trans-unit id="4f5213e5966d1dc7812d67e6434bf47c9574b0b4" translate="yes" xml:space="preserve">
          <source>Left Right Double Arrow</source>
          <target state="translated">左右二重矢印</target>
        </trans-unit>
        <trans-unit id="83ed63f2653f9ec7aef827c095dc0fd80a9657f8" translate="yes" xml:space="preserve">
          <source>Left Right Double Arrow With Stroke</source>
          <target state="translated">ストローク付き左右二重矢印</target>
        </trans-unit>
        <trans-unit id="a2ff1377f747643672f8858987628f93747b7eb2" translate="yes" xml:space="preserve">
          <source>Left Right Double Arrow With Vertical Stroke</source>
          <target state="translated">垂直方向のストロークを持つ左右の二重矢印</target>
        </trans-unit>
        <trans-unit id="172365e73cff74845a1277eb1fb198684eed94bd" translate="yes" xml:space="preserve">
          <source>Left Right Open-Headed Arrow</source>
          <target state="translated">左 右 開頭矢印</target>
        </trans-unit>
        <trans-unit id="8055689a32aa93576b189b393a7f7e70b68fbc3d" translate="yes" xml:space="preserve">
          <source>Left Right Wave Arrow</source>
          <target state="translated">左右波矢印</target>
        </trans-unit>
        <trans-unit id="37d876c1c2c475cd47f27703a88e7f2f9166fd62" translate="yes" xml:space="preserve">
          <source>Left Semidirect Product</source>
          <target state="translated">左半間接製品</target>
        </trans-unit>
        <trans-unit id="62324b102cc4b4bf016fb9203c38bec07856133a" translate="yes" xml:space="preserve">
          <source>Left Single Quotation Mark / Single Turned Comma Quotation Mark</source>
          <target state="translated">左シングル引用符/シングルターンコンマ引用符</target>
        </trans-unit>
        <trans-unit id="19e4168df09f34516f6fddcc4e445fc021594bcb" translate="yes" xml:space="preserve">
          <source>Left Square Bracket Lower Corner</source>
          <target state="translated">左角ブラケット下コーナー</target>
        </trans-unit>
        <trans-unit id="ac1fd430a7759464f468517dfa51418639f0abf8" translate="yes" xml:space="preserve">
          <source>Left Tack</source>
          <target state="translated">左タック</target>
        </trans-unit>
        <trans-unit id="07241f21177a787dd3313c67746b03f50c2d9592" translate="yes" xml:space="preserve">
          <source>Left Triangle Beside Vertical Bar</source>
          <target state="translated">垂直バーの横にある左の三角形</target>
        </trans-unit>
        <trans-unit id="3b3a0479d1df49711a0b5dda01c8a9f250ee53e9" translate="yes" xml:space="preserve">
          <source>Left Triangle Beside Vertical Bar + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">垂直バーの横にある左の三角形+ロングソリダスオーバーレイ/ノンスペーシングロングスラッシュオーバーレイの組み合わせ</target>
        </trans-unit>
        <trans-unit id="24f6c1c79f67d997809b3110481aa58d9f740e6a" translate="yes" xml:space="preserve">
          <source>Left Vertical Box Line</source>
          <target state="translated">左の縦長のボックスライン</target>
        </trans-unit>
        <trans-unit id="e2e904284d118de6f14c002567a428193497055e" translate="yes" xml:space="preserve">
          <source>Left arrow, &lt;code&gt;^B&lt;/code&gt;</source>
          <target state="translated">左矢印、 &lt;code&gt;^B&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43c75bdc1fa38ddb43ed3abfdf3e4dda383f45ac" translate="yes" xml:space="preserve">
          <source>Left bit shift operator, &lt;code&gt;B &amp;lt;&amp;lt; n&lt;/code&gt;. For &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, the result is &lt;code&gt;B&lt;/code&gt; with elements shifted &lt;code&gt;n&lt;/code&gt; positions backwards, filling with &lt;code&gt;false&lt;/code&gt; values. If &lt;code&gt;n &amp;lt; 0&lt;/code&gt;, elements are shifted forwards. Equivalent to &lt;code&gt;B &amp;gt;&amp;gt; -n&lt;/code&gt;.</source>
          <target state="translated">左ビットシフト演算子、 &lt;code&gt;B &amp;lt;&amp;lt; n&lt;/code&gt; 。以下のために &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; 、結果は &lt;code&gt;B&lt;/code&gt; の要素とがシフト &lt;code&gt;n&lt;/code&gt; の充填、後方位置を &lt;code&gt;false&lt;/code&gt; の値。 &lt;code&gt;n &amp;lt; 0&lt;/code&gt; 場合、要素は前方にシフトされます。同等の &lt;code&gt;B &amp;gt;&amp;gt; -n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="700db7c2e4663e2dc271d4c36173f17b6c63b025" translate="yes" xml:space="preserve">
          <source>Left bit shift operator, &lt;code&gt;x &amp;lt;&amp;lt; n&lt;/code&gt;. For &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, the result is &lt;code&gt;x&lt;/code&gt; shifted left by &lt;code&gt;n&lt;/code&gt; bits, filling with &lt;code&gt;0&lt;/code&gt;s. This is equivalent to &lt;code&gt;x * 2^n&lt;/code&gt;. For &lt;code&gt;n &amp;lt; 0&lt;/code&gt;, this is equivalent to &lt;code&gt;x &amp;gt;&amp;gt; -n&lt;/code&gt;.</source>
          <target state="translated">左ビットシフト演算子、 &lt;code&gt;x &amp;lt;&amp;lt; n&lt;/code&gt; 。以下のために &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; 、結果は &lt;code&gt;x&lt;/code&gt; 左シフト &lt;code&gt;n&lt;/code&gt; の充填、ビット &lt;code&gt;0&lt;/code&gt; 秒。これは &lt;code&gt;x * 2^n&lt;/code&gt; と同等です。以下のため &lt;code&gt;n &amp;lt; 0&lt;/code&gt; 、これはと等価である &lt;code&gt;x &amp;gt;&amp;gt; -n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47e029a3c897df6f4c0de3d067011451de3151f3" translate="yes" xml:space="preserve">
          <source>Left division operator: multiplication of &lt;code&gt;y&lt;/code&gt; by the inverse of &lt;code&gt;x&lt;/code&gt; on the left. Gives floating-point results for integer arguments.</source>
          <target state="translated">左除算演算子：左側の &lt;code&gt;x&lt;/code&gt; の逆数による &lt;code&gt;y&lt;/code&gt; の乗算。整数の引数に対して浮動小数点の結果を返します。</target>
        </trans-unit>
        <trans-unit id="5ddde4aec1f53e97b5a1f34009e407e1cb187578" translate="yes" xml:space="preserve">
          <source>Left-Pointing Magnifying Glass</source>
          <target state="translated">左向き拡大鏡</target>
        </trans-unit>
        <trans-unit id="35088a4f27322015e328e0637be16cff0df478d9" translate="yes" xml:space="preserve">
          <source>Left-rotate matrix &lt;code&gt;A&lt;/code&gt; 90 degrees counterclockwise an integer &lt;code&gt;k&lt;/code&gt; number of times. If &lt;code&gt;k&lt;/code&gt; is a multiple of four (including zero), this is equivalent to a &lt;code&gt;copy&lt;/code&gt;.</source>
          <target state="translated">左回転行列 &lt;code&gt;A&lt;/code&gt; を反時計回りに90度整数 &lt;code&gt;k&lt;/code&gt; 回回転させます。場合 &lt;code&gt;k&lt;/code&gt; は（ゼロを含む）4の倍数であり、これは、と等価である &lt;code&gt;copy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af413d32c0aefe9e0a6c5345832116ac3819cfc9" translate="yes" xml:space="preserve">
          <source>Left&lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;</source>
          <target state="translated">Left&lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="927f085de46b51d7752a0f754c30861f6cbe6126" translate="yes" xml:space="preserve">
          <source>Left&lt;sup&gt;&lt;a href=&quot;#footnote-2&quot; id=&quot;citeref-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">Left&lt;sup&gt;&lt;a href=&quot;#footnote-2&quot; id=&quot;citeref-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8b0da9967a31e27b91c5f79f61cda48210161da5" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow / Left Arrow</source>
          <target state="translated">左矢印/左矢印</target>
        </trans-unit>
        <trans-unit id="bb62e777d053b849a3960927799605c68d6f5eca" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Above Almost Equal To</source>
          <target state="translated">左方向の矢印の上にほぼ等しく</target>
        </trans-unit>
        <trans-unit id="c453288b80fc56c56e06ba24b30f84f5dac9e172" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Above Reverse Almost Equal To</source>
          <target state="translated">左方向の矢印の上にリバースとほぼ同じ</target>
        </trans-unit>
        <trans-unit id="c80976998c602bbf7e0960e57864b997e7fa3170" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Above Reverse Tilde Operator</source>
          <target state="translated">左方向の矢印の上に逆ティルデ演算子</target>
        </trans-unit>
        <trans-unit id="b339bc529a24441191ee0d608b29a79c5db84b52" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow From Bar / Left Arrow From Bar</source>
          <target state="translated">バーからの左矢印/バーからの左矢印</target>
        </trans-unit>
        <trans-unit id="1e84d429549228a5c098aec3446031d7ead6505a" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow From Bar To Black Diamond</source>
          <target state="translated">バーからブラックダイヤモンドへの左向き矢印</target>
        </trans-unit>
        <trans-unit id="3b47b1dfc544dad6abdaf2ebcb4206c54487efc5" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Over Rightwards Arrow / Left Arrow Over Right Arrow</source>
          <target state="translated">右矢印の上に左矢印/右矢印の上に左矢印</target>
        </trans-unit>
        <trans-unit id="ae9989b5442d5772a5dadc97fcf089e63cd8bb1f" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Through X</source>
          <target state="translated">Xを通した左方向の矢印</target>
        </trans-unit>
        <trans-unit id="ae63102c5c00038eb021088d9b27a739caf11f6e" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow To Bar / Left Arrow To Bar</source>
          <target state="translated">バーへの左矢印/バーへの左矢印</target>
        </trans-unit>
        <trans-unit id="ba54e194d48c6e6846ca63e167eaa511daf10b83" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow To Bar Over Rightwards Arrow To Bar / Left Arrow To Bar Over Right Arrow To Bar</source>
          <target state="translated">バーへの右矢印バー/バーへの左矢印バーへの左矢印バーへの右矢印バーへの右矢印上のバーへの左矢印</target>
        </trans-unit>
        <trans-unit id="352323837c59795cd0e83f313a7f1aad09357b67" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow To Black Diamond</source>
          <target state="translated">ブラックダイヤモンドへの左矢印</target>
        </trans-unit>
        <trans-unit id="0dbfe3aca18f61d6f1a6e05b8ae3c26d1725c775" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Dotted Stem</source>
          <target state="translated">点線の茎が付いている左向きの矢印</target>
        </trans-unit>
        <trans-unit id="b5f4b7ef2746d70757e6dc984fb3961f86960c29" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Double Vertical Stroke</source>
          <target state="translated">二重の垂直方向のストロークを持つ左向きの矢印</target>
        </trans-unit>
        <trans-unit id="42e353d97e79c0c1b091dc7d9378f532aaef3b3d" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Hook / Left Arrow With Hook</source>
          <target state="translated">フック付き左矢印/フック付き左矢印</target>
        </trans-unit>
        <trans-unit id="023d9a3502015dcd3b3f76fa14c946cbbc2d6f32" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Loop / Left Arrow With Loop</source>
          <target state="translated">ループが付いている左方向の矢印/ループが付いている左矢印</target>
        </trans-unit>
        <trans-unit id="9e22f7f96528d90c3397d6b157c1fdc2594ea742" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Plus Below</source>
          <target state="translated">プラスの下にある左方向の矢印</target>
        </trans-unit>
        <trans-unit id="cc480573c42bb17cb0e2940abfedd3c8ea38e8ea" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Stroke / Left Arrow With Stroke</source>
          <target state="translated">ストローク付き左矢印/ストローク付き左矢印</target>
        </trans-unit>
        <trans-unit id="52d1604edf7ef87df0bdda8c2b40df8871c49a60" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Tail / Left Arrow With Tail</source>
          <target state="translated">テール付き左矢印/テール付き左矢印</target>
        </trans-unit>
        <trans-unit id="88f9604cfadba8964cc29be77251abe676f9051a" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Tail With Double Vertical Stroke</source>
          <target state="translated">二重の垂直ストロークを持つ尾を持つ左向きの矢印</target>
        </trans-unit>
        <trans-unit id="390234b436d1a22d91a1f9368ac90420d25a50f9" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Tail With Vertical Stroke</source>
          <target state="translated">テールと垂直ストロークを持つ左向きの矢印</target>
        </trans-unit>
        <trans-unit id="11ebeb1eafd67ffeeffad131d7ac82c3b52085be" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Vertical Stroke</source>
          <target state="translated">垂直方向のストロークを持つ左方向の矢印</target>
        </trans-unit>
        <trans-unit id="c87c24a3eb1d8323b9fa96777c93ec260174835d" translate="yes" xml:space="preserve">
          <source>Leftwards Black Arrow</source>
          <target state="translated">左上のブラックアロー</target>
        </trans-unit>
        <trans-unit id="33cfca8919d0753ef59ada74348c2a4c4b3bf344" translate="yes" xml:space="preserve">
          <source>Leftwards Dashed Arrow / Left Dashed Arrow</source>
          <target state="translated">左方向破線矢印/左方向破線矢印</target>
        </trans-unit>
        <trans-unit id="8a19ba0a75d89ee68704a7ebb90ffd71f1e1b278" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow / Left Double Arrow</source>
          <target state="translated">左向きダブルアロー/左ダブルアロー</target>
        </trans-unit>
        <trans-unit id="60c9a06f1f5b3ab83b89088f525d893f40459a8e" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow From Bar</source>
          <target state="translated">バーから左方向に二重矢印</target>
        </trans-unit>
        <trans-unit id="0d8615420d5ad768b1f26184a0a7a40704148a7d" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow With Stroke / Left Double Arrow With Stroke</source>
          <target state="translated">ストロークとストローク/ストロークと左ダブルアローと左方向の二重矢印</target>
        </trans-unit>
        <trans-unit id="4f6b99ebd5ed363e088c4f88602ef903b8e06f64" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow With Vertical Stroke</source>
          <target state="translated">垂直方向のストロークを持つ左方向の二重矢印</target>
        </trans-unit>
        <trans-unit id="4f794063524482bcc21c38eae616ca798ede37a8" translate="yes" xml:space="preserve">
          <source>Leftwards Double Dash Arrow</source>
          <target state="translated">左向きダブルダッシュ矢印</target>
        </trans-unit>
        <trans-unit id="39e96a986704f562e46fbf1d03e4f9e54add9f77" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon Over Rightwards Harpoon / Left Harpoon Over Right Harpoon</source>
          <target state="translated">左寄せハープーンオーバー右寄せハープーン/左寄せハープーンオーバー右寄せハープーン</target>
        </trans-unit>
        <trans-unit id="690c48df2218ae792864eaf9456cf6955b424427" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down Above Rightwards Harpoon With Barb Down</source>
          <target state="translated">上の下のバーブを持つ左方向の銛 右方向の銛 下のバーブを持つ右方向の銛</target>
        </trans-unit>
        <trans-unit id="2a8c5adb9efda04b9d2fabf980287f590ba155e5" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down Below Long Dash</source>
          <target state="translated">ロングダッシュの下にバーブを下げた左回りの銛</target>
        </trans-unit>
        <trans-unit id="d60c5396df85f38cca433173bdcae8dd56a90b18" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down From Bar</source>
          <target state="translated">バーブをバーから下にした左向きのハープーン</target>
        </trans-unit>
        <trans-unit id="93c5200b6461e9ba3314eb9a0b244de1ac0949de" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down To Bar</source>
          <target state="translated">左向きハープーン ウィズ バーブ ダウン トゥ バー</target>
        </trans-unit>
        <trans-unit id="b6d93e8905d73cadcac079a3790b467b97f9e3ec" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Downwards / Left Harpoon With Barb Down</source>
          <target state="translated">Leftwards Harpoon With Barb Downwards/Left Harpoon With Barb Down Down</target>
        </trans-unit>
        <trans-unit id="662b3d2cbb862798f1987f0dd2c11e4c77a5182f" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up Above Leftwards Harpoon With Barb Down</source>
          <target state="translated">上のバーブを持つ左方向の銛 上のバーブを持つ左方向の銛 下のバーブを持つ左方向の銛</target>
        </trans-unit>
        <trans-unit id="b0567c46db77bd91abd63923235b4420e5bd82e5" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up Above Long Dash</source>
          <target state="translated">ロングダッシュの上にバーブを上げた左回りの銛</target>
        </trans-unit>
        <trans-unit id="0084ef3852a19447620ab7c0dfc2d2b12aeeb77d" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up Above Rightwards Harpoon With Barb Up</source>
          <target state="translated">左向きの銛とバーブを上にした右向きの銛とバーブを上にした右向きの銛</target>
        </trans-unit>
        <trans-unit id="730216336dfd2e32435830075fdb2df0dfaa397f" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up From Bar</source>
          <target state="translated">バーブからバーブアップした左向きハープーン</target>
        </trans-unit>
        <trans-unit id="4cbc38b13463300c356dd264e992f7457f26d5f3" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up To Bar</source>
          <target state="translated">左向きハープーン ウィズ バーブ アップ トゥ バー</target>
        </trans-unit>
        <trans-unit id="42c26ac6b35b0c13895bf055d9cecb545b0ec09a" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Upwards / Left Harpoon With Barb Up</source>
          <target state="translated">レフトワーズ ハープーン ウィズ バーブ アップワード/レフト ハープーン ウィズ バーブ アップワード</target>
        </trans-unit>
        <trans-unit id="5439409c437a7e20e57d117b3dc53bfc59be5b1e" translate="yes" xml:space="preserve">
          <source>Leftwards Open-Headed Arrow</source>
          <target state="translated">左開き矢印</target>
        </trans-unit>
        <trans-unit id="fb802d31c4d84700fe501788c56f0616bde89895" translate="yes" xml:space="preserve">
          <source>Leftwards Paired Arrows / Left Paired Arrows</source>
          <target state="translated">左向きペアリングアロー/左向きペアリングアロー</target>
        </trans-unit>
        <trans-unit id="1e30b6357af1b8210adc5e8500513f1780a44b86" translate="yes" xml:space="preserve">
          <source>Leftwards Quadruple Arrow</source>
          <target state="translated">左向き四重矢印</target>
        </trans-unit>
        <trans-unit id="e990b5a5a1b8966a349729643a9904c9a464f8f2" translate="yes" xml:space="preserve">
          <source>Leftwards Squiggle Arrow / Left Squiggle Arrow</source>
          <target state="translated">左向きスクイグルアロー/左スクイグルアロー</target>
        </trans-unit>
        <trans-unit id="40ef7c42edfad6e4a2b0c741f7a2e57b2d0a3d17" translate="yes" xml:space="preserve">
          <source>Leftwards Triple Arrow / Left Triple Arrow</source>
          <target state="translated">左向きトリプルアロー/左向きトリプルアロー</target>
        </trans-unit>
        <trans-unit id="e443b0f54a32ffe38d3c2940e3150615527deb02" translate="yes" xml:space="preserve">
          <source>Leftwards Triple Dash Arrow</source>
          <target state="translated">左上トリプルダッシュアロー</target>
        </trans-unit>
        <trans-unit id="0e6ace611eb46c42c60ebf869526d6d80107ee54" translate="yes" xml:space="preserve">
          <source>Leftwards Two Headed Arrow / Left Two Headed Arrow</source>
          <target state="translated">左向き二頭立て矢印/左向き二頭立て矢印</target>
        </trans-unit>
        <trans-unit id="73e956493780be5029f93be5ee242950d63a7b37" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow From Bar</source>
          <target state="translated">バーからの左方向の双頭の矢印</target>
        </trans-unit>
        <trans-unit id="c8fe728344df16251ef3411400150ba0b2c50044" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Double Vertical Stroke</source>
          <target state="translated">二重の垂直ストロークを持つ左方向の双頭の矢</target>
        </trans-unit>
        <trans-unit id="19a7c2f943c6a266d93318b4faccd25877a453bc" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Tail</source>
          <target state="translated">左方双頭矢</target>
        </trans-unit>
        <trans-unit id="fad45cb4bffed0212e02a7dd5b2b9636aeff862a" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Tail With Double Vertical Stroke</source>
          <target state="translated">二重の垂直ストロークを持つ尾を持つ左方の双頭の矢</target>
        </trans-unit>
        <trans-unit id="5354b323327ab9574144f2502eac42843f5fcc1b" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Tail With Vertical Stroke</source>
          <target state="translated">左方の垂直ストロークと尾を持つ両頭の矢</target>
        </trans-unit>
        <trans-unit id="be95b8e9e0c8c9337712cb0f314c9ab2a05f3613" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Vertical Stroke</source>
          <target state="translated">垂直方向のストロークを持つ左方向の双頭の矢</target>
        </trans-unit>
        <trans-unit id="43f10f58eb0471f466412a154b6c2de8a4b85793" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Triple Dash Arrow</source>
          <target state="translated">左方二頭身三連ダッシュアロー</target>
        </trans-unit>
        <trans-unit id="54be3ecc08f6dfc79a630a29d3be179ecc6e1de9" translate="yes" xml:space="preserve">
          <source>Leftwards Wave Arrow / Left Wave Arrow</source>
          <target state="translated">左方向のウェーブアロー/左方向のウェーブアロー</target>
        </trans-unit>
        <trans-unit id="a8988dc4aff78fbf3d6dec72ae6a15340f71c39b" translate="yes" xml:space="preserve">
          <source>Leftwards White Arrow / White Left Arrow</source>
          <target state="translated">左上がりの白矢印/左上がりの白矢印</target>
        </trans-unit>
        <trans-unit id="53789e63c0a26b06f6ee3389f57916b3259c1e85" translate="yes" xml:space="preserve">
          <source>Legend:</source>
          <target state="translated">Legend:</target>
        </trans-unit>
        <trans-unit id="4459b791a680572873dc2cf033487dc21edfcb9c" translate="yes" xml:space="preserve">
          <source>Lemon</source>
          <target state="translated">Lemon</target>
        </trans-unit>
        <trans-unit id="cfaf50ac3721461bd3a2d27ef5f35e144901fbb6" translate="yes" xml:space="preserve">
          <source>Leo</source>
          <target state="translated">Leo</target>
        </trans-unit>
        <trans-unit id="3ee924e59f48f89881e4cde275cb373a5ca3ccb1" translate="yes" xml:space="preserve">
          <source>Leopard</source>
          <target state="translated">Leopard</target>
        </trans-unit>
        <trans-unit id="2b515baec988fd996a77420ccdf808df339479aa" translate="yes" xml:space="preserve">
          <source>Less-Than Above Double-Line Equal Above Greater-Than</source>
          <target state="translated">二重線上の以下 同等の上 大きい以上</target>
        </trans-unit>
        <trans-unit id="5132ce6dbd42eef8696f2795c98fbde608c55ddc" translate="yes" xml:space="preserve">
          <source>Less-Than Above Greater-Than Above Double-Line Equal</source>
          <target state="translated">上記以下 大以上 ダブルライン イコール</target>
        </trans-unit>
        <trans-unit id="0996bf12be96a0c9cfd35d9c3d1cd4d7ae0dc489" translate="yes" xml:space="preserve">
          <source>Less-Than Above Similar Above Greater-Than</source>
          <target state="translated">以下 上記 似たようなもの 上記 大規模なもの</target>
        </trans-unit>
        <trans-unit id="f47dca757b69c3cbb5c4318a3148b185aa51ad59" translate="yes" xml:space="preserve">
          <source>Less-Than Above Similar Or Equal</source>
          <target state="translated">類似または同等以下</target>
        </trans-unit>
        <trans-unit id="d46f5f3bf1beaa31682309e60c70c4c4589a153d" translate="yes" xml:space="preserve">
          <source>Less-Than Above Slanted Equal Above Greater-Than Above Slanted Equal</source>
          <target state="translated">斜め上の等倍以下 斜め上の等倍以上 斜め上の等倍以上</target>
        </trans-unit>
        <trans-unit id="713b9a189c39738ac2705479504dc75c64634c14" translate="yes" xml:space="preserve">
          <source>Less-Than And Not Approximate</source>
          <target state="translated">以下であり、近似ではない</target>
        </trans-unit>
        <trans-unit id="2796bb948b259786fd87ad28f516271749c20d52" translate="yes" xml:space="preserve">
          <source>Less-Than And Single-Line Not Equal To</source>
          <target state="translated">以下と単線は同じではありません。</target>
        </trans-unit>
        <trans-unit id="709360d5eb9bea213909aadcf59a29aa892cbe75" translate="yes" xml:space="preserve">
          <source>Less-Than But Not Equal To / Less Than But Not Equal To</source>
          <target state="translated">未満であるが、同等ではない/未満であるが、同等ではない</target>
        </trans-unit>
        <trans-unit id="e453412818d96e7a4f420ee26bac5ea434246d68" translate="yes" xml:space="preserve">
          <source>Less-Than But Not Equal To / Less Than But Not Equal To + Variation Selector-1</source>
          <target state="translated">等しくないが等しい以下/等しくないが等しい以下+バリエーションセレクタ-1</target>
        </trans-unit>
        <trans-unit id="2f4b9cde7d599f1fdfcdcd2d149da1761281cf59" translate="yes" xml:space="preserve">
          <source>Less-Than But Not Equivalent To / Less Than But Not Equivalent To</source>
          <target state="translated">以下であるが同等ではない/以下であるが同等ではない</target>
        </trans-unit>
        <trans-unit id="d47b00bfbef46bd9077401979c412c7c9f4f06db" translate="yes" xml:space="preserve">
          <source>Less-Than Closed By Curve</source>
          <target state="translated">曲線で閉じる以下</target>
        </trans-unit>
        <trans-unit id="e9bc15ca0894be74c91d83dd7307ed3d4d198f47" translate="yes" xml:space="preserve">
          <source>Less-Than Closed By Curve Above Slanted Equal</source>
          <target state="translated">斜め上のカーブで閉じられた以下のもの 同等</target>
        </trans-unit>
        <trans-unit id="22c4db9e780b7f321b3a098f0b550b5d05360802" translate="yes" xml:space="preserve">
          <source>Less-Than Equal To Or Greater-Than / Less Than Equal To Or Greater Than</source>
          <target state="translated">等しくないまたは大きいより小さい/等しいまたは大きいより小さいより大きいより小さい</target>
        </trans-unit>
        <trans-unit id="125980c6753f24cfef91a7aee66e7177aefa9911" translate="yes" xml:space="preserve">
          <source>Less-Than Or Approximate</source>
          <target state="translated">以下または近似</target>
        </trans-unit>
        <trans-unit id="c6b5679738cc00d2db14ba6a2056c401ded59619" translate="yes" xml:space="preserve">
          <source>Less-Than Or Equal To / Less Than Or Equal To</source>
          <target state="translated">以下または同等以下/以下または同等以下</target>
        </trans-unit>
        <trans-unit id="35d27cfb30206b75fdeb27b601c10d1aad047c85" translate="yes" xml:space="preserve">
          <source>Less-Than Or Equivalent To / Less Than Or Equivalent To</source>
          <target state="translated">以下又は同等以下/以下又は同等以下</target>
        </trans-unit>
        <trans-unit id="b9b477ee81eb35999da4d54deb44ce4b860fe5f0" translate="yes" xml:space="preserve">
          <source>Less-Than Or Greater-Than / Less Than Or Greater Than</source>
          <target state="translated">以下の場合は、以下の場合は、以下の場合は、以下の場合は、以下の場合は、以下の場合は、以上の場合は</target>
        </trans-unit>
        <trans-unit id="cfd32ee1a60232f0de86d5e566782496b87faa45" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To</source>
          <target state="translated">以下または斜めに等しい</target>
        </trans-unit>
        <trans-unit id="c2210b5afd5a3271bd637771d340007b9651af50" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">長尺ソリッドスオーバーレイ/ノンスペーシング長尺スラッシュオーバーレイを組み合わせたものと同等以下または斜め</target>
        </trans-unit>
        <trans-unit id="a5250f1e7fd00d514cf7de98b151fff6e960ca41" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To With Dot Above</source>
          <target state="translated">上記のドットを持つことに等しい以下または傾斜</target>
        </trans-unit>
        <trans-unit id="08ee594bef0f1ebfc9a347365790474b8aa06aae" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To With Dot Above Right</source>
          <target state="translated">右上のドットを持つことに等しい以下または傾斜した</target>
        </trans-unit>
        <trans-unit id="6028a8d9f280a98196c48a63aa608f95a5002030" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To With Dot Inside</source>
          <target state="translated">ドットの内側にあるものと同等以下または傾斜したもの</target>
        </trans-unit>
        <trans-unit id="a654d5c89ef59a82d905f082b763c64619e9d053" translate="yes" xml:space="preserve">
          <source>Less-Than Over Equal To / Less Than Over Equal To</source>
          <target state="translated">等価以上/等価以上未満</target>
        </trans-unit>
        <trans-unit id="3cd5d177f863b189035a69ddc7dc355152c827d7" translate="yes" xml:space="preserve">
          <source>Less-Than With Circle Inside</source>
          <target state="translated">内側に円を入れた状態でのレスタン</target>
        </trans-unit>
        <trans-unit id="f5f82e2a0d06ff7d257c2989f80e7e63fdfcc406" translate="yes" xml:space="preserve">
          <source>Less-Than With Dot / Less Than With Dot</source>
          <target state="translated">ドット付き以下/ドット付き以下</target>
        </trans-unit>
        <trans-unit id="e8d2d29dc34fdea25f29dead5f22ec63a8a158fd" translate="yes" xml:space="preserve">
          <source>Less-Than With Question Mark Above</source>
          <target state="translated">上記の疑問符が付いている以下</target>
        </trans-unit>
        <trans-unit id="98215ce56f609905c57ffcaa9fd368bd9a664b9f" translate="yes" xml:space="preserve">
          <source>Less-than comparison operator. Falls back to &lt;a href=&quot;../base/index#Base.isless&quot;&gt;&lt;code&gt;isless&lt;/code&gt;&lt;/a&gt;. Because of the behavior of floating-point NaN values, this operator implements a partial order.</source>
          <target state="translated">小なり比較演算子。滝の裏&lt;a href=&quot;../base/index#Base.isless&quot;&gt; &lt;code&gt;isless&lt;/code&gt; &lt;/a&gt;。浮動小数点NaN値の動作のため、この演算子は半順序を実装します。</target>
        </trans-unit>
        <trans-unit id="6b17017e386fc2cfd407cedbcefdc1a56529ec61" translate="yes" xml:space="preserve">
          <source>Less-than-or-equals comparison operator. Falls back to &lt;code&gt;(x &amp;lt; y) | (x == y)&lt;/code&gt;.</source>
          <target state="translated">より小さいか等しい比較演算子。 &lt;code&gt;(x &amp;lt; y) | (x == y)&lt;/code&gt; 戻る| （x == y）。</target>
        </trans-unit>
        <trans-unit id="7223264dca9d07a87ce4ee4c3f4c203febf05b3c" translate="yes" xml:space="preserve">
          <source>Let Blocks</source>
          <target state="translated">ブロック</target>
        </trans-unit>
        <trans-unit id="7a4b5aa264a12a56a65beda1765bedfd0c0c5b4a" translate="yes" xml:space="preserve">
          <source>Let us explore the low level construct &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; to understand how task switching works. &lt;code&gt;yieldto(task,value)&lt;/code&gt; suspends the current task, switches to the specified &lt;code&gt;task&lt;/code&gt;, and causes that task's last &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; call to return the specified &lt;code&gt;value&lt;/code&gt;. Notice that &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; is the only operation required to use task-style control flow; instead of calling and returning we are always just switching to a different task. This is why this feature is also called &quot;symmetric coroutines&quot;; each task is switched to and from using the same mechanism.</source>
          <target state="translated">タスクの切り替えがどのように機能するかを理解するために、低レベルの構造体&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;を調べてみましょう。 &lt;code&gt;yieldto(task,value)&lt;/code&gt; は、現在のタスクを中断し、指定された &lt;code&gt;task&lt;/code&gt; に切り替え、そのタスクの最後の&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;呼び出しで指定された &lt;code&gt;value&lt;/code&gt; を返します。タスクスタイルの制御フローを使用するために必要な操作は、&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;だけであることに注意してください。呼び出して戻るのではなく、常に別のタスクに切り替えるだけです。これが、この機能が「対称コルーチン」とも呼ばれる理由です。各タスクは、同じメカニズムを使用して切り替えられます。</target>
        </trans-unit>
        <trans-unit id="67246c5c8735d7e8441000a86e3cb7192688e453" translate="yes" xml:space="preserve">
          <source>Let us illustrate this principle with the logical &quot;or&quot; operator &lt;code&gt;|&lt;/code&gt;. Following the rules of boolean logic, if one of the operands is &lt;code&gt;true&lt;/code&gt;, the value of the other operand does not have an influence on the result, which will always be &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">論理的な「or」演算子でこの原理を説明しましょう &lt;code&gt;|&lt;/code&gt; 。ブール論理の規則に従って、一方のオペランドが &lt;code&gt;true&lt;/code&gt; の場合、もう一方のオペランドの値は結果に影響を与えません。これは常に &lt;code&gt;true&lt;/code&gt; になります</target>
        </trans-unit>
        <trans-unit id="5989117a8f456835a0f1be3863e508fbd507b1e1" translate="yes" xml:space="preserve">
          <source>Let us operate on this array simultaneously using 4 threads. We'll have each thread write its thread ID into each location.</source>
          <target state="translated">この配列を4つのスレッドを使って同時に操作してみましょう。各スレッドにはそれぞれの場所にスレッドIDを書き込ませます。</target>
        </trans-unit>
        <trans-unit id="6183c7c4afe71ef5b8231a90fffb2c5978fa45fa" translate="yes" xml:space="preserve">
          <source>Let's consider some of the abstract types that make up Julia's numerical hierarchy:</source>
          <target state="translated">ジュリアの数値階層を構成する抽象型のいくつかを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="01a2c551d7b29ee2d56fdf88a3feffacdd9828c3" translate="yes" xml:space="preserve">
          <source>Let's define a producer task, which produces values via the &lt;code&gt;put!&lt;/code&gt; call. To consume values, we need to schedule the producer to run in a new task. A special &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; constructor which accepts a 1-arg function as an argument can be used to run a task bound to a channel. We can then &lt;code&gt;take!&lt;/code&gt; values repeatedly from the channel object:</source>
          <target state="translated">&lt;code&gt;put!&lt;/code&gt; を介して値を生成するプロデューサータスクを定義しましょう。コール。値を消費するには、新しいタスクで実行するようにプロデューサーをスケジュールする必要があります。引数として1引数の関数を受け入れる特別な&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;コンストラクターを使用して、チャネルにバインドされたタスクを実行できます。その後、私たちは &lt;code&gt;take!&lt;/code&gt; ことができます！チャネルオブジェクトからの値を繰り返し：</target>
        </trans-unit>
        <trans-unit id="d05f0c73a4331f267ffda8d64fbec89860b0ccf5" translate="yes" xml:space="preserve">
          <source>Let's dig into the fact that the &lt;code&gt;for&lt;/code&gt; loop body has its own scope for a second by writing a slightly more verbose variation which we'll call &lt;code&gt;sum_to&amp;prime;&lt;/code&gt;, in which we save the sum &lt;code&gt;s + i&lt;/code&gt; in a variable &lt;code&gt;t&lt;/code&gt; before updating &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ループ本体には、 &lt;code&gt;sum_to&amp;prime;&lt;/code&gt; と呼ばれるもう少し詳細なバリエーションを記述して、1秒間独自のスコープがあるという事実を掘り下げてみましょう。ここでは、 &lt;code&gt;s&lt;/code&gt; を更新する前に合計 &lt;code&gt;s + i&lt;/code&gt; を変数 &lt;code&gt;t&lt;/code&gt; に保存します。</target>
        </trans-unit>
        <trans-unit id="9df15ca83d0947dbf1751a612bf2340b275f4ac4" translate="yes" xml:space="preserve">
          <source>Let's first discuss the two positional arguments, and later the keyword arguments:</source>
          <target state="translated">まず、2つの位置引数、そして後にキーワード引数について説明しましょう。</target>
        </trans-unit>
        <trans-unit id="6418114a78265d3efb7f605d5f750649435cf8a7" translate="yes" xml:space="preserve">
          <source>Let's jump right in with a simple example involving TCP sockets. This functionality is in a standard library package called &lt;code&gt;Sockets&lt;/code&gt;. Let's first create a simple server:</source>
          <target state="translated">TCPソケットに関する簡単な例を見てみましょう。この機能は、 &lt;code&gt;Sockets&lt;/code&gt; と呼ばれる標準ライブラリパッケージに含まれています。まず簡単なサーバーを作成しましょう：</target>
        </trans-unit>
        <trans-unit id="9d1274ee3906a8208793462a30f6e28d1823afa2" translate="yes" xml:space="preserve">
          <source>Let's move onto some more ambiguous cases covered by the soft scope rule. We'll explore this by extracting the bodies of the &lt;code&gt;greet&lt;/code&gt; and &lt;code&gt;sum_to&amp;prime;&lt;/code&gt; functions into soft scope contexts. First, let's put the body of &lt;code&gt;greet&lt;/code&gt; in a &lt;code&gt;for&lt;/code&gt; loop&amp;mdash;which is soft, rather than hard&amp;mdash;and evaluate it in the REPL:</source>
          <target state="translated">ソフトスコープルールでカバーされている、よりあいまいなケースに移りましょう。 &lt;code&gt;greet&lt;/code&gt; 関数と &lt;code&gt;sum_to&amp;prime;&lt;/code&gt; 関数の本体をソフトスコープコンテキストに抽出することで、これを調査します。まず、聞かせてのは、身体の入れ &lt;code&gt;greet&lt;/code&gt; して &lt;code&gt;for&lt;/code&gt; ループではなく、ソフトでハードとREPLでそれを評価します：</target>
        </trans-unit>
        <trans-unit id="1122c34c203c69e459bc638ef4ea480a5b8130e2" translate="yes" xml:space="preserve">
          <source>Let's say you want to create an &lt;code&gt;N&lt;/code&gt;-dimensional array that has size 3 along each axis. Such arrays can be created like this:</source>
          <target state="translated">各軸に沿ってサイズ3の &lt;code&gt;N&lt;/code&gt; 次元配列を作成するとします。このような配列は次のように作成できます。</target>
        </trans-unit>
        <trans-unit id="8748cf620bf48795063bf239466aafbea94faee0" translate="yes" xml:space="preserve">
          <source>Let's set up a new environment so we may experiment. To set the active environment, use &lt;code&gt;activate&lt;/code&gt;:</source>
          <target state="translated">実験できるように、新しい環境をセットアップしましょう。アクティブな環境を設定するには、 &lt;code&gt;activate&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="c76b2235d981c65461960877af26f1dbe64a8ee1" translate="yes" xml:space="preserve">
          <source>Let's start with a simple example of a C wrapper that returns a &lt;code&gt;Ptr&lt;/code&gt; type:</source>
          <target state="translated">&lt;code&gt;Ptr&lt;/code&gt; タイプを返すCラッパーの簡単な例から始めましょう。</target>
        </trans-unit>
        <trans-unit id="1df8e39d6c6cb9f345698606b67ad54d1b7ae227" translate="yes" xml:space="preserve">
          <source>Let's take the following example: we implement a &lt;code&gt;Die&lt;/code&gt; type, with a variable number &lt;code&gt;n&lt;/code&gt; of sides, numbered from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;n&lt;/code&gt;. We want &lt;code&gt;rand(Die)&lt;/code&gt; to produce a &lt;code&gt;Die&lt;/code&gt; with a random number of up to 20 sides (and at least 4):</source>
          <target state="translated">次の例を見てみましょう &lt;code&gt;1&lt;/code&gt; から &lt;code&gt;n&lt;/code&gt; までの番号が付けられた可変数 &lt;code&gt;n&lt;/code&gt; の辺を持つ &lt;code&gt;Die&lt;/code&gt; タイプを実装します。私たちは望ん &lt;code&gt;rand(Die)&lt;/code&gt; 生成するために &lt;code&gt;Die&lt;/code&gt; 20本の辺（少なくとも4）までの乱数とを：</target>
        </trans-unit>
        <trans-unit id="71ba98ed632749544ae49e36ff83983c01e402b0" translate="yes" xml:space="preserve">
          <source>Let's take the following example: we implement a &lt;code&gt;Die&lt;/code&gt; type, with a variable number &lt;code&gt;n&lt;/code&gt; of sides, numbered from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;n&lt;/code&gt;. We want &lt;code&gt;rand(Die)&lt;/code&gt; to produce a die with a random number of up to 20 sides (and at least 4):</source>
          <target state="translated">次の例を見てみましょう &lt;code&gt;1&lt;/code&gt; から &lt;code&gt;n&lt;/code&gt; までの番号が付けられた、側面の数 &lt;code&gt;n&lt;/code&gt; が可変の &lt;code&gt;Die&lt;/code&gt; タイプを実装します。私たちは望ん &lt;code&gt;rand(Die)&lt;/code&gt; 20本の辺（少なくとも4）までの乱数を持つ金型を生産します：</target>
        </trans-unit>
        <trans-unit id="f3530d6febbeb3af1b1c75ff5864143019e5c7e9" translate="yes" xml:space="preserve">
          <source>Let's try it out. First we modify the file at &lt;code&gt;tutorial/dev/Example/src/Example.jl&lt;/code&gt; and add a simple function:</source>
          <target state="translated">試してみましょう。まず、 &lt;code&gt;tutorial/dev/Example/src/Example.jl&lt;/code&gt; にあるファイルを変更し、簡単な関数を追加します。</target>
        </trans-unit>
        <trans-unit id="d9f3d5d59e7aa3d7e910a3c03fcdc92c22584287" translate="yes" xml:space="preserve">
          <source>Let's try this out. Starting with &lt;code&gt;julia -p n&lt;/code&gt; provides &lt;code&gt;n&lt;/code&gt; worker processes on the local machine. Generally it makes sense for &lt;code&gt;n&lt;/code&gt; to equal the number of CPU threads (logical cores) on the machine. Note that the &lt;code&gt;-p&lt;/code&gt; argument implicitly loads module &lt;code&gt;Distributed&lt;/code&gt;.</source>
          <target state="translated">これを試してみましょう。 &lt;code&gt;julia -p n&lt;/code&gt; 始まると、ローカルマシンに &lt;code&gt;n&lt;/code&gt; 個のワーカープロセスが提供されます。一般に、 &lt;code&gt;n&lt;/code&gt; がマシン上のCPUスレッド（論理コア）の数と等しいことは理にかなっています。 &lt;code&gt;-p&lt;/code&gt; 引数は、モジュール &lt;code&gt;Distributed&lt;/code&gt; を暗黙的にロードすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b446a4746adc500fc9039decd4f98dd1f28494be" translate="yes" xml:space="preserve">
          <source>Let's verify there are 4 threads at our disposal.</source>
          <target state="translated">自由に4つのスレッドがあることを確認してみましょう。</target>
        </trans-unit>
        <trans-unit id="a857063978f61fa4bd1f41b325d1aa75b04e9d5e" translate="yes" xml:space="preserve">
          <source>Let's work a simple example using our native threads. Let us create an array of zeros:</source>
          <target state="translated">ネイティブスレッドを使って簡単な例を作ってみましょう。ゼロの配列を作成してみましょう。</target>
        </trans-unit>
        <trans-unit id="01ca76f755ba1afdf88a6b78abbe4839783a3a4d" translate="yes" xml:space="preserve">
          <source>Let's work with a simple test case:</source>
          <target state="translated">簡単なテストケースを使って作業してみましょう。</target>
        </trans-unit>
        <trans-unit id="7dd0810d04c75d2aee9682c9c0e389c01969f9df" translate="yes" xml:space="preserve">
          <source>Lets start Julia with 4 threads:</source>
          <target state="translated">4つのスレッドでジュリアをスタートさせましょう。</target>
        </trans-unit>
        <trans-unit id="ee8556898b2b9f9b2564fd6a9f4e2eeba1821894" translate="yes" xml:space="preserve">
          <source>LibGit2</source>
          <target state="translated">LibGit2</target>
        </trans-unit>
        <trans-unit id="76b53f15ef89ba2bfb2e2f62f34201129332b916" translate="yes" xml:space="preserve">
          <source>Libc</source>
          <target state="translated">Libc</target>
        </trans-unit>
        <trans-unit id="60368a5f4bc52be83598e88566f2089a47f21a35" translate="yes" xml:space="preserve">
          <source>Libc.FormatMessage()</source>
          <target state="translated">Libc.FormatMessage()</target>
        </trans-unit>
        <trans-unit id="41585a339c2503f89fb1f9aa92fdc8fb9adcdd4d" translate="yes" xml:space="preserve">
          <source>Libc.GetLastError()</source>
          <target state="translated">Libc.GetLastError()</target>
        </trans-unit>
        <trans-unit id="a85a19153d65e87480d301d0383428f7125ed99b" translate="yes" xml:space="preserve">
          <source>Libc.RawFD</source>
          <target state="translated">Libc.RawFD</target>
        </trans-unit>
        <trans-unit id="b9d6e139e984d53b5bcde695421e487faedd7c51" translate="yes" xml:space="preserve">
          <source>Libc.TmStruct</source>
          <target state="translated">Libc.TmStruct</target>
        </trans-unit>
        <trans-unit id="bc871e61e3ca821c6cfe4accdd2d8e0693a588e4" translate="yes" xml:space="preserve">
          <source>Libc.calloc()</source>
          <target state="translated">Libc.calloc()</target>
        </trans-unit>
        <trans-unit id="1f4d269c85f0cdd9201cbed97992b84adebdf595" translate="yes" xml:space="preserve">
          <source>Libc.errno()</source>
          <target state="translated">Libc.errno()</target>
        </trans-unit>
        <trans-unit id="0848e3c16acc14bb2ec577b598d650c18e77b315" translate="yes" xml:space="preserve">
          <source>Libc.flush_cstdio()</source>
          <target state="translated">Libc.flush_cstdio()</target>
        </trans-unit>
        <trans-unit id="3ce556c3b59d7aa2c3af19ecb0b6877f650470df" translate="yes" xml:space="preserve">
          <source>Libc.free()</source>
          <target state="translated">Libc.free()</target>
        </trans-unit>
        <trans-unit id="b0704af4d5eaf445364159bc7d46c36ac0dd99b9" translate="yes" xml:space="preserve">
          <source>Libc.gethostname()</source>
          <target state="translated">Libc.gethostname()</target>
        </trans-unit>
        <trans-unit id="34f021f7afa28bfc40d0c964b655d57537eeeb56" translate="yes" xml:space="preserve">
          <source>Libc.getpid()</source>
          <target state="translated">Libc.getpid()</target>
        </trans-unit>
        <trans-unit id="b3ae4ddcce36b5e6214d98b8603cc79d72f7795f" translate="yes" xml:space="preserve">
          <source>Libc.malloc()</source>
          <target state="translated">Libc.malloc()</target>
        </trans-unit>
        <trans-unit id="755d16743ca50b746f3e9f832dc2d5638fe7b1d4" translate="yes" xml:space="preserve">
          <source>Libc.realloc()</source>
          <target state="translated">Libc.realloc()</target>
        </trans-unit>
        <trans-unit id="189c473490df982a84b81ce12725d8d1b054705a" translate="yes" xml:space="preserve">
          <source>Libc.strerror()</source>
          <target state="translated">Libc.strerror()</target>
        </trans-unit>
        <trans-unit id="9c2a2e1ec6af2d38549c677ba7248e856a349879" translate="yes" xml:space="preserve">
          <source>Libc.strftime()</source>
          <target state="translated">Libc.strftime()</target>
        </trans-unit>
        <trans-unit id="291439a5e7bded77e555ba7822b85155ea0e9ab9" translate="yes" xml:space="preserve">
          <source>Libc.strptime()</source>
          <target state="translated">Libc.strptime()</target>
        </trans-unit>
        <trans-unit id="50e854ed1dcc836eb5e225047ee11442a2f80cd3" translate="yes" xml:space="preserve">
          <source>Libc.systemsleep()</source>
          <target state="translated">Libc.systemsleep()</target>
        </trans-unit>
        <trans-unit id="81d6424efbc87c9c17b0813b0c148152bd3c2475" translate="yes" xml:space="preserve">
          <source>Libc.time()</source>
          <target state="translated">Libc.time()</target>
        </trans-unit>
        <trans-unit id="f9ac7f64b772b55f84e761baea56c702c55005b2" translate="yes" xml:space="preserve">
          <source>Libdl.RTLD_NOW</source>
          <target state="translated">Libdl.RTLD_NOW</target>
        </trans-unit>
        <trans-unit id="754e38c44e40a9e9cb516d0f693c9b5afa0d7ec7" translate="yes" xml:space="preserve">
          <source>Libdl.dlclose()</source>
          <target state="translated">Libdl.dlclose()</target>
        </trans-unit>
        <trans-unit id="b20c01d11dde97a5fa90df2ec685adbcf15207ab" translate="yes" xml:space="preserve">
          <source>Libdl.dlext</source>
          <target state="translated">Libdl.dlext</target>
        </trans-unit>
        <trans-unit id="bbe848e2a374e3e28b9be1468210bde354760df9" translate="yes" xml:space="preserve">
          <source>Libdl.dlopen()</source>
          <target state="translated">Libdl.dlopen()</target>
        </trans-unit>
        <trans-unit id="bc44712bf06d7cde2930672cea24ac5283dc04d2" translate="yes" xml:space="preserve">
          <source>Libdl.dlopen_e()</source>
          <target state="translated">Libdl.dlopen_e()</target>
        </trans-unit>
        <trans-unit id="f76c025cd327748a8ae48ab21c1d0d6937ee6cf3" translate="yes" xml:space="preserve">
          <source>Libdl.dlsym()</source>
          <target state="translated">Libdl.dlsym()</target>
        </trans-unit>
        <trans-unit id="ddc83875e28b579f9ad7f02bee458a0c03e115cf" translate="yes" xml:space="preserve">
          <source>Libdl.dlsym_e()</source>
          <target state="translated">Libdl.dlsym_e()</target>
        </trans-unit>
        <trans-unit id="e5858af9f095388c617c420aefd6c16e0594c3bf" translate="yes" xml:space="preserve">
          <source>Libdl.find_library()</source>
          <target state="translated">Libdl.find_library()</target>
        </trans-unit>
        <trans-unit id="cb8e2b307865af7fc3116bd1827bf102132b7b87" translate="yes" xml:space="preserve">
          <source>Libra</source>
          <target state="translated">Libra</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MITライセンスに基づいてライセンスされています。</target>
        </trans-unit>
        <trans-unit id="8a1bb5e870bb9b77202596bab439b6db423dbba2" translate="yes" xml:space="preserve">
          <source>Light Rail</source>
          <target state="translated">ライトレール</target>
        </trans-unit>
        <trans-unit id="4944819e2ca85d61a3c9e24619e3eb246b5a52a9" translate="yes" xml:space="preserve">
          <source>Light Shade</source>
          <target state="translated">ライトシェード</target>
        </trans-unit>
        <trans-unit id="9921ca32d9a43716da2c222cd03f37ec5fd109a5" translate="yes" xml:space="preserve">
          <source>Lightweight &quot;green&quot; threading (&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;coroutines&lt;/a&gt;)</source>
          <target state="translated">軽量の「グリーン」スレッディング（&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;コルーチン&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="8a26ac5926eeae89368f7fb44a40e4b026751c42" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt;, but store the result of &lt;code&gt;broadcast(f, As...)&lt;/code&gt; in the &lt;code&gt;dest&lt;/code&gt; array. Note that &lt;code&gt;dest&lt;/code&gt; is only used to store the result, and does not supply arguments to &lt;code&gt;f&lt;/code&gt; unless it is also listed in the &lt;code&gt;As&lt;/code&gt;, as in &lt;code&gt;broadcast!(f, A, A, B)&lt;/code&gt; to perform &lt;code&gt;A[:] = broadcast(f, A, B)&lt;/code&gt;.</source>
          <target state="translated">以下のような&lt;a href=&quot;#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt;が、結果格納 &lt;code&gt;broadcast(f, As...)&lt;/code&gt; に &lt;code&gt;dest&lt;/code&gt; 配列。そのノート &lt;code&gt;dest&lt;/code&gt; が結果だけを格納するために使用され、且つに引数を供給しない &lt;code&gt;f&lt;/code&gt; それはまたにリストされていない限り &lt;code&gt;As&lt;/code&gt; のように、 &lt;code&gt;broadcast!(f, A, A, B)&lt;/code&gt; 実行する &lt;code&gt;A[:] = broadcast(f, A, B)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1bc834338e49af8951a520f98a93394195b34a0" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt;&lt;code&gt;uperm&lt;/code&gt;&lt;/a&gt; but gets the permissions for people who neither own the file nor are a member of the group owning the file</source>
          <target state="translated">同様&lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt; &lt;code&gt;uperm&lt;/code&gt; &lt;/a&gt;が、どちらもファイルを所有することも、ファイルを所有するグループのメンバーである人々のための権限を取得します</target>
        </trans-unit>
        <trans-unit id="52da4e2a0d663a1dbba38c505be636c82ff3a124" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt;&lt;code&gt;uperm&lt;/code&gt;&lt;/a&gt; but gets the permissions of the group owning the file.</source>
          <target state="translated">同様&lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt; &lt;code&gt;uperm&lt;/code&gt; &lt;/a&gt;が、ファイルを所有するグループのアクセス権を取得します。</target>
        </trans-unit>
        <trans-unit id="28e1f410620d4fc1c47d7926e96c9bea23f8d4c1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Sort.partialsortperm&quot;&gt;&lt;code&gt;partialsortperm&lt;/code&gt;&lt;/a&gt;, but accepts a preallocated index vector &lt;code&gt;ix&lt;/code&gt; the same size as &lt;code&gt;v&lt;/code&gt;, which is used to store (a permutation of) the indices of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.Sort.partialsortperm&quot;&gt; &lt;code&gt;partialsortperm&lt;/code&gt; &lt;/a&gt;と同様ですが、 &lt;code&gt;v&lt;/code&gt; と同じサイズの事前に割り当てられたインデックスベクトル &lt;code&gt;ix&lt;/code&gt; を受け入れます。これは、 &lt;code&gt;v&lt;/code&gt; のインデックス（の順列）を格納するために使用されます。</target>
        </trans-unit>
        <trans-unit id="55b69ac4b886c93cd981119d2156a08505ea6f20" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Sort.partialsortperm&quot;&gt;&lt;code&gt;partialsortperm&lt;/code&gt;&lt;/a&gt;, but accepts a preallocated index vector &lt;code&gt;ix&lt;/code&gt;. If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), &lt;code&gt;ix&lt;/code&gt; is initialized to contain the values &lt;code&gt;1:length(ix)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.Sort.partialsortperm&quot;&gt; &lt;code&gt;partialsortperm&lt;/code&gt; &lt;/a&gt;に似ていますが、事前に割り当てられたインデックスベクトル &lt;code&gt;ix&lt;/code&gt; を受け入れます。場合は &lt;code&gt;initialized&lt;/code&gt; ある &lt;code&gt;false&lt;/code&gt; （デフォルト）、 &lt;code&gt;ix&lt;/code&gt; 値格納するように初期化された &lt;code&gt;1:length(ix)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="529e4e84127591bc458006a7c31028da87258a93" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.asyncmap&quot;&gt;&lt;code&gt;asyncmap&lt;/code&gt;&lt;/a&gt;, but stores output in &lt;code&gt;results&lt;/code&gt; rather than returning a collection.</source>
          <target state="translated">同様&lt;a href=&quot;#Base.asyncmap&quot;&gt; &lt;code&gt;asyncmap&lt;/code&gt; &lt;/a&gt;ではなく、店舗の出力 &lt;code&gt;results&lt;/code&gt; ではなく、コレクションを返します。</target>
        </trans-unit>
        <trans-unit id="06d62bd10c05ce2bf6e378f3ac0cebfd0dc1f43e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;, except reads code from the given string rather than from a file.</source>
          <target state="translated">&lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt;と同様ですが、ファイルからではなく、指定された文字列からコードを読み取ります。</target>
        </trans-unit>
        <trans-unit id="33fc1f575b86086215aa1689af4abbedb592d014" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, but stores the result in &lt;code&gt;destination&lt;/code&gt; rather than a new collection. &lt;code&gt;destination&lt;/code&gt; must be at least as large as the first collection.</source>
          <target state="translated">&lt;a href=&quot;#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;に似ていますが、結果を新しいコレクションではなく &lt;code&gt;destination&lt;/code&gt; 保存します。 &lt;code&gt;destination&lt;/code&gt; は、少なくとも最初のコレクションと同じ大きさでなければなりません。</target>
        </trans-unit>
        <trans-unit id="9053e0f6dd39d888ac2c2e819878de129f87dfec" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapreduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed left associativity, as in &lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldl&lt;/code&gt;&lt;/a&gt;. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">同様&lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapreduce&lt;/code&gt; &lt;/a&gt;、しかし、のように保証する左結合性、と&lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldl&lt;/code&gt; の&lt;/a&gt;。指定すると、キーワード引数 &lt;code&gt;init&lt;/code&gt; が1回だけ使用されます。一般に、空のコレクションを処理するには &lt;code&gt;init&lt;/code&gt; を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="ffe977f18117519aca83d726747101ffed876b72" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapreduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed right associativity, as in &lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldr&lt;/code&gt;&lt;/a&gt;. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">&lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapreduce&lt;/code&gt; &lt;/a&gt;と似ていますが、&lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldr&lt;/code&gt; の&lt;/a&gt;ように正しい結合性が保証されています。指定すると、キーワード引数 &lt;code&gt;init&lt;/code&gt; が1回だけ使用されます。一般に、空のコレクションを処理するには &lt;code&gt;init&lt;/code&gt; を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="9d8eaa8363c2e7fc8a90587868e4968a125caadc" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt;, but returns either a value of the requested type, or &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; if the string does not contain a valid number.</source>
          <target state="translated">&lt;a href=&quot;#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt;に似ていますが、リクエストされたタイプの値を返すか、文字列に有効な数値が含まれていない場合は&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;返しません。</target>
        </trans-unit>
        <trans-unit id="51eaec3c8abd237c8d9e9bba6cf07e3a4cb08010" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.permute!-Tuple%7BAny,AbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt;&lt;code&gt;permute!&lt;/code&gt;&lt;/a&gt;, but the inverse of the given permutation is applied.</source>
          <target state="translated">以下のように&lt;a href=&quot;#Base.permute!-Tuple%7BAny,AbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt; &lt;code&gt;permute!&lt;/code&gt; &lt;/a&gt;、ただし指定された順列の逆が適用されます。</target>
        </trans-unit>
        <trans-unit id="4756a006313f096261885c0ef2037e8fe0a50c17" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.redirect_stdout&quot;&gt;&lt;code&gt;redirect_stdout&lt;/code&gt;&lt;/a&gt;, but for &lt;a href=&quot;#Base.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.redirect_stdout&quot;&gt; &lt;code&gt;redirect_stdout&lt;/code&gt; &lt;/a&gt;に似ていますが、&lt;a href=&quot;#Base.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f085d340882a97bb66329f21bdf7b61cf3ba9878" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.redirect_stdout&quot;&gt;&lt;code&gt;redirect_stdout&lt;/code&gt;&lt;/a&gt;, but for &lt;a href=&quot;#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;. Note that the order of the return tuple is still &lt;code&gt;(rd, wr)&lt;/code&gt;, i.e. data to be read from &lt;a href=&quot;#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; may be written to &lt;code&gt;wr&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.redirect_stdout&quot;&gt; &lt;code&gt;redirect_stdout&lt;/code&gt; &lt;/a&gt;と似ていますが、&lt;a href=&quot;#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;です。戻りタプルの順序はまだ &lt;code&gt;(rd, wr)&lt;/code&gt; であることに注意してください。つまり、&lt;a href=&quot;#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;から読み取るデータは &lt;code&gt;wr&lt;/code&gt; に書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="5f5dd7f815a4d7bf1a89e4740bb5b8ac9a464da9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed left associativity. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">&lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;と同様ですが、左結合性が保証されています。指定すると、キーワード引数 &lt;code&gt;init&lt;/code&gt; が1回だけ使用されます。一般に、空のコレクションを処理するには &lt;code&gt;init&lt;/code&gt; を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="024595a61bd923552b757965d3ba72515fa95986" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed right associativity. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">&lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;と同様ですが、正しい結合性が保証されています。指定すると、キーワード引数 &lt;code&gt;init&lt;/code&gt; が1回だけ使用されます。一般に、空のコレクションを処理するには &lt;code&gt;init&lt;/code&gt; を提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="1ef0876ab486f437b72ce65e44751d3b6dbccac7" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.sortperm&quot;&gt;&lt;code&gt;sortperm&lt;/code&gt;&lt;/a&gt;, but accepts a preallocated index vector &lt;code&gt;ix&lt;/code&gt;. If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), &lt;code&gt;ix&lt;/code&gt; is initialized to contain the values &lt;code&gt;1:length(v)&lt;/code&gt;.</source>
          <target state="translated">同様&lt;a href=&quot;#Base.sortperm&quot;&gt; &lt;code&gt;sortperm&lt;/code&gt; &lt;/a&gt;が、事前に割り当てられたインデックスベクトル受け入れ &lt;code&gt;ix&lt;/code&gt; 。場合は &lt;code&gt;initialized&lt;/code&gt; ある &lt;code&gt;false&lt;/code&gt; （デフォルト）、 &lt;code&gt;ix&lt;/code&gt; 値格納するように初期化された &lt;code&gt;1:length(v)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08026f6d5cc67e6a499233d241ca672fd865f4fa" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt;, but for symbolic links gets the info for the link itself rather than the file it refers to. This function must be called on a file path rather than a file object or a file descriptor.</source>
          <target state="translated">&lt;a href=&quot;#Base.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;に似ていますが、シンボリックリンクの場合、参照先のファイルではなく、リンク自体の情報を取得します。この関数は、ファイルオブジェクトやファイル記述子ではなく、ファイルパスで呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="f60e04278b9015f6c3e9ffaf7e10b12cd6419309" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.systemerror&quot;&gt;&lt;code&gt;systemerror&lt;/code&gt;&lt;/a&gt;, but for Windows API functions that use &lt;a href=&quot;../libc/index#Base.Libc.GetLastError&quot;&gt;&lt;code&gt;GetLastError&lt;/code&gt;&lt;/a&gt; to return an error code instead of setting &lt;a href=&quot;../libc/index#Base.Libc.errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#Base.systemerror&quot;&gt; &lt;code&gt;systemerror&lt;/code&gt; &lt;/a&gt;と同様ですが、&lt;a href=&quot;../libc/index#Base.Libc.errno&quot;&gt; &lt;code&gt;errno&lt;/code&gt; &lt;/a&gt;を設定する代わりに&lt;a href=&quot;../libc/index#Base.Libc.GetLastError&quot;&gt; &lt;code&gt;GetLastError&lt;/code&gt; &lt;/a&gt;を使用してエラーコードを返すWindowsAPI関数の場合です。</target>
        </trans-unit>
        <trans-unit id="b3086501e29c75ea565e72a0019576b980b02fe5" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Random.randsubseq&quot;&gt;&lt;code&gt;randsubseq&lt;/code&gt;&lt;/a&gt;, but the results are stored in &lt;code&gt;S&lt;/code&gt; (which is resized as needed).</source>
          <target state="translated">&lt;a href=&quot;#Random.randsubseq&quot;&gt; &lt;code&gt;randsubseq&lt;/code&gt; &lt;/a&gt;と同様ですが、結果は &lt;code&gt;S&lt;/code&gt; に格納されます（Sは必要に応じてサイズ変更されます）。</target>
        </trans-unit>
        <trans-unit id="eb969f16d7c8b092d782534c60f5aa57438f02b4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Statistics.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;, but may overwrite the input vector.</source>
          <target state="translated">&lt;a href=&quot;#Statistics.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt;に似ていますが、入力ベクトルを上書きする可能性があります。</target>
        </trans-unit>
        <trans-unit id="c740cd8f4daa963edb800319e0b46fdd4c9b8a9e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, but returns a view into the parent array &lt;code&gt;A&lt;/code&gt; with the given indices instead of making a copy. Calling &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt; on the returned &lt;code&gt;SubArray&lt;/code&gt; computes the indices to the parent array on the fly without checking bounds.</source>
          <target state="translated">&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;と似ていますが、コピーを作成する代わりに、指定されたインデックスを持つ親配列 &lt;code&gt;A&lt;/code&gt; にビューを返します。&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;またはsetindexを呼び出す&lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;返された &lt;code&gt;SubArray&lt;/code&gt; では、境界をチェックせずに、その場で親配列へのインデックスを計算します。</target>
        </trans-unit>
        <trans-unit id="a4ecbe47eb2e0c87296b762b01d3e9398f50b6c5" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, but returns a view into the parent string &lt;code&gt;s&lt;/code&gt; within range &lt;code&gt;i:j&lt;/code&gt; or &lt;code&gt;r&lt;/code&gt; respectively instead of making a copy.</source>
          <target state="translated">&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;と同様ですが、コピーを作成する代わりに、範囲 &lt;code&gt;i:j&lt;/code&gt; または &lt;code&gt;r&lt;/code&gt; 内の親文字列 &lt;code&gt;s&lt;/code&gt; にそれぞれビューを返します。</target>
        </trans-unit>
        <trans-unit id="c974955b45097854e43f11799b1b6bcc9d8f3eee" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SamplerDie&lt;/code&gt;, any custom sampler must be a subtype of &lt;code&gt;Sampler{T}&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is the type of the generated values. Note that &lt;code&gt;SamplerSimple(x, data) isa Sampler{eltype(x)}&lt;/code&gt;, so this constrains what the first argument to &lt;code&gt;SamplerSimple&lt;/code&gt; can be (it's recommended to use &lt;code&gt;SamplerSimple&lt;/code&gt; like in the &lt;code&gt;Die&lt;/code&gt; example, where &lt;code&gt;x&lt;/code&gt; is simply forwarded while defining a &lt;code&gt;Sampler&lt;/code&gt; method). Similarly, &lt;code&gt;SamplerTrivial(x) isa Sampler{eltype(x)}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SamplerDie&lt;/code&gt; と同様に、カスタムサンプラーは &lt;code&gt;Sampler{T}&lt;/code&gt; サブタイプである必要があります。ここで、 &lt;code&gt;T&lt;/code&gt; は生成された値のタイプです。なお、 &lt;code&gt;SamplerSimple(x, data) isa Sampler{eltype(x)}&lt;/code&gt; 、最初の引数何この制約よう &lt;code&gt;SamplerSimple&lt;/code&gt; は、使用することをお勧めします（することができる &lt;code&gt;SamplerSimple&lt;/code&gt; のと同様に &lt;code&gt;Die&lt;/code&gt; 例えば、 &lt;code&gt;x&lt;/code&gt; 定義しながら、単に転送さ &lt;code&gt;Sampler&lt;/code&gt; 方法）。同様に、 &lt;code&gt;SamplerTrivial(x) isa Sampler{eltype(x)}&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="807404638eb67f1a49cc813e53a998bea5df9d33" translate="yes" xml:space="preserve">
          <source>Like C and Java, but unlike most dynamic languages, Julia has a first-class type for representing a single character, called &lt;a href=&quot;../../base/strings/index#Core.AbstractChar&quot;&gt;&lt;code&gt;AbstractChar&lt;/code&gt;&lt;/a&gt;. The built-in &lt;a href=&quot;../../base/strings/index#Core.Char&quot;&gt;&lt;code&gt;Char&lt;/code&gt;&lt;/a&gt; subtype of &lt;code&gt;AbstractChar&lt;/code&gt; is a 32-bit primitive type that can represent any Unicode character (and which is based on the UTF-8 encoding).</source>
          <target state="translated">CやJavaと同様ですが、ほとんどの動的言語とは異なり、Juliaには、&lt;a href=&quot;../../base/strings/index#Core.AbstractChar&quot;&gt; &lt;code&gt;AbstractChar&lt;/code&gt; &lt;/a&gt;と呼ばれる単一の文字を表すためのファーストクラスの型があります。 &lt;code&gt;AbstractChar&lt;/code&gt; の組み込み&lt;a href=&quot;../../base/strings/index#Core.Char&quot;&gt; &lt;code&gt;Char&lt;/code&gt; &lt;/a&gt;サブタイプは、任意のUnicode文字を表すことができる32ビットのプリミティブ型です（UTF-8エンコーディングに基づいています）。</target>
        </trans-unit>
        <trans-unit id="b144d1ab3b4daafe713dd1906d84dd6576675e14" translate="yes" xml:space="preserve">
          <source>Like ccall, all of these arguments will be evaluated at compile-time, when the containing method is defined.</source>
          <target state="translated">ccall と同様に、これらの引数はすべて、含まれるメソッドが定義されたときにコンパイル時に評価されます。</target>
        </trans-unit>
        <trans-unit id="d14af23f7b07876d0e17dec387b3e911da07b564" translate="yes" xml:space="preserve">
          <source>Like many languages, Julia does not always allow operations on vectors of different lengths, unlike R where the vectors only need to share a common index range. For example, &lt;code&gt;c(1, 2, 3, 4) + c(1, 2)&lt;/code&gt; is valid R but the equivalent &lt;code&gt;[1, 2, 3, 4] + [1, 2]&lt;/code&gt; will throw an error in Julia.</source>
          <target state="translated">多くの言語と同様に、ジュリアは、ベクトルが共通のインデックス範囲のみを共有する必要があるRとは異なり、異なる長さのベクトルでの操作を常に許可するわけではありません。たとえば、 &lt;code&gt;c(1, 2, 3, 4) + c(1, 2)&lt;/code&gt; は有効なRですが、同等の &lt;code&gt;[1, 2, 3, 4] + [1, 2]&lt;/code&gt; はJuliaでエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="76129ab650b5177af08ad48252475d8daddeec47" translate="yes" xml:space="preserve">
          <source>Like many other environments, Julia has an &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; function, which takes a filename and returns an &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt;&lt;code&gt;IOStream&lt;/code&gt;&lt;/a&gt; object that you can use to read and write things from the file. For example, if we have a file, &lt;code&gt;hello.txt&lt;/code&gt;, whose contents are &lt;code&gt;Hello, World!&lt;/code&gt;:</source>
          <target state="translated">他の多くの環境と同様に、Juliaには&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;関数があり、ファイル名を受け取り、ファイルからの読み取りと書き込みに使用できる&lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt; &lt;code&gt;IOStream&lt;/code&gt; &lt;/a&gt;オブジェクトを返します。たとえば、 &lt;code&gt;hello.txt&lt;/code&gt; というファイルがあり、その内容が &lt;code&gt;Hello, World!&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1f57deb1de610f6542b69d3ee454e00aa561ce8c" translate="yes" xml:space="preserve">
          <source>Like non-standard string literals, non-standard command literals exist using a prefixed variant of the command literal syntax. The command literal &lt;code&gt;custom`literal`&lt;/code&gt; is parsed as &lt;code&gt;@custom_cmd &quot;literal&quot;&lt;/code&gt;. Julia itself does not contain any non-standard command literals, but packages can make use of this syntax. Aside from the different syntax and the &lt;code&gt;_cmd&lt;/code&gt; suffix instead of the &lt;code&gt;_str&lt;/code&gt; suffix, non-standard command literals behave exactly like non-standard string literals.</source>
          <target state="translated">非標準の文字列リテラルと同様に、非標準のコマンドリテラルは、コマンドリテラル構文のプレフィックス付きのバリアントを使用して存在します。コマンドリテラル &lt;code&gt;custom`literal`&lt;/code&gt; は &lt;code&gt;@custom_cmd &quot;literal&quot;&lt;/code&gt; として解析されます。Julia自体には非標準のコマンドリテラルは含まれていませんが、パッケージはこの構文を利用できます。異なる構文と、 &lt;code&gt;_cmd&lt;/code&gt; サフィックスではなく_cmdサフィックスを &lt;code&gt;_str&lt;/code&gt; 、非標準のコマンドリテラルは、非標準の文字列リテラルとまったく同じように動作します。</target>
        </trans-unit>
        <trans-unit id="ca04337635b1b8ca769f7475dd5bb9a710a07316" translate="yes" xml:space="preserve">
          <source>Like remote references, shared arrays are also dependent on garbage collection on the creating node to release references from all participating workers. Code which creates many short lived shared array objects would benefit from explicitly finalizing these objects as soon as possible. This results in both memory and file handles mapping the shared segment being released sooner.</source>
          <target state="translated">リモート参照と同様に、共有配列もまた、参加しているすべてのワーカーから参照を解放するために、作成ノードのガベージコレクションに依存しています。短期間で多くの共有配列オブジェクトを作成するコードでは、これらのオブジェクトをできるだけ早く明示的に最終化することが有益です。これにより、共有セグメントをマッピングするメモリとファイルハンドルの両方がより早く解放されます。</target>
        </trans-unit>
        <trans-unit id="bc02118fe44dfd1db0138406f1b30a59afe69954" translate="yes" xml:space="preserve">
          <source>Likewise, the global variable &lt;code&gt;Base.SYSCONFDIR&lt;/code&gt; determines a relative path to the configuration file directory. Then Julia searches for a &lt;code&gt;startup.jl&lt;/code&gt; file at</source>
          <target state="translated">同様に、グローバル変数 &lt;code&gt;Base.SYSCONFDIR&lt;/code&gt; は、構成ファイルディレクトリへの相対パスを決定します。次にJuliaは、 &lt;code&gt;startup.jl&lt;/code&gt; ファイルを次の場所で検索します。</target>
        </trans-unit>
        <trans-unit id="40654ee5f02852c7196e6e2f00f07fee2fb0ef03" translate="yes" xml:space="preserve">
          <source>Limit usage of CPU features up to &lt;code&gt;&amp;lt;target&amp;gt;&lt;/code&gt;; set to &lt;code&gt;help&lt;/code&gt; to see the available options</source>
          <target state="translated">CPU機能の使用を &lt;code&gt;&amp;lt;target&amp;gt;&lt;/code&gt; までに制限します。利用可能なオプションを確認する &lt;code&gt;help&lt;/code&gt; に設定します</target>
        </trans-unit>
        <trans-unit id="8d96ce8bb4e79cb43743b90921151985b53e510c" translate="yes" xml:space="preserve">
          <source>LinRange</source>
          <target state="translated">LinRange</target>
        </trans-unit>
        <trans-unit id="d937e9c2df56b1e58e5b8819252e720563fa79ea" translate="yes" xml:space="preserve">
          <source>Line 3 of &lt;code&gt;myfunc&lt;/code&gt; contains the call to &lt;code&gt;maximum&lt;/code&gt;, and there were 28 (out of 80) backtraces taken here. Below that, you can see the specific places in &lt;code&gt;base/reduce.jl&lt;/code&gt; that carry out the time-consuming operations in the &lt;code&gt;maximum&lt;/code&gt; function for this type of input data.</source>
          <target state="translated">3行目 &lt;code&gt;myfunc&lt;/code&gt; 関数はへの呼び出しが含まれ &lt;code&gt;maximum&lt;/code&gt; 、そしてここで撮影したバックトレース（80のうちの）28がありました。その下に、このタイプの入力データの &lt;code&gt;maximum&lt;/code&gt; 関数で時間のかかる操作を実行する &lt;code&gt;base/reduce.jl&lt;/code&gt; の特定の場所が表示されます。</target>
        </trans-unit>
        <trans-unit id="677b9ff91279f2c92df14e8f98feaaad0ff02671" translate="yes" xml:space="preserve">
          <source>Line Integration Not Including The Pole</source>
          <target state="translated">ポールを含まないライン統合</target>
        </trans-unit>
        <trans-unit id="aa862b80ca648d32974899a07b490c840367365f" translate="yes" xml:space="preserve">
          <source>Line Integration With Rectangular Path Around Pole</source>
          <target state="translated">ポールの周りに長方形の経路を持つ線の統合</target>
        </trans-unit>
        <trans-unit id="cd235d8e390a116750618564e9fef4ddd8d815c0" translate="yes" xml:space="preserve">
          <source>Line Integration With Semicircular Path Around Pole</source>
          <target state="translated">極付近の半円経路を用いた線積分</target>
        </trans-unit>
        <trans-unit id="fcb739908d0a50031f680d3b4fffc6749c4002d3" translate="yes" xml:space="preserve">
          <source>Linear Algebra</source>
          <target state="translated">線形代数</target>
        </trans-unit>
        <trans-unit id="3ab90484838b94648400b6fcaea9c0833f594271" translate="yes" xml:space="preserve">
          <source>Linear algebra functions in Julia are largely implemented by calling functions from &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK&lt;/a&gt;. Sparse factorizations call functions from &lt;a href=&quot;http://faculty.cse.tamu.edu/davis/suitesparse.html&quot;&gt;SuiteSparse&lt;/a&gt;.</source>
          <target state="translated">Juliaの線形代数関数は、主に&lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK&lt;/a&gt;から関数を呼び出すことによって実装されます。スパース分解は&lt;a href=&quot;http://faculty.cse.tamu.edu/davis/suitesparse.html&quot;&gt;SuiteSparse&lt;/a&gt;から関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="d1c65bd6bdbd1cc3a07c925c8d1f63a9ef479713" translate="yes" xml:space="preserve">
          <source>Linear index to cartesian index conversion exploits the fact that a &lt;code&gt;CartesianIndices&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt; and can be indexed linearly:</source>
          <target state="translated">線形インデックスからデカルトインデックスへの変換は、 &lt;code&gt;CartesianIndices&lt;/code&gt; が &lt;code&gt;AbstractArray&lt;/code&gt; であり、線形インデックスを付けることができるという事実を利用しています。</target>
        </trans-unit>
        <trans-unit id="c1c4acc4812d010d9f4c5b8b2c947ad6bf3a9bbc" translate="yes" xml:space="preserve">
          <source>Linear indexing</source>
          <target state="translated">リニアインデックス</target>
        </trans-unit>
        <trans-unit id="a4c16b0102a66cf314085c9fb0015204063e6fd3" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Adjoint</source>
          <target state="translated">LinearAlgebra.Adjoint</target>
        </trans-unit>
        <trans-unit id="f15dbf32eea38f12565a79b8c505de8f87a92ec9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS</source>
          <target state="translated">LinearAlgebra.BLAS</target>
        </trans-unit>
        <trans-unit id="e45107bca3f2265e5d9c85ca1c9fec27cc17de1c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.asum()</source>
          <target state="translated">LinearAlgebra.BLAS.asum()</target>
        </trans-unit>
        <trans-unit id="0372d64ede3f868ef8099f9d2d0ba0d26301cae5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.blascopy!()</source>
          <target state="translated">LinearAlgebra.BLAS.blascopy!()</target>
        </trans-unit>
        <trans-unit id="d13717e84d8e032e30650fc47582fb7cd32b85c2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.dotc()</source>
          <target state="translated">LinearAlgebra.BLAS.dotc()</target>
        </trans-unit>
        <trans-unit id="80b561d6fb654a4f5dbc4d039a743babeb78f05a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.dotu()</source>
          <target state="translated">LinearAlgebra.BLAS.dotu()</target>
        </trans-unit>
        <trans-unit id="182543675c48dfba38aa5478d8ce3279d26d4ef4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gbmv!()</source>
          <target state="translated">LinearAlgebra.BLAS.gbmv!()</target>
        </trans-unit>
        <trans-unit id="6cec9f631b39a94bb3001b07c15c7364aacddbae" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gbmv()</source>
          <target state="translated">LinearAlgebra.BLAS.gbmv()</target>
        </trans-unit>
        <trans-unit id="59202f7fad0ff0f17101364487458d9228718112" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemm!()</source>
          <target state="translated">LinearAlgebra.BLAS.gemm!()</target>
        </trans-unit>
        <trans-unit id="a90dea0e894e7db5d100f0da8dd99eb55becb11a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemm()</source>
          <target state="translated">LinearAlgebra.BLAS.gemm()</target>
        </trans-unit>
        <trans-unit id="9c43130d6006aefdd06d70d7199a76e138e6d41f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemv!()</source>
          <target state="translated">LinearAlgebra.BLAS.gemv!()</target>
        </trans-unit>
        <trans-unit id="9e7d057213847eff9fcee5278de6f9c65c129248" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemv()</source>
          <target state="translated">LinearAlgebra.BLAS.gemv()</target>
        </trans-unit>
        <trans-unit id="7de983e341dd493a6005bdeccd16b2008abe1b4c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.ger!()</source>
          <target state="translated">LinearAlgebra.BLAS.ger!()</target>
        </trans-unit>
        <trans-unit id="c508786b30abc595e3c001798b77caf3e83ceab1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.her!()</source>
          <target state="translated">LinearAlgebra.BLAS.her!()</target>
        </trans-unit>
        <trans-unit id="01f3abbc9926c6680a10dada97213576f68220e4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.herk!()</source>
          <target state="translated">LinearAlgebra.BLAS.herk!()</target>
        </trans-unit>
        <trans-unit id="7ca416ce67850358cd75772ae19bf13edb1e3145" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.herk()</source>
          <target state="translated">LinearAlgebra.BLAS.herk()</target>
        </trans-unit>
        <trans-unit id="ae660954410680fe7bf17073b8a5a13e3d858105" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.iamax()</source>
          <target state="translated">LinearAlgebra.BLAS.iamax()</target>
        </trans-unit>
        <trans-unit id="cd1a2671bbd0fd5d0123954f4b697032be1e635c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.nrm2()</source>
          <target state="translated">LinearAlgebra.BLAS.nrm2()</target>
        </trans-unit>
        <trans-unit id="e90dcf81b0d3bcd42a1f41c82cba29bfcb9a2dc1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.sbmv!()</source>
          <target state="translated">LinearAlgebra.BLAS.sbmv!()</target>
        </trans-unit>
        <trans-unit id="726229488f087bf6f4b29c015474123c38acb7e3" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.sbmv()</source>
          <target state="translated">LinearAlgebra.BLAS.sbmv()</target>
        </trans-unit>
        <trans-unit id="e38b1b5860121c691bed2ff0a82bb4bddb43aeda" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.scal!()</source>
          <target state="translated">LinearAlgebra.BLAS.scal!()</target>
        </trans-unit>
        <trans-unit id="4a5ae3b0e35b9b56d0ca4f544caed75fc4410c97" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.scal()</source>
          <target state="translated">LinearAlgebra.BLAS.scal()</target>
        </trans-unit>
        <trans-unit id="bd2ae45b248f17f2163a416ae8b1b8f316599548" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.set_num_threads()</source>
          <target state="translated">LinearAlgebra.BLAS.set_num_threads()</target>
        </trans-unit>
        <trans-unit id="0ee907ef539363efacff8c904278837def446859" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symm!()</source>
          <target state="translated">LinearAlgebra.BLAS.symm!()</target>
        </trans-unit>
        <trans-unit id="2ca89af9829c4450e1da15d694b423f02feaf2fc" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symm()</source>
          <target state="translated">LinearAlgebra.BLAS.symm()</target>
        </trans-unit>
        <trans-unit id="c4ff899252dc161c59c729ece50db7c6e510be1f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symv!()</source>
          <target state="translated">LinearAlgebra.BLAS.symv!()</target>
        </trans-unit>
        <trans-unit id="c3f814d8d8c968ce7e35bf9e0c795e7503d54b00" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symv()</source>
          <target state="translated">LinearAlgebra.BLAS.symv()</target>
        </trans-unit>
        <trans-unit id="5668a0235a5cc16113ef6c829d5f4f3cb946eb77" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.syr!()</source>
          <target state="translated">LinearAlgebra.BLAS.syr!()</target>
        </trans-unit>
        <trans-unit id="0ea3ba86e685fafe1804ca06ce2cc0aa30792e4d" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.syrk!()</source>
          <target state="translated">LinearAlgebra.BLAS.syrk!()</target>
        </trans-unit>
        <trans-unit id="2910b73b192710f5034193e1b67ded6bb10699b0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.syrk()</source>
          <target state="translated">LinearAlgebra.BLAS.syrk()</target>
        </trans-unit>
        <trans-unit id="c657c078868b4b49e269336d3ff46af071f8fa01" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmm!()</source>
          <target state="translated">LinearAlgebra.BLAS.trmm!()</target>
        </trans-unit>
        <trans-unit id="04b9bf86a921535849558977a38bc7efdcdd3272" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmm()</source>
          <target state="translated">LinearAlgebra.BLAS.trmm()</target>
        </trans-unit>
        <trans-unit id="9d8cb1ea03abc954f9254445e2db3781f49756de" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmv!()</source>
          <target state="translated">LinearAlgebra.BLAS.trmv!()</target>
        </trans-unit>
        <trans-unit id="72558d3ed3ecbb2cf81ea6ad3401440af8b8f050" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmv()</source>
          <target state="translated">LinearAlgebra.BLAS.trmv()</target>
        </trans-unit>
        <trans-unit id="218cea369dcdb92ba6f1e8b45bda62d05efdb29f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsm!()</source>
          <target state="translated">LinearAlgebra.BLAS.trsm!()</target>
        </trans-unit>
        <trans-unit id="05197b08bc46d65744a62e5816cecfcc72ef9983" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsm()</source>
          <target state="translated">LinearAlgebra.BLAS.trsm()</target>
        </trans-unit>
        <trans-unit id="a147ea56a9e55d82d2590cd764be5c11a28ac42c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsv!()</source>
          <target state="translated">LinearAlgebra.BLAS.trsv!()</target>
        </trans-unit>
        <trans-unit id="3205efa3be1bef6bfc936054e89c97d514d48dc9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsv()</source>
          <target state="translated">LinearAlgebra.BLAS.trsv()</target>
        </trans-unit>
        <trans-unit id="6364f45353271734da7f68207b58b49b90c519aa" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Bidiagonal</source>
          <target state="translated">LinearAlgebra.Bidiagonal</target>
        </trans-unit>
        <trans-unit id="b0cf658cc297affd7bac8f29cb18f8d5898c988a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Diagonal</source>
          <target state="translated">LinearAlgebra.Diagonal</target>
        </trans-unit>
        <trans-unit id="1b39c6247cb769989ac9ddbddb50b7a2c7340d63" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Givens</source>
          <target state="translated">LinearAlgebra.Givens</target>
        </trans-unit>
        <trans-unit id="202cd7384296c88f891bea55496b32195e848e3c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Hermitian</source>
          <target state="translated">LinearAlgebra.Hermitian</target>
        </trans-unit>
        <trans-unit id="79fc319c7c269772fed2f361672bd676a3520fae" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.I</source>
          <target state="translated">LinearAlgebra.I</target>
        </trans-unit>
        <trans-unit id="2a1626ced0dce6995c5f58e8d3def911fe7d751f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK</source>
          <target state="translated">LinearAlgebra.LAPACK</target>
        </trans-unit>
        <trans-unit id="6952bafd874a0b24bee2d594a25adae4924e4368" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.bdsdc!()</source>
          <target state="translated">LinearAlgebra.LAPACK.bdsdc!()</target>
        </trans-unit>
        <trans-unit id="8d0c6a0d204bac9380f45220c8b25a01fbcacfc6" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.bdsqr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.bdsqr!()</target>
        </trans-unit>
        <trans-unit id="21f727539d33d03dc8b986b7ecf7ebc53925b185" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gbtrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gbtrf!()</target>
        </trans-unit>
        <trans-unit id="2bb72a67df1d100e66f590117e79a6b1fe23456f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gbtrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gbtrs!()</target>
        </trans-unit>
        <trans-unit id="042b17e7fbbcced06624b5d18cecc1aa4880dfbf" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gebak!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gebak!()</target>
        </trans-unit>
        <trans-unit id="5d6511493ba85c27c966c3e62df9148d39254215" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gebal!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gebal!()</target>
        </trans-unit>
        <trans-unit id="3f829c89a9fa98bb138c195dfc567bcd88556869" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gebrd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gebrd!()</target>
        </trans-unit>
        <trans-unit id="7b9eae4d91dc7949a3ab26f80620c6913329a279" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gecon!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gecon!()</target>
        </trans-unit>
        <trans-unit id="bb09b2b974d5f60b025547cb0fa46b9c45f6eabf" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gees!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gees!()</target>
        </trans-unit>
        <trans-unit id="4adfdd0d27bb95b254d684fb07bba4182c2a0a10" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geev!()</target>
        </trans-unit>
        <trans-unit id="f5fc1d59d033c8ca0452a21a055c7e9b2cdc3409" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geevx!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geevx!()</target>
        </trans-unit>
        <trans-unit id="4162f14b7f241061ff814adad6bc4880eae0e215" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gehrd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gehrd!()</target>
        </trans-unit>
        <trans-unit id="8e52c2ea87a7196909af8b847322a690fcef6a4f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gelqf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gelqf!()</target>
        </trans-unit>
        <trans-unit id="b7bb54e5159886ceee34f20483cdbbf42f4c1539" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gels!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gels!()</target>
        </trans-unit>
        <trans-unit id="7f10b1dc3cf7af9a395a67850e24907c94936d00" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gelsd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gelsd!()</target>
        </trans-unit>
        <trans-unit id="80af9020ee1658e044f9880edaa420f6156e7344" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gelsy!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gelsy!()</target>
        </trans-unit>
        <trans-unit id="0287631b489ed93feb1a00a1ebe340392e903cd8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gemqrt!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gemqrt!()</target>
        </trans-unit>
        <trans-unit id="756fb9e8e80236b54ccbf1725c3d3d72fe14d0a7" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqlf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqlf!()</target>
        </trans-unit>
        <trans-unit id="0fa233b136691bcd50a971792940b70a927e194d" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqp3!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqp3!()</target>
        </trans-unit>
        <trans-unit id="965cf80f5d69f9b2fe0863a82cdd4b368ed4eba1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqrf!()</target>
        </trans-unit>
        <trans-unit id="47893a6fd6bd1458706a0673e1d64d54be6d20ec" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqrt!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqrt!()</target>
        </trans-unit>
        <trans-unit id="94f19bfcd3971a4989d673487abd3bd487d293d1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqrt3!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqrt3!()</target>
        </trans-unit>
        <trans-unit id="19ff37cfcf822fda7f988e77f92c195943446d8b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gerqf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gerqf!()</target>
        </trans-unit>
        <trans-unit id="c47fe5b7f34f49ec65d1767c07d0c357d6c12e20" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesdd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesdd!()</target>
        </trans-unit>
        <trans-unit id="5abf4ebce7739a88e07c58cc2ab150c8e79b9a6f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesv!()</target>
        </trans-unit>
        <trans-unit id="f900ac3ce3ebbd4997a5abaafa85072405326271" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesvd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesvd!()</target>
        </trans-unit>
        <trans-unit id="3a69b9c0d56562dd7ea697ae7f5eea3c3217e8c4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesvx!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesvx!()</target>
        </trans-unit>
        <trans-unit id="997ad4b85fe561bd14fecda4a9185c9be5de7367" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.getrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.getrf!()</target>
        </trans-unit>
        <trans-unit id="d93427849097672e5ca2dd0b81aead36db3bffe6" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.getri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.getri!()</target>
        </trans-unit>
        <trans-unit id="46614120fda23ffee34b46ef06a4d2717d89fb72" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.getrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.getrs!()</target>
        </trans-unit>
        <trans-unit id="3d14f5edf2f52561c8b1cfcc015d4eefd5e8344a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gges!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gges!()</target>
        </trans-unit>
        <trans-unit id="7a73e7bdeb2ad0938d68fd93e6f27345108ba8b1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ggev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ggev!()</target>
        </trans-unit>
        <trans-unit id="3ae17e2685021efceba3fcfa226528ce1e41d6a9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gglse!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gglse!()</target>
        </trans-unit>
        <trans-unit id="3100382b56a5f6703f1da34614842b2f9fd9e2ad" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ggsvd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ggsvd!()</target>
        </trans-unit>
        <trans-unit id="61dfaab553dd3ccfaacf89bcaa2704beb947b945" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ggsvd3!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ggsvd3!()</target>
        </trans-unit>
        <trans-unit id="db05e9a4a5c735805bf40092dca7033de637b064" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gtsv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gtsv!()</target>
        </trans-unit>
        <trans-unit id="9b6b3e96efd10abaf039016da8b07d6fdefa2dac" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gttrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gttrf!()</target>
        </trans-unit>
        <trans-unit id="7d5b231fee9480951dc3ad4ba6239425f9a1a69e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gttrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gttrs!()</target>
        </trans-unit>
        <trans-unit id="56b45916f3c5b6ccae7d5897efff708c77670fe9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hesv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hesv!()</target>
        </trans-unit>
        <trans-unit id="1dd5d2c561afecfbda18ff5f8f3e44ea02e6d2fc" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hetrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hetrf!()</target>
        </trans-unit>
        <trans-unit id="cf6a921b989ce1adbf03be52e76504708a3db4ac" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hetri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hetri!()</target>
        </trans-unit>
        <trans-unit id="a535b2e2552fdefb2e31ef5cf705c68b406e0e4e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hetrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hetrs!()</target>
        </trans-unit>
        <trans-unit id="3c7e4832c831bf40fdec955ad64e7df4981b628e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orghr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orghr!()</target>
        </trans-unit>
        <trans-unit id="9afd9979936c6db6319fad409953eb23f579d5ca" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orglq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orglq!()</target>
        </trans-unit>
        <trans-unit id="72fc39a42e1ba3ec988e4e34aca8961c7d4dd43b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orgql!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orgql!()</target>
        </trans-unit>
        <trans-unit id="3f36d991b78dd60e8ba960e3ddf5db19bd097fb8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orgqr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orgqr!()</target>
        </trans-unit>
        <trans-unit id="18eb3015f314ddb831889efa958dd72893b66864" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orgrq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orgrq!()</target>
        </trans-unit>
        <trans-unit id="ee585149aad96671646932b1d3634278142c13f9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormlq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormlq!()</target>
        </trans-unit>
        <trans-unit id="bdfbc8d40444d8bafd90c67f455d3b34e73228cf" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormql!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormql!()</target>
        </trans-unit>
        <trans-unit id="1087b8488a465127e32826863adc779bd9d1327c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormqr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormqr!()</target>
        </trans-unit>
        <trans-unit id="a2fb188b73bde57195bb1d824030a4ed0bbd608b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormrq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormrq!()</target>
        </trans-unit>
        <trans-unit id="ffa8283f30595d57d465f23f206871d42b88b987" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormrz!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormrz!()</target>
        </trans-unit>
        <trans-unit id="c7253e7d1bd1dce84f707a9c7bb94c23529af18b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.posv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.posv!()</target>
        </trans-unit>
        <trans-unit id="9686f05e5f67aa477b854f99ab98169e47b19084" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.potrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.potrf!()</target>
        </trans-unit>
        <trans-unit id="a162ea4f7602eae7842c83604fa469aeb77c3bfd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.potri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.potri!()</target>
        </trans-unit>
        <trans-unit id="22fdc042984e65bbd42e11f87af366faeef74622" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.potrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.potrs!()</target>
        </trans-unit>
        <trans-unit id="2e152451a9c97ebf916e592216ff01087a6982bd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.pstrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.pstrf!()</target>
        </trans-unit>
        <trans-unit id="9a048d5b8589397c46ecf7dd3a023271382559b0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ptsv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ptsv!()</target>
        </trans-unit>
        <trans-unit id="6bd4c3257dbbd4280e5dfb016628a7275adf1a33" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.pttrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.pttrf!()</target>
        </trans-unit>
        <trans-unit id="959a9d0a79a973f313fff6fc55c623c797c6c7f7" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.pttrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.pttrs!()</target>
        </trans-unit>
        <trans-unit id="6d7e0b67347ba1e8b9a711859117ac575684e8e1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stebz!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stebz!()</target>
        </trans-unit>
        <trans-unit id="e4c4102de134bdf1c8c27920913760be8971f8a2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stegr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stegr!()</target>
        </trans-unit>
        <trans-unit id="09e672928c1ecc7dda3783503f4b5dded92b9673" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stein!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stein!()</target>
        </trans-unit>
        <trans-unit id="eace3492602beabe1f2ab7981e7d9209cfc2204c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stev!()</target>
        </trans-unit>
        <trans-unit id="66d07521e84ded0664c8e6d24cb062cfa0abf44c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.syconv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.syconv!()</target>
        </trans-unit>
        <trans-unit id="e37c017154e2c1fa3c47a038f981c9a2f9b128ad" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.syev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.syev!()</target>
        </trans-unit>
        <trans-unit id="371acb573fdc2cfe58acc84371e930aa7f66f883" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.syevr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.syevr!()</target>
        </trans-unit>
        <trans-unit id="4489b4eba27fe6a94403f8fc257631ee4a85b0d1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sygvd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sygvd!()</target>
        </trans-unit>
        <trans-unit id="f6128668d243c8ac355a7d5c46c06adfedbfe0c0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sysv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sysv!()</target>
        </trans-unit>
        <trans-unit id="022ac6bcea134ce5fe3a89f3bf4383107b51b2a0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sytrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sytrf!()</target>
        </trans-unit>
        <trans-unit id="a8bb80be7fdb78fb2ac23b9a1ad4b26eace9add4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sytri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sytri!()</target>
        </trans-unit>
        <trans-unit id="9d2a23098c970b0a82d03a2a452ca8118a4c74c0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sytrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sytrs!()</target>
        </trans-unit>
        <trans-unit id="83c634bcfc2f6365a7a5ab5dac799d6cefa5dae1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.tgsen!()</source>
          <target state="translated">LinearAlgebra.LAPACK.tgsen!()</target>
        </trans-unit>
        <trans-unit id="b190b8b87f953db3f01614e0cef9f46ab8ddef6c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trcon!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trcon!()</target>
        </trans-unit>
        <trans-unit id="81c93a5fe65faa5e18e25557226f1e29499c9834" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trevc!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trevc!()</target>
        </trans-unit>
        <trans-unit id="0fde83f3dc9a18889586b82aefe631e75f1ca0a5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trexc!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trexc!()</target>
        </trans-unit>
        <trans-unit id="e0a6fb5f31ac808c6c4c2d58c9bd3c8bf4547c3c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trrfs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trrfs!()</target>
        </trans-unit>
        <trans-unit id="b4a63b08edea3206f96883f52f887e335290d30c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trsen!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trsen!()</target>
        </trans-unit>
        <trans-unit id="0981f544b1017b88401f0c0d727a8512e3a16911" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trsyl!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trsyl!()</target>
        </trans-unit>
        <trans-unit id="0dd13d83537af1986304c93341975314e0a3cb92" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trtri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trtri!()</target>
        </trans-unit>
        <trans-unit id="6ace8e21c229caf81f057c6691dc06ea1d7feacb" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trtrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trtrs!()</target>
        </trans-unit>
        <trans-unit id="9f4a95aa5cd6a48d65dcce0dfbc0c2104db08ddb" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.tzrzf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.tzrzf!()</target>
        </trans-unit>
        <trans-unit id="8dc3928b7aacf4bc69fb8fb480397c2bd0754291" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LowerTriangular</source>
          <target state="translated">LinearAlgebra.LowerTriangular</target>
        </trans-unit>
        <trans-unit id="d296a34551600570579f05eb52f68d858500b6d0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.PosDefException</source>
          <target state="translated">LinearAlgebra.PosDefException</target>
        </trans-unit>
        <trans-unit id="1a5ee969e2fda57a234091ffc7169bb0717b4b55" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.QR</source>
          <target state="translated">LinearAlgebra.QR</target>
        </trans-unit>
        <trans-unit id="f252432902b3e7d2b6f5a1f541fab2b2b837e497" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.QRCompactWY</source>
          <target state="translated">LinearAlgebra.QRCompactWY</target>
        </trans-unit>
        <trans-unit id="f69a9de928f655bcff2c3bb620374afc9c7adc36" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.QRPivoted</source>
          <target state="translated">LinearAlgebra.QRPivoted</target>
        </trans-unit>
        <trans-unit id="91c43501578d11cc7b806496b694bc7fb0798c40" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.SingularException</source>
          <target state="translated">LinearAlgebra.SingularException</target>
        </trans-unit>
        <trans-unit id="21fa708b4606d3744276dbdb6504d1d33fb0880d" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.SymTridiagonal</source>
          <target state="translated">LinearAlgebra.SymTridiagonal</target>
        </trans-unit>
        <trans-unit id="c49662dfefa654d140f37c4f501e68d902dc9896" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Symmetric</source>
          <target state="translated">LinearAlgebra.Symmetric</target>
        </trans-unit>
        <trans-unit id="0b7bcff88afd509726e928a1da4371d5aad48e96" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Transpose</source>
          <target state="translated">LinearAlgebra.Transpose</target>
        </trans-unit>
        <trans-unit id="2f6e7904ca2d80d08fecb44ff694e5529ca8a0d2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Tridiagonal</source>
          <target state="translated">LinearAlgebra.Tridiagonal</target>
        </trans-unit>
        <trans-unit id="bcd3cd958cfc2292b170f7eb25170c03f9af2ed5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UniformScaling</source>
          <target state="translated">LinearAlgebra.UniformScaling</target>
        </trans-unit>
        <trans-unit id="5441959246e16a93a832c57343376624fe880467" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UnitLowerTriangular</source>
          <target state="translated">LinearAlgebra.UnitLowerTriangular</target>
        </trans-unit>
        <trans-unit id="828cc10c694c730e1acddbbb4fe2c09ed2dca433" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UnitUpperTriangular</source>
          <target state="translated">LinearAlgebra.UnitUpperTriangular</target>
        </trans-unit>
        <trans-unit id="fa757c0838038ffc2a6e801a13ed5a7b6a193380" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UpperTriangular</source>
          <target state="translated">LinearAlgebra.UpperTriangular</target>
        </trans-unit>
        <trans-unit id="738beaba8ed2df6f31a673ee2db8f7e43295d515" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.adjoint!()</source>
          <target state="translated">LinearAlgebra.adjoint!()</target>
        </trans-unit>
        <trans-unit id="9920d50dc92a459847aa3353d4531d0f64c48729" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.axpy!()</source>
          <target state="translated">LinearAlgebra.axpy!()</target>
        </trans-unit>
        <trans-unit id="8382532f0eba26f9bafb22dc5faa9989630741b4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.bunchkaufman!()</source>
          <target state="translated">LinearAlgebra.bunchkaufman!()</target>
        </trans-unit>
        <trans-unit id="f1ff255591a788d659f39c668b504aff71f28694" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.bunchkaufman()</source>
          <target state="translated">LinearAlgebra.bunchkaufman()</target>
        </trans-unit>
        <trans-unit id="49b3835122bf27c1a5c23bc1f6af4df7016dfd20" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.checksquare()</source>
          <target state="translated">LinearAlgebra.checksquare()</target>
        </trans-unit>
        <trans-unit id="f296f09ff80bdc588b439135e7b625bce1f0d744" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cholesky!()</source>
          <target state="translated">LinearAlgebra.cholesky!()</target>
        </trans-unit>
        <trans-unit id="2614d615a16d87a3a50db7af9f3788e4b71855b0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cholesky()</source>
          <target state="translated">LinearAlgebra.cholesky()</target>
        </trans-unit>
        <trans-unit id="848b264dd28237efb792aa43901c5f8f5aab83f0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cond()</source>
          <target state="translated">LinearAlgebra.cond()</target>
        </trans-unit>
        <trans-unit id="763a7ceb07efeb8156da716b3ef8c72573b2e7a4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.condskeel()</source>
          <target state="translated">LinearAlgebra.condskeel()</target>
        </trans-unit>
        <trans-unit id="639f206bebf5466d93a4ba2c03f4c4a29b6d5ea5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cross()</source>
          <target state="translated">LinearAlgebra.cross()</target>
        </trans-unit>
        <trans-unit id="d362f85f49e425d14c9978220ba2468f026a4067" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.det()</source>
          <target state="translated">LinearAlgebra.det()</target>
        </trans-unit>
        <trans-unit id="9abda27c81a472d3c63a1a657c4bee31686d49bc" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.diag()</source>
          <target state="translated">LinearAlgebra.diag()</target>
        </trans-unit>
        <trans-unit id="a7c7cacbbacea0c74222541b31910df567bdb6fb" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.diagind()</source>
          <target state="translated">LinearAlgebra.diagind()</target>
        </trans-unit>
        <trans-unit id="1aef8c46a780d7765016e06dcf0a60d28ea11f98" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.diagm()</source>
          <target state="translated">LinearAlgebra.diagm()</target>
        </trans-unit>
        <trans-unit id="a943f01470875cdccf0a181e83dd06c730b15424" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.dot()</source>
          <target state="translated">LinearAlgebra.dot()</target>
        </trans-unit>
        <trans-unit id="03ea5670e94fee3cdb29e27ac132cc775f5e56ba" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigen!()</source>
          <target state="translated">LinearAlgebra.eigen!()</target>
        </trans-unit>
        <trans-unit id="cc8ed4ca720004997b29c2c20ec5efc0988c78b6" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigen()</source>
          <target state="translated">LinearAlgebra.eigen()</target>
        </trans-unit>
        <trans-unit id="2006a7e56e96f08e8b101a5a98e0ce5438f051fd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigmax()</source>
          <target state="translated">LinearAlgebra.eigmax()</target>
        </trans-unit>
        <trans-unit id="495e81e9aba12ed4873afb4fbfc9910161c06935" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigmin()</source>
          <target state="translated">LinearAlgebra.eigmin()</target>
        </trans-unit>
        <trans-unit id="26373fb486681d828210b9eb0ada3db569ae5c9f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigvals!()</source>
          <target state="translated">LinearAlgebra.eigvals!()</target>
        </trans-unit>
        <trans-unit id="0ea943b4827b5ab3ec563686a13cb3fa1fff55de" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigvals()</source>
          <target state="translated">LinearAlgebra.eigvals()</target>
        </trans-unit>
        <trans-unit id="28aa4c8f8bdda4caedf38b6c3a8bdcbdcb929bd5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigvecs()</source>
          <target state="translated">LinearAlgebra.eigvecs()</target>
        </trans-unit>
        <trans-unit id="c1f95e8750fd563a65769748339ff1021d07a664" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.factorize()</source>
          <target state="translated">LinearAlgebra.factorize()</target>
        </trans-unit>
        <trans-unit id="245f91f9f7fc9cc2df2bdf9c6e80f2d0014ba521" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.givens()</source>
          <target state="translated">LinearAlgebra.givens()</target>
        </trans-unit>
        <trans-unit id="42383aca01a3095d7de60dfdd23a34e7aff90f64" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.hessenberg!()</source>
          <target state="translated">LinearAlgebra.hessenberg!()</target>
        </trans-unit>
        <trans-unit id="4470ba44b04e09b558f06c669c830f27803c6604" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.hessenberg()</source>
          <target state="translated">LinearAlgebra.hessenberg()</target>
        </trans-unit>
        <trans-unit id="6c9988c8648ff7a78199a102f477a45b0d53eb2c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.isdiag()</source>
          <target state="translated">LinearAlgebra.isdiag()</target>
        </trans-unit>
        <trans-unit id="86f33205a580fff63ee19ac4843205922d3b8fbe" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ishermitian()</source>
          <target state="translated">LinearAlgebra.ishermitian()</target>
        </trans-unit>
        <trans-unit id="bad9e76616b147a9a6b22ef39daed46e374592df" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.isposdef!()</source>
          <target state="translated">LinearAlgebra.isposdef!()</target>
        </trans-unit>
        <trans-unit id="a3eff21980aaad7c0e8ab2571fde20cb7f9a4ac3" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.isposdef()</source>
          <target state="translated">LinearAlgebra.isposdef()</target>
        </trans-unit>
        <trans-unit id="f184fbce8f26db2479a19308ee554a971eb91845" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.issuccess()</source>
          <target state="translated">LinearAlgebra.issuccess()</target>
        </trans-unit>
        <trans-unit id="3b45090c87a6e9b6490c1b86caef6bc289e9811b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.issymmetric()</source>
          <target state="translated">LinearAlgebra.issymmetric()</target>
        </trans-unit>
        <trans-unit id="27361a0db065863449e5514f392695a8843c50d2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.istril()</source>
          <target state="translated">LinearAlgebra.istril()</target>
        </trans-unit>
        <trans-unit id="154536c971d912aac5c55987e04b500058382262" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.istriu()</source>
          <target state="translated">LinearAlgebra.istriu()</target>
        </trans-unit>
        <trans-unit id="8702b95d8a1b1c5f29f2af932f7b339f131fc979" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ldiv!()</source>
          <target state="translated">LinearAlgebra.ldiv!()</target>
        </trans-unit>
        <trans-unit id="f628486016bf8bb2592d19dea3a4ef558655d6d8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ldlt!()</source>
          <target state="translated">LinearAlgebra.ldlt!()</target>
        </trans-unit>
        <trans-unit id="c666984e1b5f4107efe1cc308dd23df3742d794b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ldlt()</source>
          <target state="translated">LinearAlgebra.ldlt()</target>
        </trans-unit>
        <trans-unit id="87445caeed19ddaad799f1582737a52e40bde9e9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lmul!()</source>
          <target state="translated">LinearAlgebra.lmul!()</target>
        </trans-unit>
        <trans-unit id="f5e67426386e0244313c54bbe9e11137664a7611" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.logabsdet()</source>
          <target state="translated">LinearAlgebra.logabsdet()</target>
        </trans-unit>
        <trans-unit id="a6c4efc9dcb4f29a594919d0a4a0c4ecc1b0eb49" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.logdet()</source>
          <target state="translated">LinearAlgebra.logdet()</target>
        </trans-unit>
        <trans-unit id="aed69ea345782519298a7b83289a6fd2a0d20a22" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lowrankdowndate!()</source>
          <target state="translated">LinearAlgebra.lowrankdowndate!()</target>
        </trans-unit>
        <trans-unit id="065afe0c96edc42ef451662159895201fbe9f74e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lowrankdowndate()</source>
          <target state="translated">LinearAlgebra.lowrankdowndate()</target>
        </trans-unit>
        <trans-unit id="10584a564acc8cafcbd880790d5a3223c614e997" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lowrankupdate!()</source>
          <target state="translated">LinearAlgebra.lowrankupdate!()</target>
        </trans-unit>
        <trans-unit id="952be3b610fe2e74216ee89053ff75f7419d4b28" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lowrankupdate()</source>
          <target state="translated">LinearAlgebra.lowrankupdate()</target>
        </trans-unit>
        <trans-unit id="47c1af320726090525f6d61978444c2ea6c9d0ab" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lq!()</source>
          <target state="translated">LinearAlgebra.lq!()</target>
        </trans-unit>
        <trans-unit id="5375dc727ff35daa144ad173772170766a77fc84" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lq()</source>
          <target state="translated">LinearAlgebra.lq()</target>
        </trans-unit>
        <trans-unit id="19c721bb8412a08453cd493f076ec151ec21919f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lu!()</source>
          <target state="translated">LinearAlgebra.lu!()</target>
        </trans-unit>
        <trans-unit id="416610984f232609e5a5300d47b309939683e378" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lu()</source>
          <target state="translated">LinearAlgebra.lu()</target>
        </trans-unit>
        <trans-unit id="e5fa084cafc39d82b66f8c8dc2e12353e03f3704" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lyap()</source>
          <target state="translated">LinearAlgebra.lyap()</target>
        </trans-unit>
        <trans-unit id="7c99824c12d49750627f623ddd871e015e24c8c8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.mul!()</source>
          <target state="translated">LinearAlgebra.mul!()</target>
        </trans-unit>
        <trans-unit id="24933f7d1d932d73149fe8820b01ff0b8033488b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.norm()</source>
          <target state="translated">LinearAlgebra.norm()</target>
        </trans-unit>
        <trans-unit id="1639614f72f390991f3c415b26fb661709818686" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.normalize!()</source>
          <target state="translated">LinearAlgebra.normalize!()</target>
        </trans-unit>
        <trans-unit id="bfa13b34d43df925bb276eb2b2712a5d9852eb7e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.normalize()</source>
          <target state="translated">LinearAlgebra.normalize()</target>
        </trans-unit>
        <trans-unit id="123d380f57ea839fe9386bdced9ecbd4bfa56d19" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.nullspace()</source>
          <target state="translated">LinearAlgebra.nullspace()</target>
        </trans-unit>
        <trans-unit id="c473c4d32b408a10287aa2043ce1410d94d0f8ba" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.opnorm()</source>
          <target state="translated">LinearAlgebra.opnorm()</target>
        </trans-unit>
        <trans-unit id="27873174504747d088813d705a5c2057e78a6fa4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ordschur!()</source>
          <target state="translated">LinearAlgebra.ordschur!()</target>
        </trans-unit>
        <trans-unit id="a0cf19c8a32916092aead5343f54d5c29799bf44" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ordschur()</source>
          <target state="translated">LinearAlgebra.ordschur()</target>
        </trans-unit>
        <trans-unit id="f7c256ca3b590fa1c68a6c5c968889de72035a1c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.peakflops()</source>
          <target state="translated">LinearAlgebra.peakflops()</target>
        </trans-unit>
        <trans-unit id="3b416155a9648251a3dab2c1f86f654cbc45f766" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.pinv()</source>
          <target state="translated">LinearAlgebra.pinv()</target>
        </trans-unit>
        <trans-unit id="24a51a0a6b9a091503d04d18751653ab70e63907" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.qr!()</source>
          <target state="translated">LinearAlgebra.qr!()</target>
        </trans-unit>
        <trans-unit id="32cd922076c561139a5133388ff3de86aee2f838" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.qr()</source>
          <target state="translated">LinearAlgebra.qr()</target>
        </trans-unit>
        <trans-unit id="25c16b6062a5721edfc89f6f1b58866c9999fd30" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.rank()</source>
          <target state="translated">LinearAlgebra.rank()</target>
        </trans-unit>
        <trans-unit id="292d72424657c4aa082122899b52a2ca37500f51" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.rdiv!()</source>
          <target state="translated">LinearAlgebra.rdiv!()</target>
        </trans-unit>
        <trans-unit id="12f33b8246f53c039178bae0493a696a7aff5605" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.rmul!()</source>
          <target state="translated">LinearAlgebra.rmul!()</target>
        </trans-unit>
        <trans-unit id="3ce18ca8ac025f0f6376582ad516bf09b60beb97" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.schur!()</source>
          <target state="translated">LinearAlgebra.schur!()</target>
        </trans-unit>
        <trans-unit id="d1c7d7a7be766a0227fceaaeba6b125494ecacc5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.schur()</source>
          <target state="translated">LinearAlgebra.schur()</target>
        </trans-unit>
        <trans-unit id="875a6969d0c4c9e685666728e0a075eb8c05fd34" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.stride1()</source>
          <target state="translated">LinearAlgebra.stride1()</target>
        </trans-unit>
        <trans-unit id="e830629f4eb2b2f684c386f2e83c4cd8d40d08c7" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.svd!()</source>
          <target state="translated">LinearAlgebra.svd!()</target>
        </trans-unit>
        <trans-unit id="9ac0ee09de07e5d20a225d6487f69df6607076ac" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.svd()</source>
          <target state="translated">LinearAlgebra.svd()</target>
        </trans-unit>
        <trans-unit id="988da18329a53e16de1bd6da5c1f8e417469db10" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.svdvals!()</source>
          <target state="translated">LinearAlgebra.svdvals!()</target>
        </trans-unit>
        <trans-unit id="5f88c1d8eeb98c086bcbe1a4efbb1ecfea5359dd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.svdvals()</source>
          <target state="translated">LinearAlgebra.svdvals()</target>
        </trans-unit>
        <trans-unit id="08228eabf0d0dbc8efbc58ae8f1948646134de59" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.sylvester()</source>
          <target state="translated">LinearAlgebra.sylvester()</target>
        </trans-unit>
        <trans-unit id="b64e39526f66a386113f15a1ffcc6de69561a7ea" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.tr()</source>
          <target state="translated">LinearAlgebra.tr()</target>
        </trans-unit>
        <trans-unit id="421907594b9500deaf9ebf0a78b09e30e97d0969" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.transpose!()</source>
          <target state="translated">LinearAlgebra.transpose!()</target>
        </trans-unit>
        <trans-unit id="9e11fafcc7c6da90f84fe85de7b987df1ab51a50" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.tril!()</source>
          <target state="translated">LinearAlgebra.tril!()</target>
        </trans-unit>
        <trans-unit id="943eef9228abf32d3acece710a792a24018ad5d0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.tril()</source>
          <target state="translated">LinearAlgebra.tril()</target>
        </trans-unit>
        <trans-unit id="a45cd5a2a1e79b5eba2cf22f01b2ab8a64dcfeec" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.triu!()</source>
          <target state="translated">LinearAlgebra.triu!()</target>
        </trans-unit>
        <trans-unit id="6fa6a88dc15e19a67b21c0de2d88e00b6f996707" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.triu()</source>
          <target state="translated">LinearAlgebra.triu()</target>
        </trans-unit>
        <trans-unit id="3c8e04f396865f7c2a68d63b51786aa52075e28e" translate="yes" xml:space="preserve">
          <source>LinearIndices</source>
          <target state="translated">LinearIndices</target>
        </trans-unit>
        <trans-unit id="97539d497456e8ae64ab21e30e72713379418284" translate="yes" xml:space="preserve">
          <source>Link Symbol</source>
          <target state="translated">リンクシンボル</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="6b94a7684e8c9e36ac262755ad390b4f84d2ef0f" translate="yes" xml:space="preserve">
          <source>Links to each of these download types can be found on the download page at &lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https://julialang.org/downloads/&lt;/a&gt;. Note that not all versions of Julia are available for all platforms.</source>
          <target state="translated">これらの各ダウンロードタイプへのリンクは、&lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https：//julialang.org/downloads/の&lt;/a&gt;ダウンロードページにあります。Juliaのすべてのバージョンがすべてのプラットフォームで使用できるわけではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="0bd309fe8c158ca93bf01439f879abad96a2d9ae" translate="yes" xml:space="preserve">
          <source>Links to either external or internal addresses can be written using the following syntax, where the text enclosed in square brackets, &lt;code&gt;[ ]&lt;/code&gt;, is the name of the link and the text enclosed in parentheses, &lt;code&gt;( )&lt;/code&gt;, is the URL.</source>
          <target state="translated">外部または内部アドレスへのリンクは、次の構文を使用して記述できます。角括弧 &lt;code&gt;[ ]&lt;/code&gt; で囲まれたテキストはリンクの名前であり、括弧 &lt;code&gt;( )&lt;/code&gt; で囲まれたテキストはURLです。</target>
        </trans-unit>
        <trans-unit id="800618f12f938e53d9c627356df00435b9a51301" translate="yes" xml:space="preserve">
          <source>Links to either external or internal targets can be written using the following syntax, where the text enclosed in square brackets, &lt;code&gt;[ ]&lt;/code&gt;, is the name of the link and the text enclosed in parentheses, &lt;code&gt;( )&lt;/code&gt;, is the URL.</source>
          <target state="translated">外部ターゲットまたは内部ターゲットへのリンクは、次の構文を使用して記述できます。ここで、角括弧 &lt;code&gt;[ ]&lt;/code&gt; で囲まれたテキストはリンクの名前であり、括弧 &lt;code&gt;( )&lt;/code&gt; で囲まれたテキストはURLです。</target>
        </trans-unit>
        <trans-unit id="f988d8955026b4558444945785c9b5dbc82a7b4f" translate="yes" xml:space="preserve">
          <source>Lipstick</source>
          <target state="translated">Lipstick</target>
        </trans-unit>
        <trans-unit id="97c285fe5eb710455fe67ecf43ec5d1858f0c7b3" translate="yes" xml:space="preserve">
          <source>Lisp-like macros and other metaprogramming facilities</source>
          <target state="translated">Lisp ライクなマクロとその他のメタプログラミング機能</target>
        </trans-unit>
        <trans-unit id="17810a1438ef5dd3fd5dc6cdd00bf4fbecb5795c" translate="yes" xml:space="preserve">
          <source>List the number of revisions between &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt; (committish OIDs in string form). Since &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt; may be on different branches, &lt;code&gt;revcount&lt;/code&gt; performs a &quot;left-right&quot; revision list (and count), returning a tuple of &lt;code&gt;Int&lt;/code&gt;s - the number of left and right commits, respectively. A left (or right) commit refers to which side of a symmetric difference in a tree the commit is reachable from.</source>
          <target state="translated">&lt;code&gt;commit1&lt;/code&gt; と &lt;code&gt;commit2&lt;/code&gt; の間のリビジョン数をリストします（文字列形式のコミットメント OID）。 &lt;code&gt;commit1&lt;/code&gt; と &lt;code&gt;commit2&lt;/code&gt; は異なるブランチにある可能性があるため、 &lt;code&gt;revcount&lt;/code&gt; は「左右」のリビジョンリスト（およびカウント）を実行し、 &lt;code&gt;Int&lt;/code&gt; のタプル（それぞれ左と右のコミット数）を返します。左（または右）コミットとは、ツリー内の対称差分のどちら側からコミットに到達できるかを指します。</target>
        </trans-unit>
        <trans-unit id="388721610609dc9098cd8f36e62807e84d1fade7" translate="yes" xml:space="preserve">
          <source>Listen on port on the address specified by &lt;code&gt;addr&lt;/code&gt;. By default this listens on &lt;code&gt;localhost&lt;/code&gt; only. To listen on all interfaces pass &lt;code&gt;IPv4(0)&lt;/code&gt; or &lt;code&gt;IPv6(0)&lt;/code&gt; as appropriate. &lt;code&gt;backlog&lt;/code&gt; determines how many connections can be pending (not having called &lt;a href=&quot;#Sockets.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;) before the server will begin to reject them. The default value of &lt;code&gt;backlog&lt;/code&gt; is 511.</source>
          <target state="translated">&lt;code&gt;addr&lt;/code&gt; で指定されたアドレスでポートをリッスンします。デフォルトでは、これは &lt;code&gt;localhost&lt;/code&gt; のみリッスンします。すべてのインターフェースでリッスンするには、必要に応じて &lt;code&gt;IPv4(0)&lt;/code&gt; または &lt;code&gt;IPv6(0)&lt;/code&gt; を渡します。 &lt;code&gt;backlog&lt;/code&gt; は、サーバーが接続を拒否し始める前に、保留にできる（&lt;a href=&quot;#Sockets.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;を呼び出していない）接続の数を決定します。 &lt;code&gt;backlog&lt;/code&gt; のデフォルト値は511です。</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="8aa67be98327d7646247b7e62d87af940b94fc8a" translate="yes" xml:space="preserve">
          <source>Lists can contain other nested toplevel elements such as lists, code blocks, or quoteblocks. A blank line should be left between each list item when including any toplevel elements within a list.</source>
          <target state="translated">リストには、リスト、コード ブロック、またはクォートブロックなど、他の入れ子になったトップレベル要素を含めることができます。リスト内にトップレベル要素を含める場合は、各リスト項目の間に空白行を残す必要があります。</target>
        </trans-unit>
        <trans-unit id="4c9fcbea9e81be568fdc5a4af6993f666806fde2" translate="yes" xml:space="preserve">
          <source>Literal floating-point numbers are represented in the standard formats, using &lt;a href=&quot;https://en.wikipedia.org/wiki/Scientific_notation#E-notation&quot;&gt;E-notation&lt;/a&gt; when necessary:</source>
          <target state="translated">リテラル浮動小数点数は、必要に応じて&lt;a href=&quot;https://en.wikipedia.org/wiki/Scientific_notation#E-notation&quot;&gt;E表記&lt;/a&gt;を使用して、標準形式で表されます。</target>
        </trans-unit>
        <trans-unit id="3562cae13eedce4e4d416c818141141826f44ea7" translate="yes" xml:space="preserve">
          <source>Literal integers are represented in the standard manner:</source>
          <target state="translated">リテラル整数は標準的な方法で表現されます。</target>
        </trans-unit>
        <trans-unit id="2ab27329d47948b21415226c577e214e77fab191" translate="yes" xml:space="preserve">
          <source>Literal one of type &lt;code&gt;x&lt;/code&gt; or type of variable &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">タイプ &lt;code&gt;x&lt;/code&gt; または変数 &lt;code&gt;x&lt;/code&gt; のタイプのリテラル1</target>
        </trans-unit>
        <trans-unit id="a585d71445ba7f9e68c5da186d786f4437873367" translate="yes" xml:space="preserve">
          <source>Literal zero and one</source>
          <target state="translated">文字通りのゼロと1</target>
        </trans-unit>
        <trans-unit id="24e8678ee4be704fc611c4a474de77fa54f1d95f" translate="yes" xml:space="preserve">
          <source>Literal zero of type &lt;code&gt;x&lt;/code&gt; or type of variable &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">タイプ &lt;code&gt;x&lt;/code&gt; のリテラルゼロまたは変数 &lt;code&gt;x&lt;/code&gt; のタイプ</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="c6a4e1f3b4978cbaedfb2e99a34a61a5e64f4b8d" translate="yes" xml:space="preserve">
          <source>Literals should be used when writing text that refers to names of variables, functions, or other parts of a Julia program.</source>
          <target state="translated">変数名や関数名など、Juliaプログラムの他の部分を参照する文章を書くときには、リテラルを使用してください。</target>
        </trans-unit>
        <trans-unit id="cccfebf2b6bb84af7b7416c30102f0fb5345d20a" translate="yes" xml:space="preserve">
          <source>Load &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; immediately on all processors</source>
          <target state="translated">すべてのプロセッサに &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; をすぐにロードします</target>
        </trans-unit>
        <trans-unit id="221a8e52842df5b19245cbcdd992a3dedaa109d5" translate="yes" xml:space="preserve">
          <source>Load &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; ロードします</target>
        </trans-unit>
        <trans-unit id="ea8d49a8f75a3b101a94caadd4a63e8ab235d750" translate="yes" xml:space="preserve">
          <source>Load a shared library, returning an opaque handle.</source>
          <target state="translated">共有ライブラリをロードし、不透明なハンドルを返します。</target>
        </trans-unit>
        <trans-unit id="c25f7156c983ea8a18f757a2b60fb37dd817a64d" translate="yes" xml:space="preserve">
          <source>Load a value of type &lt;code&gt;T&lt;/code&gt; from the address of the &lt;code&gt;i&lt;/code&gt;th element (1-indexed) starting at &lt;code&gt;p&lt;/code&gt;. This is equivalent to the C expression &lt;code&gt;p[i-1]&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;T&lt;/code&gt; の値を、 &lt;code&gt;p&lt;/code&gt; から始まる &lt;code&gt;i&lt;/code&gt; 番目の要素（1から始まる）のアドレスからロードします。これは、Cの式 &lt;code&gt;p[i-1]&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="37f3c2f4c2bbe8c48d77f7372d4681f5071a6c1b" translate="yes" xml:space="preserve">
          <source>Load or save history</source>
          <target state="translated">履歴の読み込みまたは保存</target>
        </trans-unit>
        <trans-unit id="2a3d64c128591f94e5fcdc12bbe22bc691844af1" translate="yes" xml:space="preserve">
          <source>Load the file using &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;, evaluate all expressions, and return the value of the last one.</source>
          <target state="translated">&lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt;を使用してファイルをロードし、すべての式を評価して、最後の式の値を返します。</target>
        </trans-unit>
        <trans-unit id="1c25d02a3443b64be0a5e8874e859825f3a072cf" translate="yes" xml:space="preserve">
          <source>Loads a source file, in the context of the &lt;code&gt;Main&lt;/code&gt; module, on every active node, searching standard locations for files. &lt;code&gt;require&lt;/code&gt; is considered a top-level operation, so it sets the current &lt;code&gt;include&lt;/code&gt; path but does not use it to search for files (see help for &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;). This function is typically used to load library code, and is implicitly called by &lt;code&gt;using&lt;/code&gt; to load packages.</source>
          <target state="translated">&lt;code&gt;Main&lt;/code&gt; モジュールのコンテキストで、アクティブなすべてのノードにソースファイルを読み込み、ファイルの標準の場所を検索します。 &lt;code&gt;require&lt;/code&gt; はトップレベルの操作と見なされるため、現在の &lt;code&gt;include&lt;/code&gt; パスを設定しますが、ファイルの検索には使用しません（&lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; の&lt;/a&gt;ヘルプを参照）。この関数は通常、ライブラリコードをロードするために使用され、パッケージをロード &lt;code&gt;using&lt;/code&gt; ためにを使用して暗黙的に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="2aaca902d4d3758e11a3b458199407392409931c" translate="yes" xml:space="preserve">
          <source>Local Scope</source>
          <target state="translated">ローカルスコープ</target>
        </trans-unit>
        <trans-unit id="53e6be3ba94721357dc8f1cd8a4a35bc46260d53" translate="yes" xml:space="preserve">
          <source>Local constants are quite different. The compiler is able to determine automatically when a local variable is constant, so local constant declarations are not necessary, and in fact are currently not supported.</source>
          <target state="translated">ローカル定数は全く異なります。コンパイラはローカル変数が定数であるかどうかを自動的に判断することができるので、ローカル定数の宣言は必要ありませんし、実際には現在サポートされていません。</target>
        </trans-unit>
        <trans-unit id="7bc74c802188a5ae5dd86ce1121ca4599d93af45" translate="yes" xml:space="preserve">
          <source>Local invocations</source>
          <target state="translated">ローカル呼び出し</target>
        </trans-unit>
        <trans-unit id="aea223f531a712477fac84f8fcf490b4f65ae3a6" translate="yes" xml:space="preserve">
          <source>Local invocations(@id man-distributed-local-invocations)</source>
          <target state="translated">ローカル呼び出し(@id man-distributed-local-invocations)</target>
        </trans-unit>
        <trans-unit id="40051a807238da75ab231f8a8a71c830f614ed27" translate="yes" xml:space="preserve">
          <source>Local variable &lt;code&gt;x&lt;/code&gt; starts as an integer, and after one loop iteration becomes a floating-point number (the result of &lt;a href=&quot;../../base/math/index#Base.:/&quot;&gt;&lt;code&gt;/&lt;/code&gt;&lt;/a&gt; operator). This makes it more difficult for the compiler to optimize the body of the loop. There are several possible fixes:</source>
          <target state="translated">ローカル変数 &lt;code&gt;x&lt;/code&gt; は整数で始まり、1回のループ反復の後に浮動小数点数（&lt;a href=&quot;../../base/math/index#Base.:/&quot;&gt; &lt;code&gt;/&lt;/code&gt; &lt;/a&gt;演算子の結果）になります。これにより、コンパイラーがループの本体を最適化することがより困難になります。考えられる修正がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="891ebccd5baa32daed16fb5a0825ca7a4464931f" translate="yes" xml:space="preserve">
          <source>Lock</source>
          <target state="translated">Lock</target>
        </trans-unit>
        <trans-unit id="7e9d4e021d5117e7b0d661a7918f799df5c20541" translate="yes" xml:space="preserve">
          <source>Lock With Ink Pen</source>
          <target state="translated">インクペンでロック</target>
        </trans-unit>
        <trans-unit id="2d7a18ee66cedde04088fccb894adfaa5d0be6f1" translate="yes" xml:space="preserve">
          <source>Log a message to &lt;code&gt;logger&lt;/code&gt; at &lt;code&gt;level&lt;/code&gt;. The logical location at which the message was generated is given by module &lt;code&gt;_module&lt;/code&gt; and &lt;code&gt;group&lt;/code&gt;; the source location by &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt;. &lt;code&gt;id&lt;/code&gt; is an arbitrary unique &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; to be used as a key to identify the log statement when filtering.</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; &lt;code&gt;logger&lt;/code&gt; にメッセージを記録します。メッセージが生成された論理的な場所は、module &lt;code&gt;_module&lt;/code&gt; および &lt;code&gt;group&lt;/code&gt; によって指定されます。 &lt;code&gt;file&lt;/code&gt; と &lt;code&gt;line&lt;/code&gt; によるソースの場所。 &lt;code&gt;id&lt;/code&gt; は、フィルタリング時にログステートメントを識別するためのキーとして使用される任意の一意の&lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="2db3a05837e9b250facfd93e1fe4f8c7f938c9cc" translate="yes" xml:space="preserve">
          <source>Log a message to &lt;code&gt;logger&lt;/code&gt; at &lt;code&gt;level&lt;/code&gt;. The logical location at which the message was generated is given by module &lt;code&gt;_module&lt;/code&gt; and &lt;code&gt;group&lt;/code&gt;; the source location by &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt;. &lt;code&gt;id&lt;/code&gt; is an arbitrary unique value (typically a &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;) to be used as a key to identify the log statement when filtering.</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; &lt;code&gt;logger&lt;/code&gt; にメッセージを記録します。メッセージが生成された論理的な場所は、 &lt;code&gt;_module&lt;/code&gt; および &lt;code&gt;group&lt;/code&gt; ;によって指定されます。 &lt;code&gt;file&lt;/code&gt; と &lt;code&gt;line&lt;/code&gt; によるソースの場所。 &lt;code&gt;id&lt;/code&gt; は、フィルタリング時にログステートメントを識別するためのキーとして使用される任意の一意の値（通常は&lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt;）です。</target>
        </trans-unit>
        <trans-unit id="d4ccff841d7f5fb35e7f3223eae831d879121ed8" translate="yes" xml:space="preserve">
          <source>Log event structure</source>
          <target state="translated">ログイベント構造</target>
        </trans-unit>
        <trans-unit id="5de4f5e761f85511e1c9dded76464677e6b5b91b" translate="yes" xml:space="preserve">
          <source>Log events are a side effect of running normal code, but you might find yourself wanting to test particular informational messages and warnings. The &lt;code&gt;Test&lt;/code&gt; module provides a &lt;a href=&quot;../test/index#Test.@test_logs&quot;&gt;&lt;code&gt;@test_logs&lt;/code&gt;&lt;/a&gt; macro that can be used to pattern match against the log event stream.</source>
          <target state="translated">ログイベントは、通常のコードの実行による副作用ですが、特定の情報メッセージと警告をテストしたい場合があります。 &lt;code&gt;Test&lt;/code&gt; モジュールが提供&lt;a href=&quot;../test/index#Test.@test_logs&quot;&gt; &lt;code&gt;@test_logs&lt;/code&gt; の&lt;/a&gt;ログ・イベント・ストリームに対してパターン一致させるために使用することができるマクロ。</target>
        </trans-unit>
        <trans-unit id="39e0c0b6171a5e937cc4b913037f6617883ef778" translate="yes" xml:space="preserve">
          <source>Log levels less than &lt;code&gt;min_level&lt;/code&gt; are filtered out.</source>
          <target state="translated">&lt;code&gt;min_level&lt;/code&gt; 未満のログレベルは除外されます。</target>
        </trans-unit>
        <trans-unit id="b95a88cbf9b7104d12a1c6e6be0a2df585c9c414" translate="yes" xml:space="preserve">
          <source>Log of absolute value of matrix determinant. Equivalent to &lt;code&gt;(log(abs(det(M))), sign(det(M)))&lt;/code&gt;, but may provide increased accuracy and/or speed.</source>
          <target state="translated">行列式の絶対値の対数。 &lt;code&gt;(log(abs(det(M))), sign(det(M)))&lt;/code&gt; と同等ですが、精度や速度が向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="25e0bc59a9512a0f503efed371b6e58c737cb2b5" translate="yes" xml:space="preserve">
          <source>Log of matrix determinant. Equivalent to &lt;code&gt;log(det(M))&lt;/code&gt;, but may provide increased accuracy and/or speed.</source>
          <target state="translated">行列式の対数。 &lt;code&gt;log(det(M))&lt;/code&gt; と同等ですが、精度や速度が向上する場合があります。</target>
        </trans-unit>
        <trans-unit id="09b41ebbca90f28e72616fb548aed5c2cdb190af" translate="yes" xml:space="preserve">
          <source>Logger installation and inspection:</source>
          <target state="translated">ロガーの設置・点検。</target>
        </trans-unit>
        <trans-unit id="3e0a58fce8ac790c3d3776b2f9cb69da4b8e968b" translate="yes" xml:space="preserve">
          <source>Logger which disables all messages and produces no output - the logger equivalent of /dev/null.</source>
          <target state="translated">すべてのメッセージを無効にして出力を生成しないロガー-/dev/null と同等のロガー。</target>
        </trans-unit>
        <trans-unit id="c489f7460af4426236655b519a2e843c0796afcf" translate="yes" xml:space="preserve">
          <source>Logger with formatting optimized for readability in a text console, for example interactive work with the Julia REPL.</source>
          <target state="translated">テキスト・コンソールでの読みやすさのために最適化されたフォーマットを持つロガー、例えばJulia REPLを使った対話的な作業など。</target>
        </trans-unit>
        <trans-unit id="012294fbc07fc652fdbbd3b8b48183b6e7925dda" translate="yes" xml:space="preserve">
          <source>Loggers</source>
          <target state="translated">Loggers</target>
        </trans-unit>
        <trans-unit id="ab6dfdab464b019150c40525f7d8fef7f42317d8" translate="yes" xml:space="preserve">
          <source>Loggers that are supplied with the system:</source>
          <target state="translated">システムに付属しているロガー。</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="84dd6708d003df0c49c9ba90e02bb2e238e90fae" translate="yes" xml:space="preserve">
          <source>Logging module</source>
          <target state="translated">ロギングモジュール</target>
        </trans-unit>
        <trans-unit id="89da04acc02b6d97d3dda5b51691b7f2df8ab3f2" translate="yes" xml:space="preserve">
          <source>Logical (or boolean) operators &lt;code&gt;|&lt;/code&gt;, &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt; are another special case, as they only propagate &lt;code&gt;missing&lt;/code&gt; values when it is logically required. For these operators, whether or not the result is uncertain depends on the particular operation, following the well-established rules of &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;&lt;em&gt;three-valued logic&lt;/em&gt;&lt;/a&gt; which are also implemented by &lt;code&gt;NULL&lt;/code&gt; in SQL and &lt;code&gt;NA&lt;/code&gt; in R. This abstract definition actually corresponds to a relatively natural behavior which is best explained via concrete examples.</source>
          <target state="translated">論理（またはブール）演算子 &lt;code&gt;|&lt;/code&gt; 、&lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt;は、論理的に必要な場合にのみ &lt;code&gt;missing&lt;/code&gt; 値を伝播するため、もう1つの特殊なケースです。これらの演算子の場合、結果が不確かであるかどうかは、SQLの &lt;code&gt;NULL&lt;/code&gt; およびRの &lt;code&gt;NA&lt;/code&gt; でも実装される&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;&lt;em&gt;3値論理の&lt;/em&gt;&lt;/a&gt;確立された規則に従って、特定の操作に依存します。この抽象的な定義は実際には比較的自然な具体的な例で最もよく説明される動作。</target>
        </trans-unit>
        <trans-unit id="786908e4097f50192db248aa36b5528e31277867" translate="yes" xml:space="preserve">
          <source>Logical And</source>
          <target state="translated">論理的および</target>
        </trans-unit>
        <trans-unit id="67c3357e4a7007cce9dad8abe1e464a6faaed6cf" translate="yes" xml:space="preserve">
          <source>Logical And With Dot Above</source>
          <target state="translated">論理的で、上のドットと</target>
        </trans-unit>
        <trans-unit id="ad73258bccc391936166d8f628d173e6ce3c7d3d" translate="yes" xml:space="preserve">
          <source>Logical And With Double Overbar</source>
          <target state="translated">論理的でダブルオーバーバー付き</target>
        </trans-unit>
        <trans-unit id="3a27d20134d696f264e94d803f411cd413383e05" translate="yes" xml:space="preserve">
          <source>Logical And With Double Underbar</source>
          <target state="translated">論理的で、ダブルアンダーバー付き</target>
        </trans-unit>
        <trans-unit id="cb54d54f9d2ab29ccd05e2998f6679b7b0a51e55" translate="yes" xml:space="preserve">
          <source>Logical And With Horizontal Dash</source>
          <target state="translated">論理的で水平方向のダッシュと</target>
        </trans-unit>
        <trans-unit id="f6e1b3f2c2e3537f4121f6786ee7d2f1fdcc7214" translate="yes" xml:space="preserve">
          <source>Logical And With Middle Stem</source>
          <target state="translated">論理的で、中間の茎を持つ</target>
        </trans-unit>
        <trans-unit id="cee1bd132c4db9d40b5015470294a3309557d652" translate="yes" xml:space="preserve">
          <source>Logical And With Underbar</source>
          <target state="translated">論理的でアンダーバー付き</target>
        </trans-unit>
        <trans-unit id="fed4dc8cd8f466453469c24bdf945b136419ffef" translate="yes" xml:space="preserve">
          <source>Logical Operations on Arrays</source>
          <target state="translated">配列の論理演算</target>
        </trans-unit>
        <trans-unit id="6b4765205b7632c3acd6f4b0016fe8b785f2d3e7" translate="yes" xml:space="preserve">
          <source>Logical Or</source>
          <target state="translated">論理的または</target>
        </trans-unit>
        <trans-unit id="090611a42c7037c3c2bfae57153874d16efc59fb" translate="yes" xml:space="preserve">
          <source>Logical Or With Dot Above</source>
          <target state="translated">論理的なまたは上のドットと</target>
        </trans-unit>
        <trans-unit id="563b798880b958c47070de3da511383e45a77828" translate="yes" xml:space="preserve">
          <source>Logical Or With Double Overbar</source>
          <target state="translated">論理的またはダブルオーバーバー付き</target>
        </trans-unit>
        <trans-unit id="7d683350404e6e9be8c9e2e65c1b673dedd263fb" translate="yes" xml:space="preserve">
          <source>Logical Or With Double Underbar</source>
          <target state="translated">論理的またはダブルアンダーバー付き</target>
        </trans-unit>
        <trans-unit id="66977fa56bf367cf9edb7c775c7703db1cb43216" translate="yes" xml:space="preserve">
          <source>Logical Or With Horizontal Dash</source>
          <target state="translated">論理的または水平ダッシュ付き</target>
        </trans-unit>
        <trans-unit id="04ee9b0a538e88f1af58f8f182ea27dfc50a851f" translate="yes" xml:space="preserve">
          <source>Logical Or With Middle Stem</source>
          <target state="translated">論理的または中間ステム付き</target>
        </trans-unit>
        <trans-unit id="daaabe581776a9024a83133896be28214c21d330" translate="yes" xml:space="preserve">
          <source>Logical indexing</source>
          <target state="translated">論理的なインデキシング</target>
        </trans-unit>
        <trans-unit id="a5da835bb3de6e8855950138a28dea23921e5aaa" translate="yes" xml:space="preserve">
          <source>Logical operators</source>
          <target state="translated">論理演算子</target>
        </trans-unit>
        <trans-unit id="621d5dc0716b80a4b24a2ab36703beb47f8e9970" translate="yes" xml:space="preserve">
          <source>Lollipop</source>
          <target state="translated">Lollipop</target>
        </trans-unit>
        <trans-unit id="3dd8963fe38f95d47b45ad8afdc61266eb3c705b" translate="yes" xml:space="preserve">
          <source>Long Left Right Arrow</source>
          <target state="translated">左長い右矢印</target>
        </trans-unit>
        <trans-unit id="c35393bc1526e081d6c45ef1fbb48cf17d0c8bf0" translate="yes" xml:space="preserve">
          <source>Long Left Right Double Arrow</source>
          <target state="translated">左長右二重矢印</target>
        </trans-unit>
        <trans-unit id="e284c1dcf57b9e16654ce906eebd4ade05f805b3" translate="yes" xml:space="preserve">
          <source>Long Leftwards Arrow</source>
          <target state="translated">左に長い矢印</target>
        </trans-unit>
        <trans-unit id="0b53faa1153d8df2a62532b492821e710a37aaad" translate="yes" xml:space="preserve">
          <source>Long Leftwards Arrow From Bar</source>
          <target state="translated">バーから左方向に長い矢印</target>
        </trans-unit>
        <trans-unit id="88125db03adc91c18e4b911d1e8543cb06fb2b1b" translate="yes" xml:space="preserve">
          <source>Long Leftwards Double Arrow</source>
          <target state="translated">左方向に長い二重矢印</target>
        </trans-unit>
        <trans-unit id="f84697639bf777eba1549b50e7d78fe9fc6c3b1a" translate="yes" xml:space="preserve">
          <source>Long Leftwards Double Arrow From Bar</source>
          <target state="translated">バーから左方向に長い二重矢印</target>
        </trans-unit>
        <trans-unit id="b98fbfea9069a23125b4969bdb4539cfde1d985c" translate="yes" xml:space="preserve">
          <source>Long Leftwards Squiggle Arrow</source>
          <target state="translated">長い左向きのスクイグル矢印</target>
        </trans-unit>
        <trans-unit id="ea5233fe4b9cd95205a27a4dce0a7bbfb8aae26f" translate="yes" xml:space="preserve">
          <source>Long Rightwards Arrow</source>
          <target state="translated">右上がりの長い矢印</target>
        </trans-unit>
        <trans-unit id="529625a98773524bc52c828a69957fbaaca9fd91" translate="yes" xml:space="preserve">
          <source>Long Rightwards Arrow From Bar</source>
          <target state="translated">バーから右に長い矢印</target>
        </trans-unit>
        <trans-unit id="0e2515e3d0dae9c81aaf0c44bf451d94396badbf" translate="yes" xml:space="preserve">
          <source>Long Rightwards Double Arrow</source>
          <target state="translated">右方向に長い二重矢印</target>
        </trans-unit>
        <trans-unit id="1278f556f7a008b8d9f849c9d7f07ad7d2fda02a" translate="yes" xml:space="preserve">
          <source>Long Rightwards Double Arrow From Bar</source>
          <target state="translated">バーから右方向に長い二重矢印</target>
        </trans-unit>
        <trans-unit id="3c3264b81769074f17253d6ac449ae0214eb0511" translate="yes" xml:space="preserve">
          <source>Long Rightwards Squiggle Arrow</source>
          <target state="translated">右方向に長いスクイグル矢印</target>
        </trans-unit>
        <trans-unit id="f9731487237a7d36eb57c97e02893eb0fcbe12b9" translate="yes" xml:space="preserve">
          <source>Look up a remote git repository using its name and URL. Uses the default fetch refspec.</source>
          <target state="translated">リモートの git リポジトリを名前と URL で調べます。デフォルトの fetch refspec を使用します。</target>
        </trans-unit>
        <trans-unit id="f3e71ff4dab9481f1e14a82514827c17c83dee43" translate="yes" xml:space="preserve">
          <source>Look up a remote git repository using only its URL, not its name.</source>
          <target state="translated">リモートの git リポジトリを検索するには、名前ではなく URL のみを使用します。</target>
        </trans-unit>
        <trans-unit id="6d614bcd7bb6dd66d43226d39894a37944a369ee" translate="yes" xml:space="preserve">
          <source>Look up a remote git repository using the repository's name and URL, as well as specifications for how to fetch from the remote (e.g. which remote branch to fetch from).</source>
          <target state="translated">リモートの git リポジトリを検索するには、リポジトリの名前と URL、そしてリモートからの取得方法 (どのリモートブランチから取得するかなど)を指定します。</target>
        </trans-unit>
        <trans-unit id="297e4906774f5b0f9f9ea2352dd36b66f2c9d575" translate="yes" xml:space="preserve">
          <source>Look up a symbol from a shared library handle, return callable function pointer on success.</source>
          <target state="translated">共有ライブラリのハンドルからシンボルを検索し、成功したら呼び出し可能な関数ポインタを返します。</target>
        </trans-unit>
        <trans-unit id="b2554c797a77ef5cd564f4094822fce342e2ced7" translate="yes" xml:space="preserve">
          <source>Look up a symbol from a shared library handle, silently return &lt;code&gt;C_NULL&lt;/code&gt; on lookup failure. This method is now deprecated in favor of &lt;code&gt;dlsym(handle, sym; throw_error=false)&lt;/code&gt;.</source>
          <target state="translated">共有ライブラリのハンドルからシンボルを検索し、検索が失敗した場合は &lt;code&gt;C_NULL&lt;/code&gt; を返します。このメソッドは廃止され、 &lt;code&gt;dlsym(handle, sym; throw_error=false)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c18a26a0372be6990fb3f7d9280fb8a4395903a4" translate="yes" xml:space="preserve">
          <source>Look up the value of a key in the current task's task-local storage.</source>
          <target state="translated">現在のタスクのタスクローカルストレージのキーの値を検索します。</target>
        </trans-unit>
        <trans-unit id="1a5964da6a0276ac045eacedf1ca054ba281575e" translate="yes" xml:space="preserve">
          <source>Lookup the name of the current HEAD of git repository &lt;code&gt;repo&lt;/code&gt;. If &lt;code&gt;repo&lt;/code&gt; is currently detached, return the name of the HEAD it's detached from.</source>
          <target state="translated">git repository &lt;code&gt;repo&lt;/code&gt; の現在のHEADの名前を検索します。 &lt;code&gt;repo&lt;/code&gt; が現在切り離されている場合は、切り離されているHEADの名前を返します。</target>
        </trans-unit>
        <trans-unit id="c7d22d27b21054a2d862fb3e778055ec62497845" translate="yes" xml:space="preserve">
          <source>Lookup the object id of the current HEAD of git repository &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">git repository &lt;code&gt;repo&lt;/code&gt; の現在のHEADのオブジェクトIDを検索します。</target>
        </trans-unit>
        <trans-unit id="2897343d4dfca50b3dbd880e6b406397dfc276be" translate="yes" xml:space="preserve">
          <source>Lookup the status of the file at &lt;code&gt;path&lt;/code&gt; in the git repository &lt;code&gt;repo&lt;/code&gt;. For instance, this can be used to check if the file at &lt;code&gt;path&lt;/code&gt; has been modified and needs to be staged and committed.</source>
          <target state="translated">で、ファイルの検索状況 &lt;code&gt;path&lt;/code&gt; のgitリポジトリに &lt;code&gt;repo&lt;/code&gt; 。たとえば、これを使用して、 &lt;code&gt;path&lt;/code&gt; あるファイルが変更されており、ステージングしてコミットする必要があるかどうかを確認できます。</target>
        </trans-unit>
        <trans-unit id="e83f1c0d81e570990421db9c6c5103dd52bab5e9" translate="yes" xml:space="preserve">
          <source>Loops and Comprehensions</source>
          <target state="translated">ループと理解度</target>
        </trans-unit>
        <trans-unit id="292714b14a57c3b911bea2bc02c843a11e53cd72" translate="yes" xml:space="preserve">
          <source>Loudly Crying Face</source>
          <target state="translated">大声で泣き顔</target>
        </trans-unit>
        <trans-unit id="68479172d96d6399ed79d6c3cc2275a9e4cb417d" translate="yes" xml:space="preserve">
          <source>Love Hotel</source>
          <target state="translated">ラブホテル</target>
        </trans-unit>
        <trans-unit id="e8ed5bf829210dcfddc85b2455095cf9764bc443" translate="yes" xml:space="preserve">
          <source>Love Letter</source>
          <target state="translated">ラブレター</target>
        </trans-unit>
        <trans-unit id="1e20259076165d87571f777f8f501c9eec6cf077" translate="yes" xml:space="preserve">
          <source>Low Brightness Symbol</source>
          <target state="translated">低輝度シンボル</target>
        </trans-unit>
        <trans-unit id="3c768d286c3fa1a1be3b0b32968dce7e2bf6df5f" translate="yes" xml:space="preserve">
          <source>Low-level (C kernel) based operations &lt;a href=&quot;https://github.com/JuliaGPU/OpenCL.jl&quot;&gt;OpenCL.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/CUDAdrv.jl&quot;&gt;CUDAdrv.jl&lt;/a&gt; which are respectively an OpenCL interface and a CUDA wrapper.</source>
          <target state="translated">低レベル（Cカーネル）ベースの操作&lt;a href=&quot;https://github.com/JuliaGPU/OpenCL.jl&quot;&gt;OpenCL.jl&lt;/a&gt;と&lt;a href=&quot;https://github.com/JuliaGPU/CUDAdrv.jl&quot;&gt;CUDAdrv.jl&lt;/a&gt;は、それぞれOpenCLインターフェースとCUDAラッパーです。</target>
        </trans-unit>
        <trans-unit id="0d470f206b953bd94a63cddee039b55b43eb02d8" translate="yes" xml:space="preserve">
          <source>Low-level (Julia Kernel) interfaces like &lt;a href=&quot;https://github.com/JuliaGPU/CUDAnative.jl&quot;&gt;CUDAnative.jl&lt;/a&gt; which is a Julia native CUDA implementation.</source>
          <target state="translated">JuliaネイティブCUDA実装である&lt;a href=&quot;https://github.com/JuliaGPU/CUDAnative.jl&quot;&gt;CUDAnative.jlの&lt;/a&gt;ような低レベル（Juliaカーネル）インターフェース。</target>
        </trans-unit>
        <trans-unit id="8a939192d22d6941f17735b112fcce8351ea8eba" translate="yes" xml:space="preserve">
          <source>Low-level macro used to mark expressions returned by a macro that should be documented. If more than one expression is marked then the same docstring is applied to each expression.</source>
          <target state="translated">文書化されるべきマクロによって返された式をマークするために使用される低レベルのマクロ。複数の式がマークされている場合は、それぞれの式に同じ docstring が適用されます。</target>
        </trans-unit>
        <trans-unit id="93d0030ec86c684d10a9c49e09b2634f0ca13492" translate="yes" xml:space="preserve">
          <source>Low-level matrix operations</source>
          <target state="translated">低レベルの行列演算</target>
        </trans-unit>
        <trans-unit id="c33ae1bfbf8999a2bc79cecceab734ada1f32053" translate="yes" xml:space="preserve">
          <source>Low-level synchronization primitives</source>
          <target state="translated">低レベル同期プリミティブ</target>
        </trans-unit>
        <trans-unit id="69c6e547fabb23ad635ac8fe93ede5712392e080" translate="yes" xml:space="preserve">
          <source>Lower &lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_matrix&quot;&gt;triangular matrix&lt;/a&gt;</source>
          <target state="translated">下&lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_matrix&quot;&gt;三角行列&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="23a4f4335d144fa2497d4fe37f2b528b18f4e240" translate="yes" xml:space="preserve">
          <source>Lower &lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_matrix&quot;&gt;triangular matrix&lt;/a&gt; with unit diagonal</source>
          <target state="translated">対角単位の下&lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_matrix&quot;&gt;三角行列&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e67838aee8be4e7755da1c297ec68ae6e282902c" translate="yes" xml:space="preserve">
          <source>Lower Half Block</source>
          <target state="translated">下部ハーフブロック</target>
        </trans-unit>
        <trans-unit id="b7bfddef31a484ac690f541d1587c0a82f9ea2c7" translate="yes" xml:space="preserve">
          <source>Lower Half Circle</source>
          <target state="translated">下半円</target>
        </trans-unit>
        <trans-unit id="0a46dc7d5d38dbb0f9593bbac09bb5a5e1168df1" translate="yes" xml:space="preserve">
          <source>Lower Half Inverse White Circle</source>
          <target state="translated">下半分インバースホワイトサークル</target>
        </trans-unit>
        <trans-unit id="19c077435147598603f42bc8543d280b80283f3c" translate="yes" xml:space="preserve">
          <source>Lower Left Quadrant Circular Arc</source>
          <target state="translated">左下四分儀円弧</target>
        </trans-unit>
        <trans-unit id="a3a82cb0d0923582f86a3cfde8b8e51e4ca1a96a" translate="yes" xml:space="preserve">
          <source>Lower Left Triangle</source>
          <target state="translated">左下の三角形</target>
        </trans-unit>
        <trans-unit id="01b22a0cc9e2a392fdb90f606abf5d1b88f864a7" translate="yes" xml:space="preserve">
          <source>Lower Right Quadrant Circular Arc</source>
          <target state="translated">右下四分儀円弧</target>
        </trans-unit>
        <trans-unit id="70aee1ac83a2f1a5579bf9159c07bceb364ffd0e" translate="yes" xml:space="preserve">
          <source>Lower Right Triangle</source>
          <target state="translated">右下の三角形</target>
        </trans-unit>
        <trans-unit id="fe9cd1617eaf77e57754425b931c1afef95157bf" translate="yes" xml:space="preserve">
          <source>Lower bound for log level of accepted events</source>
          <target state="translated">受け付けたイベントのログレベルの下限</target>
        </trans-unit>
        <trans-unit id="44e79a7195ba19b673d8eec03c4e37479443f063" translate="yes" xml:space="preserve">
          <source>Lower triangle of a matrix, overwriting &lt;code&gt;M&lt;/code&gt; in the process. See also &lt;a href=&quot;#LinearAlgebra.tril&quot;&gt;&lt;code&gt;tril&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">行列の下三角で、プロセスで &lt;code&gt;M&lt;/code&gt; を上書きします。&lt;a href=&quot;#LinearAlgebra.tril&quot;&gt; &lt;code&gt;tril&lt;/code&gt; &lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="b635a689678f453635c9ee1b78fc69558f89e909" translate="yes" xml:space="preserve">
          <source>Lower triangle of a matrix.</source>
          <target state="translated">行列の下三角形。</target>
        </trans-unit>
        <trans-unit id="3b856a21fe98568ae306d713f4ed924f2bea5deb" translate="yes" xml:space="preserve">
          <source>Lozenge</source>
          <target state="translated">Lozenge</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
