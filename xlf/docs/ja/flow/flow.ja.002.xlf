<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="flow">
    <body>
      <group id="flow">
        <trans-unit id="c47667d674268b42d8bc54bea9304a308b2c873f" translate="yes" xml:space="preserve">
          <source>Now suppose that instead of a boolean, we have a numerical value representing, say, the number of comments on a post. We want to display a count of the comments, unless there are no comments. We might naively try to do something similar to the boolean case:</source>
          <target state="translated">ここで、ブール値の代わりに、投稿に対するコメント数を表す数値があるとします。コメントがない場合を除いて、コメントの数を表示したいとします。素朴に、ブーリアンの場合と似たようなことをしようとするかもしれません。</target>
        </trans-unit>
        <trans-unit id="130ecc6b759fae2f2cbba2aade21537572c9ebf2" translate="yes" xml:space="preserve">
          <source>Now that all the setup and initialization is complete, you are ready to write actual Flow code. For each file that you have flagged with &lt;code&gt;// @flow&lt;/code&gt;, you now have the full power of Flow and its type-checking available to you. Here is an example Flow file:</source>
          <target state="translated">これですべてのセットアップと初期化が完了したので、実際のフローコードを記述できます。 &lt;code&gt;// @flow&lt;/code&gt; でフラグを付けたファイルごとに、Flowの全機能とその型チェックを利用できるようになります。次にフローファイルの例を示します。</target>
        </trans-unit>
        <trans-unit id="8a0aa492d72ba5e5ee4e490208cd56c9c6fd8b5b" translate="yes" xml:space="preserve">
          <source>Now type inference can keep working for &lt;code&gt;typeof obj&lt;/code&gt; which returns the expected shape of the object.</source>
          <target state="translated">これで、型推論は、オブジェクトの予想される形状を返す &lt;code&gt;typeof obj&lt;/code&gt; に対して機能し続けることができます。</target>
        </trans-unit>
        <trans-unit id="18e7605734b62fc321cd934a156de7bc5fd3f54f" translate="yes" xml:space="preserve">
          <source>Now wherever we use &lt;code&gt;this.props&lt;/code&gt; in our React component Flow will treat it as the &lt;code&gt;Props&lt;/code&gt; type we defined.</source>
          <target state="translated">これで、Reactコンポーネントフローで &lt;code&gt;this.props&lt;/code&gt; を使用する場合は常に、定義した &lt;code&gt;Props&lt;/code&gt; タイプとして処理されます。</target>
        </trans-unit>
        <trans-unit id="cba47b2f9c45e1dcfda8b52779b4d36ece5cf6c4" translate="yes" xml:space="preserve">
          <source>Now you&amp;rsquo;ll get a warning from Flow if you try to use numbers.</source>
          <target state="translated">数値を使用しようとすると、フローから警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="abd74ca854ddc164ed4dd85269784a3b28f553e8" translate="yes" xml:space="preserve">
          <source>Now your code will not leak &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">これで、コードはリークし &lt;code&gt;any&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="d733ad521afc4421b4a66b432128c9bcdc2b5eec" translate="yes" xml:space="preserve">
          <source>Now, if you pass two values then &lt;code&gt;props.children&lt;/code&gt; will be an array. Specifically in this case &lt;code&gt;props.children&lt;/code&gt; will be &lt;code&gt;[1, 2]&lt;/code&gt;.</source>
          <target state="translated">ここで、2つの値を &lt;code&gt;props.children&lt;/code&gt; と、props.childrenは配列になります。特にこの場合、 &lt;code&gt;props.children&lt;/code&gt; は &lt;code&gt;[1, 2]&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="be6e2a0e2bd898f29d9210b231319127fd00f218" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s Flowify the component we just wrote:</source>
          <target state="translated">次に、先ほど書いたコンポーネントをFlowifyしましょう。</target>
        </trans-unit>
        <trans-unit id="c7db6f471fb8404ecff0960ed4244da4532a2c7e" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s walk through different definitions of &lt;code&gt;method()&lt;/code&gt; in a couple different &lt;em&gt;subclasses&lt;/em&gt;.</source>
          <target state="translated">ここで、いくつかの異なる&lt;em&gt;サブクラス&lt;/em&gt;での &lt;code&gt;method()&lt;/code&gt; の異なる定義について見ていきましょう。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3fe7f794fc68b1034d0e3f564bf32dd7ffd089d7" translate="yes" xml:space="preserve">
          <source>Nuclide</source>
          <target state="translated">Nuclide</target>
        </trans-unit>
        <trans-unit id="63c0e833d1f670a8069d40968493548f0265ef94" translate="yes" xml:space="preserve">
          <source>Nuclide also comes with many other features including support for remote projects, hack, mercurial etc.</source>
          <target state="translated">Nuclideには、リモートプロジェクト、ハック、マーキュリアルなどのサポートを含む多くの機能が搭載されています。</target>
        </trans-unit>
        <trans-unit id="9e0b7a63508302d9d09c38742d062288dc1823d2" translate="yes" xml:space="preserve">
          <source>Nuclide v0.243.0 onward has support for working with Flow to limit the reported warnings to the working fileset. This allows Nuclide and Flow to work efficiently on large codebases with tens of thousands of unsuppressed warnings.</source>
          <target state="translated">Nuclide v0.243.0以降では、Flowとの連携により、報告される警告を作業ファイルセットに限定することができるようになりました。これにより、NuclideとFlowは、何万もの抑圧されていない警告を持つ大規模なコードベースで効率的に作業できるようになりました。</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="335e5e44a812438f93ba78ec1988eb2972404cb9" translate="yes" xml:space="preserve">
          <source>Numbers: like &lt;code&gt;42&lt;/code&gt; or &lt;code&gt;3.14&lt;/code&gt;</source>
          <target state="translated">数字： &lt;code&gt;42&lt;/code&gt; や &lt;code&gt;3.14&lt;/code&gt; など</target>
        </trans-unit>
        <trans-unit id="cbf147d445453a6660add525598d56066b954b1c" translate="yes" xml:space="preserve">
          <source>Object Types</source>
          <target state="translated">オブジェクトの種類</target>
        </trans-unit>
        <trans-unit id="9ed92c18b4e477381c353e8136dbc9d058b63386" translate="yes" xml:space="preserve">
          <source>Object type inference</source>
          <target state="translated">オブジェクト型推論</target>
        </trans-unit>
        <trans-unit id="0b9a72ed85754757a03a424a4f413c85cc295a74" translate="yes" xml:space="preserve">
          <source>Object type syntax</source>
          <target state="translated">オブジェクト型の構文</target>
        </trans-unit>
        <trans-unit id="cdea7c16abb43506671d0750b87a9ae17eb2398a" translate="yes" xml:space="preserve">
          <source>Object types can have optional properties where a question mark &lt;code&gt;?&lt;/code&gt; comes after the property name.</source>
          <target state="translated">オブジェクトタイプは、疑問符（ &lt;code&gt;?&lt;/code&gt; )が付いているオプションのプロパティを持つことができます。プロパティ名の後に続きます。</target>
        </trans-unit>
        <trans-unit id="f85c54a239ca0dd9865eaee3f09163bc064e2fde" translate="yes" xml:space="preserve">
          <source>Object types try to match the syntax for objects in JavaScript as much as possible. Using curly braces &lt;code&gt;{}&lt;/code&gt; and name-value pairs using a colon &lt;code&gt;:&lt;/code&gt; split by commas &lt;code&gt;,&lt;/code&gt;.</source>
          <target state="translated">オブジェクト型は、JavaScriptのオブジェクトの構文にできるだけ一致するように試みます。中括弧用い &lt;code&gt;{}&lt;/code&gt; および結腸使用して、名前と値のペア &lt;code&gt;:&lt;/code&gt; コンマによって分割し &lt;code&gt;,&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1354578aed5c555826e657109cf8e1a80a7db3d0" translate="yes" xml:space="preserve">
          <source>Objects are structurally typed</source>
          <target state="translated">オブジェクトは構造的に型付けされています。</target>
        </trans-unit>
        <trans-unit id="9ab5bd450c651a40acb31c6d2173d2d8a317f03b" translate="yes" xml:space="preserve">
          <source>Objects as maps</source>
          <target state="translated">マップとしてのオブジェクト</target>
        </trans-unit>
        <trans-unit id="01a1617fcbeab1f400211a1e0e3d5541707fdd66" translate="yes" xml:space="preserve">
          <source>Objects can be used in many different ways in JavaScript. There are a number of different ways to type them in order to support all the different use cases.</source>
          <target state="translated">オブジェクトは、JavaScriptではさまざまな方法で使用することができます。さまざまなユースケースをサポートするために、オブジェクトのタイプにはさまざまな方法があります。</target>
        </trans-unit>
        <trans-unit id="a4eb44d5d295882356db532a105f60a76be3916a" translate="yes" xml:space="preserve">
          <source>Obsolete. Set this to &lt;code&gt;true&lt;/code&gt; to always strip the root directory from file paths in error messages when using &lt;code&gt;--json&lt;/code&gt;, &lt;code&gt;--from emacs&lt;/code&gt;, and &lt;code&gt;--from vim&lt;/code&gt;. Do not use this option. Instead, pass the command line flag &lt;code&gt;--strip-root&lt;/code&gt;.</source>
          <target state="translated">廃止されました。 &lt;code&gt;--json&lt;/code&gt; 、-- &lt;code&gt;--from emacs&lt;/code&gt; 、および &lt;code&gt;--from vim&lt;/code&gt; を使用するときにエラーメッセージのファイルパスからルートディレクトリを常に削除するには、これを &lt;code&gt;true&lt;/code&gt; に設定します。このオプションは使用しないでください。代わりに、コマンドラインフラグ &lt;code&gt;--strip-root&lt;/code&gt; を渡します。</target>
        </trans-unit>
        <trans-unit id="fd9b17a8cc9cfeab14950ff409781477ba7078b9" translate="yes" xml:space="preserve">
          <source>Often third-party libraries have broken type definitions or have type definitions only compatible with a certain version of Flow. In those cases it may be useful to use type information from the third-party libraries without typechecking their contents.</source>
          <target state="translated">サードパーティのライブラリでは、型定義が壊れていたり、特定のバージョンのFlowとしか互換性のない型定義を持っていたりすることがよくあります。このような場合、サードパーティライブラリの内容をタイプチェックせずに、サードパーティライブラリの型情報を使用することが有用な場合があります。</target>
        </trans-unit>
        <trans-unit id="adacc74ca82788d5eac49de1a84a330f45c46c00" translate="yes" xml:space="preserve">
          <source>Often, third-party code is organized in terms of modules rather than globals. To write a libdef that declares the presence of a module you&amp;rsquo;ll want to use the &lt;code&gt;declare module&lt;/code&gt; syntax:</source>
          <target state="translated">多くの場合、サードパーティのコードはグローバルではなくモジュールの観点から整理されています。モジュールの存在を宣言するlibdefを作成するには、 &lt;code&gt;declare module&lt;/code&gt; 構文を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="b24bbeccf5137f66b11ed50187cc6eafef3213fa" translate="yes" xml:space="preserve">
          <source>On the flip-side, &lt;strong&gt;&lt;em&gt;completeness&lt;/em&gt;&lt;/strong&gt; is the ability for a type checker to only ever catch errors that &lt;em&gt;would&lt;/em&gt; happen at runtime. This comes at the cost of sometimes missing errors that will happen at runtime.</source>
          <target state="translated">フリップ側では、&lt;strong&gt;&lt;em&gt;完全に&lt;/em&gt;&lt;/strong&gt;しかエラーをキャッチするために型チェッカーのための能力である&lt;em&gt;だろう&lt;/em&gt;、実行時に起こります。これには、実行時に発生するエラーが欠落する場合があります。</target>
        </trans-unit>
        <trans-unit id="d37f56efe0e6015ca80498e8ea761c659a342927" translate="yes" xml:space="preserve">
          <source>Once all the dependencies of a &lt;code&gt;@flow strict-local&lt;/code&gt; file are strict, the file can be upgraded to a &lt;code&gt;@flow strict&lt;/code&gt; file. A &lt;code&gt;@flow strict&lt;/code&gt; file cannot depend on a &lt;code&gt;@flow strict-local&lt;/code&gt; file as this would break the &lt;code&gt;nonstrict-import&lt;/code&gt; rule.</source>
          <target state="translated">&lt;code&gt;@flow strict-local&lt;/code&gt; ファイルのすべての依存関係が厳密になったら、ファイルを &lt;code&gt;@flow strict&lt;/code&gt; ファイルにアップグレードできます。 &lt;code&gt;@flow strict&lt;/code&gt; ファイルが依存することはできません &lt;code&gt;@flow strict-local&lt;/code&gt; これが壊れると、ファイル &lt;code&gt;nonstrict-import&lt;/code&gt; ルールを。</target>
        </trans-unit>
        <trans-unit id="2e418e3cfbf0c00ec225eae651536e321fd3bd30" translate="yes" xml:space="preserve">
          <source>Once you have &lt;a href=&quot;https://flow.org/en/install/&quot;&gt;installed&lt;/a&gt; Flow, you will want to get a feel of how to use Flow at the most basic level. For most new Flow projects, you will follow this general pattern:</source>
          <target state="translated">Flow を&lt;a href=&quot;https://flow.org/en/install/&quot;&gt;インストール&lt;/a&gt;したら、Flowを最も基本的なレベルで使用する方法を理解する必要があります。ほとんどの新しいFlowプロジェクトでは、次の一般的なパターンに従います。</target>
        </trans-unit>
        <trans-unit id="6ccb0b14eaa9c14dee4efd8a3cd89afe87b6ccb4" translate="yes" xml:space="preserve">
          <source>Once you have Babel setup, install &lt;code&gt;@babel/preset-flow&lt;/code&gt; with either &lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt; or &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">Babelのセットアップが完了したら、 &lt;code&gt;@babel/preset-flow&lt;/code&gt; を&lt;a href=&quot;https://yarnpkg.com/&quot;&gt;Yarn&lt;/a&gt;または&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;でインストールします。</target>
        </trans-unit>
        <trans-unit id="fb59ba6cf0854aeafe84a152636ede676c99a388" translate="yes" xml:space="preserve">
          <source>Once you have eliminated signature verification errors, you can turn on the types-first mode, by adding the following line to the &lt;code&gt;[options]&lt;/code&gt; section of the &lt;code&gt;.flowconfig&lt;/code&gt; file:</source>
          <target state="translated">署名検証エラーを排除したら、 &lt;code&gt;.flowconfig&lt;/code&gt; ファイルの &lt;code&gt;[options]&lt;/code&gt; セクションに次の行を追加することで、types-firstモードをオンにできます。</target>
        </trans-unit>
        <trans-unit id="f5fea1da9e23ea1d202b2729a702a3f535801fdd" translate="yes" xml:space="preserve">
          <source>One of the main contributors of Flow&amp;rsquo;s precision is path-sensitivity: the way types interact with runtime tests. The essence of many JavaScript idioms is to put together ad hoc sets of runtime values and to take them apart with shallow, structural (in)equality checks. In Flow, the set of runtime values that a variable may contain is described by its type, and a runtime test on that variable refines the type to a smaller set. This ability turns out to be quite powerful and general in practice.</source>
          <target state="translated">Flowの精度の主な貢献者の1つはパスセンシティビティです。つまり、型がランタイムテストと相互作用する方法です。多くのJavaScriptイディオムの本質は、ランタイム値のアドホックセットをまとめ、それらを浅い構造的（不等）チェックで分解することです。フローでは、変数に含まれる可能性のあるランタイム値のセットはそのタイプによって記述され、その変数に対するランタイムテストはタイプをより小さなセットに絞り込みます。この能力は、実際には非常に強力で一般的であることがわかります。</target>
        </trans-unit>
        <trans-unit id="c922fe63b25cd49cec8888b01a561a5582a84a58" translate="yes" xml:space="preserve">
          <source>Only allowing a specific element type as children.</source>
          <target state="translated">特定の要素タイプのみを子として許可します。</target>
        </trans-unit>
        <trans-unit id="552faaf2aafbe53d107876ccee0f0634f915c3e5" translate="yes" xml:space="preserve">
          <source>Only one background process will be running at any given time, so if you run &lt;code&gt;flow status&lt;/code&gt; multiple times, it will use the same process.</source>
          <target state="translated">一度に実行されるバックグラウンドプロセスは1つだけなので、 &lt;code&gt;flow status&lt;/code&gt; 複数回実行すると、同じプロセスが使用されます。</target>
        </trans-unit>
        <trans-unit id="e4a45cacdd8d7e9f0ebca1ec7bc3fb1f33c78855" translate="yes" xml:space="preserve">
          <source>Opaque Type Alias Syntax</source>
          <target state="translated">不透明型エイリアス構文</target>
        </trans-unit>
        <trans-unit id="65ea8514201b92749598f548009f0a4afe84c188" translate="yes" xml:space="preserve">
          <source>Opaque Type Alias Type Checking</source>
          <target state="translated">不透明タイプのエイリアスタイプのチェック</target>
        </trans-unit>
        <trans-unit id="961bf1b4717073b1bc912e5a6e9062ea360301f6" translate="yes" xml:space="preserve">
          <source>Opaque Type Aliases</source>
          <target state="translated">不透明なエイリアスタイプ</target>
        </trans-unit>
        <trans-unit id="6077a6482ea571ceaa9f7539cf7e9cbf318e56ce" translate="yes" xml:space="preserve">
          <source>Opaque type aliases are created using the words &lt;code&gt;opaque type&lt;/code&gt; followed by its name, an equals sign &lt;code&gt;=&lt;/code&gt;, and a type definition.</source>
          <target state="translated">不透明タイプのエイリアスは、 &lt;code&gt;opaque type&lt;/code&gt; という単語に続けて、その名前、等号 &lt;code&gt;=&lt;/code&gt; 、タイプ定義を使用して作成されます。</target>
        </trans-unit>
        <trans-unit id="ee9ac0643d45dfbbd750de612f57c1963700d825" translate="yes" xml:space="preserve">
          <source>Opaque type aliases are type aliases that do not allow access to their underlying type outside of the file in which they are defined.</source>
          <target state="translated">不透明型エイリアスとは、定義されているファイルの外部からその基礎となる型にアクセスできないようにする型エイリアスです。</target>
        </trans-unit>
        <trans-unit id="5f911be9170f1811fca0f4efce9cc2904081c303" translate="yes" xml:space="preserve">
          <source>Opaque type aliases can also have their own &lt;a href=&quot;../generics&quot;&gt;generics&lt;/a&gt;, and they work exactly as generics do in regular &lt;a href=&quot;../aliases#toc-type-alias-generics&quot;&gt;type aliases&lt;/a&gt;</source>
          <target state="translated">不透明な型エイリアスは独自の&lt;a href=&quot;../generics&quot;&gt;ジェネリックを&lt;/a&gt;持つこともでき、通常の&lt;a href=&quot;../aliases#toc-type-alias-generics&quot;&gt;型エイリアス&lt;/a&gt;でジェネリックが行うのとまったく同じように機能します。</target>
        </trans-unit>
        <trans-unit id="a9f3700878b30b619fa2c5143a86c38508c7ca4b" translate="yes" xml:space="preserve">
          <source>Opaque type aliases, like regular type aliases, may be used anywhere a type can be used.</source>
          <target state="translated">不透明な型のエイリアスは、通常の型のエイリアスのように、型が使用できる場所であればどこでも使用することができます。</target>
        </trans-unit>
        <trans-unit id="ddd2d4ec70a68949d8c75dd5fb57b7fa281e8e27" translate="yes" xml:space="preserve">
          <source>Optional Parameters</source>
          <target state="translated">オプションのパラメータ</target>
        </trans-unit>
        <trans-unit id="6eb1e4ba2d4c68b05e65e2f8b787201061244dd0" translate="yes" xml:space="preserve">
          <source>Optional function parameters</source>
          <target state="translated">オプションの関数パラメータ</target>
        </trans-unit>
        <trans-unit id="b20d0cae17674ab970acb532453aaf71edae6a61" translate="yes" xml:space="preserve">
          <source>Optional object properties</source>
          <target state="translated">オプションのオブジェクトプロパティ</target>
        </trans-unit>
        <trans-unit id="2d932cfadb898020aa3d7c79ba0029b42cc035ac" translate="yes" xml:space="preserve">
          <source>Optional object type properties</source>
          <target state="translated">オプションのオブジェクト型プロパティ</target>
        </trans-unit>
        <trans-unit id="7d05768bc14089a0cc0ad2e54b12a94fab4dbaf6" translate="yes" xml:space="preserve">
          <source>Optional parameters will accept missing, &lt;code&gt;undefined&lt;/code&gt;, or matching types. But they will not accept &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">オプションのパラメーターは、欠落、 &lt;code&gt;undefined&lt;/code&gt; 、または一致するタイプを受け入れます。しかし、それらは &lt;code&gt;null&lt;/code&gt; を受け入れません。</target>
        </trans-unit>
        <trans-unit id="5037e7b0dd30d22a12232b46317dc9e63f9ba600" translate="yes" xml:space="preserve">
          <source>Or as constructed wrapper objects.</source>
          <target state="translated">あるいは、構築されたラッパーオブジェクトとして。</target>
        </trans-unit>
        <trans-unit id="f26ec27bdcca139b8bc25d769f1290e1e51a3bf0" translate="yes" xml:space="preserve">
          <source>Or you could be accessing an element that does not exist if it is a &amp;ldquo;sparse array&amp;rdquo;.</source>
          <target state="translated">または、「スパース配列」の場合、存在しない要素にアクセスしている可能性があります。</target>
        </trans-unit>
        <trans-unit id="e404be6e42270a506b9fda4079e3cbb1faf93ee5" translate="yes" xml:space="preserve">
          <source>Or you could refine on the shape of objects.</source>
          <target state="translated">あるいは、オブジェクトの形状で絞り込むこともできます。</target>
        </trans-unit>
        <trans-unit id="36ccd6fa5b54b074d48b3c318b7724049b209ff5" translate="yes" xml:space="preserve">
          <source>Other Editors</source>
          <target state="translated">その他の編集者</target>
        </trans-unit>
        <trans-unit id="b01d9e5fc57d8be7b4d4cfaf9d867219b88b9c98" translate="yes" xml:space="preserve">
          <source>Other extensions that you may try are:</source>
          <target state="translated">他にも試してみたい拡張機能があります。</target>
        </trans-unit>
        <trans-unit id="55d5eb5f68ae162a0c0275477fbf7fd7aa314ea9" translate="yes" xml:space="preserve">
          <source>Other type systems will favor completeness instead, only reporting real errors in favor of possibly missing errors. Unit/Integration testing is an extreme form of this approach. Often this comes at the cost of missing the errors that are the most complicated to find, leaving that part up to the developer.</source>
          <target state="translated">他のタイプのシステムは、代わりに完全性を重視し、見落としている可能性のあるエラーの代わりに、実際のエラーのみを報告します。ユニット/統合テストは、このアプローチの極端な形です。多くの場合、このアプローチは、見つけるのが最も複雑なエラーを見落とす代償として、その部分を開発者に任せることになります。</target>
        </trans-unit>
        <trans-unit id="8d7bf5bf136e81f9388c1f4eca050d6d94e965d7" translate="yes" xml:space="preserve">
          <source>Others</source>
          <target state="translated">Others</target>
        </trans-unit>
        <trans-unit id="d10a332d2514aa48380a681c92c805bab5fc2c39" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;../types&quot;&gt;types reference&lt;/a&gt; has more information about both &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../types#toc-react-element&quot;&gt;&lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">私たちの&lt;a href=&quot;../types&quot;&gt;タイプの参照は、&lt;/a&gt;両方の詳細については持ってい&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../types#toc-react-element&quot;&gt; &lt;code&gt;React.Element&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c7ec91907688dba7293db664f96aa7520dd5050d" translate="yes" xml:space="preserve">
          <source>Our first case is an element with no children:</source>
          <target state="translated">最初のケースは、子供のいない要素です。</target>
        </trans-unit>
        <trans-unit id="3e4d85a254d099e6caabb9070a8f1a5835e74184" translate="yes" xml:space="preserve">
          <source>Outside the Defining File</source>
          <target state="translated">定義ファイルの外側</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="2bfd0b733d61ec42886bc0c31e24e1f1a0d24fdf" translate="yes" xml:space="preserve">
          <source>Parameterized generics</source>
          <target state="translated">パラメータ化されたジェネリック</target>
        </trans-unit>
        <trans-unit id="bc7025db05fe11cfb78fa0f8ede0665290fcb863" translate="yes" xml:space="preserve">
          <source>Parts of the source that are visible from a file&amp;rsquo;s exports need to be annotated unless their type can be trivially inferred (e.g. the exported expression is a numeric literal). This is a requirement for types-first mode to function properly. Failure to properly annotate exports raise &lt;code&gt;signature-verfication-failure&lt;/code&gt;s.</source>
          <target state="translated">ファイルのエクスポートから見えるソースの部分は、そのタイプを簡単に推測できない限り（たとえば、エクスポートされた式が数値リテラルである場合）、注釈を付ける必要があります。これは、タイプファーストモードが正しく機能するための要件です。エクスポートに適切な注釈を付けないと、 &lt;code&gt;signature-verfication-failure&lt;/code&gt; が発生します。</target>
        </trans-unit>
        <trans-unit id="6aa250c187d7bae549c808c9085514424d802eea" translate="yes" xml:space="preserve">
          <source>Pathogen</source>
          <target state="translated">Pathogen</target>
        </trans-unit>
        <trans-unit id="3dd4db5ce7ea626f59e720f0c27096a22aa1ecd0" translate="yes" xml:space="preserve">
          <source>Precision</source>
          <target state="translated">Precision</target>
        </trans-unit>
        <trans-unit id="8a51f97f15da4dd4d5a94fab1a4108cee0b5e1d4" translate="yes" xml:space="preserve">
          <source>Precision also has other desirable consequences. When types are trustworthy, developers tend to rely on them to structure their code and reason about it, leading to cleaner and more efficient code with fewer dynamic checks. When type errors are trustworthy, developers can focus on what their code does rather than thinking about how to rewrite their code to satisfy (or work around) the type system.</source>
          <target state="translated">精度は他にも望ましい結果をもたらします。型が信頼できるものであれば、開発者はコードの構造化や推論を型に頼る傾向があり、動的なチェックが少なく、よりクリーンで効率的なコードにつながります。型エラーが信頼できる場合、開発者は型システムを満足させる(あるいは回避する)ためにコードをどのように書き換えるかを考えるよりも、自分のコードが何をするかに集中することができます。</target>
        </trans-unit>
        <trans-unit id="83590fe5defcf4d8a2747e7bff66e91f7879b09e" translate="yes" xml:space="preserve">
          <source>Precision usually comes at the cost of speed. But while a precise analysis is desirable, most of the appeal of JavaScript is lost if we slow down the edit-refresh cycle by making developers wait as we compile.</source>
          <target state="translated">正確さは通常、スピードを犠牲にして生まれます。しかし、正確な分析が望ましいとはいえ、コンパイル時に開発者を待たせることで編集・更新サイクルを遅くしてしまうと、JavaScriptの魅力のほとんどが失われてしまいます。</target>
        </trans-unit>
        <trans-unit id="257e6b97ae8767ca7162ae0be418d790074caf9b" translate="yes" xml:space="preserve">
          <source>Predicate Functions</source>
          <target state="translated">叙述関数</target>
        </trans-unit>
        <trans-unit id="8fcc548a63302b124fd2a2a6ebe6d394e16cc696" translate="yes" xml:space="preserve">
          <source>Prepare Your Code for Flow</source>
          <target state="translated">フローのためのコードの準備</target>
        </trans-unit>
        <trans-unit id="ba3433a4118eec88859d98e1423037c6cc489342" translate="yes" xml:space="preserve">
          <source>Prepare your codebase for Types-First</source>
          <target state="translated">Types-First 用のコードベースを準備します。</target>
        </trans-unit>
        <trans-unit id="80015c28ef31d8e37f60f4672f12166e4717f624" translate="yes" xml:space="preserve">
          <source>Preparing a project for Flow requires only one command:</source>
          <target state="translated">Flow用のプロジェクトを準備する際に必要なコマンドは1つだけです。</target>
        </trans-unit>
        <trans-unit id="0334ecb0491c1c96b75c2abb7a0dde8caad5c58f" translate="yes" xml:space="preserve">
          <source>Preserving the Instance Type of a Component</source>
          <target state="translated">コンポーネントのインスタンス型を保持する</target>
        </trans-unit>
        <trans-unit id="f6675da1b1e3eb27ea3b95e0125a3fc19547c62c" translate="yes" xml:space="preserve">
          <source>Press Ctrl+Shift+P to bring up the Command Palette (or use Tools &amp;gt; Command Palette menu)</source>
          <target state="translated">Ctrl + Shift + Pを押してコマンドパレットを表示します（または[ツール]&amp;gt; [コマンドパレット]メニューを使用します）。</target>
        </trans-unit>
        <trans-unit id="4e34606590cc14f76b8a62ab4f8ca344fd2d5ed8" translate="yes" xml:space="preserve">
          <source>Prevent this from happening by cutting &lt;code&gt;any&lt;/code&gt; off as soon as possible by casting it to another type.</source>
          <target state="translated">別のタイプにキャストしてできるだけ早く切り取って &lt;code&gt;any&lt;/code&gt; これが起こらないようにしてください。</target>
        </trans-unit>
        <trans-unit id="d8f0896601269b7c415369db5197a7aa8c4bfad4" translate="yes" xml:space="preserve">
          <source>Primitive Types</source>
          <target state="translated">原始型</target>
        </trans-unit>
        <trans-unit id="4d1f996aa17807ebebdb5143b01f86f170d5bea6" translate="yes" xml:space="preserve">
          <source>React</source>
          <target state="translated">React</target>
        </trans-unit>
        <trans-unit id="8fbb63e06d63d6be6834fa16600e9a6203922475" translate="yes" xml:space="preserve">
          <source>React Runtimes</source>
          <target state="translated">React ランタイム</target>
        </trans-unit>
        <trans-unit id="498f09c9f4966796c2534e5801feef8ccd4eed84" translate="yes" xml:space="preserve">
          <source>React allows you to grab the instance of an element or component with &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;&lt;code&gt;ref&lt;/code&gt; functions&lt;/a&gt;. To use a ref function add a &lt;a href=&quot;https://flow.org/en/types/maybe/&quot;&gt;maybe instance type&lt;/a&gt; to your class and assign your instance to that property in your ref function.</source>
          <target state="translated">Reactでは、&lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt; &lt;code&gt;ref&lt;/code&gt; 関数を&lt;/a&gt;使用して要素またはコンポーネントのインスタンスを取得できます。ref関数を使用するには、&lt;a href=&quot;https://flow.org/en/types/maybe/&quot;&gt;多分インスタンスタイプ&lt;/a&gt;をクラスに追加し、インスタンスをref関数のそのプロパティに割り当てます。</target>
        </trans-unit>
        <trans-unit id="ce33237a4802f75e813a38036292316d4ce2343b" translate="yes" xml:space="preserve">
          <source>React allows you to pass &lt;em&gt;any&lt;/em&gt; value as the children of a React component. There are some creative uses of this capability such as using a function for children which could look like this:</source>
          <target state="translated">Reactでは、Reactコンポーネントの子として&lt;em&gt;任意の&lt;/em&gt;値を渡すことができます。この機能には、次のような子供向けの関数を使用するなど、いくつかの創造的な用途があります。</target>
        </trans-unit>
        <trans-unit id="177c1e000dc1d0316d4c2c3d73adf88cdc7bde20" translate="yes" xml:space="preserve">
          <source>React also supports default props on stateless functional components. Similarly to class components, default props for stateless functional components will work without any extra type annotations.</source>
          <target state="translated">React はステートレスな機能コンポーネントのデフォルトプロップもサポートしています。クラスコンポーネントと同様に、ステートレス機能コンポーネントのデフォルトプロップは、余分な型アノテーションなしで動作します。</target>
        </trans-unit>
        <trans-unit id="b4a8bc5b355decd0225ee33bd0badaf612842a37" translate="yes" xml:space="preserve">
          <source>React class components will be the class instance. So if you had &lt;code&gt;class Foo extends React.Component&amp;lt;{}&amp;gt; {}&lt;/code&gt; and used &lt;code&gt;React.ElementRef&amp;lt;typeof Foo&amp;gt;&lt;/code&gt; then the type would be the instance of &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">Reactクラスコンポーネントはクラスインスタンスになります。したがって、 &lt;code&gt;class Foo extends React.Component&amp;lt;{}&amp;gt; {}&lt;/code&gt; を &lt;code&gt;React.ElementRef&amp;lt;typeof Foo&amp;gt;&lt;/code&gt; 場合、タイプは &lt;code&gt;Foo&lt;/code&gt; のインスタンスになります。</target>
        </trans-unit>
        <trans-unit id="c111454a8a259a2534472c017a3802fd7ccb4ddd" translate="yes" xml:space="preserve">
          <source>React elements can have zero, one, or many children. Being able to type these children with Flow allows you to build expressive APIs with React children.</source>
          <target state="translated">React要素は、0個、1個、または多数の子を持つことができます。Flowでこれらの子をタイプできるようになると、Reactの子を使って表現力豊かなAPIを構築することができます。</target>
        </trans-unit>
        <trans-unit id="007c7fdccd509ac94dc704a539b8aed206e42677" translate="yes" xml:space="preserve">
          <source>React exports a handful of utility types that may be useful to you when typing advanced React patterns. In previous sections we have seen a few of them. The following is a complete reference for each of these types along with some examples for how/where to use them.</source>
          <target state="translated">React は、高度な React パターンを入力する際に便利なユーティリティタイプをエクスポートします。前のセクションではそのうちのいくつかを見てきました。以下に、これらのタイプの完全なリファレンスと、それらを使用する方法や場所の例を示します。</target>
        </trans-unit>
        <trans-unit id="83f2828960b3b5c2589074d8fb5ec48d203a2618" translate="yes" xml:space="preserve">
          <source>React stateless functional components do not have a backing instance and so &lt;code&gt;React.ElementRef&amp;lt;typeof Bar&amp;gt;&lt;/code&gt; (when &lt;code&gt;Bar&lt;/code&gt; is &lt;code&gt;function Bar() {}&lt;/code&gt;) will give you the undefined type.</source>
          <target state="translated">Reactステートレス機能コンポーネントにはバッキングインスタンスがないため、 &lt;code&gt;React.ElementRef&amp;lt;typeof Bar&amp;gt;&lt;/code&gt; （ &lt;code&gt;Bar&lt;/code&gt; が &lt;code&gt;function Bar() {}&lt;/code&gt; ）は未定義のタイプを提供します。</target>
        </trans-unit>
        <trans-unit id="29ed07e15fc66a324459b85d24416800bceafaa3" translate="yes" xml:space="preserve">
          <source>React supports the notion of &lt;code&gt;defaultProps&lt;/code&gt; which you can think of as default function arguments. When you create an element and you did not include a prop with a default then React will substitute that prop with its corresponding value from &lt;code&gt;defaultProps&lt;/code&gt;. Flow supports this notion as well. To type default props add a &lt;code&gt;static defaultProps&lt;/code&gt; property to your class.</source>
          <target state="translated">Reactは &lt;code&gt;defaultProps&lt;/code&gt; の概念をサポートしています。これは、デフォルトの関数引数と考えることができます。要素を作成し、デフォルトのプロップを含めなかった場合、Reactはそのプロップを &lt;code&gt;defaultProps&lt;/code&gt; の対応する値で置き換えます。Flowはこの概念もサポートしています。デフォルトの小道具を入力するには、 &lt;code&gt;static defaultProps&lt;/code&gt; プロパティをクラスに追加します。</target>
        </trans-unit>
        <trans-unit id="70287cb5f65a904f3e064a37b30a5a631627d2e6" translate="yes" xml:space="preserve">
          <source>Read more about &lt;a href=&quot;variance&quot;&gt;property variance&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;variance&quot;&gt;プロパティの分散の&lt;/a&gt;詳細をご覧ください。</target>
        </trans-unit>
        <trans-unit id="61910c412c7b58b226db5d6ed180b312f69dc750" translate="yes" xml:space="preserve">
          <source>Reassigning unsealed object properties</source>
          <target state="translated">封印されていないオブジェクトのプロパティの再割り当て</target>
        </trans-unit>
        <trans-unit id="1bf2749de445e45162652ccf38c834bf918ba1b2" translate="yes" xml:space="preserve">
          <source>Reassigning variables</source>
          <target state="translated">変数の再割り当て</target>
        </trans-unit>
        <trans-unit id="d6101a7583b060dcae14c84065094e42d98e9a54" translate="yes" xml:space="preserve">
          <source>Recall that the instance type of a function component is &lt;code&gt;void&lt;/code&gt;. Our example above wraps a component in a function, so the returned component has the instance type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">関数コンポーネントのインスタンスタイプは &lt;code&gt;void&lt;/code&gt; であることを思い出してください。上記の例では、コンポーネントを関数でラップしているため、返されるコンポーネントのインスタンスタイプは &lt;code&gt;void&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="dda31a027bfa36f4ca8585837d08aaa1912d41bf" translate="yes" xml:space="preserve">
          <source>Reducers</source>
          <target state="translated">Reducers</target>
        </trans-unit>
        <trans-unit id="1a5dd83d686967dbee491e598c66e203e42c8bea" translate="yes" xml:space="preserve">
          <source>Redux</source>
          <target state="translated">Redux</target>
        </trans-unit>
        <trans-unit id="7c12d3319cfff8593c41d6d684faf2f999524cf3" translate="yes" xml:space="preserve">
          <source>Redux state &lt;a href=&quot;http://redux.js.org/docs/introduction/ThreePrinciples.html#state-is-read-only&quot;&gt;is meant to be immutable&lt;/a&gt;: creating a new state object instead of changing properties on a single object.</source>
          <target state="translated">Redux状態&lt;a href=&quot;http://redux.js.org/docs/introduction/ThreePrinciples.html#state-is-read-only&quot;&gt;は不変であることを意味し&lt;/a&gt;ます。単一のオブジェクトのプロパティを変更するのではなく、新しい状態オブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="ed05f5c415303abb0d8305ee74bd6d2e8ce7eda3" translate="yes" xml:space="preserve">
          <source>Refinement Invalidations</source>
          <target state="translated">絞り込みの無効化</target>
        </trans-unit>
        <trans-unit id="43586e5f8885df744af66a163f9bd504927049f7" translate="yes" xml:space="preserve">
          <source>Refinement invalidation can also happen with &lt;a href=&quot;types/unions#toc-disjoint-unions&quot;&gt;disjoint unions&lt;/a&gt;. Any function call will invalidate any refinement.</source>
          <target state="translated">洗練された無効化は、&lt;a href=&quot;types/unions#toc-disjoint-unions&quot;&gt;結合されていないユニオンで&lt;/a&gt;も発生する可能性があります。関数を呼び出すと、絞り込みが無効になります。</target>
        </trans-unit>
        <trans-unit id="a02ef029699599da7905088f0dc103f214ced944" translate="yes" xml:space="preserve">
          <source>Refinements are a frequently used aspect of many type systems. They are so ingrained in the way that we program and even the way that we think you might not even notice them.</source>
          <target state="translated">改良は多くの型システムで頻繁に使用されています。これらは、私たちがプログラムを組む方法や、あなたが気づかないかもしれないと思うような方法にまで染み付いています。</target>
        </trans-unit>
        <trans-unit id="0b89cb145cee7a8457a6e4dd2a97e9f0caac7219" translate="yes" xml:space="preserve">
          <source>Refinements can also come in other forms other than testing for equality:</source>
          <target state="translated">洗練されたものは、平等性のためのテスト以外の形でもよい。</target>
        </trans-unit>
        <trans-unit id="698e6391f48381c22849ea4013ae0a7dff98a9af" translate="yes" xml:space="preserve">
          <source>Refining Maybe types</source>
          <target state="translated">洗練されたかもしれないタイプ</target>
        </trans-unit>
        <trans-unit id="9452f08c2e094961ce428c428ee0585501ce1d09" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;boolean&lt;/code&gt; and &lt;code&gt;Boolean&lt;/code&gt; are different types.</source>
          <target state="translated">&lt;code&gt;boolean&lt;/code&gt; と &lt;code&gt;Boolean&lt;/code&gt; は異なるタイプであることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="11f6d4fee5ab698ed0a3047ac64f1d9637774150" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;Number&lt;/code&gt; are different types.</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; と &lt;code&gt;Number&lt;/code&gt; は異なるタイプであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="55b41046e32661a87f2a8fd34325d7734f4d4cd1" translate="yes" xml:space="preserve">
          <source>Remember that &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;String&lt;/code&gt; are different types.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; と &lt;code&gt;String&lt;/code&gt; は異なるタイプであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">Requirements</target>
        </trans-unit>
        <trans-unit id="3d6f80999c0c50a74e8acebc121f44bdbef82ae3" translate="yes" xml:space="preserve">
          <source>Requires Flow to be installed and available on your path.</source>
          <target state="translated">Flowがインストールされている必要があり、パス上で利用できるようになります。</target>
        </trans-unit>
        <trans-unit id="33b4e56519b4614c59e8b72375bac3a885fdacaa" translate="yes" xml:space="preserve">
          <source>Requires JavaScript files to be marked with /* @flow */ at the top.</source>
          <target state="translated">JavaScript ファイルの先頭に /*@flow */を付ける必要があります。</target>
        </trans-unit>
        <trans-unit id="0a7c549205648d46b232d0e6177754a236939fcb" translate="yes" xml:space="preserve">
          <source>Requires projects containing JavaScript files to be initialised with flow init.</source>
          <target state="translated">JavaScript ファイルを含むプロジェクトが flow init で初期化される必要があります。</target>
        </trans-unit>
        <trans-unit id="3e884a460b4d82c0f0401e11f902d2d3991a0a50" translate="yes" xml:space="preserve">
          <source>Rest Parameters</source>
          <target state="translated">休息パラメータ</target>
        </trans-unit>
        <trans-unit id="7af6341ba4a77c200422ad48589bc5fcb0b569c3" translate="yes" xml:space="preserve">
          <source>Return types ensure that every branch of your function returns the same type. This prevents you from accidentally not returning a value under certain conditions.</source>
          <target state="translated">リターン型は、関数のすべてのブランチが同じ型を返すことを保証します。これにより、特定の条件下で誤って値を返さないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="686039dfdbe08da5125ed6c00f4c1399d48dfd9b" translate="yes" xml:space="preserve">
          <source>Right, the &lt;code&gt;isLeapYear&lt;/code&gt; call in &lt;code&gt;src/LookBeforeYouLeap.js&lt;/code&gt; will typecheck, since the &lt;code&gt;year&lt;/code&gt; parameter expects a &lt;code&gt;string&lt;/code&gt; in the declaration file.</source>
          <target state="translated">右、 &lt;code&gt;src/LookBeforeYouLeap.js&lt;/code&gt; の &lt;code&gt;isLeapYear&lt;/code&gt; 呼び出しはタイプチェックになります。 &lt;code&gt;year&lt;/code&gt; パラメーターは宣言ファイル内の &lt;code&gt;string&lt;/code&gt; を想定しているためです。</target>
        </trans-unit>
        <trans-unit id="67d0f5e7710e2e8d6a977594f3101bc9772e4d34" translate="yes" xml:space="preserve">
          <source>Run the Flow Background Process</source>
          <target state="translated">フローのバックグラウンドプロセスを実行する</target>
        </trans-unit>
        <trans-unit id="61ba9e06d750a8c11a8c53dbe4b159704d49a040" translate="yes" xml:space="preserve">
          <source>Run this command at the top level of your project to create one, empty file called &lt;a href=&quot;https://flow.org/en/config/&quot;&gt;&lt;code&gt;.flowconfig&lt;/code&gt;&lt;/a&gt;. At its most basic level, &lt;code&gt;.flowconfig&lt;/code&gt; tells the Flow background process the root of where to begin checking Flow code for errors.</source>
          <target state="translated">プロジェクトの最上位でこのコマンドを実行して、&lt;a href=&quot;https://flow.org/en/config/&quot;&gt; &lt;code&gt;.flowconfig&lt;/code&gt; &lt;/a&gt;という名前の空のファイルを1つ作成します。最も基本的なレベルでは、 &lt;code&gt;.flowconfig&lt;/code&gt; はフローバックグラウンドプロセスに、フローコードのエラーチェックを開始する場所のルートを指示します。</target>
        </trans-unit>
        <trans-unit id="6e373532fbaa792fe51ef4bf5789af3104a5d987" translate="yes" xml:space="preserve">
          <source>Say you have the following directory structure, with your &lt;code&gt;.flowconfig&lt;/code&gt; in &lt;code&gt;mydir&lt;/code&gt;:</source>
          <target state="translated">あなたと、あなたは次のディレクトリ構造を持っていると言う &lt;code&gt;.flowconfig&lt;/code&gt; で &lt;code&gt;mydir&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cd4baa0dfc8d959b9fb1e5d9e4810ee66a642362" translate="yes" xml:space="preserve">
          <source>Seal your intermediate results</source>
          <target state="translated">中間結果を封印する</target>
        </trans-unit>
        <trans-unit id="3bfb431a612a3027c31b75652ccf295595fa76b2" translate="yes" xml:space="preserve">
          <source>Sealed objects</source>
          <target state="translated">封印された物体</target>
        </trans-unit>
        <trans-unit id="554e5e25f0d86fc7d48da5b753f3b192e04d6a22" translate="yes" xml:space="preserve">
          <source>Second example:</source>
          <target state="translated">第二の例。</target>
        </trans-unit>
        <trans-unit id="863a42ae0f0b0630cfee6b7740c09c1edf767d9c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../utilities#toc-class&quot;&gt;here&lt;/a&gt; for details on &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt;, which allows you to refer to the type of the class in an annotation.</source>
          <target state="translated">参照してください&lt;a href=&quot;../utilities#toc-class&quot;&gt;ここで&lt;/a&gt;の詳細については、 &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; あなたは注釈でクラスの型を参照することができます。</target>
        </trans-unit>
        <trans-unit id="5437018c74686a42995bf3c86f110c73dfb010d3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://github.com/facebook/flow/issues/5725&quot;&gt;this GitHub issue for the original motivation&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebook/flow/issues/5725&quot;&gt;元の動機については、このGitHubの問題を&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="e6fc3fca1eed93ff9d9a6c2799720ebdd64e3698" translate="yes" xml:space="preserve">
          <source>See also &lt;code&gt;[untyped]&lt;/code&gt;(untyped) for not typechecking files, and instead using &lt;code&gt;any&lt;/code&gt; for all contents.</source>
          <target state="translated">ファイルのタイプチェックを行わず、代わりにすべてのコンテンツに &lt;code&gt;any&lt;/code&gt; を使用する場合は、 &lt;code&gt;[untyped]&lt;/code&gt; （untyped）も参照してください。</target>
        </trans-unit>
        <trans-unit id="d10cc1add2564282fb8d240521737d52d850d2d5" translate="yes" xml:space="preserve">
          <source>See how we added &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;SomeOtherComponent&amp;gt;&lt;/code&gt; as children to &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt;? This is not allowed and &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; will throw an error. How do we make sure Flow does not allow this pattern?</source>
          <target state="translated">我々は追加する方法を参照してください &lt;code&gt;&amp;lt;View&amp;gt;&lt;/code&gt; と &lt;code&gt;&amp;lt;SomeOtherComponent&amp;gt;&lt;/code&gt; などの子どもへの &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; ？これは許可されておらず、 &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; はエラーをスローします。 Flowがこのパターンを許可しないことをどのように確認しますか？</target>
        </trans-unit>
        <trans-unit id="f741f4c166b4ccd4d41f13a13dece778f73df85a" translate="yes" xml:space="preserve">
          <source>Select &amp;lsquo;Flow for Sublime Text 2 and 3&amp;rsquo; to install</source>
          <target state="translated">インストールする「崇高なテキスト2および3のフロー」を選択します</target>
        </trans-unit>
        <trans-unit id="e6b4c56f97df36a6ecd6ed02f0d6868208b5ab27" translate="yes" xml:space="preserve">
          <source>Select Package Control: Install Package</source>
          <target state="translated">パッケージコントロールを選択します。パッケージのインストール</target>
        </trans-unit>
        <trans-unit id="8d4e3440a48420d6cf0f3379e89fee66456a0ae3" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;automatic&lt;/code&gt; if you are using React&amp;rsquo;s automatic runtime in &lt;code&gt;@babel/plugin-transform-react-jsx&lt;/code&gt;. Otherwise, use &lt;code&gt;classic&lt;/code&gt;. &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx&quot;&gt;See the babel documentation&lt;/a&gt; for details about the transform.</source>
          <target state="translated">&lt;code&gt;@babel/plugin-transform-react-jsx&lt;/code&gt; Reactの自動ランタイムを使用している場合は、これを &lt;code&gt;automatic&lt;/code&gt; 設定します。それ以外の場合は、 &lt;code&gt;classic&lt;/code&gt; 使用します。変換の詳細については&lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-react-jsx&quot;&gt;、babelのドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5a51c55e03c6fe62b671bf2a091c73c068704caf" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;enable&lt;/code&gt; to indicate that Flow should support the &lt;code&gt;export * as&lt;/code&gt; syntax from &lt;a href=&quot;https://github.com/leebyron/ecmascript-more-export-from&quot;&gt;leebyron&amp;rsquo;s proposal&lt;/a&gt;.</source>
          <target state="translated">これを &lt;code&gt;enable&lt;/code&gt; に設定して、Flowが&lt;a href=&quot;https://github.com/leebyron/ecmascript-more-export-from&quot;&gt;leebyronの提案&lt;/a&gt;からの構文 &lt;code&gt;export * as&lt;/code&gt; 構文をサポートする必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="d2f2f8212166435e1e26351a8d0075e389cfc197" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;enable&lt;/code&gt; to indicate that Flow should support the use of &lt;a href=&quot;https://github.com/tc39/proposal-nullish-coalescing&quot;&gt;nullish coalescing&lt;/a&gt; per the pending spec.</source>
          <target state="translated">これを &lt;code&gt;enable&lt;/code&gt; に設定して、フローが保留中の仕様に従って&lt;a href=&quot;https://github.com/tc39/proposal-nullish-coalescing&quot;&gt;無効な合体&lt;/a&gt;の使用をサポートする必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="5ffd0d476596e4beacfa43c710cc9eca05a02fef" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;enable&lt;/code&gt; to indicate that Flow should support the use of &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining&quot;&gt;optional chaining&lt;/a&gt; per the pending spec.</source>
          <target state="translated">これを &lt;code&gt;enable&lt;/code&gt; に設定して、フローが保留中の仕様に従って&lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining&quot;&gt;オプションのチェーン&lt;/a&gt;の使用をサポートする必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="a791224e1e0c6173296867136f2701fa594c4db9" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should ignore decorators.</source>
          <target state="translated">これを &lt;code&gt;ignore&lt;/code&gt; に設定して、フローがデコレーターを無視することを示します。</target>
        </trans-unit>
        <trans-unit id="7252ab4a3a45b3b2cf1e24f49aebbbc8df2bea70" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; and Flow will no longer complain when you use &lt;code&gt;require()&lt;/code&gt; with something other than a string literal.</source>
          <target state="translated">これを &lt;code&gt;true&lt;/code&gt; に設定する &lt;code&gt;require()&lt;/code&gt; 、文字列リテラル以外のものでrequire（）を使用してもFlowは文句を言わなくなります。</target>
        </trans-unit>
        <trans-unit id="17b19723fab321f07b8d03e9886bc4fd290afff7" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; if you use a transpiler that adds &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; to the top of every module.</source>
          <target state="translated">&lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; を追加するトランスパイラーを使用する場合は、これを &lt;code&gt;true&lt;/code&gt; に設定します。すべてのモジュールの先頭に。</target>
        </trans-unit>
        <trans-unit id="8f7810533f5b1afdbd99345ceeeb8bb80fe383b5" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to add emoji to the status messages that Flow outputs when it&amp;rsquo;s busy checking your project.</source>
          <target state="translated">これを &lt;code&gt;true&lt;/code&gt; に設定して、プロジェクトのチェックでビジー状態のときにFlowが出力するステータスメッセージに絵文字を追加します。</target>
        </trans-unit>
        <trans-unit id="0a9e20b6f9ef8f6259569858fa3254651f50988f" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to check all files, not just those with &lt;code&gt;@flow&lt;/code&gt;.</source>
          <target state="translated">これを &lt;code&gt;true&lt;/code&gt; に設定すると、 &lt;code&gt;@flow&lt;/code&gt; のファイルだけでなく、すべてのファイルがチェックされます。</target>
        </trans-unit>
        <trans-unit id="d2763696664697d56a9bd55ceed56c975dbfc607" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to check that array spread syntax is only used with arrays, not arbitrary iterables (such as &lt;code&gt;Map&lt;/code&gt; or &lt;code&gt;Set&lt;/code&gt;). This is useful if you transform your code with Babel in &lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-spread#loose&quot;&gt;loose mode&lt;/a&gt; which makes this non-spec-compliant assumption at runtime.</source>
          <target state="translated">これを &lt;code&gt;true&lt;/code&gt; に設定して、配列スプレッド構文が配列でのみ使用され、任意の反復可能オブジェクト（ &lt;code&gt;Map&lt;/code&gt; や &lt;code&gt;Set&lt;/code&gt; など）ではないことを確認します。これは、実行時にこの非仕様に準拠した仮定を行う&lt;a href=&quot;https://babeljs.io/docs/en/babel-plugin-transform-spread#loose&quot;&gt;ルーズモード&lt;/a&gt;でBabelを使用してコードを変換する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="632e3852195a2720cf86c3695ec9f34205f83f66" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to have Flow treat underscore-prefixed class properties and methods as private. This should be used in conjunction with &lt;a href=&quot;https://github.com/facebook/jstransform/blob/master/visitors/es6-class-visitors.js&quot;&gt;&lt;code&gt;jstransform&lt;/code&gt;&amp;rsquo;s ES6 class transform&lt;/a&gt;, which enforces the same privacy at runtime.</source>
          <target state="translated">これを &lt;code&gt;true&lt;/code&gt; に設定すると、フローでアンダースコアが前に付けられたクラスのプロパティとメソッドがプライベートとして扱われます。これは、実行時に同じプライバシーを&lt;a href=&quot;https://github.com/facebook/jstransform/blob/master/visitors/es6-class-visitors.js&quot;&gt; &lt;code&gt;jstransform&lt;/code&gt; &lt;/a&gt;するjstransformのES6クラス変換と組み合わせて使用​​する必要があります。</target>
        </trans-unit>
        <trans-unit id="c35c47e5290b31d5376f35f006e7cd6e182798e4" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; to indicate that Flow should interpret object types as exact by default. When this flag is &lt;code&gt;false&lt;/code&gt;, Flow has the following behavior:</source>
          <target state="translated">これを &lt;code&gt;true&lt;/code&gt; に設定すると、フローがオブジェクトタイプをデフォルトで正確に解釈する必要があることを示します。このフラグが &lt;code&gt;false&lt;/code&gt; の場合、フローは次のように動作します。</target>
        </trans-unit>
        <trans-unit id="0b6026d788e6990fc2b88f5d97a8a7e72d548d84" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;warn&lt;/code&gt; to indicate that Flow should give a warning on use of instance &lt;a href=&quot;https://github.com/tc39/proposal-class-public-fields&quot;&gt;class fields&lt;/a&gt; per the pending spec.</source>
          <target state="translated">これを &lt;code&gt;warn&lt;/code&gt; に設定して、フローが保留中の仕様に従ってインスタンス&lt;a href=&quot;https://github.com/tc39/proposal-class-public-fields&quot;&gt;クラスフィールドの&lt;/a&gt;使用について警告を出す必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="5a95e4b769085b845d2cd025dba547c259b83a10" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;warn&lt;/code&gt; to indicate that Flow should give a warning on use of static &lt;a href=&quot;https://github.com/tc39/proposal-class-public-fields&quot;&gt;class fields&lt;/a&gt; per the pending spec.</source>
          <target state="translated">これを &lt;code&gt;warn&lt;/code&gt; に設定して、フローが保留中の仕様に従って静的&lt;a href=&quot;https://github.com/tc39/proposal-class-public-fields&quot;&gt;クラスフィールドの&lt;/a&gt;使用について警告を出す必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="3723576f1e23f9a6be80dfc2da353444ecba4fa5" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;lazy_mode&lt;/code&gt; in the &lt;code&gt;.flowconfig&lt;/code&gt; will cause new Flow servers for that root to use that lazy mode (or no lazy mode if set to &lt;code&gt;none&lt;/code&gt;). This option can be overridden from the CLI using the &lt;code&gt;--lazy-mode&lt;/code&gt; flag.</source>
          <target state="translated">設定 &lt;code&gt;lazy_mode&lt;/code&gt; の中 &lt;code&gt;.flowconfig&lt;/code&gt; はその怠惰モード（または全くレイジー・モードに設定されている場合は、使用すること根のための新しいフローのサーバーの原因になります &lt;code&gt;none&lt;/code&gt; ）。このオプションは、 &lt;code&gt;--lazy-mode&lt;/code&gt; フラグを使用してCLIからオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="f8742e5ede9ca0ab99281256cb0a8da2b2abf5c7" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;sketchy-null&lt;/code&gt; sets the level for all sketchy null checks, but there are more granular rules for particular types. These are:</source>
          <target state="translated">設定 &lt;code&gt;sketchy-null&lt;/code&gt; すべて不完全ヌルチェックのレベルを設定するが、特定のタイプのより詳細なルールがあります。これらは：</target>
        </trans-unit>
        <trans-unit id="4dbac04babde4f94fd1324574fc30f6647291c38" translate="yes" xml:space="preserve">
          <source>Setting this option to X means the table will support up to 2^X elements, which is 16*2^X bytes.</source>
          <target state="translated">このオプションをXに設定すると、テーブルは最大2^X要素、つまり16*2^Xバイトをサポートすることになります。</target>
        </trans-unit>
        <trans-unit id="6f8b6166467119123c34cb8d2a8307f8f72ae96e" translate="yes" xml:space="preserve">
          <source>Setting this to 1 will cause Flow to output some stats about the data that is serialized into and deserialized out of shared memory.</source>
          <target state="translated">これを1に設定すると、共有メモリにシリアル化されたデータと、共有メモリからシリアル化されたデータに関する統計情報が出力されます。</target>
        </trans-unit>
        <trans-unit id="3907024420fe6565a297982966b2459dd6dc6639" translate="yes" xml:space="preserve">
          <source>Setting this to &lt;code&gt;true&lt;/code&gt; makes Flow commands include warnings in the error output. Warnings are hidden by default in the CLI to avoid console spew. (An IDE is a much better interface to show warnings.)</source>
          <target state="translated">これを &lt;code&gt;true&lt;/code&gt; に設定すると、フローコマンドはエラー出力に警告を含めます。コンソールスピューを回避するために、警告はデフォルトでCLIに表示されません。（IDEは、警告を表示するためのはるかに優れたインターフェースです。）</target>
        </trans-unit>
        <trans-unit id="a78591e430fc75d428e63794ccb099ae8c20961b" translate="yes" xml:space="preserve">
          <source>Setting this to &lt;code&gt;true&lt;/code&gt; makes Flow treat all function parameters as const bindings. Reassigning a param is an error which lets Flow be less conservative with refinements.</source>
          <target state="translated">これを &lt;code&gt;true&lt;/code&gt; に設定すると、フローはすべての関数パラメーターをconstバインディングとして扱います。paramの再割り当てはエラーであり、これにより、Flowが改良されて保守的でなくなります。</target>
        </trans-unit>
        <trans-unit id="c2da3d4ed1af623cc4e8b8d52d8edb981c85d346" translate="yes" xml:space="preserve">
          <source>Setting up &amp;ldquo;boundaries&amp;rdquo; with your types means you can tell Flow your intent on top of the inference it already does.</source>
          <target state="translated">タイプで「境界」を設定すると、フローがすでに行っている推論に加えて、フローに意図を伝えることができます。</target>
        </trans-unit>
        <trans-unit id="cdd7bb2816b7a8f88bce0e47be39943bc369516b" translate="yes" xml:space="preserve">
          <source>Setup</source>
          <target state="translated">Setup</target>
        </trans-unit>
        <trans-unit id="7133d91a35c40bcb71979c3896fc1deb038a8a20" translate="yes" xml:space="preserve">
          <source>Setup Flow with React</source>
          <target state="translated">Reactを使った設定フロー</target>
        </trans-unit>
        <trans-unit id="7330bdb6aab9d47b6f4302ca23a0b1d1a997ea7d" translate="yes" xml:space="preserve">
          <source>Severity Levels and Meanings</source>
          <target state="translated">重大度レベルとその意味</target>
        </trans-unit>
        <trans-unit id="9ef912b88879662392f8c53fad059d3c74586282" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#toc-react-componenttype&quot;&gt;&lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt;&lt;/a&gt; except it also includes JSX intrinsics (strings).</source>
          <target state="translated">&lt;a href=&quot;#toc-react-componenttype&quot;&gt; &lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; &lt;/a&gt;似ていますが、JSX組み込み（文字列）も含まれています。</target>
        </trans-unit>
        <trans-unit id="ad9df7675219090b45a68675090f8c88c2996d47" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;../utilities#toc-readonly&quot;&gt;&lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, it is the supertype of all arrays and all tuples and represents a read-only view of an array. It does not contain any methods that will allow an object of this type to be mutated (no &lt;code&gt;push()&lt;/code&gt;, &lt;code&gt;pop()&lt;/code&gt;, etc.).</source>
          <target state="translated">&lt;a href=&quot;../utilities#toc-readonly&quot;&gt; &lt;code&gt;$ReadOnly&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;と同様に、すべての配列とすべてのタプルのスーパータイプであり、配列の読み取り専用ビューを表します。このタイプのオブジェクトを変更できるようにするメソッドは含まれていません（ &lt;code&gt;push()&lt;/code&gt; 、 &lt;code&gt;pop()&lt;/code&gt; などは不可）。</target>
        </trans-unit>
        <trans-unit id="7e25832c7fbfc04c711346a40af98680a99ba4e4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;../variables#toc-reassigning-variables&quot;&gt;&lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; variables&lt;/a&gt; if you reassign a property of an unsealed object, by default Flow will give it the type of all possible assignments.</source>
          <target state="translated">&lt;a href=&quot;../variables#toc-reassigning-variables&quot;&gt; &lt;code&gt;var&lt;/code&gt; および &lt;code&gt;let&lt;/code&gt; 変数と&lt;/a&gt;同様に、封印されていないオブジェクトのプロパティを再割り当てする場合、デフォルトでは、Flowはすべての可能な割り当てのタイプを提供します。</target>
        </trans-unit>
        <trans-unit id="8ccc6ec56ed0f7579fe7c1219285baf1e414f25d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;const&lt;/code&gt;, Flow can either infer the type from the value you are assigning to it or you can provide it with a type:</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; と同様に、Flowは、割り当てている値から型を推測するか、型を提供できます。</target>
        </trans-unit>
        <trans-unit id="31cdc6274e2048217641f19c7436522e7c83902e" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;mixed&lt;/code&gt;, generics have an &amp;ldquo;unknown&amp;rdquo; type. You&amp;rsquo;re not allowed to use a generic as if it were a specific type.</source>
          <target state="translated">&lt;code&gt;mixed&lt;/code&gt; と同様に、ジェネリックには「不明な」タイプがあります。ジェネリックを特定のタイプであるかのように使用することはできません。</target>
        </trans-unit>
        <trans-unit id="6f53a1bfd2499be63c34f7067d2986e44abdec95" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;var&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; can be re-assigned, there&amp;rsquo;s a few more rules you&amp;rsquo;ll need to know about.</source>
          <target state="translated">以来 &lt;code&gt;var&lt;/code&gt; と &lt;code&gt;let&lt;/code&gt; 再割り当てすることができ、あなたが知っておく必要がありますより多くのいくつかのルールがあります。</target>
        </trans-unit>
        <trans-unit id="339082925233909f355d06179fa3b6b26ccf7865" translate="yes" xml:space="preserve">
          <source>Since Flow does not know the length of an array, an &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; type cannot be passed into a tuple.</source>
          <target state="translated">Flowは配列の長さを認識しないため、 &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; タイプをタプルに渡すことはできません。</target>
        </trans-unit>
        <trans-unit id="decf7e18c6fe06fc86a8a5bc89a669829d507c85" translate="yes" xml:space="preserve">
          <source>Since a &lt;code&gt;const&lt;/code&gt; variable cannot be re-assigned at a later time it is fairly simple.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 変数は後で再割り当てできないため、かなり簡単です。</target>
        </trans-unit>
        <trans-unit id="8c614b00ece097ea225988eb96c38c1dc27bdcf2" translate="yes" xml:space="preserve">
          <source>Since the parameter &lt;code&gt;arr&lt;/code&gt; of the &lt;code&gt;someOperation&lt;/code&gt; function is typed as a mutable &lt;code&gt;Array&lt;/code&gt;, pushing a string into it would be possible inside that scope, which would then break the type contract of the outside &lt;code&gt;array&lt;/code&gt; variable. By annotating the parameter as &lt;code&gt;$ReadOnlyArray&lt;/code&gt; instead in this case, Flow can be sure this won&amp;rsquo;t happen and no errors will occur:</source>
          <target state="translated">&lt;code&gt;someOperation&lt;/code&gt; 関数のパラメーター &lt;code&gt;arr&lt;/code&gt; は変更可能な &lt;code&gt;Array&lt;/code&gt; として型付けされるため、そのスコープ内で文字列をプッシュすることは可能であり、その場合、外側の &lt;code&gt;array&lt;/code&gt; 変数の型コントラクトが壊れます。この場合、代わりに &lt;code&gt;$ReadOnlyArray&lt;/code&gt; としてパラメーターに注釈を付けることで、フローはこれが発生せず、エラーが発生しないことを確認できます。</target>
        </trans-unit>
        <trans-unit id="a1785a5e0b243285a1963526da42f273c5dc42f7" translate="yes" xml:space="preserve">
          <source>So a single array child is left alone, but what happens if we have multiple children that are arrays?</source>
          <target state="translated">では、1つの配列の子はそのままにしておきますが、配列である子が複数ある場合はどうなるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="a70bd7a3ca7dbd388181ff69fc1a9d9059244ca3" translate="yes" xml:space="preserve">
          <source>So far, we support the following ways to specify supported versions</source>
          <target state="translated">これまでのところ、サポートされているバージョンを指定する方法は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="64c91e3d58f11315a8f98d01485d70281a6c3678" translate="yes" xml:space="preserve">
          <source>So if Flow sees this in the &lt;code&gt;.flowconfig&lt;/code&gt;:</source>
          <target state="translated">したがって、Flowが &lt;code&gt;.flowconfig&lt;/code&gt; でこれを確認した場合：</target>
        </trans-unit>
        <trans-unit id="9eb921ba09ace5711e414821fe52adee56f0c3ff" translate="yes" xml:space="preserve">
          <source>So if I write a function that expects the numbers 1 through 5, any subtype of that set will be acceptable.</source>
          <target state="translated">ですから、1から5までの数を期待して関数を書けば、その集合のどのサブタイプも許容されます。</target>
        </trans-unit>
        <trans-unit id="0e8b161db695089b318d824534a1f60ea4c81045" translate="yes" xml:space="preserve">
          <source>So if you have the following in your &lt;code&gt;.flowconfig&lt;/code&gt;:</source>
          <target state="translated">したがって、 &lt;code&gt;.flowconfig&lt;/code&gt; に次のものが含まれている場合：</target>
        </trans-unit>
        <trans-unit id="85f50aa3f8aa1b205c54f2530dfd25375a26cc15" translate="yes" xml:space="preserve">
          <source>So in the following example, &lt;code&gt;obj2&lt;/code&gt; is a &lt;em&gt;subtype&lt;/em&gt; of &lt;code&gt;obj1&lt;/code&gt;.</source>
          <target state="translated">したがって、次の例では、 &lt;code&gt;obj2&lt;/code&gt; は &lt;code&gt;obj1&lt;/code&gt; の&lt;em&gt;サブタイプ&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="bd21dd92e8bb38520c7aed585ce5c138a49e1e9e" translate="yes" xml:space="preserve">
          <source>So, for example, if you want to know more about how the autocomplete works, you can use this command:</source>
          <target state="translated">そのため、例えばオートコンプリートの仕組みをもっと詳しく知りたい場合は、このコマンドを使うといいでしょう。</target>
        </trans-unit>
        <trans-unit id="32f718b68766575b95119fe1d6ed7b79b6857e82" translate="yes" xml:space="preserve">
          <source>Some examples of suppression comments:</source>
          <target state="translated">抑圧コメントの例をいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="6a5040bb6c58acac2d87c681ffa0099ee5ad8294" translate="yes" xml:space="preserve">
          <source>Sometimes Flow is able to figure out (with certainty) the type of a property after reassignment. In that case, Flow will give it the known type.</source>
          <target state="translated">場合によっては、Flowは、再割り当て後のプロパティの型を(確実に)把握することができる。その場合、Flowは、既知の型をそれに与える。</target>
        </trans-unit>
        <trans-unit id="8cbd2e30f0fd2935872139edbe248c42b74f633b" translate="yes" xml:space="preserve">
          <source>Sometimes Flow is able to figure out (with certainty) the type of a variable after re-assignment. In that case, Flow will give it the known type.</source>
          <target state="translated">場合によっては、再割り当て後にFlowが変数の型を(確実に)把握できることがある。その場合、Flowは既知の型をそれに与えます。</target>
        </trans-unit>
        <trans-unit id="190aedcaebf30683452cc18021384bd29eb893ec" translate="yes" xml:space="preserve">
          <source>Sometimes Flow&amp;rsquo;s inference will create types that are more permissive than you want them to be.</source>
          <target state="translated">時々、フローの推論は、あなたが望むよりも寛容なタイプを作成します。</target>
        </trans-unit>
        <trans-unit id="bf2bc69b7d682ca6d088a661a2cccdb41226e95b" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to assert a type without using something like a function or a variable to do so. For this Flow supports an inline type cast expression syntax which can be used in a number of different ways.</source>
          <target state="translated">時には、関数や変数のようなものを使わずに型をアサートしたい場合があります。このため、Flowはインライン型キャスト式構文をサポートしており、様々な方法で使用することができます。</target>
        </trans-unit>
        <trans-unit id="05acde073f433e3ebdb05840c280af6194f4f161" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to create a type which is &lt;strong&gt;&lt;em&gt;all of&lt;/em&gt;&lt;/strong&gt; a set of other types. For example, you might want to write a function which accepts an object which is the combination of other object types. For this, Flow supports &lt;strong&gt;intersection types&lt;/strong&gt;.</source>
          <target state="translated">他のタイプのセットの&lt;strong&gt;&lt;em&gt;すべてで&lt;/em&gt;&lt;/strong&gt;あるタイプを作成すると便利な場合があります。たとえば、他のオブジェクトタイプの組み合わせであるオブジェクトを受け入れる関数を記述したい場合があります。このため、Flowは&lt;strong&gt;交差タイプを&lt;/strong&gt;サポートしてい&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="508d0f1b6949c54ce48ed8515843765f74b1ff2c" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to disable this behavior and only allow a specific set of properties. For this, Flow supports &amp;ldquo;exact&amp;rdquo; object types.</source>
          <target state="translated">この動作を無効にし、特定のプロパティセットのみを許可すると便利な場合があります。このため、フローは「正確な」オブジェクトタイプをサポートします。</target>
        </trans-unit>
        <trans-unit id="7e197db0c5e7c34ea4bc888687f7a0d82f7f2217" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to make declarations inline, as part of the source of an implementation file.</source>
          <target state="translated">実装ファイルのソースの一部としてインラインで宣言を行うことが便利な場合もあります。</target>
        </trans-unit>
        <trans-unit id="4b7f2e42ec427dfe19e7546bbfa4cb1df144aec0" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to write types that accept arbitrary functions, for those you should write &lt;code&gt;() =&amp;gt; mixed&lt;/code&gt; like this:</source>
          <target state="translated">次のように &lt;code&gt;() =&amp;gt; mixed&lt;/code&gt; 書く必要がある場合は、任意の関数を受け入れる型を記述すると便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="0d699df94c70d270a74922c6dd7a75522ca1022c" translate="yes" xml:space="preserve">
          <source>Sometimes it is useful to write types that accept arbitrary objects, for those you should write &lt;code&gt;{}&lt;/code&gt; like this:</source>
          <target state="translated">次のように &lt;code&gt;{}&lt;/code&gt; を記述する必要がある場合は、任意のオブジェクトを受け入れる型を記述すると便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="48c4be69fd7d7e116bfe9fff8287e72150b14b65" translate="yes" xml:space="preserve">
          <source>Sometimes it&amp;rsquo;s useful to create a type which is &lt;strong&gt;&lt;em&gt;one of&lt;/em&gt;&lt;/strong&gt; a set of other types. For example, you might want to write a function which accepts a set of primitive value types. For this Flow supports &lt;strong&gt;union types&lt;/strong&gt;.</source>
          <target state="translated">他のタイプのセットの&lt;strong&gt;&lt;em&gt;1つで&lt;/em&gt;&lt;/strong&gt;あるタイプを作成すると便利な場合があります。たとえば、一連のプリミティブ値タイプを受け入れる関数を記述したい場合があります。このフローでは、&lt;strong&gt;共用体タイプを&lt;/strong&gt;サポートしてい&lt;strong&gt;ます&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="56e08cb76776b6d22c74c00289b74deb8fcafaba" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to ignore all files inside a directory with the exception of a few. An optional prefix &amp;ldquo;!&amp;rdquo; which negates the pattern may help. With this, any matching file excluded by a previous pattern will become included again.</source>
          <target state="translated">一部のファイルを除いて、ディレクトリ内のすべてのファイルを無視したい場合があります。オプションのプレフィックス「！」パターンを否定することが役立つかもしれません。これにより、前のパターンで除外された一致するファイルが再び含まれるようになります。</target>
        </trans-unit>
        <trans-unit id="079287524f7de17d8166e352d620ee09cbcee756" translate="yes" xml:space="preserve">
          <source>Sometimes you only want a specific component as the children to your React component. This often happens when you are building a table component which needs specific column children components, or a tab bar which needs specific configuration for each tab. One such tab bar component that uses this pattern is React Native&amp;rsquo;s &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">Reactコンポーネントの子として特定のコンポーネントのみが必要な場合があります。これは、特定の列の子コンポーネントを必要とするテーブルコンポーネント、または各タブの特定の構成を必要とするタブバーを構築しているときによく発生します。このパターンを使用するそのようなタブバーコンポーネントの1つは、React Nativeの &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; コンポーネントです。</target>
        </trans-unit>
        <trans-unit id="0ca3345128fc09227a3fc76aff4497f80cecc7db" translate="yes" xml:space="preserve">
          <source>Sometimes you want to enforce that your component will &lt;em&gt;only&lt;/em&gt; receive a single child. You could use &lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children.only&quot;&gt;&lt;code&gt;React.Children.only()&lt;/code&gt; function&lt;/a&gt; to enforce this constraint, but you could also enforce this in Flow. To do this you would not wrap the type for your children in &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. Like so:</source>
          <target state="translated">コンポーネントが単一の子&lt;em&gt;のみを&lt;/em&gt;受け取るように強制したい場合があります。&lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children.only&quot;&gt; &lt;code&gt;React.Children.only()&lt;/code&gt; 関数&lt;/a&gt;を使用してこの制約を強制できますが、フローで強制することもできます。これを行うには、&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;子の型をラップしないでください。そのようです：</target>
        </trans-unit>
        <trans-unit id="9c3a1440695c1cfe2882e899cdcec139639bb34e" translate="yes" xml:space="preserve">
          <source>Sometimes you want to enforce that your component will &lt;em&gt;only&lt;/em&gt; receive a single child. You could use &lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children.only&quot;&gt;&lt;code&gt;React.Children.only()&lt;/code&gt; function&lt;/a&gt; to enforce this constraint, but you could also enforce this in Flow. To do this, instead of wrapping the type for your children in &lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;, specify a single element argument, like so:</source>
          <target state="translated">コンポーネントが1つの子&lt;em&gt;のみを&lt;/em&gt;受け取るように強制したい場合があります。&lt;a href=&quot;https://facebook.github.io/react/docs/react-api.html#react.children.only&quot;&gt; &lt;code&gt;React.Children.only()&lt;/code&gt; 関数&lt;/a&gt;を使用してこの制約を適用できますが、フローでこれを適用することもできます。これを行うには、&lt;a href=&quot;../types#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;で子の型をラップする代わりに、次のように単一の要素引数を指定します。</target>
        </trans-unit>
        <trans-unit id="0204e6779dafad940b69a188f3ba177a640b8f57" translate="yes" xml:space="preserve">
          <source>Sometimes you will want to move the condition from an &lt;code&gt;if&lt;/code&gt; statement into a function:</source>
          <target state="translated">条件を &lt;code&gt;if&lt;/code&gt; ステートメントから関数に移動したい場合があります。</target>
        </trans-unit>
        <trans-unit id="e54a11047f43ee69df389e7749159027d890696d" translate="yes" xml:space="preserve">
          <source>Soundness and Completeness</source>
          <target state="translated">健全性と完全性</target>
        </trans-unit>
        <trans-unit id="746df4e9e7a562d767f5e24a05664f4a720c7f81" translate="yes" xml:space="preserve">
          <source>Soundness is fine as long as Flow isn&amp;rsquo;t being too noisy and preventing you from being productive. Sometimes when soundness would get in your way too much, Flow will favor completeness instead. There&amp;rsquo;s only a handful of cases where Flow does this.</source>
          <target state="translated">Flowのノイズが多すぎず、生産性が妨げられない限り、健全性は問題ありません。場合によっては、健全性が邪魔になりすぎると、Flowは完全性を優先します。Flowがこれを行うケースはほんの一握りです。</target>
        </trans-unit>
        <trans-unit id="0490059ec84f1bbf6b567a4e9c26b3a680460a91" translate="yes" xml:space="preserve">
          <source>Specify a file extension to match, and a replacement module name, separated by a &lt;code&gt;-&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">一致するファイル拡張子と、 &lt;code&gt;-&amp;gt;&lt;/code&gt; で区切られた置換モジュール名を指定します。</target>
        </trans-unit>
        <trans-unit id="c23f789b3f6c7eff8cfdc73ee793e9e6cd434ab2" translate="yes" xml:space="preserve">
          <source>Specify a regular expression to match against module names, and a replacement pattern, separated by a &lt;code&gt;-&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">モジュール名と照合する正規表現、および &lt;code&gt;-&amp;gt;&lt;/code&gt; で区切られた置換パターンを指定します。</target>
        </trans-unit>
        <trans-unit id="2d2cb022bc3d26bd1407c4aa787d5e46e1ad4c3b" translate="yes" xml:space="preserve">
          <source>Speed</source>
          <target state="translated">Speed</target>
        </trans-unit>
        <trans-unit id="3b2886d5473db8f2728b89b52d94f9b866760285" translate="yes" xml:space="preserve">
          <source>Start the &lt;a href=&quot;#toc-run-the-flow-background-process&quot;&gt;Flow background process&lt;/a&gt; with &lt;code&gt;flow&lt;/code&gt;.</source>
          <target state="translated">開始&lt;a href=&quot;#toc-run-the-flow-background-process&quot;&gt;フローバックグラウンド・プロセス&lt;/a&gt;との &lt;code&gt;flow&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33040dda5793f74572e67f14abdfb073ecb04f28" translate="yes" xml:space="preserve">
          <source>Starting with Flow v0.23.0, you may use the &lt;code&gt;&amp;lt;PROJECT_ROOT&amp;gt;&lt;/code&gt; placeholder in your regular expressions. At runtime, Flow will treat the placeholder as if it were the absolute path to the project&amp;rsquo;s root directory. This is useful for writing regular expressions that are relative rather than absolute.</source>
          <target state="translated">Flow v0.23.0以降、正規表現で &lt;code&gt;&amp;lt;PROJECT_ROOT&amp;gt;&lt;/code&gt; プレースホルダーを使用できます。実行時に、Flowはプレースホルダーをプロジェクトのルートディレクトリへの絶対パスであるかのように扱います。これは、絶対ではなく相対である正規表現を書くのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="a72502067518684f9deeec70cf119fd26326cd33" translate="yes" xml:space="preserve">
          <source>State</source>
          <target state="translated">State</target>
        </trans-unit>
        <trans-unit id="62b1fce124c3fa807ff7f42885010e1fc39fe39d" translate="yes" xml:space="preserve">
          <source>Stateless Functional Components</source>
          <target state="translated">ステートレス機能部品</target>
        </trans-unit>
        <trans-unit id="2f0b1209b659172e1b117e95bf918d52ef746c97" translate="yes" xml:space="preserve">
          <source>Statements manipulating &lt;code&gt;module.exports&lt;/code&gt; and the &lt;code&gt;exports&lt;/code&gt; alias may only appear as top-level statements.</source>
          <target state="translated">&lt;code&gt;module.exports&lt;/code&gt; および &lt;code&gt;exports&lt;/code&gt; エイリアスを操作するステートメントは、トップレベルのステートメントとしてのみ表示される場合があります。</target>
        </trans-unit>
        <trans-unit id="8ab6b0ce50387fe5c38a665805e317164318c6cd" translate="yes" xml:space="preserve">
          <source>Strict Local</source>
          <target state="translated">厳格なローカル</target>
        </trans-unit>
        <trans-unit id="984e1a2ea44698c9bc621d3cc2a46a2ebbfcffdb" translate="yes" xml:space="preserve">
          <source>Strictly enforced tuple length (arity)</source>
          <target state="translated">厳密にはタプルの長さ(アリティ)を指定します。</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="b5c84f808b85754e46cef96360cc97ceca30a211" translate="yes" xml:space="preserve">
          <source>Strings are &lt;code&gt;&quot;foo&quot;&lt;/code&gt; values in JavaScript. The &lt;code&gt;string&lt;/code&gt; type in Flow accepts these values.</source>
          <target state="translated">文字列は、JavaScriptの &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 値です。フローの &lt;code&gt;string&lt;/code&gt; タイプはこれらの値を受け入れます。</target>
        </trans-unit>
        <trans-unit id="371de9693f4209b3d6baabc8cf5aa9bd9123f714" translate="yes" xml:space="preserve">
          <source>Strings: like &lt;code&gt;&quot;foo&quot;&lt;/code&gt; or &lt;code&gt;&quot;bar&quot;&lt;/code&gt;</source>
          <target state="translated">文字列： &lt;code&gt;&quot;foo&quot;&lt;/code&gt; や &lt;code&gt;&quot;bar&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fad0aefa729b2e3f757e7d3a4090cd9f7990d889" translate="yes" xml:space="preserve">
          <source>Structural typing</source>
          <target state="translated">構造的なタイピング</target>
        </trans-unit>
        <trans-unit id="9ce6ba148fe8d9ab4a1efa44f043d11727e7f6ee" translate="yes" xml:space="preserve">
          <source>Sublime Text</source>
          <target state="translated">崇高なテキスト</target>
        </trans-unit>
        <trans-unit id="d14ac23dd85e9a8386862e11638c030009ce4084" translate="yes" xml:space="preserve">
          <source>SublimeLinter-flow</source>
          <target state="translated">SublimeLinter-flow</target>
        </trans-unit>
        <trans-unit id="3f018ae5c81afd7ff03157c258e75546aee33dc2" translate="yes" xml:space="preserve">
          <source>Subsets &amp;amp; Subtypes</source>
          <target state="translated">サブセットとサブタイプ</target>
        </trans-unit>
        <trans-unit id="6cdd77a39c406add3dd649d12b90f08405e31a63" translate="yes" xml:space="preserve">
          <source>Subtypes of complex types</source>
          <target state="translated">複合型のサブタイプ</target>
        </trans-unit>
        <trans-unit id="9d06116efdf07868027a1561d8d0339ecc6e6c45" translate="yes" xml:space="preserve">
          <source>Subtypes of functions</source>
          <target state="translated">機能のサブタイプ</target>
        </trans-unit>
        <trans-unit id="476bb4d588f74c233bb6c1ee03fd986be62e7cea" translate="yes" xml:space="preserve">
          <source>Subtypes of objects</source>
          <target state="translated">オブジェクトのサブタイプ</target>
        </trans-unit>
        <trans-unit id="0be5fa8c6c74f697319a9589425f3a2612939e3d" translate="yes" xml:space="preserve">
          <source>Subtyping Constraints</source>
          <target state="translated">サブタイプ制約</target>
        </trans-unit>
        <trans-unit id="f17dd2152e8dc1f949523edeb4f3e8b48630834f" translate="yes" xml:space="preserve">
          <source>Subtyping rules for functions are more complicated. So far, we&amp;rsquo;ve seen that &lt;code&gt;A&lt;/code&gt; is a subtype of &lt;code&gt;B&lt;/code&gt; if &lt;code&gt;B&lt;/code&gt; contains all possible values for &lt;code&gt;A&lt;/code&gt;. For functions, it&amp;rsquo;s not clear how this relationship would apply. To simplify things, you can think of a function type &lt;code&gt;A&lt;/code&gt; as being a subtype of a function type &lt;code&gt;B&lt;/code&gt; if functions of type &lt;code&gt;A&lt;/code&gt; can be used wherever a function of type &lt;code&gt;B&lt;/code&gt; is expected.</source>
          <target state="translated">関数のサブタイプ規則はより複雑です。これまでのところ、 &lt;code&gt;B&lt;/code&gt; に &lt;code&gt;A&lt;/code&gt; のすべての可能な値が含まれている場合、 &lt;code&gt;A&lt;/code&gt; は &lt;code&gt;B&lt;/code&gt; のサブタイプであることがわかりました。関数の場合、この関係がどのように適用されるかは明らかではありません。物事を単純化するために、タイプ &lt;code&gt;A&lt;/code&gt; の関数がタイプ &lt;code&gt;B&lt;/code&gt; の関数が期待されるところならどこでも使用できる場合、関数タイプ &lt;code&gt;A&lt;/code&gt; を関数タイプ &lt;code&gt;B&lt;/code&gt; のサブタイプと考えることができます。</target>
        </trans-unit>
        <trans-unit id="78102c720eccd1810b8e560681ce6685d79fff31" translate="yes" xml:space="preserve">
          <source>Suports vim 8 and neovim</source>
          <target state="translated">vim 8とneovimをサポート</target>
        </trans-unit>
        <trans-unit id="3ea46343abafb30794aea626700e565b309f371e" translate="yes" xml:space="preserve">
          <source>Supplying Type Arguments to Callables</source>
          <target state="translated">コールアブルへの型引数の供給</target>
        </trans-unit>
        <trans-unit id="e4426aae8665ecf03f0c5957ef62701c977ed33b" translate="yes" xml:space="preserve">
          <source>Suppose for example that you want to associate a value to each suit of the previous example.</source>
          <target state="translated">例えば、先ほどの例の各スートに値を関連付けたいとします。</target>
        </trans-unit>
        <trans-unit id="9d5e2489ceb4c7228924f9abf264d9d064bbb4ee" translate="yes" xml:space="preserve">
          <source>Suppressible Flow errors will also have an error code associated with them (after version 0.127). This code concisely describes the type of issue the error is reporting, and is different between different kinds of errors.</source>
          <target state="translated">また、抑圧可能なフロー・エラーには、それらに関連付けられたエラー・コードがあります(バージョン0.127以降)。このコードは、エラーが報告している問題のタイプを簡潔に記述しており、異なる種類のエラーの間で異なる。</target>
        </trans-unit>
        <trans-unit id="4045032ea32b290b2df4209d32c0f98371142465" translate="yes" xml:space="preserve">
          <source>Suppressing one type of sketchy null check only suppresses that type, so, for example</source>
          <target state="translated">1つのタイプのスケッチ的なヌルチェックを抑制することは、そのタイプのみを抑制することになるので、例えば</target>
        </trans-unit>
        <trans-unit id="ade6040e71c5d23d0d099b6e7dbe0b4d723d42dd" translate="yes" xml:space="preserve">
          <source>Suppressions must be on the line immediately before the error they suppress, otherwise they will not apply.</source>
          <target state="translated">抑圧は、抑圧するエラーの直前の行になければならず、そうでなければ適用されません。</target>
        </trans-unit>
        <trans-unit id="259c4642c493b3e83c12d27ca13e5dcbed833440" translate="yes" xml:space="preserve">
          <source>Switching between classic and types-first mode may cause some new Flow errors, besides signature-verification failures that we mentioned earlier. These errors are due differences in the way types based on annotations are interpreted, compared to their respective inferred types.</source>
          <target state="translated">クラシックモードと型優先モードを切り替えると、先に述べた署名検証の失敗以外にも、新たにFlowのエラーが発生することがあります。これらのエラーは、アノテーションに基づく型が、それぞれの推論型と比較して解釈される方法の違いに起因しています。</target>
        </trans-unit>
        <trans-unit id="22ad664e9eb98b75a73333b2b2395fc4b52e6fc9" translate="yes" xml:space="preserve">
          <source>Symbols</source>
          <target state="translated">Symbols</target>
        </trans-unit>
        <trans-unit id="5388b4e54e46d7ce88e2e324bb0464dd484b2048" translate="yes" xml:space="preserve">
          <source>Symbols (new in ECMAScript 2015)</source>
          <target state="translated">シンボル(ECMAScript 2015の新機能</target>
        </trans-unit>
        <trans-unit id="b6410af0c2d3799d510fea0f3019deaa0a7626b1" translate="yes" xml:space="preserve">
          <source>Symbols are created with &lt;code&gt;Symbol()&lt;/code&gt; in JavaScript. Flow has basic support for symbols, using the &lt;code&gt;symbol&lt;/code&gt; type.</source>
          <target state="translated">シンボルは、JavaScriptの &lt;code&gt;Symbol()&lt;/code&gt; で作成されます。フローは、 &lt;code&gt;symbol&lt;/code&gt; タイプを使用して、シンボルを基本的にサポートしています。</target>
        </trans-unit>
        <trans-unit id="a6251b774c7c6606be961a6810aa903791863a16" translate="yes" xml:space="preserve">
          <source>Syntax of functions</source>
          <target state="translated">関数の構文</target>
        </trans-unit>
        <trans-unit id="38f70f0698cfc1eb1310e93dc39ca20595f7e95e" translate="yes" xml:space="preserve">
          <source>Syntax of generics</source>
          <target state="translated">ジェネリックの構文</target>
        </trans-unit>
        <trans-unit id="bae14ee1fff7b2a05299ec56ecdba3f6a62d2c5f" translate="yes" xml:space="preserve">
          <source>Table of contents:</source>
          <target state="translated">目次です。</target>
        </trans-unit>
        <trans-unit id="47b04edd80b66ddca98050f09adbdab0598b38a9" translate="yes" xml:space="preserve">
          <source>Take note of the &lt;code&gt;typeof&lt;/code&gt;, it is required! &lt;code&gt;Foo&lt;/code&gt; without &lt;code&gt;typeof&lt;/code&gt; would be the type of an instance of &lt;code&gt;Foo&lt;/code&gt;. So: &lt;code&gt;(new Foo(): Foo)&lt;/code&gt;. We want the type &lt;em&gt;of&lt;/em&gt;&lt;code&gt;Foo&lt;/code&gt; not the type of an instance of &lt;code&gt;Foo&lt;/code&gt;. So: &lt;code&gt;(Foo: typeof Foo)&lt;/code&gt;. &lt;code&gt;Class&amp;lt;Foo&amp;gt;&lt;/code&gt; would also work here, but we prefer &lt;code&gt;typeof&lt;/code&gt; for consistency with stateless functional components.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; に注意してください、それは必須です！ &lt;code&gt;typeof&lt;/code&gt; のない &lt;code&gt;Foo&lt;/code&gt; は、 &lt;code&gt;Foo&lt;/code&gt; のインスタンスのタイプになります。つまり： &lt;code&gt;(new Foo(): Foo)&lt;/code&gt; 。私たちは、タイプしたい&lt;em&gt;の&lt;/em&gt; &lt;code&gt;Foo&lt;/code&gt; ないのインスタンスのタイプ &lt;code&gt;Foo&lt;/code&gt; 。つまり： &lt;code&gt;(Foo: typeof Foo)&lt;/code&gt; 。 &lt;code&gt;Class&amp;lt;Foo&amp;gt;&lt;/code&gt; もここで機能しますが、ステートレス機能コンポーネントとの一貫性のために &lt;code&gt;typeof&lt;/code&gt; を使用します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="143158f8e0d23bcab4c6519c800370955610ba03" translate="yes" xml:space="preserve">
          <source>Tell Flow which directory to use as a temp directory. Can be overridden with the command line flag &lt;code&gt;--temp-dir&lt;/code&gt;.</source>
          <target state="translated">一時ディレクトリとして使用するディレクトリをFlowに指示します。コマンドラインフラグ &lt;code&gt;--temp-dir&lt;/code&gt; で上書きできます。</target>
        </trans-unit>
        <trans-unit id="2a5ea6782ec2acdb66109615aa3170a3b9e5c7b0" translate="yes" xml:space="preserve">
          <source>The 3 largest parts of the shared memory are a dependency table, a hash table, and a heap. While the heap grows and shrinks, the two tables are allocated in full. This option lets you change the size of the hash table.</source>
          <target state="translated">共有メモリの最大の3つの部分は、依存関係テーブル、ハッシュテーブル、ヒープです。ヒープが成長したり縮小したりする間、2つのテーブルは完全に割り当てられます。このオプションでは、ハッシュテーブルのサイズを変更することができます。</target>
        </trans-unit>
        <trans-unit id="abe1c88748594db64c94f5f66792cd9877ba43f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;CODE&amp;gt;&lt;/code&gt; portion of a suppression is optional, but when included specifies which &lt;a href=&quot;#toc-making-suppressions-more-granular-with-error-codes&quot;&gt;error code&lt;/a&gt; the suppression affects.</source>
          <target state="translated">抑制の &lt;code&gt;&amp;lt;CODE&amp;gt;&lt;/code&gt; 部分はオプションですが、含まれている&lt;a href=&quot;#toc-making-suppressions-more-granular-with-error-codes&quot;&gt;場合&lt;/a&gt;、抑制が影響するエラーコードを指定します。</target>
        </trans-unit>
        <trans-unit id="0934dcae4f0cd7ddb495aeab8057d00242e3e126" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.flowconfig&lt;/code&gt; consists of 7 sections:</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; は 7つのセクションから構成されています。</target>
        </trans-unit>
        <trans-unit id="b2e7419e93c6bb39d11632417b0da8c56509fd33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.flowconfig&lt;/code&gt; uses a custom format that vaguely resembles INI files. We are not proud of our custom format and plan to support a better format in the future. &lt;a href=&quot;https://github.com/facebook/flow/issues/153&quot;&gt;GitHub issue #153&lt;/a&gt; tracks this.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; は漠然とINIファイルに似ているカスタムフォーマットを使用しています。私たちはカスタムフォーマットを誇りに思っておらず、将来的にはより良いフォーマットをサポートする予定です。&lt;a href=&quot;https://github.com/facebook/flow/issues/153&quot;&gt;GitHub issue＃153&lt;/a&gt;がこれを追跡しています。</target>
        </trans-unit>
        <trans-unit id="1aa5025da02d927676c9cd482376361a167bd517" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;?&lt;/code&gt; in &lt;code&gt;?HTMLButtonElement&lt;/code&gt; is important. In the example above the first argument to &lt;code&gt;ref&lt;/code&gt; will be &lt;code&gt;HTMLButtonElement | null&lt;/code&gt; as React will &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element&quot;&gt;call your &lt;code&gt;ref&lt;/code&gt; callback with null&lt;/a&gt; when the component unmounts. Also, the &lt;code&gt;button&lt;/code&gt; property on &lt;code&gt;MyComponent&lt;/code&gt; will not be set until React has finished rendering. Until then your &lt;code&gt;button&lt;/code&gt; ref will be undefined. Protect yourself against these cases and use a &lt;code&gt;?&lt;/code&gt; (like in &lt;code&gt;?HTMLButtonElement&lt;/code&gt;) to protect yourself from bugs.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; で &lt;code&gt;?HTMLButtonElement&lt;/code&gt; 重要です。上記の例では、 &lt;code&gt;ref&lt;/code&gt; の最初の引数は &lt;code&gt;HTMLButtonElement | null&lt;/code&gt; になります。コンポーネントがマウント解除される&lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element&quot;&gt;と、 &lt;code&gt;ref&lt;/code&gt; &lt;/a&gt; Reactはnullを使用してrefコールバックを呼び出すため、null。また、 &lt;code&gt;MyComponent&lt;/code&gt; の &lt;code&gt;button&lt;/code&gt; プロパティは、Reactがレンダリングを完了するまで設定されません。それまでは、 &lt;code&gt;button&lt;/code&gt; 参照は未定義になります。これらのケースから身を守り、 &lt;code&gt;?&lt;/code&gt; （ &lt;code&gt;?HTMLButtonElement&lt;/code&gt; のように）バグから身を守るため。</target>
        </trans-unit>
        <trans-unit id="719a6a4c0e07c1dc9a47466bbab725e9662338ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; types that React provides and the DOM events they are related to are:</source>
          <target state="translated">&lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; 提供リアクト種類とそれらがあるために関連しているDOMイベント：</target>
        </trans-unit>
        <trans-unit id="653be0e1cd193d42d4fa78964cd56de69b5da2cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[declarations]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to parse files matching the specified regular expressions in &lt;em&gt;declaration mode&lt;/em&gt;. In declaration mode the code is not typechecked. However, the signatures of functions, classes, etc are extracted and used by the typechecker when checking other code.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; ファイルの &lt;code&gt;[declarations]&lt;/code&gt; セクションは、指定された正規表現に一致するファイルを&lt;em&gt;宣言モードで&lt;/em&gt;解析するようにFlowに指示し&lt;em&gt;ます&lt;/em&gt;。宣言モードでは、コードは型チェックされません。ただし、関数、クラスなどのシグネチャは抽出され、他のコードをチェックするときにタイプチェッカーによって使用されます。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="df21474ae6954ba751628a9d46d6c9512fa40f07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[ignore]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to ignore files matching the specified regular expressions when type checking your code. By default, nothing is ignored.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; ファイルの &lt;code&gt;[ignore]&lt;/code&gt; セクションは、コードのタイプチェック時に、指定された正規表現に一致するファイルを無視するようにFlowに指示します。デフォルトでは、何も無視されません。</target>
        </trans-unit>
        <trans-unit id="89a1fffc651c11cf6e66838e0172e44593fd9d49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[include]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to include the specified files or directories. Including a directory recursively includes all the files under that directory. Symlinks are followed as long as they lead to a file or directory that is also included. Each line in the include section is a path to include. These paths can be relative to the root directory or absolute, and support both single and double star wildcards.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; ファイルの &lt;code&gt;[include]&lt;/code&gt; セクションは、指定されたファイルまたはディレクトリを含めるようにFlowに指示します。ディレクトリを含めると、そのディレクトリの下にあるすべてのファイルが再帰的に含まれます。含まれているファイルまたはディレクトリにつながる限り、シンボリックリンクをたどります。 includeセクションの各行は、含めるパスです。これらのパスは、ルートディレクトリへの相対パスまたは絶対パスであり、シングルスターとダブルスターの両方のワイルドカードをサポートしています。</target>
        </trans-unit>
        <trans-unit id="f33fef6875ad046a3f7a76b86437d56196d9c414" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[libs]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to include the specified &lt;a href=&quot;https://flow.org/en/libdefs/&quot;&gt;library definitions&lt;/a&gt; when type checking your code. Multiple libraries can be specified. By default, the &lt;code&gt;flow-typed&lt;/code&gt; folder in your project root directory is included as a library directory. This default allows you to use &lt;a href=&quot;https://github.com/flowtype/flow-typed&quot;&gt;&lt;code&gt;flow-typed&lt;/code&gt;&lt;/a&gt; to install library definitions without additional configuration.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; ファイルの &lt;code&gt;[libs]&lt;/code&gt; セクションは、コードの型チェック時に、指定された&lt;a href=&quot;https://flow.org/en/libdefs/&quot;&gt;ライブラリ定義&lt;/a&gt;を含めるようにFlowに指示します。複数のライブラリを指定できます。デフォルトでは、プロジェクトのルートディレクトリにある &lt;code&gt;flow-typed&lt;/code&gt; フォルダは、ライブラリディレクトリとして含まれています。このデフォルトでは、&lt;a href=&quot;https://github.com/flowtype/flow-typed&quot;&gt; &lt;code&gt;flow-typed&lt;/code&gt; &lt;/a&gt;を使用して、追加の構成なしでライブラリ定義をインストールできます。</target>
        </trans-unit>
        <trans-unit id="93975a8a26491b29c7786a7d20f47e387cfa3514" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[lints]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file can contain several key-value pairs of the form:</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; ファイルの &lt;code&gt;[lints]&lt;/code&gt; セクションには、次の形式のキーと値のペアをいくつか含めることができます。</target>
        </trans-unit>
        <trans-unit id="263df81c3f42c9c4c0096bb79a58e2dee22d2326" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[options]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file can contain several key-value pairs of the form:</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; ファイルの &lt;code&gt;[options]&lt;/code&gt; セクションには、次の形式のキーと値のペアをいくつか含めることができます。</target>
        </trans-unit>
        <trans-unit id="81ba04249ba83fffa732ce0d0760f8ad3472a183" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;[untyped]&lt;/code&gt; section in a &lt;code&gt;.flowconfig&lt;/code&gt; file tells Flow to not typecheck files matching the specified regular expressions and instead throw away types and treat modules as &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; ファイルの &lt;code&gt;[untyped]&lt;/code&gt; untyped ]セクションは、指定された正規表現に一致するファイルをタイプチェックせず、代わりにタイプを破棄してモジュールを &lt;code&gt;any&lt;/code&gt; として扱うようにFlowに指示します。</target>
        </trans-unit>
        <trans-unit id="924f7192ca7f7c407e938ed0acd12668b4d33fbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeof&lt;/code&gt; operator returns the Flow type of a given value to be used as a type.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 演算の演算子は、所与の値のフロータイプは、タイプとして使用することに戻ります。</target>
        </trans-unit>
        <trans-unit id="1330e72fe13fbae1f885a0745df109da8382e39b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;well_formed_exports&lt;/code&gt; flag from before is implied by &lt;code&gt;types_first&lt;/code&gt;. Once this process is completed and types-first has been enabled, you can remove &lt;code&gt;well_formed_exports&lt;/code&gt;.</source>
          <target state="translated">以前の &lt;code&gt;well_formed_exports&lt;/code&gt; フラグは、 &lt;code&gt;types_first&lt;/code&gt; によって暗示されます。このプロセスが完了し、types-firstが有効になったら、 &lt;code&gt;well_formed_exports&lt;/code&gt; を削除できます。</target>
        </trans-unit>
        <trans-unit id="67966e36f904c5d8958d761e6cb9127537aff7ef" translate="yes" xml:space="preserve">
          <source>The Asynchronous Lint Engine (ALE) plugin for Vim 8+ and NeoVim, &lt;a href=&quot;https://github.com/w0rp/ale&quot;&gt;vim-ale&lt;/a&gt;, is a generalized linting engine with support for Flow and many other tools.</source>
          <target state="translated">Vim 8+およびNeoVimの非同期リントエンジン（ALE）プラグインである&lt;a href=&quot;https://github.com/w0rp/ale&quot;&gt;vim-ale&lt;/a&gt;は、Flowおよびその他の多くのツールをサポートする汎用リンティングエンジンです。</target>
        </trans-unit>
        <trans-unit id="5183c3b41bf0492de80698dc738a05d76568f6ad" translate="yes" xml:space="preserve">
          <source>The CLI tool also provides several other options and commands that allow you to control the server and build tools that integrate with Flow. For example, this is how the &lt;a href=&quot;https://nuclide.io/&quot;&gt;Nuclide&lt;/a&gt; editor integrates with Flow to provide autocompletion, type errors, etc. in its UI.</source>
          <target state="translated">CLIツールには、サーバーを制御し、Flowと統合するツールを構築するためのその他のオプションとコマンドもいくつか用意されています。たとえば、これは&lt;a href=&quot;https://nuclide.io/&quot;&gt;Nuclide&lt;/a&gt;エディターがFlowと統合して、UIでオートコンプリートやタイプエラーなどを提供する方法です。</target>
        </trans-unit>
        <trans-unit id="0b12391516f21ae19dfcef64eb8647ae6924887e" translate="yes" xml:space="preserve">
          <source>The Flow background process monitors all Flow files. However, how does it know which files are Flow files and, thus, should be checked? Placing the following &lt;strong&gt;before any code&lt;/strong&gt; in a JavaScript file is the flag the process uses to answer that question.</source>
          <target state="translated">Flowバックグラウンドプロセスは、すべてのFlowファイルを監視します。ただし、どのファイルがフローファイルであり、したがって、チェックする必要があるかをどのようにして知るのでしょうか。JavaScriptファイルの&lt;strong&gt;コードの前&lt;/strong&gt;に以下を配置することは、プロセスがその質問に答えるために使用するフラグです。</target>
        </trans-unit>
        <trans-unit id="3ea8fcfb745f317d30dab0afe405550d9490a0f7" translate="yes" xml:space="preserve">
          <source>The Flow root must be within a &lt;a href=&quot;https://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt; repository.</source>
          <target state="translated">フロールートは&lt;a href=&quot;https://www.mercurial-scm.org/&quot;&gt;Mercurial&lt;/a&gt;リポジトリ内にある必要があります。</target>
        </trans-unit>
        <trans-unit id="eb9d9e2a123153d996537b64730290848876d71f" translate="yes" xml:space="preserve">
          <source>The IDE needs to integrate with &lt;code&gt;flow lsp&lt;/code&gt; to tell Flow which files are open.</source>
          <target state="translated">IDEはFlow &lt;code&gt;flow lsp&lt;/code&gt; と統合して、開いているファイルをFlowに通知する必要があります。</target>
        </trans-unit>
        <trans-unit id="e36e3ea40dbe1430b59533dc1b80fc6036bba9ee" translate="yes" xml:space="preserve">
          <source>The JavaScript language is a bunch of object-oriented ideas and functional ideas mixed together. Developer&amp;rsquo;s usage of JavaScript tends to be mixed as well. Classes (or constructor functions) being the more object-oriented side and functions (as lambdas) and objects tend to be more on the functional side, developers use both simultaneously.</source>
          <target state="translated">JavaScript言語は、オブジェクト指向のアイデアと機能のアイデアを組み合わせたものです。JavaScriptの開発者の使用法も混合される傾向があります。クラス（またはコンストラクター関数）はよりオブジェクト指向の側面であり、関数（ラムダとして）およびオブジェクトはより機能的な側面である傾向があるため、開発者は両方を同時に使用します。</target>
        </trans-unit>
        <trans-unit id="7bd394e3f7c77eaabbe75ef337cf434e120de82b" translate="yes" xml:space="preserve">
          <source>The Trivial HOC</source>
          <target state="translated">トリビアルHOC</target>
        </trans-unit>
        <trans-unit id="025b59ea409d457aec020e335d2f4bc894d68ede" translate="yes" xml:space="preserve">
          <source>The ability for a static type checker to be able to tell that the value inside the if statement must be &lt;code&gt;&quot;A&quot;&lt;/code&gt; is known as a refinement.</source>
          <target state="translated">静的型チェッカーがifステートメント内の値が &lt;code&gt;&quot;A&quot;&lt;/code&gt; でなければならないことを認識できる機能は、改良と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="fec021ecaeba3a8ee38ad356d77c56a0bb6f13a4" translate="yes" xml:space="preserve">
          <source>The above code has a type error because Flow would also allow the call expression &lt;code&gt;method({ foo: 1, bar: 2 })&lt;/code&gt;, because &lt;code&gt;{foo:number,bar:number}&lt;/code&gt; is a subtype of &lt;code&gt;{bar:number}&lt;/code&gt;, one of the members of the parameter&amp;rsquo;s union type.</source>
          <target state="translated">上記のコードにはタイプエラーがあります。フローは呼び出し式 &lt;code&gt;method({ foo: 1, bar: 2 })&lt;/code&gt; も許可するためです。 &lt;code&gt;{foo:number,bar:number}&lt;/code&gt; は &lt;code&gt;{bar:number}&lt;/code&gt; のサブタイプであるため、パラメータの共用体型のメンバー。</target>
        </trans-unit>
        <trans-unit id="fe2ac4fdbea23fe269b2df48740a8fe5b6447c33" translate="yes" xml:space="preserve">
          <source>The advantage of the &lt;code&gt;$Exports&lt;/code&gt; syntax is that you can &lt;code&gt;export&lt;/code&gt; the type on the same line</source>
          <target state="translated">&lt;code&gt;$Exports&lt;/code&gt; 構文の利点は、同じ行で型を &lt;code&gt;export&lt;/code&gt; できることです</target>
        </trans-unit>
        <trans-unit id="eba2348e4056127995e90c22bf6c18e156a3d1c5" translate="yes" xml:space="preserve">
          <source>The base type for Redux &lt;a href=&quot;http://redux.js.org/docs/basics/Actions.html&quot;&gt;actions&lt;/a&gt; is an object with a &lt;code&gt;type&lt;/code&gt; property.</source>
          <target state="translated">Redux &lt;a href=&quot;http://redux.js.org/docs/basics/Actions.html&quot;&gt;アクション&lt;/a&gt;の基本タイプは、 &lt;code&gt;type&lt;/code&gt; プロパティを持つオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="8af3b40968bb4f75f70768133b814cdf17d5d2ec" translate="yes" xml:space="preserve">
          <source>The basic &lt;code&gt;flowlint&lt;/code&gt; comment takes a comma-delimited list of &lt;code&gt;rule:severity&lt;/code&gt; pairs and applies those settings for the rest of the source file until overridden. This has three primary purposes: applying settings over a block, applying settings over a file, and applying settings over part of a line.</source>
          <target state="translated">基本的な &lt;code&gt;flowlint&lt;/code&gt; コメントは、 &lt;code&gt;rule:severity&lt;/code&gt; ペアのコンマ区切りのリストを取り、上書きされるまで、残りのソースファイルにそれらの設定を適用します。これには3つの主な目的があります。ブロックに設定を適用する、ファイルに設定を適用する、および行の一部に設定を適用することです。</target>
        </trans-unit>
        <trans-unit id="48755c9924c91563b67114a45c53a5f50b06fab7" translate="yes" xml:space="preserve">
          <source>The benefit of this new architecture is dual:</source>
          <target state="translated">この新しいアーキテクチャの利点は二重にある。</target>
        </trans-unit>
        <trans-unit id="f167409d5ec197b4871f95c5db2fcf7f6bbd5cd2" translate="yes" xml:space="preserve">
          <source>The body of these predicate functions need to be expressions (i.e. local variable declarations are not supported). But it&amp;rsquo;s possible to call other predicate functions inside a predicate function. For example:</source>
          <target state="translated">これらの述語関数の本体は式である必要があります（つまり、ローカル変数宣言はサポートされていません）。ただし、述語関数内で他の述語関数を呼び出すことは可能です。例えば：</target>
        </trans-unit>
        <trans-unit id="3c484a1b1878460543cc195aaf9ab4cae85fb2ea" translate="yes" xml:space="preserve">
          <source>The caveat of this new version is that it requires exported parts of the code to be annotated with types, or to be expressions whose type can be trivially inferred (for example numbers and strings).</source>
          <target state="translated">この新しいバージョンの注意点は、エクスポートされたコードの一部に型のアノテーションを付けるか、型が容易に推測できる式(例えば、数値や文字列)でなければならないということです。</target>
        </trans-unit>
        <trans-unit id="182510f68d230df9a3e633ed8ee2db47f5bc405d" translate="yes" xml:space="preserve">
          <source>The core benefit to Flow is its ability to quickly check your code for errors. Once you have enabled your project for Flow, you can start the process that allows Flow to check your code incrementally and with great speed.</source>
          <target state="translated">Flowの中心的な利点は、コードにエラーがないかどうかを素早くチェックできることです。プロジェクトをFlow用に有効にしたら、Flowがコードを段階的に、かつ高速にチェックできるようにするプロセスを開始することができます。</target>
        </trans-unit>
        <trans-unit id="8a1aab316dcc9dd57ed72229c368c2d026bb14e1" translate="yes" xml:space="preserve">
          <source>The coverage command provides a metric of the amount of checking that Flow has performed on each part of your code. A program with high Flow coverage should increase your confidence that Flow has detected any potential runtime errors.</source>
          <target state="translated">coverageコマンドは、Flowがコードの各部分に対して実行したチェックの量を示すメトリックを提供します。Flowのカバレッジが高いプログラムは、Flowが潜在的なランタイムエラーを検出したという確信度を高めることができます。</target>
        </trans-unit>
        <trans-unit id="f7197940d208092be8c8d13b858faffa50044428" translate="yes" xml:space="preserve">
          <source>The decision of which direction to apply the subtyping rule on inputs and outputs is governed by variance, which is the topic of the next section.</source>
          <target state="translated">入力と出力のどちらの方向にサブタイピングルールを適用するかの決定は、次のセクションのトピックである分散によって支配されます。</target>
        </trans-unit>
        <trans-unit id="4ff505957015ad603cc74c9be6c56afdb90f26dc" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">デフォルトは &lt;code&gt;node&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="684bf3ea595241d58aa0cbec92715b88590f0f96" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;all&lt;/code&gt; のデフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="dcc51d57d4a016ea1192824513bdb37f918f5d3a" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;babel_loose_array_spread&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;babel_loose_array_spread&lt;/code&gt; のデフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a3320966c1ed05d8e92be8263eb0872986cd5b9d" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;emoji&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;emoji&lt;/code&gt; のデフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="108bf5699171bd14f4e61bce6c21f7bec782d0a5" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;types_first&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (as of version 0.134).</source>
          <target state="translated">&lt;code&gt;types_first&lt;/code&gt; のデフォルト値は &lt;code&gt;true&lt;/code&gt; です（バージョン0.134以降）。</target>
        </trans-unit>
        <trans-unit id="b4b4c401e7d77aa94ed0f3d78556a2ab12605661" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;/tmp/flow&lt;/code&gt;.</source>
          <target state="translated">デフォルト値は &lt;code&gt;/tmp/flow&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6ab75823e9609a97fc3968cb003989422d1692ab" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;automatic&lt;/code&gt;.</source>
          <target state="translated">デフォルト値は &lt;code&gt;automatic&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6d1dcc6b3a394539acf783a764b41f856bcb2ec9" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">デフォルト値は &lt;code&gt;false&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="17a6f3086f6053ea99056f8787ec9e3c7714223a" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">デフォルト値は &lt;code&gt;none&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="385f9197e267dca024cc7c5ee266ab77c07dd86b" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;max_header_tokens&lt;/code&gt; is 10.</source>
          <target state="translated">&lt;code&gt;max_header_tokens&lt;/code&gt; のデフォルト値は10です。</target>
        </trans-unit>
        <trans-unit id="4afe27211cbc9af6d345271f3bd53dcd4c074b64" translate="yes" xml:space="preserve">
          <source>The default value of this option is &lt;code&gt;enable&lt;/code&gt;, which allows use of this proposed syntax.</source>
          <target state="translated">このオプションのデフォルト値は &lt;code&gt;enable&lt;/code&gt; で、この提案された構文を使用できます。</target>
        </trans-unit>
        <trans-unit id="07a26010ceb723197e0f6ed4ccf098b594327ee9" translate="yes" xml:space="preserve">
          <source>The default value of this option is &lt;code&gt;warn&lt;/code&gt;, which gives a warning on use since this proposal is still very early-stage.</source>
          <target state="translated">このオプションのデフォルト値は &lt;code&gt;warn&lt;/code&gt; です。これは、この提案がまだ非常に初期段階であるため、使用時に警告を発します。</target>
        </trans-unit>
        <trans-unit id="4804a2b774fe8e16ad5ee7fbc61053dc05f70f20" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; is roughly:</source>
          <target state="translated">&lt;code&gt;React.ComponentType&amp;lt;Props&amp;gt;&lt;/code&gt; の定義はおおよそ次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c3087bc731ef3517a427cf5c4e5203623cadca99" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.ElementType&lt;/code&gt; is roughly:</source>
          <target state="translated">&lt;code&gt;React.ElementType&lt;/code&gt; の定義はおおよそ次のとおりです。</target>
        </trans-unit>
        <trans-unit id="6e617c1ee84ca2ef49a14a0c500b7bf9f6b27172" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.Ref&amp;lt;typeof Component&amp;gt;&lt;/code&gt; is roughly:</source>
          <target state="translated">&lt;code&gt;React.Ref&amp;lt;typeof Component&amp;gt;&lt;/code&gt; の定義はおおよそ次のとおりです。</target>
        </trans-unit>
        <trans-unit id="f2c72eeedacf538eae7405dbd87fe7965700eed1" translate="yes" xml:space="preserve">
          <source>The definition for &lt;code&gt;React.StatelessFunctionalComponent&amp;lt;Props&amp;gt;&lt;/code&gt; is roughly:</source>
          <target state="translated">&lt;code&gt;React.StatelessFunctionalComponent&amp;lt;Props&amp;gt;&lt;/code&gt; の定義はおおよそ次のとおりです。</target>
        </trans-unit>
        <trans-unit id="67931b95c973afece9e67ea2abaeb942c4811eaf" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;React.Node&lt;/code&gt; can be roughly approximated with a &lt;a href=&quot;#toc-react-childrenarray&quot;&gt;&lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;React.Node&lt;/code&gt; の定義は、おおよそ&lt;a href=&quot;#toc-react-childrenarray&quot;&gt; &lt;code&gt;React.ChildrenArray&amp;lt;T&amp;gt;&lt;/code&gt; &lt;/a&gt;近似できます。</target>
        </trans-unit>
        <trans-unit id="65be16845f607fa6de2868121655dbf19d303167" translate="yes" xml:space="preserve">
          <source>The design decision in Flow around mixing nominal and structural typing was chosen based on how objects, functions, and classes are already used in JavaScript.</source>
          <target state="translated">Flowでは、JavaScriptですでにオブジェクト、関数、クラスがどのように使用されているかに基づいて、名目型付けと構造型付けの混合を中心とした設計決定が行われました。</target>
        </trans-unit>
        <trans-unit id="615278e593ca17f18421f88e244590b32e0dc1cd" translate="yes" xml:space="preserve">
          <source>The determining factor for this is the presence of &lt;a href=&quot;../types/any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; in the inferred type of each expression. An expression whose inferred type is &lt;code&gt;any&lt;/code&gt; is considered &lt;em&gt;uncovered&lt;/em&gt;, otherwise it is considered &lt;em&gt;covered&lt;/em&gt;.</source>
          <target state="translated">これを決定する要因は、各式の推定タイプに&lt;a href=&quot;../types/any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt;が存在することです。その推論された型で表現 &lt;code&gt;any&lt;/code&gt; 考えられている&lt;em&gt;覆われていない&lt;/em&gt;そうでない場合を考慮し、&lt;em&gt;カバー&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="29d2d625710fa5cd0abd9e50046510b51fb847f2" translate="yes" xml:space="preserve">
          <source>The example above could not be accomplished without the &lt;code&gt;+&lt;/code&gt; variance sigil:</source>
          <target state="translated">上記の例は、 &lt;code&gt;+&lt;/code&gt; 分散シギルなしでは実現できません。</target>
        </trans-unit>
        <trans-unit id="569e13c9d22dc97266745256891834efe9cb254b" translate="yes" xml:space="preserve">
          <source>The first time this is run, the &lt;a href=&quot;#toc-run-flow-background-process&quot;&gt;Flow background process&lt;/a&gt; will be spawned and all of your Flow files will be checked. Then, as you continue to iterate on your project, the background process will continuously monitor your code such that when you run &lt;code&gt;flow&lt;/code&gt; again, the updated result will be near instantaneous.</source>
          <target state="translated">これを初めて実行すると、&lt;a href=&quot;#toc-run-flow-background-process&quot;&gt;フローバックグラウンドプロセス&lt;/a&gt;が生成され、すべてのフローファイルがチェックされます。その後、プロジェクトで繰り返し処理を続けると、バックグラウンドプロセスが継続的にコードを監視するため、 &lt;code&gt;flow&lt;/code&gt; 再度実行すると、更新された結果がほぼ瞬時になります。</target>
        </trans-unit>
        <trans-unit id="f48e199f3e1c2873fac5e329e515e0affa5734d6" translate="yes" xml:space="preserve">
          <source>The fix here is to add types to the parameters of &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">ここでの修正は、addのパラメーターに型を &lt;code&gt;add&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="decaa6f4bcdc1dd98facfb522a07ee0290e90e6a" translate="yes" xml:space="preserve">
          <source>The flow command line tool is made to be easy-to-use for simple cases.</source>
          <target state="translated">フローコマンドラインツールは、簡単なケースでも使いやすいように作られています。</target>
        </trans-unit>
        <trans-unit id="568d41ac14b4b2796ccd853ff99f7c7a730490f8" translate="yes" xml:space="preserve">
          <source>The following are functionally equivalent</source>
          <target state="translated">以下は機能的に等価です。</target>
        </trans-unit>
        <trans-unit id="10e5012640308970d1812cdfc15f495ee3f6ea82" translate="yes" xml:space="preserve">
          <source>The function argument allows &lt;code&gt;string&lt;/code&gt; values in its field, but in this case Flow prevents the original object from having a &lt;code&gt;number&lt;/code&gt; written to it. Within the body of the function you would be able to mutate the object so that the property &lt;code&gt;a&lt;/code&gt; would receive a &lt;code&gt;number&lt;/code&gt;, causing the type of the original object to no longer be accurate. You can fix this error by making the property covariant (read-only): &lt;code&gt;{+a:string|&amp;nbsp;number}&lt;/code&gt;. This prevents the function body from writing to the property, making it safe to pass more restricted types to the function.</source>
          <target state="translated">関数の引数では、フィールドに &lt;code&gt;string&lt;/code&gt; 値を指定できますが、この場合、フローでは元のオブジェクトに &lt;code&gt;number&lt;/code&gt; 書き込まれません。関数の本体内でオブジェクトを変更して、プロパティ &lt;code&gt;a&lt;/code&gt; が &lt;code&gt;number&lt;/code&gt; を受け取るようにして、元のオブジェクトのタイプが正確でなくなるようにすることができます。このエラーは、プロパティを共変（読み取り専用）にすることで修正できます： &lt;code&gt;{+a:string|&amp;nbsp;number}&lt;/code&gt; 。これにより、関数本体がプロパティに書き込むことができなくなり、より制限された型を関数に安全に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="2155dfc51f926d913a644cc3de06c804ab01b2ad" translate="yes" xml:space="preserve">
          <source>The function&amp;rsquo;s argument allows &lt;code&gt;string&lt;/code&gt; values in its array, but in this case Flow prevents the original array from receiving a &lt;code&gt;number&lt;/code&gt;. Inside the function, you would be able to push a &lt;code&gt;number&lt;/code&gt; to the argument array, causing the type of the original array to no longer be accurate. You can fix this error by changing the type of the argument to &lt;code&gt;$ReadOnlyArray&amp;lt;string |&amp;nbsp;number&amp;gt;&lt;/code&gt;. This prevents the function body from pushing anything to the array, allowing it to accept narrower types.</source>
          <target state="translated">関数の引数はその配列で &lt;code&gt;string&lt;/code&gt; 値を許可しますが、この場合、フローは元の配列が &lt;code&gt;number&lt;/code&gt; を受け取ることを防ぎます。関数内では、引数の配列に &lt;code&gt;number&lt;/code&gt; をプッシュできるため、元の配列の型が正確でなくなります。このエラーを修正するには、引数のタイプを &lt;code&gt;$ReadOnlyArray&amp;lt;string |&amp;nbsp;number&amp;gt;&lt;/code&gt; 変更します。番号&amp;gt;。これにより、関数本体が配列に何かをプッシュするのを防ぎ、より狭い型を受け入れることができます。</target>
        </trans-unit>
        <trans-unit id="63f89c1777909f20b429c72e0ff7ec4f5852765d" translate="yes" xml:space="preserve">
          <source>The function&amp;rsquo;s purpose is to run all the thunks and return an object made of values. What&amp;rsquo;s the return type of this function?</source>
          <target state="translated">関数の目的は、すべてのサンクを実行し、値で構成されるオブジェクトを返すことです。この関数の戻り値の型は何ですか？</target>
        </trans-unit>
        <trans-unit id="c023f83d766bac37fd8c93749ac0588a01c18d3d" translate="yes" xml:space="preserve">
          <source>The great thing about Flow is that you can get near real-time feedback on the state of your code. At any point that you want to check for errors, just run:</source>
          <target state="translated">Flowの素晴らしいところは、コードの状態をほぼリアルタイムでフィードバックできることです。エラーをチェックしたいときはいつでも実行してください。</target>
        </trans-unit>
        <trans-unit id="1d3a896ebf3c8fbb9102531fb367809a43a70216" translate="yes" xml:space="preserve">
          <source>The idea of using types to manage code evolution and growth in JavaScript (and related languages) is not new. In fact, several useful type systems have been built for JavaScript in recent years. However, type systems differ in their goals. On one end of the spectrum are permissive type systems that provide some degree of linting against likely errors, without regard for correctness. On the other end of the spectrum are restrictive type systems that can guarantee the correctness of static code optimizations, at the cost of interoperability. Another area that has not seen a lot of focus is the performance of type checking itself.</source>
          <target state="translated">JavaScript (および関連言語)におけるコードの進化と成長を管理するために型を使用するという考えは新しいものではありません。実際、近年、いくつかの有用な型システムが JavaScript のために構築されてきました。しかし、型システムはその目的に違いがあります。一方では、正しさを気にせずに、ありそうなエラーに対してある程度のリントを提供する寛容な型システムがあります。一方で、静的なコード最適化の正しさを保証し、相互運用性を犠牲にする制限的な型システムがあります。もう一つ、あまり注目されていない分野として、型検査自体の性能があります。</target>
        </trans-unit>
        <trans-unit id="895222166e3067cff8bd88b8a774d6ab00fde9e2" translate="yes" xml:space="preserve">
          <source>The inferred type of the property becomes what you set it to.</source>
          <target state="translated">プロパティの推論型は、それを設定するものになります。</target>
        </trans-unit>
        <trans-unit id="e551fea41cfe91f78e0d3bfde3174c0c4fa76ec7" translate="yes" xml:space="preserve">
          <source>The key to Flow&amp;rsquo;s speed is modularity: the ability to break the analysis into file-sized chunks that can be assembled later.</source>
          <target state="translated">Flowの速度の鍵はモジュール性です。分析をファイルサイズのチャンクに分割し、後で組み立てることができます。</target>
        </trans-unit>
        <trans-unit id="ef6ba2b0cdf8e98a8b5dce1cdbd0afc335063144" translate="yes" xml:space="preserve">
          <source>The keys are the same, but the values have a different type, namely the return type of each function. At a value level (the implementation of the function) we&amp;rsquo;re essentially mapping over the object to produce new values for the keys. How to express this at a type level?</source>
          <target state="translated">キーは同じですが、値の型が異なります。つまり、各関数の戻り値の型です。値レベル（関数の実装）では、基本的にオブジェクトをマッピングして、キーの新しい値を生成します。タイプレベルでこれをどのように表現しますか？</target>
        </trans-unit>
        <trans-unit id="92ccbfce1a4e920f5d1758fbdebfc31032b257d4" translate="yes" xml:space="preserve">
          <source>The length of the tuple is known as the &amp;ldquo;arity&amp;rdquo;. The length of a tuple is strictly enforced in Flow.</source>
          <target state="translated">タプルの長さは「アリティ」と呼ばれます。タプルの長さは、フローで厳密に適用されます。</target>
        </trans-unit>
        <trans-unit id="647cfb5d0aaa8b82192bbb83417ad5b3177c198f" translate="yes" xml:space="preserve">
          <source>The lint settings parser is fairly intelligent and will stop you if you write a redundant rule, a rule that gets completely overwritten, or an unused suppression. This should prevent most accidental misconfigurations of lint rules.</source>
          <target state="translated">lint 設定パーサはかなりインテリジェントで、冗長なルールを書いたり、完全に上書きされたり、使われていない抑圧を書いたりした場合には止めてくれます。これにより、ほとんどの lint ルールの誤った設定を防ぐことができるはずです。</target>
        </trans-unit>
        <trans-unit id="f02d9fd7d48002b88a676cb504a249985d85238a" translate="yes" xml:space="preserve">
          <source>The location of the &lt;code&gt;.flowconfig&lt;/code&gt; is significant. Flow treats the directory that contains the &lt;code&gt;.flowconfig&lt;/code&gt; as the &lt;em&gt;project root&lt;/em&gt;. By default Flow includes all the source code under the project root. The paths in the &lt;a href=&quot;include&quot;&gt;[include] section&lt;/a&gt; are relative to the project root. Some other configuration also lets you reference the project root via the macro &lt;code&gt;&amp;lt;PROJECT_ROOT&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; の場所は重要です。Flowは、 &lt;code&gt;.flowconfig&lt;/code&gt; を含むディレクトリを&lt;em&gt;プロジェクトルート&lt;/em&gt;として扱います。デフォルトでは、フローにはプロジェクトルートの下のすべてのソースコードが含まれます。&lt;a href=&quot;include&quot;&gt;[include]セクション&lt;/a&gt;のパスは、プロジェクトルートからの相対パスです。その他の構成では、マクロ &lt;code&gt;&amp;lt;PROJECT_ROOT&amp;gt;&lt;/code&gt; を介してプロジェクトルートを参照することもできます。</target>
        </trans-unit>
        <trans-unit id="88b94dfde96af7809cecaa352baf181b5eb93f8e" translate="yes" xml:space="preserve">
          <source>The main advantage to using &lt;code&gt;$ReadOnlyArray&lt;/code&gt; instead of &lt;code&gt;Array&lt;/code&gt; is that &lt;code&gt;$ReadOnlyArray&lt;/code&gt;&amp;rsquo;s type parameter is &lt;em&gt;covariant&lt;/em&gt; while &lt;code&gt;Array&lt;/code&gt;&amp;rsquo;s type parameter is &lt;em&gt;invariant&lt;/em&gt;. That means that &lt;code&gt;$ReadOnlyArray&amp;lt;number&amp;gt;&lt;/code&gt; is a subtype of &lt;code&gt;$ReadOnlyArray&amp;lt;number | string&amp;gt;&lt;/code&gt; while &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt; is NOT a subtype of &lt;code&gt;Array&amp;lt;number | string&amp;gt;&lt;/code&gt;. So it&amp;rsquo;s often useful to use &lt;code&gt;$ReadOnlyArray&lt;/code&gt; in type annotations for arrays of various types of elements. Take, for instance, the following scenario:</source>
          <target state="translated">&lt;code&gt;Array&lt;/code&gt; の代わりに &lt;code&gt;$ReadOnlyArray&lt;/code&gt; を使用する主な利点は、 &lt;code&gt;$ReadOnlyArray&lt;/code&gt; の型パラメーターが&lt;em&gt;共変であるの&lt;/em&gt;に対し、 &lt;code&gt;Array&lt;/code&gt; の型パラメーターは&lt;em&gt;不変であること&lt;/em&gt;です。つまり、 &lt;code&gt;$ReadOnlyArray&amp;lt;number&amp;gt;&lt;/code&gt; は &lt;code&gt;$ReadOnlyArray&amp;lt;number | string&amp;gt;&lt;/code&gt; サブタイプです。 string&amp;gt;が &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt; は &lt;code&gt;Array&amp;lt;number | string&amp;gt;&lt;/code&gt; サブタイプではありません| string&amp;gt;。したがって、さまざまなタイプの要素の配列のタイプアノテーションで &lt;code&gt;$ReadOnlyArray&lt;/code&gt; を使用すると便利です。たとえば、次のシナリオを考えてみます。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="641f626a5da92cffb82099b03123b4b7495ce303" translate="yes" xml:space="preserve">
          <source>The main difference with &lt;a href=&quot;#toc-diff&quot;&gt;&lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt;&lt;/a&gt;, is that &lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; aims to represent the true runtime rest operation, which implies that exact object types are treated differently in &lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt;. For example, &lt;code&gt;$Rest&amp;lt;{|n: number|}, {}&amp;gt;&lt;/code&gt; will result in &lt;code&gt;{|n?:number|}&lt;/code&gt; because an in-exact empty object may have an &lt;code&gt;n&lt;/code&gt; property, while &lt;code&gt;$Diff&amp;lt;{|n: number|}, {}&amp;gt;&lt;/code&gt; will result in &lt;code&gt;{|n:number|}&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#toc-diff&quot;&gt; &lt;code&gt;$Diff&amp;lt;A, B&amp;gt;&lt;/code&gt; &lt;/a&gt;との主な違いは、 &lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; が真のランタイムレストオペレーションを表すことです。これは、正確なオブジェクトタイプが &lt;code&gt;$Rest&amp;lt;A, B&amp;gt;&lt;/code&gt; 異なる方法で処理されることを意味します。たとえば、 &lt;code&gt;$Rest&amp;lt;{|n: number|}, {}&amp;gt;&lt;/code&gt; は &lt;code&gt;{|n?:number|}&lt;/code&gt; なります。これは、正確でない空のオブジェクトには &lt;code&gt;n&lt;/code&gt; プロパティがある可能性があるため、 &lt;code&gt;$Diff&amp;lt;{|n: number|}, {}&amp;gt;&lt;/code&gt; は &lt;code&gt;{|n:number|}&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="7bbdc2ea29d0148a224653e3dc437fe724818563" translate="yes" xml:space="preserve">
          <source>The maximum number of workers the Flow server can start. By default, the server will use all available cores.</source>
          <target state="translated">フローサーバーが起動できるワーカーの最大数。デフォルトでは、サーバーは利用可能なすべてのコアを使用します。</target>
        </trans-unit>
        <trans-unit id="2288b72b1f95feec127ed704e5e991f5ea4c03bb" translate="yes" xml:space="preserve">
          <source>The module system to use to resolve &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;require&lt;/code&gt;. &lt;a href=&quot;https://github.com/facebook/node-haste&quot;&gt;Haste&lt;/a&gt; is used in React Native.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; および &lt;code&gt;require&lt;/code&gt; 解決に使用するモジュールシステム。&lt;a href=&quot;https://github.com/facebook/node-haste&quot;&gt;Haste&lt;/a&gt;はReact Nativeで使用されます。</target>
        </trans-unit>
        <trans-unit id="4ccdab5f7410661918848aa1e2e6bf4bba7ef93d" translate="yes" xml:space="preserve">
          <source>The most common case you&amp;rsquo;ll encounter is when exporting a function or React component. Flow requires you to annotate inputs. For instance, in this &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBTAHgB1gJwC6gMawB2AzngIYAmloAvKOXQHwOgDUoAjANxA&quot;&gt;example&lt;/a&gt;, flow will complain:</source>
          <target state="translated">遭遇する最も一般的なケースは、関数またはReactコンポーネントをエクスポートするときです。フローでは、入力に注釈を付ける必要があります。たとえば、この&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBTAHgB1gJwC6gMawB2AzngIYAmloAvKOXQHwOgDUoAjANxA&quot;&gt;例では&lt;/a&gt;、フローは文句を言うでしょう：</target>
        </trans-unit>
        <trans-unit id="1d256527f1fd7c67fd36002480923ad5cedc2e90" translate="yes" xml:space="preserve">
          <source>The name specified in quotes after &lt;code&gt;declare module&lt;/code&gt; can be any string, but it should correspond to the same string you&amp;rsquo;d use to &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; the third-party module into your project. For defining modules that are accessed via a relative &lt;code&gt;require&lt;/code&gt;/&lt;code&gt;import&lt;/code&gt; path, please see the docs on the &lt;a href=&quot;https://flow.org/en/declarations&quot;&gt;&lt;code&gt;.flow&lt;/code&gt; files&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;declare module&lt;/code&gt; 後に引用符で指定する名前は任意の文字列にすることができますが、サードパーティモジュールをプロジェクトに &lt;code&gt;require&lt;/code&gt; または &lt;code&gt;import&lt;/code&gt; するために使用するのと同じ文字列に対応する必要があります。相対 &lt;code&gt;require&lt;/code&gt; / &lt;code&gt;import&lt;/code&gt; パスを介してアクセスされるモジュールの定義については、&lt;a href=&quot;https://flow.org/en/declarations&quot;&gt; &lt;code&gt;.flow&lt;/code&gt; &lt;/a&gt;ファイルのドキュメントを参照してください</target>
        </trans-unit>
        <trans-unit id="fee97a1aa5d0e2a829b605bdbaea327f2fcfbd4f" translate="yes" xml:space="preserve">
          <source>The path to the log file (defaults to &lt;code&gt;/tmp/flow/&amp;lt;escaped root path&amp;gt;.log&lt;/code&gt;).</source>
          <target state="translated">ログファイルへのパス（デフォルトは &lt;code&gt;/tmp/flow/&amp;lt;escaped root path&amp;gt;.log&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6028aa8c33369bd6d14f531cdbe045d2ca494cce" translate="yes" xml:space="preserve">
          <source>The plus sign indicates that the &lt;code&gt;who&lt;/code&gt; property is &amp;ldquo;covariant.&amp;rdquo; Using a covariant property allows us to use objects which have subtype-compatible values for that property. By default, object properties are invariant, which allow both reads and writes, but are more restrictive in the values they accept.</source>
          <target state="translated">プラス記号は、 &lt;code&gt;who&lt;/code&gt; プロパティが「共変」であることを示します。共変プロパティを使用すると、そのプロパティに対してサブタイプ互換の値を持つオブジェクトを使用できます。デフォルトでは、オブジェクトプロパティは不変で、読み取りと書き込みの両方が可能ですが、受け入れる値はより制限されています。</target>
        </trans-unit>
        <trans-unit id="8b6e43a14a66d8e57ad3388723dad2315e2002cc" translate="yes" xml:space="preserve">
          <source>The primitive types appear in the language as either literal values.</source>
          <target state="translated">プリミティブ型は、リテラル値のいずれかとして言語に登場します。</target>
        </trans-unit>
        <trans-unit id="fbcdf34cda6e03181b88966618eea724fde6c716" translate="yes" xml:space="preserve">
          <source>The project root directory (where your &lt;code&gt;.flowconfig&lt;/code&gt; lives) is automatically included.</source>
          <target state="translated">プロジェクトのルートディレクトリ（ &lt;code&gt;.flowconfig&lt;/code&gt; が存在する場所）は自動的に含まれます。</target>
        </trans-unit>
        <trans-unit id="2de246126745bc16c8eecf3d43ab6f8772098522" translate="yes" xml:space="preserve">
          <source>The purpose of this option is to help prepare a codebase for Flow types-first mode. See &lt;a href=&quot;#toc-seal-your-intermediate-results&quot;&gt;this section&lt;/a&gt; for more.</source>
          <target state="translated">このオプションの目的は、フロータイプファーストモードのコードベースの準備を支援することです。詳細については、&lt;a href=&quot;#toc-seal-your-intermediate-results&quot;&gt;このセクション&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="28bebee27e53966722fe139f706cf86a64136098" translate="yes" xml:space="preserve">
          <source>The reason for this is that we don&amp;rsquo;t know that &lt;code&gt;otherMethod()&lt;/code&gt; hasn&amp;rsquo;t done something to our value. Imagine the following scenario:</source>
          <target state="translated">これは、 &lt;code&gt;otherMethod()&lt;/code&gt; が値に対して何かを行っていないことを知らないためです。次のシナリオを想像してみてください：</target>
        </trans-unit>
        <trans-unit id="dcdaec4a5e807c4478cc1b0eb9fd497d6c728c78" translate="yes" xml:space="preserve">
          <source>The ref function will take one and only argument which will be the element instance which is retrieved using &lt;a href=&quot;#toc-react-elementref&quot;&gt;&lt;code&gt;React.ElementRef&amp;lt;typeof Component&amp;gt;&lt;/code&gt;&lt;/a&gt; or null since &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element&quot;&gt;React will pass null into a ref function when unmounting&lt;/a&gt;.</source>
          <target state="translated">ref関数は、&lt;a href=&quot;#toc-react-elementref&quot;&gt; &lt;code&gt;React.ElementRef&amp;lt;typeof Component&amp;gt;&lt;/code&gt; &lt;/a&gt;またはnull を使用して取得される要素インスタンスになる唯一の引数を取るか、または&lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html#adding-a-ref-to-a-dom-element&quot;&gt;マウント解除時にReactがref関数にnullを渡す&lt;/a&gt;ためです。</target>
        </trans-unit>
        <trans-unit id="d4ed83b0753888b656968d3936e2dd6c832b277c" translate="yes" xml:space="preserve">
          <source>The return type of function calls is currently not trivially inferable (due to features like polymorphism, overloading etc.). Their result needs to be annotated and so you&amp;rsquo;d see the following error:</source>
          <target state="translated">関数呼び出しの戻り値の型は、現在、自明に推測することはできません（ポリモーフィズム、オーバーロードなどの機能のため）。結果に注釈を付ける必要があるため、次のエラーが表示されます。</target>
        </trans-unit>
        <trans-unit id="5ec9470d19e8edaa8b9faed31b8b1054cafb7447" translate="yes" xml:space="preserve">
          <source>The rule to remember with React children is that if you have no children then &lt;code&gt;props.children&lt;/code&gt; will not be set, if you have one single child then &lt;code&gt;props.children&lt;/code&gt; will be set to exactly that value, and if you have two or more children then &lt;code&gt;props.children&lt;/code&gt; will be a new array of those values.</source>
          <target state="translated">Reactの子で覚えておくべきルールは、子がない場合は &lt;code&gt;props.children&lt;/code&gt; は設定されず、1つの子がある場合は &lt;code&gt;props.children&lt;/code&gt; はその値に正確に設定され、2つ以上の子がある場合は &lt;code&gt;props.children&lt;/code&gt; はこれらの値の新しい配列になります。</target>
        </trans-unit>
        <trans-unit id="8a4824f1afb35e479739e160a81e69708d8ef1aa" translate="yes" xml:space="preserve">
          <source>The same holds for more complex assignment patterns like</source>
          <target state="translated">のようなより複雑な割り当てパターンについても同じことが言えます。</target>
        </trans-unit>
        <trans-unit id="fb6cae9d717814c0ee942c2f77703ca8ec47aca7" translate="yes" xml:space="preserve">
          <source>The second is when the left-hand-side could be nullish, but the short-circuiting behavior of &lt;code&gt;?.&lt;/code&gt; is sufficient to handle it anyway:</source>
          <target state="translated">2つ目は、左側が無効になる可能性がある場合ですが、 &lt;code&gt;?.&lt;/code&gt; 短絡動作です。とにかくそれを処理するのに十分です：</target>
        </trans-unit>
        <trans-unit id="dd5b733400ddf864761d4b603d7eedbf4fe23de9" translate="yes" xml:space="preserve">
          <source>The solution here is to move the if check in the &lt;code&gt;forEach&lt;/code&gt;, or to assign the &lt;code&gt;age&lt;/code&gt; to an intermediate variable.</source>
          <target state="translated">ここでの解決策は、中かどうかを確認を動かすことである &lt;code&gt;forEach&lt;/code&gt; 、または割り当てるには、 &lt;code&gt;age&lt;/code&gt; 中間変数に。</target>
        </trans-unit>
        <trans-unit id="793214c4162efec809460a089d3515988a580153" translate="yes" xml:space="preserve">
          <source>The syntax of the block matches the syntax of object types and has all of the same features.</source>
          <target state="translated">ブロックの構文はオブジェクト型の構文と一致しており、すべて同じ機能を持っています。</target>
        </trans-unit>
        <trans-unit id="9cfb3fe3a8ca2679172f7460529c617ce30b2448" translate="yes" xml:space="preserve">
          <source>The type for &lt;code&gt;children&lt;/code&gt; is a function that takes in some object type and returns a &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; which is the type for any value that can be rendered by React. A &lt;code&gt;children&lt;/code&gt; function does not need to return &lt;a href=&quot;../types#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt;. It could return any type, but in this case &lt;code&gt;react-router&lt;/code&gt; wants to render the result returned by the &lt;code&gt;children&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;children&lt;/code&gt; のタイプは、いくつかのオブジェクトタイプを&lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt;で、Reactでレンダリングできる任意の値のタイプであるReact.Nodeを返す関数です。 &lt;code&gt;children&lt;/code&gt; 機能は、返す必要はありません&lt;a href=&quot;../types#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; を&lt;/a&gt;。任意のタイプを返すことができますが、この場合、 &lt;code&gt;react-router&lt;/code&gt; は、 &lt;code&gt;children&lt;/code&gt; 関数によって返された結果をレンダリングしたいと考えています。</target>
        </trans-unit>
        <trans-unit id="e26f0c3b68e62adaf93121b472c68d0c8f76d159" translate="yes" xml:space="preserve">
          <source>The type of the &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;ref prop on React elements&lt;/a&gt;. &lt;code&gt;React.Ref&amp;lt;typeof Component&amp;gt;&lt;/code&gt; could be a string or a ref function.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;React要素の参照プロップ&lt;/a&gt;のタイプ。 &lt;code&gt;React.Ref&amp;lt;typeof Component&amp;gt;&lt;/code&gt; は、文字列またはref関数にすることができます。</target>
        </trans-unit>
        <trans-unit id="4218f62d2ad5c72e63a98ec879dc92c04a46ac00" translate="yes" xml:space="preserve">
          <source>The type of the key prop on React elements. It is a union of strings and numbers defined as:</source>
          <target state="translated">React要素のキープロップの型。として定義されている文字列と数値の組み合わせです。</target>
        </trans-unit>
        <trans-unit id="67e5a93b06a1471f36d4271abfe153e052448938" translate="yes" xml:space="preserve">
          <source>The type of this function will be</source>
          <target state="translated">この関数の型は</target>
        </trans-unit>
        <trans-unit id="9d3cd96ca03492da9df4ce4513f536c1b74f86f6" translate="yes" xml:space="preserve">
          <source>The type-specific variants are useful for specifying that some types of sketchy null checks are acceptable while others should be errors/warnings. For example, if you want to allow boolean sketchy null checks (for the pattern of treating undefined optional booleans as false) but forbid other types of sketchy null checks, you can do so with this &lt;code&gt;.flowconfig&lt;/code&gt;&lt;code&gt;[lints]&lt;/code&gt; section:</source>
          <target state="translated">タイプ固有のバリアントは、一部のタイプの不完全なnullチェックを許容できる一方で、他のタイプはエラー/警告であることを指定するのに役立ちます。たとえば、ブールの不完全なnullチェック（未定義のオプションのブールをfalseとして扱うパターン）を許可したいが、他のタイプの不完全なnullチェックを禁止したい場合は、次の &lt;code&gt;.flowconfig&lt;/code&gt; &lt;code&gt;[lints]&lt;/code&gt; セクションを使用できます。</target>
        </trans-unit>
        <trans-unit id="62c2f90618d60a77f31571f70171c3abffcad492" translate="yes" xml:space="preserve">
          <source>The types-first signature extractor will not pick up subsequent update of an exported let-bound variables. Consider the example</source>
          <target state="translated">型優先シグネチャ抽出器は、エクスポートされたlet-bound変数の後続の更新を拾いません。例を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="6e42194738022b79f11b671ad7ae0139eab4cfde" translate="yes" xml:space="preserve">
          <source>The value itself can also be an expression:</source>
          <target state="translated">値自体が式になることもあります。</target>
        </trans-unit>
        <trans-unit id="a9386266d754633b2348817655aa4135672d2a80" translate="yes" xml:space="preserve">
          <source>The workaround here might be to turn your object into an &lt;em&gt;unsealed object&lt;/em&gt;.</source>
          <target state="translated">ここでの回避策は、オブジェクトを&lt;em&gt;封印さ&lt;/em&gt;れてい&lt;em&gt;ないオブジェクトにすること&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="6ba1aa455c617f9487799c55083af5aee022c88f" translate="yes" xml:space="preserve">
          <source>Then Flow will instead look for the file extensions &lt;code&gt;.foo&lt;/code&gt; and &lt;code&gt;.bar&lt;/code&gt;.</source>
          <target state="translated">次に、Flowは代わりにファイル拡張子 &lt;code&gt;.foo&lt;/code&gt; および &lt;code&gt;.bar&lt;/code&gt; を探します。</target>
        </trans-unit>
        <trans-unit id="16315533799a2def071bace787cce1d7a9a11029" translate="yes" xml:space="preserve">
          <source>Then Flow will look in directories named &lt;code&gt;node_modules&lt;/code&gt; or &lt;code&gt;custom_node_modules&lt;/code&gt;.</source>
          <target state="translated">次に、フローは &lt;code&gt;node_modules&lt;/code&gt; またはcustom_node_modulesという名前のディレクトリを調べ &lt;code&gt;custom_node_modules&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a695f40c07e9301bce62dd550ff93b6b48cf54b" translate="yes" xml:space="preserve">
          <source>Then add &lt;code&gt;flow&lt;/code&gt; to your Babel presets config.</source>
          <target state="translated">次に、Babelプリセット設定に &lt;code&gt;flow&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="bbfbb8a4c24c2122ec36dde61b7e1b8b853e31ea" translate="yes" xml:space="preserve">
          <source>Then to type a thunk action creator, add a return type of a &lt;code&gt;ThunkAction&lt;/code&gt; to your action creator.</source>
          <target state="translated">次に、サンクアクションクリエーターを入力するには、アクションクリエーターに戻り値のタイプの &lt;code&gt;ThunkAction&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="2d95f939b9b75dc6ef39e9b74bf9e89365c8618f" translate="yes" xml:space="preserve">
          <source>Then to type the action creator, just add a return type of the appropriate action.</source>
          <target state="translated">そして、アクションの作成者をタイプするには、適切なアクションのリターン型を追加するだけです。</target>
        </trans-unit>
        <trans-unit id="8d0d1639f463f57d4ca23faf1c9cada63360b1c0" translate="yes" xml:space="preserve">
          <source>Then when Flow checks the project in &lt;code&gt;/path/to/root&lt;/code&gt;, it will read and watch</source>
          <target state="translated">次に、Flowが &lt;code&gt;/path/to/root&lt;/code&gt; でプロジェクトをチェックするとき、それは読み取って監視します</target>
        </trans-unit>
        <trans-unit id="5d4c41383342278b4baf1bc8936c93b77b60516b" translate="yes" xml:space="preserve">
          <source>There are a number of different places where generic types appear in syntax.</source>
          <target state="translated">シンタックスの中でジェネリック型が登場する場所はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="416eb69d14d7c0984bf388d12cfb15f4c4cb73f0" translate="yes" xml:space="preserve">
          <source>There are also more specific synthetic event types like &lt;code&gt;SyntheticKeyboardEvent&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;SyntheticMouseEvent&amp;lt;T&amp;gt;&lt;/code&gt;, or &lt;code&gt;SyntheticTouchEvent&amp;lt;T&amp;gt;&lt;/code&gt;. The &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; types all take a single type argument. The type of the HTML element the event handler was placed on.</source>
          <target state="translated">&lt;code&gt;SyntheticKeyboardEvent&amp;lt;T&amp;gt;&lt;/code&gt; 、 &lt;code&gt;SyntheticMouseEvent&amp;lt;T&amp;gt;&lt;/code&gt; 、または &lt;code&gt;SyntheticTouchEvent&amp;lt;T&amp;gt;&lt;/code&gt; ような、より具体的な合成イベントタイプもあります。 &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; の型はすべて、単一の型引数を取ります。イベントハンドラーが配置されたHTML要素のタイプ。</target>
        </trans-unit>
        <trans-unit id="1787b085e796793d008332b01f6a6da8bb5275b0" translate="yes" xml:space="preserve">
          <source>There are many different types in Flow, some of these types behave differently than others. These differences make sense for that particular type but not for others.</source>
          <target state="translated">Flowには多くの異なるタイプがありますが、その中には他のタイプとは異なる挙動をするものもあります。これらの違いは、その特定のタイプには意味がありますが、他のタイプにはありません。</target>
        </trans-unit>
        <trans-unit id="bf3db35b680beed72ddb758d9747774831b6fb79" translate="yes" xml:space="preserve">
          <source>There are only a couple of scenarios where you might consider using &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">次のシナリオの &lt;code&gt;any&lt;/code&gt; を使用することを検討する可能性があります：</target>
        </trans-unit>
        <trans-unit id="6aaa00344637c45d30679cf3abd801a1db746b96" translate="yes" xml:space="preserve">
          <source>There are other cases where this happens, and they might be harder to understand. You&amp;rsquo;ll get an error like &lt;code&gt;Missing type annotation for U&lt;/code&gt; For instance, you wrote this &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiDGsB2BnALqAhgE4F4CeoAvKANoDkeNANKDQEY0C6iApgB4AOsArjRZcAcy7ouBAJYoAgkVIV8SkgDoAtnj4AKPBQB8+AJRA&quot;&gt;code&lt;/a&gt;:</source>
          <target state="translated">これが発生する他のケースがあり、それらは理解するのが難しいかもしれません。 &lt;code&gt;Missing type annotation for U&lt;/code&gt; などのエラーが発生します。たとえば、次の&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQiDGsB2BnALqAhgE4F4CeoAvKANoDkeNANKDQEY0C6iApgB4AOsArjRZcAcy7ouBAJYoAgkVIV8SkgDoAtnj4AKPBQB8+AJRA&quot;&gt;コードを記述したとします&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4e04cbaf68e5bad49ef31cbab0ae229a010af35" translate="yes" xml:space="preserve">
          <source>There are some Babel plugins which will generate &lt;code&gt;PropTypes&lt;/code&gt; from Flow types such as &lt;a href=&quot;https://github.com/thejameskyle/babel-plugin-react-flow-props-to-prop-types&quot;&gt;&lt;code&gt;babel-plugin-react-flow-props-to-prop-types&lt;/code&gt;&lt;/a&gt; if you want both static and runtime checks.</source>
          <target state="translated">静的チェックとランタイムチェックの両方が必要&lt;a href=&quot;https://github.com/thejameskyle/babel-plugin-react-flow-props-to-prop-types&quot;&gt; &lt;code&gt;babel-plugin-react-flow-props-to-prop-types&lt;/code&gt; &lt;/a&gt;場合は、Babel -plugin-react-flow-props-to-prop-typesなどのフロータイプから &lt;code&gt;PropTypes&lt;/code&gt; を生成するいくつかのBabelプラグインがあります。</target>
        </trans-unit>
        <trans-unit id="05f1bf8a574169e2b0cbcee1bdb8f70d3d1115e5" translate="yes" xml:space="preserve">
          <source>There are three forms of functions that each have their own slightly different syntax.</source>
          <target state="translated">関数には3つの形式があり、それぞれが微妙に異なる構文を持っています。</target>
        </trans-unit>
        <trans-unit id="ee47d349aa7bd1ef38439d36fc72e0cdd36c9114" translate="yes" xml:space="preserve">
          <source>There are three ways which Flow can use to tell which files the user cares about.</source>
          <target state="translated">Flowでは、ユーザーがどのファイルを気にしているかを伝えるために3つの方法があります。</target>
        </trans-unit>
        <trans-unit id="4e2987ad3c65445a4b5f525f040f6b2d00300b6c" translate="yes" xml:space="preserve">
          <source>There are two possible use cases, depending on whether an implementation file exists or not.</source>
          <target state="translated">実装ファイルが存在するかどうかによって、2つの使用例が考えられます。</target>
        </trans-unit>
        <trans-unit id="bc6225a3f37590ec533fb885e85a5169bfedf04f" translate="yes" xml:space="preserve">
          <source>There are two potential reasons:</source>
          <target state="translated">考えられる理由は2つあります。</target>
        </trans-unit>
        <trans-unit id="fc65a65476288080ee29ba1be6fd72bb6d6711c0" translate="yes" xml:space="preserve">
          <source>There are two primary pieces of the syntax: type includes and type annotations.</source>
          <target state="translated">構文には、インクルード型と型注釈という2つの主要な部分があります。</target>
        </trans-unit>
        <trans-unit id="dcd202d61a19f5fccfdf0c23e9bd5cbafd620669" translate="yes" xml:space="preserve">
          <source>There are two ways which Flow can use to tell which files the user cares about.</source>
          <target state="translated">Flowでは、ユーザーが気になるファイルを伝えるために2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="fb5471e40283f41215cba92d35f5766a72606428" translate="yes" xml:space="preserve">
          <source>There is a little bit more to the definition of &lt;code&gt;React.StatelessFunctionalComponent&amp;lt;Props&amp;gt;&lt;/code&gt; for context and props.</source>
          <target state="translated">コンテキストとプロップの &lt;code&gt;React.StatelessFunctionalComponent&amp;lt;Props&amp;gt;&lt;/code&gt; 定義にはもう少しあります。</target>
        </trans-unit>
        <trans-unit id="bb1108b33f08694a9173b9d3961f8db88797e3f6" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a special type of union in Flow known as a &amp;ldquo;disjoint union&amp;rdquo; which can be used in &lt;a href=&quot;https://flow.org/en/lang/refinements/&quot;&gt;refinements&lt;/a&gt;. These disjoint unions are made up of any number of object types which are each tagged by a single property.</source>
          <target state="translated">Flowには、「ディスジョイントユニオン」と呼ばれる特殊なタイプのユニオンがあり、これを&lt;a href=&quot;https://flow.org/en/lang/refinements/&quot;&gt;リファインメント&lt;/a&gt;で使用できます。これらのばらばらの共用体は、それぞれが単一のプロパティによってタグ付けされた、任意の数のオブジェクトタイプで構成されています。</target>
        </trans-unit>
        <trans-unit id="b519d9ef0909b18ff9e1aa56c6579a08789cbdf3" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a straightforward way to get around this. Store the value before calling another method and use the stored value instead. This way you can prevent the refinement from invalidating.</source>
          <target state="translated">これを回避する簡単な方法があります。別のメソッドを呼び出す前に値を保存し、代わりに保存された値を使用します。これにより、絞り込みが無効になるのを防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="5932b1e94eef91ff83b30936f3c0165f2887a0a9" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also a slightly shorter form of this syntax: &lt;code&gt;Type[]&lt;/code&gt;.</source>
          <target state="translated">この構文には、少し短い形式の &lt;code&gt;Type[]&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="c33c60a371f4bbf35c4a6734c388e9cc2e847eac" translate="yes" xml:space="preserve">
          <source>These are &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp&quot;&gt;OCaml regular expressions&lt;/a&gt;.</source>
          <target state="translated">これらは&lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp&quot;&gt;OCamlの正規表現&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="bf1350e4fbb26ae0f7f95072f456f487f37767ce" translate="yes" xml:space="preserve">
          <source>These are &lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp&quot;&gt;OCaml regular expressions&lt;/a&gt;. Use &lt;code&gt;\(&lt;/code&gt; and &lt;code&gt;\)&lt;/code&gt; (slashes required!) to create a capturing group, which you can refer to in the replacement pattern as &lt;code&gt;\1&lt;/code&gt; (up to &lt;code&gt;\9&lt;/code&gt;).</source>
          <target state="translated">これらは&lt;a href=&quot;http://caml.inria.fr/pub/docs/manual-ocaml/libref/Str.html#TYPEregexp&quot;&gt;OCamlの正規表現&lt;/a&gt;です。使用 &lt;code&gt;\(&lt;/code&gt; と &lt;code&gt;\)&lt;/code&gt; （スラッシュが必要！）あなたのように交換用のパターンで参照することができキャプチャグループ、作成するために、 &lt;code&gt;\1&lt;/code&gt; （最大 &lt;code&gt;\9&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="973bfa9d37cd36bbc104342639ed6decfd34c64c" translate="yes" xml:space="preserve">
          <source>These comments allow Flow to work in plain JavaScript files without any additional work.</source>
          <target state="translated">これらのコメントにより、Flowは追加の作業をすることなく、プレーンなJavaScriptファイルで動作するようになっています。</target>
        </trans-unit>
        <trans-unit id="d93265fc7d47ba2359b8e8723579e2877162a149" translate="yes" xml:space="preserve">
          <source>These regular expressions match against absolute paths. They probably should start with &lt;code&gt;.*&lt;/code&gt;</source>
          <target state="translated">これらの正規表現は、絶対パスと照合します。おそらく &lt;code&gt;.*&lt;/code&gt; 始まるはずです。</target>
        </trans-unit>
        <trans-unit id="e82167070fabc30781330eea12f26f96e5cc3459" translate="yes" xml:space="preserve">
          <source>These special files use the same &lt;code&gt;.js&lt;/code&gt; extension as normal JS code, but they are placed in a directory called &lt;code&gt;flow-typed&lt;/code&gt; in the root directory of your project. Placement in this directory tells Flow to interpret them as libdefs rather than normal JS files.</source>
          <target state="translated">これらの特殊ファイルは、通常のJSコードと同じ &lt;code&gt;.js&lt;/code&gt; 拡張子を使用しますが、プロジェクトのルートディレクトリにある &lt;code&gt;flow-typed&lt;/code&gt; と呼ばれるディレクトリに配置されます。このディレクトリに配置すると、Flowは通常のJSファイルではなくlibdefsとして解釈するようになります。</target>
        </trans-unit>
        <trans-unit id="420387e05d0ef5c191c2b528df67882573697852" translate="yes" xml:space="preserve">
          <source>These three are the most common categories of types. They will make up the majority of the types you&amp;rsquo;ll be writing.</source>
          <target state="translated">これらの3つは、タイプの最も一般的なカテゴリです。それらはあなたが書くタイプの大部分を構成します。</target>
        </trans-unit>
        <trans-unit id="521ca96243c563b5695a0817345b1aaac530fbea" translate="yes" xml:space="preserve">
          <source>These type aliases can be used anywhere a type can be used.</source>
          <target state="translated">これらの型エイリアスは、型が使用できる場所であればどこでも使用することができます。</target>
        </trans-unit>
        <trans-unit id="03c735f166579e7b6a2b1df8b0b57996603576f1" translate="yes" xml:space="preserve">
          <source>These types are all exported as named type exports from the &lt;code&gt;react&lt;/code&gt; module. If you want to access them as members on the &lt;code&gt;React&lt;/code&gt; object (e.g. &lt;a href=&quot;#toc-react-node&quot;&gt;&lt;code&gt;React.Node&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#toc-react-statelessfunctionalcomponent&quot;&gt;&lt;code&gt;React.StatelessFunctionalComponent&lt;/code&gt;&lt;/a&gt;) and you are importing React as an ES module then you should import &lt;code&gt;React&lt;/code&gt; as a namespace:</source>
          <target state="translated">これらのタイプはすべて、 &lt;code&gt;react&lt;/code&gt; モジュールから名前付きタイプのエクスポートとしてエクスポートされます。 &lt;code&gt;React&lt;/code&gt; オブジェクト（&lt;a href=&quot;#toc-react-node&quot;&gt; &lt;code&gt;React.Node&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#toc-react-statelessfunctionalcomponent&quot;&gt; &lt;code&gt;React.StatelessFunctionalComponent&lt;/code&gt; など&lt;/a&gt;）のメンバーとしてそれらにアクセスする場合、Reactを ESモジュールとしてインポートする場合は、 &lt;code&gt;React&lt;/code&gt; を名前空間としてインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="38dbce068fe67847b4312ef7a49844b1a3730edb" translate="yes" xml:space="preserve">
          <source>These unknown types are less common, but are still useful at times.</source>
          <target state="translated">これらの未知のタイプはあまり一般的ではありませんが、それでも時々役に立つことがあります。</target>
        </trans-unit>
        <trans-unit id="630fbbe3db84f8cd1f22f033444bd46fd4f788d9" translate="yes" xml:space="preserve">
          <source>These values can be used in many different ways:</source>
          <target state="translated">これらの値は、様々な方法で使用することができます。</target>
        </trans-unit>
        <trans-unit id="acee363f8ecdca8ebcbfe3c36617f3a858f460fa" translate="yes" xml:space="preserve">
          <source>These wrapper objects are rarely used.</source>
          <target state="translated">これらのラッパーオブジェクトはほとんど使われません。</target>
        </trans-unit>
        <trans-unit id="0ecb01f38d4891f3ba605fe10abbc133a33eebcb" translate="yes" xml:space="preserve">
          <source>Things to keep in mind:</source>
          <target state="translated">気をつけておきたいこと</target>
        </trans-unit>
        <trans-unit id="25df2f7528015bf66ff8cb5856b46ca9f89a989e" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;[declarations]&lt;/code&gt; section will parse in declaration mode:</source>
          <target state="translated">この &lt;code&gt;[declarations]&lt;/code&gt; セクションは、宣言モードで解析されます。</target>
        </trans-unit>
        <trans-unit id="633b00a02de45953dce9e17ff82080b18f32ddce" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;[ignore]&lt;/code&gt; section will ignore:</source>
          <target state="translated">この &lt;code&gt;[ignore]&lt;/code&gt; セクションは無視します。</target>
        </trans-unit>
        <trans-unit id="881b9060a283396b0ef0fc92c8d4d847c624170a" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;[untyped]&lt;/code&gt; section will parse:</source>
          <target state="translated">この &lt;code&gt;[untyped]&lt;/code&gt; セクションは解析します：</target>
        </trans-unit>
        <trans-unit id="6523434d73a5cea939dbb47f88e915c46aa3c5df" translate="yes" xml:space="preserve">
          <source>This affects Linux only.</source>
          <target state="translated">これはLinuxのみに影響します。</target>
        </trans-unit>
        <trans-unit id="543aa46e91339d316364681d2b7a939cdad920b8" translate="yes" xml:space="preserve">
          <source>This allows you to pass a less specific type in place of that property.</source>
          <target state="translated">これにより、そのプロパティの代わりに、あまり特定されていない型を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="1766dd7d0a89406504a02b5ace1d77e4b69c5963" translate="yes" xml:space="preserve">
          <source>This allows you to pass a more specific type in place of that property.</source>
          <target state="translated">これにより、そのプロパティの代わりに、より特定の型を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="2bd174f439abda4ebf248fb0e156219e91c6b759" translate="yes" xml:space="preserve">
          <source>This can be especially useful for referring to the type of React props, or, even the entire &lt;code&gt;props&lt;/code&gt; type itself.</source>
          <target state="translated">これは、Reactプロップのタイプ、または &lt;code&gt;props&lt;/code&gt; 全体のタイプ自体を参照する場合に特に役立ちます。</target>
        </trans-unit>
        <trans-unit id="7b5bf94cd27d17a08f16ee047fe0e258d2090c51" translate="yes" xml:space="preserve">
          <source>This case happens often when you use &lt;code&gt;array.map()&lt;/code&gt; such as in:</source>
          <target state="translated">次のように &lt;code&gt;array.map()&lt;/code&gt; を使用すると、このケースが頻繁に発生します。</target>
        </trans-unit>
        <trans-unit id="79978b89a7e3ee94ff65dc558994d8b9943253b3" translate="yes" xml:space="preserve">
          <source>This code leads to a runtime type error, since we are attempting to perform a call on a number. Flow, however, does not flag an error here, because we have annotated variable &lt;code&gt;one&lt;/code&gt; as &lt;code&gt;any&lt;/code&gt;. Flow&amp;rsquo;s checking is effectively turned off whenever &lt;code&gt;any&lt;/code&gt; is involved, so it will silently allow the call. The use of this &lt;em&gt;unsafe&lt;/em&gt; type has rendered the type checker ineffective, and the coverage metric is here to surface this, by reporting all instances of &lt;code&gt;one&lt;/code&gt; as uncovered.</source>
          <target state="translated">番号に対して呼び出しを実行しようとしているため、このコードはランタイムタイプエラーにつながります。ただし、変数 &lt;code&gt;one&lt;/code&gt; に &lt;code&gt;any&lt;/code&gt; 注釈を付けているため、フローはここでエラーのフラグを立てません。フローのチェックは、関係する &lt;code&gt;any&lt;/code&gt; は常に事実上オフになっているため、サイレントに呼び出しを許可します。この&lt;em&gt;安全でない&lt;/em&gt;タイプを使用すると、タイプチェッカーが無効になります。カバレッジメトリックは、 &lt;code&gt;one&lt;/code&gt; インスタンスをすべてカバーされていないものとして報告することにより、これを明らかにします。</target>
        </trans-unit>
        <trans-unit id="f0b87f03b6d241cb8b45f84bd4bf0506c5abe6b1" translate="yes" xml:space="preserve">
          <source>This command first starts a background process that will check all &lt;a href=&quot;#toc-prepare-your-code-for-flow&quot;&gt;Flow files&lt;/a&gt; for errors. The background process continues running, monitoring changes to your code and checking those changes incrementally for errors.</source>
          <target state="translated">このコマンドは最初に、すべての&lt;a href=&quot;#toc-prepare-your-code-for-flow&quot;&gt;フローファイル&lt;/a&gt;のエラーをチェックするバックグラウンドプロセスを開始します。バックグラウンドプロセスは引き続き実行され、コードへの変更を監視し、それらの変更のエラーを段階的にチェックします。</target>
        </trans-unit>
        <trans-unit id="57498d0fa536623389bfd336daad29db2ae2dc08" translate="yes" xml:space="preserve">
          <source>This command uses types that Flow infers, to fill in positions that would otherwise raise &lt;em&gt;signature-verification&lt;/em&gt; failures. It will include the necessary type import statements, as long as the respective types are exported from their defining modules.</source>
          <target state="translated">このコマンドは、フローが推測するタイプを使用して、&lt;em&gt;署名検証の&lt;/em&gt;失敗を引き起こす可能性のある位置を埋めます。それぞれのタイプが定義モジュールからエクスポートされる限り、必要なタイプインポートステートメントが含まれます。</target>
        </trans-unit>
        <trans-unit id="00dd495b583130371ce040479335e5dc21959b5e" translate="yes" xml:space="preserve">
          <source>This command will transform files under &lt;code&gt;/path/to/folder&lt;/code&gt;. This does not need to be the root directory (the one containing &lt;code&gt;.flowconfig&lt;/code&gt;).</source>
          <target state="translated">このコマンドは、 &lt;code&gt;/path/to/folder&lt;/code&gt; の下のファイルを変換します。これはルートディレクトリ（ &lt;code&gt;.flowconfig&lt;/code&gt; を含むディレクトリ）である必要はありません。</target>
        </trans-unit>
        <trans-unit id="3d875274c3b689e4f7ad033af88961c28bd2f54a" translate="yes" xml:space="preserve">
          <source>This compiles to: &lt;code&gt;React.createElement(MyComponent, {}, '// some comment...', 42)&lt;/code&gt;. See how the comment is included in the element&amp;rsquo;s children? In this case &lt;code&gt;props.children&lt;/code&gt; would be &lt;code&gt;['// some comment...', 42]&lt;/code&gt; which includes the comment. To write comments in JSX use the following syntax:</source>
          <target state="translated">これは &lt;code&gt;React.createElement(MyComponent, {}, '// some comment...', 42)&lt;/code&gt; コンパイルされます。要素の子にコメントがどのように含まれているかを確認しますか？この場合、 &lt;code&gt;props.children&lt;/code&gt; は &lt;code&gt;['// some comment...', 42]&lt;/code&gt; を含む['// some comment ...'、42]になります。JSXでコメントを書き込むには、次の構文を使用します。</target>
        </trans-unit>
        <trans-unit id="1981415185918a76b00cd452a5e0eb6fd87253c8" translate="yes" xml:space="preserve">
          <source>This compiles to: &lt;code&gt;React.createElement(MyComponent, {}, 42, '  ')&lt;/code&gt;. (With the spaces!) See how the spaces show up as part of the children? In this case &lt;code&gt;props.children&lt;/code&gt; would be &lt;code&gt;[42, '  ']&lt;/code&gt; and &lt;em&gt;not&lt;/em&gt; the number 42. However, the following is fine:</source>
          <target state="translated">これは &lt;code&gt;React.createElement(MyComponent, {}, 42, ' ')&lt;/code&gt; コンパイルされます。（スペースあり！）スペースが子供たちの一部としてどのように表示されるか確認してください。この場合、 &lt;code&gt;props.children&lt;/code&gt; は &lt;code&gt;[42, ' ']&lt;/code&gt; で&lt;em&gt;あり&lt;/em&gt;、数値42ではあり&lt;em&gt;ません。&lt;/em&gt;ただし、以下は問題あり&lt;em&gt;ません&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="734dbfe930904c1dff5464c3868a3c58b214bbf9" translate="yes" xml:space="preserve">
          <source>This flag is in the form of a normal JavaScript comment annotated with &lt;code&gt;@flow&lt;/code&gt;. The Flow background process gathers all the files with this flag and uses the type information available from all of these files to ensure consistency and error free programming.</source>
          <target state="translated">このフラグは、 &lt;code&gt;@flow&lt;/code&gt; で注釈が付けられた通常のJavaScriptコメントの形式です。フローバックグラウンドプロセスは、このフラグが設定されたすべてのファイルを収集し、これらすべてのファイルから取得できるタイプ情報を使用して、一貫性とエラーのないプログラミングを保証します。</target>
        </trans-unit>
        <trans-unit id="e8107dcd86e50a45fb0aff78e434d3e405ffe634" translate="yes" xml:space="preserve">
          <source>This follows the same rule that when you pass in a single child then &lt;code&gt;props.children&lt;/code&gt; will be &lt;em&gt;exactly&lt;/em&gt; that value. Even though &lt;code&gt;[1, 2]&lt;/code&gt; is an array it is a single value and so &lt;code&gt;props.children&lt;/code&gt; will be &lt;em&gt;exactly&lt;/em&gt; that value. That is to say &lt;code&gt;props.children&lt;/code&gt; will be the array &lt;code&gt;[1, 2]&lt;/code&gt; and not an array of arrays.</source>
          <target state="translated">これは、単一の子を渡す際に、その同じルールは以下の &lt;code&gt;props.children&lt;/code&gt; はなります&lt;em&gt;正確に&lt;/em&gt;その値を。にもかかわらず &lt;code&gt;[1, 2]&lt;/code&gt; アレイはそれが単一の値であり、ある &lt;code&gt;props.children&lt;/code&gt; になり&lt;em&gt;、正確に&lt;/em&gt;その値。つまり、 &lt;code&gt;props.children&lt;/code&gt; は配列 &lt;code&gt;[1, 2]&lt;/code&gt; であり、配列の配列ではありません。</target>
        </trans-unit>
        <trans-unit id="d7ef0baedb6b23a6e6c0bc9c81182d27e5e3dc1d" translate="yes" xml:space="preserve">
          <source>This guide will teach you the syntax and semantics of all the different types you can have in Flow.</source>
          <target state="translated">このガイドでは、Flowで持つことができるすべての異なるタイプの構文とセマンティクスを学びます。</target>
        </trans-unit>
        <trans-unit id="096c3c9fc415cf70866aa9adcd243f084dfc276d" translate="yes" xml:space="preserve">
          <source>This includes the code into the syntax that Flow sees.</source>
          <target state="translated">これは、Flowが見る構文にコードが含まれています。</target>
        </trans-unit>
        <trans-unit id="d9fb28a17538a9106a3ad6a6bed152242ff6e4d8" translate="yes" xml:space="preserve">
          <source>This is Flow&amp;rsquo;s most abstract representation of a React component, and is most useful for writing HOCs and library definitions.</source>
          <target state="translated">これは、ReactコンポーネントのFlowの最も抽象的な表現であり、HOCとライブラリ定義を記述するのに最も役立ちます。</target>
        </trans-unit>
        <trans-unit id="9af90c0ecae6766788f603b8275d9514e3979ca9" translate="yes" xml:space="preserve">
          <source>This is a basic template for what your HOCs might look like. At runtime, this HOC doesn&amp;rsquo;t do anything at all. Let&amp;rsquo;s take a look at some more complex examples.</source>
          <target state="translated">これは、HOCがどのように見えるかの基本的なテンプレートです。実行時には、このHOCは何もしません。より複雑な例をいくつか見てみましょう。</target>
        </trans-unit>
        <trans-unit id="c365f2918438c7a6e1888b46e0b930bd53745fff" translate="yes" xml:space="preserve">
          <source>This is a kind of subtyping commonly referred to as &amp;ldquo;width subtyping&amp;rdquo; because a type that is &amp;ldquo;wider&amp;rdquo; (i.e., has more properties) is a subtype of a narrower type.</source>
          <target state="translated">これは、「幅が広い」（つまり、より多くのプロパティを持つ）型がより狭い型のサブタイプであるため、一般に「幅のサブタイプ」と呼ばれる一種のサブタイプです。</target>
        </trans-unit>
        <trans-unit id="75b065150ca9eda7d9b645bb02ec9b648bf937bd" translate="yes" xml:space="preserve">
          <source>This is a union of a class component or a stateless functional component. This is the type you want to use for functions that receive or return React components such as higher-order components or other utilities.</source>
          <target state="translated">クラスコンポーネントやステートレスな関数コンポーネントを組み合わせたものです。高次コンポーネントや他のユーティリティなど、Reactコンポーネントを受け取ったり返したりする関数に使いたいタイプです。</target>
        </trans-unit>
        <trans-unit id="eb111ed813f5032a53f03d0b631da3f19b265167" translate="yes" xml:space="preserve">
          <source>This is also okay because if something is using &lt;code&gt;SubClass&lt;/code&gt; as if it were a &lt;code&gt;BaseClass&lt;/code&gt; they would still have access to the same interface as before because &lt;code&gt;SanFrancisco&lt;/code&gt; is just a &lt;code&gt;City&lt;/code&gt; with a little more information.</source>
          <target state="translated">何かが &lt;code&gt;BaseClass&lt;/code&gt; であるかのようにSubClassを &lt;code&gt;SubClass&lt;/code&gt; ている場合でも、 &lt;code&gt;SanFrancisco&lt;/code&gt; はもう少し情報のある &lt;code&gt;City&lt;/code&gt; なので、以前と同じインターフェイスに引き続きアクセスできるため、これも問題ありません。</target>
        </trans-unit>
        <trans-unit id="ed9084ae2d3a6d3909814247a0a9d2fe5955a81d" translate="yes" xml:space="preserve">
          <source>This is an error because objects are mutable. The value referenced by the &lt;code&gt;employee&lt;/code&gt; variable is the same as the value referenced by the &lt;code&gt;person&lt;/code&gt; variable.</source>
          <target state="translated">オブジェクトは変更可能であるため、これはエラーです。で参照される値は &lt;code&gt;employee&lt;/code&gt; 変数が参照する値と同じである &lt;code&gt;person&lt;/code&gt; 変数。</target>
        </trans-unit>
        <trans-unit id="5b9e89f0566afa9b997d9c3c388578a1bf739bfd" translate="yes" xml:space="preserve">
          <source>This is an error in Flow because if you are expecting a &lt;code&gt;SanFrancisco&lt;/code&gt; and you get a &lt;code&gt;City&lt;/code&gt; you could be using something that only exists on &lt;code&gt;SanFrancisco&lt;/code&gt; which would cause an error at runtime.</source>
          <target state="translated">あなたが期待している場合ので、これはフロー内のエラーで &lt;code&gt;SanFrancisco&lt;/code&gt; 、あなたが取得する &lt;code&gt;City&lt;/code&gt; あなただけに存在する何か使用することができ &lt;code&gt;SanFrancisco&lt;/code&gt; 、実行時にエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="56976d17f40e185b38c5c6efa84d2af088f0b974" translate="yes" xml:space="preserve">
          <source>This is because classes in Flow are &lt;a href=&quot;https://flow.org/en/lang/nominal-structural&quot;&gt;nominally typed&lt;/a&gt;.</source>
          <target state="translated">これは、フローのクラスが&lt;a href=&quot;https://flow.org/en/lang/nominal-structural&quot;&gt;名目上型付けされているため&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="127badd88c854dba7d3f79ae45c90e45e0bab65a" translate="yes" xml:space="preserve">
          <source>This is because in Flow it is okay to pass an object value with more properties than the object type expects (because of width subtyping).</source>
          <target state="translated">これは、Flowではオブジェクト型が期待する以上のプロパティを持つオブジェクト値を渡しても問題ないからです(幅のサブタイプのため)。</target>
        </trans-unit>
        <trans-unit id="987cc1138d48992770da78cddf5c25e772ec1fb5" translate="yes" xml:space="preserve">
          <source>This is because the only refinements supported through &lt;code&gt;bar&lt;/code&gt; would be on &lt;code&gt;obj&lt;/code&gt; itself.</source>
          <target state="translated">これは、 &lt;code&gt;bar&lt;/code&gt; を介してサポートされる唯一の改良が &lt;code&gt;obj&lt;/code&gt; 自体にあるためです。</target>
        </trans-unit>
        <trans-unit id="a696e7fa8715b1a73c06f5c45c3a6a89c88aadac" translate="yes" xml:space="preserve">
          <source>This is different from the &lt;code&gt;[ignore]&lt;/code&gt; config section that causes matching files to be ignored by the module resolver, which inherently makes them un-typechecked, and also unresolvable by &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;. When ignored &lt;code&gt;[libs]&lt;/code&gt; must then be specified for each &lt;code&gt;import&lt;/code&gt; using &lt;code&gt;flow-typed&lt;/code&gt;, which may not always be desired.</source>
          <target state="translated">これは、一致するファイルがモジュールリゾルバによって無視される原因となる &lt;code&gt;[ignore]&lt;/code&gt; configセクションとは異なり、本質的に型チェックが解除され、 &lt;code&gt;import&lt;/code&gt; または &lt;code&gt;require&lt;/code&gt; によっても解決できません。無視された場合、 &lt;code&gt;flow-typed&lt;/code&gt; を使用して &lt;code&gt;import&lt;/code&gt; ごとに &lt;code&gt;[libs]&lt;/code&gt; を指定する必要がありますが、これは常に望ましいとは限りません。</target>
        </trans-unit>
        <trans-unit id="a3e3b48d7024605ecf73a60b4a059e305833ff81" translate="yes" xml:space="preserve">
          <source>This is extremely useful for expressing the return type of functions that manipulate objects values. You could use a similar approach (for instance) to provide the return type of bluebird&amp;rsquo;s &lt;a href=&quot;http://bluebirdjs.com/docs/api/promise.props.html&quot;&gt;&lt;code&gt;Promise.props&lt;/code&gt;&lt;/a&gt; function, which is like &lt;code&gt;Promise.all&lt;/code&gt; but takes an object as input.</source>
          <target state="translated">これは、オブジェクトの値を操作する関数の戻り値の型を表すのに非常に役立ちます。（たとえば）同様のアプローチを使用して、bluebirdの&lt;a href=&quot;http://bluebirdjs.com/docs/api/promise.props.html&quot;&gt; &lt;code&gt;Promise.props&lt;/code&gt; &lt;/a&gt;関数の戻り値の型を提供できます。これは、 &lt;code&gt;Promise.all&lt;/code&gt; に似ていますが、オブジェクトを入力として受け取ります。</target>
        </trans-unit>
        <trans-unit id="60dfb0118bc43aa84388f7d66bc4c2be8af7089f" translate="yes" xml:space="preserve">
          <source>This is okay because if something else in your program is using &lt;code&gt;SubClass&lt;/code&gt; as if it were a &lt;code&gt;BaseClass&lt;/code&gt;, it would still be using a &lt;code&gt;City&lt;/code&gt; and wouldn&amp;rsquo;t cause any issues.</source>
          <target state="translated">プログラムの他の何かが &lt;code&gt;BaseClass&lt;/code&gt; であるかのようにSubClassを &lt;code&gt;SubClass&lt;/code&gt; ている場合でも、 &lt;code&gt;City&lt;/code&gt; を使用しているため問題は発生しないため、これは問題ありません。</target>
        </trans-unit>
        <trans-unit id="def5148d9c559d37a047e98dc2513022553f61be" translate="yes" xml:space="preserve">
          <source>This is perfectly fine because if we pass in a more specific type we&amp;rsquo;ll still have all the information we need to be compatible with &lt;code&gt;Noun&lt;/code&gt;.</source>
          <target state="translated">より具体的なタイプを渡しても、 &lt;code&gt;Noun&lt;/code&gt; との互換性を維持するために必要なすべての情報を保持できるため、これはまったく問題ありません。</target>
        </trans-unit>
        <trans-unit id="424b976babef7901da66b2db61ee539c2a0be62a" translate="yes" xml:space="preserve">
          <source>This is the type of a React stateless functional component.</source>
          <target state="translated">これはReactのステートレス機能コンポーネントのタイプです。</target>
        </trans-unit>
        <trans-unit id="b2b862b3fcdd9450bc624dc8b8cf55e1f701d1ad" translate="yes" xml:space="preserve">
          <source>This is unsafe and not recommended. But it&amp;rsquo;s sometimes useful when you are doing something with a value which is very difficult or impossible to type and want to make sure that the result has the desired type.</source>
          <target state="translated">これは危険であり、推奨されません。しかし、タイプするのが非常に困難または不可能な値で何かを実行していて、結果が目的のタイプであることを確認したい場合には、これが役立つことがあります。</target>
        </trans-unit>
        <trans-unit id="35aa78e533f2578f7e162a36de338a1f47f6c0b2" translate="yes" xml:space="preserve">
          <source>This is useful when you need to use a read-only version of an object type you&amp;rsquo;ve already defined, without manually having to re-define and annotate each key as read-only. For example:</source>
          <target state="translated">これは、定義済みのオブジェクトタイプの読み取り専用バージョンを使用する必要がある場合に便利です。手動で各キーを再定義して、読み取り専用として注釈を付ける必要はありません。例えば：</target>
        </trans-unit>
        <trans-unit id="f4cb01bc5bdd818c1407e6cedc026d2b0b09c1ad" translate="yes" xml:space="preserve">
          <source>This is very handy, but sometimes you need to access the enum definition at runtime (i.e. at a value level).</source>
          <target state="translated">これは非常に便利ですが、時には実行時に(つまり値レベルで)enum定義にアクセスする必要があります。</target>
        </trans-unit>
        <trans-unit id="54f3db6a2015884e8473b3172c31c08a869daab0" translate="yes" xml:space="preserve">
          <source>This is where &lt;a href=&quot;../types#toc-react-config&quot;&gt;&lt;code&gt;React.Config&amp;lt;Props, DefaultProps&amp;gt;&lt;/code&gt;&lt;/a&gt; comes in handy! We can use the type for Props and DefaultProps to calculate the &lt;code&gt;Config&lt;/code&gt; type for our component.</source>
          <target state="translated">ここで、&lt;a href=&quot;../types#toc-react-config&quot;&gt; &lt;code&gt;React.Config&amp;lt;Props, DefaultProps&amp;gt;&lt;/code&gt; &lt;/a&gt;が役に立ちます。PropsとDefaultPropsのタイプを使用して、コンポーネントの &lt;code&gt;Config&lt;/code&gt; タイプを計算できます。</target>
        </trans-unit>
        <trans-unit id="21ae5e6ce6468f7ff3f32ccfa0dd3f8fb2f7bcea" translate="yes" xml:space="preserve">
          <source>This is where &lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt; comes in handy.</source>
          <target state="translated">ここで &lt;code&gt;ObjMap&amp;lt;T, F&amp;gt;&lt;/code&gt; が役に立ちます。</target>
        </trans-unit>
        <trans-unit id="ee856278c549261688abdbd19d4ddec7e5efdc46" translate="yes" xml:space="preserve">
          <source>This lint setting is ignored when &lt;code&gt;exact_by_default&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;exact_by_default&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; に設定されている場合、このlint設定は無視されます。</target>
        </trans-unit>
        <trans-unit id="a70889c6b7d22baa7cf64ab4c9b4c3c93d6d9191" translate="yes" xml:space="preserve">
          <source>This makes Flow treat &lt;code&gt;require('image!foo.jpg')&lt;/code&gt; as if it were &lt;code&gt;require('ImageStub')&lt;/code&gt;.</source>
          <target state="translated">これにより、フロー &lt;code&gt;require('image!foo.jpg')&lt;/code&gt; を &lt;code&gt;require('ImageStub')&lt;/code&gt; であるかのように扱います。</target>
        </trans-unit>
        <trans-unit id="e23feb9278c999088a311838ae5b7031bb5b5bf1" translate="yes" xml:space="preserve">
          <source>This makes it clear to the reader that &lt;code&gt;bar&lt;/code&gt; is not a potentially nullish property.</source>
          <target state="translated">これは、 &lt;code&gt;bar&lt;/code&gt; が潜在的に無効なプロパティではないことを読者に明らかにします。</target>
        </trans-unit>
        <trans-unit id="76437fdbf44079b1c571bd4124ab2ff68199ec3a" translate="yes" xml:space="preserve">
          <source>This means that a shorter tuple can&amp;rsquo;t be used in place of a longer one.</source>
          <target state="translated">つまり、長いタプルの代わりに短いタプルを使用することはできません。</target>
        </trans-unit>
        <trans-unit id="ebff5f8c600e3fd9834aa943d918c1bfbd8d2dbe" translate="yes" xml:space="preserve">
          <source>This means that reads from unsealed objects with no matching writes are never checked. This is an unsafe behavior of Flow which may be improved in the future.</source>
          <target state="translated">これは、一致する書き込みのない非封印オブジェクトからの読み込みがチェックされないことを意味します。これはFlowの安全でない動作であり、将来的には改善される可能性があります。</target>
        </trans-unit>
        <trans-unit id="3bf9058b929ae73030823387d719318f0032a9fd" translate="yes" xml:space="preserve">
          <source>This means that the following 2 types are equivalent:</source>
          <target state="translated">つまり、以下の2種類が該当します。</target>
        </trans-unit>
        <trans-unit id="6784af09c850d7330fc9ffa9c72f9fa8a86cc84a" translate="yes" xml:space="preserve">
          <source>This often means figuring out if the value you are passing in is a subtype of the value you are expecting.</source>
          <target state="translated">これは多くの場合、あなたが渡している値があなたが期待している値のサブタイプであるかどうかを調べることを意味します。</target>
        </trans-unit>
        <trans-unit id="2cd8bc2873ab259581a052bdf16376541801c36c" translate="yes" xml:space="preserve">
          <source>This option configures the maximum possible size for the shared heap. You should most likely not need to configure this, as it doesn&amp;rsquo;t really affect how much RSS Flow uses. However, if you are working on a massive codebase you might see the following error after init: &amp;ldquo;Heap init size is too close to max heap size; GC will never get triggered!&amp;rdquo; In this case, you may need to increase the size of the heap.</source>
          <target state="translated">このオプションは、共有ヒープの可能な最大サイズを構成します。RSSフローの使用量には実際には影響しないため、これを構成する必要はほとんどありません。ただし、大規模なコードベースで作業している場合、initの後に次のエラーが表示されることがあります。「ヒープのinitサイズが最大ヒープサイズに近すぎます。GCがトリガーされることはありません！」この場合、ヒープのサイズを増やす必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="b218d95c59f706fc5a5e4f4c250e3a7ed23a95c4" translate="yes" xml:space="preserve">
          <source>This option is set to &lt;code&gt;true&lt;/code&gt; by default, since it is implied by &lt;a href=&quot;#toc-types-first-boolean&quot;&gt;&lt;code&gt;types_first&lt;/code&gt;&lt;/a&gt;, but the option is useful on its own when upgrading a project from classic mode to types-first mode.</source>
          <target state="translated">このオプションは&lt;a href=&quot;#toc-types-first-boolean&quot;&gt; &lt;code&gt;types_first&lt;/code&gt; &lt;/a&gt;によって暗示されるため、デフォルトで &lt;code&gt;true&lt;/code&gt; に設定されていますが、プロジェクトをクラシックモードからtypes-firstモードにアップグレードする場合、このオプションはそれ自体で役立ちます。</target>
        </trans-unit>
        <trans-unit id="9586cb7b0444ddcbaf378ece59924e71eed799e4" translate="yes" xml:space="preserve">
          <source>This option lets you alias &lt;code&gt;any&lt;/code&gt; with a given string. This is useful for explaining why you&amp;rsquo;re using &lt;code&gt;any&lt;/code&gt;. For example, let&amp;rsquo;s say you sometimes want to sometimes use &lt;code&gt;any&lt;/code&gt; to suppress an error and sometimes to mark a TODO. Your code might look like</source>
          <target state="translated">このオプションを使用すると、任意の文字列で &lt;code&gt;any&lt;/code&gt; エイリアスを作成できます。これは、あなたが使用している理由を説明するために有用である &lt;code&gt;any&lt;/code&gt; 。たとえば、 &lt;code&gt;any&lt;/code&gt; を使用してエラーを抑制したり、TODOにマークを付けたりしたい場合があります。コードは次のようになります</target>
        </trans-unit>
        <trans-unit id="0f8104fc2a3ba71732d91aefe2ba32da9e1bba10" translate="yes" xml:space="preserve">
          <source>This output means that 5 out of the 10 nodes of this program were inferred to have type &lt;code&gt;any&lt;/code&gt;. To see exactly which parts are uncovered you can also pass one of the following flags:</source>
          <target state="translated">この出力は、このプログラムの10ノードのうち5ノードがタイプ &lt;code&gt;any&lt;/code&gt; であると推測されたことを意味します。カバーされていないパーツを正確に確認するには、次のフラグのいずれかを渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="36407b4a8671f76cf48e67ecd38443356cf43c1d" translate="yes" xml:space="preserve">
          <source>This pattern is also not limited to function children. You could also pass in arbitrary object or class types.</source>
          <target state="translated">また、このパターンは関数の子に限定されません。任意のオブジェクトやクラスの型を渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="8daebbe8ae6fc42b982d8e4fe22459a7a10cd94c" translate="yes" xml:space="preserve">
          <source>This represents any node that can be rendered in a React application. &lt;code&gt;React.Node&lt;/code&gt; can be null, a boolean, a number, a string, a React element, or an array of any of those types recursively.</source>
          <target state="translated">これは、Reactアプリケーションでレンダリングできるすべてのノードを表します。 &lt;code&gt;React.Node&lt;/code&gt; は、null、ブール値、数値、文字列、React要素、またはこれらのタイプの配列を再帰的に指定できます。</target>
        </trans-unit>
        <trans-unit id="752249d3acac833c3c21ce430f38863e1937ed27" translate="yes" xml:space="preserve">
          <source>This syntax is also available in a &lt;code&gt;flow-include&lt;/code&gt; form.</source>
          <target state="translated">この構文は、 &lt;code&gt;flow-include&lt;/code&gt; 形式でも使用できます。</target>
        </trans-unit>
        <trans-unit id="5b31f92efc0a4da4dd28fb6304800cf7cd7fbb9c" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;PI&lt;/code&gt; global variable &amp;ndash; which, in this case, is a &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">これにより、プロジェクト内のすべてのコードが &lt;code&gt;PI&lt;/code&gt; グローバル変数（この場合は &lt;code&gt;number&lt;/code&gt; を参照できることがFlowに通知されます。</target>
        </trans-unit>
        <trans-unit id="7f16bca30984be4eadbc92268c71095b6f69d5a4" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;URL&lt;/code&gt; global class. Note that this class definition does not have any implementation details &amp;ndash; it exclusively defines the interface of the class.</source>
          <target state="translated">これにより、プロジェクト内のすべてのコードが &lt;code&gt;URL&lt;/code&gt; グローバルクラスを参照できるようになります。このクラス定義には実装の詳細が含まれていないことに注意してください。クラスのインターフェースのみを定義します。</target>
        </trans-unit>
        <trans-unit id="fe10f9e40b8844cde008f22e6f7e27a41dd5807d" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;UserID&lt;/code&gt; global type &amp;ndash; which, in this case, is just an alias for &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">これは、プロジェクト内のすべてのコードが &lt;code&gt;UserID&lt;/code&gt; グローバルタイプ（この場合は、 &lt;code&gt;number&lt;/code&gt; のエイリアス）を参照できることをFlowに伝えます。</target>
        </trans-unit>
        <trans-unit id="b06e9eb45a05735715e1d1b65c57610ee02c78b2" translate="yes" xml:space="preserve">
          <source>This tells Flow that any code within the project can reference the &lt;code&gt;foo&lt;/code&gt; global function, and that the function takes one argument (a &lt;code&gt;number&lt;/code&gt;) and it returns a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">これは、プロジェクト内のすべてのコードが &lt;code&gt;foo&lt;/code&gt; グローバル関数を参照できること、および関数が1つの引数（ &lt;code&gt;number&lt;/code&gt; ）を取り、 &lt;code&gt;string&lt;/code&gt; 返すことをFlowに伝えます。</target>
        </trans-unit>
        <trans-unit id="e6bab6dcb6b25f93bc93c3ef139cb0898176b837" translate="yes" xml:space="preserve">
          <source>This utility has been deprecated and should be avoided. See &lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-deprecated-type&quot;&gt;here&lt;/a&gt; for details.</source>
          <target state="translated">このユーティリティは廃止されており、回避する必要があります。詳細は&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-deprecated-type&quot;&gt;こちら&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="b74c252b0eeaacbb897eb419ddf06e190d869384" translate="yes" xml:space="preserve">
          <source>This utility has been deprecated and should be avoided. See &lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-deprecated-utility&quot;&gt;here&lt;/a&gt; for details.</source>
          <target state="translated">このユーティリティは廃止されており、回避する必要があります。詳細は&lt;a href=&quot;https://flow.org/en/linting/rule-reference/#toc-deprecated-utility&quot;&gt;こちら&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="cabd9148684b1aa762ff2b690b8f720e71dd5acb" translate="yes" xml:space="preserve">
          <source>This way you avoid duplicating the properties that happen to have a default value.</source>
          <target state="translated">このようにして、デフォルト値を持つプロパティの重複を避けることができます。</target>
        </trans-unit>
        <trans-unit id="22fe37b0969c2ab3810a8157bfb87e3e61565f27" translate="yes" xml:space="preserve">
          <source>This way you can keep the behavior of generics while only allowing certain types to be used.</source>
          <target state="translated">この方法では、ジェネリックの動作を維持しつつ、特定の型のみを使用できるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="d06c742de148aa21dfa2ce9950e849bcb9ab4c64" translate="yes" xml:space="preserve">
          <source>This will give you information about everything that flow can do. Running this command should print something like this:</source>
          <target state="translated">これにより、フローができることのすべてについての情報が表示されます。このコマンドを実行すると、以下のように表示されるはずです。</target>
        </trans-unit>
        <trans-unit id="25f1d22273c04f62e4a5c6ea73e398a03b77af32" translate="yes" xml:space="preserve">
          <source>This will suppress both of the two errors on this line.</source>
          <target state="translated">これは、この行の2つのエラーの両方を抑制します。</target>
        </trans-unit>
        <trans-unit id="c5358194d5e312667901904699178d180ad0d876" translate="yes" xml:space="preserve">
          <source>This would be the same as including a type annotation inside an include comment.</source>
          <target state="translated">これは、インクルードコメントの中に型注釈を含めるのと同じことになります。</target>
        </trans-unit>
        <trans-unit id="80babb7d0ff0eda4573ad401ec556fbf50e83b89" translate="yes" xml:space="preserve">
          <source>To add a type for state to your React class component then create a new object type, in the example below we name it &lt;code&gt;State&lt;/code&gt;, and pass it as the second type argument to &lt;code&gt;React.Component&lt;/code&gt;.</source>
          <target state="translated">状態の型をReactクラスコンポーネントに追加してから、新しいオブジェクト型を作成します。以下の例では、 &lt;code&gt;State&lt;/code&gt; という名前を付け、それを2番目の型引数として &lt;code&gt;React.Component&lt;/code&gt; に渡します。</target>
        </trans-unit>
        <trans-unit id="46cc112d13261a13154b6cfac4e2d48bf5063881" translate="yes" xml:space="preserve">
          <source>To create an array type you can use &lt;code&gt;Array&amp;lt;Type&amp;gt;&lt;/code&gt; type where &lt;code&gt;Type&lt;/code&gt; is the type of elements in the array. For example, to create a type for an array of numbers you use &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">配列型を作成するには、 &lt;code&gt;Array&amp;lt;Type&amp;gt;&lt;/code&gt; 型を使用できます。ここで、 &lt;code&gt;Type&lt;/code&gt; は配列内の要素の型です。たとえば、数値の配列の型を作成するには、 &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="8dd0d93865b9bfacde3e4affb1eb92fd379b6bf0" translate="yes" xml:space="preserve">
          <source>To declare a global class that should be accessible throughout your project, use the &lt;code&gt;declare class&lt;/code&gt; syntax in a libdef file:</source>
          <target state="translated">プロジェクト全体でアクセス可能なグローバルクラスを宣言するには、libdefファイルで &lt;code&gt;declare class&lt;/code&gt; 構文を使用します。</target>
        </trans-unit>
        <trans-unit id="2c05553bc81af5c0b4f02184bd805aba0fa865c0" translate="yes" xml:space="preserve">
          <source>To declare a global function that should be accessible throughout your project, use the &lt;code&gt;declare function&lt;/code&gt; syntax in a libdef file:</source>
          <target state="translated">プロジェクト全体でアクセスできるグローバル関数を宣言するには、libdefファイルで &lt;code&gt;declare function&lt;/code&gt; 構文を使用します。</target>
        </trans-unit>
        <trans-unit id="3d8d4cb10458061c2bc75c04590a96a2ed068bd5" translate="yes" xml:space="preserve">
          <source>To declare a global type that should be accessible throughout your project, use the &lt;code&gt;declare type&lt;/code&gt; syntax in a libdef file:</source>
          <target state="translated">プロジェクト全体でアクセス可能なグローバルタイプを宣言するには、libdefファイルで &lt;code&gt;declare type&lt;/code&gt; 構文を使用します。</target>
        </trans-unit>
        <trans-unit id="d38d878e01cad40728f252774b0c25def7d4cb78" translate="yes" xml:space="preserve">
          <source>To declare a global variable that should be accessible throughout your project, use the &lt;code&gt;declare var&lt;/code&gt; syntax in a libdef file:</source>
          <target state="translated">プロジェクト全体からアクセスできるグローバル変数を宣言するには、libdefファイルで &lt;code&gt;declare var&lt;/code&gt; 構文を使用します。</target>
        </trans-unit>
        <trans-unit id="f1875d662019d803a3d158d296ddb77c1752c55d" translate="yes" xml:space="preserve">
          <source>To explicitly specify the type of a context value, pass a type parameter to &lt;code&gt;createContext&lt;/code&gt;:</source>
          <target state="translated">コンテキスト値のタイプを明示的に指定するには、typeパラメータを &lt;code&gt;createContext&lt;/code&gt; に渡します。</target>
        </trans-unit>
        <trans-unit id="dc65e5d43387ac143a42fd49169c9f382ad9e6e7" translate="yes" xml:space="preserve">
          <source>To find out more about the CLI just type:</source>
          <target state="translated">CLIの詳細を知るには、タイプするだけです。</target>
        </trans-unit>
        <trans-unit id="4d7d33015c801a7c6d2c398d267001cb7e383f0d" translate="yes" xml:space="preserve">
          <source>To find out the coverage of a file foo.js with the following contents</source>
          <target state="translated">以下の内容のファイル foo.js のカバレッジを調べるには</target>
        </trans-unit>
        <trans-unit id="d062574c0bbb40aba96339ff0dbe5323fbfe73f8" translate="yes" xml:space="preserve">
          <source>To get a sense of when and why the different kinds of variance matters, let&amp;rsquo;s talk about methods of subclasses and how they get type checked.</source>
          <target state="translated">さまざまな種類の分散がいつどのように重要であるかを理解するために、サブクラスのメソッドと、それらがどのように型チェックされるかについて話しましょう。</target>
        </trans-unit>
        <trans-unit id="e8ca9700f4d5ea2116113c0a357e597df59a1d6a" translate="yes" xml:space="preserve">
          <source>To remove a prop from the config, we can take a component that includes the prop and return a component that does not. It&amp;rsquo;s best to construct these types using object type spread.</source>
          <target state="translated">構成からプロップを削除するには、プロップを含むコンポーネントを取得し、含まないコンポーネントを返すことができます。オブジェクト型スプレッドを使用してこれらの型を構築するのが最善です。</target>
        </trans-unit>
        <trans-unit id="af162968659acb875948b1adecd192a495aa886b" translate="yes" xml:space="preserve">
          <source>To resolve this, you can add an annotation like the following:</source>
          <target state="translated">これを解決するには、以下のようなアノテーションを追加します。</target>
        </trans-unit>
        <trans-unit id="8da5a47f9a8fbbb9d2efd234b56f09b304fb7f98" translate="yes" xml:space="preserve">
          <source>To see how you can annotate exported React components, check out our docs on &lt;a href=&quot;https://flow.org/en/react/hoc/#toc-exporting-wrapped-components&quot;&gt;HOCs&lt;/a&gt;.</source>
          <target state="translated">エクスポートされたReactコンポーネントに注釈を付ける方法については、&lt;a href=&quot;https://flow.org/en/react/hoc/#toc-exporting-wrapped-components&quot;&gt;HOC&lt;/a&gt;に関するドキュメントをご覧ください。</target>
        </trans-unit>
        <trans-unit id="887e026dfa02b4db43c36574cea623de3e0927d9" translate="yes" xml:space="preserve">
          <source>To see what types are missing to make your codebase types-first ready, add the following line to the &lt;code&gt;[options]&lt;/code&gt; section of the &lt;code&gt;.flowconfig&lt;/code&gt; file:</source>
          <target state="translated">コードベースタイプを最初に準備するために不足しているタイプを確認するには、 &lt;code&gt;.flowconfig&lt;/code&gt; ファイルの &lt;code&gt;[options]&lt;/code&gt; セクションに次の行を追加します。</target>
        </trans-unit>
        <trans-unit id="f5fcd1977220cbf8582e71619f881b97e9e50e3e" translate="yes" xml:space="preserve">
          <source>To see why this metric was chosen for determining Flow&amp;rsquo;s effectiveness, consider the example</source>
          <target state="translated">フローの有効性を判断するためにこのメトリックが選択された理由を確認するには、例を検討してください。</target>
        </trans-unit>
        <trans-unit id="38d849d799ad5dab7240320680d5c36bc5f7e6a7" translate="yes" xml:space="preserve">
          <source>To start a Flow server in Filesystem lazy mode, you run</source>
          <target state="translated">ファイルシステム遅延モードでフローサーバを起動するには、以下のように実行します。</target>
        </trans-unit>
        <trans-unit id="2cf8bbf7b6d19d0001e46d5b57c96b778d96ae37" translate="yes" xml:space="preserve">
          <source>To start a Flow server in IDE lazy mode, you run</source>
          <target state="translated">IDEのレイジーモードでFlowサーバを起動するには、次のように実行します。</target>
        </trans-unit>
        <trans-unit id="6e9bdac3d6d4ba3e13640e1b5c7a6fd976aa5a44" translate="yes" xml:space="preserve">
          <source>To start a Flow server in Watchman lazy mode, you run</source>
          <target state="translated">WatchmanのレイジーモードでFlowサーバを起動するには、以下のように実行します。</target>
        </trans-unit>
        <trans-unit id="3978fe345012186156eab3faa3a6473c8b81612a" translate="yes" xml:space="preserve">
          <source>To start, we can define a SubClass that extends our BaseClass. Here you can see that the value and the return type are both City just like in BaseClass:</source>
          <target state="translated">まず、BaseClass を拡張した SubClass を定義します。ここでは、BaseClass と同様に、値と戻り値の型が両方とも City であることがわかります。</target>
        </trans-unit>
        <trans-unit id="8cfed2a3a8f7e86b967cf2cb173010c65146aff8" translate="yes" xml:space="preserve">
          <source>To stop the background process, run &lt;code&gt;flow stop&lt;/code&gt;.</source>
          <target state="translated">バックグラウンドプロセスを停止するには、 &lt;code&gt;flow stop&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="365cac5ca300e0e137b8e8e9c5ccad2ec1dd9628" translate="yes" xml:space="preserve">
          <source>To suppress multiple error codes on the same line, you can stack suppression comments one after another, and they will all apply to the first non-comment line like so:</source>
          <target state="translated">同一行に複数のエラーコードを抑制するには、抑制コメントを次々に積み重ねることができ、以下のように最初のコメント以外の行にすべて適用されます。</target>
        </trans-unit>
        <trans-unit id="338950985d59d6b6ee99128178aad62509b70476" translate="yes" xml:space="preserve">
          <source>To type event handlers you may use the &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; types like this:</source>
          <target state="translated">イベントハンドラを入力するには、次のような &lt;code&gt;SyntheticEvent&amp;lt;T&amp;gt;&lt;/code&gt; タイプを使用できます。</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="624f97de4950b92b803c5cac29be65a9f2a26ac4" translate="yes" xml:space="preserve">
          <source>Triggers when a &lt;code&gt;number&lt;/code&gt; is used in a manner which may lead to unexpected results if the value is falsy. Currently, this lint triggers if a &lt;code&gt;number&lt;/code&gt; appears in:</source>
          <target state="translated">値が偽である場合に予期しない結果につながる可能性がある方法で &lt;code&gt;number&lt;/code&gt; が使用されるとトリガーされます。現在、このlintは、 &lt;code&gt;number&lt;/code&gt; が出現した場合にトリガーされます。</target>
        </trans-unit>
        <trans-unit id="8244aa53a1217dc629b3a687638e12f7a3825a89" translate="yes" xml:space="preserve">
          <source>Triggers when a dynamic type (usually &lt;code&gt;any&lt;/code&gt;) appears in a position exported from a file. Note that this is a very noisy lint, and can be triggered even when exporting types that are defined in our library definitions to include &lt;code&gt;any&lt;/code&gt; types. For this reason we recommend turning it on on a per-file or even per-line basis using &lt;a href=&quot;../flowlint-comments#toc-flowlint&quot;&gt;flowlint comments&lt;/a&gt; rather than for your whole repository in the &lt;code&gt;.flowconfig&lt;/code&gt;.</source>
          <target state="translated">動的タイプ（通常 &lt;code&gt;any&lt;/code&gt; ）がファイルからエクスポートされた位置に表示されるとトリガーされます。これは非常にノイズの多いリントであり、ライブラリ定義で定義されているタイプをエクスポートして &lt;code&gt;any&lt;/code&gt; タイプを含める場合でもトリガーされる可能性があることに注意してください。このため、 &lt;code&gt;.flowconfig&lt;/code&gt; のリポジトリ全体ではなく、&lt;a href=&quot;../flowlint-comments#toc-flowlint&quot;&gt;flowlintコメント&lt;/a&gt;を使用してファイルごとまたは行ごとに有効にすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="47ddc8ed6cfa00004f5b18730edf70132171135b" translate="yes" xml:space="preserve">
          <source>Triggers when you do an existence check on a value that can be either null/undefined or falsey.</source>
          <target state="translated">null/undefined または falsey のいずれかの値の存在チェックを行うときにトリガされます。</target>
        </trans-unit>
        <trans-unit id="4ce10e302a6e69d26761a0ef32f11a1014584bb6" translate="yes" xml:space="preserve">
          <source>Triggers when you import a type from an untyped file. Importing a type from an untyped file results in an &lt;code&gt;any&lt;/code&gt; alias, which is typically not the intended behavior. Enabling this lint brings extra attention to this case and can help improve Flow coverage of typed files by limiting the spread of implicit &lt;code&gt;any&lt;/code&gt; types.</source>
          <target state="translated">型なしファイルから型をインポートするとトリガーされます。内型なしファイル結果からタイプをインポートする &lt;code&gt;any&lt;/code&gt; 一般的に意図挙動ない別名、。このlintを有効にすると、このケースにさらに注意が向けられ、暗黙的な &lt;code&gt;any&lt;/code&gt; 型の広がりを制限することにより、型付きファイルのフローカバレッジを改善するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="40e312343bc5d66e00ad8f9190f3b8d256cb21f3" translate="yes" xml:space="preserve">
          <source>Triggers when you import from an untyped file. Importing from an untyped file results in those imports being typed as &lt;code&gt;any&lt;/code&gt;, which is unsafe.</source>
          <target state="translated">型なしファイルからインポートするとトリガーされます。型指定されていないファイルからインポートすると、それらのインポートは &lt;code&gt;any&lt;/code&gt; として型指定され、安全ではありません。</target>
        </trans-unit>
        <trans-unit id="39095841a2d5b46ef9de672a2165376705e39be2" translate="yes" xml:space="preserve">
          <source>Triggers when you use &lt;code&gt;?.&lt;/code&gt; where it isn&amp;rsquo;t needed. This comes in two main flavors. The first is when the left-hand-side cannot be nullish:</source>
          <target state="translated">&lt;code&gt;?.&lt;/code&gt; を使用するとトリガーされます。必要ないところ。これには2つの主要な種類があります。1つ目は、左側をnullにできない場合です。</target>
        </trans-unit>
        <trans-unit id="7a041463679a6c0a8cd599df21a504646bc4568e" translate="yes" xml:space="preserve">
          <source>Triggers when you use &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;Object&lt;/code&gt;, or &lt;code&gt;Function&lt;/code&gt; as type annotations. These types are unsafe.</source>
          <target state="translated">タイプ注釈として &lt;code&gt;any&lt;/code&gt; 、 &lt;code&gt;Object&lt;/code&gt; 、または &lt;code&gt;Function&lt;/code&gt; を使用するとトリガーされます。これらのタイプは安全ではありません。</target>
        </trans-unit>
        <trans-unit id="19e0b14f57c0eae8e32ecfbe46dbafa0b69613db" translate="yes" xml:space="preserve">
          <source>Triggers when you use &lt;code&gt;invariant&lt;/code&gt; to check a condition which we know must be truthy based on the available type information. This is quite conservative: for example, if all we know about the condition is that it is a &lt;code&gt;boolean&lt;/code&gt;, then the lint will not fire even if the condition must be &lt;code&gt;true&lt;/code&gt; at runtime.</source>
          <target state="translated">&lt;code&gt;invariant&lt;/code&gt; 条件を使用して、利用可能な型情報に基づいて真実でなければならないことがわかっている条件をチェックするとトリガーされます。これはかなり保守的です。たとえば、条件が &lt;code&gt;boolean&lt;/code&gt; であることだけがわかっている場合、実行時に条件が &lt;code&gt;true&lt;/code&gt; でなければならない場合でも、lintは起動しません。</target>
        </trans-unit>
        <trans-unit id="88f0c0e34ae8ddb6395ee1c9617fdf1fcbad8760" translate="yes" xml:space="preserve">
          <source>Triggers when you use getters or setters. Getters and setters can have side effects and are unsafe.</source>
          <target state="translated">ゲッターやセッターを使用した場合のトリガー。ゲッターやセッターは副作用があり、安全ではありません。</target>
        </trans-unit>
        <trans-unit id="ffe944ad5706f41a9277209e96a262e3b635f27d" translate="yes" xml:space="preserve">
          <source>Triggers when you use object type syntax without explicitly specifying exactness or inexactness.</source>
          <target state="translated">正確さや不正確さを明示的に指定せずにオブジェクト型構文を使用した場合にトリガされます。</target>
        </trans-unit>
        <trans-unit id="53aef4ae56fa920050fd71a2e06d45055d43a802" translate="yes" xml:space="preserve">
          <source>Triggers when you use the &lt;code&gt;$Supertype&lt;/code&gt; or &lt;code&gt;$Subtype&lt;/code&gt; utility types, as these types are unsafe and equivalent to &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$Supertype&lt;/code&gt; または &lt;code&gt;$Subtype&lt;/code&gt; ユーティリティタイプを使用するとトリガーされます。これらのタイプは安全ではなく、 &lt;code&gt;any&lt;/code&gt; と同等です。</target>
        </trans-unit>
        <trans-unit id="5d53a0bb8e4d9ee63e0c2e172befa01db4dc5e57" translate="yes" xml:space="preserve">
          <source>Triggers when you use the &lt;code&gt;*&lt;/code&gt; (existential) type, as this type is unsafe and usually just equivalent to &lt;code&gt;any&lt;/code&gt;. The effect of &lt;code&gt;*&lt;/code&gt; can generally be achieved by simply not providing a type annotation.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; （既存の）タイプを使用するとトリガーされます。このタイプは安全ではなく、通常、 &lt;code&gt;any&lt;/code&gt; と同等です。 &lt;code&gt;*&lt;/code&gt; の効果は、通常、型注釈を提供しないことで実現できます。</target>
        </trans-unit>
        <trans-unit id="3cddc0a96f7b4bc576c5197edc188b6a0fc13138" translate="yes" xml:space="preserve">
          <source>Trying to access an index that does not exist results in an index-out-of-bounds error.</source>
          <target state="translated">存在しないインデックスにアクセスしようとすると、インデックスアウトオブバウンズエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="cded0e3b203109683ae6b9ee54b86c57e5dee4ad" translate="yes" xml:space="preserve">
          <source>Trying to combine these two separate types into a single one will only cause us trouble.</source>
          <target state="translated">この2つの別々のタイプを1つにまとめようとしても、私たちに迷惑をかけるだけです。</target>
        </trans-unit>
        <trans-unit id="8f2a5e4b9220f04b1f591d617289494ede815765" translate="yes" xml:space="preserve">
          <source>Tuple Types</source>
          <target state="translated">タプル型</target>
        </trans-unit>
        <trans-unit id="61fc0a89e720d49271749ab98f1e68ad73b11567" translate="yes" xml:space="preserve">
          <source>Tuples are a sort of list but with a limited set of items. In JavaScript, tuples are created using arrays.</source>
          <target state="translated">タプルはリストの一種ですが、項目のセットが限られています。JavaScriptでは、タプルは配列を使って作成されます。</target>
        </trans-unit>
        <trans-unit id="73e71c95d22953ac62aab7556972e23a84de8572" translate="yes" xml:space="preserve">
          <source>Tuples don&amp;rsquo;t match array types</source>
          <target state="translated">タプルが配列型と一致しません</target>
        </trans-unit>
        <trans-unit id="8228214d660934e2f3e63e0eebd31592280771e2" translate="yes" xml:space="preserve">
          <source>Tuples only match tuples with same length</source>
          <target state="translated">タプルは同じ長さのタプルにしかマッチしない</target>
        </trans-unit>
        <trans-unit id="ebd8267f01d325be2d1360510829d925406c4930" translate="yes" xml:space="preserve">
          <source>Type &amp;lsquo;Flow&amp;rsquo; to find &amp;lsquo;Flow for Sublime Text 2 and 3&amp;rsquo;</source>
          <target state="translated">「Flow」と入力して、「崇高なテキスト2および3のフロー」を検索します</target>
        </trans-unit>
        <trans-unit id="706d45898c47974656ad0920b31f4684a46f295c" translate="yes" xml:space="preserve">
          <source>Type Alias Generics</source>
          <target state="translated">タイプエイリアスジェネリック</target>
        </trans-unit>
        <trans-unit id="967c606ccee3e18535dabb6a9b4bb749abac062f" translate="yes" xml:space="preserve">
          <source>Type Alias Syntax</source>
          <target state="translated">タイプエイリアス構文</target>
        </trans-unit>
        <trans-unit id="353ce315d4b89d72fbf39db84d79fda4b261f3b6" translate="yes" xml:space="preserve">
          <source>Type Aliases</source>
          <target state="translated">型別名</target>
        </trans-unit>
        <trans-unit id="22d158ab75d63715d420bc5e58daab5d8357398c" translate="yes" xml:space="preserve">
          <source>Type Annotations</source>
          <target state="translated">タイプアノテーション</target>
        </trans-unit>
        <trans-unit id="77177e460aea3473402f5aaa44a506ee91144641" translate="yes" xml:space="preserve">
          <source>Type Assertions</source>
          <target state="translated">タイプアサーション</target>
        </trans-unit>
        <trans-unit id="679d10a7debbdc2089b71c9b81e4e219e305c114" translate="yes" xml:space="preserve">
          <source>Type Cast Expression Syntax</source>
          <target state="translated">タイプキャスト式の構文</target>
        </trans-unit>
        <trans-unit id="7f7ae61fc4d52305e688b8380ee480f65e186212" translate="yes" xml:space="preserve">
          <source>Type Casting</source>
          <target state="translated">鋳造タイプ</target>
        </trans-unit>
        <trans-unit id="622cca8db4f4ef9c127d2e4b8f7ee4a1c6c56924" translate="yes" xml:space="preserve">
          <source>Type Casting Expressions</source>
          <target state="translated">鋳造表現の種類</target>
        </trans-unit>
        <trans-unit id="242837be86dac228098509d8b1d22d367cdf4559" translate="yes" xml:space="preserve">
          <source>Type Casting through any</source>
          <target state="translated">どのようなタイプのキャスティングでも</target>
        </trans-unit>
        <trans-unit id="5ad392a89ee608a47c6212c75337d50433a48220" translate="yes" xml:space="preserve">
          <source>Type Reference</source>
          <target state="translated">タイプリファレンス</target>
        </trans-unit>
        <trans-unit id="ce57a9b5c9b93e38d173ed05c80dc328e2cdfdfc" translate="yes" xml:space="preserve">
          <source>Type Refinements</source>
          <target state="translated">タイプの絞り込み</target>
        </trans-unit>
        <trans-unit id="7433446286e8e2d16c8a5d667b180309a3d0c3b1" translate="yes" xml:space="preserve">
          <source>Type System</source>
          <target state="translated">タイプシステム</target>
        </trans-unit>
        <trans-unit id="472d5c5df27f757dd28ba1d382ee583d4a9c6081" translate="yes" xml:space="preserve">
          <source>Type Variance</source>
          <target state="translated">タイプの違い</target>
        </trans-unit>
        <trans-unit id="7081fc7a1f2c1115eff37592f8d91d2655e0035b" translate="yes" xml:space="preserve">
          <source>Type alias generics are &lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;parameterized&lt;/a&gt;. When you use a type alias you need to pass parameters for each of its generics.</source>
          <target state="translated">タイプエイリアスのジェネリックは&lt;a href=&quot;../generics#toc-parameterized-generics&quot;&gt;パラメーター化されます&lt;/a&gt;。タイプエイリアスを使用する場合、ジェネリックのそれぞれにパラメータを渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="ed6584609a640d5af10378fda6649aaa9963a745" translate="yes" xml:space="preserve">
          <source>Type aliases are created using the keyword &lt;code&gt;type&lt;/code&gt; followed by its name, an equals sign &lt;code&gt;=&lt;/code&gt;, and a type definition.</source>
          <target state="translated">タイプエイリアスは、キーワード &lt;code&gt;type&lt;/code&gt; 後に名前、等号 &lt;code&gt;=&lt;/code&gt; 、タイプ定義を続けて作成します。</target>
        </trans-unit>
        <trans-unit id="f5e43ef93cfc8bf99af97c7220813d7732015c36" translate="yes" xml:space="preserve">
          <source>Type aliases can also have their own &lt;a href=&quot;../generics&quot;&gt;generics&lt;/a&gt;.</source>
          <target state="translated">型エイリアスは、独自の&lt;a href=&quot;../generics&quot;&gt;ジェネリックを&lt;/a&gt;持つこともできます。</target>
        </trans-unit>
        <trans-unit id="094f893f7105ba5dce34064ff2a962e9a5dea0a2" translate="yes" xml:space="preserve">
          <source>Type aliases with generics</source>
          <target state="translated">ジェネリックなエイリアスをタイプする</target>
        </trans-unit>
        <trans-unit id="856da198c41cb55e6e7b7e17d220f7f074929070" translate="yes" xml:space="preserve">
          <source>Type cast expressions can appear anywhere an expression can appear.</source>
          <target state="translated">型キャスト式は、式が出現する場所であればどこでも出現させることができます。</target>
        </trans-unit>
        <trans-unit id="52a7383784e25f833d11d59af803f7d6f5fb1c80" translate="yes" xml:space="preserve">
          <source>Type checking through type assertions</source>
          <target state="translated">型アサーションによる型チェック</target>
        </trans-unit>
        <trans-unit id="b0b25b95faf957cfa80952cbe05fe4b40c3ff732" translate="yes" xml:space="preserve">
          <source>Typeof Types</source>
          <target state="translated">タイプの種類</target>
        </trans-unit>
        <trans-unit id="e96900534c313f15c2044eb007fe55d438980bfc" translate="yes" xml:space="preserve">
          <source>Types &amp;amp; Expressions</source>
          <target state="translated">タイプと式</target>
        </trans-unit>
        <trans-unit id="c71bc629994455a4ae2c2c56b3468d4335892413" translate="yes" xml:space="preserve">
          <source>Types for literal values are lowercase.</source>
          <target state="translated">リテラル値の型は小文字になります。</target>
        </trans-unit>
        <trans-unit id="580c5ee4989e8d41e98c7cbde35a3b6779ea36bd" translate="yes" xml:space="preserve">
          <source>Types for the wrapper objects are capitalized (the same as their constructor).</source>
          <target state="translated">ラッパー・オブジェクトの型は大文字で表記されます(コンストラクタと同じ)。</target>
        </trans-unit>
        <trans-unit id="261798fb195afa2ef742905bdf96b253f84a80b5" translate="yes" xml:space="preserve">
          <source>Types-First</source>
          <target state="translated">Types-First</target>
        </trans-unit>
        <trans-unit id="b7462bb0d3927c58dff4b373159f208396dac87e" translate="yes" xml:space="preserve">
          <source>Types-first mode is officially released with version 0.125, but has been available in &lt;em&gt;experimental&lt;/em&gt; status as of version 0.102. If you are currently on an older Flow version, you&amp;rsquo;d have to first upgrade Flow. Using the latest Flow version is the best way to benefit from the performance benefits outlined above.</source>
          <target state="translated">タイプファーストモードはバージョン0.125で正式にリリースされていますが、バージョン0.102の時点で&lt;em&gt;実験的な&lt;/em&gt;状態で利用可能になっています。現在古いバージョンのFlowを使用している場合は、最初にFlowをアップグレードする必要があります。上記のパフォーマンス上の利点を活用するには、最新のFlowバージョンを使用するのが最善の方法です。</target>
        </trans-unit>
        <trans-unit id="ed2e12e68cfc75ec2c60ea3b9e8b6d3511b2f122" translate="yes" xml:space="preserve">
          <source>Types-first requires annotations at module boundaries in order to build type signature for files. If these annotations are missing, then a &lt;code&gt;signature-verification-failure&lt;/code&gt; is raised, and the exported type for the respective part of the code will be &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">タイプ-最初に、ファイルのタイプ署名を作成するために、モジュール境界に注釈が必要です。これらのアノテーションが欠落している場合、 &lt;code&gt;signature-verification-failure&lt;/code&gt; が発生し、コードのそれぞれの部分のエクスポートされたタイプは &lt;code&gt;any&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="7b4e1425babb83699dcc06797b8fc4bf14a2ecce" translate="yes" xml:space="preserve">
          <source>Typing Redux action creators</source>
          <target state="translated">タイピングReduxアクションクリエイター</target>
        </trans-unit>
        <trans-unit id="5dfff1352be5ea6c7148bf3b4ca1615b03fabc81" translate="yes" xml:space="preserve">
          <source>Typing Redux actions</source>
          <target state="translated">Reduxアクションのタイピング</target>
        </trans-unit>
        <trans-unit id="6ac33fe488507408b1948fb67be46790295ab295" translate="yes" xml:space="preserve">
          <source>Typing Redux reducers</source>
          <target state="translated">Reduxの減速機を入力する</target>
        </trans-unit>
        <trans-unit id="1133cd18fcd897fc2f5bb525485b9229e6071672" translate="yes" xml:space="preserve">
          <source>Typing Redux state</source>
          <target state="translated">Redux の状態を入力します。</target>
        </trans-unit>
        <trans-unit id="0640a2bc7ae817374f47547199fbe5f3a1a3b619" translate="yes" xml:space="preserve">
          <source>Typing Redux state immutability</source>
          <target state="translated">Typing Redux 状態の不変性</target>
        </trans-unit>
        <trans-unit id="5122ba530622fd5f4a0332eb09fb6325c4305df1" translate="yes" xml:space="preserve">
          <source>Typing Redux thunk actions</source>
          <target state="translated">ReduxのThunkアクションを入力する</target>
        </trans-unit>
        <trans-unit id="8f00b09a4880f70aa5139aa250a7d8b335930e96" translate="yes" xml:space="preserve">
          <source>Typing function children or other exotic children types.</source>
          <target state="translated">関数の子やその他のエキゾチックな子のタイプを入力します。</target>
        </trans-unit>
        <trans-unit id="ee1f5ee4decdbb0b21342950c2b6f1f39fa45f3a" translate="yes" xml:space="preserve">
          <source>Typing your &lt;a href=&quot;http://redux.js.org/docs/introduction/ThreePrinciples.html#single-source-of-truth&quot;&gt;state&lt;/a&gt; object, works the same as typing any other object in Flow.</source>
          <target state="translated">あなたの入力&lt;a href=&quot;http://redux.js.org/docs/introduction/ThreePrinciples.html#single-source-of-truth&quot;&gt;状態の&lt;/a&gt;オブジェクトを、フロー内の他のオブジェクトを入力するのと同じように動作します。</target>
        </trans-unit>
        <trans-unit id="eaeff57d46868fd923495803e50c88004276ec83" translate="yes" xml:space="preserve">
          <source>Typings HOCs can be complicated. While you can follow the &lt;a href=&quot;react/hoc&quot;&gt;docs about it&lt;/a&gt;, sometimes it can be easier to type the returned component.</source>
          <target state="translated">HOCの入力は複雑になる場合があります。&lt;a href=&quot;react/hoc&quot;&gt;それに関するドキュメントに&lt;/a&gt;従うことができますが、返されたコンポーネントを入力する方が簡単な場合があります。</target>
        </trans-unit>
        <trans-unit id="28e0451237256965294e54fd3ed734d927e133c0" translate="yes" xml:space="preserve">
          <source>Under the hood, Flow relies on a high-throughput low-latency systems infrastructure that enables distribution of tasks among parallel workers, and communication of results in parallel via shared memory. Combined with an architecture where the analysis of a codebase is updated automatically in the background on file system changes, Flow delivers near-instantaneous feedback as the developer edits and rebases code, even in a large repository.</source>
          <target state="translated">Flowは、並列ワーカー間でタスクを分散し、共有メモリを介して並列で結果を通信することを可能にするハイスループット低レイテンシシステムインフラストラクチャに依存しています。ファイルシステムの変更に応じてコードベースの分析がバックグラウンドで自動的に更新されるアーキテクチャと組み合わせることで、Flowは、開発者がコードを編集したりリベースしたりする際に、大規模なリポジトリ内であっても、ほぼ瞬時にフィードバックを得ることができます。</target>
        </trans-unit>
        <trans-unit id="667d6f69fc6e6557c1fd07a997502ffbb6fea4b6" translate="yes" xml:space="preserve">
          <source>Understanding the logic behind generics might be useful, but what you really need to know to make your typings valid is that you need to help Flow to understand the type of &lt;code&gt;genericArray&lt;/code&gt;.</source>
          <target state="translated">ジェネリックの背後にあるロジックを理解することは役立つかもしれませんが、タイピングを有効にするために本当に知っておく必要があるのは、Flowが &lt;code&gt;genericArray&lt;/code&gt; のタイプを理解できるようにする必要があるということです。</target>
        </trans-unit>
        <trans-unit id="19b606b9d09ef359154b3796d3b6d1ef4472ad09" translate="yes" xml:space="preserve">
          <source>Unfortunately, it is not possible to enable types-first mode for part of your repo; this switch affects all files managed by the current &lt;code&gt;.flowconfig&lt;/code&gt;.</source>
          <target state="translated">残念ながら、リポジトリの一部でタイプファーストモードを有効にすることはできません。このスイッチは、現在の &lt;code&gt;.flowconfig&lt;/code&gt; によって管理されているすべてのファイルに影響します。</target>
        </trans-unit>
        <trans-unit id="468ccd5bcf72e4958742b43ae3e09374a05c2b83" translate="yes" xml:space="preserve">
          <source>Union Types</source>
          <target state="translated">ユニオンの種類</target>
        </trans-unit>
        <trans-unit id="5997dfe0e231fc3d5039a0ce77e27fc997c50e93" translate="yes" xml:space="preserve">
          <source>Union type syntax</source>
          <target state="translated">ユニオン型構文</target>
        </trans-unit>
        <trans-unit id="5772a5be68b2acc1748e16bd31117c9dcf779b80" translate="yes" xml:space="preserve">
          <source>Union types are any number of types which are joined by a vertical bar &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">ユニオンタイプは、縦棒で結合された任意の数のタイプです &lt;code&gt;|&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4fcae8ac4735463f8391bdf76cd83a6272aa90b" translate="yes" xml:space="preserve">
          <source>Union types requires one in, but all out</source>
          <target state="translated">ユニオンタイプは1つの入力が必要ですが、すべての入力が必要です。</target>
        </trans-unit>
        <trans-unit id="40ebabc3d3f621503bd72ccc4402a11bbf25a8ef" translate="yes" xml:space="preserve">
          <source>Unions &amp;amp; Refinements</source>
          <target state="translated">ユニオンと洗練</target>
        </trans-unit>
        <trans-unit id="38ed70ea0b1d89e63badbd5bea1ce73346a2e36d" translate="yes" xml:space="preserve">
          <source>Unknown property lookup on unsealed objects is unsafe</source>
          <target state="translated">封印されていないオブジェクトでの不明なプロパティ検索は安全ではない</target>
        </trans-unit>
        <trans-unit id="703d1ae54d78dc2791b520eb4ed986a6d9a34e11" translate="yes" xml:space="preserve">
          <source>Unless the objects somehow conflict with one another there is no way to distinguish them.</source>
          <target state="translated">物体が何らかの形で互いに衝突しない限り、それらを区別する方法はありません。</target>
        </trans-unit>
        <trans-unit id="ef3248cdccf6c3a032dec37be3fbfe52ccc8052c" translate="yes" xml:space="preserve">
          <source>Unlike many other languages, JavaScript only has one type of number. These values may appear as &lt;code&gt;42&lt;/code&gt; or &lt;code&gt;3.14&lt;/code&gt;. JavaScript also considers &lt;code&gt;Infinity&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; to be numbers. The &lt;code&gt;number&lt;/code&gt; type captures everything JavaScript considers a number.</source>
          <target state="translated">他の多くの言語とは異なり、JavaScriptには1種類の数値しかありません。これらの値は、 &lt;code&gt;42&lt;/code&gt; または &lt;code&gt;3.14&lt;/code&gt; と表示される場合があります。JavaScriptも &lt;code&gt;Infinity&lt;/code&gt; と &lt;code&gt;NaN&lt;/code&gt; を数値と見なします。 &lt;code&gt;number&lt;/code&gt; タイプは、JavaScriptが数を考慮し、すべてをキャプチャします。</target>
        </trans-unit>
        <trans-unit id="3af13bbea775e8595b01bcfbe26e08a735507b74" translate="yes" xml:space="preserve">
          <source>Unlike regular object types, it is not valid to pass an object with &amp;ldquo;extra&amp;rdquo; properties to an exact object type.</source>
          <target state="translated">通常のオブジェクトタイプとは異なり、「追加」プロパティを持つオブジェクトを正確なオブジェクトタイプに渡すことは無効です。</target>
        </trans-unit>
        <trans-unit id="07ef2b2dcd96f0dd48fe2da326d94f53363ed4ce" translate="yes" xml:space="preserve">
          <source>Unsealed objects</source>
          <target state="translated">封印されていないオブジェクト</target>
        </trans-unit>
        <trans-unit id="25c6b6f53e08c0606a31166d8b9a877dcfc420f6" translate="yes" xml:space="preserve">
          <source>Unsealed objects allow new properties to be written at any time. Flow ensures that reads are compatible with writes, but does not ensure that writes happen before reads (in the order of execution).</source>
          <target state="translated">封印されていないオブジェクトは、新しいプロパティをいつでも書き込めるようにします。フローは読み込みと書き込みの互換性を保証しますが、書き込みが読み込みの前に起こることは保証しません(実行順序で)。</target>
        </trans-unit>
        <trans-unit id="0d33c5b31a20c87d8bda6835c104266836b20ac8" translate="yes" xml:space="preserve">
          <source>Upgrade Flow version</source>
          <target state="translated">フローのバージョンアップ</target>
        </trans-unit>
        <trans-unit id="b1c17d9e11ded3c8ebada61242238b401f935c20" translate="yes" xml:space="preserve">
          <source>Upgrading to &lt;a href=&quot;https://flow.org/en/lang/types-first&quot;&gt;Types-First&lt;/a&gt; mode may require a substantial number of type annotations at module boundaries. To help with the process of upgrading large codebases, we are providing a codemod command, whose goal is to fill in these missing annotations. This command is included in the Flow binary in versions &lt;code&gt;&amp;gt;= 0.125&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/lang/types-first&quot;&gt;型&lt;/a&gt;へのアップグレード-ファーストモードでは、モジュールの境界にかなりの数の型注釈が必要になる場合があります。大規模なコードベースをアップグレードするプロセスを支援するために、これらの欠落している注釈を埋めることを目的としたcodemodコマンドを提供しています。このコマンドは、バージョン &lt;code&gt;&amp;gt;= 0.125&lt;/code&gt; フローバイナリに含まれています。</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="a37aa700a25d2f5c26f5844b90cdc3158398c792" translate="yes" xml:space="preserve">
          <source>Used in conjuction with &lt;a href=&quot;https://flow.org/en/strict/&quot;&gt;Flow Strict&lt;/a&gt;. Triggers when importing a non &lt;code&gt;@flow strict&lt;/code&gt; module. When enabled, dependencies of a &lt;code&gt;@flow strict&lt;/code&gt; module must also be &lt;code&gt;@flow strict&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://flow.org/en/strict/&quot;&gt;Flow Strict&lt;/a&gt;と組み合わせて使用​​します。 &lt;code&gt;@flow strict&lt;/code&gt; 以外のモジュールをインポートするとトリガーされます。有効にした場合、 &lt;code&gt;@flow strict&lt;/code&gt; モジュールの依存関係も &lt;code&gt;@flow strict&lt;/code&gt; でなければなりません。</target>
        </trans-unit>
        <trans-unit id="37435b49f34aed7ea4a10106bbcc3330cbcab593" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;React.Node&lt;/code&gt; but without some primitive types like strings.</source>
          <target state="translated">&lt;code&gt;React.Node&lt;/code&gt; を使用していますが、文字列のようないくつかのプリミティブ型はありません。</target>
        </trans-unit>
        <trans-unit id="a55e66a75946c4c072cc420e4c3ed94f6780a7c2" translate="yes" xml:space="preserve">
          <source>Using Default Props</source>
          <target state="translated">デフォルトの小道具の使用</target>
        </trans-unit>
        <trans-unit id="08b120d1bbe1cac9b101fd75ecc8814d5b08ec58" translate="yes" xml:space="preserve">
          <source>Using Default Props for Functional Components</source>
          <target state="translated">機能コンポーネントにデフォルトの小道具を使用する</target>
        </trans-unit>
        <trans-unit id="3c58620d569e6a2825f19e911cd8c7f8b356ab31" translate="yes" xml:space="preserve">
          <source>Using Filesystem Lazy Mode</source>
          <target state="translated">ファイルシステム遅延モードの使用</target>
        </trans-unit>
        <trans-unit id="0eca84f8818d70549fd226298ab6a5af63ae5ddc" translate="yes" xml:space="preserve">
          <source>Using Flow you can use Maybe types for these values. Maybe types work with any other type by simply prefixing it with a question mark &lt;code&gt;?&lt;/code&gt; such as &lt;code&gt;?number&lt;/code&gt; as a sort of modifier.</source>
          <target state="translated">フローを使用すると、これらの値にMaybeタイプを使用できます。たぶん、タイプは単に疑問符を前に付けるだけで他のタイプと一緒に機能し &lt;code&gt;?&lt;/code&gt; 修飾子としての &lt;code&gt;?number&lt;/code&gt; など。</target>
        </trans-unit>
        <trans-unit id="ba7902faac97670dd0cee466cfc7b1872b6191c6" translate="yes" xml:space="preserve">
          <source>Using IDE Lazy Mode</source>
          <target state="translated">IDEのレイジーモードの使用</target>
        </trans-unit>
        <trans-unit id="dcb8b5c22a81a676bc4f6e0097672681d67ad964" translate="yes" xml:space="preserve">
          <source>Using Watchman Lazy Mode</source>
          <target state="translated">ウォッチマンのレイジーモードを使う</target>
        </trans-unit>
        <trans-unit id="4acbbdc6b766f0f60a0b004c91a169d2b83a940e" translate="yes" xml:space="preserve">
          <source>Using disjoint unions, Flow will be able to understand your reducers much better.</source>
          <target state="translated">disjoint unionsを使用することで、Flowはレデューサをよりよく理解できるようになります。</target>
        </trans-unit>
        <trans-unit id="e6ba24474eb6d1b00633e337c8dace730b98eb30" translate="yes" xml:space="preserve">
          <source>Using exact object types lets Flow know that no extra properties will exist at runtime, which allows &lt;a href=&quot;../refinements&quot;&gt;refinements&lt;/a&gt; to get more specific.</source>
          <target state="translated">正確なオブジェクトタイプを使用することで、実行時に余分なプロパティが存在しないことをFlowに知らせ、&lt;a href=&quot;../refinements&quot;&gt;洗練&lt;/a&gt;をより具体的にすることができます。</target>
        </trans-unit>
        <trans-unit id="10ade4f79788cce4dea297a9d609f90e95de4261" translate="yes" xml:space="preserve">
          <source>Using inference, these types are often optional:</source>
          <target state="translated">推論を使用すると、これらのタイプはオプションであることが多いです。</target>
        </trans-unit>
        <trans-unit id="638d500275968b8c62e284497de3a8262dc86007" translate="yes" xml:space="preserve">
          <source>Using intersection types, it is possible to create types which are impossible to create at runtime. Intersection types will allow you to combine any set of types, even ones that conflict with one another.</source>
          <target state="translated">交差型を使用することで、実行時には作成不可能な型を作成することができます。交差型を使うと、型のセットを組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="b8ada9fc6bb8dffff0336dfb6dc98c7dc0b143de" translate="yes" xml:space="preserve">
          <source>Using the above definition we can declare a function &lt;code&gt;fn&lt;/code&gt; that has the following behavior:</source>
          <target state="translated">上記の定義を使用して、次の動作をする関数 &lt;code&gt;fn&lt;/code&gt; を宣言できます。</target>
        </trans-unit>
        <trans-unit id="86509a1d00de10c9136938cbdfb1d9850e246f6e" translate="yes" xml:space="preserve">
          <source>Using the command &lt;code&gt;flow&lt;/code&gt; will type-check your current directory if the &lt;code&gt;.flowconfig&lt;/code&gt; file is present. A flow server will automatically be started if needed.</source>
          <target state="translated">コマンド &lt;code&gt;flow&lt;/code&gt; を使用すると、 &lt;code&gt;.flowconfig&lt;/code&gt; ファイルが存在する場合、現在のディレクトリのタイプチェックが行われます。フローサーバーは、必要に応じて自動的に起動されます。</target>
        </trans-unit>
        <trans-unit id="b4fce26a90d1ee7b21142442ea9f330e4afede8c" translate="yes" xml:space="preserve">
          <source>Using these with &lt;a href=&quot;../unions&quot;&gt;union types&lt;/a&gt; is powerful:</source>
          <target state="translated">&lt;a href=&quot;../unions&quot;&gt;ユニオンタイプで&lt;/a&gt;これらを使用すると強力です。</target>
        </trans-unit>
        <trans-unit id="58f37430c61b5ea396ac215dd6bf35547ff8b510" translate="yes" xml:space="preserve">
          <source>Using type cast expressions</source>
          <target state="translated">型キャスト式の使用</target>
        </trans-unit>
        <trans-unit id="4e74c3c3dbc90177ee7906987795cb4e37db9635" translate="yes" xml:space="preserve">
          <source>Using type cast expressions you can assert that values are certain types.</source>
          <target state="translated">型キャスト式を使用すると、値が特定の型であることを主張することができます。</target>
        </trans-unit>
        <trans-unit id="aba045b792a727f53d493f5cc2d4bbe68e26bbc6" translate="yes" xml:space="preserve">
          <source>Utility Types</source>
          <target state="translated">ユーティリティの種類</target>
        </trans-unit>
        <trans-unit id="d981987c61afbbc64d7655e2b4cdb6bf5b85cbce" translate="yes" xml:space="preserve">
          <source>Variable Types</source>
          <target state="translated">変数の種類</target>
        </trans-unit>
        <trans-unit id="3c555fe12c9dd11facd9128e236d5c42157a806e" translate="yes" xml:space="preserve">
          <source>Variance Sigils</source>
          <target state="translated">バリアンスサイン</target>
        </trans-unit>
        <trans-unit id="12e8ee8b0b460ae1489f8fa70aa448077ad5be60" translate="yes" xml:space="preserve">
          <source>Variance in Classes</source>
          <target state="translated">クラスの違い</target>
        </trans-unit>
        <trans-unit id="661548cc8ae30e106f079ae71da4e22fdee3f0a3" translate="yes" xml:space="preserve">
          <source>Variance is a topic that comes up fairly often in type systems and can be a bit confusing the first time you hear it. Let&amp;rsquo;s walk through each form of variance.</source>
          <target state="translated">分散は型システムでかなり頻繁に現れるトピックであり、初めて聞いたときに少し混乱する可能性があります。それぞれの分散形態について見ていきましょう。</target>
        </trans-unit>
        <trans-unit id="4f27c48fa3564f7410e0121a7646d154ac051a32" translate="yes" xml:space="preserve">
          <source>Variance sigils allow you to be more specific about how you intend to use your generics, giving Flow the power to do more precise type checking. For example, you may want this relationship to hold:</source>
          <target state="translated">バリアンス記号を使用することで、ジェネリックをどのように使用するかをより具体的に示すことができ、Flowではより正確な型チェックを行うことができます。例えば、次のような関係を保持したいとします。</target>
        </trans-unit>
        <trans-unit id="a78ad277616170813560c5fab7aabae8ac9cfb23" translate="yes" xml:space="preserve">
          <source>Vim</source>
          <target state="translated">Vim</target>
        </trans-unit>
        <trans-unit id="afbd00670e2a500077ed926aedfb070c71244c15" translate="yes" xml:space="preserve">
          <source>VimPlug</source>
          <target state="translated">VimPlug</target>
        </trans-unit>
        <trans-unit id="423f1f3d80c4d824ca917e13649a5c584a13ec87" translate="yes" xml:space="preserve">
          <source>Visual Studio Code</source>
          <target state="translated">Visual Studioコード</target>
        </trans-unit>
        <trans-unit id="3b8fd17bcb03bb77eb2cbfe9f38369745aa51b8d" translate="yes" xml:space="preserve">
          <source>Warning: That this is a &lt;em&gt;substring&lt;/em&gt; check, not a regular expression (for performance reasons).</source>
          <target state="translated">警告：これは&lt;em&gt;部分文字列&lt;/em&gt;チェックであり、正規表現ではありません（パフォーマンス上の理由から）。</target>
        </trans-unit>
        <trans-unit id="b8fd2f3a8255adad646ca5327eba0b8786744dbe" translate="yes" xml:space="preserve">
          <source>Warnings aren&amp;rsquo;t shown on the CLI by default, to avoid spew. CLI warnings can be enabled by passing the &amp;ndash;include-warnings flag to the Flow server or the Flow client, or by setting &amp;ldquo;include_warnings=true&amp;rdquo; in the &lt;code&gt;.flowconfig&lt;/code&gt;. This is good for smaller projects that want to see all project warnings at once.</source>
          <target state="translated">吐き出しを避けるため、デフォルトでは警告はCLIに表示されません。&amp;ndash;include-warningsフラグをフローサーバーまたはフロークライアントに &lt;code&gt;.flowconfig&lt;/code&gt; 、.flowconfigで「include_warnings = true」を設定することにより、CLI警告を有効にできます。これは、すべてのプロジェクト警告を一度に表示したい小規模なプロジェクトに適しています。</target>
        </trans-unit>
        <trans-unit id="fe8d40071f5a559a669afec325304551bb16aba4" translate="yes" xml:space="preserve">
          <source>Warnings don&amp;rsquo;t affect the exit code of Flow. If Flow finds warnings but no errors, it still returns 0.</source>
          <target state="translated">警告はFlowの終了コードには影響しません。Flowが警告を検出したがエラーを検出しなかった場合でも、0を返します。</target>
        </trans-unit>
        <trans-unit id="81f9219fd8a874b03e97d8fac13dedd6210a919b" translate="yes" xml:space="preserve">
          <source>Warnings have special &lt;a href=&quot;ide-integration&quot;&gt;IDE Integration&lt;/a&gt;.</source>
          <target state="translated">警告には特別な&lt;a href=&quot;ide-integration&quot;&gt;IDE統合があり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="bb2debe559facf651a601f9c7527b8296d8b9624" translate="yes" xml:space="preserve">
          <source>Watchman lazy mode has a few additional requirements.</source>
          <target state="translated">ウォッチマンのレイジーモードには、いくつかの追加要件があります。</target>
        </trans-unit>
        <trans-unit id="78080fc13eb28909de716d744a8a47810b22cd61" translate="yes" xml:space="preserve">
          <source>We also need &lt;code&gt;typeof&lt;/code&gt; for &lt;code&gt;Bar&lt;/code&gt; because &lt;code&gt;Bar&lt;/code&gt; is a value. So we want to get the type &lt;em&gt;of&lt;/em&gt; the value &lt;code&gt;Bar&lt;/code&gt;. &lt;code&gt;(Bar: Bar)&lt;/code&gt; is an error because &lt;code&gt;Bar&lt;/code&gt; cannot be used as a type, so the following is correct: &lt;code&gt;(Bar: typeof Bar)&lt;/code&gt;.</source>
          <target state="translated">また、必要 &lt;code&gt;typeof&lt;/code&gt; 演算のための &lt;code&gt;Bar&lt;/code&gt; ので、 &lt;code&gt;Bar&lt;/code&gt; 値です。だから我々は、タイプを取得したい&lt;em&gt;の&lt;/em&gt;値 &lt;code&gt;Bar&lt;/code&gt; 。 &lt;code&gt;(Bar: Bar)&lt;/code&gt; は、 &lt;code&gt;Bar&lt;/code&gt; をタイプとして使用できないためエラーです。したがって、 &lt;code&gt;(Bar: typeof Bar)&lt;/code&gt; は正しいです。</target>
        </trans-unit>
        <trans-unit id="565a855b54dc5d4e5feb1c24229c3c37a0aa82ca" translate="yes" xml:space="preserve">
          <source>We can try to express both of these objects in a single object type. However, we&amp;rsquo;ll quickly run into issues where we know a property exists based on the success property but Flow does not.</source>
          <target state="translated">これらの両方のオブジェクトを1つのオブジェクトタイプで表現することができます。ただし、successプロパティに基づいてプロパティが存在することがわかっていても、Flowには存在しないという問題がすぐに発生します。</target>
        </trans-unit>
        <trans-unit id="fb681ad5a4120e328dc7b7df6b9ecb5757df66ef" translate="yes" xml:space="preserve">
          <source>We can use this type alias to make sure reducers work correctly.</source>
          <target state="translated">このタイプのエイリアスを使用して、レデューサーが正しく動作するようにすることができます。</target>
        </trans-unit>
        <trans-unit id="0eb5411b6ed2d064b0d0e833606639f58a6b2b5f" translate="yes" xml:space="preserve">
          <source>We get this error message because &lt;code&gt;React.AbstractComponent&amp;lt;Config&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t set the &lt;code&gt;Instance&lt;/code&gt; type parameter, so it is automatically set to &lt;code&gt;mixed&lt;/code&gt;. If we wanted to preserve the instance type of the component, we can use &lt;a href=&quot;https://reactjs.org/docs/forwarding-refs.html&quot;&gt;&lt;code&gt;React.forwardRef&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;React.AbstractComponent&amp;lt;Config&amp;gt;&lt;/code&gt; は &lt;code&gt;Instance&lt;/code&gt; typeパラメーターを設定しないため、このエラーメッセージが表示され、自動的に &lt;code&gt;mixed&lt;/code&gt; に設定されます。コンポーネントのインスタンスタイプを保持したい場合は、&lt;a href=&quot;https://reactjs.org/docs/forwarding-refs.html&quot;&gt; &lt;code&gt;React.forwardRef&lt;/code&gt; &lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="14c408c67aca29a7fa863fd2f5d381f5c8273e88" translate="yes" xml:space="preserve">
          <source>We recommend you enable all your desired rules from the beginning, then adopt Flow Strict file-by-file. This works better than enabling a single rule, adding &lt;code&gt;@flow strict&lt;/code&gt; to many files, and then adding more rules to the config.</source>
          <target state="translated">最初から必要なルールをすべて有効にしてから、Flow Strictをファイルごとに採用することをお勧めします。これは、単一のルールを有効にし、 &lt;code&gt;@flow strict&lt;/code&gt; を多くのファイルに追加してから、構成にルールを追加するよりもうまく機能します。</target>
        </trans-unit>
        <trans-unit id="34abdcf44b0093985cf9e1d46481109cab9f85f9" translate="yes" xml:space="preserve">
          <source>We removed our dependency on &lt;code&gt;prop-types&lt;/code&gt; and added a Flow object type named &lt;code&gt;Props&lt;/code&gt; with the same shape as the prop types but using Flow&amp;rsquo;s static type syntax. Then we passed our new &lt;code&gt;Props&lt;/code&gt; type into &lt;code&gt;React.Component&lt;/code&gt; as a type argument.</source>
          <target state="translated">&lt;code&gt;prop-types&lt;/code&gt; への依存を削除し、Propタイプと同じ形状で、Flowの静的タイプ構文を使用して、 &lt;code&gt;Props&lt;/code&gt; という名前のFlowオブジェクトタイプを追加しました。次に、新しい &lt;code&gt;Props&lt;/code&gt; タイプをタイプ引数として &lt;code&gt;React.Component&lt;/code&gt; に渡しました。</target>
        </trans-unit>
        <trans-unit id="fdbcb95f6a23f42e50318e1968770b634c1e41d0" translate="yes" xml:space="preserve">
          <source>We set the type of props to &lt;code&gt;React.ChildrenArray&amp;lt;React.Element&amp;lt;typeof TabBarIOSItem&amp;gt;&amp;gt;&lt;/code&gt; which will guarantee that &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; must only have children that are &lt;code&gt;TabBarIOS.Item&lt;/code&gt; React elements.</source>
          <target state="translated">小道具のタイプを &lt;code&gt;React.ChildrenArray&amp;lt;React.Element&amp;lt;typeof TabBarIOSItem&amp;gt;&amp;gt;&lt;/code&gt; に設定します。これにより、 &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; は &lt;code&gt;TabBarIOS.Item&lt;/code&gt; React要素である子のみを持つ必要があることが保証されます。</target>
        </trans-unit>
        <trans-unit id="91fdfa76ed94bd3897d04cec5f4134f4e7bc035e" translate="yes" xml:space="preserve">
          <source>We will refer to all the types in the following reference as if we imported them with:</source>
          <target state="translated">でインポートしたかのように、以下の参照先のすべての型を参照します。</target>
        </trans-unit>
        <trans-unit id="d0deed72cfe69559a9e7c7724e402ecb7a9ed446" translate="yes" xml:space="preserve">
          <source>We would have a lot of trouble trying to write specific types for this function since it could be anything.</source>
          <target state="translated">この関数のために特定の型を書こうとすると、それは何でもあり得ることなので、多くの問題が発生します。</target>
        </trans-unit>
        <trans-unit id="54c34be58b1366378d47ad4ba8a861a9a07fe8d5" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll quickly set up our &lt;code&gt;BaseClass&lt;/code&gt; which will define just one method that accepts an input value with the type &lt;code&gt;City&lt;/code&gt; and an returned output also with the type &lt;code&gt;City&lt;/code&gt;.</source>
          <target state="translated">我々はすぐに私たちのセットアップよ &lt;code&gt;BaseClass&lt;/code&gt; のタイプで、入力値を受け入れるだけの一つの方法を定義します &lt;code&gt;City&lt;/code&gt; とも型で返された出力 &lt;code&gt;City&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f20c7e2164e3a5acb3717c0236d43d3267a9c8ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll use these classes to write a method that has each kind of variance.</source>
          <target state="translated">これらのクラスを使用して、さまざまな種類の分散を持つメソッドを記述します。</target>
        </trans-unit>
        <trans-unit id="04c0bd1c623d23997ff99f3caa7042e13039a782" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve demonstrated both nominal and structure typing of classes, but there are also other complex types like objects and functions which can also be either nominal or structural. Even further, they can be different within the same type system (most of the languages listed before has features of both).</source>
          <target state="translated">クラスの名義型と構造型の両方を示しましたが、名義型または構造型のオブジェクトや関数など、他の複雑な型もあります。さらに、それらは同じ型システム内で異なる場合があります（前述のほとんどの言語には両方の機能があります）。</target>
        </trans-unit>
        <trans-unit id="c5b6d6d89517eff4ce180cea4ab387ae48e094cb" translate="yes" xml:space="preserve">
          <source>WebStorm</source>
          <target state="translated">WebStorm</target>
        </trans-unit>
        <trans-unit id="d40a79cfe25e4cc102f0a57e8b44e1c01d37bcbb" translate="yes" xml:space="preserve">
          <source>WebStorm 2016.3</source>
          <target state="translated">WebStorm 2016.3</target>
        </trans-unit>
        <trans-unit id="6c3e64366f1d6fbef0a5c75ba4449cc79038d05d" translate="yes" xml:space="preserve">
          <source>WebStorm 2017.1</source>
          <target state="translated">WebStorm 2017.1</target>
        </trans-unit>
        <trans-unit id="8f14c5dae174ee34d208589e220dbdb169f943d4" translate="yes" xml:space="preserve">
          <source>Webstorm installation instructions can be found here:</source>
          <target state="translated">ウェブストームのインストール方法はこちらをご覧ください。</target>
        </trans-unit>
        <trans-unit id="44f3ba4fbbef59c08df191dcbed16fa19c8defe9" translate="yes" xml:space="preserve">
          <source>What do you think will happen?</source>
          <target state="translated">どうなると思いますか?</target>
        </trans-unit>
        <trans-unit id="4b5eba71e139ed73ff2a0e9b6ced493bb2e4087c" translate="yes" xml:space="preserve">
          <source>What happens when you have a single child?</source>
          <target state="translated">子供が一人産まれたらどうなるの?</target>
        </trans-unit>
        <trans-unit id="6966f9bf72c264264a3efaf8dc5ecfa61beb1bb2" translate="yes" xml:space="preserve">
          <source>What happens when you have multiple children?</source>
          <target state="translated">子供が複数いるとどうなるの?</target>
        </trans-unit>
        <trans-unit id="f268d50869e2db0c0130a3ca7a85cf1506065d2f" translate="yes" xml:space="preserve">
          <source>What is a Suppression?</source>
          <target state="translated">抑圧とは何か?</target>
        </trans-unit>
        <trans-unit id="12b550ae1d285f33798a42afbb386fd6afdc67f5" translate="yes" xml:space="preserve">
          <source>What is a subtype?</source>
          <target state="translated">サブタイプとは?</target>
        </trans-unit>
        <trans-unit id="ac4ecfb3127c03f684e91c1f130988581c874a06" translate="yes" xml:space="preserve">
          <source>What makes Flow fast?</source>
          <target state="translated">フローが速いのはなぜ?</target>
        </trans-unit>
        <trans-unit id="db33814c5657c00a949fba0af9d59dbafa3fcb1a" translate="yes" xml:space="preserve">
          <source>What makes Flow precise?</source>
          <target state="translated">フローの精度はどうなっているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="b9615372050b04d6519babea83812805557c5167" translate="yes" xml:space="preserve">
          <source>What was described above is a rather coarse grained way to determine coverage. One could imagine a criterion that flags expressions as uncovered if &lt;em&gt;any&lt;/em&gt; part of their type includes &lt;code&gt;any&lt;/code&gt;, for example &lt;code&gt;Array&amp;lt;any&amp;gt;&lt;/code&gt;. While there is value in a metric like this, the &amp;ldquo;uncovered&amp;rdquo; part of the type will typically be uncovered through various operations on values of this type. For example, in the code</source>
          <target state="translated">上で説明したのは、カバレッジを決定するためのかなり粗い方法です。型の&lt;em&gt;いずれかの&lt;/em&gt;部分に &lt;code&gt;any&lt;/code&gt; 含まれている場合、たとえば &lt;code&gt;Array&amp;lt;any&amp;gt;&lt;/code&gt; ように、式にカバーされていないものとしてフラグを立てる基準を想像することができます。このようなメトリックには値がありますが、タイプの「カバーされていない」部分は通常、このタイプの値に対するさまざまな操作によってカバーされます。たとえば、コードでは</target>
        </trans-unit>
        <trans-unit id="0fd65380fb716403292b7d92faef2766c527f8ab" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s Ahead</source>
          <target state="translated">今後の予定</target>
        </trans-unit>
        <trans-unit id="c5e189be8dd7a5933934ab2b958e415933a6e5ad" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s a &amp;ldquo;Library Definition&amp;rdquo;?</source>
          <target state="translated">「ライブラリ定義」とは何ですか？</target>
        </trans-unit>
        <trans-unit id="40731c621de61ed4b398992215b3e1a3b5986f84" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s a Declaration File?</source>
          <target state="translated">宣言ファイルとは何ですか？</target>
        </trans-unit>
        <trans-unit id="b9efc85fa229daf00790235bc1d272e8bf51c10c" translate="yes" xml:space="preserve">
          <source>When an object type has an indexer property, property accesses are assumed to have the annotated type, even if the object does not have a value in that slot at runtime. It is the programmer&amp;rsquo;s responsibility to ensure the access is safe, as with arrays.</source>
          <target state="translated">オブジェクトタイプにインデクサープロパティがある場合、実行時にオブジェクトのスロットに値がない場合でも、プロパティアクセスには注釈付きのタイプがあると見なされます。配列と同様に、アクセスが安全であることを保証するのはプログラマーの責任です。</target>
        </trans-unit>
        <trans-unit id="f8b96e1aead97a6dccb4198de5ff7a26c459a398" translate="yes" xml:space="preserve">
          <source>When are subtypes used?</source>
          <target state="translated">サブタイプはどのような場合に使用されますか?</target>
        </trans-unit>
        <trans-unit id="1f4a3bdc8dfbb9e08a8423a54448b12d02bbd84f" translate="yes" xml:space="preserve">
          <source>When calling our function that accepts a union type we must pass in &lt;strong&gt;&lt;em&gt;one of those types&lt;/em&gt;&lt;/strong&gt;. But inside of our function we are required to handle &lt;strong&gt;&lt;em&gt;all of the possible types&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">共用体型を受け入れる関数を呼び出すときは、&lt;strong&gt;&lt;em&gt;それらの型の1つを&lt;/em&gt;&lt;/strong&gt;渡す必要があり&lt;strong&gt;&lt;em&gt;ます&lt;/em&gt;&lt;/strong&gt;。しかし、関数の内部で&lt;strong&gt;&lt;em&gt;は、可能なすべての型&lt;/em&gt;&lt;/strong&gt;を処理する必要があり&lt;strong&gt;&lt;em&gt;ます&lt;/em&gt;&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="302b36e230abf6c143e3b19fe2499d796c35aef9" translate="yes" xml:space="preserve">
          <source>When comparing a function type with a function it must have the same structure in order to be considered valid.</source>
          <target state="translated">関数型と関数を比較する場合、有効とみなされるためには同じ構造を持っていなければなりません。</target>
        </trans-unit>
        <trans-unit id="64ef3ae0ab9bcb0e4ab1d4e8a1404fcbb0a3607c" translate="yes" xml:space="preserve">
          <source>When comparing an object type with an object it must have the same structure in order to be considered valid.</source>
          <target state="translated">オブジェクト型とオブジェクトを比較する場合、有効とみなされるためには同じ構造を持っていなければなりません。</target>
        </trans-unit>
        <trans-unit id="8396399d85dff5129d383218ce52eac55a623a9e" translate="yes" xml:space="preserve">
          <source>When importing an opaque type alias, it behaves like a &lt;a href=&quot;https://flow.org/en/lang/nominal-structural/#toc-nominal-typing&quot;&gt;nominal type&lt;/a&gt;, hiding its underlying type.</source>
          <target state="translated">不透明な型のエイリアスをインポートすると、&lt;a href=&quot;https://flow.org/en/lang/nominal-structural/#toc-nominal-typing&quot;&gt;名義型の&lt;/a&gt;ように動作し、その基礎となる型が非表示になります。</target>
        </trans-unit>
        <trans-unit id="d2485de3e0573347cabc863911d04dfca31e158c" translate="yes" xml:space="preserve">
          <source>When in the same file the alias is defined, opaque type aliases behave exactly as regular &lt;a href=&quot;../aliases&quot;&gt;type aliases&lt;/a&gt; do.</source>
          <target state="translated">同じファイルでエイリアスが定義されている場合、不透明な型のエイリアスは通常の&lt;a href=&quot;../aliases&quot;&gt;型のエイリアスと&lt;/a&gt;まったく同じように動作します。</target>
        </trans-unit>
        <trans-unit id="fcb175c445847655877f1db30e472a996195f098" translate="yes" xml:space="preserve">
          <source>When setting a new value inside a tuple, the new value must match the type at that index.</source>
          <target state="translated">タプル内に新しい値を設定する場合、新しい値はそのインデックスの型と一致している必要があります。</target>
        </trans-unit>
        <trans-unit id="7517a9e192b4a198ec7b3f51067f670add7135eb" translate="yes" xml:space="preserve">
          <source>When someone writes a class, they are declaring a &lt;em&gt;thing&lt;/em&gt;. This thing might have the same structure as something else but they still serve different purposes. Imagine two component classes that both have &lt;code&gt;render()&lt;/code&gt; methods, these components could still have totally different purposes, but in a structural type system they&amp;rsquo;d be considered exactly the same.</source>
          <target state="translated">誰かがクラスを書くとき、彼らは&lt;em&gt;物事&lt;/em&gt;を宣言してい&lt;em&gt;ます&lt;/em&gt;。このものは他のものと同じ構造を持つかもしれませんが、それらはまだ異なる目的を果たします。 &lt;code&gt;render()&lt;/code&gt; メソッドを持つ2つのコンポーネントクラスを想像してみてください。これらのコンポーネントの目的はまったく異なる可能性がありますが、構造型システムではまったく同じものと見なされます。</target>
        </trans-unit>
        <trans-unit id="95d1e8cda45984711f6710361a85006d8bcb3ff6" translate="yes" xml:space="preserve">
          <source>When the request fails, we&amp;rsquo;ll get back an object with &lt;code&gt;success&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; and an &lt;code&gt;error&lt;/code&gt; property describing the error.</source>
          <target state="translated">リクエストが失敗すると、 &lt;code&gt;success&lt;/code&gt; を &lt;code&gt;false&lt;/code&gt; に設定したオブジェクトと、 &lt;code&gt;error&lt;/code&gt; を説明するエラープロパティが返されます。</target>
        </trans-unit>
        <trans-unit id="b94abdda8ce69397406ef44dd82ee02693dedecd" translate="yes" xml:space="preserve">
          <source>When this flag is &lt;code&gt;true&lt;/code&gt;, Flow has the following behavior:</source>
          <target state="translated">このフラグが &lt;code&gt;true&lt;/code&gt; の場合、フローは次のように動作します。</target>
        </trans-unit>
        <trans-unit id="1be3aebbba7f2ab96d8a1da1d160dd3a2c2cfa21" translate="yes" xml:space="preserve">
          <source>When using a generic type for a value, Flow will track the value and make sure that you aren&amp;rsquo;t replacing it with something else.</source>
          <target state="translated">値にジェネリック型を使用する場合、フローは値を追跡し、それを他のもので置き換えていないことを確認します。</target>
        </trans-unit>
        <trans-unit id="967200160ca1f6e61c2f31daca12d9063b3bdc5b" translate="yes" xml:space="preserve">
          <source>When using this syntax, you are not required to give it a type annotation. But you still can if you need to.</source>
          <target state="translated">この構文を使用する場合、型のアノテーションを与える必要はありません。しかし、必要であれば与えても構いません。</target>
        </trans-unit>
        <trans-unit id="5028ae04135e00456a2a9a3d217b11e267ea9467" translate="yes" xml:space="preserve">
          <source>When you add a subtyping constraint to an opaque type alias, we allow the opaque type to be used as the super type when outside of the defining file.</source>
          <target state="translated">不透明な型のエイリアスにサブタイプ制約を追加すると、定義ファイルの外では不透明な型をスーパー型として使用できるようにします。</target>
        </trans-unit>
        <trans-unit id="7f4548b3e8ef7180dc3aa259a4fafbe13e9785c6" translate="yes" xml:space="preserve">
          <source>When you are certain your code works and for some reason Flow is unable to type check it correctly. There are a (decreasing) number of idioms in JavaScript that Flow is unable to statically type.</source>
          <target state="translated">自分のコードが動作していると確信しているのに、何らかの理由でFlowが正しくタイプできない場合は、それをチェックしてください。JavaScriptには、Flowが静的にタイプできないイディオムが(減少して)存在します。</target>
        </trans-unit>
        <trans-unit id="0640e9c67a5446e2d096da264d95ec5c0854ffcf" translate="yes" xml:space="preserve">
          <source>When you are declaring a new variable, you may optionally declare its type.</source>
          <target state="translated">新しい変数を宣言する際には、オプションでその型を宣言することができます。</target>
        </trans-unit>
        <trans-unit id="7d4a50c3c1cd36ed94156b1a9f3ca046b8801870" translate="yes" xml:space="preserve">
          <source>When you are getting a value from a tuple at a specific index, it will return the type at that index.</source>
          <target state="translated">特定のインデックスでタプルから値を取得している場合は、そのインデックスの型を返します。</target>
        </trans-unit>
        <trans-unit id="01a3af0d6ce8b90608026581625e6d89d89308d5" translate="yes" xml:space="preserve">
          <source>When you are in the process of converting existing code to using Flow types and you are currently blocked on having the code type checked (maybe other code needs to be converted first).</source>
          <target state="translated">既存のコードをフロータイプを使用して変換している最中で、現在コードタイプのチェックがブロックされている場合(他のコードを先に変換する必要があるかもしれません)。</target>
        </trans-unit>
        <trans-unit id="e1e90957894730cc07cfd478f29c1f4e5b53f0ac" translate="yes" xml:space="preserve">
          <source>When you create an intersection of object types, you merge all of their properties together.</source>
          <target state="translated">オブジェクトタイプの交差点を作成するときは、それらのプロパティをすべてマージします。</target>
        </trans-unit>
        <trans-unit id="e5b45384d6cd9faea2b667285789acfc51eefb58" translate="yes" xml:space="preserve">
          <source>When you create an object with its properties, you create a &lt;em&gt;sealed&lt;/em&gt; object type in Flow. These sealed objects will know all of the properties you declared them with and the types of their values.</source>
          <target state="translated">プロパティを持つオブジェクトを作成するときは、Flowで&lt;em&gt;シールされた&lt;/em&gt;オブジェクトタイプを作成します。これらのシールされたオブジェクトは、宣言したすべてのプロパティとそれらの値のタイプを知っています。</target>
        </trans-unit>
        <trans-unit id="a41115243f1e2d1d0a4ea4f2efbfe55245e33a0c" translate="yes" xml:space="preserve">
          <source>When you create an object without any properties, you create an &lt;em&gt;unsealed&lt;/em&gt; object type in Flow. These unsealed objects will not know all of their properties and will allow you to add new ones.</source>
          <target state="translated">プロパティなしでオブジェクトを作成すると、フローで&lt;em&gt;封印されていない&lt;/em&gt;オブジェクトタイプが作成&lt;em&gt;され&lt;/em&gt;ます。これらの封印されていないオブジェクトは、それらのプロパティのすべてを知っているわけではなく、新しいオブジェクトを追加できます。</target>
        </trans-unit>
        <trans-unit id="2796a6c82e1741b853aad01a67eda238fc96c9eb" translate="yes" xml:space="preserve">
          <source>When you create an opaque type alias with a subtyping constraint, the type in the type position must be a subtype of the type in the super type position.</source>
          <target state="translated">サブタイプ制約付きの不透明な型エイリアスを作成する場合、型位置の型はスーパー型位置の型のサブタイプでなければなりません。</target>
        </trans-unit>
        <trans-unit id="49218e622c26dc57b5c913ea8900e0123789162a" translate="yes" xml:space="preserve">
          <source>When you do not provide a type, the inferred type will do one of two things if you re-assign it.</source>
          <target state="translated">型を指定しなかった場合、再指定すると推論された型は次の2つのうちの1つのことを行います。</target>
        </trans-unit>
        <trans-unit id="dad7818449b82b15d065d9c37e04d1727c40f683" translate="yes" xml:space="preserve">
          <source>When you have a value which is a union type it&amp;rsquo;s often useful to break it apart and handle each individual type separately. With union types in Flow you can &amp;ldquo;refine&amp;rdquo; the value down to a single type.</source>
          <target state="translated">共用体型の値がある場合、それを分解して個々の型を個別に処理すると便利なことがよくあります。フローのユニオンタイプを使用すると、値を単一のタイプに「絞り込み」できます。</target>
        </trans-unit>
        <trans-unit id="bb229dc9cf4f41267624f023e36cd675a57c24d6" translate="yes" xml:space="preserve">
          <source>When you have a value with the type &lt;code&gt;any&lt;/code&gt;, you can cause Flow to infer &lt;code&gt;any&lt;/code&gt; for the results of all of the operations you perform.</source>
          <target state="translated">タイプ &lt;code&gt;any&lt;/code&gt; の値がある場合、実行するすべての操作の結果に対してFlowに &lt;code&gt;any&lt;/code&gt; を推測させることができます。</target>
        </trans-unit>
        <trans-unit id="4eeac5c8af6e744b935a9344a38a377561163682" translate="yes" xml:space="preserve">
          <source>When you have complicated types that you want to reuse in multiple places, you can alias them in Flow using a &lt;strong&gt;type alias&lt;/strong&gt;.</source>
          <target state="translated">複数の場所で再利用したい複雑な型がある場合、&lt;strong&gt;型エイリアス&lt;/strong&gt;を使用してFlowでそれらにエイリアスを設定できます。</target>
        </trans-unit>
        <trans-unit id="d25839cb54cf8d678ab4f10e96c01f04e2a7fa3e" translate="yes" xml:space="preserve">
          <source>When you have properties that overlap by having the same name, Flow follows the same strategy as with overloaded functions: it will return the type of the first property that matches this name.</source>
          <target state="translated">同じ名前を持つことで重複するプロパティがある場合、Flowはオーバーロードされた関数と同じ戦略に従います:この名前にマッチする最初のプロパティの型を返します。</target>
        </trans-unit>
        <trans-unit id="9ca6b3bbee47f3932b78bb3624b2a8e13ee5660b" translate="yes" xml:space="preserve">
          <source>When you have two classes with the same structure, they still are not considered equivalent because Flow uses nominal typing for classes.</source>
          <target state="translated">同じ構造を持つ2つのクラスがある場合でも、Flowはクラスに名目型付けを使用しているため、それらは同等とはみなされません。</target>
        </trans-unit>
        <trans-unit id="10b1b571956caaa58b630e76dcdcbd496c248766" translate="yes" xml:space="preserve">
          <source>When you provide a type, you will be able to re-assign the value, but it must always be of a compatible type.</source>
          <target state="translated">型を提供すると、値を再代入することができますが、常に互換性のある型でなければなりません。</target>
        </trans-unit>
        <trans-unit id="73cb2287de1c6f15cf8167e43a3d3d87043228a3" translate="yes" xml:space="preserve">
          <source>When you retrieve an element from an array there is always a possibility that it is &lt;code&gt;undefined&lt;/code&gt;. You could have either accessed an index which is out of the bounds of the array, or the element could not exist because it is a &amp;ldquo;sparse array&amp;rdquo;.</source>
          <target state="translated">配列から要素を取得するときは、常に &lt;code&gt;undefined&lt;/code&gt; ある可能性があります。配列の範囲外のインデックスにアクセスしたか、「疎配列」であるために要素が存在しなかった可能性があります。</target>
        </trans-unit>
        <trans-unit id="996a2595f6a66f040b899960922e9f1e015492aa" translate="yes" xml:space="preserve">
          <source>When you run your code, a single expression will only be run with a limited set of values. But still Flow checks &lt;em&gt;every&lt;/em&gt; possible value. In this way Flow is checking too many things or &lt;em&gt;over-approximating&lt;/em&gt; what will be valid code.</source>
          <target state="translated">コードを実行すると、単一の式は限られた値のセットでのみ実行されます。ただし、Flowは可能な&lt;em&gt;すべての&lt;/em&gt;値をチェックします。このようにして、Flowはチェックする対象が多すぎたり&lt;em&gt;、&lt;/em&gt;有効なコードとなるものを&lt;em&gt;概算し&lt;/em&gt;すぎたり&lt;em&gt;してい&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="cfdf2c27394909eba3b1ac9709368e9e60c92c6c" translate="yes" xml:space="preserve">
          <source>When you strip the types all that is left is the value.</source>
          <target state="translated">型を取り除くと、残るのは値だけです。</target>
        </trans-unit>
        <trans-unit id="16d02930754982f643818365c9eb65e4b4b501a2" translate="yes" xml:space="preserve">
          <source>When you try to use a value of a &lt;code&gt;mixed&lt;/code&gt; type you must first figure out what the actual type is or you&amp;rsquo;ll end up with an error.</source>
          <target state="translated">&lt;code&gt;mixed&lt;/code&gt; 型の値を使用しようとすると、最初に実際の型が何であるかを理解する必要があります。そうしないと、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="5a280997d975deface44a674ffdcce743182e95b" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;typeof&lt;/code&gt;, you&amp;rsquo;re inserting another type with all of its behaviors. This can make &lt;code&gt;typeof&lt;/code&gt; seem inconsistent where it is not.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; を使用すると、すべての動作を備えた別の型が挿入されます。これにより、 &lt;code&gt;typeof&lt;/code&gt; が一貫していないように見える場合があります。</target>
        </trans-unit>
        <trans-unit id="d77557c593fb829bce95fc59df4b1a3be746ce8b" translate="yes" xml:space="preserve">
          <source>When you use the name of your class in an annotation, it means an &lt;em&gt;instance&lt;/em&gt; of your class:</source>
          <target state="translated">アノテーションでクラスの名前を使用する場合、それはクラスの&lt;em&gt;インスタンス&lt;/em&gt;を意味し&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="06a3b2f1c8635c3489f18114c859485b4887b6c9" translate="yes" xml:space="preserve">
          <source>When you use this function, Flow knows exactly what is going on.</source>
          <target state="translated">この機能を使用すると、Flowは何が起こっているかを正確に把握しています。</target>
        </trans-unit>
        <trans-unit id="b433fb4be7e2c12ca3f57f9ed0a23cad0b0d75ad" translate="yes" xml:space="preserve">
          <source>When you write a type cast expression, the result of that expression is the value with the provided type. If you hold onto the resulting value, it will have the new type.</source>
          <target state="translated">型キャスト式を書くと、その式の結果は、指定された型を持つ値になります。結果の値を保持すると、その値は新しい型を持つことになります。</target>
        </trans-unit>
        <trans-unit id="f5f053b01bbe2e5493eb03b59a33406b2934f8f5" translate="yes" xml:space="preserve">
          <source>Whenever you want to use a class field in Flow you must first give it an annotation.</source>
          <target state="translated">Flowでクラスフィールドを使用したい場合は、必ず最初にアノテーションを付けなければなりません。</target>
        </trans-unit>
        <trans-unit id="007c9142c650370d910eaa325adeac0c9f34bd33" translate="yes" xml:space="preserve">
          <source>Where to put the &lt;code&gt;.flowconfig&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.flowconfig&lt;/code&gt; を配置する場所</target>
        </trans-unit>
        <trans-unit id="f9cd9b92722317ed472575adad6561c4aaa8a0c9" translate="yes" xml:space="preserve">
          <source>Which also applies to nested types within objects.</source>
          <target state="translated">これは、オブジェクト内の入れ子になった型にも適用されます。</target>
        </trans-unit>
        <trans-unit id="5d77dcbc51b2f3900b8512f7fcc4c2e9f1910a53" translate="yes" xml:space="preserve">
          <source>Which then gets used as its own type.</source>
          <target state="translated">それはそれ自身のタイプとして使用されます。</target>
        </trans-unit>
        <trans-unit id="8a80fced10ab4b19389a445b9f4af05de4c583bb" translate="yes" xml:space="preserve">
          <source>Which would ignore any file or directory under the directory named &lt;code&gt;__tests__/&lt;/code&gt; within the project root. However, unlike the previous example&amp;rsquo;s &lt;code&gt;.*/__tests__/.*&lt;/code&gt;, it would NOT ignore files or directories under other directories named &lt;code&gt;__tests__/&lt;/code&gt;, like &lt;code&gt;src/__tests__/&lt;/code&gt;.</source>
          <target state="translated">プロジェクトルート内の &lt;code&gt;__tests__/&lt;/code&gt; という名前のディレクトリの下にあるファイルまたはディレクトリは無視されます。ただし、前の例の &lt;code&gt;.*/__tests__/.*&lt;/code&gt; &lt;code&gt;__tests__/&lt;/code&gt; とは異なり、 &lt;code&gt;src/__tests__/&lt;/code&gt; などの__tests __ /という名前の他のディレクトリの下のファイルまたはディレクトリは無視されません。</target>
        </trans-unit>
        <trans-unit id="c59a762c09f756bb3fe009f558e38099bc0a51a6" translate="yes" xml:space="preserve">
          <source>Which would parse in declaration mode any file or directory under the directory named &lt;code&gt;third_party/&lt;/code&gt; within the project root. However, unlike the previous example&amp;rsquo;s &lt;code&gt;.*/third_party/.*&lt;/code&gt;, it would NOT parse files or directories under directories named &lt;code&gt;third_party/&lt;/code&gt;, like &lt;code&gt;src/third_party/&lt;/code&gt;.</source>
          <target state="translated">宣言モードでは、プロジェクトルート内の &lt;code&gt;third_party/&lt;/code&gt; という名前のディレクトリの下にあるファイルまたはディレクトリを解析します。ただし、前の例の &lt;code&gt;.*/third_party/.*&lt;/code&gt; とは異なり、 &lt;code&gt;src/third_party/&lt;/code&gt; ような、 &lt;code&gt;third_party/&lt;/code&gt; という名前のディレクトリの下のファイルやディレクトリは解析されません。</target>
        </trans-unit>
        <trans-unit id="6bbea4304dd73554152ad23aedd562115dbd9129" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;all&lt;/code&gt; isn&amp;rsquo;t technically a lint rule, it&amp;rsquo;s worth mentioning here. &lt;code&gt;all&lt;/code&gt; sets the default level for lint rules that don&amp;rsquo;t have a level set explicitly. &lt;code&gt;all&lt;/code&gt; can only occur as the first entry in a &lt;code&gt;.flowconfig&lt;/code&gt; or as the first rule in a &lt;code&gt;--lints&lt;/code&gt; flag. It&amp;rsquo;s not allowed in comments at all because it would have different semantics than would be expected.</source>
          <target state="translated">一方で &lt;code&gt;all&lt;/code&gt; 技術的に糸くずのルールではありません、それはここで言及する価値があります。 &lt;code&gt;all&lt;/code&gt; 明示的にレベルが設定されていないlintルールのデフォルトレベルを設定します。 &lt;code&gt;all&lt;/code&gt; は、 &lt;code&gt;.flowconfig&lt;/code&gt; の最初のエントリとして、または &lt;code&gt;--lints&lt;/code&gt; フラグの最初のルールとしてのみ発生します。予想とは異なるセマンティクスを持つため、コメントでは許可されていません。</target>
        </trans-unit>
        <trans-unit id="52ea1ea47df53d1cf736a6d4890e67395ca8b9c4" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I pass &lt;code&gt;{a:string}&lt;/code&gt; to a function that takes &lt;code&gt;{a:string|&amp;nbsp;number}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{a:string|&amp;nbsp;number}&lt;/code&gt; を取る関数に &lt;code&gt;{a:string}&lt;/code&gt; を渡せないのはなぜですか？数}</target>
        </trans-unit>
        <trans-unit id="fe6cefc353f86770ed15c2136f41c2eff2427e68" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I pass an &lt;code&gt;Array&amp;lt;string&amp;gt;&lt;/code&gt; to a function that takes an &lt;code&gt;Array&amp;lt;string |&amp;nbsp;number&amp;gt;&lt;/code&gt;</source>
          <target state="translated">なぜ私は渡すことはできません &lt;code&gt;Array&amp;lt;string&amp;gt;&lt;/code&gt; 取る関数に &lt;code&gt;Array&amp;lt;string |&amp;nbsp;number&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96c5c443e0f5b7e99e95365f6c4edd88369864cd" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I refine a union of objects?</source>
          <target state="translated">オブジェクトの結合を洗練できないのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="6e3de66a2c90224644ba944e2aa7479606459060" translate="yes" xml:space="preserve">
          <source>Why can&amp;rsquo;t I use a function in my if-clause to check the type of a property?</source>
          <target state="translated">if節で関数を使用してプロパティのタイプをチェックできないのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="30ff0da03e55358af58809fea89afe7aa72356c6" translate="yes" xml:space="preserve">
          <source>Width Subtyping</source>
          <target state="translated">幅のサブタイプ</target>
        </trans-unit>
        <trans-unit id="c4a257d9d182ebc37abf03c9319df6d8959cf5db" translate="yes" xml:space="preserve">
          <source>With Flow build step, using flow-bin</source>
          <target state="translated">フロービルドステップでは、フロービンを使用して</target>
        </trans-unit>
        <trans-unit id="2995c53166bcc91b45280d17fe04fd71848fc06d" translate="yes" xml:space="preserve">
          <source>With exact object types, we cannot have additional properties, so the objects conflict with one another and we are able to distinguish which is which.</source>
          <target state="translated">厳密なオブジェクトタイプでは、追加のプロパティを持つことができないので、オブジェクトは互いに競合し、どちらがどちらであるかを区別することができます。</target>
        </trans-unit>
        <trans-unit id="c6943265cff3d8a72357d6db4963743033fc9d4b" translate="yes" xml:space="preserve">
          <source>With modularity, we can aggressively parallelize our analysis. Furthermore, when files change, we can incrementally analyze only those files that depend on the changed files. Together, these choices have helped scale the analysis to millions of lines of code.</source>
          <target state="translated">モジュール化することで、解析を積極的に並列化することができます。さらに、ファイルが変更された場合、変更されたファイルに依存するファイルのみをインクリメンタルに解析することができます。これらの選択により、解析を何百万行ものコードにスケールアップすることができました。</target>
        </trans-unit>
        <trans-unit id="3574433dfccbc2cdc3e7d09b6a827e56cbb69b39" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;method&lt;/code&gt;, we know that &lt;code&gt;obj&lt;/code&gt; has at least a property &lt;code&gt;foo&lt;/code&gt; and the property access expression &lt;code&gt;obj.foo&lt;/code&gt; will have type &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;method&lt;/code&gt; 内では、 &lt;code&gt;obj&lt;/code&gt; には少なくともプロパティ &lt;code&gt;foo&lt;/code&gt; があり、プロパティアクセス式 &lt;code&gt;obj.foo&lt;/code&gt; は &lt;code&gt;string&lt;/code&gt; 型を持つことがわかります。</target>
        </trans-unit>
        <trans-unit id="7f4fbc91308a94a65821208a1c024c9c0775a04d" translate="yes" xml:space="preserve">
          <source>Within the -lints flag and the flowconfig, rules lower down override rules higher up, allowing you to write things like</source>
          <target state="translated">lintsフラグとflowconfigの中では、下位のルールは上位のルールを上書きし、以下のようなことを書くことができます。</target>
        </trans-unit>
        <trans-unit id="c37d919a96ee4ea89b463c060f82bc0a6e402a8f" translate="yes" xml:space="preserve">
          <source>Within the Defining File</source>
          <target state="translated">定義ファイル内</target>
        </trans-unit>
        <trans-unit id="d68dc31f474400f6b50bf4dad60cd35f6668b0b3" translate="yes" xml:space="preserve">
          <source>Within the body of a &lt;code&gt;declare module&lt;/code&gt; block, you can specify the set of exports for that module. However, before we start talking about exports we have to talk about the two kinds of modules that Flow supports: CommonJS and ES modules.</source>
          <target state="translated">&lt;code&gt;declare module&lt;/code&gt; ブロックの本体内で、そのモジュールのエクスポートのセットを指定できます。ただし、エクスポートについて説明する前に、Flowがサポートする2種類のモジュール（CommonJSおよびESモジュール）について説明する必要があります。</target>
        </trans-unit>
        <trans-unit id="a3933bb581c579641e65e780ba1a7fc018cbb1e5" translate="yes" xml:space="preserve">
          <source>Write Flow Code</source>
          <target state="translated">フローコードを書く</target>
        </trans-unit>
        <trans-unit id="0d42dc7f273412358b6af025e21835f6b2b59f3c" translate="yes" xml:space="preserve">
          <source>You are destructuring the object. When destructuring, Flow loses track of object properties.</source>
          <target state="translated">オブジェクトを破壊しています。オブジェクトを破壊すると、Flowはオブジェクトのプロパティを追跡できなくなります。</target>
        </trans-unit>
        <trans-unit id="5a1fd67e5d3bc9809749035f19782f6067817cf6" translate="yes" xml:space="preserve">
          <source>You are not allowed to do the following when using &lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;&amp;lt;TabBarIOS&amp;gt;&lt;/code&gt; を使用する場合、次のことは許可されていません。</target>
        </trans-unit>
        <trans-unit id="cb97175b80248d75078c2d56240c55e682afdb8b" translate="yes" xml:space="preserve">
          <source>You are using inexact objects.</source>
          <target state="translated">不正確なオブジェクトを使用しています。</target>
        </trans-unit>
        <trans-unit id="545f113ee57613cf761d4e16a9296f0dddf18ea1" translate="yes" xml:space="preserve">
          <source>You can add methods to interfaces following the same syntax as object methods.</source>
          <target state="translated">オブジェクトメソッドと同じ構文に従って、インターフェースにメソッドを追加することができます。</target>
        </trans-unit>
        <trans-unit id="f13b654915322571d79f9d2209ebb3f541cb4c01" translate="yes" xml:space="preserve">
          <source>You can add properties to interfaces following the same syntax as object properties.</source>
          <target state="translated">オブジェクトのプロパティと同じ構文に従って、インターフェースにプロパティを追加することができます。</target>
        </trans-unit>
        <trans-unit id="0ff142ce9ee3fec9b4cc52b1ba40b05d9245d3f7" translate="yes" xml:space="preserve">
          <source>You can add support for Flow in Emacs by using &lt;a href=&quot;https://github.com/flowtype/flow-for-emacs&quot;&gt;flow-for-emacs&lt;/a&gt;</source>
          <target state="translated">EmacsでFlowのサポートを追加するには、&lt;a href=&quot;https://github.com/flowtype/flow-for-emacs&quot;&gt;flow-for-emacsを使用します。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f60bece6a43fa1f4f89bb550305ddcf7599cfe4f" translate="yes" xml:space="preserve">
          <source>You can add this to your &lt;code&gt;package.json&lt;/code&gt; scripts easily.</source>
          <target state="translated">これは、 &lt;code&gt;package.json&lt;/code&gt; スクリプトに簡単に追加できます。</target>
        </trans-unit>
        <trans-unit id="c722675694802907c5488d3f01827234fdbd4367" translate="yes" xml:space="preserve">
          <source>You can also add type annotations for rest parameters using the same syntax but with an &lt;code&gt;Array&lt;/code&gt;.</source>
          <target state="translated">同じ構文を使用して、 &lt;code&gt;Array&lt;/code&gt; を使用して、残りのパラメーターの型注釈を追加することもできます。</target>
        </trans-unit>
        <trans-unit id="e71d63fcbe7402ef7a02851894adf81dac971541" translate="yes" xml:space="preserve">
          <source>You can also adopt Flow incrementally and easily remove it at anytime, so you can try Flow out on any codebase and see how you like it.</source>
          <target state="translated">また、Flowは段階的に採用することができ、いつでも簡単に削除することができるので、どんなコードベースでも試してみて、自分の好みを確認することができます。</target>
        </trans-unit>
        <trans-unit id="699187814f44354c9d5904df70d1d9ddacb546d5" translate="yes" xml:space="preserve">
          <source>You can also create arrays and add values to them later on:</source>
          <target state="translated">また、後から配列を作成して、そこに値を追加することもできます。</target>
        </trans-unit>
        <trans-unit id="c646f56329a9cb5b56e87a03fe5b8a2719eb6c74" translate="yes" xml:space="preserve">
          <source>You can also declare opaque type aliases in &lt;a href=&quot;../libdefs&quot;&gt;libdefs&lt;/a&gt;. There, you omit the underlying type, but may still optionally include a super type.</source>
          <target state="translated">&lt;a href=&quot;../libdefs&quot;&gt;libdefsで&lt;/a&gt;不透明型のエイリアスを宣言することもできます。そこでは、基礎となる型を省略しますが、オプションでスーパー型を含めることもできます。</target>
        </trans-unit>
        <trans-unit id="cdd17629705a4d950906c4a4641c7cec10003dd5" translate="yes" xml:space="preserve">
          <source>You can also give generic classes type arguments directly in the &lt;code&gt;new&lt;/code&gt; expression:</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 式でジェネリッククラスの型引数を直接指定することもできます。</target>
        </trans-unit>
        <trans-unit id="b0940d878e3d44c8bd9c7d98cbd45fecf2f71a13" translate="yes" xml:space="preserve">
          <source>You can also have optional parameters by adding a question mark &lt;code&gt;?&lt;/code&gt; after the name of the parameter and before the colon &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">疑問符を追加することで、オプションのパラメーターを使用することもできます &lt;code&gt;?&lt;/code&gt; パラメータの名前の後にコロンの前に &lt;code&gt;:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cbe3e05438e8030d576dbde48b1eceb1121d9a3" translate="yes" xml:space="preserve">
          <source>You can also nest calls to &lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt;, which is useful when you need to access the types inside nested structures:</source>
          <target state="translated">&lt;code&gt;$ElementType&amp;lt;T, K&amp;gt;&lt;/code&gt; への呼び出しをネストすることもできます。これは、ネストされた構造内の型にアクセスする必要がある場合に便利です。</target>
        </trans-unit>
        <trans-unit id="8c12a05528aaeb309adc27e2605804422f3d3660" translate="yes" xml:space="preserve">
          <source>You can also pass &lt;code&gt;--types-first&lt;/code&gt; to the &lt;code&gt;flow check&lt;/code&gt; or &lt;code&gt;flow start&lt;/code&gt; commands.</source>
          <target state="translated">&lt;code&gt;--types-first&lt;/code&gt; を &lt;code&gt;flow check&lt;/code&gt; または &lt;code&gt;flow start&lt;/code&gt; コマンドに渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="815ff0c60624ac9094cf1c49f665f71a3473e58d" translate="yes" xml:space="preserve">
          <source>You can also provide defaults for parameterized generics just like parameters of a function.</source>
          <target state="translated">関数のパラメータと同じように、パラメータ化されたジェネリックにもデフォルトを与えることができます。</target>
        </trans-unit>
        <trans-unit id="719a9a50e459a2a6ce7e2c56e63ed6b525dc0279" translate="yes" xml:space="preserve">
          <source>You can also specify the subtyping behavior of a generic via variance sigils. By default, generics behave invariantly, but you may add a &lt;code&gt;+&lt;/code&gt; to their declaration to make them behave covariantly, or a &lt;code&gt;-&lt;/code&gt; to their declaration to make them behave contravariantly. See &lt;a href=&quot;https://flow.org/en/lang/variance&quot;&gt;our docs on variance&lt;/a&gt; for a more information on variance in Flow.</source>
          <target state="translated">分散シギルを介してジェネリックのサブタイピング動作を指定することもできます。デフォルトでは、ジェネリックスは不変に動作しますが、 &lt;code&gt;+&lt;/code&gt; を宣言に追加してそれらを共変的に動作させるか、 &lt;code&gt;-&lt;/code&gt; をそれらの宣言に追加してそれらを反変的に動作させることができます。Flowの分散の詳細については、分散に関する&lt;a href=&quot;https://flow.org/en/lang/variance&quot;&gt;ドキュメントを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="f9363b7818b6e43e3422f3ad1d7ee6efa7ab8e46" translate="yes" xml:space="preserve">
          <source>You can also type &lt;code&gt;flow&lt;/code&gt; to accomplish the same effect as &lt;code&gt;status&lt;/code&gt; is the default flag to the &lt;code&gt;flow&lt;/code&gt; binary.</source>
          <target state="translated">&lt;code&gt;flow&lt;/code&gt; を入力して、 &lt;code&gt;status&lt;/code&gt; が &lt;code&gt;flow&lt;/code&gt; バイナリのデフォルトフラグであるのと同じ効果を達成することもできます。</target>
        </trans-unit>
        <trans-unit id="b68e51da33b5e539af5dbf6e3dcc5a59c33fe6c7" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;implements&lt;/code&gt; to tell Flow that you want the class to match an interface. This prevents you from making incompatible changes when editing the class.</source>
          <target state="translated">&lt;code&gt;implements&lt;/code&gt; を使用して、クラスにインターフェースを一致させることをFlowに指示することもできます。これにより、クラスの編集時に互換性のない変更を加えることを防ぎます。</target>
        </trans-unit>
        <trans-unit id="e3a1292b81cf7cdb77a98439b57cf0147e0f8f3b" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;implements&lt;/code&gt; with multiple interfaces.</source>
          <target state="translated">複数のインターフェースを備えた &lt;code&gt;implements&lt;/code&gt; を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="48dd13ac8774ad647e286bd9947352ec269d5800" translate="yes" xml:space="preserve">
          <source>You can also use named type imports in either an ES module environment or a CommonJS environment:</source>
          <target state="translated">また、ESモジュール環境でもCommonJS環境でも、名前付きタイプのインポートを使用することができます。</target>
        </trans-unit>
        <trans-unit id="7a88daebe91d272da9a7e038c3583dda16175e43" translate="yes" xml:space="preserve">
          <source>You can also use the form &lt;code&gt;/* @flow */&lt;/code&gt; for the flag as well.</source>
          <target state="translated">フラグには &lt;code&gt;/* @flow */&lt;/code&gt; 形式も使用できます。</target>
        </trans-unit>
        <trans-unit id="01c4697a441a0d2aa3c1b9f07e0ceb2ffc32acec" translate="yes" xml:space="preserve">
          <source>You can also validate that you have handled every single type of action by using the &lt;code&gt;empty&lt;/code&gt; type in your &lt;code&gt;default&lt;/code&gt; case.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; ケースでは &lt;code&gt;empty&lt;/code&gt; タイプを使用して、すべてのタイプのアクションを処理したことを検証することもできます。</target>
        </trans-unit>
        <trans-unit id="8d608633d54b23080262b0d07f6cb7d3dc534564" translate="yes" xml:space="preserve">
          <source>You can benefit from having Flow run as you develop by integrating into your editor.</source>
          <target state="translated">エディタに統合することで、開発に合わせてFlowを実行させることができます。</target>
        </trans-unit>
        <trans-unit id="2dcc931397145e4c230e84b33d5d8a5720c03798" translate="yes" xml:space="preserve">
          <source>You can create &lt;a href=&quot;../objects#toc-objects-as-maps&quot;&gt;&amp;ldquo;indexer properties&amp;rdquo;&lt;/a&gt; the same way as with objects.</source>
          <target state="translated">オブジェクトと同じ方法で&lt;a href=&quot;../objects#toc-objects-as-maps&quot;&gt;「インデクサープロパティ」を&lt;/a&gt;作成できます。</target>
        </trans-unit>
        <trans-unit id="b7946b65fbac98e9648cd5f68e306b48534b1a74" translate="yes" xml:space="preserve">
          <source>You can do that by adding an explicit type argument:</source>
          <target state="translated">明示的な型の引数を追加することで、これを行うことができます。</target>
        </trans-unit>
        <trans-unit id="d7fff0a703433e91168cd9bf5a21b4d5e3872e70" translate="yes" xml:space="preserve">
          <source>You can enable stronger safety guarantees in Flow (such as banning &lt;code&gt;any&lt;/code&gt;/&lt;code&gt;Object&lt;/code&gt;/&lt;code&gt;Function&lt;/code&gt; types and requiring all dependencies to be typed) by adding &lt;strong&gt;&lt;code&gt;@flow strict&lt;/code&gt;&lt;/strong&gt; to your files.</source>
          <target state="translated">ファイルに&lt;strong&gt; &lt;code&gt;@flow strict&lt;/code&gt; &lt;/strong&gt;を追加することにより、フローでより強力な安全性の保証を有効にすることができます（/ &lt;code&gt;Object&lt;/code&gt; / &lt;code&gt;Function&lt;/code&gt; タイプを禁止し &lt;code&gt;any&lt;/code&gt; すべての依存関係を入力する必要があるなど）。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eaa5fe932d239a06fd9575f03866b957b8981092" translate="yes" xml:space="preserve">
          <source>You can enforce this in Flow by making every property effectively &amp;ldquo;read-only&amp;rdquo; using &amp;ldquo;covariant&amp;rdquo; properties throughout your state object.</source>
          <target state="translated">状態オブジェクト全体の「共変」プロパティを使用して、すべてのプロパティを効果的に「読み取り専用」にすることで、これをフローで実施できます。</target>
        </trans-unit>
        <trans-unit id="ba6431d84c3e47b98b215406e4d6e813fefabd22" translate="yes" xml:space="preserve">
          <source>You can even nest lookups:</source>
          <target state="translated">ネスト検索もできます。</target>
        </trans-unit>
        <trans-unit id="4ccb58e74c71e2de2b124e20c360c5995e2ecd92" translate="yes" xml:space="preserve">
          <source>You can expand this even further and keep refining possibilities away:</source>
          <target state="translated">これをさらに拡大して、可能性を遠ざけていくことができます。</target>
        </trans-unit>
        <trans-unit id="f2afe0e2209309fcca1d0d4c82e4b42131180ea4" translate="yes" xml:space="preserve">
          <source>You can fix this by making &lt;code&gt;truthy&lt;/code&gt; a &lt;em&gt;predicate function&lt;/em&gt;, by using the &lt;code&gt;%checks&lt;/code&gt; annotation like so:</source>
          <target state="translated">これを修正するには、次のように &lt;code&gt;%checks&lt;/code&gt; アノテーションを使用して、 &lt;code&gt;truthy&lt;/code&gt; の&lt;em&gt;述語関数を&lt;/em&gt;作成します。</target>
        </trans-unit>
        <trans-unit id="1300bdbd711a74807a169ed243bc8221cc1ddb60" translate="yes" xml:space="preserve">
          <source>You can force Flow to treat one or more files as focused from the CLI.</source>
          <target state="translated">CLIから1つ以上のファイルをフォーカスされたものとしてFlowに強制的に扱うことができます。</target>
        </trans-unit>
        <trans-unit id="235ba8a2cc1e9c6fd298a395322859ee23a447be" translate="yes" xml:space="preserve">
          <source>You can get around this by storing your checked values in local variables:</source>
          <target state="translated">チェックした値をローカル変数に格納することで、この問題を回避することができます。</target>
        </trans-unit>
        <trans-unit id="64fd44f437add0d9e133a8562afc12f273306434" translate="yes" xml:space="preserve">
          <source>You can give callable entities type arguments for their generics directly in the call:</source>
          <target state="translated">呼び出し可能なエンティティのジェネリックの型引数を呼び出しの中で直接与えることができます。</target>
        </trans-unit>
        <trans-unit id="8ade9cad1bbc6b49fbea6fdd6de913340f01abe2" translate="yes" xml:space="preserve">
          <source>You can have as many of these generics as you need in the type parameter list, naming them whatever you want:</source>
          <target state="translated">これらのジェネリックは、型パラメータリストに必要な数だけ用意することができ、好きな名前をつけることができます。</target>
        </trans-unit>
        <trans-unit id="5cf2172f11dbbcc47d7a009c576faeb7aa356654" translate="yes" xml:space="preserve">
          <source>You can make a property contravariant by adding a minus symbol - in front of the property name.</source>
          <target state="translated">プロパティ名の前にマイナス記号を追加することで、プロパティを矛盾させることができます。</target>
        </trans-unit>
        <trans-unit id="1bdca1788706e2fc8e4a9c9a6e2d01cd32f92dcf" translate="yes" xml:space="preserve">
          <source>You can make a property covariant by adding a plus symbol &lt;code&gt;+&lt;/code&gt; in front of the property name.</source>
          <target state="translated">プロパティ名の前にプラス記号 &lt;code&gt;+&lt;/code&gt; を追加すると、プロパティを共変にできます。</target>
        </trans-unit>
        <trans-unit id="b010851670e4ca7a130bea951f459af8dca6a36b" translate="yes" xml:space="preserve">
          <source>You can optionally add a subtyping constraint to an opaque type alias by adding a colon &lt;code&gt;:&lt;/code&gt; and a type after the name.</source>
          <target state="translated">名前の後にコロン &lt;code&gt;:&lt;/code&gt; と型を追加することにより、不透明型のエイリアスにサブタイプ制約をオプションで追加できます。</target>
        </trans-unit>
        <trans-unit id="fd2496b164e62d7e0f41690b9f5e9552b1b451b8" translate="yes" xml:space="preserve">
          <source>You can pass as many arguments as you want into a rest parameter.</source>
          <target state="translated">残りのパラメータには、必要な数だけ引数を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="e6bd5c0ce38f5afd67d2acbbfbe61b90c3c48db4" translate="yes" xml:space="preserve">
          <source>You can put any type within &lt;code&gt;Array&amp;lt;Type&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Array&amp;lt;Type&amp;gt;&lt;/code&gt; 内に任意のタイプを置くことができます。</target>
        </trans-unit>
        <trans-unit id="732207deaac1dc0f323e2c9b02fc147f8f812da1" translate="yes" xml:space="preserve">
          <source>You can simplify the two checks against &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; using a single &lt;code&gt;!= null&lt;/code&gt; check which will do both.</source>
          <target state="translated">両方を行う単一の &lt;code&gt;!= null&lt;/code&gt; チェックを使用して、 &lt;code&gt;null&lt;/code&gt; と &lt;code&gt;undefined&lt;/code&gt; 2つのチェックを簡略化できます。</target>
        </trans-unit>
        <trans-unit id="9afabef0657e245fef1b9b2930123308edd5afac" translate="yes" xml:space="preserve">
          <source>You can specify in the &lt;code&gt;.flowconfig&lt;/code&gt; which version of Flow you expect to use. You do this with the &lt;code&gt;[version]&lt;/code&gt; section. If this section is omitted or left blank, then any version is allowed. If a version is specified and not matched, then Flow will immediately error and exit.</source>
          <target state="translated">使用する予定のFlowのバージョンを &lt;code&gt;.flowconfig&lt;/code&gt; で指定できます。これは &lt;code&gt;[version]&lt;/code&gt; セクションで行います。このセクションを省略するか、空白のままにすると、すべてのバージョンが許可されます。バージョンが指定されていて一致しない場合、Flowはすぐにエラーになり終了します。</target>
        </trans-unit>
        <trans-unit id="e03b894ceec87547a288939cd8aaf30ae007c81b" translate="yes" xml:space="preserve">
          <source>You can start to compare two objects by their keys. If one object contains all the keys of another object, then it may be a subtype.</source>
          <target state="translated">2つのオブジェクトをキーで比較することができます。あるオブジェクトが別のオブジェクトのすべてのキーを含む場合、そのオブジェクトはサブタイプである可能性があります。</target>
        </trans-unit>
        <trans-unit id="d28e07b9c51e5ffadf873da6f7a3f54bbf76f2f9" translate="yes" xml:space="preserve">
          <source>You can then, further dig into particular COMMANDs by adding the &lt;code&gt;--help&lt;/code&gt; flag.</source>
          <target state="translated">その後、 &lt;code&gt;--help&lt;/code&gt; フラグを追加することで、特定のコマンドをさらに掘り下げることができます。</target>
        </trans-unit>
        <trans-unit id="bd1e8c4360056b71335ea367a6b3e679639d25f3" translate="yes" xml:space="preserve">
          <source>You can think of this like passing arguments to a function, only the return value is a type that you can use.</source>
          <target state="translated">これは関数に引数を渡すようなものと考えることができます。</target>
        </trans-unit>
        <trans-unit id="77a6915e052949d36dbc7c36f8a0ffc2fd6eea09" translate="yes" xml:space="preserve">
          <source>You can update your code to the more readable:</source>
          <target state="translated">コードをより読みやすいものに更新することができます。</target>
        </trans-unit>
        <trans-unit id="ebd1cddf8c517151cd84a6cfd9b8b49383f2e6c4" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;typeof x === &quot;symbol&quot;&lt;/code&gt; to refine to a symbol.</source>
          <target state="translated">&lt;code&gt;typeof x === &quot;symbol&quot;&lt;/code&gt; を使用して、記号に絞り込むことができます。</target>
        </trans-unit>
        <trans-unit id="b81520be069e0fa0c9db8cbcabf710cfccf37e42" translate="yes" xml:space="preserve">
          <source>You can use any value with &lt;code&gt;typeof&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; では任意の値を使用できます。</target>
        </trans-unit>
        <trans-unit id="5eb1e9ebfd9c95be03ab9be04d025560b3074e1c" translate="yes" xml:space="preserve">
          <source>You can use generics in the same places you&amp;rsquo;d add any other type in a class (property types and method parameter/return types).</source>
          <target state="translated">ジェネリックは、クラスに他のタイプを追加するのと同じ場所で使用できます（プロパティタイプとメソッドパラメーター/戻り値のタイプ）。</target>
        </trans-unit>
        <trans-unit id="f4aa0e86d6f17a2f8d19918819c102cbd6c3820e" translate="yes" xml:space="preserve">
          <source>You can use generics in the same places you&amp;rsquo;d add any other type in a function (parameter or return types).</source>
          <target state="translated">関数に他の型（パラメーター型または戻り型）を追加するのと同じ場所でジェネリックを使用できます。</target>
        </trans-unit>
        <trans-unit id="8de2ccca92b2b43ac3dc44c63b7e55c6b432c76a" translate="yes" xml:space="preserve">
          <source>You can use generics in the same places you&amp;rsquo;d add any other type in a function type (parameter or return types).</source>
          <target state="translated">関数型（パラメーター型または戻り型）に他の型を追加するのと同じ場所でジェネリックを使用できます。</target>
        </trans-unit>
        <trans-unit id="2d107b2ef0635398f316220ce167c042b23a92d8" translate="yes" xml:space="preserve">
          <source>You can use primitive values for these types:</source>
          <target state="translated">これらの型にはプリミティブ値を使用することができます。</target>
        </trans-unit>
        <trans-unit id="1997334cf38d8070cc18855e7eb4a51b9f7aa599" translate="yes" xml:space="preserve">
          <source>You can use this in combination with &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; to get static props:</source>
          <target state="translated">これを &lt;code&gt;Class&amp;lt;T&amp;gt;&lt;/code&gt; と組み合わせて使用​​して、静的な小道具を取得できます。</target>
        </trans-unit>
        <trans-unit id="b38b57891c6a590d35857959678efd3a7cbc9edf" translate="yes" xml:space="preserve">
          <source>You cannot use &lt;code&gt;Array.prototype&lt;/code&gt; methods that mutate the tuple, only ones that do not.</source>
          <target state="translated">タプルを変更する &lt;code&gt;Array.prototype&lt;/code&gt; メソッドは使用できません。変更しないメソッドのみを使用できます。</target>
        </trans-unit>
        <trans-unit id="34cdb6dbd42effcc5eee6814751e14333d7ad7b4" translate="yes" xml:space="preserve">
          <source>You could also flip it around, and check to make sure that the value has a type of &lt;code&gt;number&lt;/code&gt; before using it.</source>
          <target state="translated">また、値を反転させて、値を使用する前に値のタイプが &lt;code&gt;number&lt;/code&gt; あることを確認することもできます。</target>
        </trans-unit>
        <trans-unit id="d54fcc4baacde621798558cd944fe72a2272653e" translate="yes" xml:space="preserve">
          <source>You could continue this process until &lt;code&gt;any&lt;/code&gt; has leaked all over your code.</source>
          <target state="translated">コード全体にリークが発生するまで &lt;code&gt;any&lt;/code&gt; このプロセスを続けることができます。</target>
        </trans-unit>
        <trans-unit id="a5ccb2330f2aef610502456380da1cc91e063a81" translate="yes" xml:space="preserve">
          <source>You could do</source>
          <target state="translated">あなたならできる</target>
        </trans-unit>
        <trans-unit id="a96c3e789576bc7f92cd0b34129750d6ad259391" translate="yes" xml:space="preserve">
          <source>You could refine the type, but the generic will still allow any type to be passed in.</source>
          <target state="translated">型を絞り込むこともできますが、ジェネリックではどのような型でも渡すことができます。</target>
        </trans-unit>
        <trans-unit id="2ce625c160012e98036189d91961fd70764c6f12" translate="yes" xml:space="preserve">
          <source>You could then use the resulting value in another operation, such as adding it as if it were a number and the result will also be &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">次に、結果の値を別の操作で使用できます。たとえば、数値であるかのように追加すると、結果も &lt;code&gt;any&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="6d0c0f6b4e6d2338d922e76b590f2d36d1904032" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to annotate the return type of either your &lt;code&gt;render()&lt;/code&gt; method or a stateless functional component. However, if you want to annotate the return type then &lt;code&gt;React.Node&lt;/code&gt; is the generic to use.</source>
          <target state="translated">&lt;code&gt;render()&lt;/code&gt; メソッドまたはステートレス機能コンポーネントの戻り型に注釈を付ける必要はありません。ただし、戻り値の型に注釈を付けたい場合は、 &lt;code&gt;React.Node&lt;/code&gt; が使用するジェネリックです。</target>
        </trans-unit>
        <trans-unit id="2f9c2c80449347f7166dc305529f30c45a9e9eed" translate="yes" xml:space="preserve">
          <source>You may also add a leading ampersand which is useful when breaking intersection types onto multiple lines.</source>
          <target state="translated">また、 交差点の型を複数の行に分割するときに便利な先頭のアンパサンドを追加することもできます。</target>
        </trans-unit>
        <trans-unit id="2fa909f29db190474cf723005ff4008d9b7598e9" translate="yes" xml:space="preserve">
          <source>You may also add a leading vertical bar which is useful when breaking union types onto multiple lines.</source>
          <target state="translated">また、複数の行にユニオンタイプを分割するときに便利な、先行する垂直バーを追加することもできます。</target>
        </trans-unit>
        <trans-unit id="4b9fdbe0651aa0dcc77f656e366ff86ea773ba26" translate="yes" xml:space="preserve">
          <source>You may also optionally leave out the parameter names.</source>
          <target state="translated">オプションでパラメータ名を省略することもできます。</target>
        </trans-unit>
        <trans-unit id="8369235f7cc951c26ca572a5f0d1089b25b9b0f4" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax (i.e. Flow will not use this syntax to indicate the presence of a property on instances of the class).</source>
          <target state="translated">また、これを &lt;code&gt;ignore&lt;/code&gt; に設定して、フローが構文を単に無視することを示すこともできます（つまり、フローはこの構文を使用して、クラスのインスタンスにプロパティが存在することを示しません）。</target>
        </trans-unit>
        <trans-unit id="12abc47c0cac769438a2a10d53130bb5088f3b42" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax (i.e. Flow will not use this syntax to indicate the presence of a static property on the class).</source>
          <target state="translated">これを &lt;code&gt;ignore&lt;/code&gt; に設定して、フローが単に構文を無視するように指定することもできます（つまり、フローはこの構文を使用して、クラスに静的プロパティが存在することを示しません）。</target>
        </trans-unit>
        <trans-unit id="bfbbefdd992a4649126e811e71f05644039bb6d5" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax.</source>
          <target state="translated">これを &lt;code&gt;ignore&lt;/code&gt; に設定して、Flowが構文を単に無視することを示すこともできます。</target>
        </trans-unit>
        <trans-unit id="43a0ac12f9014a2da637bcb44bcbb4fbf90a6924" translate="yes" xml:space="preserve">
          <source>You may also set this to &lt;code&gt;ignore&lt;/code&gt; to indicate that Flow should simply ignore the syntax. The default value of this option is &lt;code&gt;warn&lt;/code&gt;, which gives a warning on use since this proposal is still very early-stage.</source>
          <target state="translated">これを &lt;code&gt;ignore&lt;/code&gt; に設定して、Flowが構文を単に無視することを示すこともできます。このオプションのデフォルト値は &lt;code&gt;warn&lt;/code&gt; です。これは、この提案がまだ非常に初期段階であるため、使用時に警告を発します。</target>
        </trans-unit>
        <trans-unit id="aa76b5b2c71934a0d36af87656f7165b00582a43" translate="yes" xml:space="preserve">
          <source>You may also wish to install a popular SublimeLinter plugin for Flow like &lt;a href=&quot;https://packagecontrol.io/packages/SublimeLinter-flow&quot;&gt;SublimeLinter-flow&lt;/a&gt;.</source>
          <target state="translated">また、&lt;a href=&quot;https://packagecontrol.io/packages/SublimeLinter-flow&quot;&gt;SublimeLinter-flowの&lt;/a&gt;ようなFlow向けの人気のあるSublimeLinterプラグインをインストールすることもできます。</target>
        </trans-unit>
        <trans-unit id="bd52a5c29c3e64a83bb0f62e994bfb74ab453fe3" translate="yes" xml:space="preserve">
          <source>You might use these functions types for something like a callback.</source>
          <target state="translated">これらの関数の型は、コールバックのようなものに使用することができます。</target>
        </trans-unit>
        <trans-unit id="2ed4bf60715e28afa28e2fa5a72f5002c15618be" translate="yes" xml:space="preserve">
          <source>You must always include the brackets &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; when using the type (just like parentheses for a function call).</source>
          <target state="translated">タイプを使用するときは、常に括弧 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; を含める必要があります（関数呼び出しの括弧のように）。</target>
        </trans-unit>
        <trans-unit id="99f73949e10ba9c21b14d2d45c52b596aa157461" translate="yes" xml:space="preserve">
          <source>You must be explicit and convert other types into strings. You can do this by using the String method or using another method for stringifying values.</source>
          <target state="translated">明示的に他の型を文字列に変換する必要があります。これは、Stringメソッドを使用するか、値を文字列化する別のメソッドを使用して行うことができます。</target>
        </trans-unit>
        <trans-unit id="01b16b93eebbf6cd3d2d130c4da4b067de2c5876" translate="yes" xml:space="preserve">
          <source>You should represent these values with &lt;code&gt;mixed&lt;/code&gt;.</source>
          <target state="translated">これらの値を &lt;code&gt;mixed&lt;/code&gt; 表す必要があります。</target>
        </trans-unit>
        <trans-unit id="e73e4c01718490bcf4d4cc882d49967190833cfe" translate="yes" xml:space="preserve">
          <source>You will have access to all of the values that React exports, but you will &lt;strong&gt;not&lt;/strong&gt; have access to the types documented below! This is because Flow will not add types to a default export since the default export could be any value (like a number). Flow will add exported named types to an ES namespace object which you can get with &lt;code&gt;import * as React from 'react'&lt;/code&gt; since Flow knows if you export a value with the same name as an exported type.</source>
          <target state="translated">Reactがエクスポートするすべての値にアクセスできますが、以下に記載されているタイプにはアクセスでき&lt;strong&gt;ません&lt;/strong&gt;！これは、デフォルトのエクスポートは任意の値（数値など）になる可能性があるため、フローはデフォルトのエクスポートにタイプを追加しないためです。Flowは、エクスポートされた名前付きタイプをES名前空間オブジェクトに追加します。これは、 &lt;code&gt;import * as React from 'react'&lt;/code&gt; 取得できます。フローは、エクスポートされたタイプと同じ名前の値をエクスポートするかどうかを認識しているためです。</target>
        </trans-unit>
        <trans-unit id="3c23f9cce0d3c2c8df25b9ff8cf278ae227f7bad" translate="yes" xml:space="preserve">
          <source>You write classes the same way you would without Flow, but then you can use the name of the class as a type.</source>
          <target state="translated">Flowを使わない場合と同じようにクラスを書きますが、その場合はクラス名を型として使うことができます。</target>
        </trans-unit>
        <trans-unit id="654c5e74e5e546451d0e1429c2931cddd203538d" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll notice that if we do not handle each possible type of our value, Flow will give us an error.</source>
          <target state="translated">考えられる値のタイプをそれぞれ処理しないと、Flowによってエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="75e6e89e1f9c5b889605448ec75232836809ed76" translate="yes" xml:space="preserve">
          <source>[declarations]</source>
          <target state="translated">[declarations]</target>
        </trans-unit>
        <trans-unit id="8efeedea6584d5d0f6aa150fe286ea3d383ef4a5" translate="yes" xml:space="preserve">
          <source>[ignore]</source>
          <target state="translated">[ignore]</target>
        </trans-unit>
        <trans-unit id="6c51495394c6e6372e62ee5ec85bb9eaef21cce5" translate="yes" xml:space="preserve">
          <source>[include]</source>
          <target state="translated">[include]</target>
        </trans-unit>
        <trans-unit id="7afbe53dfddbe7c93f7de3dd43aba3228ee7b934" translate="yes" xml:space="preserve">
          <source>[libs]</source>
          <target state="translated">[libs]</target>
        </trans-unit>
        <trans-unit id="0a5387e3c9cf9ab97fc0bf23e3269594e185c36d" translate="yes" xml:space="preserve">
          <source>[lints]</source>
          <target state="translated">[lints]</target>
        </trans-unit>
        <trans-unit id="83f3a6281fb9adf03bf77c91402ae0e931ccb966" translate="yes" xml:space="preserve">
          <source>[options]</source>
          <target state="translated">[options]</target>
        </trans-unit>
        <trans-unit id="5342d8199f9eb9d08f90a284e8dd1dc7804a74f9" translate="yes" xml:space="preserve">
          <source>[untyped]</source>
          <target state="translated">[untyped]</target>
        </trans-unit>
        <trans-unit id="82269fe5787de6e7ec27fcc12d83c2cbb09336c3" translate="yes" xml:space="preserve">
          <source>[version]</source>
          <target state="translated">[version]</target>
        </trans-unit>
        <trans-unit id="a1024232bfedfebb6aacd740ffd636d6f41a840a" translate="yes" xml:space="preserve">
          <source>and now</source>
          <target state="translated">而して今</target>
        </trans-unit>
        <trans-unit id="48e7db6313c704fbd26e0ba32bef954b2e977a24" translate="yes" xml:space="preserve">
          <source>and spread that into the &lt;code&gt;Props&lt;/code&gt; type:</source>
          <target state="translated">それを &lt;code&gt;Props&lt;/code&gt; タイプに広げます：</target>
        </trans-unit>
        <trans-unit id="2cc9aa7176523739af8846ebf98bde04cafdfc07" translate="yes" xml:space="preserve">
          <source>and suppose that &lt;code&gt;src/Misc.js&lt;/code&gt; has an incompatible implementation of &lt;code&gt;isLeapYear&lt;/code&gt;:</source>
          <target state="translated">また、 &lt;code&gt;src/Misc.js&lt;/code&gt; に &lt;code&gt;isLeapYear&lt;/code&gt; の互換性のない実装があるとします。</target>
        </trans-unit>
        <trans-unit id="ec2d7bdbbbacb178e39b0b7c79bfc355baf6b95f" translate="yes" xml:space="preserve">
          <source>and suppress the error. If there is no error on the next line (the suppression is unnecessary), an &amp;ldquo;Unused suppression&amp;rdquo; warning will be shown instead.</source>
          <target state="translated">エラーを抑制します。次の行にエラーがない場合（抑制は不要）、代わりに「未使用の抑制」警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="a9745abbdcf92eab56732a7d35f17f430c1336bf" translate="yes" xml:space="preserve">
          <source>and then it comes across a &lt;code&gt;package.json&lt;/code&gt; with</source>
          <target state="translated">そしてそれは出くわす &lt;code&gt;package.json&lt;/code&gt; で</target>
        </trans-unit>
        <trans-unit id="0768098259f562a18299b5c17e4ddd6a8b9d9b5b" translate="yes" xml:space="preserve">
          <source>and you try to use Flow v0.21.0, then Flow will immediately error with the message</source>
          <target state="translated">というメッセージが表示され、Flow v0.21.0を使用しようとした場合、Flowはすぐにエラーとなります。</target>
        </trans-unit>
        <trans-unit id="fca2dbc7b2ac4e20f39f9f3ef522d55252c79cbb" translate="yes" xml:space="preserve">
          <source>broken: &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAb2IAuUADsRqMZSwAaUGPVade0AF8A3D36DRYgEwzYc0IpVF1JHFmQaAc0Mab19-AMsbRBpYDR9hcQl3UAAKdFkSdQdpDIBKdwA+UAAeABNkADdQYAKbGLi8B0dktIys8Wc8wpLyqpqo+viAYSYWpURQUBJKaEo6bH0J0AA6VfTXEkQLdRVp2fmsdV8RSkNV5eyXNwtQAB9lKZm5nGx1SCJoabPVpquyC3y8gKSz2z2woAA-CVsspzus5DcaqB1MUmrC1hlEbUgA&quot;&gt;https://flow.org/try&lt;/a&gt;</source>
          <target state="translated">壊れた：&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAb2IAuUADsRqMZSwAaUGPVade0AF8A3D36DRYgEwzYc0IpVF1JHFmQaAc0Mab19-AMsbRBpYDR9hcQl3UAAKdFkSdQdpDIBKdwA+UAAeABNkADdQYAKbGLi8B0dktIys8Wc8wpLyqpqo+viAYSYWpURQUBJKaEo6bH0J0AA6VfTXEkQLdRVp2fmsdV8RSkNV5eyXNwtQAB9lKZm5nGx1SCJoabPVpquyC3y8gKSz2z2woAA-CVsspzus5DcaqB1MUmrC1hlEbUgA&quot;&gt;https&lt;/a&gt; : //flow.org/try</target>
        </trans-unit>
        <trans-unit id="e64557fab980626ab81ed51e1987304bd8228deb" translate="yes" xml:space="preserve">
          <source>but in types-first the exported type will be</source>
          <target state="translated">のようになりますが、type-first でエクスポートされた型は</target>
        </trans-unit>
        <trans-unit id="774e51ee6ebca6e8cb9d7f4d3fe9750f2b9256ae" translate="yes" xml:space="preserve">
          <source>but this doesn&amp;rsquo;t feel very DRY, as we had to explicitly define the suit names twice.</source>
          <target state="translated">しかし、スーツ名を2回明示的に定義する必要があったので、これは非常に乾燥しているとは感じません。</target>
        </trans-unit>
        <trans-unit id="6e45777a3dd462c6a840e9e356a7099b6982bc19" translate="yes" xml:space="preserve">
          <source>but with &lt;code&gt;$ReadOnlyArray&lt;/code&gt; you can achieve what you were looking for:</source>
          <target state="translated">しかし &lt;code&gt;$ReadOnlyArray&lt;/code&gt; を使用すると、探していたものを実現できます。</target>
        </trans-unit>
        <trans-unit id="46438caefd12a0fd432aedcd449aa37d123fa4c1" translate="yes" xml:space="preserve">
          <source>but with a covariant property you can achieve what you were looking for:</source>
          <target state="translated">しかし、共変量プロパティを使用すると、あなたが探していたものを達成することができます。</target>
        </trans-unit>
        <trans-unit id="ccd55bda6574570ee546195840fdf67842826f24" translate="yes" xml:space="preserve">
          <source>coc.nvim-neovim</source>
          <target state="translated">coc.nvim-neovim</target>
        </trans-unit>
        <trans-unit id="eca0bd3451749c34200b52876c4df81d84e1e7cd" translate="yes" xml:space="preserve">
          <source>doesn&amp;rsquo;t report a warning.</source>
          <target state="translated">警告を報告しません。</target>
        </trans-unit>
        <trans-unit id="ecb70bca541e08251da88aa6114a01ea186dc721" translate="yes" xml:space="preserve">
          <source>fixed: &lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAbwA+xAFygAdiNRjKWADSgxmnXoOgVAXwDcPfoNFiATDNhzQi1RtAkcWMhaAObGNJr+gSFWdtw0sFr+wuISXqAAFOiyJJrO0tkAlF4AfKAAPAAmyABuoMDF9vGJeM4uaZnZueJuhSXlVbX19ohNSQDCTO1ZHjnKaiSU0JR02JoBIpTGAHQ7ee6eNlZzfovLOKugkETQC9u73ftkNkXypUqIoKDIkBnTclsLJYrLBFd6fT5LPBKQFnbB3LbsfzWNJ-Ej2cGgdg4ERYLTlPLKHYIyhIuoND6gZGLBbKCkQyhQmHA+GInDIxSo9HgrE4vFlVqEnas5FDCnWRDWIA&quot;&gt;https://flow.org/try&lt;/a&gt;</source>
          <target state="translated">修正：&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gFSgCGAzqAEoCmRAxnpFrKqAORbV0uKI4Ce6lUAGUArgCMAjAAVG6MgF5QAbwA+xAFygAdiNRjKWADSgxmnXoOgVAXwDcPfoNFiATDNhzQi1RtAkcWMhaAObGNJr+gSFWdtw0sFr+wuISXqAAFOiyJJrO0tkAlF4AfKAAPAAmyABuoMDF9vGJeM4uaZnZueJuhSXlVbX19ohNSQDCTO1ZHjnKaiSU0JR02JoBIpTGAHQ7ee6eNlZzfovLOKugkETQC9u73ftkNkXypUqIoKDIkBnTclsLJYrLBFd6fT5LPBKQFnbB3LbsfzWNJ-Ej2cGgdg4ERYLTlPLKHYIyhIuoND6gZGLBbKCkQyhQmHA+GInDIxSo9HgrE4vFlVqEnas5FDCnWRDWIA&quot;&gt;https&lt;/a&gt; : //flow.org/try</target>
        </trans-unit>
        <trans-unit id="406a50ab8f418267ad4cb79f7ec8af3c757e5d1a" translate="yes" xml:space="preserve">
          <source>flow-for-emacs</source>
          <target state="translated">flow-for-emacs</target>
        </trans-unit>
        <trans-unit id="b31ed27db0f3f06537ccbd7e0612af0839145d27" translate="yes" xml:space="preserve">
          <source>flow-remove-types</source>
          <target state="translated">flow-remove-types</target>
        </trans-unit>
        <trans-unit id="bb6bd705fa5bbecd686c0aa80112ee7f1ec636a5" translate="yes" xml:space="preserve">
          <source>flowlint</source>
          <target state="translated">flowlint</target>
        </trans-unit>
        <trans-unit id="1ae5604c6b19edcfc16e8a0c46ddf12d0f3961dd" translate="yes" xml:space="preserve">
          <source>flowlint-line</source>
          <target state="translated">flowlint-line</target>
        </trans-unit>
        <trans-unit id="d424129af5ff1e8c17f038e5baf6afdeaa7378ab" translate="yes" xml:space="preserve">
          <source>flowlint-next-line</source>
          <target state="translated">flowlint-next-line</target>
        </trans-unit>
        <trans-unit id="9523c342f10c383dc3724202de645481a80652c5" translate="yes" xml:space="preserve">
          <source>if you want control at an even finer level than you get from the line-based comments.</source>
          <target state="translated">ラインベースのコメントよりもさらに細かいレベルでコントロールしたい場合は</target>
        </trans-unit>
        <trans-unit id="ec606816757167e05f48d162279dba3e8be72530" translate="yes" xml:space="preserve">
          <source>is an alias for React.AbstractComponent&amp;lt;Config, any&amp;gt;, which represents a component with config type Config and any instance type.</source>
          <target state="translated">React.AbstractComponent &amp;lt;Config、any&amp;gt;のエイリアスです。これは、構成タイプConfigおよび任意のインスタンスタイプを持つコンポーネントを表します。</target>
        </trans-unit>
        <trans-unit id="069f84bc5a9db81934e7d45531980b8b2dda9222" translate="yes" xml:space="preserve">
          <source>is treated as having type &lt;code&gt;Array&amp;lt;t1 | t2&amp;gt;&lt;/code&gt;, where &lt;code&gt;e1&lt;/code&gt; and &lt;code&gt;e2&lt;/code&gt; have types &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;, instead of the tuple type &lt;code&gt;[t1, t2]&lt;/code&gt;.</source>
          <target state="translated">タイプ &lt;code&gt;Array&amp;lt;t1 | t2&amp;gt;&lt;/code&gt; を持つものとして扱われます。t2&amp;gt;、ここで、 &lt;code&gt;e1&lt;/code&gt; と &lt;code&gt;e2&lt;/code&gt; は、タプルタイプ &lt;code&gt;[t1, t2]&lt;/code&gt; ではなく、タイプ &lt;code&gt;t1&lt;/code&gt; と &lt;code&gt;t2&lt;/code&gt; を持ちます。</target>
        </trans-unit>
        <trans-unit id="e56b448d5548cfe9ad70cc70da30a02c7890ea87" translate="yes" xml:space="preserve">
          <source>or by annotating the exported constant (&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBjWA7AzgF1AQwE764CeoAvKANoDku1ANKNQEbUC6iApgB4AOs+HKkw4A5pzSd8AS2QBBQiQBcoBUWIAebDLSiAfOTyLiAOgC2uXgApc5A7gCUQA&quot;&gt;https://flow.org/try&lt;/a&gt;):</source>
          <target state="translated">または、エクスポートされた定数に注釈を付けることによって（&lt;a href=&quot;https://flow.org/try/#0PTAEAEDMBsHsHcBQBjWA7AzgF1AQwE764CeoAvKANoDku1ANKNQEbUC6iApgB4AOs+HKkw4A5pzSd8AS2QBBQiQBcoBUWIAebDLSiAfOTyLiAOgC2uXgApc5A7gCUQA&quot;&gt;https://flow.org/try&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="7a4bfa85ec41023a2a32b1cdf3f48b7562fdb4a7" translate="yes" xml:space="preserve">
          <source>ref functions</source>
          <target state="translated">参照関数</target>
        </trans-unit>
        <trans-unit id="2193165c31d2f4f8af241c9a8931a8b36a67d5d4" translate="yes" xml:space="preserve">
          <source>returns a number, when we pass in the value &lt;code&gt;&quot;number&quot;&lt;/code&gt;, and</source>
          <target state="translated">戻って、我々は値を渡す番号、 &lt;code&gt;&quot;number&quot;&lt;/code&gt; 、および</target>
        </trans-unit>
        <trans-unit id="ac03e5cf9b7ed34c910a9d7e41d6ef0b28bee9d4" translate="yes" xml:space="preserve">
          <source>returns a string, when we pass in the value &lt;code&gt;&quot;string&quot;&lt;/code&gt;,</source>
          <target state="translated">値 &lt;code&gt;&quot;string&quot;&lt;/code&gt; を渡すと、文字列を返します。</target>
        </trans-unit>
        <trans-unit id="34f484f97d66326080e8ca936a1ad359ef6b4abc" translate="yes" xml:space="preserve">
          <source>returns any possible type (&lt;code&gt;mixed&lt;/code&gt;), when we pass in any other string.</source>
          <target state="translated">他の文字列を渡すと、可能なタイプ（ &lt;code&gt;mixed&lt;/code&gt; ）を返します。</target>
        </trans-unit>
        <trans-unit id="293bf85b0e8555f44772dd43c5b8cdf5ff5c89b9" translate="yes" xml:space="preserve">
          <source>the left-hand side of an &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; expression.</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 式の左側。</target>
        </trans-unit>
        <trans-unit id="aca33d45708489b41473f878247540a6c340f31f" translate="yes" xml:space="preserve">
          <source>the parameter &lt;code&gt;x&lt;/code&gt; will be flagged as uncovered. Also, in practice, a strict criterion like this would be too noisy and rather expensive to compute on the fly.</source>
          <target state="translated">パラメータ &lt;code&gt;x&lt;/code&gt; には、カバーされていないというフラグが立てられます。また、実際には、このような厳密な基準は、ノイズが多すぎて、その場で計算するにはかなりコストがかかります。</target>
        </trans-unit>
        <trans-unit id="9fc1ee20cda978df2390bc72489f853397097bc8" translate="yes" xml:space="preserve">
          <source>to encode the same condition, then the following refinement would fail</source>
          <target state="translated">が同じ条件をエンコードしている場合、次のような改良は失敗します。</target>
        </trans-unit>
        <trans-unit id="1470003cc6f898cdf238607c6ab34328b293da93" translate="yes" xml:space="preserve">
          <source>vim-flow</source>
          <target state="translated">vim-flow</target>
        </trans-unit>
        <trans-unit id="2ad74a5e0937034a00b7730362af6b184bbbc385" translate="yes" xml:space="preserve">
          <source>vscode-flow-ide</source>
          <target state="translated">vscode-flow-ide</target>
        </trans-unit>
        <trans-unit id="7e30df14febfb74a504a9f7e0ea2a1f5f14e3450" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;file.txt&lt;/code&gt; contains a specific list of files to be transformed.</source>
          <target state="translated">ここで、 &lt;code&gt;file.txt&lt;/code&gt; には、変換するファイルの特定のリストが含まれています。</target>
        </trans-unit>
        <trans-unit id="0cbdfb85ff349a0802c41f318988e156dfbc0529" translate="yes" xml:space="preserve">
          <source>where as you would otherwise need to export an alias in the &lt;code&gt;import typeof&lt;/code&gt; case</source>
          <target state="translated">&lt;code&gt;import typeof&lt;/code&gt; ケースでエイリアスをエクスポートする必要がある場合と同様に</target>
        </trans-unit>
        <trans-unit id="2c7d718acdeb4c28153f3554978db15557a7145c" translate="yes" xml:space="preserve">
          <source>where you&amp;rsquo;ll need to manually annotate the export with &lt;code&gt;{():void;x:number}&lt;/code&gt;, or assignments preceding the function definition</source>
          <target state="translated">ここで、エクスポートに &lt;code&gt;{():void;x:number}&lt;/code&gt; 、または関数定義の前の割り当てで手動で注釈を付ける必要があります</target>
        </trans-unit>
        <trans-unit id="bd186b6002ab463466be199db517792bf8202dbe" translate="yes" xml:space="preserve">
          <source>will match a comment like this:</source>
          <target state="translated">のようなコメントにマッチします。</target>
        </trans-unit>
        <trans-unit id="f9a9d8b1f4f99fe8e77aee03fea19f8d5c42d401" translate="yes" xml:space="preserve">
          <source>will only report export related errors in files under &lt;code&gt;dirA&lt;/code&gt; and &lt;code&gt;dirB&lt;/code&gt;. This option requires &lt;code&gt;well_formed_exports&lt;/code&gt; to be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dirA&lt;/code&gt; および &lt;code&gt;dirB&lt;/code&gt; の下のファイルのエクスポート関連エラーのみを報告します。このオプションでは、 &lt;code&gt;well_formed_exports&lt;/code&gt; を &lt;code&gt;true&lt;/code&gt; に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="703e35916510aa0709f422ccc116c890cd2d9aee" translate="yes" xml:space="preserve">
          <source>will report coverage statistics for each file under &lt;code&gt;dir/&lt;/code&gt;, as well as aggregate results.</source>
          <target state="translated">&lt;code&gt;dir/&lt;/code&gt; 下の各ファイルのカバレッジ統計と、集計結果を報告します。</target>
        </trans-unit>
        <trans-unit id="dd8179879b4cc1b0a4e2ed32e13778f6df541014" translate="yes" xml:space="preserve">
          <source>would report no errors, but</source>
          <target state="translated">はエラーを報告しませんが</target>
        </trans-unit>
        <trans-unit id="cba826f3eaa4834a5baad670fcedb5ee1f1e012b" translate="yes" xml:space="preserve">
          <source>would still have a sketchy-null-number warning on line 3.</source>
          <target state="translated">の場合、3行目にはまだスケッチ的な NULL-NULL-NUMBER の警告が表示されています。</target>
        </trans-unit>
        <trans-unit id="594bfb76f84b1b4ba073112718b87595f61a0b22" translate="yes" xml:space="preserve">
          <source>would still report a type incompatibility.</source>
          <target state="translated">は型の非互換性を報告します。</target>
        </trans-unit>
        <trans-unit id="d75e67ce648cee2a5ca84dc314da13569be0152a" translate="yes" xml:space="preserve">
          <source>you can issue the following command</source>
          <target state="translated">を実行すると、次のコマンドを発行することができます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
