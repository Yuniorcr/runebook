<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="sequelize">
    <body>
      <group id="sequelize">
        <trans-unit id="becd6dae52b2df153aa08d2d6f44756bb498c1b3" translate="yes" xml:space="preserve">
          <source>Column name</source>
          <target state="translated">カラム名</target>
        </trans-unit>
        <trans-unit id="c5d567c34c1265b1ead009da4afd96d277739a5e" translate="yes" xml:space="preserve">
          <source>Column name to remove</source>
          <target state="translated">削除するカラム名</target>
        </trans-unit>
        <trans-unit id="62a7611cf3ef3c6da72c643e3290dc1aa76d72a1" translate="yes" xml:space="preserve">
          <source>Column on which COUNT() should be applied</source>
          <target state="translated">COUNT()が適用されるべきカラム</target>
        </trans-unit>
        <trans-unit id="8f7f21fd7a3abe8fec6502d8c488d6889457b13d" translate="yes" xml:space="preserve">
          <source>Combinations</source>
          <target state="translated">Combinations</target>
        </trans-unit>
        <trans-unit id="e04d03c32b7e4d785b35d28fb5a1bc66c34d8834" translate="yes" xml:space="preserve">
          <source>Combining getters and setters</source>
          <target state="translated">ゲッターとセッターを組み合わせる</target>
        </trans-unit>
        <trans-unit id="c43c326ba531af8989310bee529e2456bbca867f" translate="yes" xml:space="preserve">
          <source>Comment for this column</source>
          <target state="translated">このコラムへのコメント</target>
        </trans-unit>
        <trans-unit id="c380604c38a888e7ca2dfa7caabf62f3c38be34d" translate="yes" xml:space="preserve">
          <source>Commit the transaction</source>
          <target state="translated">トランザクションをコミットする</target>
        </trans-unit>
        <trans-unit id="82cbd9f28b6e73dc5b2eb3f3f5ea8ad929b246d0" translate="yes" xml:space="preserve">
          <source>Common useful values for &lt;code&gt;options.logging&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;options.logging&lt;/code&gt; の一般的な有用な値：</target>
        </trans-unit>
        <trans-unit id="8106773f052ee9ae49f2206b16988a2229233a00" translate="yes" xml:space="preserve">
          <source>Complex filtering / OR / NOT queries</source>
          <target state="translated">複雑なフィルタリング/OR/NOT クエリ</target>
        </trans-unit>
        <trans-unit id="e409f2f341dbf30646ad912983a01811dd9971c0" translate="yes" xml:space="preserve">
          <source>Complex ordering involving sub-queries</source>
          <target state="translated">副問い合わせを含む複雑な順序付け</target>
        </trans-unit>
        <trans-unit id="62455764071b6e8dcbedb8de8585e524d2539d45" translate="yes" xml:space="preserve">
          <source>Complex where clauses at the top-level</source>
          <target state="translated">トップレベルの節がある複合体</target>
        </trans-unit>
        <trans-unit id="c05bafdb56031bb64da1f1d1861f60118932c605" translate="yes" xml:space="preserve">
          <source>Concept</source>
          <target state="translated">Concept</target>
        </trans-unit>
        <trans-unit id="1c266f3a917d2c18a19ca7ec428bb01eb610216c" translate="yes" xml:space="preserve">
          <source>Concurrent/Partial transactions</source>
          <target state="translated">兼業・一部取引</target>
        </trans-unit>
        <trans-unit id="754164850f38c1ecdaf6b8ed894cb192bc36c5f4" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="translated">Configuration</target>
        </trans-unit>
        <trans-unit id="6e7b90869f394206b5f3ab5eab0eeb92c62fea14" translate="yes" xml:space="preserve">
          <source>Configuration Connection String</source>
          <target state="translated">設定接続文字列</target>
        </trans-unit>
        <trans-unit id="ac7068df65770d41e1c1be02a2987c9d9b99bd10" translate="yes" xml:space="preserve">
          <source>Configuration file is by default a JSON file called &lt;code&gt;config.json&lt;/code&gt;. But sometimes you want to execute some code or access environment variables which is not possible in JSON files.</source>
          <target state="translated">構成ファイルは、デフォルトでは &lt;code&gt;config.json&lt;/code&gt; というJSONファイルです。しかし、JSONファイルでは不可能なコードを実行したり、環境変数にアクセスしたい場合があります。</target>
        </trans-unit>
        <trans-unit id="fee588358df2f846638bf1ca63ee279f4d14ff08" translate="yes" xml:space="preserve">
          <source>Configuring a Many-to-Many polymorphic association</source>
          <target state="translated">多対多の多形アソシエーションの設定</target>
        </trans-unit>
        <trans-unit id="d13377a4905b9505e4686ca51f32514d15076ca1" translate="yes" xml:space="preserve">
          <source>Configuring a One-to-Many polymorphic association</source>
          <target state="translated">一対多の多形アソシエーションの設定</target>
        </trans-unit>
        <trans-unit id="494adab5bcf0f1438e56ef80e560621c33a0af84" translate="yes" xml:space="preserve">
          <source>Connecting to a database</source>
          <target state="translated">データベースへの接続</target>
        </trans-unit>
        <trans-unit id="4733a8400eab2bdda8721610017ea165deacc02f" translate="yes" xml:space="preserve">
          <source>Connection Hooks</source>
          <target state="translated">接続フック</target>
        </trans-unit>
        <trans-unit id="7f9c4306f84d429259837709a99d4b419088037c" translate="yes" xml:space="preserve">
          <source>Connection Pool</source>
          <target state="translated">接続プール</target>
        </trans-unit>
        <trans-unit id="f348ad399aba3329bb32334b281fb10590cd7a00" translate="yes" xml:space="preserve">
          <source>ConnectionAcquireTimeoutError</source>
          <target state="translated">ConnectionAcquireTimeoutError</target>
        </trans-unit>
        <trans-unit id="54c5f681f77ec4523760ad989f74ae402f08fb1c" translate="yes" xml:space="preserve">
          <source>ConnectionError</source>
          <target state="translated">ConnectionError</target>
        </trans-unit>
        <trans-unit id="346d0cb89df3354c71056beb8315f1fd603881a7" translate="yes" xml:space="preserve">
          <source>ConnectionRefusedError</source>
          <target state="translated">ConnectionRefusedError</target>
        </trans-unit>
        <trans-unit id="e3dc1982d3ea5e3f79a133ef369a5b444b9b3b22" translate="yes" xml:space="preserve">
          <source>ConnectionTimedOutError</source>
          <target state="translated">ConnectionTimedOutError</target>
        </trans-unit>
        <trans-unit id="f720ddc83f6c781e782e7ca3e485c29ee89c1014" translate="yes" xml:space="preserve">
          <source>Consider a comment &lt;code&gt;Foo&lt;/code&gt; whose &lt;code&gt;commentableId&lt;/code&gt; is 2 and &lt;code&gt;commentableType&lt;/code&gt; is &lt;code&gt;image&lt;/code&gt;. Consider also that &lt;code&gt;Image A&lt;/code&gt; and &lt;code&gt;Video X&lt;/code&gt; both happen to have an id equal to 2. Conceptually, it is clear that &lt;code&gt;Video X&lt;/code&gt; is not associated to &lt;code&gt;Foo&lt;/code&gt;, because even though its id is 2, the &lt;code&gt;commentableType&lt;/code&gt; of &lt;code&gt;Foo&lt;/code&gt; is &lt;code&gt;image&lt;/code&gt;, not &lt;code&gt;video&lt;/code&gt;. However, this distinction is made by Sequelize only at the level of the abstractions performed by &lt;code&gt;getCommentable&lt;/code&gt; and the hook we created above.</source>
          <target state="translated">&lt;code&gt;commentableId&lt;/code&gt; が2で、 &lt;code&gt;commentableType&lt;/code&gt; が &lt;code&gt;image&lt;/code&gt; であるコメント &lt;code&gt;Foo&lt;/code&gt; について考えてみます。ことも考えてみましょう &lt;code&gt;Image A&lt;/code&gt; と &lt;code&gt;Video X&lt;/code&gt; 2概念的に等しいIDを持つように起こるの両方、あることは明らかである &lt;code&gt;Video X&lt;/code&gt; に関連付けられていない &lt;code&gt;Foo&lt;/code&gt; そのIDは、2であってもので、 &lt;code&gt;commentableType&lt;/code&gt; の &lt;code&gt;Foo&lt;/code&gt; ある &lt;code&gt;image&lt;/code&gt; ではなく &lt;code&gt;video&lt;/code&gt; 。ただし、この区別は、 &lt;code&gt;getCommentable&lt;/code&gt; と上記で作成したフックによって実行される抽象化のレベルでのみSequelizeによって行われます。</target>
        </trans-unit>
        <trans-unit id="fa2bbd2a354ce9e7972eb878b3a1ee4c75fb8a7d" translate="yes" xml:space="preserve">
          <source>Consider four models: Foo, Bar, Baz and Qux, with has-many associations as follows:</source>
          <target state="translated">4つのモデルを考えてみましょう。Foo,Bar,Baz,Quxの4つのモデルで、以下のようなhas-many連想を持つものを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="8c3a3ab334659340d513bf749ecacb50b2a63e71" translate="yes" xml:space="preserve">
          <source>Consider the following models:</source>
          <target state="translated">以下のようなモデルを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="ff00b81c3559dc0b9e1135401780b330c7a957d9" translate="yes" xml:space="preserve">
          <source>Consider the following setup:</source>
          <target state="translated">以下のような設定を考えてみてください。</target>
        </trans-unit>
        <trans-unit id="0b33329e240af621019008f86344b0be64b14f48" translate="yes" xml:space="preserve">
          <source>Consider the models &lt;code&gt;Foo&lt;/code&gt;, &lt;code&gt;Bar&lt;/code&gt;, &lt;code&gt;Baz&lt;/code&gt; and &lt;code&gt;Qux&lt;/code&gt;, with One-to-Many associations as follows:</source>
          <target state="translated">次のように1 &lt;code&gt;Qux&lt;/code&gt; の関連付けを持つモデル &lt;code&gt;Foo&lt;/code&gt; 、 &lt;code&gt;Bar&lt;/code&gt; 、 &lt;code&gt;Baz&lt;/code&gt; 、およびQuxについて考えてみます。</target>
        </trans-unit>
        <trans-unit id="756bf2141d4d3adc3f2eb59e60aba90481c63543" translate="yes" xml:space="preserve">
          <source>Consider then, that Post has a default scope which only shows active posts: &lt;code&gt;where: { active: true }&lt;/code&gt;. This scope lives on the associated model (Post), and not on the association like the &lt;code&gt;commentable&lt;/code&gt; scope did. Just like the default scope is applied when calling &lt;code&gt;Post.findAll()&lt;/code&gt;, it is also applied when calling &lt;code&gt;User.getPosts()&lt;/code&gt; - this will only return the active posts for that user.</source>
          <target state="translated">次に、そのPostに、アクティブな投稿のみを表示するデフォルトのスコープがあるとします。 &lt;code&gt;where: { active: true }&lt;/code&gt; 。このスコープは関連付けられたモデル（Post）にあり、 &lt;code&gt;commentable&lt;/code&gt; スコープのように関連付けにはありません。呼び出したときに、デフォルトのスコープが適用されただけのよう &lt;code&gt;Post.findAll()&lt;/code&gt; を呼び出すときに、それはまた、適用される &lt;code&gt;User.getPosts()&lt;/code&gt; -これはそのユーザーに対してのみ有効の記事を返します。</target>
        </trans-unit>
        <trans-unit id="6a4dea536e29daa1c05405382d46014c98e615a5" translate="yes" xml:space="preserve">
          <source>Consider you are trying to model a game championship. There are players and teams. Teams play games. However, players can change teams in the middle of the championship (but not in the middle of a game). So, given one specific game, there are certain teams participating in that game, and each of these teams has a set of players (for that game).</source>
          <target state="translated">あなたはゲームのチャンピオンシップをモデルにしようとしていると考えてください。プレイヤーとチームがあります。チームはゲームをします。しかし、プレイヤーはチャンピオンシップの途中でチームを変更することができます (ただし、ゲームの途中では変更できません)。つまり、ある特定のゲームがあるとすると、そのゲームに参加している特定のチームがあり、これらのチームにはそれぞれ(そのゲームのための)選手がいます。</target>
        </trans-unit>
        <trans-unit id="60af5d54bdc5016ac2a43310e8832aa5e063fc6a" translate="yes" xml:space="preserve">
          <source>Consider you have two models, &lt;code&gt;Post&lt;/code&gt; and &lt;code&gt;Reaction&lt;/code&gt;, with a One-to-Many relationship set up, so that one post has many reactions:</source>
          <target state="translated">&lt;code&gt;Post&lt;/code&gt; と &lt;code&gt;Reaction&lt;/code&gt; 2つのモデルがあり、1対多の関係が設定されているため、1つの投稿に多くのリアクションがあるとします。</target>
        </trans-unit>
        <trans-unit id="7856a8e8c39cd680655ba92f560ace09370be10d" translate="yes" xml:space="preserve">
          <source>Constraint name</source>
          <target state="translated">制約名</target>
        </trans-unit>
        <trans-unit id="1e9b6f1184d92e432aaf1a869f53a5985359da7b" translate="yes" xml:space="preserve">
          <source>Constraints &amp;amp; Circularities</source>
          <target state="translated">制約と循環性</target>
        </trans-unit>
        <trans-unit id="60b63939905f7f97033aaa23260215ac8a754e10" translate="yes" xml:space="preserve">
          <source>Constructor Summary</source>
          <target state="translated">コンストラクタの概要</target>
        </trans-unit>
        <trans-unit id="4378934eb83df73dbc84b219479fa9e29d94690f" translate="yes" xml:space="preserve">
          <source>Containment</source>
          <target state="translated">Containment</target>
        </trans-unit>
        <trans-unit id="bbc85e007bcf3a63e687ce28c7b580d4ca82c66d" translate="yes" xml:space="preserve">
          <source>Continuing with the idea of a polymorphic model, consider a tag table - an item can have multiple tags, and a tag can be related to several items.</source>
          <target state="translated">多相モデルのアイデアを続けて、タグテーブルを考えてみましょう-アイテムは複数のタグを持つことができ、1つのタグは複数のアイテムに関連することができます。</target>
        </trans-unit>
        <trans-unit id="11d1abaf886a63a3fd8a522a0742e78e659703ae" translate="yes" xml:space="preserve">
          <source>Convert a user's username to upper case</source>
          <target state="translated">ユーザーのユーザー名を大文字に変換</target>
        </trans-unit>
        <trans-unit id="20e575de41b5214352c5143062f3a7e7e02e945b" translate="yes" xml:space="preserve">
          <source>Convert the instance to a JSON representation.</source>
          <target state="translated">インスタンスを JSON 表現に変換します。</target>
        </trans-unit>
        <trans-unit id="ac4971b8f81e75f5a4f00b92b69be1f460649c65" translate="yes" xml:space="preserve">
          <source>Convert the instance to a JSON representation. Proxies to calling &lt;code&gt;get&lt;/code&gt; with no keys. This means get all values gotten from the DB, and apply all custom getters.</source>
          <target state="translated">インスタンスをJSON表現に変換します。呼び出しのプロキシはキーなしで &lt;code&gt;get&lt;/code&gt; します。つまり、DBから取得したすべての値を取得し、すべてのカスタムゲッターを適用します。</target>
        </trans-unit>
        <trans-unit id="8304bb8920c7e2b2a0e4d69fea55b5b362278cd9" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 2014&amp;ndash;present Sequelize contributors</source>
          <target state="translated">Copyright&amp;copy;2014&amp;ndash;present Sequelize寄稿者</target>
        </trans-unit>
        <trans-unit id="e19828935677052b69324fbd367b0ad39bf3f188" translate="yes" xml:space="preserve">
          <source>Count everything currently associated with this, using an optional where clause.</source>
          <target state="translated">オプションの where 節を使用して、現在これに関連付けられているすべてのものをカウントします。</target>
        </trans-unit>
        <trans-unit id="ef71fb390593b0b29733c9c1039b3befc6ba5d9e" translate="yes" xml:space="preserve">
          <source>Count the number of records matching the provided where clause.</source>
          <target state="translated">提供されたwhere句にマッチするレコードの数をカウントします。</target>
        </trans-unit>
        <trans-unit id="fd79e3727765aac8ff8fffd929e06662ab2d9e3b" translate="yes" xml:space="preserve">
          <source>Create a database</source>
          <target state="translated">データベースの作成</target>
        </trans-unit>
        <trans-unit id="de5a7b79ddceb719d6200b84240e41ec77c637e2" translate="yes" xml:space="preserve">
          <source>Create a migration file with name like &lt;code&gt;XXXXXXXXXXXXXX-create-user.js&lt;/code&gt; in &lt;code&gt;migrations&lt;/code&gt; folder</source>
          <target state="translated">以下のような名前を持つ移行ファイルを作成 &lt;code&gt;XXXXXXXXXXXXXX-create-user.js&lt;/code&gt; 内 &lt;code&gt;migrations&lt;/code&gt; フォルダ</target>
        </trans-unit>
        <trans-unit id="07446a34596749390dc2bd1cac1891ffb6351a36" translate="yes" xml:space="preserve">
          <source>Create a migration file with name like &lt;code&gt;XXXXXXXXXXXXXX-create-user.js&lt;/code&gt; in &lt;code&gt;migrations&lt;/code&gt; folder.</source>
          <target state="translated">以下のような名前を持つ移行ファイルを作成 &lt;code&gt;XXXXXXXXXXXXXX-create-user.js&lt;/code&gt; 中に &lt;code&gt;migrations&lt;/code&gt; フォルダを。</target>
        </trans-unit>
        <trans-unit id="99323ec55c6e204f16f2bb5ffbb975127493e762" translate="yes" xml:space="preserve">
          <source>Create a model file &lt;code&gt;user&lt;/code&gt; in &lt;code&gt;models&lt;/code&gt; folder</source>
          <target state="translated">モデルファイルを作成し &lt;code&gt;user&lt;/code&gt; における &lt;code&gt;models&lt;/code&gt; フォルダを</target>
        </trans-unit>
        <trans-unit id="2ce3a2c5dfbc6062b42c1675414616386c84f16c" translate="yes" xml:space="preserve">
          <source>Create a model file &lt;code&gt;user&lt;/code&gt; in &lt;code&gt;models&lt;/code&gt; folder;</source>
          <target state="translated">モデルファイルを作成し &lt;code&gt;user&lt;/code&gt; における &lt;code&gt;models&lt;/code&gt; フォルダを、</target>
        </trans-unit>
        <trans-unit id="7797bc29d4bd0332ce03664a292c536536e180a1" translate="yes" xml:space="preserve">
          <source>Create a new database schema.</source>
          <target state="translated">新しいデータベーススキーマを作成します。</target>
        </trans-unit>
        <trans-unit id="9453930cbc091a75a646affa7dab856f7e45dec4" translate="yes" xml:space="preserve">
          <source>Create a new instance of the associated model and associate it with this.</source>
          <target state="translated">関連するモデルの新しいインスタンスを作成し、これに関連付けます。</target>
        </trans-unit>
        <trans-unit id="3a6aaf38e60ca2cc55478161e7b4a836605b6fa7" translate="yes" xml:space="preserve">
          <source>Create a new linestring</source>
          <target state="translated">新しいラインストリングを作成します。</target>
        </trans-unit>
        <trans-unit id="12570ffcd72c603ae6aeee594175ad61fc097f4f" translate="yes" xml:space="preserve">
          <source>Create a new point</source>
          <target state="translated">新しいポイントを作成する</target>
        </trans-unit>
        <trans-unit id="82dfd34e745e530b3fcc28f4186f64266ebe877f" translate="yes" xml:space="preserve">
          <source>Create a new point with a custom SRID</source>
          <target state="translated">カスタムSRIDで新規ポイントを作成する</target>
        </trans-unit>
        <trans-unit id="6b61beea019117c97920f1cc2bb6487a9fdec829" translate="yes" xml:space="preserve">
          <source>Create a new polygon</source>
          <target state="translated">新しいポリゴンを作成</target>
        </trans-unit>
        <trans-unit id="5fcf1f19c726fb76f01b4726442f28df05d6330a" translate="yes" xml:space="preserve">
          <source>Create a schema</source>
          <target state="translated">スキーマを作成する</target>
        </trans-unit>
        <trans-unit id="bec1c414ba9217919b8cef5ddabbc69d4cb16d58" translate="yes" xml:space="preserve">
          <source>Create a table with given set of attributes</source>
          <target state="translated">与えられた属性を持つテーブルを作成します。</target>
        </trans-unit>
        <trans-unit id="c806431924f95a4671285986e8923d75dc94de19" translate="yes" xml:space="preserve">
          <source>Create a unique index</source>
          <target state="translated">ユニークなインデックスを作成する</target>
        </trans-unit>
        <trans-unit id="aaef67db78379914630a8533d2f4994117a0a106" translate="yes" xml:space="preserve">
          <source>Create an N:M association with a join table.</source>
          <target state="translated">結合テーブルでN:Mのアソシエーションを作成します。</target>
        </trans-unit>
        <trans-unit id="dafc97e8fbbfb663e5c7e7a02f93f9f5fc43213b" translate="yes" xml:space="preserve">
          <source>Create an N:M association with a join table. Defining &lt;code&gt;through&lt;/code&gt; is required.</source>
          <target state="translated">結合テーブルとのN：M関連付けを作成します。完全に定義 &lt;code&gt;through&lt;/code&gt; 必要があります。</target>
        </trans-unit>
        <trans-unit id="d3a9f18191b0d692a90416a89fd7001f6489ff74" translate="yes" xml:space="preserve">
          <source>Create an SQL function</source>
          <target state="translated">SQL関数を作成する</target>
        </trans-unit>
        <trans-unit id="b40240dca19b3537530cd051448f217b757e0deb" translate="yes" xml:space="preserve">
          <source>Create and insert multiple instances in bulk.</source>
          <target state="translated">複数のインスタンスを一括で作成して挿入します。</target>
        </trans-unit>
        <trans-unit id="37d9838324affaf03f8c636744fea0e83694f29f" translate="yes" xml:space="preserve">
          <source>Creates a 1:m association between this (the source) and the provided target.</source>
          <target state="translated">これ(ソース)と指定されたターゲットの間に1:mのアソシエーションを作成します。</target>
        </trans-unit>
        <trans-unit id="1613f18a42dec9eb987d0bb139eea7fabac56df8" translate="yes" xml:space="preserve">
          <source>Creates a 1:m association between this (the source) and the provided target. The foreign key is added on the target.</source>
          <target state="translated">これ (ソース)と提供されたターゲットの間に 1:m のアソシエーションを作成します。外部キーはターゲットに追加されます。</target>
        </trans-unit>
        <trans-unit id="5f206fe551edb446e2ca35e949d8cdd3e2dd278c" translate="yes" xml:space="preserve">
          <source>Creates a new transaction instance</source>
          <target state="translated">新しいトランザクションインスタンスを作成します。</target>
        </trans-unit>
        <trans-unit id="66c0c5557018e9d480a9c78aa567937c436233a2" translate="yes" xml:space="preserve">
          <source>Creates a table called &lt;code&gt;Users&lt;/code&gt; with all columns as specified in its migration file.</source>
          <target state="translated">移行ファイルで指定されているすべての列を &lt;code&gt;Users&lt;/code&gt; して、Usersというテーブルを作成します。</target>
        </trans-unit>
        <trans-unit id="fdfd171f497df28f7ee38fce7628d79ee63f6507" translate="yes" xml:space="preserve">
          <source>Creates an association between this (the source) and the provided target.</source>
          <target state="translated">これ(ソース)と指定されたターゲットの間に関連付けを作成します。</target>
        </trans-unit>
        <trans-unit id="6f74c907e9756e800049b593ef6b274752344ba3" translate="yes" xml:space="preserve">
          <source>Creates an association between this (the source) and the provided target. The foreign key is added on the source.</source>
          <target state="translated">これ(ソース)と提供されたターゲットの間に関連付けを作成します。外部キーはソースに追加されます。</target>
        </trans-unit>
        <trans-unit id="004b91a2322793619b65b3c81414e80df0ebf671" translate="yes" xml:space="preserve">
          <source>Creates an association between this (the source) and the provided target. The foreign key is added on the target.</source>
          <target state="translated">これ(ソース)と提供されたターゲットの間に関連付けを作成します。外部キーがターゲットに追加されます。</target>
        </trans-unit>
        <trans-unit id="fbfab4a6c96f1f410afcb33106ef3c738c414173" translate="yes" xml:space="preserve">
          <source>Creates an object representing a call to the cast function.</source>
          <target state="translated">キャスト関数の呼び出しを表すオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="7c78f7a45c7ef1a333f7fdaf346ca3634e2e4737" translate="yes" xml:space="preserve">
          <source>Creates an object representing a database function.</source>
          <target state="translated">データベース関数を表すオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="4b53fc20f9a1060c0591933ba958616ffd2a1bcf" translate="yes" xml:space="preserve">
          <source>Creates an object representing a database function. This can be used in search queries, both in where and order parts, and as default values in column definitions. If you want to refer to columns in your function, you should use &lt;code&gt;sequelize.col&lt;/code&gt;, so that the columns are properly interpreted as columns and not a strings.</source>
          <target state="translated">データベース関数を表すオブジェクトを作成します。これは、whereとorderの両方の部分での検索クエリ、および列定義のデフォルト値として使用できます。関数の列を参照する場合は、 &lt;code&gt;sequelize.col&lt;/code&gt; を使用して、列が文字列ではなく列として適切に解釈されるようにする必要があります。</target>
        </trans-unit>
        <trans-unit id="0f2fa3193c2f10b70f87c639d7850bccb1764b19" translate="yes" xml:space="preserve">
          <source>Creates an object representing a literal, i.e.</source>
          <target state="translated">リテラルを表すオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="1b65d5d95dba6c3c38bd5b50fd82102e6eaef45e" translate="yes" xml:space="preserve">
          <source>Creates an object representing a literal, i.e. something that will not be escaped.</source>
          <target state="translated">リテラル、つまりエスケープされないものを表すオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="118fd0d0a0112e0fe426478ed3a4dfbcb76dbd62" translate="yes" xml:space="preserve">
          <source>Creates an object representing nested where conditions for postgres/sqlite/mysql json data-type.</source>
          <target state="translated">postgres/sqlite/mysql jsonデータ型のネストされたwhere条件を表すオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="f1fb4d4fc9e715c0f15076c4f63e7ef753a6e351" translate="yes" xml:space="preserve">
          <source>Creates an object which represents a column in the DB, this allows referencing another column in your query.</source>
          <target state="translated">DB内のカラムを表すオブジェクトを作成し、クエリ内の別のカラムを参照できるようにします。</target>
        </trans-unit>
        <trans-unit id="aaa2ff3dcc66fe0290d99e1f82ae9f8d3fb0e137" translate="yes" xml:space="preserve">
          <source>Creates an object which represents a column in the DB, this allows referencing another column in your query. This is often useful in conjunction with &lt;code&gt;sequelize.fn&lt;/code&gt;, since raw string arguments to fn will be escaped.</source>
          <target state="translated">DBの列を表すオブジェクトを作成します。これにより、クエリで別の列を参照できます。fnへの生の文字列引数は &lt;code&gt;sequelize.fn&lt;/code&gt; れるため、これはsequelize.fnと組み合わせて使用​​すると便利です。</target>
        </trans-unit>
        <trans-unit id="d049de031fac4a1d122cc0f8ddee0a3dc0e6664c" translate="yes" xml:space="preserve">
          <source>Creates new validation error item</source>
          <target state="translated">新しい検証エラー項目を作成します。</target>
        </trans-unit>
        <trans-unit id="3aa728453c208f42daeb32a0a15f64a2a1fc7d8e" translate="yes" xml:space="preserve">
          <source>Creating First Seed</source>
          <target state="translated">ファーストシードの作成</target>
        </trans-unit>
        <trans-unit id="caa32e4e8e79e2c3c02dca0de8e30c735ffb9e02" translate="yes" xml:space="preserve">
          <source>Creating a table</source>
          <target state="translated">テーブルの作成</target>
        </trans-unit>
        <trans-unit id="6dc74922e055dcd620d8e26b521f5669cd570096" translate="yes" xml:space="preserve">
          <source>Creating an association will add a foreign key constraint to the attributes. All associations use &lt;code&gt;CASCADE&lt;/code&gt; on update and &lt;code&gt;SET NULL&lt;/code&gt; on delete, except for n:m, which also uses &lt;code&gt;CASCADE&lt;/code&gt; on delete.</source>
          <target state="translated">関連付けを作成すると、属性に外部キー制約が追加されます。すべての関連付けは、更新時に &lt;code&gt;CASCADE&lt;/code&gt; を使用し、削除時に &lt;code&gt;SET NULL&lt;/code&gt; を使用します。ただし、n：mは、削除時に &lt;code&gt;CASCADE&lt;/code&gt; も使用します。</target>
        </trans-unit>
        <trans-unit id="3086da36f77bee52dcfe1664393977bd52cec77b" translate="yes" xml:space="preserve">
          <source>Creating an instance</source>
          <target state="translated">インスタンスの作成</target>
        </trans-unit>
        <trans-unit id="4b3d5849847aa768f7f083714361ed65cbcf480b" translate="yes" xml:space="preserve">
          <source>Creating associations in sequelize is done by calling one of the belongsTo / hasOne / hasMany / belongsToMany functions on a model (the source), and providing another model as the first argument to the function (the target).</source>
          <target state="translated">sequelize でのアソシエーションの作成は、モデル (ソース)で belongsTo/hasOne/hasMany/belongsToMany 関数のいずれかを呼び出し、関数の第一引数として別のモデル (ターゲット)を提供することで行われます。</target>
        </trans-unit>
        <trans-unit id="64c897965ef5b8a5f324e2bab7ce95b0dc43659b" translate="yes" xml:space="preserve">
          <source>Creating associations referencing a field which is not the primary key</source>
          <target state="translated">主キーではないフィールドを参照するアソシエーションの作成</target>
        </trans-unit>
        <trans-unit id="aad3e4efd94560e1bc4495b635681eae60ad2d51" translate="yes" xml:space="preserve">
          <source>Creating first Model (and Migration)</source>
          <target state="translated">最初のモデルの作成(およびマイグレーション</target>
        </trans-unit>
        <trans-unit id="f08dfddc9c37b5535ffc44f2c90aeea7e390127f" translate="yes" xml:space="preserve">
          <source>Creating in bulk</source>
          <target state="translated">一括作成</target>
        </trans-unit>
        <trans-unit id="ac5b66de6104cc5ff1e50e727c226274bbec0715" translate="yes" xml:space="preserve">
          <source>Creating persistent instances</source>
          <target state="translated">永続的なインスタンスの作成</target>
        </trans-unit>
        <trans-unit id="b4d618c3adec150bb5b7f92035f77ae3a872e661" translate="yes" xml:space="preserve">
          <source>Creating the first Model (and Migration)</source>
          <target state="translated">最初のモデルの作成(とマイグレーション</target>
        </trans-unit>
        <trans-unit id="543e903ce50fec3a23c4d48cc7b8a277550fdac5" translate="yes" xml:space="preserve">
          <source>Creating the first Seed</source>
          <target state="translated">第一シードの作成</target>
        </trans-unit>
        <trans-unit id="9c1dc2f546ca537d27b49705ba79bc5ec885fc56" translate="yes" xml:space="preserve">
          <source>Creating the standard relationships</source>
          <target state="translated">標準的な関係性を作る</target>
        </trans-unit>
        <trans-unit id="fbeaf5bb2295a0ad55bf0d5a18c884864de3f9cc" translate="yes" xml:space="preserve">
          <source>Creating with Associations</source>
          <target state="translated">アソシエーションを使った作成</target>
        </trans-unit>
        <trans-unit id="c28e71f7de26b1295c660b682b873ce3319dc459" translate="yes" xml:space="preserve">
          <source>Creating with associations</source>
          <target state="translated">アソシエーションを使った作成</target>
        </trans-unit>
        <trans-unit id="c6d419641c4bf5d88e2cad8d761a6a7082d6c6d1" translate="yes" xml:space="preserve">
          <source>Creating, updating and deleting</source>
          <target state="translated">作成、更新、削除</target>
        </trans-unit>
        <trans-unit id="3110c1f3e73c788e86e5d4512cf410c3dc1c1690" translate="yes" xml:space="preserve">
          <source>Currenly, SQLite does not support &lt;a href=&quot;https://www.sqlite.org/omitted.html&quot;&gt;right joins&lt;/a&gt;.</source>
          <target state="translated">現在、SQLiteは&lt;a href=&quot;https://www.sqlite.org/omitted.html&quot;&gt;右結合を&lt;/a&gt;サポートしていません。</target>
        </trans-unit>
        <trans-unit id="5a30d10fd754280e661548db197d38eed9b8ed2b" translate="yes" xml:space="preserve">
          <source>Current column name</source>
          <target state="translated">現在のカラム名</target>
        </trans-unit>
        <trans-unit id="aeb8251d8beeaa384177f46738068526c66c50c8" translate="yes" xml:space="preserve">
          <source>Current name of function</source>
          <target state="translated">現在の関数名</target>
        </trans-unit>
        <trans-unit id="636981c9acb94bb09350975b62614e7b5d0d708c" translate="yes" xml:space="preserve">
          <source>Current name of table</source>
          <target state="translated">現在のテーブル名</target>
        </trans-unit>
        <trans-unit id="db756f94c9070eedd019aa02b12998ab497e3ccb" translate="yes" xml:space="preserve">
          <source>Customizing the foreign key</source>
          <target state="translated">外部キーのカスタマイズ</target>
        </trans-unit>
        <trans-unit id="b3718a764361fcf0cb3afe936701f3e0f34a0552" translate="yes" xml:space="preserve">
          <source>Cyclic dependencies &amp;amp; Disabling constraints</source>
          <target state="translated">循環依存と制約の無効化</target>
        </trans-unit>
        <trans-unit id="8c76abdec41a7652375d00f4bf05256b82c68494" translate="yes" xml:space="preserve">
          <source>DATE</source>
          <target state="translated">DATE</target>
        </trans-unit>
        <trans-unit id="1b6e0231710c4347c4a9adaa78a001d3be5f1953" translate="yes" xml:space="preserve">
          <source>DATEONLY</source>
          <target state="translated">DATEONLY</target>
        </trans-unit>
        <trans-unit id="0cdc67ab1e0e2c1a616bd7f5b265aa1ac042f629" translate="yes" xml:space="preserve">
          <source>DECIMAL</source>
          <target state="translated">DECIMAL</target>
        </trans-unit>
        <trans-unit id="1473660f8ec2c1cd5ec200a9312979ae92af62e2" translate="yes" xml:space="preserve">
          <source>DEFAULT (MSSQL only)</source>
          <target state="translated">DEFAULT(MSSQLのみ</target>
        </trans-unit>
        <trans-unit id="10f984f7d502771d13c63406af087a7b917fd1aa" translate="yes" xml:space="preserve">
          <source>DEFERRED</source>
          <target state="translated">DEFERRED</target>
        </trans-unit>
        <trans-unit id="d6f5636098cd458ce9d22939f8e3e8deab0e9bd0" translate="yes" xml:space="preserve">
          <source>DELETE</source>
          <target state="translated">DELETE</target>
        </trans-unit>
        <trans-unit id="188157101620ef8e467f19e0555258980540195c" translate="yes" xml:space="preserve">
          <source>DESCRIBE</source>
          <target state="translated">DESCRIBE</target>
        </trans-unit>
        <trans-unit id="097274c5c7abaa172853282efd2062239c4afe9d" translate="yes" xml:space="preserve">
          <source>DOUBLE</source>
          <target state="translated">DOUBLE</target>
        </trans-unit>
        <trans-unit id="c18842877f84be9bb3ae10673c4e60242f22c160" translate="yes" xml:space="preserve">
          <source>Data Types</source>
          <target state="translated">データ型</target>
        </trans-unit>
        <trans-unit id="16b6d1302e113952c2e74d59e21f98e7c034b4ca" translate="yes" xml:space="preserve">
          <source>Data retrieval / Finders</source>
          <target state="translated">データ検索・ファインダーズ</target>
        </trans-unit>
        <trans-unit id="5cf77b3e7be996116602805a95309307cedd99bb" translate="yes" xml:space="preserve">
          <source>Data type: ARRAY(ENUM) - PostgreSQL only</source>
          <target state="translated">データ型:ARRAY(ENUM)-PostgreSQLのみ</target>
        </trans-unit>
        <trans-unit id="51c6c861435ac739298311001d9adf19ab20e376" translate="yes" xml:space="preserve">
          <source>Data type: TIMESTAMP WITHOUT TIME ZONE - PostgreSQL only</source>
          <target state="translated">データ型:TIMESTAMP WITHOUT TIME ZONE-PostgreSQLのみ</target>
        </trans-unit>
        <trans-unit id="452dae9d92ae82969a792e2c32fbd27f5b783894" translate="yes" xml:space="preserve">
          <source>DataTypes</source>
          <target state="translated">DataTypes</target>
        </trans-unit>
        <trans-unit id="e55983deb404c0934789dc39ba2d5c698868a848" translate="yes" xml:space="preserve">
          <source>DataTypes.GEOGRAPHY</source>
          <target state="translated">DataTypes.GEOGRAPHY</target>
        </trans-unit>
        <trans-unit id="39c278c49d95904686600a297ae838fcdcf5ad1e" translate="yes" xml:space="preserve">
          <source>Database Engine Support</source>
          <target state="translated">データベースエンジンのサポート</target>
        </trans-unit>
        <trans-unit id="92ea1f457717f68645fb46cf1c8284c96865e310" translate="yes" xml:space="preserve">
          <source>Database character classification, PostgreSQL only</source>
          <target state="translated">データベース文字分類、PostgreSQLのみ</target>
        </trans-unit>
        <trans-unit id="b85ae159464679d594a0b15732ce1cc5fef9ffd2" translate="yes" xml:space="preserve">
          <source>Database default character set, MYSQL only</source>
          <target state="translated">データベースのデフォルト文字セット、MYSQLのみ</target>
        </trans-unit>
        <trans-unit id="b9185d523dfbfceff505f8308320e46ff84b45ea" translate="yes" xml:space="preserve">
          <source>Database default character set, PostgreSQL only</source>
          <target state="translated">データベースのデフォルト文字セット、PostgreSQLのみ</target>
        </trans-unit>
        <trans-unit id="57715d7d4ad61f3f1d3cdcc16b2a51ad6d81bc27" translate="yes" xml:space="preserve">
          <source>Database default collation</source>
          <target state="translated">データベースのデフォルト照合</target>
        </trans-unit>
        <trans-unit id="7ed3cf2f6786b03f145894f684242a6f47c80ccf" translate="yes" xml:space="preserve">
          <source>Database name to create</source>
          <target state="translated">作成するデータベース名</target>
        </trans-unit>
        <trans-unit id="1e1475d0d52ad61d289472a24505e8cdf27dcb54" translate="yes" xml:space="preserve">
          <source>Database name to drop</source>
          <target state="translated">ドロップするデータベース名</target>
        </trans-unit>
        <trans-unit id="6440a03a5b1c2049664d2238af4b2afbe339c003" translate="yes" xml:space="preserve">
          <source>Database safety check</source>
          <target state="translated">データベースの安全性チェック</target>
        </trans-unit>
        <trans-unit id="fe855d9eb6616607500e1663ab7e41c3404361e0" translate="yes" xml:space="preserve">
          <source>Database synchronization</source>
          <target state="translated">データベースの同期化</target>
        </trans-unit>
        <trans-unit id="f3035ba3f23d1737dbf5d8db4bcd70058e5e68f8" translate="yes" xml:space="preserve">
          <source>DatabaseError</source>
          <target state="translated">DatabaseError</target>
        </trans-unit>
        <trans-unit id="8562930b64d8c57b6dc3907022c61a4e6a5ac83f" translate="yes" xml:space="preserve">
          <source>Datatypes</source>
          <target state="translated">Datatypes</target>
        </trans-unit>
        <trans-unit id="87ee1c987881d06cbf1ff8b715a82cae5934ee96" translate="yes" xml:space="preserve">
          <source>Date column with timezone, default is UTC</source>
          <target state="translated">タイムゾーン付きの日付カラム、デフォルトはUTCです。</target>
        </trans-unit>
        <trans-unit id="842b7b5d71896a41ecd92997ec80b1df5243c81e" translate="yes" xml:space="preserve">
          <source>Dates</source>
          <target state="translated">Dates</target>
        </trans-unit>
        <trans-unit id="6e1a74ef484369499fb26648565c6c22d4089da5" translate="yes" xml:space="preserve">
          <source>Decimal type, variable precision, take length as specified by user</source>
          <target state="translated">10進数型、可変精度、ユーザが指定した長さを取ります。</target>
        </trans-unit>
        <trans-unit id="d5d3294a4f7b017bc5ac427c1cc5667cf41327a6" translate="yes" xml:space="preserve">
          <source>Declaring Hooks</source>
          <target state="translated">フックの宣言</target>
        </trans-unit>
        <trans-unit id="639f5e24d627d5a69fe35788701863daccd9a1ba" translate="yes" xml:space="preserve">
          <source>Decrement the value of one or more columns.</source>
          <target state="translated">1つ以上の列の値をデクリメントします。</target>
        </trans-unit>
        <trans-unit id="611219592e750f90a29ad21a5eea84c21c768cf6" translate="yes" xml:space="preserve">
          <source>Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a</source>
          <target state="translated">1 つ以上の列の値を減少させます。これはデータベース内で行われ、現在インスタンスに保存されている値を使用しないことを意味します。デクリメントは</target>
        </trans-unit>
        <trans-unit id="f4b629840b1479afda3a588f435bd1786d5df9a9" translate="yes" xml:space="preserve">
          <source>Decrement the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The decrement is done using a &lt;code&gt;sql SET column = column - X WHERE foo = 'bar'&lt;/code&gt; query. To get the correct value after a decrement into the Instance you should do a reload.</source>
          <target state="translated">1つ以上の列の値を減らします。これはデータベースで行われます。つまり、インスタンスに現在保存されている値は使用されません。デクリメントは、 &lt;code&gt;sql SET column = column - X WHERE foo = 'bar'&lt;/code&gt; クエリを使用して行われます。インスタンスへのデクリメント後に正しい値を取得するには、リロードを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="82b93adf8abc4a2c439c2caba7da91ec4da03ccd" translate="yes" xml:space="preserve">
          <source>Decrementing</source>
          <target state="translated">Decrementing</target>
        </trans-unit>
        <trans-unit id="9a3add6ccd892dadee1d219b35616d2f38e2779d" translate="yes" xml:space="preserve">
          <source>Decrementing works in the exact same way.</source>
          <target state="translated">デクリメントも全く同じように機能します。</target>
        </trans-unit>
        <trans-unit id="cc0c0d02ed365707f66785c5c11f4efe2a9f8b17" translate="yes" xml:space="preserve">
          <source>Default - MSSQL only</source>
          <target state="translated">デフォルト-MSSQL のみ</target>
        </trans-unit>
        <trans-unit id="ce5dc4c4981e0079ab6d262f8a2560c04386013e" translate="yes" xml:space="preserve">
          <source>Default Hooks (Sequelize.options.define)</source>
          <target state="translated">デフォルトフック (Sequelize.options.define)</target>
        </trans-unit>
        <trans-unit id="bf322e63e4129512a8e82c0cf2816cb488ddb28f" translate="yes" xml:space="preserve">
          <source>Default Hooks (on Sequelize constructor options)</source>
          <target state="translated">デフォルトのフック (Sequelize コンストラクタのオプション)</target>
        </trans-unit>
        <trans-unit id="54e853e380fbb256af90f1b6701ddb337a923884" translate="yes" xml:space="preserve">
          <source>Default Values</source>
          <target state="translated">デフォルト値</target>
        </trans-unit>
        <trans-unit id="c8b0078307212ac99d70aed14cde95cfd0e8edab" translate="yes" xml:space="preserve">
          <source>Default options for model definitions. See &lt;a href=&quot;model.js~model#static-method-init&quot;&gt;Model.init&lt;/a&gt;.</source>
          <target state="translated">モデル定義のデフォルトオプション。&lt;a href=&quot;model.js~model#static-method-init&quot;&gt;Model.initを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="138ea2bc5fd2d8230ea890634a179578fd0a3280" translate="yes" xml:space="preserve">
          <source>Default options for sequelize.query</source>
          <target state="translated">sequelize.query のデフォルトオプション</target>
        </trans-unit>
        <trans-unit id="3282ec791792bf75df8dc4184c3cfa1bf4129358" translate="yes" xml:space="preserve">
          <source>Default options for sequelize.set</source>
          <target state="translated">sequelize.set のデフォルトオプション</target>
        </trans-unit>
        <trans-unit id="148d18b0afcd38983917272029338aa34abe2546" translate="yes" xml:space="preserve">
          <source>Default options for sequelize.sync</source>
          <target state="translated">sequelize.sync のデフォルトオプション</target>
        </trans-unit>
        <trans-unit id="e034cbbe2b8762f796d4892d08bbfed1145d3ef8" translate="yes" xml:space="preserve">
          <source>Default values</source>
          <target state="translated">デフォルト値</target>
        </trans-unit>
        <trans-unit id="1cf31c3996a9575ac98fa259e4f15d6814eb7d75" translate="yes" xml:space="preserve">
          <source>Default values to use if building a new instance</source>
          <target state="translated">新しいインスタンスを構築する際に使用するデフォルト値</target>
        </trans-unit>
        <trans-unit id="c3644ae30a48d92e1c5317f11e352c68c4a1a5e7" translate="yes" xml:space="preserve">
          <source>Default values to use if creating a new instance</source>
          <target state="translated">新しいインスタンスを作成する際に使用するデフォルト値</target>
        </trans-unit>
        <trans-unit id="1b6417ab627b74c6bc6da989846304f37ee7f50e" translate="yes" xml:space="preserve">
          <source>Defaults to pluralized model name, unless freezeTableName is true, in which case it uses model name verbatim</source>
          <target state="translated">freezeTableNameがtrueの場合はモデル名をそのまま使用します。</target>
        </trans-unit>
        <trans-unit id="417d326a6c611f33a5dbe90a166a7f6da3456bc0" translate="yes" xml:space="preserve">
          <source>Defer constraints checks to the end of transactions.</source>
          <target state="translated">制約チェックをトランザクションの最後まで延期します。</target>
        </trans-unit>
        <trans-unit id="4dee511653d844d8c7e6bb9a625536c8afb8a6b7" translate="yes" xml:space="preserve">
          <source>Deferrable</source>
          <target state="translated">Deferrable</target>
        </trans-unit>
        <trans-unit id="e2c8beb421bc96d4598ad75cd6bcaf8cc3c04d09" translate="yes" xml:space="preserve">
          <source>Define a new instance method on the &lt;code&gt;Tag&lt;/code&gt; model called &lt;code&gt;getTaggables&lt;/code&gt; which calls, under the hood, the correct mixin to fetch the appropriate taggables.</source>
          <target state="translated">&lt;code&gt;getTaggables&lt;/code&gt; と呼ばれる &lt;code&gt;Tag&lt;/code&gt; モデルに新しいインスタンスメソッドを定義します。このメソッドは、内部で正しいミックスインを呼び出して、適切なタグガブルをフェッチします。</target>
        </trans-unit>
        <trans-unit id="a18f0956a766ec1d65be95892143c8ccfd248050" translate="yes" xml:space="preserve">
          <source>Define a new model, representing a table in the database.</source>
          <target state="translated">データベース内のテーブルを表す新しいモデルを定義します。</target>
        </trans-unit>
        <trans-unit id="6950a6e98fe5e1257a8d847336aa8883c50fab57" translate="yes" xml:space="preserve">
          <source>Define a string field called &lt;code&gt;commentableType&lt;/code&gt; in the &lt;code&gt;Comment&lt;/code&gt; model;</source>
          <target state="translated">呼ばれる文字列フィールド定義 &lt;code&gt;commentableType&lt;/code&gt; に &lt;code&gt;Comment&lt;/code&gt; モデル。</target>
        </trans-unit>
        <trans-unit id="479dd6fd4b78f2302aaee932b13d364f2a4c5a33" translate="yes" xml:space="preserve">
          <source>Define a string field called &lt;code&gt;taggableType&lt;/code&gt; in the junction model;</source>
          <target state="translated">ジャンクションモデルで &lt;code&gt;taggableType&lt;/code&gt; という文字列フィールドを定義します。</target>
        </trans-unit>
        <trans-unit id="e326f2112166494f0b6c9952a9561efbd4ff9aae" translate="yes" xml:space="preserve">
          <source>Define the &lt;code&gt;belongsToMany&lt;/code&gt; associations between the two models and &lt;code&gt;Tag&lt;/code&gt;:</source>
          <target state="translated">2つのモデルと &lt;code&gt;Tag&lt;/code&gt; 間の &lt;code&gt;belongsToMany&lt;/code&gt; の関連付けを定義します。</target>
        </trans-unit>
        <trans-unit id="d6e58a5c8da437f1060b865a4c7978851f1bc80c" translate="yes" xml:space="preserve">
          <source>Define the &lt;code&gt;hasMany&lt;/code&gt; and &lt;code&gt;belongsTo&lt;/code&gt; association between &lt;code&gt;Image&lt;/code&gt;/&lt;code&gt;Video&lt;/code&gt; and &lt;code&gt;Comment&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Image&lt;/code&gt; / &lt;code&gt;Video&lt;/code&gt; と &lt;code&gt;Comment&lt;/code&gt; 間の &lt;code&gt;hasMany&lt;/code&gt; と &lt;code&gt;belongsTo&lt;/code&gt; の関連付けを定義します。</target>
        </trans-unit>
        <trans-unit id="dc447867338cc4fa8513dafb96f2dbf47262250d" translate="yes" xml:space="preserve">
          <source>Define the default search scope to use for this model. Scopes have the same form as the options passed to find / findAll</source>
          <target state="translated">このモデルで使用するデフォルトの検索スコープを定義します。スコープは find/findAll に渡されるオプションと同じ形式です。</target>
        </trans-unit>
        <trans-unit id="fa07cd438d840d41fd6930c33e885db6ea7bc5db" translate="yes" xml:space="preserve">
          <source>Define the juncion model explicitly, specifying the two foreign keys as &lt;code&gt;tagId&lt;/code&gt; and &lt;code&gt;taggableId&lt;/code&gt; (this way it is a junction model for a Many-to-Many relationship between &lt;code&gt;Tag&lt;/code&gt; and the abstract concept of &lt;em&gt;taggable&lt;/em&gt;);</source>
          <target state="translated">2つの外部キーを指定して、明示的にjuncionモデルを定義して &lt;code&gt;tagId&lt;/code&gt; と &lt;code&gt;taggableId&lt;/code&gt; （この方法は、それが間の多対多の関係のための接合モデルで &lt;code&gt;Tag&lt;/code&gt; との抽象的な概念&lt;em&gt;タグ付け可能&lt;/em&gt;）。</target>
        </trans-unit>
        <trans-unit id="dc4248d08beab2357993fa80f9f88dc8d366770f" translate="yes" xml:space="preserve">
          <source>Define the sequelize instance to attach to the new Model. Throw error if none is provided.</source>
          <target state="translated">新しいモデルにアタッチする sequelize インスタンスを定義します。何も指定しない場合はエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="6f7c68eadb6a94a86fb7ac811b331392abec3504" translate="yes" xml:space="preserve">
          <source>Defining &lt;code&gt;through&lt;/code&gt; is &lt;strong&gt;required&lt;/strong&gt;. Sequelize would previously attempt to autogenerate names but that would not always lead to the most logical setups.</source>
          <target state="translated">完全に定義 &lt;code&gt;through&lt;/code&gt; &lt;strong&gt;必要&lt;/strong&gt;が&lt;strong&gt;あり&lt;/strong&gt;ます。Sequelizeは以前に名前を自動生成しようとしましたが、それが常に最も論理的なセットアップにつながるとは限りません。</target>
        </trans-unit>
        <trans-unit id="3d69043479905b749aa977824179767f7ffeaa7c" translate="yes" xml:space="preserve">
          <source>Defining a Geography type attribute</source>
          <target state="translated">地理型属性の定義</target>
        </trans-unit>
        <trans-unit id="722136870c63dcf938b34b0d787aa1361792ee6f" translate="yes" xml:space="preserve">
          <source>Defining a Geometry type attribute</source>
          <target state="translated">Geometry型属性の定義</target>
        </trans-unit>
        <trans-unit id="0bebaea2e6e58b3029ddffbe4dded1019d9a2927" translate="yes" xml:space="preserve">
          <source>Defining a model as paranoid</source>
          <target state="translated">妄想的なモデルの定義</target>
        </trans-unit>
        <trans-unit id="26e26e600d5af3e30989258622a1bdcb5b8d2d19" translate="yes" xml:space="preserve">
          <source>Defining an Alias</source>
          <target state="translated">エイリアスの定義</target>
        </trans-unit>
        <trans-unit id="1ae922b49beac040a2d64dd8047c9f7a2592360e" translate="yes" xml:space="preserve">
          <source>Defining an Alias is more powerful than simply specifying a custom name for the foreign key. This is better understood with an example:</source>
          <target state="translated">エイリアスの定義は、単に外部キーのカスタム名を指定するよりも強力です。これは例を見ていただくとよくわかると思います。</target>
        </trans-unit>
        <trans-unit id="9c2f0ca4f53353261b29b3b36cb51bb641043be2" translate="yes" xml:space="preserve">
          <source>Defining an alias for a &lt;code&gt;belongsToMany&lt;/code&gt; association also impacts the way includes are performed:</source>
          <target state="translated">&lt;code&gt;belongsToMany&lt;/code&gt; アソシエーションのエイリアスを定義すると、インクルードの実行方法にも影響します。</target>
        </trans-unit>
        <trans-unit id="ec8934836699eb58af226e164faa6976aaeadebe" translate="yes" xml:space="preserve">
          <source>Defining as part of a property</source>
          <target state="translated">プロパティの一部として定義</target>
        </trans-unit>
        <trans-unit id="6ca0aae705049c1cde57c354dc3e656c9775db27" translate="yes" xml:space="preserve">
          <source>Defining as part of the model options</source>
          <target state="translated">モデルオプションの一部として定義</target>
        </trans-unit>
        <trans-unit id="6beb64bd8e9f32456ed8404f04359888b293c09f" translate="yes" xml:space="preserve">
          <source>Defining the Sequelize associations</source>
          <target state="translated">Sequelize アソシエーションの定義</target>
        </trans-unit>
        <trans-unit id="bf1be2b7ad07bae2fe92475d10173eb638774def" translate="yes" xml:space="preserve">
          <source>Definition</source>
          <target state="translated">Definition</target>
        </trans-unit>
        <trans-unit id="7b355055101652c13fbb4a0407b5baa90351f05c" translate="yes" xml:space="preserve">
          <source>Delete instead of setting deletedAt to current timestamp (only applicable if &lt;code&gt;paranoid&lt;/code&gt; is enabled)</source>
          <target state="translated">deletedAtを現在のタイムスタンプに設定する代わりに削除（ &lt;code&gt;paranoid&lt;/code&gt; が有効な場合にのみ適用可能）</target>
        </trans-unit>
        <trans-unit id="6ca8cb72940d4ee2942def3d3422e73a34a4d0ad" translate="yes" xml:space="preserve">
          <source>Delete multiple instances, or set their deletedAt timestamp to the current time if &lt;code&gt;paranoid&lt;/code&gt; is enabled.</source>
          <target state="translated">複数のインスタンスを削除するか、 &lt;code&gt;paranoid&lt;/code&gt; が有効になっている場合は、それらのdeletedAtタイムスタンプを現在の時刻に設定します。</target>
        </trans-unit>
        <trans-unit id="918f8bfa458557d9f7a7062a6a388c0f8c5d41b1" translate="yes" xml:space="preserve">
          <source>Delete multiple records from a table</source>
          <target state="translated">テーブルから複数のレコードを削除する</target>
        </trans-unit>
        <trans-unit id="2ca33980535f175f034ff949b301b2d6e2967fd4" translate="yes" xml:space="preserve">
          <source>Delete queries also accept the &lt;code&gt;where&lt;/code&gt; option, just like the read queries shown above.</source>
          <target state="translated">上記の読み取りクエリと同様に、削除クエリも &lt;code&gt;where&lt;/code&gt; オプションを受け入れます。</target>
        </trans-unit>
        <trans-unit id="2cda36c95c093ae4cd6d399186e93976d1bcca02" translate="yes" xml:space="preserve">
          <source>Deleting</source>
          <target state="translated">Deleting</target>
        </trans-unit>
        <trans-unit id="4eba1c4e233cd4f035a51130c50d726a17d83bb1" translate="yes" xml:space="preserve">
          <source>Deleting an instance</source>
          <target state="translated">インスタンスの削除</target>
        </trans-unit>
        <trans-unit id="9a66aadbfd8ac653ab54cd294931e8c04b2e90ef" translate="yes" xml:space="preserve">
          <source>Deprecated: &lt;code&gt;sequelize.import&lt;/code&gt;</source>
          <target state="translated">非推奨： &lt;code&gt;sequelize.import&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac2dd9e550f14e75a7e1372fd0a96b971d90c102" translate="yes" xml:space="preserve">
          <source>Deprecated: Operator Aliases</source>
          <target state="translated">非推奨。オペレータエイリアス</target>
        </trans-unit>
        <trans-unit id="704a9772bc74638722ad09f4eff3c22fc1f31ca9" translate="yes" xml:space="preserve">
          <source>Describe a table structure</source>
          <target state="translated">テーブルの構造を記述する</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="a5888710dff7b58370cc3187d0c54b8b1462c852" translate="yes" xml:space="preserve">
          <source>Destroy the row corresponding to this instance.</source>
          <target state="translated">このインスタンスに対応する行を破棄します。</target>
        </trans-unit>
        <trans-unit id="3016ef950b0c07e28f3a688d79e8ac567daaeabc" translate="yes" xml:space="preserve">
          <source>Destroy the row corresponding to this instance. Depending on your setting for paranoid, the row will either be completely deleted, or have its deletedAt timestamp set to the current time.</source>
          <target state="translated">このインスタンスに対応する行を破棄します。paranoidの設定にもよりますが、行は完全に削除されるか、deletedAtのタイムスタンプが現在の時刻に設定されます。</target>
        </trans-unit>
        <trans-unit id="ddc29095a9fdf37911daa81999d86249d7a919a5" translate="yes" xml:space="preserve">
          <source>Destroying / Deleting persistent instances</source>
          <target state="translated">永続的なインスタンスの破棄/削除</target>
        </trans-unit>
        <trans-unit id="209d2430bedcc4a2d947ae78704ba91c9dec679e" translate="yes" xml:space="preserve">
          <source>Dialect-Specific Things</source>
          <target state="translated">方言特有のこと</target>
        </trans-unit>
        <trans-unit id="e3c71164c6732aa2815690d848fc5e3dc0309a6e" translate="yes" xml:space="preserve">
          <source>Dialects</source>
          <target state="translated">Dialects</target>
        </trans-unit>
        <trans-unit id="ecf655b86917e76c2cefb3aafa360c4b73b6caeb" translate="yes" xml:space="preserve">
          <source>Difference between HasOne and BelongsTo</source>
          <target state="translated">HasOneとBelongsToの違い</target>
        </trans-unit>
        <trans-unit id="de4ade1039dd218ba31ee544525b597b50e7c6ac" translate="yes" xml:space="preserve">
          <source>Difference between Validations and Constraints</source>
          <target state="translated">検証と制約の違い</target>
        </trans-unit>
        <trans-unit id="ee0894f4da97be7c2b2d7842e892b6820058cd59" translate="yes" xml:space="preserve">
          <source>Direct Subclass:</source>
          <target state="translated">ダイレクトサブクラス。</target>
        </trans-unit>
        <trans-unit id="1029544ae8b46287a52a74595462c217cf60a5a9" translate="yes" xml:space="preserve">
          <source>Directories</source>
          <target state="translated">Directories</target>
        </trans-unit>
        <trans-unit id="40783af09b3161aa9f78059481ba68494121fbd9" translate="yes" xml:space="preserve">
          <source>Disabling constraints (i.e. using &lt;code&gt;{ constraints: false }&lt;/code&gt;), since the same foreign key is referencing multiple tables;</source>
          <target state="translated">同じ外部キーが複数のテーブルを参照しているため、 &lt;code&gt;{ constraints: false }&lt;/code&gt; を無効にします（つまり、{制約：false}を使用します）。</target>
        </trans-unit>
        <trans-unit id="e214b8a29923056887b7edf6635d90dcbb2abe88" translate="yes" xml:space="preserve">
          <source>Document</source>
          <target state="translated">Document</target>
        </trans-unit>
        <trans-unit id="9231c89cb4b996a3523d0655172a51ddb9432e20" translate="yes" xml:space="preserve">
          <source>Doing both things</source>
          <target state="translated">両方のことをすること</target>
        </trans-unit>
        <trans-unit id="e7a3976561a537ed64807ce91c39598b4ea5be13" translate="yes" xml:space="preserve">
          <source>Don't forget that the field referenced in the association must have a unique constraint placed on it. Otherwise, an error will be thrown (and sometimes with a mysterious error message - such as &lt;code&gt;SequelizeDatabaseError: SQLITE_ERROR: foreign key mismatch - &quot;ships&quot; referencing &quot;captains&quot;&lt;/code&gt; for SQLite).</source>
          <target state="translated">アソシエーションで参照されるフィールドには、一意の制約が設定されている必要があることを忘れないでください。そうしないと、エラーがスローされます（ &lt;code&gt;SequelizeDatabaseError: SQLITE_ERROR: foreign key mismatch - &quot;ships&quot; referencing &quot;captains&quot;&lt;/code&gt; などの不思議なエラーメッセージが表示されることもあります-SQLiteの「キャプテン」を参照する「ships」）。</target>
        </trans-unit>
        <trans-unit id="045a42e3d77964443cb4a715021f498d78eb3a87" translate="yes" xml:space="preserve">
          <source>Don't persist null values. This means that all columns with null values will not be saved</source>
          <target state="translated">ヌル値を永続化しないでください。これは、ヌル値を持つすべてのカラムが保存されないことを意味します。</target>
        </trans-unit>
        <trans-unit id="e867a88f9e61b1ff73ce33bede301baf6bc1bec2" translate="yes" xml:space="preserve">
          <source>Drop a database</source>
          <target state="translated">データベースのドロップ</target>
        </trans-unit>
        <trans-unit id="51a731fe93dbec2124eb4572b00521e4d18deb78" translate="yes" xml:space="preserve">
          <source>Drop a schema</source>
          <target state="translated">スキーマのドロップ</target>
        </trans-unit>
        <trans-unit id="3e681d45842a1eedfd3f17a772dd0df3ea64a792" translate="yes" xml:space="preserve">
          <source>Drop a single schema</source>
          <target state="translated">単一のスキーマをドロップ</target>
        </trans-unit>
        <trans-unit id="c6285ba1646b4f6c3f7c7ae6df1edc6b758762c3" translate="yes" xml:space="preserve">
          <source>Drop a table from database</source>
          <target state="translated">データベースからテーブルをドロップ</target>
        </trans-unit>
        <trans-unit id="c6e8e4f6389b865ed79529a8c94177f04852e0c5" translate="yes" xml:space="preserve">
          <source>Drop all enums from database (Postgres only)</source>
          <target state="translated">データベースからすべての列挙型を削除(Postgresのみ</target>
        </trans-unit>
        <trans-unit id="71834bb059b7bfe1e00cb32ece9f92a7a2d6864e" translate="yes" xml:space="preserve">
          <source>Drop all schemas</source>
          <target state="translated">すべてのスキーマを削除</target>
        </trans-unit>
        <trans-unit id="4ec4d18ea59b44900db2aee531543d9d0c7bde38" translate="yes" xml:space="preserve">
          <source>Drop all schemas.</source>
          <target state="translated">すべてのスキーマを削除します。</target>
        </trans-unit>
        <trans-unit id="3c9401f0ed6d8ea9f8cfbd099d568a33700aa2fc" translate="yes" xml:space="preserve">
          <source>Drop all tables defined through this sequelize instance.</source>
          <target state="translated">この sequelize インスタンスで定義されたすべてのテーブルを削除します。</target>
        </trans-unit>
        <trans-unit id="0003d1781c25c006028bf3fe4d8def7b340e045c" translate="yes" xml:space="preserve">
          <source>Drop all tables defined through this sequelize instance. This is done by calling Model.drop on each model.</source>
          <target state="translated">この sequelize インスタンスを通して定義されたすべてのテーブルをドロップします。これは、各モデルに対して Model.drop を呼び出すことで行われます。</target>
        </trans-unit>
        <trans-unit id="be5be0af3c0ffa1f406647d9bf5b9aa1a5ab8605" translate="yes" xml:space="preserve">
          <source>Drop all tables from database</source>
          <target state="translated">データベースからすべてのテーブルを削除</target>
        </trans-unit>
        <trans-unit id="39f143b5e8b4911ef525b400f53591d655ba04ad" translate="yes" xml:space="preserve">
          <source>Drop an SQL function</source>
          <target state="translated">SQL関数のドロップ</target>
        </trans-unit>
        <trans-unit id="c3b90df544139ef8dcf1fff4a49dd1a2c0eea688" translate="yes" xml:space="preserve">
          <source>Drop specified enum from database (Postgres only)</source>
          <target state="translated">指定した列挙をデータベースから削除(Postgresのみ</target>
        </trans-unit>
        <trans-unit id="a43aea21fa1ae00928a7e8b8f2fd5d0ffd712f96" translate="yes" xml:space="preserve">
          <source>Drop the table represented by this Model</source>
          <target state="translated">このモデルで表現されたテーブルをドロップします。</target>
        </trans-unit>
        <trans-unit id="796f1eac263f012ff07de56e7e9791b5447b9208" translate="yes" xml:space="preserve">
          <source>Dropping tables</source>
          <target state="translated">テーブルのドロップ</target>
        </trans-unit>
        <trans-unit id="096c9809fdc0538b50d5a68da39154922316935a" translate="yes" xml:space="preserve">
          <source>Dynamic Configuration</source>
          <target state="translated">動的設定</target>
        </trans-unit>
        <trans-unit id="3ca7327a7bd2f5353024f65ee68945fbf10eccf7" translate="yes" xml:space="preserve">
          <source>Dynamic configuration</source>
          <target state="translated">動的設定</target>
        </trans-unit>
        <trans-unit id="507ccbdaf83ab03c2929498330b7d2836e4c06b2" translate="yes" xml:space="preserve">
          <source>ENUM</source>
          <target state="translated">ENUM</target>
        </trans-unit>
        <trans-unit id="38c42767076a41529fd4110de20e3a2bd31c59aa" translate="yes" xml:space="preserve">
          <source>ENUMs</source>
          <target state="translated">ENUMs</target>
        </trans-unit>
        <trans-unit id="4f904a90891673e8467ae5439c5fad8bc4413ccd" translate="yes" xml:space="preserve">
          <source>ENUMs can also be specified with the &lt;code&gt;values&lt;/code&gt; field of the column definition, as follows:</source>
          <target state="translated">ENUMは、次のように、列定義の &lt;code&gt;values&lt;/code&gt; フィールドで指定することもできます。</target>
        </trans-unit>
        <trans-unit id="6a142f6999680571fa05b1a87552e101c1e3b874" translate="yes" xml:space="preserve">
          <source>EXCLUSIVE</source>
          <target state="translated">EXCLUSIVE</target>
        </trans-unit>
        <trans-unit id="cd6fe9d09ea45ac95915d4ba7dcca7c401cc3254" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;write&lt;/code&gt; or &lt;code&gt;useMaster: true&lt;/code&gt; query will use write pool. For &lt;code&gt;SELECT&lt;/code&gt; read pool will be used. Read replica are switched using a basic round robin scheduling.</source>
          <target state="translated">各 &lt;code&gt;write&lt;/code&gt; または &lt;code&gt;useMaster: true&lt;/code&gt; クエリは書き込みプールを使用します。以下のために &lt;code&gt;SELECT&lt;/code&gt; 読み取りプールに使用されます。リードレプリカは、基本的なラウンドロビンスケジューリングを使用して切り替えられます。</target>
        </trans-unit>
        <trans-unit id="9084acde7fe83981db445a5a63fa3f407800b2b0" translate="yes" xml:space="preserve">
          <source>Each argument will be joined by AND</source>
          <target state="translated">各引数は AND で結合されます。</target>
        </trans-unit>
        <trans-unit id="959d2abea6938ee0a35e2a625351c03924a8c888" translate="yes" xml:space="preserve">
          <source>Each argument will be joined by OR</source>
          <target state="translated">各引数は OR で結合されます。</target>
        </trans-unit>
        <trans-unit id="fae80e446045ebe7e57d9510b77e77012bb01de8" translate="yes" xml:space="preserve">
          <source>Eager Loading</source>
          <target state="translated">イーガーローディング</target>
        </trans-unit>
        <trans-unit id="649bb3fa54f741a195405e15046bb061ba0b7495" translate="yes" xml:space="preserve">
          <source>Eager Loading Example</source>
          <target state="translated">イーガーローディングの例</target>
        </trans-unit>
        <trans-unit id="5d3fbbcd2b7be5f32cd21068f876888b53dc6019" translate="yes" xml:space="preserve">
          <source>Eager loading</source>
          <target state="translated">積極的なローディング</target>
        </trans-unit>
        <trans-unit id="e53f14a0716535073a65a5a1de6522af0bc92f55" translate="yes" xml:space="preserve">
          <source>Eager loading filtered at the associated model level</source>
          <target state="translated">関連するモデルレベルでフィルタリングされたイエイガーローディング</target>
        </trans-unit>
        <trans-unit id="364e8c5f90f24bc981383745a7fd6ec338243574" translate="yes" xml:space="preserve">
          <source>Eager loading with Many-to-Many relationships</source>
          <target state="translated">多対多の関係での熱心なロード</target>
        </trans-unit>
        <trans-unit id="d1067a816e9c89b7d14b7d4c7bdcd1275cee9f3b" translate="yes" xml:space="preserve">
          <source>EagerLoadingError</source>
          <target state="translated">EagerLoadingError</target>
        </trans-unit>
        <trans-unit id="4c16ac9ae3d8d30c03296049af23af41a4fa561e" translate="yes" xml:space="preserve">
          <source>Either an object of named bind parameter in the format &lt;code&gt;_param&lt;/code&gt; or an array of unnamed bind parameter to replace &lt;code&gt;$1, $2, ...&lt;/code&gt; in your SQL.</source>
          <target state="translated">&lt;code&gt;_param&lt;/code&gt; 形式の名前付きバインドパラメータのオブジェクトか、SQLの &lt;code&gt;$1, $2, ...&lt;/code&gt; を置き換える名前なしバインドパラメータの配列。</target>
        </trans-unit>
        <trans-unit id="5f6cd42178e8d806c67223411a96ef4333d916f7" translate="yes" xml:space="preserve">
          <source>Either an object of named parameter replacements in the format &lt;code&gt;:param&lt;/code&gt; or an array of unnamed replacements to replace &lt;code&gt;?&lt;/code&gt; in your SQL.</source>
          <target state="translated">&lt;code&gt;:param&lt;/code&gt; 形式の名前付きパラメータ置換のオブジェクト、または置換する名前のない置換の配列のどちら &lt;code&gt;?&lt;/code&gt; あなたのSQLで。</target>
        </trans-unit>
        <trans-unit id="6716cbfae8ed41a517686fff379f0ea8884874cb" translate="yes" xml:space="preserve">
          <source>Either resolving with the resolution of your callback</source>
          <target state="translated">コールバックの解決で解決するか</target>
        </trans-unit>
        <trans-unit id="19bc5da7c3f7cf592be581309fafc0c762c3482c" translate="yes" xml:space="preserve">
          <source>EmptyResultError</source>
          <target state="translated">EmptyResultError</target>
        </trans-unit>
        <trans-unit id="afd06d8a0cebf38e46f8259e0708cdd2d8ce746b" translate="yes" xml:space="preserve">
          <source>Enforcing a foreign key reference without constraints</source>
          <target state="translated">制約なしで外部キー参照を強制する</target>
        </trans-unit>
        <trans-unit id="842967ef82c682a245e4d24b8751810c9fe848b3" translate="yes" xml:space="preserve">
          <source>Enforcing the table name to be equal to the model name</source>
          <target state="translated">テーブル名をモデル名と同じにすることの強制</target>
        </trans-unit>
        <trans-unit id="b8072ec300478b25ddbcab8a4027b6c464f0ce97" translate="yes" xml:space="preserve">
          <source>Engines - MySQL/MariaDB only</source>
          <target state="translated">エンジン-MySQL/MariaDBのみ</target>
        </trans-unit>
        <trans-unit id="761c3fe9c273bc96d11e7783dae3b61f1c7cf28d" translate="yes" xml:space="preserve">
          <source>Enum name to drop</source>
          <target state="translated">ドロップする列挙名</target>
        </trans-unit>
        <trans-unit id="ac4d135647bbefc1f4f8fc228a6cc5bd8fb32d65" translate="yes" xml:space="preserve">
          <source>Escape value.</source>
          <target state="translated">脱出値。</target>
        </trans-unit>
        <trans-unit id="0cacace9bdafc6b8db500eb4594c331013ced5da" translate="yes" xml:space="preserve">
          <source>Even if you simply call &lt;code&gt;findByPk&lt;/code&gt; providing the primary key of a soft-deleted record, the result will be &lt;code&gt;null&lt;/code&gt; as if that record didn't exist.</source>
          <target state="translated">ソフト削除されたレコードの主キーを &lt;code&gt;findByPk&lt;/code&gt; してfindByPkを呼び出すだけでも、そのレコードが存在しないかのように結果は &lt;code&gt;null&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="91ac124a5f6c5daa96e75bbd9c84acfa46132f87" translate="yes" xml:space="preserve">
          <source>Even though it is called a HasOne association, for most 1:1 relations you usually want the BelongsTo association since BelongsTo will add the foreignKey on the source where hasOne will add on the target.</source>
          <target state="translated">HasOneアソシエーションと呼ばれていても、ほとんどの1:1関係では通常BelongsToアソシエーションを使用します。</target>
        </trans-unit>
        <trans-unit id="689de9464c9604ac55af546a692d5b35c30aed44" translate="yes" xml:space="preserve">
          <source>Every column you define in your model must have a data type. Sequelize provides &lt;a href=&quot;https://github.com/sequelize/sequelize/blob/master/lib/data-types.js&quot;&gt;a lot of built-in data types&lt;/a&gt;. To access a built-in data type, you must import &lt;code&gt;DataTypes&lt;/code&gt;:</source>
          <target state="translated">モデルで定義するすべての列には、データ型が必要です。Sequelizeは&lt;a href=&quot;https://github.com/sequelize/sequelize/blob/master/lib/data-types.js&quot;&gt;、多くの組み込みデータ型を提供します&lt;/a&gt;。組み込みのデータ型にアクセスするには、 &lt;code&gt;DataTypes&lt;/code&gt; をインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="30293e7b7fe57cafdfa69e8f2bb2c893ba2c741a" translate="yes" xml:space="preserve">
          <source>Every query performed by Sequelize will automatically ignore soft-deleted records (except raw queries, of course).</source>
          <target state="translated">Sequelize が実行するすべてのクエリは、ソフト削除されたレコードを自動的に無視します (もちろん、生のクエリを除きます)。</target>
        </trans-unit>
        <trans-unit id="f2a5b0ea1ccf863bfa97a8763382a273db3ca14f" translate="yes" xml:space="preserve">
          <source>Everything else is ignored, and if raw is not set, the query will fail</source>
          <target state="translated">それ以外はすべて無視され、rawが設定されていない場合、クエリは失敗します。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="1fabb1683d22d0469c9e9cac437dfd3fa193ab75" translate="yes" xml:space="preserve">
          <source>Example code:</source>
          <target state="translated">コード例。</target>
        </trans-unit>
        <trans-unit id="13825fbbe0e6a04ddd4cc33768ddf9b985e737bb" translate="yes" xml:space="preserve">
          <source>Example of a minimal TypeScript project with strict type-checking for attributes.</source>
          <target state="translated">属性に対して厳格な型チェックを行う最小限の TypeScript プロジェクトの例。</target>
        </trans-unit>
        <trans-unit id="b5b7e6318c218c5d388eb7bcf998f3060d64fb90" translate="yes" xml:space="preserve">
          <source>Example of a minimal TypeScript project:</source>
          <target state="translated">最小限のTypeScriptプロジェクトの例。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="aec767b3ae4b216fc03e8adcc7582fa085418561" translate="yes" xml:space="preserve">
          <source>Examples with &lt;code&gt;Op.and&lt;/code&gt; and &lt;code&gt;Op.or&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Op.and&lt;/code&gt; および &lt;code&gt;Op.or&lt;/code&gt; の例</target>
        </trans-unit>
        <trans-unit id="db8dfa89274dbc41394b75d4fec3ab9092279b3e" translate="yes" xml:space="preserve">
          <source>Examples with &lt;code&gt;Op.not&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Op.not&lt;/code&gt; の例</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="58d18114e1738a1e0f6bfe569a75a8f60da8421d" translate="yes" xml:space="preserve">
          <source>ExclusionConstraintError</source>
          <target state="translated">ExclusionConstraintError</target>
        </trans-unit>
        <trans-unit id="533a4e4878244d5f688d35104f28db89f9340e32" translate="yes" xml:space="preserve">
          <source>Execute a query on the DB, optionally bypassing all the Sequelize goodness.</source>
          <target state="translated">DB へのクエリを実行し、オプションで Sequelize の良さをすべてバイパスします。</target>
        </trans-unit>
        <trans-unit id="aa91c9cca4f6493ac714adff353030085a6edafc" translate="yes" xml:space="preserve">
          <source>Execute a query which would set an environment or user variable.</source>
          <target state="translated">環境変数やユーザ変数を設定するクエリを実行します。</target>
        </trans-unit>
        <trans-unit id="4e26bfe1c237fbd1223d10b2b27a4781c0002328" translate="yes" xml:space="preserve">
          <source>Execute a query which would set an environment or user variable. The variables are set per connection, so this function needs a transaction. Only works for MySQL.</source>
          <target state="translated">環境変数やユーザ変数を設定するクエリを実行します。変数は接続ごとに設定されるので、この関数はトランザクションが必要です。MySQLでのみ動作します。</target>
        </trans-unit>
        <trans-unit id="3213e8faecb3d1137ce38a40c396141714bf3dd0" translate="yes" xml:space="preserve">
          <source>Expansion of models</source>
          <target state="translated">モデルの拡大</target>
        </trans-unit>
        <trans-unit id="4e2991b460fcf70aaefc7f3fc188ddf2588e1620" translate="yes" xml:space="preserve">
          <source>Extending &lt;a href=&quot;../class/lib/model.js~model&quot;&gt;Model&lt;/a&gt;</source>
          <target state="translated">拡張&lt;a href=&quot;../class/lib/model.js~model&quot;&gt;モデル&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8932ac693ed88dde63039fa07540cae01c6e8948" translate="yes" xml:space="preserve">
          <source>Extending &lt;a href=&quot;../class/lib/model.js~model&quot;&gt;Model&lt;/a&gt; and calling &lt;a href=&quot;../class/lib/model.js~model#static-method-init&quot;&gt;&lt;code&gt;init(attributes, options)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../class/lib/model.js~model&quot;&gt;モデルの&lt;/a&gt;拡張と&lt;a href=&quot;../class/lib/model.js~model#static-method-init&quot;&gt; &lt;code&gt;init(attributes, options)&lt;/code&gt; &lt;/a&gt;呼び出し</target>
        </trans-unit>
        <trans-unit id="5593b0456ba26bd844491ca0b003653a8c80940a" translate="yes" xml:space="preserve">
          <source>Extending Data Types</source>
          <target state="translated">データ型の拡張</target>
        </trans-unit>
        <trans-unit id="b8bae6c2f3f966ce80f423eec549a45399974a21" translate="yes" xml:space="preserve">
          <source>Extending datatypes</source>
          <target state="translated">データ型の拡張</target>
        </trans-unit>
        <trans-unit id="ddf3071dc94d26c323c107229af8795c491bd816" translate="yes" xml:space="preserve">
          <source>Extends:</source>
          <target state="translated">Extends:</target>
        </trans-unit>
        <trans-unit id="3415fc8a568de218ad7dba688ff3ef7fbcf8579c" translate="yes" xml:space="preserve">
          <source>Extra-options for creation</source>
          <target state="translated">作成のための追加オプション</target>
        </trans-unit>
        <trans-unit id="cd98ae36981ee80a267c314ec60000c7f9d30870" translate="yes" xml:space="preserve">
          <source>FLOAT</source>
          <target state="translated">FLOAT</target>
        </trans-unit>
        <trans-unit id="cc069309a71a6b082f46a01f71efc1df948b1806" translate="yes" xml:space="preserve">
          <source>FORCE</source>
          <target state="translated">FORCE</target>
        </trans-unit>
        <trans-unit id="314d411c2ac127d528e70955d9b8441f2a15fed9" translate="yes" xml:space="preserve">
          <source>FOREIGN KEY</source>
          <target state="translated">FOREIGN KEY</target>
        </trans-unit>
        <trans-unit id="757a3b8b4ae4f48c692d91a87cc6208288a0a4a6" translate="yes" xml:space="preserve">
          <source>FOREIGNKEYS</source>
          <target state="translated">FOREIGNKEYS</target>
        </trans-unit>
        <trans-unit id="ee0d6b9ce405baeef49e77e5019757177ed1b69d" translate="yes" xml:space="preserve">
          <source>Fetch a Model which is already defined</source>
          <target state="translated">既に定義されているモデルを取得する</target>
        </trans-unit>
        <trans-unit id="65398fb0dd2fcf1ce40900a5da8dce359368d457" translate="yes" xml:space="preserve">
          <source>Fetching a single associated element</source>
          <target state="translated">単一の関連する要素の取得</target>
        </trans-unit>
        <trans-unit id="8d7703328bfc5f3cff64f382e9d46db5014769f3" translate="yes" xml:space="preserve">
          <source>Fetching all associated elements</source>
          <target state="translated">関連するすべての要素の取得</target>
        </trans-unit>
        <trans-unit id="b5ee3df20f5820aae8a0ed53419df5498ce4b0e8" translate="yes" xml:space="preserve">
          <source>Fetching an Aliased association</source>
          <target state="translated">エイリアス化されたアソシエーションの取得</target>
        </trans-unit>
        <trans-unit id="2100fdf8c33fb8e1ebc4e40351da2abba466d896" translate="yes" xml:space="preserve">
          <source>Fetching associations - Eager Loading vs Lazy Loading</source>
          <target state="translated">アソシエーションの取得-熱心な読み込みと怠惰な読み込みの比較</target>
        </trans-unit>
        <trans-unit id="c52b97116b81c0e32f959af4bd49aa15d069dd75" translate="yes" xml:space="preserve">
          <source>Fetching with &lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt; (MySQL, MariaDB, PostgreSQL and MSSQL only)</source>
          <target state="translated">&lt;code&gt;RIGHT OUTER JOIN&lt;/code&gt; を使用したフェッチ（MySQL、MariaDB、PostgreSQL、およびMSSQLのみ）</target>
        </trans-unit>
        <trans-unit id="e8b685271238adf161cffed3c91f54d97023262b" translate="yes" xml:space="preserve">
          <source>Fields</source>
          <target state="translated">Fields</target>
        </trans-unit>
        <trans-unit id="992be6307b48dd72700480b89fd61a9fefdf7604" translate="yes" xml:space="preserve">
          <source>Fields to insert (defaults to all fields)</source>
          <target state="translated">挿入するフィールド (デフォルトはすべてのフィールド)</target>
        </trans-unit>
        <trans-unit id="a218aeefeca1a6f49c3dfa1531a34d49d3fe7b77" translate="yes" xml:space="preserve">
          <source>Fields to update (defaults to all fields)</source>
          <target state="translated">更新するフィールド (デフォルトはすべてのフィールド)</target>
        </trans-unit>
        <trans-unit id="b091566d89ffbcd813c47d6a123565260424f5b8" translate="yes" xml:space="preserve">
          <source>Fields to update if row key already exists (on duplicate key update)? (only supported by MySQL, MariaDB, SQLite &amp;gt;= 3.24.0 &amp;amp; Postgres &amp;gt;= 9.5). By default, all fields are updated.</source>
          <target state="translated">行キーが既に存在する場合に更新するフィールド（重複キーの更新時）？（MySQL、MariaDB、SQLite&amp;gt; = 3.24.0およびPostgres&amp;gt; = 9.5でのみサポートされます）。デフォルトでは、すべてのフィールドが更新されます。</target>
        </trans-unit>
        <trans-unit id="2c3cafa4db3f3e1e51b3dff4303502dbe42b7a89" translate="yes" xml:space="preserve">
          <source>File</source>
          <target state="translated">File</target>
        </trans-unit>
        <trans-unit id="5c762281bad63293636bf5b69b9e20d4a164180b" translate="yes" xml:space="preserve">
          <source>Filter on the join model for belongsToMany relations</source>
          <target state="translated">belongsToManyリレーションの結合モデルにフィルタをかける</target>
        </trans-unit>
        <trans-unit id="5ec9d27d20d87b6665bb72533c95b8633e4a2f14" translate="yes" xml:space="preserve">
          <source>Filter the destroy</source>
          <target state="translated">破壊をフィルタリングします。</target>
        </trans-unit>
        <trans-unit id="2c680ca846d2b1f9941c4a7e463ffdd91bad00da" translate="yes" xml:space="preserve">
          <source>Filter the restore</source>
          <target state="translated">復元のフィルタリング</target>
        </trans-unit>
        <trans-unit id="96e578211aa295317cf257310712fa28ccd8f6c6" translate="yes" xml:space="preserve">
          <source>Filters</source>
          <target state="translated">Filters</target>
        </trans-unit>
        <trans-unit id="399c9c1fc08e2080bf0584c0bb87a998c58302ec" translate="yes" xml:space="preserve">
          <source>Finally you can specify a comment for the table in MySQL and PG</source>
          <target state="translated">最後に、MySQLとPGでテーブルのコメントを指定します。</target>
        </trans-unit>
        <trans-unit id="4fdbfcfb42bceb07d23d06c8e44932b031c62ab5" translate="yes" xml:space="preserve">
          <source>Find a row that matches the query, or build (but don't save) the row if none is found. The successful result of the promise will be (instance, built)</source>
          <target state="translated">クエリにマッチする行を探すか、見つからなかった場合はその行をビルドします(保存はしません)。プロミスの成功した結果は、(インスタンス、ビルドされた)</target>
        </trans-unit>
        <trans-unit id="787ebbba15c03ea377a68ba449b2d1b30838400a" translate="yes" xml:space="preserve">
          <source>Find a row that matches the query, or build and save the row if none is found The successful result of the promise will be (instance, created)</source>
          <target state="translated">クエリにマッチする行を探すか、見つからなかった場合はビルドして保存する プロミスの成功結果は(インスタンス、作成された)になる</target>
        </trans-unit>
        <trans-unit id="950d0b08b16231e46a1ceb42c488b82439475a87" translate="yes" xml:space="preserve">
          <source>Find all the rows matching your query, within a specified offset / limit, and get the total number of rows matching your query.</source>
          <target state="translated">指定されたオフセット/制限内で、クエリに一致するすべての行を検索し、クエリに一致する行の総数を取得します。</target>
        </trans-unit>
        <trans-unit id="657f4ed3571c830a929c71c2d55286283a27633f" translate="yes" xml:space="preserve">
          <source>Find all the rows matching your query, within a specified offset / limit, and get the total number of rows matching your query. This is very useful for paging</source>
          <target state="translated">指定したオフセット/制限内で、クエリに一致するすべての行を検索し、クエリに一致する行の総数を取得します。これは、以下のようなページングに非常に便利です。</target>
        </trans-unit>
        <trans-unit id="921caff04811268180ac8aab2329507d3f93c78c" translate="yes" xml:space="preserve">
          <source>Find the maximum value of field</source>
          <target state="translated">フィールドの最大値を求める</target>
        </trans-unit>
        <trans-unit id="39c1c73d728a68b1db9304ae8005152f31adb33c" translate="yes" xml:space="preserve">
          <source>Find the minimum value of field</source>
          <target state="translated">フィールドの最小値を求める</target>
        </trans-unit>
        <trans-unit id="130ffb115c68fb414d7e62375abe569bf8d4b9e2" translate="yes" xml:space="preserve">
          <source>Find the sum of field</source>
          <target state="translated">フィールドの和を求める</target>
        </trans-unit>
        <trans-unit id="1bd3192591ee5fdc21d4c042f9968ef0194ffbf6" translate="yes" xml:space="preserve">
          <source>Finder methods are intended to query data from the database. They do &lt;em&gt;not&lt;/em&gt; return plain objects but instead return model instances. Because finder methods return model instances you can call any model instance member on the result as described in the documentation for &lt;a href=&quot;instances&quot;&gt;&lt;em&gt;instances&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">Finderメソッドは、データベースからデータを照会することを目的としています。それらはプレーンオブジェクトを返さ&lt;em&gt;ず&lt;/em&gt;、代わりにモデルインスタンスを返します。finderメソッドはモデルインスタンスを返すため、&lt;a href=&quot;instances&quot;&gt;&lt;em&gt;インスタンス&lt;/em&gt;&lt;/a&gt;のドキュメントで説明されているように、結果に対して任意のモデルインスタンスメンバーを呼び出すことができ&lt;em&gt;ます&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="4e45b45f1d2c65530e3cc8c120534ceeb76375af" translate="yes" xml:space="preserve">
          <source>Finder methods are the ones that generate &lt;code&gt;SELECT&lt;/code&gt; queries.</source>
          <target state="translated">Finderメソッドは、 &lt;code&gt;SELECT&lt;/code&gt; クエリを生成するメソッドです。</target>
        </trans-unit>
        <trans-unit id="65c69533dcf5fc1b993572a47469370650252afa" translate="yes" xml:space="preserve">
          <source>First install &lt;code&gt;babel-register&lt;/code&gt;</source>
          <target state="translated">最初に &lt;code&gt;babel-register&lt;/code&gt; をインストールします</target>
        </trans-unit>
        <trans-unit id="ff8bf30d704806b32d8f14071f06c356dd294231" translate="yes" xml:space="preserve">
          <source>First lets look at bulkCreate</source>
          <target state="translated">最初に bulkCreate を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="3691c9e6e1f00c55d7d4476af7872c4024703674" translate="yes" xml:space="preserve">
          <source>First of all you can define a field and the value you want to add to it.</source>
          <target state="translated">まず、フィールドを定義し、そこに追加したい値を定義します。</target>
        </trans-unit>
        <trans-unit id="9df15eba93973048357ed997639f3bef94575508" translate="yes" xml:space="preserve">
          <source>First you need to create a &lt;code&gt;.sequelizerc&lt;/code&gt; file in the root folder of your project. This file should override config path to a &lt;code&gt;JS&lt;/code&gt; file. Like this</source>
          <target state="translated">まず、プロジェクトのルートフォルダーに &lt;code&gt;.sequelizerc&lt;/code&gt; ファイルを作成する必要があります。このファイルは、 &lt;code&gt;JS&lt;/code&gt; ファイルへの構成パスをオーバーライドする必要があります。このような</target>
        </trans-unit>
        <trans-unit id="e73fc561d3cd75f464e29dcb9f3d3539e21bdf74" translate="yes" xml:space="preserve">
          <source>First, a simple example:</source>
          <target state="translated">まず、簡単な例。</target>
        </trans-unit>
        <trans-unit id="cb684fdaf4419e4483a38c7d5835018e360799cd" translate="yes" xml:space="preserve">
          <source>First, recall that the &lt;code&gt;A.belongsTo(B)&lt;/code&gt; association places the foreign key in the &lt;em&gt;source model&lt;/em&gt; (i.e., in &lt;code&gt;A&lt;/code&gt;).</source>
          <target state="translated">まず、 &lt;code&gt;A.belongsTo(B)&lt;/code&gt; アソシエーションが外部キーを&lt;em&gt;ソースモデル&lt;/em&gt;（つまり、 &lt;code&gt;A&lt;/code&gt; ）に配置することを思い出してください。</target>
        </trans-unit>
        <trans-unit id="46f08b9e0ac6ef5cd97661c9841bf33a8056fe1c" translate="yes" xml:space="preserve">
          <source>First, we note that:</source>
          <target state="translated">まず、次のことに注意します。</target>
        </trans-unit>
        <trans-unit id="7397423e15d2a454aac8c89d302ffd28fd522591" translate="yes" xml:space="preserve">
          <source>Fixer</source>
          <target state="translated">Fixer</target>
        </trans-unit>
        <trans-unit id="c50b9d4dbd2a8f882b28d3409c986e48b6b738ed" translate="yes" xml:space="preserve">
          <source>Fixtures / mock data</source>
          <target state="translated">什器・モックデータ</target>
        </trans-unit>
        <trans-unit id="c31adb45dba809469678acd004ba95f1e373a97f" translate="yes" xml:space="preserve">
          <source>Floating point number (4-byte precision).</source>
          <target state="translated">浮動小数点数(4バイト精度)。</target>
        </trans-unit>
        <trans-unit id="1cb6ae00fe9f4d1a554c2b9de7bbb8ed766592e8" translate="yes" xml:space="preserve">
          <source>Floating point number (8-byte precision).</source>
          <target state="translated">浮動小数点数(8バイト精度)。</target>
        </trans-unit>
        <trans-unit id="f9e7ea792fcd904b739bd21e0ab1c77d56b2db44" translate="yes" xml:space="preserve">
          <source>For 1:1 and 1:m associations the default option is &lt;code&gt;SET NULL&lt;/code&gt; for deletion, and &lt;code&gt;CASCADE&lt;/code&gt; for updates. For n:m, the default for both is &lt;code&gt;CASCADE&lt;/code&gt;. This means, that if you delete or update a row from one side of an n:m association, all the rows in the join table referencing that row will also be deleted or updated.</source>
          <target state="translated">1：1と1：mの関連付けの場合、デフォルトのオプションは、削除の場合は &lt;code&gt;SET NULL&lt;/code&gt; 、更新の場合は &lt;code&gt;CASCADE&lt;/code&gt; です。n：mの場合、両方のデフォルトは &lt;code&gt;CASCADE&lt;/code&gt; です。つまり、n：mアソシエーションの片側から行を削除または更新すると、その行を参照する結合テーブルのすべての行も削除または更新されます。</target>
        </trans-unit>
        <trans-unit id="b4ce924ceb57cb52e072969a141cd7fa53753068" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;belongsTo&lt;/code&gt; relationships</source>
          <target state="translated">以下のための &lt;code&gt;belongsTo&lt;/code&gt; のの関係</target>
        </trans-unit>
        <trans-unit id="d4aa04d2f1256558446c461dbe54ae69e0e4f384" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;belongsToMany&lt;/code&gt; relationships</source>
          <target state="translated">用 &lt;code&gt;belongsToMany&lt;/code&gt; の関係</target>
        </trans-unit>
        <trans-unit id="fcdd0af6d51c7d26e47d150496102565721d5679" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;hasOne&lt;/code&gt; and &lt;code&gt;hasMany&lt;/code&gt; relationships</source>
          <target state="translated">以下のため &lt;code&gt;hasOne&lt;/code&gt; や &lt;code&gt;hasMany&lt;/code&gt; の関係</target>
        </trans-unit>
        <trans-unit id="166cef3a04f5801fa60f50c3992929ce02d69679" translate="yes" xml:space="preserve">
          <source>For PostgreSQL, two libraries are needed, &lt;code&gt;pg@^7.0.0&lt;/code&gt; and &lt;code&gt;pg-hstore&lt;/code&gt;. You'll just need to define the dialect:</source>
          <target state="translated">PostgreSQLの場合、 &lt;code&gt;pg-hstore&lt;/code&gt; &lt;code&gt;pg@^7.0.0&lt;/code&gt; とpg-hstoreの 2つのライブラリが必要です。方言を定義する必要があるだけです：</target>
        </trans-unit>
        <trans-unit id="c52bbddae40d76ae399f0d2e8c2c0cce4b5472d1" translate="yes" xml:space="preserve">
          <source>For SQLite compatibility you'll need&lt;code&gt;sqlite3@^4.0.0&lt;/code&gt;. Configure Sequelize like this:</source>
          <target state="translated">SQLiteとの互換性を保つには、 &lt;code&gt;sqlite3@^4.0.0&lt;/code&gt; が必要です。次のようにSequelizeを構成します。</target>
        </trans-unit>
        <trans-unit id="d88898c19f358f3b7b0317837e9a40cbcb901542" translate="yes" xml:space="preserve">
          <source>For UUIDs, use &lt;code&gt;DataTypes.UUID&lt;/code&gt;. It becomes the &lt;code&gt;UUID&lt;/code&gt; data type for PostgreSQL and SQLite, and &lt;code&gt;CHAR(36)&lt;/code&gt; for MySQL. Sequelize can generate UUIDs automatically for these fields, simply use &lt;code&gt;Sequelize.UUIDV1&lt;/code&gt; or &lt;code&gt;Sequelize.UUIDV4&lt;/code&gt; as the default value:</source>
          <target state="translated">UUIDの場合は、 &lt;code&gt;DataTypes.UUID&lt;/code&gt; を使用します。PostgreSQLとSQLiteの場合は &lt;code&gt;UUID&lt;/code&gt; データ型になり、MySQLの場合は &lt;code&gt;CHAR(36)&lt;/code&gt; になります。Sequelizeは、これらのフィールドのUUIDを自動的に生成できます。デフォルト値として、 &lt;code&gt;Sequelize.UUIDV1&lt;/code&gt; または &lt;code&gt;Sequelize.UUIDV4&lt;/code&gt; を使用するだけです。</target>
        </trans-unit>
        <trans-unit id="0316acf2d6bd2d9fbcb4f39ded69d32d41777734" translate="yes" xml:space="preserve">
          <source>For a better understanding of all differences between the inner &lt;code&gt;where&lt;/code&gt; option (used inside an &lt;code&gt;include&lt;/code&gt;), with and without the &lt;code&gt;required&lt;/code&gt; option, and a top-level &lt;code&gt;where&lt;/code&gt; using the &lt;code&gt;$nested.column$&lt;/code&gt; syntax, below we have four examples for you:</source>
          <target state="translated">内側の間のすべての違いをより良く理解するために &lt;code&gt;where&lt;/code&gt; （内部で使用されるオプション &lt;code&gt;include&lt;/code&gt; ）、とない &lt;code&gt;required&lt;/code&gt; オプション、およびトップレベルの使用 &lt;code&gt;$nested.column$&lt;/code&gt; 構文を、私たちはあなたのための4つの例があります下に： &lt;code&gt;where&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89b17a6578e9841e72d6cf1b5bf0dcc1985648f7" translate="yes" xml:space="preserve">
          <source>For a full list of hooks, see &lt;a href=&quot;https://github.com/sequelize/sequelize/blob/master/lib/hooks.js#L7&quot;&gt;Hooks file&lt;/a&gt;.</source>
          <target state="translated">フックの完全なリストについては、&lt;a href=&quot;https://github.com/sequelize/sequelize/blob/master/lib/hooks.js#L7&quot;&gt;フックファイルを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f863120d43b144b6a90ad2ff72b5b590dcb39aa6" translate="yes" xml:space="preserve">
          <source>For a managed transaction: the &lt;code&gt;sequelize.transaction&lt;/code&gt; call will wait for it before settling;</source>
          <target state="translated">管理されたトランザクションの場合： &lt;code&gt;sequelize.transaction&lt;/code&gt; 呼び出しは、解決する前にそれを待ちます。</target>
        </trans-unit>
        <trans-unit id="d5334e3b0517de87f752ed7b20bdac5c27125cfe" translate="yes" xml:space="preserve">
          <source>For an unmanaged transaction: the &lt;code&gt;t.commit&lt;/code&gt; call will wait for it before settling.</source>
          <target state="translated">管理されていないトランザクションの場合： &lt;code&gt;t.commit&lt;/code&gt; 呼び出しは、決済する前にそれを待ちます。</target>
        </trans-unit>
        <trans-unit id="68128f148837e106dfab09a5ab8ecead3a265ea4" translate="yes" xml:space="preserve">
          <source>For better security it is highly advised to use symbol operators from &lt;code&gt;Sequelize.Op&lt;/code&gt; like &lt;code&gt;Op.and&lt;/code&gt; / &lt;code&gt;Op.or&lt;/code&gt; in your code and not depend on any string based operators like &lt;code&gt;$and&lt;/code&gt; / &lt;code&gt;$or&lt;/code&gt; at all. You can limit alias your application will need by setting &lt;code&gt;operatorsAliases&lt;/code&gt; option, remember to sanitize user input especially when you are directly passing them to Sequelize methods.</source>
          <target state="translated">セキュリティを強化するためには、高度から使用シンボル事業者にお勧めし &lt;code&gt;Sequelize.Op&lt;/code&gt; よう &lt;code&gt;Op.and&lt;/code&gt; / &lt;code&gt;Op.or&lt;/code&gt; コード内と同様に、任意の文字列ベースの事業者に依存しない &lt;code&gt;$and&lt;/code&gt; / &lt;code&gt;$or&lt;/code&gt; すべてで。 &lt;code&gt;operatorsAliases&lt;/code&gt; オプションを設定することで、アプリケーションが必要とするエイリアスを制限できます。特に、ユーザー入力をSequelizeメソッドに直接渡す場合は、ユーザー入力を無害化することを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="f16eb1304ddba8f79d3ea2768d2e785579e4c490" translate="yes" xml:space="preserve">
          <source>For brevity, the example only shows a Post model, but in reality Tag would be related to several other models.</source>
          <target state="translated">簡潔にするために、この例では Post モデルのみを示していますが、実際には Tag は他のいくつかのモデルに関連しています。</target>
        </trans-unit>
        <trans-unit id="32403961f9e9492bfe929e9baa09c74ec79b6df4" translate="yes" xml:space="preserve">
          <source>For creating complex counts. Will return multiple rows as needed.</source>
          <target state="translated">複雑なカウントを作成するためのものです。必要に応じて複数の行を返します。</target>
        </trans-unit>
        <trans-unit id="a8793c15ddf5531e9c1c30f2ebb28ddbc00e860d" translate="yes" xml:space="preserve">
          <source>For details see the &lt;a href=&quot;https://github.com/sequelize/cli&quot;&gt;CLI GitHub repository&lt;/a&gt;.</source>
          <target state="translated">詳細については、&lt;a href=&quot;https://github.com/sequelize/cli&quot;&gt;CLIGitHubリポジトリを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="441826693df3e8a3748c8d2e6c8dba411b9548c3" translate="yes" xml:space="preserve">
          <source>For example, consider the models &lt;code&gt;Image&lt;/code&gt;, &lt;code&gt;Video&lt;/code&gt; and &lt;code&gt;Comment&lt;/code&gt;. The first two represent something that a user might post. We want to allow comments to be placed in both of them. This way, we immediately think of establishing the following associations:</source>
          <target state="translated">たとえば、モデル &lt;code&gt;Image&lt;/code&gt; 、 &lt;code&gt;Video&lt;/code&gt; 、 &lt;code&gt;Comment&lt;/code&gt; について考えてみます。最初の2つは、ユーザーが投稿する可能性のあるものを表しています。両方にコメントを付けられるようにしたい。このようにして、私たちはすぐに次の関連付けを確立することを考えます。</target>
        </trans-unit>
        <trans-unit id="a4fb05ef47083533e499e4b461e2d05438aee39e" translate="yes" xml:space="preserve">
          <source>For example, if we have two models, &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt;, and they are associated, their instances will have the following methods/mixins available, depending on the association type:</source>
          <target state="translated">たとえば、 &lt;code&gt;Foo&lt;/code&gt; と &lt;code&gt;Bar&lt;/code&gt; の2つのモデルがあり、それらが関連付けられている場合、それらのインスタンスでは、関連付けのタイプに応じて、次のメソッド/ミックスインを使用できます。</target>
        </trans-unit>
        <trans-unit id="86e4459ee22878d56ce74dfd9d778af78d95dcab" translate="yes" xml:space="preserve">
          <source>For example, in PostgreSQL, the above setup will yield the following SQL upon &lt;code&gt;sync()&lt;/code&gt;:</source>
          <target state="translated">たとえば、PostgreSQLでは、上記の設定により、 &lt;code&gt;sync()&lt;/code&gt; で次のSQLが生成されます。</target>
        </trans-unit>
        <trans-unit id="2ad237277212dade5ad18401931779e6e7044d4e" translate="yes" xml:space="preserve">
          <source>For example, let's say we have the &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; attributes for a User.</source>
          <target state="translated">たとえば、ユーザーの &lt;code&gt;firstName&lt;/code&gt; 属性と &lt;code&gt;lastName&lt;/code&gt; 属性があるとします。</target>
        </trans-unit>
        <trans-unit id="abad332654ea013c8f3d31b41a60315bf5595a0a" translate="yes" xml:space="preserve">
          <source>For example, to configure the &lt;code&gt;ON DELETE&lt;/code&gt; and &lt;code&gt;ON UPDATE&lt;/code&gt; behaviors, you can do:</source>
          <target state="translated">たとえば、 &lt;code&gt;ON DELETE&lt;/code&gt; および &lt;code&gt;ON UPDATE&lt;/code&gt; 動作を構成するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="8568084c5ddc0ae1aa670ce522722f4f796bb953" translate="yes" xml:space="preserve">
          <source>For example, to use &lt;code&gt;UUID&lt;/code&gt; as the foreign key data type instead of the default (&lt;code&gt;INTEGER&lt;/code&gt;), you can simply do:</source>
          <target state="translated">たとえば、デフォルト（ &lt;code&gt;INTEGER&lt;/code&gt; ）の代わりに外部キーデータ型として &lt;code&gt;UUID&lt;/code&gt; を使用するには、次のようにするだけです。</target>
        </trans-unit>
        <trans-unit id="f68fce02aced8e6459f61328bbbaacdf1db3f592" translate="yes" xml:space="preserve">
          <source>For example, we can asynchronously obtain a database password from a rotating token store, and mutate Sequelize's configuration object with the new credentials:</source>
          <target state="translated">例えば、回転するトークンストアからデータベースのパスワードを非同期で取得し、新しい資格情報でSequelizeの設定オブジェクトを変異させることができます。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="fa6c7a73ad90d75d4b39a6f5cf78e6adc6923282" translate="yes" xml:space="preserve">
          <source>For hasOne/belongsTo it's basically the same:</source>
          <target state="translated">hasOne/belongsToについては、基本的には同じです。</target>
        </trans-unit>
        <trans-unit id="d4ded29545acf7b9b521d83a705d06d10cd604b1" translate="yes" xml:space="preserve">
          <source>For managed transactions, use &lt;code&gt;sequelize.transaction(options, callback)&lt;/code&gt;.</source>
          <target state="translated">管理対象トランザクションの場合は、 &lt;code&gt;sequelize.transaction(options, callback)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cab93a06a66637337f33f00e08b1e0a8c44314d" translate="yes" xml:space="preserve">
          <source>For methods that take values, like &lt;code&gt;.create&lt;/code&gt;, &lt;code&gt;.update()&lt;/code&gt;, etc. &lt;code&gt;transaction&lt;/code&gt; should be passed to the option in the second argument.</source>
          <target state="translated">&lt;code&gt;.create&lt;/code&gt; 、 &lt;code&gt;.update()&lt;/code&gt; などの値をとるメソッドの場合、 &lt;code&gt;transaction&lt;/code&gt; を2番目の引数のオプションに渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="31bbe0ca24420147043099fd299663084c1b6bdf" translate="yes" xml:space="preserve">
          <source>For more about &lt;a href=&quot;https://sequelize.org/manual/tutorial/models-definition.html#validations&quot;&gt;Validations&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://sequelize.org/manual/tutorial/models-definition.html#validations&quot;&gt;検証&lt;/a&gt;についての詳細</target>
        </trans-unit>
        <trans-unit id="04db5e8a3c35ba73b4b781f923b1f3cb89bda5c2" translate="yes" xml:space="preserve">
          <source>For starters, let's create an empty file in the root directory of your project.</source>
          <target state="translated">手始めに、プロジェクトのルートディレクトリに空のファイルを作成してみましょう。</target>
        </trans-unit>
        <trans-unit id="8869607afba1c497f7ebf21fbf6107636e23412f" translate="yes" xml:space="preserve">
          <source>For string attributes, use the regular &lt;code&gt;{ where: { attr: something }}&lt;/code&gt; syntax. If you don't want your string to be escaped, use &lt;code&gt;sequelize.literal&lt;/code&gt;.</source>
          <target state="translated">文字列属性の場合は、通常の &lt;code&gt;{ where: { attr: something }}&lt;/code&gt; 構文を使用します。文字列をエスケープしたくない場合は、 &lt;code&gt;sequelize.literal&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="7fdeeb519ef1b18d9836595c51d8d66189bf2e6e" translate="yes" xml:space="preserve">
          <source>For the most part hooks will work the same for instances when being associated except a few things</source>
          <target state="translated">大部分のフックは、いくつかのことを除いて、関連付けられたインスタンスに対しても同じように動作します。</target>
        </trans-unit>
        <trans-unit id="79e50b2785e58d0d5a8108830c47a800c341a17e" translate="yes" xml:space="preserve">
          <source>For the most part hooks will work the same for instances when being associated.</source>
          <target state="translated">ほとんどの場合、フックは関連付けられているときにインスタンスでも同じように動作します。</target>
        </trans-unit>
        <trans-unit id="919452e5c8036321e81f5c9b59a22946dabf84b1" translate="yes" xml:space="preserve">
          <source>For the rest of this example, let's assume that we have two models, &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt;. We want to setup a One-To-One relationship between them such that &lt;code&gt;Bar&lt;/code&gt; gets a &lt;code&gt;fooId&lt;/code&gt; column.</source>
          <target state="translated">この例の残りの部分では、 &lt;code&gt;Foo&lt;/code&gt; と &lt;code&gt;Bar&lt;/code&gt; の2つのモデルがあると仮定します。 &lt;code&gt;Bar&lt;/code&gt; が &lt;code&gt;fooId&lt;/code&gt; 列を取得するように、それらの間に1対1の関係を設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="14286767c7f0bf38401870d4ff77ad551e5ec000" translate="yes" xml:space="preserve">
          <source>For the sake of an example, let's say we are modeling a &lt;code&gt;Post&lt;/code&gt;, whose &lt;code&gt;content&lt;/code&gt; is a text of unlimited length. To improve memory usage, let's say we want to store a gzipped version of the content.</source>
          <target state="translated">例のために、我々はモデリングしているとしましょう &lt;code&gt;Post&lt;/code&gt; 持つ、 &lt;code&gt;content&lt;/code&gt; 無制限の長さのテキストです。メモリ使用量を改善するために、コンテンツのgzip圧縮バージョンを保存するとします。</target>
        </trans-unit>
        <trans-unit id="34429e7d26d5ca90a7dab21b6fa3d746ca222431" translate="yes" xml:space="preserve">
          <source>For this example, we will consider the models &lt;code&gt;Movie&lt;/code&gt; and &lt;code&gt;Actor&lt;/code&gt;. One actor may have participated in many movies, and one movie had many actors involved with its production. The junction table that will keep track of the associations will be called &lt;code&gt;ActorMovies&lt;/code&gt;, which will contain the foreign keys &lt;code&gt;movieId&lt;/code&gt; and &lt;code&gt;actorId&lt;/code&gt;.</source>
          <target state="translated">この例では、モデル &lt;code&gt;Movie&lt;/code&gt; と &lt;code&gt;Actor&lt;/code&gt; を検討します。1人の俳優が多くの映画に参加した可能性があり、1つの映画には多くの俳優が出演していました。アソシエーションを追跡するジャンクションテーブルは &lt;code&gt;ActorMovies&lt;/code&gt; と呼ばれ、外部キー &lt;code&gt;movieId&lt;/code&gt; と &lt;code&gt;actorId&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="f6c8a437c823fae4129407f81b8e5d25e7b9dcc0" translate="yes" xml:space="preserve">
          <source>For this guide, the following setup will be assumed:</source>
          <target state="translated">本ガイドでは、以下の設定を想定しています。</target>
        </trans-unit>
        <trans-unit id="54dd5ce5f0fd79fc38c68155b6bbf4389753112c" translate="yes" xml:space="preserve">
          <source>For this tutorial, the following setup will be assumed:</source>
          <target state="translated">このチュートリアルでは、以下のような設定を想定しています。</target>
        </trans-unit>
        <trans-unit id="a4e6735666cff2a8506e46637e28b3671fcee3e8" translate="yes" xml:space="preserve">
          <source>For unmanaged transactions, just use &lt;code&gt;sequelize.transaction(options)&lt;/code&gt;.</source>
          <target state="translated">管理されていないトランザクションの場合は、 &lt;code&gt;sequelize.transaction(options)&lt;/code&gt; を使用するだけです。</target>
        </trans-unit>
        <trans-unit id="211df75dd2f625308400095e0aa85c4a6e7a1c65" translate="yes" xml:space="preserve">
          <source>Force the query to use the write pool, regardless of the query type.</source>
          <target state="translated">クエリの種類に関係なく、書き込みプールを使用するようにクエリを強制します。</target>
        </trans-unit>
        <trans-unit id="529eee92fed5ed996f9dea4b7c1c951261cb8d07" translate="yes" xml:space="preserve">
          <source>Foreign Key</source>
          <target state="translated">海外キー</target>
        </trans-unit>
        <trans-unit id="2ee372205e15d8140654b1f5e4b497dd3fb87773" translate="yes" xml:space="preserve">
          <source>Foreign Keys</source>
          <target state="translated">海外キー</target>
        </trans-unit>
        <trans-unit id="59ede0e2e22f66178ef87fc65a758931fe2077cc" translate="yes" xml:space="preserve">
          <source>Foreign keys</source>
          <target state="translated">外部キー</target>
        </trans-unit>
        <trans-unit id="69a3add3c0f82c03a04b218b0511f0e66c3405c8" translate="yes" xml:space="preserve">
          <source>ForeignKeyConstraintError</source>
          <target state="translated">ForeignKeyConstraintError</target>
        </trans-unit>
        <trans-unit id="6f778a422d44fa6b44b00f5f10a262af846a058d" translate="yes" xml:space="preserve">
          <source>From class &lt;a href=&quot;../abstract/query-interface.js~queryinterface&quot;&gt;QueryInterface&lt;/a&gt;</source>
          <target state="translated">クラス&lt;a href=&quot;../abstract/query-interface.js~queryinterface&quot;&gt;QueryInterface&lt;/a&gt;から</target>
        </trans-unit>
        <trans-unit id="adf462e2a6ba9ff36e0e6811820bfbb9431fdd79" translate="yes" xml:space="preserve">
          <source>From class &lt;a href=&quot;base.js~association&quot;&gt;Association&lt;/a&gt;</source>
          <target state="translated">クラス&lt;a href=&quot;base.js~association&quot;&gt;協会&lt;/a&gt;から</target>
        </trans-unit>
        <trans-unit id="06ac84914781f4af68d5a72575d216973b6acc03" translate="yes" xml:space="preserve">
          <source>From now on, we will call &lt;code&gt;queryInterface&lt;/code&gt; the singleton instance of the &lt;a href=&quot;../class/lib/dialects/abstract/query-interface.js~queryinterface&quot;&gt;QueryInterface&lt;/a&gt; class, which is available on your Sequelize instance:</source>
          <target state="translated">これから、 &lt;code&gt;queryInterface&lt;/code&gt; を&lt;a href=&quot;../class/lib/dialects/abstract/query-interface.js~queryinterface&quot;&gt;QueryInterface&lt;/a&gt;クラスのシングルトンインスタンスと呼びます。これは、Sequelizeインスタンスで使用できます。</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="250f82c65e6facf5fd4fc074ab87a259cffa3f4b" translate="yes" xml:space="preserve">
          <source>GEOGRAPHY</source>
          <target state="translated">GEOGRAPHY</target>
        </trans-unit>
        <trans-unit id="27efcce7f2dcd678e80237d0773a89dad445555a" translate="yes" xml:space="preserve">
          <source>GEOMETRY</source>
          <target state="translated">GEOMETRY</target>
        </trans-unit>
        <trans-unit id="45c94c6df17fcba36c6473c4cdbbece07a403b16" translate="yes" xml:space="preserve">
          <source>Generated SQL (using MySQL):</source>
          <target state="translated">SQLを生成しました(MySQLを使用)。</target>
        </trans-unit>
        <trans-unit id="b0268be2213733a8c67f7756e7b3c5a710c2eb0e" translate="yes" xml:space="preserve">
          <source>Generated SQL (using PostgreSQL):</source>
          <target state="translated">SQLを生成(PostgreSQLを使用)。</target>
        </trans-unit>
        <trans-unit id="d6cca81b0eb9876cd4909e0d9b57556fc54a4f46" translate="yes" xml:space="preserve">
          <source>Generated SQL (using SQLite):</source>
          <target state="translated">SQLを生成しました(SQLiteを使用)。</target>
        </trans-unit>
        <trans-unit id="dd6234b0fcc953f32ce9e302a8b83f88ef78358f" translate="yes" xml:space="preserve">
          <source>Generated SQL:</source>
          <target state="translated">SQLを生成しました。</target>
        </trans-unit>
        <trans-unit id="7978d028f6cb8150ba230587b87118b98486f723" translate="yes" xml:space="preserve">
          <source>Generated SQLs, in order:</source>
          <target state="translated">生成されたSQLを順番に。</target>
        </trans-unit>
        <trans-unit id="663ae8086b179bf6bacd13c1aa3a3d3e1ff4390c" translate="yes" xml:space="preserve">
          <source>Generated where clause:</source>
          <target state="translated">where句を生成しました。</target>
        </trans-unit>
        <trans-unit id="2e10289922ac926833e39eea42788ac374af6580" translate="yes" xml:space="preserve">
          <source>GeoJSON is accepted as input and returned as output.</source>
          <target state="translated">GeoJSONは入力として受け入れられ、出力として返されます。</target>
        </trans-unit>
        <trans-unit id="72bcf5e76e57548caa290e36d582dfae4d6090a9" translate="yes" xml:space="preserve">
          <source>Get an object representing the query for this instance, use with &lt;code&gt;options.where&lt;/code&gt;</source>
          <target state="translated">このインスタンスのクエリを表すオブジェクトを取得し、 &lt;code&gt;options.where&lt;/code&gt; と共に使用します。</target>
        </trans-unit>
        <trans-unit id="d2fea989c8ec7c43b1340650323a0178a28c6a89" translate="yes" xml:space="preserve">
          <source>Get everything currently associated with this, using an optional where clause.</source>
          <target state="translated">オプションの where 節を使用して、現在これに関連付けられているすべてのものを取得します。</target>
        </trans-unit>
        <trans-unit id="886fde2920a5e02bf2bfd8bcc2bdd26cdd5a5735" translate="yes" xml:space="preserve">
          <source>Get foreign key references details for the table</source>
          <target state="translated">テーブルの外部キー参照の詳細を取得します。</target>
        </trans-unit>
        <trans-unit id="549f6341c48bcf68c253346fa28ed00691fed576" translate="yes" xml:space="preserve">
          <source>Get the associated instance.</source>
          <target state="translated">関連するインスタンスを取得します。</target>
        </trans-unit>
        <trans-unit id="7127a78c21cd3d8c20ee4fb5a952f17c883be460" translate="yes" xml:space="preserve">
          <source>Get the fn for random based on the dialect</source>
          <target state="translated">方言に基づいたランダムのための fn を取得します。</target>
        </trans-unit>
        <trans-unit id="cb52d521a2eae3bd73157d7eff418568485f2f89" translate="yes" xml:space="preserve">
          <source>Get the table name of the model, taking schema into account.</source>
          <target state="translated">スキーマを考慮してモデルのテーブル名を取得します。</target>
        </trans-unit>
        <trans-unit id="d6d9a3a0737e1c044f7f5194ac931cd09c81eeee" translate="yes" xml:space="preserve">
          <source>Get the table name of the model, taking schema into account. The method will return The name as a string if the model has no schema, or an object with &lt;code&gt;tableName&lt;/code&gt;, &lt;code&gt;schema&lt;/code&gt; and &lt;code&gt;delimiter&lt;/code&gt; properties.</source>
          <target state="translated">スキーマを考慮して、モデルのテーブル名を取得します。モデルにスキーマがない場合、または &lt;code&gt;tableName&lt;/code&gt; 、 &lt;code&gt;schema&lt;/code&gt; 、 &lt;code&gt;delimiter&lt;/code&gt; プロパティを持つオブジェクトがある場合、メソッドは名前を文字列として返します。</target>
        </trans-unit>
        <trans-unit id="d4ba2d5d8b010b8e362629cdbb02df41c96a1f90" translate="yes" xml:space="preserve">
          <source>Get the value of the underlying data value</source>
          <target state="translated">基礎となるデータ値の値を取得します。</target>
        </trans-unit>
        <trans-unit id="5063f7dc2abd60e0acc5cda5827c0c6e7683db14" translate="yes" xml:space="preserve">
          <source>Get un-scoped model</source>
          <target state="translated">非スコープモデルを取得します。</target>
        </trans-unit>
        <trans-unit id="9cadae030cb7ca06efe702854aaad1856364fe09" translate="yes" xml:space="preserve">
          <source>Gets all validation error items for the path / field specified.</source>
          <target state="translated">指定されたパス/フィールドのすべての検証エラー項目を取得します。</target>
        </trans-unit>
        <trans-unit id="3bbbe89e1bf4029f9a507d85d668e0d1d5478d40" translate="yes" xml:space="preserve">
          <source>Getters</source>
          <target state="translated">Getters</target>
        </trans-unit>
        <trans-unit id="29b2ed1e86e469631197a2a7932bdfc23e808578" translate="yes" xml:space="preserve">
          <source>Getters &amp;amp; setters</source>
          <target state="translated">ゲッターとセッター</target>
        </trans-unit>
        <trans-unit id="d4d0ee826886f86ab524da8084a390f851f7a730" translate="yes" xml:space="preserve">
          <source>Getters and Setters can be defined in 2 ways (you can mix and match these 2 approaches):</source>
          <target state="translated">ゲッターとセッターは2つの方法で定義することができます(この2つの方法をミックスしてマッチさせることができます)。</target>
        </trans-unit>
        <trans-unit id="4769d31ded30b746f20e3a883096015f17c54108" translate="yes" xml:space="preserve">
          <source>Getters and setters can be both defined in the same field.</source>
          <target state="translated">ゲッターとセッターは同じフィールドで定義することができます。</target>
        </trans-unit>
        <trans-unit id="8e3d68aebc663dc5df0a1d21122f5bf91cffb0ba" translate="yes" xml:space="preserve">
          <source>Getters, Setters &amp;amp; Virtuals</source>
          <target state="translated">ゲッター、セッター、バーチャル</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">はじめに</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">始めるには</target>
        </trans-unit>
        <trans-unit id="8d7da2f2108339b82ee618f582152ef74b008a8f" translate="yes" xml:space="preserve">
          <source>Global / universal hooks</source>
          <target state="translated">グローバル/ユニバーサルフック</target>
        </trans-unit>
        <trans-unit id="98967f63d7b035a44fd97cab8f26d31e767df876" translate="yes" xml:space="preserve">
          <source>Global hooks are hooks which are run for all models. They can define behaviours that you want for all your models, and are especially useful for plugins. They can be defined in two ways, which have slightly different semantics:</source>
          <target state="translated">グローバルフックは、すべてのモデルに対して実行されるフックです。すべてのモデルに対して必要なビヘイビアを定義することができ、特にプラグインに便利です。グローバルフックは2つの方法で定義することができ、それぞれセマンティクスが若干異なります。</target>
        </trans-unit>
        <trans-unit id="9fe00acebc106e4dba1611cdd1d7dc308a244991" translate="yes" xml:space="preserve">
          <source>Goal</source>
          <target state="translated">Goal</target>
        </trans-unit>
        <trans-unit id="2ae6967b07a45b63c8543a6c5e34052414ba32af" translate="yes" xml:space="preserve">
          <source>Grouping</source>
          <target state="translated">Grouping</target>
        </trans-unit>
        <trans-unit id="713a22cbd20899d6556f6445e17e0b0df441a8e4" translate="yes" xml:space="preserve">
          <source>HSTORE</source>
          <target state="translated">HSTORE</target>
        </trans-unit>
        <trans-unit id="a145d9919b1826c52ff91b695b21fed544ff5d43" translate="yes" xml:space="preserve">
          <source>Had we tried to use &lt;code&gt;this.username&lt;/code&gt; in the getter instead, we would have gotten an infinite loop! This is why Sequelize provides the &lt;code&gt;getDataValue&lt;/code&gt; method.</source>
          <target state="translated">代わりにgetterで &lt;code&gt;this.username&lt;/code&gt; を使用しようとすると、無限ループが発生します。これが、Sequelizeが &lt;code&gt;getDataValue&lt;/code&gt; メソッドを提供する理由です。</target>
        </trans-unit>
        <trans-unit id="92789234d7e25be07f8afca4bcff8e4eca67bd7b" translate="yes" xml:space="preserve">
          <source>HasMany</source>
          <target state="translated">HasMany</target>
        </trans-unit>
        <trans-unit id="fc80823e85d5baf1626959c05da1c05516e14b37" translate="yes" xml:space="preserve">
          <source>HasMany / BelongsToMany association</source>
          <target state="translated">HasMany/BelongsToMany アソシエーション</target>
        </trans-unit>
        <trans-unit id="bd0422a6e4667f9fd25c225c8354b9031b11095b" translate="yes" xml:space="preserve">
          <source>HasOne</source>
          <target state="translated">HasOne</target>
        </trans-unit>
        <trans-unit id="75d53992a2aa7a9af9fea66c1bb748cdaad23a04" translate="yes" xml:space="preserve">
          <source>HasOne and BelongsTo insert the association key in different models from each other. HasOne inserts the association key in &lt;strong&gt;target&lt;/strong&gt; model whereas BelongsTo inserts the association key in the &lt;strong&gt;source&lt;/strong&gt; model.</source>
          <target state="translated">HasOneとBelongsToは、互いに異なるモデルに関連付けキーを挿入します。HasOneは関連キーを&lt;strong&gt;ターゲット&lt;/strong&gt;モデルに挿入し、BelongsToは関連キーを&lt;strong&gt;ソース&lt;/strong&gt;モデルに挿入します。</target>
        </trans-unit>
        <trans-unit id="076c84709ba8c75bd1ff3bf1abc6c06bccb66654" translate="yes" xml:space="preserve">
          <source>HasOne associations are associations where the foreign key for the one-to-one relation exists on the &lt;strong&gt;target model&lt;/strong&gt;.</source>
          <target state="translated">HasOne関連付けは、1対1の関係の外部キーが&lt;strong&gt;ターゲットモデルに&lt;/strong&gt;存在する関連付けです。</target>
        </trans-unit>
        <trans-unit id="b8e63ff3de326026e493f5faa78d9c4bb875ad77" translate="yes" xml:space="preserve">
          <source>Hash of data values to create new record with</source>
          <target state="translated">で新しいレコードを作成するためのデータ値のハッシュ</target>
        </trans-unit>
        <trans-unit id="16e57d6cfdb6027ca21e69d2c248bf6d7e1e1e5e" translate="yes" xml:space="preserve">
          <source>Having &lt;strong&gt;Player&lt;/strong&gt; as the &lt;strong&gt;source&lt;/strong&gt; and &lt;strong&gt;Team&lt;/strong&gt; as the &lt;strong&gt;target&lt;/strong&gt;</source>
          <target state="translated">持つ&lt;strong&gt;プレイヤーを&lt;/strong&gt;通り&lt;strong&gt;、ソース&lt;/strong&gt;と&lt;strong&gt;チーム&lt;/strong&gt;として&lt;strong&gt;の目標&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="959db0b3adf835aecd4d86bf6cb2c39e5ee972cd" translate="yes" xml:space="preserve">
          <source>Having &lt;strong&gt;Team&lt;/strong&gt; as the &lt;strong&gt;source&lt;/strong&gt; and &lt;strong&gt;Player&lt;/strong&gt; as the &lt;strong&gt;target&lt;/strong&gt;</source>
          <target state="translated">持つ&lt;strong&gt;チーム&lt;/strong&gt;として&lt;strong&gt;ソース&lt;/strong&gt;や&lt;strong&gt;プレーヤー&lt;/strong&gt;など&lt;strong&gt;のターゲット&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="baf542c6a886f2170e6594b0cd4c2ad52976c234" translate="yes" xml:space="preserve">
          <source>Having options</source>
          <target state="translated">オプションを持つ</target>
        </trans-unit>
        <trans-unit id="8421e2a51a8261b6660fa9c0a9fd6e14eb653c86" translate="yes" xml:space="preserve">
          <source>Helper functions for use inside getter and setter definitions</source>
          <target state="translated">ゲッターやセッターの定義の中で使用するためのヘルパー関数</target>
        </trans-unit>
        <trans-unit id="24c3d9b4e0e40c927afc8e7965f44190f7b0a7ad" translate="yes" xml:space="preserve">
          <source>Helper method to determine if a instance is &quot;soft deleted&quot;.</source>
          <target state="translated">インスタンスが「ソフト削除」されているかどうかを判断するためのヘルパーメソッド。</target>
        </trans-unit>
        <trans-unit id="15900e9e0261074339464c903170431feba6def9" translate="yes" xml:space="preserve">
          <source>Helper method to determine if a instance is &quot;soft deleted&quot;. This is particularly useful if the implementer renamed the &lt;code&gt;deletedAt&lt;/code&gt; attribute to something different. This method requires &lt;code&gt;paranoid&lt;/code&gt; to be enabled.</source>
          <target state="translated">インスタンスが「ソフト削除」されているかどうかを判断するヘルパーメソッド。これは、実装者が &lt;code&gt;deletedAt&lt;/code&gt; 属性の名前を別の名前に変更した場合に特に役立ちます。この方法では、 &lt;code&gt;paranoid&lt;/code&gt; を有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="74b5b0e337605288491d3919c18791d4428323a7" translate="yes" xml:space="preserve">
          <source>Here is an example demonstrating use cases of BelongsTo and HasOne.</source>
          <target state="translated">ここでは、BelongsToとHasOneのユースケースを示す例を示します。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">ここでは一例を紹介します。</target>
        </trans-unit>
        <trans-unit id="c526e01d78df0d88e184c85be4505b4a091ed47f" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;deleted&lt;/code&gt; scope is merged with the finder. If we were to pass &lt;code&gt;where: { firstName: 'john', deleted: false }&lt;/code&gt; to the finder, the &lt;code&gt;deleted&lt;/code&gt; scope would be overwritten.</source>
          <target state="translated">ここで、 &lt;code&gt;deleted&lt;/code&gt; スコープがファインダーとマージされます。 &lt;code&gt;where: { firstName: 'john', deleted: false }&lt;/code&gt; ファインダーに渡すと、 &lt;code&gt;deleted&lt;/code&gt; スコープが上書きされます。</target>
        </trans-unit>
        <trans-unit id="0c3147f35fe7dc89058e9ae58c355036031d0914" translate="yes" xml:space="preserve">
          <source>Here we can see that &lt;code&gt;`comment`.`commentableType` = 'image'&lt;/code&gt; was automatically added to the &lt;code&gt;WHERE&lt;/code&gt; clause of the generated SQL. This is exactly the behavior we want.</source>
          <target state="translated">ここでは、生成されたSQLの &lt;code&gt;WHERE&lt;/code&gt; 句に &lt;code&gt;`comment`.`commentableType` = 'image'&lt;/code&gt; が自動的に追加されたことがわかります。これはまさに私たちが望む振る舞いです。</target>
        </trans-unit>
        <trans-unit id="dfa600773b6369b2ffc2b8f9feb2d7c8dc0d9999" translate="yes" xml:space="preserve">
          <source>Here we can see that &lt;code&gt;`tag_taggable`.`taggableType` = 'image'&lt;/code&gt; was automatically added to the &lt;code&gt;WHERE&lt;/code&gt; clause of the generated SQL. This is exactly the behavior we want.</source>
          <target state="translated">ここでは、生成されたSQLの &lt;code&gt;WHERE&lt;/code&gt; 句に &lt;code&gt;`tag_taggable`.`taggableType` = 'image'&lt;/code&gt; が自動的に追加されたことがわかります。これはまさに私たちが望む振る舞いです。</target>
        </trans-unit>
        <trans-unit id="4c42c0fb8b9ab6f18defe795bd9f6de91b6aca7b" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;tasks[0].user instanceof User&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. This shows that when Sequelize fetches associated models, they are added to the output object as model instances.</source>
          <target state="translated">ここで、 &lt;code&gt;tasks[0].user instanceof User&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; です。これは、Sequelizeが関連するモデルをフェッチすると、それらがモデルインスタンスとして出力オブジェクトに追加されることを示しています。</target>
        </trans-unit>
        <trans-unit id="9afa5e334e28c0ce37c5ef76de0154fcbd75e3db" translate="yes" xml:space="preserve">
          <source>Here, our user model is called &lt;code&gt;user&lt;/code&gt;, with a lowercase u - This means that the property in the object should also be &lt;code&gt;user&lt;/code&gt;. If the name given to &lt;code&gt;sequelize.define&lt;/code&gt; was &lt;code&gt;User&lt;/code&gt;, the key in the object should also be &lt;code&gt;User&lt;/code&gt;. Likewise for &lt;code&gt;addresses&lt;/code&gt;, except it's pluralized being a &lt;code&gt;hasMany&lt;/code&gt; association.</source>
          <target state="translated">ここでは、私たちのユーザーモデルが呼ばれ &lt;code&gt;user&lt;/code&gt; オブジェクトのプロパティでもなければならないことを、この手段- uと小文字で、 &lt;code&gt;user&lt;/code&gt; 。 &lt;code&gt;sequelize.define&lt;/code&gt; に与えられた名前が &lt;code&gt;User&lt;/code&gt; であった場合、オブジェクトのキーも &lt;code&gt;User&lt;/code&gt; である必要があります。同様に、 &lt;code&gt;hasMany&lt;/code&gt; アソシエーションであることを複数形にすることを除いて、 &lt;code&gt;addresses&lt;/code&gt; 場合。</target>
        </trans-unit>
        <trans-unit id="139103af93155175db170f4086701037ce627db7" translate="yes" xml:space="preserve">
          <source>Hierarchies</source>
          <target state="translated">Hierarchies</target>
        </trans-unit>
        <trans-unit id="4c2c702395b304a44afd07f98c51e1749b23060d" translate="yes" xml:space="preserve">
          <source>Historical records / Time travel</source>
          <target state="translated">歴史的記録/タイムトラベル</target>
        </trans-unit>
        <trans-unit id="4bd8f3f03a576b2088bd73a2339d07fca1de805d" translate="yes" xml:space="preserve">
          <source>Hooks</source>
          <target state="translated">Hooks</target>
        </trans-unit>
        <trans-unit id="4212538b69426994af61524680ab6c713fab4826" translate="yes" xml:space="preserve">
          <source>Hooks (also known as lifecycle events), are functions which are called before and after calls in sequelize are executed. For example, if you want to always set a value on a model before saving it, you can add a &lt;code&gt;beforeUpdate&lt;/code&gt; hook.</source>
          <target state="translated">フック（ライフサイクルイベントとも呼ばれます）は、sequelizeの呼び出しが実行される前と後に呼び出される関数です。たとえば、モデルを保存する前に常に値を設定する場合は、 &lt;code&gt;beforeUpdate&lt;/code&gt; フックを追加できます。</target>
        </trans-unit>
        <trans-unit id="16ec897a4973cc950eb026afaf41aeabc7ba5447" translate="yes" xml:space="preserve">
          <source>Hooks and Transactions</source>
          <target state="translated">フックとトランザクション</target>
        </trans-unit>
        <trans-unit id="69e818ce65e0ce8f34803157368c0e226e7e2738" translate="yes" xml:space="preserve">
          <source>Hooks firing order</source>
          <target state="translated">フックの発射順</target>
        </trans-unit>
        <trans-unit id="f00c9b0e6957fcef4079e622b05e8f359ef558dc" translate="yes" xml:space="preserve">
          <source>HostNotFoundError</source>
          <target state="translated">HostNotFoundError</target>
        </trans-unit>
        <trans-unit id="df98405c75e3d2293644f3903f9ba376eecd65dd" translate="yes" xml:space="preserve">
          <source>HostNotReachableError</source>
          <target state="translated">HostNotReachableError</target>
        </trans-unit>
        <trans-unit id="deb41f9eccd872d97cae66101673dc591a3dd320" translate="yes" xml:space="preserve">
          <source>How many rows to delete</source>
          <target state="translated">削除する行数</target>
        </trans-unit>
        <trans-unit id="55c6fc1c78b7f02391f35f14b313aa07ac416870" translate="yes" xml:space="preserve">
          <source>How many rows to undelete (only for mysql)</source>
          <target state="translated">削除を解除するには、どのように多くの行(唯一のmysqlのために</target>
        </trans-unit>
        <trans-unit id="c74419ff22ba551918695ec2d4d452f7e5aafa8c" translate="yes" xml:space="preserve">
          <source>How many rows to update (only for mysql and mariadb, implemented as TOP(n) for MSSQL; for sqlite it is supported only when rowid is present)</source>
          <target state="translated">更新する行数 (mysql と mariadb のみ。MSSQL では TOP(n)として実装され、sqlite では rowid が存在する場合のみサポート)</target>
        </trans-unit>
        <trans-unit id="6ae043fac4f95946de2cb5d70a20b98cbb4b4075" translate="yes" xml:space="preserve">
          <source>How many times a failing query is automatically retried.</source>
          <target state="translated">失敗したクエリが自動的に再試行される回数。</target>
        </trans-unit>
        <trans-unit id="bcd7ff308853d4934c2fcd304af01bbf8af438f7" translate="yes" xml:space="preserve">
          <source>How many times a failing query is automatically retried. Set to 0 to disable retrying on SQL_BUSY error.</source>
          <target state="translated">失敗したクエリを自動的に再試行する回数。0 に設定すると、SQL_BUSY エラー時の再試行を無効にします。</target>
        </trans-unit>
        <trans-unit id="cb9871e1bb1811c7e92e66eae26e9dbdc2227fce" translate="yes" xml:space="preserve">
          <source>However, adding &lt;code&gt;hooks: true&lt;/code&gt; explicitly tells Sequelize that optimization is not of your concern and will perform a &lt;code&gt;SELECT&lt;/code&gt; on the associated objects and destroy each instance one by one in order to be able to call the hooks with the right parameters.</source>
          <target state="translated">ただし、 &lt;code&gt;hooks: true&lt;/code&gt; 追加する：trueは、最適化が問題ではないことをSequelizeに明示的に伝え、関連するオブジェクトに対して &lt;code&gt;SELECT&lt;/code&gt; を実行し、適切なパラメーターでフックを呼び出すことができるように各インスタンスを1つずつ破棄します。</target>
        </trans-unit>
        <trans-unit id="a79c1cb05da0ee8017fa6549ca225f03e874cda9" translate="yes" xml:space="preserve">
          <source>However, adding &lt;code&gt;hooks: true&lt;/code&gt; explicitly tells Sequelize that optimization is not of your concern. Then, Sequelize will first perform a &lt;code&gt;SELECT&lt;/code&gt; on the associated objects and destroy each instance, one by one, in order to be able to properly call the hooks (with the right parameters).</source>
          <target state="translated">ただし、 &lt;code&gt;hooks: true&lt;/code&gt; 追加：trueは、最適化が問題ではないことをSequelizeに明示的に伝えます。次に、Sequelizeは最初に関連するオブジェクトに対して &lt;code&gt;SELECT&lt;/code&gt; を実行し、フックを（適切なパラメーターを使用して）適切に呼び出すことができるように、各インスタンスを1つずつ破棄します。</target>
        </trans-unit>
        <trans-unit id="c0b8790fbcc51501c47abc10ab23a76f589256b5" translate="yes" xml:space="preserve">
          <source>However, by default, &lt;code&gt;bulkCreate&lt;/code&gt; does not run validations on each object that is going to be created (which &lt;code&gt;create&lt;/code&gt; does). To make &lt;code&gt;bulkCreate&lt;/code&gt; run these validations as well, you must pass the &lt;code&gt;validate: true&lt;/code&gt; option. This will decrease performance. Usage example:</source>
          <target state="translated">ただし、デフォルトでは、 &lt;code&gt;bulkCreate&lt;/code&gt; は、作成される予定の各オブジェクトに対して検証を実行しません（ &lt;code&gt;create&lt;/code&gt; は実行します）。作るために &lt;code&gt;bulkCreate&lt;/code&gt; は、同様にこれらの検証を実行して、あなたは合格しなければならない &lt;code&gt;validate: true&lt;/code&gt; オプションを選択します。これにより、パフォーマンスが低下します。使用例：</target>
        </trans-unit>
        <trans-unit id="c58f70dd28133d7c5e6e6a4303ead204cbcfebbe" translate="yes" xml:space="preserve">
          <source>However, defining an alias here has nothing to do with the foreign key names. The names of both foreign keys created in the through table are still constructed by Sequelize based on the name of the models being associated. This can readily be seen by inspecting the generated SQL for the through table in the example above:</source>
          <target state="translated">ただし、ここでエイリアスを定義しても、外部キー名とは何の関係もありません。スルーテーブルに作成された両方の外部キーの名前は、関連付けられたモデルの名前に基づいて Sequelize によって作成されます。このことは、上の例の through テーブルの生成された SQL を調べるとすぐにわかります。</target>
        </trans-unit>
        <trans-unit id="1afd8c120c736b4818f048890cf6b0cb6cbcb4ba" translate="yes" xml:space="preserve">
          <source>However, defining the model by ourselves has several advantages. We can, for example, define more columns on our through table:</source>
          <target state="translated">しかし、自分たちでモデルを定義することにはいくつかの利点があります。例えば、スルーテーブルでより多くのカラムを定義することができます。</target>
        </trans-unit>
        <trans-unit id="c2b8ea142713d4e18b2a52407b042919ba804f65" translate="yes" xml:space="preserve">
          <source>However, if getters and/or setters are defined for &lt;code&gt;field&lt;/code&gt; they will be invoked, instead of returning the value from &lt;code&gt;dataValues&lt;/code&gt;. Accessing properties directly or using &lt;code&gt;get&lt;/code&gt; is preferred for regular use, &lt;code&gt;getDataValue&lt;/code&gt; should only be used for custom getters.</source>
          <target state="translated">ただし、 &lt;code&gt;field&lt;/code&gt; にゲッターやセッターが定義されている場合は、 &lt;code&gt;dataValues&lt;/code&gt; から値を返す代わりに、それらが呼び出されます。プロパティへの直接アクセスまたは &lt;code&gt;get&lt;/code&gt; の使用は通常の使用に &lt;code&gt;getDataValue&lt;/code&gt; ます。getDataValueはカスタムゲッターにのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="d8ad5f5b0cf3bc8e9af3c52f5db3be40f650855b" translate="yes" xml:space="preserve">
          <source>However, if you want only some of the attributes of the through table, you can provide an array with the attributes you want in the &lt;code&gt;attributes&lt;/code&gt; option. For example, if you only want the &lt;code&gt;selfGranted&lt;/code&gt; attribute from the through table:</source>
          <target state="translated">ただし、throughテーブルの属性の一部のみが必要な場合は、 &lt;code&gt;attributes&lt;/code&gt; オプションで必要な属性を配列に指定できます。たとえば、throughテーブルの &lt;code&gt;selfGranted&lt;/code&gt; 属性のみが必要な場合：</target>
        </trans-unit>
        <trans-unit id="3d191358a866703a8af0d57f25666c38b8499366" translate="yes" xml:space="preserve">
          <source>However, please note that whenever you get back a value that is range you will receive:</source>
          <target state="translated">ただし、範囲内の値が返ってきた場合は、必ず返ってくるので注意が必要です。</target>
        </trans-unit>
        <trans-unit id="57ee5980b76ef1fd54e1974afc35c9eaacd378d6" translate="yes" xml:space="preserve">
          <source>However, retrieved range values always come in the form of an array of objects. For example, if the stored value is &lt;code&gt;(&quot;2016-01-01 00:00:00+00:00&quot;, &quot;2016-02-01 00:00:00+00:00&quot;]&lt;/code&gt;, after a finder query you will get:</source>
          <target state="translated">ただし、取得される範囲値は常にオブジェクトの配列の形式で提供されます。たとえば、保存されている値が &lt;code&gt;(&quot;2016-01-01 00:00:00+00:00&quot;, &quot;2016-02-01 00:00:00+00:00&quot;]&lt;/code&gt; 場合、ファインダークエリの後に取得する：</target>
        </trans-unit>
        <trans-unit id="da602e2f959c68339d173000e21a359c7ce8d0f1" translate="yes" xml:space="preserve">
          <source>However, the above would cause Sequelize to create two foreign keys on the &lt;code&gt;Comment&lt;/code&gt; table: &lt;code&gt;ImageId&lt;/code&gt; and &lt;code&gt;VideoId&lt;/code&gt;. This is not ideal because this structure makes it look like a comment can be attached at the same time to one image and one video, which isn't true. Instead, what we really want here is precisely a polymorphic association, in which a &lt;code&gt;Comment&lt;/code&gt; points to a single &lt;strong&gt;Commentable&lt;/strong&gt;, an abstract polymorphic entity that represents one of &lt;code&gt;Image&lt;/code&gt; or &lt;code&gt;Video&lt;/code&gt;.</source>
          <target state="translated">ただし、上記の場合、Sequelizeは &lt;code&gt;Comment&lt;/code&gt; テーブルに &lt;code&gt;ImageId&lt;/code&gt; と &lt;code&gt;VideoId&lt;/code&gt; の2つの外部キーを作成します。この構造では、コメントを1つの画像と1つのビデオに同時に添付できるように見えるため、これは理想的ではありません。これは正しくありません。代わりに、ここで本当に必要なのは、正確にポリモーフィックな関連付けです。この場合、 &lt;code&gt;Comment&lt;/code&gt; は、 &lt;code&gt;Image&lt;/code&gt; または &lt;code&gt;Video&lt;/code&gt; いずれかを表す抽象的なポリモーフィックエンティティである単一の&lt;strong&gt;Commentableを&lt;/strong&gt;指します。</target>
        </trans-unit>
        <trans-unit id="d0b524080e4dd905995f7327b976a6a202e22035" translate="yes" xml:space="preserve">
          <source>However, the code above does not communicate with the database at all (note that it is not even asynchronous)! This is because the &lt;a href=&quot;../class/lib/model.js~model#static-method-build&quot;&gt;&lt;code&gt;build&lt;/code&gt;&lt;/a&gt; method only creates an object that &lt;em&gt;represents&lt;/em&gt; data that &lt;em&gt;can&lt;/em&gt; be mapped to a database. In order to really save (i.e. persist) this instance in the database, the &lt;a href=&quot;../class/lib/model.js~model#instance-method-save&quot;&gt;&lt;code&gt;save&lt;/code&gt;&lt;/a&gt; method should be used:</source>
          <target state="translated">ただし、上記のコードはデータベースとまったく通信しません（非同期ではないことに注意してください）。これは、&lt;a href=&quot;../class/lib/model.js~model#static-method-build&quot;&gt; &lt;code&gt;build&lt;/code&gt; &lt;/a&gt;メソッドがデータベースにマップ&lt;em&gt;できる&lt;/em&gt;データを&lt;em&gt;表す&lt;/em&gt;オブジェクトのみを作成するためです。このインスタンスをデータベースに実際に保存（つまり永続化）するには、&lt;a href=&quot;../class/lib/model.js~model#instance-method-save&quot;&gt; &lt;code&gt;save&lt;/code&gt; &lt;/a&gt;メソッドを使用する必要があります。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="971b6559af147ead7fa90d836302f41e54b0377c" translate="yes" xml:space="preserve">
          <source>However, the code above will result in the following error: &lt;code&gt;Cyclic dependency found. documents is dependent of itself. Dependency chain: documents -&amp;gt; versions =&amp;gt; documents&lt;/code&gt;.</source>
          <target state="translated">ただし、上記のコードでは次のエラーが発生します： &lt;code&gt;Cyclic dependency found. documents is dependent of itself. Dependency chain: documents -&amp;gt; versions =&amp;gt; documents&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08194b4a0443aab1454ff47d2091a04d2c039f36" translate="yes" xml:space="preserve">
          <source>However, unfortunately the code above will result in the following error:</source>
          <target state="translated">しかし、残念ながら上記のコードでは以下のようなエラーになってしまいます。</target>
        </trans-unit>
        <trans-unit id="1830eb27febdc5393b268a7772787a91c205863d" translate="yes" xml:space="preserve">
          <source>However, you can specify which attributes you want fetched. This is done with the &lt;code&gt;attributes&lt;/code&gt; option applied inside the &lt;code&gt;through&lt;/code&gt; option of the include. For example:</source>
          <target state="translated">ただし、フェッチする属性を指定できます。これは、includeの &lt;code&gt;through&lt;/code&gt; オプション内に適用された &lt;code&gt;attributes&lt;/code&gt; オプションを使用して行われます。例えば：</target>
        </trans-unit>
        <trans-unit id="c9226f99dd645a71848cf0585c15059d7de868f4" translate="yes" xml:space="preserve">
          <source>IGNORE</source>
          <target state="translated">IGNORE</target>
        </trans-unit>
        <trans-unit id="8ae3e8381a64e36db57a5344790db89d7de90954" translate="yes" xml:space="preserve">
          <source>IMMEDIATE</source>
          <target state="translated">IMMEDIATE</target>
        </trans-unit>
        <trans-unit id="8f3bb7db433392fa9cd059cb669816e6111bb633" translate="yes" xml:space="preserve">
          <source>INET</source>
          <target state="translated">INET</target>
        </trans-unit>
        <trans-unit id="69c8af3292fb9fef906812e99c9acfa99a66fd97" translate="yes" xml:space="preserve">
          <source>INITIALLY_DEFERRED</source>
          <target state="translated">INITIALLY_DEFERRED</target>
        </trans-unit>
        <trans-unit id="d0a0d37857e35a2dc02ec4fe0c913bf1991b276e" translate="yes" xml:space="preserve">
          <source>INITIALLY_IMMEDIATE</source>
          <target state="translated">INITIALLY_IMMEDIATE</target>
        </trans-unit>
        <trans-unit id="c20ea07e32d25c072a65368c234d6f5a88f4521a" translate="yes" xml:space="preserve">
          <source>INSERT</source>
          <target state="translated">INSERT</target>
        </trans-unit>
        <trans-unit id="0fe37e40e5dab3ac411c2ddca6d21991e811acfa" translate="yes" xml:space="preserve">
          <source>INTEGER</source>
          <target state="translated">INTEGER</target>
        </trans-unit>
        <trans-unit id="06b6ace8ca3f18249e8ba4ea9090c0f34564ce1c" translate="yes" xml:space="preserve">
          <source>Identifier</source>
          <target state="translated">Identifier</target>
        </trans-unit>
        <trans-unit id="1a1bd379d222cf88ec4b5ea4426b87de1dc9cb3d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ individualHooks: true }&lt;/code&gt; was passed to the call, then each individual hook will also run.</source>
          <target state="translated">場合 &lt;code&gt;{ individualHooks: true }&lt;/code&gt; 呼び出しに渡された後、個々のフックも実行されます。</target>
        </trans-unit>
        <trans-unit id="d9fdf457bfc8e4d5000783186983c15ac6bcde12" translate="yes" xml:space="preserve">
          <source>If a particular field of a model is set to not allow null (with &lt;code&gt;allowNull: false&lt;/code&gt;) and that value has been set to &lt;code&gt;null&lt;/code&gt;, all validators will be skipped and a &lt;code&gt;ValidationError&lt;/code&gt; will be thrown.</source>
          <target state="translated">モデルの特定のフィールドがnullを許可しないように設定され（ &lt;code&gt;allowNull: false&lt;/code&gt; ）、その値が &lt;code&gt;null&lt;/code&gt; に設定されている場合、すべてのバリデーターがスキップされ、 &lt;code&gt;ValidationError&lt;/code&gt; がスローされます。</target>
        </trans-unit>
        <trans-unit id="80d19fa71b3b212078b2af9bb47612878b596815" translate="yes" xml:space="preserve">
          <source>If a single default schema per model is needed, set the &lt;code&gt;options.schema='schema'&lt;/code&gt; parameter during the &lt;code&gt;define()&lt;/code&gt; call for the model.</source>
          <target state="translated">モデルごとに単一のデフォルトスキーマが必要な場合は、モデルの &lt;code&gt;define()&lt;/code&gt; 呼び出し中に &lt;code&gt;options.schema='schema'&lt;/code&gt; パラメーターを設定します。</target>
        </trans-unit>
        <trans-unit id="8ec2460c5c0105c3640d21141a54ba2c766998ff" translate="yes" xml:space="preserve">
          <source>If a string is provided, that column is decremented by the value of &lt;code&gt;by&lt;/code&gt; given in options. If an array is provided, the same is true for each column. If and object is provided, each column is decremented by the value given</source>
          <target state="translated">ストリングが提供されている場合、その列は、の値だけデクリメントされる &lt;code&gt;by&lt;/code&gt; オプションで与えられます。配列が提供されている場合、各列について同じことが当てはまります。オブジェクトが指定されている場合、各列は指定された値だけ減分されます</target>
        </trans-unit>
        <trans-unit id="a038ac481096e063842e82236359d80e84de916c" translate="yes" xml:space="preserve">
          <source>If a string is provided, that column is incremented by the value of &lt;code&gt;by&lt;/code&gt; given in options. If an array is provided, the same is true for each column. If and object is provided, each column is incremented by the value given.</source>
          <target state="translated">ストリングが提供されている場合、その列は、の値によってインクリメントされる &lt;code&gt;by&lt;/code&gt; オプションで与えられます。配列が提供されている場合、各列について同じことが当てはまります。オブジェクトが指定されている場合、各列は指定された値だけ増加します。</target>
        </trans-unit>
        <trans-unit id="4a7fcb8b0730043f8516c7419f01b231cdd5e908" translate="yes" xml:space="preserve">
          <source>If a transaction was used, then &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt; will ensure it is used again;</source>
          <target state="translated">トランザクションが使用された場合、 &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt; はそれが再び使用されることを保証します。</target>
        </trans-unit>
        <trans-unit id="15b44897c89a2d595b8b17d6001101f2af7c6a6e" translate="yes" xml:space="preserve">
          <source>If an alias was defined, it will be used instead of the model name to form the method names. For example:</source>
          <target state="translated">エイリアスが定義されている場合は、モデル名の代わりにそれがメソッド名を形成するために使用されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="d3f8b21413ef2d75f353e547b63ad8a094ceae96" translate="yes" xml:space="preserve">
          <source>If an array is passed, &lt;code&gt;$1&lt;/code&gt; is bound to the 1st element in the array (&lt;code&gt;bind[0]&lt;/code&gt;)</source>
          <target state="translated">配列が渡される場合、 &lt;code&gt;$1&lt;/code&gt; は配列の最初の要素に &lt;code&gt;bind[0]&lt;/code&gt; れます（bind [0]）</target>
        </trans-unit>
        <trans-unit id="04ff1e23f5982cac50100dca79c353131b430203" translate="yes" xml:space="preserve">
          <source>If an array is passed, &lt;code&gt;?&lt;/code&gt; will be replaced in the order that they appear in the array</source>
          <target state="translated">配列が渡された場合、 &lt;code&gt;?&lt;/code&gt; 配列に現れる順に置き換えられます</target>
        </trans-unit>
        <trans-unit id="b735a91d7f9b5885397dd1ca50581d91513fcb31" translate="yes" xml:space="preserve">
          <source>If an association is aliased (using the &lt;code&gt;as&lt;/code&gt; option), you must specify this alias when including the model. Instead of passing the model directly to the &lt;code&gt;include&lt;/code&gt; option, you should instead provide an object with two options: &lt;code&gt;model&lt;/code&gt; and &lt;code&gt;as&lt;/code&gt;.</source>
          <target state="translated">アソシエーションがエイリアス化されている場合（ &lt;code&gt;as&lt;/code&gt; オプションを使用）、モデルを含めるときにこのエイリアスを指定する必要があります。モデルを &lt;code&gt;include&lt;/code&gt; オプションに直接渡す代わりに、 &lt;code&gt;model&lt;/code&gt; と &lt;code&gt;as&lt;/code&gt; の2つのオプションをオブジェクトに提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="021622889c30d11d413d8e307364ba9ff4ad40e3" translate="yes" xml:space="preserve">
          <source>If an association is aliased (using the &lt;code&gt;as&lt;/code&gt; option), you must specify this alias when including the model. Notice how the user's &lt;code&gt;Tool&lt;/code&gt;s are aliased as &lt;code&gt;Instruments&lt;/code&gt; above. In order to get that right you have to specify the model you want to load, as well as the alias:</source>
          <target state="translated">（ &lt;code&gt;as&lt;/code&gt; オプションを使用して）関連付けにエイリアスが設定されている場合、モデルを含めるときにこのエイリアスを指定する必要があります。ユーザーの &lt;code&gt;Tool&lt;/code&gt; が上記の &lt;code&gt;Instruments&lt;/code&gt; としてエイリアスされていることに注意してください。これを正しく行うには、ロードするモデルとエイリアスを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="b12bd9871828e99247e957c9b710cebf3aa6b4f6" translate="yes" xml:space="preserve">
          <source>If an attempt is made to set &lt;code&gt;null&lt;/code&gt; to a field that does not allow null, a &lt;code&gt;ValidationError&lt;/code&gt; will be thrown &lt;em&gt;without any SQL query being performed&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; を許可しないフィールドにnullを設定しようとすると&lt;em&gt;、SQLクエリが実行されずに&lt;/em&gt; &lt;code&gt;ValidationError&lt;/code&gt; がスロー&lt;em&gt;され&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="ab4d0ce1426861dbc29aa82ad5a93a5f0a45e8ab" translate="yes" xml:space="preserve">
          <source>If an attribute name of the table contains dots, the resulting objects can become nested objects by setting the &lt;code&gt;nest: true&lt;/code&gt; option. This is achieved with &lt;a href=&quot;https://github.com/mickhansen/dottie.js/&quot;&gt;dottie.js&lt;/a&gt; under the hood. See below:</source>
          <target state="translated">テーブルの属性名にドットが含まれている場合、 &lt;code&gt;nest: true&lt;/code&gt; オプションを設定すると、結果のオブジェクトをネストされたオブジェクトにすることができます。これは、&lt;a href=&quot;https://github.com/mickhansen/dottie.js/&quot;&gt;内部&lt;/a&gt;でdottie.jsを使用して実現されます。下記参照：</target>
        </trans-unit>
        <trans-unit id="c54b915fccb2e4ddf42da3781b85ba11c94eff3f" translate="yes" xml:space="preserve">
          <source>If an attribute name of the table contains dots, the resulting objects will be nested. This is due to the usage of &lt;a href=&quot;https://github.com/mickhansen/dottie.js/&quot;&gt;dottie.js&lt;/a&gt; under the hood. See below:</source>
          <target state="translated">テーブルの属性名にドットが含まれている場合、結果のオブジェクトはネストされます。これは、&lt;a href=&quot;https://github.com/mickhansen/dottie.js/&quot;&gt;内部&lt;/a&gt;ではdottie.jsが使用されているためです。下記参照：</target>
        </trans-unit>
        <trans-unit id="7e8f4a0270879aa34288ff325e1734fc57abfc56" translate="yes" xml:space="preserve">
          <source>If an object is passed, &lt;code&gt;$key&lt;/code&gt; is bound to &lt;code&gt;object['key']&lt;/code&gt;. Each key must begin with a non-numeric char. &lt;code&gt;$1&lt;/code&gt; is not a valid key, even if &lt;code&gt;object['1']&lt;/code&gt; exists.</source>
          <target state="translated">オブジェクトが渡されると、 &lt;code&gt;$key&lt;/code&gt; は &lt;code&gt;object['key']&lt;/code&gt; バインドされます。各キーは、数値以外の文字で始まる必要があります。 &lt;code&gt;$1&lt;/code&gt; &lt;code&gt;object['1']&lt;/code&gt; は、object ['1']が存在する場合でも、有効なキーではありません。</target>
        </trans-unit>
        <trans-unit id="6e127f4ede46c56ba8a869fe2aad272d846c5e9a" translate="yes" xml:space="preserve">
          <source>If an object is passed, &lt;code&gt;:key&lt;/code&gt; will be replaced with the keys from that object. If the object contains keys not found in the query or vice versa, an exception will be thrown.</source>
          <target state="translated">オブジェクトが渡されると、 &lt;code&gt;:key&lt;/code&gt; はそのオブジェクトのキーに置き換えられます。オブジェクトにクエリで見つからないキーが含まれている場合、またはその逆の場合、例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="9304ce1affc25db6aa67ee93e8d468669f898fd5" translate="yes" xml:space="preserve">
          <source>If called with a dot.separated key on a JSON/JSONB attribute it will set the value nested and flag the entire object as changed.</source>
          <target state="translated">JSON/JSONB属性のdot.separatedキーで呼び出された場合、入れ子になった値を設定し、オブジェクト全体に変更のフラグを立てます。</target>
        </trans-unit>
        <trans-unit id="300a90b91f546fafc57ddf54696a6ab280b20fc2" translate="yes" xml:space="preserve">
          <source>If called without a key, returns the previous values for all values which have changed</source>
          <target state="translated">キーなしで呼び出された場合、変更されたすべての値の前の値を返します。</target>
        </trans-unit>
        <trans-unit id="db0b72801ce4daab0ede65373af164330463fbaa" translate="yes" xml:space="preserve">
          <source>If changed is called with a string it will return a boolean indicating whether the value of that key in &lt;code&gt;dataValues&lt;/code&gt; is different from the value in &lt;code&gt;_previousDataValues&lt;/code&gt;.</source>
          <target state="translated">変更は、文字列で呼び出された場合は、内のそのキーの値かどうかを示すブール値を返します &lt;code&gt;dataValues&lt;/code&gt; はの値と異なっている &lt;code&gt;_previousDataValues&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b57e7f29c55e30f10a44c4cebddd8704ddabfd60" translate="yes" xml:space="preserve">
          <source>If changed is called without an argument and no keys have changed, it will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">引数なしでchangedが呼び出され、キーが変更されていない場合、 &lt;code&gt;false&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="cb8a52b4f780a30671fc27031ceae2a7e48b802e" translate="yes" xml:space="preserve">
          <source>If changed is called without an argument, it will return an array of keys that have changed.</source>
          <target state="translated">changed が引数なしで呼ばれた場合は、変更されたキーの配列を返します。</target>
        </trans-unit>
        <trans-unit id="20c37c0197f08cf51e26c1e2044ffa20d35483f5" translate="yes" xml:space="preserve">
          <source>If false do not prepend the query with the search_path (Postgres only)</source>
          <target state="translated">falseの場合、クエリの前にsearch_pathを付加しません。</target>
        </trans-unit>
        <trans-unit id="657ba5fa03244f7aee9eb6c421c8a628fdb8a23e" translate="yes" xml:space="preserve">
          <source>If false, the column will have a NOT NULL constraint, and a not null validation will be run before an instance is saved.</source>
          <target state="translated">falseの場合、カラムはNOT NULL制約を持ち、インスタンスが保存される前にNOT NULL検証が実行されます。</target>
        </trans-unit>
        <trans-unit id="b7040facc6b4350a46a2def78c5b8c73e7bcb1a8" translate="yes" xml:space="preserve">
          <source>If false, validations won't be run.</source>
          <target state="translated">false の場合、バリデーションは実行されません。</target>
        </trans-unit>
        <trans-unit id="44cd1fb91500ac78a5a510a589057a193ab6aa6d" translate="yes" xml:space="preserve">
          <source>If force is true, any existing functions with the same parameters will be replaced. For postgres, this means using &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; instead of &lt;code&gt;CREATE FUNCTION&lt;/code&gt;. Default is false</source>
          <target state="translated">forceがtrueの場合、同じパラメーターを持つ既存の関数は置き換えられます。postgresのために、使用して、この手段は &lt;code&gt;CREATE OR REPLACE FUNCTION&lt;/code&gt; 代わりに &lt;code&gt;CREATE FUNCTION&lt;/code&gt; を。デフォルトはfalseです</target>
        </trans-unit>
        <trans-unit id="6e07f5f6020b14d25df9a8addee707cdd889572f" translate="yes" xml:space="preserve">
          <source>If force is true, each Model will run &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt;, before it tries to create its own table</source>
          <target state="translated">forceがtrueの場合、各モデルは独自のテーブルを作成する前に &lt;code&gt;DROP TABLE IF EXISTS&lt;/code&gt; を実行します</target>
        </trans-unit>
        <trans-unit id="0e59b7682415bc819345577fa12bec6b2f9cba27" translate="yes" xml:space="preserve">
          <source>If freezeTableName is true, sequelize will not try to alter the model name to get the table name. Otherwise, the model name will be pluralized</source>
          <target state="translated">freezeTableName が true の場合、 sequelize はモデル名を変更してテーブル名を取得しようとはしません。そうでなければ、モデル名は複数形になります。</target>
        </trans-unit>
        <trans-unit id="674d7115644f88b378cc58e55b691d817654dfdd" translate="yes" xml:space="preserve">
          <source>If hooks is true then beforeSync, afterSync, beforeBulkSync, afterBulkSync hooks will be called</source>
          <target state="translated">hooks が true の場合、beforeSync、afterSync、beforeBulkSync、afterBulkSync フックが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="2e6f9f406f5bd815e7f824d0bfb0ffc5524dc505" translate="yes" xml:space="preserve">
          <source>If key is given and a field or virtual getter is present for the key it will call that getter - else it will return the value for key.</source>
          <target state="translated">key が与えられ、そのキーに対応するフィールドまたは仮想ゲッターが存在する場合は、そのゲッターを呼び出します-そうでない場合は key の値を返します。</target>
        </trans-unit>
        <trans-unit id="128a3eaafb2aa713f5d89656e1b713c3a3e56e43" translate="yes" xml:space="preserve">
          <source>If no key is given, returns all values of the instance, also invoking virtual getters.</source>
          <target state="translated">キーが与えられていない場合は、インスタンスのすべての値を返します。</target>
        </trans-unit>
        <trans-unit id="894bd939fc9fbd940725facf4300464356fb6a66" translate="yes" xml:space="preserve">
          <source>If no transaction is passed in the &lt;code&gt;options&lt;/code&gt; object, a new transaction will be created internally, to prevent the race condition where a matching row is created by another connection after the find but before the insert call. However, it is not always possible to handle this case in SQLite, specifically if one transaction inserts and another tries to select before the first one has committed. In this case, an instance of sequelize. TimeoutError will be thrown instead. If a transaction is created, a savepoint will be created instead, and any unique constraint violation will be handled internally.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; オブジェクトでトランザクションが渡されない場合、内部で新しいトランザクションが作成され、一致した行が、検索後、挿入呼び出しの前に別​​の接続によって作成されるという競合状態が回避されます。ただし、SQLiteでこのケースを処理できるとは限りません。特に、1つのトランザクションが挿入し、最初のトランザクションがコミットする前に別のトランザクションが選択を試みた場合などです。この場合、sequelizeのインスタンスです。代わりにTimeoutErrorがスローされます。トランザクションが作成されると、代わりにセーブポイントが作成され、一意の制約違反は内部で処理されます。</target>
        </trans-unit>
        <trans-unit id="55f7b072e47da9d3a76ee479789dd9f0b9a7718b" translate="yes" xml:space="preserve">
          <source>If set is called with an object, it will loop over the object, and call set recursively for each key, value pair. If you set raw to true, the underlying dataValues will either be set directly to the object passed, or used to extend dataValues, if dataValues already contain values.</source>
          <target state="translated">set がオブジェクトで呼び出された場合、オブジェクトをループし、各キー、値のペアに対して再帰的に set を呼び出します。rawをtrueに設定した場合、その基礎となるdataValuesは、渡されたオブジェクトに直接設定されるか、dataValuesが既に値を含んでいる場合はdataValuesを拡張するために使用されます。</target>
        </trans-unit>
        <trans-unit id="391fbbeca7f5b84a6e11a9f54c2e0f1487c1d4cc" translate="yes" xml:space="preserve">
          <source>If set to true, destroy will SELECT all records matching the where parameter and will execute before / after destroy hooks on each row</source>
          <target state="translated">trueに設定されている場合、destroyはwhereパラメータにマッチするすべてのレコードをSELECTし、各行のdestroyフックの前後に実行されます。</target>
        </trans-unit>
        <trans-unit id="06b008b34268e778c426cab5ae74a85c1075bda2" translate="yes" xml:space="preserve">
          <source>If set to true, dialects that support it will use TRUNCATE instead of DELETE FROM. If a table is truncated the where and limit options are ignored</source>
          <target state="translated">trueに設定すると、これをサポートする方言は、DELETE FROMの代わりにTRUNCATEを使用します。テーブルが切り詰められている場合、where と limit オプションは無視されます。</target>
        </trans-unit>
        <trans-unit id="38d8c40738b16274aefd629da92a6bb29ab47eb3" translate="yes" xml:space="preserve">
          <source>If set to true, field and virtual setters will be ignored</source>
          <target state="translated">true に設定すると、フィールドと仮想セッターは無視されます。</target>
        </trans-unit>
        <trans-unit id="27b3827a991183e8f28bbcc85806f70fa71c8f62" translate="yes" xml:space="preserve">
          <source>If set to true, included instances will be returned as plain objects</source>
          <target state="translated">true に設定すると、インクルードされたインスタンスはプレーンオブジェクトとして返されます。</target>
        </trans-unit>
        <trans-unit id="eb40b80fd32cf8e71525ff0fe2f8efca5a8f93fe" translate="yes" xml:space="preserve">
          <source>If set to true, paranoid models will actually be deleted</source>
          <target state="translated">trueに設定すると、パラノイドモデルは実際に削除されます。</target>
        </trans-unit>
        <trans-unit id="a720a3ae5cb54b9f1a92c2a8683add3f1fa36c95" translate="yes" xml:space="preserve">
          <source>If set to true, restore will find all records within the where parameter and will execute before / after bulkRestore hooks on each row</source>
          <target state="translated">true に設定すると、where パラメータ内のすべてのレコードを検索し、各行の bulkRestore フックの前後に実行されます。</target>
        </trans-unit>
        <trans-unit id="c3f750e72324e6657c8b56d788253264d692f468" translate="yes" xml:space="preserve">
          <source>If set to true, values will ignore field and virtual setters.</source>
          <target state="translated">true に設定すると、値はフィールドと仮想セッターを無視します。</target>
        </trans-unit>
        <trans-unit id="2a225688455376882530e8dba312211d2bcbc470" translate="yes" xml:space="preserve">
          <source>If set, sequelize will map the attribute name to a different name in the database</source>
          <target state="translated">設定されている場合、 sequelize は属性名をデータベース内の別の名前にマッピングします。</target>
        </trans-unit>
        <trans-unit id="cc207bb584dc6def0a25ec33cd2870eeed91a21b" translate="yes" xml:space="preserve">
          <source>If specified, load the dialect library from this path. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify '/path/to/pg.js' here</source>
          <target state="translated">指定された場合、このパスから方言ライブラリをロードします。例えば、pgデータベースに接続する際にpgの代わりにpg.jsを使用したい場合、ここに'/path/to/pg.js'を指定します。</target>
        </trans-unit>
        <trans-unit id="5220457eb8ff7b1a3c9c11e68260aadf24c052ae" translate="yes" xml:space="preserve">
          <source>If specified, use this dialect library. For example, if you want to use pg.js instead of pg when connecting to a pg database, you should specify 'require(&quot;pg.js&quot;)' here</source>
          <target state="translated">指定された場合は、この方言ライブラリを使用します。例えば、pgデータベースに接続する際にpgの代わりにpg.jsを使用したい場合は、ここに'require(&quot;pg.js&quot;)を指定します。</target>
        </trans-unit>
        <trans-unit id="1dae209bc98d06b2e47281691116b5fbe149490d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;paranoid&lt;/code&gt; options is true, the object will not be deleted, instead the &lt;code&gt;deletedAt&lt;/code&gt; column will be set to the current timestamp. To force the deletion, you can pass &lt;code&gt;force: true&lt;/code&gt; to the destroy call:</source>
          <target state="translated">場合は &lt;code&gt;paranoid&lt;/code&gt; なオプションがtrueの場合、オブジェクトが削除されることはありません、代わりに &lt;code&gt;deletedAt&lt;/code&gt; の列には、現在のタイムスタンプに設定されます。強制的に削除するには、destroy呼び出しに &lt;code&gt;force: true&lt;/code&gt; を渡します。</target>
        </trans-unit>
        <trans-unit id="89216aed70fb8c41aa23d73029989645c25f0d2e" translate="yes" xml:space="preserve">
          <source>If the hook has been called in the process of a transacted operation, this makes sure that your dependent read/write is a part of that same transaction. If the hook is not transacted, you have simply specified &lt;code&gt;{ transaction: null }&lt;/code&gt; and can expect the default behaviour.</source>
          <target state="translated">トランザクション処理の処理中にフックが呼び出された場合、これにより、依存する読み取り/書き込みが同じトランザクションの一部であることを確認できます。フックが処理されない場合は、 &lt;code&gt;{ transaction: null }&lt;/code&gt; を指定しただけで、デフォルトの動作が期待できます。</target>
        </trans-unit>
        <trans-unit id="af05f51d4f3f873d18093ece45324c7ce642b8d4" translate="yes" xml:space="preserve">
          <source>If the only thing being specified about a column is its data type, the syntax can be shortened:</source>
          <target state="translated">カラムについて指定されているのがデータ型だけの場合は、構文を短縮することができます。</target>
        </trans-unit>
        <trans-unit id="2755694b8eb30539d0dbf98759fe01c4187fb45f" translate="yes" xml:space="preserve">
          <source>If this column references another table, provide it here as a Model, or a string</source>
          <target state="translated">この列が他のテーブルを参照している場合は、モデルとして、または文字列としてここに記述します。</target>
        </trans-unit>
        <trans-unit id="1c2890cf339691d4d47faf2398abe6e1b023205e" translate="yes" xml:space="preserve">
          <source>If true a unique key will be generated from the foreign keys used (might want to turn this off and create specific unique keys when using scopes)</source>
          <target state="translated">true にすると、使用した外部キーから一意のキーが生成されます (スコープを使用する際には、この機能をオフにして特定の一意のキーを作成したい場合もあるでしょう)。</target>
        </trans-unit>
        <trans-unit id="2856a473591152d31ef4a0266e32a8671fc7732b" translate="yes" xml:space="preserve">
          <source>If true, append RETURNING &amp;lt;model columns&amp;gt; to get back all defined values; if an array of column names, append RETURNING &amp;lt;columns&amp;gt; to get back specific columns (Postgres only)</source>
          <target state="translated">trueの場合、RETURNING &amp;lt;モデル列&amp;gt;を追加して、定義されたすべての値を取得します。列名の配列の場合、RETURNING &amp;lt;columns&amp;gt;を追加して特定の列を取得します（Postgresのみ）</target>
        </trans-unit>
        <trans-unit id="ac32e94080083f62fd15d534737523a9a47f0b0e" translate="yes" xml:space="preserve">
          <source>If true, combined with autoIncrement=true, will use Postgres &lt;code&gt;GENERATED BY DEFAULT AS IDENTITY&lt;/code&gt; instead of &lt;code&gt;SERIAL&lt;/code&gt;. Postgres 10+ only.</source>
          <target state="translated">trueの場合、autoIncrement = trueと組み合わせると、 &lt;code&gt;SERIAL&lt;/code&gt; ではなくPostgres &lt;code&gt;GENERATED BY DEFAULT AS IDENTITY&lt;/code&gt; が使用されます。Postgres 10+のみ。</target>
        </trans-unit>
        <trans-unit id="4df84c739c5fec04cd33156cf8d026bf97b1a13f" translate="yes" xml:space="preserve">
          <source>If true, converts to a right join if dialect support it. Ignored if &lt;code&gt;include.required&lt;/code&gt; is true.</source>
          <target state="translated">trueの場合、方言でサポートされていれば、右結合に変換されます。 &lt;code&gt;include.required&lt;/code&gt; がtrueの場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="3e0dc1c538227d7485952dc6d28c4c1abd9d5955" translate="yes" xml:space="preserve">
          <source>If true, converts to an inner join, which means that the parent model will only be loaded if it has any matching children. True if &lt;code&gt;include.where&lt;/code&gt; is set, false otherwise.</source>
          <target state="translated">trueの場合、内部結合に変換されます。つまり、親モデルは、一致する子がある場合にのみロードされます。 &lt;code&gt;include.where&lt;/code&gt; が設定されている場合はtrue 、それ以外の場合はfalse。</target>
        </trans-unit>
        <trans-unit id="176de8bd8d7d1119cf88871eae854266afc7f65d" translate="yes" xml:space="preserve">
          <source>If true, fetches back auto generated values</source>
          <target state="translated">true の場合、自動生成された値をフェッチバックします。</target>
        </trans-unit>
        <trans-unit id="81d2e26a6f45fb983320c358ee03e36d4177246b" translate="yes" xml:space="preserve">
          <source>If true, fetches back auto generated values (Postgres only)</source>
          <target state="translated">trueの場合、自動生成された値を取得します(Postgresのみ)。</target>
        </trans-unit>
        <trans-unit id="27bb8c3ebbed206d133e37533e84b395c0c9105c" translate="yes" xml:space="preserve">
          <source>If true, only non-deleted records will be returned from the join table. If false, both deleted and non-deleted records will be returned. Only applies if through model is paranoid</source>
          <target state="translated">trueの場合、削除されていないレコードのみが結合テーブルから返されます。falseの場合、削除されたレコードと削除されていないレコードの両方が返されます。スルーモデルが偏執的な場合にのみ適用されます。</target>
        </trans-unit>
        <trans-unit id="9493e0278e049ef4ff4652a3baff31d06e297e09" translate="yes" xml:space="preserve">
          <source>If true, only non-deleted records will be returned. If false, both deleted and non-deleted records will be returned. Only applies if &lt;code&gt;options.paranoid&lt;/code&gt; is true for the model.</source>
          <target state="translated">trueの場合、削除されていないレコードのみが返されます。falseの場合、削除されたレコードと削除されていないレコードの両方が返されます。 &lt;code&gt;options.paranoid&lt;/code&gt; がモデルに対してtrueの場合にのみ適用されます。</target>
        </trans-unit>
        <trans-unit id="8ce8f96e01d05bf135e8ac150e4e97d603a39cd8" translate="yes" xml:space="preserve">
          <source>If true, only non-deleted records will be updated. If false, both deleted and non-deleted records will be updated. Only applies if &lt;code&gt;options.paranoid&lt;/code&gt; is true for the model.</source>
          <target state="translated">trueの場合、削除されていないレコードのみが更新されます。falseの場合、削除されたレコードと削除されていないレコードの両方が更新されます。 &lt;code&gt;options.paranoid&lt;/code&gt; がモデルに対してtrueの場合にのみ適用されます。</target>
        </trans-unit>
        <trans-unit id="e6c3614407ad68627e43871b206c08231a35fcb2" translate="yes" xml:space="preserve">
          <source>If true, runs a separate query to fetch the associated instances, only supported for hasMany associations</source>
          <target state="translated">true の場合、関連付けられたインスタンスを取得するための別のクエリを実行します。</target>
        </trans-unit>
        <trans-unit id="647d7c653d76bc8224e8446161299293bf7a8229" translate="yes" xml:space="preserve">
          <source>If true, sequelize will not try to format the results of the query, or build an instance of a model from the result</source>
          <target state="translated">true の場合、 sequelize はクエリの結果をフォーマットしようとせず、結果からモデルのインスタンスを構築しようともしません。</target>
        </trans-unit>
        <trans-unit id="0ba0bbc2d0ad37b59e2f4202a1fa65789943978b" translate="yes" xml:space="preserve">
          <source>If true, the column will get a unique constraint. If a string is provided, the column will be part of a composite unique index. If multiple columns have the same string, they will be part of the same unique index</source>
          <target state="translated">true の場合、列は一意の制約を取得します。文字列が与えられた場合、そのカラムは複合ユニークインデックスの一部となります。複数のカラムが同じ文字列を持つ場合、それらは同じ一意インデックスの一部となります。</target>
        </trans-unit>
        <trans-unit id="beb79f16ad3fb0f8cdb6f793480ca423b3cb5429" translate="yes" xml:space="preserve">
          <source>If true, the updatedAt timestamp will not be updated.</source>
          <target state="translated">true の場合、updatedAt タイムスタンプは更新されません。</target>
        </trans-unit>
        <trans-unit id="d05e957cd328c4b4ff8ea91a8a38cc0b12d2f924" translate="yes" xml:space="preserve">
          <source>If true, this attribute will be marked as primary key</source>
          <target state="translated">true の場合、この属性は主キーとしてマークされます。</target>
        </trans-unit>
        <trans-unit id="08f9a9c95786ae05c26d607345400a2e23ad1516" translate="yes" xml:space="preserve">
          <source>If true, this column will be set to auto increment</source>
          <target state="translated">true の場合、この列は自動インクリメントに設定されます。</target>
        </trans-unit>
        <trans-unit id="75c4ea047705366df87e56ce4937449851e86344" translate="yes" xml:space="preserve">
          <source>If true, transforms objects with &lt;code&gt;.&lt;/code&gt; separated property names into nested objects using &lt;a href=&quot;https://github.com/mickhansen/dottie.js&quot;&gt;dottie.js&lt;/a&gt;. For example { 'user.username': 'john' } becomes { user: { username: 'john' }}. When &lt;code&gt;nest&lt;/code&gt; is true, the query type is assumed to be &lt;code&gt;'SELECT'&lt;/code&gt;, unless otherwise specified</source>
          <target state="translated">trueの場合、でオブジェクトを変換します &lt;code&gt;.&lt;/code&gt; &lt;a href=&quot;https://github.com/mickhansen/dottie.js&quot;&gt;dottie.js&lt;/a&gt;を使用して、プロパティ名をネストされたオブジェクトに分離しました。たとえば、{'user.username'： 'john'}は{user：{username： 'john'}}になります。ときに &lt;code&gt;nest&lt;/code&gt; 真である、クエリの種類があると仮定される &lt;code&gt;'SELECT'&lt;/code&gt; 特に指定がない限り、</target>
        </trans-unit>
        <trans-unit id="2b3c88711448952fca0e35149a0cbc1a827d0bfb" translate="yes" xml:space="preserve">
          <source>If unsure, refer to the API documentation for the method you are using to be sure of the signature.</source>
          <target state="translated">不明な場合は、使用しているメソッドの API ドキュメントを参照して署名を確認してください。</target>
        </trans-unit>
        <trans-unit id="32198f81d975b55d40ec70c7e2308553a94edcba" translate="yes" xml:space="preserve">
          <source>If validation fails, the promise is rejected with an array-like &lt;a href=&quot;http://bluebirdjs.com/docs/api/aggregateerror.html&quot;&gt;AggregateError&lt;/a&gt;</source>
          <target state="translated">検証が失敗した場合、配列のような&lt;a href=&quot;http://bluebirdjs.com/docs/api/aggregateerror.html&quot;&gt;AggregateErrorで&lt;/a&gt;プロミスが拒否されます</target>
        </trans-unit>
        <trans-unit id="32774c05c02ed991fc187042bf3598ef5a7a71e7" translate="yes" xml:space="preserve">
          <source>If validation fails, the promise is rejected with an array-like AggregateError</source>
          <target state="translated">検証に失敗した場合、プロミスは配列のような AggregateError で拒否されます。</target>
        </trans-unit>
        <trans-unit id="b68dbaff22b4a8b9e63dcda5fe1c9794aeaa88b0" translate="yes" xml:space="preserve">
          <source>If we define the pair as recommended, i.e., both &lt;code&gt;Foo.hasOne(Bar)&lt;/code&gt; and &lt;code&gt;Bar.belongsTo(Foo)&lt;/code&gt;:</source>
          <target state="translated">ペアを推奨として定義すると、つまり、 &lt;code&gt;Foo.hasOne(Bar)&lt;/code&gt; と &lt;code&gt;Bar.belongsTo(Foo)&lt;/code&gt; の両方が：</target>
        </trans-unit>
        <trans-unit id="513b8800efbf168878b3b3a1edc4baee864640f1" translate="yes" xml:space="preserve">
          <source>If we do not define the pair of associations, calling for example just &lt;code&gt;Foo.hasOne(Bar)&lt;/code&gt;:</source>
          <target state="translated">アソシエーションのペアを定義しない場合、たとえば &lt;code&gt;Foo.hasOne(Bar)&lt;/code&gt; だけを呼び出します。</target>
        </trans-unit>
        <trans-unit id="0186aab835641bad03f7589f88e576215349c709" translate="yes" xml:space="preserve">
          <source>If we had not included the transaction option in our call to &lt;code&gt;User.update&lt;/code&gt; in the preceding code, no change would have occurred, since our newly created user does not exist in the database until the pending transaction has been committed.</source>
          <target state="translated">上記のコードの &lt;code&gt;User.update&lt;/code&gt; への呼び出しにトランザクションオプションを含めなかった場合、保留中のトランザクションがコミットされるまで、新しく作成したユーザーはデータベースに存在しないため、変更は行われません。</target>
        </trans-unit>
        <trans-unit id="90a638bf427dff29f6667e845137fe18594f70ef" translate="yes" xml:space="preserve">
          <source>If we run the above raw SQL query through Sequelize, we get:</source>
          <target state="translated">上記の生の SQL クエリを Sequelize で実行すると、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="ffa3cd7e82aaa3f83dc8bf178240b35d168ceca2" translate="yes" xml:space="preserve">
          <source>If we wanted to involve another field from our model instance in the computation, that is possible and very easy!</source>
          <target state="translated">モデルのインスタンスから別のフィールドを計算に含めたい場合は、それが可能で非常に簡単です。</target>
        </trans-unit>
        <trans-unit id="af86f00788413950c29544cb321c3012b536084e" translate="yes" xml:space="preserve">
          <source>If you are accepting values directly from the user, it might be beneficial to limit the columns that you want to actually insert. To support this, &lt;code&gt;bulkCreate()&lt;/code&gt; accepts a &lt;code&gt;fields&lt;/code&gt; option, an array defining which fields must be considered (the rest will be ignored).</source>
          <target state="translated">ユーザーから直接値を受け入れる場合は、実際に挿入する列を制限すると便利な場合があります。これをサポートするために、 &lt;code&gt;bulkCreate()&lt;/code&gt; は &lt;code&gt;fields&lt;/code&gt; オプションを受け入れます。これは、考慮する必要のあるフィールドを定義する配列です（残りは無視されます）。</target>
        </trans-unit>
        <trans-unit id="bb6b5c50fe4ab3f465e27baa8bc48b315568f529" translate="yes" xml:space="preserve">
          <source>If you are accepting values directly from the user, it might be beneficial to limit the columns that you want to actually insert.&lt;code&gt;bulkCreate()&lt;/code&gt;accepts an options object as the second parameter. The object can have a &lt;code&gt;fields&lt;/code&gt; parameter, (an array) to let it know which fields you want to build explicitly</source>
          <target state="translated">ユーザーから直接値を受け入れる場合は、実際に挿入する列を制限すると効果的です。 &lt;code&gt;bulkCreate()&lt;/code&gt; は、2番目のパラメーターとしてオプションオブジェクトを受け入れます。オブジェクトは、明示的に構築したいフィールドを知らせるために、 &lt;code&gt;fields&lt;/code&gt; パラメータ（配列）を持つことができます</target>
        </trans-unit>
        <trans-unit id="5ac8d819fedae82d2ebf0ab77182ee9f429b9d81" translate="yes" xml:space="preserve">
          <source>If you are running a type of query where you don't need the metadata, for example a &lt;code&gt;SELECT&lt;/code&gt; query, you can pass in a query type to make sequelize format the results:</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; クエリなど、メタデータを必要としないタイプのクエリを実行している場合は、クエリタイプを渡して、結果を逐次化形式にすることができます。</target>
        </trans-unit>
        <trans-unit id="e0bc79231b8537df5d0e0f52b040b420676268d0" translate="yes" xml:space="preserve">
          <source>If you are starting a project from scratch, and your database does not exist yet, Sequelize can be used since the beginning in order to automate the creation of every table in your database.</source>
          <target state="translated">ゼロからプロジェクトを開始していて、データベースがまだ存在しない場合は、データベース内のすべてのテーブルの作成を自動化するために、最初からSequelizeを使用することができます。</target>
        </trans-unit>
        <trans-unit id="472f4053e4c19200204ff390506f183cb62d92a5" translate="yes" xml:space="preserve">
          <source>If you are using mixins (such as &lt;code&gt;user.getProfiles()&lt;/code&gt;) instead of finder methods (such as &lt;code&gt;User.findAll()&lt;/code&gt;), you have to use the &lt;code&gt;joinTableAttributes&lt;/code&gt; option instead:</source>
          <target state="translated">ファインダーメソッド（ &lt;code&gt;User.findAll()&lt;/code&gt; など）の代わりにミックスイン（ &lt;code&gt;user.getProfiles()&lt;/code&gt; など）を使用して &lt;code&gt;joinTableAttributes&lt;/code&gt; 場合は、代わりにjoinTableAttributesオプションを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="7c6b8f104ce1867c4fbb58c79efc25e166a19332" translate="yes" xml:space="preserve">
          <source>If you are working with the PostgreSQL &lt;code&gt;TIMESTAMP WITHOUT TIME ZONE&lt;/code&gt; and you need to parse it to a different timezone, please use the pg library's own parser:</source>
          <target state="translated">&lt;code&gt;TIMESTAMP WITHOUT TIME ZONE&lt;/code&gt; PostgreSQLタイムスタンプを使用していて、別のタイムゾーンに解析する必要がある場合は、pgライブラリの独自のパーサーを使用してください。</target>
        </trans-unit>
        <trans-unit id="c6462f72311ba7a8cddf624ea0257e29162d1f7f" translate="yes" xml:space="preserve">
          <source>If you are working with the PostgreSQL TIMESTAMP WITHOUT TIME ZONE and you need to parse it to a different timezone, please use the pg library's own parser:</source>
          <target state="translated">PostgreSQL TIMESTAMP WITHOUT TIME ZONEを使用していて、異なるタイムゾーンに解析する必要がある場合は、pgライブラリ独自のパーサを使用してください。</target>
        </trans-unit>
        <trans-unit id="7ee60dd14251d97d9e80017ad46aa8d2aedf7b51" translate="yes" xml:space="preserve">
          <source>If you change the value of some field of an instance, calling &lt;code&gt;save&lt;/code&gt; again will update it accordingly:</source>
          <target state="translated">インスタンスの一部のフィールドの値を変更した場合、 &lt;code&gt;save&lt;/code&gt; を再度呼び出すと、それに応じて更新されます。</target>
        </trans-unit>
        <trans-unit id="74ddcd65a25eb03b0ad2ef462e8d2c98a3998a61" translate="yes" xml:space="preserve">
          <source>If you do not want timestamps on your models, only want some timestamps, or you are working with an existing database where the columns are named something else, jump straight on to &lt;a href=&quot;models-definition#configuration&quot;&gt;configuration&lt;/a&gt; to see how to do that.</source>
          <target state="translated">モデルにタイムスタンプが必要ない場合、一部のタイムスタンプのみが必要な場合、または列に別の名前が付けられている既存のデータベースを使用している場合は、&lt;a href=&quot;models-definition#configuration&quot;&gt;構成&lt;/a&gt;に直接移動して、その方法を確認してください。</target>
        </trans-unit>
        <trans-unit id="82afc94c4a024c4ee379a3bc5b66fcd1dff91707" translate="yes" xml:space="preserve">
          <source>If you don't want anything from the junction table, you can explicitly provide an empty array to the &lt;code&gt;attributes&lt;/code&gt; option, and in this case nothing will be fetched and the extra property will not even be created:</source>
          <target state="translated">ジャンクションテーブルから何も必要ない場合は、 &lt;code&gt;attributes&lt;/code&gt; オプションに空の配列を明示的に指定できます。この場合、何もフェッチされず、追加のプロパティも作成されません。</target>
        </trans-unit>
        <trans-unit id="b70b7dfc0286abead1f89aa2eb01dca13de6982b" translate="yes" xml:space="preserve">
          <source>If you don't want the nested &lt;code&gt;grant&lt;/code&gt; field at all, use &lt;code&gt;attributes: []&lt;/code&gt;:</source>
          <target state="translated">ネストされた &lt;code&gt;grant&lt;/code&gt; フィールドがまったく必要ない場合は、 &lt;code&gt;attributes: []&lt;/code&gt; 使用します：[]：</target>
        </trans-unit>
        <trans-unit id="f3c5e7d03c6a36a4f0cced22fb56e3a7206de7ed" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;https://github.com/Jeff-Lewis/cls-hooked&quot;&gt;CLS&lt;/a&gt; enabled, the transaction will automatically be passed to any query that runs within the callback</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Jeff-Lewis/cls-hooked&quot;&gt;CLSを&lt;/a&gt;有効にしている場合、トランザクションはコールバック内で実行されるクエリに自動的に渡されます</target>
        </trans-unit>
        <trans-unit id="89ecba0f6c4969c1946f16a7277505b83b58a142" translate="yes" xml:space="preserve">
          <source>If you have any general settings that apply to all replicas you do not need to provide them for each instance. In the code above, database name and port is propagated to all replicas. The same will happen for user and password, if you leave them out for any of the replicas. Each replica has the following options:&lt;code&gt;host&lt;/code&gt;,&lt;code&gt;port&lt;/code&gt;,&lt;code&gt;username&lt;/code&gt;,&lt;code&gt;password&lt;/code&gt;,&lt;code&gt;database&lt;/code&gt;.</source>
          <target state="translated">すべてのレプリカに適用される一般的な設定がある場合、インスタンスごとにそれらを提供する必要はありません。上記のコードでは、データベース名とポートがすべてのレプリカに伝達されます。レプリカのいずれかを省略した場合、ユーザーとパスワードについても同じことが起こります。各レプリカには、 &lt;code&gt;host&lt;/code&gt; 、 &lt;code&gt;port&lt;/code&gt; 、 &lt;code&gt;username&lt;/code&gt; 、 &lt;code&gt;password&lt;/code&gt; 、 &lt;code&gt;database&lt;/code&gt; オプションがあります。</target>
        </trans-unit>
        <trans-unit id="9bb5e89572ab05d67a9192d69c8e80c0b0d84ee4" translate="yes" xml:space="preserve">
          <source>If you have soft-deleted an instance of a model with &lt;code&gt;paranoid: true&lt;/code&gt;, and would like to undo the deletion, use the &lt;code&gt;restore&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;paranoid: true&lt;/code&gt; モデルのインスタンスをソフト削除し、削除を元に戻したい場合は、 &lt;code&gt;restore&lt;/code&gt; メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="83a275a19fc7524ebcb47eee01b5247c06418a43" translate="yes" xml:space="preserve">
          <source>If you know that a model will always use the same alias in associations, you can provide it when creating the model</source>
          <target state="translated">モデルが常に同じエイリアスを使用することがわかっている場合は、モデルを作成する際にそれを提供することができます。</target>
        </trans-unit>
        <trans-unit id="3e5032709f3b242affafbbdb7632faacc668689e" translate="yes" xml:space="preserve">
          <source>If you know that a model will always use the same alias in associations, you can provide the singular and plural forms directly to the model itself:</source>
          <target state="translated">モデルが連想の中で常に同じエイリアスを使用することがわかっている場合、単数形と複数形をモデル自体に直接提供することができます。</target>
        </trans-unit>
        <trans-unit id="d0d51269897d4509e5bc63cdb1763b5e6f2abee2" translate="yes" xml:space="preserve">
          <source>If you log an instance you will notice, that there is a lot of additional stuff. In order to hide such stuff and reduce it to the very interesting information, you can use the&lt;code&gt;get&lt;/code&gt;-attribute. Calling it with the option &lt;code&gt;plain&lt;/code&gt; = true will only return the values of an instance.</source>
          <target state="translated">インスタンスをログに記録すると、追加の要素がたくさんあることがわかります。そのようなものを非表示にし、非常に興味深い情報に減らすために、 &lt;code&gt;get&lt;/code&gt; -attributeを使用できます。オプション &lt;code&gt;plain&lt;/code&gt; = trueを指定して呼び出すと、インスタンスの値のみが返されます。</target>
        </trans-unit>
        <trans-unit id="6b08bb3d2e947f978268c076db082fbb034c017e" translate="yes" xml:space="preserve">
          <source>If you need to get your instance in sync, you can use the method&lt;code&gt;reload&lt;/code&gt;. It will fetch the current data from the database and overwrite the attributes of the model on which the method has been called on.</source>
          <target state="translated">インスタンスを同期させる必要がある場合は、 &lt;code&gt;reload&lt;/code&gt; メソッドを使用できます。データベースから現在のデータをフェッチし、メソッドが呼び出されたモデルの属性を上書きします。</target>
        </trans-unit>
        <trans-unit id="2916bd0b55b8aca641a06d58426ff56557b254b3" translate="yes" xml:space="preserve">
          <source>If you only need some of the attributes from the join table, you can provide an array with the attributes you want:</source>
          <target state="translated">結合テーブルの属性の一部だけが必要な場合は、必要な属性を配列で指定することができます。</target>
        </trans-unit>
        <trans-unit id="fa84e598877d14dc3cb73bc586151be45d2ecb1a" translate="yes" xml:space="preserve">
          <source>If you provide an &lt;code&gt;include&lt;/code&gt; option, the number of matching associations will be counted instead.</source>
          <target state="translated">&lt;code&gt;include&lt;/code&gt; オプションを指定すると、一致する関連付けの数が代わりにカウントされます。</target>
        </trans-unit>
        <trans-unit id="dc79ee0718628292539287041025f940da4fc450" translate="yes" xml:space="preserve">
          <source>If you really want a hard-deletion and your model is paranoid, you can force it using the &lt;code&gt;force: true&lt;/code&gt; option:</source>
          <target state="translated">本当にハード削除が必要で、モデルが妄想的である場合は、 &lt;code&gt;force: true&lt;/code&gt; オプションを使用して強制することができます。</target>
        </trans-unit>
        <trans-unit id="8dd7ba08316df6d81c8bfdadc29d3cb20a63c77e" translate="yes" xml:space="preserve">
          <source>If you really want to let the query see the soft-deleted records, you can pass the &lt;code&gt;paranoid: false&lt;/code&gt; option to the query method. For example:</source>
          <target state="translated">本当にクエリにソフト削除されたレコードを表示させたい場合は、 &lt;code&gt;paranoid: false&lt;/code&gt; オプションをqueryメソッドに渡すことができます。例えば：</target>
        </trans-unit>
        <trans-unit id="5b85b7a23d962619602b9a3d66aa5e49f8b2f2fc" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;Model.bulkCreate(...)&lt;/code&gt; with the &lt;code&gt;updateOnDuplicate&lt;/code&gt; option, changes made in the hook to fields that aren't given in the &lt;code&gt;updateOnDuplicate&lt;/code&gt; array will not be persisted to the database. However it is possible to change the &lt;code&gt;updateOnDuplicate&lt;/code&gt; option inside the hook if this is what you want.</source>
          <target state="translated">&lt;code&gt;updateOnDuplicate&lt;/code&gt; オプションを &lt;code&gt;Model.bulkCreate(...)&lt;/code&gt; を使用する場合、 &lt;code&gt;updateOnDuplicate&lt;/code&gt; 配列で指定されていないフィールドへのフックで行われた変更は、データベースに保持されません。ただし、これが必要な場合は、フック内の &lt;code&gt;updateOnDuplicate&lt;/code&gt; オプションを変更することができます。</target>
        </trans-unit>
        <trans-unit id="d863b772f59c7c1fea122e1663917c43efb011ee" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;Model.bulkCreate(...)&lt;/code&gt; with the &lt;code&gt;updateOnDuplicate&lt;/code&gt; option, changes made in the hook to fields that aren't given in the &lt;code&gt;updateOnDuplicate&lt;/code&gt; array will not be persisted to the database. However it is possible to change the updateOnDuplicate option inside the hook if this is what you want.</source>
          <target state="translated">&lt;code&gt;updateOnDuplicate&lt;/code&gt; オプションを &lt;code&gt;Model.bulkCreate(...)&lt;/code&gt; を使用する場合、 &lt;code&gt;updateOnDuplicate&lt;/code&gt; 配列に指定されていないフィールドへのフックで行われた変更は、データベースに保持されません。ただし、これが必要な場合は、フック内のupdateOnDuplicateオプションを変更できます。</target>
        </trans-unit>
        <trans-unit id="afab7da99be65b4a2073f953b17af81dc02a3ed5" translate="yes" xml:space="preserve">
          <source>If you want Sequelize to automatically create the table (or modify it as needed) according to your model definition, you can use the &lt;code&gt;sync&lt;/code&gt; method, as follows:</source>
          <target state="translated">Sequelizeがモデル定義に従ってテーブルを自動的に作成する（または必要に応じて変更する）場合は、次のように &lt;code&gt;sync&lt;/code&gt; メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="f75ef969d5f06d081d766c60d1dd21fc30d0d354" translate="yes" xml:space="preserve">
          <source>If you want additional attributes in your join table, you can define a model for the join table in sequelize, before you define the association, and then tell sequelize that it should use that model for joining, instead of creating a new one:</source>
          <target state="translated">結合テーブルに追加の属性を追加したい場合は、アソシエーションを定義する前に sequelize で結合テーブルのモデルを定義し、新しいモデルを作成するのではなく、そのモデルを使用して結合するように sequelize に指示することができます。</target>
        </trans-unit>
        <trans-unit id="7cb72ec6577efe47bd8b75930fe054e841bde6bc" translate="yes" xml:space="preserve">
          <source>If you want sequelize to handle timestamps, but only want some of them, or want your timestamps to be called something else, you can override each column individually:</source>
          <target state="translated">タイムスタンプを sequelize で処理したいが、一部だけを処理したい場合や、タイムスタンプを別の名前で呼びたい場合は、それぞれのカラムを個別にオーバーライドすることができます。</target>
        </trans-unit>
        <trans-unit id="74c4a96cfc3c11e82bfff2366d0bb19c7c80c963" translate="yes" xml:space="preserve">
          <source>If you want to apply a &lt;code&gt;WHERE&lt;/code&gt; clause in an included model referring to a value from an associated model, you can simply use the &lt;code&gt;Sequelize.col&lt;/code&gt; function, as show in the example below:</source>
          <target state="translated">関連付けられたモデルの値を参照する &lt;code&gt;WHERE&lt;/code&gt; 句をインクルードモデルに適用する場合は、次の例に示すように、 &lt;code&gt;Sequelize.col&lt;/code&gt; 関数を使用するだけです。</target>
        </trans-unit>
        <trans-unit id="b777ec494ddce543c16902d51c471905b16fa9a5" translate="yes" xml:space="preserve">
          <source>If you want to apply another scope alongside the default scope, pass the key &lt;code&gt;defaultScope&lt;/code&gt; to &lt;code&gt;.scope&lt;/code&gt;:</source>
          <target state="translated">デフォルトのスコープと一緒に別のスコープを適用する場合は、キー &lt;code&gt;defaultScope&lt;/code&gt; を &lt;code&gt;.scope&lt;/code&gt; に渡します。</target>
        </trans-unit>
        <trans-unit id="0e3d2491ffbe91ae6541c30645933c5644c07ab6" translate="yes" xml:space="preserve">
          <source>If you want to create a belongs to many relationship that does not use the default primary key some setup work is required. You must set the &lt;code&gt;sourceKey&lt;/code&gt; (optionally &lt;code&gt;targetKey&lt;/code&gt;) appropriately for the two ends of the belongs to many. Further you must also ensure you have appropriate indexes created on your relationships. For example:</source>
          <target state="translated">デフォルトの主キーを使用しない多くの関係に属する所属を作成する場合は、いくつかの設定作業が必要です。 &lt;code&gt;sourceKey&lt;/code&gt; 属するものの両端に適切にsourceKey（オプションで &lt;code&gt;targetKey&lt;/code&gt; ）を設定する必要があります。さらに、関係に適切なインデックスが作成されていることを確認する必要もあります。例えば：</target>
        </trans-unit>
        <trans-unit id="f61f98f630678b685e1f3828dff3238a64205ed5" translate="yes" xml:space="preserve">
          <source>If you want to create a shortcut method to a scope on an associated model, you can pass the scoped model to the association. Consider a shortcut to get all deleted posts for a user:</source>
          <target state="translated">関連付けられたモデルのスコープにショートカット・メソッドを作成したい場合は、スコープされたモデルをアソシエーションに渡すことができます。あるユーザーの削除された投稿をすべて取得するショートカットを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="3b08f9c79138d7fcde3ec61eeae485a38887f673" translate="yes" xml:space="preserve">
          <source>If you want to emit hooks for each individual record, along with the bulk hooks you can pass &lt;code&gt;individualHooks: true&lt;/code&gt; to the call.</source>
          <target state="translated">個々のレコードごとにフックを発行したい場合は、バルクフックとともに、 &lt;code&gt;individualHooks: true&lt;/code&gt; を呼び出しに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="3b540c12693f5dbf831dc4cc9ca6c1eee425fd4d" translate="yes" xml:space="preserve">
          <source>If you want to modify these, you can pass pool as an options when instantiating Sequelize, as shown above.</source>
          <target state="translated">これらを変更したい場合は、上記のように、Sequelizeをインスタンス化する際にオプションとしてpoolを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="32c8896a0675e31aae1b24c2ac3e8559745e143a" translate="yes" xml:space="preserve">
          <source>If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:</source>
          <target state="translated">異なる属性を持つ複数のターゲットインスタンスを設定したい場合は、スルーモデルの名前を持つプロパティを使用してインスタンスに属性を設定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="1ef93ea1c2614431873c694ec0744cd661b60763" translate="yes" xml:space="preserve">
          <source>If you wish to undo a specific seed</source>
          <target state="translated">特定のシードを元に戻したい場合</target>
        </trans-unit>
        <trans-unit id="1e185b5f7416d1c9609b8910f2c095fe038cc14e" translate="yes" xml:space="preserve">
          <source>If you wish to undo a specific seed:</source>
          <target state="translated">特定のシードを元に戻したい場合。</target>
        </trans-unit>
        <trans-unit id="af863edfd5d71d3f8a26804bb152ee2c2da87ad3" translate="yes" xml:space="preserve">
          <source>If you wish to undo all seeds</source>
          <target state="translated">すべての種を元に戻したい場合</target>
        </trans-unit>
        <trans-unit id="b274488dd01fde2569538eb6ba474aa0f4c286a1" translate="yes" xml:space="preserve">
          <source>If you wish to undo all seeds:</source>
          <target state="translated">すべての種を元に戻したい場合</target>
        </trans-unit>
        <trans-unit id="c9da777accf0b16f64be8bca9d27fc688c0fd0ba" translate="yes" xml:space="preserve">
          <source>If you wish to undo most recent seed</source>
          <target state="translated">直近のシードを元に戻したい場合</target>
        </trans-unit>
        <trans-unit id="0fde4c4403536d346f7a881d06d11b078c0a1fc3" translate="yes" xml:space="preserve">
          <source>If you wish to undo the most recent seed:</source>
          <target state="translated">直近のシードを元に戻したい場合。</target>
        </trans-unit>
        <trans-unit id="67afe845a624aebd4dd0b36c74cb653944f9def5" translate="yes" xml:space="preserve">
          <source>If you're comfortable with somewhat less strict typing for the attributes on a model, you can save some code by defining the Instance to just extend &lt;code&gt;Model&lt;/code&gt; without any attributes in the generic types.</source>
          <target state="translated">モデルの属性の入力がやや厳密ではないことに慣れている場合は、インスタンスを定義して、ジェネリック型の属性なしで &lt;code&gt;Model&lt;/code&gt; を拡張するだけで、コードを保存できます。</target>
        </trans-unit>
        <trans-unit id="90e2d3d4a47e5a21011e831e9e97b42a42afde35" translate="yes" xml:space="preserve">
          <source>If you're connecting to the database from a single process, you should create only one Sequelize instance. Sequelize will set up a connection pool on initialization. This connection pool can be configured through the constructor's &lt;code&gt;options&lt;/code&gt; parameter (using &lt;code&gt;options.pool&lt;/code&gt;), as is shown in the following example:</source>
          <target state="translated">単一のプロセスからデータベースに接続している場合は、1つのSequelizeインスタンスのみを作成する必要があります。Sequelizeは初期化時に接続プールを設定します。この接続プールは、次の例に示すように、（ &lt;code&gt;options.pool&lt;/code&gt; を使用して）コンストラクタの &lt;code&gt;options&lt;/code&gt; パラメータを介して設定できます。</target>
        </trans-unit>
        <trans-unit id="b2971ed1f13da88526d6bf653a42311360d8cacf" translate="yes" xml:space="preserve">
          <source>If you're here, you might be looking for these topics:</source>
          <target state="translated">ここに来ている人は、これらのトピックを探しているかもしれません。</target>
        </trans-unit>
        <trans-unit id="6291ffc47760cc842fcd3a2e455f4f99cfb8ed05" translate="yes" xml:space="preserve">
          <source>If you're using SQLite, you should use the following instead:</source>
          <target state="translated">SQLiteを使用している場合は、代わりに以下のようにしてください。</target>
        </trans-unit>
        <trans-unit id="b3a9c13be57776d4bba71a3ea8415ae3e1d14fba" translate="yes" xml:space="preserve">
          <source>If your association is Many-to-Many, you may be interested in firing hooks on the through model when using the &lt;code&gt;remove&lt;/code&gt; call. Internally, sequelize is using &lt;code&gt;Model.destroy&lt;/code&gt; resulting in calling the &lt;code&gt;bulkDestroy&lt;/code&gt; instead of the &lt;code&gt;before/afterDestroy&lt;/code&gt; hooks on each through instance.</source>
          <target state="translated">アソシエーションが多対多の場合、 &lt;code&gt;remove&lt;/code&gt; 呼び出しを使用するときに、スルーモデルでフックを起動することに関心があるかもしれません。内部的には、sequelizeが使用さ &lt;code&gt;Model.destroy&lt;/code&gt; を呼び出し、その結果 &lt;code&gt;bulkDestroy&lt;/code&gt; 代わりの &lt;code&gt;before/afterDestroy&lt;/code&gt; インスタンスを介してそれぞれのフックを。</target>
        </trans-unit>
        <trans-unit id="a343e00321955b7beffbdeeb13a0fcb432790e92" translate="yes" xml:space="preserve">
          <source>If your association is of type &lt;code&gt;n:m&lt;/code&gt;, you may be interested in firing hooks on the through model when using the &lt;code&gt;remove&lt;/code&gt; call. Internally, sequelize is using &lt;code&gt;Model.destroy&lt;/code&gt; resulting in calling the &lt;code&gt;bulkDestroy&lt;/code&gt; instead of the &lt;code&gt;before/afterDestroy&lt;/code&gt; hooks on each through instance.</source>
          <target state="translated">アソシエーションのタイプが &lt;code&gt;n:m&lt;/code&gt; の場合、 &lt;code&gt;remove&lt;/code&gt; 呼び出しを使用するときに、throughモデルでフックを起動したい場合があります。内部的には、sequelizeが使用さ &lt;code&gt;Model.destroy&lt;/code&gt; を呼び出し、その結果 &lt;code&gt;bulkDestroy&lt;/code&gt; 代わりの &lt;code&gt;before/afterDestroy&lt;/code&gt; インスタンスを介してそれぞれのフックを。</target>
        </trans-unit>
        <trans-unit id="2e2df5af7499e577204f9c009e4644ef93552d80" translate="yes" xml:space="preserve">
          <source>If your callback succeeds, Sequelize will automatically commit the transaction</source>
          <target state="translated">コールバックが成功すると、Sequelize は自動的にトランザクションをコミットします。</target>
        </trans-unit>
        <trans-unit id="8b3adc43ab0c7ab59e41548add8cf8ff2a3b451a" translate="yes" xml:space="preserve">
          <source>If your callback throws, Sequelize will automatically rollback the transaction</source>
          <target state="translated">コールバックがスローされると、Sequelize は自動的にトランザクションをロールバックします。</target>
        </trans-unit>
        <trans-unit id="833407a04cbfb532aa3ab0eb509e48f853b7c95d" translate="yes" xml:space="preserve">
          <source>Ignore duplicate values for primary keys? (not supported by MSSQL or Postgres &amp;lt; 9.5)</source>
          <target state="translated">主キーの重複値を無視しますか？（MSSQLまたはPostgres &amp;lt;9.5ではサポートされていません）</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="0d71bedbf598c6cb2ef567aed0bcbc08631a830d" translate="yes" xml:space="preserve">
          <source>Implementation:</source>
          <target state="translated">Implementation:</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="b24a78bf1cbe20b658f9d8b812c79312cafb4997" translate="yes" xml:space="preserve">
          <source>Imported model, returned from cache if was already imported</source>
          <target state="translated">インポートされたモデル、すでにインポートされていた場合はキャッシュから返される</target>
        </trans-unit>
        <trans-unit id="42ef05cf1be558b6ed91a4aeffccb1e4cfc64023" translate="yes" xml:space="preserve">
          <source>Imports a model defined in another file.</source>
          <target state="translated">別のファイルで定義されたモデルをインポートします。</target>
        </trans-unit>
        <trans-unit id="4561455fcd06ac6b99fef1b4ec3f086730adf57a" translate="yes" xml:space="preserve">
          <source>Imports a model defined in another file. Imported models are cached, so multiple calls to import with the same path will not load the file multiple times.</source>
          <target state="translated">別のファイルで定義されたモデルをインポートします。インポートされたモデルはキャッシュされるので、同じパスで複数回呼び出してインポートしてもファイルは何度も読み込まれません。</target>
        </trans-unit>
        <trans-unit id="1eea469975ce5832153c3f8c53c1cabc35e823c1" translate="yes" xml:space="preserve">
          <source>In MySQL and MariaDB, the data types &lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;BIGINT&lt;/code&gt;, &lt;code&gt;FLOAT&lt;/code&gt; and &lt;code&gt;DOUBLE&lt;/code&gt; can be set as unsigned or zerofill (or both), as follows:</source>
          <target state="translated">MySQLとMariaDBでは、データ型 &lt;code&gt;INTEGER&lt;/code&gt; 、 &lt;code&gt;BIGINT&lt;/code&gt; 、 &lt;code&gt;FLOAT&lt;/code&gt; 、および &lt;code&gt;DOUBLE&lt;/code&gt; は、次のようにunsignedまたはzerofill（またはその両方）として設定できます。</target>
        </trans-unit>
        <trans-unit id="fc449382c5d7c01bc4ed7505e87c889bf281a9c7" translate="yes" xml:space="preserve">
          <source>In PostGIS, the GeoJSON is parsed using the PostGIS function &lt;code&gt;ST_GeomFromGeoJSON&lt;/code&gt;. In MySQL it is parsed using the function &lt;code&gt;GeomFromText&lt;/code&gt;.</source>
          <target state="translated">PostGISでは、GeoJSONはPostGIS関数 &lt;code&gt;ST_GeomFromGeoJSON&lt;/code&gt; を使用して解析されます。MySQLでは、関数 &lt;code&gt;GeomFromText&lt;/code&gt; を使用して解析されます。</target>
        </trans-unit>
        <trans-unit id="fc15714391598577351e70a8f34d6238fcc77cd0" translate="yes" xml:space="preserve">
          <source>In Sequelize 1:1 relationship can be set using HasOne and BelongsTo. They are suitable for different scenarios. Lets study this difference using an example.</source>
          <target state="translated">Sequelize では、HasOne と BelongsTo を使用して 1:1 の関係を設定できます。これらは様々なシナリオに適しています。この違いを例を使って勉強してみましょう。</target>
        </trans-unit>
        <trans-unit id="5538e00b3f69bacc6a529e276b7984b8a8b5222c" translate="yes" xml:space="preserve">
          <source>In Sequelize v4, it was possible to specify strings to refer to operators, instead of using Symbols. This is now deprecated and heavily discouraged, and will probably be removed in the next major version. If you really need it, you can pass the &lt;code&gt;operatorAliases&lt;/code&gt; option in the Sequelize constructor.</source>
          <target state="translated">Sequelize v4では、シンボルを使用する代わりに、演算子を参照する文字列を指定することができました。これは現在非推奨であり、強く推奨されておらず、おそらく次のメジャーバージョンで削除される予定です。本当に必要な場合は、Sequelizeコンストラクターで &lt;code&gt;operatorAliases&lt;/code&gt; オプションを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="3906fde18e49860f7af918b0800ba2801110f1bb" translate="yes" xml:space="preserve">
          <source>In Sequelize versions before v5, the default way of defining a model involved using &lt;code&gt;sequelize.define&lt;/code&gt;. It's still possible to define models with that, and you can also add typings to these models using interfaces.</source>
          <target state="translated">v5より前のバージョンのSequelizeでは、モデルを定義するデフォルトの方法は &lt;code&gt;sequelize.define&lt;/code&gt; を使用する必要がありました。それを使用してモデルを定義することは引き続き可能であり、インターフェイスを使用してこれらのモデルに型を追加することもできます。</target>
        </trans-unit>
        <trans-unit id="ab7b81d8aa8f174d8d5b48208d13c8d499bfffc9" translate="yes" xml:space="preserve">
          <source>In Sequelize, eager loading is mainly done by using the &lt;code&gt;include&lt;/code&gt; option on a model finder query (such as &lt;code&gt;findOne&lt;/code&gt;, &lt;code&gt;findAll&lt;/code&gt;, etc).</source>
          <target state="translated">Sequelizeでは、積極的な読み込みは主にモデルファインダークエリ（ &lt;code&gt;findOne&lt;/code&gt; 、 &lt;code&gt;findAll&lt;/code&gt; など）の &lt;code&gt;include&lt;/code&gt; オプションを使用して行われます。</target>
        </trans-unit>
        <trans-unit id="9c95a512d8d01104a5b16a7d3f2d233f18c0f08d" translate="yes" xml:space="preserve">
          <source>In Sequelize, it is possible to define multiple associations between the same models. You just have to define different aliases for them:</source>
          <target state="translated">Sequelize では、同じモデル間で複数の関連付けを定義することができます。そのためには、異なるエイリアスを定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="774bb87b46000c449a45f969a8e44a0806f3930d" translate="yes" xml:space="preserve">
          <source>In addition to the type mentioned above, integer, bigint, float and double also support unsigned and zerofill properties, which can be combined in any order: Be aware that this does not apply for PostgreSQL!</source>
          <target state="translated">上記の型に加えて、integer、bigint、float、doubleもunsignedプロパティとzerofillプロパティをサポートしており、任意の順番で組み合わせることができます。これはPostgreSQLには適用されませんので注意してください!</target>
        </trans-unit>
        <trans-unit id="4af5be18db1ad6a1a653687156ac599be363d197" translate="yes" xml:space="preserve">
          <source>In addition to updating a single instance, you can also create, update, and delete multiple instances at once. The functions you are looking for are called</source>
          <target state="translated">1つのインスタンスを更新するだけでなく、複数のインスタンスを一度に作成、更新、削除することもできます。探している関数は</target>
        </trans-unit>
        <trans-unit id="3b4cc1fd5220310d89eae1cdb8b77cbdd42fe084" translate="yes" xml:space="preserve">
          <source>In addition, after &lt;code&gt;sequelize.sync&lt;/code&gt;, the column that has &lt;code&gt;allowNull: false&lt;/code&gt; will be defined with a &lt;code&gt;NOT NULL&lt;/code&gt; SQL constraint. This way, direct SQL queries that attempt to set the value to &lt;code&gt;null&lt;/code&gt; will also fail.</source>
          <target state="translated">また、後 &lt;code&gt;sequelize.sync&lt;/code&gt; 、持つ列 &lt;code&gt;allowNull: false&lt;/code&gt; で定義されます &lt;code&gt;NOT NULL&lt;/code&gt; SQL制約。このように、値を &lt;code&gt;null&lt;/code&gt; に設定しようとする直接SQLクエリも失敗します。</target>
        </trans-unit>
        <trans-unit id="608a03c2fd0a19b5347676b81f1f4afcab08cd8a" translate="yes" xml:space="preserve">
          <source>In all cases the default foreign key can be overwritten with the &lt;code&gt;foreignKey&lt;/code&gt; option. When the foreign key option is used, Sequelize will use it as-is:</source>
          <target state="translated">すべての場合において、デフォルトの外部キーは &lt;code&gt;foreignKey&lt;/code&gt; オプションで上書きできます。外部キーオプションを使用すると、Sequelizeはそれをそのまま使用します。</target>
        </trans-unit>
        <trans-unit id="8d1442396eb18b379c62184b1e4b086254375017" translate="yes" xml:space="preserve">
          <source>In all the above examples, Sequelize automatically defined the foreign key names. For example, in the Ship and Captain example, Sequelize automatically defined a &lt;code&gt;captainId&lt;/code&gt; field on the Ship model. However, it is easy to specify a custom foreign key.</source>
          <target state="translated">上記のすべての例で、Sequelizeは外部キー名を自動的に定義しました。たとえば、Ship and Captainの例では、SequelizeはShipモデルに &lt;code&gt;captainId&lt;/code&gt; フィールドを自動的に定義しました。ただし、カスタム外部キーを指定するのは簡単です。</target>
        </trans-unit>
        <trans-unit id="87e3b464a7b0b4502bc77b6934bf2e4a7e80ae02" translate="yes" xml:space="preserve">
          <source>In all the above examples, you have noticed that the &lt;code&gt;order&lt;/code&gt; option is used at the top-level. The only situation in which &lt;code&gt;order&lt;/code&gt; also works inside the include option is when &lt;code&gt;separate: true&lt;/code&gt; is used. In that case, the usage is as follows:</source>
          <target state="translated">上記のすべての例で、 &lt;code&gt;order&lt;/code&gt; オプションがトップレベルで使用されていることに気づきました。includeオプション内でも &lt;code&gt;order&lt;/code&gt; が機能する唯一の状況は、 &lt;code&gt;separate: true&lt;/code&gt; が使用されている場合です。その場合の使用法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="99f55560f4696287997d800d3e9204066e7c2fec" translate="yes" xml:space="preserve">
          <source>In all the examples above, the associations were defined by referencing the primary keys of the involved models (in our case, their IDs). However, Sequelize allows you to define an association that uses another field, instead of the primary key field, to establish the association.</source>
          <target state="translated">上記のすべての例では、関連するモデルの主キー(ここでは ID)を参照してアソシエーションを定義しました。しかし、Sequelize では、主キーフィールドの代わりに別のフィールドを使用してアソシエーションを定義することができます。</target>
        </trans-unit>
        <trans-unit id="95d034948d56093f4fd3a267db42db031dc3b1e0" translate="yes" xml:space="preserve">
          <source>In case you want to eager load soft deleted records you can do that by setting &lt;code&gt;include.paranoid&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">ソフト削除されたレコードを熱心にロードしたい場合は、 &lt;code&gt;include.paranoid&lt;/code&gt; を &lt;code&gt;false&lt;/code&gt; に設定することで実行できます。</target>
        </trans-unit>
        <trans-unit id="d8ede833e4fc938a1a4307479c5c672f47f5c435" translate="yes" xml:space="preserve">
          <source>In case you want to eager load soft deleted records you can do that by setting &lt;code&gt;include.paranoid&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">ソフト削除されたレコードを熱心にロードしたい場合は、 &lt;code&gt;include.paranoid&lt;/code&gt; を &lt;code&gt;false&lt;/code&gt; に設定することでそれを行うことができます。</target>
        </trans-unit>
        <trans-unit id="779cd792541f894ff6ecc7d1a09d6d1d76f26c8a" translate="yes" xml:space="preserve">
          <source>In cases where &lt;code&gt;as&lt;/code&gt; has been defined it will be used in place of the target model name.</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; が定義されている場合は、ターゲットモデル名の代わりに使用されます。</target>
        </trans-unit>
        <trans-unit id="a6e18661df62cf03ad1b8c1dfaac6d64093d6a9e" translate="yes" xml:space="preserve">
          <source>In cases where you don't need to access the metadata you can pass in a query type to tell sequelize how to format the results. For example, for a simple select query you could do:</source>
          <target state="translated">メタデータにアクセスする必要がない場合は、クエリタイプを渡すことで結果のフォーマットを sequelize に伝えることができます。例えば、単純な select クエリの場合は次のようになります。</target>
        </trans-unit>
        <trans-unit id="f4aea729d09c224501cfb5032276fe9968a6cefc" translate="yes" xml:space="preserve">
          <source>In contrast, performing updates and deletions involving nested objects is currently not possible. For that, you will have to perform each separate action explicitly.</source>
          <target state="translated">対照的に、入れ子になったオブジェクトを含む更新や削除は現在のところ実行できません。そのためには、それぞれの個別のアクションを明示的に実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="038d4951b867c417185b9b9bd15b882b51593a33" translate="yes" xml:space="preserve">
          <source>In either case &lt;code&gt;$$&lt;/code&gt; can be used to escape a literal &lt;code&gt;$&lt;/code&gt; sign.</source>
          <target state="translated">どちらの場合でも、 &lt;code&gt;$$&lt;/code&gt; を使用してリテラル &lt;code&gt;$&lt;/code&gt; 記号をエスケープできます。</target>
        </trans-unit>
        <trans-unit id="fb22fea74b5a18e9648dd5f3f86b3ca5f73fef84" translate="yes" xml:space="preserve">
          <source>In last step you have create a seed file. It's still not committed to database. To do that we need to run a simple command.</source>
          <target state="translated">最後のステップでシードファイルを作成しました。まだデータベースにコミットされていません。そのためには簡単なコマンドを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="555e8f73359937df389576f9575dd78b1cbb04a0" translate="yes" xml:space="preserve">
          <source>In most case you won't need to access &lt;code&gt;namespace.get('transaction')&lt;/code&gt; directly, since all queries will automatically look for a transaction on the namespace:</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;namespace.get('transaction')&lt;/code&gt; に直接アクセスする必要はありません。これは、すべてのクエリが自動的に名前空間でトランザクションを探すためです。</target>
        </trans-unit>
        <trans-unit id="0ffa4116223b3446ad2774ab40fc1bea5b948a6e" translate="yes" xml:space="preserve">
          <source>In order to alleviate that, we can pass &lt;code&gt;constraints: false&lt;/code&gt; to one of the associations:</source>
          <target state="translated">これを緩和するために、 &lt;code&gt;constraints: false&lt;/code&gt; 1つにfalseを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="cc83ae9f1cd3ae67a5a6e4bc972a56286990ab33" translate="yes" xml:space="preserve">
          <source>In order to avoid installation bloat for non TS users, you must install the following typing packages manually:</source>
          <target state="translated">TS 以外のユーザへのインストールの肥大化を避けるためには、以下のタイピングパッケージを手動でインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="d6af6a905ac1e115cb3fd844cc79b49b4cf1c9fa" translate="yes" xml:space="preserve">
          <source>In order to calculate the sum over a specific column of a table, you can use the &lt;code&gt;sum&lt;/code&gt; method.</source>
          <target state="translated">テーブルの特定の列の合計を計算するには、 &lt;code&gt;sum&lt;/code&gt; メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="8941e4a38a8014ed6d514e02dc3ba6197c37e42b" translate="yes" xml:space="preserve">
          <source>In order to connect with a domain account, use the following format.</source>
          <target state="translated">ドメインアカウントで接続するには、以下の形式を使用します。</target>
        </trans-unit>
        <trans-unit id="ba6b9538578934a76cde7cf0edf5896fb565e928" translate="yes" xml:space="preserve">
          <source>In order to create instances of defined classes just do as follows. You might recognize the syntax if you coded Ruby in the past. Using the &lt;code&gt;build&lt;/code&gt;-method will return an unsaved object, which you explicitly have to save.</source>
          <target state="translated">定義済みクラスのインスタンスを作成するには、次のようにします。過去にRubyをコーディングした場合は、構文を認識できるかもしれません。 &lt;code&gt;build&lt;/code&gt; -methodを使用すると、保存されていないオブジェクトが返されるので、明示的に保存する必要があります。</target>
        </trans-unit>
        <trans-unit id="cf259232b5059754d2a1edf8525451aaa2799fec" translate="yes" xml:space="preserve">
          <source>In order to decrement values of an instance without running into concurrency issues, you may use &lt;code&gt;decrement&lt;/code&gt;.</source>
          <target state="translated">同時実行の問題に &lt;code&gt;decrement&lt;/code&gt; することなくインスタンスの値を減少させるには、decrementを使用できます。</target>
        </trans-unit>
        <trans-unit id="ca261ceb2eaf2ec423490304b525cf11f77c0268" translate="yes" xml:space="preserve">
          <source>In order to get Sequelize working nicely together with MySQL, you'll need to install&lt;code&gt;mysql2@^1.5.2&lt;/code&gt;or higher. Once that's done you can use it like this:</source>
          <target state="translated">SequelizeをMySQLとうまく連携させるには、mysql2 &lt;code&gt;mysql2@^1.5.2&lt;/code&gt; 以降をインストールする必要があります。完了したら、次のように使用できます。</target>
        </trans-unit>
        <trans-unit id="d50628c2ff499beb4c82368b3c407f6af0a795fe" translate="yes" xml:space="preserve">
          <source>In order to increment values of an instance without running into concurrency issues, you may use &lt;code&gt;increment&lt;/code&gt;.</source>
          <target state="translated">同時実行の問題に遭遇することなくインスタンスの値をインクリメントするには、 &lt;code&gt;increment&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="d70c048aa1fe6b43739e632650236176aa7bfa9b" translate="yes" xml:space="preserve">
          <source>In order to increment/decrement values of an instance without running into concurrency issues, Sequelize provides the &lt;a href=&quot;../class/lib/model.js~model#instance-method-increment&quot;&gt;&lt;code&gt;increment&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../class/lib/model.js~model#instance-method-decrement&quot;&gt;&lt;code&gt;decrement&lt;/code&gt;&lt;/a&gt; instance methods.</source>
          <target state="translated">同時実行の問題が発生することなくインスタンスの値をインクリメント/デクリメントするために、Sequelizeはインスタンスの&lt;a href=&quot;../class/lib/model.js~model#instance-method-increment&quot;&gt; &lt;code&gt;increment&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;../class/lib/model.js~model#instance-method-decrement&quot;&gt; &lt;code&gt;decrement&lt;/code&gt; &lt;/a&gt;メソッドを提供します。</target>
        </trans-unit>
        <trans-unit id="3ba11c5a40c1858c3524493596d5ef470b235de4" translate="yes" xml:space="preserve">
          <source>In order to study this, we will consider an example in which we have Ships and Captains, and a one-to-one relationship between them. We will allow null on foreign keys (the default), meaning that a Ship can exist without a Captain and vice-versa.</source>
          <target state="translated">これを研究するために、ShipとCaptainがあり、それらの間に一対一の関係がある例を考えてみましょう。ここでは、外部キーにnullを許可します(デフォルト)。つまり、ShipはCaptainなしで存在し、その逆も可能です。</target>
        </trans-unit>
        <trans-unit id="c0fde8aaeee3bc4a835c8c347691ddba0cf5ca1b" translate="yes" xml:space="preserve">
          <source>In principle, both options are a valid way to establish a One-To-One relationship between Foo and Bar. However, when we say something like &lt;em&gt;&quot;there is a One-To-One relationship between Foo and Bar&quot;&lt;/em&gt;, it is unclear whether or not the relationship is &lt;em&gt;mandatory&lt;/em&gt; or optional. In other words, can a Foo exist without a Bar? Can a Bar exist without a Foo? The answers to these questions helps figuring out where we want the foreign key column to be.</source>
          <target state="translated">原則として、どちらのオプションもFooとBarの間に1対1の関係を確立するための有効な方法です。ただし、&lt;em&gt;「FooとBarの間に1対1の関係がある」&lt;/em&gt;などと言うと、その関係が&lt;em&gt;必須&lt;/em&gt;かオプションかは不明です。言い換えれば、Fooはバーなしで存在できますか？ Fooなしでバーは存在できますか？これらの質問への回答は、外部キー列をどこに配置するかを理解するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="149d9edd63e09e594388c8c59f6205a3c7d42014" translate="yes" xml:space="preserve">
          <source>In production, you might want to consider using Migrations instead of calling &lt;code&gt;sync()&lt;/code&gt; in your code. Learn more in the &lt;a href=&quot;migrations&quot;&gt;Migrations&lt;/a&gt; guide.</source>
          <target state="translated">本番環境では、コードで &lt;code&gt;sync()&lt;/code&gt; を呼び出す代わりにMigrationsの使用を検討する必要がある場合があります。詳細については、&lt;a href=&quot;migrations&quot;&gt;移行&lt;/a&gt;ガイドをご覧ください。</target>
        </trans-unit>
        <trans-unit id="a74a7155df00d0a2252e9007a9498cc7f775fb94" translate="yes" xml:space="preserve">
          <source>In short, the name of the field will take the most logical form in each situation.</source>
          <target state="translated">要するに、フィールドの名前は、それぞれの状況で最も論理的な形をとります。</target>
        </trans-unit>
        <trans-unit id="c86642a07888e6db73277af0c0eaac74cefb4e90" translate="yes" xml:space="preserve">
          <source>In the API reference below, add the name of the association to the method, e.g. for &lt;code&gt;User.belongsTo(Project)&lt;/code&gt; the getter will be &lt;code&gt;user.getProject()&lt;/code&gt;.</source>
          <target state="translated">以下のAPIリファレンスで、関連付けの名前をメソッドに追加します。たとえば、 &lt;code&gt;User.belongsTo(Project)&lt;/code&gt; の場合、ゲッターは &lt;code&gt;user.getProject()&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="cef52cd717c629d67a98f43d7d2a3b36773181e1" translate="yes" xml:space="preserve">
          <source>In the API reference below, add the name of the association to the method, e.g. for &lt;code&gt;User.belongsToMany(Project)&lt;/code&gt; the getter will be &lt;code&gt;user.getProjects()&lt;/code&gt;.</source>
          <target state="translated">以下のAPIリファレンスで、関連付けの名前をメソッドに追加します。たとえば、 &lt;code&gt;User.belongsToMany(Project)&lt;/code&gt; の場合、ゲッターは &lt;code&gt;user.getProjects()&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="8b69de6ffb712491cc4ee70ce75bcc223197f419" translate="yes" xml:space="preserve">
          <source>In the API reference below, add the name of the association to the method, e.g. for &lt;code&gt;User.hasMany(Project)&lt;/code&gt; the getter will be &lt;code&gt;user.getProjects()&lt;/code&gt;. If the association is aliased, use the alias instead, e.g. &lt;code&gt;User.hasMany(Project, { as: 'jobs' })&lt;/code&gt; will be &lt;code&gt;user.getJobs()&lt;/code&gt;.</source>
          <target state="translated">以下のAPIリファレンスで、関連付けの名前をメソッドに追加します。たとえば、 &lt;code&gt;User.hasMany(Project)&lt;/code&gt; の場合、ゲッターは &lt;code&gt;user.getProjects()&lt;/code&gt; になります。関連付けがエイリアスされている場合は、代わりにエイリアスを使用します。たとえば、 &lt;code&gt;User.hasMany(Project, { as: 'jobs' })&lt;/code&gt; は &lt;code&gt;user.getJobs()&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="b19bcc7ba2b18c1f0e8b5d37540fdada124f6fcc" translate="yes" xml:space="preserve">
          <source>In the API reference below, add the name of the association to the method, e.g. for &lt;code&gt;User.hasOne(Project)&lt;/code&gt; the getter will be &lt;code&gt;user.getProject()&lt;/code&gt;. This is almost the same as &lt;code&gt;belongsTo&lt;/code&gt; with one exception - The foreign key will be defined on the target model.</source>
          <target state="translated">以下のAPIリファレンスで、関連付けの名前をメソッドに追加します。たとえば、 &lt;code&gt;User.hasOne(Project)&lt;/code&gt; の場合、ゲッターは &lt;code&gt;user.getProject()&lt;/code&gt; になります。これは、1つの例外を除いて、 &lt;code&gt;belongsTo&lt;/code&gt; とほぼ同じです。外部キーはターゲットモデルで定義されます。</target>
        </trans-unit>
        <trans-unit id="af86acfc1689af9e0f67efadcbe3050977007a0b" translate="yes" xml:space="preserve">
          <source>In the above example we are manually defining a key that references another model. It's not usual to do this, but if you have to, you should use the table name there. This is because the reference is created upon the referencced table name. In the example above, the plural form was used (&lt;code&gt;bars&lt;/code&gt;), assuming that the &lt;code&gt;bar&lt;/code&gt; model was created with the default settings (making its underlying table automatically pluralized).</source>
          <target state="translated">上記の例では、別のモデルを参照するキーを手動で定義しています。これを行うことは通常ではありませんが、必要な場合は、そこでテーブル名を使用する必要があります。これは、参照が参照されたテーブル名に基づいて作成されるためです。上記の例では、 &lt;code&gt;bar&lt;/code&gt; モデルがデフォルト設定で作成された（基になるテーブルが自動的に複数形になる）と仮定して、複数形（ &lt;code&gt;bars&lt;/code&gt; ）が使用されました。</target>
        </trans-unit>
        <trans-unit id="9c81e07a5c991fcdd92d6307e530a80a9f2f6471" translate="yes" xml:space="preserve">
          <source>In the above example, we had the models &lt;code&gt;Image&lt;/code&gt; and &lt;code&gt;Video&lt;/code&gt; being abstractly called &lt;em&gt;commentables&lt;/em&gt;, with one &lt;em&gt;commentable&lt;/em&gt; having many comments. However, one given comment would belong to a single &lt;em&gt;commentable&lt;/em&gt; - this is why the whole situation is a One-to-Many polymorphic association.</source>
          <target state="translated">上記の例では、我々は、モデルの持っていた &lt;code&gt;Image&lt;/code&gt; と &lt;code&gt;Video&lt;/code&gt; 抽象的に呼び出され&lt;em&gt;commentables&lt;/em&gt; 1で、&lt;em&gt;commentableは&lt;/em&gt;多くのコメントを持ちます。しかし、1つの所与のコメントが単一に属します&lt;em&gt;commentable&lt;/em&gt; -全体的な状況は、一対多のポリモーフィックな関連である理由です。</target>
        </trans-unit>
        <trans-unit id="02da87402808a84b0a74230cb43a995fdad4b31d" translate="yes" xml:space="preserve">
          <source>In the case of a one-to-many relationship.</source>
          <target state="translated">一対多の関係の場合。</target>
        </trans-unit>
        <trans-unit id="5ae509345fb49ae661568fc4744caa7cb1b9656b" translate="yes" xml:space="preserve">
          <source>In the case of many-to-many joins, you are also able to sort by attributes in the through table.</source>
          <target state="translated">多対多の結合の場合は、スルーテーブルで属性でソートすることもできます。</target>
        </trans-unit>
        <trans-unit id="eb6a0758e1c142fc9e84ad288ea850c903fb1ad0" translate="yes" xml:space="preserve">
          <source>In the case of many-to-many relationships, you are also able to sort by attributes in the through table. For example, assuming we have a Many-to-Many relationship between &lt;code&gt;Division&lt;/code&gt; and &lt;code&gt;Department&lt;/code&gt; whose junction model is &lt;code&gt;DepartmentDivision&lt;/code&gt;, you can do:</source>
          <target state="translated">多対多の関係の場合、throughテーブルの属性で並べ替えることもできます。たとえば、ジャンクションモデルが &lt;code&gt;DepartmentDivision&lt;/code&gt; である &lt;code&gt;Division&lt;/code&gt; と &lt;code&gt;Department&lt;/code&gt; の間に多対多の関係があるとすると、次のことができます。</target>
        </trans-unit>
        <trans-unit id="317c1f0442c62b94ccf6c9fc8c9140770a26fb3e" translate="yes" xml:space="preserve">
          <source>In the example above we have specified that a user belongs to his profile picture. Conceptually, this might not make sense, but since we want to add the foreign key to the user model this is the way to do it.</source>
          <target state="translated">上の例では、ユーザーがプロフィール画像に属することを指定しました。概念的には意味がないかもしれませんが、外部キーをユーザーモデルに追加したいので、これがその方法です。</target>
        </trans-unit>
        <trans-unit id="3f56aa735b7718af6d0f03509597c23eb6c23af7" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;scope&lt;/code&gt; options (such as &lt;code&gt;scope: { taggableType: 'image' }&lt;/code&gt;) were applied to the &lt;em&gt;through&lt;/em&gt; model, not the &lt;em&gt;target&lt;/em&gt; model, since it was used under the &lt;code&gt;through&lt;/code&gt; option.</source>
          <target state="translated">上記の例では、 &lt;code&gt;scope&lt;/code&gt; オプション（ &lt;code&gt;scope: { taggableType: 'image' }&lt;/code&gt; ）は、 &lt;code&gt;through&lt;/code&gt; オプションで使用されていたため、&lt;em&gt;ターゲット&lt;/em&gt;モデルではなく&lt;em&gt;through&lt;/em&gt;モデルに適用されました。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ce0b3ed97c0ca3b3cfb4f4a1a06ba62b0ecd8f3c" translate="yes" xml:space="preserve">
          <source>In the examples above, the transaction is still manually passed, by passing &lt;code&gt;{ transaction: t }&lt;/code&gt; as the second argument. To automatically pass the transaction to all queries you must install the &lt;a href=&quot;https://github.com/Jeff-Lewis/cls-hooked&quot;&gt;cls-hooked&lt;/a&gt; (CLS) module and instantiate a namespace in your own code:</source>
          <target state="translated">上記の例では、2番目の引数として &lt;code&gt;{ transaction: t }&lt;/code&gt; を渡すことにより、トランザクションは引き続き手動で渡されます。トランザクションをすべてのクエリに自動的に渡すには、&lt;a href=&quot;https://github.com/Jeff-Lewis/cls-hooked&quot;&gt;cls-hooked&lt;/a&gt;（CLS）モジュールをインストールし、独自のコードで名前空間をインスタンス化する必要があります。</target>
        </trans-unit>
        <trans-unit id="2a0dce9e1d09c8edbde67374cb81c49870755238" translate="yes" xml:space="preserve">
          <source>In this document we'll explore what finder methods can do:</source>
          <target state="translated">このドキュメントでは、ファインダーメソッドで何ができるのかを探っていきます。</target>
        </trans-unit>
        <trans-unit id="613042d1f3606de477403116ad2dde419489b062" translate="yes" xml:space="preserve">
          <source>In this example the name of the postgres range type is &lt;code&gt;SOMETYPE_range&lt;/code&gt; and the name of the underlying postgres datatype is &lt;code&gt;pg_new_type&lt;/code&gt;. The key of &lt;code&gt;subtypes&lt;/code&gt; and &lt;code&gt;castTypes&lt;/code&gt; is the key of the Sequelize datatype &lt;code&gt;DataTypes.SOMETYPE.key&lt;/code&gt;, in lower case.</source>
          <target state="translated">この例では、postgres範囲タイプの名前は &lt;code&gt;SOMETYPE_range&lt;/code&gt; であり、基になるpostgresデータ型の名前は &lt;code&gt;pg_new_type&lt;/code&gt; です。主要な &lt;code&gt;subtypes&lt;/code&gt; と &lt;code&gt;castTypes&lt;/code&gt; はSequelizeデータ型のキーである &lt;code&gt;DataTypes.SOMETYPE.key&lt;/code&gt; 小文字で、。</target>
        </trans-unit>
        <trans-unit id="8ccb67d5f9158b5bfef3f61c07b44ac9e4f30373" translate="yes" xml:space="preserve">
          <source>In this example the name of the postgres range type is &lt;code&gt;newtype_range&lt;/code&gt; and the name of the underlying postgres datatype is &lt;code&gt;pg_new_type&lt;/code&gt;. The key of &lt;code&gt;subtypes&lt;/code&gt; and &lt;code&gt;castTypes&lt;/code&gt; is the key of the Sequelize datatype &lt;code&gt;DataTypes.NEWTYPE.key&lt;/code&gt;, in lower case.</source>
          <target state="translated">この例では、postgres範囲型の名前は &lt;code&gt;newtype_range&lt;/code&gt; であり、基礎となるpostgresデータ型の名前は &lt;code&gt;pg_new_type&lt;/code&gt; です。主要な &lt;code&gt;subtypes&lt;/code&gt; と &lt;code&gt;castTypes&lt;/code&gt; は Sequelizeデータ型のキーである &lt;code&gt;DataTypes.NEWTYPE.key&lt;/code&gt; 小文字で、。</target>
        </trans-unit>
        <trans-unit id="35c8c41b915b7cca99bbb0a9dd22f6c0333cde65" translate="yes" xml:space="preserve">
          <source>In this example, we have the models &lt;code&gt;Team&lt;/code&gt; and &lt;code&gt;Player&lt;/code&gt;. We want to tell Sequelize that there is a One-To-Many relationship between them, meaning that one Team has many Players, while each Player belongs to a single Team.</source>
          <target state="translated">この例では、モデル &lt;code&gt;Team&lt;/code&gt; と &lt;code&gt;Player&lt;/code&gt; があります。Sequelizeに、それらの間には1対多の関係があることを伝えたいと思います。つまり、1つのチームには多くのプレーヤーがいて、各プレーヤーは1つのチームに属しています。</target>
        </trans-unit>
        <trans-unit id="183bd8588dc52f5cbe2e8f4e490c205e50053f9f" translate="yes" xml:space="preserve">
          <source>In this example, we will create a type called &lt;code&gt;SOMETYPE&lt;/code&gt; that replicates the built-in datatype &lt;code&gt;DataTypes.INTEGER(11).ZEROFILL.UNSIGNED&lt;/code&gt;.</source>
          <target state="translated">この例では、組み込みデータ型 &lt;code&gt;DataTypes.INTEGER(11).ZEROFILL.UNSIGNED&lt;/code&gt; を複製する &lt;code&gt;SOMETYPE&lt;/code&gt; という型を作成します。</target>
        </trans-unit>
        <trans-unit id="f06d44df54aba38c2a1a5e52366770a4c55d5686" translate="yes" xml:space="preserve">
          <source>In this simple case an object fails validation if either latitude or longitude is given, but not both. If we try to build one with an out-of-range latitude and no longitude, &lt;code&gt;raging_bullock_arms.validate()&lt;/code&gt; might return</source>
          <target state="translated">この単純なケースでは、緯度または経度のいずれかが指定されているが、両方が指定されていない場合、オブジェクトは検証に失敗します。緯度の範囲外で経度のないものを構築しようとすると、 &lt;code&gt;raging_bullock_arms.validate()&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="529d9ac265aa5c45aa5882637a91c017c2c415d6" translate="yes" xml:space="preserve">
          <source>In this simple case an object fails validation if either latitude or longitude is given, but not both. If we try to build one with an out-of-range latitude and no longitude, &lt;code&gt;somePlace.validate()&lt;/code&gt; might return:</source>
          <target state="translated">この単純なケースでは、緯度または経度のいずれかが指定されている場合、オブジェクトは検証に失敗しますが、両方は指定されていません。緯度が範囲外で経度がないものを作成しようとすると、 &lt;code&gt;somePlace.validate()&lt;/code&gt; が次のように返す場合があります。</target>
        </trans-unit>
        <trans-unit id="9541234d9fda492dd87e27afb4fb9fb19d8de710" translate="yes" xml:space="preserve">
          <source>In this tutorial you will learn how to setup validations and constraints for your models in Sequelize.</source>
          <target state="translated">このチュートリアルでは、Sequelizeでモデルのバリデーションと制約を設定する方法を学びます。</target>
        </trans-unit>
        <trans-unit id="3851d0f94c7be9ec7c5ead977d92fb894f0d89fb" translate="yes" xml:space="preserve">
          <source>In this tutorial you will learn to make a simple setup of Sequelize to learn the basics.</source>
          <target state="translated">このチュートリアルでは、基本を学ぶためにSequelizeの簡単なセットアップを行います。</target>
        </trans-unit>
        <trans-unit id="df1658fb7bea66f99a24c6472bf5de5a13879256" translate="yes" xml:space="preserve">
          <source>In this tutorial you will learn to make a simple setup of Sequelize.</source>
          <target state="translated">このチュートリアルでは、Sequelizeの簡単な設定方法を学びます。</target>
        </trans-unit>
        <trans-unit id="39611ac13c57239c707052898ea1f9ac93ecacef" translate="yes" xml:space="preserve">
          <source>In this tutorial you will learn what models are in Sequelize and how to use them.</source>
          <target state="translated">このチュートリアルでは、Sequelize にはどのようなモデルがあり、どのように使用するのかを学びます。</target>
        </trans-unit>
        <trans-unit id="4f5430a6a9d01363455824822c75737cf9c8f435" translate="yes" xml:space="preserve">
          <source>Include all also supports nested loading:</source>
          <target state="translated">Include all は、ネストされた読み込みにも対応しています。</target>
        </trans-unit>
        <trans-unit id="ee22d111d4c8367bcfece43e25265c1b1b970179" translate="yes" xml:space="preserve">
          <source>Include options. See &lt;code&gt;find&lt;/code&gt; for details</source>
          <target state="translated">オプションを含めます。詳細について &lt;code&gt;find&lt;/code&gt; 、検索を参照してください</target>
        </trans-unit>
        <trans-unit id="f4eea4e4d711cc1ecb5cda0e5dbfb9571c247ac3" translate="yes" xml:space="preserve">
          <source>Includes are merged recursively based on the models being included. This is a very powerful merge, added on v5, and is better understood with an example.</source>
          <target state="translated">インクルードは、インクルードされるモデルに基づいて再帰的にマージされます。これは v5 で追加された非常に強力なマージです。</target>
        </trans-unit>
        <trans-unit id="027827ecd07b15695c7b030f1a2f763df4b19097" translate="yes" xml:space="preserve">
          <source>Including everything</source>
          <target state="translated">すべてを含む</target>
        </trans-unit>
        <trans-unit id="c00227cf95dc381c6c30d2e5768223f461bcb57c" translate="yes" xml:space="preserve">
          <source>Including soft deleted records</source>
          <target state="translated">ソフト削除された記録を含む</target>
        </trans-unit>
        <trans-unit id="54a09acba666b3479a71fa90551496293ff3b39c" translate="yes" xml:space="preserve">
          <source>Increment the value of one or more columns.</source>
          <target state="translated">1つ以上の列の値をインクリメントします。</target>
        </trans-unit>
        <trans-unit id="787e3b938ace632df3c30ed406921fc264679317" translate="yes" xml:space="preserve">
          <source>Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a</source>
          <target state="translated">1 つ以上の列の値をインクリメントします。これはデータベース内で行われ、現在インスタンスに保存されている値を使用しないことを意味します。インクリメントは</target>
        </trans-unit>
        <trans-unit id="76bdd22b4e3260f69cfe386f60459acba6de3c0d" translate="yes" xml:space="preserve">
          <source>Increment the value of one or more columns. This is done in the database, which means it does not use the values currently stored on the Instance. The increment is done using a &lt;code&gt;SET column = column + X WHERE foo = 'bar'&lt;/code&gt; query. To get the correct value after an increment into the Instance you should do a reload.</source>
          <target state="translated">1つ以上の列の値を増分します。これはデータベースで行われます。つまり、インスタンスに現在保存されている値は使用されません。増分は、 &lt;code&gt;SET column = column + X WHERE foo = 'bar'&lt;/code&gt; クエリを使用して行われます。インスタンスへのインクリメント後に正しい値を取得するには、リロードを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="a8ff72a665bb30731770e7705fe338083cf89b76" translate="yes" xml:space="preserve">
          <source>Incrementing</source>
          <target state="translated">Incrementing</target>
        </trans-unit>
        <trans-unit id="a1c24bf8bfe650fa4f84c009ba48a2fd9fc32de2" translate="yes" xml:space="preserve">
          <source>Incrementing and decrementing integer values</source>
          <target state="translated">整数値のインクリメントとデクリメント</target>
        </trans-unit>
        <trans-unit id="60049830fb2701db5de1c9bccb71b67fcbb23036" translate="yes" xml:space="preserve">
          <source>Index Hints</source>
          <target state="translated">インデックスヒント</target>
        </trans-unit>
        <trans-unit id="b3ed723d45a3f790a9a9e12a818a0c61a8e14997" translate="yes" xml:space="preserve">
          <source>Index Hints - MySQL/MariaDB only</source>
          <target state="translated">インデックスのヒント-MySQL/MariaDBのみ</target>
        </trans-unit>
        <trans-unit id="ea6eb3406625826a6548de806b904dddd5791b5e" translate="yes" xml:space="preserve">
          <source>Index hints &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/index-hints.html&quot;&gt;override the default behavior of the MySQL query optimizer&lt;/a&gt;.</source>
          <target state="translated">インデックスヒント&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/index-hints.html&quot;&gt;は、MySQLクエリオプティマイザのデフォルトの動作を上書きします&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="15ed187841ecb74c7b628c9d39e663a146a445d1" translate="yes" xml:space="preserve">
          <source>Index hints &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/index-hints.html&quot;&gt;override the default behavior of the mysql query optimizer&lt;/a&gt;.</source>
          <target state="translated">インデックスヒント&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/index-hints.html&quot;&gt;は、mysqlクエリオプティマイザーのデフォルトの動作をオーバーライドします&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27bf949a8c6bbf392cd9bbfb0a23ac87298c9ae6" translate="yes" xml:space="preserve">
          <source>Index name</source>
          <target state="translated">インデックス名</target>
        </trans-unit>
        <trans-unit id="d71a6a1e24a92e4c60cd3181a6a50dee24e968c7" translate="yes" xml:space="preserve">
          <source>Index name or list of attributes that in the index</source>
          <target state="translated">インデックス名またはインデックスに含まれる属性のリスト</target>
        </trans-unit>
        <trans-unit id="2a9a9e601e879f8a25e6b88cecfaa9477d0b69b6" translate="yes" xml:space="preserve">
          <source>Index operator</source>
          <target state="translated">インデックス演算子</target>
        </trans-unit>
        <trans-unit id="3db988cf9ae171debdcc20214fccade20a6d5743" translate="yes" xml:space="preserve">
          <source>Index type. Only used by mysql. One of &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;FULLTEXT&lt;/code&gt; and &lt;code&gt;SPATIAL&lt;/code&gt;</source>
          <target state="translated">インデックスタイプ。mysqlでのみ使用されます。一つ &lt;code&gt;UNIQUE&lt;/code&gt; 、 &lt;code&gt;FULLTEXT&lt;/code&gt; と &lt;code&gt;SPATIAL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbd5e44bf0af97c76997bc5bf5b67484d7bd41fd" translate="yes" xml:space="preserve">
          <source>IndexHints</source>
          <target state="translated">IndexHints</target>
        </trans-unit>
        <trans-unit id="f642ee196088372ea886186c6c617515599afd3f" translate="yes" xml:space="preserve">
          <source>Indexes</source>
          <target state="translated">Indexes</target>
        </trans-unit>
        <trans-unit id="d546d086737ecd71ea685f7ecca5e406efe04475" translate="yes" xml:space="preserve">
          <source>Indirect Subclass:</source>
          <target state="translated">間接サブクラス。</target>
        </trans-unit>
        <trans-unit id="5f86be890f5fca505337bd96fadab61d81d1721f" translate="yes" xml:space="preserve">
          <source>Inherited Summary</source>
          <target state="translated">継承された概要</target>
        </trans-unit>
        <trans-unit id="31f1c8a556d0112856c008a3ad8749f41bf60b3f" translate="yes" xml:space="preserve">
          <source>Initialize a model, representing a table in the DB, with attributes and options.</source>
          <target state="translated">DB内のテーブルを表すモデルを、属性とオプションで初期化します。</target>
        </trans-unit>
        <trans-unit id="34082efdebc41766317697316140da8f26c3e107" translate="yes" xml:space="preserve">
          <source>Insert multiple records into a table</source>
          <target state="translated">テーブルに複数のレコードを挿入する</target>
        </trans-unit>
        <trans-unit id="7ec8753d3a44c87c9473adfa6c44b60942d04fe3" translate="yes" xml:space="preserve">
          <source>Insert or update a single row.</source>
          <target state="translated">1つの行を挿入または更新します。</target>
        </trans-unit>
        <trans-unit id="2dd5c9df09dccb9c155c03e0ece1aeed6a35cf5c" translate="yes" xml:space="preserve">
          <source>Insert or update a single row. An update will be executed if a row which matches the supplied values on either the primary key or a unique key is found. Note that the unique index must be defined in your sequelize model and not just in the table. Otherwise you may experience a unique constraint violation, because sequelize fails to identify the row that should be updated.</source>
          <target state="translated">単一の行を挿入または更新します。更新は、主キーまたは一意キーのいずれかで指定された値に一致する行が見つかった場合に実行されます。一意なインデックスは、テーブル内だけでなく sequelize モデル内で定義しなければならないことに注意してください。そうしないと、 sequelize が更新すべき行の特定に失敗してしまうため、一意性制約の違反が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="0fcf41de510c5775db6e05c056c7c1d5562270b3" translate="yes" xml:space="preserve">
          <source>Insert several rows and return all columns (Postgres only):</source>
          <target state="translated">複数の行を挿入し、すべての列を返します(Postgresのみ)。</target>
        </trans-unit>
        <trans-unit id="82c27a49773b27db4a4892eb51537165bf561a05" translate="yes" xml:space="preserve">
          <source>Insert several rows and return specific columns (Postgres only):</source>
          <target state="translated">複数の行を挿入し、特定の列を返します(Postgresのみ)。</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="e38432618ce4d39079fc324e614d4d92a2815160" translate="yes" xml:space="preserve">
          <source>Installing</source>
          <target state="translated">Installing</target>
        </trans-unit>
        <trans-unit id="738e880dd4e789ec957d300caa68fee228a78956" translate="yes" xml:space="preserve">
          <source>Installing CLI</source>
          <target state="translated">CLIのインストール</target>
        </trans-unit>
        <trans-unit id="05cd2d2edbef55f0f40dc901ecbc1b64b01dcaa9" translate="yes" xml:space="preserve">
          <source>Installing the CLI</source>
          <target state="translated">CLIのインストール</target>
        </trans-unit>
        <trans-unit id="ccb890bc332682567d34290c45bd65a654e962bd" translate="yes" xml:space="preserve">
          <source>Instance build options</source>
          <target state="translated">インスタンス構築オプション</target>
        </trans-unit>
        <trans-unit id="5ac629af8667053ca02646726c3c988282dc7f26" translate="yes" xml:space="preserve">
          <source>Instance hooks</source>
          <target state="translated">インスタンスフック</target>
        </trans-unit>
        <trans-unit id="274ad4dd86f2d3421e19dbc845f0539216d205f2" translate="yes" xml:space="preserve">
          <source>InstanceError</source>
          <target state="translated">InstanceError</target>
        </trans-unit>
        <trans-unit id="86d67413e7f102d37a19a41e92518fd07b196a5a" translate="yes" xml:space="preserve">
          <source>Instances</source>
          <target state="translated">Instances</target>
        </trans-unit>
        <trans-unit id="9e8467d590d4be1587eaf02bbcf552bcc1c6e813" translate="yes" xml:space="preserve">
          <source>Instantiate sequelize with name of database, username and password.</source>
          <target state="translated">データベース名、ユーザ名、パスワードを指定して sequelize をインスタンス化します。</target>
        </trans-unit>
        <trans-unit id="d51d3d0b6180f2e7c14a0b2e9f6c9dec8347e6ef" translate="yes" xml:space="preserve">
          <source>Instead of a string, passing a model directly is also supported, and in that case the given model will be used as the junction model (and no model will be created automatically). For example:</source>
          <target state="translated">文字列の代わりに直接モデルを渡すこともサポートされており、その場合は与えられたモデルが接合モデルとして使用されます(自動的にモデルが作成されることはありません)。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="b3094ee388cfb121e08aa8acc192a2cdfc0b8210" translate="yes" xml:space="preserve">
          <source>Instead of calling &lt;code&gt;sync()&lt;/code&gt; for every model, you can call &lt;code&gt;sequelize.sync()&lt;/code&gt; which will automatically sync all models.</source>
          <target state="translated">すべてのモデルに対して &lt;code&gt;sync()&lt;/code&gt; を呼び出す代わりに、すべてのモデルを自動的に同期する &lt;code&gt;sequelize.sync()&lt;/code&gt; を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="05580f601b5eaa4bd8a72a894129babf0543db11" translate="yes" xml:space="preserve">
          <source>Instead of setting up the Many-to-Many relationship defined above, what if we did the following instead?</source>
          <target state="translated">上で定義した多対多の関係を設定する代わりに、次のようにしたらどうでしょうか?</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="490af473232b6a93643f272bee98388cd223e9fd" translate="yes" xml:space="preserve">
          <source>Internal Transactions</source>
          <target state="translated">内部取引</target>
        </trans-unit>
        <trans-unit id="9012b802b5499dddeaa05001c949bbc17d0e16f2" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;sequelize.define&lt;/code&gt; calls &lt;code&gt;Model.init&lt;/code&gt;, so both approaches are essentially equivalent.</source>
          <target state="translated">内部的には、 &lt;code&gt;sequelize.define&lt;/code&gt; は呼び出す &lt;code&gt;Model.init&lt;/code&gt; をするので、両方のアプローチは、本質的に等価です。</target>
        </trans-unit>
        <trans-unit id="3d3960679eb413b74946e3c8863bed548577df5d" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;sequelize.define&lt;/code&gt; calls &lt;code&gt;Model.init&lt;/code&gt;.</source>
          <target state="translated">内部的には、 &lt;code&gt;sequelize.define&lt;/code&gt; がModel.initを呼び出し &lt;code&gt;Model.init&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a26b8650a9de522981bcafa08f85067a7ddceb6" translate="yes" xml:space="preserve">
          <source>InvalidConnectionError</source>
          <target state="translated">InvalidConnectionError</target>
        </trans-unit>
        <trans-unit id="9211e9fa56459ab7c08f8f8f8b73301a55b7ccfe" translate="yes" xml:space="preserve">
          <source>Is this a new record</source>
          <target state="translated">これは新譜ですか?</target>
        </trans-unit>
        <trans-unit id="afe7a6e84bced131db798b6f4a5218b8ba604521" translate="yes" xml:space="preserve">
          <source>Is this binary?</source>
          <target state="translated">これはバイナリーなのか?</target>
        </trans-unit>
        <trans-unit id="6930c839f5926a5dbc3973abed70a968ebe27fcd" translate="yes" xml:space="preserve">
          <source>Is this new record</source>
          <target state="translated">今回の新譜は</target>
        </trans-unit>
        <trans-unit id="ff65e83635da6a16fc4326dabfbf055783a3b67f" translate="yes" xml:space="preserve">
          <source>Is unsigned?</source>
          <target state="translated">符号なしですか?</target>
        </trans-unit>
        <trans-unit id="e43b3654cb7e64fdddd41aa99284538c43372f9f" translate="yes" xml:space="preserve">
          <source>Is zero filled?</source>
          <target state="translated">ゼロは埋まっているのか?</target>
        </trans-unit>
        <trans-unit id="bc950c72cafdb1b72d875b5f0116396b3dcf31bd" translate="yes" xml:space="preserve">
          <source>Isolation levels</source>
          <target state="translated">分離レベル</target>
        </trans-unit>
        <trans-unit id="ceb55c4968b36fcfbb8bfa38dd67ef748266db4a" translate="yes" xml:space="preserve">
          <source>Isolation levels can be set per-transaction by passing &lt;code&gt;options.isolationLevel&lt;/code&gt; to &lt;code&gt;sequelize.transaction&lt;/code&gt;.</source>
          <target state="translated">分離レベルは、 &lt;code&gt;options.isolationLevel&lt;/code&gt; を &lt;code&gt;sequelize.transaction&lt;/code&gt; に渡すことにより、トランザクションごとに設定できます。</target>
        </trans-unit>
        <trans-unit id="7de7da7cce1fe9bf748f458bb4ef7c345ecf4b72" translate="yes" xml:space="preserve">
          <source>Isolation levels can be set per-transaction by passing &lt;code&gt;options.isolationLevel&lt;/code&gt; to &lt;code&gt;sequelize.transaction&lt;/code&gt;. Sequelize uses the default isolation level of the database, you can override this by passing &lt;code&gt;options.isolationLevel&lt;/code&gt; in Sequelize constructor options.</source>
          <target state="translated">分離レベルは、 &lt;code&gt;options.isolationLevel&lt;/code&gt; を &lt;code&gt;sequelize.transaction&lt;/code&gt; に渡すことにより、トランザクションごとに設定できます。Sequelizeはデータベースのデフォルトの分離レベルを使用します。Sequelizeコンストラクターオプションで &lt;code&gt;options.isolationLevel&lt;/code&gt; を渡すことにより、これをオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="f496de06c48426836962ac319b8e34aaa93ebfe2" translate="yes" xml:space="preserve">
          <source>It can be used, for example, to move the where conditions from an included model from the &lt;code&gt;ON&lt;/code&gt; condition to a top-level &lt;code&gt;WHERE&lt;/code&gt; clause.</source>
          <target state="translated">たとえば、インクルードされたモデルのwhere条件を &lt;code&gt;ON&lt;/code&gt; 条件から最上位の &lt;code&gt;WHERE&lt;/code&gt; 句に移動するために使用できます。</target>
        </trans-unit>
        <trans-unit id="5908ca9c9e90f7ff830f11cc8c2e2d27ebe810b5" translate="yes" xml:space="preserve">
          <source>It is also possible to define which attributes can be set in the &lt;code&gt;create&lt;/code&gt; method. This can be especially useful if you create database entries based on a form which can be filled by a user. Using that would, for example, allow you to restrict the &lt;code&gt;User&lt;/code&gt; model to set only an username and an address but not an admin flag:</source>
          <target state="translated">&lt;code&gt;create&lt;/code&gt; メソッドで設定できる属性を定義することもできます。これは、ユーザーが入力できるフォームに基づいてデータベースエントリを作成する場合に特に便利です。これを使用すると、たとえば、 &lt;code&gt;User&lt;/code&gt; モデルを制限して、ユーザー名とアドレスのみを設定し、管理者フラグは設定しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="8c4c047702785b929a273515b1a82e520030e139" translate="yes" xml:space="preserve">
          <source>It is also possible to define which attributes can be set via the create method. This can be especially very handy if you create database entries based on a form which can be filled by a user. Using that would for example allow you to restrict the &lt;code&gt;User&lt;/code&gt; model to set only a username and an address but not an admin flag:</source>
          <target state="translated">また、createメソッドを使用して設定できる属性を定義することもできます。これは、ユーザーが入力できるフォームに基づいてデータベースエントリを作成する場合に特に便利です。これを使用すると、たとえば、 &lt;code&gt;User&lt;/code&gt; モデルを制限して、ユーザー名とアドレスのみを設定し、管理フラグは設定しないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="b0c239eac3353866dc58bd00ecb70b3153364af7" translate="yes" xml:space="preserve">
          <source>It is also possible to enable only one of &lt;code&gt;createdAt&lt;/code&gt;/&lt;code&gt;updatedAt&lt;/code&gt;, and to provide a custom name for these columns:</source>
          <target state="translated">&lt;code&gt;createdAt&lt;/code&gt; / &lt;code&gt;updatedAt&lt;/code&gt; 1つだけを有効にし、これらの列にカスタム名を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="458150e56a3d316de3d7363070d164f7fb22c292" translate="yes" xml:space="preserve">
          <source>It is also possible to include scoped models in a scope definition. This allows you to avoid duplicating &lt;code&gt;include&lt;/code&gt;, &lt;code&gt;attributes&lt;/code&gt; or &lt;code&gt;where&lt;/code&gt; definitions. Using the above example, and invoking the &lt;code&gt;active&lt;/code&gt; scope on the included User model (rather than specifying the condition directly in that include object):</source>
          <target state="translated">スコープ定義にスコープモデルを含めることもできます。これにより、 &lt;code&gt;include&lt;/code&gt; 、 &lt;code&gt;attributes&lt;/code&gt; または &lt;code&gt;where&lt;/code&gt; 定義の重複を回避できます。上記の例を使用して、（そのインクルードオブジェクトで条件を直接指定するのではなく）インクルードされたUserモデルで &lt;code&gt;active&lt;/code&gt; スコープを呼び出します。</target>
        </trans-unit>
        <trans-unit id="ddee74f90f8a0f9498567c187f111536a9989a76" translate="yes" xml:space="preserve">
          <source>It is possible to define 'object-property' getters and setter functions on your models, these can be used both for 'protecting' properties that map to database fields and for defining 'pseudo' properties.</source>
          <target state="translated">これらは、データベースフィールドにマップするプロパティを「保護」するためと、「擬似」プロパティを定義するための両方に使用することができます。</target>
        </trans-unit>
        <trans-unit id="2cf42e7c4455442ac5cf3de78fb4007302cbe5bc" translate="yes" xml:space="preserve">
          <source>It is possible to define which attributes should be saved when calling &lt;code&gt;save&lt;/code&gt;, by passing an array of column names.</source>
          <target state="translated">列名の配列を渡すことにより、 &lt;code&gt;save&lt;/code&gt; を呼び出すときに保存する属性を定義できます。</target>
        </trans-unit>
        <trans-unit id="74a71f5d94391e3a53655bde1f0b03cfbba3c3e0" translate="yes" xml:space="preserve">
          <source>It is very important to recognize that sequelize may make use of transactions internally for certain operations such as &lt;code&gt;Model.findOrCreate&lt;/code&gt;. If your hook functions execute read or write operations that rely on the object's presence in the database, or modify the object's stored values like the example in the preceding section, you should always specify &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt;.</source>
          <target state="translated">sequelizeは、 &lt;code&gt;Model.findOrCreate&lt;/code&gt; などの特定の操作で内部的にトランザクションを使用する場合があることを認識することが非常に重要です。フック関数がデータベース内のオブジェクトの存在に依存する読み取りまたは書き込み操作を実行する場合、または前のセクションの例のようにオブジェクトの格納された値を変更する場合は、常に &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt; 指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="8cbe639adc8bf73296a8d97150622ca8fa39f49f" translate="yes" xml:space="preserve">
          <source>It is very important to recognize that sequelize may make use of transactions internally for certain operations such as &lt;code&gt;Model.findOrCreate&lt;/code&gt;. If your hook functions execute read or write operations that rely on the object's presence in the database, or modify the object's stored values like the example in the preceding section, you should always specify &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt;:</source>
          <target state="translated">sequelizeは、 &lt;code&gt;Model.findOrCreate&lt;/code&gt; などの特定の操作のために内部的にトランザクションを利用する可能性があることを認識することが非常に重要です。フック関数がデータベース内のオブジェクトの存在に依存する読み取りまたは書き込み操作を実行する場合、または前のセクションの例のようにオブジェクトの格納された値を変更する場合は、常に &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt; 指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="1f7799cf6357af0cca9dd406aa99d1e281329530" translate="yes" xml:space="preserve">
          <source>It support includes. Only the includes that are marked as &lt;code&gt;required&lt;/code&gt; will be added to the count part:</source>
          <target state="translated">それはサポートが含まれています。 &lt;code&gt;required&lt;/code&gt; としてマークされているインクルードのみがカウント部分に追加されます。</target>
        </trans-unit>
        <trans-unit id="bd69590aa6bbe4480618acdf15708dead6c39e48" translate="yes" xml:space="preserve">
          <source>It works by simply converting the &lt;code&gt;commentableType&lt;/code&gt; string into a call to the correct mixin (either &lt;code&gt;getImage&lt;/code&gt; or &lt;code&gt;getVideo&lt;/code&gt;).</source>
          <target state="translated">これは、 &lt;code&gt;commentableType&lt;/code&gt; 文字列を正しいミックスイン（ &lt;code&gt;getImage&lt;/code&gt; または &lt;code&gt;getVideo&lt;/code&gt; のいずれか）への呼び出しに変換するだけで機能します。</target>
        </trans-unit>
        <trans-unit id="d2fa0eaed2c83826a4335df13a4096e1512c947c" translate="yes" xml:space="preserve">
          <source>It would be nice to have a simple way to obtain the &lt;em&gt;full name&lt;/em&gt; directly! We can combine the idea of &lt;code&gt;getters&lt;/code&gt; with the special data type Sequelize provides for this kind of situation: &lt;code&gt;DataTypes.VIRTUAL&lt;/code&gt;:</source>
          <target state="translated">&lt;em&gt;フルネームを&lt;/em&gt;直接取得する簡単な方法があると便利です。私たちは、アイデアの組み合わせることができます &lt;code&gt;getters&lt;/code&gt; ：Sequelizeはこのような状況のために提供して特殊なデータ型を持つ &lt;code&gt;DataTypes.VIRTUAL&lt;/code&gt; を：</target>
        </trans-unit>
        <trans-unit id="01152ec68278f8c0093062867b00c1b97313670b" translate="yes" xml:space="preserve">
          <source>It's also possible to define which attributes should be saved when calling &lt;code&gt;save&lt;/code&gt;, by passing an array of column names. This is useful when you set attributes based on a previously defined object. E.g. if you get the values of an object via a form of a web app. Furthermore this is used internally for &lt;code&gt;update&lt;/code&gt;. This is how it looks like:</source>
          <target state="translated">列名の配列を渡すことにより、 &lt;code&gt;save&lt;/code&gt; を呼び出すときにどの属性を保存するかを定義することもできます。これは、以前に定義されたオブジェクトに基づいて属性を設定するときに役立ちます。たとえば、Webアプリのフォームを介してオブジェクトの値を取得する場合などです。さらに、これは &lt;code&gt;update&lt;/code&gt; ために内部的に使用されます。これは次のようになります。</target>
        </trans-unit>
        <trans-unit id="186c4dfd035ca2147d8122391c159c1157303e72" translate="yes" xml:space="preserve">
          <source>It's also possible to generate complex AND/OR conditions by nesting sets of &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;and&lt;/code&gt;&lt;code&gt;Operators&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;or&lt;/code&gt; および &lt;code&gt;and&lt;/code&gt; &lt;code&gt;Operators&lt;/code&gt; セットをネストすることにより、複雑なAND / OR条件を生成することもできます。</target>
        </trans-unit>
        <trans-unit id="ad75613877702555cf316afa651fd68d8ed8a686" translate="yes" xml:space="preserve">
          <source>It's possible to do complex where queries with multiple levels of nested AND, OR and NOT conditions. In order to do that you can use &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt;&lt;code&gt;Operators&lt;/code&gt;:</source>
          <target state="translated">複数のレベルのネストされたAND、OR、およびNOT条件を含む複雑なwhereクエリを実行することは可能です。あなたが使用できることを行うために &lt;code&gt;or&lt;/code&gt; 、 &lt;code&gt;and&lt;/code&gt; または &lt;code&gt;not&lt;/code&gt; &lt;code&gt;Operators&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="33734b6b70c0dff634a36534b531693609e70498" translate="yes" xml:space="preserve">
          <source>Its only supported with PostgreSQL.</source>
          <target state="translated">PostgreSQLでのみサポートされています。</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="1f44599e616dde41701858fd22f0b746bfc3570b" translate="yes" xml:space="preserve">
          <source>JSON (SQLite, MySQL, MariaDB and PostgreSQL only)</source>
          <target state="translated">JSON(SQLite、MySQL、MariaDB、PostgreSQLのみ</target>
        </trans-unit>
        <trans-unit id="6a54171212861b9d4356ac5edc1e9c7b38716888" translate="yes" xml:space="preserve">
          <source>JSONB</source>
          <target state="translated">JSONB</target>
        </trans-unit>
        <trans-unit id="9cae984f3c9cd02acd6f6c61683bf9608c927849" translate="yes" xml:space="preserve">
          <source>JSONB (PostgreSQL only)</source>
          <target state="translated">JSONB(PostgreSQLのみ</target>
        </trans-unit>
        <trans-unit id="8f235f39a2853ef490db9713b7ebbf2012bdcd6a" translate="yes" xml:space="preserve">
          <source>JSONB can be queried in three different ways.</source>
          <target state="translated">JSONBは3つの方法で問い合わせができます。</target>
        </trans-unit>
        <trans-unit id="6b46dddcae84eab844147b41df08409aa05a20dc" translate="yes" xml:space="preserve">
          <source>JSONTYPE</source>
          <target state="translated">JSONTYPE</target>
        </trans-unit>
        <trans-unit id="1b6db652a7d2e721c6dbc04c119efa63e9efcd36" translate="yes" xml:space="preserve">
          <source>Just like Sequelize inferred the &lt;code&gt;Op.eq&lt;/code&gt; operator in the first example, here Sequelize inferred that the caller wanted an &lt;code&gt;AND&lt;/code&gt; for the two checks. The code above is equivalent to:</source>
          <target state="translated">Sequelizeが最初の例で &lt;code&gt;Op.eq&lt;/code&gt; 演算子を推測したように、ここでSequelizeは、呼び出し元が2つのチェックに &lt;code&gt;AND&lt;/code&gt; を必要としていると推測しました。上記のコードは次のものと同等です。</target>
        </trans-unit>
        <trans-unit id="90e0091ec5c2d29c031ee3793a2b88d1b8f7e828" translate="yes" xml:space="preserve">
          <source>Just like you use &lt;a href=&quot;https://en.wikipedia.org/wiki/Version_control&quot;&gt;version control&lt;/a&gt; systems such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Git&quot;&gt;Git&lt;/a&gt; to manage changes in your source code, you can use &lt;strong&gt;migrations&lt;/strong&gt; to keep track of changes to the database. With migrations you can transfer your existing database into another state and vice versa: Those state transitions are saved in migration files, which describe how to get to the new state and how to revert the changes in order to get back to the old state.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Git&quot;&gt;Git&lt;/a&gt;などの&lt;a href=&quot;https://en.wikipedia.org/wiki/Version_control&quot;&gt;バージョン管理&lt;/a&gt;システムを使用してソースコードの変更を管理するのと同じように、&lt;strong&gt;移行&lt;/strong&gt;を使用してデータベースへの変更を追跡できます。移行を使用すると、既存のデータベースを別の状態に移行したり、その逆を行ったりできます。これらの状態遷移は移行ファイルに保存され、新しい状態に移行する方法と、古い状態に戻すために変更を元に戻す方法が記述されています。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7bddeac6e43c3fc69422d0e6157627a2408995d" translate="yes" xml:space="preserve">
          <source>Just like you use Git / SVN to manage changes in your source code, you can use migrations to keep track of changes to the database. With migrations you can transfer your existing database into another state and vice versa: Those state transitions are saved in migration files, which describe how to get to the new state and how to revert the changes in order to get back to the old state.</source>
          <target state="translated">ソースコードの変更を管理するためにGit/SVNを使用するのと同じように、データベースへの変更を追跡するためにマイグレーションを使用することができます。移行では、既存のデータベースを別の状態に移行したり、その逆の状態に移行したりすることができます。状態遷移は移行ファイルに保存され、新しい状態に移行する方法と、古い状態に戻るために変更を元に戻す方法が記述されています。</target>
        </trans-unit>
        <trans-unit id="7a005acb56700e9225239e9495e645f1d56cb1fd" translate="yes" xml:space="preserve">
          <source>KEY_SHARE</source>
          <target state="translated">KEY_SHARE</target>
        </trans-unit>
        <trans-unit id="1aad7db5cd6d6405bc949aa858fe80dadf3e960b" translate="yes" xml:space="preserve">
          <source>Keep in mind, the provided range value can &lt;a href=&quot;data-types#range-types&quot;&gt;define the bound inclusion/exclusion&lt;/a&gt; as well.</source>
          <target state="translated">提供された範囲値は&lt;a href=&quot;data-types#range-types&quot;&gt;、バインドされた包含/除外&lt;/a&gt;も定義できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f136aea4f1c2a2fd3c7128a9df5a17d4667d4079" translate="yes" xml:space="preserve">
          <source>Lazy Loading example</source>
          <target state="translated">遅延読み込みの例</target>
        </trans-unit>
        <trans-unit id="a251ad95f6b7bd7655523b67ea7799fe5cf895ed" translate="yes" xml:space="preserve">
          <source>Learn more in the &lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-constructor-constructor&quot;&gt;API Reference for the Sequelize constructor&lt;/a&gt;. If you're connecting to the database from multiple processes, you'll have to create one instance per process, but each instance should have a maximum connection pool size of such that the total maximum size is respected. For example, if you want a max connection pool size of 90 and you have three processes, the Sequelize instance of each process should have a max connection pool size of 30.</source>
          <target state="translated">詳細&lt;a href=&quot;../class/lib/sequelize.js~sequelize#instance-constructor-constructor&quot;&gt;については、SequelizeコンストラクターのAPIリファレンスを&lt;/a&gt;ご覧ください。複数のプロセスからデータベースに接続する場合は、プロセスごとに1つのインスタンスを作成する必要がありますが、各インスタンスには、合計最大サイズが考慮されるような最大接続プールサイズが必要です。たとえば、90の最大接続プールサイズが必要で、3つのプロセスがある場合、各プロセスのSequelizeインスタンスの最大接続プールサイズは30にする必要があります。</target>
        </trans-unit>
        <trans-unit id="a92971ad92078a93938d1d32e8bcf667b401c1d8" translate="yes" xml:space="preserve">
          <source>Let's again use the example of Ships and Captains. Additionally, we will assume that Captain names are unique:</source>
          <target state="translated">もう一度、船と船長の例を使ってみましょう。さらに、船長の名前は一意であると仮定します。</target>
        </trans-unit>
        <trans-unit id="e70630a2a7c6ee7db84c3c444d456846c5656b46" translate="yes" xml:space="preserve">
          <source>Let's assume the following setup:</source>
          <target state="translated">以下のような設定を想定してみましょう。</target>
        </trans-unit>
        <trans-unit id="485d34bd5489f8e0226bedab13b81d0bca93aff5" translate="yes" xml:space="preserve">
          <source>Let's assume we have an empty database with a &lt;code&gt;User&lt;/code&gt; model which has a &lt;code&gt;username&lt;/code&gt; and a &lt;code&gt;job&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;username&lt;/code&gt; と &lt;code&gt;job&lt;/code&gt; を持つ &lt;code&gt;User&lt;/code&gt; モデルを持つ空のデータベースがあるとしましょう。</target>
        </trans-unit>
        <trans-unit id="385b4743ceb6a3534da7935e92d609b7f7527dd1" translate="yes" xml:space="preserve">
          <source>Let's assume we have three users, whose ages are 10, 5, and 40.</source>
          <target state="translated">ここでは、年齢が10歳、5歳、40歳の3人のユーザーがいるとします。</target>
        </trans-unit>
        <trans-unit id="6cce562eca4ce92817d991109132657b7b4e3ad1" translate="yes" xml:space="preserve">
          <source>Let's consider the models Ship and Captain in a simplified form, just to focus on the current topic, as shown below (less fields):</source>
          <target state="translated">ここでは、現在の話題に集中するためだけに、以下のように、船と船長のモデルを簡略化した形で考えてみましょう(分野が少ない)。</target>
        </trans-unit>
        <trans-unit id="a2203a28193ce384212442ecbf1bb9f0fad5d8a3" translate="yes" xml:space="preserve">
          <source>Let's create a model named &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;User&lt;/code&gt; という名前のモデルを作成してみましょう。</target>
        </trans-unit>
        <trans-unit id="f35d6d8183466326bcc0a6d0a3f462695c8d381b" translate="yes" xml:space="preserve">
          <source>Let's create a seed file which will add a demo user to our &lt;code&gt;User&lt;/code&gt; table.</source>
          <target state="translated">デモユーザーを &lt;code&gt;User&lt;/code&gt; テーブルに追加するシードファイルを作成しましょう。</target>
        </trans-unit>
        <trans-unit id="3ed6b05acdd3e3db0228fdc3709dee44638806dd" translate="yes" xml:space="preserve">
          <source>Let's fill our tables with some data:</source>
          <target state="translated">テーブルをデータで埋めてみましょう。</target>
        </trans-unit>
        <trans-unit id="be20a5757d775035047e08bf42879daa6e2f59aa" translate="yes" xml:space="preserve">
          <source>Let's first begin with a basic concept that you will see used in most associations, &lt;strong&gt;source&lt;/strong&gt; and &lt;strong&gt;target&lt;/strong&gt; model. Suppose you are trying to add an association between two Models. Here we are adding a &lt;code&gt;hasOne&lt;/code&gt; association between &lt;code&gt;User&lt;/code&gt; and &lt;code&gt;Project&lt;/code&gt;.</source>
          <target state="translated">最初に、ほとんどのアソシエーション、&lt;strong&gt;ソース&lt;/strong&gt;モデル、&lt;strong&gt;ターゲット&lt;/strong&gt;モデルで使用される基本的な概念から始めましょう。2つのモデル間の関連付けを追加しようとしていると仮定します。ここでは、 &lt;code&gt;User&lt;/code&gt; と &lt;code&gt;Project&lt;/code&gt; の間に &lt;code&gt;hasOne&lt;/code&gt; 関連付けを追加しています。</target>
        </trans-unit>
        <trans-unit id="1c450eed0e9c2a25ffab9271fad2fadc6b27a9d2" translate="yes" xml:space="preserve">
          <source>Let's introduce the ability to associate a product with many tags. Setting up the models could look like:</source>
          <target state="translated">ここでは、商品を多くのタグで関連付ける機能を紹介します。モデルを設定すると以下のようになります。</target>
        </trans-unit>
        <trans-unit id="87aac229dd1d4995475dbcc51641de5b2c4552f0" translate="yes" xml:space="preserve">
          <source>Let's modify last example to use &lt;code&gt;underscored&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;underscored&lt;/code&gt; オプションを使用するように最後の例を変更してみましょう。</target>
        </trans-unit>
        <trans-unit id="5a82db14e28117aaba1b3a12ce0a9553639d87b7" translate="yes" xml:space="preserve">
          <source>Let's say the name of the new datatype is &lt;code&gt;pg_new_type&lt;/code&gt; in the postgres database. That name has to be mapped to &lt;code&gt;DataTypes.NEWTYPE&lt;/code&gt;. Additionally, it is required to create a child postgres-specific datatype.</source>
          <target state="translated">新しいデータ型の名前がpostgresデータベースの &lt;code&gt;pg_new_type&lt;/code&gt; であるとしましょう。その名前は &lt;code&gt;DataTypes.NEWTYPE&lt;/code&gt; にマップする必要があります。さらに、子postgres固有のデータ型を作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="a6248e443874e08a90a46ab93360697f20a4e45c" translate="yes" xml:space="preserve">
          <source>Let's say the name of the new datatype is &lt;code&gt;pg_new_type&lt;/code&gt; in the postgres database. That name has to be mapped to &lt;code&gt;DataTypes.SOMETYPE&lt;/code&gt;. Additionally, it is required to create a child postgres-specific datatype.</source>
          <target state="translated">新しいデータ型の名前がpostgresデータベースの &lt;code&gt;pg_new_type&lt;/code&gt; であるとしましょう。その名前は &lt;code&gt;DataTypes.SOMETYPE&lt;/code&gt; にマップする必要があります。さらに、postgres固有の子データ型を作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="ae675e319f2445a495259e680916fd666189df3f" translate="yes" xml:space="preserve">
          <source>Let's say we have two models, &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt;. We want to establish a One-To-One relationship between Foo and Bar. We know that in a relational database, this will be done by establishing a foreign key in one of the tables. So in this case, a very relevant question is: in which table do we want this foreign key to be? In other words, do we want &lt;code&gt;Foo&lt;/code&gt; to have a &lt;code&gt;barId&lt;/code&gt; column, or should &lt;code&gt;Bar&lt;/code&gt; have a &lt;code&gt;fooId&lt;/code&gt; column instead?</source>
          <target state="translated">&lt;code&gt;Foo&lt;/code&gt; と &lt;code&gt;Bar&lt;/code&gt; の2つのモデルがあるとしましょう。FooとBarの間に1対1の関係を確立したいと考えています。リレーショナルデータベースでは、これはテーブルの1つに外部キーを確立することによって行われることがわかっています。したがって、この場合、非常に関連性の高い質問は次のとおりです。この外部キーをどのテーブルに配置しますか？言い換えると、 &lt;code&gt;Foo&lt;/code&gt; に &lt;code&gt;barId&lt;/code&gt; 列を持たせたいのでしょうか、 &lt;code&gt;fooId&lt;/code&gt; &lt;code&gt;Bar&lt;/code&gt; に代わりにfooId列を持たせるべきでしょうか？</target>
        </trans-unit>
        <trans-unit id="247cfd48c0ec826e4c2ab834edae66a5287577ad" translate="yes" xml:space="preserve">
          <source>Let's say we wanted to compute via SQL a &lt;code&gt;laughReactionsCount&lt;/code&gt; for each post. We can achieve that with a sub-query, such as the following:</source>
          <target state="translated">SQLを介して各投稿の &lt;code&gt;laughReactionsCount&lt;/code&gt; を計算したいとします。これは、次のようなサブクエリで実現できます。</target>
        </trans-unit>
        <trans-unit id="1923823b143c33ba8663b6d9fba34edbb5682fbc" translate="yes" xml:space="preserve">
          <source>Let's start with an example of a Many-to-Many relationship between &lt;code&gt;User&lt;/code&gt; and &lt;code&gt;Profile&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;User&lt;/code&gt; と &lt;code&gt;Profile&lt;/code&gt; 間の多対多の関係の例から始めましょう。</target>
        </trans-unit>
        <trans-unit id="45a0d37d2635e9d8af766d2643fce24860a449d3" translate="yes" xml:space="preserve">
          <source>Let's start with an example:</source>
          <target state="translated">まずは例を挙げてみましょう。</target>
        </trans-unit>
        <trans-unit id="46dbb18d37841e79a9d96e647e55be1608250c26" translate="yes" xml:space="preserve">
          <source>Let's start with installing CLI, you can find instructions &lt;a href=&quot;https://github.com/sequelize/cli&quot;&gt;here&lt;/a&gt;. Most preferred way is installing locally like this</source>
          <target state="translated">CLIのインストールから始めましょう。手順は&lt;a href=&quot;https://github.com/sequelize/cli&quot;&gt;ここにあります&lt;/a&gt;。最も好ましい方法は、このようにローカルにインストールすることです</target>
        </trans-unit>
        <trans-unit id="3dc80430a2ae5ef7084165f4e5c699da1d9acc78" translate="yes" xml:space="preserve">
          <source>Library for MariaDB is &lt;code&gt;mariadb&lt;/code&gt;.</source>
          <target state="translated">MariaDBのライブラリは &lt;code&gt;mariadb&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MITライセンスに基づいてライセンスされています。</target>
        </trans-unit>
        <trans-unit id="fa326bf4cc5351dc6d6da0f1e48826f37aa9639a" translate="yes" xml:space="preserve">
          <source>Like One-To-One relationships, &lt;code&gt;ON DELETE&lt;/code&gt; defaults to &lt;code&gt;SET NULL&lt;/code&gt; and &lt;code&gt;ON UPDATE&lt;/code&gt; defaults to &lt;code&gt;CASCADE&lt;/code&gt;.</source>
          <target state="translated">1対1の関係と同様に、 &lt;code&gt;ON DELETE&lt;/code&gt; デフォルトは &lt;code&gt;SET NULL&lt;/code&gt; あり、 &lt;code&gt;ON UPDATE&lt;/code&gt; デフォルトは &lt;code&gt;CASCADE&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4cf0ed70d28c5fe8dd844be088f6f6fd0468718b" translate="yes" xml:space="preserve">
          <source>Like every option for the definition of a model, this setting can also be changed globally with the &lt;code&gt;define&lt;/code&gt; option of the Sequelize constructor:</source>
          <target state="translated">モデルを定義するためのすべてのオプションと同様に、この設定は、Sequelizeコンストラクターの &lt;code&gt;define&lt;/code&gt; オプションを使用してグローバルに変更することもできます。</target>
        </trans-unit>
        <trans-unit id="c0f639fe70cb19d3a7d5bb33f35f4fcb35b0d6fb" translate="yes" xml:space="preserve">
          <source>Limit for result</source>
          <target state="translated">結果の制限</target>
        </trans-unit>
        <trans-unit id="1aeadbc7b1706711e989275655be9254c82690d6" translate="yes" xml:space="preserve">
          <source>Limit the joined rows, only supported with include.separate=true</source>
          <target state="translated">連結された行を制限し、include.separate=trueでのみサポートします。</target>
        </trans-unit>
        <trans-unit id="fda46d024f6ba85e7193174aeaa7d98a2bd9ca31" translate="yes" xml:space="preserve">
          <source>Limits and Pagination</source>
          <target state="translated">限界とページネーション</target>
        </trans-unit>
        <trans-unit id="c6fd3870c86e7422a0146e1e2a052437fb8e51e2" translate="yes" xml:space="preserve">
          <source>Lines</source>
          <target state="translated">Lines</target>
        </trans-unit>
        <trans-unit id="6038611e4627885d1cb51cbde6704232a5114027" translate="yes" xml:space="preserve">
          <source>List all enums (Postgres only)</source>
          <target state="translated">すべての列挙形式をリストアップ(Postgresのみ</target>
        </trans-unit>
        <trans-unit id="9dab3b0aa2150bf658272546827c1ef560b7cbe7" translate="yes" xml:space="preserve">
          <source>List of attributes to add index on</source>
          <target state="translated">インデックスを追加する属性のリスト</target>
        </trans-unit>
        <trans-unit id="3ce91f8ce5685aa3c7ae6bebf7959c99739d2884" translate="yes" xml:space="preserve">
          <source>List of declared variables. Each variable should be an object with string fields &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt;, and optionally having a &lt;code&gt;default&lt;/code&gt; field as well.</source>
          <target state="translated">宣言された変数のリスト。各変数は、文字列フィールド &lt;code&gt;type&lt;/code&gt; および &lt;code&gt;name&lt;/code&gt; を持つオブジェクトであり、オプションで &lt;code&gt;default&lt;/code&gt; フィールドも持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="075dd91e787bf6243a7752780ea0c8bba33ec184" translate="yes" xml:space="preserve">
          <source>List of objects (key/value pairs) to create instances from</source>
          <target state="translated">インスタンスを作成するオブジェクト(キーと値のペア)のリスト</target>
        </trans-unit>
        <trans-unit id="efd6defff3588a82427cedf6cb66687edafa5f0a" translate="yes" xml:space="preserve">
          <source>List of parameters declared for SQL function</source>
          <target state="translated">SQL関数のために宣言されたパラメータのリスト</target>
        </trans-unit>
        <trans-unit id="a01e2b9e9c9931427b664651a40032e3447516ac" translate="yes" xml:space="preserve">
          <source>List of records to insert</source>
          <target state="translated">挿入するレコードの一覧</target>
        </trans-unit>
        <trans-unit id="756dc1b93051a84503f4ee0647cfc663c3af6b9d" translate="yes" xml:space="preserve">
          <source>List of table to skip</source>
          <target state="translated">スキップするテーブル一覧</target>
        </trans-unit>
        <trans-unit id="a516eb0d586f3d22305a538c09c709ee6782c824" translate="yes" xml:space="preserve">
          <source>Load further nested related models</source>
          <target state="translated">ネストされた関連モデルをさらに読み込む</target>
        </trans-unit>
        <trans-unit id="59da4a73b5ff707274f5f8bd4f63543247b04f15" translate="yes" xml:space="preserve">
          <source>Lock the selected rows. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. Postgres also supports transaction.LOCK.KEY_SHARE, transaction.LOCK.NO_KEY_UPDATE and specific model locks with joins.</source>
          <target state="translated">選択した行をロックします。可能なオプションは、transaction.LOCK.UPDATEとtransaction.LOCK.SHAREです。Postgresはまた、transaction.LOCK.KEY_SHARE、transaction.LOCK.NO_KEY_UPDATE、および結合による特定のモデルロックもサポートしています。</target>
        </trans-unit>
        <trans-unit id="3c9c5fc6308d5bcf9e048b826209d636266946b5" translate="yes" xml:space="preserve">
          <source>Lock the selected rows. Possible options are transaction.LOCK.UPDATE and transaction.LOCK.SHARE. Postgres also supports transaction.LOCK.KEY_SHARE, transaction.LOCK.NO_KEY_UPDATE and specific model locks with joins. See &lt;a href=&quot;../../transaction#lock&quot;&gt;transaction.LOCK for an example&lt;/a&gt;</source>
          <target state="translated">選択した行をロックします。可能なオプションは、transaction.LOCK.UPDATEおよびtransaction.LOCK.SHAREです。Postgresは、transaction.LOCK.KEY_SHARE、transaction.LOCK.NO_KEY_UPDATE、および結合による特定のモデルロックもサポートしています。&lt;a href=&quot;../../transaction#lock&quot;&gt;例については、transaction.LOCKを&lt;/a&gt;参照してください</target>
        </trans-unit>
        <trans-unit id="01175ae5bc13842f1a68f275d49e45971292d2c1" translate="yes" xml:space="preserve">
          <source>Locks</source>
          <target state="translated">Locks</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="782833b03e63a64afaf4091b1f757a4976389ff7" translate="yes" xml:space="preserve">
          <source>Logical combinations with operators</source>
          <target state="translated">演算子との論理的な組み合わせ</target>
        </trans-unit>
        <trans-unit id="381f51fe7d2e48a40efecb0f6ec5b0e10560328f" translate="yes" xml:space="preserve">
          <source>MACADDR</source>
          <target state="translated">MACADDR</target>
        </trans-unit>
        <trans-unit id="fb533649ca2f9e73b11b6bb948adb363f958ac9f" translate="yes" xml:space="preserve">
          <source>MEDIUMINT</source>
          <target state="translated">MEDIUMINT</target>
        </trans-unit>
        <trans-unit id="5e10df029a02645d6284a04ec967bdb813352d80" translate="yes" xml:space="preserve">
          <source>MSSQL</source>
          <target state="translated">MSSQL</target>
        </trans-unit>
        <trans-unit id="9bc51354ceb63788d1d163c25b7f34fd57ef467b" translate="yes" xml:space="preserve">
          <source>MSSQL - Implemented as a single query using &lt;code&gt;MERGE&lt;/code&gt; and &lt;code&gt;WHEN (NOT) MATCHED THEN&lt;/code&gt;</source>
          <target state="translated">MSSQL- &lt;code&gt;MERGE&lt;/code&gt; および &lt;code&gt;WHEN (NOT) MATCHED THEN&lt;/code&gt; を使用して単一のクエリとして実装されます</target>
        </trans-unit>
        <trans-unit id="d338a8206f4d51fb083279011e9504adb9b8bc21" translate="yes" xml:space="preserve">
          <source>MSSQL - Implemented as a single query using &lt;code&gt;MERGE&lt;/code&gt; and &lt;code&gt;WHEN (NOT) MATCHED THEN&lt;/code&gt;&lt;strong&gt;Note&lt;/strong&gt; that SQLite returns undefined for created, no matter if the row was created or updated. This is because SQLite always runs INSERT OR IGNORE + UPDATE, in a single query, so there is no way to know whether the row was inserted or not.</source>
          <target state="translated">MSSQL -使用して単一のクエリとして実装 &lt;code&gt;MERGE&lt;/code&gt; をし、 &lt;code&gt;WHEN (NOT) MATCHED THEN&lt;/code&gt; &lt;strong&gt;注意&lt;/strong&gt;行が作成または更新された場合、SQLiteのリターンは、作成のために関係なく未定義こと。これは、SQLiteが常にINSERT OR IGNORE + UPDATEを単一のクエリで実行するため、行が挿入されたかどうかを確認する方法がないためです。</target>
        </trans-unit>
        <trans-unit id="956a5f56cb9c9af927343b5e2c11e9cb376ea54d" translate="yes" xml:space="preserve">
          <source>MSSQL - Implemented with MERGE statement</source>
          <target state="translated">MSSQL-MERGE 文で実装されています。</target>
        </trans-unit>
        <trans-unit id="f72f32142883a0751ac59485e9ed4435c156afa8" translate="yes" xml:space="preserve">
          <source>MSSQL Domain Account</source>
          <target state="translated">MSSQLドメインアカウント</target>
        </trans-unit>
        <trans-unit id="ffc76c03c5b6645c32d955829051a1f79970d940" translate="yes" xml:space="preserve">
          <source>MSSQL does not have a JSON data type, however it does provide some support for JSON stored as strings through certain functions since SQL Server 2016. Using these functions, you will be able to query the JSON stored in the string, but any returned values will need to be parsed seperately.</source>
          <target state="translated">MSSQLにはJSONデータ型はありませんが、SQL Server 2016以降、特定の関数を通じて文字列として格納されたJSONのサポートがいくつか提供されています。これらの関数を使用すると、文字列に格納されている JSON を問い合わせることができますが、返される値は個別に解析する必要があります。</target>
        </trans-unit>
        <trans-unit id="991df59282ae7659f4a3c3ddbd655d8dab601328" translate="yes" xml:space="preserve">
          <source>MSSQL does not have a JSON data type, however it does provide support for JSON stored as strings through certain functions since SQL Server 2016. Using these functions, you will be able to query the JSON stored in the string, but any returned values will need to be parsed seperately.</source>
          <target state="translated">MSSQLにはJSONデータ型はありませんが、SQL Server 2016以降、特定の関数を通じて文字列として格納されたJSONのサポートが提供されています。これらの関数を使用すると、文字列に格納されている JSON を問い合わせることができますが、返される値は個別に解析する必要があります。</target>
        </trans-unit>
        <trans-unit id="6703c01658bb865ea0ff8c363ba27924e5404966" translate="yes" xml:space="preserve">
          <source>MSSqlQueryInterface</source>
          <target state="translated">MSSqlQueryInterface</target>
        </trans-unit>
        <trans-unit id="1a90749e4a5e44c43a2bf4e5bc2ac3049b922dc7" translate="yes" xml:space="preserve">
          <source>Make sure you have read the &lt;a href=&quot;assocs&quot;&gt;associations guide&lt;/a&gt; before reading this guide.</source>
          <target state="translated">このガイドを読む前に、&lt;a href=&quot;assocs&quot;&gt;関連付けガイド&lt;/a&gt;を読んだことを確認してください。</target>
        </trans-unit>
        <trans-unit id="a2b1fa2c3a6d1e1afc6275611ca02b5fdffb139c" translate="yes" xml:space="preserve">
          <source>Managed transaction (auto-callback)</source>
          <target state="translated">管理されたトランザクション(オートコールバック</target>
        </trans-unit>
        <trans-unit id="efd23a483237824d33fd7aeb0a683e7d900ced3a" translate="yes" xml:space="preserve">
          <source>Managed transactions</source>
          <target state="translated">管理された取引</target>
        </trans-unit>
        <trans-unit id="8ea330d8bd2304f1ff715165a6ab5db327917663" translate="yes" xml:space="preserve">
          <source>Managed transactions handle committing or rolling back the transaction automatically. You start a managed transaction by passing a callback to &lt;code&gt;sequelize.transaction&lt;/code&gt;.</source>
          <target state="translated">管理対象トランザクションは、トランザクションのコミットまたはロールバックを自動的に処理します。 &lt;code&gt;sequelize.transaction&lt;/code&gt; にコールバックを渡すことにより、マネージトランザクションを開始します。</target>
        </trans-unit>
        <trans-unit id="cf4a88893f31215fb91305e2be0bf2c592abe7d5" translate="yes" xml:space="preserve">
          <source>Managed transactions handle committing or rolling back the transaction automatically. You start a managed transaction by passing a callback to &lt;code&gt;sequelize.transaction&lt;/code&gt;. This callback can be &lt;code&gt;async&lt;/code&gt; (and usually is).</source>
          <target state="translated">管理対象トランザクションは、トランザクションのコミットまたはロールバックを自動的に処理します。 &lt;code&gt;sequelize.transaction&lt;/code&gt; にコールバックを渡すことにより、マネージドトランザクションを開始します。このコールバックは &lt;code&gt;async&lt;/code&gt; することができます（通常は非同期です）。</target>
        </trans-unit>
        <trans-unit id="7a382444e6e34d9981178bcdc862fa5fcb7b87a2" translate="yes" xml:space="preserve">
          <source>Mandatory versus optional associations</source>
          <target state="translated">強制的な連想と任意の連想</target>
        </trans-unit>
        <trans-unit id="0cc59cf8eacc13611e26eb5e7be4726fc40e2011" translate="yes" xml:space="preserve">
          <source>Manipulating the dataset with limit, offset, order and group</source>
          <target state="translated">リミット、オフセット、オーダー、グループによるデータセットの操作</target>
        </trans-unit>
        <trans-unit id="4e836fdc2572ab23d5dc8c36bd613ac6b0f82d63" translate="yes" xml:space="preserve">
          <source>Manual</source>
          <target state="translated">Manual</target>
        </trans-unit>
        <trans-unit id="7b28fe193489f8eb6f6c57f32d0833039b082a4e" translate="yes" xml:space="preserve">
          <source>Many model operations in Sequelize allow you to specify a transaction in the options parameter of the method. If a transaction &lt;em&gt;is&lt;/em&gt; specified in the original call, it will be present in the options parameter passed to the hook function. For example, consider the following snippet:</source>
          <target state="translated">Sequelizeの多くのモデル操作では、メソッドのoptionsパラメーターでトランザクションを指定できます。元の呼び出しでトランザクション&lt;em&gt;が&lt;/em&gt;指定されている場合、そのトランザクション&lt;em&gt;は&lt;/em&gt;フック関数に渡されるオプションパラメーターに存在します。たとえば、次のスニペットについて考えてみます。</target>
        </trans-unit>
        <trans-unit id="f51460ac150e0ccb3c2cf161d1a8b2874ae7cd94" translate="yes" xml:space="preserve">
          <source>Many-To-Many associations connect one source with multiple targets, while all these targets can in turn be connected to other sources beyond the first.</source>
          <target state="translated">多対多の関連付けは、1つのソースを複数のターゲットに接続し、これらすべてのターゲットは、順番に最初のソースを超えて他のソースに接続することができます。</target>
        </trans-unit>
        <trans-unit id="255edf6f7cad57a7fe58479df122a2f372fd2daa" translate="yes" xml:space="preserve">
          <source>Many-To-Many relationships</source>
          <target state="translated">多対多の関係</target>
        </trans-unit>
        <trans-unit id="bda986cd10b1abae1d39002fb10d8505215cc8d5" translate="yes" xml:space="preserve">
          <source>Many-to-Many associations</source>
          <target state="translated">多対多の会</target>
        </trans-unit>
        <trans-unit id="377bf4b05aa29004e36d9244e2d88732601654cd" translate="yes" xml:space="preserve">
          <source>Many-to-many association with a join table.</source>
          <target state="translated">ジョインテーブルとの多対多の関連付け。</target>
        </trans-unit>
        <trans-unit id="d7204c50e7ff3946b04de7b1b82e6e3402f44d27" translate="yes" xml:space="preserve">
          <source>Many-to-many-to-many relationships and beyond</source>
          <target state="translated">多対多の関係とその先にあるもの</target>
        </trans-unit>
        <trans-unit id="a2c278e4b750406933592c346d173c2e67747cad" translate="yes" xml:space="preserve">
          <source>Map returned fields to arbitrary names for &lt;code&gt;SELECT&lt;/code&gt; query type.</source>
          <target state="translated">返されたフィールドを &lt;code&gt;SELECT&lt;/code&gt; クエリタイプの任意の名前にマップします。</target>
        </trans-unit>
        <trans-unit id="be596405e95a78e6e3fd716d1f964da33dac24e3" translate="yes" xml:space="preserve">
          <source>Map returned fields to model's fields if &lt;code&gt;options.model&lt;/code&gt; or &lt;code&gt;options.instance&lt;/code&gt; is present. Mapping will occur before building the model instance.</source>
          <target state="translated">&lt;code&gt;options.model&lt;/code&gt; または &lt;code&gt;options.instance&lt;/code&gt; が存在する場合、返されたフィールドをモデルのフィールドにマップします。モデルインスタンスを構築する前にマッピングが行われます。</target>
        </trans-unit>
        <trans-unit id="7f00002bb6ad2eec19a19de8a03c7d6fad15adff" translate="yes" xml:space="preserve">
          <source>MariaDB</source>
          <target state="translated">MariaDB</target>
        </trans-unit>
        <trans-unit id="8f7e6ef50178ceaac3c27a6e48b1989cccb85ff6" translate="yes" xml:space="preserve">
          <source>Mark the include as duplicating, will prevent a subquery from being used.</source>
          <target state="translated">インクルードを重複するものとしてマークすると、副問い合わせが使用されるのを防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="1da7a96c09b4e4634e58cd74016bd7905cd29f3a" translate="yes" xml:space="preserve">
          <source>Match a regex against the database name before syncing, a safety check for cases where force: true is used in tests but not live code</source>
          <target state="translated">同期前にデータベース名と正規表現を一致させます。 force:true がテストでは使用されているがライブコードでは使用されていない場合の安全チェックです。</target>
        </trans-unit>
        <trans-unit id="47f4c6f36bdf82bb2ab12a74bce5359bd3e3baea" translate="yes" xml:space="preserve">
          <source>Maximum number of connection in pool</source>
          <target state="translated">プール内の最大接続数</target>
        </trans-unit>
        <trans-unit id="97738b59f60343e4146991bad8d071fcf74e0ab8" translate="yes" xml:space="preserve">
          <source>Member Summary</source>
          <target state="translated">メンバーの概要</target>
        </trans-unit>
        <trans-unit id="40de0d4de887a374168bf79e72c7aa0fa4594d6e" translate="yes" xml:space="preserve">
          <source>Merging</source>
          <target state="translated">Merging</target>
        </trans-unit>
        <trans-unit id="5646c6f729482a25c89d910db627247645097c06" translate="yes" xml:space="preserve">
          <source>Merging includes</source>
          <target state="translated">合併には以下のものが含まれます。</target>
        </trans-unit>
        <trans-unit id="8102ea6074090f4681ab70e02ebe6ece740ec91c" translate="yes" xml:space="preserve">
          <source>Method Summary</source>
          <target state="translated">方法の概要</target>
        </trans-unit>
        <trans-unit id="7ee71f3365c47f24bea17f31665feff788530ffb" translate="yes" xml:space="preserve">
          <source>Migration Skeleton</source>
          <target state="translated">マイグレーションスケルトン</target>
        </trans-unit>
        <trans-unit id="c32d7ce630147bbc439f44b57c3dd404394c0d9b" translate="yes" xml:space="preserve">
          <source>Migration Storage</source>
          <target state="translated">移行ストレージ</target>
        </trans-unit>
        <trans-unit id="dca984afd74a0089c1d5a5816e4de2e8d46a60b5" translate="yes" xml:space="preserve">
          <source>Migrations</source>
          <target state="translated">Migrations</target>
        </trans-unit>
        <trans-unit id="fdaa1ef022ef7283a9b451dc1daff1a42f1e129d" translate="yes" xml:space="preserve">
          <source>Minimum number of connection in pool</source>
          <target state="translated">プール内の最小接続数</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="68c2cc7f0ceaa3e499ecb4db331feb4debbbcc23" translate="yes" xml:space="preserve">
          <source>Model</source>
          <target state="translated">Model</target>
        </trans-unit>
        <trans-unit id="f7df454559e3e51dd82ed08eb44e624585cc847f" translate="yes" xml:space="preserve">
          <source>Model Basics</source>
          <target state="translated">モデルの基本</target>
        </trans-unit>
        <trans-unit id="6ba72d12de465e9cad9bceff0ef74b878438e5dd" translate="yes" xml:space="preserve">
          <source>Model Basics: Data Types</source>
          <target state="translated">モデルの基本 データ型</target>
        </trans-unit>
        <trans-unit id="2c3701236af5fee2b21ede6278c55f7d87ab5faa" translate="yes" xml:space="preserve">
          <source>Model Definition</source>
          <target state="translated">モデル定義</target>
        </trans-unit>
        <trans-unit id="dfb4a7c9ed8c301f3a5fc24c730323523bf1ad37" translate="yes" xml:space="preserve">
          <source>Model Instances</source>
          <target state="translated">モデルインスタンス</target>
        </trans-unit>
        <trans-unit id="3772716291a8cbb522644aacea1786a0d6e479f9" translate="yes" xml:space="preserve">
          <source>Model Querying - Basics</source>
          <target state="translated">モデルクエリ-基本</target>
        </trans-unit>
        <trans-unit id="ce9c9978a8a2df228a768a8ded385b6536bc5125" translate="yes" xml:space="preserve">
          <source>Model Querying - Finders</source>
          <target state="translated">モデルクエリ-ファインダーズ</target>
        </trans-unit>
        <trans-unit id="4142158426158729ca79c5ce805fd286f210430c" translate="yes" xml:space="preserve">
          <source>Model definition</source>
          <target state="translated">モデル定義</target>
        </trans-unit>
        <trans-unit id="d5b42cbdc48b29ec85aa8da6533d3aa5c7e63a91" translate="yes" xml:space="preserve">
          <source>Model hooks</source>
          <target state="translated">モデルフック</target>
        </trans-unit>
        <trans-unit id="0a75c07ee5b0146bfd4157f900acbbac80d86138" translate="yes" xml:space="preserve">
          <source>Model instances operate with the concept of a &lt;code&gt;dataValues&lt;/code&gt; property, which stores the actual values represented by the instance. By default, the values from dataValues can also be accessed directly from the Instance, that is:</source>
          <target state="translated">モデルインスタンスは、インスタンスによって表される実際の値を格納する &lt;code&gt;dataValues&lt;/code&gt; プロパティの概念で動作します。デフォルトでは、dataValuesの値はインスタンスから直接アクセスすることもできます。</target>
        </trans-unit>
        <trans-unit id="e25e0f1340cca1f16eb599887037699a0de49610" translate="yes" xml:space="preserve">
          <source>Model synchronization</source>
          <target state="translated">モデルの同期化</target>
        </trans-unit>
        <trans-unit id="b86c2670dd4b42d8a914c0eec8b73c34afe4cef4" translate="yes" xml:space="preserve">
          <source>Model to upsert on</source>
          <target state="translated">アップサートするモデル</target>
        </trans-unit>
        <trans-unit id="a07e44c48da57fac1360b4b859e20027ab13a678" translate="yes" xml:space="preserve">
          <source>Model usage</source>
          <target state="translated">モデルの使用方法</target>
        </trans-unit>
        <trans-unit id="a53b41efe74bb25e6882a6eee3070bdffdb51b7f" translate="yes" xml:space="preserve">
          <source>Model validations allow you to specify format/content/inheritance validations for each attribute of the model.</source>
          <target state="translated">モデルバリデーションでは、モデルの各属性に対してフォーマット/コンテンツ/継承のバリデーションを指定することができます。</target>
        </trans-unit>
        <trans-unit id="21ce518813b59ff7892d35ddffbbfb5e60400474" translate="yes" xml:space="preserve">
          <source>Model validator methods are called with the model object's context and are deemed to fail if they throw an error, otherwise pass. This is just the same as with custom field-specific validators.</source>
          <target state="translated">モデルバリデータのメソッドはモデルオブジェクトのコンテキストで呼び出され、エラーが発生した場合は失敗とみなされ、そうでなければパスとみなされます。これはカスタムフィールド固有のバリデータと同じです。</target>
        </trans-unit>
        <trans-unit id="02ac210a5e2d429034fe9027e0149e7f0e54c5b1" translate="yes" xml:space="preserve">
          <source>Model validators allow you to specify format/content/inheritance validations for each attribute of the model. Validations are automatically run on &lt;code&gt;create&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;save&lt;/code&gt;. You can also call &lt;code&gt;validate()&lt;/code&gt; to manually validate an instance.</source>
          <target state="translated">モデルバリデーターを使用すると、モデルの各属性のフォーマット/コンテンツ/継承の検証を指定できます。検証は、 &lt;code&gt;create&lt;/code&gt; 、 &lt;code&gt;update&lt;/code&gt; 、 &lt;code&gt;save&lt;/code&gt; 自動的に実行されます。 &lt;code&gt;validate()&lt;/code&gt; を呼び出して、インスタンスを手動で検証することもできます。</target>
        </trans-unit>
        <trans-unit id="a823acb606efcdb0eb853730193b3ca0d95a9686" translate="yes" xml:space="preserve">
          <source>Model#create for a full explanation of options</source>
          <target state="translated">オプションの詳細な説明は Model#create を参照してください。</target>
        </trans-unit>
        <trans-unit id="8af76ef4fdb319b9698a20f8340797dab906080c" translate="yes" xml:space="preserve">
          <source>Model#get</source>
          <target state="translated">Model#get</target>
        </trans-unit>
        <trans-unit id="3cb30668d05a4e893eb0a96404decd8e56821285" translate="yes" xml:space="preserve">
          <source>Model#reload</source>
          <target state="translated">Model#reload</target>
        </trans-unit>
        <trans-unit id="4f584a3efe16470d969227bf5c8fd863f8da7ead" translate="yes" xml:space="preserve">
          <source>Model#save</source>
          <target state="translated">Model#save</target>
        </trans-unit>
        <trans-unit id="4d5283314738ecf76503ebc98257bde975737cb3" translate="yes" xml:space="preserve">
          <source>Model#set</source>
          <target state="translated">Model#set</target>
        </trans-unit>
        <trans-unit id="7fcf673bb86044c610823a0d2fc30026edfb6398" translate="yes" xml:space="preserve">
          <source>Model#where</source>
          <target state="translated">Model#where</target>
        </trans-unit>
        <trans-unit id="9e763be04a0228a99af47fdea7072bbd2305daba" translate="yes" xml:space="preserve">
          <source>Model-wide validations</source>
          <target state="translated">モデル全体の検証</target>
        </trans-unit>
        <trans-unit id="8253b756d3ad33e6e7017ccdafc1a90fc90f96c7" translate="yes" xml:space="preserve">
          <source>Model.belongsTo</source>
          <target state="translated">Model.belongsTo</target>
        </trans-unit>
        <trans-unit id="454a1355d18fe035a3d709bc71b45145b8aa70a6" translate="yes" xml:space="preserve">
          <source>Model.belongsToMany</source>
          <target state="translated">Model.belongsToMany</target>
        </trans-unit>
        <trans-unit id="338a4bdb9701251c42339f0107d0cab2dfc70bd6" translate="yes" xml:space="preserve">
          <source>Model.build</source>
          <target state="translated">Model.build</target>
        </trans-unit>
        <trans-unit id="e1b94c3211965ce0df3e43428bf03ab75c9411f6" translate="yes" xml:space="preserve">
          <source>Model.findAll</source>
          <target state="translated">Model.findAll</target>
        </trans-unit>
        <trans-unit id="e1b2d659c60c1fcfe515ae54f50c22008b1758d0" translate="yes" xml:space="preserve">
          <source>Model.hasMany</source>
          <target state="translated">Model.hasMany</target>
        </trans-unit>
        <trans-unit id="4c16d25a9fc250497c7ca38d6f46e1f59a466e24" translate="yes" xml:space="preserve">
          <source>Model.hasOne</source>
          <target state="translated">Model.hasOne</target>
        </trans-unit>
        <trans-unit id="fae0e3c371dd4093bef01bf73725ab76001c9cc8" translate="yes" xml:space="preserve">
          <source>Model.increment</source>
          <target state="translated">Model.increment</target>
        </trans-unit>
        <trans-unit id="098dd694d5c2ce27262982062cf5e8f57cabde98" translate="yes" xml:space="preserve">
          <source>Model.save</source>
          <target state="translated">Model.save</target>
        </trans-unit>
        <trans-unit id="fefb16c53c032c568ad0842061992d2b085291e3" translate="yes" xml:space="preserve">
          <source>Model.schema</source>
          <target state="translated">Model.schema</target>
        </trans-unit>
        <trans-unit id="c9a517d625d0bd2320f055ed68c71f3399c8a1e1" translate="yes" xml:space="preserve">
          <source>Modeling a table</source>
          <target state="translated">テーブルのモデリング</target>
        </trans-unit>
        <trans-unit id="b8ac15e7b4962a2e2baf204f84d2215049c4ac38" translate="yes" xml:space="preserve">
          <source>Models are stored here under the name given to &lt;code&gt;sequelize.define&lt;/code&gt;</source>
          <target state="translated">モデルは、 &lt;code&gt;sequelize.define&lt;/code&gt; に付けられた名前でここに保存されます</target>
        </trans-unit>
        <trans-unit id="c727fdba9c6de6b2fe8de1b8f77c33c570c5c601" translate="yes" xml:space="preserve">
          <source>Models are the essence of Sequelize. A model is an abstraction that represents a table in your database. In Sequelize, it is a class that extends &lt;a href=&quot;../class/lib/model.js~model&quot;&gt;Model&lt;/a&gt;.</source>
          <target state="translated">モデルはSequelizeの本質です。モデルは、データベース内のテーブルを表す抽象化です。Sequelizeでは、&lt;a href=&quot;../class/lib/model.js~model&quot;&gt;Model&lt;/a&gt;を拡張するクラスです。</target>
        </trans-unit>
        <trans-unit id="fd2a29e4791870980efc40189fe35f3704588220" translate="yes" xml:space="preserve">
          <source>Models can be defined in two equivalent ways in Sequelize:</source>
          <target state="translated">モデルは、Sequelizeでは2つの同等の方法で定義できます。</target>
        </trans-unit>
        <trans-unit id="075942798c880b98382f962a35807f50bbbc83f7" translate="yes" xml:space="preserve">
          <source>Models recap (with minor rename)</source>
          <target state="translated">モデルの再録(マイナーな名前変更あり</target>
        </trans-unit>
        <trans-unit id="04fba751c15248f028f90d7497411d6a81a5899c" translate="yes" xml:space="preserve">
          <source>Models should be defined with the singular form of a word. Example:</source>
          <target state="translated">モデルは単語の単数形で定義する必要があります。例)モデルは、単語の単数形で定義します。</target>
        </trans-unit>
        <trans-unit id="cc9169ab2687ee0ff11fb74d9665fc408f0ddcdc" translate="yes" xml:space="preserve">
          <source>More examples, &lt;a href=&quot;https://sequelize.org/manual/tutorial/models-definition.html&quot;&gt;Model Definition&lt;/a&gt;</source>
          <target state="translated">その他の例、&lt;a href=&quot;https://sequelize.org/manual/tutorial/models-definition.html&quot;&gt;モデル定義&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7e49c63d7a388fe61b0e185917e856c5555045a" translate="yes" xml:space="preserve">
          <source>More scopes, defined in the same way as defaultScope above. See &lt;code&gt;Model.scope&lt;/code&gt; for more information about how scopes are defined, and what you can do with them</source>
          <target state="translated">上記のdefaultScopeと同じ方法で定義されたより多くのスコープ。スコープがどのように定義されるか、およびスコープで何ができるかについての詳細は、 &lt;code&gt;Model.scope&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="06e96031e3182ce6001f4ff143c003c41585330f" translate="yes" xml:space="preserve">
          <source>Most likely the type you are trying to implement is already included in &lt;a href=&quot;data-types&quot;&gt;DataTypes&lt;/a&gt;. If a new datatype is not included, this manual will show how to write it yourself.</source>
          <target state="translated">ほとんどの場合、実装しようとしている型はすでに&lt;a href=&quot;data-types&quot;&gt;DataTypesに&lt;/a&gt;含まれています。新しいデータ型が含まれていない場合、このマニュアルでは、自分で書き込む方法を示します。</target>
        </trans-unit>
        <trans-unit id="a2e042750a218382f40539a75f466ae08b86fd02" translate="yes" xml:space="preserve">
          <source>Most of the methods provided by Sequelize are asynchronous and therefore return Promises. They are all &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promises&lt;/a&gt; , so you can use the Promise API (for example, using &lt;code&gt;then&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;finally&lt;/code&gt;) out of the box.</source>
          <target state="translated">Sequelizeが提供するメソッドのほとんどは非同期であるため、Promisesを返します。これらはすべて&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promises&lt;/a&gt;であるため、そのままでPromise APIを使用できます（たとえば、 &lt;code&gt;then&lt;/code&gt; 、 &lt;code&gt;catch&lt;/code&gt; 、 &lt;code&gt;finally&lt;/code&gt; を使用）。</target>
        </trans-unit>
        <trans-unit id="230cf74579a3d48af5a5cd7d6655bb5d75b0b4f5" translate="yes" xml:space="preserve">
          <source>Multiple associations involving the same models</source>
          <target state="translated">同じモデルを含む複数の関連付け</target>
        </trans-unit>
        <trans-unit id="e58a5e3c53097f103b187782be91e04647ca8ad3" translate="yes" xml:space="preserve">
          <source>Multiple checks can be passed:</source>
          <target state="translated">複数のチェックを通過することができます。</target>
        </trans-unit>
        <trans-unit id="08972958953b98e98cd5adab4847330ad1dd0d5b" translate="yes" xml:space="preserve">
          <source>Multiple eager loading</source>
          <target state="translated">複数の熱心なローディング</target>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="d9d495ec80ad0df93c05d8abe97089135bb60400" translate="yes" xml:space="preserve">
          <source>MySQL - Implemented as a single query &lt;code&gt;INSERT values ON DUPLICATE KEY UPDATE values&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;INSERT values ON DUPLICATE KEY UPDATE values&lt;/code&gt; 単一のクエリとして実装され、DUPLICATE KEY UPDATE値のINSERT値</target>
        </trans-unit>
        <trans-unit id="6c61b404af35e65eef2408a54386185fe7cd1608" translate="yes" xml:space="preserve">
          <source>MySQL - Implemented with ON DUPLICATE KEY UPDATE</source>
          <target state="translated">MySQL-ON DUPLICATE KEY UPDATE で実装されています。</target>
        </trans-unit>
        <trans-unit id="e54a5ac6d1edc357120fc2fb5937828673dff167" translate="yes" xml:space="preserve">
          <source>MySQL - Implemented with ON DUPLICATE KEY UPDATE`</source>
          <target state="translated">MySQL-ON DUPLICATE KEY UPDATE` で実装。</target>
        </trans-unit>
        <trans-unit id="dccbb9f724ea55c302c425254e9a27fbcda76836" translate="yes" xml:space="preserve">
          <source>MySQLQueryInterface</source>
          <target state="translated">MySQLQueryInterface</target>
        </trans-unit>
        <trans-unit id="cd408e0f9d0af499eda4bb5b3feec4a587a895de" translate="yes" xml:space="preserve">
          <source>NOEXPAND</source>
          <target state="translated">NOEXPAND</target>
        </trans-unit>
        <trans-unit id="75b8d58ed5ac16a53fb00f7e374f5a6e16d7f254" translate="yes" xml:space="preserve">
          <source>NOLOCK</source>
          <target state="translated">NOLOCK</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="9841c4209305816a8e9adbf24362646952f05b27" translate="yes" xml:space="preserve">
          <source>NOW</source>
          <target state="translated">NOW</target>
        </trans-unit>
        <trans-unit id="a2af9a6115134a71b0d62f68e143c19efff1f954" translate="yes" xml:space="preserve">
          <source>NOWAIT</source>
          <target state="translated">NOWAIT</target>
        </trans-unit>
        <trans-unit id="b26f87d0c59f90fdc5143250b4f83e7b4def44dc" translate="yes" xml:space="preserve">
          <source>NO_KEY_UPDATE</source>
          <target state="translated">NO_KEY_UPDATE</target>
        </trans-unit>
        <trans-unit id="6c2496a022b02739f43ed430676315b0c3b34a08" translate="yes" xml:space="preserve">
          <source>NUMBER</source>
          <target state="translated">NUMBER</target>
        </trans-unit>
        <trans-unit id="42ead8566c2a2f546d0123a49496ab3f43750da0" translate="yes" xml:space="preserve">
          <source>NUMBER#constructor</source>
          <target state="translated">NUMBER#constructor</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="ed585ba39b11c2180b849eb53de424e3c71e081f" translate="yes" xml:space="preserve">
          <source>Name of SQL function to create</source>
          <target state="translated">作成するSQL関数名</target>
        </trans-unit>
        <trans-unit id="ec874e4030f9772c022ffc4fd75b709664407142" translate="yes" xml:space="preserve">
          <source>Name of SQL function to drop</source>
          <target state="translated">ドロップするSQL関数名</target>
        </trans-unit>
        <trans-unit id="1dc36a90ec6c0522dcf70c1022a4f52a8ebd611e" translate="yes" xml:space="preserve">
          <source>Name of table to create</source>
          <target state="translated">作成するテーブル名</target>
        </trans-unit>
        <trans-unit id="b1fb57d5dc0386d03765076aea0e86c354422228" translate="yes" xml:space="preserve">
          <source>Name of the constraint. If not specified, sequelize automatically creates a named constraint based on constraint type, table &amp;amp; column names</source>
          <target state="translated">制約の名前。指定しない場合、sequelizeは制約タイプ、テーブル、列名に基づいて名前付き制約を自動的に作成します</target>
        </trans-unit>
        <trans-unit id="4f9d1ae98e9da4b2bbe6a3af8fc9c757c82ce573" translate="yes" xml:space="preserve">
          <source>Name of the index. Default is &amp;lt;table&amp;gt;&lt;em&gt;&amp;lt;attr1&amp;gt;&lt;/em&gt;&amp;lt;attr2&amp;gt;</source>
          <target state="translated">インデックスの名前。デフォルトは&amp;lt;table&amp;gt; &lt;em&gt;&amp;lt;attr1&amp;gt;&lt;/em&gt; &amp;lt;attr2&amp;gt;です</target>
        </trans-unit>
        <trans-unit id="2caed30fdd66bcf9c63c21b3cf8cfd9c614e4500" translate="yes" xml:space="preserve">
          <source>Name of the schema</source>
          <target state="translated">スキーマ名</target>
        </trans-unit>
        <trans-unit id="8f1c7cb06848b338043704b4b8b6b6387090bb38" translate="yes" xml:space="preserve">
          <source>Naming Strategies</source>
          <target state="translated">ネーミング戦略</target>
        </trans-unit>
        <trans-unit id="83417c5bdb0fb8b5e66747ac85c9affcdf83a6c6" translate="yes" xml:space="preserve">
          <source>Naming strategy</source>
          <target state="translated">ネーミング戦略</target>
        </trans-unit>
        <trans-unit id="3eb500441a28691dc9112abeaa042dd559561e1e" translate="yes" xml:space="preserve">
          <source>Native upsert is now supported for all dialects.</source>
          <target state="translated">ネイティブアップサートがすべての方言でサポートされるようになりました。</target>
        </trans-unit>
        <trans-unit id="e3dc9c09a90c87b9a68571340476b7334d583546" translate="yes" xml:space="preserve">
          <source>Nested eager loading</source>
          <target state="translated">入れ子になった熱心なローディング</target>
        </trans-unit>
        <trans-unit id="a04f6031a8e00febd6c589cf09c4d65ef201ad6b" translate="yes" xml:space="preserve">
          <source>Nested key</source>
          <target state="translated">入れ子になったキー</target>
        </trans-unit>
        <trans-unit id="fb2662973950c773f223cbb622d456ea8595339e" translate="yes" xml:space="preserve">
          <source>Nested object</source>
          <target state="translated">入れ子になったオブジェクト</target>
        </trans-unit>
        <trans-unit id="03677879a39a6dfcf623a67df9dc3d5704326271" translate="yes" xml:space="preserve">
          <source>New column name</source>
          <target state="translated">新しいカラム名</target>
        </trans-unit>
        <trans-unit id="b3cb6c83a2b8014301de948d72605c9b1be9e466" translate="yes" xml:space="preserve">
          <source>New databases versus existing databases</source>
          <target state="translated">新しいデータベースと既存のデータベースの比較</target>
        </trans-unit>
        <trans-unit id="8708814fcaebc0970f0c7c817ceb87f8487aaf17" translate="yes" xml:space="preserve">
          <source>New name from table</source>
          <target state="translated">テーブルからの新しい名前</target>
        </trans-unit>
        <trans-unit id="6201a9f7432baaca8091c6a78cc0f9fb26eaa3a1" translate="yes" xml:space="preserve">
          <source>New name of function</source>
          <target state="translated">関数の新しい名前</target>
        </trans-unit>
        <trans-unit id="ed47500954469451016c880a7f5051ccc16a64cf" translate="yes" xml:space="preserve">
          <source>Newly defined model</source>
          <target state="translated">新規定義モデル</target>
        </trans-unit>
        <trans-unit id="fb17233bc810f24085dbf005a9031819e384f852" translate="yes" xml:space="preserve">
          <source>Next thing: Loading of data with many-to-something associations!</source>
          <target state="translated">次のこと:多対多の関連付けでデータを読み込む</target>
        </trans-unit>
        <trans-unit id="e16b1a945e5b22bb16b245f22dd7211090c45d44" translate="yes" xml:space="preserve">
          <source>Normally this is done on process exit, so you only need to call this method if you are creating multiple instances, and want to garbage collect some of them.</source>
          <target state="translated">通常、これはプロセスの終了時に行われるので、複数のインスタンスを作成していて、そのうちのいくつかをガベージコレクトしたい場合にのみ、このメソッドを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="6176bdae0e6a8e545e326df9313cbff2bf37b4e6" translate="yes" xml:space="preserve">
          <source>Note about &lt;code&gt;allowNull&lt;/code&gt; implementation</source>
          <target state="translated">&lt;code&gt;allowNull&lt;/code&gt; の実装に関する注意</target>
        </trans-unit>
        <trans-unit id="3ba3b3278c1b05092ca1a7d836a057e742820ee9" translate="yes" xml:space="preserve">
          <source>Note also that the &lt;code&gt;where&lt;/code&gt; option used was converted into a condition for the &lt;code&gt;ON&lt;/code&gt; clause of the &lt;code&gt;INNER JOIN&lt;/code&gt;. In order to obtain a &lt;em&gt;top-level&lt;/em&gt;&lt;code&gt;WHERE&lt;/code&gt; clause, instead of an &lt;code&gt;ON&lt;/code&gt; clause, something different must be done. This will be shown next.</source>
          <target state="translated">使用される &lt;code&gt;where&lt;/code&gt; オプションが、 &lt;code&gt;INNER JOIN&lt;/code&gt; &lt;code&gt;ON&lt;/code&gt; 句の条件に変換されたことにも注意してください。 &lt;code&gt;ON&lt;/code&gt; 句の代わりに&lt;em&gt;トップレベルの&lt;/em&gt; &lt;code&gt;WHERE&lt;/code&gt; 句を取得するには、別のことを行う必要があります。これを次に示します。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4fecfeb74461c5b9959a4931d6c5c7f2c22b668b" translate="yes" xml:space="preserve">
          <source>Note for PostgreSQL</source>
          <target state="translated">PostgreSQLに関する注意事項</target>
        </trans-unit>
        <trans-unit id="44df5fc237f6e69bd9d791f7eb38e4498268a792" translate="yes" xml:space="preserve">
          <source>Note for production</source>
          <target state="translated">製造上の注意</target>
        </trans-unit>
        <trans-unit id="6c85945356462ad75525821c104b7dfcd213da7d" translate="yes" xml:space="preserve">
          <source>Note how &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; are overwritten by &lt;code&gt;scope2&lt;/code&gt;, while &lt;code&gt;firstName&lt;/code&gt; is preserved. The &lt;code&gt;limit&lt;/code&gt;, &lt;code&gt;offset&lt;/code&gt;, &lt;code&gt;order&lt;/code&gt;, &lt;code&gt;paranoid&lt;/code&gt;, &lt;code&gt;lock&lt;/code&gt; and &lt;code&gt;raw&lt;/code&gt; fields are overwritten, while &lt;code&gt;where&lt;/code&gt; is shallowly merged (meaning that identical keys will be overwritten). The merge strategy for &lt;code&gt;include&lt;/code&gt; will be discussed later on.</source>
          <target state="translated">注どのように &lt;code&gt;limit&lt;/code&gt; し、 &lt;code&gt;age&lt;/code&gt; によって上書きされ &lt;code&gt;scope2&lt;/code&gt; ながら、 &lt;code&gt;firstName&lt;/code&gt; のが保持されます。 &lt;code&gt;limit&lt;/code&gt; 、 &lt;code&gt;offset&lt;/code&gt; 、 &lt;code&gt;order&lt;/code&gt; 、 &lt;code&gt;paranoid&lt;/code&gt; 、 &lt;code&gt;lock&lt;/code&gt; や &lt;code&gt;raw&lt;/code&gt; ながらフィールドは、上書きされている &lt;code&gt;where&lt;/code&gt; 浅く（同じキーが上書きされることを意味します）マージされます。 &lt;code&gt;include&lt;/code&gt; のマージ戦略については、後で説明します。</target>
        </trans-unit>
        <trans-unit id="ef9ad9b0ed9a592756067e7688004b19c87f4919" translate="yes" xml:space="preserve">
          <source>Note how we also specified &lt;code&gt;constraints: false&lt;/code&gt; for profile picture. This is because we add a foreign key from user to picture (profilePictureId), and from picture to user (userId). If we were to add foreign keys to both, it would create a cyclic dependency, and sequelize would not know which table to create first, since user depends on picture, and picture depends on user. These kinds of problems are detected by sequelize before the models are synced to the database, and you will get an error along the lines of &lt;code&gt;Error: Cyclic dependency found. 'users' is dependent of itself&lt;/code&gt;. If you encounter this, you should either disable some constraints, or rethink your associations completely.</source>
          <target state="translated">&lt;code&gt;constraints: false&lt;/code&gt; も指定した方法に注意してください。プロフィール画像の場合はfalseです。これは、ユーザーから画像（profilePictureId）へ、および画像からユーザー（userId）への外部キーを追加するためです。両方に外部キーを追加すると、循環依存関係が作成され、sequelizeは最初に作成するテーブルがわかりません。ユーザーは画像に依存し、画像はユーザーに依存するためです。これらの種類の問題は、モデルがデータベースに同期される前にsequelizeによって検出され、 &lt;code&gt;Error: Cyclic dependency found. 'users' is dependent of itself&lt;/code&gt; 行に沿ってエラーが発生します。 「ユーザー」はそれ自体に依存しています。これが発生した場合は、いくつかの制約を無効にするか、関連付けを完全に再考する必要があります。</target>
        </trans-unit>
        <trans-unit id="eb9144a05775de68ebca958a87e5360db80e40b3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;attributes&lt;/code&gt; keys of multiple applied scopes are merged in such a way that &lt;code&gt;attributes.exclude&lt;/code&gt; are always preserved. This allows merging several scopes and never leaking sensitive fields in final scope.</source>
          <target state="translated">適用された複数のスコープの &lt;code&gt;attributes&lt;/code&gt; キーは、 &lt;code&gt;attributes.exclude&lt;/code&gt; が常に保持されるようにマージされることに注意してください。これにより、いくつかのスコープをマージし、最終的なスコープの機密フィールドをリークすることはありません。</target>
        </trans-unit>
        <trans-unit id="d47d21ac5fd749e2af2943107836fa234d97ebce" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;t.commit()&lt;/code&gt; and &lt;code&gt;t.rollback()&lt;/code&gt; were not called directly (which is correct).</source>
          <target state="translated">&lt;code&gt;t.commit()&lt;/code&gt; と &lt;code&gt;t.rollback()&lt;/code&gt; が直接呼び出されなかったことに注意してください（これは正しいです）。</target>
        </trans-unit>
        <trans-unit id="874d8ccb75febf029f664e8d9e1c7124e237a8ea" translate="yes" xml:space="preserve">
          <source>Note that every bar instance eager loaded into the &lt;code&gt;&quot;Bars&quot;&lt;/code&gt; property has an extra property called &lt;code&gt;Foo_Bar&lt;/code&gt; which is the relevant Sequelize instance of the junction model. By default, Sequelize fetches all attributes from the junction table in order to build this extra property.</source>
          <target state="translated">熱心なすべてのバーインスタンスがにロードされたことに注意してください &lt;code&gt;&quot;Bars&quot;&lt;/code&gt; プロパティと呼ばれる追加のプロパティがある &lt;code&gt;Foo_Bar&lt;/code&gt; 接合モデルの関連Sequelizeインスタンスです。デフォルトでは、Sequelizeは、この追加のプロパティを構築するために、ジャンクションテーブルからすべての属性をフェッチします。</target>
        </trans-unit>
        <trans-unit id="85958c9a7874f5c0d22b6bd6bca1113ce4f88dd0" translate="yes" xml:space="preserve">
          <source>Note that if you are using Sequelize migrations you will need to add the &lt;code&gt;createdAt&lt;/code&gt; and &lt;code&gt;updatedAt&lt;/code&gt; fields to your migration definition:</source>
          <target state="translated">Sequelizeマイグレーションを使用している場合は、 &lt;code&gt;createdAt&lt;/code&gt; および &lt;code&gt;updatedAt&lt;/code&gt; フィールドをマイグレーション定義に追加する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1c0231244df97b5648685a9c3faee3f96323348b" translate="yes" xml:space="preserve">
          <source>Note that in both cases the fields are still &lt;a href=&quot;https://en.wikipedia.org/wiki/Camel_case&quot;&gt;camelCase&lt;/a&gt; in the JavaScript side; this option only changes how these fields are mapped to the database itself. The &lt;code&gt;field&lt;/code&gt; option of every attribute is set to their snake_case version, but the attribute itself remains camelCase.</source>
          <target state="translated">どちらの場合も、フィールドはJavaScript側の&lt;a href=&quot;https://en.wikipedia.org/wiki/Camel_case&quot;&gt;キャメルケースの&lt;/a&gt;ままであることに注意してください。このオプションは、これらのフィールドがデータベース自体にマップされる方法のみを変更します。すべての属性の &lt;code&gt;field&lt;/code&gt; オプションはスネークケースバージョンに設定されていますが、属性自体はキャメルケースのままです。</target>
        </trans-unit>
        <trans-unit id="107947aedcad482a28cbbd5ea34b917a3cb7b194" translate="yes" xml:space="preserve">
          <source>Note that many model operations in Sequelize allow you to specify a transaction in the options parameter of the method. If a transaction _is_ specified in the original call, it will be present in the options parameter passed to the hook function. For example, consider the following snippet:</source>
          <target state="translated">Sequelize の多くのモデル操作では、メソッドの options パラメータでトランザクションを指定できることに注意してください。元の呼び出しでトランザクションが指定されている場合は、フック関数に渡されるオプションパラメータにそのトランザクションが含まれています。例えば、次のスニペットを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="3081268e8123684cad614d83cfab34d39dc4b655" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;getCommentable&lt;/code&gt; implementation above:</source>
          <target state="translated">上記の &lt;code&gt;getCommentable&lt;/code&gt; 実装に注意してください。</target>
        </trans-unit>
        <trans-unit id="e4a2d5cf04ad438df329fae57d33930a1cee82dc" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;this.firstname&lt;/code&gt; and &lt;code&gt;this.lastname&lt;/code&gt; references in the &lt;code&gt;fullName&lt;/code&gt; getter function will trigger a call to the respective getter functions. If you do not want that then use the &lt;code&gt;getDataValue()&lt;/code&gt; method to access the raw value (see below).</source>
          <target state="translated">&lt;code&gt;fullName&lt;/code&gt; ゲッター関数内の &lt;code&gt;this.firstname&lt;/code&gt; および &lt;code&gt;this.lastname&lt;/code&gt; 参照は、それぞれのゲッター関数の呼び出しをトリガーすることに注意してください。それが必要ない場合は、 &lt;code&gt;getDataValue()&lt;/code&gt; メソッドを使用して生の値にアクセスします（以下を参照）。</target>
        </trans-unit>
        <trans-unit id="c3f41755f136f1dc7c83971f78c9422549830be4" translate="yes" xml:space="preserve">
          <source>Note that the Image -&amp;gt; Comment and Post -&amp;gt; Comment relations define a scope, &lt;code&gt;commentable: 'image'&lt;/code&gt; and &lt;code&gt;commentable: 'post'&lt;/code&gt; respectively. This scope is automatically applied when using the association functions:</source>
          <target state="translated">Image-&amp;gt; CommentおよびPost-&amp;gt; Commentの関係は、それぞれ、 &lt;code&gt;commentable: 'image'&lt;/code&gt; および &lt;code&gt;commentable: 'post'&lt;/code&gt; スコープを定義することに注意してください。このスコープは、関連付け関数を使用するときに自動的に適用されます。</target>
        </trans-unit>
        <trans-unit id="5fa8504da9276f3d3bcfdfe8be4573399ed5ec4b" translate="yes" xml:space="preserve">
          <source>Note that the SQL query generated above will only fetch users that have at least one tool that matches the condition (of not being &lt;code&gt;small&lt;/code&gt;, in this case). This is the case because, when the &lt;code&gt;where&lt;/code&gt; option is used inside an &lt;code&gt;include&lt;/code&gt;, Sequelize automatically sets the &lt;code&gt;required&lt;/code&gt; option to &lt;code&gt;true&lt;/code&gt;. This means that, instead of an &lt;code&gt;OUTER JOIN&lt;/code&gt;, an &lt;code&gt;INNER JOIN&lt;/code&gt; is done, returning only the parent models with at least one matching children.</source>
          <target state="translated">上で生成されたSQLクエリは、条件（この場合は &lt;code&gt;small&lt;/code&gt; ない）に一致するツールを少なくとも1つ持っているユーザーのみをフェッチすることに注意してください。これが当てはまるの &lt;code&gt;include&lt;/code&gt; 、インクルード内 &lt;code&gt;where&lt;/code&gt; オプションを使用すると、Sequelizeが &lt;code&gt;required&lt;/code&gt; オプションを自動的に &lt;code&gt;true&lt;/code&gt; に設定するためです。代わりに、この手段 &lt;code&gt;OUTER JOIN&lt;/code&gt; をは、 &lt;code&gt;INNER JOIN&lt;/code&gt; は少なくとも一つのマッチング子どもたちと親のみのモデルを返して、行われます。</target>
        </trans-unit>
        <trans-unit id="535e728e1c2dd454b34cd31f6c84badc151925a7" translate="yes" xml:space="preserve">
          <source>Note that the Sequelize CLI assumes mysql by default. If you're using another dialect, you need to change the content of the &lt;code&gt;&quot;dialect&quot;&lt;/code&gt; option.</source>
          <target state="translated">SequelizeCLIはデフォルトでmysqlを想定していることに注意してください。別の方言を使用している場合は、 &lt;code&gt;&quot;dialect&quot;&lt;/code&gt; オプションの内容を変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="8525f9489e11bab3b2f21ec11ea967e62892eeb7" translate="yes" xml:space="preserve">
          <source>Note that the above implementation of &lt;code&gt;getTaggables()&lt;/code&gt; allows you to pass an options object to &lt;code&gt;getCommentable(options)&lt;/code&gt;, just like any other standard Sequelize method. This is useful to specify where-conditions or includes, for example.</source>
          <target state="translated">上記の &lt;code&gt;getTaggables()&lt;/code&gt; の実装では、他の標準的なSequelizeメソッドと同様に、optionsオブジェクトを &lt;code&gt;getCommentable(options)&lt;/code&gt; に渡すことができます。これは、たとえば、where-conditionsまたはincludesを指定する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="ce2721ae384c4dceeeec191b133512aaadb5dcf1" translate="yes" xml:space="preserve">
          <source>Note that the above is not the same as the &lt;em&gt;Default Hooks&lt;/em&gt; mentioned above. That one uses the &lt;code&gt;define&lt;/code&gt; option of the constructor. This one does not.</source>
          <target state="translated">上記は、上記の&lt;em&gt;デフォルトフック&lt;/em&gt;と同じではないことに注意してください。これは、コンストラクターの &lt;code&gt;define&lt;/code&gt; オプションを使用します。これはしません。</target>
        </trans-unit>
        <trans-unit id="dce9db0adb67b0d47212445f99eda65e1d938661" translate="yes" xml:space="preserve">
          <source>Note that where multiple arguments need to be passed to the built-in validation functions, the arguments to be passed must be in an array. But if a single array argument is to be passed, for instance an array of acceptable strings for &lt;code&gt;isIn&lt;/code&gt;, this will be interpreted as multiple string arguments instead of one array argument. To work around this pass a single-length array of arguments, such as &lt;code&gt;[['foo', 'bar']]&lt;/code&gt; as shown above.</source>
          <target state="translated">複数の引数を組み込みの検証関数に渡す必要がある場合、渡す引数は配列内にある必要があることに注意してください。ただし、単一の配列引数が渡される場合、たとえば &lt;code&gt;isIn&lt;/code&gt; の受け入れ可能な文字列の配列の場合、これは1つの配列引数ではなく複数の文字列引数として解釈されます。これを回避するには、上記のように &lt;code&gt;[['foo', 'bar']]&lt;/code&gt; などの引数の単一長配列を渡します。</target>
        </trans-unit>
        <trans-unit id="4f0b731694e383aebdfdb192c03dcf6b1ffbcb0d" translate="yes" xml:space="preserve">
          <source>Note that where multiple arguments need to be passed to the built-in validation functions, the arguments to be passed must be in an array. But if a single array argument is to be passed, for instance an array of acceptable strings for &lt;code&gt;isIn&lt;/code&gt;, this will be interpreted as multiple string arguments instead of one array argument. To work around this pass a single-length array of arguments, such as &lt;code&gt;[['one', 'two']]&lt;/code&gt; as shown above.</source>
          <target state="translated">組み込みの検証関数に複数の引数を渡す必要がある場合、渡される引数は配列である必要があります。ただし、1つの配列引数、たとえば &lt;code&gt;isIn&lt;/code&gt; の受け入れ可能な文字列の配列が渡される場合、これは1つの配列引数ではなく複数の文字列引数として解釈されます。この問題を回避するには、上記の &lt;code&gt;[['one', 'two']]&lt;/code&gt; など、引数の単一長の配列を渡します。</target>
        </trans-unit>
        <trans-unit id="535353d3fd19c1e937c57060bfd7578171ca07de" translate="yes" xml:space="preserve">
          <source>Note that, although &lt;code&gt;SUPERUSER123&lt;/code&gt; was logged above, the value truly stored in the database is still &lt;code&gt;SuperUser123&lt;/code&gt;. We used &lt;code&gt;this.getDataValue(username)&lt;/code&gt; to obtain this value, and converted it to uppercase.</source>
          <target state="translated">&lt;code&gt;SUPERUSER123&lt;/code&gt; は上記でログに記録されていますが、データベースに実際に格納されている値は依然として &lt;code&gt;SuperUser123&lt;/code&gt; であることに注意してください。 &lt;code&gt;this.getDataValue(username)&lt;/code&gt; を使用してこの値を取得し、大文字に変換しました。</target>
        </trans-unit>
        <trans-unit id="bbc26e1ce9a0cfc781a57cf82ff121257ce181f3" translate="yes" xml:space="preserve">
          <source>Note that, in the code above:</source>
          <target state="translated">上のコードでは、注意してください。</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">そのことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a1185b9e23d98645e5a1756245cb517d46b4d7b2" translate="yes" xml:space="preserve">
          <source>Note the usage of the &lt;a href=&quot;../class/lib/sequelize.js~sequelize#static-method-fn&quot;&gt;&lt;code&gt;sequelize.fn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../class/lib/sequelize.js~sequelize#static-method-col&quot;&gt;&lt;code&gt;sequelize.col&lt;/code&gt;&lt;/a&gt; methods, which should be used to specify an SQL function call and a table column, respectively. These methods should be used instead of passing a plain string (such as &lt;code&gt;char_length(content)&lt;/code&gt;) because Sequelize needs to treat this situation differently (for example, using other symbol escaping approaches).</source>
          <target state="translated">使用注&lt;a href=&quot;../class/lib/sequelize.js~sequelize#static-method-fn&quot;&gt; &lt;code&gt;sequelize.fn&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;../class/lib/sequelize.js~sequelize#static-method-col&quot;&gt; &lt;code&gt;sequelize.col&lt;/code&gt; &lt;/a&gt;それぞれ、SQL関数呼び出しとテーブル列を指定するために使用されるべき方法を、。Sequelizeはこの状況を別の方法で処理する必要があるため（たとえば、他のシンボルエスケープアプローチを使用して &lt;code&gt;char_length(content)&lt;/code&gt; 、プレーンな文字列（char_length（content）など）を渡す代わりに、これらのメソッドを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="a7dd5727b419c54ae3dce641926eb1877ae85ef1" translate="yes" xml:space="preserve">
          <source>Note, from the usage of &lt;code&gt;await&lt;/code&gt; in the snippet above, that &lt;code&gt;save&lt;/code&gt; is an asynchronous method. In fact, almost every Sequelize method is asynchronous; &lt;code&gt;build&lt;/code&gt; is one of the very few exceptions.</source>
          <target state="translated">上記のスニペットでの &lt;code&gt;await&lt;/code&gt; の使用法から、 &lt;code&gt;save&lt;/code&gt; は非同期メソッドであることに注意してください。実際、ほとんどすべてのSequelizeメソッドは非同期です。 &lt;code&gt;build&lt;/code&gt; は非常に少数の例外の1つです。</target>
        </trans-unit>
        <trans-unit id="4e2083a1e3128e3d36db892d90a3e9c51498a3db" translate="yes" xml:space="preserve">
          <source>Note: Method names</source>
          <target state="translated">注:メソッド名</target>
        </trans-unit>
        <trans-unit id="acc671783544f4659031c39424988278f5682f5d" translate="yes" xml:space="preserve">
          <source>Note: connection pool (production)</source>
          <target state="translated">注:接続プール(本番</target>
        </trans-unit>
        <trans-unit id="8e931cb200d41187609864e64685fc58a6af9a21" translate="yes" xml:space="preserve">
          <source>Note: here, our user model is called &lt;code&gt;user&lt;/code&gt;, with a lowercase &lt;code&gt;u&lt;/code&gt; - This means that the property in the object should also be &lt;code&gt;user&lt;/code&gt;. If the name given to &lt;code&gt;sequelize.define&lt;/code&gt; was &lt;code&gt;User&lt;/code&gt;, the key in the object should also be &lt;code&gt;User&lt;/code&gt;. Likewise for &lt;code&gt;addresses&lt;/code&gt;, except it's pluralized being a &lt;code&gt;hasMany&lt;/code&gt; association.</source>
          <target state="translated">注：ここでは、私たちのユーザーモデルが呼び出された &lt;code&gt;user&lt;/code&gt; を小文字で、 &lt;code&gt;u&lt;/code&gt; -オブジェクトのプロパティでもなければならないことを、この手段 &lt;code&gt;user&lt;/code&gt; 。 &lt;code&gt;sequelize.define&lt;/code&gt; に付けられた名前が &lt;code&gt;User&lt;/code&gt; の場合、オブジェクトのキーも &lt;code&gt;User&lt;/code&gt; である必要があります。 &lt;code&gt;addresses&lt;/code&gt; についても同様ですが、 &lt;code&gt;hasMany&lt;/code&gt; アソシエーションである複数形である点が異なります。</target>
        </trans-unit>
        <trans-unit id="a5fd63a016b678ef7095e9bf7d16779f02fbf986" translate="yes" xml:space="preserve">
          <source>Note: logging instances</source>
          <target state="translated">注意:ロギングインスタンス</target>
        </trans-unit>
        <trans-unit id="3fcf216a4ed0c8139179e6a973305b6ff1175347" translate="yes" xml:space="preserve">
          <source>Note: methods like &lt;code&gt;bulkCreate&lt;/code&gt; do not emit individual hooks by default - only the bulk hooks. However, if you want individual hooks to be emitted as well, you can pass the &lt;code&gt;{ individualHooks: true }&lt;/code&gt; option to the query call. However, this can drastically impact performance, depending on the number of records involved (since, among other things, all instances will be loaded into memory). Examples:</source>
          <target state="translated">注： &lt;code&gt;bulkCreate&lt;/code&gt; のようなメソッドは、デフォルトでは個々のフックを発行しません。バルクフックのみを発行します。ただし、個々のフックも発行する場合は、 &lt;code&gt;{ individualHooks: true }&lt;/code&gt; オプションをクエリ呼び出しに渡すことができます。ただし、これは、関係するレコードの数によっては、パフォーマンスに大きな影響を与える可能性があります（特に、すべてのインスタンスがメモリにロードされるため）。例：</target>
        </trans-unit>
        <trans-unit id="b97eebd9a45f672b355a29fd52d6abdf68ff7637" translate="yes" xml:space="preserve">
          <source>Note: recall that using &lt;code&gt;as&lt;/code&gt; to change the name of the association will also change the name of the foreign key. Therefore it is recommended to also specify the foreign key(s) involved directly in this case.</source>
          <target state="translated">注： &lt;code&gt;as&lt;/code&gt; を使用して関連付けの名前を変更すると、外部キーの名前も変更されることに注意してください。したがって、この場合に直接関係する外部キーも指定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f17a025ad4dbded90c801ce4da0060642aed6add" translate="yes" xml:space="preserve">
          <source>Note: setting up SQLite</source>
          <target state="translated">注意:SQLiteの設定</target>
        </trans-unit>
        <trans-unit id="40e25156182cc9a047ea365913ca1b7c1bf7c6e2" translate="yes" xml:space="preserve">
          <source>Note: the &lt;code&gt;getShip()&lt;/code&gt; instance method used above is one of the methods Sequelize automatically adds to &lt;code&gt;Captain&lt;/code&gt; instances. There are others. You will learn more about them later in this guide.</source>
          <target state="translated">注：上記で使用した &lt;code&gt;getShip()&lt;/code&gt; インスタンスメソッドは、Sequelizeが &lt;code&gt;Captain&lt;/code&gt; インスタンスに自動的に追加するメソッドの1つです。他にもあります。これらについては、このガイドの後半で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="cd919816b3443abb41321a6896d4c72ccca66a20" translate="yes" xml:space="preserve">
          <source>Note: there is also a &lt;em&gt;Super Many-To-Many&lt;/em&gt; relationship, which uses six associations at once, and will be discussed in the &lt;a href=&quot;advanced-many-to-many&quot;&gt;Advanced Many-to-Many relationships guide&lt;/a&gt;.</source>
          <target state="translated">注：一度に6つの関連付けを使用する&lt;em&gt;超多対多の&lt;/em&gt;関係もあります。これについては、&lt;a href=&quot;advanced-many-to-many&quot;&gt;高度な多対多の関係ガイドで説明し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="598ee651f3662bc62e474c319bd8bfacefa4b7fa" translate="yes" xml:space="preserve">
          <source>Notice how in the two examples above, the string provided is inserted verbatim into the query, i.e. column names are not escaped. When you provide a string to order/group, this will always be the case. If you want to escape column names, you should provide an array of arguments, even though you only want to order/group by a single column</source>
          <target state="translated">上の2つの例では、提供された文字列がそのままクエリに挿入されていること、つまりカラム名がエスケープされていないことに注目してください。order/groupに文字列を指定した場合は、常にこのようになります。カラム名をエスケープしたい場合は、引数の配列を指定しなければなりません。</target>
        </trans-unit>
        <trans-unit id="ea75bd7ff48126d9026a71c0c8a132e1bf24ae80" translate="yes" xml:space="preserve">
          <source>Notice how the callback passed to &lt;code&gt;transaction&lt;/code&gt; returns a promise chain, and does not explicitly call &lt;code&gt;t.commit()&lt;/code&gt; nor &lt;code&gt;t.rollback()&lt;/code&gt;. If all promises in the returned chain are resolved successfully the transaction is committed. If one or several of the promises are rejected, the transaction is rolled back.</source>
          <target state="translated">&lt;code&gt;transaction&lt;/code&gt; 渡されたコールバックがどのようにpromiseチェーンを返し、明示的に &lt;code&gt;t.commit()&lt;/code&gt; も &lt;code&gt;t.rollback()&lt;/code&gt; も呼び出さないことに注意してください。返されたチェーンのすべてのpromiseが正常に解決されると、トランザクションがコミットされます。1つまたは複数のpromiseが拒否された場合、トランザクションはロールバックされます。</target>
        </trans-unit>
        <trans-unit id="d7340a668b3a9cce1425f7bbe04ef3dad22c994b" translate="yes" xml:space="preserve">
          <source>Notice how the user's &lt;code&gt;Tool&lt;/code&gt;s are aliased as &lt;code&gt;Instruments&lt;/code&gt; above. In order to get that right you have to specify the model you want to load, as well as the alias:</source>
          <target state="translated">ユーザーの &lt;code&gt;Tool&lt;/code&gt; が上記の &lt;code&gt;Instruments&lt;/code&gt; としてエイリアスされていることに注意してください。これを正しく行うには、ロードするモデルとエイリアスを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="11f0b22a1229e459ff86618d87a61e6308c98004" translate="yes" xml:space="preserve">
          <source>Notice that the accessor (the &lt;code&gt;Tasks&lt;/code&gt; property in the resulting instance) is plural because the association is many-to-something.</source>
          <target state="translated">関連付けは多対多であるため、アクセサー（結果のインスタンスの &lt;code&gt;Tasks&lt;/code&gt; プロパティ）は複数であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="db89be52a41833866fcb78f0286f7fdf07513336" translate="yes" xml:space="preserve">
          <source>Notice that the accessor (the &lt;code&gt;User&lt;/code&gt; property in the resulting instance) is singular because the association is one-to-something.</source>
          <target state="translated">関連付けは1対何かであるため、アクセサ（結果のインスタンスの &lt;code&gt;User&lt;/code&gt; プロパティ）は単数形であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="035e80869f3e64a2811a9a26ef2461fad11e2c9a" translate="yes" xml:space="preserve">
          <source>Notice that the accessor (the &lt;code&gt;tasks&lt;/code&gt; property in the resulting instance) is pluralized since the association is one-to-many.</source>
          <target state="translated">関連付けは1対多であるため、アクセサー（結果のインスタンスの &lt;code&gt;tasks&lt;/code&gt; プロパティ）が複数化されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1c9516d33ec61798915ba72e3e7b6dc102e33d33" translate="yes" xml:space="preserve">
          <source>Notice that the outer object is an &lt;code&gt;User&lt;/code&gt;, which has a field called &lt;code&gt;profiles&lt;/code&gt;, which is a &lt;code&gt;Profile&lt;/code&gt; array, such that each &lt;code&gt;Profile&lt;/code&gt; comes with an extra field called &lt;code&gt;grant&lt;/code&gt; which is a &lt;code&gt;Grant&lt;/code&gt; instance. This is the default structure created by Sequelize when eager loading from a Many-to-Many relationship.</source>
          <target state="translated">外側のオブジェクトは &lt;code&gt;User&lt;/code&gt; であり、 &lt;code&gt;profiles&lt;/code&gt; というフィールドがあります。これは &lt;code&gt;Profile&lt;/code&gt; 配列であり、各 &lt;code&gt;Profile&lt;/code&gt; には &lt;code&gt;Grant&lt;/code&gt; インスタンスである &lt;code&gt;grant&lt;/code&gt; という追加のフィールドがあります。これは、多対多の関係から積極的にロードするときにSequelizeによって作成されるデフォルトの構造です。</target>
        </trans-unit>
        <trans-unit id="4848a0b9c04bb727fb8adec90477785147fef5df" translate="yes" xml:space="preserve">
          <source>Notice that the scoped column (&lt;code&gt;taggable&lt;/code&gt;) is now on the through model (&lt;code&gt;ItemTag&lt;/code&gt;).</source>
          <target state="translated">スコープ指定された列（ &lt;code&gt;taggable&lt;/code&gt; ）がスルーモデル（ &lt;code&gt;ItemTag&lt;/code&gt; ）上にあることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0cf25bfe98d9e52a1f895ec51fb4362193792880" translate="yes" xml:space="preserve">
          <source>Notice, that the &lt;code&gt;useCLS()&lt;/code&gt; method is on the &lt;em&gt;constructor&lt;/em&gt;, not on an instance of sequelize. This means that all instances will share the same namespace, and that CLS is all-or-nothing - you cannot enable it only for some instances.</source>
          <target state="translated">ことを通知、 &lt;code&gt;useCLS()&lt;/code&gt; メソッドがオンになっている&lt;em&gt;コンストラクタ&lt;/em&gt;はなくsequelizeのインスタンスに。つまり、すべてのインスタンスが同じ名前空間を共有し、CLSはオールオアナッシングです。一部のインスタンスに対してのみ有効にすることはできません。</target>
        </trans-unit>
        <trans-unit id="e2ed15a30fc301b436665dd5c0c8498b757d5988" translate="yes" xml:space="preserve">
          <source>Now CLI will be able to run ES6/ES7 code from migrations/seeders etc. Please keep in mind this depends upon your configuration of &lt;code&gt;.babelrc&lt;/code&gt;. Please read more about that at &lt;a href=&quot;https://babeljs.io&quot;&gt;babeljs.io&lt;/a&gt;.</source>
          <target state="translated">これで、CLIはマイグレーション/シーダーなどからES6 / ES7コードを実行できるようになります。これは &lt;code&gt;.babelrc&lt;/code&gt; の構成に依存することに注意してください。詳しくは&lt;a href=&quot;https://babeljs.io&quot;&gt;babeljs.ioを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="0dda3fffe72b1e2fffc081cac72bf40762b93a93" translate="yes" xml:space="preserve">
          <source>Now Sequelize CLI will load &lt;code&gt;config/config.js&lt;/code&gt; for getting configuration options. Since this is a JS file you can have any code executed and export final dynamic configuration file.</source>
          <target state="translated">これで、Sequelize CLIは構成オプションを取得するために &lt;code&gt;config/config.js&lt;/code&gt; をロードします。これはJSファイルなので、任意のコードを実行して、最終的な動的構成ファイルをエクスポートできます。</target>
        </trans-unit>
        <trans-unit id="c6530493050c981b03dea9cac83caf8e5e3c0eff" translate="yes" xml:space="preserve">
          <source>Now edit this file and set correct database credentials and dialect. The keys of the objects (e.g. &quot;development&quot;) are used on &lt;code&gt;model/index.js&lt;/code&gt; for matching &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; (When undefined, &quot;development&quot; is a default value).</source>
          <target state="translated">次に、このファイルを編集して、正しいデータベース資格情報と方言を設定します。オブジェクトのキー（「開発」など）は、 &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; を照合するために &lt;code&gt;model/index.js&lt;/code&gt; で使用されます（未定義の場合、「開発」がデフォルト値です）。</target>
        </trans-unit>
        <trans-unit id="95b3edba890e41548c10bf9b3b3625f9aa2f773c" translate="yes" xml:space="preserve">
          <source>Now edit this file and set correct database credentials and dialect. The keys of the objects(ex. &quot;development&quot;) are used on &lt;code&gt;model/index.js&lt;/code&gt; for matching &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; (When undefined, &quot;development&quot; is a default value.).</source>
          <target state="translated">次に、このファイルを編集して、正しいデータベース資格情報と方言を設定します。オブジェクトのキー（例： &quot;development&quot;）は、 &lt;code&gt;model/index.js&lt;/code&gt; で一致する &lt;code&gt;process.env.NODE_ENV&lt;/code&gt; に使用されます（未定義の場合、 &quot;development&quot;がデフォルト値です）。</target>
        </trans-unit>
        <trans-unit id="8bcf1d33260995a6c3b8643c00cc70d1a34e6ef9" translate="yes" xml:space="preserve">
          <source>Now include &lt;code&gt;babel-register&lt;/code&gt; setup in this file</source>
          <target state="translated">このファイルに &lt;code&gt;babel-register&lt;/code&gt; 設定を含めます</target>
        </trans-unit>
        <trans-unit id="464a349af324240ebd3cbae6fce3308732c7d91a" translate="yes" xml:space="preserve">
          <source>Now let's create &lt;code&gt;.sequelizerc&lt;/code&gt; file, it can include any configuration you may want to change for &lt;code&gt;sequelize-cli&lt;/code&gt; but in addition to that we want it to register babel for our codebase. Something like this</source>
          <target state="translated">今度は &lt;code&gt;.sequelizerc&lt;/code&gt; ファイルを作成しましょう &lt;code&gt;sequelize-cli&lt;/code&gt; 変更したい構成を含めることができますが、それに加えて、コードベースにbabelを登録する必要があります。このようなもの</target>
        </trans-unit>
        <trans-unit id="20a6638a8729006ac3616971ef324f0cd3930e50" translate="yes" xml:space="preserve">
          <source>Now let's work with an example config.</source>
          <target state="translated">では、設定例を見ながら作業してみましょう。</target>
        </trans-unit>
        <trans-unit id="aff9acc4bc5c9d94727af20f35602137e8690ce9" translate="yes" xml:space="preserve">
          <source>Now lets change some values and save changes to the database... There are two ways to do that:</source>
          <target state="translated">では、いくつかの値を変更してデータベースに保存してみましょう...。これには2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="d4fb15abf10ea3e08624eaff19cd79bb8fba56a4" translate="yes" xml:space="preserve">
          <source>Now our table has been created and saved in database. With migration you can revert to old state by just running a command.</source>
          <target state="translated">これでテーブルが作成され、データベースに保存されました。マイグレーションでは、コマンドを実行するだけで古い状態に戻すことができます。</target>
        </trans-unit>
        <trans-unit id="f7eefdac723f9c9e20d7294a50068553ae5ca48a" translate="yes" xml:space="preserve">
          <source>Now the Sequelize CLI will load &lt;code&gt;config/config.js&lt;/code&gt; for getting configuration options.</source>
          <target state="translated">これで、SequelizeCLIは構成オプションを取得するために &lt;code&gt;config/config.js&lt;/code&gt; をロードします。</target>
        </trans-unit>
        <trans-unit id="548b3c2a852af460195d73e56956f24676cc3d49" translate="yes" xml:space="preserve">
          <source>Now we can create a product with multiple tags in the following way:</source>
          <target state="translated">これで、以下のように複数のタグで商品を作成することができるようになりました。</target>
        </trans-unit>
        <trans-unit id="4cffce358a348e77c487f8192d4f0ed8395d638b" translate="yes" xml:space="preserve">
          <source>Now we can do things like:</source>
          <target state="translated">今ではこんなことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="f114dbd008171ea170c4bc3c4396af90c7dda1af" translate="yes" xml:space="preserve">
          <source>Now we should edit this file to insert demo user to &lt;code&gt;User&lt;/code&gt; table.</source>
          <target state="translated">次に、このファイルを編集して、デモユーザーを &lt;code&gt;User&lt;/code&gt; テーブルに挿入します。</target>
        </trans-unit>
        <trans-unit id="bd5005f9263eecf47904d16fa5a892e1856e0801" translate="yes" xml:space="preserve">
          <source>Now we will compare the usage of the last Many-to-Many setup shown above with the usual One-to-Many relationships, so that in the end we conclude with the concept of a &lt;em&gt;&quot;Super Many-to-Many relationship&quot;&lt;/em&gt;.</source>
          <target state="translated">ここで、上記の最後の多対多設定の使用法を通常の1対多の関係と比較し、最終的に&lt;em&gt;「超多対多の関係」&lt;/em&gt;の概念で締めくくります。</target>
        </trans-unit>
        <trans-unit id="5fbb7a53e1f2decb02a350e377272f4a1343c317" translate="yes" xml:space="preserve">
          <source>Now you know how to use &lt;code&gt;.sequelizerc&lt;/code&gt; file. Now let's see how to use this file to use babel with &lt;code&gt;sequelize-cli&lt;/code&gt; setup. This will allow you to write migrations and seeders with ES6/ES7 syntax.</source>
          <target state="translated">これで、 &lt;code&gt;.sequelizerc&lt;/code&gt; ファイルの使用方法がわかりました。次に、このファイルを使用して、 &lt;code&gt;sequelize-cli&lt;/code&gt; セットアップでbabelを使用する方法を見てみましょう。これにより、ES6 / ES7構文で移行とシーダーを作成できます。</target>
        </trans-unit>
        <trans-unit id="fa5d7518e3108590d0f1160b265811a870cd538d" translate="yes" xml:space="preserve">
          <source>Now, consider the following four scopes defined on Foo:</source>
          <target state="translated">ここで、Foo上で定義されている以下の4つのスコープを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="ea3db3e6a1f93a9eda45521737a3cb987f7c434a" translate="yes" xml:space="preserve">
          <source>Now, instead of loading the user that is associated to a given task, we will do the opposite - we will find all tasks associated to a given user.</source>
          <target state="translated">ここでは、与えられたタスクに関連付けられたユーザーをロードするのではなく、逆のことをします-与えられたユーザーに関連付けられたすべてのタスクを見つけます。</target>
        </trans-unit>
        <trans-unit id="d402f00865adc64ffa0390f1f24af9cf67021987" translate="yes" xml:space="preserve">
          <source>Now, the question is: how to associate them?</source>
          <target state="translated">さて、問題は、それらをどうやって関連付けるか?</target>
        </trans-unit>
        <trans-unit id="b3442c2dc57f57bad3870f40d6b154c87dd38302" translate="yes" xml:space="preserve">
          <source>Now, to consider a Many-to-Many polymorphic association, instead of considering comments, we will consider tags. For convenience, instead of calling Image and Video as &lt;em&gt;commentables&lt;/em&gt;, we will now call them &lt;em&gt;taggables&lt;/em&gt;. One &lt;em&gt;taggable&lt;/em&gt; may have several tags, and at the same time one tag can be placed in several &lt;em&gt;taggables&lt;/em&gt;.</source>
          <target state="translated">ここで、多対多のポリモーフィックな関連付けを検討するために、コメントを検討する代わりに、タグを検討します。便宜上、画像と動画を&lt;em&gt;コメント可能&lt;/em&gt;として呼び出す代わりに、&lt;em&gt;タグ付け可能&lt;/em&gt;と呼ぶように&lt;em&gt;なりました&lt;/em&gt;。1つのタグ付け可能&lt;em&gt;オブジェクトに&lt;/em&gt;複数のタグを&lt;em&gt;含める&lt;/em&gt;ことができ、同時に1つのタグを複数のタグ付け可能&lt;em&gt;オブジェクトに&lt;/em&gt;配置できます。</target>
        </trans-unit>
        <trans-unit id="81b312582560da24be75f76327d01f3d150384b4" translate="yes" xml:space="preserve">
          <source>Now, we are ready for examples of the power of subqueries.</source>
          <target state="translated">これで、サブクエリーの力の例の準備が整いました。</target>
        </trans-unit>
        <trans-unit id="4323615f9d1080eaa42714c1a47e9171d6778c7d" translate="yes" xml:space="preserve">
          <source>Now, we want to perform a polymorphic eager loading of the associated commentables for one (or more) comments. We want to achieve something similar to the following idea:</source>
          <target state="translated">ここで、1つ(またはそれ以上)のコメントに対して、関連するコメンタブルのポリモーフィックなイーガーローディングを実行したいと思います。以下のアイデアに似たことを実現したいと思います。</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="5582432c4864632f5e1a23cfc9dcba9e1ce92437" translate="yes" xml:space="preserve">
          <source>OK. So, first of all, let's load all tasks with their associated user.</source>
          <target state="translated">OKです。では、まず、すべてのタスクを関連するユーザーと一緒にロードしてみましょう。</target>
        </trans-unit>
        <trans-unit id="6fb9784f607ff093cd1715b61adeec04b842c2a2" translate="yes" xml:space="preserve">
          <source>OK. So, first of all, let's load all tasks with their associated user:</source>
          <target state="translated">では、まず最初に、すべてのタスクに関連するユーザーをロードしてみましょう。では、まず、すべてのタスクを関連するユーザーと一緒にロードしてみましょう。</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="524631efa40fbbd074c7d379858504a629448858" translate="yes" xml:space="preserve">
          <source>Object -</source>
          <target state="translated">オブジェクト</target>
        </trans-unit>
        <trans-unit id="7798f73e59ce895af4d9b669167864b8821ca276" translate="yes" xml:space="preserve">
          <source>Object representing a list of table attributes to create</source>
          <target state="translated">作成するテーブル属性のリストを表すオブジェクト</target>
        </trans-unit>
        <trans-unit id="a7b5e01cccb77400ad2465a66ef4eff96ddff3da" translate="yes" xml:space="preserve">
          <source>Object specifying target table, column name to create foreign key constraint</source>
          <target state="translated">外部キー制約を作成するテーブル、カラム名を指定するオブジェクト</target>
        </trans-unit>
        <trans-unit id="c785ae6c15b6aed10bfae737959e2db229782bf3" translate="yes" xml:space="preserve">
          <source>Object with multiple variables.</source>
          <target state="translated">複数の変数を持つオブジェクト。</target>
        </trans-unit>
        <trans-unit id="e3816c117ac9693a36bb6ad26b815f39c6a83f3f" translate="yes" xml:space="preserve">
          <source>Observe how the four scopes were merged into one. The includes of scopes are merged based on the model being included. If one scope includes model A and another includes model B, the merged result will include both models A and B. On the other hand, if both scopes include the same model A, but with different options (such as nested includes or other attributes), those will be merged recursively, as shown above.</source>
          <target state="translated">4 つのスコープがどのように 1 つに統合されたかを観察します。スコープのインクルードは、含まれるモデルに基づいてマージされます。一方、両方のスコープに同じモデル A が含まれているが、異なるオプション (入れ子になったインクルードや他の属性など)がある場合は、上記のように再帰的にマージされます。</target>
        </trans-unit>
        <trans-unit id="934291dd3a055f8d1ebe6a487355ae31c74c8183" translate="yes" xml:space="preserve">
          <source>Observe that Sequelize called the setter automatically, before even sending data to the database. The only data the database ever saw was the already hashed value.</source>
          <target state="translated">Sequelize がデータベースにデータを送信する前に、自動的にセッターを呼び出していることに注目してください。データベースが見たデータは、すでにハッシュ化された値だけでした。</target>
        </trans-unit>
        <trans-unit id="866d795c3e03ac5251b1b9486ccf5594e65835e3" translate="yes" xml:space="preserve">
          <source>Observe that in the example above, we made two queries, only fetching the associated ship when we wanted to use it. This can be especially useful if we may or may not need the ship, perhaps we want to fetch it conditionally, only in a few cases; this way we can save time and memory by only fetching it when necessary.</source>
          <target state="translated">上の例では、2つのクエリを作成し、関連する船を使用したいときにのみ取得していることに注意してください。これは、船が必要な場合や必要ではない場合、条件付きで取得したい場合などに特に便利です。</target>
        </trans-unit>
        <trans-unit id="355ddd1052f0bbd27e35379c1f9623b46a9df1d9" translate="yes" xml:space="preserve">
          <source>Observe that no operator (from &lt;code&gt;Op&lt;/code&gt;) was explicitly passed, so Sequelize assumed an equality comparison by default. The above code is equivalent to:</source>
          <target state="translated">（ &lt;code&gt;Op&lt;/code&gt; からの）演算子が明示的に渡されていないことに注意してください。そのため、Sequelizeはデフォルトで等価比較を想定していました。上記のコードは次と同等です。</target>
        </trans-unit>
        <trans-unit id="607110e8378fd9796e0eb0265780d5188c232e9b" translate="yes" xml:space="preserve">
          <source>Observe that, in both methods above, the table name (&lt;code&gt;Users&lt;/code&gt;) was never explicitly defined. However, the model name was given (&lt;code&gt;User&lt;/code&gt;).</source>
          <target state="translated">上記の両方の方法で、テーブル名（ &lt;code&gt;Users&lt;/code&gt; ）が明示的に定義されていないことに注意してください。ただし、モデル名は付けられています（ &lt;code&gt;User&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5069c0079b2ccec2d921137a8097a76ee6f64f7e" translate="yes" xml:space="preserve">
          <source>Observe that, in the examples above, &lt;code&gt;Sequelize&lt;/code&gt; refers to the library itself while &lt;code&gt;sequelize&lt;/code&gt; refers to an instance of Sequelize, which represents a connection to one database. This is the recommended convention and it will be followed throughout the documentation.</source>
          <target state="translated">上記の例では、 &lt;code&gt;Sequelize&lt;/code&gt; はライブラリ自体を参照し、 &lt;code&gt;sequelize&lt;/code&gt; は1つのデータベースへの接続を表すSequelizeのインスタンスを参照していることに注意してください。これは推奨される規則であり、ドキュメント全体で使用されます。</target>
        </trans-unit>
        <trans-unit id="796dec4a3b7bd0c60bf9804117e49636789a834e" translate="yes" xml:space="preserve">
          <source>Observe the usage of the &lt;code&gt;include&lt;/code&gt; option in the &lt;code&gt;Product.create&lt;/code&gt; call. That is necessary for Sequelize to understand what you are trying to create along with the association.</source>
          <target state="translated">&lt;code&gt;Product.create&lt;/code&gt; 呼び出しの &lt;code&gt;include&lt;/code&gt; オプションの使用法を観察します。これは、Sequelizeが、関連付けとともに作成しようとしているものを理解するために必要です。</target>
        </trans-unit>
        <trans-unit id="6d9e1c6d254743bd56f18ff13338f3640b6cd888" translate="yes" xml:space="preserve">
          <source>Obtaining the query interface</source>
          <target state="translated">クエリインターフェイスの取得</target>
        </trans-unit>
        <trans-unit id="3ec9751cae190e1dbc9d9b803b5cc2115aae8a88" translate="yes" xml:space="preserve">
          <source>Of course you can also access the instance's data and generate virtual getters:</source>
          <target state="translated">もちろん、インスタンスのデータにアクセスして仮想ゲッターを生成することもできます。</target>
        </trans-unit>
        <trans-unit id="ef0e1f62d7337f2b1182d77e752df8ade90bdfe4" translate="yes" xml:space="preserve">
          <source>Of course you can also define self references with belongsToMany:</source>
          <target state="translated">もちろん、自己参照を belongsToMany で定義することもできます。</target>
        </trans-unit>
        <trans-unit id="c3d7707984f636d4a319d5e24e37abbc8d39c65c" translate="yes" xml:space="preserve">
          <source>Of course, the outcome will depend upon your babel configuration (such as in a &lt;code&gt;.babelrc&lt;/code&gt; file). Learn more at &lt;a href=&quot;https://babeljs.io&quot;&gt;babeljs.io&lt;/a&gt;.</source>
          <target state="translated">もちろん、結果は（ &lt;code&gt;.babelrc&lt;/code&gt; ファイルなどの）babel構成によって異なります。詳細については、&lt;a href=&quot;https://babeljs.io&quot;&gt;babeljs.ioを&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="d4677ce1c5e0c4dec82432cd03eb9e4977e1e301" translate="yes" xml:space="preserve">
          <source>Of course, this behavior is easily configurable.</source>
          <target state="translated">もちろん、この動作は簡単に設定できます。</target>
        </trans-unit>
        <trans-unit id="6996a110d4fbad998db495e1d5480c250fa89d29" translate="yes" xml:space="preserve">
          <source>Of course, using &lt;code&gt;async&lt;/code&gt; and &lt;code&gt;await&lt;/code&gt; works normally as well.</source>
          <target state="translated">もちろん、 &lt;code&gt;async&lt;/code&gt; と &lt;code&gt;await&lt;/code&gt; の使用も正常に機能します。</target>
        </trans-unit>
        <trans-unit id="fb5654b91a94e76ab0d91f9617ed39a9eb1b3449" translate="yes" xml:space="preserve">
          <source>Offset for result</source>
          <target state="translated">結果のオフセット</target>
        </trans-unit>
        <trans-unit id="6a8127eb43bf543e2cf1dbb0892cd7b8b334689a" translate="yes" xml:space="preserve">
          <source>On success, the callback will be called with this instance. On validation error, the callback will be called with an instance of &lt;code&gt;Sequelize.ValidationError&lt;/code&gt;. This error will have a property for each of the fields for which validation failed, with the error message for that field.</source>
          <target state="translated">成功すると、このインスタンスでコールバックが呼び出されます。検証エラー時に、コールバックは &lt;code&gt;Sequelize.ValidationError&lt;/code&gt; のインスタンスで呼び出されます。このエラーには、検証が失敗した各フィールドのプロパティと、そのフィールドのエラーメッセージが含まれます。</target>
        </trans-unit>
        <trans-unit id="1351ee779095a3ab702837d5f4875be94e30e8c5" translate="yes" xml:space="preserve">
          <source>On the other hand, constraints are rules defined at SQL level. The most basic example of constraint is an Unique Constraint. If a constraint check fails, an error will be thrown by the database and Sequelize will forward this error to JavaScript (in this example, throwing a &lt;code&gt;SequelizeUniqueConstraintError&lt;/code&gt;). Note that in this case, the SQL query was performed, unlike the case for validations.</source>
          <target state="translated">一方、制約はSQLレベルで定義されたルールです。制約の最も基本的な例は、一意性制約です。制約チェックが失敗した場合、データベースによってエラーがスローされ、SequelizeはこのエラーをJavaScriptに転送します（この例では、 &lt;code&gt;SequelizeUniqueConstraintError&lt;/code&gt; をスローします）。この場合、検証の場合とは異なり、SQLクエリが実行されたことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a6e8712ec2c54c580ef45527e2407d442845c74b" translate="yes" xml:space="preserve">
          <source>On the other hand, if it is set to allow null (with &lt;code&gt;allowNull: true&lt;/code&gt;) and that value has been set to &lt;code&gt;null&lt;/code&gt;, only the built-in validators will be skipped, while the custom validators will still run.</source>
          <target state="translated">一方、nullを許可するように（ &lt;code&gt;allowNull: true&lt;/code&gt; ）設定され、その値が &lt;code&gt;null&lt;/code&gt; に設定されている場合、組み込みのバリデーターのみがスキップされ、カスタムバリデーターは引き続き実行されます。</target>
        </trans-unit>
        <trans-unit id="07f665a8c99eed865083f085d98ec8fca0015d7c" translate="yes" xml:space="preserve">
          <source>Once you created an object and got a reference to it, you can delete it from the database. The relevant method is &lt;code&gt;destroy&lt;/code&gt;:</source>
          <target state="translated">オブジェクトを作成して参照を取得したら、データベースから削除できます。関連するメソッドは &lt;code&gt;destroy&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="1f9b5321949a967ef42f55010f8e75dec29c3613" translate="yes" xml:space="preserve">
          <source>Once you have properly configured CLI config file you are ready to create your first migration. It's as simple as executing a simple command.</source>
          <target state="translated">CLIの設定ファイルを適切に設定したら、最初のマイグレーションを作成する準備ができました。それは簡単なコマンドを実行するのと同じくらい簡単です。</target>
        </trans-unit>
        <trans-unit id="e69d5be30175ff220d73f4f3f130507d5b0acad9" translate="yes" xml:space="preserve">
          <source>One game has many teams associated to it (the ones that are playing that game);</source>
          <target state="translated">1つのゲームには、それに関連する多くのチーム(そのゲームをプレイしているチーム)があります。</target>
        </trans-unit>
        <trans-unit id="e5de0806a95c7c387a573daff3380d96ce666e45" translate="yes" xml:space="preserve">
          <source>One team may have participated in many games.</source>
          <target state="translated">一つのチームが多くの試合に出場している可能性があります。</target>
        </trans-unit>
        <trans-unit id="a99024618c2527f3bc655af2bf9a61a350050032" translate="yes" xml:space="preserve">
          <source>One-To-Many associations (hasMany)</source>
          <target state="translated">一対多の関連付け</target>
        </trans-unit>
        <trans-unit id="80b8e313d7e20adeab654b03732c8d3a72861cc7" translate="yes" xml:space="preserve">
          <source>One-To-Many associations are connecting one source with multiple targets, while all these targets are connected only with this single source.</source>
          <target state="translated">一対多のアソシエーションは、1つのソースと複数のターゲットを接続していますが、これらのターゲットはすべてこの1つのソースのみで接続されています。</target>
        </trans-unit>
        <trans-unit id="b04078f82acb5642e470ea54f09be546dc7432a7" translate="yes" xml:space="preserve">
          <source>One-To-Many associations are connecting one source with multiple targets. The targets however are again connected to exactly one specific source.</source>
          <target state="translated">一対多の関連付けは、1 つのソースと複数のターゲットを接続します。しかし、ターゲットは再び特定のソースに接続されています。</target>
        </trans-unit>
        <trans-unit id="b5a781b5514ee94996d11452869654e21fc523a3" translate="yes" xml:space="preserve">
          <source>One-To-Many relationships</source>
          <target state="translated">一対多の関係</target>
        </trans-unit>
        <trans-unit id="159ce298fdb55c0ace2cae5b9eeddb9085ed1b07" translate="yes" xml:space="preserve">
          <source>One-To-One associations</source>
          <target state="translated">一対一の会</target>
        </trans-unit>
        <trans-unit id="7ac7134636ef26e8db79e47ff7c804d75176aa8d" translate="yes" xml:space="preserve">
          <source>One-To-One associations are associations between exactly two models connected by a single foreign key.</source>
          <target state="translated">1対1のアソシエーションは、1つの外部キーで接続された2つのモデル間のアソシエーションです。</target>
        </trans-unit>
        <trans-unit id="a6f42f09b773908f656b88977e0de752b08cbfe9" translate="yes" xml:space="preserve">
          <source>One-To-One relationships</source>
          <target state="translated">一対一の関係</target>
        </trans-unit>
        <trans-unit id="eb9ea5ba36ce6f7d9d94e0be6907f913407401de" translate="yes" xml:space="preserve">
          <source>One-to-One and One-to-Many associations</source>
          <target state="translated">一対一・一対多の会</target>
        </trans-unit>
        <trans-unit id="2309e67cc0497393678cf4861e18785cba42982e" translate="yes" xml:space="preserve">
          <source>One-to-many association</source>
          <target state="translated">一対多の会</target>
        </trans-unit>
        <trans-unit id="52422157c5551a74edd9efae050fd0cbd45e6b6a" translate="yes" xml:space="preserve">
          <source>One-to-one association</source>
          <target state="translated">一対一の会</target>
        </trans-unit>
        <trans-unit id="80c2f522b0cc71f97fccf4d0cc3b4b1a1a723e86" translate="yes" xml:space="preserve">
          <source>Only a hook with name param can be removed.</source>
          <target state="translated">name paramを持つフックだけが削除されます。</target>
        </trans-unit>
        <trans-unit id="d7c3ed5082d4c21101247c805bae6a1b4e6471d0" translate="yes" xml:space="preserve">
          <source>Only available for Postgres</source>
          <target state="translated">Postgresでのみ利用可能</target>
        </trans-unit>
        <trans-unit id="78606afd96fe0f52ff679e248222b3ca8c9d2f35" translate="yes" xml:space="preserve">
          <source>Only retry a query if the error matches one of these strings.</source>
          <target state="translated">エラーがこれらの文字列のいずれかに一致する場合にのみ、クエリを再試行します。</target>
        </trans-unit>
        <trans-unit id="3e2300fe17116ec50dc76cbd8fba7c82514d27c0" translate="yes" xml:space="preserve">
          <source>Only then the &lt;code&gt;sequelize.transaction&lt;/code&gt; call will settle:</source>
          <target state="translated">その場合にのみ、 &lt;code&gt;sequelize.transaction&lt;/code&gt; 呼び出しが解決します。</target>
        </trans-unit>
        <trans-unit id="ef20bd5977f69845fb3605c4d34d8da2e99079ec" translate="yes" xml:space="preserve">
          <source>Only used by sqlite. Defaults to ':memory:'</source>
          <target state="translated">sqliteでのみ使用されます。デフォルトは':memory:'です。</target>
        </trans-unit>
        <trans-unit id="72994e2f28b83f1f262ee9b3a2e57ad75ee09f35" translate="yes" xml:space="preserve">
          <source>Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.</source>
          <target state="translated">TRUNCATEと併用して使用します。切り捨てられたテーブルの列が所有するシーケンスを自動的に再開します。</target>
        </trans-unit>
        <trans-unit id="659fa6ab2bfaf4a00c71607875bf9ee544072de3" translate="yes" xml:space="preserve">
          <source>Only used in conjunction with TRUNCATE. Truncates all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.</source>
          <target state="translated">TRUNCATEと併用してのみ使用されます。指定されたテーブルへの外部キー参照を持つすべてのテーブル、またはCASCADEによってグループに追加されたテーブルを切り捨てます。</target>
        </trans-unit>
        <trans-unit id="1e5c03c4ca5dbc17c5a6129ff8dbe16f01a71ebd" translate="yes" xml:space="preserve">
          <source>Op</source>
          <target state="translated">Op</target>
        </trans-unit>
        <trans-unit id="8fe26ec471775c33716aff2e25b307500cb8f70b" translate="yes" xml:space="preserve">
          <source>Operator symbols to be used when querying data</source>
          <target state="translated">データの問い合わせ時に使用する演算子記号</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="7cbeab9a20efe2e2217d5d299f851a542c5447fe" translate="yes" xml:space="preserve">
          <source>Operators Aliases</source>
          <target state="translated">オペレータの別名</target>
        </trans-unit>
        <trans-unit id="72687734b357dface3249321a849ea8462093c98" translate="yes" xml:space="preserve">
          <source>Operators for possible operators __Alias__: _all_ The promise is resolved with an array of Model instances if the query succeeds._</source>
          <target state="translated">可能な演算子 __Alias__.All_クエリが成功した場合、プロミスはモデルインスタンスの配列で解決されます。</target>
        </trans-unit>
        <trans-unit id="09a779d716fb827fb88714d6257f33d91fa93ea1" translate="yes" xml:space="preserve">
          <source>Operators security</source>
          <target state="translated">オペレータのセキュリティ</target>
        </trans-unit>
        <trans-unit id="778c618117429ef2dedad8c828b71d5371cf6e0f" translate="yes" xml:space="preserve">
          <source>Optimistic Locking</source>
          <target state="translated">楽観的なロッキング</target>
        </trans-unit>
        <trans-unit id="6140cd6be492f81e9de5ce4e733267b4f93e5075" translate="yes" xml:space="preserve">
          <source>Optimistic locking allows concurrent access to model records for edits and prevents conflicts from overwriting data. It does this by checking whether another process has made changes to a record since it was read and throws an OptimisticLockError when a conflict is detected.</source>
          <target state="translated">オプティミスティック・ロックは、編集のためのモデル・レコードへの同時アクセスを可能にし、競合がデータを上書きするのを防ぎます。これは、読み取り後に別のプロセスがレコードに変更を加えたかどうかをチェックし、競合が検出された場合にOptimisticLockErrorをスローします。</target>
        </trans-unit>
        <trans-unit id="8f677a4471721e62d141c02c1a6189a2cab24531" translate="yes" xml:space="preserve">
          <source>Optimistic locking is disabled by default and can be enabled by setting the &lt;code&gt;version&lt;/code&gt; property to true in a specific model definition or global model configuration. See &lt;a href=&quot;models-definition#configuration&quot;&gt;model configuration&lt;/a&gt; for more details.</source>
          <target state="translated">オプティミスティックロックはデフォルトで無効になっており、特定のモデル定義またはグローバルモデル構成で &lt;code&gt;version&lt;/code&gt; プロパティをtrueに設定することで有効にできます。詳細については、&lt;a href=&quot;models-definition#configuration&quot;&gt;モデル構成&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a45991670c71fc0c7f3eb11ef210b0020884d66a" translate="yes" xml:space="preserve">
          <source>OptimisticLockError</source>
          <target state="translated">OptimisticLockError</target>
        </trans-unit>
        <trans-unit id="1664e83457c5b5ad3dd1a7ec25b5b6fdcdaa8bfb" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;returning: true&lt;/code&gt; will no longer return attributes that are not defined in the model. Old behavior can be achieved by using &lt;code&gt;returning: ['*']&lt;/code&gt; instead.</source>
          <target state="translated">オプションの &lt;code&gt;returning: true&lt;/code&gt; は、モデルで定義されていない属性を返しません。古い動作は、代わりに &lt;code&gt;returning: ['*']&lt;/code&gt; を使用することで実現できます。</target>
        </trans-unit>
        <trans-unit id="5182cc6f458b27f798ef769e48426d170adaca6f" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;returning: true&lt;/code&gt; will no longer return attributes that are not defined in the model. Old behavior can be restored by using &lt;code&gt;returning: ['*']&lt;/code&gt;</source>
          <target state="translated">オプションが &lt;code&gt;returning: true&lt;/code&gt; は、モデルで定義されていない属性を返さなくなります。return &lt;code&gt;returning: ['*']&lt;/code&gt; を使用すると、古い動作を復元できます。</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="2573f9c5c9739bda23063f4ec6575c5d4fcbe3c1" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.create&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;target.create&lt;/code&gt; に渡されるオプション</target>
        </trans-unit>
        <trans-unit id="fc281780c58169a65a5387bce961e7af93c4bb24" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.create&lt;/code&gt; and setAssociation.</source>
          <target state="translated">&lt;code&gt;target.create&lt;/code&gt; およびsetAssociationに渡されるオプション。</target>
        </trans-unit>
        <trans-unit id="40b503e9df444ee2d315f6badf5d3e76b933fb08" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.findAll&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;target.findAll&lt;/code&gt; および &lt;code&gt;update&lt;/code&gt; に渡されるオプション。</target>
        </trans-unit>
        <trans-unit id="0f7d5ec9760408cef1a3917f12f6c577fe6b6b15" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.update&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;target.update&lt;/code&gt; に渡されるオプション</target>
        </trans-unit>
        <trans-unit id="5943acc368ef8e8a62d06081b8cac9a14bc7c85f" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;target.update&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;target.update&lt;/code&gt; に渡されるオプション。</target>
        </trans-unit>
        <trans-unit id="6a4f8685a8ba251504870ba17fa94124cb574705" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;through.destroy&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;through.destroy&lt;/code&gt; に渡されるオプション</target>
        </trans-unit>
        <trans-unit id="0115f779a0e49b0656989e51e294eb81c64793d7" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;through.findAll&lt;/code&gt;, &lt;code&gt;bulkCreate&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;through.findAll&lt;/code&gt; 、 &lt;code&gt;bulkCreate&lt;/code&gt; 、および &lt;code&gt;update&lt;/code&gt; に渡されるオプション</target>
        </trans-unit>
        <trans-unit id="26176f8cc30b890f9a9b8e35a52a1de2b863ffe7" translate="yes" xml:space="preserve">
          <source>Options passed to &lt;code&gt;through.findAll&lt;/code&gt;, &lt;code&gt;bulkCreate&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;destroy&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;through.findAll&lt;/code&gt; 、 &lt;code&gt;bulkCreate&lt;/code&gt; 、 &lt;code&gt;update&lt;/code&gt; および &lt;code&gt;destroy&lt;/code&gt; に渡されるオプション</target>
        </trans-unit>
        <trans-unit id="4a4b33ed3ca527fbd4b9245bafffeee52768cf1a" translate="yes" xml:space="preserve">
          <source>Options passed to create and add</source>
          <target state="translated">作成と追加に渡されるオプション</target>
        </trans-unit>
        <trans-unit id="474d03cde40320ee091013efe8d0db26cc7d0b45" translate="yes" xml:space="preserve">
          <source>Options passed to getAssociation and &lt;code&gt;target.save&lt;/code&gt;</source>
          <target state="translated">getAssociationと &lt;code&gt;target.save&lt;/code&gt; に渡されるオプション</target>
        </trans-unit>
        <trans-unit id="fee507ed9dc18ea297e1ba8190f5aa49edd68423" translate="yes" xml:space="preserve">
          <source>Options passed to getAssociations</source>
          <target state="translated">getAssociations に渡されるオプション</target>
        </trans-unit>
        <trans-unit id="06fee8d775b90a83eb6e0500643ad5937a039f32" translate="yes" xml:space="preserve">
          <source>Options that are passed on to &lt;code&gt;Model.find&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Model.find&lt;/code&gt; に渡されるオプション</target>
        </trans-unit>
        <trans-unit id="ee8bbce524fef6ba7c6dbac58492250221aae721" translate="yes" xml:space="preserve">
          <source>Options that are passed to the validator</source>
          <target state="translated">バリデータに渡されるオプション</target>
        </trans-unit>
        <trans-unit id="a2025fe246c877972310ec609eb48f54489ec039" translate="yes" xml:space="preserve">
          <source>Options to describe the scope of the search.</source>
          <target state="translated">検索範囲を記述するオプション。</target>
        </trans-unit>
        <trans-unit id="3f3859dbc9487b25a2b59e3d5cd366d7fb290390" translate="yes" xml:space="preserve">
          <source>Or use the &lt;em&gt;&lt;a href=&quot;#special-methods-mixins-added-to-instances&quot;&gt;special methods/mixins&lt;/a&gt;&lt;/em&gt; available for associated models, which are explained later on this page.</source>
          <target state="translated">または、このページの後半で説明する、関連するモデルで使用できる&lt;em&gt;&lt;a href=&quot;#special-methods-mixins-added-to-instances&quot;&gt;特別なメソッド/ミックスインを&lt;/a&gt;&lt;/em&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="bec1ed99ae879b5c4b91ae857a753fb5fb51217b" translate="yes" xml:space="preserve">
          <source>Or you can use a connection string as well with a path:</source>
          <target state="translated">または、パスを指定して接続文字列を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="dbc9ff5400f0f9e6142729232a25f5dcca1a8793" translate="yes" xml:space="preserve">
          <source>Or, if your callback throws, rejecting with the thrown error</source>
          <target state="translated">あるいは、コールバックがスローされた場合は、スローされたエラーで拒否します。</target>
        </trans-unit>
        <trans-unit id="9f1762b33b20d79d93b528934ab2323b45f0b56c" translate="yes" xml:space="preserve">
          <source>Order of Operations</source>
          <target state="translated">業務の順序</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="7c3e631356b9b789997f759381378ec61789d79c" translate="yes" xml:space="preserve">
          <source>Ordering Eager Loaded Associations</source>
          <target state="translated">イージーロードされた協会を注文する</target>
        </trans-unit>
        <trans-unit id="c4074f8dc0dcc50a668d9c0e4f1182abf0d386af" translate="yes" xml:space="preserve">
          <source>Ordering and Grouping</source>
          <target state="translated">注文とグループ化</target>
        </trans-unit>
        <trans-unit id="d4c5ce82318e26ae51c29ee1ce6341214a0d8425" translate="yes" xml:space="preserve">
          <source>Ordering eager loaded associations</source>
          <target state="translated">熱心にロードされた関連付けを注文する</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="522eda5cc722083fbfe57e34a45a7259dc33c472" translate="yes" xml:space="preserve">
          <source>Other Data Types</source>
          <target state="translated">その他のデータ型</target>
        </trans-unit>
        <trans-unit id="96c2ab3009653c0dea9ef2fbe566de5309b08a8e" translate="yes" xml:space="preserve">
          <source>Other instance to compare against</source>
          <target state="translated">他の比較例</target>
        </trans-unit>
        <trans-unit id="8d7bf5bf136e81f9388c1f4eca050d6d94e965d7" translate="yes" xml:space="preserve">
          <source>Others</source>
          <target state="translated">Others</target>
        </trans-unit>
        <trans-unit id="7e77ada74a3be01c5d888912daa8e9c03d2a3dd2" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt; will be equivalent to &lt;code&gt;{ transaction: undefined }&lt;/code&gt;, which won't use a transaction (which is ok).</source>
          <target state="translated">それ以外の場合、 &lt;code&gt;{ transaction: options.transaction }&lt;/code&gt; は &lt;code&gt;{ transaction: undefined }&lt;/code&gt; と同等になり、トランザクションを使用しません（これは問題ありません）。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
