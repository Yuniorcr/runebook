<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="2a754fbd5a5705920e61152dd8c6911b9ca9d965" translate="yes" xml:space="preserve">
          <source>If the executable called by system()/exec()/pipe-open()/&lt;code&gt;``&lt;/code&gt; is a script without &quot;magic&quot; line, and &lt;code&gt;$ENV{EXECSHELL}&lt;/code&gt; is set to shell;</source>
          <target state="translated">実行可能ファイルは、システム（）/ EXEC（）/パイプオープン（によって呼び出された場合）/ &lt;code&gt;``&lt;/code&gt; 「魔法」の行せずにスクリプトであり、 &lt;code&gt;$ENV{EXECSHELL}&lt;/code&gt; シェルに設定されています。</target>
        </trans-unit>
        <trans-unit id="6143c4a0521be912f40be9869aedf7b75cf3c5aa" translate="yes" xml:space="preserve">
          <source>If the executable called by system()/exec()/pipe-open()/&lt;code&gt;``&lt;/code&gt; is not found (is not this remark obsolete?);</source>
          <target state="translated">システム（）/ EXEC（）/パイプオープン（）/によって呼び出され実行可能であれば &lt;code&gt;``&lt;/code&gt; 見出されない（？この発言は時代遅れではありません）。</target>
        </trans-unit>
        <trans-unit id="50b9d8b532d25e89b151dc2833716077761d9468" translate="yes" xml:space="preserve">
          <source>If the exit status used is less than 2, then output is printed on &lt;code&gt;STDOUT&lt;/code&gt; . Otherwise output is printed on &lt;code&gt;STDERR&lt;/code&gt; .</source>
          <target state="translated">使用される終了ステータスが2未満の場合、出力は &lt;code&gt;STDOUT&lt;/code&gt; に出力されます。それ以外の場合、出力は &lt;code&gt;STDERR&lt;/code&gt; に出力されます。</target>
        </trans-unit>
        <trans-unit id="e6254e53f84fb9e366ade9a7d71888f7244075a2" translate="yes" xml:space="preserve">
          <source>If the exit status used is less than 2, then output is printed on &lt;code&gt;STDOUT&lt;/code&gt;. Otherwise output is printed on &lt;code&gt;STDERR&lt;/code&gt;.</source>
          <target state="translated">使用される終了ステータスが2未満の場合、出力は &lt;code&gt;STDOUT&lt;/code&gt; に出力されます。それ以外の場合、出力は &lt;code&gt;STDERR&lt;/code&gt; に出力されます。</target>
        </trans-unit>
        <trans-unit id="48f5e0e5ea6330c7048648eb2edf1ad4ccc05a55" translate="yes" xml:space="preserve">
          <source>If the experimental &quot;bitwise&quot; feature is enabled (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;), a fifth TRUE argument is passed to subroutines handling &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; . This indicates that the caller is expecting numeric behaviour. The fourth argument will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, as that position (&lt;code&gt;$_[3]&lt;/code&gt; ) is reserved for use by &lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt;.</source>
          <target state="translated">実験的な「ビット単位」機能が有効になっている場合（&lt;a href=&quot;feature&quot;&gt;機能を&lt;/a&gt;参照）、5番目のTRUE引数が &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; を処理するサブルーチンに渡されます。、 &lt;code&gt;^&lt;/code&gt; および &lt;code&gt;~&lt;/code&gt; 。これは、呼び出し元が数値の動作を期待していることを示しています。その位置（ &lt;code&gt;$_[3]&lt;/code&gt; ）は&lt;a href=&quot;#nomethod&quot;&gt;nomethod&lt;/a&gt;で使用するために予約されているため、4番目の引数は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="8d70ab84f3a316c00496bd0dced7b93acc9fa6af" translate="yes" xml:space="preserve">
          <source>If the experimental &quot;bitwise&quot; feature is enabled via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'bitwise'&lt;/code&gt; , then this operator always treats its operand as numbers. This feature produces a warning unless you also use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings
'experimental::bitwise'&lt;/code&gt; .</source>
          <target state="translated">実験的な「ビット単位」機能が &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'bitwise'&lt;/code&gt; で有効になっている場合、この演算子は常にそのオペランドを数値として扱います。 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::bitwise'&lt;/code&gt; &lt;a href=&quot;functions/no&quot;&gt;という&lt;/a&gt;警告も使用しない限り、この機能は警告を生成します。</target>
        </trans-unit>
        <trans-unit id="429f3423b67c7b1e2fda19e3e61bde6079c26d75" translate="yes" xml:space="preserve">
          <source>If the experimental &quot;bitwise&quot; feature is enabled via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'bitwise'&lt;/code&gt; , then unary &lt;code&gt;&quot;~&quot;&lt;/code&gt; always treats its argument as a number, and an alternate form of the operator, &lt;code&gt;&quot;~.&quot;&lt;/code&gt; , always treats its argument as a string. So &lt;code&gt;~0&lt;/code&gt; and &lt;code&gt;~&quot;0&quot;&lt;/code&gt; will both give 2**32-1 on 32-bit platforms, whereas &lt;code&gt;~.0&lt;/code&gt; and &lt;code&gt;~.&quot;0&quot;&lt;/code&gt; will both yield &lt;code&gt;&quot;\xff&quot;&lt;/code&gt; . This feature produces a warning unless you use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::bitwise'&lt;/code&gt; .</source>
          <target state="translated">実験的な「ビット単位」機能が &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'bitwise'&lt;/code&gt; で有効になっている場合、単項 &lt;code&gt;&quot;~&quot;&lt;/code&gt; 常にその引数を数値として扱い、演算子 &lt;code&gt;&quot;~.&quot;&lt;/code&gt; 代替形式を扱います。、常にその引数を文字列として扱います。だから、 &lt;code&gt;~0&lt;/code&gt; と &lt;code&gt;~&quot;0&quot;&lt;/code&gt; 意志の32ビット・プラットフォーム上の両方ギブ2 ** 32-1のに対し、 &lt;code&gt;~.0&lt;/code&gt; と &lt;code&gt;~.&quot;0&quot;&lt;/code&gt; 意志の両方の利回り &lt;code&gt;&quot;\xff&quot;&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'experimental::bitwise'&lt;/code&gt; &lt;a href=&quot;functions/no&quot;&gt;という&lt;/a&gt;警告を使用しない限り、この機能は警告を生成します。</target>
        </trans-unit>
        <trans-unit id="bc923038f738e51827c6486386f676bb16b7db9f" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to a label name, its scope will be resolved dynamically. This allows for computed &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">式がラベル名に評価される場合、そのスコープは動的に解決されます。これにより、FORTRANごとに計算された&lt;a href=&quot;#goto-LABEL&quot;&gt; &lt;code&gt;goto&lt;/code&gt; &lt;/a&gt;が可能になりますが、保守性を最適化する場合は必ずしも推奨されません。</target>
        </trans-unit>
        <trans-unit id="44c964489535901a948a3b23073f9b9bb3c0a3e6" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to a label name, its scope will be resolved dynamically. This allows for computed &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">式がラベル名に評価される場合、そのスコープは動的に解決されます。これにより、FORTRANごとに計算された &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; が可能になりますが、保守性を最適化している場合は、必ずしも推奨されません。</target>
        </trans-unit>
        <trans-unit id="c0c3c70b730f0e2950f8179af548175b3c6ef32a" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to a label name, its scope will be resolved dynamically. This allows for computed &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">式がラベル名に評価される場合、そのスコープは動的に解決されます。これにより、FORTRANごとに計算された &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; が可能になりますが、保守性を最適化している場合は、必ずしも推奨されません。</target>
        </trans-unit>
        <trans-unit id="3a5f344d7e209018f81b3bb395e41710ea76000e" translate="yes" xml:space="preserve">
          <source>If the extension doesn't contain a &lt;code&gt;*&lt;/code&gt; , then it is appended to the end of the current filename as a suffix. If the extension does contain one or more &lt;code&gt;*&lt;/code&gt; characters, then each &lt;code&gt;*&lt;/code&gt; is replaced with the current filename. In Perl terms, you could think of this as:</source>
          <target state="translated">拡張子に &lt;code&gt;*&lt;/code&gt; が含まれていない場合は、現在のファイル名の末尾にサフィックスとして追加されます。拡張子に1つ以上の &lt;code&gt;*&lt;/code&gt; 文字が含まれている場合、各 &lt;code&gt;*&lt;/code&gt; は現在のファイル名に置き換えられます。Perlの用語では、これは次のように考えることができます。</target>
        </trans-unit>
        <trans-unit id="de01c14a7209a45c44123f6710c3fc14dda93261" translate="yes" xml:space="preserve">
          <source>If the extension doesn't contain a &lt;code&gt;*&lt;/code&gt;, then it is appended to the end of the current filename as a suffix. If the extension does contain one or more &lt;code&gt;*&lt;/code&gt; characters, then each &lt;code&gt;*&lt;/code&gt; is replaced with the current filename. In Perl terms, you could think of this as:</source>
          <target state="translated">拡張子に &lt;code&gt;*&lt;/code&gt; が含まれていない場合は、現在のファイル名の末尾にサフィックスとして追加されます。拡張子に1つ以上の &lt;code&gt;*&lt;/code&gt; 文字が含まれている場合、各 &lt;code&gt;*&lt;/code&gt; は現在のファイル名に置き換えられます。 Perlの用語では、これは次のように考えることができます。</target>
        </trans-unit>
        <trans-unit id="912122ed04813ef6afa69c21de9ff5d7b9578a1b" translate="yes" xml:space="preserve">
          <source>If the extension links to a library that it builds, set this to the name of the library (see SDBM_File)</source>
          <target state="translated">拡張機能がビルドするライブラリにリンクしている場合は、これをライブラリの名前に設定します (SDBM_File を参照してください)。</target>
        </trans-unit>
        <trans-unit id="d3a643174ddd0d9876c30f4ff9ae6dc788ca282c" translate="yes" xml:space="preserve">
          <source>If the extension might need extra libraries, they should be included here. The extension Makefile.PL will take care of checking whether the libraries actually exist and how they should be loaded. The extra libraries should be specified in the form -lm -lposix, etc, just as on the cc command line. By default, the Makefile.PL will search through the library path determined by Configure. That path can be augmented by including arguments of the form &lt;b&gt;-L/another/library/path&lt;/b&gt; in the extra-libraries argument.</source>
          <target state="translated">拡張機能に追加のライブラリが必要な場合は、ここに含める必要があります。拡張Makefile.PLは、ライブラリが実際に存在するかどうか、およびライブラリのロード方法をチェックします。追加のライブラリーは、ccコマンド行と同様に、-lm -lposixなどの形式で指定する必要があります。デフォルトでは、Makefile.PLは、Configureによって決定されたライブラリパスを検索します。そのパスは、&lt;b&gt;-L / another / library / path&lt;/b&gt;という形式の引数を追加ライブラリの引数に含めることによって拡張できます。</target>
        </trans-unit>
        <trans-unit id="effa256cfcef0cdd6582a1503da6bdf1fb1d1f9e" translate="yes" xml:space="preserve">
          <source>If the external</source>
          <target state="translated">外部からの</target>
        </trans-unit>
        <trans-unit id="2e204c469081d0ce7742a3d71bcaeedaf9240cda" translate="yes" xml:space="preserve">
          <source>If the extractor fails to match (in the case of a regex extractor), or returns an empty list or an undefined value (in the case of a subroutine extractor), it is assumed to have failed to extract. If none of the extractor subroutines succeeds, then one character is extracted from the start of the text and the extraction subroutines reapplied. Characters which are thus removed are accumulated and eventually become the next field (unless the fourth argument is true, in which case they are discarded).</source>
          <target state="translated">抽出サブルーチンが一致しない場合(正規表現抽出器の場合)、空のリストや未定義の値を返す場合(抽出サブルーチンの場合)は、抽出に失敗したとみなされます。抽出サブルーチンのいずれも成功しなかった場合は、テキストの先頭から1文字を抽出し、抽出サブルーチンを再適用します。こうして取り除かれた文字は蓄積され、最終的には次のフィールドになります(第4引数が真でない限り、その場合は破棄されます)。</target>
        </trans-unit>
        <trans-unit id="17d2c98a680d0b983c00126ba7fbf7037583b89d" translate="yes" xml:space="preserve">
          <source>If the extractor is a hash reference, it must contain exactly one element. The value of that element is one of the above extractor types (subroutine reference, regular expression, or string). The key of that element is the name of a class into which the successful return value of the extractor will be blessed.</source>
          <target state="translated">抽出器がハッシュ参照である場合、それは正確に1つの要素を含まなければなりません。その要素の値は、上記の抽出器の型(サブルーチン参照、正規表現、文字列)のいずれかです。その要素のキーは、抽出器の戻り値が成功した場合に祝福されるクラスの名前です。</target>
        </trans-unit>
        <trans-unit id="a2187e610c6c9ce986c9ab2bc434fe210c96d6c7" translate="yes" xml:space="preserve">
          <source>If the extractor is a precompiled regular expression or a string, it is matched against the text in a scalar context with a leading '\G' and the gc modifiers enabled. The extracted value is either $1 if that variable is defined after the match, or else the complete match (i.e. $&amp;amp;).</source>
          <target state="translated">抽出子がプリコンパイルされた正規表現または文字列の場合、スカラーコンテキストのテキストと照合され、先頭に '\ G'とgc修飾子が有効になります。抽出された値は、その変数が一致後に定義されている場合は$ 1、または完全一致（つまり$＆）です。</target>
        </trans-unit>
        <trans-unit id="8efec72894ea829331e728164da92723ccc10f46" translate="yes" xml:space="preserve">
          <source>If the extractor is a subroutine it is called in a list context and is expected to return a list of a single element, namely the extracted text. It may optionally also return two further arguments: a string representing the text left after extraction (like $' for a pattern match), and a string representing any prefix skipped before the extraction (like $` in a pattern match). Note that this is designed to facilitate the use of other Text::Balanced subroutines with &lt;code&gt;extract_multiple&lt;/code&gt; . Note too that the value returned by an extractor subroutine need not bear any relationship to the corresponding substring of the original text (see examples below).</source>
          <target state="translated">エクストラクタがサブルーチンの場合、リストコンテキストで呼び出され、単一の要素、つまり抽出されたテキストのリストを返すことが期待されます。オプションで、さらに2つの引数を返す場合もあります。抽出後に残ったテキストを表す文字列（パターンマッチの$ 'など）と、抽出前にスキップされた接頭辞を表す文字列（パターンマッチの$ `など）です。これは、他のText :: Balancedサブルーチンと &lt;code&gt;extract_multiple&lt;/code&gt; の使用を容易にするために設計されていることに注意してください。また、extractorサブルーチンによって返される値は、元のテキストの対応するサブストリングとの関係を持つ必要がないことにも注意してください（以下の例を参照）。</target>
        </trans-unit>
        <trans-unit id="91257d19dbe73c3f0115d0e82b54c986793ce4ee" translate="yes" xml:space="preserve">
          <source>If the extractor is a subroutine it is called in a list context and is expected to return a list of a single element, namely the extracted text. It may optionally also return two further arguments: a string representing the text left after extraction (like $' for a pattern match), and a string representing any prefix skipped before the extraction (like $` in a pattern match). Note that this is designed to facilitate the use of other Text::Balanced subroutines with &lt;code&gt;extract_multiple&lt;/code&gt;. Note too that the value returned by an extractor subroutine need not bear any relationship to the corresponding substring of the original text (see examples below).</source>
          <target state="translated">エクストラクタがサブルーチンの場合、リストコンテキストで呼び出され、単一の要素、つまり抽出されたテキストのリストを返すことが期待されます。オプションで、さらに2つの引数を返すこともできます。抽出後に残されたテキストを表す文字列（パターン一致の$ 'など）と、抽出前にスキップされたプレフィックスを表す文字列（パターン一致の$ `など）です。これは、 &lt;code&gt;extract_multiple&lt;/code&gt; で他のText :: Balancedサブルーチンを簡単に使用できるように設計されていることに注意してください。エクストラクタサブルーチンによって返される値は、元のテキストの対応する部分文字列とは関係がないことにも注意してください（以下の例を参照）。</target>
        </trans-unit>
        <trans-unit id="a385fcb5d8ca5cfa07426e73b4f41df3b2f355d3" translate="yes" xml:space="preserve">
          <source>If the field contains a numeric value it will be displayed in hex. Zip stored most numbers in little-endian format - the value displayed will have the little-endian encoding removed.</source>
          <target state="translated">フィールドに数値が含まれている場合は、16進数で表示されます。Zipはほとんどの数値をリトルエンディアン形式で保存しています。</target>
        </trans-unit>
        <trans-unit id="12045367f64a99179f5690e61487afbfd5fe1436" translate="yes" xml:space="preserve">
          <source>If the file begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then it is skipped before processing, and the content of the file is also decoded appropriately starting from perl 5.8.</source>
          <target state="translated">ファイルの先頭に UTF-8、UTF-16BE、UTF-16LE のバイト順マークがある場合は、処理の前にスキップされ、ファイルの内容も perl 5.8 から適切にデコードされます。</target>
        </trans-unit>
        <trans-unit id="8a0b45c8a0563151ba3b588e7383417bdd5f8a3d" translate="yes" xml:space="preserve">
          <source>If the file does not exist, &lt;code&gt;cpan&lt;/code&gt; dies.</source>
          <target state="translated">ファイルが存在しない場合、 &lt;code&gt;cpan&lt;/code&gt; は停止します。</target>
        </trans-unit>
        <trans-unit id="e4293d2972da49b7deee5cbac8e57e93be999a13" translate="yes" xml:space="preserve">
          <source>If the file is a symlink, the file it's pointing to</source>
          <target state="translated">ファイルがシンボリックリンクである場合、そのファイルが指し示すファイルは</target>
        </trans-unit>
        <trans-unit id="1260f14708b5c4f0e969b3d9b19ac87d75cb1573" translate="yes" xml:space="preserve">
          <source>If the file is pulled in by &lt;code&gt;perl_parse()&lt;/code&gt; , compiled into a newly constructed interpreter, and subsequently cleaned out with &lt;code&gt;perl_destruct()&lt;/code&gt; afterwards, you're shielded from most namespace troubles.</source>
          <target state="translated">ファイルが &lt;code&gt;perl_parse()&lt;/code&gt; によって取り込まれ、新しく構築されたインタープリターにコンパイルされ、その後 &lt;code&gt;perl_destruct()&lt;/code&gt; でクリーンアップされた場合、ほとんどのネームスペースの問題から保護されます。</target>
        </trans-unit>
        <trans-unit id="12e4d1ea92f7af34b6047df7fcc8abb443c9f062" translate="yes" xml:space="preserve">
          <source>If the file is pulled in by &lt;code&gt;perl_parse()&lt;/code&gt;, compiled into a newly constructed interpreter, and subsequently cleaned out with &lt;code&gt;perl_destruct()&lt;/code&gt; afterwards, you're shielded from most namespace troubles.</source>
          <target state="translated">ファイルが &lt;code&gt;perl_parse()&lt;/code&gt; によってプルされ、新しく構築されたインタープリターにコンパイルされ、その後 &lt;code&gt;perl_destruct()&lt;/code&gt; でクリーンアップされると、ほとんどの名前空間の問題から保護されます。</target>
        </trans-unit>
        <trans-unit id="0047e959707fe337b2aa331e4b4d29cbdd3ddf49" translate="yes" xml:space="preserve">
          <source>If the file named by FILENAME does not exist and the &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; call creates it (typically because MODE includes the &lt;code&gt;O_CREAT&lt;/code&gt; flag), then the value of PERMS specifies the permissions of the newly created file. If you omit the PERMS argument to &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt;, Perl uses the octal value &lt;code&gt;0666&lt;/code&gt;. These permission values need to be in octal, and are modified by your process's current &lt;a href=&quot;#umask-EXPR&quot;&gt;&lt;code&gt;umask&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">FILENAMEで指定されたファイルが存在せず、&lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;呼び出しで作成された場合（通常、MODEに &lt;code&gt;O_CREAT&lt;/code&gt; フラグが含まれているため）、PERMSの値は新しく作成されたファイルのアクセス許可を指定します。あなたがPERMS引数を省略した場合&lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt; &lt;code&gt;sysopen&lt;/code&gt; で&lt;/a&gt;、Perlは8進数値使用しています &lt;code&gt;0666&lt;/code&gt; 。これらの権限値は8進数である必要があり、プロセスの現在の&lt;a href=&quot;#umask-EXPR&quot;&gt; &lt;code&gt;umask&lt;/code&gt; &lt;/a&gt;によって変更されます。</target>
        </trans-unit>
        <trans-unit id="972b095c8cf0635710238db90318d20a5a12c4b1" translate="yes" xml:space="preserve">
          <source>If the file named by FILENAME does not exist and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call creates it (typically because MODE includes the &lt;code&gt;O_CREAT&lt;/code&gt; flag), then the value of PERMS specifies the permissions of the newly created file. If you omit the PERMS argument to &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, Perl uses the octal value &lt;code&gt;0666&lt;/code&gt; . These permission values need to be in octal, and are modified by your process's current &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">FILENAMEで指定されたファイルが存在せず、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 呼び出しでファイルが作成された場合（通常、MODEに &lt;code&gt;O_CREAT&lt;/code&gt; フラグが含まれているため）、PERMSの値は新しく作成されたファイルの権限を指定します。あなたがPERMS引数を省略した場合 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; で、Perlは8進数値使用しています &lt;code&gt;0666&lt;/code&gt; 。これらの許可値は8進数である必要があり、プロセスの現在の &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; によって変更されます。</target>
        </trans-unit>
        <trans-unit id="8aa66e9311c9629d0b8c20e950c88829b4d37f7e" translate="yes" xml:space="preserve">
          <source>If the file named by FILENAME does not exist and the &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call creates it (typically because MODE includes the &lt;code&gt;O_CREAT&lt;/code&gt; flag), then the value of PERMS specifies the permissions of the newly created file. If you omit the PERMS argument to &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, Perl uses the octal value &lt;code&gt;0666&lt;/code&gt; . These permission values need to be in octal, and are modified by your process's current &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">FILENAMEで指定されたファイルが存在せず、 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 呼び出しでファイルが作成された場合（通常、MODEに &lt;code&gt;O_CREAT&lt;/code&gt; フラグが含まれているため）、PERMSの値は新しく作成されたファイルの権限を指定します。あなたがPERMS引数を省略した場合 &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; で、Perlは8進数値使用しています &lt;code&gt;0666&lt;/code&gt; 。これらの許可値は8進数である必要があり、プロセスの現在の &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; によって変更されます。</target>
        </trans-unit>
        <trans-unit id="afca59eeb0296a7f173f43e8587c0ce7c2de1f87" translate="yes" xml:space="preserve">
          <source>If the file specification is already in a valid VMS syntax, it will be passed through unchanged, except that the UTF-8 flag will be cleared since VMS format file specifications are never in UTF-8.</source>
          <target state="translated">ファイル仕様がすでに有効なVMS構文である場合、VMS形式のファイル仕様は決してUTF-8ではないので、UTF-8フラグがクリアされることを除いて、変更されずに通過します。</target>
        </trans-unit>
        <trans-unit id="f20f26d4d2cfe896fd9be41e5561303708778051" translate="yes" xml:space="preserve">
          <source>If the file that contains the module begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then it is skipped before processing, and the content of the file is also decoded appropriately starting from perl 5.8.</source>
          <target state="translated">モジュールを含むファイルがUTF-8、UTF-16BE、UTF-16LEのバイト順マークで始まる場合は、処理の前にスキップされ、ファイルの内容もperl 5.8から適切にデコードされます。</target>
        </trans-unit>
        <trans-unit id="9b9e946eeefcb8ca3ed866d0a22b192157304573" translate="yes" xml:space="preserve">
          <source>If the file to be opened contains binary data instead of text characters, then the &lt;code&gt;MODE&lt;/code&gt; argument to &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is a little different. Instead of specifying the encoding, you tell Perl that your data are in raw bytes.</source>
          <target state="translated">開くファイルにテキスト文字ではなくバイナリデータが含まれている場合、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; &lt;code&gt;MODE&lt;/code&gt; 引数は少し異なります。エンコーディングを指定する代わりに、Perlにデータが生のバイトであることを伝えます。</target>
        </trans-unit>
        <trans-unit id="b62027d4bfba52954180b6ef864f354108e4a798" translate="yes" xml:space="preserve">
          <source>If the file to be opened contains binary data instead of text characters, then the &lt;code&gt;MODE&lt;/code&gt; argument to &lt;code&gt;open&lt;/code&gt; is a little different. Instead of specifying the encoding, you tell Perl that your data are in raw bytes.</source>
          <target state="translated">開くファイルにテキスト文字ではなくバイナリデータが含まれている場合、 &lt;code&gt;open&lt;/code&gt; &lt;code&gt;MODE&lt;/code&gt; 引数は少し異なります。エンコーディングを指定する代わりに、データがrawバイトであることをPerlに伝えます。</target>
        </trans-unit>
        <trans-unit id="ed7727f14d3896e4199132a911f1277a6913be80" translate="yes" xml:space="preserve">
          <source>If the file was loaded via a hook (e.g. a subroutine reference, see &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for a description of these hooks), this hook is by default inserted into &lt;code&gt;%INC&lt;/code&gt; in place of a filename. Note, however, that the hook may have set the &lt;code&gt;%INC&lt;/code&gt; entry by itself to provide some more specific info.</source>
          <target state="translated">ファイルがフックを介してロードされた場合（たとえば、サブルーチン参照、これらのフックの説明については&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;を参照）、このフックはデフォルトでファイル名の代わりに &lt;code&gt;%INC&lt;/code&gt; に挿入されます。ただし、フックが &lt;code&gt;%INC&lt;/code&gt; エントリを設定して、より具体的な情報を提供している場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="cf52c06965f9e5fc28f2b729df47caf3473ff123" translate="yes" xml:space="preserve">
          <source>If the file was loaded via a hook (e.g. a subroutine reference, see &lt;a href=&quot;perlfunc#require&quot;&gt;&quot;require&quot; in perlfunc&lt;/a&gt; for a description of these hooks), this hook is by default inserted into &lt;code&gt;%INC&lt;/code&gt; in place of a filename. Note, however, that the hook may have set the &lt;code&gt;%INC&lt;/code&gt; entry by itself to provide some more specific info.</source>
          <target state="translated">ファイルがフックを介してロードされた場合（たとえば、サブルーチン参照。これらのフックの説明については&lt;a href=&quot;perlfunc#require&quot;&gt;、perlfuncの「require」を&lt;/a&gt;参照）、このフックはデフォルトでファイル名の代わりに &lt;code&gt;%INC&lt;/code&gt; に挿入されます。ただし、フックが &lt;code&gt;%INC&lt;/code&gt; エントリを単独で設定して、より具体的な情報を提供している可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="cbada7e6f993214c7ee778a69597cde7ab2c7bef" translate="yes" xml:space="preserve">
          <source>If the file was modified and the server response includes a properly formatted &lt;code&gt;Last-Modified&lt;/code&gt; header, the file modification time will be updated accordingly.</source>
          <target state="translated">ファイルが変更され、サーバーの応答に適切にフォーマットされた &lt;code&gt;Last-Modified&lt;/code&gt; ヘッダーが含まれている場合、ファイルの変更時刻はそれに応じて更新されます。</target>
        </trans-unit>
        <trans-unit id="1055d8f3bf09e356a8ac90a312ee4c58ffecab8f" translate="yes" xml:space="preserve">
          <source>If the filehandle came from a piped open, &lt;a href=&quot;#close-FILEHANDLE&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; returns false if one of the other syscalls involved fails or if its program exits with non-zero status. If the only problem was that the program exited non-zero, &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; will be set to &lt;code&gt;0&lt;/code&gt;. Closing a pipe also waits for the process executing on the pipe to exit--in case you wish to look at the output of the pipe afterwards--and implicitly puts the exit status value of that command into &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt;&lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ファイルハンドルがパイプで開かれたものからのものである場合、関連する他のシステムコールの1つが失敗した場合、またはそのプログラムがゼロ以外のステータスで終了した場合、&lt;a href=&quot;#close-FILEHANDLE&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;はfalseを返します。唯一の問題がプログラムがゼロ以外で終了したことであった場合、&lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt; &lt;code&gt;0&lt;/code&gt; に設定されます。パイプを閉じると、パイプで実行されているプロセスが終了するのを待ち（後でパイプの出力を確認したい場合）、そのコマンドの終了ステータス値を暗黙的に&lt;a href=&quot;perlvar#%24%3F&quot;&gt; &lt;code&gt;$?&lt;/code&gt; に&lt;/a&gt;入れます。および&lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt; &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e74503c754d78c3ba0f9051478f8b0d722c72c1" translate="yes" xml:space="preserve">
          <source>If the filehandle came from a piped open, &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; returns false if one of the other syscalls involved fails or if its program exits with non-zero status. If the only problem was that the program exited non-zero, &lt;code&gt;$!&lt;/code&gt; will be set to &lt;code&gt;0&lt;/code&gt; . Closing a pipe also waits for the process executing on the pipe to exit--in case you wish to look at the output of the pipe afterwards--and implicitly puts the exit status value of that command into &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</source>
          <target state="translated">ファイルハンドルがパイプによるオープンからのものである場合、関係する他のシステムコールの1つが失敗した場合、またはそのプログラムがゼロ以外のステータスで終了した場合、 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; はfalseを返します。プログラムがゼロ以外で終了したことが唯一の問題だった場合は、 &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;0&lt;/code&gt; に設定されます。パイプを閉じると、パイプで実行されているプロセスが終了するのを待ち（後でパイプの出力を確認したい場合に備えて）、そのコマンドの終了ステータス値を暗黙的に &lt;code&gt;$?&lt;/code&gt; に入れます。および &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a275dda5ca271e5742fe50c27b80a1dea7fadc2a" translate="yes" xml:space="preserve">
          <source>If the filehandle came from a piped open, &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; returns false if one of the other syscalls involved fails or if its program exits with non-zero status. If the only problem was that the program exited non-zero, &lt;code&gt;$!&lt;/code&gt; will be set to &lt;code&gt;0&lt;/code&gt; . Closing a pipe also waits for the process executing on the pipe to exit--in case you wish to look at the output of the pipe afterwards--and implicitly puts the exit status value of that command into &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; .</source>
          <target state="translated">ファイルハンドルがパイプによるオープンからのものである場合、関係する他のシステムコールの1つが失敗した場合、またはそのプログラムがゼロ以外のステータスで終了した場合、 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; はfalseを返します。プログラムがゼロ以外で終了したことが唯一の問題だった場合は、 &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;0&lt;/code&gt; に設定されます。パイプを閉じると、パイプで実行されているプロセスが終了するのを待ち（後でパイプの出力を確認したい場合に備えて）、そのコマンドの終了ステータス値を暗黙的に &lt;code&gt;$?&lt;/code&gt; に入れます。および &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fc5e1415bd14e8d1ec6ad1e512653e073ea2d16" translate="yes" xml:space="preserve">
          <source>If the filename supplied contains directory separators (and so is an absolute or relative pathname), and if that file is not found, platforms that append file extensions will do so and try to look for the file with those extensions added, one by one.</source>
          <target state="translated">与えられたファイル名にディレクトリ区切り文字が含まれている (つまり絶対パス名か相対パス名である)場合、そのファイルが見つからない場合、ファイル拡張子を追加するプラットフォームはそうして、それらの拡張子が追加されたファイルを一つずつ探そうとします。</target>
        </trans-unit>
        <trans-unit id="8b638dc989817125971a607e8fa00529b2b307c1" translate="yes" xml:space="preserve">
          <source>If the final value specified is not in the sequence that the magical increment would produce, the sequence goes until the next value would be longer than the final value specified.</source>
          <target state="translated">指定された最終的な値が魔法の増分が生成するであろうシーケンスにない場合、次の値が指定された最終的な値よりも長くなるまでシーケンスは進みます。</target>
        </trans-unit>
        <trans-unit id="a33c6e16dc7645806ca8dcd82f881fedaded9d02" translate="yes" xml:space="preserve">
          <source>If the final value specified is not in the sequence that the magical increment would produce, the sequence goes until the next value would be longer than the final value specified. If the length of the final string is shorter than the first, the empty list is returned.</source>
          <target state="translated">指定された最終的な値が、魔法の増分が生成するであろうシーケンスにない場合、次の値が指定された最終的な値よりも長くなるまでシーケンスは進みます。最終的な文字列の長さが最初の文字列よりも短い場合は、空のリストが返されます。</target>
        </trans-unit>
        <trans-unit id="d5f8e1e30b780f6553cc08550f9370ae0ed9b97a" translate="yes" xml:space="preserve">
          <source>If the first argument is a reference to an array, the pseudo-hash will be created with keys from that array. If a second argument is supplied, it must also be a reference to an array whose elements will be used as the values. If the second array contains less elements than the first, the trailing elements of the pseudo-hash will not be initialized. This makes it particularly useful for creating a pseudo-hash from subroutine arguments:</source>
          <target state="translated">第一引数に配列への参照を指定すると、その配列のキーを用いて擬似ハッシュが作成されます。2 番目の引数を指定した場合は、その要素が値として使用される配列への参照でなければなりません。2 番目の配列の要素数が 1 番目の配列よりも少ない場合は、 擬似ハッシュの末尾の要素は初期化されません。このため、サブルーチンの引数から擬似ハッシュを作成する際に特に便利です。</target>
        </trans-unit>
        <trans-unit id="9f235f80bacbd6f2376896bcd2071e6b6ed89634" translate="yes" xml:space="preserve">
          <source>If the first argument is an empty string &quot;&quot; or is a volume name, i.e. matches the pattern /^[^:]+:/, the resulting path is &lt;b&gt;absolute&lt;/b&gt;.</source>
          <target state="translated">最初の引数が空の文字列 &quot;&quot;またはボリューム名の場合、つまりパターン/ ^ [^：] +：/に一致する場合、結果のパスは&lt;b&gt;絶対&lt;/b&gt;パスになります。</target>
        </trans-unit>
        <trans-unit id="89aa8ef2f6a6df7b419aa16ffe18ced8031ac672" translate="yes" xml:space="preserve">
          <source>If the first character after the &lt;b&gt;-M&lt;/b&gt; or &lt;b&gt;-m&lt;/b&gt; is a dash (&lt;b&gt;-&lt;/b&gt;) then the 'use' is replaced with 'no'.</source>
          <target state="translated">&lt;b&gt;-M&lt;/b&gt;または&lt;b&gt;-mの&lt;/b&gt;後の最初の文字がダッシュ（&lt;b&gt;-&lt;/b&gt;）の場合、「use」は「no」に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="d6369cd957319ca2b8d2442c19d6fcbc6b24183a" translate="yes" xml:space="preserve">
          <source>If the first character after the &lt;b&gt;-M&lt;/b&gt; or &lt;b&gt;-m&lt;/b&gt; is a dash (&lt;b&gt;-&lt;/b&gt;) then the 'use' is replaced with 'no'. This makes no difference for &lt;b&gt;-m&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;-M&lt;/b&gt;または&lt;b&gt;-mの&lt;/b&gt;後の最初の文字がダッシュ（&lt;b&gt;-&lt;/b&gt;）の場合、「use」は「no」に置き換えられます。これは&lt;b&gt;-mに&lt;/b&gt;は違いはありません。</target>
        </trans-unit>
        <trans-unit id="781d0d29a2affd4018c32ec572f1b116a7081027" translate="yes" xml:space="preserve">
          <source>If the first chars of a Perl script are &lt;code&gt;&quot;extproc &quot;&lt;/code&gt; , this line is treated as &lt;code&gt;#!&lt;/code&gt; -line, thus all the switches on this line are processed (twice if script was started via cmd.exe). See &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;DESCRIPTION in perlrun&lt;/a&gt;.</source>
          <target state="translated">Perlスクリプトの最初の文字が &lt;code&gt;&quot;extproc &quot;&lt;/code&gt; 場合、この行は &lt;code&gt;#!&lt;/code&gt; として扱われます。-line、したがって、この行のすべてのスイッチが処理されます（cmd.exeを介してスクリプトが開始された場合は2回）。&lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;perlrunのDESCRIPTIONを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="581c684b617d92750c5f38a91fda2e5d76163206" translate="yes" xml:space="preserve">
          <source>If the first chars of a Perl script are &lt;code&gt;&quot;extproc &quot;&lt;/code&gt;, this line is treated as &lt;code&gt;#!&lt;/code&gt;-line, thus all the switches on this line are processed (twice if script was started via cmd.exe). See &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;&quot;DESCRIPTION&quot; in perlrun&lt;/a&gt;.</source>
          <target state="translated">Perlスクリプトの最初の文字が &lt;code&gt;&quot;extproc &quot;&lt;/code&gt; 場合、この行は &lt;code&gt;#!&lt;/code&gt; として扱われます。-line、したがって、この行のすべてのスイッチが処理されます（スクリプトがcmd.exeを介して開始された場合は2回）。&lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;perlrunの「DESCRIPTION」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f46518f452342a5c022fec8e53026c8608f2e02a" translate="yes" xml:space="preserve">
          <source>If the first digit following the backslash is a 0, it's an octal escape.</source>
          <target state="translated">バックスラッシュの後の最初の桁が0の場合は、8進数のエスケープです。</target>
        </trans-unit>
        <trans-unit id="5675bafb3dc48482ba4a4f320234c0b4d704c9a0" translate="yes" xml:space="preserve">
          <source>If the first element of the return value (&lt;code&gt;success&lt;/code&gt; ) was 0, then some error occurred. This second element is the error message the command you requested exited with, if available. This is generally a pretty printed value of &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$@&lt;/code&gt; . See &lt;code&gt;perldoc perlvar&lt;/code&gt; for details on what they can contain. If the error was a timeout, the &lt;code&gt;error message&lt;/code&gt; will be prefixed with the string &lt;code&gt;IPC::Cmd::TimeOut&lt;/code&gt; , the timeout class.</source>
          <target state="translated">戻り値の最初の要素（ &lt;code&gt;success&lt;/code&gt; ）が0の場合、エラーが発生しました。この2番目の要素は、要求したコマンドが存在する場合に終了したエラーメッセージです。これは一般に &lt;code&gt;$?&lt;/code&gt; かなり印刷された値ですか？または &lt;code&gt;$@&lt;/code&gt; 。参照してください &lt;code&gt;perldoc perlvar&lt;/code&gt; 、彼らが含まれていることができるものの詳細については、を。エラーがタイムアウトの場合、 &lt;code&gt;error message&lt;/code&gt; 先頭には、タイムアウトクラスの文字列 &lt;code&gt;IPC::Cmd::TimeOut&lt;/code&gt; が付けられます。</target>
        </trans-unit>
        <trans-unit id="638a2f7fa728eb482819629ddfdf65e5299a089f" translate="yes" xml:space="preserve">
          <source>If the first element of the return value (&lt;code&gt;success&lt;/code&gt;) was 0, then some error occurred. This second element is the error message the command you requested exited with, if available. This is generally a pretty printed value of &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$@&lt;/code&gt;. See &lt;code&gt;perldoc perlvar&lt;/code&gt; for details on what they can contain. If the error was a timeout, the &lt;code&gt;error message&lt;/code&gt; will be prefixed with the string &lt;code&gt;IPC::Cmd::TimeOut&lt;/code&gt;, the timeout class.</source>
          <target state="translated">戻り値の最初の要素（ &lt;code&gt;success&lt;/code&gt; ）が0の場合、エラーが発生しました。この2番目の要素は、要求したコマンドが使用可能な場合に終了したエラーメッセージです。これは一般的にかなり印刷された &lt;code&gt;$?&lt;/code&gt; 値ですか？または &lt;code&gt;$@&lt;/code&gt; 。参照してください &lt;code&gt;perldoc perlvar&lt;/code&gt; 、彼らが含まれていることができるものの詳細については、を。エラーがタイムアウトであった場合、エラー &lt;code&gt;error message&lt;/code&gt; 前には、タイムアウトクラスである文字列 &lt;code&gt;IPC::Cmd::TimeOut&lt;/code&gt; が付けられます。</target>
        </trans-unit>
        <trans-unit id="6a57fb9b1830952d24356efef9c0744590e7e139" translate="yes" xml:space="preserve">
          <source>If the first item in a bracket group is &quot;*&quot;, it's taken as shorthand for the so commonly called &quot;quant&quot; method. Similarly, if the first item in a bracket group is &quot;#&quot;, it's taken to be shorthand for &quot;numf&quot;.</source>
          <target state="translated">大括弧グループの最初の項目が &quot;*&quot;の場合、一般的に &quot;quant &quot;と呼ばれている方法の速記法として扱われます。同様に、大括弧グループの最初の項目が &quot;#&quot;の場合は、&quot;numf &quot;の速記法として扱われます。</target>
        </trans-unit>
        <trans-unit id="1953104edb77654c33631a60ba8219310b08e426" translate="yes" xml:space="preserve">
          <source>If the first item in a bracket group is the empty-string, or &quot;_*&quot; or &quot;_</source>
          <target state="translated">大括弧グループの最初の項目が空文字列、または&quot;_*&quot;または&quot;_&quot;の場合</target>
        </trans-unit>
        <trans-unit id="bf6e94a3fad4e68b50306c3295f243e0a73b5811" translate="yes" xml:space="preserve">
          <source>If the first item in a bracket group looks like a method name, then that group is interpreted like this:</source>
          <target state="translated">大括弧グループの最初の項目がメソッド名のように見える場合、そのグループは次のように解釈されます。</target>
        </trans-unit>
        <trans-unit id="ccf14e3215a8aeb1aa87eb4f44052cead882fc98" translate="yes" xml:space="preserve">
          <source>If the first operand has a &quot;nomethod&quot; method then use that.</source>
          <target state="translated">最初のオペランドが &quot;nomethod &quot;メソッドを持っている場合は、それを使用します。</target>
        </trans-unit>
        <trans-unit id="a0dadbb13895f7c7975effc9602b93ea5e861379" translate="yes" xml:space="preserve">
          <source>If the first operand has declared a subroutine to overload the operator then use that implementation.</source>
          <target state="translated">最初のオペランドが演算子をオーバーロードするサブルーチンを宣言している場合は、その実装を使用します。</target>
        </trans-unit>
        <trans-unit id="f7ca747166805083d1be553c7e78c86f97bd5b0c" translate="yes" xml:space="preserve">
          <source>If the flag &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; is passed, no warnings are generated, and hence no AV is created.</source>
          <target state="translated">フラグ &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; が渡された場合、警告は生成されないため、AVは作成されません。</target>
        </trans-unit>
        <trans-unit id="63722d831a3c09d59c00e59b75ba5f74f6230f38" translate="yes" xml:space="preserve">
          <source>If the flag is present in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; will delete whitespace from the start of the subject string before it's operated on. What is considered whitespace depends on if the subject is a UTF-8 string and if the &lt;code&gt;RXf_PMf_LOCALE&lt;/code&gt; flag is set.</source>
          <target state="translated">フラグが存在する場合に &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; 、それが上で動作だ前に対象文字列の先頭から空白を削除します。空白と見なされるものは、件名がUTF-8文字列であるかどうか、 &lt;code&gt;RXf_PMf_LOCALE&lt;/code&gt; フラグが設定されているかどうかによって異なります。</target>
        </trans-unit>
        <trans-unit id="69393e8c9a9ff1f7ad6c1d1075c45161dd52ff73" translate="yes" xml:space="preserve">
          <source>If the flag is present in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt;&lt;code&gt;split&lt;/code&gt; will delete whitespace from the start of the subject string before it's operated on. What is considered whitespace depends on if the subject is a UTF-8 string and if the &lt;code&gt;RXf_PMf_LOCALE&lt;/code&gt; flag is set.</source>
          <target state="translated">フラグが存在する場合に &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; &lt;code&gt;split&lt;/code&gt; 、それが上で動作だ前に対象文字列の先頭から空白を削除します。空白と見なされるものは、サブジェクトがUTF-8文字列であるかどうか、 &lt;code&gt;RXf_PMf_LOCALE&lt;/code&gt; フラグが設定されているかどうかによって異なります。</target>
        </trans-unit>
        <trans-unit id="dbc08ae29def75bcb01866771948171d3f78fd50" translate="yes" xml:space="preserve">
          <source>If the function is used across several files, but intended only for Perl's internal use (and this should be the common case), do not export it to the public API. See the discussion about</source>
          <target state="translated">関数が複数のファイルにまたがって使用されているが、Perl の内部での使用のみを目的としている場合 (これは一般的なケースであるべきです)、公開 API にエクスポートしないでください。についての議論を参照してください。</target>
        </trans-unit>
        <trans-unit id="0cd096b932efa03a9f98d53e47997c47f5475a48" translate="yes" xml:space="preserve">
          <source>If the function is used only inside one source code file, make it static. See the discussion about</source>
          <target state="translated">関数が1つのソースコードファイル内でのみ使用される場合は、それを静的なものにしてください。についての議論を参照してください。</target>
        </trans-unit>
        <trans-unit id="56833441b11ff81d3798d0015a0f9476e6600637" translate="yes" xml:space="preserve">
          <source>If the function wants to handle the keyword, it first must parse anything following the keyword that is part of the syntax introduced by the keyword. See &lt;a href=&quot;#Lexer-interface&quot;&gt;&quot;Lexer interface&quot;&lt;/a&gt; for details.</source>
          <target state="translated">関数がキーワードを処理する場合は、最初に、キーワードによって導入された構文の一部であるキーワードに続くものをすべて解析する必要があります。詳細については、&lt;a href=&quot;#Lexer-interface&quot;&gt;「レクサーインターフェイス」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d809f75a0fec341370456ffe5542097322b23570" translate="yes" xml:space="preserve">
          <source>If the function wants to handle the keyword, it first must parse anything following the keyword that is part of the syntax introduced by the keyword. See &lt;a href=&quot;#Lexer-interface&quot;&gt;Lexer interface&lt;/a&gt; for details.</source>
          <target state="translated">関数がキーワードを処理する必要がある場合、最初に、キーワードによって導入された構文の一部であるキーワードに続くものを解析する必要があります。詳細については、&lt;a href=&quot;#Lexer-interface&quot;&gt;レクサーインターフェイス&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4257aa9162577acd082afc2803cd5eba4d35b6a8" translate="yes" xml:space="preserve">
          <source>If the function's name is &lt;b&gt;DESTROY&lt;/b&gt; then the C++ &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; function will be called and &lt;code&gt;THIS&lt;/code&gt; will be given as its parameter. The generated C++ code for</source>
          <target state="translated">関数の名前がある場合は&lt;b&gt;DESTROY&lt;/b&gt;その後、C ++ &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; 機能が呼び出され、 &lt;code&gt;THIS&lt;/code&gt; そのパラメータとして指定されます。生成されたC ++コード</target>
        </trans-unit>
        <trans-unit id="2d5573b215565d0881940be9d2690435373f68b6" translate="yes" xml:space="preserve">
          <source>If the function's name is &lt;b&gt;DESTROY&lt;/b&gt; then the C++ &lt;code&gt;delete&lt;/code&gt; function will be called and &lt;code&gt;THIS&lt;/code&gt; will be given as its parameter. The generated C++ code for</source>
          <target state="translated">関数の名前がある場合は&lt;b&gt;DESTROY&lt;/b&gt;その後、C ++ &lt;code&gt;delete&lt;/code&gt; 機能が呼び出され、 &lt;code&gt;THIS&lt;/code&gt; そのパラメータとして指定されます。生成されたC ++コード</target>
        </trans-unit>
        <trans-unit id="7a9d5afefb1f72725e3effbcde85fc42f858949b" translate="yes" xml:space="preserve">
          <source>If the function's name is &lt;b&gt;new&lt;/b&gt; then the C++ &lt;code&gt;new&lt;/code&gt; function will be called to create a dynamic C++ object. The XSUB will expect the class name, which will be kept in a variable called &lt;code&gt;CLASS&lt;/code&gt; , to be given as the first argument.</source>
          <target state="translated">関数の名前が&lt;b&gt;新しい&lt;/b&gt;場合、C ++の &lt;code&gt;new&lt;/code&gt; 関数が呼び出され、動的なC ++オブジェクトが作成されます。XSUBは、 &lt;code&gt;CLASS&lt;/code&gt; と呼ばれる変数に保持されるクラス名が最初の引数として与えられることを期待します。</target>
        </trans-unit>
        <trans-unit id="55694f31aaf01067ff0315ab3ecdf0ed7ab87a27" translate="yes" xml:space="preserve">
          <source>If the function's name is &lt;b&gt;new&lt;/b&gt; then the C++ &lt;code&gt;new&lt;/code&gt; function will be called to create a dynamic C++ object. The XSUB will expect the class name, which will be kept in a variable called &lt;code&gt;CLASS&lt;/code&gt;, to be given as the first argument.</source>
          <target state="translated">関数の名前が&lt;b&gt;新しい&lt;/b&gt;場合は、C ++の &lt;code&gt;new&lt;/code&gt; 関数が呼び出されて動的C ++オブジェクトが作成されます。XSUBは、 &lt;code&gt;CLASS&lt;/code&gt; と呼ばれる変数に保持されるクラス名が最初の引数として指定されることを期待します。</target>
        </trans-unit>
        <trans-unit id="6b71bbee27e0cc31a2af0019a27b599b4619d0d9" translate="yes" xml:space="preserve">
          <source>If the generated module were architecture-specific, you could replace &lt;code&gt;$(INST_LIB)&lt;/code&gt; above with &lt;code&gt;$(INST_ARCHLIB)&lt;/code&gt;, although if you locate modules under</source>
          <target state="translated">生成されたモジュールは、アーキテクチャ固有のであれば、あなたは置き換えることができます &lt;code&gt;$(INST_LIB)&lt;/code&gt; と上記の &lt;code&gt;$(INST_ARCHLIB)&lt;/code&gt; あなたは下のモジュールを見つけた場合にも、</target>
        </trans-unit>
        <trans-unit id="cf92d6194fe17b6faa691c083e3aa66b73fd41bc" translate="yes" xml:space="preserve">
          <source>If the given file is a Storable image return a hash describing it. If the file is readable, but not a Storable image return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. If the file does not exist or is unreadable then croak.</source>
          <target state="translated">指定されたファイルがStorableイメージの場合、それを説明するハッシュを返します。ファイルは読み取り可能であるが、格納可能なイメージでない場合は、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。ファイルが存在しないか、読み取れない場合は、鳴き声を上げます。</target>
        </trans-unit>
        <trans-unit id="1e8a49ab1a01520f2d7d29b472d08d17beed998e" translate="yes" xml:space="preserve">
          <source>If the given file is a Storable image return a hash describing it. If the file is readable, but not a Storable image return &lt;code&gt;undef&lt;/code&gt;. If the file does not exist or is unreadable then croak.</source>
          <target state="translated">指定されたファイルが保存可能な画像である場合、それを説明するハッシュを返します。ファイルが読み取り可能であるが、保存可能なイメージが読み取れない場合は、 &lt;code&gt;undef&lt;/code&gt; を返します。ファイルが存在しないか、読み取れない場合は、鳴きます。</target>
        </trans-unit>
        <trans-unit id="6f5f5dfa299a465aa9a0110ad7326e956c843743" translate="yes" xml:space="preserve">
          <source>If the given string is in FCD (&quot;Fast C or D&quot; form; cf. UTN #5), it returns the string without modification; otherwise it returns an FCD string.</source>
          <target state="translated">与えられた文字列がFCD (&quot;Fast C or D &quot;形式;UTN #5参照)であれば、変更せずに文字列を返し、そうでなければFCD文字列を返します。</target>
        </trans-unit>
        <trans-unit id="12d092a8012a2b0bc17122d5b49e40f14ceca06d" translate="yes" xml:space="preserve">
          <source>If the global variable $KEEP_ALL is true, the file or directory will not be removed.</source>
          <target state="translated">グローバル変数 $KEEP_ALL が真の場合、ファイルやディレクトリは削除されません。</target>
        </trans-unit>
        <trans-unit id="cc1c6dee6d24dc894200423540415887a91afb83" translate="yes" xml:space="preserve">
          <source>If the groupings in a regex are nested, &lt;code&gt;$1&lt;/code&gt; gets the group with the leftmost opening parenthesis, &lt;code&gt;$2&lt;/code&gt; the next opening parenthesis, etc. For example, here is a complex regex and the matching variables indicated below it:</source>
          <target state="translated">正規表現のグループがネストされている場合、 &lt;code&gt;$1&lt;/code&gt; は左端の左括弧を含むグループを取得し、 &lt;code&gt;$2&lt;/code&gt; は次の左括弧を使用してグループを取得します。たとえば、以下は複雑な正規表現とその下に示される一致する変数です。</target>
        </trans-unit>
        <trans-unit id="9d3242285e88212205a68d263609b12616c56fc8" translate="yes" xml:space="preserve">
          <source>If the groupings in a regexp are nested, &lt;code&gt;$1&lt;/code&gt; gets the group with the leftmost opening parenthesis, &lt;code&gt;$2&lt;/code&gt; the next opening parenthesis,</source>
          <target state="translated">正規表現のグループ化がネストされている場合、 &lt;code&gt;$1&lt;/code&gt; は左端の開始括弧のあるグループを取得し、 &lt;code&gt;$2&lt;/code&gt; は次の開始括弧のあるグループを取得します。</target>
        </trans-unit>
        <trans-unit id="83b41f5fdfcf62fc4686ef889212a3544a4d2078" translate="yes" xml:space="preserve">
          <source>If the groupings in a regexp are nested, &lt;code&gt;$1&lt;/code&gt; gets the group with the leftmost opening parenthesis, &lt;code&gt;$2&lt;/code&gt; the next opening parenthesis, etc. Here is a regexp with nested groups:</source>
          <target state="translated">正規表現のグループがネストされている場合、 &lt;code&gt;$1&lt;/code&gt; は左端の左括弧を含むグループを取得し、 &lt;code&gt;$2&lt;/code&gt; は次の左括弧を取得します。以下が、ネストされたグループを含む正規表現です。</target>
        </trans-unit>
        <trans-unit id="ccea903e5c5ba097dd604b81034d2fccf458d781" translate="yes" xml:space="preserve">
          <source>If the gunzip program encounters a file containing multiple gzip files concatenated together it will automatically uncompress them all. The example below illustrates this behaviour</source>
          <target state="translated">gunzip プログラムが複数の gzip ファイルを連結したファイルに遭遇した場合、自動的にすべてのファイルを解凍する。以下の例は、この動作を示している。</target>
        </trans-unit>
        <trans-unit id="7672fac594e6a7dd98d2bae0c51d24e5065e39e4" translate="yes" xml:space="preserve">
          <source>If the gzip FEXTRA header field is present it must conform to the sub-field structure as defined in RFC 1952.</source>
          <target state="translated">gzip FEXTRAヘッダフィールドが存在する場合、それはRFC 1952で定義されているサブフィールド構造に準拠しなければならない。</target>
        </trans-unit>
        <trans-unit id="948511a86fa3a757ed333c1057a05dc236b1ed7b" translate="yes" xml:space="preserve">
          <source>If the gzip header contains a comment field (FCOMMENT) it consists solely of ISO 8859-1 characters plus line-feed.</source>
          <target state="translated">gzipヘッダがコメントフィールド(FCOMMENT)を含む場合は、 ISO 8859-1文字と改行のみで構成される。</target>
        </trans-unit>
        <trans-unit id="309f2d92f5e86ee4880748347a713d797525d1c3" translate="yes" xml:space="preserve">
          <source>If the gzip header contains a name field (FNAME) it consists solely of ISO 8859-1 characters.</source>
          <target state="translated">gzipヘッダに名前フィールド(FNAME)が含まれている場合、それはISO 8859-1文字のみで構成されている。</target>
        </trans-unit>
        <trans-unit id="5ae4fed28b97ca4227cf5c00d60d4d6f2110ce60" translate="yes" xml:space="preserve">
          <source>If the hash is tied dispatches through to the SCALAR tied method, otherwise if the hash contains no keys returns 0, otherwise returns a mortal sv containing a string specifying the number of used buckets, followed by a slash, followed by the number of available buckets.</source>
          <target state="translated">ハッシュが紐付けられている場合はSCALAR tiedメソッドにディスパッチされ、そうでなければハッシュにキーが含まれていなければ0を返し、そうでなければ使用されているバケットの数を指定する文字列、スラッシュ、利用可能なバケットの数の後に続くスラッシュを含む文字列を含む死亡時のsvを返します。</target>
        </trans-unit>
        <trans-unit id="76da98a8a76e4650e3f026f7c68c78b99cc6936b" translate="yes" xml:space="preserve">
          <source>If the hash is very large, you might not want to create a long list of keys. To save some memory, you can grab one key-value pair at a time using &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt;, which returns a pair you haven't seen yet:</source>
          <target state="translated">ハッシュが非常に大きい場合は、キーの長いリストを作成したくない場合があります。メモリを節約するために、 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; を使用して一度に1つのキーと値のペアを取得できます。これにより、まだ表示されていないペアが返されます。</target>
        </trans-unit>
        <trans-unit id="80cd0158384418c000a070c2edb04e7bd8c177a8" translate="yes" xml:space="preserve">
          <source>If the hash is very large, you might not want to create a long list of keys. To save some memory, you can grab one key-value pair at a time using &lt;code&gt;each()&lt;/code&gt;, which returns a pair you haven't seen yet:</source>
          <target state="translated">ハッシュが非常に大きい場合は、キーの長いリストを作成したくない場合があります。メモリを節約するために、 &lt;code&gt;each()&lt;/code&gt; を使用して一度に1つのキーと値のペアを取得できます。これにより、まだ表示されていないペアが返されます。</target>
        </trans-unit>
        <trans-unit id="fdb896d2cffead7d5fc78c0ddc9c3c52939333bc" translate="yes" xml:space="preserve">
          <source>If the hint provided is a subroutine, then &lt;code&gt;autodie&lt;/code&gt; will pass the complete return value to that subroutine. If the hint is any other value, then &lt;code&gt;autodie&lt;/code&gt; will smart-match against the value provided. In Perl 5.8.x there is no smart-match operator, and as such only subroutine hints are supported in these versions.</source>
          <target state="translated">提供されたヒントがサブルーチンの場合、 &lt;code&gt;autodie&lt;/code&gt; は完全な戻り値をそのサブルーチンに渡します。ヒントが他の値である場合、 &lt;code&gt;autodie&lt;/code&gt; は提供された値とスマートマッチングします。Perl 5.8.xにはスマートマッチ演算子がないため、これらのバージョンではサブルーチンヒントのみがサポートされています。</target>
        </trans-unit>
        <trans-unit id="7d353d642decb66a3abbcefcf79e58c99b0ba1e9" translate="yes" xml:space="preserve">
          <source>If the hook is an array reference, its first element must be a subroutine reference. This subroutine is called as above, but the first parameter is the array reference. This lets you indirectly pass arguments to the subroutine.</source>
          <target state="translated">フックが配列参照の場合、その最初の要素はサブルーチン参照でなければなりません。このサブルーチンは上記のように呼ばれますが、最初のパラメータは配列参照です。これにより、間接的にサブルーチンに引数を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="75efff7a12e92261036612262090b64712859893" translate="yes" xml:space="preserve">
          <source>If the hook is an object, it must provide an &lt;code&gt;INC&lt;/code&gt; method that will be called as above, the first parameter being the object itself. (Note that you must fully qualify the sub's name, as unqualified &lt;code&gt;INC&lt;/code&gt; is always forced into package &lt;code&gt;main&lt;/code&gt;.) Here is a typical code layout:</source>
          <target state="translated">フックがオブジェクトの場合、上記のように呼び出される &lt;code&gt;INC&lt;/code&gt; メソッドを提供する必要があります。最初のパラメーターは、オブジェクト自体です。（修飾されていない &lt;code&gt;INC&lt;/code&gt; は常にパッケージ &lt;code&gt;main&lt;/code&gt; に強制されるため、サブの名前を完全に修飾する必要があることに注意してください。）一般的なコードレイアウトは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="089781c4ed94b59afd45ade73f63dd3ae0adcf17" translate="yes" xml:space="preserve">
          <source>If the hook is an object, it must provide an INC method that will be called as above, the first parameter being the object itself. (Note that you must fully qualify the sub's name, as unqualified &lt;code&gt;INC&lt;/code&gt; is always forced into package &lt;code&gt;main&lt;/code&gt; .) Here is a typical code layout:</source>
          <target state="translated">フックがオブジェクトの場合は、上記のように呼び出されるINCメソッドを提供する必要があります。最初のパラメーターはオブジェクト自体です。（修飾されていない &lt;code&gt;INC&lt;/code&gt; は常にパッケージ &lt;code&gt;main&lt;/code&gt; に強制されるため、サブルーチンの名前を完全に修飾する必要があることに注意してください。）次に、一般的なコードレイアウトを示します。</target>
        </trans-unit>
        <trans-unit id="dc5ac6730609a596bd949c3bb5ec01a23d4ffce0" translate="yes" xml:space="preserve">
          <source>If the initial value specified isn't part of a magical increment sequence (that is, a non-empty string matching &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; ), only the initial value will be returned. So the following will only return an alpha:</source>
          <target state="translated">指定された初期値がマジカルインクリメントシーケンスの一部でない場合（つまり、 &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; 一致する空でない文字列）、初期値のみが返されます。したがって、以下はアルファのみを返します。</target>
        </trans-unit>
        <trans-unit id="f20e6769b4c4dc9b5fc71b6e41306b51022683e2" translate="yes" xml:space="preserve">
          <source>If the initial value specified isn't part of a magical increment sequence (that is, a non-empty string matching &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt;), only the initial value will be returned.</source>
          <target state="translated">指定された初期値が魔法のインクリメントシーケンスの一部ではない場合（つまり、 &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; 一致する空でない文字列）、初期値のみが返されます。</target>
        </trans-unit>
        <trans-unit id="ce1ecd771a78ded6bdca0c84c4a8624d300c4df7" translate="yes" xml:space="preserve">
          <source>If the initialization begins with &lt;code&gt;=&lt;/code&gt; , then it is output in the declaration for the input variable, replacing the initialization supplied by the typemap. If the initialization begins with &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; , then it is performed after all of the input variables have been declared. In the &lt;code&gt;;&lt;/code&gt; case the initialization normally supplied by the typemap is not performed. For the &lt;code&gt;+&lt;/code&gt; case, the declaration for the variable will include the initialization from the typemap. A global variable, &lt;code&gt;%v&lt;/code&gt; , is available for the truly rare case where information from one initialization is needed in another initialization.</source>
          <target state="translated">初期化が &lt;code&gt;=&lt;/code&gt; で始まる場合、入力変数の宣言で出力され、タイプマップによって提供される初期化が置き換えられます。初期化がで始まる場合 &lt;code&gt;;&lt;/code&gt; または &lt;code&gt;+&lt;/code&gt; の場合、すべての入力変数が宣言された後に実行されます。で &lt;code&gt;;&lt;/code&gt; タイプマップによって通常提供される初期化は実行されません。以下のために &lt;code&gt;+&lt;/code&gt; の場合、変数の宣言は、タイプマップから初期化を含むであろう。グローバル変数 &lt;code&gt;%v&lt;/code&gt; は、ある初期化からの情報が別の初期化で必要となる本当にまれなケースで使用できます。</target>
        </trans-unit>
        <trans-unit id="ef3d32f84fa869f08148860d3a1b874f45f05bbf" translate="yes" xml:space="preserve">
          <source>If the initialization begins with &lt;code&gt;=&lt;/code&gt;, then it is output in the declaration for the input variable, replacing the initialization supplied by the typemap. If the initialization begins with &lt;code&gt;;&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;, then it is performed after all of the input variables have been declared. In the &lt;code&gt;;&lt;/code&gt; case the initialization normally supplied by the typemap is not performed. For the &lt;code&gt;+&lt;/code&gt; case, the declaration for the variable will include the initialization from the typemap. A global variable, &lt;code&gt;%v&lt;/code&gt;, is available for the truly rare case where information from one initialization is needed in another initialization.</source>
          <target state="translated">初期化が &lt;code&gt;=&lt;/code&gt; で始まる場合は、入力変数の宣言に出力され、タイプマップによって提供される初期化が置き換えられます。初期化が &lt;code&gt;;&lt;/code&gt; で始まる場合または &lt;code&gt;+&lt;/code&gt; の場合、すべての入力変数が宣言された後に実行されます。で &lt;code&gt;;&lt;/code&gt; タイプマップによって通常提供される初期化が実行されない場合。以下のために &lt;code&gt;+&lt;/code&gt; の場合、変数の宣言は、タイプマップから初期化を含むであろう。グローバル変数 &lt;code&gt;%v&lt;/code&gt; は、ある初期化からの情報が別の初期化で必要となる非常にまれなケースで使用できます。</target>
        </trans-unit>
        <trans-unit id="a641a3d375c74024ce1445924cf66af681f41ebd" translate="yes" xml:space="preserve">
          <source>If the input code point's name has more than one synonym, they are returned joined into a single comma-separated string.</source>
          <target state="translated">入力コードポイントの名前に複数の同義語がある場合、それらはカンマで区切られた単一の文字列に結合されて返されます。</target>
        </trans-unit>
        <trans-unit id="9e071ed158601437a7fd928632778e71dc9740aa" translate="yes" xml:space="preserve">
          <source>If the input file/buffer contains multiple compressed data streams, this option will uncompress the whole lot as a single data stream.</source>
          <target state="translated">入力ファイル/バッファに複数の圧縮されたデータストリームが含まれている場合、このオプションは全体を単一のデータストリームとして解凍します。</target>
        </trans-unit>
        <trans-unit id="3c582e01c3ed1134227361002db4abc5ef87f0a6" translate="yes" xml:space="preserve">
          <source>If the input is a buffer, &lt;code&gt;trailingData&lt;/code&gt; will return everything from the end of the compressed data stream to the end of the buffer.</source>
          <target state="translated">入力がバッファの場合、 &lt;code&gt;trailingData&lt;/code&gt; は圧縮データストリームの最後からバッファの最後まですべてを返します。</target>
        </trans-unit>
        <trans-unit id="646ddea5cc7fe42fca7b5f673b48b7968e951a94" translate="yes" xml:space="preserve">
          <source>If the input is a filehandle, &lt;code&gt;trailingData&lt;/code&gt; will return the data that is left in the filehandle input buffer once the end of the compressed data stream has been reached. You can then use the filehandle to read the rest of the input file.</source>
          <target state="translated">入力がファイルハンドルの場合、 &lt;code&gt;trailingData&lt;/code&gt; は、圧縮されたデータストリームの最後に到達すると、ファイルハンドル入力バッファーに残っているデータを返します。その後、ファイルハンドルを使用して、入力ファイルの残りを読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="68ffb2242fbe49d90e0f353510f536b7c97b26ff" translate="yes" xml:space="preserve">
          <source>If the input is a gzip (RFC 1952) data stream, the following will be checked:</source>
          <target state="translated">入力が gzip (RFC 1952)データストリームの場合は、以下のようにチェックされます。</target>
        </trans-unit>
        <trans-unit id="fbb62e9bad07668939b33bd6b3f35cbd2a29221c" translate="yes" xml:space="preserve">
          <source>If the input is an RFC 1950 data stream, the following will be checked:</source>
          <target state="translated">入力がRFC1950のデータストリームの場合は、以下のようにチェックされます。</target>
        </trans-unit>
        <trans-unit id="681895bf526e306295ee60c6f4d01df1e2e0e233" translate="yes" xml:space="preserve">
          <source>If the input is being interpreted as UTF-8 and a UTF-8 encoding error is encountered, an exception is generated.</source>
          <target state="translated">入力がUTF-8として解釈されていて、UTF-8エンコーディングエラーが発生した場合、例外が生成されます。</target>
        </trans-unit>
        <trans-unit id="3c3ba700c41877fa613cc375e9afc8a49773890d" translate="yes" xml:space="preserve">
          <source>If the input is unknown &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned in scalar context; an empty-list in list context. If the input is known, the number of elements in the list is returned if called in scalar context.</source>
          <target state="translated">入力が不明な場合、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; がスカラーコンテキストで返されます。リストコンテキストの空のリスト。入力が既知の場合、スカラーコンテキストで呼び出されると、リスト内の要素の数が返されます。</target>
        </trans-unit>
        <trans-unit id="a3761d436a5408df215f967b2c72bd018ebcc47f" translate="yes" xml:space="preserve">
          <source>If the input is unknown &lt;code&gt;undef&lt;/code&gt; is returned in scalar context; an empty-list in list context. If the input is known, the number of elements in the list is returned if called in scalar context.</source>
          <target state="translated">入力が不明な場合、 &lt;code&gt;undef&lt;/code&gt; はスカラーコンテキストで返されます。リストコンテキストの空のリスト。入力がわかっている場合、スカラーコンテキストで呼び出されると、リスト内の要素の数が返されます。</target>
        </trans-unit>
        <trans-unit id="a45a90c97d69c88324a18a4a975329202a110a46" translate="yes" xml:space="preserve">
          <source>If the input string is longer than needed, extra characters are ignored.</source>
          <target state="translated">入力文字列が必要以上に長い場合、余分な文字は無視されます。</target>
        </trans-unit>
        <trans-unit id="daec947152f5e00d64f719376318858935b663a6" translate="yes" xml:space="preserve">
          <source>If the input string is longer than needed, remaining characters are ignored.</source>
          <target state="translated">入力文字列が必要以上に長い場合、残りの文字は無視されます。</target>
        </trans-unit>
        <trans-unit id="1a191161ccbd661c7961516bab02ad1f7aadb16a" translate="yes" xml:space="preserve">
          <source>If the interdependence of your &lt;code&gt;BOOT:&lt;/code&gt; section and Perl code is more complicated than this (e.g., the &lt;code&gt;BOOT:&lt;/code&gt; section makes calls to Perl functions which make calls to XSUBs with prototypes), get rid of the &lt;code&gt;BOOT:&lt;/code&gt; section altogether. Replace it with a function &lt;code&gt;onBOOT()&lt;/code&gt; , and call it like this:</source>
          <target state="translated">&lt;code&gt;BOOT:&lt;/code&gt; セクションとPerlコードの相互依存性がこれよりも複雑な場合（たとえば、 &lt;code&gt;BOOT:&lt;/code&gt; セクションがプロトタイプを使用してXSUBを呼び出すPerl関数を呼び出す）、 &lt;code&gt;BOOT:&lt;/code&gt; セクションを完全に削除します。それを関数 &lt;code&gt;onBOOT()&lt;/code&gt; に置き換え、次のように呼び出します。</target>
        </trans-unit>
        <trans-unit id="baa35ea6f799cdc2c58744681c4a0f8490276128" translate="yes" xml:space="preserve">
          <source>If the interdependence of your &lt;code&gt;BOOT:&lt;/code&gt; section and Perl code is more complicated than this (e.g., the &lt;code&gt;BOOT:&lt;/code&gt; section makes calls to Perl functions which make calls to XSUBs with prototypes), get rid of the &lt;code&gt;BOOT:&lt;/code&gt; section altogether. Replace it with a function &lt;code&gt;onBOOT()&lt;/code&gt;, and call it like this:</source>
          <target state="translated">&lt;code&gt;BOOT:&lt;/code&gt; セクションとPerlコードの相互依存性がこれよりも複雑な場合（たとえば、 &lt;code&gt;BOOT:&lt;/code&gt; セクションがプロトタイプでXSUBを呼び出すPerl関数を呼び出す場合）、 &lt;code&gt;BOOT:&lt;/code&gt; セクションを完全に削除します。これを関数 &lt;code&gt;onBOOT()&lt;/code&gt; に置き換えて、次のように呼び出します。</target>
        </trans-unit>
        <trans-unit id="2909f2e071daf0b882a5795cb2264aafaf8e4b0b" translate="yes" xml:space="preserve">
          <source>If the interpreter's &lt;code&gt;PL_exit_flags&lt;/code&gt; word has the &lt;code&gt;PERL_EXIT_DESTRUCT_END&lt;/code&gt; flag set, then this function will execute code in &lt;code&gt;END&lt;/code&gt; blocks before performing the rest of destruction. If it is desired to make any use of the interpreter between &lt;a href=&quot;#perl_parse&quot;&gt;&quot;perl_parse&quot;&lt;/a&gt; and &lt;a href=&quot;#perl_destruct&quot;&gt;&quot;perl_destruct&quot;&lt;/a&gt; other than just calling &lt;a href=&quot;#perl_run&quot;&gt;&quot;perl_run&quot;&lt;/a&gt;, then this flag should be set early on. This matters if &lt;a href=&quot;#perl_run&quot;&gt;&quot;perl_run&quot;&lt;/a&gt; will not be called, or if anything else will be done in addition to calling &lt;a href=&quot;#perl_run&quot;&gt;&quot;perl_run&quot;&lt;/a&gt;.</source>
          <target state="translated">インタプリタの &lt;code&gt;PL_exit_flags&lt;/code&gt; ワードに &lt;code&gt;PERL_EXIT_DESTRUCT_END&lt;/code&gt; フラグが設定されている場合、この関数は残りの破棄を実行する前に &lt;code&gt;END&lt;/code&gt; ブロックでコードを実行します。それは間の通訳のいずれかを使用することが望まれている場合は&lt;a href=&quot;#perl_parse&quot;&gt;、「perl_parse」&lt;/a&gt;と&lt;a href=&quot;#perl_destruct&quot;&gt;「perl_destruct」&lt;/a&gt;だけを呼び出す以外の&lt;a href=&quot;#perl_run&quot;&gt;「perl_run」を&lt;/a&gt;、このフラグは、上で早期に設定する必要があります。これは、&lt;a href=&quot;#perl_run&quot;&gt;「perl_run」&lt;/a&gt;が呼び出されない場合、または&lt;a href=&quot;#perl_run&quot;&gt;「perl_run」の&lt;/a&gt;呼び出しに加えて他の何かが行われる場合に重要です。</target>
        </trans-unit>
        <trans-unit id="fd4475a90b24f7b1ba4a7b6ea113603191eff994" translate="yes" xml:space="preserve">
          <source>If the kernel set-id script feature isn't disabled, then any set-id script provides an exploitable vulnerability. Perl can't avoid being exploitable, but will point out vulnerable scripts where it can. If Perl detects that it is being applied to a set-id script then it will complain loudly that your set-id script is insecure, and won't run it. When Perl complains, you need to remove the set-id bit from the script to eliminate the vulnerability. Refusing to run the script doesn't in itself close the vulnerability; it is just Perl's way of encouraging you to do this.</source>
          <target state="translated">カーネルの set-id スクリプト機能が無効化されていない場合、どのような set-id スクリプトでも悪用可能な脆弱性を提供します。Perl は脆弱性を回避することはできませんが、脆弱性のあるスクリプトを指摘します。Perl が set-id スクリプトに適用されていることを検出すると、 set-id スクリプトが安全ではないと大声で文句を言い、実行しません。Perl が文句を言ってきたら、スクリプトから set-id ビットを削除して脆弱性を排除する必要があります。スクリプトの実行を拒否すること自体が脆弱性を解消するわけではありません。</target>
        </trans-unit>
        <trans-unit id="3e4a966e522ce068cba366c74c39330ba735c481" translate="yes" xml:space="preserve">
          <source>If the key does not exist the method returns 1.</source>
          <target state="translated">キーが存在しない場合、このメソッドは 1 を返します。</target>
        </trans-unit>
        <trans-unit id="f85edef10f25d12c44c4dedc4c6946807ec9d900" translate="yes" xml:space="preserve">
          <source>If the label equals '-', then Concise will treat the bit as a raw bit and not try to display it symbolically.</source>
          <target state="translated">ラベルが '-' に等しい場合、Concise はそのビットを生のビットとして扱い、記号的に表示しようとはしません。</target>
        </trans-unit>
        <trans-unit id="f74ad7c032adb69e8741c3ce089dbedf2af387c8" translate="yes" xml:space="preserve">
          <source>If the language handle has a &quot;fail&quot; attribute whose value is a coderef, then $lh-&amp;gt;maketext(</source>
          <target state="translated">言語ハンドルに値がcoderefである &quot;fail&quot;属性がある場合、$ lh-&amp;gt; maketext（</target>
        </trans-unit>
        <trans-unit id="74b0a2c233bae54a5a0a22d4c6904ecf217ffcc9" translate="yes" xml:space="preserve">
          <source>If the language handle has no &quot;fail&quot; attribute, maketext will simply throw an exception (i.e., it calls &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, mentioning the</source>
          <target state="translated">言語ハンドルに「fail」属性がない場合、maketextは単に例外をスローします（つまり、 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; を呼び出し、</target>
        </trans-unit>
        <trans-unit id="ed178838d46c1e8b7a50a0bfb02973479dc8e58f" translate="yes" xml:space="preserve">
          <source>If the language handle has no &quot;fail&quot; attribute, maketext will simply throw an exception (i.e., it calls &lt;code&gt;die&lt;/code&gt;, mentioning the</source>
          <target state="translated">言語ハンドルに「fail」属性がない場合、maketextは単に例外をスローします（つまり、 &lt;code&gt;die&lt;/code&gt; を呼び出し、</target>
        </trans-unit>
        <trans-unit id="f4c30b1f2ee79d6c9f16717998b6ca5cb7a43494" translate="yes" xml:space="preserve">
          <source>If the last definition is removed, then the DOS device name is also deleted.</source>
          <target state="translated">最後の定義が削除された場合、DOSデバイス名も削除されます。</target>
        </trans-unit>
        <trans-unit id="11f576169bf47c87f2f0af12c0e2e1a4146c280c" translate="yes" xml:space="preserve">
          <source>If the last element of LIST does not end in a newline, the current script line number and input line number (if any) are also printed, and a newline is supplied. Note that the &quot;input line number&quot; (also known as &quot;chunk&quot;) is subject to whatever notion of &quot;line&quot; happens to be currently in effect, and is also available as the special variable &lt;code&gt;$.&lt;/code&gt; . See &lt;a href=&quot;../perlvar#%24%2f&quot;&gt;$/ in perlvar&lt;/a&gt; and &lt;a href=&quot;../perlvar#%24.&quot;&gt;$. in perlvar&lt;/a&gt;.</source>
          <target state="translated">LISTの最後の要素が改行で終わっていない場合、現在のスクリプトの行番号と入力行番号（ある場合）も出力され、改行が提供されます。「入力行番号」（「チャンク」とも呼ばれる）は、「行」の概念が現在有効になっている場合に適用され、特殊変数 &lt;code&gt;$.&lt;/code&gt; としても使用できることに注意してください。。&lt;a href=&quot;../perlvar#%24%2f&quot;&gt;perlvarの$ /&lt;/a&gt;と&lt;a href=&quot;../perlvar#%24.&quot;&gt;$を&lt;/a&gt;参照してください。perlvarで。</target>
        </trans-unit>
        <trans-unit id="2ddf8780e7e7d9b3df1dc954871c1e6b0c532c31" translate="yes" xml:space="preserve">
          <source>If the last element of LIST does not end in a newline, the current script line number and input line number (if any) are also printed, and a newline is supplied. Note that the &quot;input line number&quot; (also known as &quot;chunk&quot;) is subject to whatever notion of &quot;line&quot; happens to be currently in effect, and is also available as the special variable &lt;code&gt;$.&lt;/code&gt; . See &lt;a href=&quot;perlvar#%24%2f&quot;&gt;$/ in perlvar&lt;/a&gt; and &lt;a href=&quot;perlvar#%24.&quot;&gt;$. in perlvar&lt;/a&gt;.</source>
          <target state="translated">LISTの最後の要素が改行で終わっていない場合、現在のスクリプトの行番号と入力行番号（ある場合）も出力され、改行が提供されます。「入力行番号」（「チャンク」とも呼ばれる）は、「行」の概念が現在有効になっている場合に適用され、特殊変数 &lt;code&gt;$.&lt;/code&gt; としても使用できることに注意してください。。&lt;a href=&quot;perlvar#%24%2f&quot;&gt;perlvarの$ /&lt;/a&gt;と&lt;a href=&quot;perlvar#%24.&quot;&gt;$を&lt;/a&gt;参照してください。perlvarで。</target>
        </trans-unit>
        <trans-unit id="65ccdf7ae6afe2d083d0de8afca0765301ad5a3c" translate="yes" xml:space="preserve">
          <source>If the left hand side is neither a package name nor an object, then the method call will cause an error, but see the section on &lt;a href=&quot;#Method-Call-Variations&quot;&gt;&quot;Method Call Variations&quot;&lt;/a&gt; for more nuances.</source>
          <target state="translated">左側がパッケージ名でもオブジェクトでもない場合、メソッド呼び出しはエラーを引き起こしますが、詳細については&lt;a href=&quot;#Method-Call-Variations&quot;&gt;「メソッド呼び出しのバリエーション」の&lt;/a&gt;セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="e90835049bf9dceb2b3128f6e0da3805c87bc497" translate="yes" xml:space="preserve">
          <source>If the left hand side is neither a package name nor an object, then the method call will cause an error, but see the section on &lt;a href=&quot;#Method-Call-Variations&quot;&gt;Method Call Variations&lt;/a&gt; for more nuances.</source>
          <target state="translated">左側がパッケージ名でもオブジェクトでもない場合、メソッド呼び出しはエラーの原因になりますが、詳細については、&lt;a href=&quot;#Method-Call-Variations&quot;&gt;メソッド呼び出しのバリエーションの&lt;/a&gt;セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="37bacecd2332508665ec81733fbdffa749ac5bfa" translate="yes" xml:space="preserve">
          <source>If the length of the input string is not even, it behaves as if padded by a null character at the end. Similarly, &quot;extra&quot; nybbles are ignored during unpacking.</source>
          <target state="translated">入力文字列の長さが偶数でない場合は、最後にヌル文字を入れてパディングしたように振る舞います。同様に、&quot;余分な&quot; nybbles は解凍時に無視されます。</target>
        </trans-unit>
        <trans-unit id="88b7864a27a0577ffff54b7d555aea0617e9d505" translate="yes" xml:space="preserve">
          <source>If the length of the input string is not evenly divisible by 8, the remainder is packed as if the input string were padded by null characters at the end. Similarly during unpacking, &quot;extra&quot; bits are ignored.</source>
          <target state="translated">入力文字列の長さが 8 で割り切れる長さでない場合、残りの部分は入力文字列の最後にヌル文字をパディングしたかのようにパックされる。同様に、解凍時には &quot;余分な &quot;ビットは無視される。</target>
        </trans-unit>
        <trans-unit id="a2e67d3ea522ed96fe7a9c8431714f7f3d0ba5c5" translate="yes" xml:space="preserve">
          <source>If the library happens to be in a location not in &lt;code&gt;$Config{libpth}&lt;/code&gt; , you need:</source>
          <target state="translated">ライブラリが &lt;code&gt;$Config{libpth}&lt;/code&gt; 場所にある場合は、次のものが必要です。</target>
        </trans-unit>
        <trans-unit id="c256d5d027a4accdcc167669a7812e5bf777ccbe" translate="yes" xml:space="preserve">
          <source>If the library happens to be in a location not in &lt;code&gt;$Config{libpth}&lt;/code&gt;, you need:</source>
          <target state="translated">ライブラリが &lt;code&gt;$Config{libpth}&lt;/code&gt; 場所にある場合は、次のものが必要です。</target>
        </trans-unit>
        <trans-unit id="96118a855a2f1b2515701521249ef16334052e1f" translate="yes" xml:space="preserve">
          <source>If the line number is &lt;code&gt;.&lt;/code&gt;, sets a breakpoint on the current line:</source>
          <target state="translated">行番号がの場合 &lt;code&gt;.&lt;/code&gt; 、現在の行にブレークポイントを設定します。</target>
        </trans-unit>
        <trans-unit id="94650250941df693d5a68b4ac245a935f3b9c2e5" translate="yes" xml:space="preserve">
          <source>If the list moderators tell you that you are not being civil, carefully consider how your words have appeared before responding in any way. Were they kind? You may protest, but repeated protest in the face of a repeatedly reaffirmed decision is not acceptable. Repeatedly protesting about the moderators' decisions regarding a third party is also unacceptable, as is continuing to initiate off-list contact with the moderators about their decisions.</source>
          <target state="translated">リストの司会者があなたが礼儀正しくないと言ったら、どのような方法で応答する前に、あなたの言葉がどのように現れたかを注意深く考えてみてください。彼らは親切でしたか?抗議するのは構いませんが、何度も再確認された決定に対して抗議を繰り返すのは許されません。第三者に関するモデレーターの決定について繰り返し抗議することも、モデレーターの決定についてリスト外の連絡を開始し続けることと同様に受け入れられません。</target>
        </trans-unit>
        <trans-unit id="f93c03970a56584f9fb61994432bc17cb7db5f12" translate="yes" xml:space="preserve">
          <source>If the list moderators tell you that you are not being civil, carefully consider how your words have appeared before responding in any way. You may protest, but repeated protest in the face of a repeatedly reaffirmed decision is not acceptable.</source>
          <target state="translated">リストの司会者から礼儀を欠いていると言われた場合は、どのような方法で対応する前に、自分の言葉がどのように現れたのかをよく考えてください。抗議するのは構いませんが、何度も再確認された決定に対して抗議を繰り返すのは許されません。</target>
        </trans-unit>
        <trans-unit id="e0a9f58b026642b9c9e8e7bb8deab3007d5236f6" translate="yes" xml:space="preserve">
          <source>If the locale from the user's environment is desired, there should be no need for XS code to set the locale except for &lt;code&gt;LC_NUMERIC&lt;/code&gt; , as perl has already set it up. XS code should avoid changing the locale, as it can adversely affect other, unrelated, code and may not be thread safe. However, some alien libraries that may be called do set it, such as &lt;code&gt;Gtk&lt;/code&gt; . This can cause problems for the perl core and other modules. Starting in v5.20.1, calling the function &lt;a href=&quot;perlapi#sync_locale&quot;&gt;sync_locale()&lt;/a&gt; from XS should be sufficient to avoid most of these problems. Prior to this, you need a pure Perl statement that does this:</source>
          <target state="translated">ユーザーの環境からのロケールが必要な場合、perlによってすでに設定されているため、 &lt;code&gt;LC_NUMERIC&lt;/code&gt; を除いて、ロケールを設定するためのXSコードは必要ありません。XSコードは、他の無関係なコードに悪影響を与える可能性があり、スレッドセーフではない可能性があるため、ロケールの変更を避ける必要があります。ただし、 &lt;code&gt;Gtk&lt;/code&gt; など、呼び出される可能性のある一部のエイリアンライブラリは設定します。これは、perlコアおよびその他のモジュールに問題を引き起こす可能性があります。v5.20.1以降、これらの問題のほとんどを回避するには、XSから関数&lt;a href=&quot;perlapi#sync_locale&quot;&gt;sync_locale（）を&lt;/a&gt;呼び出すだけで十分です。これの前に、これを行う純粋なPerlステートメントが必要です。</target>
        </trans-unit>
        <trans-unit id="29cc247eadfeb453e1955bad0bbc5ed23022a753" translate="yes" xml:space="preserve">
          <source>If the locale from the user's environment is desired, there should be no need for XS code to set the locale except for &lt;code&gt;LC_NUMERIC&lt;/code&gt;, as perl has already set the others up. XS code should avoid changing the locale, as it can adversely affect other, unrelated, code and may not be thread-safe. To minimize problems, the macros &lt;a href=&quot;perlapi#STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;&quot;STORE_LC_NUMERIC_SET_TO_NEEDED&quot; in perlapi&lt;/a&gt;, &lt;a href=&quot;perlapi#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;&quot;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot; in perlapi&lt;/a&gt;, and &lt;a href=&quot;perlapi#RESTORE_LC_NUMERIC&quot;&gt;&quot;RESTORE_LC_NUMERIC&quot; in perlapi&lt;/a&gt; should be used to affect any needed change.</source>
          <target state="translated">ユーザーの環境からのロケールが必要な場合、perlはすでに他のロケールを設定しているため、 &lt;code&gt;LC_NUMERIC&lt;/code&gt; を除いて、XSコードでロケールを設定する必要はありません。XSコードは、他の無関係なコードに悪影響を及ぼし、スレッドセーフではない可能性があるため、ロケールの変更を避ける必要があります。問題を最小限に抑えるために、マクロ&lt;a href=&quot;perlapi#STORE_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;「STORE_LC_NUMERIC_SET_TO_NEEDED」はperlapiで&lt;/a&gt;、&lt;a href=&quot;perlapi#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;はperlapiで「STORE_LC_NUMERIC_FORCE_TO_UNDERLYING」&lt;/a&gt;と&lt;a href=&quot;perlapi#RESTORE_LC_NUMERIC&quot;&gt;はperlapiで「RESTORE_LC_NUMERICは」&lt;/a&gt;あらゆる必要な変更に影響を与えるために使用されるべきです。</target>
        </trans-unit>
        <trans-unit id="4664ee573739492d5623b9369f8faea69d271aa1" translate="yes" xml:space="preserve">
          <source>If the main thread exits while there are detached threads which are still running, then Perl's global destruction phase is not executed because otherwise certain global structures that control the operation of threads and that are allocated in the main thread's memory may get destroyed before the detached thread is destroyed.</source>
          <target state="translated">もし、メインスレッドが終了した後も実行中のデタッチドスレッドがある場合、Perl のグローバル破壊フェーズは実行されません。</target>
        </trans-unit>
        <trans-unit id="823e97e3e713d61f96695c0b7d66500ba0535b81" translate="yes" xml:space="preserve">
          <source>If the make process encounters trouble with either compilation or linking then try setting the _C89_CCMODE to 1. Assuming sh is your login shell then run:</source>
          <target state="translated">make プロセスでコンパイルやリンクに問題が発生した場合は、_C89_CCMODE を 1 に設定してみてください。sh がログインシェルだと仮定して実行してみてください。</target>
        </trans-unit>
        <trans-unit id="fa7d8db26880e3b2b83f69006312ed2e5013aabf" translate="yes" xml:space="preserve">
          <source>If the member name in the zip archive is not valid UTF-8 when this optionn is true, the script will die with an error message.</source>
          <target state="translated">このオプションnがtrueの場合、zipアーカイブ内のメンバー名がUTF-8ではない場合、スクリプトはエラーメッセージを表示して終了します。</target>
        </trans-unit>
        <trans-unit id="0119f182d57e85f55c259aad67e5507f5a71d506" translate="yes" xml:space="preserve">
          <source>If the method is called in scalar context, then it will try to extract exactly</source>
          <target state="translated">メソッドがスカラコンテキストで呼び出された場合、そのメソッドは正確に</target>
        </trans-unit>
        <trans-unit id="2ae0fed8c834da6c72af01b4cce727e6b5ec751e" translate="yes" xml:space="preserve">
          <source>If the module &lt;code&gt;Module&lt;/code&gt; is already loaded, then the declaration</source>
          <target state="translated">モジュール &lt;code&gt;Module&lt;/code&gt; がすでにロードされている場合は、宣言</target>
        </trans-unit>
        <trans-unit id="1b3cd9a44d834ecaba373518cdced67ef6882e1c" translate="yes" xml:space="preserve">
          <source>If the module &lt;code&gt;Module&lt;/code&gt; is not loaded yet, then the above declaration declares functions func1() and func2() in the current package. When these functions are called, they load the package &lt;code&gt;Module&lt;/code&gt; if needed, and substitute themselves with the correct definitions.</source>
          <target state="translated">モジュール &lt;code&gt;Module&lt;/code&gt; がまだロードされていない場合、上記の宣言は現在のパッケージで関数func1（）およびfunc2（）を宣言します。これらの関数が呼び出されると、必要に応じてパッケージ &lt;code&gt;Module&lt;/code&gt; ロードされ、適切な定義に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="aa83e5ba98e2e00acddd7117050d321e4e9d54d9" translate="yes" xml:space="preserve">
          <source>If the module is already loaded, &lt;code&gt;mark_as_loaded&lt;/code&gt; will carp about this and tell you from where the &lt;code&gt;PACKAGE&lt;/code&gt; has been loaded already.</source>
          <target state="translated">モジュールがすでにロードされている場合、 &lt;code&gt;mark_as_loaded&lt;/code&gt; はこれについて鯉を調べ、 &lt;code&gt;PACKAGE&lt;/code&gt; がすでにロードされている場所から通知します。</target>
        </trans-unit>
        <trans-unit id="e1cec740a866f3242f2245723f611d8e6a35a17e" translate="yes" xml:space="preserve">
          <source>If the module is already unloaded, &lt;code&gt;mark_as_unloaded&lt;/code&gt; will carp about this and tell you the &lt;code&gt;PACKAGE&lt;/code&gt; has been unloaded already.</source>
          <target state="translated">モジュールがすでにアンロードされている場合、 &lt;code&gt;mark_as_unloaded&lt;/code&gt; はこれを回避し、 &lt;code&gt;PACKAGE&lt;/code&gt; がすでにアンロードされていることを通知します。</target>
        </trans-unit>
        <trans-unit id="55dd2ee6ad71be855cc8cea6dc45014e0de598b9" translate="yes" xml:space="preserve">
          <source>If the module is needed inside the</source>
          <target state="translated">内部でモジュールが必要な場合</target>
        </trans-unit>
        <trans-unit id="fab3a0f11307492451a39d88e9be980974dcb4d2" translate="yes" xml:space="preserve">
          <source>If the module will only be used inside a thread, you can try loading the module from inside the thread entry point function using &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; if needed):</source>
          <target state="translated">モジュールがスレッド内でのみ使用される場合は、 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; （および必要に応じて &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ）を使用して、スレッドエントリポイント関数内からモジュールをロードしてみます。</target>
        </trans-unit>
        <trans-unit id="b3aa735bc422b148dd84e6d085642a87f49e47ba" translate="yes" xml:space="preserve">
          <source>If the module will only be used inside a thread, you can try loading the module from inside the thread entry point function using &lt;code&gt;require&lt;/code&gt; (and &lt;code&gt;import&lt;/code&gt; if needed):</source>
          <target state="translated">モジュールがスレッド内でのみ使用される場合は、 &lt;code&gt;require&lt;/code&gt; （および必要に応じて &lt;code&gt;import&lt;/code&gt; ）を使用して、スレッドエントリポイント関数内からモジュールをロードしてみてください。</target>
        </trans-unit>
        <trans-unit id="cc3b3934908dc77b79dcbb0b789e5b838d36463c" translate="yes" xml:space="preserve">
          <source>If the name is given in UTF-8, set this to &lt;code&gt;HVhek_UTF8&lt;/code&gt; . The value is passed direct as the parameter</source>
          <target state="translated">名前がUTF-8で指定されている場合は、これを &lt;code&gt;HVhek_UTF8&lt;/code&gt; に設定します。値はパラメーターとして直接渡されます</target>
        </trans-unit>
        <trans-unit id="873d55d8a257eaf7386c02b0cf4a9016781f6d23" translate="yes" xml:space="preserve">
          <source>If the name is given in UTF-8, set this to &lt;code&gt;HVhek_UTF8&lt;/code&gt;. The value is passed direct as the parameter</source>
          <target state="translated">名前がUTF-8で指定されている場合は、これを &lt;code&gt;HVhek_UTF8&lt;/code&gt; に設定します。値はパラメータとして直接渡されます</target>
        </trans-unit>
        <trans-unit id="31ddfa3306f944720376a989f9d5fd87c400eb47" translate="yes" xml:space="preserve">
          <source>If the name is omitted, format &quot;STDOUT&quot; is defined. A single &quot;.&quot; in column 1 is used to terminate a format. FORMLIST consists of a sequence of lines, each of which may be one of three types:</source>
          <target state="translated">名前を省略した場合、フォーマット &quot;STDOUT &quot;が定義される。1 列目の&quot;.はフォーマットの終了に使用される。FORMLIST は一連の行で構成されており、それぞれの行は 3 種類のうちの 1 つである。</target>
        </trans-unit>
        <trans-unit id="0def4cf3757d0553a2341afef733c2c0849f1052" translate="yes" xml:space="preserve">
          <source>If the name is unknown, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned (or an empty list in list context). Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt; &quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt; . This function does not recognize those in the input, returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. Nor are they included in the output as possible synonyms.</source>
          <target state="translated">名前が不明の場合、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （またはリストコンテキストの空のリスト）が返されます。Perlは通常、正規表現のプロパティ名を認識し、オプションの &lt;code&gt;&quot;Is_&lt;/code&gt; &quot;（アンダースコアあり、またはアンダースコアなし）を &lt;code&gt;\p{isgc=punct}&lt;/code&gt; などのように接頭辞として付けます。この関数は入力のそれらを認識せず、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。また、それらは可能な同義語として出力に含まれていません。</target>
        </trans-unit>
        <trans-unit id="88548ac66c76967c7a6bd845c8445fe8da2c6437" translate="yes" xml:space="preserve">
          <source>If the name is unknown, &lt;code&gt;undef&lt;/code&gt; is returned (or an empty list in list context). Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt;&quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt;. This function does not recognize those in the input, returning &lt;code&gt;undef&lt;/code&gt;. Nor are they included in the output as possible synonyms.</source>
          <target state="translated">名前が不明な場合は、 &lt;code&gt;undef&lt;/code&gt; （またはリストコンテキストの空のリスト）が返されます。Perlは通常、 &lt;code&gt;\p{isgc=punct}&lt;/code&gt; ように、接頭辞としてオプションの &lt;code&gt;&quot;Is_&lt;/code&gt; 」（アンダースコアの有無にかかわらず）が付いた正規表現のプロパティ名を認識することに注意してください。この関数は入力内のものを認識せず、 &lt;code&gt;undef&lt;/code&gt; を返します。また、可能な同義語として出力に含まれていません。</target>
        </trans-unit>
        <trans-unit id="a79bb3cadb8f975e939ef18071a526a4b5d3363e" translate="yes" xml:space="preserve">
          <source>If the named parameter &lt;code&gt;config_override&lt;/code&gt; is specified, it should be a reference to a hash which contains all information usually found in &lt;code&gt;%Config::Config&lt;/code&gt; . For example, you can obtain the configuration information for a separate perl installation and pass that in.</source>
          <target state="translated">名前付きパラメーター &lt;code&gt;config_override&lt;/code&gt; が指定されている場合、これは通常 &lt;code&gt;%Config::Config&lt;/code&gt; にあるすべての情報を含むハッシュへの参照である必要があります。たとえば、個別のperlインストールの構成情報を取得して渡すことができます。</target>
        </trans-unit>
        <trans-unit id="455e39c93d939d0a811460c9e6eb8b61291c4896" translate="yes" xml:space="preserve">
          <source>If the named parameter &lt;code&gt;config_override&lt;/code&gt; is specified, it should be a reference to a hash which contains all information usually found in &lt;code&gt;%Config::Config&lt;/code&gt;. For example, you can obtain the configuration information for a separate perl installation and pass that in.</source>
          <target state="translated">名前付きパラメーター &lt;code&gt;config_override&lt;/code&gt; が指定されている場合は、 &lt;code&gt;%Config::Config&lt;/code&gt; 通常あるすべての情報を含むハッシュへの参照である必要があります。たとえば、個別のperlインストールの構成情報を取得して、それを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="db3ef5746e8cd5bab310439aa50dba89f545a584" translate="yes" xml:space="preserve">
          <source>If the named parameter &lt;code&gt;skip_cwd&lt;/code&gt; is true, the current directory &lt;code&gt;.&lt;/code&gt; will be stripped from &lt;code&gt;@INC&lt;/code&gt; before searching for .packlists. This keeps ExtUtils::Installed from finding modules installed in other perls that happen to be located below the current directory.</source>
          <target state="translated">名前付きパラメーター &lt;code&gt;skip_cwd&lt;/code&gt; がtrueの場合、現在のディレクトリ &lt;code&gt;.&lt;/code&gt; &lt;code&gt;@INC&lt;/code&gt; を検索する前に@INC から削除されます。これにより、ExtUtils :: Installedは、現在のディレクトリの下にある他のperlにインストールされているモジュールを見つけることができなくなります。</target>
        </trans-unit>
        <trans-unit id="7f6facbdb87684a56df7a20a0d54e6b8073b8eb9" translate="yes" xml:space="preserve">
          <source>If the new version of the C library is ABI-compatible (that's Application Binary Interface compatible) with the version you're upgrading from, and if the shared library version didn't change, no re-compilation should be necessary.</source>
          <target state="translated">C ライブラリの新しいバージョンがアップグレード元のバージョンと ABI 互換 (つまり Application Binary Interface 互換)であり、共有ライブラリのバージョンが変更されていなければ、再コンパイルは必要ありません。</target>
        </trans-unit>
        <trans-unit id="3f6451aaf2bf86188eece8b63b5bab6c7257462f" translate="yes" xml:space="preserve">
          <source>If the next character is in (or extends into) the next chunk of input text, the next chunk will be read in. Normally the current chunk will be discarded at the same time, but if</source>
          <target state="translated">次の文字が入力テキストの次のチャンクにある(または次のチャンクに伸びている)場合、次のチャンクが読み込まれます。通常、現在のチャンクは同時に破棄されますが、もし</target>
        </trans-unit>
        <trans-unit id="1f73682ad19692885d11822d4f6d7cb69031b04a" translate="yes" xml:space="preserve">
          <source>If the next character is in (or extends into) the next chunk of input text, the next chunk will be read in. Normally the current chunk will be discarded at the same time, but if &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;LEX_KEEP_PREVIOUS&lt;/code&gt; bit set, then the current chunk will not be discarded.</source>
          <target state="translated">次の文字が入力テキストの次のチャンクにある（または拡張されている）場合、次のチャンクが読み込まれます。通常、現在のチャンクは同時に破棄されますが、 &lt;code&gt;flags&lt;/code&gt; に &lt;code&gt;LEX_KEEP_PREVIOUS&lt;/code&gt; ビットが設定されている場合、現在のチャンクはチャンクは破棄されません。</target>
        </trans-unit>
        <trans-unit id="2a6672795e23362230912b4b8b4e28fb661f0a19" translate="yes" xml:space="preserve">
          <source>If the number consists of digits only, JSON::PP will try to represent it as an integer value. If that fails, it will try to represent it as a numeric (floating point) value if that is possible without loss of precision. Otherwise it will preserve the number as a string value (in which case you lose roundtripping ability, as the JSON number will be re-encoded to a JSON string).</source>
          <target state="translated">数値が数字のみで構成されている場合、JSON::PPはそれを整数値として表現しようとします。失敗した場合は、精度を落とさずに数値 (浮動小数点)で表現しようとします。そうでない場合は、数値を文字列として保持します (この場合、JSON の数値は JSON 文字列に再エンコードされるため、ラウンドトリップ機能を失います)。</target>
        </trans-unit>
        <trans-unit id="bf7862ebb65f1805f38240d9ec3614885b02e6ad" translate="yes" xml:space="preserve">
          <source>If the number following the backslash is N (in decimal), and Perl already has seen N capture groups, Perl considers this a backreference. Otherwise, it considers it an octal escape. If N has more than three digits, Perl takes only the first three for the octal escape; the rest are matched as is.</source>
          <target state="translated">バックスラッシュに続く数字がN(10進数)で、PerlがすでにN個のキャプチャグループを見ている場合、Perlはこれを逆参照とみなします。そうでなければ、8進数のエスケープとみなします。Nが3桁以上の数字を持つ場合、Perlは最初の3桁だけを八進数エスケープとし、残りはそのままマッチします。</target>
        </trans-unit>
        <trans-unit id="fad0df49da49393094ec039045da70fce50b5429" translate="yes" xml:space="preserve">
          <source>If the number of data bytes ($bytes) is given, that many data bytes are included in the ping packet sent to the remote host. The number of data bytes is ignored if the protocol is &quot;tcp&quot;. The minimum (and default) number of data bytes is 1 if the protocol is &quot;udp&quot; and 0 otherwise. The maximum number of data bytes that can be specified is 1024.</source>
          <target state="translated">データバイト数($bytes)が与えられた場合、リモートホストに送信されるpingパケットにその数だけのデータバイトが含まれます。プロトコルが &quot;tcp &quot;の場合、データバイト数は無視されます。プロトコルが &quot;udp &quot;の場合、データバイト数の最小値(およびデフォルト値)は1で、それ以外の場合は0です。指定できるデータバイト数の最大値は1024です。</target>
        </trans-unit>
        <trans-unit id="173b84764a7ba838f6e1039dc98cb544515aa621" translate="yes" xml:space="preserve">
          <source>If the number of data bytes (&lt;code&gt;bytes&lt;/code&gt;) is given, that many data bytes are included in the ping packet sent to the remote host. The number of data bytes is ignored if the protocol is &quot;tcp&quot;. The minimum (and default) number of data bytes is 1 if the protocol is &quot;udp&quot; and 0 otherwise. The maximum number of data bytes that can be specified is 65535, but staying below the MTU (1472 bytes for ICMP) is recommended. Many small devices cannot deal with fragmented ICMP packets.</source>
          <target state="translated">データバイト数（ &lt;code&gt;bytes&lt;/code&gt; ）が指定されている場合、その数のデータバイトがリモートホストに送信されるpingパケットに含まれます。プロトコルが「tcp」の場合、データバイト数は無視されます。プロトコルが「udp」の場合、データバイトの最小（およびデフォルト）数は1で、それ以外の場合は0です。指定できるデータバイトの最大数は65535ですが、MTU（ICMPの場合は1472バイト）を下回ることをお勧めします。多くの小さなデバイスは、断片化されたICMPパケットを処理できません。</target>
        </trans-unit>
        <trans-unit id="6ea88b95c30f8557b60611e6fa0d52e56ecf8669" translate="yes" xml:space="preserve">
          <source>If the number of partitions on the disk.</source>
          <target state="translated">ディスク上のパーティションの数の場合。</target>
        </trans-unit>
        <trans-unit id="a34b4bc1598422e778b8ed9662906c7efb975344" translate="yes" xml:space="preserve">
          <source>If the number of scalars in the left-hand list is greater than that in the left-hand list, the &quot;missing&quot; scalars will become undefined.</source>
          <target state="translated">左側のリストのスカラの数が、左側のリストのスカラの数よりも多い場合、「欠落している」スカラは未定義になります。</target>
        </trans-unit>
        <trans-unit id="73c7831330bbfcd31669c32d53f7a76b28d963cd" translate="yes" xml:space="preserve">
          <source>If the number of scalars in the left-hand list is less than that in the right-hand list, the &quot;extra&quot; scalars in the right-hand list will simply not be assigned.</source>
          <target state="translated">左手のリストのスカラの数が右手のリストのスカラの数より少ない場合、右手のリストの「余分な」スカラは単純に割り当てられません。</target>
        </trans-unit>
        <trans-unit id="cf726231b3d599cdbe46b108046dbf7815381c4c" translate="yes" xml:space="preserve">
          <source>If the object has been passed to a child process during a fork, the file will be deleted when the object goes out of scope in the parent.</source>
          <target state="translated">フォーク中にオブジェクトが子プロセスに渡された場合、オブジェクトが親プロセスのスコープ外になるとファイルは削除されます。</target>
        </trans-unit>
        <trans-unit id="39e52d92c6b313ed3349d0401be82f80d273536a" translate="yes" xml:space="preserve">
          <source>If the only casing for a code point is locale-dependent, then the returned hash will not have any of the base keys, like &lt;code&gt;code&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , etc., but will contain only locale keys.</source>
          <target state="translated">コードポイントの &lt;code&gt;upper&lt;/code&gt; と小文字のみがロケールに依存する場合、返されるハッシュには、 &lt;code&gt;code&lt;/code&gt; 、upperなどの基本キーは含まれず、ロケールキーのみが含まれます。</target>
        </trans-unit>
        <trans-unit id="4285420e25852376bd4b42fe10dbce58fa32d6ad" translate="yes" xml:space="preserve">
          <source>If the only casing for a code point is locale-dependent, then the returned hash will not have any of the base keys, like &lt;code&gt;code&lt;/code&gt;, &lt;code&gt;upper&lt;/code&gt;, etc., but will contain only locale keys.</source>
          <target state="translated">コードポイントの唯一の &lt;code&gt;upper&lt;/code&gt; 小文字がロケールに依存している場合、返されるハッシュには、 &lt;code&gt;code&lt;/code&gt; 、アッパーなどの基本キーは含まれませんが、ロケールキーのみが含まれます。</target>
        </trans-unit>
        <trans-unit id="17fa159e601e547a6489ad99ba45fba36084dad4" translate="yes" xml:space="preserve">
          <source>If the only comparison needed is whether an installed module is of a sufficiently high version, a direct test may be done using the string form of &lt;code&gt;eval&lt;/code&gt; and the &lt;code&gt;use&lt;/code&gt; function. For example, for module &lt;code&gt;$mod&lt;/code&gt; and version prerequisite &lt;code&gt;$prereq&lt;/code&gt;:</source>
          <target state="translated">インストールされているモジュールが十分に高いバージョンであるかどうかだけを比較する必要がある場合は、文字列形式の &lt;code&gt;eval&lt;/code&gt; と &lt;code&gt;use&lt;/code&gt; 関数を使用して直接テストを実行できます。たとえば、モジュール &lt;code&gt;$mod&lt;/code&gt; とバージョンの前提条件 &lt;code&gt;$prereq&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e51d5a9ae61f6c29388fc414c6297a691764547b" translate="yes" xml:space="preserve">
          <source>If the operand is a reference to a blessed object, then the name of the class into which the referent is blessed will be returned. &lt;code&gt;ref&lt;/code&gt; doesn't care what the physical type of the referent is; blessing takes precedence over such concerns. Beware that exact comparison of &lt;code&gt;ref&lt;/code&gt; results against a class name doesn't perform a class membership test: a class's members also include objects blessed into subclasses, for which &lt;code&gt;ref&lt;/code&gt; will return the name of the subclass. Also beware that class names can clash with the built-in type names (described below).</source>
          <target state="translated">オペランドが祝福されたオブジェクトへの参照である場合、指示対象が祝福されているクラスの名前が返されます。 &lt;code&gt;ref&lt;/code&gt; は、指示対象の物理的なタイプが何であるかを気にしません。祝福はそのような懸念よりも優先されます。 &lt;code&gt;ref&lt;/code&gt; の結果をクラス名と正確に比較しても、クラスメンバーシップテストは実行されないことに注意してください。クラスのメンバーには、サブクラスに祝福されたオブジェクトも含まれ、 &lt;code&gt;ref&lt;/code&gt; はサブクラスの名前を返します。また、クラス名が組み込みの型名（以下で説明）と衝突する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7623f1bb883be3a3b5a21de5d5644725c26daefe" translate="yes" xml:space="preserve">
          <source>If the operand is a reference to an unblessed object, then the return value indicates the type of object. If the unblessed referent is not a scalar, then the return value will be one of the strings &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;HASH&lt;/code&gt;, &lt;code&gt;CODE&lt;/code&gt;, &lt;code&gt;FORMAT&lt;/code&gt;, or &lt;code&gt;IO&lt;/code&gt;, indicating only which kind of object it is. If the unblessed referent is a scalar, then the return value will be one of the strings &lt;code&gt;SCALAR&lt;/code&gt;, &lt;code&gt;VSTRING&lt;/code&gt;, &lt;code&gt;REF&lt;/code&gt;, &lt;code&gt;GLOB&lt;/code&gt;, &lt;code&gt;LVALUE&lt;/code&gt;, or &lt;code&gt;REGEXP&lt;/code&gt;, depending on the kind of value the scalar currently has. But note that &lt;code&gt;qr//&lt;/code&gt; scalars are created already blessed, so &lt;code&gt;ref qr/.../&lt;/code&gt; will likely return &lt;code&gt;Regexp&lt;/code&gt;. Beware that these built-in type names can also be used as class names, so &lt;code&gt;ref&lt;/code&gt; returning one of these names doesn't unambiguously indicate that the referent is of the kind to which the name refers.</source>
          <target state="translated">オペランドが祝福されていないオブジェクトへの参照である場合、戻り値はオブジェクトのタイプを示します。祝福されていない指示対象がスカラーでない場合、戻り値は文字列 &lt;code&gt;ARRAY&lt;/code&gt; 、 &lt;code&gt;HASH&lt;/code&gt; 、 &lt;code&gt;CODE&lt;/code&gt; 、 &lt;code&gt;FORMAT&lt;/code&gt; 、または &lt;code&gt;IO&lt;/code&gt; のいずれかになり、オブジェクトの種類のみを示します。祝福されていない指示対象がスカラーの場合、戻り値は、スカラーが現在持っている値の種類に応じて、文字列 &lt;code&gt;SCALAR&lt;/code&gt; 、 &lt;code&gt;VSTRING&lt;/code&gt; 、 &lt;code&gt;REF&lt;/code&gt; 、 &lt;code&gt;GLOB&lt;/code&gt; 、 &lt;code&gt;LVALUE&lt;/code&gt; 、または &lt;code&gt;REGEXP&lt;/code&gt; のいずれかになります。ただし、 &lt;code&gt;qr//&lt;/code&gt; スカラーはすでに祝福されて作成されているため、 &lt;code&gt;ref qr/.../&lt;/code&gt; はおそらく正規表現を返し &lt;code&gt;Regexp&lt;/code&gt; 。これらの組み込み型名はクラス名としても使用できることに注意してください。したがって、これらの名前の1つを返す &lt;code&gt;ref&lt;/code&gt; は、指示対象がその名前が参照する種類であることを明確に示しているわけではありません。</target>
        </trans-unit>
        <trans-unit id="8aa1ec170d0d4fcfcfbbdd9dd518a1d70b552ce0" translate="yes" xml:space="preserve">
          <source>If the operand is not a reference, then the empty string will be returned. An empty string will only be returned in this situation. &lt;code&gt;ref&lt;/code&gt; is often useful to just test whether a value is a reference, which can be done by comparing the result to the empty string. It is a common mistake to use the result of &lt;code&gt;ref&lt;/code&gt; directly as a truth value: this goes wrong because &lt;code&gt;0&lt;/code&gt; (which is false) can be returned for a reference.</source>
          <target state="translated">オペランドが参照でない場合は、空の文字列が返されます。空の文字列は、この状況でのみ返されます。 &lt;code&gt;ref&lt;/code&gt; は、値が参照であるかどうかをテストする場合に役立つことがよくあります。これは、結果を空の文字列と比較することで実行できます。 &lt;code&gt;ref&lt;/code&gt; の結果を真理値として直接使用することはよくある間違いです。参照用に &lt;code&gt;0&lt;/code&gt; （false）が返される可能性があるため、これはうまくいきません。</target>
        </trans-unit>
        <trans-unit id="addcad10a864d1cffc4846608d394fea1feac09a" translate="yes" xml:space="preserve">
          <source>If the operands to a binary bitwise op are strings of different sizes, &lt;b&gt;|&lt;/b&gt; and &lt;b&gt;^&lt;/b&gt; ops act as though the shorter operand had additional zero bits on the right, while the &lt;b&gt;&amp;amp;&lt;/b&gt; op acts as though the longer operand were truncated to the length of the shorter. The granularity for such extension or truncation is one or more bytes.</source>
          <target state="translated">バイナリビット単位演算のオペランドが異なるサイズの文字列の場合、&lt;b&gt;| &lt;/b&gt;および&lt;b&gt;^&lt;/b&gt; opsは、短い方のオペランドの右側に追加のゼロビットがあるかのように動作し、&lt;b&gt;＆&lt;/b&gt; opは、長い方のオペランドが短い方の長さに切り捨てられたかのように動作します。そのような拡張または切り捨ての細分性は、1バイト以上です。</target>
        </trans-unit>
        <trans-unit id="c7870bd3c024159f240305b7047279e21ad1fe56" translate="yes" xml:space="preserve">
          <source>If the operating system supports it (for example BSD derived systems), the filehandle will be opened with O_EXLOCK (open with exclusive file lock). This can sometimes cause problems if the intention is to pass the filename to another system that expects to take an exclusive lock itself (such as DBD::SQLite) whilst ensuring that the tempfile is not reused. In this situation the &quot;EXLOCK&quot; option can be passed to tempfile. By default EXLOCK will be true (this retains compatibility with earlier releases).</source>
          <target state="translated">オペレーティングシステムがこれをサポートしている場合 (BSD 派生システムなど)、ファイルハンドルは O_EXLOCK (排他的ファイルロックで開く)で開かれます。これは、ファイル名を他のシステム (DBD::SQLite など)に渡す際に、 tempfile が再利用されないようにしながら排他的なロックをかけようとする場合に問題が発生することがあります。このような場合、 tempfile に &quot;EXLOCK&quot; オプションを渡すことができます。デフォルトでは EXLOCK は true になります (これは以前のリリースとの互換性を保持しています)。</target>
        </trans-unit>
        <trans-unit id="e19b7bb4d69a3c985ce8931960025916d3561c3a" translate="yes" xml:space="preserve">
          <source>If the operation being timed out is system() or qx(), this technique is liable to generate zombies. If this matters to you, you'll need to do your own fork() and exec(), and kill the errant child process.</source>
          <target state="translated">タイムアウトしている操作が system()や qx()の場合、この手法はゾンビを発生させる可能性があります。これが気になる場合は、自分で fork()と exec()を行い、間違った子プロセスを kill する必要があります。</target>
        </trans-unit>
        <trans-unit id="05f4a71ea34fe9d7ddbd210db5290a2dfa223838" translate="yes" xml:space="preserve">
          <source>If the operation shown is &quot;ToFold&quot;, it means that case-insensitive matching in a regular expression was done on the code point.</source>
          <target state="translated">表示されている操作が &quot;ToFold &quot;であれば、正規表現の大文字小文字を区別しないマッチングがコードポイント上で行われたことを意味します。</target>
        </trans-unit>
        <trans-unit id="3ba42937f598291497eafce66d29e91aabe688c5" translate="yes" xml:space="preserve">
          <source>If the optimization can not be applied, this returns undef. If it can be applied, this method returns a hash reference containing the following information:</source>
          <target state="translated">最適化を適用できない場合は undef を返します。最適化が適用できる場合、このメソッドは以下の情報を含むハッシュ参照を返します。</target>
        </trans-unit>
        <trans-unit id="a982ec5add551174c87d54c0c75cad924249147a" translate="yes" xml:space="preserve">
          <source>If the option destination is a reference to a hash, the option will take, as value, strings of the form</source>
          <target state="translated">オプションの先がハッシュへの参照である場合、オプションは値として以下の形式の文字列を取ります。</target>
        </trans-unit>
        <trans-unit id="ab8a370e734c2b7f25ad3475fabaef52fd095ddb" translate="yes" xml:space="preserve">
          <source>If the option is provided, and &lt;code&gt;PERL_PERTURB_KEYS&lt;/code&gt; is NOT set, then a value of '0' implies &lt;code&gt;PERL_PERTURB_KEYS=0&lt;/code&gt; and any other value implies &lt;code&gt;PERL_PERTURB_KEYS=2&lt;/code&gt; .</source>
          <target state="translated">オプションが指定されていて、 &lt;code&gt;PERL_PERTURB_KEYS&lt;/code&gt; が設定されていない場合、値「0」は &lt;code&gt;PERL_PERTURB_KEYS=0&lt;/code&gt; を意味し、他の値は &lt;code&gt;PERL_PERTURB_KEYS=2&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="2d707532b21b034988218d78dc5dd2089b91f3ef" translate="yes" xml:space="preserve">
          <source>If the option is provided, and &lt;code&gt;PERL_PERTURB_KEYS&lt;/code&gt; is NOT set, then a value of '0' implies &lt;code&gt;PERL_PERTURB_KEYS=0&lt;/code&gt; and any other value implies &lt;code&gt;PERL_PERTURB_KEYS=2&lt;/code&gt;.</source>
          <target state="translated">オプションが提供され、 &lt;code&gt;PERL_PERTURB_KEYS&lt;/code&gt; が設定されていない場合、値「0」は &lt;code&gt;PERL_PERTURB_KEYS=0&lt;/code&gt; を意味し、その他の値は &lt;code&gt;PERL_PERTURB_KEYS=2&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="bb774833de734f7b65efa56e3c7c5f53234542f8" translate="yes" xml:space="preserve">
          <source>If the option is set to false, the output buffer in the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method will be truncated before uncompressed data is written to it.</source>
          <target state="translated">このオプションがfalseに設定されている場合、 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; メソッドの出力バッファーは、圧縮されていないデータが書き込まれる前に切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="a7e5a140437039036cbeabf084c8f96c887a93f7" translate="yes" xml:space="preserve">
          <source>If the option is set to true, uncompressed data will be appended to the output buffer by the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method.</source>
          <target state="translated">このオプションがtrueに設定されている場合、非圧縮データは &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; メソッドによって出力バッファーに追加されます。</target>
        </trans-unit>
        <trans-unit id="c22c2720bbc793b56d2bdb2031cd852762e79aba" translate="yes" xml:space="preserve">
          <source>If the option is set to true, uncompressed data will be appended to the output buffer in the &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; and &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; methods.</source>
          <target state="translated">このオプションをtrueに設定すると、圧縮されていないデータが &lt;code&gt;$d-&amp;gt;deflate&lt;/code&gt; および &lt;code&gt;$d-&amp;gt;flush&lt;/code&gt; メソッドの出力バッファーに追加されます。</target>
        </trans-unit>
        <trans-unit id="943c28148863687139f9e45e03407da89d7e13fa" translate="yes" xml:space="preserve">
          <source>If the option value is required, Getopt::Long will take the command line argument that follows the option and assign this to the option variable. If, however, the option value is specified as optional, this will only be done if that value does not look like a valid command line option itself.</source>
          <target state="translated">オプション値が必須の場合、Getopt::Long はオプションの後に続くコマンドライン引数を取り、これをオプション変数に代入します。しかし、オプションの値がオプションとして指定されている場合は、その値が有効なコマンドラインオプションのように見えない場合にのみ、この処理が行われます。</target>
        </trans-unit>
        <trans-unit id="8b25fc0c82dd37f9c4b9d7996e6e001cd8c1c22e" translate="yes" xml:space="preserve">
          <source>If the order of &lt;code&gt;sv_setiv&lt;/code&gt; and &lt;code&gt;sv_setpv&lt;/code&gt; had been reversed, then the macro &lt;code&gt;SvPOK_on&lt;/code&gt; would need to be called instead of &lt;code&gt;SvIOK_on&lt;/code&gt; .</source>
          <target state="translated">順序場合 &lt;code&gt;sv_setiv&lt;/code&gt; と &lt;code&gt;sv_setpv&lt;/code&gt; が逆転していた、そしてマクロ &lt;code&gt;SvPOK_on&lt;/code&gt; はの代わりに呼び出される必要があるだろう &lt;code&gt;SvIOK_on&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2507fa462b26287b008669ac5e4307de24ce4d06" translate="yes" xml:space="preserve">
          <source>If the order of &lt;code&gt;sv_setiv&lt;/code&gt; and &lt;code&gt;sv_setpv&lt;/code&gt; had been reversed, then the macro &lt;code&gt;SvPOK_on&lt;/code&gt; would need to be called instead of &lt;code&gt;SvIOK_on&lt;/code&gt;.</source>
          <target state="translated">順序場合 &lt;code&gt;sv_setiv&lt;/code&gt; と &lt;code&gt;sv_setpv&lt;/code&gt; が逆転していた、そしてマクロ &lt;code&gt;SvPOK_on&lt;/code&gt; はの代わりに呼び出される必要があるだろう &lt;code&gt;SvIOK_on&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b0f391156a0e1896106ec41b93d3c42cc8fd48b" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; already contains a value (typically from a previous eval) that value is reused after appending &lt;code&gt;&quot;\t...propagated&quot;&lt;/code&gt; . This is useful for propagating exceptions:</source>
          <target state="translated">出力が空で、 &lt;code&gt;$@&lt;/code&gt; 既に値（通常は前の評価からの値）が含まれている場合、その値は &lt;code&gt;&quot;\t...propagated&quot;&lt;/code&gt; 追加した後に再利用されます。これは例外の伝播に役立ちます：</target>
        </trans-unit>
        <trans-unit id="25d81dad12165191ac2a4d2f3e667fda9ababd8e" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; already contains a value (typically from a previous eval) that value is used after appending &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; to &lt;code&gt;$@&lt;/code&gt; . This is useful for staying almost, but not entirely similar to &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">出力が空で、 &lt;code&gt;$@&lt;/code&gt; すでに値（通常は前の評価からの値）が含まれている場合、その値は &lt;code&gt;$@&lt;/code&gt; &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; を追加した後に使用されます。これは、ほとんど滞在するのに役立ちますが、完全に &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; とは似ていません。</target>
        </trans-unit>
        <trans-unit id="65e420bc5858eb45a1dddd4a10cb455bd1ce4cc1" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; already contains a value (typically from a previous eval) that value is used after appending &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; to &lt;code&gt;$@&lt;/code&gt; . This is useful for staying almost, but not entirely similar to &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">出力が空で、 &lt;code&gt;$@&lt;/code&gt; すでに値（通常は前の評価からの値）が含まれている場合、その値は &lt;code&gt;$@&lt;/code&gt; &lt;code&gt;&quot;\t...caught&quot;&lt;/code&gt; を追加した後に使用されます。これは、ほとんど滞在するのに役立ちますが、完全に &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; とは似ていません。</target>
        </trans-unit>
        <trans-unit id="2cfa46357b1516decacabae244126181d8b80b21" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; contains an object reference that has a &lt;code&gt;PROPAGATE&lt;/code&gt; method, that method will be called with additional file and line number parameters. The return value replaces the value in &lt;code&gt;$@&lt;/code&gt; ; i.e., as if &lt;code&gt;$@ = &lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; were called.</source>
          <target state="translated">出力が空で、 &lt;code&gt;$@&lt;/code&gt; に &lt;code&gt;PROPAGATE&lt;/code&gt; メソッドを持つオブジェクト参照が含まれている場合、そのメソッドは追加のファイルおよび行番号パラメーターを指定して呼び出されます。戻り値は &lt;code&gt;$@&lt;/code&gt; 値を置き換えます。つまり、 &lt;code&gt;$@ = &lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; 呼ばれた。</target>
        </trans-unit>
        <trans-unit id="a97492155e7589378bb301645dfa7c34b680ef04" translate="yes" xml:space="preserve">
          <source>If the output is empty and &lt;code&gt;$@&lt;/code&gt; contains an object reference that has a &lt;code&gt;PROPAGATE&lt;/code&gt; method, that method will be called with additional file and line number parameters. The return value replaces the value in &lt;code&gt;$@&lt;/code&gt; ; i.e., as if &lt;code&gt;$@ = &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; were called.</source>
          <target state="translated">出力が空で、 &lt;code&gt;$@&lt;/code&gt; に &lt;code&gt;PROPAGATE&lt;/code&gt; メソッドを持つオブジェクト参照が含まれている場合、そのメソッドは追加のファイルおよび行番号パラメーターを指定して呼び出されます。戻り値は &lt;code&gt;$@&lt;/code&gt; 値を置き換えます。つまり、 &lt;code&gt;$@ = &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; { $@-&amp;gt;PROPAGATE(__FILE__, __LINE__) };&lt;/code&gt; 呼ばれた。</target>
        </trans-unit>
        <trans-unit id="4e71a254b15b38644afabad82376b2bb1e4f7fab" translate="yes" xml:space="preserve">
          <source>If the output of the &lt;code&gt;h h&lt;/code&gt; command (or any command, for that matter) scrolls past your screen, precede the command with a leading pipe symbol so that it's run through your pager, as in</source>
          <target state="translated">次のように、 &lt;code&gt;h h&lt;/code&gt; コマンド（または、任意のコマンド）の出力が画面を超えてスクロールする場合は、コマンドの前に先頭のパイプ記号を付けて、ポケットベルで実行されるようにします。</target>
        </trans-unit>
        <trans-unit id="f7911c6fed712fb085afb893540153d04c3ba2b2" translate="yes" xml:space="preserve">
          <source>If the package has a mailing list, include a URL or subscription instructions here.</source>
          <target state="translated">パッケージにメーリングリストがある場合は、ここにURLや購読方法を記載してください。</target>
        </trans-unit>
        <trans-unit id="2bd5efd382acc87571dd747451ad45f157dd85d7" translate="yes" xml:space="preserve">
          <source>If the package has a web site, include a URL here.</source>
          <target state="translated">パッケージにWebサイトがある場合は、ここにURLを記載してください。</target>
        </trans-unit>
        <trans-unit id="128d72462f8fdf7586cd07b73dc9169d6e753911" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, &lt;code&gt;U+FFFE&lt;/code&gt; has a minimal primary weight. The comparison between &lt;code&gt;&quot;$a1\x{FFFE}$a2&quot;&lt;/code&gt; and &lt;code&gt;&quot;$b1\x{FFFE}$b2&quot;&lt;/code&gt; first compares &lt;code&gt;$a1&lt;/code&gt; and &lt;code&gt;$b1&lt;/code&gt; at level 1, and then &lt;code&gt;$a2&lt;/code&gt; and &lt;code&gt;$b2&lt;/code&gt; at level 1, as followed.</source>
          <target state="translated">パラメータがtrueに設定されている場合、 &lt;code&gt;U+FFFE&lt;/code&gt; は最小のプライマリウェイトを持ちます。比較 &lt;code&gt;&quot;$a1\x{FFFE}$a2&quot;&lt;/code&gt; 及び &lt;code&gt;&quot;$b1\x{FFFE}$b2&quot;&lt;/code&gt; 最初の比較 &lt;code&gt;$a1&lt;/code&gt; と &lt;code&gt;$b1&lt;/code&gt; レベル1で、次に &lt;code&gt;$a2&lt;/code&gt; と &lt;code&gt;$b2&lt;/code&gt; レベル1には以下のように、 。</target>
        </trans-unit>
        <trans-unit id="c1bc1d540aa212d81d3c27835031fe5adbb0eee1" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, &lt;code&gt;U+FFFF&lt;/code&gt; has a highest primary weight. When a boolean of &lt;code&gt;$coll-&amp;gt;ge($str, &quot;abc&quot;)&lt;/code&gt; and &lt;code&gt;$coll-&amp;gt;le($str, &quot;abc\x{FFFF}&quot;)&lt;/code&gt; is true, it is expected that &lt;code&gt;$str&lt;/code&gt; begins with &lt;code&gt;&quot;abc&quot;&lt;/code&gt; , or another primary equivalent. &lt;code&gt;$str&lt;/code&gt; may be &lt;code&gt;&quot;abcd&quot;&lt;/code&gt; , &lt;code&gt;&quot;abc012&quot;&lt;/code&gt; , but should not include &lt;code&gt;U+FFFF&lt;/code&gt; such as &lt;code&gt;&quot;abc\x{FFFF}xyz&quot;&lt;/code&gt; .</source>
          <target state="translated">パラメータがtrueに設定されている場合、 &lt;code&gt;U+FFFF&lt;/code&gt; が最も高いプライマリウェイトになります。 &lt;code&gt;$coll-&amp;gt;ge($str, &quot;abc&quot;)&lt;/code&gt; および &lt;code&gt;$coll-&amp;gt;le($str, &quot;abc\x{FFFF}&quot;)&lt;/code&gt; ブール値がtrueの場合、 &lt;code&gt;$str&lt;/code&gt; が &lt;code&gt;&quot;abc&quot;&lt;/code&gt; で始まることが期待されます、または別の主要な同等物。 &lt;code&gt;$str&lt;/code&gt; は &lt;code&gt;&quot;abcd&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;abc012&quot;&lt;/code&gt; の場合がありますが、 &lt;code&gt;&quot;abc\x{FFFF}xyz&quot;&lt;/code&gt; などの &lt;code&gt;U+FFFF&lt;/code&gt; を含めることはできません。</target>
        </trans-unit>
        <trans-unit id="bd592631134dd93dfb6509b2405e1e6bdddd05d2" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, &lt;code&gt;U+FFFF&lt;/code&gt; has a highest primary weight. When a boolean of &lt;code&gt;$coll-&amp;gt;ge($str, &quot;abc&quot;)&lt;/code&gt; and &lt;code&gt;$coll-&amp;gt;le($str, &quot;abc\x{FFFF}&quot;)&lt;/code&gt; is true, it is expected that &lt;code&gt;$str&lt;/code&gt; begins with &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, or another primary equivalent. &lt;code&gt;$str&lt;/code&gt; may be &lt;code&gt;&quot;abcd&quot;&lt;/code&gt;, &lt;code&gt;&quot;abc012&quot;&lt;/code&gt;, but should not include &lt;code&gt;U+FFFF&lt;/code&gt; such as &lt;code&gt;&quot;abc\x{FFFF}xyz&quot;&lt;/code&gt;.</source>
          <target state="translated">パラメータをtrueにすると、 &lt;code&gt;U+FFFF&lt;/code&gt; のプライマリウェイトが最大になります。 &lt;code&gt;$coll-&amp;gt;ge($str, &quot;abc&quot;)&lt;/code&gt; および &lt;code&gt;$coll-&amp;gt;le($str, &quot;abc\x{FFFF}&quot;)&lt;/code&gt; ブール値が真の場合、 &lt;code&gt;$str&lt;/code&gt; は &lt;code&gt;&quot;abc&quot;&lt;/code&gt; で始まると予想されます。、または別の主要な同等物。 &lt;code&gt;$str&lt;/code&gt; は &lt;code&gt;&quot;abcd&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;abc012&quot;&lt;/code&gt; の場合がありますが、 &lt;code&gt;&quot;abc\x{FFFF}xyz&quot;&lt;/code&gt; などの &lt;code&gt;U+FFFF&lt;/code&gt; を含めることはできません。</target>
        </trans-unit>
        <trans-unit id="2379a678967ce11b206cce9256eec402c626744e" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, a final, tie-breaking level is used. If no difference of weights is found after the comparison through all the level specified by &lt;code&gt;level&lt;/code&gt; , the comparison with code points will be performed. For the tie-breaking comparison, the sort key has code points of the original string appended. Completely ignorable characters are not ignored.</source>
          <target state="translated">パラメータをtrueにすると、最終的なタイブレークレベルが使用されます。重みの差がで指定されたすべてのレベルを介して比較した後に検出されない場合 &lt;code&gt;level&lt;/code&gt; 、コードポイントとの比較が行われます。タイブレークの比較のために、並べ替えキーには、元の文字列のコードポイントが追加されています。完全に無視できる文字は無視されません。</target>
        </trans-unit>
        <trans-unit id="cf3801fdcc987b0c168aed25eff11116ed2d9d13" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, a final, tie-breaking level is used. If no difference of weights is found after the comparison through all the level specified by &lt;code&gt;level&lt;/code&gt;, the comparison with code points will be performed. For the tie-breaking comparison, the sort key has code points of the original string appended. Completely ignorable characters are not ignored.</source>
          <target state="translated">パラメータがtrueにされると、最終的なタイブレークレベルが使用されます。重みの差がで指定されたすべてのレベルを介して比較した後に検出されない場合 &lt;code&gt;level&lt;/code&gt; 、コードポイントとの比較が行われます。タイブレーク比較のために、ソートキーには元の文字列のコードポイントが追加されています。完全に無視できる文字は無視されません。</target>
        </trans-unit>
        <trans-unit id="e6d70ed0cf4279c5cf91d7d6890341737c51d4df" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, accents (and other primary ignorable characters) are ignored, even though cases are taken into account.</source>
          <target state="translated">このパラメータを true にすると、アクセント(およびその他の主要な無視可能な文字)は、ケースは考慮されますが無視されます。</target>
        </trans-unit>
        <trans-unit id="3ffce08d047eaee75c853cd8ab3be63e13efe5a7" translate="yes" xml:space="preserve">
          <source>If the parameter is made true, for a contraction with three or more characters (here nicknamed &quot;long contraction&quot;), initial substrings will be handled. For example, a contraction ABC, where A is a starter, and B and C are non-starters (character with non-zero combining character class), will be detected even if there is not AB as a contraction.</source>
          <target state="translated">このパラメータを真にすると、3文字以上の縮約(ここでは「長い縮約」と呼ばれています)では、初期部分文字列が処理されます。例えば、Aがスターターで、BとCが非スターター(結合文字クラスが0でない文字)である縮約ABCは、縮約としてABがなくても検出されます。</target>
        </trans-unit>
        <trans-unit id="6196ed90d85a5642d1f2bff307d9850731d3ee76" translate="yes" xml:space="preserve">
          <source>If the parameters to the INCLUDE: keyword are followed by a pipe (&lt;code&gt;|&lt;/code&gt;) then the compiler will interpret the parameters as a command. This feature is mildly deprecated in favour of the &lt;code&gt;INCLUDE_COMMAND:&lt;/code&gt; directive, as documented below.</source>
          <target state="translated">INCLUDE：キーワードへのパラメーターの後にパイプ（ &lt;code&gt;|&lt;/code&gt; ）が続く場合、コンパイラーはパラメーターをコマンドとして解釈します。以下に記載されているように、この機能は &lt;code&gt;INCLUDE_COMMAND:&lt;/code&gt; ディレクティブを支持して、やや廃止予定です。</target>
        </trans-unit>
        <trans-unit id="60984150a4a273c37051fdd1024089806a686df1" translate="yes" xml:space="preserve">
          <source>If the parent process is killed (either using Perl's kill() builtin, or using some external means) all the pseudo-processes are killed as well, and the whole process exits.</source>
          <target state="translated">親プロセスが kill されると (Perl の kill()ビルトインを使用するか、外部の手段を使用するかのいずれか)すべての疑似プロセスも同様に kill され、プロセス全体が終了します。</target>
        </trans-unit>
        <trans-unit id="aa64f5b5dc3063c1ec88bf3714d6a78f8885563e" translate="yes" xml:space="preserve">
          <source>If the pattern contains embedded code, such as</source>
          <target state="translated">パターンに以下のような埋め込みコードが含まれている場合</target>
        </trans-unit>
        <trans-unit id="c8e637c05d0476b3ff64dcc72c39f7a79e3a588a" translate="yes" xml:space="preserve">
          <source>If the pattern contains its delimiter within it, that delimiter must be escaped. Prefixing it with a backslash (</source>
          <target state="translated">パターンの中に区切り文字が含まれている場合は、その区切り文字をエスケープする必要があります。バックスラッシュ (</target>
        </trans-unit>
        <trans-unit id="400ab285c2500104132be9cd3fcc1a752df8a4f5" translate="yes" xml:space="preserve">
          <source>If the pattern does not match any pathname, then bsd_glob() returns a list consisting of only the pattern. If &lt;code&gt;GLOB_QUOTE&lt;/code&gt; is set, its effect is present in the pattern returned.</source>
          <target state="translated">パターンがどのパス名とも一致しない場合、bsd_glob（）はパターンのみで構成されるリストを返します。 &lt;code&gt;GLOB_QUOTE&lt;/code&gt; が設定されている場合、その効果は返されるパターンに存在します。</target>
        </trans-unit>
        <trans-unit id="6adde583f90fd2399e3928b4e6217841c09c97fb" translate="yes" xml:space="preserve">
          <source>If the pattern may match only at a handful of places, with &lt;code&gt;TYPE&lt;/code&gt; being &lt;code&gt;SBOL&lt;/code&gt; , &lt;code&gt;MBOL&lt;/code&gt; , or &lt;code&gt;GPOS&lt;/code&gt; . See the table below.</source>
          <target state="translated">&lt;code&gt;TYPE&lt;/code&gt; が &lt;code&gt;SBOL&lt;/code&gt; 、 &lt;code&gt;MBOL&lt;/code&gt; 、または &lt;code&gt;GPOS&lt;/code&gt; で、パターンが少数の場所でのみ一致する場合。下の表を参照してください。</target>
        </trans-unit>
        <trans-unit id="40469f0b5b6e999f3b3f0091f7983d3535304a67" translate="yes" xml:space="preserve">
          <source>If the pattern may match only at a handful of places, with &lt;code&gt;TYPE&lt;/code&gt; being &lt;code&gt;SBOL&lt;/code&gt;, &lt;code&gt;MBOL&lt;/code&gt;, or &lt;code&gt;GPOS&lt;/code&gt;. See the table below.</source>
          <target state="translated">パターンが少数の場所でのみ一致する可能性がある場合、 &lt;code&gt;TYPE&lt;/code&gt; は &lt;code&gt;SBOL&lt;/code&gt; 、 &lt;code&gt;MBOL&lt;/code&gt; 、または &lt;code&gt;GPOS&lt;/code&gt; です。以下の表を参照してください。</target>
        </trans-unit>
        <trans-unit id="d0ce5cbb841f39a51912df72d9768f6a6a5fae33" translate="yes" xml:space="preserve">
          <source>If the pattern was used as follows</source>
          <target state="translated">以下のようにパターンが使われていた場合</target>
        </trans-unit>
        <trans-unit id="2dd05fadef47c4bd45462fdfaa94e04afc77ad22" translate="yes" xml:space="preserve">
          <source>If the performance in such cases is unacceptable, you may defer the actual writing, and then have it done all at once. The following loop will perform much better for large files:</source>
          <target state="translated">このような場合の性能が許容できない場合は、実際の書き込みを先延ばしにして、一気に書き込んでもらうこともできます。大きなファイルの場合は、以下のようなループの方がパフォーマンスが良くなります。</target>
        </trans-unit>
        <trans-unit id="956656b1b2d0c77e2fbe4d0d92677dc48070a8ed" translate="yes" xml:space="preserve">
          <source>If the platform is MS-DOS like and normally does CRLF to &quot;\n&quot; translation for text files then the default layers are :</source>
          <target state="translated">プラットフォームがMS-DOSのようなもので、テキストファイルのためにCRLFを&quot;\n &quot;翻訳するのが普通の場合、デフォルトのレイヤーは.</target>
        </trans-unit>
        <trans-unit id="5f1c5a6b0ba8f7ba98047b8fb60cfdcca7e45034" translate="yes" xml:space="preserve">
          <source>If the platform is MS-DOS like and normally does CRLF to &quot;\n&quot; translation for text files then the default layers are:</source>
          <target state="translated">プラットフォームがMS-DOSのようなもので、テキストファイルのためにCRLFから&quot;\n &quot;翻訳を通常行う場合、デフォルトのレイヤーは次のようになります。</target>
        </trans-unit>
        <trans-unit id="fee788dad0c5b1cd15e2fa5ddb122d4f9bd910af" translate="yes" xml:space="preserve">
          <source>If the platform supports the &lt;code&gt;langinfo(CODESET)&lt;/code&gt; interface, the codeset returned is used as the default encoding for the open pragma.</source>
          <target state="translated">プラットフォームが &lt;code&gt;langinfo(CODESET)&lt;/code&gt; インターフェースをサポートしている場合、返されたコードセットがopenプラグマのデフォルトのエンコーディングとして使用されます。</target>
        </trans-unit>
        <trans-unit id="e029b7bfe44b40ce79cdafd38dd9f57646af8f39" translate="yes" xml:space="preserve">
          <source>If the program exits without all threads having either been joined or detached, then a warning will be issued.</source>
          <target state="translated">すべてのスレッドが結合されていないか切り離されていない状態でプログラムが終了すると、警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="68122aab68b9511758161a833aab14bd7cf8f3f4" translate="yes" xml:space="preserve">
          <source>If the program exits without all threads having either been joined or detached, then this warning will be issued.</source>
          <target state="translated">すべてのスレッドが結合されていないか切り離されていない状態でプログラムが終了した場合、この警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="3f05e0c9adcc7343a41a8d24201ee4c19ce64a54" translate="yes" xml:space="preserve">
          <source>If the program has been given to perl via the switches &lt;code&gt;-e&lt;/code&gt; or &lt;code&gt;-E&lt;/code&gt; , &lt;code&gt;$0&lt;/code&gt; will contain the string &lt;code&gt;&quot;-e&quot;&lt;/code&gt; .</source>
          <target state="translated">プログラムがスイッチ &lt;code&gt;-e&lt;/code&gt; または &lt;code&gt;-E&lt;/code&gt; を介してperlに与えられている場合、 &lt;code&gt;$0&lt;/code&gt; には文字列 &lt;code&gt;&quot;-e&quot;&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="7b296afa5e8ade3ba3ac78a9d465e171ac5067f8" translate="yes" xml:space="preserve">
          <source>If the program has been given to perl via the switches &lt;code&gt;-e&lt;/code&gt; or &lt;code&gt;-E&lt;/code&gt;, &lt;code&gt;$0&lt;/code&gt; will contain the string &lt;code&gt;&quot;-e&quot;&lt;/code&gt;.</source>
          <target state="translated">プログラムがスイッチ &lt;code&gt;-e&lt;/code&gt; または &lt;code&gt;-E&lt;/code&gt; を介してperlに渡された場合、 &lt;code&gt;$0&lt;/code&gt; には文字列 &lt;code&gt;&quot;-e&quot;&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="187d3c3b9917db708f6b4997f1f577493d56ad38" translate="yes" xml:space="preserve">
          <source>If the program is syntactically correct, it is executed. If the program runs off the end without hitting an exit() or die() operator, an implicit &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(0)&lt;/a&gt;&lt;/code&gt; is provided to indicate successful completion.</source>
          <target state="translated">プログラムが構文的に正しい場合は、それが実行されます。プログラムがexit（）またはdie（）オペレーターにヒットすることなく最後まで実行した場合、正常終了を示す暗黙の &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit(0)&lt;/a&gt;&lt;/code&gt; が提供されます。</target>
        </trans-unit>
        <trans-unit id="c7da837d3689d8811d08d5a2ade1a1a152e04568" translate="yes" xml:space="preserve">
          <source>If the program is syntactically correct, it is executed. If the program runs off the end without hitting an exit() or die() operator, an implicit &lt;code&gt;exit(0)&lt;/code&gt; is provided to indicate successful completion.</source>
          <target state="translated">プログラムが構文的に正しい場合、それは実行されます。プログラムがexit（）またはdie（）演算子をヒットせずに最後から実行された場合、正常に完了したことを示すために暗黙の &lt;code&gt;exit(0)&lt;/code&gt; が提供されます。</target>
        </trans-unit>
        <trans-unit id="8cf82d5604429bbfe1cb41298b645fa1f014e9ae" translate="yes" xml:space="preserve">
          <source>If the property doesn't have such a restricted set, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">プロパティにそのような制限されたセットがない場合、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="f561839327dfb379f3ced83b14775ceeeefed09a" translate="yes" xml:space="preserve">
          <source>If the property doesn't have such a restricted set, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">プロパティにそのような制限されたセットがない場合、 &lt;code&gt;undef&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="f736ee647a4d5e1589838b72f5b05af7545714ad" translate="yes" xml:space="preserve">
          <source>If the property name is unknown, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned. Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt; &quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt; . This function does not recognize those in the property parameter, returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">プロパティ名が不明の場合、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。Perlは通常、正規表現のプロパティ名を認識し、オプションの &lt;code&gt;&quot;Is_&lt;/code&gt; &quot;（アンダースコアあり、またはアンダースコアなし）を &lt;code&gt;\p{isgc=punct}&lt;/code&gt; などのように接頭辞として付けます。この関数は、プロパティパラメータ内のものを認識せず、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="c8e6c1687e04cb1c576cc3de9ba670b370bee76a" translate="yes" xml:space="preserve">
          <source>If the property name is unknown, &lt;code&gt;undef&lt;/code&gt; is returned. Note that Perl typically recognizes property names in regular expressions with an optional &lt;code&gt;&quot;Is_&lt;/code&gt;&quot; (with or without the underscore) prefixed to them, such as &lt;code&gt;\p{isgc=punct}&lt;/code&gt;. This function does not recognize those in the property parameter, returning &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">プロパティ名が不明な場合は、 &lt;code&gt;undef&lt;/code&gt; が返されます。Perlは通常、 &lt;code&gt;\p{isgc=punct}&lt;/code&gt; ように、接頭辞としてオプションの &lt;code&gt;&quot;Is_&lt;/code&gt; 」（アンダースコアの有無にかかわらず）が付いた正規表現のプロパティ名を認識することに注意してください。この関数はpropertyパラメーター内のものを認識せず、 &lt;code&gt;undef&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="afaf0816b79f3c9b4d1b468e6b1d9a01691cd781" translate="yes" xml:space="preserve">
          <source>If the protocol is set to &quot;tcp&quot;, this method may be called any number of times, and each call to the ping() method (below) will use the most recent $local_addr. If the protocol is &quot;icmp&quot; or &quot;udp&quot;, then bind() must be called at most once per object, and (if it is called at all) must be called before the first call to ping() for that object.</source>
          <target state="translated">プロトコルが &quot;tcp&quot; に設定されている場合は、このメソッドを何度でも呼び出すことができ、 ping()メソッド (以下)をコールするたびに最新の $local_addr を使用します。プロトコルが &quot;icmp&quot; あるいは &quot;udp&quot; の場合は、 bind()はオブジェクトごとに最大でも一度は呼ばれなければなりませんし、 (呼ばれた場合は)そのオブジェクトの最初の ping()の呼び出しの前に呼ばれなければなりません。</target>
        </trans-unit>
        <trans-unit id="bd278d79ed04376a1ab23bc38f3813d0d8a95858" translate="yes" xml:space="preserve">
          <source>If the prototypes are enabled, you can disable it locally for a given XSUB as in the following example:</source>
          <target state="translated">プロトタイプが有効になっている場合、以下の例のように、指定されたXSUBに対してローカルで無効にすることができます。</target>
        </trans-unit>
        <trans-unit id="22222d2992db775cc93f4e6df7a745c81e01a6be" translate="yes" xml:space="preserve">
          <source>If the referenced object has been blessed into a package, then that package name is returned instead. But don't use that, as it's now considered &quot;bad practice&quot;. For one reason, an object could be using a class called &lt;code&gt;Regexp&lt;/code&gt; or &lt;code&gt;IO&lt;/code&gt; , or even &lt;code&gt;HASH&lt;/code&gt; . Also, &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; doesn't take into account subclasses, like &lt;code&gt;isa&lt;/code&gt; does.</source>
          <target state="translated">参照されるオブジェクトがパッケージにblessされている場合、代わりにそのパッケージ名が返されます。しかし、これは「悪い習慣」と見なされているため、使用しないでください。1つの理由で、オブジェクトは &lt;code&gt;Regexp&lt;/code&gt; または &lt;code&gt;IO&lt;/code&gt; または &lt;code&gt;HASH&lt;/code&gt; と呼ばれるクラスを使用している可能性があります。また、 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;isa&lt;/code&gt; のようにサブクラスを考慮しません。</target>
        </trans-unit>
        <trans-unit id="cf268542a8929b7e398cc1536659093d140d5216" translate="yes" xml:space="preserve">
          <source>If the referenced object has been blessed into a package, then that package name is returned instead. But don't use that, as it's now considered &quot;bad practice&quot;. For one reason, an object could be using a class called &lt;code&gt;Regexp&lt;/code&gt; or &lt;code&gt;IO&lt;/code&gt; , or even &lt;code&gt;HASH&lt;/code&gt; . Also, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; doesn't take into account subclasses, like &lt;code&gt;isa&lt;/code&gt; does.</source>
          <target state="translated">参照されるオブジェクトがパッケージにblessされている場合、代わりにそのパッケージ名が返されます。しかし、これは「悪い習慣」と見なされているため、使用しないでください。1つの理由で、オブジェクトは &lt;code&gt;Regexp&lt;/code&gt; または &lt;code&gt;IO&lt;/code&gt; または &lt;code&gt;HASH&lt;/code&gt; と呼ばれるクラスを使用している可能性があります。また、 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;isa&lt;/code&gt; のようにサブクラスを考慮しません。</target>
        </trans-unit>
        <trans-unit id="09e68bc71ae659a158de263698e821903752a759" translate="yes" xml:space="preserve">
          <source>If the referred library is an archive library, then it is treated as a simple collection of .o modules (all of which must contain PIC). These modules are then linked into the shared library.</source>
          <target state="translated">参照するライブラリがアーカイブライブラリの場合は、.oモジュールの単純なコレクションとして扱われます(すべてPICを含む必要があります)。これらのモジュールは、共有ライブラリにリンクされます。</target>
        </trans-unit>
        <trans-unit id="487c69f3c32cf6208263be856047bd1120b5cb11" translate="yes" xml:space="preserve">
          <source>If the regex engine was entered, the output may look like this:</source>
          <target state="translated">正規表現エンジンが入力されている場合、出力は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="4071da6362bfae97335d6ccd04527e0675ca1ecf" translate="yes" xml:space="preserve">
          <source>If the remote server sends data a byte at time, and you need that data immediately without waiting for a newline (which might not happen), you may wish to replace the &lt;code&gt;while&lt;/code&gt; loop in the parent with the following:</source>
          <target state="translated">リモートサーバーが一度に1バイトずつデータを送信し、改行を待たずにすぐにそのデータが必要な場合（これは発生しない場合があります）、親の &lt;code&gt;while&lt;/code&gt; ループを次のように置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="78e886a06c0d6c64ae06980c39f4979b0d06c657" translate="yes" xml:space="preserve">
          <source>If the repeat count is &lt;code&gt;*&lt;/code&gt; , the offset is relative to the start of the packed string.</source>
          <target state="translated">繰り返し数が &lt;code&gt;*&lt;/code&gt; の場合、オフセットはパックされた文字列の先頭を基準にしています。</target>
        </trans-unit>
        <trans-unit id="0c6d8ab738d17a47ddcc7210024698f2d723ba66" translate="yes" xml:space="preserve">
          <source>If the repeat count is &lt;code&gt;*&lt;/code&gt;, the offset is relative to the start of the packed string.</source>
          <target state="translated">繰り返し回数が &lt;code&gt;*&lt;/code&gt; の場合、オフセットはパックされた文字列の先頭を基準にしています。</target>
        </trans-unit>
        <trans-unit id="71535d2706781140ebf79d95c5c1eb0328f89697" translate="yes" xml:space="preserve">
          <source>If the repeat count is &lt;code&gt;0&lt;/code&gt; , it's relative to the current position.</source>
          <target state="translated">繰り返し回数が &lt;code&gt;0&lt;/code&gt; の場合、現在の位置を基準にしています。</target>
        </trans-unit>
        <trans-unit id="8bb595e18165255d40d28696ced7cb987361acca" translate="yes" xml:space="preserve">
          <source>If the repeat count is &lt;code&gt;0&lt;/code&gt;, it's relative to the current position.</source>
          <target state="translated">繰り返し回数が &lt;code&gt;0&lt;/code&gt; の場合、現在の位置を基準にしています。</target>
        </trans-unit>
        <trans-unit id="adddd684b7b4b320c5c6cd3d4e144f8d42b00be2" translate="yes" xml:space="preserve">
          <source>If the requested class doesn't yet exist, this function will still succeed, and return &lt;code&gt;[ $classname ]&lt;/code&gt;</source>
          <target state="translated">要求されたクラスがまだ存在しない場合でも、この関数は成功し、 &lt;code&gt;[ $classname ]&lt;/code&gt; を返します</target>
        </trans-unit>
        <trans-unit id="f3c8df40676c5ef413c4d428cc8bce1edd4a74be" translate="yes" xml:space="preserve">
          <source>If the required version is older than Perl 5.10, the &quot;:default&quot; feature bundle is automatically loaded instead.</source>
          <target state="translated">必要なバージョンがPerl 5.10よりも古い場合は、&quot;:default &quot;機能バンドルが自動的にロードされます。</target>
        </trans-unit>
        <trans-unit id="d407bfa98e92001cef51aaea080c36419318c881" translate="yes" xml:space="preserve">
          <source>If the result is a fraction, it is converted into a floating point number to the accuracy of your platform.</source>
          <target state="translated">結果が分数の場合は、プラットフォームの精度に合わせて浮動小数点数に変換されます。</target>
        </trans-unit>
        <trans-unit id="a0f32bf4dd5015a300ddb6707d47fae5eba9e46c" translate="yes" xml:space="preserve">
          <source>If the result is multiple script names, they are returned joined into a single comma-separated string.</source>
          <target state="translated">結果が複数のスクリプト名の場合は、それらをカンマで区切られた単一の文字列に結合して返されます。</target>
        </trans-unit>
        <trans-unit id="45ec7fbff805996e6714524f94283d541160e6c3" translate="yes" xml:space="preserve">
          <source>If the return type of the XSUB includes &lt;code&gt;static&lt;/code&gt; , the method is considered to be a static method. It will call the C++ function using the class::method() syntax. If the method is not static the function will be called using the THIS-&amp;gt;method() syntax.</source>
          <target state="translated">XSUBの戻り型に &lt;code&gt;static&lt;/code&gt; が含まれている場合、メソッドは静的メソッドと見なされます。これは、class :: method（）構文を使用してC ++関数を呼び出します。メソッドが静的でない場合、関数はTHIS-&amp;gt; method（）構文を使用して呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b467c0c1883d9fa2c1ada74a10e9d69505846ac1" translate="yes" xml:space="preserve">
          <source>If the return type of the XSUB includes &lt;code&gt;static&lt;/code&gt;, the method is considered to be a static method. It will call the C++ function using the class::method() syntax. If the method is not static the function will be called using the THIS-&amp;gt;method() syntax.</source>
          <target state="translated">XSUBの戻り値の型に &lt;code&gt;static&lt;/code&gt; が含まれている場合、そのメソッドは静的メソッドと見なされます。class :: method（）構文を使用してC ++関数を呼び出します。メソッドが静的でない場合、関数はTHIS-&amp;gt; method（）構文を使用して呼び出されます。</target>
        </trans-unit>
        <trans-unit id="0b11488412f3e860557eb1891af20655d0de0fe4" translate="yes" xml:space="preserve">
          <source>If the return value of reval() is (or contains) any code reference, those code references are wrapped to be themselves executed always in the compartment. See &lt;a href=&quot;#wrap_code_refs_within&quot;&gt;&quot;wrap_code_refs_within&quot;&lt;/a&gt;.</source>
          <target state="translated">reval（）の戻り値がコード参照である（または含まれている）場合、それらのコード参照はラップされ、常にコンパートメントで実行されます。&lt;a href=&quot;#wrap_code_refs_within&quot;&gt;「wrap_code_refs_within」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="95ff7ce638cb043eea1113e455241d4090a0ba15" translate="yes" xml:space="preserve">
          <source>If the return value of reval() is (or contains) any code reference, those code references are wrapped to be themselves executed always in the compartment. See &lt;a href=&quot;#wrap_code_refs_within&quot;&gt;wrap_code_refs_within&lt;/a&gt;.</source>
          <target state="translated">reval（）の戻り値がコード参照である（または含まれている）場合、それらのコード参照は、コンパートメント内で常に実行されるようにラップされます。&lt;a href=&quot;#wrap_code_refs_within&quot;&gt;wrap_code_refs_withinを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9b5b2e1517f57a24f52793e2d523bf3e3916b624" translate="yes" xml:space="preserve">
          <source>If the revision (previously &quot;tracking version&quot;) number of UCA is given, behavior of that revision is emulated on collating. If omitted, the return value of &lt;code&gt;UCA_Version()&lt;/code&gt; is used.</source>
          <target state="translated">UCAのリビジョン（以前の「トラッキングバージョン」）番号が指定されている場合、照合時にそのリビジョンの動作がエミュレートされます。省略した場合、 &lt;code&gt;UCA_Version()&lt;/code&gt; の戻り値が使用されます。</target>
        </trans-unit>
        <trans-unit id="1a7a3bfd506eaa3a5969fb39449cbd90048c5cd5" translate="yes" xml:space="preserve">
          <source>If the right argument is an expression rather than a search pattern, substitution, or transliteration, it is interpreted as a search pattern at run time. Note that this means that its contents will be interpolated twice, so</source>
          <target state="translated">右の引数が検索パターン、置換、音訳ではなく式である場合、実行時には検索パターンとして解釈されます。これは、その内容が2回補間されることを意味することに注意してください。</target>
        </trans-unit>
        <trans-unit id="397d47eee4fc1ac1405170a336868a5dec199f77" translate="yes" xml:space="preserve">
          <source>If the same C type is used in several different contexts which require different translations, &lt;code&gt;typedef&lt;/code&gt; several new types mapped to this C type, and create separate</source>
          <target state="translated">同じCタイプが、異なる変換を必要とするいくつかの異なるコンテキストで使用されている場合、 &lt;code&gt;typedef&lt;/code&gt; はこのCタイプにマップされたいくつかの新しいタイプを作成し、個別に</target>
        </trans-unit>
        <trans-unit id="456756c29fcce7da570891f767727aa9e1c8ea70" translate="yes" xml:space="preserve">
          <source>If the same character (or a sequence of characters) exists in the collation element table through &lt;code&gt;table&lt;/code&gt; , mapping to collation elements is overridden. If it does not exist, the mapping is defined additionally.</source>
          <target state="translated">同一の文字（または文字列）を介して照合要素テーブルに存在する場合 &lt;code&gt;table&lt;/code&gt; 、照合要素へのマッピングが上書きされます。存在しない場合は、マッピングが追加で定義されます。</target>
        </trans-unit>
        <trans-unit id="e4dde7b413bfb31794120513bb19ebe90728fd10" translate="yes" xml:space="preserve">
          <source>If the same character (or a sequence of characters) exists in the collation element table through &lt;code&gt;table&lt;/code&gt;, mapping to collation elements is overridden. If it does not exist, the mapping is defined additionally.</source>
          <target state="translated">同一の文字（または文字列）を介して照合要素テーブルに存在する場合 &lt;code&gt;table&lt;/code&gt; 、照合要素へのマッピングが上書きされます。存在しない場合は、マッピングが追加で定義されます。</target>
        </trans-unit>
        <trans-unit id="250b229660b09d1a93cecb0077c43fdb021bc44f" translate="yes" xml:space="preserve">
          <source>If the scalar contains a number the raw SV will be leaner.</source>
          <target state="translated">スカラーに数値が含まれている場合、生のSVはよりリーンになります。</target>
        </trans-unit>
        <trans-unit id="129cba7aa8d1059953f619ec45963493064daafb" translate="yes" xml:space="preserve">
          <source>If the scalar from the previous example had an extra reference:</source>
          <target state="translated">前の例のスカラが余分な参照を持っていた場合。</target>
        </trans-unit>
        <trans-unit id="942a6cfe1787a0e79c2fbf6e9025269b48593e53" translate="yes" xml:space="preserve">
          <source>If the script says that your package is incomplete, and asks whether to continue, just answer with Y (this can only happen if you don't use long filenames or forget to issue &quot;set FNCASE=y&quot; first).</source>
          <target state="translated">スクリプトがパッケージが不完全であると言って、続けるかどうかを尋ねてきたら、Y で答えてください (長いファイル名を使っていなかったり、最初に &quot;set FNCASE=y&quot; を発行するのを忘れていたりした場合にのみ起こりえます)。</target>
        </trans-unit>
        <trans-unit id="1ebc636a0a5f78fe0991b4d30678c7a47413c67b" translate="yes" xml:space="preserve">
          <source>If the second argument to a piped &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; contains shell metacharacters, perl &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;s, then &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;s a shell to decode the metacharacters and eventually run the desired program. If the program couldn't be run, it's the shell that gets the message, not Perl. All your Perl program can find out is whether the shell itself could be successfully started. You can still capture the shell's STDERR and check it for error messages. See &lt;a href=&quot;#How-can-I-capture-STDERR-from-an-external-command%3f&quot;&gt;How can I capture STDERR from an external command?&lt;/a&gt; elsewhere in this document, or use the &lt;a href=&quot;ipc/open3&quot;&gt;IPC::Open3&lt;/a&gt; module.</source>
          <target state="translated">第2引数は、パイプ場合 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; のPerl、シェルメタキャラクタを含ん &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; Sは、 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; メタキャラクタをデコードし、最終的に所望のプログラムを実行するために、SAシェル。プログラムを実行できなかった場合、メッセージを受け取るのはPerlではなくシェルです。 Perlプログラムが見つけることができるのは、シェル自体が正常に起動できるかどうかだけです。シェルのSTDERRをキャプチャして、エラーメッセージを確認できます。&lt;a href=&quot;#How-can-I-capture-STDERR-from-an-external-command%3f&quot;&gt;外部コマンドからSTDERRをキャプチャするに&lt;/a&gt;はどうすればよいですか？を参照してください。このドキュメントの他の場所、または&lt;a href=&quot;ipc/open3&quot;&gt;IPC :: Open3&lt;/a&gt;モジュールを使用します。</target>
        </trans-unit>
        <trans-unit id="4c86f791ed05e6400ffb0303d6157f674dcf38a9" translate="yes" xml:space="preserve">
          <source>If the second argument to a piped &lt;code&gt;open()&lt;/code&gt; contains shell metacharacters, perl &lt;code&gt;fork()&lt;/code&gt;s, then &lt;code&gt;exec()&lt;/code&gt;s a shell to decode the metacharacters and eventually run the desired program. If the program couldn't be run, it's the shell that gets the message, not Perl. All your Perl program can find out is whether the shell itself could be successfully started. You can still capture the shell's STDERR and check it for error messages. See &lt;a href=&quot;#How-can-I-capture-STDERR-from-an-external-command%3F&quot;&gt;&quot;How can I capture STDERR from an external command?&quot;&lt;/a&gt; elsewhere in this document, or use the &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt; module.</source>
          <target state="translated">パイプさ &lt;code&gt;open()&lt;/code&gt; の2番目の引数にシェルメタ文字perl &lt;code&gt;fork()&lt;/code&gt; （）が含まれている場合は、 &lt;code&gt;exec()&lt;/code&gt; saシェルを使用してメタ文字をデコードし、最終的に目的のプログラムを実行します。プログラムを実行できなかった場合、メッセージを受け取るのはPerlではなくシェルです。 Perlプログラムが見つけることができるのは、シェル自体が正常に開始できるかどうかだけです。シェルのSTDERRをキャプチャして、エラーメッセージを確認することはできます。&lt;a href=&quot;#How-can-I-capture-STDERR-from-an-external-command%3F&quot;&gt;「外部コマンドからSTDERRをキャプチャするにはどうすればよいですか？」を&lt;/a&gt;参照してください。このドキュメントの他の場所で、または&lt;a href=&quot;IPC::Open3&quot;&gt;IPC :: Open3&lt;/a&gt;モジュールを使用してください。</target>
        </trans-unit>
        <trans-unit id="6a485d6980d01df96f56ec659ef159a6f3e30c7c" translate="yes" xml:space="preserve">
          <source>If the second operand has a &quot;nomethod&quot; method then use that.</source>
          <target state="translated">2番目のオペランドが &quot;nomethod &quot;メソッドを持っている場合は、それを使用します。</target>
        </trans-unit>
        <trans-unit id="d89fc930c903cfb2489602dfe78fa395aab16a02" translate="yes" xml:space="preserve">
          <source>If the second parameter (a boolean) is omitted or false, the decomposition is canonical decomposition; if the second parameter (a boolean) is true, the decomposition is compatibility decomposition.</source>
          <target state="translated">2番目のパラメータ(ブール値)が省略されているかfalseの場合、分解は正準分解であり、2番目のパラメータ(ブール値)がtrueの場合、分解は互換性分解です。</target>
        </trans-unit>
        <trans-unit id="cdc3a4f8b493e77f4b46b059968dc0b38f7409ec" translate="yes" xml:space="preserve">
          <source>If the selected element is outside the string, the value 0 is returned. If an element off the end of the string is written to, Perl will first extend the string with sufficiently many zero bytes. It is an error to try to write off the beginning of the string (i.e., negative OFFSET).</source>
          <target state="translated">選択された要素が文字列の外にある場合、値 0 が返されます。文字列の末尾から外れた要素が書き込まれた場合、Perlは最初に十分な数の0バイトで文字列を拡張します。文字列の先頭から外れた要素を書き込もうとするとエラーになります(つまり、負のOFFSET)。</target>
        </trans-unit>
        <trans-unit id="a0efffe8f3cec0c66bc0076cfbf0d0f016059fa0" translate="yes" xml:space="preserve">
          <source>If the semaphore's count would drop below zero, this method will block until either the semaphore's count is greater than or equal to the amount you're &lt;code&gt;down&lt;/code&gt;ing the semaphore's count by, or until the timeout is reached.</source>
          <target state="translated">セマフォのカウントがゼロを下回る場合、このメソッドは、セマフォのカウントがセマフォのカウントを &lt;code&gt;down&lt;/code&gt; ている量以上になるか、タイムアウトに達するまでブロックします。</target>
        </trans-unit>
        <trans-unit id="08309d3b072967d3ab275a7c77649be9b9f2f474" translate="yes" xml:space="preserve">
          <source>If the semaphore's count would drop below zero, this method will block until such time as the semaphore's count is greater than or equal to the amount you're &lt;code&gt;down&lt;/code&gt; ing the semaphore's count by.</source>
          <target state="translated">セマフォのカウントがゼロ未満に低下したい場合、このメソッドは、セマフォのカウントがより大きいか、あなたがしている量に等しくなるような時間までブロックします &lt;code&gt;down&lt;/code&gt; によって、セマフォのカウントする。</target>
        </trans-unit>
        <trans-unit id="083a8e90721e210cc119c4e7060a13485c79131e" translate="yes" xml:space="preserve">
          <source>If the semaphore's count would drop below zero, this method will block until such time as the semaphore's count is greater than or equal to the amount you're &lt;code&gt;down&lt;/code&gt;ing the semaphore's count by.</source>
          <target state="translated">セマフォのカウントがゼロを下回る場合、このメソッドは、セマフォのカウントがセマフォのカウントを &lt;code&gt;down&lt;/code&gt; ている量以上になるまでブロックします。</target>
        </trans-unit>
        <trans-unit id="49cf6efaba2d8b062462556a6172122cd62a7391" translate="yes" xml:space="preserve">
          <source>If the semaphore's count would drop below zero, this method will return</source>
          <target state="translated">セマフォのカウントがゼロ以下になると、このメソッドは</target>
        </trans-unit>
        <trans-unit id="43da8fe1e0dfe354dcb09a89c8401b1d0438aefd" translate="yes" xml:space="preserve">
          <source>If the sequence contains a single code point which is unassigned to a character in the version of Unicode being used, the function will return TRUE, and the script will be &lt;code&gt;SCX_Unknown&lt;/code&gt;. Any other combination of unassigned code points in the input sequence will result in the function treating the input as not being a script run.</source>
          <target state="translated">シーケンスに、使用されているUnicodeのバージョンの文字に割り当てられていない単一のコードポイントが含まれている場合、関数はTRUEを返し、スクリプトは &lt;code&gt;SCX_Unknown&lt;/code&gt; になります。入力シーケンス内の割り当てられていないコードポイントのその他の組み合わせにより、関数は入力をスクリプト実行ではないものとして扱います。</target>
        </trans-unit>
        <trans-unit id="ecadb78dff58886929648354bb050576d1075181" translate="yes" xml:space="preserve">
          <source>If the sequence is empty, TRUE is returned, but &lt;code&gt;*ret_script&lt;/code&gt; (if asked for) will be &lt;code&gt;SCX_INVALID&lt;/code&gt;.</source>
          <target state="translated">シーケンスが空の場合、TRUEが返されますが、 &lt;code&gt;*ret_script&lt;/code&gt; （要求された場合）は &lt;code&gt;SCX_INVALID&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="feaf413a0792a40fde39688dd7794f1b79d23f9d" translate="yes" xml:space="preserve">
          <source>If the shareable image isn't in any of these places, you'll need to define a logical name</source>
          <target state="translated">共有可能な画像がこれらの場所にない場合は、論理的な名前を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="34b3b705ebfb832784afae8421a8cf44e644e9c0" translate="yes" xml:space="preserve">
          <source>If the socket is in a connected state, the peer address is returned. If the socket is not in a connected state, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">ソケットが接続状態の場合、ピアアドレスが返されます。ソケットが接続状態にない場合、 &lt;code&gt;undef&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="5d77daa474d5b520bbe270f2db415132f8e51945" translate="yes" xml:space="preserve">
          <source>If the socket is in a connected state, the peer address is returned. If the socket is not in a connected state, undef is returned.</source>
          <target state="translated">ソケットが接続状態にある場合、ピアアドレスを返す。ソケットが接続状態でない場合は undef を返す。</target>
        </trans-unit>
        <trans-unit id="bc839afaf75ab77ac378c573dd37cfe67fada222" translate="yes" xml:space="preserve">
          <source>If the source number can be represented in the target form, that representation is used.</source>
          <target state="translated">ソース番号がターゲット形式で表現できる場合は、その表現が使用されます。</target>
        </trans-unit>
        <trans-unit id="ad2456e62439e41ca828e4d7a559faef86d9a12f" translate="yes" xml:space="preserve">
          <source>If the source number is between two numbers representable in the target form, a representation of one of these numbers is used. (</source>
          <target state="translated">元の数値が対象の形式で表現可能な2つの数値の間にある場合は、そのうちの1つの数値の表現が使用されます。(</target>
        </trans-unit>
        <trans-unit id="5807a3edb0534ce60ac2857df2fbffa4467c6e15" translate="yes" xml:space="preserve">
          <source>If the source number is outside of the limits representable in the target form, a representation of the closest limit is used. (</source>
          <target state="translated">ソース番号がターゲットフォームで表現可能な限界の外にある場合、最も近い限界の表現が使用されます。(</target>
        </trans-unit>
        <trans-unit id="a2b6fc7f507aeb4c29a8733766d6c6136c45fda9" translate="yes" xml:space="preserve">
          <source>If the special input filename &quot;&quot;, &quot;-&quot; or &quot;&amp;lt;&amp;amp;STDIN&quot; is given then the STDIN filehandle is used for input (and no open or close is performed). If no input filename is specified then &quot;-&quot; is implied. Filehandle references, or objects that support the regular IO operations (like &lt;code&gt;&amp;lt;$fh&amp;gt;&lt;/code&gt; or &lt;code&gt;$fh-&amp;lt;Egt&lt;/code&gt;getline&amp;gt;) are also accepted; the handles must already be opened.</source>
          <target state="translated">特別な入力ファイル名 &quot;&quot;、 &quot;-&quot;、または &quot;&amp;lt;＆S​​TDIN&quot;が指定されている場合、STDINファイルハンドルが入力に使用されます（オープンまたはクローズは実行されません）。入力ファイル名が指定されていない場合、「-」が暗黙指定されます。ファイルハンドル参照、または通常のIO操作をサポートするオブジェクト（ &lt;code&gt;&amp;lt;$fh&amp;gt;&lt;/code&gt; や &lt;code&gt;$fh-&amp;lt;Egt&lt;/code&gt; getline&amp;gt;など）も受け入れられます。ハンドルはすでに開かれている必要があります。</target>
        </trans-unit>
        <trans-unit id="3247f1e5568a45232c218d52498138f8657c71b9" translate="yes" xml:space="preserve">
          <source>If the specification of the class was not completely valid, the message indicates that.</source>
          <target state="translated">クラスの指定が完全に有効ではなかった場合は、そのことを示すメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="0ec8f0307ac0cd29be9e31e20412d0003c85f12a" translate="yes" xml:space="preserve">
          <source>If the standard options aren't enough, you may want to subclass Pod::Simple::XHMTL. These are the most likely candidates for methods you'll want to override when subclassing.</source>
          <target state="translated">標準のオプションでは不十分な場合は、Pod::Simple::XHMTLをサブクラス化するとよいでしょう。サブクラス化する際にオーバーライドしたいメソッドは、以下のようなものが考えられます。</target>
        </trans-unit>
        <trans-unit id="c57481fa08ceb2f9368092d11351ebd6c6865947" translate="yes" xml:space="preserve">
          <source>If the string can not be interpreted, NaN is returned.</source>
          <target state="translated">文字列が解釈できない場合は、NaNを返します。</target>
        </trans-unit>
        <trans-unit id="fc03084e4b347434da04ee646a45ae6dc9795b98" translate="yes" xml:space="preserve">
          <source>If the string exception does not end in a newline, the current script line number and input line number (if any) and a newline are appended to it. Note that the &quot;input line number&quot; (also known as &quot;chunk&quot;) is subject to whatever notion of &quot;line&quot; happens to be currently in effect, and is also available as the special variable &lt;a href=&quot;perlvar#%24.&quot;&gt;&lt;code&gt;$.&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&quot;$/&quot; in perlvar&lt;/a&gt; and &lt;a href=&quot;perlvar#%24.&quot;&gt;&quot;$.&quot; in perlvar&lt;/a&gt;.</source>
          <target state="translated">文字列例外が改行で終わっていない場合は、現在のスクリプト行番号と入力行番号（存在する場合）および改行が追加されます。「入力行番号」（「チャンク」とも呼ばれます）は、現在有効な「行」の概念の影響を受け、特別な変数&lt;a href=&quot;perlvar#%24.&quot;&gt; &lt;code&gt;$.&lt;/code&gt; &lt;/a&gt;としても使用できることに注意してください。。&lt;a href=&quot;perlvar#%24%2F&quot;&gt;perlvarの「$ /」&lt;/a&gt;および&lt;a href=&quot;perlvar#%24.&quot;&gt;「$ &lt;/a&gt;」を参照してください。perlvarで。</target>
        </trans-unit>
        <trans-unit id="61afcdbf0b63afa329f8dddf52dc441cb7c93f4b" translate="yes" xml:space="preserve">
          <source>If the string happens to be encoded as UTF-8 internally (and thus has the UTF8 flag set), &lt;a href=&quot;#vec-EXPR%2COFFSET%2CBITS&quot;&gt;&lt;code&gt;vec&lt;/code&gt;&lt;/a&gt; tries to convert it to use a one-byte-per-character internal representation. However, if the string contains characters with values of 256 or higher, a fatal error will occur.</source>
          <target state="translated">文字列がたまたま内部でUTF-8としてエンコードされている場合（したがってUTF8フラグが設定されている場合）、&lt;a href=&quot;#vec-EXPR%2COFFSET%2CBITS&quot;&gt; &lt;code&gt;vec&lt;/code&gt; &lt;/a&gt;は文字ごとに1バイトの内部表現を使用するように文字列を変換しようとします。ただし、文字列に256以上の値の文字が含まれている場合、致命的なエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="95c4f5fed91805150d0fb1f5cc265445f3719afe" translate="yes" xml:space="preserve">
          <source>If the string happens to be encoded as UTF-8 internally (and thus has the UTF8 flag set), this is ignored by &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;, and it operates on the internal byte string, not the conceptual character string, even if you only have characters with values less than 256.</source>
          <target state="translated">文字列がたまたま内部でUTF-8としてエンコードされている（したがってUTF8フラグが設定されている）場合、これは &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; によって無視され、概念的な文字列ではなく内部バイト文字列で動作します。 256未満の値。</target>
        </trans-unit>
        <trans-unit id="e46f7dff46b6e909ca2a4c0f1cd989e3474f6367" translate="yes" xml:space="preserve">
          <source>If the string happens to be encoded as UTF-8 internally (and thus has the UTF8 flag set), this is ignored by &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt;, and it operates on the internal byte string, not the conceptual character string, even if you only have characters with values less than 256.</source>
          <target state="translated">文字列がたまたま内部でUTF-8としてエンコードされている（したがってUTF8フラグが設定されている）場合、これは &lt;code&gt;&lt;a href=&quot;vec&quot;&gt;vec&lt;/a&gt;&lt;/code&gt; によって無視され、概念的な文字列ではなく内部バイト文字列で動作します。 256未満の値。</target>
        </trans-unit>
        <trans-unit id="7652f3d26c3d783ee2b0cdbd7edb6550d6506acc" translate="yes" xml:space="preserve">
          <source>If the string has a &quot;0b&quot; prefix, it is interpreted as a binary number.</source>
          <target state="translated">文字列の接頭辞が &quot;0b &quot;の場合は、2進数として解釈されます。</target>
        </trans-unit>
        <trans-unit id="88ff0fdfcd38431066beb5169d3e97b3f28b4513" translate="yes" xml:space="preserve">
          <source>If the string has a &quot;0x&quot; prefix, it is interpreted as a hexadecimal number.</source>
          <target state="translated">文字列の接頭辞が「0x」の場合は、16進数として解釈されます。</target>
        </trans-unit>
        <trans-unit id="556906a3727707516e15ba62fe70b3006b4bd52d" translate="yes" xml:space="preserve">
          <source>If the string is just one character in length, the Unicode numeric value is returned if it has one, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; otherwise. Note that this need not be a whole number. &lt;code&gt;num(&quot;\N{TIBETAN DIGIT HALF ZERO}&quot;)&lt;/code&gt; , for example returns -0.5.</source>
          <target state="translated">文字列の長さが1文字の場合、Unicodeの数値には、それが含まれている場合はそれが返され、そうでない場合は &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。これは整数である必要はないことに注意してください。たとえば、 &lt;code&gt;num(&quot;\N{TIBETAN DIGIT HALF ZERO}&quot;)&lt;/code&gt; 、-0.5を返します。</target>
        </trans-unit>
        <trans-unit id="4fce93c48f5e7099a349c6ef5a41848fb5f748c7" translate="yes" xml:space="preserve">
          <source>If the string is just one character in length, the Unicode numeric value is returned if it has one, or &lt;code&gt;undef&lt;/code&gt; otherwise. If the optional scalar ref is passed, it would be set to 1 if the return is valid; or 0 if the return is &lt;code&gt;undef&lt;/code&gt;. Note that the numeric value returned need not be a whole number. &lt;code&gt;num(&quot;\N{TIBETAN DIGIT HALF ZERO}&quot;)&lt;/code&gt;, for example returns -0.5.</source>
          <target state="translated">文字列の長さが1文字だけの場合、Unicode数値があればそれが返され、それ以外の場合は &lt;code&gt;undef&lt;/code&gt; が返されます。オプションのスカラー参照が渡された場合、戻り値が有効であれば1に設定されます。戻り値が &lt;code&gt;undef&lt;/code&gt; の場合は0 。返される数値は整数である必要はないことに注意してください。 &lt;code&gt;num(&quot;\N{TIBETAN DIGIT HALF ZERO}&quot;)&lt;/code&gt; は、たとえば-0.5を返します。</target>
        </trans-unit>
        <trans-unit id="3c98175c6574b582a8455429e44a48ac7e74d895" translate="yes" xml:space="preserve">
          <source>If the string is more than one character, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned unless all its characters are decimal digits (that is, they would match &lt;code&gt;\d+&lt;/code&gt; ), from the same script. For example if you have an ASCII '0' and a Bengali '3', mixed together, they aren't considered a valid number, and &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned. A further restriction is that the digits all have to be of the same form. A half-width digit mixed with a full-width one will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. The Arabic script has two sets of digits; &lt;code&gt;num&lt;/code&gt; will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; unless all the digits in the string come from the same set.</source>
          <target state="translated">文字列が複数の文字の場合、同じスクリプトからすべての文字が10進数字でない（つまり、 &lt;code&gt;\d+&lt;/code&gt; と一致する）場合を除いて、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。たとえば、ASCII '0'とベンガル語 '3'が混在している場合、それらは有効な数値と見なされず、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。さらなる制限は、数字はすべて同じ形式でなければならないということです。全角の数字と混合された半角の数字は &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。アラビア文字には2組の数字があります。文字列のすべての数字が同じセットに由来しない限り、 &lt;code&gt;num&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="38c89008b47ecbaadc076b7aa2f24f0e7c6c9985" translate="yes" xml:space="preserve">
          <source>If the string is more than one character, &lt;code&gt;undef&lt;/code&gt; is returned unless all its characters are decimal digits (that is, they would match &lt;code&gt;\d+&lt;/code&gt;), from the same script. For example if you have an ASCII '0' and a Bengali '3', mixed together, they aren't considered a valid number, and &lt;code&gt;undef&lt;/code&gt; is returned. A further restriction is that the digits all have to be of the same form. A half-width digit mixed with a full-width one will return &lt;code&gt;undef&lt;/code&gt;. The Arabic script has two sets of digits; &lt;code&gt;num&lt;/code&gt; will return &lt;code&gt;undef&lt;/code&gt; unless all the digits in the string come from the same set. In all cases, the optional scalar ref parameter is set to how long any valid initial substring of digits is; hence it will be set to the entire string length if the main return value is not &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">文字列が複数の文字である場合、同じスクリプトから、すべての文字が10進数でない限り（つまり、 &lt;code&gt;\d+&lt;/code&gt; と一致しない限り） &lt;code&gt;undef&lt;/code&gt; が返されます。たとえば、ASCII「0」とベンガル語「3」が混在している場合、それらは有効な数値とは見なされず、 &lt;code&gt;undef&lt;/code&gt; が返されます。さらなる制限は、数字がすべて同じ形式でなければならないということです。半角の数字と全角の数字を混在させると、 &lt;code&gt;undef&lt;/code&gt; が返されます。アラビア文字には2組の数字があります。 &lt;code&gt;num&lt;/code&gt; は &lt;code&gt;undef&lt;/code&gt; を返します文字列のすべての数字が同じセットからのものでない限り。すべての場合において、オプションのスカラーrefパラメーターは、有効な最初の数字の部分文字列の長さに設定されます。したがって、メインの戻り値が &lt;code&gt;undef&lt;/code&gt; でない場合は、文字列全体の長さに設定されます。</target>
        </trans-unit>
        <trans-unit id="4fc51a016846748fdbc037c08fcea8e548c16fe0" translate="yes" xml:space="preserve">
          <source>If the string used for the filename and/or comment is not valid UTF-8 when this option is true, the script will die with a &quot;wide character&quot; error.</source>
          <target state="translated">このオプションが true のときに、ファイル名やコメントに使用される文字列が有効な UTF-8 でない場合、スクリプトは「ワイドキャラクタ」エラーで終了します。</target>
        </trans-unit>
        <trans-unit id="bc54c0830b9373d2798de2bf5260229a62e838a3" translate="yes" xml:space="preserve">
          <source>If the subroutine has one of a few special names, such as &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;, then it will be claimed by the appropriate queue for automatic running of phase-related subroutines. In this case the relevant glob will be left not containing any subroutine, even if it did contain one before. Execution of the subroutine will likely be a no-op, unless &lt;code&gt;sv&lt;/code&gt; was a tied array or the caller modified the subroutine in some interesting way before it was executed. In the case of &lt;code&gt;BEGIN&lt;/code&gt;, the treatment is buggy: the sub will be executed when only half built, and may be deleted prematurely, possibly causing a crash.</source>
          <target state="translated">サブルーチンに &lt;code&gt;BEGIN&lt;/code&gt; や &lt;code&gt;END&lt;/code&gt; などのいくつかの特別な名前のいずれかがある場合、フェーズ関連のサブルーチンを自動的に実行するための適切なキューによって要求されます。この場合、関連するglobには、以前にサブルーチンが含まれていたとしても、サブルーチンは含まれません。 &lt;code&gt;sv&lt;/code&gt; がタイ配列であるか、呼び出し元が実行前に何らかの興味深い方法でサブルーチンを変更していない限り、サブルーチンの実行は操作なしになる可能性があります。 &lt;code&gt;BEGIN&lt;/code&gt; の場合、処理にはバグがあります。サブは半分しかビルドされていないときに実行され、途中で削除されてクラッシュする可能性があります。</target>
        </trans-unit>
        <trans-unit id="6c1db3945f60801d9fe74fe01151fa3c625ba2ad" translate="yes" xml:space="preserve">
          <source>If the subroutine has one of a few special names, such as &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;, then it will be claimed by the appropriate queue for automatic running of phase-related subroutines. In this case the relevant glob will be left not containing any subroutine, even if it did contain one before. In the case of &lt;code&gt;BEGIN&lt;/code&gt;, the subroutine will be executed and the reference to it disposed of before this function returns, and also before its prototype is set. If a &lt;code&gt;BEGIN&lt;/code&gt; subroutine would not be sufficiently constructed by this function to be ready for execution then the caller must prevent this happening by giving the subroutine a different name.</source>
          <target state="translated">サブルーチンに &lt;code&gt;BEGIN&lt;/code&gt; や &lt;code&gt;END&lt;/code&gt; などのいくつかの特別な名前のいずれかがある場合、フェーズ関連のサブルーチンを自動的に実行するための適切なキューによって要求されます。この場合、関連するglobには、以前にサブルーチンが含まれていたとしても、サブルーチンは含まれません。 &lt;code&gt;BEGIN&lt;/code&gt; の場合、この関数が戻る前、およびプロトタイプが設定される前に、サブルーチンが実行され、サブルーチンへの参照が破棄されます。場合 &lt;code&gt;BEGIN&lt;/code&gt; サブルーチンは十分に実行するために準備ができて、この機能によって構築されない発信者は、サブルーチンに別の名前を与えることによって、この出来事を防ぐ必要があります。</target>
        </trans-unit>
        <trans-unit id="bb58246d15f13a6f8775c588f89be7261648c55a" translate="yes" xml:space="preserve">
          <source>If the subroutine has one of a few special names, such as &lt;code&gt;BEGIN&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;, then it will be claimed by the appropriate queue for automatic running of phase-related subroutines. In this case the relevant glob will be left not containing any subroutine, even if it did contain one before. In the case of &lt;code&gt;BEGIN&lt;/code&gt;, the subroutine will be executed and the reference to it disposed of before this function returns.</source>
          <target state="translated">サブルーチンに &lt;code&gt;BEGIN&lt;/code&gt; や &lt;code&gt;END&lt;/code&gt; などのいくつかの特別な名前のいずれかがある場合、フェーズ関連のサブルーチンを自動的に実行するための適切なキューによって要求されます。この場合、関連するglobには、以前にサブルーチンが含まれていたとしても、サブルーチンは含まれません。 &lt;code&gt;BEGIN&lt;/code&gt; の場合、この関数が戻る前に、サブルーチンが実行され、サブルーチンへの参照が破棄されます。</target>
        </trans-unit>
        <trans-unit id="b8c4922eb5c062cef768c57176fb78d4965487a5" translate="yes" xml:space="preserve">
          <source>If the subroutine is an XSUB, the elements to be compared are pushed on to the stack, the way arguments are usually passed to XSUBs. $a and $b are not set.</source>
          <target state="translated">サブルーチンがXSUBの場合、比較対象の要素は、通常XSUBに渡される引数と同じようにスタックにプッシュされます。aと$bは設定されません。</target>
        </trans-unit>
        <trans-unit id="1afca0c8662d7dc27c024fcc727c62d11480ea99" translate="yes" xml:space="preserve">
          <source>If the subroutine is an XSUB, the elements to be compared are pushed on to the stack, the way arguments are usually passed to XSUBs. &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are not set.</source>
          <target state="translated">サブルーチンがXSUBの場合、比較される要素はスタックにプッシュされます。これは、引数が通常XSUBに渡される方法です。 &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; は設定されていません。</target>
        </trans-unit>
        <trans-unit id="976151f66fa723fd3131374feb62ee8e2fa9f3b7" translate="yes" xml:space="preserve">
          <source>If the subroutine needs to signal an error, it should call die() with the desired error message as its argument. GetOptions() will catch the die(), issue the error message, and record that an error result must be returned upon completion.</source>
          <target state="translated">サブルーチンがエラーを通知する必要がある場合は、目的のエラーメッセージを引数としてdie()を呼び出す必要があります。GetOptions()はdie()をキャッチし、エラーメッセージを発行し、完了時にエラー結果を返さなければならないことを記録します。</target>
        </trans-unit>
        <trans-unit id="40540ec0b48601a220c70ec78c454bb0e1f51c33" translate="yes" xml:space="preserve">
          <source>If the subroutine returns a scalar with a newline or a filehandle, it will be interpreted as raw TAP or as a TAP stream, respectively.</source>
          <target state="translated">サブルーチンが改行付きスカラ値やファイルハンドルを返す場合は、それぞれ生のTAPまたはTAPストリームとして解釈されます。</target>
        </trans-unit>
        <trans-unit id="ca613cca9ddf94b18fd3a6da5979f02e2a0a3fcf" translate="yes" xml:space="preserve">
          <source>If the subroutine's prototype is &lt;code&gt;($$)&lt;/code&gt; , the elements to be compared are passed by reference in &lt;code&gt;@_&lt;/code&gt; , as for a normal subroutine. This is slower than unprototyped subroutines, where the elements to be compared are passed into the subroutine as the package global variables $a and $b (see example below). Note that in the latter case, it is usually highly counter-productive to declare $a and $b as lexicals.</source>
          <target state="translated">サブルーチンのプロトタイプが &lt;code&gt;($$)&lt;/code&gt; の場合、通常のサブルーチンと同様に、比較される要素は &lt;code&gt;@_&lt;/code&gt; で参照渡しされます。これは、比較対象の要素がパッケージグローバル変数$ aおよび$ bとしてサブルーチンに渡される、プロトタイプ化されていないサブルーチンよりも低速です（以下の例を参照）。後者の場合、通常、$ aと$ bを字句として宣言することは非常に非生産的です。</target>
        </trans-unit>
        <trans-unit id="84b98f5d60037882d103faaf29e539e20c444828" translate="yes" xml:space="preserve">
          <source>If the subroutine's prototype is &lt;code&gt;($$)&lt;/code&gt;, the elements to be compared are passed by reference in &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt;, as for a normal subroutine. This is slower than unprototyped subroutines, where the elements to be compared are passed into the subroutine as the package global variables &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; (see example below).</source>
          <target state="translated">サブルーチンのプロトタイプが &lt;code&gt;($$)&lt;/code&gt; の場合、比較される要素は、通常のサブルーチンと同様に、&lt;a href=&quot;perlvar#%40_&quot;&gt; &lt;code&gt;@_&lt;/code&gt; &lt;/a&gt;で参照によって渡されます。これは、比較される要素がパッケージグローバル変数 &lt;code&gt;$a&lt;/code&gt; および &lt;code&gt;$b&lt;/code&gt; としてサブルーチンに渡される、プロトタイプ化されていないサブルーチンよりも低速です（以下の例を参照）。</target>
        </trans-unit>
        <trans-unit id="1b8a697c5090fd8ce94c13b5cefb41955f99b010" translate="yes" xml:space="preserve">
          <source>If the sv already is UTF-8 (or if it is not POK), or if the encoding is not a reference, nothing is done to the sv. If the encoding is not an &lt;code&gt;Encode::XS&lt;/code&gt; Encoding object, bad things will happen. (See</source>
          <target state="translated">svがすでにUTF-8である場合（またはPOKでない場合）、またはエンコーディングが参照でない場合、svは何も行われません。エンコーディングが &lt;code&gt;Encode::XS&lt;/code&gt; Encodingオブジェクトでない場合、問題が発生します。（見る</target>
        </trans-unit>
        <trans-unit id="25e6d11786b2dfdb0f52678b6850a3dff8731c46" translate="yes" xml:space="preserve">
          <source>If the sv is the target of a weak reference then it returns the back references structure associated with the sv; otherwise return NULL.</source>
          <target state="translated">svが弱い参照の対象である場合は、svに関連付けられた後方参照構造体を返します。</target>
        </trans-unit>
        <trans-unit id="82b0821b14cc4cbb805ab8ac00aa5900da22e409" translate="yes" xml:space="preserve">
          <source>If the symbol &lt;code&gt;:void&lt;/code&gt; appears in the import list, then functions named later in that import list raise an exception only when these are called in void context--that is, when their return values are ignored. For example</source>
          <target state="translated">シンボル &lt;code&gt;:void&lt;/code&gt; がインポートリストにある場合、そのインポートリストで後に指定された関数は、voidコンテキストで呼び出された場合、つまり戻り値が無視された場合にのみ例外を発生させます。例えば</target>
        </trans-unit>
        <trans-unit id="50cf7df5061941de64a11ddf12781ae7a8f3290f" translate="yes" xml:space="preserve">
          <source>If the system Perl is compiled in has thread-safe variants of such calls, they will be used. Beyond that, Perl is at the mercy of the thread-safety or -unsafety of the calls. Please consult your C library call documentation.</source>
          <target state="translated">Perl がコンパイルされているシステムが、そのような呼び出しのスレッドセーフなバリアントを持っている場合は、それらが使用されます。それ以上の場合は、Perlはその呼び出しのスレッドセーフか-セーフではないかの判断に委ねられています。C ライブラリのコールのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="d5b1234bec481f7f0fb540471e8867994b10762a" translate="yes" xml:space="preserve">
          <source>If the target machine is little-endian, we could write:</source>
          <target state="translated">対象マシンがリトルエンディアンであれば、書けます。</target>
        </trans-unit>
        <trans-unit id="4756e731e627a9969d09a902907c109ca92f4013" translate="yes" xml:space="preserve">
          <source>If the template is not specified, a template is always automatically generated. This temporary file is placed in tmpdir() (&lt;a href=&quot;File::Spec&quot;&gt;File::Spec&lt;/a&gt;) unless a directory is specified explicitly with the DIR option.</source>
          <target state="translated">テンプレートが指定されていない場合、テンプレートは常に自動的に生成されます。この一時ファイルは、ディレクトリがDIRオプションで明示的に指定されていない限り、tmpdir（）（&lt;a href=&quot;File::Spec&quot;&gt;File :: Spec&lt;/a&gt;）に配置されます。</target>
        </trans-unit>
        <trans-unit id="ff635540edd5aea28a885e06a80c5c6844ba7c11" translate="yes" xml:space="preserve">
          <source>If the template is not specified, a template is always automatically generated. This temporary file is placed in tmpdir() (L&amp;lt;:spec&amp;gt;) unless a directory is specified explicitly with the DIR option.</source>
          <target state="translated">テンプレートが指定されていない場合、テンプレートは常に自動的に生成されます。この一時ファイルは、ディレクトリがDIRオプションで明示的に指定されていない限り、tmpdir（）（L &amp;lt;：spec&amp;gt;）に配置されます。</target>
        </trans-unit>
        <trans-unit id="593ec0746d963b28de5ba2cf0799b3f4777c63c7" translate="yes" xml:space="preserve">
          <source>If the temporary file can not be created undef is returned. Currently this command will probably not work when the temporary directory is on an NFS file system.</source>
          <target state="translated">一時ファイルを作成できない場合は undef が返されます。現在のところ、このコマンドは、一時ディレクトリが NFS ファイルシステム上にある場合には、おそらく動作しません。</target>
        </trans-unit>
        <trans-unit id="326e7cf804954bda3811121b38cb7c631e7575fe" translate="yes" xml:space="preserve">
          <source>If the terminating string is quoted, the type of quotes used determine the treatment of the text.</source>
          <target state="translated">終了文字列が引用符で囲まれている場合、引用符の種類によってテキストの扱いが決まります。</target>
        </trans-unit>
        <trans-unit id="957eb5ae659823f7ba1c0183ec0ac873de8b4109" translate="yes" xml:space="preserve">
          <source>If the test is unplanned, this method will always return false. See &lt;code&gt;is_unplanned&lt;/code&gt; .</source>
          <target state="translated">テストが計画外の場合、このメソッドは常にfalseを返します。 &lt;code&gt;is_unplanned&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="20d3ba6a3f24850f51b5f59f10528892b52a140e" translate="yes" xml:space="preserve">
          <source>If the test is unplanned, this method will always return false. See &lt;code&gt;is_unplanned&lt;/code&gt;.</source>
          <target state="translated">テストが計画外の場合、このメソッドは常にfalseを返します。 &lt;code&gt;is_unplanned&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="1bfabe273698ccd033cf292d0d277e005ca02c57" translate="yes" xml:space="preserve">
          <source>If the tests fail &lt;code&gt;prove&lt;/code&gt; will exit with non-zero status.</source>
          <target state="translated">テストが失敗した場合、 &lt;code&gt;prove&lt;/code&gt; はゼロ以外のステータスで終了します。</target>
        </trans-unit>
        <trans-unit id="269c79628ff3b9a7faad565d0d36f6d320d9b282" translate="yes" xml:space="preserve">
          <source>If the text of the L&amp;lt;&amp;gt; escape is entirely enclosed in double quotes, it's interpreted as a link to a section for backward compatibility.</source>
          <target state="translated">L &amp;lt;&amp;gt;エスケープのテキストが完全に二重引用符で囲まれている場合、下位互換性のためにセクションへのリンクとして解釈されます。</target>
        </trans-unit>
        <trans-unit id="f92e03b607dab58b8f2f2e3c224ccb0a3fc3ca6c" translate="yes" xml:space="preserve">
          <source>If the text of the error message starts with an exclamation mark &lt;code&gt;!&lt;/code&gt; it is interpreted specially by GetOptions(). There is currently one special command implemented: &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die(&quot;!FINISH&quot;)&lt;/a&gt;&lt;/code&gt; will cause GetOptions() to stop processing options, as if it encountered a double dash &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">エラーメッセージのテキストが感嘆符で始まっている場合 &lt;code&gt;!&lt;/code&gt; GetOptions（）によって特別に解釈されます。現在実装されている特別なコマンドは1つ &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die(&quot;!FINISH&quot;)&lt;/a&gt;&lt;/code&gt; 。die（&quot;！FINISH&quot;）を指定すると、GetOptions（）は、ダブルダッシュ &lt;code&gt;--&lt;/code&gt; したかのようにオプションの処理を停止します。</target>
        </trans-unit>
        <trans-unit id="3d332109bf38a18b83347b1abe4af5018dfcf4a0" translate="yes" xml:space="preserve">
          <source>If the text of the error message starts with an exclamation mark &lt;code&gt;!&lt;/code&gt; it is interpreted specially by GetOptions(). There is currently one special command implemented: &lt;code&gt;die(&quot;!FINISH&quot;)&lt;/code&gt; will cause GetOptions() to stop processing options, as if it encountered a double dash &lt;code&gt;--&lt;/code&gt;.</source>
          <target state="translated">エラーメッセージのテキストが感嘆符で始まる場合 &lt;code&gt;!&lt;/code&gt; GetOptions（）によって特別に解釈されます。現在、実装されている特別なコマンドが1つあります。die（ &lt;code&gt;die(&quot;!FINISH&quot;)&lt;/code&gt; により、GetOptions（）は、二重ダッシュが発生したかのようにオプションの処理を停止します &lt;code&gt;--&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54a21a0dcb36b1ce3d43912ccebce5a460b97864" translate="yes" xml:space="preserve">
          <source>If the third argument is</source>
          <target state="translated">第三引数が</target>
        </trans-unit>
        <trans-unit id="b232866b6ad063c73d4ad37ea476edb565d6de63" translate="yes" xml:space="preserve">
          <source>If the third argument,</source>
          <target state="translated">第三引数の場合。</target>
        </trans-unit>
        <trans-unit id="66bf0740d3ced4e3ce4166e93bb8bdf81549240a" translate="yes" xml:space="preserve">
          <source>If the thread being &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;ed &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;d, the error it died with will be returned at this time. If you don't want the thread performing the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; to die as well, you should either wrap the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; or use the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; thread method instead of &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">スレッドがされている場合は &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 編 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; dは、それはして死亡したエラーは、この時点で返されます。あなたが実行するスレッドしたくない場合は &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; だけでなく死ぬことを、あなたはどちらかラップする必要があります &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; や使用 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; スレッド方式の代わりに &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a5af2f1be44751c2177059f4e6af4dd499466cc" translate="yes" xml:space="preserve">
          <source>If the thread being &lt;code&gt;join&lt;/code&gt;ed &lt;code&gt;die&lt;/code&gt;d, the error it died with will be returned at this time. If you don't want the thread performing the &lt;code&gt;join&lt;/code&gt; to die as well, you should either wrap the &lt;code&gt;join&lt;/code&gt; in an &lt;code&gt;eval&lt;/code&gt; or use the &lt;code&gt;eval&lt;/code&gt; thread method instead of &lt;code&gt;join&lt;/code&gt;.</source>
          <target state="translated">スレッドがされている場合は &lt;code&gt;join&lt;/code&gt; 編 &lt;code&gt;die&lt;/code&gt; dは、それはして死亡したエラーは、この時点で返されます。あなたが実行するスレッドしたくない場合は &lt;code&gt;join&lt;/code&gt; だけでなく死ぬことを、あなたはどちらかラップする必要があります &lt;code&gt;join&lt;/code&gt; に &lt;code&gt;eval&lt;/code&gt; や使用 &lt;code&gt;eval&lt;/code&gt; スレッド方式の代わりに &lt;code&gt;join&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2279b2f8b74fd7d772a6ba18eb3177b3a248c49d" translate="yes" xml:space="preserve">
          <source>If the timeout is reached, this method will return</source>
          <target state="translated">タイムアウトに達した場合、このメソッドは</target>
        </trans-unit>
        <trans-unit id="3cd970acc5e28ee89d2e82334dde273c65bae5b7" translate="yes" xml:space="preserve">
          <source>If the title can't be found, then get_short_title returns empty-string (&quot;&quot;).</source>
          <target state="translated">タイトルが見つからない場合は、get_short_titleは空文字列(&quot;&quot;)を返します。</target>
        </trans-unit>
        <trans-unit id="697a489e14d5b870ec5510bd4b458c67ab45bad8" translate="yes" xml:space="preserve">
          <source>If the typeglob &lt;code&gt;gv&lt;/code&gt; can be expressed more succinctly, by having something other than a real GV in its place in the stash, replace it with the optimised form. Basic requirements for this are that &lt;code&gt;gv&lt;/code&gt; is a real typeglob, is sufficiently ordinary, and is only referenced from its package. This function is meant to be used when a GV has been looked up in part to see what was there, causing upgrading, but based on what was found it turns out that the real GV isn't required after all.</source>
          <target state="translated">タイプグロブ &lt;code&gt;gv&lt;/code&gt; をより簡潔に表現できる場合は、スタッシュの代わりに実際のGV以外のものを配置して、最適化された形式に置き換えます。これの基本的な要件は、 &lt;code&gt;gv&lt;/code&gt; が実際の型グロブであり、十分に普通であり、そのパッケージからのみ参照されることです。この機能は、GVを部分的に調べてそこにあるものを確認し、アップグレードを引き起こしたときに使用することを意図していますが、見つかった結果に基づいて、結局、実際のGVは不要であることがわかります。</target>
        </trans-unit>
        <trans-unit id="7e317e256420ab2a48b2f7e7b312c3d9f416e521" translate="yes" xml:space="preserve">
          <source>If the underlying &lt;code&gt;IO::Handle&lt;/code&gt; is closed, or if there are any read or write failures, the file handle will be forced closed, and &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return &quot;[$pkg] Connection closed&quot; (where $pkg is the name of the class that subclassed &lt;code&gt;Net::Cmd&lt;/code&gt; ). The _set_status_closed() method can be overridden to set a different message (by calling set_status()) or otherwise trap this error.</source>
          <target state="translated">基になる &lt;code&gt;IO::Handle&lt;/code&gt; が閉じている場合、または読み取りまたは書き込みの失敗がある場合、ファイルハンドルは強制的に閉じられ、 &lt;code&gt;code()&lt;/code&gt; は &quot;421&quot;（一時的な接続失敗 &lt;code&gt;message()&lt;/code&gt; を返し、message（）は &quot;[を返します。 $ pkg] Connection closed」（$ pkgは &lt;code&gt;Net::Cmd&lt;/code&gt; をサブクラス化したクラスの名前です）。_set_status_closed（）メソッドをオーバーライドして、（set_status（）を呼び出して）別のメッセージを設定するか、このエラーをトラップすることができます。</target>
        </trans-unit>
        <trans-unit id="1e77ce40e4dd7efc2c043a17aee5d821a48fe672" translate="yes" xml:space="preserve">
          <source>If the underlying &lt;code&gt;IO::Handle&lt;/code&gt; is closed, or if there are any read or write failures, the file handle will be forced closed, and &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return &quot;[$pkg] Connection closed&quot; (where $pkg is the name of the class that subclassed &lt;code&gt;Net::Cmd&lt;/code&gt;). The _set_status_closed() method can be overridden to set a different message (by calling set_status()) or otherwise trap this error.</source>
          <target state="translated">基になる &lt;code&gt;IO::Handle&lt;/code&gt; が閉じている場合、または読み取りまたは書き込みの失敗がある場合、ファイルハンドルは強制的に閉じられ、 &lt;code&gt;code()&lt;/code&gt; は「421」（一時的な接続の失敗 &lt;code&gt;message()&lt;/code&gt; を返し、message（）は「[ $ pkg]接続が閉じられました」（$ pkgは &lt;code&gt;Net::Cmd&lt;/code&gt; をサブクラス化したクラスの名前です）。 _set_status_closed（）メソッドをオーバーライドして、別のメッセージを設定するか（set_status（）を呼び出すことにより）、またはこのエラーをトラップすることができます。</target>
        </trans-unit>
        <trans-unit id="cdc3b2cf894256f273b0349af8d5d688d0cdcb39" translate="yes" xml:space="preserve">
          <source>If the user builds a shared</source>
          <target state="translated">ユーザーが共有の</target>
        </trans-unit>
        <trans-unit id="32324af5745fb70c85007da7a27faa556a189cfd" translate="yes" xml:space="preserve">
          <source>If the user didn't specify anything, it's interpreted as having used the &lt;code&gt;please&lt;/code&gt; tag. It's up to you to make this useful.</source>
          <target state="translated">ユーザーが何も指定しなかった場合は、 &lt;code&gt;please&lt;/code&gt; タグを使用したと解釈されます。これを役立てるのはあなた次第です。</target>
        </trans-unit>
        <trans-unit id="cd074d1ec9315994a5770ffd227be188d8ea3674" translate="yes" xml:space="preserve">
          <source>If the user does not have HTML::Lint installed, the whole block of code</source>
          <target state="translated">ユーザーが HTML::Lint をインストールしていない場合は、コードブロック全体の</target>
        </trans-unit>
        <trans-unit id="b39c8811f479889c6eabed43038bf7a333557852" translate="yes" xml:space="preserve">
          <source>If the user has superuser privileges, and is not working on AFS or relatives, then the defaults for INSTALLPRIVLIB, INSTALLARCHLIB, INSTALLSCRIPT, etc. will be appropriate, and this incantation will be the best:</source>
          <target state="translated">スーパーユーザー権限を持っていて、AFSや親戚の作業をしていない場合は、installprivlib、installarchlib、installscriptなどのデフォルトが適切で、この呪文が一番良いでしょう。</target>
        </trans-unit>
        <trans-unit id="3d9745c4616cab220c27715466f7a222d8b72268" translate="yes" xml:space="preserve">
          <source>If the value</source>
          <target state="translated">値が</target>
        </trans-unit>
        <trans-unit id="1676523b419ae746e43ad6553d2687aea42c504e" translate="yes" xml:space="preserve">
          <source>If the value doesn't match the 'make' program you want to use, edit Config.pm to fix it.</source>
          <target state="translated">値が使用したい 'make' プログラムと一致しない場合は、Config.pm を編集して修正してください。</target>
        </trans-unit>
        <trans-unit id="9aa86f4743abc7079a416abc9073771271ff4394" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; it is returned as a UV, the output flags are clear, and nothing is written to</source>
          <target state="translated">値が &lt;code&gt;UV_MAX&lt;/code&gt; 以下の場合、UVとして返され、出力フラグはクリアされ、何も書き込まれません。</target>
        </trans-unit>
        <trans-unit id="69db17f26df78ff9935057c8c72522c8171dedc4" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; it is returned as a UV, the output flags are clear, and nothing is written to &lt;code&gt;*result&lt;/code&gt;. If the value is &amp;gt; &lt;code&gt;UV_MAX&lt;/code&gt;, &lt;code&gt;grok_bin&lt;/code&gt; returns &lt;code&gt;UV_MAX&lt;/code&gt;, sets &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; in the output flags, and writes an approximation of the correct value into &lt;code&gt;*result&lt;/code&gt; (which is an NV; or the approximation is discarded if &lt;code&gt;result&lt;/code&gt; is NULL).</source>
          <target state="translated">値が&amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; の場合、UVとして返され、出力フラグはクリアされ、 &lt;code&gt;*result&lt;/code&gt; には何も書き込まれません。値が&amp;gt;である場合 &lt;code&gt;UV_MAX&lt;/code&gt; 、 &lt;code&gt;grok_bin&lt;/code&gt; 戻り &lt;code&gt;UV_MAX&lt;/code&gt; 、セット &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; 出力フラグには、及びに正しい値の近似値書き込み &lt;code&gt;*result&lt;/code&gt; （NVである場合、または近似が破棄され &lt;code&gt;result&lt;/code&gt; NULLです）。</target>
        </trans-unit>
        <trans-unit id="b33edf1191e45f2f7c173468860c56b9c68eec7c" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; it is returned as a UV, the output flags are clear, and nothing is written to &lt;code&gt;*result&lt;/code&gt;. If the value is &amp;gt; &lt;code&gt;UV_MAX&lt;/code&gt;, &lt;code&gt;grok_hex&lt;/code&gt; returns &lt;code&gt;UV_MAX&lt;/code&gt;, sets &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; in the output flags, and writes an approximation of the correct value into &lt;code&gt;*result&lt;/code&gt; (which is an NV; or the approximation is discarded if &lt;code&gt;result&lt;/code&gt; is NULL).</source>
          <target state="translated">値が&amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; の場合、UVとして返され、出力フラグはクリアされ、 &lt;code&gt;*result&lt;/code&gt; には何も書き込まれません。値がある場合&amp;gt; &lt;code&gt;UV_MAX&lt;/code&gt; 、 &lt;code&gt;grok_hex&lt;/code&gt; は戻り &lt;code&gt;UV_MAX&lt;/code&gt; 、セット &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; を出力フラグに、そしてに正しい値の近似値書き込み &lt;code&gt;*result&lt;/code&gt; （;又は場合近似値は破棄されるNVある &lt;code&gt;result&lt;/code&gt; NULLです）。</target>
        </trans-unit>
        <trans-unit id="11949fed265c94f0f9f0cc1d3c0a3164a55a86d5" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; it is returned as a UV, the output flags are clear, and nothing is written to &lt;code&gt;*result&lt;/code&gt;. If the value is &amp;gt; &lt;code&gt;UV_MAX&lt;/code&gt;, &lt;code&gt;grok_oct&lt;/code&gt; returns &lt;code&gt;UV_MAX&lt;/code&gt;, sets &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; in the output flags, and writes an approximation of the correct value into &lt;code&gt;*result&lt;/code&gt; (which is an NV; or the approximation is discarded if &lt;code&gt;result&lt;/code&gt; is NULL).</source>
          <target state="translated">値が&amp;lt;= &lt;code&gt;UV_MAX&lt;/code&gt; の場合、UVとして返され、出力フラグはクリアされ、 &lt;code&gt;*result&lt;/code&gt; には何も書き込まれません。値が&amp;gt;である場合 &lt;code&gt;UV_MAX&lt;/code&gt; 、 &lt;code&gt;grok_oct&lt;/code&gt; 戻り &lt;code&gt;UV_MAX&lt;/code&gt; 、設定 &lt;code&gt;PERL_SCAN_GREATER_THAN_UV_MAX&lt;/code&gt; は、出力フラグに、そしてに正しい値の近似値を書き込む &lt;code&gt;*result&lt;/code&gt; （NVであるか;または場合近似値は破棄され &lt;code&gt;result&lt;/code&gt; NULLです）。</target>
        </trans-unit>
        <trans-unit id="bd15952acdcd265d4f18a816b3be548c37a82d83" translate="yes" xml:space="preserve">
          <source>If the value is &amp;lt;= UV_MAX it is returned as a UV, the output flags are clear, and nothing is written to</source>
          <target state="translated">値がUV_MAX以下の場合、UVとして返され、出力フラグはクリアされ、何も書き込まれません。</target>
        </trans-unit>
        <trans-unit id="c10d8690679793d91d603d7249997075229bffed" translate="yes" xml:space="preserve">
          <source>If the value is a coderef, we return &amp;amp;$value($lh, ...parameters...).</source>
          <target state="translated">値がcoderefの場合、＆$ value（$ lh、... parameters ...）を返します。</target>
        </trans-unit>
        <trans-unit id="ef50a320b2209faad43a3f8213d92ea4b618e424" translate="yes" xml:space="preserve">
          <source>If the value is a scalarref, the scalar is dereferenced and returned (and any parameters are ignored).</source>
          <target state="translated">値がスカラrefの場合は,スカラが参照されて返されます(パラメータは無視されます).</target>
        </trans-unit>
        <trans-unit id="6f950a468109b8d39520112d3f58effdc56407fc" translate="yes" xml:space="preserve">
          <source>If the value is a string that</source>
          <target state="translated">値が文字列の場合は</target>
        </trans-unit>
        <trans-unit id="034aa5dfb1d3fc388ace8815e3c3af316b7fe0f0" translate="yes" xml:space="preserve">
          <source>If the value is true, then the appropriate pragma is assumed to be in the ambient scope, otherwise not.</source>
          <target state="translated">値が真の場合は、適切なプラグマがアンビエントスコープ内にあると仮定し、そうでない場合はそうではないと仮定します。</target>
        </trans-unit>
        <trans-unit id="c4b0ded1a1deef22b5fab46f3c6efeda2921b5b8" translate="yes" xml:space="preserve">
          <source>If the value of</source>
          <target state="translated">の値が</target>
        </trans-unit>
        <trans-unit id="3679a65190bd3883b712c84ff2c3ed51da02c8c9" translate="yes" xml:space="preserve">
          <source>If the value of the number can fit in a UV, it is returned in &lt;code&gt;*valuep&lt;/code&gt;. &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; will be set to indicate that &lt;code&gt;*valuep&lt;/code&gt; is valid, &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; will never be set unless &lt;code&gt;*valuep&lt;/code&gt; is valid, but &lt;code&gt;*valuep&lt;/code&gt; may have been assigned to during processing even though &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; is not set on return. If &lt;code&gt;valuep&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; will be set for the same cases as when &lt;code&gt;valuep&lt;/code&gt; is non-&lt;code&gt;NULL&lt;/code&gt;, but no actual assignment (or SEGV) will occur.</source>
          <target state="translated">数値の値がUVに収まる場合は、 &lt;code&gt;*valuep&lt;/code&gt; で返されます。 &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; はことを示すように設定されます &lt;code&gt;*valuep&lt;/code&gt; が有効で、 &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; がない限り、設定されることはありません &lt;code&gt;*valuep&lt;/code&gt; は有効ですが、 &lt;code&gt;*valuep&lt;/code&gt; はいても、処理中に割り当てられているかもしれ &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; が戻り時に設定されていません。場合 &lt;code&gt;valuep&lt;/code&gt; がある &lt;code&gt;NULL&lt;/code&gt; 、 &lt;code&gt;IS_NUMBER_IN_UV&lt;/code&gt; は時と同じ場合に設定されません &lt;code&gt;valuep&lt;/code&gt; が非ある &lt;code&gt;NULL&lt;/code&gt; が、実際の割り当て（またはSEGV）が発生します。</target>
        </trans-unit>
        <trans-unit id="3799e4ea2da2d340ca2beed8a5872250c216eb41" translate="yes" xml:space="preserve">
          <source>If the value of the number can fit in a UV, it is returned in the *valuep IS_NUMBER_IN_UV will be set to indicate that *valuep is valid, IS_NUMBER_IN_UV will never be set unless *valuep is valid, but *valuep may have been assigned to during processing even though IS_NUMBER_IN_UV is not set on return. If valuep is NULL, IS_NUMBER_IN_UV will be set for the same cases as when valuep is non-NULL, but no actual assignment (or SEGV) will occur.</source>
          <target state="translated">数値の値がUVに収まる場合は、*valuepで返されます。 IS_NUMBER_IN_UVは、*valuepが有効であることを示すために設定されますが、IS_NUMBER_IN_UVは、*valuepが有効でない限り設定されることはありませんが、戻り時にIS_NUMBER_IN_UVが設定されていなくても、処理中に*valuepが代入されている可能性があります。valuepがNULLの場合は、valuepがNULLでない場合と同様にIS_NUMBER_IN_UVが設定されますが、実際の代入(またはSEGV)は発生しません。</target>
        </trans-unit>
        <trans-unit id="d417792987cefdc8fbbad820c7047930346b40c5" translate="yes" xml:space="preserve">
          <source>If the value to pack is too long, the result is truncated. If it's too long and an explicit count is provided, &lt;code&gt;Z&lt;/code&gt; packs only &lt;code&gt;$count-1&lt;/code&gt; bytes, followed by a null byte. Thus &lt;code&gt;Z&lt;/code&gt; always packs a trailing null, except when the count is 0.</source>
          <target state="translated">パックする値が長すぎる場合、結果は切り捨てられます。長すぎて明示的なカウントが指定されている場合、 &lt;code&gt;Z&lt;/code&gt; は &lt;code&gt;$count-1&lt;/code&gt; バイトのみをパックし、その後にnullバイトが続きます。したがって、 &lt;code&gt;Z&lt;/code&gt; は、カウントが0の場合を除いて、常に後続のnullをパックします。</target>
        </trans-unit>
        <trans-unit id="2b18faee7915986e7efaa1de04f931c2b8c71f1c" translate="yes" xml:space="preserve">
          <source>If the values are all small integers, you could use a simple indexed array. This kind of an array will take up less space:</source>
          <target state="translated">値がすべて小さな整数であれば、単純なインデックス付きの配列を使うことができます。この種の配列の方がスペースを取らずに済みます。</target>
        </trans-unit>
        <trans-unit id="5cc9e16e91b4a8896cd9faaa5f9549cbc7085c8f" translate="yes" xml:space="preserve">
          <source>If the values in question are integers instead of strings, you can save quite a lot of space by using bit strings instead:</source>
          <target state="translated">問題の値が文字列ではなく整数である場合、代わりにビット文字列を使うことでかなりのスペースを節約することができます。</target>
        </trans-unit>
        <trans-unit id="82319500e10e873dfa0526d703945d89b55231f8" translate="yes" xml:space="preserve">
          <source>If the values of &lt;code&gt;$mod&lt;/code&gt; and &lt;code&gt;$prereq&lt;/code&gt; have not been scrubbed, however, this presents security implications.</source>
          <target state="translated">ただし、 &lt;code&gt;$mod&lt;/code&gt; と &lt;code&gt;$prereq&lt;/code&gt; の値がスクラブされていない場合、これはセキュリティに影響を及ぼします。</target>
        </trans-unit>
        <trans-unit id="73e7da39372f108fea1077e432f6f8a5490ef1c9" translate="yes" xml:space="preserve">
          <source>If the variable is locked by another thread, the &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; call will block until it's available. &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; is recursive, so multiple calls to &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; are safe--the variable will remain locked until the outermost lock on the variable goes out of scope.</source>
          <target state="translated">変数が別のスレッドによってロックされている場合、 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 呼び出しは、使用可能になるまでブロックされます。 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; は再帰的であるため、 &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; への複数の呼び出しは安全です。変数の最も外側のロックがスコープ外になるまで、変数はロックされたままになります。</target>
        </trans-unit>
        <trans-unit id="d43da14411193cb05153c9413f27d1e7c410d9b1" translate="yes" xml:space="preserve">
          <source>If the variable is locked by another thread, the &lt;code&gt;lock&lt;/code&gt; call will block until it's available. &lt;code&gt;lock&lt;/code&gt; is recursive, so multiple calls to &lt;code&gt;lock&lt;/code&gt; are safe--the variable will remain locked until the outermost lock on the variable goes out of scope.</source>
          <target state="translated">変数が別のスレッドによってロックされている場合、 &lt;code&gt;lock&lt;/code&gt; 呼び出しは使用可能になるまでブロックされます。 &lt;code&gt;lock&lt;/code&gt; は再帰的であるため、複数回の &lt;code&gt;lock&lt;/code&gt; 呼び出しは安全です。変数の最も外側のロックがスコープ外になるまで、変数はロックされたままになります。</target>
        </trans-unit>
        <trans-unit id="82a274850c71686d34e3baa803737f0dedda24d3" translate="yes" xml:space="preserve">
          <source>If the variable is not set, or if the head of space-separated list is empty, the best available package is loaded.</source>
          <target state="translated">変数が設定されていない場合や、スペース区切りリストの先頭が空の場合は、利用可能な最良のパッケージがロードされます。</target>
        </trans-unit>
        <trans-unit id="332df1267de6f0a87c793832b4c5597a101a667d" translate="yes" xml:space="preserve">
          <source>If the warning comes from other than I/O, this diagnostic probably indicates that incorrect results are being obtained. You should examine your code to determine how a wide character is getting to an operation that doesn't handle them.</source>
          <target state="translated">警告がI/O以外から来ている場合、この診断はおそらく間違った結果が得られていることを示しています。コードを調べて、ワイド文字を処理しない操作にどのようにしてワイド文字が到達しているのかを判断する必要があります。</target>
        </trans-unit>
        <trans-unit id="80b83d018cb7a8db8be65fb54c56d8b5b7e8cb24" translate="yes" xml:space="preserve">
          <source>If the warnings category, &lt;code&gt;$category&lt;/code&gt; , has been set to &quot;FATAL&quot; in the calling module then die. Otherwise return.</source>
          <target state="translated">警告カテゴリ &lt;code&gt;$category&lt;/code&gt; が呼び出しモジュールで &quot;FATAL&quot;に設定されている場合は、終了します。それ以外の場合は戻ります。</target>
        </trans-unit>
        <trans-unit id="834ab1c45a3f45ffae4b5d0f33ce4babb0604bab" translate="yes" xml:space="preserve">
          <source>If the warnings category, &lt;code&gt;$category&lt;/code&gt;, has been set to &quot;FATAL&quot; in the calling module then die. Otherwise return.</source>
          <target state="translated">警告カテゴリ &lt;code&gt;$category&lt;/code&gt; が呼び出し元モジュールで「FATAL」に設定されている場合、終了します。それ以外の場合は戻ります。</target>
        </trans-unit>
        <trans-unit id="a5e41570d4b0ba06d69d1ed0ddaa70c09dffea4d" translate="yes" xml:space="preserve">
          <source>If the whole program is Unicode (signified by using 8-bit &lt;b&gt;U&lt;/b&gt;nicode &lt;b&gt;T&lt;/b&gt;ransformation &lt;b&gt;F&lt;/b&gt;ormat), then all literal strings within it must be Unicode.</source>
          <target state="translated">プログラム全体がUnicodeである場合（8ビットの使用によって示さ&lt;b&gt;U&lt;/b&gt; nicode &lt;b&gt;T&lt;/b&gt; ransformation &lt;b&gt;Fの&lt;/b&gt;書式（O））を、その中のすべてのリテラル文字列は、Unicodeでなければなりません。</target>
        </trans-unit>
        <trans-unit id="9de09cf9a89a26f0cb448619847689ec2527d3db" translate="yes" xml:space="preserve">
          <source>If the whole program is Unicode (signified by using 8-bit &lt;b&gt;U&lt;/b&gt;nicode &lt;b&gt;T&lt;/b&gt;ransformation &lt;b&gt;F&lt;/b&gt;ormat), then all strings within it must be Unicode.</source>
          <target state="translated">プログラム全体がUnicodeである場合（8ビットの使用によって示さ&lt;b&gt;U&lt;/b&gt; nicode &lt;b&gt;T&lt;/b&gt; ransformation &lt;b&gt;Fの&lt;/b&gt;書式（O））を、その内のすべての文字列は、Unicodeでなければなりません。</target>
        </trans-unit>
        <trans-unit id="9cdf7f58b72ea89ccbb496e2eb6b9b4bc7fadaa5" translate="yes" xml:space="preserve">
          <source>If the word &lt;code&gt;while&lt;/code&gt; is replaced by the word &lt;code&gt;until&lt;/code&gt; , the sense of the test is reversed, but the conditional is still tested before the first iteration.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; という単語が &lt;code&gt;until&lt;/code&gt; によって置き換えられる場合、テストの意味は逆になりますが、条件は最初の反復の前にテストされます。</target>
        </trans-unit>
        <trans-unit id="bb24c8d0dff7253263fabb1012737a1c5185daa5" translate="yes" xml:space="preserve">
          <source>If the word &lt;code&gt;while&lt;/code&gt; is replaced by the word &lt;code&gt;until&lt;/code&gt;, the sense of the test is reversed, but the conditional is still tested before the first iteration.</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; という単語が &lt;code&gt;until&lt;/code&gt; という単語に置き換えられた場合、テストの意味は逆になりますが、条件は最初の反復の前にテストされます。</target>
        </trans-unit>
        <trans-unit id="10166029e96e7fe67231308fbe3c16515584c847" translate="yes" xml:space="preserve">
          <source>If there are additional casing rules that apply only in certain locales, an additional key for each will be defined in the returned hash. Each such key will be its locale name, defined as a 2-letter ISO 3166 country code, possibly followed by a &quot;_&quot; and a 2-letter ISO language code (possibly followed by a &quot;_&quot; and a variant code). You can find the lists of all possible locales, see &lt;a href=&quot;../locale/country&quot;&gt;Locale::Country&lt;/a&gt; and &lt;a href=&quot;../locale/language&quot;&gt;Locale::Language&lt;/a&gt;. (In Unicode 6.0, the only locales returned by this function are &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;az&lt;/code&gt; .)</source>
          <target state="translated">特定のロケールにのみ適用される追加の大文字と小文字の規則がある場合、それぞれの追加のキーが返されるハッシュで定義されます。そのような各キーは、ロケール名であり、2文字のISO 3166国コードとして定義され、その後に「_」と2文字のISO言語コードが続く場合があります（「_」とバリアントコードが後に続く場合があります）。可能なすべてのロケールのリストを見つけることができます&lt;a href=&quot;../locale/country&quot;&gt;。Locale :: Country&lt;/a&gt;および&lt;a href=&quot;../locale/language&quot;&gt;Locale :: Languageを&lt;/a&gt;参照してください。 （Unicode 6.0では、この関数によって返されるロケールは &lt;code&gt;lt&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;az&lt;/code&gt; のみです。）</target>
        </trans-unit>
        <trans-unit id="c9b92a1c0c95f09069f2ada78514b6761e600855" translate="yes" xml:space="preserve">
          <source>If there are additional casing rules that apply only in certain locales, an additional key for each will be defined in the returned hash. Each such key will be its locale name, defined as a 2-letter ISO 3166 country code, possibly followed by a &quot;_&quot; and a 2-letter ISO language code (possibly followed by a &quot;_&quot; and a variant code). You can find the lists of all possible locales, see &lt;a href=&quot;Locale::Country&quot;&gt;Locale::Country&lt;/a&gt; and &lt;a href=&quot;Locale::Language&quot;&gt;Locale::Language&lt;/a&gt;. (In Unicode 6.0, the only locales returned by this function are &lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;tr&lt;/code&gt;, and &lt;code&gt;az&lt;/code&gt;.)</source>
          <target state="translated">特定のロケールにのみ適用される追加のケーシングルールがある場合、それぞれの追加のキーが返されるハッシュで定義されます。このような各キーはロケール名であり、2文字のISO 3166国コードとして定義され、その後に「_」と2文字のISO言語コード（「_」とバリアントコードが続く場合があります）が続く場合があります。可能なすべてのロケールのリストを見つけることができます&lt;a href=&quot;Locale::Country&quot;&gt;。Locale:: Country&lt;/a&gt;および&lt;a href=&quot;Locale::Language&quot;&gt;Locale :: Languageを&lt;/a&gt;参照してください。（Unicode 6.0では、この関数によって返されるロケールは &lt;code&gt;lt&lt;/code&gt; 、 &lt;code&gt;tr&lt;/code&gt; 、および &lt;code&gt;az&lt;/code&gt; のみです。）</target>
        </trans-unit>
        <trans-unit id="10187abc55d0802b4b3951872dffe3ad9dfa823c" translate="yes" xml:space="preserve">
          <source>If there are fewer than &lt;code&gt;$count&lt;/code&gt; items in the list then the function will return once all of them have been randomly selected; effectively the function behaves similarly to &lt;a href=&quot;#shuffle&quot;&gt;&quot;shuffle&quot;&lt;/a&gt;.</source>
          <target state="translated">リスト内のアイテムが &lt;code&gt;$count&lt;/code&gt; 未満の場合、それらすべてがランダムに選択されると、関数は戻ります。事実上、関数は&lt;a href=&quot;#shuffle&quot;&gt;「シャッフル」&lt;/a&gt;と同様に動作します。</target>
        </trans-unit>
        <trans-unit id="c91a8fd751937bd233ccdf982bb8140e1a1456b2" translate="yes" xml:space="preserve">
          <source>If there are more pack codes or if the repeat count of a field or a group is larger than what the remainder of the input string allows, the result is not well defined: the repeat count may be decreased, or &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; may produce empty strings or zeros, or it may raise an exception. If the input string is longer than one described by the TEMPLATE, the remainder of that input string is ignored.</source>
          <target state="translated">パックコードが多い場合、またはフィールドまたはグループの繰り返し回数が入力文字列の残りの部分で許可されている数よりも多い場合、結果は明確に定義されていません。繰り返し回数が減るか、&lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; &lt;/a&gt;すると空の文字列が生成されるか、ゼロ、または例外が発生する可能性があります。入力文字列がTEMPLATEで記述されたものより長い場合、その入力文字列の残りは無視されます。</target>
        </trans-unit>
        <trans-unit id="c264a98231858c182cc8e558543c798b7c30e957" translate="yes" xml:space="preserve">
          <source>If there are more pack codes or if the repeat count of a field or a group is larger than what the remainder of the input string allows, the result is not well defined: the repeat count may be decreased, or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; may produce empty strings or zeros, or it may raise an exception. If the input string is longer than one described by the TEMPLATE, the remainder of that input string is ignored.</source>
          <target state="translated">より多くのパックコードがある場合、またはフィールドまたはグループの繰り返し数が残りの入力文字列で許可されている数より大きい場合、結果は明確に定義されていません。繰り返し数が減少するか、 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; が空になる場合があります文字列またはゼロ、または例外が発生する可能性があります。入力文字列がTEMPLATEによって記述されたものより長い場合、その入力文字列の残りは無視されます。</target>
        </trans-unit>
        <trans-unit id="b76f7ceb246d4c2d7fabcbfce30f4b0cda04fc65" translate="yes" xml:space="preserve">
          <source>If there are more pack codes or if the repeat count of a field or a group is larger than what the remainder of the input string allows, the result is not well defined: the repeat count may be decreased, or &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; may produce empty strings or zeros, or it may raise an exception. If the input string is longer than one described by the TEMPLATE, the remainder of that input string is ignored.</source>
          <target state="translated">より多くのパックコードがある場合、またはフィールドまたはグループの繰り返し数が残りの入力文字列で許可されている数より大きい場合、結果は明確に定義されていません。繰り返し数が減少するか、 &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; が空になる場合があります文字列またはゼロ、または例外が発生する可能性があります。入力文字列がTEMPLATEによって記述されたものより長い場合、その入力文字列の残りは無視されます。</target>
        </trans-unit>
        <trans-unit id="68b83d3193021444c248ae823551b36481a4afcb" translate="yes" xml:space="preserve">
          <source>If there are multiple threads running, &lt;a href=&quot;#close-FILEHANDLE&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; on a filehandle from a piped open returns true without waiting for the child process to terminate, if the filehandle is still open in another thread.</source>
          <target state="translated">複数のスレッドが実行されている場合、ファイルハンドルが別のスレッドでまだ開いていると、パイプされたオープンからファイルハンドルを&lt;a href=&quot;#close-FILEHANDLE&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;と、子プロセスが終了するのを待たずにtrueが返されます。</target>
        </trans-unit>
        <trans-unit id="cf8ae3d8fd9e42e9aba417d2727a1cef25f1654d" translate="yes" xml:space="preserve">
          <source>If there are multiple threads running, &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; on a filehandle from a piped open returns true without waiting for the child process to terminate, if the filehandle is still open in another thread.</source>
          <target state="translated">複数のスレッドが実行されている場合、ファイルハンドルがまだ別のスレッドで開いていると、パイプ処理されたオープンからファイルハンドルを &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; と、子プロセスの終了を待たずにtrueが返されます。</target>
        </trans-unit>
        <trans-unit id="2d703ea78c6bd312ccc4d4536374984caf742a2c" translate="yes" xml:space="preserve">
          <source>If there are multiple threads running, &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; on a filehandle from a piped open returns true without waiting for the child process to terminate, if the filehandle is still open in another thread.</source>
          <target state="translated">複数のスレッドが実行されている場合、ファイルハンドルがまだ別のスレッドで開いていると、パイプ処理されたオープンからファイルハンドルを &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; と、子プロセスの終了を待たずにtrueが返されます。</target>
        </trans-unit>
        <trans-unit id="b367c7608072c7b2e27d64beb7fdc3ebcfc5757e" translate="yes" xml:space="preserve">
          <source>If there are no case mappings for the &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;, or if all three possible mappings (</source>
          <target state="translated">&lt;a href=&quot;#code-point-argument&quot;&gt;「コードポイント引数」&lt;/a&gt;のケースマッピングがない場合、または3つの可能なマッピングすべての場合（</target>
        </trans-unit>
        <trans-unit id="c3ca3b8e4b7d3fd6327a3431ba332cb4654544b7" translate="yes" xml:space="preserve">
          <source>If there are no case mappings for the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;, or if all three possible mappings (</source>
          <target state="translated">&lt;a href=&quot;#code-point-argument&quot;&gt;コードポイント引数&lt;/a&gt;のケースマッピングがない場合、または3つの可能なマッピングすべて（</target>
        </trans-unit>
        <trans-unit id="4d288bab40c0346d55a3c0eb77940eab7a6641ad" translate="yes" xml:space="preserve">
          <source>If there are no shell metacharacters in the argument of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, Perl runs the command directly, without using the shell, and can correctly report whether the command started.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; の引数にシェルメタキャラクターがない場合、Perlはシェルを使用せずにコマンドを直接実行し、コマンドが開始したかどうかを正しく報告できます。</target>
        </trans-unit>
        <trans-unit id="07b923cdb7f2db79984c43279c6e1908fa7560e3" translate="yes" xml:space="preserve">
          <source>If there are no shell metacharacters in the argument of &lt;code&gt;open()&lt;/code&gt;, Perl runs the command directly, without using the shell, and can correctly report whether the command started.</source>
          <target state="translated">&lt;code&gt;open()&lt;/code&gt; の引数にシェルのメタ文字がない場合、Perlはシェルを使用せずにコマンドを直接実行し、コマンドが開始されたかどうかを正しく報告できます。</target>
        </trans-unit>
        <trans-unit id="83b3c9dc933e2482f8eba281e591135e3899389e" translate="yes" xml:space="preserve">
          <source>If there are no threads blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the variable, the signal is discarded.</source>
          <target state="translated">変数の &lt;code&gt;cond_wait&lt;/code&gt; でブロックされているスレッドがない場合、シグナルは破棄されます。</target>
        </trans-unit>
        <trans-unit id="dcf5c5ee7e0424ea7ada5c7826f4b90fdb2a116c" translate="yes" xml:space="preserve">
          <source>If there are no threads blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the variable, the signal is discarded. By always locking before signaling, you can (with care), avoid signaling before another thread has entered cond_wait().</source>
          <target state="translated">変数の &lt;code&gt;cond_wait&lt;/code&gt; でブロックされているスレッドがない場合、シグナルは破棄されます。シグナルの前に常にロックすることで、別のスレッドがcond_wait（）に入る前にシグナルを避けることができます（慎重に）。</target>
        </trans-unit>
        <trans-unit id="a5de19948908467a5a983001d47b7d9a0689b746" translate="yes" xml:space="preserve">
          <source>If there are no valid digits between the braces, the generated character is the NULL character (&lt;code&gt;\x{00}&lt;/code&gt; ). However, an explicit empty brace (&lt;code&gt;\x{}&lt;/code&gt; ) will not cause a warning (currently).</source>
          <target state="translated">中括弧の間に有効な数字がない場合、生成される文字はNULL文字（ &lt;code&gt;\x{00}&lt;/code&gt; ）です。ただし、明示的な空の括弧（ &lt;code&gt;\x{}&lt;/code&gt; ）は（現在）警告を引き起こしません。</target>
        </trans-unit>
        <trans-unit id="954b2d334088acf7ff9ea75b92d63622f7bf51c0" translate="yes" xml:space="preserve">
          <source>If there are no valid digits between the braces, the generated character is the NULL character (&lt;code&gt;\x{00}&lt;/code&gt;). However, an explicit empty brace (&lt;code&gt;\x{}&lt;/code&gt;) will not cause a warning (currently).</source>
          <target state="translated">中括弧の間に有効な数字がない場合、生成される文字はNULL文字（ &lt;code&gt;\x{00}&lt;/code&gt; ）です。ただし、明示的な空の中括弧（ &lt;code&gt;\x{}&lt;/code&gt; ）は（現在）警告を引き起こしません。</target>
        </trans-unit>
        <trans-unit id="b342c6d59112da790e47e12118a22cde8dbcaf22" translate="yes" xml:space="preserve">
          <source>If there are only a few field hashes to declare, it is simplest to</source>
          <target state="translated">宣言するフィールドハッシュが数個しかない場合は、次のようにするのが最も簡単です。</target>
        </trans-unit>
        <trans-unit id="ae8e9a2c571cd018342d9c2118caec048fd77da4" translate="yes" xml:space="preserve">
          <source>If there are only three arguments and the third argument is a hash reference, the keys of that hash can have values &lt;code&gt;dict&lt;/code&gt; , &lt;code&gt;fold&lt;/code&gt; , and &lt;code&gt;comp&lt;/code&gt; or &lt;code&gt;xfrm&lt;/code&gt; (see below), and their corresponding values will be used as the parameters.</source>
          <target state="translated">引数が3つしかなく、3番目の引数がハッシュ参照である場合、そのハッシュのキーは &lt;code&gt;dict&lt;/code&gt; 、 &lt;code&gt;fold&lt;/code&gt; 、および &lt;code&gt;comp&lt;/code&gt; または &lt;code&gt;xfrm&lt;/code&gt; （以下を参照）の値を持つことができ、対応する値がパラメーターとして使用されます。</target>
        </trans-unit>
        <trans-unit id="e81956a0441efe3f26746423f2c17c9cee5f29f4" translate="yes" xml:space="preserve">
          <source>If there are only three arguments and the third argument is a hash reference, the keys of that hash can have values &lt;code&gt;dict&lt;/code&gt;, &lt;code&gt;fold&lt;/code&gt;, and &lt;code&gt;comp&lt;/code&gt; or &lt;code&gt;xfrm&lt;/code&gt; (see below), and their corresponding values will be used as the parameters.</source>
          <target state="translated">引数が3つだけで、3番目の引数がハッシュ参照である場合、そのハッシュのキーには &lt;code&gt;dict&lt;/code&gt; 、 &lt;code&gt;fold&lt;/code&gt; 、 &lt;code&gt;comp&lt;/code&gt; または &lt;code&gt;xfrm&lt;/code&gt; の値を指定でき（以下を参照）、対応する値がパラメーターとして使用されます。</target>
        </trans-unit>
        <trans-unit id="1e86b013905dd12651149e8ec83c3ae6cf6c6b73" translate="yes" xml:space="preserve">
          <source>If there are two modules using &lt;code&gt;FindBin&lt;/code&gt; from different directories under the same interpreter, this won't work. Since &lt;code&gt;FindBin&lt;/code&gt; uses a &lt;code&gt;BEGIN&lt;/code&gt; block, it'll be executed only once, and only the first caller will get it right. This is a problem under mod_perl and other persistent Perl environments, where you shouldn't use this module. Which also means that you should avoid using &lt;code&gt;FindBin&lt;/code&gt; in modules that you plan to put on CPAN. To make sure that &lt;code&gt;FindBin&lt;/code&gt; will work is to call the &lt;code&gt;again&lt;/code&gt; function:</source>
          <target state="translated">同じインタープリターの下の異なるディレクトリーから &lt;code&gt;FindBin&lt;/code&gt; を使用する2つのモジュールがある場合、これは機能しません。 &lt;code&gt;FindBin&lt;/code&gt; は &lt;code&gt;BEGIN&lt;/code&gt; ブロックを使用するため、1回だけ実行され、最初の呼び出し元のみが正しく実行します。これは、このモジュールを使用すべきではないmod_perlおよびその他の永続的なPerl環境での問題です。これは、CPANに配置する予定のモジュールで &lt;code&gt;FindBin&lt;/code&gt; を使用しないようにする必要があることも意味します。 &lt;code&gt;FindBin&lt;/code&gt; が機能することを確認するには、 &lt;code&gt;again&lt;/code&gt; 関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="fcc3c3e2760c5e396f33222005be848fc9fe18e0" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK, it is always executed just before the conditional is about to be evaluated again. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; ブロックがある場合は、常に条件が再評価される直前に実行されます。したがって、 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ステートメントでループが継続されている場合でも、ループ変数をインクリメントするために使用できます。</target>
        </trans-unit>
        <trans-unit id="47225f2cbf093a41e464bfd235d898451ab3fec3" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;continue&lt;/code&gt; BLOCK, it is always executed just before the conditional is about to be evaluated again. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;next&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;continue&lt;/code&gt; ブロックがある場合は、条件が再度評価される直前に常に実行されます。したがって、 &lt;code&gt;next&lt;/code&gt; ステートメントを介してループが継続されている場合でも、ループ変数をインクリメントするために使用できます。</target>
        </trans-unit>
        <trans-unit id="8b36be5061281671022cf399b379651681b1d4d0" translate="yes" xml:space="preserve">
          <source>If there is a case folding for that code point, a reference to a hash with the following fields is returned:</source>
          <target state="translated">そのコードポイントに case folding がある場合、以下のフィールドを持つハッシュへの参照が返されます。</target>
        </trans-unit>
        <trans-unit id="791dad5bf77a3c7753599734b55d1d951806d6b3" translate="yes" xml:space="preserve">
          <source>If there is a possibility of malformed input, use instead:</source>
          <target state="translated">不正な入力の可能性がある場合は、代わりに使用します。</target>
        </trans-unit>
        <trans-unit id="6424bf8b1f44f30e366f5038ca9bafadec447990" translate="yes" xml:space="preserve">
          <source>If there is a read or write timeout &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return &quot;[$pkg] Timeout&quot; (where $pkg is the name of the class that subclassed &lt;code&gt;Net::Cmd&lt;/code&gt; ). The _set_status_timeout() method can be overridden to set a different message (by calling set_status()) or otherwise trap this error.</source>
          <target state="translated">読み取りまたは書き込みのタイムアウトがある場合、 &lt;code&gt;code()&lt;/code&gt; は &quot;421&quot;（一時的な接続障害 &lt;code&gt;message()&lt;/code&gt; を返し、message（）は &quot;[$ pkg] Timeout&quot;を返します（ $ pkgは &lt;code&gt;Net::Cmd&lt;/code&gt; をサブクラス化したクラスの名前です））。_set_status_timeout（）メソッドをオーバーライドして、別のメッセージを設定する（set_status（）を呼び出す）か、このエラーをトラップすることができます。</target>
        </trans-unit>
        <trans-unit id="5c5ddbe053c3383dcb2da814550e984622b561fa" translate="yes" xml:space="preserve">
          <source>If there is a read or write timeout &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return &quot;[$pkg] Timeout&quot; (where $pkg is the name of the class that subclassed &lt;code&gt;Net::Cmd&lt;/code&gt;). The _set_status_timeout() method can be overridden to set a different message (by calling set_status()) or otherwise trap this error.</source>
          <target state="translated">読み取りまたは書き込みタイムアウトがある場合、 &lt;code&gt;code()&lt;/code&gt; は「421」（一時的な接続障害 &lt;code&gt;message()&lt;/code&gt; を返し、message（）は「[$ pkg] Timeout」（$ pkgは &lt;code&gt;Net::Cmd&lt;/code&gt; をサブクラス化したクラスの名前）を返します。）。 _set_status_timeout（）メソッドをオーバーライドして、別のメッセージを設定するか（set_status（）を呼び出すことにより）、またはこのエラーをトラップすることができます。</target>
        </trans-unit>
        <trans-unit id="5a08eec9ef05dccf9a00729a1af45acee83fa1a4" translate="yes" xml:space="preserve">
          <source>If there is a syntax error or runtime error, or a &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; statement is executed, &lt;code&gt;eval&lt;/code&gt; returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; in scalar context, or an empty list in list context, and &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; is set to the error message. (Prior to 5.16, a bug caused &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; to be returned in list context for syntax errors, but not for runtime errors.) If there was no error, &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; is set to the empty string. A control flow operator like &lt;a href=&quot;#last-LABEL&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt; can bypass the setting of &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt;. Beware that using &lt;code&gt;eval&lt;/code&gt; neither silences Perl from printing warnings to STDERR, nor does it stuff the text of warning messages into &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt;. To do either of those, you have to use the &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&lt;code&gt;$SIG{__WARN__}&lt;/code&gt;&lt;/a&gt; facility, or turn off warnings inside the BLOCK or EXPR using &lt;code&gt;no warnings 'all'&lt;/code&gt;. See &lt;a href=&quot;#warn-LIST&quot;&gt;&lt;code&gt;warn&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;, and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">構文エラーまたはランタイムエラーがある場合、または&lt;a href=&quot;#die-LIST&quot;&gt; &lt;code&gt;die&lt;/code&gt; &lt;/a&gt;ステートメントが実行された場合、 &lt;code&gt;eval&lt;/code&gt; はスカラーコンテキストで&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;を返すか、リストコンテキストで空のリストを返し、&lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt;がエラーメッセージに設定されます。 （5.16より前は、バグにより、構文エラーではリストコンテキストに&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;が返されましたが、ランタイムエラーでは返されませんでした。）エラーがなかった場合、&lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt;は空の文字列に設定されます。&lt;a href=&quot;#last-LABEL&quot;&gt; &lt;code&gt;last&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;#goto-LABEL&quot;&gt; &lt;code&gt;goto&lt;/code&gt; &lt;/a&gt;などの制御フロー演算子は、&lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt;設定をバイパスできます。 &lt;code&gt;eval&lt;/code&gt; を使用しても、Perlが警告をSTDERRに出力するのを黙らせたり、警告メッセージのテキストを&lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt;に詰め込んだりしないことに注意してください。。これらのいずれかを行うには、&lt;a href=&quot;perlvar#%25SIG&quot;&gt; &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; &lt;/a&gt;機能を使用するか &lt;code&gt;no warnings 'all'&lt;/code&gt; を使用してBLOCKまたはEXPR内の警告をオフにする必要があります。&lt;a href=&quot;#warn-LIST&quot;&gt; &lt;code&gt;warn&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;、および&lt;a href=&quot;warnings&quot;&gt;warningsを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="11aba41a92baa1006f7ccfb764892fd564d365da" translate="yes" xml:space="preserve">
          <source>If there is a syntax error or runtime error, or a &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; statement is executed, &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context or an empty list in list context, and &lt;code&gt;$@&lt;/code&gt; is set to the error message. (Prior to 5.16, a bug caused &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to be returned in list context for syntax errors, but not for runtime errors.) If there was no error, &lt;code&gt;$@&lt;/code&gt; is set to the empty string. A control flow operator like &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; can bypass the setting of &lt;code&gt;$@&lt;/code&gt; . Beware that using &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; neither silences Perl from printing warnings to STDERR, nor does it stuff the text of warning messages into &lt;code&gt;$@&lt;/code&gt; . To do either of those, you have to use the &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; facility, or turn off warnings inside the BLOCK or EXPR using &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; . See &lt;a href=&quot;warn&quot;&gt;warn&lt;/a&gt;, &lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt;, and &lt;a href=&quot;../warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">構文エラーまたは実行時エラーがあるか、 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ステートメントが実行されると、 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; はスカラーコンテキストで &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返すか、リストコンテキストで空のリストを返し、 &lt;code&gt;$@&lt;/code&gt; がエラーメッセージに設定されます。 （5.16より前のバグでは、 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が構文エラーのリストコンテキストで返されましたが、ランタイムエラーは返されませんでした。）エラーがなかった場合、 &lt;code&gt;$@&lt;/code&gt; は空の文字列に設定されます。 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; などの制御フロー演算子は、 &lt;code&gt;$@&lt;/code&gt; 設定をバイパスできます。 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; を使用すると、Perlが警告をSTDERRに出力することを止めることも、警告メッセージのテキストを &lt;code&gt;$@&lt;/code&gt; に詰め込まないことにも注意してください。。これらのいずれかを行うには、 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 機能を使用するか &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; を使用せずに BLOCKまたはEXPR内の警告をオフにする必要があります。&lt;a href=&quot;warn&quot;&gt;warn&lt;/a&gt;、&lt;a href=&quot;../perlvar&quot;&gt;perlvar&lt;/a&gt;、および&lt;a href=&quot;../warnings&quot;&gt;warningsを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ebacccba519ce29c0edb6165a1d7c06041545422" translate="yes" xml:space="preserve">
          <source>If there is a syntax error or runtime error, or a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; statement is executed, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in scalar context or an empty list in list context, and &lt;code&gt;$@&lt;/code&gt; is set to the error message. (Prior to 5.16, a bug caused &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to be returned in list context for syntax errors, but not for runtime errors.) If there was no error, &lt;code&gt;$@&lt;/code&gt; is set to the empty string. A control flow operator like &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; can bypass the setting of &lt;code&gt;$@&lt;/code&gt; . Beware that using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; neither silences Perl from printing warnings to STDERR, nor does it stuff the text of warning messages into &lt;code&gt;$@&lt;/code&gt; . To do either of those, you have to use the &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; facility, or turn off warnings inside the BLOCK or EXPR using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; . See &lt;a href=&quot;#warn&quot;&gt;warn&lt;/a&gt;, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;, and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">構文エラーまたは実行時エラーがあるか、 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ステートメントが実行されると、 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; はスカラーコンテキストで &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返すか、リストコンテキストで空のリストを返し、 &lt;code&gt;$@&lt;/code&gt; がエラーメッセージに設定されます。 （5.16より前のバグでは、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が構文エラーのリストコンテキストで返されましたが、ランタイムエラーは返されませんでした。）エラーがなかった場合、 &lt;code&gt;$@&lt;/code&gt; は空の文字列に設定されます。 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; などの制御フロー演算子は、 &lt;code&gt;$@&lt;/code&gt; 設定をバイパスできます。 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; を使用すると、Perlが警告をSTDERRに出力することを止めることも、警告メッセージのテキストを &lt;code&gt;$@&lt;/code&gt; に詰め込まないことにも注意してください。。これらのいずれかを行うには、 &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; 機能を使用するか &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'all'&lt;/code&gt; を使用せずに BLOCKまたはEXPR内の警告をオフにする必要があります。&lt;a href=&quot;#warn&quot;&gt;warn&lt;/a&gt;、&lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;、および&lt;a href=&quot;warnings&quot;&gt;warningsを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0363f8d22dbc9b336b291dea3342e0d06c042240" translate="yes" xml:space="preserve">
          <source>If there is already a subroutine of the specified name, then the new sub will either replace the existing one in the glob or be merged with the existing one. A warning may be generated about redefinition.</source>
          <target state="translated">指定した名前のサブルーチンが既に存在する場合、新しいサブは、グロブ内の既存のサブを置き換えるか、既存のサブとマージされます。再定義に関する警告が発生する場合があります。</target>
        </trans-unit>
        <trans-unit id="f502d2c87f9e6854805c11486fbe0df87ab65e99" translate="yes" xml:space="preserve">
          <source>If there is already a subroutine of the specified name, then the new sub will replace the existing one in the glob. A warning may be generated about the redefinition.</source>
          <target state="translated">指定した名前のサブルーチンが既に存在する場合は、新しいサブが glob 内の既存のサブを置換します。再定義に関する警告が発生する場合があります。</target>
        </trans-unit>
        <trans-unit id="9b62d67db30c0ed8a724a981f3cdb26a57d7bac9" translate="yes" xml:space="preserve">
          <source>If there is already a subroutine of the specified name, then the new sub will replace the existing one in the glob. A warning may be generated about the redefinition. If the old subroutine was &lt;code&gt;CvCONST&lt;/code&gt; then the decision about whether to warn is influenced by an expectation about whether the new subroutine will become a constant of similar value. That expectation is determined by &lt;code&gt;const_svp&lt;/code&gt;. (Note that the call to this function doesn't make the new subroutine &lt;code&gt;CvCONST&lt;/code&gt; in any case; that is left to the caller.) If &lt;code&gt;const_svp&lt;/code&gt; is null then it indicates that the new subroutine will not become a constant. If &lt;code&gt;const_svp&lt;/code&gt; is non-null then it indicates that the new subroutine will become a constant, and it points to an &lt;code&gt;SV*&lt;/code&gt; that provides the constant value that the subroutine will have.</source>
          <target state="translated">指定された名前のサブルーチンがすでに存在する場合、新しいサブルーチンがglob内の既存のサブルーチンを置き換えます。再定義について警告が生成される場合があります。古いサブルーチンが &lt;code&gt;CvCONST&lt;/code&gt; であった場合、警告するかどうかの決定は、新しいサブルーチンが同様の値の定数になるかどうかについての期待に影響されます。その期待値は &lt;code&gt;const_svp&lt;/code&gt; によって決定されます。 （この関数の呼び出しは、どのような場合でも新しいサブルーチン &lt;code&gt;CvCONST&lt;/code&gt; を作成しないことに注意してください。これは、呼び出し元に任されます。） &lt;code&gt;const_svp&lt;/code&gt; がnullの場合、新しいサブルーチンが定数にならないことを示します。 &lt;code&gt;const_svp&lt;/code&gt; がnull以外の場合、新しいサブルーチンが定数になることを示し、 &lt;code&gt;SV*&lt;/code&gt; サブルーチンが持つ定数値を提供するSV *。</target>
        </trans-unit>
        <trans-unit id="5466934b0ce09952bbdf7a873d8e98baf5e63870" translate="yes" xml:space="preserve">
          <source>If there is an error then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">エラーがある場合は、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="b85ca592364b34a60190d51f6450258a4cd0c81b" translate="yes" xml:space="preserve">
          <source>If there is an error then &lt;code&gt;undef&lt;/code&gt; will be returned.</source>
          <target state="translated">エラーが発生した場合は、 &lt;code&gt;undef&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="467d2ed550f37bc1b9fda912fd43e11ff12b4118" translate="yes" xml:space="preserve">
          <source>If there is any question about whether a given patch might merit inclusion in a maint release, then it almost certainly should not be included.</source>
          <target state="translated">与えられたパッチがメインのリリースに含める価値があるかどうかについて疑問がある場合、それはほぼ確実に含めるべきではありません。</target>
        </trans-unit>
        <trans-unit id="ca419a7d4011e71c524719322dfff4afd6d50991" translate="yes" xml:space="preserve">
          <source>If there is more than one argument in LIST, this calls &lt;a href=&quot;http://man.he.net/man3/execvp&quot;&gt;execvp(3)&lt;/a&gt; with the arguments in LIST. If there is only one element in LIST, the argument is checked for shell metacharacters, and if there are any, the entire argument is passed to the system's command shell for parsing (this is &lt;code&gt;/bin/sh -c&lt;/code&gt; on Unix platforms, but varies on other platforms). If there are no shell metacharacters in the argument, it is split into words and passed directly to &lt;code&gt;execvp&lt;/code&gt;, which is more efficient. Examples:</source>
          <target state="translated">LISTに複数の引数がある場合、これはLISTの引数を使用して&lt;a href=&quot;http://man.he.net/man3/execvp&quot;&gt;execvp（3）&lt;/a&gt;を呼び出します。LISTに要素が1つしかない場合は、引数のシェルメタ文字がチェックされ、ある場合は、引数全体がシステムのコマンドシェルに渡されて解析されます（Unixプラットフォームでは &lt;code&gt;/bin/sh -c&lt;/code&gt; ですが、異なります）。他のプラットフォーム）。引数に &lt;code&gt;execvp&lt;/code&gt; 文字がない場合は、単語に分割されてexecvpに直接渡されます。これはより効率的です。例：</target>
        </trans-unit>
        <trans-unit id="0f8376c45472eeb9e97a43b3d977d663509a5686" translate="yes" xml:space="preserve">
          <source>If there is more than one argument in LIST, this calls execvp(3) with the arguments in LIST. If there is only one element in LIST, the argument is checked for shell metacharacters, and if there are any, the entire argument is passed to the system's command shell for parsing (this is &lt;code&gt;/bin/sh -c&lt;/code&gt; on Unix platforms, but varies on other platforms). If there are no shell metacharacters in the argument, it is split into words and passed directly to &lt;code&gt;execvp&lt;/code&gt; , which is more efficient. Examples:</source>
          <target state="translated">LISTに複数の引数がある場合、これはLISTの引数を使用してexecvp（3）を呼び出します。LISTに要素が1つしかない場合、引数のシェルメタキャラクターがチェックされ、存在する場合は、引数全体が解析のためにシステムのコマンドシェルに渡されます（これはUNIXプラットフォームでは &lt;code&gt;/bin/sh -c&lt;/code&gt; ですが、さまざまです）他のプラットフォーム）。引数にシェルのメタ文字がない場合は、単語に分割され、より効率的な &lt;code&gt;execvp&lt;/code&gt; に直接渡されます。例：</target>
        </trans-unit>
        <trans-unit id="2594b97a91aa3fa79863d35058be1a8172ac679a" translate="yes" xml:space="preserve">
          <source>If there is no</source>
          <target state="translated">がない場合は</target>
        </trans-unit>
        <trans-unit id="836d7eec1f71c6b6f4181b3811b03cbac0e80430" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;\E&lt;/code&gt; , case is converted until the end of the string. The regexps &lt;code&gt;\L\u$word&lt;/code&gt; or &lt;code&gt;\u\L$word&lt;/code&gt; convert the first character of &lt;code&gt;$word&lt;/code&gt; to uppercase and the rest of the characters to lowercase.</source>
          <target state="translated">&lt;code&gt;\E&lt;/code&gt; がない場合、文字列の最後まで大文字と小文字が変換されます。正規表現 &lt;code&gt;\L\u$word&lt;/code&gt; または &lt;code&gt;\u\L$word&lt;/code&gt; 変換の最初の文字 &lt;code&gt;$word&lt;/code&gt; 大文字にし、小文字に文字の残りの部分。</target>
        </trans-unit>
        <trans-unit id="f1b2b91591fb1955a250148f5d6f9f32438d8436" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;\E&lt;/code&gt;, case is converted until the end of the string. The regexps &lt;code&gt;\L\u$word&lt;/code&gt; or &lt;code&gt;\u\L$word&lt;/code&gt; convert the first character of &lt;code&gt;$word&lt;/code&gt; to uppercase and the rest of the characters to lowercase.</source>
          <target state="translated">&lt;code&gt;\E&lt;/code&gt; がない場合、大文字と小文字は文字列の終わりまで変換されます。正規表現 &lt;code&gt;\L\u$word&lt;/code&gt; または &lt;code&gt;\u\L$word&lt;/code&gt; 変換の最初の文字 &lt;code&gt;$word&lt;/code&gt; 大文字にし、小文字に文字の残りの部分。</target>
        </trans-unit>
        <trans-unit id="c73d7b3af9d178254858949bc270c269c6e2e60d" translate="yes" xml:space="preserve">
          <source>If there is no INSTALL.SKIP file in the make directory then this value can be used to provide a default.</source>
          <target state="translated">make ディレクトリに INSTALL.SKIP ファイルがない場合は、この値をデフォルトとして使用できます。</target>
        </trans-unit>
        <trans-unit id="3610af61096f12f4c9e6f52b35a24b772a2c16bd" translate="yes" xml:space="preserve">
          <source>If there is no Pod in the given document, then the event structure will be this:</source>
          <target state="translated">与えられたドキュメントにPodがない場合、イベント構造はこのようになります。</target>
        </trans-unit>
        <trans-unit id="349639462c1781c6c7203933948097f1b032dbf1" translate="yes" xml:space="preserve">
          <source>If there is no case folding for the input code point, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">入力コードポイントの大文字と小文字の区別がない場合、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="8fb296c4463c79fc259188fecb37636b958c8768" translate="yes" xml:space="preserve">
          <source>If there is no case folding for the input code point, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">入力コードポイントの大文字と小文字の区別がない場合、 &lt;code&gt;undef&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="20a8d9cc6cec6caebf969b32884584509dabbda2" translate="yes" xml:space="preserve">
          <source>If there is no corresponding capture group defined, then it is a fatal error. Recursing deeper than 50 times without consuming any input string will also result in a fatal error. The maximum depth is compiled into perl, so changing it requires a custom build.</source>
          <target state="translated">対応するキャプチャグループが定義されていない場合は、致命的なエラーとなります。入力文字列を消費せずに50回以上深く再帰することも致命的なエラーになります。最大深度はperlにコンパイルされているので、それを変更するにはカスタムビルドが必要です。</target>
        </trans-unit>
        <trans-unit id="9a6e24a6b319d54eae6772ce7d4930464be16411" translate="yes" xml:space="preserve">
          <source>If there is no corresponding capture group defined, then it is a fatal error. Recursing deeply without consuming any input string will also result in a fatal error. The depth at which that happens is compiled into perl, so it can be changed with a custom build.</source>
          <target state="translated">対応するキャプチャグループが定義されていない場合は、致命的なエラーとなります。入力文字列を消費せずに深く再帰することも致命的なエラーになります。このようなことが起こる深さはperlにコンパイルされているので、カスタムビルドで変更することができます。</target>
        </trans-unit>
        <trans-unit id="28265c4ced5473656451fd65ecb5d6a73bdd1b4e" translate="yes" xml:space="preserve">
          <source>If there is no description, its the same as the parameter to WriteMakefile() documented in &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;.</source>
          <target state="translated">説明がない場合は、&lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils :: MakeMakerに&lt;/a&gt;記載されているWriteMakefile（）のパラメーターと同じです。</target>
        </trans-unit>
        <trans-unit id="c5c7947682ddf8ce5897cbba5d096660017802ec" translate="yes" xml:space="preserve">
          <source>If there is no description, its the same as the parameter to WriteMakefile() documented in ExtUtils::MakeMaker.</source>
          <target state="translated">説明がない場合は、ExtUtils::MakeMaker で説明されている WriteMakefile()のパラメータと同じです。</target>
        </trans-unit>
        <trans-unit id="9a08244ff3de5da70abd74d4f48bc9a98bd5fd63" translate="yes" xml:space="preserve">
          <source>If there is no error, then the method returns the value of the last expression evaluated, or a return statement may be used, just as with subroutines and &lt;b&gt;eval()&lt;/b&gt;. The context (list or scalar) is determined by the caller as usual.</source>
          <target state="translated">エラーがない場合、メソッドは最後に評価された式の値を返します。または、サブルーチンや&lt;b&gt;eval（）&lt;/b&gt;と同様に、returnステートメントを使用できます。コンテキスト（リストまたはスカラー）は、通常どおり呼び出し元によって決定されます。</target>
        </trans-unit>
        <trans-unit id="9fcf9881e5055fcb38df136c867429f9722c1a7e" translate="yes" xml:space="preserve">
          <source>If there is no global precision or accuracy set, &lt;b&gt;and&lt;/b&gt; the operation in question was not called with a requested precision or accuracy, &lt;b&gt;and&lt;/b&gt; the input $x has no accuracy or precision set, then a fallback parameter will be used. For historical reasons, it is called &lt;code&gt;div_scale&lt;/code&gt; and can be accessed via:</source>
          <target state="translated">そこには世界的な精度や確度セットされていない、場合&lt;b&gt;や&lt;/b&gt;問題の操作が要求精度や正確さで呼び出されていなかった、&lt;b&gt;と&lt;/b&gt;入力$ xは何の正確さや精度のセットを持っていない場合、フォールバックパラメータが使用されます。歴史的な理由により、これは &lt;code&gt;div_scale&lt;/code&gt; と呼ばれ、以下を介してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="bbd1fd130f18a572d29a93b5834a0fdb0347ebb7" translate="yes" xml:space="preserve">
          <source>If there is no interactivity then you may still want to look at using something like &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fmodule%2fTemplate&quot;&gt;Template Toolkit&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::TemplateToolkit&quot;&gt;Plack::Middleware::TemplateToolkit&lt;/a&gt; so maintenance of your HTML files (and other assets) is easier.</source>
          <target state="translated">対話性がない場合でも、&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fmodule%2fTemplate&quot;&gt;テンプレートツールキット&lt;/a&gt;や&lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::TemplateToolkit&quot;&gt;Plack :: Middleware :: TemplateToolkitの&lt;/a&gt;ようなものを使用して、HTMLファイル（およびその他のアセット）のメンテナンスが容易になるようにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a299e842222c6ed90a64aa41cd2a789a3c361e2f" translate="yes" xml:space="preserve">
          <source>If there is no interactivity then you may still want to look at using something like &lt;a href=&quot;https://metacpan.org/module/Template&quot;&gt;Template Toolkit&lt;/a&gt; or &lt;a href=&quot;Plack::Middleware::TemplateToolkit&quot;&gt;Plack::Middleware::TemplateToolkit&lt;/a&gt; so maintenance of your HTML files (and other assets) is easier.</source>
          <target state="translated">対話性がない場合でも、&lt;a href=&quot;https://metacpan.org/module/Template&quot;&gt;TemplateToolkit&lt;/a&gt;や&lt;a href=&quot;Plack::Middleware::TemplateToolkit&quot;&gt;Plack :: Middleware :: TemplateToolkitの&lt;/a&gt;ようなものを使用して、HTMLファイル（およびその他のアセット）の保守を容易にすることを検討することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="8dd8956e9b63cae584008cf6c1bbe7cd26c8c5c5" translate="yes" xml:space="preserve">
          <source>If there is no matching entry found and there is no default defined, or no .netrc file is found, then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">一致するエントリが見つからず、デフォルトが定義されていないか、.netrcファイルが見つからない場合は、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="e6537a61412be05c76bbd6dbb9043f0a60ac95b9" translate="yes" xml:space="preserve">
          <source>If there is no matching entry found and there is no default defined, or no .netrc file is found, then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">一致するエントリが見つからず、デフォルトが定義されていない場合、または.netrcファイルが見つからない場合は、 &lt;code&gt;undef&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="ed6dfba39c8f615f2c8441ca5b61296e07f9cf19" translate="yes" xml:space="preserve">
          <source>If there is no top hub, and you do not ask to leave IPC and formatter undef, then a new formatter will be created, and the IPC instance from &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt; will be used.</source>
          <target state="translated">トップハブがなく、IPCとフォーマッターを未定義のままにするように要求しない場合は、新しいフォーマッターが作成され、&lt;a href=&quot;Test2::API&quot;&gt;Test2 :: APIの&lt;/a&gt;IPCイン​​スタンスが使用されます。</target>
        </trans-unit>
        <trans-unit id="40165726268e187e7ad5a226c93cb70fb5e7ae2c" translate="yes" xml:space="preserve">
          <source>If there is only one argument and it is a reference to an array then the array is assumed to contain a list of key-value pairs specifying the options. In this case the option &quot;from_to&quot; is mandatory. This style means that you do not have to supply a cryptic list of arguments and can use a self documenting argument list that is easier to understand.</source>
          <target state="translated">引数がひとつだけで、それが配列への参照である場合は、その配列は、オプションを指定するキーと値のペアのリストを含んでいると想定されます。この場合、オプション &quot;from_to&quot; は必須です。このスタイルは、暗号化された引数のリストを提供する必要がなく、より理解しやすい自己文書化された引数リストを使用することができることを意味します。</target>
        </trans-unit>
        <trans-unit id="663e6f7ad7626839945e055f61dd00fa139292d7" translate="yes" xml:space="preserve">
          <source>If there was an error authenticating the user then</source>
          <target state="translated">ユーザーの認証にエラーがあった場合は</target>
        </trans-unit>
        <trans-unit id="c4805e4afe7a0ccfe45caa54514a077972082082" translate="yes" xml:space="preserve">
          <source>If there's already an entry in &lt;code&gt;%table&lt;/code&gt; for the current &lt;code&gt;$country&lt;/code&gt; , then nothing is different. Line 6 will locate the value in &lt;code&gt;$table{$country}&lt;/code&gt; , which is a reference to an array, and push &lt;code&gt;$city&lt;/code&gt; into the array. But what does it do when &lt;code&gt;$country&lt;/code&gt; holds a key, say &lt;code&gt;Greece&lt;/code&gt; , that is not yet in &lt;code&gt;%table&lt;/code&gt; ?</source>
          <target state="translated">現在の &lt;code&gt;$country&lt;/code&gt; エントリが &lt;code&gt;%table&lt;/code&gt; にすでにある場合、違いはありません。6行目は、配列への参照である &lt;code&gt;$table{$country}&lt;/code&gt; 内の値を特定し、 &lt;code&gt;$city&lt;/code&gt; を配列にプッシュします。しかし、 &lt;code&gt;$country&lt;/code&gt; がキーを保持している場合はどうなりますか（ &lt;code&gt;Greece&lt;/code&gt; 、まだ &lt;code&gt;%table&lt;/code&gt; にありませんか？</target>
        </trans-unit>
        <trans-unit id="9e3670f66abc27b9c0c1a9a3a64b0edd5b7f7779" translate="yes" xml:space="preserve">
          <source>If there's already an entry in &lt;code&gt;%table&lt;/code&gt; for the current &lt;code&gt;$country&lt;/code&gt;, then nothing is different. Line 6 will locate the value in &lt;code&gt;$table{$country}&lt;/code&gt;, which is a reference to an array, and push &lt;code&gt;$city&lt;/code&gt; into the array. But what does it do when &lt;code&gt;$country&lt;/code&gt; holds a key, say &lt;code&gt;Greece&lt;/code&gt;, that is not yet in &lt;code&gt;%table&lt;/code&gt;?</source>
          <target state="translated">現在の &lt;code&gt;$country&lt;/code&gt; &lt;code&gt;%table&lt;/code&gt; にすでにエントリがある場合は、何も変わりません。6行目では、配列への参照である &lt;code&gt;$table{$country}&lt;/code&gt; 内の値を見つけ、 &lt;code&gt;$city&lt;/code&gt; を配列にプッシュします。しかし、 &lt;code&gt;$country&lt;/code&gt; がキーを保持している場合、たとえば &lt;code&gt;Greece&lt;/code&gt; はまだ &lt;code&gt;%table&lt;/code&gt; にない場合、どうなりますか？</target>
        </trans-unit>
        <trans-unit id="b79b95fc8b6f0bdad9a42663607fbb6bbfce24c2" translate="yes" xml:space="preserve">
          <source>If there's no &lt;code&gt;\w&lt;/code&gt; in &lt;code&gt;s1&lt;/code&gt; nor in &lt;code&gt;s2&lt;/code&gt; , why does their concatenation have one?</source>
          <target state="translated">&lt;code&gt;s1&lt;/code&gt; にも &lt;code&gt;s2&lt;/code&gt; にも &lt;code&gt;\w&lt;/code&gt; がない場合、なぜそれらの連結に1つあるのですか？</target>
        </trans-unit>
        <trans-unit id="f998e73c18ed98eef0579d8f9950627eae9eb668" translate="yes" xml:space="preserve">
          <source>If there's no &lt;code&gt;\w&lt;/code&gt; in &lt;code&gt;s1&lt;/code&gt; nor in &lt;code&gt;s2&lt;/code&gt;, why does their concatenation have one?</source>
          <target state="translated">&lt;code&gt;s1&lt;/code&gt; にも &lt;code&gt;s2&lt;/code&gt; にも &lt;code&gt;\w&lt;/code&gt; がない場合、それらの連結に\ wがあるのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="e887683b17f434ea92edf8b372be7bfa0a590185" translate="yes" xml:space="preserve">
          <source>If there's no handle_unknown_option, then we just warn, and then increment the error counter</source>
          <target state="translated">handle_unknown_option がない場合は、警告を出してからエラーカウンタをインクリメントします。</target>
        </trans-unit>
        <trans-unit id="4d867e0a4fd4a8ea827c16a08b87197c9c461d55" translate="yes" xml:space="preserve">
          <source>If these dependent libraries are not listed at shared library creation time, you will get fatal &quot;Unresolved symbol&quot; errors at run time when the library is loaded.</source>
          <target state="translated">これらの依存ライブラリが共有ライブラリ作成時にリストアップされていない場合、ライブラリのロード時に実行時に致命的な &quot;Unresolved symbol &quot;エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="66c4d2d6f3874b5b92940f178682f9bbdd8c1db5" translate="yes" xml:space="preserve">
          <source>If these operators are not explicitly overloaded then they work in the normal way, yielding the underlying scalar, array, or whatever stores the object data (or the appropriate error message if the dereference operator doesn't match it). Defining a catch-all &lt;code&gt;'nomethod'&lt;/code&gt; (see &lt;a href=&quot;#nomethod&quot;&gt;below&lt;/a&gt;) makes no difference to this as the catch-all function will not be called to implement a missing dereference operator.</source>
          <target state="translated">これらの演算子が明示的にオーバーロードされていない場合、それらは通常の方法で動作し、基になるスカラー、配列、またはオブジェクトデータを格納するもの（または逆参照演算子が一致しない場合は適切なエラーメッセージ）を生成します。キャッチオール &lt;code&gt;'nomethod'&lt;/code&gt; （&lt;a href=&quot;#nomethod&quot;&gt;以下を参照&lt;/a&gt;）を定義しても、キャッチオール関数が呼び出されて欠落している間接参照演算子が実装されないため、これに違いはありません。</target>
        </trans-unit>
        <trans-unit id="e7e81ed1aafee87e39f3bf4df7400134171b1b47" translate="yes" xml:space="preserve">
          <source>If these were ordinary paragraphs, the Pod parser would try to expand the &quot;E&amp;lt;/em&amp;gt;&quot; (in the first paragraph) as a formatting code, just like &quot;E&amp;lt;lt&amp;gt;&quot; or &quot;E&amp;lt;eacute&amp;gt;&quot;. But since this is in a &quot;=begin</source>
          <target state="translated">これらが通常の段落である場合、Podパーサーは「E &amp;lt;lt&amp;gt;」または「E &amp;lt;eacute&amp;gt;」のように、「E &amp;lt;/ em&amp;gt;」（最初の段落）をフォーマットコードとして展開しようとします。しかし、これは &quot;= begin</target>
        </trans-unit>
        <trans-unit id="fc6b5f11ab146ad9637defe5808c195788361c30" translate="yes" xml:space="preserve">
          <source>If these weren't meant to be POSIX classes, this warning message is spurious, and can be suppressed by reordering things, such as</source>
          <target state="translated">これらが POSIX クラスであることを意味していなかった場合、この警告メッセージは偽物であり、次のように順序を変えることで抑制することができます。</target>
        </trans-unit>
        <trans-unit id="4135dfc8a9407c20cefc1359ee43028a8d9e9a77" translate="yes" xml:space="preserve">
          <source>If they are not composable, it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">合成できない場合は、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="9a6c7139e709a41aafbcb832650d6f1102386857" translate="yes" xml:space="preserve">
          <source>If they are not composable, it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">それらが構成可能でない場合は、 &lt;code&gt;undef&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="7928853cb29cf0ed7b6549f627a68e66710a9993" translate="yes" xml:space="preserve">
          <source>If they wanted to clobber something, they might say:</source>
          <target state="translated">何かにぶつかりたいと思ったら、言うかもしれません。</target>
        </trans-unit>
        <trans-unit id="005637a170229ceb4ce45f18dce99b88396f9f92" translate="yes" xml:space="preserve">
          <source>If things aren't broken, upgrading perl may break them (or at least issue new warnings).</source>
          <target state="translated">壊れていないものは、perl をアップグレードすると壊れてしまうかもしれません (少なくとも新しい警告が出るかもしれません)。</target>
        </trans-unit>
        <trans-unit id="f401b770207b3e95d6e44d96ff6ad2d9bf229b05" translate="yes" xml:space="preserve">
          <source>If this attribute is set to true, the parser will not ignore empty &lt;code&gt;=over&lt;/code&gt;/&lt;code&gt;=back&lt;/code&gt; blocks. The type of &lt;code&gt;=over&lt;/code&gt; will be</source>
          <target state="translated">この属性がtrueに設定されている場合、パーサーは空の &lt;code&gt;=over&lt;/code&gt; / &lt;code&gt;=back&lt;/code&gt; ブロックを無視しません。 &lt;code&gt;=over&lt;/code&gt; のタイプは次のようになります</target>
        </trans-unit>
        <trans-unit id="af3184843a959ec8cbcadf6df48b4b495b6b3f78" translate="yes" xml:space="preserve">
          <source>If this behaviour is not desirable, the &lt;code&gt;error&lt;/code&gt; attribute may be used to hold a reference to a variable, which will be used to store the diagnostics. The variable is made a reference to an array of hash references. Each hash contain a single key/value pair where the key is the name of the file, and the value is the error message (including the contents of &lt;code&gt;$!&lt;/code&gt; when appropriate). If a general error is encountered the diagnostic key will be empty.</source>
          <target state="translated">この動作が望ましくない場合は、 &lt;code&gt;error&lt;/code&gt; 属性を使用して、診断の保存に使用される変数への参照を保持できます。変数は、ハッシュ参照の配列への参照になります。各ハッシュには、キーがファイルの名前である単一のキー/値のペアが含まれ、値はエラーメッセージです（適切な場合は &lt;code&gt;$!&lt;/code&gt; の内容を含みます）。一般的なエラーが発生した場合、診断キーは空になります。</target>
        </trans-unit>
        <trans-unit id="b9e80a2a00d7763bcb33166ac12286d96be2d204" translate="yes" xml:space="preserve">
          <source>If this bit is set and a file [but not a directory] named &lt;code&gt;$sNewName&lt;/code&gt; already exists, then it will be replaced by &lt;code&gt;$sOldName&lt;/code&gt;. If this bit is not set then &lt;code&gt;MoveFileEx&lt;/code&gt; will fail rather than replace an existing &lt;code&gt;$sNewName&lt;/code&gt;.</source>
          <target state="translated">このビットが設定されていて、 &lt;code&gt;$sNewName&lt;/code&gt; という名前のファイル[ディレクトリではない]がすでに存在する場合は、 &lt;code&gt;$sOldName&lt;/code&gt; 置き換えられます。このビットが設定されていない場合、 &lt;code&gt;MoveFileEx&lt;/code&gt; は、既存の &lt;code&gt;$sNewName&lt;/code&gt; 置き換えるのではなく、失敗します。</target>
        </trans-unit>
        <trans-unit id="fa9fb1ea3eae474e9c243073b7277960fe7cd8b7" translate="yes" xml:space="preserve">
          <source>If this bit is set, then calls to &lt;code&gt;CloseHandle&lt;/code&gt; against this handle will be ignored, leaving the handle open and usable.</source>
          <target state="translated">このビットが設定されている場合、このハンドルに対する &lt;code&gt;CloseHandle&lt;/code&gt; の呼び出しは無視され、ハンドルは開いたまま使用可能になります。</target>
        </trans-unit>
        <trans-unit id="cb0ba2e4466abc8ea8b16e3596960ca402d75037" translate="yes" xml:space="preserve">
          <source>If this bit is set, then children of this process who inherit handles [that is, processes created by calls to the Win32 &lt;code&gt;CreateProcess&lt;/code&gt; API with the &lt;code&gt;bInheritHandles&lt;/code&gt; parameter specified as &lt;code&gt;TRUE&lt;/code&gt;], will inherit this particular object handle.</source>
          <target state="translated">このビットが設定されている場合、ハンドルを継承するこのプロセスの子[つまり、 &lt;code&gt;bInheritHandles&lt;/code&gt; パラメーターを &lt;code&gt;TRUE&lt;/code&gt; として指定してWin32 &lt;code&gt;CreateProcess&lt;/code&gt; APIを呼び出して作成されたプロセス]は、この特定のオブジェクトハンドルを継承します。</target>
        </trans-unit>
        <trans-unit id="cfffc413c869bcf00848584ef88629d0cba8d4b7" translate="yes" xml:space="preserve">
          <source>If this command lists any paths that don't exist on your system, then you may need to move the appropriate libraries to these locations, or create symbolic links, aliases, or shortcuts appropriately. &lt;code&gt;@INC&lt;/code&gt; is also printed as part of the output of</source>
          <target state="translated">このコマンドでシステムに存在しないパスが一覧表示される場合は、適切なライブラリをこれらの場所に移動するか、シンボリックリンク、エイリアス、またはショートカットを適切に作成する必要があります。 &lt;code&gt;@INC&lt;/code&gt; は、出力の一部としても出力されます。</target>
        </trans-unit>
        <trans-unit id="4975023e8ced451b521e66f7c64344d22c9935aa" translate="yes" xml:space="preserve">
          <source>If this directory is exactly the same as the prefix which was compiled into</source>
          <target state="translated">にコンパイルされたプレフィックスと全く同じディレクトリであれば</target>
        </trans-unit>
        <trans-unit id="285c8028480f1bd9da414482302791b2b2e5917d" translate="yes" xml:space="preserve">
          <source>If this displays any &lt;code&gt;D&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt; symbols (or possibly &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; ), you have non-const data. The symbols the &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; removed are as follows: &lt;code&gt;Tt&lt;/code&gt; are</source>
          <target state="translated">これが &lt;code&gt;D&lt;/code&gt; または &lt;code&gt;d&lt;/code&gt; シンボル（または &lt;code&gt;C&lt;/code&gt; または &lt;code&gt;c&lt;/code&gt; ）を表示する場合、非constデータがあります。シンボル &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; 、次のように削除は、以下のとおりです。 &lt;code&gt;Tt&lt;/code&gt; があります</target>
        </trans-unit>
        <trans-unit id="e00722416b7c55f26c8b791511437fbf3bd5fa48" translate="yes" xml:space="preserve">
          <source>If this displays any &lt;code&gt;D&lt;/code&gt; or &lt;code&gt;d&lt;/code&gt; symbols (or possibly &lt;code&gt;C&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt;), you have non-const data. The symbols the &lt;code&gt;grep&lt;/code&gt; removed are as follows: &lt;code&gt;Tt&lt;/code&gt; are</source>
          <target state="translated">これに &lt;code&gt;D&lt;/code&gt; または &lt;code&gt;d&lt;/code&gt; シンボル（または &lt;code&gt;C&lt;/code&gt; または &lt;code&gt;c&lt;/code&gt; ）が表示される場合は、非定数データが​​あります。シンボル &lt;code&gt;grep&lt;/code&gt; 、次のように削除は、以下のとおりです。 &lt;code&gt;Tt&lt;/code&gt; があります</target>
        </trans-unit>
        <trans-unit id="4abdac7aa391382bc2754c2374cb867d27e05580" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to a true value, all of the functions defined by this module (color(), colored(), and all of the constants not previously used in the program) will not output any escape sequences and instead will just return the empty string or pass through the original text as appropriate. This is intended to support easy use of scripts using this module on platforms that don't support ANSI escape sequences.</source>
          <target state="translated">この環境変数が真の値に設定されている場合、このモジュールで定義されているすべての関数 (color()、colored()、およびプログラムで以前に使用されていないすべての定数)は、エスケープシーケンスを出力せず、代わりに空の文字列を返すか、元のテキストを適切に通過させます。これは、ANSI エスケープシーケンスをサポートしていないプラットフォーム上で、このモジュールを使用したスクリプトを簡単に使用できるようにすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="38f035ce9a9a2458333cab9abdbe9a0ca164bacc" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to a true value, all of the functions defined by this module (color(), colored(), and all of the constants) will not output any escape sequences and instead will just return the empty string or pass through the original text as appropriate. This is intended to support easy use of scripts using this module on platforms that don't support ANSI escape sequences.</source>
          <target state="translated">この環境変数が真の値に設定されている場合、このモジュールで定義されているすべての関数 (color()、colored()、およびすべての定数)はエスケープシーケンスを出力せず、代わりに空の文字列を返すか、適切に元のテキストを通過させます。これは、ANSI エスケープシーケンスをサポートしていないプラットフォーム上で、このモジュールを使用したスクリプトを簡単に使用できるようにすることを目的としています。</target>
        </trans-unit>
        <trans-unit id="f18c65b6596250b7fc84f994b0860dfb64443933" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to any value, it suppresses generation of escape sequences the same as if ANSI_COLORS_DISABLED is set to a true value. This implements the &lt;a href=&quot;https://no-color.org/&quot;&gt;https://no-color.org/&lt;/a&gt; informal standard. Programs that want to enable color despite NO_COLOR being set will need to unset that environment variable before any constant or function provided by this module is used.</source>
          <target state="translated">この環境変数が任意の値に設定されている場合、ANSI_COLORS_DISABLEDが真の値に設定されている場合と同じようにエスケープシーケンスの生成が抑制されます。これにより、&lt;a href=&quot;https://no-color.org/&quot;&gt;https：//no-color.org/&lt;/a&gt;非公式の標準が実装されます。 NO_COLORが設定されているにもかかわらず色を有効にしたいプログラムは、このモジュールによって提供される定数または関数を使用する前に、その環境変数の設定を解除する必要があります。</target>
        </trans-unit>
        <trans-unit id="876cbaf8d98a55944949f12e34d25c434a20bad7" translate="yes" xml:space="preserve">
          <source>If this environment variable is true then normal install processes will always overwrite older identical files during the install process.</source>
          <target state="translated">この環境変数が真の場合、通常のインストールプロセスは、インストールプロセス中に常に古い同一のファイルを上書きします。</target>
        </trans-unit>
        <trans-unit id="e053edd732d7c1c9c9166271bdb64b8b374b5d23" translate="yes" xml:space="preserve">
          <source>If this event is nested inside of other events, this should be the depth of nesting. (This is mainly for subtests)</source>
          <target state="translated">このイベントが他のイベントの中に入れ子になっている場合は、入れ子の深さを指定します。(これは主にサブテストのためのものです)</target>
        </trans-unit>
        <trans-unit id="30b941d4f353a594151f4f0a38deaca7c7d4a4d4" translate="yes" xml:space="preserve">
          <source>If this feature is enabled (which is the default under a &lt;code&gt;use 5.16&lt;/code&gt; or higher declaration), EXPR is considered to be in the same encoding as the surrounding program. Thus if &lt;a href=&quot;utf8&quot;&gt;&lt;code&gt;use utf8&lt;/code&gt;&lt;/a&gt; is in effect, the string will be treated as being UTF-8 encoded. Otherwise, the string is considered to be a sequence of independent bytes. Bytes that correspond to ASCII-range code points will have their normal meanings for operators in the string. The treatment of the other bytes depends on if the &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;'unicode_strings&quot;&lt;/code&gt; feature&lt;/a&gt; is in effect.</source>
          <target state="translated">この機能が有効になっている場合（ &lt;code&gt;use 5.16&lt;/code&gt; 以降の使用宣言ではデフォルト）、EXPRは周囲のプログラムと同じエンコーディングであると見なされます。したがって、&lt;a href=&quot;utf8&quot;&gt; &lt;code&gt;use utf8&lt;/code&gt; &lt;/a&gt;が有効な場合、文字列はUTF-8でエンコードされたものとして扱われます。それ以外の場合、文字列は独立したバイトのシーケンスと見なされます。 ASCII範囲のコードポイントに対応するバイトは、文字列内の演算子に対して通常の意味を持ちます。他のバイトの処理は、&lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt; &lt;code&gt;'unicode_strings&quot;&lt;/code&gt; 機能&lt;/a&gt;が有効かどうかによって異なります。</target>
        </trans-unit>
        <trans-unit id="f7eb5123560aed4a2756b83ae3d2c52a26a17f8b" translate="yes" xml:space="preserve">
          <source>If this field is omitted, it defaults to 1 (true).</source>
          <target state="translated">このフィールドが省略された場合、デフォルトは 1 (真)です。</target>
        </trans-unit>
        <trans-unit id="07fe5d03fc19f605909f122565e563658cd995e6" translate="yes" xml:space="preserve">
          <source>If this field is zero then &lt;code&gt;PerlIO_pushed&lt;/code&gt; does not malloc anything and assumes layer's Pushed function will do any required layer stack manipulation - used to avoid malloc/free overhead for dummy layers. If the field is non-zero it must be at least the size of &lt;code&gt;PerlIOl&lt;/code&gt; , &lt;code&gt;PerlIO_pushed&lt;/code&gt; will allocate memory for the layer's data structures and link new layer onto the stream's stack. (If the layer's Pushed method returns an error indication the layer is popped again.)</source>
          <target state="translated">このフィールドがゼロの場合、 &lt;code&gt;PerlIO_pushed&lt;/code&gt; は何もmallocせず、レイヤーのPushed関数が必要なレイヤースタック操作を行うと想定します-ダミーレイヤーのmalloc / freeオーバーヘッドを回避するために使用されます。フィールドがゼロ以外の場合、少なくとも &lt;code&gt;PerlIOl&lt;/code&gt; のサイズでなければなりません &lt;code&gt;PerlIO_pushed&lt;/code&gt; は、レイヤーのデータ構造にメモリを割り当て、新しいレイヤーをストリームのスタックにリンクします。（レイヤーのPushedメソッドがエラーを示す場合、レイヤーは再びポップされます。）</target>
        </trans-unit>
        <trans-unit id="a5a45df8d66f9a394f3a4c96ed9c17f127fd5118" translate="yes" xml:space="preserve">
          <source>If this field is zero then &lt;code&gt;PerlIO_pushed&lt;/code&gt; does not malloc anything and assumes layer's Pushed function will do any required layer stack manipulation - used to avoid malloc/free overhead for dummy layers. If the field is non-zero it must be at least the size of &lt;code&gt;PerlIOl&lt;/code&gt;, &lt;code&gt;PerlIO_pushed&lt;/code&gt; will allocate memory for the layer's data structures and link new layer onto the stream's stack. (If the layer's Pushed method returns an error indication the layer is popped again.)</source>
          <target state="translated">このフィールドがゼロの場合、 &lt;code&gt;PerlIO_pushed&lt;/code&gt; は何もmallocせず、レイヤーのPushed関数が必要なレイヤースタック操作を実行すると想定します。これは、ダミーレイヤーのmalloc / freeオーバーヘッドを回避するために使用されます。フィールドがゼロ以外の場合、少なくとも &lt;code&gt;PerlIOl&lt;/code&gt; のサイズである必要があります &lt;code&gt;PerlIO_pushed&lt;/code&gt; は、レイヤーのデータ構造にメモリを割り当て、新しいレイヤーをストリームのスタックにリンクします。 （レイヤーのPushedメソッドがエラー表示を返す場合、レイヤーは再びポップされます。）</target>
        </trans-unit>
        <trans-unit id="6eff879286b0f884c3e6b0dc473e05a91d80d4a8" translate="yes" xml:space="preserve">
          <source>If this function is being sourced in from a separate file via &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;, then this is probably just fine. If it's all in the main program, you'll need to arrange for the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; to be executed early, either by putting the whole block above your main program, or more likely, placing merely a &lt;code&gt;BEGIN&lt;/code&gt; code block around it to make sure it gets executed before your program starts to run:</source>
          <target state="translated">この関数が &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; を介して別のファイルから供給されている場合、おそらくこれで十分です。すべてがメインプログラム内にある場合は、ブロック全体をメインプログラムの上に置くか、 &lt;code&gt;BEGIN&lt;/code&gt; コードブロックをその周りに配置するだけで、 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; が早期に実行されるように調整する必要があります。プログラムが実行を開始する前に実行されます：</target>
        </trans-unit>
        <trans-unit id="3b08fb8fb677146606e9cfcd0ad7806affc639d2" translate="yes" xml:space="preserve">
          <source>If this function is being sourced in from a separate file via &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;use&lt;/code&gt;, then this is probably just fine. If it's all in the main program, you'll need to arrange for the &lt;code&gt;my&lt;/code&gt; to be executed early, either by putting the whole block above your main program, or more likely, placing merely a &lt;code&gt;BEGIN&lt;/code&gt; code block around it to make sure it gets executed before your program starts to run:</source>
          <target state="translated">この関数が &lt;code&gt;require&lt;/code&gt; または &lt;code&gt;use&lt;/code&gt; を介して別のファイルから供給されている場合、これはおそらく問題ありません。すべてがメインプログラムにある場合は、ブロック全体をメインプログラムの上に配置するか、おそらく &lt;code&gt;BEGIN&lt;/code&gt; コードブロックをその周りに配置して確実に取得することにより、 &lt;code&gt;my&lt;/code&gt; が早期に実行されるように調整する必要があります。プログラムの実行が開始される前に実行されます。</target>
        </trans-unit>
        <trans-unit id="e5121e7b7256f6d0ab378dc9bff9a8c6dad43577" translate="yes" xml:space="preserve">
          <source>If this happens to you, there's not much you can do except switch to use a different locale or use &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; to translate from the locale into UTF-8; if that's impracticable, you have been warned that some things may break.</source>
          <target state="translated">これが発生した場合、別のロケールを使用するように切り替えるか、&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;を使用してロケールからUTF-8に変換する以外にできることは多くありません。それが実行不可能である場合、いくつかが壊れる可能性があると警告されています。</target>
        </trans-unit>
        <trans-unit id="faa64c33180aaefa8582782daf214d7a2f4780a7" translate="yes" xml:space="preserve">
          <source>If this interior sequence is nested inside of another interior sequence, then the outer/parent sequence that contains it is returned. Otherwise &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">この内部シーケンスが別の内部シーケンスの内側にネストされている場合、それを含む外部/親シーケンスが返されます。それ以外の場合は、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="bf7d995797b0338af1d03b9d03a8511323aeb269" translate="yes" xml:space="preserve">
          <source>If this is a TODO test and an 'ok' line, this method returns true. Otherwise, it will always return false (regardless of passing status on non-todo tests).</source>
          <target state="translated">これが TODO テストで 'ok' 行の場合、このメソッドは true を返します。そうでない場合は、常に false を返します (非 TODO テストの通過状況に関わらず)。</target>
        </trans-unit>
        <trans-unit id="604eb865cff5427575c78b447eb628e9c645992c" translate="yes" xml:space="preserve">
          <source>If this is a simple scalar then it will be treated as a boolean for the 'buffered' setting. If this is a hash reference then it will be used as a parameters hash. The param hash will be used for hub construction (with the specified keys removed).</source>
          <target state="translated">これが単純なスカラであれば、'buffered'設定のブール値として扱われます。これがハッシュ参照の場合は、パラメータハッシュとして使用されます。paramハッシュはハブの構築に使用されます(指定されたキーは削除されます)。</target>
        </trans-unit>
        <trans-unit id="f7666722db0ac2cfa26e5cabc574e02e68556877" translate="yes" xml:space="preserve">
          <source>If this is being called as &lt;code&gt;re::regname&lt;/code&gt; , &lt;code&gt;re::regnames&lt;/code&gt; or &lt;code&gt;re::regnames_count&lt;/code&gt; , if any. The first two will be combined with &lt;code&gt;RXapif_ONE&lt;/code&gt; or &lt;code&gt;RXapif_ALL&lt;/code&gt; .</source>
          <target state="translated">これが &lt;code&gt;re::regname&lt;/code&gt; として呼び出されている場合、 &lt;code&gt;re::regnames&lt;/code&gt; または &lt;code&gt;re::regnames_count&lt;/code&gt; （存在する場合）。最初の2つは &lt;code&gt;RXapif_ONE&lt;/code&gt; または &lt;code&gt;RXapif_ALL&lt;/code&gt; と組み合わされます。</target>
        </trans-unit>
        <trans-unit id="79a068f47ba129d0ff77349a01057b9518f8fbed" translate="yes" xml:space="preserve">
          <source>If this is being called as &lt;code&gt;re::regname&lt;/code&gt;, &lt;code&gt;re::regnames&lt;/code&gt; or &lt;code&gt;re::regnames_count&lt;/code&gt;, if any. The first two will be combined with &lt;code&gt;RXapif_ONE&lt;/code&gt; or &lt;code&gt;RXapif_ALL&lt;/code&gt;.</source>
          <target state="translated">これが &lt;code&gt;re::regname&lt;/code&gt; 、 &lt;code&gt;re::regnames&lt;/code&gt; または &lt;code&gt;re::regnames_count&lt;/code&gt; （存在する場合）として呼び出されている場合。最初の2つは、 &lt;code&gt;RXapif_ONE&lt;/code&gt; または &lt;code&gt;RXapif_ALL&lt;/code&gt; と組み合わされます。</target>
        </trans-unit>
        <trans-unit id="9edbce2664bb4f91955d900ea95b27deaa6b5a4b" translate="yes" xml:space="preserve">
          <source>If this is in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; it will be passed to &lt;code&gt;Perl_fbm_instr&lt;/code&gt; by &lt;code&gt;pp_split&lt;/code&gt; which will treat the subject string as a multi-line string.</source>
          <target state="translated">これが &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; にある場合、対象の文字列を複数行の文字列として扱う &lt;code&gt;Perl_fbm_instr&lt;/code&gt; によって &lt;code&gt;pp_split&lt;/code&gt; 渡されます。</target>
        </trans-unit>
        <trans-unit id="3e0c042153cf9f6ff54247584b15672ab611a4af" translate="yes" xml:space="preserve">
          <source>If this is negative, and amounts to &lt;code&gt;HEf_SVKEY&lt;/code&gt; , it indicates the entry holds an &lt;code&gt;SV*&lt;/code&gt; key. Otherwise, holds the actual length of the key. Can be assigned to. The &lt;code&gt;HePV()&lt;/code&gt; macro is usually preferable for finding key lengths.</source>
          <target state="translated">これが負の値で &lt;code&gt;HEf_SVKEY&lt;/code&gt; になる場合は、エントリが &lt;code&gt;SV*&lt;/code&gt; キーを保持していることを示しています。それ以外の場合は、キーの実際の長さを保持します。に割り当てることができます。 &lt;code&gt;HePV()&lt;/code&gt; マクロは、キーの長さを見つけるための通常好ましいです。</target>
        </trans-unit>
        <trans-unit id="f90d0f4d493e8df7c15bcc83bca70a42ffcdb6df" translate="yes" xml:space="preserve">
          <source>If this is negative, and amounts to &lt;code&gt;HEf_SVKEY&lt;/code&gt;, it indicates the entry holds an &lt;code&gt;SV*&lt;/code&gt; key. Otherwise, holds the actual length of the key. Can be assigned to. The &lt;code&gt;HePV()&lt;/code&gt; macro is usually preferable for finding key lengths.</source>
          <target state="translated">これが負で、 &lt;code&gt;HEf_SVKEY&lt;/code&gt; になる場合は、エントリが &lt;code&gt;SV*&lt;/code&gt; キーを保持していることを示します。それ以外の場合は、キーの実際の長さを保持します。に割り当てることができます。 &lt;code&gt;HePV()&lt;/code&gt; マクロは、キーの長さを見つけるための通常好ましいです。</target>
        </trans-unit>
        <trans-unit id="ddda819aeefa94d361f2fc0677ccc065e6c33f4f" translate="yes" xml:space="preserve">
          <source>If this is starting to sound scarier than it's worth, relax. Perl has some features to help you avoid its most common pitfalls. The best way to avoid getting confused is to start every program like this:</source>
          <target state="translated">もしこれが価値があるというよりも怖く聞こえてきたら、リラックスしてください。Perlには、その最も一般的な落とし穴を避けるための機能がいくつかあります。混乱を避けるための最良の方法は、すべてのプログラムをこのように起動することです。</target>
        </trans-unit>
        <trans-unit id="c2cd7396387cdb373b2dd32a6d21ffa39a9fbdd0" translate="yes" xml:space="preserve">
          <source>If this is true, none of that will be done.</source>
          <target state="translated">これが本当ならば、どれもこれもできません。</target>
        </trans-unit>
        <trans-unit id="998c59b2484753d1482d0ff9ba7497a84e80fcd4" translate="yes" xml:space="preserve">
          <source>If this is what you intended then you can silence the warning by using &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/${\}/&lt;/a&gt;&lt;/code&gt; (for example: &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo${\}s+bar/&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">これが意図したものである場合は、 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/${\}/&lt;/a&gt;&lt;/code&gt; を使用して警告を止めることができます（例： &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/foo${\}s+bar/&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="44c23df76d34643bd06f7fcbfd01951d86e6affe" translate="yes" xml:space="preserve">
          <source>If this is what you intended then you can silence the warning by using &lt;code&gt;m/${\}/&lt;/code&gt; (for example: &lt;code&gt;m/foo${\}s+bar/&lt;/code&gt;).</source>
          <target state="translated">これが意図したものである場合は、 &lt;code&gt;m/${\}/&lt;/code&gt; を使用して警告を消音できます（例： &lt;code&gt;m/foo${\}s+bar/&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b2f4b7328771b0d9e19ff0a7ce5f9c13e4b36300" translate="yes" xml:space="preserve">
          <source>If this is your first use of Sys::Syslog, you must read the doc.</source>
          <target state="translated">Sys::Syslog を初めて使う場合は、ドキュメントを読む必要があります。</target>
        </trans-unit>
        <trans-unit id="51d2478f45a9802ed436c7d6c5c2a5bb72aeb395" translate="yes" xml:space="preserve">
          <source>If this optimization is applicable, &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; will emit a &lt;code&gt;dXSTARG;&lt;/code&gt; definition at the start of the generated XSUB code, and type (see below) dependent code to set &lt;code&gt;TARG&lt;/code&gt; and push it on the stack at the end of the generated XSUB code.</source>
          <target state="translated">この最適化が適用可能な場合、 &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; は &lt;code&gt;dXSTARG;&lt;/code&gt; 生成されたXSUBコードの先頭で定義し、依存コードを入力して（以下を参照）、 &lt;code&gt;TARG&lt;/code&gt; を設定し、生成されたXSUBコードの最後でスタックにプッシュします。</target>
        </trans-unit>
        <trans-unit id="51861420a23f19227e776c6bc3a38fdcea309df1" translate="yes" xml:space="preserve">
          <source>If this option is not present, the value stored in XFL field will be determined by the setting of the &lt;code&gt;Level&lt;/code&gt; option.</source>
          <target state="translated">このオプションが存在しない場合、XFLフィールドに格納される値は、 &lt;code&gt;Level&lt;/code&gt; オプションの設定によって決定されます。</target>
        </trans-unit>
        <trans-unit id="415323d14a6e182890345d78f7ae3f3149cdff1f" translate="yes" xml:space="preserve">
          <source>If this option is set and the input file/buffer is not compressed data, the module will allow reading of it anyway.</source>
          <target state="translated">このオプションが設定されていて、入力ファイル/バッファが圧縮データではない場合、モジュールはとにかく読み込みを許可します。</target>
        </trans-unit>
        <trans-unit id="805aae725ba9def01f764562edc887adcbc46d85" translate="yes" xml:space="preserve">
          <source>If this option is set, Pod::Man will instead output UTF-8. If your *roff implementation can handle it, this is the best output format to use and avoids corruption of documents containing non-ASCII characters. However, be warned that *roff source with literal UTF-8 characters is not supported by many implementations and may even result in segfaults and other bad behavior.</source>
          <target state="translated">このオプションが設定されている場合、Pod::Manは代わりにUTF-8を出力します。お使いの*roffの実装がこれを扱えるのであれば、これが最良の出力形式であり、非ASCII文字を含むドキュメントの破損を防ぎます。しかし、リテラルなUTF-8文字を含む*roffソースは多くの実装ではサポートされておらず、セグメンテーションフォールトやその他の悪い動作を引き起こす可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9276827e0a43ce0cd98e803156d215d94a1cfced" translate="yes" xml:space="preserve">
          <source>If this paragraph is a command paragraph, then this method will return the name of the command (</source>
          <target state="translated">この段落がコマンドの段落である場合、このメソッドはコマンドの名前を返します(</target>
        </trans-unit>
        <trans-unit id="bcc44b3b4b66c03b7a2464f3e737f50efd9dbf21" translate="yes" xml:space="preserve">
          <source>If this paragraph is a command paragraph, then this method will return the prefix used to denote the command (which should be the string &quot;=&quot; or &quot;==&quot;).</source>
          <target state="translated">この段落がコマンドの段落である場合、このメソッドはコマンドを表すために使用される接頭辞を返します (文字列 &quot;=&quot; または &quot;==&quot; でなければなりません)。</target>
        </trans-unit>
        <trans-unit id="97d5af9792754821d43f791eb7a3e99d0e1078a4" translate="yes" xml:space="preserve">
          <source>If this paragraph is a command paragraph, then this method will return the text used to separate the command name from the rest of the paragraph (if any).</source>
          <target state="translated">この段落がコマンドの段落である場合、このメソッドはコマンド名を段落の残りの部分から分離するために使用されたテキストを返します(もしあれば)。</target>
        </trans-unit>
        <trans-unit id="b75f187e2f383fe73ad62fc9d325ab173aba9b5e" translate="yes" xml:space="preserve">
          <source>If this parameter is not used, certain error conditions may raise a fatal error that will cause the program to halt, unless trapped in an &lt;code&gt;eval&lt;/code&gt; block.</source>
          <target state="translated">このパラメーターを使用しない場合、特定のエラー条件によって致命的なエラーが発生し、 &lt;code&gt;eval&lt;/code&gt; ブロックにトラップされない限り、プログラムが停止する可能性があります。</target>
        </trans-unit>
        <trans-unit id="f1f4b76081f3628eb70be0fbee8dbf0d6e9f3ca4" translate="yes" xml:space="preserve">
          <source>If this parameter is not used, certain error conditions may raise a fatal error that will cause the program will halt, unless trapped in an &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; block.</source>
          <target state="translated">このパラメーターを使用しない場合、特定のエラー条件によって重大なエラーが発生し、 &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ブロックでトラップされない限り、プログラムが停止する可能性があります。</target>
        </trans-unit>
        <trans-unit id="0d2fb08e29fba6225fdf1f445f37f2366e459721" translate="yes" xml:space="preserve">
          <source>If this regexp matches, &lt;code&gt;$1&lt;/code&gt; contains a string starting with &lt;code&gt;'ab'&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; is either set to &lt;code&gt;'cd'&lt;/code&gt; or &lt;code&gt;'ef'&lt;/code&gt; , &lt;code&gt;$3&lt;/code&gt; equals either &lt;code&gt;'gi'&lt;/code&gt; or &lt;code&gt;'j'&lt;/code&gt; , and &lt;code&gt;$4&lt;/code&gt; is either set to &lt;code&gt;'gi'&lt;/code&gt; , just like &lt;code&gt;$3&lt;/code&gt; , or it remains undefined.</source>
          <target state="translated">この正規表現と一致した場合、 &lt;code&gt;$1&lt;/code&gt; で始まる文字列が含ま &lt;code&gt;'ab'&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; のいずれかに設定している &lt;code&gt;'cd'&lt;/code&gt; または &lt;code&gt;'ef'&lt;/code&gt; 、 &lt;code&gt;$3&lt;/code&gt; のいずれかに等しい &lt;code&gt;'gi'&lt;/code&gt; または &lt;code&gt;'j'&lt;/code&gt; 、および &lt;code&gt;$4&lt;/code&gt; のいずれかに設定している &lt;code&gt;'gi'&lt;/code&gt; 、ちょうど &lt;code&gt;$3&lt;/code&gt; ように、または未定義のままです。</target>
        </trans-unit>
        <trans-unit id="1b5fa9692a7ddbf5956b5114988e2959b2c5e493" translate="yes" xml:space="preserve">
          <source>If this regexp matches, &lt;code&gt;$1&lt;/code&gt; contains a string starting with &lt;code&gt;'ab'&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt; is either set to &lt;code&gt;'cd'&lt;/code&gt; or &lt;code&gt;'ef'&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt; equals either &lt;code&gt;'gi'&lt;/code&gt; or &lt;code&gt;'j'&lt;/code&gt;, and &lt;code&gt;$4&lt;/code&gt; is either set to &lt;code&gt;'gi'&lt;/code&gt;, just like &lt;code&gt;$3&lt;/code&gt;, or it remains undefined.</source>
          <target state="translated">この正規表現と一致した場合、 &lt;code&gt;$1&lt;/code&gt; で始まる文字列が含ま &lt;code&gt;'ab'&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; のいずれかに設定している &lt;code&gt;'cd'&lt;/code&gt; または &lt;code&gt;'ef'&lt;/code&gt; 、 &lt;code&gt;$3&lt;/code&gt; のいずれかに等しい &lt;code&gt;'gi'&lt;/code&gt; または &lt;code&gt;'j'&lt;/code&gt; 、および &lt;code&gt;$4&lt;/code&gt; のいずれかに設定している &lt;code&gt;'gi'&lt;/code&gt; 、ちょうど &lt;code&gt;$3&lt;/code&gt; ように、またはそれは未定義のままです。</target>
        </trans-unit>
        <trans-unit id="9bf2f5a008449abe516d485f423f30c756bf9374" translate="yes" xml:space="preserve">
          <source>If this seems like a lot, then feel free to inherit from merely the standard Tie::StdHash module for most of your methods, redefining only the interesting ones. See &lt;a href=&quot;Tie::Hash&quot;&gt;Tie::Hash&lt;/a&gt; for details.</source>
          <target state="translated">これが多くのように思われる場合は、ほとんどのメソッドで標準のTie :: StdHashモジュールから継承し、興味深いメソッドのみを再定義してください。詳細については、&lt;a href=&quot;Tie::Hash&quot;&gt;Tie :: Hash&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f4f92dc123bfc535dc7925652fedf35a2b5f0876" translate="yes" xml:space="preserve">
          <source>If this seems like a lot, then feel free to inherit from merely the standard Tie::StdHash module for most of your methods, redefining only the interesting ones. See &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; for details.</source>
          <target state="translated">これが多く思われる場合は、ほとんどのメソッドで標準のTie :: StdHashモジュールから継承して、興味深いものだけを再定義してください。詳細は&lt;a href=&quot;tie/hash&quot;&gt;Tie :: Hash&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="c67ef6ff224aaeb335a4c34ee8f8573b58ab3fc4" translate="yes" xml:space="preserve">
          <source>If this still doesn't work, look into the &lt;code&gt;clearerr&lt;/code&gt; method from &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;, which resets the error and end-of-file states on the handle.</source>
          <target state="translated">それでも機能しない場合は、&lt;a href=&quot;IO::Handle&quot;&gt;IO :: Handleの&lt;/a&gt; &lt;code&gt;clearerr&lt;/code&gt; メソッドを調べてください。これにより、ハンドルのエラー状態とファイルの終わりの状態がリセットされます。</target>
        </trans-unit>
        <trans-unit id="d3f60efe640d39524c6e11c22deb74b1e7bd6e48" translate="yes" xml:space="preserve">
          <source>If this still doesn't work, look into the &lt;code&gt;clearerr&lt;/code&gt; method from &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt;, which resets the error and end-of-file states on the handle.</source>
          <target state="translated">それでも機能しない場合は、&lt;a href=&quot;io/handle&quot;&gt;IO :: Handleの&lt;/a&gt; &lt;code&gt;clearerr&lt;/code&gt; メソッドを調べてください。これにより、ハンドルのエラーとファイルの終わりの状態がリセットされます。</target>
        </trans-unit>
        <trans-unit id="5f660c829995c0ccf8574939955dcb34cbb1fbc2" translate="yes" xml:space="preserve">
          <source>If this template key is true, enforces that if this key is provided by user input, its value is &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt;. This just means that the user is not allowed to pass &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as a value for this key and is equivalent to: allow =&amp;gt; sub { defined $_[0] &amp;amp;&amp;amp; OTHER TESTS }</source>
          <target state="translated">このテンプレートキーがtrueの場合、このキーがユーザー入力によって提供される場合、その値が &lt;code&gt;&lt;a href=&quot;../functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; ように強制します。これは、ユーザーが &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; をこのキーの値として渡すことを許可されておらず、次と同等であることを意味します。allow =&amp;gt; sub {defined $ _ [0] &amp;amp;&amp;amp; OTHER TESTS}</target>
        </trans-unit>
        <trans-unit id="e156c85e449c1c19860e80cb4d0bda5ed5967f61" translate="yes" xml:space="preserve">
          <source>If this template key is true, enforces that if this key is provided by user input, its value is &lt;code&gt;defined&lt;/code&gt;. This just means that the user is not allowed to pass &lt;code&gt;undef&lt;/code&gt; as a value for this key and is equivalent to: allow =&amp;gt; sub { defined $_[0] &amp;amp;&amp;amp; OTHER TESTS }</source>
          <target state="translated">このテンプレートキーがtrueの場合、このキーがユーザー入力によって提供された場合、その値が &lt;code&gt;defined&lt;/code&gt; ように強制します。これは、ユーザーがこのキーの値として &lt;code&gt;undef&lt;/code&gt; を渡すことを許可されておらず、次と同等であることを意味します。allow =&amp;gt; sub {defined $ _ [0] &amp;amp;&amp;amp; OTHER TESTS}</target>
        </trans-unit>
        <trans-unit id="76bbabb48932b2f041b390c777de07be84c85182" translate="yes" xml:space="preserve">
          <source>If this value is defined but false then such an operation has ocurred, but should not impact later operations.</source>
          <target state="translated">この値が定義されていても false の場合は、そのような操作が発生したことになりますが、それ以降の操作には影響しません。</target>
        </trans-unit>
        <trans-unit id="cc6a20a1fa0fe02624d3822b74f6ca89396c5ee4" translate="yes" xml:space="preserve">
          <source>If this variable is set to a true value, then &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; on Windows will not try to open the file. This means that the link count cannot be determined and file attributes may be out of date if additional hardlinks to the file exist. On the other hand, not opening the file is considerably faster, especially for files on network drives.</source>
          <target state="translated">この変数がtrue値に設定されている場合、Windowsの &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; はファイルを開こうとしません。これは、ファイルへの追加のハードリンクが存在する場合、リンク数を特定できず、ファイル属性が古くなる可能性があることを意味します。一方、特にネットワークドライブ上のファイルの場合、ファイルを開かない方がかなり高速です。</target>
        </trans-unit>
        <trans-unit id="bea7dc99d361b98967fbf94336d0529e85ea5d0f" translate="yes" xml:space="preserve">
          <source>If this variable is set to a true value, then &lt;code&gt;stat()&lt;/code&gt; on Windows will not try to open the file. This means that the link count cannot be determined and file attributes may be out of date if additional hardlinks to the file exist. On the other hand, not opening the file is considerably faster, especially for files on network drives.</source>
          <target state="translated">この変数がtrue値に設定されている場合、Windowsの &lt;code&gt;stat()&lt;/code&gt; はファイルを開こうとしません。これは、ファイルへの追加のハードリンクが存在する場合、リンクカウントを判別できず、ファイル属性が古くなっている可能性があることを意味します。一方、ファイルを開かない方が、特にネットワークドライブ上のファイルの場合はかなり高速です。</target>
        </trans-unit>
        <trans-unit id="65e9d7214894094637d48b5893992a1d4deebf1e" translate="yes" xml:space="preserve">
          <source>If this variable is true then such an operation has occurred and anything depending on this module cannot proceed until a reboot has occurred.</source>
          <target state="translated">この変数が真の場合、そのような操作が発生し、リブートが発生するまでこのモジュールに依存するものは何も進みません。</target>
        </trans-unit>
        <trans-unit id="0523b9c70c7c9e8111746aca12afc08517491534" translate="yes" xml:space="preserve">
          <source>If this warning does come from I/O, the easiest way to quiet it is simply to add the &lt;code&gt;:utf8&lt;/code&gt; layer,</source>
          <target state="translated">この警告がI / Oから発生する場合、それを静める最も簡単な方法は、 &lt;code&gt;:utf8&lt;/code&gt; レイヤーを追加することです。</target>
        </trans-unit>
        <trans-unit id="41c3e520fc9953b8c23b0cb154effeffba4245f7" translate="yes" xml:space="preserve">
          <source>If three (or more) arguments are specified, the open mode (including optional encoding) in the second argument are distinct from the filename in the third. If MODE is &lt;code&gt;&amp;lt;&lt;/code&gt; or nothing, the file is opened for input. If MODE is &lt;code&gt;&amp;gt;&lt;/code&gt;, the file is opened for output, with existing files first being truncated (&quot;clobbered&quot;) and nonexisting files newly created. If MODE is &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , the file is opened for appending, again being created if necessary.</source>
          <target state="translated">3つ（またはそれ以上）の引数が指定されている場合、2番目の引数のオープンモード（オプションのエンコーディングを含む）は3番目の引数のファイル名とは異なります。 MODEが &lt;code&gt;&amp;lt;&lt;/code&gt; または何もない場合、ファイルは入力用に開かれます。 MODEが &lt;code&gt;&amp;gt;&lt;/code&gt; の場合、ファイルは出力用に開かれ、既存のファイルは最初に切り捨てられ（「破損」）、存在しないファイルが新しく作成されます。 MODEが &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; の場合、ファイルは追加のために開かれ、必要に応じて再度作成されます。</target>
        </trans-unit>
        <trans-unit id="977c9556940f8be99675602713d0721d1fa68782" translate="yes" xml:space="preserve">
          <source>If trailing data is present immediately after the zip archive and the &lt;code&gt;Transparent&lt;/code&gt; option is enabled, this method will consider that trailing data to be another member of the zip archive.</source>
          <target state="translated">zipアーカイブの直後に末尾のデータが存在し、[ &lt;code&gt;Transparent&lt;/code&gt; ]オプションが有効になっている場合、このメソッドは、末尾のデータがzipアーカイブの別のメンバーであると見なします。</target>
        </trans-unit>
        <trans-unit id="2e10a47d1100af2f4e741fa10c714b1d6eb83c05" translate="yes" xml:space="preserve">
          <source>If true (the default value), we autogenerate a JavaScript in the output directory, and set our HTML files to use it. Currently, the JavaScript is used only to get the browser to remember what stylesheet it prefers. TODO: continue</source>
          <target state="translated">true (デフォルト値)の場合、出力ディレクトリにある JavaScript を自動生成し、それを使用するように HTML ファイルを設定します。現在のところ、JavaScriptはブラウザがどのスタイルシートを好むかを記憶するためにのみ使用されています。TODO:続き</target>
        </trans-unit>
        <trans-unit id="634c500cd04e5d0b913158c1c6e9ccddc0f9bc06" translate="yes" xml:space="preserve">
          <source>If true (the default value), we autogenerate some CSS files in the output directory, and set our HTML files to use those. TODO: continue</source>
          <target state="translated">true (デフォルト値)の場合、出力ディレクトリにある CSS ファイルを自動生成し、それらを使用するように HTML ファイルを設定します。TODO:続きを読む</target>
        </trans-unit>
        <trans-unit id="ed672b2b381b7d94345040cc4eb4667fc3d97c8b" translate="yes" xml:space="preserve">
          <source>If true and a code reference, will be called with the symbolic link name and the directory it lives in as arguments. Otherwise, if true and warnings are on, warning &quot;symbolic_link_name is a dangling symbolic link\n&quot; will be issued. If false, the dangling symbolic link will be silently ignored.</source>
          <target state="translated">もし、真で、コード参照があれば、シンボリックリンク名と、それが住んでいるディレクトリを引数にして呼ばれます。そうでなければ、trueで警告がオンの場合、警告 &quot;symbolic_link_name is a dangling symbolic link\n &quot;が発行されます。false の場合、ぶら下がっているシンボリックリンクは静かに無視されます。</target>
        </trans-unit>
        <trans-unit id="93e6a2b3c3a0187d609e46522f3b6f893e49aa02" translate="yes" xml:space="preserve">
          <source>If true is returned, those arguments &lt;b&gt;should&lt;/b&gt; in theory be processed with &lt;code&gt;quadmath_snprintf()&lt;/code&gt;, but in case there is more than one such format specifier (see &lt;a href=&quot;#quadmath_format_valid&quot;&gt;&quot;quadmath_format_valid&quot;&lt;/a&gt;), and if there is anything else beyond that one (even just a single byte), they &lt;b&gt;cannot&lt;/b&gt; be processed because &lt;code&gt;quadmath_snprintf()&lt;/code&gt; is very strict, accepting only one format spec, and nothing else. In this case, the code should probably fail.</source>
          <target state="translated">trueが返された場合、理論的に&lt;b&gt;は&lt;/b&gt;これらの引数&lt;b&gt;は&lt;/b&gt; &lt;code&gt;quadmath_snprintf()&lt;/code&gt; で処理する必要がありますが、そのような形式指定子が複数ある場合（&lt;a href=&quot;#quadmath_format_valid&quot;&gt;「quadmath_format_valid」を&lt;/a&gt;参照）、それ以外のものがある場合（1バイトだけでも） ）、 &lt;code&gt;quadmath_snprintf()&lt;/code&gt; は非常に厳密であり、1つの形式仕様のみを受け入れ、他には何も受け入れないため、処理&lt;b&gt;できませ&lt;/b&gt;ん。この場合、コードはおそらく失敗するはずです。</target>
        </trans-unit>
        <trans-unit id="3f3fdfd0a40c103a2211bdac354013485a8b6be3" translate="yes" xml:space="preserve">
          <source>If true is returned, those arguments &lt;b&gt;should&lt;/b&gt; in theory be processed with quadmath_snprintf(), but in case there is more than one such format specifier (see &lt;a href=&quot;#quadmath_format_single&quot;&gt;quadmath_format_single&lt;/a&gt;), and if there is anything else beyond that one (even just a single byte), they &lt;b&gt;cannot&lt;/b&gt; be processed because quadmath_snprintf() is very strict, accepting only one format spec, and nothing else. In this case, the code should probably fail.</source>
          <target state="translated">trueが返された場合、これらの引数&lt;b&gt;は&lt;/b&gt;理論的にはquadmath_snprintf（）で処理する必要がありますが、そのようなフォーマット指定子が複数ある場合（&lt;a href=&quot;#quadmath_format_single&quot;&gt;quadmath_format_singleを&lt;/a&gt;参照）、それ以外に何かがある場合（1バイトだけでも）、彼らが&lt;b&gt;することはできません&lt;/b&gt; quadmath_snprintf（）は1つのフォーマットのみの仕様、および他には何を受け入れ、非常に厳格であるため、処理されます。この場合、コードはおそらく失敗するはずです。</target>
        </trans-unit>
        <trans-unit id="0653af7b3995880e12e86c1b6df46b2abdc8adcd" translate="yes" xml:space="preserve">
          <source>If true then &lt;code&gt;Configure&lt;/code&gt; will check each hostname given that it exists</source>
          <target state="translated">trueの場合、 &lt;code&gt;Configure&lt;/code&gt; は、存在する場合、各ホスト名をチェックします</target>
        </trans-unit>
        <trans-unit id="5e192827bd7624c2eefa078600e9250f2fd8d099" translate="yes" xml:space="preserve">
          <source>If true then &lt;code&gt;make test&lt;/code&gt; may attempt to connect to hosts given in the configuration.</source>
          <target state="translated">trueの場合、 &lt;code&gt;make test&lt;/code&gt; は構成で指定されたホストへの接続を試みる場合があります。</target>
        </trans-unit>
        <trans-unit id="0dfb0e1e33130859f2e7e4109870d6a5dff7d085" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;TAP::Harness&lt;/code&gt; will output the verbose results of running its tests.</source>
          <target state="translated">trueの場合、 &lt;code&gt;TAP::Harness&lt;/code&gt; はテストの実行の詳細な結果を出力します。</target>
        </trans-unit>
        <trans-unit id="1bd986bfa48b8d9de9607995da53c20f474abed0" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;Test::Harness&lt;/code&gt; will output the verbose results of running its tests. Setting &lt;code&gt;$Test::Harness::verbose&lt;/code&gt; will override this, or you can use the &lt;code&gt;-v&lt;/code&gt; switch in the</source>
          <target state="translated">trueの場合、 &lt;code&gt;Test::Harness&lt;/code&gt; はテストの実行の詳細な結果を出力します。 &lt;code&gt;$Test::Harness::verbose&lt;/code&gt; を設定すると、これが上書きされます。または、 &lt;code&gt;-v&lt;/code&gt; スイッチを</target>
        </trans-unit>
        <trans-unit id="44529fee5d3eb44416500710e8dc9bea67c57ded" translate="yes" xml:space="preserve">
          <source>If true, STDERR and STDOUT are the same filehandle. This may cause breakage if STDERR contains anything resembling TAP format, but does allow exact synchronization.</source>
          <target state="translated">true の場合、STDERR と STDOUT は同じファイルハンドルです。これは、STDERRにTAPフォーマットに似たものが含まれている場合にブレークする可能性がありますが、正確な同期は可能です。</target>
        </trans-unit>
        <trans-unit id="fe1c5580c4e77a7f54f6b42fc274494bf3ad60b5" translate="yes" xml:space="preserve">
          <source>If true, make install will be verbose</source>
          <target state="translated">true の場合、make install は冗長になります。</target>
        </trans-unit>
        <trans-unit id="a169cfeed98e3c1eafec522650538e080de52944" translate="yes" xml:space="preserve">
          <source>If true, set the &lt;code&gt;SO_BROADCAST&lt;/code&gt; sockopt</source>
          <target state="translated">trueの場合、設定 &lt;code&gt;SO_BROADCAST&lt;/code&gt; sockoptを</target>
        </trans-unit>
        <trans-unit id="2e14d9f9dc273a75bb28fef309ebf7b650f85381" translate="yes" xml:space="preserve">
          <source>If true, set the &lt;code&gt;SO_REUSEADDR&lt;/code&gt; sockopt</source>
          <target state="translated">trueの場合、設定 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; sockoptを</target>
        </trans-unit>
        <trans-unit id="e89fb240c4dc14ea640fd2d16ea6df8791107ad3" translate="yes" xml:space="preserve">
          <source>If true, set the &lt;code&gt;SO_REUSEPORT&lt;/code&gt; sockopt (not all OSes implement this sockopt)</source>
          <target state="translated">trueの場合、 &lt;code&gt;SO_REUSEPORT&lt;/code&gt; sockoptを設定します（すべてのOSがこのsockoptを実装しているわけではありません）</target>
        </trans-unit>
        <trans-unit id="dab1cddffad75299c410b1e954057e9efb6fb3e2" translate="yes" xml:space="preserve">
          <source>If true, uses proxy subs. See &lt;a href=&quot;ExtUtils::Constant::ProxySubs&quot;&gt;ExtUtils::Constant::ProxySubs&lt;/a&gt;.</source>
          <target state="translated">trueの場合、プロキシサブを使用します。&lt;a href=&quot;ExtUtils::Constant::ProxySubs&quot;&gt;ExtUtils :: Constant :: ProxySubsを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="fb2c5a318ef60df6e780dd24e4ef173dd23b6b3c" translate="yes" xml:space="preserve">
          <source>If true, uses proxy subs. See &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Constant::ProxySubs&quot;&gt;ExtUtils::Constant::ProxySubs&lt;/a&gt;.</source>
          <target state="translated">trueの場合、プロキシサブを使用します。&lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Constant::ProxySubs&quot;&gt;ExtUtils :: Constant :: ProxySubsを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="33b670decc24a56dd9e5e0101143f31051cabe4b" translate="yes" xml:space="preserve">
          <source>If two arrays smartmatch each other, then they are deep copies of each others' values, as this example reports:</source>
          <target state="translated">2つの配列がお互いにスマートマッチした場合、この例のようにお互いの値の深いコピーになります。</target>
        </trans-unit>
        <trans-unit id="acee3e1d7871c445b42f87ba144a405a067cf53f" translate="yes" xml:space="preserve">
          <source>If two characters here and next (as code points) are composable (including Hangul Jamo/Syllables and Composition Exclusions), it returns the code point of the composite.</source>
          <target state="translated">ここと次の2つの文字(コードポイントとして)が合成可能な場合(ハングル・ジャモ/音節、合成除外を含む)、合成のコードポイントを返します。</target>
        </trans-unit>
        <trans-unit id="5cba0eaa180ef04fc5494ba487a038ca330cd204" translate="yes" xml:space="preserve">
          <source>If type is non-Unix (see &lt;a href=&quot;#fileparse_set_fstype&quot;&gt;&quot;fileparse_set_fstype&quot;&lt;/a&gt;) then the pattern matching for suffix removal is performed case-insensitively, since those systems are not case-sensitive when opening existing files.</source>
          <target state="translated">タイプが非Unixの場合（&lt;a href=&quot;#fileparse_set_fstype&quot;&gt;「fileparse_set_fstype」を&lt;/a&gt;参照）、既存のファイルを開くときにこれらのシステムでは大文字と小文字が区別されないため、サフィックス削除のパターンマッチングでは大文字と小文字が区別されません。</target>
        </trans-unit>
        <trans-unit id="42360b0ce037c1aa50c01166917adec5fecc2590" translate="yes" xml:space="preserve">
          <source>If type is non-Unix (see &lt;a href=&quot;#fileparse_set_fstype&quot;&gt;fileparse_set_fstype&lt;/a&gt;) then the pattern matching for suffix removal is performed case-insensitively, since those systems are not case-sensitive when opening existing files.</source>
          <target state="translated">タイプが非Unix（&lt;a href=&quot;#fileparse_set_fstype&quot;&gt;fileparse_set_fstypeを&lt;/a&gt;参照）の場合、既存のファイルを開くときに大文字と小文字を区別しないため、サフィックスの削除のパターンマッチングは大文字と小文字を区別せずに実行されます。</target>
        </trans-unit>
        <trans-unit id="2fd48f2e17e1f717f9f154bd3292076827285d01" translate="yes" xml:space="preserve">
          <source>If umask(2) is not implemented on your system and you are trying to restrict access for</source>
          <target state="translated">umask(2)がシステムに実装されておらず、アクセスを制限しようとしている場合は</target>
        </trans-unit>
        <trans-unit id="67a1f447b6ee3db12f569b14d8d5a13cc81a620d" translate="yes" xml:space="preserve">
          <source>If unsafe signals is in effect, then signal handling is not thread-safe, and the &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; signalling method cannot be used.</source>
          <target state="translated">安全でないシグナルが有効な場合、シグナル処理はスレッドセーフではなく、 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; シグナルメソッドは使用できません。</target>
        </trans-unit>
        <trans-unit id="70663a96a9c0a32a9a2fde13b31bf56729b3885e" translate="yes" xml:space="preserve">
          <source>If upgrading is in effect, returns PI, rounded to N digits with the current rounding mode:</source>
          <target state="translated">アップグレードが有効な場合、現在の丸めモードで N 桁に丸められた PI を返します。</target>
        </trans-unit>
        <trans-unit id="6635daa00264b763872dbf741802de705f31e8f0" translate="yes" xml:space="preserve">
          <source>If used with -v &amp;lt;version&amp;gt; then all utilities released with that version of perl are listed, and any utility programs named on the command line are ignored.</source>
          <target state="translated">-v &amp;lt;version&amp;gt;とともに使用すると、そのバージョンのperlでリリースされたすべてのユーティリティが一覧表示され、コマンドラインで指定されたユーティリティプログラムはすべて無視されます。</target>
        </trans-unit>
        <trans-unit id="d763c9ab9f9ca920e89e5e82fe0a4c19ddec98c7" translate="yes" xml:space="preserve">
          <source>If used with a single argument in a scalar context, returns the string consisting of the code points of the named sequence, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if no named sequence by that name exists. If used with a single argument in a list context, it returns the list of the ordinals of the code points.</source>
          <target state="translated">スカラーコンテキストで単一の引数と共に使用した場合、名前付きシーケンスのコードポイントで構成される文字列を返します。その名前の名前付きシーケンスが存在しない場合は、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。リストコンテキストで単一の引数を指定して使用すると、コードポイントの序数のリストが返されます。</target>
        </trans-unit>
        <trans-unit id="da57dfd2566c5bbbb36939e6a816eb57d92a5102" translate="yes" xml:space="preserve">
          <source>If used with a single argument in a scalar context, returns the string consisting of the code points of the named sequence, or &lt;code&gt;undef&lt;/code&gt; if no named sequence by that name exists. If used with a single argument in a list context, it returns the list of the ordinals of the code points.</source>
          <target state="translated">スカラーコンテキストで単一の引数とともに使用される場合、名前付きシーケンスのコードポイントで構成される文字列を返します。その名前の名前付きシーケンスが存在しない場合は、 &lt;code&gt;undef&lt;/code&gt; を返します。リストコンテキストで単一の引数とともに使用すると、コードポイントの序数のリストが返されます。</target>
        </trans-unit>
        <trans-unit id="beaceddc3b74ab2a5e89e9e5517463a3fd4ed9e1" translate="yes" xml:space="preserve">
          <source>If used with no arguments in a list context, it returns a hash with the names of all the named sequences as the keys and their sequences as strings as the values. Otherwise, it returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or an empty list depending on the context.</source>
          <target state="translated">リストコンテキストで引数なしで使用すると、すべての名前付きシーケンスの名前をキーとして、それらのシーケンスを文字列として値を持つハッシュを返します。それ以外の場合は、コンテキストに応じて &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; または空のリストを返します。</target>
        </trans-unit>
        <trans-unit id="0407b6cc8a060a9f5a98513aa0ab0a70e400908b" translate="yes" xml:space="preserve">
          <source>If used with no arguments in a list context, it returns a hash with the names of all the named sequences as the keys and their sequences as strings as the values. Otherwise, it returns &lt;code&gt;undef&lt;/code&gt; or an empty list depending on the context.</source>
          <target state="translated">リストコンテキストで引数なしで使用すると、名前付きシーケンスすべての名前をキーとして、それらのシーケンスを文字列として値として持つハッシュを返します。それ以外の場合は、コンテキストに応じて &lt;code&gt;undef&lt;/code&gt; または空のリストを返します。</target>
        </trans-unit>
        <trans-unit id="20ccd67205017380c2547c8a9567b9cb20e04c0c" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; on a Unicode string (which</source>
          <target state="translated">Unicode文字列で&lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt; &lt;code&gt;crypt&lt;/code&gt; &lt;/a&gt;を使用する場合（</target>
        </trans-unit>
        <trans-unit id="bcae58a7d75cf50d08d76e85d4556f2e6099dd18" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;https://metacpan.org/pod/BerkeleyDB&quot;&gt;BerkeleyDB&lt;/a&gt; isn't an option, there are a number of modules available on CPAN that can be used to implement locking. Each one implements locking differently and has different goals in mind. It is therefore worth knowing the difference, so that you can pick the right one for your application. Here are the three locking wrappers:</source>
          <target state="translated">&lt;a href=&quot;https://metacpan.org/pod/BerkeleyDB&quot;&gt;BerkeleyDB&lt;/a&gt;を使用するオプションがない場合は、ロックを実装するために使用できるCPANで利用可能なモジュールがいくつかあります。それぞれが異なる方法でロックを実装し、異なる目標を念頭に置いています。したがって、アプリケーションに適したものを選択できるように、違いを知ることは価値があります。3つのロッキングラッパーは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="6b1f504c6467cdb5b94820cfba3df9e446f6d20a" translate="yes" xml:space="preserve">
          <source>If using &lt;b&gt;BerkeleyDB&lt;/b&gt; isn't an option, there are a number of modules available on CPAN that can be used to implement locking. Each one implements locking differently and has different goals in mind. It is therefore worth knowing the difference, so that you can pick the right one for your application. Here are the three locking wrappers:</source>
          <target state="translated">&lt;b&gt;BerkeleyDBの&lt;/b&gt;使用がオプションではない場合、ロックの実装に使用できるCPANで利用可能なモジュールがいくつかあります。ロックの実装方法はそれぞれ異なり、目的も異なります。したがって、違いを知っておく価値があるため、アプリケーションに適したものを選択できます。以下は3つのロックラッパーです。</target>
        </trans-unit>
        <trans-unit id="b0d8dee3f60efc11f28b77ac32acb4a0d6da837c" translate="yes" xml:space="preserve">
          <source>If using a Perl file as a source, optional switches may be passed which will be used when invoking the perl executable.</source>
          <target state="translated">Perlファイルをソースとして使用している場合、オプションのスイッチを渡すことができます。</target>
        </trans-unit>
        <trans-unit id="a612abcdba4adc1d68486aebb4d51b768494dc19" translate="yes" xml:space="preserve">
          <source>If using adb, a &quot;basic&quot; Configure line will look like this:</source>
          <target state="translated">adbを使用している場合、&quot;基本的な &quot;Configure行は次のようになります。</target>
        </trans-unit>
        <trans-unit id="d2c2e41b4856cbf4192df9fdfdae8eb4debbc3b0" translate="yes" xml:space="preserve">
          <source>If using crypt() on a Unicode string (which</source>
          <target state="translated">crypt()を Unicode 文字列 (これは</target>
        </trans-unit>
        <trans-unit id="45cfcf2e0c855940dc64008801ae135f972cfd74" translate="yes" xml:space="preserve">
          <source>If using ftp remember to transfer the distribution in binary format.</source>
          <target state="translated">ftpを使用する場合は、バイナリ形式で転送することを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="b6fa09de90b513e62acb77e553ed8a67bf3a34b1" translate="yes" xml:space="preserve">
          <source>If using gcc, you can add the &lt;code&gt;-std=c89&lt;/code&gt; option which will hopefully catch most of these unportabilities. (However it might also catch incompatibilities in your system's header files.)</source>
          <target state="translated">gccを使用している場合は、これらの非移植性のほとんどをうまくキャッチできる &lt;code&gt;-std=c89&lt;/code&gt; オプションを追加できます。（ただし、システムのヘッダーファイルの非互換性も検出される場合があります。）</target>
        </trans-unit>
        <trans-unit id="fae0365130c2e3d1490dd7527e14992a1ddb3fda" translate="yes" xml:space="preserve">
          <source>If using ssh, it's not too different -- we just change targetrun to ssh, and pass in targetuser and targetport. It ends up looking like this:</source>
          <target state="translated">ssh を使用している場合は、それほど違いはありません --targetrun を ssh に変更して、targetuser と targetport を渡すだけです。最終的には以下のようになります。</target>
        </trans-unit>
        <trans-unit id="664754e120bf0080d8c4c2636edd9c4d43e0b86a" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; pragma without an explicit encoding name, the PERL_ENCODING environment variable is consulted for an encoding name.</source>
          <target state="translated">明示的なエンコーディング名なしで &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; プラグマを使用する場合、エンコーディング名についてPERL_ENCODING環境変数が調べられます。</target>
        </trans-unit>
        <trans-unit id="47d8d46dc66c1660b89d6816f6548597b112a1d7" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;gcc -Wall&lt;/code&gt; note that not all the possible warnings (like &lt;code&gt;-Wuninitialized&lt;/code&gt;) are given unless you also compile with &lt;code&gt;-O&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gcc -Wall&lt;/code&gt; を使用する場合は、 &lt;code&gt;-O&lt;/code&gt; を使用してコンパイルしない限り、考えられるすべての警告（ &lt;code&gt;-Wuninitialized&lt;/code&gt; など）が表示されるわけではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="cfca052b74a8f394827d7f4faa9fd4f5bf5109bf" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;gcc -Wall&lt;/code&gt; note that not all the possible warnings (like &lt;code&gt;-Wunitialized&lt;/code&gt; ) are given unless you also compile with &lt;code&gt;-O&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;gcc -Wall&lt;/code&gt; を使用する場合、 &lt;code&gt;-O&lt;/code&gt; を指定してコンパイルしない限り、すべての警告（ &lt;code&gt;-Wunitialized&lt;/code&gt; など）が表示されるわけではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="fa9480a44177272fde2828188fac358cc2184e4c" translate="yes" xml:space="preserve">
          <source>If using the &lt;code&gt;use encoding&lt;/code&gt; pragma without an explicit encoding name, the PERL_ENCODING environment variable is consulted for an encoding name.</source>
          <target state="translated">明示的なエンコーディング名なしでuseencodingプラグマを &lt;code&gt;use encoding&lt;/code&gt; 場合、エンコーディング名についてPERL_ENCODING環境変数が参照されます。</target>
        </trans-unit>
        <trans-unit id="49dda8790f1c37a11e446613192c2ff1c5642e05" translate="yes" xml:space="preserve">
          <source>If using the VC IDE, to build use for example the File-&amp;gt;Open Workspace-&amp;gt; C:\Symbian\8.0a\S60_2nd_FP2\epoc32\build\symbian\perl\perl\wins\perl.dsw The emulator binaries will appear in the same directory.</source>
          <target state="translated">VC IDEを使用している場合、ビルドするには、たとえば[ファイル]-&amp;gt; [ワークスペースを開く]-&amp;gt; [C：\ Symbian \ 8.0a \ S60_2nd_FP2 \ epoc32 \ build \ symbian \ perl \ perl \ wins \ perl.dsw]を使用します。エミュレータのバイナリは次の場所に表示されます。同じディレクトリ。</target>
        </trans-unit>
        <trans-unit id="87f25526e76efefdb9a4ff18e831107d545ddc34" translate="yes" xml:space="preserve">
          <source>If using the VC IDE, you will a lot of warnings in the beginning of the build because a lot of headers mentioned by the source cannot be found, but this is not serious since those headers are not used.</source>
          <target state="translated">VC IDEを使用している場合、ソースで言及されている多くのヘッダが見つからないため、ビルドの最初に多くの警告が表示されますが、これらのヘッダは使用されていないので、これは深刻ではありません。</target>
        </trans-unit>
        <trans-unit id="95f6a03b7ab2b25638142acde2118920ba4f7593" translate="yes" xml:space="preserve">
          <source>If we add a &lt;code&gt;(*PRUNE)&lt;/code&gt; before the count like the following</source>
          <target state="translated">次のようにカウントの前に &lt;code&gt;(*PRUNE)&lt;/code&gt; を追加すると</target>
        </trans-unit>
        <trans-unit id="f49196da102bf295b3091d7157018af8c9071a57" translate="yes" xml:space="preserve">
          <source>If we call a method on a &lt;code&gt;Child&lt;/code&gt; object and that method is not defined in the &lt;code&gt;Child&lt;/code&gt; class, Perl will look for that method in the &lt;code&gt;Parent&lt;/code&gt; class and then, if necessary, in the &lt;code&gt;Grandparent&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;Child&lt;/code&gt; オブジェクトのメソッドを呼び出し、そのメソッドが &lt;code&gt;Child&lt;/code&gt; クラスで定義されていない場合、Perlは &lt;code&gt;Parent&lt;/code&gt; クラスでそのメソッドを探し、必要に応じて &lt;code&gt;Grandparent&lt;/code&gt; クラスで探します。</target>
        </trans-unit>
        <trans-unit id="ef968fd799fd1b1033f77f3853f27266c25aff48" translate="yes" xml:space="preserve">
          <source>If we can tell that there is no valid start point then we don't bother running the interpreter at all. Likewise, if we know from the analysis phase that we cannot detect a short-cut to the start position, we go straight to the interpreter.</source>
          <target state="translated">有効な開始点がないことがわかれば、わざわざインタプリタを実行する必要はありません。同様に、解析の段階で開始位置へのショートカットが検出できないことがわかった場合は、そのままインタープリタを実行します。</target>
        </trans-unit>
        <trans-unit id="ee8cb3b419bcafdec86df4116638973be94d94a5" translate="yes" xml:space="preserve">
          <source>If we could reliably use `goto &amp;amp;` on core builtins, we wouldn't need this subroutine.</source>
          <target state="translated">コアビルトインで `goto＆`を確実に使用できれば、このサブルーチンは必要ありません。</target>
        </trans-unit>
        <trans-unit id="2cd027f23ebc9bafdd0ef83ac988a2e8f6205abb" translate="yes" xml:space="preserve">
          <source>If we encrypt this with &lt;code&gt;mkrot13&lt;/code&gt; :</source>
          <target state="translated">これを &lt;code&gt;mkrot13&lt;/code&gt; で暗号化すると：</target>
        </trans-unit>
        <trans-unit id="b2db7414804acef79a0ead64758e1284fbf24a9c" translate="yes" xml:space="preserve">
          <source>If we encrypt this with &lt;code&gt;mkrot13&lt;/code&gt;:</source>
          <target state="translated">これを &lt;code&gt;mkrot13&lt;/code&gt; で暗号化すると：</target>
        </trans-unit>
        <trans-unit id="b742d69e435d1dc4ae57558eae468b9e3038bfd1" translate="yes" xml:space="preserve">
          <source>If we have a string which needs to be modified, while a regex will almost always be much more flexible, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt;, an oft underused tool, can still be a useful. One scenario might be replace all vowels with another character. The regex solution might look like this:</source>
          <target state="translated">変更が必要な文字列がある場合、正規表現はほとんどの場合はるかに柔軟性がありますが、よく使用されないツールである &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; は依然として有用です。1つのシナリオでは、すべての母音を別の文字に置き換える場合があります。正規表現ソリューションは次のようになります。</target>
        </trans-unit>
        <trans-unit id="d8dec03047abaaa8042a15b74ce655789698f5d5" translate="yes" xml:space="preserve">
          <source>If we have a string which needs to be modified, while a regex will almost always be much more flexible, &lt;code&gt;tr&lt;/code&gt;, an oft underused tool, can still be a useful. One scenario might be replace all vowels with another character. The regex solution might look like this:</source>
          <target state="translated">変更が必要な文字列がある場合、正規表現はほとんどの場合はるかに柔軟ですが、よく使用されないツールである &lt;code&gt;tr&lt;/code&gt; は依然として有用です。1つのシナリオは、すべての母音を別の文字に置き換えることです。正規表現ソリューションは次のようになります。</target>
        </trans-unit>
        <trans-unit id="e9e855f5e5eecc49e2e1826c2e605b2358ee8b64" translate="yes" xml:space="preserve">
          <source>If we look at any of the C code generated by any of the examples except example 1, you will notice a number of references to ST(n), where n is usually 0. &quot;ST&quot; is actually a macro that points to the n'th argument on the argument stack. ST(0) is thus the first argument on the stack and therefore the first argument passed to the XSUB, ST(1) is the second argument, and so on.</source>
          <target state="translated">例1以外の例で生成されたC言語のコードを見ると、ST(n)を参照していることに気づくでしょう。ST(0)はスタック上の最初の引数であり、XSUBに渡される最初の引数です。</target>
        </trans-unit>
        <trans-unit id="b4b727c2115d816f7a5edf98b373babd311821be" translate="yes" xml:space="preserve">
          <source>If we replace the &lt;code&gt; (?{local $c = $c + 1;})&lt;/code&gt; with &lt;code&gt; (?{$c = $c + 1;})&lt;/code&gt;, the variable changes are</source>
          <target state="translated">&lt;code&gt; (?{local $c = $c + 1;})&lt;/code&gt; を &lt;code&gt; (?{$c = $c + 1;})&lt;/code&gt; に置き換えると、変数の変更は</target>
        </trans-unit>
        <trans-unit id="6b22701c7de1c1b18f83a3da253320877e6db57e" translate="yes" xml:space="preserve">
          <source>If we want to call the function in scalar context, we have to do a bit more work. We can really have any code we like inside the braces, so we simply have to end with the scalar reference, although how you do that is up to you, and you can use code inside the braces. Note that the use of parens creates a list context, so we need &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; to force the scalar context on the function:</source>
          <target state="translated">関数をスカラーコンテキストで呼び出す場合は、もう少し作業を行う必要があります。中かっこの中に好きなコードを置くことができるので、スカラー参照で終わらせればよいだけです。私たちに必要なので、括弧の使用は、リストコンテキストを作成することに注意してください &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 関数にスカラーコンテキストを強制します：</target>
        </trans-unit>
        <trans-unit id="b2ecb0d182e5a6aa3494d3aa82a88c04143a9745" translate="yes" xml:space="preserve">
          <source>If we want to call the function in scalar context, we have to do a bit more work. We can really have any code we like inside the braces, so we simply have to end with the scalar reference, although how you do that is up to you, and you can use code inside the braces. Note that the use of parens creates a list context, so we need &lt;code&gt;scalar&lt;/code&gt; to force the scalar context on the function:</source>
          <target state="translated">スカラーコンテキストで関数を呼び出したい場合は、もう少し作業を行う必要があります。中括弧内には実際に好きなコードを含めることができるので、スカラー参照で終了する必要がありますが、それをどのように行うかはあなた次第であり、中括弧内でコードを使用できます。私たちに必要なので、括弧の使用は、リストコンテキストを作成することに注意してください &lt;code&gt;scalar&lt;/code&gt; 関数にスカラーコンテキストを強制します：</target>
        </trans-unit>
        <trans-unit id="2aa4af82f261a5bfccad859728bbc5e698f2ad5a" translate="yes" xml:space="preserve">
          <source>If we want to sort by the hash value instead, we use the hash key to look it up. We still get out a list of keys, but this time they are ordered by their value.</source>
          <target state="translated">代わりにハッシュ値でソートしたい場合は、ハッシュキーを使って検索します。これでもキーのリストが出てきますが、今回は値でソートされています。</target>
        </trans-unit>
        <trans-unit id="1a0a23be20e0afdc53dc3805694c934e04c1d63f" translate="yes" xml:space="preserve">
          <source>If we wanted to include the mp3's title in the greeting, we could override the method:</source>
          <target state="translated">挨拶の中にmp3のタイトルを入れたい場合は、このメソッドをオーバーライドすることができます。</target>
        </trans-unit>
        <trans-unit id="215abf71d62aea6c4bacd7ab63842ca42cbc8d09" translate="yes" xml:space="preserve">
          <source>If we were interested in performance, not in code compactness, in the success branch we would not use &lt;code&gt;XPUSHs&lt;/code&gt; macros, but &lt;code&gt;PUSHs&lt;/code&gt; macros, and would pre-extend the stack before pushing the return values:</source>
          <target state="translated">コードのコンパクトさではなくパフォーマンスに関心がある場合、成功分岐では &lt;code&gt;XPUSHs&lt;/code&gt; マクロではなく &lt;code&gt;PUSHs&lt;/code&gt; マクロを使用し、戻り値をプッシュする前にスタックを事前に拡張します。</target>
        </trans-unit>
        <trans-unit id="65993e20767895a57d8f797f997352ddbf9ddad7" translate="yes" xml:space="preserve">
          <source>If we've done things right, you'll probably want to write a new source, rather than sub-classing this (see &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; for that).</source>
          <target state="translated">正しく行った場合は、これをサブクラス化するのではなく、新しいソースを作成することをお勧めします（これについては、&lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="ed55ede23a733b9689b8f241805b425f9dc0c341" translate="yes" xml:space="preserve">
          <source>If we've done things right, you'll probably want to write a new source, rather than sub-classing this (see &lt;a href=&quot;sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; for that).</source>
          <target state="translated">私たちが正しいことを行っていれば、おそらくこれをサブクラス化するのではなく、新しいソースを記述したいと思うでしょう（そのための&lt;a href=&quot;sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="433a6e7876c97a91d0108a2079322b6917a252c6" translate="yes" xml:space="preserve">
          <source>If what the angle brackets contain is a simple scalar variable (for example, &lt;code&gt;$foo&lt;/code&gt; ), then that variable contains the name of the filehandle to input from, or its typeglob, or a reference to the same. For example:</source>
          <target state="translated">山かっこに含まれているものが単純なスカラー変数（たとえば、 &lt;code&gt;$foo&lt;/code&gt; ）である場合、その変数には、入力元のファイルハンドルの名前、そのタイプグロブ、またはその参照が含まれます。例えば：</target>
        </trans-unit>
        <trans-unit id="6838a6ca305b32b023903f5887f6858a0601c74f" translate="yes" xml:space="preserve">
          <source>If what the angle brackets contain is a simple scalar variable (for example, &lt;code&gt;$foo&lt;/code&gt;), then that variable contains the name of the filehandle to input from, or its typeglob, or a reference to the same. For example:</source>
          <target state="translated">山かっこに含まれるものが単純なスカラー変数（たとえば、 &lt;code&gt;$foo&lt;/code&gt; ）である場合、その変数には、入力元のファイルハンドルの名前、そのtypeglob、または同じものへの参照が含まれます。例えば：</target>
        </trans-unit>
        <trans-unit id="0b51d046d4f4e47130f90dab13b7fc186caff6e3" translate="yes" xml:space="preserve">
          <source>If what's within the angle brackets is neither a filehandle nor a simple scalar variable containing a filehandle name, typeglob, or typeglob reference, it is interpreted as a filename pattern to be globbed, and either a list of filenames or the next filename in the list is returned, depending on context. This distinction is determined on syntactic grounds alone. That means &lt;code&gt;&amp;lt;$x&amp;gt;&lt;/code&gt; is always a &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; from an indirect handle, but &lt;code&gt;&amp;lt;$hash{key}&amp;gt;&lt;/code&gt; is always a &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt;. That's because &lt;code&gt;$x&lt;/code&gt; is a simple scalar variable, but &lt;code&gt;$hash{key}&lt;/code&gt; is not--it's a hash element. Even &lt;code&gt;&amp;lt;$x &amp;gt;&lt;/code&gt; (note the extra space) is treated as &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;$x &quot;)&lt;/code&gt; , not &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline($x)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">山かっこ内にあるものがファイルハンドルでも、ファイルハンドル名、typeglob、typeglob参照を含む単純なスカラー変数でもない場合、それは、グロブされるファイル名パターン、およびファイル名のリストまたはリスト内の次のファイル名として解釈されますコンテキストに応じて返されます。この区別は、構文上の理由だけで決定されます。つまり、 &lt;code&gt;&amp;lt;$x&amp;gt;&lt;/code&gt; は常に間接ハンドルからの &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline()&lt;/a&gt;&lt;/code&gt; ですが、 &lt;code&gt;&amp;lt;$hash{key}&amp;gt;&lt;/code&gt; は常に &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; です。これは、 &lt;code&gt;$x&lt;/code&gt; は単純なスカラー変数ですが、 &lt;code&gt;$hash{key}&lt;/code&gt; はそうではなく、ハッシュ要素であるためです。でも、 &lt;code&gt;&amp;lt;$x &amp;gt;&lt;/code&gt; （余分なスペースに注意）として扱われ &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;$x &quot;)&lt;/code&gt; 、ない &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline($x)&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6919e586a25966a42d5d004843760749c92f077" translate="yes" xml:space="preserve">
          <source>If what's within the angle brackets is neither a filehandle nor a simple scalar variable containing a filehandle name, typeglob, or typeglob reference, it is interpreted as a filename pattern to be globbed, and either a list of filenames or the next filename in the list is returned, depending on context. This distinction is determined on syntactic grounds alone. That means &lt;code&gt;&amp;lt;$x&amp;gt;&lt;/code&gt; is always a &lt;code&gt;readline()&lt;/code&gt; from an indirect handle, but &lt;code&gt;&amp;lt;$hash{key}&amp;gt;&lt;/code&gt; is always a &lt;code&gt;glob()&lt;/code&gt;. That's because &lt;code&gt;$x&lt;/code&gt; is a simple scalar variable, but &lt;code&gt;$hash{key}&lt;/code&gt; is not--it's a hash element. Even &lt;code&gt;&amp;lt;$x &amp;gt;&lt;/code&gt; (note the extra space) is treated as &lt;code&gt;glob(&quot;$x &quot;)&lt;/code&gt;, not &lt;code&gt;readline($x)&lt;/code&gt;.</source>
          <target state="translated">山かっこ内にあるのがファイルハンドルでも、ファイルハンドル名、typeglob、またはtypeglob参照を含む単純なスカラー変数でもない場合、グロブされるファイル名パターン、およびファイル名のリストまたはリスト内の次のファイル名として解釈されます。コンテキストに応じて、が返されます。この区別は、構文上の理由だけで決定されます。つまり、 &lt;code&gt;&amp;lt;$x&amp;gt;&lt;/code&gt; は常に間接ハンドルからの &lt;code&gt;readline()&lt;/code&gt; ですが、 &lt;code&gt;&amp;lt;$hash{key}&amp;gt;&lt;/code&gt; は常に &lt;code&gt;glob()&lt;/code&gt; です。これは、 &lt;code&gt;$x&lt;/code&gt; は単純なスカラー変数ですが、 &lt;code&gt;$hash{key}&lt;/code&gt; はそうではないためです。これはハッシュ要素です。でも、 &lt;code&gt;&amp;lt;$x &amp;gt;&lt;/code&gt; （余分なスペースに注意）として扱われ &lt;code&gt;glob(&quot;$x &quot;)&lt;/code&gt; ではなく、 &lt;code&gt;readline($x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b842d8a427447b55d56f0f86ffb1407d7bbf70b" translate="yes" xml:space="preserve">
          <source>If whitespace is mostly irrelevant, how does one include space characters in an extended regexp? The answer is to backslash it &lt;code&gt;'\ '&lt;/code&gt; or put it in a character class &lt;code&gt;[ ]&lt;/code&gt; . The same thing goes for pound signs: use &lt;code&gt;\#&lt;/code&gt; or &lt;code&gt;[#]&lt;/code&gt;. For instance, Perl allows a space between the sign and the mantissa or integer, and we could add this to our regexp as follows:</source>
          <target state="translated">空白がほとんど関係がない場合、拡張正規表現に空白文字を含めるにはどうすればよいですか？答えは &lt;code&gt;'\ '&lt;/code&gt; をバックスラッシュするか、文字クラス &lt;code&gt;[ ]&lt;/code&gt; 入れることです。同じことがポンド記号にも当てはまります。 &lt;code&gt;\#&lt;/code&gt; または &lt;code&gt;[#]&lt;/code&gt; を使用してください。たとえば、Perlでは符号と仮数または整数の間にスペースを使用できます。これを次のように正規表現に追加できます。</target>
        </trans-unit>
        <trans-unit id="5ea95fa4866be380e5de6f53e01cf2830a2660fd" translate="yes" xml:space="preserve">
          <source>If whitespace is mostly irrelevant, how does one include space characters in an extended regexp? The answer is to backslash it &lt;code&gt;'\ '&lt;/code&gt; or put it in a character class &lt;code&gt;[ ]&lt;/code&gt;. The same thing goes for pound signs: use &lt;code&gt;\#&lt;/code&gt; or &lt;code&gt;[#]&lt;/code&gt;. For instance, Perl allows a space between the sign and the mantissa or integer, and we could add this to our regexp as follows:</source>
          <target state="translated">空白がほとんど関係ない場合、拡張正規表現にスペース文字を含めるにはどうすればよいですか？答えは、バックスラッシュ &lt;code&gt;'\ '&lt;/code&gt; または文字クラス &lt;code&gt;[ ]&lt;/code&gt; 入れることです。同じことがポンド記号にも当てはまります。 &lt;code&gt;\#&lt;/code&gt; または &lt;code&gt;[#]&lt;/code&gt; を使用します。たとえば、Perlでは、記号と仮数または整数の間にスペースを入れることができます。これを次のように正規表現に追加できます。</target>
        </trans-unit>
        <trans-unit id="f6171e2e12a8c60c3485d29916f7ac5529de6161" translate="yes" xml:space="preserve">
          <source>If writing a plugin is not enough, you can write your own test harness; one of the motives for the 3.00 rewrite of Test::Harness was to make it easier to subclass and extend.</source>
          <target state="translated">プラグインを書くだけでは十分でない場合は、独自のテストハーネスを書くことができます。3.00のTest::Harnessの書き換えの動機の一つは、サブクラスと拡張をより簡単にすることでした。</target>
        </trans-unit>
        <trans-unit id="0ac523288e8907db49cd44aeec42c46983d54f41" translate="yes" xml:space="preserve">
          <source>If you</source>
          <target state="translated">もし、あなたが</target>
        </trans-unit>
        <trans-unit id="a97a499d1638eac60812016983597e71f2e68467" translate="yes" xml:space="preserve">
          <source>If you &quot;mmap&quot; the file with the File::Map module from CPAN, you can virtually load the entire file into a string without actually storing it in memory:</source>
          <target state="translated">CPANのFile::Mapモジュールを使用してファイルを「mmap」すると、実際にメモリに保存することなく、事実上ファイル全体を文字列にロードすることができます。</target>
        </trans-unit>
        <trans-unit id="bbc7d708aba8a01827e46990051f630f335a2e71" translate="yes" xml:space="preserve">
          <source>If you &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; without ever waiting on your children, you will accumulate zombies. On some systems, you can avoid this by setting &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&lt;code&gt;$SIG{CHLD}&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt;. See also &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more examples of forking and reaping moribund children.</source>
          <target state="translated">あなたがいる場合&lt;a href=&quot;#fork&quot;&gt; &lt;code&gt;fork&lt;/code&gt; &lt;/a&gt;、これまであなたの子供に待つことなく、あなたはゾンビを蓄積します。一部のシステムでは、&lt;a href=&quot;perlvar#%25SIG&quot;&gt; &lt;code&gt;$SIG{CHLD}&lt;/code&gt; &lt;/a&gt;を &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 設定することでこれを回避できます。瀕死の子供たちをフォークして刈り取る例については、&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="e9fdf3b9fc81571db27bb02cd29a8e0b53b10cc5" translate="yes" xml:space="preserve">
          <source>If you &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; without ever waiting on your children, you will accumulate zombies. On some systems, you can avoid this by setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . See also &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for more examples of forking and reaping moribund children.</source>
          <target state="translated">あなたがいる場合 &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 、これまであなたの子供に待つことなく、あなたはゾンビを蓄積します。一部のシステムでは、 &lt;code&gt;$SIG{CHLD}&lt;/code&gt; を &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; に設定することでこれを回避できます。瀕死の子供をフォークしたり刈り取ったりする例については、&lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="3342529f369584d116691354aca02d8a637cdc3f" translate="yes" xml:space="preserve">
          <source>If you &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; without ever waiting on your children, you will accumulate zombies. On some systems, you can avoid this by setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . See also &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for more examples of forking and reaping moribund children.</source>
          <target state="translated">あなたがいる場合 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 、これまであなたの子供に待つことなく、あなたはゾンビを蓄積します。一部のシステムでは、 &lt;code&gt;$SIG{CHLD}&lt;/code&gt; を &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; に設定することでこれを回避できます。瀕死の子供をフォークしたり刈り取ったりする例については、&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="bb90d14b290d4320ac5634dcbc5bece03b18182e" translate="yes" xml:space="preserve">
          <source>If you actually need to be able to get a real reference back from each hash entry, you can use the Tie::RefHash module, which does the required work for you.</source>
          <target state="translated">各ハッシュエントリから実際に参照を取得する必要がある場合は、Tie::RefHashモジュールを使うことができます。</target>
        </trans-unit>
        <trans-unit id="0863c378529bcaaf05a08fbe7b9d62fcdd40f533" translate="yes" xml:space="preserve">
          <source>If you actually want to bless into the stringified version of the reference supplied, you need to stringify it yourself, for example by:</source>
          <target state="translated">もし実際に、与えられた参照の文字列化されたバージョンに bless したいのであれば、例えば以下のように自分で文字列化する必要があります。</target>
        </trans-unit>
        <trans-unit id="7632fd79ddaeaed4fd83611844af65a8558ccb38" translate="yes" xml:space="preserve">
          <source>If you actually want to pack Unicode codepoints, use the &lt;code&gt;&quot;U&quot;&lt;/code&gt; format instead.</source>
          <target state="translated">Unicodeコードポイントをパックしたい場合は、代わりに &lt;code&gt;&quot;U&quot;&lt;/code&gt; 形式を使用してください。</target>
        </trans-unit>
        <trans-unit id="30a06cdba55cf94e2b0d8887615268f65da700c2" translate="yes" xml:space="preserve">
          <source>If you add the &lt;code&gt;stringify&lt;/code&gt; import option to your &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; declaration, then using a threads object in a string or a string context (e.g., as a hash key) will cause its ID to be used as the value:</source>
          <target state="translated">&lt;code&gt;stringify&lt;/code&gt; インポートオプションを &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; 宣言に追加した場合、文字列または文字列コンテキストで（たとえば、ハッシュキーとして）スレッドオブジェクトを使用すると、そのIDが値として使用されます。</target>
        </trans-unit>
        <trans-unit id="30adb136bf842fc19188bd6258e57dee7ddb8e9f" translate="yes" xml:space="preserve">
          <source>If you add the &lt;code&gt;stringify&lt;/code&gt; import option to your &lt;code&gt;use threads&lt;/code&gt; declaration, then using a threads object in a string or a string context (e.g., as a hash key) will cause its ID to be used as the value:</source>
          <target state="translated">あなたが追加した場合は &lt;code&gt;stringify&lt;/code&gt; あなたにインポートオプションを &lt;code&gt;use threads&lt;/code&gt; 宣言、その後、（ハッシュキーとして、例えば）は、文字列または文字列のコンテキストでスレッドオブジェクトを使用すると、そのIDが値として使用されるようになります：</target>
        </trans-unit>
        <trans-unit id="24defde4aa2bffa14e170e2d3b5990c2b9ad5b66" translate="yes" xml:space="preserve">
          <source>If you already have a Perl repository, you should ensure that you're on the</source>
          <target state="translated">すでに Perl リポジトリを持っている場合は、そのリポジトリが</target>
        </trans-unit>
        <trans-unit id="77f0b688e7f7db776b8a41a0294b1be395b96046" translate="yes" xml:space="preserve">
          <source>If you already have the data in memory or if you want to keep your code simple, you can use one of the sv_cat*() variants, such as sv_catpvn(). If you want to insert anywhere in the string you can use sv_insert() or sv_insert_flags().</source>
          <target state="translated">すでにメモリにデータがある場合や、コードをシンプルにしたい場合は、 sv_catpvn()のような sv_cat*()を使用することができます。文字列のどこかに挿入したい場合は、 sv_insert()あるいは sv_insert_flags()を使用します。</target>
        </trans-unit>
        <trans-unit id="d0e6e027d69f3e21d5d8d4eaafdf5a18b7a271a0" translate="yes" xml:space="preserve">
          <source>If you also specify the &lt;code&gt;save&lt;/code&gt; option newly passing tests will be excluded from subsequent runs.</source>
          <target state="translated">&lt;code&gt;save&lt;/code&gt; オプションも指定すると、新しく合格したテストは以降の実行から除外されます。</target>
        </trans-unit>
        <trans-unit id="f2315b4f443374dc91536026901e2322007448a6" translate="yes" xml:space="preserve">
          <source>If you alter your @_ arguments in a subroutine (such as with &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;), the stack backtrace will not show the original values.</source>
          <target state="translated">サブルーチンで@_引数を変更した場合（ &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; など）、スタックのバックトレースには元の値が表示されません。</target>
        </trans-unit>
        <trans-unit id="87b7e2c0f9e7bf47de8a9bd321c66e6de23241e4" translate="yes" xml:space="preserve">
          <source>If you alter your @_ arguments in a subroutine (such as with &lt;code&gt;shift&lt;/code&gt; or &lt;code&gt;pop&lt;/code&gt;), the stack backtrace will not show the original values.</source>
          <target state="translated">サブルーチンで@_引数を変更した場合（ &lt;code&gt;shift&lt;/code&gt; や &lt;code&gt;pop&lt;/code&gt; など）、スタックバックトレースには元の値が表示されません。</target>
        </trans-unit>
        <trans-unit id="a5bf3485b53b1f2fcb4fdcf6bb2cccc1e74cefad" translate="yes" xml:space="preserve">
          <source>If you are a committer to Perl and you think the patch is good, you can then merge it into blead then push it out to the main repository:</source>
          <target state="translated">もしあなたが Perl のコミッターで、そのパッチが良いと思ったら、それを blead にマージしてメインリポジトリにプッシュすることができます。</target>
        </trans-unit>
        <trans-unit id="bcce70763746b8ab89abce0fda8214efc82356bb" translate="yes" xml:space="preserve">
          <source>If you are accustomed to using perl from various command-line shells found in UNIX environments, you will be less than pleased with what Windows offers by way of a command shell.</source>
          <target state="translated">UNIX 環境で見られる様々なコマンドラインシェルから perl を使うことに慣れている人は、Windows がコマンドシェルの形で提供しているものにあまり満足していないでしょう。</target>
        </trans-unit>
        <trans-unit id="75851b1a6055f8c9601d27bb8e4f2638f62e5f5e" translate="yes" xml:space="preserve">
          <source>If you are advanced enough with building C code, here is a suggestion to speed up building perl, and the later &lt;code&gt;make test&lt;/code&gt; . Try to keep your PATH enviromental variable with the least number of folders possible (remember to keep your C compiler's folders there). &lt;code&gt;C:\WINDOWS\system32&lt;/code&gt; or &lt;code&gt;C:\WINNT\system32&lt;/code&gt; depending on your OS version should be first folder in PATH, since &quot;cmd.exe&quot; is the most commonly launched program during the build and later testing.</source>
          <target state="translated">Cコードのビルドに十分慣れている場合は、perlのビルドを高速化するための提案と、後で &lt;code&gt;make test&lt;/code&gt; を実行します。可能な限り少ない数のフォルダーでPATH環境変数を維持するようにしてください（Cコンパイラーのフォルダーをそこに維持することを忘れないでください）。 &lt;code&gt;C:\WINDOWS\system32&lt;/code&gt; または &lt;code&gt;C:\WINNT\system32&lt;/code&gt; は、OSバージョンに応じて、PATHの最初のフォルダーにする必要があります。これは、「cmd.exe」がビルドおよびその後のテスト中に最も一般的に起動されるプログラムであるためです。</target>
        </trans-unit>
        <trans-unit id="04da8dab27ca1a90f04cb94a9ccc32581630ed82" translate="yes" xml:space="preserve">
          <source>If you are advanced enough with building C code, here is a suggestion to speed up building perl, and the later &lt;code&gt;make test&lt;/code&gt;. Try to keep your PATH environmental variable with the least number of folders possible (remember to keep your C compiler's folders there). &lt;code&gt;C:\WINDOWS\system32&lt;/code&gt; or &lt;code&gt;C:\WINNT\system32&lt;/code&gt; depending on your OS version should be first folder in PATH, since &quot;cmd.exe&quot; is the most commonly launched program during the build and later testing.</source>
          <target state="translated">Cコードの構築が十分に進んでいる場合は、perlの構築を高速化し、後で &lt;code&gt;make test&lt;/code&gt; 。可能な限り少ない数のフォルダーでPATH環境変数を維持するようにしてください（Cコンパイラーのフォルダーをそこに維持することを忘れないでください）。「cmd.exe」はビルドおよびその後のテスト中に最も一般的に起動されるプログラムであるため、OSのバージョンに応じて &lt;code&gt;C:\WINDOWS\system32&lt;/code&gt; または &lt;code&gt;C:\WINNT\system32&lt;/code&gt; をPATHの最初のフォルダーにする必要があります。</target>
        </trans-unit>
        <trans-unit id="9e6e47c6af55350e3bd275924a9467fa5be92cb6" translate="yes" xml:space="preserve">
          <source>If you are author of a package and wonder if your $VERSION can be parsed, please try the above method.</source>
          <target state="translated">もしあなたがパッケージの作者で、$VERSION が解析できるかどうか疑問に思っているなら、上記の方法を試してみてください。</target>
        </trans-unit>
        <trans-unit id="e9341f5fe0aca50dc1a438efa6a2a0829ec331a7" translate="yes" xml:space="preserve">
          <source>If you are building Perl from source, the Perl test suite file</source>
          <target state="translated">ソースから Perl をビルドしている場合は、Perl テストスイートファイル</target>
        </trans-unit>
        <trans-unit id="fd709122178ec9749d3b052901d53a7e7c059f96" translate="yes" xml:space="preserve">
          <source>If you are calling &lt;b&gt;pod2usage()&lt;/b&gt; from a module and want to display that module's POD, you can use this:</source>
          <target state="translated">モジュールから&lt;b&gt;pod2usage（）&lt;/b&gt;を呼び出していて、そのモジュールのPODを表示したい場合は、これを使用できます。</target>
        </trans-unit>
        <trans-unit id="f5b3eed9ee23b3eafd899b21c185d1c6a6521682" translate="yes" xml:space="preserve">
          <source>If you are careful, it is possible to mix API calls with the tied hash/array interface in the same piece of code. Although only a few of the methods used to implement the tied interface currently make use of the cursor, you should always assume that the cursor has been changed any time the tied hash/array interface is used. As an example, this code will probably not do what you expect:</source>
          <target state="translated">注意すれば、同じコードの中にAPIコールと紐付きハッシュ/配列インターフェースを混在させることができます。現在、カーソルを使用しているのは、いくつかのメソッドでしかありませんが、カーソルは常に変更されていると仮定する必要があります。例として、このコードはおそらくあなたが期待しているようなことはしないでしょう。</target>
        </trans-unit>
        <trans-unit id="f310b0eef5419b5aba99dec1af26f1763cc1c050" translate="yes" xml:space="preserve">
          <source>If you are certain that you want a different tool to use the same context you may pass it a snapshot. &lt;code&gt;$ctx-&amp;gt;snapshot&lt;/code&gt; will give you a shallow clone of the context that is safe to pass around or store.</source>
          <target state="translated">別のツールで同じコンテキストを使用することが確実な場合は、スナップショットを渡すことができます。 &lt;code&gt;$ctx-&amp;gt;snapshot&lt;/code&gt; は、安全に渡したり保存したりできるコンテキストの浅いクローンを提供します。</target>
        </trans-unit>
        <trans-unit id="4e316a557a29cf6095279d19d99c5e2d5b583af0" translate="yes" xml:space="preserve">
          <source>If you are certain that you want to save the context for later, you can use a snapshot. &lt;code&gt;$ctx-&amp;gt;snapshot&lt;/code&gt; will give you a shallow clone of the context that is safe to pass around or store.</source>
          <target state="translated">後で使用するためにコンテキストを保存することが確実な場合は、スナップショットを使用できます。 &lt;code&gt;$ctx-&amp;gt;snapshot&lt;/code&gt; は、安全に渡したり保存したりできるコンテキストの浅いクローンを提供します。</target>
        </trans-unit>
        <trans-unit id="46443ee64846124969f99d9a251a1b5c33defa28" translate="yes" xml:space="preserve">
          <source>If you are coming here because code of yours is being adversely affected by someone's use of this variable, you can usually work around it by doing this:</source>
          <target state="translated">もしあなたのコードが誰かにこの変数を使われて悪影響を受けているからここに来たのであれば、通常はこのようにして回避することができます。</target>
        </trans-unit>
        <trans-unit id="580a992ac4c85198002e3da1ab0af0114ef2843d" translate="yes" xml:space="preserve">
          <source>If you are compiling Perl on a remotely-mounted NFS filesystem, the test io/fs.t may fail on test #18. This appears to be a bug in HP-UX and no fix is currently available.</source>
          <target state="translated">リモートマウントされた NFS ファイルシステム上で Perl をコンパイルしている場合、テストの io/fs.t がテスト #18 で失敗することがあります。これは HP-UX のバグのようで、現在のところ修正はされていません。</target>
        </trans-unit>
        <trans-unit id="3b33c19354a1a90e2387b434d12153c90f20f627" translate="yes" xml:space="preserve">
          <source>If you are compiling in PASE, then &quot;make install&quot; is the only thing you will need to do.</source>
          <target state="translated">PASEでコンパイルしているのであれば、&quot;make install &quot;だけでOKです。</target>
        </trans-unit>
        <trans-unit id="81413ae9ed04e602e1a5e2aa34f9a9228c164afc" translate="yes" xml:space="preserve">
          <source>If you are compiling on AIX, simply do a &quot;make install&quot; on the AIX box. Once the install finishes, tar up the /QOpenSys/perl directory. Transfer the tarball to the OS/400 using FTP with the following commands:</source>
          <target state="translated">AIXでコンパイルしている場合は、AIXボックスで &quot;make install &quot;を実行してください。インストールが終了したら、/QOpenSys/perlディレクトリをtar化します。以下のコマンドを使用してFTPを使用して、tarballをOS/400に転送します。</target>
        </trans-unit>
        <trans-unit id="633f40501c71cc3d9b9dd021b947e0958a8636a6" translate="yes" xml:space="preserve">
          <source>If you are confident that all byte-strings will be in a specific encoding like UTF-8,</source>
          <target state="translated">すべてのバイト文字列がUTF-8のような特定のエンコーディングであると確信している場合。</target>
        </trans-unit>
        <trans-unit id="24c32dcfc58ac17c09099d20bc9bc3a8e41bba8b" translate="yes" xml:space="preserve">
          <source>If you are content with the test result, just &quot;make install&quot;</source>
          <target state="translated">テスト結果に満足しているのであれば、&quot;make install &quot;を実行してください。</target>
        </trans-unit>
        <trans-unit id="aa6a61423fd16b04dc17486be56b73db7a8c3506" translate="yes" xml:space="preserve">
          <source>If you are creating a PerlIO layer, you may want to be lazy, in other words, implement only the methods that interest you. The other methods you can either replace with the &quot;blank&quot; methods</source>
          <target state="translated">PerlIO レイヤーを作成している場合は、怠け者になりたくなるかもしれませんが、言い換えれば、興味のあるメソッドだけを実装してください。他のメソッドは、&quot;空白 &quot;のメソッドで置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="602ef84230a9a9bbabefd6f60652a28db56ddfcd" translate="yes" xml:space="preserve">
          <source>If you are creating a Zip file using the one-shot interface, and any of the input files is greater than 4Gig, a zip64 complaint zip file will be created.</source>
          <target state="translated">ワンショットインターフェースを使用してZipファイルを作成している場合、入力ファイルのいずれかが4Gigを超えている場合は、Zip64のクレームZipファイルが作成されます。</target>
        </trans-unit>
        <trans-unit id="4b2de75d9b2a463fc1f9325a0ae503a9f6861718" translate="yes" xml:space="preserve">
          <source>If you are developing a suite of related modules/classes it's good practice to use nested classes with a common prefix as this will avoid namespace clashes. For example: Xyz::Control, Xyz::View, Xyz::Model etc. Use the modules in this list as a naming guide.</source>
          <target state="translated">関連するモジュール/クラスのスイートを開発しているのであれば、名前空間の衝突を避けるために、共通のプレフィックスを持つネストされたクラスを使うのが良い習慣です。例えば、以下のようになります。例えば、Xyz::Control、Xyz::View、Xyz::Model などです。このリストのモジュールを名前付けの目安にしてください。</target>
        </trans-unit>
        <trans-unit id="cf3f54058ec5c3861eafa70f589fb5c16feca4d3" translate="yes" xml:space="preserve">
          <source>If you are doing a blocking &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread()&lt;/a&gt;&lt;/code&gt;, you'll have to arrange for an alarm handler to provide a timeout (see &lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;). If you have a non-blocking open, you'll likely have a non-blocking read, which means you may have to use a 4-arg &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; to determine whether I/O is ready on that device (see &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;.</source>
          <target state="translated">ブロッキング &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread()&lt;/a&gt;&lt;/code&gt; を実行している場合は、タイムアウトを提供するようにアラームハンドラーを準備する必要があります（&lt;a href=&quot;functions/alarm&quot;&gt;alarmを&lt;/a&gt;参照）。非ブロッキングを開いている場合、非ブロッキング読み取りが発生する可能性があります。つまり、4引数の &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; を使用して、そのデバイスでI / Oの準備ができているかどうかを判断する必要がある場合があります（&lt;a href=&quot;functions/select&quot;&gt; selectを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="a3262a8838df2cab768e5f0aeb8b39d02c8c5bb9" translate="yes" xml:space="preserve">
          <source>If you are doing a blocking &lt;code&gt;read()&lt;/code&gt; or &lt;code&gt;sysread()&lt;/code&gt;, you'll have to arrange for an alarm handler to provide a timeout (see &lt;a href=&quot;perlfunc#alarm&quot;&gt;&quot;alarm&quot; in perlfunc&lt;/a&gt;). If you have a non-blocking open, you'll likely have a non-blocking read, which means you may have to use a 4-arg &lt;code&gt;select()&lt;/code&gt; to determine whether I/O is ready on that device (see &lt;a href=&quot;perlfunc#select&quot;&gt;&quot;select&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">ブロッキング &lt;code&gt;read()&lt;/code&gt; または &lt;code&gt;sysread()&lt;/code&gt; を実行している場合は、タイムアウトを提供するアラームハンドラーを調整する必要があります（&lt;a href=&quot;perlfunc#alarm&quot;&gt;perlfuncの「alarm」を参照&lt;/a&gt;）。非ブロッキングを開いている場合は、非ブロッキングの読み取りが行われる可能性があります。つまり、4引数の &lt;code&gt;select()&lt;/code&gt; を使用して、そのデバイスでI / Oの準備ができているかどうかを判断する必要があります（&lt;a href=&quot;perlfunc#select&quot;&gt;「選択」を&lt;/a&gt;参照）。 perlfuncで。</target>
        </trans-unit>
        <trans-unit id="ec0d9c19ee9bcc3793bd395f6bcc7da295d90db4" translate="yes" xml:space="preserve">
          <source>If you are doing something complex, such as moving through many pages and forms or a web site, you can use &lt;a href=&quot;WWW::Mechanize&quot;&gt;WWW::Mechanize&lt;/a&gt;. See its documentation for all the details.</source>
          <target state="translated">多くのページやフォーム、またはWebサイトを移動するなど、複雑なことをしている場合は、&lt;a href=&quot;WWW::Mechanize&quot;&gt;WWW :: Mechanizeを&lt;/a&gt;使用できます。詳細については、そのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="27eb5f2751e7b3c976fa3693eb1b047c9ea468b5" translate="yes" xml:space="preserve">
          <source>If you are doing something complex, such as moving through many pages and forms or a web site, you can use &lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW::Mechanize&lt;/a&gt;. See its documentation for all the details.</source>
          <target state="translated">多くのページやフォーム、またはWebサイトを移動するなど、複雑なことをしている場合は、&lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW :: Mechanizeを&lt;/a&gt;使用できます。詳細については、ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="1a9b4d7923308acf7ee68c13a2cd11f90f3c70ce" translate="yes" xml:space="preserve">
          <source>If you are experiencing variable suicide, that &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; in the subroutine doesn't pick up a fresh copy of the &lt;code&gt;$f&lt;/code&gt; whose value is &lt;code&gt;'foo'&lt;/code&gt; . The output shows that inside the subroutine the value of &lt;code&gt;$f&lt;/code&gt; leaks through when it shouldn't, as in this output:</source>
          <target state="translated">あなたは、変数の自殺が発生している場合は、という &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $f&lt;/code&gt; サブルーチンではの新しいコピーをピックアップしません &lt;code&gt;$f&lt;/code&gt; 値である &lt;code&gt;'foo'&lt;/code&gt; 。この出力は、次の出力のように、サブルーチンの内部で &lt;code&gt;$f&lt;/code&gt; の値がリークすべきでないときにリークすることを示しています。</target>
        </trans-unit>
        <trans-unit id="90ffffc1c986cd8a0326c90c4ba333b4ce6ffe43" translate="yes" xml:space="preserve">
          <source>If you are experiencing variable suicide, that &lt;code&gt;my $f&lt;/code&gt; in the subroutine doesn't pick up a fresh copy of the &lt;code&gt;$f&lt;/code&gt; whose value is &lt;code&gt;'foo'&lt;/code&gt;. The output shows that inside the subroutine the value of &lt;code&gt;$f&lt;/code&gt; leaks through when it shouldn't, as in this output:</source>
          <target state="translated">あなたは、変数の自殺が発生している場合は、という &lt;code&gt;my $f&lt;/code&gt; サブルーチンではの新しいコピーをピックアップしません &lt;code&gt;$f&lt;/code&gt; 値である &lt;code&gt;'foo'&lt;/code&gt; 。この出力は、次の出力のように、サブルーチン内で &lt;code&gt;$f&lt;/code&gt; の値がリークすべきでないときにリークすることを示しています。</target>
        </trans-unit>
        <trans-unit id="bbeae6d94c0568a9909c55582ce46133df1b3000" translate="yes" xml:space="preserve">
          <source>If you are familiar with the</source>
          <target state="translated">に精通している方は</target>
        </trans-unit>
        <trans-unit id="09b5540260d1429f031cae6d4fea34d1c0219ed0" translate="yes" xml:space="preserve">
          <source>If you are forking many processes in parallel that are all creating temporary files, you may need to reset the random number seed using srand(EXPR) in each child else all the children will attempt to walk through the same set of random file names and may well cause themselves to give up if they exceed the number of retry attempts.</source>
          <target state="translated">多くのプロセスを並列にフォークして、すべてのプロセスが一時ファイルを作成している場合、各子プロセスで srand(EXPR)を使って乱数シードをリセットする必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="79eaecd3ef824520bc14f0a6f551bc580fb007f0" translate="yes" xml:space="preserve">
          <source>If you are going to convert the script to a module you can use the opportunity to redesign the interface. The guidelines for module creation above include many of the issues you should consider.</source>
          <target state="translated">スクリプトをモジュールに変換する場合は、インターフェイスを再設計する機会を利用することができます。上記のモジュール作成のガイドラインには、考慮すべき多くの問題が含まれています。</target>
        </trans-unit>
        <trans-unit id="37c8864889db08a398c2a1fd61fb5557dd86b1b1" translate="yes" xml:space="preserve">
          <source>If you are going to put something onto the Perl stack, you need to know where to put it. This is the purpose of the macro &lt;code&gt;dSP&lt;/code&gt; --it declares and initializes a</source>
          <target state="translated">Perlスタックに何かを配置する場合は、どこに配置するかを知る必要があります。これは、マクロの目的である &lt;code&gt;dSP&lt;/code&gt; --itを宣言し、初期化します</target>
        </trans-unit>
        <trans-unit id="537495a37e599c942d74bd5d8aca0155b4da8202" translate="yes" xml:space="preserve">
          <source>If you are going to put something onto the Perl stack, you need to know where to put it. This is the purpose of the macro &lt;code&gt;dSP&lt;/code&gt;--it declares and initializes a</source>
          <target state="translated">Perlスタックに何かを置く場合は、どこに置くかを知る必要があります。これがマクロ &lt;code&gt;dSP&lt;/code&gt; の目的です-それは宣言して初期化します</target>
        </trans-unit>
        <trans-unit id="0cf3f133791811ca9201975358ebf1e226d3c50a" translate="yes" xml:space="preserve">
          <source>If you are going to use the HP DCE package, the library used for threading is /usr/lib/libcma.sl, but there have been multiple updates of that library over time. Perl will build with the first version, but it will not pass the test suite. Older Oracle versions might be a compelling reason not to update that library, otherwise please find a newer version in one of the following patches: PHSS_19739, PHSS_20608, or PHSS_23672</source>
          <target state="translated">HP DCEパッケージを使用する場合、スレッディングに使用するライブラリは/usr/lib/libcma.slですが、そのライブラリは時間の経過とともに複数のアップデートが行われてきました。Perlは最初のバージョンでビルドしますが、テストスイートには合格しません。Oracle の古いバージョンは、そのライブラリを更新しないやむを得ない理由になるかもしれませんが、そうでなければ、以下のパッチのいずれかで新しいバージョンを見つけてください。PHSS_19739、PHSS_20608、PHSS_23672 のいずれかのパッチで新しいバージョンを見つけてください。</target>
        </trans-unit>
        <trans-unit id="330882464199f1a0851acc4b79e3a966cdc91c15" translate="yes" xml:space="preserve">
          <source>If you are going to use this method you have to be aware of a possible memory leak which can arise under very specific circumstances. To explain these circumstances you need to know a bit about the flow of control between Perl and the callback routine.</source>
          <target state="translated">このメソッドを使用する場合は、特定の状況下で発生する可能性のあるメモリリークに注意しなければなりません。これらの状況を説明するために、Perlとコールバックルーチンの間の制御の流れを少し知っておく必要があります。</target>
        </trans-unit>
        <trans-unit id="91073f8278c247bf05c5742a59e2d0906bf12cbd" translate="yes" xml:space="preserve">
          <source>If you are going to write a platform specific MM package, please try to limit the necessary overrides to primitive methods, and if it is not possible to do so, let's work out how to achieve that gain.</source>
          <target state="translated">プラットフォームに特化したMMパッケージを書くのであれば、必要なオーバーライドはプリミティブなメソッドに限定して、それができないのであれば、そのゲインを得るための方法を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="3470649433d76902fec9be392ea404a581213006" translate="yes" xml:space="preserve">
          <source>If you are having trouble with square brackets then consider switching your rlogin or telnet client. Try to avoid older 3270 emulators and ISHELL for working with Perl on USS.</source>
          <target state="translated">もし角括弧で問題がある場合は、rlogin や telnet クライアントを変更することを検討してください。古い 3270 エミュレータや ISHELL は避けてください。</target>
        </trans-unit>
        <trans-unit id="fb193e3267912e83638916e973e0dcc8b120aead" translate="yes" xml:space="preserve">
          <source>If you are in any doubt about the license situation, contact either the Berkeley DB authors or the author of DB_File. See &lt;a href=&quot;#AUTHOR&quot;&gt;&quot;AUTHOR&quot;&lt;/a&gt; for details.</source>
          <target state="translated">ライセンスの状況について疑問がある場合は、BerkeleyDBの作成者またはDB_Fileの作成者に連絡してください。詳細は&lt;a href=&quot;#AUTHOR&quot;&gt;「作者」&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="be777d0c50e7b77da7283f3ff8a7e540b7f7344c" translate="yes" xml:space="preserve">
          <source>If you are in any doubt about the license situation, contact either the Berkeley DB authors or the author of DB_File. See &lt;a href=&quot;#AUTHOR&quot;&gt;AUTHOR&lt;/a&gt; for details.</source>
          <target state="translated">ライセンスの状況について疑問がある場合は、Berkeley DBの作成者またはDB_Fileの作成者に連絡してください。詳細については、&lt;a href=&quot;#AUTHOR&quot;&gt;作者&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="99320978b9537887ebc85e1dfd4bdf0910cbc812" translate="yes" xml:space="preserve">
          <source>If you are in doubt which package contains a file you are missing, try to find an installation that has that file. Then do a</source>
          <target state="translated">どのパッケージに不足しているファイルが含まれているかわからない場合は、そのファイルが含まれているインストールを探してみてください。次に、以下のようにしてください。</target>
        </trans-unit>
        <trans-unit id="92276bc0e44e1b658a5288e18f73cfbd284b63bb" translate="yes" xml:space="preserve">
          <source>If you are intending to manipulate bitstrings, be certain that you're supplying bitstrings: If an operand is a number, that will imply a &lt;b&gt;numeric&lt;/b&gt; bitwise operation. You may explicitly show which type of operation you intend by using &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;0+&lt;/code&gt; , as in the examples below.</source>
          <target state="translated">ビット文字列を操作する場合は、ビット文字列を指定していることを確認してください。オペランドが&lt;b&gt;数値の&lt;/b&gt;場合、それはビット単位の&lt;b&gt;数値&lt;/b&gt;演算を意味し&lt;b&gt;ます&lt;/b&gt;。以下の例のように、 &lt;code&gt;&quot;&quot;&lt;/code&gt; または &lt;code&gt;0+&lt;/code&gt; を使用して、意図する操作のタイプを明示的に示すことができます。</target>
        </trans-unit>
        <trans-unit id="2877e8cae4b72c189b80caef94210456b80f06da" translate="yes" xml:space="preserve">
          <source>If you are intending to manipulate bitstrings, be certain that you're supplying bitstrings: If an operand is a number, that will imply a &lt;b&gt;numeric&lt;/b&gt; bitwise operation. You may explicitly show which type of operation you intend by using &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;0+&lt;/code&gt;, as in the examples below.</source>
          <target state="translated">ビット文字列を操作する場合は、ビット文字列を指定していることを確認してください。オペランドが&lt;b&gt;数値の&lt;/b&gt;場合、ビット単位の&lt;b&gt;数値&lt;/b&gt;演算を意味し&lt;b&gt;ます&lt;/b&gt;。以下の例のように、 &lt;code&gt;&quot;&quot;&lt;/code&gt; または &lt;code&gt;0+&lt;/code&gt; を使用して、意図する操作のタイプを明示的に示すことができます。</target>
        </trans-unit>
        <trans-unit id="a0e74d8ccd8d67f221dc38d69397982438ef8887" translate="yes" xml:space="preserve">
          <source>If you are interested in the guts underlying these systems, check out &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">これらのシステムの根底にある内臓に興味がある場合は、&lt;a href=&quot;perlobj&quot;&gt;perlobjを&lt;/a&gt;チェックしてください。</target>
        </trans-unit>
        <trans-unit id="f81bce975381ffe867c89af365021d38913e30eb" translate="yes" xml:space="preserve">
          <source>If you are interested in the z/OS (formerly known as OS/390) and POSIX-BC (BS2000) ports of Perl then see the perl-mvs mailing list. To subscribe, send an empty message to perl-mvs-subscribe@perl.org.</source>
          <target state="translated">Perl の z/OS (以前は OS/390 として知られていました)と POSIX-BC (BS2000)の移植版に興味があるならば、 perl-mvs メーリングリストを見てください。購読するには、空のメッセージを perl-mvs-subscribe@perl.org に送ってください。</target>
        </trans-unit>
        <trans-unit id="81e9b341887276c07ed78e971fe73fb2fe685324" translate="yes" xml:space="preserve">
          <source>If you are interested in writing new tools you should take a look at &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt; first.</source>
          <target state="translated">新しいツールの作成に興味がある場合は、最初に&lt;a href=&quot;Test2::API&quot;&gt;Test2 :: APIを&lt;/a&gt;確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="18b06deb07c89c9dfd8a2b96ce84d618599bef3b" translate="yes" xml:space="preserve">
          <source>If you are interested in writing tests using new tools then you should look at &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt;. &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt; is a separate cpan distribution that contains many tools implemented on Test2.</source>
          <target state="translated">新しいツールを使用してテストを作成することに興味がある場合は、&lt;a href=&quot;Test2::Suite&quot;&gt;Test2 :: Suite&lt;/a&gt;を確認する必要があります。&lt;a href=&quot;Test2::Suite&quot;&gt;Test2 :: Suite&lt;/a&gt;は、Test2に実装された多くのツールを含む別個のcpanディストリビューションです。</target>
        </trans-unit>
        <trans-unit id="38d9bbb97bd39f15f79a0ad6f3bd53d77bb54ef1" translate="yes" xml:space="preserve">
          <source>If you are looking for a &quot;bar&quot; that isn't preceded by a &quot;foo&quot;, &lt;code&gt;/(?!foo)bar/&lt;/code&gt; will not do what you want. That's because the &lt;code&gt;(?!foo)&lt;/code&gt; is just saying that the next thing cannot be &quot;foo&quot;--and it's not, it's a &quot;bar&quot;, so &quot;foobar&quot; will match. Use look-behind instead (see below).</source>
          <target state="translated">「foo」が前に付いていない「バー」を探している場合、 &lt;code&gt;/(?!foo)bar/&lt;/code&gt; は期待どおりに動作しません。これは、 &lt;code&gt;(?!foo)&lt;/code&gt; が次のことを「foo」にすることはできないとだけ言っているためです。そうではなく、「バー」なので、「foobar」が一致します。代わりに後読みを使用してください（以下を参照）。</target>
        </trans-unit>
        <trans-unit id="f7b2a50928124f0618a8144a8e1baa9cc8e568eb" translate="yes" xml:space="preserve">
          <source>If you are looking for a &quot;bar&quot; that isn't preceded by a &quot;foo&quot;, &lt;code&gt;/(?!foo)bar/&lt;/code&gt; will not do what you want. That's because the &lt;code&gt;(?!foo)&lt;/code&gt; is just saying that the next thing cannot be &quot;foo&quot;--and it's not, it's a &quot;bar&quot;, so &quot;foobar&quot; will match. Use lookbehind instead (see below).</source>
          <target state="translated">「foo」が前に付いていない「bar」を探している場合、 &lt;code&gt;/(?!foo)bar/&lt;/code&gt; はあなたが望むことをしません。これは、 &lt;code&gt;(?!foo)&lt;/code&gt; が、次のものを「foo」にすることはできないと言っているだけだからです。そうではなく、「bar」なので、「foobar」が一致します。代わりにルックビハインドを使用してください（以下を参照）。</target>
        </trans-unit>
        <trans-unit id="dc60d35f80efdd879c9aa94cc9f2ee7ad195384c" translate="yes" xml:space="preserve">
          <source>If you are looking for a class that does everything for you that you don't define yourself, use the &lt;code&gt;Tie::StdScalar&lt;/code&gt; class, not the &lt;code&gt;Tie::Scalar&lt;/code&gt; one.</source>
          <target state="translated">自分で定義していないすべてのことを実行するクラスを探している場合は、 &lt;code&gt;Tie::Scalar&lt;/code&gt; クラスではなく &lt;code&gt;Tie::StdScalar&lt;/code&gt; クラスを使用してください。</target>
        </trans-unit>
        <trans-unit id="f20427718038bfba8c53137f8646eb9abfc2ff46" translate="yes" xml:space="preserve">
          <source>If you are looking for a class that does everything for you you don't define yourself, use the &lt;code&gt;Tie::StdScalar&lt;/code&gt; class, not the &lt;code&gt;Tie::Scalar&lt;/code&gt; one.</source>
          <target state="translated">自分で定義していないすべてのことを行うクラスを探している場合は、 &lt;code&gt;Tie::Scalar&lt;/code&gt; クラスではなく、Tie :: &lt;code&gt;Tie::StdScalar&lt;/code&gt; クラスを使用してください。</target>
        </trans-unit>
        <trans-unit id="7787fb3feb00a627232c8ef4ce3954c9d7deed73" translate="yes" xml:space="preserve">
          <source>If you are looking for a table of contents to the Perl library modules documentation, see the &lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc&lt;/a&gt; page.</source>
          <target state="translated">Perlライブラリモジュールのドキュメントの目次を探している場合は、&lt;a href=&quot;http://search.cpan.org/perldoc/perltoc&quot;&gt;perltoc&lt;/a&gt;ページを参照してください。</target>
        </trans-unit>
        <trans-unit id="40f5e81161933568c426f178117fbe0b2c9f0084" translate="yes" xml:space="preserve">
          <source>If you are looking for a table of contents to the Perl library modules documentation, see the &lt;a href=&quot;perltoc&quot;&gt;perltoc&lt;/a&gt; page.</source>
          <target state="translated">Perlライブラリモジュールのドキュメントの目次を探している場合は、&lt;a href=&quot;perltoc&quot;&gt;perltoc&lt;/a&gt;ページを参照してください。</target>
        </trans-unit>
        <trans-unit id="3fac826063cfc00ef4ae02f7626b0848d723ad5d" translate="yes" xml:space="preserve">
          <source>If you are looking for an example, I recommend that you look at the simple example in the Memoize::Expire documentation, or at the code for Memoize::Expire itself.</source>
          <target state="translated">例を探しているのであれば、Memoize::Expireのドキュメントにあるシンプルな例を見るか、Memoize::Expire自体のコードを見ることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="01bb70148d15624f6da074182f77ad2f0eee86c6" translate="yes" xml:space="preserve">
          <source>If you are looking for helpers with &lt;code&gt;is&lt;/code&gt;, &lt;code&gt;like&lt;/code&gt;, and others, see &lt;a href=&quot;Test2::Suite&quot;&gt;Test2::Suite&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; 、 &lt;code&gt;like&lt;/code&gt; などのヘルパーを探している場合は、&lt;a href=&quot;Test2::Suite&quot;&gt;Test2 :: Suiteを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b33652a525614ae7d89321a43fb11331d7e5b6fa" translate="yes" xml:space="preserve">
          <source>If you are making use of the Perl stack pointer in your code you must always refresh the local copy using SPAGAIN whenever you make use of the</source>
          <target state="translated">コードの中でPerlのスタックポインタを使用している場合は、常にSPAGAINを使用してローカルコピーを更新しなければなりません。</target>
        </trans-unit>
        <trans-unit id="31bb9506f4ff23e6db70b0b08455755a7de18605" translate="yes" xml:space="preserve">
          <source>If you are not using threads, forking, or IPC then the only difference between a &lt;code&gt;filter&lt;/code&gt; and a &lt;code&gt;pre_filter&lt;/code&gt; is that &lt;code&gt;pre_filter&lt;/code&gt; subs run first. When you are using threads, forking, or IPC, pre_filters happen to events before they are sent to their destination proc/thread, ordinary filters happen only in the destination hub/thread.</source>
          <target state="translated">スレッド、フォーク、またはIPCを使用していない場合、 &lt;code&gt;filter&lt;/code&gt; と &lt;code&gt;pre_filter&lt;/code&gt; の唯一の違いは、 &lt;code&gt;pre_filter&lt;/code&gt; サブが最初に実行されることです。スレッド、フォーク、またはIPCを使用している場合、pre_filtersは、イベントが宛先proc / threadに送信される前に発生し、通常のフィルターは宛先ハブ/スレッドでのみ発生します。</target>
        </trans-unit>
        <trans-unit id="0468c5bae6319f4655b5720508b9d190b598ea2a" translate="yes" xml:space="preserve">
          <source>If you are on a Unix-like system, you might be able to get away with a system call where you put an &lt;code&gt;&amp;amp;&lt;/code&gt; on the end of the command:</source>
          <target state="translated">Unixライクなシステムを使用している場合は、コマンドの最後に &lt;code&gt;&amp;amp;&lt;/code&gt; を付けるシステムコールを使用して回避できる場合があります。</target>
        </trans-unit>
        <trans-unit id="74fb92ccab7935bd1e0cc2c8300a7bef29eb75de" translate="yes" xml:space="preserve">
          <source>If you are on a non-UNIX platform &lt;b&gt;perldoc&lt;/b&gt;&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;, as some features may be unimplemented or work differently.</source>
          <target state="translated">非UNIXプラットフォームの&lt;b&gt;perldoc &lt;/b&gt;&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;を使用している場合、一部の機能が実装されていないか、動作が異なる可能性があります。</target>
        </trans-unit>
        <trans-unit id="5f59ff52a71652ecb89231c85ecae2ce17688eb9" translate="yes" xml:space="preserve">
          <source>If you are on a system that correctly implements &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; and you use the example appending code from &quot;perldoc -f flock&quot; everything will be OK even if the OS you are on doesn't implement append mode correctly (if such a system exists). So if you are happy to restrict yourself to OSs that implement &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; (and that's not really much of a restriction) then that is what you should do.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; を正しく実装しているシステムで、 &quot;perldoc -f flock&quot;の追加コードの例を使用している場合は、使用しているOSが追加モードを正しく実装していない場合でも（そのようなシステムが存在する場合）、すべて問題ありません。したがって、 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; を実装するOSに自分自身を制限することに満足している場合（そして、それは実際にはそれほど制限ではありません）、それを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="775ac36d1065d528736d6584503c5960de9afca8" translate="yes" xml:space="preserve">
          <source>If you are on a system that correctly implements &lt;code&gt;flock&lt;/code&gt; and you use the example appending code from &quot;perldoc -f flock&quot; everything will be OK even if the OS you are on doesn't implement append mode correctly (if such a system exists). So if you are happy to restrict yourself to OSs that implement &lt;code&gt;flock&lt;/code&gt; (and that's not really much of a restriction) then that is what you should do.</source>
          <target state="translated">&lt;code&gt;flock&lt;/code&gt; を正しく実装するシステムを使用していて、「perldoc -f flock」の追加コードの例を使用する場合、使用しているOSが追加モードを正しく実装していなくても（そのようなシステムが存在する場合）、すべて問題ありません。したがって、 &lt;code&gt;flock&lt;/code&gt; を実装するOSに自分自身を制限することに満足している場合（そしてそれは実際にはそれほど制限ではありません）、それがあなたがすべきことです。</target>
        </trans-unit>
        <trans-unit id="54d7fa3e38420fc843370b116c9be081ea5603e0" translate="yes" xml:space="preserve">
          <source>If you are only exporting function names it is recommended to omit the ampersand, as the implementation is faster this way.</source>
          <target state="translated">関数名のみをエクスポートする場合は、アンパサンドを省略することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2de91fd61e5dabce87e62b432c1af2d2e0384486" translate="yes" xml:space="preserve">
          <source>If you are overriding any of these methods in your Makefile.PL (in the MY class), please report that to the makemaker mailing list. We are trying to minimize the necessary method overrides and switch to data driven Makefile.PLs wherever possible. In the long run less methods will be overridable via the MY class.</source>
          <target state="translated">もし、Makefile.PL (MY クラス)でこれらのメソッドをオーバーライドしている場合は、 makemaker メーリングリストに報告してください。私たちは必要なメソッドのオーバーライドを最小限にして、可能な限りデータ駆動の Makefile.PL に切り替えようとしています。長い目で見れば、MY クラスでオーバーライドできるメソッドは少なくなるでしょう。</target>
        </trans-unit>
        <trans-unit id="25095e5b9b6ab11015f95ba50809b8be1a58758d" translate="yes" xml:space="preserve">
          <source>If you are particularly interested in customizing this module's output even more, see the source and/or write to me.</source>
          <target state="translated">このモジュールの出力をさらにカスタマイズしたい場合は、ソースを参照してください。</target>
        </trans-unit>
        <trans-unit id="d40865e3f4f814dc75edbc20fbc8762037c6c824" translate="yes" xml:space="preserve">
          <source>If you are printing IVs, UVs, or NVS instead of the stdio(3) style formatting codes like &lt;code&gt;%d&lt;/code&gt; , &lt;code&gt;%ld&lt;/code&gt; , &lt;code&gt;%f&lt;/code&gt; , you should use the following macros for portability</source>
          <target state="translated">&lt;code&gt;%d&lt;/code&gt; 、 &lt;code&gt;%ld&lt;/code&gt; 、 &lt;code&gt;%f&lt;/code&gt; などのstdio（3）スタイルのフォーマットコードの代わりにIV、UV、またはNVSを印刷する場合は、移植性のために次のマクロを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="367b87e5b6a685cdb2627b032e60c907e2607076" translate="yes" xml:space="preserve">
          <source>If you are printing IVs, UVs, or NVS instead of the stdio(3) style formatting codes like &lt;code&gt;%d&lt;/code&gt;, &lt;code&gt;%ld&lt;/code&gt;, &lt;code&gt;%f&lt;/code&gt;, you should use the following macros for portability</source>
          <target state="translated">&lt;code&gt;%d&lt;/code&gt; 、 &lt;code&gt;%ld&lt;/code&gt; 、 &lt;code&gt;%f&lt;/code&gt; などのstdio（3）スタイルのフォーマットコードの代わりにIV、UV、またはNVSを印刷する場合は、移植性のために次のマクロを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="6da5a3aba0348fe8e8ae52d62d3e9bfb01a53b73" translate="yes" xml:space="preserve">
          <source>If you are printing addresses of pointers, use %p or UVxf combined with PTR2UV().</source>
          <target state="translated">ポインタのアドレスを印刷する場合は、%p または UVxf を PTR2UV()と組み合わせて使用します。</target>
        </trans-unit>
        <trans-unit id="b082a380f246d61dd682cd511f2ea77809e32735" translate="yes" xml:space="preserve">
          <source>If you are printing addresses of pointers, use UVxf combined with PTR2UV(), do not use %lx or %p.</source>
          <target state="translated">ポインタのアドレスを印刷する場合は、PTR2UV()と組み合わせてUVxfを使用します。</target>
        </trans-unit>
        <trans-unit id="b6f4ed221243b9dde4f0f2cc29b067e485bbf822" translate="yes" xml:space="preserve">
          <source>If you are reading this documentation, looking for a replacement for the &lt;code&gt;FileHandle&lt;/code&gt; package, then I suggest you read the documentation for &lt;code&gt;IO::File&lt;/code&gt; too.</source>
          <target state="translated">このドキュメントを読んでいて、 &lt;code&gt;FileHandle&lt;/code&gt; パッケージの代替を探している場合は、 &lt;code&gt;IO::File&lt;/code&gt; ドキュメントも読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="8c40246fed4e0a31f96c46a72d0a85e56bbe29c3" translate="yes" xml:space="preserve">
          <source>If you are reading this in the future then it's possible that the state of the art has changed. We recommend you start by reading the perlootut document in the latest stable release of Perl, rather than this version.</source>
          <target state="translated">もしあなたがこれからこれを読んでいるのであれば、状態が変わっている可能性があります。このバージョンではなく、Perl の最新の安定版である perlootut のドキュメントを読むことから始めることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d0add6c557074aa94dbce442362b0e5da76c5396" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Bzip2 can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以上を実行している場合、IO :: Compress :: Bzip2から返されるオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;../file&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。つまり、通常の出力ファイル操作はすべて &lt;code&gt;$z&lt;/code&gt; して実行できます。たとえば、圧縮ファイル/バッファに書き込むには、次のいずれかの形式を使用できます</target>
        </trans-unit>
        <trans-unit id="b7e4df4e4f27db0bf9a46e2a1941e85758d61068" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Deflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以上を実行している場合、IO :: Compress :: Deflateから返されたオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;../file&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。つまり、通常の出力ファイル操作はすべて &lt;code&gt;$z&lt;/code&gt; して実行できます。たとえば、圧縮ファイル/バッファに書き込むには、次のいずれかの形式を使用できます</target>
        </trans-unit>
        <trans-unit id="41e65ffc69fed189ecd525fba0988f92db4e7035" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Gzip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以上を実行している場合、IO :: Compress :: Gzipから返されたオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;../file&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。つまり、通常の出力ファイル操作はすべて &lt;code&gt;$z&lt;/code&gt; して実行できます。たとえば、圧縮ファイル/バッファに書き込むには、次のいずれかの形式を使用できます</target>
        </trans-unit>
        <trans-unit id="c6b6ef257ae9881b6bd3fd8eaa22b1a4c05c99ca" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::RawDeflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以上を実行している場合、IO :: Compress :: RawDeflateから返されたオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;../file&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。つまり、通常の出力ファイル操作はすべて &lt;code&gt;$z&lt;/code&gt; して実行できます。たとえば、圧縮ファイル/バッファに書き込むには、次のいずれかの形式を使用できます</target>
        </trans-unit>
        <trans-unit id="3c423a94c7fc5cb61812044d70c6c094354f683a" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Compress::Zip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以上を実行している場合、IO :: Compress :: Zipから返されたオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;../file&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。つまり、通常の出力ファイル操作はすべて &lt;code&gt;$z&lt;/code&gt; して実行できます。たとえば、圧縮ファイル/バッファに書き込むには、次のいずれかの形式を使用できます</target>
        </trans-unit>
        <trans-unit id="5fea5722273a1695c99b2d6f3f73bb1257cd24c3" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::AnyInflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以上を実行している場合、IO :: Uncompress :: AnyInflateから返されたオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;../file&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。つまり、通常の入力ファイル操作はすべて &lt;code&gt;$z&lt;/code&gt; して実行できます。たとえば、圧縮ファイル/バッファから行を読み取るには、次のいずれかの形式を使用できます</target>
        </trans-unit>
        <trans-unit id="b2972d5cdbb1eb98b989631b3ded397e40e59e75" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::AnyUncompress can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以上を実行している場合、IO :: Uncompress :: AnyUncompressから返されたオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;../file&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。つまり、通常の入力ファイル操作はすべて &lt;code&gt;$z&lt;/code&gt; して実行できます。たとえば、圧縮ファイル/バッファから行を読み取るには、次のいずれかの形式を使用できます</target>
        </trans-unit>
        <trans-unit id="18aa1921698d337e93a7e4edaa2b66e95de457bf" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Bunzip2 can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以上を実行している場合、IO :: Uncompress :: Bunzip2から返されるオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;../file&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。つまり、通常の入力ファイル操作はすべて &lt;code&gt;$z&lt;/code&gt; して実行できます。たとえば、圧縮ファイル/バッファから行を読み取るには、次のいずれかの形式を使用できます</target>
        </trans-unit>
        <trans-unit id="f86eb994b5def7f39f87b382b570ded31372309e" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Gunzip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以上を実行している場合、IO :: Uncompress :: Gunzipから返されるオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;../file&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。つまり、通常の入力ファイル操作はすべて &lt;code&gt;$z&lt;/code&gt; して実行できます。たとえば、圧縮ファイル/バッファから行を読み取るには、次のいずれかの形式を使用できます</target>
        </trans-unit>
        <trans-unit id="05ab40d4db9fa577fb79380b48870abe52f5c6be" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Inflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以上を実行している場合、IO :: Uncompress :: Inflateから返されるオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;../file&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。つまり、通常の入力ファイル操作はすべて &lt;code&gt;$z&lt;/code&gt; して実行できます。たとえば、圧縮ファイル/バッファから行を読み取るには、次のいずれかの形式を使用できます</target>
        </trans-unit>
        <trans-unit id="d70a4ecbd7bb1c964123dba102fe8a49b561cb00" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::RawInflate can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以降を実行している場合、IO :: Uncompress :: RawInflateから返されたオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;../file&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。つまり、通常の入力ファイル操作はすべて &lt;code&gt;$z&lt;/code&gt; して実行できます。たとえば、圧縮ファイル/バッファから行を読み取るには、次のいずれかの形式を使用できます</target>
        </trans-unit>
        <trans-unit id="3608890b582bffd465c544ac9e831ad2b06501a0" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt; , returned from IO::Uncompress::Unzip can be used exactly like an &lt;a href=&quot;../file&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt; . For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以上を実行している場合、IO :: Uncompress :: Unzipから返されるオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;../file&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。つまり、通常の入力ファイル操作はすべて &lt;code&gt;$z&lt;/code&gt; して実行できます。たとえば、圧縮ファイル/バッファから行を読み取るには、次のいずれかの形式を使用できます</target>
        </trans-unit>
        <trans-unit id="c3f55f8a5aa9143947c1b03103f8fcb1230f8026" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::Bzip2 can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以降を実行している場合、IO :: Compress :: Bzip2から返されるオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;IO::File&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。これは、すべての通常の出力ファイル操作が &lt;code&gt;$z&lt;/code&gt; 実行できることを意味します。たとえば、圧縮ファイル/バッファに書き込むには、これらの形式のいずれかを使用できます</target>
        </trans-unit>
        <trans-unit id="4c943ecc09f7906641ce0c8c9195f36b53b0da84" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::Deflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以降を実行している場合、IO :: Compress :: Deflateから返されるオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;IO::File&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。これは、すべての通常の出力ファイル操作が &lt;code&gt;$z&lt;/code&gt; 実行できることを意味します。たとえば、圧縮ファイル/バッファに書き込むには、これらの形式のいずれかを使用できます</target>
        </trans-unit>
        <trans-unit id="d0d2de3cb6af8e02dfa388bc8385e1f9fef63232" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::Gzip can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以降を実行している場合、IO :: Compress :: Gzipから返されるオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;IO::File&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。これは、すべての通常の出力ファイル操作が &lt;code&gt;$z&lt;/code&gt; 実行できることを意味します。たとえば、圧縮ファイル/バッファに書き込むには、これらの形式のいずれかを使用できます</target>
        </trans-unit>
        <trans-unit id="0f19394fb5dae0da1468d85a7077d6de961381d1" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::RawDeflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以降を実行している場合、IO :: Compress :: RawDeflateから返されるオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;IO::File&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。これは、すべての通常の出力ファイル操作が &lt;code&gt;$z&lt;/code&gt; 実行できることを意味します。たとえば、圧縮ファイル/バッファに書き込むには、これらの形式のいずれかを使用できます</target>
        </trans-unit>
        <trans-unit id="8705529210f30abadfa2690a88a8e55709062caf" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Compress::Zip can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal output file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to write to a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以降を実行している場合、IO :: Compress :: Zipから返されるオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;IO::File&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。これは、すべての通常の出力ファイル操作が &lt;code&gt;$z&lt;/code&gt; 実行できることを意味します。たとえば、圧縮ファイル/バッファに書き込むには、これらの形式のいずれかを使用できます</target>
        </trans-unit>
        <trans-unit id="af8dcbb9c89b754c497d19b04a16a87cbcd0b450" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::AnyInflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以降を実行している場合、IO :: Uncompress :: AnyInflateから返されるオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;IO::File&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。これは、すべての通常の入力ファイル操作が &lt;code&gt;$z&lt;/code&gt; 実行できることを意味します。たとえば、圧縮ファイル/バッファから行を読み取るには、これらの形式のいずれかを使用できます</target>
        </trans-unit>
        <trans-unit id="3dc295bba8742677124dc7e9dbafd6bdce18ea43" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::AnyUncompress can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以降を実行している場合、IO :: Uncompress :: AnyUncompressから返されるオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;IO::File&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。これは、すべての通常の入力ファイル操作が &lt;code&gt;$z&lt;/code&gt; 実行できることを意味します。たとえば、圧縮ファイル/バッファから行を読み取るには、これらの形式のいずれかを使用できます</target>
        </trans-unit>
        <trans-unit id="f04020399fea242c9c0dc69403e3ea87fc90e780" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::Bunzip2 can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以降を実行している場合、IO :: Uncompress :: Bunzip2から返されるオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;IO::File&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。これは、すべての通常の入力ファイル操作が &lt;code&gt;$z&lt;/code&gt; 実行できることを意味します。たとえば、圧縮ファイル/バッファから行を読み取るには、これらの形式のいずれかを使用できます</target>
        </trans-unit>
        <trans-unit id="d8386c862fdf7a36268d1e2d11759b36cc61a052" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::Gunzip can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以降を実行している場合、IO :: Uncompress :: Gunzipから返されるオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;IO::File&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。これは、すべての通常の入力ファイル操作が &lt;code&gt;$z&lt;/code&gt; 実行できることを意味します。たとえば、圧縮ファイル/バッファから行を読み取るには、これらの形式のいずれかを使用できます</target>
        </trans-unit>
        <trans-unit id="e228b2a0d2a2705757b5a03c01b16b81052402f0" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::Inflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以降を実行している場合、IO :: Uncompress :: Inflateから返されるオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;IO::File&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。これは、すべての通常の入力ファイル操作が &lt;code&gt;$z&lt;/code&gt; 実行できることを意味します。たとえば、圧縮ファイル/バッファから行を読み取るには、これらの形式のいずれかを使用できます</target>
        </trans-unit>
        <trans-unit id="250328bb572e14771a91f743881702e8168f7ce1" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::RawInflate can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以降を実行している場合、IO :: Uncompress :: RawInflateから返されるオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;IO::File&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。これは、すべての通常の入力ファイル操作が &lt;code&gt;$z&lt;/code&gt; 実行できることを意味します。たとえば、圧縮ファイル/バッファから行を読み取るには、これらの形式のいずれかを使用できます</target>
        </trans-unit>
        <trans-unit id="ac7ddace8a1bf7c76549d07abf22fa8e8e550364" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.005 or better the object, &lt;code&gt;$z&lt;/code&gt;, returned from IO::Uncompress::Unzip can be used exactly like an &lt;a href=&quot;IO::File&quot;&gt;IO::File&lt;/a&gt; filehandle. This means that all normal input file operations can be carried out with &lt;code&gt;$z&lt;/code&gt;. For example, to read a line from a compressed file/buffer you can use either of these forms</source>
          <target state="translated">Perl 5.005以降を実行している場合、IO :: Uncompress :: Unzipから返されるオブジェクト &lt;code&gt;$z&lt;/code&gt; は、&lt;a href=&quot;IO::File&quot;&gt;IO :: Fileファイル&lt;/a&gt;ハンドルとまったく同じように使用できます。これは、すべての通常の入力ファイル操作が &lt;code&gt;$z&lt;/code&gt; 実行できることを意味します。たとえば、圧縮ファイル/バッファから行を読み取るには、これらの形式のいずれかを使用できます</target>
        </trans-unit>
        <trans-unit id="89f53b731da5c3618fcf6d87c9434da7f9ed2f65" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.6.0 or better, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma allows fine control of what warnings are produced. See &lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt; for more details.</source>
          <target state="translated">Perl 5.6.0以降を実行している場合、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; プラグマを使用すると、生成される警告を細かく制御できます。詳細については&lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e3a447e1361d79aaa9ee74688b52a31d693ae7e5" translate="yes" xml:space="preserve">
          <source>If you are running Perl 5.6.0 or better, the &lt;code&gt;use warnings&lt;/code&gt; pragma allows fine control of what warnings are produced. See &lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt; for more details.</source>
          <target state="translated">Perl 5.6.0以降を実行している場合、 &lt;code&gt;use warnings&lt;/code&gt; の使用プラグマを使用すると、生成される警告を細かく制御できます。詳細については、&lt;a href=&quot;perllexwarn&quot;&gt;perllexwarn&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="af8514c8e63d77882efdff2789324ce75a2c20f4" translate="yes" xml:space="preserve">
          <source>If you are running VOS Release 14.4.1 or later, you can obtain a pre-compiled, supported copy of perl by purchasing the GNU Tools product from Stratus Technologies.</source>
          <target state="translated">VOS Release 14.4.1 以降を実行している場合は、Stratus Technologies 社から GNU Tools 製品を購入することで、コンパイル済みでサポートされている perl のコピーを入手することができます。</target>
        </trans-unit>
        <trans-unit id="90113b08f2e5803b4f4fa9119cc6038c86b7bb42" translate="yes" xml:space="preserve">
          <source>If you are running a Unix derivative this value defaults to</source>
          <target state="translated">Unix 派生版を実行している場合、この値のデフォルトは</target>
        </trans-unit>
        <trans-unit id="9cc43bdd9e8f39cf93edce0474ecd12686e0c219" translate="yes" xml:space="preserve">
          <source>If you are running experiments with embedding perl as a library into other applications, you might find MakeMaker is not sufficient. You'd better have a look at &lt;a href=&quot;ExtUtils::Embed&quot;&gt;ExtUtils::Embed&lt;/a&gt; which is a collection of utilities for embedding.</source>
          <target state="translated">perlをライブラリとして他のアプリケーションに埋め込む実験を実行している場合は、MakeMakerでは不十分な場合があります。埋め込み用のユーティリティのコレクションである&lt;a href=&quot;ExtUtils::Embed&quot;&gt;ExtUtils :: Embed&lt;/a&gt;をご覧ください。</target>
        </trans-unit>
        <trans-unit id="ae421a254aed7ffd059cb6be52110578a85cd308" translate="yes" xml:space="preserve">
          <source>If you are running experiments with embedding perl as a library into other applications, you might find MakeMaker is not sufficient. You'd better have a look at ExtUtils::Embed which is a collection of utilities for embedding.</source>
          <target state="translated">Perlをライブラリとして他のアプリケーションに埋め込む実験をしている場合、MakeMakerだけでは不十分だと感じるかもしれません。埋め込むためのユーティリティを集めた ExtUtils::Embed を見てみるといいでしょう。</target>
        </trans-unit>
        <trans-unit id="743cbf656ee357233b7747fd85635a26f54ae749" translate="yes" xml:space="preserve">
          <source>If you are running the tests from a emacs shell window, you may see failures in op/stat.t. Run &quot;dmake test-notty&quot; in that case.</source>
          <target state="translated">emacsシェルウィンドウからテストを実行している場合、 op/stat.tに失敗が表示されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="eb661707e45d0fa6207ff65030fca0e35ac953eb" translate="yes" xml:space="preserve">
          <source>If you are running under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; (and if you aren't, why in the world aren't you?), you'll have to add some declarations to make it happy:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; の下で実行している場合（そうでない場合は、なぜ世界にないのですか？）、それを満足させるためにいくつかの宣言を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="0cc4f2e6ac843fbaf8224a05183a7220196cd15a" translate="yes" xml:space="preserve">
          <source>If you are running under &lt;code&gt;use strict&lt;/code&gt; (and if you aren't, why in the world aren't you?), you'll have to add some declarations to make it happy:</source>
          <target state="translated">&lt;code&gt;use strict&lt;/code&gt; を使用して実行している場合（そうでない場合は、なぜ世界ではそうではないのですか？）、それを幸せにするためにいくつかの宣言を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="767de91007776d2ff4bd67fc3c5e04ab7cebdfa3" translate="yes" xml:space="preserve">
          <source>If you are seeing spaces between the elements of your array when you print the array, you are probably interpolating the array in double quotes:</source>
          <target state="translated">配列を印刷するときに配列の要素間にスペースが表示される場合は、二重引用符で配列を補間している可能性があります。</target>
        </trans-unit>
        <trans-unit id="094ee1dd3418e11cdcfc777d87840149f066679d" translate="yes" xml:space="preserve">
          <source>If you are stuck with older Perls, you can do Unicode with the &lt;a href=&quot;Unicode::String&quot;&gt;Unicode::String&lt;/a&gt; module, and character conversions using the &lt;a href=&quot;Unicode::Map8&quot;&gt;Unicode::Map8&lt;/a&gt; and &lt;a href=&quot;Unicode::Map&quot;&gt;Unicode::Map&lt;/a&gt; modules. If you are using Japanese encodings, you might try using the jperl 5.005_03.</source>
          <target state="translated">古いPerlで立ち往生している場合は、&lt;a href=&quot;Unicode::String&quot;&gt;Unicode :: String&lt;/a&gt;モジュールを使用して&lt;a href=&quot;Unicode::Map8&quot;&gt;Unicode&lt;/a&gt;を実行し、Unicode :: Map8および&lt;a href=&quot;Unicode::Map&quot;&gt;Unicode :: Map&lt;/a&gt;モジュールを使用して文字変換を行うことができます。日本語のエンコーディングを使用している場合は、jperl5.005_03を使用してみてください。</target>
        </trans-unit>
        <trans-unit id="16bb00dc57c212c5f89aeced92e2138d70407e36" translate="yes" xml:space="preserve">
          <source>If you are stuck with older Perls, you can do Unicode with the &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::String&quot;&gt;Unicode::String&lt;/a&gt; module, and character conversions using the &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map8&quot;&gt;Unicode::Map8&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map&quot;&gt;Unicode::Map&lt;/a&gt; modules. If you are using Japanese encodings, you might try using the jperl 5.005_03.</source>
          <target state="translated">古い&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map8&quot;&gt;Perlに悩まされ&lt;/a&gt;て&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Map&quot;&gt;いる&lt;/a&gt;場合は、&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::String&quot;&gt;Unicode :: String&lt;/a&gt;モジュールでUnicodeを実行し、Unicode :: Map8およびUnicode :: Mapモジュールを使用して文字変換を行うことができます。日本語のエンコーディングを使用している場合は、jperl 5.005_03を使用してみてください。</target>
        </trans-unit>
        <trans-unit id="a4539f5703f218245f234df49c0b9e75bd10857f" translate="yes" xml:space="preserve">
          <source>If you are submitting a code patch there are several things that you can do to help the Perl 5 Porters accept your patch.</source>
          <target state="translated">コードパッチを提出する場合、Perl 5 Porters があなたのパッチを受け入れるためにできることがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="9d2ae6978c448ceee8a44a91cddc4545fb9e5c5e" translate="yes" xml:space="preserve">
          <source>If you are targetting an ARM device -- which currently includes the vast majority of phones and tablets -- you'll want to pass -Dcc=arm-unknown-nto-qnx8.0.0eabi-gcc to Configure. Alternatively, if you are targetting an x86 device, or using the simulator provided with the NDK, you should specify -Dcc=ntox86-gcc instead.</source>
          <target state="translated">ARMデバイスをターゲットにしている場合(現在、電話やタブレットの大部分を含む)、Configureに-Dcc=arm-unknown-nto-qnx8.0.0eabi-gccを渡したいでしょう。また、x86デバイスをターゲットにしている場合やNDK付属のシミュレータを使用している場合は、代わりに-Dcc=ntox86-gccを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="562b5f2e0c42aed49d34015bad0780eaae56e849" translate="yes" xml:space="preserve">
          <source>If you are targetting x86 Android, you will have to change &lt;code&gt;$TARGETARCH-gcc&lt;/code&gt; to &lt;code&gt;i686-linux-android-gcc&lt;/code&gt;.</source>
          <target state="translated">x86 Androidをターゲットにしている場合は、 &lt;code&gt;$TARGETARCH-gcc&lt;/code&gt; を &lt;code&gt;i686-linux-android-gcc&lt;/code&gt; に変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="c81847f52511bd6e6f2d950ba6b028d46d7fda4c" translate="yes" xml:space="preserve">
          <source>If you are testing locales (see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;), there are helper functions in</source>
          <target state="translated">ロケールをテストしている場合（&lt;a href=&quot;perllocale&quot;&gt;perllocaleを&lt;/a&gt;参照）、次の場所にヘルパー関数があります。</target>
        </trans-unit>
        <trans-unit id="638d5e69c0134925bf444f9f37d95ff5346d9353" translate="yes" xml:space="preserve">
          <source>If you are testing only once, the standard module &lt;a href=&quot;List::Util&quot;&gt;List::Util&lt;/a&gt; exports the function &lt;code&gt;any&lt;/code&gt; for this purpose. It works by stopping once it finds the element. It's written in C for speed, and its Perl equivalent looks like this subroutine:</source>
          <target state="translated">テストを1回だけ行う場合、標準モジュール&lt;a href=&quot;List::Util&quot;&gt;List :: Util&lt;/a&gt;はこの目的のために関数 &lt;code&gt;any&lt;/code&gt; をエクスポートします。要素が見つかると停止することで機能します。速度を上げるためにCで記述されており、Perlに相当するものは次のサブルーチンのようになります。</target>
        </trans-unit>
        <trans-unit id="1005d40b52c8fba9456ef2a3b1ec6cff90f7233f" translate="yes" xml:space="preserve">
          <source>If you are testing only once, the standard module &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt; exports the function &lt;code&gt;first&lt;/code&gt; for this purpose. It works by stopping once it finds the element. It's written in C for speed, and its Perl equivalent looks like this subroutine:</source>
          <target state="translated">一度だけテストする場合、標準モジュール&lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt;はこの目的のために &lt;code&gt;first&lt;/code&gt; に関数をエクスポートします。要素を見つけたら停止することで機能します。速度を上げるためにCで書かれており、対応するPerlは次のサブルーチンのようになります。</target>
        </trans-unit>
        <trans-unit id="ee2ce6dbafcb9d4d548485293c0456fbed2a8877" translate="yes" xml:space="preserve">
          <source>If you are trying to use this instead of &lt;a href=&quot;#write-FILEHANDLE&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; to capture the output, you may find it easier to open a filehandle to a scalar (&lt;code&gt;open my $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt;) and write to that instead.</source>
          <target state="translated">&lt;a href=&quot;#write-FILEHANDLE&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;代わりにこれを使用して出力をキャプチャしようとしている場合は、ファイルハンドルをスカラーに &lt;code&gt;open my $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; を開く）、代わりに書き込む方が簡単な場合があります。</target>
        </trans-unit>
        <trans-unit id="faf3c25ab12fb420d9fdf6ea0144e15dc43f0fe2" translate="yes" xml:space="preserve">
          <source>If you are trying to use this instead of &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; to capture the output, you may find it easier to open a filehandle to a scalar (&lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ) and write to that instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; なくこれを使用して出力をキャプチャしようとしている場合は、スカラーへのファイルハンドルを開いて（ &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ）、代わりにそれに書き込む方が簡単な場合があります。</target>
        </trans-unit>
        <trans-unit id="87f126d580b9d17eb9520e5adc6ebcd7b64cbce8" translate="yes" xml:space="preserve">
          <source>If you are trying to use this instead of &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; to capture the output, you may find it easier to open a filehandle to a scalar (&lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ) and write to that instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; なくこれを使用して出力をキャプチャしようとしている場合は、スカラーへのファイルハンドルを開いて（ &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; $fh, &quot;&amp;gt;&quot;, \$output&lt;/code&gt; ）、代わりにそれに書き込む方が簡単な場合があります。</target>
        </trans-unit>
        <trans-unit id="f0601abe3b8fe05fc06de5499fb9941a40db6bc0" translate="yes" xml:space="preserve">
          <source>If you are unable to send your report using &lt;b&gt;perlbug&lt;/b&gt; (most likely because your system doesn't have a way to send mail that perlbug recognizes), you may be able to use this tool to compose your report and save it to a file which you can then send to &lt;b&gt;perlbug@perl.org&lt;/b&gt; using your regular mail client.</source>
          <target state="translated">&lt;b&gt;perlbug&lt;/b&gt;を使用してレポートを送信できない場合（おそらくシステムにperlbugが認識するメールを送信する方法がないため）、このツールを使用してレポートを作成し、ファイルに保存することができます。次に、通常のメールクライアントを使用して&lt;b&gt;perlbug@perl.orgに&lt;/b&gt;送信できます。</target>
        </trans-unit>
        <trans-unit id="dd788f693f0912cff62f6c5004a3304201e94790" translate="yes" xml:space="preserve">
          <source>If you are used to working with a version of Perl prior to the introduction of lexically scoped warnings, or have code that uses both lexical warnings and &lt;code&gt;$^W&lt;/code&gt; , this section will describe how they interact.</source>
          <target state="translated">レキシカルスコープの警告が導入される前のバージョンのPerlでの作業に慣れている場合、またはレキシカル警告と &lt;code&gt;$^W&lt;/code&gt; 両方を使用するコードがある場合、このセクションではそれらの相互作用について説明します。</target>
        </trans-unit>
        <trans-unit id="d4b0bb469edf0650ec3f65bb5c7e77e909873d27" translate="yes" xml:space="preserve">
          <source>If you are used to working with a version of Perl prior to the introduction of lexically scoped warnings, or have code that uses both lexical warnings and &lt;code&gt;$^W&lt;/code&gt;, this section will describe how they interact.</source>
          <target state="translated">字句スコープの警告が導入される前のバージョンのPerlでの作業に慣れている場合、または字句警告と &lt;code&gt;$^W&lt;/code&gt; 両方を使用するコードがある場合は、このセクションでそれらがどのように相互作用するかについて説明します。</target>
        </trans-unit>
        <trans-unit id="08e74829ea9d71b80a5466e72595b5d826dd1692" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt; or one of its subclasses, you can call the &lt;code&gt;autoflush&lt;/code&gt; method to change the settings of the filehandle:</source>
          <target state="translated">&lt;a href=&quot;IO::Handle&quot;&gt;IO :: Handle&lt;/a&gt;またはそのサブクラスの1つを使用している場合は、 &lt;code&gt;autoflush&lt;/code&gt; メソッドを呼び出してファイルハンドルの設定を変更できます。</target>
        </trans-unit>
        <trans-unit id="19c883172a7bd8c24338f9dd7a287c030969e4c2" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt; or one of its subclasses, you can call the &lt;code&gt;autoflush&lt;/code&gt; method to change the settings of the filehandle:</source>
          <target state="translated">&lt;a href=&quot;io/handle&quot;&gt;IO :: Handle&lt;/a&gt;またはそのサブクラスの1つを使用している場合は、 &lt;code&gt;autoflush&lt;/code&gt; メソッドを呼び出して、ファイルハンドルの設定を変更できます。</target>
        </trans-unit>
        <trans-unit id="66ca3a901cfd38d2b33b77415f58b3c173825a91" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;HePV&lt;/code&gt; to get values to pass to &lt;code&gt;newSVpvn()&lt;/code&gt; to create a new SV, you should consider using &lt;code&gt;newSVhek(HeKEY_hek(he))&lt;/code&gt; as it is more efficient.</source>
          <target state="translated">&lt;code&gt;HePV&lt;/code&gt; を使用して &lt;code&gt;newSVpvn()&lt;/code&gt; に渡す値を取得し、新しいSVを作成する場合は、 &lt;code&gt;newSVhek(HeKEY_hek(he))&lt;/code&gt; を使用する方が効率的です。</target>
        </trans-unit>
        <trans-unit id="987d668924ef21e965c8815374cd5ece61317689" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;nanosleep&lt;/code&gt; for something else than mixing sleeping with signals, give some thought to whether Perl is the tool you should be using for work requiring nanosecond accuracies.</source>
          <target state="translated">スリープと信号を混合する以外の目的で &lt;code&gt;nanosleep&lt;/code&gt; を使用している場合は、Perlがナノ秒の精度を必要とする作業に使用するツールであるかどうかを検討してください。</target>
        </trans-unit>
        <trans-unit id="ef7387a4fe9a4611da9e256c7be19f5e356ca6ea" translate="yes" xml:space="preserve">
          <source>If you are using ACLs, there is a pragma called &lt;a href=&quot;filetest&quot;&gt;&lt;code&gt;filetest&lt;/code&gt;&lt;/a&gt; that may produce more accurate results than the bare &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; mode bits. When under &lt;code&gt;use filetest 'access'&lt;/code&gt;, the above-mentioned filetests test whether the permission can(not) be granted using the &lt;a href=&quot;http://man.he.net/man2/access&quot;&gt;access(2)&lt;/a&gt; family of system calls. Also note that the &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;-X&lt;/code&gt; tests may under this pragma return true even if there are no execute permission bits set (nor any extra execute permission ACLs). This strangeness is due to the underlying system calls' definitions. Note also that, due to the implementation of &lt;code&gt;use filetest 'access'&lt;/code&gt;, the &lt;code&gt;_&lt;/code&gt; special filehandle won't cache the results of the file tests when this pragma is in effect. Read the documentation for the &lt;a href=&quot;filetest&quot;&gt;&lt;code&gt;filetest&lt;/code&gt;&lt;/a&gt; pragma for more information.</source>
          <target state="translated">ACLを使用している場合は、&lt;a href=&quot;filetest&quot;&gt; &lt;code&gt;filetest&lt;/code&gt; &lt;/a&gt;と呼ばれるプラグマがあり、ベア&lt;a href=&quot;#stat-FILEHANDLE&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;モードビットよりも正確な結果が得られる可能性があります。 &lt;code&gt;use filetest 'access'&lt;/code&gt; を使用している場合、上記のfiletestsは、システムコールの&lt;a href=&quot;http://man.he.net/man2/access&quot;&gt;access（2）&lt;/a&gt;ファミリを使用してアクセス許可を付与できる（できない）かどうかをテストします。また、 &lt;code&gt;-x&lt;/code&gt; および &lt;code&gt;-X&lt;/code&gt; テストは、実行許可ビットが設定されていない場合（または追加の実行許可ACLがない場合でも）、このプラグマの下でtrueを返す場合があることに注意してください。この奇妙さは、基礎となるシステムコールの定義によるものです。 &lt;code&gt;use filetest 'access'&lt;/code&gt; 実装により、 &lt;code&gt;_&lt;/code&gt; このプラグマが有効な場合、特別なファイルハンドルはファイルテストの結果をキャッシュしません。詳細については、&lt;a href=&quot;filetest&quot;&gt; &lt;code&gt;filetest&lt;/code&gt; &lt;/a&gt;プラグマのドキュメントをお読みください。</target>
        </trans-unit>
        <trans-unit id="f9a45f762f42b66675541c22b88f50402f53057c" translate="yes" xml:space="preserve">
          <source>If you are using ACLs, there is a pragma called &lt;code&gt;filetest&lt;/code&gt; that may produce more accurate results than the bare stat() mode bits. When under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; the above-mentioned filetests test whether the permission can(not) be granted using the access(2) family of system calls. Also note that the &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; may under this pragma return true even if there are no execute permission bits set (nor any extra execute permission ACLs). This strangeness is due to the underlying system calls' definitions. Note also that, due to the implementation of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; , the &lt;code&gt;_&lt;/code&gt; special filehandle won't cache the results of the file tests when this pragma is in effect. Read the documentation for the &lt;code&gt;filetest&lt;/code&gt; pragma for more information.</source>
          <target state="translated">ACLを使用している場合は、裸のstat（）モードビットよりも正確な結果が得られる &lt;code&gt;filetest&lt;/code&gt; というプラグマがあります。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用している&lt;/a&gt;場合、上記のファイルテストは、システムコールのaccess（2）ファミリを使用してアクセス許可を付与できるかどうかをテストします。また、実行プラグインが設定されていなくても（追加の実行アクセス許可ACLもない）、このプラグマの下で &lt;code&gt;-x&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; がtrueを返す場合があることに注意してください。この奇妙さは、基になるシステムコールの定義によるものです。また、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; の実装により、 &lt;code&gt;_&lt;/code&gt; このプラグマが有効な場合、特別なファイルハンドルはファイルテストの結果をキャッシュしません。詳細については、 &lt;code&gt;filetest&lt;/code&gt; プラグマのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="536f259afd4833a386595561631d799b0872387d" translate="yes" xml:space="preserve">
          <source>If you are using ACLs, there is a pragma called &lt;code&gt;filetest&lt;/code&gt; that may produce more accurate results than the bare stat() mode bits. When under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; the above-mentioned filetests test whether the permission can(not) be granted using the access(2) family of system calls. Also note that the &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; may under this pragma return true even if there are no execute permission bits set (nor any extra execute permission ACLs). This strangeness is due to the underlying system calls' definitions. Note also that, due to the implementation of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; , the &lt;code&gt;_&lt;/code&gt; special filehandle won't cache the results of the file tests when this pragma is in effect. Read the documentation for the &lt;code&gt;filetest&lt;/code&gt; pragma for more information.</source>
          <target state="translated">ACLを使用している場合は、裸のstat（）モードビットよりも正確な結果が得られる &lt;code&gt;filetest&lt;/code&gt; というプラグマがあります。 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; &lt;a href=&quot;use&quot;&gt;使用している&lt;/a&gt;場合、上記のファイルテストは、システムコールのaccess（2）ファミリを使用してアクセス許可を付与できるかどうかをテストします。また、実行プラグインが設定されていなくても（追加の実行アクセス許可ACLもない）、このプラグマの下で &lt;code&gt;-x&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; がtrueを返す場合があることに注意してください。この奇妙さは、基になるシステムコールの定義によるものです。また、 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; filetest 'access'&lt;/code&gt; の実装により、 &lt;code&gt;_&lt;/code&gt; このプラグマが有効な場合、特別なファイルハンドルはファイルテストの結果をキャッシュしません。詳細については、 &lt;code&gt;filetest&lt;/code&gt; プラグマのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="4cb0cc5912b1065f25576985628bc261176328a3" translate="yes" xml:space="preserve">
          <source>If you are using MacOS, the same concerns apply. MacPerl (for Classic environments) comes with a simple editor. Popular external editors are BBEdit ( &lt;a href=&quot;http://www.barebones.com/products/bbedit/&quot;&gt;http://www.barebones.com/products/bbedit/&lt;/a&gt; ) or Alpha ( &lt;a href=&quot;http://www.his.com/~jguyer/Alpha/Alpha8.html&quot;&gt;http://www.his.com/~jguyer/Alpha/Alpha8.html&lt;/a&gt; ). MacOS X users can use Unix editors as well.</source>
          <target state="translated">MacOSを使用している場合、同じ懸念事項が適用されます。MacPerl（クラシック環境用）にはシンプルなエディターが付属しています。人気のある外部エディターはBBEdit（&lt;a href=&quot;http://www.barebones.com/products/bbedit/&quot;&gt;http://www.barebones.com/products/bbedit/&lt;/a&gt;）またはAlpha（&lt;a href=&quot;http://www.his.com/~jguyer/Alpha/Alpha8.html&quot;&gt;http://www.his.com/~jguyer/Alpha/Alpha8.html&lt;/a&gt;）です。MacOS Xユーザーは、Unixエディターも使用できます。</target>
        </trans-unit>
        <trans-unit id="6089a0839b7337d6b244906202548f79ff85a178" translate="yes" xml:space="preserve">
          <source>If you are using Plack (which most frameworks do), then &lt;a href=&quot;Plack::Middleware::Rewrite&quot;&gt;Plack::Middleware::Rewrite&lt;/a&gt; is worth looking at if you are migrating from Apache or have URL's you want to always redirect.</source>
          <target state="translated">Plack（ほとんどのフレームワークが使用）を使用している場合、Apacheから移行する場合、または常にリダイレクトするURLがある場合は、&lt;a href=&quot;Plack::Middleware::Rewrite&quot;&gt;Plack :: Middleware :: Rewrite&lt;/a&gt;を確認する価値があります。</target>
        </trans-unit>
        <trans-unit id="6e4548a312b12b5507979ee1df1e5c700b717005" translate="yes" xml:space="preserve">
          <source>If you are using Plack (which most frameworks do), then &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Rewrite&quot;&gt;Plack::Middleware::Rewrite&lt;/a&gt; is worth looking at if you are migrating from Apache or have URL's you want to always redirect.</source>
          <target state="translated">Plack（ほとんどのフレームワークで使用）を使用している場合、Apacheから移行する場合、または常にリダイレクトするURLがある場合は、&lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Rewrite&quot;&gt;Plack :: Middleware :: Rewrite&lt;/a&gt;を検討する価値があります。</target>
        </trans-unit>
        <trans-unit id="88dc2855988852eaabc5467d99d4705c5f78e44c" translate="yes" xml:space="preserve">
          <source>If you are using Term::ANSIColor in a console command, consider supporting the CLICOLOR standard. See &lt;a href=&quot;#Supporting-CLICOLOR&quot;&gt;&quot;Supporting CLICOLOR&quot;&lt;/a&gt; for more information.</source>
          <target state="translated">コンソールコマンドでTerm :: ANSIColorを使用している場合は、CLICOLOR標準のサポートを検討してください。詳細については、&lt;a href=&quot;#Supporting-CLICOLOR&quot;&gt;「CLICOLORのサポート」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b1b08c775dc3592188f9dd4afa0190ccbb806664" translate="yes" xml:space="preserve">
          <source>If you are using Windows, you can use any editor that lets you work with plain text, such as NotePad or WordPad. Word processors, such as Microsoft Word or WordPerfect, typically do not work since they insert all sorts of behind-the-scenes information, although some allow you to save files as &quot;Text Only&quot;. You can also download text editors designed specifically for programming, such as Textpad ( &lt;a href=&quot;http://www.textpad.com/&quot;&gt;http://www.textpad.com/&lt;/a&gt; ) and UltraEdit ( &lt;a href=&quot;http://www.ultraedit.com/&quot;&gt;http://www.ultraedit.com/&lt;/a&gt; ), among others.</source>
          <target state="translated">Windowsを使用している場合は、メモ帳やワードパッドなどのプレーンテキストを操作できる任意のエディターを使用できます。 Microsoft WordやWordPerfectなどのワードプロセッサは、あらゆる種類の舞台裏情報を挿入するため、通常は機能しませんが、一部のユーザーは「テキストのみ」としてファイルを保存できます。 Textpad（&lt;a href=&quot;http://www.textpad.com/&quot;&gt;http://www.textpad.com/&lt;/a&gt;）やUltraEdit（&lt;a href=&quot;http://www.ultraedit.com/&quot;&gt;http://www.ultraedit.com/&lt;/a&gt;）など、プログラミング用に特別に設計されたテキストエディターをダウンロードすることもできます。</target>
        </trans-unit>
        <trans-unit id="42b14c31c340803d7d1a8907e87c3b623cebca0d" translate="yes" xml:space="preserve">
          <source>If you are using a SOCKS firewall, you will need to compile perl and link it with the SOCKS library. This is what is normally called a 'socksified' perl. With this executable you will be able to connect to servers outside the firewall as if it were not there.</source>
          <target state="translated">SOCKSファイアウォールを使用している場合は、perlをコンパイルしてSOCKSライブラリと連携させる必要があります。これが通常「ソックス化された」perlと呼ばれるものです。この実行ファイルを使えば、あたかもファイアウォールが存在しないかのように、ファイアウォール外のサーバに接続することができるようになります。</target>
        </trans-unit>
        <trans-unit id="52dddb8880620f072f3a58161e2e257e19923fa6" translate="yes" xml:space="preserve">
          <source>If you are using a module which returns something special on failure, then you can manually create hints for each of the desired subroutines. Once the hints are specified, they are available for all files and modules loaded thereafter, thus you can move this work into a module and it will still work.</source>
          <target state="translated">失敗したときに何か特別なものを返すモジュールを使用している場合は、必要なサブルーチンごとにヒントを手動で作成することができます。一度ヒントが指定されると、それはその後に読み込まれたすべてのファイルやモジュールで利用できるようになります。</target>
        </trans-unit>
        <trans-unit id="29c561106308348f3755c72923d0a263a80ca5d3" translate="yes" xml:space="preserve">
          <source>If you are using a regex here, you have to use the quotes as shown or it won't work. Also note that regex handling is tricky even for the experienced. Use this feature with caution.</source>
          <target state="translated">ここで正規表現を使用している場合は、表示されているように引用符を使用しなければなりません。また、正規表現の扱いは経験者でもトリッキーなので注意してください。この機能は注意して使用してください。</target>
        </trans-unit>
        <trans-unit id="5a12a925a69a2c6041232d382cd6683ae36d2da6" translate="yes" xml:space="preserve">
          <source>If you are using a version of Perl earlier than 5.004_57, the tied array interface is quite limited. In the example script above &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; or determining the array length will not work with a tied array.</source>
          <target state="translated">5.004_57より前のバージョンのPerlを使用している場合、結合配列インターフェースはかなり制限されています。上記のスクリプト例では、 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; 、または配列の長さの決定は、結合配列では機能しません。</target>
        </trans-unit>
        <trans-unit id="5e370f11050262a4d86dce72f35bfab79335c669" translate="yes" xml:space="preserve">
          <source>If you are using a version of Perl earlier than 5.004_57, the tied array interface is quite limited. In the example script above &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;shift&lt;/code&gt;, &lt;code&gt;unshift&lt;/code&gt; or determining the array length will not work with a tied array.</source>
          <target state="translated">5.004_57より前のバージョンのPerlを使用している場合、タイドアレイインターフェイスはかなり制限されます。上記のサンプルスクリプトでは、 &lt;code&gt;push&lt;/code&gt; 、 &lt;code&gt;pop&lt;/code&gt; 、 &lt;code&gt;shift&lt;/code&gt; 、 &lt;code&gt;unshift&lt;/code&gt; 、または配列の長さの決定は、タイの配列では機能しません。</target>
        </trans-unit>
        <trans-unit id="02abd4a44d56e10cd1bbe5fedc62225b1b539860" translate="yes" xml:space="preserve">
          <source>If you are using any code that requires the execution of the global destruction phase for clean up (e.g., removing temp files), then do not use detached threads, but rather join all threads before exiting the program.</source>
          <target state="translated">クリーンアップのためにグローバル破壊フェーズの実行を必要とするコードを使用している場合(例:テンポラリファイルの削除)、デタッチドスレッドを使用せず、プログラムを終了する前にすべてのスレッドを結合してください。</target>
        </trans-unit>
        <trans-unit id="360a39abe6795afd63327f3e470a092ad595cbfe" translate="yes" xml:space="preserve">
          <source>If you are using cpan-mac, just drop the folder on the &lt;b&gt;installme&lt;/b&gt; droplet, and use the module.</source>
          <target state="translated">cpan-macを使用している場合は、フォルダーを&lt;b&gt;installme&lt;/b&gt;ドロップレットにドロップして、モジュールを使用します。</target>
        </trans-unit>
        <trans-unit id="1fc1c37b5a3d2067860bd9ba4aa2038972693c34" translate="yes" xml:space="preserve">
          <source>If you are using gcc, just</source>
          <target state="translated">gccを使用している場合は</target>
        </trans-unit>
        <trans-unit id="8fd5d7695f8aa3649f7196f528604d5d3ae20e06" translate="yes" xml:space="preserve">
          <source>If you are using gcc, you would need to use -mcpu=v9 -m64 instead. This option is not yet supported as of gcc 2.95.2; from install/SPECIFIC in that release:</source>
          <target state="translated">gcc を使用している場合は、代わりに -mcpu=v9 -m64 を使用する必要があります。このオプションは gcc 2.95.2 の時点ではまだサポートされていません。</target>
        </trans-unit>
        <trans-unit id="43b374ff761647040bfef238a2f344855f86b957" translate="yes" xml:space="preserve">
          <source>If you are using locale purely for its characteristics related to things like its numeric and time formatting (and not &lt;code&gt;LC_CTYPE&lt;/code&gt; ), consider using a restricted form of the locale pragma (see &lt;a href=&quot;perllocale#The-%22use-locale%22-pragma&quot;&gt;The use locale pragma in perllocale&lt;/a&gt;) like &quot;&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; &quot;.</source>
          <target state="translated">数値や時間のフォーマット（ &lt;code&gt;LC_CTYPE&lt;/code&gt; ではなく）などに関連する特性のためだけにロケールを使用している場合は、&quot; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale ':not_characters'&lt;/code&gt; locale '：not_characters'のような制限された形式のロケールプラグマ（&lt;a href=&quot;perllocale#The-%22use-locale%22-pragma&quot;&gt;perllocaleでのロケールプラグマの使用を&lt;/a&gt;参照）の使用を検討してください。」</target>
        </trans-unit>
        <trans-unit id="3f4713ad5807b5f7826ec2dd53e64e4312c481e4" translate="yes" xml:space="preserve">
          <source>If you are using locale purely for its characteristics related to things like its numeric and time formatting (and not &lt;code&gt;LC_CTYPE&lt;/code&gt;), consider using a restricted form of the locale pragma (see &lt;a href=&quot;perllocale#The-%22use-locale%22-pragma&quot;&gt;&quot;The &quot;use locale&quot; pragma&quot; in perllocale&lt;/a&gt;) like &quot;&lt;code&gt;use locale ':not_characters'&lt;/code&gt;&quot;.</source>
          <target state="translated">あなたがその数値と時間の書式設定（とないようなものに関連するその特性のために純粋にロケールを使用している場合は &lt;code&gt;LC_CTYPE&lt;/code&gt; ）、ロケールプラグマの制限された形式を使用することを検討してください（参照&lt;a href=&quot;perllocale#The-%22use-locale%22-pragma&quot;&gt;はperllocaleに「『使用のロケール』プラグマを」&lt;/a&gt;）」のような &lt;code&gt;use locale ':not_characters'&lt;/code&gt; &quot;。</target>
        </trans-unit>
        <trans-unit id="bf7e18738b21f2b01d05483723778a511f7e8e06" translate="yes" xml:space="preserve">
          <source>If you are using the 'make' directly, it is the GNU make from the SDKs, and it will invoke the right make commands for the Windows emulator build and the Arm target builds ('thumb' by default) as necessary.</source>
          <target state="translated">make' を直接使用している場合、これは SDK からの GNU make であり、必要に応じて Windows エミュレータビルドと Arm ターゲットビルド ('thumb')用の正しい make コマンドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="63c7cadf9ebf06d221687f1101781684817f90c8" translate="yes" xml:space="preserve">
          <source>If you are using the DB_RECNO interface and you intend making use of &lt;code&gt;bval&lt;/code&gt; , you should check out &lt;a href=&quot;#The-'bval'-Option&quot;&gt;The 'bval' Option&lt;/a&gt;.</source>
          <target state="translated">DB_RECNOインターフェースを使用していて、 &lt;code&gt;bval&lt;/code&gt; を使用する場合は、&lt;a href=&quot;#The-'bval'-Option&quot;&gt;「bval」オプションを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="1f6185500a12d4aa7861d0d23b58da2516585e5a" translate="yes" xml:space="preserve">
          <source>If you are using the DB_RECNO interface and you intend making use of &lt;code&gt;bval&lt;/code&gt;, you should check out &lt;a href=&quot;#The-%27bval%27-Option&quot;&gt;&quot;The 'bval' Option&quot;&lt;/a&gt;.</source>
          <target state="translated">DB_RECNOインターフェースを使用していて、 &lt;code&gt;bval&lt;/code&gt; を使用する予定の場合は、&lt;a href=&quot;#The-%27bval%27-Option&quot;&gt;「 'bval'オプション」&lt;/a&gt;を確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="9e34b95c988ef9ff5f011e4473a6842bbc8f305e" translate="yes" xml:space="preserve">
          <source>If you are using the Visual C compiler, you can get the C runtime's command line wildcard expansion built into perl binary. The resulting binary will always expand unquoted command lines, which may not be what you want if you use a shell that does that for you. The expansion done is also somewhat less powerful than the approach suggested above.</source>
          <target state="translated">Visual C コンパイラを使用している場合、C ランタイムのコマンドラインのワイルドカード展開を perl バイナリに組み込むことができます。結果として得られるバイナリは常に引用符で囲まれていないコマンドラインを展開します。展開された展開は、上記の提案されたアプローチに比べて、やや強力ではありません。</target>
        </trans-unit>
        <trans-unit id="7d685e73a12ad96dde7946d5ecb4aacf9b0497e1" translate="yes" xml:space="preserve">
          <source>If you are using the constant interface, be sure to include this code before you use any color constants (such as at the very top of your script), since this environment variable is only honored the first time a color constant is seen.</source>
          <target state="translated">定数インターフェイスを使用している場合は、色定数を使用する前にこのコードを必ず含めるようにしてください (スクリプトの一番上など)。</target>
        </trans-unit>
        <trans-unit id="b64d320b887e6639115cc4ac113f85e3f1804107" translate="yes" xml:space="preserve">
          <source>If you are using this in non-legacy code you may need to reconsider the course of your life, maybe a hermitage would suite you?</source>
          <target state="translated">非legacyコードでこれを使用している場合は、あなたの人生のコースを再考する必要があるかもしれません、もしかしたら庵があなたに合うでしょうか?</target>
        </trans-unit>
        <trans-unit id="a368c00c8ef926e64658830003081d5eb361bb8d" translate="yes" xml:space="preserve">
          <source>If you are using zlib 1.2.0 or older, &lt;code&gt;zlibCompileFlags&lt;/code&gt; will return 0.</source>
          <target state="translated">zlib 1.2.0以前を使用している場合、 &lt;code&gt;zlibCompileFlags&lt;/code&gt; は0を返します。</target>
        </trans-unit>
        <trans-unit id="9d19a794a39cad7420e5c34d0bb89a7b77ddba40" translate="yes" xml:space="preserve">
          <source>If you are willing to accept all the defaults run Configure with &lt;b&gt;-de&lt;/b&gt;. However, several useful customizations are available.</source>
          <target state="translated">すべてのデフォルトを受け入れる場合は、&lt;b&gt;-de&lt;/b&gt;を&lt;b&gt;指定して&lt;/b&gt; Configureを実行します。ただし、いくつかの便利なカスタマイズを利用できます。</target>
        </trans-unit>
        <trans-unit id="fd5b1c2924a349d7291d8ad147e3c28043609419" translate="yes" xml:space="preserve">
          <source>If you are working with a git clone of the Perl repository, you will want to create a branch for your changes. This will make creating a proper patch much simpler. See the &lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt; for details on how to do this.</source>
          <target state="translated">Perlリポジトリのgitクローンを使用している場合は、変更用のブランチを作成する必要があります。これにより、適切なパッチの作成がはるかに簡単になります。これを行う方法の詳細については、&lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d3a5c5d66921962ee5d2f131da55a853da5b0930" translate="yes" xml:space="preserve">
          <source>If you are working with data you know to be valid, you can speed your code up by using the &quot;nocheck&quot; variants, &lt;code&gt;timelocal_nocheck()&lt;/code&gt; and &lt;code&gt;timegm_nocheck()&lt;/code&gt; . These variants must be explicitly imported.</source>
          <target state="translated">有効であることがわかっているデータを使用している場合は、 &quot;nocheck&quot;バリアントである &lt;code&gt;timelocal_nocheck()&lt;/code&gt; および &lt;code&gt;timegm_nocheck()&lt;/code&gt; を使用してコードを高速化できます。これらのバリアントは明示的にインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="44340ebb8cf0e2382c2ca3711523d41bd143a85f" translate="yes" xml:space="preserve">
          <source>If you are working with data you know to be valid, you can speed your code up by using the &quot;nocheck&quot; variants, &lt;code&gt;timelocal_nocheck()&lt;/code&gt; and &lt;code&gt;timegm_nocheck()&lt;/code&gt;. These variants must be explicitly imported.</source>
          <target state="translated">有効であることがわかっているデータを操作している場合は、「nocheck」バリアント、 &lt;code&gt;timelocal_nocheck()&lt;/code&gt; および &lt;code&gt;timegm_nocheck()&lt;/code&gt; を使用してコードを高速化できます。これらのバリアントは明示的にインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="a9fdba02c2ad23e42f49d14ef3350c451024e80f" translate="yes" xml:space="preserve">
          <source>If you are writing a module to expand an already existing set of modules, please coordinate with the author of the package. It helps if you follow the same naming scheme and module interaction scheme as the original author.</source>
          <target state="translated">既存のモジュールを拡張するためにモジュールを書く場合は、パッケージの作者と調整してください。オリジナルの作者と同じ名前付けスキームとモジュールの相互作用スキームに従うと助かります。</target>
        </trans-unit>
        <trans-unit id="1cd2c8d5447831e253b224430edc3070841bc27c" translate="yes" xml:space="preserve">
          <source>If you are writing a package that &lt;code&gt;AUTOLOAD&lt;/code&gt; s, consider forcing an &lt;code&gt;AUTOLOAD&lt;/code&gt; for any constants explicitly imported by other packages or which are usually used when your package is &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;d.</source>
          <target state="translated">あなたはそのパッケージを作成している場合は &lt;code&gt;AUTOLOAD&lt;/code&gt; 秒、強制的に検討し &lt;code&gt;AUTOLOAD&lt;/code&gt; をあなたのパッケージがあるときに通常使用されている明示的に他のパッケージによってインポート任意の定数または &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; D。</target>
        </trans-unit>
        <trans-unit id="008854f6c49a92df108a1a38fd8f1f0c1b757eb6" translate="yes" xml:space="preserve">
          <source>If you are writing a package that &lt;code&gt;AUTOLOAD&lt;/code&gt;s, consider forcing an &lt;code&gt;AUTOLOAD&lt;/code&gt; for any constants explicitly imported by other packages or which are usually used when your package is &lt;code&gt;use&lt;/code&gt;d.</source>
          <target state="translated">あなたはそのパッケージを作成している場合は &lt;code&gt;AUTOLOAD&lt;/code&gt; 秒、強制的に検討し &lt;code&gt;AUTOLOAD&lt;/code&gt; をあなたのパッケージがあるときに通常使用されている明示的に他のパッケージによってインポート任意の定数または &lt;code&gt;use&lt;/code&gt; D。</target>
        </trans-unit>
        <trans-unit id="f5966f6f48bbef92de0797373659162ca479de0d" translate="yes" xml:space="preserve">
          <source>If you are writing new code, your first port of call should be one of the new &lt;code&gt;IO::Compress&lt;/code&gt; or &lt;code&gt;IO::Uncompress&lt;/code&gt; modules.</source>
          <target state="translated">新しいコードを作成する場合、最初の呼び出しポートは、新しい &lt;code&gt;IO::Compress&lt;/code&gt; または &lt;code&gt;IO::Uncompress&lt;/code&gt; モジュールのいずれかである必要があります。</target>
        </trans-unit>
        <trans-unit id="0d5955743a0fa060d529640f937e917d974a0fd9" translate="yes" xml:space="preserve">
          <source>If you ask for nothing in particular, you'll be asking for &lt;code&gt;less
'please'&lt;/code&gt; .</source>
          <target state="translated">特に何も要求しない場合は、 &lt;code&gt;less 'please'&lt;/code&gt; 求めます。</target>
        </trans-unit>
        <trans-unit id="8027e6b734038f8b5eea431be412179b0c1aa993" translate="yes" xml:space="preserve">
          <source>If you ask for nothing in particular, you'll be asking for &lt;code&gt;less 'please'&lt;/code&gt;.</source>
          <target state="translated">あなたが特に何も求めないなら、あなたは &lt;code&gt;less 'please'&lt;/code&gt; ます」を求めているでしょう。</target>
        </trans-unit>
        <trans-unit id="d232183f686226b9e4d9f0a9749bb4ab75350724" translate="yes" xml:space="preserve">
          <source>If you ask it to unmemoize a function that was never memoized, it croaks.</source>
          <target state="translated">メモされていなかった機能をメモされていないようにしてもらうと唸ります。</target>
        </trans-unit>
        <trans-unit id="5ac398bf0535c0d2bb95ebfd6fd6655ce0bd6b20" translate="yes" xml:space="preserve">
          <source>If you ask to override your chdir() built-in function,</source>
          <target state="translated">組み込みの chdir()関数をオーバーライドしてくれと言われたら。</target>
        </trans-unit>
        <trans-unit id="aae82346550e5f30641b00cfb651b5e652048f2e" translate="yes" xml:space="preserve">
          <source>If you attempt to compile Perl with (POSIX) threads on an 11.X system and also link in the GDBM library, then Perl will immediately core dump when it starts up. The only workaround at this point is to relink the GDBM library under 11.X, then relink it into Perl.</source>
          <target state="translated">11.Xシステム上で(POSIX)スレッドを使ってPerlをコンパイルし、GDBMライブラリをリンクすると、Perlの起動時にすぐにコアダンプされてしまいます。この時点での唯一の回避策は、11.XでGDBMライブラリを再リンクしてからPerlに再リンクすることです。</target>
        </trans-unit>
        <trans-unit id="372756b443de4017a28427029bf0d506d7081a2a" translate="yes" xml:space="preserve">
          <source>If you believe the scalar comes back as UTF-8, you will most likely want the UTF8 flag restored:</source>
          <target state="translated">スカラがUTF-8で戻ってくると思ったら、UTF8フラグを復元したいと思うでしょう。</target>
        </trans-unit>
        <trans-unit id="1489e0cb25a613554ca1fb1509eb4766e09aaf06" translate="yes" xml:space="preserve">
          <source>If you believe you have found a security vulnerability in Perl, please email perl5-security-report@perl.org with details. This points to a closed subscription, unarchived mailing list. Please only use this address for security issues in the Perl core, not for modules independently distributed on CPAN.</source>
          <target state="translated">Perl にセキュリティ上の脆弱性を発見したと思われる方は、詳細を perl5-security-report@perl.org までメールでお知らせください。このアドレスは、非公開の購読、アーカイブされていないメーリングリストを指しています。このアドレスは Perl コアのセキュリティ問題にのみ使用し、CPAN で独立して配布されているモジュールには使用しないでください。</target>
        </trans-unit>
        <trans-unit id="74dfa21f751ce3fabe2deb1f0f641c590253ad7e" translate="yes" xml:space="preserve">
          <source>If you believe you have found a security vulnerability in Perl, please email the details to perl5-security-report@perl.org. This creates a new Request Tracker ticket in a special queue which isn't initially publicly accessible. The email will also be copied to a closed subscription unarchived mailing list which includes all the core committers, who will be able to help assess the impact of issues, figure out a resolution, and help co-ordinate the release of patches to mitigate or fix the problem across all platforms on which Perl is supported. Please only use this address for security issues in the Perl core, not for modules independently distributed on CPAN.</source>
          <target state="translated">Perl のセキュリティ脆弱性を発見したと思われる場合は、その詳細を perl5-security-report@perl.org までメールしてください。これにより、最初は公開されていない特別なキューに新しい Request Tracker チケットが作成されます。このメールはまた、すべてのコアコミッタを含む、クローズドサブスクリプションのアーカイブされていないメーリングリストにコピーされ、問題の影響を評価し、解決策を考え、Perl がサポートされているすべてのプラットフォームで問題を緩和または修正するためのパッチのリリースを調整するのを助けることができます。このアドレスは、Perl コアのセキュリティ問題にのみ使用し、CPAN で独立して配布されているモジュールには使用しないでください。</target>
        </trans-unit>
        <trans-unit id="2508e4352c00aad2e5cda3b21b798f7f8735a139" translate="yes" xml:space="preserve">
          <source>If you build with Visual C++ 2013 then three tests currently may fail with Daylight Saving Time related problems:</source>
          <target state="translated">Visual C++2013 で構築した場合、現在 3 つのテストでは、昼間の節電時間に関連する問題で失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="a29ad197e59c85308f30e04c723a79c6188595db" translate="yes" xml:space="preserve">
          <source>If you build with Visual C++ 2015 or later then</source>
          <target state="translated">Visual C++2015 以降でビルドする場合は</target>
        </trans-unit>
        <trans-unit id="fc747a2308602b12226c600429d56710358ba8a4" translate="yes" xml:space="preserve">
          <source>If you build with certain versions (e.g. 4.8.1) of gcc from www.mingw.org then</source>
          <target state="translated">www.mingw.org から特定のバージョンの gcc (4.8.1 など)でビルドした場合は、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="5d082c0ec07ad4429dea09b4d3b6034a0edf4cf9" translate="yes" xml:space="preserve">
          <source>If you built perl with dynamic loading capability then that would also be the way to build XS based extensions. However, if you built perl with the default static linking you can still build XS based extensions for OS/390 but you will need to follow the instructions in ExtUtils::MakeMaker for building statically linked perl binaries. In the simplest configurations building a static perl + XS extension boils down to:</source>
          <target state="translated">動的読み込み機能を持つ perl をビルドした場合は、XS ベースの拡張機能をビルドする方法もあります。しかし、デフォルトのスタティックリンクで perl をビルドした場合は、OS/390 用に XS ベースの拡張機能をビルドすることができますが、スタティックリンクされた perl バイナリをビルドするには ExtUtils::MakeMaker の指示に従う必要があります。最も簡単な設定では、静的リンクされた perl+XS ベースの拡張機能のビルドは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="fccb9cfffea038156e1e9bf29f1e74a06b7c692d" translate="yes" xml:space="preserve">
          <source>If you built perl with dynamic loading capability then that would also be the way to build xs based extensions. However, if you built perl with the default static linking you can still build xs based extensions for OS/390 but you will need to follow the instructions in ExtUtils::MakeMaker for building statically linked perl binaries. In the simplest configurations building a static perl + xs extension boils down to:</source>
          <target state="translated">動的ロード機能を持つ perl をビルドした場合は、それも xs ベースの拡張機能をビルドする方法になります。しかし、デフォルトのスタティックリンクで perl をビルドした場合は、OS/390 用の xs ベースの拡張機能をビルドすることができますが、スタティックリンクされた perl バイナリをビルドするには ExtUtils::MakeMaker の指示に従う必要があります。最も簡単な設定では、静的リンクされた perl+xs ベースの拡張機能のビルドは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="b4bbe3ec8c3dbb9079b54edeba88cab20e6c6b9a" translate="yes" xml:space="preserve">
          <source>If you call $lh-&amp;gt;maketext(</source>
          <target state="translated">$ lh-&amp;gt; maketext（</target>
        </trans-unit>
        <trans-unit id="b2b245ecec2ba731bc1217986ab8fe3ce3832fb6" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;plan()&lt;/code&gt; , don't call any of the other methods below.</source>
          <target state="translated">あなたが呼び出す場合 &lt;code&gt;plan()&lt;/code&gt; 、下記の他の方法のいずれかを呼び出すことはありません。</target>
        </trans-unit>
        <trans-unit id="1fcdeca5cd1457b673de047212c964254182c124" translate="yes" xml:space="preserve">
          <source>If you call &lt;code&gt;plan()&lt;/code&gt;, don't call any of the other methods below.</source>
          <target state="translated">あなたが呼び出す場合 &lt;code&gt;plan()&lt;/code&gt; 、下記の他の方法のいずれかを呼び出すことはありません。</target>
        </trans-unit>
        <trans-unit id="f29b01f558f5cc8e37b47ab816256a32df3eb207" translate="yes" xml:space="preserve">
          <source>If you call a method that doesn't exist in a class, Perl will throw an error. However, if that class or any of its parent classes defines an &lt;code&gt;AUTOLOAD&lt;/code&gt; method, that &lt;code&gt;AUTOLOAD&lt;/code&gt; method is called instead.</source>
          <target state="translated">クラスに存在しないメソッドを呼び出すと、Perlはエラーをスローします。ただし、そのクラスまたはその親クラスのいずれかが &lt;code&gt;AUTOLOAD&lt;/code&gt; メソッドを定義して &lt;code&gt;AUTOLOAD&lt;/code&gt; 場合は、代わりにそのAUTOLOADメソッドが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="945646515b442a128e465225a1d325a7ca2f3625" translate="yes" xml:space="preserve">
          <source>If you call a subroutine that is undefined, you would ordinarily get an immediate, fatal error complaining that the subroutine doesn't exist. (Likewise for subroutines being used as methods, when the method doesn't exist in any base class of the class's package.) However, if an &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine is defined in the package or packages used to locate the original subroutine, then that &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine is called with the arguments that would have been passed to the original subroutine. The fully qualified name of the original subroutine magically appears in the global $AUTOLOAD variable of the same package as the &lt;code&gt;AUTOLOAD&lt;/code&gt; routine. The name is not passed as an ordinary argument because, er, well, just because, that's why. (As an exception, a method call to a nonexistent &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;unimport&lt;/code&gt; method is just skipped instead. Also, if the AUTOLOAD subroutine is an XSUB, there are other ways to retrieve the subroutine name. See &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;Autoloading with XSUBs in perlguts&lt;/a&gt; for details.)</source>
          <target state="translated">未定義のサブルーチンを呼び出すと、通常、そのサブルーチンが存在しないという不平を言う致命的なエラーがすぐに発生します。 （メソッドがクラスのパッケージの基本クラスに存在しない場合に、メソッドとして使用されているサブルーチンと同様に）。ただし、元のサブルーチンを見つけるために使用されるパッケージで &lt;code&gt;AUTOLOAD&lt;/code&gt; サブルーチンが定義されている場合、その &lt;code&gt;AUTOLOAD&lt;/code&gt; サブルーチン元のサブルーチンに渡されるはずの引数を使用して呼び出されます。元サブルーチンの完全修飾名は、魔法と同じパッケージのグローバル$ AUTOLOAD変数に表示されます &lt;code&gt;AUTOLOAD&lt;/code&gt; ルーチン。名前が通常の引数として渡されないのは、えーと、まあ、それが理由です。（例外として、存在しない &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; またはインポート &lt;code&gt;unimport&lt;/code&gt; メソッドへのメソッド呼び出しは代わりにスキップされます。また、AUTOLOADサブルーチンがXSUBである場合、サブルーチン名を取得する他の方法があります。詳細については、PerlgutsでのXSUBを使用した&lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;オートロードを&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="ae93390d7689eae59da77f05524628edc8a8e772" translate="yes" xml:space="preserve">
          <source>If you call a subroutine that is undefined, you would ordinarily get an immediate, fatal error complaining that the subroutine doesn't exist. (Likewise for subroutines being used as methods, when the method doesn't exist in any base class of the class's package.) However, if an &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine is defined in the package or packages used to locate the original subroutine, then that &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine is called with the arguments that would have been passed to the original subroutine. The fully qualified name of the original subroutine magically appears in the global $AUTOLOAD variable of the same package as the &lt;code&gt;AUTOLOAD&lt;/code&gt; routine. The name is not passed as an ordinary argument because, er, well, just because, that's why. (As an exception, a method call to a nonexistent &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;unimport&lt;/code&gt; method is just skipped instead. Also, if the AUTOLOAD subroutine is an XSUB, there are other ways to retrieve the subroutine name. See &lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;&quot;Autoloading with XSUBs&quot; in perlguts&lt;/a&gt; for details.)</source>
          <target state="translated">未定義のサブルーチンを呼び出すと、通常、サブルーチンが存在しないことを示す致命的なエラーが即座に発生します。（メソッドとして使用されているサブルーチンの場合と同様に、メソッドがクラスのパッケージの基本クラスに存在しない場合。）ただし、 &lt;code&gt;AUTOLOAD&lt;/code&gt; サブルーチンが、元のサブルーチンの検索に使用された1つまたは複数のパッケージで定義されている場合、その &lt;code&gt;AUTOLOAD&lt;/code&gt; サブルーチン元のサブルーチンに渡されたはずの引数を使用して呼び出されます。元サブルーチンの完全修飾名は、魔法と同じパッケージのグローバル$ AUTOLOAD変数に表示されます &lt;code&gt;AUTOLOAD&lt;/code&gt; ルーチン。名前は通常の引数として渡されません。なぜなら、ええと、まあ、それが理由だからです。（例外として、存在しない &lt;code&gt;import&lt;/code&gt; または &lt;code&gt;unimport&lt;/code&gt; メソッドへのメソッド呼び出しはスキップされます。また、AUTOLOADサブルーチンがXSUBの場合、サブルーチン名を取得する他の方法があります。詳細については&lt;a href=&quot;perlguts#Autoloading-with-XSUBs&quot;&gt;、perlgutsの「AutoloadingwithXSUBs」&lt;/a&gt;を参照してください。 。）</target>
        </trans-unit>
        <trans-unit id="a71cdebace5c6abb01b81af0b4383d9f3787c035" translate="yes" xml:space="preserve">
          <source>If you can arrange for everyone to deal with this through references, it's cleaner code, although not so nice to look at. Here's a function that takes two array references as arguments, returning the two array elements in order of how many elements they have in them:</source>
          <target state="translated">全員が参照を通してこれを処理できるようにすれば、見栄えはあまり良くありませんが、よりすっきりとしたコードになります。ここでは、2 つの配列参照を引数にとり、2 つの配列要素を要素数の多い順に返す関数を示します。</target>
        </trans-unit>
        <trans-unit id="3cb0b0acb5a45f37eacb24751a1ec1aefb74d989" translate="yes" xml:space="preserve">
          <source>If you can avoid it, don't, or if you can use a templating system, such as &lt;a href=&quot;Text::Template&quot;&gt;Text::Template&lt;/a&gt; or &lt;a href=&quot;template&quot;&gt;Template&lt;/a&gt; Toolkit, do that instead. You might even be able to get the job done with &lt;code&gt;sprintf&lt;/code&gt; or &lt;code&gt;printf&lt;/code&gt;:</source>
          <target state="translated">回避できる場合は回避するか、&lt;a href=&quot;Text::Template&quot;&gt;Text :: Template&lt;/a&gt;や&lt;a href=&quot;template&quot;&gt;TemplateToolkit&lt;/a&gt;などのテンプレートシステムを使用できる場合は、代わりに実行してください。 &lt;code&gt;sprintf&lt;/code&gt; または &lt;code&gt;printf&lt;/code&gt; で仕事を終わらせることさえできるかもしれません：</target>
        </trans-unit>
        <trans-unit id="23b6ce07b51bd0ae187fbd5346ee2bf854f2bb10" translate="yes" xml:space="preserve">
          <source>If you can avoid it, don't, or if you can use a templating system, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text::Template&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/perldoc/Template&quot;&gt;Template&lt;/a&gt; Toolkit, do that instead. You might even be able to get the job done with &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">回避できる場合は避けてください。または、&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text :: Template&lt;/a&gt;や&lt;a href=&quot;http://search.cpan.org/perldoc/Template&quot;&gt;Template&lt;/a&gt; Toolkit などのテンプレートシステムを使用できる場合は、代わりにそれを行ってください。 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; を使用してジョブを完了することもできます。</target>
        </trans-unit>
        <trans-unit id="f9556f6832194ce02eb38bf13ea3951955c6d164" translate="yes" xml:space="preserve">
          <source>If you can do these things, you've started on the long road to Perl porting. Thanks for wanting to help make Perl better - and happy hacking!</source>
          <target state="translated">これらのことができれば、Perl 移植への長い道のりが始まったことになります。Perl をより良いものにするための手助けをしたいと思ってくれてありがとう-そしてハッキングを楽しんでください!</target>
        </trans-unit>
        <trans-unit id="4e5e8e457d8aab789523193251b0cae471debcb4" translate="yes" xml:space="preserve">
          <source>If you can go through your firewall with e.g. lynx, presumably with a command such as</source>
          <target state="translated">lynx のようなコマンドでファイアウォールを通ることができれば、おそらく次のようなコマンドで</target>
        </trans-unit>
        <trans-unit id="22d913b1c7a6af16ecff397b87485204b5a8ebbc" translate="yes" xml:space="preserve">
          <source>If you can not reach the author for some reason contact the PAUSE admins at modules@perl.org who may be able to help, but each case is treated separately.</source>
          <target state="translated">何らかの理由で作者と連絡が取れない場合は、PAUSEの管理者(modules@perl.org)に連絡してください。</target>
        </trans-unit>
        <trans-unit id="e0ff87acae1d2fe61dfcf4190a982955e52a9134" translate="yes" xml:space="preserve">
          <source>If you can't configure &lt;code&gt;TAP::Harness&lt;/code&gt; to do exactly what you want, and writing a plugin isn't an option, consider extending it. It is designed to be (mostly) easy to subclass, though the cases when sub-classing is necessary should be few and far between.</source>
          <target state="translated">&lt;code&gt;TAP::Harness&lt;/code&gt; を希望どおりに実行するように構成できず、プラグインを作成するオプションがない場合は、プラグインを拡張することを検討してください。サブクラス化が必要になるケースは少なく、はるかに限られていますが、サブクラス化が（ほとんど）簡単にできるように設計されています。</target>
        </trans-unit>
        <trans-unit id="700d8f92e3038752feec96509274cbd7256d79dc" translate="yes" xml:space="preserve">
          <source>If you can't configure &lt;code&gt;TAP::Harness&lt;/code&gt; to do what you want, and you can't find an existing plugin, consider writing one.</source>
          <target state="translated">&lt;code&gt;TAP::Harness&lt;/code&gt; を希望どおりに設定できず、既存のプラグインが見つからない場合は、プラグインの作成を検討してください。</target>
        </trans-unit>
        <trans-unit id="aab6be6829c9bde3ac67ace0b1b8f3a83861108b" translate="yes" xml:space="preserve">
          <source>If you can't use &lt;a href=&quot;File::Copy&quot;&gt;File::Copy&lt;/a&gt;, you'll have to do the work yourself: open the original file, open the destination file, then print to the destination file as you read the original. You also have to remember to copy the permissions, owner, and group to the new file.</source>
          <target state="translated">&lt;a href=&quot;File::Copy&quot;&gt;File :: Copyを&lt;/a&gt;使用できない場合は、自分で作業を行う必要があります。元のファイルを開き、宛先ファイルを開いてから、元のファイルを読みながら宛先ファイルに印刷します。また、権限、所有者、およびグループを新しいファイルにコピーすることを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="edcd365c3753fb0814dbbf4b5f1da5978fabe2e0" translate="yes" xml:space="preserve">
          <source>If you can't use &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt;, you'll have to do the work yourself: open the original file, open the destination file, then print to the destination file as you read the original. You also have to remember to copy the permissions, owner, and group to the new file.</source>
          <target state="translated">&lt;a href=&quot;file/copy&quot;&gt;File :: Copyを&lt;/a&gt;使用できない場合は、作業を自分で行う必要があります。元のファイルを開き、宛先ファイルを開いてから、元のファイルを読み取って宛先ファイルに印刷します。また、アクセス許可、所有者、およびグループを新しいファイルにコピーすることを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="2431416836e7be159e91db05fdcbf62b13f365c1" translate="yes" xml:space="preserve">
          <source>If you cannot achieve the desired Makefile behaviour by specifying attributes you may define private subroutines in the Makefile.PL. Each subroutine returns the text it wishes to have written to the Makefile. To override a section of the Makefile you can either say:</source>
          <target state="translated">属性を指定しても希望するMakefileの動作を実現できない場合は、Makefile.PLでプライベートサブルーチンを定義することができます。各サブルーチンは、Makefileに書き込ませたいテキストを返します。Makefileのセクションをオーバーライドするには、次のように言うことができます。</target>
        </trans-unit>
        <trans-unit id="069db45c3cccee54b16dacbbc26ce2a59fc37a49" translate="yes" xml:space="preserve">
          <source>If you cannot upgrade your Perl to 5.8.0 or later, you can still do some Unicode processing by using the modules &lt;code&gt;Unicode::String&lt;/code&gt; , &lt;code&gt;Unicode::Map8&lt;/code&gt; , and &lt;code&gt;Unicode::Map&lt;/code&gt; , available from CPAN. If you have the GNU recode installed, you can also use the Perl front-end &lt;code&gt;Convert::Recode&lt;/code&gt; for character conversions.</source>
          <target state="translated">Perlを5.8.0以降にアップグレードできない場合でも、CPANから入手できるモジュール &lt;code&gt;Unicode::String&lt;/code&gt; 、 &lt;code&gt;Unicode::Map8&lt;/code&gt; 、および &lt;code&gt;Unicode::Map&lt;/code&gt; を使用して、いくつかのUnicode処理を行うことができます。GNU recodeがインストールされている場合は、Perlのフロントエンド &lt;code&gt;Convert::Recode&lt;/code&gt; を使用して文字を変換することもできます。</target>
        </trans-unit>
        <trans-unit id="675032f69b34d194dcc7017e3c4c3044e3fbd01f" translate="yes" xml:space="preserve">
          <source>If you cannot upgrade your Perl to 5.8.0 or later, you can still do some Unicode processing by using the modules &lt;code&gt;Unicode::String&lt;/code&gt;, &lt;code&gt;Unicode::Map8&lt;/code&gt;, and &lt;code&gt;Unicode::Map&lt;/code&gt;, available from CPAN. If you have the GNU recode installed, you can also use the Perl front-end &lt;code&gt;Convert::Recode&lt;/code&gt; for character conversions.</source>
          <target state="translated">Perlを5.8.0以降にアップグレードできない場合でも、CPANから入手できる &lt;code&gt;Unicode::String&lt;/code&gt; 、 &lt;code&gt;Unicode::Map8&lt;/code&gt; 、および &lt;code&gt;Unicode::Map&lt;/code&gt; モジュールを使用して、Unicode処理を行うことができます。GNU recodeがインストールされている場合は、Perlフロントエンドの &lt;code&gt;Convert::Recode&lt;/code&gt; を使用して文字を変換することもできます。</target>
        </trans-unit>
        <trans-unit id="0d66bfc35fac26ccfc5a2fc8cf1cd9923cd9f43b" translate="yes" xml:space="preserve">
          <source>If you cannot use &lt;a href=&quot;List::Util&quot;&gt;List::Util&lt;/a&gt;, you can make your own loop to do the same thing. Once you find the element, you stop the loop with last.</source>
          <target state="translated">&lt;a href=&quot;List::Util&quot;&gt;List :: Utilを&lt;/a&gt;使用できない場合は、独自のループを作成して同じことを行うことができます。要素を見つけたら、最後にループを停止します。</target>
        </trans-unit>
        <trans-unit id="7f06f83624114fcf502e132fac57a686e4d7a4ee" translate="yes" xml:space="preserve">
          <source>If you cannot use &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt;, you can make your own loop to do the same thing. Once you find the element, you stop the loop with last.</source>
          <target state="translated">&lt;a href=&quot;list/util&quot;&gt;List :: Utilを&lt;/a&gt;使用できない場合は、独自のループを作成して同じことを行うことができます。要素を見つけたら、lastでループを停止します。</target>
        </trans-unit>
        <trans-unit id="83e89259781d3b7bf972995b7c8dc74ef7aacff4" translate="yes" xml:space="preserve">
          <source>If you cannot use the git protocol for firewall reasons, you can also clone via http, though this is much slower:</source>
          <target state="translated">ファイアウォール上の理由でgitプロトコルを使えない場合は、http経由でクローンを作成することもできます。</target>
        </trans-unit>
        <trans-unit id="b117af02a8ee1b3faa8a2a2959074d94964f1bce" translate="yes" xml:space="preserve">
          <source>If you cannot use the git protocol for firewall reasons, you can also clone via http:</source>
          <target state="translated">ファイアウォールの理由でgitプロトコルが使えない場合は、http経由でクローンすることもできます。</target>
        </trans-unit>
        <trans-unit id="794395d65809aff375720f1da63fe61351840429" translate="yes" xml:space="preserve">
          <source>If you change &lt;code&gt;$pattern&lt;/code&gt; after the first substitution happens, Perl will ignore it. If you don't want any substitutions at all, use the special delimiter &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">最初の置換が行われた後で &lt;code&gt;$pattern&lt;/code&gt; を変更すると、Perlはそれを無視します。置換がまったく必要ない場合は、特別な区切り文字 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="5a64e176836406787422c8fb3c6947be0def6d35" translate="yes" xml:space="preserve">
          <source>If you change &lt;code&gt;$pattern&lt;/code&gt; after the first substitution happens, Perl will ignore it. If you don't want any substitutions at all, use the special delimiter &lt;code&gt;m''&lt;/code&gt;:</source>
          <target state="translated">最初の置換が行われた後に &lt;code&gt;$pattern&lt;/code&gt; を変更すると、Perlはそれを無視します。置換がまったく必要ない場合は、特別な区切り文字 &lt;code&gt;m''&lt;/code&gt; ：を使用します。</target>
        </trans-unit>
        <trans-unit id="bca560012b71cc8dce8e6a03ec54196daca3d350" translate="yes" xml:space="preserve">
          <source>If you check &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;, you'll see that several of the ways to call open() should do the trick. For example:</source>
          <target state="translated">&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;をチェックすると、open（）を呼び出すいくつかの方法でうまくいくはずです。例えば：</target>
        </trans-unit>
        <trans-unit id="65c2b7d80f9113d02d83f4af5a6da477cccfeb58" translate="yes" xml:space="preserve">
          <source>If you check &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;, you'll see that several of the ways to call open() should do the trick. For example:</source>
          <target state="translated">&lt;a href=&quot;perlfunc#open&quot;&gt;perlfunc&lt;/a&gt;で「open」をチェックすると、open（）を呼び出すいくつかの方法でうまくいくことがわかります。例えば：</target>
        </trans-unit>
        <trans-unit id="e4dedfaceb9670f08b0798c739b80203032d536c" translate="yes" xml:space="preserve">
          <source>If you chomp a list, each element is chomped, and the total number of characters removed is returned.</source>
          <target state="translated">リストをchompすると、各要素がchompされ、削除された文字数の合計が返されます。</target>
        </trans-unit>
        <trans-unit id="716512a060dd3d5999bac2b4045e2b9123dc9b1b" translate="yes" xml:space="preserve">
          <source>If you choose XL C/C++ V11 you need the April 2010 PTF (or newer) installed otherwise you will not get a working Perl version.</source>
          <target state="translated">XL C/C++V11を選択した場合、2010年4月版のPTF(またはそれより新しいもの)がインストールされていないと、Perlのバージョンは動作しません。</target>
        </trans-unit>
        <trans-unit id="c10052f207d29ada4465d2d73fcdfabf3621a0b6" translate="yes" xml:space="preserve">
          <source>If you choose XL C/C++ V9 you need APAR IZ35785 installed otherwise the integrated SDBM_File do not compile correctly due to an optimization bug. You can circumvent this problem by adding -qipa to the optimization flags (-Doptimize='-O -qipa'). The PTF for APAR IZ35785 which solves this problem is available from IBM (April 2009 PTF for XL C/C++ Enterprise Edition for AIX, V9.0).</source>
          <target state="translated">XL C/C++V9を選択した場合、APAR IZ35785がインストールされていないと、統合されたSDBM_Fileが最適化のバグのために正しくコンパイルされません。この問題は、最適化フラグに -qipa を追加することで回避できます (-Doptimize='-O -qipa')。この問題を解決する APAR IZ35785 用の PTF は IBM から入手可能です (April 2009 PTF for XL C/C++Enterprise Edition for AIX,V9.0)。</target>
        </trans-unit>
        <trans-unit id="fb54bcde599a5f03b31c1ac1b1fac745b31dc5b8" translate="yes" xml:space="preserve">
          <source>If you choose for the PTH package, use swinstall to install pth in the default location (/opt/pth), and then make symbolic links to the libraries from /usr/lib</source>
          <target state="translated">PTH パッケージを選択した場合は、swinstall を使ってデフォルトの場所 (/opt/th)に pth をインストールし、/usr/lib からライブラリへのシンボリックリンクを作成します。</target>
        </trans-unit>
        <trans-unit id="5ca7b309ef65dd317303754f8c4a5fd3689e4197" translate="yes" xml:space="preserve">
          <source>If you choose gcc to compile 64-bit Perl then you need to add the following option:</source>
          <target state="translated">64ビットPerlをコンパイルするためにgccを選択した場合は、以下のオプションを追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="043ebe155c68a02fa99782ad455e116e9535a4e8" translate="yes" xml:space="preserve">
          <source>If you chop a list, each element is chopped. Only the value of the last &lt;a href=&quot;#chop-VARIABLE&quot;&gt;&lt;code&gt;chop&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">リストを切り刻むと、各要素が切り刻まれます。最後の&lt;a href=&quot;#chop-VARIABLE&quot;&gt; &lt;code&gt;chop&lt;/code&gt; &lt;/a&gt;値のみが返されます。</target>
        </trans-unit>
        <trans-unit id="875c1fe2de9773e7e9366d0703f2a602deb9c197" translate="yes" xml:space="preserve">
          <source>If you chop a list, each element is chopped. Only the value of the last &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">リストを切り刻むと、各要素が切り刻まれます。最後の &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 値のみが返されます。</target>
        </trans-unit>
        <trans-unit id="03160d33f05c1b78628995f8692e16c5933ebe05" translate="yes" xml:space="preserve">
          <source>If you chop a list, each element is chopped. Only the value of the last &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">リストを切り刻むと、各要素が切り刻まれます。最後の &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 値のみが返されます。</target>
        </trans-unit>
        <trans-unit id="caf1e734b10683713e7d496bb52630f5b34525d0" translate="yes" xml:space="preserve">
          <source>If you compile and run</source>
          <target state="translated">コンパイルして実行すると</target>
        </trans-unit>
        <trans-unit id="4359b9f0177138527f6b61e374c639bb3caf7642" translate="yes" xml:space="preserve">
          <source>If you completely hide the short forms of the Perl public API, add -DPERL_NO_SHORT_NAMES to the compilation flags. This means that for example instead of writing</source>
          <target state="translated">Perl のパブリック API の短縮形を完全に隠す場合は、コンパイルフラグに -DPERL_NO_SHORT_NAMES を追加してください。これは、例えば</target>
        </trans-unit>
        <trans-unit id="2026c5f1b05bc468fd9f9b21ddfe279181855850" translate="yes" xml:space="preserve">
          <source>If you constrain the portion of &lt;code&gt;pv&lt;/code&gt; that is looked at by this function (by passing a non-NULL &lt;code&gt;endptr&lt;/code&gt;), and if the intial bytes of that portion form a valid value, it will return TRUE, setting &lt;code&gt;*endptr&lt;/code&gt; to the byte following the final digit of the value. But if there is no constraint at what's looked at, all of &lt;code&gt;pv&lt;/code&gt; must be valid in order for TRUE to be returned. &lt;code&gt;*endptr&lt;/code&gt; is unchanged from its value on input if FALSE is returned;</source>
          <target state="translated">この関数によって調べられる &lt;code&gt;pv&lt;/code&gt; の部分を（NULL以外の &lt;code&gt;endptr&lt;/code&gt; を渡すことによって）制約し、その部分の最初のバイトが有効な値を形成する場合、TRUEを返し、 &lt;code&gt;*endptr&lt;/code&gt; を次のバイトに設定します。値の最後の桁。ただし、表示内容に制約がない場合、TRUEが返されるには、すべての &lt;code&gt;pv&lt;/code&gt; が有効である必要があります。 &lt;code&gt;*endptr&lt;/code&gt; FALSEが返された場合、endptrは入力時の値から変更されません。</target>
        </trans-unit>
        <trans-unit id="7e117fe20aeb505e6fb3bd26d20ee9983d45c623" translate="yes" xml:space="preserve">
          <source>If you consult &lt;code&gt;perldoc -f &lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; you will see that &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; will behave differently when given a bareword or a string.</source>
          <target state="translated">あなたが相談した場合 &lt;code&gt;perldoc -f &lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; しますが、その表示される &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 裸の単語または文字列が与えられたときに異なる動作をします。</target>
        </trans-unit>
        <trans-unit id="675f3fe6a1b5c4eacc7781347f628b31f87a96c1" translate="yes" xml:space="preserve">
          <source>If you consult &lt;code&gt;perldoc -f require&lt;/code&gt; you will see that &lt;code&gt;require&lt;/code&gt; will behave differently when given a bareword or a string.</source>
          <target state="translated">あなたが相談した場合 &lt;code&gt;perldoc -f require&lt;/code&gt; あなたがいることがわかります &lt;code&gt;require&lt;/code&gt; 裸の単語または文字列が与えられたときに異なる動作をします。</target>
        </trans-unit>
        <trans-unit id="e933e27b4b6affb17bacc2be8545945df23e47f1" translate="yes" xml:space="preserve">
          <source>If you create interpreters in one thread and then proceed to call them in another, you need to make sure perl's own Thread Local Storage (TLS) slot is initialized correctly in each of those threads.</source>
          <target state="translated">あるスレッドでインタプリタを作成し、別のスレッドでそれを呼び出す場合、Perl自身のスレッドローカルストレージ(TLS)スロットがそれぞれのスレッドで正しく初期化されていることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="4e50c2bd9e835a3a7f1961b7856f6dac61424cbe" translate="yes" xml:space="preserve">
          <source>If you decide to ignore this advice and use the GNU versions anyway, then be sure that they are relatively recent. Versions newer than 2.7 are apparently new enough. Older versions may have trouble with dynamic loading.</source>
          <target state="translated">このアドバイスを無視してGNUのバージョンを使うことにした場合、それらが比較的新しいものであることを確認してください。2.7より新しいバージョンは、明らかに十分に新しいものです。古いバージョンは動的な読み込みに問題があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="ff55c7f7dfadd85537843d3b167612c0ffcaee31" translate="yes" xml:space="preserve">
          <source>If you decide to use a different version of the zlib library, you need to be aware of the following issues</source>
          <target state="translated">異なるバージョンの zlib ライブラリを使用する場合は、以下の問題に注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="dea32ebc2834b73dcbf2cbd2fdecffa9453ead2d" translate="yes" xml:space="preserve">
          <source>If you decide to use gcc, make sure your installation is recent and complete, and be sure to read the Perl INSTALL file for more gcc-specific details.</source>
          <target state="translated">gcc を使用することにした場合は、インストールが最新で完全であることを確認し、gcc 固有の詳細については Perl の INSTALL ファイルを必ず読んでください。</target>
        </trans-unit>
        <trans-unit id="275ebe9364d1067d763d9e8ee83a9ef9cef15d89" translate="yes" xml:space="preserve">
          <source>If you decide to use gcc, make sure your installation is recent and complete, and be sure to read the Perl INSTALL file for more gcc-specific details. Please report any hoops you had to jump through to the development team.</source>
          <target state="translated">gcc を使用する場合は、インストールが最新で完全であることを確認し、gcc 固有の詳細については Perl の INSTALL ファイルを必ず読んでください。飛び越えなければならなかったことがあれば、開発チームに報告してください。</target>
        </trans-unit>
        <trans-unit id="129ecc12b1557dd3798539452dbf9b9ea8476c0d" translate="yes" xml:space="preserve">
          <source>If you define an &lt;code&gt;AUTOLOAD&lt;/code&gt; in your class, then Perl will call your &lt;code&gt;AUTOLOAD&lt;/code&gt; to handle the &lt;code&gt;DESTROY&lt;/code&gt; method. You can prevent this by defining an empty &lt;code&gt;DESTROY&lt;/code&gt; , like we did in the autoloading example. You can also check the value of &lt;code&gt;$AUTOLOAD&lt;/code&gt; and return without doing anything when called to handle &lt;code&gt;DESTROY&lt;/code&gt; .</source>
          <target state="translated">クラスで &lt;code&gt;AUTOLOAD&lt;/code&gt; を定義すると、Perlは &lt;code&gt;AUTOLOAD&lt;/code&gt; を呼び出して &lt;code&gt;DESTROY&lt;/code&gt; メソッドを処理します。これを防ぐには、オートローディングの例で行ったように、空の &lt;code&gt;DESTROY&lt;/code&gt; を定義します。 &lt;code&gt;$AUTOLOAD&lt;/code&gt; の値を確認して、 &lt;code&gt;DESTROY&lt;/code&gt; を処理するために呼び出されたときに何もせずに戻ることもできます。</target>
        </trans-unit>
        <trans-unit id="498a8ce676b34793704f21213180e13370975cc0" translate="yes" xml:space="preserve">
          <source>If you define an &lt;code&gt;AUTOLOAD&lt;/code&gt; in your class, then Perl will call your &lt;code&gt;AUTOLOAD&lt;/code&gt; to handle the &lt;code&gt;DESTROY&lt;/code&gt; method. You can prevent this by defining an empty &lt;code&gt;DESTROY&lt;/code&gt;, like we did in the autoloading example. You can also check the value of &lt;code&gt;$AUTOLOAD&lt;/code&gt; and return without doing anything when called to handle &lt;code&gt;DESTROY&lt;/code&gt;.</source>
          <target state="translated">クラスで &lt;code&gt;AUTOLOAD&lt;/code&gt; を定義すると、Perlは &lt;code&gt;AUTOLOAD&lt;/code&gt; を呼び出して &lt;code&gt;DESTROY&lt;/code&gt; メソッドを処理します。自動読み込みの例で行ったように、空の &lt;code&gt;DESTROY&lt;/code&gt; を定義することで、これを防ぐことができます。 &lt;code&gt;$AUTOLOAD&lt;/code&gt; の値を確認し、 &lt;code&gt;DESTROY&lt;/code&gt; を処理するために呼び出されたときに何もせずに戻ることもできます。</target>
        </trans-unit>
        <trans-unit id="94eb8ac68c4fb558c46d1ee64b3833ca570000ed" translate="yes" xml:space="preserve">
          <source>If you define more than one name for the code point, it is indeterminate which one will be returned.</source>
          <target state="translated">コードポイントに複数の名前を定義した場合、どの名前が返されるかは不確定です。</target>
        </trans-unit>
        <trans-unit id="49322aadfdd4f7ccdbc478f7d31a6ef35c74c780" translate="yes" xml:space="preserve">
          <source>If you desire complete control over SSL connections, the &lt;code&gt;SSL_options&lt;/code&gt; attribute lets you provide a hash reference that will be passed through to &lt;code&gt;IO::Socket::SSL::start_SSL()&lt;/code&gt;, overriding any options set by HTTP::Tiny. For example, to provide your own trusted CA file:</source>
          <target state="translated">SSL接続を完全に制御したい場合は、 &lt;code&gt;SSL_options&lt;/code&gt; 属性を使用して、 &lt;code&gt;IO::Socket::SSL::start_SSL()&lt;/code&gt; に渡されるハッシュ参照を提供し、HTTP :: Tinyで設定されたオプションをオーバーライドできます。たとえば、独自の信頼できるCAファイルを提供するには：</target>
        </trans-unit>
        <trans-unit id="04b2ed76508ea6501a561cd368f25fd856dfc7e2" translate="yes" xml:space="preserve">
          <source>If you develop any useful expiration managers that you think should be distributed with Memoize, please let me know.</source>
          <target state="translated">Memoizeで配布すべきだと思う便利な賞味期限管理ツールを開発したら、ぜひ教えてください。</target>
        </trans-unit>
        <trans-unit id="2101fa1f88298b0b195dfaac7732fd2635cea835" translate="yes" xml:space="preserve">
          <source>If you didn't mean to use a Unicode property, escape the &lt;code&gt;\p&lt;/code&gt;, either by &lt;code&gt;\\p&lt;/code&gt; (just the &lt;code&gt;\p&lt;/code&gt;) or by &lt;code&gt;\Q\p&lt;/code&gt; (the rest of the string, or until &lt;code&gt;\E&lt;/code&gt;).</source>
          <target state="translated">Unicodeプロパティを使用するつもりがなかった場合は、 &lt;code&gt;\\p&lt;/code&gt; （ &lt;code&gt;\p&lt;/code&gt; ）または &lt;code&gt;\Q\p&lt;/code&gt; （文字列の残りの部分、または &lt;code&gt;\E&lt;/code&gt; まで）のいずれかで &lt;code&gt;\p&lt;/code&gt; エスケープします。</target>
        </trans-unit>
        <trans-unit id="0cf4a8657eebfe97ba9c4e743bd983d09e5edaa6" translate="yes" xml:space="preserve">
          <source>If you didn't use &lt;code&gt;openlog()&lt;/code&gt; before using &lt;code&gt;syslog()&lt;/code&gt; , &lt;code&gt;syslog()&lt;/code&gt; will try to guess the &lt;code&gt;$ident&lt;/code&gt; by extracting the shortest prefix of &lt;code&gt;$format&lt;/code&gt; that ends in a &lt;code&gt;&quot;:&quot;&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;syslog()&lt;/code&gt; を使用する前に &lt;code&gt;openlog()&lt;/code&gt; を使用しなかった場合、 &lt;code&gt;syslog()&lt;/code&gt; は、 &lt;code&gt;&quot;:&quot;&lt;/code&gt; で終わる &lt;code&gt;$format&lt;/code&gt; 最も短い接頭辞を抽出することにより、 &lt;code&gt;$ident&lt;/code&gt; を推測しようとします。</target>
        </trans-unit>
        <trans-unit id="c2758eb43b68115ce83395ea254e99fa90136500" translate="yes" xml:space="preserve">
          <source>If you didn't use &lt;code&gt;openlog()&lt;/code&gt; before using &lt;code&gt;syslog()&lt;/code&gt;, &lt;code&gt;syslog()&lt;/code&gt; will try to guess the &lt;code&gt;$ident&lt;/code&gt; by extracting the shortest prefix of &lt;code&gt;$format&lt;/code&gt; that ends in a &lt;code&gt;&quot;:&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;syslog()&lt;/code&gt; を使用する前に &lt;code&gt;openlog()&lt;/code&gt; を使用しなかった場合、 &lt;code&gt;syslog()&lt;/code&gt; は、 &lt;code&gt;&quot;:&quot;&lt;/code&gt; で終わる &lt;code&gt;$format&lt;/code&gt; 最短プレフィックスを抽出して &lt;code&gt;$ident&lt;/code&gt; を推測しようとします。</target>
        </trans-unit>
        <trans-unit id="06ed1961687b0abd10e165d61c48cda9ac3ae785" translate="yes" xml:space="preserve">
          <source>If you discover some glitches, move directories of problematic modules to a different location; if these modules are non-XS modules, you may just ignore them - they are already installed; the remaining, XS, modules you need to install manually one by one.</source>
          <target state="translated">不具合を発見した場合は、問題のあるモジュールのディレクトリを別の場所に移動してください。</target>
        </trans-unit>
        <trans-unit id="43d56dedc7192e637755e1fdcd48fbf68cbff70a" translate="yes" xml:space="preserve">
          <source>If you do</source>
          <target state="translated">もし、あなたが</target>
        </trans-unit>
        <trans-unit id="cb8667358646593d3b3e540e94dd3bddc5a68445" translate="yes" xml:space="preserve">
          <source>If you do need to sort non-alphabetically for whatever reasons, you can give a code reference (or a subroutine name) to &lt;code&gt;sort_by&lt;/code&gt;, then the argument will be passed to Perl's &lt;code&gt;sort&lt;/code&gt; built-in function.</source>
          <target state="translated">なんらかの理由でアルファベット順以外で並べ替える必要がある場合は、 &lt;code&gt;sort_by&lt;/code&gt; にコード参照（またはサブルーチン名）を指定すると、引数がPerlの &lt;code&gt;sort&lt;/code&gt; 組み込み関数に渡されます。</target>
        </trans-unit>
        <trans-unit id="f303cdfeba4ec1c04b3ea76ad07c019d7ba1217e" translate="yes" xml:space="preserve">
          <source>If you do not do this, then tools you call that also check for a context will notice that the context they grabbed was created at the same stack depth, which will trigger protective measures that warn you and destroy the existing context.</source>
          <target state="translated">これを行わないと、コンテキストのチェックも行う呼び出したツールは、取得したコンテキストが同じスタック深度で作成されたことに気付き、警告を発して既存のコンテキストを破壊する保護手段を発動します。</target>
        </trans-unit>
        <trans-unit id="87ef7e6c621828b29eab79e96b5fb6269cd00a77" translate="yes" xml:space="preserve">
          <source>If you do not enter the shell, shell commands are available both as methods (&lt;code&gt;CPAN::Shell-&amp;gt;install(...)&lt;/code&gt; ) and as functions in the calling package (&lt;code&gt;install(...)&lt;/code&gt; ). Before calling low-level commands, it makes sense to initialize components of CPAN you need, e.g.:</source>
          <target state="translated">シェルを入力しない場合、シェルコマンドはメソッド（ &lt;code&gt;CPAN::Shell-&amp;gt;install(...)&lt;/code&gt; ）と呼び出し元パッケージの関数（ &lt;code&gt;install(...)&lt;/code&gt; ）の両方として使用できます。低レベルのコマンドを呼び出す前に、必要なCPANのコンポーネントを初期化することは意味があります。例：</target>
        </trans-unit>
        <trans-unit id="bc816a9fd08d7a00464780adbf72cc89737d7fde" translate="yes" xml:space="preserve">
          <source>If you do not have</source>
          <target state="translated">を持っていない場合は</target>
        </trans-unit>
        <trans-unit id="69ced298dbf1c87fefd1662253cccc2e7a8bde7d" translate="yes" xml:space="preserve">
          <source>If you do not have a copy of the GNU General Public License write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</source>
          <target state="translated">GNU一般公衆利用許諾書のコピーをお持ちでない場合は、Free Software Foundation,Inc,675 Mass Ave,Cambridge,MA 02139,USAまでご連絡ください。</target>
        </trans-unit>
        <trans-unit id="ca85e836f91816edbc4e15e9107effedf45973f0" translate="yes" xml:space="preserve">
          <source>If you do not have that module, you can do the same thing with &lt;a href=&quot;File::Find&quot;&gt;File::Find&lt;/a&gt; which is part of the standard library:</source>
          <target state="translated">そのモジュールがない場合は、標準ライブラリの一部である&lt;a href=&quot;File::Find&quot;&gt;File :: Find&lt;/a&gt;を使用して同じことを行うことができます。</target>
        </trans-unit>
        <trans-unit id="f9c124bac0783d0b5dcccc34a0dbf3566f426f11" translate="yes" xml:space="preserve">
          <source>If you do not have that module, you can do the same thing with &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt; which is part of the standard library:</source>
          <target state="translated">そのモジュールがない場合は、標準ライブラリの一部である&lt;a href=&quot;file/find&quot;&gt;File :: Find&lt;/a&gt;を使用して同じことを実行できます。</target>
        </trans-unit>
        <trans-unit id="05c2496743b48fe9b410f73d7328bfcdc228baa8" translate="yes" xml:space="preserve">
          <source>If you do not have the SDK installed you must at least have abc-shell installed or some other suitable sh port. This is required to run external commands and should be available as 'sh' in your path.</source>
          <target state="translated">SDK がインストールされていない場合は、少なくとも abc-shell がインストールされているか、他の適切な sh ポートが必要です。これは外部コマンドを実行するために必要なもので、パス内の'sh'として利用できるようになっている必要があります。</target>
        </trans-unit>
        <trans-unit id="bd07d5a5c26be6eca98f51764342db5783f35fa8" translate="yes" xml:space="preserve">
          <source>If you do not know what shell you have, consult your local helpdesk or the equivalent.</source>
          <target state="translated">お使いのシェルがわからない場合は、お近くのヘルプデスクに相談するか、それに相当するものをご利用ください。</target>
        </trans-unit>
        <trans-unit id="7e4c6cc6957c31110bb18e19744ff8957469df93" translate="yes" xml:space="preserve">
          <source>If you do not override this then the default implementation will attempt to generate facets from the legacy API. This generation is limited only to what the legacy API can provide. It is recommended that you override this method and write out explicit facet data.</source>
          <target state="translated">これをオーバーライドしない場合、デフォルトの実装はレガシー API からのファセットの生成を試みます。この生成は、レガシー API が提供できるものに限定されます。このメソッドをオーバーライドして、明示的な切子データを書き出すことを推奨します。</target>
        </trans-unit>
        <trans-unit id="1de6e3279f2bd155e7f8bf6759e637927cce20be" translate="yes" xml:space="preserve">
          <source>If you do not set this flag then it is</source>
          <target state="translated">このフラグを設定しない場合は</target>
        </trans-unit>
        <trans-unit id="926a166805dd3b0aef3dd1d472d192955fb1ec52" translate="yes" xml:space="preserve">
          <source>If you do not specify a package name, the variable is created in the current package.</source>
          <target state="translated">パッケージ名を指定しない場合、変数は現在のパッケージに作成されます。</target>
        </trans-unit>
        <trans-unit id="eb887a9c7d54012c86e6e1c5e9df47c38a1fd9a7" translate="yes" xml:space="preserve">
          <source>If you do not want to actually create a full blown version object, but would still like to verify that a given string meets the criteria to be parsed as a version, there are two helper functions that can be employed directly:</source>
          <target state="translated">完全なバージョンオブジェクトを実際に作成するのではなく、与えられた文字列がバージョンとして解析される基準を満たしているかどうかを検証したい場合は、直接使用できるヘルパー関数が2つあります。</target>
        </trans-unit>
        <trans-unit id="5ec84ed1a6f6d8da6377929662414a47b27976a2" translate="yes" xml:space="preserve">
          <source>If you do not want to call the package's &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method (for instance, to stop your namespace from being altered), explicitly supply the empty list:</source>
          <target state="translated">パッケージの&lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;メソッドを呼び出さない場合（たとえば、名前空間が変更されないようにするため）、空のリストを明示的に指定します。</target>
        </trans-unit>
        <trans-unit id="3b6ac2382b8b465b26d1901487c44646a3e50e04" translate="yes" xml:space="preserve">
          <source>If you do not want to call the package's &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method (for instance, to stop your namespace from being altered), explicitly supply the empty list:</source>
          <target state="translated">パッケージの &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; メソッドを呼び出さない場合（たとえば、名前空間の変更を停止する場合）、空のリストを明示的に指定します。</target>
        </trans-unit>
        <trans-unit id="ea10c1ff3a243c28f284c149e22c1d185c65b318" translate="yes" xml:space="preserve">
          <source>If you do not want to call the package's &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method (for instance, to stop your namespace from being altered), explicitly supply the empty list:</source>
          <target state="translated">パッケージの &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; メソッドを呼び出さない場合（たとえば、名前空間の変更を停止する場合）、空のリストを明示的に指定します。</target>
        </trans-unit>
        <trans-unit id="8470234c0d68b289fd8da0f074a387fae1ae490f" translate="yes" xml:space="preserve">
          <source>If you do not want to use these defaults they can be overridden by explicitly setting the &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;TextFlag&lt;/code&gt; , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; and &lt;code&gt;exTime&lt;/code&gt; options or by setting the &lt;code&gt;Minimal&lt;/code&gt; parameter.</source>
          <target state="translated">これらのデフォルトを使用したくない場合は、 &lt;code&gt;Name&lt;/code&gt; 、 &lt;code&gt;Time&lt;/code&gt; 、 &lt;code&gt;TextFlag&lt;/code&gt; 、 &lt;code&gt;ExtAttr&lt;/code&gt; 、 &lt;code&gt;exUnixN&lt;/code&gt; および &lt;code&gt;exTime&lt;/code&gt; オプションを明示的に設定するか、または &lt;code&gt;Minimal&lt;/code&gt; パラメーターを設定することにより、これらをオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="f15a287c32e6f66173e359fbddfbe362d18b693a" translate="yes" xml:space="preserve">
          <source>If you do not want to use these defaults they can be overridden by explicitly setting the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Time&lt;/code&gt; options or by setting the &lt;code&gt;Minimal&lt;/code&gt; parameter.</source>
          <target state="translated">これらのデフォルトを使用したくない場合は、[ &lt;code&gt;Name&lt;/code&gt; および[ &lt;code&gt;Time&lt;/code&gt; オプションを明示的に設定するか、[ &lt;code&gt;Minimal&lt;/code&gt; パラメーターを設定することで、これらを上書きできます。</target>
        </trans-unit>
        <trans-unit id="de7aec51016dff43e0ecf45d764d0cccf666e711" translate="yes" xml:space="preserve">
          <source>If you do not want to use these defaults they can be overridden by explicitly setting the &lt;code&gt;Name&lt;/code&gt;, &lt;code&gt;Time&lt;/code&gt;, &lt;code&gt;TextFlag&lt;/code&gt;, &lt;code&gt;ExtAttr&lt;/code&gt;, &lt;code&gt;exUnixN&lt;/code&gt; and &lt;code&gt;exTime&lt;/code&gt; options or by setting the &lt;code&gt;Minimal&lt;/code&gt; parameter.</source>
          <target state="translated">これらのデフォルトを使用したくない場合は、 &lt;code&gt;Name&lt;/code&gt; 、 &lt;code&gt;Time&lt;/code&gt; 、 &lt;code&gt;TextFlag&lt;/code&gt; 、 &lt;code&gt;ExtAttr&lt;/code&gt; 、 &lt;code&gt;exUnixN&lt;/code&gt; 、および &lt;code&gt;exTime&lt;/code&gt; オプションを明示的に設定するか、 &lt;code&gt;Minimal&lt;/code&gt; パラメーターを設定することでオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="c647e4788bb29e5dcf3d258b1e0dc34c9ef54f62" translate="yes" xml:space="preserve">
          <source>If you do not wish this to happen, you should provide an array reference, where all parts of your command are already separated out. Note however, if there are extra or spurious whitespaces in these parts, the parser or underlying code may not interpret it correctly, and cause an error.</source>
          <target state="translated">これを望まない場合は、コマンドのすべての部分が既に分離されている配列参照を提供する必要があります。しかし、これらの部分に余分な空白やスプリアスな空白があると、パーサや基礎となるコードがそれを正しく解釈できず、エラーが発生する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="459db29c5c8a7302439a70851525c81616dcc865" translate="yes" xml:space="preserve">
          <source>If you do not wish to install the &lt;a href=&quot;Module::Starter&quot;&gt;Module::Starter&lt;/a&gt; package from CPAN,</source>
          <target state="translated">CPANから&lt;a href=&quot;Module::Starter&quot;&gt;Module :: Starter&lt;/a&gt;パッケージをインストールしたくない場合は、</target>
        </trans-unit>
        <trans-unit id="1f09ee5e6b9af0c82c4326addc62e789f8443f5c" translate="yes" xml:space="preserve">
          <source>If you do not wish to install the &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Starter&quot;&gt;Module::Starter&lt;/a&gt; package from CPAN,</source>
          <target state="translated">CPANから&lt;a href=&quot;http://search.cpan.org/perldoc/Module::Starter&quot;&gt;Module :: Starter&lt;/a&gt;パッケージをインストールしたくない場合は、</target>
        </trans-unit>
        <trans-unit id="484cd976813c85d85881ff70f66c34600b720c15" translate="yes" xml:space="preserve">
          <source>If you do set &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; to 0, you may notice an improvement in speed at the risk of not recursing into subdirectories if a filesystem doesn't populate &lt;code&gt;nlink&lt;/code&gt; as expected.</source>
          <target state="translated">あなたがセットした場合は &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; 0に、あなたはファイルシステムが移入されません場合は、サブディレクトリへの再帰ないリスクでの速度の改善に気づくことがあり &lt;code&gt;nlink&lt;/code&gt; 予想通りに。</target>
        </trans-unit>
        <trans-unit id="0549310bae0dd74950be604da632c91876f7d8c0" translate="yes" xml:space="preserve">
          <source>If you do set &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; to 1, you will notice slow-downs.</source>
          <target state="translated">あなたがセットした場合は &lt;code&gt;$File::Find::dont_use_nlink&lt;/code&gt; 1に、あなたはスローダウンに気付くでしょう。</target>
        </trans-unit>
        <trans-unit id="feef0b7ae2868ad2a4e1f83d30c63fb0d93e6be4" translate="yes" xml:space="preserve">
          <source>If you do this in a binary operator, you will actually change one of the strings that came into the operator, and, while it shouldn't be noticeable by the end user, it can cause problems in deficient code.</source>
          <target state="translated">バイナリ演算子でこれを行うと、実際には演算子に入ってきた文字列のいずれかを変更することになり、エンドユーザには気づかれないはずですが、欠陥のあるコードで問題を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="32f0578310d415019b09f619288e373d3b705f8d" translate="yes" xml:space="preserve">
          <source>If you do want this subroutine to be a closure that reflects future changes to the variable that it closes over, add an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">このサブルーチンを、クローズする変数に対する将来の変更を反映するクロージャにしたい場合は、明示的な &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="38c006c4445fbc760bcc20774ff0c404fc351e3b" translate="yes" xml:space="preserve">
          <source>If you do want this subroutine to be a closure that reflects future changes to the variable that it closes over, add an explicit &lt;code&gt;return&lt;/code&gt;:</source>
          <target state="translated">このサブルーチンを、それが閉じる変数への将来の変更を反映するクロージャにしたい場合は、明示的な &lt;code&gt;return&lt;/code&gt; 追加します。</target>
        </trans-unit>
        <trans-unit id="7553259d39face4afb80ca316b04630713e25671" translate="yes" xml:space="preserve">
          <source>If you do want to work with large integers like under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; , try &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint;&lt;/code&gt; :</source>
          <target state="translated">あなたは下のような大きな整数で動作するようにしたいならば &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用して&lt;/a&gt;みてください。：</target>
        </trans-unit>
        <trans-unit id="b1975a786e24a8553b122ca84ecd2c75458bf60c" translate="yes" xml:space="preserve">
          <source>If you do want to work with large integers like under &lt;code&gt;use integer;&lt;/code&gt;, try &lt;code&gt;use bigint;&lt;/code&gt;:</source>
          <target state="translated">under &lt;code&gt;use integer;&lt;/code&gt; ように大きな整数を処理したい場合は、、 &lt;code&gt;use bigint;&lt;/code&gt; みてください。：</target>
        </trans-unit>
        <trans-unit id="226407ccd685c51b95b1d8b7151f227bb1d0575c" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to be included in the AUTHORS file, just let us know. Otherwise we will take your submission of a patch as permission to credit you in the AUTHORS file.</source>
          <target state="translated">AUTHORSファイルに含めたくない場合は、お知らせください。それ以外の場合は、パッチの送信をAUTHORSファイルにクレジットする許可として受け取ります。</target>
        </trans-unit>
        <trans-unit id="a338314884729930813df6e4dec44b70118fce2d" translate="yes" xml:space="preserve">
          <source>If you don't ask for any feature, you get the list of features that the user requested you to be nice to. This has the nice side effect that if you don't respect anything in particular then you can just ask for it and use it like a boolean.</source>
          <target state="translated">何も機能を要求しない場合は、ユーザーがあなたに親切にしてほしいと要求した機能のリストを取得します。これは、特に何かを尊重しない場合は、それを要求してブーリアンのように使うことができるという良い副作用があります。</target>
        </trans-unit>
        <trans-unit id="d5b6d156d7cf6f2a797778536a48c223724f9360" translate="yes" xml:space="preserve">
          <source>If you don't care about the order of the elements, you could just create the hash then extract the keys. It's not important how you create that hash: just that you use &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; to get the unique elements.</source>
          <target state="translated">要素の順序を気にしない場合は、ハッシュを作成してからキーを抽出できます。そのハッシュの作成方法は重要ではありません。 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; を使用して一意の要素を取得するだけです。</target>
        </trans-unit>
        <trans-unit id="6ab466d2383fda10b330c50a2b963d3911043a02" translate="yes" xml:space="preserve">
          <source>If you don't care about the order of the elements, you could just create the hash then extract the keys. It's not important how you create that hash: just that you use &lt;code&gt;keys&lt;/code&gt; to get the unique elements.</source>
          <target state="translated">要素の順序を気にしない場合は、ハッシュを作成してからキーを抽出するだけです。そのハッシュをどのように作成するかは重要ではありません。 &lt;code&gt;keys&lt;/code&gt; を使用して一意の要素を取得するだけです。</target>
        </trans-unit>
        <trans-unit id="e21625178e6b6545fac5abe6f5027d91ef293d91" translate="yes" xml:space="preserve">
          <source>If you don't care about where digits and underscore sort to, you can do something like this</source>
          <target state="translated">数字やアンダースコアのソート先を気にしない場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="f92e493c5048826b06ef70fc4669cac080dfe915" translate="yes" xml:space="preserve">
          <source>If you don't care that one hash overwrites keys and values from the other, you could just use a hash slice to add one hash to another. In this case, values from &lt;code&gt;%hash2&lt;/code&gt; replace values from &lt;code&gt;%hash1&lt;/code&gt; when they have keys in common:</source>
          <target state="translated">1つのハッシュが他のハッシュからキーと値を上書きすることを気にしない場合は、ハッシュスライスを使用して1つのハッシュを別のハッシュに追加できます。この場合は、からの値 &lt;code&gt;%hash2&lt;/code&gt; から値を置き換える &lt;code&gt;%hash1&lt;/code&gt; 彼らは共通のキーを持っている場合：</target>
        </trans-unit>
        <trans-unit id="c43d001ee345c63043409156142b64f915867634" translate="yes" xml:space="preserve">
          <source>If you don't get a paragraph or two of expanded discussion, it might not be perl's message.</source>
          <target state="translated">一段落か二段落の拡張議論が出てこないと、perlのメッセージではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="7a12cb113cb2e2457200764dfd73d419fb8973d7" translate="yes" xml:space="preserve">
          <source>If you don't have File::Stream, you have to do a little more work.</source>
          <target state="translated">File::Streamを持っていない場合は、もう少し手を加えなければなりません。</target>
        </trans-unit>
        <trans-unit id="ea4a8fbdbdee9b250414a6cc40a6c3e590cef92d" translate="yes" xml:space="preserve">
          <source>If you don't have data written with specific configuration of perl described above, then you do not and should not do anything. Don't set the flag - not only will Storable on an identically configured perl refuse to load them, but Storable a differently configured perl will load them believing them to be correct for it, and then may well fail or crash part way through reading them.</source>
          <target state="translated">上記のperlの特定の設定で書かれたデータを持っていない場合は、何もしないし、何もすべきではありません。フラグを設定しないでください-同じ設定のPerl上のStorableはデータの読み込みを拒否するだけでなく、異なる設定のPerl上のStorableはそれが正しいと信じてデータを読み込み、読み込み途中で失敗したり、クラッシュしたりする可能性があります。</target>
        </trans-unit>
        <trans-unit id="670ababa1b4eae15ad2ad8b23b062bc17283021f" translate="yes" xml:space="preserve">
          <source>If you don't have the safe version of set-id scripts, all is not lost. Sometimes this kernel &quot;feature&quot; can be disabled, so that the kernel either doesn't run set-id scripts with the set-id or doesn't run them at all. Either way avoids the exploitability of the race condition, but doesn't help in actually running scripts set-id.</source>
          <target state="translated">set-id スクリプトの安全なバージョンを持っていなくても、すべてが失われるわけではありません。時には、このカーネルの「機能」を無効にすることができ、カーネルが set-id で set-id スクリプトを実行しないか、全く実行しないようにすることができます。どちらの方法でも、競合状態の悪用は回避できますが、実際に set-id スクリプトを実行する際には役に立ちません。</target>
        </trans-unit>
        <trans-unit id="f34e9607e58d64a63d5aabb3955bab5ec740de09" translate="yes" xml:space="preserve">
          <source>If you don't have write access to the DBM file, you can only read hash variables, not set them. If you want to test whether you can write, either use file tests or try setting a dummy hash entry inside an &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; to trap the error.</source>
          <target state="translated">DBMファイルへの書き込みアクセス権がない場合は、ハッシュ変数の読み取りのみが可能であり、設定はできません。書き込み可能かどうかをテストする場合は、ファイルテストを使用するか、&lt;a href=&quot;#eval-EXPR&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;内にダミーのハッシュエントリを設定してエラーをトラップしてみてください。</target>
        </trans-unit>
        <trans-unit id="36289d77701a121889713d6277f544f12a871bb4" translate="yes" xml:space="preserve">
          <source>If you don't have write access to the DBM file, you can only read hash variables, not set them. If you want to test whether you can write, either use file tests or try setting a dummy hash entry inside an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; to trap the error.</source>
          <target state="translated">DBMファイルへの書き込みアクセス権がない場合、ハッシュ変数の読み取りのみが可能で、設定はできません。書き込み可能かどうかをテストする場合は、ファイルテストを使用するか、 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 内にダミーハッシュエントリを設定してエラーをトラップしてみてください。</target>
        </trans-unit>
        <trans-unit id="bdbbd37031df2f33535ed6549b499d32ea9aa9e5" translate="yes" xml:space="preserve">
          <source>If you don't have write access to the DBM file, you can only read hash variables, not set them. If you want to test whether you can write, either use file tests or try setting a dummy hash entry inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; to trap the error.</source>
          <target state="translated">DBMファイルへの書き込みアクセス権がない場合、ハッシュ変数の読み取りのみが可能で、設定はできません。書き込み可能かどうかをテストする場合は、ファイルテストを使用するか、 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 内にダミーハッシュエントリを設定してエラーをトラップしてみてください。</target>
        </trans-unit>
        <trans-unit id="8f4b767528b9f98c2858aad05fc8520eae2c1d33" translate="yes" xml:space="preserve">
          <source>If you don't import any of these functions, assume a &lt;code&gt;&amp;amp;I18N::LangTags::&lt;/code&gt; in front of all the function names in the following examples.</source>
          <target state="translated">これらの関数をインポートしない場合は、次の例のすべての関数名の前に &lt;code&gt;&amp;amp;I18N::LangTags::&lt;/code&gt; があると想定します。</target>
        </trans-unit>
        <trans-unit id="107952179f7076da25aad77d14c209ced7df48df" translate="yes" xml:space="preserve">
          <source>If you don't know how many tests you're going to run, you can issue the plan when you're done running tests.</source>
          <target state="translated">どれだけのテストを実行するかわからない場合は、テストを実行し終わった時点でプランを発行することができます。</target>
        </trans-unit>
        <trans-unit id="739739cb456280bdf258e73ad5d6021f89fcc54e" translate="yes" xml:space="preserve">
          <source>If you don't know if a string contains YAML or JSON, this method will use &lt;a href=&quot;Parse::CPAN::Meta&quot;&gt;Parse::CPAN::Meta&lt;/a&gt; to guess. In other respects it is identical to &lt;code&gt;load_file()&lt;/code&gt;.</source>
          <target state="translated">文字列にYAMLとJSONのどちらが含まれているかわからない場合、このメソッドは&lt;a href=&quot;Parse::CPAN::Meta&quot;&gt;Parse :: CPAN :: Meta&lt;/a&gt;を使用して推測します。その他の点では、 &lt;code&gt;load_file()&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="209c65929fc8bcea028a0c96cf1f684c89334602" translate="yes" xml:space="preserve">
          <source>If you don't know what license to use, dual licensing under the GPL and Artistic licenses (the same as Perl itself) is a good idea. See &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt; and &lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartistic&lt;/a&gt;.</source>
          <target state="translated">使用するライセンスがわからない場合は、GPLライセンスとArtisticライセンス（Perl自体と同じ）でのデュアルライセンスをお勧めします。&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlgpl.html&quot;&gt;perlgpl&lt;/a&gt;および&lt;a href=&quot;https://perldoc.perl.org/5.26.0/perlartistic.html&quot;&gt;perlartisticを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ed23e5a70f4d9c445aa4d9a13f1bd7f582002fa9" translate="yes" xml:space="preserve">
          <source>If you don't know what license to use, dual licensing under the GPL and Artistic licenses (the same as Perl itself) is a good idea. See &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlgpl&quot;&gt;perlgpl&lt;/a&gt; and &lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlartistic&quot;&gt;perlartistic&lt;/a&gt;.</source>
          <target state="translated">使用するライセンスがわからない場合は、GPLライセンスとArtisticライセンス（Perl自体と同じ）でのデュアルライセンスをお勧めします。&lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlgpl&quot;&gt;perlgpl&lt;/a&gt;および&lt;a href=&quot;https://perldoc.perl.org/5.32.0/perlartistic&quot;&gt;perlartisticを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0afa056a783c1ff17e6396cee6d067cb1e22c33a" translate="yes" xml:space="preserve">
          <source>If you don't know whether a string contains YAML or JSON data, this method will use some heuristics and guess. If it can't tell, it assumes YAML.</source>
          <target state="translated">文字列にYAMLかJSONデータが含まれているかわからない場合、このメソッドはいくつかのヒューリスティックを使って推測します。もしわからない場合はYAMLだと仮定します。</target>
        </trans-unit>
        <trans-unit id="d34593d2a30bd46dc846ad60717c333d071ef181" translate="yes" xml:space="preserve">
          <source>If you don't mind shelling out, the &lt;code&gt;wc&lt;/code&gt; command is usually the fastest, even with the extra interprocess overhead. Ensure that you have an untainted filename though:</source>
          <target state="translated">シェルアウトを気にしない場合は、プロセス間オーバーヘッドが余分にある場合でも、通常は &lt;code&gt;wc&lt;/code&gt; コマンドが最速です。ただし、汚染されていないファイル名があることを確認してください。</target>
        </trans-unit>
        <trans-unit id="ab42639abd5abd9367c12d1d0ad1d1482fb0d4b6" translate="yes" xml:space="preserve">
          <source>If you don't need the existing content of the SV, you can avoid some copying with:</source>
          <target state="translated">既存のSVの内容が不要な場合は、SVで多少のコピーは避けられます。</target>
        </trans-unit>
        <trans-unit id="bd9e10a2452b68c075fcb32cabd703d0209267ed" translate="yes" xml:space="preserve">
          <source>If you don't need to know the name of the file, you can use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in place of the file name. In Perl 5.8 or later, the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; function creates an anonymous temporary file:</source>
          <target state="translated">ファイルの名前を知る必要がない場合は、ファイル名の代わりに &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を指定して &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; を使用できます。Perl 5.8以降では、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 関数は匿名の一時ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="22928fef3e84c8263a53f0cfc23f1b5d448491ff" translate="yes" xml:space="preserve">
          <source>If you don't need to know the name of the file, you can use &lt;code&gt;open()&lt;/code&gt; with &lt;code&gt;undef&lt;/code&gt; in place of the file name. In Perl 5.8 or later, the &lt;code&gt;open()&lt;/code&gt; function creates an anonymous temporary file:</source>
          <target state="translated">ファイルの名前を知る必要がない場合は、ファイル名の代わりに &lt;code&gt;undef&lt;/code&gt; を指定して &lt;code&gt;open()&lt;/code&gt; を使用できます。Perl 5.8以降では、 &lt;code&gt;open()&lt;/code&gt; 関数は匿名の一時ファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="b260604ab4c441d85ae092e22c063810eb4d30c0" translate="yes" xml:space="preserve">
          <source>If you don't provide an exact inverse transformation, you will find that code like this will not behave as you expect.</source>
          <target state="translated">厳密な逆変換を提供しないと、このようなコードは期待通りに動作しないことがわかります。</target>
        </trans-unit>
        <trans-unit id="da9f240e2e4669201b3520ed7f3f5a0edd014292" translate="yes" xml:space="preserve">
          <source>If you don't really want to execute the first argument, but want to lie to the program you are executing about its own name, you can specify the program you actually want to run as an &quot;indirect object&quot; (without a comma) in front of the LIST, as in &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; . (This always forces interpretation of the LIST as a multivalued list, even if there is only a single scalar in the list.) Example:</source>
          <target state="translated">本当に最初の引数を実行したくないが、実行しているプログラムにそれ自身の名前について嘘をつきたい場合は、実際に実行したいプログラムを「間接オブジェクト」（コンマなし）として指定できます。 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; の場合と同様に、リストの前。（これにより、リストに単一のスカラーしかない場合でも、リストは常に複数値リストとして解釈されます。）例：</target>
        </trans-unit>
        <trans-unit id="90475a6e4998e8131a7d71a411d5204a133b0a81" translate="yes" xml:space="preserve">
          <source>If you don't really want to execute the first argument, but want to lie to the program you are executing about its own name, you can specify the program you actually want to run as an &quot;indirect object&quot; (without a comma) in front of the LIST, as in &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; . (This always forces interpretation of the LIST as a multivalued list, even if there is only a single scalar in the list.) Example:</source>
          <target state="translated">本当に最初の引数を実行したくないが、実行しているプログラムにそれ自身の名前について嘘をつきたい場合は、実際に実行したいプログラムを「間接オブジェクト」（コンマなし）として指定できます。 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; の場合と同様に、リストの前。（これにより、リストに単一のスカラーしかない場合でも、リストは常に複数値リストとして解釈されます。）例：</target>
        </trans-unit>
        <trans-unit id="418ff649fbe756afaa4bfbbd2264a36cfbe884b8" translate="yes" xml:space="preserve">
          <source>If you don't really want to execute the first argument, but want to lie to the program you are executing about its own name, you can specify the program you actually want to run as an &quot;indirect object&quot; (without a comma) in front of the LIST, as in &lt;code&gt;exec PROGRAM LIST&lt;/code&gt;. (This always forces interpretation of the LIST as a multivalued list, even if there is only a single scalar in the list.) Example:</source>
          <target state="translated">最初の引数を実際には実行したくないが、実行しているプログラムに自分の名前について嘘をつきたい場合は、実際に実行したいプログラムを「間接オブジェクト」（コンマなし）として指定できます。 &lt;code&gt;exec PROGRAM LIST&lt;/code&gt; のように、LISTの前。（これにより、リストにスカラーが1つしかない場合でも、常にLISTが複数値のリストとして解釈されます。）例：</target>
        </trans-unit>
        <trans-unit id="24b9da8187ce4c2f915ec1ca4c659113a1fb93a3" translate="yes" xml:space="preserve">
          <source>If you don't run the full test suite, at least &lt;code&gt;make test_porting&lt;/code&gt;. This will run basic sanity checks. To see which sanity checks, have a look in</source>
          <target state="translated">完全なテストスイートを実行しない場合は、少なくとも &lt;code&gt;make test_porting&lt;/code&gt; 。これにより、基本的な健全性チェックが実行されます。どの健全性チェックを確認するには、以下をご覧ください</target>
        </trans-unit>
        <trans-unit id="1d09c87ff03423122d55e0fe04c7fdafafae320f" translate="yes" xml:space="preserve">
          <source>If you don't see an error message, you have the module. (If you do see an error message, it's still possible you have the module, but that it's not in your path, which you can display with &lt;code&gt;perl -e
&quot;print qq(@INC)&quot;&lt;/code&gt; .) For the remainder of this document, we'll assume that you really honestly truly lack an installed module, but have found it on the CPAN.</source>
          <target state="translated">エラーメッセージが表示されない場合は、モジュールがあります。（エラーメッセージが表示される場合でも、モジュールがある可能性はありますが、モジュールがパスにないため、 &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt; 表示できます。）このドキュメントの残りの部分では、インストールされているモジュールが本当に正直に不足していると想定しますが、CPANでそれを見つけました。</target>
        </trans-unit>
        <trans-unit id="eb0d75079c24e83da6fecb7132e9b60520bba455" translate="yes" xml:space="preserve">
          <source>If you don't see an error message, you have the module. (If you do see an error message, it's still possible you have the module, but that it's not in your path, which you can display with &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt;.) For the remainder of this document, we'll assume that you really honestly truly lack an installed module, but have found it on the CPAN.</source>
          <target state="translated">エラーメッセージが表示されない場合は、モジュールがあります。（エラーメッセージが表示された場合でも、モジュールがある可能性はありますが、パスに含まれていない可能性があります。これは、 &lt;code&gt;perl -e &quot;print qq(@INC)&quot;&lt;/code&gt; で表示できます。）このドキュメントの残りの部分では、正直なところ、インストールされているモジュールが本当に不足していると想定しますが、CPANで見つけました。</target>
        </trans-unit>
        <trans-unit id="22a71969f2b2e317963f5563c127a63079459334" translate="yes" xml:space="preserve">
          <source>If you don't specify a &lt;code&gt;dw_size&lt;/code&gt; , it defaults to the entire memory limit.</source>
          <target state="translated">&lt;code&gt;dw_size&lt;/code&gt; を指定しない場合、デフォルトで全体のメモリ制限になります。</target>
        </trans-unit>
        <trans-unit id="a1d09f5237198c8d539c87c541eb6e6b72285d75" translate="yes" xml:space="preserve">
          <source>If you don't specify a &lt;code&gt;dw_size&lt;/code&gt;, it defaults to the entire memory limit.</source>
          <target state="translated">&lt;code&gt;dw_size&lt;/code&gt; を指定しない場合、デフォルトでメモリ制限全体になります。</target>
        </trans-unit>
        <trans-unit id="680f0cec0c96fdd6b5789593128bcc203ccf616d" translate="yes" xml:space="preserve">
          <source>If you don't specify a plan, &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; expects to see &lt;code&gt;done_testing()&lt;/code&gt; before your program exits. It will warn you if you forget it. You can give &lt;code&gt;done_testing()&lt;/code&gt; an optional number of tests you expected to run, and if the number ran differs, &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; will give you another kind of warning.</source>
          <target state="translated">プランを指定しない場合、&lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt;は、プログラムが終了する前に &lt;code&gt;done_testing()&lt;/code&gt; が表示されることを期待します。あなたがそれを忘れるとそれはあなたに警告します。あなたは与えることができます &lt;code&gt;done_testing()&lt;/code&gt; あなたが実行すると予想テストのオプションの数を、その数のRANが異なる場合、&lt;a href=&quot;Test::More&quot;&gt;テスト::詳細は&lt;/a&gt;あなたに警告、別の種類を提供します。</target>
        </trans-unit>
        <trans-unit id="d559d6056536d78595c17d437dfe78484f93f47a" translate="yes" xml:space="preserve">
          <source>If you don't understand this question, just press ENTER.</source>
          <target state="translated">この質問がわからない場合は、ENTERを押してください。</target>
        </trans-unit>
        <trans-unit id="e1a9da1b5f8c61c5b3d264532c0386f7656b5414" translate="yes" xml:space="preserve">
          <source>If you don't want &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; to change your original variable you can use the non-destructive substitute modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt;. This changes the behavior so that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; returns the final substituted string (instead of the number of substitutions):</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 元の変数を変更したくない場合は、非破壊的な置換修飾子 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; 使用できます。これにより、 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; が（置換の数ではなく）最終的な置換文字列を返すように動作が変更されます。</target>
        </trans-unit>
        <trans-unit id="b16ffc6d1bac1378ef5d03cf556d21c8b3e4f33f" translate="yes" xml:space="preserve">
          <source>If you don't want &lt;code&gt;s///&lt;/code&gt; to change your original variable you can use the non-destructive substitute modifier, &lt;code&gt;s///r&lt;/code&gt;. This changes the behavior so that &lt;code&gt;s///r&lt;/code&gt; returns the final substituted string (instead of the number of substitutions):</source>
          <target state="translated">&lt;code&gt;s///&lt;/code&gt; 元の変数を変更したくない場合は、非破壊の代替修飾子 &lt;code&gt;s///r&lt;/code&gt; 使用できます。これにより、 &lt;code&gt;s///r&lt;/code&gt; が（置換の数ではなく）最終的な置換文字列を返すように動作が変更されます。</target>
        </trans-unit>
        <trans-unit id="b63f96d379f7a46f61c3872f0a57972ef07d6947" translate="yes" xml:space="preserve">
          <source>If you don't want any output should all modules be up to date, parse the output of above command for the regular expression &lt;code&gt;/modules are up to date/&lt;/code&gt; and decide to mail the output only if it doesn't match.</source>
          <target state="translated">すべてのモジュールが最新の状態である必要がない場合は、上記のコマンドの出力を解析して、正規表現 &lt;code&gt;/modules are up to date/&lt;/code&gt; を解析し、一致しない場合のみ出力をメールで送信することを決定します。</target>
        </trans-unit>
        <trans-unit id="717adb67f10193acb40c16a22305c4dc8ba0e791" translate="yes" xml:space="preserve">
          <source>If you don't want to create a new hash, you can still use this looping technique; just change the &lt;code&gt;%new_hash&lt;/code&gt; to &lt;code&gt;%hash1&lt;/code&gt; .</source>
          <target state="translated">新しいハッシュを作成したくない場合でも、このループ手法を使用できます。 &lt;code&gt;%new_hash&lt;/code&gt; を &lt;code&gt;%hash1&lt;/code&gt; に変更するだけです。</target>
        </trans-unit>
        <trans-unit id="611b9b2078bc455fea7df0c75d337a1c6b770290" translate="yes" xml:space="preserve">
          <source>If you don't want to create a new hash, you can still use this looping technique; just change the &lt;code&gt;%new_hash&lt;/code&gt; to &lt;code&gt;%hash1&lt;/code&gt;.</source>
          <target state="translated">新しいハッシュを作成したくない場合でも、このループ手法を使用できます。 &lt;code&gt;%new_hash&lt;/code&gt; を &lt;code&gt;%hash1&lt;/code&gt; に変更するだけです。</target>
        </trans-unit>
        <trans-unit id="5861b9dcca59001a7ac94c68a3d243558acaf640" translate="yes" xml:space="preserve">
          <source>If you don't want to install the compiled Perl in AIX into /QOpenSys (for packaging it before copying it to PASE), you can use a Configure parameter: -Dinstallprefix=/tmp/QOpenSys/perl. This will cause the &quot;make install&quot; to install everything into that directory, while the installed files still think they are (will be) in /QOpenSys/perl.</source>
          <target state="translated">AIXでコンパイルされたPerlを/QOpenSysにインストールしたくない場合(PASEにコピーする前にパッケージ化するため)、Configureパラメータ-Dinstallprefix=/tmp/QOpenSys/perlを使用することができます。これにより、&quot;make install&quot; はすべてをそのディレクトリにインストールしますが、インストールされたファイルは /QOpenSys/perl にある (と思われる)と思われます。</target>
        </trans-unit>
        <trans-unit id="ebe8a5460a3cd2a89a4ca3fccf1f4c546c9647e5" translate="yes" xml:space="preserve">
          <source>If you don't want to keep the defaults for the INSTALL* macros, MakeMaker helps you to minimize the typing needed: the usual relationship between INSTALLPRIVLIB and INSTALLARCHLIB is determined by Configure at perl compilation time. MakeMaker supports the user who sets INSTALLPRIVLIB. If INSTALLPRIVLIB is set, but INSTALLARCHLIB not, then MakeMaker defaults the latter to be the same subdirectory of INSTALLPRIVLIB as Configure decided for the counterparts in %Config, otherwise it defaults to INSTALLPRIVLIB. The same relationship holds for INSTALLSITELIB and INSTALLSITEARCH.</source>
          <target state="translated">INSTALL*マクロのデフォルトを維持したくない場合は、MakeMakerを使えば、必要最小限の入力で済みます。MakeMakerはINSTALLPRIVLIBを設定するユーザーをサポートしています。INSTALLPRIVLIBが設定されていて、INSTALLARCHLIBが設定されていない場合、MakeMakerは後者を、%Configで対応する部分についてConfigが決定したのと同じINSTALLPRIVLIBのサブディレクトリにするようにデフォルトし、そうでない場合はINSTALLPRIVLIBをデフォルトします。INSTALLSITELIB と INSTALLSITEARCH も同じ関係です。</target>
        </trans-unit>
        <trans-unit id="5f0e1c4bb41a9dbee49413981e4f4536890ac2a6" translate="yes" xml:space="preserve">
          <source>If you don't want to modify your source code, but still have on-the-fly warnings, do this:</source>
          <target state="translated">ソースコードを変更したくないが、オンザフライで警告が出る場合は、このようにしてください。</target>
        </trans-unit>
        <trans-unit id="883af52a64cbec821f8f52f9cf06fce4facdd6ad" translate="yes" xml:space="preserve">
          <source>If you don't want to use the objects, you may import the &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method into your namespace as a regular function called &lt;code&gt;stat_cando&lt;/code&gt; . This takes an arrayref containing the return values of &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; as its first argument, and interprets it for you.</source>
          <target state="translated">オブジェクトを使用したくない場合は、 &lt;code&gt;-&amp;gt;cando&lt;/code&gt; メソッドを &lt;code&gt;stat_cando&lt;/code&gt; と呼ばれる通常の関数として名前空間にインポートできます。これは、最初の引数として &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; の戻り値を含むarrayrefを取り、それを解釈します。</target>
        </trans-unit>
        <trans-unit id="75651ef23090da325a0156abcf83a5415a24e8bd" translate="yes" xml:space="preserve">
          <source>If you don't want to use the objects, you may import the &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method into your namespace as a regular function called &lt;code&gt;stat_cando&lt;/code&gt;. This takes an arrayref containing the return values of &lt;code&gt;stat&lt;/code&gt; or &lt;code&gt;lstat&lt;/code&gt; as its first argument, and interprets it for you.</source>
          <target state="translated">あなたがオブジェクトを使用したくない場合は、インポートすることがあり &lt;code&gt;-&amp;gt;cando&lt;/code&gt; と呼ばれる通常の関数としてあなたの名前空間にメソッドを &lt;code&gt;stat_cando&lt;/code&gt; 。これは、 &lt;code&gt;stat&lt;/code&gt; または &lt;code&gt;lstat&lt;/code&gt; の戻り値を含むarrayrefを最初の引数として受け取り、それを解釈します。</target>
        </trans-unit>
        <trans-unit id="8ca8817e625d3ffbecabec4b725646c93f6f8e36" translate="yes" xml:space="preserve">
          <source>If you don't wish to do this, set this variable to &lt;code&gt;false&lt;/code&gt; . Understand then that version comparisons are not possible, and Module::Load::Conditional can not tell you what module version you have installed. This may be desirable from a security or performance point of view. Note that &lt;code&gt;$FIND_VERSION&lt;/code&gt; code runs safely under &lt;code&gt;taint mode&lt;/code&gt; .</source>
          <target state="translated">これを行わない場合は、この変数を &lt;code&gt;false&lt;/code&gt; に設定します。バージョンの比較は不可能であり、Module :: Load :: Conditionalはインストールされているモジュールのバージョンを通知できないことを理解してください。これは、セキュリティまたはパフォーマンスの観点から望ましい場合があります。 &lt;code&gt;$FIND_VERSION&lt;/code&gt; コードは &lt;code&gt;taint mode&lt;/code&gt; 安全に実行されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="de94190185ca2f3465ff49971ba654614381737e" translate="yes" xml:space="preserve">
          <source>If you don't wish to do this, set this variable to &lt;code&gt;false&lt;/code&gt;. Understand then that version comparisons are not possible, and Module::Load::Conditional can not tell you what module version you have installed. This may be desirable from a security or performance point of view. Note that &lt;code&gt;$FIND_VERSION&lt;/code&gt; code runs safely under &lt;code&gt;taint mode&lt;/code&gt;.</source>
          <target state="translated">これを実行したくない場合は、この変数を &lt;code&gt;false&lt;/code&gt; に設定します。その場合、バージョン比較は不可能であり、Module :: Load :: Conditionalはインストールしたモジュールバージョンを通知できないことを理解してください。これは、セキュリティまたはパフォーマンスの観点から望ましい場合があります。 &lt;code&gt;$FIND_VERSION&lt;/code&gt; コードは、 &lt;code&gt;taint mode&lt;/code&gt; 安全に実行されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1341f2f78549b1827b1d11fb4b0cc0463ec09d6c" translate="yes" xml:space="preserve">
          <source>If you don't, you may experience strange build errors.</source>
          <target state="translated">そうしないと、奇妙なビルドエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="dae8c74471266a8218d010f2ece1eeec7e339df7" translate="yes" xml:space="preserve">
          <source>If you edit</source>
          <target state="translated">編集する場合</target>
        </trans-unit>
        <trans-unit id="2fb01cc36906ab2ae202731906c27291970214ff" translate="yes" xml:space="preserve">
          <source>If you either have Perl 5.8.0 or later installed, or if you have Scalar-List-Utils 1.03 or later installed, you can say:</source>
          <target state="translated">Perl 5.8.0以降がインストールされているか、Scalar-List-Utils 1.03以降がインストールされているかのどちらかであれば、と言うことになります。</target>
        </trans-unit>
        <trans-unit id="09872666932a845e43c465fbd124a59438a49096" translate="yes" xml:space="preserve">
          <source>If you evaluate a hash in scalar context, it returns a false value if the hash is empty. If there are any key/value pairs, it returns a true value. A more precise definition is version dependent.</source>
          <target state="translated">スカラコンテキストでハッシュを評価した場合、ハッシュが空の場合は偽の値を返します。キーと値のペアがある場合は真の値を返します。より正確な定義はバージョンに依存します。</target>
        </trans-unit>
        <trans-unit id="b892a658ce0764f4b064036e5d8f58bd78f5e370" translate="yes" xml:space="preserve">
          <source>If you evaluate a hash in scalar context, it returns false if the hash is empty. If there are any key/value pairs, it returns true; more precisely, the value returned is a string consisting of the number of used buckets and the number of allocated buckets, separated by a slash. This is pretty much useful only to find out whether Perl's internal hashing algorithm is performing poorly on your data set. For example, you stick 10,000 things in a hash, but evaluating %HASH in scalar context reveals &lt;code&gt;&quot;1/16&quot;&lt;/code&gt; , which means only one out of sixteen buckets has been touched, and presumably contains all 10,000 of your items. This isn't supposed to happen. If a tied hash is evaluated in scalar context, the &lt;code&gt;SCALAR&lt;/code&gt; method is called (with a fallback to &lt;code&gt;FIRSTKEY&lt;/code&gt; ).</source>
          <target state="translated">スカラーコンテキストでハッシュを評価する場合、ハッシュが空の場合はfalseを返します。キーと値のペアがある場合は、trueを返します。より正確には、返される値はスラッシュで区切られた、使用されたバケットの数と割り当てられたバケットの数で構成される文字列です。これは、Perlの内部ハッシュアルゴリズムがデータセットで十分に機能していないかどうかを確認する場合にのみ役立ちます。たとえば、ハッシュに10,000個のアイテムを貼り付けますが、スカラーコンテキストで％HASHを評価すると &lt;code&gt;&quot;1/16&quot;&lt;/code&gt; が明らかになります。これは、16個のバケットのうち1つだけが操作され、おそらく10,000個すべてのアイテムが含まれていることを意味します。これは起こり得ないことです。タイハッシュがスカラーコンテキストで評価されると、 &lt;code&gt;SCALAR&lt;/code&gt; メソッドが呼び出されます（ &lt;code&gt;FIRSTKEY&lt;/code&gt; へのフォールバック付き）。</target>
        </trans-unit>
        <trans-unit id="8b7212a78497ddedc16438e486691b2144fe7186" translate="yes" xml:space="preserve">
          <source>If you evaluate an array in scalar context, it returns the length of the array. (Note that this is not true of lists, which return the last value, like the C comma operator, nor of built-in functions, which return whatever they feel like returning.) The following is always true:</source>
          <target state="translated">スカラコンテキストで配列を評価すると、配列の長さを返します。(C のカンマ演算子のように最後の値を返すリストや、返したいと思ったものを何でも返す組み込み関数には当てはまらないことに注意してください)。以下は常に真です。</target>
        </trans-unit>
        <trans-unit id="ae75f4b9e5f451131a1e22cec2a555eb5370ed40" translate="yes" xml:space="preserve">
          <source>If you ever see a string that looks like this, you'll know you printed out a reference by mistake.</source>
          <target state="translated">こんな感じの文字列が出てきたら、間違って参照先をプリントアウトしたことに気づくと思います。</target>
        </trans-unit>
        <trans-unit id="d2eae54bf1fbe9ae68c160098f500a78269b550c" translate="yes" xml:space="preserve">
          <source>If you execute the &lt;code&gt;T&lt;/code&gt; command from inside an active &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement, the backtrace will contain both a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; frame and an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; frame.</source>
          <target state="translated">アクティブな &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ステートメント内から &lt;code&gt;T&lt;/code&gt; コマンドを実行すると、バックトレースには &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; フレームと &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; フレームの両方が含まれます。</target>
        </trans-unit>
        <trans-unit id="091b3761ddd88c9d0dd9f58cc16fae998cfc428e" translate="yes" xml:space="preserve">
          <source>If you execute the &lt;code&gt;T&lt;/code&gt; command from inside an active &lt;code&gt;use&lt;/code&gt; statement, the backtrace will contain both a &lt;code&gt;require&lt;/code&gt; frame and an &lt;code&gt;eval&lt;/code&gt; frame.</source>
          <target state="translated">アクティブな &lt;code&gt;use&lt;/code&gt; ステートメント内から &lt;code&gt;T&lt;/code&gt; コマンドを実行すると、バックトレースには &lt;code&gt;require&lt;/code&gt; フレームと &lt;code&gt;eval&lt;/code&gt; フレームの両方が含まれます。</target>
        </trans-unit>
        <trans-unit id="e5fd5107f38bc928d4af20adedacdcf1cb44e019" translate="yes" xml:space="preserve">
          <source>If you expect characters to get to your device when you &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; them, you'll want to autoflush that filehandle. You can use &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;$|&lt;/code&gt; variable to control autoflushing (see</source>
          <target state="translated">文字を &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; したときにデバイスに到達することが予想される場合は、そのファイルハンドルを自動フラッシュする必要があります。 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;$|&lt;/code&gt; 使用できます 自動フラッシュを制御する変数（参照</target>
        </trans-unit>
        <trans-unit id="13366f7fd030f27f570c375099dc54189f595b15" translate="yes" xml:space="preserve">
          <source>If you expect characters to get to your device when you &lt;code&gt;print()&lt;/code&gt; them, you'll want to autoflush that filehandle. You can use &lt;code&gt;select()&lt;/code&gt; and the &lt;code&gt;$|&lt;/code&gt; variable to control autoflushing (see &lt;a href=&quot;perlvar#%24%7C&quot;&gt;&quot;$|&quot; in perlvar&lt;/a&gt; and &lt;a href=&quot;perlfunc#select&quot;&gt;&quot;select&quot; in perlfunc&lt;/a&gt;, or &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt;, &quot;How do I flush/unbuffer an output filehandle? Why must I do this?&quot;):</source>
          <target state="translated">&lt;code&gt;print()&lt;/code&gt; したときに文字がデバイスに到達することが予想される場合は、そのファイルハンドルを自動フラッシュする必要があります。 &lt;code&gt;select()&lt;/code&gt; と &lt;code&gt;$|&lt;/code&gt; 使用できます自動フラッシュを制御する変数（perlvarの&lt;a href=&quot;perlvar#%24%7C&quot;&gt;「$ |」&lt;/a&gt;および&lt;a href=&quot;perlfunc#select&quot;&gt;perlfuncの「select」&lt;/a&gt;または&lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt;、「出力ファイルハンドルをフラッシュ/バッファリング解除するにはどうすればよいですか？なぜこれを行う必要があるのですか？」を参照）：</target>
        </trans-unit>
        <trans-unit id="b65a4bc3927cbd6d7618d76eb545351eb5d8a945" translate="yes" xml:space="preserve">
          <source>If you expect to use both read and write operations on the device, you'll have to open it for update (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for details). You may wish to open it without running the risk of blocking by using &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module (part of the standard perl distribution). See &lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt; for more on this approach.</source>
          <target state="translated">デバイスで読み取り操作と書き込み操作の両方を使用する場合は、更新のためにそれを開く必要があります（詳細については、&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;を参照してください）。あなたは使用して、ブロッキングのリスクを実行せず、それを開きたいかもしれ &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; から&lt;a href=&quot;fcntl&quot;&gt;をFcntl&lt;/a&gt;モジュール（標準のperlディストリビューションの一部）。このアプローチの詳細については、&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="0c9408c9e8ecf3bf3ccb1ff9f6037ecd31cab34f" translate="yes" xml:space="preserve">
          <source>If you expect to use both read and write operations on the device, you'll have to open it for update (see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt; for details). You may wish to open it without running the risk of blocking by using &lt;code&gt;sysopen()&lt;/code&gt; and &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module (part of the standard perl distribution). See &lt;a href=&quot;perlfunc#sysopen&quot;&gt;&quot;sysopen&quot; in perlfunc&lt;/a&gt; for more on this approach.</source>
          <target state="translated">デバイスで読み取り操作と書き込み操作の両方を使用する予定の場合は、更新のためにデバイスを開く必要があります（詳細については&lt;a href=&quot;perlfunc#open&quot;&gt;、perlfuncの「開く」&lt;/a&gt;を参照してください）。あなたは使用して、ブロッキングのリスクを実行せず、それを開きたいかもしれ &lt;code&gt;sysopen()&lt;/code&gt; と &lt;code&gt;O_RDWR|O_NDELAY|O_NOCTTY&lt;/code&gt; から&lt;a href=&quot;fcntl&quot;&gt;をFcntl&lt;/a&gt;モジュール（標準のperlディストリビューションの一部）。このアプローチの詳細について&lt;a href=&quot;perlfunc#sysopen&quot;&gt;は、perlfuncの「sysopen」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="086943bc39b9078514791bccbde5ea2eddf63045" translate="yes" xml:space="preserve">
          <source>If you fail more than 254 tests, it will be reported as 254.</source>
          <target state="translated">254以上のテストに失敗した場合は254として報告されます。</target>
        </trans-unit>
        <trans-unit id="cba05a1f1e542bc35030ada7de3e6bf8ced79b98" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt; . Note that you will then need &lt;code&gt;IO::String&lt;/code&gt; installed to support writing stringified archives.</source>
          <target state="translated">無効にしたい場合は、この変数を &lt;code&gt;false&lt;/code&gt; に設定してください。文字列化されたアーカイブの書き込みをサポートするには、 &lt;code&gt;IO::String&lt;/code&gt; インストールする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0eb03812b9a06455d8a297e6d6e18c05b28becbc" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt; . Note that you will then need &lt;code&gt;perlio&lt;/code&gt; support from your perl to be able to write stringified archives.</source>
          <target state="translated">無効にしたい場合は、この変数を &lt;code&gt;false&lt;/code&gt; に設定してください。文字列化されたアーカイブを書き込むには、perlからの &lt;code&gt;perlio&lt;/code&gt; サポートが必要になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3a8a7ec77511b20c4509af066f4a3c986692847a" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt;. Note that you will then need &lt;code&gt;IO::String&lt;/code&gt; installed to support writing stringified archives.</source>
          <target state="translated">無効にすることを強く望んでいる場合は、この変数を &lt;code&gt;false&lt;/code&gt; に設定してください。次に、文字列化されたアーカイブの書き込みをサポートするために &lt;code&gt;IO::String&lt;/code&gt; インストールする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="fdfe08a0cfcd839078102e8b91b9b69bb63aa64b" translate="yes" xml:space="preserve">
          <source>If you feel strongly about disabling it, set this variable to &lt;code&gt;false&lt;/code&gt;. Note that you will then need &lt;code&gt;perlio&lt;/code&gt; support from your perl to be able to write stringified archives.</source>
          <target state="translated">無効にすることを強く望んでいる場合は、この変数を &lt;code&gt;false&lt;/code&gt; に設定してください。ストリング化されたアーカイブを作成できるようにするには、perlからの &lt;code&gt;perlio&lt;/code&gt; サポートが必要になることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8b50f7e3c982f4c5e423c530952e3d4ee9e5c5f1" translate="yes" xml:space="preserve">
          <source>If you feel the urge to write Perl modules, &lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt; will give you good advice.</source>
          <target state="translated">Perlモジュールを作成する衝動を感じた場合は、&lt;a href=&quot;perlnewmod&quot;&gt;perlnewmod&lt;/a&gt;が適切なアドバイスを提供します。</target>
        </trans-unit>
        <trans-unit id="5e8118a36fba749a624194d24477115572a55b8e" translate="yes" xml:space="preserve">
          <source>If you feel you need to use one of these functions, first send email to &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;perl5-porters@perl.org&lt;/a&gt;. It may be that there is a good reason for the function not being documented, and it should be removed from this list; or it may just be that no one has gotten around to documenting it. In the latter case, you will be asked to submit a patch to document the function. Once your patch is accepted, it will indicate that the interface is stable (unless it is explicitly marked otherwise) and usable by you.</source>
          <target state="translated">これらの機能のいずれかを使用する必要があると思われる場合は、最初に&lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;perl5-porters@perl.org&lt;/a&gt;に電子メールを送信してください。関数が文書化されていない正当な理由がある可能性があるため、このリストから削除する必要があります。あるいは、誰もそれを文書化することに慣れていないというだけかもしれません。後者の場合、機能を文書化するためのパッチを提出するように求められます。パッチが受け入れられると、インターフェイスが安定していて（明示的にマークされていない限り）、使用可能であることが示されます。</target>
        </trans-unit>
        <trans-unit id="1ab4e553b43f57ec6c364e3642fd9276b76ed300" translate="yes" xml:space="preserve">
          <source>If you fill comfortable with</source>
          <target state="translated">あなたが快適に充填する場合</target>
        </trans-unit>
        <trans-unit id="d37bfff208b4893c857f8a0e5567752243d86aa9" translate="yes" xml:space="preserve">
          <source>If you find any bugs, &lt;code&gt;Devel::PPPort&lt;/code&gt; doesn't seem to build on your system, or any of its tests fail, please file an issue here: &lt;a href=&quot;https://github.com/mhx/Devel-PPPort/issues/&quot;&gt;https://github.com/mhx/Devel-PPPort/issues/&lt;/a&gt;</source>
          <target state="translated">バグを見つけた場合、 &lt;code&gt;Devel::PPPort&lt;/code&gt; がシステム上に構築されていないか、そのテストのいずれかが失敗した場合は、&lt;a href=&quot;https://github.com/mhx/Devel-PPPort/issues/&quot;&gt;https&lt;/a&gt;：//github.com/mhx/Devel-PPPort/issues/で問題を報告してください。</target>
        </trans-unit>
        <trans-unit id="55c31040a6a87b03d0eac44bd1c63f05031e2f01" translate="yes" xml:space="preserve">
          <source>If you find any bugs, &lt;code&gt;Devel::PPPort&lt;/code&gt; doesn't seem to build on your system, or any of its tests fail, please send a bug report to &lt;a href=&quot;https://github.com/Dual-Life/Devel-PPPort/issues/new&quot;&gt;https://github.com/Dual-Life/Devel-PPPort/issues/new&lt;/a&gt;.</source>
          <target state="translated">バグを見つけた場合、 &lt;code&gt;Devel::PPPort&lt;/code&gt; がシステム上に構築されていないようであるか、そのテストのいずれかが失敗した場合は、バグレポートを&lt;a href=&quot;https://github.com/Dual-Life/Devel-PPPort/issues/new&quot;&gt;https://github.com/Dual-Life/Devel-PPPort/issuesに&lt;/a&gt;送信してください。 / new。</target>
        </trans-unit>
        <trans-unit id="6f336ce8c57722e9cc0dd1c79931ced850c7378d" translate="yes" xml:space="preserve">
          <source>If you find any other limitations or bugs then let me know.</source>
          <target state="translated">他の制限やバグを見つけたら、私に知らせてください。</target>
        </trans-unit>
        <trans-unit id="8d6e534aca61d370cf38f89adc29a8e3c3accf6a" translate="yes" xml:space="preserve">
          <source>If you find bugs in perl, you can report them to &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="translated">perlにバグを見つけた場合は、&lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https：//github.com/Perl/perl5/issuesに&lt;/a&gt;報告できます。</target>
        </trans-unit>
        <trans-unit id="b5ef4696f943b05c3aef9d5f207bfe62cada2927" translate="yes" xml:space="preserve">
          <source>If you find bugs in perl, you can run &lt;code&gt;perlbug&lt;/code&gt; to create a bug report (you may have to send it manually if &lt;code&gt;perlbug&lt;/code&gt; cannot find a mailer on your system).</source>
          <target state="translated">perlでバグを見つけたら、 &lt;code&gt;perlbug&lt;/code&gt; を実行してバグレポートを作成できます（ &lt;code&gt;perlbug&lt;/code&gt; がシステムでメーラーを見つけられない場合は、手動で送信する必要がある場合があります）。</target>
        </trans-unit>
        <trans-unit id="549be5a33ff1eaf5b330339ea140d5f50a8a508b" translate="yes" xml:space="preserve">
          <source>If you find bugs or if it does not work at all on your device, send mail to the address below. Please report the details of your device (processor, ceversion, devicetype (hpc/palm/pocket)) and the date of the downloaded files.</source>
          <target state="translated">バグを発見した場合や、お使いのデバイスで全く動作しない場合は、以下のアドレスにメールを送ってください。お使いのデバイスの詳細(プロセッサ、バージョン、デバイスタイプ(hpc/palm/pocket))とダウンロードしたファイルの日付を報告してください。</target>
        </trans-unit>
        <trans-unit id="ce181ab3a1836691a411c40b59cfd6c2a33af266" translate="yes" xml:space="preserve">
          <source>If you find instances of this in the Perl distribution itself, please let us know, so we can try to work around them.</source>
          <target state="translated">Perl ディストリビューションでこのような例を見つけた場合は、私たちに知らせてください。</target>
        </trans-unit>
        <trans-unit id="a35b038d2558b01a66b6ce215ee08874b540cf15" translate="yes" xml:space="preserve">
          <source>If you find that you do need to update the system Perl, one issue worth keeping in mind is the question of static vs. dynamic libraries. If you upgrade using the default static libperl, you will find that the dynamic libperl supplied by Apple will not be deleted. If both libraries are present when an application that links against libperl is built, ld will link against the dynamic library by default. So, if you need to replace Apple's dynamic libperl with a static libperl, you need to be sure to delete the older dynamic library after you've installed the update.</source>
          <target state="translated">システム Perl を更新する必要があることがわかった場合、心に留めておく価値のある問題は、静的ライブラリと動的ライブラリの問題です。デフォルトの静的 libperl を使用してアップグレードした場合、Apple によって提供された動的 libperl は削除されないことがわかります。libperl にリンクするアプリケーションがビルドされたときに両方のライブラリが存在する場合、ld はデフォルトで動的ライブラリにリンクします。そのため、Appleのダイナミックlibperlをスタティックlibperlに置き換える必要がある場合は、アップデートをインストールした後に古いダイナミックライブラリを必ず削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="8facfef28f917f827b51a8dc9cc5203934df7f46" translate="yes" xml:space="preserve">
          <source>If you find that you need to speed up a specific part of a Perl application (not something you often need) you may want to use C, but you can access this from your Perl code with &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;.</source>
          <target state="translated">Perlアプリケーションの特定の部分（頻繁に必要なものではない）を高速化する必要がある場合は、Cを使用することもできますが、Perlコードから&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;を使用してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="6d6f2d3762fd66cb49c45a26180601ab0ecbaf26" translate="yes" xml:space="preserve">
          <source>If you find the Calc module to slow, try to install any of the replacement modules and see if they help you.</source>
          <target state="translated">Calc モジュールの動作が遅いと感じたら、代替モジュールをインストールしてみて、それが役に立つかどうか確認してみてください。</target>
        </trans-unit>
        <trans-unit id="9507dd44f0fdbd974fde8543eaceef56a9bf59da" translate="yes" xml:space="preserve">
          <source>If you find the implementation document unclear or not sufficient, look at the existing PerlIO layer implementations, which include:</source>
          <target state="translated">実装ドキュメントが不明瞭であったり、十分ではないと思われる場合は、既存のPerlIOレイヤの実装を見てください。</target>
        </trans-unit>
        <trans-unit id="bb1a29c843961bd016421afc69613b486ab41b5a" translate="yes" xml:space="preserve">
          <source>If you find this module useful, please consider rating it on the CPAN Ratings service at &lt;a href=&quot;http://cpanratings.perl.org/rate?distribution=autodie&quot;&gt;http://cpanratings.perl.org/rate?distribution=autodie&lt;/a&gt; .</source>
          <target state="translated">このモジュールが有用であると思われる場合は、&lt;a href=&quot;http://cpanratings.perl.org/rate?distribution=autodie&quot;&gt;http：&lt;/a&gt; //cpanratings.perl.org/rate？distribution = autodieのCPANレーティングサービスで評価することを検討してください。</target>
        </trans-unit>
        <trans-unit id="8307a7110288b02faca83e75adb216a84beaca75" translate="yes" xml:space="preserve">
          <source>If you find you need to provide custom functionality (as you would have using &lt;a href=&quot;Test::Harness::Straps&quot;&gt;Test::Harness::Straps&lt;/a&gt;), you're in luck: &lt;code&gt;TAP::Parser&lt;/code&gt; and friends are designed to be easily plugged-into and/or subclassed.</source>
          <target state="translated">（&lt;a href=&quot;Test::Harness::Straps&quot;&gt;Test :: Harness :: Traps&lt;/a&gt;を使用する場合のように）カスタム機能を提供する必要がある場合は、幸運です &lt;code&gt;TAP::Parser&lt;/code&gt; とその仲間は、簡単にプラグインしたり、サブクラス化したりできるように設計されています。</target>
        </trans-unit>
        <trans-unit id="5afed98244534d5e7bd9f07d6f953a138ea4f8e9" translate="yes" xml:space="preserve">
          <source>If you find you need to provide custom functionality (as you would have using &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test::Harness::Straps&lt;/a&gt;), you're in luck: &lt;code&gt;TAP::Parser&lt;/code&gt; and friends are designed to be easily plugged-into and/or subclassed.</source>
          <target state="translated">カスタム機能を提供する必要がある場合（&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Harness::Straps&quot;&gt;Test :: Harness :: Straps&lt;/a&gt;を使用する場合と同様）、幸運です： &lt;code&gt;TAP::Parser&lt;/code&gt; とその仲間は、簡単にプラグインやサブクラス化できるように設計されています。</target>
        </trans-unit>
        <trans-unit id="e0f3870d3b01febf6f7490ea91b0d476cdafaf0c" translate="yes" xml:space="preserve">
          <source>If you find you really need to use your own iterator factory you can still do so without sub-classing &lt;code&gt;TAP::Parser&lt;/code&gt; by setting &lt;a href=&quot;#iterator_factory_class&quot;&gt;&quot;iterator_factory_class&quot;&lt;/a&gt;.</source>
          <target state="translated">独自のイテレータファクトリを本当に使用する必要がある場合は、&lt;a href=&quot;#iterator_factory_class&quot;&gt;「iterator_factory_class」を&lt;/a&gt;設定することで、 &lt;code&gt;TAP::Parser&lt;/code&gt; をサブクラス化せずに使用できます。</target>
        </trans-unit>
        <trans-unit id="7eaae25128643ba9a8e9cd9fd035b84dc1c8a6c4" translate="yes" xml:space="preserve">
          <source>If you find you really need to use your own iterator factory you can still do so without sub-classing &lt;code&gt;TAP::Parser&lt;/code&gt; by setting &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt;.</source>
          <target state="translated">独自のイテレーターファクトリを本当に使用する必要がある場合でも、&lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt;を設定することにより、 &lt;code&gt;TAP::Parser&lt;/code&gt; をサブクラス化せずに使用できます。</target>
        </trans-unit>
        <trans-unit id="ef253d4b5355af7bdf0e5249c9becef0fb63f08e" translate="yes" xml:space="preserve">
          <source>If you for some reason (such as binary backward compatibility) really need to use perl's malloc, you can rebuild perl from the sources and Configure the build with</source>
          <target state="translated">何らかの理由で(バイナリの下位互換性など)どうしてもperlのmallocを使う必要がある場合は、ソースからperlをリビルドして、ビルドの設定を</target>
        </trans-unit>
        <trans-unit id="a38ea3094c2349d48a8464c8b2ede590e7cc8393" translate="yes" xml:space="preserve">
          <source>If you forget &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , high bytes will be misunderstood as separate characters, and nothing will work right.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;を忘れると、上位バイトが別の文字として誤解され、何も正しく機能しなくなります。</target>
        </trans-unit>
        <trans-unit id="1c95ef6991d8327e95ef74bf4e7dd1e20f49af62" translate="yes" xml:space="preserve">
          <source>If you forget &lt;code&gt;use utf8&lt;/code&gt;, high bytes will be misunderstood as separate characters, and nothing will work right.</source>
          <target state="translated">&lt;code&gt;use utf8&lt;/code&gt; を忘れると、上位バイトは個別の文字として誤解され、何も正しく機能しません。</target>
        </trans-unit>
        <trans-unit id="5c73cb5a6222b98080e0788ac4c8f896039ff111" translate="yes" xml:space="preserve">
          <source>If you forget to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , you'll miss out entirely on the helpful diagnostic message:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;を忘れた場合、役立つ診断メッセージを完全に見逃してしまいます。</target>
        </trans-unit>
        <trans-unit id="f4036448bea62235f8e0ea98c0684157616bfe9e" translate="yes" xml:space="preserve">
          <source>If you forget to &lt;code&gt;use warnings&lt;/code&gt;, you'll miss out entirely on the helpful diagnostic message:</source>
          <target state="translated">&lt;code&gt;use warnings&lt;/code&gt; を忘れると、役立つ診断メッセージを完全に見逃してしまいます。</target>
        </trans-unit>
        <trans-unit id="4e4db242421a858aa14b9bcaa4e5f3862b8a23c5" translate="yes" xml:space="preserve">
          <source>If you get a core dump (or equivalent), you may use a debugger (&lt;b&gt;dbx&lt;/b&gt;, &lt;b&gt;gdb&lt;/b&gt;, etc) to produce a stack trace to include in the bug report.</source>
          <target state="translated">コアダンプ（または同等のもの）を取得した場合は、デバッガ（&lt;b&gt;dbx&lt;/b&gt;、&lt;b&gt;gdb&lt;/b&gt;など）を使用して、バグレポートに含めるスタックトレースを生成できます。</target>
        </trans-unit>
        <trans-unit id="722060cb13bfb62427a93bad15761822b6a7686d" translate="yes" xml:space="preserve">
          <source>If you get a message like &quot;perl: command not found&quot;, perl is not in your PATH, which might also mean that the location of perl is not where you expect it so you need to adjust your shebang line.</source>
          <target state="translated">perl:command not found &quot;のようなメッセージが表示された場合は、perlがPATHにないことを意味しています。</target>
        </trans-unit>
        <trans-unit id="6bc5836fc16b720e6dc1a4fbf9bbeb14813f0dae" translate="yes" xml:space="preserve">
          <source>If you get an error like</source>
          <target state="translated">のようなエラーが出た場合</target>
        </trans-unit>
        <trans-unit id="e71cc5ed2d43a688912302c22a7a0e3e08b5d7b1" translate="yes" xml:space="preserve">
          <source>If you get an error message</source>
          <target state="translated">エラーメッセージが表示された場合</target>
        </trans-unit>
        <trans-unit id="8b6135f8eeab8f4ac6ffe0b88df52abad52ae3b4" translate="yes" xml:space="preserve">
          <source>If you get complaints about so_locations then search in the file hints/irix_6.sh for &quot;lddflags&quot; and do the suggested adjustments. (David Billinghurst &amp;lt;David.Billinghurst@riotinto.com.au&amp;gt;)</source>
          <target state="translated">so_locationsに関する不満を受け取った場合は、ファイルhints / irix_6.shで「lddflags」を検索し、提案された調整を行ってください。（David Billinghurst &amp;lt;David.Billinghurst@riotinto.com.au&amp;gt;）</target>
        </trans-unit>
        <trans-unit id="0d74278837310505aa97f12b787c58f0bb90e74c" translate="yes" xml:space="preserve">
          <source>If you get lots of errors of the form</source>
          <target state="translated">フォームのエラーがたくさん出た場合</target>
        </trans-unit>
        <trans-unit id="0e2cd49639ef6344568879d541e1a269a34ede3d" translate="yes" xml:space="preserve">
          <source>If you get the error</source>
          <target state="translated">エラーが出た場合</target>
        </trans-unit>
        <trans-unit id="39b025fcc6f0d1c529cf233b24ac57e017d8f611" translate="yes" xml:space="preserve">
          <source>If you get this message on SunOS or Solaris, and you're using gcc, it's probably the GNU as or GNU ld problem in the previous item &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;&quot;GNU as and GNU ld&quot;&lt;/a&gt;.</source>
          <target state="translated">SunOSまたはSolarisでこのメッセージが表示され、gccを使用している場合は、前の項目&lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;「GNUasおよびGNUld」の&lt;/a&gt;GNUasまたはGNUldの問題である可能性があります。</target>
        </trans-unit>
        <trans-unit id="91993b40c91822c3454671d4c8a24b32c3e646ba" translate="yes" xml:space="preserve">
          <source>If you get this message on SunOS or Solaris, and you're using gcc, it's probably the GNU as or GNU ld problem in the previous item &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as and GNU ld&lt;/a&gt;.</source>
          <target state="translated">SunOSまたはSolarisでこのメッセージが表示され、gccを使用している場合、おそらく前の項目の&lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU asおよびGNU ld&lt;/a&gt;のGNU asまたはGNU ldの問題です。</target>
        </trans-unit>
        <trans-unit id="36f4dbd793640e550ca076d30024d627de795ab8" translate="yes" xml:space="preserve">
          <source>If you get tired of being subject to your platform's native integers, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; pragma neatly sidesteps the issue altogether:</source>
          <target state="translated">プラットフォームのネイティブ整数の影響を受けることに飽きたら、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; プラグマを&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;すると問題が完全に回避されます。</target>
        </trans-unit>
        <trans-unit id="69ba4fd6db8745c64a8a60725ff36af2b0505794" translate="yes" xml:space="preserve">
          <source>If you get tired of being subject to your platform's native integers, the &lt;code&gt;use bigint&lt;/code&gt; pragma neatly sidesteps the issue altogether:</source>
          <target state="translated">プラットフォームのネイティブ整数の影響を受けることにうんざりしている場合は、 &lt;code&gt;use bigint&lt;/code&gt; プラグマを使用することで問題を完全に回避できます。</target>
        </trans-unit>
        <trans-unit id="a28e8a38182dc716f4c7bb3a2e2a63a098694e97" translate="yes" xml:space="preserve">
          <source>If you get tired of constantly saying &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; $lh-&amp;gt;maketext&lt;/code&gt; , consider making a functional wrapper for it, like so:</source>
          <target state="translated">常に &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; $lh-&amp;gt;maketext&lt;/code&gt; と言うのに飽きたら、次のように、関数ラッパーを作成することを検討してください。</target>
        </trans-unit>
        <trans-unit id="f2e5f31a627306a3c5068e17e18a085ffc1169d9" translate="yes" xml:space="preserve">
          <source>If you get tired of constantly saying &lt;code&gt;print $lh-&amp;gt;maketext&lt;/code&gt;, consider making a functional wrapper for it, like so:</source>
          <target state="translated">&lt;code&gt;print $lh-&amp;gt;maketext&lt;/code&gt; と絶えず言うことにうんざりしている場合は、次のように機能的なラッパーを作成することを検討してください。</target>
        </trans-unit>
        <trans-unit id="572c0959177d510f33c38a6508a8f796163c8877" translate="yes" xml:space="preserve">
          <source>If you get tired of remembering which element of the return list contains which return value, by-name interfaces are provided in standard modules: &lt;a href=&quot;File::stat&quot;&gt;&lt;code&gt;File::stat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Net::hostent&quot;&gt;&lt;code&gt;Net::hostent&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Net::netent&quot;&gt;&lt;code&gt;Net::netent&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Net::protoent&quot;&gt;&lt;code&gt;Net::protoent&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Net::servent&quot;&gt;&lt;code&gt;Net::servent&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Time::gmtime&quot;&gt;&lt;code&gt;Time::gmtime&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;Time::localtime&quot;&gt;&lt;code&gt;Time::localtime&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;User::grent&quot;&gt;&lt;code&gt;User::grent&lt;/code&gt;&lt;/a&gt;. These override the normal built-ins, supplying versions that return objects with the appropriate names for each field. For example:</source>
          <target state="translated">あなたは、戻り値、名前によるインターフェースが標準モジュールで提供されているリターン・リストの要素が含まれてい覚えるのに疲れている場合：&lt;a href=&quot;File::stat&quot;&gt; &lt;code&gt;File::stat&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;Net::hostent&quot;&gt; &lt;code&gt;Net::hostent&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;Net::netent&quot;&gt; &lt;code&gt;Net::netent&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;Net::protoent&quot;&gt; &lt;code&gt;Net::protoent&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;Net::servent&quot;&gt; &lt;code&gt;Net::servent&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;Time::gmtime&quot;&gt; &lt;code&gt;Time::gmtime&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;Time::localtime&quot;&gt; &lt;code&gt;Time::localtime&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;User::grent&quot;&gt; &lt;code&gt;User::grent&lt;/code&gt; &lt;/a&gt;。これらは通常の組み込みをオーバーライドし、各フィールドに適切な名前のオブジェクトを返すバージョンを提供します。例えば：</target>
        </trans-unit>
        <trans-unit id="693c393f75e992e3003bea94747936126a6b0327" translate="yes" xml:space="preserve">
          <source>If you get tired of remembering which element of the return list contains which return value, by-name interfaces are provided in standard modules: &lt;code&gt;File::stat&lt;/code&gt; , &lt;code&gt;Net::hostent&lt;/code&gt; , &lt;code&gt;Net::netent&lt;/code&gt; , &lt;code&gt;Net::protoent&lt;/code&gt; , &lt;code&gt;Net::servent&lt;/code&gt; , &lt;code&gt;Time::gmtime&lt;/code&gt; , &lt;code&gt;Time::localtime&lt;/code&gt; , and &lt;code&gt;User::grent&lt;/code&gt; . These override the normal built-ins, supplying versions that return objects with the appropriate names for each field. For example:</source>
          <target state="translated">戻りリストのどの要素にどの戻り値が含まれるかを覚えるのに飽きた場合は、名前によるインターフェイスが標準モジュールで提供されています： &lt;code&gt;File::stat&lt;/code&gt; 、 &lt;code&gt;Net::hostent&lt;/code&gt; 、 &lt;code&gt;Net::netent&lt;/code&gt; 、 &lt;code&gt;Net::protoent&lt;/code&gt; 、 &lt;code&gt;Net::servent&lt;/code&gt; 、 &lt;code&gt;Time::gmtime&lt;/code&gt; 、 &lt;code&gt;Time::localtime&lt;/code&gt; 、および &lt;code&gt;User::grent&lt;/code&gt; 。これらは通常の組み込みをオーバーライドし、各フィールドに適切な名前のオブジェクトを返すバージョンを提供します。例えば：</target>
        </trans-unit>
        <trans-unit id="b8e0fc194ad5e5c2cd16a3f242684fe425f3428b" translate="yes" xml:space="preserve">
          <source>If you get used to writing odd things like these:</source>
          <target state="translated">こういう変なことを書くのに慣れてしまうと</target>
        </trans-unit>
        <trans-unit id="0cd15dd92a142244892a9be7434b98670ff15dc6" translate="yes" xml:space="preserve">
          <source>If you had &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %Foo::Bar::QUUX&lt;/code&gt; to check whether such a package variable exists then that's never really been reliable, and isn't a good way to enquire about the features of a package, or whether it's loaded, etc.</source>
          <target state="translated">あなたはしていた場合に &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %Foo::Bar::QUUX&lt;/code&gt; 、このようなパッケージ変数は、など、のは、本当に信頼性の高いされてないことを、その後に存在し、パッケージの機能を問い合わせるための良い方法ではないか、それがロードされるかどうかかどうかを確認します</target>
        </trans-unit>
        <trans-unit id="3a8d785689c76bcc85c3a87585c7936ee4bbbc6c" translate="yes" xml:space="preserve">
          <source>If you had &lt;code&gt;defined %Foo::Bar::QUUX&lt;/code&gt; to check whether such a package variable exists then that's never really been reliable, and isn't a good way to enquire about the features of a package, or whether it's loaded, etc.</source>
          <target state="translated">あなたはしていた場合 &lt;code&gt;defined %Foo::Bar::QUUX&lt;/code&gt; 、そのようなパッケージ変数は、など、のは、本当に信頼性の高いされてないことを、その後に存在し、パッケージの機能を問い合わせるための良い方法ではないか、それがロードされるかどうかかどうかを確認します</target>
        </trans-unit>
        <trans-unit id="4ef8417488b5df9f33f3d1b38e3847657756981c" translate="yes" xml:space="preserve">
          <source>If you had to get a variable through, you could do this:</source>
          <target state="translated">変数を通す必要があった場合はこうすればいいんじゃない?</target>
        </trans-unit>
        <trans-unit id="67b4946ef744afdd9a1b21f685b5b8e140afa4b4" translate="yes" xml:space="preserve">
          <source>If you have</source>
          <target state="translated">を持っている場合は</target>
        </trans-unit>
        <trans-unit id="5887bd3238a6e02f0034680e74b35124b3f3183f" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;File::Stream&quot;&gt;File::Stream&lt;/a&gt;, this is easy.</source>
          <target state="translated">&lt;a href=&quot;File::Stream&quot;&gt;File :: Stream&lt;/a&gt;がある場合、これは簡単です。</target>
        </trans-unit>
        <trans-unit id="aebe0c8d3505d2fdad4a2b644054c80705f47533" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module installed from CPAN, you can use it to fetch the width and height in characters and in pixels:</source>
          <target state="translated">あなたが持っている場合は&lt;a href=&quot;Term::ReadKey&quot;&gt;ターム:: ReadKey&lt;/a&gt; CPANからインストールしたモジュールを、あなたは文字にし、幅と高さをピクセル単位で取得するためにそれを使用することができます。</target>
        </trans-unit>
        <trans-unit id="8ebbe151437cc5de6b126287c5035e996e85c741" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;http://search.cpan.org/perldoc/File::Stream&quot;&gt;File::Stream&lt;/a&gt;, this is easy.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/File::Stream&quot;&gt;File :: Stream&lt;/a&gt;があれば、これは簡単です。</target>
        </trans-unit>
        <trans-unit id="8477c0614e083a37a8e560c57638a0b5f36ef52b" translate="yes" xml:space="preserve">
          <source>If you have &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module installed from CPAN, you can use it to fetch the width and height in characters and in pixels:</source>
          <target state="translated">あなたが持っている場合は&lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;ターム:: ReadKey&lt;/a&gt; CPANからインストールしたモジュールを、あなたは文字にし、幅と高さをピクセル単位で取得するためにそれを使用することができます。</target>
        </trans-unit>
        <trans-unit id="7230ece2e031d91cec5a13b629b5ff58c45c8753" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;IPC::Run&lt;/code&gt; installed, and the variable &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; is set to true (See the &lt;a href=&quot;#Global-Variables&quot;&gt;&quot;Global Variables&quot;&lt;/a&gt; section) use that to execute the command. You will have the full output available in buffers, interactive commands are sure to work and you are guaranteed to have your verbosity settings honored cleanly.</source>
          <target state="translated">あなたが持っている場合は &lt;code&gt;IPC::Run&lt;/code&gt; 設置し、変数 &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; （参照trueに設定されている&lt;a href=&quot;#Global-Variables&quot;&gt;「グローバル変数」&lt;/a&gt;コマンドを実行することを使用のセクションを）。バッファで完全な出力を利用できるようになり、インタラクティブコマンドが確実に機能し、詳細設定が適切に尊重されることが保証されます。</target>
        </trans-unit>
        <trans-unit id="240e14e2dd47b4fb473147b6d297b2d7726b59cc" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;IPC::Run&lt;/code&gt; installed, and the variable &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; is set to true (See the &lt;a href=&quot;#Global-Variables&quot;&gt;Global Variables&lt;/a&gt; section) use that to execute the command. You will have the full output available in buffers, interactive commands are sure to work and you are guaranteed to have your verbosity settings honored cleanly.</source>
          <target state="translated">あなたが持っている場合は &lt;code&gt;IPC::Run&lt;/code&gt; 設置し、変数 &lt;code&gt;$IPC::Cmd::USE_IPC_RUN&lt;/code&gt; （参照trueに設定されている&lt;a href=&quot;#Global-Variables&quot;&gt;グローバル変数の&lt;/a&gt;コマンドを実行することを使用のセクションを）。バッファーで完全な出力を利用できるようになり、対話型コマンドが確実に機能し、冗長性設定が正しく反映されることが保証されます。</target>
        </trans-unit>
        <trans-unit id="b8acd2601ad065393113859c8a7e3855297ce5ac" translate="yes" xml:space="preserve">
          <source>If you have &lt;code&gt;man&lt;/code&gt; installed on your system, and you installed perl manpages, use something like this:</source>
          <target state="translated">システムに &lt;code&gt;man&lt;/code&gt; がインストールされていて、perlマンページがインストールされている場合は、次のようなものを使用します。</target>
        </trans-unit>
        <trans-unit id="d6036be6bd4d2a23f70dfe8c9f989a5911198ccc" translate="yes" xml:space="preserve">
          <source>If you have Perl 5.10 or later, and you just want to store a value against the reference for lookup later, you can use the core Hash::Util::Fieldhash module. This will also handle renaming the keys if you use multiple threads (which causes all variables to be reallocated at new addresses, changing their stringification), and garbage-collecting the entries when the referenced variable goes out of scope.</source>
          <target state="translated">Perl 5.10 以降を使用していて、後で調べるために参照に対して値を保存したい場合は、コアの Hash::Util::Fieldhash モジュールを使用することができます。これはまた、複数のスレッドを使用している場合にはキーの名前を変更したり (これにより、すべての変数が新しいアドレスで再割り当てされ、文字列化が変更されます)、参照されている変数がスコープ外になったときにエントリをガベージコレクションしたりすることもできます。</target>
        </trans-unit>
        <trans-unit id="1ff5e330b4023d9ffe19df36972bfcc73814fd9b" translate="yes" xml:space="preserve">
          <source>If you have Perl 5.10 or later, this is almost trivial. You just smart match against an array of regular expression objects:</source>
          <target state="translated">Perl 5.10 以降であれば、これはほぼ簡単です。正規表現オブジェクトの配列に対してスマートマッチを行うだけです。</target>
        </trans-unit>
        <trans-unit id="f112acda35554c21f927d9597b0b2023538c4e09" translate="yes" xml:space="preserve">
          <source>If you have Perl v5.16 or v5.18 and can't upgrade, you can use</source>
          <target state="translated">Perl v5.16 または v5.18 を使用していて、アップグレードできない場合は</target>
        </trans-unit>
        <trans-unit id="2fe696e9056ea562cb89c9b2f102390c60db24f0" translate="yes" xml:space="preserve">
          <source>If you have Perl v5.16, the problems mentioned above go away if you use the &lt;code&gt;:not_characters&lt;/code&gt; parameter to the locale pragma (except for vendor bugs in the non-character portions). If you don't have v5.16, and you</source>
          <target state="translated">Perl v5.16を使用している場合、 &lt;code&gt;:not_characters&lt;/code&gt; パラメーターをロケールプラグマに使用すると、上記の問題は解消されます（文字以外の部分のベンダーバグを除く）。v5.16がなく、</target>
        </trans-unit>
        <trans-unit id="6642f62c4bfdebf5e62452d5d72c26f1bd89b8ec" translate="yes" xml:space="preserve">
          <source>If you have YAML.pm (or some other YAML module configured in &lt;code&gt;yaml_module&lt;/code&gt; ) installed, CPAN.pm collects a few statistical data about recent downloads. You can view the statistics with the &lt;code&gt;hosts&lt;/code&gt; command or inspect them directly by looking into the &lt;code&gt;FTPstats.yml&lt;/code&gt; file in your &lt;code&gt;cpan_home&lt;/code&gt; directory.</source>
          <target state="translated">YAML.pm（または &lt;code&gt;yaml_module&lt;/code&gt; で設定された他のYAMLモジュール）がインストールされている場合、CPAN.pmは最近のダウンロードに関するいくつかの統計データを収集します。 &lt;code&gt;hosts&lt;/code&gt; コマンドで統計を表示したり、 &lt;code&gt;cpan_home&lt;/code&gt; ディレクトリの &lt;code&gt;FTPstats.yml&lt;/code&gt; ファイルを調べて直接統計を調べたりできます。</target>
        </trans-unit>
        <trans-unit id="225c354ad980b0b7bb691380c5b2f0d3c2643a5a" translate="yes" xml:space="preserve">
          <source>If you have a ReadLine module installed, you can hit TAB at any point of the commandline and &lt;code&gt;o conf&lt;/code&gt; will offer you completion for the built-in subcommands and/or config variable names.</source>
          <target state="translated">あなたがReadLineメソッドモジュールがインストールされている場合は、コマンドラインの任意の時点でTABを打つことができ &lt;code&gt;o conf&lt;/code&gt; 内蔵のサブコマンドおよび/またはコンフィギュレーション変数名のあなたの完了を提供します。</target>
        </trans-unit>
        <trans-unit id="86d2e902132f610059a158729cf105aa2e1d4e91" translate="yes" xml:space="preserve">
          <source>If you have a buffer allocated with Newx() and want to set that as the SV's value, you can use sv_usepvn_flags(). That has some requirements if you want to avoid perl re-allocating the buffer to fit the trailing NUL:</source>
          <target state="translated">Newx()で割り当てられたバッファがあり、それを SV の値として設定したい場合は sv_usepvn_flags()を使用することができます。これは、末尾の NUL に合わせて perl がバッファを再割り当てするのを避けたい場合には、いくつかの要件があります。</target>
        </trans-unit>
        <trans-unit id="28b93e0d6dcdb9743374e046e2c50f7ec24b530d" translate="yes" xml:space="preserve">
          <source>If you have a burning desire to tell the world about your release, post an announcement to the moderated &lt;code&gt;comp.lang.perl.announce&lt;/code&gt; newsgroup.</source>
          <target state="translated">リリースについて世界中に伝えたいという強い欲求がある場合は、モデレートされた &lt;code&gt;comp.lang.perl.announce&lt;/code&gt; ニュースグループにアナウンスを投稿してください。</target>
        </trans-unit>
        <trans-unit id="2ed22a427a030ed732816620f86f5c52ec466566" translate="yes" xml:space="preserve">
          <source>If you have a command-line program that does the job, you can call it in backticks to capture whatever it outputs so you can use it later:</source>
          <target state="translated">仕事をするコマンドラインプログラムを持っている場合は、それをバックトークで呼び出して、それが出力するものをキャプチャし、後でそれを使用できるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="aabc7446c5d3e0c2ebc9233bf601a7899d673f9d" translate="yes" xml:space="preserve">
          <source>If you have a commit bit, please see &lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt; for more details on using git.</source>
          <target state="translated">コミットビットがある場合は、gitの使用に関する詳細について&lt;a href=&quot;perlgit&quot;&gt;perlgit&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="392daf22cd236f28ba9ceee336856176b759059d" translate="yes" xml:space="preserve">
          <source>If you have a complicated function needed to pull out the part you want to sort on, then don't do it inside the sort function. Pull it out first, because the sort BLOCK can be called many times for the same element. Here's an example of how to pull out the first word after the first number on each item, and then sort those words case-insensitively.</source>
          <target state="translated">ソートしたい部分を引き出すために複雑な関数が必要な場合は、ソート関数の中では行わないでください。なぜなら、ソートブロックは同じ要素に対して何度も呼び出すことができるからです。各項目の最初の数字の後の最初の単語を引き出し、それらの単語を大文字小文字を区別せずにソートする方法の例を以下に示します。</target>
        </trans-unit>
        <trans-unit id="b0e6b3bda8c96c33f56e6b729af6c8286cbfdc17" translate="yes" xml:space="preserve">
          <source>If you have a legacy encoding, you can use the &lt;code&gt;:encoding(...)&lt;/code&gt; tag.</source>
          <target state="translated">レガシーエンコーディングがある場合は、 &lt;code&gt;:encoding(...)&lt;/code&gt; タグを使用できます。</target>
        </trans-unit>
        <trans-unit id="01656c2b4f7ea5f69bae8d5caaac9ea48410bb3e" translate="yes" xml:space="preserve">
          <source>If you have a library that provides an API, you can make any component of it available as just another Perl function or variable using a Perl extension written in C or C++ and dynamically linked into your main perl interpreter. You can also go the other direction, and write your main program in C or C++, and then link in some Perl code on the fly, to create a powerful application. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">APIを提供するライブラリがある場合、CまたはC ++で記述され、メインのperlインタープリターに動的にリンクされたPerl拡張を使用して、そのコンポーネントを別のPerl関数または変数として使用できるようにすることができます。また、別の方向に進んで、メインプログラムをCまたはC ++で記述し、その場でいくつかのPerlコードにリンクして、強力なアプリケーションを作成することもできます。&lt;a href=&quot;perlembed&quot;&gt;perlembedを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="51f9e3f6122598346b767c490154d73f3d45b4f6" translate="yes" xml:space="preserve">
          <source>If you have a list of tests (or URLs, or anything else you want to test) in a file, you can add them to your tests by using a '-':</source>
          <target state="translated">ファイル内にテストのリスト (または URL などテストしたいもの)がある場合は、'-' を使ってテストに追加することができます。</target>
        </trans-unit>
        <trans-unit id="a1add680b7e930dc8542127166a2c6922328bade" translate="yes" xml:space="preserve">
          <source>If you have a local mirror of CPAN and can access all files with &quot;file:&quot; URLs, then you only need a perl later than perl5.003 to run this module. Otherwise Net::FTP is strongly recommended. LWP may be required for non-UNIX systems, or if your nearest CPAN site is associated with a URL that is not &lt;code&gt;ftp:&lt;/code&gt; .</source>
          <target state="translated">CPANのローカルミラーがあり、 &quot;file：&quot; URLですべてのファイルにアクセスできる場合、このモジュールを実行するにはperl5.003より後のperlのみが必要です。それ以外の場合は、Net :: FTPを強くお勧めします。UNIX以外のシステムの場合、または最も近いCPANサイトが &lt;code&gt;ftp:&lt;/code&gt; ではないURLに関連付けられている場合は、LWPが必要になることがあります。</target>
        </trans-unit>
        <trans-unit id="cc89a24f0e796df127e886da4fce9233949042a4" translate="yes" xml:space="preserve">
          <source>If you have a module that uses a decimal $VERSION (floating point), and you do not intend to ever change that, this module is not for you. There is nothing that version.pm gains you over a simple $VERSION assignment:</source>
          <target state="translated">10進数の $VERSION (浮動小数点)を使うモジュールを持っていて、それを変更するつもりがないのであれば、このモジュールはあなたのためのものではありません。version.pm が単純な $VERSION の代入よりも得るものは何もありません。</target>
        </trans-unit>
        <trans-unit id="44d0404e38c1a8f4fe7f4884e84970ffe1a562e8" translate="yes" xml:space="preserve">
          <source>If you have a question you'd like to see added to the FAQ (whether or not you have the answer) please either:</source>
          <target state="translated">FAQに追加してほしい質問があれば(答えを持っているかどうかに関わらず)、どちらかにお願いします。</target>
        </trans-unit>
        <trans-unit id="3c6b091f1c2f3916b6f982ec5d76127aba417742" translate="yes" xml:space="preserve">
          <source>If you have a question you'd like to see added to the FAQ (whether or not you have the answer) please send it to makemaker@perl.org.</source>
          <target state="translated">FAQに追加してほしい質問があれば(答えがあるかどうかは別として)、makemaker@perl.org まで送ってください。</target>
        </trans-unit>
        <trans-unit id="883ef441e28a9d839f80a61f11348168ebf17cd9" translate="yes" xml:space="preserve">
          <source>If you have a raw sequence of bytes that you know should be interpreted via a particular encoding, you can use &lt;code&gt;Encode&lt;/code&gt; :</source>
          <target state="translated">特定のエンコーディングを介して解釈する必要があることがわかっている未加工のバイトシーケンスがある場合は、 &lt;code&gt;Encode&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="5b4a02619440b043ea55b1e3e613964a4f9957c4" translate="yes" xml:space="preserve">
          <source>If you have a raw sequence of bytes that you know should be interpreted via a particular encoding, you can use &lt;code&gt;Encode&lt;/code&gt;:</source>
          <target state="translated">特定のエンコーディングを介して解釈する必要があることがわかっている生のバイトシーケンスがある場合は、 &lt;code&gt;Encode&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="4977b6a1b7796edc98abe66364bdbf5af8c6caa8" translate="yes" xml:space="preserve">
          <source>If you have a really hairy regular expression, use the &lt;code&gt;/x&lt;/code&gt; modifier and put in some whitespace to make it look a little less like line noise. Don't use slash as a delimiter when your regexp has slashes or backslashes.</source>
          <target state="translated">本当に毛深い正規表現を使用している場合は、 &lt;code&gt;/x&lt;/code&gt; 修飾子を使用して空白を入れ、ラインノイズのように見えないようにします。正規表現にスラッシュまたはバックスラッシュがある場合は、区切り文字としてスラッシュを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="df35f05fcbbff85a11dabd04bca96051a29d5068" translate="yes" xml:space="preserve">
          <source>If you have a really hairy regular expression, use the &lt;code&gt;/x&lt;/code&gt; or &lt;code&gt;/xx&lt;/code&gt; modifiers and put in some whitespace to make it look a little less like line noise. Don't use slash as a delimiter when your regexp has slashes or backslashes.</source>
          <target state="translated">非常に毛深い正規表現がある場合は、 &lt;code&gt;/x&lt;/code&gt; または &lt;code&gt;/xx&lt;/code&gt; 修飾子を使用し、空白を入れて、ラインノイズのように見えないようにします。正規表現にスラッシュまたはバックスラッシュがある場合は、区切り文字としてスラッシュを使用しないでください。</target>
        </trans-unit>
        <trans-unit id="c4670adaa2657eda2badbded5180916956105a77" translate="yes" xml:space="preserve">
          <source>If you have a sequence of bytes you &lt;b&gt;know&lt;/b&gt; is valid UTF-8, but Perl doesn't know it yet, you can make Perl a believer, too:</source>
          <target state="translated">有効なUTF-8であることが&lt;b&gt;わかって&lt;/b&gt;いるバイトシーケンスがあるが、Perlはまだそれを認識していない場合、Perlを信者にすることもできます。</target>
        </trans-unit>
        <trans-unit id="9756e7acda84539ead2e5f85f560f283b75aed93" translate="yes" xml:space="preserve">
          <source>If you have a single string that you want to check for &quot;equality in locale&quot; against several others, you might think you could gain a little efficiency by using &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; in conjunction with &lt;code&gt;eq&lt;/code&gt; :</source>
          <target state="translated">「ロケールの等価性」を他のいくつかに対してチェックする単一の文字列がある場合、 &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; を &lt;code&gt;eq&lt;/code&gt; と組み合わせて使用すると、少し効率が上がると思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="f95d4b51e2c5877925e6bfc513dc2300a8f4721e" translate="yes" xml:space="preserve">
          <source>If you have a single string that you want to check for &quot;equality in locale&quot; against several others, you might think you could gain a little efficiency by using &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; in conjunction with &lt;code&gt;eq&lt;/code&gt;:</source>
          <target state="translated">「ロケールでの同等性」を他の複数の文字列と &lt;code&gt;POSIX::strxfrm()&lt;/code&gt; してチェックする単一の文字列がある場合、POSIX :: strxfrm（）を &lt;code&gt;eq&lt;/code&gt; ：と組み合わせて使用すると、少し効率が上がると思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="f645dc4bb8034c3799b831d6996356797ca7be48" translate="yes" xml:space="preserve">
          <source>If you have a small patch to submit, please submit it via perlbug. You can also send email directly to perlbug@perl.org. Please note that messages sent to perlbug may be held in a moderation queue, so you won't receive a response immediately.</source>
          <target state="translated">小さなパッチを提出する場合は、perlbug経由で提出してください。perlbug@perl.org に直接メールを送ることもできます。perlbug に送られたメッセージは、モデレーションキューに保留されている場合がありますので、すぐに返事が返ってくるわけではありませんのでご注意ください。</target>
        </trans-unit>
        <trans-unit id="6b5776918dce21a614ab7d2b6b104a983a49243a" translate="yes" xml:space="preserve">
          <source>If you have a small patch to submit, please submit it via the GitHub Pull Request workflow. You may also send patches to the p5p list.</source>
          <target state="translated">小さなパッチを提出したい場合は、GitHub Pull Request のワークフローから提出してください。また、p5pリストにパッチを送ることもできます。</target>
        </trans-unit>
        <trans-unit id="42845d8c8c875f89de9dd2d1b7586e0d3ad16bc8" translate="yes" xml:space="preserve">
          <source>If you have a specific romanization scheme in mind, use the specific module:</source>
          <target state="translated">特定のローマ字化スキームがある場合は、特定のモジュールを使用してください。</target>
        </trans-unit>
        <trans-unit id="fb355db0f3f4b40524a1c3ff445d923be623d546" translate="yes" xml:space="preserve">
          <source>If you have a working &lt;code&gt;DynaLoader&lt;/code&gt; then there is rarely any need to statically link in any other extensions.</source>
          <target state="translated">&lt;code&gt;DynaLoader&lt;/code&gt; が機能している場合は、他の拡張機能を静的にリンクする必要はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="fd5f81af8a4a7363d6132316fb90657fc9d4e232" translate="yes" xml:space="preserve">
          <source>If you have a zip file that contains multiple members and want to read a specific member from the file, say &lt;code&gt;&quot;data1&quot;&lt;/code&gt; , use the &lt;code&gt;Name&lt;/code&gt; option</source>
          <target state="translated">複数のメンバーを含むzipファイルがあり、そのファイルから特定のメンバーを読み取りたい場合（例： &lt;code&gt;&quot;data1&quot;&lt;/code&gt; ）、 &lt;code&gt;Name&lt;/code&gt; オプションを使用します</target>
        </trans-unit>
        <trans-unit id="6052cdbbf6fcaf2baac87ba7e1b86897c2e18ac9" translate="yes" xml:space="preserve">
          <source>If you have a zip file that contains multiple members and want to read a specific member from the file, say &lt;code&gt;&quot;data1&quot;&lt;/code&gt;, use the &lt;code&gt;Name&lt;/code&gt; option</source>
          <target state="translated">複数のメンバーを含むzipファイルがあり、ファイルから特定のメンバー（ &lt;code&gt;&quot;data1&quot;&lt;/code&gt; など）を読み取りたい場合は、[ &lt;code&gt;Name&lt;/code&gt; ]オプションを使用します</target>
        </trans-unit>
        <trans-unit id="e8e60773a7086adcadd9997f1e4e60bf13f42c27" translate="yes" xml:space="preserve">
          <source>If you have an FTP proxy firewall (&lt;b&gt;NOT&lt;/b&gt; an HTTP or SOCKS firewall) then this value should be set to the firewall hostname. If your firewall does not listen to port 21, then this value should be set to &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; (eg &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt; )</source>
          <target state="translated">あなたがFTPプロキシファイアウォールを（持っている場合は&lt;b&gt;、NOT&lt;/b&gt; HTTPまたはSOCKSファイアウォール）、この値は、ファイアウォールのホスト名に設定する必要があります。ファイアウォールがポート21をリッスンしない場合、この値は &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; に設定する必要があります（例： &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="3ebb071202346598d9545555072b8cd9d0e64671" translate="yes" xml:space="preserve">
          <source>If you have an FTP proxy firewall (&lt;b&gt;NOT&lt;/b&gt; an HTTP or SOCKS firewall) then this value should be set to the firewall hostname. If your firewall does not listen to port 21, then this value should be set to &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; (eg &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt;)</source>
          <target state="translated">あなたがFTPプロキシファイアウォールを（持っている場合は&lt;b&gt;、NOT&lt;/b&gt; HTTPまたはSOCKSファイアウォール）、この値は、ファイアウォールのホスト名に設定する必要があります。ファイアウォールがポート21をリッスンしない場合、この値は &lt;code&gt;&quot;hostname:port&quot;&lt;/code&gt; 設定する必要があります（例： &lt;code&gt;&quot;hostname:99&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3a37d9c6262b12c7aa2b49bfbcebb4a375757d2e" translate="yes" xml:space="preserve">
          <source>If you have an SV and want to know what kind of data Perl thinks is stored in it, you can use the following macros to check the type of SV you have.</source>
          <target state="translated">SV を持っていて、Perl がどのようなデータが格納されているかを知りたい場合は、以下のマクロを使って SV の種類を調べることができます。</target>
        </trans-unit>
        <trans-unit id="2bc4f67186bf30ca57f017f1cea8612b943dd146" translate="yes" xml:space="preserve">
          <source>If you have an array of &lt;code&gt;@string&lt;/code&gt; that should be concatenated and then normalized, you can do like this:</source>
          <target state="translated">連結して正規化する必要がある &lt;code&gt;@string&lt;/code&gt; の配列がある場合は、次のようにできます。</target>
        </trans-unit>
        <trans-unit id="403ab04dd713d2cfe6f16d5487fb0193f691f18c" translate="yes" xml:space="preserve">
          <source>If you have an empty directory, you can use Perl's built-in &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt;. If the directory is not empty (so, no files or subdirectories), you either have to empty it yourself (a lot of work) or use a module to help you.</source>
          <target state="translated">空のディレクトリがある場合は、Perlの組み込み &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; を使用できます。ディレクトリが空でない場合（つまり、ファイルやサブディレクトリがない場合）、自分で空にする（多くの作業）か、モジュールを使用して支援する必要があります。</target>
        </trans-unit>
        <trans-unit id="e617c76fa41bca088e2fe925791d55bef7f3208c" translate="yes" xml:space="preserve">
          <source>If you have an empty directory, you can use Perl's built-in &lt;code&gt;rmdir&lt;/code&gt;. If the directory is not empty (so, with files or subdirectories), you either have to empty it yourself (a lot of work) or use a module to help you.</source>
          <target state="translated">空のディレクトリがある場合は、Perlの組み込み &lt;code&gt;rmdir&lt;/code&gt; を使用できます。ディレクトリが空でない場合（つまり、ファイルまたはサブディレクトリがある場合）、自分でディレクトリを空にするか（多くの作業）、モジュールを使用して支援する必要があります。</target>
        </trans-unit>
        <trans-unit id="6898ea8c69aa4a0ff2b81092a3457a58f7bdc010" translate="yes" xml:space="preserve">
          <source>If you have an existing inside-out class, simply making all hashes field hashes with no other change should make no difference. Through the calls to &lt;code&gt;refaddr&lt;/code&gt; or equivalent, the field hashes never get to see a reference and work like normal hashes. Your DESTROY (and CLONE) methods are still needed.</source>
          <target state="translated">既存のインサイドアウトクラスがある場合は、他の変更を加えずにすべてのハッシュフィールドハッシュを作成しても、違いはありません。 &lt;code&gt;refaddr&lt;/code&gt; または同等の関数を呼び出すことにより、フィールドハッシュは参照を取得できず、通常のハッシュのように機能します。DESTROY（およびCLONE）メソッドは引き続き必要です。</target>
        </trans-unit>
        <trans-unit id="03fcf475306c60d974596613b76c03a9f344e66a" translate="yes" xml:space="preserve">
          <source>If you have an older version of Perl, the &lt;code&gt;$^W&lt;/code&gt; variable (documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;) controls runtime warnings for a block:</source>
          <target state="translated">古いバージョンのPerlを使用している場合、 &lt;code&gt;$^W&lt;/code&gt; 変数（&lt;a href=&quot;perlvar&quot;&gt;perlvarに記載&lt;/a&gt;）がブロックのランタイム警告を制御します。</target>
        </trans-unit>
        <trans-unit id="55ec04844d40449455953b5a185c6050647bf370" translate="yes" xml:space="preserve">
          <source>If you have any other characters you need to escape, please install the &lt;code&gt;URI::Escape&lt;/code&gt; module from CPAN, and pre-encode your URI before passing it to &lt;code&gt;File::Fetch&lt;/code&gt; . You can read about the details of URIs and URI encoding here:</source>
          <target state="translated">エスケープする必要がある他の文字がある場合は、CPANから &lt;code&gt;URI::Escape&lt;/code&gt; モジュールをインストールし、URIを &lt;code&gt;File::Fetch&lt;/code&gt; に渡す前にプリエンコードしてください。URIとURIエンコーディングの詳細については、こちらをご覧ください。</target>
        </trans-unit>
        <trans-unit id="b3a311e2f3de5d8bd7b59c7e63cc0db7c3de9dbd" translate="yes" xml:space="preserve">
          <source>If you have any other characters you need to escape, please install the &lt;code&gt;URI::Escape&lt;/code&gt; module from CPAN, and pre-encode your URI before passing it to &lt;code&gt;File::Fetch&lt;/code&gt;. You can read about the details of URIs and URI encoding here:</source>
          <target state="translated">エスケープする必要のある他の文字がある場合は、CPANから &lt;code&gt;URI::Escape&lt;/code&gt; モジュールをインストールし、 &lt;code&gt;File::Fetch&lt;/code&gt; に渡す前にURIを事前にエンコードしてください。URIとURIエンコードの詳細については、次を参照してください。</target>
        </trans-unit>
        <trans-unit id="baafc393e6c194ed8ae0aabf8fee882236c21df9" translate="yes" xml:space="preserve">
          <source>If you have any suggested changes for this page, let me know. Please don't send me mail asking for help on how to install your modules. There are too many modules, and too few Orwants, for me to be able to answer or even acknowledge all your questions. Contact the module author instead, ask someone familiar with Perl on your operating system, or if all else fails, file a ticket at &lt;a href=&quot;https://rt.cpan.org/&quot;&gt;https://rt.cpan.org/&lt;/a&gt;.</source>
          <target state="translated">このページに提案された変更がある場合は、お知らせください。モジュールのインストール方法について助けを求めるメールを送らないでください。モジュールが多すぎて、Orwantsが少なすぎるため、すべての質問に答えたり、確認したりすることはできません。代わりに、モジュールの作成者に連絡するか、オペレーティングシステムのPerlに精通している人に尋ねるか、他のすべてが失敗した場合は、&lt;a href=&quot;https://rt.cpan.org/&quot;&gt;https：//rt.cpan.org/で&lt;/a&gt;チケットを提出してください。</target>
        </trans-unit>
        <trans-unit id="59ef038a12de814aa0cdf806e88e5a326fdaf2d5" translate="yes" xml:space="preserve">
          <source>If you have any suggested changes for this page, let me know. Please don't send me mail asking for help on how to install your modules. There are too many modules, and too few Orwants, for me to be able to answer or even acknowledge all your questions. Contact the module author instead, or post to comp.lang.perl.modules, or ask someone familiar with Perl on your operating system.</source>
          <target state="translated">このページの変更点があれば、私に教えてください。モジュールのインストール方法についてのヘルプを求めるメールを私に送らないでください。モジュールの数が多すぎて、Orwant の数が少なすぎて、あなたの質問にすべて答えることができませんし、 答えることすらできません。代わりにモジュールの作者に連絡するか、 comp.lang.perl.modules に投稿するか、Perl に詳しい人に聞いてみてください。</target>
        </trans-unit>
        <trans-unit id="e2545920681caa56966e901dca47f4688bdb95ac" translate="yes" xml:space="preserve">
          <source>If you have built this module with zlib &amp;gt;= 1.2.0, the &lt;code&gt;$eof&lt;/code&gt; parameter is ignored. You can still set it if you want, but it won't be used behind the scenes.</source>
          <target state="translated">このモジュールをzlib&amp;gt; = 1.2.0でビルドした場合、 &lt;code&gt;$eof&lt;/code&gt; パラメーターは無視されます。必要に応じて設定できますが、舞台裏では使用されません。</target>
        </trans-unit>
        <trans-unit id="bd7c754383786ab750ba8d8b8b5b2710b62cfc9e" translate="yes" xml:space="preserve">
          <source>If you have built this module with zlib 1.2.3 or better, two more CRC-related functions are available.</source>
          <target state="translated">このモジュールを zlib 1.2.3 以上でビルドした場合、さらに 2 つの CRC 関連の関数が利用できます。</target>
        </trans-unit>
        <trans-unit id="b49d178439aabd6902535000d809a8c4d8c6c0d0" translate="yes" xml:space="preserve">
          <source>If you have compile-time executable statements (such as code within BEGIN, UNITCHECK and CHECK blocks or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statements), these will</source>
          <target state="translated">コンパイル時の実行可能ステートメント（BEGIN、UNITCHECKおよびCHECKブロック内のコード、またはステートメントの &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ）がある場合、これらは</target>
        </trans-unit>
        <trans-unit id="23cdaab0976c373088c475389e1f28133a88c5c3" translate="yes" xml:space="preserve">
          <source>If you have compile-time executable statements (such as code within BEGIN, UNITCHECK and CHECK blocks or &lt;code&gt;use&lt;/code&gt; statements), these will</source>
          <target state="translated">コンパイル時の実行可能ステートメント（BEGIN、UNITCHECK、CHECKブロック内のコード、 &lt;code&gt;use&lt;/code&gt; ステートメントなど）がある場合、これらは</target>
        </trans-unit>
        <trans-unit id="4a053828197d3de496e658e2f64e31f462c0e7ce" translate="yes" xml:space="preserve">
          <source>If you have experience with other thread implementations, you might find that things aren't quite what you expect. It's very important to remember when dealing with Perl threads that</source>
          <target state="translated">他のスレッドの実装を経験したことがある人は、期待していたものと違うことに気づくかもしれません。Perl のスレッドを扱う際には、以下のことを覚えておくことが非常に重要です。</target>
        </trans-unit>
        <trans-unit id="0ffa35b58c4462159f2ea02872365ed984d54889" translate="yes" xml:space="preserve">
          <source>If you have found a bug with a non-standard port (one that was not part of the</source>
          <target state="translated">標準ではないポートでバグを発見した場合 (</target>
        </trans-unit>
        <trans-unit id="0e1af930aa8bf951949bff6fef33b900fd538735" translate="yes" xml:space="preserve">
          <source>If you have generated such a statically-linked executable by choice, then instead of saying &quot;&lt;code&gt;make test&lt;/code&gt; &quot;, you should say &quot;&lt;code&gt;make test_static&lt;/code&gt; &quot;. On systems that cannot build dynamically-loadable libraries at all, simply saying &quot;&lt;code&gt;make test&lt;/code&gt; &quot; is sufficient.</source>
          <target state="translated">そのような静的にリンクされた実行可能ファイルを選択して生成した場合、「 &lt;code&gt;make test&lt;/code&gt; 」と言う代わりに、「 &lt;code&gt;make test_static&lt;/code&gt; 」と言う必要があります。動的にロード可能なライブラリをまったく構築できないシステムでは、単に「 &lt;code&gt;make test&lt;/code&gt; 」と言うだけで十分です。</target>
        </trans-unit>
        <trans-unit id="23bdd0e95f3443590926733fe84eb18d18c20c8a" translate="yes" xml:space="preserve">
          <source>If you have generated such a statically-linked executable by choice, then instead of saying &quot;&lt;code&gt;make test&lt;/code&gt;&quot;, you should say &quot;&lt;code&gt;make test_static&lt;/code&gt;&quot;. On systems that cannot build dynamically-loadable libraries at all, simply saying &quot;&lt;code&gt;make test&lt;/code&gt;&quot; is sufficient.</source>
          <target state="translated">このような静的にリンクされた実行可能ファイルを選択して生成した場合は、「 &lt;code&gt;make test&lt;/code&gt; 」と言う代わりに、「 &lt;code&gt;make test_static&lt;/code&gt; 」と言う必要があります。単に「と言って、すべての動的にロード可能なライブラリを構築することができないシステムでは &lt;code&gt;make test&lt;/code&gt; 、」十分です。</target>
        </trans-unit>
        <trans-unit id="ea57a23a75f969a9e5ed037d598a374a300583a4" translate="yes" xml:space="preserve">
          <source>If you have gotten this far into the tutorial, you can probably guess what the different parts of the debugging output tell you. The first part</source>
          <target state="translated">チュートリアルをここまで読んでいただければ、デバッグ出力のさまざまな部分が何を示しているのか想像がつくと思います。最初の部分</target>
        </trans-unit>
        <trans-unit id="9d264a66a026ef716495bcfe67d5b82c2fd75d79" translate="yes" xml:space="preserve">
          <source>If you have installed a signal handler for &lt;code&gt;SIGCHLD&lt;/code&gt; , the value of &lt;code&gt;$?&lt;/code&gt; will usually be wrong outside that handler.</source>
          <target state="translated">&lt;code&gt;SIGCHLD&lt;/code&gt; のシグナルハンドラーをインストールしている場合、 &lt;code&gt;$?&lt;/code&gt; そのハンドラの外では通常間違っているでしょう。</target>
        </trans-unit>
        <trans-unit id="b8c96322abc1990a9be6677edc2fb6d0c6fb9d00" translate="yes" xml:space="preserve">
          <source>If you have installed a signal handler for &lt;code&gt;SIGCHLD&lt;/code&gt;, the value of &lt;code&gt;$?&lt;/code&gt; will usually be wrong outside that handler.</source>
          <target state="translated">&lt;code&gt;SIGCHLD&lt;/code&gt; のシグナルハンドラーをインストールした場合、 &lt;code&gt;$?&lt;/code&gt; の値は？通常、そのハンドラーの外では間違っています。</target>
        </trans-unit>
        <trans-unit id="d59e8efecc586326d2ab32c89e976a471be555e8" translate="yes" xml:space="preserve">
          <source>If you have installed extra libraries such as GDBM through Fink (in other words, you have libraries under</source>
          <target state="translated">Fink経由でGDBMなどの追加ライブラリをインストールしている場合(つまり</target>
        </trans-unit>
        <trans-unit id="30e77bf1c945abc2f9365943feb77a853899df5c" translate="yes" xml:space="preserve">
          <source>If you have loaded the &lt;a href=&quot;posix&quot;&gt;&lt;code&gt;POSIX&lt;/code&gt;&lt;/a&gt; module you can use the methods given in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; to call &lt;a href=&quot;posix#setlocale&quot;&gt;&lt;code&gt;POSIX::setlocale&lt;/code&gt;&lt;/a&gt; to safely change or query the locale (on systems where it is safe to do so), or you can use the new 5.28 function &lt;a href=&quot;perlapi#Perl_setlocale&quot;&gt;&quot;Perl_setlocale&quot; in perlapi&lt;/a&gt; instead, which is a drop-in replacement for the system &lt;a href=&quot;setlocale(3)&quot;&gt;&lt;code&gt;setlocale(3)&lt;/code&gt;&lt;/a&gt;, and handles single-threaded and multi-threaded applications transparently.</source>
          <target state="translated">&lt;a href=&quot;posix&quot;&gt; &lt;code&gt;POSIX&lt;/code&gt; &lt;/a&gt;モジュールをロードした場合は、&lt;a href=&quot;perlcall&quot;&gt;perlcallで&lt;/a&gt;指定されたメソッドを使用して&lt;a href=&quot;posix#setlocale&quot;&gt; &lt;code&gt;POSIX::setlocale&lt;/code&gt; &lt;/a&gt;を呼び出し、ロケールを安全に変更またはクエリできます（安全なシステムでは）。または、新しい5.28関数&lt;a href=&quot;perlapi#Perl_setlocale&quot;&gt;「Perl_setlocale」を&lt;/a&gt;使用できます。&quot;代わりにperlapiで、これはシステム&lt;a href=&quot;setlocale(3)&quot;&gt; &lt;code&gt;setlocale(3)&lt;/code&gt; の&lt;/a&gt;ドロップイン置換であり、シングルスレッドおよびマルチスレッドのアプリケーションを透過的に処理します。</target>
        </trans-unit>
        <trans-unit id="adf0535478f796f8c19ba9c98c90186d9fd4978f" translate="yes" xml:space="preserve">
          <source>If you have more than two files, this is the place where you should boot extra XS files from.</source>
          <target state="translated">2つ以上のファイルがある場合は、ここから余分なXSファイルを起動する必要があります。</target>
        </trans-unit>
        <trans-unit id="47f402ce95a3894708d131d4f57afb65a8408c3a" translate="yes" xml:space="preserve">
          <source>If you have neither Net::FTP nor LWP, there is a fallback mechanism implemented for an external ftp command or for an external lynx command.</source>
          <target state="translated">Net::FTP も LWP も持っていない場合、外部 ftp コマンドや外部 lynx コマンドのフォールバック機構が実装されている。</target>
        </trans-unit>
        <trans-unit id="24c715fba81da2278914f96579f9af2c125fe732" translate="yes" xml:space="preserve">
          <source>If you have never been to a hackathon, here are a few basic things you need to know before attending: have a working laptop and know how to use it; check out the involved projects beforehand; have the necessary version control client; and bring backup equipment (an extra LAN cable, additional power strips, etc.) because someone will forget.</source>
          <target state="translated">ハッカソンに参加したことがない人は、参加する前に知っておくべき基本的なことをいくつか紹介します:動作するノートパソコンとその使い方を知っていること、関連するプロジェクトを事前にチェックしておくこと、必要なバージョン管理クライアントを持っていること、そして誰かが忘れてしまうのでバックアップ機器(追加のLANケーブル、追加の電源タップなど)を持っていくこと。</target>
        </trans-unit>
        <trans-unit id="1eb2a3bd6bb2269e089bc5caced075f60ca01d0a" translate="yes" xml:space="preserve">
          <source>If you have never defined your own &lt;code&gt;urllist&lt;/code&gt; in your configuration then &lt;code&gt;CPAN.pm&lt;/code&gt; will be hesitant to use the built in default sites for downloading. It will ask you once per session if a connection to the internet is OK and only if you say yes, it will try to connect. But to avoid this question, you can choose your favorite download sites once and get away with it. Or, if you have no favorite download sites answer yes to the following question.</source>
          <target state="translated">構成で独自の &lt;code&gt;urllist&lt;/code&gt; を定義したことがない場合、 &lt;code&gt;CPAN.pm&lt;/code&gt; は組み込みのデフォルトサイトをダウンロードに使用することをためらいます。インターネットへの接続に問題がないかどうか、セッションごとに1回尋ねられます。「はい」と答えた場合のみ、接続を試みます。しかし、この質問を回避するために、お気に入りのダウンロードサイトを一度選択して、それを回避することができます。または、お気に入りのダウンロードサイトがない場合は、次の質問に「はい」と答えてください。</target>
        </trans-unit>
        <trans-unit id="4eb5903dce5dded96414f72da47519a1cbbb4440" translate="yes" xml:space="preserve">
          <source>If you have never uploaded a module to CPAN before (and even if you have), you are strongly encouraged to get feedback on &lt;a href=&quot;http://prepan.org&quot;&gt;PrePAN&lt;/a&gt;. PrePAN is a site dedicated to discussing ideas for CPAN modules with other Perl developers and is a great resource for new (and experienced) Perl developers.</source>
          <target state="translated">これまでにモジュールをCPANにアップロードしたことがない場合（アップロードした場合でも）、&lt;a href=&quot;http://prepan.org&quot;&gt;PrePAN&lt;/a&gt;に関するフィードバックを入手することを強くお勧めします。PrePANは、他のPerl開発者とCPANモジュールのアイデアについて話し合うための専用サイトであり、新しい（そして経験豊富な）Perl開発者にとって素晴らしいリソースです。</target>
        </trans-unit>
        <trans-unit id="7a84d97dce110800ef0a7f4d11d992d7a0415274" translate="yes" xml:space="preserve">
          <source>If you have never uploaded a module to CPAN before (and even if you have), you are strongly encouraged to get feedback on &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fprepan.org&quot;&gt;PrePAN&lt;/a&gt;. PrePAN is a site dedicated to discussing ideas for CPAN modules with other Perl developers and is a great resource for new (and experienced) Perl developers.</source>
          <target state="translated">これまでにCPANにモジュールをアップロードしたことがない場合は（アップロードしたことがある場合でも）、&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fprepan.org&quot;&gt;PrePAN&lt;/a&gt;に関するフィードバックを取得することを強くお勧めします。PrePANは、CPANモジュールのアイデアを他のPerl開発者と議論するための専用サイトであり、新しい（そして経験豊富な）Perl開発者にとって素晴らしいリソースです。</target>
        </trans-unit>
        <trans-unit id="69b676873a6496894a8ce65e0d6abefddf731b2d" translate="yes" xml:space="preserve">
          <source>If you have not guessed it yet, the</source>
          <target state="translated">まだお察しになっていない方は</target>
        </trans-unit>
        <trans-unit id="eb6ae544b0243a12b93b26e3f0b3956b5515717f" translate="yes" xml:space="preserve">
          <source>If you have one of the readline packages (Term::ReadLine::Perl, Term::ReadLine::Gnu, possibly others) installed, the interactive CPAN shell will have history support. The next two questions deal with the filename of the history file and with its size. If you do not want to set this variable, please hit SPACE ENTER to the following question.</source>
          <target state="translated">readlineパッケージ(Term::ReadLine::Perl、Term::ReadLine::Gnu、場合によってはその他)のいずれかがインストールされている場合、対話型CPANシェルは履歴をサポートしている。次の2つの質問では、履歴ファイルのファイル名とサイズを扱う。この変数を設定したくない場合は、SPACE ENTERを押して次の質問に進んでください。</target>
        </trans-unit>
        <trans-unit id="bb7b55bdb52c9b6a39041d0271244a521cb3ff47" translate="yes" xml:space="preserve">
          <source>If you have perl documentation in the source form, perl utilities installed, and GNU groff installed, you may use</source>
          <target state="translated">ソースコードに perl ドキュメントがあり、Perl ユーティリティがインストールされていて、GNU groff がインストールされている場合は</target>
        </trans-unit>
        <trans-unit id="841004095d25b3d59f531a821f770d0871403ca9" translate="yes" xml:space="preserve">
          <source>If you have previously used &lt;code&gt;Compress::Zlib&lt;/code&gt; 1.x, the following enhancements/changes have been made to the &lt;code&gt;gzopen&lt;/code&gt; interface:</source>
          <target state="translated">以前に &lt;code&gt;Compress::Zlib&lt;/code&gt; 1.xを使用したことがある場合、 &lt;code&gt;gzopen&lt;/code&gt; インターフェースに以下の拡張機能/変更が加えられています。</target>
        </trans-unit>
        <trans-unit id="d0935b429ee79675810171542b17a2b721980e73" translate="yes" xml:space="preserve">
          <source>If you have problems with dynamic loading using gcc on SunOS or Solaris, and you are using GNU as and GNU ld, see the section &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;&quot;GNU as and GNU ld&quot;&lt;/a&gt; above.</source>
          <target state="translated">SunOSまたはSolarisでgccを使用した動的ロードに問題があり、GNUasおよびGNUldを使用している場合は、上記の&lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;「GNUasおよびGNUld」の&lt;/a&gt;セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="d2a37b8d2199c6cd81ec323e698311d35b1e6c13" translate="yes" xml:space="preserve">
          <source>If you have problems with dynamic loading using gcc on SunOS or Solaris, and you are using GNU as and GNU ld, see the section &lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNU as and GNU ld&lt;/a&gt; above.</source>
          <target state="translated">あなたはSunOSのまたはSolaris上のgccを使用して動的ロードに問題がある、とあなたのようにGNUを使用していて、GNU ldの場合は、セクションを参照&lt;a href=&quot;#GNU-as-and-GNU-ld&quot;&gt;GNUなどとGNU LDを&lt;/a&gt;上に。</target>
        </trans-unit>
        <trans-unit id="ea5710225473b92c4d4337a393fa28ea045d7828" translate="yes" xml:space="preserve">
          <source>If you have questions about DJGPP, try posting to the DJGPP newsgroup: comp.os.msdos.djgpp, or use the email gateway djgpp@delorie.com.</source>
          <target state="translated">DJGPP について質問がある場合は、DJGPP ニュースグループ:comp.os.msdos.djgpp に投稿するか、電子メールゲートウェイ djgpp@delorie.com を使用してみてください。</target>
        </trans-unit>
        <trans-unit id="fe0f8d11e3dbd4746ff7b4eeb245a0d52d534f6e" translate="yes" xml:space="preserve">
          <source>If you have questions, I will be happy to answer them if you send them to mjd-perl-memoize+@plover.com.</source>
          <target state="translated">質問があれば、mjd-perl-memoize+@plover.comまで送っていただければ、お答えできると思います。</target>
        </trans-unit>
        <trans-unit id="f26f03ce6e7bfe1cbb7f3ba37413ced07d1e0917" translate="yes" xml:space="preserve">
          <source>If you have read this far, congratulations! You now have all the basic tools needed to use regular expressions to solve a wide range of text processing problems. If this is your first time through the tutorial, why not stop here and play around with regexps a while.... Part 2 concerns the more esoteric aspects of regular expressions and those concepts certainly aren't needed right at the start.</source>
          <target state="translated">ここまで読んでくださった方、おめでとうございます。これで、正規表現を使って様々なテキスト処理の問題を解決するために必要な基本的なツールがすべて揃ったことになります。チュートリアルを初めてご覧になる方は、ここで止めて正規表現を使ってしばらく遊んでみてはいかがでしょうか。パート2では、正規表現のより難解な側面について説明します。</target>
        </trans-unit>
        <trans-unit id="3d2bd9a5983ab6b077a9576a5fb009ebd58ad9d0" translate="yes" xml:space="preserve">
          <source>If you have received a patch file generated using the above section, you should try out the patch.</source>
          <target state="translated">上記の項目で生成されたパッチファイルを受け取った方は、ぜひ試してみてください。</target>
        </trans-unit>
        <trans-unit id="75f3eda9f9b422ec46068b583597695f9e1e075d" translate="yes" xml:space="preserve">
          <source>If you have some WWW browser available, installed the Perl documentation in the source form, and Perl utilities, you can build HTML docs. Cd to directory with</source>
          <target state="translated">WWWブラウザが利用可能で、Perlのドキュメントをソース形式でインストールし、Perlのユーティリティをインストールしておけば、HTMLドキュメントを構築することができます。のあるディレクトリにCdしてください。</target>
        </trans-unit>
        <trans-unit id="15919d939102f998b0d1a3071b0bdc4ec9361810" translate="yes" xml:space="preserve">
          <source>If you have some WWW browser available, you can build &lt;b&gt;HTML&lt;/b&gt; docs. Cd to directory with</source>
          <target state="translated">使用可能なWWWブラウザーがある場合は、&lt;b&gt;HTML&lt;/b&gt;ドキュメントを作成でき&lt;b&gt;ます&lt;/b&gt;。cd to directory to</target>
        </trans-unit>
        <trans-unit id="760a427c6aacab9e74e50c0e342e67f06ea0a89d" translate="yes" xml:space="preserve">
          <source>If you have some working code for &lt;code&gt;OS2::Cmd&lt;/code&gt; , please send it to me, I will include it into distribution. I have no need for such a module, so cannot test it.</source>
          <target state="translated">&lt;code&gt;OS2::Cmd&lt;/code&gt; 動作するコードがある場合は、私に送信してください。配布に含めます。そのようなモジュールは必要ないので、テストできません。</target>
        </trans-unit>
        <trans-unit id="92b80366e1063cc2e2041c74ed4ea55af2ea445a" translate="yes" xml:space="preserve">
          <source>If you have some working code for &lt;code&gt;OS2::Cmd&lt;/code&gt;, please send it to me, I will include it into distribution. I have no need for such a module, so cannot test it.</source>
          <target state="translated">&lt;code&gt;OS2::Cmd&lt;/code&gt; 動作するコードがある場合は、私に送ってください。配布に含めます。私はそのようなモジュールを必要としないので、それをテストすることはできません。</target>
        </trans-unit>
        <trans-unit id="c766c1d4e406f5a8fab49e64104f5bd544a7e67b" translate="yes" xml:space="preserve">
          <source>If you have test cases that fail, check for the existence of spool files. The test case may be trying to use a syscall that is not implemented in PASE. To avoid the SIGILL, try setting the PASE_SYSCALL_NOSIGILL environment variable or have a handler for the SIGILL. If you can compile programs for PASE, run the config script and edit config.sh when it gives you the option. If you want to remove fchdir(), which isn't implement in V5R1, simply change the line that says:</source>
          <target state="translated">テストケースが失敗する場合は、スプールファイルが存在するかどうかを確認してください。テストケースはPASEで実装されていないsyscallを使おうとしている可能性があります。SIGILLを回避するには、環境変数PASE_SYSCALL_NOSIGILLを設定するか、SIGILL用のハンドラを用意してみてください。PASE用のプログラムをコンパイルできるのであれば、configスクリプトを実行し、オプションが与えられたらconfig.shを編集してください。V5R1 で実装されていない fchdir()を削除したい場合は、以下の行を変更してください。</target>
        </trans-unit>
        <trans-unit id="c895956df28d2a0d520a665ed39e5054b694f69f" translate="yes" xml:space="preserve">
          <source>If you have the &lt;code&gt;Kwalify&lt;/code&gt; module installed (which is part of the Bundle::CPANxxl), then all your distroprefs files are checked for syntactic correctness.</source>
          <target state="translated">&lt;code&gt;Kwalify&lt;/code&gt; モジュール（Bundle :: CPANxxlの一部）がインストールされている場合、すべてのdistroprefsファイルの構文が正しいかどうかがチェックされます。</target>
        </trans-unit>
        <trans-unit id="310e2cf6fe93a96344e5f48617c55b650052b357" translate="yes" xml:space="preserve">
          <source>If you have the &lt;code&gt;uncompress&lt;/code&gt; program available, you can use this to read compressed files</source>
          <target state="translated">あなたが持っている場合は &lt;code&gt;uncompress&lt;/code&gt; プログラムが利用可能に、あなたは圧縮されたファイルを読むためにこれを使用することができます</target>
        </trans-unit>
        <trans-unit id="a48f13710ced892050924fc9519945fba0fac1d0" translate="yes" xml:space="preserve">
          <source>If you have the GNU's version of &lt;b&gt;emacs&lt;/b&gt; installed on your system, it can interact with the Perl debugger to provide an integrated software development environment reminiscent of its interactions with C debuggers.</source>
          <target state="translated">システムにGNUバージョンの&lt;b&gt;emacsが&lt;/b&gt;インストールされている場合、Perlデバッガーと対話して、Cデバッガーとの対話を連想させる統合ソフトウェア開発環境を提供できます。</target>
        </trans-unit>
        <trans-unit id="831bd1aa0f0b4a83cdb4f8d8c798aaee5e24ba5d" translate="yes" xml:space="preserve">
          <source>If you have the LD_LIBRARY_PATH environment variable set, be sure that it does NOT include /lib or /usr/lib. If you will be building extensions that call third-party shared libraries (e.g. Berkeley DB) then make sure that your LD_LIBRARY_PATH environment variable includes the directory with that library (e.g. /usr/local/lib).</source>
          <target state="translated">LD_LIBRARY_PATH 環境変数が設定されている場合は、/lib や /usr/lib が含まれていないことを確認してください。サードパーティの共有ライブラリ (例:Berkeley DB)を呼び出す拡張機能をビルドする場合は、LD_LIBRARY_PATH 環境変数にそのライブラリのあるディレクトリ (例:/usr/local/lib)が含まれていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="483a6567552062a96a05353738254e25f5829f05" translate="yes" xml:space="preserve">
          <source>If you have the earlier ports perl 5.16 or 5.8 installed you may like to rename your perl executable to perl516 or perl58 or something similar before the installation of 5.22.1, this will allow you to use both versions at the same time.</source>
          <target state="translated">以前のバージョンの perl 5.16 や 5.8 がインストールされている場合は、5.22.1 をインストールする前に perl 実行ファイルの名前を perl516 や perl58 などに変更した方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="7b99419c67def721d2695cd48d34dc88cb8c781c" translate="yes" xml:space="preserve">
          <source>If you have to deal with a lot of C structures, and don't want to hack all your template strings manually, you'll probably want to have a look at the CPAN module &lt;code&gt;Convert::Binary::C&lt;/code&gt; . Not only can it parse your C source directly, but it also has built-in support for all the odds and ends described further on in this section.</source>
          <target state="translated">多くのC構造体を扱う必要があり、すべてのテンプレート文字列を手動でハックしたくない場合は、CPANモジュール &lt;code&gt;Convert::Binary::C&lt;/code&gt; 確認することをお勧めします。Cソースを直接解析できるだけでなく、このセクションでさらに説明するすべてのオッズとエンドの組み込みサポートも備えています。</target>
        </trans-unit>
        <trans-unit id="20f202512374709bcbdf3d36e09a30c2730f3952" translate="yes" xml:space="preserve">
          <source>If you have to deal with a lot of C structures, and don't want to hack all your template strings manually, you'll probably want to have a look at the CPAN module &lt;code&gt;Convert::Binary::C&lt;/code&gt;. Not only can it parse your C source directly, but it also has built-in support for all the odds and ends described further on in this section.</source>
          <target state="translated">多くのC構造体を処理する必要があり、すべてのテンプレート文字列を手動でハックしたくない場合は、CPANモジュール &lt;code&gt;Convert::Binary::C&lt;/code&gt; 確認することをお勧めします。Cソースを直接解析できるだけでなく、このセクションでさらに説明するすべてのオッズとエンドのサポートが組み込まれています。</target>
        </trans-unit>
        <trans-unit id="fedff50b6bdfc3eaf8ccc29c03df5c84e0ff6a06" translate="yes" xml:space="preserve">
          <source>If you have trouble compiling the scripts in this documentation, you're not alone. The cardinal rule: COMPILE THE PROGRAMS IN EXACTLY THE SAME WAY THAT YOUR PERL WAS COMPILED. (Sorry for yelling.)</source>
          <target state="translated">このドキュメントのスクリプトのコンパイルに問題がある場合は、あなただけではありません。基本的なルールです。あなたのperlがコンパイルされたのと全く同じ方法でプログラムをコンパイルしてください。(怒鳴ってごめんなさい)</target>
        </trans-unit>
        <trans-unit id="899489485e48eb6acab0142eabbf325712e8b44a" translate="yes" xml:space="preserve">
          <source>If you have updated your Solaris version, you may also have to update your gcc. For example, if you are running Solaris 2.6 and your gcc is installed under /usr/local, check in /usr/local/lib/gcc-lib and make sure you have the appropriate directory, sparc-sun-solaris2.6/ or i386-pc-solaris2.6/. If gcc's directory is for a different version of Solaris than you are running, then you will need to rebuild gcc for your new version of Solaris.</source>
          <target state="translated">Solaris のバージョンを更新した場合、gcc も更新する必要があるかもしれません。例えば、Solaris 2.6 を実行していて、gcc が /usr/local にインストールされている場合、/usr/local/lib/gcc-lib をチェックして、適切なディレクトリ (sparc-sun-solaris2.6/または i386-pc-solaris2.6/)があることを確認してください。 gcc のディレクトリが実行している Solaris のバージョンと異なる場合は、新しいバージョンの Solaris 用に gcc を再構築する必要があります。</target>
        </trans-unit>
        <trans-unit id="61a8da0f8f7da9cf9cae8a262e98843a7815ba5c" translate="yes" xml:space="preserve">
          <source>If you have used a decimal $VERSION in the past and wish to switch to a dotted-decimal $VERSION, then you need to make a one-time conversion to the new format.</source>
          <target state="translated">過去に 10 進 $VERSION を使用していて、dotted-decimal $VERSION に切り替えたい場合は、新しいフォーマットへの変換を一度だけ行う必要があります。</target>
        </trans-unit>
        <trans-unit id="e5baa162c1dcd052bd0eee802b13bec96e916c96" translate="yes" xml:space="preserve">
          <source>If you have written a test module based on Test::Builder then Test::Tester allows you to test it with the minimum of effort.</source>
          <target state="translated">Test::Builder をベースにテストモジュールを書いている場合、Test::Tester は最小限の労力でテストを行うことができます。</target>
        </trans-unit>
        <trans-unit id="d44abb6ca108f95533f7bd86193633f514940a80" translate="yes" xml:space="preserve">
          <source>If you have your perl compiled for debugging (usually done with &lt;code&gt;-DDEBUGGING&lt;/code&gt; on the &lt;code&gt;Configure&lt;/code&gt; command line), you may examine the compiled tree by specifying &lt;code&gt;-Dx&lt;/code&gt; on the Perl command line. The output takes several lines per node, and for &lt;code&gt;$b+$c&lt;/code&gt; it looks like this:</source>
          <target state="translated">デバッグ用にperlをコンパイルしている場合（通常、 &lt;code&gt;Configure&lt;/code&gt; コマンドラインで &lt;code&gt;-DDEBUGGING&lt;/code&gt; を使用して行われます）、Perlコマンドラインで &lt;code&gt;-Dx&lt;/code&gt; を指定して、コンパイルしたツリーを調べることができます。出力はノードごとに数行かかり、 &lt;code&gt;$b+$c&lt;/code&gt; 場合は次のようになります。</target>
        </trans-unit>
        <trans-unit id="4be3c9c74002e27258a38e4f113b05f31396c7de" translate="yes" xml:space="preserve">
          <source>If you haven't already guessed, the location string is stored with a terminating NULL. This means you need to be careful when accessing the database.</source>
          <target state="translated">まだ推測していないのであれば、場所の文字列は終端のNULLで格納されています。つまり、データベースにアクセスする際には注意が必要です。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
