<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="9adb69905ef42f7e50e2708e20623f57aec71e19" translate="yes" xml:space="preserve">
          <source>In a Perl version number such as 5.6.2, this is the 6. This value is manually set in</source>
          <target state="translated">5.6.2のようなPerlのバージョン番号では、これは6です。 この値は手動で</target>
        </trans-unit>
        <trans-unit id="00e75241de38f496d3e98c78e65b223be163fce0" translate="yes" xml:space="preserve">
          <source>In a UTF-8 locale in v5.20 and later, the only visible difference between locale and non-locale in regular expressions should be tainting (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;).</source>
          <target state="translated">v5.20以降のUTF-8ロケールでは、正規表現でのロケールと非ロケールの目に見える唯一の違いは汚染であるはずです（&lt;a href=&quot;perlsec&quot;&gt;perlsecを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="684ae84268e30b89f35130d6bd4027aeb36b7294" translate="yes" xml:space="preserve">
          <source>In a bracketed character class in a regular expression pattern, you had a range which has exactly one end of it specified using &lt;code&gt;\N{}&lt;/code&gt; , and the other end is specified using a non-portable mechanism. Perl treats the range as a Unicode range, that is, all the characters in it are considered to be the Unicode characters, and which may be different code points on some platforms Perl runs on. For example, &lt;code&gt;[\N{U+06}-\x08]&lt;/code&gt; is treated as if you had instead said &lt;code&gt;[\N{U+06}-\N{U+08}]&lt;/code&gt; , that is it matches the characters whose code points in Unicode are 6, 7, and 8. But that &lt;code&gt;\x08&lt;/code&gt; might indicate that you meant something different, so the warning gets raised.</source>
          <target state="translated">正規表現パターン内の括弧で囲まれた文字クラスで、範囲の一端が &lt;code&gt;\N{}&lt;/code&gt; を使用して指定され、他端が移植できないメカニズムを使用して指定されていました。Perlはその範囲をUnicode範囲として扱います。つまり、その範囲内のすべての文字はUnicode文字と見なされ、Perlが実行されるプラットフォームによってはコードポイントが異なる場合があります。たとえば、 &lt;code&gt;[\N{U+06}-\x08]&lt;/code&gt; は、代わりに &lt;code&gt;[\N{U+06}-\N{U+08}]&lt;/code&gt; と言ったかのように扱われます。つまり、コードポイントの文字と一致しますUnicodeでは &lt;code&gt;\x08&lt;/code&gt; が、\ x08は別の意味を示している可能性があるため、警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="56b5f943e2723e6656ff71443d600b126557a979" translate="yes" xml:space="preserve">
          <source>In a bracketed character class in a regular expression pattern, you had a range which has exactly one end of it specified using &lt;code&gt;\N{}&lt;/code&gt;, and the other end is specified using a non-portable mechanism. Perl treats the range as a Unicode range, that is, all the characters in it are considered to be the Unicode characters, and which may be different code points on some platforms Perl runs on. For example, &lt;code&gt;[\N{U+06}-\x08]&lt;/code&gt; is treated as if you had instead said &lt;code&gt;[\N{U+06}-\N{U+08}]&lt;/code&gt;, that is it matches the characters whose code points in Unicode are 6, 7, and 8. But that &lt;code&gt;\x08&lt;/code&gt; might indicate that you meant something different, so the warning gets raised.</source>
          <target state="translated">正規表現パターンの括弧で囲まれた文字クラスに、 &lt;code&gt;\N{}&lt;/code&gt; を使用して指定された範囲の一方の端があり、もう一方の端は移植性のないメカニズムを使用して指定されています。Perlは範囲をUnicode範囲として扱います。つまり、その中のすべての文字はUnicode文字と見なされ、Perlが実行される一部のプラットフォームでは異なるコードポイントになる場合があります。たとえば、 &lt;code&gt;[\N{U+06}-\x08]&lt;/code&gt; は、代わりに &lt;code&gt;[\N{U+06}-\N{U+08}]&lt;/code&gt; と言ったかのように扱われます。つまり、コードポイントを持つ文字と一致します。 Unicodeでは6、7、および8です。ただし、 &lt;code&gt;\x08&lt;/code&gt; は別の意味を示している可能性があるため、警告が発生します。</target>
        </trans-unit>
        <trans-unit id="94d73a68cf480ae509179c7a8fbc1f901fa2e9db" translate="yes" xml:space="preserve">
          <source>In a chained comparison, each argument expression is evaluated at most once, even if it takes part in two comparisons, but the result of the evaluation is fetched for each comparison. (It is not evaluated at all if the short-circuiting means that it's not required for any comparisons.) This matters if the computation of an interior argument is expensive or non-deterministic. For example,</source>
          <target state="translated">連鎖比較では、各引数式は2つの比較に参加する場合でも最大1回評価されますが、評価結果は各比較ごとにフェッチされます。(短絡しているため、どの比較にも必要とされない場合は全く評価されません)。これは、内引数の計算が高価であったり、非決定論的であったりする場合に重要です。例えば</target>
        </trans-unit>
        <trans-unit id="1004ce202059ee590c51b52b194413677ea17ca4" translate="yes" xml:space="preserve">
          <source>In a context not requiring a list value, the value of what appears to be a list literal is simply the value of the final element, as with the C comma operator. For example,</source>
          <target state="translated">リスト値を必要としないコンテキストでは、リストリテラルのように見えるものの値は、Cのカンマ演算子のように、単に最後の要素の値です。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c0a278d73a0b72613c40dbe8d0193bd356d40954" translate="yes" xml:space="preserve">
          <source>In a first-hack implementation of Maketext, each language-module's lexicon looked like this:</source>
          <target state="translated">Maketext のファーストハック実装では、各言語モジュールの辞書は以下のようになっていました。</target>
        </trans-unit>
        <trans-unit id="4c9fb939bd1697123252f0ff4192d8603d7b42ba" translate="yes" xml:space="preserve">
          <source>In a future version of Storable, we intend to provide options to disable loading modules for classes and to disable deserializing objects altogether.</source>
          <target state="translated">Storable の将来のバージョンでは、クラスのモジュールの読み込みを無効にしたり、オブジェクトのデシリアライズを完全に無効にしたりするオプションを提供する予定です。</target>
        </trans-unit>
        <trans-unit id="7f48268e7084e302cd8de3636cf3c45d91f67d83" translate="yes" xml:space="preserve">
          <source>In a list context it returns a list of all the operator names. (Not yet implemented, use @names = opset_to_ops(full_opset).)</source>
          <target state="translated">リストコンテキストでは、すべての演算子名のリストを返します。(まだ実装されていませんが、 @names=opset_to_ops(full_opset)を使用してください)。</target>
        </trans-unit>
        <trans-unit id="b5d9986ae8bd12e0cac8222f9f5aeaf66d07a75b" translate="yes" xml:space="preserve">
          <source>In a list context it returns the inflation object, &lt;code&gt;$i&lt;/code&gt; , and the</source>
          <target state="translated">リストコンテキストでは、インフレオブジェクト &lt;code&gt;$i&lt;/code&gt; と</target>
        </trans-unit>
        <trans-unit id="a2be3d9cfb3783d19a27056a4954efa7988e1874" translate="yes" xml:space="preserve">
          <source>In a list context it returns the inflation object, &lt;code&gt;$i&lt;/code&gt;, and the</source>
          <target state="translated">リストコンテキストでは、インフレオブジェクト、 &lt;code&gt;$i&lt;/code&gt; 、および</target>
        </trans-unit>
        <trans-unit id="145c4668502bd10d7409835c5418f6cbabe20a25" translate="yes" xml:space="preserve">
          <source>In a list context it returns the inflation stream, &lt;code&gt;$i&lt;/code&gt; , and the</source>
          <target state="translated">リストコンテキストでは、インフレストリーム &lt;code&gt;$i&lt;/code&gt; と</target>
        </trans-unit>
        <trans-unit id="19840bfce1f7d4562308d36f49b5b530cfea492a" translate="yes" xml:space="preserve">
          <source>In a list context it returns the inflation stream, &lt;code&gt;$i&lt;/code&gt;, and the</source>
          <target state="translated">リストコンテキストでは、インフレストリーム、 &lt;code&gt;$i&lt;/code&gt; 、および</target>
        </trans-unit>
        <trans-unit id="1cf4f84fa82dd8ae218d529ba322249a8b367063" translate="yes" xml:space="preserve">
          <source>In a list context, &lt;code&gt;extract_quotelike&lt;/code&gt; would return the list</source>
          <target state="translated">リストのコンテキストでは、 &lt;code&gt;extract_quotelike&lt;/code&gt; はリストを返します</target>
        </trans-unit>
        <trans-unit id="7602890513e241f884402d4ec0723dbc5ab2f461" translate="yes" xml:space="preserve">
          <source>In a list context, all the functions return &lt;code&gt;(&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;,$original_text)&lt;/code&gt; on failure. In a scalar context, failure is indicated by returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (in this case the input text is not modified in any way).</source>
          <target state="translated">リストコンテキストでは、すべての関数が失敗すると &lt;code&gt;(&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;,$original_text)&lt;/code&gt; を返します。スカラーコンテキストでは、失敗は &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返すことで示されます（この場合、入力テキストはまったく変更されません）。</target>
        </trans-unit>
        <trans-unit id="d4b6138bd9c8bc770c89fa1734f707bd100e5c6b" translate="yes" xml:space="preserve">
          <source>In a list context, all the functions return &lt;code&gt;(undef,$original_text)&lt;/code&gt; on failure. In a scalar context, failure is indicated by returning &lt;code&gt;undef&lt;/code&gt; (in this case the input text is not modified in any way).</source>
          <target state="translated">リストコンテキストでは、失敗するとすべての関数が &lt;code&gt;(undef,$original_text)&lt;/code&gt; を返します。スカラーコンテキストでは、失敗は &lt;code&gt;undef&lt;/code&gt; を返すことで示されます（この場合、入力テキストは変更されません）。</target>
        </trans-unit>
        <trans-unit id="9a94ef45d6203b10b750123aea4390fcb5b00e20" translate="yes" xml:space="preserve">
          <source>In a list context, all the subroutines return a list, the first three elements of which are always:</source>
          <target state="translated">リストコンテキストでは、すべてのサブルーチンはリストを返します。</target>
        </trans-unit>
        <trans-unit id="f3d0f0be64532af27f8e2b721243720c0db92d9a" translate="yes" xml:space="preserve">
          <source>In a list context, an array of 11 elements is returned. The elements are:</source>
          <target state="translated">リストコンテキストでは、11 個の要素からなる配列が返されます。要素は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="908708042ec2a982cddb96ed31208bb8910e08cf" translate="yes" xml:space="preserve">
          <source>In a nutshell, this will check whether the output code involves calling &lt;code&gt;sv_setiv&lt;/code&gt;, &lt;code&gt;sv_setuv&lt;/code&gt;, &lt;code&gt;sv_setnv&lt;/code&gt;, &lt;code&gt;sv_setpv&lt;/code&gt; or &lt;code&gt;sv_setpvn&lt;/code&gt; to set the special &lt;code&gt;$arg&lt;/code&gt; placeholder to a new value &lt;b&gt;AT THE END OF THE OUTPUT CODE&lt;/b&gt;. If that is the case, the code is eligible for using the &lt;code&gt;TARG&lt;/code&gt;-related macros to optimize this. Thus the name of the method: &lt;code&gt;targetable&lt;/code&gt;.</source>
          <target state="translated">一言で言えば、これは、出力コードが呼び出す必要かどうかを確認します &lt;code&gt;sv_setiv&lt;/code&gt; 、 &lt;code&gt;sv_setuv&lt;/code&gt; 、 &lt;code&gt;sv_setnv&lt;/code&gt; 、 &lt;code&gt;sv_setpv&lt;/code&gt; または &lt;code&gt;sv_setpvn&lt;/code&gt; を特別に設定する &lt;code&gt;$arg&lt;/code&gt; 新しい値にプレースホルダを&lt;b&gt;出力コードの最後に&lt;/b&gt;。その場合、コードは &lt;code&gt;TARG&lt;/code&gt; 関連のマクロを使用してこれを最適化するのに適しています。したがって、メソッドの名前： &lt;code&gt;targetable&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d3d6cbfb7caf07ade67b0cd6e1a9dc2096892c7" translate="yes" xml:space="preserve">
          <source>In a pinch, if you cannot wait for Configure to be educated, or if you have a good hunch of where quux() might be available, you can temporarily try the following:</source>
          <target state="translated">ピンチの時に、Configureが教育されるのを待てない場合や、quux()が使えそうな場所の予感がする場合は、一時的に以下のようにしてみてもいいでしょう。</target>
        </trans-unit>
        <trans-unit id="8904deace3383be6f62627ad2fa40ed65a69d2bd" translate="yes" xml:space="preserve">
          <source>In a plain &lt;code&gt;eval&lt;/code&gt; without an EXPR argument, being in &lt;code&gt;use utf8&lt;/code&gt; or not is irrelevant; the UTF-8ness of &lt;code&gt;$_&lt;/code&gt; itself determines the behavior.</source>
          <target state="translated">EXPR引数のない単純な &lt;code&gt;eval&lt;/code&gt; で &lt;code&gt;use utf8&lt;/code&gt; を使用しているかどうかは関係ありません。 &lt;code&gt;$_&lt;/code&gt; 自体のUTF-8nessが動作を決定します。</target>
        </trans-unit>
        <trans-unit id="8692c1987c2bd18d4696b2de38e79ce9a490834f" translate="yes" xml:space="preserve">
          <source>In a real situation, care should be taken that all threads are finished executing before the program exits. That care has &lt;b&gt;not&lt;/b&gt; been taken in these examples in the interest of simplicity. Running these examples</source>
          <target state="translated">実際の状況では、プログラムが終了する前にすべてのスレッドの実行が終了するように注意する必要があります。単純にするために、これらの例では注意が払われて&lt;b&gt;いません&lt;/b&gt;。これらの例を実行する</target>
        </trans-unit>
        <trans-unit id="81c10dc0ae0ebb18c61b259ddfe6843d666964b7" translate="yes" xml:space="preserve">
          <source>In a reciprocal fashion, an operation provides either a scalar or a list context to each of its arguments. For example, if you say</source>
          <target state="translated">互恵的な方法で、操作はそれぞれの引数にスカラまたはリストコンテキストを提供します。例えば</target>
        </trans-unit>
        <trans-unit id="7ae53fee8d17396b84228f6cefecffeb87519079" translate="yes" xml:space="preserve">
          <source>In a regex set</source>
          <target state="translated">正規表現セットでは</target>
        </trans-unit>
        <trans-unit id="c78cf6df929776e529a74a77e45234f404202f1c" translate="yes" xml:space="preserve">
          <source>In a regular expression, the backslash can perform one of two tasks: it either takes away the special meaning of the character following it (for instance, &lt;code&gt;\|&lt;/code&gt; matches a vertical bar, it's not an alternation), or it is the start of a backslash or escape sequence.</source>
          <target state="translated">正規表現では、バックスラッシュは次の2つのタスクのいずれかを実行できます。バックスラッシュは、それに続く文字の特別な意味を取り除きます（たとえば、 &lt;code&gt;\|&lt;/code&gt; は縦棒に一致し、代替ではありません）、またはバックスラッシュまたはエスケープシーケンス。</target>
        </trans-unit>
        <trans-unit id="81b5d9cd571e9943815277ab89c7fe545d260e8a" translate="yes" xml:space="preserve">
          <source>In a scalar context &lt;code&gt;deflate&lt;/code&gt; will return &lt;code&gt;$out&lt;/code&gt; only.</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;deflate&lt;/code&gt; は &lt;code&gt;$out&lt;/code&gt; のみを返します。</target>
        </trans-unit>
        <trans-unit id="d751225aea131e8c18607565afa032c5caedabd6" translate="yes" xml:space="preserve">
          <source>In a scalar context &lt;code&gt;flush&lt;/code&gt; will return &lt;code&gt;$out&lt;/code&gt; only.</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;flush&lt;/code&gt; は &lt;code&gt;$out&lt;/code&gt; のみを返します。</target>
        </trans-unit>
        <trans-unit id="24a49c87bdb8b460c4017296f34ddb336c87c832" translate="yes" xml:space="preserve">
          <source>In a scalar context it returns the group name.</source>
          <target state="translated">スカラコンテキストでは、グループ名を返します。</target>
        </trans-unit>
        <trans-unit id="32d6c6f3bf39438d4047ce657137dce5d3577d7c" translate="yes" xml:space="preserve">
          <source>In a scalar context opcodes returns the number of opcodes in this version of perl (around 350 for perl-5.7.0).</source>
          <target state="translated">スカラコンテキストでは opcodes はこのバージョンの perl での opcodes の数を返します (約 350 個の opcodes を返します)。</target>
        </trans-unit>
        <trans-unit id="208f6e20787f24b907ff451f1741888a45d23759" translate="yes" xml:space="preserve">
          <source>In a scalar context the method returns the number of values associated with the key, &lt;code&gt;$key&lt;/code&gt; .</source>
          <target state="translated">スカラーコンテキストでは、メソッドはキー &lt;code&gt;$key&lt;/code&gt; 関連付けられた値の数を返します。</target>
        </trans-unit>
        <trans-unit id="e9df32f544b32017f1a687d3dc29e952bea935c6" translate="yes" xml:space="preserve">
          <source>In a scalar context the method returns the number of values associated with the key, &lt;code&gt;$key&lt;/code&gt;.</source>
          <target state="translated">スカラーコンテキストでは、メソッドはキー &lt;code&gt;$key&lt;/code&gt; 関連付けられた値の数を返します。</target>
        </trans-unit>
        <trans-unit id="432d105e0c68a882f3e01defe90d20d01d0c26a5" translate="yes" xml:space="preserve">
          <source>In a scalar context the new socket is returned, or &lt;code&gt;undef&lt;/code&gt; upon failure. In a list context a two-element array is returned containing the new socket and the peer address; the list will be empty upon failure.</source>
          <target state="translated">スカラーコンテキストでは、新しいソケットが返されるか、失敗すると &lt;code&gt;undef&lt;/code&gt; が返されます。リストコンテキストでは、新しいソケットとピアアドレスを含む2要素の配列が返されます。失敗するとリストは空になります。</target>
        </trans-unit>
        <trans-unit id="cec0bad3cd5e75ede69094662ac02e11b4300440" translate="yes" xml:space="preserve">
          <source>In a scalar context the new socket is returned, or undef upon failure. In a list context a two-element array is returned containing the new socket and the peer address; the list will be empty upon failure.</source>
          <target state="translated">スカラコンテキストでは、新しいソケットを返すか、失敗した場合は undef を返します。リストコンテキストでは、新しいソケットとピアアドレスを含む 2 要素の配列が返されます。</target>
        </trans-unit>
        <trans-unit id="92d1e3370613f74b8985a6b3b39b4a2c46223d16" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_quotelike&lt;/code&gt; returns just the complete substring that matched a quotelike operation (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on failure). In a scalar or void context, the input text has the same substring (and any specified prefix) removed.</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;extract_quotelike&lt;/code&gt; はquotelikeオペレーション（または失敗した場合は &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ）に一致した完全なサブストリングのみを返します。スカラーまたはvoidコンテキストでは、入力テキストから同じ部分文字列（および指定された接頭辞）が削除されます。</target>
        </trans-unit>
        <trans-unit id="cb043da2c0d1ddbcbe23b4dfa1c70dc8d30d93aa" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_quotelike&lt;/code&gt; returns just the complete substring that matched a quotelike operation (or &lt;code&gt;undef&lt;/code&gt; on failure). In a scalar or void context, the input text has the same substring (and any specified prefix) removed.</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;extract_quotelike&lt;/code&gt; は、quotelike操作（または失敗した場合は &lt;code&gt;undef&lt;/code&gt; ）に一致する完全な部分文字列のみを返します。スカラーまたはvoidコンテキストでは、入力テキストの同じ部分文字列（および指定されたプレフィックス）が削除されます。</target>
        </trans-unit>
        <trans-unit id="b5b8dc86dc00a1f2952c9a2e48c451d832e4c066" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_tagged&lt;/code&gt; returns just the complete substring that matched a tagged text (including the start and end tags). &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned on failure. In addition, the original input text has the returned substring (and any prefix) removed from it.</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;extract_tagged&lt;/code&gt; は、タグ付きテキスト（開始タグと終了タグを含む）と一致した完全な部分文字列のみを返します。失敗すると &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。さらに、元の入力テキストから返された部分文字列（および任意の接頭辞）が削除されています。</target>
        </trans-unit>
        <trans-unit id="58e1b2c9f41d6622189dffef6c6b3c984f3970a5" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_tagged&lt;/code&gt; returns just the complete substring that matched a tagged text (including the start and end tags). &lt;code&gt;undef&lt;/code&gt; is returned on failure. In addition, the original input text has the returned substring (and any prefix) removed from it.</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;extract_tagged&lt;/code&gt; は、タグ付きテキスト（開始タグと終了タグを含む）に一致する完全な部分文字列のみを返します。 &lt;code&gt;undef&lt;/code&gt; は失敗時に返されます。さらに、元の入力テキストでは、返された部分文字列（およびプレフィックス）が削除されています。</target>
        </trans-unit>
        <trans-unit id="f9900a2af209760381e75d8f7a14615b5a9bdbec" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_variable&lt;/code&gt; returns just the complete substring that matched a variablish expression. &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned on failure. In addition, the original input text has the returned substring (and any prefix) removed from it.</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;extract_variable&lt;/code&gt; は、可変式に一致した完全な部分文字列のみを返します。失敗すると &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。さらに、元の入力テキストから返された部分文字列（および任意の接頭辞）が削除されています。</target>
        </trans-unit>
        <trans-unit id="29022909d0ff04a63844f8132ef7f7171aee73fe" translate="yes" xml:space="preserve">
          <source>In a scalar context, &lt;code&gt;extract_variable&lt;/code&gt; returns just the complete substring that matched a variablish expression. &lt;code&gt;undef&lt;/code&gt; is returned on failure. In addition, the original input text has the returned substring (and any prefix) removed from it.</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;extract_variable&lt;/code&gt; は、変数式に一致する完全な部分文字列のみを返します。 &lt;code&gt;undef&lt;/code&gt; は失敗時に返されます。さらに、元の入力テキストでは、返された部分文字列（およびプレフィックス）が削除されています。</target>
        </trans-unit>
        <trans-unit id="945278245cb407350f6bc45cb3b502fc5ad85d58" translate="yes" xml:space="preserve">
          <source>In a scalar context, just the extracted substring is returned. In a void context, the extracted substring (and any prefix) are simply removed from the beginning of the first argument.</source>
          <target state="translated">スカラコンテキストでは、抽出された部分文字列だけが返されます。voidコンテキストでは、抽出された部分文字列(と任意の接頭辞)は単に第1引数の先頭から削除されます。</target>
        </trans-unit>
        <trans-unit id="7e3e24a2a724494140e588e3803a95e574330808" translate="yes" xml:space="preserve">
          <source>In a scalar context, the extracted string is returned, having first been removed from the input text. Thus, the following code also processes each quote-like operation, but actually removes them from $text:</source>
          <target state="translated">スカラコンテキストでは、抽出された文字列が返され、最初に入力テキストから削除されます。したがって、以下のコードでは、引用符のような操作も処理していますが、実際には $text から削除しています。</target>
        </trans-unit>
        <trans-unit id="0d5544cfc850136e8726fbbd9c72234c9b7ae747" translate="yes" xml:space="preserve">
          <source>In a sense, perl (the C program) is a good example of embedding Perl (the language), so I'll demonstrate embedding with</source>
          <target state="translated">ある意味、Perl(言語)を埋め込むにはPerl(Cプログラム)が良い例なので、ここでは</target>
        </trans-unit>
        <trans-unit id="ff595beb69ecf8f38b6337a9d03b24a9b262246c" translate="yes" xml:space="preserve">
          <source>In a similar fashion, overriding the &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; function also overrides the equivalent I/O operator &lt;code&gt;&amp;lt;FILEHANDLE&amp;gt;&lt;/code&gt; . Also, overriding &lt;code&gt;&lt;a href=&quot;functions/readpipe&quot;&gt;readpipe&lt;/a&gt;&lt;/code&gt; also overrides the operators &lt;code&gt;``&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">同様に、 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 関数をオーバーライドすると、同等のI / O演算子 &lt;code&gt;&amp;lt;FILEHANDLE&amp;gt;&lt;/code&gt; もオーバーライドされます。また、 &lt;code&gt;&lt;a href=&quot;functions/readpipe&quot;&gt;readpipe&lt;/a&gt;&lt;/code&gt; をオーバーライドすると、演算子 &lt;code&gt;``&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; もオーバーライドされます。</target>
        </trans-unit>
        <trans-unit id="a7df5882938822589a5bd41ee1d3ff81d5d0fe68" translate="yes" xml:space="preserve">
          <source>In a similar fashion, overriding the &lt;code&gt;readline&lt;/code&gt; function also overrides the equivalent I/O operator &lt;code&gt;&amp;lt;FILEHANDLE&amp;gt;&lt;/code&gt;. Also, overriding &lt;code&gt;readpipe&lt;/code&gt; also overrides the operators &lt;code&gt;``&lt;/code&gt; and &lt;code&gt;qx//&lt;/code&gt;.</source>
          <target state="translated">同様に、 &lt;code&gt;readline&lt;/code&gt; 関数をオーバーライドすると、同等のI / O演算子 &lt;code&gt;&amp;lt;FILEHANDLE&amp;gt;&lt;/code&gt; もオーバーライドされます。また、 &lt;code&gt;readpipe&lt;/code&gt; をオーバーライドすると、演算子 &lt;code&gt;``&lt;/code&gt; と &lt;code&gt;qx//&lt;/code&gt; もオーバーライドされます。</target>
        </trans-unit>
        <trans-unit id="2d250c896d3f5eb11d7a648b3bc78f5925e2fcce" translate="yes" xml:space="preserve">
          <source>In a void context the behaviour of the extraction subroutines is exactly the same as in a scalar context, except (of course) that the extracted substring is not returned.</source>
          <target state="translated">voidコンテキストでは、抽出サブルーチンの動作はスカラコンテキストと全く同じですが、(もちろん)抽出された部分文字列が返されないことを除いては、です。</target>
        </trans-unit>
        <trans-unit id="164ac7c993944f12e7319a81a34bfbc9042d71d4" translate="yes" xml:space="preserve">
          <source>In a void context, the input text just has the matched substring (and any specified prefix) removed.</source>
          <target state="translated">void のコンテキストでは、入力テキストからマッチした部分文字列 (および指定された接頭辞)が削除されます。</target>
        </trans-unit>
        <trans-unit id="a9b13f420194df675e5068f5af3ab2ba48ac53e8" translate="yes" xml:space="preserve">
          <source>In a word - don't, at least not without a *very* good reason. Your scripts can just as easily begin with &quot;#!/usr/local/bin/perl&quot; as with &quot;#!/usr/bin/perl&quot;. Scripts supplied by Apple and other third parties as part of installation packages and such have generally only been tested with the /usr/bin/perl that's installed by Apple.</source>
          <target state="translated">一言で言えば-してはいけません。あなたのスクリプトは、&quot;#!/usr/local/bin/perl &quot;で始まるのと、&quot;#!/usr/bin/perl &quot;で始まるのと同じように簡単に始めることができます。Apple やその他のサードパーティがインストールパッケージの一部として提供するスクリプトは、一般的に Apple がインストールした /usr/bin/perl でしかテストされていません。</target>
        </trans-unit>
        <trans-unit id="fcf1ea0b348743b5d23b285ecea8c108896961cc" translate="yes" xml:space="preserve">
          <source>In academia, a curriculum vit&amp;aelig;, a fancy kind of r&amp;eacute;sum&amp;eacute;. In Perl, an internal &amp;ldquo;code value&amp;rdquo; typedef holding a &lt;b&gt;subroutine&lt;/b&gt;. The &lt;code&gt;CV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">アカデミアでは、カリキュラム、空想的な履歴書。Perlでは、&lt;b&gt;サブルーチンを&lt;/b&gt;保持する内部「コード値」typedef 。 &lt;code&gt;CV&lt;/code&gt; のタイプはのサブクラスである&lt;b&gt;SV&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="b2f52867b2f837c43cc5640194de947dbf1e2090" translate="yes" xml:space="preserve">
          <source>In actuality, the period and &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; abbreviations are themselves types of character classes, so the ones surrounded by brackets are just one type of character class. When we need to make a distinction, we refer to them as &quot;bracketed character classes.&quot;</source>
          <target state="translated">実際には、ピリオドと &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; 省略形はそれ自体が文字クラスのタイプであるため、角括弧で囲まれたものは1つの文字クラスのタイプにすぎません。区別する必要がある場合、それらを「ブラケット文字クラス」と呼びます。</target>
        </trans-unit>
        <trans-unit id="46e3a38016d86ba7214b26757c2cfc95f05dd8d8" translate="yes" xml:space="preserve">
          <source>In addition</source>
          <target state="translated">さらに</target>
        </trans-unit>
        <trans-unit id="7e82af699df6da7e07e9ea8a98307994127655f1" translate="yes" xml:space="preserve">
          <source>In addition EXTEND will be called when perl would have pre-extended allocation in a real array.</source>
          <target state="translated">また、実際の配列にあらかじめ拡張された割り当てがある場合には、EXTENDが呼ばれます。</target>
        </trans-unit>
        <trans-unit id="ed2d1a9f24dc62aaee4efacb9df22dbcc5333d73" translate="yes" xml:space="preserve">
          <source>In addition it contains two fields that are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and &lt;code&gt;pprivate&lt;/code&gt; members. &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure, whose use and management is the responsibility of the compiling engine. Perl will never modify either of these values.</source>
          <target state="translated">さらに、パターンをコンパイルした正規表現エンジンの私的使用を目的とした2つのフィールドが含まれています。これらは、 &lt;code&gt;intflags&lt;/code&gt; および &lt;code&gt;pprivate&lt;/code&gt; メンバーです。 &lt;code&gt;pprivate&lt;/code&gt; は任意の構造体への無効なポインタであり、その使用と管理はコンパイルエンジンの責任です。Perlがこれらの値を変更することはありません。</target>
        </trans-unit>
        <trans-unit id="7aa9ca3525844fd7a1f1f038ab777e0241661c46" translate="yes" xml:space="preserve">
          <source>In addition it contains two fields that are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and pprivate members. The &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure whose use and management is the responsibility of the compiling engine. perl will never modify either of these values.</source>
          <target state="translated">さらに、パターンをコンパイルした正規表現エンジンの私的使用を目的とした2つのフィールドが含まれています。これらは、 &lt;code&gt;intflags&lt;/code&gt; およびpprivateメンバーです。 &lt;code&gt;pprivate&lt;/code&gt; は、使用及び管理コンパイルエンジンの責務である任意の構造にボイドのポインタです。 perlがこれらの値を変更することはありません。</target>
        </trans-unit>
        <trans-unit id="152b5f495da9efbec00e14f0ef1bc85e80c4a061" translate="yes" xml:space="preserve">
          <source>In addition to &lt;b&gt;scripts&lt;/b&gt;, Unicode also defines &lt;b&gt;blocks&lt;/b&gt; of characters. The difference between scripts and blocks is that the concept of scripts is closer to natural languages, while the concept of blocks is more of an artificial grouping based on groups of Unicode characters with consecutive ordinal values. For example, the &lt;code&gt;&quot;Basic Latin&quot;&lt;/code&gt; block is all the characters whose ordinals are between 0 and 127, inclusive; in other words, the ASCII characters. The &lt;code&gt;&quot;Latin&quot;&lt;/code&gt; script contains some letters from this as well as several other blocks, like &lt;code&gt;&quot;Latin-1 Supplement&quot;&lt;/code&gt; , &lt;code&gt;&quot;Latin Extended-A&quot;&lt;/code&gt; ,</source>
          <target state="translated">&lt;b&gt;スクリプト&lt;/b&gt;に加えて、Unicode は文字の&lt;b&gt;ブロック&lt;/b&gt;も定義し&lt;b&gt;ます&lt;/b&gt;。スクリプトとブロックの違いは、スクリプトの概念は自然言語に近いということですが、ブロックの概念は、連続した序数値を持つUnicode文字のグループに基づいた人工的なグループ化のようなものです。たとえば、 &lt;code&gt;&quot;Basic Latin&quot;&lt;/code&gt; ブロックは、序数が0〜127のすべての文字です。つまり、ASCII文字です。 &lt;code&gt;&quot;Latin&quot;&lt;/code&gt; のスクリプトは次のように、本だけでなく、他のいくつかのブロックからいくつかの文字が含まれている &lt;code&gt;&quot;Latin-1 Supplement&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;Latin Extended-A&quot;&lt;/code&gt; 、</target>
        </trans-unit>
        <trans-unit id="7f09088f954a7db82a8b57fd467bd7775553888e" translate="yes" xml:space="preserve">
          <source>In addition to &lt;b&gt;scripts&lt;/b&gt;, Unicode also defines &lt;b&gt;blocks&lt;/b&gt; of characters. The difference between scripts and blocks is that the concept of scripts is closer to natural languages, while the concept of blocks is more of an artificial grouping based on groups of Unicode characters with consecutive ordinal values. For example, the &lt;code&gt;&quot;Basic Latin&quot;&lt;/code&gt; block is all the characters whose ordinals are between 0 and 127, inclusive; in other words, the ASCII characters. The &lt;code&gt;&quot;Latin&quot;&lt;/code&gt; script contains some letters from this as well as several other blocks, like &lt;code&gt;&quot;Latin-1 Supplement&quot;&lt;/code&gt;, &lt;code&gt;&quot;Latin Extended-A&quot;&lt;/code&gt;,</source>
          <target state="translated">&lt;b&gt;スクリプト&lt;/b&gt;に加えて、Unicodeは文字の&lt;b&gt;ブロック&lt;/b&gt;も定義し&lt;b&gt;ます&lt;/b&gt;。スクリプトとブロックの違いは、スクリプトの概念が自然言語に近いのに対し、ブロックの概念は、連続する順序値を持つUnicode文字のグループに基づく人工的なグループ化に近いことです。たとえば、 &lt;code&gt;&quot;Basic Latin&quot;&lt;/code&gt; ブロックは、序数が0〜127のすべての文字です。言い換えれば、ASCII文字です。 &lt;code&gt;&quot;Latin&quot;&lt;/code&gt; のスクリプトは次のように、本だけでなく、他のいくつかのブロックからいくつかの文字が含まれている &lt;code&gt;&quot;Latin-1 Supplement&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;Latin Extended-A&quot;&lt;/code&gt; 、</target>
        </trans-unit>
        <trans-unit id="fc1471fd86b05121c975247d3ecf108832020f99" translate="yes" xml:space="preserve">
          <source>In addition to accepting the &lt;code&gt;collect_pod&lt;/code&gt; and &lt;code&gt;decode_pod&lt;/code&gt; arguments as described above, this method accepts a &lt;code&gt;inc&lt;/code&gt; argument which is a reference to an array of directories to search for the module. If none are given, the default is @INC.</source>
          <target state="translated">上記のように &lt;code&gt;collect_pod&lt;/code&gt; 引数と &lt;code&gt;decode_pod&lt;/code&gt; 引数を受け入れることに加えて、このメソッドは、モジュールを検索するためのディレクトリの配列への参照である &lt;code&gt;inc&lt;/code&gt; 引数を受け入れます。何も指定されていない場合、デフォルトは@INCです。</target>
        </trans-unit>
        <trans-unit id="f86a4eaf10c727caafeb64d3a643f53ff65e9454" translate="yes" xml:space="preserve">
          <source>In addition to adding seconds, there are two APIs for adding months and years:</source>
          <target state="translated">秒数の追加に加えて、月数と年数を追加するためのAPIが2つあります。</target>
        </trans-unit>
        <trans-unit id="b2fd5a60f4cdde51801210d2d64a0096f9f11eee" translate="yes" xml:space="preserve">
          <source>In addition to an editor/IDE you might be interested in a more powerful shell environment for Win32. Your options include</source>
          <target state="translated">エディタ/IDEに加えて、Win32用のより強力なシェル環境に興味があるかもしれません。オプションには以下のものがあります。</target>
        </trans-unit>
        <trans-unit id="00eb917cf5efd07f43486b691141200c354a7e24" translate="yes" xml:space="preserve">
          <source>In addition to arranging for various Encode aliases the following functions and variables are provided:</source>
          <target state="translated">様々なEncodeエイリアスのアレンジに加えて、以下のような関数や変数が用意されています。</target>
        </trans-unit>
        <trans-unit id="1749590c161975b92597e609a16d593c1ab667da" translate="yes" xml:space="preserve">
          <source>In addition to being Unix, we're U/WIN.</source>
          <target state="translated">Unixであることに加えて、私たちはU/WINです。</target>
        </trans-unit>
        <trans-unit id="59ad52f794c0c2f95e95db00a5db4b0758359fc7" translate="yes" xml:space="preserve">
          <source>In addition to computing what you expected, the last example also does &lt;b&gt;not&lt;/b&gt; &quot;taint&quot; the result with an accuracy or precision setting, which would influence any further operation.</source>
          <target state="translated">最後の例では、期待どおりの計算に加えて、精度や精度の設定で結果が「汚染」され&lt;b&gt;ない&lt;/b&gt;ため、以降の操作に影響が出ます。</target>
        </trans-unit>
        <trans-unit id="28f0a444647c3ca604a27ded60bf62b43ff7e031" translate="yes" xml:space="preserve">
          <source>In addition to fields allowed in &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;, you may prefix a field with a %&amp;lt;number&amp;gt; to indicate that you want a &amp;lt;number&amp;gt;-bit checksum of the items instead of the items themselves. Default is a 16-bit checksum. The checksum is calculated by summing numeric values of expanded values (for string fields the sum of &lt;code&gt;ord($char)&lt;/code&gt; is taken; for bit fields the sum of zeroes and ones).</source>
          <target state="translated">&lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt;で許可されているフィールドに加えて、フィールドの前に％&amp;lt;number&amp;gt;を付けて、アイテム自体ではなく、アイテムの&amp;lt;number&amp;gt;ビットのチェックサムが必要であることを示すことができます。デフォルトは16ビットのチェックサムです。チェックサムは、展開された値の数値を合計することによって計算されます（文字列フィールドの場合は &lt;code&gt;ord($char)&lt;/code&gt; の合計が取られ、ビットフィールドの場合は0と1の合計が取られます）。</target>
        </trans-unit>
        <trans-unit id="ae2d9c47551f30ac79ac4fb8a4a7835684b54313" translate="yes" xml:space="preserve">
          <source>In addition to fields allowed in pack(), you may prefix a field with a %&amp;lt;number&amp;gt; to indicate that you want a &amp;lt;number&amp;gt;-bit checksum of the items instead of the items themselves. Default is a 16-bit checksum. Checksum is calculated by summing numeric values of expanded values (for string fields the sum of &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; is taken; for bit fields the sum of zeroes and ones).</source>
          <target state="translated">pack（）で許可されているフィールドに加えて、フィールドの前に％&amp;lt;number&amp;gt;を付けて、アイテム自体ではなく、アイテムの&amp;lt;number&amp;gt;ビットのチェックサムが必要であることを示すことができます。デフォルトは16ビットのチェックサムです。チェックサムは、拡張された値の数値を合計することによって計算されます（文字列フィールドの場合は、 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; の合計が取得されます。ビットフィールドの場合は、ゼロと1の合計が取得されます）。</target>
        </trans-unit>
        <trans-unit id="8fab1ee4cfb63b6e2e7d76c7cfd5888f6ab2e679" translate="yes" xml:space="preserve">
          <source>In addition to fields allowed in pack(), you may prefix a field with a %&amp;lt;number&amp;gt; to indicate that you want a &amp;lt;number&amp;gt;-bit checksum of the items instead of the items themselves. Default is a 16-bit checksum. Checksum is calculated by summing numeric values of expanded values (for string fields the sum of &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; is taken; for bit fields the sum of zeroes and ones).</source>
          <target state="translated">pack（）で許可されているフィールドに加えて、フィールドの前に％&amp;lt;number&amp;gt;を付けて、アイテム自体ではなく、アイテムの&amp;lt;number&amp;gt;ビットのチェックサムが必要であることを示すことができます。デフォルトは16ビットのチェックサムです。チェックサムは、拡張された値の数値を合計することによって計算されます（文字列フィールドの場合は、 &lt;code&gt;&lt;a href=&quot;ord&quot;&gt;ord($char)&lt;/a&gt;&lt;/code&gt; の合計が取得されます。ビットフィールドの場合は、ゼロと1の合計が取得されます）。</target>
        </trans-unit>
        <trans-unit id="11a4b3be42c1bc1c34ed610faa54c6750890304a" translate="yes" xml:space="preserve">
          <source>In addition to interacting with the &lt;code&gt;(*SKIP)&lt;/code&gt; pattern, &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; can be used to &quot;label&quot; a pattern branch, so that after matching, the program can determine which branches of the pattern were involved in the match.</source>
          <target state="translated">&lt;code&gt;(*SKIP)&lt;/code&gt; パターンとの対話に加えて、 &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; を使用してパターンブランチに「ラベルを付ける」ことができるため、照合後、プログラムはパターンのどのブランチが照合に関与したかを判別できます。</target>
        </trans-unit>
        <trans-unit id="40ec63aed202427c78ae99bf79365c2b0344aea9" translate="yes" xml:space="preserve">
          <source>In addition to interacting with the &lt;code&gt;(*SKIP)&lt;/code&gt; pattern, &lt;code&gt;(*MARK:NAME)&lt;/code&gt; can be used to &quot;label&quot; a pattern branch, so that after matching, the program can determine which branches of the pattern were involved in the match.</source>
          <target state="translated">&lt;code&gt;(*SKIP)&lt;/code&gt; パターンとの相互作用に加えて、 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; を使用して、パターンブランチに「ラベルを付ける」ことができます。これにより、一致後、プログラムはパターンのどのブランチが一致に関係していたかを判別できます。</target>
        </trans-unit>
        <trans-unit id="cea68ca5519ffc8129501826ad0bb9062eef1e64" translate="yes" xml:space="preserve">
          <source>In addition to possible bugs and an inability to follow changes to the translation policy with off/on switches of TERMIO translation, this introduces a serious incompatible change: before sysread() on text-mode filehandles would go through the translation layer, now it would not.</source>
          <target state="translated">可能性のあるバグやTERMIO翻訳のオフ/オンスイッチでの翻訳ポリシーの変更に追従できないことに加えて、これは深刻な互換性のない変更を導入しています:以前はテキストモードのファイルハンドル上のsysread()は翻訳レイヤーを通過していましたが、今は通過しません。</target>
        </trans-unit>
        <trans-unit id="d4d69cf9bd1e25a37f285dc63efc29fb797f0fe0" translate="yes" xml:space="preserve">
          <source>In addition to standard-like API defined so far above there is an &quot;implementation&quot; interface which allows perl to get at internals of PerlIO. The following calls correspond to the various FILE_xxx macros determined by Configure - or their equivalent in other implementations. This section is really of interest to only those concerned with detailed perl-core behaviour, implementing a PerlIO mapping or writing code which can make use of the &quot;read ahead&quot; that has been done by the IO system in the same way perl does. Note that any code that uses these interfaces must be prepared to do things the traditional way if a handle does not support them.</source>
          <target state="translated">これまでに定義された標準的なAPIに加えて、PerlがPerlIOの内部を取得するための「実装」インターフェースがあります。以下の呼び出しは、Configureによって決定された様々なFILE_xxxマクロ、または他の実装では同等のものに対応しています。このセクションは、Perl-コアの詳細な動作に関心がある人、PerlIOマッピングを実装している人、またはPerlと同じ方法でIOシステムによって行われた「先読み」を利用できるコードを書いている人だけが興味を持つことができます。これらのインターフェイスを使用するコードは、ハンドルがそれらをサポートしていない場合には、従来の方法で物事を行う準備をしておかなければならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="c328df560ff213b6d17abffac103ff94284e681e" translate="yes" xml:space="preserve">
          <source>In addition to the MEDIUM security checks, also check for the possibility of ``chown() giveaway'' using the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; sysconf() function. If this is a possibility, each directory in the path is checked in turn for safeness, recursively walking back to the root directory.</source>
          <target state="translated">MEDIUMセキュリティチェックに加えて、&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; sysconf（）関数を使用して「chown（）プレゼント」の可能性もチェックします。これが可能である場合は、パス内の各ディレクトリの安全性が順番にチェックされ、ルートディレクトリに再帰的に戻ります。</target>
        </trans-unit>
        <trans-unit id="17eaea3931a67cb37ce8cb0cb3c4e8d09398b8c0" translate="yes" xml:space="preserve">
          <source>In addition to the MEDIUM security checks, also check for the possibility of ``chown() giveaway'' using the L</source>
          <target state="translated">MEDIUMのセキュリティチェックに加えて、L</target>
        </trans-unit>
        <trans-unit id="89182cb06f6668d208e0619e4cbe15cde7591879" translate="yes" xml:space="preserve">
          <source>In addition to the OVERLOAD keyword, if you need to control how Perl autogenerates missing overloaded operators, you can set the FALLBACK keyword in the module header section, like this:</source>
          <target state="translated">OVERLOAD キーワードに加えて、Perl が欠落したオーバーロード演算子をどのように自動生成するかを制御する必要がある場合は、以下のようにモジュール・ヘッダ・セクションで FALLBACK キーワードを設定することができます。</target>
        </trans-unit>
        <trans-unit id="cf43e38422f03f19f7c8bc12dfe3cf7238322b4f" translate="yes" xml:space="preserve">
          <source>In addition to the STANDARD security, the output directory is checked to make sure that it is owned either by root or the user running the program. If the directory is writable by group or by other, it is then checked to make sure that the sticky bit is set.</source>
          <target state="translated">STANDARD セキュリティに加えて、出力ディレクトリが root またはプログラムを実行しているユーザのどちらかの所有物であることを確認します。ディレクトリがグループや他の人によって書き込み可能な場合は、 スティッキービットが設定されているかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="a6827bb11452b38549da194a0e9f946e676fb6ab" translate="yes" xml:space="preserve">
          <source>In addition to the compiler flags used to select the SDK, also add the flags for creating a universal binary:</source>
          <target state="translated">SDKを選択するために使用されるコンパイラフラグに加えて、ユニバーサルバイナリを作成するためのフラグも追加します。</target>
        </trans-unit>
        <trans-unit id="73c76010fe3f7536529c60cd357cfa7c8e4a0b21" translate="yes" xml:space="preserve">
          <source>In addition to the different levels of OS involvement in threads, different OSes (and different thread implementations for a particular OS) allocate CPU cycles to threads in different ways.</source>
          <target state="translated">スレッドへのOSの関与のレベルの違いに加えて、異なるOS(および特定のOSの異なるスレッド実装)は、異なる方法でスレッドにCPUサイクルを割り当てます。</target>
        </trans-unit>
        <trans-unit id="79a96fb0aa6c1ca892c14d42638abd6240d03e9c" translate="yes" xml:space="preserve">
          <source>In addition to the file and subroutine-related variables mentioned above, the debugger also maintains various magical internal variables.</source>
          <target state="translated">上記のファイルやサブルーチン関連の変数に加えて、デバッガは様々な魔法の内部変数も保持しています。</target>
        </trans-unit>
        <trans-unit id="bab0de29db31c89ae8ab9839888cf6f1bf406c03" translate="yes" xml:space="preserve">
          <source>In addition to the key-value pairs accepted by &lt;a href=&quot;../socket&quot;&gt;IO::Socket&lt;/a&gt;, &lt;code&gt;IO::Socket::INET&lt;/code&gt; provides.</source>
          <target state="translated">&lt;a href=&quot;../socket&quot;&gt;IO :: Socket&lt;/a&gt;で受け入れられるキーと値のペアに加えて、 &lt;code&gt;IO::Socket::INET&lt;/code&gt; 提供します。</target>
        </trans-unit>
        <trans-unit id="7a72b31c557cda8bc1b722b2e6a26c2c901af09d" translate="yes" xml:space="preserve">
          <source>In addition to the key-value pairs accepted by &lt;a href=&quot;../socket&quot;&gt;IO::Socket&lt;/a&gt;, &lt;code&gt;IO::Socket::UNIX&lt;/code&gt; provides.</source>
          <target state="translated">&lt;a href=&quot;../socket&quot;&gt;IO :: Socketが&lt;/a&gt;受け入れるキーと値のペアに加えて、 &lt;code&gt;IO::Socket::UNIX&lt;/code&gt; 提供します。</target>
        </trans-unit>
        <trans-unit id="2c8512896a52a4b21163cc6634b2cdd39a0ba342" translate="yes" xml:space="preserve">
          <source>In addition to the key-value pairs accepted by &lt;a href=&quot;IO::Socket&quot;&gt;IO::Socket&lt;/a&gt;, &lt;code&gt;IO::Socket::INET&lt;/code&gt; provides.</source>
          <target state="translated">&lt;a href=&quot;IO::Socket&quot;&gt;IO :: Socket&lt;/a&gt;で受け入れられるキーと値のペアに加えて、 &lt;code&gt;IO::Socket::INET&lt;/code&gt; 提供します。</target>
        </trans-unit>
        <trans-unit id="c27e58eddb584a8c9586d7873c892baa74f4f56d" translate="yes" xml:space="preserve">
          <source>In addition to the key-value pairs accepted by &lt;a href=&quot;IO::Socket&quot;&gt;IO::Socket&lt;/a&gt;, &lt;code&gt;IO::Socket::UNIX&lt;/code&gt; provides.</source>
          <target state="translated">&lt;a href=&quot;IO::Socket&quot;&gt;IO :: Socket&lt;/a&gt;で受け入れられるキーと値のペアに加えて、 &lt;code&gt;IO::Socket::UNIX&lt;/code&gt; 提供します。</target>
        </trans-unit>
        <trans-unit id="7c45e877ad35106ffbe7de68a1cdc70a047e523f" translate="yes" xml:space="preserve">
          <source>In addition to the metacharacters, there are some ASCII characters which don't have printable character equivalents and are instead represented by</source>
          <target state="translated">メタキャラクタに加えて、印刷可能な文字の等価物を持たないASCII文字もあります。</target>
        </trans-unit>
        <trans-unit id="08676326b07558d72976a15d2e5ea67b5354d4ab" translate="yes" xml:space="preserve">
          <source>In addition to the perl API described above, a C API is available for extension writers. The following C functions are available in the modglobal hash:</source>
          <target state="translated">上で説明した perl API の他に、拡張機能を書くための C API が用意されています。modglobalハッシュには以下のC関数が用意されています。</target>
        </trans-unit>
        <trans-unit id="ef88c015cd90a62555639afdea15aa945900339f" translate="yes" xml:space="preserve">
          <source>In addition to the quote delimiters &lt;code&gt;'&lt;/code&gt;, &lt;code&gt;&quot;&lt;/code&gt;, and &lt;code&gt;`&lt;/code&gt;, full Perl quote-like quoting (i.e. q{string}, qq{string}, etc) can be specified by including the letter 'q' as a delimiter. Hence:</source>
          <target state="translated">引用符の区切り文字 &lt;code&gt;'&lt;/code&gt; 、 &lt;code&gt;&quot;&lt;/code&gt; 、 &lt;code&gt;`&lt;/code&gt; に加えて、Perlの引用のような完全な引用（つまり、q {string}、qq {string}など）は、区切り文字として文字' q 'を含めることで指定できます。</target>
        </trans-unit>
        <trans-unit id="3ee26c7c2937194436d9d08c9a82ea42e06abcd1" translate="yes" xml:space="preserve">
          <source>In addition to the six exported functions there exists one function that can only be accessed with a fully qualified function call.</source>
          <target state="translated">エクスポートされた6つの関数に加えて、完全修飾された関数呼び出しでしかアクセスできない関数が1つあります。</target>
        </trans-unit>
        <trans-unit id="048f808ac9289a4a6c87dcb85ac0e60ea7b3a024" translate="yes" xml:space="preserve">
          <source>In addition to the tie() interface, it is also possible to access most of the functions provided in the Berkeley DB API directly. See &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;&quot;THE API INTERFACE&quot;&lt;/a&gt;.</source>
          <target state="translated">tie（）インターフェースに加えて、Berkeley DBAPIで提供されるほとんどの関数に直接アクセスすることもできます。&lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;「APIインターフェース」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1fd0fd0dfb0a01af1b34dd0a74cf43897f0a81ea" translate="yes" xml:space="preserve">
          <source>In addition to the tie() interface, it is also possible to access most of the functions provided in the Berkeley DB API directly. See &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;THE API INTERFACE&lt;/a&gt;.</source>
          <target state="translated">tie（）インターフェースに加えて、Berkeley DB APIで提供されるほとんどの関数に直接アクセスすることもできます。&lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;APIインターフェイスを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="85ce3c1d378a3aef7a0dc077cfad69336b01172a" translate="yes" xml:space="preserve">
          <source>In addition to the traditional Perl default MRO (depth first search, called &lt;code&gt;DFS&lt;/code&gt; here), Perl now offers the C3 MRO as well. Perl's support for C3 is based on the work done in Stevan Little's module &lt;a href=&quot;Class::C3&quot;&gt;Class::C3&lt;/a&gt;, and most of the C3-related documentation here is ripped directly from there.</source>
          <target state="translated">従来のPerlのデフォルトMRO（深さ優先探索、ここでは &lt;code&gt;DFS&lt;/code&gt; と呼ばれます）に加えて、PerlはC3MROも提供するようになりました。PerlによるC3のサポートは、StevanLittleのモジュール&lt;a href=&quot;Class::C3&quot;&gt;Class :: C3&lt;/a&gt;で行われた作業に基づいており、ここにあるC3関連のドキュメントのほとんどはそこから直接リッピングされています。</target>
        </trans-unit>
        <trans-unit id="53b1ffa79f559c5952d0b2eca922c0eb1fe018a7" translate="yes" xml:space="preserve">
          <source>In addition to the traditional Perl default MRO (depth first search, called &lt;code&gt;DFS&lt;/code&gt; here), Perl now offers the C3 MRO as well. Perl's support for C3 is based on the work done in Stevan Little's module &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class::C3&lt;/a&gt;, and most of the C3-related documentation here is ripped directly from there.</source>
          <target state="translated">従来のPerlデフォルトMRO（ここでは &lt;code&gt;DFS&lt;/code&gt; と呼ばれる深さ優先検索）に加えて、PerlはC3 MROも提供するようになりました。PerlによるC3のサポートは、Stevan Littleのモジュール&lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class :: C3&lt;/a&gt;で行われた作業に基づいており、ここにあるC3関連のドキュメントのほとんどは、そこから直接取り込んでいます。</target>
        </trans-unit>
        <trans-unit id="8eca212407dc344e58d9927ac55df67e502679ba" translate="yes" xml:space="preserve">
          <source>In addition to the two arrays that form the inversion map, &lt;code&gt;prop_invmap&lt;/code&gt; returns two other values; one is a scalar that gives some details as to the format of the entries of the map array; the other is a default value, useful in maps whose format name begins with the letter &lt;code&gt;&quot;a&quot;&lt;/code&gt; , as described &lt;a href=&quot;#a&quot;&gt;below in its subsection&lt;/a&gt;; and for specialized purposes, such as converting to another data structure, described at the end of this main section.</source>
          <target state="translated">反転マップを形成する2つの配列に加えて、 &lt;code&gt;prop_invmap&lt;/code&gt; は他の2つの値を返します。1つは、マップ配列のエントリの形式に関する詳細を提供するスカラーです。もう1つはデフォルト値&lt;a href=&quot;#a&quot;&gt;であり、サブセクションで&lt;/a&gt;後述するように、フォーマット名が文字 &lt;code&gt;&quot;a&quot;&lt;/code&gt; で始まるマップで役立ちます。また、このメインセクションの最後で説明する、別のデータ構造への変換などの特殊な目的のため。</target>
        </trans-unit>
        <trans-unit id="a95287c02690513e66aa164f6a62d254e29970f0" translate="yes" xml:space="preserve">
          <source>In addition to the two arrays that form the inversion map, &lt;code&gt;prop_invmap&lt;/code&gt; returns two other values; one is a scalar that gives some details as to the format of the entries of the map array; the other is a default value, useful in maps whose format name begins with the letter &lt;code&gt;&quot;a&quot;&lt;/code&gt;, as described &lt;a href=&quot;#a&quot;&gt;below in its subsection&lt;/a&gt;; and for specialized purposes, such as converting to another data structure, described at the end of this main section.</source>
          <target state="translated">反転マップを形成する2つの配列に加えて、 &lt;code&gt;prop_invmap&lt;/code&gt; は他の2つの値を返します。 1つは、マップ配列のエントリの形式に関する詳細を提供するスカラーです。もう1つはデフォルト値であり、&lt;a href=&quot;#a&quot;&gt;以下のサブセクションで&lt;/a&gt;説明するように、フォーマット名が文字 &lt;code&gt;&quot;a&quot;&lt;/code&gt; で始まるマップで役立ちます。また、このメインセクションの最後で説明する、別のデータ構造への変換などの特殊な目的のために。</target>
        </trans-unit>
        <trans-unit id="5681bb6c22a6fc5f25fa9d9c98d1119dc3e69d9b" translate="yes" xml:space="preserve">
          <source>In addition to the version objects, this modules also replaces the core UNIVERSAL::VERSION function with one that uses version objects for its comparisons. The return from this operator is always the stringified form as a simple scalar (i.e. not an object), but the warning message generated includes either the stringified form or the normal form, depending on how it was called.</source>
          <target state="translated">バージョンオブジェクトに加えて、このモジュールはコアの UNIVERSAL::VERSION 関数を、比較にバージョンオブジェクトを使用する関数に置き換えています。この演算子からの戻り値は常に文字列化された形式の単純なスカラ(つまりオブジェクトではない)ですが、生成される警告メッセージには、呼び出された方法に応じて文字列化された形式と通常の形式のどちらかが含まれています。</target>
        </trans-unit>
        <trans-unit id="dab2897e25695e7867181ff90ba23794c8c60c0d" translate="yes" xml:space="preserve">
          <source>In addition to using the &lt;code&gt;\p{Blk=...}&lt;/code&gt; and &lt;code&gt;\P{Blk=...}&lt;/code&gt; constructs, you can also test whether a code point is in the</source>
          <target state="translated">&lt;code&gt;\p{Blk=...}&lt;/code&gt; および &lt;code&gt;\P{Blk=...}&lt;/code&gt; 構成の使用に加えて、コードポイントが</target>
        </trans-unit>
        <trans-unit id="dac7bc321eb3333dc44a14f1d9acf1fbd74fd29b" translate="yes" xml:space="preserve">
          <source>In addition to what was matched, Perl also provides the positions of what was matched as contents of the &lt;code&gt;@-&lt;/code&gt; and &lt;code&gt;@+&lt;/code&gt; arrays. &lt;code&gt;$-[0]&lt;/code&gt; is the position of the start of the entire match and &lt;code&gt;$+[0]&lt;/code&gt; is the position of the end. Similarly, &lt;code&gt;$-[n]&lt;/code&gt; is the position of the start of the &lt;code&gt;$n&lt;/code&gt; match and &lt;code&gt;$+[n]&lt;/code&gt; is the position of the end. If &lt;code&gt;$n&lt;/code&gt; is undefined, so are &lt;code&gt;$-[n]&lt;/code&gt; and &lt;code&gt;$+[n]&lt;/code&gt; . Then this code</source>
          <target state="translated">一致したものに加えて、Perlは &lt;code&gt;@-&lt;/code&gt; および &lt;code&gt;@+&lt;/code&gt; 配列のコンテンツとして一致したものの位置も提供します。 &lt;code&gt;$-[0]&lt;/code&gt; はマッチ全体の開始位置で、 &lt;code&gt;$+[0]&lt;/code&gt; は終了位置です。同様に、 &lt;code&gt;$-[n]&lt;/code&gt; は &lt;code&gt;$n&lt;/code&gt; マッチの開始位置であり、 &lt;code&gt;$+[n]&lt;/code&gt; は終了位置です。 &lt;code&gt;$n&lt;/code&gt; が未定義の場合、 &lt;code&gt;$-[n]&lt;/code&gt; と &lt;code&gt;$+[n]&lt;/code&gt; も同様です。次に、このコード</target>
        </trans-unit>
        <trans-unit id="ccbfdb924619efe15959974a161721499fe098ee" translate="yes" xml:space="preserve">
          <source>In addition to what was matched, Perl also provides the positions of what was matched as contents of the &lt;code&gt;@-&lt;/code&gt; and &lt;code&gt;@+&lt;/code&gt; arrays. &lt;code&gt;$-[0]&lt;/code&gt; is the position of the start of the entire match and &lt;code&gt;$+[0]&lt;/code&gt; is the position of the end. Similarly, &lt;code&gt;$-[n]&lt;/code&gt; is the position of the start of the &lt;code&gt;$n&lt;/code&gt; match and &lt;code&gt;$+[n]&lt;/code&gt; is the position of the end. If &lt;code&gt;$n&lt;/code&gt; is undefined, so are &lt;code&gt;$-[n]&lt;/code&gt; and &lt;code&gt;$+[n]&lt;/code&gt;. Then this code</source>
          <target state="translated">一致したものに加えて、Perlは &lt;code&gt;@-&lt;/code&gt; および &lt;code&gt;@+&lt;/code&gt; 配列の内容として一致したものの位置も提供します。 &lt;code&gt;$-[0]&lt;/code&gt; は試合全体の開始位置であり、 &lt;code&gt;$+[0]&lt;/code&gt; は終了位置です。同様に、 &lt;code&gt;$-[n]&lt;/code&gt; は &lt;code&gt;$n&lt;/code&gt; マッチの開始位置であり、 &lt;code&gt;$+[n]&lt;/code&gt; は終了位置です。 &lt;code&gt;$n&lt;/code&gt; が未定義の場合、 &lt;code&gt;$-[n]&lt;/code&gt; と &lt;code&gt;$+[n]&lt;/code&gt; も定義されていません。次に、このコード</target>
        </trans-unit>
        <trans-unit id="7741b40dbd2e708ac5c5d3ad7fd7389004debdeb" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;GetFileAttributes&lt;/code&gt; can return these constants (or INVALID_FILE_ATTRIBUTES in case of an error).</source>
          <target state="translated">さらに、 &lt;code&gt;GetFileAttributes&lt;/code&gt; はこれらの定数（またはエラーの場合はINVALID_FILE_ATTRIBUTES）を返すことができます。</target>
        </trans-unit>
        <trans-unit id="340df59f8245bd9d352756a2f3fe84ca2ba2b14a" translate="yes" xml:space="preserve">
          <source>In addition, Perl defines the following:</source>
          <target state="translated">また、Perlでは以下のように定義されています。</target>
        </trans-unit>
        <trans-unit id="7b18dfd70f7fb70cb969c8b7231702490b8ef572" translate="yes" xml:space="preserve">
          <source>In addition, Perl permits the following widely-supported conversions:</source>
          <target state="translated">さらに、Perlは以下のような広くサポートされている変換を許可しています。</target>
        </trans-unit>
        <trans-unit id="58a30b45039ea55ccfbff7c03b534706dd5f4a4e" translate="yes" xml:space="preserve">
          <source>In addition, a second package variable (&lt;code&gt;@Filter::Simple::components&lt;/code&gt; ) contains a list of the various pieces of &lt;code&gt;$_&lt;/code&gt; , as they were originally split up to allow placeholders to be inserted.</source>
          <target state="translated">さらに、2番目のパッケージ変数（ &lt;code&gt;@Filter::Simple::components&lt;/code&gt; ）には、元々プレースホルダーを挿入できるように分割されているため、 &lt;code&gt;$_&lt;/code&gt; さまざまな部分のリストが含まれています。</target>
        </trans-unit>
        <trans-unit id="b0ff23c18253f069733b435a5b431ccd9634d8e2" translate="yes" xml:space="preserve">
          <source>In addition, a second package variable (&lt;code&gt;@Filter::Simple::components&lt;/code&gt;) contains a list of the various pieces of &lt;code&gt;$_&lt;/code&gt;, as they were originally split up to allow placeholders to be inserted.</source>
          <target state="translated">さらに、2番目のパッケージ変数（ &lt;code&gt;@Filter::Simple::components&lt;/code&gt; ）には、プレースホルダーを挿入できるように元々分割されていたため、 &lt;code&gt;$_&lt;/code&gt; さまざまな部分のリストが含まれています。</target>
        </trans-unit>
        <trans-unit id="8b824cddab0454f6fa746f5f5efb2df055e6a062" translate="yes" xml:space="preserve">
          <source>In addition, an attempt is made to recognize several common Unix library names, and filter them out or convert them to their VMS equivalents, as appropriate.</source>
          <target state="translated">さらに、いくつかの一般的な Unix ライブラリ名を認識し、それらをフィルタリングしたり、必要に応じて VMS と同等のものに変換したりする試みがなされています。</target>
        </trans-unit>
        <trans-unit id="20f0764c130ac7b7bb4ff76a14f2a6cf3a71b811" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a simple filename, the default values for the &lt;code&gt;Name&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;TextFlag&lt;/code&gt; , &lt;code&gt;ExtAttr&lt;/code&gt; , &lt;code&gt;exUnixN&lt;/code&gt; and &lt;code&gt;exTime&lt;/code&gt; options will be sourced from that file.</source>
          <target state="translated">さらに、 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; が単純なファイル名である場合、 &lt;code&gt;Name&lt;/code&gt; 、 &lt;code&gt;Time&lt;/code&gt; 、 &lt;code&gt;TextFlag&lt;/code&gt; 、 &lt;code&gt;ExtAttr&lt;/code&gt; 、 &lt;code&gt;exUnixN&lt;/code&gt; および &lt;code&gt;exTime&lt;/code&gt; オプションのデフォルト値は、そのファイルから供給されます。</target>
        </trans-unit>
        <trans-unit id="bdc3e8410e98f27c3f135fcd34c0e133beddff18" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a simple filename, the default values for the &lt;code&gt;Name&lt;/code&gt; and &lt;code&gt;Time&lt;/code&gt; options will be sourced from that file.</source>
          <target state="translated">さらに、 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; が単純なファイル名の場合、[ &lt;code&gt;Name&lt;/code&gt; および[ &lt;code&gt;Time&lt;/code&gt; オプションのデフォルト値はそのファイルから取得されます。</target>
        </trans-unit>
        <trans-unit id="d0ae1b4a0292104ef4e7dc7c425220d101005db4" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;code&gt;$input_filename_or_reference&lt;/code&gt; is a simple filename, the default values for the &lt;code&gt;Name&lt;/code&gt;, &lt;code&gt;Time&lt;/code&gt;, &lt;code&gt;TextFlag&lt;/code&gt;, &lt;code&gt;ExtAttr&lt;/code&gt;, &lt;code&gt;exUnixN&lt;/code&gt; and &lt;code&gt;exTime&lt;/code&gt; options will be sourced from that file.</source>
          <target state="translated">さらに、 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; が単純なファイル名の場合、 &lt;code&gt;Name&lt;/code&gt; 、 &lt;code&gt;Time&lt;/code&gt; 、 &lt;code&gt;TextFlag&lt;/code&gt; 、 &lt;code&gt;ExtAttr&lt;/code&gt; 、 &lt;code&gt;exUnixN&lt;/code&gt; 、および &lt;code&gt;exTime&lt;/code&gt; オプションのデフォルト値はそのファイルから取得されます。</target>
        </trans-unit>
        <trans-unit id="91ed0a2f179c5ac2d45e1e913820f71e61b32911" translate="yes" xml:space="preserve">
          <source>In addition, if the input file/buffer does contain compressed data and there is non-compressed data immediately following it, setting this option will make this module treat the whole file/buffer as a single data stream.</source>
          <target state="translated">さらに、入力ファイル/バッファに圧縮データが含まれていて、その直後に非圧縮データがある場合、このオプションを設定すると、このモジュールはファイル/バッファ全体を単一のデータストリームとして扱うようになります。</target>
        </trans-unit>
        <trans-unit id="a03250cf8d36596835773013a7ed159131abe9f9" translate="yes" xml:space="preserve">
          <source>In addition, on failure in</source>
          <target state="translated">また、失敗した場合には</target>
        </trans-unit>
        <trans-unit id="1d296f66c5968bb02c723c76da82a489ff4f8824" translate="yes" xml:space="preserve">
          <source>In addition, other &lt;a href=&quot;Getopt::Long&quot;&gt;Getopt::Long&lt;/a&gt; error messages may result from invalid command-line options.</source>
          <target state="translated">さらに、他の&lt;a href=&quot;Getopt::Long&quot;&gt;Getopt :: Long&lt;/a&gt;エラーメッセージは、無効なコマンドラインオプションが原因で発生する場合があります。</target>
        </trans-unit>
        <trans-unit id="289227a7d3ba6bcbce57645ed49463f1d7e46764" translate="yes" xml:space="preserve">
          <source>In addition, other &lt;a href=&quot;getopt/long&quot;&gt;Getopt::Long&lt;/a&gt; error messages may result from invalid command-line options.</source>
          <target state="translated">さらに、他の&lt;a href=&quot;getopt/long&quot;&gt;Getopt :: Long&lt;/a&gt;エラーメッセージは、無効なコマンドラインオプションが原因で発生する場合があります。</target>
        </trans-unit>
        <trans-unit id="147a39b11e58c10277c6a279d8224a769b9bb498" translate="yes" xml:space="preserve">
          <source>In addition, output may be piped to a subprocess, using the character '|'. Anything after this character on the command line is passed to a subprocess for execution; the subprocess takes the output of Perl as its input.</source>
          <target state="translated">さらに、出力は '|' という文字を使って、サブプロセスにパイプされることがあります。コマンドライン上のこの文字以降の文字は、実行のためにサブプロセスに渡され、サブプロセスは Perl の出力を入力として受け取ります。</target>
        </trans-unit>
        <trans-unit id="99121fa175239d30527a66db54352aec9e7f4845" translate="yes" xml:space="preserve">
          <source>In addition, plenty of code in the wild does all of its OO &quot;by hand&quot;, using just the Perl built-in OO features. If you need to maintain such code, you should read &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; to understand exactly how Perl's built-in OO works.</source>
          <target state="translated">さらに、Perlの組み込みのOO機能だけを使用して、多くのコードが実際にOOのすべてを「手動」で実行します。このようなコードを保守する必要がある場合は、&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;を読んで、Perlの組み込みOOがどのように機能するかを正確に理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="df2c5f9f6d74347865f1b7d8c718b9166dce24c6" translate="yes" xml:space="preserve">
          <source>In addition, subroutines are named with an initial '&amp;amp;', though this is optional when unambiguous, just as the word &quot;do&quot; is often redundant in English. Symbol table entries can be named with an initial '*', but you don't really care about that yet (if ever :-).</source>
          <target state="translated">さらに、サブルーチンには最初の「＆」で名前が付けられますが、これは、「do」という単語が英語で冗長になることが多いのと同様に、曖昧でない場合はオプションです。シンボルテーブルエントリは、頭文字 '*'を使用して名前を付けることができますが、まだ気にしていません（あるとしても:-)。</target>
        </trans-unit>
        <trans-unit id="e4639b7e9ac66cd60ee8c3525c4580bbed98b234" translate="yes" xml:space="preserve">
          <source>In addition, the generated &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine passes its own argument list to the filtering subroutine, so the BANG.pm filter could easily be made parametric:</source>
          <target state="translated">さらに、生成された &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; サブルーチンは独自の引数リストをフィルタリングサブルーチンに渡すため、BANG.pmフィルターを簡単にパラメトリックにすることができます。</target>
        </trans-unit>
        <trans-unit id="804038d4a839a29500af9574b5756d8de10f044f" translate="yes" xml:space="preserve">
          <source>In addition, the generated &lt;code&gt;import&lt;/code&gt; subroutine passes its own argument list to the filtering subroutine, so the BANG.pm filter could easily be made parametric:</source>
          <target state="translated">さらに、生成された &lt;code&gt;import&lt;/code&gt; サブルーチンは、独自の引数リストをフィルタリングサブルーチンに渡すため、BANG.pmフィルターを簡単にパラメトリックにすることができます。</target>
        </trans-unit>
        <trans-unit id="9370bc00f7d65fe78c300f43b36130879db13c63" translate="yes" xml:space="preserve">
          <source>In addition, the new IO system can also be configured to read/write UTF-8 encoded characters (as noted above, this is efficient):</source>
          <target state="translated">また、新IOシステムでは、UTF-8でエンコードされた文字を読み書きするように構成することも可能です(前述の通り、これが効率的です)。</target>
        </trans-unit>
        <trans-unit id="3e36eb4b4d16be01e13411f12c4f853328d8d124" translate="yes" xml:space="preserve">
          <source>In addition, the returned value will be unique within the context of the Pod::Simple::XHTML object unless a second argument is passed a true value. ID attributes should always be unique within a single XHTML document, but pass the true value if you are creating not an ID but a URL hash to point to an ID (i.e., if you need to put the &quot;#foo&quot; in &lt;code&gt;&amp;lt;a href=&quot;#foo&quot;&amp;gt;foo&amp;lt;/a&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">さらに、2番目の引数にtrue値が渡されない限り、戻り値はPod :: Simple :: XHTMLオブジェクトのコンテキスト内で一意になります。ID属性は常に単一のXHTMLドキュメント内で一意である必要がありますが、IDではなくURLハッシュを作成してIDを指す場合（つまり、「＃foo」を &lt;code&gt;&amp;lt;a href=&quot;#foo&quot;&amp;gt;foo&amp;lt;/a&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de0edea48e0434c59597ceff4d726d410f442fce" translate="yes" xml:space="preserve">
          <source>In addition, when ldopts is called with parameters, it will return the argument string rather than print it to STDOUT.</source>
          <target state="translated">また、ldoptsはパラメータを指定して呼び出された場合、STDOUTに出力するのではなく、引数の文字列を返します。</target>
        </trans-unit>
        <trans-unit id="3769f70780de829d878e1b8185000692b19a1f05" translate="yes" xml:space="preserve">
          <source>In addition, you must define a &lt;code&gt;AUTODIE_HINTS&lt;/code&gt; subroutine that returns a hash-reference containing the hints for your subroutines:</source>
          <target state="translated">さらに、サブルーチンのヒントを含むハッシュ参照を返す &lt;code&gt;AUTODIE_HINTS&lt;/code&gt; サブルーチンを定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="0fe8a6e2911b84e5bf182d375e70d71ebf4dcde5" translate="yes" xml:space="preserve">
          <source>In all Perl versions you can use &lt;code&gt;as_number()&lt;/code&gt; or &lt;code&gt;as_int&lt;/code&gt; for the same effect:</source>
          <target state="translated">すべてのPerlバージョンで、同じ効果のために &lt;code&gt;as_number()&lt;/code&gt; または &lt;code&gt;as_int&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="9a826c545f2fecb5bd50e173dbd7f3d696f12f03" translate="yes" xml:space="preserve">
          <source>In all Perl versions, &lt;code&gt;\s&lt;/code&gt; matches the 5 characters [\t\n\f\r ]; that is, the horizontal tab, the newline, the form feed, the carriage return, and the space. Starting in Perl v5.18, it also matches the vertical tab, &lt;code&gt;\cK&lt;/code&gt; . See note &lt;code&gt;[1]&lt;/code&gt; below for a discussion of this.</source>
          <target state="translated">すべてのバージョンのPerlでは、 &lt;code&gt;\s&lt;/code&gt; は5文字に一致します[\ t \ n \ f \ r]; つまり、水平タブ、改行、フォームフィード、キャリッジリターン、スペースです。Perl v5.18以降では、垂直タブ &lt;code&gt;\cK&lt;/code&gt; にも一致します。これについては、下の注 &lt;code&gt;[1]&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="c841b634904e3955229cb8026fd88108b68b251d" translate="yes" xml:space="preserve">
          <source>In all Perl versions, &lt;code&gt;\s&lt;/code&gt; matches the 5 characters [\t\n\f\r ]; that is, the horizontal tab, the newline, the form feed, the carriage return, and the space. Starting in Perl v5.18, it also matches the vertical tab, &lt;code&gt;\cK&lt;/code&gt;. See note &lt;code&gt;[1]&lt;/code&gt; below for a discussion of this.</source>
          <target state="translated">すべてのPerlバージョンで、 &lt;code&gt;\s&lt;/code&gt; は5文字に一致します[\ t \ n \ f \ r]; つまり、水平タブ、改行、フォームフィード、キャリッジリターン、およびスペースです。Perl v5.18以降では、垂直タブ &lt;code&gt;\cK&lt;/code&gt; とも一致します。これについては、以下の注 &lt;code&gt;[1]&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="781b45f1e32e901ab32d784bb9ee31c8ef4d8da4" translate="yes" xml:space="preserve">
          <source>In all but the most memory-paranoid configurations (ex: PURIFY), heads and bodies are allocated out of arenas, which by default are approximately 4K chunks of memory parcelled up into N heads or bodies. Sv-bodies are allocated by their sv-type, guaranteeing size consistency needed to allocate safely from arrays.</source>
          <target state="translated">最もメモリに偏執的な設定(例:PURIFY)以外のすべての場合、ヘッドとボディはアリーナから割り当てられます。Sv-body は sv-type によって割り当てられ、配列から安全に割り当てるために必要なサイズの一貫性が保証されます。</target>
        </trans-unit>
        <trans-unit id="82cf0166b1026f5214dc5e9dee6752fb9c70f2f9" translate="yes" xml:space="preserve">
          <source>In all cases shown above, the line indentation shows the call tree. If bit 2 of &lt;code&gt;frame&lt;/code&gt; is set, a line is printed on exit from a subroutine as well. If bit 4 is set, the arguments are printed along with the caller info. If bit 8 is set, the arguments are printed even if they are tied or references. If bit 16 is set, the return value is printed, too.</source>
          <target state="translated">上記のすべてのケースで、行のインデントは呼び出しツリーを示しています。 &lt;code&gt;frame&lt;/code&gt; ビット2 が設定されている場合、サブルーチンの終了時にも行が出力されます。ビット4が設定されている場合、引数は呼び出し元の情報とともに出力されます。ビット8が設定されている場合、引き数または参照であっても、引数が出力されます。ビット16が設定されている場合、戻り値も出力されます。</target>
        </trans-unit>
        <trans-unit id="6061ee2ae8dec0f2b671e0d3e14bae7a6b818d83" translate="yes" xml:space="preserve">
          <source>In all cases where the very common phenomenon of quantification (saying &quot;</source>
          <target state="translated">定量化(と言う)という非常に一般的な現象が発生しているすべてのケースで</target>
        </trans-unit>
        <trans-unit id="e3c2c7f74b86dde15a7c489ee7be1789b4697e9f" translate="yes" xml:space="preserve">
          <source>In all dealings with contributed modules, everyone maintaining Perl should keep in mind that the code belongs to the original author, that they may not be on perl5-porters at any given time, and that a patch is not official unless it has been integrated into the author's copy of the module. To aid with this, and with points #1, #2, and #3 above, contact information for the authors of all contributed modules should be kept with the Perl distribution.</source>
          <target state="translated">貢献されたモジュールとのすべての取引において、Perl を管理しているすべての人は、コードが元の作者に属していること、それらがいつでも perl5-porters にあるわけではないこと、そして、パッチが作者のモジュールのコピーに統合されていない限り、公式なものではないことを心に留めておく必要があります。これを助けるために、また上記のポイント#1,#2,#3を助けるために、貢献したすべてのモジュールの作者の連絡先情報は、Perl の配布物と一緒に保管しておくべきです。</target>
        </trans-unit>
        <trans-unit id="9f633a9cd1f1e79fef8f8eaa0a6cfd15cedc67ef" translate="yes" xml:space="preserve">
          <source>In all of the above cases, option values may be inserted in the bundle. For example:</source>
          <target state="translated">上記のすべての場合において、オプション値をバンドルに挿入してもよい。例えば、以下のような場合です。</target>
        </trans-unit>
        <trans-unit id="2383a8bd7489fcdd2f83ac67cbbc873796c97eb5" translate="yes" xml:space="preserve">
          <source>In all operations on %ENV, the key string is treated as if it were entirely uppercase, regardless of the case actually specified in the Perl expression.</source>
          <target state="translated">ENV のすべての操作では、Perl 式で実際に指定された大文字と小文字に関係なく、キー文字列は完全に大文字であるかのように扱われます。</target>
        </trans-unit>
        <trans-unit id="95b3792cd6f5e2af35835ac883e0e6a53f125114" translate="yes" xml:space="preserve">
          <source>In all the above examples, &lt;code&gt;minus()&lt;/code&gt; is required only to return the result of the subtraction: Perl takes care of the assignment to $x. In fact, such methods should</source>
          <target state="translated">上記のすべての例で、 &lt;code&gt;minus()&lt;/code&gt; の結果は、減算の結果を返すためにのみ必要です。Perlが$ xへの代入を処理します。実際、そのようなメソッドは</target>
        </trans-unit>
        <trans-unit id="62e6398632ccd73e2b501ee72778e7e043a2eb59" translate="yes" xml:space="preserve">
          <source>In all the previous examples I have 'hard-wired' the name of the Perl subroutine to be called from C. Most of the time though, it is more convenient to be able to specify the name of the Perl subroutine from within the Perl script, and you'll want to use &lt;a href=&quot;perlapi#call_sv&quot;&gt;call_sv&lt;/a&gt;.</source>
          <target state="translated">これまでのすべての例で、Cから呼び出されるPerlサブルーチンの名前を「ハードワイヤード」しました。ただし、ほとんどの場合、Perlスクリプト内からPerlサブルーチンの名前を指定できる方が便利です。 、および&lt;a href=&quot;perlapi#call_sv&quot;&gt;call_sv&lt;/a&gt;を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="97f2c173d7ed4e9aee1d1f9fb64f4d9f9b0ea2fe" translate="yes" xml:space="preserve">
          <source>In all the previous examples I have 'hard-wired' the name of the Perl subroutine to be called from C. Most of the time though, it is more convenient to be able to specify the name of the Perl subroutine from within the Perl script.</source>
          <target state="translated">これまでの例では、Perlのサブルーチン名をCから呼び出すように「ハードワイヤリング」していましたが、ほとんどの場合、Perlスクリプト内からPerlのサブルーチン名を指定できる方が便利です。</target>
        </trans-unit>
        <trans-unit id="ff04c34f746275001332ffb6b05f235dced368be" translate="yes" xml:space="preserve">
          <source>In all these calls, the &lt;code&gt;U32 w&lt;i&gt;n&lt;/i&gt;&lt;/code&gt; parameters are warning category constants. You can see the ones currently available in &lt;a href=&quot;warnings#Category-Hierarchy&quot;&gt;&quot;Category Hierarchy&quot; in warnings&lt;/a&gt;, just capitalize all letters in the names and prefix them by &lt;code&gt;WARN_&lt;/code&gt;. So, for example, the category &lt;code&gt;void&lt;/code&gt; used in a perl program becomes &lt;code&gt;WARN_VOID&lt;/code&gt; when used in XS code and passed to one of the calls below.</source>
          <target state="translated">すべてのこれらの呼び出しでは、 &lt;code&gt;U32 w&lt;i&gt;n&lt;/i&gt;&lt;/code&gt; パラメータは、カテゴリ定数を警告しています。&lt;a href=&quot;warnings#Category-Hierarchy&quot;&gt;「CategoryHierarchy」で&lt;/a&gt;現在利用可能なものは警告で &lt;code&gt;WARN_&lt;/code&gt; ます。名前のすべての文字を大文字にして、接頭辞WARN_を付けるだけです。したがって、たとえば、perlプログラムで使用されるカテゴリ &lt;code&gt;void&lt;/code&gt; は、XSコードで使用され、以下のいずれかの呼び出しに渡されると、 &lt;code&gt;WARN_VOID&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="aaae17ed6f36eac3220705015e0ea930013f7c8e" translate="yes" xml:space="preserve">
          <source>In all these cases, the user can override this stubborn behaviour by prepending the command with the word force, for example:</source>
          <target state="translated">これらすべての場合において、ユーザはコマンドの前に force という単語を付けることで、この頑固な挙動を上書きすることができます。</target>
        </trans-unit>
        <trans-unit id="4cbe02d68ddbd502acef7d9e9916746fae4beca6" translate="yes" xml:space="preserve">
          <source>In almost all cases like this, it's usually a far, far better idea to use the structured control flow mechanisms of &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; instead of resorting to a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;. For certain applications, the catch and throw pair of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; and die() for exception processing can also be a prudent approach.</source>
          <target state="translated">このようなほとんどすべてのケースで、 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; に頼る代わりに、 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; の構造化制御フローメカニズムを使用する方がはるかに優れています。特定のアプリケーションでは、例外処理用の &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; とdie（）のキャッチアンドスローペアも賢明なアプローチになる場合があります。</target>
        </trans-unit>
        <trans-unit id="bcd7916d5198052c029284d36ab0810a786fae19" translate="yes" xml:space="preserve">
          <source>In almost all cases like this, it's usually a far, far better idea to use the structured control flow mechanisms of &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;, or &lt;code&gt;redo&lt;/code&gt; instead of resorting to a &lt;code&gt;goto&lt;/code&gt;. For certain applications, the catch and throw pair of &lt;code&gt;eval{}&lt;/code&gt; and die() for exception processing can also be a prudent approach.</source>
          <target state="translated">このようなほとんどすべての場合、 &lt;code&gt;goto&lt;/code&gt; に頼るのではなく、 &lt;code&gt;next&lt;/code&gt; 、 &lt;code&gt;last&lt;/code&gt; 、または &lt;code&gt;redo&lt;/code&gt; の構造化された制御フローメカニズムを使用することをお勧めします。特定のアプリケーションでは、例外処理のための &lt;code&gt;eval{}&lt;/code&gt; とdie（）のキャッチアンドスローペアも賢明なアプローチです。</target>
        </trans-unit>
        <trans-unit id="8cf0558a3828c482ff92b5a9786f51b397db3041" translate="yes" xml:space="preserve">
          <source>In an array context &lt;code&gt;extract_multiple&lt;/code&gt; returns an array of substrings of the original string, as extracted by the specified extractors. In a scalar context, &lt;code&gt;extract_multiple&lt;/code&gt; returns the first substring successfully extracted from the original string. In both scalar and void contexts the original string has the first successfully extracted substring removed from it. In all contexts &lt;code&gt;extract_multiple&lt;/code&gt; starts at the current &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; of the string, and sets that &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; appropriately after it matches.</source>
          <target state="translated">配列コンテキストでは、 &lt;code&gt;extract_multiple&lt;/code&gt; は、指定されたエクストラクタによって抽出された、元の文字列の部分文字列の配列を返します。スカラーコンテキストでは、 &lt;code&gt;extract_multiple&lt;/code&gt; は元の文字列から正常に抽出された最初の部分文字列を返します。スカラーコンテキストとvoidコンテキストの両方で、元の文字列から最初に正常に抽出された部分文字列が削除されます。すべてのコンテキストで、 &lt;code&gt;extract_multiple&lt;/code&gt; は文字列の現在の &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; から始まり、一致した後にその &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; を適切に設定します。</target>
        </trans-unit>
        <trans-unit id="64f4703d98a2bbd61fb2abe591377e6cc1a8eae4" translate="yes" xml:space="preserve">
          <source>In an array context &lt;code&gt;extract_multiple&lt;/code&gt; returns an array of substrings of the original string, as extracted by the specified extractors. In a scalar context, &lt;code&gt;extract_multiple&lt;/code&gt; returns the first substring successfully extracted from the original string. In both scalar and void contexts the original string has the first successfully extracted substring removed from it. In all contexts &lt;code&gt;extract_multiple&lt;/code&gt; starts at the current &lt;code&gt;pos&lt;/code&gt; of the string, and sets that &lt;code&gt;pos&lt;/code&gt; appropriately after it matches.</source>
          <target state="translated">配列コンテキストでは、 &lt;code&gt;extract_multiple&lt;/code&gt; は、指定されたエクストラクタによって抽出された、元の文字列の部分文字列の配列を返します。スカラーコンテキストでは、 &lt;code&gt;extract_multiple&lt;/code&gt; は、元の文字列から正常に抽出された最初の部分文字列を返します。スカラーコンテキストとvoidコンテキストの両方で、元の文字列では、最初に正常に抽出された部分文字列が削除されます。すべてのコンテキストで &lt;code&gt;extract_multiple&lt;/code&gt; 現在で始まる &lt;code&gt;pos&lt;/code&gt; 文字列の、およびセットその &lt;code&gt;pos&lt;/code&gt; それが一致して適切後。</target>
        </trans-unit>
        <trans-unit id="0bf045366670deb82562441b69ea96760a43c736" translate="yes" xml:space="preserve">
          <source>In an array context the return value is a list containing, the number of articles in the group, the number of the first article, the number of the last article and the group name.</source>
          <target state="translated">配列のコンテキストでは、戻り値はグループ内の記事の数、最初の記事の数、最後の記事の数、グループ名を含むリストです。</target>
        </trans-unit>
        <trans-unit id="5a5982cddd4d8975197c2744da1608d9e4548d41" translate="yes" xml:space="preserve">
          <source>In an array context, returns a list of lines returned from the server. In a scalar context, returns a reference to a list.</source>
          <target state="translated">配列コンテキストでは、サーバから返された行のリストを返します。スカラコンテキストでは、リストへの参照を返します。</target>
        </trans-unit>
        <trans-unit id="c41a798a42099e75be11d7d0369af1bc79b214a4" translate="yes" xml:space="preserve">
          <source>In an interpolated literal, whether a double-quoted string or a regex, you may specify a character by its number using the &lt;code&gt;\x{&lt;i&gt;HHHHHH&lt;/i&gt;}&lt;/code&gt; escape.</source>
          <target state="translated">補間されたリテラルでは、二重引用符で囲まれた文字列でも正規表現でも、 &lt;code&gt;\x{&lt;i&gt;HHHHHH&lt;/i&gt;}&lt;/code&gt; エスケープを使用して、文字を番号で指定できます。</target>
        </trans-unit>
        <trans-unit id="4918ab5fdbd686e859250551837a7ee9a52207eb" translate="yes" xml:space="preserve">
          <source>In ancient times, Unix was also used to refer to some code that a couple of people at Bell Labs wrote to make use of a PDP-7 computer that wasn&amp;rsquo;t doing much of anything else at the time.</source>
          <target state="translated">昔、Unixは、ベル研究所の数人が当時、他にほとんど何もしていなかったPDP-7コンピュータを利用するために書いたいくつかのコードを参照するためにも使用されました。</target>
        </trans-unit>
        <trans-unit id="d17b1ed4f6399a33863173b63d7cf4eeef9ce1db" translate="yes" xml:space="preserve">
          <source>In any case do not expect nanosecond resolution, or even a microsecond resolution. Also note that the modify/access timestamps might have different resolutions, and that they need not be synchronized, e.g. if the operations are</source>
          <target state="translated">どのような場合でも、ナノ秒やマイクロ秒の分解能を期待してはいけません。また、モディファイ/アクセスのタイムスタンプは異なる解像度を持つかもしれないこと、そして、それらは同期する必要がないことにも注意してください。</target>
        </trans-unit>
        <trans-unit id="a2ea48b73fadf70f92647ed4cbbc7d19e3016b8b" translate="yes" xml:space="preserve">
          <source>In any case you will be prompted with the correct invocation of the &lt;code&gt;inst_perl&lt;/code&gt; target that installs the new binary into INSTALLBIN.</source>
          <target state="translated">いずれの場合も、新しいバイナリをINSTALLBINにインストールする &lt;code&gt;inst_perl&lt;/code&gt; ターゲットを正しく呼び出すように求められます。</target>
        </trans-unit>
        <trans-unit id="416ebb085a2d5e940040c711d2f8d1e17ddebb19" translate="yes" xml:space="preserve">
          <source>In any way, if you're seeing failures beyond those mentioned in this document, please consider upgrading to the latest Hurd before reporting the failure as a bug.</source>
          <target state="translated">いずれにしても、本書に記載されている以上の障害が発生している場合は、バグとして報告する前に、最新のHurdへのアップグレードを検討してください。</target>
        </trans-unit>
        <trans-unit id="86069d4fc266f927b18d767a1cba7026af51c3e5" translate="yes" xml:space="preserve">
          <source>In array context returns a two-element array with the seconds and microseconds since the epoch. In scalar context returns floating seconds like &lt;code&gt;Time::HiRes::time()&lt;/code&gt; (see below).</source>
          <target state="translated">配列コンテキストでは、エポックからの秒とマイクロ秒を含む2要素の配列を返します。スカラーコンテキストでは、 &lt;code&gt;Time::HiRes::time()&lt;/code&gt; ような浮動秒を返します（以下を参照）。</target>
        </trans-unit>
        <trans-unit id="16582d55b272e81d53e1e61c0aba11a653333faf" translate="yes" xml:space="preserve">
          <source>In between two &lt;b&gt;subscripts&lt;/b&gt;, the arrow is optional.</source>
          <target state="translated">2つの&lt;b&gt;添え字の&lt;/b&gt;間の矢印はオプションです。</target>
        </trans-unit>
        <trans-unit id="e15bc0bc69692882714387f5e16ad85b014d51b1" translate="yes" xml:space="preserve">
          <source>In block mode, &lt;code&gt;filter_read&lt;/code&gt; will append a block of data which is &amp;lt;= &lt;code&gt;$size&lt;/code&gt; to the end of the &lt;code&gt;$_&lt;/code&gt; scalar. It is important to emphasise the that &lt;code&gt;filter_read&lt;/code&gt; will not necessarily read a block which is</source>
          <target state="translated">ブロックモードでは、 &lt;code&gt;filter_read&lt;/code&gt; は&amp;lt; &lt;code&gt;$_&lt;/code&gt; &lt;code&gt;$size&lt;/code&gt; のデータブロックを$ _スカラーの末尾に追加します。 &lt;code&gt;filter_read&lt;/code&gt; が必ずしもブロックであるとは限らないことを強調することが重要です。</target>
        </trans-unit>
        <trans-unit id="86311b9447535cd22a0807e557574828944f0087" translate="yes" xml:space="preserve">
          <source>In bootstrapping situations it is usually sufficient to translate only a few YAML files to Data::Dumper for crucial modules like &lt;code&gt;YAML::Syck&lt;/code&gt; , &lt;code&gt;YAML.pm&lt;/code&gt; and &lt;code&gt;Expect.pm&lt;/code&gt; . If you prefer Storable over Data::Dumper, remember to pull out a Storable version that writes an older format than all the other Storable versions that will need to read them.</source>
          <target state="translated">ブートストラップの状況では、通常、 &lt;code&gt;YAML::Syck&lt;/code&gt; 、 &lt;code&gt;YAML.pm&lt;/code&gt; 、および &lt;code&gt;Expect.pm&lt;/code&gt; などの重要なモジュールの場合、少数のYAMLファイルのみをData :: Dumperに変換するだけで十分です。Data :: DumperよりもStorableを使用する場合は、それらを読み取る必要がある他のすべてのStorableバージョンよりも古いフォーマットを書き込むStorableバージョンを必ずプルしてください。</target>
        </trans-unit>
        <trans-unit id="193c5d594ac73cc20a544832d2468fc8181bf983" translate="yes" xml:space="preserve">
          <source>In both cases events are generated and stored in an array. This array is eventually used to populate the &lt;code&gt;subevents&lt;/code&gt; attribute on the &lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2::Event::Subtest&lt;/a&gt; event that is generated at the end of the subtest. This flag has no effect on this part, it always happens.</source>
          <target state="translated">どちらの場合も、イベントが生成され、配列に格納されます。この配列は、最終的に、 &lt;code&gt;subevents&lt;/code&gt; &lt;a href=&quot;Test2::Event::Subtest&quot;&gt;テスト&lt;/a&gt;の最後に生成されるTest2 :: Event :: Subtestイベントのサブイベント属性を設定するために使用されます。このフラグはこの部分には影響しません。常に発生します。</target>
        </trans-unit>
        <trans-unit id="7d32bdf3cfc0bcbd8616099443aea4c2f02bae5f" translate="yes" xml:space="preserve">
          <source>In both cases this should only be considered to be a temporary measure - you should upgrade to the later version of perl as soon as is practicable.</source>
          <target state="translated">どちらの場合も、これは一時的な措置であると考えるべきです。</target>
        </trans-unit>
        <trans-unit id="d2a841147fc72cc4482e0a7e84067a22e8db15fe" translate="yes" xml:space="preserve">
          <source>In both cases, if you want access to the original, unaltered routine, use the &lt;code&gt;CORE::&lt;/code&gt; prefix:</source>
          <target state="translated">どちらの場合も、元の変更されていないルーチンにアクセスする場合は、 &lt;code&gt;CORE::&lt;/code&gt; プレフィックスを使用します。</target>
        </trans-unit>
        <trans-unit id="3b49d045d120cddc991a05308fecf5d02438bfd9" translate="yes" xml:space="preserve">
          <source>In both cases, it is strongly recommended that you use these flags when you run Configure. If you do not use do this, but later answer the questions about 64-bit numbers when Configure asks you, you may get a configuration that cannot be compiled, or that does not function as expected.</source>
          <target state="translated">どちらの場合も、Configure を実行する際にこれらのフラグを使用することを強くお勧めします。do this を使用せずに、後になって Configure が 64 ビットの数値に関する質問に答えた場合、コンパイルできない設定や期待通りに機能しない設定が得られる可能性があります。</target>
        </trans-unit>
        <trans-unit id="cb84a1bc50cca6fcae9507ee085502026d5e423b" translate="yes" xml:space="preserve">
          <source>In both forms, the value returned is the value of the last expression evaluated inside the mini-program; a return statement may also be used, just as with subroutines. The expression providing the return value is evaluated in void, scalar, or list context, depending on the context of the &lt;code&gt;eval&lt;/code&gt; itself. See &lt;a href=&quot;#wantarray&quot;&gt;&lt;code&gt;wantarray&lt;/code&gt;&lt;/a&gt; for more on how the evaluation context can be determined.</source>
          <target state="translated">どちらの形式でも、返される値は、ミニプログラム内で評価された最後の式の値です。サブルーチンの場合と同様に、returnステートメントも使用できます。戻り値を提供する式は、 &lt;code&gt;eval&lt;/code&gt; 自体のコンテキストに応じて、void、スカラー、またはリストのコンテキストで評価されます。評価コンテキストを決定する方法の詳細については、&lt;a href=&quot;#wantarray&quot;&gt; &lt;code&gt;wantarray&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="28f5f411ebc893dbf219e8f06f5338fdd368072e" translate="yes" xml:space="preserve">
          <source>In both forms, the value returned is the value of the last expression evaluated inside the mini-program; a return statement may be also used, just as with subroutines. The expression providing the return value is evaluated in void, scalar, or list context, depending on the context of the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself. See &lt;a href=&quot;wantarray&quot;&gt;wantarray&lt;/a&gt; for more on how the evaluation context can be determined.</source>
          <target state="translated">どちらの形式でも、返される値はミニプログラム内で評価された最後の式の値です。サブルーチンと同様に、returnステートメントも使用できます。戻り値を提供する式は、 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 自体のコンテキストに応じて、void、スカラー、またはリストのコンテキストで評価されます。評価コンテキストを決定する方法の詳細については、&lt;a href=&quot;wantarray&quot;&gt;wantarray&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4a7857febf47f6d9d7d4d6147004e7ae7af4e0b5" translate="yes" xml:space="preserve">
          <source>In both forms, the value returned is the value of the last expression evaluated inside the mini-program; a return statement may be also used, just as with subroutines. The expression providing the return value is evaluated in void, scalar, or list context, depending on the context of the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself. See &lt;a href=&quot;#wantarray&quot;&gt;wantarray&lt;/a&gt; for more on how the evaluation context can be determined.</source>
          <target state="translated">どちらの形式でも、返される値はミニプログラム内で評価された最後の式の値です。サブルーチンと同様に、returnステートメントも使用できます。戻り値を提供する式は、 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 自体のコンテキストに応じて、void、スカラー、またはリストのコンテキストで評価されます。評価コンテキストを決定する方法の詳細については、&lt;a href=&quot;#wantarray&quot;&gt;wantarray&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c9f62f445147592772dba8cf7d0b7f085f6d5d1f" translate="yes" xml:space="preserve">
          <source>In both last cases, the last expression is evaluated in the context that was applied to the &lt;code&gt;given&lt;/code&gt; block.</source>
          <target state="translated">最後のどちらの場合でも、最後の式は、 &lt;code&gt;given&lt;/code&gt; されたブロックに適用されたコンテキストで評価されます。</target>
        </trans-unit>
        <trans-unit id="faca50452b363bafe8294bb759677cc9d971a027" translate="yes" xml:space="preserve">
          <source>In both the case of unquoted command line arguments or in calls to &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; VMS wildcard expansion is performed. (csh-style wildcard expansion is available if you use &lt;code&gt;File::Glob::glob&lt;/code&gt; .) If the wildcard filespec contains a device or directory specification, then the resultant filespecs will also contain a device and directory; otherwise, device and directory information are removed. VMS-style resultant filespecs will contain a full device and directory, while Unix-style resultant filespecs will contain only as much of a directory path as was present in the input filespec. For example, if your default directory is Perl_Root:[000000], the expansion of &lt;code&gt;[.t]*.*&lt;/code&gt; will yield filespecs like &quot;perl_root:[t]base.dir&quot;, while the expansion of &lt;code&gt;t/*/*&lt;/code&gt; will yield filespecs like &quot;t/base.dir&quot;. (This is done to match the behavior of glob expansion performed by Unix shells.)</source>
          <target state="translated">引用符で囲まれていないコマンドライン引数の場合も、 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; の呼び出しの場合も、VMSワイルドカード拡張が実行されます。 （cshスタイルのワイルドカード拡張は、 &lt;code&gt;File::Glob::glob&lt;/code&gt; を使用する場合に使用できます。）ワイルドカードファイル指定にデバイスまたはディレクトリの指定が含まれている場合、結果のファイル指定にもデバイスとディレクトリが含まれます。それ以外の場合、デバイスとディレクトリの情報は削除されます。 VMSスタイルの結果のファイル仕様には、完全なデバイスとディレクトリが含まれますが、Unixスタイルの結果のファイル仕様には、入力ファイル仕様に存在していたのと同じだけのディレクトリパスが含まれます。たとえば、デフォルトのディレクトリがPerl_Root：[000000]の場合、 &lt;code&gt;[.t]*.*&lt;/code&gt; すると「perl_root：[t] base.dir」のようなファイル仕様が生成され、 &lt;code&gt;t/*/*&lt;/code&gt; を展開すると「t / base.dir」のようなファイル仕様を生成します。（これは、Unixシェルによって実行されるグロブ拡張の動作と一致させるために行われます。）</target>
        </trans-unit>
        <trans-unit id="151a64667d69a6e020ca3351948ca015aaa39af7" translate="yes" xml:space="preserve">
          <source>In both the case of unquoted command line arguments or in calls to &lt;code&gt;glob()&lt;/code&gt; VMS wildcard expansion is performed. (csh-style wildcard expansion is available if you use &lt;code&gt;File::Glob::glob&lt;/code&gt;.) If the wildcard filespec contains a device or directory specification, then the resultant filespecs will also contain a device and directory; otherwise, device and directory information are removed. VMS-style resultant filespecs will contain a full device and directory, while Unix-style resultant filespecs will contain only as much of a directory path as was present in the input filespec. For example, if your default directory is Perl_Root:[000000], the expansion of &lt;code&gt;[.t]*.*&lt;/code&gt; will yield filespecs like &quot;perl_root:[t]base.dir&quot;, while the expansion of &lt;code&gt;t/*/*&lt;/code&gt; will yield filespecs like &quot;t/base.dir&quot;. (This is done to match the behavior of glob expansion performed by Unix shells.)</source>
          <target state="translated">引用符で囲まれていないコマンドライン引数の場合、または &lt;code&gt;glob()&lt;/code&gt; の呼び出しの場合の両方で、VMSワイルドカード展開が実行されます。 （ &lt;code&gt;File::Glob::glob&lt;/code&gt; を使用すると、cshスタイルのワイルドカード拡張を使用できます。）ワイルドカードfilespecにデバイスまたはディレクトリの仕様が含まれている場合、結果のfilespecにはデバイスとディレクトリも含まれます。それ以外の場合は、デバイスとディレクトリの情報が削除されます。 VMSスタイルの結果のfilespecには、完全なデバイスとディレクトリが含まれますが、Unixスタイルの結果のfilespecには、入力filespecに存在したのと同じ量のディレクトリパスのみが含まれます。たとえば、デフォルトのディレクトリがPerl_Root：[000000]の場合、 &lt;code&gt;[.t]*.*&lt;/code&gt; を展開すると、「perl_root：[t] base.dir」のようなファイル仕様が生成されますが、 &lt;code&gt;t/*/*&lt;/code&gt; を展開すると「t / base.dir」のようなファイル仕様が生成されます。（これは、Unixシェルによって実行されるglob拡張の動作と一致させるために行われます。）</target>
        </trans-unit>
        <trans-unit id="7acbdc4bab7e93326f2e293e78aa137135b956f7" translate="yes" xml:space="preserve">
          <source>In both these examples, the character being matched is non-Unicode, so Unicode doesn't define how it should match. It clearly isn't an ASCII hex digit, so the first example clearly should fail, and so it does, with no warning. But it is arguable that the second example should have an undefined, hence &lt;code&gt;FALSE&lt;/code&gt; , result. So a warning is raised for it.</source>
          <target state="translated">これらの例の両方で、一致する文字は非Unicodeであるため、Unicodeは文字の一致方法を定義していません。これは明らかにASCII 16進数字ではないので、最初の例は明らかに失敗するはずです。しかし、2番目の例の結果が未定義、つまり &lt;code&gt;FALSE&lt;/code&gt; になることは間違いありません。したがって、警告が出されます。</target>
        </trans-unit>
        <trans-unit id="ada6e60fc27e067365f9bf0a0ffb98e7d709449e" translate="yes" xml:space="preserve">
          <source>In both these examples, the character being matched is non-Unicode, so Unicode doesn't define how it should match. It clearly isn't an ASCII hex digit, so the first example clearly should fail, and so it does, with no warning. But it is arguable that the second example should have an undefined, hence &lt;code&gt;FALSE&lt;/code&gt;, result. So a warning is raised for it.</source>
          <target state="translated">これらの両方の例で、一致する文字は非Unicodeであるため、Unicodeは一致する方法を定義していません。これは明らかにASCIIの16進数ではないため、最初の例は明らかに失敗するはずであり、警告なしに失敗します。しかし、2番目の例では、結果が未定義、つまり &lt;code&gt;FALSE&lt;/code&gt; になるはずであるということは議論の余地があります。そのため、警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="9f0223354df20f59a567232c3197191e5bff5d52" translate="yes" xml:space="preserve">
          <source>In both usages of the autosplitter, only subroutines defined following the perl</source>
          <target state="translated">オートスプリッタのどちらの使用法においても、perlの</target>
        </trans-unit>
        <trans-unit id="406fcea7e1602f14dd1022ebb22952808a0b1f3f" translate="yes" xml:space="preserve">
          <source>In case</source>
          <target state="translated">場合には</target>
        </trans-unit>
        <trans-unit id="e541d9732ad7ef01278201444dc42735718b9c21" translate="yes" xml:space="preserve">
          <source>In case of L&amp;lt;...&amp;gt; codes with no &quot;text|&quot; part in them, older formatters have exhibited great variation in actually displaying the link or cross reference. For example, L&amp;lt;crontab(5)&amp;gt; would render as &quot;the &lt;code&gt;crontab(5)&lt;/code&gt; manpage&quot;, or &quot;in the &lt;code&gt;crontab(5)&lt;/code&gt; manpage&quot; or just &quot;&lt;code&gt;crontab(5)&lt;/code&gt; &quot;.</source>
          <target state="translated">「テキスト|」のないL &amp;lt;...&amp;gt;コードの場合 その一部として、古いフォーマッターはリンクや相互参照を実際に表示する際に大きなバリエーションを示しています。たとえば、L &amp;lt;crontab（5）&amp;gt;は、「 &lt;code&gt;crontab(5)&lt;/code&gt; マンページ」、「 &lt;code&gt;crontab(5)&lt;/code&gt; マンページ内」、または単に「 &lt;code&gt;crontab(5)&lt;/code&gt; 」としてレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="2814b51f24a73a872d7d804cf971bb1ce84fc6ad" translate="yes" xml:space="preserve">
          <source>In case of L&amp;lt;...&amp;gt; codes with no &quot;text|&quot; part in them, older formatters have exhibited great variation in actually displaying the link or cross reference. For example, L&amp;lt;crontab(5)&amp;gt; would render as &quot;the &lt;code&gt;crontab(5)&lt;/code&gt; manpage&quot;, or &quot;in the &lt;code&gt;crontab(5)&lt;/code&gt; manpage&quot; or just &quot;&lt;code&gt;crontab(5)&lt;/code&gt;&quot;.</source>
          <target state="translated">「テキスト|」のないL &amp;lt;...&amp;gt;コードの場合 それらの一部として、古いフォーマッターは、リンクまたは相互参照を実際に表示する際に大きなバリエーションを示しました。たとえば、L &amp;lt;crontab（5）&amp;gt;は、「 &lt;code&gt;crontab(5)&lt;/code&gt; マンページ」、「 &lt;code&gt;crontab(5)&lt;/code&gt; マンページ内」、または単に「 &lt;code&gt;crontab(5)&lt;/code&gt; 」としてレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="365d296ccf4014f926ba35dfa5ea9a2c360d66e7" translate="yes" xml:space="preserve">
          <source>In case of doubt, insert the following statement in front of your Perl program:</source>
          <target state="translated">疑わしい場合は、Perlプログラムの前に以下の文を挿入してください。</target>
        </trans-unit>
        <trans-unit id="dfdb2521cd21a1ef333094706d67bdf22192a8cc" translate="yes" xml:space="preserve">
          <source>In case the advice in this guide has been updated recently, read the latest version directly from the perl source:</source>
          <target state="translated">このガイドのアドバイスが最近更新された場合は、perlのソースから直接最新版を読んでください。</target>
        </trans-unit>
        <trans-unit id="23c62db8a34f2416b1d1b03ee56f5f1471c6e5f5" translate="yes" xml:space="preserve">
          <source>In case the result of one operation has more digits than specified, it is rounded. The rounding mode taken is either the default mode, or the one supplied to the operation after the</source>
          <target state="translated">1 つの演算結果の桁数が指定された桁数より多い場合は、丸められます。丸められるモードは、デフォルトのモード、または</target>
        </trans-unit>
        <trans-unit id="4ff81268a14bba4a99da29ff2559bdaaf817ec79" translate="yes" xml:space="preserve">
          <source>In case you can choose between running a Makefile.PL or a Build.PL, which installer would you prefer (EUMM or MB or RAND)?</source>
          <target state="translated">Makefile.PLとBuild.PLのどちらを実行するかを選択できる場合、どちらのインストーラがいいでしょうか (EUMMかMBかRANDか)?</target>
        </trans-unit>
        <trans-unit id="4bcc550b219bf3be3a6806897874d6bb2e99f2b2" translate="yes" xml:space="preserve">
          <source>In case you're not familiar with the &quot;regular&quot; Version 8 regex routines, here are the pattern-matching rules not described above.</source>
          <target state="translated">念のため、「通常の」バージョン8の正規表現ルーチンに慣れていない方のために、上記では説明していないパターンマッチのルールをご紹介します。</target>
        </trans-unit>
        <trans-unit id="62dab9a7c702990dbb833dc9d9dafc87377a09a8" translate="yes" xml:space="preserve">
          <source>In cases of exceptionally aberrant documents, Pod parsers may abort the parse. Even then, using &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;ing/&lt;code&gt;croak&lt;/code&gt; ing is to be avoided; where possible, the parser library may simply close the input file and add text like &quot;*** Formatting Aborted ***&quot; to the end of the (partial) in-memory document.</source>
          <target state="translated">非常に異常なドキュメントの場合、ポッドパーサーは解析を中止することがあります。それでも、 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;croak&lt;/code&gt; 使用は避けられるべきです。可能な場合、パーサーライブラリは単に入力ファイルを閉じ、「*** Formatting Aborted ***」のようなテキストを（部分的な）インメモリドキュメントの最後に追加します。</target>
        </trans-unit>
        <trans-unit id="b59217a1c8a005c9ab6145ee6ec0ce18535c0415" translate="yes" xml:space="preserve">
          <source>In cases of exceptionally aberrant documents, Pod parsers may abort the parse. Even then, using &lt;code&gt;die&lt;/code&gt;ing/&lt;code&gt;croak&lt;/code&gt;ing is to be avoided; where possible, the parser library may simply close the input file and add text like &quot;*** Formatting Aborted ***&quot; to the end of the (partial) in-memory document.</source>
          <target state="translated">非常に異常なドキュメントの場合、ポッドパーサーは解析を中止することがあります。その後も、使用し &lt;code&gt;die&lt;/code&gt; ING / &lt;code&gt;croak&lt;/code&gt; INGすることは避けるべきです。可能な場合、パーサーライブラリは入力ファイルを閉じて、（部分的な）メモリ内ドキュメントの最後に「*** Formatting Aborted ***」のようなテキストを追加するだけです。</target>
        </trans-unit>
        <trans-unit id="951ca6ae3fa63f2c3fd17e15460e33ec812d0590" translate="yes" xml:space="preserve">
          <source>In cases of links to a section in a different Pod document, there are both a</source>
          <target state="translated">別のPodドキュメント内のセクションへのリンクの場合は</target>
        </trans-unit>
        <trans-unit id="145ce40561aae9dcc1363caeb763ac38680de18e" translate="yes" xml:space="preserve">
          <source>In cases of links to a section in the current Pod document, there is a</source>
          <target state="translated">現在のPod文書内のセクションへのリンクの場合は</target>
        </trans-unit>
        <trans-unit id="59b86d710288939d8eb974b61f2bbf30d7a131a6" translate="yes" xml:space="preserve">
          <source>In cases where get_title can't find the title, it will return empty-string (&quot;&quot;).</source>
          <target state="translated">get_titleがタイトルを見つけられなかった場合は、空文字列(&quot;&quot;)を返します。</target>
        </trans-unit>
        <trans-unit id="973bb49bb790d075ff05520ff06dce4f9260825c" translate="yes" xml:space="preserve">
          <source>In cases where there is link-text explicitly specified, it is to be found in the content of the element (and not the attributes), just as with the L&amp;lt;</source>
          <target state="translated">リンクテキストが明示的に指定されている場合は、L &amp;lt;の場合と同様に、要素のコンテンツ（属性ではなく）に含まれます。</target>
        </trans-unit>
        <trans-unit id="8bf9664b1f4d1fbea5b6e435c9a6c227eff0e2f3" translate="yes" xml:space="preserve">
          <source>In certain cases, the OS-level handles created by the pipe(), socket(), and accept() operators are apparently not duplicated accurately in pseudo-processes. This only happens in some situations, but where it does happen, it may result in deadlocks between the read and write ends of pipe handles, or inability to send or receive data across socket handles.</source>
          <target state="translated">pipe(),socket(),accept()の各演算子で作成された OS レベルのハンドルが、 擬似プロセス内で正確に複製されていない場合があります。これはいくつかの状況でしか起こりませんが、パイプハンドルの読み書きのデッドロックや、ソケットハンドル間でのデータの送受信ができなくなることがあります。</target>
        </trans-unit>
        <trans-unit id="f0057891cced8b178aba4808a03218c5201e0280" translate="yes" xml:space="preserve">
          <source>In certain systems, the operating system's locale support is broken and cannot be fixed or used by Perl. Such deficiencies can and will result in mysterious hangs and/or Perl core dumps when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect. When confronted with such a system, please report in excruciating detail to &amp;lt;</source>
          <target state="translated">特定のシステムでは、オペレーティングシステムのロケールサポートが壊れており、Perlで修正または使用できません。このような欠陥があると、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; が有効になっているときに、不可解なハングやPerlコアダンプが発生する可能性があり、また発生する可能性があります。このようなシステムに直面した場合は、非常に詳細な情報を&amp;lt;に報告してください。</target>
        </trans-unit>
        <trans-unit id="fc5ce54a3d04a968232d4bfde109041471f0d94a" translate="yes" xml:space="preserve">
          <source>In certain systems, the operating system's locale support is broken and cannot be fixed or used by Perl. Such deficiencies can and will result in mysterious hangs and/or Perl core dumps when &lt;code&gt;use locale&lt;/code&gt; is in effect. When confronted with such a system, please report in excruciating detail to &amp;lt;&lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;&amp;gt;, and also contact your vendor: bug fixes may exist for these problems in your operating system. Sometimes such bug fixes are called an operating system upgrade. If you have the source for Perl, include in the bug report the output of the test described above in &lt;a href=&quot;#Testing-for-broken-locales&quot;&gt;&quot;Testing for broken locales&quot;&lt;/a&gt;.</source>
          <target state="translated">特定のシステムでは、オペレーティングシステムのロケールサポートが壊れており、Perlで修正または使用することはできません。このような欠陥は、 &lt;code&gt;use locale&lt;/code&gt; が有効な場合に、不思議なハングやPerlコアダンプを引き起こす可能性があります。このようなシステムに直面した場合は、&amp;lt; &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt; &amp;gt;に非常に詳細に報告し、ベンダーにも連絡してください。オペレーティングシステムにこれらの問題のバグ修正が存在する可能性があります。このようなバグ修正は、オペレーティングシステムのアップグレードと呼ばれることもあります。 Perlのソースがある場合は、上記の&lt;a href=&quot;#Testing-for-broken-locales&quot;&gt;「壊れたロケールのテスト」で&lt;/a&gt;説明したテストの出力をバグレポートに含めます。</target>
        </trans-unit>
        <trans-unit id="60c7a29f6dd0bd0c499c2a79f889945240814e67" translate="yes" xml:space="preserve">
          <source>In code that currently says &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader; @ISA = qw(AutoLoader);&lt;/code&gt; you should remove AutoLoader from @ISA and change &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader 'AUTOLOAD';&lt;/code&gt; .</source>
          <target state="translated">現在 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader; @ISA = qw(AutoLoader);&lt;/code&gt; と記述されているコードでは、@ISA = qw（AutoLoader）; @ISAからAutoLoaderを削除し、AutoLoaderの &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader;&lt;/code&gt; を変更する必要があります。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader 'AUTOLOAD';&lt;/code&gt; を&lt;a href=&quot;functions/use&quot;&gt;使用するには&lt;/a&gt;、。</target>
        </trans-unit>
        <trans-unit id="520a5e3954242a96e3ad7ef22ff14d7e52ffc0e7" translate="yes" xml:space="preserve">
          <source>In code that currently says &lt;code&gt;use AutoLoader; @ISA = qw(AutoLoader);&lt;/code&gt; you should remove AutoLoader from @ISA and change &lt;code&gt;use AutoLoader;&lt;/code&gt; to &lt;code&gt;use AutoLoader 'AUTOLOAD';&lt;/code&gt;.</source>
          <target state="translated">現在 &lt;code&gt;use AutoLoader; @ISA = qw(AutoLoader);&lt;/code&gt; と書かれているコードでは; @ISA = qw（AutoLoader）; @ISAからAutoLoaderを削除し、AutoLoaderの &lt;code&gt;use AutoLoader;&lt;/code&gt; を変更する必要があります。 &lt;code&gt;use AutoLoader 'AUTOLOAD';&lt;/code&gt; を使用するには 'AUTOLOAD'; 。</target>
        </trans-unit>
        <trans-unit id="b746a74a7b045be066091fe7c51bf38b893c45a1" translate="yes" xml:space="preserve">
          <source>In comparison to the standard implementation where the object is a hash and the fields correspond to hash keys, here the fields correspond to hashes, and the object determines the hash key. Thus the hashes appear to be turned</source>
          <target state="translated">オブジェクトがハッシュであり、フィールドがハッシュキーに対応する標準的な実装と比較して、ここではフィールドがハッシュに対応し、オブジェクトがハッシュキーを決定します。このように、ハッシュは</target>
        </trans-unit>
        <trans-unit id="402b2ae815c1f3f49820717ee0f679511f29fbf5" translate="yes" xml:space="preserve">
          <source>In connection with &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; simply adds bits, and this can be put to good use to count set bits efficiently:</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; または &lt;code&gt;B&lt;/code&gt; に関連して、 &lt;code&gt;%&lt;/code&gt; は単にビットを追加します。これは、設定されたビットを効率的にカウントするために有効に利用できます。</target>
        </trans-unit>
        <trans-unit id="f5310c67f357a7a6bdb19f2c82ce4734dee7eee5" translate="yes" xml:space="preserve">
          <source>In connection with &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt; simply adds bits, and this can be put to good use to count set bits efficiently:</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; または &lt;code&gt;B&lt;/code&gt; に関連して、 &lt;code&gt;%&lt;/code&gt; は単にビットを追加するだけであり、これは設定されたビットを効率的にカウントするために有効に活用できます。</target>
        </trans-unit>
        <trans-unit id="ed09b7a66d2eaa93bbb9724cd18388dac9e53c52" translate="yes" xml:space="preserve">
          <source>In consequence, if two or more classes want to access an object they</source>
          <target state="translated">結果として、2 つ以上のクラスがオブジェクトにアクセスしたい場合は</target>
        </trans-unit>
        <trans-unit id="f69c1a7795cd05f1f7a1c806e629e11c671e5598" translate="yes" xml:space="preserve">
          <source>In contrast, &lt;code&gt;\b{...}&lt;/code&gt; and &lt;code&gt;\B{...}&lt;/code&gt; may or may not match at the beginning and end of the line, depending on the boundary type. These implement the Unicode default boundaries, specified in &lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;http://www.unicode.org/reports/tr29/&lt;/a&gt;. The boundary types currently available are:</source>
          <target state="translated">対照的に、境界タイプに応じて、 &lt;code&gt;\b{...}&lt;/code&gt; と &lt;code&gt;\B{...}&lt;/code&gt; は行の最初と最後で一致する場合と一致しない場合があります。これらは、&lt;a href=&quot;http://www.unicode.org/reports/tr29/&quot;&gt;http://www.unicode.org/reports/tr29/&lt;/a&gt;で指定されているUnicodeデフォルト境界を実装しています。現在利用可能な境界タイプは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="dc44b4fc0c973a2fe9378a9f6c2bc3a5ba5d5988" translate="yes" xml:space="preserve">
          <source>In contrast, &lt;code&gt;\b{...}&lt;/code&gt; and &lt;code&gt;\B{...}&lt;/code&gt; may or may not match at the beginning and end of the line, depending on the boundary type. These implement the Unicode default boundaries, specified in &lt;a href=&quot;https://www.unicode.org/reports/tr14/&quot;&gt;https://www.unicode.org/reports/tr14/&lt;/a&gt; and &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;https://www.unicode.org/reports/tr29/&lt;/a&gt;. The boundary types are:</source>
          <target state="translated">対照的に、 &lt;code&gt;\b{...}&lt;/code&gt; と &lt;code&gt;\B{...}&lt;/code&gt; は、境界タイプに応じて、行の最初と最後で一致する場合と一致しない場合があります。これらは、&lt;a href=&quot;https://www.unicode.org/reports/tr14/&quot;&gt;https：//www.unicode.org/reports/tr14/&lt;/a&gt;および&lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;https://www.unicode.org/reports/tr29/&lt;/a&gt;で指定されているUnicodeのデフォルト境界を実装しています。境界タイプは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="01521aaa27588449bcad287436418e3fa90af89f" translate="yes" xml:space="preserve">
          <source>In contrast, INSTALL_BASE has predictable, easy to explain installation locations. Now that Module::Build and MakeMaker both have INSTALL_BASE there is little reason to use PREFIX other than to preserve your existing installation locations. If you are starting a fresh Perl installation we encourage you to use INSTALL_BASE. If you have an existing installation installed via PREFIX, consider moving it to an installation structure matching INSTALL_BASE and using that instead.</source>
          <target state="translated">対照的に、INSTALL_BASE はインストール場所が予測でき、説明も簡単です。Module::Build と MakeMaker には INSTALL_BASE があるので、既存のインストール場所を保存する以外に PREFIX を使う理由はほとんどありません。Perl を新規にインストールする場合は INSTALL_BASE を使うことをお勧めします。既存のインストールがPREFIXでインストールされている場合は、それをINSTALL_BASEにマッチするインストール構造体に移動して、代わりにそれを使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="b83a5099aeab352d7a9903a13c782e0d912d2e78" translate="yes" xml:space="preserve">
          <source>In contrast, hard references are more like hard links in a Unix file system: They are used to access an underlying object without concern for what its (other) name is. When the word &quot;reference&quot; is used without an adjective, as in the following paragraph, it is usually talking about a hard reference.</source>
          <target state="translated">対照的に、ハード参照はUnixファイルシステムのハードリンクに似ています。それらは、その(他の)名前を気にすることなく、基礎となるオブジェクトにアクセスするために使用されます。次の段落のように「参照」という単語が形容詞なしで使われている場合、それは通常、ハードリファレンスのことを言っているのです。</target>
        </trans-unit>
        <trans-unit id="4fefb1775bf2d6d801dc0e18387b980f80b2a1f8" translate="yes" xml:space="preserve">
          <source>In contrast, modules in the</source>
          <target state="translated">対照的に、モジュールの</target>
        </trans-unit>
        <trans-unit id="d9d8046b6af82f0d0498eb1133f08ab96606ff69" translate="yes" xml:space="preserve">
          <source>In corporate life, to grant official approval to a thing, as in, &amp;ldquo;The VP of Engineering has blessed our WebCruncher project.&amp;rdquo; Similarly, in Perl, to grant official approval to a &lt;b&gt;referent&lt;/b&gt; so that it can function as an &lt;b&gt;object&lt;/b&gt;, such as a WebCruncher object. See the &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">企業生活において、「エンジニアリングのVPが私たちのWebCruncherプロジェクトを祝福した」のように、あるものに公式の承認を与えること。同様に、Perlでは、WebCruncherオブジェクトなどの&lt;b&gt;オブジェクト&lt;/b&gt;として機能できるように、&lt;b&gt;参照先に&lt;/b&gt;公式の承認を与えること。Camelの第27章「関数」の &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 関数を参照してください。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4625f6aedb66ab6c0cd003200a635f106d69fe95" translate="yes" xml:space="preserve">
          <source>In corporate life, to grant official approval to a thing, as in, &amp;ldquo;The VP of Engineering has blessed our WebCruncher project.&amp;rdquo; Similarly, in Perl, to grant official approval to a &lt;b&gt;referent&lt;/b&gt; so that it can function as an &lt;b&gt;object&lt;/b&gt;, such as a WebCruncher object. See the &lt;code&gt;bless&lt;/code&gt; function in Camel chapter 27, &amp;ldquo;Functions&amp;rdquo;.</source>
          <target state="translated">企業生活において、「エンジニアリング担当副社長は私たちのWebCruncherプロジェクトを祝福してくれました」のように、物事に公式の承認を与えること。同様に、Perlでは、&lt;b&gt;指示対象&lt;/b&gt;がWebCruncherオブジェクトなどの&lt;b&gt;オブジェクト&lt;/b&gt;として機能できるように、&lt;b&gt;指示対象に&lt;/b&gt;正式な承認を与えること。キャメルの第27章「関数」の &lt;code&gt;bless&lt;/code&gt; 関数を参照してください。</target>
        </trans-unit>
        <trans-unit id="790c2868d3d66b4c19140a7f88a9ac87243f5c3f" translate="yes" xml:space="preserve">
          <source>In deep binding, lexical variables mentioned in anonymous subroutines are the same ones that were in scope when the subroutine was created. In shallow binding, they are whichever variables with the same names happen to be in scope when the subroutine is called. Perl always uses deep binding of lexical variables (i.e., those created with my()). However, dynamic variables (aka global, local, or package variables) are effectively shallowly bound. Consider this just one more reason not to use them. See the answer to &lt;a href=&quot;#What%27s-a-closure%3F&quot;&gt;&quot;What's a closure?&quot;&lt;/a&gt;.</source>
          <target state="translated">ディープバインディングでは、匿名サブルーチンで言及されている字句変数は、サブルーチンが作成されたときにスコープ内にあったものと同じです。浅いバインディングでは、サブルーチンが呼び出されたときに同じ名前の変数がスコープ内にあるものです。Perlは常に字句変数（つまり、my（）で作成された変数）のディープバインディングを使用します。ただし、動的変数（別名、グローバル変数、ローカル変数、またはパッケージ変数）は、事実上浅くバインドされています。これを使用しないもう1つの理由と考えてください。&lt;a href=&quot;#What%27s-a-closure%3F&quot;&gt;「クロージャとは何ですか？」の&lt;/a&gt;回答を参照してください。。</target>
        </trans-unit>
        <trans-unit id="d9b2433b690bbfb6a8d4a6c1783fb717c5f969db" translate="yes" xml:space="preserve">
          <source>In deep binding, lexical variables mentioned in anonymous subroutines are the same ones that were in scope when the subroutine was created. In shallow binding, they are whichever variables with the same names happen to be in scope when the subroutine is called. Perl always uses deep binding of lexical variables (i.e., those created with my()). However, dynamic variables (aka global, local, or package variables) are effectively shallowly bound. Consider this just one more reason not to use them. See the answer to &lt;a href=&quot;#What's-a-closure%3f&quot;&gt;What's a closure?&lt;/a&gt;.</source>
          <target state="translated">ディープバインディングでは、匿名サブルーチンで言及されているレキシカル変数は、サブルーチンが作成されたときにスコープ内にあったものと同じです。浅いバインディングでは、同じ名前の変数が、サブルーチンが呼び出されたときにスコープ内にあるものです。 Perlは常に字句変数（つまり、my（）で作成されたもの）のディープバインディングを使用します。ただし、動的変数（グローバル変数、ローカル変数、パッケージ変数とも呼ばれます）は事実上浅くバインドされています。これを使用しない理由をもう1つだけ考えてください。回答を参照してください&lt;a href=&quot;#What's-a-closure%3f&quot;&gt;クロージャは何を？&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99e7fbb09770b6f32c5f70c75d8aea1be23012f2" translate="yes" xml:space="preserve">
          <source>In default</source>
          <target state="translated">デフォルトでは</target>
        </trans-unit>
        <trans-unit id="20fadc3ec5ca97e1da30f076e8b9de4f5b9c66b4" translate="yes" xml:space="preserve">
          <source>In directories where either &lt;code&gt;Makefile.PL&lt;/code&gt; or &lt;code&gt;Build.PL&lt;/code&gt; exist, &lt;code&gt;perldoc&lt;/code&gt; will add &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; first to its search path, and as long as you're not the superuser will add &lt;code&gt;blib&lt;/code&gt; too. This is really helpful if you're working inside of a build directory and want to read through the docs even if you have a version of a module previously installed.</source>
          <target state="translated">&lt;code&gt;Makefile.PL&lt;/code&gt; または &lt;code&gt;Build.PL&lt;/code&gt; が存在するディレクトリには、 &lt;code&gt;perldoc&lt;/code&gt; がを追加し &lt;code&gt;.&lt;/code&gt; そして、 &lt;code&gt;lib&lt;/code&gt; その検索パスに最初の、そして限り、あなたはスーパーユーザが追加されますしていないよう &lt;code&gt;blib&lt;/code&gt; 過ぎます。これは、ビルドディレクトリ内で作業していて、以前にインストールされているモジュールのバージョンがある場合でもドキュメントを読みたい場合に非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="ea11b5cca3eecd37f4df3d54042b48987e1a258f" translate="yes" xml:space="preserve">
          <source>In double-quotish context, as is usually the case, you need to be careful about &lt;code&gt;&quot;$&quot;&lt;/code&gt; and the non-metacharacter &lt;code&gt;&quot;@&quot;&lt;/code&gt;. Those could interpolate variables, which may or may not be what you intended.</source>
          <target state="translated">二重引用符のコンテキストでは、通常の場合と同様に、 &lt;code&gt;&quot;$&quot;&lt;/code&gt; と非メタ文字 &lt;code&gt;&quot;@&quot;&lt;/code&gt; 注意する必要があります。それらは変数を補間する可能性があり、それはあなたが意図したものであるかもしれないし、そうでないかもしれません。</target>
        </trans-unit>
        <trans-unit id="efd19cad20b9e59643f15ee87358174035c99ef1" translate="yes" xml:space="preserve">
          <source>In each case, the port or service name (e.g. &lt;code&gt;80&lt;/code&gt;) is passed as the &lt;code&gt;LocalService&lt;/code&gt; or &lt;code&gt;PeerService&lt;/code&gt; argument.</source>
          <target state="translated">いずれの場合も、ポートまたはサービス名（ &lt;code&gt;80&lt;/code&gt; など）が &lt;code&gt;LocalService&lt;/code&gt; または &lt;code&gt;PeerService&lt;/code&gt; 引数として渡されます。</target>
        </trans-unit>
        <trans-unit id="b98ec9678a77351791b177991b84c25fc1205921" translate="yes" xml:space="preserve">
          <source>In each of the following groups, there may be many more constants provided than just the ones given as examples in the section heading. If the heading ends &lt;code&gt;...&lt;/code&gt; then this means there are likely more; the exact constants provided will depend on the OS and headers found at compile-time.</source>
          <target state="translated">次の各グループでは、セクションの見出しで例として挙げた定数だけではなく、より多くの定数が提供されている場合があります。見出しが終了した場合 &lt;code&gt;...&lt;/code&gt; これは、さらに多くの可能性があることを意味します。提供される正確な定数は、コンパイル時に見つかったOSとヘッダーによって異なります。</target>
        </trans-unit>
        <trans-unit id="b68e75d7a1476c3ad7fa38606ac2d7ce5e34258a" translate="yes" xml:space="preserve">
          <source>In earlier Perl versions, when byte and character data were concatenated, the new string was sometimes created by decoding the byte strings as</source>
          <target state="translated">以前のPerlのバージョンでは、バイトデータと文字データが連結されているときに、バイト文字列を</target>
        </trans-unit>
        <trans-unit id="85963e44254facb2c74a4ad36d06d1d324a0415d" translate="yes" xml:space="preserve">
          <source>In earlier Perls, this bit was named &lt;code&gt;UTF8_GOT_ABOVE_31_BIT&lt;/code&gt;, which you still may use for backward compatibility. That name is misleading, as this flag may be set when the code point actually does fit in 31 bits. This happens on EBCDIC platforms, and sometimes when the &lt;a href=&quot;#UTF8_GOT_LONG&quot;&gt;overlong malformation&lt;/a&gt; is also present. The new name accurately describes the situation in all cases.</source>
          <target state="translated">以前の &lt;code&gt;UTF8_GOT_ABOVE_31_BIT&lt;/code&gt; では、このビットはUTF8_GOT_ABOVE_31_BITという名前でしたが、下位互換性のために引き続き使用できます。このフラグは、コードポイントが実際に31ビットに収まるときに設定される可能性があるため、この名前は誤解を招く可能性があります。これはEBCDICプラットフォームで発生し、場合によっては&lt;a href=&quot;#UTF8_GOT_LONG&quot;&gt;長すぎる奇形&lt;/a&gt;も存在します。新しい名前は、すべての場合の状況を正確に表しています。</target>
        </trans-unit>
        <trans-unit id="6cd886bd81b2389456301c1edaca970f0fd117a3" translate="yes" xml:space="preserve">
          <source>In earlier versions, when byte and character data were concatenated, the new string was sometimes created by decoding the byte strings as</source>
          <target state="translated">以前のバージョンでは、バイトデータと文字データが連結されているときに、バイト文字列をデコードして新しい文字列が作成されることがありました。</target>
        </trans-unit>
        <trans-unit id="7dc7a0656f22946eb4e770e46a3f69e5d6f40e31" translate="yes" xml:space="preserve">
          <source>In effect, your search prefix is ignored and $Config{vms_prefix} is used instead.</source>
          <target state="translated">事実上、検索プレフィックスは無視され、代わりに $Config{vms_prefix}が使用されます。</target>
        </trans-unit>
        <trans-unit id="94c2468a1701c5657c0fd595d96849c8e021725b" translate="yes" xml:space="preserve">
          <source>In either case, please &lt;b&gt;attach&lt;/b&gt; patches to the bug report rather than including them inline in the web post or the body of the email.</source>
          <target state="translated">いずれの場合も、パッチをWeb投稿や電子メールの本文にインラインで含めるのではなく、バグレポートに&lt;b&gt;添付&lt;/b&gt;してください。</target>
        </trans-unit>
        <trans-unit id="4c62ad53bb4b783795294732eef580256b60e336" translate="yes" xml:space="preserve">
          <source>In either case, you should still be able to run the scripts with perl explicitly:</source>
          <target state="translated">どちらの場合でも、明示的に perl でスクリプトを実行できるはずです。</target>
        </trans-unit>
        <trans-unit id="10204eb47c47fbf1753216a2fbda8ce2e5713135" translate="yes" xml:space="preserve">
          <source>In extreme cases, &lt;b&gt;perlbug&lt;/b&gt; may not work well enough on your system to guide you through composing a bug report. In those cases, you may be able to use &lt;b&gt;perlbug -d&lt;/b&gt; or &lt;b&gt;perl -V&lt;/b&gt; to get system configuration information to include in your issue report.</source>
          <target state="translated">極端な場合、&lt;b&gt;perlbug&lt;/b&gt;は、バグレポートの作成をガイドするのに十分なシステム上で機能しない可能性があります。そのような場合、&lt;b&gt;perlbug-d&lt;/b&gt;または&lt;b&gt;perl-V&lt;/b&gt;を使用して、システム構成情報を取得し、問題レポートに含めることができる場合があります。</target>
        </trans-unit>
        <trans-unit id="fb41a30683f07ad432fb7627b6f4d0b50b059664" translate="yes" xml:space="preserve">
          <source>In extreme cases, &lt;b&gt;perlbug&lt;/b&gt; may not work well enough on your system to guide you through composing a bug report. In those cases, you may be able to use &lt;b&gt;perlbug -d&lt;/b&gt; to get system configuration information to include in a manually composed bug report to &lt;b&gt;perlbug@perl.org&lt;/b&gt;.</source>
          <target state="translated">極端な場合、システム上で&lt;b&gt;perlbug&lt;/b&gt;が十分に機能せず、バグレポートの作成をガイドできません。そのような場合は、&lt;b&gt;perlbug -d&lt;/b&gt;を使用してシステム構成情報を取得し、手動で作成したバグレポートに&lt;b&gt;含める&lt;/b&gt;ことができます&lt;b&gt;perlbug@perl.org&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="937f09e779144f446b6eecefbcdc1c71e24ac90e" translate="yes" xml:space="preserve">
          <source>In fact if you want to update your local repository without touching your working directory you do:</source>
          <target state="translated">実際には、作業ディレクトリに触れずにローカルリポジトリを更新したい場合は、そのようにします。</target>
        </trans-unit>
        <trans-unit id="abe9c1f86e0ce32785f02f8f2556f43d9ccd3599" translate="yes" xml:space="preserve">
          <source>In fact it is not 100% true that a compiled unit contains a pointer to the scratchpad AV. In fact it contains a pointer to an AV of (initially) one element, and this element is the scratchpad AV. Why do we need an extra level of indirection?</source>
          <target state="translated">実際には、コンパイルされたユニットがスクラッチパッドのAVへのポインタを含んでいるというのは100%真実ではありません。実際には、(初期状態では)1つの要素のAVへのポインタが含まれており、この要素がスクラッチパッドのAVなのです。なぜ、余分なレベルのインダイレクトが必要なのでしょうか?</target>
        </trans-unit>
        <trans-unit id="e844204f376cced819af429b122503a8c0eba54a" translate="yes" xml:space="preserve">
          <source>In fact mangling of</source>
          <target state="translated">実際には</target>
        </trans-unit>
        <trans-unit id="3370e0fda40977698cd4fccd53b4e05e504a7a69" translate="yes" xml:space="preserve">
          <source>In fact numbers stored in the native integer format may be stored either in the signed native form, or in the unsigned native form. Thus the limits for Perl numbers stored as native integers would typically be -2**31..2**32-1, with appropriate modifications in the case of 64-bit integers. Again, this does not mean that Perl can do operations only over integers in this range: it is possible to store many more integers in floating point format.</source>
          <target state="translated">実際、ネイティブ整数形式で格納された数値は、符号付きネイティブ形式でも、符号なしネイティブ形式でも格納できます。したがって、ネイティブ整数として格納されるPerlの数値の限界は、通常-2**31...2**32-1となりますが、64ビット整数の場合は適切に修正されます。繰り返しになりますが、これは Perl がこの範囲の整数に対してのみ演算を行うことができるということを意味するものではありません。</target>
        </trans-unit>
        <trans-unit id="58c12119d45a0a6b7a7d70173ad8a47276ea5e91" translate="yes" xml:space="preserve">
          <source>In fact, a dynamic variable (also known as package or global variables) are still accessible using the fully qualified &lt;code&gt;::&lt;/code&gt; notation even while a lexical of the same name is also visible:</source>
          <target state="translated">実際、動的変数（パッケージ変数またはグローバル変数とも呼ばれます）は、完全修飾 &lt;code&gt;::&lt;/code&gt; 表記を使用してアクセスできますが、同じ名前の語彙も表示されます。</target>
        </trans-unit>
        <trans-unit id="43fe617e28edf5522d6d7a7c2fe5c4bc3af16527" translate="yes" xml:space="preserve">
          <source>In fact, a simple identifier within such curlies is forced to be a string, and likewise within a hash subscript. Neither need quoting. Our earlier example, &lt;code&gt;$days{'Feb'}&lt;/code&gt; can be written as &lt;code&gt;$days{Feb}&lt;/code&gt; and the quotes will be assumed automatically. But anything more complicated in the subscript will be interpreted as an expression. This means for example that &lt;code&gt;$version{2.0}++&lt;/code&gt; is equivalent to &lt;code&gt;$version{2}++&lt;/code&gt; , not to &lt;code&gt;$version{'2.0'}++&lt;/code&gt; .</source>
          <target state="translated">実際、そのようなカーリー内の単純な識別子は文字列である必要があり、同様にハッシュ添え字内にあります。どちらも引用する必要はありません。以前の例では、 &lt;code&gt;$days{'Feb'}&lt;/code&gt; は &lt;code&gt;$days{Feb}&lt;/code&gt; として記述でき、引用符は自動的に想定されます。しかし、下付き文字でより複雑なものは、式として解釈されます。これは、たとえば、 &lt;code&gt;$version{2.0}++&lt;/code&gt; は &lt;code&gt;$version{'2.0'}++&lt;/code&gt; なく、 &lt;code&gt;$version{2}++&lt;/code&gt; と同等であることを意味します。</target>
        </trans-unit>
        <trans-unit id="870d18d0761d61a25a30e29a5f77ba577a01c448" translate="yes" xml:space="preserve">
          <source>In fact, a simple identifier within such curlies is forced to be a string, and likewise within a hash subscript. Neither need quoting. Our earlier example, &lt;code&gt;$days{'Feb'}&lt;/code&gt; can be written as &lt;code&gt;$days{Feb}&lt;/code&gt; and the quotes will be assumed automatically. But anything more complicated in the subscript will be interpreted as an expression. This means for example that &lt;code&gt;$version{2.0}++&lt;/code&gt; is equivalent to &lt;code&gt;$version{2}++&lt;/code&gt;, not to &lt;code&gt;$version{'2.0'}++&lt;/code&gt;.</source>
          <target state="translated">実際、このようなカーリー内の単純な識別子は、文字列である必要があり、同様にハッシュ添え字内でも同様です。どちらも引用する必要はありません。前の例である &lt;code&gt;$days{'Feb'}&lt;/code&gt; は &lt;code&gt;$days{Feb}&lt;/code&gt; と書くことができ、引用符は自動的に想定されます。ただし、添え字がより複雑なものはすべて式として解釈されます。これは、たとえば、 &lt;code&gt;$version{2.0}++&lt;/code&gt; は &lt;code&gt;$version{'2.0'}++&lt;/code&gt; なく、 &lt;code&gt;$version{2}++&lt;/code&gt; と同等であることを意味します。</target>
        </trans-unit>
        <trans-unit id="721f4b0102ec5d45627b4acee4d7283205201fd1" translate="yes" xml:space="preserve">
          <source>In fact, if you predeclare functions you want to call that way, you don't even need parentheses:</source>
          <target state="translated">実際、そのように呼び出したい関数を事前に宣言しておけば、カッコも必要ありません。</target>
        </trans-unit>
        <trans-unit id="84798f732a21afa219bddab775dec767e752c195" translate="yes" xml:space="preserve">
          <source>In fact, one can put this check into a POSTCALL: section as well. Together with PREINIT: simplifications, this leads to:</source>
          <target state="translated">実際には、このチェックを POSTCALL:セクションにも入れることができます。preinit:の簡略化と合わせて、これは次のようになります。</target>
        </trans-unit>
        <trans-unit id="ebdfc7c600521f2938c49c5c2856e2e2b5dd3018" translate="yes" xml:space="preserve">
          <source>In fact, the above is a specific instance of a more general problem: we can't guarantee to produce BEGIN blocks or &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; declarations in exactly the right place. So if you use a module which affects compilation (such as by over-riding keywords, overloading constants or whatever) then the output code might not work as intended.</source>
          <target state="translated">実際、上記はより一般的な問題の具体的な例です。BEGINブロックを生成したり、正しい場所で宣言を &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; たりすることは保証できません。したがって、（キーワードのオーバーライド、定数のオーバーロードなどによって）コンパイルに影響を与えるモジュールを使用すると、出力コードが意図したとおりに機能しない可能性があります。</target>
        </trans-unit>
        <trans-unit id="c1ab69392f6a1419564af0b0e6efcb82e0db27bf" translate="yes" xml:space="preserve">
          <source>In fact, the above is a specific instance of a more general problem: we can't guarantee to produce BEGIN blocks or &lt;code&gt;use&lt;/code&gt; declarations in exactly the right place. So if you use a module which affects compilation (such as by over-riding keywords, overloading constants or whatever) then the output code might not work as intended.</source>
          <target state="translated">実際、上記はより一般的な問題の特定の例です。BEGINブロックを生成したり、正確に正しい場所で宣言を &lt;code&gt;use&lt;/code&gt; たりすることを保証することはできません。したがって、コンパイルに影響を与えるモジュールを使用する場合（キーワードのオーバーライド、定数のオーバーロードなど）、出力コードが意図したとおりに機能しない可能性があります。</target>
        </trans-unit>
        <trans-unit id="d0e1b83f62468f002550abce8cac5172e95bf62f" translate="yes" xml:space="preserve">
          <source>In fact, the context stack is actually part of a stack-of-stacks system; whenever something unusual is done such as calling a &lt;code&gt;DESTROY&lt;/code&gt; or tie handler, a new stack is pushed, then popped at the end.</source>
          <target state="translated">実際、コンテキストスタックは実際にはスタックスタックシステムの一部です。 &lt;code&gt;DESTROY&lt;/code&gt; やタイハンドラーの呼び出しなど、異常なことが行われると、新しいスタックがプッシュされ、最後にポップされます。</target>
        </trans-unit>
        <trans-unit id="ee7429eb30ff20d649952850c91750d9f7b5208e" translate="yes" xml:space="preserve">
          <source>In fact, the skeleton modules shown above are fully functional</source>
          <target state="translated">実際には、上記のスケルトンモジュールは、完全に機能的な</target>
        </trans-unit>
        <trans-unit id="c08ff00d22228fb68d08d8dbc97cd530161909a6" translate="yes" xml:space="preserve">
          <source>In fact, what can happen is that the Perl subroutine you have called can access the &lt;code&gt;@_&lt;/code&gt; array from a previous Perl subroutine. This will occur when the code that is executing the</source>
          <target state="translated">実際、起こり得ることは、あなたが呼び出したPerlサブルーチンが以前のPerlサブルーチンから &lt;code&gt;@_&lt;/code&gt; 配列にアクセスできるということです。これは、コードを実行しているときに発生します</target>
        </trans-unit>
        <trans-unit id="5159536cbfaf213ba408ca2109f0a550ad3339ea" translate="yes" xml:space="preserve">
          <source>In fact, you can use as many repeated angle-brackets as you like so long as you have the same number of them in the opening and closing delimiters, and make sure that whitespace immediately follows the last '&amp;lt;' of the opening delimiter, and immediately precedes the first '&amp;gt;' of the closing delimiter. (The whitespace is ignored.) So the following will also work:</source>
          <target state="translated">実際、開始と終了の区切り文字に同じ数の山かっこがある限り、好きなだけ繰り返し山かっこを使用でき、開始の区切り文字の最後の '&amp;lt;'の直後に空白があることを確認します。終了デリミタの最初の「&amp;gt;」の直前。（空白は無視されます。）したがって、以下も機能します。</target>
        </trans-unit>
        <trans-unit id="eeef4cfd76862c3bdd64f8624b59be39f324bbb5" translate="yes" xml:space="preserve">
          <source>In former versions of FindBin there was no &lt;code&gt;again&lt;/code&gt; function. The workaround was to force the &lt;code&gt;BEGIN&lt;/code&gt; block to be executed again:</source>
          <target state="translated">FindBinの以前のバージョンでは、 &lt;code&gt;again&lt;/code&gt; 機能はありませんでした。回避策は、 &lt;code&gt;BEGIN&lt;/code&gt; ブロックを強制的に再度実行することでした。</target>
        </trans-unit>
        <trans-unit id="81bdf0d224677096b960b752cf09cb19f280de31" translate="yes" xml:space="preserve">
          <source>In function definitions, name starts in column 0 (return value-type is on previous line)</source>
          <target state="translated">関数定義では、名前は0列目から始まります(戻り値型は前の行にあります)</target>
        </trans-unit>
        <trans-unit id="bd418e3b4eaab23d82d37560db5e07798de430bc" translate="yes" xml:space="preserve">
          <source>In general the flags should be preserved in &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; after compilation, although the regex engine might want to add or delete some of them to invoke or disable some special behavior in Perl. The flags along with any special behavior they cause are documented below:</source>
          <target state="translated">一般に、フラグはコンパイル後に &lt;code&gt;rx-&amp;gt;extflags&lt;/code&gt; に保存する必要がありますが、正規表現エンジンはそれらの一部を追加または削除して、Perlの特別な動作を呼び出したり無効にしたりする場合があります。フラグとそれらが引き起こす特別な動作を以下に示します。</target>
        </trans-unit>
        <trans-unit id="1f8c3a47d2c8a27c27215b79122a4036f3b68a20" translate="yes" xml:space="preserve">
          <source>In general you will not be creating contexts directly. To obtain a context you should always use &lt;code&gt;context()&lt;/code&gt; which is exported by the &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt; module.</source>
          <target state="translated">通常、コンテキストを直接作成することはありません。コンテキストを取得するには、&lt;a href=&quot;Test2::API&quot;&gt;Test2 :: API&lt;/a&gt;モジュールによってエクスポートされる &lt;code&gt;context()&lt;/code&gt; を常に使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="76fd7f62eb6b7876bb97cdf2307bf8323fe78e66" translate="yes" xml:space="preserve">
          <source>In general, &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; should be called after &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; but before any I/O is done on the filehandle. Calling &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; normally flushes any pending buffered output data (and perhaps pending input data) on the handle. An exception to this is the &lt;code&gt;:encoding&lt;/code&gt; layer that changes the default character encoding of the handle. The &lt;code&gt;:encoding&lt;/code&gt; layer sometimes needs to be called in mid-stream, and it doesn't flush the stream. &lt;code&gt;:encoding&lt;/code&gt; also implicitly pushes on top of itself the &lt;code&gt;:utf8&lt;/code&gt; layer because internally Perl operates on UTF8-encoded Unicode characters.</source>
          <target state="translated">一般に、&lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt;は、&lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;た後、ファイルハンドルでI / Oが実行される前に呼び出す必要があります。&lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; を&lt;/a&gt;呼び出すと、通常、ハンドル上の保留中のバッファリングされた出力データ（およびおそらく保留中の入力データ）がフラッシュされます。これの例外は、ハンドルのデフォルトの文字エンコードを変更する &lt;code&gt;:encoding&lt;/code&gt; レイヤーです。 &lt;code&gt;:encoding&lt;/code&gt; 層は、時にはミッドストリームで呼び出す必要がある、そしてそれは、ストリームをフラッシュしません。 &lt;code&gt;:encoding&lt;/code&gt; は、内部的にPerlがUTF8でエンコードされたUnicode文字で動作するため、暗黙的に &lt;code&gt;:utf8&lt;/code&gt; レイヤーをプッシュします。</target>
        </trans-unit>
        <trans-unit id="cf0fc22fd30f9556953173964854405f4701bcb8" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Module ()&lt;/code&gt; is recommended over &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Module&lt;/code&gt; , because it determines module availability at compile time, not in the middle of your program's execution. An exception would be if two modules each tried to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; each other, and each also called a function from that other module. In that case, it's easy to use &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">一般に、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Module ()&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;は、プログラムの実行の途中ではなく、コンパイル時にモジュールの可用性を決定するため、 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Module&lt;/code&gt; よりも推奨されます。例外は、2つのモジュールがそれぞれ互いに &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 試み、それぞれがその別のモジュールから関数を呼び出した場合です。その場合、代わりに &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; を使用するのは簡単です。</target>
        </trans-unit>
        <trans-unit id="f3cf26c1ed42bf5b3d9ea8691cda05dc89cb71bf" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;use Module ()&lt;/code&gt; is recommended over &lt;code&gt;require Module&lt;/code&gt;, because it determines module availability at compile time, not in the middle of your program's execution. An exception would be if two modules each tried to &lt;code&gt;use&lt;/code&gt; each other, and each also called a function from that other module. In that case, it's easy to use &lt;code&gt;require&lt;/code&gt; instead.</source>
          <target state="translated">一般的には、 &lt;code&gt;use Module ()&lt;/code&gt; 以上、推奨される &lt;code&gt;require Module&lt;/code&gt; 、それはない、あなたのプログラムの実行の途中で、コンパイル時にモジュールの可用性を決定しますので、。例外は、2つのモジュールがそれぞれ相互に &lt;code&gt;use&lt;/code&gt; しようとし、それぞれが他のモジュールから関数を呼び出した場合です。その場合、代わりに &lt;code&gt;require&lt;/code&gt; を使用するのは簡単です。</target>
        </trans-unit>
        <trans-unit id="781b20a886715083a2a3027ccb146131c22fb0e2" translate="yes" xml:space="preserve">
          <source>In general, Dotted-Decimal Versions permit the greatest amount of freedom to specify a version, whereas Decimal Versions enforce a certain uniformity.</source>
          <target state="translated">一般的に、Dotted-Decimalバージョンではバージョンを指定する自由度が最大になりますが、Decimalバージョンでは一定の統一性が強制されます。</target>
        </trans-unit>
        <trans-unit id="f587f957aa9f0d170955c8740a69ee20fd8f9433" translate="yes" xml:space="preserve">
          <source>In general, a value of 256MB (or &quot;256*1024*1024&quot;) is sufficient for Perl to compile at maximum optimization.</source>
          <target state="translated">一般的に、Perlが最大最適化された状態でコンパイルするには、256MB(または「256*1024*1024」)の値で十分です。</target>
        </trans-unit>
        <trans-unit id="131ff1b059b6e02af211bb33de067db4f34cad70" translate="yes" xml:space="preserve">
          <source>In general, any generated Makefile checks for the current version of MakeMaker and the version the Makefile was built under. If NO_VC is set, the version check is neglected. Do not write this into your Makefile.PL, use it interactively instead.</source>
          <target state="translated">一般的に、生成されたMakefileは、MakeMakerの現在のバージョンとMakefileがビルドされたバージョンをチェックします。NO_VC が設定されている場合、バージョンチェックは無視されます。これを Makefile.PL に書かないで、対話的に使用してください。</target>
        </trans-unit>
        <trans-unit id="ed1c758f94f821404f1b8e30ece4cfe61ee49211" translate="yes" xml:space="preserve">
          <source>In general, binmode() should be called after open() but before any I/O is done on the filehandle. Calling binmode() normally flushes any pending buffered output data (and perhaps pending input data) on the handle. An exception to this is the &lt;code&gt;:encoding&lt;/code&gt; layer that changes the default character encoding of the handle; see &lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt;. The &lt;code&gt;:encoding&lt;/code&gt; layer sometimes needs to be called in mid-stream, and it doesn't flush the stream. The &lt;code&gt;:encoding&lt;/code&gt; also implicitly pushes on top of itself the &lt;code&gt;:utf8&lt;/code&gt; layer because internally Perl operates on UTF8-encoded Unicode characters.</source>
          <target state="translated">一般に、binmode（）は、open（）の後で、ファイルハンドルでI / Oが行われる前に呼び出す必要があります。通常、binmode（）を呼び出すと、ハンドル上の保留中のバッファリングされた出力データ（およびおそらく保留中の入力データ）がフラッシュされます。これの例外は、ハンドルのデフォルトの文字エンコードを変更する &lt;code&gt;:encoding&lt;/code&gt; レイヤーです。&lt;a href=&quot;#open&quot;&gt;openを&lt;/a&gt;参照してください。 &lt;code&gt;:encoding&lt;/code&gt; 層は、時にはミッドストリームで呼び出す必要がある、そしてそれは、ストリームをフラッシュしません。 &lt;code&gt;:encoding&lt;/code&gt; 暗黙的にもすることは、それ自体の上にプッシュ &lt;code&gt;:utf8&lt;/code&gt; 層を内部的にPerlはUTF8でエンコードされたUnicode文字の上に動作するため。</target>
        </trans-unit>
        <trans-unit id="fcb23e7c19f51e6c8ab203413d609cc6c59591a8" translate="yes" xml:space="preserve">
          <source>In general, binmode() should be called after open() but before any I/O is done on the filehandle. Calling binmode() normally flushes any pending buffered output data (and perhaps pending input data) on the handle. An exception to this is the &lt;code&gt;:encoding&lt;/code&gt; layer that changes the default character encoding of the handle; see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;. The &lt;code&gt;:encoding&lt;/code&gt; layer sometimes needs to be called in mid-stream, and it doesn't flush the stream. The &lt;code&gt;:encoding&lt;/code&gt; also implicitly pushes on top of itself the &lt;code&gt;:utf8&lt;/code&gt; layer because internally Perl operates on UTF8-encoded Unicode characters.</source>
          <target state="translated">一般に、binmode（）は、open（）の後で、ファイルハンドルでI / Oが行われる前に呼び出す必要があります。通常、binmode（）を呼び出すと、ハンドル上の保留中のバッファリングされた出力データ（およびおそらく保留中の入力データ）がフラッシュされます。これの例外は、ハンドルのデフォルトの文字エンコードを変更する &lt;code&gt;:encoding&lt;/code&gt; レイヤーです。&lt;a href=&quot;open&quot;&gt;openを&lt;/a&gt;参照してください。 &lt;code&gt;:encoding&lt;/code&gt; 層は、時にはミッドストリームで呼び出す必要がある、そしてそれは、ストリームをフラッシュしません。 &lt;code&gt;:encoding&lt;/code&gt; 暗黙的にもすることは、それ自体の上にプッシュ &lt;code&gt;:utf8&lt;/code&gt; 層を内部的にPerlはUTF8でエンコードされたUnicode文字の上に動作するため。</target>
        </trans-unit>
        <trans-unit id="9112f219636184c8537b2886b966af1ac78ce610" translate="yes" xml:space="preserve">
          <source>In general, documentation should describe what Perl does &quot;now&quot; rather than what it used to do. It's perfectly reasonable to include notes in documentation about how behaviour has changed from previous releases, but, with very few exceptions, documentation isn't &quot;dual-life&quot; -- it doesn't need to fully describe how all old versions used to work.</source>
          <target state="translated">一般的に、ドキュメントは Perl が以前に何をしていたかではなく、「今」何をしているかを記述すべきです。以前のリリースからどのように動作が変化したかについてのメモをドキュメントに含めるのは完全に合理的ですが、ごく少数の例外を除いて、ドキュメントは「二重生活」ではありません --すべての古いバージョンがどのように動作していたかを完全に記述する必要はありません。</target>
        </trans-unit>
        <trans-unit id="a074510bee3b614b8e7a71cd1b464639580f9e03" translate="yes" xml:space="preserve">
          <source>In general, don't directly access the system in code meant to be portable. That means, no &lt;a href=&quot;perlfunc#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#pipe-READHANDLE%2CWRITEHANDLE&quot;&gt;&lt;code&gt;pipe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlop#qx%2FSTRING%2F&quot;&gt;&lt;code&gt;``&lt;/code&gt; or &lt;code&gt;qx//&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; with a &lt;code&gt;|&lt;/code&gt;, nor any of the other things that makes being a Perl hacker worth being.</source>
          <target state="translated">一般に、移植可能であることを意図したコードでシステムに直接アクセスしないでください。つまり、 &lt;code&gt;|&lt;/code&gt; で&lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;perlfunc#system-LIST&quot;&gt; &lt;code&gt;system&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;perlfunc#exec-LIST&quot;&gt; &lt;code&gt;exec&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;perlfunc#fork&quot;&gt; &lt;code&gt;fork&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;perlfunc#pipe-READHANDLE%2CWRITEHANDLE&quot;&gt; &lt;code&gt;pipe&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;perlop#qx%2FSTRING%2F&quot;&gt; &lt;code&gt;``&lt;/code&gt; または &lt;code&gt;qx//&lt;/code&gt; &lt;/a&gt;はありません。、Perlハッカーであることを価値あるものにする他のこともありません。</target>
        </trans-unit>
        <trans-unit id="c3bded401bb84dc2978238aa4ca8d1e409847f99" translate="yes" xml:space="preserve">
          <source>In general, don't directly access the system in code meant to be portable. That means, no &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;``&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; with a &lt;code&gt;|&lt;/code&gt;, nor any of the other things that makes being a Perl hacker worth being.</source>
          <target state="translated">一般に、移植可能であることを意図したコードでシステムに直接アクセスしないでください。手段、いやその &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;``&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx//&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; で &lt;code&gt;|&lt;/code&gt; 、また、Perlハッカーであることを価値のあるものにする他のことはありません。</target>
        </trans-unit>
        <trans-unit id="0d0cabae10db7de03b357778791ebb3ae57baf9a" translate="yes" xml:space="preserve">
          <source>In general, functions in Perl that serve as wrappers for system calls (&quot;syscalls&quot;) of the same name (like &lt;a href=&quot;http://man.he.net/man2/chown&quot;&gt;chown(2)&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man2/fork&quot;&gt;fork(2)&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man2/closedir&quot;&gt;closedir(2)&lt;/a&gt;, etc.) return true when they succeed and &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; otherwise, as is usually mentioned in the descriptions below. This is different from the C interfaces, which return &lt;code&gt;-1&lt;/code&gt; on failure. Exceptions to this rule include &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#waitpid-PID%2CFLAGS&quot;&gt;&lt;code&gt;waitpid&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#syscall-NUMBER%2C-LIST&quot;&gt;&lt;code&gt;syscall&lt;/code&gt;&lt;/a&gt;. System calls also set the special &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; variable on failure. Other functions do not, except accidentally.</source>
          <target state="translated">一般に、同じ名前のシステムコール（ &quot;syscalls&quot;）のラッパーとして機能するPerlの関数（&lt;a href=&quot;http://man.he.net/man2/chown&quot;&gt;chown（2）&lt;/a&gt;、&lt;a href=&quot;http://man.he.net/man2/fork&quot;&gt;fork（2）&lt;/a&gt;、&lt;a href=&quot;http://man.he.net/man2/closedir&quot;&gt;closedir（2）&lt;/a&gt;など）は、成功するとtrueを返し、それ以外の場合は&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;を返します。、以下の説明で通常言及されているように。これは、失敗時に &lt;code&gt;-1&lt;/code&gt; を返すCインターフェイスとは異なります。このルールの例外には、&lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#waitpid-PID%2CFLAGS&quot;&gt; &lt;code&gt;waitpid&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#syscall-NUMBER%2C-LIST&quot;&gt; &lt;code&gt;syscall&lt;/code&gt; が含まれます&lt;/a&gt;。システムコールも特別な&lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;設定します！失敗時に変数。他の機能は、偶然を除いて、そうではありません。</target>
        </trans-unit>
        <trans-unit id="4812a1f34a0b31a652cad991bba82f8957d788f2" translate="yes" xml:space="preserve">
          <source>In general, functions in Perl that serve as wrappers for system calls (&quot;syscalls&quot;) of the same name (like chown(2), fork(2), closedir(2), etc.) return true when they succeed and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; otherwise, as is usually mentioned in the descriptions below. This is different from the C interfaces, which return &lt;code&gt;-1&lt;/code&gt; on failure. Exceptions to this rule include &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt;. System calls also set the special &lt;code&gt;$!&lt;/code&gt; variable on failure. Other functions do not, except accidentally.</source>
          <target state="translated">一般に、同じ名前のシステムコール（「syscalls」）のラッパーとして機能するPerlの関数（chown（2）、fork（2）、closedir（2）など）は、成功するとtrueを返し、それ以外の場合は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。、通常は以下の説明で言及されています。これは、失敗すると &lt;code&gt;-1&lt;/code&gt; を返すCインターフェイスとは異なります。このルールの例外には、 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; があります。システムコールも特別な &lt;code&gt;$!&lt;/code&gt; を設定します。失敗時の変数。偶然を除いて、他の機能はしません。</target>
        </trans-unit>
        <trans-unit id="2c889b6cf9a5ef75bf23f5e723b8633717436597" translate="yes" xml:space="preserve">
          <source>In general, if something strange has gone wrong with your program and you're not sure where you should look for help, try making your code comply with &lt;b&gt;use &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt;&lt;/b&gt; and &lt;b&gt;use &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;&lt;/b&gt;. These will often point out exactly where the trouble is.</source>
          <target state="translated">一般的には、奇妙な何かがあなたのプログラムと共に去りぬ間違っていて、あなたが助けを探すべき場所がわからない場合は、あなたのコードが準拠作ってみる&lt;b&gt;の使用&lt;a href=&quot;strict&quot;&gt;厳しい&lt;/a&gt;&lt;/b&gt;と&lt;b&gt;使用&lt;a href=&quot;warnings&quot;&gt;警告&lt;/a&gt;&lt;/b&gt;。これらは多くの場合、問題がどこにあるかを正確に指摘します。</target>
        </trans-unit>
        <trans-unit id="2d920741739edbfdbddc6a5906e0b7d1f697b74b" translate="yes" xml:space="preserve">
          <source>In general, if something strange has gone wrong with your program and you're not sure where you should look for help, try making your code comply with &lt;b&gt;use strict&lt;/b&gt; and &lt;b&gt;use warnings&lt;/b&gt;. These will often point out exactly where the trouble is.</source>
          <target state="translated">一般に、プログラムに何か奇妙な問題があり、どこに助けを求めればよいかわからない場合は、コードを&lt;b&gt;use strict&lt;/b&gt;および&lt;b&gt;use警告に&lt;/b&gt;準拠させるようにしてください。これらはしばしばどこに問題があるかを正確に指摘します。</target>
        </trans-unit>
        <trans-unit id="4f338449d4134d94449e7a10434356d790a883d8" translate="yes" xml:space="preserve">
          <source>In general, it is better to create directories with a permissive MASK and let the user modify that with their &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; than it is to supply a restrictive MASK and give the user no way to be more permissive. The exceptions to this rule are when the file or directory should be kept private (mail files, for instance). The perlfunc(1) entry on &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; discusses the choice of MASK in more detail.</source>
          <target state="translated">一般に、制限付きのMASKを指定してユーザーに許可を与えるよりも、制限付きのMASK を使用してディレクトリを作成し、ユーザーが &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; を使用してディレクトリを変更できるようにすることをお勧めします。このルールの例外は、ファイルまたはディレクトリを非公開にする必要がある場合です（たとえば、メールファイル）。 &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; のperlfunc（1）エントリでは、MASKの選択について詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="859fd0676cfab168da7696f014146535cbe0534d" translate="yes" xml:space="preserve">
          <source>In general, it is better to create directories with a permissive MASK and let the user modify that with their &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; than it is to supply a restrictive MASK and give the user no way to be more permissive. The exceptions to this rule are when the file or directory should be kept private (mail files, for instance). The perlfunc(1) entry on &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; discusses the choice of MASK in more detail.</source>
          <target state="translated">一般に、制限付きのMASKを指定してユーザーに許可を与えるよりも、制限付きのMASK を使用してディレクトリを作成し、ユーザーが &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; を使用してディレクトリを変更できるようにすることをお勧めします。このルールの例外は、ファイルまたはディレクトリを非公開にする必要がある場合です（たとえば、メールファイル）。 &lt;code&gt;&lt;a href=&quot;umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; のperlfunc（1）エントリでは、MASKの選択について詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="545124287118e73717798516d78a3a8f08195676" translate="yes" xml:space="preserve">
          <source>In general, it is better to create directories with a permissive MODE and let the user modify that with their &lt;a href=&quot;#umask-EXPR&quot;&gt;&lt;code&gt;umask&lt;/code&gt;&lt;/a&gt; than it is to supply a restrictive MODE and give the user no way to be more permissive. The exceptions to this rule are when the file or directory should be kept private (mail files, for instance). The documentation for &lt;a href=&quot;#umask-EXPR&quot;&gt;&lt;code&gt;umask&lt;/code&gt;&lt;/a&gt; discusses the choice of MODE in more detail.</source>
          <target state="translated">一般に、制限モードを提供してユーザーに許容度を上げる方法を提供するよりも、許容モードでディレクトリを作成し、ユーザーに&lt;a href=&quot;#umask-EXPR&quot;&gt; &lt;code&gt;umask&lt;/code&gt; &lt;/a&gt;でそれを変更させる方が適切です。このルールの例外は、ファイルまたはディレクトリをプライベートに保つ必要がある場合です（たとえば、メールファイル）。&lt;a href=&quot;#umask-EXPR&quot;&gt; &lt;code&gt;umask&lt;/code&gt; &lt;/a&gt;のドキュメントでは、MODEの選択について詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="fa73f4a0bd2efbebe02160b7edc4173916c47a23" translate="yes" xml:space="preserve">
          <source>In general, it is necessary to evaluate the suitaility of a script to run under &lt;code&gt;sudo&lt;/code&gt; specifically with that kind of execution environment in mind. It is neither necessary nor sufficient for the same script to be suitable to run in a traditional set-id arrangement, though many of the issues overlap.</source>
          <target state="translated">一般に、特にそのような実行環境を念頭に置いて、 &lt;code&gt;sudo&lt;/code&gt; で実行するスクリプトの適合性を評価する必要があります。問題の多くは重複していますが、同じスクリプトを従来のset-id配置で実行するのに適している必要も十分でもありません。</target>
        </trans-unit>
        <trans-unit id="cad59e50fb94fade64091c926ff1356d37dc6324" translate="yes" xml:space="preserve">
          <source>In general, it's not a good idea to write extensions that modify their input parameters, as in Example 3. Instead, you should probably return multiple values in an array and let the caller handle them (we'll do this in a later example). However, in order to better accommodate calling pre-existing C routines, which often do modify their input parameters, this behavior is tolerated.</source>
          <target state="translated">一般的に、例3のように入力パラメータを変更する拡張モジュールを書くのは良い考えではありません。その代わりに、複数の値を配列で返し、呼び出し元に処理を任せるべきでしょう (これについては後の例で説明します)。しかし、入力パラメータを変更することが多い既存の C ルーチンの呼び出しに対応するために、この動作は許容されています。</target>
        </trans-unit>
        <trans-unit id="183640340bc430e8d749b47027dff4d3c19e6dde" translate="yes" xml:space="preserve">
          <source>In general, memory allocation and de-allocation isn't something you can or should be worrying about much in Perl.</source>
          <target state="translated">一般的に、メモリの割り当てや割り当て解除は、Perlではあまり気にする必要はありません。</target>
        </trans-unit>
        <trans-unit id="694bbd0c5ca4e3fe0dcb487e904ca0b8ccaba6cd" translate="yes" xml:space="preserve">
          <source>In general, please follow the particular style of the code you are patching.</source>
          <target state="translated">一般的には、パッチを当てているコードの特定のスタイルに従ってください。</target>
        </trans-unit>
        <trans-unit id="76448cd179f9ee3d08189e3b4f4ab1ba0deb68f0" translate="yes" xml:space="preserve">
          <source>In general, production code should not have file paths hardcoded. Making them user-supplied or read from a configuration file is better, keeping in mind that file path syntax varies on different machines.</source>
          <target state="translated">一般的に、プロダクションコードはファイルパスをハードコーディングしてはいけません。ファイルパスの構文はマシンによって異なることを念頭に置きながら、ユーザーが提供するか、設定ファイルから読み取るようにした方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="15ebd5f7d0f38eb2ba1e333ec5e5f7197b5f77f7" translate="yes" xml:space="preserve">
          <source>In general, the VMS version of ext() should properly handle input from extensions originally designed for a Unix or VMS environment. If you encounter problems, or discover cases where the search could be improved, please let us know.</source>
          <target state="translated">一般的に、VMS 版の ext()は、元々 Unix や VMS 環境用に設計された拡張機能からの入力を適切に扱うべきです。もし問題が発生したり、検索が改善されるケースを発見したりした場合は、私たちに知らせてください。</target>
        </trans-unit>
        <trans-unit id="6fd9faf570da706152bccbfe022ff5b9665bb3b0" translate="yes" xml:space="preserve">
          <source>In general, the benefit of a language is closely related to the skill of the people using that language. If you or your team can be faster, better, and stronger through Perl, you'll deliver more value. Remember, people often respond better to what they get out of it. If you run into resistance, figure out what those people get out of the other choice and how Perl might satisfy that requirement.</source>
          <target state="translated">一般的に、言語の利点は、その言語を使用する人々のスキルと密接に関係しています。もしあなたやあなたのチームがPerlを使ってより速く、より良く、より強くなることができれば、より多くの価値を提供することができます。覚えておいてほしいのは、人々は自分がそれから得たものに対してより良い反応をすることが多いということです。もしあなたが抵抗に遭遇したら、その人たちが他の選択肢から何を得ているのか、そしてPerlがどのようにしてその要件を満たすのかを考えてみてください。</target>
        </trans-unit>
        <trans-unit id="c1872d2ad517d8a6c01a447283eab0112566170f" translate="yes" xml:space="preserve">
          <source>In general, the distributed kit for a Perl extension includes a file named Makefile.PL, which is a Perl program which is used to create a</source>
          <target state="translated">一般的に、Perl拡張子の配布キットには、Makefile.PLという名前のファイルが含まれています。</target>
        </trans-unit>
        <trans-unit id="f86589e39189e52cad67f339850bc9ac0faa4d19" translate="yes" xml:space="preserve">
          <source>In general, the easiest path to portability is always to specify filenames in Unix format unless they will need to be processed by native commands or utilities. Because of this latter consideration, the &lt;a href=&quot;File::Spec&quot;&gt;File::Spec&lt;/a&gt; module by default returns native format specifications regardless of input format. This default may be reversed so that filenames are always reported in Unix format by specifying the &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; feature logical in the environment.</source>
          <target state="translated">一般に、移植性への最も簡単な方法は、ネイティブコマンドまたはユーティリティで処理する必要がない限り、常にUnix形式でファイル名を指定することです。この後者の考慮事項のため、&lt;a href=&quot;File::Spec&quot;&gt;File :: Spec&lt;/a&gt;モジュールは、デフォルトで、入力形式に関係なくネイティブ形式の仕様を返します。環境で論理的な &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; 機能を指定することにより、ファイル名が常にUnix形式で報告されるように、このデフォルトを逆にすることができます。</target>
        </trans-unit>
        <trans-unit id="3997a59e30d7c4c978daa07218b367eb8d7c9173" translate="yes" xml:space="preserve">
          <source>In general, the easiest path to portability is always to specify filenames in Unix format unless they will need to be processed by native commands or utilities. Because of this latter consideration, the File::Spec module by default returns native format specifications regardless of input format. This default may be reversed so that filenames are always reported in Unix format by specifying the &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; feature logical in the environment.</source>
          <target state="translated">一般に、移植性への最も簡単な方法は、ネイティブコマンドまたはユーティリティで処理する必要がない限り、常にUNIX形式でファイル名を指定することです。この後者の考慮事項のため、File :: Specモジュールはデフォルトで、入力フォーマットに関係なくネイティブフォーマット仕様を返します。このデフォルトを逆にして、環境内で &lt;code&gt;DECC$FILENAME_UNIX_REPORT&lt;/code&gt; 機能を論理的に指定することにより、ファイル名が常にUnix形式で報告されるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="28770c3025c0aede638f676bb8209a09acd6f0b6" translate="yes" xml:space="preserve">
          <source>In general, the perl interpreter views itself as the center of the universe as far as the Perl program goes. XS code is viewed as a help-mate, to accomplish things that perl doesn't do, or doesn't do fast enough, but always subservient to perl. The closer XS code adheres to this model, the less likely conflicts will occur.</source>
          <target state="translated">一般的に、Perlのプログラムでは、Perlのインタープリタは自分自身を宇宙の中心と見なしています。XSのコードは、Perlができないことや、十分に速くできないことを達成するために、常にPerlに従属しているヘルプメイトのようなものとみなされます。XSのコードがこのモデルに忠実であればあるほど、衝突は起こりにくくなります。</target>
        </trans-unit>
        <trans-unit id="0cb5716a5153b7e57dae5aef701221e438dfda22" translate="yes" xml:space="preserve">
          <source>In general, the standard modules work across platforms. Notable exceptions are the &lt;a href=&quot;cpan&quot;&gt;&lt;code&gt;CPAN&lt;/code&gt;&lt;/a&gt; module (which currently makes connections to external programs that may not be available), platform-specific modules (like &lt;a href=&quot;ExtUtils::MM_VMS&quot;&gt;&lt;code&gt;ExtUtils::MM_VMS&lt;/code&gt;&lt;/a&gt;), and DBM modules.</source>
          <target state="translated">一般に、標準モジュールはプラットフォーム間で機能します。注目すべき例外は、&lt;a href=&quot;cpan&quot;&gt; &lt;code&gt;CPAN&lt;/code&gt; &lt;/a&gt;モジュール（現在利用できない可能性のある外部プログラムに接続する）、プラットフォーム固有のモジュール（&lt;a href=&quot;ExtUtils::MM_VMS&quot;&gt; &lt;code&gt;ExtUtils::MM_VMS&lt;/code&gt; &lt;/a&gt;）、およびDBMモジュールです。</target>
        </trans-unit>
        <trans-unit id="a1d0e4d941599d8b8058171587801ee612197c61" translate="yes" xml:space="preserve">
          <source>In general, the standard modules work across platforms. Notable exceptions are the &lt;code&gt;CPAN&lt;/code&gt; module (which currently makes connections to external programs that may not be available), platform-specific modules (like &lt;code&gt;ExtUtils::MM_VMS&lt;/code&gt; ), and DBM modules.</source>
          <target state="translated">一般に、標準モジュールはプラットフォーム間で機能します。注目すべき例外は、 &lt;code&gt;CPAN&lt;/code&gt; モジュール（現在は使用できない可能性のある外部プログラムへの接続を行う）、プラットフォーム固有のモジュール（ &lt;code&gt;ExtUtils::MM_VMS&lt;/code&gt; ）、およびDBMモジュールです。</target>
        </trans-unit>
        <trans-unit id="95121980b89b7a9fb796f03c8d74599823515afb" translate="yes" xml:space="preserve">
          <source>In general, there's no need to worry about the order of calls. They will be left-to-right, breadth-first, most-derived-first. This works perfectly for most inherited methods (including destructors), but is inappropriate for some kinds of methods (such as constructors, cloners, debuggers, and initializers) where it's more appropriate that the least-derived methods be called first (as more-derived methods may rely on the behaviour of their &quot;ancestors&quot;). In that case, instead of using the &lt;code&gt;EVERY&lt;/code&gt; pseudo-class:</source>
          <target state="translated">一般に、呼び出しの順序を気にする必要はありません。それらは、左から右、幅優先、最も派生優先です。これは、ほとんどの継承されたメソッド（デストラクタを含む）には完全に機能しますが、最小派生メソッドを最初に呼び出すことがより適切である（コンストラクタ、クローン、デバッガ、初期化子などの）ある種のメソッドには不適切です。メソッドは「祖先」の動作に依存する場合があります）。その場合、 &lt;code&gt;EVERY&lt;/code&gt; 疑似クラスを使用する代わりに：</target>
        </trans-unit>
        <trans-unit id="294f7f9dd3d63c6c658291241c38389ef5522490" translate="yes" xml:space="preserve">
          <source>In general, though, it's best to use the &lt;code&gt;Sv*V&lt;/code&gt; macros.</source>
          <target state="translated">ただし、一般的には、 &lt;code&gt;Sv*V&lt;/code&gt; マクロを使用するのが最善です。</target>
        </trans-unit>
        <trans-unit id="aabaf80efaeb23cca024ae206403fa19e6f8a255" translate="yes" xml:space="preserve">
          <source>In general, with &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; enabled, more detailed information will be available in the exit status for DCL scripts or other native VMS tools, and will give the expected information for Posix programs. It has not been made the default in order to preserve backward compatibility.</source>
          <target state="translated">一般に、 &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; を有効にすると、DCLスクリプトまたは他のネイティブVMSツールの終了ステータスでより詳細な情報が利用可能になり、Posixプログラムに期待される情報が提供されます。下位互換性を維持するために、デフォルトにはなりません。</target>
        </trans-unit>
        <trans-unit id="1d7815f81eaaf88a2d89c1f351c700ea10be85e9" translate="yes" xml:space="preserve">
          <source>In general, you can't do this. There are some things that may work for your situation though. People usually ask this question because they want to distribute their works without giving away the source code, and most solutions trade disk space for convenience. You probably won't see much of a speed increase either, since most solutions simply bundle a Perl interpreter in the final product (but see &lt;a href=&quot;#How-can-I-make-my-Perl-program-run-faster%3F&quot;&gt;&quot;How can I make my Perl program run faster?&quot;&lt;/a&gt;).</source>
          <target state="translated">一般的に、これを行うことはできません。しかし、あなたの状況に役立つかもしれないいくつかのことがあります。人々は通常、ソースコードを提供せずに作品を配布したいので、この質問をします。ほとんどのソリューションは、便宜上ディスクスペースを交換します。ほとんどのソリューションはPerlインタープリターを最終製品にバンドルしているだけなので、おそらく速度の大幅な向上は見られないでしょう（ただし、&lt;a href=&quot;#How-can-I-make-my-Perl-program-run-faster%3F&quot;&gt;「Perlプログラムをより高速に実行するにはどうすればよいですか？」を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="d941c018a8912081ee9a18eaddf237ed10e20a20" translate="yes" xml:space="preserve">
          <source>In general, you can't do this. There are some things that may work for your situation though. People usually ask this question because they want to distribute their works without giving away the source code, and most solutions trade disk space for convenience. You probably won't see much of a speed increase either, since most solutions simply bundle a Perl interpreter in the final product (but see &lt;a href=&quot;#How-can-I-make-my-Perl-program-run-faster%3f&quot;&gt;How can I make my Perl program run faster?&lt;/a&gt;).</source>
          <target state="translated">通常、これはできません。ただし、状況によってはうまくいく場合があります。人々は通常、ソースコードを提供せずに作品を配布したいため、この質問をします。ほとんどのソリューションは、ディスク容量を便宜上トレードオフしています。ほとんどのソリューションでは、Perlインタープリターが最終製品にバンドルされているだけなので、速度の大幅な向上は見られないでしょう（ただし&lt;a href=&quot;#How-can-I-make-my-Perl-program-run-faster%3f&quot;&gt;、Perlプログラムをより高速に実行するに&lt;/a&gt;はどうすればよいですか？を参照）。</target>
        </trans-unit>
        <trans-unit id="a9eadd2908a4639d8decf9b9f18aef810c6f9990" translate="yes" xml:space="preserve">
          <source>In general, you don't &quot;declare&quot; a structure. Just use a (probably anonymous) hash reference. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; and &lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt; for details. Here's an example:</source>
          <target state="translated">一般に、構造体を「宣言」することはありません。（おそらく匿名の）ハッシュ参照を使用するだけです。詳細については、&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;および&lt;a href=&quot;perldsc&quot;&gt;perldsc&lt;/a&gt;を参照してください。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="70d4ca9b1495d90b59e6399e064486d24aa6cc52" translate="yes" xml:space="preserve">
          <source>In general, you don't, because you don't know whether the recipient has a color-aware display device. If you know that they have an ANSI terminal that understands color, you can use the &lt;a href=&quot;Term::ANSIColor&quot;&gt;Term::ANSIColor&lt;/a&gt; module from CPAN:</source>
          <target state="translated">受信者がカラー対応のディスプレイデバイスを持っているかどうかわからないため、一般的にはわかりません。色を理解するANSI端末があることがわかっている場合は、CPANの&lt;a href=&quot;Term::ANSIColor&quot;&gt;Term :: ANSIColor&lt;/a&gt;モジュールを使用できます。</target>
        </trans-unit>
        <trans-unit id="7f00c5d5b02fc95d1502392b2b9783083f707dee" translate="yes" xml:space="preserve">
          <source>In general, you don't, because you don't know whether the recipient has a color-aware display device. If you know that they have an ANSI terminal that understands color, you can use the &lt;a href=&quot;term/ansicolor&quot;&gt;Term::ANSIColor&lt;/a&gt; module from CPAN:</source>
          <target state="translated">受信者がカラー対応のディスプレイデバイスを持っているかどうかわからないため、一般的にはそうではありません。彼らが色を理解するANSI端末を持っていることがわかっている場合は、CPANの&lt;a href=&quot;term/ansicolor&quot;&gt;Term :: ANSIColor&lt;/a&gt;モジュールを使用できます。</target>
        </trans-unit>
        <trans-unit id="2f87cb8b42da40e06ddcf5b3026af1eac6aa3d5a" translate="yes" xml:space="preserve">
          <source>In general, you either have to know what you're dealing with, or you have to guess. The API function &lt;code&gt;is_utf8_string&lt;/code&gt; can help; it'll tell you if a string contains only valid UTF-8 characters, and the chances of a non-UTF-8 string looking like valid UTF-8 become very small very quickly with increasing string length. On a character-by-character basis, &lt;code&gt;isUTF8_CHAR&lt;/code&gt; will tell you whether the current character in a string is valid UTF-8.</source>
          <target state="translated">一般的には、自分が何を扱っているかを知る必要があるか、推測する必要があります。API関数 &lt;code&gt;is_utf8_string&lt;/code&gt; が役立ちます。文字列に有効なUTF-8文字のみが含まれているかどうかがわかります。また、UTF-8以外の文字列が有効なUTF-8のように見える可能性は、文字列の長さが増えると非常に速くなります。 &lt;code&gt;isUTF8_CHAR&lt;/code&gt; は、文字ごとに、文字列内の現在の文字が有効なUTF-8かどうかを通知します。</target>
        </trans-unit>
        <trans-unit id="0f7f43b24f7b332fad6c89f7cd9bd3e7d7da5112" translate="yes" xml:space="preserve">
          <source>In hints/os390.sh, selecting -Dusedl will default to *also* select -Duseshrplib. Having a shared plib not only requires LIBPATH to be set to the correct location of libperl.so but also makes it close to impossible to run more than one different perl that was built this way at the same time.</source>
          <target state="translated">hints/os390.sh では、-Dusedl を選択すると、デフォルトで -Duseshrplib を選択するようになります。共有plibを持つことは、libperl.soの正しい場所にLIBPATHを設定する必要があるだけでなく、このようにしてビルドされた複数の異なるperlを同時に実行することを不可能に近いものにします。</target>
        </trans-unit>
        <trans-unit id="26ea48aedd1cf988ca4c353ab67e2113694ba714" translate="yes" xml:space="preserve">
          <source>In human terms, it's a funny way of passing arguments to a subroutine when you define it as well as when you call it. It's useful for setting up little bits of code to run later, such as callbacks. You can even do object-oriented stuff with it, though Perl already provides a different mechanism to do that--see &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">人間の言葉で言えば、これは、サブルーチンを定義するとき、および呼び出すときに、引数をサブルーチンに渡す面白い方法です。コールバックなど、後で実行するコードを少し設定するのに役立ちます。Perlはそれを行うための別のメカニズムをすでに提供していますが、オブジェクト指向のものを使用することもできます&lt;a href=&quot;perlobj&quot;&gt;-perlobjを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6ba4c53f21b8779523425f16e680264ebae0decb" translate="yes" xml:space="preserve">
          <source>In inverted bracketed character classes, Perl ignores the Unicode rules that normally say that named sequence, and certain characters should match a sequence of multiple characters use under caseless &lt;code&gt;/i&lt;/code&gt; matching. Following those rules could lead to highly confusing situations:</source>
          <target state="translated">逆角かっこで囲まれた文字クラスでは、Perlは通常、名前付きシーケンスと言うUnicodeルールを無視します。特定の文字は、大文字と小文字を区別しない &lt;code&gt;/i&lt;/code&gt; 一致で使用される複数の文字のシーケンスと一致する必要があります。これらのルールに従うと、非常に混乱する状況につながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="60a70875c03150cbfc8e14e2cc2dec49ecd50454" translate="yes" xml:space="preserve">
          <source>In its most basic usage, &lt;code&gt;ok(...)&lt;/code&gt; simply takes a single scalar expression. If its value is true, the test passes; if false, the test fails. Examples:</source>
          <target state="translated">最も基本的な使用法では、 &lt;code&gt;ok(...)&lt;/code&gt; は単純に単一のスカラー式を取ります。その値がtrueの場合、テストは成功します。falseの場合、テストは失敗します。例：</target>
        </trans-unit>
        <trans-unit id="4d817298c353371e9d0b73c75cf1950195e64063" translate="yes" xml:space="preserve">
          <source>In its second form, &lt;code&gt;cond_wait&lt;/code&gt; takes a shared, &lt;b&gt;unlocked&lt;/b&gt; variable followed by a shared, &lt;b&gt;locked&lt;/b&gt; variable. The second variable is unlocked and thread execution suspended until another thread signals the first variable.</source>
          <target state="translated">2番目の形式では、 &lt;code&gt;cond_wait&lt;/code&gt; は共有の&lt;b&gt;ロックさ&lt;/b&gt;れてい&lt;b&gt;ない&lt;/b&gt;変数を受け取り、その後に共有の&lt;b&gt;ロックさ&lt;/b&gt;れた変数が続きます。2番目の変数はロック解除され、別のスレッドが最初の変数に信号を送るまでスレッドの実行が中断されます。</target>
        </trans-unit>
        <trans-unit id="4c9702efe584ddf3df38f0a305879394e6c945fd" translate="yes" xml:space="preserve">
          <source>In its two-argument form, &lt;code&gt;cond_timedwait&lt;/code&gt; takes a &lt;b&gt;locked&lt;/b&gt; variable and an absolute timeout in</source>
          <target state="translated">2つの引数の形式では、 &lt;code&gt;cond_timedwait&lt;/code&gt; は&lt;b&gt;ロックされた&lt;/b&gt;変数と絶対タイムアウトを受け取ります</target>
        </trans-unit>
        <trans-unit id="fbaa31119043f388b0d536e0c6af6beff83b01ef" translate="yes" xml:space="preserve">
          <source>In its two-argument form, &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt; compares the two scalar values to see if they match. They match if both are undefined, or if</source>
          <target state="translated">2つの引数の形式では、 &lt;code&gt;ok(&lt;i&gt;arg1&lt;/i&gt;, &lt;i&gt;arg2&lt;/i&gt;)&lt;/code&gt; は2つのスカラー値を比較して、それらが一致するかどうかを確認します。両方が定義されていない場合、または</target>
        </trans-unit>
        <trans-unit id="463cd3fb9dde14730ac60103e974616f5a19b70d" translate="yes" xml:space="preserve">
          <source>In late 2009, David Golden organized the version 2 proposal review process. David and Ricardo Signes drafted the final version 2 spec in April 2010 based on the version 1.4 spec and patches contributed during the proposal process.</source>
          <target state="translated">2009年後半、David Goldenはバージョン2の提案レビュープロセスを組織しました。DavidとRicardo Signesは、バージョン1.4の仕様と提案プロセス中に投稿されたパッチに基づいて、2010年4月にバージョン2の最終仕様を起草しました。</target>
        </trans-unit>
        <trans-unit id="278b05f5c861132c7f4bc86f277c1645adbbdf57" translate="yes" xml:space="preserve">
          <source>In less grandiose terms, the first part of the job is to turn a pattern into something the computer can efficiently use to find the matching point in the string, and the second part is performing the search itself.</source>
          <target state="translated">壮大な言い方をすれば、最初の仕事は、パターンをコンピュータが効率的に文字列の中から一致するポイントを見つけるために使えるものに変えることであり、次の仕事は検索そのものを行うことです。</target>
        </trans-unit>
        <trans-unit id="f53ef23dfb1a32e84061a4ee3198583f6963d3be" translate="yes" xml:space="preserve">
          <source>In line 7, we make sure that the SV will have enough room to accommodate the old string, the new string and the null terminator. If &lt;code&gt;LEN&lt;/code&gt; isn't big enough, &lt;code&gt;SvGROW&lt;/code&gt; will reallocate space for us.</source>
          <target state="translated">7行目では、SVに古い文字列、新しい文字列、およびnullターミネーターを収容するのに十分なスペースがあることを確認します。 &lt;code&gt;LEN&lt;/code&gt; が十分に大きくない場合、 &lt;code&gt;SvGROW&lt;/code&gt; はスペースを再割り当てします。</target>
        </trans-unit>
        <trans-unit id="6338eafb38b19e3533d3d49a05621b9aaa4f97d8" translate="yes" xml:space="preserve">
          <source>In line mode, &lt;code&gt;filter_read&lt;/code&gt; will append the next source line to the end of the &lt;code&gt;$_&lt;/code&gt; scalar.</source>
          <target state="translated">行モードでは、 &lt;code&gt;filter_read&lt;/code&gt; は次のソース行を &lt;code&gt;$_&lt;/code&gt; スカラーの最後に追加します。</target>
        </trans-unit>
        <trans-unit id="a450e27bd36ea332e7d75f6381cc8a12782b5b7a" translate="yes" xml:space="preserve">
          <source>In list context (which is usually what you want), the function returns a (possibly empty) list of language tags representing (best first) what languages the user apparently would accept output in. You will probably want to pass the output of this through &lt;code&gt;I18N::LangTags::implicate_supers_tightly(...)&lt;/code&gt; or &lt;code&gt;I18N::LangTags::implicate_supers(...)&lt;/code&gt; , like so:</source>
          <target state="translated">リストコンテキスト（これは通常必要なものです）では、関数は、ユーザーが出力を受け入れると思われる言語を（最初に）どの言語で表すかを表す（おそらく空の）言語タグのリストを返します。おそらく、この出力を &lt;code&gt;I18N::LangTags::implicate_supers_tightly(...)&lt;/code&gt; または &lt;code&gt;I18N::LangTags::implicate_supers(...)&lt;/code&gt; ように：</target>
        </trans-unit>
        <trans-unit id="b8b769bcccabaec9629d49138a4947e089422ab4" translate="yes" xml:space="preserve">
          <source>In list context (which is usually what you want), the function returns a (possibly empty) list of language tags representing (best first) what languages the user apparently would accept output in. You will probably want to pass the output of this through &lt;code&gt;I18N::LangTags::implicate_supers_tightly(...)&lt;/code&gt; or &lt;code&gt;I18N::LangTags::implicate_supers(...)&lt;/code&gt;, like so:</source>
          <target state="translated">リストコンテキスト（通常は必要なもの）では、関数は、ユーザーが出力を受け入れると思われる言語を（最初に）表す言語タグの（おそらく空の）リストを返します。おそらく、これの出力を渡す必要があります。 &lt;code&gt;I18N::LangTags::implicate_supers_tightly(...)&lt;/code&gt; または &lt;code&gt;I18N::LangTags::implicate_supers(...)&lt;/code&gt; ように：</target>
        </trans-unit>
        <trans-unit id="239ff52c002bacbd9ef8a650976d52e44cb1392b" translate="yes" xml:space="preserve">
          <source>In list context it returns a two element list, the first element containing the pattern and the second containing the modifiers used when the pattern was compiled.</source>
          <target state="translated">リストコンテキストでは、パターンを含む最初の要素と、パターンがコンパイルされたときに使用された修飾子を含む2つの要素のリストを返します。</target>
        </trans-unit>
        <trans-unit id="a8954af69f3e9417a81eb4843c66328678eb290e" translate="yes" xml:space="preserve">
          <source>In list context, &lt;code&gt;//g&lt;/code&gt; returns a list of matched groupings, or if there are no groupings, a list of matches to the whole regex. So</source>
          <target state="translated">リストコンテキストでは、 &lt;code&gt;//g&lt;/code&gt; は一致したグループのリストを返します。グループがない場合は、正規表現全体との一致のリストを返します。そう</target>
        </trans-unit>
        <trans-unit id="4a59e7f9e300ced2156a7bfdcb5c2ed656175ffd" translate="yes" xml:space="preserve">
          <source>In list context, &lt;code&gt;//g&lt;/code&gt; returns a list of matched groupings, or if there are no groupings, a list of matches to the whole regexp. So if we wanted just the words, we could use</source>
          <target state="translated">リストコンテキストでは、 &lt;code&gt;//g&lt;/code&gt; は一致したグループのリストを返します。グループがない場合は、正規表現全体との一致のリストを返します。したがって、単語だけが必要な場合は、</target>
        </trans-unit>
        <trans-unit id="6e2b15caf8e0e18f5890e016db28894ce2475850" translate="yes" xml:space="preserve">
          <source>In list context, &lt;code&gt;/g&lt;/code&gt; returns a list of matched groupings, or if there are no groupings, a list of matches to the whole regex. So</source>
          <target state="translated">リストコンテキストでは、 &lt;code&gt;/g&lt;/code&gt; は一致するグループのリストを返します。グループがない場合は、正規表現全体に一致するリストを返します。そう</target>
        </trans-unit>
        <trans-unit id="fa78ab0459f0c546f62a6ba44d40e5cfcd5ba381" translate="yes" xml:space="preserve">
          <source>In list context, &lt;code&gt;/g&lt;/code&gt; returns a list of matched groupings, or if there are no groupings, a list of matches to the whole regexp. So if we wanted just the words, we could use</source>
          <target state="translated">リストコンテキストでは、 &lt;code&gt;/g&lt;/code&gt; は一致するグループのリストを返します。グループがない場合は、正規表現全体に一致するリストを返します。だから私たちが言葉だけが欲しいなら、私たちは使うことができます</target>
        </trans-unit>
        <trans-unit id="ce23af9639d689001f6ad6f1b438efaee509bdfe" translate="yes" xml:space="preserve">
          <source>In list context, &lt;code&gt;extract_delimited&lt;/code&gt; returns a array of three elements, the extracted substring (</source>
          <target state="translated">リストコンテキストでは、 &lt;code&gt;extract_delimited&lt;/code&gt; は3つの要素の配列、抽出された部分文字列（</target>
        </trans-unit>
        <trans-unit id="e472cb823d18651b8bfb2582f84acfb33002068c" translate="yes" xml:space="preserve">
          <source>In list context, F(0) and F(n) is the first and last number in the output, respectively. For example, if $n is 12, then &lt;code&gt;@F = $n-&amp;gt;bfib()&lt;/code&gt; returns the following values, F(0) to F(12):</source>
          <target state="translated">リストのコンテキストでは、F（0）とF（n）は、それぞれ出力の最初と最後の数値です。たとえば、$ nが12の場合、 &lt;code&gt;@F = $n-&amp;gt;bfib()&lt;/code&gt; は、F（0）からF（12）の値を返します。</target>
        </trans-unit>
        <trans-unit id="5889fdbc3b684f4564d298e03582627a0f1d67cc" translate="yes" xml:space="preserve">
          <source>In list context, L(0) and L(n) is the first and last number in the output, respectively. For example, if $n is 12, then &lt;code&gt;@L = $n-&amp;gt;blucas()&lt;/code&gt; returns the following values, L(0) to L(12):</source>
          <target state="translated">リストのコンテキストでは、L（0）とL（n）は、それぞれ出力の最初と最後の数値です。たとえば、$ nが12の場合、 &lt;code&gt;@L = $n-&amp;gt;blucas()&lt;/code&gt; は、L（0）からL（12）の値を返します。</target>
        </trans-unit>
        <trans-unit id="85fefe43cf3ce99aee8bf62db2fc923ea0e22144" translate="yes" xml:space="preserve">
          <source>In list context, a match &lt;code&gt;/regex/&lt;/code&gt; with groupings will return the list of matched values &lt;code&gt;($1,$2,...)&lt;/code&gt; . So we could rewrite it as</source>
          <target state="translated">リストのコンテキストでは、グループとの &lt;code&gt;/regex/&lt;/code&gt; の一致は、一致した値のリスト &lt;code&gt;($1,$2,...)&lt;/code&gt; を返します。したがって、次のように書き直すことができます</target>
        </trans-unit>
        <trans-unit id="939fd917e535aec01742cc126c0bd35df43aa502" translate="yes" xml:space="preserve">
          <source>In list context, a match &lt;code&gt;/regex/&lt;/code&gt; with groupings will return the list of matched values &lt;code&gt;($1,$2,...)&lt;/code&gt;. So we could rewrite it as</source>
          <target state="translated">リストコンテキストでは、グループ化された &lt;code&gt;/regex/&lt;/code&gt; の一致は、一致した値のリスト &lt;code&gt;($1,$2,...)&lt;/code&gt; を返します。だから私たちはそれを次のように書き直すことができます</target>
        </trans-unit>
        <trans-unit id="c008355e8673133191ef9e0d9724c780f81e596e" translate="yes" xml:space="preserve">
          <source>In list context, both the remaining time and the interval are returned.</source>
          <target state="translated">リストコンテキストでは、残り時間と間隔の両方が返されます。</target>
        </trans-unit>
        <trans-unit id="4ff8ef7b7f3933511d227abc0760c6958871615f" translate="yes" xml:space="preserve">
          <source>In list context, both the remaining time and the interval are returned. The interval is always what you put in using &lt;code&gt;setitimer()&lt;/code&gt; .</source>
          <target state="translated">リストのコンテキストでは、残り時間と間隔の両方が返されます。間隔は常に、 &lt;code&gt;setitimer()&lt;/code&gt; を使用して入力したものです。</target>
        </trans-unit>
        <trans-unit id="bfe9012620873b36aaee603ca083e0f3f3500013" translate="yes" xml:space="preserve">
          <source>In list context, both the remaining time and the interval are returned. The interval is always what you put in using &lt;code&gt;setitimer()&lt;/code&gt;.</source>
          <target state="translated">リストコンテキストでは、残り時間と間隔の両方が返されます。間隔は常に &lt;code&gt;setitimer()&lt;/code&gt; を使用して入力したものです。</target>
        </trans-unit>
        <trans-unit id="1f52db4aa7cef4591f6ad21954e80ef3d1ce4ff3" translate="yes" xml:space="preserve">
          <source>In list context, if the second parameter is present and evaluates TRUE, the method returns an associative array. The keys of the associative array correspond to the values that matched in the BTREE and the values of the array are a count of the number of times that particular value occurred in the BTREE.</source>
          <target state="translated">リストのコンテキストでは、2 番目のパラメータを指定して TRUE を評価した場合は連想配列を返します。連想配列のキーは BTREE でマッチした値に対応し、配列の値はその値が BTREE で何回出現したかを表したものとなります。</target>
        </trans-unit>
        <trans-unit id="611c9c24bc1f7655268ae0a922a1bafe9f75484e" translate="yes" xml:space="preserve">
          <source>In list context, it returns all the values which match &lt;code&gt;$key&lt;/code&gt; . Note that the values will be returned in an apparently random order.</source>
          <target state="translated">リストのコンテキストでは、 &lt;code&gt;$key&lt;/code&gt; 一致するすべての値を返します。値は明らかにランダムな順序で返されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ae580f37b964b097156f3a709cd209fec9b4b0f5" translate="yes" xml:space="preserve">
          <source>In list context, it returns all the values which match &lt;code&gt;$key&lt;/code&gt;. Note that the values will be returned in an apparently random order.</source>
          <target state="translated">リストコンテキストでは、 &lt;code&gt;$key&lt;/code&gt; 一致するすべての値を返します。値は明らかにランダムな順序で返されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b9e8a08a17d7e9ccb66ceef8551ab60c5578a3cb" translate="yes" xml:space="preserve">
          <source>In list context, it's just the list argument separator, and inserts both its arguments into the list. These arguments are also evaluated from left to right.</source>
          <target state="translated">リストコンテキストでは、リストの引数の区切り文字に過ぎず、その両方の引数をリストに挿入します。これらの引数も左から右に評価されます。</target>
        </trans-unit>
        <trans-unit id="d53a53afd4d30e8bf9ee4f38d18899b7c7ca7c4f" translate="yes" xml:space="preserve">
          <source>In list context, returns a (possibly empty) list of filename expansions on the value of EXPR such as the standard Unix shell</source>
          <target state="translated">リストコンテキストでは、標準的な Unix シェルのような EXPR の値に対するファイル名展開の (おそらく空の)リストを返します。</target>
        </trans-unit>
        <trans-unit id="6f4ce95673df56dca54efc694ff26b54d19e3c4c" translate="yes" xml:space="preserve">
          <source>In list context, returns a list consisting of all the values of the named hash. In Perl 5.12 or later only, will also return a list of the values of an array; prior to that release, attempting to use an array argument will produce a syntax error. In scalar context, returns the number of values.</source>
          <target state="translated">リストコンテキストでは、指定されたハッシュのすべての値からなるリストを返します。Perl 5.12以降では、配列の値のリストを返します。それ以前のリリースでは、配列の引数を使おうとすると構文エラーが発生します。スカラコンテキストでは、値の数を返します。</target>
        </trans-unit>
        <trans-unit id="7bcc561bb33b529c7d0fa7662daf305595924e45" translate="yes" xml:space="preserve">
          <source>In list context, returns a list value consisting of the elements of LIST in the opposite order. In scalar context, concatenates the elements of LIST and returns a string value with all characters in the opposite order.</source>
          <target state="translated">リストコンテキストでは、LISTの要素を逆順に連結したリスト値を返す。スカラコンテキストでは、LISTの要素を連結し、全ての文字を逆順に並べた文字列値を返します。</target>
        </trans-unit>
        <trans-unit id="8b48751518b742e90690dec941b028dbd41c2485" translate="yes" xml:space="preserve">
          <source>In list context, returns the value or values deleted, or the last such element in scalar context. The return list's length always matches that of the argument list: deleting non-existent elements returns the undefined value in their corresponding positions.</source>
          <target state="translated">リストコンテキストでは、削除された値や値、スカラコンテキストでは最後に削除された要素を返します。戻り値リストの長さは、常に引数リストの長さと一致します:存在しない要素を削除すると、対応する位置にある未定義の値が返されます。</target>
        </trans-unit>
        <trans-unit id="a341489f824f6b17a2a55f993696ad829ad19868" translate="yes" xml:space="preserve">
          <source>In list context, this sorts the LIST and returns the sorted list value. In scalar context, the behaviour of &lt;a href=&quot;#sort-SUBNAME-LIST&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; is undefined.</source>
          <target state="translated">リストコンテキストでは、これによりLISTがソートされ、ソートされたリスト値が返されます。スカラーコンテキストでは、&lt;a href=&quot;#sort-SUBNAME-LIST&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;の動作は定義されていません。</target>
        </trans-unit>
        <trans-unit id="14dda5a0315cd38b494f1396d6549e05a88ce769" translate="yes" xml:space="preserve">
          <source>In list context, this sorts the LIST and returns the sorted list value. In scalar context, the behaviour of &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; is undefined.</source>
          <target state="translated">リストのコンテキストでは、これはリストをソートし、ソートされたリストの値を返します。スカラーコンテキストでは、 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="c275967193060ed0f99b2fe8baeb485ea49b9b81" translate="yes" xml:space="preserve">
          <source>In list context, this sorts the LIST and returns the sorted list value. In scalar context, the behaviour of &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; is undefined.</source>
          <target state="translated">リストのコンテキストでは、これはリストをソートし、ソートされたリストの値を返します。スカラーコンテキストでは、 &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; の動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="b0c91abf023bc70153195871169298db2bcd959f" translate="yes" xml:space="preserve">
          <source>In list context, usually returns the value or values deleted, or the last such element in scalar context. The return list's length corresponds to that of the argument list: deleting non-existent elements returns the undefined value in their corresponding positions. When a &lt;a href=&quot;perldata#Key%2FValue-Hash-Slices&quot;&gt;key/value hash slice&lt;/a&gt; is passed to &lt;code&gt;delete&lt;/code&gt;, the return value is a list of key/value pairs (two elements for each item deleted from the hash).</source>
          <target state="translated">リストコンテキストでは、通常、削除された1つまたは複数の値、またはスカラーコンテキストの最後のそのような要素を返します。戻りリストの長さは引数リストの長さに対応します。存在しない要素を削除すると、対応する位置に未定義の値が返されます。場合&lt;a href=&quot;perldata#Key%2FValue-Hash-Slices&quot;&gt;、キー/値のハッシュスライスが&lt;/a&gt;に渡され &lt;code&gt;delete&lt;/code&gt; 、戻り値は、キー/値のペアのリストである（各項目のための2つの要素がハッシュから削除）。</target>
        </trans-unit>
        <trans-unit id="f04d016b9064bf9bf9d2d6da3b96e6acf6fd1521" translate="yes" xml:space="preserve">
          <source>In literal patterns, the code is parsed at the same time as the surrounding code. While within the pattern, control is passed temporarily back to the perl parser, until the logically-balancing closing brace is encountered. This is similar to the way that an array index expression in a literal string is handled, for example</source>
          <target state="translated">リテラルパターンでは、コードは周囲のコードと同時に解析されます。パターン内では、論理的にバランスのとれた終了波括弧が見つかるまで、制御は一時的にperlパーサに戻されます。これは、リテラル文字列の配列インデックス式が処理される方法に似ています。</target>
        </trans-unit>
        <trans-unit id="887e3136c0061f6a2d087f339773eb48207aff6c" translate="yes" xml:space="preserve">
          <source>In many applications it's wise to let Perl use Unicode for the strings it processes. Most of the interfaces Perl has to the outside world are still byte based. Programs therefore need to decode byte strings that enter the program from the outside and encode them again on the way out.</source>
          <target state="translated">多くのアプリケーションでは、Perl が処理する文字列に Unicode を使用することが賢明です。Perl が外部との間に持つインターフェースのほとんどは、まだバイトベースです。そのため、プログラムは外部からプログラムに入ってきたバイト文字列をデコードし、出てくるときに再度エンコードする必要があります。</target>
        </trans-unit>
        <trans-unit id="1a35afb8085f46becc13477af444009e4d377a40" translate="yes" xml:space="preserve">
          <source>In many cases, methods that are used to set the internal state of the object will return the object itself, so method calls can be conveniently chained together.</source>
          <target state="translated">多くの場合、オブジェクトの内部状態を設定するために使用されるメソッドは、オブジェクト自体を返すことになるので、メソッドの呼び出しは便利に連鎖させることができます。</target>
        </trans-unit>
        <trans-unit id="2fe4577dec3e6223467649ed832dbc4e6a555dd0" translate="yes" xml:space="preserve">
          <source>In many systems the &lt;code&gt;O_EXCL&lt;/code&gt; flag is available for opening files in exclusive mode. This is &lt;b&gt;not&lt;/b&gt; locking: exclusiveness means here that if the file already exists, &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt; fails. &lt;code&gt;O_EXCL&lt;/code&gt; may not work on network filesystems, and has no effect unless the &lt;code&gt;O_CREAT&lt;/code&gt; flag is set as well. Setting &lt;code&gt;O_CREAT|O_EXCL&lt;/code&gt; prevents the file from being opened if it is a symbolic link. It does not protect against symbolic links in the file's path.</source>
          <target state="translated">多くのシステムでは、排他モードでファイルを開くために &lt;code&gt;O_EXCL&lt;/code&gt; フラグを使用できます。これはロックではあり&lt;b&gt;ません&lt;/b&gt;。排他性とは、ファイルがすでに存在する場合、&lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt; &lt;code&gt;sysopen&lt;/code&gt; &lt;/a&gt;が失敗することを意味します。 &lt;code&gt;O_EXCL&lt;/code&gt; はネットワークファイルシステムでは機能しない可能性があり、 &lt;code&gt;O_CREAT&lt;/code&gt; フラグも設定されていない限り効果がありません。 &lt;code&gt;O_CREAT|O_EXCL&lt;/code&gt; を設定すると、ファイルがシンボリックリンクである場合にファイルが開かれなくなります。ファイルのパス内のシンボリックリンクからは保護されません。</target>
        </trans-unit>
        <trans-unit id="e9b8eb0a3ccf1ee1e198f508015d1976e62c80e9" translate="yes" xml:space="preserve">
          <source>In many systems the &lt;code&gt;O_EXCL&lt;/code&gt; flag is available for opening files in exclusive mode. This is &lt;b&gt;not&lt;/b&gt; locking: exclusiveness means here that if the file already exists, sysopen() fails. &lt;code&gt;O_EXCL&lt;/code&gt; may not work on network filesystems, and has no effect unless the &lt;code&gt;O_CREAT&lt;/code&gt; flag is set as well. Setting &lt;code&gt;O_CREAT|O_EXCL&lt;/code&gt; prevents the file from being opened if it is a symbolic link. It does not protect against symbolic links in the file's path.</source>
          <target state="translated">多くのシステムでは、ファイルを排他モードで開くために &lt;code&gt;O_EXCL&lt;/code&gt; フラグを使用できます。これはロックではあり&lt;b&gt;ません&lt;/b&gt;。排他性とは、ファイルがすでに存在する場合、sysopen（）が失敗することを意味します。 &lt;code&gt;O_EXCL&lt;/code&gt; はネットワークファイルシステムでは機能しない可能性があり、 &lt;code&gt;O_CREAT&lt;/code&gt; フラグも設定されていない場合は効果がありません。 &lt;code&gt;O_CREAT|O_EXCL&lt;/code&gt; を設定すると、ファイルがシンボリックリンクの場合、ファイルが開かれなくなります。ファイルのパスにあるシンボリックリンクからは保護されません。</target>
        </trans-unit>
        <trans-unit id="8450d241305d74878facdc73fccc0a1c6ea4d3de" translate="yes" xml:space="preserve">
          <source>In module</source>
          <target state="translated">モジュール内</target>
        </trans-unit>
        <trans-unit id="286bdc943117014c33efb93a016a5d1869678221" translate="yes" xml:space="preserve">
          <source>In module filtering context, it can be used as Perl version filter.</source>
          <target state="translated">モジュールフィルタリングのコンテキストでは、Perl のバージョンフィルタとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="a173a70aa245271ccb4f943a053fd8f7539c03d6" translate="yes" xml:space="preserve">
          <source>In more practical terms, the typemap is a collection of code fragments which are used by the &lt;b&gt;xsubpp&lt;/b&gt; compiler to map C function parameters and values to Perl values. The typemap file may consist of three sections labelled &lt;code&gt;TYPEMAP&lt;/code&gt; , &lt;code&gt;INPUT&lt;/code&gt; , and &lt;code&gt;OUTPUT&lt;/code&gt; . An unlabelled initial section is assumed to be a &lt;code&gt;TYPEMAP&lt;/code&gt; section. The INPUT section tells the compiler how to translate Perl values into variables of certain C types. The OUTPUT section tells the compiler how to translate the values from certain C types into values Perl can understand. The TYPEMAP section tells the compiler which of the INPUT and OUTPUT code fragments should be used to map a given C type to a Perl value. The section labels &lt;code&gt;TYPEMAP&lt;/code&gt; , &lt;code&gt;INPUT&lt;/code&gt; , or &lt;code&gt;OUTPUT&lt;/code&gt; must begin in the first column on a line by themselves, and must be in uppercase.</source>
          <target state="translated">より実用的な用語では、typemapはC関数のパラメーターと値をPerlの値にマップするために&lt;b&gt;xsubpp&lt;/b&gt;コンパイラーによって使用されるコードフラグメントのコレクションです。タイプマップファイルは、 &lt;code&gt;TYPEMAP&lt;/code&gt; 、 &lt;code&gt;INPUT&lt;/code&gt; 、および &lt;code&gt;OUTPUT&lt;/code&gt; というラベルの付いた3つのセクションで構成されます。ラベルのない最初のセクションは、 &lt;code&gt;TYPEMAP&lt;/code&gt; セクションであると見なされます。 INPUTセクションは、Perl値を特定のCタイプの変数に変換する方法をコンパイラーに指示します。 OUTPUTセクションは、特定のC型の値をPerlが理解できる値に変換する方法をコンパイラーに指示します。 TYPEMAPセクションは、特定のCタイプをPerl値にマップするために使用する必要があるINPUTおよびOUTPUTコードフラグメントをコンパイラーに指示します。セクションは &lt;code&gt;TYPEMAP&lt;/code&gt; とラベル付けします、 &lt;code&gt;INPUT&lt;/code&gt; 、または &lt;code&gt;OUTPUT&lt;/code&gt; は、それ自体が行の最初の列から始まり、大文字でなければなりません。</target>
        </trans-unit>
        <trans-unit id="a2596ab70d131727b8db450d6439c8e749db46f7" translate="yes" xml:space="preserve">
          <source>In more practical terms, the typemap is a collection of code fragments which are used by the &lt;b&gt;xsubpp&lt;/b&gt; compiler to map C function parameters and values to Perl values. The typemap file may consist of three sections labelled &lt;code&gt;TYPEMAP&lt;/code&gt;, &lt;code&gt;INPUT&lt;/code&gt;, and &lt;code&gt;OUTPUT&lt;/code&gt;. An unlabelled initial section is assumed to be a &lt;code&gt;TYPEMAP&lt;/code&gt; section. The INPUT section tells the compiler how to translate Perl values into variables of certain C types. The OUTPUT section tells the compiler how to translate the values from certain C types into values Perl can understand. The TYPEMAP section tells the compiler which of the INPUT and OUTPUT code fragments should be used to map a given C type to a Perl value. The section labels &lt;code&gt;TYPEMAP&lt;/code&gt;, &lt;code&gt;INPUT&lt;/code&gt;, or &lt;code&gt;OUTPUT&lt;/code&gt; must begin in the first column on a line by themselves, and must be in uppercase.</source>
          <target state="translated">より実際的な用語では、タイプマップは、C関数のパラメーターと値をPerl値にマップするために&lt;b&gt;xsubpp&lt;/b&gt;コンパイラーによって使用されるコードフラグメントのコレクションです。タイプマップファイルは、 &lt;code&gt;TYPEMAP&lt;/code&gt; 、 &lt;code&gt;INPUT&lt;/code&gt; 、および &lt;code&gt;OUTPUT&lt;/code&gt; というラベルの付いた3つのセクションで構成されている場合があります。ラベルのない最初のセクションは、 &lt;code&gt;TYPEMAP&lt;/code&gt; セクションと見なされます。 INPUTセクションは、Perl値を特定のCタイプの変数に変換する方法をコンパイラーに指示します。 OUTPUTセクションは、特定のCタイプの値をPerlが理解できる値に変換する方法をコンパイラーに指示します。 TYPEMAPセクションは、特定のCタイプをPerl値にマップするために、INPUTコードフラグメントとOUTPUTコードフラグメントのどちらを使用するかをコンパイラーに指示します。セクションラベル &lt;code&gt;TYPEMAP&lt;/code&gt; 、 &lt;code&gt;INPUT&lt;/code&gt; 、または &lt;code&gt;OUTPUT&lt;/code&gt; は、それ自体で行の最初の列から開始する必要があり、大文字である必要があります。</target>
        </trans-unit>
        <trans-unit id="fc3dbb912233fbf5258ce4b83a5eac5057d0b3f5" translate="yes" xml:space="preserve">
          <source>In most cases people have reported better results with GNU make rather than the system's /bin/make program, whether for plain modules or for XS based extensions.</source>
          <target state="translated">ほとんどの場合、人々はシステムの/bin/makeプログラムよりもGNU makeの方が良い結果が得られると報告しています。</target>
        </trans-unit>
        <trans-unit id="428ffc575a57b1bff79640b48a60fb8f688d9deb" translate="yes" xml:space="preserve">
          <source>In most cases people have reported better results with GNU make rather than the system's /bin/make program, whether for plain modules or for xs based extensions.</source>
          <target state="translated">ほとんどの場合、人々はシステムの/bin/makeプログラムよりもGNU makeの方が良い結果が得られると報告しています。</target>
        </trans-unit>
        <trans-unit id="ddebdad5fbd20cefe48a1c3287d455763963e1d8" translate="yes" xml:space="preserve">
          <source>In most cases you just need to load the desired IPC driver to make it work. You should load this driver as early as possible. A warning will be issued if you load it too late for it to be effective.</source>
          <target state="translated">ほとんどの場合、目的のIPCドライバをロードするだけで動作するようになります。このドライバはできるだけ早くロードする必要があります。有効にするためにロードが遅すぎると警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="f5afec4e8618986f557789f84e21b385879c2564" translate="yes" xml:space="preserve">
          <source>In most cases you want to make sure that the $io_handle is in &quot;binmode&quot; before you pass it as argument to the addfile() method.</source>
          <target state="translated">ほとんどの場合、$io_handle を addfile()メソッドの引数に渡す前に、$io_handle が &quot;binmode&quot; であることを確認したいと思います。</target>
        </trans-unit>
        <trans-unit id="c59025c8c8f5462c9fb0d9eec8118a96c3e872c2" translate="yes" xml:space="preserve">
          <source>In most cases you want to make sure that the $io_handle is in &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before you pass it as argument to the addfile() method.</source>
          <target state="translated">ほとんどの場合、addfile（）メソッドに引数として渡す前に、$ io_handleが &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; であることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="295ff2e93e3edb18812fcf358a08839cc337a030" translate="yes" xml:space="preserve">
          <source>In most cases you want to make sure that the $io_handle is in &lt;code&gt;binmode&lt;/code&gt; before you pass it as argument to the addfile() method.</source>
          <target state="translated">ほとんどの場合、addfile（）メソッドに引数として渡す前に、$ io_handleが &lt;code&gt;binmode&lt;/code&gt; になっていることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="525f40bb529483f51193d29f821ebe7da0a52cf3" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; is implemented via the undocumented system service &lt;code&gt;$SIGPRC&lt;/code&gt; , which has the same calling sequence as &lt;code&gt;$FORCEX&lt;/code&gt; , but throws an exception in the target process rather than forcing it to call &lt;code&gt;$EXIT&lt;/code&gt; . Generally speaking, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; follows the behavior of the CRTL's &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; function, but unlike that function can be called from within a signal handler. Also, unlike the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; in some versions of the CRTL, Perl's &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; checks the validity of the signal passed in and returns an error rather than attempting to send an unrecognized signal.</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; はドキュメント化されていないシステムサービス &lt;code&gt;$SIGPRC&lt;/code&gt; を介して実装されます。これは、 &lt;code&gt;$FORCEX&lt;/code&gt; と同じ呼び出しシーケンスを持っていますが、強制的に &lt;code&gt;$EXIT&lt;/code&gt; を呼び出すのではなく、ターゲットプロセスで例外をスローします。一般的に、 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; はCRTLの &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; 関数の動作に従いますが、その関数とは異なり、シグナルハンドラー内から呼び出すことができます。また、CRTLの一部のバージョンの &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; とは異なり、Perlの &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; は渡された信号の有効性をチェックし、認識されない信号を送信しようとするのではなく、エラーを返します。</target>
        </trans-unit>
        <trans-unit id="df94ec9676af59ec6113f48e169109d0b6d9385f" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;code&gt;kill&lt;/code&gt; is implemented via the undocumented system service &lt;code&gt;$SIGPRC&lt;/code&gt;, which has the same calling sequence as &lt;code&gt;$FORCEX&lt;/code&gt;, but throws an exception in the target process rather than forcing it to call &lt;code&gt;$EXIT&lt;/code&gt;. Generally speaking, &lt;code&gt;kill&lt;/code&gt; follows the behavior of the CRTL's &lt;code&gt;kill()&lt;/code&gt; function, but unlike that function can be called from within a signal handler. Also, unlike the &lt;code&gt;kill&lt;/code&gt; in some versions of the CRTL, Perl's &lt;code&gt;kill&lt;/code&gt; checks the validity of the signal passed in and returns an error rather than attempting to send an unrecognized signal.</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;kill&lt;/code&gt; は、ドキュメント化されていないシステムサービス &lt;code&gt;$SIGPRC&lt;/code&gt; を介して実装されます。これは、 &lt;code&gt;$FORCEX&lt;/code&gt; と同じ呼び出しシーケンスを持ちますが、 &lt;code&gt;$EXIT&lt;/code&gt; を強制的に呼び出さずに、ターゲットプロセスで例外をスローします。一般的に、 &lt;code&gt;kill&lt;/code&gt; はCRTLの &lt;code&gt;kill()&lt;/code&gt; 関数の動作に従いますが、その関数とは異なり、シグナルハンドラー内から呼び出すことができます。また、CRTLの一部のバージョンの &lt;code&gt;kill&lt;/code&gt; とは異なり、Perlの &lt;code&gt;kill&lt;/code&gt; は、認識されないシグナルを送信しようとするのではなく、渡されたシグナルの有効性をチェックしてエラーを返します。</target>
        </trans-unit>
        <trans-unit id="eede988897716aa1422cf3adeb53444b2cab13f0" translate="yes" xml:space="preserve">
          <source>In most cases, it is probably easier to simply use string concatenation, which also forces scalar context.</source>
          <target state="translated">ほとんどの場合、単純に文字列の連結を使用した方が簡単でしょう。</target>
        </trans-unit>
        <trans-unit id="ace8b1ddef61865f0aa48c02a6d220e56f6740dd" translate="yes" xml:space="preserve">
          <source>In most cases, patches to modules in</source>
          <target state="translated">ほとんどの場合</target>
        </trans-unit>
        <trans-unit id="3d608639121073b361e23e425be9ba9c84646ab9" translate="yes" xml:space="preserve">
          <source>In most cases, you can just run it interactively from a command line without any special arguments and follow the prompts.</source>
          <target state="translated">ほとんどの場合、特別な引数なしでコマンドラインから対話的に実行し、プロンプトに従うだけです。</target>
        </trans-unit>
        <trans-unit id="2f1846566ce8422fbda676e86cc15846d05061a2" translate="yes" xml:space="preserve">
          <source>In most cases, you should probably round the results explicitly using one of &lt;a href=&quot;#round()&quot;&gt;round()&lt;/a&gt;, &lt;a href=&quot;#bround()&quot;&gt;bround()&lt;/a&gt; or &lt;a href=&quot;#bfround()&quot;&gt;bfround()&lt;/a&gt; or by passing the desired accuracy to the math operation as additional parameter:</source>
          <target state="translated">ほとんどの場合、おそらくround &lt;a href=&quot;#round()&quot;&gt;（）&lt;/a&gt;、&lt;a href=&quot;#bround()&quot;&gt;bround（）、&lt;/a&gt;または&lt;a href=&quot;#bfround()&quot;&gt;bfround（）の&lt;/a&gt;いずれかを使用して明示的に結果を丸めるか、必要な精度を追加パラメーターとして数学演算に渡します。</target>
        </trans-unit>
        <trans-unit id="33cd688bb41635445ecc1419591038ede4e8360f" translate="yes" xml:space="preserve">
          <source>In most cases, you should probably round the results explicitly using one of &lt;a href=&quot;Math::BigInt#round%28%29&quot;&gt;&quot;round()&quot; in Math::BigInt&lt;/a&gt;, &lt;a href=&quot;Math::BigInt#bround%28%29&quot;&gt;&quot;bround()&quot; in Math::BigInt&lt;/a&gt; or &lt;a href=&quot;Math::BigInt#bfround%28%29&quot;&gt;&quot;bfround()&quot; in Math::BigInt&lt;/a&gt; or by passing the desired accuracy to the math operation as additional parameter:</source>
          <target state="translated">ほとんどの場合、あなたはおそらくラウンドの結果が明示的にのいずれかを使用しなければならない&lt;a href=&quot;Math::BigInt#round%28%29&quot;&gt;数学:: BigIntの中「）（ラウンド」&lt;/a&gt;、&lt;a href=&quot;Math::BigInt#bround%28%29&quot;&gt;「bround（）」数学における:: BigIntの&lt;/a&gt;か&lt;a href=&quot;Math::BigInt#bfround%28%29&quot;&gt;「bfround（）」数学:: BigIntの中&lt;/a&gt;または渡すことにより、追加パラメータとしての数学演算に必要な精度：</target>
        </trans-unit>
        <trans-unit id="fbf91aec7f60195ab2e4c16d72de4bd0b0dad318" translate="yes" xml:space="preserve">
          <source>In most cases, you should probably round the results explicitly using one of &lt;a href=&quot;bigint#round()&quot;&gt;round() in Math::BigInt&lt;/a&gt;, &lt;a href=&quot;bigint#bround()&quot;&gt;bround() in Math::BigInt&lt;/a&gt; or &lt;a href=&quot;bigint#bfround()&quot;&gt;bfround() in Math::BigInt&lt;/a&gt; or by passing the desired accuracy to the math operation as additional parameter:</source>
          <target state="translated">ほとんどの場合、&lt;a href=&quot;bigint#round()&quot;&gt;Math :: &lt;/a&gt;&lt;a href=&quot;bigint#bround()&quot;&gt;BigIntのround（）、Math :: &lt;/a&gt;&lt;a href=&quot;bigint#bfround()&quot;&gt;BigIntのbround（）、&lt;/a&gt;またはMath :: BigIntのbfround（）のいずれかを使用するか、必要な精度を数学演算に渡して、結果を明示的に丸める必要があります。追加パラメーターとして：</target>
        </trans-unit>
        <trans-unit id="a42b298f707283d45326f409618401d12bc90d6e" translate="yes" xml:space="preserve">
          <source>In most cases, you write an external module to do it--see the answer to &quot;Where can I learn about linking C with Perl? [h2xs, xsubpp]&quot;. However, if the function is a system call, and your system supports &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall()&lt;/a&gt;&lt;/code&gt;, you can use the &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; function (documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;).</source>
          <target state="translated">ほとんどの場合、それを行うための外部モジュールを作成します。「CとPerlのリンクについてどこで学べますか？[h2xs、xsubpp]」への回答を参照してください。ただし、関数がシステムコールであり、システムが &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall()&lt;/a&gt;&lt;/code&gt; をサポートしている場合は、 &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; 関数（&lt;a href=&quot;perlfunc&quot;&gt;perlfuncに記載&lt;/a&gt;）を使用できます。</target>
        </trans-unit>
        <trans-unit id="65cdcdedc88950930966f20f06c6f6a1bc834c3d" translate="yes" xml:space="preserve">
          <source>In most cases, you write an external module to do it--see the answer to &quot;Where can I learn about linking C with Perl? [h2xs, xsubpp]&quot;. However, if the function is a system call, and your system supports &lt;code&gt;syscall()&lt;/code&gt;, you can use the &lt;code&gt;syscall&lt;/code&gt; function (documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;).</source>
          <target state="translated">ほとんどの場合、それを行うための外部モジュールを作成します。「CとPerlのリンクについてどこで学ぶことができますか？[h2xs、xsubpp]」の回答を参照してください。ただし、関数がシステムコールであり、システムが &lt;code&gt;syscall()&lt;/code&gt; をサポートしている場合は、 &lt;code&gt;syscall&lt;/code&gt; 関数（&lt;a href=&quot;perlfunc&quot;&gt;perlfuncに記載&lt;/a&gt;）を使用できます。</target>
        </trans-unit>
        <trans-unit id="7f196207a99eece1cc9a419701bff50faa9e469c" translate="yes" xml:space="preserve">
          <source>In most instances, the function that discovers the issue sets the causal flag and returns failure immediately. &lt;a href=&quot;#Parsing-complications&quot;&gt;&quot;Parsing complications&quot;&lt;/a&gt; contains an explicit example of how this works. In other cases, such as a forward reference to a numbered parenthetical grouping, we need to finish the parse to know if that numbered grouping actually appears in the pattern. In those cases, the parse is just redone at the end, with the knowledge of how many groupings occur in it.</source>
          <target state="translated">ほとんどの場合、問題を検出する関数は原因フラグを設定し、すぐに失敗を返します。&lt;a href=&quot;#Parsing-complications&quot;&gt;「合併症の解析」に&lt;/a&gt;は、これがどのように機能するかの明確な例が含まれています。番号付きの括弧で囲まれたグループへの前方参照など、その他の場合は、その番号付きのグループが実際にパターンに表示されるかどうかを確認するために解析を終了する必要があります。そのような場合、解析は最後に再実行され、そこで発生するグループ化の数がわかります。</target>
        </trans-unit>
        <trans-unit id="d19f51a558abe46dfdc218b96bc734b3c276b079" translate="yes" xml:space="preserve">
          <source>In most operating systems, lines in files are terminated by newlines. Just what is used as a newline may vary from OS to OS. Unix traditionally uses &lt;code&gt;\012&lt;/code&gt; , one type of DOSish I/O uses &lt;code&gt;\015\012&lt;/code&gt; , Mac OS uses &lt;code&gt;\015&lt;/code&gt; , and z/OS uses &lt;code&gt;\025&lt;/code&gt; .</source>
          <target state="translated">ほとんどのオペレーティングシステムでは、ファイルの行は改行で終了します。改行として使用されるものは、OSによって異なる場合があります。Unixは伝統的に &lt;code&gt;\012&lt;/code&gt; 使用し、DOSish I / Oの1つのタイプは &lt;code&gt;\015\012&lt;/code&gt; 使用し、Mac OSは &lt;code&gt;\015&lt;/code&gt; 使用し、z / OSは &lt;code&gt;\025&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="f67379f4e94f10ca981b8e2ea0b0a789ca5f65aa" translate="yes" xml:space="preserve">
          <source>In most operating systems, lines in files are terminated by newlines. Just what is used as a newline may vary from OS to OS. Unix traditionally uses &lt;code&gt;\012&lt;/code&gt;, one type of DOSish I/O uses &lt;code&gt;\015\012&lt;/code&gt;, Mac OS uses &lt;code&gt;\015&lt;/code&gt;, and z/OS uses &lt;code&gt;\025&lt;/code&gt;.</source>
          <target state="translated">ほとんどのオペレーティングシステムでは、ファイルの行は改行で終了します。改行として使用されるものは、OSごとに異なる場合があります。Unixは伝統的に &lt;code&gt;\012&lt;/code&gt; 使用し、DOSish I / Oの1つのタイプは &lt;code&gt;\015\012&lt;/code&gt; 使用し、MacOSは &lt;code&gt;\015&lt;/code&gt; 使用し、z / OSは &lt;code&gt;\025&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="59c4293bfbaf72968d51c71aab642ca2822c9579" translate="yes" xml:space="preserve">
          <source>In multithreaded scripts Perl coordinates the threads so that any thread may modify its copy of the &lt;code&gt;$0&lt;/code&gt; and the change becomes visible to ps(1) (assuming the operating system plays along). Note that the view of &lt;code&gt;$0&lt;/code&gt; the other threads have will not change since they have their own copies of it.</source>
          <target state="translated">マルチスレッドスクリプトでは、Perlはスレッドを調整して、どのスレッドも &lt;code&gt;$0&lt;/code&gt; コピーを変更し、その変更をps（1）で認識できるようにします（オペレーティングシステムが動作している場合）。他のスレッドが持っている &lt;code&gt;$0&lt;/code&gt; のビューは、独自のコピーを持っているので変更されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="2ff5aa25fe59ffebaa3d9b983e6ed41dcfbb4c10" translate="yes" xml:space="preserve">
          <source>In networking, a &lt;b&gt;process&lt;/b&gt; that either advertises a &lt;b&gt;service&lt;/b&gt; or just hangs around at a known location and waits for &lt;b&gt;clients&lt;/b&gt; who need service to get in touch with it.</source>
          <target state="translated">ネットワーキングでは、&lt;b&gt;プロセスは、&lt;/b&gt;どちらかがアドバタイズする&lt;b&gt;サービス&lt;/b&gt;のためか、既知の場所に周りだけでハングアップして待機&lt;b&gt;クライアント&lt;/b&gt;それとの接触を取得するサービスを必要としています。</target>
        </trans-unit>
        <trans-unit id="fe020f31c58d30517974e8b54ebe9cc4a8fb1397" translate="yes" xml:space="preserve">
          <source>In networking, a &lt;b&gt;process&lt;/b&gt; that initiates contact with a &lt;b&gt;server&lt;/b&gt; process in order to exchange data and perhaps receive a service.</source>
          <target state="translated">ネットワーキングにおいて、データを交換し、場合によってはサービスを受けるために、&lt;b&gt;サーバー&lt;/b&gt;プロセスとの&lt;b&gt;接続&lt;/b&gt;を開始する&lt;b&gt;プロセス&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b7faa009c2918d4804b660feca8b23ad35925a6e" translate="yes" xml:space="preserve">
          <source>In networking, an agreed-upon way of sending messages back and forth so that neither correspondent will get too confused.</source>
          <target state="translated">ネットワークでは、通信相手があまり混乱しないように、メッセージを前後に送信する合意された方法。</target>
        </trans-unit>
        <trans-unit id="c0e4746f4dfd5f8f65267b46eb6ee2bd94d9dce3" translate="yes" xml:space="preserve">
          <source>In non-UTF-8 locales (hence single byte), code points above 0xFF are technically invalid. But if present, again starting in v5.26, they will collate to the same position as the highest valid code point does. This generally gives good results, but the collation order may be skewed if the valid code point gets special treatment when it forms particular sequences with other characters as defined by the locale. When two strings collate identically, the code point order is used as a tie breaker.</source>
          <target state="translated">非 UTF-8 ロケール (つまりシングルバイト)では、0xFF より上のコードポイントは技術的に無効です。しかし、存在する場合は、v5.26 以降では、最も高い有効なコードポイントと同じ位置に照合されます。これにより一般的には良い結果が得られますが、有効なコードポイントがロケールで定義されている他の文字と特定のシーケンスを形成している場合に特別な扱いを受けると、照合順序が歪んでしまうことがあります。ふたつの文字列が同じように照合する場合は、コードポイントの順序をタイブレークとして使用します。</target>
        </trans-unit>
        <trans-unit id="71b3fd1615492dc9bf230d9f033afbf83da86082" translate="yes" xml:space="preserve">
          <source>In normal &amp;ldquo;computerese&amp;rdquo;, the piece of data of the size most efficiently handled by your computer, typically 32 bits or so, give or take a few powers of 2. In Perl culture, it more often refers to an alphanumeric &lt;b&gt;identifier&lt;/b&gt; (including underscores), or to a string of nonwhitespace &lt;b&gt;characters&lt;/b&gt; bounded by whitespace or string boundaries.</source>
          <target state="translated">通常の「コンピューター」では、コンピューターで最も効率的に処理されるサイズのデータ​​（通常32ビット程度）は、2のべき乗を与えるか、または取ります。Perlカルチャでは、英数字の&lt;b&gt;識別子&lt;/b&gt;（アンダースコアを含む）を参照することが多い）、または空白以外の文字列に&lt;b&gt;文字&lt;/b&gt;空白や文字列の境界線で囲まれました。</target>
        </trans-unit>
        <trans-unit id="2b1437a6901ce1f87cee7f4d6385fbba76b51c73" translate="yes" xml:space="preserve">
          <source>In object-oriented code, we often find that one object references another object. This is called &lt;b&gt;composition&lt;/b&gt;, or a &lt;b&gt;has-a&lt;/b&gt; relationship.</source>
          <target state="translated">オブジェクト指向のコードでは、あるオブジェクトが別のオブジェクトを参照していることがよくあります。これは呼ばれる&lt;b&gt;構成&lt;/b&gt;、あるいは&lt;b&gt;持ってい-&lt;/b&gt;関係を。</target>
        </trans-unit>
        <trans-unit id="0840885f4ae0e15a9e1a64e6e2f2e63bb6055bf6" translate="yes" xml:space="preserve">
          <source>In olden days, the act of looking up a &lt;b&gt;key&lt;/b&gt; in an actual index (such as a phone book). But now it's merely the act of using any kind of key or position to find the corresponding &lt;b&gt;value&lt;/b&gt;, even if no index is involved. Things have degenerated to the point that Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; function merely locates the position (index) of one string in another.</source>
          <target state="translated">昔は、実際のインデックス（電話帳など）で&lt;b&gt;キー&lt;/b&gt;を検索する行為。しかし、今では、インデックスが含まれていなくても、対応する&lt;b&gt;値&lt;/b&gt;を見つけるためにあらゆる種類のキーまたは位置を使用する行為にすぎません。Perlの &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; 関数は、ある文字列の位置（インデックス）を別の文字列に配置するだけであるという点まで、状況は悪化しています。</target>
        </trans-unit>
        <trans-unit id="b754306ff2e4bb5b2e3f0917babd038de6c2bb80" translate="yes" xml:space="preserve">
          <source>In olden days, the act of looking up a &lt;b&gt;key&lt;/b&gt; in an actual index (such as a phone book). But now it's merely the act of using any kind of key or position to find the corresponding &lt;b&gt;value&lt;/b&gt;, even if no index is involved. Things have degenerated to the point that Perl&amp;rsquo;s &lt;code&gt;index&lt;/code&gt; function merely locates the position (index) of one string in another.</source>
          <target state="translated">昔は、実際のインデックス（電話帳など）で&lt;b&gt;キー&lt;/b&gt;を検索する行為。しかし今では、インデックスが含まれていなくても、対応する&lt;b&gt;値&lt;/b&gt;を見つけるために任意の種類のキーまたは位置を使用する行為にすぎません。Perlの &lt;code&gt;index&lt;/code&gt; 関数が、ある文字列の位置（インデックス）を別の文字列に配置するだけになるまで、状況は悪化しています。</target>
        </trans-unit>
        <trans-unit id="8954164487b10a1a06bdaedbfbaa22faf258c328" translate="yes" xml:space="preserve">
          <source>In older Unicode versions, a small number of characters (all of which are CJK compatibility ideographs as far as they have been found) may have an erroneous decomposition mapping (see</source>
          <target state="translated">古い Unicode バージョンでは、少数の文字 (発見された限りではすべて日中韓互換表意文字です)が誤った分解マッピングを持つ可能性があります (参照)。</target>
        </trans-unit>
        <trans-unit id="25564a5fe1398dbc91939b7e3cb0a5bccfb1e2c1" translate="yes" xml:space="preserve">
          <source>In one sense, what you are asking doesn't make much sense: encodings are for characters, and binary data are not &quot;characters&quot;, so converting &quot;data&quot; into some encoding isn't meaningful unless you know in what character set and encoding the binary data is in, in which case it's not just binary data, now is it?</source>
          <target state="translated">エンコーディングは文字のためのものであり、バイナリデータは「文字」ではないので、「データ」を何らかのエンコーディングに変換することは、バイナリデータがどのような文字セットで、どのようなエンコーディングになっているかがわからなければ意味がありません。</target>
        </trans-unit>
        <trans-unit id="0665aadb9203e48ab11fdbdc61f426bdf069c8ef" translate="yes" xml:space="preserve">
          <source>In one's own MANIFEST.SKIP file, certain directives can be used to include the contents of other MANIFEST.SKIP files. At present two such directives are recognized.</source>
          <target state="translated">自分自身のMANIFEST.SKIPファイルでは、他のMANIFEST.SKIPファイルの内容を含めるために、あるディレクティブを使うことができます。現在のところ、そのような二つのディレクティブが認識されています。</target>
        </trans-unit>
        <trans-unit id="775d518fe37c14b3f79041d34b5efaca033dd3ab" translate="yes" xml:space="preserve">
          <source>In one-liner form:</source>
          <target state="translated">ワンライナー形式で。</target>
        </trans-unit>
        <trans-unit id="3a599813be17001915e0601602237bd798d15d3b" translate="yes" xml:space="preserve">
          <source>In one-shot mode this flag will be set to true if the Perl &lt;code&gt;-T&lt;/code&gt; operator thinks the file contains text.</source>
          <target state="translated">ワンショットモードでは、Perl &lt;code&gt;-T&lt;/code&gt; オペレーターがファイルにテキストが含まれていると見なした場合、このフラグはtrueに設定されます。</target>
        </trans-unit>
        <trans-unit id="0a387689b89f7b0ad51aa990a4b2c214ffa94375" translate="yes" xml:space="preserve">
          <source>In order for object method lookup and/or prototype checking to operate correctly even when methods have not yet been defined it is necessary to &quot;forward declare&quot; each subroutine (as in &lt;code&gt;sub NAME;&lt;/code&gt; ). See &lt;a href=&quot;perlsub#SYNOPSIS&quot;&gt;SYNOPSIS in perlsub&lt;/a&gt;. Such forward declaration creates &quot;subroutine stubs&quot;, which are place holders with no code.</source>
          <target state="translated">メソッドがまだ定義されていない場合でも、オブジェクトメソッドのルックアップやプロトタイプチェックが正しく機能するためには、各サブルーチンを &quot;前方宣言&quot;する必要があります（ &lt;code&gt;sub NAME;&lt;/code&gt; ）。&lt;a href=&quot;perlsub#SYNOPSIS&quot;&gt;perlsubのSYNOPSISを&lt;/a&gt;参照してください。このような前方宣言は、コードのないプレースホルダーである「サブルーチンスタブ」を作成します。</target>
        </trans-unit>
        <trans-unit id="90345d24344bda0288805e106343fe2f95bd2679" translate="yes" xml:space="preserve">
          <source>In order for object method lookup and/or prototype checking to operate correctly even when methods have not yet been defined it is necessary to &quot;forward declare&quot; each subroutine (as in &lt;code&gt;sub NAME;&lt;/code&gt;). See &lt;a href=&quot;perlsub#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot; in perlsub&lt;/a&gt;. Such forward declaration creates &quot;subroutine stubs&quot;, which are place holders with no code.</source>
          <target state="translated">メソッドがまだ定義されていない場合でも、オブジェクトメソッドのルックアップやプロトタイプチェックが正しく機能するためには、各サブルーチンを「前方宣言」する必要があります（ &lt;code&gt;sub NAME;&lt;/code&gt; ）。&lt;a href=&quot;perlsub#SYNOPSIS&quot;&gt;perlsubの「SYNOPSIS」を&lt;/a&gt;参照してください。このような前方宣言は、コードのないプレースホルダーである「サブルーチンスタブ」を作成します。</target>
        </trans-unit>
        <trans-unit id="f0241ec9af4c551ca21dc35ad3b6791e44a33543" translate="yes" xml:space="preserve">
          <source>In order to allow for multiple big integer libraries, Math::BigInt was rewritten to use a plug-in library for core math routines. Any module which conforms to the API can be used by Math::BigInt by using this in your program:</source>
          <target state="translated">複数のビッグ整数ライブラリを使用できるようにするために、Math::BigInt はコアの数学ルーチンのためのプラグインライブラリを使用するように書き換えられました。API に準拠したモジュールであれば、これをプログラムで使用することで Math::BigInt で使用することができます。</target>
        </trans-unit>
        <trans-unit id="db68f3a19f1d4b1da9de666e4465352494a86e3b" translate="yes" xml:space="preserve">
          <source>In order to allow for multiple big integer libraries, Math::BigInt was rewritten to use library modules for core math routines. Any module which follows the same API as this can be used instead by using the following:</source>
          <target state="translated">複数のビッグ整数ライブラリを使用できるようにするために、Math::BigInt はコアの数学ルーチンにライブラリモジュールを使用するように書き換えられました。これと同じAPIに従ったモジュールであれば、以下のようにして代わりに使用することができます。</target>
        </trans-unit>
        <trans-unit id="79f9d107daff2d5afbf356c8809d8a77ed4fb993" translate="yes" xml:space="preserve">
          <source>In order to build your own version of Perl you will need 'make', which is part of Apple's developer tools - also known as Xcode. From Mac OS X 10.7 &quot;Lion&quot; onwards, it can be downloaded separately as the 'Command Line Tools' bundle directly from &lt;a href=&quot;https://developer.apple.com/downloads/&quot;&gt;https://developer.apple.com/downloads/&lt;/a&gt; (you will need a free account to log in), or as a part of the Xcode suite, freely available at the App Store. Xcode is a pretty big app, so unless you already have it or really want it, you are advised to get the 'Command Line Tools' bundle separately from the link above. If you want to do it from within Xcode, go to Xcode -&amp;gt; Preferences -&amp;gt; Downloads and select the 'Command Line Tools' option.</source>
          <target state="translated">独自のバージョンのPerlをビルドするには、「make」が必要です。これは、Appleの開発者ツールの一部であり、Xcodeとしても知られています。 Mac OS X 10.7 &quot;Lion&quot;以降、&lt;a href=&quot;https://developer.apple.com/downloads/&quot;&gt;https：//developer.apple.com/downloads/&lt;/a&gt;から直接「コマンドラインツール」バンドルとして個別にダウンロードできます（ログインするには無料のアカウントが必要です）、またはXcodeスイートの一部として、App Storeから無料で入手できます。 Xcodeはかなり大きなアプリであるため、既に持っている場合や本当に必要な場合を除き、上記のリンクとは別に「コマンドラインツール」バンドルを入手することをお勧めします。 Xcode内から実行する場合は、Xcode-&amp;gt; Preferences-&amp;gt; Downloadsに移動して、[Command Line Tools]オプションを選択します。</target>
        </trans-unit>
        <trans-unit id="a93cd8781d8e041e8355a0aefc4276597d7a98e8" translate="yes" xml:space="preserve">
          <source>In order to convert a string of characters from one character set to another a simple list of numbers, such as in the right columns in the above table, along with Perl's &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; operator is all that is needed. The data in the table are in ASCII/Latin1 order, hence the EBCDIC columns provide easy-to-use ASCII/Latin1 to EBCDIC operations that are also easily reversed.</source>
          <target state="translated">文字列をある文字セットから別の文字セットに変換するには、上記の表の右側の列にあるような、Perlの &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 演算子とともに単純な数値のリストを使用するだけです。表のデータはASCII / Latin1の順序になっているため、EBCDIC列は使いやすいASCII / Latin1からEBCDICへの操作を提供し、これらも簡単に逆転できます。</target>
        </trans-unit>
        <trans-unit id="2705e74e9648fc4b957e6b22cc815af6c67ac538" translate="yes" xml:space="preserve">
          <source>In order to convert a string of characters from one character set to another a simple list of numbers, such as in the right columns in the above table, along with Perl's &lt;code&gt;tr///&lt;/code&gt; operator is all that is needed. The data in the table are in ASCII/Latin1 order, hence the EBCDIC columns provide easy-to-use ASCII/Latin1 to EBCDIC operations that are also easily reversed.</source>
          <target state="translated">文字列をある文字セットから別の文字セットに変換するには、上記の表の右側の列にあるような単純な数字のリストと、Perlの &lt;code&gt;tr///&lt;/code&gt; 演算子だけが必要です。表のデータはASCII / Latin1の順序であるため、EBCDIC列は、使いやすいASCII / Latin1からEBCDICへの操作を提供し、簡単に逆にすることもできます。</target>
        </trans-unit>
        <trans-unit id="614dd2adb3410a9f885520f92ddaaafdc83205d2" translate="yes" xml:space="preserve">
          <source>In order to facilitate this feature, the following code can be employed:</source>
          <target state="translated">この機能を容易にするために、以下のコードを採用することができます。</target>
        </trans-unit>
        <trans-unit id="2f5fa67b20e8cfe8e347f59bf69babb07bc272aa" translate="yes" xml:space="preserve">
          <source>In order to install a new regexp handler, &lt;code&gt;$^H{regcomp}&lt;/code&gt; is set to an integer which (when casted appropriately) resolves to one of these structures. When compiling, the &lt;code&gt;comp&lt;/code&gt; method is executed, and the resulting &lt;code&gt;regexp&lt;/code&gt; structure's engine field is expected to point back at the same structure.</source>
          <target state="translated">新しい正規表現ハンドラーをインストールするために、 &lt;code&gt;$^H{regcomp}&lt;/code&gt; は整数に設定されます（適切にキャストされた場合）これらの構造の1つに解決されます。コンパイル時に &lt;code&gt;comp&lt;/code&gt; メソッドが実行され、結果の &lt;code&gt;regexp&lt;/code&gt; 構造体のengineフィールドが同じ構造体を指すことが期待されます。</target>
        </trans-unit>
        <trans-unit id="437d80cea54e562ec941100e6a72df58383866f9" translate="yes" xml:space="preserve">
          <source>In order to keep lib.pm small and simple, it only works with Unix filepaths. This doesn't mean it only works on Unix, but non-Unix users must first translate their file paths to Unix conventions.</source>
          <target state="translated">lib.pm を小さくシンプルに保つために、Unix のファイルパスでのみ動作します。これは Unix でのみ動作するという意味ではありませんが、Unix 以外のユーザはまずファイルパスを Unix の規約に翻訳しなければなりません。</target>
        </trans-unit>
        <trans-unit id="364bb5f6d99dcae74466742fdf303cf213f25184" translate="yes" xml:space="preserve">
          <source>In order to maintain maximum compatibility with earlier versions of Perl, this function will return either the floating point notation or the multiple dotted notation, depending on whether the original version contained 1 or more dots, respectively.</source>
          <target state="translated">以前のバージョンのPerlとの互換性を最大限に維持するために、この関数は、元のバージョンがそれぞれ1つ以上のドットを含むかどうかに応じて、浮動小数点記法または複数のドット記法のいずれかを返します。</target>
        </trans-unit>
        <trans-unit id="ff0a513e88ce791d6cb047a72ff030f3cd3db74e" translate="yes" xml:space="preserve">
          <source>In order to maintain portability of attributes with older versions of MakeMaker you may want to use &lt;a href=&quot;App::EUMM::Upgrade&quot;&gt;App::EUMM::Upgrade&lt;/a&gt; with your &lt;code&gt;Makefile.PL&lt;/code&gt;.</source>
          <target state="translated">古いバージョンのMakeMakerで属性の移植性を維持するために、 &lt;code&gt;Makefile.PL&lt;/code&gt; で&lt;a href=&quot;App::EUMM::Upgrade&quot;&gt;App :: EUMM :: Upgrade&lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="381ea4e1bb108f2a93fb8d7c5edae34da5e15c66" translate="yes" xml:space="preserve">
          <source>In order to maintain portability of attributes with older versions of MakeMaker you may want to use &lt;a href=&quot;http://search.cpan.org/perldoc/App::EUMM::Upgrade&quot;&gt;App::EUMM::Upgrade&lt;/a&gt; with your &lt;code&gt;Makefile.PL&lt;/code&gt; .</source>
          <target state="translated">古いバージョンのMakeMakerで属性の移植性を維持するために、 &lt;code&gt;Makefile.PL&lt;/code&gt; で&lt;a href=&quot;http://search.cpan.org/perldoc/App::EUMM::Upgrade&quot;&gt;App :: EUMM :: Upgrade&lt;/a&gt;を使用することができます。</target>
        </trans-unit>
        <trans-unit id="9248f937d9955a6043a592d635bc82f1867f0186" translate="yes" xml:space="preserve">
          <source>In order to make RECNO more compatible with Perl, the array offset for all RECNO arrays begins at 0 rather than 1 as in Berkeley DB.</source>
          <target state="translated">RECNOをPerlとの互換性を高めるために、すべてのRECNO配列の配列オフセットは、Berkeley DBのように1ではなく0から始まります。</target>
        </trans-unit>
        <trans-unit id="a134e96e551361d71e9403326bccc706fc907e08" translate="yes" xml:space="preserve">
          <source>In order to make it impossible to know what seed to generate an attack key set for, this seed is randomly initialized at process start. This may be overridden by using the PERL_HASH_SEED environment variable, see &lt;a href=&quot;perlrun#PERL_HASH_SEED&quot;&gt;&quot;PERL_HASH_SEED&quot; in perlrun&lt;/a&gt;. This environment variable controls how items are actually stored, not how they are presented via &lt;code&gt;keys&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt; and &lt;code&gt;each&lt;/code&gt;.</source>
          <target state="translated">攻撃キーセットを生成するシードを知ることができないようにするために、このシードはプロセスの開始時にランダムに初期化されます。これは、PERL_HASH_SEED環境変数を使用してオーバーライドできます。perlrunの&lt;a href=&quot;perlrun#PERL_HASH_SEED&quot;&gt;「PERL_HASH_SEED」を&lt;/a&gt;参照してください。この環境変数は、 &lt;code&gt;keys&lt;/code&gt; 、 &lt;code&gt;values&lt;/code&gt; 、および &lt;code&gt;each&lt;/code&gt; 介してアイテムがどのように表示されるかではなく、アイテムが実際に保存される方法を制御します。</target>
        </trans-unit>
        <trans-unit id="c8f50d2afd74c2c616567dbb29c3d95a6bbbba68" translate="yes" xml:space="preserve">
          <source>In order to make it impossible to know what seed to generate an attack key set for, this seed is randomly initialized at process start. This may be overridden by using the PERL_HASH_SEED environment variable, see &lt;a href=&quot;perlrun#PERL_HASH_SEED&quot;&gt;PERL_HASH_SEED in perlrun&lt;/a&gt;. This environment variable controls how items are actually stored, not how they are presented via &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">攻撃キーセットを生成するためのシードを知ることを不可能にするために、このシードはプロセスの開始時にランダムに初期化されます。これは、PERL_HASH_SEED環境変数を使用してオーバーライドできます&lt;a href=&quot;perlrun#PERL_HASH_SEED&quot;&gt;。perlrunのPERL_HASH_SEEDを&lt;/a&gt;参照してください。アイテムが実際にそれらを介して提示されているか、いない保存されているどのようにこの環境変数のコントロール &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ee499e6bf85d10a6d431bac5ed2b0a2689595e9" translate="yes" xml:space="preserve">
          <source>In order to make sense of Maketext and how all its components fit together, you should probably go read &lt;a href=&quot;Locale::Maketext::TPJ13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;, and</source>
          <target state="translated">MAKETEXTの意味を理解し、そのすべてのコンポーネントを組み合わせるどのように、あなたはおそらく読んで行くべきために&lt;a href=&quot;Locale::Maketext::TPJ13&quot;&gt;TPJ13 ::ロケールを:: MAKETEXT&lt;/a&gt;、および</target>
        </trans-unit>
        <trans-unit id="e1eda6692f2f4e28d3303c1b91852403d3cf17be" translate="yes" xml:space="preserve">
          <source>In order to make sense of Maketext and how all its components fit together, you should probably go read &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;, and</source>
          <target state="translated">MAKETEXTの意味を理解し、そのすべてのコンポーネントを組み合わせるどのように、あなたはおそらく読んで行くべきために&lt;a href=&quot;maketext/tpj13&quot;&gt;TPJ13 ::ロケールを:: MAKETEXT&lt;/a&gt;、および</target>
        </trans-unit>
        <trans-unit id="5ff6fc777d96f10921d74c27d5ed5e70b4334507" translate="yes" xml:space="preserve">
          <source>In order to make use of the rot13 filter we need some way of encoding the source file in rot13 format. The script below, &lt;code&gt;mkrot13&lt;/code&gt; , does just that.</source>
          <target state="translated">rot13フィルターを使用するには、ソースファイルをrot13形式でエンコードする方法が必要です。以下のスクリプト &lt;code&gt;mkrot13&lt;/code&gt; は、まさにそれを行います。</target>
        </trans-unit>
        <trans-unit id="e5ce5aaa659273d789866dcaf152404f645eca91" translate="yes" xml:space="preserve">
          <source>In order to make use of the rot13 filter we need some way of encoding the source file in rot13 format. The script below, &lt;code&gt;mkrot13&lt;/code&gt;, does just that.</source>
          <target state="translated">rot13フィルターを利用するには、ソースファイルをrot13形式でエンコードする方法が必要です。以下のスクリプト &lt;code&gt;mkrot13&lt;/code&gt; は、まさにそれを実行します。</target>
        </trans-unit>
        <trans-unit id="a7f6e1960069058479b2fc6d8a1c1c5f09a5d874" translate="yes" xml:space="preserve">
          <source>In order to preserve backward compatibility, Perl does not turn on full internal Unicode support unless the pragma &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;use feature 'unicode_strings'&lt;/code&gt;&lt;/a&gt; is specified. (This is automatically selected if you &lt;code&gt;use 5.012&lt;/code&gt; or higher.) Failure to do this can trigger unexpected surprises. See &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot;&lt;/a&gt; below.</source>
          <target state="translated">下位互換性を維持するために、プラグマ&lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt; &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; &lt;/a&gt;が指定されていない限り、Perlは完全な内部Unicodeサポートをオンにしません。（ &lt;code&gt;use 5.012&lt;/code&gt; 以降を使用している場合、これは自動的に選択されます。）これを行わないと、予期しない驚きが発生する可能性があります。以下&lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;の「Unicodeバグ」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="21d2fc600dcdd5c6cb297e557194c37b7f0f485a" translate="yes" xml:space="preserve">
          <source>In order to preserve backward compatibility, Perl does not turn on full internal Unicode support unless the pragma &lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;use feature 'unicode_strings' &lt;/a&gt; is specified. (This is automatically selected if you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher.) Failure to do this can trigger unexpected surprises. See &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt; below.</source>
          <target state="translated">下位互換性を維持するために、プラグマ&lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;使用機能「unicode_strings」&lt;/a&gt;が指定されていない限り、Perlは完全な内部Unicodeサポートをオンにしません。（ &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 以降を&lt;a href=&quot;functions/use&quot;&gt;使用している&lt;/a&gt;場合、これは自動的に選択されます。）これを怠ると、予期しない驚きが発生する可能性があります。下記&lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;のUnicodeバグを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b671fb091ffbe602fd70383514c67045115109bc" translate="yes" xml:space="preserve">
          <source>In order to preserve the meaning of the processed version, the normalized representation will always contain at least three sub terms. In other words, the following is guaranteed to always be true:</source>
          <target state="translated">処理されたバージョンの意味を保持するために、正規化された表現は、常に少なくとも3つのサブタームを含む。言い換えれば、以下のことが常に保証されているということです。</target>
        </trans-unit>
        <trans-unit id="fd47550c4a48b602de1804d810fabdd19f1a7062" translate="yes" xml:space="preserve">
          <source>In order to process interior sequences, subclasses implementations of this method will probably want to invoke either &lt;b&gt;interpolate()&lt;/b&gt; or &lt;b&gt;parse_text()&lt;/b&gt;, passing it the text block &lt;code&gt;$text&lt;/code&gt; , and the corresponding line number in &lt;code&gt;$line_num&lt;/code&gt; , and then perform any desired processing upon the returned result.</source>
          <target state="translated">内部シーケンスを処理するために、このメソッドのサブクラス実装は、おそらく&lt;b&gt;interpolate（）&lt;/b&gt;または&lt;b&gt;parse_text（）の&lt;/b&gt;いずれかを呼び出し、&lt;b&gt;それに&lt;/b&gt;テキストブロック &lt;code&gt;$text&lt;/code&gt; と &lt;code&gt;$line_num&lt;/code&gt; 対応する行番号を渡し、必要な処理を実行する必要があります。返された結果。</target>
        </trans-unit>
        <trans-unit id="c302db0fb7a3da4f6c22dd771e513397179c92f5" translate="yes" xml:space="preserve">
          <source>In order to specifically obtain the &quot;blocking connect then non-blocking send and receive&quot; behaviour of specifying this combination of options to &lt;code&gt;::INET&lt;/code&gt; when using &lt;code&gt;::IP&lt;/code&gt;, perform first a blocking connect, then afterwards turn the socket into nonblocking mode.</source>
          <target state="translated">&lt;code&gt;::IP&lt;/code&gt; を使用するときに &lt;code&gt;::INET&lt;/code&gt; にこのオプションの組み合わせを指定する「ブロッキング接続と非ブロッキング送受信」の動作を具体的に取得するには、最初にブロッキング接続を実行し、その後ソケットを非ブロッキングモードにします。</target>
        </trans-unit>
        <trans-unit id="96a9bbcaad8032f3708be9f9aad29a52e4a152b3" translate="yes" xml:space="preserve">
          <source>In order to test that our extension works, we now need to look at the file Mytest.t. This file is set up to imitate the same kind of testing structure that Perl itself has. Within the test script, you perform a number of tests to confirm the behavior of the extension, printing &quot;ok&quot; when the test is correct, &quot;not ok&quot; when it is not.</source>
          <target state="translated">このファイルは、Perl自身が持っているのと同じようなテスト構造を模倣するように設定されています。テストスクリプトの中で、拡張機能の動作を確認するためにいくつかのテストを実行し、テストが正しい場合は「OK」、正しくない場合は「OKではない」と表示します。</target>
        </trans-unit>
        <trans-unit id="e8108d3bcd39eeb2141d68d5707c2daf6f01568e" translate="yes" xml:space="preserve">
          <source>In order to understand Perl objects, you first need to understand references in Perl. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; for details.</source>
          <target state="translated">Perlオブジェクトを理解するには、まずPerlでの参照を理解する必要があります。詳細は&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="27839c8923c39400f0c61162217f01b584f16173" translate="yes" xml:space="preserve">
          <source>In order to understand Perl objects, you first need to understand references in Perl. See &lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt; for details.</source>
          <target state="translated">Perlオブジェクトを理解するには、最初にPerlの参照を理解する必要があります。詳細については、&lt;a href=&quot;perlreftut&quot;&gt;perlreftut&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="769d36508232140bd94018f22812d43183fa9db1" translate="yes" xml:space="preserve">
          <source>In order to use &lt;b&gt;AutoLoader&lt;/b&gt;'s AUTOLOAD subroutine you</source>
          <target state="translated">&lt;b&gt;AutoLoader&lt;/b&gt;のAUTOLOADサブルーチンを使用するには、</target>
        </trans-unit>
        <trans-unit id="af99082b46921b802ae95263001ef07cb7aa2040" translate="yes" xml:space="preserve">
          <source>In ordinary paragraphs and in some command paragraphs, various formatting codes (a.k.a. &quot;interior sequences&quot;) can be used:</source>
          <target state="translated">通常の段落や一部のコマンド段落では、様々な書式コード(別名「内部シーケンス」)を使用することができます。</target>
        </trans-unit>
        <trans-unit id="de5a0be2abf85a22324ace726b3f113f3ddb049b" translate="yes" xml:space="preserve">
          <source>In other boolean contexts, &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; without an explicit &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; test or comparison elicits a warning if the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; command-line switch (the &lt;code&gt;$^W&lt;/code&gt; variable) is in effect.</source>
          <target state="translated">他のブールコンテキストでは、明示的に &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; テストまたは比較なしの &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; warningsプラグマまたは&lt;b&gt;-w&lt;/b&gt;コマンドラインスイッチ（ &lt;code&gt;$^W&lt;/code&gt; 変数）が有効な場合に警告を出します。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="db1110375e2390784483badecec61d64d1163ab0" translate="yes" xml:space="preserve">
          <source>In other boolean contexts, &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; without an explicit &lt;code&gt;defined&lt;/code&gt; test or comparison elicits a warning if the &lt;code&gt;use warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; command-line switch (the &lt;code&gt;$^W&lt;/code&gt; variable) is in effect.</source>
          <target state="translated">他のブールコンテキストでは、明示的に &lt;code&gt;defined&lt;/code&gt; テストまたは比較のない &lt;code&gt;&amp;lt;&lt;i&gt;FILEHANDLE&lt;/i&gt;&amp;gt;&lt;/code&gt; は、警告 &lt;code&gt;use warnings&lt;/code&gt; プラグマまたは&lt;b&gt;-w&lt;/b&gt;コマンドラインスイッチ（ &lt;code&gt;$^W&lt;/code&gt; 変数）が有効な場合に警告を引き出します。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6b1fabb50ebfaee65dd88358116ce7e544578fdb" translate="yes" xml:space="preserve">
          <source>In other cases, it is the program's responsibility to transform characters into bytes using the API above before doing writes, and to transform the bytes read from a handle into characters before doing &quot;character operations&quot; (e.g. &lt;code&gt;lc&lt;/code&gt;, &lt;code&gt;/\W+/&lt;/code&gt;, ...).</source>
          <target state="translated">その他の場合、書き込みを行う前に上記のAPIを使用して文字をバイトに変換し、「文字操作」を行う前にハンドルから読み取ったバイトを文字に変換するのはプログラムの責任です（たとえば、 &lt;code&gt;lc&lt;/code&gt; 、 &lt;code&gt;/\W+/&lt;/code&gt; 、.。 。）。</target>
        </trans-unit>
        <trans-unit id="633c40ae3272eb641ed90a2b64f933bcfc1ab4fa" translate="yes" xml:space="preserve">
          <source>In other cases, the patch will need more work or discussion. That will happen on the p5p list.</source>
          <target state="translated">他のケースでは、パッチはより多くの作業や議論を必要とするでしょう。それはp5pリストで行われます。</target>
        </trans-unit>
        <trans-unit id="c74f18e17145b68ed08eb57bab88ef99e0da3c9f" translate="yes" xml:space="preserve">
          <source>In other cases, the patch will need more work or discussion. You are encouraged to participate in the discussion and advocate for your patch. Sometimes your patch may get lost in the shuffle. It's appropriate to send a reminder email to p5p if no action has been taken in a month. Please remember that the Perl 5 developers are all volunteers, and be polite.</source>
          <target state="translated">他のケースでは、パッチはより多くの作業や議論を必要とするでしょう。議論に参加して、あなたのパッチを擁護することをお勧めします。時には、あなたのパッチは、シャッフルの中で迷子になってしまうかもしれません。1ヶ月間何のアクションも取られていない場合は、p5pにリマインダーメールを送るのが適切です。Perl 5 の開発者はすべてボランティアであることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="7b3796099c87e59fc24644465a4e8f63a8bac8d4" translate="yes" xml:space="preserve">
          <source>In other files which wish to use &lt;code&gt;YourModule&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;YourModule&lt;/code&gt; を使用したい他のファイル：</target>
        </trans-unit>
        <trans-unit id="3361910c0a44a8f06143bc3e2135d6b5df3e75a8" translate="yes" xml:space="preserve">
          <source>In other files which wish to use &lt;code&gt;YourModule&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;YourModule&lt;/code&gt; を使用したい他のファイル：</target>
        </trans-unit>
        <trans-unit id="3b8bb595443598bbfebd43734b72b246e5109db8" translate="yes" xml:space="preserve">
          <source>In other files which wish to use your module there are three basic ways for them to load your module and import its symbols:</source>
          <target state="translated">あなたのモジュールを使用したい他のファイルでは、モジュールをロードしてシンボルをインポートするための3つの基本的な方法があります。</target>
        </trans-unit>
        <trans-unit id="2a62d5a9fb2b01aecc3f16e0f5d8dbd83913e66d" translate="yes" xml:space="preserve">
          <source>In other words this returns TRUE if &lt;code&gt;s&lt;/code&gt; points to a partial UTF-8-encoded code point.</source>
          <target state="translated">言い換えると、 &lt;code&gt;s&lt;/code&gt; が部分的なUTF-8でエンコードされたコードポイントを指している場合、これはTRUEを返します。</target>
        </trans-unit>
        <trans-unit id="dac5b44cbcccec7c46874f1c0dae34c3e4179f83" translate="yes" xml:space="preserve">
          <source>In other words, a call to &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; resumes the depth-first, left-to-right search of &lt;code&gt;$self&lt;/code&gt; 's class hierarchy that resulted in the original call to &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">言い換えると、 &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; への呼び出しは、 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; への元の呼び出しをもたらした &lt;code&gt;$self&lt;/code&gt; のクラス階層の深さ優先、左から右への検索を再開します。</target>
        </trans-unit>
        <trans-unit id="43077ef64c7bdb380f466e9ffbd60672fc125c18" translate="yes" xml:space="preserve">
          <source>In other words, a call to &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; resumes the depth-first, left-to-right search of &lt;code&gt;$self&lt;/code&gt;'s class hierarchy that resulted in the original call to &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">つまり、 &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; を呼び出すと、深さ優先の左から右への &lt;code&gt;$self&lt;/code&gt; のクラス階層の検索が再開され、 &lt;code&gt;m&lt;/code&gt; が最初に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="fc23fa173938b1012fd5950a9ca473499f233be7" translate="yes" xml:space="preserve">
          <source>In other words, a phrasebook entry takes some values as parameters (the things that you fill in the blank or blanks), and provides a value based on these parameters, where the way you get that final value from the given values can, properly speaking, involve an arbitrarily complex series of operations. (In the case of Chinese, it'd be not at all complex, at least in cases like the examples at the beginning of this article; whereas in the case of Russian it'd be a rather complex series of operations. And in some languages, the complexity could be spread around differently: while the act of putting a number-expression in front of a noun phrase might not be complex by itself, it may change how you have to, for example, inflect a verb elsewhere in the sentence. This is what in syntax is called &quot;long-distance dependencies&quot;.)</source>
          <target state="translated">言い換えれば、フレーズブックのエントリはいくつかの値をパラメータ(空欄や空白を埋めるもの)として受け取り、これらのパラメータに基づいて値を提供します。(中国語の場合、少なくともこの記事の冒頭の例のようなケースでは、全く複雑ではありませんが、ロシア語の場合はかなり複雑な操作の連続です。また、いくつかの言語では、複雑さが異なる形で広がることもあります。名詞句の前に数式を置くという行為はそれ自体は複雑ではないかもしれませんが、それによって、例えば文中の他の場所で動詞を屈折させるなどの方法が変わることがあります。これを構文では「長距離依存関係」と呼んでいます)。</target>
        </trans-unit>
        <trans-unit id="a52dac3e16942362561bc185e3a6885901f3c2e9" translate="yes" xml:space="preserve">
          <source>In other words, do not &lt;code&gt;use encoding&lt;/code&gt; unless you are certain that the program will not deal with any raw, 8-bit binary data at all.</source>
          <target state="translated">つまり、プログラムが生の8ビットバイナリデータをまったく処理しないことが確実でない限り、 &lt;code&gt;use encoding&lt;/code&gt; ないでください。</target>
        </trans-unit>
        <trans-unit id="4828bb0cda42f406a7ca05570f3e0910c8f19571" translate="yes" xml:space="preserve">
          <source>In other words, each type of bracket specified as a delimiter must be balanced and correctly nested within the substring, and any other kind of (&quot;non-delimiter&quot;) bracket in the substring is ignored.</source>
          <target state="translated">言い換えれば、デリミタとして指定された各タイプの括弧は、バランスが取れていて、部分文字列の中に正しく入れ子になっていなければならず、部分文字列の中にある他の種類の括弧(「デリミタではない」)は無視されなければなりません。</target>
        </trans-unit>
        <trans-unit id="74fd5671e652ca312e8092bc1ce538f5b223a43a" translate="yes" xml:space="preserve">
          <source>In other words, if you try this:</source>
          <target state="translated">つまり、これをやってみると</target>
        </trans-unit>
        <trans-unit id="877ca893c0d0ee5563d6603bca839b1fc7617192" translate="yes" xml:space="preserve">
          <source>In other words, implicate_supers_strictly takes a list of strings (which are presumed to be language-tags; strings that aren't, are ignored) and after the whole given list, it inserts the super-ordinate forms of all given tags, minus any tags that already appear in the input list.</source>
          <target state="translated">言い換えれば、 implicate_supers_strictly は文字列のリスト(言語タグと推定され、言語タグでない文字列は無視されます)を受け取り、与えられたリスト全体の後に、与えられたすべてのタグの超従属形を挿入し、入力リストに既に現れているタグを除外します。</target>
        </trans-unit>
        <trans-unit id="25d319aebdebcd5625f4059cfe98447477589bac" translate="yes" xml:space="preserve">
          <source>In other words, in the &quot;C&quot; (or English) locale the above will probably print something like:</source>
          <target state="translated">つまり、&quot;C&quot; (または英語)のロケールでは、上記はおそらく次のように表示されるでしょう。</target>
        </trans-unit>
        <trans-unit id="550ff39ed161b9edd0e84b02fed3dec9d30c2e67" translate="yes" xml:space="preserve">
          <source>In other words, it does not check the full recursion stack.</source>
          <target state="translated">つまり、完全な再帰スタックをチェックしません。</target>
        </trans-unit>
        <trans-unit id="e0fc4bff9ab6a124fdea1a036cef443002eab13f" translate="yes" xml:space="preserve">
          <source>In other words, it takes this:</source>
          <target state="translated">つまり、これが必要なのです。</target>
        </trans-unit>
        <trans-unit id="9c65668195992fe68f06679feb8eacf4cd2f8800" translate="yes" xml:space="preserve">
          <source>In other words, it's the character whose code point has had 64 xor'd with its uppercase. &lt;code&gt;\c?&lt;/code&gt; is DELETE on ASCII platforms because &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;?&quot;) ^ 64&lt;/code&gt; is 127, and &lt;code&gt;\c@&lt;/code&gt; is NULL because the ord of &lt;code&gt;&quot;@&quot;&lt;/code&gt; is 64, so xor'ing 64 itself produces 0.</source>
          <target state="translated">言い換えると、コードポイントが64の大文字でxorされた文字です。 &lt;code&gt;\c?&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;(&quot;?&quot;) ^ 64&lt;/code&gt; は127であるため、ASCIIプラットフォームではDELETE です。 &lt;code&gt;&quot;@&quot;&lt;/code&gt; の ord は64であるため、 &lt;code&gt;\c@&lt;/code&gt; はNULL です。</target>
        </trans-unit>
        <trans-unit id="3b1f13df18bf646ce1ea690c89b90d0f23fa7742" translate="yes" xml:space="preserve">
          <source>In other words, it's the character whose code point has had 64 xor'd with its uppercase. &lt;code&gt;\c?&lt;/code&gt; is DELETE on ASCII platforms because &lt;code&gt;ord(&quot;?&quot;) ^ 64&lt;/code&gt; is 127, and &lt;code&gt;\c@&lt;/code&gt; is NULL because the ord of &lt;code&gt;&quot;@&quot;&lt;/code&gt; is 64, so xor'ing 64 itself produces 0.</source>
          <target state="translated">言い換えると、コードポイントが大文字で64xorされた文字です。 &lt;code&gt;\c?&lt;/code&gt; &lt;code&gt;ord(&quot;?&quot;) ^ 64&lt;/code&gt; は127であり、 &lt;code&gt;&quot;@&quot;&lt;/code&gt; のordは64であるため、 &lt;code&gt;\c@&lt;/code&gt; はNULLであるため、ASCIIプラットフォームではDELETEです。したがって、xor'ing64自体は0を生成します。</target>
        </trans-unit>
        <trans-unit id="2b7ead3432ce6ef0a214c631da3fb65f28ad59d4" translate="yes" xml:space="preserve">
          <source>In other words, it's the projection of the vector onto the</source>
          <target state="translated">言い換えれば、ベクトルの</target>
        </trans-unit>
        <trans-unit id="173982625284de4ecdaf57b42d11dd41503a3a62" translate="yes" xml:space="preserve">
          <source>In other words, once the &lt;code&gt;(*COMMIT)&lt;/code&gt; has been entered, and if the pattern does not match, the regex engine will not try any further matching on the rest of the string.</source>
          <target state="translated">つまり、 &lt;code&gt;(*COMMIT)&lt;/code&gt; が入力され、パターンが一致しない場合、正規表現エンジンは残りの文字列に対してそれ以上の一致を試みません。</target>
        </trans-unit>
        <trans-unit id="080def995649dc7c78c927509a6265da0f050d82" translate="yes" xml:space="preserve">
          <source>In other words, text outside bracket groups is turned into string literals. Text in brackets is rather more complex, and currently follows these rules:</source>
          <target state="translated">言い換えれば、大括弧グループの外のテキストは文字列リテラルに変換されます。大括弧内のテキストはより複雑で、現在はこれらのルールに従っています。</target>
        </trans-unit>
        <trans-unit id="f68e3679fc5753d52f8311d0156c23ac089d43c6" translate="yes" xml:space="preserve">
          <source>In other words, the Pod processing handler for &quot;head1&quot; will apply the same processing to &quot;Did You Remember to C&amp;lt;use strict;&amp;gt;?&quot; that it would to an ordinary paragraph (i.e., formatting codes like &quot;C&amp;lt;...&amp;gt;&quot;) are parsed and presumably formatted appropriately, and whitespace in the form of literal spaces and/or tabs is not significant.</source>
          <target state="translated">つまり、「head1」のポッド処理ハンドラは、「C &amp;lt;use strict;&amp;gt;を覚えていますか？」にも同じ処理を適用します。通常の段落（つまり、「C &amp;lt;...&amp;gt;」のようなフォーマットコード）が解析され、おそらく適切にフォーマットされ、リテラルスペースやタブの形式の空白は重要ではありません。</target>
        </trans-unit>
        <trans-unit id="d0443748797b84576038c7f78a4ac322e4d4dc07" translate="yes" xml:space="preserve">
          <source>In other words, the author of a module should be considered to have final say on modifications to their module whenever possible (bearing in mind that it's expected that everyone involved will work together and arrive at reasonable compromises when there are disagreements).</source>
          <target state="translated">言い換えれば、モジュールの作成者は、可能な限りモジュールの修正について最終的な意見を持つべきであると考えられています (関係者全員が協力し、意見の相違があった場合には合理的な妥協点に到達することが期待されていることを念頭に置いてください)。</target>
        </trans-unit>
        <trans-unit id="585a94d48c61cb81b39fc84dfe81f19ca97413b7" translate="yes" xml:space="preserve">
          <source>In other words, the implementation of &lt;code&gt;extract_tagged&lt;/code&gt; is exactly equivalent to:</source>
          <target state="translated">言い換えると、 &lt;code&gt;extract_tagged&lt;/code&gt; の実装は次とまったく同じです。</target>
        </trans-unit>
        <trans-unit id="6437ac2d46829a1156ddedffd3475d352ba0e256" translate="yes" xml:space="preserve">
          <source>In other words, the previous example, would become:</source>
          <target state="translated">つまり、先ほどの例では、こうなります。</target>
        </trans-unit>
        <trans-unit id="bb35ba757de61444a9e16187e2167074637a80ae" translate="yes" xml:space="preserve">
          <source>In other words, the two zero-width assertions next to each other work as though they're ANDed together, just as you'd use any built-in assertions: &lt;code&gt;/^$/&lt;/code&gt; matches only if you're at the beginning of the line AND the end of the line simultaneously. The deeper underlying truth is that juxtaposition in regular expressions always means AND, except when you write an explicit OR using the vertical bar. &lt;code&gt;/ab/&lt;/code&gt; means match &quot;a&quot; AND (then) match &quot;b&quot;, although the attempted matches are made at different positions because &quot;a&quot; is not a zero-width assertion, but a one-width assertion.</source>
          <target state="translated">言い換えれば、2つのゼロ幅アサーションは、お互いの仕事の隣に、彼らはあなたが使用したいと同じように、一緒にAND演算しているかのように任意のビルトインアサーション： &lt;code&gt;/^$/&lt;/code&gt; あなたが最初にしている場合にのみマッチ行と行の終わりを同時に。より深い根本的な真実は、垂直バーを使用して明示的なORを書く場合を除いて、正規表現の並列は常にANDを意味するということです。 &lt;code&gt;/ab/&lt;/code&gt; は、「a」と一致することを意味し、「a」は「b」と一致しますが、「a」は幅がゼロのアサーションではなく、幅が1つのアサーションであるため、異なる位置で一致が試みられます。</target>
        </trans-unit>
        <trans-unit id="b22de3fc0445ea5201a62f3ef67fff0c1b919420" translate="yes" xml:space="preserve">
          <source>In other words, the version will be automatically parsed out of the string, and it will be quoted to preserve the meaning CVS normally carries for versions. The CVS $Revision$ increments differently from Decimal versions (i.e. 1.10 follows 1.9), so it must be handled as if it were a Dotted-Decimal Version.</source>
          <target state="translated">言い換えれば、バージョンは自動的に文字列から解析され、CVSが通常バージョンのために運ぶ意味を維持するために引用符で囲まれます。CVS の $Revision$ は Decimal バージョンとは異なるインクリメントをします (例:1.9 の後に 1.10 が続く)ので、Dotted-Decimal バージョンのように扱わなければなりません。</target>
        </trans-unit>
        <trans-unit id="459d5640fff6f70049a1cb4e21dd9d95f811c50c" translate="yes" xml:space="preserve">
          <source>In other words, this is valid:</source>
          <target state="translated">つまり、これは有効です。</target>
        </trans-unit>
        <trans-unit id="b1e37082db8f86fab9970e0f78a995b4a26a2a25" translate="yes" xml:space="preserve">
          <source>In other words, you can write:</source>
          <target state="translated">つまり、書けばいいのです。</target>
        </trans-unit>
        <trans-unit id="8aa186b5e0e574c2c9765bd09cdce944830c9ba2" translate="yes" xml:space="preserve">
          <source>In other words: regardless of platform, use &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; on binary data, like images, for example.</source>
          <target state="translated">言い換えると、プラットフォームに関係なく、たとえば画像などのバイナリデータで&lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="760e520ac926fbcbcf184f0f289efd734964ab6f" translate="yes" xml:space="preserve">
          <source>In other words: regardless of platform, use binmode() on binary data, like images, for example.</source>
          <target state="translated">言い換えれば、プラットフォームに関係なく、例えば画像のようなバイナリデータではbinmode()を使用してください。</target>
        </trans-unit>
        <trans-unit id="9c34e83f6eab1310b3613a944eb5e27cd7e611dd" translate="yes" xml:space="preserve">
          <source>In other words: replace &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; DynaLoader&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; , remove &lt;code&gt;DynaLoader&lt;/code&gt; from &lt;code&gt;@ISA&lt;/code&gt; , change &lt;code&gt;bootstrap&lt;/code&gt; by &lt;code&gt;XSLoader::load&lt;/code&gt; . Do not forget to quote the name of your package on the &lt;code&gt;XSLoader::load&lt;/code&gt; line, and add comma (&lt;code&gt;,&lt;/code&gt; ) before the arguments (&lt;code&gt;$VERSION&lt;/code&gt; above).</source>
          <target state="translated">言い換えれば、交換する &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; DynaLoader&lt;/code&gt; することにより &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; 、削除 &lt;code&gt;DynaLoader&lt;/code&gt; やから &lt;code&gt;@ISA&lt;/code&gt; 、変更の &lt;code&gt;bootstrap&lt;/code&gt; によって &lt;code&gt;XSLoader::load&lt;/code&gt; 。 &lt;code&gt;XSLoader::load&lt;/code&gt; 行でパッケージの名前を引用し、引数（上記の &lt;code&gt;$VERSION&lt;/code&gt; ）の前にコンマ（ &lt;code&gt;,&lt;/code&gt; ）を追加することを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="4b5c137fe49cb774422851c667c514342acdc0cc" translate="yes" xml:space="preserve">
          <source>In other words: replace &lt;code&gt;require DynaLoader&lt;/code&gt; by &lt;code&gt;use XSLoader&lt;/code&gt;, remove &lt;code&gt;DynaLoader&lt;/code&gt; from &lt;code&gt;@ISA&lt;/code&gt;, change &lt;code&gt;bootstrap&lt;/code&gt; by &lt;code&gt;XSLoader::load&lt;/code&gt;. Do not forget to quote the name of your package on the &lt;code&gt;XSLoader::load&lt;/code&gt; line, and add comma (&lt;code&gt;,&lt;/code&gt;) before the arguments (&lt;code&gt;$VERSION&lt;/code&gt; above).</source>
          <target state="translated">言い換えると、 &lt;code&gt;require DynaLoader&lt;/code&gt; をXSLoaderを &lt;code&gt;use XSLoader&lt;/code&gt; 、 &lt;code&gt;DynaLoader&lt;/code&gt; を &lt;code&gt;@ISA&lt;/code&gt; から削除し、 &lt;code&gt;bootstrap&lt;/code&gt; を &lt;code&gt;XSLoader::load&lt;/code&gt; で変更します。 &lt;code&gt;XSLoader::load&lt;/code&gt; 行でパッケージの名前を引用することを忘れないでください。また、引数の前にコンマ（ &lt;code&gt;,&lt;/code&gt; ）を追加してください（上記の &lt;code&gt;$VERSION&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cc33d1c173d87ad8a862029ec4420d308b38832f" translate="yes" xml:space="preserve">
          <source>In our case, Mytest.pm tells perl that it will need the Exporter and Dynamic Loader extensions. It then sets the &lt;code&gt;@ISA&lt;/code&gt; and &lt;code&gt;@EXPORT&lt;/code&gt; arrays and the &lt;code&gt;$VERSION&lt;/code&gt; scalar; finally it tells perl to bootstrap the module. Perl will call its dynamic loader routine (if there is one) and load the shared library.</source>
          <target state="translated">私たちのケースでは、Mytest.pmはperlにExporterおよびDynamic Loader拡張機能が必要になることを伝えています。その後、設定し &lt;code&gt;@ISA&lt;/code&gt; と &lt;code&gt;@EXPORT&lt;/code&gt; 配列と &lt;code&gt;$VERSION&lt;/code&gt; スカラを、最後に、perlにモジュールをブートストラップするように指示します。Perlは、動的ローダールーチン（存在する場合）を呼び出し、共有ライブラリをロードします。</target>
        </trans-unit>
        <trans-unit id="a50979678185f172c0b3a9e65775a69eef6dc7e9" translate="yes" xml:space="preserve">
          <source>In our example there is no reason to implement this method, so we leave it as a no-op. This method is only relevant to tied array implementations where there is the possibility of having the allocated size of the array be larger than is visible to a perl programmer inspecting the size of the array. Many tied array implementations will have no reason to implement it.</source>
          <target state="translated">この例では、このメソッドを実装する理由はありません。このメソッドは、配列のサイズを検査しているPerlプログラマが見えるサイズよりも、配列の割り当てられたサイズが大きくなる可能性がある場合にのみ、紐付き配列の実装に関係します。多くの縛り配列の実装では、このメソッドを実装する理由がありません。</target>
        </trans-unit>
        <trans-unit id="92b4893cf24b728e0fae1966639d9078e63fc3f7" translate="yes" xml:space="preserve">
          <source>In our example we can just call &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; on the underlying hash referenced by &lt;code&gt;$self-&amp;gt;{LIST}&lt;/code&gt; :</source>
          <target state="translated">この例では、 &lt;code&gt;$self-&amp;gt;{LIST}&lt;/code&gt; によって参照される基礎となるハッシュで &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; を呼び出すだけです。</target>
        </trans-unit>
        <trans-unit id="fb7cff901b6f0144e1ee9b6dc1a0e390ab74d831" translate="yes" xml:space="preserve">
          <source>In our example we can just call &lt;code&gt;scalar&lt;/code&gt; on the underlying hash referenced by &lt;code&gt;$self-&amp;gt;{LIST}&lt;/code&gt;:</source>
          <target state="translated">この例では、 &lt;code&gt;$self-&amp;gt;{LIST}&lt;/code&gt; によって参照される基になるハッシュで &lt;code&gt;scalar&lt;/code&gt; を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="bc1f779d9a34032474fc9a65f77cb8d2776cbce1" translate="yes" xml:space="preserve">
          <source>In our example we're going to create a shouting handle.</source>
          <target state="translated">この例では、シャウトハンドルを作成します。</target>
        </trans-unit>
        <trans-unit id="a13dbabebbc5437dccc50e5be8ddf3c33a642ee8" translate="yes" xml:space="preserve">
          <source>In our example, 'undef' is really an element containing &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; number of spaces. Observe:</source>
          <target state="translated">この例では、「undef」は実際には &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; 個のスペースを含む要素です。観察する：</target>
        </trans-unit>
        <trans-unit id="aabcb2149f4617fcf7efa6bbc92a17b687ef3353" translate="yes" xml:space="preserve">
          <source>In our example, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is really &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; number of spaces so we have a little more work to do here:</source>
          <target state="translated">この例では、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; は実際には &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; のスペース数であるため、ここで行う作業が少し増えます。</target>
        </trans-unit>
        <trans-unit id="d967da8f9ad72b6996f76cb7869dbad1f32de0ee" translate="yes" xml:space="preserve">
          <source>In our example, &lt;code&gt;undef&lt;/code&gt; is really &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; number of spaces so we have a little more work to do here:</source>
          <target state="translated">この例では、 &lt;code&gt;undef&lt;/code&gt; は実際には &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; のスペース数であるため、ここで行う作業がもう少しあります。</target>
        </trans-unit>
        <trans-unit id="1f1787ee08eebed75ede8020208e3ff9eccca1a6" translate="yes" xml:space="preserve">
          <source>In our example, a deleted item is &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; spaces:</source>
          <target state="translated">この例では、削除されたアイテムは &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; スペースです。</target>
        </trans-unit>
        <trans-unit id="91424799b59a91080c214218f5e7f8c9b0b084d8" translate="yes" xml:space="preserve">
          <source>In our example, just to show you that you don't</source>
          <target state="translated">私たちの例では、あなたがしないことを示すためだけに</target>
        </trans-unit>
        <trans-unit id="11b35d0e0b09647c243a787b95c24ae27233aecd" translate="yes" xml:space="preserve">
          <source>In our example, that would remove all the user's dot files! It's such a dangerous thing that they'll have to set CLOBBER to something higher than 1 to make it happen.</source>
          <target state="translated">私たちの例では、それはユーザーのドットファイルをすべて削除することになります CLOBBERを1よりも高い値に設定しなければならないほど危険なことなのです。</target>
        </trans-unit>
        <trans-unit id="8f92d427a1809586b396dc516bf348aaa08bbed7" translate="yes" xml:space="preserve">
          <source>In our example, we want to make sure there are no blank (&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) entries, so &lt;code&gt;EXTEND&lt;/code&gt; will make use of &lt;code&gt;STORESIZE&lt;/code&gt; to fill elements as needed:</source>
          <target state="translated">この例では、空白（ &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ）のエントリがないことを確認したいので、 &lt;code&gt;EXTEND&lt;/code&gt; は &lt;code&gt;STORESIZE&lt;/code&gt; を使用して、必要に応じて要素を入力します。</target>
        </trans-unit>
        <trans-unit id="24d1f4e04fd957695cb0fc036193c59fca0468cd" translate="yes" xml:space="preserve">
          <source>In our example, we will determine that if an element consists of &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; spaces only, it does not exist:</source>
          <target state="translated">この例では、要素が &lt;code&gt;$self-&amp;gt;{ELEMSIZE}&lt;/code&gt; スペースのみで構成されている場合は存在しないと判断します。</target>
        </trans-unit>
        <trans-unit id="9241072dd02f63704e06d0e4788fd47ef3eca294" translate="yes" xml:space="preserve">
          <source>In our example, we'll use a little shortcut if there is a</source>
          <target state="translated">この例では、ちょっとしたショートカットで</target>
        </trans-unit>
        <trans-unit id="6a2c73ee683cc447274fd115e41a8a6212c0860c" translate="yes" xml:space="preserve">
          <source>In our intranet, we have many modules for internal use. How can I integrate these modules with CPAN.pm but without uploading the modules to CPAN?</source>
          <target state="translated">私たちのイントラネットには、社内で使用するためのモジュールがたくさんあります。これらのモジュールをCPAN.pmと統合しますが、CPANにモジュールをアップロードすることなく統合するにはどうすればよいでしょうか?</target>
        </trans-unit>
        <trans-unit id="e3d33b8a8cd9ee1cbb39097ccf83087f357647e8" translate="yes" xml:space="preserve">
          <source>In our tied hash DotFiles example, we use a regular hash for the object containing several important fields, of which only the &lt;code&gt;{LIST}&lt;/code&gt; field will be what the user thinks of as the real hash.</source>
          <target state="translated">紐付けされたハッシュDotFilesの例では、いくつかの重要なフィールドを含むオブジェクトに通常のハッシュを使用します。このうち &lt;code&gt;{LIST}&lt;/code&gt; フィールドのみが、ユーザーが実際のハッシュと見なすものになります。</target>
        </trans-unit>
        <trans-unit id="07709450f49a2785357dceda9bbcd6e033ef5380" translate="yes" xml:space="preserve">
          <source>In paragraphs where formatting codes (like E&amp;lt;...&amp;gt;, B&amp;lt;...&amp;gt;) are understood (i.e.,</source>
          <target state="translated">書式コード（E &amp;lt;...&amp;gt;、B &amp;lt;...&amp;gt;など）が理解される段落（つまり、</target>
        </trans-unit>
        <trans-unit id="fb0742f46f732e81f9ef6b26f9dd077a50514538" translate="yes" xml:space="preserve">
          <source>In parsing Pod, a notably tricky part is the correct parsing of (potentially nested!) formatting codes. Implementors should consult the code in the &lt;code&gt;parse_text&lt;/code&gt; routine in Pod::Parser as an example of a correct implementation.</source>
          <target state="translated">ポッドの解析で特に注意が必要なのは、（潜在的にネストされている！）書式コードの正しい解析です。実装者は、正しい実装の例として、Pod :: Parserの &lt;code&gt;parse_text&lt;/code&gt; ルーチンのコードを調べる必要があります。</target>
        </trans-unit>
        <trans-unit id="e44b2915e9ebcfa80eaf0cd0b8fc6a537b378a7a" translate="yes" xml:space="preserve">
          <source>In parsing an L&amp;lt;...&amp;gt; code, Pod parsers must distinguish at least four attributes:</source>
          <target state="translated">L &amp;lt;...&amp;gt;コードの解析では、ポッドパーサーは少なくとも4つの属性を区別する必要があります。</target>
        </trans-unit>
        <trans-unit id="173ae1b4c7abf280ed9de2a2e4233e82968c1ade" translate="yes" xml:space="preserve">
          <source>In parsing these constructs, Perl always ignores Upper/lower case differences everywhere within the {braces}. Thus &lt;code&gt;\p{Greek}&lt;/code&gt; means the same thing as &lt;code&gt;\p{greek}&lt;/code&gt; . But note that changing the case of the &lt;code&gt;&quot;p&quot;&lt;/code&gt; or &lt;code&gt;&quot;P&quot;&lt;/code&gt; before the left brace completely changes the meaning of the construct, from &quot;match&quot; (for &lt;code&gt;\p{}&lt;/code&gt; ) to &quot;doesn't match&quot; (for &lt;code&gt;\P{}&lt;/code&gt; ). Casing in this document is for improved legibility.</source>
          <target state="translated">これらの構文を解析する際、Perlは常に{中括弧}内のすべての場所で大文字と小文字の違いを無視します。したがって、 &lt;code&gt;\p{Greek}&lt;/code&gt; は &lt;code&gt;\p{greek}&lt;/code&gt; と同じことを意味します。ただし、左中括弧の前に &lt;code&gt;&quot;p&quot;&lt;/code&gt; または &lt;code&gt;&quot;P&quot;&lt;/code&gt; の大文字と小文字を変更すると、構成の意味が「一致」（ &lt;code&gt;\p{}&lt;/code&gt; ）から「一致しない」（ &lt;code&gt;\P{}&lt;/code&gt; 場合）に完全に変わることに注意してください。}）。このドキュメントのケーシングは、読みやすさを向上させるためのものです。</target>
        </trans-unit>
        <trans-unit id="567197a99a2b6b0fd77102ccbee0d1f2509d1634" translate="yes" xml:space="preserve">
          <source>In parsing these constructs, Perl always ignores Upper/lower case differences everywhere within the {braces}. Thus &lt;code&gt;\p{Greek}&lt;/code&gt; means the same thing as &lt;code&gt;\p{greek}&lt;/code&gt;. But note that changing the case of the &lt;code&gt;&quot;p&quot;&lt;/code&gt; or &lt;code&gt;&quot;P&quot;&lt;/code&gt; before the left brace completely changes the meaning of the construct, from &quot;match&quot; (for &lt;code&gt;\p{}&lt;/code&gt;) to &quot;doesn't match&quot; (for &lt;code&gt;\P{}&lt;/code&gt;). Casing in this document is for improved legibility.</source>
          <target state="translated">これらの構造を解析する際、Perlは{中括弧}内のすべての場所で大文字と小文字の違いを常に無視します。したがって、 &lt;code&gt;\p{Greek}&lt;/code&gt; は &lt;code&gt;\p{greek}&lt;/code&gt; と同じ意味です。ただし、左中括弧の前の &lt;code&gt;&quot;p&quot;&lt;/code&gt; または &lt;code&gt;&quot;P&quot;&lt;/code&gt; の大文字と小文字を変更すると、構成の意味が「一致」（ &lt;code&gt;\p{}&lt;/code&gt; ）から「一致しない」（ &lt;code&gt;\P{}&lt;/code&gt; 場合）に完全に変更されることに注意してください。}）。このドキュメントのケーシングは、読みやすさを向上させるためのものです。</target>
        </trans-unit>
        <trans-unit id="9aaf8e25ca7ca9dd8d4b03a35ad6a47a7f371c04" translate="yes" xml:space="preserve">
          <source>In particular</source>
          <target state="translated">特に</target>
        </trans-unit>
        <trans-unit id="2f4b20effb603658d4594f20068f3202a019f207" translate="yes" xml:space="preserve">
          <source>In particular have a hunt around for the following:</source>
          <target state="translated">特に以下のような狩りをしています。</target>
        </trans-unit>
        <trans-unit id="549a73d37bd647b3d02bdfb1ed4587a94e6c791c" translate="yes" xml:space="preserve">
          <source>In particular the following metacharacters have their standard</source>
          <target state="translated">特に以下のメタキャラクタには、その標準的な</target>
        </trans-unit>
        <trans-unit id="d9ca3d8c112df43cded72f31c7db395214aede20" translate="yes" xml:space="preserve">
          <source>In particular,</source>
          <target state="translated">特に</target>
        </trans-unit>
        <trans-unit id="ef80eb5daee93a0d4fde8126fc49aefdc4e89c82" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;Tie::File&lt;/code&gt; will</source>
          <target state="translated">特に、 &lt;code&gt;Tie::File&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="2db3c0671aba0d3ee80c31fffb1da43c83f4160e" translate="yes" xml:space="preserve">
          <source>In particular, braces do not need to be balanced:</source>
          <target state="translated">特に、歯列矯正はバランスをとる必要はありません。</target>
        </trans-unit>
        <trans-unit id="2cbf0bbf93ed5b0e470ae4c77978f151618da6e4" translate="yes" xml:space="preserve">
          <source>In particular, follow these general guidelines for patching Perl sources:</source>
          <target state="translated">特に、Perl のソースにパッチを当てる際には、以下の一般的なガイドラインに従ってください。</target>
        </trans-unit>
        <trans-unit id="588a69fc1734910196fa33dcc3398592c9c2b486" translate="yes" xml:space="preserve">
          <source>In particular, if you are using Info-Zip you need to have zip version 3.x or better to update a Zip64 archive and unzip version 6.x to read a zip64 archive.</source>
          <target state="translated">特に、Info-Zipを使用している場合、Zip64アーカイブを更新するにはZipバージョン3.x以上、Zip64アーカイブを読み込むにはZipバージョン6.x以上が必要です。</target>
        </trans-unit>
        <trans-unit id="b8504eca27d4d7dd980e055d06368ef344507bf5" translate="yes" xml:space="preserve">
          <source>In particular, if you opened the pipe using &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; , then you cannot simply use close() in the parent process to close an unwanted writer. Consider this code:</source>
          <target state="translated">特に、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; を使用してパイプを開いた場合、親プロセスでclose（）を使用して不要なライターを閉じることはできません。このコードを考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="617f0768594e1a999044d2a759bf8abcc2e11a58" translate="yes" xml:space="preserve">
          <source>In particular, if you opened the pipe using &lt;code&gt;open $fh, &quot;|-&quot;&lt;/code&gt;, then you cannot simply use close() in the parent process to close an unwanted writer. Consider this code:</source>
          <target state="translated">特に、 &lt;code&gt;open $fh, &quot;|-&quot;&lt;/code&gt; を使用してパイプを開いた場合、親プロセスで単にclose（）を使用して、不要なライターを閉じることはできません。このコードを検討してください：</target>
        </trans-unit>
        <trans-unit id="55f883bf0e56efd410000618d8c0d414be5f0032" translate="yes" xml:space="preserve">
          <source>In particular, it is not possible to write general-purpose classes in this technique, classes that can advertise themselves as &quot;Put me on your @ISA list and use my methods&quot;. If the other class has different ideas about how the object body is used, there is trouble.</source>
          <target state="translated">特に、この手法では汎用クラスを書くことはできません。&quot;私をあなたの@ISAリストに入れて、私のメソッドを使ってください &quot;と自己PRできるクラス。オブジェクトボディの使い方について、相手のクラスの考え方が違うとトラブルが発生します。</target>
        </trans-unit>
        <trans-unit id="03344b04b4c0d7615be3556f843e83b5fe66f49c" translate="yes" xml:space="preserve">
          <source>In particular, matches in the Block property have single forms defined by Perl that begin with &lt;code&gt;&quot;In_&quot;&lt;/code&gt;, &lt;code&gt;&quot;Is_&lt;/code&gt;, or even with no prefix at all, Like all &lt;b&gt;DISCOURAGED&lt;/b&gt; forms, these are not stable. For example, &lt;code&gt;\p{Block=Deseret}&lt;/code&gt; can currently be written as &lt;code&gt;\p{In_Deseret}&lt;/code&gt;, &lt;code&gt;\p{Is_Deseret}&lt;/code&gt;, or &lt;code&gt;\p{Deseret}&lt;/code&gt;. But, a new Unicode version may come along that would force Perl to change the meaning of one or more of these, and your program would no longer be correct. Currently there are no such conflicts with the form that begins &lt;code&gt;&quot;In_&quot;&lt;/code&gt;, but there are many with the other two shortcuts, and Unicode continues to define new properties that begin with &lt;code&gt;&quot;In&quot;&lt;/code&gt;, so it's quite possible that a conflict will occur in the future. The compound form is guaranteed to not become obsolete, and its meaning is clearer anyway. See &lt;a href=&quot;perlunicode#Blocks&quot;&gt;&quot;Blocks&quot; in perlunicode&lt;/a&gt; for more information about this.</source>
          <target state="translated">特に、Blockプロパティの一致には、 &lt;code&gt;&quot;In_&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;Is_&lt;/code&gt; 、またはプレフィックスがまったくない、Perlによって定義された単一のフォームがあります。すべての&lt;b&gt;DISCOURAGED&lt;/b&gt;フォームと同様に、これらは安定していません。たとえば、 &lt;code&gt;\p{Block=Deseret}&lt;/code&gt; は現在、 &lt;code&gt;\p{In_Deseret}&lt;/code&gt; 、 &lt;code&gt;\p{Is_Deseret}&lt;/code&gt; 、または &lt;code&gt;\p{Deseret}&lt;/code&gt; と書くことができます。しかし、Perlにこれらの1つ以上の意味を変更させる新しいUnicodeバージョンが登場する可能性があります。現在、 &lt;code&gt;&quot;In_&quot;&lt;/code&gt; で始まるフォームとの競合はありませんが、他の2つのショートカットとの競合は多く、Unicodeは引き続き「In_」で始まる新しいプロパティを定義します。 &lt;code&gt;&quot;In&quot;&lt;/code&gt; なので、将来的に競合が発生する可能性があります。複合形式は時代遅れにならないことが保証されており、その意味はとにかく明確です。詳細について&lt;a href=&quot;perlunicode#Blocks&quot;&gt;は、perlunicodeの「ブロック」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2fd11e0201dc297df1cba370809db0d5939f0ec0" translate="yes" xml:space="preserve">
          <source>In particular, the extensions &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt; and &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode::Normalize&lt;/a&gt; are not supported under EBCDIC; likewise for the (now deprecated) &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; pragma.</source>
          <target state="translated">特に、拡張&lt;a href=&quot;unicode/collate&quot;&gt;Unicode :: Collat​​e&lt;/a&gt;および&lt;a href=&quot;unicode/normalize&quot;&gt;Unicode :: Normalize&lt;/a&gt;はEBCDICではサポートされていません。同様に（現在は非推奨）&lt;a href=&quot;encoding&quot;&gt;エンコーディング&lt;/a&gt;プラグマ。</target>
        </trans-unit>
        <trans-unit id="b491336832fe24926f813912697f1c74d79ed48d" translate="yes" xml:space="preserve">
          <source>In particular, the special &lt;code&gt;${^_XYZ}&lt;/code&gt; variables are always taken to be in package &lt;code&gt;main&lt;/code&gt; , regardless of any &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; declarations presently in scope.</source>
          <target state="translated">特に、現在スコープ内にある &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 宣言に関係なく、特別な &lt;code&gt;${^_XYZ}&lt;/code&gt; 変数は常にパッケージ &lt;code&gt;main&lt;/code&gt; にあると見なされます。</target>
        </trans-unit>
        <trans-unit id="8a1a5cc8fc75fe5ee962a5cf753fa9e49875cad8" translate="yes" xml:space="preserve">
          <source>In particular, the special &lt;code&gt;${^_XYZ}&lt;/code&gt; variables are always taken to be in package &lt;code&gt;main&lt;/code&gt;, regardless of any &lt;code&gt;package&lt;/code&gt; declarations presently in scope.</source>
          <target state="translated">特に、特別な &lt;code&gt;${^_XYZ}&lt;/code&gt; 変数は、現在スコープ内にある &lt;code&gt;package&lt;/code&gt; 宣言に関係なく、常にパッケージ &lt;code&gt;main&lt;/code&gt; にあると見なされます。</target>
        </trans-unit>
        <trans-unit id="5adbc38d169db3c0edbc488274012a781b34d025" translate="yes" xml:space="preserve">
          <source>In particular, this API does &lt;b&gt;not&lt;/b&gt; provide the following functions:</source>
          <target state="translated">特に、このAPIは次の機能を提供しませ&lt;b&gt;ん&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="26d259999f6bd5eabc0e32bc92fd018cffcba101" translate="yes" xml:space="preserve">
          <source>In particular, this is applicable to the structure of &lt;code&gt;@INC&lt;/code&gt; used for testing not-yet-installed extensions. This means that running uninstalled extensions may have much more overhead than running the same extensions after &lt;code&gt;make install&lt;/code&gt; .</source>
          <target state="translated">特に、これは、まだインストールされていない拡張機能のテストに使用される &lt;code&gt;@INC&lt;/code&gt; の構造に適用されます。つまり、アンインストールされた拡張機能を実行すると、 &lt;code&gt;make install&lt;/code&gt; 後に同じ拡張機能を実行するよりもオーバーヘッドが大きくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="1aaa91f92ed68961c96b411d0f088a1a8511e37d" translate="yes" xml:space="preserve">
          <source>In particular, this is applicable to the structure of &lt;code&gt;@INC&lt;/code&gt; used for testing not-yet-installed extensions. This means that running uninstalled extensions may have much more overhead than running the same extensions after &lt;code&gt;make install&lt;/code&gt;.</source>
          <target state="translated">特に、これは、まだインストールされていない拡張機能のテストに使用される &lt;code&gt;@INC&lt;/code&gt; の構造に当てはまります。アンインストールの拡張機能を実行すると、はるか頭上同じ拡張子を実行するよりも後に持っていることが、この手段 &lt;code&gt;make install&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="da2e58986eb4f3be556785c248e50c152e1a4485" translate="yes" xml:space="preserve">
          <source>In particular, this means that you shouldn't use this for selecting between two aggregates for assignment:</source>
          <target state="translated">特に、これは、割り当てのために2つのアグリゲートの間で選択するために使用するべきではないことを意味します。</target>
        </trans-unit>
        <trans-unit id="6b654969e8b0fb9bedec078843fc01697a0cd123" translate="yes" xml:space="preserve">
          <source>In particular:</source>
          <target state="translated">特に</target>
        </trans-unit>
        <trans-unit id="f7e08b6bdc00b0694ecd1bf1d445c34c08eeec2b" translate="yes" xml:space="preserve">
          <source>In patterns where the text of the code is derived from run-time information rather than appearing literally in a source code /pattern/, the code is compiled at the same time that the pattern is compiled, and for reasons of security, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; must be in scope. This is to stop user-supplied patterns containing code snippets from being executable.</source>
          <target state="translated">コードのテキストが文字どおりソースコード/ pattern /に表示されるのではなく、ランタイム情報から派生するパターンでは、コードはパターンのコンパイルと同時にコンパイルされ &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; セキュリティ上の理由から、re 'を使用します。 eval 'はスコープ内にある必要があります。これは、コードスニペットを含むユーザー指定のパターンが実行可能にならないようにするためです。</target>
        </trans-unit>
        <trans-unit id="e276d91a0e58a0322954e2290f2d425e6220be43" translate="yes" xml:space="preserve">
          <source>In patterns where the text of the code is derived from run-time information rather than appearing literally in a source code /pattern/, the code is compiled at the same time that the pattern is compiled, and for reasons of security, &lt;code&gt;use re 'eval'&lt;/code&gt; must be in scope. This is to stop user-supplied patterns containing code snippets from being executable.</source>
          <target state="translated">コードのテキストがソースコード/ pattern /に文字通り表示されるのではなく、実行時情報から派生するパターンでは、コードはパターンのコンパイルと同時にコンパイルされ &lt;code&gt;use re 'eval'&lt;/code&gt; セキュリティ上の理由から、re 'を使用してください。 eval 'はスコープ内にある必要があります。これは、コードスニペットを含むユーザー指定のパターンが実行可能になるのを防ぐためです。</target>
        </trans-unit>
        <trans-unit id="1ea88d26430c6d46158be27b80e4634d3a9d07c0" translate="yes" xml:space="preserve">
          <source>In perl 5.14 and higher, on systems other than Windows that do not support the &lt;code&gt;fchdir&lt;/code&gt; C function, directory handles (see &lt;a href=&quot;functions/opendir&quot;&gt;opendir DIRHANDLE,EXPR&lt;/a&gt;) will not be copied to new threads. You can use the &lt;code&gt;d_fchdir&lt;/code&gt; variable in &lt;a href=&quot;config&quot;&gt;Config.pm&lt;/a&gt; to determine whether your system supports it.</source>
          <target state="translated">perl 5.14以降では、 &lt;code&gt;fchdir&lt;/code&gt; C関数をサポートしていないWindows以外のシステムでは、ディレクトリハンドル（&lt;a href=&quot;functions/opendir&quot;&gt;opendir DIRHANDLE、EXPRを&lt;/a&gt;参照）は新しいスレッドにコピーされません。&lt;a href=&quot;config&quot;&gt;Config.pm&lt;/a&gt;の &lt;code&gt;d_fchdir&lt;/code&gt; 変数を使用して、システムがそれをサポートしているかどうかを判断できます。</target>
        </trans-unit>
        <trans-unit id="75d927412f420eb0f10ead4e75910cbe7eab7430" translate="yes" xml:space="preserve">
          <source>In perl 5.14 and higher, on systems other than Windows that do not support the &lt;code&gt;fchdir&lt;/code&gt; C function, directory handles (see &lt;a href=&quot;perlfunc#opendir-DIRHANDLE%2CEXPR&quot;&gt;opendir&lt;/a&gt;) will not be copied to new threads. You can use the &lt;code&gt;d_fchdir&lt;/code&gt; variable in &lt;a href=&quot;config&quot;&gt;Config.pm&lt;/a&gt; to determine whether your system supports it.</source>
          <target state="translated">perl 5.14以降では、 &lt;code&gt;fchdir&lt;/code&gt; C関数をサポートしていないWindows以外のシステムでは、ディレクトリハンドル（&lt;a href=&quot;perlfunc#opendir-DIRHANDLE%2CEXPR&quot;&gt;opendirを&lt;/a&gt;参照）は新しいスレッドにコピーされません。&lt;a href=&quot;config&quot;&gt;Config.pm&lt;/a&gt;の &lt;code&gt;d_fchdir&lt;/code&gt; 変数を使用して、システムがそれをサポートしているかどうかを判断できます。</target>
        </trans-unit>
        <trans-unit id="978dbedfe97270c6d04770e8f1b09ed5adf8e8d1" translate="yes" xml:space="preserve">
          <source>In perl 5.8.0, &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; was also used to mark placeholders in restricted hashes. This caused such hash entries not to appear when iterating over the hash or when checking for the keys with the &lt;code&gt;hv_exists&lt;/code&gt; function.</source>
          <target state="translated">perl 5.8.0では、 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; は制限付きハッシュのプレースホルダーをマークするためにも使用されました。これにより、ハッシュを反復するとき、または &lt;code&gt;hv_exists&lt;/code&gt; 関数でキーをチェックするときに、そのようなハッシュエントリが表示されなくなりました。</target>
        </trans-unit>
        <trans-unit id="e2d10ca79661f6cd0c4cfd21cf2e8aa0ee582a6a" translate="yes" xml:space="preserve">
          <source>In perl 5.8.1 and later, Test::Builder is thread-safe. The test number is shared amongst all threads. This means if one thread sets the test number using &lt;code&gt;current_test()&lt;/code&gt; they will all be effected.</source>
          <target state="translated">Perl 5.8.1以降では、Test :: Builderはスレッドセーフです。テスト番号はすべてのスレッド間で共有されます。つまり、1つのスレッドが &lt;code&gt;current_test()&lt;/code&gt; を使用してテスト番号を設定すると、それらすべてが影響を受けます。</target>
        </trans-unit>
        <trans-unit id="3a5a7894f13b3108e48548883e8c5856a72ec473" translate="yes" xml:space="preserve">
          <source>In perl 5.8.1 and later, Test::Builder is thread-safe. The test number is shared by all threads. This means if one thread sets the test number using &lt;code&gt;current_test()&lt;/code&gt; they will all be effected.</source>
          <target state="translated">perl 5.8.1以降では、Test :: Builderはスレッドセーフです。テスト番号はすべてのスレッドで共有されます。これは、1つのスレッドが &lt;code&gt;current_test()&lt;/code&gt; を使用してテスト番号を設定すると、それらすべてが影響を受けることを意味します。</target>
        </trans-unit>
        <trans-unit id="eb8e3efeeef1db05dc1739fc816278f8bdf67e0a" translate="yes" xml:space="preserve">
          <source>In perl namespaces are called &quot;packages&quot; and the &lt;code&gt;package&lt;/code&gt; declaration tells the compiler which namespace to prefix to &lt;code&gt;our&lt;/code&gt; variables and unqualified dynamic names. This both protects against accidental stomping and provides an interface for deliberately clobbering global dynamic variables declared and used in other scopes or packages, when that is what you want to do.</source>
          <target state="translated">perlの名前空間は、「パッケージ」と呼ばれ、中に &lt;code&gt;package&lt;/code&gt; 宣言はしている名前空間接頭辞にコンパイラに指示します &lt;code&gt;our&lt;/code&gt; 変数と修飾されていないダイナミック名。これは、偶発的な踏みつけから保護し、他のスコープまたはパッケージで宣言および使用されるグローバル動的変数を意図的に破壊するためのインターフェイスを提供します。</target>
        </trans-unit>
        <trans-unit id="1269cc2ad1ea6f2d742e35bd480e05b3838a6225" translate="yes" xml:space="preserve">
          <source>In perl v5.8.0, you can work around this as follows;</source>
          <target state="translated">perl v5.8.0では、以下のように回避することができます。</target>
        </trans-unit>
        <trans-unit id="3903f5f9bb5ec2db6467ae7e05ade21cf24078e9" translate="yes" xml:space="preserve">
          <source>In perls older than 5.8.1, map suffers from this problem as well. But since 5.8.1, this has been fixed, and map is context aware - in void context, no lists are constructed.</source>
          <target state="translated">5.8.1 より古い perls では、map もこの問題に悩まされていました。しかし、5.8.1 以降では、この問題は修正されており、map はコンテキストを認識するようになりました。</target>
        </trans-unit>
        <trans-unit id="ea278e7090fabecd692fd4230b81818704c298d3" translate="yes" xml:space="preserve">
          <source>In perls without multi-thread locale support, some alien libraries, such as &lt;code&gt;Gtk&lt;/code&gt; change locales. This can cause problems for the Perl core and other modules. For these, before control is returned to perl, starting in v5.20.1, calling the function &lt;a href=&quot;perlapi#sync_locale&quot;&gt;sync_locale()&lt;/a&gt; from XS should be sufficient to avoid most of these problems. Prior to this, you need a pure Perl statement that does this:</source>
          <target state="translated">マルチスレッドロケールをサポートしていないPerlでは、 &lt;code&gt;Gtk&lt;/code&gt; などの一部のエイリアンライブラリがロケールを変更します。これにより、Perlコアおよびその他のモジュールで問題が発生する可能性があります。これらの場合、v5.20.1以降、制御がperlに戻る前に、XSから関数&lt;a href=&quot;perlapi#sync_locale&quot;&gt;sync_locale（）を&lt;/a&gt;呼び出すだけで、これらの問題のほとんどを回避できます。これに先立ち、これを行う純粋なPerlステートメントが必要です。</target>
        </trans-unit>
        <trans-unit id="201c993ba430d2b34780a5f6bce751f372ee2124" translate="yes" xml:space="preserve">
          <source>In portable Perl code, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;(9, $child)&lt;/code&gt; must not be used on forked processes. Killing a forked process is unsafe and has unpredictable results. See &lt;a href=&quot;#kill()&quot;&gt;kill()&lt;/a&gt;, above.</source>
          <target state="translated">移植可能なPerlコードでは、forkプロセスで &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;(9, $child)&lt;/code&gt; 使用してはなりません。フォークされたプロセスを強制終了することは安全ではなく、予期しない結果をもたらします。上記の&lt;a href=&quot;#kill()&quot;&gt;kill（）を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1e83f0a235b98e42c7720cdbf4e5b9c914546580" translate="yes" xml:space="preserve">
          <source>In portable Perl code, &lt;code&gt;kill(9, $child)&lt;/code&gt; must not be used on forked processes. Killing a forked process is unsafe and has unpredictable results. See &lt;a href=&quot;#kill%28%29&quot;&gt;&quot;kill()&quot;&lt;/a&gt;, above.</source>
          <target state="translated">移植可能なPerlコードでは、 &lt;code&gt;kill(9, $child)&lt;/code&gt; をフォークされたプロセスで使用してはなりません。分岐したプロセスを強制終了することは安全ではなく、予測できない結果をもたらします。上記の&lt;a href=&quot;#kill%28%29&quot;&gt;「kill（）」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="87c591de97ad94e43f8f39a0a83433ac7e94d500" translate="yes" xml:space="preserve">
          <source>In practice people have come to depend on these over the years, despite being historically undocumented, so we will provide some level of forward compatibility for some time. Nevertheless you can assume that any routine documented here is experimental or deprecated and you should find alternatives to their use.</source>
          <target state="translated">歴史的に文書化されていないにもかかわらず、実際には何年にもわたってこれらに依存するようになってきました。とはいえ、ここで文書化されているルーチンは実験的なものか非推奨のものだと思ってください。</target>
        </trans-unit>
        <trans-unit id="47486744068ceb35eb15ff07d8adf80ccffc0917" translate="yes" xml:space="preserve">
          <source>In practice this logic is better performed by &lt;a href=&quot;IO::Socket::IP&quot;&gt;IO::Socket::IP&lt;/a&gt;.</source>
          <target state="translated">実際には、このロジックは&lt;a href=&quot;IO::Socket::IP&quot;&gt;IO :: Socket :: IP&lt;/a&gt;によってより適切に実行されます。</target>
        </trans-unit>
        <trans-unit id="64e70c5c9f546a348d8be9f13ed9b3d5b217325e" translate="yes" xml:space="preserve">
          <source>In practice this logic is better performed by &lt;a href=&quot;io/socket/ip&quot;&gt;IO::Socket::IP&lt;/a&gt;.</source>
          <target state="translated">実際には、このロジックは&lt;a href=&quot;io/socket/ip&quot;&gt;IO :: Socket :: IPで&lt;/a&gt;実行する方が適切です。</target>
        </trans-unit>
        <trans-unit id="f10d5bbc85368eaaed58b49509d8d5537fcea2c6" translate="yes" xml:space="preserve">
          <source>In practice this makes seldom a difference as &lt;b&gt;parts and results&lt;/b&gt; of expressions will be truncated anyway, but this can, for instance, affect the return value of subroutines:</source>
          <target state="translated">実際には、式の&lt;b&gt;部分と結果&lt;/b&gt;が切り捨てられるため、これがめったに違いを生じることはありませんが、これは、たとえば、サブルーチンの戻り値に影響を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="2c8bdda291d4d16e099108c0540471c243257c86" translate="yes" xml:space="preserve">
          <source>In practice, Perl scripts that call programs that return _POSIX_EXIT type status values will be expecting those values, and programs that call traditional VMS programs will either be expecting the previous behavior or just checking for a non-zero status.</source>
          <target state="translated">実際には、_POSIX_EXIT型のステータス値を返すプログラムを呼び出すPerlスクリプトはそれらの値を期待しており、従来のVMSプログラムを呼び出すプログラムは、以前の動作を期待しているか、ゼロではないステータスをチェックしているかのどちらかです。</target>
        </trans-unit>
        <trans-unit id="1a4189d0a08fe1510a9bb56d98f077ee7698c8fc" translate="yes" xml:space="preserve">
          <source>In practice, however, one can generally expect such prerequisites to be one of two things:</source>
          <target state="translated">しかし、実際には、このような前提条件は、一般的に2つのうちの1つであると予想されます。</target>
        </trans-unit>
        <trans-unit id="6ed326b6d59e850419b57af366a49ca220934029" translate="yes" xml:space="preserve">
          <source>In practice, it is anticipated that this character will not be used often, but formatters should either support it, or delete it.</source>
          <target state="translated">実際には、この文字はあまり使われないことが予想されますが、フォーマッタはこの文字をサポートするか、削除するべきです。</target>
        </trans-unit>
        <trans-unit id="1ef0975bd5345aa7b1f7b096896a28cbd99bcab1" translate="yes" xml:space="preserve">
          <source>In pre-Sierra macOS (pre-10.12, OS X) clock_getres(), clock_gettime() and clock_nanosleep() are emulated using the Mach timers; as a side effect of being emulated the CLOCK_REALTIME and CLOCK_MONOTONIC are the same timer.</source>
          <target state="translated">Sierra macOS以前(10.12以前、OS X)では、clock_getres()、clock_gettime()、clock_nanosleep()はMachタイマを使ってエミュレートされていますが、その副作用としてCLOCK_REALTIMEとCLOCK_MONOTONICは同じタイマになっています。</target>
        </trans-unit>
        <trans-unit id="796550631a5df07b05a560a67d63d7ad67fdf7c5" translate="yes" xml:space="preserve">
          <source>In previous sections we have seen how to pack numbers and character strings. If it were not for a couple of snags we could conclude this section right away with the terse remark that C structures don't contain anything else, and therefore you already know all there is to it. Sorry, no: read on, please.</source>
          <target state="translated">これまでのセクションでは、数字と文字列の詰め方を見てきました。もし、いくつかの問題がなければ、C の構造体には他の何も含まれていないので、あなたはすでにすべてを知っています、という簡潔な言葉で、このセクションをすぐに終えることができます。申し訳ありません。</target>
        </trans-unit>
        <trans-unit id="692b842adc759f56816c9c058cae643b8a51086a" translate="yes" xml:space="preserve">
          <source>In principle the unpack() command can be used to convert the bytes back to a number (if the underlying type is known to be a number).</source>
          <target state="translated">原則として、unpack()コマンドはバイトを数値に変換するために使用することができます (基礎となる型が数値であることがわかっている場合)。</target>
        </trans-unit>
        <trans-unit id="1221515422031848620efe6d264c7054adcd4f04" translate="yes" xml:space="preserve">
          <source>In prior perl versions, spawning threads with open directory handles would crash the interpreter. &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2frt.perl.org%2frt3%2fPublic%2fBug%2fDisplay.html%3fid%3d75154&quot;&gt;[perl #75154]&lt;/a&gt;</source>
          <target state="translated">以前のバージョンのperlでは、開いているディレクトリハンドルでスレッドを生成すると、インタープリターがクラッシュしました。&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2frt.perl.org%2frt3%2fPublic%2fBug%2fDisplay.html%3fid%3d75154&quot;&gt;[perl＃75154]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e963293b700fb96161131daf0471b9f677f48564" translate="yes" xml:space="preserve">
          <source>In prior perl versions, spawning threads with open directory handles would crash the interpreter. &lt;a href=&quot;https://rt.perl.org/rt3/Public/Bug/Display.html?id=75154&quot;&gt;[perl #75154]&lt;/a&gt;</source>
          <target state="translated">以前のperlバージョンでは、開いているディレクトリハンドルでスレッドを生成すると、インタプリタがクラッシュしていました。&lt;a href=&quot;https://rt.perl.org/rt3/Public/Bug/Display.html?id=75154&quot;&gt;[perl＃75154]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d807cc153636cb39c76e4cb0277ef6012694dae7" translate="yes" xml:space="preserve">
          <source>In programs:</source>
          <target state="translated">プログラムの中で</target>
        </trans-unit>
        <trans-unit id="48c74c56dfa96426cf79d4567af2599b0fde094e" translate="yes" xml:space="preserve">
          <source>In recent years, vendors have begun to supply systems free of this inherent security bug. On such systems, when the kernel passes the name of the set-id script to open to the interpreter, rather than using a pathname subject to meddling, it instead passes</source>
          <target state="translated">近年、ベンダはこの固有のセキュリティバグのないシステムを提供し始めています。そのようなシステムでは、カーネルが set-id スクリプトの名前をインタープリタに渡すときに、お節介なパス名を使うのではなく、代わりに</target>
        </trans-unit>
        <trans-unit id="fc7a0ac9fe9f163678a08865a8ae2ec22fbc06ff" translate="yes" xml:space="preserve">
          <source>In regex speak, a word boundary (\b) is a &quot;zero width assertion&quot;, meaning that it doesn't represent a character in the string, but a condition at a certain position.</source>
          <target state="translated">正規表現で言えば、単語の境界(\b)は「ゼロ幅のアサーション」であり、文字列の中の文字ではなく、ある位置の条件を表しています。</target>
        </trans-unit>
        <trans-unit id="1b5ca67e58e909ea0b763b445166b0dc50f9fff9" translate="yes" xml:space="preserve">
          <source>In regular expressions, the &lt;code&gt;${foo[2]}&lt;/code&gt; syntax is sometimes necessary to disambiguate between array subscripts and character classes. &lt;code&gt;/$length[2345]/&lt;/code&gt; , for instance, will be interpreted as &lt;code&gt;$length&lt;/code&gt; followed by the character class &lt;code&gt;[2345]&lt;/code&gt; . If an array subscript is what you want, you can avoid the warning by changing &lt;code&gt;/${length[2345]}/&lt;/code&gt; to the unsightly &lt;code&gt;/${\$length[2345]}/&lt;/code&gt; , by renaming your array to something that does not coincide with a built-in keyword, or by simply turning off warnings with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'ambiguous';&lt;/code&gt; .</source>
          <target state="translated">正規表現では、配列の添え字と文字クラスを明確にするために、 &lt;code&gt;${foo[2]}&lt;/code&gt; 構文が必要になる場合があります。 &lt;code&gt;/$length[2345]/&lt;/code&gt; は、たとえば、 &lt;code&gt;$length&lt;/code&gt; 後に文字クラス &lt;code&gt;[2345]&lt;/code&gt; が続くものとして解釈されます。配列の添え字が必要な場合は、 &lt;code&gt;/${length[2345]}/&lt;/code&gt; を見苦しい &lt;code&gt;/${\$length[2345]}/&lt;/code&gt; に変更して、配列の名前を一致しないものに変更することで、警告を回避できます内蔵のキーワード、または単にで警告をオフにすることで、 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'ambiguous';&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd333dd1f620232f5d53f75438d1fbecd387c044" translate="yes" xml:space="preserve">
          <source>In regular expressions, the &lt;code&gt;${foo[2]}&lt;/code&gt; syntax is sometimes necessary to disambiguate between array subscripts and character classes. &lt;code&gt;/$length[2345]/&lt;/code&gt;, for instance, will be interpreted as &lt;code&gt;$length&lt;/code&gt; followed by the character class &lt;code&gt;[2345]&lt;/code&gt;. If an array subscript is what you want, you can avoid the warning by changing &lt;code&gt;/${length[2345]}/&lt;/code&gt; to the unsightly &lt;code&gt;/${\$length[2345]}/&lt;/code&gt;, by renaming your array to something that does not coincide with a built-in keyword, or by simply turning off warnings with &lt;code&gt;no warnings 'ambiguous';&lt;/code&gt;.</source>
          <target state="translated">正規表現では、配列の添え字と文字クラスを明確にするために、 &lt;code&gt;${foo[2]}&lt;/code&gt; 構文が必要になる場合があります。たとえば、 &lt;code&gt;/$length[2345]/&lt;/code&gt; 、 &lt;code&gt;$length&lt;/code&gt; 後に文字クラス &lt;code&gt;[2345]&lt;/code&gt; が続くものとして解釈されます。配列の添え字が必要な場合は、 &lt;code&gt;/${length[2345]}/&lt;/code&gt; を見苦しい &lt;code&gt;/${\$length[2345]}/&lt;/code&gt; に変更し、配列の名前を一致しない名前に変更することで、警告を回避できます。組み込みのキーワードを使用するか、警告 &lt;code&gt;no warnings 'ambiguous';&lt;/code&gt; オフにするだけで「あいまい」になります。。</target>
        </trans-unit>
        <trans-unit id="870f19d24df4b4eee6c062f874fd2afacdfc9f30" translate="yes" xml:space="preserve">
          <source>In scalar context it returns the same as perl would when stringifying a raw &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; with the same pattern inside. If the argument is not a compiled reference then this routine returns false but defined in scalar context, and the empty list in list context. Thus the following</source>
          <target state="translated">スカラーコンテキストでは、内部で同じパターンを使用して生の &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; を文字列化するときにperlが返すのと同じように返します。引数がコンパイルされた参照でない場合、このルーチンはfalseを返しますが、スカラーコンテキストで定義され、リストコンテキストでは空のリストです。したがって、次の</target>
        </trans-unit>
        <trans-unit id="63b198727926386f9c90953cc658aa09102f11ba" translate="yes" xml:space="preserve">
          <source>In scalar context it returns the same as perl would when stringifying a raw &lt;code&gt;qr//&lt;/code&gt; with the same pattern inside. If the argument is not a compiled reference then this routine returns false but defined in scalar context, and the empty list in list context. Thus the following</source>
          <target state="translated">スカラーコンテキストでは、内部に同じパターンで生の &lt;code&gt;qr//&lt;/code&gt; を文字列化する場合のperlと同じものを返します。引数がコンパイルされた参照ではない場合、このルーチンはfalseを返しますが、スカラーコンテキストで定義され、リストコンテキストでは空のリストを返します。したがって、次の</target>
        </trans-unit>
        <trans-unit id="d798e2857dfe13a30f68c169a5217a15884e07bf" translate="yes" xml:space="preserve">
          <source>In scalar context returns the name of the Win32 operating system being used. In list context returns a two element list of the OS name and whatever edition information is known about the particular build (for Win9X boxes) and whatever service packs have been installed. The latter is roughly equivalent to the first item returned by GetOSVersion() in list context.</source>
          <target state="translated">スカラコンテキストでは、使用している Win32 オペレーティングシステムの名前を返します。リストコンテキストでは、OS 名と、特定のビルド (Win9X ボックスの場合)やインストールされているサービスパックについてわかっているエディション情報の 2 つの要素のリストを返します。後者は、リストコンテキストの GetOSVersion()が返す最初の項目とほぼ同等です。</target>
        </trans-unit>
        <trans-unit id="0a19f93e8a70aa3709a4c5eb5c497d67c74952ec" translate="yes" xml:space="preserve">
          <source>In scalar context will return just the IP address.</source>
          <target state="translated">スカラコンテキストでは、IPアドレスだけを返します。</target>
        </trans-unit>
        <trans-unit id="1370034b95e83c1602601f8f2c93a5f4f13c28ad" translate="yes" xml:space="preserve">
          <source>In scalar context without arguments, this method returns the number of parsers aggregated. In list context without arguments, returns the parsers in the order they were added.</source>
          <target state="translated">引数のないスカラコンテキストでは、このメソッドは集約されたパーサの数を返します。引数のないリストコンテキストでは、追加された順にパーサーを返します。</target>
        </trans-unit>
        <trans-unit id="408e422198127b367c2df3b98eea7ea06f9026b1" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;a href=&quot;#localtime-EXPR&quot;&gt;&lt;code&gt;localtime&lt;/code&gt;&lt;/a&gt; returns the &lt;a href=&quot;http://man.he.net/man3/ctime&quot;&gt;ctime(3)&lt;/a&gt; value:</source>
          <target state="translated">スカラーコンテキストでは、&lt;a href=&quot;#localtime-EXPR&quot;&gt; &lt;code&gt;localtime&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;http://man.he.net/man3/ctime&quot;&gt;ctime（3）&lt;/a&gt;値を返します。</target>
        </trans-unit>
        <trans-unit id="ddd842934d85c69674953e0bf0440bc470724af8" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; returns a boolean value indicating success or failure, and, if successful, sets the information associated with the special filehandle &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">スカラーコンテキストでは、&lt;a href=&quot;#stat-FILEHANDLE&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;は成功または失敗を示すブール値を返し、成功した場合は、特別なファイルハンドル &lt;code&gt;_&lt;/code&gt; に関連付けられた情報を設定します。</target>
        </trans-unit>
        <trans-unit id="4062294e689c1833bcdae539d23c73d6b5a0887d" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;a href=&quot;#times&quot;&gt;&lt;code&gt;times&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;$user&lt;/code&gt;.</source>
          <target state="translated">スカラーコンテキストでは、&lt;a href=&quot;#times&quot;&gt; &lt;code&gt;times&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;$user&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="3e333b48f248d91366426a74dfbbc3da65c8ea7d" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&quot;..&quot;&lt;/code&gt; returns a boolean value. The operator is bistable, like a flip-flop, and emulates the line-range (comma) operator of &lt;b&gt;sed&lt;/b&gt;, &lt;b&gt;awk&lt;/b&gt;, and various editors. Each &lt;code&gt;&quot;..&quot;&lt;/code&gt; operator maintains its own boolean state, even across calls to a subroutine that contains it. It is false as long as its left operand is false. Once the left operand is true, the range operator stays true until the right operand is true,</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;&quot;..&quot;&lt;/code&gt; はブール値を返します。演算子はフリップフロップのように双安定であり、&lt;b&gt;sed&lt;/b&gt;、&lt;b&gt;awk&lt;/b&gt;、およびさまざまなエディターの行範囲（カンマ）演算子をエミュレートします。各 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 演算子は、それを含むサブルーチンへの呼び出し間でも、独自のブール状態を維持します。左側のオペランドがfalseである限り、falseです。左側のオペランドが真になると、範囲演算子は右側のオペランドが真になるまで真のままです。</target>
        </trans-unit>
        <trans-unit id="4702696bd1a6606f8c00bfa48b7462e238b219f8" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; returns the ctime(3) value:</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; はctime（3）値を返します。</target>
        </trans-unit>
        <trans-unit id="50ab8480db61cacd9dd3820b8d1635a7c8fbf2e8" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; returns a boolean value indicating success or failure, and, if successful, sets the information associated with the special filehandle &lt;code&gt;_&lt;/code&gt; .</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; は成功または失敗を示すブール値を返し、成功した場合は、特別なファイルハンドル &lt;code&gt;_&lt;/code&gt; に関連付けられた情報を設定します。</target>
        </trans-unit>
        <trans-unit id="d1818a475de168c2b1a7d2bb086c2af5a3f3a97b" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;$user&lt;/code&gt; .</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;$user&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="d16f2c8ac24f3fef816016a050127e8baea1e4f0" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; returns the ctime(3) value:</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; はctime（3）値を返します。</target>
        </trans-unit>
        <trans-unit id="c038fe7af8fd4fba37237e821dee5726e03d9bcf" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; returns a boolean value indicating success or failure, and, if successful, sets the information associated with the special filehandle &lt;code&gt;_&lt;/code&gt; .</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;&lt;a href=&quot;stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; は成功または失敗を示すブール値を返し、成功した場合は、特別なファイルハンドル &lt;code&gt;_&lt;/code&gt; に関連付けられた情報を設定します。</target>
        </trans-unit>
        <trans-unit id="f361652bf48a4a2a1736272eaacbdbdece5ad741" translate="yes" xml:space="preserve">
          <source>In scalar context, &lt;code&gt;&lt;a href=&quot;times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;$user&lt;/code&gt; .</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;&lt;a href=&quot;times&quot;&gt;times&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;$user&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="1674eb64be9587ce137d56ac70c490cdb01951f2" translate="yes" xml:space="preserve">
          <source>In scalar context, divides $x by $y and returns the result to the given or default accuracy/precision. In list context, does floored division (F-division), returning an integer $q and a remainder $r so that $x = $q * $y + $r. The remainer (modulo) is equal to what is returned by &lt;code&gt;$x-&amp;gt;bmod($y)&lt;/code&gt;.</source>
          <target state="translated">スカラーコンテキストでは、$ xを$ yで除算し、結果を指定された、またはデフォルトの精度/精度に戻します。リストのコンテキストでは、フロア除算（F除算）を実行し、整数$ qと剰余$ rを返し、$ x = $ q * $ y + $ rとなります。残り（モジュロ）は、 &lt;code&gt;$x-&amp;gt;bmod($y)&lt;/code&gt; によって返されるものと同じです。</target>
        </trans-unit>
        <trans-unit id="907f0666cff82b9d0476cd5d474908eaefafe8db" translate="yes" xml:space="preserve">
          <source>In scalar context, divides $x by $y and returns the result. In list context, does floored division (F-division), returning an integer $q and a remainder $r so that $x = $q * $y + $r. The remainer (modulo) is equal to what is returned by &lt;code&gt;$x-&lt;/code&gt;bmod($y)&amp;gt;.</source>
          <target state="translated">スカラーコンテキストでは、$ xを$ yで除算し、結果を返します。リストのコンテキストでは、フロア除算（F除算）を実行し、整数$ qと剰余$ rを返し、$ x = $ q * $ y + $ rとなります。残り（モジュロ）は、 &lt;code&gt;$x-&lt;/code&gt; bmod（$ y）&amp;gt;によって返されるものと同じです。</target>
        </trans-unit>
        <trans-unit id="67f63380dd91d8509df2b85f67d144a31345d453" translate="yes" xml:space="preserve">
          <source>In scalar context, each execution of &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; finds the next match, returning true if it matches, and false if there is no further match. The position after the last match can be read or set using the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; function; see &lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;. A failed match normally resets the search position to the beginning of the string, but you can avoid that by adding the &lt;code&gt;/c&lt;/code&gt; modifier (for example, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt;). Modifying the target string also resets the search position.</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; を実行するたびに次の一致が検出され、一致する場合はtrueが、それ以上一致しない場合はfalseが返されます。最後の一致後の位置は、 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 関数を使用して読み取りまたは設定できます。&lt;a href=&quot;functions/pos&quot;&gt;posを&lt;/a&gt;参照してください。一致が失敗すると、通常、検索位置は文字列の先頭にリセットされますが、 &lt;code&gt;/c&lt;/code&gt; 修飾子（たとえば、 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; ）を追加することで回避できます。ターゲット文字列を変更すると、検索位置もリセットされます。</target>
        </trans-unit>
        <trans-unit id="4a6e0628ceeeb02c47448d71e6cf72d4e6e644eb" translate="yes" xml:space="preserve">
          <source>In scalar context, each execution of &lt;code&gt;m//g&lt;/code&gt; finds the next match, returning true if it matches, and false if there is no further match. The position after the last match can be read or set using the &lt;code&gt;pos()&lt;/code&gt; function; see &lt;a href=&quot;perlfunc#pos&quot;&gt;&quot;pos&quot; in perlfunc&lt;/a&gt;. A failed match normally resets the search position to the beginning of the string, but you can avoid that by adding the &lt;code&gt;/c&lt;/code&gt; modifier (for example, &lt;code&gt;m//gc&lt;/code&gt;). Modifying the target string also resets the search position.</source>
          <target state="translated">スカラーコンテキストでは、 &lt;code&gt;m//g&lt;/code&gt; を実行するたびに次の一致が検出され、一致する場合はtrueが返され、一致するものがない場合はfalseが返されます。最後の一致の後の位置は、 &lt;code&gt;pos()&lt;/code&gt; 関数を使用して読み取りまたは設定できます。&lt;a href=&quot;perlfunc#pos&quot;&gt;perlfuncの「pos」を&lt;/a&gt;参照してください。一致に失敗すると、通常、検索位置が文字列の先頭にリセットされますが、 &lt;code&gt;/c&lt;/code&gt; 修飾子（たとえば、 &lt;code&gt;m//gc&lt;/code&gt; ）を追加することでこれを回避できます。ターゲット文字列を変更すると、検索位置もリセットされます。</target>
        </trans-unit>
        <trans-unit id="8800b54c59ca34fbb2fd00902e130cb43eb3acc5" translate="yes" xml:space="preserve">
          <source>In scalar context, evaluating a filehandle in angle brackets yields the next line from that file (the newline, if any, included), or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; at end-of-file or on error. When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (sometimes known as file-slurp mode) and the file is empty, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; subsequently.</source>
          <target state="translated">スカラーコンテキストでは、山かっこでファイルハンドルを評価すると、そのファイルの次の行（改行がある場合は、それが含まれます）、またはファイルの終わりやエラー時に &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が生成されます。ときに &lt;code&gt;$/&lt;/code&gt; に設定されている &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を（時にはファイル吸い込みモードとして知られている）と、ファイルが空である、それは返す &lt;code&gt;''&lt;/code&gt; に続いて、最初の時間を &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を後に。</target>
        </trans-unit>
        <trans-unit id="03380a29fdbee6fa1870baa930432527d010a246" translate="yes" xml:space="preserve">
          <source>In scalar context, evaluating a filehandle in angle brackets yields the next line from that file (the newline, if any, included), or &lt;code&gt;undef&lt;/code&gt; at end-of-file or on error. When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;undef&lt;/code&gt; (sometimes known as file-slurp mode) and the file is empty, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;undef&lt;/code&gt; subsequently.</source>
          <target state="translated">スカラーコンテキストでは、山括弧内のファイルハンドルを評価すると、そのファイルから次の行（改行がある場合は含まれます）が生成されるか、ファイルの終わりまたはエラー時に &lt;code&gt;undef&lt;/code&gt; が生成されます。ときに &lt;code&gt;$/&lt;/code&gt; に設定されている &lt;code&gt;undef&lt;/code&gt; を（時にはファイル吸い込みモードとして知られている）と、ファイルが空である、それは返す &lt;code&gt;''&lt;/code&gt; に続いて、最初の時間を &lt;code&gt;undef&lt;/code&gt; を後に。</target>
        </trans-unit>
        <trans-unit id="90d5e99280edc013a52bda47119a081391fd852e" translate="yes" xml:space="preserve">
          <source>In scalar context, just the filehandle is returned.</source>
          <target state="translated">スカラコンテキストでは、ファイルハンドルだけが返されます。</target>
        </trans-unit>
        <trans-unit id="e8180b7134edf387de3ba20adf4f7b9e0d9a09d4" translate="yes" xml:space="preserve">
          <source>In scalar context, returns a boolean indicating if SSL is available. In list context, returns the boolean and a (possibly multi-line) string of errors indicating why SSL isn't available.</source>
          <target state="translated">スカラコンテキストでは、SSLが利用可能かどうかを示すブール値を返します。リストコンテキストでは、SSLが利用できない理由を示す boolean と (複数行の)エラーの文字列を返します。</target>
        </trans-unit>
        <trans-unit id="1e5c0aafd8e8839028ecc16b9e49ead2fb7551ce" translate="yes" xml:space="preserve">
          <source>In scalar context, returns a single Fibonacci number. In list context, returns a list of Fibonacci numbers. The invocand is the last element in the output.</source>
          <target state="translated">スカラコンテキストでは、単一のフィボナッチ数を返します。リストコンテキストでは、フィボナッチ数のリストを返します。インボキャンドは出力の最後の要素です。</target>
        </trans-unit>
        <trans-unit id="ae996766d8949391f4258a78d5552412d910e1ec" translate="yes" xml:space="preserve">
          <source>In scalar context, returns a single Lucas number. In list context, returns a list of Lucas numbers. The invocand is the last element in the output.</source>
          <target state="translated">スカラコンテキストでは、1つのルーカス数を返します。リストコンテキストでは、ルーカス数のリストを返します。インボキャンドは出力の最後の要素となります。</target>
        </trans-unit>
        <trans-unit id="3b41a148fc8880eed7038e400dbf7ebdd585912a" translate="yes" xml:space="preserve">
          <source>In scalar context, returns the nth Fibonacci number: _fib(0) returns 0, _fib(1) returns 1, _fib(2) returns 1, _fib(3) returns 2 etc. In list context, returns the Fibonacci numbers from F(0) to F(n): 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...</source>
          <target state="translated">スカラコンテキストでは、n 番目のフィボナッチ数を返します。_fib(0)は 0 を返し、_fib(1)は 1 を返し、_fib(2)は 1 を返し、_fib(3)は 2 を返します。リストコンテキストでは、F(0)からF(n)までのフィボナッチ数を返します:0,1,1,2,3,5,8,13,21,34,...</target>
        </trans-unit>
        <trans-unit id="e88b23f1542291b640449137479d5bbdeb5b3c4f" translate="yes" xml:space="preserve">
          <source>In scalar context, returns the nth Lucas number: _lucas(0) returns 2, _lucas(1) returns 1, _lucas(2) returns 3, etc. In list context, returns the Lucas numbers from L(0) to L(n): 2, 1, 3, 4, 7, 11, 18, 29,47, 76, ...</source>
          <target state="translated">スカラコンテキストでは、n 番目のルーカス数を返します。lucas(0)は 2、_lucas(1)は 1、_lucas(2)は 3 などを返します。リストコンテキストでは、L(0)から L(n)までのルーカス数を返します:2,1,3,4,7,11,18,29,47,76,...</target>
        </trans-unit>
        <trans-unit id="5bc406c89894a3609e93b6be654bf8c26772c5a5" translate="yes" xml:space="preserve">
          <source>In scalar context, returns the number of elements that would have been returned as a list.</source>
          <target state="translated">スカラコンテキストでは、リストとして返されるであろう要素の数を返します。</target>
        </trans-unit>
        <trans-unit id="75fe50c921958ecaf606c5e87e67fc368c7bde2e" translate="yes" xml:space="preserve">
          <source>In scalar context, returns the peer host and port, joined with a colon, or &lt;code&gt;undef&lt;/code&gt; (if no peer is connected). In list context, returns the peer host and port or an empty list (if no peer is connected).</source>
          <target state="translated">スカラーコンテキストでは、コロンで結合されたピアホストとポート、または &lt;code&gt;undef&lt;/code&gt; （ピアが接続されていない場合）を返します。リストコンテキストでは、ピアのホストとポート、または空のリスト（ピアが接続されていない場合）を返します。</target>
        </trans-unit>
        <trans-unit id="7670efb624f43827626a2d7abe8ac56200cd57f1" translate="yes" xml:space="preserve">
          <source>In scalar context, returns the quotient after dividing OBJ1 by OBJ2 and truncating the result to an integer. In list context, return the quotient and the remainder.</source>
          <target state="translated">スカラコンテキストでは、OBJ1 を OBJ2 で除算し、その結果を整数に切り捨てた商を返します。リストコンテキストでは、商と残りを返します。</target>
        </trans-unit>
        <trans-unit id="26e7b891880cf2546cd4182b9d0f0a5ab5924094" translate="yes" xml:space="preserve">
          <source>In scalar context, the function returns the most preferred language tag (or undef if no preference was seen).</source>
          <target state="translated">スカラコンテキストでは、この関数は最も優先度の高い言語タグを返します(優先度が見られなかった場合は undef)。</target>
        </trans-unit>
        <trans-unit id="b1d9f6c7ff92d9e4431c44fd49623f31abe26893" translate="yes" xml:space="preserve">
          <source>In scalar context, the remaining time in the timer is returned.</source>
          <target state="translated">スカラコンテキストでは、タイマーの残り時間が返されます。</target>
        </trans-unit>
        <trans-unit id="f286b508bea32b55376de76bb51800a879183e4c" translate="yes" xml:space="preserve">
          <source>In scalar context, the remaining time is returned.</source>
          <target state="translated">スカラコンテキストでは、残りの時間が返されます。</target>
        </trans-unit>
        <trans-unit id="1fc032fde56245f910fbc6d13638ce22e45ea79e" translate="yes" xml:space="preserve">
          <source>In scalar context, you get the name, unless the function was a lookup by name, in which case you get the other thing, whatever it is. (If the entry doesn't exist you get the undefined value.) For example:</source>
          <target state="translated">スカラコンテキストでは、関数が名前による検索でない限り、名前を取得します。(エントリが存在しない場合は未定義の値を取得します)。</target>
        </trans-unit>
        <trans-unit id="070ead24adcf97bbf0458e41cddfaf9060fd1c75" translate="yes" xml:space="preserve">
          <source>In scopes where &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; is in force, nearly all the operators listed above will force their argument(s) into integer format, and return an integer result. The exceptions, &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; , do not change their behavior with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用する&lt;/a&gt;スコープ内。が有効な場合、上記のほぼすべての演算子は引数を整数形式に強制し、整数の結果を返します。例外、 &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;++&lt;/code&gt; および &lt;code&gt;--&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; integerを使用しても動作を変更しません。</target>
        </trans-unit>
        <trans-unit id="b6e91894f56bfff94294bd3277c1eafb159dcee4" translate="yes" xml:space="preserve">
          <source>In scopes where &lt;code&gt;use integer;&lt;/code&gt; is in force, nearly all the operators listed above will force their argument(s) into integer format, and return an integer result. The exceptions, &lt;code&gt;abs&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, do not change their behavior with &lt;code&gt;use integer;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;use integer;&lt;/code&gt; スコープ内。が有効である場合、上記のほぼすべての演算子は引数を整数形式に強制し、整数の結果を返します。例外 &lt;code&gt;abs&lt;/code&gt; 、 &lt;code&gt;++&lt;/code&gt; および &lt;code&gt;--&lt;/code&gt; 、 &lt;code&gt;use integer;&lt;/code&gt; を使用しても動作を変更しません。</target>
        </trans-unit>
        <trans-unit id="d3fd63b759e64d942882eb1c88a05afcfdaffadf" translate="yes" xml:space="preserve">
          <source>In searching for &lt;code&gt;/\bfoo\b/&lt;/code&gt; , only locations in &lt;code&gt;$_&lt;/code&gt; that contain &lt;code&gt;f&lt;/code&gt; will be looked at, because &lt;code&gt;f&lt;/code&gt; is rarer than &lt;code&gt;o&lt;/code&gt; . In general, this is a big win except in pathological cases. The only question is whether it saves you more time than it took to build the linked list in the first place.</source>
          <target state="translated">&lt;code&gt;/\bfoo\b/&lt;/code&gt; 検索では、 &lt;code&gt;f&lt;/code&gt; が &lt;code&gt;o&lt;/code&gt; よりも少ないため、 &lt;code&gt;f&lt;/code&gt; を含む &lt;code&gt;$_&lt;/code&gt; 内の場所のみが検索されます。一般的に、これは病理的な場合を除いて大きな勝利です。唯一の問題は、そもそもリンクリストを作成するよりも時間を節約できるかどうかです。</target>
        </trans-unit>
        <trans-unit id="d510b9d55974c5ad5785f6cfe4077983c695078d" translate="yes" xml:space="preserve">
          <source>In short, Perl 4 is the parent to both Perl 5 and Perl 6. Perl 5 is the older sibling, and though they are different languages, someone who knows one will spot many similarities in the other.</source>
          <target state="translated">要するに、Perl 4 は Perl 5 と Perl 6 の両方の親です。Perl 5 は兄妹であり、異なる言語ではありますが、一方を知っている人は他方に多くの類似点があることに気づくでしょう。</target>
        </trans-unit>
        <trans-unit id="ed75eeeb8979a82ac73d297c5e1f3634bea45872" translate="yes" xml:space="preserve">
          <source>In short, Perl 4 is the parent to both Perl 5 and Raku (formerly known as Perl 6). Perl 5 is the older sibling, and though they are different languages, someone who knows one will spot many similarities in the other.</source>
          <target state="translated">要するに、Perl 4 は Perl 5 と Raku (以前は Perl 6 として知られていました)の親です。Perl 5 は兄妹であり、異なる言語ではありますが、一方を知っている人は他方に多くの類似点があることに気づくでしょう。</target>
        </trans-unit>
        <trans-unit id="27c26dcc733ecda091da4a3f15918e2cc3eb4955" translate="yes" xml:space="preserve">
          <source>In short: If the module exports anything that should be run directly by a test script it should probably NOT go directly into &lt;code&gt;Test2::XXX&lt;/code&gt;.</source>
          <target state="translated">つまり、モジュールがテストスクリプトによって直接実行する必要のあるものをエクスポートする場合、おそらく &lt;code&gt;Test2::XXX&lt;/code&gt; 直接移動するべきではありません。</target>
        </trans-unit>
        <trans-unit id="a022deee593194afb675e77892be1749073d500f" translate="yes" xml:space="preserve">
          <source>In simple cases, it is equivalent to:</source>
          <target state="translated">単純に考えれば、これに相当します。</target>
        </trans-unit>
        <trans-unit id="ffcc65b4ec59c10cd981321f645c18e2c2833005" translate="yes" xml:space="preserve">
          <source>In simple terms, this is what happens:</source>
          <target state="translated">簡単に言うと、こうなります。</target>
        </trans-unit>
        <trans-unit id="8d3443fd7f0c08a6561ba5f63f633adb2afde771" translate="yes" xml:space="preserve">
          <source>In situations where it doesn't make sense for a particular metacharacter to mean what it normally does, it automatically loses its metacharacter-ness and becomes an ordinary character that is to be matched literally. For example, the &lt;code&gt;'}'&lt;/code&gt; is a metacharacter only when it is the mate of a &lt;code&gt;'{'&lt;/code&gt; metacharacter. Otherwise it is treated as a literal RIGHT CURLY BRACKET. This may lead to unexpected results. &lt;a href=&quot;re#%27strict%27-mode&quot;&gt;&lt;code&gt;use re 'strict'&lt;/code&gt;&lt;/a&gt; can catch some of these.</source>
          <target state="translated">特定のメタ文字が通常の機能を意味することが意味をなさない状況では、メタ文字は自動的にそのメタ文字性を失い、文字通り一致する通常の文字になります。たとえば、 &lt;code&gt;'}'&lt;/code&gt; は、 &lt;code&gt;'{'&lt;/code&gt; メタ文字のメイトである場合にのみメタ文字です。それ以外の場合は、文字通りのRIGHT CURLYBRACKETとして扱われます。これにより、予期しない結果が生じる可能性があります。&lt;a href=&quot;re#%27strict%27-mode&quot;&gt; &lt;code&gt;use re 'strict'&lt;/code&gt; &lt;/a&gt;、これらの一部をキャッチできます。</target>
        </trans-unit>
        <trans-unit id="d121139946109160493990901ec9a05c62500b61" translate="yes" xml:space="preserve">
          <source>In situations where you need to enable this with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; , you should also have taint checking enabled. Better yet, use the carefully constrained evaluation within a Safe compartment. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for details about both these mechanisms.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; でこれを有効にする必要がある状況では、汚染チェックも有効にする必要があります。さらに、安全なコンパートメント内で、慎重に制約された評価を使用してください。参照してください&lt;a href=&quot;perlsec&quot;&gt;perlsecを&lt;/a&gt;両方これらのメカニズムの詳細については。</target>
        </trans-unit>
        <trans-unit id="890a195db1801db98e427898d4624b5cd0fd0e61" translate="yes" xml:space="preserve">
          <source>In situations where you need to enable this with &lt;code&gt;use re 'eval'&lt;/code&gt;, you should also have taint checking enabled. Better yet, use the carefully constrained evaluation within a Safe compartment. See &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; for details about both these mechanisms.</source>
          <target state="translated">&lt;code&gt;use re 'eval'&lt;/code&gt; でこれを有効にする必要がある状況では、汚染チェックも有効にする必要があります。さらに良いことに、Safeコンパートメント内で慎重に制約された評価を使用してください。参照してください&lt;a href=&quot;perlsec&quot;&gt;perlsecを&lt;/a&gt;両方これらのメカニズムの詳細については。</target>
        </trans-unit>
        <trans-unit id="e2046d35bd71cc3166ad97adddb890d2444c1f0f" translate="yes" xml:space="preserve">
          <source>In some cases (starting server processes, for instance) you'll want to completely dissociate the child process from the parent. This is often called daemonization. A well-behaved daemon will also chdir() to the root directory so it doesn't prevent unmounting the filesystem containing the directory from which it was launched, and redirect its standard file descriptors from and to</source>
          <target state="translated">場合によっては (例えばサーバプロセスの起動など)、子プロセスを親プロセスから完全に切り離したいこともあるでしょう。これはしばしばデーモン化と呼ばれます。行儀の良いデーモンは、起動されたディレクトリを含むファイルシステムのアンマウントを妨げないように、ルートディレクトリに chdir()を実行し、その標準ファイルディスクリプタを</target>
        </trans-unit>
        <trans-unit id="a5b5fb7e89a60fc9793673e892211f18421217cb" translate="yes" xml:space="preserve">
          <source>In some cases an object may only have 1 or 2 attributes, in which case a hashref may be too verbose for your liking. In these cases you can pass in an arrayref with only values. The values will be assigned to attributes in the order the attributes were listed. When there is inheritance involved the attributes from parent classes will come before subclasses.</source>
          <target state="translated">場合によっては、オブジェクトが1つか2つの属性しか持たないこともあるでしょう。このような場合には、値のみの配列refを渡すことができます。値は、属性がリストアップされた順に属性に割り当てられます。継承がある場合は、親クラスの属性がサブクラスの前に来ます。</target>
        </trans-unit>
        <trans-unit id="c9396ca88545422246dd73162e905f2e472202a6" translate="yes" xml:space="preserve">
          <source>In some cases files created by File::Temp are removed from within an END block. Since END blocks are triggered when a child process exits (unless &lt;code&gt;POSIX::_exit()&lt;/code&gt; is used by the child) File::Temp takes care to only remove those temp files created by a particular process ID. This means that a child will not attempt to remove temp files created by the parent process.</source>
          <target state="translated">File :: Tempによって作成されたファイルは、ENDブロック内から削除される場合があります。 ENDブロックは、子プロセスが終了したときにトリガーされるため（ &lt;code&gt;POSIX::_exit()&lt;/code&gt; が子によって使用されている場合を除く）、File :: Tempは、特定のプロセスIDによって作成された一時ファイルのみを削除するように注意します。これは、子が親プロセスによって作成された一時ファイルを削除しようとしないことを意味します。</target>
        </trans-unit>
        <trans-unit id="fd4562e3425450ab12fc121ff9cd696fd05153a4" translate="yes" xml:space="preserve">
          <source>In some cases files created by File::Temp are removed from within an END block. Since END blocks are triggered when a child process exits (unless C&amp;lt;:_exit&amp;gt; is used by the child) File::Temp takes care to only remove those temp files created by a particular process ID. This means that a child will not attempt to remove temp files created by the parent process.</source>
          <target state="translated">File :: Tempによって作成されたファイルがENDブロック内から削除される場合があります。ENDブロックは子プロセスの終了時にトリガーされるため（C &amp;lt;：_ exit&amp;gt;が子によって使用されている場合を除く）、File :: Tempは、特定のプロセスIDによって作成された一時ファイルのみを削除するように注意します。これは、子プロセスが親プロセスによって作成された一時ファイルを削除しようとしないことを意味します。</target>
        </trans-unit>
        <trans-unit id="4cd284f272380bf09ca4f9468d05eb334cb95414" translate="yes" xml:space="preserve">
          <source>In some cases the 'application' can then be reduced to a small</source>
          <target state="translated">いくつかのケースでは、「アプリケーション」を小さな</target>
        </trans-unit>
        <trans-unit id="df381c2814bde8cd15795ab2d100f8c130800cb5" translate="yes" xml:space="preserve">
          <source>In some cases this</source>
          <target state="translated">いくつかのケースでは、これは</target>
        </trans-unit>
        <trans-unit id="cde62ba475df964750a3cdf495be48e1d052051b" translate="yes" xml:space="preserve">
          <source>In some cases, files will only be retained if this variable is true when the file is created. This means that you can not create a temporary file, set this variable and expect the temp file to still be around when the program exits.</source>
          <target state="translated">いくつかのケースでは、ファイルが作成されたときにこの変数が真である場合にのみ、ファイルが保持されます。つまり、一時ファイルを作成してこの変数を設定し、プログラムが終了したときに一時ファイルが残っていることを期待することはできません。</target>
        </trans-unit>
        <trans-unit id="833bad25b1c7e7dcf3b679328d88bdc7a807854c" translate="yes" xml:space="preserve">
          <source>In some cases, it doesn't make practical sense for elements to be supported earlier than they already are. For example, UTF-8 functionality isn't provided prior to the release where it was first introduced.</source>
          <target state="translated">いくつかのケースでは、要素が既にサポートされているよりも早くサポートされることは現実的ではありません。例えば、UTF-8の機能は、それが最初に導入されたリリースより前には提供されていません。</target>
        </trans-unit>
        <trans-unit id="82de4f66144949e592925ee2402c722d415cd5ed" translate="yes" xml:space="preserve">
          <source>In some cases, there is the need for incremental parsing of JSON texts. While this module always has to keep both JSON text and resulting Perl data structure in memory at one time, it does allow you to parse a JSON stream incrementally. It does so by accumulating text until it has a full JSON object, which it then can decode. This process is similar to using &lt;code&gt;decode_prefix&lt;/code&gt; to see if a full JSON object is available, but is much more efficient (and can be implemented with a minimum of method calls).</source>
          <target state="translated">場合によっては、JSONテキストの増分解析が必要になります。このモジュールは常にJSONテキストと結果のPerlデータ構造の両方を一度にメモリに保持する必要がありますが、JSONストリームを段階的に解析することもできます。これは、完全なJSONオブジェクトができるまでテキストを蓄積し、それをデコードできるようにすることで行われます。このプロセスは、 &lt;code&gt;decode_prefix&lt;/code&gt; を使用して完全なJSONオブジェクトが使用可能かどうかを確認するのと似ていますが、はるかに効率的です（最小限のメソッド呼び出しで実装できます）。</target>
        </trans-unit>
        <trans-unit id="3905e6a37b63c12afc3763addc4e36a653fc636f" translate="yes" xml:space="preserve">
          <source>In some cases, using substr() or vec() to simulate arrays can be highly beneficial. For example, an array of a thousand booleans will take at least 20,000 bytes of space, but it can be turned into one 125-byte bit vector--a considerable memory savings. The standard Tie::SubstrHash module can also help for certain types of data structure. If you're working with specialist data structures (matrices, for instance) modules that implement these in C may use less memory than equivalent Perl modules.</source>
          <target state="translated">場合によっては、配列をシミュレートするために substr()や vec()を使用することは非常に有益です。例えば、1000個のブール演算子の配列は少なくとも20,000バイトのスペースを必要としますが、これを1つの125バイトのビットベクタに変換することができ、かなりのメモリ節約になります。標準の Tie::SubstrHash モジュールは、特定のタイプのデータ構造を扱う際にも役立ちます。特殊なデータ構造 (例えば行列)を扱う場合は、C 言語で実装されているモジュールの方が、同等の Perl モジュールよりも少ないメモリで済むかもしれません。</target>
        </trans-unit>
        <trans-unit id="24e84c8e00f2a5bb70e605cd2c69e1dd80d922f5" translate="yes" xml:space="preserve">
          <source>In some cases, yes. You can use the &lt;code&gt;iter&lt;/code&gt; class method to iterate over the files in the tarball without reading them all in memory at once.</source>
          <target state="translated">いくつかのケースでは、はい。 &lt;code&gt;iter&lt;/code&gt; クラスメソッドを使用すると、メモリ内のすべてのファイルを一度に読み取ることなく、tarball内のファイルを反復処理できます。</target>
        </trans-unit>
        <trans-unit id="da7c53f5c4edfd54be873e35b150cbb2e0f64102" translate="yes" xml:space="preserve">
          <source>In some cases, you may be able to make several patterns into a single regular expression. Beware of situations that require backtracking though.</source>
          <target state="translated">場合によっては、いくつかのパターンを一つの正規表現にすることができるかもしれません。しかし、バックトラックを必要とする状況には注意してください。</target>
        </trans-unit>
        <trans-unit id="55ed1ae3a3af36b978490ace319abb286ca584e8" translate="yes" xml:space="preserve">
          <source>In some cases, you'll want to completely skip an entire testing script.</source>
          <target state="translated">場合によっては、テストスクリプト全体を完全にスキップしたいこともあるでしょう。</target>
        </trans-unit>
        <trans-unit id="37bab3244974f03d4bcb3b02a30c6dfe56b096d6" translate="yes" xml:space="preserve">
          <source>In some contexts, a backslash followed by two or even one octal digits may be interpreted as an octal escape, sometimes with a warning, and because of some bugs, sometimes with surprising results. Also, if you are creating a regex out of smaller snippets concatenated together, and you use fewer than three digits, the beginning of one snippet may be interpreted as adding digits to the ending of the snippet before it. See &lt;a href=&quot;#Absolute-referencing&quot;&gt;&quot;Absolute referencing&quot;&lt;/a&gt; for more discussion and examples of the snippet problem.</source>
          <target state="translated">状況によっては、バックスラッシュの後に2桁または1桁の8進数が続く場合は、8進数のエスケープとして解釈されることがあり、警告が表示されることもあれば、バグが原因で予期しない結果が発生することもあります。また、連結された小さなスニペットから正規表現を作成していて、使用する数字が3桁未満の場合、1つのスニペットの先頭は、その前のスニペットの末尾に数字を追加すると解釈される場合があります。スニペットの問題の詳細と例については、&lt;a href=&quot;#Absolute-referencing&quot;&gt;「絶対参照」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b444fb6bd755ce68abe6b0c45e2101b6fb938848" translate="yes" xml:space="preserve">
          <source>In some contexts, a backslash followed by two or even one octal digits may be interpreted as an octal escape, sometimes with a warning, and because of some bugs, sometimes with surprising results. Also, if you are creating a regex out of smaller snippets concatenated together, and you use fewer than three digits, the beginning of one snippet may be interpreted as adding digits to the ending of the snippet before it. See &lt;a href=&quot;#Absolute-referencing&quot;&gt;Absolute referencing&lt;/a&gt; for more discussion and examples of the snippet problem.</source>
          <target state="translated">一部のコンテキストでは、バックスラッシュの後に2桁または1桁の8進数が続く場合、警告が出たり、バグが原因で、驚くべき結果になることもある8進エスケープとして解釈されることがあります。また、小さいスニペットを連結して正規表現を作成し、使用する数字が3桁未満の場合、1つのスニペットの先頭が、その前のスニペットの末尾に数字を追加すると解釈される場合があります。スニペットの問題の詳細と例については、&lt;a href=&quot;#Absolute-referencing&quot;&gt;絶対参照&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="941b228759db0ad2f21515f9edebce99234327a5" translate="yes" xml:space="preserve">
          <source>In some future version of I18N::LangTags, I plan to include support for RFC2482-style language tags -- which are basically just normal language tags with their ASCII characters shifted into Plane 14.</source>
          <target state="translated">I18N::LangTagsの将来のバージョンでは、RFC2482スタイルの言語タグのサポートを含めることを計画しています。</target>
        </trans-unit>
        <trans-unit id="b0260d31b907a523df71ffe831436a5256c0c0bb" translate="yes" xml:space="preserve">
          <source>In some literature this construct is called &quot;atomic matching&quot; or &quot;possessive matching&quot;.</source>
          <target state="translated">いくつかの文献では、この構成は「アトミック・マッチング」または「所有的マッチング」と呼ばれています。</target>
        </trans-unit>
        <trans-unit id="79419ef5fc7d87682a2736d33053a4e99ddcc17b" translate="yes" xml:space="preserve">
          <source>In some platforms it is not possible to get an alarm with subsecond resolution and later than one second.</source>
          <target state="translated">いくつかのプラットフォームでは、1秒以下の解像度でアラームを取得することはできません。</target>
        </trans-unit>
        <trans-unit id="6aef2a6b389cc51b9d270ade7d87dfa403f876dd" translate="yes" xml:space="preserve">
          <source>In some platforms there may be arbitrary amount of padding, for example space characters, after the modified name as shown by &lt;code&gt;ps&lt;/code&gt; . In some platforms this padding may extend all the way to the original length of the argument area, no matter what you do (this is the case for example with Linux 2.2).</source>
          <target state="translated">一部のプラットフォームでは、 &lt;code&gt;ps&lt;/code&gt; で示されるように、変更された名前の後にスペースなどの任意の量のパディングがある場合があります。一部のプラットフォームでは、このパディングは、何をしても、引数領域の元の長さにまで及ぶ場合があります（これは、たとえばLinux 2.2の場合です）。</target>
        </trans-unit>
        <trans-unit id="7f1ea5fc2fd23321facda4d50fc1cbae08642e40" translate="yes" xml:space="preserve">
          <source>In some platforms there may be arbitrary amount of padding, for example space characters, after the modified name as shown by &lt;code&gt;ps&lt;/code&gt;. In some platforms this padding may extend all the way to the original length of the argument area, no matter what you do (this is the case for example with Linux 2.2).</source>
          <target state="translated">一部のプラットフォームでは、 &lt;code&gt;ps&lt;/code&gt; で示されているように、変更された名前の後に、スペース文字などの任意の量のパディングが存在する場合があります。一部のプラットフォームでは、このパディングは、何をしても、引数領域の元の長さまで拡張される場合があります（これは、たとえばLinux 2.2の場合です）。</target>
        </trans-unit>
        <trans-unit id="08216ba09095e01bafc1d8f5f89aaf1f507c0440" translate="yes" xml:space="preserve">
          <source>In some situations you may want to prevent certain symbols from being exported. Typically this applies to extensions which have functions or constants that may not exist on some systems.</source>
          <target state="translated">状況によっては、特定のシンボルをエクスポートできないようにしたい場合もあるでしょう。通常、これはシステムによっては存在しない関数や定数を持つ拡張機能に適用されます。</target>
        </trans-unit>
        <trans-unit id="8e21d6f7b1ac2792e8d9bd0f52e8f29c7e8c027c" translate="yes" xml:space="preserve">
          <source>In some special cases, from_bytes() matches the conversion done by unpack():</source>
          <target state="translated">いくつかの特別なケースでは、 from_bytes()は unpack()で行われた変換にマッチします。</target>
        </trans-unit>
        <trans-unit id="7d2b095943328b792355034f8226aaf120447210" translate="yes" xml:space="preserve">
          <source>In specific, version numbers initialized as &lt;a href=&quot;#Decimal-Versions&quot;&gt;&quot;Decimal Versions&quot;&lt;/a&gt; will stringify as they were originally created (i.e. the same string that was passed to &lt;code&gt;new()&lt;/code&gt;. Version numbers initialized as &lt;a href=&quot;#Dotted-Decimal-Versions&quot;&gt;&quot;Dotted-Decimal Versions&quot;&lt;/a&gt; will be stringified as &lt;a href=&quot;#Normal-Form&quot;&gt;&quot;Normal Form&quot;&lt;/a&gt;.</source>
          <target state="translated">具体的には、&lt;a href=&quot;#Decimal-Versions&quot;&gt;「Decimal Versions」&lt;/a&gt;として初期化されたバージョン番号は、最初に作成されたとおりに文字列化されます（つまり、 &lt;code&gt;new()&lt;/code&gt; に渡されたのと同じ文字列です。&lt;a href=&quot;#Dotted-Decimal-Versions&quot;&gt;「Dotted-DecimalVersions」&lt;/a&gt;として初期化されたバージョン番号は「NormalForm」として文字化され&lt;a href=&quot;#Normal-Form&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f0ffd2574e55bd73781b2f238993d92b6b53578" translate="yes" xml:space="preserve">
          <source>In spite of its name,</source>
          <target state="translated">名前の割には</target>
        </trans-unit>
        <trans-unit id="9dba8e2fdad7dbac2aaec75e6f6e84418a6299a9" translate="yes" xml:space="preserve">
          <source>In spite of the name, this macro gives the correct result if the input string from which &lt;code&gt;c&lt;/code&gt; comes is not encoded in UTF-8.</source>
          <target state="translated">名前にもかかわらず、 &lt;code&gt;c&lt;/code&gt; が由来する入力文字列がUTF-8でエンコードされていない場合、このマクロは正しい結果を提供します。</target>
        </trans-unit>
        <trans-unit id="3a8cbd2876234fb0eafe4d9966f4f375e97df144" translate="yes" xml:space="preserve">
          <source>In such cases, to force an additional variable to be declared together with declarations of other variables, place the declaration into a PREINIT: section. The PREINIT: keyword may be used one or more times within an XSUB.</source>
          <target state="translated">このような場合、他の変数の宣言と一緒に追加の変数を強制的に宣言するには、その宣言をPREINIT:セクションに入れます。PREINIT:キーワードはXSUB内で1回以上使用することができます。</target>
        </trans-unit>
        <trans-unit id="ac9198f5929b9dd8df4d3b09d9577116cbbad276" translate="yes" xml:space="preserve">
          <source>In such cases, you are advised to either split the test file into smaller ones, or use a reverse approach, doing &quot;normal&quot; (code) compares and triggering &lt;code&gt;fail()&lt;/code&gt; should anything go unexpected.</source>
          <target state="translated">そのような場合は、テストファイルを小さいファイルに分割するか、逆のアプローチを使用して、「通常の」（コード）比較を行い、予期しない事態が発生した &lt;code&gt;fail()&lt;/code&gt; をトリガーすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a4b3a6172283064c4d2c38bcdfc1abf019578af1" translate="yes" xml:space="preserve">
          <source>In summary, Perl now normally treats non-Unicode code points as typical Unicode unassigned code points for regular expression matches, raising a warning only when it is arguable what the result should be. However, if this warning has been made fatal, it isn't skipped.</source>
          <target state="translated">要約すると、Perl は通常、正規表現のマッチのために Unicode 以外のコードポイントを典型的な Unicode 未割り当てコードポイントとして扱い、結果が何であるべきか議論が可能な場合にのみ警告を表示します。しかし、この警告が致命的なものになっている場合、警告はスキップされません。</target>
        </trans-unit>
        <trans-unit id="bdfe847eef52d0f5e340cab498d8b20a1e1ac3a3" translate="yes" xml:space="preserve">
          <source>In summary, a compiler backend module should be called &quot;B::Foo&quot; for some foo and live in the appropriate directory for that name. It should define a function called &lt;code&gt;compile&lt;/code&gt; . When the user types</source>
          <target state="translated">要約すると、コンパイラバックエンドモジュールは、一部のfooの場合は「B :: Foo」と呼ばれ、その名前の適切なディレクトリに存在する必要があります。 &lt;code&gt;compile&lt;/code&gt; という関数を定義する必要があります。ユーザーが入力したとき</target>
        </trans-unit>
        <trans-unit id="3b0a8b9a8c95f6fb4ee0c747c5c13c70148a1fb6" translate="yes" xml:space="preserve">
          <source>In summary, a compiler backend module should be called &quot;B::Foo&quot; for some foo and live in the appropriate directory for that name. It should define a function called &lt;code&gt;compile&lt;/code&gt;. When the user types</source>
          <target state="translated">要約すると、コンパイラバックエンドモジュールは、一部のfooでは「B :: Foo」と呼ばれ、その名前の適切なディレクトリに存在する必要があります。 &lt;code&gt;compile&lt;/code&gt; と呼ばれる関数を定義する必要があります。ユーザーが入力したとき</target>
        </trans-unit>
        <trans-unit id="fc74db358d542b3438f19ea437ddcca2306a63f1" translate="yes" xml:space="preserve">
          <source>In summary, local() doesn't make what you think of as private, local variables. It gives a global variable a temporary value. my() is what you're looking for if you want private variables.</source>
          <target state="translated">まとめると、local()はプライベートなローカル変数として考えているものを作りません。グローバル変数に一時的な値を与えます。 プライベート変数が欲しい場合は my()を使用します。</target>
        </trans-unit>
        <trans-unit id="ec6a62285f67e2d7161b800ebd3c834d396ca9bd" translate="yes" xml:space="preserve">
          <source>In summary:</source>
          <target state="translated">要約すると</target>
        </trans-unit>
        <trans-unit id="f27d5775b98cc1edc00b71d0a359c25acea44018" translate="yes" xml:space="preserve">
          <source>In telephony, the temporary electrical circuit between the caller&amp;rsquo;s and the callee&amp;rsquo;s phone. In networking, the same kind of temporary circuit between a &lt;b&gt;client&lt;/b&gt; and a &lt;b&gt;server&lt;/b&gt;.</source>
          <target state="translated">電話において、発信者と着信者の電話間の一時的な電気回路。ネットワーキングでは、&lt;b&gt;クライアント&lt;/b&gt;と&lt;b&gt;サーバー&lt;/b&gt;間の同じ種類の一時的な回線。</target>
        </trans-unit>
        <trans-unit id="c823f59ff2dd302aca99cff2c9b13c16174b9151" translate="yes" xml:space="preserve">
          <source>In that case, the value of the</source>
          <target state="translated">その場合には</target>
        </trans-unit>
        <trans-unit id="8a961ce11a5972421c4f26b07fe69c91b0c3c7f5" translate="yes" xml:space="preserve">
          <source>In the .xs file, there's now a #include directive with the absolute path to the mylib.h header file. We changed this to a relative path so that we could move the extension directory if we wanted to.</source>
          <target state="translated">.xs ファイルには、mylib.h ヘッダファイルへの絶対パスを持つ #include ディレクティブがあります。これを相対パスに変更して、必要に応じて拡張子ディレクトリを移動できるようにしました。</target>
        </trans-unit>
        <trans-unit id="f2ed93444f2e4f61ea8ed89fb84f5492a5e66658" translate="yes" xml:space="preserve">
          <source>In the 5.9.x development version of perl you can &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re Debug =&amp;gt; 'PARSE'&lt;/code&gt; to see some trace information about the parse process. We will start with some simple patterns and build up to more complex patterns.</source>
          <target state="translated">Perlの5.9.x開発バージョンでは &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re Debug =&amp;gt; 'PARSE'&lt;/code&gt; を使用して、解析プロセスに関するいくつかのトレース情報を表示できます。いくつかの単純なパターンから始めて、より複雑なパターンを構築します。</target>
        </trans-unit>
        <trans-unit id="79df17d32e87b2b81dcedf27e568b372a500063c" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;..&lt;/code&gt; or &lt;a href=&quot;perlop#Range-Operators&quot;&gt;range&lt;/a&gt; operator.</source>
          <target state="translated">で &lt;code&gt;..&lt;/code&gt; .または&lt;a href=&quot;perlop#Range-Operators&quot;&gt;範囲&lt;/a&gt;演算子。</target>
        </trans-unit>
        <trans-unit id="695cc6d82e9a098f429aaf4feaee8cd47933f5d7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;Encode&lt;/code&gt; module, &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; is actually a canonical name for &lt;code&gt;&quot;utf-8-strict&quot;&lt;/code&gt; . That hyphen between the &lt;code&gt;&quot;UTF&quot;&lt;/code&gt; and the &lt;code&gt;&quot;8&quot;&lt;/code&gt; is critical; without it, &lt;code&gt;Encode&lt;/code&gt; goes &quot;liberal&quot; and (perhaps overly-)permissive:</source>
          <target state="translated">で &lt;code&gt;Encode&lt;/code&gt; モジュール、 &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; 、実際の正規名である &lt;code&gt;&quot;utf-8-strict&quot;&lt;/code&gt; 。 &lt;code&gt;&quot;UTF&quot;&lt;/code&gt; と &lt;code&gt;&quot;8&quot;&lt;/code&gt; 間のハイフンは重要です。それがなければ、 &lt;code&gt;Encode&lt;/code&gt; は「リベラル」になり、（おそらく過度に）許容的になります。</target>
        </trans-unit>
        <trans-unit id="36d48d477c6e12e1ea532cffd25bfde82fe49f5d" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;Encode&lt;/code&gt; module, &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; is actually a canonical name for &lt;code&gt;&quot;utf-8-strict&quot;&lt;/code&gt;. That hyphen between the &lt;code&gt;&quot;UTF&quot;&lt;/code&gt; and the &lt;code&gt;&quot;8&quot;&lt;/code&gt; is critical; without it, &lt;code&gt;Encode&lt;/code&gt; goes &quot;liberal&quot; and (perhaps overly-)permissive:</source>
          <target state="translated">で &lt;code&gt;Encode&lt;/code&gt; モジュール、 &lt;code&gt;&quot;UTF-8&quot;&lt;/code&gt; 、実際の正規名である &lt;code&gt;&quot;utf-8-strict&quot;&lt;/code&gt; 。 &lt;code&gt;&quot;UTF&quot;&lt;/code&gt; と &lt;code&gt;&quot;8&quot;&lt;/code&gt; 間のハイフンは重要です。それがないと、 &lt;code&gt;Encode&lt;/code&gt; は「リベラル」になり、（おそらく過度に）寛容になります。</target>
        </trans-unit>
        <trans-unit id="b4feedfc56c9ca92e3c18dcd179dd65dfefb5217" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;SvPV&lt;/code&gt; macro, the length of the string returned is placed into the variable &lt;code&gt;len&lt;/code&gt; (this is a macro, so you do</source>
          <target state="translated">で &lt;code&gt;SvPV&lt;/code&gt; のマクロ、返される文字列の長さは、変数に入れられ &lt;code&gt;len&lt;/code&gt; あなたが行うので、これはマクロです（</target>
        </trans-unit>
        <trans-unit id="070901afbf1f09255274e8877eb8bc2c70b45164" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; form,</source>
          <target state="translated">では &lt;code&gt;\&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; 形、</target>
        </trans-unit>
        <trans-unit id="ee3da4d146e84bbefdc7f3a8d2819d53f2a9270e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;use VERSION&lt;/code&gt; form, VERSION may be either a v-string such as v5.24.1, which will be compared to &lt;a href=&quot;perlvar#%24%5EV&quot;&gt;&lt;code&gt;$^V&lt;/code&gt;&lt;/a&gt; (aka $PERL_VERSION), or a numeric argument of the form 5.024001, which will be compared to &lt;a href=&quot;perlvar#%24%5D&quot;&gt;&lt;code&gt;$]&lt;/code&gt;&lt;/a&gt;. An exception is raised if VERSION is greater than the version of the current Perl interpreter; Perl will not attempt to parse the rest of the file. Compare with &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;, which can do a similar check at run time. Symmetrically, &lt;code&gt;no VERSION&lt;/code&gt; allows you to specify that you want a version of Perl older than the specified one.</source>
          <target state="translated">&lt;code&gt;use VERSION&lt;/code&gt; 形態、VERSIONは、と比較されるようv5.24.1としてVストリング、のいずれであってもよい&lt;a href=&quot;perlvar#%24%5EV&quot;&gt; &lt;code&gt;$^V&lt;/code&gt; &lt;/a&gt;（別名$ PERL_VERSION）、またはと比較する形5.024001の数値引数、&lt;a href=&quot;perlvar#%24%5D&quot;&gt; &lt;code&gt;$]&lt;/code&gt; &lt;/a&gt;。 VERSIONが現在のPerlインタープリターのバージョンより大きい場合、例外が発生します。 Perlはファイルの残りの部分を解析しようとはしません。実行時に同様のチェックを実行できる&lt;a href=&quot;#require-VERSION&quot;&gt; &lt;code&gt;require&lt;/code&gt; と&lt;/a&gt;比較してください。対称的に、指定されたバージョンよりも古いバージョンのPerlが必要であることを指定できる &lt;code&gt;no VERSION&lt;/code&gt; はありません。</target>
        </trans-unit>
        <trans-unit id="95cc687da96e0b7f7623a95a00b37de925f9f2e9" translate="yes" xml:space="preserve">
          <source>In the C part of the XS file (above the first MODULE line) you have</source>
          <target state="translated">XS ファイルの C 部分 (MODULE の最初の行の上)には、以下のように記述されています。</target>
        </trans-unit>
        <trans-unit id="9da81592ea409347d5f06bd8bb3e9dfa81794242" translate="yes" xml:space="preserve">
          <source>In the RE above, which is intentionally obfuscated for illustration, the delimiter is &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;, the modifier is &lt;code&gt;mx&lt;/code&gt; , and after delimiter-removal the RE is the same as for &lt;code&gt;m/ ^ a \s* b /mx&lt;/code&gt; . There's more than one reason you're encouraged to restrict your delimiters to non-alphanumeric, non-whitespace choices.</source>
          <target state="translated">説明のために意図的に難読化されている上記のREでは、区切り文字は &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 、修飾子は &lt;code&gt;mx&lt;/code&gt; であり、区切り文字を削除した後のREは &lt;code&gt;m/ ^ a \s* b /mx&lt;/code&gt; と同じです。区切り文字を英数字や空白以外の選択肢に制限することをお勧めする理由は複数あります。</target>
        </trans-unit>
        <trans-unit id="4cfa0dc8147e78f76fb03859acf432fb6d2aa234" translate="yes" xml:space="preserve">
          <source>In the RE above, which is intentionally obfuscated for illustration, the delimiter is &lt;code&gt;m&lt;/code&gt;, the modifier is &lt;code&gt;mx&lt;/code&gt;, and after delimiter-removal the RE is the same as for &lt;code&gt;m/ ^ a \s* b /mx&lt;/code&gt;. There's more than one reason you're encouraged to restrict your delimiters to non-alphanumeric, non-whitespace choices.</source>
          <target state="translated">説明のために意図的に難読化された上記のREでは、区切り文字は &lt;code&gt;m&lt;/code&gt; 、修飾子は &lt;code&gt;mx&lt;/code&gt; であり、区切り文字を削除した後のREは &lt;code&gt;m/ ^ a \s* b /mx&lt;/code&gt; と同じです。区切り文字を英数字以外、空白以外の選択肢に制限することをお勧めする理由は複数あります。</target>
        </trans-unit>
        <trans-unit id="e13a699e1847e4e4560a850a3ff6592656db6884" translate="yes" xml:space="preserve">
          <source>In the above &quot;TAP&quot;, the second and fourth lines will generate &quot;Unknown&quot; tokens.</source>
          <target state="translated">上記の「TAP」では、2行目と4行目で「不明」のトークンが生成されます。</target>
        </trans-unit>
        <trans-unit id="058e91307a10961fd993a819105cb638818d3bdd" translate="yes" xml:space="preserve">
          <source>In the above [A, C] example, the &lt;code&gt;STORABLE_freeze&lt;/code&gt; hook could return:</source>
          <target state="translated">上記の[A、C]の例では、 &lt;code&gt;STORABLE_freeze&lt;/code&gt; のフックは、返すことができます。</target>
        </trans-unit>
        <trans-unit id="eb159de765838e35dcdde7356fd1bd005beb7684" translate="yes" xml:space="preserve">
          <source>In the above, the threads object is returned to the parent thread in scalar context, and the thread's entry point function &lt;code&gt;foo&lt;/code&gt; will be called in list (array) context such that the parent thread can receive a list (array) from the &lt;code&gt;-&amp;gt;join()&lt;/code&gt; call. (&lt;code&gt;'array'&lt;/code&gt; is synonymous with &lt;code&gt;'list'&lt;/code&gt; .)</source>
          <target state="translated">上記では、スレッドオブジェクトはスカラーコンテキストで親スレッドに返され、スレッドのエントリポイント関数 &lt;code&gt;foo&lt;/code&gt; はリスト（配列）コンテキストで呼び出され、親スレッドは &lt;code&gt;-&amp;gt;join()&lt;/code&gt; からリスト（配列）を受け取ることができます。（）の呼び出し。（ &lt;code&gt;'array'&lt;/code&gt; は &lt;code&gt;'list'&lt;/code&gt; と同義です。）</target>
        </trans-unit>
        <trans-unit id="e897db5f465666236003f392b985996d3d9611d4" translate="yes" xml:space="preserve">
          <source>In the above, the threads object is returned to the parent thread in scalar context, and the thread's entry point function &lt;code&gt;foo&lt;/code&gt; will be called in list (array) context such that the parent thread can receive a list (array) from the &lt;code&gt;-&amp;gt;join()&lt;/code&gt; call. (&lt;code&gt;'array'&lt;/code&gt; is synonymous with &lt;code&gt;'list'&lt;/code&gt;.)</source>
          <target state="translated">上記では、スレッドオブジェクトはスカラーコンテキストで親スレッドに返され、スレッドのエントリポイント関数 &lt;code&gt;foo&lt;/code&gt; は、親スレッドが &lt;code&gt;-&amp;gt;join()&lt;/code&gt; からリスト（配列）を受信できるように、リスト（配列）コンテキストで呼び出されます。（）呼び出します。（ &lt;code&gt;'array'&lt;/code&gt; は &lt;code&gt;'list'&lt;/code&gt; と同義です。）</target>
        </trans-unit>
        <trans-unit id="9d73b10ae1520507352b424e24dd93e5f334c96c" translate="yes" xml:space="preserve">
          <source>In the above, your &lt;code&gt;frobnicate&lt;/code&gt; function has been changed to be made aware of whether or not it's dealing with UTF-8 data, so that it can handle the string appropriately.</source>
          <target state="translated">上記では、 &lt;code&gt;frobnicate&lt;/code&gt; 関数が変更され、UTF-8データを処理しているかどうかを認識できるようになり、文字列を適切に処理できるようになりました。</target>
        </trans-unit>
        <trans-unit id="e3c7cb8befa26cf8853246bc9e4f9d7c53539559" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_COLLATE&lt;/code&gt; chooses the collation (sorting) locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_COLLATE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the collation locale.</source>
          <target state="translated">&lt;code&gt;LC_ALL&lt;/code&gt; がない場合、 &lt;code&gt;LC_COLLATE&lt;/code&gt; は照合（ソート）ロケールを選択します。 &lt;code&gt;LC_ALL&lt;/code&gt; と &lt;code&gt;LC_COLLATE&lt;/code&gt; の両方がない場合、 &lt;code&gt;LANG&lt;/code&gt; は照合ロケールを選択します。</target>
        </trans-unit>
        <trans-unit id="15ce031d9fce06ed575c3914c8c9ea6101622d1e" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_CTYPE&lt;/code&gt; chooses the character type locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the character type locale.</source>
          <target state="translated">&lt;code&gt;LC_ALL&lt;/code&gt; がない場合、 &lt;code&gt;LC_CTYPE&lt;/code&gt; は文字タイプのロケールを選択します。 &lt;code&gt;LC_ALL&lt;/code&gt; と &lt;code&gt;LC_CTYPE&lt;/code&gt; の両方がない場合、 &lt;code&gt;LANG&lt;/code&gt; は文字タイプのロケールを選択します。</target>
        </trans-unit>
        <trans-unit id="6468a6eaf61ca1746bc5af34d7e2d7db949b3755" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_MONETARY&lt;/code&gt; chooses the monetary formatting locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the monetary formatting locale.</source>
          <target state="translated">&lt;code&gt;LC_ALL&lt;/code&gt; がない場合、 &lt;code&gt;LC_MONETARY&lt;/code&gt; は通貨フォーマットロケールを選択します。 &lt;code&gt;LC_ALL&lt;/code&gt; と &lt;code&gt;LC_MONETARY&lt;/code&gt; の両方がない場合、 &lt;code&gt;LANG&lt;/code&gt; は通貨フォーマットロケールを選択します。</target>
        </trans-unit>
        <trans-unit id="aa4035e23872d9d83606fa0ea98c9a044e6d0674" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_NUMERIC&lt;/code&gt; chooses the numeric format locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_NUMERIC&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the numeric format.</source>
          <target state="translated">&lt;code&gt;LC_ALL&lt;/code&gt; がない場合、 &lt;code&gt;LC_NUMERIC&lt;/code&gt; は数値形式のロケールを選択します。 &lt;code&gt;LC_ALL&lt;/code&gt; と &lt;code&gt;LC_NUMERIC&lt;/code&gt; の両方がない場合、 &lt;code&gt;LANG&lt;/code&gt; は数値形式を選択します。</target>
        </trans-unit>
        <trans-unit id="6ab8079d22785df117a0b766ea8b7c3baae6e9c3" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_TIME&lt;/code&gt; chooses the date and time formatting locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_TIME&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; chooses the date and time formatting locale.</source>
          <target state="translated">&lt;code&gt;LC_ALL&lt;/code&gt; がない場合、 &lt;code&gt;LC_TIME&lt;/code&gt; は日付と時刻のフォーマットロケールを選択します。 &lt;code&gt;LC_ALL&lt;/code&gt; と &lt;code&gt;LC_TIME&lt;/code&gt; の両方がない場合、 &lt;code&gt;LANG&lt;/code&gt; は日付と時刻のフォーマットロケールを選択します。</target>
        </trans-unit>
        <trans-unit id="baa7ea095dc5ac2ae935e08f3403e4b2247a827b" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt;, &lt;code&gt;LC_COLLATE&lt;/code&gt; chooses the collation (sorting) locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_COLLATE&lt;/code&gt;, &lt;code&gt;LANG&lt;/code&gt; chooses the collation locale.</source>
          <target state="translated">&lt;code&gt;LC_ALL&lt;/code&gt; がない場合、 &lt;code&gt;LC_COLLATE&lt;/code&gt; は照合（ソート）ロケールを選択します。 &lt;code&gt;LC_ALL&lt;/code&gt; と &lt;code&gt;LC_COLLATE&lt;/code&gt; の両方がない場合、 &lt;code&gt;LANG&lt;/code&gt; は照合ロケールを選択します。</target>
        </trans-unit>
        <trans-unit id="43ec2099f7545c8e9b202ce433f85529dedee2a2" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt;, &lt;code&gt;LC_CTYPE&lt;/code&gt; chooses the character type locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_CTYPE&lt;/code&gt;, &lt;code&gt;LANG&lt;/code&gt; chooses the character type locale.</source>
          <target state="translated">&lt;code&gt;LC_ALL&lt;/code&gt; がない場合、 &lt;code&gt;LC_CTYPE&lt;/code&gt; は文字タイプのロケールを選択します。 &lt;code&gt;LC_ALL&lt;/code&gt; と &lt;code&gt;LC_CTYPE&lt;/code&gt; の両方がない場合、 &lt;code&gt;LANG&lt;/code&gt; は文字タイプのロケールを選択します。</target>
        </trans-unit>
        <trans-unit id="17060ec8d669313b51e7970818eee9376316ad91" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt;, &lt;code&gt;LC_MONETARY&lt;/code&gt; chooses the monetary formatting locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt;, &lt;code&gt;LANG&lt;/code&gt; chooses the monetary formatting locale.</source>
          <target state="translated">&lt;code&gt;LC_ALL&lt;/code&gt; がない場合、 &lt;code&gt;LC_MONETARY&lt;/code&gt; は通貨フォーマットロケールを選択します。 &lt;code&gt;LC_ALL&lt;/code&gt; と &lt;code&gt;LC_MONETARY&lt;/code&gt; の両方がない場合、 &lt;code&gt;LANG&lt;/code&gt; は通貨フォーマットロケールを選択します。</target>
        </trans-unit>
        <trans-unit id="f9caf17cd1367aa2fadeb5cf40ede5223f42444e" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt;, &lt;code&gt;LC_NUMERIC&lt;/code&gt; chooses the numeric format locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_NUMERIC&lt;/code&gt;, &lt;code&gt;LANG&lt;/code&gt; chooses the numeric format.</source>
          <target state="translated">&lt;code&gt;LC_ALL&lt;/code&gt; がない場合、 &lt;code&gt;LC_NUMERIC&lt;/code&gt; は数値形式のロケールを選択します。 &lt;code&gt;LC_ALL&lt;/code&gt; と &lt;code&gt;LC_NUMERIC&lt;/code&gt; の両方がない場合、 &lt;code&gt;LANG&lt;/code&gt; は数値形式を選択します。</target>
        </trans-unit>
        <trans-unit id="da232ff7cb7add5ab8264508686db664433513b3" translate="yes" xml:space="preserve">
          <source>In the absence of &lt;code&gt;LC_ALL&lt;/code&gt;, &lt;code&gt;LC_TIME&lt;/code&gt; chooses the date and time formatting locale. In the absence of both &lt;code&gt;LC_ALL&lt;/code&gt; and &lt;code&gt;LC_TIME&lt;/code&gt;, &lt;code&gt;LANG&lt;/code&gt; chooses the date and time formatting locale.</source>
          <target state="translated">&lt;code&gt;LC_ALL&lt;/code&gt; がない場合、 &lt;code&gt;LC_TIME&lt;/code&gt; は日付と時刻のフォーマットロケールを選択します。 &lt;code&gt;LC_ALL&lt;/code&gt; と &lt;code&gt;LC_TIME&lt;/code&gt; の両方がない場合、 &lt;code&gt;LANG&lt;/code&gt; は日付と時刻のフォーマットロケールを選択します。</target>
        </trans-unit>
        <trans-unit id="68e71f53c7f8acf89933bfc63a04da9641a2aa37" translate="yes" xml:space="preserve">
          <source>In the absence of parentheses, the precedence of list operators such as &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; is either very high or very low depending on whether you are looking at the left side or the right side of the operator. For example, in</source>
          <target state="translated">括弧がない場合、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt;&lt;/code&gt; などのリスト演算子の優先順位は、演算子の左側と右側のどちらを見ているかに応じて、非常に高いか非常に低くなります。たとえば、</target>
        </trans-unit>
        <trans-unit id="f77bc2d6be8faa985f9454517bf2c7fdaf4bd39e" translate="yes" xml:space="preserve">
          <source>In the absence of parentheses, the precedence of list operators such as &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;sort&lt;/code&gt;, or &lt;code&gt;chmod&lt;/code&gt; is either very high or very low depending on whether you are looking at the left side or the right side of the operator. For example, in</source>
          <target state="translated">括弧がない場合、 &lt;code&gt;print&lt;/code&gt; 、 &lt;code&gt;sort&lt;/code&gt; 、 &lt;code&gt;chmod&lt;/code&gt; などのリスト演算子の優先順位は、演算子の左側と右側のどちらを見ているかに応じて、非常に高くなるか、非常に低くなります。たとえば、</target>
        </trans-unit>
        <trans-unit id="8e8c77934a4391ccf6a1b211036cc4430a6aec4a" translate="yes" xml:space="preserve">
          <source>In the argument hashref,</source>
          <target state="translated">引数のhashrefで</target>
        </trans-unit>
        <trans-unit id="c8faecb0e00885cd9d3471fff022824b0e193793" translate="yes" xml:space="preserve">
          <source>In the beginning there was ASCII, the &quot;American Standard Code for Information Interchange&quot;, which works quite well for Americans with their English alphabet and dollar-denominated currency. But it doesn't work so well even for other English speakers, who may use different currencies, such as the pound sterling (as the symbol for that currency is not in ASCII); and it's hopelessly inadequate for many of the thousands of the world's other languages.</source>
          <target state="translated">当初はASCIIという「情報交換のためのアメリカ標準コード」がありましたが、これは英語のアルファベットとドル建ての通貨を使うアメリカ人にとっては非常にうまく機能しています。しかし、ポンドスターリングのような異なる通貨を使用する可能性のある他の英語話者にとっても、それはあまりうまく機能しません(通貨の記号がASCIIではないため)。</target>
        </trans-unit>
        <trans-unit id="4d58fb76f14dae3b712c2d1ef16b33d41abd7aa5" translate="yes" xml:space="preserve">
          <source>In the case of &lt;b&gt;-M&lt;/b&gt; and &lt;b&gt;-m&lt;/b&gt;, this is an error because those options are not intended for use inside scripts. Use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; pragma instead.</source>
          <target state="translated">&lt;b&gt;-M&lt;/b&gt;および&lt;b&gt;-mの&lt;/b&gt;場合、これらのオプションはスクリプト内での使用を目的としていないため、これはエラーです。代わりに &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; プラグマを使用してください。</target>
        </trans-unit>
        <trans-unit id="aa2dc1d853a0888a9b4beead512f4c24741b70d4" translate="yes" xml:space="preserve">
          <source>In the case of &lt;b&gt;-M&lt;/b&gt; and &lt;b&gt;-m&lt;/b&gt;, this is an error because those options are not intended for use inside scripts. Use the &lt;code&gt;use&lt;/code&gt; pragma instead.</source>
          <target state="translated">&lt;b&gt;-M&lt;/b&gt;および&lt;b&gt;-mの&lt;/b&gt;場合、これらのオプションはスクリプト内での使用を目的としていないため、これはエラーです。代わりに &lt;code&gt;use&lt;/code&gt; プラグマを使用してください。</target>
        </trans-unit>
        <trans-unit id="468d95254e2569de4c93c44e90ecaaab6e1c8a96" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;(normalization =&amp;gt; &quot;prenormalized&quot;)&lt;/code&gt; , any normalization is not performed, but discontiguous contractions with combining characters are performed. Therefore &lt;code&gt;(normalization =&amp;gt; 'prenormalized', preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt;&lt;b&gt;is&lt;/b&gt; equivalent to &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; . If source strings are finely prenormalized, &lt;code&gt;(normalization =&amp;gt; 'prenormalized')&lt;/code&gt; may save time for normalization.</source>
          <target state="translated">以下の場合には &lt;code&gt;(normalization =&amp;gt; &quot;prenormalized&quot;)&lt;/code&gt; 、任意の正規化が行われず、結合文字で不連続な収縮が行われます。したがって、 &lt;code&gt;(normalization =&amp;gt; 'prenormalized', preprocess =&amp;gt; &lt;a href=&quot;../functions/sub&quot;&gt;sub&lt;/a&gt; { NFD(&lt;a href=&quot;../functions/shift&quot;&gt;shift&lt;/a&gt;) })&lt;/code&gt; &lt;b&gt;は&lt;/b&gt; &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; &lt;b&gt;と&lt;/b&gt;同等です。ソース文字列が細かく事前 &lt;code&gt;(normalization =&amp;gt; 'prenormalized')&lt;/code&gt; されている場合、（正規化=&amp;gt; '事前正規化'）は正規化の時間を節約できます。</target>
        </trans-unit>
        <trans-unit id="e14cf0303bff15e63f1d4bb8fb829c422640cba4" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;(normalization =&amp;gt; &quot;prenormalized&quot;)&lt;/code&gt;, any normalization is not performed, but discontiguous contractions with combining characters are performed. Therefore &lt;code&gt;(normalization =&amp;gt; 'prenormalized', preprocess =&amp;gt; sub { NFD(shift) })&lt;/code&gt;&lt;b&gt;is&lt;/b&gt; equivalent to &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt;. If source strings are finely prenormalized, &lt;code&gt;(normalization =&amp;gt; 'prenormalized')&lt;/code&gt; may save time for normalization.</source>
          <target state="translated">以下の場合には &lt;code&gt;(normalization =&amp;gt; &quot;prenormalized&quot;)&lt;/code&gt; 、任意の正規化が行われず、結合文字を不連続収縮が行われます。したがって、 &lt;code&gt;(normalization =&amp;gt; 'prenormalized', preprocess =&amp;gt; sub { NFD(shift) })&lt;/code&gt; &lt;b&gt;は&lt;/b&gt; &lt;code&gt;(normalization =&amp;gt; 'NFD')&lt;/code&gt; &lt;b&gt;と&lt;/b&gt;同等です。ソース文字列が細かく事前 &lt;code&gt;(normalization =&amp;gt; 'prenormalized')&lt;/code&gt; されている場合（正規化=&amp;gt; '事前正規化'）、正規化の時間を節約できます。</target>
        </trans-unit>
        <trans-unit id="5830f7641c2c9f00de57771005c708cf9a4d5c74" translate="yes" xml:space="preserve">
          <source>In the case of a perl test suite, typically</source>
          <target state="translated">Perl のテストスイートの場合、通常は</target>
        </trans-unit>
        <trans-unit id="93b5501796f0c8e106f09c3c3a171aba6b8b3835" translate="yes" xml:space="preserve">
          <source>In the case of a shared array, all the array's elements are shared, and for a shared hash, all the keys and values are shared. This places restrictions on what may be assigned to shared array and hash elements: only simple values or references to shared variables are allowed - this is so that a private variable can't accidentally become shared. A bad assignment will cause the thread to die. For example:</source>
          <target state="translated">共有配列の場合、配列のすべての要素が共有され、共有ハッシュの場合はすべてのキーと値が共有されます。これにより、共有配列やハッシュの要素に代入できるものが制限されます。 単純な値や共有変数への参照のみが許可されます。これは、プライベート変数が誤って共有されてしまうことを防ぐためです。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="2e771b6edcf0a67e48248188d99cc8c1ee77f6d9" translate="yes" xml:space="preserve">
          <source>In the case of a string, &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; assumes you are wanting to load a file. But in the case of a bareword, it assumes you mean a module.</source>
          <target state="translated">文字列の場合、 &lt;code&gt;&lt;a href=&quot;../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; はファイルをロードすることを想定しています。しかし、裸語の場合、それはあなたがモジュールを意味すると仮定します。</target>
        </trans-unit>
        <trans-unit id="ac24b60f2e88b7aed91e2ca7c78a3affc1277034" translate="yes" xml:space="preserve">
          <source>In the case of a string, &lt;code&gt;require&lt;/code&gt; assumes you are wanting to load a file. But in the case of a bareword, it assumes you mean a module.</source>
          <target state="translated">文字列の場合、 &lt;code&gt;require&lt;/code&gt; は、ファイルをロードすることを想定しています。しかし、ベアワードの場合、それはあなたがモジュールを意味すると仮定します。</target>
        </trans-unit>
        <trans-unit id="92d133184cc1d94941d92f9ddbb74be254d7536c" translate="yes" xml:space="preserve">
          <source>In the case of an unrestricted hash this will be equivalent to</source>
          <target state="translated">制限のないハッシュの場合、これは</target>
        </trans-unit>
        <trans-unit id="9c7996f6bbe611631e0062a5b0c8688fa0df75c4" translate="yes" xml:space="preserve">
          <source>In the case of an unrestricted hash this will return an empty list.</source>
          <target state="translated">制限のないハッシュの場合、これは空のリストを返します。</target>
        </trans-unit>
        <trans-unit id="bbcb89949ef30fa331653e26c292cc6bfd5402d5" translate="yes" xml:space="preserve">
          <source>In the case of branching constructs like the following:</source>
          <target state="translated">のような分岐構造の場合。</target>
        </trans-unit>
        <trans-unit id="f5299444f09060df2c8b59facc0396320022caaf" translate="yes" xml:space="preserve">
          <source>In the case of sharing phrases, consider that you have an interface already localized for American English (probably by having been written with that as the native locale, but that's incidental). Localizing it for UK English should, in practical terms, be just a matter of running it past a British person with the instructions to indicate what few phrases would benefit from a change in spelling or possibly minor rewording. In that case, you should be able to put in the UK English localization module</source>
          <target state="translated">フレーズを共有する場合、アメリカ英語用にローカライズされたインターフェイスを持っていることを考えてみてください(おそらくネイティブロケールとして書かれたものだと思いますが、それは付随的なものです)。イギリス英語用にローカライズした場合、実用的には、イギリス人にスペルを変えたり、ちょっとした言い回しを変えた方がいいフレーズを教えてもらうだけでいいでしょう。その場合、イギリス英語のローカライズモジュールを入れることができるはずです。</target>
        </trans-unit>
        <trans-unit id="235ed9f8205c1cb0e0f0c89543ab0c301b45cc8b" translate="yes" xml:space="preserve">
          <source>In the case where bsd_glob() has found some matching paths, but is interrupted by an error, it will return a list of filenames &lt;b&gt;and&lt;/b&gt; set &amp;amp;File::Glob::ERROR.</source>
          <target state="translated">bsd_glob（）が一致するパスをいくつか見つけたが、エラーによって中断された場合、ファイル名のリストを返し、＆File :: Glob :: ERROR &lt;b&gt;を&lt;/b&gt;設定します。</target>
        </trans-unit>
        <trans-unit id="ab44e54a843289d8fb48be15296e74831fd77123" translate="yes" xml:space="preserve">
          <source>In the cases of NFD, NFKD, and FCD, the answer must be either &lt;code&gt;YES&lt;/code&gt; or &lt;code&gt;NO&lt;/code&gt; . The answer &lt;code&gt;MAYBE&lt;/code&gt; may be returned in the cases of NFC, NFKC, and FCC.</source>
          <target state="translated">NFD、NFKD、およびFCDの場合、答えは &lt;code&gt;YES&lt;/code&gt; または &lt;code&gt;NO&lt;/code&gt; でなければなりません。答えは &lt;code&gt;MAYBE&lt;/code&gt; NFC、NFKC、およびFCCの場合に返されることがあります。</target>
        </trans-unit>
        <trans-unit id="a9290433a82e6cf3e26db0b835cf369ebaa80c05" translate="yes" xml:space="preserve">
          <source>In the cases of NFD, NFKD, and FCD, the answer must be either &lt;code&gt;YES&lt;/code&gt; or &lt;code&gt;NO&lt;/code&gt;. The answer &lt;code&gt;MAYBE&lt;/code&gt; may be returned in the cases of NFC, NFKC, and FCC.</source>
          <target state="translated">NFD、NFKD、およびFCDの場合、答えは &lt;code&gt;YES&lt;/code&gt; または &lt;code&gt;NO&lt;/code&gt; のいずれかである必要があります。答えは &lt;code&gt;MAYBE&lt;/code&gt; NFC、NFKC、およびFCCの場合に返されることがあります。</target>
        </trans-unit>
        <trans-unit id="94e0ab2727afbd4185da2de81e38250408bd5cc4" translate="yes" xml:space="preserve">
          <source>In the code below, the use of &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; can all produce a &lt;code&gt;&quot;Useless use of xxx in void context&quot;&lt;/code&gt; warning.</source>
          <target state="translated">以下のコードでは、 &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;&quot;Useless use of xxx in void context&quot;&lt;/code&gt; すると、すべて「無効なコンテキストでのxxxの無用な使用」警告が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="83084455671be2342089bb45fada8c84af832860" translate="yes" xml:space="preserve">
          <source>In the code below, the use of &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt; can all produce a &lt;code&gt;&quot;Useless use of xxx in void context&quot;&lt;/code&gt; warning.</source>
          <target state="translated">以下のコードでは、 &lt;code&gt;time&lt;/code&gt; 、 &lt;code&gt;length&lt;/code&gt; 、 &lt;code&gt;join&lt;/code&gt; を &lt;code&gt;&quot;Useless use of xxx in void context&quot;&lt;/code&gt; すると、すべて「voidコンテキストでのxxxの無用な使用」という警告が生成される可能性があります。</target>
        </trans-unit>
        <trans-unit id="8fd1596cdd97dc35baf217614ea25fccb283e4de" translate="yes" xml:space="preserve">
          <source>In the consideration of speed against memory requirements the balance has been tilted in favor of faster execution. This has influenced the way C compilers allocate memory for structures: On architectures where a 16-bit or 32-bit operand can be moved faster between places in memory, or to or from a CPU register, if it is aligned at an even or multiple-of-four or even at a multiple-of eight address, a C compiler will give you this speed benefit by stuffing extra bytes into structures. If you don't cross the C shoreline this is not likely to cause you any grief (although you should care when you design large data structures, or you want your code to be portable between architectures (you do want that, don't you?)).</source>
          <target state="translated">メモリ要件に対する速度を考慮すると、バランスはより高速な実行に有利に傾いてきました。これはCコンパイラが構造体にメモリを割り当てる方法に影響を与えています。16ビットや32ビットのオペランドがメモリ内の場所間やCPUレジスタとの間を高速に移動できるアーキテクチャでは、偶数アドレスや4の倍数アドレス、8の倍数アドレスにアラインメントされている場合、Cコンパイラは構造体に余分なバイトを詰め込むことで、この速度の利点を提供しています。C の海岸線を渡らないのであれば、このようなことをしても問題になることはありません(ただし、大きなデータ構造を設計する場合や、アーキテクチャ間でコードを移植したい場合は注意が必要です(そうしたいですよね?</target>
        </trans-unit>
        <trans-unit id="9d33a076ef77a2ea3c1cd018606852167138e6c8" translate="yes" xml:space="preserve">
          <source>In the context of the</source>
          <target state="translated">の文脈では</target>
        </trans-unit>
        <trans-unit id="36e06d755cd3fd5bf54637378805e22f4acd5720" translate="yes" xml:space="preserve">
          <source>In the course of hacking on the Perl core distribution, you may have occasion to configure, build and test perl at an old commit. Sometimes &lt;code&gt;make&lt;/code&gt; will fail during this process. If that happens, you may be able to salvage the situation by using the Devel::PatchPerl library from CPAN (not included in the core) to bring the source code at that commit to a buildable state.</source>
          <target state="translated">Perlコアディストリビューションをハッキングする過程で、古いコミットでperlを構成、ビルド、テストする機会があるかもしれません。このプロセス中に &lt;code&gt;make&lt;/code&gt; が失敗することがあります。その場合は、CPAN（コアには含まれていません）のDevel :: PatchPerlライブラリを使用して、そのコミット時のソースコードをビルド可能な状態にすることで、状況を改善できる可能性があります。</target>
        </trans-unit>
        <trans-unit id="f4abaa133201d3b086e220fd2a8825f9d8810e3d" translate="yes" xml:space="preserve">
          <source>In the current implementation, scalar constants are actually inlinable subroutines. As of version 5.004 of Perl, the appropriate scalar constant is inserted directly in place of some subroutine calls, thereby saving the overhead of a subroutine call. See &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;&quot;Constant Functions&quot; in perlsub&lt;/a&gt; for details about how and when this happens.</source>
          <target state="translated">現在の実装では、スカラー定数は実際にはインライン化できないサブルーチンです。Perlのバージョン5.004以降、一部のサブルーチン呼び出しの代わりに適切なスカラー定数が直接挿入されるため、サブルーチン呼び出しのオーバーヘッドが節約されます。参照&lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;はperlsubに「定数関数」を&lt;/a&gt;どのようにしてこの問題が発生したときの詳細については。</target>
        </trans-unit>
        <trans-unit id="d491c48b25f3ad65e82b4c5c2097be0b50a9588c" translate="yes" xml:space="preserve">
          <source>In the current implementation, scalar constants are actually inlinable subroutines. As of version 5.004 of Perl, the appropriate scalar constant is inserted directly in place of some subroutine calls, thereby saving the overhead of a subroutine call. See &lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;Constant Functions in perlsub&lt;/a&gt; for details about how and when this happens.</source>
          <target state="translated">現在の実装では、スカラー定数は実際にはインライン化可能なサブルーチンです。Perlのバージョン5.004以降、一部のサブルーチン呼び出しの代わりに適切なスカラー定数が直接挿入されるため、サブルーチン呼び出しのオーバーヘッドを節約できます。これがいつどのように発生するかについての詳細は&lt;a href=&quot;perlsub#Constant-Functions&quot;&gt;、perlsubの定数関数を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3c0455a3b2b53d95f4e20ec0b4340a717b68f76c" translate="yes" xml:space="preserve">
          <source>In the default case where no value is explicitly assigned to &lt;code&gt;fallback&lt;/code&gt; , magic autogeneration is enabled.</source>
          <target state="translated">&lt;code&gt;fallback&lt;/code&gt; に明示的に値が割り当てられていないデフォルトの場合、魔法の自動生成が有効になります。</target>
        </trans-unit>
        <trans-unit id="c9f523dc0714c247e84ee8251b5363ace685ef46" translate="yes" xml:space="preserve">
          <source>In the default case where no value is explicitly assigned to &lt;code&gt;fallback&lt;/code&gt;, magic autogeneration is enabled.</source>
          <target state="translated">&lt;code&gt;fallback&lt;/code&gt; 値が明示的に割り当てられていないデフォルトの場合、マジックの自動生成が有効になっています。</target>
        </trans-unit>
        <trans-unit id="9458e90e2a5f3acd753b6153a03f2c183bb3d3dd" translate="yes" xml:space="preserve">
          <source>In the default case, the events corresponding to &lt;code&gt;=encoding&lt;/code&gt; directives are not emitted. They are emitted if &lt;code&gt;keep_encoding_directive&lt;/code&gt; is true. In that case they produce event structures like &lt;a href=&quot;#events-with-an-element_name-of-head1-..-head4&quot;&gt;&quot;events with an element_name of head1 .. head4&quot;&lt;/a&gt; above.</source>
          <target state="translated">デフォルトの場合、 &lt;code&gt;=encoding&lt;/code&gt; ディレクティブに対応するイベントは発行されません。 &lt;code&gt;keep_encoding_directive&lt;/code&gt; がtrueの場合に発行されます。その場合、上記の&lt;a href=&quot;#events-with-an-element_name-of-head1-..-head4&quot;&gt;「element_nameがhead1 ..head4のイベント」の&lt;/a&gt;ようなイベント構造を生成します。</target>
        </trans-unit>
        <trans-unit id="23054b89eefbfee4eec8f7b57971efe41724413f" translate="yes" xml:space="preserve">
          <source>In the default configuration, options names may be abbreviated to uniqueness, case does not matter, and a single dash is sufficient, even for long option names. Also, options may be placed between non-option arguments. See &lt;a href=&quot;#Configuring-Getopt%3A%3ALong&quot;&gt;&quot;Configuring Getopt::Long&quot;&lt;/a&gt; for more details on how to configure Getopt::Long.</source>
          <target state="translated">デフォルトの構成では、オプション名は一意性に省略される場合があり、大文字と小文字は区別されません。長いオプション名の場合でも、ダッシュは1つで十分です。また、オプションはオプション以外の引数の間に配置することもできます。参照してください&lt;a href=&quot;#Configuring-Getopt%3A%3ALong&quot;&gt;「の設定にGetopt ::ロング」を&lt;/a&gt;Getoptの::ロングを設定する方法の詳細については。</target>
        </trans-unit>
        <trans-unit id="9e4e78aa2b33a6d6dac51bbc3211d37de72733b0" translate="yes" xml:space="preserve">
          <source>In the default configuration, options names may be abbreviated to uniqueness, case does not matter, and a single dash is sufficient, even for long option names. Also, options may be placed between non-option arguments. See &lt;a href=&quot;#Configuring-Getopt%3a%3aLong&quot;&gt;Configuring Getopt::Long&lt;/a&gt; for more details on how to configure Getopt::Long.</source>
          <target state="translated">デフォルトの構成では、オプション名は一意に短縮される場合があり、大文字と小文字は関係ありません。長いオプション名であっても、ダッシュは1つで十分です。また、オプションは非オプション引数の間に置くことができます。参照&lt;a href=&quot;#Configuring-Getopt%3a%3aLong&quot;&gt;設定Getoptの::ロング&lt;/a&gt; Getoptの::ロングを設定する方法の詳細については。</target>
        </trans-unit>
        <trans-unit id="e72101fd159fd0afaf983f558f5b87febb7113ce" translate="yes" xml:space="preserve">
          <source>In the description it is mentioned that</source>
          <target state="translated">説明の中では、次のように述べられています。</target>
        </trans-unit>
        <trans-unit id="ef03d8c00322da2ed4dc98f0803a382ee30a4ed1" translate="yes" xml:space="preserve">
          <source>In the diagram, the further right you go the more deeply nested the scope is. It is only when control is back with perl on the extreme left of the diagram that you will have dropped back to the enclosing scope and any temporaries you have left hanging around will be freed.</source>
          <target state="translated">図では、右に行くほどスコープは深く入れ子になっています。制御が図の左端にあるperlに戻って初めて、スコープを囲んでいる状態に戻り、ぶら下がったままにしておいたテンポラリが解放されることになります。</target>
        </trans-unit>
        <trans-unit id="a19348facef1eccdb0bfe0058ba391b435c7d989" translate="yes" xml:space="preserve">
          <source>In the directory where you unpacked the sources, issue the familiar commands:</source>
          <target state="translated">ソースを解凍したディレクトリで、おなじみのコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="6f416a980a416e375bc66bc2d4fa36e45d3dee04" translate="yes" xml:space="preserve">
          <source>In the event that your XS code may need the underlying &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale, there are macros available to access this; see &lt;a href=&quot;perlapi#Locale-related-functions-and-macros&quot;&gt;Locale-related functions and macros in perlapi&lt;/a&gt;.</source>
          <target state="translated">XSコードが基本的な &lt;code&gt;LC_NUMERIC&lt;/code&gt; ロケールを必要とする場合、これにアクセスするために利用可能なマクロがあります。&lt;a href=&quot;perlapi#Locale-related-functions-and-macros&quot;&gt;perlapiのロケール関連の関数とマクロを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cf76bf6bac3fdd00f94042b70f25cd2c0127da6a" translate="yes" xml:space="preserve">
          <source>In the example above $DB_HASH is actually a pre-defined reference to a hash object. &lt;b&gt;DB_File&lt;/b&gt; has three of these pre-defined references. Apart from $DB_HASH, there is also $DB_BTREE and $DB_RECNO.</source>
          <target state="translated">上記の例では、$ DB_HASHは実際にはハッシュオブジェクトへの事前定義された参照です。&lt;b&gt;DB_Fileに&lt;/b&gt;は、これらの定義済み参照が3つあります。$ DB_HASHの他に、$ DB_BTREEと$ DB_RECNOもあります。</target>
        </trans-unit>
        <trans-unit id="f9fdb8bfd43fe6e2a44475d6d573995092816442" translate="yes" xml:space="preserve">
          <source>In the example above for &lt;code&gt;no_index&lt;/code&gt;, &lt;code&gt;My::Module::Sample::Foo&lt;/code&gt; would be ignored, but &lt;code&gt;My::Module::Sample&lt;/code&gt; would not.</source>
          <target state="translated">上記の &lt;code&gt;no_index&lt;/code&gt; の例では、 &lt;code&gt;My::Module::Sample::Foo&lt;/code&gt; は無視されますが、 &lt;code&gt;My::Module::Sample&lt;/code&gt; は無視されません。</target>
        </trans-unit>
        <trans-unit id="383bad82dbf36df5fcbc2607474fc2833874c49f" translate="yes" xml:space="preserve">
          <source>In the example above, no file in</source>
          <target state="translated">上記の例では</target>
        </trans-unit>
        <trans-unit id="a6fdb80f186445ea957d140c9ee93d85c7f7bc67" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; method returns as soon as the thread ends. In addition to waiting for a thread to finish and gathering up any values that the thread might have returned, &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; also performs any OS cleanup necessary for the thread. That cleanup might be important, especially for long-running programs that spawn lots of threads. If you don't want the return values and don't want to wait for the thread to finish, you should call the &lt;code&gt;detach()&lt;/code&gt; method instead, as described next.</source>
          <target state="translated">上記の例では、スレッドが終了するとすぐに &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; メソッドが返されます。スレッドが終了するのを待ち、スレッドが返した可能性のある値を収集することに加えて、 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; はスレッドに必要なOSクリーンアップも実行します。このクリーンアップは、特に多くのスレッドを生成する長時間実行プログラムにとって重要になる場合があります。戻り値が不要で、スレッドが終了するまで待機したくない場合は、次に説明するように、代わりに &lt;code&gt;detach()&lt;/code&gt; メソッドを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="95d3b55907325681c5f8c375c41d335ffa7d8ded" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;join()&lt;/code&gt; method returns as soon as the thread ends. In addition to waiting for a thread to finish and gathering up any values that the thread might have returned, &lt;code&gt;join()&lt;/code&gt; also performs any OS cleanup necessary for the thread. That cleanup might be important, especially for long-running programs that spawn lots of threads. If you don't want the return values and don't want to wait for the thread to finish, you should call the &lt;code&gt;detach()&lt;/code&gt; method instead, as described next.</source>
          <target state="translated">上記の例では、 &lt;code&gt;join()&lt;/code&gt; メソッドはスレッドが終了するとすぐに戻ります。 &lt;code&gt;join()&lt;/code&gt; は、スレッドが終了するのを待って、スレッドが返した可能性のある値を収集するだけでなく、スレッドに必要なOSのクリーンアップも実行します。このクリーンアップは、特に大量のスレッドを生成する長時間実行プログラムの場合に重要になる可能性があります。戻り値が不要で、スレッドが終了するのを待ちたくない場合は、次に説明するように、代わりに &lt;code&gt;detach()&lt;/code&gt; メソッドを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="c0aec8a73878fae65e2fc321ef79436b2e98a6ee" translate="yes" xml:space="preserve">
          <source>In the example above, the true parent does not want to write to the $writer filehandle, so it closes it. However, because $writer was opened using &lt;code&gt;open $fh, &quot;|-&quot;&lt;/code&gt;, it has a special behavior: closing it calls waitpid() (see &lt;a href=&quot;perlfunc#waitpid&quot;&gt;&quot;waitpid&quot; in perlfunc&lt;/a&gt;), which waits for the subprocess to exit. If the child process ends up waiting for something happening in the section marked &quot;do something else&quot;, you have deadlock.</source>
          <target state="translated">上記の例では、真の親は$ writerファイルハンドルに書き込みたくないので、それを閉じます。ただし、$ writerは &lt;code&gt;open $fh, &quot;|-&quot;&lt;/code&gt; を使用して開かれたため、特別な動作があります。閉じると、サブプロセスが終了するのを待つwaitpid（）（&lt;a href=&quot;perlfunc#waitpid&quot;&gt;perlfuncの &quot;waitpid&quot;を&lt;/a&gt;参照）が呼び出されます。子プロセスが「何か他のことをする」とマークされたセクションで何かが起こるのを待つことになった場合、デッドロックが発生します。</target>
        </trans-unit>
        <trans-unit id="e4fb9b67eb5a1d7e86fa97df408aad4ebc6c2e68" translate="yes" xml:space="preserve">
          <source>In the example above, the true parent does not want to write to the WRITER filehandle, so it closes it. However, because WRITER was opened using &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; , it has a special behavior: closing it calls waitpid() (see &lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;), which waits for the subprocess to exit. If the child process ends up waiting for something happening in the section marked &quot;do something else&quot;, you have deadlock.</source>
          <target state="translated">上記の例では、真の親はWRITERファイルハンドルへの書き込みを望まないため、それを閉じます。ただし、WRITERは &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; FH, &quot;|-&quot;&lt;/code&gt; を使用して開かれたため、特別な動作があります。閉じると、サブプロセスの終了を待機するwaitpid（）（&lt;a href=&quot;functions/waitpid&quot;&gt;waitpidを&lt;/a&gt;参照）が呼び出されます。子プロセスが「何か他のことをする」とマークされたセクションで何かが起こるのを待つことになる場合、デッドロックがあります。</target>
        </trans-unit>
        <trans-unit id="e18ac50c69f2e5daf082fad97b93479b32118e7a" translate="yes" xml:space="preserve">
          <source>In the example above, we've created a global variable to temporarily store the computed value of our eval'ed expression. It is also possible and in most cases a better strategy to fetch the return value from</source>
          <target state="translated">上の例では、evalされた式の計算値を一時的に保存するためにグローバル変数を作成しました。から戻り値を取得することも可能ですし、ほとんどの場合はより良い方法です。</target>
        </trans-unit>
        <trans-unit id="215f011f187069670df6baefac97d219cfd4d544" translate="yes" xml:space="preserve">
          <source>In the example above, you can see that we passed &lt;code&gt;isa =&amp;gt; 'Bool'&lt;/code&gt; to &lt;code&gt;has()&lt;/code&gt; when creating our &lt;code&gt;is_on&lt;/code&gt; attribute. This tells &lt;code&gt;Moose&lt;/code&gt; that this attribute must be a boolean value. If we try to set it to an invalid value, our code will throw an error.</source>
          <target state="translated">上記の例では、 &lt;code&gt;is_on&lt;/code&gt; 属性を作成するときに &lt;code&gt;isa =&amp;gt; 'Bool'&lt;/code&gt; を &lt;code&gt;has()&lt;/code&gt; に渡したことがわかります。これは、この属性がブール値でなければならないことを &lt;code&gt;Moose&lt;/code&gt; に伝えます。それを無効な値に設定しようとすると、コードはエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="7091546bde153dd7889f18e20c48c8bc55eaa567" translate="yes" xml:space="preserve">
          <source>In the example filter, the object (&lt;code&gt;$ref&lt;/code&gt; ) is blessed just like any other Perl object. Our example uses an anonymous array, but this isn't a requirement. Because this example doesn't need to store any context information, we could have used a scalar or hash reference just as well. The next section demonstrates context data.</source>
          <target state="translated">フィルタの例では、オブジェクト（ &lt;code&gt;$ref&lt;/code&gt; ）は他のPerlオブジェクトと同じように祝福されています。この例では無名配列を使用していますが、これは必須ではありません。この例ではコンテキスト情報を格納する必要がないため、スカラーまたはハッシュ参照も使用できます。次のセクションでは、コンテキストデータを示します。</target>
        </trans-unit>
        <trans-unit id="21a83782fbb9be8126f7468757dd72bbc0bf6692" translate="yes" xml:space="preserve">
          <source>In the example filter, the object (&lt;code&gt;$ref&lt;/code&gt;) is blessed just like any other Perl object. Our example uses an anonymous array, but this isn't a requirement. Because this example doesn't need to store any context information, we could have used a scalar or hash reference just as well. The next section demonstrates context data.</source>
          <target state="translated">サンプルフィルターでは、オブジェクト（ &lt;code&gt;$ref&lt;/code&gt; ）は他のPerlオブジェクトと同じように祝福されています。この例では匿名配列を使用していますが、これは必須ではありません。この例ではコンテキスト情報を格納する必要がないため、スカラーまたはハッシュ参照を使用することもできます。次のセクションでは、コンテキストデータについて説明します。</target>
        </trans-unit>
        <trans-unit id="7cad79aaf9d1ce6eabd545156fa679d72897f6d5" translate="yes" xml:space="preserve">
          <source>In the example script below, the &lt;code&gt;match&lt;/code&gt; sub uses this feature to find and print the first matching key/value pair given a partial key.</source>
          <target state="translated">以下のスクリプト例では、 &lt;code&gt;match&lt;/code&gt; サブルーチンはこの機能を使用して、部分的なキーを指定して、最初に一致するキーと値のペアを見つけて出力します。</target>
        </trans-unit>
        <trans-unit id="874b0ca5f6d74bc36f1a8bf750e4d758cb8b0d1e" translate="yes" xml:space="preserve">
          <source>In the examples above, we assigned the filehandle to a scalar variable before using it. That is because only simple scalar variables, not expressions or subscripts of hashes or arrays, can be used with built-ins like &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, or the diamond operator. Using something other than a simple scalar variable as a filehandle is illegal and won't even compile:</source>
          <target state="translated">上記の例では、ファイルハンドルを使用する前にスカラー変数に割り当てました。これは、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 、またはdiamond演算子のような組み込み関数で使用できるのは、ハッシュや配列の式や添え字ではなく、単純なスカラー変数だけだからです。単純なスカラー変数以外のものをファイルハンドルとして使用することは違法であり、コンパイルすらできません。</target>
        </trans-unit>
        <trans-unit id="3c7dfe54f4652ddbd0ee59dd84dc74edf8984d67" translate="yes" xml:space="preserve">
          <source>In the examples above, we assigned the filehandle to a scalar variable before using it. That is because only simple scalar variables, not expressions or subscripts of hashes or arrays, can be used with built-ins like &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, or the diamond operator. Using something other than a simple scalar variable as a filehandle is illegal and won't even compile:</source>
          <target state="translated">上記の例では、ファイルハンドルを使用する前にスカラー変数に割り当てました。これは、ハッシュや配列の式や添え字ではなく、単純なスカラー変数のみが、 &lt;code&gt;print&lt;/code&gt; 、 &lt;code&gt;printf&lt;/code&gt; 、diamond演算子などの組み込みで使用できるためです。単純なスカラー変数以外のものをファイルハンドルとして使用することは違法であり、コンパイルすらしません。</target>
        </trans-unit>
        <trans-unit id="1d5cb1050428e1b3c39a6dbeac5fa82c4e3ee30c" translate="yes" xml:space="preserve">
          <source>In the examples given to date, any temporaries created in the callback (i.e., parameters passed on the stack to the</source>
          <target state="translated">これまでの例では、コールバックで作成されたテンポラリ(つまり、スタック上で</target>
        </trans-unit>
        <trans-unit id="52df5ff09c57ff6bd4a65152023282e8e3fdf423" translate="yes" xml:space="preserve">
          <source>In the extended usage form, the references to be dumped can be given user-specified names. If a name begins with a &lt;code&gt;*&lt;/code&gt; , the output will describe the dereferenced type of the supplied reference for hashes and arrays, and coderefs. Output of names will be avoided where possible if the &lt;code&gt;Terse&lt;/code&gt; flag is set.</source>
          <target state="translated">拡張使用形式では、ダンプされる参照にユーザー指定の名前を付けることができます。名前が &lt;code&gt;*&lt;/code&gt; で始まる場合、出力には、ハッシュと配列、およびcoderefに指定された参照の逆参照型が記述されます。 &lt;code&gt;Terse&lt;/code&gt; フラグが設定されている場合、名前の出力は可能な限り回避されます。</target>
        </trans-unit>
        <trans-unit id="8be4e12f45149670637e90a3aa95e43448b1b2ae" translate="yes" xml:space="preserve">
          <source>In the extended usage form, the references to be dumped can be given user-specified names. If a name begins with a &lt;code&gt;*&lt;/code&gt;, the output will describe the dereferenced type of the supplied reference for hashes and arrays, and coderefs. Output of names will be avoided where possible if the &lt;code&gt;Terse&lt;/code&gt; flag is set.</source>
          <target state="translated">拡張使用フォームでは、ダンプされる参照にユーザー指定の名前を付けることができます。名前が &lt;code&gt;*&lt;/code&gt; で始まる場合、出力には、ハッシュと配列、およびコード参照に対して提供された参照の逆参照タイプが記述されます。 &lt;code&gt;Terse&lt;/code&gt; フラグが設定されている場合、名前の出力は可能な限り回避されます。</target>
        </trans-unit>
        <trans-unit id="1e093183cde30fbf5834bc8c2f2306668f0a93ab" translate="yes" xml:space="preserve">
          <source>In the eyes of the operating system, pseudo-processes created via the fork() emulation are simply threads in the same process. This means that any process-level limits imposed by the operating system apply to all pseudo-processes taken together. This includes any limits imposed by the operating system on the number of open file, directory and socket handles, limits on disk space usage, limits on memory size, limits on CPU utilization etc.</source>
          <target state="translated">オペレーティングシステムから見れば、fork()エミュレーションによって作成された疑似プロセスは、単に同じプロセス内のスレッドに過ぎません。つまり、オペレーティングシステムによって課せられるプロセスレベルの制限は、すべての疑似プロセスに適用されます。これには、ファイル、ディレクトリ、ソケットハンドルのオープン数、ディスクスペースの使用量、メモリサイズの制限、CPU 使用率の制限など、オペレーティングシステムによって課せられる制限が含まれます。</target>
        </trans-unit>
        <trans-unit id="c87855f737ebcf54612bd0d985e7951567552bdc" translate="yes" xml:space="preserve">
          <source>In the final example above, the first ASCII Hex digit is code point 48, the character &quot;0&quot;, and all code points from it through 57 (a &quot;9&quot;) are ASCII hex digits. Code points 58 through 64 aren't, but 65 (an &quot;A&quot;) through 70 (an &quot;F&quot;) are, as are 97 (&quot;a&quot;) through 102 (&quot;f&quot;). 103 starts a range of code points that aren't ASCII hex digits. That range extends to infinity, which on your computer can be found in the variable &lt;code&gt;$Unicode::UCD::MAX_CP&lt;/code&gt; . (This variable is as close to infinity as Perl can get on your platform, and may be too high for some operations to work; you may wish to use a smaller number for your purposes.)</source>
          <target state="translated">上記の最後の例では、最初のASCII 16進数字はコードポイント48、文字「0」、およびそれから57までのすべてのコードポイント（「9」）はASCII 16進数字です。コードポイント58〜64はありませんが、97（ &quot;a&quot;）〜102（ &quot;f&quot;）と同様に、65（ &quot;A&quot;）〜70（ &quot;F&quot;）です。 103は、ASCII 16進数字ではないコードポイントの範囲を開始します。その範囲は無限大まで拡張されます。これは、コンピューターでは &lt;code&gt;$Unicode::UCD::MAX_CP&lt;/code&gt; 変数で確認できます。 （この変数は、Perlがプラットフォームで取得できる限り無限に近く、一部の操作が機能するには高すぎる可能性があります。目的に応じて、より小さい数値を使用することもできます。）</target>
        </trans-unit>
        <trans-unit id="94e9a81f285a566a35b6b1d438008270601b9a19" translate="yes" xml:space="preserve">
          <source>In the final example above, the first ASCII Hex digit is code point 48, the character &quot;0&quot;, and all code points from it through 57 (a &quot;9&quot;) are ASCII hex digits. Code points 58 through 64 aren't, but 65 (an &quot;A&quot;) through 70 (an &quot;F&quot;) are, as are 97 (&quot;a&quot;) through 102 (&quot;f&quot;). 103 starts a range of code points that aren't ASCII hex digits. That range extends to infinity, which on your computer can be found in the variable &lt;code&gt;$Unicode::UCD::MAX_CP&lt;/code&gt;. (This variable is as close to infinity as Perl can get on your platform, and may be too high for some operations to work; you may wish to use a smaller number for your purposes.)</source>
          <target state="translated">上記の最後の例では、最初のASCII 16進数字はコードポイント48、文字「0」であり、それから57までのすべてのコードポイント（「9」）はASCII16進数字です。コードポイント58から64はそうではありませんが、65（ &quot;A&quot;）から70（ &quot;F&quot;）は、97（ &quot;a&quot;）から102（ &quot;f&quot;）と同様です。 103は、ASCII16進数ではないコードポイントの範囲を開始します。その範囲は無限大まで広がり、コンピューターでは変数 &lt;code&gt;$Unicode::UCD::MAX_CP&lt;/code&gt; ます。 （この変数は、Perlがプラットフォーム上で取得できる限り無限大に近く、一部の操作が機能するには高すぎる可能性があります。目的に応じて、より小さな数を使用することをお勧めします。）</target>
        </trans-unit>
        <trans-unit id="acc9782ed3f3e2b680013d144689804f90d54bf6" translate="yes" xml:space="preserve">
          <source>In the first example, an error handler, the flow of control could be as follows. You have created an interface to an external library. Control can reach the external library like this</source>
          <target state="translated">最初の例のエラーハンドラでは、制御の流れは次のようになります。外部ライブラリへのインターフェースを作成したとします。制御は次のように外部ライブラリに到達することができます。</target>
        </trans-unit>
        <trans-unit id="837426c8f21e7781853f5f83912529e607900661" translate="yes" xml:space="preserve">
          <source>In the first form, often referred to as a &quot;string eval&quot;, the return value of EXPR is parsed and executed as if it were a little Perl program. The value of the expression (which is itself determined within scalar context) is first parsed, and if there were no errors, executed as a block within the lexical context of the current Perl program. This means, that in particular, any outer lexical variables are visible to it, and any package variable settings or subroutine and format definitions remain afterwards.</source>
          <target state="translated">最初の形式では、しばしば &quot;string eval &quot;と呼ばれ、EXPRの戻り値が解析され、小さなPerlプログラムであるかのように実行されます。式の値(これ自体はスカラコンテキスト内で決定されます)は最初に解析され、エラーがなければ、現在のPerlプログラムの語彙コンテキスト内のブロックとして実行されます。これは、特に、外部の字句変数はすべてそれを見ることができ、パッケージ変数の設定やサブルーチンやフォーマットの定義は、その後も残っていることを意味します。</target>
        </trans-unit>
        <trans-unit id="9907ef81620f333168bdff52969249681c5309f5" translate="yes" xml:space="preserve">
          <source>In the first form, registers an object to work with for the function &lt;code&gt;id_2obj()&lt;/code&gt; . In the second form, it additionally marks the given hashrefs down for garbage collection. This means that when the object goes out of scope, any entries in the given hashes under the key of &lt;code&gt;id($obj)&lt;/code&gt; will be deleted from the hashes.</source>
          <target state="translated">最初の形式では、関数 &lt;code&gt;id_2obj()&lt;/code&gt; で使用するオブジェクトを登録します。2番目の形式では、指定されたハッシュ参照をガベージコレクション用にマークダウンします。これは、オブジェクトがスコープから外れると、 &lt;code&gt;id($obj)&lt;/code&gt; キーの下にある特定のハッシュのエントリがハッシュから削除されることを意味します。</target>
        </trans-unit>
        <trans-unit id="82daad9f8422b91114fc168e8a72aa6a69bd4b7c" translate="yes" xml:space="preserve">
          <source>In the first form, registers an object to work with for the function &lt;code&gt;id_2obj()&lt;/code&gt;. In the second form, it additionally marks the given hashrefs down for garbage collection. This means that when the object goes out of scope, any entries in the given hashes under the key of &lt;code&gt;id($obj)&lt;/code&gt; will be deleted from the hashes.</source>
          <target state="translated">最初の形式では、関数 &lt;code&gt;id_2obj()&lt;/code&gt; で使用するオブジェクトを登録します。2番目の形式では、ガベージコレクションのために指定されたハッシュ参照を追加でマークします。これは、オブジェクトがスコープ外になると、 &lt;code&gt;id($obj)&lt;/code&gt; キーの下にある指定されたハッシュのすべてのエントリがハッシュから削除されることを意味します。</target>
        </trans-unit>
        <trans-unit id="886a42840b4db0f0804225c4bdd1da338f8eaea4" translate="yes" xml:space="preserve">
          <source>In the first form, the anonymous hash is being blessed into the class in &lt;code&gt;$class&lt;/code&gt; . In the second form, the anonymous hash is blessed into the current package.</source>
          <target state="translated">最初の形式では、匿名ハッシュが &lt;code&gt;$class&lt;/code&gt; クラスに祝福されています。2番目の形式では、匿名ハッシュが現在のパッケージに組み込まれています。</target>
        </trans-unit>
        <trans-unit id="241819a9fd13f09ae7d3eb578ecbc5ee2d6a8a15" translate="yes" xml:space="preserve">
          <source>In the first form, the anonymous hash is being blessed into the class in &lt;code&gt;$class&lt;/code&gt;. In the second form, the anonymous hash is blessed into the current package.</source>
          <target state="translated">最初の形式では、匿名ハッシュが &lt;code&gt;$class&lt;/code&gt; クラスに祝福されています。2番目の形式では、匿名ハッシュが現在のパッケージに組み込まれます。</target>
        </trans-unit>
        <trans-unit id="5ba19d40237087370736921c2b055d0f9f4e8621" translate="yes" xml:space="preserve">
          <source>In the first two versions, the body of the subroutine is lexically in the main package,</source>
          <target state="translated">最初の2つのバージョンでは、サブルーチンの本体はメインパッケージに語彙的に含まれています。</target>
        </trans-unit>
        <trans-unit id="78475acfd51fd678e0727a44ada7dcef5de0bc33" translate="yes" xml:space="preserve">
          <source>In the first version above, you let the appropriate encoding layer handle the conversion. In the second, you explicitly translate from one encoding to the other.</source>
          <target state="translated">最初のバージョンでは、適切なエンコーディングレイヤーに変換処理を任せます。2番目のバージョンでは、あるエンコーディングから他のエンコーディングへの変換を明示的に行います。</target>
        </trans-unit>
        <trans-unit id="2414010bede2999a6fc168db89c621d8bb7bb77d" translate="yes" xml:space="preserve">
          <source>In the following all questions and explanations regarding config variables are collected.</source>
          <target state="translated">以下では、config変数に関するすべての質問と説明を収集しています。</target>
        </trans-unit>
        <trans-unit id="33eb6a227648440eaeed500f955607df47c5aa25" translate="yes" xml:space="preserve">
          <source>In the following examples, &lt;code&gt;$pad_len&lt;/code&gt; is the length to which you wish to pad the string, &lt;code&gt;$text&lt;/code&gt; or &lt;code&gt;$num&lt;/code&gt; contains the string to be padded, and &lt;code&gt;$pad_char&lt;/code&gt; contains the padding character. You can use a single character string constant instead of the &lt;code&gt;$pad_char&lt;/code&gt; variable if you know what it is in advance. And in the same way you can use an integer in place of &lt;code&gt;$pad_len&lt;/code&gt; if you know the pad length in advance.</source>
          <target state="translated">次の例では、 &lt;code&gt;$pad_len&lt;/code&gt; は文字列にパディングする長さ、 &lt;code&gt;$text&lt;/code&gt; または &lt;code&gt;$num&lt;/code&gt; はパディングされる文字列を含み、 &lt;code&gt;$pad_char&lt;/code&gt; はパディング文字を含みます。事前にわかっている場合は、 &lt;code&gt;$pad_char&lt;/code&gt; 変数の代わりに1文字の文字列定数を使用できます。同様に、パッドの長さが事前にわかっている場合は、 &lt;code&gt;$pad_len&lt;/code&gt; 代わりに整数を使用できます。</target>
        </trans-unit>
        <trans-unit id="fc65931a92616454753f1a0ca267288397762366" translate="yes" xml:space="preserve">
          <source>In the following section, we use XML to represent the event structure associated with a particular construct. That is, an opening tag represents the element start, the attributes of that opening tag are the attributes given to the callback, and the closing tag represents the end element.</source>
          <target state="translated">次の節では、特定のコンストラクタに関連するイベント構造をXMLで表現します。つまり、オープニングタグは要素の開始を表し、そのオープニングタグの属性はコールバックに与えられた属性であり、クロージングタグは要素の終了を表します。</target>
        </trans-unit>
        <trans-unit id="a479078b9cedbc887640e0bba65b952ff07c579b" translate="yes" xml:space="preserve">
          <source>In the following sections, these operators are covered in detail, in the same order in which they appear in the table above.</source>
          <target state="translated">以下のセクションでは、これらの演算子について、上の表と同じ順番で詳細に説明します。</target>
        </trans-unit>
        <trans-unit id="76ac42f7d8b0a7d53378ec8bb6883cc947c8612a" translate="yes" xml:space="preserve">
          <source>In the following sections, these operators are covered in precedence order.</source>
          <target state="translated">以下のセクションでは、これらの演算子を優先順位の高い順に説明します。</target>
        </trans-unit>
        <trans-unit id="4b178b275b86ca37ae6642cdcf850388ebe0add6" translate="yes" xml:space="preserve">
          <source>In the following tables, numbers indicate priority. For example, the table below states that, if no implementation for &lt;code&gt;'!'&lt;/code&gt; has been defined then Perl will implement it using &lt;code&gt;'bool'&lt;/code&gt; (that is, by inverting the value returned by the method for &lt;code&gt;'bool'&lt;/code&gt; ); if boolean conversion is also unimplemented then Perl will use &lt;code&gt;'0+'&lt;/code&gt; or, failing that, &lt;code&gt;'&quot;&quot;'&lt;/code&gt; .</source>
          <target state="translated">次の表で、数字は優先順位を示します。たとえば、次の表は、 &lt;code&gt;'!'&lt;/code&gt; 実装がない場合、定義されている場合、Perlは &lt;code&gt;'bool'&lt;/code&gt; を使用してそれを実装します（つまり、 &lt;code&gt;'bool'&lt;/code&gt; メソッドから返された値を反転します）。ブール変換も実装されていない場合、Perlは &lt;code&gt;'0+'&lt;/code&gt; を使用するか、失敗すると &lt;code&gt;'&quot;&quot;'&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="3f242ec2577ee075f67a91be886c834c96f1626f" translate="yes" xml:space="preserve">
          <source>In the following tables, numbers indicate priority. For example, the table below states that, if no implementation for &lt;code&gt;'!'&lt;/code&gt; has been defined then Perl will implement it using &lt;code&gt;'bool'&lt;/code&gt; (that is, by inverting the value returned by the method for &lt;code&gt;'bool'&lt;/code&gt;); if boolean conversion is also unimplemented then Perl will use &lt;code&gt;'0+'&lt;/code&gt; or, failing that, &lt;code&gt;'&quot;&quot;'&lt;/code&gt;.</source>
          <target state="translated">次の表で、数字は優先度を示しています。たとえば、次の表は、 &lt;code&gt;'!'&lt;/code&gt; 実装がない場合は次のように示しています。定義されている場合、Perlは &lt;code&gt;'bool'&lt;/code&gt; を使用して（つまり、 &lt;code&gt;'bool'&lt;/code&gt; のメソッドによって返される値を反転することによって）それを実装します。ブール変換も実装されていない場合、Perlは &lt;code&gt;'0+'&lt;/code&gt; を使用するか、それが失敗した場合は &lt;code&gt;'&quot;&quot;'&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="f8a38bcdad9de0c83d52fd95f8565a94b07788e8" translate="yes" xml:space="preserve">
          <source>In the following tables:</source>
          <target state="translated">以下の表では</target>
        </trans-unit>
        <trans-unit id="8d00c0473cd774a465a212e290a62a3d57987f7d" translate="yes" xml:space="preserve">
          <source>In the form of pipe opens taking three or more arguments, if LIST is specified (extra arguments after the command name) then LIST becomes arguments to the command invoked if the platform supports it. The meaning of &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; with more than three arguments for non-pipe modes is not yet defined, but experimental &quot;layers&quot; may give extra LIST arguments meaning.</source>
          <target state="translated">3つ以上の引数を取るパイプオープンの形式で、LISTが指定されている場合（コマンド名の後に追加の引数）、プラットフォームがサポートしている場合、LISTは呼び出されたコマンドの引数になります。非パイプモードの3つ以上の引数で&lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;の意味はまだ定義されていませんが、実験的な「レイヤー」は追加のLIST引数の意味を与える可能性があります。</target>
        </trans-unit>
        <trans-unit id="770598786b9fb05b86d05d808ab206b9dce08c07" translate="yes" xml:space="preserve">
          <source>In the form of pipe opens taking three or more arguments, if LIST is specified (extra arguments after the command name) then LIST becomes arguments to the command invoked if the platform supports it. The meaning of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; with more than three arguments for non-pipe modes is not yet defined, but experimental &quot;layers&quot; may give extra LIST arguments meaning.</source>
          <target state="translated">3つ以上の引数を取るパイプオープンの形式で、LISTが指定されている場合（コマンド名の後に追加の引数）、LISTは、プラットフォームがサポートしている場合に呼び出されるコマンドの引数になります。非パイプモードで3つ以上の引数を使用して &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; の意味はまだ定義されていませんが、実験的な「レイヤー」は追加のLIST引数の意味を与える場合があります。</target>
        </trans-unit>
        <trans-unit id="351023ba55a42928810e8ea146d7f9a69c7e4007" translate="yes" xml:space="preserve">
          <source>In the form of pipe opens taking three or more arguments, if LIST is specified (extra arguments after the command name) then LIST becomes arguments to the command invoked if the platform supports it. The meaning of &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; with more than three arguments for non-pipe modes is not yet defined, but experimental &quot;layers&quot; may give extra LIST arguments meaning.</source>
          <target state="translated">3つ以上の引数を取るパイプオープンの形式で、LISTが指定されている場合（コマンド名の後に追加の引数）、LISTは、プラットフォームがサポートしている場合に呼び出されるコマンドの引数になります。非パイプモードで3つ以上の引数を使用して &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; の意味はまだ定義されていませんが、実験的な「レイヤー」は追加のLIST引数の意味を与える場合があります。</target>
        </trans-unit>
        <trans-unit id="d0c6eb4ba4d293106779dbeb28a115c48d149f15" translate="yes" xml:space="preserve">
          <source>In the function descriptions below the term</source>
          <target state="translated">以下の機能説明では</target>
        </trans-unit>
        <trans-unit id="0d9756e636c498fe9304eb168ab8f26e641d5c72" translate="yes" xml:space="preserve">
          <source>In the future, this module will likely use File::Spec for determining paths, as it does now for Mac OS (where Unix-style or Mac-style paths work, and Unix-style paths are converted properly to Mac-style paths before being added to @INC).</source>
          <target state="translated">将来的には、このモジュールは、現在の Mac OS 用のように、パスを決定するために File::Spec を使うことになるでしょう (Unix スタイルまたは Mac スタイルのパスが動作し、@INC に追加される前に Unix スタイルのパスが Mac スタイルのパスに適切に変換されます)。</target>
        </trans-unit>
        <trans-unit id="46cedf56be184729e0d91d65fc9c0d53cad92704" translate="yes" xml:space="preserve">
          <source>In the last example, the end of the string is considered a word boundary.</source>
          <target state="translated">最後の例では、文字列の末尾を単語の境界とみなしています。</target>
        </trans-unit>
        <trans-unit id="6405a42cdbbb08be1356ae610a2c353a3021f6e3" translate="yes" xml:space="preserve">
          <source>In the last example, the whole string was matched, but only the part inside the single quotes was grouped. With the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. are immediately available for use in the replacement expression, so we use &lt;code&gt;$1&lt;/code&gt; to replace the quoted string with just what was quoted. With the global modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; will search and replace all occurrences of the regexp in the string:</source>
          <target state="translated">最後の例では、文字列全体が一致しましたが、単一引用符内の部分のみがグループ化されました。 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 演算子、マッチ変数 &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; 、我々が使用してなど、交換式の使用のためにすぐに利用できる &lt;code&gt;$1&lt;/code&gt; 引用されたものだけを引用符で囲んだ文字列を置換します。グローバル修飾子を使用すると、 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; は文字列内のすべての正規表現を検索して置き換えます。</target>
        </trans-unit>
        <trans-unit id="083adc541bcebeae1c40187264f802274bed10c9" translate="yes" xml:space="preserve">
          <source>In the last example, the whole string was matched, but only the part inside the single quotes was grouped. With the &lt;code&gt;s///&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;,</source>
          <target state="translated">最後の例では、文字列全体が一致しましたが、一重引用符内の部分のみがグループ化されました。 &lt;code&gt;s///&lt;/code&gt; 演算子、マッチ変数 &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; 、</target>
        </trans-unit>
        <trans-unit id="06c06ffd743a05cb45342ceadd66f34d1f6c47cc" translate="yes" xml:space="preserve">
          <source>In the last regex, the forward slash &lt;code&gt;'/'&lt;/code&gt; is also backslashed, because it is used to delimit the regex.</source>
          <target state="translated">最後の正規表現では、スラッシュ &lt;code&gt;'/'&lt;/code&gt; も正規表現を区切るために使用されるため、バックスラッシュが付けられます。</target>
        </trans-unit>
        <trans-unit id="11c4a29ccb7ab2ebd1eeaf108124208b060d0f4a" translate="yes" xml:space="preserve">
          <source>In the last regexp, the forward slash &lt;code&gt;'/'&lt;/code&gt; is also backslashed, because it is used to delimit the regexp. This can lead to LTS (leaning toothpick syndrome), however, and it is often more readable to change delimiters.</source>
          <target state="translated">最後の正規表現では、スラッシュ &lt;code&gt;'/'&lt;/code&gt; も正規表現を区切るために使用されるため、バックスラッシュが付けられます。これはLTS（つまようじ症候群の傾き）につながる可能性がありますが、区切り文字を変更する方が読みやすい場合があります。</target>
        </trans-unit>
        <trans-unit id="3c351aa56c66843f422f8613ab5ba80764ad66e0" translate="yes" xml:space="preserve">
          <source>In the last statement, even though &lt;code&gt;'c'&lt;/code&gt; is the first character in the class, &lt;code&gt;'a'&lt;/code&gt; matches because the first character position in the string is the earliest point at which the regexp can match.</source>
          <target state="translated">最後の文では、たとえ &lt;code&gt;'c'&lt;/code&gt; クラスの最初の文字であり、 &lt;code&gt;'a'&lt;/code&gt; 文字列の最初の文字の位置は、正規表現を一致させることができる最も早い時点であるので、マッチ。</target>
        </trans-unit>
        <trans-unit id="eb7827ba059fba337cd380ecde1e864bd7488e84" translate="yes" xml:space="preserve">
          <source>In the last statement, even though &lt;code&gt;'c'&lt;/code&gt; is the first character in the class, the earliest point at which the regex can match is &lt;code&gt;'a'&lt;/code&gt; .</source>
          <target state="translated">最後のステートメントでは、 &lt;code&gt;'c'&lt;/code&gt; はクラスの最初の文字ですが、正規表現が一致できる最も早い時点は &lt;code&gt;'a'&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="fb0e131732b0d0f21b5019af566fe7f7ba1531a8" translate="yes" xml:space="preserve">
          <source>In the last statement, even though &lt;code&gt;'c'&lt;/code&gt; is the first character in the class, the earliest point at which the regex can match is &lt;code&gt;'a'&lt;/code&gt;.</source>
          <target state="translated">最後のステートメントでは、 &lt;code&gt;'c'&lt;/code&gt; がクラスの最初の文字ですが、正規表現が一致できる最も早いポイントは &lt;code&gt;'a'&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3d9813d8232f26905286fe72c0fb88aaeece44db" translate="yes" xml:space="preserve">
          <source>In the latter case, characters that map to 0212 are first converted to U+3013 (0xA2AE in EUC-JP; a white square also known as 'Tofu' or 'geta mark') then fed to the decoding engine. U+FFFD is not used, in order to preserve text layout as much as possible.</source>
          <target state="translated">後者の場合、0212に対応する文字はまずU+3013(EUC-JPでは0xA2AE;「豆腐」や「下駄マーク」とも呼ばれる白い四角)に変換され、その後デコードエンジンに送られます。テキストレイアウトを可能な限り保持するため、U+FFFDは使用されません。</target>
        </trans-unit>
        <trans-unit id="a8f8d594e47a7aed4b47d21c04c8b5fc5ac50b38" translate="yes" xml:space="preserve">
          <source>In the latter, foo.h is taken as</source>
          <target state="translated">後者では、foo.h は</target>
        </trans-unit>
        <trans-unit id="9b81dfce26cb69eddfbb13b42d7a921ee8ba05af" translate="yes" xml:space="preserve">
          <source>In the list of parameters for an XSUB, one can precede parameter names by the &lt;code&gt;IN&lt;/code&gt; /&lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; keywords. &lt;code&gt;IN&lt;/code&gt; keyword is the default, the other keywords indicate how the Perl interface should differ from the C interface.</source>
          <target state="translated">XSUBのパラメーターのリストでは、パラメーター名の前に &lt;code&gt;IN&lt;/code&gt; / &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; キーワードを付けることができます。 &lt;code&gt;IN&lt;/code&gt; キーワードがデフォルトです。他のキーワードは、PerlインターフェースとCインターフェースの違いを示します。</target>
        </trans-unit>
        <trans-unit id="eaa86694f038fb390a6437b7cfb383ab6f33e503" translate="yes" xml:space="preserve">
          <source>In the list of parameters for an XSUB, one can precede parameter names by the &lt;code&gt;IN&lt;/code&gt;/&lt;code&gt;OUTLIST&lt;/code&gt;/&lt;code&gt;IN_OUTLIST&lt;/code&gt;/&lt;code&gt;OUT&lt;/code&gt;/&lt;code&gt;IN_OUT&lt;/code&gt; keywords. &lt;code&gt;IN&lt;/code&gt; keyword is the default, the other keywords indicate how the Perl interface should differ from the C interface.</source>
          <target state="translated">XSUBのパラメーターのリストでは、パラメーター名の前に &lt;code&gt;IN&lt;/code&gt; / &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; キーワードを付けることができます。 &lt;code&gt;IN&lt;/code&gt; キーワードがデフォルトであり、他のキーワードは、PerlインターフェースがCインターフェースとどのように異なるかを示します。</target>
        </trans-unit>
        <trans-unit id="6c32d4238ee6ff96fa8bb06b99ee3f8b0689422e" translate="yes" xml:space="preserve">
          <source>In the method descriptions below</source>
          <target state="translated">以下の方法の説明では</target>
        </trans-unit>
        <trans-unit id="1b237b2ec2e195bf52f7f15f0ad99e5a2c78e4b1" translate="yes" xml:space="preserve">
          <source>In the more general case, you can use the &lt;code&gt;/g&lt;/code&gt; modifier in a &lt;code&gt;while&lt;/code&gt; loop, keeping count of matches.</source>
          <target state="translated">より一般的なケースでは、 &lt;code&gt;while&lt;/code&gt; ループで &lt;code&gt;/g&lt;/code&gt; 修飾子を使用して、一致の数を維持できます。</target>
        </trans-unit>
        <trans-unit id="4effaa0b6c8c5116ec13300ff6598d1e650296b0" translate="yes" xml:space="preserve">
          <source>In the most common case, the simple case of a L&amp;lt;podpage&amp;gt; code produces this event structure:</source>
          <target state="translated">最も一般的なケースでは、L &amp;lt;podpage&amp;gt;コードの単純なケースで、次のイベント構造が生成されます。</target>
        </trans-unit>
        <trans-unit id="784f063825aaf77ec4d5f9b15d7c0e7efc2377c9" translate="yes" xml:space="preserve">
          <source>In the mylib directory, create a file mylib.h that looks like this:</source>
          <target state="translated">mylibディレクトリに、以下のようなファイルmylib.hを作成します。</target>
        </trans-unit>
        <trans-unit id="8fae5d3b394459ca514c1ba039cdb1ef56a38f82" translate="yes" xml:space="preserve">
          <source>In the next example, the expression is evaluated only once, and the tied scalar is fetched once as part of the operation within the expression. The result of that operation is fetched for each comparison, which normally doesn't matter unless that expression result is also magical due to operator overloading.</source>
          <target state="translated">次の例では、式は一度だけ評価され、式の中の操作の一部として一度だけタイドスカラがフェッチされます。その操作の結果は比較のたびにフェッチされますが、演算子のオーバーロードによってその式の結果も魔法のようにならない限り、通常は問題になりません。</target>
        </trans-unit>
        <trans-unit id="79fbf0c13d713302225cff8f61abd9dd7ac74b43" translate="yes" xml:space="preserve">
          <source>In the next paragraph follows a short description of terms used here (because these may differ from terms used by others people or documentation).</source>
          <target state="translated">次の段落では、ここで使用されている用語の簡単な説明に続きます(これらは他の人や文書によって使用されている用語と異なる場合があるため)。</target>
        </trans-unit>
        <trans-unit id="5152e34177e8a3d4c184b97093704f88de6ca9db" translate="yes" xml:space="preserve">
          <source>In the notation discussed so far, the characters &quot;[&quot; and &quot;]&quot; are given special meaning, for opening and closing bracket groups, and &quot;,&quot; has a special meaning inside bracket groups, where it separates items in the group. This begs the question of how you'd express a literal &quot;[&quot; or &quot;]&quot; in a Bracket Notation string, and how you'd express a literal comma inside a bracket group. For this purpose I've adopted &quot;~&quot; (tilde) as an escape character: &quot;~[&quot; means a literal '[' character anywhere in Bracket Notation (i.e., regardless of whether you're in a bracket group or not), and ditto for &quot;~]&quot; meaning a literal ']', and &quot;~,&quot; meaning a literal comma. (Altho &quot;,&quot; means a literal comma outside of bracket groups -- it's only inside bracket groups that commas are special.)</source>
          <target state="translated">これまで説明してきた記法では、「[&quot;」と「]&quot;」という文字はブラケットグループの開閉に特別な意味を持ち、「,」はブラケットグループの中で特別な意味を持ち、グループ内の項目を区切ることができます。これは、ブラケット記法の文字列の中でリテラルの&quot;[&quot;や&quot;]&quot;をどのように表現するのか、また、ブラケットグループの中でリテラルのカンマをどのように表現するのか、という疑問を投げかけています。この目的のために、エスケープ文字として &quot;~&quot; (チルダ)を採用しました。&quot;~[&quot; は、ブラケット記法のどこにいてもリテラル '[' 文字を意味します (つまり、ブラケットグループにいるかどうかに関係なく)。(「,」は大括弧グループの外ではリテラルカンマを意味しますが、カンマが特別なのは大括弧グループの中だけです)。</target>
        </trans-unit>
        <trans-unit id="9c42fcbdbf3cd24cfb1dac2e8ba1cbc829f18933" translate="yes" xml:space="preserve">
          <source>In the olden, less enlightened times, we all used to use ASCII. Most of us did, anyway. The big problem with ASCII is that it's American. Well, no, that's not actually the problem; the problem is that it's not particularly useful for people who don't use the Roman alphabet. What used to happen was that particular languages would stick their own alphabet in the upper range of the sequence, between 128 and 255. Of course, we then ended up with plenty of variants that weren't quite ASCII, and the whole point of it being a standard was lost.</source>
          <target state="translated">昔の、それほど啓蒙されていない時代には、みんなASCIIを使っていました。私たちのほとんどがそうでした。ASCIIの大きな問題は、それがアメリカのものだということです。問題は、ローマ字を使わない人にとっては特に便利なものではないということです。問題は、ローマ字を使わない人にとっては特に便利ではないということです。もちろん、その結果、ASCIIではない文字がたくさん出てきて、標準であることの意味が失われてしまいました。</target>
        </trans-unit>
        <trans-unit id="50b947f69a6b2d22a725a2d7ba0813fc1f66f21b" translate="yes" xml:space="preserve">
          <source>In the one case the code, which does exactly the same thing as far as outputting any debugging information is concerned, in other words nothing, takes 14 seconds, and in the other case the code takes one hundredth of a second. Looks fairly definitive. Use a &lt;code&gt;$DEBUG&lt;/code&gt; variable BEFORE you call the subroutine, rather than relying on the smart functionality inside it.</source>
          <target state="translated">デバッグ情報の出力に関する限りまったく同じことを行うコード、つまり何もない場合は14秒かかり、もう1つの場合は100分の1秒かかります。かなり決定的に見えます。サブルーチンを呼び出す前に、 &lt;code&gt;$DEBUG&lt;/code&gt; 変数を使用してください。サブルーチン内のスマートな機能に依存するのではありません。</target>
        </trans-unit>
        <trans-unit id="9cd2461949e5dab65a2af380d7f878aad8f12946" translate="yes" xml:space="preserve">
          <source>In the one- and two-argument forms of the call, the mode and filename should be concatenated (in that order), preferably separated by white space. You can--but shouldn't--omit the mode in these forms when that mode is &lt;code&gt;&amp;lt;&lt;/code&gt; . It is always safe to use the two-argument form of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; if the filename argument is a known literal.</source>
          <target state="translated">引数の1引数形式と2引数形式では、モードとファイル名を（この順序で）連結する必要があります。できれば空白で区切ります。モードが &lt;code&gt;&amp;lt;&lt;/code&gt; の場合、これらの形式でモードを省略できますが、省略してはなりません。filename引数が既知のリテラルである場合は、常に2引数形式の &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; を使用しても安全です。</target>
        </trans-unit>
        <trans-unit id="6c1895cc93a277f17a7d9aa8c8fca89d99b0c8a2" translate="yes" xml:space="preserve">
          <source>In the one- and two-argument forms of the call, the mode and filename should be concatenated (in that order), preferably separated by white space. You can--but shouldn't--omit the mode in these forms when that mode is &lt;code&gt;&amp;lt;&lt;/code&gt; . It is always safe to use the two-argument form of &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; if the filename argument is a known literal.</source>
          <target state="translated">引数の1引数形式と2引数形式では、モードとファイル名を（この順序で）連結する必要があります。できれば空白で区切ります。モードが &lt;code&gt;&amp;lt;&lt;/code&gt; の場合、これらの形式でモードを省略できますが、省略してはなりません。filename引数が既知のリテラルである場合は、常に2引数形式の &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; を使用しても安全です。</target>
        </trans-unit>
        <trans-unit id="ece5db37f09d793410ad6532c80d07a8dc5b931d" translate="yes" xml:space="preserve">
          <source>In the one- and two-argument forms of the call, the mode and filename should be concatenated (in that order), preferably separated by white space. You can--but shouldn't--omit the mode in these forms when that mode is &lt;code&gt;&amp;lt;&lt;/code&gt;. It is safe to use the two-argument form of &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; if the filename argument is a known literal.</source>
          <target state="translated">呼び出しの1引数形式と2引数形式では、モードとファイル名を（この順序で）連結し、できれば空白で区切る必要があります。モードが &lt;code&gt;&amp;lt;&lt;/code&gt; の場合、これらの形式でモードを省略できますが、省略しないでください。filename引数が既知のリテラルである場合は、&lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; の&lt;/a&gt;2つの引数形式を使用しても安全です。</target>
        </trans-unit>
        <trans-unit id="9baa512a702be95a00f5cdfa9d3fa8d7a2a0b696" translate="yes" xml:space="preserve">
          <source>In the opposite way, to resolve a hostname to the IP address you can write this:</source>
          <target state="translated">逆に、ホスト名をIPアドレスに解決するには、次のように書きます。</target>
        </trans-unit>
        <trans-unit id="ecb2e91137fed6da0013b83630021f3d72198be0" translate="yes" xml:space="preserve">
          <source>In the option specification, the option name is followed by an equals sign &lt;code&gt;=&lt;/code&gt; and the letter &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;. The equals sign indicates that this option requires a value. The letter &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; indicates that this value is an arbitrary string. Other possible value types are &lt;code&gt;i&lt;/code&gt; for integer values, and &lt;code&gt;f&lt;/code&gt; for floating point values. Using a colon &lt;code&gt;:&lt;/code&gt; instead of the equals sign indicates that the option value is optional. In this case, if no suitable value is supplied, string valued options get an empty string &lt;code&gt;''&lt;/code&gt; assigned, while numeric options are set to &lt;code&gt;0&lt;/code&gt; .</source>
          <target state="translated">オプション指定では、オプション名の後に等号 &lt;code&gt;=&lt;/code&gt; と文字 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; が続きます。等号は、このオプションに値が必要であることを示します。文字 &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; は、この値が任意の文字列であることを示します。他に考えられる値の型は、整数値の場合は &lt;code&gt;i&lt;/code&gt; 、浮動小数点値の場合は &lt;code&gt;f&lt;/code&gt; です。コロンを使用した &lt;code&gt;:&lt;/code&gt; 等号の代わりには、オプションの値がオプションであることを示しています。この場合、適切な値が指定されていないと、文字列値のオプションには空の文字列 &lt;code&gt;''&lt;/code&gt; が割り当てられますが、数値オプションには &lt;code&gt;0&lt;/code&gt; が設定されます。</target>
        </trans-unit>
        <trans-unit id="2973e9ef2ea1b82ed03c1ee6b61fab3e0195c205" translate="yes" xml:space="preserve">
          <source>In the option specification, the option name is followed by an equals sign &lt;code&gt;=&lt;/code&gt; and the letter &lt;code&gt;s&lt;/code&gt;. The equals sign indicates that this option requires a value. The letter &lt;code&gt;s&lt;/code&gt; indicates that this value is an arbitrary string. Other possible value types are &lt;code&gt;i&lt;/code&gt; for integer values, and &lt;code&gt;f&lt;/code&gt; for floating point values. Using a colon &lt;code&gt;:&lt;/code&gt; instead of the equals sign indicates that the option value is optional. In this case, if no suitable value is supplied, string valued options get an empty string &lt;code&gt;''&lt;/code&gt; assigned, while numeric options are set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">オプション仕様では、オプション名の後に等号 &lt;code&gt;=&lt;/code&gt; と文字 &lt;code&gt;s&lt;/code&gt; が続きます。等号は、このオプションに値が必要であることを示します。文字 &lt;code&gt;s&lt;/code&gt; は、この値が任意の文字列であることを示します。他の可能な値タイプは、整数値の場合は &lt;code&gt;i&lt;/code&gt; 、浮動小数点値の場合は &lt;code&gt;f&lt;/code&gt; です。等号の代わりにコロンを使用する &lt;code&gt;:&lt;/code&gt; オプション値がオプションであることを示します。この場合、適切な値が指定されていない場合、文字列値のオプションには空の文字列 &lt;code&gt;''&lt;/code&gt; が割り当てられ、数値オプションは &lt;code&gt;0&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="53db56988ad2d32c572da0df498153024ad7a10e" translate="yes" xml:space="preserve">
          <source>In the past, the Perl community experimented with a technique called &quot;inside-out objects&quot;. An inside-out object stores its data outside of the object's reference, indexed on a unique property of the object, such as its memory address, rather than in the object itself. This has the advantage of enforcing the encapsulation of object attributes, since their data is not stored in the object itself.</source>
          <target state="translated">過去に Perl コミュニティでは、「インサイドアウト・オブジェクト」と呼ばれる技術を実験的に使用していました。インサイドアウトオブジェクトは、そのデータをオブジェクトの参照の外側に保存し、オブジェクト自体ではなく、そのメモリアドレスのようなオブジェクトのユニークなプロパティにインデックスを付けます。これは、オブジェクトの属性のデータがオブジェクト自体に保存されないので、オブジェクトの属性のカプセル化を強制するという利点があります。</target>
        </trans-unit>
        <trans-unit id="b5906a56cbc722b4f6580ce6c1001f48ce79b661" translate="yes" xml:space="preserve">
          <source>In the past, the distribution metadata structure had been packed with distributions as</source>
          <target state="translated">これまでは、ディストリビューションのメタデータ構造は、ディストリビューションを</target>
        </trans-unit>
        <trans-unit id="8a3a725cb056826efb62b17fb21f5a5c69a3ce79" translate="yes" xml:space="preserve">
          <source>In the past, the leading &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; was optional, but omitting it would produce a deprecation warning. As of v5.22.0, omitting it produces a syntax error. If you encounter this construct in older code, you can just add &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">過去には、大手 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; で &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; オプションでしたが、省略すると非推奨の警告が表示されます。 v5.22.0以降では、省略すると構文エラーが発生します。古いコードでこの構造に遭遇した場合は、 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; を追加するだけで済みます。</target>
        </trans-unit>
        <trans-unit id="6491315a7266db76aa8c4f0b2210eb7af26bbb35" translate="yes" xml:space="preserve">
          <source>In the past, the leading &lt;code&gt;m&lt;/code&gt; in &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; was optional, but omitting it would produce a deprecation warning. As of v5.22.0, omitting it produces a syntax error. If you encounter this construct in older code, you can just add &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">過去には、大手 &lt;code&gt;m&lt;/code&gt; で &lt;code&gt;m?&lt;i&gt;PATTERN&lt;/i&gt;?&lt;/code&gt; オプションでしたが、省略すると非推奨の警告が表示されます。 v5.22.0以降、これを省略すると構文エラーが発生します。古いコードでこの構成に遭遇した場合は、 &lt;code&gt;m&lt;/code&gt; を追加するだけです。</target>
        </trans-unit>
        <trans-unit id="3a63857af592db7e75d88e816c7c7a1180f9eb89" translate="yes" xml:space="preserve">
          <source>In the pathological case that a script is called via a relative path</source>
          <target state="translated">スクリプトが相対パスを経由して呼び出されるという病理学的なケースでは</target>
        </trans-unit>
        <trans-unit id="b5cb98f00aa6aaa22eb71c271690cbb1ebc9df81" translate="yes" xml:space="preserve">
          <source>In the pattern /\Bam\B/, there must be a word character before the &quot;a&quot; and after the &quot;m&quot;. These patterns match /\Bam\B/:</source>
          <target state="translated">パターン/\Bam\B/では、&quot;a &quot;の前と &quot;m &quot;の後に単語の文字があるはず。これらのパターンは、/\\BamB/と一致する。</target>
        </trans-unit>
        <trans-unit id="d454ee791b9ae0c5bbb81657f656033f3c0c5a24" translate="yes" xml:space="preserve">
          <source>In the peculiar &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; form, VERSION may be either a positive decimal fraction such as 5.006, which will be compared to &lt;code&gt;$]&lt;/code&gt; , or a v-string of the form v5.6.1, which will be compared to &lt;code&gt;$^V&lt;/code&gt; (aka $PERL_VERSION). An exception is raised if VERSION is greater than the version of the current Perl interpreter; Perl will not attempt to parse the rest of the file. Compare with &lt;a href=&quot;#require&quot;&gt;require&lt;/a&gt;, which can do a similar check at run time. Symmetrically, &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; allows you to specify that you want a version of Perl older than the specified one.</source>
          <target state="translated">特殊な &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; フォームでは、VERSIONは、5.006などの正の小数であり、 &lt;code&gt;$]&lt;/code&gt; と比較されます。または、フォームv5.6.1のv文字列で、 &lt;code&gt;$^V&lt;/code&gt; （別名$ PERL_VERSION）。 VERSIONが現在のPerlインタープリターのバージョンより大きい場合、例外が発生します。 Perlは残りのファイルの解析を試みません。実行時に同様のチェックを実行できる&lt;a href=&quot;#require&quot;&gt;requireと&lt;/a&gt;比較してください。対称的に、 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; 、あなたが指定したものより古いバージョンのPerlをしたいことを指定することができません。</target>
        </trans-unit>
        <trans-unit id="74d3b7e92857ff92a78ee1a11cb1e6022b249cb3" translate="yes" xml:space="preserve">
          <source>In the peculiar &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; form, VERSION may be either a positive decimal fraction such as 5.006, which will be compared to &lt;code&gt;$]&lt;/code&gt; , or a v-string of the form v5.6.1, which will be compared to &lt;code&gt;$^V&lt;/code&gt; (aka $PERL_VERSION). An exception is raised if VERSION is greater than the version of the current Perl interpreter; Perl will not attempt to parse the rest of the file. Compare with &lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;, which can do a similar check at run time. Symmetrically, &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; allows you to specify that you want a version of Perl older than the specified one.</source>
          <target state="translated">特殊な &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; フォームでは、VERSIONは、5.006などの正の小数であり、 &lt;code&gt;$]&lt;/code&gt; と比較されます。または、フォームv5.6.1のv文字列で、 &lt;code&gt;$^V&lt;/code&gt; （別名$ PERL_VERSION）。 VERSIONが現在のPerlインタープリターのバージョンより大きい場合、例外が発生します。 Perlは残りのファイルの解析を試みません。実行時に同様のチェックを実行できる&lt;a href=&quot;require&quot;&gt;requireと&lt;/a&gt;比較してください。対称的に、 &lt;code&gt;&lt;a href=&quot;no&quot;&gt;no&lt;/a&gt; VERSION&lt;/code&gt; 、あなたが指定したものより古いバージョンのPerlをしたいことを指定することができません。</target>
        </trans-unit>
        <trans-unit id="a5da666074fc2ec75362b3b68f86858be734f6e9" translate="yes" xml:space="preserve">
          <source>In the presence of multiple classes it can be non-trivial to make sure that every relevant destructor is called for every object. Perl calls the first one it finds on the inheritance tree (if any) and that's it.</source>
          <target state="translated">複数のクラスが存在する場合、すべてのオブジェクトに関連するデストラクタが確実に呼び出されるようにすることは容易ではありません。Perl は継承ツリー上で最初に見つけたものを(もしあれば)呼び出し、それで終わりです。</target>
        </trans-unit>
        <trans-unit id="cd34d34a3c68755abc29d11ed297638bd9fdb29d" translate="yes" xml:space="preserve">
          <source>In the presence of the &lt;code&gt;REXEC_COPY_STR&lt;/code&gt; flag, but with the addition of the &lt;code&gt;REXEC_COPY_SKIP_PRE&lt;/code&gt; or &lt;code&gt;REXEC_COPY_SKIP_POST&lt;/code&gt; flags, an engine can choose not to copy the full buffer (although it must still do so in the presence of &lt;code&gt;RXf_PMf_KEEPCOPY&lt;/code&gt; or the relevant bits being set in &lt;code&gt;PL_sawampersand&lt;/code&gt; ). In this case, it may set &lt;code&gt;suboffset&lt;/code&gt; to indicate the number of bytes from the logical start of the buffer to the physical start (i.e. &lt;code&gt;subbeg&lt;/code&gt; ). It should also set &lt;code&gt;subcoffset&lt;/code&gt; , the number of characters in the offset. The latter is needed to support &lt;code&gt;@-&lt;/code&gt; and &lt;code&gt;@+&lt;/code&gt; which work in characters, not bytes.</source>
          <target state="translated">存在下で &lt;code&gt;REXEC_COPY_STR&lt;/code&gt; のフラグが、添加と &lt;code&gt;REXEC_COPY_SKIP_PRE&lt;/code&gt; 又は &lt;code&gt;REXEC_COPY_SKIP_POST&lt;/code&gt; （それがまだ存在下で行う必要があるがフラグ、エンジンが完全なバッファをコピーしないことを選択することができ &lt;code&gt;RXf_PMf_KEEPCOPY&lt;/code&gt; またはに設定されている関連ビット &lt;code&gt;PL_sawampersand&lt;/code&gt; ） 。この場合、 &lt;code&gt;suboffset&lt;/code&gt; を設定して、バッファの論理的開始から物理的開始までのバイト数（つまり、 &lt;code&gt;subbeg&lt;/code&gt; ）を示すことができます。また、オフセットの文字数である &lt;code&gt;subcoffset&lt;/code&gt; も設定する必要があります。後者は、バイトではなく文字で機能する &lt;code&gt;@-&lt;/code&gt; および &lt;code&gt;@+&lt;/code&gt; をサポートするために必要です。</target>
        </trans-unit>
        <trans-unit id="e824f56cbef986827e73fc6c293b5f1b6c0ceaea" translate="yes" xml:space="preserve">
          <source>In the presence of the &lt;code&gt;REXEC_COPY_STR&lt;/code&gt; flag, but with the addition of the &lt;code&gt;REXEC_COPY_SKIP_PRE&lt;/code&gt; or &lt;code&gt;REXEC_COPY_SKIP_POST&lt;/code&gt; flags, an engine can choose not to copy the full buffer (although it must still do so in the presence of &lt;code&gt;RXf_PMf_KEEPCOPY&lt;/code&gt; or the relevant bits being set in &lt;code&gt;PL_sawampersand&lt;/code&gt;). In this case, it may set &lt;code&gt;suboffset&lt;/code&gt; to indicate the number of bytes from the logical start of the buffer to the physical start (i.e. &lt;code&gt;subbeg&lt;/code&gt;). It should also set &lt;code&gt;subcoffset&lt;/code&gt;, the number of characters in the offset. The latter is needed to support &lt;code&gt;@-&lt;/code&gt; and &lt;code&gt;@+&lt;/code&gt; which work in characters, not bytes.</source>
          <target state="translated">存在下で &lt;code&gt;REXEC_COPY_STR&lt;/code&gt; のフラグが、添加と &lt;code&gt;REXEC_COPY_SKIP_PRE&lt;/code&gt; 又は &lt;code&gt;REXEC_COPY_SKIP_POST&lt;/code&gt; （それがまだ存在下で行う必要があるがフラグ、エンジンが完全なバッファをコピーしないことを選択することができ &lt;code&gt;RXf_PMf_KEEPCOPY&lt;/code&gt; またはに設定されている関連ビット &lt;code&gt;PL_sawampersand&lt;/code&gt; ） 。この場合、バッファの論理的な開始から物理的な開始までのバイト数を示すように &lt;code&gt;suboffset&lt;/code&gt; を設定できます（つまり、 &lt;code&gt;subbeg&lt;/code&gt; ）。また、オフセットの文字数である &lt;code&gt;subcoffset&lt;/code&gt; も設定する必要があります。後者は、バイトではなく文字で機能する &lt;code&gt;@-&lt;/code&gt; および &lt;code&gt;@+&lt;/code&gt; をサポートするために必要です。</target>
        </trans-unit>
        <trans-unit id="b073c0a34c41b3ba5f06418d694ba351020d4acc" translate="yes" xml:space="preserve">
          <source>In the previous example, you created a function-private variable because only one function remembered its reference. You could define multiple functions while the variable is in scope, and each function can share the &quot;private&quot; variable. It's not really &quot;static&quot; because you can access it outside the function while the lexical variable is in scope, and even create references to it. In this example, &lt;code&gt;increment_count&lt;/code&gt; and &lt;code&gt;return_count&lt;/code&gt; share the variable. One function adds to the value and the other simply returns the value. They can both access &lt;code&gt;$count&lt;/code&gt; , and since it has gone out of scope, there is no other way to access it.</source>
          <target state="translated">前の例では、1つの関数だけがその参照を記憶しているため、関数プライベート変数を作成しました。変数がスコープ内にある間に複数の関数を定義でき、各関数は「プライベート」変数を共有できます。レキシカル変数がスコープ内にあるときに関数の外でアクセスでき、それへの参照を作成することもできるため、実際には「静的」ではありません。この例では、 &lt;code&gt;increment_count&lt;/code&gt; と &lt;code&gt;return_count&lt;/code&gt; が変数を共有しています。 1つの関数は値に追加し、もう1つの関数は単に値を返します。どちらも &lt;code&gt;$count&lt;/code&gt; にアクセスできます。また、スコープから外れたため、他の方法でアクセスすることはできません。</target>
        </trans-unit>
        <trans-unit id="d2b9d6cad21d85345ac4d94d7af37ac664ad662a" translate="yes" xml:space="preserve">
          <source>In the previous example, you created a function-private variable because only one function remembered its reference. You could define multiple functions while the variable is in scope, and each function can share the &quot;private&quot; variable. It's not really &quot;static&quot; because you can access it outside the function while the lexical variable is in scope, and even create references to it. In this example, &lt;code&gt;increment_count&lt;/code&gt; and &lt;code&gt;return_count&lt;/code&gt; share the variable. One function adds to the value and the other simply returns the value. They can both access &lt;code&gt;$count&lt;/code&gt;, and since it has gone out of scope, there is no other way to access it.</source>
          <target state="translated">前の例では、1つの関数のみがその参照を記憶しているため、function-private変数を作成しました。変数がスコープ内にある間に複数の関数を定義でき、各関数は「プライベート」変数を共有できます。字句変数がスコープ内にあるときに関数の外部からアクセスでき、参照を作成することもできるため、実際には「静的」ではありません。この例では、 &lt;code&gt;increment_count&lt;/code&gt; と &lt;code&gt;return_count&lt;/code&gt; が変数を共有しています。 1つの関数は値に追加し、もう1つの関数は単に値を返します。どちらも &lt;code&gt;$count&lt;/code&gt; にアクセスできますが、スコープ外になっているため、他にアクセスする方法はありません。</target>
        </trans-unit>
        <trans-unit id="d099eddc17fd02123a62f3b5a7b0e3fc3ac46d20" translate="yes" xml:space="preserve">
          <source>In the previous examples, the &lt;code&gt;{}&lt;/code&gt; code creates a reference to an empty anonymous hash. The &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function then takes that reference and associates the hash with the class in &lt;code&gt;$class&lt;/code&gt; . In the simplest case, the &lt;code&gt;$class&lt;/code&gt; variable will end up containing the string &quot;File&quot;.</source>
          <target state="translated">前の例では、 &lt;code&gt;{}&lt;/code&gt; コードは空の匿名ハッシュへの参照を作成します。次に &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; 関数はその参照を受け取り、ハッシュを &lt;code&gt;$class&lt;/code&gt; クラスに関連付けます。最も単純なケースでは、 &lt;code&gt;$class&lt;/code&gt; 変数には文字列「File」が含まれます。</target>
        </trans-unit>
        <trans-unit id="a5350392ddebfffc20c7f17feabf4ccae1793367" translate="yes" xml:space="preserve">
          <source>In the previous examples, the &lt;code&gt;{}&lt;/code&gt; code creates a reference to an empty anonymous hash. The &lt;code&gt;bless&lt;/code&gt; function then takes that reference and associates the hash with the class in &lt;code&gt;$class&lt;/code&gt;. In the simplest case, the &lt;code&gt;$class&lt;/code&gt; variable will end up containing the string &quot;File&quot;.</source>
          <target state="translated">前の例では、 &lt;code&gt;{}&lt;/code&gt; コードは空の匿名ハッシュへの参照を作成します。次に、 &lt;code&gt;bless&lt;/code&gt; 関数はその参照を取得し、ハッシュを &lt;code&gt;$class&lt;/code&gt; クラスに関連付けます。最も単純なケースでは、 &lt;code&gt;$class&lt;/code&gt; 変数に文字列「File」が含まれることになります。</target>
        </trans-unit>
        <trans-unit id="c1001ba58ff0530a993f349b4836f78782ab43f8" translate="yes" xml:space="preserve">
          <source>In the previous section we've seen a network message that was constructed by prefixing the binary message length to the actual message. You'll find that packing a length followed by so many bytes of data is a frequently used recipe since appending a null byte won't work if a null byte may be part of the data. Here is an example where both techniques are used: after two null terminated strings with source and destination address, a Short Message (to a mobile phone) is sent after a length byte:</source>
          <target state="translated">前のセクションでは、実際のメッセージにバイナリメッセージの長さの接頭辞を付けて構築されたネットワークメッセージを見てきました。ヌルバイトがデータの一部である可能性がある場合、ヌルバイトを追加してもうまくいかないので、データの長さの後に何バイトものデータを追加するのは、よく使われる方法だとわかります。ここでは、両方のテクニックを使用した例を示します:送信元と宛先のアドレスを持つ2つのNULL終端文字列の後に、ショートメッセージ(携帯電話への)が長さのバイトの後に送信されます。</target>
        </trans-unit>
        <trans-unit id="4d306b4b58fb980badf24b06473c4af8a30ac12e" translate="yes" xml:space="preserve">
          <source>In the previous sections we've learned how to use &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; to pack and unpack integers with big- or little-endian byte-order. While this is nice, it's still rather limited because it leaves out all kinds of signed integers as well as 64-bit integers. For example, if you wanted to unpack a sequence of signed big-endian 16-bit integers in a platform-independent way, you would have to write:</source>
          <target state="translated">前のセクションでは、 &lt;code&gt;n&lt;/code&gt; 、 &lt;code&gt;N&lt;/code&gt; 、 &lt;code&gt;v&lt;/code&gt; および &lt;code&gt;V&lt;/code&gt; を使用して、ビッグエンディアンまたはリトルエンディアンのバイト順で整数をパックおよびアンパックする方法を学びました。これはすばらしいことですが、64ビット整数だけでなく、あらゆる種類の符号付き整数が除外されているため、かなり制限があります。たとえば、プラットフォームに依存しない方法で一連の符号付きビッグエンディアン16ビット整数をアンパックする場合は、次のように記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="7c615499a4424a37edb78ee5b923ce59bdd024d2" translate="yes" xml:space="preserve">
          <source>In the previous sections we've learned how to use &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; to pack and unpack integers with big- or little-endian byte-order. While this is nice, it's still rather limited because it leaves out all kinds of signed integers as well as 64-bit integers. For example, if you wanted to unpack a sequence of signed big-endian 16-bit integers in a platform-independent way, you would have to write:</source>
          <target state="translated">前のセクションでは、 &lt;code&gt;n&lt;/code&gt; 、 &lt;code&gt;N&lt;/code&gt; 、 &lt;code&gt;v&lt;/code&gt; 、および &lt;code&gt;V&lt;/code&gt; を使用して、ビッグエンディアンまたはリトルエンディアンのバイトオーダーで整数をパックおよびアンパックする方法を学習しました。これは素晴らしいことですが、64ビット整数だけでなくすべての種類の符号付き整数が除外されるため、まだかなり制限されています。たとえば、署名されたビッグエンディアンの16ビット整数のシーケンスをプラットフォームに依存しない方法で解凍する場合は、次のように記述する必要があります。</target>
        </trans-unit>
        <trans-unit id="4bb18f0a7b082417093abe50cb091ae0ce9d7c1a" translate="yes" xml:space="preserve">
          <source>In the rare case in which you need to discover at run time whether a particular constant has been declared via this module, you may use this function to examine the hash &lt;code&gt;%constant::declared&lt;/code&gt; . If the given constant name does not include a package name, the current package is used.</source>
          <target state="translated">特定の定数がこのモジュールを介して宣言されているかどうかを実行時に検出する必要があるまれなケースでは、この関数を使用してハッシュ &lt;code&gt;%constant::declared&lt;/code&gt; を調べることができます。指定された定数名にパッケージ名が含まれていない場合、現在のパッケージが使用されます。</target>
        </trans-unit>
        <trans-unit id="9a85e53a816aad498e6024b9d058168f37940833" translate="yes" xml:space="preserve">
          <source>In the rare case in which you need to discover at run time whether a particular constant has been declared via this module, you may use this function to examine the hash &lt;code&gt;%constant::declared&lt;/code&gt;. If the given constant name does not include a package name, the current package is used.</source>
          <target state="translated">実行時にこのモジュールを介して特定の定数が宣言されているかどうかを検出する必要があるまれなケースでは、この関数を使用してハッシュ &lt;code&gt;%constant::declared&lt;/code&gt; を調べることができます。指定された定数名にパッケージ名が含まれていない場合は、現在のパッケージが使用されます。</target>
        </trans-unit>
        <trans-unit id="e3fa00fdc801acdaeaeaafa7c77b5e93974f8b30" translate="yes" xml:space="preserve">
          <source>In the rare case where the Pod document has code like L&amp;lt;</source>
          <target state="translated">ポッドドキュメントにL &amp;lt;のようなコードが含まれているまれなケース</target>
        </trans-unit>
        <trans-unit id="3b8dca1a84eab639eb1c11dec6ee3458c3d80e63" translate="yes" xml:space="preserve">
          <source>In the rare cases where a man page link has a section specified, that text appears in a</source>
          <target state="translated">まれに man ページのリンクにセクションが指定されている場合、そのテキストは</target>
        </trans-unit>
        <trans-unit id="b3168d71bbd1d6362a03e87b3b6357cbc463ee97" translate="yes" xml:space="preserve">
          <source>In the scalar context, returns the modified collator (but it is &lt;b&gt;not&lt;/b&gt; a clone from the original).</source>
          <target state="translated">スカラーコンテキストでは、変更されたコレーターを返します（ただし、元のクローンからのクローンではあり&lt;b&gt;ません&lt;/b&gt;）。</target>
        </trans-unit>
        <trans-unit id="4e123d33b9c36acd15c038a592d06bccf26e5a4c" translate="yes" xml:space="preserve">
          <source>In the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; , Perl obeys the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale setting. This controls the application's notion of which characters are alphabetic, numeric, punctuation,</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; を含む &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; フォームのスコープでは、Perlは &lt;code&gt;LC_CTYPE&lt;/code&gt; ロケール設定に従います。これは、文字がアルファベット、数字、句読点であるというアプリケーションの概念を制御します。</target>
        </trans-unit>
        <trans-unit id="ea3c9a616e33a3cad4631e8af654cde72ce4e1bd" translate="yes" xml:space="preserve">
          <source>In the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes collation, Perl looks to the &lt;code&gt;LC_COLLATE&lt;/code&gt; environment variable to determine the application's notions on collation (ordering) of characters. For example, &quot;b&quot; follows &quot;a&quot; in Latin alphabets, but where do &quot;&amp;aacute;&quot; and &quot;&amp;aring;&quot; belong? And while &quot;color&quot; follows &quot;chocolate&quot; in English, what about in traditional Spanish?</source>
          <target state="translated">Perlは、照合を含む &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; フォームのスコープ内で、 &lt;code&gt;LC_COLLATE&lt;/code&gt; 環境変数を調べて、文字の照合（順序）に関するアプリケーションの概念を決定します。たとえば、「b」はラテンアルファベットで「a」の後に続きますが、「&amp;aacute;」と「&amp;aring;」はどこに属しますか？そして、「色」は英語では「チョコレート」に続きますが、伝統的なスペイン語ではどうですか？</target>
        </trans-unit>
        <trans-unit id="42610118c4c59300a5cb5815d6a9dfee51cae833" translate="yes" xml:space="preserve">
          <source>In the scope of a &lt;code&gt;use locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt;, Perl obeys the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale setting. This controls the application's notion of which characters are alphabetic, numeric, punctuation,</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; を含む &lt;code&gt;use locale&lt;/code&gt; フォームのスコープでは、Perlは &lt;code&gt;LC_CTYPE&lt;/code&gt; ロケール設定に従います。これは、どの文字がアルファベット、数字、句読点であるかというアプリケーションの概念を制御します。</target>
        </trans-unit>
        <trans-unit id="8d056d856cee45cf14c89294fd2e1cd2905d97a0" translate="yes" xml:space="preserve">
          <source>In the scope of a &lt;code&gt;use locale&lt;/code&gt; form that includes collation, Perl looks to the &lt;code&gt;LC_COLLATE&lt;/code&gt; environment variable to determine the application's notions on collation (ordering) of characters. For example, &quot;b&quot; follows &quot;a&quot; in Latin alphabets, but where do &quot;&amp;aacute;&quot; and &quot;&amp;aring;&quot; belong? And while &quot;color&quot; follows &quot;chocolate&quot; in English, what about in traditional Spanish?</source>
          <target state="translated">照合を含む &lt;code&gt;use locale&lt;/code&gt; フォームのスコープでは、Perlは &lt;code&gt;LC_COLLATE&lt;/code&gt; 環境変数を調べて、文字の照合（順序付け）に関するアプリケーションの概念を決定します。たとえば、ラテンアルファベットでは「b」は「a」の後に続きますが、「&amp;aacute;」と「&amp;aring;」はどこに属しますか？そして、英語では「色」が「チョコレート」に続くのに対し、伝統的なスペイン語ではどうでしょうか。</target>
        </trans-unit>
        <trans-unit id="85dc6b4df5881b7609167c49737d8fd061975bdc" translate="yes" xml:space="preserve">
          <source>In the second example, an event driven program, the flow of control will be more like this</source>
          <target state="translated">2 番目の例では、イベント駆動型のプログラムの場合、制御の流れは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="0aec5f41df04fa608d73972b5b60d0e21665dd44" translate="yes" xml:space="preserve">
          <source>In the second example, however, we have stored another reference to the tied object in $x. That means that when untie() gets called there will still be a valid reference to the object in existence, so the destructor is not called at that time, and thus the file is not closed. The reason there is no output is because the file buffers have not been flushed to disk.</source>
          <target state="translated">しかし、二番目の例では、紐付けられたオブジェクトへの別の参照を $x に保存しています。つまり、 untie()がコールされたときには、そのオブジェクトへの有効な参照がまだ存在していることになります。出力がないのは、ファイルバッファがディスクにフラッシュされていないからです。</target>
        </trans-unit>
        <trans-unit id="69631891c8053c89e0b6bca3447bddf1c255a6c7" translate="yes" xml:space="preserve">
          <source>In the second form, the code within the BLOCK is parsed only once--at the same time the code surrounding the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself was parsed--and executed within the context of the current Perl program. This form is typically used to trap exceptions more efficiently than the first (see below), while also providing the benefit of checking the code within BLOCK at compile time.</source>
          <target state="translated">2番目の形式では、BLOCK内のコードが1回だけ解析され、同時に &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 自体を囲むコードが解析され、現在のPerlプログラムのコンテキスト内で実行されます。このフォームは通常、最初の例外（下記参照）よりも効率的に例外をトラップするために使用されますが、コンパイル時にBLOCK内のコードをチェックするという利点もあります。</target>
        </trans-unit>
        <trans-unit id="4a4b1f50ba31b2407de5a923935b79599705457e" translate="yes" xml:space="preserve">
          <source>In the second form, the code within the BLOCK is parsed only once--at the same time the code surrounding the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; itself was parsed--and executed within the context of the current Perl program. This form is typically used to trap exceptions more efficiently than the first (see below), while also providing the benefit of checking the code within BLOCK at compile time.</source>
          <target state="translated">2番目の形式では、BLOCK内のコードが1回だけ解析され、同時に &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 自体を囲むコードが解析され、現在のPerlプログラムのコンテキスト内で実行されます。このフォームは通常、最初の例外（下記参照）よりも効率的に例外をトラップするために使用されますが、コンパイル時にBLOCK内のコードをチェックするという利点もあります。</target>
        </trans-unit>
        <trans-unit id="1201aa9883bceff61ceee62acff043056d093395" translate="yes" xml:space="preserve">
          <source>In the second match, &lt;code&gt;$`&lt;/code&gt; equals &lt;code&gt;''&lt;/code&gt; because the regexp matched at the first character position in the string and stopped; it never saw the second &quot;the&quot;.</source>
          <target state="translated">2番目の一致では、正規表現が文字列の最初の文字位置で一致して停止したため、 &lt;code&gt;$`&lt;/code&gt; は &lt;code&gt;''&lt;/code&gt; に等しくなります。それは2番目の「the」を見たことがありません。</target>
        </trans-unit>
        <trans-unit id="0d9a2ff0446afe648b7cb9385c3e87c463ddf6fa" translate="yes" xml:space="preserve">
          <source>In the second match, &lt;code&gt;$`&lt;/code&gt; equals &lt;code&gt;''&lt;/code&gt; because the regexp matched at the first character position in the string and stopped; it never saw the second 'the'.</source>
          <target state="translated">2番目の一致では、正規表現が文字列の最初の文字位置で一致して停止したため、 &lt;code&gt;$`&lt;/code&gt; は &lt;code&gt;''&lt;/code&gt; に等しくなります。2番目の「the」を見たことはありません。</target>
        </trans-unit>
        <trans-unit id="37e9c3cdd59dd9ca84f70e11b37a63713067a365" translate="yes" xml:space="preserve">
          <source>In the second step, the free inheritability of the implementation (or lack thereof) is demonstrated. For this purpose it constructs a class called &lt;code&gt;NamedFile&lt;/code&gt; which is a common subclass of &lt;code&gt;Name&lt;/code&gt; and the standard class &lt;code&gt;IO::File&lt;/code&gt; . This puts inheritability to the test because objects of &lt;code&gt;IO::File&lt;/code&gt;</source>
          <target state="translated">2番目のステップでは、実装の無料の継承可能性（またはその欠如）が示されます。この目的のために、 &lt;code&gt;Name&lt;/code&gt; の共通サブクラスである &lt;code&gt;NamedFile&lt;/code&gt; というクラスと標準クラス &lt;code&gt;IO::File&lt;/code&gt; 構築します。これは、 &lt;code&gt;IO::File&lt;/code&gt; オブジェクトのため、継承性をテストに入れます。</target>
        </trans-unit>
        <trans-unit id="0af589bc3ee5e35834b2ae0ea25f9b4768b209d4" translate="yes" xml:space="preserve">
          <source>In the second step, the free inheritability of the implementation (or lack thereof) is demonstrated. For this purpose it constructs a class called &lt;code&gt;NamedFile&lt;/code&gt; which is a common subclass of &lt;code&gt;Name&lt;/code&gt; and the standard class &lt;code&gt;IO::File&lt;/code&gt;. This puts inheritability to the test because objects of &lt;code&gt;IO::File&lt;/code&gt;</source>
          <target state="translated">2番目のステップでは、実装の自由な継承性（または実装の欠如）が示されます。この目的のために、 &lt;code&gt;Name&lt;/code&gt; の共通サブクラスである &lt;code&gt;NamedFile&lt;/code&gt; と呼ばれるクラスと標準クラス &lt;code&gt;IO::File&lt;/code&gt; 構築します。 &lt;code&gt;IO::File&lt;/code&gt; オブジェクトがあるため、これにより継承性がテストされます。</target>
        </trans-unit>
        <trans-unit id="979450caa584768989298a5e328245eeac253de3" translate="yes" xml:space="preserve">
          <source>In the strictest sense, it can't be done--the script executes as a different process from the shell it was started from. Changes to a process are not reflected in its parent--only in any children created after the change. There is shell magic that may allow you to fake it by &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;ing the script's output in your shell; check out the comp.unix.questions FAQ for details.</source>
          <target state="translated">厳密には、それを行うことはできません。スクリプトは、開始されたシェルとは異なるプロセスとして実行されます。プロセスへの変更は、その親には反映されません。変更後に作成された子にのみ反映されます。シェルマジックには、シェルのスクリプトの出力を &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; することで偽造できるものがあります。詳しくはcomp.unix.questions FAQをご覧ください。</target>
        </trans-unit>
        <trans-unit id="860fc9235e7c86163e85788bda311e6bc6c6ab87" translate="yes" xml:space="preserve">
          <source>In the strictest sense, it can't be done--the script executes as a different process from the shell it was started from. Changes to a process are not reflected in its parent--only in any children created after the change. There is shell magic that may allow you to fake it by &lt;code&gt;eval()&lt;/code&gt;ing the script's output in your shell; check out the comp.unix.questions FAQ for details.</source>
          <target state="translated">厳密な意味では、それを行うことはできません。スクリプトは、開始されたシェルとは異なるプロセスとして実行されます。プロセスへの変更は、その親には反映されません。変更後に作成された子にのみ反映されます。シェルでスクリプトの出力を &lt;code&gt;eval()&lt;/code&gt; することで、それを偽造できるシェルマジックがあります。詳細については、comp.unix.questionsFAQを確認してください。</target>
        </trans-unit>
        <trans-unit id="8d5c6294b971049c13607515864de8d9b4202e94" translate="yes" xml:space="preserve">
          <source>In the symbian subdirectory there is</source>
          <target state="translated">symbian サブディレクトリには</target>
        </trans-unit>
        <trans-unit id="a6664c3e7887f18c07bf996abcbf98da47057e7d" translate="yes" xml:space="preserve">
          <source>In the syntax descriptions that follow, list operators that expect a list (and provide list context for elements of the list) are shown with LIST as an argument. Such a list may consist of any combination of scalar arguments or list values; the list values will be included in the list as if each individual element were interpolated at that point in the list, forming a longer single-dimensional list value. Commas should separate literal elements of the LIST.</source>
          <target state="translated">以下の構文の説明では、リストを期待する(リストの要素にリストコンテキストを提供する)リスト演算子は、LISTを引数として示しています。そのようなリストは、スカラー引数またはリスト値の任意の組み合わせで構成されることができます;リスト値は、各個別の要素がリストのその時点で補間され、より長い一次元のリスト値を形成しているかのようにリストに含まれます。カンマはLISTのリテラル要素を区切るべきである。</target>
        </trans-unit>
        <trans-unit id="fe67245ac84887f626543e24a3e6a624b4a7332b" translate="yes" xml:space="preserve">
          <source>In the tie() call, &lt;code&gt;VARIABLE&lt;/code&gt; is the name of the variable to be enchanted. &lt;code&gt;CLASSNAME&lt;/code&gt; is the name of a class implementing objects of the correct type. Any additional arguments in the &lt;code&gt;LIST&lt;/code&gt; are passed to the appropriate constructor method for that class--meaning TIESCALAR(), TIEARRAY(), TIEHASH(), or TIEHANDLE(). (Typically these are arguments such as might be passed to the dbminit() function of C.) The object returned by the &quot;new&quot; method is also returned by the tie() function, which would be useful if you wanted to access other methods in &lt;code&gt;CLASSNAME&lt;/code&gt; . (You don't actually have to return a reference to a right &quot;type&quot; (e.g., HASH or &lt;code&gt;CLASSNAME&lt;/code&gt; ) so long as it's a properly blessed object.) You can also retrieve a reference to the underlying object using the tied() function.</source>
          <target state="translated">tie（）呼び出しで、 &lt;code&gt;VARIABLE&lt;/code&gt; はエンチャントされる変数の名前です。 &lt;code&gt;CLASSNAME&lt;/code&gt; は、正しいタイプのオブジェクトを実装するクラスの名前です。 &lt;code&gt;LIST&lt;/code&gt; 内の追加の引数は、そのクラスの適切なコンストラクタメソッドに渡されます。つまり、TIESCALAR（）、TIEARRAY（）、TIEHASH（）、またはTIEHANDLE（）です。 （通常、これらはCのdbminit（）関数に渡される可能性があるような引数です。）「new」メソッドによって返されるオブジェクトは、tie（）関数によっても返されます。これは、他のメソッドにアクセスしたい場合に役立ちます。で &lt;code&gt;CLASSNAME&lt;/code&gt; 。 （実際に正しい「タイプ」への参照を返す必要はありません（たとえば、HASHまたは &lt;code&gt;CLASSNAME&lt;/code&gt; ）適切に祝福されたオブジェクトである限り。）また、tied（）関数を使用して、基になるオブジェクトへの参照を取得することもできます。</target>
        </trans-unit>
        <trans-unit id="c85e139a9d34793e56b9fe2b00c4a278f893619e" translate="yes" xml:space="preserve">
          <source>In the tie() call, &lt;code&gt;VARIABLE&lt;/code&gt; is the name of the variable to be enchanted. &lt;code&gt;CLASSNAME&lt;/code&gt; is the name of a class implementing objects of the correct type. Any additional arguments in the &lt;code&gt;LIST&lt;/code&gt; are passed to the appropriate constructor method for that class--meaning TIESCALAR(), TIEARRAY(), TIEHASH(), or TIEHANDLE(). (Typically these are arguments such as might be passed to the dbminit() function of C.) The object returned by the &quot;new&quot; method is also returned by the tie() function, which would be useful if you wanted to access other methods in &lt;code&gt;CLASSNAME&lt;/code&gt;. (You don't actually have to return a reference to a right &quot;type&quot; (e.g., HASH or &lt;code&gt;CLASSNAME&lt;/code&gt;) so long as it's a properly blessed object.) You can also retrieve a reference to the underlying object using the tied() function.</source>
          <target state="translated">tie（）呼び出しでは、 &lt;code&gt;VARIABLE&lt;/code&gt; はエンチャントされる変数の名前です。 &lt;code&gt;CLASSNAME&lt;/code&gt; は、正しいタイプのオブジェクトを実装するクラスの名前です。 &lt;code&gt;LIST&lt;/code&gt; 内の追加の引数はすべて、そのクラスの適切なコンストラクターメソッドに渡されます。つまり、TIESCALAR（）、TIEARRAY（）、TIEHASH（）、またはTIEHANDLE（）です。 （通常、これらはCのdbminit（）関数に渡される可能性のある引数です。）「new」メソッドによって返されるオブジェクトは、tie（）関数によっても返されます。これは、他のメソッドにアクセスする場合に役立ちます。で &lt;code&gt;CLASSNAME&lt;/code&gt; 。 （実際には、正しい「タイプ」（HASHや &lt;code&gt;CLASSNAME&lt;/code&gt; など）への参照を返す必要はありません。）適切に祝福されたオブジェクトである限り。）tied（）関数を使用して、基になるオブジェクトへの参照を取得することもできます。</target>
        </trans-unit>
        <trans-unit id="72e605f529d11854bba56a166fe10700b1dd88fb" translate="yes" xml:space="preserve">
          <source>In the two-argument (and one-argument) form, opening &lt;code&gt;&amp;lt;-&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; opens STDIN and opening &lt;code&gt;&amp;gt;-&lt;/code&gt; opens STDOUT.</source>
          <target state="translated">2つの引数（および1つの引数）の形式では、 &lt;code&gt;&amp;lt;-&lt;/code&gt; または &lt;code&gt;-&lt;/code&gt; を開くとSTDINが開き、 &lt;code&gt;&amp;gt;-&lt;/code&gt; を開くとSTDOUTが開きます。</target>
        </trans-unit>
        <trans-unit id="43780fa78aa7e37a1a813f3169ce3533b0cbb0cd" translate="yes" xml:space="preserve">
          <source>In the two-argument form of open(), a pipe open can be achieved by either appending or prepending a pipe symbol to the second argument:</source>
          <target state="translated">open()の 2 引数形式では、第 2 引数にパイプシンボルを追加または前置することでパイプオープンを実現できます。</target>
        </trans-unit>
        <trans-unit id="305b7a93b43681322f3469e0f0cb84a704ec6817" translate="yes" xml:space="preserve">
          <source>In the unlikely case of a SV requiring more complex initialization, you can create an empty SV with newSV(len). If &lt;code&gt;len&lt;/code&gt; is 0 an empty SV of type NULL is returned, else an SV of type PV is returned with len + 1 (for the &lt;code&gt;NUL&lt;/code&gt; ) bytes of storage allocated, accessible via SvPVX. In both cases the SV has the undef value.</source>
          <target state="translated">より複雑な初期化を必要とするSVのまれなケースでは、newSV（len）を使用して空のSVを作成できます。 &lt;code&gt;len&lt;/code&gt; が0の場合、タイプNULLの空のSVが返されます。それ以外の場合、タイプPVのSVは、SvPVXを介してアクセス可能なlen + 1（ &lt;code&gt;NUL&lt;/code&gt; の場合）バイトのストレージで返されます。どちらの場合も、SVにはundef値があります。</target>
        </trans-unit>
        <trans-unit id="a7cf307c9a8a074b8b42ee12dd010c5730718073" translate="yes" xml:space="preserve">
          <source>In the unlikely case of a SV requiring more complex initialization, you can create an empty SV with newSV(len). If &lt;code&gt;len&lt;/code&gt; is 0 an empty SV of type NULL is returned, else an SV of type PV is returned with len + 1 (for the &lt;code&gt;NUL&lt;/code&gt;) bytes of storage allocated, accessible via SvPVX. In both cases the SV has the undef value.</source>
          <target state="translated">より複雑な初期化を必要とするSVのまれなケースでは、newSV（len）を使用して空のSVを作成できます。 &lt;code&gt;len&lt;/code&gt; が0の場合、タイプNULLの空のSVが返されます。それ以外の場合、タイプPVのSVが返され、ストレージのlen + 1（ &lt;code&gt;NUL&lt;/code&gt; の場合）バイトが割り当てられ、SvPVXを介してアクセスできます。どちらの場合も、SVにはundef値があります。</target>
        </trans-unit>
        <trans-unit id="d65702a5086ab6fd62074e14eca8df9ddcb2f9f3" translate="yes" xml:space="preserve">
          <source>In the unlikely situation that you need to tell the parser that you will accept additional directives (&quot;=foo&quot; things), you need to first set the parser to treat its content as data (i.e., not really processed at all), or as verbatim (mostly just expanding tabs), or as processed text (parsing formatting codes like B&amp;lt;...&amp;gt;).</source>
          <target state="translated">追加のディレクティブ（ &quot;= foo&quot;のもの）を受け入れることをパーサーに通知する必要があるというまれな状況では、最初にパーサーを設定して、そのコンテンツをデータとして（つまり、実際にはまったく処理されない）、またはとして処理する必要があります。逐語的（ほとんどはタブを展開するだけ）、または処理されたテキストとして（B &amp;lt;...&amp;gt;のようなフォーマットコードを解析する）。</target>
        </trans-unit>
        <trans-unit id="e08f73822da4db28b0244d63be2806e6742a13f9" translate="yes" xml:space="preserve">
          <source>In the words of Chaim Frenkel: &quot;Perl's grammar can not be reduced to BNF. The work of parsing perl is distributed between yacc, the lexer, smoke and mirrors.&quot;</source>
          <target state="translated">Chaim Frenkelの言葉を借りれば、「Perlの文法はBNFに還元することはできない。Perlを解析する作業は、yacc、レキサー、煙と鏡の間に分散されています。&quot;</target>
        </trans-unit>
        <trans-unit id="eea8935b77be896004ea3b86596d8c4b9f389127" translate="yes" xml:space="preserve">
          <source>In the work crew model, several threads are created that do essentially the same thing to different pieces of data. It closely mirrors classical parallel processing and vector processors, where a large array of processors do the exact same thing to many pieces of data.</source>
          <target state="translated">ワーククルーモデルでは、複数のスレッドが作成され、異なるデータに対して本質的に同じことを行います。これは、大規模なプロセッサの配列が多くのデータに対して全く同じことを行う古典的な並列処理やベクトルプロセッサと密接に関係しています。</target>
        </trans-unit>
        <trans-unit id="c55ef95af3c2d0a3702a06238a73d0da82b1e62b" translate="yes" xml:space="preserve">
          <source>In the year 2010 App::cpanminus was launched as a new approach to a cpan shell with a considerably smaller footprint. Very cool stuff.</source>
          <target state="translated">2010年、App::cpanminusは、かなり小さなフットプリントを持つcpanシェルへの新しいアプローチとして発表されました。非常にクールな内容です。</target>
        </trans-unit>
        <trans-unit id="113762dd3316218250364ac4d21aa3eda82fed63" translate="yes" xml:space="preserve">
          <source>In theory &lt;code&gt;Strtol&lt;/code&gt; and &lt;code&gt;Strtoul&lt;/code&gt; may not be defined if the machine perl is built on doesn't actually have strtol and strtoul. But as those 2 functions are part of the 1989 ANSI C spec we suspect you'll find them everywhere by now.</source>
          <target state="translated">理論 &lt;code&gt;Strtol&lt;/code&gt; 、perlが構築されているマシンに実際にstrtolとstrtoulがない場合、Strtolと &lt;code&gt;Strtoul&lt;/code&gt; は定義されない可能性があります。しかし、これらの2つの関数は1989年のANSI C仕様の一部であるため、今ではどこにでも見つかると思います。</target>
        </trans-unit>
        <trans-unit id="04c962eb376205914b3738a1df3cdb3251c93666" translate="yes" xml:space="preserve">
          <source>In theory these routines were not and are not intended to be used outside of the perl core, and are subject to change and removal at any time.</source>
          <target state="translated">理論的には、これらのルーチンはperlコアの外では使用されず、また使用することを意図していません。</target>
        </trans-unit>
        <trans-unit id="d524f396baff67e45d81dc7f8d13d5cf1e77d980" translate="yes" xml:space="preserve">
          <source>In theory, &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; is reliable from -2**63 to 2**63-1. However, because work arounds in the implementation use floating point numbers, it will become inaccurate as the time gets larger. This is a bug and will be fixed in the future.</source>
          <target state="translated">理論的には、 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; は-2 ** 63から2 ** 63-1まで信頼できます。ただし、実装での回避策は浮動小数点数を使用するため、時間が長くなると不正確になります。これはバグであり、将来修正される予定です。</target>
        </trans-unit>
        <trans-unit id="6b03e06382fed416572947e88ed120d6b2caf5ff" translate="yes" xml:space="preserve">
          <source>In theory, &lt;code&gt;gmtime&lt;/code&gt; is reliable from -2**63 to 2**63-1. However, because work-arounds in the implementation use floating point numbers, it will become inaccurate as the time gets larger. This is a bug and will be fixed in the future.</source>
          <target state="translated">理論的には、 &lt;code&gt;gmtime&lt;/code&gt; は-2 ** 63から2 ** 63-1まで信頼できます。ただし、実装の回避策では浮動小数点数が使用されるため、時間が長くなると不正確になります。これはバグであり、将来修正される予定です。</target>
        </trans-unit>
        <trans-unit id="cbe5df9e111a076eb83a7b1ca2b907e2c293b988" translate="yes" xml:space="preserve">
          <source>In these loop constructs, the assigned value (whether assignment is automatic or explicit) is then tested to see whether it is defined. The defined test avoids problems where the line has a string value that would be treated as false by Perl; for example a &quot;&quot; or a &lt;code&gt;&quot;0&quot;&lt;/code&gt; with no trailing newline. If you really mean for such values to terminate the loop, they should be tested for explicitly:</source>
          <target state="translated">これらのループ構造では、割り当てられた値（割り当てが自動か明示か）がテストされ、定義されているかどうかが確認されます。定義されたテストは、Perlによってfalseとして扱われる文字列値が行に含まれるという問題を回避します。たとえば、末尾に改行がない「」または &lt;code&gt;&quot;0&quot;&lt;/code&gt; 。そのような値がループを終了することを本当に意味している場合は、明示的にテストする必要があります。</target>
        </trans-unit>
        <trans-unit id="6e44b8059bd25cac80d7a80701ceeb87c0cc485a" translate="yes" xml:space="preserve">
          <source>In this -exec rendering, each opcode is executed in the order shown. The add opcode, marked with '*', is discussed in more detail.</source>
          <target state="translated">この -exec レンダリングでは、各オペコードが表示された順に実行されます。'*' でマークされた add オプコードについては、さらに詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="fd1f4af2f36f22296f6e12cb734299d228fd203a" translate="yes" xml:space="preserve">
          <source>In this alternation, it is important to put &lt;code&gt;'\d+\.\d+'&lt;/code&gt; before &lt;code&gt;'\d+\.'&lt;/code&gt; . If &lt;code&gt;'\d+\.'&lt;/code&gt; were first, the regexp would happily match that and ignore the fractional part of the number.</source>
          <target state="translated">この代替では、 &lt;code&gt;'\d+\.\d+'&lt;/code&gt; 前に &lt;code&gt;'\d+\.'&lt;/code&gt; \ d +」を置くことが重要です。。 &lt;code&gt;'\d+\.'&lt;/code&gt; 場合 最初は、正規表現が喜んでそれに一致し、数値の小数部分を無視します。</target>
        </trans-unit>
        <trans-unit id="4d8fb7dabadcf5fdf3a7d10f33d4299f66b99d0d" translate="yes" xml:space="preserve">
          <source>In this alternation, it is important to put &lt;code&gt;'\d+\.\d+'&lt;/code&gt; before &lt;code&gt;'\d+\.'&lt;/code&gt;. If &lt;code&gt;'\d+\.'&lt;/code&gt; were first, the regexp would happily match that and ignore the fractional part of the number.</source>
          <target state="translated">この交替では、 &lt;code&gt;'\d+\.\d+'&lt;/code&gt; 前に &lt;code&gt;'\d+\.'&lt;/code&gt; \ d +」を置くことが重要です。。もし &lt;code&gt;'\d+\.'&lt;/code&gt; 最初は、正規表現はそれとうまく一致し、数値の小数部分を無視します。</target>
        </trans-unit>
        <trans-unit id="c0e19afab75cca33f669db41034484d08b958820" translate="yes" xml:space="preserve">
          <source>In this call,</source>
          <target state="translated">この電話では</target>
        </trans-unit>
        <trans-unit id="4ecf4a828b4af8d398e7cb607aebb3e775eec012" translate="yes" xml:space="preserve">
          <source>In this call, &lt;code&gt;entersubop&lt;/code&gt; is a pointer to the &lt;code&gt;entersub&lt;/code&gt; op, which may be replaced by the check function, and &lt;code&gt;namegv&lt;/code&gt; supplies the name that should be used by the check function to refer to the callee of the &lt;code&gt;entersub&lt;/code&gt; op if it needs to emit any diagnostics. It is permitted to apply the check function in non-standard situations, such as to a call to a different subroutine or to a method call.</source>
          <target state="translated">この呼び出しでは、 &lt;code&gt;entersubop&lt;/code&gt; は &lt;code&gt;entersub&lt;/code&gt; opへのポインターであり、check関数で置き換えることができます &lt;code&gt;namegv&lt;/code&gt; は、check関数が &lt;code&gt;entersub&lt;/code&gt; opの呼び出し先を参照するために使用する名前を提供します。診断。別のサブルーチンの呼び出しやメソッドの呼び出しなど、非標準の状況でチェック関数を適用することは許可されています。</target>
        </trans-unit>
        <trans-unit id="6f085ed6c4e3052eb0bb052f156e9a4157a1fe5d" translate="yes" xml:space="preserve">
          <source>In this call, the two arrays will be populated as shown below (for Unicode 6.0):</source>
          <target state="translated">この呼び出しでは、以下のように2つの配列が入力されます(Unicode 6.0の場合)。</target>
        </trans-unit>
        <trans-unit id="9ebdd72fd702032acef9641f741ed417c8e827d9" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;IO::Compress::Zip&lt;/code&gt; will check that &lt;code&gt;$rawdata&lt;/code&gt; consists of zero or more conformant sub-fields.</source>
          <target state="translated">この場合、 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; は、 &lt;code&gt;$rawdata&lt;/code&gt; が0個以上の適合サブフィールドで構成されていることを確認します。</target>
        </trans-unit>
        <trans-unit id="7445390dec364c96fb636b6c3a3e08bbc004467f" translate="yes" xml:space="preserve">
          <source>In this case a possible way around this problem is to predefine a series of C functions to act as the interface to Perl, thus</source>
          <target state="translated">この場合、この問題を回避する方法としては、Perlへのインターフェースとして動作する一連のC関数を事前に定義しておくことです。</target>
        </trans-unit>
        <trans-unit id="e58eeb1fce65fa0151692bc12dbf74ccd83c8127" translate="yes" xml:space="preserve">
          <source>In this case it is possible to speed up the routine (often quite substantially) by using the lightweight callback API. The idea is that the calling context only needs to be created and destroyed once, and the sub can be called arbitrarily many times in between.</source>
          <target state="translated">この場合、軽量コールバック API を使用することで、ルーチンを高速化することができます (多くの場合、かなり大幅に)。呼び出しコンテキストは一度だけ作成して破棄する必要があり、その間にサブを任意に何度も呼び出すことができるという考え方です。</target>
        </trans-unit>
        <trans-unit id="befe7f5d777ad4551126d4a3070f7f52a7093b40" translate="yes" xml:space="preserve">
          <source>In this case the extra input files will be passed to the program after the target file:</source>
          <target state="translated">この場合、余分な入力ファイルはターゲットファイルの後にプログラムに渡されます。</target>
        </trans-unit>
        <trans-unit id="7a45b342cd0260187347347f25fa6f1ce0fc4500" translate="yes" xml:space="preserve">
          <source>In this case the flow of control can consist of only the repeated sequence</source>
          <target state="translated">この場合、制御の流れは、繰り返しのシーケンスのみで構成することができます。</target>
        </trans-unit>
        <trans-unit id="de52280d051bfe1e84ce26c045f4bd463f4ae0ee" translate="yes" xml:space="preserve">
          <source>In this case the functions &lt;code&gt;fn1&lt;/code&gt; , &lt;code&gt;fn2&lt;/code&gt; , and &lt;code&gt;fn3&lt;/code&gt; are used to remember the Perl subroutine to be called. Each of the functions holds a separate hard-wired index which is used in the function &lt;code&gt;Pcb&lt;/code&gt; to access the &lt;code&gt;Map&lt;/code&gt; array and actually call the Perl subroutine.</source>
          <target state="translated">この場合、関数 &lt;code&gt;fn1&lt;/code&gt; 、 &lt;code&gt;fn2&lt;/code&gt; 、および &lt;code&gt;fn3&lt;/code&gt; は、呼び出されるPerlサブルーチンを記憶するために使用されます。それぞれの関数は、 &lt;code&gt;Map&lt;/code&gt; 配列にアクセスして実際にPerlサブルーチンを呼び出すために関数 &lt;code&gt;Pcb&lt;/code&gt; で使用される個別のハードワイヤードインデックスを保持します。</target>
        </trans-unit>
        <trans-unit id="a32656bde8fd76ba84b5248615b4f3d9ae23b187" translate="yes" xml:space="preserve">
          <source>In this case the functions &lt;code&gt;fn1&lt;/code&gt;, &lt;code&gt;fn2&lt;/code&gt;, and &lt;code&gt;fn3&lt;/code&gt; are used to remember the Perl subroutine to be called. Each of the functions holds a separate hard-wired index which is used in the function &lt;code&gt;Pcb&lt;/code&gt; to access the &lt;code&gt;Map&lt;/code&gt; array and actually call the Perl subroutine.</source>
          <target state="translated">この場合、関数 &lt;code&gt;fn1&lt;/code&gt; 、 &lt;code&gt;fn2&lt;/code&gt; 、および &lt;code&gt;fn3&lt;/code&gt; は、呼び出されるPerlサブルーチンを記憶するために使用されます。各関数は、 &lt;code&gt;Map&lt;/code&gt; 配列にアクセスし、実際にPerlサブルーチンを呼び出すために、関数 &lt;code&gt;Pcb&lt;/code&gt; で使用される個別のハードワイヤードインデックスを保持しています。</target>
        </trans-unit>
        <trans-unit id="4ba717b73fce507fddc399244f240ef5b6f054dd" translate="yes" xml:space="preserve">
          <source>In this case the input fileglob &lt;code&gt;*.tar.gz&lt;/code&gt; will be transformed into this Perl regular expression</source>
          <target state="translated">この場合、入力ファイルglob &lt;code&gt;*.tar.gz&lt;/code&gt; はこのPerl正規表現に変換されます</target>
        </trans-unit>
        <trans-unit id="779676f9752f28e10579e10de2beca329de72fea" translate="yes" xml:space="preserve">
          <source>In this case the main point to note is that only the last item in the list is returned from the subroutine.</source>
          <target state="translated">この場合の注意点は、サブルーチンからリストの最後の項目だけが返ってくることです。</target>
        </trans-unit>
        <trans-unit id="570da359699c43b4bafeef5621d77b9bbf97eae1" translate="yes" xml:space="preserve">
          <source>In this case the program will be run multiple times using each target file.</source>
          <target state="translated">この場合、各ターゲットファイルを使用して複数回実行されます。</target>
        </trans-unit>
        <trans-unit id="2b0f3bc0334984124b9519a2c06691727251a21f" translate="yes" xml:space="preserve">
          <source>In this case we know that the string must contain a &lt;code&gt;foo&lt;/code&gt; which must be followed by &lt;code&gt;bar&lt;/code&gt; . We can use Fast Boyer-Moore matching as implemented in &lt;code&gt;fbm_instr()&lt;/code&gt; to find the location of these strings. If they don't exist then we don't need to resort to the much more expensive regex engine. Even better, if they do exist then we can use their positions to reduce the search space that the regex engine needs to cover to determine if the entire pattern matches.</source>
          <target state="translated">この場合、文字列には &lt;code&gt;foo&lt;/code&gt; が含まれている必要があり、その後ろに &lt;code&gt;bar&lt;/code&gt; が続く必要があります。これらの文字列の場所を見つけるために、 &lt;code&gt;fbm_instr()&lt;/code&gt; で実装されているFast Boyer-Mooreマッチングを使用できます。それらが存在しない場合は、はるかに高価な正規表現エンジンに頼る必要はありません。さらに良いことに、それらが存在する場合は、それらの位置を使用して、パターン全体が一致するかどうかを判断するために正規表現エンジンがカバーする必要がある検索スペースを減らすことができます。</target>
        </trans-unit>
        <trans-unit id="69f3e109a5f7360c04fda6b9c374a7b2aee30c55" translate="yes" xml:space="preserve">
          <source>In this case we know that the string must contain a &lt;code&gt;foo&lt;/code&gt; which must be followed by &lt;code&gt;bar&lt;/code&gt;. We can use Fast Boyer-Moore matching as implemented in &lt;code&gt;fbm_instr()&lt;/code&gt; to find the location of these strings. If they don't exist then we don't need to resort to the much more expensive regex engine. Even better, if they do exist then we can use their positions to reduce the search space that the regex engine needs to cover to determine if the entire pattern matches.</source>
          <target state="translated">この場合、文字列には &lt;code&gt;foo&lt;/code&gt; が含まれている必要があり、その後に &lt;code&gt;bar&lt;/code&gt; が続く必要があります。 &lt;code&gt;fbm_instr()&lt;/code&gt; に実装されているFast Boyer-Mooreマッチングを使用して、これらの文字列の場所を見つけることができます。それらが存在しない場合は、はるかに高価な正規表現エンジンに頼る必要はありません。さらに良いことに、それらが存在する場合は、それらの位置を使用して、パターン全体が一致するかどうかを判断するために正規表現エンジンがカバーする必要のある検索スペースを減らすことができます。</target>
        </trans-unit>
        <trans-unit id="7adf1e07cf7e2de470c351018728e0b1e6d507de" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be substituted for the item to be cloned. If set to zero:</source>
          <target state="translated">この場合、クローンされるアイテムの代わりに &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が使用されます。ゼロに設定した場合：</target>
        </trans-unit>
        <trans-unit id="fd0174890e09efbb34e87a3b7a337a821e192e2c" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;JSON::PP&lt;/code&gt; creates a tagged JSON value, using a nonstandard extension to the JSON syntax.</source>
          <target state="translated">この場合、 &lt;code&gt;JSON::PP&lt;/code&gt; は、JSON構文の非標準の拡張機能を使用して、タグ付きJSON値を作成します。</target>
        </trans-unit>
        <trans-unit id="8c3e63cc6861b8f9065b2614b3c8a800786d3119" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;undef&lt;/code&gt; will be substituted for the item to be cloned. If set to zero:</source>
          <target state="translated">この場合、複製されるアイテムの代わりに &lt;code&gt;undef&lt;/code&gt; が使用されます。ゼロに設定されている場合：</target>
        </trans-unit>
        <trans-unit id="6c66364cb0f3415ad0b76d2776349bcfcc95f50e" translate="yes" xml:space="preserve">
          <source>In this case, because the &lt;code&gt;JMPENV&lt;/code&gt; level recorded in the &lt;code&gt;CxEVAL&lt;/code&gt; differs from the current one, &lt;code&gt;docatch&lt;/code&gt; just does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; and the C stack unwinds to:</source>
          <target state="translated">この場合、ため &lt;code&gt;JMPENV&lt;/code&gt; のに記録レベル &lt;code&gt;CxEVAL&lt;/code&gt; の現在のものと異なる、 &lt;code&gt;docatch&lt;/code&gt; はちょうどし &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; ：およびCスタック展開を</target>
        </trans-unit>
        <trans-unit id="38ba605349bb20448e174208a445c574b3bbbe89" translate="yes" xml:space="preserve">
          <source>In this case, if</source>
          <target state="translated">この場合、もし</target>
        </trans-unit>
        <trans-unit id="bb541d2c2f3bc8d3faf27ff1a86aae9a349b1c56" translate="yes" xml:space="preserve">
          <source>In this case, it finds a &lt;code&gt;save()&lt;/code&gt; method in the &lt;code&gt;File&lt;/code&gt; class. Note that the object passed to &lt;code&gt;save()&lt;/code&gt; in this case is still a &lt;code&gt;File::MP3&lt;/code&gt; object, even though the method is found in the &lt;code&gt;File&lt;/code&gt; class.</source>
          <target state="translated">この場合、 &lt;code&gt;File&lt;/code&gt; クラスで &lt;code&gt;save()&lt;/code&gt; メソッドを見つけます。この場合に &lt;code&gt;save()&lt;/code&gt; に渡されるオブジェクトは、メソッドが &lt;code&gt;File&lt;/code&gt; クラスにある場合でも、 &lt;code&gt;File::MP3&lt;/code&gt; オブジェクトであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="904227a42dd6a4688cfaf025d7e725bbdfcba9cb" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;TO_JSON&lt;/code&gt; method of the object is invoked in scalar context. It must return a single scalar that can be directly encoded into JSON. This scalar replaces the object in the JSON text.</source>
          <target state="translated">この場合、オブジェクトの &lt;code&gt;TO_JSON&lt;/code&gt; メソッドはスカラーコンテキストで呼び出されます。JSONに直接エンコードできる単一のスカラーを返す必要があります。このスカラーは、JSONテキストのオブジェクトを置き換えます。</target>
        </trans-unit>
        <trans-unit id="d9ed12158dee993299753ff9f1084ddd79644a4a" translate="yes" xml:space="preserve">
          <source>In this case, the BEGIN is freed immediately after execution since there are no active references to it: the anon sub prototype has &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; set since it's not a closure, and $a points to the same CV, so it doesn't contribute to BEGIN's refcount either. When $a is executed, the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; '$x'&lt;/code&gt; causes the chain of &lt;code&gt;CvOUTSIDE&lt;/code&gt; s to be followed, and the freed BEGIN is accessed.</source>
          <target state="translated">この場合、BEGINへのアクティブな参照がないため、BEGINは実行直後に解放されます &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; サブプロトタイプは、クロージャーではないためCvWEAKOUTSIDEが設定されており、$ aは同じCVを指しているため、BEGINの原因にはなりません。 refcountのどちらか。$ aが実行されると、 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; '$x'&lt;/code&gt; によって &lt;code&gt;CvOUTSIDE&lt;/code&gt; のチェーンが追跡され、解放されたBEGINがアクセスされます。</target>
        </trans-unit>
        <trans-unit id="2d6feeb3d0329a363666ad3d9cc4549891bf4b38" translate="yes" xml:space="preserve">
          <source>In this case, the BEGIN is freed immediately after execution since there are no active references to it: the anon sub prototype has &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; set since it's not a closure, and $a points to the same CV, so it doesn't contribute to BEGIN's refcount either. When $a is executed, the &lt;code&gt;eval '$x'&lt;/code&gt; causes the chain of &lt;code&gt;CvOUTSIDE&lt;/code&gt;s to be followed, and the freed BEGIN is accessed.</source>
          <target state="translated">この場合、BEGINはアクティブな参照がないため、実行直後に解放されます &lt;code&gt;CvWEAKOUTSIDE&lt;/code&gt; サブプロトタイプにはクロージャではないためCvWEAKOUTSIDEが設定されており、$ aは同じCVを指しているため、BEGINには寄与しません。どちらかを参照します。$ aが実行されると、 &lt;code&gt;eval '$x'&lt;/code&gt; によって &lt;code&gt;CvOUTSIDE&lt;/code&gt; のチェーンが追跡され、解放されたBEGINにアクセスします。</target>
        </trans-unit>
        <trans-unit id="a9a3c5178883306c2188aa48aea362372e427fd0" translate="yes" xml:space="preserve">
          <source>In this case, the behavior is problematic and is not so easily described. Here are two bugs that cannot easily be fixed without breaking existing programs:</source>
          <target state="translated">この場合、動作に問題があり、簡単には記述できません。ここでは、既存のプログラムを壊さずに簡単に修正できないバグを2つ紹介します。</target>
        </trans-unit>
        <trans-unit id="445e238a2cf161c353789dd6ff6ac3c0dc14cd3f" translate="yes" xml:space="preserve">
          <source>In this case, the data flow from the pipeline can be represented as follows:</source>
          <target state="translated">この場合、パイプラインからのデータフローは以下のように表すことができる。</target>
        </trans-unit>
        <trans-unit id="76ef174320084e5b9df3d70ddc86b3f46c5bccd4" translate="yes" xml:space="preserve">
          <source>In this case, the function will overload both of the three way comparison operators. For all overload operations using non-alpha characters, you must type the parameter without quoting, separating multiple overloads with whitespace. Note that &quot;&quot; (the stringify overload) should be entered as \&quot;\&quot; (i.e. escaped).</source>
          <target state="translated">この場合、この関数は 3 者間比較演算子の両方をオーバーロードします。アルファ文字以外の文字を使用するすべてのオーバーロード操作では、複数のオーバーロードを空白で区切って、クォートせずにパラメータを入力する必要があります。&quot;&quot; (文字列化オーバーロード)は、&quot;&quot;\&quot;\&quot; (つまりエスケープされた)と入力する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b8364049e54a9d18ffd4855b1a0b1335cff126ce" translate="yes" xml:space="preserve">
          <source>In this case, the name (&lt;code&gt;http&lt;/code&gt;) will be tried first, but if the resolver does not understand it then the port number (&lt;code&gt;80&lt;/code&gt;) will be used instead.</source>
          <target state="translated">この場合、名前（ &lt;code&gt;http&lt;/code&gt; ）が最初に試行されますが、リゾルバーがそれを理解しない場合は、代わりにポート番号（ &lt;code&gt;80&lt;/code&gt; ）が使用されます。</target>
        </trans-unit>
        <trans-unit id="3d4b7be359855c6b427d300bbc65846d64f8cf9d" translate="yes" xml:space="preserve">
          <source>In this case, the reference count for the variables will never reach 0, and the references will never be garbage-collected. This can lead to memory leaks.</source>
          <target state="translated">この場合、変数の参照カウントが0になることはありませんし、その参照がガーベージコレクションされることもありません。これはメモリリークにつながる可能性があります。</target>
        </trans-unit>
        <trans-unit id="cc6f51a2de8f8d888eeb99016141d99a3d195bd9" translate="yes" xml:space="preserve">
          <source>In this case, the yes-pattern is never directly executed, and no no-pattern is allowed. Similar in spirit to &lt;code&gt;(?{0})&lt;/code&gt; but more efficient. See below for details.</source>
          <target state="translated">この場合、yes-patternが直接実行されることはなく、no-patternは許可されません。精神的には &lt;code&gt;(?{0})&lt;/code&gt; に似ていますが、より効率的です。詳細については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="c85c8e55100a9206350f3d9de1af13e8521e9423" translate="yes" xml:space="preserve">
          <source>In this case, the yes-pattern is never directly executed, and no no-pattern is allowed. Similar in spirit to &lt;code&gt;(?{0})&lt;/code&gt; but more efficient. See below for details. Full syntax: &lt;code&gt;(?(DEFINE)&lt;i&gt;definitions&lt;/i&gt;...)&lt;/code&gt;</source>
          <target state="translated">この場合、yes-patternが直接実行されることはなく、no-patternは許可されません。精神的には &lt;code&gt;(?{0})&lt;/code&gt; に似ていますが、より効率的です。詳細については、以下を参照してください。完全な構文： &lt;code&gt;(?(DEFINE)&lt;i&gt;definitions&lt;/i&gt;...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="18c031d44e01689714a7d1be31709243cd683ac5" translate="yes" xml:space="preserve">
          <source>In this case, there's not much to see, but of course normally there's pages of stuff to wade through, and 'l' can be very useful. To reset your view to the line we're about to execute, type a lone period '.':</source>
          <target state="translated">この場合、あまり見るべきものはありませんが、もちろん通常は何ページものページがあり、'l' は非常に便利です。これから実行しようとしている行にビューをリセットするには、ピリオド '.' を入力してください。</target>
        </trans-unit>
        <trans-unit id="d6cf564bd8d8897a564d43efb035ccf8128bfa59" translate="yes" xml:space="preserve">
          <source>In this case, you cannot omit the first</source>
          <target state="translated">この場合、最初の</target>
        </trans-unit>
        <trans-unit id="c6ff251bc24fa4db8e24130b2fd6042c3837352e" translate="yes" xml:space="preserve">
          <source>In this case, you use the &lt;code&gt;detach()&lt;/code&gt; method. Once a thread is detached, it'll run until it's finished; then Perl will clean up after it automatically.</source>
          <target state="translated">この場合、 &lt;code&gt;detach()&lt;/code&gt; メソッドを使用します。スレッドが切り離されると、完了するまで実行されます。その後、Perlはその後自動的にクリーンアップします。</target>
        </trans-unit>
        <trans-unit id="f06a2a722f183edc4aa583848f94d04c7c5ace33" translate="yes" xml:space="preserve">
          <source>In this document, &quot;must&quot; / &quot;must not&quot;, &quot;should&quot; / &quot;should not&quot;, and &quot;may&quot; have their conventional (cf. RFC 2119) meanings: &quot;X must do Y&quot; means that if X doesn't do Y, it's against this specification, and should really be fixed. &quot;X should do Y&quot; means that it's recommended, but X may fail to do Y, if there's a good reason. &quot;X may do Y&quot; is merely a note that X can do Y at will (although it is up to the reader to detect any connotation of &quot;and I think it would be</source>
          <target state="translated">このドキュメントでは、&quot;must&quot;/&quot;must not&quot;、&quot;should&quot;/&quot;should not&quot;、および &quot;may&quot; は、従来の (RFC 2119 参照)意味を持っています。&quot;X must do Y&quot; は、もし X が Y をしなければ、それはこの仕様に反しており、本当に修正されるべきだということを意味します。&quot;X should do Y &quot;は、それが推奨されているが、正当な理由があれば、XはYをしないかもしれないということを意味します。&quot;X may do Y&quot; は、単に X が自由に Y をすることができるという注意書きに過ぎません (ただし、&quot;and I think it would be the</target>
        </trans-unit>
        <trans-unit id="f65b8f5200f2d0ab93731dfb5d397ad4f5889d0a" translate="yes" xml:space="preserve">
          <source>In this documentation, &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; on the first line of the program will stand in for whatever method works on your system. You are advised to use a specific path if you care about a specific version.</source>
          <target state="translated">このドキュメントでは、プログラムの最初の行の &lt;code&gt;#!/usr/bin/perl&lt;/code&gt; が、システムで機能するすべてのメソッドの代わりになります。特定のバージョンを気にする場合は、特定のパスを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="317bfd052c319e12e1dcc797f6ad498f8171149f" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;--all&lt;/code&gt; will</source>
          <target state="translated">この例では、 &lt;code&gt;--all&lt;/code&gt; will</target>
        </trans-unit>
        <trans-unit id="e92bf3ad9ffe37a0d52db0112f7aacb357e3a712" translate="yes" xml:space="preserve">
          <source>In this example, a new &lt;code&gt;$x&lt;/code&gt; is created when &lt;code&gt;whatever&lt;/code&gt; is called, and also a new &lt;code&gt;inner&lt;/code&gt; , which can see the new &lt;code&gt;$x&lt;/code&gt; . A &quot;state&quot; sub will only see the &lt;code&gt;$x&lt;/code&gt; from the first call to &lt;code&gt;whatever&lt;/code&gt; .</source>
          <target state="translated">この例では、 &lt;code&gt;whatever&lt;/code&gt; が呼び出されても新しい &lt;code&gt;$x&lt;/code&gt; が作成され、新しい &lt;code&gt;$x&lt;/code&gt; 表示できる新しい &lt;code&gt;inner&lt;/code&gt; も作成されます。「状態」のサブだけで表示されます &lt;code&gt;$x&lt;/code&gt; への最初の呼び出しから &lt;code&gt;whatever&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03a782210b8b5b9d56172f6b6115f6aa3cd92695" translate="yes" xml:space="preserve">
          <source>In this example, a new &lt;code&gt;$x&lt;/code&gt; is created when &lt;code&gt;whatever&lt;/code&gt; is called, and also a new &lt;code&gt;inner&lt;/code&gt;, which can see the new &lt;code&gt;$x&lt;/code&gt;. A &quot;state&quot; sub will only see the &lt;code&gt;$x&lt;/code&gt; from the first call to &lt;code&gt;whatever&lt;/code&gt;.</source>
          <target state="translated">この例では、新しい &lt;code&gt;$x&lt;/code&gt; するときに作成された &lt;code&gt;whatever&lt;/code&gt; 呼ばれ、また、新しい &lt;code&gt;inner&lt;/code&gt; 新見ることができる、 &lt;code&gt;$x&lt;/code&gt; 。「状態」のサブだけで表示されます &lt;code&gt;$x&lt;/code&gt; への最初の呼び出しから &lt;code&gt;whatever&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd205d2b3e2dec6816acf70e5f088db6d1ebf4c2" translate="yes" xml:space="preserve">
          <source>In this example, only the first two assignments will be done immediately; after this, all the changes to the file will be deferred up to the user-specified memory limit.</source>
          <target state="translated">この例では、最初の2つの割り当てだけがすぐに行われ、その後、ファイルへのすべての変更は、ユーザーが指定したメモリ制限まで延期されます。</target>
        </trans-unit>
        <trans-unit id="5a4ab6947e272be82ce081150ade300e39621eac" translate="yes" xml:space="preserve">
          <source>In this example, the expression is evaluated only once, and the tied scalar (the result of the expression) is fetched for each comparison that uses it.</source>
          <target state="translated">この例では、式は一度だけ評価され、それを使用する各比較に対して、タイドスカラ(式の結果)がフェッチされます。</target>
        </trans-unit>
        <trans-unit id="19c920ce6f8f3e81b20912d17931330182ad0a53" translate="yes" xml:space="preserve">
          <source>In this example, we will accept a reference to an array as an input parameter, and return a reference to an array of hashes. This will demonstrate manipulation of complex Perl data types from an XSUB.</source>
          <target state="translated">この例では、入力パラメータとして配列への参照を受け取り、ハッシュの配列への参照を返します。これは、XSUBから複雑なPerlのデータ型を操作することを実演します。</target>
        </trans-unit>
        <trans-unit id="b22f4e4bd19dab41fd1e0219238248b0317aa35c" translate="yes" xml:space="preserve">
          <source>In this example, we will get the following output:</source>
          <target state="translated">この例では、以下のような出力が得られます。</target>
        </trans-unit>
        <trans-unit id="ee2620c9071c60e99d08be588513a407e9d8d25d" translate="yes" xml:space="preserve">
          <source>In this example, we'll do some more work with the argument stack. The previous examples have all returned only a single value. We'll now create an extension that returns an array.</source>
          <target state="translated">この例では、引数スタックを使ってさらにいくつかの作業を行います。これまでの例では、すべて単一の値を返していました。これから配列を返す拡張モジュールを作成します。</target>
        </trans-unit>
        <trans-unit id="bc42a21b3f25368390b359d2c6a1e02f5038d3de" translate="yes" xml:space="preserve">
          <source>In this example, we'll now begin to write XSUBs that will interact with pre-defined C libraries. To begin with, we will build a small library of our own, then let h2xs write our .pm and .xs files for us.</source>
          <target state="translated">この例では、あらかじめ定義された C ライブラリと相互作用する XSUB を書き始めます。まず,自分の小さなライブラリを作成し,h2xs に .pm と .xs ファイルを書かせます.</target>
        </trans-unit>
        <trans-unit id="955bf75951fa8c51c57a77cb9f4962e2f9fbe8e1" translate="yes" xml:space="preserve">
          <source>In this facet the &lt;code&gt;details&lt;/code&gt; field overrides the &quot;failed at test_file.t line 42.&quot; message provided on assertion failure.</source>
          <target state="translated">このファセットでは、 &lt;code&gt;details&lt;/code&gt; フィールドは「test_file.tの42行目で失敗しました」を上書きします。アサーションの失敗時に提供されるメッセージ。</target>
        </trans-unit>
        <trans-unit id="ccfbfd9001b68d4bb9123e9a75f5be994042b170" translate="yes" xml:space="preserve">
          <source>In this form, it is easier to see a way to simplify the alternation. Alternatives 1, 2, and 4 all start with &lt;code&gt;\d+&lt;/code&gt; , so it could be factored out:</source>
          <target state="translated">この形式では、代替を単純化する方法がわかりやすくなります。選択肢1、2、および4はすべて &lt;code&gt;\d+&lt;/code&gt; で始まるため、除外することができます。</target>
        </trans-unit>
        <trans-unit id="8872fe0affc69c9606769a8a65343eca2f4676ad" translate="yes" xml:space="preserve">
          <source>In this form, it is easier to see a way to simplify the alternation. Alternatives 1, 2, and 4 all start with &lt;code&gt;\d+&lt;/code&gt;, so it could be factored out:</source>
          <target state="translated">この形式では、交代を単純化する方法を簡単に見つけることができます。選択肢1、2、および4はすべて &lt;code&gt;\d+&lt;/code&gt; で始まるため、次のように除外できます。</target>
        </trans-unit>
        <trans-unit id="5b24fb7d07c9db355f07769493a9de293acc8111" translate="yes" xml:space="preserve">
          <source>In this hash each key represents a category of functions and the value is a short description of that category.</source>
          <target state="translated">このハッシュでは、各キーは関数のカテゴリを表し、値はそのカテゴリの簡単な説明です。</target>
        </trans-unit>
        <trans-unit id="3f56d8b8bdb8c26426f0b6660b2be0710caeb9c2" translate="yes" xml:space="preserve">
          <source>In this hash each key represents a function and the value is a short description of that function.</source>
          <target state="translated">このハッシュでは、各キーは関数を表し、値はその関数の短い説明です。</target>
        </trans-unit>
        <trans-unit id="4112ec477caea48107dc76ca327ecc26b9559568" translate="yes" xml:space="preserve">
          <source>In this hash each key represents a function and the value is the category. The category can be a comma separated list.</source>
          <target state="translated">このハッシュでは、各キーは関数を表し、値はカテゴリを表します。カテゴリはカンマ区切りのリストにすることができます。</target>
        </trans-unit>
        <trans-unit id="5b991cc90d42bab8c037a6310ce95c7fd23aada4" translate="yes" xml:space="preserve">
          <source>In this instance the &quot;Store&quot; and &quot;Fetch&quot; methods are encapsulated inside a &quot;Filter&quot; method.</source>
          <target state="translated">この例では、&quot;Store &quot;メソッドと &quot;Fetch &quot;メソッドは &quot;Filter &quot;メソッドの中にカプセル化されています。</target>
        </trans-unit>
        <trans-unit id="d35ad5c2c0618e945079ac0ca929cf4d613d24d9" translate="yes" xml:space="preserve">
          <source>In this library, the numbers are represented in base B = 10**N, where N is the largest possible value that does not cause overflow in the intermediate computations. The base B elements are stored in an array, with the least significant element stored in array element zero. There are no leading zero elements, except a single zero element when the number is zero.</source>
          <target state="translated">このライブラリでは、数値は基底B=10**Nで表され、Nは中間計算でオーバーフローを起こさない最大の値です。ベースBの要素は配列に格納され、最下位の要素は配列要素0に格納されます。数字がゼロのときにゼロ要素が1つあることを除いて、先頭のゼロ要素はありません。</target>
        </trans-unit>
        <trans-unit id="df68cfd3648ab58a91a7f368ccaceffbf7d1f325" translate="yes" xml:space="preserve">
          <source>In this particular case we don't have to call</source>
          <target state="translated">この特定のケースでは</target>
        </trans-unit>
        <trans-unit id="dad6a924b2e38abcfe4b4ffded7acf8266a85c31" translate="yes" xml:space="preserve">
          <source>In this pass the input pattern is parsed in order to calculate how much space is needed for each regop we would need to emit. The size is also used to determine whether long jumps will be required in the program.</source>
          <target state="translated">このパスでは入力パターンが解析され、各レゴップに必要なスペースを計算します。サイズは、プログラムの中で長いジャンプが必要かどうかを判断するためにも使われます。</target>
        </trans-unit>
        <trans-unit id="41f31a4be766288871cf075eb0ef8be8f75f8e7b" translate="yes" xml:space="preserve">
          <source>In this pod section each line obeys the format</source>
          <target state="translated">このポッドセクションでは、各行はフォーマットに従います。</target>
        </trans-unit>
        <trans-unit id="64cfb9e395c018a6592c08f321f44ebdc6f304df" translate="yes" xml:space="preserve">
          <source>In this regexp, you might expect the first minimal quantifier &lt;code&gt;.*?&lt;/code&gt; to match the empty string, because it is not constrained by a &lt;code&gt;'^'&lt;/code&gt; anchor to match the beginning of the word. Principle 0 applies here, however. Because it is possible for the whole regexp to match at the start of the string, it</source>
          <target state="translated">この正規表現では、最初の最小数量詞 &lt;code&gt;.*?&lt;/code&gt; 期待するかもしれません。単語の先頭に一致するように &lt;code&gt;'^'&lt;/code&gt; アンカーによって制約されていないため、空の文字列に一致します。ただし、ここでは原則0が適用されます。文字列の先頭で正規表現全体が一致する可能性があるため、</target>
        </trans-unit>
        <trans-unit id="2a40391b3aa03b91dc32950cbb01e23eafc7a333" translate="yes" xml:space="preserve">
          <source>In this regexp, you might expect the first minimal quantifier &lt;code&gt;.*?&lt;/code&gt; to match the empty string, because it is not constrained by a &lt;code&gt;^&lt;/code&gt; anchor to match the beginning of the word. Principle 0 applies here, however. Because it is possible for the whole regexp to match at the start of the string, it</source>
          <target state="translated">この正規表現では、最初の最小量指定子 &lt;code&gt;.*?&lt;/code&gt; 空の文字列に一致します。これは、単語の先頭に一致する &lt;code&gt;^&lt;/code&gt; アンカーによる制約を受けないためです。ただし、ここでは原則0が適用されます。文字列の先頭で正規表現全体が一致する可能性があるため、</target>
        </trans-unit>
        <trans-unit id="1677ca4d68d5b3cd757901e02552a2ca6071fc8c" translate="yes" xml:space="preserve">
          <source>In this regular expression, the alternation matches either at the beginning or the end of the string since the anchors have a lower precedence than the alternation. With the &lt;code&gt;/g&lt;/code&gt; flag, the substitution makes all possible matches, so it gets both. Remember, the trailing newline matches the &lt;code&gt;\s+&lt;/code&gt;, and the &lt;code&gt;$&lt;/code&gt; anchor can match to the absolute end of the string, so the newline disappears too. Just add the newline to the output, which has the added benefit of preserving &quot;blank&quot; (consisting entirely of whitespace) lines which the &lt;code&gt;^\s+&lt;/code&gt; would remove all by itself:</source>
          <target state="translated">この正規表現では、アンカーは優先順位よりも優先順位が低いため、文字列の最初または最後のいずれかで交互に一致します。 &lt;code&gt;/g&lt;/code&gt; のそれは両方を取得するためのフラグ、置換は、すべての可能なマッチを行います。末尾の改行は &lt;code&gt;\s+&lt;/code&gt; に一致し、 &lt;code&gt;$&lt;/code&gt; アンカーは文字列の絶対的な末尾に一致する可能性があるため、改行も表示されないことに注意してください。出力に改行を追加するだけで、 &lt;code&gt;^\s+&lt;/code&gt; が単独ですべて削除する「空白」（空白のみで構成される）行を保持するという追加の利点があります。</target>
        </trans-unit>
        <trans-unit id="77b676e373d337a1558a3681668f6ee37714295f" translate="yes" xml:space="preserve">
          <source>In this statement, &lt;code&gt;World&lt;/code&gt; is a regex and the &lt;code&gt;//&lt;/code&gt; enclosing &lt;code&gt;/World/&lt;/code&gt; tells Perl to search a string for a match. The operator &lt;code&gt;=~&lt;/code&gt; associates the string with the regex match and produces a true value if the regex matched, or false if the regex did not match. In our case, &lt;code&gt;World&lt;/code&gt; matches the second word in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; , so the expression is true. This idea has several variations.</source>
          <target state="translated">このステートメントでは、 &lt;code&gt;World&lt;/code&gt; は正規表現であり、 &lt;code&gt;//&lt;/code&gt; を囲む &lt;code&gt;/World/&lt;/code&gt; は、一致する文字列を検索するようPerlに指示します。演算子 &lt;code&gt;=~&lt;/code&gt; は、文字列を正規表現一致に関連付け、正規表現が一致した場合はtrue値を生成し、正規表現が一致しなかった場合はfalseを生成します。この例では、 &lt;code&gt;World&lt;/code&gt; は &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; の 2番目の単語と一致するため、式はtrueです。このアイデアにはいくつかのバリエーションがあります。</target>
        </trans-unit>
        <trans-unit id="cb6960dd1a14a1f651e7be335db315d0fa175d1d" translate="yes" xml:space="preserve">
          <source>In this statement, &lt;code&gt;World&lt;/code&gt; is a regex and the &lt;code&gt;//&lt;/code&gt; enclosing &lt;code&gt;/World/&lt;/code&gt; tells Perl to search a string for a match. The operator &lt;code&gt;=~&lt;/code&gt; associates the string with the regex match and produces a true value if the regex matched, or false if the regex did not match. In our case, &lt;code&gt;World&lt;/code&gt; matches the second word in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt;, so the expression is true. This idea has several variations.</source>
          <target state="translated">このステートメントでは、 &lt;code&gt;World&lt;/code&gt; は正規表現であり、 &lt;code&gt;//&lt;/code&gt; 囲んでいる &lt;code&gt;/World/&lt;/code&gt; は、Perlに一致する文字列を検索するように指示します。演算子 &lt;code&gt;=~&lt;/code&gt; は、文字列を正規表現の一致に関連付け、正規表現が一致した場合はtrue値を生成し、正規表現が一致しなかった場合はfalseを生成します。この場合、 &lt;code&gt;World&lt;/code&gt; は &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; の2番目の単語と一致するため、式は真です。このアイデアにはいくつかのバリエーションがあります。</target>
        </trans-unit>
        <trans-unit id="c818981124c0efd397c772e8c5a5bccf099d60f4" translate="yes" xml:space="preserve">
          <source>In this way (as for perl's scalars) a pointer to a PerlIOBuf can be treated as a pointer to a PerlIOl.</source>
          <target state="translated">このようにして(Perlのスカラーと同様に)PerlIOBufへのポインタはPerlIOlへのポインタとして扱うことができます。</target>
        </trans-unit>
        <trans-unit id="47c607bae4c1c842072097188930b7f5e712b730" translate="yes" xml:space="preserve">
          <source>In those 8 cases above, the value of EXPR is used directly as a boolean, so no smartmatching is done. You may think of &lt;code&gt;when&lt;/code&gt; as a smartsmartmatch.</source>
          <target state="translated">上記の8つのケースでは、EXPRの値はブール値として直接使用されるため、スマートマッチングは行われません。あなたは考えるかもしれ &lt;code&gt;when&lt;/code&gt; smartsmartmatchとして。</target>
        </trans-unit>
        <trans-unit id="9186d74e76b80422b13adb44366ed78c8afac4f7" translate="yes" xml:space="preserve">
          <source>In those cases, it is easier to just append the filtering subroutine and any terminator specification directly to the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement that loads Filter::Simple, like so:</source>
          <target state="translated">そのような場合、次のように、Filtering :: Simpleをロードする &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ステートメントに直接、フィルタリングサブルーチンとターミネーター指定を追加する方が簡単です。</target>
        </trans-unit>
        <trans-unit id="db9ccecefd39facec4b439c7bf015dafd9285f67" translate="yes" xml:space="preserve">
          <source>In those cases, it is easier to just append the filtering subroutine and any terminator specification directly to the &lt;code&gt;use&lt;/code&gt; statement that loads Filter::Simple, like so:</source>
          <target state="translated">このような場合、次のように、Filter :: Simpleをロードする &lt;code&gt;use&lt;/code&gt; ステートメントにフィルタリングサブルーチンとターミネーター仕様を直接追加する方が簡単です。</target>
        </trans-unit>
        <trans-unit id="95167fe0e36a49f5080da73352ed44710a152f26" translate="yes" xml:space="preserve">
          <source>In those cases, you would turn off &lt;code&gt;strict 'refs'&lt;/code&gt; temporarily so you can play around with the symbol table. For example:</source>
          <target state="translated">そのような場合は、一時的に &lt;code&gt;strict 'refs'&lt;/code&gt; オフにして、シンボルテーブルを操作できるようにします。例えば：</target>
        </trans-unit>
        <trans-unit id="c6200c4c82d6daee49dcd17953c7919b7352b65f" translate="yes" xml:space="preserve">
          <source>In time-critical applications, it is worthwhile to avoid splitting into more fields than necessary. Thus, when assigning to a list, if LIMIT is omitted (or zero), then LIMIT is treated as though it were one larger than the number of variables in the list; for the following, LIMIT is implicitly 3:</source>
          <target state="translated">タイムクリティカルなアプリケーションでは、必要以上に多くのフィールドに分割することを避けることは価値があります。したがって、リストに代入するとき、LIMITが省略されている(またはゼロである)場合、LIMITはリスト内の変数の数よりも1つ大きいものであるかのように扱われます;以下の場合、LIMITは暗黙のうちに3です。</target>
        </trans-unit>
        <trans-unit id="d371abf0abc6f35041f85b45c9387a28fef727f3" translate="yes" xml:space="preserve">
          <source>In turning &lt;a href=&quot;Foo::Bar&quot;&gt;Foo::Bar&lt;/a&gt; into http://whatever/Foo%3a%3aBar, what to put before the &quot;Foo%3a%3aBar&quot;. The default value is &quot;https://metacpan.org/pod/&quot;.</source>
          <target state="translated">ターニングで&lt;a href=&quot;Foo::Bar&quot;&gt;はFoo ::バー&lt;/a&gt;のhttpへ：//どんな/ Fooの％3A％3aBar、 &quot;フー％3A％3aBar&quot;の前に置くために何を。デフォルト値は「https://metacpan.org/pod/」です。</target>
        </trans-unit>
        <trans-unit id="61aec1693f3cca77d878f9993860b197db04ab69" translate="yes" xml:space="preserve">
          <source>In turning &lt;a href=&quot;http://search.cpan.org/perldoc/Foo::Bar&quot;&gt;Foo::Bar&lt;/a&gt; into &lt;a href=&quot;http://whatever/Foo%3a%3aBar&quot;&gt;http://whatever/Foo%3a%3aBar&lt;/a&gt;, what to put before the &quot;Foo%3a%3aBar&quot;. The default value is &quot;&lt;a href=&quot;http://search.cpan.org/perldoc&quot;&gt;http://search.cpan.org/perldoc&lt;/a&gt;?&quot;.</source>
          <target state="translated">ターニングで&lt;a href=&quot;http://search.cpan.org/perldoc/Foo::Bar&quot;&gt;はFoo ::バー&lt;/a&gt;へ&lt;a href=&quot;http://whatever/Foo%3a%3aBar&quot;&gt;のhttp：//どんな/ Fooの％3A％3aBar&lt;/a&gt;、 &quot;フー％3A％3aBar&quot;の前に置くために何を。デフォルト値は「&lt;a href=&quot;http://search.cpan.org/perldoc&quot;&gt;http://search.cpan.org/perldoc&lt;/a&gt;？」です。</target>
        </trans-unit>
        <trans-unit id="2f2439be782d8b7a999e11dc7c3353fae2805425" translate="yes" xml:space="preserve">
          <source>In turning &lt;code&gt;&lt;a href=&quot;http://man.he.net/man5/crontab&quot;&gt;crontab(5)&lt;/a&gt;&lt;/code&gt; into http://whatever/man/1/crontab, what to put before the &quot;1/crontab&quot;. The default value is &quot;http://man.he.net/man&quot;.</source>
          <target state="translated">ターニングで &lt;code&gt;&lt;a href=&quot;http://man.he.net/man5/crontab&quot;&gt;crontab(5)&lt;/a&gt;&lt;/code&gt; // &quot;1 / crontabの&quot;の前に置くためにどのようなものは何でも/男性/ 1 / crontabのを、：のhttpに。デフォルト値は「http://man.he.net/man」です。</target>
        </trans-unit>
        <trans-unit id="fe66d5d405c8ef8a7eac08fc91eff0a843fd6e3f" translate="yes" xml:space="preserve">
          <source>In turning &lt;code&gt;&lt;i&gt;crontab(5)&lt;/i&gt;&lt;/code&gt; into &lt;a href=&quot;http://whatever/man/1/crontab&quot;&gt;http://whatever/man/1/crontab&lt;/a&gt;, what to put before the &quot;1/crontab&quot;. The default value is &quot;&lt;a href=&quot;http://man.he.net/man&quot;&gt;http://man.he.net/man&lt;/a&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;&lt;i&gt;crontab(5)&lt;/i&gt;&lt;/code&gt; を&lt;a href=&quot;http://whatever/man/1/crontab&quot;&gt;http：// whatever / man / 1 / crontab&lt;/a&gt;に変える際に、「1 / crontab」の前に何を置くか。デフォルト値は「&lt;a href=&quot;http://man.he.net/man&quot;&gt;http://man.he.net/man&lt;/a&gt;」です。</target>
        </trans-unit>
        <trans-unit id="43281809d91fd31f1807b9436030386775e6651b" translate="yes" xml:space="preserve">
          <source>In typical VMS style, only the first letter of the value of this logical name is actually checked in a case insensitive mode, and it is considered enabled if it is the value &quot;T&quot;,&quot;1&quot; or &quot;E&quot;.</source>
          <target state="translated">典型的なVMSのスタイルでは、この論理名の値の最初の文字だけが大文字小文字を区別しないモードで実際にチェックされ、値が &quot;T&quot;,&quot;1&quot;,&quot;E &quot;であれば有効とみなされます。</target>
        </trans-unit>
        <trans-unit id="573e7b50018345b4e76799c05af940dc27c74f2b" translate="yes" xml:space="preserve">
          <source>In ualarm() you tried to use number of microseconds or interval (also in microseconds) more than 1_000_000 and setitimer() is not available in your system to emulate that case.</source>
          <target state="translated">ualarm()で、1_000_000_000 を超えるマイクロ秒数や間隔 (マイクロ秒単位でも可)を使おうとした場合、そのようなケースをエミュレートするための setitimer()がシステムで利用できません。</target>
        </trans-unit>
        <trans-unit id="f02423b74e4b6df478931aa6ac2f4633241db988" translate="yes" xml:space="preserve">
          <source>In verbose mode, a warning is printed if shadows are found (i.e., more than one POD file with the same POD name is found, e.g.</source>
          <target state="translated">冗長モードでは、影が見つかった場合に警告が表示されます(つまり、同じPOD名のPODファイルが2つ以上見つかった場合など)。</target>
        </trans-unit>
        <trans-unit id="8a3ebab20ae57eb43347721d9e5a409b1ce17a43" translate="yes" xml:space="preserve">
          <source>In version 2.37 the first argument to the callback function was changed from string to object. This was done to make room for extensions and more detailed control. The object stringifies to the option name so this change should not introduce compatibility problems.</source>
          <target state="translated">バージョン 2.37 では、コールバック関数の最初の引数が文字列からオブジェクトに変更されました。これは、拡張機能やより詳細な制御のためのスペースを確保するために行われました。オブジェクトはオプション名に文字列化されるので、この変更が互換性の問題を引き起こすことはないはずです。</target>
        </trans-unit>
        <trans-unit id="880a8be23ba2ee8779ff63078e49dfc5216b39eb" translate="yes" xml:space="preserve">
          <source>In versions 5.000 and 5.001, instead of using the above line, you will need to use the following line:</source>
          <target state="translated">バージョン5.000と5.001では、上記の行を使用する代わりに、以下の行を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="1cc474b32c69cb459158c3dcaef8e4f4b651d874" translate="yes" xml:space="preserve">
          <source>In versions 5.6 and later, Perl won't recompile the regular expression if the variable hasn't changed, so you probably don't need the &lt;code&gt;/o&lt;/code&gt; option. It doesn't hurt, but it doesn't help either. If you want any version of Perl to compile the regular expression only once even if the variable changes (thus, only using its initial value), you still need the &lt;code&gt;/o&lt;/code&gt;.</source>
          <target state="translated">バージョン5.6以降では、変数が変更されていない場合、Perlは正規表現を再コンパイルしないため、 &lt;code&gt;/o&lt;/code&gt; オプションはおそらく必要ありません。害はありませんが、効果もありません。変数が変更されても（したがって、その初期値のみを使用して）、Perlのいずれかのバージョンで正規表現を1回だけコンパイルする場合でも、 &lt;code&gt;/o&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="cb448bdd461c35050663768e40f737fb69d01266" translate="yes" xml:space="preserve">
          <source>In versions of 5.002 prior to the gamma version, the test script in Example 1 will not function properly. You need to change the &quot;use lib&quot; line to read:</source>
          <target state="translated">5.002より前のバージョンのガンマ版では、例1のテストスクリプトが正しく機能しません。use lib」の行を読み替える必要があります。</target>
        </trans-unit>
        <trans-unit id="47fb4d46b782f60712d6e476480e232acaeda83d" translate="yes" xml:space="preserve">
          <source>In versions of 5.002 prior to version 5.002b1h, the test.pl file was not automatically created by h2xs. This means that you cannot say &quot;make test&quot; to run the test script. You will need to add the following line before the &quot;use extension&quot; statement:</source>
          <target state="translated">バージョン 5.002 より前のバージョン 5.002b1h では、test.pl ファイルは h2xs によって自動的に作成されませんでした。これは、テストスクリプトを実行するために &quot;make test&quot; と言うことができないことを意味します。use extension&quot; ステートメントの前に以下の行を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="ac1080be96df0c995d03afc96266140d8a96249c" translate="yes" xml:space="preserve">
          <source>In versions of Perl prior to 5.004, per-locale collation was possible using the &lt;code&gt;I18N::Collate&lt;/code&gt; library module. This module is now mildly obsolete and should be avoided in new applications. The &lt;code&gt;LC_COLLATE&lt;/code&gt; functionality is now integrated into the Perl core language: One can use locale-specific scalar data completely normally with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , so there is no longer any need to juggle with the scalar references of &lt;code&gt;I18N::Collate&lt;/code&gt; .</source>
          <target state="translated">5.004より前のバージョンのPerlでは、 &lt;code&gt;I18N::Collate&lt;/code&gt; ライブラリモジュールを使用してロケールごとの照合が可能でした。このモジュールは現在やや時代遅れであり、新しいアプリケーションでは使用しないでください。 &lt;code&gt;LC_COLLATE&lt;/code&gt; の機能は、現在のPerlのコア言語に統合されています。一つは、と完全に正常にロケール固有のスカラーデータを使用することはできません &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 程度のスカラ参照を持つジャグリングする必要はもはやあり、 &lt;code&gt;I18N::Collate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="643eb53656f3778cf6551882e9802bdd3c4faa37" translate="yes" xml:space="preserve">
          <source>In versions of Perl prior to 5.004, per-locale collation was possible using the &lt;code&gt;I18N::Collate&lt;/code&gt; library module. This module is now mildly obsolete and should be avoided in new applications. The &lt;code&gt;LC_COLLATE&lt;/code&gt; functionality is now integrated into the Perl core language: One can use locale-specific scalar data completely normally with &lt;code&gt;use locale&lt;/code&gt;, so there is no longer any need to juggle with the scalar references of &lt;code&gt;I18N::Collate&lt;/code&gt;.</source>
          <target state="translated">5.004より前のバージョンのPerlでは、 &lt;code&gt;I18N::Collate&lt;/code&gt; ライブラリモジュールを使用してロケールごとの照合が可能でした。このモジュールは現在やや時代遅れであり、新しいアプリケーションでは避ける必要があります。 &lt;code&gt;LC_COLLATE&lt;/code&gt; の機能は、現在のPerlのコア言語に統合されています。一つは、と完全に正常にロケール固有のスカラーデータを使用することはできません &lt;code&gt;use locale&lt;/code&gt; 程度のスカラ参照を持つジャグリングする必要はもはやあり、 &lt;code&gt;I18N::Collate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0768c48f4e49e936d5436a0c1bb338303666576" translate="yes" xml:space="preserve">
          <source>In void context no args are returned, so it's more efficient to skip calling &lt;code&gt;leave_adjust_stacks()&lt;/code&gt;. Also in void context, a &lt;code&gt;nextstate&lt;/code&gt; op is likely to be imminently called which will do a &lt;code&gt;FREETMPS&lt;/code&gt;, so there's no need to do that either.</source>
          <target state="translated">voidコンテキストでは、引数は返されないため、 &lt;code&gt;leave_adjust_stacks()&lt;/code&gt; の呼び出しをスキップする方が効率的です。また、無効なコンテキストでは、 &lt;code&gt;FREETMPS&lt;/code&gt; を実行する &lt;code&gt;nextstate&lt;/code&gt; opが差し迫って呼び出される可能性が高いため、これも実行する必要はありません。</target>
        </trans-unit>
        <trans-unit id="48a813c6d738225545b449a151bcdc156058f932" translate="yes" xml:space="preserve">
          <source>In your XS code, when you define an argument with a C type or when you are using a &lt;code&gt;CODE:&lt;/code&gt; and an &lt;code&gt;OUTPUT:&lt;/code&gt; section together with a C return type of your XSUB, it'll be the typemapping mechanism that makes this easy.</source>
          <target state="translated">XSコードで、Cタイプの引数を定義する場合、または &lt;code&gt;CODE:&lt;/code&gt; と &lt;code&gt;OUTPUT:&lt;/code&gt; セクションをXSUBのC戻り値タイプと一緒に使用する場合、これは、これを簡単にするタイプマッピングメカニズムになります。</target>
        </trans-unit>
        <trans-unit id="9357861451f0b2f036dafa4da40d9ece429bcae6" translate="yes" xml:space="preserve">
          <source>In-line functions that are in headers that are accessible to XS code need to be able to compile without warnings with commonly used extra compilation flags, such as gcc's &lt;code&gt;-Wswitch-default&lt;/code&gt; which warns whenever a switch statement does not have a &quot;default&quot; case. The use of these extra flags is to catch potential problems in legal C code, and is often used by Perl aggregators, such as Linux distributors.</source>
          <target state="translated">XSコードにアクセスできるヘッダーにあるインライン関数は、gccの &lt;code&gt;-Wswitch-default&lt;/code&gt; などの一般的に使用される追加のコンパイルフラグを使用して、switchステートメントに「デフォルト」のケースがない場合に警告する警告なしでコンパイルできる必要があります。 。これらの追加のフラグの使用は、合法的なCコードの潜在的な問題をキャッチするためであり、LinuxディストリビューターなどのPerlアグリゲーターによってよく使用されます。</target>
        </trans-unit>
        <trans-unit id="1fac261b8677bb294fa8e76c7f44d73a02d84ebb" translate="yes" xml:space="preserve">
          <source>In-memory IO, scalar IO</source>
          <target state="translated">インメモリIO、スカラIO</target>
        </trans-unit>
        <trans-unit id="103334731df65dd74f84e4f87f0649c004460a4d" translate="yes" xml:space="preserve">
          <source>In-place sort an array of SV pointers with the given comparison routine, with various SORTf_* flag options.</source>
          <target state="translated">SV ポインタの配列を、様々な SORTf_*フラグオプションを用いて、指定された比較ルーチンでインプレースソートします。</target>
        </trans-unit>
        <trans-unit id="5f2427ea8046d416f8b78bbc872c1a8336130b5f" translate="yes" xml:space="preserve">
          <source>In-place sort an array of SV pointers with the given comparison routine.</source>
          <target state="translated">指定された比較ルーチンを用いて SV ポインタの配列をインプレースソートします。</target>
        </trans-unit>
        <trans-unit id="022b1dbe77251c047456c4feb5d0409e122d6848" translate="yes" xml:space="preserve">
          <source>In-place upgrade of the supplied SV to a version object.</source>
          <target state="translated">提供された SV をバージョンオブジェクトにインプレースアップグレードします。</target>
        </trans-unit>
        <trans-unit id="1930e5219f1534978185f9ba376df01339047154" translate="yes" xml:space="preserve">
          <source>Inappropriate documentation</source>
          <target state="translated">不適切な文書</target>
        </trans-unit>
        <trans-unit id="72a5f6c42a6c39ea891ecb24d22128fd281d0e18" translate="yes" xml:space="preserve">
          <source>Inc</source>
          <target state="translated">Inc</target>
        </trans-unit>
        <trans-unit id="70b0bede26554e7ae42316f8d3fd932a7cdc066c" translate="yes" xml:space="preserve">
          <source>Incidentally, note that each class's &lt;code&gt;%Lexicon&lt;/code&gt; inherits-and-extends the lexicons in its superclasses. This is not because these are special hashes</source>
          <target state="translated">ちなみに、各クラスの &lt;code&gt;%Lexicon&lt;/code&gt; はスーパークラスのレキシコンを継承および拡張することに注意してください。これは特別なハッシュだからではありません</target>
        </trans-unit>
        <trans-unit id="56c1bcd0fe0c175606142de66e47a332c19454ad" translate="yes" xml:space="preserve">
          <source>Incidentally, note that there's no easy way to express a data paragraph starting with something that looks like a command. Consider:</source>
          <target state="translated">ちなみに、コマンドのようなものから始まるデータの段落を簡単に表現する方法はないので注意が必要です。考えてみてください。</target>
        </trans-unit>
        <trans-unit id="f4d888a4b6d2de9b573a52498056bdfd61c34932" translate="yes" xml:space="preserve">
          <source>Incidentally, note that we do not distinguish between these syntaxes:</source>
          <target state="translated">ちなみに、これらの構文を区別していないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="af23144864617d68a82ad427e6d70d917f0fe977" translate="yes" xml:space="preserve">
          <source>Incidentally, note the variance in the result values between the two examples; this is typical of benchmarking. If this were a real benchmark, you would probably want to run a lot more iterations.</source>
          <target state="translated">ちなみに、2つの例の間の結果値のばらつきに注意してください。これが実際のベンチマークであれば、おそらくもっと多くの繰り返しを実行したいと思うでしょう。</target>
        </trans-unit>
        <trans-unit id="11c54a59d8a9668fa20146e40c46116f6e7acc35" translate="yes" xml:space="preserve">
          <source>Include</source>
          <target state="translated">Include</target>
        </trans-unit>
        <trans-unit id="7f36757a0ff9e21d096da46852dca59689517203" translate="yes" xml:space="preserve">
          <source>Include /usr/ccs/bin/ in your PATH.</source>
          <target state="translated">/usr/ccs/bin/をPATHに含めてください。</target>
        </trans-unit>
        <trans-unit id="5f7213221d8f17a14d6c7b8882fe3f1c79362499" translate="yes" xml:space="preserve">
          <source>Include a &quot;POD ERRORS&quot; section in the outfile if there were any POD errors in the infile (default behaviour).</source>
          <target state="translated">インファイルにPODエラーがあった場合、アウトファイルに &quot;POD ERRORS &quot;セクションを含める(デフォルトの動作)。</target>
        </trans-unit>
        <trans-unit id="1f63d3adcc78e2a751c9de88b5a592a5d6f05fed" translate="yes" xml:space="preserve">
          <source>Include a &quot;POD ERRORS&quot; section in the outfile if there were any POD errors in the infile. This section is included by default.</source>
          <target state="translated">インファイルにPODエラーがあった場合は、アウトファイルに「POD ERRORS」セクションを含める。このセクションはデフォルトで含まれています。</target>
        </trans-unit>
        <trans-unit id="1be836334b7992bf64bdd66feaf2cdd670e862a6" translate="yes" xml:space="preserve">
          <source>Include a single css source in the header:</source>
          <target state="translated">ヘッダに単一の css ソースを含めます。</target>
        </trans-unit>
        <trans-unit id="82da13ca7b8da7d4d7bd6d25f32b5e4df5ab790d" translate="yes" xml:space="preserve">
          <source>Include a single javascript source:</source>
          <target state="translated">1つのjavascriptのソースを含めます。</target>
        </trans-unit>
        <trans-unit id="dacfcf246f0e94f511558260bbdd933b10ed8af6" translate="yes" xml:space="preserve">
          <source>Include any non-POD text from the input file in the output as well. Useful for viewing code documented with POD blocks with the POD rendered and the code left intact.</source>
          <target state="translated">入力ファイルのPOD以外のテキストも出力に含めます。PODがレンダリングされ、コードがそのままの状態でPODブロックで文書化されたコードを表示するのに便利です。</target>
        </trans-unit>
        <trans-unit id="b3aefa9c8a28918cfdeb274cb63c2499f4f13ccf" translate="yes" xml:space="preserve">
          <source>Include code for safely storing static data in the .xs file. Extensions that do no make use of static data can ignore this option.</source>
          <target state="translated">.xs ファイルに静的データを安全に格納するためのコードを含めます。静的データを使用しない拡張機能は、このオプションを無視することができます。</target>
        </trans-unit>
        <trans-unit id="73830e720872f365cfd2f2dbd3697deb29a3d139" translate="yes" xml:space="preserve">
          <source>Include file dirs eg: &lt;code&gt;&quot;-I/usr/5include -I/path/to/inc&quot;&lt;/code&gt;</source>
          <target state="translated">インクルードファイル &lt;code&gt;&quot;-I/usr/5include -I/path/to/inc&quot;&lt;/code&gt; ：例：「-I / usr / 5include -I / path / to / inc」</target>
        </trans-unit>
        <trans-unit id="6a46c6bf1682df8e2b9b455d4e2e63979aa173ed" translate="yes" xml:space="preserve">
          <source>Include list of valid licenses from &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; 0.17 rather than linking to the module, with minor updates to text and links to reflect versions at the time of publication.</source>
          <target state="translated">モジュールにリンクするのではなく、&lt;a href=&quot;Module::Build&quot;&gt;Module :: Build&lt;/a&gt; 0.17からの有効なライセンスのリストを含め、公開時のバージョンを反映するようにテキストとリンクをマイナーアップデートします。</target>
        </trans-unit>
        <trans-unit id="233868d9365dc18e1add2e1bf54ab892c2b257e4" translate="yes" xml:space="preserve">
          <source>Include list of valid licenses from &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; 0.18 rather than linking to the module, with minor updates to text and links to reflect versions at the time of publication.</source>
          <target state="translated">モジュールにリンクするのではなく、&lt;a href=&quot;Module::Build&quot;&gt;Module :: Build&lt;/a&gt; 0.18からの有効なライセンスのリストを含め、公開時のバージョンを反映するようにテキストとリンクをマイナーアップデートします。</target>
        </trans-unit>
        <trans-unit id="40111b47c700ae2f5642d997d209744f7e18b0e6" translate="yes" xml:space="preserve">
          <source>Include list of valid licenses from &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; 0.2611 rather than linking to the module, with minor updates to text and links to reflect versions at the time of publication.</source>
          <target state="translated">モジュールにリンクするのではなく、&lt;a href=&quot;Module::Build&quot;&gt;Module :: Build&lt;/a&gt; 0.2611からの有効なライセンスのリストを含め、公開時のバージョンを反映するようにテキストとリンクをマイナーアップデートします。</target>
        </trans-unit>
        <trans-unit id="758b345104d352569d53c61623a248e076a8b20f" translate="yes" xml:space="preserve">
          <source>Include list of valid licenses from &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; 0.2805 rather than linking to the module, with minor updates to text and links to reflect versions at the time of publication.</source>
          <target state="translated">モジュールにリンクするのではなく、&lt;a href=&quot;Module::Build&quot;&gt;Module :: Build&lt;/a&gt; 0.2805からの有効なライセンスのリストを含め、公開時のバージョンを反映するようにテキストとリンクをマイナーアップデートします。</target>
        </trans-unit>
        <trans-unit id="f157fc1eac4aa33c6e19320dad9c45ca1ddace2f" translate="yes" xml:space="preserve">
          <source>Include list of valid licenses from &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; 0.2807 rather than linking to the module, with minor updates to text and links to reflect versions at the time of publication.</source>
          <target state="translated">モジュールにリンクするのではなく、&lt;a href=&quot;Module::Build&quot;&gt;Module :: Build&lt;/a&gt; 0.2807からの有効なライセンスのリストを含め、公開時のバージョンを反映するようにテキストとリンクをマイナーアップデートします。</target>
        </trans-unit>
        <trans-unit id="ca280b8dc9676e12b899416fb9b80aa66ff24f11" translate="yes" xml:space="preserve">
          <source>Include recommended modules?</source>
          <target state="translated">推奨モジュールを含めるか?</target>
        </trans-unit>
        <trans-unit id="1acbf3f254752a10abcbbc0af380ce1701ab1294" translate="yes" xml:space="preserve">
          <source>Include suggested modules?</source>
          <target state="translated">提案されたモジュールを含めるか?</target>
        </trans-unit>
        <trans-unit id="bf7dea1bf3fcc056eca7b649b6605fbf3217e27a" translate="yes" xml:space="preserve">
          <source>Include tests with your module</source>
          <target state="translated">モジュールにテストを含める</target>
        </trans-unit>
        <trans-unit id="44cae264b95e40204b6c9817100d817393044faa" translate="yes" xml:space="preserve">
          <source>Include the `nstore' option to have the &lt;code&gt;Storable&lt;/code&gt; database written in `network order'. (See &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; for more details about this.)</source>
          <target state="translated">&lt;code&gt;Storable&lt;/code&gt; データベースを「ネットワーク順」で書き込むには、「nstore」オプションを含めます。（これについて詳しくは、&lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="428c39cb578db360bfc5803c8ec5f4e60b61ea16" translate="yes" xml:space="preserve">
          <source>Include the code from the &lt;b&gt;.h&lt;/b&gt; file as a comment in the &lt;b&gt;.ph&lt;/b&gt; file. This is primarily used for debugging</source>
          <target state="translated">&lt;b&gt;.h&lt;/b&gt;ファイルのコードをコメントとして&lt;b&gt;.ph&lt;/b&gt;ファイルに含めます。これは主にデバッグに使用されます</target>
        </trans-unit>
        <trans-unit id="5318c44a39f5f77944d683ed2f0ae1a7ab04539f" translate="yes" xml:space="preserve">
          <source>Include the following line in the XS section of your XS file: (don't break the line)</source>
          <target state="translated">XSファイルのXSセクションに以下の行を含めてください。(改行しないでください)</target>
        </trans-unit>
        <trans-unit id="eb7645ad7831d7d6fd6181e27396b77155390482" translate="yes" xml:space="preserve">
          <source>Include the main program in the output, even if subroutines were also specified. This rendering is normally suppressed when a subroutine name or reference is given.</source>
          <target state="translated">サブルーチンも指定されていた場合でも、メインプログラムを出力に含めます。このレンダリングは、サブルーチン名や参照が指定されている場合は、通常は抑制されます。</target>
        </trans-unit>
        <trans-unit id="39d690d519d42e4c1222e708f1a7882603060ecf" translate="yes" xml:space="preserve">
          <source>Include verbose configuration data in the report.</source>
          <target state="translated">冗長な構成データをレポートに含めます。</target>
        </trans-unit>
        <trans-unit id="520eeda3e72b576dbaab99011b2e61a86a377e9b" translate="yes" xml:space="preserve">
          <source>Included 'name', 'version', 'license', 'distribution_type', 'requires', 'recommends', 'build_requires', 'conflicts', 'dynamic_config', 'generated_by'</source>
          <target state="translated">'name'、'version'、'license'、'distribution_type'、'requires'、'recommends'、'build_requires'、'conflicts'、'dynamic_config'、'generated_by' を含みます。</target>
        </trans-unit>
        <trans-unit id="7af107d55e07795d28db937bc5e2e6b3d1acdce5" translate="yes" xml:space="preserve">
          <source>Included in the official Perl distribution, as in a standard module, a standard tool, or a standard Perl &lt;b&gt;manpage&lt;/b&gt;.</source>
          <target state="translated">標準モジュール、標準ツール、または標準Perl &lt;b&gt;マンページのよう&lt;/b&gt;に、公式のPerlディストリビューションに含まれています。</target>
        </trans-unit>
        <trans-unit id="0c36d5529b0434732ae50f5c4cfddc9ab638ebdc" translate="yes" xml:space="preserve">
          <source>Included recommended modules?</source>
          <target state="translated">推奨モジュールが含まれていますか?</target>
        </trans-unit>
        <trans-unit id="2d5cfde693773293f9c93c5da459379d1390e74a" translate="yes" xml:space="preserve">
          <source>Included suggested modules?</source>
          <target state="translated">提案されたモジュールが含まれていますか?</target>
        </trans-unit>
        <trans-unit id="fd1eb7c27a0ef162dc3c74b06bcd124d36810aee" translate="yes" xml:space="preserve">
          <source>Included with the standard Cygwin netrelease is the inetutils package which includes libutil.a.</source>
          <target state="translated">標準のCygwin netreleaseにはlibutil.aを含むinetutilsパッケージが含まれています。</target>
        </trans-unit>
        <trans-unit id="5d99a8e54557c65faa85e976aa75857ac0de5775" translate="yes" xml:space="preserve">
          <source>Includes &lt;code&gt;FSCTL_SET_REPARSE_POINT&lt;/code&gt;, &lt;code&gt;FSCTL_GET_REPARSE_POINT&lt;/code&gt;, &lt;code&gt;FSCTL_DELETE_REPARSE_POINT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FSCTL_SET_REPARSE_POINT&lt;/code&gt; 、 &lt;code&gt;FSCTL_GET_REPARSE_POINT&lt;/code&gt; 、 &lt;code&gt;FSCTL_DELETE_REPARSE_POINT&lt;/code&gt; が含まれます。</target>
        </trans-unit>
        <trans-unit id="5cb2c4473fcc6d850527caa45adfc81f1b873a15" translate="yes" xml:space="preserve">
          <source>Includes &lt;code&gt;IOCTL_DISK_FORMAT_TRACKS&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_FORMAT_TRACKS_EX&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_GET_DRIVE_GEOMETRY&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_GET_DRIVE_LAYOUT&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_GET_MEDIA_TYPES&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_GET_PARTITION_INFO&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_HISTOGRAM_DATA&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_HISTOGRAM_RESET&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_HISTOGRAM_STRUCTURE&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_IS_WRITABLE&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_LOGGING&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_PERFORMANCE&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_REASSIGN_BLOCKS&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_REQUEST_DATA&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_REQUEST_STRUCTURE&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_SET_DRIVE_LAYOUT&lt;/code&gt;, &lt;code&gt;IOCTL_DISK_SET_PARTITION_INFO&lt;/code&gt;, and &lt;code&gt;IOCTL_DISK_VERIFY&lt;/code&gt;.</source>
          <target state="translated">含ま &lt;code&gt;IOCTL_DISK_FORMAT_TRACKS&lt;/code&gt; 、 &lt;code&gt;IOCTL_DISK_FORMAT_TRACKS_EX&lt;/code&gt; 、 &lt;code&gt;IOCTL_DISK_GET_DRIVE_GEOMETRY&lt;/code&gt; 、 &lt;code&gt;IOCTL_DISK_GET_DRIVE_LAYOUT&lt;/code&gt; 、 &lt;code&gt;IOCTL_DISK_GET_MEDIA_TYPES&lt;/code&gt; 、 &lt;code&gt;IOCTL_DISK_GET_PARTITION_INFO&lt;/code&gt; 、 &lt;code&gt;IOCTL_DISK_HISTOGRAM_DATA&lt;/code&gt; 、 &lt;code&gt;IOCTL_DISK_HISTOGRAM_RESET&lt;/code&gt; 、 &lt;code&gt;IOCTL_DISK_HISTOGRAM_STRUCTURE&lt;/code&gt; 、 &lt;code&gt;IOCTL_DISK_IS_WRITABLE&lt;/code&gt; 、 &lt;code&gt;IOCTL_DISK_LOGGING&lt;/code&gt; 、 &lt;code&gt;IOCTL_DISK_PERFORMANCE&lt;/code&gt; 、 &lt;code&gt;IOCTL_DISK_REASSIGN_BLOCKS&lt;/code&gt; 、 &lt;code&gt;IOCTL_DISK_REQUEST_DATA&lt;/code&gt; 、 &lt;code&gt;IOCTL_DISK_REQUEST_STRUCTURE&lt;/code&gt; は、 &lt;code&gt;IOCTL_DISK_SET_DRIVE_LAYOUT&lt;/code&gt; 、 &lt;code&gt;IOCTL_DISK_SET_PARTITION_INFO&lt;/code&gt; 、および &lt;code&gt;IOCTL_DISK_VERIFY&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62deb9b6c9960c6cf27bcef72a0cb725d958b5ee" translate="yes" xml:space="preserve">
          <source>Includes the closing tag of &amp;lt;/title&amp;gt; and through the rest of the head till the opening of the body</source>
          <target state="translated">&amp;lt;/ title&amp;gt;の終了タグを含み、本体の開口部まで頭の残りの部分を通過します</target>
        </trans-unit>
        <trans-unit id="33e824f5c1da8228b52bc56b109b9797a650528d" translate="yes" xml:space="preserve">
          <source>Inclusion of library modules is better done with the &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; operators, which also do automatic error checking and raise an exception if there's a problem.</source>
          <target state="translated">ライブラリモジュールを含めるには、&lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt;演算子と&lt;a href=&quot;#require-VERSION&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt;演算子を使用する方が適切です。この演算子は、自動エラーチェックも実行し、問題が発生した場合は例外を発生させます。</target>
        </trans-unit>
        <trans-unit id="9abdbb8c9871ea5d015e2e60e10f71a6f7c5bffa" translate="yes" xml:space="preserve">
          <source>Inclusion of library modules is better done with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; operators, which also do automatic error checking and raise an exception if there's a problem.</source>
          <target state="translated">ライブラリモジュールを含めるには、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 演算子を使用する方が適切です。これにより、自動エラーチェックが行われ、問題がある場合は例外が発生します。</target>
        </trans-unit>
        <trans-unit id="fc7468d33bdeb93695da594528f2501435fe4708" translate="yes" xml:space="preserve">
          <source>Inclusion of library modules is better done with the &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; operators, which also do automatic error checking and raise an exception if there's a problem.</source>
          <target state="translated">ライブラリモジュールを含めるには、 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 演算子を使用する方が適切です。これにより、自動エラーチェックが行われ、問題がある場合は例外が発生します。</target>
        </trans-unit>
        <trans-unit id="d536a03f0c3143f6e1f810634a3c64f1cee1463a" translate="yes" xml:space="preserve">
          <source>Incompatibility with AIX Toolbox lib gdbm</source>
          <target state="translated">AIX Toolbox lib gdbm との非互換性</target>
        </trans-unit>
        <trans-unit id="e8ee16b208edc6448df6fc055ab0018eee84b8c5" translate="yes" xml:space="preserve">
          <source>Incomplete expression within '(?[ ])' in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正規表現の「（？[]）」内の不完全な式。&amp;lt;-ここにm /％s /でマーク</target>
        </trans-unit>
        <trans-unit id="b53d2a95e2a16580ce48c32385151c299f727d6f" translate="yes" xml:space="preserve">
          <source>Inconsistent hierarchy during C3 merge of class '%s': merging failed on parent '%s'</source>
          <target state="translated">クラス '%s' の C3 マージ時の階層構造の不整合:親 '%s' でのマージに失敗しました。</target>
        </trans-unit>
        <trans-unit id="e53b7251c10e4fb16639ff0eb74e48d3fdb255f3" translate="yes" xml:space="preserve">
          <source>Increment OBJ by one.</source>
          <target state="translated">OBJを1つ増やす。</target>
        </trans-unit>
        <trans-unit id="a3b00269821fb57d8ea2de1fc824b0f5f9a60902" translate="yes" xml:space="preserve">
          <source>Increment an SV's reference count. Use the &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; wrapper instead.</source>
          <target state="translated">SVの参照カウントをインクリメントします。代わりに &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; ラッパーを使用してください。</target>
        </trans-unit>
        <trans-unit id="0e74e496959812fcc073992ca705206317cb9544" translate="yes" xml:space="preserve">
          <source>Increment the reference count of a &lt;code&gt;refcounted_he&lt;/code&gt; . The pointer to the &lt;code&gt;refcounted_he&lt;/code&gt; is also returned. It is safe to pass a null pointer to this function: no action occurs and a null pointer is returned.</source>
          <target state="translated">&lt;code&gt;refcounted_he&lt;/code&gt; の参照カウントを増やします。 &lt;code&gt;refcounted_he&lt;/code&gt; へのポインターも返されます。この関数にnullポインターを渡しても安全です。アクションは発生せず、nullポインターが返されます。</target>
        </trans-unit>
        <trans-unit id="9858409e70adfac3f5375aa7bf5fb0c442d68e13" translate="yes" xml:space="preserve">
          <source>Increment the reference count of a &lt;code&gt;refcounted_he&lt;/code&gt;. The pointer to the &lt;code&gt;refcounted_he&lt;/code&gt; is also returned. It is safe to pass a null pointer to this function: no action occurs and a null pointer is returned.</source>
          <target state="translated">&lt;code&gt;refcounted_he&lt;/code&gt; の参照カウントをインクリメントします。 &lt;code&gt;refcounted_he&lt;/code&gt; へのポインタも返されます。この関数にnullポインタを渡しても安全です。アクションは発生せず、nullポインタが返されます。</target>
        </trans-unit>
        <trans-unit id="e3802b6aa343742e73ae6047c081fca9075a08d1" translate="yes" xml:space="preserve">
          <source>Increment the version number for every change, no matter how small</source>
          <target state="translated">どんなに小さくても、変更があるたびにバージョン番号をインクリメントする</target>
        </trans-unit>
        <trans-unit id="2478eca32c2a75c27f5473c45c519262b31bc3ab" translate="yes" xml:space="preserve">
          <source>Increments $x by 1 and returns the result.</source>
          <target state="translated">x を 1 増分して結果を返します。</target>
        </trans-unit>
        <trans-unit id="4c98c7bfa60bc9d7d9626649411d920868a3e57d" translate="yes" xml:space="preserve">
          <source>Increments &lt;code&gt;PL_sub_generation&lt;/code&gt; , which invalidates method caching in all packages.</source>
          <target state="translated">&lt;code&gt;PL_sub_generation&lt;/code&gt; を増分します。これにより、すべてのパッケージのメソッドキャッシュが無効になります。</target>
        </trans-unit>
        <trans-unit id="bef0acad6c664dfddc6d4ee1b5ec03b4981c74c9" translate="yes" xml:space="preserve">
          <source>Increments &lt;code&gt;PL_sub_generation&lt;/code&gt;, which invalidates method caching in all packages.</source>
          <target state="translated">&lt;code&gt;PL_sub_generation&lt;/code&gt; をインクリメントします。これにより、すべてのパッケージのメソッドキャッシングが無効になります。</target>
        </trans-unit>
        <trans-unit id="3272c368109726f88d497737f134b46e95de8369" translate="yes" xml:space="preserve">
          <source>Increments the reference count of the given SV, returning the SV.</source>
          <target state="translated">与えられた SV の参照カウントを増加させ、SV を返します。</target>
        </trans-unit>
        <trans-unit id="b3fb59bb686d8260401f92a3aa6f2bbde8cfdc66" translate="yes" xml:space="preserve">
          <source>Indeed, a negative real number can be noted &lt;code&gt;[x,pi]&lt;/code&gt; (the modulus</source>
          <target state="translated">実際、負の実数は &lt;code&gt;[x,pi]&lt;/code&gt; （係数</target>
        </trans-unit>
        <trans-unit id="a04774d4b73d320e20f71b059e1b914a71747c31" translate="yes" xml:space="preserve">
          <source>Indeed, to terminate the cycle, the $cnt should become false. However, the operator &lt;code&gt;bool&lt;/code&gt; for checking falsity is overloaded (this time via overloaded &lt;code&gt;&quot;&quot;&lt;/code&gt; ), and returns a long string, thus any object of type &lt;code&gt;symbolic&lt;/code&gt; is true. To overcome this, we need a way to compare an object to 0. In fact, it is easier to write a numeric conversion routine.</source>
          <target state="translated">実際、サイクルを終了するには、$ cntがfalseになる必要があります。ただし、偽をチェックするための演算子 &lt;code&gt;bool&lt;/code&gt; はオーバーロードされ（今回はオーバーロードされた &lt;code&gt;&quot;&quot;&lt;/code&gt; を介して）、長い文字列を返すため、 &lt;code&gt;symbolic&lt;/code&gt; タイプのオブジェクトはすべてtrueです。これを克服するには、オブジェクトを0と比較する方法が必要です。実際、数値変換ルーチンを書く方が簡単です。</target>
        </trans-unit>
        <trans-unit id="35950a01017cb2dc9bdf8ca69f4b06c266fec7af" translate="yes" xml:space="preserve">
          <source>Indeed, to terminate the cycle, the $cnt should become false. However, the operator &lt;code&gt;bool&lt;/code&gt; for checking falsity is overloaded (this time via overloaded &lt;code&gt;&quot;&quot;&lt;/code&gt;), and returns a long string, thus any object of type &lt;code&gt;symbolic&lt;/code&gt; is true. To overcome this, we need a way to compare an object to 0. In fact, it is easier to write a numeric conversion routine.</source>
          <target state="translated">実際、サイクルを終了するには、$ cntがfalseになる必要があります。ただし、偽りをチェックするための演算子 &lt;code&gt;bool&lt;/code&gt; はオーバーロードされ（今回はオーバーロードされた &lt;code&gt;&quot;&quot;&lt;/code&gt; を介して）、長い文字列を返すため、 &lt;code&gt;symbolic&lt;/code&gt; 型のオブジェクトはすべてtrueになります。これを克服するには、オブジェクトを0と比較する方法が必要です。実際、数値変換ルーチンを作成する方が簡単です。</target>
        </trans-unit>
        <trans-unit id="62ba8e1b3397c92c36fc4b8d835f19b0c882946b" translate="yes" xml:space="preserve">
          <source>Indent lines by multiples of</source>
          <target state="translated">の倍数で行をインデントします。</target>
        </trans-unit>
        <trans-unit id="af112fcfab59a5128ecdee5791e9c1c13e552da5" translate="yes" xml:space="preserve">
          <source>Indentation on line %d of here-doc doesn't match delimiter</source>
          <target state="translated">her-doc の %d 行のインデントが区切り文字と一致しません。</target>
        </trans-unit>
        <trans-unit id="5bc3818470788f955b725157028fb28b522ca6be" translate="yes" xml:space="preserve">
          <source>Indented Here-docs</source>
          <target state="translated">インデントのついたヘル・ドク</target>
        </trans-unit>
        <trans-unit id="62114f3245956b96ef644ac166335fb4a4e9a90b" translate="yes" xml:space="preserve">
          <source>Independent of which seed is used in the hash function, &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; return items in a per-hash randomized order. Modifying a hash by insertion will change the iteration order of that hash. This behavior can be overridden by using &lt;code&gt;hash_traversal_mask()&lt;/code&gt; from &lt;a href=&quot;hash/util&quot;&gt;Hash::Util&lt;/a&gt; or by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;PERL_PERTURB_KEYS in perlrun&lt;/a&gt;. Note that this feature controls the &quot;visible&quot; order of the keys, and not the actual order they are stored in.</source>
          <target state="translated">ハッシュ関数で使用されるシードに関係なく、 &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; ハッシュごとのランダム化された順序でアイテムを返します。挿入によってハッシュを変更すると、そのハッシュの反復順序が変更されます。この動作は、&lt;a href=&quot;hash/util&quot;&gt;Hash :: Utilの&lt;/a&gt; &lt;code&gt;hash_traversal_mask()&lt;/code&gt; を使用するか、PERL_PERTURB_KEYS環境変数を使用してオーバーライドできます&lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;。perlrunのPERL_PERTURB_KEYSを&lt;/a&gt;参照してください。この機能は、キーの「表示」順序を制御するものであり、実際に格納される順序は制御しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="e0d3b18e6e5a02cb47428995e30bd3cf0aea8164" translate="yes" xml:space="preserve">
          <source>Independent of which seed is used in the hash function, &lt;code&gt;keys&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;, and &lt;code&gt;each&lt;/code&gt; return items in a per-hash randomized order. Modifying a hash by insertion will change the iteration order of that hash. This behavior can be overridden by using &lt;code&gt;hash_traversal_mask()&lt;/code&gt; from &lt;a href=&quot;Hash::Util&quot;&gt;Hash::Util&lt;/a&gt; or by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;&quot;PERL_PERTURB_KEYS&quot; in perlrun&lt;/a&gt;. Note that this feature controls the &quot;visible&quot; order of the keys, and not the actual order they are stored in.</source>
          <target state="translated">ハッシュ関数で使用されるシードに関係なく、 &lt;code&gt;keys&lt;/code&gt; 、 &lt;code&gt;values&lt;/code&gt; 、および &lt;code&gt;each&lt;/code&gt; ハッシュごとにランダム化された順序でアイテムを返します。挿入によってハッシュを変更すると、そのハッシュの反復順序が変更されます。この動作は、&lt;a href=&quot;Hash::Util&quot;&gt;Hash :: Utilの&lt;/a&gt; &lt;code&gt;hash_traversal_mask()&lt;/code&gt; を使用するか、PERL_PERTURB_KEYS環境変数を使用することでオーバーライドできます。perlrunの&lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;「PERL_PERTURB_KEYS」を&lt;/a&gt;参照してください。この機能は、キーが格納されている実際の順序ではなく、キーの「表示」順序を制御することに注意してください。</target>
        </trans-unit>
        <trans-unit id="074fa110a121b41d1fc8547d15dc9f9c647ba94b" translate="yes" xml:space="preserve">
          <source>Independent subexpressions</source>
          <target state="translated">独立した副表現</target>
        </trans-unit>
        <trans-unit id="af34ac32829575a31a5420b259a403615ce25ff8" translate="yes" xml:space="preserve">
          <source>Index.txt</source>
          <target state="translated">Index.txt</target>
        </trans-unit>
        <trans-unit id="f095033a2da35066ce69235bfd888bf108da82db" translate="yes" xml:space="preserve">
          <source>Index/Value Array Slices</source>
          <target state="translated">インデックス/値配列スライス</target>
        </trans-unit>
        <trans-unit id="ea194faeed183e57e74609dce9cd3c08f293d1f1" translate="yes" xml:space="preserve">
          <source>Indexing distributions a la PAUSE</source>
          <target state="translated">PAUSEのようなインデックス配布</target>
        </trans-unit>
        <trans-unit id="967ce367d89dccc133d71049f1197d29561b3726" translate="yes" xml:space="preserve">
          <source>India</source>
          <target state="translated">India</target>
        </trans-unit>
        <trans-unit id="9376bb53130ade1b5bef94ae526efe4afa9ba571" translate="yes" xml:space="preserve">
          <source>India Pale Ale. Also the International Phonetic Alphabet, the standard alphabet used for phonetic notation worldwide. Draws heavily on Unicode, including many combining characters.</source>
          <target state="translated">インディア・ペールエール。また、国際音声アルファベット(International Phonetic Alphabet)、世界の音声表記に使用される標準的なアルファベット。多くの結合文字を含むUnicodeを多用している。</target>
        </trans-unit>
        <trans-unit id="5d00be2150a7a2970ecf83338644746fe69f68bc" translate="yes" xml:space="preserve">
          <source>Indiana</source>
          <target state="translated">Indiana</target>
        </trans-unit>
        <trans-unit id="7939b23cc59e5fecb713c284b9570bf5c06bc4a8" translate="yes" xml:space="preserve">
          <source>Indicate if List::Util was compiled with a C compiler</source>
          <target state="translated">List::Util が C コンパイラでコンパイルされているかどうかを示す</target>
        </trans-unit>
        <trans-unit id="257f1f56edc7d22d13ca3e932a232d7b1ce1cb6a" translate="yes" xml:space="preserve">
          <source>Indicates how many bits are produced by the function used to generate normalized random numbers.</source>
          <target state="translated">正規化乱数の生成に使用される関数で生成されるビット数を示す。</target>
        </trans-unit>
        <trans-unit id="f59dd948b843172b40aa09dfd5bd724d214b6e0d" translate="yes" xml:space="preserve">
          <source>Indicates if SSL support is available. When called as a class object, it checks for the correct version of &lt;a href=&quot;Net::SSLeay&quot;&gt;Net::SSLeay&lt;/a&gt; and &lt;a href=&quot;IO::Socket::SSL&quot;&gt;IO::Socket::SSL&lt;/a&gt;. When called as an object methods, if &lt;code&gt;SSL_verify&lt;/code&gt; is true or if &lt;code&gt;SSL_verify_mode&lt;/code&gt; is set in &lt;code&gt;SSL_options&lt;/code&gt;, it checks that a CA file is available.</source>
          <target state="translated">SSLサポートが利用可能かどうかを示します。クラスオブジェクトとして呼び出されると、&lt;a href=&quot;Net::SSLeay&quot;&gt;Net :: SSLeay&lt;/a&gt;と&lt;a href=&quot;IO::Socket::SSL&quot;&gt;IO :: Socket :: SSL&lt;/a&gt;の正しいバージョンをチェックします。場合と、オブジェクトのメソッドとして呼び出さ &lt;code&gt;SSL_verify&lt;/code&gt; が真である場合、または &lt;code&gt;SSL_verify_mode&lt;/code&gt; がに設定されている &lt;code&gt;SSL_options&lt;/code&gt; CAファイルが利用可能であること、それをチェックします。</target>
        </trans-unit>
        <trans-unit id="ecc34d4e90099631370d69b93d5e19f62c32c10d" translate="yes" xml:space="preserve">
          <source>Indicates if a connection to a peer is being kept alive, per the &lt;code&gt;keep_alive&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;keep_alive&lt;/code&gt; オプションに従って、ピアへの接続が維持されているかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="9e61b5d3c6d9951043a7c42ee4ac908615e6dda5" translate="yes" xml:space="preserve">
          <source>Indicates if the test suite is currently passing.</source>
          <target state="translated">テストスイートが現在合格しているかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="ef01c58c919f2b098417df7378a5f02c4c2d45a0" translate="yes" xml:space="preserve">
          <source>Indicates that &lt;code&gt;$sTargetPath&lt;/code&gt; will be a raw Windows NT object name. This usually means that &lt;code&gt;$sTargetPath&lt;/code&gt; starts with &lt;code&gt;&quot;\\Device\\&quot;&lt;/code&gt;. Note that you cannot use &lt;code&gt;&quot;/&quot;&lt;/code&gt; in place of &lt;code&gt;&quot;\\&quot;&lt;/code&gt; in raw target path names.</source>
          <target state="translated">&lt;code&gt;$sTargetPath&lt;/code&gt; が未加工のWindowsNTオブジェクト名になることを示します。これは通常、 &lt;code&gt;$sTargetPath&lt;/code&gt; が &lt;code&gt;&quot;\\Device\\&quot;&lt;/code&gt; 始まることを意味します。生のターゲットパス名で &lt;code&gt;&quot;\\&quot;&lt;/code&gt; 代わりに「 &lt;code&gt;&quot;/&quot;&lt;/code&gt; を使用することはできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="4520cd78eb8d8cd3353abddf71f5cfdf3e0ea242" translate="yes" xml:space="preserve">
          <source>Indicates that Ctrl/U, Ctrl/R, and DELETE are not to be considered control commands on terminal input, but are to be passed to the application program.</source>
          <target state="translated">Ctrl/U、Ctrl/R、DELETEは、ターミナル入力上では制御コマンドとみなされず、アプリケーションプログラムに渡されることを示します。</target>
        </trans-unit>
        <trans-unit id="89c8d4afc13dccaac0824429842e2b3486822df1" translate="yes" xml:space="preserve">
          <source>Indicates that a user-supplied typemap should take precedence over the default typemaps. A single typemap may be specified as a string, or multiple typemaps can be specified in an array reference, with the last typemap having the highest precedence.</source>
          <target state="translated">ユーザが指定したタイプマップをデフォルトのタイプマップよりも優先することを示します。単一のタイプマップを文字列で指定することもできますし、複数のタイプマップを配列参照で指定することもできます。</target>
        </trans-unit>
        <trans-unit id="a07031906aeffe3119baa721e29202522fd91917" translate="yes" xml:space="preserve">
          <source>Indicates that a user-supplied typemap should take precedence over the default typemaps. This option may be used multiple times, with the last typemap having the highest precedence.</source>
          <target state="translated">デフォルトのタイプマップよりもユーザが指定したタイプマップを優先することを示します。このオプションは複数回使用することができ、最後のタイプマップが最も優先されます。</target>
        </trans-unit>
        <trans-unit id="2a6c6be6a26747d93fbb6c3ceadc3f2de48a2c99" translate="yes" xml:space="preserve">
          <source>Indicates that arguments returned from a callback should be discarded. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">コールバックから返された引数を破棄する必要があることを示します。&lt;a href=&quot;perlcall&quot;&gt;perlcallを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0527e8a268302f8a5a261750f72fb958d828bf1d" translate="yes" xml:space="preserve">
          <source>Indicates that no arguments are being sent to a callback. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">コールバックに引数が送信されていないことを示します。&lt;a href=&quot;perlcall&quot;&gt;perlcallを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a1a4d2b29fe4bc866080992a5b7a34bdbecb2aeb" translate="yes" xml:space="preserve">
          <source>Indicates that the caller is not interested in the hostname of the result, so it does not have to be converted. &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned as the hostname.</source>
          <target state="translated">呼び出し元が結果のホスト名に関心がないため、変換する必要がないことを示します。ホスト名として &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="91d2892aa8952e09a191501575b51fbbf525086f" translate="yes" xml:space="preserve">
          <source>Indicates that the caller is not interested in the hostname of the result, so it does not have to be converted. &lt;code&gt;undef&lt;/code&gt; will be returned as the hostname.</source>
          <target state="translated">呼び出し元が結果のホスト名に関心がないため、変換する必要がないことを示します。 &lt;code&gt;undef&lt;/code&gt; がホスト名として返されます。</target>
        </trans-unit>
        <trans-unit id="b7ec72841bfda828e77f110fabfe3b01a8c116ba" translate="yes" xml:space="preserve">
          <source>Indicates that the caller is not interested in the service name of the result, so it does not have to be converted. &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned as the service name.</source>
          <target state="translated">呼び出し元が結果のサービス名に関心がないため、変換する必要がないことを示します。 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; はサービス名として返されます。</target>
        </trans-unit>
        <trans-unit id="52065ec2a07be88eb3f6bb4c9b96986da981df93" translate="yes" xml:space="preserve">
          <source>Indicates that the caller is not interested in the service name of the result, so it does not have to be converted. &lt;code&gt;undef&lt;/code&gt; will be returned as the service name.</source>
          <target state="translated">呼び出し元が結果のサービス名に関心がないため、変換する必要がないことを示します。 &lt;code&gt;undef&lt;/code&gt; はサービス名として返されます。</target>
        </trans-unit>
        <trans-unit id="f532e8b4a0494e58b3d4e84b40bc705bd9387b6c" translate="yes" xml:space="preserve">
          <source>Indicates that the caller will pass a numeric address, rather than a hostname, and that getaddrinfo() must not perform a resolve operation on this name. This flag will prevent a possibly-slow network lookup operation, and instead return an error if a hostname is passed.</source>
          <target state="translated">呼び出し元がホスト名ではなく数値のアドレスを渡すことを示し、 getaddrinfo()がこの名前に対して解決処理を実行してはならないことを示します。このフラグは、ネットワーク検索の処理が遅くなることを防ぎ、 ホスト名が渡された場合にはエラーを返します。</target>
        </trans-unit>
        <trans-unit id="3c8087750e8c32a23d6ccd2949d0b7dadc5ebeea" translate="yes" xml:space="preserve">
          <source>Indicates that the caller wishes the canonical hostname (&lt;code&gt;canonname&lt;/code&gt; ) field of the result to be filled in.</source>
          <target state="translated">呼び出し元が、結果の正規ホスト名（ &lt;code&gt;canonname&lt;/code&gt; ）フィールドに入力することを望んでいることを示します。</target>
        </trans-unit>
        <trans-unit id="765c5439c71bb5dd46ae2b457c3aebf852e2ce63" translate="yes" xml:space="preserve">
          <source>Indicates that the caller wishes the canonical hostname (&lt;code&gt;canonname&lt;/code&gt;) field of the result to be filled in.</source>
          <target state="translated">呼び出し元が結果の正規のホスト名（ &lt;code&gt;canonname&lt;/code&gt; ）フィールドに入力することを希望していることを示します。</target>
        </trans-unit>
        <trans-unit id="0a02454d6f3918d6c495eef14a92688abca3837e" translate="yes" xml:space="preserve">
          <source>Indicates that the referenced subroutine is a method. A subroutine so marked will not trigger the &quot;Ambiguous call resolved as CORE::%s&quot; warning.</source>
          <target state="translated">参照されるサブルーチンがメソッドであることを示します。このようにマークされたサブルーチンでは、&quot;Ambiguous call resolved as CORE::%s&quot; 警告は発生しません。</target>
        </trans-unit>
        <trans-unit id="1c805274f5974d7ec81414a21a79ac4005ac17f0" translate="yes" xml:space="preserve">
          <source>Indicates that the referenced subroutine is a valid lvalue and can be assigned to. The subroutine must return a modifiable value such as a scalar variable, as described in &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">参照されたサブルーチンが有効な左辺値であり、代入できることを示します。サブルーチンは、&lt;a href=&quot;perlsub&quot;&gt;perlsubで&lt;/a&gt;説明されているように、スカラー変数などの変更可能な値を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="945cc6067d92cdd88f1d4d49015ca5f672222998" translate="yes" xml:space="preserve">
          <source>Indicates that the referenced variable can be shared across different threads when used in conjunction with the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; modules.</source>
          <target state="translated">参照される変数は、&lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt;および&lt;a href=&quot;threads/shared&quot;&gt;threads :: shared&lt;/a&gt;モジュールと組み合わせて使用​​すると、異なるスレッド間で共有できることを示します。</target>
        </trans-unit>
        <trans-unit id="11cf21dbf5fe03fde0078615e81d4953585daf83" translate="yes" xml:space="preserve">
          <source>Indicates that the referenced variable can be shared across different threads when used in conjunction with the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt; modules.</source>
          <target state="translated">参照される変数を&lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt;および&lt;a href=&quot;threads::shared&quot;&gt;threads :: shared&lt;/a&gt;モジュールと組み合わせて使用​​すると、異なるスレッド間で共有できることを示します。</target>
        </trans-unit>
        <trans-unit id="f5dc796b3c6e09f2adbe1df261ece3a878874b6e" translate="yes" xml:space="preserve">
          <source>Indicates that the socket address relates to a &lt;code&gt;SOCK_DGRAM&lt;/code&gt; socket, for the services whose name differs between TCP and UDP protocols.</source>
          <target state="translated">ソケットアドレスが、TCPプロトコルとUDPプロトコルで名前が異なるサービスの &lt;code&gt;SOCK_DGRAM&lt;/code&gt; ソケットに関連していることを示します。</target>
        </trans-unit>
        <trans-unit id="d2c743e25365a9bdf3ff9b009f1ca948b97e6afb" translate="yes" xml:space="preserve">
          <source>Indicates that this resolution is for a local bind() for a passive (i.e. listening) socket, rather than an active (i.e. connecting) socket.</source>
          <target state="translated">この解決方法は、アクティブ(接続)ソケットではなく、パッシブ(リスニング)ソケットに対するローカルバインド()であることを示します。</target>
        </trans-unit>
        <trans-unit id="1f10eaccf1b997cf7e5e0f8a8f4fab0ca55e7525" translate="yes" xml:space="preserve">
          <source>Indicates the macro to be used to generate normalized random numbers. Uses randfunc, often divided by (double) (((unsigned long) 1 &amp;lt;&amp;lt; randbits)) in order to normalize the result. In C programs, the macro &lt;code&gt;Drand01&lt;/code&gt; is mapped to drand01.</source>
          <target state="translated">正規化された乱数の生成に使用されるマクロを示します。結果を正規化するために、randfuncを使用し、多くの場合（double）（（（unsigned long）1 &amp;lt;&amp;lt; randbits））で除算します。Cプログラムでは、マクロ &lt;code&gt;Drand01&lt;/code&gt; はdrand01にマップされます。</target>
        </trans-unit>
        <trans-unit id="46fbaffe89877f1dd0586f026a063f6bfd1ece0d" translate="yes" xml:space="preserve">
          <source>Indicates the name of the random number function to use. Values include drand48, random, and rand. In C programs, the &lt;code&gt;Drand01&lt;/code&gt; macro is defined to generate uniformly distributed random numbers over the range [0., 1.[ (see drand01 and nrand).</source>
          <target state="translated">使用する乱数関数の名前を示します。値には、drand48、random、およびrandが含まれます。Cプログラムでは、 &lt;code&gt;Drand01&lt;/code&gt; マクロは[0.、1. [の範囲で一様に分布した乱数を生成するように定義されています（drand01とnrandを参照）。</target>
        </trans-unit>
        <trans-unit id="0e9d38aea41337c4a340bd6ff37e0fceaaf530c7" translate="yes" xml:space="preserve">
          <source>Indicates the random number generating seed function. Values include srand48, srandom, and srand.</source>
          <target state="translated">乱数生成シード関数を示す。値には srand48,srandom,srand が含まれます。</target>
        </trans-unit>
        <trans-unit id="cd655229f991b7aec42a78f98c296efa6aab20f6" translate="yes" xml:space="preserve">
          <source>Indicates the tool that was used to create this</source>
          <target state="translated">この作成に使用されたツールを示します。</target>
        </trans-unit>
        <trans-unit id="90e351cd851905a73031d78312feecb33ffe731a" translate="yes" xml:space="preserve">
          <source>Indicates the type of the argument of the seedfunc.</source>
          <target state="translated">seedfunc の引数の型を示す。</target>
        </trans-unit>
        <trans-unit id="157e831f2a32e9a34450598504f4e81bdfe93334" translate="yes" xml:space="preserve">
          <source>Indicates to the &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; that things are going so badly all testing should terminate. This includes running any additional test scripts.</source>
          <target state="translated">&lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt;に対して、すべてのテストが非常にうまくいかないことを示します。これには、追加のテストスクリプトの実行が含まれます。</target>
        </trans-unit>
        <trans-unit id="2261f14a4235af1795b8d1185c5372fb55826237" translate="yes" xml:space="preserve">
          <source>Indicates to the &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; that things are going so badly all testing should terminate. This includes running any additional test scripts.</source>
          <target state="translated">&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt;に対して、事態が非常に悪化しているため、すべてのテストを終了する必要があることを示します。これには、追加のテストスクリプトの実行が含まれます。</target>
        </trans-unit>
        <trans-unit id="fe441aac507416c2ecf5fefc2720f5a5e7cc6991" translate="yes" xml:space="preserve">
          <source>Indicates to the harness that things are going so badly all testing should terminate. This includes the running of any additional test scripts.</source>
          <target state="translated">状況が悪化しているため、すべてのテストを終了すべきであることをハーネスに示します。これには、追加のテストスクリプトの実行も含まれます。</target>
        </trans-unit>
        <trans-unit id="bdde223b122eaee17c31cfd6ef76f52ec58ce6f0" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the current item is a YAML block.</source>
          <target state="translated">現在のアイテムがYAMLブロックであるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="2ac3f8f7cb3f69c816245189833fb5047e4be353" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the current line could be parsed.</source>
          <target state="translated">現在の行を解析できるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="765249e9b3e3ba66799eb3c3e692065e2ef4bdde" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the given result has a SKIP directive.</source>
          <target state="translated">与えられた結果にSKIP指令があるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="1e5feadbfd972a9ef3f2203c437baf1b81be3303" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the given result has a TODO directive.</source>
          <target state="translated">与えられた結果にTODO指令があるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="5ae3ac2f7146f745d483818a88c053580ae4ad1e" translate="yes" xml:space="preserve">
          <source>Indicates whether or not the given result has a TODO or SKIP directive.</source>
          <target state="translated">与えられた結果にTODO指令やSKIP指令があるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="33c1162df0e994c2dba92771958227447c3c8740" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a TAP version line.</source>
          <target state="translated">これがTAPバージョンの行であるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="82a274793f5ee26247829ddf91f4a9bd5a24bbd9" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a YAML chunk.</source>
          <target state="translated">これがYAMLチャンクであるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="551b037463cdc6d8ee7a155c709c206438a14ea9" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a comment.</source>
          <target state="translated">これがコメントであるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="fa47f2a4b95862bdf9eb043bb9b755ecb73bbd6f" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a comment. Comments will generally only appear in the TAP stream if STDERR is merged to STDOUT. See the &lt;code&gt;merge&lt;/code&gt; option.</source>
          <target state="translated">これがコメントかどうかを示します。コメントは通常、STDERRがSTDOUTにマージされた場合にのみTAPストリームに表示されます。 &lt;code&gt;merge&lt;/code&gt; オプションを参照してください。</target>
        </trans-unit>
        <trans-unit id="5add899043fa2f2909dd47a1020e2ad33a37e66d" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a pragma line.</source>
          <target state="translated">これがプラグマ行であるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="7023aeaf089510f19833c997992b3c941c8dc92d" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is a test line.</source>
          <target state="translated">これがテストラインであるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="9f9b15b44f69cccc124e6789e9d93a4a06a7d51c" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is bailout line.</source>
          <target state="translated">これがベイルアウトラインであるかどうかを示す。</target>
        </trans-unit>
        <trans-unit id="7a3a5d84e52530eeac47fceba7db01f6e0dcbe22" translate="yes" xml:space="preserve">
          <source>Indicates whether or not this is the test plan line.</source>
          <target state="translated">これがテスト計画線であるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="53a07ae6433afd9e304cca7c30208aa346f95b4e" translate="yes" xml:space="preserve">
          <source>Indicates whether the octets in the lexer buffer (&lt;a href=&quot;#PL_parser-%3Elinestr&quot;&gt;&quot;PL_parser-&amp;gt;linestr&quot;&lt;/a&gt;) should be interpreted as the UTF-8 encoding of Unicode characters. If not, they should be interpreted as Latin-1 characters. This is analogous to the &lt;code&gt;SvUTF8&lt;/code&gt; flag for scalars.</source>
          <target state="translated">レクサーバッファー（&lt;a href=&quot;#PL_parser-%3Elinestr&quot;&gt;&quot;PL_parser-&amp;gt; linestr&quot;&lt;/a&gt;）のオクテットをUnicode文字のUTF-8エンコーディングとして解釈する必要があるかどうかを示します。そうでない場合は、Latin-1文字として解釈する必要があります。これは、スカラーの &lt;code&gt;SvUTF8&lt;/code&gt; フラグに類似しています。</target>
        </trans-unit>
        <trans-unit id="9010b0739ea277aa1257ee6d74e58336f2039de7" translate="yes" xml:space="preserve">
          <source>Indicates whether the octets in the lexer buffer (&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt;) should be interpreted as the UTF-8 encoding of Unicode characters. If not, they should be interpreted as Latin-1 characters. This is analogous to the &lt;code&gt;SvUTF8&lt;/code&gt; flag for scalars.</source>
          <target state="translated">レクサーバッファー内のオクテット（&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt; linestr&lt;/a&gt;）をUnicode文字のUTF-8エンコーディングとして解釈する必要があるかどうかを示します。そうでない場合は、Latin-1文字として解釈する必要があります。これは、スカラーの &lt;code&gt;SvUTF8&lt;/code&gt; フラグに似ています。</target>
        </trans-unit>
        <trans-unit id="6add24acec866ad90335d7337161ba97a738a82e" translate="yes" xml:space="preserve">
          <source>Indicating the Film::Rating() method is broken.</source>
          <target state="translated">Film::Rating()メソッドが壊れていることを示します。</target>
        </trans-unit>
        <trans-unit id="065a6d5ea3be3a587038269a904d146bb9a0a3c1" translate="yes" xml:space="preserve">
          <source>Indirect Object Syntax</source>
          <target state="translated">間接オブジェクト構文</target>
        </trans-unit>
        <trans-unit id="3fba9ca2a9139d262136aa9779aba86f7f14b1e8" translate="yes" xml:space="preserve">
          <source>Individual Results</source>
          <target state="translated">個別成績</target>
        </trans-unit>
        <trans-unit id="9cee924720451366321a5d77a5bce661294a6372" translate="yes" xml:space="preserve">
          <source>Individual committers should create topic branches under &lt;b&gt;yourname&lt;/b&gt;/&lt;b&gt;some_descriptive_name&lt;/b&gt;:</source>
          <target state="translated">個々のコミッターは、&lt;b&gt;yourname&lt;/b&gt; / &lt;b&gt;some_descriptive_nameの&lt;/b&gt;下にトピックブランチを作成する必要があります：</target>
        </trans-unit>
        <trans-unit id="cb52fbb620cf2997c4aa4b5107c331f4b77d2de2" translate="yes" xml:space="preserve">
          <source>Individual test results.</source>
          <target state="translated">個別の検査結果。</target>
        </trans-unit>
        <trans-unit id="a6118403aceb71cf86308ba3cff213cbc8856dc0" translate="yes" xml:space="preserve">
          <source>Individual test suite results.</source>
          <target state="translated">個々のテストスイートの結果。</target>
        </trans-unit>
        <trans-unit id="35536a41b209715d9e3ad440431fef2672f20bbe" translate="yes" xml:space="preserve">
          <source>Indonesia</source>
          <target state="translated">Indonesia</target>
        </trans-unit>
        <trans-unit id="a1d71ca242908209d7ea479076e7d5102e909486" translate="yes" xml:space="preserve">
          <source>Inf</source>
          <target state="translated">Inf</target>
        </trans-unit>
        <trans-unit id="fcefc0b17d205c1c65f4c51d0fe902c4a064f2d7" translate="yes" xml:space="preserve">
          <source>Infinite recursion in regex</source>
          <target state="translated">正規表現の無限再帰</target>
        </trans-unit>
        <trans-unit id="4367ace45c63bdb1f549a2a2f7dd6cdd72c8dfb1" translate="yes" xml:space="preserve">
          <source>Infinite recursion via empty pattern</source>
          <target state="translated">空のパターンを介した無限の再帰</target>
        </trans-unit>
        <trans-unit id="68dcf262960464f7812ef1f6844ea3187d8ab76d" translate="yes" xml:space="preserve">
          <source>Infinity and Not a Number</source>
          <target state="translated">無限大と数ではない</target>
        </trans-unit>
        <trans-unit id="ec4c72e2c7996edd7fe98bac862051d171e8f331" translate="yes" xml:space="preserve">
          <source>Inflate Interface</source>
          <target state="translated">インフレートインターフェース</target>
        </trans-unit>
        <trans-unit id="ae8803342c993280c888b28837c9da6527d39370" translate="yes" xml:space="preserve">
          <source>Inflates the complete contents of &lt;code&gt;$buffer&lt;/code&gt; . The buffer can either be a scalar or a scalar reference.</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; 内容全体を膨らませます。バッファーは、スカラーまたはスカラー参照のいずれかです。</target>
        </trans-unit>
        <trans-unit id="7d9b46b317dca1e834a024c29757ee0f8a5e027e" translate="yes" xml:space="preserve">
          <source>Inflates the complete contents of &lt;code&gt;$buffer&lt;/code&gt;. The buffer can either be a scalar or a scalar reference.</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; 内容全体を膨らませます。バッファーは、スカラーまたはスカラー参照のいずれかです。</target>
        </trans-unit>
        <trans-unit id="beedaffabd6b03c265ffb648f984a13e030e2063" translate="yes" xml:space="preserve">
          <source>Inflates the complete contents of &lt;code&gt;$input&lt;/code&gt; and writes the uncompressed data to &lt;code&gt;$output&lt;/code&gt; . The &lt;code&gt;$input&lt;/code&gt; and &lt;code&gt;$output&lt;/code&gt; parameters can either be scalars or scalar references.</source>
          <target state="translated">&lt;code&gt;$input&lt;/code&gt; 完全なコンテンツを展開し、圧縮されていないデータを &lt;code&gt;$output&lt;/code&gt; 書き込みます。 &lt;code&gt;$input&lt;/code&gt; と &lt;code&gt;$output&lt;/code&gt; パラメータは、いずれかのスカラーまたはスカラー参照することができます。</target>
        </trans-unit>
        <trans-unit id="6a474d8e337dea1030c8c9f1ba0d71abcee898bb" translate="yes" xml:space="preserve">
          <source>Inflates the complete contents of &lt;code&gt;$input&lt;/code&gt; and writes the uncompressed data to &lt;code&gt;$output&lt;/code&gt;. The &lt;code&gt;$input&lt;/code&gt; and &lt;code&gt;$output&lt;/code&gt; parameters can either be scalars or scalar references.</source>
          <target state="translated">&lt;code&gt;$input&lt;/code&gt; 内容全体を膨らませ、非圧縮データを &lt;code&gt;$output&lt;/code&gt; 書き込みます。 &lt;code&gt;$input&lt;/code&gt; と &lt;code&gt;$output&lt;/code&gt; パラメータは、いずれかのスカラーまたはスカラー参照することができます。</target>
        </trans-unit>
        <trans-unit id="424924a8af9c413db917d51e67110d95dea81788" translate="yes" xml:space="preserve">
          <source>Information about true color support in various terminal emulators and test programs you can run to check the true color support in your terminal emulator are available at &lt;a href=&quot;https://gist.github.com/XVilka/8346728&quot;&gt;https://gist.github.com/XVilka/8346728&lt;/a&gt;.</source>
          <target state="translated">ターミナルエミュレータでのトゥルーカラーサポートを確認するために実行できるさまざまなターミナルエミュレータおよびテストプログラムでのトゥルーカラーサポートに関する情報は、&lt;a href=&quot;https://gist.github.com/XVilka/8346728&quot;&gt;https：//gist.github.com/XVilka/8346728で&lt;/a&gt;入手できます。</target>
        </trans-unit>
        <trans-unit id="75ddcc47830d9749b1f6958774d6b7383d928afa" translate="yes" xml:space="preserve">
          <source>Information on installing the Perl documentation in HTML format can be found in the</source>
          <target state="translated">HTML形式のPerlドキュメントをインストールする際の情報は</target>
        </trans-unit>
        <trans-unit id="63a11938f1b7522fad4baac591e5655e30cc1a15" translate="yes" xml:space="preserve">
          <source>Information on the git commit from which the current perl binary was compiled can be found in the variable &lt;code&gt;$Config::Git_Data&lt;/code&gt; . The variable is a structured string that looks something like this:</source>
          <target state="translated">現在のperlバイナリがコンパイルされたgitコミットに関する情報は、変数 &lt;code&gt;$Config::Git_Data&lt;/code&gt; ます。変数は、次のような構造化文字列です。</target>
        </trans-unit>
        <trans-unit id="a0e7d716e288cb7e639286453bea0a95db3d58e1" translate="yes" xml:space="preserve">
          <source>Information on the git commit from which the current perl binary was compiled can be found in the variable &lt;code&gt;$Config::Git_Data&lt;/code&gt;. The variable is a structured string that looks something like this:</source>
          <target state="translated">現在のperlバイナリがコンパイルされた &lt;code&gt;$Config::Git_Data&lt;/code&gt; に関する情報は、変数$ Config :: Git_Dataにあります。変数は、次のような構造化文字列です。</target>
        </trans-unit>
        <trans-unit id="4fa18069a4aed5716a8df64d9e082aca15aa5195" translate="yes" xml:space="preserve">
          <source>Informative call that array is likely to grow to have</source>
          <target state="translated">配列が持つように成長する可能性が高いことを知らせる呼び出し</target>
        </trans-unit>
        <trans-unit id="4002d66fcc252c8f943869f47b18239871e5a38c" translate="yes" xml:space="preserve">
          <source>Informative names</source>
          <target state="translated">情報量の多い名前</target>
        </trans-unit>
        <trans-unit id="6c1c216b5b3374ee549f4e7ce25195c9cfb38752" translate="yes" xml:space="preserve">
          <source>Ingy's suggestions</source>
          <target state="translated">インギーの提案</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="fdd8dbf1164cff77c53c1fcf6f05a5248f3597e3" translate="yes" xml:space="preserve">
          <source>Inheritance allows two classes to share code. By default, every method in the parent class is also available in the child. The child can explicitly &lt;b&gt;override&lt;/b&gt; a parent's method to provide its own implementation. For example, if we have an &lt;code&gt;File::MP3&lt;/code&gt; object, it has the &lt;code&gt;print_info()&lt;/code&gt; method from &lt;code&gt;File&lt;/code&gt; :</source>
          <target state="translated">継承により、2つのクラスでコードを共有できます。デフォルトでは、親クラスのすべてのメソッドが子でも使用できます。子は、親のメソッドを明示的に&lt;b&gt;オーバーライドし&lt;/b&gt;て、独自の実装を提供でき&lt;b&gt;ます&lt;/b&gt;。たとえば、 &lt;code&gt;File::MP3&lt;/code&gt; オブジェクトがある場合は、Fileの &lt;code&gt;print_info()&lt;/code&gt; メソッドがあり &lt;code&gt;File&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbc39f4531ecbce98b377fac6454c84ec2034707" translate="yes" xml:space="preserve">
          <source>Inheritance allows two classes to share code. By default, every method in the parent class is also available in the child. The child can explicitly &lt;b&gt;override&lt;/b&gt; a parent's method to provide its own implementation. For example, if we have an &lt;code&gt;File::MP3&lt;/code&gt; object, it has the &lt;code&gt;print_info()&lt;/code&gt; method from &lt;code&gt;File&lt;/code&gt;:</source>
          <target state="translated">継承により、2つのクラスがコードを共有できます。デフォルトでは、親クラスのすべてのメソッドは子でも使用できます。子は、親のメソッドを明示的に&lt;b&gt;オーバーライドし&lt;/b&gt;て、独自の実装を提供でき&lt;b&gt;ます&lt;/b&gt;。たとえば、 &lt;code&gt;File::MP3&lt;/code&gt; オブジェクトがある場合、File：の &lt;code&gt;print_info()&lt;/code&gt; メソッドがあり &lt;code&gt;File&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbc41c48400edb2d66f46abd2eeeb9f193aa61fe" translate="yes" xml:space="preserve">
          <source>Inheritance and Overloading</source>
          <target state="translated">継承とオーバーロード</target>
        </trans-unit>
        <trans-unit id="73b13d6576dee61ad6c9a67be3c5fd56748eb8f1" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt; which allows you to change the trace.</source>
          <target state="translated">トレースを変更できる&lt;a href=&quot;Test2::Event&quot;&gt;Test2 :: Event&lt;/a&gt;から継承されます。</target>
        </trans-unit>
        <trans-unit id="6ae06620429d483baf3958f6460d3cab1b8f1403" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt;, overridden to also vivify/mutate the 'about' facet.</source>
          <target state="translated">&lt;a href=&quot;Test2::Event&quot;&gt;Test2 :: Event&lt;/a&gt;から継承され、「about」ファセットを活性化/変更するためにオーバーライドされます。</target>
        </trans-unit>
        <trans-unit id="fa5c47bbe5bffb87fdc63768d24cbdd7ac233292" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt;. This can be used to add 'amnesty' facets to an existing event. Each new item is added to the &lt;b&gt;END&lt;/b&gt; of the list.</source>
          <target state="translated">&lt;a href=&quot;Test2::Event&quot;&gt;Test2 :: Event&lt;/a&gt;から継承されます。これは、既存のイベントに「恩赦」ファセットを追加するために使用できます。新しいアイテムはそれぞれ、リストの&lt;b&gt;最後&lt;/b&gt;に追加されます。</target>
        </trans-unit>
        <trans-unit id="19c5f1d372c49633a5f800879863d9084768bf54" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt;. This is used by hubs to stamp events as they pass through. New items are added to the &lt;b&gt;START&lt;/b&gt; of the list.</source>
          <target state="translated">&lt;a href=&quot;Test2::Event&quot;&gt;Test2 :: Event&lt;/a&gt;から継承されます。これは、ハブが通過するイベントにスタンプを付けるために使用されます。リストの&lt;b&gt;先頭&lt;/b&gt;に新しい項目が追加されます。</target>
        </trans-unit>
        <trans-unit id="b4102e1cbc70e34f207d4b05daf2f7d154eb2cce" translate="yes" xml:space="preserve">
          <source>Inheriting from *Tie::ExtraHash*</source>
          <target state="translated">Tie::ExtraHash*からの継承</target>
        </trans-unit>
        <trans-unit id="07845e4fa81351b41e3aca0473590f0745f203e3" translate="yes" xml:space="preserve">
          <source>Inheriting from *Tie::Memoize*</source>
          <target state="translated">Tie::Memoize*からの継承</target>
        </trans-unit>
        <trans-unit id="c5a788b89ced595ecbe83baf444c015d5af4ed62" translate="yes" xml:space="preserve">
          <source>Inheriting from *Tie::StdHash*</source>
          <target state="translated">Tie::StdHash*からの継承</target>
        </trans-unit>
        <trans-unit id="2af015f1a7a88588d2bedaaf274af7c154500941" translate="yes" xml:space="preserve">
          <source>Inheriting from &lt;b&gt;Tie::ExtraHash&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Tie :: ExtraHash&lt;/b&gt;から継承&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0ee435be5e637cbc759b674414f3dfaaeaa6a310" translate="yes" xml:space="preserve">
          <source>Inheriting from &lt;b&gt;Tie::Memoize&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Tie :: Memoize&lt;/b&gt;から継承&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0942164c538c56917cf82fee8d95de867370af98" translate="yes" xml:space="preserve">
          <source>Inheriting from &lt;b&gt;Tie::StdHash&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Tie :: StdHash&lt;/b&gt;から継承&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="48240d94f1e40cb4a0ce31e0d0412d7b8f4b76ab" translate="yes" xml:space="preserve">
          <source>Inheriting from Tie::ExtraHash</source>
          <target state="translated">Tie::ExtraHash からの継承</target>
        </trans-unit>
        <trans-unit id="6eb8e208cadd5346ff9c4a40511d1dbe6081d340" translate="yes" xml:space="preserve">
          <source>Inheriting from Tie::Memoize</source>
          <target state="translated">Tie::Memoizeからの継承</target>
        </trans-unit>
        <trans-unit id="fa6d1eeae612ef4f96a499b488d3c738fd7b2bd5" translate="yes" xml:space="preserve">
          <source>Inheriting from Tie::StdHash</source>
          <target state="translated">Tie::StdHash からの継承</target>
        </trans-unit>
        <trans-unit id="f87f7c07fa0f8ea9a950efcf13bc372319f2a9a4" translate="yes" xml:space="preserve">
          <source>Inherits from &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt;. Also defines:</source>
          <target state="translated">&lt;a href=&quot;Test2::Event&quot;&gt;Test2 :: Event&lt;/a&gt;から継承します。また、以下を定義します。</target>
        </trans-unit>
        <trans-unit id="12b78aab8730ee025153421cab4a6381c4215485" translate="yes" xml:space="preserve">
          <source>Inherits some evil code from &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; からいくつかの邪悪なコードを継承します。</target>
        </trans-unit>
        <trans-unit id="697bba69426638bf8ad3245a38ff2084b17b3805" translate="yes" xml:space="preserve">
          <source>Init methods</source>
          <target state="translated">Initメソッド</target>
        </trans-unit>
        <trans-unit id="469d92ba331e1f193a058b9d59b36d9c2695f1be" translate="yes" xml:space="preserve">
          <source>Init.U</source>
          <target state="translated">Init.U</target>
        </trans-unit>
        <trans-unit id="188fedc6f79203e40eb5a91d186ec6c30916e7f9" translate="yes" xml:space="preserve">
          <source>Initial discussion of the ability to modify IO streams behaviour used the term &quot;discipline&quot; for the entities which were added. This came (I believe) from the use of the term in &quot;sfio&quot;, which in turn borrowed it from &quot;line disciplines&quot; on Unix terminals. However, this document (and the C code) uses the term &quot;layer&quot;.</source>
          <target state="translated">IOストリームの振る舞いを変更する機能の最初の議論では、追加されたエンティティのために &quot;discipline &quot;という用語が使われていました。これは(私は)&quot;sfio &quot;での用語の使用に由来するもので、Unix端末の &quot;line disciplines &quot;から借りてきたものです。しかしながら、このドキュメント(とCコード)では &quot;layer &quot;という用語を使っています。</target>
        </trans-unit>
        <trans-unit id="af26189aae099c8b0074103f2d4d6fbc19c70e2f" translate="yes" xml:space="preserve">
          <source>Initial port of perl to WinCE. It was performed in separate directory named</source>
          <target state="translated">WinCEへのPerlのイニシャルポート。という名前の別のディレクトリで実行されました。</target>
        </trans-unit>
        <trans-unit id="fcb1ddc45496d5bd9bbb1d0e3e24a58c56f33281" translate="yes" xml:space="preserve">
          <source>Initial value</source>
          <target state="translated">初期値</target>
        </trans-unit>
        <trans-unit id="64a1cc8196dec5ffb0b6abf423df9a7b0c6e0219" translate="yes" xml:space="preserve">
          <source>Initial version (GSAR 20-FEB-97)</source>
          <target state="translated">初期バージョン(GSAR 20-FEB-97</target>
        </trans-unit>
        <trans-unit id="681e3458dd2b1a02b6b17850e74b7b6f830be8ea" translate="yes" xml:space="preserve">
          <source>Initialisation in &lt;code&gt;pregcomp()&lt;/code&gt; mostly involves the creation and data-filling of a special structure, &lt;code&gt;RExC_state_t&lt;/code&gt; (defined in</source>
          <target state="translated">&lt;code&gt;pregcomp()&lt;/code&gt; の初期化には、特別な構造体 &lt;code&gt;RExC_state_t&lt;/code&gt; （</target>
        </trans-unit>
        <trans-unit id="c7a9076545ffc08af19383275c9bb0a670aaa64a" translate="yes" xml:space="preserve">
          <source>Initialises a deflation object.</source>
          <target state="translated">デフレーションオブジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="b36a0f0079e64fa2a033c629779d3f623a057d8c" translate="yes" xml:space="preserve">
          <source>Initialises a deflation stream.</source>
          <target state="translated">デフレの流れを初期化します。</target>
        </trans-unit>
        <trans-unit id="6050c58e3e77b97a8c7a9c2f34e629bf70ca3f1a" translate="yes" xml:space="preserve">
          <source>Initialises an inflation object.</source>
          <target state="translated">インフレーションオブジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="d6dc7f91e03e45468b8ef5863382d6fe3515a834" translate="yes" xml:space="preserve">
          <source>Initialises an inflation stream.</source>
          <target state="translated">インフレストリームを初期化します。</target>
        </trans-unit>
        <trans-unit id="925a3411c38d467154e067193b51fb11192479d2" translate="yes" xml:space="preserve">
          <source>Initialization of certain non-subroutine variables in ExtUtils::ParseXS and some of its supporting packages has been moved into this package so that those values can be defined exactly once and then re-used in any package.</source>
          <target state="translated">ExtUtils::ParseXS とそのサポートパッケージのいくつかのサブルーチン変数の初期化は、このパッケージに移され、これらの値を一度だけ定義して、どのパッケージでも再利用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="7f93bcd9e79c47792da25c51c98403872611fece" translate="yes" xml:space="preserve">
          <source>Initialization of state variables in list currently forbidden</source>
          <target state="translated">現在禁止されているリストの状態変数の初期化</target>
        </trans-unit>
        <trans-unit id="a08fb78f0ee25d9e540249a9eb4c3ec2aebf86f6" translate="yes" xml:space="preserve">
          <source>Initialization values for some globals</source>
          <target state="translated">一部のグローバルの初期化値</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
