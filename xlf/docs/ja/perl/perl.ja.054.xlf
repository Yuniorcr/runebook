<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="944edb7108bfdb534265951ea7b5a33f9f4b73e0" translate="yes" xml:space="preserve">
          <source>Share =&amp;gt; $uShare</source>
          <target state="translated">シェア=&amp;gt; $ uShare</target>
        </trans-unit>
        <trans-unit id="b8bf62db0a202cfe8b527778be027079163e0d35" translate="yes" xml:space="preserve">
          <source>Share what you did with the other people. Relax. Enjoy fruits of your work.</source>
          <target state="translated">自分がしたことを他の人と共有しましょう。リラックスして 仕事の成果を楽しむ。</target>
        </trans-unit>
        <trans-unit id="df3c637adb69abac13b29419d0cfa8b766ae4adc" translate="yes" xml:space="preserve">
          <source>Shared And Unshared Data</source>
          <target state="translated">共有データと非共有データ</target>
        </trans-unit>
        <trans-unit id="2ad8427c8c9758999d3e74a7bdd5fb7162a57750" translate="yes" xml:space="preserve">
          <source>Shared libraries created on a platform using a particular PA-RISC version are not usable on platforms using an earlier PA-RISC version by default. However, this backwards compatibility may be enabled using the same +DAportable compiler flag (with the same PA-RISC 1.0 caveat mentioned above).</source>
          <target state="translated">特定のPA-RISCバージョンを使用しているプラットフォームで作成された共有ライブラリは、デフォルトでは以前のPA-RISCバージョンを使用しているプラットフォームでは使用できません。しかし、この後方互換性は、同じ+DAportableコンパイラフラグを使用して有効にすることができます(上述のPA-RISC 1.0と同じ注意点があります)。</target>
        </trans-unit>
        <trans-unit id="193a001ab941319380e15850d6f5c791732088df" translate="yes" xml:space="preserve">
          <source>Shared libraries created on an Itanium platform cannot be loaded on a PA-RISC platform. Shared libraries created on a PA-RISC platform can only be loaded on an Itanium platform if it is a PA-RISC executable that is attempting to load the PA-RISC library. A PA-RISC shared library cannot be loaded into an Itanium executable nor vice-versa.</source>
          <target state="translated">Itaniumプラットフォーム上で作成された共有ライブラリは、PA-RISCプラットフォーム上ではロードできません。PA-RISCプラットフォーム上で作成された共有ライブラリは、そのPA-RISCライブラリをロードしようとしているのがPA-RISC実行ファイルである場合にのみ、Itaniumプラットフォーム上にロードすることができます。PA-RISC共有ライブラリをItanium実行ファイルにロードすることはできません。</target>
        </trans-unit>
        <trans-unit id="6953ee78fc5edeec2d6a50098821da893b0458f7" translate="yes" xml:space="preserve">
          <source>Shared references among objects will not stay shared: if we're serializing the list of object [A, C] where both object A and C refer to the SAME object B, and if there is a serializing hook in A that says freeze(B), then when deserializing, we'll get [A', C'] where A' refers to B', but C' refers to D, a deep clone of B'. The topology was not preserved.</source>
          <target state="translated">オブジェクト間で共有された参照は共有されたままではありません:オブジェクトAとCの両方がSAMEのオブジェクトBを参照しているオブジェクト[A,C]のリストをシリアライズしていて、Aにfreeze(B)というシリアライズフックがある場合、デシリアライズすると、A'はB'を参照していますが、C'はB'の深いクローンであるDを参照している[A',C']が得られてしまいます。トポロジーは保存されていませんでした。</target>
        </trans-unit>
        <trans-unit id="f728eba8dfb3236f1667f74466840c95e5a7b8ee" translate="yes" xml:space="preserve">
          <source>Shared variables can only store scalars, refs of shared variables, or refs of shared data (discussed in next section):</source>
          <target state="translated">共有変数は、スカラー、共有変数のref、または共有データのrefのみを格納することができます(次のセクションで説明します)。</target>
        </trans-unit>
        <trans-unit id="001c163e34c30bd422c6c0b180836b52f1afdb17" translate="yes" xml:space="preserve">
          <source>Sharing Databases With C Applications</source>
          <target state="translated">Cアプリケーションでのデータベースの共有</target>
        </trans-unit>
        <trans-unit id="bd8715c47f235864c2ceb04d785a7b7ec14fa56b" translate="yes" xml:space="preserve">
          <source>Sharing typemaps Between CPAN Distributions</source>
          <target state="translated">CPAN ディストリビューション間でのタイプマップの共有</target>
        </trans-unit>
        <trans-unit id="0a07afc00eaa14a561ef50fb9dc88822e22b041a" translate="yes" xml:space="preserve">
          <source>Sharp shell programmers should take note of the following:</source>
          <target state="translated">シャープシェルのプログラマーは以下の点に注意が必要です。</target>
        </trans-unit>
        <trans-unit id="f78065b15d0af880ad317e4f961cef2d5893c97c" translate="yes" xml:space="preserve">
          <source>Shawn H Corey &lt;code&gt;SHCOREY at cpan.org&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SHCOREY at cpan.org&lt;/code&gt; Corey SHCOREY</target>
        </trans-unit>
        <trans-unit id="6aa79f294b4ff3f2bd0e6980c0d9d3429325e3b2" translate="yes" xml:space="preserve">
          <source>Shawn M Moore &lt;code&gt;sartak@gmail.com&lt;/code&gt;</source>
          <target state="translated">Shawn M Moore &lt;code&gt;sartak@gmail.com&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a14cc09b3426b2766b9650c676895c8481a40916" translate="yes" xml:space="preserve">
          <source>Shebang Race Condition</source>
          <target state="translated">シェバンのレースコンディション</target>
        </trans-unit>
        <trans-unit id="bdc1fd5d3c0f3dcfd55d010426e61bf9451e680d" translate="yes" xml:space="preserve">
          <source>Shell</source>
          <target state="translated">Shell</target>
        </trans-unit>
        <trans-unit id="46f2fc676064cd202c006928e29b43973667f22c" translate="yes" xml:space="preserve">
          <source>Shell Traps</source>
          <target state="translated">シェルトラップ</target>
        </trans-unit>
        <trans-unit id="05e1aa29dff23edb2a5976ffe3e3f5926084ec96" translate="yes" xml:space="preserve">
          <source>Shell escapes newlines in $text.</source>
          <target state="translated">シェルは$textで改行をエスケープします。</target>
        </trans-unit>
        <trans-unit id="411430d5faea18a48223083d430d03ec02723be9" translate="yes" xml:space="preserve">
          <source>Shell mode</source>
          <target state="translated">シェルモード</target>
        </trans-unit>
        <trans-unit id="ae8110256e73e2d29bfd2b0361c6084818dcf5fb" translate="yes" xml:space="preserve">
          <source>Shell variables from the</source>
          <target state="translated">からのシェル変数</target>
        </trans-unit>
        <trans-unit id="a5efec93b7817b727267bf3e97356065022021aa" translate="yes" xml:space="preserve">
          <source>Shell::Command which is these same functions but take arguments normally.</source>
          <target state="translated">Shell::Commandはこれらの関数と同じですが、通常は引数を取ります。</target>
        </trans-unit>
        <trans-unit id="5597033de9e3a9ee3ab28b086225929f8384f842" translate="yes" xml:space="preserve">
          <source>Shells (especially &lt;b&gt;csh&lt;/b&gt;) do several levels of substitution on each command line. Perl does substitution in only certain constructs such as double quotes, backticks, angle brackets, and search patterns.</source>
          <target state="translated">シェル（特に&lt;b&gt;csh&lt;/b&gt;）は、各コマンドラインでいくつかのレベルの置換を行います。Perlは、二重引用符、バッククォート、山かっこ、検索パターンなどの特定の構成体でのみ置換を行います。</target>
        </trans-unit>
        <trans-unit id="c3085316e59739c3d0881dec21da7ebe8e1387d1" translate="yes" xml:space="preserve">
          <source>Shells interpret scripts a little bit at a time. Perl compiles the entire program before executing it (except for &lt;code&gt;BEGIN&lt;/code&gt; blocks, which execute at compile time).</source>
          <target state="translated">シェルはスクリプトを少しずつ解釈します。Perlは、プログラム全体を実行前にコンパイルします（コンパイル時に実行される &lt;code&gt;BEGIN&lt;/code&gt; ブロックを除く）。</target>
        </trans-unit>
        <trans-unit id="d740f71b4c0205327f8285c81beee6b58843073b" translate="yes" xml:space="preserve">
          <source>Shift Operators</source>
          <target state="translated">シフトオペレーター</target>
        </trans-unit>
        <trans-unit id="53ffaf0e7e7ca17703b35ea2272d3800a2b8789e" translate="yes" xml:space="preserve">
          <source>Shift object N digits right in base B and return the resulting object. This is equivalent to performing integer division by B**N and discarding the remainder, except that it might be much faster, depending on how the number is represented internally.</source>
          <target state="translated">オブジェクトを B 基底で N 桁右にシフトし、結果のオブジェクトを返します。これは、整数を B**N で除算して残りを破棄するのと同等ですが、内部的にどのように数値が表現されているかによっては、より高速になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="816ba91c6c549fed8497fc4ed9fd5be93db7467c" translate="yes" xml:space="preserve">
          <source>Shift the object N digits left in base B. This is equivalent to multiplying by B**N, except that it might be much faster, depending on how the number is represented internally.</source>
          <target state="translated">これは、内部的にどのように数値が表現されるかによって、より高速になる可能性があることを除けば、B**N を乗算するのと同等です。</target>
        </trans-unit>
        <trans-unit id="34ca9f2e9bedec059779353756117cfa0cd23d9b" translate="yes" xml:space="preserve">
          <source>Shift_JIS</source>
          <target state="translated">Shift_JIS</target>
        </trans-unit>
        <trans-unit id="c96929f71a3c235121f63b63fb9116d40dbf5a0d" translate="yes" xml:space="preserve">
          <source>Shifting by more bits than the size of the integers means most of the time zero (all bits fall off), except that under &lt;code&gt;use integer&lt;/code&gt; right overshifting a negative shiftee results in -1. This is unlike in C, where shifting by too many bits is undefined. A common C behavior is &quot;shift by modulo wordbits&quot;, so that for example</source>
          <target state="translated">整数のサイズよりも多くのビットをシフトすると、ほとんどの場合ゼロになります（すべてのビットがフォールオフします）。ただし、 &lt;code&gt;use integer&lt;/code&gt; 右にオーバーシフトすると、負のシフティーが-1になります。これは、あまりにも多くのビットによるシフトが定義されていないCとは異なります。一般的なCの動作は、「モジュロワードビットによるシフト」です。</target>
        </trans-unit>
        <trans-unit id="c82c36060459ec37e9c46c5b4c7db69b11b3eb70" translate="yes" xml:space="preserve">
          <source>Shifting by negative number of bits means the reverse shift: left shift becomes right shift, right shift becomes left shift. This is unlike in C, where negative shift is undefined.</source>
          <target state="translated">負のビット数でシフトするということは、左シフトが右シフトになり、右シフトが左シフトになるという逆シフトを意味します。これは、負のシフトが定義されていないC言語とは異なります。</target>
        </trans-unit>
        <trans-unit id="2bbd5485928f42790ecd61230b448ed394726e75" translate="yes" xml:space="preserve">
          <source>Shifts $x right by $y in base $n. Default is base 2, used are usually 10 and 2, but others work, too.</source>
          <target state="translated">xを$nを基準にして$yを右にシフトします。デフォルトは基底 2 で、通常は 10 と 2 を使用しますが、他のものも使用できます。</target>
        </trans-unit>
        <trans-unit id="84e5b666ca83223606a44c0968ce869e11125987" translate="yes" xml:space="preserve">
          <source>Shifts the first value of the array off and returns it, shortening the array by 1 and moving everything down. If there are no elements in the array, returns the undefined value. If ARRAY is omitted, shifts the &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt; array within the lexical scope of subroutines and formats, and the &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt; array outside a subroutine and also within the lexical scopes established by the &lt;code&gt;eval STRING&lt;/code&gt;, &lt;code&gt;BEGIN {}&lt;/code&gt;, &lt;code&gt;INIT {}&lt;/code&gt;, &lt;code&gt;CHECK {}&lt;/code&gt;, &lt;code&gt;UNITCHECK {}&lt;/code&gt;, and &lt;code&gt;END {}&lt;/code&gt; constructs.</source>
          <target state="translated">配列の最初の値をオフにシフトして返し、配列を1短くして、すべてを下に移動します。配列に要素がない場合は、未定義の値を返します。ARRAYが省略された場合、シフト&lt;a href=&quot;perlvar#%40_&quot;&gt; &lt;code&gt;@_&lt;/code&gt; &lt;/a&gt;サブルーチンやフォーマットの字句範囲内の配列、及び&lt;a href=&quot;perlvar#%40ARGV&quot;&gt; &lt;code&gt;@ARGV&lt;/code&gt; の&lt;/a&gt;字句スコープによって確立サブルーチン外部また以内アレイ &lt;code&gt;eval STRING&lt;/code&gt; 、 &lt;code&gt;BEGIN {}&lt;/code&gt; 、 &lt;code&gt;INIT {}&lt;/code&gt; 、 &lt;code&gt;CHECK {}&lt;/code&gt; 、 &lt;code&gt;UNITCHECK {}&lt;/code&gt; 、および &lt;code&gt;END {}&lt;/code&gt; コンストラクト。</target>
        </trans-unit>
        <trans-unit id="cab6779d1c4d586e5a686816d2490a5a885e59ca" translate="yes" xml:space="preserve">
          <source>Shifts the first value of the array off and returns it, shortening the array by 1 and moving everything down. If there are no elements in the array, returns the undefined value. If ARRAY is omitted, shifts the &lt;code&gt;@_&lt;/code&gt; array within the lexical scope of subroutines and formats, and the &lt;code&gt;@ARGV&lt;/code&gt; array outside a subroutine and also within the lexical scopes established by the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; , &lt;code&gt;BEGIN {}&lt;/code&gt; , &lt;code&gt;INIT {}&lt;/code&gt; , &lt;code&gt;CHECK {}&lt;/code&gt; , &lt;code&gt;UNITCHECK {}&lt;/code&gt; , and &lt;code&gt;END {}&lt;/code&gt; constructs.</source>
          <target state="translated">配列の最初の値をシフトして返し、配列を1だけ短くしてすべて下に移動します。配列に要素がない場合、未定義の値を返します。ARRAYが省略された場合、シフト &lt;code&gt;@_&lt;/code&gt; サブルーチンやフォーマットの字句範囲内の配列、及び &lt;code&gt;@ARGV&lt;/code&gt; の字句スコープによって確立サブルーチン外部また以内アレイ &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; 、 &lt;code&gt;BEGIN {}&lt;/code&gt; 、 &lt;code&gt;INIT {}&lt;/code&gt; 、 &lt;code&gt;CHECK {}&lt;/code&gt; 、 &lt;code&gt;UNITCHECK {}&lt;/code&gt; 、および &lt;code&gt;END {}&lt;/code&gt; 構文。</target>
        </trans-unit>
        <trans-unit id="ceb6ece5170a4ff335501d527cf25219b25ce8af" translate="yes" xml:space="preserve">
          <source>Shifts the first value of the array off and returns it, shortening the array by 1 and moving everything down. If there are no elements in the array, returns the undefined value. If ARRAY is omitted, shifts the &lt;code&gt;@_&lt;/code&gt; array within the lexical scope of subroutines and formats, and the &lt;code&gt;@ARGV&lt;/code&gt; array outside a subroutine and also within the lexical scopes established by the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; , &lt;code&gt;BEGIN {}&lt;/code&gt; , &lt;code&gt;INIT {}&lt;/code&gt; , &lt;code&gt;CHECK {}&lt;/code&gt; , &lt;code&gt;UNITCHECK {}&lt;/code&gt; , and &lt;code&gt;END {}&lt;/code&gt; constructs.</source>
          <target state="translated">配列の最初の値をシフトして返し、配列を1だけ短くしてすべて下に移動します。配列に要素がない場合、未定義の値を返します。ARRAYが省略された場合、シフト &lt;code&gt;@_&lt;/code&gt; サブルーチンやフォーマットの字句範囲内の配列、及び &lt;code&gt;@ARGV&lt;/code&gt; の字句スコープによって確立サブルーチン外部また以内アレイ &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; STRING&lt;/code&gt; 、 &lt;code&gt;BEGIN {}&lt;/code&gt; 、 &lt;code&gt;INIT {}&lt;/code&gt; 、 &lt;code&gt;CHECK {}&lt;/code&gt; 、 &lt;code&gt;UNITCHECK {}&lt;/code&gt; 、および &lt;code&gt;END {}&lt;/code&gt; 構文。</target>
        </trans-unit>
        <trans-unit id="a9246a967ab694917a93818e0c2f25b9c02d69c1" translate="yes" xml:space="preserve">
          <source>Shlomi Fish</source>
          <target state="translated">シュロミフィッシュ</target>
        </trans-unit>
        <trans-unit id="531ae3a2e613d67a406a1e927931cfe1052049c5" translate="yes" xml:space="preserve">
          <source>Shoichi Kaji &amp;lt;skaji@cpan.org&amp;gt;</source>
          <target state="translated">梶翔一&amp;lt;skaji@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="dece67ae205fea215adef783e8ddedd9ee8cd234" translate="yes" xml:space="preserve">
          <source>Short for</source>
          <target state="translated">ショートフォー</target>
        </trans-unit>
        <trans-unit id="e560762a5e85f4245145df0a3d5f14955ebfbe7e" translate="yes" xml:space="preserve">
          <source>Short for &amp;ldquo;an instance of a class&amp;rdquo;, meaning an &lt;b&gt;object&lt;/b&gt; of that &lt;b&gt;class&lt;/b&gt;.</source>
          <target state="translated">「クラスのインスタンス」の略で、その&lt;b&gt;クラスの&lt;/b&gt;&lt;b&gt;オブジェクト&lt;/b&gt;を意味し&lt;b&gt;ます&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="bf0f9ba179007d01df18b67571c95890eacf53a2" translate="yes" xml:space="preserve">
          <source>Short for &amp;ldquo;array value&amp;rdquo;, which refers to one of Perl&amp;rsquo;s internal data types that holds an &lt;b&gt;array&lt;/b&gt;. The &lt;code&gt;AV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">「配列値」の略で、&lt;b&gt;配列&lt;/b&gt;を保持するPerlの内部データ型の1つを指します。 &lt;code&gt;AV&lt;/code&gt; のタイプのサブクラスである&lt;b&gt;SV&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="daa4e28096f49e40bca183e69c8dbf8fb7d81587" translate="yes" xml:space="preserve">
          <source>Short for &amp;ldquo;scalar value&amp;rdquo;. But within the Perl interpreter, every &lt;b&gt;referent&lt;/b&gt; is treated as a member of a class derived from SV, in an object-oriented sort of way. Every &lt;b&gt;value&lt;/b&gt; inside Perl is passed around as a C language &lt;code&gt;SV*&lt;/code&gt; pointer. The SV &lt;b&gt;struct&lt;/b&gt; knows its own &amp;ldquo;referent type&amp;rdquo;, and the code is smart enough (we hope) not to try to call a &lt;b&gt;hash&lt;/b&gt; function on a &lt;b&gt;subroutine&lt;/b&gt;.</source>
          <target state="translated">「スカラー値」の略。しかし、Perlインタープリター内では、すべての&lt;b&gt;指示対象&lt;/b&gt;は、オブジェクト指向の方法で、SVから派生したクラスのメンバーとして扱われます。Perl内のすべての&lt;b&gt;値&lt;/b&gt;は、C言語の &lt;code&gt;SV*&lt;/code&gt; ポインターとして渡されます。SV &lt;b&gt;構造体は&lt;/b&gt;それ自体の「リファレントタイプ」を知っており、コードは&lt;b&gt;サブルーチンで&lt;/b&gt;&lt;b&gt;ハッシュ&lt;/b&gt;関数を呼び出さないように十分にスマートです（希望します）。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5d19c4596f6bfea39cf19abcb0120dd79077a176" translate="yes" xml:space="preserve">
          <source>Short for &lt;b&gt;scratchpad&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;スクラッチパッドの&lt;/b&gt;略。</target>
        </trans-unit>
        <trans-unit id="11be5993935a64f6ec9ea9395f4cafbeb6afecc6" translate="yes" xml:space="preserve">
          <source>Short for Nevada, no part of which will ever be confused with civilization. NV also means an internal floating- point Numeric Value of the type a &lt;b&gt;scalar&lt;/b&gt; can hold, not to be confused with an &lt;b&gt;IV&lt;/b&gt;.</source>
          <target state="translated">ネバダの略で、文明と混同されることはありません。NV は、&lt;b&gt;IV&lt;/b&gt;と混同しないように、&lt;b&gt;スカラー&lt;/b&gt;が保持できるタイプの内部浮動小数点数値も意味します。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="753c68d3ba41db74e4df8914f2ce920431708ec4" translate="yes" xml:space="preserve">
          <source>Short for Transmission Control Protocol. A protocol wrapped around the Internet Protocol to make an unreliable packet transmission mechanism appear to the application program to be a reliable &lt;b&gt;stream&lt;/b&gt; of bytes. (Usually.)</source>
          <target state="translated">Transmission Control Protocolの略。信頼性の低いパケット送信メカニズムをアプリケーションプログラムから信頼性の高いバイト&lt;b&gt;ストリーム&lt;/b&gt;のように見せるために、インターネットプロトコルにラップされたプロトコル。（通常。）</target>
        </trans-unit>
        <trans-unit id="dc5ee68c69bf44299748c4c256b80c120fb271e9" translate="yes" xml:space="preserve">
          <source>Short for a &amp;ldquo;hash value&amp;rdquo; typedef, which holds Perl&amp;rsquo;s internal representation of a hash. The &lt;code&gt;HV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">Perlのハッシュの内部表現を保持する「ハッシュ値」typedefの短縮形。 &lt;code&gt;HV&lt;/code&gt; のタイプはのサブクラスである&lt;b&gt;SV&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="641d12dc5680debd9252f30257e835d77f2b58b5" translate="yes" xml:space="preserve">
          <source>Short for a &amp;ldquo;terminal&amp;rdquo;&amp;mdash;that is, a leaf node of a &lt;b&gt;syntax tree&lt;/b&gt;. A thing that functions grammatically as an &lt;b&gt;operand&lt;/b&gt; for the operators in an expression.</source>
          <target state="translated">「ターミナル」、つまり&lt;b&gt;構文ツリーの&lt;/b&gt;リーフノードの略。式の演算子の&lt;b&gt;オペランド&lt;/b&gt;として文法的に機能するもの。</target>
        </trans-unit>
        <trans-unit id="2a34ff2be32b26b7b9b0b3b4f346552a9899d102" translate="yes" xml:space="preserve">
          <source>Short for one member of &lt;b&gt;Perl mongers&lt;/b&gt;, a purveyor of Perl.</source>
          <target state="translated">&lt;b&gt;Perl&lt;/b&gt;の提供者である&lt;b&gt;Perl mongersの&lt;/b&gt; 1人のメンバーの略。</target>
        </trans-unit>
        <trans-unit id="215e423928369d110ed59f1768219b3b38101a83" translate="yes" xml:space="preserve">
          <source>Short integers. This is equivalent to T_IV but explicitly casts the return to type &lt;code&gt;short&lt;/code&gt; . The default typemap for &lt;code&gt;short&lt;/code&gt; is T_IV.</source>
          <target state="translated">短整数。これはT_IVと同じですが、戻り値を &lt;code&gt;short&lt;/code&gt; 型に明示的にキャストします。 &lt;code&gt;short&lt;/code&gt; のデフォルトのタイプマップはT_IVです。</target>
        </trans-unit>
        <trans-unit id="12e34708f98b55fcfa0df10d0541bdc76b04003d" translate="yes" xml:space="preserve">
          <source>Short integers. This is equivalent to T_IV but explicitly casts the return to type &lt;code&gt;short&lt;/code&gt;. The default typemap for &lt;code&gt;short&lt;/code&gt; is T_IV.</source>
          <target state="translated">短整数。これはT_IVと同等ですが、明示的にreturnを &lt;code&gt;short&lt;/code&gt; 型にキャストします。 &lt;code&gt;short&lt;/code&gt; デフォルトのタイプマップはT_IVです。</target>
        </trans-unit>
        <trans-unit id="e173f44ce033e23615a07008598ed98e0724ec82" translate="yes" xml:space="preserve">
          <source>Short of loading the file into a database or pre-indexing the lines in the file, there are a couple of things that you can do.</source>
          <target state="translated">ファイルをデータベースにロードしたり、ファイル内の行を事前にインデックス化したりする以外にも、いくつかの方法があります。</target>
        </trans-unit>
        <trans-unit id="84208312087b060594b7b3ab194603ca9b48cd14" translate="yes" xml:space="preserve">
          <source>Short string (usually 10 characters or less, not enforced, but may be truncated by renderers) categorizing the amnesty.</source>
          <target state="translated">アムネスティを分類する短い文字列(通常は10文字以下、強制ではありませんが、レンダラーによって切り捨てられる場合があります)。</target>
        </trans-unit>
        <trans-unit id="342f19ffca54484d831bc22d60422377cb72128f" translate="yes" xml:space="preserve">
          <source>Short summary: You need to create a package that defines four methods:</source>
          <target state="translated">簡単なまとめ:4つのメソッドを定義したパッケージを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="7d0c4499cb9c122a7211725e510477fa79e82bb6" translate="yes" xml:space="preserve">
          <source>Short tag to categorize the error. This is usually 10 characters or less, formatters may truncate longer tags.</source>
          <target state="translated">エラーを分類するための短いタグ。これは通常10文字以下ですが、フォーマッタはより長いタグを切り捨てることができます。</target>
        </trans-unit>
        <trans-unit id="5092f6331f83cfc30c23eb79579783db3e8793f1" translate="yes" xml:space="preserve">
          <source>Short tag to categorize the info. This is usually 10 characters or less, formatters may truncate longer tags.</source>
          <target state="translated">情報を分類するための短いタグ。これは通常10文字以下ですが、フォーマッタは長いタグを切り捨てることができます。</target>
        </trans-unit>
        <trans-unit id="c1b21662873145e63208c0c220c63eecf3382545" translate="yes" xml:space="preserve">
          <source>Short tests may produce negative figures because perl can appear to take longer to execute the empty loop than a short test; try:</source>
          <target state="translated">短いテストでは負の数字が出ることがありますが、これはperlが短いテストよりも空のループを実行するのに時間がかかるように見えるからです。</target>
        </trans-unit>
        <trans-unit id="3c291d239a5572586d5800f8940e243040b2c7b5" translate="yes" xml:space="preserve">
          <source>Shortcomings of Perl under AmigaOS</source>
          <target state="translated">AmigaOSでのPerlの欠点</target>
        </trans-unit>
        <trans-unit id="fa78e77c849e3197f1c80d2dbbfe4db374f3b001" translate="yes" xml:space="preserve">
          <source>Shortcomings of Perl under DOS</source>
          <target state="translated">DOS版Perlの欠点</target>
        </trans-unit>
        <trans-unit id="a84b9d9cc1ba4235d4b9a38a4443bc225f0a9d86" translate="yes" xml:space="preserve">
          <source>Should I do anything special if I call perl from multiple threads?</source>
          <target state="translated">複数のスレッドからperlを呼び出す場合は、何か特別なことをした方がいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="41623a0ef32a13c7058b74719f5d1256441b7302" translate="yes" xml:space="preserve">
          <source>Should I use a web framework?</source>
          <target state="translated">Webフレームワークを使うべきか?</target>
        </trans-unit>
        <trans-unit id="706821549d14c573be320aadd1615ad49253a11a" translate="yes" xml:space="preserve">
          <source>Should a user have the need for compiling Perl in the LP64 environment, use the -Duse64bitall flag to Configure. This will force Perl to be compiled in a pure LP64 environment (with the +DD64 flag for HP C-ANSI-C, with no additional options for GNU gcc 64-bit on PA-RISC, and with -mlp64 for GNU gcc on Itanium). If you want to compile Perl using gcc, you will have to get a version of the compiler that supports 64-bit operations.)</source>
          <target state="translated">PerlをLP64環境でコンパイルする必要がある場合、Configureに-Duse64bitallフラグを使用してください。これにより、Perlは強制的に純粋なLP64環境でコンパイルされます(HP C-ANSI-Cでは+DD64フラグ、PA-RISCではGNU gcc 64-bit用の追加オプションなし、ItaniumではGNU gcc用の-mlp64)。gccを使ってPerlをコンパイルしたい場合は、64ビット操作をサポートするコンパイラのバージョンを取得する必要があります)。</target>
        </trans-unit>
        <trans-unit id="efca6f20e60abb6462f2115cc6f4f778b3e904aa" translate="yes" xml:space="preserve">
          <source>Should an &lt;code&gt;ok()&lt;/code&gt; fail, it will produce some diagnostics:</source>
          <target state="translated">万一 &lt;code&gt;ok()&lt;/code&gt; が失敗、それはいくつかの診断を生成します。</target>
        </trans-unit>
        <trans-unit id="6ed2a6a9606e8c4524e86ab5840b45b4bc37bfbb" translate="yes" xml:space="preserve">
          <source>Should be true if this event should result in a test count increment.</source>
          <target state="translated">このイベントがテストカウントのインクリメントになるかどうかを判定するためにtrueを指定します。</target>
        </trans-unit>
        <trans-unit id="7aa2401927f1002b79d1cf0dcfbafc98b85b5c42" translate="yes" xml:space="preserve">
          <source>Should be used if the perl library is moved from the default location in preference to &lt;code&gt;PERL(5)LIB&lt;/code&gt;, since this would not leave wrong entries in @INC. For example, if the compiled version of perl looks for @INC in</source>
          <target state="translated">@INCに間違ったエントリを残さないため、 &lt;code&gt;PERL(5)LIB&lt;/code&gt; ライブラリがデフォルトの場所からPERL（5）LIBに優先して移動される場合に使用する必要があります。たとえば、コンパイルされたバージョンのperlが@INCを探す場合</target>
        </trans-unit>
        <trans-unit id="56e9538fa48dc5397d7704d11be1b316f1409e45" translate="yes" xml:space="preserve">
          <source>Should make stream's state consistent with layers below. That is, any buffered write data should be written, and file position of lower layers adjusted for data read from below but not actually consumed. (Should perhaps &lt;code&gt;Unread()&lt;/code&gt; such data to the lower layer.)</source>
          <target state="translated">ストリームの状態を下のレイヤーと一致させる必要があります。つまり、バッファリングされた書き込みデータが書き込まれ、下位層のファイル位置が下から読み取られたデータ用に調整されますが、実際には消費されません。（おそらくこのようなデータを下位層に &lt;code&gt;Unread()&lt;/code&gt; する必要があります。）</target>
        </trans-unit>
        <trans-unit id="1c3d2c3d146bd37267ff2248c2cd5e844253f599" translate="yes" xml:space="preserve">
          <source>Should not be set with newer Perls, since this may hide some</source>
          <target state="translated">新しいPerlでは設定すべきではありません。</target>
        </trans-unit>
        <trans-unit id="ed8ff1c4976aa7b4301ba319829b15d5951b2c6e" translate="yes" xml:space="preserve">
          <source>Should probably be built into the core, and needs to stop pandering to DOS habits. Needs a dose of optimization too.</source>
          <target state="translated">おそらくコアに組み込まれるべきで、DOS の習慣に迎合するのをやめる必要があります。最適化も必要です。</target>
        </trans-unit>
        <trans-unit id="fbde5e966385ab1512ea67e3f35d08dd24d83ceb" translate="yes" xml:space="preserve">
          <source>Should return 0 on success, -1 on error. Optional.</source>
          <target state="translated">成功した場合は 0、エラーの場合は -1 を返す必要があります。オプション。</target>
        </trans-unit>
        <trans-unit id="f8c399f86acf033efef1e2751ef404b5ddaa2865" translate="yes" xml:space="preserve">
          <source>Should return 0 on success, -1 on error. Optional. Default is to fail, but that is likely to be changed in future.</source>
          <target state="translated">成功した場合は 0、エラーの場合は -1 を返す必要があります。オプション。デフォルトは失敗しますが、将来的には変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="246758221cfd3e60868d6718c892fa1bb87177ab" translate="yes" xml:space="preserve">
          <source>Should return a string to be placed in the buffer. Optional. If not provided, must provide READ or reject handles open for reading in PUSHED.</source>
          <target state="translated">バッファに配置する文字列を返す必要があります。省略可能。用意されていない場合は、PUSHEDでの読み込みのためのREADハンドルまたはリジェクトハンドルを用意しなければなりません。</target>
        </trans-unit>
        <trans-unit id="d3cbfd0fcf4f24975313de4df8de49164d7ee2fd" translate="yes" xml:space="preserve">
          <source>Should return an object or the class, or -1 on failure. (Compare TIEHANDLE.) The arguments are an optional mode string (&quot;r&quot;, &quot;w&quot;, &quot;w+&quot;, ...) and a filehandle for the PerlIO layer below. Mandatory.</source>
          <target state="translated">オブジェクトかクラスを返すか、失敗した場合は -1 を返す必要があります(TIEHANDLE を比較してください)。引数はオプションのモード文字列 (&quot;r&quot;,&quot;w&quot;,&quot;w+&quot;,....)と、以下の PerlIO レイヤーのファイルハンドルです。必須。</target>
        </trans-unit>
        <trans-unit id="5642f34ce9dcd1c3ffa2dfc0c58640c6cb31044d" translate="yes" xml:space="preserve">
          <source>Should the $prefix fail to match</source>
          <target state="translated">もし $prefix が一致しなかった場合は</target>
        </trans-unit>
        <trans-unit id="1690346ded0caeaa5dcdd766cbbfd423effb3884" translate="yes" xml:space="preserve">
          <source>Should yield no problems with AIX 5.1 / 5.2 / 5.3 / 6.1 / 7.1.</source>
          <target state="translated">AIX 5.1/5.2/5.3/6.1/7.1で問題がないはずです。</target>
        </trans-unit>
        <trans-unit id="377f03a2a4c9b170d5d73c84fdd0fa6c29b00142" translate="yes" xml:space="preserve">
          <source>Should yield no problems.</source>
          <target state="translated">何の問題もないはずです。</target>
        </trans-unit>
        <trans-unit id="35f86593f3a7cab63ebec9bff3335371662e4b80" translate="yes" xml:space="preserve">
          <source>Should you be stuck with an ancient version of git (prior to 1.7), then &lt;code&gt;git push&lt;/code&gt; will not have the &lt;code&gt;-u&lt;/code&gt; switch, and you have to replace the last step with the following sequence:</source>
          <target state="translated">古いバージョンのgit（1.7より前）で立ち往生している場合、 &lt;code&gt;git push&lt;/code&gt; には &lt;code&gt;-u&lt;/code&gt; スイッチがないため、最後の手順を次のシーケンスに置き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="0b16df946245605727ff1e16d4791f2bf174400d" translate="yes" xml:space="preserve">
          <source>Should you wish to build a statically-linked executable on a system which can dynamically load libraries, you may, in all the following examples, where the command &quot;&lt;code&gt;make&lt;/code&gt; &quot; with no arguments is executed, run the command &quot;&lt;code&gt;make perl&lt;/code&gt; &quot; instead.</source>
          <target state="translated">ライブラリを動的にロードできるシステムで静的にリンクされた実行可能ファイルを構築したい場合、以下のすべての例で、引数なしでコマンド「 &lt;code&gt;make&lt;/code&gt; 」が実行される場合は、代わりにコマンド「 &lt;code&gt;make perl&lt;/code&gt; 」を実行できます。</target>
        </trans-unit>
        <trans-unit id="398654e660729596cb8454b7f800d571ef53f379" translate="yes" xml:space="preserve">
          <source>Should you wish to build a statically-linked executable on a system which can dynamically load libraries, you may, in all the following examples, where the command &quot;&lt;code&gt;make&lt;/code&gt;&quot; with no arguments is executed, run the command &quot;&lt;code&gt;make perl&lt;/code&gt;&quot; instead.</source>
          <target state="translated">ライブラリを動的にロードできるシステム上で静的にリンクされた実行可能ファイルを構築する場合は、以下のすべての例で、引数なしでコマンド「 &lt;code&gt;make&lt;/code&gt; 」を実行し、代わりにコマンド「 &lt;code&gt;make perl&lt;/code&gt; 」を実行できます。</target>
        </trans-unit>
        <trans-unit id="4ad198af5ed254b36c0129bab30cb66de4af9306" translate="yes" xml:space="preserve">
          <source>Show all individual modules that have a $VERSION of zero?</source>
          <target state="translated">ゼロの $VERSION を持つ個々のモジュールをすべて表示しますか?</target>
        </trans-unit>
        <trans-unit id="5886e6a19b112ccca7d7e5c6a420d33f7dc320f4" translate="yes" xml:space="preserve">
          <source>Show all individual modules that have no $VERSION?</source>
          <target state="translated">VERSION がない個々のモジュールをすべて表示しますか?</target>
        </trans-unit>
        <trans-unit id="432657faf9897211c68f4ccc299c680506ae0f85" translate="yes" xml:space="preserve">
          <source>Show lexical variables used in functions or files</source>
          <target state="translated">関数やファイルで使用される語彙変数を表示する</target>
        </trans-unit>
        <trans-unit id="15563729135e9ba264fbcba30a709d66c8a1dd93" translate="yes" xml:space="preserve">
          <source>Show test comments (this is a no-op if &lt;code&gt;verbose&lt;/code&gt; is selected).</source>
          <target state="translated">テストコメントを表示します（ &lt;code&gt;verbose&lt;/code&gt; が選択されている場合、これは何もしません）。</target>
        </trans-unit>
        <trans-unit id="453672f22864e2ecabd52010a0251f21457a02b2" translate="yes" xml:space="preserve">
          <source>Show test failures (this is a no-op if &lt;code&gt;verbose&lt;/code&gt; is selected).</source>
          <target state="translated">テストの失敗を表示します（ &lt;code&gt;verbose&lt;/code&gt; が選択されている場合、これは何もしません）。</target>
        </trans-unit>
        <trans-unit id="25af3a88c3b3773349dd8ac90b045308d5492ec5" translate="yes" xml:space="preserve">
          <source>Show the</source>
          <target state="translated">を表示します。</target>
        </trans-unit>
        <trans-unit id="07ccbb891469b1a972be7b689b1ec1c7304ecb2a" translate="yes" xml:space="preserve">
          <source>Show the module details. This prints one line for each out-of-date module (meaning, modules locally installed but have newer versions on CPAN). Each line has three columns: module name, local version, and CPAN version.</source>
          <target state="translated">モジュールの詳細を表示します。これは、古いモジュール(ローカルにインストールされているが、CPANに新しいバージョンがあるモジュールを意味する)ごとに1行ずつ表示します。各行には、モジュール名、ローカルバージョン、および CPAN バージョンの 3 つの列があります。</target>
        </trans-unit>
        <trans-unit id="bad96a4d0e92d1a92a25032d1a69981cb8c4094d" translate="yes" xml:space="preserve">
          <source>Show the out-of-date modules.</source>
          <target state="translated">古いモジュールを表示します。</target>
        </trans-unit>
        <trans-unit id="e3deb58d49160799c00454338107f604ea794ed5" translate="yes" xml:space="preserve">
          <source>Show usage.</source>
          <target state="translated">使用法を表示します。</target>
        </trans-unit>
        <trans-unit id="7222550b5b66397acb151415418533c6a8f6f5fe" translate="yes" xml:space="preserve">
          <source>ShowMode</source>
          <target state="translated">ShowMode</target>
        </trans-unit>
        <trans-unit id="66970db782112b1077801cd655daa3c67c2cdecf" translate="yes" xml:space="preserve">
          <source>Shows if the given module is primarily maintained in perl core or on CPAN and bug tracker URL.</source>
          <target state="translated">指定されたモジュールが主に perl core でメンテナンスされているか、CPAN とバグトラッカーの URL でメンテナンスされているかを表示します。</target>
        </trans-unit>
        <trans-unit id="ab7d18eafb7bcc2a74ee000087e57646aecc2b0d" translate="yes" xml:space="preserve">
          <source>Shows the primary maintainers for the specified modules.</source>
          <target state="translated">指定されたモジュールのプライマリメンテナを表示します。</target>
        </trans-unit>
        <trans-unit id="11a820735e69e06ccea6cc9de4ba8697b78a4549" translate="yes" xml:space="preserve">
          <source>Shuts down a Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt; for a tutorial.</source>
          <target state="translated">Perlインタプリタをシャットダウンします。チュートリアルについては、&lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ac75e459283e311c2d85839794c7648cec7df9c2" translate="yes" xml:space="preserve">
          <source>Shuts down a Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">Perlインタープリターをシャットダウンします。&lt;a href=&quot;perlembed&quot;&gt;perlembedを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="90e62e13ea37ff3f7a2ddce5609c724fd7e64daf" translate="yes" xml:space="preserve">
          <source>Shuts down a socket connection in the manner indicated by HOW, which has the same interpretation as in the syscall of the same name.</source>
          <target state="translated">HOW で指定された方法でソケット接続をシャットダウンしますが、これは同名のシステムコールと同じ解釈になります。</target>
        </trans-unit>
        <trans-unit id="7187637d0f34c57d8bea4681c13bb60273e1f7d1" translate="yes" xml:space="preserve">
          <source>Shuts down a socket connection in the manner indicated by the value passed in, which has the same interpretation as in the syscall of the same name.</source>
          <target state="translated">ソケット接続をシャットダウンします。</target>
        </trans-unit>
        <trans-unit id="de95fa319fad54d4fda1efff03c4320b4f1bbba0" translate="yes" xml:space="preserve">
          <source>Shutsdown the specified MACHINE, notifying users with the supplied MESSAGE, within the specified TIMEOUT interval. Forces closing of all documents without prompting the user if FORCECLOSE is true, and reboots the machine if REBOOT is true. This function works only on WinNT.</source>
          <target state="translated">指定されたTIMEOUT間隔内に、指定されたMESSAGEでユーザに通知しながら、指定されたマシンをシャットダウンします。FORCECLOSEが真の場合はユーザにプロンプトを出さずに全てのドキュメントを強制終了し,REBOOTが真の場合はマシンを再起動します.この機能はWinNTでのみ動作します。</target>
        </trans-unit>
        <trans-unit id="8b3d8d665a765918b70a3f5f0378d51df00b92dd" translate="yes" xml:space="preserve">
          <source>Sign</source>
          <target state="translated">Sign</target>
        </trans-unit>
        <trans-unit id="27bed13a88c60350c3de92ec3820e1cc4f7d6ec3" translate="yes" xml:space="preserve">
          <source>Signal</source>
          <target state="translated">Signal</target>
        </trans-unit>
        <trans-unit id="76e3a47c3cea2b4bc39210e8f1a7a4f458325f46" translate="yes" xml:space="preserve">
          <source>Signal flag. Will be set to a true value if a signal was caught. Clients may check for this flag to abort time-consuming operations.</source>
          <target state="translated">シグナルフラグ。シグナルがキャッチされた場合、真の値に設定されます。クライアントはこのフラグをチェックして、時間のかかる操作を中止することができます。</target>
        </trans-unit>
        <trans-unit id="47e8409eab6e54647df4cb7cecc41ee28c30a02b" translate="yes" xml:space="preserve">
          <source>Signal handlers deal with signal names, not numbers. Use &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; to find their names on your system.</source>
          <target state="translated">シグナルハンドラは、番号ではなくシグナル名を扱います。 &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -l&lt;/code&gt; を使用して、システムでそれらの名前を検索します。</target>
        </trans-unit>
        <trans-unit id="f793004ac2bfb867d7b8c1fed8ccaa1370121adc" translate="yes" xml:space="preserve">
          <source>Signal handlers deal with signal names, not numbers. Use &lt;code&gt;kill -l&lt;/code&gt; to find their names on your system.</source>
          <target state="translated">シグナルハンドラーは、番号ではなくシグナル名を扱います。 &lt;code&gt;kill -l&lt;/code&gt; を使用して、システム上でそれらの名前を見つけます。</target>
        </trans-unit>
        <trans-unit id="a89722759e06611996072c09d8d893f78366be03" translate="yes" xml:space="preserve">
          <source>Signal handlers need to be set up in the threads for the signals they are expected to act upon. Here's an example for</source>
          <target state="translated">シグナルハンドラは、それらが動作することが期待されるシグナルに対してスレッド内で設定する必要があります。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="4c81c67cfc40c99d8beeb124cd5a299ed53f7fa3" translate="yes" xml:space="preserve">
          <source>Signal handling is also used for timeouts in Unix. While safely protected within an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; block, you set a signal handler to trap alarm signals and then schedule to have one delivered to you in some number of seconds. Then try your blocking operation, clearing the alarm when it's done but not before you've exited your &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; block. If it goes off, you'll use die() to jump out of the block.</source>
          <target state="translated">シグナル処理は、Unixのタイムアウトにも使用されます。 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; ブロック内で安全に保護しながら、アラームシグナルをトラップするようにシグナルハンドラーを設定し、数秒後にシグナルハンドラーが配信されるようにスケジュールします。次に、ブロック操作を試してください。アラームをクリアしますが、 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; ブロックを終了する前ではありません。オフになった場合は、die（）を使用してブロックからジャンプします。</target>
        </trans-unit>
        <trans-unit id="d4984dbb18bb8f6d69231c1c5402b289b6cae3fd" translate="yes" xml:space="preserve">
          <source>Signal handling is also used for timeouts in Unix. While safely protected within an &lt;code&gt;eval{}&lt;/code&gt; block, you set a signal handler to trap alarm signals and then schedule to have one delivered to you in some number of seconds. Then try your blocking operation, clearing the alarm when it's done but not before you've exited your &lt;code&gt;eval{}&lt;/code&gt; block. If it goes off, you'll use die() to jump out of the block.</source>
          <target state="translated">シグナル処理は、Unixのタイムアウトにも使用されます。 &lt;code&gt;eval{}&lt;/code&gt; ブロック内で安全に保護されている間、アラーム信号をトラップするようにシグナルハンドラーを設定し、数秒以内にアラーム信号が配信されるようにスケジュールします。次に、ブロック操作を試してください。完了したらアラームをクリアしますが、 &lt;code&gt;eval{}&lt;/code&gt; ブロックを終了する前にはクリアしません。それが消えたら、die（）を使用してブロックから飛び出します。</target>
        </trans-unit>
        <trans-unit id="c9cd055a7cd87b137130bb8b93c1c2e53904764f" translate="yes" xml:space="preserve">
          <source>Signal handling may not behave as on Unix platforms (where it doesn't exactly &quot;behave&quot;, either :). For instance, calling &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; from signal handlers will cause an exception, since most implementations of &lt;code&gt;signal()&lt;/code&gt; on Windows are severely crippled. Thus, signals may work only for simple things like setting a flag variable in the handler. Using signals under this port should currently be considered unsupported.</source>
          <target state="translated">シグナル処理は、Unixプラットフォームのように動作しない場合があります（正確に「動作」しない場合も同様です）。たとえば、Windows での &lt;code&gt;signal()&lt;/code&gt; のほとんどの実装はひどく機能していないため、シグナルハンドラから &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; を呼び出すと例外が発生します。したがって、シグナルは、ハンドラーでフラグ変数を設定するような単純な場合にのみ機能します。このポートでの信号の使用は、現在サポートされていないと見なされます。</target>
        </trans-unit>
        <trans-unit id="a87648f8ff8510d519181cee20c22a292d601e89" translate="yes" xml:space="preserve">
          <source>Signal handling may not behave as on Unix platforms (where it doesn't exactly &quot;behave&quot;, either :). For instance, calling &lt;code&gt;die()&lt;/code&gt; or &lt;code&gt;exit()&lt;/code&gt; from signal handlers will cause an exception, since most implementations of &lt;code&gt;signal()&lt;/code&gt; on Windows are severely crippled. Thus, signals may work only for simple things like setting a flag variable in the handler. Using signals under this port should currently be considered unsupported.</source>
          <target state="translated">シグナル処理は、Unixプラットフォームのように動作しない場合があります（正確に「動作」しない場合もあります:)。たとえば、シグナルハンドラから &lt;code&gt;die()&lt;/code&gt; または &lt;code&gt;exit()&lt;/code&gt; を呼び出すと、例外が発生します。これは、Windowsでの &lt;code&gt;signal()&lt;/code&gt; のほとんどの実装が大幅に機能しなくなっているためです。したがって、シグナルは、ハンドラーでフラグ変数を設定するなどの単純な場合にのみ機能する可能性があります。このポートでの信号の使用は、現在サポートされていないと見なされます。</target>
        </trans-unit>
        <trans-unit id="2e6c417fd537a17b001daa7dbea3a3b50cef51ef" translate="yes" xml:space="preserve">
          <source>Signal number zero may fail because you lack permission to send the signal when directed at a process whose real or saved UID is not identical to the real or effective UID of the sending process, even though the process is alive. You may be able to determine the cause of failure using &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;%!&lt;/code&gt; .</source>
          <target state="translated">プロセスが生きていても、実際のUIDまたは保存されたUIDが送信プロセスの実際のUIDまたは実効UIDと一致しないプロセスに信号を送ると、シグナルを送信する権限がないため、シグナル番号0が失敗することがあります。 &lt;code&gt;$!&lt;/code&gt; を使用して、失敗の原因を特定できる場合があります。または &lt;code&gt;%!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2252f0feffa6900d113f918d18d91c133bf55365" translate="yes" xml:space="preserve">
          <source>Signal number zero may fail because you lack permission to send the signal when directed at a process whose real or saved UID is not identical to the real or effective UID of the sending process, even though the process is alive. You may be able to determine the cause of failure using &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;%!&lt;/code&gt;.</source>
          <target state="translated">プロセスが稼働していても、実際のUIDまたは保存されたUIDが送信プロセスの実際のUIDまたは有効なUIDと同一ではないプロセスに向けられたときにシグナルを送信する権限がないため、シグナル番号0が失敗する場合があります。 &lt;code&gt;$!&lt;/code&gt; を使用して、失敗の原因を特定できる場合があります。または &lt;code&gt;%!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="fec07adfbf089fdf5b54412a5f3085422a9dd0ae" translate="yes" xml:space="preserve">
          <source>Signals are</source>
          <target state="translated">シグナルは</target>
        </trans-unit>
        <trans-unit id="fe837ae8c05b966bdccbee31fe8ed0fe5d881059" translate="yes" xml:space="preserve">
          <source>Signals as &quot;faults&quot;</source>
          <target state="translated">シグナルを &quot;欠陥 &quot;として</target>
        </trans-unit>
        <trans-unit id="43861fb85280c34c4b0e58573e896842254a1d10" translate="yes" xml:space="preserve">
          <source>Signals in Plan 9 Perl</source>
          <target state="translated">プラン9 Perlでのシグナル</target>
        </trans-unit>
        <trans-unit id="259b4915ff9abfbb2a728a264509dffb23aed5c4" translate="yes" xml:space="preserve">
          <source>Signals that are intercepted:</source>
          <target state="translated">傍受された信号。</target>
        </trans-unit>
        <trans-unit id="0e2f061cd789264d5433118e03b134a8734af9d2" translate="yes" xml:space="preserve">
          <source>Signals triggered by operating system state</source>
          <target state="translated">オペレーティングシステムの状態によってトリガされる信号</target>
        </trans-unit>
        <trans-unit id="e4cf0392296064579858651f856889aadbc2805e" translate="yes" xml:space="preserve">
          <source>Signatures</source>
          <target state="translated">Signatures</target>
        </trans-unit>
        <trans-unit id="d9d7c542958055b1904998cdb447122ec36a75ab" translate="yes" xml:space="preserve">
          <source>Signed bitwise operators.</source>
          <target state="translated">符号付きビット演算子。</target>
        </trans-unit>
        <trans-unit id="2622f509b356185fe6a42f6313ddbc8e57057af2" translate="yes" xml:space="preserve">
          <source>Significant performance improvements</source>
          <target state="translated">パフォーマンスの大幅な改善</target>
        </trans-unit>
        <trans-unit id="ae6207f79c10c58b3e0ef4c08bbf6c86acc82fd9" translate="yes" xml:space="preserve">
          <source>Signum function. Set the number to -1, 0, or 1, depending on whether the number is negative, zero, or positive, respectively. Does not modify NaNs.</source>
          <target state="translated">シグナム関数。マイナス、ゼロ、プラスのいずれかに応じて、それぞれ-1、0、1のいずれかに設定します。NaN を変更しません。</target>
        </trans-unit>
        <trans-unit id="31506097adfa948440134c0119e5a52038393445" translate="yes" xml:space="preserve">
          <source>Silberschatz, Abraham, and Peter B. Galvin. Operating System Concepts, 4th ed. Addison-Wesley, 1995, ISBN 0-201-59292-4</source>
          <target state="translated">シルバーシャッツ、エイブラハム、ピーター・B・ガルビン。オペレーティングシステムの概念、第4版。アディソンウェズリー、1995年、ISBN 0-201-59292-4</target>
        </trans-unit>
        <trans-unit id="c1200bf449b67efb756e3194a25dcba2a224c7bd" translate="yes" xml:space="preserve">
          <source>Similar in functionality to &lt;a href=&quot;perlfunc#recv&quot;&gt;&quot;recv&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlfunc#recv&quot;&gt;perlfuncの「recv」&lt;/a&gt;と機能が似ています。</target>
        </trans-unit>
        <trans-unit id="ebf91ecf8b9db2d36c3c4af1dda8c5294da5403f" translate="yes" xml:space="preserve">
          <source>Similar in functionality to &lt;a href=&quot;perlfunc#send&quot;&gt;&quot;send&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlfunc#send&quot;&gt;perlfuncの「送信」&lt;/a&gt;と機能が似ています。</target>
        </trans-unit>
        <trans-unit id="8c4b469b48eb970781d347cff775a6eb6ed07b9c" translate="yes" xml:space="preserve">
          <source>Similar problems can occur when storing &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; in HVs:</source>
          <target state="translated">&lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; をHV に保存するときに、同様の問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="0939c3fe5c0d5d2bff40d1b5db20a06321bba976" translate="yes" xml:space="preserve">
          <source>Similar to</source>
          <target state="translated">に似ています。</target>
        </trans-unit>
        <trans-unit id="ca29a7deeeb800f3b647ae8e447ace2495bd48e6" translate="yes" xml:space="preserve">
          <source>Similar to &quot;CHECK&quot;, but for &lt;code&gt;INIT&lt;/code&gt; -blocks, not &lt;code&gt;CHECK&lt;/code&gt; blocks.</source>
          <target state="translated">「CHECK」に似ていますが、 &lt;code&gt;INIT&lt;/code&gt; ブロックではなく、 &lt;code&gt;CHECK&lt;/code&gt; ブロックです。</target>
        </trans-unit>
        <trans-unit id="f5ec53f333f04a2995b3e086134767c778243eaa" translate="yes" xml:space="preserve">
          <source>Similar to &quot;CHECK&quot;, but for &lt;code&gt;INIT&lt;/code&gt;-blocks, not &lt;code&gt;CHECK&lt;/code&gt; blocks.</source>
          <target state="translated">「CHECK」に似ていますが、 &lt;code&gt;CHECK&lt;/code&gt; ブロックではなく &lt;code&gt;INIT&lt;/code&gt; ブロック用です。</target>
        </trans-unit>
        <trans-unit id="a02dc2c9e4fd99225658784381bc57431376c4f2" translate="yes" xml:space="preserve">
          <source>Similar to $io-&amp;gt;seek, but sets the IO::File's position using the system call lseek(2) directly, so will confuse most perl IO operators except sysread and syswrite (see &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; for full details)</source>
          <target state="translated">$ io-&amp;gt; seekに似ていますが、システムコールlseek（2）を使用してIO :: Fileの位置を直接設定するため、sysreadとsyswriteを除くほとんどのperl IOオペレーターを混同します（詳細については&lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt;を参照）</target>
        </trans-unit>
        <trans-unit id="68c4347f8fea5b416312257ca34ba342de4d10b9" translate="yes" xml:space="preserve">
          <source>Similar to $io-&amp;gt;seek, but sets the IO::File's position using the system call lseek(2) directly, so will confuse most perl IO operators except sysread and syswrite (see &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for full details)</source>
          <target state="translated">$ io-&amp;gt; seekに似ていますが、システムコールlseek（2）を直接使用してIO :: Fileの位置を設定するため、sysreadとsyswriteを除くほとんどのperl IO演算子が混乱します（詳細については、&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="54a39eaf579340710bf4bd0f530bd675ee9e7a95" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#any&quot;&gt;&quot;any&quot;&lt;/a&gt; and &lt;a href=&quot;#all&quot;&gt;&quot;all&quot;&lt;/a&gt;, but with the return sense inverted. &lt;code&gt;none&lt;/code&gt; returns true only if no value in the &lt;code&gt;@list&lt;/code&gt; causes the &lt;code&gt;BLOCK&lt;/code&gt; to return true, and &lt;code&gt;notall&lt;/code&gt; returns true only if not all of the values do.</source>
          <target state="translated">&lt;a href=&quot;#any&quot;&gt;「any」&lt;/a&gt;と&lt;a href=&quot;#all&quot;&gt;「all」&lt;/a&gt;に似ていますが、戻り方向が逆になっています。 &lt;code&gt;@list&lt;/code&gt; に値がないために &lt;code&gt;BLOCK&lt;/code&gt; がtrueを返す場合にのみ、 &lt;code&gt;none&lt;/code&gt; はtrueを返し、 &lt;code&gt;notall&lt;/code&gt; は、すべての値がそうではない場合にのみtrueを返します。</target>
        </trans-unit>
        <trans-unit id="48998732d2d944be662f876c6215817f6203f325" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#any&quot;&gt;&quot;any&quot;&lt;/a&gt;, except that it requires all elements of the &lt;code&gt;@list&lt;/code&gt; to make the &lt;code&gt;BLOCK&lt;/code&gt; return true. If any element returns false, then it returns false. If the &lt;code&gt;BLOCK&lt;/code&gt; never returns false or the &lt;code&gt;@list&lt;/code&gt; was empty then it returns true.</source>
          <target state="translated">&lt;a href=&quot;#any&quot;&gt;「any」&lt;/a&gt;と同様ですが、 &lt;code&gt;BLOCK&lt;/code&gt; をtrueに戻すために &lt;code&gt;@list&lt;/code&gt; のすべての要素が必要になる点が異なります。いずれかの要素がfalseを返す場合、falseを返します。 &lt;code&gt;BLOCK&lt;/code&gt; がfalseを返さない場合、または &lt;code&gt;@list&lt;/code&gt; が空の場合は、trueを返します。</target>
        </trans-unit>
        <trans-unit id="aeabee18f75813e1d32d468eb7ba172bf546eaed" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#any&quot;&gt;any&lt;/a&gt; and &lt;a href=&quot;#all&quot;&gt;all&lt;/a&gt;, but with the return sense inverted. &lt;code&gt;none&lt;/code&gt; returns true only if no value in the &lt;code&gt;@list&lt;/code&gt; causes the &lt;code&gt;BLOCK&lt;/code&gt; to return true, and &lt;code&gt;notall&lt;/code&gt; returns true only if not all of the values do.</source>
          <target state="translated">&lt;a href=&quot;#any&quot;&gt;any&lt;/a&gt; and &lt;a href=&quot;#all&quot;&gt;allに&lt;/a&gt;似ていますが、戻り方向が逆になっています。 &lt;code&gt;none&lt;/code&gt; は、 &lt;code&gt;@list&lt;/code&gt; 値がないために &lt;code&gt;BLOCK&lt;/code&gt; がtrueを返す場合にのみtrueを返し、 &lt;code&gt;notall&lt;/code&gt; は、すべての値がそうでない場合にのみtrueを返します。</target>
        </trans-unit>
        <trans-unit id="e0b3d2d208d62b5b40ff53db1e72a57e69459f20" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#any&quot;&gt;any&lt;/a&gt;, except that it requires all elements of the &lt;code&gt;@list&lt;/code&gt; to make the &lt;code&gt;BLOCK&lt;/code&gt; return true. If any element returns false, then it returns false. If the &lt;code&gt;BLOCK&lt;/code&gt; never returns false or the &lt;code&gt;@list&lt;/code&gt; was empty then it returns true.</source>
          <target state="translated">同様に&lt;a href=&quot;#any&quot;&gt;すべての&lt;/a&gt;、それはすべての要素が必要ですことを除いて &lt;code&gt;@list&lt;/code&gt; を作るために &lt;code&gt;BLOCK&lt;/code&gt; リターンが真。いずれかの要素がfalseを返す場合、falseを返します。場合 &lt;code&gt;BLOCK&lt;/code&gt; は falseを返すことはありませんか &lt;code&gt;@list&lt;/code&gt; は空だった、それはtrueを返します。</target>
        </trans-unit>
        <trans-unit id="4be8eb83dc7372a8ceafe2d398607db21cbd0df8" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#max&quot;&gt;&quot;max&quot;&lt;/a&gt; but returns the entry in the list with the lowest numerical value. If the list is empty then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;a href=&quot;#max&quot;&gt;「max」に&lt;/a&gt;似ていますが、数値が最も小さいリスト内のエントリを返します。リストが空の場合、 &lt;code&gt;undef&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="dfcb2ef3c4104f74e02c3a234af9ace81a7ab965" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#max&quot;&gt;&quot;max&quot;&lt;/a&gt;, but treats all the entries in the list as strings and returns the highest string as defined by the &lt;code&gt;gt&lt;/code&gt; operator. If the list is empty then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;a href=&quot;#max&quot;&gt;「max」に&lt;/a&gt;似ていますが、リスト内のすべてのエントリを文字列として扱い、 &lt;code&gt;gt&lt;/code&gt; 演算子で定義された最高の文字列を返します。リストが空の場合、 &lt;code&gt;undef&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="b9665cd00110ac2a060c12898dd3b9d89a35f309" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#max&quot;&gt;max&lt;/a&gt; but returns the entry in the list with the lowest numerical value. If the list is empty then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;a href=&quot;#max&quot;&gt;maxに&lt;/a&gt;似ていますが、数値が最小のリストのエントリを返します。リストが空の場合、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="1acc3d00496e9a8972d2b21602c04ac03da5cacb" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#max&quot;&gt;max&lt;/a&gt;, but treats all the entries in the list as strings and returns the highest string as defined by the &lt;code&gt;gt&lt;/code&gt; operator. If the list is empty then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;a href=&quot;#max&quot;&gt;max&lt;/a&gt;に似ていますが、リスト内のすべてのエントリを文字列として扱い、 &lt;code&gt;gt&lt;/code&gt; 演算子で定義されている最上位の文字列を返します。リストが空の場合、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="cfb0f506a775b443c104de0b0c91306a78f551b3" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#min&quot;&gt;&quot;min&quot;&lt;/a&gt;, but treats all the entries in the list as strings and returns the lowest string as defined by the &lt;code&gt;lt&lt;/code&gt; operator. If the list is empty then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;a href=&quot;#min&quot;&gt;「min」に&lt;/a&gt;似ていますが、リスト内のすべてのエントリを文字列として扱い、 &lt;code&gt;lt&lt;/code&gt; 演算子で定義された最小の文字列を返します。リストが空の場合、 &lt;code&gt;undef&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="5a68b93abd1f3ba4015d6e167facf857ecad51b4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#min&quot;&gt;min&lt;/a&gt;, but treats all the entries in the list as strings and returns the lowest string as defined by the &lt;code&gt;lt&lt;/code&gt; operator. If the list is empty then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;a href=&quot;#min&quot;&gt;min&lt;/a&gt;に似ていますが、リスト内のすべてのエントリを文字列として扱い、 &lt;code&gt;lt&lt;/code&gt; 演算子で定義されている最小の文字列を返します。リストが空の場合、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="4ecb07a28c8b871910322942b1bd79e2ea6e867f" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#sum&quot;&gt;&quot;sum&quot;&lt;/a&gt;, except this returns 0 when given an empty list, rather than &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sum&quot;&gt;「sum」に&lt;/a&gt;似ていますが、 &lt;code&gt;undef&lt;/code&gt; ではなく空のリストが与えられたときに0を返す点が異なります。</target>
        </trans-unit>
        <trans-unit id="720744a95bf0e839c040c184fab6270aac42881d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#sum&quot;&gt;sum&lt;/a&gt;, except this returns 0 when given an empty list, rather than &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sum&quot;&gt;sum&lt;/a&gt;に似ていますが、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ではなく空のリストを指定すると0を返します。</target>
        </trans-unit>
        <trans-unit id="de0c5d81a8f59f78025d72fb656f559ed47e0b02" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;%+&lt;/code&gt; , this variable allows access to the named capture groups in the last successful match in the currently active dynamic scope. To each capture group name found in the regular expression, it associates a reference to an array containing the list of values captured by all buffers with that name (should there be several of them), in the order where they appear.</source>
          <target state="translated">&lt;code&gt;%+&lt;/code&gt; と同様に、この変数を使用すると、現在アクティブな動的スコープで最後に成功した一致の名前付きキャプチャグループにアクセスできます。正規表現で見つかった各キャプチャグループ名に対して、すべてのバッファーによってキャプチャされた値のリストを含む配列への参照を、その名前（複数ある場合）と、それらが出現する順序で関連付けます。</target>
        </trans-unit>
        <trans-unit id="fc5cb74e6a15c2726021f737c1b80fe548fe2cc2" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;%+&lt;/code&gt;, this variable allows access to the named capture groups in the last successful match in the currently active dynamic scope. To each capture group name found in the regular expression, it associates a reference to an array containing the list of values captured by all buffers with that name (should there be several of them), in the order where they appear.</source>
          <target state="translated">&lt;code&gt;%+&lt;/code&gt; と同様に、この変数を使用すると、現在アクティブな動的スコープで最後に成功した一致で指定されたキャプチャグループにアクセスできます。正規表現で見つかった各キャプチャグループ名に、すべてのバッファによってキャプチャされた値のリストを含む配列への参照を、表示されている順序でその名前（複数ある場合）に関連付けます。</target>
        </trans-unit>
        <trans-unit id="dc471f756f7e6a826fb6380627738dab038925d3" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;(??{ &lt;i&gt;code&lt;/i&gt; })&lt;/code&gt; except that it does not involve executing any code or potentially compiling a returned pattern string; instead it treats the part of the current pattern contained within a specified capture group as an independent pattern that must match at the current position. Also different is the treatment of capture buffers, unlike &lt;code&gt;(??{ &lt;i&gt;code&lt;/i&gt; })&lt;/code&gt; recursive patterns have access to their caller's match state, so one can use backreferences safely.</source>
          <target state="translated">&lt;code&gt;(??{ &lt;i&gt;code&lt;/i&gt; })&lt;/code&gt; と似ていますが、コードの実行や、返されたパターン文字列のコンパイルが含まれない点が異なります。代わりに、指定されたキャプチャグループに含まれる現在のパターンの一部を、現在の位置で一致する必要がある独立したパターンとして扱います。また、 &lt;code&gt;(??{ &lt;i&gt;code&lt;/i&gt; })&lt;/code&gt; 再帰パターンが呼び出し元の一致状態にアクセスできるのとは異なり、キャプチャバッファの処理も異なるため、後方参照を安全に使用できます。</target>
        </trans-unit>
        <trans-unit id="e85d1cf5a45c378c11b14a61c254003e40f86d06" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;(??{ code })&lt;/code&gt; except that it does not involve executing any code or potentially compiling a returned pattern string; instead it treats the part of the current pattern contained within a specified capture group as an independent pattern that must match at the current position. Also different is the treatment of capture buffers, unlike &lt;code&gt;(??{ code })&lt;/code&gt; recursive patterns have access to their callers match state, so one can use backreferences safely.</source>
          <target state="translated">&lt;code&gt;(??{ code })&lt;/code&gt; 似ていますが、コードの実行や、返されたパターン文字列のコンパイルの可能性はありません。代わりに、指定されたキャプチャグループに含まれる現在のパターンの一部を、現在の位置で一致する必要のある独立したパターンとして扱います。また、 &lt;code&gt;(??{ code })&lt;/code&gt; 再帰パターンが呼び出し元の一致状態にアクセスできるのとは異なり、キャプチャバッファーの扱いが異なるため、後方参照を安全に使用できます。</target>
        </trans-unit>
        <trans-unit id="7b5e1028f59af1e35880841b72d98eb83a4ac03c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;(R1)&lt;/code&gt; , this predicate checks to see if we're executing directly inside of the leftmost group with a given name (this is the same logic used by &lt;code&gt;(?&amp;amp;NAME)&lt;/code&gt; to disambiguate). It does not check the full stack, but only the name of the innermost active recursion.</source>
          <target state="translated">&lt;code&gt;(R1)&lt;/code&gt; と同様に、この述語は、指定された名前で左端のグループ内で直接実行されているかどうかを確認します（これは &lt;code&gt;(?&amp;amp;NAME)&lt;/code&gt; が明確にするために使用するのと同じロジックです）。完全なスタックはチェックせず、最も内側のアクティブな再帰の名前のみをチェックします。</target>
        </trans-unit>
        <trans-unit id="a58b4285d54a7974cddfaf2830c81dd7d35f40eb" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;(R1)&lt;/code&gt;, this predicate checks to see if we're executing directly inside of the leftmost group with a given name (this is the same logic used by &lt;code&gt;(?&amp;amp;&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; to disambiguate). It does not check the full stack, but only the name of the innermost active recursion. Full syntax: &lt;code&gt;(?(R&amp;amp;&lt;i&gt;name&lt;/i&gt;)&lt;i&gt;then&lt;/i&gt;|&lt;i&gt;else&lt;/i&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;(R1)&lt;/code&gt; と同様に、この述語は、指定された名前で左端のグループ内で直接実行されているかどうかを確認します（これは、 &lt;code&gt;(?&amp;amp;&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; が明確にするために使用するロジックと同じです）。スタック全体をチェックするのではなく、最も内側のアクティブな再帰の名前のみをチェックします。完全な構文： &lt;code&gt;(?(R&amp;amp;&lt;i&gt;name&lt;/i&gt;)&lt;i&gt;then&lt;/i&gt;|&lt;i&gt;else&lt;/i&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d819c8539b4d29d94e8d4689944b0f7272e6c433" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in that it evaluates &lt;code&gt;BLOCK&lt;/code&gt; setting &lt;code&gt;$_&lt;/code&gt; to each element of &lt;code&gt;@list&lt;/code&gt; in turn. &lt;code&gt;any&lt;/code&gt; returns true if any element makes the &lt;code&gt;BLOCK&lt;/code&gt; return a true value. If &lt;code&gt;BLOCK&lt;/code&gt; never returns true or &lt;code&gt;@list&lt;/code&gt; was empty then it returns false.</source>
          <target state="translated">同様に &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; することが評価されていることで &lt;code&gt;BLOCK&lt;/code&gt; を設定 &lt;code&gt;$_&lt;/code&gt; それぞれの要素に &lt;code&gt;@list&lt;/code&gt; ターンインチ &lt;code&gt;any&lt;/code&gt; かの要素が &lt;code&gt;BLOCK&lt;/code&gt; を true値に戻す場合、anyはtrueを返します。場合は &lt;code&gt;BLOCK&lt;/code&gt; trueを返すことはありませんか &lt;code&gt;@list&lt;/code&gt; は空だった、それは偽を返します。</target>
        </trans-unit>
        <trans-unit id="309f2e4aced8f70bc86983e34f644c5eeda43d60" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in that it evaluates &lt;code&gt;BLOCK&lt;/code&gt; setting &lt;code&gt;$_&lt;/code&gt; to each element of &lt;code&gt;@list&lt;/code&gt; in turn. &lt;code&gt;first&lt;/code&gt; returns the first element where the result from &lt;code&gt;BLOCK&lt;/code&gt; is a true value. If &lt;code&gt;BLOCK&lt;/code&gt; never returns true or &lt;code&gt;@list&lt;/code&gt; was empty then &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">同様に &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; することが評価されていることで &lt;code&gt;BLOCK&lt;/code&gt; を設定 &lt;code&gt;$_&lt;/code&gt; それぞれの要素に &lt;code&gt;@list&lt;/code&gt; ターンインチ &lt;code&gt;first&lt;/code&gt; リターンからの結果の最初の要素 &lt;code&gt;BLOCK&lt;/code&gt; 真の値です。場合は &lt;code&gt;BLOCK&lt;/code&gt; trueを返すことはありませんか &lt;code&gt;@list&lt;/code&gt; は空だった、その後 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="1e075f217be25d05567036ad66b6856b5e68b562" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;@+&lt;/code&gt; , the &lt;code&gt;%+&lt;/code&gt; hash allows access to the named capture buffers, should they exist, in the last successful match in the currently active dynamic scope.</source>
          <target state="translated">&lt;code&gt;@+&lt;/code&gt; と同様に、 &lt;code&gt;%+&lt;/code&gt; ハッシュを使用すると、現在アクティブな動的スコープで最後に成功した一致で、名前付きキャプチャバッファーにアクセスできます（存在する場合）。</target>
        </trans-unit>
        <trans-unit id="c20f7b2090b36afe2f8cc1a28252ce82895a9532" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;@+&lt;/code&gt;, the &lt;code&gt;%+&lt;/code&gt; hash allows access to the named capture buffers, should they exist, in the last successful match in the currently active dynamic scope.</source>
          <target state="translated">&lt;code&gt;@+&lt;/code&gt; と同様に、 &lt;code&gt;%+&lt;/code&gt; ハッシュは、現在アクティブな動的スコープで最後に成功した一致で、名前付きキャプチャバッファーが存在する場合、それらへのアクセスを許可します。</target>
        </trans-unit>
        <trans-unit id="a8d5383c2abb4219427283869f7f92149d2a972c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;Open&lt;/code&gt; , returns PerlIO* on success, &lt;code&gt;NULL&lt;/code&gt; on failure.</source>
          <target state="translated">&lt;code&gt;Open&lt;/code&gt; と同様に、成功した場合はPerlIO *を &lt;code&gt;NULL&lt;/code&gt; 、失敗した場合はNULLを返します。</target>
        </trans-unit>
        <trans-unit id="1de2fbefa7ee02f134e1d332ea00e119a6f12731" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;Open&lt;/code&gt;, returns PerlIO* on success, &lt;code&gt;NULL&lt;/code&gt; on failure.</source>
          <target state="translated">&lt;code&gt;Open&lt;/code&gt; と同様に、成功した場合はPerlIO *を &lt;code&gt;NULL&lt;/code&gt; 、失敗した場合はNULLを返します。</target>
        </trans-unit>
        <trans-unit id="9b9b990cdb77a226953210e003d5b8ec28f7e6d4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;eq_array()&lt;/code&gt; , except the order of the elements is &lt;b&gt;not&lt;/b&gt; important. This is a deep check, but the irrelevancy of order only applies to the top level.</source>
          <target state="translated">&lt;code&gt;eq_array()&lt;/code&gt; に似ていますが、要素の順序は重要ではあり&lt;b&gt;ません&lt;/b&gt;。これは詳細なチェックですが、順序の無関係性は最上位にのみ適用されます。</target>
        </trans-unit>
        <trans-unit id="c6f86f2d94dbcc71aafb977b9cc5434713d6b331" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;eq_array()&lt;/code&gt;, except the order of the elements is &lt;b&gt;not&lt;/b&gt; important. This is a deep check, but the irrelevancy of order only applies to the top level.</source>
          <target state="translated">要素の順序が重要で&lt;b&gt;ないこと&lt;/b&gt;を除いて、 &lt;code&gt;eq_array()&lt;/code&gt; と同様です。これは詳細なチェックですが、順序の無関係性はトップレベルにのみ適用されます。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3701740d1ad6bfc649e15fd040627ffd1f305bbb" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;grep&lt;/code&gt; in that it evaluates &lt;code&gt;BLOCK&lt;/code&gt; setting &lt;code&gt;$_&lt;/code&gt; to each element of &lt;code&gt;@list&lt;/code&gt; in turn. &lt;code&gt;any&lt;/code&gt; returns true if any element makes the &lt;code&gt;BLOCK&lt;/code&gt; return a true value. If &lt;code&gt;BLOCK&lt;/code&gt; never returns true or &lt;code&gt;@list&lt;/code&gt; was empty then it returns false.</source>
          <target state="translated">&lt;code&gt;@list&lt;/code&gt; の各要素に &lt;code&gt;$_&lt;/code&gt; を設定する &lt;code&gt;BLOCK&lt;/code&gt; を順番に評価するという点で &lt;code&gt;grep&lt;/code&gt; に似ています。 &lt;code&gt;any&lt;/code&gt; かの要素が &lt;code&gt;BLOCK&lt;/code&gt; にtrue値を返すようにすると、anyはtrueを返します。場合は &lt;code&gt;BLOCK&lt;/code&gt; trueを返すことはありませんか &lt;code&gt;@list&lt;/code&gt; は空だった、それは偽を返します。</target>
        </trans-unit>
        <trans-unit id="fbfbf42053ee4ef8969a4fa2ee7faff4e2fb6ee2" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;grep&lt;/code&gt; in that it evaluates &lt;code&gt;BLOCK&lt;/code&gt; setting &lt;code&gt;$_&lt;/code&gt; to each element of &lt;code&gt;@list&lt;/code&gt; in turn. &lt;code&gt;first&lt;/code&gt; returns the first element where the result from &lt;code&gt;BLOCK&lt;/code&gt; is a true value. If &lt;code&gt;BLOCK&lt;/code&gt; never returns true or &lt;code&gt;@list&lt;/code&gt; was empty then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;@list&lt;/code&gt; の各要素に &lt;code&gt;$_&lt;/code&gt; を設定する &lt;code&gt;BLOCK&lt;/code&gt; を順番に評価するという点で &lt;code&gt;grep&lt;/code&gt; に似ています。 &lt;code&gt;first&lt;/code&gt; は、 &lt;code&gt;BLOCK&lt;/code&gt; の結果が真の値である最初の要素を返します。場合は &lt;code&gt;BLOCK&lt;/code&gt; trueを返すことはありませんか &lt;code&gt;@list&lt;/code&gt; は空だった、その後 &lt;code&gt;undef&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="799cf1cf4afc49012909146223bfe3d0985a8027" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;htmlify()&lt;/code&gt; , but turns non-alphanumerics into underscores. Note that &lt;code&gt;anchorify()&lt;/code&gt; is not exported by default.</source>
          <target state="translated">&lt;code&gt;htmlify()&lt;/code&gt; に似ていますが、非英数字をアンダースコアに変換します。 &lt;code&gt;anchorify()&lt;/code&gt; はデフォルトではエクスポートされないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="c853c707bee9ff3b2aad37853128e372734e9e4d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;htmlify()&lt;/code&gt;, but turns non-alphanumerics into underscores. Note that &lt;code&gt;anchorify()&lt;/code&gt; is not exported by default.</source>
          <target state="translated">&lt;code&gt;htmlify()&lt;/code&gt; に似ていますが、英数字以外の文字をアンダースコアに変換します。デフォルトでは、 &lt;code&gt;anchorify()&lt;/code&gt; はエクスポートされないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="e12c5c9a9a0658e780b40222b20b1585f58ad997" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;is()&lt;/code&gt; , except that if $got and $expected are references, it does a deep comparison walking each data structure to see if they are equivalent. If the two structures are different, it will display the place where they start differing.</source>
          <target state="translated">&lt;code&gt;is()&lt;/code&gt; に似ていますが、$ gotと$ expectedが参照である場合は、各データ構造を詳細に比較して、同等かどうかを確認します。2つの構造が異なる場合は、構造が異なる場所が表示されます。</target>
        </trans-unit>
        <trans-unit id="5856aeb59fd6e40eddb32ad4b83e28afc3331a2a" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;is()&lt;/code&gt;, except that if $got and $expected are references, it does a deep comparison walking each data structure to see if they are equivalent. If the two structures are different, it will display the place where they start differing.</source>
          <target state="translated">&lt;code&gt;is()&lt;/code&gt; と似ていますが、$ gotと$ expectedが参照である場合、各データ構造を調べてそれらが同等であるかどうかを確認するために詳細な比較を行います。2つの構造が異なる場合は、それらが異なり始める場所が表示されます。</target>
        </trans-unit>
        <trans-unit id="78a60ea110d9d9e2f388b25322faf3b4d38a6a8c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;list&lt;/code&gt; but only active groups that match the pattern are returned. &lt;code&gt;PATTERN&lt;/code&gt; can be a group pattern.</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; 似ていますが、パターンに一致するアクティブなグループのみが返されます。 &lt;code&gt;PATTERN&lt;/code&gt; はグループパターンにすることができます。</target>
        </trans-unit>
        <trans-unit id="8394e4ee5f103a1c48fa6ce025d057e64f7170cc" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;lock_keys()&lt;/code&gt; , with the difference being that the optional key list specifies keys that may or may not be already in the hash. Essentially this is an easier way to say</source>
          <target state="translated">&lt;code&gt;lock_keys()&lt;/code&gt; に似ていますが、オプションのキーリストは、ハッシュにすでに存在するかどうかに関係なく、キーを指定する点が異なります。基本的に、これは簡単な言い方です</target>
        </trans-unit>
        <trans-unit id="fd28c174d303c48db24df8e8b11ae9ae4d26bc24" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;lock_keys()&lt;/code&gt;, with the difference being that the optional key list specifies keys that may or may not be already in the hash. Essentially this is an easier way to say</source>
          <target state="translated">&lt;code&gt;lock_keys()&lt;/code&gt; に似ていますが、オプションのキーリストが、ハッシュにすでに含まれている場合と含まれていない場合があるキーを指定する点が異なります。本質的にこれは言うのが簡単な方法です</target>
        </trans-unit>
        <trans-unit id="ffb0fd1c6610a16c5e7d118e0a5ba89092c8069d" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;newUNOP&lt;/code&gt; , but creates an UNOP_AUX struct instead, with op_aux initialised to aux</source>
          <target state="translated">&lt;code&gt;newUNOP&lt;/code&gt; に似ていますが、代わりにop_auxがauxに初期化されたUNOP_AUX構造体を作成します</target>
        </trans-unit>
        <trans-unit id="5e858708a27caba519590b6fdb8853664bd94dce" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;newUNOP&lt;/code&gt;, but creates an &lt;code&gt;UNOP_AUX&lt;/code&gt; struct instead, with &lt;code&gt;op_aux&lt;/code&gt; initialised to &lt;code&gt;aux&lt;/code&gt;</source>
          <target state="translated">同様に &lt;code&gt;newUNOP&lt;/code&gt; が、作成 &lt;code&gt;UNOP_AUX&lt;/code&gt; で、代わりに構造体を &lt;code&gt;op_aux&lt;/code&gt; に初期化 &lt;code&gt;aux&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc376b4266acbbeb8358039fda2afe78067b9523" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;ok()&lt;/code&gt; , &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; compare their two arguments with &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;ne&lt;/code&gt; respectively and use the result of that to determine if the test succeeded or failed. So these:</source>
          <target state="translated">&lt;code&gt;ok()&lt;/code&gt; と同様に、 &lt;code&gt;is()&lt;/code&gt; および &lt;code&gt;isnt()&lt;/code&gt; は、2つの引数をそれぞれ &lt;code&gt;eq&lt;/code&gt; および &lt;code&gt;ne&lt;/code&gt; と比較し、その結果を使用して、テストが成功したか失敗したかを判断します。したがって、これら：</target>
        </trans-unit>
        <trans-unit id="2d613f276bedf9458ff8ce32e8990c5576137f0b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;ok()&lt;/code&gt; , &lt;code&gt;like()&lt;/code&gt; matches $got against the regex &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/expected/&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ok()&lt;/code&gt; と同様に、 &lt;code&gt;like()&lt;/code&gt; は $ gotを正規表現 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/expected/&lt;/a&gt;&lt;/code&gt; と照合します。</target>
        </trans-unit>
        <trans-unit id="d80b81dd55578d43ab2dc56b52c4c8c56c375c2a" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;ok()&lt;/code&gt;, &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; compare their two arguments with &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;ne&lt;/code&gt; respectively and use the result of that to determine if the test succeeded or failed. So these:</source>
          <target state="translated">&lt;code&gt;ok()&lt;/code&gt; と同様に、 &lt;code&gt;is()&lt;/code&gt; と &lt;code&gt;isnt()&lt;/code&gt; は、2つの引数をそれぞれ &lt;code&gt;eq&lt;/code&gt; と &lt;code&gt;ne&lt;/code&gt; と比較し、その結果を使用して、テストが成功したか失敗したかを判断します。だからこれら：</target>
        </trans-unit>
        <trans-unit id="b38f30f4277690cf45428e116cea438e779a9819" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;ok()&lt;/code&gt;, &lt;code&gt;like()&lt;/code&gt; matches $got against the regex &lt;code&gt;qr/expected/&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ok()&lt;/code&gt; と同様に、 &lt;code&gt;like()&lt;/code&gt; は$ gotを正規表現 &lt;code&gt;qr/expected/&lt;/code&gt; と照合します。</target>
        </trans-unit>
        <trans-unit id="6f443cdf5d4202dff7105c24c5a2b89e3df5ba0b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;reduce&lt;/code&gt; except that it also returns the intermediate values along with the final result. As before, &lt;code&gt;$a&lt;/code&gt; is set to the first element of the given list, and the &lt;code&gt;BLOCK&lt;/code&gt; is then called once for remaining item in the list set into &lt;code&gt;$b&lt;/code&gt;, with the result being captured for return as well as becoming the new value for &lt;code&gt;$a&lt;/code&gt;.</source>
          <target state="translated">最終結果とともに中間値も返す &lt;code&gt;reduce&lt;/code&gt; を除いて、reduceと同様です。前と同じように、 &lt;code&gt;$a&lt;/code&gt; は指定されたリストの最初の要素に設定され、 &lt;code&gt;BLOCK&lt;/code&gt; は、 &lt;code&gt;$b&lt;/code&gt; に設定されたリスト内の残りのアイテムに対して一度呼び出され、結果は戻り値としてキャプチャされ、 &lt;code&gt;$a&lt;/code&gt; 新しい値になります。A。</target>
        </trans-unit>
        <trans-unit id="050d8bfd9d6dd81a6f8789b0e8d9cd7b8f6780b4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_scalar&lt;/code&gt; , but localize &lt;code&gt;@gv&lt;/code&gt; and &lt;code&gt;%gv&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;save_scalar&lt;/code&gt; に似ていますが、 &lt;code&gt;@gv&lt;/code&gt; &lt;code&gt;%gv&lt;/code&gt; と％gvをローカライズします。</target>
        </trans-unit>
        <trans-unit id="07501a6bba290a81025a9cc58f969fd7da78b384" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_scalar&lt;/code&gt; , but will reinstate an &lt;code&gt;SV *&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;save_scalar&lt;/code&gt; に似ていますが、 &lt;code&gt;SV *&lt;/code&gt; を復元します。</target>
        </trans-unit>
        <trans-unit id="657ba45f71ac8c697cb507869c08178c868c5018" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_scalar&lt;/code&gt;, but localize &lt;code&gt;@gv&lt;/code&gt; and &lt;code&gt;%gv&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;save_scalar&lt;/code&gt; に似ていますが、 &lt;code&gt;@gv&lt;/code&gt; &lt;code&gt;%gv&lt;/code&gt; と％gvをローカライズします。</target>
        </trans-unit>
        <trans-unit id="3fd7eb38494553782c4863edc348cc1335774a8b" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_scalar&lt;/code&gt;, but will reinstate an &lt;code&gt;SV *&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;save_scalar&lt;/code&gt; に似ていますが、 &lt;code&gt;SV *&lt;/code&gt; を復元します。</target>
        </trans-unit>
        <trans-unit id="d1390e677f6a0ebeb104aa1d188d2523b30d8bc4" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_svref&lt;/code&gt; , but localize &lt;code&gt;AV *&lt;/code&gt; and &lt;code&gt;HV *&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;save_svref&lt;/code&gt; に似ていますが、 &lt;code&gt;AV *&lt;/code&gt; および &lt;code&gt;HV *&lt;/code&gt; をローカライズします。</target>
        </trans-unit>
        <trans-unit id="4f3780c5e475fc5db102e3fd087d1848086a6f08" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;save_svref&lt;/code&gt;, but localize &lt;code&gt;AV *&lt;/code&gt; and &lt;code&gt;HV *&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;save_svref&lt;/code&gt; に似ていますが、 &lt;code&gt;AV *&lt;/code&gt; と &lt;code&gt;HV *&lt;/code&gt; をローカライズします。</target>
        </trans-unit>
        <trans-unit id="cdee7e1885c1d2ec3f4e4850b44e46e9ebce62cc" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;unlink0&lt;/code&gt; except after file comparison using cmpstat, the filehandle is closed prior to attempting to unlink the file. This allows the file to be removed without using an END block, but does mean that the post-unlink comparison of the filehandle state provided by &lt;code&gt;unlink0&lt;/code&gt; is not available.</source>
          <target state="translated">&lt;code&gt;unlink0&lt;/code&gt; を使用してファイルを比較した後を除いて、unlink0と同様に、ファイルのリンクを解除する前にファイルハンドルが閉じられます。これにより、ENDブロックを使用せずにファイルを削除できますが、 &lt;code&gt;unlink0&lt;/code&gt; によって提供されるファイルハンドル状態のリンク解除後の比較が利用できないことを意味します。</target>
        </trans-unit>
        <trans-unit id="7cf1c2a19f0b0ee74a54bd214a8ec4d84f8e3cf9" translate="yes" xml:space="preserve">
          <source>Similar to C</source>
          <target state="translated">Cに似ている</target>
        </trans-unit>
        <trans-unit id="a64ea60affb2a9690ec81f413108d64202543e9b" translate="yes" xml:space="preserve">
          <source>Similar to T_PTR except that the pointer is stored in a scalar and the reference to that scalar is returned to the caller. This can be used to hide the actual pointer value from the programmer since it is usually not required directly from within perl.</source>
          <target state="translated">ポインタがスカラに格納され、そのスカラへの参照が呼び出し元に返される点を除けば、T_PTRと似ています。これは、実際のポインタの値をプログラマーから隠すために使用することができます。</target>
        </trans-unit>
        <trans-unit id="4ed1b14b67aa9193491a3dd6d65f8409d185456b" translate="yes" xml:space="preserve">
          <source>Similar to T_PTROBJ in that the pointer is blessed into a scalar object. The difference is that when the object is passed back into XS it must be of the correct type (inheritance is not supported) while T_PTROBJ supports inheritance.</source>
          <target state="translated">T_PTROBJと似ていますが、ポインタがスカラーオブジェクトに変換されます。T_PTROBJが継承をサポートしているのに対し、XSにオブジェクトを戻す際には正しい型でなければなりません(継承はサポートされていません)。</target>
        </trans-unit>
        <trans-unit id="98345bece5539f546d5a8e96d6aece125a75354c" translate="yes" xml:space="preserve">
          <source>Similar to T_PTRREF except that the reference is blessed into a class. This allows the pointer to be used as an object. Most commonly used to deal with C structs. The typemap checks that the perl object passed into the XS routine is of the correct class (or part of a subclass).</source>
          <target state="translated">参照がクラスに祝福されることを除いて、T_PTRREFと似ています。これにより、ポインタをオブジェクトとして使用することができます。最も一般的にはC言語の構造体を扱うのに使われます。タイプマップは、XSルーチンに渡されたperlオブジェクトが正しいクラス(またはサブクラスの一部)であるかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="a0e3f786e5320b6b926d5843480fabad22b49df4" translate="yes" xml:space="preserve">
          <source>Similar to T_PTRREF, except the pointer stored in the referenced scalar is dereferenced and copied to the output variable. This means that T_REFREF is to T_PTRREF as T_OPAQUE is to T_OPAQUEPTR. All clear?</source>
          <target state="translated">T_PTRREFと似ていますが、参照されたスカラに格納されているポインタが参照解除され、出力変数にコピーされることを除いては、T_PTRREFと似ています。これは、T_OPAQUEがT_OPAQUEPTRにあるように、T_REFREFはT_PTRREFにあることを意味します。これでいいですか?</target>
        </trans-unit>
        <trans-unit id="316a66a038c9003e3588353dd7b06b4570041574" translate="yes" xml:space="preserve">
          <source>Similar to key/value hash slices (and also introduced in Perl 5.20), the % array slice syntax returns a list of index/value pairs:</source>
          <target state="translated">キー/値のハッシュ・スライス (Perl 5.20 で導入された)と同様に、% 配列スライス構文は、インデックス/値のペアのリストを返します。</target>
        </trans-unit>
        <trans-unit id="fcdb3335ff45dd421a45fea8e6567734b9ec0cac" translate="yes" xml:space="preserve">
          <source>Similar to mkstemp(), except that an extra argument can be supplied with a suffix to be appended to the template.</source>
          <target state="translated">mkstemp()と似ていますが、追加の引数にテンプレートに追加するサフィックスを与えることができます。</target>
        </trans-unit>
        <trans-unit id="4cf9bfb3c81fe1275534c974c84d67c5db310bda" translate="yes" xml:space="preserve">
          <source>Similar to perl's &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; keyword, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in scalar context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt; .</source>
          <target state="translated">perlの &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; キーワードに似ていますが、指定されたリストを偶数サイズのペアのリストとして解釈します。 &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; が &lt;code&gt;@kvlist&lt;/code&gt; からの値の連続するペアに設定された状態で、スカラーコンテキストで &lt;code&gt;BLOCK&lt;/code&gt; を複数回呼び出します。</target>
        </trans-unit>
        <trans-unit id="20605e6412e378f2426dfa2ecf790a73c30912ee" translate="yes" xml:space="preserve">
          <source>Similar to perl's &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; keyword, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in list context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt; .</source>
          <target state="translated">perlの &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; キーワードに似ていますが、指定されたリストを偶数サイズのペアのリストとして解釈します。 &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; が &lt;code&gt;@kvlist&lt;/code&gt; からの値の連続するペアに設定された状態で、リストコンテキストで &lt;code&gt;BLOCK&lt;/code&gt; を複数回呼び出します。</target>
        </trans-unit>
        <trans-unit id="c8dc38a4899c208d20a94f1397e679f06553d540" translate="yes" xml:space="preserve">
          <source>Similar to perl's &lt;code&gt;grep&lt;/code&gt; keyword, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in scalar context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt;.</source>
          <target state="translated">perlの &lt;code&gt;grep&lt;/code&gt; キーワードに似ていますが、指定されたリストを偶数サイズのペアのリストとして解釈します。これは、呼び出し &lt;code&gt;BLOCK&lt;/code&gt; で、スカラーコンテキストで複数回、 &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; からの値の連続したペアに設定さ &lt;code&gt;@kvlist&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6971d89c696879a9eeb673adbf4f23a22af252ce" translate="yes" xml:space="preserve">
          <source>Similar to perl's &lt;code&gt;map&lt;/code&gt; keyword, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in list context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt;.</source>
          <target state="translated">perlの &lt;code&gt;map&lt;/code&gt; キーワードに似ていますが、指定されたリストを偶数サイズのペアのリストとして解釈します。これは、呼び出し &lt;code&gt;BLOCK&lt;/code&gt; で、リストコンテキストでは、複数回 &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; からの値の連続したペアに設定さ &lt;code&gt;@kvlist&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4e0979e74abc467bf78f9a39fbc983727e9baaf" translate="yes" xml:space="preserve">
          <source>Similar to strings, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt; acts like apostrophes on a regexp; all other &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; delimiters act like quotes. If the regexp evaluates to the empty string, the regexp in the</source>
          <target state="translated">文字列と同様に、 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m''&lt;/a&gt;&lt;/code&gt; は正規表現ではアポストロフィのように機能します。他のすべての &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 区切り文字は引用符のように機能します。正規表現が空の文字列に評価される場合、</target>
        </trans-unit>
        <trans-unit id="19b88f89de77da98af72b4163220db2f0a7c8ecd" translate="yes" xml:space="preserve">
          <source>Similar to strings, &lt;code&gt;m''&lt;/code&gt; acts like apostrophes on a regexp; all other &lt;code&gt;'m'&lt;/code&gt; delimiters act like quotes. If the regexp evaluates to the empty string, the regexp in the</source>
          <target state="translated">文字列と同様に、 &lt;code&gt;m''&lt;/code&gt; は正規表現のアポストロフィのように機能します。他 &lt;code&gt;'m'&lt;/code&gt; すべての「m」区切り文字は引用符のように機能します。正規表現が空の文字列に評価される場合、</target>
        </trans-unit>
        <trans-unit id="a82cc003c44f0253412b5190a2e4c975c854a684" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#first&quot;&gt;&quot;first&quot;&lt;/a&gt; function, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in scalar context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#first&quot;&gt;「最初の」&lt;/a&gt;関数に似ていますが、指定されたリストを偶数サイズのペアのリストとして解釈します。これは、呼び出し &lt;code&gt;BLOCK&lt;/code&gt; で、スカラーコンテキストで複数回、 &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; からの値の連続したペアに設定さ &lt;code&gt;@kvlist&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7ef33d2521670adf2f6b3cf61cae1999ab3778c" translate="yes" xml:space="preserve">
          <source>Similar to the &lt;a href=&quot;#first&quot;&gt;first&lt;/a&gt; function, but interprets the given list as an even-sized list of pairs. It invokes the &lt;code&gt;BLOCK&lt;/code&gt; multiple times, in scalar context, with &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; set to successive pairs of values from the &lt;code&gt;@kvlist&lt;/code&gt; .</source>
          <target state="translated">&lt;a href=&quot;#first&quot;&gt;最初の&lt;/a&gt;関数に似ていますが、指定されたリストを偶数サイズのペアのリストとして解釈します。 &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; が &lt;code&gt;@kvlist&lt;/code&gt; からの値の連続するペアに設定された状態で、スカラーコンテキストで &lt;code&gt;BLOCK&lt;/code&gt; を複数回呼び出します。</target>
        </trans-unit>
        <trans-unit id="f852487d7b194c670f738b8370d3735ea507b49e" translate="yes" xml:space="preserve">
          <source>Similar to the above, a sigil, followed by bareword text in braces, where the first character is a caret. The next character is any one of the characters &lt;code&gt;[][A-Z^_?\]&lt;/code&gt;, followed by ASCII word characters. An example is &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt;.</source>
          <target state="translated">上記と同様に、印章の後に中括弧で囲まれた裸のテキストが続きます。最初の文字はキャレットです。次の文字は、 &lt;code&gt;[][A-Z^_?\]&lt;/code&gt; いずれかの文字で、その後にASCII単語文字が続きます。例は &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="0747626402d2dd7f7c45b97cc24e9304db46b6d7" translate="yes" xml:space="preserve">
          <source>Similar to the above, a sigil, followed by bareword text in brackets, where the first character is either a caret followed by an uppercase letter, like &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; or a non-&lt;code&gt;NUL&lt;/code&gt; , non-space literal control like &lt;code&gt;${\7LOBAL_PHASE}&lt;/code&gt; . Like the above, when not under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; , the characters in &lt;code&gt;[0x80-0xFF]&lt;/code&gt; are considered controls, but as of v5.22, the use of any that are non-graphical are deprecated, and as of v5.20 the use of any ASCII-range literal control is deprecated. Support for these will be removed in a future version of perl.</source>
          <target state="translated">上記と同様に、シギル、その後にかっこ内の裸語テキストが続きます。最初の文字は、キャレットの後に &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; ような大文字が続くか、 &lt;code&gt;${\7LOBAL_PHASE}&lt;/code&gt; ような非 &lt;code&gt;NUL&lt;/code&gt; の非スペースリテラルコントロールです。7LOBAL_PHASE}。上記と同様に、 &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; 下にない場合、 &lt;code&gt;[0x80-0xFF]&lt;/code&gt; の文字はコントロールと見なされますが、v5.22以降では、非グラフィカルな文字の使用は非推奨になり、v5.20以降ではASCII範囲のリテラルコントロールの使用は非推奨です。これらのサポートは、将来のバージョンのperlで削除される予定です。</target>
        </trans-unit>
        <trans-unit id="668df669d9efbd5ecee333d1f8978a303dbbc797" translate="yes" xml:space="preserve">
          <source>Similar to try, except that it does not catch exceptions. The idea here is to protect $@ and $! from changes. $@ and $! will be restored to whatever they were before the run so long as it is successful. If the run fails $! will still be restored, but $@ will contain the exception being thrown.</source>
          <target state="translated">tryと似ていますが、例外をキャッチしないことを除けば、例外をキャッチすることはできません。ここでの考えは、$@と$!を変更から守ることです。と $! は、実行が成功している限り、実行前の状態に復元されます。実行に失敗した場合でも $! は復元されますが、$@ にはスローされた例外が含まれます。</target>
        </trans-unit>
        <trans-unit id="21000b274c1010d95d46737a373e917805b17d88" translate="yes" xml:space="preserve">
          <source>Similar to:</source>
          <target state="translated">似ています。</target>
        </trans-unit>
        <trans-unit id="3f2112c220c2b71523b70f673d7ec4dcde3c15e0" translate="yes" xml:space="preserve">
          <source>Similarly &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'Debug'&lt;/code&gt; produces debugging output, the difference being that it allows the fine tuning of what debugging output will be emitted. Options are divided into three groups, those related to compilation, those related to execution and those related to special purposes. The options are as follows:</source>
          <target state="translated">同様に &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'Debug'&lt;/code&gt; を使用すると、デバッグ出力が生成されます。違いは、出力されるデバッグ出力を微調整できることです。オプションは、コンパイルに関連するもの、実行に関連するもの、特別な目的に関連するものの3つのグループに分類されます。オプションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c569ec67d5806423bac1b597854e2fd9a9cd8f16" translate="yes" xml:space="preserve">
          <source>Similarly &lt;code&gt;use re 'Debug'&lt;/code&gt; produces debugging output, the difference being that it allows the fine tuning of what debugging output will be emitted. Options are divided into three groups, those related to compilation, those related to execution and those related to special purposes. The options are as follows:</source>
          <target state="translated">同様に、 &lt;code&gt;use re 'Debug'&lt;/code&gt; を使用すると、デバッグ出力が生成されますが、違いは、出力されるデバッグ出力を微調整できることです。オプションは、コンパイルに関連するもの、実行に関連するもの、および特別な目的に関連するものの3つのグループに分けられます。オプションは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="84d106c3869ea4929caecddf63406cc3cb977903" translate="yes" xml:space="preserve">
          <source>Similarly all warnings are disabled in a block by either of these:</source>
          <target state="translated">同様に、これらのいずれかによってブロック内のすべての警告が無効化されます。</target>
        </trans-unit>
        <trans-unit id="55dea1c41dc940323d881fe12ebce9ec69c591cf" translate="yes" xml:space="preserve">
          <source>Similarly if you opened that handle &lt;code&gt;FH&lt;/code&gt; with regular &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, you may use:</source>
          <target state="translated">同様に、 &lt;code&gt;FH&lt;/code&gt; ハンドルを通常の &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;../functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; で開いた場合、以下を使用できます。</target>
        </trans-unit>
        <trans-unit id="64831f5e93834f6bf428903e01c563e7e7bece53" translate="yes" xml:space="preserve">
          <source>Similarly if you opened that handle &lt;code&gt;FH&lt;/code&gt; with regular &lt;code&gt;open&lt;/code&gt; or &lt;code&gt;sysopen&lt;/code&gt;, you may use:</source>
          <target state="translated">同様に、通常の &lt;code&gt;open&lt;/code&gt; または &lt;code&gt;sysopen&lt;/code&gt; で &lt;code&gt;FH&lt;/code&gt; を処理するものを開いた場合は、次を使用できます。</target>
        </trans-unit>
        <trans-unit id="53be67a31768325e220272f535bb98f85e3fcddf" translate="yes" xml:space="preserve">
          <source>Similarly one could take the output of the third numbers column from recipe 2 to obtain a &lt;code&gt;$cp_1047&lt;/code&gt; table. The fourth numbers column of the output from recipe 2 could provide a &lt;code&gt;$cp_posix_bc&lt;/code&gt; table suitable for transcoding as well.</source>
          <target state="translated">同様に、レシピ2から3番目の数値列の出力を取得して、 &lt;code&gt;$cp_1047&lt;/code&gt; テーブルを取得できます。レシピ2の出力の4番目の数値列は、トランスコーディングにも適した &lt;code&gt;$cp_posix_bc&lt;/code&gt; テーブルを提供します。</target>
        </trans-unit>
        <trans-unit id="d0f4815a422eaba46c3d84f219793b24d2375a6b" translate="yes" xml:space="preserve">
          <source>Similarly the NULL needs to be taken into account when you are considering the length of existing keys/values.</source>
          <target state="translated">同様に、既存のキー/値の長さを考慮する際にはNULLを考慮する必要があります。</target>
        </trans-unit>
        <trans-unit id="15d5ffcdd52f893f6f74efb6a4803895765d4c4b" translate="yes" xml:space="preserve">
          <source>Similarly the name &quot;WinWin32s&quot; should have been &quot;Win32s&quot; but has been kept as-is for backwards compatibility reasons too.</source>
          <target state="translated">同様に、&quot;WinWin32s &quot;という名前は &quot;Win32s &quot;であるべきでしたが、下位互換性のためにそのままになっています。</target>
        </trans-unit>
        <trans-unit id="b052290a572fb153a5a7598b50b12efdb7ef549e" translate="yes" xml:space="preserve">
          <source>Similarly unclear is what should be generated when the &lt;code&gt;\N{...}&lt;/code&gt; is used as one of the end points of the range, such as in</source>
          <target state="translated">同様に、 &lt;code&gt;\N{...}&lt;/code&gt; が範囲のエンドポイントの1つとして使用された場合に何が生成されるかは、次のように不明確です。</target>
        </trans-unit>
        <trans-unit id="04230c63a76d30ed5b83266e25e001a24b4eb855" translate="yes" xml:space="preserve">
          <source>Similarly with the one-shot interface, if the input is a buffer larger than 4 Gig, a zip64 complaint zip file will be created.</source>
          <target state="translated">ワンショットインターフェースと同様に、入力が4Gig以上のバッファであれば、ZIP64のクレームZIPファイルが作成されます。</target>
        </trans-unit>
        <trans-unit id="b4baed99da5d9cf308161bde5e8cc00af2ab9d79" translate="yes" xml:space="preserve">
          <source>Similarly you can build in parallel with GNU make, type &quot;gmake -j2&quot; to build with two parallel jobs, or higher for more.</source>
          <target state="translated">同様に、GNU makeを使って並列にビルドすることもできます。</target>
        </trans-unit>
        <trans-unit id="cc4fb6a726563143c1c04086d201d673d7729dd3" translate="yes" xml:space="preserve">
          <source>Similarly,</source>
          <target state="translated">Similarly,</target>
        </trans-unit>
        <trans-unit id="90864fd67d3db4c105028d84006c631220f52597" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;$href-&amp;gt;{'red'}&lt;/code&gt; is part of the hash referred to by the scalar variable &lt;code&gt;$href&lt;/code&gt; , perhaps even one with no name. &lt;code&gt;$href{'red'}&lt;/code&gt; is part of the deceptively named &lt;code&gt;%href&lt;/code&gt; hash. It's easy to forget to leave out the &lt;code&gt;-&amp;gt;&lt;/code&gt; , and if you do, you'll get bizarre results when your program gets array and hash elements out of totally unexpected hashes and arrays that weren't the ones you wanted to use.</source>
          <target state="translated">同様に、 &lt;code&gt;$href-&amp;gt;{'red'}&lt;/code&gt; は、スカラー変数 &lt;code&gt;$href&lt;/code&gt; によって参照されるハッシュの一部であり、おそらく名前のないものです。 &lt;code&gt;$href{'red'}&lt;/code&gt; は、一見して名前が付けられた &lt;code&gt;%href&lt;/code&gt; ハッシュの一部です。 &lt;code&gt;-&amp;gt;&lt;/code&gt; を省略することは忘れがちですが、省略した場合、プログラムが想定外のハッシュや配列から、意図したものではなかった配列やハッシュ要素を取得したときに、奇妙な結果が得られます。</target>
        </trans-unit>
        <trans-unit id="b70d4728a23b61603feac7dca92ea80423288fd3" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;$href-&amp;gt;{'red'}&lt;/code&gt; is part of the hash referred to by the scalar variable &lt;code&gt;$href&lt;/code&gt;, perhaps even one with no name. &lt;code&gt;$href{'red'}&lt;/code&gt; is part of the deceptively named &lt;code&gt;%href&lt;/code&gt; hash. It's easy to forget to leave out the &lt;code&gt;-&amp;gt;&lt;/code&gt;, and if you do, you'll get bizarre results when your program gets array and hash elements out of totally unexpected hashes and arrays that weren't the ones you wanted to use.</source>
          <target state="translated">同様に、 &lt;code&gt;$href-&amp;gt;{'red'}&lt;/code&gt; は、スカラー変数 &lt;code&gt;$href&lt;/code&gt; によって参照されるハッシュの一部であり、おそらく名前のないものですらあります。 &lt;code&gt;$href{'red'}&lt;/code&gt; は、一見名前が付けられた &lt;code&gt;%href&lt;/code&gt; ハッシュの一部です。 &lt;code&gt;-&amp;gt;&lt;/code&gt; を省略するのを忘れがちです。そうすると、プログラムが、使用したいものではなかったまったく予期しないハッシュと配列から配列とハッシュ要素を取得したときに、奇妙な結果が得られます。</target>
        </trans-unit>
        <trans-unit id="4d9f2629494d34ddc3413b1763638df2e3855408" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;-&amp;gt;autodefer(1)&lt;/code&gt; re-enables autodeferment, and &lt;code&gt;-&amp;gt;autodefer()&lt;/code&gt; recovers the current value of the autodefer setting.</source>
          <target state="translated">同様に、 &lt;code&gt;-&amp;gt;autodefer(1)&lt;/code&gt; はautodefermentを再度有効にし、 &lt;code&gt;-&amp;gt;autodefer()&lt;/code&gt; はautodefer設定の現在の値を回復します。</target>
        </trans-unit>
        <trans-unit id="ed0a74921b522c90d239c941839d98f9f544df9e" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;.=&lt;/code&gt; and &lt;code&gt;x=&lt;/code&gt; operators lose their mathemagical properties if the string conversion substitution is applied.</source>
          <target state="translated">同様に、文字列変換置換が適用されると、 &lt;code&gt;.=&lt;/code&gt; および &lt;code&gt;x=&lt;/code&gt; 演算子は数学的なプロパティを失います。</target>
        </trans-unit>
        <trans-unit id="98381cd292cecc23499c5a97dc7663476a411916" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic can be used much like tie() to call a C function any time a scalar's value is used or changed. The &lt;code&gt;MAGIC&lt;/code&gt; 's &lt;code&gt;mg_ptr&lt;/code&gt; field points to a &lt;code&gt;ufuncs&lt;/code&gt; structure:</source>
          <target state="translated">同様に、 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; マジックはC関数スカラーの値が使用されるか、または変更されるたびに呼び出すために）多くのタイ（同様に使用することができます。 &lt;code&gt;MAGIC&lt;/code&gt; さん &lt;code&gt;mg_ptr&lt;/code&gt; に視野点 &lt;code&gt;ufuncs&lt;/code&gt; の構造：</target>
        </trans-unit>
        <trans-unit id="dd56bf6157ee2e5e27ea1785ce7250db948cb17e" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic can be used much like tie() to call a C function any time a scalar's value is used or changed. The &lt;code&gt;MAGIC&lt;/code&gt;'s &lt;code&gt;mg_ptr&lt;/code&gt; field points to a &lt;code&gt;ufuncs&lt;/code&gt; structure:</source>
          <target state="translated">同様に、 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; マジックは、スカラーの値が使用または変更されるたびにC関数を呼び出すためにtie（）のように使用できます。 &lt;code&gt;MAGIC&lt;/code&gt; さん &lt;code&gt;mg_ptr&lt;/code&gt; に視野点 &lt;code&gt;ufuncs&lt;/code&gt; の構造：</target>
        </trans-unit>
        <trans-unit id="084028b0095b78ad708b249b88f8a8326808bba4" translate="yes" xml:space="preserve">
          <source>Similarly, &lt;code&gt;\x&lt;i&gt;nn&lt;/i&gt;&lt;/code&gt;, where</source>
          <target state="translated">同様に、 &lt;code&gt;\x&lt;i&gt;nn&lt;/i&gt;&lt;/code&gt; 、ここで</target>
        </trans-unit>
        <trans-unit id="e1434bb43847966624ccbd7c82a8d888d8931593" translate="yes" xml:space="preserve">
          <source>Similarly, Perl's built-in &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; function treats a reference to a blessed object specially. If you call &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref($thing)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;$thing&lt;/code&gt; holds a reference to an object, it will return the name of the class that the object has been blessed into.</source>
          <target state="translated">同様に、Perlの組み込み &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 関数は、祝福されたオブジェクトへの参照を特別に扱います。 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref($thing)&lt;/a&gt;&lt;/code&gt; を呼び出し、 &lt;code&gt;$thing&lt;/code&gt; がオブジェクトへの参照を保持している場合、オブジェクトがblessされたクラスの名前を返します。</target>
        </trans-unit>
        <trans-unit id="3c79bdba87881c1ec05393b4d27a2c965c79a1a5" translate="yes" xml:space="preserve">
          <source>Similarly, Perl's built-in &lt;code&gt;ref&lt;/code&gt; function treats a reference to a blessed object specially. If you call &lt;code&gt;ref($thing)&lt;/code&gt; and &lt;code&gt;$thing&lt;/code&gt; holds a reference to an object, it will return the name of the class that the object has been blessed into.</source>
          <target state="translated">同様に、Perlの組み込み &lt;code&gt;ref&lt;/code&gt; 関数は、祝福されたオブジェクトへの参照を特別に扱います。あなたが呼び出す場合 &lt;code&gt;ref($thing)&lt;/code&gt; と &lt;code&gt;$thing&lt;/code&gt; オブジェクトへの参照を保持し、それは、オブジェクトがに恵まれていることを、クラスの名前を返します。</target>
        </trans-unit>
        <trans-unit id="ed57441510534192d07967fc62d33e33379b4e80" translate="yes" xml:space="preserve">
          <source>Similarly, a list assignment in list context produces the list of lvalues assigned to, and a list assignment in scalar context returns the number of elements produced by the expression on the right hand side of the assignment.</source>
          <target state="translated">同様に、リストコンテキストでのリスト代入は、代入されたl値のリストを生成し、スカラコンテキストでのリスト代入は、代入の右側の式によって生成された要素の数を返します。</target>
        </trans-unit>
        <trans-unit id="105351b9ff1ce0c3b0da126c3158372b6f241c09" translate="yes" xml:space="preserve">
          <source>Similarly, a value assigned to &lt;code&gt;$)&lt;/code&gt; must also be a space-separated list of numbers. The first number sets the effective gid, and the rest (if any) are passed to &lt;code&gt;setgroups()&lt;/code&gt; . To get the effect of an empty list for &lt;code&gt;setgroups()&lt;/code&gt; , just repeat the new effective gid; that is, to force an effective gid of 5 and an effectively empty &lt;code&gt;setgroups()&lt;/code&gt; list, say &lt;code&gt; $) = &quot;5 5&quot; &lt;/code&gt; .</source>
          <target state="translated">同様に、 &lt;code&gt;$)&lt;/code&gt; に割り当てられる値も、スペースで区切られた数値のリストでなければなりません。最初の数は有効なgidを設定し、残りは（もしあれば） &lt;code&gt;setgroups()&lt;/code&gt; に渡されます。 &lt;code&gt;setgroups()&lt;/code&gt; の空のリストの効果を取得するには、新しい有効なgidを繰り返します。つまり、有効なgidを5に、効果的に空の &lt;code&gt;setgroups()&lt;/code&gt; リストを強制するには、 &lt;code&gt; $) = &quot;5 5&quot; &lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="a9bfb808fae3d4ef85e01abecf018c96a424092b" translate="yes" xml:space="preserve">
          <source>Similarly, a value assigned to &lt;code&gt;$)&lt;/code&gt; must also be a space-separated list of numbers. The first number sets the effective gid, and the rest (if any) are passed to &lt;code&gt;setgroups()&lt;/code&gt;. To get the effect of an empty list for &lt;code&gt;setgroups()&lt;/code&gt;, just repeat the new effective gid; that is, to force an effective gid of 5 and an effectively empty &lt;code&gt;setgroups()&lt;/code&gt; list, say &lt;code&gt; $) = &quot;5 5&quot; &lt;/code&gt;.</source>
          <target state="translated">同様に、 &lt;code&gt;$)&lt;/code&gt; に割り当てられる値も、スペースで区切られた数値のリストである必要があります。最初の数値は有効なgidを設定し、残り（存在する場合）は &lt;code&gt;setgroups()&lt;/code&gt; に渡されます。 &lt;code&gt;setgroups()&lt;/code&gt; の空のリストの効果を得るには、新しい有効なgidを繰り返すだけです。つまり、5の有効なgidと実質的に空の &lt;code&gt;setgroups()&lt;/code&gt; リストを強制するには、 &lt;code&gt; $) = &quot;5 5&quot; &lt;/code&gt; 55 &quot;と言います。</target>
        </trans-unit>
        <trans-unit id="f830d9f2bf12f89de4edd3497ea1af8e153890fe" translate="yes" xml:space="preserve">
          <source>Similarly, an expression that returns a reference to a scalar can be dereferenced via &lt;code&gt;${...}&lt;/code&gt; . Thus, the above expression may be written as:</source>
          <target state="translated">同様に、スカラーへの参照を返す式は、 &lt;code&gt;${...}&lt;/code&gt; 介して逆参照できます。したがって、上記の式は次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="6c0225a1fecb24141de2c67cfa637dd7b4544c6f" translate="yes" xml:space="preserve">
          <source>Similarly, an expression that returns a reference to a scalar can be dereferenced via &lt;code&gt;${...}&lt;/code&gt;. Thus, the above expression may be written as:</source>
          <target state="translated">同様に、スカラーへの参照を返す式は、 &lt;code&gt;${...}&lt;/code&gt; 介して逆参照できます。したがって、上記の式は次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="d1370fc5b87a4deef9433fab962c63dda2bb0891" translate="yes" xml:space="preserve">
          <source>Similarly, autogeneration for keys &lt;code&gt;'+='&lt;/code&gt; and &lt;code&gt;'++'&lt;/code&gt; is analogous to &lt;code&gt;'-='&lt;/code&gt; and &lt;code&gt;'--'&lt;/code&gt; above:</source>
          <target state="translated">同様に、キー &lt;code&gt;'+='&lt;/code&gt; および &lt;code&gt;'++'&lt;/code&gt; 自動生成は、上記の &lt;code&gt;'-='&lt;/code&gt; および &lt;code&gt;'--'&lt;/code&gt; 類似しています。</target>
        </trans-unit>
        <trans-unit id="22f4fe3ff0b7318ce2f9a1f22a4a30c916f48517" translate="yes" xml:space="preserve">
          <source>Similarly, because of all the subscripting that is done using single words, the same rule applies to any bareword that is used for subscripting a hash. So now, instead of writing</source>
          <target state="translated">同様に、すべての添え字は単一語を使用して行われるため、ハッシュの添え字に使用されるすべての裸語にも同じルールが適用されます。したがって、次のように記述する代わりに</target>
        </trans-unit>
        <trans-unit id="1ef17c2e729b74afc14b925795781df60a813811" translate="yes" xml:space="preserve">
          <source>Similarly, decimal strings can represent only those numbers which have a finite decimal expansion. Being strings, and thus of arbitrary length, there is no practical limit for the exponent or number of decimal digits for these numbers. (But realize that what we are discussing the rules for just the</source>
          <target state="translated">同様に、10進数の文字列は、有限の10進数展開を持つ数だけを表すことができます。文字列であり、したがって任意の長さであるため、これらの数の指数や小数点以下の桁数には実用的な制限はありません。(しかし、私たちが議論しているのは、単に</target>
        </trans-unit>
        <trans-unit id="d345f5b26d91c2f90c4bf682659d17c36e269cb0" translate="yes" xml:space="preserve">
          <source>Similarly, for repeated &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/()/g&lt;/a&gt;&lt;/code&gt; the second-best match is the match at the position one notch further in the string.</source>
          <target state="translated">同様に、繰り返される &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/()/g&lt;/a&gt;&lt;/code&gt; 、2番目に一致するのは、文字列の1ノッチ先の位置での一致です。</target>
        </trans-unit>
        <trans-unit id="120bba2aa7dfcc858de2e7ae463e7151de6901e1" translate="yes" xml:space="preserve">
          <source>Similarly, for repeated &lt;code&gt;m/()/g&lt;/code&gt; the second-best match is the match at the position one notch further in the string.</source>
          <target state="translated">同様に、繰り返される &lt;code&gt;m/()/g&lt;/code&gt; 、次善の一致は、文字列の1ノッチ先の位置での一致です。</target>
        </trans-unit>
        <trans-unit id="dee2c36ef0fdac4abda9dcad28ab4aed983df538" translate="yes" xml:space="preserve">
          <source>Similarly, functions that return text data--such as a function that fetches a web page--should sometimes translate newlines before returning the data, if they've not yet been translated to the local newline representation. A single line of code will often suffice:</source>
          <target state="translated">同様に、テキストデータを返す関数(例えばウェブページを取得する関数など)は、データを返す前に改行を翻訳しなければならないことがありますが、もし改行がまだローカルの改行表現に翻訳されていない場合は、翻訳しなければなりません。多くの場合、一行のコードで十分です。</target>
        </trans-unit>
        <trans-unit id="6397152c0c35f4b75972d06222dcea4b97f1756f" translate="yes" xml:space="preserve">
          <source>Similarly, if the &lt;code&gt;compress&lt;/code&gt; program is available, you can use this to write a &lt;code&gt;.tar.Z&lt;/code&gt; file</source>
          <target state="translated">同様に、 &lt;code&gt;compress&lt;/code&gt; プログラムが利用可能な場合、これを使用して &lt;code&gt;.tar.Z&lt;/code&gt; ファイルを書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="5e75a2bb501471358d82a9998e95b65710f45b03" translate="yes" xml:space="preserve">
          <source>Similarly, if you need the threads object, but your thread will not be returning a value (i.e.,</source>
          <target state="translated">同様に、スレッドオブジェクトが必要だが、スレッドが値を返さない場合 (すなわち</target>
        </trans-unit>
        <trans-unit id="5871ebe0fa13ed14449c1f6ca87d126616162345" translate="yes" xml:space="preserve">
          <source>Similarly, in the failure branch we could use &lt;code&gt;PUSHs&lt;/code&gt;</source>
          <target state="translated">同様に、失敗ブランチでは &lt;code&gt;PUSHs&lt;/code&gt; を使用できます</target>
        </trans-unit>
        <trans-unit id="9077bdc5741605a4137fa6215e60fd225b8f3e44" translate="yes" xml:space="preserve">
          <source>Similarly, it would be better to use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; instead of,</source>
          <target state="translated">同様に、代わりに &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; を使用&lt;a href=&quot;functions/use&quot;&gt;する&lt;/a&gt;方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="14a6593d35c0dd5a226aba97a86d554f0e84ed18" translate="yes" xml:space="preserve">
          <source>Similarly, it would be better to use &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; instead of,</source>
          <target state="translated">同様に、 &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; 代わりに使用機能 'unicode_strings'を使用する方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="c46d4cfe15f7f292996d268d497a4ca8dd6bd83c" translate="yes" xml:space="preserve">
          <source>Similarly, just because an operator lets you assume default arguments doesn't mean that you have to make use of the defaults. The defaults are there for lazy systems programmers writing one-shot programs. If you want your program to be readable, consider supplying the argument.</source>
          <target state="translated">同様に、演算子がデフォルトの引数を仮定できるからといって、デフォルトを利用しなければならないという意味ではありません。デフォルトは、単発のプログラムを書く怠惰なシステムプログラマのためのものです。プログラムを読めるようにしたいのであれば、引数を与えることを検討してください。</target>
        </trans-unit>
        <trans-unit id="65a3c4117ed70cbe8d3af699e5cf5e22b4df58b4" translate="yes" xml:space="preserve">
          <source>Similarly, mixing signals and threads may be problematic. Implementations are platform-dependent, and even the POSIX semantics may not be what you expect (and Perl doesn't even give you the full POSIX API). For example, there is no way to guarantee that a signal sent to a multi-threaded Perl application will get intercepted by any particular thread. (However, a recently added feature does provide the capability to send signals between threads. See &lt;a href=&quot;threads#THREAD-SIGNALLING&quot;&gt;&quot;THREAD SIGNALLING&quot; in threads&lt;/a&gt; for more details.)</source>
          <target state="translated">同様に、信号とスレッドの混合は問題になる可能性があります。実装はプラットフォームに依存し、POSIXセマンティクスでさえあなたが期待するものではないかもしれません（そしてPerlはあなたに完全なPOSIXAPIさえ提供しません）。たとえば、マルチスレッドのPerlアプリケーションに送信されたシグナルが特定のスレッドによってインターセプトされることを保証する方法はありません。（ただし、最近追加された機能は、スレッド間でシグナルを送信する機能を提供します。詳細について&lt;a href=&quot;threads#THREAD-SIGNALLING&quot;&gt;は、スレッドの「スレッド署名」を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="aab81862aa9c1688c2206840c0db77adfc7697fb" translate="yes" xml:space="preserve">
          <source>Similarly, mixing signals and threads may be problematic. Implementations are platform-dependent, and even the POSIX semantics may not be what you expect (and Perl doesn't even give you the full POSIX API). For example, there is no way to guarantee that a signal sent to a multi-threaded Perl application will get intercepted by any particular thread. (However, a recently added feature does provide the capability to send signals between threads. See &lt;a href=&quot;threads#THREAD-SIGNALLING&quot;&gt;THREAD SIGNALLING in threads&lt;/a&gt; for more details.)</source>
          <target state="translated">同様に、信号とスレッドを混在させると問題が発生する可能性があります。実装はプラットフォームに依存しており、POSIXのセマンティクスでさえ期待どおりではない場合があります（Perlでは完全なPOSIX APIも提供されません）。たとえば、マルチスレッドのPerlアプリケーションに送信された信号が特定のスレッドによってインターセプトされることを保証する方法はありません。（ただし、最近追加された機能は、スレッド間で信号を送信する機能を提供しません。を参照してください&lt;a href=&quot;threads#THREAD-SIGNALLING&quot;&gt;スレッドでTHREADシグナリングを&lt;/a&gt;詳細については。）</target>
        </trans-unit>
        <trans-unit id="cd7a72bba4a729c17beea354c31212e7918a1056" translate="yes" xml:space="preserve">
          <source>Similarly, syswrite() and send() use only the &lt;code&gt;:utf8&lt;/code&gt; flag, otherwise ignoring any layers. If the flag is set, both write the value UTF-8 encoded, even if the layer is some different encoding, such as the example above.</source>
          <target state="translated">同様に、syswrite（）とsend（）は &lt;code&gt;:utf8&lt;/code&gt; フラグのみを使用し、それ以外の場合はレイヤーを無視します。フラグが設定されている場合、レイヤーが上記の例のように別のエンコードであっても、両方ともUTF-8エンコードされた値を書き込みます。</target>
        </trans-unit>
        <trans-unit id="b0b7335ed3c7d05707d8547cd24aeb6b264218d7" translate="yes" xml:space="preserve">
          <source>Similarly, syswrite() and send() used only the &lt;code&gt;:utf8&lt;/code&gt; flag, otherwise ignoring any layers. If the flag is set, both wrote the value UTF-8 encoded, even if the layer is some different encoding, such as the example above.</source>
          <target state="translated">同様に、syswrite（）とsend（）は &lt;code&gt;:utf8&lt;/code&gt; フラグのみを使用し、それ以外の場合はレイヤーを無視しました。フラグが設定されている場合、レイヤーが上記の例のように別のエンコードであっても、両方がUTF-8エンコードされた値を書き込みました。</target>
        </trans-unit>
        <trans-unit id="f9312c4a2cb541668748a3ea749dc0d9f12c2cf9" translate="yes" xml:space="preserve">
          <source>Similarly, the &lt;code&gt;UNICODE_WARN_NONCHAR&lt;/code&gt; and &lt;code&gt;UNICODE_DISALLOW_NONCHAR&lt;/code&gt; flags affect how the function handles a Unicode non-character.</source>
          <target state="translated">同様に、 &lt;code&gt;UNICODE_WARN_NONCHAR&lt;/code&gt; フラグと &lt;code&gt;UNICODE_DISALLOW_NONCHAR&lt;/code&gt; フラグは、関数がUnicodeの非文字を処理する方法に影響を与えます。</target>
        </trans-unit>
        <trans-unit id="2fa030e076fa248a433f0f83ee4a1aceaeee249f" translate="yes" xml:space="preserve">
          <source>Similarly, the parameter &lt;code&gt;inc_override&lt;/code&gt; may be a reference to an array which is used in place of the default module search paths from &lt;code&gt;@INC&lt;/code&gt; .</source>
          <target state="translated">同様に、パラメーター &lt;code&gt;inc_override&lt;/code&gt; は、 &lt;code&gt;@INC&lt;/code&gt; からのデフォルトのモジュール検索パスの代わりに使用される配列への参照である場合があります。</target>
        </trans-unit>
        <trans-unit id="1c747d6cbaa1a9a827f93122d97bf098849b7485" translate="yes" xml:space="preserve">
          <source>Similarly, the parameter &lt;code&gt;inc_override&lt;/code&gt; may be a reference to an array which is used in place of the default module search paths from &lt;code&gt;@INC&lt;/code&gt;.</source>
          <target state="translated">同様に、パラメータ &lt;code&gt;inc_override&lt;/code&gt; は、 &lt;code&gt;@INC&lt;/code&gt; からのデフォルトのモジュール検索パスの代わりに使用される配列への参照である可能性があります。</target>
        </trans-unit>
        <trans-unit id="1497da8abe3ed6eca13bd6302e3d281ea65007d7" translate="yes" xml:space="preserve">
          <source>Similarly, the resultant filespec will contain the file version only if one was present in the input filespec.</source>
          <target state="translated">同様に、結果として得られるファイルスペックには、入力ファイルスペックにファイルバージョンが存在する場合にのみ、ファイルバージョンが含まれます。</target>
        </trans-unit>
        <trans-unit id="0dacead88183b1e9c6304a4ceec665b6c24796d7" translate="yes" xml:space="preserve">
          <source>Similarly, they can be used in regular expression literals</source>
          <target state="translated">同様に、それらは正規表現リテラルで使用することができます。</target>
        </trans-unit>
        <trans-unit id="395326d4967b38aae5eb742109108213c899c254" translate="yes" xml:space="preserve">
          <source>Similarly, this is invalid:</source>
          <target state="translated">同様に、これも無効です。</target>
        </trans-unit>
        <trans-unit id="6c8f54b856913d21b69f361a1a90203715ac01de" translate="yes" xml:space="preserve">
          <source>Similarly, this recipe can be used for properties that do require adjustments:</source>
          <target state="translated">同様に、このレシピは、調整が必要なプロパティに使用することができます。</target>
        </trans-unit>
        <trans-unit id="838e649b773f393ab1e3e6ec2fd3f5756cf00ea3" translate="yes" xml:space="preserve">
          <source>Similarly, this will silence warnings from this module, and preserve the default behaviour:</source>
          <target state="translated">同様に、これはこのモジュールからの警告を消し、デフォルトの動作を維持します。</target>
        </trans-unit>
        <trans-unit id="e4b2e4fdd23d41dfea9d8225a12a424a715230bb" translate="yes" xml:space="preserve">
          <source>Similarly, this:</source>
          <target state="translated">同様に、これも。</target>
        </trans-unit>
        <trans-unit id="d1bdda2be136926ef9a893301ff91d18747c507f" translate="yes" xml:space="preserve">
          <source>Similarly, to copy an anonymous hash, you can use</source>
          <target state="translated">同様に、匿名ハッシュをコピーするには</target>
        </trans-unit>
        <trans-unit id="7850beac28db723d025cfad11fb93ce97e2ced9b" translate="yes" xml:space="preserve">
          <source>Similarly, using &lt;code&gt;$^W&lt;/code&gt; to either disable or enable blocks of code is fundamentally flawed. For a start, say you want to disable warnings in a block of code. You might expect this to be enough to do the trick:</source>
          <target state="translated">同様に、コードのブロックを無効または有効にするために &lt;code&gt;$^W&lt;/code&gt; を使用することには、根本的な欠陥があります。まず、コードブロックで警告を無効にしたいとします。あなたはこれがトリックを行うのに十分であると期待するかもしれません：</target>
        </trans-unit>
        <trans-unit id="2664530a7df4eabf1ac2e9d54c9f06c6deee6b41" translate="yes" xml:space="preserve">
          <source>Similarly, with this code</source>
          <target state="translated">同様に、このコードでは</target>
        </trans-unit>
        <trans-unit id="b0293d771b0de8656e1c85bf1faad486bf545599" translate="yes" xml:space="preserve">
          <source>Similarly, you may use these I/O layers on output streams to automatically convert Unicode to the specified encoding when it is written to the stream. For example, the following snippet copies the contents of the file &quot;text.jis&quot; (encoded as ISO-2022-JP, aka JIS) to the file &quot;text.utf8&quot;, encoded as UTF-8:</source>
          <target state="translated">同様に、出力ストリーム上のこれらの I/O レイヤを使用して、ストリームに書き込まれたときに Unicode を指定されたエンコーディングに自動的に変換することもできます。例えば、以下のスニペットは、ファイル「text.jis」(ISO-2022-JP、別名JISとしてエンコードされています)の内容を、ファイル「text.utf8」(UTF-8としてエンコードされています)にコピーしています。</target>
        </trans-unit>
        <trans-unit id="a9548affa7e4acbe2593b885978a8755658bc00f" translate="yes" xml:space="preserve">
          <source>Similary to</source>
          <target state="translated">に似ています。</target>
        </trans-unit>
        <trans-unit id="d038c3b0b4f25db2b86d3e73c906bad029553a54" translate="yes" xml:space="preserve">
          <source>Simon Cozens &amp;lt;simon AT brecon DOT co DOT uk&amp;gt; - Being there to answer zillions of annoying questions</source>
          <target state="translated">Simon Cozens &amp;lt;simon AT brecon DOT co DOT uk&amp;gt;-何十億もの迷惑な質問に答えるためにそこにいる</target>
        </trans-unit>
        <trans-unit id="db6a8ce8a7b56a60b15a1e81509c2149cf995dfb" translate="yes" xml:space="preserve">
          <source>Simon Cozens and Wolfgang Laun.</source>
          <target state="translated">シモン・コーゼンスとウォルフガング・ラウン</target>
        </trans-unit>
        <trans-unit id="911ebed02457e684e0b32e14a35ae78fa21f67e0" translate="yes" xml:space="preserve">
          <source>Simon Cozens, &lt;code&gt;simon@cpan.org&lt;/code&gt;</source>
          <target state="translated">Simon Cozens、 &lt;code&gt;simon@cpan.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c339f709f7b43634c7fbcb9cbd9eccd0f9cc3ac2" translate="yes" xml:space="preserve">
          <source>Simple Mail Transfer Protocol Client</source>
          <target state="translated">簡易メール転送プロトコルクライアント</target>
        </trans-unit>
        <trans-unit id="0b80f19dce22ed4ff1ea0703ed5ec7dc2f2434d5" translate="yes" xml:space="preserve">
          <source>Simple Perl scalars (any scalar that is not a reference) are the most difficult objects to encode: JSON::PP will encode undefined scalars as JSON &lt;code&gt;null&lt;/code&gt; values, scalars that have last been used in a string context before encoding as JSON strings, and anything else as number value:</source>
          <target state="translated">単純なPerlスカラー（参照ではないスカラー）は、エンコードが最も難しいオブジェクトです。JSON:: PPは、未定義のスカラーをJSON &lt;code&gt;null&lt;/code&gt; 値としてエンコードし、JSON文字列としてエンコードする前に文字列コンテキストで最後に使用されたスカラーをエンコードします。数値として他のもの：</target>
        </trans-unit>
        <trans-unit id="bee009eadcb45691f1eecbe3d87057665862d1bd" translate="yes" xml:space="preserve">
          <source>Simple Scalar</source>
          <target state="translated">シンプルスカラー</target>
        </trans-unit>
        <trans-unit id="83f59937d173df040577971290f0e1cacd671a9c" translate="yes" xml:space="preserve">
          <source>Simple Statements</source>
          <target state="translated">シンプルなステートメント</target>
        </trans-unit>
        <trans-unit id="84ffc80b7ca3fcee70bdb32bddd613a718e0b12c" translate="yes" xml:space="preserve">
          <source>Simple assignment is not overloadable (the &lt;code&gt;'='&lt;/code&gt; key is used for the &lt;a href=&quot;#Copy-Constructor&quot;&gt;&quot;Copy Constructor&quot;&lt;/a&gt;). Perl does have a way to make assignments to an object do whatever you want, but this involves using tie(), not overload - see &lt;a href=&quot;perlfunc#tie&quot;&gt;&quot;tie&quot; in perlfunc&lt;/a&gt; and the &lt;a href=&quot;#COOKBOOK&quot;&gt;&quot;COOKBOOK&quot;&lt;/a&gt; examples below.</source>
          <target state="translated">単純な代入はオーバーロードできません（&lt;a href=&quot;#Copy-Constructor&quot;&gt;「コピーコンストラクタ」に&lt;/a&gt;は &lt;code&gt;'='&lt;/code&gt; キーが使用されます）。Perlには、オブジェクトへの割り当てを任意に行う方法がありますが、これには、オーバーロードではなくtie（）の使用が含ま&lt;a href=&quot;perlfunc#tie&quot;&gt;れます。perlfuncの「tie」&lt;/a&gt;および以下の&lt;a href=&quot;#COOKBOOK&quot;&gt;「COOKBOOK」の&lt;/a&gt;例を参照してください。</target>
        </trans-unit>
        <trans-unit id="fd89bedbaeb791041cff4fe148dbfde653b95d00" translate="yes" xml:space="preserve">
          <source>Simple assignment is not overloadable (the &lt;code&gt;'='&lt;/code&gt; key is used for the &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;). Perl does have a way to make assignments to an object do whatever you want, but this involves using tie(), not overload - see &lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; and the &lt;a href=&quot;#COOKBOOK&quot;&gt;COOKBOOK&lt;/a&gt; examples below.</source>
          <target state="translated">単純な割り当てはオーバーロード可能ではありません（ &lt;code&gt;'='&lt;/code&gt; キーは&lt;a href=&quot;#Copy-Constructor&quot;&gt;コピーコンストラクターに&lt;/a&gt;使用されます）。Perlはオブジェクトへの割り当ては、あなたがやりたいようにする方法を持っているが、これは過負荷ではない、（）ネクタイを使用することを含む-を参照して&lt;a href=&quot;functions/tie&quot;&gt;ネクタイ&lt;/a&gt;や&lt;a href=&quot;#COOKBOOK&quot;&gt;クックブック&lt;/a&gt;以下の例を。</target>
        </trans-unit>
        <trans-unit id="8605c0b660faa7b5703ee9847774a8d43e86ed05" translate="yes" xml:space="preserve">
          <source>Simple delegatees for misc parameters derived from distribution</source>
          <target state="translated">分布から派生したmiscパラメータのためのシンプルなデリゲート</target>
        </trans-unit>
        <trans-unit id="94eac8882772ef72bea55863ece1200dedf301b7" translate="yes" xml:space="preserve">
          <source>Simple enough. Now compile and run:</source>
          <target state="translated">十分に簡単です。今すぐコンパイルして実行してください。</target>
        </trans-unit>
        <trans-unit id="ba971c7177cc7a0849b0167e7f954b49b5a4aaf2" translate="yes" xml:space="preserve">
          <source>Simple examples</source>
          <target state="translated">簡単な例</target>
        </trans-unit>
        <trans-unit id="764eff41a5149cfadde2c6b72cdd2e21368ca43b" translate="yes" xml:space="preserve">
          <source>Simple examples to open a file for reading:</source>
          <target state="translated">ファイルを開いて読むための簡単な例</target>
        </trans-unit>
        <trans-unit id="8bbdbbffdc1d0c057f0470ba8573e7773f1d085a" translate="yes" xml:space="preserve">
          <source>Simple interface to Locale::Maketext::Lexicon</source>
          <target state="translated">Locale::Maketext::Lexiconへのシンプルなインターフェイス</target>
        </trans-unit>
        <trans-unit id="7b8b7240c656011159c28f4357d2c8a844877df6" translate="yes" xml:space="preserve">
          <source>Simple matching</source>
          <target state="translated">シンプルなマッチング</target>
        </trans-unit>
        <trans-unit id="d1a65de4566d838633c7cfe8d2f3954d6165e02e" translate="yes" xml:space="preserve">
          <source>Simple methods for simple tasks</source>
          <target state="translated">簡単な作業のためのシンプルな方法</target>
        </trans-unit>
        <trans-unit id="107deb5b12e566d319794bc7ce2d8bcc70c508d0" translate="yes" xml:space="preserve">
          <source>Simple options</source>
          <target state="translated">シンプルなオプション</target>
        </trans-unit>
        <trans-unit id="b3c11d00394d5efd68e3089882ea99ef88db2b49" translate="yes" xml:space="preserve">
          <source>Simple subroutine to insert the macros defined by the macro attribute into the Makefile.</source>
          <target state="translated">マクロ属性で定義されたマクロをMakefileに挿入するシンプルなサブルーチンです。</target>
        </trans-unit>
        <trans-unit id="adadcc42c8be98750be33acd4bfac36bd737f651" translate="yes" xml:space="preserve">
          <source>Simple substitution</source>
          <target state="translated">単純な置換</target>
        </trans-unit>
        <trans-unit id="4f78d32b59c097fb10ad26d36f2e74fdbebe4e64" translate="yes" xml:space="preserve">
          <source>Simple word matching</source>
          <target state="translated">簡単な単語のマッチング</target>
        </trans-unit>
        <trans-unit id="f7b02d0f94f21913ddb8d295324658b8720d69e0" translate="yes" xml:space="preserve">
          <source>Simple, eh?</source>
          <target state="translated">簡単だろ?</target>
        </trans-unit>
        <trans-unit id="5ab4a74caba11b1370fe119fe34f9f5db826dbbf" translate="yes" xml:space="preserve">
          <source>Simple, one-off commits pushed to the 'blead' branch should be simple commits that apply cleanly. In other words, you should make sure your work is committed against the current position of blead, so that you can push back to the master repository without merging.</source>
          <target state="translated">blead' ブランチにプッシュされる単純な単発のコミットは、クリーンに適用される単純なコミットであるべきです。言い換えれば、あなたの作業が blead の現在の位置に対してコミットされていることを確認し、マージせずにマスターリポジトリにプッシュできるようにすべきです。</target>
        </trans-unit>
        <trans-unit id="4ee1790ba48c5c5f5aec6b6de12f218c366e78db" translate="yes" xml:space="preserve">
          <source>Simple... Now look:</source>
          <target state="translated">単純な...見てください</target>
        </trans-unit>
        <trans-unit id="6c9330b7a2ff965f7db6cafb9f575b4d58374515" translate="yes" xml:space="preserve">
          <source>Simpler definition of attribute handlers</source>
          <target state="translated">よりシンプルな属性ハンドラの定義</target>
        </trans-unit>
        <trans-unit id="50c361747016ee3aff5355a6c96f0c2b139551ef" translate="yes" xml:space="preserve">
          <source>Simplest way to do it automatically is to use your version control system's revision number (you are using version control, right?).</source>
          <target state="translated">自動的に行う最も単純な方法は、バージョン管理システムのリビジョン番号を使用することです(バージョン管理を使用していますよね?</target>
        </trans-unit>
        <trans-unit id="68be18029150583164f9438753e32a72fd3e4c87" translate="yes" xml:space="preserve">
          <source>Simplified source filtering</source>
          <target state="translated">簡素化されたソースフィルタリング</target>
        </trans-unit>
        <trans-unit id="66f7f6fe24549ec54694a312ab799bde4d89b2f3" translate="yes" xml:space="preserve">
          <source>Simply not portable. Get your lvalue to be of the right type, or maybe use temporary variables, or dirty tricks with unions.</source>
          <target state="translated">単純にポータブルではありません。lvalue が正しい型になるようにしたり、一時的な変数を使ったり、ユニオンを使った汚いトリックを使ったりします。</target>
        </trans-unit>
        <trans-unit id="20084b93a5f754ce0ccd01de74eb0172d18babfc" translate="yes" xml:space="preserve">
          <source>Simply put:</source>
          <target state="translated">簡単に言うと</target>
        </trans-unit>
        <trans-unit id="991f810db6d12637f2fd5bbddcb5e86f7ab43bb2" translate="yes" xml:space="preserve">
          <source>Simply put: for each extension linked with your Perl executable (determined during its initial configuration on your computer or when adding a new extension), a Perl subroutine is created to incorporate the extension's routines. Normally, that subroutine is named</source>
          <target state="translated">簡単に言えば、Perlの実行ファイルにリンクされた各拡張子(コンピュータの初期設定時や新しい拡張子の追加時に決定されます)に対して、拡張子のルーチンを組み込むためのPerlのサブルーチンが作成されます。通常、そのサブルーチンの名前は</target>
        </trans-unit>
        <trans-unit id="86b802f817d8db47f98e358e0df4e43c122569da" translate="yes" xml:space="preserve">
          <source>Simply run</source>
          <target state="translated">単純に実行</target>
        </trans-unit>
        <trans-unit id="14c3e2e53d9dfb6b8072093e8b927f77f6a76d42" translate="yes" xml:space="preserve">
          <source>Simply says that we're Unix.</source>
          <target state="translated">単純にUnixだと言っているだけです。</target>
        </trans-unit>
        <trans-unit id="22a4ed66c623d273a571652cc9ae1a89577a837f" translate="yes" xml:space="preserve">
          <source>Since</source>
          <target state="translated">Since</target>
        </trans-unit>
        <trans-unit id="60dbe9f3bc2001b2c722387a7d49aaabb3da33d1" translate="yes" xml:space="preserve">
          <source>Since # can be used for comments, # must be escaped.</source>
          <target state="translated">コメントには#を使用できるので、#はエスケープしなければなりません。</target>
        </trans-unit>
        <trans-unit id="7f16eb993aa5b4126dadedc6b4f7941b4f104c6b" translate="yes" xml:space="preserve">
          <source>Since 3.26, using &lt;code&gt;-F&lt;/code&gt; as the superuser also implies &lt;code&gt;-U&lt;/code&gt; as opening most files and traversing directories requires privileges that are above the nobody/nogroup level.</source>
          <target state="translated">3.26以降、スーパーユーザーとして &lt;code&gt;-F&lt;/code&gt; を使用すると、ほとんどのファイルを開き、ディレクトリをトラバースするために &lt;code&gt;-U&lt;/code&gt; が必要になるため、nobody / nogroupレベルより上の特権が必要になります。</target>
        </trans-unit>
        <trans-unit id="d18dd63133c168a4767fcb87b71a43b938682e1a" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt; does a &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; it may affect a &lt;code&gt;SIGCHLD&lt;/code&gt; handler. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">以来&lt;a href=&quot;#system-LIST&quot;&gt; &lt;code&gt;system&lt;/code&gt; &lt;/a&gt;ない&lt;a href=&quot;#fork&quot;&gt; &lt;code&gt;fork&lt;/code&gt; &lt;/a&gt;して&lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;それが影響する可能性が &lt;code&gt;SIGCHLD&lt;/code&gt; のハンドラを。詳細については、&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1ded02f76d7e8f2623d74fdc5f26a66cd0a132c8" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;http://man.he.net/man3/flock&quot;&gt;flock(3)&lt;/a&gt; is present in EMX, but is not functional, it is emulated by perl. To disable the emulations, set environment variable &lt;code&gt;USE_PERL_FLOCK=0&lt;/code&gt;.</source>
          <target state="translated">以来、&lt;a href=&quot;http://man.he.net/man3/flock&quot;&gt;群れ（3）&lt;/a&gt; EMXに存在するが、機能していない、それは、Perlによってエミュレートされます。エミュレーションを無効にするには、環境変数 &lt;code&gt;USE_PERL_FLOCK=0&lt;/code&gt; を設定します。</target>
        </trans-unit>
        <trans-unit id="af160de91abb536123124eac1ecabfc37de02e74" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; it may affect a &lt;code&gt;SIGCHLD&lt;/code&gt; handler. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">以来 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ない &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; して &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; それが影響する可能性が &lt;code&gt;SIGCHLD&lt;/code&gt; のハンドラを。詳細については、&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="aba59b2cf00e40d21bac4c0a192544510ddcbae0" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; will also call the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method, the actual value for &lt;code&gt;MODULE&lt;/code&gt; must be a bareword. That is, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; cannot load files by name, although &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; can:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; メソッドも呼び出すので、 &lt;code&gt;MODULE&lt;/code&gt; の実際の値はベアワードでなければなりません。つまり、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; は名前でファイルをロードできませんが、 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; は次のことができます。</target>
        </trans-unit>
        <trans-unit id="73d2921b742823e6f578c98791a72739f4a21337" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; it may affect a &lt;code&gt;SIGCHLD&lt;/code&gt; handler. See &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">以来 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ない &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; して &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; それが影響する可能性が &lt;code&gt;SIGCHLD&lt;/code&gt; のハンドラを。詳細については、&lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="53cc6266d93eb2a78be0857ad5ecd43af7e2b644" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;Archive::Tar&lt;/code&gt; doesn't change the current directory internally while it is extracting the items in a tarball, all calls to &lt;code&gt;Cwd::cwd()&lt;/code&gt; can be avoided if we can guarantee that the current directory doesn't get changed externally.</source>
          <target state="translated">以来 &lt;code&gt;Archive::Tar&lt;/code&gt; それがtarballに項目を抽出している間に、内部でカレントディレクトリを変更しない場合には、すべてのコール &lt;code&gt;Cwd::cwd()&lt;/code&gt; 私たちは、現在のディレクトリが外部から変更されないことを保証できる場合に回避することができます。</target>
        </trans-unit>
        <trans-unit id="42aa5efcb3e75000fce11592bd84e59ec314928e" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;SIGINT&lt;/code&gt; and &lt;code&gt;SIGQUIT&lt;/code&gt; are ignored during the execution of &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;, if you expect your program to terminate on receipt of these signals you will need to arrange to do so yourself based on the return value.</source>
          <target state="translated">以来 &lt;code&gt;SIGINT&lt;/code&gt; と &lt;code&gt;SIGQUIT&lt;/code&gt; は、実行中に無視される&lt;a href=&quot;#system-LIST&quot;&gt; &lt;code&gt;system&lt;/code&gt; &lt;/a&gt;、あなたのプログラムは、これらの信号の受信時に終了することが予想される場合には、戻り値に基づいて自分自身そうするように配置する必要があるでしょう。</target>
        </trans-unit>
        <trans-unit id="8c3c7a53144e6a3302e2a2f9e7b6229b194fa174" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;SIGINT&lt;/code&gt; and &lt;code&gt;SIGQUIT&lt;/code&gt; are ignored during the execution of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, if you expect your program to terminate on receipt of these signals you will need to arrange to do so yourself based on the return value.</source>
          <target state="translated">以来 &lt;code&gt;SIGINT&lt;/code&gt; と &lt;code&gt;SIGQUIT&lt;/code&gt; は、実行中に無視される &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 、あなたのプログラムは、これらの信号の受信時に終了することが予想される場合には、戻り値に基づいて自分自身そうするように配置する必要があるでしょう。</target>
        </trans-unit>
        <trans-unit id="e4f45d5c1543b43feed600201b8df9285b671829" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;SIGINT&lt;/code&gt; and &lt;code&gt;SIGQUIT&lt;/code&gt; are ignored during the execution of &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, if you expect your program to terminate on receipt of these signals you will need to arrange to do so yourself based on the return value.</source>
          <target state="translated">以来 &lt;code&gt;SIGINT&lt;/code&gt; と &lt;code&gt;SIGQUIT&lt;/code&gt; は、実行中に無視される &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 、あなたのプログラムは、これらの信号の受信時に終了することが予想される場合には、戻り値に基づいて自分自身そうするように配置する必要があるでしょう。</target>
        </trans-unit>
        <trans-unit id="c78eaa920d9b2c6c4c17bb6231c81108ebdc9ea7" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;XSRETURN_*&lt;/code&gt; macros can be used with CODE blocks as well, one can rewrite this example as:</source>
          <target state="translated">以来 &lt;code&gt;XSRETURN_*&lt;/code&gt; マクロは、同様のコードブロックを使用することができ、一つは、この例を書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="ddeb2559b4a933dbff6f6bd50711c077c5250a4a" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;use&lt;/code&gt; will also call the &lt;code&gt;import&lt;/code&gt; method, the actual value for &lt;code&gt;MODULE&lt;/code&gt; must be a bareword. That is, &lt;code&gt;use&lt;/code&gt; cannot load files by name, although &lt;code&gt;require&lt;/code&gt; can:</source>
          <target state="translated">以来 &lt;code&gt;use&lt;/code&gt; また呼ぶ &lt;code&gt;import&lt;/code&gt; 方法を、の実際の値 &lt;code&gt;MODULE&lt;/code&gt; は、裸の単語でなければなりません。つまり、 &lt;code&gt;use&lt;/code&gt; は名前でファイルをロードできませんが、 &lt;code&gt;require&lt;/code&gt; は次のことができます。</target>
        </trans-unit>
        <trans-unit id="4ae1fb90f2e2a999e504c7cb0f71e0777fa542ca" translate="yes" xml:space="preserve">
          <source>Since CPAN.pm version 1.88_51 modules declared as &lt;code&gt;build_requires&lt;/code&gt; by a distribution are treated differently depending on the config variable &lt;code&gt;build_requires_install_policy&lt;/code&gt; . By setting &lt;code&gt;build_requires_install_policy&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt;, such a module is not installed. It is only built and tested, and then kept in the list of tested but uninstalled modules. As such, it is available during the build of the dependent module by integrating the path to the &lt;code&gt;blib/arch&lt;/code&gt; and &lt;code&gt;blib/lib&lt;/code&gt; directories in the environment variable PERL5LIB. If &lt;code&gt;build_requires_install_policy&lt;/code&gt; is set ti &lt;code&gt;yes&lt;/code&gt; , then both modules declared as &lt;code&gt;requires&lt;/code&gt; and those declared as &lt;code&gt;build_requires&lt;/code&gt; are treated alike. By setting to &lt;code&gt;ask/yes&lt;/code&gt; or &lt;code&gt;ask/&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; , CPAN.pm asks the user and sets the default accordingly.</source>
          <target state="translated">CPAN.pmバージョン1.88_51以降、ディストリビューションによって &lt;code&gt;build_requires&lt;/code&gt; として宣言されたモジュールは、設定変数 &lt;code&gt;build_requires_install_policy&lt;/code&gt; に応じて異なる方法で処理されます。 &lt;code&gt;build_requires_install_policy&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; に設定すると、そのようなモジュールはインストールされません。ビルドおよびテストのみが行われ、テスト済みでアンインストールされたモジュールのリストに保持されます。そのため、依存モジュールのビルド中に、環境変数PERL5LIB の &lt;code&gt;blib/arch&lt;/code&gt; および &lt;code&gt;blib/lib&lt;/code&gt; ディレクトリへのパスを統合することで利用できます。 &lt;code&gt;build_requires_install_policy&lt;/code&gt; がti &lt;code&gt;yes&lt;/code&gt; に設定されている場合、両方のモジュールがrequireとして宣言されてい &lt;code&gt;requires&lt;/code&gt; また、 &lt;code&gt;build_requires&lt;/code&gt; として宣言されたものも同様に扱われます。 &lt;code&gt;ask/yes&lt;/code&gt; または「 &lt;code&gt;ask/&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 」に設定すると、CPAN.pmはユーザーに質問し、それに応じてデフォルトを設定します。</target>
        </trans-unit>
        <trans-unit id="92bd94b93ba7aa98da9b694cc55416c0183aa164" translate="yes" xml:space="preserve">
          <source>Since DLLs may be loaded at run time, to have the same mechanism for DLLs one needs to have the address range of</source>
          <target state="translated">DLLは実行時にロードされる可能性があるので、DLLのための同じメカニズムを持つためには、アドレス範囲が</target>
        </trans-unit>
        <trans-unit id="b8d7eab0940cbd19c7e5c0a0410f1af9f2b70a97" translate="yes" xml:space="preserve">
          <source>Since Emacs version 19 patchlevel 22 or so, there have been both a perl-mode.el and support for the Perl debugger built in. These should come with the standard Emacs 19 distribution.</source>
          <target state="translated">Emacs 19のパッチレベル22くらいから、Perl-mode.elとPerlデバッガが組み込まれています。これらは標準の Emacs 19 ディストリビューションに付属しているはずです。</target>
        </trans-unit>
        <trans-unit id="ae992899a872766d28cfb8b692b2e7f7ecf24212" translate="yes" xml:space="preserve">
          <source>Since File::Spec is object oriented, subroutines should not be called directly, as in:</source>
          <target state="translated">File::Specはオブジェクト指向なので、サブルーチンを直接呼び出すべきではありません。</target>
        </trans-unit>
        <trans-unit id="58330cb00aafa72e888d41a23aef159c39b70e0c" translate="yes" xml:space="preserve">
          <source>Since INPUT sections allow declaration of C variables which do not appear in the parameter list of a subroutine, this may be shortened to:</source>
          <target state="translated">INPUTセクションでは、サブルーチンのパラメータリストに現れないC変数の宣言が可能なので、これは短縮されているかもしれません。</target>
        </trans-unit>
        <trans-unit id="45546e69c804ad74560b03b1bfa0ada21545dbab" translate="yes" xml:space="preserve">
          <source>Since Math::BigInt and BigFloat also overload the normal math operations, the following line will still work:</source>
          <target state="translated">Math::BigIntやBigFloatも通常の数学演算をオーバーロードしているので、以下の行はまだ動作します。</target>
        </trans-unit>
        <trans-unit id="1a22aa5b5825f973b9ba76849397ffcf019b0d3e" translate="yes" xml:space="preserve">
          <source>Since OS/2 port of perl uses a remarkable EMX environment, it can run (and build extensions, and - possibly - be built itself) under any environment which can run EMX. The current list is DOS, DOS-inside-OS/2, Win0.3*, Win0.95 and WinNT. Out of many perl flavors, only one works, see &lt;a href=&quot;#perl_.exe&quot;&gt;&quot;&lt;i&gt;perl_.exe&lt;/i&gt;&quot;&lt;/a&gt;.</source>
          <target state="translated">perlのOS / 2ポートは注目に値するEMX環境を使用しているため、EMXを実行できる任意の環境で実行できます（拡張機能をビルドし、場合によってはそれ自体をビルドできます）。現在のリストは、DOS、DOS-inside-OS / 2、Win0.3 *、Win0.95、およびWinNTです。多くのperlフレーバーのうち、1つだけが機能します。&lt;a href=&quot;#perl_.exe&quot;&gt;「&lt;i&gt;perl_.exe&lt;/i&gt;」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="bfdb84eddf5f43124818a551b78d4d19bef89ac6" translate="yes" xml:space="preserve">
          <source>Since OS/2 port of perl uses a remarkable EMX environment, it can run (and build extensions, and - possibly - be built itself) under any environment which can run EMX. The current list is DOS, DOS-inside-OS/2, Win0.3*, Win0.95 and WinNT. Out of many perl flavors, only one works, see &lt;a href=&quot;#perl_.exe&quot;&gt;perl_.exe&lt;/a&gt;.</source>
          <target state="translated">perlのOS / 2ポートは注目に値するEMX環境を使用しているため、EMXを実行できる任意の環境で実行できます（拡張機能をビルドし、場合によっては自分でビルドできます）。現在のリストは、DOS、DOS-inside-OS / 2、Win0.3 *、Win0.95、WinNTです。多くのperlフレーバーのうち、1つだけが機能します&lt;a href=&quot;#perl_.exe&quot;&gt;。perl_.exeを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6084ebce66f9d95008fbd76add0c4721f5880c4b" translate="yes" xml:space="preserve">
          <source>Since PERL_SYS_INIT3() may change &lt;code&gt;env&lt;/code&gt; , it may be more appropriate to provide &lt;code&gt;env&lt;/code&gt; as an argument to perl_parse().</source>
          <target state="translated">PERL_SYS_INIT3（）は &lt;code&gt;env&lt;/code&gt; を変更する可能性があるため、perl_parse（）の引数として &lt;code&gt;env&lt;/code&gt; を提供する方が適切な場合があります。</target>
        </trans-unit>
        <trans-unit id="f7f8af64efb04a46b462c34b5604a1102a5d4309" translate="yes" xml:space="preserve">
          <source>Since PERL_SYS_INIT3() may change &lt;code&gt;env&lt;/code&gt;, it may be more appropriate to provide &lt;code&gt;env&lt;/code&gt; as an argument to perl_parse().</source>
          <target state="translated">PERL_SYS_INIT3（）は &lt;code&gt;env&lt;/code&gt; を変更する可能性があるため、perl_parse（）の引数として &lt;code&gt;env&lt;/code&gt; を指定する方が適切な場合があります。</target>
        </trans-unit>
        <trans-unit id="908c64d54ba36fa8efadd65bbb91e193ec071dc5" translate="yes" xml:space="preserve">
          <source>Since Perl 5.004, however, this situation is a special case and Perl creates the hash key only when you make the assignment:</source>
          <target state="translated">しかし、Perl 5.004以降は、このような状況は特殊なケースであり、Perlは代入を行ったときにのみハッシュキーを生成します。</target>
        </trans-unit>
        <trans-unit id="a9ff67b0f4d57746c4f60694c82d05a6c7b9009b" translate="yes" xml:space="preserve">
          <source>Since Perl 5.16.0, the &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; token is available under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature
'current_sub'&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.16.0&lt;/code&gt; . It will evaluate to a reference to the currently-running sub, which allows for recursive calls without knowing your subroutine's name.</source>
          <target state="translated">Perl 5.16.0以降、 &lt;code&gt;&lt;a href=&quot;functions/__sub__&quot;&gt;__SUB__&lt;/a&gt;&lt;/code&gt; トークンは &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'current_sub'&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.16.0&lt;/code&gt; を使用します。これは、現在実行中のサブルーチンへの参照に評価され、サブルーチンの名前を知らなくても再帰呼び出しが可能になります。</target>
        </trans-unit>
        <trans-unit id="d1a3d1fb600646bfa2800199a2796c986b7ed30e" translate="yes" xml:space="preserve">
          <source>Since Perl 5.16.0, the &lt;code&gt;__SUB__&lt;/code&gt; token is available under &lt;code&gt;use feature 'current_sub'&lt;/code&gt; and &lt;code&gt;use 5.16.0&lt;/code&gt;. It will evaluate to a reference to the currently-running sub, which allows for recursive calls without knowing your subroutine's name.</source>
          <target state="translated">Perl 5.16.0以降、 &lt;code&gt;__SUB__&lt;/code&gt; トークンは &lt;code&gt;use feature 'current_sub'&lt;/code&gt; で使用可能であり、5.16.0を &lt;code&gt;use 5.16.0&lt;/code&gt; 。現在実行中のサブルーチンへの参照に評価されます。これにより、サブルーチンの名前を知らなくても再帰呼び出しが可能になります。</target>
        </trans-unit>
        <trans-unit id="3fae0c1bd1740225eb42eb57769894f0dc25fdf8" translate="yes" xml:space="preserve">
          <source>Since Perl 5.18, the option &lt;code&gt;--libpods&lt;/code&gt; has been deprecated, and using this option did not do anything other than producing a warning.</source>
          <target state="translated">Perl 5.18以降、オプション &lt;code&gt;--libpods&lt;/code&gt; は非推奨になり、このオプションを使用しても警告を生成する以外のことは何もしませんでした。</target>
        </trans-unit>
        <trans-unit id="8fd0c9118f331aebc3c70bcab476c8b369f379f5" translate="yes" xml:space="preserve">
          <source>Since Perl 5.26, this functionality with the extra parameter has been available by using a corresponding macro to each one of these, and whose name is formed by appending &lt;code&gt;_safe&lt;/code&gt; to the base name. There is no change to the functionality of those. For example, &lt;code&gt;isDIGIT_utf8_safe&lt;/code&gt; corresponds to &lt;code&gt;isDIGIT_utf8&lt;/code&gt;, and both now behave identically. All are documented in &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;&quot;Character case changing&quot; in perlapi&lt;/a&gt; and &lt;a href=&quot;perlapi#Character-classification&quot;&gt;&quot;Character classification&quot; in perlapi&lt;/a&gt;.</source>
          <target state="translated">Perl 5.26以降、追加パラメーターを使用したこの機能は、これらのそれぞれに対応するマクロを使用することで使用可能になり、その名前は、ベース名に &lt;code&gt;_safe&lt;/code&gt; を追加することによって形成されます。それらの機能に変更はありません。例えば、 &lt;code&gt;isDIGIT_utf8_safe&lt;/code&gt; に対応 &lt;code&gt;isDIGIT_utf8&lt;/code&gt; 、との両方が、今同じように動作します。すべて&lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;、perlapiの「文字大文字小文字の変更」&lt;/a&gt;およびperlapiの&lt;a href=&quot;perlapi#Character-classification&quot;&gt;「文字分類」に記載されてい&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="1fd1865b1bb90979ee802c45310e91e7b7152674" translate="yes" xml:space="preserve">
          <source>Since Perl 5.6.1 the special variables @- and @+ can functionally replace $`, $&amp;amp; and $'. These arrays contain pointers to the beginning and end of each match (see perlvar for the full story), so they give you essentially the same information, but without the risk of excessive string copying.</source>
          <target state="translated">Perl 5.6.1以降、特殊変数@-および@ +は$ `、$＆および$ 'を機能的に置き換えることができます。これらの配列には、各一致の最初と最後へのポインターが含まれているため（詳細についてはperlvarを参照）、基本的に同じ情報が得られますが、文字列が過度にコピーされるリスクはありません。</target>
        </trans-unit>
        <trans-unit id="0c3b5811fc581b714a97d98184d154d442e77a68" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8, thread programming has been available using a model called</source>
          <target state="translated">Perl 5.8 以降、スレッドプログラミングは</target>
        </trans-unit>
        <trans-unit id="8b1528960c7f653f3987ab48deb0e1d4226f3c72" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0 a file handle referring to a string can be created by calling open with a reference to that string instead of the filename. This file handle can then be used to read from or write to the string:</source>
          <target state="translated">Perl 5.8.0 以降では、ファイル名の代わりにその文字列を参照して open を呼び出すことで、文字列を参照するファイルハンドルを作成することができます。このファイルハンドルは、文字列からの読み書きに使用することができます。</target>
        </trans-unit>
        <trans-unit id="e4d8eb9b8b02c94511ca94b8a0081bc372e591a2" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, if the first two elements of the list are &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;http://man.he.net/man2/utime&quot;&gt;utime(2)&lt;/a&gt; syscall from your C library is called with a null second argument. On most systems, this will set the file's access and modification times to the current time (i.e., equivalent to the example above) and will work even on files you don't own provided you have write permission:</source>
          <target state="translated">Perl 5.8.0以降、リストの最初の2つの要素が&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; の&lt;/a&gt;場合、Cライブラリからの&lt;a href=&quot;http://man.he.net/man2/utime&quot;&gt;utime（2）&lt;/a&gt;システムコールがnullの2番目の引数で呼び出されます。ほとんどのシステムでは、これによりファイルのアクセス時間と変更時間が現在の時間に設定され（つまり、上記の例と同等）、書き込み権限があれば、所有していないファイルでも機能します。</target>
        </trans-unit>
        <trans-unit id="bd9a4f3a496c7e0b6fbb6d2a333860ae199a0774" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, if the first two elements of the list are &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the utime(2) syscall from your C library is called with a null second argument. On most systems, this will set the file's access and modification times to the current time (i.e., equivalent to the example above) and will work even on files you don't own provided you have write permission:</source>
          <target state="translated">Perl 5.8.0以降、リストの最初の2つの要素が &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; の場合、Cライブラリからのutime（2）syscallは2番目の引数がnullで呼び出されます。ほとんどのシステムでは、これによりファイルのアクセス時刻と変更時刻が現在の時刻に設定され（つまり、上記の例と同等）、書き込み権限がある場合は、所有していないファイルでも機能します。</target>
        </trans-unit>
        <trans-unit id="82732a952fbe092bd928ea5f2a3dfaabc967f5cd" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, if the first two elements of the list are &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the utime(2) syscall from your C library is called with a null second argument. On most systems, this will set the file's access and modification times to the current time (i.e., equivalent to the example above) and will work even on files you don't own provided you have write permission:</source>
          <target state="translated">Perl 5.8.0以降、リストの最初の2つの要素が &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; の場合、Cライブラリからのutime（2）syscallは2番目の引数がnullで呼び出されます。ほとんどのシステムでは、これによりファイルのアクセス時刻と変更時刻が現在の時刻に設定され（つまり、上記の例と同等）、書き込み権限がある場合は、所有していないファイルでも機能します。</target>
        </trans-unit>
        <trans-unit id="e51f3522d03a5b3a232bf4033ea382564508f931" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, signals have been made safer in Perl by postponing their handling until the interpreter is in a</source>
          <target state="translated">Perl 5.8.0 以降、Perl ではシグナルの処理をインタープリタが</target>
        </trans-unit>
        <trans-unit id="f2d46e3f9d2d01548c43a50c625a8e637b891700" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, you can also use the list form of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; for pipes. This is preferred when you wish to avoid having the shell interpret metacharacters that may be in your command string.</source>
          <target state="translated">Perl 5.8.0以降では、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; for pipesのリスト形式も使用できます。これは、コマンド文字列に含まれる可能性のあるメタ文字をシェルに解釈させたくない場合に適しています。</target>
        </trans-unit>
        <trans-unit id="718a678663da5c7f9393577cff7fa0dc58227371" translate="yes" xml:space="preserve">
          <source>Since Perl 5.8.0, you can also use the list form of &lt;code&gt;open&lt;/code&gt; for pipes. This is preferred when you wish to avoid having the shell interpret metacharacters that may be in your command string.</source>
          <target state="translated">Perl 5.8.0以降、パイプ用に &lt;code&gt;open&lt;/code&gt; のリスト形式を使用することもできます。これは、コマンド文字列に含まれている可能性のあるメタ文字をシェルに解釈させたくない場合に適しています。</target>
        </trans-unit>
        <trans-unit id="3480b6dbc008fbf05d437030616ffbd60db1a205" translate="yes" xml:space="preserve">
          <source>Since Perl 5.9.5</source>
          <target state="translated">Perl 5.9.5以降</target>
        </trans-unit>
        <trans-unit id="ce3c317911640225ca1493860827b3b6d9d6a56f" translate="yes" xml:space="preserve">
          <source>Since Perl doesn't currently do anything with the &lt;code&gt;LC_MONETARY&lt;/code&gt; category, specifying &lt;code&gt;:monetary&lt;/code&gt; does effectively nothing. Some systems have other categories, such as &lt;code&gt;LC_PAPER&lt;/code&gt;, but Perl also doesn't do anything with them, and there is no way to specify them in this pragma's arguments.</source>
          <target state="translated">現在、Perlは &lt;code&gt;LC_MONETARY&lt;/code&gt; カテゴリに対して何も実行しないため、 &lt;code&gt;:monetary&lt;/code&gt; を指定しても事実上何も実行されません。一部のシステムには &lt;code&gt;LC_PAPER&lt;/code&gt; などの他のカテゴリがありますが、Perlもそれらを処理せず、このプラグマの引数でそれらを指定する方法はありません。</target>
        </trans-unit>
        <trans-unit id="83749785256b2bd98e45a0b0907ae739a924facc" translate="yes" xml:space="preserve">
          <source>Since Perl doesn't currently do anything with the &lt;code&gt;LC_MONETARY&lt;/code&gt; category, specifying &lt;code&gt;:monetary&lt;/code&gt; does effectively nothing. Some systems have other categories, such as &lt;code&gt;LC_PAPER_SIZE&lt;/code&gt; , but Perl also doesn't know anything about them, and there is no way to specify them in this pragma's arguments.</source>
          <target state="translated">Perlは現在 &lt;code&gt;LC_MONETARY&lt;/code&gt; カテゴリーで何もしないので、 &lt;code&gt;:monetary&lt;/code&gt; を指定しても実質的に何もしません。一部のシステムには &lt;code&gt;LC_PAPER_SIZE&lt;/code&gt; などの他のカテゴリがありますが、Perlもそれらについて何も認識せず、このプラグマの引数でそれらを指定する方法がありません。</target>
        </trans-unit>
        <trans-unit id="7873f3b494192ca12067337abef4df445eb77998" translate="yes" xml:space="preserve">
          <source>Since Perl may compile the pattern at the moment of execution of the &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; operator, using &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; may have speed advantages in some situations, notably if the result of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; is used standalone:</source>
          <target state="translated">Perlは実行の瞬間にパターンをコンパイルすることができるので、 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; 使用して、オペレータ &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; 、いくつかの状況では、速度の利点を有していてもよく、特に、結果場合 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr()&lt;/a&gt;&lt;/code&gt; 使用スタンドアロンです。</target>
        </trans-unit>
        <trans-unit id="7ee8fc05b2f265e0275f90b02e962f3d6fb61694" translate="yes" xml:space="preserve">
          <source>Since Perl may compile the pattern at the moment of execution of the &lt;code&gt;qr()&lt;/code&gt; operator, using &lt;code&gt;qr()&lt;/code&gt; may have speed advantages in some situations, notably if the result of &lt;code&gt;qr()&lt;/code&gt; is used standalone:</source>
          <target state="translated">Perlは実行の瞬間にパターンをコンパイルすることができるので、 &lt;code&gt;qr()&lt;/code&gt; 使用して、オペレータ &lt;code&gt;qr()&lt;/code&gt; 、いくつかの状況では、速度の利点を有していてもよく、特に、結果場合 &lt;code&gt;qr()&lt;/code&gt; 使用スタンドアロンです。</target>
        </trans-unit>
        <trans-unit id="a306c8d466811a3ef5f554b084c63b5f925fc7a3" translate="yes" xml:space="preserve">
          <source>Since Perl processes the &lt;code&gt;#!&lt;/code&gt; -line (cf. &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;DESCRIPTION in perlrun&lt;/a&gt;, &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;Command Switches in perlrun&lt;/a&gt;, &lt;a href=&quot;perldiag#No-Perl-script-found-in-input&quot;&gt;No Perl script found in input in perldiag&lt;/a&gt;), it should know when a program</source>
          <target state="translated">Perlは &lt;code&gt;#!&lt;/code&gt; -line（参照のこと&lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;はperlrunで説明&lt;/a&gt;、&lt;a href=&quot;perlrun#Command-Switches&quot;&gt;コマンドはperlrunにスイッチ&lt;/a&gt;、&lt;a href=&quot;perldiag#No-Perl-script-found-in-input&quot;&gt;ノーのPerlスクリプトははperldiagに入力で見つかった&lt;/a&gt;）、それはときにプログラム知っておくべき</target>
        </trans-unit>
        <trans-unit id="15eed331802dca8328c200227a6895f19cb9da5d" translate="yes" xml:space="preserve">
          <source>Since Perl processes the &lt;code&gt;#!&lt;/code&gt;-line (cf. &lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;&quot;DESCRIPTION&quot; in perlrun&lt;/a&gt;, &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;&quot;Command Switches&quot; in perlrun&lt;/a&gt;, &lt;a href=&quot;perldiag#No-Perl-script-found-in-input&quot;&gt;&quot;No Perl script found in input&quot; in perldiag&lt;/a&gt;), it should know when a program</source>
          <target state="translated">Perlは &lt;code&gt;#!&lt;/code&gt; 処理するので！ -line（参照&lt;a href=&quot;perlrun#DESCRIPTION&quot;&gt;はperlrun内「説明」&lt;/a&gt;、&lt;a href=&quot;perlrun#Command-Switches&quot;&gt;はperlrunに「コマンドスイッチ」&lt;/a&gt;、&lt;a href=&quot;perldiag#No-Perl-script-found-in-input&quot;&gt;はperldiagに「いいえPerlのスクリプトは入力で見つかった」&lt;/a&gt;）、それはときにプログラム知っておくべき</target>
        </trans-unit>
        <trans-unit id="8b7890be1aa1eaa7cb9334a73bda7962f1d481f1" translate="yes" xml:space="preserve">
          <source>Since Perl recognizes a Unicode Byte Order Mark at the start of files as signaling that the file is Unicode encoded as in UTF-16 (whether big-endian or little-endian) or UTF-8, Pod parsers should do the same. Otherwise, the character encoding should be understood as being UTF-8 if the first highbit byte sequence in the file seems valid as a UTF-8 sequence, or otherwise as CP-1252 (earlier versions of this specification used Latin-1 instead of CP-1252).</source>
          <target state="translated">Perlはファイルの先頭にあるUnicodeバイトオーダーマークを、ファイルがUTF-16(ビッグエンディアンでもリトルエンディアンでも)またはUTF-8でUnicodeエンコードされていることを示すものとして認識していますので、Podパーサも同じようにしなければなりません。それ以外の場合は、ファイル内の最初のハイビットバイト列がUTF-8列として有効であると思われる場合はUTF-8、そうでない場合はCP-1252(この仕様の以前のバージョンではCP-1252の代わりにLatin-1を使用していました)として、文字エンコーディングはUTF-8であると理解すべきです。</target>
        </trans-unit>
        <trans-unit id="ca8e547d2675a51d87227fd5471e1262dc702174" translate="yes" xml:space="preserve">
          <source>Since Perl v5.10.0 includes the version.pm comparison logic anyways, you don't need to do anything at all.</source>
          <target state="translated">Perl v5.10.0 には version.pm 比較ロジックが含まれているので、何もする必要はありません。</target>
        </trans-unit>
        <trans-unit id="6b73dcb8330d72308d60b51669745466fec012ac" translate="yes" xml:space="preserve">
          <source>Since Perl v5.22.0, calls to this function are optimized out on ASCII platforms, so there is no performance hit in using it there.</source>
          <target state="translated">Perl v5.22.0 以降、この関数の呼び出しは ASCII プラットフォーム上で最適化されているため、そこで使用してもパフォーマンスの低下はありません。</target>
        </trans-unit>
        <trans-unit id="3b795b95acb54fe26d52c3d9e0c84f28d54d781c" translate="yes" xml:space="preserve">
          <source>Since Perl v5.6.0, Perl variable names may also be alphanumeric strings preceded by a caret. These must all be written in the form &lt;code&gt;${^Foo}&lt;/code&gt;; the braces are not optional. &lt;code&gt;${^Foo}&lt;/code&gt; denotes the scalar variable whose name is considered to be a control-&lt;code&gt;F&lt;/code&gt; followed by two &lt;code&gt;o&lt;/code&gt;'s. These variables are reserved for future special uses by Perl, except for the ones that begin with &lt;code&gt;^_&lt;/code&gt; (caret-underscore). No name that begins with &lt;code&gt;^_&lt;/code&gt; will acquire a special meaning in any future version of Perl; such names may therefore be used safely in programs. &lt;code&gt;$^_&lt;/code&gt; itself, however,</source>
          <target state="translated">Perl v5.6.0以降、Perl変数名は、キャレットが前に付いた英数字の文字列にすることもできます。これらはすべて &lt;code&gt;${^Foo}&lt;/code&gt; 形式で記述する必要があります;中括弧はオプションではありません。 &lt;code&gt;${^Foo}&lt;/code&gt; は、名前がcontrol &lt;code&gt;F&lt;/code&gt; 後に2つの &lt;code&gt;o&lt;/code&gt; が続くと見なされるスカラー変数を示します。これらの変数は、 &lt;code&gt;^_&lt;/code&gt; （キャレットアンダースコア）で始まる変数を除いて、Perlによる将来の特別な使用のために予約されています。 &lt;code&gt;^_&lt;/code&gt; で始まる名前は、Perlの将来のバージョンで特別な意味を獲得することはありません。したがって、このような名前はプログラムで安全に使用できます。ただし、 &lt;code&gt;$^_&lt;/code&gt; 自体は</target>
        </trans-unit>
        <trans-unit id="9077183204414786a18b0b5b41280a8b58d8fe93" translate="yes" xml:space="preserve">
          <source>Since Perl v5.6.0, Perl variable names may be alphanumeric strings that begin with a caret (or a control character, but this form is deprecated). These variables must be written in the form &lt;code&gt;${^Foo}&lt;/code&gt; ; the braces are not optional. &lt;code&gt;${^Foo}&lt;/code&gt; denotes the scalar variable whose name is a control-&lt;code&gt;F&lt;/code&gt; followed by two &lt;code&gt;o&lt;/code&gt; 's. These variables are reserved for future special uses by Perl, except for the ones that begin with &lt;code&gt;^_&lt;/code&gt; (control-underscore or caret-underscore). No control-character name that begins with &lt;code&gt;^_&lt;/code&gt; will acquire a special meaning in any future version of Perl; such names may therefore be used safely in programs. &lt;code&gt;$^_&lt;/code&gt; itself, however,</source>
          <target state="translated">Perl v5.6.0以降、Perl変数名は、キャレット（または制御文字）で始まる英数字の文字列になる場合がありますが、この形式は非推奨です。これらの変数は &lt;code&gt;${^Foo}&lt;/code&gt; 形式で記述する必要があります。中括弧はオプションではありません。 &lt;code&gt;${^Foo}&lt;/code&gt; は、名前がcontrol &lt;code&gt;F&lt;/code&gt; 後に2つの &lt;code&gt;o&lt;/code&gt; が続くスカラー変数を示します。これらの変数は、 &lt;code&gt;^_&lt;/code&gt; で始まる変数（control-underscoreまたはcaret-underscore）を除いて、Perlによる将来の特別な使用のために予約されています。 &lt;code&gt;^_&lt;/code&gt; で始まる制御文字名は、将来のバージョンのPerlで特別な意味を持つことはありません。したがって、このような名前はプログラムで安全に使用できます。ただし、 &lt;code&gt;$^_&lt;/code&gt; 自体</target>
        </trans-unit>
        <trans-unit id="33f810cef075561e9d829f100d7d5982e746f4f2" translate="yes" xml:space="preserve">
          <source>Since PodParser-1.24 the &lt;b&gt;Pod::Checker&lt;/b&gt; module uses only the &lt;b&gt;poderror&lt;/b&gt; method to print errors and warnings. The summary output (e.g. &quot;Pod syntax OK&quot;) has been dropped from the module and has been included in &lt;b&gt;podchecker&lt;/b&gt; (the script). This allows users of &lt;b&gt;Pod::Checker&lt;/b&gt; to control completely the output behavior. Users of &lt;b&gt;podchecker&lt;/b&gt; (the script) get the well-known behavior.</source>
          <target state="translated">PodParser-1.24以降、&lt;b&gt;Pod :: Checker&lt;/b&gt;モジュールは&lt;b&gt;poderror&lt;/b&gt;メソッドのみを使用してエラーと警告を出力します。要約出力（たとえば、「Pod syntax OK」）はモジュールから削除され、&lt;b&gt;podchecker&lt;/b&gt;（スクリプト）に含まれています。これにより、&lt;b&gt;Pod :: Checkerの&lt;/b&gt;ユーザーは出力動作を完全に制御できます。&lt;b&gt;ポッドチェッカー&lt;/b&gt;（スクリプト）のユーザーは、よく知られた動作をします。</target>
        </trans-unit>
        <trans-unit id="25c4aa2f7c7ea22cd03f6256eb0cf383feb5378c" translate="yes" xml:space="preserve">
          <source>Since Storable version 2.05, CODE references may be serialized with the help of &lt;a href=&quot;B::Deparse&quot;&gt;B::Deparse&lt;/a&gt;. To enable this feature, set &lt;code&gt;$Storable::Deparse&lt;/code&gt; to a true value. To enable deserialization, &lt;code&gt;$Storable::Eval&lt;/code&gt; should be set to a true value. Be aware that deserialization is done through &lt;code&gt;eval&lt;/code&gt;, which is dangerous if the Storable file contains malicious data. You can set &lt;code&gt;$Storable::Eval&lt;/code&gt; to a subroutine reference which would be used instead of &lt;code&gt;eval&lt;/code&gt;. See below for an example using a &lt;a href=&quot;safe&quot;&gt;Safe&lt;/a&gt; compartment for deserialization of CODE references.</source>
          <target state="translated">Storableバージョン2.05以降、CODE参照は&lt;a href=&quot;B::Deparse&quot;&gt;B :: Deparseを使用してシリアル化でき&lt;/a&gt;ます。この機能を有効にするには、 &lt;code&gt;$Storable::Deparse&lt;/code&gt; をtrueの値に設定します。デシリアライズを有効にするには、 &lt;code&gt;$Storable::Eval&lt;/code&gt; をtrue値に設定する必要があります。デシリアライズは &lt;code&gt;eval&lt;/code&gt; を介して行われることに注意してください。これは、Storableファイルに悪意のあるデータが含まれている場合は危険です。 &lt;code&gt;$Storable::Eval&lt;/code&gt; を、 &lt;code&gt;eval&lt;/code&gt; の代わりに使用されるサブルーチン参照に設定できます。CODE参照の逆シリアル化に&lt;a href=&quot;safe&quot;&gt;Safe&lt;/a&gt;コンパートメントを使用する例については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="c62ae1b79550d7e8d8b071446dadbd144fa9a44a" translate="yes" xml:space="preserve">
          <source>Since Storable version 2.05, CODE references may be serialized with the help of &lt;a href=&quot;b/deparse&quot;&gt;B::Deparse&lt;/a&gt;. To enable this feature, set &lt;code&gt;$Storable::Deparse&lt;/code&gt; to a true value. To enable deserialization, &lt;code&gt;$Storable::Eval&lt;/code&gt; should be set to a true value. Be aware that deserialization is done through &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, which is dangerous if the Storable file contains malicious data. You can set &lt;code&gt;$Storable::Eval&lt;/code&gt; to a subroutine reference which would be used instead of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. See below for an example using a &lt;a href=&quot;safe&quot;&gt;Safe&lt;/a&gt; compartment for deserialization of CODE references.</source>
          <target state="translated">Storableバージョン2.05以降、CODE参照は&lt;a href=&quot;b/deparse&quot;&gt;B :: Deparse&lt;/a&gt;を使用してシリアル化される場合があります。この機能を有効にするには、 &lt;code&gt;$Storable::Deparse&lt;/code&gt; をtrue値に設定します。逆シリアル化を有効にするには、 &lt;code&gt;$Storable::Eval&lt;/code&gt; をtrue値に設定する必要があります。逆シリアル化は &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; を介して行われることに注意してください。これは、Storableファイルに悪意のあるデータが含まれている場合は危険です。 &lt;code&gt;$Storable::Eval&lt;/code&gt; を、 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; の代わりに使用されるサブルーチン参照に設定できます。CODE参照の逆シリアル化に&lt;a href=&quot;safe&quot;&gt;セーフ&lt;/a&gt;コンパートメントを使用する例については、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="c88a8ad5ec93e93fc48a98cd339628a0d0dbcb2e" translate="yes" xml:space="preserve">
          <source>Since UTF-7 is a 7-bit (re)encoded version of UTF-16BE, It is not part of Unicode's Character Encoding Scheme. It is separately implemented in Encode::Unicode::UTF7. For details see &lt;a href=&quot;Encode::Unicode::UTF7&quot;&gt;Encode::Unicode::UTF7&lt;/a&gt;.</source>
          <target state="translated">UTF-7はUTF-16BEの7ビット（再）エンコードバージョンであるため、Unicodeの文字エンコードスキームの一部ではありません。Encode :: Unicode :: UTF7に個別に実装されています。詳細については、&lt;a href=&quot;Encode::Unicode::UTF7&quot;&gt;Encode :: Unicode :: UTF7を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f0441a16b2e74d4d0e51c5a02d816d3fcef92571" translate="yes" xml:space="preserve">
          <source>Since UTF-7 is a 7-bit (re)encoded version of UTF-16BE, It is not part of Unicode's Character Encoding Scheme. It is separately implemented in Encode::Unicode::UTF7. For details see &lt;a href=&quot;unicode/utf7&quot;&gt;Encode::Unicode::UTF7&lt;/a&gt;.</source>
          <target state="translated">UTF-7はUTF-16BEの7ビット（再）エンコードバージョンであるため、Unicodeの文字エンコードスキームの一部ではありません。Encode :: Unicode :: UTF7で個別に実装されています。詳細については、&lt;a href=&quot;unicode/utf7&quot;&gt;Encode :: Unicode :: UTF7を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2162d18e9f113918db80108542b383e4720b61a0" translate="yes" xml:space="preserve">
          <source>Since Unicode rules are not defined on these code points, if a Unicode-defined operation is done on them, Perl uses what we believe are sensible rules, while generally warning, using the &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; category. For example, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc(&quot;\x{11_0000}&quot;)&lt;/a&gt;&lt;/code&gt; will generate such a warning, returning the input parameter as its result, since Perl defines the uppercase of every non-Unicode code point to be the code point itself. (All the case changing operations, not just uppercasing, work this way.)</source>
          <target state="translated">Unicodeルールはこれらのコードポイントで定義されていないため、Unicode定義の操作がそれらに対して行われる場合、Perlは一般に警告しながら、 &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; カテゴリを使用して、賢明なルールであると私たちが信じるものを使用します。たとえば、 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc(&quot;\x{11_0000}&quot;)&lt;/a&gt;&lt;/code&gt; はそのような警告を生成し、Perlはすべての非Unicodeコードポイントの大文字をコードポイント自体として定義するため、その結果として入力パラメーターを返します。（大文字変換だけでなく、すべての大文字小文字変換操作がこのように機能します。）</target>
        </trans-unit>
        <trans-unit id="e37eae9f276840962a41c4b116e9f1cbc6df456a" translate="yes" xml:space="preserve">
          <source>Since Unicode rules are not defined on these code points, if a Unicode-defined operation is done on them, Perl uses what we believe are sensible rules, while generally warning, using the &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; category. For example, &lt;code&gt;uc(&quot;\x{11_0000}&quot;)&lt;/code&gt; will generate such a warning, returning the input parameter as its result, since Perl defines the uppercase of every non-Unicode code point to be the code point itself. (All the case changing operations, not just uppercasing, work this way.)</source>
          <target state="translated">これらのコードポイントではUnicodeルールが定義されていないため、Unicode定義の操作が実行されると、Perlは賢明なルールであると思われるものを使用しますが、一般的には &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; カテゴリを使用して警告します。たとえば、 &lt;code&gt;uc(&quot;\x{11_0000}&quot;)&lt;/code&gt; はそのような警告を生成し、結果として入力パラメータを返します。これは、Perlがすべての非Unicodeコードポイントの大文字をコードポイント自体として定義しているためです。（大文字だけでなく、すべてのケース変更操作はこのように機能します。）</target>
        </trans-unit>
        <trans-unit id="7285a56d9c4d213c9ad280d3cdcf143edd27d7d8" translate="yes" xml:space="preserve">
          <source>Since VMS keeps track of files according to a different scheme than Unix, it's not really possible to represent the file's ID in the &lt;code&gt;st_dev&lt;/code&gt; and &lt;code&gt;st_ino&lt;/code&gt; fields of a &lt;code&gt;struct &lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; . Perl tries its best, though, and the values it uses are pretty unlikely to be the same for two different files. We can't guarantee this, though, so caveat scriptor.</source>
          <target state="translated">VMSはUnixとは異なるスキームに従ってファイルを追跡しているため、 &lt;code&gt;struct &lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;functions/stat&quot;&gt;statの&lt;/a&gt; &lt;code&gt;st_dev&lt;/code&gt; および &lt;code&gt;st_ino&lt;/code&gt; フィールドでファイルのIDを表すことは実際には不可能です。ただし、Perlは最善を尽くします。Perlが使用する値は、2つの異なるファイルで同じになることはほとんどありません。ただし、これを保証することはできませんので、注意してください。</target>
        </trans-unit>
        <trans-unit id="f97165e0cc621ecf8ede47b3bb388f24e3bbd9ef" translate="yes" xml:space="preserve">
          <source>Since VMS keeps track of files according to a different scheme than Unix, it's not really possible to represent the file's ID in the &lt;code&gt;st_dev&lt;/code&gt; and &lt;code&gt;st_ino&lt;/code&gt; fields of a &lt;code&gt;struct stat&lt;/code&gt;. Perl tries its best, though, and the values it uses are pretty unlikely to be the same for two different files. We can't guarantee this, though, so caveat scriptor.</source>
          <target state="translated">VMSは、UNIXとは異なる方式に従ってファイルを追跡しますので、それは、ファイルのIDを表すために実際にことはできません &lt;code&gt;st_dev&lt;/code&gt; フィールドと &lt;code&gt;st_ino&lt;/code&gt; の分野 &lt;code&gt;struct stat&lt;/code&gt; 。ただし、Perlは最善を尽くしており、使用する値が2つの異なるファイルで同じになる可能性はほとんどありません。ただし、これを保証することはできませんので、scriptorに注意してください。</target>
        </trans-unit>
        <trans-unit id="5c5a9b6174ae871df152be709da101732e21f32c" translate="yes" xml:space="preserve">
          <source>Since Windows has nothing as simple as an executable bit, we check the file extension.</source>
          <target state="translated">Windowsには実行ビットのような単純なものはないので、ファイルの拡張子を確認します。</target>
        </trans-unit>
        <trans-unit id="fd9730169823a0770803a5925e2496af06ca17b1" translate="yes" xml:space="preserve">
          <source>Since a TODO test does not need a reason, this function can return an empty string even when inside a TODO block. Use &lt;code&gt;$Test-&amp;gt;in_todo&lt;/code&gt; to determine if you are currently inside a TODO block.</source>
          <target state="translated">TODOテストは理由を必要としないため、この関数はTODOブロック内にある場合でも空の文字列を返す可能性があります。 &lt;code&gt;$Test-&amp;gt;in_todo&lt;/code&gt; を使用して、現在TODOブロック内にいるかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="9ae46893bafbcba3b5e81c0b6866dc9c42e9443c" translate="yes" xml:space="preserve">
          <source>Since a wide character does not fit into a byte, the Digest::SHA routines croak if they encounter one. Whereas if a Unicode string contains no wide characters, the module accepts it quite happily. The following code illustrates the two cases:</source>
          <target state="translated">ワイド文字はバイトに収まらないので、ダイジェスト::SHA ルーチンは、ワイド文字に遭遇すると悲鳴を上げます。一方、Unicode 文字列にワイド文字が含まれていない場合、モジュールは喜んでそれを受け入れます。以下のコードは、この2つのケースを示しています。</target>
        </trans-unit>
        <trans-unit id="cf5ecd8beadbfc6894afc9b33f8c568a935ac82c" translate="yes" xml:space="preserve">
          <source>Since all &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; directives are executed at compile-time, the only way to change overloading during run-time is to</source>
          <target state="translated">すべての &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ディレクティブはコンパイル時に実行されるため、実行時にオーバーロードを変更する唯一の方法は、</target>
        </trans-unit>
        <trans-unit id="993a10b235330ad1f20f4c41c806f9d2c3a4329f" translate="yes" xml:space="preserve">
          <source>Since all &lt;code&gt;use&lt;/code&gt; directives are executed at compile-time, the only way to change overloading during run-time is to</source>
          <target state="translated">すべての &lt;code&gt;use&lt;/code&gt; ディレクティブはコンパイル時に実行されるため、実行時にオーバーロードを変更する唯一の方法は、</target>
        </trans-unit>
        <trans-unit id="121e9d461e86db932f5cbbcefdf834cbc71c32ee" translate="yes" xml:space="preserve">
          <source>Since all numbers are not objects, you can use all functions that are part of the BigInt or BigFloat API. It is wise to use only the bxxx() notation, and not the fxxx() notation, though. This makes you independent on the fact that the underlying object might morph into a different class than BigFloat.</source>
          <target state="translated">すべての数値はオブジェクトではないので、BigInt または BigFloat API の一部であるすべての関数を使用できます。ただし、fxxx()記法ではなく bxxx()記法のみを使用するのが賢明です。これにより、基礎となるオブジェクトが BigFloat とは異なるクラスに変形する可能性があるという事実から独立しています。</target>
        </trans-unit>
        <trans-unit id="a8ab3cbd0a89b8927ddf254335c455bf7a9e0853" translate="yes" xml:space="preserve">
          <source>Since all numbers are now objects, you can use all functions that are part of the BigInt API. You can only use the bxxx() notation, and not the fxxx() notation, though.</source>
          <target state="translated">すべての数値がオブジェクトになったので、BigInt API の一部であるすべての関数を使用できます。ただし、使用できるのは bxxx()記法のみで、fxxx()記法は使用できません。</target>
        </trans-unit>
        <trans-unit id="4e2f7ef257d55f0fed05e16ea09bffefc9e8b92c" translate="yes" xml:space="preserve">
          <source>Since all numbers are now objects, you can use all functions that are part of the BigInt or BigFloat API. It is wise to use only the bxxx() notation, and not the fxxx() notation, though. This makes it possible that the underlying object might morph into a different class than BigFloat.</source>
          <target state="translated">すべての数値がオブジェクトになったので、BigInt または BigFloat API の一部であるすべての関数を使用できます。ただし、fxxx()記法ではなく bxxx()記法のみを使用するのが賢明です。これにより、基礎となるオブジェクトが BigFloat とは異なるクラスに変化する可能性があります。</target>
        </trans-unit>
        <trans-unit id="6baa6e390f30e8a9126d448dab3ed477bfa1776f" translate="yes" xml:space="preserve">
          <source>Since an expression &lt;code&gt;&quot;ab$cd,,&quot;&lt;/code&gt; is just a shortcut for &lt;code&gt;'ab' . $cd . ',,'&lt;/code&gt; , it is expected that overloaded constant strings are equipped with reasonable overloaded catenation operator, otherwise absurd results will result. Similarly, negative numbers are considered as negations of positive constants.</source>
          <target state="translated">&lt;code&gt;&quot;ab$cd,,&quot;&lt;/code&gt; という表現は &lt;code&gt;'ab' . $cd . ',,'&lt;/code&gt; 単なるショートカットです。$ cd。',,'、オーバーロードされた定数文字列には、合理的なオーバーロードされた連結演算子が装備されていると予想されます。そうでない場合、不合理な結果が生じます。同様に、負の数は正の定数の否定と見なされます。</target>
        </trans-unit>
        <trans-unit id="9eab2e484706387d3cb0dc782cf2ac19206003e5" translate="yes" xml:space="preserve">
          <source>Since an expression &lt;code&gt;&quot;ab$cd,,&quot;&lt;/code&gt; is just a shortcut for &lt;code&gt;'ab' . $cd . ',,'&lt;/code&gt;, it is expected that overloaded constant strings are equipped with reasonable overloaded catenation operator, otherwise absurd results will result. Similarly, negative numbers are considered as negations of positive constants.</source>
          <target state="translated">式 &lt;code&gt;&quot;ab$cd,,&quot;&lt;/code&gt; は &lt;code&gt;'ab' . $cd . ',,'&lt;/code&gt; ショートカットにすぎないためです。$ cd。'、、'、オーバーロードされた定数文字列には、適切なオーバーロードされたカテネーション演算子が装備されていると予想されます。そうしないと、不条理な結果になります。同様に、負の数は正の定数の否定と見なされます。</target>
        </trans-unit>
        <trans-unit id="6ad22ba0685e5d4fac9ab43140e5e8b95922e320" translate="yes" xml:space="preserve">
          <source>Since any scalar can be passed as a pattern, it's possible to implement an engine that does something with an array (&lt;code&gt;&quot;ook&quot; =~ [ qw/ eek
hlagh / ]&lt;/code&gt; ) or with the non-stringified form of a compiled regular expression (&lt;code&gt;&quot;ook&quot; =~ qr/eek/&lt;/code&gt; ). Perl's own engine will always stringify everything using the snippet above, but that doesn't mean other engines have to.</source>
          <target state="translated">任意のスカラーをパターンとして渡すことができるため、配列（ &lt;code&gt;&quot;ook&quot; =~ [ qw/ eek hlagh / ]&lt;/code&gt; ）または文字列化されていない形式のコンパイル済み正規表現（ &lt;code&gt;&quot;ook&quot; =~ qr/eek/&lt;/code&gt; を使用して何かを実行するエンジンを実装できます。 ook &quot;=〜qr / eek /）。Perl自身のエンジンは常に上記のスニペットを使用してすべてを文字列化しますが、それは他のエンジンがそうする必要があることを意味しません。</target>
        </trans-unit>
        <trans-unit id="a96aedcf3c01c8994f2ad1304c88bcd0b989eae9" translate="yes" xml:space="preserve">
          <source>Since any scalar can be passed as a pattern, it's possible to implement an engine that does something with an array (&lt;code&gt;&quot;ook&quot; =~ [ qw/ eek hlagh / ]&lt;/code&gt;) or with the non-stringified form of a compiled regular expression (&lt;code&gt;&quot;ook&quot; =~ qr/eek/&lt;/code&gt;). Perl's own engine will always stringify everything using the snippet above, but that doesn't mean other engines have to.</source>
          <target state="translated">任意のスカラーをパターンとして渡すことができるため、配列（ &lt;code&gt;&quot;ook&quot; =~ [ qw/ eek hlagh / ]&lt;/code&gt; ）またはコンパイルされた正規表現の非文字列形式（&quot;）で何かを実行するエンジンを実装できます &lt;code&gt;&quot;ook&quot; =~ qr/eek/&lt;/code&gt; ）。Perl独自のエンジンは常に上記のスニペットを使用してすべてを文字列化しますが、それは他のエンジンがそうしなければならないという意味ではありません。</target>
        </trans-unit>
        <trans-unit id="641d084a3985af991bd9e2608e23022b03d9ab2f" translate="yes" xml:space="preserve">
          <source>Since blessed objects are actually stored as RV's, it is useful to use the typemap features to preprocess parameters and extract the actual SV stored within the blessed RV. See the sample for T_PTROBJ_SPECIAL below.</source>
          <target state="translated">blessedオブジェクトは実際にはRVとして格納されているので、タイプマップ機能を使ってパラメータを前処理し、bessed RV内に格納されている実際のSVを抽出すると便利です。以下の T_PTROBJ_SPECIAL のサンプルを参照してください。</target>
        </trans-unit>
        <trans-unit id="8c4a595ff52b120e783068a746cfa5bbb3e02fd1" translate="yes" xml:space="preserve">
          <source>Since changing a slice changes the original array or hash that it's slicing, a &lt;code&gt;foreach&lt;/code&gt; construct will alter some--or even all--of the values of the array or hash.</source>
          <target state="translated">スライスを変更すると、スライスする元の配列またはハッシュが変更されるため、 &lt;code&gt;foreach&lt;/code&gt; 構文は、配列またはハッシュの値の一部またはすべてを変更します。</target>
        </trans-unit>
        <trans-unit id="fe77918163189e19fb5ee32ad02fe79f3b55c3d3" translate="yes" xml:space="preserve">
          <source>Since code that runs both with and without threads is usually pretty messy, it's best to isolate the thread-specific code in its own module. In our example above, that's what &lt;code&gt;MyMod_threaded&lt;/code&gt; is, and it's only imported if we're running on a threaded Perl.</source>
          <target state="translated">スレッドありとスレッドなしの両方で実行されるコードは通常かなり面倒なので、スレッド固有のコードを独自のモジュールに分離するのが最善です。上記の例では、これが &lt;code&gt;MyMod_threaded&lt;/code&gt; であり、スレッド化されたPerlで実行している場合にのみインポートされます。</target>
        </trans-unit>
        <trans-unit id="7cbe078e4c38d00728f285597cf545219cabca7e" translate="yes" xml:space="preserve">
          <source>Since cygwin-1.7 pathnames are UTF-8 encoded.</source>
          <target state="translated">cygwin-1.7のパス名はUTF-8でエンコードされているので。</target>
        </trans-unit>
        <trans-unit id="266d3a18d9d36b211495f4b1c929d7f21c8d9c1c" translate="yes" xml:space="preserve">
          <source>Since cygwin-1.7 textmounts are deprecated and strongly discouraged.</source>
          <target state="translated">cygwin-1.7以降、テキストマウントは非推奨であり、強く推奨されていません。</target>
        </trans-unit>
        <trans-unit id="d1be23ed029f3a9d2b3315834beff1a066fe092b" translate="yes" xml:space="preserve">
          <source>Since environment variables are normally in all uppercase, no additional special formatting is generally needed; they're glaring enough as it is.</source>
          <target state="translated">環境変数は通常すべて大文字で書かれているので、一般的には特別な書式設定は必要ありません。</target>
        </trans-unit>
        <trans-unit id="7b1f94f3541d2fa04906c8d0560fd0adccde7ea8" translate="yes" xml:space="preserve">
          <source>Since evaluation of the translation function (see &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;&quot;CUSTOM TRANSLATORS&quot;&lt;/a&gt;) happens in the middle of compilation (of a string literal), the translation function should not do any &lt;code&gt;eval&lt;/code&gt;s or &lt;code&gt;require&lt;/code&gt;s. This restriction should be lifted (but is low priority) in a future version of Perl.</source>
          <target state="translated">変換関数（&lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;「CUSTOMTRANSLATORS」を&lt;/a&gt;参照）の評価は（文字列リテラルの）コンパイルの途中で行われるため、変換関数は &lt;code&gt;eval&lt;/code&gt; を実行したり &lt;code&gt;require&lt;/code&gt; sを要求したりしないでください。この制限は、Perlの将来のバージョンで解除される必要があります（ただし、優先度は低くなります）。</target>
        </trans-unit>
        <trans-unit id="af76bf7b4202770a0de3b09fc13dec72dab7c4f4" translate="yes" xml:space="preserve">
          <source>Since evaluation of the translation function (see &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;CUSTOM TRANSLATORS&lt;/a&gt;) happens in the middle of compilation (of a string literal), the translation function should not do any &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;s or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;s. This restriction should be lifted (but is low priority) in a future version of Perl.</source>
          <target state="translated">翻訳関数（&lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;CUSTOM TRANSLATORSを&lt;/a&gt;参照）の評価は（文字列リテラルの）コンパイルの途中で行われるため、翻訳関数は &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; やsを &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ません。この制限は、Perlの将来のバージョンで解除する必要があります（ただし、優先度は低くなります）。</target>
        </trans-unit>
        <trans-unit id="e702e67c36d5f56f32c4ca887c029adc55bb2d25" translate="yes" xml:space="preserve">
          <source>Since file associations don't work everywhere, and there are reportedly bugs with file associations where it does work, the old method of wrapping the perl script to make it look like a regular batch file to the OS, may be used. The install process makes available the &quot;pl2bat.bat&quot; script which can be used to wrap perl scripts into batch files. For example:</source>
          <target state="translated">ファイルの関連付けはどこでも動作するわけではなく、動作する場所ではファイルの関連付けにバグがあると報告されていますので、Perl スクリプトをラップして OS に通常のバッチファイルのように見せる昔からの方法を使うことができます。インストールプロセスでは &quot;pl2bat.bat&quot; スクリプトが利用可能になり、これを使って perl スクリプトをバッチファイルにラップすることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="23fd0e0c0c88af650bd14da915c09ac6e76b1837" translate="yes" xml:space="preserve">
          <source>Since hash keys are strings, the default normalizer will not distinguish between &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and the empty string. It also won't work when the function's arguments are references. For example, consider a function &lt;code&gt;g&lt;/code&gt; which gets two arguments: A number, and a reference to an array of numbers:</source>
          <target state="translated">ハッシュキーは文字列なので、デフォルトのノーマライザは &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; と空の文字列を区別しません。また、関数の引数が参照の場合も機能しません。たとえば、2つの引数を取得する関数 &lt;code&gt;g&lt;/code&gt; について考えてみましょう。数値と、数値の配列への参照です。</target>
        </trans-unit>
        <trans-unit id="5436c585986115252a0eaae5572a50baa0e6e228" translate="yes" xml:space="preserve">
          <source>Since hash keys are strings, the default normalizer will not distinguish between &lt;code&gt;undef&lt;/code&gt; and the empty string. It also won't work when the function's arguments are references. For example, consider a function &lt;code&gt;g&lt;/code&gt; which gets two arguments: A number, and a reference to an array of numbers:</source>
          <target state="translated">ハッシュキーは文字列であるため、デフォルトのノーマライザーは &lt;code&gt;undef&lt;/code&gt; と空の文字列を区別しません。また、関数の引数が参照である場合も機能しません。たとえば、2つの引数を取得する関数 &lt;code&gt;g&lt;/code&gt; について考えてみます。数値と数値の配列への参照です。</target>
        </trans-unit>
        <trans-unit id="fa1b02458a611387371114bfc83a2b6bef610aa1" translate="yes" xml:space="preserve">
          <source>Since in this example only the hostname was used, the redundant conversion of the port number into a service name may be omitted by passing the &lt;code&gt;NIx_NOSERV&lt;/code&gt; flag.</source>
          <target state="translated">この例ではホスト名のみが使用されているため、 &lt;code&gt;NIx_NOSERV&lt;/code&gt; フラグを渡すことで、ポート番号からサービス名への冗長な変換を省略できます。</target>
        </trans-unit>
        <trans-unit id="43ba5f496d72ffff6bead4e713df055d0751d289" translate="yes" xml:space="preserve">
          <source>Since it is an actual &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; (not a &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;),</source>
          <target state="translated">これは実際に &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; あるため（必須ではありません）、</target>
        </trans-unit>
        <trans-unit id="55f0899d2eb4523813b05345316dcef5758fc23e" translate="yes" xml:space="preserve">
          <source>Since it is an actual &lt;code&gt;do&lt;/code&gt; (not a &lt;code&gt;require&lt;/code&gt;),</source>
          <target state="translated">これは実際の &lt;code&gt;do&lt;/code&gt; （ &lt;code&gt;require&lt;/code&gt; ません）なので、</target>
        </trans-unit>
        <trans-unit id="bb621853d8928b75d75f89c40a84cc2ef109eca4" translate="yes" xml:space="preserve">
          <source>Since it is based on Linux, the NAS can run many popular Linux software packages, including Perl. In fact, Synology provides a ready-to-install package for Perl, depending on the version of DSM the installed perl ranges from 5.8.6 on DSM-4.3 to 5.24.0 on DSM-6.1.</source>
          <target state="translated">NAS は Linux をベースにしているため、Perl を含む多くの一般的な Linux ソフトウェア パッケージを実行することができます。実際、Synology は Perl 用にすぐにインストールできるパッケージを提供しています。インストールされている Perl は DSM のバージョンによって異なりますが、DSM-4.3 の 5.8.6 から DSM-6.1 の 5.24.0 までの範囲です。</target>
        </trans-unit>
        <trans-unit id="0d7acf7de7efee5f314675d9545729adcf4f4695" translate="yes" xml:space="preserve">
          <source>Since it is only at the compilation stage that the operator mask applies, controlled access to potentially unsafe operations can be achieved by having a handle to a wrapper subroutine (written outside the compartment) placed into the compartment. For example,</source>
          <target state="translated">オペレータマスクが適用されるのはコンパイルの段階だけなので、安全でない可能性のある操作への制御されたアクセスは、(コンパートメントの外側に書かれた)ラッパーサブルーチンのハンドルをコンパートメントの中に配置することで実現できます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="1f11ca56ce1f8e288941a46d45decb0b96762c16" translate="yes" xml:space="preserve">
          <source>Since it's a common mistake to use &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;, Perl warns you if &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt; is called in void context and if there is a following statement that isn't &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#warn-LIST&quot;&gt;&lt;code&gt;warn&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#exit-EXPR&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt; (if &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; are enabled--but you always do that, right?). If you</source>
          <target state="translated">&lt;a href=&quot;#system-LIST&quot;&gt; &lt;code&gt;system&lt;/code&gt; &lt;/a&gt;代わりに&lt;a href=&quot;#exec-LIST&quot;&gt; &lt;code&gt;exec&lt;/code&gt; &lt;/a&gt;を使用することはよくある間違いなので、Perlは、&lt;a href=&quot;#exec-LIST&quot;&gt; &lt;code&gt;exec&lt;/code&gt; &lt;/a&gt;がvoidコンテキストで呼び出された場合、および&lt;a href=&quot;#die-LIST&quot;&gt; &lt;code&gt;die&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#warn-LIST&quot;&gt; &lt;code&gt;warn&lt;/code&gt; &lt;/a&gt;、または&lt;a href=&quot;#exit-EXPR&quot;&gt; &lt;code&gt;exit&lt;/code&gt; &lt;/a&gt;ではない次のステートメントがある場合に&lt;a href=&quot;warnings&quot;&gt;警告します&lt;/a&gt;（警告が有効になっている場合-ただし、常に実行します）それでしょ？）もし、あんたが</target>
        </trans-unit>
        <trans-unit id="194e3b48a27a3bdaa4b431c05b89584d736f7041" translate="yes" xml:space="preserve">
          <source>Since it's a common mistake to use &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, Perl warns you if &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; is called in void context and if there is a following statement that isn't &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; (if &lt;code&gt;-w&lt;/code&gt; is set--but you always do that, right?). If you</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ではなく &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; を使用するのはよくある間違いであるため、 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; がvoidコンテキストで呼び出され、次のステートメントが &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; でない場合（ &lt;code&gt;-w&lt;/code&gt; が設定されている場合）、Perlは警告しますが、常にそうですか？）もし、あんたが</target>
        </trans-unit>
        <trans-unit id="84dfc8fed05280b5766bcde26ffe3ad58754f68f" translate="yes" xml:space="preserve">
          <source>Since it's a common mistake to use &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, Perl warns you if &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; is called in void context and if there is a following statement that isn't &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; (if &lt;code&gt;-w&lt;/code&gt; is set--but you always do that, right?). If you</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ではなく &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; を使用するのはよくある間違いであるため、 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; がvoidコンテキストで呼び出され、次のステートメントが &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; でない場合（ &lt;code&gt;-w&lt;/code&gt; が設定されている場合）、Perlは警告しますが、常にそうですか？）もし、あんたが</target>
        </trans-unit>
        <trans-unit id="738084392e8e6e74486d375f063b4666c3458a7c" translate="yes" xml:space="preserve">
          <source>Since just passing an SV to an XS function and copying the data of the SV is not enough to copy the UTF8 flags, even less right is just passing a &lt;code&gt;char *&lt;/code&gt; to an XS function.</source>
          <target state="translated">SVをXS関数に渡してSVのデータをコピーするだけではUTF8フラグをコピーするのに十分ではないので、 &lt;code&gt;char *&lt;/code&gt; をXS関数に渡すだけでは不十分です。</target>
        </trans-unit>
        <trans-unit id="b9469e3eb840b801f9d7d7208ec99b06d836b6ea" translate="yes" xml:space="preserve">
          <source>Since kernel threading can interrupt a thread at any time, they will uncover some of the implicit locking assumptions you may make in your program. For example, something as simple as &lt;code&gt;$x = $x + 2&lt;/code&gt; can behave unpredictably with kernel threads if &lt;code&gt;$x&lt;/code&gt; is visible to other threads, as another thread may have changed &lt;code&gt;$x&lt;/code&gt; between the time it was fetched on the right hand side and the time the new value is stored.</source>
          <target state="translated">カーネルスレッドはいつでもスレッドに割り込むことができるため、プログラムで行う可能性のある暗黙のロックの仮定の一部が明らかになります。以下のような簡単な例としては、何か &lt;code&gt;$x = $x + 2&lt;/code&gt; あれば、カーネルスレッドと予期しない動作することができる &lt;code&gt;$x&lt;/code&gt; 別のスレッドが変更されていてもよいように、他のスレッドに見える &lt;code&gt;$x&lt;/code&gt; それが右側にフェッチされた時刻との間新しい値が保存される時間。</target>
        </trans-unit>
        <trans-unit id="50bf4cd3ab25a16dfb39690f40c89ca9d71697ee" translate="yes" xml:space="preserve">
          <source>Since many pieces of code create tiny subroutines consisting of only a few ops, and since a huge slab would be quite a bit of baggage for those to carry around, the first slab is always very small. To avoid allocating too many slabs for a single CV, each subsequent slab is twice the size of the previous.</source>
          <target state="translated">多くのコードの断片は,わずか数個の操作からなる小さなサブルーチンを作成するので,巨大なスラブは持ち歩くにはかなりの荷物になるので,最初のスラブは常に非常に小さいものになります.1つのCVにあまりにも多くのスラブを割り当てるのを避けるため,後続のスラブはそれぞれ前のスラブの2倍の大きさになります.</target>
        </trans-unit>
        <trans-unit id="c3c7d09052cf4af0cf4ad320357c5a1a11966392" translate="yes" xml:space="preserve">
          <source>Since numbers are actually objects, you can call all the usual methods from BigInt/BigFloat on them. This even works to some extent on expressions:</source>
          <target state="translated">数字は実際にはオブジェクトなので、BigInt/BigFloatの通常のメソッドをすべて呼び出すことができます。これは式に対してもある程度機能します。</target>
        </trans-unit>
        <trans-unit id="ae2a46b8ade0fb9460587cc2799fe61eb4a8fb37" translate="yes" xml:space="preserve">
          <source>Since perl 5.17.1</source>
          <target state="translated">perl 5.17.1以降</target>
        </trans-unit>
        <trans-unit id="3f51453ac56d21d59ae3e879a25ac51097e95502" translate="yes" xml:space="preserve">
          <source>Since perl does not (yet?) support constant objects, these constants are in seconds only, so you cannot, for example, do this: &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; ONE_WEEK-&amp;gt;minutes;&lt;/code&gt;</source>
          <target state="translated">（？まだ）perlがないので、あなたが、たとえば、これを行うことはできませんので、サポート定数オブジェクト、これらの定数は、わずか数秒である： &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; ONE_WEEK-&amp;gt;minutes;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cab6e87a3c1e5785b11343a6d4dd9e12fc5fa718" translate="yes" xml:space="preserve">
          <source>Since perl does not (yet?) support constant objects, these constants are in seconds only, so you cannot, for example, do this: &lt;code&gt;print ONE_WEEK-&amp;gt;minutes;&lt;/code&gt;</source>
          <target state="translated">perlは（まだ？）定数オブジェクトをサポートしていないため、これらの定数は秒単位であるため、たとえば、次のようにすることはできません &lt;code&gt;print ONE_WEEK-&amp;gt;minutes;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ea4faada9587774e63ccd6c739ed955f5067def" translate="yes" xml:space="preserve">
          <source>Since pi &amp;asymp; 355/116 is only accurate to 6 decimal places, you would want to say:</source>
          <target state="translated">pi&amp;asymp;355/ 116は小数点以下6桁までしか正確ではないため、次のように言います。</target>
        </trans-unit>
        <trans-unit id="f6206d48617efe1643080f044370ee3db2757b71" translate="yes" xml:space="preserve">
          <source>Since release 1.77, CPAN.pm has been able to verify cryptographically signed module distributions using Module::Signature. The CPAN modules can be signed by their authors, thus giving more security. The simple unsigned MD5 checksums that were used before by CPAN protect mainly against accidental file corruption.</source>
          <target state="translated">リリース 1.77 以降、CPAN.pm は Module::Signature を使って暗号的に署名されたモジュール配布物を検証できるようになりました。CPAN モジュールはその作者によって署名されることができるので、より多くのセキュリティが得られます。CPAN が以前に使用していた単純な符号なし MD5 チェックサムは、主に偶発的なファイル破損から保護します。</target>
        </trans-unit>
        <trans-unit id="f410d2ff83f136d497487286db5d2eccb910e974" translate="yes" xml:space="preserve">
          <source>Since some operations can be automatically generated from others, there is a minimal set of operations that need to be overloaded in order to have the complete set of overloaded operations at one's disposal. Of course, the autogenerated operations may not do exactly what the user expects. The minimal set is:</source>
          <target state="translated">いくつかの操作は他の操作から自動的に生成されることがあるので、自分の自由にオーバーロードされた操作の完全なセットを持つために、オーバーロードされる必要がある操作の最小限のセットがあります。もちろん、自動生成された操作は、ユーザが期待している通りに動作しないこともあります。最小限のセットとは</target>
        </trans-unit>
        <trans-unit id="9e13ee98073f6b6ff77b6bcc87f449d4c9298e6d" translate="yes" xml:space="preserve">
          <source>Since static extensions are incorporated directly into</source>
          <target state="translated">静的拡張機能は</target>
        </trans-unit>
        <trans-unit id="a88aba659efeb2d72344fd5945ed041580ceab14" translate="yes" xml:space="preserve">
          <source>Since storage is performed recursively, you might want to stuff references to objects that share a lot of common data into a single array or hash table, and then store that object. That way, when you retrieve back the whole thing, the objects will continue to share what they originally shared.</source>
          <target state="translated">ストレージは再帰的に実行されるので、多くの共通データを共有するオブジェクトへの参照を単一の配列やハッシュテーブルに詰め込んで、そのオブジェクトを格納したいと思うかもしれません。そうすれば、全体を取り出すときに、オブジェクトは元々共有していたものを共有し続けることができます。</target>
        </trans-unit>
        <trans-unit id="9ba4735b13fee2b9416d8bafb7be0fc636ca00de" translate="yes" xml:space="preserve">
          <source>Since subroutines implementing assignment operators are not required to modify their operands (see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;&quot;Overloadable Operations&quot;&lt;/a&gt; above), we do not need anything special to make &lt;code&gt;+=&lt;/code&gt; and friends work, besides adding these operators to %subr and defining a copy constructor (needed since Perl has no way to know that the implementation of &lt;code&gt;'+='&lt;/code&gt; does not mutate the argument - see &lt;a href=&quot;#Copy-Constructor&quot;&gt;&quot;Copy Constructor&quot;&lt;/a&gt;).</source>
          <target state="translated">代入演算子を実装するサブルーチンはオペランドを変更する必要がないため（上記の&lt;a href=&quot;#Overloadable-Operations&quot;&gt;「オーバーロード可能な操作」を&lt;/a&gt;参照）、これらの演算子を％subrに追加し、コピーコンストラクターを定義する以外に、 &lt;code&gt;+=&lt;/code&gt; やフレンドを機能させるために特別なことは何も必要ありません（ Perlには、 &lt;code&gt;'+='&lt;/code&gt; 実装が引数を変更しないことを知る方法がありません。&lt;a href=&quot;#Copy-Constructor&quot;&gt;「コピーコンストラクタ」を&lt;/a&gt;参照してください）。</target>
        </trans-unit>
        <trans-unit id="e4b31e0831fe480c7543658e6a5c02d003d2e334" translate="yes" xml:space="preserve">
          <source>Since subroutines implementing assignment operators are not required to modify their operands (see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Overloadable Operations&lt;/a&gt; above), we do not need anything special to make &lt;code&gt;+=&lt;/code&gt; and friends work, besides adding these operators to %subr and defining a copy constructor (needed since Perl has no way to know that the implementation of &lt;code&gt;'+='&lt;/code&gt; does not mutate the argument - see &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;).</source>
          <target state="translated">代入演算子を実装するサブルーチンはオペランドを変更する必要がないため（上記の&lt;a href=&quot;#Overloadable-Operations&quot;&gt;オーバーロード可能な&lt;/a&gt;演算を参照）、これらの演算子を％subrに追加してコピーコンストラクターを定義する（Perlが必要なため）以外に、 &lt;code&gt;+=&lt;/code&gt; やフレンドを機能させるために特別なことは必要ありません。 &lt;code&gt;'+='&lt;/code&gt; の実装が引数を変更しないことを知る方法はありません- &lt;a href=&quot;#Copy-Constructor&quot;&gt;コピーコンストラクターを&lt;/a&gt;参照してください）。</target>
        </trans-unit>
        <trans-unit id="39828fbb336c2f70993a4540589d36ff13c1f2fe" translate="yes" xml:space="preserve">
          <source>Since such a construct is equivalent to using an empty string, you are recommended to remove such &lt;code&gt;\N{}&lt;/code&gt; constructs.</source>
          <target state="translated">このような構成は空の文字列を使用することと同等であるため、このような &lt;code&gt;\N{}&lt;/code&gt; 構成を削除することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="24efb6846ccb0dd586c9a2d632cd24665dcacdba" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;UNIVERSAL::VERSION&lt;/code&gt; method treats the &lt;code&gt;$VERSION&lt;/code&gt; number as a simple numeric value it will regard version 1.10 as lower than 1.9. For this reason it is strongly recommended that you use numbers with at least two decimal places, e.g., 1.09.</source>
          <target state="translated">以来 &lt;code&gt;UNIVERSAL::VERSION&lt;/code&gt; メソッドの扱い &lt;code&gt;$VERSION&lt;/code&gt; 簡単な数値として数それはより低い1.9とバージョン1.10を考えてます。このため、1.09など、少なくとも小数点以下2桁の数値を使用することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="9984a40959f39d46f91cc9c90e354da67e76965d" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;ops&lt;/code&gt; pragma currently has an irreversible global effect, it is only of significant practical use with the &lt;code&gt;-M&lt;/code&gt; option on the command line.</source>
          <target state="translated">以来 &lt;code&gt;ops&lt;/code&gt; プラグマは、現在、不可逆的なグローバルな効果を持っている、それだけで大きな実用的である &lt;code&gt;-M&lt;/code&gt; コマンドラインでオプション。</target>
        </trans-unit>
        <trans-unit id="953376be0c1beefb5a7844380d81b187b71cbf9b" translate="yes" xml:space="preserve">
          <source>Since the CV takes ownership of its slab when flagged, that flag is never copied when a CV is cloned, as one CV could free a slab that another CV still points to, since forced freeing of ops ignores the reference count (but asserts that it looks right).</source>
          <target state="translated">CVはフラグが立てられたときにそのスラブの所有権を取得するので、あるCVが複製されたときにそのフラグがコピーされることはありません。</target>
        </trans-unit>
        <trans-unit id="926a29507017e24c08c49eb96c57773fd03c95dd" translate="yes" xml:space="preserve">
          <source>Since the MD5 algorithm is byte oriented you might only add bits as multiples of 8, so you probably want to just use add() instead. The add_bits() method is provided for compatibility with other digest implementations. See &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; for description of the arguments that add_bits() take.</source>
          <target state="translated">MD5アルゴリズムはバイト指向であるため、ビットを8の倍数としてのみ追加する可能性があるため、代わりに単にadd（）を使用することをお勧めします。add_bits（）メソッドは、他のダイジェスト実装との互換性のために提供されています。add_bits（）が取る引数の説明については、&lt;a href=&quot;../digest&quot;&gt;ダイジェスト&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b38cceb121fc001ce43895b005634147912b7f28" translate="yes" xml:space="preserve">
          <source>Since the MD5 algorithm is byte oriented you might only add bits as multiples of 8, so you probably want to just use add() instead. The add_bits() method is provided for compatibility with other digest implementations. See &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt; for description of the arguments that add_bits() take.</source>
          <target state="translated">MD5アルゴリズムはバイト指向であるため、ビットを8の倍数として追加するだけでよいため、代わりにadd（）を使用することをお勧めします。add_bits（）メソッドは、他のダイジェスト実装との互換性のために提供されています。add_bits（）が取る引数の説明については、&lt;a href=&quot;digest&quot;&gt;ダイジェスト&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="fcf00ba41dfb6029d72bbfa314d984c685681962" translate="yes" xml:space="preserve">
          <source>Since the MD5 algorithm is only defined for strings of bytes, it can not be used on strings that contains chars with ordinal number above 255 (Unicode strings). The MD5 functions and methods will croak if you try to feed them such input data:</source>
          <target state="translated">MD5 アルゴリズムはバイトの文字列に対してのみ定義されているので、255 以上の序数を持つ文字を含む文字列 (Unicode 文字列)には使用できません。このような入力データを与えようとすると、MD5 の関数やメソッドは動作を停止します。</target>
        </trans-unit>
        <trans-unit id="4504893c7038fe54de5cf229bf7abc99b79c512f" translate="yes" xml:space="preserve">
          <source>Since the Perl extension DLLs are always loaded with the full path, there is no need to mangle their names in a version-specific ways: their directory already reflects the corresponding version of perl, and @INC takes into account binary compatibility with older version. Starting from &lt;code&gt;5.6.2&lt;/code&gt; the name mangling scheme is fixed to be the same as for Perl 5.005_53 (same as in a popular binary release). Thus new Perls will be able to</source>
          <target state="translated">Perl拡張DLLは常にフルパスでロードされるため、バージョン固有の方法で名前を変更する必要はありません。それらのディレクトリはすでに対応するバージョンのperlを反映しており、@ INCは古いバージョンとのバイナリ互換性を考慮しています。始まる &lt;code&gt;5.6.2&lt;/code&gt; 名前の符号化方式が固定されているPerlの5.005_53（人気のバイナリリリースと同じ）の場合と同じであることを。したがって、新しいPerlは</target>
        </trans-unit>
        <trans-unit id="d9753e3adbb08c389f10d17cb835e755759949e1" translate="yes" xml:space="preserve">
          <source>Since the VMS linker distinguishes symbols based only on the first 31 characters of their names, it is occasionally necessary to shorten symbol names in order to avoid collisions. (This is especially true of names generated by xsubpp, since prefixes generated by nested package names can become quite long.) &lt;code&gt;ExtUtils::XSSymSet&lt;/code&gt; provides functions to shorten names in a consistent fashion, and to track a set of names to insure that each is unique. While designed with</source>
          <target state="translated">VMSリンカは、名前の最初の31文字のみに基づいてシンボルを区別するため、衝突を避けるためにシンボル名を短くする必要がある場合があります。（ネストされたパッケージ名によって生成されるプレフィックスは非常に長くなる可能性があるため、これはxsubppによって生成される名前に特に当てはまります。） &lt;code&gt;ExtUtils::XSSymSet&lt;/code&gt; は、一貫した方法で名前を短縮し、名前のセットを追跡してそれぞれが確実に長くなるようにする関数を提供します。ユニーク。で設計されている間</target>
        </trans-unit>
        <trans-unit id="b3bc7c77475d3cf936d8648a172f314719ec1f56" translate="yes" xml:space="preserve">
          <source>Since the first character of $x matched the regex, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; prepended an empty initial element to the list.</source>
          <target state="translated">$ xの最初の文字が正規表現に一致したため、 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; は空の初期要素をリストの先頭に追加しました。</target>
        </trans-unit>
        <trans-unit id="e30d9369cb9f674a0338e525db18f9f146fc0752" translate="yes" xml:space="preserve">
          <source>Since the first character of $x matched the regex, &lt;code&gt;split&lt;/code&gt; prepended an empty initial element to the list.</source>
          <target state="translated">$ xの最初の文字が正規表現と一致したため、 &lt;code&gt;split&lt;/code&gt; は空の初期要素をリストの先頭に追加しました。</target>
        </trans-unit>
        <trans-unit id="2334de3a289af7777d7979b79868746517ddea3f" translate="yes" xml:space="preserve">
          <source>Since the first character of $x matched the regexp, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; prepended an empty initial element to the list.</source>
          <target state="translated">$ xの最初の文字が正規表現に一致したため、 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; は空の初期要素をリストの先頭に追加しました。</target>
        </trans-unit>
        <trans-unit id="dfb32be28d90dd8cfadf42b0da79f140a1aebe0c" translate="yes" xml:space="preserve">
          <source>Since the first character of &lt;code&gt;$x&lt;/code&gt; matched the regexp, &lt;code&gt;split&lt;/code&gt; prepended an empty initial element to the list.</source>
          <target state="translated">&lt;code&gt;$x&lt;/code&gt; 最初の文字が正規表現と一致したため、 &lt;code&gt;split&lt;/code&gt; は空の初期要素をリストの先頭に追加しました。</target>
        </trans-unit>
        <trans-unit id="c9108eba2d411db85e70e8df1569d830e2a5d25c" translate="yes" xml:space="preserve">
          <source>Since the fork() emulation runs code in multiple threads, extensions calling into non-thread-safe libraries may not work reliably when calling fork(). As Perl's threading support gradually becomes more widely adopted even on platforms with a native fork(), such extensions are expected to be fixed for thread-safety.</source>
          <target state="translated">fork()エミュレーションは複数のスレッドでコードを実行するため、スレッドセーフではないライブラリを呼び出す拡張機能は、fork()を呼び出す際に確実に動作しない可能性があります。ネイティブの fork()があるプラットフォームでも Perl のスレッド化サポートが徐々に広く採用されるようになると、スレッドセーフのためにこのような拡張機能が修正されることが期待されています。</target>
        </trans-unit>
        <trans-unit id="b5c6d6292298eef29abac825fb611cdb8dbc410b" translate="yes" xml:space="preserve">
          <source>Since the logging doesn't use PerlIO, all SV allocations are logged and no extra SV allocations are introduced by enabling the logging. If compiled with &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; , the serial number for each SV allocation is also logged.</source>
          <target state="translated">ロギングはPerlIOを使用しないため、すべてのSV割り当てがログに記録され、ロギングを有効にすることで追加のSV割り当ては導入されません。 &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; を指定してコンパイルした場合、各SV割り当てのシリアル番号もログに記録されます。</target>
        </trans-unit>
        <trans-unit id="3e539eeb6fc84357572fa6a057c29a86c8133533" translate="yes" xml:space="preserve">
          <source>Since the logging doesn't use PerlIO, all SV allocations are logged and no extra SV allocations are introduced by enabling the logging. If compiled with &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt;, the serial number for each SV allocation is also logged.</source>
          <target state="translated">ロギングはPerlIOを使用しないため、すべてのSV割り当てがログに記録され、ロギングを有効にすることによって追加のSV割り当てが導入されることはありません。 &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; を使用してコンパイルした場合、各SV割り当てのシリアル番号もログに記録されます。</target>
        </trans-unit>
        <trans-unit id="3279571aa6d0a69a5a2abdeb30f262cc44dbbdae" translate="yes" xml:space="preserve">
          <source>Since the match operator &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, the substitution operator &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, and the regular expression quoting operator &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; are double-quotish constructs, you can interpolate variables into the pattern. See the answer to &quot;How can I quote a variable to use in a regex?&quot; for more details.</source>
          <target state="translated">一致演算子 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 、置換演算子 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 、および正規表現引用演算子 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; は二重引用符構造なので、変数をパターンに補間できます。「正規表現で使用する変数をどのように引用できるか」の回答を参照してください。詳細については。</target>
        </trans-unit>
        <trans-unit id="7344ea0eab36d0c1c0f9a8a859bf628b21f3791b" translate="yes" xml:space="preserve">
          <source>Since the match operator &lt;code&gt;m//&lt;/code&gt;, the substitution operator &lt;code&gt;s///&lt;/code&gt;, and the regular expression quoting operator &lt;code&gt;qr//&lt;/code&gt; are double-quotish constructs, you can interpolate variables into the pattern. See the answer to &quot;How can I quote a variable to use in a regex?&quot; for more details.</source>
          <target state="translated">一致演算子 &lt;code&gt;m//&lt;/code&gt; 、置換演算子 &lt;code&gt;s///&lt;/code&gt; 、および正規表現引用演算子 &lt;code&gt;qr//&lt;/code&gt; は二重引用符構造であるため、変数をパターンに補間できます。「正規表現で使用する変数を引用するにはどうすればよいですか？」の回答を参照してください。詳細については。</target>
        </trans-unit>
        <trans-unit id="84b10458d44f04e31c63c483bc8240735b5e37c7" translate="yes" xml:space="preserve">
          <source>Since the null filehandle uses the two argument form of &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; it interprets special characters, so if you have a script like this:</source>
          <target state="translated">nullファイルハンドルは&lt;a href=&quot;functions/open&quot;&gt;openの&lt;/a&gt; 2つの引数形式を使用するため、特殊文字を解釈するので、次のようなスクリプトがあるとします。</target>
        </trans-unit>
        <trans-unit id="66fb7ce305be412987d9aacf9b06a1422f1fe031" translate="yes" xml:space="preserve">
          <source>Since the null filehandle uses the two argument form of &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt; it interprets special characters, so if you have a script like this:</source>
          <target state="translated">nullファイルハンドルは&lt;a href=&quot;perlfunc#open&quot;&gt;perlfunc&lt;/a&gt;で「open」の2つの引数形式を使用するため、特殊文字を解釈します。したがって、次のようなスクリプトがある場合：</target>
        </trans-unit>
        <trans-unit id="cd81accbd1bb6c167fba1a41e5f2407058ac7a87" translate="yes" xml:space="preserve">
          <source>Since the object is also a hash, you can treat it as one, using it to store data associated with the object. Typically, code inside the class can treat the hash as an accessible data structure, while code outside the class should always treat the object as opaque. This is called &lt;b&gt;encapsulation&lt;/b&gt;. Encapsulation means that the user of an object does not have to know how it is implemented. The user simply calls documented methods on the object.</source>
          <target state="translated">オブジェクトはハッシュでもあるため、オブジェクトに関連付けられたデータを格納するためにそれを使用して、1つのオブジェクトとして扱うことができます。通常、クラス内のコードはハッシュをアクセス可能なデータ構造として扱うことができますが、クラス外のコードは常にオブジェクトを不透明として扱う必要があります。これは&lt;b&gt;カプセル化&lt;/b&gt;と呼ばれ&lt;b&gt;ます&lt;/b&gt;。カプセル化とは、オブジェクトのユーザーが、オブジェクトの実装方法を知る必要がないことを意味します。ユーザーはオブジェクトのドキュメント化されたメソッドを呼び出すだけです。</target>
        </trans-unit>
        <trans-unit id="db12f27020b74e90b153b0c7282afabc69308986" translate="yes" xml:space="preserve">
          <source>Since the original &lt;code&gt;big5&lt;/code&gt; encoding (1984) is not supported anywhere (glibc and DOS-based systems uses &lt;code&gt;big5&lt;/code&gt; to mean &lt;code&gt;big5-eten&lt;/code&gt; ; Microsoft uses &lt;code&gt;big5&lt;/code&gt; to mean &lt;code&gt;cp950&lt;/code&gt; ), a conscious decision was made to alias &lt;code&gt;big5&lt;/code&gt; to &lt;code&gt;big5-eten&lt;/code&gt; , which is the de facto superset of the original big5.</source>
          <target state="translated">オリジナルため &lt;code&gt;big5&lt;/code&gt; エンコーディング（1984）は、どこにもサポートされていない（のglibcとDOSベースのシステムの用途の &lt;code&gt;big5&lt;/code&gt; に平均 &lt;code&gt;big5-eten&lt;/code&gt; ; Microsoftが使用 &lt;code&gt;big5&lt;/code&gt; 意味するために &lt;code&gt;cp950&lt;/code&gt; ）意識的な決定がエイリアスに作られた、 &lt;code&gt;big5&lt;/code&gt; に &lt;code&gt;big5-eten&lt;/code&gt; 、ありますオリジナルのbig5の事実上のスーパーセット。</target>
        </trans-unit>
        <trans-unit id="d8d087310b96c8a2161d52fb071f50cb14fd5ed5" translate="yes" xml:space="preserve">
          <source>Since the original &lt;code&gt;big5&lt;/code&gt; encoding (1984) is not supported anywhere (glibc and DOS-based systems uses &lt;code&gt;big5&lt;/code&gt; to mean &lt;code&gt;big5-eten&lt;/code&gt;; Microsoft uses &lt;code&gt;big5&lt;/code&gt; to mean &lt;code&gt;cp950&lt;/code&gt;), a conscious decision was made to alias &lt;code&gt;big5&lt;/code&gt; to &lt;code&gt;big5-eten&lt;/code&gt;, which is the de facto superset of the original big5.</source>
          <target state="translated">オリジナルため &lt;code&gt;big5&lt;/code&gt; エンコーディング（1984）は、どこにもサポートされていない（のglibcとDOSベースのシステムの用途の &lt;code&gt;big5&lt;/code&gt; に平均 &lt;code&gt;big5-eten&lt;/code&gt; ; Microsoftが使用 &lt;code&gt;big5&lt;/code&gt; 意味するために &lt;code&gt;cp950&lt;/code&gt; ）意識的な決定がエイリアスに作られた、 &lt;code&gt;big5&lt;/code&gt; に &lt;code&gt;big5-eten&lt;/code&gt; 、ありますオリジナルのbig5の事実上のスーパーセット。</target>
        </trans-unit>
        <trans-unit id="e096824f5ca19792394259581d18c44d0fb48327" translate="yes" xml:space="preserve">
          <source>Since the path separators are different on some operating systems ('/' on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec modules wherever portability is a concern.</source>
          <target state="translated">オペレーティングシステムによってはパスセパレータが異なるため ('/'はUnixで、':'はMacPerlで、など)、移植性が気になる場合はFile::Specモジュールを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="8b814beacf19306d64e3fcdb9e9e2ebc37bd2f9a" translate="yes" xml:space="preserve">
          <source>Since the return value of EXPR is executed as a block within the lexical context of the current Perl program, any outer lexical variables are visible to it, and any package variable settings or subroutine and format definitions remain afterwards.</source>
          <target state="translated">EXPRの戻り値は、現在のPerlプログラムの字句コンテキスト内のブロックとして実行されるので、外部の字句変数はすべてそれに見え、パッケージ変数の設定やサブルーチンやフォーマットの定義はその後も残ります。</target>
        </trans-unit>
        <trans-unit id="afc1d2d6e3b782b2dd5e1481aef1464f9b2e04bc" translate="yes" xml:space="preserve">
          <source>Since the scope wasn't lexical, other modules' use of &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;,</source>
          <target state="translated">スコープ以来の字句、他のモジュールの使用はなかった &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 、</target>
        </trans-unit>
        <trans-unit id="a424c04edb43b51178f65103d1803116d4fd0aaa" translate="yes" xml:space="preserve">
          <source>Since the scope wasn't lexical, other modules' use of &lt;code&gt;chr&lt;/code&gt;, &lt;code&gt;ord&lt;/code&gt;,</source>
          <target state="translated">スコープが字句ではなかったため、他のモジュールでの &lt;code&gt;chr&lt;/code&gt; 、 &lt;code&gt;ord&lt;/code&gt; 、</target>
        </trans-unit>
        <trans-unit id="b0b947b7b4bc7b90e1cd94b89023d67ed8fe406b" translate="yes" xml:space="preserve">
          <source>Since the symbols listed within &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; must also appear in either &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; , two utility functions are provided which allow you to easily add tagged sets of symbols to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; :</source>
          <target state="translated">内にリストシンボル以来 &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; またいずれかに表示される必要があります &lt;code&gt;@EXPORT&lt;/code&gt; または &lt;code&gt;@EXPORT_OK&lt;/code&gt; 、2つのユーティリティ関数を使用すると、簡単にシンボルのタグ付きセットを追加することができますが提供される &lt;code&gt;@EXPORT&lt;/code&gt; または &lt;code&gt;@EXPORT_OK&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="12348ccf02ace58fde57dcb8fdfe6146a5174932" translate="yes" xml:space="preserve">
          <source>Since the symbols listed within &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; must also appear in either &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt;, two utility functions are provided which allow you to easily add tagged sets of symbols to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;%EXPORT_TAGS&lt;/code&gt; 内にリストされているシンボルは、 &lt;code&gt;@EXPORT&lt;/code&gt; または &lt;code&gt;@EXPORT_OK&lt;/code&gt; にも表示される必要があるため、タグ付きのシンボルセットを &lt;code&gt;@EXPORT&lt;/code&gt; または &lt;code&gt;@EXPORT_OK&lt;/code&gt; に簡単に追加できる2つのユーティリティ関数が提供されています。</target>
        </trans-unit>
        <trans-unit id="1a1ad4491daa19cab8cfcffcbf76d31fdb6dedaa" translate="yes" xml:space="preserve">
          <source>Since the text to insert should be different in &lt;code&gt;bytes&lt;/code&gt; mode and out of it, the function should check the current state of &lt;code&gt;bytes&lt;/code&gt; -flag as in:</source>
          <target state="translated">挿入するテキストは &lt;code&gt;bytes&lt;/code&gt; モードとそれ以外では異なるため、関数は次のように &lt;code&gt;bytes&lt;/code&gt; -flagの現在の状態を確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="a18ac7a6a5b44dc9939056baa28ada3143807b7e" translate="yes" xml:space="preserve">
          <source>Since the text to insert should be different in &lt;code&gt;bytes&lt;/code&gt; mode and out of it, the function should check the current state of &lt;code&gt;bytes&lt;/code&gt;-flag as in:</source>
          <target state="translated">挿入するテキストは &lt;code&gt;bytes&lt;/code&gt; モードとバイトモードで異なる必要があるため、関数は次のように &lt;code&gt;bytes&lt;/code&gt; フラグの現在の状態をチェックする必要があります。</target>
        </trans-unit>
        <trans-unit id="b57f88b4da7c64e61f7bcbc6480133424225f899" translate="yes" xml:space="preserve">
          <source>Since the total size of all Perl SIS files once installed is over 2 MB, it is recommended to do the installation into a memory card (drive E:) instead of the C: drive.</source>
          <target state="translated">一度インストールされたPerl SISファイルの合計サイズは2MBを超えるので、C:ドライブの代わりにメモリカード(Eドライブ)にインストールすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="50530d766e72e0b6fff4d2cca6e94d3aad2090a6" translate="yes" xml:space="preserve">
          <source>Since there are relatively few objects in a picture, there are only a few colors, which get looked up over and over again. Memoizing &lt;code&gt;ColorToRGB&lt;/code&gt; sped up the program by several percent.</source>
          <target state="translated">画像に含まれるオブジェクトは比較的少ないため、何度も何度も調べられる色は数個しかありません。ColorToRGBを &lt;code&gt;ColorToRGB&lt;/code&gt; すると、プログラムが数パーセント高速化しました。</target>
        </trans-unit>
        <trans-unit id="6cb6a83a2f2c3167da777a122214abb67623928e" translate="yes" xml:space="preserve">
          <source>Since there are so many, they are presented in table format with languages and corresponding encoding names by vendors. Note that the table is sorted in order of ISO-8859 and the corresponding vendor mappings are slightly different from that of ISO. See &lt;a href=&quot;http://czyborra.com/charsets/iso8859.html&quot;&gt;http://czyborra.com/charsets/iso8859.html&lt;/a&gt; for details.</source>
          <target state="translated">非常に多くあるため、ベンダーによって言語と対応するエンコーディング名を含む表形式で表示されます。表はISO-8859の順序でソートされており、対応するベンダーのマッピングはISOのマッピングとわずかに異なることに注意してください。詳細については、&lt;a href=&quot;http://czyborra.com/charsets/iso8859.html&quot;&gt;http：//czyborra.com/charsets/iso8859.html&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b29f8659dcd90c4211c87b64479756be9287fa54" translate="yes" xml:space="preserve">
          <source>Since there is a bijection between a point in the 2D plane and a complex number (i.e. the mapping is unique and reciprocal), a complex number can also be uniquely identified with polar coordinates:</source>
          <target state="translated">2次元平面上の点と複素数との間にはバイjectionが存在する(すなわち、マッピングは一意で逆数である)ので、複素数もまた、極座標で一意に識別することができる。</target>
        </trans-unit>
        <trans-unit id="bc706817bd3a8e95c1023efd45beb0908b6a5e49" translate="yes" xml:space="preserve">
          <source>Since these aren't legal POSIX class specifications, but are legal bracketed character classes, Perl treats them as the latter. In the first example, it matches the characters &lt;code&gt;&quot;:&quot;&lt;/code&gt;, &lt;code&gt;&quot;[&quot;&lt;/code&gt;, &lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;l&quot;&lt;/code&gt;, &lt;code&gt;&quot;m&quot;&lt;/code&gt;, &lt;code&gt;&quot;n&quot;&lt;/code&gt;, and &lt;code&gt;&quot;u&quot;&lt;/code&gt;.</source>
          <target state="translated">これらは正当なPOSIXクラス仕様ではありませんが、正当な括弧で囲まれた文字クラスであるため、Perlはそれらを後者として扱います。最初の例では、文字 &lt;code&gt;&quot;:&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;[&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;l&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;m&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;n&quot;&lt;/code&gt; 、および &lt;code&gt;&quot;u&quot;&lt;/code&gt; と一致します。</target>
        </trans-unit>
        <trans-unit id="3716c24306b4924201a3a983711259349f4d7b7c" translate="yes" xml:space="preserve">
          <source>Since these functions are different for most operating systems, each set of OS specific routines is available in a separate module, including:</source>
          <target state="translated">これらの機能はほとんどのオペレーティングシステムで異なるため、OS固有のルーチンの各セットは、以下のような別のモジュールで利用可能です。</target>
        </trans-unit>
        <trans-unit id="61e7fa1fca7db47b0de02fb29d8bdc7a036c2ad4" translate="yes" xml:space="preserve">
          <source>Since these macros have side-effects don't use them as arguments to macros that may evaluate their argument several times, for example:</source>
          <target state="translated">これらのマクロには副作用があるので、例えば引数を何度も評価するようなマクロの引数としては使用しないでください。</target>
        </trans-unit>
        <trans-unit id="c3d20e57f802de1056f71e94f07efcc76036480f" translate="yes" xml:space="preserve">
          <source>Since things like &lt;code&gt;&lt;a href=&quot;../functions/sqrt&quot;&gt;sqrt(2)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;1 / 3&lt;/code&gt; must presented with a limited accuracy lest a operation consumes all resources, each operation produces no more than the requested number of digits.</source>
          <target state="translated">ようなもの以来 &lt;code&gt;&lt;a href=&quot;../functions/sqrt&quot;&gt;sqrt(2)&lt;/a&gt;&lt;/code&gt; 又は &lt;code&gt;1 / 3&lt;/code&gt; 操作LEST限られた精度で呈示する必要がある各操作は、数字の要求された数を超えない生成、すべてのリソースを消費しません。</target>
        </trans-unit>
        <trans-unit id="55385d26f11babeaaffc540cfe07e740a0d30a4d" translate="yes" xml:space="preserve">
          <source>Since things like &lt;code&gt;sqrt(2)&lt;/code&gt; or &lt;code&gt;1 / 3&lt;/code&gt; must presented with a limited accuracy lest a operation consumes all resources, each operation produces no more than the requested number of digits.</source>
          <target state="translated">ようなもの以来 &lt;code&gt;sqrt(2)&lt;/code&gt; 又は &lt;code&gt;1 / 3&lt;/code&gt; 操作LEST限られた精度で呈示する必要がある各操作は、数字の要求された数を超えない生成、すべてのリソースを消費しません。</target>
        </trans-unit>
        <trans-unit id="b1a21b989b9d575d7d2eef7cf2bea0c2bc7b6c1e" translate="yes" xml:space="preserve">
          <source>Since this document was first written, the convention has become more and more to use hexadecimal notation for code points. To do this with the recipes and to also sort is a multi-step process, so here, for convenience, is the table from above, re-sorted to be in Code Page 1047 order, and using hex notation.</source>
          <target state="translated">この文書が最初に書かれて以来、コードポイントには16進数表記を使うことが多くなってきました。レシピでこれを行い、またソートすることは多段階のプロセスですので、ここでは便宜上、上の表をコードページ1047の順序になるように再ソートし、16進表記を使用しています。</target>
        </trans-unit>
        <trans-unit id="ef4f428bd8f59049b7e023a3a37d2ecfa135c01b" translate="yes" xml:space="preserve">
          <source>Since this is 0.something release, any future releases are almost guaranteed to be binary incompatible. As a sign of this the Symbian symbol exports are kept unfrozen and the .def files fully rebuilt every time.</source>
          <target state="translated">これは 0.something のリリースなので、将来のリリースはバイナリ互換性がないことがほとんど保証されています。その証として、Symbian のシンボルのエクスポートは凍結されておらず、.def ファイルは毎回完全に再構築されています。</target>
        </trans-unit>
        <trans-unit id="a29b3865557e1b6dfb498bcdde9cd5a7a83c05b9" translate="yes" xml:space="preserve">
          <source>Since this module is most often used only indirectly from extension &lt;code&gt;Makefile.PL&lt;/code&gt; files, here is an example &lt;code&gt;Makefile.PL&lt;/code&gt; entry to add a library to the build process for an extension:</source>
          <target state="translated">このモジュールは、拡張 &lt;code&gt;Makefile.PL&lt;/code&gt; ファイルから間接的にのみ使用されることが多いので、拡張のビルドプロセスにライブラリを追加する &lt;code&gt;Makefile.PL&lt;/code&gt; エントリの例を次に示します。</target>
        </trans-unit>
        <trans-unit id="01f476f0532c2e2f8ff2160a3485f37336e92c5d" translate="yes" xml:space="preserve">
          <source>Since this module refers to perl core's Unicode database in the directory</source>
          <target state="translated">このモジュールは、ディレクトリ内の perl core の Unicode データベースを参照しています。</target>
        </trans-unit>
        <trans-unit id="e87fdde57834ef3e5b68a023cf000c8017fe6842" translate="yes" xml:space="preserve">
          <source>Since this procedure may take quite a long time to complete, it makes sense to &quot;freeze&quot; your CPAN configuration by disabling periodic updates of the local copy of CPAN index: set &lt;code&gt;index_expire&lt;/code&gt; to some big value (I use 365), then save the settings</source>
          <target state="translated">この手順は完了するまでにかなり長い時間がかかる可能性があるため、CPANインデックスのローカルコピーの定期的な更新を無効にしてCPAN構成を「フリーズ」することは理にかなっています &lt;code&gt;index_expire&lt;/code&gt; をいくつかの大きな値に設定し（365を使用）、設定を保存します</target>
        </trans-unit>
        <trans-unit id="db30ab250873c1062c4781e4e7b7fad867ddcab0" translate="yes" xml:space="preserve">
          <source>Since this will lead to issues as described above.</source>
          <target state="translated">上記のような問題が発生することになりますので</target>
        </trans-unit>
        <trans-unit id="5b8353c61df27001cdfae1689cea0393e824247d" translate="yes" xml:space="preserve">
          <source>Since threads are also subroutines, they can return values. To wait for a thread to exit and extract any values it might return, you can use the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; method:</source>
          <target state="translated">スレッドもサブルーチンなので、値を返すことができます。スレッドが終了するのを待ち、スレッドが返す可能性のある値を抽出するには、 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join()&lt;/a&gt;&lt;/code&gt; メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="9bad1409df4464c147cc94bb57065c1ad067150c" translate="yes" xml:space="preserve">
          <source>Since threads are also subroutines, they can return values. To wait for a thread to exit and extract any values it might return, you can use the &lt;code&gt;join()&lt;/code&gt; method:</source>
          <target state="translated">スレッドもサブルーチンであるため、値を返すことができます。スレッドが終了するのを待って、返される可能性のある値を抽出するには、 &lt;code&gt;join()&lt;/code&gt; メソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="865359543cead83315159b60389211a49302275e" translate="yes" xml:space="preserve">
          <source>Since to call certain OS/2 API one needs to have a correctly initialized &lt;code&gt;Win&lt;/code&gt; subsystem, OS/2-specific extensions may require getting &lt;code&gt;HAB&lt;/code&gt; s and &lt;code&gt;HMQ&lt;/code&gt; s. If an extension would do it on its own, another extension could fail to initialize.</source>
          <target state="translated">特定のOS / 2 APIを呼び出すには、正しく初期化された &lt;code&gt;Win&lt;/code&gt; サブシステムが必要になるため、OS / 2固有の拡張機能では、 &lt;code&gt;HAB&lt;/code&gt; と &lt;code&gt;HMQ&lt;/code&gt; を取得する必要があります。拡張機能が独自に行う場合、別の拡張機能が初期化に失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="a707076963b2deddc0e47770d659e4e4346ffd5b" translate="yes" xml:space="preserve">
          <source>Since to call certain OS/2 API one needs to have a correctly initialized &lt;code&gt;Win&lt;/code&gt; subsystem, OS/2-specific extensions may require getting &lt;code&gt;HAB&lt;/code&gt;s and &lt;code&gt;HMQ&lt;/code&gt;s. If an extension would do it on its own, another extension could fail to initialize.</source>
          <target state="translated">特定のOS / 2 APIを呼び出すには、正しく初期化された &lt;code&gt;Win&lt;/code&gt; サブシステムが必要なため、OS / 2固有の拡張機能では、 &lt;code&gt;HAB&lt;/code&gt; と &lt;code&gt;HMQ&lt;/code&gt; を取得する必要がある場合があります。拡張機能がそれ自体でそれを行う場合、別の拡張機能が初期化に失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ac123183aa461484cfbda02f53a1d46605cce417" translate="yes" xml:space="preserve">
          <source>Since v1.24 the &lt;b&gt;Pod::Checker&lt;/b&gt; module uses only the &lt;b&gt;poderror&lt;/b&gt; method to print errors and warnings. The summary output (e.g. &quot;Pod syntax OK&quot;) has been dropped from the module and has been included in &lt;b&gt;podchecker&lt;/b&gt; (the script). This allows users of &lt;b&gt;Pod::Checker&lt;/b&gt; to control completely the output behavior. Users of &lt;b&gt;podchecker&lt;/b&gt; (the script) get the well-known behavior.</source>
          <target state="translated">v1.24以降、&lt;b&gt;Pod :: Checker&lt;/b&gt;モジュールは、&lt;b&gt;poderror&lt;/b&gt;メソッドのみを使用してエラーと警告を出力します。要約出力（「ポッド構文OK」など）はモジュールから削除され、&lt;b&gt;podchecker&lt;/b&gt;（スクリプト）に含まれています。これにより、&lt;b&gt;Pod :: Checkerの&lt;/b&gt;ユーザーは出力動作を完全に制御できます。&lt;b&gt;podchecker&lt;/b&gt;（スクリプト）のユーザーは、よく知られた動作をします。</target>
        </trans-unit>
        <trans-unit id="31c16cb5be350777f69ddd741df453e37c786546" translate="yes" xml:space="preserve">
          <source>Since v5.6.0, Perl's CORE::glob() is implemented in terms of bsd_glob(). Note that they don't share the same prototype--CORE::glob() only accepts a single argument. Due to historical reasons, CORE::glob() will also split its argument on whitespace, treating it as multiple patterns, whereas bsd_glob() considers them as one pattern. But see &lt;code&gt;:bsd_glob&lt;/code&gt; under &lt;a href=&quot;#EXPORTS&quot;&gt;&quot;EXPORTS&quot;&lt;/a&gt;, below.</source>
          <target state="translated">v5.6.0以降、PerlのCORE :: glob（）はbsd_glob（）の観点から実装されています。それらは同じプロトタイプを共有しないことに注意してください--CORE :: glob（）は単一の引数のみを受け入れます。歴史的な理由により、CORE :: glob（）は空白で引数を分割し、複数のパターンとして扱いますが、bsd_glob（）はそれらを1つのパターンと見なします。ただし、以下の&lt;a href=&quot;#EXPORTS&quot;&gt;「&lt;/a&gt; &lt;code&gt;:bsd_glob&lt;/code&gt; 」の下にある：bsd_globを参照してください。</target>
        </trans-unit>
        <trans-unit id="993c2506a3b501e251a227378341211573ee7139" translate="yes" xml:space="preserve">
          <source>Since v5.6.0, Perl's CORE::glob() is implemented in terms of bsd_glob(). Note that they don't share the same prototype--CORE::glob() only accepts a single argument. Due to historical reasons, CORE::glob() will also split its argument on whitespace, treating it as multiple patterns, whereas bsd_glob() considers them as one pattern. But see &lt;code&gt;:bsd_glob&lt;/code&gt; under &lt;a href=&quot;#EXPORTS&quot;&gt;EXPORTS&lt;/a&gt;, below.</source>
          <target state="translated">v5.6.0以降、PerlのCORE :: glob（）はbsd_glob（）の観点から実装されています。これらは同じプロトタイプを共有しないことに注意してください。CORE:: glob（）は単一の引数のみを受け入れます。歴史的な理由により、CORE :: glob（）は引数を空白で分割し、複数のパターンとして扱いますが、bsd_glob（）はそれらを1つのパターンと見なします。しかし参照 &lt;code&gt;:bsd_glob&lt;/code&gt; の下で&lt;a href=&quot;#EXPORTS&quot;&gt;輸出を&lt;/a&gt;、以下。</target>
        </trans-unit>
        <trans-unit id="4ad68534057bbff035849577fdc9d02265e92498" translate="yes" xml:space="preserve">
          <source>Since valgrind adds significant overhead, tests will take much longer to run. The valgrind tests support being run in parallel to help with this:</source>
          <target state="translated">valgrindはかなりのオーバーヘッドを追加するので、テストを実行するのに時間がかかります。valgrind のテストは、これを助けるために並行して実行することをサポートしています。</target>
        </trans-unit>
        <trans-unit id="cddab41a34bae01a0c375cc55e93affd1f3991b2" translate="yes" xml:space="preserve">
          <source>Since version 1.26.</source>
          <target state="translated">バージョン1.26から。</target>
        </trans-unit>
        <trans-unit id="6b04b338e1bf6330ffba84da282f69c260eb86f1" translate="yes" xml:space="preserve">
          <source>Since version 1.29.</source>
          <target state="translated">バージョン1.29から。</target>
        </trans-unit>
        <trans-unit id="90fa8ea868e9b39ffa1222c302c6573df472b992" translate="yes" xml:space="preserve">
          <source>Since version 1.30.</source>
          <target state="translated">バージョン1.30から。</target>
        </trans-unit>
        <trans-unit id="b46b7661e42d1c9773df584f5695782bec0ddb2f" translate="yes" xml:space="preserve">
          <source>Since version 1.33.</source>
          <target state="translated">バージョン1.33から。</target>
        </trans-unit>
        <trans-unit id="4b40436a29419119d4b78bb2f402e947b823a0e2" translate="yes" xml:space="preserve">
          <source>Since version 1.35.</source>
          <target state="translated">バージョン1.35から。</target>
        </trans-unit>
        <trans-unit id="3a2c4273e02619f5ed86c67adac94047a5ca0b70" translate="yes" xml:space="preserve">
          <source>Since version 1.36.</source>
          <target state="translated">バージョン1.36から。</target>
        </trans-unit>
        <trans-unit id="828428c704d4b18c115ba845d9cbbc499bb7c74e" translate="yes" xml:space="preserve">
          <source>Since version 1.40.</source>
          <target state="translated">バージョン1.40から。</target>
        </trans-unit>
        <trans-unit id="623e941c243fc86dd1af6f5b5214ee2ab1b54b93" translate="yes" xml:space="preserve">
          <source>Since version 1.42.</source>
          <target state="translated">バージョン1.42から。</target>
        </trans-unit>
        <trans-unit id="0995e25b2df10d5239bf46e745e3af66bfa38ff9" translate="yes" xml:space="preserve">
          <source>Since version 1.44.</source>
          <target state="translated">バージョン1.44から。</target>
        </trans-unit>
        <trans-unit id="85fc2cbdcb50a3cca10d3657cdf7b3d3b631c2f4" translate="yes" xml:space="preserve">
          <source>Since version 1.45.</source>
          <target state="translated">バージョン1.45から。</target>
        </trans-unit>
        <trans-unit id="20faedc97370e5707a72fd235e65122603a7fcc7" translate="yes" xml:space="preserve">
          <source>Since version 1.50.</source>
          <target state="translated">バージョン1.50から。</target>
        </trans-unit>
        <trans-unit id="21a1a8817578d6cd5474a6b1a0cb684b5b5d0681" translate="yes" xml:space="preserve">
          <source>Since version 1.54.</source>
          <target state="translated">バージョン1.54から。</target>
        </trans-unit>
        <trans-unit id="52ea051224d185be13b4a3d24b650c0164b10687" translate="yes" xml:space="preserve">
          <source>Since version 1.55.</source>
          <target state="translated">バージョン1.55から。</target>
        </trans-unit>
        <trans-unit id="aefe381ec383217e51c9e6b76ef75c74617d1b90" translate="yes" xml:space="preserve">
          <source>Since version 2.22 (part of Encode 2.83), the MIME encoder should be fully compliant to &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2231&quot;&gt;RFC 2231&lt;/a&gt;. Due to the aforementioned bugs in previous versions of the MIME encoder, there is a</source>
          <target state="translated">バージョン2.22（Encode 2.83の一部）以降、MIMEエンコーダーは&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC2047&lt;/a&gt;および&lt;a href=&quot;https://tools.ietf.org/html/rfc2231&quot;&gt;RFC2231に&lt;/a&gt;完全に準拠する必要があります。以前のバージョンのMIMEエンコーダーには前述のバグがあるため、</target>
        </trans-unit>
        <trans-unit id="991cb9597f8a402ad66b55672ad9333f3ec6c358" translate="yes" xml:space="preserve">
          <source>Since version 2.91_01, JSON::PP uses a different number detection logic that converts a scalar that is possible to turn into a number safely. The new logic is slightly faster, and tends to help people who use older perl or who want to encode complicated data structure. However, this may results in a different JSON text from the one JSON::XS encodes (and thus may break tests that compare entire JSON texts). If you do need the previous behavior for compatibility or for finer control, set PERL_JSON_PP_USE_B environmental variable to true before you &lt;code&gt;use&lt;/code&gt; JSON::PP (or JSON.pm).</source>
          <target state="translated">バージョン2.91_01以降、JSON :: PPは、安全に数値に変換できるスカラーを変換する別の数値検出ロジックを使用しています。新しいロジックはわずかに高速で、古いperlを使用している人や、複雑なデータ構造をエンコードしたい人に役立つ傾向があります。ただし、これにより、1つのJSON :: XSエンコードとは異なるJSONテキストが生成される可能性があります（したがって、JSONテキスト全体を比較するテストが失敗する可能性があります）。互換性またはより細かい制御のために以前の動作が必要な場合は、JSON :: PP（またはJSON.pm）を &lt;code&gt;use&lt;/code&gt; 前に、PERL_JSON_PP_USE_B環境変数をtrueに設定してください。</target>
        </trans-unit>
        <trans-unit id="2498504f50455260e9635ae498353ef8c9decaca" translate="yes" xml:space="preserve">
          <source>Since version 5.8 Perl uses the PerlIO I/O library. This enables you to use different encodings per IO channel. For example you may use</source>
          <target state="translated">バージョン 5.8 以降、Perl は PerlIO I/O ライブラリを使用しています。これにより、IO チャンネルごとに異なるエンコーディングを使用することができます。例えば、以下のように</target>
        </trans-unit>
        <trans-unit id="656ca296455da01a08e031bd90f196ae0bd4a55c" translate="yes" xml:space="preserve">
          <source>Since version 5.8 Perl uses the new PerlIO on BS2000. This enables you using different encodings per IO channel. For example you may use</source>
          <target state="translated">バージョン5.8以降、PerlはBS2000で新しいPerlIOを使用しています。これにより、IOチャンネルごとに異なるエンコーディングを使用することができます。例えば</target>
        </trans-unit>
        <trans-unit id="5792847b18d8585cbe32d073b79aab824b6fbb3d" translate="yes" xml:space="preserve">
          <source>Since version 5.8.0, hashes can be</source>
          <target state="translated">バージョン5.8.0以降、ハッシュは</target>
        </trans-unit>
        <trans-unit id="a80731504bb0fcf1278621181ce230d90a8fe55c" translate="yes" xml:space="preserve">
          <source>Since version &lt;code&gt;1.39&lt;/code&gt; these &lt;code&gt;ARRAY&lt;/code&gt; references are blessed objects, recognising the two methods &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;. The following code is equivalent:</source>
          <target state="translated">バージョン &lt;code&gt;1.39&lt;/code&gt; 以降、これらの &lt;code&gt;ARRAY&lt;/code&gt; 参照は祝福されたオブジェクトであり、 &lt;code&gt;key&lt;/code&gt; と &lt;code&gt;value&lt;/code&gt; の2つのメソッドを認識します。次のコードは同等です。</target>
        </trans-unit>
        <trans-unit id="3045986b0102a2064e1410bb295874d9fe22b31d" translate="yes" xml:space="preserve">
          <source>Since version &lt;code&gt;1.39&lt;/code&gt; these ARRAY references are blessed objects, recognising the two methods &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; . The following code is equivalent:</source>
          <target state="translated">バージョン &lt;code&gt;1.39&lt;/code&gt; 以降、これらのARRAY参照はblessオブジェクトであり、2つのメソッド &lt;code&gt;key&lt;/code&gt; および &lt;code&gt;value&lt;/code&gt; を認識します。次のコードは同等です。</target>
        </trans-unit>
        <trans-unit id="d22b88a2ec6cf389267a717ce7fbb228afb24d03" translate="yes" xml:space="preserve">
          <source>Since version &lt;code&gt;1.51&lt;/code&gt; they also have a &lt;code&gt;TO_JSON&lt;/code&gt; method to ease serialisation.</source>
          <target state="translated">バージョン &lt;code&gt;1.51&lt;/code&gt; 以降、 &lt;code&gt;TO_JSON&lt;/code&gt; 化を容易にするTO_JSONメソッドもあります。</target>
        </trans-unit>
        <trans-unit id="4da1ba2b2bc63ba7f5a165684b362132feb79be8" translate="yes" xml:space="preserve">
          <source>Since version v1.33, Math::BigInt and Math::BigFloat have full support for accuracy and precision based rounding, both automatically after every operation, as well as manually.</source>
          <target state="translated">バージョン v1.33 以降、Math::BigInt と Math::BigFloat は、精度と精度に基づく丸めを完全にサポートしており、すべての操作の後に自動的に丸められるだけでなく、手動でも丸められるようになりました。</target>
        </trans-unit>
        <trans-unit id="75e1e7b33ae8faf22bfba9121d2d99d1efb7768e" translate="yes" xml:space="preserve">
          <source>Since we didn't define a &lt;code&gt;save()&lt;/code&gt; method in the &lt;code&gt;File::MP3&lt;/code&gt; class, Perl will look at the &lt;code&gt;File::MP3&lt;/code&gt; class's parent classes to find the &lt;code&gt;save()&lt;/code&gt; method. If Perl cannot find a &lt;code&gt;save()&lt;/code&gt; method anywhere in the inheritance hierarchy, it will die.</source>
          <target state="translated">&lt;code&gt;File::MP3&lt;/code&gt; クラスで &lt;code&gt;save()&lt;/code&gt; メソッドを定義していないので、Perlは &lt;code&gt;File::MP3&lt;/code&gt; クラスの親クラスを調べて、 &lt;code&gt;save()&lt;/code&gt; メソッドを見つけます。Perlが継承階層のどこにも &lt;code&gt;save()&lt;/code&gt; メソッドを見つけられない場合、それは死にます。</target>
        </trans-unit>
        <trans-unit id="3e236441f92cccda5b2d49a5d2e52d11313518e5" translate="yes" xml:space="preserve">
          <source>Since we don't have an NV for &lt;code&gt;$b&lt;/code&gt; , we'll have to use &lt;code&gt;sv_2nv&lt;/code&gt; to convert it. If we step again, we'll find ourselves there:</source>
          <target state="translated">&lt;code&gt;$b&lt;/code&gt; NVがないため、 &lt;code&gt;sv_2nv&lt;/code&gt; を使用して変換する必要があります。もう一度足を踏み入れると、そこにいることがわかります。</target>
        </trans-unit>
        <trans-unit id="43d65fe03aac7da5dd4ef49b28b5012afba90c77" translate="yes" xml:space="preserve">
          <source>Since we don't have an NV for &lt;code&gt;$b&lt;/code&gt;, we'll have to use &lt;code&gt;sv_2nv&lt;/code&gt; to convert it. If we step again, we'll find ourselves there:</source>
          <target state="translated">&lt;code&gt;$b&lt;/code&gt; NVがないため、 &lt;code&gt;sv_2nv&lt;/code&gt; を使用して変換する必要があります。もう一度足を踏み入れると、そこにいることに気付くでしょう。</target>
        </trans-unit>
        <trans-unit id="3708f0927e1925f92bdee0634ab63e7742c6b549" translate="yes" xml:space="preserve">
          <source>Since we don't know if &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; works, or even subroutines, use ad hoc tests for these three. Step carefully to avoid using the feature being tested. Tests in</source>
          <target state="translated">作業が &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; かどうか、あるいはサブルーチンさえもわからないので、これら3つにはアドホックテストを使用します。テスト中の機能を使用しないように注意してください。テスト</target>
        </trans-unit>
        <trans-unit id="959f38fbc36ca9c82998d3e370dda38e5dddb0bf" translate="yes" xml:space="preserve">
          <source>Since we don't know if &lt;code&gt;require&lt;/code&gt; works, or even subroutines, use ad hoc tests for these three. Step carefully to avoid using the feature being tested. Tests in</source>
          <target state="translated">作業が &lt;code&gt;require&lt;/code&gt; かどうか、あるいはサブルーチンさえもわからないので、これら3つにアドホックテストを使用します。テスト対象の機能を使用しないように注意してください。でのテスト</target>
        </trans-unit>
        <trans-unit id="b3f9ededf0cd07d09b1ffd3609acb21770a40353" translate="yes" xml:space="preserve">
          <source>Since we feed a list of ten 2-digit hexadecimal strings to &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, the pack template should contain ten pack codes. If this is run on a computer with ASCII character coding, it will print &lt;code&gt;0123456789&lt;/code&gt; .</source>
          <target state="translated">10個の2桁の16進数文字列のリストを &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; にフィードするため、packテンプレートには10​​個のパックコードを含める必要があります。これがASCII文字コードのコンピューターで実行されると、 &lt;code&gt;0123456789&lt;/code&gt; が出力されます。</target>
        </trans-unit>
        <trans-unit id="c3e96dcf9d6747abca3c34da42f376ec3097c3d9" translate="yes" xml:space="preserve">
          <source>Since we feed a list of ten 2-digit hexadecimal strings to &lt;code&gt;pack&lt;/code&gt;, the pack template should contain ten pack codes. If this is run on a computer with ASCII character coding, it will print &lt;code&gt;0123456789&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pack&lt;/code&gt; 2桁の16進文字列10個のリストをフィードするため、パックテンプレートには10​​個のパックコードが含まれている必要があります。これをASCII文字コードを使用するコンピューターで実行すると、 &lt;code&gt;0123456789&lt;/code&gt; が出力されます。</target>
        </trans-unit>
        <trans-unit id="c1a3bb738728020d7b3d2bd56167deba0672548c" translate="yes" xml:space="preserve">
          <source>Since we said earlier:</source>
          <target state="translated">さっき言ったように</target>
        </trans-unit>
        <trans-unit id="78829eafb6296e19175ed55a3097f673b5dc1d5f" translate="yes" xml:space="preserve">
          <source>Since you can assign to a list of variables, you can also assign to an array or hash slice.</source>
          <target state="translated">変数のリストに代入できるので、配列やハッシュスライスに代入することもできます。</target>
        </trans-unit>
        <trans-unit id="35b796faff1e6866bc3d8ff9ecdff8f636cea4f9" translate="yes" xml:space="preserve">
          <source>Since you only run one test per program &lt;code&gt;new&lt;/code&gt; always returns the same Test::Builder object. No matter how many times you call &lt;code&gt;new()&lt;/code&gt; , you're getting the same object. This is called a singleton. This is done so that multiple modules share such global information as the test counter and where test output is going.</source>
          <target state="translated">プログラムごとに1つのテストしか実行しないため、 &lt;code&gt;new&lt;/code&gt; は常に同じTest :: Builderオブジェクトを返します。 &lt;code&gt;new()&lt;/code&gt; を何度呼び出しても、同じオブジェクトを取得しています。これはシングルトンと呼ばれます。これは、複数のモジュールがテストカウンターやテスト出力の送信先などのグローバル情報を共有するために行われます。</target>
        </trans-unit>
        <trans-unit id="d6632404c7510ee37ef12fec086b1b9886c3c039" translate="yes" xml:space="preserve">
          <source>Since you only run one test per program &lt;code&gt;new&lt;/code&gt; always returns the same Test::Builder object. No matter how many times you call &lt;code&gt;new()&lt;/code&gt;, you're getting the same object. This is called a singleton. This is done so that multiple modules share such global information as the test counter and where test output is going.</source>
          <target state="translated">プログラムごとに1つのテストしか実行しないため、 &lt;code&gt;new&lt;/code&gt; は常に同じTest :: Builderオブジェクトを返します。 &lt;code&gt;new()&lt;/code&gt; を何度呼び出しても、同じオブジェクトを取得します。これはシングルトンと呼ばれます。これは、複数のモジュールがテストカウンターやテスト出力の送信先などのグローバル情報を共有するために行われます。</target>
        </trans-unit>
        <trans-unit id="5df43da3b7bd5966cc2c20737e50dc599284dd8e" translate="yes" xml:space="preserve">
          <source>Since you want to be a good programmer, you probably want to use a lexical filehandle, even though formats are designed to work with bareword filehandles since the default format names take the filehandle name. However, you can control this with some Perl special per-filehandle variables: &lt;code&gt;$^&lt;/code&gt; , which names the top-of-page format, and &lt;code&gt;$~&lt;/code&gt; which shows the line format. You have to change the default filehandle to set these variables:</source>
          <target state="translated">優れたプログラマーになりたいので、デフォルトのフォーマット名はファイルハンドル名をとるので、フォーマットはベアワードファイルハンドルで機能するように設計されていますが、レキシカルファイルハンドルを使用する必要があります。ただし、Perlのファイルハンドルごとの特別な変数を使用して、これを制御できます。 &lt;code&gt;$^&lt;/code&gt; はページの先頭の形式を示し、 &lt;code&gt;$~&lt;/code&gt; は行の形式を示します。これらの変数を設定するには、デフォルトのファイルハンドルを変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="8a72acc5d7f8358918f3a719037cabf59df13c37" translate="yes" xml:space="preserve">
          <source>Since you want to be a good programmer, you probably want to use a lexical filehandle, even though formats are designed to work with bareword filehandles since the default format names take the filehandle name. However, you can control this with some Perl special per-filehandle variables: &lt;code&gt;$^&lt;/code&gt;, which names the top-of-page format, and &lt;code&gt;$~&lt;/code&gt; which shows the line format. You have to change the default filehandle to set these variables:</source>
          <target state="translated">デフォルトのフォーマット名はファイルハンドル名を使用するため、フォーマットはベアワードファイルハンドルで機能するように設計されていますが、優れたプログラマーになりたいので、おそらく字句ファイルハンドルを使用することをお勧めします。ただし、これは、Perlの特別なファイルハンドルごとの変数で制御できます。 &lt;code&gt;$^&lt;/code&gt; はページの先頭の形式を示し、 &lt;code&gt;$~&lt;/code&gt; は行の形式を示します。これらの変数を設定するには、デフォルトのファイルハンドルを変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="31ee6b56ac231ef340b4b0ce7a9b1c774baa56bb" translate="yes" xml:space="preserve">
          <source>Since you're assigning to a scalar, the righthand side is in scalar context. The comma operator (yes, it's an operator!) in scalar context evaluates its lefthand side, throws away the result, and evaluates it's righthand side and returns the result. In effect, that list-lookalike assigns to &lt;code&gt;$scalar&lt;/code&gt; it's rightmost value. Many people mess this up because they choose a list-lookalike whose last element is also the count they expect:</source>
          <target state="translated">スカラーに割り当てるので、右側はスカラーコンテキストになります。スカラーコンテキストのコンマ演算子（はい、これは演算子です！）は、左側を評価し、結果を破棄し、右側を評価して結果を返します。実際には、そのリストのように、 &lt;code&gt;$scalar&lt;/code&gt; に右端の値を割り当てます。多くの人々は、最後の要素が期待する数でもあるリストのようなものを選択するので、これを台無しにします：</target>
        </trans-unit>
        <trans-unit id="b1e4d1f3b6584286a7b1e87475e6b68a4163f836" translate="yes" xml:space="preserve">
          <source>Since you're using ssh, you'll have to pass some extra arguments to Configure:</source>
          <target state="translated">ssh を使用しているので、Configure にいくつかの余分な引数を渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="a9e2d6a9962eddfc9f09d9986a8e8b8277588e75" translate="yes" xml:space="preserve">
          <source>Since, as mentioned above, bitwise operators may take extra arguments, you may want to use something like &lt;code&gt;(lobj, robj, swap, ...)&lt;/code&gt; (with literal &lt;code&gt;...&lt;/code&gt;) as your parameter list.</source>
          <target state="translated">上記のように、ビット演算子は追加の引数を取る可能性があるため、パラメーターリストとして &lt;code&gt;(lobj, robj, swap, ...)&lt;/code&gt; （リテラル &lt;code&gt;...&lt;/code&gt; を使用）のようなものを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="20c0b7bdab70ca2cc9c844a0d74a3af0bbf41c3e" translate="yes" xml:space="preserve">
          <source>Singapore</source>
          <target state="translated">Singapore</target>
        </trans-unit>
        <trans-unit id="b227b1e063b8171583fca32f48c11de71e845c84" translate="yes" xml:space="preserve">
          <source>Single 8-bit characters.</source>
          <target state="translated">シングル8ビット文字。</target>
        </trans-unit>
        <trans-unit id="62539aaf022cade9262a4b6494d3943b6956e5a8" translate="yes" xml:space="preserve">
          <source>Single Byte Encodings</source>
          <target state="translated">シングルバイトエンコーディング</target>
        </trans-unit>
        <trans-unit id="4530f93a4bcf9d5873d117244d6fb7434ad7291d" translate="yes" xml:space="preserve">
          <source>Single Quotes</source>
          <target state="translated">シングルの名言</target>
        </trans-unit>
        <trans-unit id="012b49ff1827b6d4c0bd35ca2f9e9f57f854cb53" translate="yes" xml:space="preserve">
          <source>Single form (&lt;code&gt;\p{name}&lt;/code&gt;) tighter rules:</source>
          <target state="translated">単一形式（ &lt;code&gt;\p{name}&lt;/code&gt; ）のより厳密なルール：</target>
        </trans-unit>
        <trans-unit id="6a8a4e28358318025ab4a8b973931c58f9de9358" translate="yes" xml:space="preserve">
          <source>Single quotes indicate the text is to be treated literally with no interpolation of its content. This is similar to single quoted strings except that backslashes have no special meaning, with &lt;code&gt;\\&lt;/code&gt; being treated as two backslashes and not one as they would in every other quoting construct.</source>
          <target state="translated">一重引用符は、テキストがその内容を補間せずに文字どおりに処理されることを示します。これは、バックスラッシュが特別な意味を持たないことを除いて、単一引用符付き文字列に似ています。 &lt;code&gt;\\&lt;/code&gt; は、他のすべての引用構文でのように1つではなく2つのバックスラッシュとして扱われます。</target>
        </trans-unit>
        <trans-unit id="2988b7ce72e4ef43941b210b5d2de77bb3a0210b" translate="yes" xml:space="preserve">
          <source>Single space after keywords that are followed by parens, no space between function name and following paren</source>
          <target state="translated">キーワードの後にパーレンが続くキーワードの後にはシングルスペース、関数名と後続のパーレンの間にはスペースはありません。</target>
        </trans-unit>
        <trans-unit id="998773a99793919677d4844303decc2eb2f960f3" translate="yes" xml:space="preserve">
          <source>Single step. Executes until the beginning of another statement, descending into subroutine calls. If an expression is supplied that includes function calls, it too will be single-stepped.</source>
          <target state="translated">シングルステップ。別の文が始まるまで実行され、サブルーチンの呼び出しに発展します。関数呼び出しを含む式が与えられた場合、それもシングルステップになります。</target>
        </trans-unit>
        <trans-unit id="b39e88e61083334da27e22ac3304f5322910c7a2" translate="yes" xml:space="preserve">
          <source>Single-letter properties match all characters in any of the two-letter sub-properties starting with the same letter. &lt;code&gt;LC&lt;/code&gt; and &lt;code&gt;L&amp;amp;&lt;/code&gt; are special: both are aliases for the set consisting of everything matched by &lt;code&gt;Ll&lt;/code&gt; , &lt;code&gt;Lu&lt;/code&gt; , and &lt;code&gt;Lt&lt;/code&gt; .</source>
          <target state="translated">1文字のプロパティは、同じ文字で始まる2文字のサブプロパティのすべての文字に一致します。 &lt;code&gt;LC&lt;/code&gt; と &lt;code&gt;L&amp;amp;&lt;/code&gt; は特別です。どちらも、 &lt;code&gt;Ll&lt;/code&gt; 、 &lt;code&gt;Lu&lt;/code&gt; 、および &lt;code&gt;Lt&lt;/code&gt; に一致するすべてのもので構成されるセットのエイリアスです。</target>
        </trans-unit>
        <trans-unit id="d8acda7f90b42defaf44562897d2b28bbd83f4e8" translate="yes" xml:space="preserve">
          <source>Single-letter properties match all characters in any of the two-letter sub-properties starting with the same letter. &lt;code&gt;LC&lt;/code&gt; and &lt;code&gt;L&amp;amp;&lt;/code&gt; are special: both are aliases for the set consisting of everything matched by &lt;code&gt;Ll&lt;/code&gt;, &lt;code&gt;Lu&lt;/code&gt;, and &lt;code&gt;Lt&lt;/code&gt;.</source>
          <target state="translated">1文字のプロパティは、同じ文字で始まる2文字のサブプロパティのすべての文字と一致します。 &lt;code&gt;LC&lt;/code&gt; と &lt;code&gt;L&amp;amp;&lt;/code&gt; は特別です。どちらも、 &lt;code&gt;Ll&lt;/code&gt; 、 &lt;code&gt;Lu&lt;/code&gt; 、および &lt;code&gt;Lt&lt;/code&gt; に一致するすべてのもので構成されるセットのエイリアスです。</target>
        </trans-unit>
        <trans-unit id="47784ae534e76f07f938e74b6b49c2e04c524d60" translate="yes" xml:space="preserve">
          <source>Single-step flag. Will be true if the API will stop at the next statement.</source>
          <target state="translated">シングルステップフラグ。APIが次のステートメントで停止する場合はtrueになります。</target>
        </trans-unit>
        <trans-unit id="3fd72cbf421902beaf4893343701c7e9f292181e" translate="yes" xml:space="preserve">
          <source>Sinograms like &amp;ldquo;東京&amp;rdquo; come back with character names of &lt;code&gt;CJK UNIFIED IDEOGRAPH-6771&lt;/code&gt; and &lt;code&gt;CJK UNIFIED IDEOGRAPH-4EAC&lt;/code&gt; , because their &amp;ldquo;names&amp;rdquo; vary. The CPAN &lt;code&gt;Unicode::Unihan&lt;/code&gt; module has a large database for decoding these (and a whole lot more), provided you know how to understand its output.</source>
          <target state="translated">「東京」のような &lt;code&gt;CJK UNIFIED IDEOGRAPH-4EAC&lt;/code&gt; は、「名前」が異なるため、 &lt;code&gt;CJK UNIFIED IDEOGRAPH-6771&lt;/code&gt; およびCJK UNIFIED IDEOGRAPH-4EACの文字名で返されます。CPAN &lt;code&gt;Unicode::Unihan&lt;/code&gt; モジュールには、その出力を理解する方法がわかっていれば、これらをデコードするための大規模なデータベース（およびその他多数）があります。</target>
        </trans-unit>
        <trans-unit id="b9df3910d077951b174aefd94b54e0bc3ac87d77" translate="yes" xml:space="preserve">
          <source>Sinograms like &amp;ldquo;東京&amp;rdquo; come back with character names of &lt;code&gt;CJK UNIFIED IDEOGRAPH-6771&lt;/code&gt; and &lt;code&gt;CJK UNIFIED IDEOGRAPH-4EAC&lt;/code&gt;, because their &amp;ldquo;names&amp;rdquo; vary. The CPAN &lt;code&gt;Unicode::Unihan&lt;/code&gt; module has a large database for decoding these (and a whole lot more), provided you know how to understand its output.</source>
          <target state="translated">「東京」のような &lt;code&gt;CJK UNIFIED IDEOGRAPH-4EAC&lt;/code&gt; は、「名前」が異なるため、CJK統合漢字-6771とCJK統合 &lt;code&gt;CJK UNIFIED IDEOGRAPH-6771&lt;/code&gt; 文字名で戻ってきます。CPAN &lt;code&gt;Unicode::Unihan&lt;/code&gt; モジュールには、その出力を理解する方法を知っていれば、これら（およびそれ以上）をデコードするための大規模なデータベースがあります。</target>
        </trans-unit>
        <trans-unit id="28e8fd907b0e11131190209772e747eaed820c59" translate="yes" xml:space="preserve">
          <source>Site-specific perl extensions and modules can be installed in one of two places. Put architecture-independent files into:</source>
          <target state="translated">サイト固有の perl 拡張機能とモジュールは、2つの場所のいずれかにインストールすることができます。アーキテクチャに依存しないファイルを</target>
        </trans-unit>
        <trans-unit id="00832815e260edfba2e83c2f4b5a6a35db1c2d1c" translate="yes" xml:space="preserve">
          <source>Six such conversions are possible:</source>
          <target state="translated">このような変換は6つあります。</target>
        </trans-unit>
        <trans-unit id="ab71370c759f98b4c2c5f12f621583aa7cb9faf2" translate="yes" xml:space="preserve">
          <source>Sixth:</source>
          <target state="translated">Sixth:</target>
        </trans-unit>
        <trans-unit id="43701334f4b3da3fdeb3363278217ac0f215873d" translate="yes" xml:space="preserve">
          <source>Size of the function table. This is compared against the value PerlIO code &quot;knows&quot; as a compatibility check. Future versions</source>
          <target state="translated">関数テーブルのサイズ。これは、互換性チェックとしてPerlIOコードが「知っている」値と比較されます。将来のバージョン</target>
        </trans-unit>
        <trans-unit id="936d52e1c615ea7024397f6ff1aeb7c89ebd5bad" translate="yes" xml:space="preserve">
          <source>Size, Endianness, and BOM</source>
          <target state="translated">サイズ、エンディアンス、BOM</target>
        </trans-unit>
        <trans-unit id="0ec62bfb6670c34f50ed4190d4e6017dc34d76d5" translate="yes" xml:space="preserve">
          <source>Skip a package when throwing autodie exceptions</source>
          <target state="translated">自動生成の例外を投げるときにパッケージをスキップする</target>
        </trans-unit>
        <trans-unit id="73e856b6ebf6aeb3a630b124c6e02c2a78566450" translate="yes" xml:space="preserve">
          <source>Skip all tests.</source>
          <target state="translated">すべてのテストをスキップします。</target>
        </trans-unit>
        <trans-unit id="99c526a5770e20da3a4179e52c1b052314f790b3" translate="yes" xml:space="preserve">
          <source>Skip event type</source>
          <target state="translated">イベントタイプをスキップ</target>
        </trans-unit>
        <trans-unit id="31ffbfd6b2e06775aaf14afc6238b4599cf532c4" translate="yes" xml:space="preserve">
          <source>Skip events bump test counts just like &lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2::Event::Ok&lt;/a&gt; events, but they can never fail.</source>
          <target state="translated">スキップイベントは、&lt;a href=&quot;Test2::Event::Ok&quot;&gt;Test2 :: Event :: Ok&lt;/a&gt;イベントと同じようにテストカウントをバンプしますが、失敗することはありません。</target>
        </trans-unit>
        <trans-unit id="57a18bbc33fb3b107b0f37ec04073b6f8f1aa7be" translate="yes" xml:space="preserve">
          <source>Skip sub-char mapping should there be no code point.</source>
          <target state="translated">コードポイントがない場合は、サブチャーマッピングをスキップします。</target>
        </trans-unit>
        <trans-unit id="fa22bcdeb4f395bdc09dc2fd5b11b93a885994fb" translate="yes" xml:space="preserve">
          <source>Skip the real Pod formatting, and just show the raw Pod source (&lt;b&gt;U&lt;/b&gt;nformatted)</source>
          <target state="translated">実際のポッドのフォーマットをスキップして、未加工のポッドソースを表示します（&lt;b&gt;U&lt;/b&gt; nformatted）</target>
        </trans-unit>
        <trans-unit id="e6cd533514432f62bafda9ad5f9825a972ff6179" translate="yes" xml:space="preserve">
          <source>Skip this section if the XSUB functions are supposed to be called from other modules only; read it only if you call your XSUBs from the code in your module, or have a &lt;code&gt;BOOT:&lt;/code&gt; section in your XS file (see &lt;a href=&quot;perlxs#The-BOOT%3A-Keyword&quot;&gt;&quot;The BOOT: Keyword&quot; in perlxs&lt;/a&gt;). What is described here is equally applicable to the &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; interface.</source>
          <target state="translated">XSUB関数が他のモジュールからのみ呼び出されることになっている場合は、このセクションをスキップしてください。モジュール内のコードからXSUBを呼び出す場合、またはXSファイルに &lt;code&gt;BOOT:&lt;/code&gt; セクションがある場合にのみ読み取ります（&lt;a href=&quot;perlxs#The-BOOT%3A-Keyword&quot;&gt;perlxsの「BOOT：キーワード」を参照&lt;/a&gt;）。ここで説明する内容は、&lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt;インターフェースにも同様に適用できます。</target>
        </trans-unit>
        <trans-unit id="3e59adfb26a9113df0d5c476d39a18d0087952f5" translate="yes" xml:space="preserve">
          <source>Skip this section if the XSUB functions are supposed to be called from other modules only; read it only if you call your XSUBs from the code in your module, or have a &lt;code&gt;BOOT:&lt;/code&gt; section in your XS file (see &lt;a href=&quot;perlxs#The-BOOT%3a-Keyword&quot;&gt;The BOOT: Keyword in perlxs&lt;/a&gt;). What is described here is equally applicable to the &lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt; interface.</source>
          <target state="translated">XSUB関数が他のモジュールからのみ呼び出されることになっている場合は、このセクションをスキップしてください。モジュールのコードからXSUBを呼び出すか、XSファイルに &lt;code&gt;BOOT:&lt;/code&gt; セクションがある場合にのみこれを読み取ります（&lt;a href=&quot;perlxs#The-BOOT%3a-Keyword&quot;&gt;perlxsのBOOT：キーワードを参照&lt;/a&gt;）。ここで説明する内容は、&lt;a href=&quot;dynaloader&quot;&gt;DynaLoader&lt;/a&gt;インターフェースにも同様に適用できます。</target>
        </trans-unit>
        <trans-unit id="a516a3ce4b9fd1e3a2a9186564fe4ca0d9da8218" translate="yes" xml:space="preserve">
          <source>Skipping tests</source>
          <target state="translated">テストのスキップ</target>
        </trans-unit>
        <trans-unit id="54ab6781ff6514e41583039acc42db3e0f3c9201" translate="yes" xml:space="preserve">
          <source>Skips all the tests, using the given &lt;code&gt;$reason&lt;/code&gt; . Exits immediately with 0.</source>
          <target state="translated">指定された &lt;code&gt;$reason&lt;/code&gt; を使用して、すべてのテストをスキップします。0ですぐに終了します。</target>
        </trans-unit>
        <trans-unit id="9d406363c0222ce5a6c71553ed555dc077dda244" translate="yes" xml:space="preserve">
          <source>Skips all the tests, using the given &lt;code&gt;$reason&lt;/code&gt;. Exits immediately with 0.</source>
          <target state="translated">指定された &lt;code&gt;$reason&lt;/code&gt; を使用して、すべてのテストをスキップします。0ですぐに終了します。</target>
        </trans-unit>
        <trans-unit id="563adc0d862d00d2bcc7549833d1039985aead2a" translate="yes" xml:space="preserve">
          <source>Skips the current test, reporting &lt;code&gt;$why&lt;/code&gt; .</source>
          <target state="translated">現在のテストをスキップし、 &lt;code&gt;$why&lt;/code&gt; 報告します。</target>
        </trans-unit>
        <trans-unit id="9c9a19a668210cd54ae808f068a27dac1e967c53" translate="yes" xml:space="preserve">
          <source>Skips the current test, reporting &lt;code&gt;$why&lt;/code&gt;.</source>
          <target state="translated">現在のテストをスキップし、 &lt;code&gt;$why&lt;/code&gt; 報告します。</target>
        </trans-unit>
        <trans-unit id="ca1ac1071abc2c48fe8c683c23437c17bcd0e5ba" translate="yes" xml:space="preserve">
          <source>Skips to the next compressed data stream in the input file/buffer. If a new compressed data stream is found, the eof marker will be cleared and &lt;code&gt;$.&lt;/code&gt; will be reset to 0.</source>
          <target state="translated">入力ファイル/バッファ内の次の圧縮データストリームにスキップします。新しい圧縮データストリームが見つかると、eofマーカーはクリアされ、 &lt;code&gt;$.&lt;/code&gt; 0にリセットされます。</target>
        </trans-unit>
        <trans-unit id="4249f92b08fd3ea49d1d4587b0dc45efe6514ff5" translate="yes" xml:space="preserve">
          <source>SkyMarshal &amp;lt;skymarshal1729@gmail.com&amp;gt;</source>
          <target state="translated">SkyMarshal &amp;lt;skymarshal1729@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="aa1af20e2176a0b7a938bf7cbbbf01e3f656d901" translate="yes" xml:space="preserve">
          <source>Skye Shaw &amp;lt;</source>
          <target state="translated">スカイショー&amp;lt;</target>
        </trans-unit>
        <trans-unit id="41574ecb0de77a7fed0beca1f4434e4a44173169" translate="yes" xml:space="preserve">
          <source>Slab leaked from cv %p</source>
          <target state="translated">cv からスラブが漏れる %p</target>
        </trans-unit>
        <trans-unit id="d051f41b7de19e7acc50c00d91bed9bc77c2a243" translate="yes" xml:space="preserve">
          <source>Slab-based operator allocation</source>
          <target state="translated">スラブベースのオペレータ割当</target>
        </trans-unit>
        <trans-unit id="28422baab3fe565caf66be5cefa3539fc1817282" translate="yes" xml:space="preserve">
          <source>Slab_Alloc</source>
          <target state="translated">Slab_Alloc</target>
        </trans-unit>
        <trans-unit id="dfee07ce355211f20f3bdab2cb3fa2a9def9c336" translate="yes" xml:space="preserve">
          <source>Slab_Free</source>
          <target state="translated">Slab_Free</target>
        </trans-unit>
        <trans-unit id="8b86eb2caadb21d205d9d0ad56cf031153fb8e27" translate="yes" xml:space="preserve">
          <source>Slab_to_ro</source>
          <target state="translated">Slab_to_ro</target>
        </trans-unit>
        <trans-unit id="b4128d18330a7f45f087418a9b524193204735bc" translate="yes" xml:space="preserve">
          <source>Slab_to_rw</source>
          <target state="translated">Slab_to_rw</target>
        </trans-unit>
        <trans-unit id="147d6799969166c3bb4c81176bc4c31ac64ac6bd" translate="yes" xml:space="preserve">
          <source>Slaven Rezic &amp;lt;slaven.rezic@idealo.de&amp;gt;</source>
          <target state="translated">Slaven Rezic &amp;lt;slaven.rezic@idealo.de&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0ac691e6a9650a28847ff59e7d257f5f29d2f4fa" translate="yes" xml:space="preserve">
          <source>Slaven Rezic &amp;lt;slaven@rezic.de&amp;gt;</source>
          <target state="translated">Slaven Rezic &amp;lt;slaven@rezic.de&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e59d0602eb0550fd0dbf5d82907d6271ae4af6ea" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of microseconds (millionths of a second) specified. Returns the number of microseconds actually slept. Can sleep for more than one second, unlike the &lt;code&gt;usleep&lt;/code&gt; system call. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">指定したマイクロ秒（100万分の1秒）の間スリープします。実際にスリープしたマイクロ秒数を返します。 &lt;code&gt;usleep&lt;/code&gt; システムコールとは異なり、1秒以上スリープできます。ゼロ秒間スリープすることもできます。</target>
        </trans-unit>
        <trans-unit id="a7c111ccc19a7463efac9caa48bfd176015106c5" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of nanoseconds (1e9ths of a second) specified. Returns the number of nanoseconds actually slept (accurate only to microseconds, the nearest thousand of them). Can sleep for more than one second. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">指定したナノ秒(1e9分の1秒)分だけスリープします。実際にスリープしたナノ秒数を返します(正確なのは1000分の1に近いマイクロ秒のみ)。1秒以上スリープすることができます。のように動作することが多いゼロ秒スリープも可能です。</target>
        </trans-unit>
        <trans-unit id="858360f4742bec3dbad2b4b1586f95ca8cfce48d" translate="yes" xml:space="preserve">
          <source>Sleeps for the number of nanoseconds (1e9ths of a second) specified. Returns the number of nanoseconds actually slept. The $which is the &quot;clock id&quot;, as with clock_gettime() and clock_getres(). The flags default to zero but &lt;code&gt;TIMER_ABSTIME&lt;/code&gt; can specified (must be exported explicitly) which means that &lt;code&gt;$nanoseconds&lt;/code&gt; is not a time interval (as is the default) but instead an absolute time. Can sleep for more than one second. Can also sleep for zero seconds, which often works like a</source>
          <target state="translated">指定したナノ秒（1e9秒）の数だけスリープします。実際にスリープしたナノ秒数を返します。$ whichは、clock_gettime（）およびclock_getres（）と同様に、「クロックID」です。フラグのデフォルトはゼロですが、 &lt;code&gt;TIMER_ABSTIME&lt;/code&gt; を指定できます（明示的にエクスポートする必要があります）。つまり、 &lt;code&gt;$nanoseconds&lt;/code&gt; nanosecondsは（デフォルトのように）時間間隔ではなく、絶対時間です。1秒以上眠ることができます。ゼロ秒間スリープすることもできます。</target>
        </trans-unit>
        <trans-unit id="bfc9358c36664745e87042ffeea926ba49acc8f0" translate="yes" xml:space="preserve">
          <source>Sleeps for the specified amount of seconds. Returns the number of seconds actually slept (a floating point value). This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; below.</source>
          <target state="translated">指定した秒数の間スリープします。実際にスリープした秒数（浮動小数点値）を返します。この関数はインポート可能であり、perlで提供される &lt;code&gt;&lt;a href=&quot;../functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 優れた代替品になります。以下の&lt;a href=&quot;#EXAMPLES&quot;&gt;例を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="18ae77017c85766e5d3a71c2d083fdfba9357fdb" translate="yes" xml:space="preserve">
          <source>Sleeps for the specified amount of seconds. Returns the number of seconds actually slept (a floating point value). This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;sleep&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;EXAMPLES&quot;&lt;/a&gt; below.</source>
          <target state="translated">指定された秒数の間スリープします。実際にスリープした秒数（浮動小数点値）を返します。この関数はインポートできるので、perlで提供される &lt;code&gt;sleep&lt;/code&gt; 代わりにドロップインを使用できます。以下の&lt;a href=&quot;#EXAMPLES&quot;&gt;「例」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a455933ba1827ec6d2d6cea6cb61c05bd3954351" translate="yes" xml:space="preserve">
          <source>Slices</source>
          <target state="translated">Slices</target>
        </trans-unit>
        <trans-unit id="de97696f04df2d455746fc0459c7a0334ac08b94" translate="yes" xml:space="preserve">
          <source>Slices in scalar context return the last item of the slice.</source>
          <target state="translated">スカラコンテキスト内のスライスは、スライスの最後の項目を返します。</target>
        </trans-unit>
        <trans-unit id="fade4867f2281855741bb2fdfae6ec6bfe669774" translate="yes" xml:space="preserve">
          <source>Slicing operations and parentheses cause the right-hand side to be evaluated in list context:</source>
          <target state="translated">スライス操作と括弧は、リストコンテキストで右辺が評価される原因となります。</target>
        </trans-unit>
        <trans-unit id="dcf621083da44b050ec0828499127db4dc13006b" translate="yes" xml:space="preserve">
          <source>SlickEdit</source>
          <target state="translated">SlickEdit</target>
        </trans-unit>
        <trans-unit id="71625e10c96350176b8faecaf24d1d897cf6efce" translate="yes" xml:space="preserve">
          <source>Slightly modified by Arthur Bergman to fit the new thread model/module.</source>
          <target state="translated">新しいスレッドモデル/モジュールに合わせて、アーサー・バーグマンによって少し修正されました。</target>
        </trans-unit>
        <trans-unit id="b6c149c3e00467fba347629a63ed02fed098d061" translate="yes" xml:space="preserve">
          <source>Slovakia</source>
          <target state="translated">Slovakia</target>
        </trans-unit>
        <trans-unit id="d1aa0503612aa4168939b77b59ca74532a11951a" translate="yes" xml:space="preserve">
          <source>Slovenia</source>
          <target state="translated">Slovenia</target>
        </trans-unit>
        <trans-unit id="945d75b6ccb37accbc9182a048ffec51dcd1a47f" translate="yes" xml:space="preserve">
          <source>Slurpy parameter not last</source>
          <target state="translated">スラーピーパラメータが最後ではない</target>
        </trans-unit>
        <trans-unit id="5c84511f9de85f2a5bea737ad0651170f5fc9c55" translate="yes" xml:space="preserve">
          <source>Smart matching a non-overloaded object breaks encapsulation</source>
          <target state="translated">オーバーロードされていないオブジェクトをスマートにマッチングするとカプセル化が破られる</target>
        </trans-unit>
        <trans-unit id="c05c92e1201b3c7a99b14a3196c426c41067b9ce" translate="yes" xml:space="preserve">
          <source>Smartmatch Operator</source>
          <target state="translated">スマートマッチオペレーター</target>
        </trans-unit>
        <trans-unit id="853b5644d464d7aa87bcee31b98647e7b0076053" translate="yes" xml:space="preserve">
          <source>Smartmatch expects to be able to allocate an op at run time, run it, and then throw it away. For that to work the op is simply malloced when PL_compcv hasn't been set up. So all slab-allocated ops are marked as such (&lt;code&gt;-&amp;gt;op_slabbed&lt;/code&gt;), to distinguish them from malloced ops.</source>
          <target state="translated">Smartmatchは、実行時にopを割り当て、実行してから破棄できることを期待しています。それが機能するためには、PL_compcvが設定されていない場合、opは単純にmallocされます。したがって、スラブに割り当てられたすべてのopsは、そのようにマークされ（ &lt;code&gt;-&amp;gt;op_slabbed&lt;/code&gt; ）、mallocされたopsと区別されます。</target>
        </trans-unit>
        <trans-unit id="226b6fe8f9e2cd4e8ca8e6e55a94a83ba3f2cf5a" translate="yes" xml:space="preserve">
          <source>Smartmatch is experimental</source>
          <target state="translated">スマートマッチは実験的</target>
        </trans-unit>
        <trans-unit id="e4adce585ab904a3b57996c9eacd1526a8856e59" translate="yes" xml:space="preserve">
          <source>Smartmatching of Objects</source>
          <target state="translated">オブジェクトのスマートマッチング</target>
        </trans-unit>
        <trans-unit id="fcef3abf224b18a1a9539b5cd1a74a21f40eb21d" translate="yes" xml:space="preserve">
          <source>Smartmatching one hash against another reports whether both contain the same keys, no more and no less. This could be used to see whether two records have the same field names, without caring what values those fields might have. For example:</source>
          <target state="translated">あるハッシュと別のハッシュをスマートマッチングすると、両方が同じキーを含んでいるかどうかをレポートします。これは、2つのレコードが同じフィールド名を持っているかどうかを確認するために使われますが、フィールドの値を気にする必要はありません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="f02489100f7e7550e46dc3c0c8c28f36daa00353" translate="yes" xml:space="preserve">
          <source>Smoke testing Perl 5</source>
          <target state="translated">スモークテスト Perl 5</target>
        </trans-unit>
        <trans-unit id="c177aabcbd4f359e0aaa8a530199381f4cf98371" translate="yes" xml:space="preserve">
          <source>Snooping</source>
          <target state="translated">Snooping</target>
        </trans-unit>
        <trans-unit id="4460e52ce30ee2f7dab472f65e7bc2c1c88dffad" translate="yes" xml:space="preserve">
          <source>So I got smart: I decided to be lazy and let the C compiler parse the C, which would spit out debugger stabs for me to read. These were much easier to parse. It's still not a pretty program, but at least it's more robust.</source>
          <target state="translated">そこで私は賢くなりました。私は怠け者になり、C コンパイラに C を解析させることにしました。この方がずっと簡単にパースできました。まだまだきれいなプログラムではありませんが、少なくともより堅牢になりました。</target>
        </trans-unit>
        <trans-unit id="a1f5ce193c65cebf4de4614792ca39a016541f36" translate="yes" xml:space="preserve">
          <source>So a typical call to check would look like this:</source>
          <target state="translated">そのため、典型的なチェックの電話は次のようになります。</target>
        </trans-unit>
        <trans-unit id="32bf3b4ebf1dd24fdccf516f7c267bd10f4fed6f" translate="yes" xml:space="preserve">
          <source>So assuming the database created above, we can use &lt;code&gt;get_dup&lt;/code&gt; like this:</source>
          <target state="translated">上記で作成したデータベースを想定すると、 &lt;code&gt;get_dup&lt;/code&gt; ようにget_dupを使用できます。</target>
        </trans-unit>
        <trans-unit id="9531481e3958e36f87e15fe09a502608d674e17a" translate="yes" xml:space="preserve">
          <source>So called because of a similar construct in &lt;b&gt;shells&lt;/b&gt; that pretends that the &lt;b&gt;lines&lt;/b&gt; following the &lt;b&gt;command&lt;/b&gt; are a separate &lt;b&gt;file&lt;/b&gt; to be fed to the command, up to some terminating string. In Perl, however, it&amp;rsquo;s just a fancy form of quoting.</source>
          <target state="translated">だから、理由で同様のコンストラクトのと呼ばれる&lt;b&gt;殻&lt;/b&gt;ふりをすることをことを&lt;b&gt;行&lt;/b&gt;以下&lt;b&gt;のコマンドは、&lt;/b&gt;分離されている&lt;b&gt;ファイル&lt;/b&gt;のコマンドに供給するための、いくつかの終端文字列まで。ただし、Perlでは、これは単なる派手な引用形式です。</target>
        </trans-unit>
        <trans-unit id="93e9a6ece24ada54b55dc7612c9389e7a638c36b" translate="yes" xml:space="preserve">
          <source>So each subroutine is born with an array of scratchpads (of length 1). On each entry to the subroutine it is checked that the current depth of the recursion is not more than the length of this array, and if it is, new scratchpad is created and pushed into the array.</source>
          <target state="translated">したがって、各サブルーチンはスクラッチパッドの配列(長さ1)を持って生まれます。サブルーチンの各エントリでは、現在の再帰の深さがこの配列の長さを超えていないかどうかがチェックされ、超えている場合は、新しいスクラッチパッドが作成されて配列に押し込まれます。</target>
        </trans-unit>
        <trans-unit id="c0f1f69e80ab7ebe217f8989a490d4af7ac57aa2" translate="yes" xml:space="preserve">
          <source>So far I've shown you nothing that</source>
          <target state="translated">今まで何も見せていない</target>
        </trans-unit>
        <trans-unit id="bfd2a2cfe6e08c35c8f0019242b9920756d8258f" translate="yes" xml:space="preserve">
          <source>So far so good. But suppose the way you're implementing this is:</source>
          <target state="translated">ここまでは順調です。でも、仮に実装方法が</target>
        </trans-unit>
        <trans-unit id="99d938c6031e3ad535ec502cea56c5d218d4389a" translate="yes" xml:space="preserve">
          <source>So far so good. Those of you who have been paying attention will have spotted that the tied object hasn't been used so far. So lets add an extra method to the Remember class to allow comments to be included in the file; say, something like this:</source>
          <target state="translated">ここまでは順調です。注意を払っていた人は、Tiedオブジェクトが今のところ使われていないことに気づいたでしょう。そこで、Rememberクラスに追加のメソッドを追加して、コメントをファイルに含めることができるようにします。</target>
        </trans-unit>
        <trans-unit id="438b9b4e31229df657e054c261ee9d298ca8b103" translate="yes" xml:space="preserve">
          <source>So far we've merely tried to find and list the experimental features and infer their inception, versions, etc. There's a lot of speculation here.</source>
          <target state="translated">今のところ我々は単に実験的な機能を見つけてリストアップして、それらの初期設定やバージョンなどを推測しようとしているに過ぎません。ここでは多くの憶測が飛び交っています。</target>
        </trans-unit>
        <trans-unit id="10bc3a4c124b48037408d12298d27779d339f321" translate="yes" xml:space="preserve">
          <source>So far, so good. With the knowledge above you can already perform searches with just about any literal string regexp you can dream up. Here is a</source>
          <target state="translated">ここまでは順調です。上記の知識があれば、思いつく限りのリテラル文字列正規表現を使って検索を行うことができます。以下はその例です。</target>
        </trans-unit>
        <trans-unit id="8af65d96d3224572aaaeff6426ae992e0bd5b192" translate="yes" xml:space="preserve">
          <source>So far, we're using just the normal list return mechanism. What happens if you want to pass or return a hash? Well, if you're using only one of them, or you don't mind them concatenating, then the normal calling convention is ok, although a little expensive.</source>
          <target state="translated">今のところ、通常のリストリターンの仕組みだけを使っています。ハッシュを渡したり返したりしたい場合はどうなるのでしょうか? どちらか一方だけを使っているか、あるいはそれらが連結されることを気にしないのであれば、通常の呼び出し方法でも問題ありません。</target>
        </trans-unit>
        <trans-unit id="6a1a83e9f4437f40c54f1506b859ac7294d0d128" translate="yes" xml:space="preserve">
          <source>So far, we've seen literals used as templates. If the list of pack items doesn't have fixed length, an expression constructing the template is required (whenever, for some reason, &lt;code&gt;()*&lt;/code&gt; cannot be used). Here's an example: To store named string values in a way that can be conveniently parsed by a C program, we create a sequence of names and null terminated ASCII strings, with &lt;code&gt;=&lt;/code&gt; between the name and the value, followed by an additional delimiting null byte. Here's how:</source>
          <target state="translated">これまで、テンプレートとして使用されるリテラルを見てきました。パックアイテムのリストが固定長でない場合、テンプレートを構成する式が必要です（何らかの理由で &lt;code&gt;()*&lt;/code&gt; を使用できない場合は常に）。次に例を示します。Cプログラムで簡単に解析できる方法で名前付き文字列値を格納するには、名前のシーケンスとnullで終了するASCII文字列を作成し、名前と値の間に &lt;code&gt;=&lt;/code&gt; を付け、その後に追加の区切りnullバイトを続けます。 。方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="7a5692420708108a4d7ad47094be88b57cf9bf66" translate="yes" xml:space="preserve">
          <source>So for English (with Bracket Notation) &lt;code&gt;&quot;...[quant,_1,file]...&quot;&lt;/code&gt; is fine (for 0 it returns &quot;0 files&quot;, for 1 it returns &quot;1 file&quot;, and for more it returns &quot;2 files&quot;, etc.)</source>
          <target state="translated">したがって、英語（ブラケット表記を使用）の場合、 &lt;code&gt;&quot;...[quant,_1,file]...&quot;&lt;/code&gt; は問題ありません（0の場合は「0ファイル」を返し、1の場合は「1ファイル」を返し、それ以上の場合は「」を返します2ファイル」など）</target>
        </trans-unit>
        <trans-unit id="8477c048b776b6250b8d3a6b206bd8a95a79a9ff" translate="yes" xml:space="preserve">
          <source>So for example, instead of using:</source>
          <target state="translated">だから例えば、代わりに</target>
        </trans-unit>
        <trans-unit id="23a15c81788a2c5aff56ccaef77af7e0b8ce44eb" translate="yes" xml:space="preserve">
          <source>So given the diagram above, Perl will search &lt;code&gt;Child&lt;/code&gt; , &lt;code&gt;Father&lt;/code&gt; , &lt;code&gt;PaternalGrandparent&lt;/code&gt; , &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; , &lt;code&gt;Mother&lt;/code&gt; , and finally &lt;code&gt;MaternalGrandparent&lt;/code&gt; . This may be a problem because now we're looking in &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;</source>
          <target state="translated">したがって、上記の図の場合、Perlは &lt;code&gt;Child&lt;/code&gt; 、 &lt;code&gt;Father&lt;/code&gt; 、 &lt;code&gt;PaternalGrandparent&lt;/code&gt; 、 &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; 、 &lt;code&gt;Mother&lt;/code&gt; 、最後に &lt;code&gt;MaternalGrandparent&lt;/code&gt; を検索します。 &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; を調べているため、これは問題になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="5f8c16c38e4b1347fbe4bd6bed13c87b6b97a967" translate="yes" xml:space="preserve">
          <source>So given the diagram above, Perl will search &lt;code&gt;Child&lt;/code&gt;, &lt;code&gt;Father&lt;/code&gt;, &lt;code&gt;PaternalGrandparent&lt;/code&gt;, &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;, &lt;code&gt;Mother&lt;/code&gt;, and finally &lt;code&gt;MaternalGrandparent&lt;/code&gt;. This may be a problem because now we're looking in &lt;code&gt;SharedGreatGrandParent&lt;/code&gt;</source>
          <target state="translated">したがって、上の図を考えると、Perlは &lt;code&gt;Child&lt;/code&gt; 、 &lt;code&gt;Father&lt;/code&gt; 、 &lt;code&gt;PaternalGrandparent&lt;/code&gt; 、 &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; 、 &lt;code&gt;Mother&lt;/code&gt; 、そして最後に &lt;code&gt;MaternalGrandparent&lt;/code&gt; を検索します。 &lt;code&gt;SharedGreatGrandParent&lt;/code&gt; を探しているので、これは問題になる可能性があります</target>
        </trans-unit>
        <trans-unit id="91f4e47cc018c4b1c4ca9fc78408994ad8035bd1" translate="yes" xml:space="preserve">
          <source>So here is the bottom line--if you are sure that control will revert back to the enclosing Perl scope fairly quickly after the end of your callback, then it isn't absolutely necessary to dispose explicitly of any temporaries you may have created. Mind you, if you are at all uncertain about what to do, it doesn't do any harm to tidy up anyway.</source>
          <target state="translated">コールバックの終了後に制御が Perl スコープにすぐに戻ると確信しているのであれば、作成したテンポラリを明示的に破棄する必要はありません。もし何をすべきかわからない場合は、とにかく片付けておいて損はありません。</target>
        </trans-unit>
        <trans-unit id="4443d502fbd614fe670f624b7a8d6e87d74c5b32" translate="yes" xml:space="preserve">
          <source>So hopefully you've now got a few ideas about what's good to modularise. Let's now see how it's done.</source>
          <target state="translated">うまくいけば、モジュール化するのに良いものについて、いくつかのアイデアが得られたことでしょう。では、実際にどのようにするのかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="6d3a27421600e7d4abecd702bd20845b8466123d" translate="yes" xml:space="preserve">
          <source>So how do I use a proxy with File::Fetch?</source>
          <target state="translated">では、File::Fetch でプロキシを使うにはどうすればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="9d00ee45ac1982b7db0dbf721dd3e3787ed6d62f" translate="yes" xml:space="preserve">
          <source>So how do you use a source filter in a Perl script? Above, I said that a source filter is just a special kind of module. Like all Perl modules, a source filter is invoked with a use statement.</source>
          <target state="translated">では、Perl スクリプトでソースフィルタを使うにはどうすればいいのでしょうか?上では、ソースフィルタは特殊なモジュールであると述べましたが、他の Perl モジュールと同様に、ソースフィルタは use 文で呼び出されます。他の Perl モジュールと同様に、ソースフィルタは use 文で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="6cca2cb75a50d0827a566440232066af85d09fbe" translate="yes" xml:space="preserve">
          <source>So how does it work?</source>
          <target state="translated">では、どのような仕組みになっているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="7fc04ce8d1c409ed6d44985cf7b3c46dd155a24f" translate="yes" xml:space="preserve">
          <source>So how hard could that be? You look at the code that produces the first item, and it reads:</source>
          <target state="translated">それがどれほど難しいことなのでしょうか?最初の項目を生成するコードを見て、それを読みます。</target>
        </trans-unit>
        <trans-unit id="9612f816ae3d1d599129006ddc23ec570699e275" translate="yes" xml:space="preserve">
          <source>So if you take for example the shell command</source>
          <target state="translated">例えば、シェルコマンド</target>
        </trans-unit>
        <trans-unit id="557e6fd5bed4c1d07e89cc778dd5ffa04e712afb" translate="yes" xml:space="preserve">
          <source>So if you want to check the validity of the encoding, surround the expression with &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; block as follows;</source>
          <target state="translated">したがって、エンコーディングの有効性を確認する場合は、次のように式を &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; ブロックで囲みます。</target>
        </trans-unit>
        <trans-unit id="a821fbe9858bdf4860678fd5e1e7551e3704e346" translate="yes" xml:space="preserve">
          <source>So if you want to check the validity of the encoding, surround the expression with &lt;code&gt;eval {}&lt;/code&gt; block as follows;</source>
          <target state="translated">したがって、エンコーディングの有効性を確認する場合は、次のように式を &lt;code&gt;eval {}&lt;/code&gt; ブロックで囲みます。</target>
        </trans-unit>
        <trans-unit id="d7e30a7ebf49e6593b8da91cf7504894e9cfa473" translate="yes" xml:space="preserve">
          <source>So if you were to supply a new, complete, top-level source file to add to Perl, you should conform to this peculiar practice by yourself selecting an appropriate quotation from Tolkien, retaining the original spelling and punctuation and using the same format the rest of the quotes are in. Indirect and oblique is just fine; remember, it's a metaphor, so being meta is, after all, what it's for.</source>
          <target state="translated">ですから、もしあなたがPerlに追加するために新しい完全なトップレベルのソースファイルを提供するとしたら、あなたはこの独特の慣習に従うべきです。間接的で斜めの表現でも構いません。これは比喩ですから、メタであることは結局のところ何のためにあるのかということを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="02bb4252af15d73e7777da1a95cce444353d918a" translate="yes" xml:space="preserve">
          <source>So if you're working with Unicode data, consult the documentation of every module you're using if there are any issues with Unicode data exchange. If the documentation does not talk about Unicode at all, suspect the worst and probably look at the source to learn how the module is implemented. Modules written completely in Perl shouldn't cause problems. Modules that directly or indirectly access code written in other programming languages are at risk.</source>
          <target state="translated">ですから、Unicode データを扱う場合は、Unicode データ交換に問題がある場合は、使用しているすべてのモジュールのドキュメントを参照してください。ドキュメントに Unicode についての記述が全くない場合は、最悪の場合を疑って、そのモジュールがどのように実装されているかを知るためにソースを見てください。完全に Perl で書かれたモジュールは問題を起こすべきではありません。他のプログラミング言語で書かれたコードに直接または間接的にアクセスするモジュールは危険です。</target>
        </trans-unit>
        <trans-unit id="e319523cadbb2780f0ef0af26ce5a7a559c73594" translate="yes" xml:space="preserve">
          <source>So in VMS its pm_to_blib.ts.</source>
          <target state="translated">VMS では pm_to_blib.ts です。</target>
        </trans-unit>
        <trans-unit id="3bce9b15392a6c8658669f57b4a2decac3558eb6" translate="yes" xml:space="preserve">
          <source>So instead you'll want to do something like this:</source>
          <target state="translated">だから、代わりにこんなことをしたくなります。</target>
        </trans-unit>
        <trans-unit id="6161c23b3048d528f32556aeffc6deb23d6328c9" translate="yes" xml:space="preserve">
          <source>So it is round-trip safe for \xF9\xF9. But if the line above is upside down, here is what happens.</source>
          <target state="translated">往復で安全なんですね。でも 上の線を逆さまにすると こうなる。</target>
        </trans-unit>
        <trans-unit id="c06ae4675003e825258b16549181d9f72cc7560a" translate="yes" xml:space="preserve">
          <source>So it's clearer and best to use the compound form when specifying blocks. And be sure that is what you really really want to do. In most cases scripts are what you want instead.</source>
          <target state="translated">なので、ブロックを指定するときは複合形を使ったほうがわかりやすくてベストです。そして、それが本当にやりたいことであることを確認してください。ほとんどの場合、代わりにスクリプトを使用します。</target>
        </trans-unit>
        <trans-unit id="3007e0313fdaf4be553a40db748fe3ab3979d2d6" translate="yes" xml:space="preserve">
          <source>So just remember always to use the array or hash constructors with &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;{}&lt;/code&gt; , and you'll be fine, although it's not always optimally efficient.</source>
          <target state="translated">したがって、常に配列またはハッシュコンストラクターを &lt;code&gt;[]&lt;/code&gt; または &lt;code&gt;{}&lt;/code&gt; で使用することを忘れないでください。これは、常に最適であるとは限りませんが、問題ありません。</target>
        </trans-unit>
        <trans-unit id="d027afb082f340c36adda48951c99192de3bf3d9" translate="yes" xml:space="preserve">
          <source>So just remember always to use the array or hash constructors with &lt;code&gt;[]&lt;/code&gt; or &lt;code&gt;{}&lt;/code&gt;, and you'll be fine, although it's not always optimally efficient.</source>
          <target state="translated">したがって、 &lt;code&gt;[]&lt;/code&gt; または &lt;code&gt;{}&lt;/code&gt; で配列またはハッシュコンストラクターを使用することを常に忘れないでください。常に最適に効率的であるとは限りませんが、問題はありません。</target>
        </trans-unit>
        <trans-unit id="28f6b3059bd71a14d4d6430ebaa792ae77f9b5ae" translate="yes" xml:space="preserve">
          <source>So much for textual data. Let's get onto the meaty stuff that &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; are best at: handling binary formats for numbers. There is, of course, not just one binary format - life would be too simple - but Perl will do all the finicky labor for you.</source>
          <target state="translated">テキストデータについてはこれで終わりです。 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; が最も得意とする重要なこと、数値のバイナリ形式の処理に取り掛かりましょう。もちろん、バイナリ形式は1つだけではありません-人生は単純すぎるでしょう-しかし、Perlはあなたのために細心の注意を払うすべての作業を行います。</target>
        </trans-unit>
        <trans-unit id="c03e630c08b97b3f5b437a4e7c4b378ae3776973" translate="yes" xml:space="preserve">
          <source>So much for textual data. Let's get onto the meaty stuff that &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; are best at: handling binary formats for numbers. There is, of course, not just one binary format - life would be too simple - but Perl will do all the finicky labor for you.</source>
          <target state="translated">テキストデータについてはこれだけです。 &lt;code&gt;pack&lt;/code&gt; と &lt;code&gt;unpack&lt;/code&gt; が得意とする、数字のバイナリ形式の処理に取り掛かりましょう。もちろん、バイナリ形式は1つだけではなく、人生は単純すぎるでしょうが、Perlがすべての厄介な作業を行います。</target>
        </trans-unit>
        <trans-unit id="6434510a7a13803f70088fd4384a0dc891e9b671" translate="yes" xml:space="preserve">
          <source>So neither &lt;code&gt;latin1&lt;/code&gt; nor &lt;code&gt;ascii&lt;/code&gt; are incompatible with the &lt;code&gt;utf8&lt;/code&gt; flag - they only govern when the JSON output engine escapes a character or not.</source>
          <target state="translated">したがって、 &lt;code&gt;latin1&lt;/code&gt; も &lt;code&gt;ascii&lt;/code&gt; も &lt;code&gt;utf8&lt;/code&gt; フラグと互換性がありません。これらは、JSON出力エンジンが文字をエスケープするかどうかのみを制御します。</target>
        </trans-unit>
        <trans-unit id="3f6d818d0bc8716d4413f806e54c839d9543bd1d" translate="yes" xml:space="preserve">
          <source>So now &lt;code&gt;tie $scalar&lt;/code&gt; will always tie the scalar, not the handle it holds. To tie the handle, use &lt;code&gt;tie *$scalar&lt;/code&gt; (with an explicit asterisk). The same applies to &lt;code&gt;tied *$scalar&lt;/code&gt; and &lt;code&gt;untie *$scalar&lt;/code&gt;.</source>
          <target state="translated">したがって、 &lt;code&gt;tie $scalar&lt;/code&gt; は常にスカラーを結びます。それが保持するハンドルではありません。ハンドルを結ぶには、 &lt;code&gt;tie *$scalar&lt;/code&gt; 使用します（明示的なアスタリスク付き）。同じことが、 &lt;code&gt;tied *$scalar&lt;/code&gt; と &lt;code&gt;untie *$scalar&lt;/code&gt; れた* $ scalarにも当てはまります。</target>
        </trans-unit>
        <trans-unit id="19e5670a7ba385b708ff4bcfadcd36a0825afece" translate="yes" xml:space="preserve">
          <source>So now this code would be written:</source>
          <target state="translated">そこで今、このコードを書くことになります。</target>
        </trans-unit>
        <trans-unit id="7ec657e348cc94be548b290696e0a818e7f982d5" translate="yes" xml:space="preserve">
          <source>So now you have a file ending in .tar.gz (or, less often, .zip). You know there's a tasty module inside. There are four steps you must now take:</source>
          <target state="translated">これで、.tar.gz で終わるファイルができました。この中に美味しいモジュールが入っていることがわかります。ここで、4つのステップを実行しなければなりません。</target>
        </trans-unit>
        <trans-unit id="9f7f09ef2fcd4d20ffdab1795e6c221c8b2cdf50" translate="yes" xml:space="preserve">
          <source>So please select carefully what library you want to use.</source>
          <target state="translated">そのため、どの図書館を利用するかは慎重に選んでください。</target>
        </trans-unit>
        <trans-unit id="fc4d504736579a86ac1ba1abd47d391cec08a768" translate="yes" xml:space="preserve">
          <source>So put in parentheses to say what you really mean.</source>
          <target state="translated">だから本音を言うためにカッコの中に入れてください。</target>
        </trans-unit>
        <trans-unit id="291a379872204cd90f4de2f2a608af9f0d7dabed" translate="yes" xml:space="preserve">
          <source>So specifically, autoloaded functions cannot see package lexicals (this applies to both the &lt;b&gt;SelfLoader&lt;/b&gt; and the Autoloader). The &lt;code&gt;vars&lt;/code&gt; pragma provides an alternative to defining package-level globals that will be visible to autoloaded routines. See the documentation on &lt;b&gt;vars&lt;/b&gt; in the pragma section of &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;.</source>
          <target state="translated">したがって、具体的には、オートロードされた関数はパッケージレキシカルを認識できません（これは&lt;b&gt;SelfLoader&lt;/b&gt;とAutoloaderの両方に適用されます）。 &lt;code&gt;vars&lt;/code&gt; のプラグマはオートロードルーチンに見えるであろうパッケージレベルのグローバルを定義する代替手段を提供します。&lt;a href=&quot;perlmod&quot;&gt;perlmodの&lt;/a&gt;プラグマセクションの&lt;b&gt;vars&lt;/b&gt;に関するドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="178e0296c43b2c22ca3149a0d363aa4b6a82de7c" translate="yes" xml:space="preserve">
          <source>So that's how we consume and produce fixed-width data. Let's recap what we've seen of &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; so far:</source>
          <target state="translated">これが、固定幅のデータを消費および生成する方法です。これまでに &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; について見てきたことを要約してみましょう。</target>
        </trans-unit>
        <trans-unit id="ae19d4915e0b62760549bd4eeb2c1e92ef2ac7db" translate="yes" xml:space="preserve">
          <source>So that's how we consume and produce fixed-width data. Let's recap what we've seen of &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; so far:</source>
          <target state="translated">これが、固定幅のデータを消費および生成する方法です。これまでに見た &lt;code&gt;pack&lt;/code&gt; と &lt;code&gt;unpack&lt;/code&gt; 内容を要約してみましょう。</target>
        </trans-unit>
        <trans-unit id="da5a5de8356ec781cae3674738f4fa4085230f11" translate="yes" xml:space="preserve">
          <source>So the Perl interface would look like this</source>
          <target state="translated">そのため、Perl のインターフェイスは次のようになります。</target>
        </trans-unit>
        <trans-unit id="eb361df349469f52fd13dc7f637fd6d3f4002c01" translate="yes" xml:space="preserve">
          <source>So the Perl subroutine would look like this:</source>
          <target state="translated">そのため、Perlのサブルーチンは次のようになります。</target>
        </trans-unit>
        <trans-unit id="f9e5e29abec6c42a24502ee051f01eb881622a3a" translate="yes" xml:space="preserve">
          <source>So the exit codes are...</source>
          <target state="translated">出口コードは...</target>
        </trans-unit>
        <trans-unit id="ecdcbf5b6eec0983bdba576e908b1b991d7bdaa0" translate="yes" xml:space="preserve">
          <source>So the methods &lt;code&gt;PrintID&lt;/code&gt; and &lt;code&gt;Display&lt;/code&gt; can be invoked like this:</source>
          <target state="translated">したがって、メソッド &lt;code&gt;PrintID&lt;/code&gt; および &lt;code&gt;Display&lt;/code&gt; は次のように呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="fc02af530f320939749f4c5dd232069afbb23ee8" translate="yes" xml:space="preserve">
          <source>So the return value will be true if the seek operation was successful. For failure, a false value is returned and &lt;code&gt;fileLastError()&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt; are set to the reason for the failure.</source>
          <target state="translated">したがって、シーク操作が成功した場合、戻り値はtrueになります。失敗した場合、false値が返され、 &lt;code&gt;fileLastError()&lt;/code&gt; と &lt;code&gt;$^E&lt;/code&gt; が失敗の理由に設定されます。</target>
        </trans-unit>
        <trans-unit id="bc7fd8e534a0a64d6932df0e7228b52bddc2accd" translate="yes" xml:space="preserve">
          <source>So these now have simple defaults rather than probing at build-time.</source>
          <target state="translated">そのため、ビルド時にプロービングするのではなく、シンプルなデフォルトを持つようになりました。</target>
        </trans-unit>
        <trans-unit id="050bc5740a1b6bb30a161c3c46fabef260c75737" translate="yes" xml:space="preserve">
          <source>So this:</source>
          <target state="translated">だから、これだ。</target>
        </trans-unit>
        <trans-unit id="65f64a88a88a2a42947aa812e415dc968ce4fc3b" translate="yes" xml:space="preserve">
          <source>So to repeat always use SvOK() to check whether an sv is defined.</source>
          <target state="translated">繰り返しになりますが、sv が定義されているかどうかをチェックするには常に SvOK()を使用します。</target>
        </trans-unit>
        <trans-unit id="ec007077340f2b45239679ca4cc61f38315a3433" translate="yes" xml:space="preserve">
          <source>So what happened to dTHR?</source>
          <target state="translated">で、dTHRはどうなったの?</target>
        </trans-unit>
        <trans-unit id="dd71b3066f2c37ca89d49c13416a448baf2ad1f1" translate="yes" xml:space="preserve">
          <source>So what has this got to do with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;? Well, if you want to compose a Unicode string (that is internally encoded as UTF-8), you can do so by using template code &lt;code&gt;U&lt;/code&gt; . As an example, let's produce the Euro currency symbol (code number 0x20AC):</source>
          <target state="translated">それで、これは &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; どう関係しているのですか？まあ、Unicode文字列（内部的にはUTF-8でエンコードされている）を作成したい場合は、テンプレートコード &lt;code&gt;U&lt;/code&gt; を使用して作成できます。例として、ユーロ通貨記号（コード番号0x20AC）を作成してみましょう。</target>
        </trans-unit>
        <trans-unit id="be8214c7c17783a92e4d370b91d6755f26454042" translate="yes" xml:space="preserve">
          <source>So what has this got to do with &lt;code&gt;pack&lt;/code&gt;? Well, if you want to compose a Unicode string (that is internally encoded as UTF-8), you can do so by using template code &lt;code&gt;U&lt;/code&gt;. As an example, let's produce the Euro currency symbol (code number 0x20AC):</source>
          <target state="translated">では、これは &lt;code&gt;pack&lt;/code&gt; 何の関係があるのでしょうか？Unicode文字列（内部でUTF-8としてエンコードされている）を作成する場合は、テンプレートコード &lt;code&gt;U&lt;/code&gt; を使用して作成できます。例として、ユーロ通貨記号（コード番号0x20AC）を作成してみましょう。</target>
        </trans-unit>
        <trans-unit id="76db05e5ac37110bc4537d598a8e57f24d0e7d58" translate="yes" xml:space="preserve">
          <source>So what is the big problem? Well, if you are expecting Perl to tidy up those temporaries for you, you might be in for a long wait. For Perl to dispose of your temporaries, control must drop back to the enclosing scope at some stage. In the event driven scenario that may never happen. This means that, as time goes on, your program will create more and more temporaries, none of which will ever be freed. As each of these temporaries consumes some memory your program will eventually consume all the available memory in your system--kapow!</source>
          <target state="translated">では、何が大きな問題なのでしょうか?もし Perl がテンポラリを片付けてくれることを期待しているのであれば、長い間待たされることになるかもしれません。Perl がテンポラリを処分するためには、ある段階で制御がスコープを囲んでいるところに戻らなければなりません。イベント駆動型のシナリオでは、それは決して起こらないかもしれません。つまり、時間が経つにつれて、プログラムはどんどんテンポラリを作成していきますが、そのどれもが解放されることはありません。これらのテンポラリのそれぞれがメモリを消費するため、あなたのプログラムは最終的にシステム内の利用可能なメモリをすべて消費することになります。</target>
        </trans-unit>
        <trans-unit id="49dd0c06fd8f279176f457e7dd90bd0af2090341" translate="yes" xml:space="preserve">
          <source>So what's new?</source>
          <target state="translated">で、何が新しいの?</target>
        </trans-unit>
        <trans-unit id="8be287051544a93972a5fe33ce5f2eed6334bad0" translate="yes" xml:space="preserve">
          <source>So when the output is a filehandle it will carry out a seek to the eof before writing any compressed data. If the output is a filename, it will be opened for appending. If the output is a buffer, all compressed data will be appended to the existing buffer.</source>
          <target state="translated">そのため、出力がファイルハンドルの場合は、圧縮データを書き込む前に eof へのシークを行います。出力がファイル名の場合は、追加のためにオープンされます。出力がバッファの場合、すべての圧縮データは既存のバッファに追加されます。</target>
        </trans-unit>
        <trans-unit id="2b16151fbc25d8d9908507f5cf41dca81006fcb5" translate="yes" xml:space="preserve">
          <source>So when the output is a filehandle it will carry out a seek to the eof before writing any uncompressed data. If the output is a filename, it will be opened for appending. If the output is a buffer, all uncompressed data will be appended to the existing buffer.</source>
          <target state="translated">そのため、出力がファイルハンドルの場合は、非圧縮データを書き込む前に eof へのシークを行います。出力がファイル名の場合は、追加のためにオープンされます。出力がバッファの場合、すべての非圧縮データは既存のバッファに追加されます。</target>
        </trans-unit>
        <trans-unit id="faf320f95dede4954f64d637d17b4ef0ec2ac56b" translate="yes" xml:space="preserve">
          <source>So when we parse &lt;code&gt;/foo/&lt;/code&gt; we see something like the following table. The left shows what is being parsed, and the number indicates where the next regop would go. The stuff on the right is the trace output of the graph. The names are chosen to be short to make it less dense on the screen. 'tsdy' is a special form of &lt;code&gt;regtail()&lt;/code&gt; which does some extra analysis.</source>
          <target state="translated">したがって、 &lt;code&gt;/foo/&lt;/code&gt; を解析すると、次の表のようなものが表示されます。左側は何が解析されているかを示し、数字は次のレゴがどこに行くかを示します。右側のものはグラフのトレース出力です。画面上での密度が低くなるように、名前は短くなるように選択されています。'tsdy'は &lt;code&gt;regtail()&lt;/code&gt; の特別な形式で、追加の分析を行います。</target>
        </trans-unit>
        <trans-unit id="4ca42b2545bb9f74c7dfcf26ad336456861738d0" translate="yes" xml:space="preserve">
          <source>So why is UNINST=1 not the default?</source>
          <target state="translated">ではなぜUNINST=1がデフォルトではないのでしょうか?</target>
        </trans-unit>
        <trans-unit id="5764d39b6b45dd4fdf0407e6dadfbf8730c1c2c3" translate="yes" xml:space="preserve">
          <source>So why use these? They produce better diagnostics on failure. &lt;code&gt;ok()&lt;/code&gt; cannot know what you are testing for (beyond the name), but &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; know what the test was and why it failed. For example this test:</source>
          <target state="translated">なぜこれらを使用するのですか？障害の診断が改善されます。 &lt;code&gt;ok()&lt;/code&gt; は何をテストしているのか（名前を超えて &lt;code&gt;isnt()&lt;/code&gt; 知ることはできませんが、 &lt;code&gt;is()&lt;/code&gt; とisnt（）はテストが何で、なぜ失敗したのかを知っています。たとえば、このテスト：</target>
        </trans-unit>
        <trans-unit id="0723871c8efb4af11337b70788bc11e5f341de34" translate="yes" xml:space="preserve">
          <source>So why would you ever want to use a Unix domain socket instead of a simpler named pipe? Because a named pipe doesn't give you sessions. You can't tell one process's data from another's. With socket programming, you get a separate session for each client; that's why accept() takes two arguments.</source>
          <target state="translated">では、なぜシンプルな名前付きパイプではなく、Unixドメインソケットを使いたいのでしょうか?名前付きパイプではセッションが得られないからです。あるプロセスのデータと別のプロセスのデータを区別することができません。ソケットプログラミングでは、クライアントごとに別々のセッションを取得します。</target>
        </trans-unit>
        <trans-unit id="907dfd8f705f1e1d725ffd018f44b3318d9e84e1" translate="yes" xml:space="preserve">
          <source>So you can figure out what went wrong without rerunning the test.</source>
          <target state="translated">だから、テストを再実行しなくても、何が間違っていたのかがわかるのです。</target>
        </trans-unit>
        <trans-unit id="23330e80d1d5c0a1be567b0263265e46b7f62019" translate="yes" xml:space="preserve">
          <source>So you rewrite it to read:</source>
          <target state="translated">読むように書き換えるんですね。</target>
        </trans-unit>
        <trans-unit id="85a109f19c85f2e155b7bae45252c43e85217d92" translate="yes" xml:space="preserve">
          <source>So you should instead try this;</source>
          <target state="translated">だから、代わりにこれを試してみてください。</target>
        </trans-unit>
        <trans-unit id="99368e21d7e985fc9382de7cbad3270d6b572550" translate="yes" xml:space="preserve">
          <source>So you want to know what &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; actually does?</source>
          <target state="translated">それで、実際にどのような &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; が行われるのか知りたいですか？</target>
        </trans-unit>
        <trans-unit id="f880312d8311a1d75dbe80304cdf01f9913e6eb1" translate="yes" xml:space="preserve">
          <source>So you want to know what &lt;code&gt;import&lt;/code&gt; actually does?</source>
          <target state="translated">では、 &lt;code&gt;import&lt;/code&gt; 実際に何をするのか知りたいですか？</target>
        </trans-unit>
        <trans-unit id="d98457d69f47757522cf080b8cba6d90757ec58b" translate="yes" xml:space="preserve">
          <source>So, beside calls like</source>
          <target state="translated">のようなコールの横には</target>
        </trans-unit>
        <trans-unit id="8b676466aa2043751e164c60e8f768fad4f2409b" translate="yes" xml:space="preserve">
          <source>So, for classes and subclasses to have inheritance correctly work with autoloading, you need to ensure stubs are loaded.</source>
          <target state="translated">そのため、クラスやサブクラスがオートロードで正しく動作するように継承するためには、スタブがロードされていることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="3fdc850c88acfeea0034b4d0a5ecf1cbe8955116" translate="yes" xml:space="preserve">
          <source>So, for example, &quot;wb9&quot; means open for writing with the maximum compression using the default strategy and &quot;wb4R&quot; means open for writing with compression level 4 and run-length encoding.</source>
          <target state="translated">そのため、例えば &quot;wb9 &quot;はデフォルトのストラテジーを使用した最大圧縮での書き込みのためのオープンを意味し、&quot;wb4R &quot;は圧縮レベル4とランレングスエンコーディングでの書き込みのためのオープンを意味します。</target>
        </trans-unit>
        <trans-unit id="ef8d2c630e8e6fd22bf1a2656520cdc24a0e732f" translate="yes" xml:space="preserve">
          <source>So, for example, say you have a file compressed with gzip that you want to recompress with bzip2. Here is all that is needed to carry out the recompression.</source>
          <target state="translated">例えば、gzip で圧縮されたファイルを bzip2 で再圧縮したいとします。再圧縮を実行するために必要なものは以下の通りである。</target>
        </trans-unit>
        <trans-unit id="98d3c65256a4087c70ab29c5923eefef7208b53e" translate="yes" xml:space="preserve">
          <source>So, for instance, to pack 20302 to a signed 16 bit integer in your computer's representation you write</source>
          <target state="translated">ですから、例えば、20302を符号付き16ビット整数にパックするには、次のように書きます。</target>
        </trans-unit>
        <trans-unit id="5a026df42e6a15ca497ded704c00f477c0e8e518" translate="yes" xml:space="preserve">
          <source>So, if you see two terms with an &lt;code&gt;=&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt; , between them, you can turn them into a single expression. When you do this, you execute the code in the block on the next line: if you see &lt;code&gt;=&lt;/code&gt; , you'll do the code in line 2. If you see &lt;code&gt;+&lt;/code&gt; , you'll do the code in line 4. It's this code which contributes to the op tree.</source>
          <target state="translated">したがって、2つの用語の間に &lt;code&gt;=&lt;/code&gt; または &lt;code&gt;+&lt;/code&gt; がある場合は、それらを1つの式に変換できます。これを行うと、次の行のブロックでコードを実行します。 &lt;code&gt;=&lt;/code&gt; が表示されている場合は、2行目でコードを実行します。 &lt;code&gt;+&lt;/code&gt; が表示されている場合は、4行目でコードを実行します。これがこのコードですこれはopツリーに貢献します。</target>
        </trans-unit>
        <trans-unit id="0379bb60c338fa89d5d14562ac618c3cb90f2526" translate="yes" xml:space="preserve">
          <source>So, if you see two terms with an &lt;code&gt;=&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;, between them, you can turn them into a single expression. When you do this, you execute the code in the block on the next line: if you see &lt;code&gt;=&lt;/code&gt;, you'll do the code in line 2. If you see &lt;code&gt;+&lt;/code&gt;, you'll do the code in line 4. It's this code which contributes to the op tree.</source>
          <target state="translated">したがって、 &lt;code&gt;=&lt;/code&gt; または &lt;code&gt;+&lt;/code&gt; の間にある2つの用語が表示された場合、それらを1つの式に変換できます。これを行うときは、次の行のブロックでコードを実行します。 &lt;code&gt;=&lt;/code&gt; が表示されている場合は、2行目でコードを実行します。 &lt;code&gt;+&lt;/code&gt; が表示されている場合は、4行目でコードを実行します。これがこのコードです。これはopツリーに貢献します。</target>
        </trans-unit>
        <trans-unit id="f012b7bad59a01daf6da8ed100b9c040ae573c55" translate="yes" xml:space="preserve">
          <source>So, if you want to collect memory info in a cycle, you may call</source>
          <target state="translated">そのため、サイクルごとにメモリ情報を収集したい場合は</target>
        </trans-unit>
        <trans-unit id="f33ef09895b9595e58c40994534996d41b9b84f6" translate="yes" xml:space="preserve">
          <source>So, in general, &quot;state&quot; subroutines are faster. But &quot;my&quot; subs are necessary if you want to create closures:</source>
          <target state="translated">ですから、一般的には &quot;状態 &quot;サブルーチンの方が速いのです。しかし、「私の」サブは、クロージャを作成したい場合には必要です。</target>
        </trans-unit>
        <trans-unit id="b92446e0fc5150a550f9b239a78e7589775be2a5" translate="yes" xml:space="preserve">
          <source>So, let's say you want to add a custom element called 'foo'. In your subclass's &lt;code&gt;new&lt;/code&gt; method, after calling &lt;code&gt;SUPER::new&lt;/code&gt; you'd call:</source>
          <target state="translated">したがって、「foo」というカスタム要素を追加するとします。サブクラスの &lt;code&gt;new&lt;/code&gt; メソッドで、 &lt;code&gt;SUPER::new&lt;/code&gt; を呼び出した後、次のように呼び出します。</target>
        </trans-unit>
        <trans-unit id="6f5a18b784416c2faf1e8dee13b0302a69a860cf" translate="yes" xml:space="preserve">
          <source>So, on the advice of the gettext manual, you rewrite:</source>
          <target state="translated">そこで、gettextマニュアルのアドバイスを受けて、あなたは書き換えます。</target>
        </trans-unit>
        <trans-unit id="04546d861006181e7076b52be007eeaf163f592b" translate="yes" xml:space="preserve">
          <source>So, rather than having to say:</source>
          <target state="translated">だから、言わなくてもいいというよりは</target>
        </trans-unit>
        <trans-unit id="ce7cf438ffd137d4b9ae434030e4dd1bac347bb0" translate="yes" xml:space="preserve">
          <source>So, saying &lt;code&gt;11 &amp;amp; 3&lt;/code&gt; performs the &quot;and&quot; operation on numbers (yielding &lt;code&gt;3&lt;/code&gt; ). Saying &lt;code&gt;&quot;11&quot; &amp;amp; &quot;3&quot;&lt;/code&gt; performs the &quot;and&quot; operation on strings (yielding &lt;code&gt;&quot;1&quot;&lt;/code&gt; ).</source>
          <target state="translated">したがって、 &lt;code&gt;11 &amp;amp; 3&lt;/code&gt; と言うと、数値に対して「and」演算が実行されます（yielding &lt;code&gt;3&lt;/code&gt; ）。 &lt;code&gt;&quot;11&quot; &amp;amp; &quot;3&quot;&lt;/code&gt; と言うと、文字列に対して &quot;and&quot;演算が実行されます（ &lt;code&gt;&quot;1&quot;&lt;/code&gt; を生成）</target>
        </trans-unit>
        <trans-unit id="82342d83c583203ac699858cccf76690e3807bf1" translate="yes" xml:space="preserve">
          <source>So, saying &lt;code&gt;11 &amp;amp; 3&lt;/code&gt; performs the &quot;and&quot; operation on numbers (yielding &lt;code&gt;3&lt;/code&gt;). Saying &lt;code&gt;&quot;11&quot; &amp;amp; &quot;3&quot;&lt;/code&gt; performs the &quot;and&quot; operation on strings (yielding &lt;code&gt;&quot;1&quot;&lt;/code&gt;).</source>
          <target state="translated">したがって、 &lt;code&gt;11 &amp;amp; 3&lt;/code&gt; と言うと、数値に対して「and」演算が実行されます（ &lt;code&gt;3&lt;/code&gt; が得られます）。 &lt;code&gt;&quot;11&quot; &amp;amp; &quot;3&quot;&lt;/code&gt; と言うと、文字列に対して「and」操作が実行されます（ &lt;code&gt;&quot;1&quot;&lt;/code&gt; 生成されます）。</target>
        </trans-unit>
        <trans-unit id="4a687b4464c81c65ad71b0b242c9a17889c06be5" translate="yes" xml:space="preserve">
          <source>So, sometimes you might want to use symbolic references to manipulate the symbol table directly. This doesn't matter for formats, handles, and subroutines, because they are always global--you can't use my() on them. For scalars, arrays, and hashes, though--and usually for subroutines-- you probably only want to use hard references.</source>
          <target state="translated">そのため、シンボリック参照を使ってシンボルテーブルを直接操作したくなることもあるでしょう。フォーマットやハンドル、サブルーチンは常にグローバルなので、これは問題ではありません。しかし、スカラ、配列、ハッシュ、そして通常のサブルーチンでは、おそらくハードリファレンスだけを使いたいと思うでしょう。</target>
        </trans-unit>
        <trans-unit id="988f750cf0c3c51b512a9cb6f00133978c0404e1" translate="yes" xml:space="preserve">
          <source>So, the following examples now works as expected:</source>
          <target state="translated">そこで、以下の例は期待通りに動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="8b62c1a83484ac0f80542a2de9bd04874ec15952" translate="yes" xml:space="preserve">
          <source>So, the following examples will now work all as expected:</source>
          <target state="translated">これで、以下の例はすべて期待通りに動作するようになりました。</target>
        </trans-unit>
        <trans-unit id="b83b5043b490e39d23dba00f7ce754a2ed020ba9" translate="yes" xml:space="preserve">
          <source>So, the following line:</source>
          <target state="translated">ということで、次の行。</target>
        </trans-unit>
        <trans-unit id="e43264c4b337b0feb1da1b34ab4669d9bfde22ae" translate="yes" xml:space="preserve">
          <source>So, the following two statements do the same thing:</source>
          <target state="translated">つまり、次の2つの発言は同じことをしているということです。</target>
        </trans-unit>
        <trans-unit id="0f5b24deb12867f441d62aa11cf38e02b6693a70" translate="yes" xml:space="preserve">
          <source>So, the string of Martian &quot;I am CVSGXX!&quot; uses 12 bytes to encode the nine characters 'I', ' ', 'a', 'm', ' ', 'CV', 'SG', 'XX', '!'.</source>
          <target state="translated">そこで、火星人の「私はCVSGXXです!」という文字列は、12バイトを使って、「I」「'」「'」「a」「m」「'」「CV」「SG」「XX」「!」の9文字をエンコードしています。</target>
        </trans-unit>
        <trans-unit id="93058ef0377751cf8a22fa887d9f94acca14dc08" translate="yes" xml:space="preserve">
          <source>So, this:</source>
          <target state="translated">だから、これ。</target>
        </trans-unit>
        <trans-unit id="23a65604ac4ef3bcdf6fdcf41ebba719fc161bed" translate="yes" xml:space="preserve">
          <source>So, what needs to replace gettext is a system that supports lexicons of functions instead of lexicons of strings. An entry in a lexicon from such a system should</source>
          <target state="translated">ですから、gettext の代わりに必要なのは、文字列のレキシコンではなく関数のレキシコンをサポートするシステムです。そのようなシステムからのレキシコンのエントリは、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="666f233dad00e2e027af2bcddbc736103b174459" translate="yes" xml:space="preserve">
          <source>So, what's the big problem with that? It looks right, doesn't it? After all, I just told you that you need an array of references, so by golly, you've made me one!</source>
          <target state="translated">で、何が問題なの?それは正しいように見えますよね?結局のところ、参考文献の配列が必要だと言っただけなので、なんと、私を1つにしてくれたんですね!</target>
        </trans-unit>
        <trans-unit id="c5f7a9040d43fdd63e7b31365a3279f444817139" translate="yes" xml:space="preserve">
          <source>So, you email your various translators (the boss decides that the languages du jour are Chinese, Arabic, Russian, and Italian, so you have one translator for each), asking for translations for &quot;I scanned %g directory.&quot; and &quot;I scanned %g directories.&quot;. When they reply, you'll put that in the lexicons for gettext to use when it localizes your software, so that when the user is running under the &quot;zh&quot; (Chinese) locale, gettext(&quot;I scanned %g directory.&quot;) will return the appropriate Chinese text, with a &quot;%g&quot; in there where printf can then interpolate $dir_scan.</source>
          <target state="translated">そこで、様々な翻訳者にメールを送り(ボスは、時事言語は中国語、アラビア語、ロシア語、イタリア語だと決めているので、それぞれに翻訳者を一人ずつ用意しています)、&quot;I scanned %g directory.&quot; と &quot;I scanned %g directories.&quot; の翻訳を求めます。これにより、ユーザが &quot;zh&quot; (中国語)ロケールで実行しているときに gettext(&quot;I scanned %g directory.&quot;)は適切な中国語のテキストを返し、その中に &quot;%g&quot; を入れて printf が $dir_scan を補間できるようにします。</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="93c6a1f183694628e37ced41591147bfc0da1908" translate="yes" xml:space="preserve">
          <source>Socket</source>
          <target state="translated">Socket</target>
        </trans-unit>
        <trans-unit id="1a669dbe9f824af2034872bc98a2b6823a4c09af" translate="yes" xml:space="preserve">
          <source>Socket option level constant for setsockopt() and getsockopt().</source>
          <target state="translated">setsockopt()および getsockopt()のソケットオプションレベル定数。</target>
        </trans-unit>
        <trans-unit id="e89a311c363b4ef4dc4be93eaeb6560498486275" translate="yes" xml:space="preserve">
          <source>Socket option name constants for IPv4 socket options at the &lt;code&gt;IPPROTO_IP&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;IPPROTO_IP&lt;/code&gt; レベルのIPv4ソケットオプションのソケットオプション名定数。</target>
        </trans-unit>
        <trans-unit id="d741b5bebfd867658e744ca3a901afeae953cecf" translate="yes" xml:space="preserve">
          <source>Socket option name constants for IPv6 socket options at the &lt;code&gt;IPPROTO_IPV6&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;IPPROTO_IPV6&lt;/code&gt; レベルのIPv6ソケットオプションのソケットオプション名定数。</target>
        </trans-unit>
        <trans-unit id="1bea3c52b1b205afb6610aaf669b9a46fdff261d" translate="yes" xml:space="preserve">
          <source>Socket option name constants for TCP socket options at the &lt;code&gt;IPPROTO_TCP&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;IPPROTO_TCP&lt;/code&gt; レベルのTCPソケットオプションのソケットオプション名定数。</target>
        </trans-unit>
        <trans-unit id="8943cecdeb64eeb6c75caac188d81a6e580de3c7" translate="yes" xml:space="preserve">
          <source>Socket option name constants for setsockopt() and getsockopt() at the &lt;code&gt;SOL_SOCKET&lt;/code&gt; level.</source>
          <target state="translated">&lt;code&gt;SOL_SOCKET&lt;/code&gt; レベルのsetsockopt（）およびgetsockopt（）のソケットオプション名定数。</target>
        </trans-unit>
        <trans-unit id="8a16f3d4e350888989be5c310a53b83649d06948" translate="yes" xml:space="preserve">
          <source>Socket option value constants for &lt;code&gt;IP_TOS&lt;/code&gt; socket option.</source>
          <target state="translated">&lt;code&gt;IP_TOS&lt;/code&gt; ソケットオプションのソケットオプション値定数。</target>
        </trans-unit>
        <trans-unit id="fa50a464d89f205a80a64569fe1c6e97815468d2" translate="yes" xml:space="preserve">
          <source>Socket option value contants for &lt;code&gt;IP_MTU_DISCOVER&lt;/code&gt; socket option.</source>
          <target state="translated">&lt;code&gt;IP_MTU_DISCOVER&lt;/code&gt; ソケットオプションのソケットオプション値定数。</target>
        </trans-unit>
        <trans-unit id="734337896e45cc2ebeff48479a66b46bdd05ddb4" translate="yes" xml:space="preserve">
          <source>Socket type constants to use as the second argument to socket(), or the value of the &lt;code&gt;SO_TYPE&lt;/code&gt; socket option.</source>
          <target state="translated">socket（）の2番目の引数として使用するソケットタイプ定数、または &lt;code&gt;SO_TYPE&lt;/code&gt; ソケットオプションの値。</target>
        </trans-unit>
        <trans-unit id="5bedda872ecdb70c2a2d140ada477f5b294eb6f0" translate="yes" xml:space="preserve">
          <source>Socket.</source>
          <target state="translated">Socket.</target>
        </trans-unit>
        <trans-unit id="ebe92a08483968e414740930bf0a0a08483ad931" translate="yes" xml:space="preserve">
          <source>Socket.a</source>
          <target state="translated">Socket.a</target>
        </trans-unit>
        <trans-unit id="848572346180cfeef643ccd7fddcc1762d26f13a" translate="yes" xml:space="preserve">
          <source>Sockets: Client/Server Communication</source>
          <target state="translated">ソケット。クライアント/サーバー通信</target>
        </trans-unit>
        <trans-unit id="7ec10a4e74fb45054402ed905e46c34443ecf08d" translate="yes" xml:space="preserve">
          <source>Sockopts =&amp;gt; ARRAY</source>
          <target state="translated">Sockopts =&amp;gt; ARRAY</target>
        </trans-unit>
        <trans-unit id="96898c7bdde72d33b35d72cb9458ecfe538b1436" translate="yes" xml:space="preserve">
          <source>Software distributions released to the CPAN include a</source>
          <target state="translated">CPANにリリースされたソフトウェア・ディストリビューションには、以下のものが含まれます。</target>
        </trans-unit>
        <trans-unit id="ad9951caf8addf9e39a4e5a9ec448dfc26c21d1a" translate="yes" xml:space="preserve">
          <source>Solaris (x86, SPARC)</source>
          <target state="translated">ソラリス</target>
        </trans-unit>
        <trans-unit id="bbfadcc007c702d16ecd0e6f6d3baeefff3d72aa" translate="yes" xml:space="preserve">
          <source>Solaris 10 documentation on syslog, &lt;a href=&quot;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&quot;&gt;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&lt;/a&gt;</source>
          <target state="translated">syslogに関するSolaris 10のドキュメント、&lt;a href=&quot;http://docs.sun.com/app/docs/doc/816-5168/syslog-3c?a=view&quot;&gt;http：//docs.sun.com/app/docs/doc/816-5168/syslog-3c？a = view&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c7dc4f9a32286dc36b6fd2393ea8eff49fa670d" translate="yes" xml:space="preserve">
          <source>Solaris 11 documentation on syslog, &lt;a href=&quot;https://docs.oracle.com/cd/E53394_01/html/E54766/syslog-3c.html&quot;&gt;https://docs.oracle.com/cd/E53394_01/html/E54766/syslog-3c.html&lt;/a&gt;</source>
          <target state="translated">Syslogに関するSolaris11のドキュメント、&lt;a href=&quot;https://docs.oracle.com/cd/E53394_01/html/E54766/syslog-3c.html&quot;&gt;https：//docs.oracle.com/cd/E53394_01/html/E54766/syslog-3c.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98fa552d1b28be69cf1da96419b8a90307162871" translate="yes" xml:space="preserve">
          <source>Solaris 7 and above will run in either 32 bit or 64 bit mode on SPARC CPUs, via a reboot. You can build 64 bit apps whilst running 32 bit mode and vice-versa. 32 bit apps will run under Solaris running in either 32 or 64 bit mode. 64 bit apps require Solaris to be running 64 bit mode.</source>
          <target state="translated">Solaris 7 以降は、SPARC CPU で再起動することで、32 ビットまたは 64 ビットモードで実行されます。32 ビットモードを実行しながら 64 ビットアプリをビルドしたり、その逆もできます。32 ビットアプリは、32 ビットまたは 64 ビットモードで実行されている Solaris で実行されます。64 ビットアプリを実行するには、Solaris が 64 ビットモードで動作している必要があります。</target>
        </trans-unit>
        <trans-unit id="bd381ce5f7739cf9ac8dad77ffda2188f3978def" translate="yes" xml:space="preserve">
          <source>Solaris Documentation</source>
          <target state="translated">Solaris ドキュメント</target>
        </trans-unit>
        <trans-unit id="ed34c43c64cf4558fcdec9f488cfa58f0a1b6fe3" translate="yes" xml:space="preserve">
          <source>Solaris FAQ</source>
          <target state="translated">Solaris FAQ</target>
        </trans-unit>
        <trans-unit id="6ef2766b707c501497b46c746afec2754f6fc860" translate="yes" xml:space="preserve">
          <source>Solaris Version Numbers.</source>
          <target state="translated">Solarisのバージョン番号。</target>
        </trans-unit>
        <trans-unit id="cc61dfb91810e5a0313350199a1b65c0af136cfa" translate="yes" xml:space="preserve">
          <source>Solaris global loading added by Nick Ing-Simmons with design/coding assistance from Tim Bunce, January 1996.</source>
          <target state="translated">Nick Ing-Simmons による Solaris グローバルロードの追加、Tim Bunce による設計/コーディングの支援、1996 年 1 月。</target>
        </trans-unit>
        <trans-unit id="708154fc528413c51483abd6933e68d503e36bdc" translate="yes" xml:space="preserve">
          <source>Solaris may include two versions of perl, e.g. Solaris 9 includes both 5.005_03 and 5.6.1. This is to provide stability across Solaris releases, in cases where a later perl version has incompatibilities with the version included in the preceding Solaris release. The default perl version will always be the most recent, and in general the old version will only be retained for one Solaris release. Note also that the default perl will NOT be configured to search for modules in the older version, again due to compatibility/stability concerns. As a consequence if you upgrade Solaris, you will have to rebuild/reinstall any additional CPAN modules that you installed for the previous Solaris version. See the CPAN manpage under 'autobundle' for a quick way of doing this.</source>
          <target state="translated">Solaris には 2 つのバージョンの perl が含まれている場合があります。例えば、Solaris 9 には 5.005_03 と 5.6.1 の両方が含まれています。これは、後の perl バージョンが前の Solaris リリースに含まれているバージョンと互換性がない場合に、Solaris のリリース間の安定性を提供するためです。デフォルトの perl バージョンは常に最新のものになり、通常、古いバージョンは 1 つの Solaris リリースに対してのみ保持されます。また、互換性や安定性の問題から、デフォルトの perl が古いバージョンのモジュールを検索するように設定されることはありません。そのため、Solaris をアップグレードすると、以前の Solaris バージョンにインストールした追加の CPAN モジュールを再構築/インストールする必要があります。これを簡単に行う方法については、「autobundle」の下の CPAN マニュアルページを参照してください。</target>
        </trans-unit>
        <trans-unit id="4bfa1cd2c976e4c546cb366d1dac1622384583a6" translate="yes" xml:space="preserve">
          <source>Solaris provides some BSD-compatibility functions in /usr/ucblib/libucb.a. Perl will not build and run correctly if linked against -lucb since it contains routines that are incompatible with the standard Solaris libc. Normally this is not a problem since the solaris hints file prevents Configure from even looking in /usr/ucblib for libraries, and also explicitly omits -lucb.</source>
          <target state="translated">Solaris は /usr/ucblib/libucb.a にいくつかの BSD 互換関数を提供しています。Perl は -lucb に対してリンクされた場合、標準の Solaris libc と互換性のないルーチンを含んでいるため、正しくビルドして実行することができません。通常、これは solaris のヒントファイルによって Configure が /usr/ucblib 内のライブラリを探すことすらできないようになっており、また -lucb を明示的に省略しているため、問題にはなりません。</target>
        </trans-unit>
        <trans-unit id="d0c3f51965773ced91efb778a3671a3477592fd4" translate="yes" xml:space="preserve">
          <source>Solaris ships with a range of Solaris-specific modules. If you choose to install your own version of perl you will find the source of many of these modules is available on CPAN under the Sun::Solaris:: namespace.</source>
          <target state="translated">Solaris には、さまざまな Solaris 固有のモジュールが同梱されています。独自のバージョンの perl をインストールする場合は、これらのモジュールの多くのソースが CPAN の Sun::Solaris::namespace にあります。</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="05b004a92e5eda3ec6e47516b582fc25b61b35b9" translate="yes" xml:space="preserve">
          <source>Solutions</source>
          <target state="translated">Solutions</target>
        </trans-unit>
        <trans-unit id="9cdf28d779226e286e9b065703a4425b88267886" translate="yes" xml:space="preserve">
          <source>Solving the problem</source>
          <target state="translated">問題を解決する</target>
        </trans-unit>
        <trans-unit id="00b2aad45d07b70e1b7eefea74316913901b6e42" translate="yes" xml:space="preserve">
          <source>Some</source>
          <target state="translated">Some</target>
        </trans-unit>
        <trans-unit id="5f679f54e4d0cf2197954f773a392f8d165d2696" translate="yes" xml:space="preserve">
          <source>Some (minor) parts copyright 2009 Adam Kennedy.</source>
          <target state="translated">一部(小)の著作権は2009年アダム・ケネディに帰属します。</target>
        </trans-unit>
        <trans-unit id="3a644bfc8b4acacc1b56f8b5a49f0fbd16c47364" translate="yes" xml:space="preserve">
          <source>Some *nix programs use fork() a lot; with the mostly useful flavors of perl for OS/2 (there are several built simultaneously) this is supported; but some flavors do not support this (e.g., when Perl is called from inside REXX). Using fork() after</source>
          <target state="translated">いくつかの *nix プログラムは fork()を多用しています;OS/2 用の perl のほとんどの有用なフレーバー (同時にビルドされたものがいくつかあります)ではこれがサポートされていますが、いくつかのフレーバーはこれをサポートしていません (例えば REXX の内部から Perl が呼び出される場合)。の後に fork()を使うこと</target>
        </trans-unit>
        <trans-unit id="6a808c47f9491da438c1507c81067e0d0ad1d610" translate="yes" xml:space="preserve">
          <source>Some / became \ in pdksh.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ced2108dbb21d847b539e5bf8d6eae4e6952b9e" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;/&lt;/code&gt; became &lt;code&gt;\&lt;/code&gt; in pdksh.</source>
          <target state="translated">一部 &lt;code&gt;/&lt;/code&gt; はpdkshで &lt;code&gt;\&lt;/code&gt; になりました。</target>
        </trans-unit>
        <trans-unit id="aee5f872bb2cc36da4c3ed1ff4e14aea96b6faa3" translate="yes" xml:space="preserve">
          <source>Some &lt;code&gt;Win*&lt;/code&gt; entry points also overload a &quot;meaningful&quot; return value with the error indicator; having a 0 return value indicates an error. Yet some other &lt;code&gt;Win*&lt;/code&gt; entry points overload things even more, and 0 return value may mean a successful call returning a valid value 0, as well as an error condition; in the case of a 0 return value one should call WinGetLastError() API to distinguish a successful call from a failing one.</source>
          <target state="translated">一部の &lt;code&gt;Win*&lt;/code&gt; エントリポイントは、「意味のある」戻り値をエラーインジケータでオーバーロードします。戻り値が0の場合はエラーを示します。しかし、他の一部の &lt;code&gt;Win*&lt;/code&gt; エントリポイントはさらに負荷をかけ、戻り値が0の場合、呼び出しが成功して有効な値0を返し、エラー条件が返される場合があります。戻り値が0の場合、WinGetLastError（）APIを呼び出して、成功した呼び出しと失敗した呼び出しを区別する必要があります。</target>
        </trans-unit>
        <trans-unit id="7d77130c6b6fd9352c737bed1bb1dcb935bd9ca9" translate="yes" xml:space="preserve">
          <source>Some DLLs are only present in some versions of OS/2, or in some configurations of OS/2. Some exported entry points are present only in DLLs shipped with some versions of OS/2. If these DLLs and entry points were linked directly for a Perl executable/DLL or from a Perl extensions, this binary would work only with the specified versions/setups. Even if these entry points were not needed, the</source>
          <target state="translated">いくつかのDLLは、OS/2の一部のバージョン、またはOS/2の一部の構成にのみ存在します。エクスポートされたエントリーポイントの中には、OS/2のいくつかのバージョンに同梱されているDLLにのみ存在するものがあります。これらのDLLとエントリポイントがPerlの実行ファイル/DLLやPerlの拡張機能から直接リンクされている場合、このバイナリは指定されたバージョン/設定でのみ動作します。これらのエントリポイントが必要ない場合でも</target>
        </trans-unit>
        <trans-unit id="8e4ba3d45352907bcc89de2a6a57c8be8f5ee286" translate="yes" xml:space="preserve">
          <source>Some Filters Clobber the &lt;code&gt;DATA&lt;/code&gt; Handle</source>
          <target state="translated">一部のフィルターは &lt;code&gt;DATA&lt;/code&gt; ハンドルを覆い隠します</target>
        </trans-unit>
        <trans-unit id="14adc2a370c74e9f0b7a6eb136961fb44f4e9d5e" translate="yes" xml:space="preserve">
          <source>Some IBM EBCDIC character sets may be known by character code set identification numbers (CCSID numbers) or code page numbers.</source>
          <target state="translated">IBM EBCDIC 文字セットの中には、文字コードセット識別番号(CCSID 番号)やコードページ番号で知られているものもあります。</target>
        </trans-unit>
        <trans-unit id="20970d609d169c267b614af470114dc6b026c453" translate="yes" xml:space="preserve">
          <source>Some Irix cc versions, e.g. 7.3.1.1m (try cc -version) have been known to have issues (coredumps) when compiling perl.c. If you've used -OPT:fast_io=ON and this happens, try removing it. If that fails, or you didn't use that, then try adjusting other optimization options (-LNO, -INLINE, -O3 to -O2, etcetera). The compiler bug has been reported to SGI. (Allen Smith &amp;lt;easmith@beatrice.rutgers.edu&amp;gt;)</source>
          <target state="translated">7.3.1.1m（cc -versionを試す）などの一部のIrix ccバージョンは、perl.cのコンパイル時に問題（コアダンプ）が発生することがわかっています。 -OPT：fast_io = ONを使用していて、これが発生した場合は、削除してみてください。それが失敗した場合、またはそれを使用しなかった場合は、他の最適化オプション（-LNO、-INLINE、-O3から-O2など）を調整してみてください。コンパイラのバグはSGIに報告されています。 （アレン・スミス&amp;lt;easmith@beatrice.rutgers.edu&amp;gt;）</target>
        </trans-unit>
        <trans-unit id="e270800f9e2c9ef58198c6c9f8463f63bac86a3b" translate="yes" xml:space="preserve">
          <source>Some Linux platforms have a maximum stack size. Setting too large of a stack size will cause thread creation to fail.</source>
          <target state="translated">Linux プラットフォームの中には、スタックサイズの最大値が設定されているものがあります。スタックサイズを大きく設定しすぎると、スレッドの作成に失敗します。</target>
        </trans-unit>
        <trans-unit id="bad9f67e1f3cb77c4fe9db59234d0c5d6bb841b2" translate="yes" xml:space="preserve">
          <source>Some OSes do not need these in which case leave it blank.</source>
          <target state="translated">OSによっては必要ないものもありますが、その場合は空欄にしてください。</target>
        </trans-unit>
        <trans-unit id="69e7c8fdafb5d76df4c8f736ecf437657f4dc150" translate="yes" xml:space="preserve">
          <source>Some Pod formatters output to formats that implement non-breaking spaces as an individual character (which I'll call &quot;NBSP&quot;), and others output to formats that implement non-breaking spaces just as spaces wrapped in a &quot;don't break this across lines&quot; code. Note that at the level of Pod, both sorts of codes can occur: Pod can contain a NBSP character (whether as a literal, or as a &quot;E&amp;lt;160&amp;gt;&quot; or &quot;E&amp;lt;nbsp&amp;gt;&quot; code); and Pod can contain &quot;S&amp;lt;foo I&amp;lt;bar&amp;gt; baz&amp;gt;&quot; codes, where &quot;mere spaces&quot; (character 32) in such codes are taken to represent non-breaking spaces. Pod parsers should consider supporting the optional parsing of &quot;S&amp;lt;foo I&amp;lt;bar&amp;gt; baz&amp;gt;&quot; as if it were &quot;foo</source>
          <target state="translated">一部のポッドフォーマッターは、改行しないスペースを個別の文字として実装するフォーマットに出力します（これを「NBSP」と呼びます）。他のポッターは、改行しないスペースを実装するフォーマットに出力します。行を越えて」コード。ポッドのレベルでは、両方の種類のコードが発生する可能性があることに注意してください。ポッドにはNBSP文字を含めることができます（リテラルとして、または「E &amp;lt;160&amp;gt;」または「E &amp;lt;nbsp&amp;gt;」コードとして）。また、ポッドには「S &amp;lt;foo I &amp;lt;bar&amp;gt; baz&amp;gt;」コードを含めることができます。このようなコードの「単なるスペース」（文字32）は、改行しないスペースを表すために使用されます。ポッドパーサーは、「S &amp;lt;foo I &amp;lt;bar&amp;gt; baz&amp;gt;」のオプションの解析を、「foo」であるかのようにサポートすることを検討する必要があります。</target>
        </trans-unit>
        <trans-unit id="f04294d93d5e63f6eed93e1148616595ef1487e2" translate="yes" xml:space="preserve">
          <source>Some Sys-V based systems, notably Solaris 2.X, redefined some of the standard socket constants. Since these were constant across all architectures, they were often hardwired into perl code. The proper way to deal with this is to &quot;use Socket&quot; to get the correct values.</source>
          <target state="translated">いくつかの Sys-V ベースのシステム、特に Solaris 2.X では、いくつかの標準ソケット定数が再定義されています。これらの定数はすべてのアーキテクチャで一定であったため、しばしば perl コードにハードワイヤードされていました。これに対処するための適切な方法は、正しい値を取得するために「ソケットを使う」ことです。</target>
        </trans-unit>
        <trans-unit id="a5a0c5f6bf86975f2c301ba492652230f705bf5a" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; ; and there are only a few dozen possible General Categories.</source>
          <target state="translated">一部のUnicodeプロパティには、有効な値のセットが制限されています。たとえば、すべてのバイナリプロパティは、 &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; に制限されています。そして、数十の可能な一般カテゴリがあります。</target>
        </trans-unit>
        <trans-unit id="9e6eb6762559c642717c0b35b0e9407b4ea3c431" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; ; and there are only a few dozen possible General Categories. Use &lt;code&gt;prop_values&lt;/code&gt; to find out if a given property is one such, and if so, to get a list of the values:</source>
          <target state="translated">一部のUnicodeプロパティには、有効な値のセットが制限されています。たとえば、すべてのバイナリプロパティは、 &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; に制限されています。そして、数十の可能な一般カテゴリがあります。 &lt;code&gt;prop_values&lt;/code&gt; を使用して、特定のプロパティがそのようなプロパティであるかどうかを確認し、そうである場合は、値のリストを取得します。</target>
        </trans-unit>
        <trans-unit id="5c1e962daca68404a4b5aeb9ebaf19ea3e632a80" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;; and there are only a few dozen possible General Categories.</source>
          <target state="translated">一部のUnicodeプロパティには、有効な値の制限されたセットがあります。たとえば、すべてのバイナリプロパティは &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; のみに制限されています。考えられる一般的なカテゴリは数十個だけです。</target>
        </trans-unit>
        <trans-unit id="f826abadcb88c4b8481c939d03177c526f688d85" translate="yes" xml:space="preserve">
          <source>Some Unicode properties have a restricted set of legal values. For example, all binary properties are restricted to just &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;; and there are only a few dozen possible General Categories. Use &lt;code&gt;prop_values&lt;/code&gt; to find out if a given property is one such, and if so, to get a list of the values:</source>
          <target state="translated">一部のUnicodeプロパティには、有効な値の制限されたセットがあります。たとえば、すべてのバイナリプロパティは &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; のみに制限されています。考えられる一般的なカテゴリは数十個だけです。 &lt;code&gt;prop_values&lt;/code&gt; を使用して、特定のプロパティがそのようなものであるかどうかを確認し、そうである場合は、値のリストを取得します。</target>
        </trans-unit>
        <trans-unit id="da934a0c72e4b177f3b0df8a238ca7ff76fadba5" translate="yes" xml:space="preserve">
          <source>Some Unixes, especially more recent ones, are free of this inherent security bug. On such systems, when the kernel passes the name of the set-id script to open to the interpreter, rather than using a pathname subject to meddling, it instead passes</source>
          <target state="translated">いくつかの Unix、特に最近の Unix では、この固有のセキュリティバグがありません。そのようなシステムでは、カーネルが set-id スクリプトの名前をインタープリタに渡すときに、お節介なパス名を使うのではなく、代わりに</target>
        </trans-unit>
        <trans-unit id="b16213d61f5d76543cce7f4b52c976b8f28e064a" translate="yes" xml:space="preserve">
          <source>Some approximate operating system names and their &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; values in the &quot;OTHER&quot; category include:</source>
          <target state="translated">「その他」カテゴリのオペレーティングシステムのおおよその名前とその&lt;a href=&quot;perlvar#%24%5EO&quot;&gt; &lt;code&gt;$^O&lt;/code&gt; &lt;/a&gt;値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="abd2e23e9cee0c22d7103f4f9a78d73d761dd3aa" translate="yes" xml:space="preserve">
          <source>Some approximate operating system names and their &lt;code&gt;$^O&lt;/code&gt; values in the &quot;OTHER&quot; category include:</source>
          <target state="translated">おおよそのオペレーティングシステム名と、「その他」カテゴリの &lt;code&gt;$^O&lt;/code&gt; 値には、次のものがあります。</target>
        </trans-unit>
        <trans-unit id="fc63731ea34f43c4af1c4ec405f7ea69ef1d9704" translate="yes" xml:space="preserve">
          <source>Some authors have strange characters in their names.</source>
          <target state="translated">名前に変な文字が入っている作家もいます。</target>
        </trans-unit>
        <trans-unit id="6877eb2746dbad4bb0e9e27d968022bfea3412f0" translate="yes" xml:space="preserve">
          <source>Some background on thread implementations from the operating system viewpoint. There are three basic categories of threads: user-mode threads, kernel threads, and multiprocessor kernel threads.</source>
          <target state="translated">オペレーティングシステムの観点から見たスレッド実装の背景をいくつか紹介します。スレッドには、ユーザーモードスレッド、カーネルスレッド、マルチプロセッサカーネルスレッドの3つの基本的なカテゴリがあります。</target>
        </trans-unit>
        <trans-unit id="fc0d6a626635ac5ae4291cc3487e50efd6ae5a14" translate="yes" xml:space="preserve">
          <source>Some bits may be relevant at compile-time only, some at run-time only. This is a new mechanism and the details may change. See also &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;.</source>
          <target state="translated">コンパイル時にのみ関連するビットもあれば、実行時にのみ関連するビットもあります。これは新しいメカニズムであり、詳細は変更される可能性があります。&lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="fd8e9b1766f0e1e6eaaded7abc870a37e4571ff0" translate="yes" xml:space="preserve">
          <source>Some brief examples:</source>
          <target state="translated">簡単な例をいくつか。</target>
        </trans-unit>
        <trans-unit id="61327002f5b3861abd79c62e144ccb79536f4f22" translate="yes" xml:space="preserve">
          <source>Some builtins (e.g. &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt;) has a call signature that cannot completely be representated with a Perl prototype. This means that some valid Perl code will be invalid under autodie. As an example:</source>
          <target state="translated">一部の組み込み関数（たとえば、 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/truncate&quot;&gt;truncate&lt;/a&gt;&lt;/code&gt; ）には、Perlプロトタイプでは完全に表現できない呼び出しシグネチャがあります。これは、いくつかの有効なPerlコードがautodieでは無効になることを意味します。例として：</target>
        </trans-unit>
        <trans-unit id="7e79ef5917eeda28b646e901197de5a6a38623ed" translate="yes" xml:space="preserve">
          <source>Some builtins (e.g. &lt;code&gt;chdir&lt;/code&gt; or &lt;code&gt;truncate&lt;/code&gt;) has a call signature that cannot completely be representated with a Perl prototype. This means that some valid Perl code will be invalid under autodie. As an example:</source>
          <target state="translated">一部のビルトイン（ &lt;code&gt;chdir&lt;/code&gt; や &lt;code&gt;truncate&lt;/code&gt; など）には、Perlプロトタイプで完全に表現できない呼び出しシグネチャがあります。これは、一部の有効なPerlコードがautodieでは無効になることを意味します。例として：</target>
        </trans-unit>
        <trans-unit id="21eaccc7842c81c4d4f8ac981ea6b511271286ba" translate="yes" xml:space="preserve">
          <source>Some calls simply aren't available, real or emulated, on every platform.</source>
          <target state="translated">一部の通話は、すべてのプラットフォームで、リアルでもエミュレートでも、利用できないことがあります。</target>
        </trans-unit>
        <trans-unit id="f873ff9032d8b5cf7f774b66c05c986170a4cd42" translate="yes" xml:space="preserve">
          <source>Some characters have multiple names (synonyms).</source>
          <target state="translated">複数の名前(同義語)を持つキャラクターもいます。</target>
        </trans-unit>
        <trans-unit id="7144ad6e6fa073f902e93d5905df49ebac937d92" translate="yes" xml:space="preserve">
          <source>Some code points also have abbreviated names, such as &quot;LF&quot; or &quot;NL&quot;. &lt;code&gt;viacode&lt;/code&gt; never returns these.</source>
          <target state="translated">一部のコードポイントには、「LF」や「NL」などの省略名もあります。 &lt;code&gt;viacode&lt;/code&gt; はこれらを返しません。</target>
        </trans-unit>
        <trans-unit id="73ac6d49c092929d2ed08d514c7b1beb64ede02a" translate="yes" xml:space="preserve">
          <source>Some code taken from &lt;a href=&quot;../more&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Catch&quot;&gt;Test::Catch&lt;/a&gt;, written by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;. Hence, those parts Copyright Micheal G Schwern 2001. Used and distributed with permission.</source>
          <target state="translated">Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;によって書かれた&lt;a href=&quot;../more&quot;&gt;Test :: More&lt;/a&gt;および&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Catch&quot;&gt;Test :: Catch&lt;/a&gt;から取得したコードの一部。したがって、これらの部品はCopyright Micheal G Schwern 2001です。許可を得て使用および配布しています。</target>
        </trans-unit>
        <trans-unit id="5561c8c582f640440613f3fca93ddc04efa36da2" translate="yes" xml:space="preserve">
          <source>Some code taken from &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;Test::Catch&quot;&gt;Test::Catch&lt;/a&gt;, written by Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;. Hence, those parts Copyright Micheal G Schwern 2001. Used and distributed with permission.</source>
          <target state="translated">Michael G Schwern &amp;lt;schwern@pobox.com&amp;gt;によって作成された&lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt;および&lt;a href=&quot;Test::Catch&quot;&gt;Test :: Catch&lt;/a&gt;から取得したコード。したがって、これらの部分はCopyright Micheal G Schwern2001です。許可を得て使用および配布しています。</target>
        </trans-unit>
        <trans-unit id="82e5cd1d1e32143aa0622aa3ff5ac884d8c3a28f" translate="yes" xml:space="preserve">
          <source>Some comparison operators, as their associativity,</source>
          <target state="translated">いくつかの比較演算子は、その連想性として。</target>
        </trans-unit>
        <trans-unit id="a1339e50839100723841e8e48747e9f9a1f5bed3" translate="yes" xml:space="preserve">
          <source>Some constants and functions are exported by default by this module; but for backward-compatibility any recently-added symbols are not exported by default and must be requested explicitly. When an import list is provided to the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; line, the default exports are not automatically imported. It is therefore best practice to always to explicitly list all the symbols required.</source>
          <target state="translated">一部の定数と関数は、このモジュールによってデフォルトでエクスポートされます。ただし、下位互換性のために、最近追加されたシンボルはデフォルトではエクスポートされないため、明示的に要求する必要があります。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; 行にインポートリストが提供されている場合、デフォルトのエクスポートは自動的にインポートされません。したがって、必要なすべてのシンボルを常に明示的にリストすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="54e9eafb99e932590ca2a179b6517831860be80f" translate="yes" xml:space="preserve">
          <source>Some constants and functions are exported by default by this module; but for backward-compatibility any recently-added symbols are not exported by default and must be requested explicitly. When an import list is provided to the &lt;code&gt;use Socket&lt;/code&gt; line, the default exports are not automatically imported. It is therefore best practice to always to explicitly list all the symbols required.</source>
          <target state="translated">一部の定数と関数は、このモジュールによってデフォルトでエクスポートされます。ただし、下位互換性のために、最近追加されたシンボルはデフォルトではエクスポートされないため、明示的に要求する必要があります。 &lt;code&gt;use Socket&lt;/code&gt; 行にインポートリストが提供されている場合、デフォルトのエクスポートは自動的にインポートされません。したがって、必要なすべての記号を常に明示的にリストすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="078dd465c32a4795a8e3e38bd49c7d92d32009a8" translate="yes" xml:space="preserve">
          <source>Some constants don't print correctly either with or without &lt;b&gt;-d&lt;/b&gt;. For instance, neither B::Deparse nor Data::Dumper know how to print dual-valued scalars correctly, as in:</source>
          <target state="translated">一部の定数は、&lt;b&gt;-dの&lt;/b&gt;有無にかかわらず正しく印刷されません。たとえば、B :: DeparseもData :: Dumperも、次のように2値スカラーを正しく出力する方法を認識していません。</target>
        </trans-unit>
        <trans-unit id="c475f4b24c437233a2b88333a558801f98c19297" translate="yes" xml:space="preserve">
          <source>Some contexts allow 2 or even 1 digit, but any usage without exactly three digits, the first being a zero, may give unintended results. (For example, in a regular expression it may be confused with a backreference; see &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;&quot;Octal escapes&quot; in perlrebackslash&lt;/a&gt;.) Starting in Perl 5.14, you may use &lt;code&gt;\o{}&lt;/code&gt; instead, which avoids all these problems. Otherwise, it is best to use this construct only for ordinals &lt;code&gt;\077&lt;/code&gt; and below, remembering to pad to the left with zeros to make three digits. For larger ordinals, either use &lt;code&gt;\o{}&lt;/code&gt;, or convert to something else, such as to hex and use &lt;code&gt;\N{U+}&lt;/code&gt; (which is portable between platforms with different character sets) or &lt;code&gt;\x{}&lt;/code&gt; instead.</source>
          <target state="translated">一部のコンテキストでは2桁または1桁が許可されますが、正確に3桁（最初はゼロ）を使用しないと、意図しない結果が生じる可能性があります。 （たとえば、正規表現では&lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;、後方&lt;/a&gt;参照と混同される可能性があります。perlrebackslashの「8進エスケープ」を参照してください。）Perl 5.14以降では、代わりに &lt;code&gt;\o{}&lt;/code&gt; 使用できます。これにより、これらすべての問題が回避されます。それ以外の場合は、この構成を序数 &lt;code&gt;\077&lt;/code&gt; 以下にのみ使用し、左側にゼロを埋めて3桁にすることを忘れないでください。より大きな序数の場合は、 &lt;code&gt;\o{}&lt;/code&gt; 使用するか、16進数に変換して、代わりに &lt;code&gt;\N{U+}&lt;/code&gt; （異なる文字セットのプラットフォーム間で移植可能）または &lt;code&gt;\x{}&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="0e689eba4cf9a38a4acdff5d45d4adaf1f020711" translate="yes" xml:space="preserve">
          <source>Some contexts allow 2 or even 1 digit, but any usage without exactly three digits, the first being a zero, may give unintended results. (For example, in a regular expression it may be confused with a backreference; see &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;Octal escapes in perlrebackslash&lt;/a&gt;.) Starting in Perl 5.14, you may use &lt;code&gt;\o{}&lt;/code&gt; instead, which avoids all these problems. Otherwise, it is best to use this construct only for ordinals &lt;code&gt;\077&lt;/code&gt; and below, remembering to pad to the left with zeros to make three digits. For larger ordinals, either use &lt;code&gt;\o{}&lt;/code&gt; , or convert to something else, such as to hex and use &lt;code&gt;\N{U+}&lt;/code&gt; (which is portable between platforms with different character sets) or &lt;code&gt;\x{}&lt;/code&gt; instead.</source>
          <target state="translated">一部のコンテキストでは2桁または1桁まで使用できますが、最初の数字がゼロである3桁がないと、意図しない結果が生じる可能性があります。 （たとえば、正規表現では&lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;後方&lt;/a&gt;参照と混同される可能性があります。perlrebackslashのOctalエスケープを参照してください。）Perl 5.14 以降では、これらすべての問題を回避する代わりに &lt;code&gt;\o{}&lt;/code&gt; 使用できます。それ以外の場合は、通常の &lt;code&gt;\077&lt;/code&gt; 以下でのみこの構成を使用し、左側にゼロを埋めて3桁にすることを忘れないでください。より大きな序数の場合は、 &lt;code&gt;\o{}&lt;/code&gt; 使用するか、16進数などに変換して、代わりに &lt;code&gt;\N{U+}&lt;/code&gt; （異なる文字セットのプラットフォーム間で移植可能）または &lt;code&gt;\x{}&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="17469d7643e0741d1ada43cbcada6ad7b4213174" translate="yes" xml:space="preserve">
          <source>Some cool command line examples to impress the Python crowd ;)</source>
          <target state="translated">Python の群衆を感動させるクールなコマンドラインの例をいくつか紹介します ;)</target>
        </trans-unit>
        <trans-unit id="4f597c06196db5dfae23debf5b526fce9cd25685" translate="yes" xml:space="preserve">
          <source>Some cool command line examples to impress the Python crowd ;) You might want to compare them to the results under -Mbignum or -Mbigrat:</source>
          <target state="translated">Python の群衆を感動させるクールなコマンドラインの例をいくつか紹介します ;)-Mbignum や -Mbigrat での結果と比較してみてください。</target>
        </trans-unit>
        <trans-unit id="c6746b978d2a5bd75b46a34b757950222f7e2d87" translate="yes" xml:space="preserve">
          <source>Some database drivers for DBI can also automatically encode and decode, but that is sometimes limited to the UTF-8 encoding.</source>
          <target state="translated">DBI用のデータベースドライバの中には、自動的にエンコードとデコードを行うことができるものもありますが、それはUTF-8エンコーディングに限定されることもあります。</target>
        </trans-unit>
        <trans-unit id="20c968c59a29a0ad6a0ddbad176bb82749120644" translate="yes" xml:space="preserve">
          <source>Some devices will be expecting a &quot;\r&quot; at the end of each line rather than a &quot;\n&quot;. In some ports of perl, &quot;\r&quot; and &quot;\n&quot; are different from their usual (Unix) ASCII values of &quot;\015&quot; and &quot;\012&quot;. You may have to give the numeric values you want directly, using octal (&quot;\015&quot;), hex (&quot;0x0D&quot;), or as a control-character specification (&quot;\cM&quot;).</source>
          <target state="translated">いくつかのデバイスは、&quot;\n &quot;ではなく、各行の最後に &quot;\r &quot;を期待しています。perl のいくつかのポートでは、&quot;\r&quot; と &quot;\n&quot; は、通常の (Unix の)ASCII 値である &quot;015&quot; と &quot;\012&quot; とは異なります。8進数(&quot;\015&quot;)、16進数(&quot;0x0D&quot;)、または制御文字指定(&quot;\cM&quot;)を使って、あなたが望む数値を直接与えなければならないかもしれません。</target>
        </trans-unit>
        <trans-unit id="29952c75d7a51b190a8cddfeefebadadc1b42414" translate="yes" xml:space="preserve">
          <source>Some digits that &lt;code&gt;\d&lt;/code&gt; matches look like some of the [0-9] ones, but have different values. For example, BENGALI DIGIT FOUR (U+09EA) looks very much like an ASCII DIGIT EIGHT (U+0038), and LEPCHA DIGIT SIX (U+1C46) looks very much like an ASCII DIGIT FIVE (U+0035). An application that is expecting only the ASCII digits might be misled, or if the match is &lt;code&gt;\d+&lt;/code&gt;, the matched string might contain a mixture of digits from different writing systems that look like they signify a number different than they actually do. &lt;a href=&quot;Unicode::UCD#num%28%29&quot;&gt;&quot;num()&quot; in Unicode::UCD&lt;/a&gt; can be used to safely calculate the value, returning &lt;code&gt;undef&lt;/code&gt; if the input string contains such a mixture. Otherwise, for example, a displayed price might be deliberately different than it appears.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 一致する一部の数字は、[0-9]の一部のように見えますが、値が異なります。たとえば、BENGALI DIGIT FOUR（U + 09EA）はASCII DIGIT EIGHT（U + 0038）に非常によく似ており、LEPCHA DIGIT SIX（U + 1C46）はASCII DIGIT FIVE（U + 0035）に非常によく似ています。 ASCII数字のみを期待しているアプリケーションは誤解される可能性があります。または、一致が &lt;code&gt;\d+&lt;/code&gt; 場合、一致する文字列には、実際とは異なる数字を示しているように見える、異なる書記体系の数字が混在している可能性があります。&lt;a href=&quot;Unicode::UCD#num%28%29&quot;&gt;Unicode :: UCDの「num（）」を&lt;/a&gt;使用して値を安全に計算でき、入力文字列にそのような混合が含まれている場合は &lt;code&gt;undef&lt;/code&gt; を返します。そうしないと、たとえば、表示されている価格が表示されている価格と意図的に異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="b15270299f74ddedc9cb2a27cec0a8d56d430a18" translate="yes" xml:space="preserve">
          <source>Some digits that &lt;code&gt;\d&lt;/code&gt; matches look like some of the [0-9] ones, but have different values. For example, BENGALI DIGIT FOUR (U+09EA) looks very much like an ASCII DIGIT EIGHT (U+0038). An application that is expecting only the ASCII digits might be misled, or if the match is &lt;code&gt;\d+&lt;/code&gt; , the matched string might contain a mixture of digits from different writing systems that look like they signify a number different than they actually do. &lt;a href=&quot;unicode/ucd#num()&quot;&gt;num() in Unicode::UCD&lt;/a&gt; can be used to safely calculate the value, returning &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the input string contains such a mixture.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 一致するいくつかの数字は、[0-9]の数字のように見えますが、値が異なります。たとえば、BENGALI DIGIT FOUR（U + 09EA）は、ASCII DIGIT EIGHT（U + 0038）によく似ています。 ASCII数字のみを期待しているアプリケーションは、誤解を招く可能性があります。または、一致が &lt;code&gt;\d+&lt;/code&gt; 場合、一致した文字列には、実際に異なる数字を示すように見える、異なる書記体系からの数字の混合が含まれる場合があります。&lt;a href=&quot;unicode/ucd#num()&quot;&gt;Unicode :: UCDのnum（）を&lt;/a&gt;使用して値を安全に計算し、入力文字列にそのような混合が含まれている場合は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返すことができます。</target>
        </trans-unit>
        <trans-unit id="eb6208f023afd54f9f4acc30a7d493bf14dc6378" translate="yes" xml:space="preserve">
          <source>Some distributions may fail some tests, but you may want to install them anyway (as above, or via &lt;code&gt;force install&lt;/code&gt; command of &lt;code&gt;CPAN.pm&lt;/code&gt; shell-mode).</source>
          <target state="translated">一部のディストリビューションは一部のテストに失敗する可能性がありますが、とにかく（上記のように、または &lt;code&gt;CPAN.pm&lt;/code&gt; シェルモードの &lt;code&gt;force install&lt;/code&gt; コマンドを使用して）インストールしたい場合があります。</target>
        </trans-unit>
        <trans-unit id="673083d85e2bc8b38798cec75fcc0568d074003d" translate="yes" xml:space="preserve">
          <source>Some distributions may need to link to libraries or other third-party code and their build and installation sequences may be more complicated. Check any</source>
          <target state="translated">ディストリビューションによっては、ライブラリや他のサードパーティコードへのリンクが必要な場合があり、そのビルドやインストールシーケンスがより複雑になる場合があります。そのような場合は</target>
        </trans-unit>
        <trans-unit id="1c42a00c69d1bae42ece6b69f30632a5649a6c28" translate="yes" xml:space="preserve">
          <source>Some documentation is not available as man pages, so if a cross-reference is not found by man, try it with &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;. Perldoc can also take you directly to documentation for functions (with the &lt;b&gt;-f&lt;/b&gt; switch). See &lt;code&gt;perldoc --help&lt;/code&gt; (or &lt;a href=&quot;perldoc&quot;&gt;&lt;code&gt;perldoc perldoc&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;man perldoc&lt;/code&gt;) for other helpful options &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; has to offer.</source>
          <target state="translated">一部のドキュメントはmanページとして利用できないため、manが相互参照を見つけられない場合は、&lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;で試してください。 Perldocを使用すると、関数のドキュメントに直接アクセスすることもできます（&lt;b&gt;-f&lt;/b&gt;スイッチを使用）。&lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;が提供しなければならない他の便利なオプションについては、 &lt;code&gt;perldoc --help&lt;/code&gt; （または&lt;a href=&quot;perldoc&quot;&gt; &lt;code&gt;perldoc perldoc&lt;/code&gt; &lt;/a&gt;または &lt;code&gt;man perldoc&lt;/code&gt; ）を参照してください。</target>
        </trans-unit>
        <trans-unit id="e14b5226c1b3194a20df87855367bd2962c1e595" translate="yes" xml:space="preserve">
          <source>Some documentation is not available as man pages, so if a cross-reference is not found by man, try it with &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;. Perldoc can also take you directly to documentation for functions (with the &lt;b&gt;-f&lt;/b&gt; switch). See &lt;code&gt;perldoc --help&lt;/code&gt; (or &lt;code&gt;perldoc perldoc&lt;/code&gt; or &lt;code&gt;man perldoc&lt;/code&gt; ) for other helpful options &lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt; has to offer.</source>
          <target state="translated">一部のドキュメントはmanページとして利用できないため、manによって相互参照が見つからない場合は、&lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;で試してください。Perldocは、関数のドキュメントに直接移動することもできます（&lt;b&gt;-f&lt;/b&gt;スイッチを使用）。&lt;a href=&quot;perldoc&quot;&gt;perldoc&lt;/a&gt;が提供するその他の便利なオプションについては、 &lt;code&gt;perldoc --help&lt;/code&gt; （または &lt;code&gt;perldoc perldoc&lt;/code&gt; または &lt;code&gt;man perldoc&lt;/code&gt; ）を参照してください。</target>
        </trans-unit>
        <trans-unit id="24f338e775f9d8f25e87916116198ed5fdfd8fac" translate="yes" xml:space="preserve">
          <source>Some earlier versions of this module had docs with some confusing typos in the description of &lt;code&gt;skip(...)&lt;/code&gt; .</source>
          <target state="translated">このモジュールの以前のバージョンの一部には、 &lt;code&gt;skip(...)&lt;/code&gt; の説明にいくつかの紛らわしいタイプミスがあるドキュメントがありました。</target>
        </trans-unit>
        <trans-unit id="755fe62cf032f564de90de30771b7c019c165183" translate="yes" xml:space="preserve">
          <source>Some earlier versions of this module had docs with some confusing typos in the description of &lt;code&gt;skip(...)&lt;/code&gt;.</source>
          <target state="translated">このモジュールの以前のバージョンのいくつかには、 &lt;code&gt;skip(...)&lt;/code&gt; の説明にいくつかの紛らわしいタイプミスのあるドキュメントがありました。</target>
        </trans-unit>
        <trans-unit id="2d5fff71fc694b06c17e66dad87b134506e2302b" translate="yes" xml:space="preserve">
          <source>Some essentially obsolete locales that aren't supersets of ASCII, mainly those in ISO 646 or other 7-bit locales, such as ASMO 449, can also have problems, depending on what portions of the ASCII character set get changed by the locale and are also used by the program. The warning message lists the determinable conflicting characters.</source>
          <target state="translated">ASCII のスーパーセットではない本質的に時代遅れのロケール、主に ISO 646 や ASMO 449 のような 7 ビットロケールも、ASCII 文字セットのどの部分がロケールによって変更され、 プログラムでも使用されるかによっては問題が発生する可能性があります。警告メッセージには、確定可能な競合文字が列挙されています。</target>
        </trans-unit>
        <trans-unit id="e8b38cbb77fcb476bf8e2983ccfda5ed33f46a79" translate="yes" xml:space="preserve">
          <source>Some example section specifications follow.</source>
          <target state="translated">以下にいくつかのセクションの仕様例を示します。</target>
        </trans-unit>
        <trans-unit id="6e29ae8ec1bfc30435ce56e5aeb3c20b82d6940f" translate="yes" xml:space="preserve">
          <source>Some examples of lists include:</source>
          <target state="translated">リストの例としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="ae84b84bf5612613743104cf4d1d3f624e770f5d" translate="yes" xml:space="preserve">
          <source>Some examples of syntactically invalid attribute lists (with annotation):</source>
          <target state="translated">構文的に無効な属性リストのいくつかの例(注釈付き)。</target>
        </trans-unit>
        <trans-unit id="9c0e82c6c1b276d5dbb162e62c1346aa697136e3" translate="yes" xml:space="preserve">
          <source>Some examples of syntactically valid attribute lists:</source>
          <target state="translated">構文的に有効な属性リストのいくつかの例。</target>
        </trans-unit>
        <trans-unit id="9ef77adb00cc27df250473773f43482c29f3a24d" translate="yes" xml:space="preserve">
          <source>Some examples of valid string input</source>
          <target state="translated">有効な文字列入力の例</target>
        </trans-unit>
        <trans-unit id="01706013cfdbcb0fc543d3c97784f3f4c235d630" translate="yes" xml:space="preserve">
          <source>Some examples:</source>
          <target state="translated">いくつかの例を紹介します。</target>
        </trans-unit>
        <trans-unit id="75d23fa0c37e5a03812b09ef6b9c46fbb0fa3389" translate="yes" xml:space="preserve">
          <source>Some extensions provide filters on data entry/exit points, such as &lt;code&gt;DB_File::filter_store_key&lt;/code&gt; and family. Look out for such filters in the documentation of your extensions; they can make the transition to Unicode data much easier.</source>
          <target state="translated">一部の拡張機能は、 &lt;code&gt;DB_File::filter_store_key&lt;/code&gt; やファミリなど、データのエントリポイント/出口ポイントにフィルタを提供します。拡張機能のドキュメントでそのようなフィルターを探してください。 Unicodeデータへの移行をはるかに簡単にすることができます。</target>
        </trans-unit>
        <trans-unit id="1ba2d8223f5d5832c6d62c8b546d87c608dd84fc" translate="yes" xml:space="preserve">
          <source>Some extensions, like DB_File and Compress::Zlib use/require prebuilt libraries for the perl extensions/modules to work. If these libraries are built using the default configuration, it might happen that you run into an error like &quot;invalid loader fixup&quot; during load phase. HP is aware of this problem. Search the HP-UX cxx-dev forums for discussions about the subject. The short answer is that &lt;b&gt;everything&lt;/b&gt; (all libraries, everything) must be compiled with &lt;code&gt;+z&lt;/code&gt; or &lt;code&gt;+Z&lt;/code&gt; to be PIC (position independent code). (For gcc, that would be &lt;code&gt;-fpic&lt;/code&gt; or &lt;code&gt;-fPIC&lt;/code&gt; ). In HP-UX 11.00 or newer the linker error message should tell the name of the offending object file.</source>
          <target state="translated">DB_FileやCompress :: Zlibなどの一部の拡張機能は、perl拡張機能/モジュールが機能するために、事前に構築されたライブラリを使用/必要とします。これらのライブラリーがデフォルト構成を使用してビルドされている場合、ロード・フェーズ中に「無効なローダー修正」のようなエラーが発生する可能性があります。 HPはこの問題を認識しています。この件に関するディスカッションについては、HP-UX cxx-devフォーラムを検索してください。簡単に言えば、PIC（位置独立コード）になるには、&lt;b&gt;すべて&lt;/b&gt;（すべてのライブラリ、すべて）を &lt;code&gt;+z&lt;/code&gt; または &lt;code&gt;+Z&lt;/code&gt; でコンパイルする必要があります。 （gccの場合、 &lt;code&gt;-fpic&lt;/code&gt; または &lt;code&gt;-fPIC&lt;/code&gt; になります）。 HP-UX 11.00以降では、リンカーエラーメッセージで問題のオブジェクトファイルの名前が示されます。</target>
        </trans-unit>
        <trans-unit id="97e5fb9532f2e63b2e8307d7b53c5f2c9628f824" translate="yes" xml:space="preserve">
          <source>Some extensions, like DB_File and Compress::Zlib use/require prebuilt libraries for the perl extensions/modules to work. If these libraries are built using the default configuration, it might happen that you run into an error like &quot;invalid loader fixup&quot; during load phase. HP is aware of this problem. Search the HP-UX cxx-dev forums for discussions about the subject. The short answer is that &lt;b&gt;everything&lt;/b&gt; (all libraries, everything) must be compiled with &lt;code&gt;+z&lt;/code&gt; or &lt;code&gt;+Z&lt;/code&gt; to be PIC (position independent code). (For gcc, that would be &lt;code&gt;-fpic&lt;/code&gt; or &lt;code&gt;-fPIC&lt;/code&gt;). In HP-UX 11.00 or newer the linker error message should tell the name of the offending object file.</source>
          <target state="translated">DB_FileやCompress :: Zlibなどの一部の拡張機能は、perl拡張機能/モジュールが機能するためにビルド済みのライブラリを使用/必要とします。これらのライブラリがデフォルト構成を使用して構築されている場合、ロードフェーズ中に「無効なローダーの修正」などのエラーが発生する可能性があります。 HPはこの問題を認識しています。このテーマに関する議論については、HP-UXcxx-devフォーラムを検索してください。簡単に言うと、PIC（位置に依存しないコード）になるには、&lt;b&gt;すべて&lt;/b&gt;（すべてのライブラリ、すべて）を &lt;code&gt;+z&lt;/code&gt; または &lt;code&gt;+Z&lt;/code&gt; でコンパイルする必要があります。 （gccの場合、 &lt;code&gt;-fpic&lt;/code&gt; または &lt;code&gt;-fPIC&lt;/code&gt; になります）。 HP-UX 11.00以降では、リンカーエラーメッセージに問題のあるオブジェクトファイルの名前が表示されます。</target>
        </trans-unit>
        <trans-unit id="96048dd05a92d52cf8eb93ed66aaff949feef0b8" translate="yes" xml:space="preserve">
          <source>Some features of Storable can lead to security vulnerabilities if you accept Storable documents from untrusted sources with the default flags. Most obviously, the optional (off by default) CODE reference serialization feature allows transfer of code to the deserializing process. Furthermore, any serialized object will cause Storable to helpfully load the module corresponding to the class of the object in the deserializing module. For manipulated module names, this can load almost arbitrary code. Finally, the deserialized object's destructors will be invoked when the objects get destroyed in the deserializing process. Maliciously crafted Storable documents may put such objects in the value of a hash key that is overridden by another key/value pair in the same hash, thus causing immediate destructor execution.</source>
          <target state="translated">Storable の機能の中には、デフォルトのフラグで信頼されていないソースから Storable ドキュメントを受け入れると、セキュリティの脆弱性につながるものがあります。最も明らかなのは、オプションの(デフォルトではオフの)CODE参照シリアライズ機能により、デシリアライズ処理へのコードの転送が可能になることです。さらに、任意のシリアライズされたオブジェクトは、デシリアライズモジュール内のオブジェクトのクラスに対応するモジュールをStorableが親切にロードするようになります。操作されたモジュール名の場合、これはほぼ任意のコードをロードすることができます。最後に、オブジェクトがデシリアライズ処理で破壊されると、デシリアライズされたオブジェクトのデストラクタが呼び出されます。悪意を持って細工されたStorableドキュメントは、そのようなオブジェクトを、同じハッシュ内の別のキー/値のペアによってオーバーライドされたハッシュキーの値の中に置くことがあり、その結果、即座にデストラクタが実行されてしまいます。</target>
        </trans-unit>
        <trans-unit id="4b7fd53f722062eada03c99c5c0131726fe7cb4c" translate="yes" xml:space="preserve">
          <source>Some features of Storable can lead to security vulnerabilities if you accept Storable documents from untrusted sources. Most obviously, the optional (off by default) CODE reference serialization feature allows transfer of code to the deserializing process. Furthermore, any serialized object will cause Storable to helpfully load the module corresponding to the class of the object in the deserializing module. For manipulated module names, this can load almost arbitrary code. Finally, the deserialized object's destructors will be invoked when the objects get destroyed in the deserializing process. Maliciously crafted Storable documents may put such objects in the value of a hash key that is overridden by another key/value pair in the same hash, thus causing immediate destructor execution.</source>
          <target state="translated">信頼できないソースからStorable文書を受け取ると、Storableの一部の機能がセキュリティ上の脆弱性につながる可能性があります。最も明らかなのは、オプションの (デフォルトではオフの)CODE リファレンスシリアライズ機能により、デシリアライズ処理へのコードの転送が可能になることです。さらに、シリアル化されたオブジェクトは、デシリアライズ モジュール内のオブジェクトのクラスに対応するモジュールを Storable が親切にロードするようになります。操作されたモジュール名の場合、これはほぼ任意のコードをロードすることができます。最後に、オブジェクトがデシリアライズ処理で破壊されると、デシリアライズされたオブジェクトのデストラクタが呼び出されます。悪意を持って細工されたStorableドキュメントは、そのようなオブジェクトを、同じハッシュ内の別のキー/値のペアによってオーバーライドされたハッシュキーの値の中に置くことがあり、その結果、即座にデストラクタが実行されてしまいます。</target>
        </trans-unit>
        <trans-unit id="f752a90675005dd54235d7444500f6345be768a8" translate="yes" xml:space="preserve">
          <source>Some fields (prereq, optional_features) indicate the particular version(s) of some other module that may be required as a prerequisite. This section details the Version Range type used to provide this information.</source>
          <target state="translated">いくつかのフィールド (prereq,optional_features)は、前提条件として要求される可能性のある他のモジュールの特定のバージョンを示します。このセクションでは、この情報を提供するために使用されるバージョン範囲のタイプについて詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="4359f8aa4aabe1dad1748bdef1a7b9a37c1bbf67" translate="yes" xml:space="preserve">
          <source>Some fields are marked</source>
          <target state="translated">いくつかのフィールドにはマークが付いています。</target>
        </trans-unit>
        <trans-unit id="5db1ec9986268b7b9f60738685c3882e9bc3347c" translate="yes" xml:space="preserve">
          <source>Some fields require a version specification (ex. &lt;a href=&quot;#requires&quot;&gt;&quot;requires&quot;&lt;/a&gt;, &lt;a href=&quot;#recommends&quot;&gt;&quot;recommends&quot;&lt;/a&gt;, &lt;a href=&quot;#build_requires&quot;&gt;&quot;build_requires&quot;&lt;/a&gt;, etc.) to indicate the particular version(s) of some other module that may be required as a prerequisite. This section details the version specification formats that are currently supported.</source>
          <target state="translated">一部のフィールドでは、前提条件として必要となる可能性のある他のモジュールの特定のバージョンを示すために、バージョン指定（&lt;a href=&quot;#requires&quot;&gt;「requires」&lt;/a&gt;、&lt;a href=&quot;#recommends&quot;&gt;「recommends」&lt;/a&gt;、&lt;a href=&quot;#build_requires&quot;&gt;「build_requires」&lt;/a&gt;など）が必要です。このセクションでは、現在サポートされているバージョン仕様フォーマットについて詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="97585d9b5872f5fb97ab1bbd9ba4d3f871bc3309" translate="yes" xml:space="preserve">
          <source>Some fields require a version specification (ex. &lt;a href=&quot;#requires&quot;&gt;&quot;requires&quot;&lt;/a&gt;, &lt;a href=&quot;#recommends&quot;&gt;&quot;recommends&quot;&lt;/a&gt;, &lt;a href=&quot;#build_requires&quot;&gt;&quot;build_requires&quot;&lt;/a&gt;, etc.). This section details the version specifications that are currently supported.</source>
          <target state="translated">一部のフィールドにはバージョン指定が必要です（例：&lt;a href=&quot;#requires&quot;&gt;「requires」&lt;/a&gt;、&lt;a href=&quot;#recommends&quot;&gt;「recommends」&lt;/a&gt;、&lt;a href=&quot;#build_requires&quot;&gt;「build_requires」&lt;/a&gt;など）。このセクションでは、現在サポートされているバージョン仕様について詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="f1a5845f2d183141d3d5841eae9982c91a04a877" translate="yes" xml:space="preserve">
          <source>Some filesystems may not support UTF-8 file names, or they may be supported incompatibly with Perl. Therefore UTF-8 names that are visible to the filesystem, such as module names may not work.</source>
          <target state="translated">ファイルシステムによっては、ファイル名がUTF-8に対応していない場合や、Perlとの互換性がない場合があります。そのため、モジュール名のようにファイルシステムから見えるUTF-8名は動作しない可能性があります。</target>
        </trans-unit>
        <trans-unit id="410f15ec6c766d4ad924aef6bed79d8486d14679" translate="yes" xml:space="preserve">
          <source>Some folks are surprised that &lt;code&gt;make distclean&lt;/code&gt; does not delete everything not listed in their MANIFEST (thus making a clean distribution) but only tells them what they need to delete. This is done because it is considered too dangerous. While developing your module you might write a new file, not add it to the MANIFEST, then run a &lt;code&gt;distclean&lt;/code&gt; and be sad because your new work was deleted.</source>
          <target state="translated">一部の人々は、 &lt;code&gt;make distclean&lt;/code&gt; がMANIFESTにリストされていないすべてを削除するのではなく（したがって、クリーンなディストリビューションを作成します）、驚かされます。危険すぎると考えられているためです。モジュールの開発中に、MANIFESTに追加するのではなく、新しいファイルを作成してから、 &lt;code&gt;distclean&lt;/code&gt; を実行すると、新しい作業が削除されたため悲しくなります。</target>
        </trans-unit>
        <trans-unit id="278e93ddc6a44b33edbb2aa1b1e3252bdefc68ee" translate="yes" xml:space="preserve">
          <source>Some folks would prefer full alphanumeric prototypes. Alphanumerics have been intentionally left out of prototypes for the express purpose of someday in the future adding named, formal parameters. The current mechanism's main goal is to let module writers provide better diagnostics for module users. Larry feels the notation quite understandable to Perl programmers, and that it will not intrude greatly upon the meat of the module, nor make it harder to read. The line noise is visually encapsulated into a small pill that's easy to swallow.</source>
          <target state="translated">中には、完全な英数字のプロトタイプを希望する人もいます。英数字は、将来的に名前付きの正式なパラメータを追加するという明確な目的のために、意図的にプロトタイプから除外されています。現在のメカニズムの主な目的は、モジュール・ライターがモジュール・ユーザのためにより良い診断を提供できるようにすることです。ラリーは、この表記法はPerlプログラマにとって非常に理解しやすいもので、モジュールの本質を大きく阻害したり、読みにくくしたりすることはないと考えています。ラインノイズは、飲み込みやすい小さな錠剤に視覚的にカプセル化されています。</target>
        </trans-unit>
        <trans-unit id="97b6babea6d7a1882a7f9edff1a7d1c57e6e6a28" translate="yes" xml:space="preserve">
          <source>Some format names that formatters currently are known to accept include &quot;roff&quot;, &quot;man&quot;, &quot;latex&quot;, &quot;tex&quot;, &quot;text&quot;, and &quot;html&quot;. (Some formatters will treat some of these as synonyms.)</source>
          <target state="translated">現在フォーマッタが受け入れることが知られているフォーマット名には、&quot;roff&quot;,&quot;man&quot;,&quot;latex&quot;,&quot;tex&quot;,&quot;text&quot;,&quot;html &quot;などがあります。(いくつかのフォーマッタはこれらのいくつかを同義語として扱います)。</target>
        </trans-unit>
        <trans-unit id="947f64f8eb13b365edd8f2a637d714cf57c4bdc9" translate="yes" xml:space="preserve">
          <source>Some formatter subclasses use this as a flag for whether output should have prologue and epilogue code omitted. For example, setting this to true for an HTML formatter class should omit the &quot;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;...&amp;lt;/title&amp;gt;&amp;lt;body&amp;gt;...&quot; prologue and the &quot;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot; epilogue.</source>
          <target state="translated">一部のフォーマッタサブクラスは、これを出力でプロローグコードとエピローグコードを省略するかどうかのフラグとして使用します。たとえば、HTMLフォーマッタクラスでこれをtrueに設定すると、「&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt; ... &amp;lt;/ title&amp;gt; &amp;lt;body&amp;gt; ...」プロローグと「&amp;lt;/ body&amp;gt; &amp;lt;/ html」を省略できます。 &amp;gt; &quot;エピローグ。</target>
        </trans-unit>
        <trans-unit id="bae9c58f7596d57c13463eeb374970b17faa09ff" translate="yes" xml:space="preserve">
          <source>Some frequently seen examples:</source>
          <target state="translated">よく見かける例もあります。</target>
        </trans-unit>
        <trans-unit id="5f63fbe742ecc7df05393f6e705a1b34f98dd874" translate="yes" xml:space="preserve">
          <source>Some functions are provided to simplify customization.</source>
          <target state="translated">カスタマイズを簡単にするためにいくつかの機能が用意されています。</target>
        </trans-unit>
        <trans-unit id="37fca23bc4f77bc45e835fb641ab69a99facbd7e" translate="yes" xml:space="preserve">
          <source>Some functions are slower when working on UTF-8 encoded strings than on byte encoded strings. All functions that need to hop over characters such as &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt;, or matching regular expressions can work &lt;b&gt;much&lt;/b&gt; faster when the underlying data are byte-encoded.</source>
          <target state="translated">一部の関数は、バイトエンコードされた文字列よりも、UTF-8エンコードされた文字列を処理する場合に時間がかかります。 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index()&lt;/a&gt;&lt;/code&gt; などの文字をホップする必要があるすべての関数、または正規表現のマッチングは、基になるデータがバイトエンコードされている場合、&lt;b&gt;はるかに&lt;/b&gt;高速に機能します。</target>
        </trans-unit>
        <trans-unit id="29d81f6ce46ee6c8888e985a057496dc42144979" translate="yes" xml:space="preserve">
          <source>Some functions are slower when working on UTF-8 encoded strings than on byte encoded strings. All functions that need to hop over characters such as &lt;code&gt;length()&lt;/code&gt;, &lt;code&gt;substr()&lt;/code&gt; or &lt;code&gt;index()&lt;/code&gt;, or matching regular expressions can work &lt;b&gt;much&lt;/b&gt; faster when the underlying data are byte-encoded.</source>
          <target state="translated">一部の関数は、UTF-8でエンコードされた文字列を処理する場合、バイトでエンコードされた文字列よりも遅くなります。 &lt;code&gt;length()&lt;/code&gt; 、 &lt;code&gt;substr()&lt;/code&gt; 、 &lt;code&gt;index()&lt;/code&gt; などの文字をホップする必要があるすべての関数、または一致する正規式は、基になるデータがバイトエンコードされている場合に&lt;b&gt;はるかに&lt;/b&gt;高速に動作します。</target>
        </trans-unit>
        <trans-unit id="83116620b210d6b01d6ea586806a731e05a2beb8" translate="yes" xml:space="preserve">
          <source>Some functions available based on the version of VMS. (VMS)</source>
          <target state="translated">VMSのバージョンに応じて利用できる機能があります。(VMS)</target>
        </trans-unit>
        <trans-unit id="851bf3122418d781546b0c8256e17049b7be4c91" translate="yes" xml:space="preserve">
          <source>Some languages work directly with the memory addresses of values, but this can be like playing with fire. Perl provides a set of asbestos gloves for handling all memory management. The closest to an address operator in Perl is the backslash operator, but it gives you a &lt;b&gt;hard reference&lt;/b&gt;, which is much safer than a memory address.</source>
          <target state="translated">一部の言語は値のメモリアドレスを直接処理しますが、これは火で遊ぶようなものです。Perlは、すべてのメモリ管理を処理するためのアスベストグローブのセットを提供します。Perlのアドレス演算子に最も近いのはバックスラッシュ演算子ですが、これは&lt;b&gt;ハード参照&lt;/b&gt;を提供します。これはメモリアドレスよりもはるかに安全です。</target>
        </trans-unit>
        <trans-unit id="3b63ca608d0f3df96b959d17a1dcc8d27338725f" translate="yes" xml:space="preserve">
          <source>Some layers will automatically insert required lower level layers if not present; for example &lt;code&gt;:perlio&lt;/code&gt; will insert &lt;code&gt;:unix&lt;/code&gt; below itself for low level IO, and &lt;code&gt;:encoding&lt;/code&gt; will insert the platform defaults for buffered IO.</source>
          <target state="translated">一部のレイヤーは、存在しない場合、必要な下位レベルのレイヤーを自動的に挿入します。たとえば、 &lt;code&gt;:perlio&lt;/code&gt; は低レベルIOの場合はそれ自体の下に &lt;code&gt;:unix&lt;/code&gt; を挿入し、 &lt;code&gt;:encoding&lt;/code&gt; はバッファリングされたIOの場合はプラットフォームのデフォルトを挿入します。</target>
        </trans-unit>
        <trans-unit id="2879836a3b0aef43a136fc41d29e15e272723203" translate="yes" xml:space="preserve">
          <source>Some libraries use methods that don't modify their argument, and some libraries don't even use objects, but rather unblessed references. Because of this, liberary methods are always called as class methods, not instance methods:</source>
          <target state="translated">ライブラリによっては、引数を変更しないメソッドを使っているところもありますし、オブジェクトすら使わず、無節操な参照を使っているところもあります。このため、リベラルメソッドは常にインスタンスメソッドではなく、クラスメソッドとして呼び出されます。</target>
        </trans-unit>
        <trans-unit id="f2704cdd835e2ffc2151c5b3e73d345acc2100f0" translate="yes" xml:space="preserve">
          <source>Some locales have special sorting rules.</source>
          <target state="translated">一部のロケールでは、特別なソートルールがあります。</target>
        </trans-unit>
        <trans-unit id="4cbad0bcc8b3efd678863ec66e302790409bbb20" translate="yes" xml:space="preserve">
          <source>Some methods take slightly different arguments to those defined in &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; in attempt to make the interface more flexible. These are</source>
          <target state="translated">一部のメソッドは、インターフェイスをより柔軟にするために、&lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt;で定義されたものとは少し異なる引数を取ります。これらは</target>
        </trans-unit>
        <trans-unit id="4d5ca2cd44839d0147fa7ed895887914f1a8f96d" translate="yes" xml:space="preserve">
          <source>Some modules have an event loop, waiting for user-input. It is highly unlikely that two such modules would work adequately together in a single Perl application.</source>
          <target state="translated">いくつかのモジュールは、ユーザの入力を待つイベントループを持っています。このようなモジュールが、1つのPerlアプリケーションで2つのモジュールが一緒に動作することはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="e535cd54feac531816f027ba1cdedeba3dabdc08" translate="yes" xml:space="preserve">
          <source>Some modules have validation for particular types of input, such as &lt;a href=&quot;Business::ISBN&quot;&gt;Business::ISBN&lt;/a&gt;, &lt;a href=&quot;Business::CreditCard&quot;&gt;Business::CreditCard&lt;/a&gt;, &lt;a href=&quot;Email::Valid&quot;&gt;Email::Valid&lt;/a&gt;, and &lt;a href=&quot;Data::Validate::IP&quot;&gt;Data::Validate::IP&lt;/a&gt;.</source>
          <target state="translated">一部のモジュールには、&lt;a href=&quot;Business::ISBN&quot;&gt;Business :: ISBN&lt;/a&gt;、&lt;a href=&quot;Business::CreditCard&quot;&gt;Business :: CreditCard&lt;/a&gt;、&lt;a href=&quot;Email::Valid&quot;&gt;Email :: Valid&lt;/a&gt;、&lt;a href=&quot;Data::Validate::IP&quot;&gt;Data :: Validate :: IP&lt;/a&gt;などの特定のタイプの入力に対する検証があります。</target>
        </trans-unit>
        <trans-unit id="99aeed54cc1e7c695f296661c28f743d9f582de7" translate="yes" xml:space="preserve">
          <source>Some modules have validation for particular types of input, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business::ISBN&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Business::CreditCard&quot;&gt;Business::CreditCard&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Valid&quot;&gt;Email::Valid&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Validate::IP&quot;&gt;Data::Validate::IP&lt;/a&gt;.</source>
          <target state="translated">一部のモジュールは、&lt;a href=&quot;http://search.cpan.org/perldoc/Business::ISBN&quot;&gt;Business :: ISBN&lt;/a&gt;、&lt;a href=&quot;http://search.cpan.org/perldoc/Business::CreditCard&quot;&gt;Business :: CreditCard&lt;/a&gt;、&lt;a href=&quot;http://search.cpan.org/perldoc/Email::Valid&quot;&gt;Email :: Valid&lt;/a&gt;、および&lt;a href=&quot;http://search.cpan.org/perldoc/Data::Validate::IP&quot;&gt;Data :: Validate :: IP&lt;/a&gt;など、特定のタイプの入力を検証します。</target>
        </trans-unit>
        <trans-unit id="8896acdebb142a8bf319a25d0ebc467b0372d0f5" translate="yes" xml:space="preserve">
          <source>Some modules live both in the &lt;b&gt;Standard Library&lt;/b&gt; and on &lt;b&gt;CPAN&lt;/b&gt;. These modules might be developed on two tracks as people modify either version. The trend currently is to untangle these situations.</source>
          <target state="translated">一部のモジュールは、&lt;b&gt;標準ライブラリ&lt;/b&gt;と&lt;b&gt;CPANの&lt;/b&gt;両方にあります。これらのモジュールは、いずれかのバージョンを変更するときに2つのトラックで開発される可能性があります。現在の傾向は、これらの状況を解決することです。</target>
        </trans-unit>
        <trans-unit id="267ef3c8246a5b5e4dbd867563c1e64b65448f37" translate="yes" xml:space="preserve">
          <source>Some modules look directly at hash keys on the Test::Builder singleton. The problem here is that the Test::Builder singleton no longer holds anything important.</source>
          <target state="translated">モジュールの中には、Test::Builderシングルトンのハッシュキーを直接見るものがあります。ここでの問題は、Test::Builder のシングルトンがもはや何も重要なものを保持していないことです。</target>
        </trans-unit>
        <trans-unit id="215c8776bbaeb0d62cdfe5e95b87468adeef4092" translate="yes" xml:space="preserve">
          <source>Some modules may call a non-perl library that is locale-aware. This is fine as long as it doesn't try to query or change the locale using the system &lt;code&gt;setlocale&lt;/code&gt;. But if these do call the system &lt;code&gt;setlocale&lt;/code&gt;, those calls may be ineffective. Instead, &lt;a href=&quot;perlapi#Perl_setlocale&quot;&gt;&lt;code&gt;Perl_setlocale&lt;/code&gt;&lt;/a&gt; works in all circumstances. Plain setlocale is ineffective on multi-threaded POSIX 2008 systems. It operates only on the global locale, whereas each thread has its own locale, paying no attention to the global one. Since converting these non-Perl libraries to &lt;code&gt;Perl_setlocale&lt;/code&gt; is out of the question, there is a new function in v5.28 &lt;a href=&quot;perlapi#switch_to_global_locale&quot;&gt;&lt;code&gt;switch_to_global_locale&lt;/code&gt;&lt;/a&gt; that will switch the thread it is called from so that any system &lt;code&gt;setlocale&lt;/code&gt; calls will have their desired effect. The function &lt;a href=&quot;perlapi#sync_locale&quot;&gt;&lt;code&gt;sync_locale&lt;/code&gt;&lt;/a&gt; must be called before returning to perl.</source>
          <target state="translated">一部のモジュールは、ロケール対応の非perlライブラリを呼び出す場合があります。これは、システム &lt;code&gt;setlocale&lt;/code&gt; を使用してロケールを照会または変更しようとしない限り、問題ありません。ただし、これらがシステム &lt;code&gt;setlocale&lt;/code&gt; を呼び出す場合、これらの呼び出しは効果がない可能性があります。代わりに、&lt;a href=&quot;perlapi#Perl_setlocale&quot;&gt; &lt;code&gt;Perl_setlocale&lt;/code&gt; &lt;/a&gt;はすべての状況で機能します。プレーンなsetlocaleは、マルチスレッドのPOSIX2008システムでは効果がありません。これはグローバルロケールでのみ動作しますが、各スレッドには独自のロケールがあり、グローバルロケールには注意を払いません。これらの非Perlライブラリを &lt;code&gt;Perl_setlocale&lt;/code&gt; に変換することは問題外であるため、v5.28 &lt;a href=&quot;perlapi#switch_to_global_locale&quot;&gt; &lt;code&gt;switch_to_global_locale&lt;/code&gt; &lt;/a&gt;には、呼び出されたスレッドを切り替えて、システムが &lt;code&gt;setlocale&lt;/code&gt; になるようにする新しい関数があります。呼び出しは、望ましい効果をもたらします。perlに戻る前に、関数&lt;a href=&quot;perlapi#sync_locale&quot;&gt; &lt;code&gt;sync_locale&lt;/code&gt; を呼び出す&lt;/a&gt;必要があります。</target>
        </trans-unit>
        <trans-unit id="2536c5611f03605401087c295c560b8c0a55966f" translate="yes" xml:space="preserve">
          <source>Some modules might have special reporting requirements, such as a Github or Google Code tracking system, so you should check the module documentation too.</source>
          <target state="translated">モジュールによっては、GithubやGoogleのコードトラッキングシステムのように、特別な報告要件がある場合がありますので、モジュールのドキュメントも確認してください。</target>
        </trans-unit>
        <trans-unit id="9d3dcbb265761ea263567338345aa34c90c2eea2" translate="yes" xml:space="preserve">
          <source>Some modules, mainly extensions, provide their own AUTOLOAD subroutines. They typically need to check for some special cases (such as constants) and then fallback to &lt;b&gt;AutoLoader&lt;/b&gt;'s AUTOLOAD for the rest.</source>
          <target state="translated">一部のモジュール、主に拡張は、独自のAUTOLOADサブルーチンを提供します。彼らは通常、いくつかの特別なケース（定数など）をチェックしてから、残りの部分について&lt;b&gt;AutoLoader&lt;/b&gt;のAUTOLOADにフォールバックする必要があります。</target>
        </trans-unit>
        <trans-unit id="f0adb7b022a9b5dadbc9c6aa9b58b0a54e7f8265" translate="yes" xml:space="preserve">
          <source>Some more examples, all returning 250:</source>
          <target state="translated">他にもいくつかの例がありますが、すべて250を返します。</target>
        </trans-unit>
        <trans-unit id="2c12ec8767768e2405ac12fa9dd3e5b3e02eaa4d" translate="yes" xml:space="preserve">
          <source>Some names known to &lt;code&gt;\N{...}&lt;/code&gt; refer to a sequence of multiple characters, instead of the usual single character. When one of these is included in the class, the entire sequence is matched. For example,</source>
          <target state="translated">&lt;code&gt;\N{...}&lt;/code&gt; 知られている一部の名前は、通常の1文字ではなく、複数の文字のシーケンスを参照しています。これらの1つがクラスに含まれている場合、シーケンス全体が照合されます。例えば、</target>
        </trans-unit>
        <trans-unit id="86874fce71a4882d328a8877cd2a4fc52a6a4fe2" translate="yes" xml:space="preserve">
          <source>Some networking library functions like gethostbyname() are known to have their own implementations of timeouts which may conflict with your timeouts. If you have problems with such functions, try using the POSIX sigaction() function, which bypasses Perl safe signals. Be warned that this does subject you to possible memory corruption, as described above.</source>
          <target state="translated">gethostbyname()のようないくつかのネットワーキングライブラリ関数は、タイムアウトの独自の実装を持っていることが知られていますが、それはあなたのタイムアウトと競合する可能性があります。このような関数で問題がある場合は、Perl の安全なシグナルをバイパスする POSIX sigaction()関数を使ってみてください。これは Perl の安全信号をバイパスするものですが、上で述べたようにメモリ破損の可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0ce6014b84ac6fe075f649ff6034ad219b7b909a" translate="yes" xml:space="preserve">
          <source>Some non-Perl implementations of the Age property may change its meaning to be the same as the Perl &lt;code&gt;Present_In&lt;/code&gt; property; just be aware of that.</source>
          <target state="translated">Ageプロパティの非Perl実装によっては、その意味がPerl &lt;code&gt;Present_In&lt;/code&gt; プロパティと同じになるように変更される場合があります。ただそれを意識してください。</target>
        </trans-unit>
        <trans-unit id="020d12e0872ef168546404b52284bd6940ecd187" translate="yes" xml:space="preserve">
          <source>Some non-numeric HTML entity name, such as &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; , meaning the same thing as &lt;code&gt;&amp;amp;eacute;&lt;/code&gt; in HTML -- i.e., a lowercase e with an acute (/-shaped) accent.</source>
          <target state="translated">&lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; など、数値以外のHTMLエンティティ名 &lt;code&gt;&amp;amp;eacute;&lt;/code&gt; と同じことを意味します。HTMLの場合-つまり、鋭い（/形）アクセントを持つ小文字のe。</target>
        </trans-unit>
        <trans-unit id="d647bb86c88fea55dd1fa79cef8c74e6a775c39b" translate="yes" xml:space="preserve">
          <source>Some non-numeric HTML entity name, such as &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt;, meaning the same thing as &lt;code&gt;&amp;amp;eacute;&lt;/code&gt; in HTML -- i.e., a lowercase e with an acute (/-shaped) accent.</source>
          <target state="translated">&lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; などの数値以外のHTMLエンティティ名 &lt;code&gt;&amp;amp;eacute;&lt;/code&gt; と同じ意味です。HTMLの場合-つまり、鋭い（/字型の）アクセントが付いた小文字のe。</target>
        </trans-unit>
        <trans-unit id="742d524f056fc75f1015c7da11070249cb40a21b" translate="yes" xml:space="preserve">
          <source>Some notes about ftp archives: Please use a long descriptive file name that includes the version number. Most incoming directories will not be readable/listable, i.e., you won't be able to see your file after uploading it. Remember to send your email notification message as soon as possible after uploading else your file may get deleted automatically. Allow time for the file to be processed and/or check the file has been processed before announcing its location.</source>
          <target state="translated">ftp アーカイブについての注意事項です。バージョン番号を含む長い説明的なファイル名を使用してください。ほとんどの受信ディレクトリでは、ファイルをアップロードした後にファイルを見ることができなくなります。アップロード後、できるだけ早くメール通知メッセージを送信するようにしてください。ファイルが処理されるまでに時間がかかる場合や、ファイルが処理されたかどうかを確認してから、ファイルの場所を発表してください。</target>
        </trans-unit>
        <trans-unit id="7d0867bfec63bbea7b4c7184ee3d3a80f6c90eb5" translate="yes" xml:space="preserve">
          <source>Some of Test::Tester's functions return arrays of these hashes, just like Test::Builder-&amp;gt;details. That is, the hash for the first test will be array element 1 (not 0). Element 0 will not be a hash it will be a string which contains any diagnostic output that came before the first test. This should usually be empty, if it's not, it means something output diagnostics before any test results showed up.</source>
          <target state="translated">Test :: Builder-&amp;gt; detailsのように、Test :: Testerの関数の一部はこれらのハッシュの配列を返します。つまり、最初のテストのハッシュは配列要素1（0ではない）になります。要素0はハッシュではなく、最初のテストの前に送信された診断出力を含む文字列になります。これは通常空である必要があります。そうでない場合は、テスト結果が表示される前に診断を出力することを意味します。</target>
        </trans-unit>
        <trans-unit id="cc5039f425d422cec80636f2fe25c7aa8c335808" translate="yes" xml:space="preserve">
          <source>Some of the books we've listed appear almost ancient in internet scale, but we've included those books because they still describe the current way of doing things. Not everything in Perl changes every day. Many of the beginner-level books, too, go over basic features and techniques that are still valid today. In general though, we try to limit this list to books published in the past five years.</source>
          <target state="translated">ここに挙げた本の中には、インターネットの規模からするとほとんど古いものもありますが、それらの本は今でも現在のやり方を説明しているので、それらの本も含めています。Perl のすべてが毎日変わるわけではありません。初心者向けの本の多くも、今日でも有効な基本的な機能やテクニックを説明しています。しかし、一般的には、このリストは過去 5 年以内に出版された本に限定するようにしています。</target>
        </trans-unit>
        <trans-unit id="ec6365cb89577ea447484ee46de59521b7dffa94" translate="yes" xml:space="preserve">
          <source>Some of the built-in functions do not act exactly as documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, and a few are not implemented at all. To avoid surprises, particularly if you have had prior exposure to Perl in other operating environments or if you intend to write code that will be portable to other environments, see &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for a reasonably definitive list of these differences.</source>
          <target state="translated">一部の組み込み関数は&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;に記載されているとおりに機能せず、一部はまったく実装されていません。特に他のオペレーティング環境でPerlを使用した経験がある場合、または他の環境に移植できるコードを作成する場合は、驚きを避けるために、&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;を参照して、これらの違いの合理的な決定リストを確認してください。</target>
        </trans-unit>
        <trans-unit id="0c8239353496c2009cfe543c3292467ce35311ef" translate="yes" xml:space="preserve">
          <source>Some of the configuration files in /etc used by the networking APIs are either missing or have the wrong names. In particular, make sure that there's either an /etc/resolv.conf or an /etc/hosts, so that gethostbyname() works, and make sure that the file /etc/proto has been renamed to /etc/protocol (NOT /etc/protocols, as used by other Unix systems). You may have to look for things like HOSTNAME and DOMAINORIGIN in the &quot;//'SYS1.TCPPARMS(TCPDATA)'&quot; PDS member in order to properly set up your /etc networking files.</source>
          <target state="translated">ネットワーク API によって使用される /etc の設定ファイルの中には、欠落していたり、間違った名前を持っていたりするものがあります。特に、gethostbyname()が動作するように /etc/resolv.conf か /etc/hosts があることを確認し、/etc/proto ファイルが /etc/protocol にリネームされていることを確認してください (他の Unix システムで使われている /etc/protocols ではありません)。HOSTNAME や DOMAINORIGIN のようなものを &quot;//'SYS1.TCPPARMS(TCPDATA)&quot; の中で探す必要があるかもしれません。etcネットワークファイルを適切に設定するためのPDSメンバー。</target>
        </trans-unit>
        <trans-unit id="1d2fcdaf6bf2b0dace2c66c8a0e3613f9f85f66f" translate="yes" xml:space="preserve">
          <source>Some of the entries in the list are marked as &quot;experimental&quot;. This means these should not generally be used. They may be removed or changed without notice. You can ask why they are experimental by sending email to &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;mailto:perl5-porters@perl.org&lt;/a&gt;.</source>
          <target state="translated">リスト内の一部のエントリは「実験的」としてマークされています。これは、これらは一般的に使用されるべきではないことを意味します。予告なしに削除または変更される場合があります。&lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;mailto：perl5-porters@perl.orgに&lt;/a&gt;電子メールを送信することで、実験的な理由を尋ねることができます。</target>
        </trans-unit>
        <trans-unit id="97b022f479803e9b4139aa894b3173d5ebd19950" translate="yes" xml:space="preserve">
          <source>Some of the examples later in &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt; use the &lt;a href=&quot;Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; module from CPAN. The reason you might choose &lt;a href=&quot;Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; over the perl built-in functions is that it works with numbers of ANY size, that it is optimized for speed on some operations, and for at least some programmers the notation might be familiar.</source>
          <target state="translated">&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4の後半&lt;/a&gt;の例のいくつかは、CPANの&lt;a href=&quot;Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt;モジュールを使用しています。perlの組み込み関数ではなく&lt;a href=&quot;Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt;を選択する理由は、任意のサイズの数値で機能し、一部の操作の速度が最適化されているためです。少なくとも一部のプログラマーにとっては、表記に慣れている可能性があります。</target>
        </trans-unit>
        <trans-unit id="c4c6dd767013c78841ab05e0e012ebcc93f26f14" translate="yes" xml:space="preserve">
          <source>Some of the examples later in &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt; use the &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; module from CPAN. The reason you might choose &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; over the perl built-in functions is that it works with numbers of ANY size, that it is optimized for speed on some operations, and for at least some programmers the notation might be familiar.</source>
          <target state="translated">後の&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4の&lt;/a&gt;いくつかの例では、CPANの&lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt;モジュールを使用しています。perl組み込み関数ではなく&lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt;を選択する理由は、任意のサイズの数値で機能し、一部の操作の速度が最適化されていること、そして少なくとも一部のプログラマーにとっては、この表記はなじみがあるかもしれないためです。</target>
        </trans-unit>
        <trans-unit id="b1b52c56fd19edbbc0804a6b9841658fb64d4030" translate="yes" xml:space="preserve">
          <source>Some of the functionality of the debugging code can be achieved using XS modules.</source>
          <target state="translated">デバッグコードの機能の一部は、XSモジュールを使って実現することができます。</target>
        </trans-unit>
        <trans-unit id="bf0e1ecb04bb221fe8c8c990742dfa2a73f01086" translate="yes" xml:space="preserve">
          <source>Some of the functionality of the debugging code can be achieved with a non-debugging perl by using XS modules:</source>
          <target state="translated">デバッグコードの機能の一部は、XSモジュールを使用することで、非デバッグ用のPerlでも実現できます。</target>
        </trans-unit>
        <trans-unit id="129d9d1e78c142ea547ff6b028cde8ebd0aadf7f" translate="yes" xml:space="preserve">
          <source>Some of the functions are called with a</source>
          <target state="translated">いくつかの関数は</target>
        </trans-unit>
        <trans-unit id="43704b45451eba3bea984abb31f94004f6ecfd41" translate="yes" xml:space="preserve">
          <source>Some of the highlights of &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;のハイライトのいくつか：</target>
        </trans-unit>
        <trans-unit id="02ba05af57929b86c26da34f7202e0310b46aa70" translate="yes" xml:space="preserve">
          <source>Some of the methods defined in &lt;code&gt;Net::FTP&lt;/code&gt; return an object which will be derived from the &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; class. See &lt;a href=&quot;Net::FTP::dataconn&quot;&gt;Net::FTP::dataconn&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;Net::FTP&lt;/code&gt; 定義されているメソッドの中には、 &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; クラスから派生するオブジェクトを返すものがあります。詳細については、&lt;a href=&quot;Net::FTP::dataconn&quot;&gt;Net :: FTP :: dataconn&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c35b9e6be7b3bf5bc03040d536fb7da8f901aae2" translate="yes" xml:space="preserve">
          <source>Some of the methods defined in &lt;code&gt;Net::FTP&lt;/code&gt; return an object which will be derived from the &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; class. See &lt;a href=&quot;ftp/dataconn&quot;&gt;Net::FTP::dataconn&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;Net::FTP&lt;/code&gt; 定義されているメソッドの一部は、 &lt;code&gt;Net::FTP::dataconn&lt;/code&gt; クラスから派生するオブジェクトを返します。詳細については、&lt;a href=&quot;ftp/dataconn&quot;&gt;Net :: FTP :: dataconn&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="085f62b2598cb482a6875006e876358d6d804f21" translate="yes" xml:space="preserve">
          <source>Some of the methods defined in &lt;code&gt;Net::FTP&lt;/code&gt; return an object which will be derived from this class. The dataconn class itself is derived from the &lt;code&gt;IO::Socket::INET&lt;/code&gt; class, so any normal IO operations can be performed. However the following methods are defined in the dataconn class and IO should be performed using these.</source>
          <target state="translated">&lt;code&gt;Net::FTP&lt;/code&gt; 定義されているメソッドのいくつかは、このクラスから派生するオブジェクトを返します。dataconnクラス自体は &lt;code&gt;IO::Socket::INET&lt;/code&gt; クラスから派生しているため、通常のIO操作を実行できます。ただし、以下のメソッドはdataconnクラスで定義されており、IOはこれらを使用して実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="fbd9bb2f70bdb8a22b7796ad4ee4aab43ab4a22a" translate="yes" xml:space="preserve">
          <source>Some of the modifiers require more explanation than given in the &lt;a href=&quot;#Overview&quot;&gt;&quot;Overview&quot;&lt;/a&gt; above.</source>
          <target state="translated">一部の修飾子には、上記の&lt;a href=&quot;#Overview&quot;&gt;「概要」に&lt;/a&gt;記載されているよりも多くの説明が必要です。</target>
        </trans-unit>
        <trans-unit id="a2754422800ffdc8654fa173c411cbbdaf9ca8a2" translate="yes" xml:space="preserve">
          <source>Some of the modules that use these libraries &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt;, &lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt;, and &lt;a href=&quot;Math::BigRat&quot;&gt;Math::BigRat&lt;/a&gt;.</source>
          <target state="translated">これらのライブラリを使用モジュールのいくつかの&lt;a href=&quot;Math::BigInt&quot;&gt;数学:: BigIntの&lt;/a&gt;、&lt;a href=&quot;Math::BigFloat&quot;&gt;数学::ビッグフロート&lt;/a&gt;、および&lt;a href=&quot;Math::BigRat&quot;&gt;数学を:: BigRat&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="312d5ef79ec3abd87646ed6a59f9c68ae862462d" translate="yes" xml:space="preserve">
          <source>Some of the most common mistakes:</source>
          <target state="translated">よくある間違いのいくつか。</target>
        </trans-unit>
        <trans-unit id="5796d9bed54a4c270451442098ed19f9f0088003" translate="yes" xml:space="preserve">
          <source>Some of the most common values are &lt;code&gt;O_RDONLY&lt;/code&gt; for opening the file in read-only mode, &lt;code&gt;O_WRONLY&lt;/code&gt; for opening the file in write-only mode, and &lt;code&gt;O_RDWR&lt;/code&gt; for opening the file in read-write mode.</source>
          <target state="translated">最も一般的な値には、ファイルを読み取り専用モードで開く場合の &lt;code&gt;O_RDONLY&lt;/code&gt; 、書き込み専用モードでファイルを開く場合の &lt;code&gt;O_WRONLY&lt;/code&gt; 、読み取り/書き込みモードでファイルを開く場合の &lt;code&gt;O_RDWR&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="d5f4367d2cd66fe5bca2400a4df459be12cf9924" translate="yes" xml:space="preserve">
          <source>Some of the parser default template files in /samples are needed in /etc. In particular be sure that you at least copy /samples/yyparse.c to /etc before running Perl's Configure. This step ensures successful extraction of EBCDIC versions of parser files such as perly.c and perly.h. This has to be done before running Configure the first time. If you failed to do so then the easiest way to re-Configure Perl is to delete your misconfigured build root and re-extract the source from the tar ball. Then you must ensure that /etc/yyparse.c is properly in place before attempting to re-run Configure.</source>
          <target state="translated">samples にあるパーサのデフォルトテンプレートファイルのいくつかは /etc に必要です。特に、Perl の Configure を実行する前に /samples/yyparse.c を /etc にコピーしてください。このステップは、perly.c や perly.h のようなパーサファイルの EBCDIC バージョンの抽出を成功させるためのものです。Configure を実行できなかった場合、Perl を再設定する最も簡単な方法は、誤って設定したビルドルートを削除して、tar ボールからソースを再抽出することです。その後、Configure を再実行する前に /etc/yyparse.c が適切に配置されていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="83c0811a95d044951ce0ba50edb2e9cd1f45c8cb" translate="yes" xml:space="preserve">
          <source>Some of the reported info, such as hex addresses, is not particularly valuable. Other information would be more useful for the typical programmer, such as line-numbers, pad-slot reuses, etc.. Given this, -newlex is not a particularly good flag-name.</source>
          <target state="translated">16進数アドレスなど、報告されている情報の中には、特に価値のあるものはありません。その他の情報は、行番号やパッドスロットの再利用など、典型的なプログラマにとってはより有用なものでしょう。これを考えると、-newlex は特に良いフラグ名ではありません。</target>
        </trans-unit>
        <trans-unit id="6116e5b7738fb6cac5aba2e6136f23c97d874e1d" translate="yes" xml:space="preserve">
          <source>Some of the standard Perl XS extensions (see &lt;a href=&quot;#HISTORY&quot;&gt;&quot;HISTORY&quot;&lt;/a&gt; are also available:</source>
          <target state="translated">標準のPerlXS拡張機能の一部（&lt;a href=&quot;#HISTORY&quot;&gt;「HISTORY」を&lt;/a&gt;参照）も利用できます。</target>
        </trans-unit>
        <trans-unit id="e2180880e97e49639996064a1f6af7e81cac534b" translate="yes" xml:space="preserve">
          <source>Some of the standard Perl libraries are included, but not all: see &lt;a href=&quot;#HISTORY&quot;&gt;&quot;HISTORY&quot;&lt;/a&gt; or</source>
          <target state="translated">標準のPerlライブラリの一部が含まれていますが、すべてではありません。&lt;a href=&quot;#HISTORY&quot;&gt;「HISTORY」&lt;/a&gt;または</target>
        </trans-unit>
        <trans-unit id="2cdf99bdb0c6c762dab8d358da246b612330e8fa" translate="yes" xml:space="preserve">
          <source>Some of these are also deprecated. You can exclude these from your compiled Perl by adding this option to Configure: &lt;code&gt;-Accflags='-DNO_MATHOMS'&lt;/code&gt;</source>
          <target state="translated">これらの一部も非推奨です。あなたは、設定するには、このオプションを追加してコンパイルされたPerlからこれらを除外することができます &lt;code&gt;-Accflags='-DNO_MATHOMS'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d94da1d47f6dfef189dc9a92fab735da2e9c93d7" translate="yes" xml:space="preserve">
          <source>Some of these books are available as free downloads.</source>
          <target state="translated">無料でダウンロードできる本もあります。</target>
        </trans-unit>
        <trans-unit id="55b425b2a6fe515905b997d3820e2d955eabc2cf" translate="yes" xml:space="preserve">
          <source>Some of these functions also combine dynaloading semantic with the error-propagation semantic discussed above.</source>
          <target state="translated">これらの機能の中には、上述したエラープロパゲーションセマンティックとdynaloadingセマンティックを組み合わせたものもあります。</target>
        </trans-unit>
        <trans-unit id="7a3b090758880601b5c97fb9b694e1e73a3369bc" translate="yes" xml:space="preserve">
          <source>Some of these methods might be of interest to general users, as well as of interest to formatter-writers.</source>
          <target state="translated">これらのメソッドのいくつかは、フォーマッタライターにとっても、一般ユーザーにとっても興味のあるものかもしれません。</target>
        </trans-unit>
        <trans-unit id="644a8605b72e956aa183e4a65e2c5fc19e8769dc" translate="yes" xml:space="preserve">
          <source>Some of these pseudo-modules import semantics into the current block scope (like &lt;a href=&quot;strict&quot;&gt;&lt;code&gt;strict&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;integer&quot;&gt;&lt;code&gt;integer&lt;/code&gt;&lt;/a&gt;, unlike ordinary modules, which import symbols into the current package (which are effective through the end of the file).</source>
          <target state="translated">これらの疑似モジュールの一部は、セマンティクスを現在のブロックスコープにインポートします（現在のパッケージにシンボルをインポートする通常のモジュール（ファイルの最後まで有効）とは異なり、&lt;a href=&quot;strict&quot;&gt; &lt;code&gt;strict&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;integer&quot;&gt; &lt;code&gt;integer&lt;/code&gt; &lt;/a&gt;など）。</target>
        </trans-unit>
        <trans-unit id="80eb2a0ac01474685656b9eca0e98318c5698b3f" translate="yes" xml:space="preserve">
          <source>Some of these pseudo-modules import semantics into the current block scope (like &lt;code&gt;strict&lt;/code&gt; or &lt;code&gt;integer&lt;/code&gt; , unlike ordinary modules, which import symbols into the current package (which are effective through the end of the file).</source>
          <target state="translated">これらの疑似モジュールの一部は、現在のブロックスコープに意味論をインポートします（通常のモジュールとは異なり、 &lt;code&gt;strict&lt;/code&gt; または &lt;code&gt;integer&lt;/code&gt; のように、現在のパッケージにシンボルをインポートします（ファイルの最後まで有効です）。</target>
        </trans-unit>
        <trans-unit id="f69cda68e897fa9c0b4882048fc82a98372f85df" translate="yes" xml:space="preserve">
          <source>Some of these shouldn't really be called in a Perl application, and for others there are thread-safe versions of these already implemented:</source>
          <target state="translated">これらの中には、実際には Perl アプリケーションの中で呼ばれるべきではないものもありますし、すでに実装されているスレッドセーフなバージョンもあります。</target>
        </trans-unit>
        <trans-unit id="8fc82daea8e525be9f1657205fd39cc94c0720ec" translate="yes" xml:space="preserve">
          <source>Some of these specific cases are shown as examples in other answers in this section of the perlfaq.</source>
          <target state="translated">これらの具体的なケースのいくつかは、perlfaqのこのセクションの他の回答の例として示されています。</target>
        </trans-unit>
        <trans-unit id="7ac7dfacde52b03cada88bb1c11d6be2449d545b" translate="yes" xml:space="preserve">
          <source>Some of this may be confusing. Here's a handy reference to the ASCII CR and LF characters. You can print it out and stick it in your wallet.</source>
          <target state="translated">紛らわしいものもあるかもしれません。そこで便利なのがアスキーのCRとLFの文字です。印刷してお財布に貼り付けておきましょう。</target>
        </trans-unit>
        <trans-unit id="9436ec9fafb3dbaf8b6e8266e0c7a558118556b8" translate="yes" xml:space="preserve">
          <source>Some older Pod translators require paragraphs (including command paragraphs like &quot;=head2 Functions&quot;) to be separated by</source>
          <target state="translated">古いPod翻訳者の中には、段落(&quot;=head2 Functions &quot;のようなコマンド段落を含む)を</target>
        </trans-unit>
        <trans-unit id="530312ef21d84b684c5534cd434fe4d79ac602e0" translate="yes" xml:space="preserve">
          <source>Some older versions of Berkeley DB had problems with fixed length records using the RECNO file format. This problem has been fixed since version 1.85 of Berkeley DB.</source>
          <target state="translated">Berkeley DB の一部の古いバージョンでは、RECNO ファイル形式を使用した固定長レコードに問題がありました。この問題は、Berkeley DBのバージョン1.85から修正されています。</target>
        </trans-unit>
        <trans-unit id="4c2cd6192ba71ba66f15fbdbb416f6e8ad76580e" translate="yes" xml:space="preserve">
          <source>Some operating systems don't ship the CORE directory with their base perl install. To solve the problem, you likely need to install a perl development package such as perl-devel (CentOS, Fedora and other Redhat systems) or perl (Ubuntu and other Debian systems).</source>
          <target state="translated">オペレーティングシステムによっては、perl をインストールする際に CORE ディレクトリがインストールされていない場合があります。この問題を解決するには、perl-devel (CentOS,Fedora,その他の Redhat システム)や perl (Ubuntu,その他の Debian システム)などの perl 開発パッケージをインストールする必要があるでしょう。</target>
        </trans-unit>
        <trans-unit id="a0bcdb116909bbaf782dcc8531648c8104b0144b" translate="yes" xml:space="preserve">
          <source>Some operating systems have bugs in the kernel that make setuid scripts inherently insecure. Perl gives you a number of options (described in &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;) to work around such systems.</source>
          <target state="translated">一部のオペレーティングシステムにはカーネルにバグがあり、setuidスクリプトが本質的に安全ではありません。Perlには、そのようなシステムを回避するためのいくつかのオプション（&lt;a href=&quot;perlsec&quot;&gt;perlsecで&lt;/a&gt;説明）があります。</target>
        </trans-unit>
        <trans-unit id="2250e1a4559063fcac9cec7cc104374f3f26f7ef" translate="yes" xml:space="preserve">
          <source>Some operating systems may perform &lt;code&gt;IO::File::new()&lt;/code&gt; or &lt;code&gt;IO::File::open()&lt;/code&gt; on a directory without errors. This behavior is not portable and not suggested for use. Using &lt;code&gt;&lt;a href=&quot;../functions/opendir&quot;&gt;opendir()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;IO::Dir&lt;/code&gt; are suggested instead.</source>
          <target state="translated">一部のオペレーティングシステムでは、ディレクトリに対して &lt;code&gt;IO::File::new()&lt;/code&gt; または &lt;code&gt;IO::File::open()&lt;/code&gt; をエラーなしで実行できます。この動作は移植可能ではなく、使用は推奨されていません。使い方 &lt;code&gt;&lt;a href=&quot;../functions/opendir&quot;&gt;opendir()&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;IO::Dir&lt;/code&gt; 代わりに提案されています。</target>
        </trans-unit>
        <trans-unit id="69855bea0e31a33e7317d263f4ec459059c92ed3" translate="yes" xml:space="preserve">
          <source>Some operating systems may perform &lt;code&gt;IO::File::new()&lt;/code&gt; or &lt;code&gt;IO::File::open()&lt;/code&gt; on a directory without errors. This behavior is not portable and not suggested for use. Using &lt;code&gt;opendir()&lt;/code&gt; and &lt;code&gt;readdir()&lt;/code&gt; or &lt;code&gt;IO::Dir&lt;/code&gt; are suggested instead.</source>
          <target state="translated">一部のオペレーティングシステムは、エラーなしでディレクトリに対して &lt;code&gt;IO::File::new()&lt;/code&gt; または &lt;code&gt;IO::File::open()&lt;/code&gt; を実行する場合があります。この動作は移植性がなく、使用を推奨されていません。使い方 &lt;code&gt;opendir()&lt;/code&gt; と &lt;code&gt;readdir()&lt;/code&gt; または &lt;code&gt;IO::Dir&lt;/code&gt; 代わりに提案されています。</target>
        </trans-unit>
        <trans-unit id="39015af4e836c35f8e25b30fad81d0e5afdfce43" translate="yes" xml:space="preserve">
          <source>Some operations may be slower for small numbers, but are significantly faster for big numbers. Other operations are now constant (O(1), like &lt;code&gt;bneg()&lt;/code&gt; , &lt;code&gt;babs()&lt;/code&gt; etc), instead of O(N) and thus nearly always take much less time. These optimizations were done on purpose.</source>
          <target state="translated">一部の操作は、小さい数では遅くなる場合がありますが、大きい数では大幅に速くなります。他の操作はO（N）ではなく定数（ &lt;code&gt;bneg()&lt;/code&gt; 、 &lt;code&gt;babs()&lt;/code&gt; などのO（1））になり、ほとんどの場合時間がかかりません。これらの最適化は意図的に行われました。</target>
        </trans-unit>
        <trans-unit id="34443f21f05a44f91512261ff33473bdb84f64b0" translate="yes" xml:space="preserve">
          <source>Some operations may be slower for small numbers, but are significantly faster for big numbers. Other operations are now constant (O(1), like &lt;code&gt;bneg()&lt;/code&gt;, &lt;code&gt;babs()&lt;/code&gt; etc), instead of O(N) and thus nearly always take much less time. These optimizations were done on purpose.</source>
          <target state="translated">一部の操作は、小さい数の場合は遅くなりますが、大きい数の場合は大幅に速くなります。他の操作は、O（N）の代わりに一定（ &lt;code&gt;bneg()&lt;/code&gt; 、 &lt;code&gt;babs()&lt;/code&gt; などのO（1））になり、ほとんどの場合、はるかに短い時間で済みます。これらの最適化は意図的に行われました。</target>
        </trans-unit>
        <trans-unit id="6c9f3e95144e8b33a9458895d77a0f239683f515" translate="yes" xml:space="preserve">
          <source>Some operators are instead non-associative, meaning that it is a syntax error to use a sequence of those operators of the same precedence. For example, &lt;code&gt;&quot;$x .. $y .. $z&quot;&lt;/code&gt; is an error.</source>
          <target state="translated">代わりに、一部の演算子は関連付けられていません。つまり、同じ優先順位の演算子のシーケンスを使用することは構文エラーです。たとえば、 &lt;code&gt;&quot;$x .. $y .. $z&quot;&lt;/code&gt; はエラーです。</target>
        </trans-unit>
        <trans-unit id="62110d88a0d086d7fc7d0ffc86ee7f8031edd34d" translate="yes" xml:space="preserve">
          <source>Some options, in particular &lt;code&gt;-I&lt;/code&gt;, &lt;code&gt;-M&lt;/code&gt;, &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;PERL5OPT&lt;/code&gt; can interact, and the order in which they are applied is important.</source>
          <target state="translated">一部のオプション、特に &lt;code&gt;-I&lt;/code&gt; 、 &lt;code&gt;-M&lt;/code&gt; 、 &lt;code&gt;PERL5LIB&lt;/code&gt; 、および &lt;code&gt;PERL5OPT&lt;/code&gt; は相互作用でき、それらが適用される順序は重要です。</target>
        </trans-unit>
        <trans-unit id="03ecacb543bf1cb170543843116f3f4c7e881ad8" translate="yes" xml:space="preserve">
          <source>Some other (not completely debugged) situations when FP flags change include some video drivers (?), and some operations related to creation of the windows. People who code &lt;b&gt;OpenGL&lt;/b&gt; may have more experience on this.</source>
          <target state="translated">FPフラグが変更されるその他の（完全にデバッグされていない）状況には、ビデオドライバー（？）や、ウィンドウの作成に関連する操作などがあります。&lt;b&gt;OpenGL&lt;/b&gt;をコーディングする人は、これについてより多くの経験があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="377fbf88a15d635b8d6d486abdf4ac17224b10a7" translate="yes" xml:space="preserve">
          <source>Some other IO modules don't belong to the perl core but can be loaded as well if they have been installed from CPAN. You can discover which ones exist by searching for &quot;^IO::&quot; on &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt;.</source>
          <target state="translated">他のいくつかのIOモジュールはperlコアに属していませんが、CPANからインストールされている場合はロードすることもできます。&lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt;で「^ IO ::」を検索すると、存在するものを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="2d0a736269bfee7b88f6f3d6b373b941a1d11276" translate="yes" xml:space="preserve">
          <source>Some other values are treated specially for internal use and should not be depended on.</source>
          <target state="translated">他にもいくつかの値は内部使用のために特別に扱われており、依存すべきではありません。</target>
        </trans-unit>
        <trans-unit id="7424cd4ab88fb33b2270b2db7bbe8e04cad5739e" translate="yes" xml:space="preserve">
          <source>Some output formats that do allow rendering &quot;L&amp;lt;...&amp;gt;&quot; codes as hypertext, might not allow the link-text to be formatted; in that case, formatters will have to just ignore that formatting.</source>
          <target state="translated">&quot;L &amp;lt;...&amp;gt;&quot;コードをハイパーテキストとしてレンダリングできる一部の出力形式では、リンクテキストをフォーマットできない場合があります。その場合、フォーマッターはそのフォーマットを無視する必要があります。</target>
        </trans-unit>
        <trans-unit id="256ae5437abb579a53a890ac8a995ac8070fd714" translate="yes" xml:space="preserve">
          <source>Some particular limitations of note include:</source>
          <target state="translated">注意すべきいくつかの特定の制限が含まれています。</target>
        </trans-unit>
        <trans-unit id="7659015df8ed2f8e8d7c6aab66109d4919b25a40" translate="yes" xml:space="preserve">
          <source>Some particular sequences of characters are given a single name, in addition to their individual ones.</source>
          <target state="translated">いくつかの特定の文字列には、個々の文字に加えて単一の名前が付けられています。</target>
        </trans-unit>
        <trans-unit id="e1a79a974eeb026992ad7b1bb5fab50968d6932c" translate="yes" xml:space="preserve">
          <source>Some passes discussed below are performed concurrently, but because their results are the same, we consider them individually. For different quoting constructs, Perl performs different numbers of passes, from one to four, but these passes are always performed in the same order.</source>
          <target state="translated">以下で説明するいくつかのパスは同時に実行されますが、結果は同じなので、個別に検討します。異なる引用構造に対して、Perl は 1 つから 4 つまでの異なる数のパスを実行しますが、これらのパスは常に同じ順序で実行されます。</target>
        </trans-unit>
        <trans-unit id="7ae8fed66b51985370778e2e29c81e03a37d1f13" translate="yes" xml:space="preserve">
          <source>Some people get too used to writing things like:</source>
          <target state="translated">みたいなことを書くのに慣れすぎている人もいます。</target>
        </trans-unit>
        <trans-unit id="970ff42e05d0088fd549cac2a995425a1e1eba68" translate="yes" xml:space="preserve">
          <source>Some people have reported encountering &quot;Out of memory!&quot; errors while trying to build Perl using GNU make binaries. If you encounter such trouble then try to download the source code kit and build GNU make from source to eliminate any such trouble. You might also find GNU make (as well as Perl and Apache) in the red-piece/book &quot;Open Source Software for OS/390 UNIX&quot;, SG24-5944-00 from IBM.</source>
          <target state="translated">何人かの人が、GNU make のバイナリを使って Perl をビルドしようとしたときに &quot;Out of memory!&quot; エラーに遭遇したと報告しています。そのようなトラブルに遭遇した場合は、ソースコードキットをダウンロードして、ソースからGNU makeをビルドしてみてください。また、IBMのレッドピース/書籍 &quot;Open Source Software for OS/390 UNIX&quot; SG24-5944-00にGNU make (PerlやApacheと同様に)が掲載されています。</target>
        </trans-unit>
        <trans-unit id="98c7c01703d39bcc6345fdf8d617292db8f23d37" translate="yes" xml:space="preserve">
          <source>Some people may be inclined to include an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in the above XSUB, rather than letting control fall through to the end. In those situations &lt;code&gt;XSRETURN_EMPTY&lt;/code&gt; should be used, instead. This will ensure that the XSUB stack is properly adjusted. Consult &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for other &lt;code&gt;XSRETURN&lt;/code&gt; macros.</source>
          <target state="translated">一部の人々は、制御を最後まで行わせずに、上記のXSUBに明示的な &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; を含める傾向があります。そのような状況では、代わりに &lt;code&gt;XSRETURN_EMPTY&lt;/code&gt; を使用する必要があります。これにより、XSUBスタックが適切に調整されます。ご相談&lt;a href=&quot;perlapi&quot;&gt;はperlapi&lt;/a&gt;他のため &lt;code&gt;XSRETURN&lt;/code&gt; のマクロ。</target>
        </trans-unit>
        <trans-unit id="b6b8960b846f5085f978f5b96b85b0906849df57" translate="yes" xml:space="preserve">
          <source>Some people may be inclined to include an explicit &lt;code&gt;return&lt;/code&gt; in the above XSUB, rather than letting control fall through to the end. In those situations &lt;code&gt;XSRETURN_EMPTY&lt;/code&gt; should be used, instead. This will ensure that the XSUB stack is properly adjusted. Consult &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for other &lt;code&gt;XSRETURN&lt;/code&gt; macros.</source>
          <target state="translated">一部の人々は、制御を最後まで失敗させるのではなく、上記のXSUBに明示的な &lt;code&gt;return&lt;/code&gt; を含める傾向があるかもしれません。そのような状況では、代わりに &lt;code&gt;XSRETURN_EMPTY&lt;/code&gt; を使用する必要があります。これにより、XSUBスタックが適切に調整されます。他の &lt;code&gt;XSRETURN&lt;/code&gt; マクロについては、&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;に問い合わせてください。</target>
        </trans-unit>
        <trans-unit id="6b055a6a001cadf9ec7b3e638f2bc15cb8ed85e4" translate="yes" xml:space="preserve">
          <source>Some people may wish to outlaw barewords entirely. If you say</source>
          <target state="translated">裸族を完全にアウトローにしたいという人もいるでしょう。もしあなたが</target>
        </trans-unit>
        <trans-unit id="bae38a7d38c5d89eb67db6e4b702e604142997e5" translate="yes" xml:space="preserve">
          <source>Some people mistakenly regard this as a security problem. If your program does insecure things, and relies on people not knowing how to exploit those insecurities, it is not secure. It is often possible for someone to determine the insecure things and exploit them without viewing the source. Security through obscurity, the name for hiding your bugs instead of fixing them, is little security indeed.</source>
          <target state="translated">これをセキュリティの問題と勘違いしている人がいます。もしあなたのプログラムが安全ではないことをしていて、その安全ではないことを悪用する方法を知らない人に頼っているのであれば、それは安全ではありません。ソースを見なくても、誰かが安全でないことを判断し、それを悪用することが可能な場合が多いのです。曖昧さを利用したセキュリティは、バグを修正する代わりにバグを隠すための名目であり、実際にはほとんどセキュリティではありません。</target>
        </trans-unit>
        <trans-unit id="df10001a5e994bd1a3232bcb5d3f173424f0cd78" translate="yes" xml:space="preserve">
          <source>Some people need this and some people avoid it. For Perl, it&amp;rsquo;s an old way to say &lt;b&gt;I/O layer&lt;/b&gt;.</source>
          <target state="translated">これを必要とする人もいれば、避ける人もいます。Perlの場合、これは&lt;b&gt;I / Oレイヤー&lt;/b&gt;と言う古い方法です。</target>
        </trans-unit>
        <trans-unit id="37ecbcdb1f8127ee6539d97d23e8c04d2e848681" translate="yes" xml:space="preserve">
          <source>Some people regard this as a security problem. If your program does insecure things and relies on people not knowing how to exploit those insecurities, it is not secure. It is often possible for someone to determine the insecure things and exploit them without viewing the source. Security through obscurity, the name for hiding your bugs instead of fixing them, is little security indeed.</source>
          <target state="translated">これをセキュリティの問題と考える人もいます。もしあなたのプログラムが安全ではないことをしていて、その安全ではないことを悪用する方法を知らない人に頼っているのであれば、それは安全ではありません。ソースを見なくても、誰かが安全ではないことを判断し、それを悪用することが可能な場合が多いのです。不確実性を利用したセキュリティ、つまりバグを修正する代わりにバグを隠すという名のセキュリティは、実際にはほとんど安全ではありません。</target>
        </trans-unit>
        <trans-unit id="646207c2365abd1daf6b5c56b0451ba2ee5e82de" translate="yes" xml:space="preserve">
          <source>Some platforms (Win32, AIX, VMS, OS/2, to name a few) require any function that is part of the public API (the shared Perl library) to be explicitly marked as exported. See the discussion about</source>
          <target state="translated">いくつかのプラットフォーム(Win32,AIX,VMS,OS/2など)では、パブリックAPI(共有Perlライブラリ)の一部である関数は、明示的にエクスポートとしてマークされる必要があります。についての議論を参照してください。</target>
        </trans-unit>
        <trans-unit id="f71f7e49e6244b0a28baf7e54c8479e2d307382e" translate="yes" xml:space="preserve">
          <source>Some platforms can't delete or rename files held open by the system, this limitation may also apply to changing filesystem metainformation like file permissions or owners. Remember to &lt;a href=&quot;perlfunc#close-FILEHANDLE&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; files when you are done with them. Don't &lt;a href=&quot;perlfunc#unlink-LIST&quot;&gt;&lt;code&gt;unlink&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;perlfunc#rename-OLDNAME%2CNEWNAME&quot;&gt;&lt;code&gt;rename&lt;/code&gt;&lt;/a&gt; an open file. Don't &lt;a href=&quot;perlfunc#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt;&lt;code&gt;tie&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; a file already tied or opened; &lt;a href=&quot;perlfunc#untie-VARIABLE&quot;&gt;&lt;code&gt;untie&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;perlfunc#close-FILEHANDLE&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; it first.</source>
          <target state="translated">一部のプラットフォームでは、システムによって開いたままのファイルを削除または名前変更できません。この制限は、ファイルのアクセス許可や所有者などのファイルシステムのメタ情報の変更にも適用される場合があります。ファイルを使い終わったら、忘れず&lt;a href=&quot;perlfunc#close-FILEHANDLE&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;ファイルを閉じてください。開いているファイルの&lt;a href=&quot;perlfunc#unlink-LIST&quot;&gt; &lt;code&gt;unlink&lt;/code&gt; &lt;/a&gt;たり、&lt;a href=&quot;perlfunc#rename-OLDNAME%2CNEWNAME&quot;&gt; &lt;code&gt;rename&lt;/code&gt; &lt;/a&gt;したりしないでください。すでに&lt;a href=&quot;perlfunc#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt; &lt;code&gt;tie&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;perlfunc#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;いるファイルをタイまたはオープンしないでください。最初&lt;a href=&quot;perlfunc#close-FILEHANDLE&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;それを&lt;a href=&quot;perlfunc#untie-VARIABLE&quot;&gt; &lt;code&gt;untie&lt;/code&gt; &lt;/a&gt;か閉じます。</target>
        </trans-unit>
        <trans-unit id="29e0751f43cf70fa1b809101e7e4735cf3d63955" translate="yes" xml:space="preserve">
          <source>Some platforms can't delete or rename files held open by the system, this limitation may also apply to changing filesystem metainformation like file permissions or owners. Remember to &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; files when you are done with them. Don't &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename&lt;/a&gt;&lt;/code&gt; an open file. Don't &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; a file already tied or opened; &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; it first.</source>
          <target state="translated">一部のプラットフォームでは、システムによって開かれたままのファイルを削除または名前変更できません。この制限は、ファイルのアクセス許可や所有者などのファイルシステムのメタ情報の変更にも適用される場合があります。使い終わったら、必ずファイルを &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; てください。開いているファイルの &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; たり、 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename&lt;/a&gt;&lt;/code&gt; したりしないでください。既に &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; いるファイルを結合またはオープンしないでください。最初 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; それを &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; か閉じる。</target>
        </trans-unit>
        <trans-unit id="da26b78199e00ef73fdfb4bbe53a1032367ab8a7" translate="yes" xml:space="preserve">
          <source>Some platforms have a minimum thread stack size. Trying to set the stack size below this value will result in a warning, and the minimum stack size will be used.</source>
          <target state="translated">プラットフォームによっては、最小のスレッドスタックサイズが設定されているものがあります。この値以下のスタックサイズを設定しようとすると警告が表示され、最小スタックサイズが使用されます。</target>
        </trans-unit>
        <trans-unit id="bcf43713051466cf97d586bae0917d51d61ca30f" translate="yes" xml:space="preserve">
          <source>Some platforms have a minimum thread stack size. Trying to set the stack size below this value will result in the above warning, and the stack size will be set to the minimum.</source>
          <target state="translated">プラットフォームによっては、スレッドのスタックサイズの最小値が設定されているものがあります。この値以下のスタックサイズを設定しようとすると、上記の警告が表示され、スタックサイズは最小値に設定されます。</target>
        </trans-unit>
        <trans-unit id="5105a7088de9859cd20060f09ecf9b0528ad1069" translate="yes" xml:space="preserve">
          <source>Some platforms have other categories, dealing with such things as measurement units and paper sizes. None of these are used directly by Perl, but outside operations that Perl interacts with may use these. See &lt;a href=&quot;#Not-within-the-scope-of-%22use-locale%22&quot;&gt;&quot;Not within the scope of &quot;use locale&quot;&quot;&lt;/a&gt; below.</source>
          <target state="translated">一部のプラットフォームには他のカテゴリがあり、測定単位や用紙サイズなどを扱います。これらはいずれもPerlによって直接使用されることはありませんが、Perlが対話する外部操作がこれらを使用する場合があります。以下の&lt;a href=&quot;#Not-within-the-scope-of-%22use-locale%22&quot;&gt;「ロケールの使用」の範囲外を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a11c8787b6044982e680d4ae9bfff407819b6d1c" translate="yes" xml:space="preserve">
          <source>Some platforms have other categories, dealing with such things as measurement units and paper sizes. None of these are used directly by Perl, but outside operations that Perl interacts with may use these. See &lt;a href=&quot;#Not-within-the-scope-of-%22use-locale%22&quot;&gt;Not within the scope of use locale&lt;/a&gt; below.</source>
          <target state="translated">一部のプラットフォームには、測定単位や用紙サイズなどを扱う他のカテゴリがあります。これらはいずれもPerlによって直接使用されることはありませんが、Perlが対話する外部の操作はこれらを使用する場合があります。下記の「&lt;a href=&quot;#Not-within-the-scope-of-%22use-locale%22&quot;&gt;使用ロケールの範囲外&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="27d67098e269de48eafdad3480b3920c43ba2cb7" translate="yes" xml:space="preserve">
          <source>Some points to note:</source>
          <target state="translated">いくつかの注意点があります。</target>
        </trans-unit>
        <trans-unit id="4d3653fc867e65c669e5c29b359dbebb9253c5c0" translate="yes" xml:space="preserve">
          <source>Some possible reasons: your inheritance is getting confused, you've misspelled the method name, or the object is of the wrong type. Check out &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for details about any of the above cases. You may also use &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;($object)&lt;/code&gt; to find out the class &lt;code&gt;$object&lt;/code&gt; was blessed into.</source>
          <target state="translated">考えられる理由：継承が混乱している、メソッド名のスペルが間違っている、オブジェクトのタイプが間違っている。チェックアウト&lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;上記の例の任意の詳細については。また、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;($object)&lt;/code&gt; を使用して、 &lt;code&gt;$object&lt;/code&gt; が祝福されたクラスを見つけることもできます。</target>
        </trans-unit>
        <trans-unit id="290c6b9cea94cfe13fbb802d97a5a0cd78346837" translate="yes" xml:space="preserve">
          <source>Some possible reasons: your inheritance is getting confused, you've misspelled the method name, or the object is of the wrong type. Check out &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for details about any of the above cases. You may also use &lt;code&gt;print ref($object)&lt;/code&gt; to find out the class &lt;code&gt;$object&lt;/code&gt; was blessed into.</source>
          <target state="translated">いくつかの考えられる理由：継承が混乱している、メソッド名のスペルを間違えている、またはオブジェクトのタイプが間違っている。上記のケースの詳細については、&lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;を確認してください。また、 &lt;code&gt;print ref($object)&lt;/code&gt; を使用して、 &lt;code&gt;$object&lt;/code&gt; が祝福されたクラスを見つけることもできます。</target>
        </trans-unit>
        <trans-unit id="7b61ffed7b1a69179adefb6f5756bdb1cb79574b" translate="yes" xml:space="preserve">
          <source>Some pragmas are lexically scoped--typically those that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable. Others affect the current package instead, like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; , which allow you to predeclare a variables or subroutines within a particular</source>
          <target state="translated">一部のプラグマはレキシカルにスコープ指定されています。通常、 &lt;code&gt;$^H&lt;/code&gt; ヒント変数に影響するプラグマです。代わりに、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vars&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; subs&lt;/code&gt; のような他のものが現在のパッケージに影響を与えます。これにより、特定の内部の変数またはサブルーチンを事前宣言できます。</target>
        </trans-unit>
        <trans-unit id="7d87d5053d095f39938496538e49008745b231d2" translate="yes" xml:space="preserve">
          <source>Some pragmas are lexically scoped--typically those that affect the &lt;code&gt;$^H&lt;/code&gt; hints variable. Others affect the current package instead, like &lt;code&gt;use vars&lt;/code&gt; and &lt;code&gt;use subs&lt;/code&gt;, which allow you to predeclare a variables or subroutines within a particular</source>
          <target state="translated">一部のプラグマはレキシカルスコープです。通常、 &lt;code&gt;$^H&lt;/code&gt; ヒント変数に影響を与えるプラグマです。代わりに、 &lt;code&gt;use vars&lt;/code&gt; や &lt;code&gt;use subs&lt;/code&gt; を使用するなど、現在のパッケージに影響を与えるものもあります。これにより、特定の変数またはサブルーチンを事前に宣言できます。</target>
        </trans-unit>
        <trans-unit id="ca977f551e014badc60a278bfe97ad872b1a03f5" translate="yes" xml:space="preserve">
          <source>Some problem (forget which ;-)</source>
          <target state="translated">何か問題があったようです。</target>
        </trans-unit>
        <trans-unit id="747d0cb3f2eb2365d2dd72ee766a74de28620e7d" translate="yes" xml:space="preserve">
          <source>Some problems are associated with using temporary files that reside on NFS file systems and it is recommended that a local filesystem is used whenever possible. Some of the security tests will most probably fail when the temp file is not local. Additionally, be aware that the performance of I/O operations over NFS will not be as good as for a local disk.</source>
          <target state="translated">NFS ファイルシステム上に存在する一時ファイルの使用にはいくつかの問題があり、可能な限りローカルのファイルシステムを使用することをお勧めします。一時ファイルがローカルでない場合、セキュリティテストの一部は、ほとんどの場合失敗します。さらに、NFS 上での I/O 操作のパフォーマンスは、ローカルディスクの場合ほど良くないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="82690c6e6b8e4e473e3f2745d7358e432662fc95" translate="yes" xml:space="preserve">
          <source>Some processors may find that the &lt;code&gt;S&amp;lt;...&amp;gt;&lt;/code&gt; code is easiest to implement by replacing each space in the parse tree under the content of the S, with an NBSP. But note: the replacement should apply</source>
          <target state="translated">一部のプロセッサは、 &lt;code&gt;S&amp;lt;...&amp;gt;&lt;/code&gt; コードが、Sのコンテンツの下の解析ツリーの各スペースをNBSPで置き換えることにより、実装が最も簡単であることに気付く場合があります。ただし、注意：交換が適用されます。</target>
        </trans-unit>
        <trans-unit id="229ed6abc320881bbd15c4ddf8619bff82e22293" translate="yes" xml:space="preserve">
          <source>Some programmers choose to use an explicit conversion so as to leave nothing to doubt:</source>
          <target state="translated">一部のプログラマは、何も疑う余地がないように明示的な変換を使用することを選択します。</target>
        </trans-unit>
        <trans-unit id="76cff92347a8a5dd33b0b88b52afc87676bbe1d1" translate="yes" xml:space="preserve">
          <source>Some programmers may prefer to think of filehandles as objects with methods, preferring to write the last example as:</source>
          <target state="translated">プログラマーの中には、ファイルハンドルをメソッドを持つオブジェクトとして考えることを好む人もいるかもしれません。</target>
        </trans-unit>
        <trans-unit id="9293db7d23e9765c2433258535b9e48d3fd5d563" translate="yes" xml:space="preserve">
          <source>Some properties are considered obsolete by Unicode, but still available. There are several varieties of obsolescence:</source>
          <target state="translated">いくつかのプロパティは、Unicodeによって陳腐化していると考えられていますが、まだ利用可能です。陳腐化にはいくつかの種類があります。</target>
        </trans-unit>
        <trans-unit id="8e185e2d007b85b8d377436c39a0c68b4b4f4ab1" translate="yes" xml:space="preserve">
          <source>Some rare applications will need to create more than one interpreter during a session. Such an application might sporadically decide to release any resources associated with the interpreter.</source>
          <target state="translated">まれに、セッション中に複数のインタプリタを作成する必要があるアプリケーションがあります。そのようなアプリケーションは、インタプリタに関連付けられたリソースを解放するかどうかを散発的に決定するかもしれません。</target>
        </trans-unit>
        <trans-unit id="0314a7222da4e53e09e85e4d4942b044d7cacfc9" translate="yes" xml:space="preserve">
          <source>Some regular expressions use identical subpatterns in several places. Starting with Perl 5.10, it is possible to define named subpatterns in a section of the pattern so that they can be called up by name anywhere in the pattern. This syntactic pattern for this definition group is &lt;code&gt;(?(DEFINE)(?&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;i&gt;pattern&lt;/i&gt;)...)&lt;/code&gt;. An insertion of a named pattern is written as &lt;code&gt;(?&amp;amp;&lt;i&gt;name&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="translated">一部の正規表現は、いくつかの場所で同一のサブパターンを使用します。Perl 5.10以降では、パターンのセクションに名前付きサブパターンを定義して、パターン内のどこからでも名前で呼び出すことができるようにすることができます。この定義グループのこの構文パターンは &lt;code&gt;(?(DEFINE)(?&amp;lt;&lt;i&gt;name&lt;/i&gt;&amp;gt;&lt;i&gt;pattern&lt;/i&gt;)...)&lt;/code&gt; です。名前付きパターンの挿入は、 &lt;code&gt;(?&amp;amp;&lt;i&gt;name&lt;/i&gt;)&lt;/code&gt; と記述されます。</target>
        </trans-unit>
        <trans-unit id="7c5ce3e6e9260f74f3afe8318024d986a7fd16de" translate="yes" xml:space="preserve">
          <source>Some regular expressions use identical subpatterns in several places. Starting with Perl 5.10, it is possible to define named subpatterns in a section of the pattern so that they can be called up by name anywhere in the pattern. This syntactic pattern for this definition group is &lt;code&gt;(?(DEFINE)(?&amp;lt;name&amp;gt;pattern)...)&lt;/code&gt;. An insertion of a named pattern is written as &lt;code&gt;(?&amp;amp;name)&lt;/code&gt;.</source>
          <target state="translated">一部の正規表現は、いくつかの場所で同じサブパターンを使用します。Perl 5.10以降では、名前付きサブパターンをパターンのセクションに定義して、パターン内のどこからでも名前で呼び出すことができるようになりました。この定義グループの構文パターンは &lt;code&gt;(?(DEFINE)(?&amp;lt;name&amp;gt;pattern)...)&lt;/code&gt; です。名前付きパターンの挿入は、 &lt;code&gt;(?&amp;amp;name)&lt;/code&gt; として記述されます。</target>
        </trans-unit>
        <trans-unit id="58899e8b736f7c4726449bcec0f3b25df5fc7632" translate="yes" xml:space="preserve">
          <source>Some routines (&lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; ) return true or false, while others (&lt;code&gt;bcmp()&lt;/code&gt; , &lt;code&gt;bacmp()&lt;/code&gt; ) return either undef, &amp;lt;0, 0 or &amp;gt;0 and are suited for sort.</source>
          <target state="translated">一部のルーチン（ &lt;code&gt;is_odd()&lt;/code&gt; 、 &lt;code&gt;is_even()&lt;/code&gt; 、 &lt;code&gt;is_zero()&lt;/code&gt; 、 &lt;code&gt;is_one()&lt;/code&gt; 、 &lt;code&gt;is_nan()&lt;/code&gt; ）はtrueまたはfalseを返し、他の &lt;code&gt;bcmp()&lt;/code&gt; 、 &lt;code&gt;bacmp()&lt;/code&gt; ）はundef、&amp;lt;0、0または&amp;gt; 0を返しますソートに適しています。</target>
        </trans-unit>
        <trans-unit id="834cc437cec84afae22c004e80ee3d6149cb6f55" translate="yes" xml:space="preserve">
          <source>Some routines (&lt;code&gt;is_odd()&lt;/code&gt; , &lt;code&gt;is_even()&lt;/code&gt; , &lt;code&gt;is_zero()&lt;/code&gt; , &lt;code&gt;is_one()&lt;/code&gt; , &lt;code&gt;is_nan()&lt;/code&gt; , etc.) return true or false, while others (&lt;code&gt;bcmp()&lt;/code&gt; , &lt;code&gt;bacmp()&lt;/code&gt; ) return either undef (if NaN is involved), &amp;lt;0, 0 or &amp;gt;0 and are suited for sort.</source>
          <target state="translated">一部のルーチン（ &lt;code&gt;is_odd()&lt;/code&gt; 、 &lt;code&gt;is_even()&lt;/code&gt; 、 &lt;code&gt;is_zero()&lt;/code&gt; 、 &lt;code&gt;is_one()&lt;/code&gt; 、 &lt;code&gt;is_nan()&lt;/code&gt; など）はtrueまたはfalseを返しますが、他の &lt;code&gt;bcmp()&lt;/code&gt; 、 &lt;code&gt;bacmp()&lt;/code&gt; ）はundef（NaNが関係している場合）を返します）、&amp;lt;0、0、または&amp;gt; 0で、ソートに適しています。</target>
        </trans-unit>
        <trans-unit id="b07ef2379b9c2b49ab7fe4b04878c3104f0be76f" translate="yes" xml:space="preserve">
          <source>Some scalar variables contain more than one type of scalar data. For example, the variable &lt;code&gt;$!&lt;/code&gt; contains either the numeric value of &lt;code&gt;errno&lt;/code&gt; or its string equivalent from either &lt;code&gt;strerror&lt;/code&gt; or &lt;code&gt;sys_errlist[]&lt;/code&gt; .</source>
          <target state="translated">一部のスカラー変数には、複数のタイプのスカラーデータが含まれています。たとえば、変数 &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;errno&lt;/code&gt; の数値、または &lt;code&gt;strerror&lt;/code&gt; または &lt;code&gt;sys_errlist[]&lt;/code&gt; からの同等の文字列のいずれかが含まれます。</target>
        </trans-unit>
        <trans-unit id="293877a0e77da8a8b9fbcbcd030c4833f67c96da" translate="yes" xml:space="preserve">
          <source>Some scalar variables contain more than one type of scalar data. For example, the variable &lt;code&gt;$!&lt;/code&gt; contains either the numeric value of &lt;code&gt;errno&lt;/code&gt; or its string equivalent from either &lt;code&gt;strerror&lt;/code&gt; or &lt;code&gt;sys_errlist[]&lt;/code&gt;.</source>
          <target state="translated">一部のスカラー変数には、複数のタイプのスカラーデータが含まれています。たとえば、変数 &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;errno&lt;/code&gt; の数値、または &lt;code&gt;strerror&lt;/code&gt; または &lt;code&gt;sys_errlist[]&lt;/code&gt; いずれかから同等の文字列が含まれます。</target>
        </trans-unit>
        <trans-unit id="b802bf6a4f1848df9acbe46a4e2a4fe02ad51578" translate="yes" xml:space="preserve">
          <source>Some scripts, usually identified with a *.PL extension, are self-configuring and are able to correctly create their own shebang path from config information located in Plan 9 Perl. These you won't need to be worried about.</source>
          <target state="translated">いくつかのスクリプトは、通常 *.PL 拡張子で識別され、自己設定可能であり、Plan 9 Perl にある設定情報から独自の shebang パスを正しく作成することができます。これらは心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="0de1611bc5300339bfc467a34c6fb8f9747fd7ed" translate="yes" xml:space="preserve">
          <source>Some servers are configured to only work in passive mode. If you have one of these you can force &lt;code&gt;Net::FTP&lt;/code&gt; to always transfer in passive mode; when not going via a firewall, by setting &lt;code&gt;ftp_int_passive&lt;/code&gt; to a</source>
          <target state="translated">一部のサーバーは、パッシブモードでのみ動作するように構成されています。これらのいずれかがある場合は、 &lt;code&gt;Net::FTP&lt;/code&gt; を常にパッシブモードで転送するように強制できます。ファイアウォールを経由しない場合は、 &lt;code&gt;ftp_int_passive&lt;/code&gt; をaに設定して</target>
        </trans-unit>
        <trans-unit id="ebc3655c5b01cc226f09d2ace7c8e5f430f35ebd" translate="yes" xml:space="preserve">
          <source>Some servers do not understand this command, but issuing it and ignoring the response is harmless.</source>
          <target state="translated">このコマンドを理解していないサーバもありますが、発行してレスポンスを無視しても害はありません。</target>
        </trans-unit>
        <trans-unit id="c3d7fb888727f4ae5ed3bb068213cd5f194d2bf2" translate="yes" xml:space="preserve">
          <source>Some signals can be neither trapped nor ignored, such as the KILL and STOP (but not the TSTP) signals. Note that ignoring signals makes them disappear. If you only want them blocked temporarily without them getting lost you'll have to use POSIX' sigprocmask.</source>
          <target state="translated">信号の中には、KILL や STOP(TSTP ではなく)など、トラップも無視もできないものがあります。シグナルを無視するとシグナルが消えてしまうことに注意してください。シグナルが消えないように一時的にブロックしたいだけなら、POSIX の sigprocmask を使う必要があります。</target>
        </trans-unit>
        <trans-unit id="2b6d2a03109d9cfeb6b788931c3af13636a6e9ce" translate="yes" xml:space="preserve">
          <source>Some signals can be neither trapped nor ignored, such as the KILL and STOP (but not the TSTP) signals. Note that ignoring signals makes them disappear. If you only want them blocked temporarily without them getting lost you'll have to use the &lt;code&gt;POSIX&lt;/code&gt; module's &lt;a href=&quot;posix#sigprocmask&quot;&gt;sigprocmask&lt;/a&gt;.</source>
          <target state="translated">KILLおよびSTOP（TSTPではない）信号など、一部の信号はトラップも無視もできません。信号を無視すると、信号が消えることに注意してください。それらが失われることなく一時的にブロックしたいだけの場合は、 &lt;code&gt;POSIX&lt;/code&gt; モジュールの&lt;a href=&quot;posix#sigprocmask&quot;&gt;sigprocmask&lt;/a&gt;を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="2bcba60d06f3c08a852e1ccedb100d4bd2f6af23" translate="yes" xml:space="preserve">
          <source>Some simple style guidelines</source>
          <target state="translated">いくつかのシンプルなスタイルのガイドライン</target>
        </trans-unit>
        <trans-unit id="0a3063c3a46746b861b03ccbf2777db3ca544d44" translate="yes" xml:space="preserve">
          <source>Some simple tricks for determining if you are running on an EBCDIC platform could include any of the following (perhaps all):</source>
          <target state="translated">EBCDICプラットフォーム上で動作しているかどうかを判断するための簡単なトリックには、以下のいずれか(おそらくすべて)が含まれている可能性があります。</target>
        </trans-unit>
        <trans-unit id="3f3c0a1f0f425bdd141982a9f345d9ad53284159" translate="yes" xml:space="preserve">
          <source>Some source filters use the &lt;code&gt;DATA&lt;/code&gt; handle to read the calling program. When using these source filters you cannot rely on this handle, nor expect any particular kind of behavior when operating on it. Filters based on Filter::Util::Call (and therefore Filter::Simple) do not alter the &lt;code&gt;DATA&lt;/code&gt; filehandle, but on the other hand totally ignore the text after &lt;code&gt;__DATA__&lt;/code&gt;.</source>
          <target state="translated">一部のソースフィルターは、 &lt;code&gt;DATA&lt;/code&gt; ハンドルを使用して呼び出し側プログラムを読み取ります。これらのソースフィルターを使用する場合、このハンドルに依存することも、操作時に特定の種類の動作を期待することもできません。Filter :: Util :: Call（したがってFilter :: Simple）に基づくフィルターは、 &lt;code&gt;DATA&lt;/code&gt; ファイルハンドルを変更しませんが、一方で、 &lt;code&gt;__DATA__&lt;/code&gt; の後のテキストを完全に無視します。</target>
        </trans-unit>
        <trans-unit id="038ab8e08e45dcac2b1a2ba44edc5e7ade978952" translate="yes" xml:space="preserve">
          <source>Some source filters use the &lt;code&gt;DATA&lt;/code&gt; handle to read the calling program. When using these source filters you cannot rely on this handle, nor expect any particular kind of behavior when operating on it. Filters based on Filter::Util::Call (and therefore Filter::Simple) do not alter the &lt;code&gt;DATA&lt;/code&gt; filehandle.</source>
          <target state="translated">一部のソースフィルターは、呼び出し元のプログラムを読み取るために &lt;code&gt;DATA&lt;/code&gt; ハンドルを使用します。これらのソースフィルターを使用する場合、このハンドルに依存することも、操作するときに特定の種類の動作を期待することもできません。Filter :: Util :: Call（およびFilter :: Simple）に基づくフィルターは、 &lt;code&gt;DATA&lt;/code&gt; ファイルハンドルを変更しません。</target>
        </trans-unit>
        <trans-unit id="b1b44415edca47e18840114c042b3fbafad7d31e" translate="yes" xml:space="preserve">
          <source>Some special cases like a trailing 0x00 byte or a lone 0x1B byte are not well-defined and decode() will return an empty string for them. One possible workaround is</source>
          <target state="translated">後続の 0x00 バイトや単独の 0x1B バイトのような特殊なケースは、十分に定義されておらず、 decode()は空の文字列を返します。回避策としては、次のようなものが考えられます。</target>
        </trans-unit>
        <trans-unit id="887e76ddfe1351446ffd243bda2aac92d02dd5a3" translate="yes" xml:space="preserve">
          <source>Some subclasses that indiscriminately dump event attributes (well, except for ones beginning with &quot;~&quot;) can use this object attribute for refraining to dump the &quot;start_line&quot; attribute.</source>
          <target state="translated">イベント属性を無差別にダンプするいくつかのサブクラスは(まあ、&quot;~&quot;で始まるものを除いて)、&quot;start_line &quot;属性をダンプするのを控えるために、このオブジェクト属性を使うことができます。</target>
        </trans-unit>
        <trans-unit id="0397fafffa0394e8352d14b65804f0f4b7e0e7f0" translate="yes" xml:space="preserve">
          <source>Some switches do care if they are processed twice, for instance combinations of &lt;a href=&quot;#-l%5Boctnum%5D&quot;&gt;-l&lt;/a&gt; and &lt;a href=&quot;#-0%5Boctal%2Fhexadecimal%5D&quot;&gt;-0&lt;/a&gt;. Either put all the switches after the 32-character boundary (if applicable), or replace the use of &lt;b&gt;-0&lt;/b&gt;</source>
          <target state="translated">一部のスイッチは、たとえば&lt;a href=&quot;#-l%5Boctnum%5D&quot;&gt;-l&lt;/a&gt;と&lt;a href=&quot;#-0%5Boctal%2Fhexadecimal%5D&quot;&gt;-0の&lt;/a&gt;組み合わせなど、2回処理されても問題ありません。32文字の境界（該当する場合）の後に、すべてのスイッチを入れて、またはの使用を置き換えるのいずれか&lt;b&gt;-0&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5b3ebd295e43b2c81df8bd4b9c3baef266ee5f66" translate="yes" xml:space="preserve">
          <source>Some switches do care if they are processed twice, for instance combinations of &lt;b&gt;-l&lt;/b&gt; and &lt;b&gt;-0&lt;/b&gt;. Either put all the switches after the 32-character boundary (if applicable), or replace the use of &lt;b&gt;-0&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;-l&lt;/b&gt;と&lt;b&gt;-0の&lt;/b&gt;組み合わせなど、一部のスイッチは、2度処理されても問題ありません。すべてのスイッチを32文字の境界の後に配置するか（該当する場合）、または&lt;b&gt;-0&lt;/b&gt;の使用を置き換えます&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="109f18c999c7939dc43da5678ce045bdc21c20e9" translate="yes" xml:space="preserve">
          <source>Some systems define &lt;a href=&quot;#pipe-READHANDLE%2CWRITEHANDLE&quot;&gt;&lt;code&gt;pipe&lt;/code&gt;&lt;/a&gt; in terms of &lt;a href=&quot;#socketpair-SOCKET1%2CSOCKET2%2CDOMAIN%2CTYPE%2CPROTOCOL&quot;&gt;&lt;code&gt;socketpair&lt;/code&gt;&lt;/a&gt;, in which a call to &lt;code&gt;pipe($rdr, $wtr)&lt;/code&gt; is essentially:</source>
          <target state="translated">一部のシステムは、&lt;a href=&quot;#socketpair-SOCKET1%2CSOCKET2%2CDOMAIN%2CTYPE%2CPROTOCOL&quot;&gt; &lt;code&gt;socketpair&lt;/code&gt; の&lt;/a&gt;観点から&lt;a href=&quot;#pipe-READHANDLE%2CWRITEHANDLE&quot;&gt; &lt;code&gt;pipe&lt;/code&gt; &lt;/a&gt;を定義します。この場合、 &lt;code&gt;pipe($rdr, $wtr)&lt;/code&gt; は基本的に次のようになります。</target>
        </trans-unit>
        <trans-unit id="c346e3627bcf4ba52fad903600add2510035afb4" translate="yes" xml:space="preserve">
          <source>Some systems defined &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; in terms of &lt;code&gt;&lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt;, in which a call to &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; is essentially:</source>
          <target state="translated">定義されたいくつかのシステム &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; の点で &lt;code&gt;&lt;a href=&quot;functions/socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; にコールした、 &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; 、本質的にです。</target>
        </trans-unit>
        <trans-unit id="6fc6b04b810684b6c41fe63810499cab8b09c739" translate="yes" xml:space="preserve">
          <source>Some systems defined &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; in terms of &lt;code&gt;&lt;a href=&quot;socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt;, in which a call to &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; is essentially:</source>
          <target state="translated">定義されたいくつかのシステム &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;&lt;/code&gt; の点で &lt;code&gt;&lt;a href=&quot;socketpair&quot;&gt;socketpair&lt;/a&gt;&lt;/code&gt; にコールした、 &lt;code&gt;&lt;a href=&quot;pipe&quot;&gt;pipe&lt;/a&gt;(Rdr, Wtr)&lt;/code&gt; 、本質的にです。</target>
        </trans-unit>
        <trans-unit id="ec2cddcb7714cb3145808dbf1959d4cf532d708d" translate="yes" xml:space="preserve">
          <source>Some systems have APIs but not implementations: for example QNX and Haiku have the interval timer APIs but not the functionality.</source>
          <target state="translated">システムによっては API を持っていても実装されていないものもあります。例えば、QNX や Haiku はインターバル タイマー API を持っていますが、機能は持っていません。</target>
        </trans-unit>
        <trans-unit id="af9e4e7dc8e2d766a51ba5d183c159f4967112d1" translate="yes" xml:space="preserve">
          <source>Some systems have thread-safe versions of some of the functions, such as &lt;code&gt;getpwnam_r()&lt;/code&gt; instead of &lt;code&gt;getpwnam()&lt;/code&gt;. There, Perl automatically and invisibly substitutes the thread-safe version, without notice. This means that code that safely runs on some systems can fail on others that lack the thread-safe versions.</source>
          <target state="translated">一部のシステムには、 &lt;code&gt;getpwnam_r()&lt;/code&gt; 代わりに &lt;code&gt;getpwnam()&lt;/code&gt; など、一部の関数のスレッドセーフバージョンがあります。そこで、Perlは、通知なしに、スレッドセーフバージョンを自動的かつ目に見えない形で置き換えます。つまり、一部のシステムで安全に実行されるコードは、スレッドセーフバージョンがない他のシステムでは失敗する可能性があります。</target>
        </trans-unit>
        <trans-unit id="f1b5dcc57517fdbe334dfa953d44b8287e96b48c" translate="yes" xml:space="preserve">
          <source>Some systems may have even weirder byte orders such as</source>
          <target state="translated">システムによっては、以下のようなさらに奇妙なバイトオーダーを持つ場合があります。</target>
        </trans-unit>
        <trans-unit id="6223cb44b81823af78522ece7689e7171de5236a" translate="yes" xml:space="preserve">
          <source>Some systems use CONFORMING TO to note conformance to relevant standards and MT-LEVEL to note safeness for use in threaded programs or signal handlers. These headings are primarily useful when documenting parts of a C library.</source>
          <target state="translated">システムによっては、関連する標準への適合性を示すために CONFORMING TO を、スレッドプログラムやシグナルハンドラでの使用の安全性を示すために MT-LEVEL を使用しているものもあります。これらの見出しは、C ライブラリの一部を文書化する際に主に役立ちます。</target>
        </trans-unit>
        <trans-unit id="b5f78f639815d7596cee6bf607be57c18273af36" translate="yes" xml:space="preserve">
          <source>Some test failures may occur if you use a command shell other than the native &quot;cmd.exe&quot;, or if you are building from a path that contains spaces. So don't do that.</source>
          <target state="translated">ネイティブの「cmd.exe」以外のコマンドシェルを使用していたり、スペースを含むパスからビルドしていたりすると、テストに失敗することがあります。なので、そのようなことはしないようにしましょう。</target>
        </trans-unit>
        <trans-unit id="db2f4892c2d72b4b87094017ed92e99d93095f9c" translate="yes" xml:space="preserve">
          <source>Some test modules would replace the Test::Builder singleton instance with their own instance or subclass. This was usually done to intercept or modify results as they happened.</source>
          <target state="translated">いくつかのテストモジュールでは、Test::Builder のシングルトンインスタンスを独自のインスタンスやサブクラスに置き換えていました。これは通常、結果を傍受したり修正したりするために行われます。</target>
        </trans-unit>
        <trans-unit id="ec70ba84fc671de1bea2095d64f0ecee13115e62" translate="yes" xml:space="preserve">
          <source>Some tests are known to fail:</source>
          <target state="translated">失敗することが知られているテストもあります。</target>
        </trans-unit>
        <trans-unit id="6a89cc5c4b8e960cca98e5c9aef6613a37510494" translate="yes" xml:space="preserve">
          <source>Some tests depended on &lt;code&gt;$!&lt;/code&gt; and &lt;code&gt;$?&lt;/code&gt; being modified in subtle ways. A patch was applied to correct things that changed.</source>
          <target state="translated">一部のテストは &lt;code&gt;$!&lt;/code&gt; 依存していました！と &lt;code&gt;$?&lt;/code&gt; 微妙な方法で変更されています。変更されたものを修正するためにパッチが適用されました。</target>
        </trans-unit>
        <trans-unit id="75d98556687379d0793051b330180895e416a427" translate="yes" xml:space="preserve">
          <source>Some tests may complain under known circumstances.</source>
          <target state="translated">検査によっては、既知の状況下で文句を言うことがあります。</target>
        </trans-unit>
        <trans-unit id="c1340d9e04d7bf928c677a3bd6e8e8121f7021a3" translate="yes" xml:space="preserve">
          <source>Some tests may generate extra messages similar to</source>
          <target state="translated">テストによっては</target>
        </trans-unit>
        <trans-unit id="ed680f9db7c37de4a3fb02472a48fb5b299c3b28" translate="yes" xml:space="preserve">
          <source>Some tests were fragile and required base.pm to be loaded at a late stage. Test2 was loading base.pm too early. The tests were updated to fix this.</source>
          <target state="translated">いくつかのテストは壊れやすく、遅い段階で base.pm をロードする必要がありました。Test2 は base.pm のロードが早すぎました。テストはこれを修正するために更新されました。</target>
        </trans-unit>
        <trans-unit id="1d3e7fb048dd3da6c3efee2236b9f7245e42c776" translate="yes" xml:space="preserve">
          <source>Some tests were fragile, but have been fixed. The actual breakage was from the subtest comment indentation change.</source>
          <target state="translated">一部のテストで壊れやすい箇所がありましたが、修正しました。実際に壊れたのは、サブテストのコメントのインデント変更によるものでした。</target>
        </trans-unit>
        <trans-unit id="81c36c454152688ffa8f0d5944c5eae241cf584a" translate="yes" xml:space="preserve">
          <source>Some tests will be skipped because they need the fork() function:</source>
          <target state="translated">いくつかのテストは fork()関数を必要とするため、スキップされます。</target>
        </trans-unit>
        <trans-unit id="ae4dfb05b376af0b4aa8499ceeb5ad1587cfc612" translate="yes" xml:space="preserve">
          <source>Some things might not work as you expect them. Below is documented what is known to be troublesome:</source>
          <target state="translated">思ったように動かないものもあるかもしれません。以下、面倒なことがわかっていることを文書化しました。</target>
        </trans-unit>
        <trans-unit id="c22086010db6828bca64b97b121f052c5aaeaeec" translate="yes" xml:space="preserve">
          <source>Some time ago I had reports it does not work. Nowadays it is checked in the Perl test suite, so grep</source>
          <target state="translated">少し前までは動作しないという報告がありましたが、最近はPerlのテストスイートでチェックされるようになりました。最近ではPerlのテストスイートでチェックされるようになったので、 grep</target>
        </trans-unit>
        <trans-unit id="ff04f69dfe09fd05da827bf89d221c2f8cd81859" translate="yes" xml:space="preserve">
          <source>Some tools did do a good job setting these to the correct hub, but you cannot always rely on that. Use the 'hubs' facet list instead.</source>
          <target state="translated">いくつかのツールでは、これらを正しいハブに設定することができますが、必ずしもそれに頼ることはできません。代わりに'ハブ'ファセットリストを使用してください。</target>
        </trans-unit>
        <trans-unit id="e2d4257cf6ff6a8e43bd3c5319c1718bd7fb9ab6" translate="yes" xml:space="preserve">
          <source>Some type of removable media other than a floppy diskette.</source>
          <target state="translated">フロッピーディスク以外のリムーバブルメディアの一種。</target>
        </trans-unit>
        <trans-unit id="729fe9bb5c1721be7b9c47b47d38d0043a1d5be9" translate="yes" xml:space="preserve">
          <source>Some types of lvalues can be localized as well: hash and array elements and slices, conditionals (provided that their result is always localizable), and symbolic references. As for simple variables, this creates new, dynamically scoped values.</source>
          <target state="translated">いくつかのタイプのlvaluesもローカライズすることができます:ハッシュや配列の要素やスライス、条件式(それらの結果が常にローカライズ可能であることを条件とします)、そしてシンボリック参照です。単純な変数については、動的にスコープされた新しい値を作成します。</target>
        </trans-unit>
        <trans-unit id="36c279e82d37aef763f2dc425df33d302f2edc2c" translate="yes" xml:space="preserve">
          <source>Some unusual systems, such as VMS, require special filename handling in order to deal with symbolic names for files (i.e., VMS's Logical Names).</source>
          <target state="translated">VMS のようないくつかの珍しいシステムでは、ファイルのシンボリック名(すなわち VMS の論理名)を扱うために、特別なファイル名処理が必要になります。</target>
        </trans-unit>
        <trans-unit id="6a39214b093577878080cd0246589b3e208ffeb5" translate="yes" xml:space="preserve">
          <source>Some user's however may feel that the above &quot;economy of expression&quot; is not particularly readable nor consistent and may instead choose to do something more like the following:</source>
          <target state="translated">しかし、一部のユーザーは、上記の「表現の経済性」が特に読みやすくもなく、一貫性もないと感じ、代わりに以下のようなことを選択するかもしれません。</target>
        </trans-unit>
        <trans-unit id="1ad295080cd8e985d193a33706aa64c82df7132f" translate="yes" xml:space="preserve">
          <source>Some users have expressed that they think this whole mechanism of having a &quot;fail&quot; attribute at all, seems a rather pointless complication. But I want Locale::Maketext to be usable for software projects of</source>
          <target state="translated">何人かのユーザは、&quot;fail &quot;属性を持つというこの仕組みは無意味な複雑さだと思っていると表明しています。しかし、私はLocale::Maketextを、以下のようなソフトウェアプロジェクトで使えるようにしたいのです。</target>
        </trans-unit>
        <trans-unit id="7ab6d61e44a0f4b38225b697b64d41eb4c216b63" translate="yes" xml:space="preserve">
          <source>Some users may wish to encourage the use of lexically scoped variables. As an aid to catching implicit uses to package variables, which are always global, if you say</source>
          <target state="translated">ユーザによっては、語彙的にスコープされた変数の使用を奨励したいと思うかもしれません。パッケージ化された変数への暗黙の使用をキャッチするための補助として、常にグローバルである変数を</target>
        </trans-unit>
        <trans-unit id="020ce1178f605ac1782ec8459fa4fa7fd0cf745e" translate="yes" xml:space="preserve">
          <source>Some versions of &lt;code&gt;DB_File&lt;/code&gt; won't let you store data under a key of length 0. That means that if you have a function &lt;code&gt;f&lt;/code&gt; which you memoized and the cache is in a &lt;code&gt;DB_File&lt;/code&gt; database, then the value of &lt;code&gt;f()&lt;/code&gt; (&lt;code&gt;f&lt;/code&gt; called with no arguments) will not be memoized. If this is a big problem, you can supply a normalizer function that prepends &lt;code&gt;&quot;x&quot;&lt;/code&gt; to every key.</source>
          <target state="translated">一部のバージョン &lt;code&gt;DB_File&lt;/code&gt; あなたが長さ0のキーの下にデータを保存させないことをあなたは、機能している場合ことを意味し &lt;code&gt;f&lt;/code&gt; あなたがメモ化とキャッシュがでている &lt;code&gt;DB_File&lt;/code&gt; 、データベースの、値 &lt;code&gt;f()&lt;/code&gt; （ &lt;code&gt;f&lt;/code&gt; を使って呼び出さ引数なし）はメモされません。これが大きな問題である場合は、すべてのキーの前に &lt;code&gt;&quot;x&quot;&lt;/code&gt; を付加するノーマライザ関数を提供できます。</target>
        </trans-unit>
        <trans-unit id="8bb4498f94e563a623dff663cd55b4fc862752c4" translate="yes" xml:space="preserve">
          <source>Some versions of &lt;code&gt;make&lt;/code&gt; set the variable &lt;code&gt;MAKE&lt;/code&gt; . Others do not. This variable contains the string to be included in</source>
          <target state="translated">&lt;code&gt;make&lt;/code&gt; のバージョンによっては、変数 &lt;code&gt;MAKE&lt;/code&gt; を設定します。他の人はしません。この変数には、含まれる文字列が含まれています</target>
        </trans-unit>
        <trans-unit id="fd2f9dd996c82ce27f9d189fd038a8b3dc2b29cb" translate="yes" xml:space="preserve">
          <source>Some versions of &lt;code&gt;make&lt;/code&gt; set the variable &lt;code&gt;MAKE&lt;/code&gt;. Others do not. This variable contains the string to be included in</source>
          <target state="translated">&lt;code&gt;make&lt;/code&gt; の一部のバージョンでは、変数 &lt;code&gt;MAKE&lt;/code&gt; が設定されています。他の人はしません。この変数には、含まれる文字列が含まれています</target>
        </trans-unit>
        <trans-unit id="954f7aeec06323e12a6983f37a0846eca84625d3" translate="yes" xml:space="preserve">
          <source>Some versions of flock() can't lock files over a network (e.g. on NFS file systems), so you'd need to force the use of fcntl(2) when you build Perl. But even this is dubious at best. See the flock entry of &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; and the</source>
          <target state="translated">flock（）の一部のバージョンは、ネットワーク（NFSファイルシステムなど）を介してファイルをロックできないため、Perlをビルドするときにfcntl（2）の使用を強制する必要があります。しかし、これでもせいぜい怪しいです。&lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;のflockエントリと</target>
        </trans-unit>
        <trans-unit id="dd60cc6568aba712fcca69343c88a2420637338a" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is one reason why this function is deprecated. The other is that only in extremely limited circumstances should the Unicode versus native code point be of any interest to you. See &lt;a href=&quot;#utf8_to_uvuni_buf&quot;&gt;&quot;utf8_to_uvuni_buf&quot;&lt;/a&gt; for alternatives.</source>
          <target state="translated">すべてではありませんが、一部のUTF-8奇形が検出されます。実際、一部の不正な入力により、入力バッファーの終わりを超えて読み取りが行われる可能性があります。これが、この関数が非推奨になる理由の1つです。もう1つは、非常に限られた状況でのみ、Unicodeとネイティブコードのポイントに関心があるはずです。代替方法については、&lt;a href=&quot;#utf8_to_uvuni_buf&quot;&gt;「utf8_to_uvuni_buf」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d311518a6bb3b8613076ce871f73cf8cb1a1e05f" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is one reason why this function is deprecated. The other is that only in extremely limited circumstances should the Unicode versus native code point be of any interest to you. See &lt;a href=&quot;#utf8_to_uvuni_buf&quot;&gt;utf8_to_uvuni_buf&lt;/a&gt; for alternatives.</source>
          <target state="translated">すべてではありませんが、一部のUTF-8の奇形が検出されます。実際、いくつかの誤った形式の入力により、入力バッファーの終わりを超えて読み取りが発生する可能性があります。これが、この関数が廃止された理由の1つです。もう1つは、非常に限られた状況でのみ、Unicodeとネイティブコードのポイントがどのようなユーザーにとっても重要であることです。代替方法については、&lt;a href=&quot;#utf8_to_uvuni_buf&quot;&gt;utf8_to_uvuni_buf&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f0f7251754bf0f46339bfaca2d9d1483409569f4" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is why this function is deprecated. Use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;&quot;utf8_to_uvchr_buf&quot;&lt;/a&gt; instead.</source>
          <target state="translated">すべてではありませんが、一部のUTF-8奇形が検出されます。実際、一部の不正な入力により、入力バッファーの終わりを超えて読み取りが行われる可能性があるため、この関数は非推奨になります。代わりに&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;「utf8_to_uvchr_buf」を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="2fc9641c97ef26419e8b09582d42e0230f643449" translate="yes" xml:space="preserve">
          <source>Some, but not all, UTF-8 malformations are detected, and in fact, some malformed input could cause reading beyond the end of the input buffer, which is why this function is deprecated. Use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt; instead.</source>
          <target state="translated">すべてではありませんが、一部のUTF-8の奇形が検出されます。実際には、いくつかの誤った形式の入力が入力バッファーの終わりを超えて読み取りを引き起こす可能性があるため、この関数は非推奨になっています。代わりに&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="d5b99daee126bc167396885e5a173ca7e1b5727f" translate="yes" xml:space="preserve">
          <source>Some, such as &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; aren't provided because the concept does not exist within Plan 9. Others, such as some of the socket-related functions, simply haven't been written yet. Many in the latter category may be supported in the future.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; などの一部は、コンセプトがプラン9内に存在しないため提供されていません。その他の一部（ソケット関連の関数など）は、まだまだ作成されていません。後者のカテゴリの多くは、将来サポートされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="63c9382b076dd9dd8161d9b49e86f36c6b0988c1" translate="yes" xml:space="preserve">
          <source>Some, such as &lt;code&gt;chown&lt;/code&gt; and &lt;code&gt;umask&lt;/code&gt; aren't provided because the concept does not exist within Plan 9. Others, such as some of the socket-related functions, simply haven't been written yet. Many in the latter category may be supported in the future.</source>
          <target state="translated">コンセプトがプラン9内に存在しないため、 &lt;code&gt;chown&lt;/code&gt; や &lt;code&gt;umask&lt;/code&gt; などの一部は提供されていません。ソケット関連の関数の一部など、その他はまだ作成されていません。後者のカテゴリの多くは、将来サポートされる可能性があります。</target>
        </trans-unit>
        <trans-unit id="6b529d1f2a1daeac288a5dc3e3f1ad071820c7a2" translate="yes" xml:space="preserve">
          <source>Some/Module.pm</source>
          <target state="translated">Some/Module.pm</target>
        </trans-unit>
        <trans-unit id="75f6f0269318d3e6d862e35e227cdb78f8aa0076" translate="yes" xml:space="preserve">
          <source>Someone like Larry, or one of his peculiar friends. Also refers to the strange prefixes that Perl requires as noun markers on its variables.</source>
          <target state="translated">ラリーのような誰か、または彼の奇妙な友人の一人。また、Perl が変数の名詞マーカーとして要求する奇妙な接頭辞のことも指します。</target>
        </trans-unit>
        <trans-unit id="4645c18015bf5520c386fecd9f2627c0f851f491" translate="yes" xml:space="preserve">
          <source>Someone who &amp;ldquo;carries&amp;rdquo; software from one &lt;b&gt;platform&lt;/b&gt; to another. Porting programs written in platform-dependent languages such as C can be difficult work, but porting programs like Perl is very much worth the agony.</source>
          <target state="translated">ある&lt;b&gt;プラットフォーム&lt;/b&gt;から別の&lt;b&gt;プラットフォーム&lt;/b&gt;にソフトウェアを「運ぶ」人。Cなどのプラットフォームに依存する言語で記述されたプログラムの移植は困難な作業になる可能性がありますが、Perlのようなプログラムの移植は苦痛に値するものです。</target>
        </trans-unit>
        <trans-unit id="81901ca358030c454d79961747b435397961631e" translate="yes" xml:space="preserve">
          <source>Someone who breaks security on computer systems. A cracker may be a true &lt;b&gt;hacker&lt;/b&gt; or only a &lt;b&gt;script kiddie&lt;/b&gt;.</source>
          <target state="translated">コンピュータシステムのセキュリティを破る人。クラッカーは真の&lt;b&gt;ハッカー&lt;/b&gt;かもしれないし、&lt;b&gt;スクリプトのキディ&lt;/b&gt;だけかもしれない。</target>
        </trans-unit>
        <trans-unit id="1964ccb6039dfc22b78b8e0d35db2a914eb047cc" translate="yes" xml:space="preserve">
          <source>Someone who is brilliantly persistent in solving technical problems, whether these involve golfing, fighting orcs, or programming. Hacker is a neutral term, morally speaking. Good hackers are not to be confused with evil &lt;b&gt;crackers&lt;/b&gt; or clueless &lt;b&gt;script kiddies&lt;/b&gt;. If you confuse them, we will presume that you are either evil or clueless.</source>
          <target state="translated">ゴルフ、オークとの戦い、プログラミングなど、技術的な問題の解決に精通している人。ハッカーは道徳的に言えば中立的な用語です。優れたハッカーは、邪悪な&lt;b&gt;クラッカー&lt;/b&gt;や無知な&lt;b&gt;スクリプトキディ&lt;/b&gt;と混同しないでください。それらを混同する場合、私たちはあなたが邪悪であるか無知であると推定します。</target>
        </trans-unit>
        <trans-unit id="a06bdcd2151c9efce6b287181e34780a4956856f" translate="yes" xml:space="preserve">
          <source>Something &amp;ldquo;iffy&amp;rdquo;. See &lt;b&gt;Boolean context&lt;/b&gt;.</source>
          <target state="translated">何か「難しい」。&lt;b&gt;ブールコンテキストを&lt;/b&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e155f24963deb993057b4c0bc7a9a37afd51cb22" translate="yes" xml:space="preserve">
          <source>Something extra that happens when you evaluate an &lt;b&gt;expression&lt;/b&gt;. Nowadays it can refer to almost anything. For example, evaluating a simple assignment statement typically has the &amp;ldquo;side effect&amp;rdquo; of assigning a value to a variable. (And you thought assigning the value was your primary intent in the first place!) Likewise, assigning a value to the special variable &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt; ) has the side effect of forcing a flush after every &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; on the currently selected filehandle.</source>
          <target state="translated">&lt;b&gt;式&lt;/b&gt;を評価するときに発生する特別なこと。最近では、ほとんど何でも参照できます。たとえば、単純な代入ステートメントを評価すると、通常、変数に値を代入する「副作用」があります。（そして、そもそも値の割り当てが第一の目的であると考えました！）同様に、値を特殊変数 &lt;code&gt;$|&lt;/code&gt; に割り当てます。（ &lt;code&gt;$AUTOFLUSH&lt;/code&gt; ）には、現在選択されているファイルハンドルへの &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; たびにフラッシュを強制するという副作用があります。</target>
        </trans-unit>
        <trans-unit id="4a7cb9b5327bb852f44f8593a79f045c7ad57891" translate="yes" xml:space="preserve">
          <source>Something extra that happens when you evaluate an &lt;b&gt;expression&lt;/b&gt;. Nowadays it can refer to almost anything. For example, evaluating a simple assignment statement typically has the &amp;ldquo;side effect&amp;rdquo; of assigning a value to a variable. (And you thought assigning the value was your primary intent in the first place!) Likewise, assigning a value to the special variable &lt;code&gt;$|&lt;/code&gt; (&lt;code&gt;$AUTOFLUSH&lt;/code&gt;) has the side effect of forcing a flush after every &lt;code&gt;write&lt;/code&gt; or &lt;code&gt;print&lt;/code&gt; on the currently selected filehandle.</source>
          <target state="translated">&lt;b&gt;式&lt;/b&gt;を評価するときに発生する追加の何か。今日では、ほとんど何でも参照できます。たとえば、単純な代入ステートメントを評価すると、通常、変数に値を代入するという「副作用」があります。（そして、そもそも値を割り当てることがあなたの主な目的だと思っていました！）同様に、特別な変数 &lt;code&gt;$|&lt;/code&gt; 値を割り当てること （ &lt;code&gt;$AUTOFLUSH&lt;/code&gt; ）には、現在選択されているファイルハンドルへの &lt;code&gt;write&lt;/code&gt; または &lt;code&gt;print&lt;/code&gt; たびに強制的にフラッシュするという副作用があります。</target>
        </trans-unit>
        <trans-unit id="783e080adee89f0dfad650da0b7f44d322697c43" translate="yes" xml:space="preserve">
          <source>Something is rotten in the state of the program. An attributed subroutine ceased to exist between the point it was declared and the point at which its attribute handler(s) would have been called.</source>
          <target state="translated">プログラムの状態に何かが腐っています。宣言された時点と、その属性ハンドラが呼び出されたであろう時点との間に、属性付きサブルーチンが存在しなくなりました。</target>
        </trans-unit>
        <trans-unit id="9119b80c4db3125e0e5d3f36b18c5029258c49c9" translate="yes" xml:space="preserve">
          <source>Something is still amiss: consider the loop variable $cnt of the script. It was a number, not an object. We cannot make this value of type &lt;code&gt;symbolic&lt;/code&gt; , since then the loop will not terminate.</source>
          <target state="translated">まだ問題があります。スクリプトのループ変数$ cntを検討してください。それは物体ではなく、数でした。ループが終了しないため、この値を &lt;code&gt;symbolic&lt;/code&gt; 型にすることはできません。</target>
        </trans-unit>
        <trans-unit id="e0a55c1b08a5503b38a652a677cea0c95bbc3889" translate="yes" xml:space="preserve">
          <source>Something is still amiss: consider the loop variable $cnt of the script. It was a number, not an object. We cannot make this value of type &lt;code&gt;symbolic&lt;/code&gt;, since then the loop will not terminate.</source>
          <target state="translated">まだ問題があります。スクリプトのループ変数$ cntを検討してください。それは数であり、オブジェクトではありませんでした。ループが終了しないため、この型の値を &lt;code&gt;symbolic&lt;/code&gt; することはできません。</target>
        </trans-unit>
        <trans-unit id="b420f56b3a25fc6071dc9a2a0d9e492a4d5a4fac" translate="yes" xml:space="preserve">
          <source>Something like &lt;code&gt;&quot;-DHAVE_UNISTD_H&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;-DHAVE_UNISTD_H&quot;&lt;/code&gt; ようなもの</target>
        </trans-unit>
        <trans-unit id="2229723dcea531af53507e7f80155b0032f61e90" translate="yes" xml:space="preserve">
          <source>Something not owned by anybody. Perl is copyrighted and is thus</source>
          <target state="translated">誰のものでもないもの。Perlは著作権で保護されているので</target>
        </trans-unit>
        <trans-unit id="63320e06b401dd030b4898741e99304253f96385" translate="yes" xml:space="preserve">
          <source>Something of a hack but it prevents a lot of code duplication between MM_* variants.</source>
          <target state="translated">ハックのようなものですが、MM_*変種間のコードの重複を防ぐことができます。</target>
        </trans-unit>
        <trans-unit id="bbccb8a40149fe00b8fef910fa55b43eced89db6" translate="yes" xml:space="preserve">
          <source>Something similar to the offset hack is performed on AVs to enable efficient shifting and splicing off the beginning of the array; while &lt;code&gt;AvARRAY&lt;/code&gt; points to the first element in the array that is visible from Perl, &lt;code&gt;AvALLOC&lt;/code&gt; points to the real start of the C array. These are usually the same, but a &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; operation can be carried out by increasing &lt;code&gt;AvARRAY&lt;/code&gt; by one and decreasing &lt;code&gt;AvFILL&lt;/code&gt; and &lt;code&gt;AvMAX&lt;/code&gt; . Again, the location of the real start of the C array only comes into play when freeing the array. See &lt;code&gt;av_shift&lt;/code&gt; in</source>
          <target state="translated">オフセットハックと同様の処理がAVで実行され、効率的なシフトとアレイの先頭からのスプライシングが可能になります。一方 &lt;code&gt;AvARRAY&lt;/code&gt; はパール、から可視である配列の最初の要素を指し &lt;code&gt;AvALLOC&lt;/code&gt; の Cアレイの実際の開始を指します。これらは通常同じですが、 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 操作は &lt;code&gt;AvARRAY&lt;/code&gt; を1 増やし、 &lt;code&gt;AvFILL&lt;/code&gt; と &lt;code&gt;AvMAX&lt;/code&gt; を減らすことで実行できます。この場合も、C配列の実際の開始位置は、配列を解放するときにのみ有効になります。の &lt;code&gt;av_shift&lt;/code&gt; を参照してください</target>
        </trans-unit>
        <trans-unit id="d8e742452f6bb725bfab3a5c5dba5836e7b3c368" translate="yes" xml:space="preserve">
          <source>Something similar to the offset hack is performed on AVs to enable efficient shifting and splicing off the beginning of the array; while &lt;code&gt;AvARRAY&lt;/code&gt; points to the first element in the array that is visible from Perl, &lt;code&gt;AvALLOC&lt;/code&gt; points to the real start of the C array. These are usually the same, but a &lt;code&gt;shift&lt;/code&gt; operation can be carried out by increasing &lt;code&gt;AvARRAY&lt;/code&gt; by one and decreasing &lt;code&gt;AvFILL&lt;/code&gt; and &lt;code&gt;AvMAX&lt;/code&gt;. Again, the location of the real start of the C array only comes into play when freeing the array. See &lt;code&gt;av_shift&lt;/code&gt; in</source>
          <target state="translated">オフセットハックと同様のことがAVで実行され、アレイの先頭から効率的にシフトおよびスプライシングできるようにします。一方 &lt;code&gt;AvARRAY&lt;/code&gt; はパール、から可視である配列の最初の要素を指し &lt;code&gt;AvALLOC&lt;/code&gt; のCアレイの実際の開始を指します。これらは通常同じですが、 &lt;code&gt;shift&lt;/code&gt; 操作は、 &lt;code&gt;AvARRAY&lt;/code&gt; を1つ増やし、 &lt;code&gt;AvFILL&lt;/code&gt; と &lt;code&gt;AvMAX&lt;/code&gt; を減らすことで実行できます。この場合も、C配列の実際の開始位置は、配列を解放するときにのみ機能します。の &lt;code&gt;av_shift&lt;/code&gt; を参照してください</target>
        </trans-unit>
        <trans-unit id="4332fef1f22d39fca98466a0536a5b2d1aaa44ee" translate="yes" xml:space="preserve">
          <source>Something that tells your program what sort of variable you&amp;rsquo;d like. Perl doesn&amp;rsquo;t require you to declare variables, but you can use &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; to denote that you want something other than the default.</source>
          <target state="translated">プログラムにどのような変数が必要かを指示するもの。Perlでは変数を宣言する必要はありませんが &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; を使用して、デフォルト以外のものが必要であることを示すことができます。</target>
        </trans-unit>
        <trans-unit id="e3fc8d53ca8cfa587374cbbfc4c208732524185a" translate="yes" xml:space="preserve">
          <source>Something that tells your program what sort of variable you&amp;rsquo;d like. Perl doesn&amp;rsquo;t require you to declare variables, but you can use &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt;, or &lt;code&gt;state&lt;/code&gt; to denote that you want something other than the default.</source>
          <target state="translated">どのような種類の変数が必要かをプログラムに伝えるもの。Perlでは変数を宣言する必要はありませんが &lt;code&gt;my&lt;/code&gt; 、 &lt;code&gt;our&lt;/code&gt; 、または &lt;code&gt;state&lt;/code&gt; を使用して、デフォルト以外のものが必要であることを示すことができます。</target>
        </trans-unit>
        <trans-unit id="7ad3b77572daa04075d4890e62387b4b824f1955" translate="yes" xml:space="preserve">
          <source>Something to exclude, prefixed by &lt;code&gt;&quot;-&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">プレフィックス &lt;code&gt;&quot;-&quot;&lt;/code&gt; が付いた除外するもの：既存の文字プロパティ（プレフィックスが &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ）または完全修飾（パッケージ名を含む）ユーザー定義文字プロパティ。そのプロパティのすべての文字を表します。範囲の2つの16進コードポイント。または単一の16進コードポイント。</target>
        </trans-unit>
        <trans-unit id="7bf62f5d5b516cf40152d9946d4ef2a34c8991f7" translate="yes" xml:space="preserve">
          <source>Something to exclude, prefixed by &lt;code&gt;&quot;-&quot;&lt;/code&gt;: an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt;) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">除外するもの、接頭辞 &lt;code&gt;&quot;-&quot;&lt;/code&gt; ：既存の文字プロパティ（接頭辞 &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ）または完全修飾（パッケージ名を含む）ユーザー定義文字プロパティ。そのプロパティ内のすべての文字を表します。範囲の2つの16進コードポイント。または単一の16進コードポイント。</target>
        </trans-unit>
        <trans-unit id="2f7458ff984e1016174a3ccc404733830b1557d4" translate="yes" xml:space="preserve">
          <source>Something to include, prefixed by &lt;code&gt;&quot;+&quot;&lt;/code&gt; : a built-in character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">&lt;code&gt;&quot;+&quot;&lt;/code&gt; が前に付いているもの：組み込みの文字プロパティ（ &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; 前に付いている）または完全修飾（パッケージ名を含む）ユーザー定義の文字プロパティで、そのプロパティのすべての文字を表します。範囲の2つの16進コードポイント。または単一の16進コードポイント。</target>
        </trans-unit>
        <trans-unit id="bb71dc1c8ef0238d1cf6b1ff9fe27bbba1762fb7" translate="yes" xml:space="preserve">
          <source>Something to include, prefixed by &lt;code&gt;&quot;+&quot;&lt;/code&gt;: a built-in character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt;) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">接頭辞 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 付いた含めるもの：組み込みの文字プロパティ（接頭辞 &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ）または完全修飾（パッケージ名を含む）ユーザー定義の文字プロパティ。そのプロパティ内のすべての文字を表します。範囲の2つの16進コードポイント。または単一の16進コードポイント。</target>
        </trans-unit>
        <trans-unit id="691cfd6a9c9ef44b73a6c3b1fc2fc7e231422dbe" translate="yes" xml:space="preserve">
          <source>Something to intersect with, prefixed by &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, for all the characters except the characters in the property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">プロパティの文字を除くすべての文字について、 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; で始まる、交差するもの：既存の文字プロパティ（ &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ）または完全修飾（パッケージ名を含む）ユーザー定義文字プロパティ。範囲の2つの16進コードポイント。または単一の16進コードポイント。</target>
        </trans-unit>
        <trans-unit id="4e94a757edcaa7aad7a0e5c39dc75f3c74ce6898" translate="yes" xml:space="preserve">
          <source>Something to intersect with, prefixed by &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt;: an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt;) or a fully qualified (including package name) user-defined character property, for all the characters except the characters in the property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">交差するもの、接頭辞 &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; ：既存の文字プロパティ（接頭辞 &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ）または完全修飾（パッケージ名を含む）ユーザー定義文字プロパティ（プロパティ内の文字を除くすべての文字）。範囲の2つの16進コードポイント。または単一の16進コードポイント。</target>
        </trans-unit>
        <trans-unit id="6131959027de2eb65107afa87755cfdbae0af220" translate="yes" xml:space="preserve">
          <source>Something to negate, prefixed &lt;code&gt;&quot;!&quot;&lt;/code&gt; : an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">否定するもの、接頭辞 &lt;code&gt;&quot;!&quot;&lt;/code&gt; ：既存の文字プロパティ（接頭辞 &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ）または完全修飾（パッケージ名を含む）ユーザー定義文字プロパティ。そのプロパティのすべての文字を表します。範囲の2つの16進コードポイント。または単一の16進コードポイント。</target>
        </trans-unit>
        <trans-unit id="1f4e74c8c058a6efc1c6982e3f86bee213dbdf3d" translate="yes" xml:space="preserve">
          <source>Something to negate, prefixed &lt;code&gt;&quot;!&quot;&lt;/code&gt;: an existing character property (prefixed by &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt;) or a fully qualified (including package name) user-defined character property, to represent all the characters in that property; two hexadecimal code points for a range; or a single hexadecimal code point.</source>
          <target state="translated">接頭辞 &lt;code&gt;&quot;!&quot;&lt;/code&gt; 付けて否定するもの ：既存の文字プロパティ（接頭辞 &lt;code&gt;&quot;utf8::&quot;&lt;/code&gt; ）または完全修飾（パッケージ名を含む）ユーザー定義文字プロパティ。そのプロパティ内のすべての文字を表します。範囲の2つの16進コードポイント。または単一の16進コードポイント。</target>
        </trans-unit>
        <trans-unit id="b29b35d3b7e27c5736fa04a9d5a9779f7c0d02b4" translate="yes" xml:space="preserve">
          <source>Something we&amp;rsquo;d call a &lt;b&gt;metacharacter&lt;/b&gt; except that it&amp;rsquo;s a sequence of more than one character. Generally, the first character in the sequence must be a true metacharacter to get the other characters in the metasymbol to misbehave along with it.</source>
          <target state="translated">複数の文字のシーケンスであることを除いて、&lt;b&gt;メタ&lt;/b&gt;キャラクターと呼ぶもの。通常、メタシンボル内の他の文字が正しく動作しないようにするには、シーケンスの最初の文字を真のメタ文字にする必要があります。</target>
        </trans-unit>
        <trans-unit id="0939ed03ca5713b7d596d517d3a21d567b42a063" translate="yes" xml:space="preserve">
          <source>Something went horribly wrong-- the number of microseconds that cannot become negative just became negative. Maybe your compiler is broken?</source>
          <target state="translated">何かがひどく間違っていました --負になりきれないマイクロ秒の数が負になっただけです。コンパイラが壊れているのでは?</target>
        </trans-unit>
        <trans-unit id="c59ba282daa2ae9441382d6bdd1d5cbb102eba6e" translate="yes" xml:space="preserve">
          <source>Something you can see from anywhere, usually used of &lt;b&gt;variables&lt;/b&gt; and &lt;b&gt;subroutines&lt;/b&gt; that are visible everywhere in your program. In Perl, only certain special variables are truly global&amp;mdash;most variables (and all subroutines) exist only in the current &lt;b&gt;package&lt;/b&gt;. Global variables can be declared with &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;. See &amp;ldquo;Global Declarations&amp;rdquo; in Camel chapter 4, &amp;ldquo;Statements and Declarations&amp;rdquo;.</source>
          <target state="translated">どこからでも見られるもので、通常はプログラム内のどこからでも見える&lt;b&gt;変数&lt;/b&gt;や&lt;b&gt;サブルーチン&lt;/b&gt;を使用します。Perlでは、特定の特殊変数のみが真にグローバルです。ほとんどの変数（およびすべてのサブルーチン）は、現在の&lt;b&gt;パッケージに&lt;/b&gt;のみ存在し&lt;b&gt;ます&lt;/b&gt;。グローバル変数は、で宣言でき &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 。ラクダの第4章「ステートメントと宣言」の「グローバル宣言」を参照してください。</target>
        </trans-unit>
        <trans-unit id="e2c9c959fabe06831c4dbb79467f69e8f2c98312" translate="yes" xml:space="preserve">
          <source>Something you can see from anywhere, usually used of &lt;b&gt;variables&lt;/b&gt; and &lt;b&gt;subroutines&lt;/b&gt; that are visible everywhere in your program. In Perl, only certain special variables are truly global&amp;mdash;most variables (and all subroutines) exist only in the current &lt;b&gt;package&lt;/b&gt;. Global variables can be declared with &lt;code&gt;our&lt;/code&gt;. See &amp;ldquo;Global Declarations&amp;rdquo; in Camel chapter 4, &amp;ldquo;Statements and Declarations&amp;rdquo;.</source>
          <target state="translated">どこからでも見ることができるもの。通常、プログラムのどこにでも表示される&lt;b&gt;変数&lt;/b&gt;と&lt;b&gt;サブルーチン&lt;/b&gt;を使用します。Perlでは、特定の特別な変数のみが真にグローバルです。ほとんどの変数（およびすべてのサブルーチン）は、現在の&lt;b&gt;パッケージに&lt;/b&gt;のみ存在し&lt;b&gt;ます&lt;/b&gt;。グローバル変数は、で宣言でき &lt;code&gt;our&lt;/code&gt; 。Camelの第4章「ステートメントと宣言」の「グローバル宣言」を参照してください。</target>
        </trans-unit>
        <trans-unit id="07e88fa4cc64647b2e3278d50a97cb8b0618c720" translate="yes" xml:space="preserve">
          <source>Something you do for someone else to make them happy, like giving them the time of day (or of their life). On some machines, well-known services are listed by the &lt;code&gt;&lt;a href=&quot;functions/getservent&quot;&gt;getservent&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">誰かに時間（または生活）を与えるなど、誰かを幸せにするために行うこと。一部のマシンでは、既知のサービスが &lt;code&gt;&lt;a href=&quot;functions/getservent&quot;&gt;getservent&lt;/a&gt;&lt;/code&gt; 関数によってリストされます。</target>
        </trans-unit>
        <trans-unit id="3583892f6ad6941063be20d46c43faa9b54da5ee" translate="yes" xml:space="preserve">
          <source>Something you do for someone else to make them happy, like giving them the time of day (or of their life). On some machines, well-known services are listed by the &lt;code&gt;getservent&lt;/code&gt; function.</source>
          <target state="translated">他の誰かが彼らを幸せにするためにあなたがすること、例えば彼らに一日の時間（または彼らの人生）を与えること。一部のマシンでは、既知のサービスが &lt;code&gt;getservent&lt;/code&gt; 関数によってリストされます。</target>
        </trans-unit>
        <trans-unit id="ae96bed2910e868f1f0a103c503d2b55a0cc3496" translate="yes" xml:space="preserve">
          <source>Sometimes (see &lt;a href=&quot;#When-Unicode-Does-Not-Happen&quot;&gt;&quot;When Unicode Does Not Happen&quot;&lt;/a&gt; or &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot;&lt;/a&gt;) there are situations where you simply need to force a byte string into UTF-8, or vice versa. The standard module &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; can be used for this, or the low-level calls &lt;a href=&quot;utf8#Utility-functions&quot;&gt;&lt;code&gt;utf8::upgrade($bytestring)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;utf8#Utility-functions&quot;&gt;&lt;code&gt;utf8::downgrade($utf8string[, FAIL_OK])&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">場合によっては（&lt;a href=&quot;#When-Unicode-Does-Not-Happen&quot;&gt;「Unicodeが発生しない場合」&lt;/a&gt;または&lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;「「Unicodeバグ」」を&lt;/a&gt;参照）、バイト文字列をUTF-8に強制する必要がある場合や、その逆の場合があります。これには、標準モジュール&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;を使用できます。または、低レベルの呼び出し&lt;a href=&quot;utf8#Utility-functions&quot;&gt; &lt;code&gt;utf8::upgrade($bytestring)&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;utf8#Utility-functions&quot;&gt; &lt;code&gt;utf8::downgrade($utf8string[, FAIL_OK])&lt;/code&gt; &lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="457be77433ae10862116d65ca361c913afdc2edf" translate="yes" xml:space="preserve">
          <source>Sometimes (see &lt;a href=&quot;#When-Unicode-Does-Not-Happen&quot;&gt;When Unicode Does Not Happen&lt;/a&gt; or &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt;) there are situations where you simply need to force a byte string into UTF-8, or vice versa. The standard module &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; can be used for this, or the low-level calls &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::upgrade($bytestring) &lt;/a&gt; and &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::downgrade($utf8string[, FAIL_OK]) &lt;/a&gt;.</source>
          <target state="translated">ときどき（&lt;a href=&quot;#When-Unicode-Does-Not-Happen&quot;&gt;Unicodeが発生しない場合&lt;/a&gt;や&lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;Unicodeのバグを&lt;/a&gt;参照）、バイト文字列をUTF-8に強制したり、その逆を行う必要がある場合があります。標準モジュール&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;を使用するか、低レベルの呼び出し&lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: upgrade（$ bytestring）&lt;/a&gt;および&lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: downgrade（$ utf8string [、FAIL_OK]）を使用でき&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="3f608ce8dd6d68e4a0eca5a70c40d0ca13048d16" translate="yes" xml:space="preserve">
          <source>Sometimes a change affects code paths which you cannot test on the OSes which are directly available to you and it would be wise to have users on other OSes test the change before you commit it to blead.</source>
          <target state="translated">時々、変更がコードパスに影響を与えることがありますが、それはあなたが直接利用できるOSではテストできません。</target>
        </trans-unit>
        <trans-unit id="5c72f071a765fd3018bc7af5d49df36cbd9aae7b" translate="yes" xml:space="preserve">
          <source>Sometimes greed is not good. At times, we would like quantifiers to match a</source>
          <target state="translated">欲張りはよくないこともある。時には、量詞にマッチするように</target>
        </trans-unit>
        <trans-unit id="0aa27e840004256e29009bb974e009bb34e90abf" translate="yes" xml:space="preserve">
          <source>Sometimes instead of zeroing the allocated heap by using Newxz() you should consider &quot;poisoning&quot; the data. This means writing a bit pattern into it that should be illegal as pointers (and floating point numbers), and also hopefully surprising enough as integers, so that any code attempting to use the data without forethought will break sooner rather than later. Poisoning can be done using the Poison() macros, which have similar arguments to Zero():</source>
          <target state="translated">Newxz()を使って割り当てられたヒープをゼロにするのではなく、データを「ポイズニング」することを考えてみてはいかがでしょうか。これは、ポインタ (および浮動小数点数)としては違法であり、整数としては十分に驚くべきビットパターンを書き込むことを意味します。毒殺は Poison()マクロを使用して行うことができますが、これは Zero()と同様の引数を持っています。</target>
        </trans-unit>
        <trans-unit id="cae5675054ecaa30b3d68d273e86faefe7bf19e0" translate="yes" xml:space="preserve">
          <source>Sometimes it is advantageous to construct a pattern from the</source>
          <target state="translated">からパターンを構築するのが有利な場合もあります。</target>
        </trans-unit>
        <trans-unit id="fa5de12a356ae81ac7e15fb6c4fdf4f42322289c" translate="yes" xml:space="preserve">
          <source>Sometimes it may be necessary to make more than one pass over the input files. If this is the case you have several options. You can make the first pass using &lt;b&gt;Pod::Parser&lt;/b&gt; and override your methods to store the intermediate results in memory somewhere for the &lt;b&gt;end_pod()&lt;/b&gt; method to process. You could use &lt;b&gt;Pod::Parser&lt;/b&gt; for several passes with an appropriate state variable to control the operation for each pass. If your input source can't be reset to start at the beginning, you can store it in some other structure as a string or an array and have that structure implement a &lt;b&gt;getline()&lt;/b&gt; method (which is all that &lt;b&gt;parse_from_filehandle()&lt;/b&gt; uses to read input).</source>
          <target state="translated">入力ファイルを複数回パスする必要がある場合があります。この場合、いくつかのオプションがあります。&lt;b&gt;Pod :: Parser&lt;/b&gt;を使用して最初のパスを作成し、メソッドをオーバーライドして、中間結果を&lt;b&gt;end_pod（）&lt;/b&gt;メソッドが処理するメモリのどこかに格納することができます。適切な状態変数を使用して、複数のパスで&lt;b&gt;Pod :: Parser&lt;/b&gt;を使用して、各パスの操作を制御できます。入力ソースを最初から開始するようにリセットできない場合は、それを文字列または配列として他の構造体に格納し、その構造体に&lt;b&gt;getline（）&lt;/b&gt;メソッドを実装させることができます（これは、&lt;b&gt;parse_from_filehandle（）&lt;/b&gt;が読み取るために使用するすべてです&lt;b&gt;）&lt;/b&gt;入力）。</target>
        </trans-unit>
        <trans-unit id="f6006f7823a5727b8006f191fa888a2e039ea099" translate="yes" xml:space="preserve">
          <source>Sometimes minimal matching can help a lot. Imagine you'd like to match everything between &quot;foo&quot; and &quot;bar&quot;. Initially, you write something like this:</source>
          <target state="translated">時には、最小限のマッチングで済むこともあります。foo &quot;と &quot;bar &quot;の間にあるものをすべてマッチさせたいとしましょう。最初は、次のように書きます。</target>
        </trans-unit>
        <trans-unit id="7e0fb1495abd7611e5570cce2cb4d1976ffa0113" translate="yes" xml:space="preserve">
          <source>Sometimes older versions of the module you're installing live in other directories in @INC. Because Perl loads the first version of a module it finds, not the newest, you might accidentally get one of these older versions even after installing a brand new version. To delete</source>
          <target state="translated">インストールしているモジュールの古いバージョンが @INC の他のディレクトリに存在することがあります。Perl は見つけたモジュールの最初のバージョンをロードするので、真新しいバージョンをインストールした後であっても、誤ってこれらの古いバージョンの 1 つを取得してしまうことがあります。削除するには</target>
        </trans-unit>
        <trans-unit id="eb753520a2d796d4f761ee04ddf336bdbe0915a3" translate="yes" xml:space="preserve">
          <source>Sometimes ops are executed within an inner runops loop, such as tie, sort or overload code. In this case, something like</source>
          <target state="translated">時には、タイ、ソート、オーバーロードコードなど、内部のランナップスループ内で ops が実行されることがあります。この場合</target>
        </trans-unit>
        <trans-unit id="147ec757892c0aed445b0fb45a48e27c978e8a0c" translate="yes" xml:space="preserve">
          <source>Sometimes running a test under certain conditions will cause the test script to die. A certain function or method isn't implemented (such as &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; on MacOS), some resource isn't available (like a net connection) or a module isn't available. In these cases it's necessary to skip tests, or declare that they are supposed to fail but will work in the future (a todo test).</source>
          <target state="translated">特定の条件下でテストを実行すると、テストスクリプトが停止する場合があります。特定の関数またはメソッドが実装されていない（MacOSの &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; など）、一部のリソースが使用できない（ネット接続など）、またはモジュールが使用できない。これらの場合、テストをスキップするか、失敗するはずであるが将来は機能することを宣言する必要があります（todoテスト）。</target>
        </trans-unit>
        <trans-unit id="7390e59acad33d69c3848b5a344152fa281f8af4" translate="yes" xml:space="preserve">
          <source>Sometimes running a test under certain conditions will cause the test script to die. A certain function or method isn't implemented (such as &lt;code&gt;fork()&lt;/code&gt; on MacOS), some resource isn't available (like a net connection) or a module isn't available. In these cases it's necessary to skip tests, or declare that they are supposed to fail but will work in the future (a todo test).</source>
          <target state="translated">特定の条件下でテストを実行すると、テストスクリプトが停止する場合があります。特定の関数またはメソッドが実装されていない（MacOSの &lt;code&gt;fork()&lt;/code&gt; など）、一部のリソースが利用できない（ネット接続など）、またはモジュールが利用できない。このような場合、テストをスキップするか、テストが失敗するはずであるが将来は機能することを宣言する必要があります（todoテスト）。</target>
        </trans-unit>
        <trans-unit id="14a525fd22c2b653fcabe0c32c53b3975d5455dc" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::Builder test counter is incremented without it printing any test output, for example, when &lt;code&gt;current_test()&lt;/code&gt; is changed. In these cases, Test::Builder doesn't know the result of the test, so its type is 'unknown'. These details for these tests are filled in. They are considered ok, but the name and actual_ok is left &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;current_test()&lt;/code&gt; が変更された場合など、テスト出力を出力せずにTest :: Builderテストカウンターがインクリメントされることがあります。これらの場合、Test :: Builderはテストの結果を認識しないため、そのタイプは「不明」です。これらのテストの詳細が入力されています。これらは問題ないと見なされますが、名前とactual_okは &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f02b8eb27bf0ac9011c417f61209efd72c4a3f25" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::Builder test counter is incremented without it printing any test output, for example, when &lt;code&gt;current_test()&lt;/code&gt; is changed. In these cases, Test::Builder doesn't know the result of the test, so its type is 'unknown'. These details for these tests are filled in. They are considered ok, but the name and actual_ok is left &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">たとえば、 &lt;code&gt;current_test()&lt;/code&gt; が変更された場合、Test :: Builderテストカウンターがテスト出力を出力せずにインクリメントされることがあります。このような場合、Test :: Builderはテストの結果を認識しないため、そのタイプは「不明」です。これらのテストのこれらの詳細が入力されます。これらは問題ないと見なされますが、名前とactual_okは &lt;code&gt;undef&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="fd534b46a8017bb548267c02f58ed840dafad837" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::More interface isn't quite enough. Fortunately, Test::More is built on top of &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; which provides a single, unified backend for any test library to use. This means two test libraries which both use &amp;lt;Test::Builder&amp;gt; &lt;b&gt;can&lt;/b&gt; be used together in the same program&amp;gt;.</source>
          <target state="translated">Test :: Moreインターフェースでは不十分な場合があります。幸い、Test :: Moreは&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builderの&lt;/a&gt;上に構築されており、任意のテストライブラリで使用できる単一の統合されたバックエンドを提供します。これは、両方が&amp;lt;Test :: Builder&amp;gt;を使用する2つのテストライブラリを同じプログラムで一緒に使用&lt;b&gt;できることを&lt;/b&gt;意味します&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="8c117b85f5735958c8ac918f5819ede8cc1b0ef4" translate="yes" xml:space="preserve">
          <source>Sometimes the Test::More interface isn't quite enough. Fortunately, Test::More is built on top of &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; which provides a single, unified backend for any test library to use. This means two test libraries which both use &amp;lt;Test::Builder&amp;gt; &lt;b&gt;can&lt;/b&gt; be used together in the same program&amp;gt;.</source>
          <target state="translated">Test :: Moreインターフェースでは十分でない場合があります。幸い、Test :: Moreは&lt;a href=&quot;builder&quot;&gt;Test :: Builderの&lt;/a&gt;上に構築されており、使用するテストライブラリに単一の統合バックエンドを提供します。これは、両方が&amp;lt;Test :: Builder&amp;gt;を使用する2つのテストライブラリを同じプログラムで一緒に使用&lt;b&gt;できることを&lt;/b&gt;意味します。</target>
        </trans-unit>
        <trans-unit id="df8dfca3bc58e211921f51d53ab1d95cb5cb75f5" translate="yes" xml:space="preserve">
          <source>Sometimes the tests are wrong</source>
          <target state="translated">テストが間違っていることもある</target>
        </trans-unit>
        <trans-unit id="ff0436b0b7df1e2c343b73c639e499fd807b68f3" translate="yes" xml:space="preserve">
          <source>Sometimes there is some confusion about where &lt;code&gt;todo()&lt;/code&gt; should be looking for the &lt;code&gt;$TODO&lt;/code&gt; variable. If you want to be sure, tell it explicitly what $pack to use.</source>
          <target state="translated">&lt;code&gt;todo()&lt;/code&gt; が &lt;code&gt;$TODO&lt;/code&gt; 変数を探す場所について混乱が生じることがあります。確実にしたい場合は、使用する$ packを明示的に伝えます。</target>
        </trans-unit>
        <trans-unit id="399765aa05845ba02b6fea1a15de4bf746fb4a9e" translate="yes" xml:space="preserve">
          <source>Sometimes we would like our regexp to be able to match different possible words or character strings. This is accomplished by using the</source>
          <target state="translated">正規表現を使って異なる単語や文字列にマッチさせたいこともあります。これは</target>
        </trans-unit>
        <trans-unit id="c45fdfd630d6939174042d52a2669877eec8162b" translate="yes" xml:space="preserve">
          <source>Sometimes you don't want to pass the value of an array to a subroutine but rather the name of it, so that the subroutine can modify the global copy of it rather than working with a local copy. In perl you can refer to all objects of a particular name by prefixing the name with a star: &lt;code&gt;*foo&lt;/code&gt; . This is often known as a &quot;typeglob&quot;, because the star on the front can be thought of as a wildcard match for all the funny prefix characters on variables and subroutines and such.</source>
          <target state="translated">場合によっては、配列の値ではなく、その名前をサブルーチンに渡して、サブルーチンがローカルコピーを操作するのではなく、そのグローバルコピーを変更できるようにする必要があります。perlでは、名前の前にスター &lt;code&gt;*foo&lt;/code&gt; を付けることにより、特定の名前のすべてのオブジェクトを参照できます。これは、「typeglob」と呼ばれることがよくあります。これは、前面のスターが、変数やサブルーチンなどのすべての面白いプレフィックス文字のワイルドカード一致と考えることができるためです。</target>
        </trans-unit>
        <trans-unit id="5af3185bc4cb6153940818cc124ced30384d5bf0" translate="yes" xml:space="preserve">
          <source>Sometimes you don't want to pass the value of an array to a subroutine but rather the name of it, so that the subroutine can modify the global copy of it rather than working with a local copy. In perl you can refer to all objects of a particular name by prefixing the name with a star: &lt;code&gt;*foo&lt;/code&gt;. This is often known as a &quot;typeglob&quot;, because the star on the front can be thought of as a wildcard match for all the funny prefix characters on variables and subroutines and such.</source>
          <target state="translated">配列の値をサブルーチンに渡したくない場合がありますが、サブルーチンの名前を渡して、サブルーチンがローカルコピーを操作するのではなく、そのグローバルコピーを変更できるようにします。perlでは、名前の前にスター &lt;code&gt;*foo&lt;/code&gt; を付けることで、特定の名前のすべてのオブジェクトを参照できます。これは「typeglob」と呼ばれることがよくあります。これは、前面の星が、変数やサブルーチンなどのすべての面白いプレフィックス文字のワイルドカード一致と見なすことができるためです。</target>
        </trans-unit>
        <trans-unit id="fd89c56c7d1482880d960bf6dbcdba4cb33c9a40" translate="yes" xml:space="preserve">
          <source>Sometimes you have a context that is not current, and you want things to use it as the current one. In these cases you can call &lt;code&gt;$ctx-&amp;gt;do_in_context(sub { ... })&lt;/code&gt;. The codeblock will be run, and anything inside of it that looks for a context will find the one on which the method was called.</source>
          <target state="translated">現在のものではないコンテキストがあり、それを現在のものとして使用したい場合があります。このような場合、 &lt;code&gt;$ctx-&amp;gt;do_in_context(sub { ... })&lt;/code&gt; を呼び出すことができます。コードブロックが実行され、コンテキストを検索するコードブロック内のすべてのものが、メソッドが呼び出されたコードブロックを見つけます。</target>
        </trans-unit>
        <trans-unit id="3dc7c2918cdb381ad384c3d9167215ff71a8a0da" translate="yes" xml:space="preserve">
          <source>Sometimes you have to store undefined values in AVs or HVs. Although this may be a rare case, it can be tricky. That's because you're used to using &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; if you need an undefined SV.</source>
          <target state="translated">未定義の値をAVまたはHVに保存する必要がある場合があります。これはまれなケースですが、注意が必要な場合があります。これは、未定義のSVが必要な場合に &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; を使用することに慣れているためです。</target>
        </trans-unit>
        <trans-unit id="ce5b78669327a1c5203b6d6638f97e91e235e173" translate="yes" xml:space="preserve">
          <source>Sometimes you just want to say that the tests have passed. Usually the case is you've got some complicated condition that is difficult to wedge into an &lt;code&gt;ok()&lt;/code&gt; . In this case, you can simply use &lt;code&gt;pass()&lt;/code&gt; (to declare the test ok) or fail (for not ok). They are synonyms for &lt;code&gt;ok(1)&lt;/code&gt; and &lt;code&gt;ok(0)&lt;/code&gt; .</source>
          <target state="translated">時々、あなたはテストがパスしたと言いたいだけです。通常は、 &lt;code&gt;ok()&lt;/code&gt; に割り込むのが難しい複雑な条件がある場合です。この場合、単純に &lt;code&gt;pass()&lt;/code&gt; を使用して（テストをokと宣言する）、失敗する（not ok）。これらは &lt;code&gt;ok(1)&lt;/code&gt; および &lt;code&gt;ok(0)&lt;/code&gt; の同義語です。</target>
        </trans-unit>
        <trans-unit id="a82677750f0ce8e378152fcb09ef45c3dffa03dc" translate="yes" xml:space="preserve">
          <source>Sometimes you just want to say that the tests have passed. Usually the case is you've got some complicated condition that is difficult to wedge into an &lt;code&gt;ok()&lt;/code&gt;. In this case, you can simply use &lt;code&gt;pass()&lt;/code&gt; (to declare the test ok) or fail (for not ok). They are synonyms for &lt;code&gt;ok(1)&lt;/code&gt; and &lt;code&gt;ok(0)&lt;/code&gt;.</source>
          <target state="translated">テストに合格したと言いたい場合もあります。通常、 &lt;code&gt;ok()&lt;/code&gt; にくさびで留めるのが難しい複雑な状態になっている場合があります。この場合、 &lt;code&gt;pass()&lt;/code&gt; を使用して（テストを正常に宣言する）、または失敗する（正常でない場合）ことができます。これらは &lt;code&gt;ok(1)&lt;/code&gt; と &lt;code&gt;ok(0)&lt;/code&gt; の同義語です。</target>
        </trans-unit>
        <trans-unit id="99ad657b111885cfb86229225ce3dd7e07ab7571" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to truncate an already-existing file. This can be done using the &lt;code&gt;O_TRUNC&lt;/code&gt; flag. The behavior of &lt;code&gt;O_TRUNC&lt;/code&gt; with &lt;code&gt;O_RDONLY&lt;/code&gt; is undefined.</source>
          <target state="translated">既存のファイルを切り捨てたい場合があります。これは、 &lt;code&gt;O_TRUNC&lt;/code&gt; フラグを使用して行うことができます。 &lt;code&gt;O_RDONLY&lt;/code&gt; を &lt;code&gt;O_TRUNC&lt;/code&gt; したO_TRUNCの動作は定義されていません。</target>
        </trans-unit>
        <trans-unit id="d108e62bce7d546642fdcfcda3e786d8361305f7" translate="yes" xml:space="preserve">
          <source>Sometimes you may wish to leave the processes run by CPAN alone without caring about them. Because the Makefile.PL or the Build.PL sometimes contains question you're expected to answer, you can set a timer that will kill a 'perl Makefile.PL' process after the specified time in seconds.</source>
          <target state="translated">CPANで実行されているプロセスを気にせずに放っておきたいと思うことがあります。Makefile.PLやBuild.PLには回答を求められる質問が含まれていることがあるので、指定した時間後に'perl Makefile.PL'プロセスを秒単位で終了させるタイマーを設定することができます。</target>
        </trans-unit>
        <trans-unit id="c00f6f509d151b6fb1ea7605fa661bc15fbf5303" translate="yes" xml:space="preserve">
          <source>Sometimes you might really need to know the byte length of a string instead of the character length. For that use either the &lt;code&gt;Encode::encode_utf8()&lt;/code&gt; function or the &lt;code&gt;bytes&lt;/code&gt; pragma and the &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; function:</source>
          <target state="translated">文字長ではなく、文字列のバイト長を知る必要がある場合があります。そのためには、 &lt;code&gt;Encode::encode_utf8()&lt;/code&gt; 関数または &lt;code&gt;bytes&lt;/code&gt; プラグマと &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; 関数のいずれかを使用します。</target>
        </trans-unit>
        <trans-unit id="f11bb3346a94ad8679e866144b82f5a7774a030a" translate="yes" xml:space="preserve">
          <source>Sometimes you might really need to know the byte length of a string instead of the character length. For that use the &lt;code&gt;bytes&lt;/code&gt; pragma and the &lt;code&gt;length()&lt;/code&gt; function:</source>
          <target state="translated">文字の長さではなく、文字列のバイト長を本当に知る必要がある場合があります。そのためには、 &lt;code&gt;bytes&lt;/code&gt; プラグマと &lt;code&gt;length()&lt;/code&gt; 関数を使用します。</target>
        </trans-unit>
        <trans-unit id="69ca48a72c9601cef59e5c67d6f3681c75e3b061" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to build a statically linked perl although your system supports dynamic loading. In this case you may explicitly set the linktype with the invocation of the Makefile.PL or make:</source>
          <target state="translated">システムが動的な読み込みをサポートしているにもかかわらず、静的にリンクされた perl をビルドしたいことがあるかもしれません。この場合、Makefile.PLやmakeの呼び出しでリンクタイプを明示的に設定することができます。</target>
        </trans-unit>
        <trans-unit id="d30402c312d3b94f0c6f02a6509532f4e38398dd" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to display Perl scalars containing Unicode as simple ASCII (or EBCDIC) text. The following subroutine converts its argument so that Unicode characters with code points greater than 255 are displayed as &lt;code&gt;\x{...}&lt;/code&gt; , control characters (like &lt;code&gt;\n&lt;/code&gt; ) are displayed as &lt;code&gt;\x..&lt;/code&gt; , and the rest of the characters as themselves:</source>
          <target state="translated">Unicodeを含むPerlスカラーを単純なASCII（またはEBCDIC）テキストとして表示したい場合があります。次のサブルーチンは、引数を変換して、コードポイントが255より大きいUnicode文字が &lt;code&gt;\x{...}&lt;/code&gt; として表示され、制御文字（ &lt;code&gt;\n&lt;/code&gt; ）が &lt;code&gt;\x..&lt;/code&gt; として表示され、残りの文字がそのまま表示されるようにします：</target>
        </trans-unit>
        <trans-unit id="93f2d5137c1ee615f6cf1836ee85be0ea4a982af" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to display Perl scalars containing Unicode as simple ASCII (or EBCDIC) text. The following subroutine converts its argument so that Unicode characters with code points greater than 255 are displayed as &lt;code&gt;\x{...}&lt;/code&gt;, control characters (like &lt;code&gt;\n&lt;/code&gt;) are displayed as &lt;code&gt;\x..&lt;/code&gt;, and the rest of the characters as themselves:</source>
          <target state="translated">Unicodeを含むPerlスカラーを単純なASCII（またはEBCDIC）テキストとして表示したい場合があります。次のサブルーチンは、コードポイントが255より大きいUnicode文字が &lt;code&gt;\x{...}&lt;/code&gt; として表示され、制御文字（ &lt;code&gt;\n&lt;/code&gt; ）が &lt;code&gt;\x..&lt;/code&gt; として表示され、残りの文字がそれ自体として表示されるように、引数を変換します。：</target>
        </trans-unit>
        <trans-unit id="93cab2a917ae8f995aa91a73cd34dbac7106cc0f" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to provide some extra methods or subroutines to assist in making the interface between Perl and your extension simpler or easier to understand. These routines should live in the .pm file. Whether they are automatically loaded when the extension itself is loaded or only loaded when called depends on where in the .pm file the subroutine definition is placed. You can also consult &lt;a href=&quot;autoloader&quot;&gt;AutoLoader&lt;/a&gt; for an alternate way to store and load your extra subroutines.</source>
          <target state="translated">場合によっては、Perlと拡張機能との間のインターフェースをより単純または理解しやすくするために、いくつかの追加のメソッドまたはサブルーチンを提供したいことがあります。これらのルーチンは.pmファイルに存在する必要があります。拡張機能自体が読み込まれるときに自動的に読み込まれるか、呼び出されたときにのみ読み込まれるかは、.pmファイル内のどこにサブルーチン定義が配置されているかによって異なります。追加のサブルーチンを格納およびロードする別の方法については、&lt;a href=&quot;autoloader&quot;&gt;オートローダー&lt;/a&gt;を参照することもできます。</target>
        </trans-unit>
        <trans-unit id="d50f25bb7791c3200f165a11a2621c66fc26aa1f" translate="yes" xml:space="preserve">
          <source>Sometimes you need to have two and more XS files in the same package. One way to go is to put them into separate directories, but sometimes this is not the most suitable solution. The following technique allows you to put two (and more) XS files in the same directory.</source>
          <target state="translated">2つ以上のXSファイルを同じパッケージに入れる必要がある場合があります。別々のディレクトリに置くのも一つの方法ですが、これが最も適切な解決策ではないこともあります。以下の方法では、2つ以上のXSファイルを同じディレクトリに置くことができます。</target>
        </trans-unit>
        <trans-unit id="aecdaaa113e37c215923d6d01ac79b4d26b62dd7" translate="yes" xml:space="preserve">
          <source>Sometimes you need to have two and more XS files in the same package. There are three ways: &lt;code&gt;XSMULTI&lt;/code&gt;, separate directories, and bootstrapping one XS from another.</source>
          <target state="translated">同じパッケージに2つ以上のXSファイルが必要な場合があります。3つの方法があります： &lt;code&gt;XSMULTI&lt;/code&gt; 、個別のディレクトリ、およびあるXSを別のXSからブートストラップする。</target>
        </trans-unit>
        <trans-unit id="1dc76b72e97adc6a2bca89e4051260b585b27319" translate="yes" xml:space="preserve">
          <source>Sometimes you need to invoke the same subroutine repeatedly. This usually happens with a function that acts on a list of values, such as Perl's built-in sort(). You can pass a comparison function to sort(), which will then be invoked for every pair of values that needs to be compared. The first() and reduce() functions from &lt;a href=&quot;List::Util&quot;&gt;List::Util&lt;/a&gt; follow a similar pattern.</source>
          <target state="translated">同じサブルーチンを繰り返し呼び出す必要がある場合があります。これは通常、Perlの組み込みのsort（）など、値のリストに作用する関数で発生します。比較関数をsort（）に渡すことができます。これは、比較する必要のある値のペアごとに呼び出されます。&lt;a href=&quot;List::Util&quot;&gt;List :: Util&lt;/a&gt;のfirst（）関数とreduce（）関数も同様のパターンに従います。</target>
        </trans-unit>
        <trans-unit id="d84ae75a88af76cd17f4e95ee970d0624fc53ec5" translate="yes" xml:space="preserve">
          <source>Sometimes you need to invoke the same subroutine repeatedly. This usually happens with a function that acts on a list of values, such as Perl's built-in sort(). You can pass a comparison function to sort(), which will then be invoked for every pair of values that needs to be compared. The first() and reduce() functions from &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt; follow a similar pattern.</source>
          <target state="translated">同じサブルーチンを繰り返し呼び出す必要がある場合があります。これは通常、Perlの組み込みsort（）など、値のリストに作用する関数で発生します。比較関数をsort（）に渡すと、比較する必要がある値のペアごとに呼び出されます。&lt;a href=&quot;list/util&quot;&gt;List :: Util&lt;/a&gt;のfirst（）およびreduce（）関数も同様のパターンに従います。</target>
        </trans-unit>
        <trans-unit id="74631c8a306d075a7cfb9919a67e89afd99fe44c" translate="yes" xml:space="preserve">
          <source>Sometimes you really don't know how many tests were run, or it's too difficult to calculate. In which case you can leave off $number_of_tests_run.</source>
          <target state="translated">時々、本当に何回テストが実行されたかわからない場合や、計算するのが難しすぎる場合があります。その場合は $number_of_tests_run を省略することができます。</target>
        </trans-unit>
        <trans-unit id="85a6426e0300f2135b305a518e04a9c8bcb36f5b" translate="yes" xml:space="preserve">
          <source>Sometimes you should change the positions of the constant and the variable. For example, let's say you wanted to test which of many answers you were given, but in a case-insensitive way that also allows abbreviations. You can use the following technique if the strings all start with different characters or if you want to arrange the matches so that one takes precedence over another, as &lt;code&gt;&quot;SEND&quot;&lt;/code&gt; has precedence over &lt;code&gt;&quot;STOP&quot;&lt;/code&gt; here:</source>
          <target state="translated">時々、定数と変数の位置を変更する必要があります。たとえば、与えられた多くの回答のうちどれをテストしたいが、大文字と小文字を区別せずに省略形も使用できるとします。ここで &lt;code&gt;&quot;SEND&quot;&lt;/code&gt; が &lt;code&gt;&quot;STOP&quot;&lt;/code&gt; よりも優先されるため、文字列がすべて異なる文字で始まる場合、または一致を調整して一方が他方よりも優先されるようにする場合は、次の手法を使用できます。</target>
        </trans-unit>
        <trans-unit id="e295d93f5cf54bf6ebaedc8fedd1af1c66b62ba7" translate="yes" xml:space="preserve">
          <source>Sometimes you want to combine the best of hashes and arrays. For example, the command line:</source>
          <target state="translated">ハッシュと配列の長所を組み合わせたいこともあるでしょう。例えば、コマンドラインで</target>
        </trans-unit>
        <trans-unit id="eb405d6eff8a4115aee698cb0c98540a6a3fb25a" translate="yes" xml:space="preserve">
          <source>Sometimes you want to test if a module, or a list of modules, can successfully load. For example, you'll often want a first test which simply loads all the modules in the distribution to make sure they work before going on to do more complicated testing.</source>
          <target state="translated">あるモジュールやモジュールのリストが正常にロードできるかどうかをテストしたい場合があります。例えば、より複雑なテストを行う前に、ディストリビューション内のすべてのモジュールをロードして動作することを確認する最初のテストが必要になることが多いでしょう。</target>
        </trans-unit>
        <trans-unit id="39b7fbc0e51ead34509190d6590e14e10ef47adc" translate="yes" xml:space="preserve">
          <source>Sometimes, blead will move while you're building or testing your changes. When this happens, your push will be rejected with a message like this:</source>
          <target state="translated">変更をビルド中やテスト中に blead が動くことがあります。このような場合、あなたのプッシュはこのようなメッセージで拒否されます。</target>
        </trans-unit>
        <trans-unit id="ddf8f669e0c9325d3a3aabdd507e3c59589ddd67" translate="yes" xml:space="preserve">
          <source>Sometimes, for example when there are a lot of options, having a separate variable for each of them can be cumbersome. GetOptions() supports, as an alternative mechanism, storing options values in a hash.</source>
          <target state="translated">時々、例えば多くのオプションがある場合、それぞれの変数を個別に持つのは面倒なことになります。GetOptions()は、代替のメカニズムとしてオプションの値をハッシュに格納することをサポートしています。</target>
        </trans-unit>
        <trans-unit id="02fbdd8083e416b0e9b5fb808fb524ba8afb9c15" translate="yes" xml:space="preserve">
          <source>Sometimes, however, linked lists can be useful in situations where you want to &quot;shard&quot; an array so you have many small arrays instead of a single big array. You can keep arrays longer than Perl's largest array index, lock smaller arrays separately in threaded programs, reallocate less memory, or quickly insert elements in the middle of the chain.</source>
          <target state="translated">しかし、リンクされたリストは、1つの大きな配列を1つにするのではなく、多くの小さな配列を持つように配列を「シャード」したい場合に便利なこともあります。Perl の最大の配列インデックスよりも長い配列を保持したり、スレッドプログラムの中で小さな配列を別々にロックしたり、より少ないメモリを再割り当てしたり、チェーンの途中で要素を素早く挿入したりすることができます。</target>
        </trans-unit>
        <trans-unit id="97c577b8a14d559ea222f726e98e3c5c96ca2ea7" translate="yes" xml:space="preserve">
          <source>Sometimes, it can be necessary or useful to make sure that a certain function is fully loaded by AutoLoader. This is the case, for example, when you need to wrap a function to inject debugging code. It is also helpful to force early loading of code before forking to make use of copy-on-write as much as possible.</source>
          <target state="translated">時には、ある関数がAutoLoaderによって完全にロードされていることを確認することが必要であったり、有用であったりすることがあります。例えば、デバッグコードを注入するために関数をラップする必要がある場合などがそうです。また、コピーオンライトをできるだけ利用するために、フォークする前にコードを強制的に早めにロードしておくと便利です。</target>
        </trans-unit>
        <trans-unit id="135822a5181e82def02074d4f94c0948ca18c68d" translate="yes" xml:space="preserve">
          <source>Sometimes, when the extension does not convert data but just stores and retrieves it, you will be able to use the otherwise dangerous &lt;a href=&quot;encode#_utf8_on&quot;&gt;&lt;code&gt;Encode::_utf8_on()&lt;/code&gt;&lt;/a&gt; function. Let's say the popular &lt;code&gt;Foo::Bar&lt;/code&gt; extension, written in C, provides a &lt;code&gt;param&lt;/code&gt; method that lets you store and retrieve data according to these prototypes:</source>
          <target state="translated">拡張機能がデータを変換せず、データを格納および取得するだけの場合、危険な&lt;a href=&quot;encode#_utf8_on&quot;&gt; &lt;code&gt;Encode::_utf8_on()&lt;/code&gt; &lt;/a&gt;関数を使用できる場合があります。Cで書かれた人気のある &lt;code&gt;Foo::Bar&lt;/code&gt; 拡張機能が、これらのプロトタイプに従ってデータを保存および取得できるようにする &lt;code&gt;param&lt;/code&gt; メソッドを提供するとします。</target>
        </trans-unit>
        <trans-unit id="c69c69258cfab486eea48fb3f2e535b94c5ff785" translate="yes" xml:space="preserve">
          <source>Sometimes, when the extension does not convert data but just stores and retrieves it, you will be able to use the otherwise dangerous &lt;a href=&quot;encode#_utf8_on&quot;&gt;Encode::_utf8_on() &lt;/a&gt; function. Let's say the popular &lt;code&gt;Foo::Bar&lt;/code&gt; extension, written in C, provides a &lt;code&gt;param&lt;/code&gt; method that lets you store and retrieve data according to these prototypes:</source>
          <target state="translated">拡張機能がデータを変換せずに格納して取得するだけの場合は、そうでなければ危険な&lt;a href=&quot;encode#_utf8_on&quot;&gt;Encode :: _ utf8_on（）&lt;/a&gt;関数を使用できることがあります。Cで書かれた人気のある &lt;code&gt;Foo::Bar&lt;/code&gt; 拡張が、これらのプロトタイプに従ってデータを格納および取得できる &lt;code&gt;param&lt;/code&gt; メソッドを提供するとします。</target>
        </trans-unit>
        <trans-unit id="915dac0cd6a2dc4688c56bcdae8cb3044da9ebd2" translate="yes" xml:space="preserve">
          <source>Sometimes, you might not wish to extract a complete archive, just the files that are relevant to you, based on some criteria.</source>
          <target state="translated">時には、いくつかの基準に基づいて、あなたに関連するファイルだけで、完全なアーカイブを抽出したくないかもしれません。</target>
        </trans-unit>
        <trans-unit id="f51205933e073241a85c203ffa02d17e6d6be23a" translate="yes" xml:space="preserve">
          <source>Somewhat obsolete (last update in 1996), but still useful. Also try</source>
          <target state="translated">多少時代遅れになっていますが(最終更新は1996年)、まだ便利です。以下も試してみてください。</target>
        </trans-unit>
        <trans-unit id="fdb96cd07e3d9541f84e40d3e5c507a59f023fa2" translate="yes" xml:space="preserve">
          <source>Sorry, hash keys must be smaller than 2**31 bytes</source>
          <target state="translated">申し訳ありませんが、ハッシュキーは2**31バイトよりも小さくなければなりません。</target>
        </trans-unit>
        <trans-unit id="7d2c8f1aa042b04053bafd03d4559b130a601b41" translate="yes" xml:space="preserve">
          <source>Sort an array, with various options.</source>
          <target state="translated">様々なオプションで配列をソートします。</target>
        </trans-unit>
        <trans-unit id="f11b2d382bb4d1812bd22f06feccfbd16f64c011" translate="yes" xml:space="preserve">
          <source>Sort an array. Here is an example:</source>
          <target state="translated">配列をソートします。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="4d31f4a6a4ae686389ba0f01ad7435ce3ff7f965" translate="yes" xml:space="preserve">
          <source>Sort speed and memory use impacts</source>
          <target state="translated">ソート速度とメモリ使用量の影響</target>
        </trans-unit>
        <trans-unit id="669dcc90bf40cd3f0218ee9881e32132c08114cc" translate="yes" xml:space="preserve">
          <source>Sort subroutines written using &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are bound to their calling package. It is possible, but of limited interest, to define them in a different package, since the subroutine must still refer to the calling package's &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; を使用して記述されたソートサブルーチンは、それらの呼び出しパッケージにバインドされます。サブルーチンは呼び出し元のパッケージの &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; 参照する必要があるため、別のパッケージでそれらを定義することは可能ですが、関心は限られています。</target>
        </trans-unit>
        <trans-unit id="e86fa3b469953cdb9c0cfc2f27adce6dc70ff6d4" translate="yes" xml:space="preserve">
          <source>Sort your map in Unicode order.</source>
          <target state="translated">マップを Unicode 順に並べ替えます。</target>
        </trans-unit>
        <trans-unit id="ba790800e4b9f3d3512c898b0e6088f4dbb30c87" translate="yes" xml:space="preserve">
          <source>Sorting - the quicksort algorithm used in Perls before 5.8.0 to implement the sort() function is very easy to trick into misbehaving so that it consumes a lot of time. Starting from Perl 5.8.0 a different sorting algorithm, mergesort, is used by default. Mergesort cannot misbehave on any input.</source>
          <target state="translated">ソート-5.8.0 より前の Perl で sort()関数を実装するために使用されていた quicksort アルゴリズムは、非常に簡単に誤動作するように仕組まれており、多くの時間を消費します。Perl 5.8.0 からは、異なるソートアルゴリズムである mergesort がデフォルトで使用されています。mergesort はどのような入力に対しても誤動作することはありません。</target>
        </trans-unit>
        <trans-unit id="375ce09517152463f4dde67936d2c7e3cbb12301" translate="yes" xml:space="preserve">
          <source>Sorting - the quicksort algorithm used in Perls before 5.8.0 to implement the sort() function was very easy to trick into misbehaving so that it consumes a lot of time. Starting from Perl 5.8.0 a different sorting algorithm, mergesort, is used by default. Mergesort cannot misbehave on any input.</source>
          <target state="translated">ソート-5.8.0 以前の Perl で sort()関数を実装するために使用されていた quicksort アルゴリズムは、非常に簡単に誤動作するように仕組まれており、多くの時間を消費していました。Perl 5.8.0 からは、異なるソートアルゴリズムである mergesort がデフォルトで使用されています。mergesort はどのような入力に対しても誤動作することはありません。</target>
        </trans-unit>
        <trans-unit id="88a6e89fe9499560d5c7c4f0eba879f0797fcbdf" translate="yes" xml:space="preserve">
          <source>Sorts a list of strings.</source>
          <target state="translated">文字列のリストをソートします。</target>
        </trans-unit>
        <trans-unit id="89989e7858233b758069d9e36e356e32ea1f4ab9" translate="yes" xml:space="preserve">
          <source>Sounds an awful lot like a process, doesn't it? Well, it should. Threads are one of the pieces of a process. Every process has at least one thread and, up until now, every process running Perl had only one thread. With 5.8, though, you can create extra threads. We're going to show you how, when, and why.</source>
          <target state="translated">過程のように聞こえるだろ?そうだな スレッドはプロセスの一部です。すべてのプロセスは少なくとも一つのスレッドを持っており、今まではPerlを実行しているすべてのプロセスは一つのスレッドしか持っていませんでした。しかし、5.8では、追加のスレッドを作成することができます。ここでは、いつ、どのようにして、どのような理由でスレッドを作成するのかを説明します。</target>
        </trans-unit>
        <trans-unit id="7b37110e5b01350732eac4676af2611966b9ccef" translate="yes" xml:space="preserve">
          <source>Source Code</source>
          <target state="translated">ソースコード</target>
        </trans-unit>
        <trans-unit id="f0a8c7951e6c30a3c63c9dfb78486cbdf3df91af" translate="yes" xml:space="preserve">
          <source>Source Documentation</source>
          <target state="translated">ソースドキュメント</target>
        </trans-unit>
        <trans-unit id="c29ede2e39eca25683627a84bf1a76ac20119bd7" translate="yes" xml:space="preserve">
          <source>Source Filters</source>
          <target state="translated">ソースフィルタ</target>
        </trans-unit>
        <trans-unit id="ade8f2661e9afaab2f2ac27ea8394747efc3b4bf" translate="yes" xml:space="preserve">
          <source>Source Handler</source>
          <target state="translated">ソースハンドラ</target>
        </trans-unit>
        <trans-unit id="862ba12e5a4342d2fb92f862ee8e26706e1ba4d8" translate="yes" xml:space="preserve">
          <source>Source code locations, even if available, can often be missing or misleading if the compiler has e.g. inlined code. Optimizer can make matching the source code and the object code quite challenging.</source>
          <target state="translated">ソースコードの場所があったとしても、コンパイラがインラインコードなどを使用している場合、ソースコードの場所が見つからなかったり、誤解を招く可能性があります。オプティマイザは、ソースコードとオブジェクトコードのマッチングを非常に困難にします。</target>
        </trans-unit>
        <trans-unit id="145cfa7abc78d317a3cc42e7465f11df70966408" translate="yes" xml:space="preserve">
          <source>Source detection stuff added by Steve Purkis</source>
          <target state="translated">Steve Purkisによって追加されたソース検出機能</target>
        </trans-unit>
        <trans-unit id="b0272509bdb0dc4d43ea57d6e30f085a388335e1" translate="yes" xml:space="preserve">
          <source>Source documentation is created by putting POD comments into the C source, like this:</source>
          <target state="translated">ソースドキュメントは、このようにCのソースにPODコメントを入れて作成します。</target>
        </trans-unit>
        <trans-unit id="4e42a4c9cdabac1017a64b490d8e6fd830b2d27a" translate="yes" xml:space="preserve">
          <source>Source filtering is an immensely powerful feature of recent versions of Perl. It allows one to extend the language itself (e.g. the Switch module), to simplify the language (e.g. Language::Pythonesque), or to completely recast the language (e.g. Lingua::Romana::Perligata). Effectively, it allows one to use the full power of Perl as its own, recursively applied, macro language.</source>
          <target state="translated">ソースフィルタリングは、Perl の最近のバージョンでは非常に強力な機能です。これにより、言語自体を拡張したり (例:Switch モジュール)、言語を単純化したり (例:Language::Pythonesque)、言語を完全に再構築したり (例:Lingua::Romana::Perligata)することができます。実質的には、Perl の能力をフルに活用して、独自の再帰的に適用されるマクロ言語として使用することができます。</target>
        </trans-unit>
        <trans-unit id="83fa9e2aac616eaf300f336da8ba4cb15a670bf8" translate="yes" xml:space="preserve">
          <source>Source filters activated within &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; leak out into whichever</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 内でアクティブにされたソースフィルターがどちらかに漏れます</target>
        </trans-unit>
        <trans-unit id="29b60a7012567152c7f8bb1a380fa37b7673b6a3" translate="yes" xml:space="preserve">
          <source>Source filters activated within &lt;code&gt;eval&lt;/code&gt; leak out into whichever file scope is currently being compiled. To give an example with the CPAN module &lt;a href=&quot;Semi::Semicolons&quot;&gt;Semi::Semicolons&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;eval&lt;/code&gt; 内でアクティブ化されたソースフィルターは、現在コンパイルされているファイルスコープにリークします。CPANモジュール&lt;a href=&quot;Semi::Semicolons&quot;&gt;Semi :: Semicolonsの&lt;/a&gt;例を挙げます：</target>
        </trans-unit>
        <trans-unit id="800c2a6e745195ecf7cc595cd16957a9d13fb318" translate="yes" xml:space="preserve">
          <source>Source filters activated within the evaluated code apply to the code itself.</source>
          <target state="translated">評価されたコード内で有効化されたソースフィルタは、コード自体に適用されます。</target>
        </trans-unit>
        <trans-unit id="da4d1a2fe52cc093111f41dbe07243489fb88fda" translate="yes" xml:space="preserve">
          <source>Source filters apply only to byte streams</source>
          <target state="translated">ソースフィルタはバイトストリームにのみ適用されます。</target>
        </trans-unit>
        <trans-unit id="23c4984b5ea778bfe1a620b2921096dd64ef1a0a" translate="yes" xml:space="preserve">
          <source>Source filters only work on the string level, thus are highly limited in its ability to change source code on the fly. It cannot detect comments, quoted strings, heredocs, it is no replacement for a real parser. The only stable usage for source filters are encryption, compression, or the byteloader, to translate binary code back to source code.</source>
          <target state="translated">ソースフィルタは文字列レベルでしか動作しないため、ソースコードをその場で変更する能力が非常に限られています。コメントや引用された文字列、ヘアドキュメントを検出することはできませんので、本物のパーサーの代わりにはなりません。ソースフィルタの安定した利用法は、暗号化、圧縮、バイナリコードをソースコードに戻すためのバイトローダだけです。</target>
        </trans-unit>
        <trans-unit id="80de4aac92ca7a214fcac217051e36befa5aa31a" translate="yes" xml:space="preserve">
          <source>Source for Perl documentation</source>
          <target state="translated">Perl ドキュメントのソース</target>
        </trans-unit>
        <trans-unit id="6cf561fd42e8003d80556309fdb07a79bace6a7b" translate="yes" xml:space="preserve">
          <source>Source of the ISO 639-2 codes.</source>
          <target state="translated">ISO 639-2コードのソース。</target>
        </trans-unit>
        <trans-unit id="178db77b6a3b9b6df2ef880ae7bdafacae37b3c6" translate="yes" xml:space="preserve">
          <source>Source of the ISO 639-5 codes.</source>
          <target state="translated">ISO 639-5コードのソース。</target>
        </trans-unit>
        <trans-unit id="b69498a9aee25a26e6f9b5b4bc9ecc63222abc92" translate="yes" xml:space="preserve">
          <source>SourceHandler</source>
          <target state="translated">SourceHandler</target>
        </trans-unit>
        <trans-unit id="8644212c6ba60e5d4b37bed3eca56024c125205f" translate="yes" xml:space="preserve">
          <source>SourceHandlers</source>
          <target state="translated">SourceHandlers</target>
        </trans-unit>
        <trans-unit id="2eb56be3c2d93cdab0c52e677e3167dfddb30ac5" translate="yes" xml:space="preserve">
          <source>Sources</source>
          <target state="translated">Sources</target>
        </trans-unit>
        <trans-unit id="0933c3d8de99d538b1745c97c9ac4e0808ab779e" translate="yes" xml:space="preserve">
          <source>Sources of further information</source>
          <target state="translated">詳しい情報源</target>
        </trans-unit>
        <trans-unit id="35fda17ff05f63e9061208c2dd2aaaf98790e921" translate="yes" xml:space="preserve">
          <source>South Africa</source>
          <target state="translated">南ア</target>
        </trans-unit>
        <trans-unit id="b1ffb4c07982ffdd1d32da2ad256d5f400cca0af" translate="yes" xml:space="preserve">
          <source>South America</source>
          <target state="translated">南米</target>
        </trans-unit>
        <trans-unit id="ac6a60017b0bf8bff41d9bd208e6ef210c47fbdf" translate="yes" xml:space="preserve">
          <source>South Carolina</source>
          <target state="translated">サウスカロライナ</target>
        </trans-unit>
        <trans-unit id="f082fd9f31b253e1bc875b4f98b8b4196b3c96c9" translate="yes" xml:space="preserve">
          <source>Space after each comma.</source>
          <target state="translated">各コンマの後にスペースを入れてください。</target>
        </trans-unit>
        <trans-unit id="b842d2b9fb013f376f25c0749d5ad88cdb3e09d2" translate="yes" xml:space="preserve">
          <source>Space after last parenthesis matching on current line.</source>
          <target state="translated">現在の行の最後の括弧の後にスペースを入れます。</target>
        </trans-unit>
        <trans-unit id="155b83258e151629b360ae86e49e0abf46f96413" translate="yes" xml:space="preserve">
          <source>Space around a &quot;complex&quot; subscript (inside brackets).</source>
          <target state="translated">複雑な &quot;下付き添字(括弧内)の周りにスペースを空けます。</target>
        </trans-unit>
        <trans-unit id="3f9d9d7fddff18fb290d25d4e2d47eb10b024565" translate="yes" xml:space="preserve">
          <source>Space around most operators.</source>
          <target state="translated">ほとんどのオペレーターの周りのスペース。</target>
        </trans-unit>
        <trans-unit id="01ea9b6b043a2469906ded26f3a48de8eaf9e6e3" translate="yes" xml:space="preserve">
          <source>Space before the opening curly of a multi-line BLOCK.</source>
          <target state="translated">複数行BLOCKのオープニングカーリーの前のスペース。</target>
        </trans-unit>
        <trans-unit id="1109418eced3ecb23f96484aec5504c863ea2053" translate="yes" xml:space="preserve">
          <source>Spaces in the argument delimit distinct patterns, so &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('*.exe *.dll')&lt;/code&gt; globs all filenames that end in &lt;code&gt;.exe&lt;/code&gt; or &lt;code&gt;.dll&lt;/code&gt;. If you want to put in literal spaces in the glob pattern, you can escape them with either double quotes, or backslashes. e.g. &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/&quot;Program Files&quot;/*/*.dll')&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/Program\ Files/*/*.dll')&lt;/code&gt; . The argument is tokenized using &lt;code&gt;Text::ParseWords::parse_line()&lt;/code&gt; , so see &lt;a href=&quot;../text/parsewords&quot;&gt;Text::ParseWords&lt;/a&gt; for details of the quoting rules used.</source>
          <target state="translated">引数のスペースは異なるパターンを区切るため、 &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('*.exe *.dll')&lt;/code&gt; は &lt;code&gt;.exe&lt;/code&gt; または &lt;code&gt;.dll&lt;/code&gt; で終わるすべてのファイル名をグロブします。 globパターンにリテラルスペースを挿入する場合は、二重引用符またはバックスラッシュでエスケープできます。例： &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/&quot;Program Files&quot;/*/*.dll')&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;('c:/Program\ Files/*/*.dll')&lt;/code&gt; 。引数を使用してトークン化された &lt;code&gt;Text::ParseWords::parse_line()&lt;/code&gt; ので、参照&lt;a href=&quot;../text/parsewords&quot;&gt;テキスト:: ParseWords&lt;/a&gt;使用引用規則の詳細については、を。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
