<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="ea689de74e82f416fbcbf4ee9e4cea8733686d01" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Using a regular &lt;code&gt;foreach&lt;/code&gt; loop for this purpose would be clearer in most cases. See also &lt;a href=&quot;#grep&quot;&gt;grep&lt;/a&gt; for an array composed of those items of the original list for which the BLOCK or EXPR evaluates to true.</source>
          <target state="translated">&lt;code&gt;$_&lt;/code&gt; はリスト値のエイリアスであるため、LISTの要素を変更するために使用できることに注意してください。これは便利でサポートされていますが、LISTの要素が変数でない場合、奇妙な結果を引き起こす可能性があります。この目的で通常の &lt;code&gt;foreach&lt;/code&gt; ループを使用すると、ほとんどの場合より明確になります。BLOCKまたはEXPRがtrueと評価される元のリストの項目で構成される配列については、&lt;a href=&quot;#grep&quot;&gt;grep&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="e54794d0f40f1a8695668c788a3a5c6d8b245de4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$_&lt;/code&gt; is an alias to the list value, so it can be used to modify the elements of the LIST. While this is useful and supported, it can cause bizarre results if the elements of LIST are not variables. Using a regular &lt;code&gt;foreach&lt;/code&gt; loop for this purpose would be clearer in most cases. See also &lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt; for an array composed of those items of the original list for which the BLOCK or EXPR evaluates to true.</source>
          <target state="translated">&lt;code&gt;$_&lt;/code&gt; はリスト値のエイリアスであるため、LISTの要素を変更するために使用できることに注意してください。これは便利でサポートされていますが、LISTの要素が変数でない場合、奇妙な結果を引き起こす可能性があります。この目的で通常の &lt;code&gt;foreach&lt;/code&gt; ループを使用すると、ほとんどの場合より明確になります。BLOCKまたはEXPRがtrueと評価される元のリストの項目で構成される配列については、&lt;a href=&quot;grep&quot;&gt;grep&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="ff224648e7f90554d343ed0de97c9efcc8456e37" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$processed&lt;/code&gt; may be empty (when &lt;code&gt;$normalized&lt;/code&gt; contains no starter or starts with the last starter), and then &lt;code&gt;$unprocessed&lt;/code&gt; should be equal to the entire &lt;code&gt;$normalized&lt;/code&gt; .</source>
          <target state="translated">そのノート &lt;code&gt;$processed&lt;/code&gt; （空の場合であってもよい &lt;code&gt;$normalized&lt;/code&gt; 最後のスターターとはスターターまたは開始を含まない）、および &lt;code&gt;$unprocessed&lt;/code&gt; 全体に等しくなければならない &lt;code&gt;$normalized&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2dca7ba63a68f9fddd9b7ac309791bf8abd311e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;$processed&lt;/code&gt; may be empty (when &lt;code&gt;$normalized&lt;/code&gt; contains no starter or starts with the last starter), and then &lt;code&gt;$unprocessed&lt;/code&gt; should be equal to the entire &lt;code&gt;$normalized&lt;/code&gt;.</source>
          <target state="translated">そのノート &lt;code&gt;$processed&lt;/code&gt; （空の場合であってもよい &lt;code&gt;$normalized&lt;/code&gt; 最後のスターターとはスターターまたは開始を含まない）、および &lt;code&gt;$unprocessed&lt;/code&gt; 全体に等しくなければならない &lt;code&gt;$normalized&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6f1dc26add5ebccf190f8ef66eb27e1f5723ef3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%b&lt;/code&gt;, the short forms of the day of the week and the month of the year, may not necessarily be three characters wide.</source>
          <target state="translated">注意 &lt;code&gt;%a&lt;/code&gt; 及び &lt;code&gt;%b&lt;/code&gt; 、曜日と月の短い表現は、必ずしも3つの文字幅ではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="2098e1cc9941a87eb89bbdff478cb887098142a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;(?[ ])&lt;/code&gt; is a regex-compile-time construct. Any attempt to use something which isn't knowable at the time the containing regular expression is compiled is a fatal error. In practice, this means just three limitations:</source>
          <target state="translated">&lt;code&gt;(?[ ])&lt;/code&gt; は正規表現のコンパイル時の構造であることに注意してください。含まれている正規表現がコンパイルされた時点ではわからないものを使用しようとすると、致命的なエラーになります。実際には、これは3つの制限を意味します。</target>
        </trans-unit>
        <trans-unit id="cd09559e1981494f86fde1566facece3e2639305" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;--opt value&lt;/code&gt; is still accepted, even though GNU getopt_long() doesn't.</source>
          <target state="translated">GNU getopt_long（）が受け入れない場合でも、 &lt;code&gt;--opt value&lt;/code&gt; は引き続き受け入れられることに注意してください。</target>
        </trans-unit>
        <trans-unit id="afc9bdd2d79f09af0f88913bcc31f66fb74dccd1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-register&lt;/code&gt; is a global setting that applies to the entire program; it cannot be applied only for certain callers, removed, or limited by lexical scope.</source>
          <target state="translated">&lt;code&gt;-register&lt;/code&gt; は、プログラム全体に適用されるグローバル設定であることに注意してください。特定の呼び出し元にのみ適用したり、削除したり、字句スコープによって制限したりすることはできません。</target>
        </trans-unit>
        <trans-unit id="fd002d9c23fd4dcc51fd0e853c891c09f321ec46" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-s/a/b/&lt;/code&gt; does not do a negated substitution. Saying &lt;code&gt;-&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; still works as expected, however: only single letters following a minus are interpreted as file tests.</source>
          <target state="translated">&lt;code&gt;-s/a/b/&lt;/code&gt; は否定置換を行わないことに注意してください。言って &lt;code&gt;-&lt;a href=&quot;exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; 予想通り、まだ動作しますが、しかし：マイナスを以下の唯一の文字はファイルテストと解釈されています。</target>
        </trans-unit>
        <trans-unit id="dd375a04334c45f998942d7896c30f702e8152ff" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-s/a/b/&lt;/code&gt; does not do a negated substitution. Saying &lt;code&gt;-&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; still works as expected, however: only single letters following a minus are interpreted as file tests.</source>
          <target state="translated">&lt;code&gt;-s/a/b/&lt;/code&gt; は否定置換を行わないことに注意してください。言って &lt;code&gt;-&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;($foo)&lt;/code&gt; 予想通り、まだ動作しますが、しかし：マイナスを以下の唯一の文字はファイルテストと解釈されています。</target>
        </trans-unit>
        <trans-unit id="e3f960c753f2dbcaaba10ddc75d049f8c367286e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;-s/a/b/&lt;/code&gt; does not do a negated substitution. Saying &lt;code&gt;-exp($foo)&lt;/code&gt; still works as expected, however: only single letters following a minus are interpreted as file tests.</source>
          <target state="translated">&lt;code&gt;-s/a/b/&lt;/code&gt; は否定置換を行わないことに注意してください。言って &lt;code&gt;-exp($foo)&lt;/code&gt; 予想通り、まだしかし、作品：マイナスを以下の唯一の文字はファイルテストと解釈されています。</target>
        </trans-unit>
        <trans-unit id="48bc3a755225cb163af628efdd36b7e99bf599a7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;:constants256&lt;/code&gt; does not include the other constants, so if you want to mix both, you need to include &lt;code&gt;:constants&lt;/code&gt; as well. You may want to explicitly import at least &lt;code&gt;RESET&lt;/code&gt; , as in:</source>
          <target state="translated">注こと &lt;code&gt;:constants256&lt;/code&gt; あなたは両方をミックスしたい場合ので、あなたは含める必要があり、他の定数が含まれていません &lt;code&gt;:constants&lt;/code&gt; 同様に。次のように、少なくとも &lt;code&gt;RESET&lt;/code&gt; を明示的にインポートすることができます。</target>
        </trans-unit>
        <trans-unit id="e353e5ca3a012a60bd40d8c3d650a30fa181791c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;:constants256&lt;/code&gt; does not include the other constants, so if you want to mix both, you need to include &lt;code&gt;:constants&lt;/code&gt; as well. You may want to explicitly import at least &lt;code&gt;RESET&lt;/code&gt;, as in:</source>
          <target state="translated">&lt;code&gt;:constants256&lt;/code&gt; には他の定数が含まれていないため、両方を混合する場合は、 &lt;code&gt;:constants&lt;/code&gt; も含める必要があることに注意してください。次のように、少なくとも &lt;code&gt;RESET&lt;/code&gt; を明示的にインポートすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f3a3c31d64bd9d3852dee2165f0cdbe3c7fd1617" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;../../functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; are the totals of the wait and exit statuses of each of the tests. These values are totalled only to provide a true value if any of them are non-zero.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; は、各テストの待機および終了ステータスの合計であることに注意してください。これらの値は、いずれかがゼロ以外の場合にのみ真の値を提供するために合計されます。</target>
        </trans-unit>
        <trans-unit id="9173a2f0f306c97db5af943fc6a5b25c88ebded1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; are not listed above. If called as methods on a Time::Piece object, they act as constructors, returning a new Time::Piece object for the current time. In other words: they're not useful as methods.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; は上記にリストされていないことに注意してください。Time :: Pieceオブジェクトのメソッドとして呼び出された場合、それらはコンストラクターとして機能し、現在の時間の新しいTime :: Pieceオブジェクトを返します。つまり、メソッドとしては役に立ちません。</target>
        </trans-unit>
        <trans-unit id="9ce1c937ab3425a64de9dbc02778e5245a104b13" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; returns the last character. To return all but the last character, use &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; は最後の文字を返すことに注意してください。最後の文字を除くすべてを返すには、 &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="37ddc1b7985e6cde1bfecc807084dd2439da4505" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will not call your &lt;code&gt;END&lt;/code&gt; blocks, nor will it invoke &lt;code&gt;DESTROY&lt;/code&gt; methods on your objects.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;END&lt;/code&gt; ブロックを呼び出したり、オブジェクトの &lt;code&gt;DESTROY&lt;/code&gt; メソッドを呼び出したりしないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a60dfdd6e65097f6c305737073a8bc35fe255a7e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; raises an exception if used on a machine that doesn't implement fcntl(2). See the Fcntl module or your fcntl(2) manpage to learn what functions are available on your system.</source>
          <target state="translated">fcntl（2）を実装していないマシンで &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; を使用すると、例外が発生することに注意してください。システムで使用可能な機能については、Fcntlモジュールまたはfcntl（2）のマンページを参照してください。</target>
        </trans-unit>
        <trans-unit id="dfb2038f7135091071546cb9a6d373bb9a56e94d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; is generally not necessary when using normal filehandles; it is provided so that you can control I/O to existing record-structured files when necessary. You can also use the &lt;code&gt;vmsfopen&lt;/code&gt; function in the VMS::Stdio extension to gain finer control of I/O to files and devices with different record structures.</source>
          <target state="translated">通常のファイルハンドルを使用する場合、 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; は通常必要ないことに注意してください。必要に応じて、既存のレコード構造ファイルへのI / Oを制御できるように提供されています。VMS :: &lt;code&gt;vmsfopen&lt;/code&gt; 機能でvmsfopen関数を使用して、異なるレコード構造を持つファイルやデバイスへのI / Oをより細かく制御することもできます。</target>
        </trans-unit>
        <trans-unit id="bb9b28a9d5d46f3c748ef4753fd4b0b26da11633" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; returns the last character. To return all but the last character, use &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; は最後の文字を返すことに注意してください。最後の文字を除くすべてを返すには、 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;($string, 0, -1)&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="f2886ca2fd4621ed375e17bc5caf418ae86a77d6" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; will not call your &lt;code&gt;END&lt;/code&gt; blocks, nor will it invoke &lt;code&gt;DESTROY&lt;/code&gt; methods on your objects.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;END&lt;/code&gt; ブロックを呼び出したり、オブジェクトの &lt;code&gt;DESTROY&lt;/code&gt; メソッドを呼び出したりしないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f249c4d8b204567737cd31f8ec07948c8d5ac294" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; raises an exception if used on a machine that doesn't implement fcntl(2). See the Fcntl module or your fcntl(2) manpage to learn what functions are available on your system.</source>
          <target state="translated">fcntl（2）を実装していないマシンで &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; を使用すると、例外が発生することに注意してください。システムで使用可能な機能については、Fcntlモジュールまたはfcntl（2）のマンページを参照してください。</target>
        </trans-unit>
        <trans-unit id="d7d9c1784c1fe9a279665a4571e3c21c04751dcb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; splits its arguments on whitespace and treats each segment as separate pattern. As such, &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; matches all files with a</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; は引数を空白で分割し、各セグメントを個別のパターンとして扱うことに注意してください。そのため、 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="dd0f76b7382c19ee434e95709a48f61a31e19d7a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9&lt;/code&gt; does not work with the current version of EMX.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; -9&lt;/code&gt; は現在のバージョンのEMXでは機能しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d132135000cd2c7bd9f4aab4e6bdef7ae41bf7a4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; depends on the fdopen() C library function. On many Unix systems, fdopen() is known to fail when file descriptors exceed a certain value, typically 255. If you need more file descriptors than that, consider using the POSIX::open() function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; はfdopen（）Cライブラリ関数に依存することに注意してください。多くのUnixシステムでは、ファイル記述子が特定の値（通常は255）を超えるとfdopen（）が失敗することが知られています。それ以上のファイル記述子が必要な場合は、POSIX :: open（）関数の使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="967dccf72de487894a0bc580911ae2819ad24053" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; does &lt;b&gt;not&lt;/b&gt; do regular expression character classes such as &lt;code&gt;\d&lt;/code&gt; or &lt;code&gt;\pL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; operator is not equivalent to the &lt;code&gt;&lt;i&gt;tr(1)&lt;/i&gt;&lt;/code&gt; utility. If you want to map strings between lower/upper cases, see &lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt; and &lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;, and in general consider using the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; operator if you need regular expressions. The &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , and &lt;code&gt;\l&lt;/code&gt; string-interpolation escapes on the right side of a substitution operator will perform correct case-mappings, but &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[a-z][A-Z]&lt;/a&gt;&lt;/code&gt; will not (except sometimes on legacy 7-bit data).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;\d&lt;/code&gt; や &lt;code&gt;\pL&lt;/code&gt; などの正規表現文字クラスを実行し&lt;b&gt;ない&lt;/b&gt;ことに注意してください。 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; オペレータは、と等価ではない &lt;code&gt;&lt;i&gt;tr(1)&lt;/i&gt;&lt;/code&gt; ユーティリティ。大文字と小文字の間で文字列をマッピングする場合は、&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;および&lt;a href=&quot;functions/uc&quot;&gt;ucを&lt;/a&gt;参照してください。通常、正規表現が必要な場合は、 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 演算子の使用を検討してください。置換演算子の右側の &lt;code&gt;\U&lt;/code&gt; 、 &lt;code&gt;\u&lt;/code&gt; 、 &lt;code&gt;\L&lt;/code&gt; 、および &lt;code&gt;\l&lt;/code&gt; 文字列補間エスケープは、大文字と小文字の正しいマッピングを実行しますが、 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr[a-z][A-Z]&lt;/a&gt;&lt;/code&gt; &lt;i&gt;&lt;/i&gt; しません（場合によっては、レガシー7ビットデータを除く）。</target>
        </trans-unit>
        <trans-unit id="1a25e1352e6c84bdaa3b67f15d7d22519e3dc2fd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;\U&lt;/code&gt; in interpolated strings, translates to uppercase, while &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;\u&lt;/code&gt; in interpolated strings, translates to titlecase in languages that make the distinction (which is equivalent to uppercase in languages without the distinction).</source>
          <target state="translated">そのノート &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;\U&lt;/code&gt; 補間文字列では、大文字に変換し、一方 &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; 、又は &lt;code&gt;\u&lt;/code&gt; 補間文字列では、（区別なしの言語で大文字と等価である）の区別を行う言語のタイトルケースに変換されます。</target>
        </trans-unit>
        <trans-unit id="f7309bf49e0287f1d8c15ab22ef310f10a5d4bd7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; splits its arguments on whitespace and treats each segment as separate pattern. As such, &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; matches all files with a</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; は引数を空白で分割し、各セグメントを個別のパターンとして扱うことに注意してください。そのため、 &lt;code&gt;&lt;a href=&quot;glob&quot;&gt;glob&lt;/a&gt;(&quot;*.c *.h&quot;)&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="986549b394dff5a5a4195bbc3a0e0761106da86b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; depends on the fdopen() C library function. On many Unix systems, fdopen() is known to fail when file descriptors exceed a certain value, typically 255. If you need more file descriptors than that, consider using the POSIX::open() function.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; はfdopen（）Cライブラリ関数に依存することに注意してください。多くのUnixシステムでは、ファイル記述子が特定の値（通常は255）を超えるとfdopen（）が失敗することが知られています。それ以上のファイル記述子が必要な場合は、POSIX :: open（）関数の使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="f9b1a84ba3ae7615ac251b965f25b6f6929c148a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; requires &lt;code&gt;DECC$FILENAME_UNIX_NO_VERSION&lt;/code&gt; because the conversion routine cannot differentiate whether the last &lt;code&gt;.&lt;/code&gt; of a Unix specification is delimiting a version, or is just part of a file specification.</source>
          <target state="translated">変換ルーチンは最後のものかどうかを区別できないため、 &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; は &lt;code&gt;DECC$FILENAME_UNIX_NO_VERSION&lt;/code&gt; が必要であることに注意してください &lt;code&gt;.&lt;/code&gt; Unix仕様のは、バージョンを区切るか、ファイル仕様の一部にすぎません。</target>
        </trans-unit>
        <trans-unit id="79f5400ae4c62646c847435cddda21b4c40e3a93" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Dump&lt;/code&gt; will not report</source>
          <target state="translated">&lt;code&gt;Dump&lt;/code&gt; は報告しないことに注意してください</target>
        </trans-unit>
        <trans-unit id="14efce4f98a6d3ded52ecf9f7ef2c0c61f9e5d1c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;END&lt;/code&gt; code blocks are &lt;b&gt;not&lt;/b&gt; executed at the end of a string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;: if any &lt;code&gt;END&lt;/code&gt; code blocks are created in a string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;, they will be executed just as any other &lt;code&gt;END&lt;/code&gt; code block of that package in LIFO order just before the interpreter is being exited.</source>
          <target state="translated">そのノート &lt;code&gt;END&lt;/code&gt; のコードブロックはされ&lt;b&gt;ていない&lt;/b&gt;文字列の最後に実行 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; ：もしあれば &lt;code&gt;END&lt;/code&gt; のコードブロックは、文字列内に作成されている &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; それらは他のどのとしてだけで実行されます &lt;code&gt;END&lt;/code&gt; の LIFO順だけでそのパッケージのコードブロックインタープリターが終了する前。</target>
        </trans-unit>
        <trans-unit id="87d3d5579888e295497dd30ab3df3385d0ee5915" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;END&lt;/code&gt; code blocks are &lt;b&gt;not&lt;/b&gt; executed at the end of a string &lt;code&gt;eval()&lt;/code&gt;: if any &lt;code&gt;END&lt;/code&gt; code blocks are created in a string &lt;code&gt;eval()&lt;/code&gt;, they will be executed just as any other &lt;code&gt;END&lt;/code&gt; code block of that package in LIFO order just before the interpreter is being exited.</source>
          <target state="translated">そのノート &lt;code&gt;END&lt;/code&gt; のコードブロックはされ&lt;b&gt;ていない&lt;/b&gt;文字列の最後に実行 &lt;code&gt;eval()&lt;/code&gt; ：もしあれば &lt;code&gt;END&lt;/code&gt; のコードブロックは、文字列内に作成されている &lt;code&gt;eval()&lt;/code&gt; それらは他のどのとしてだけで実行されます &lt;code&gt;END&lt;/code&gt; のLIFO順だけでそのパッケージのコードブロックインタプリタが終了する前。</target>
        </trans-unit>
        <trans-unit id="6b4c9a20647174655acdade54ceb924854974320" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Math::BigFloat-&amp;gt;accuracy()&lt;/code&gt; and &lt;code&gt;Math::BigFloat-&amp;gt;precision()&lt;/code&gt; set the global variables, and thus &lt;b&gt;any&lt;/b&gt; newly created number will be subject to the global rounding &lt;b&gt;immediately&lt;/b&gt;. This means that in the examples above, the &lt;code&gt;3&lt;/code&gt; as argument to &lt;code&gt;bdiv()&lt;/code&gt; will also get an accuracy of &lt;b&gt;5&lt;/b&gt;.</source>
          <target state="translated">そのノート &lt;code&gt;Math::BigFloat-&amp;gt;accuracy()&lt;/code&gt; と &lt;code&gt;Math::BigFloat-&amp;gt;precision()&lt;/code&gt; グローバル変数を設定し、したがって&lt;b&gt;、任意の&lt;/b&gt;新しく作成された番号がグローバル丸めの対象となり&lt;b&gt;、直ちに&lt;/b&gt;。つまり、上記の例では、 &lt;code&gt;bdiv()&lt;/code&gt; の引数としての &lt;code&gt;3&lt;/code&gt; の精度も&lt;b&gt;5になり&lt;/b&gt;ます。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d2356c11b794082befde64b563384a96e7b0173c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;NULL&lt;/code&gt; is a valid &lt;code&gt;proto&lt;/code&gt; and will always return &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; は有効な &lt;code&gt;proto&lt;/code&gt; あり、常に &lt;code&gt;true&lt;/code&gt; を返すことに注意してください。</target>
        </trans-unit>
        <trans-unit id="199f2f9c1f354b6dfdfcfb899b79a41c177c2dfa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;NULL&lt;/code&gt; is a valid &lt;code&gt;proto&lt;/code&gt; and will always return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; は有効な &lt;code&gt;proto&lt;/code&gt; あり、常に &lt;code&gt;true&lt;/code&gt; を返すことに注意してください。</target>
        </trans-unit>
        <trans-unit id="bb94a8fcace7106b0c7ce3250a66c0e461c261b7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;STDERR&lt;/code&gt; WILL NOT be changed, regardless.</source>
          <target state="translated">&lt;code&gt;STDERR&lt;/code&gt; は関係なく変更されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="3dc8a38e3cc3af9d760a1ed60a8a353aa279d10b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;TAP::Parser&lt;/code&gt; is designed to be the central &quot;maker&quot; - ie: it is responsible for creating most new objects in the &lt;code&gt;TAP::Parser::*&lt;/code&gt; namespace.</source>
          <target state="translated">&lt;code&gt;TAP::Parser&lt;/code&gt; は、中心的な「メーカー」になるように設計されていることに注意してください。つまり、 &lt;code&gt;TAP::Parser::*&lt;/code&gt; 名前空間にほとんどの新しいオブジェクトを作成します。</target>
        </trans-unit>
        <trans-unit id="e4f8d4428f9f4403397e153eb6c9a469d63599ed" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;UNIVERSAL&lt;/code&gt; (and any members of &lt;code&gt;UNIVERSAL&lt;/code&gt; 's MRO) are not part of the MRO of a class, even though all classes implicitly inherit methods from &lt;code&gt;UNIVERSAL&lt;/code&gt; and its parents.</source>
          <target state="translated">&lt;code&gt;UNIVERSAL&lt;/code&gt; （および &lt;code&gt;UNIVERSAL&lt;/code&gt; のMROのメンバー）は、クラスのMROの一部ではないことに注意してください。ただし、すべてのクラスは &lt;code&gt;UNIVERSAL&lt;/code&gt; とその親から暗黙的にメソッドを継承します。</target>
        </trans-unit>
        <trans-unit id="d2ebe68731e3dfdbe752ef6caa15931a10fc553d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;UNIVERSAL&lt;/code&gt; (and any members of &lt;code&gt;UNIVERSAL&lt;/code&gt;'s MRO) are not part of the MRO of a class, even though all classes implicitly inherit methods from &lt;code&gt;UNIVERSAL&lt;/code&gt; and its parents.</source>
          <target state="translated">すべてのクラスが暗黙的に &lt;code&gt;UNIVERSAL&lt;/code&gt; とその親からメソッドを継承している場合でも、 &lt;code&gt;UNIVERSAL&lt;/code&gt; （および &lt;code&gt;UNIVERSAL&lt;/code&gt; のMROのメンバー）はクラスのMROの一部ではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="3fd56e1e046b5a0f876bfdbc7dc77a2bed0822bc" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N&lt;/code&gt; has two meanings. When of the form &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, it matches the character or character sequence whose name is</source>
          <target state="translated">&lt;code&gt;\N&lt;/code&gt; は2つの意味があることに注意してください。 &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; 形式の場合、名前が次の文字または文字シーケンスと一致します。</target>
        </trans-unit>
        <trans-unit id="40891c11dca9d7b7c3291116c4d74a2cf45b3046" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N&lt;/code&gt; has two meanings. When of the form &lt;code&gt;\N{NAME}&lt;/code&gt; , it matches the character or character sequence whose name is &lt;code&gt;NAME&lt;/code&gt; ; and similarly when of the form &lt;code&gt;\N{U+&lt;i&gt;hex&lt;/i&gt;}&lt;/code&gt;, it matches the character whose Unicode code point is</source>
          <target state="translated">&lt;code&gt;\N&lt;/code&gt; は2つの意味があることに注意してください。 &lt;code&gt;\N{NAME}&lt;/code&gt; 形式の場合、名前が &lt;code&gt;NAME&lt;/code&gt; である文字または文字シーケンスと一致します。同様に、形式が &lt;code&gt;\N{U+&lt;i&gt;hex&lt;/i&gt;}&lt;/code&gt; 場合、Unicodeコードポイントが</target>
        </trans-unit>
        <trans-unit id="6fec90a9c83208c9ab833401f72e3ba22b8885c3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{...}&lt;/code&gt; can mean a &lt;a href=&quot;#Named-or-numbered-characters-and-character-sequences&quot;&gt;named or numbered character &lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\N{...}&lt;/code&gt; は、&lt;a href=&quot;#Named-or-numbered-characters-and-character-sequences&quot;&gt;名前付きまたは番号付きの文字を&lt;/a&gt;意味する場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c272dee08a4ec0d279e74b44ce54c8507ca63ec0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{...}&lt;/code&gt; is compile-time; it's a special form of string constant used inside double-quotish strings; this means that you cannot use variables inside the &lt;code&gt;\N{...}&lt;/code&gt; . If you want similar run-time functionality, use &lt;a href=&quot;#charnames%3a%3astring_vianame(name)&quot;&gt;charnames::string_vianame()&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\N{...}&lt;/code&gt; はコンパイル時であることに注意してください。これは、二重引用符の文字列内で使用される文字列定数の特殊な形式です。つまり、 &lt;code&gt;\N{...}&lt;/code&gt; 内では変数を使用できません。同様のランタイム機能が必要な場合は、&lt;a href=&quot;#charnames%3a%3astring_vianame(name)&quot;&gt;charnames :: string_vianame（）を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="6ceeaecdecef4fbab384a44465508a20a199dce2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{...}&lt;/code&gt; is compile-time; it's a special form of string constant used inside double-quotish strings; this means that you cannot use variables inside the &lt;code&gt;\N{...}&lt;/code&gt;. If you want similar run-time functionality, use &lt;a href=&quot;#charnames%3A%3Astring_vianame%28name%29&quot;&gt;charnames::string_vianame()&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\N{...}&lt;/code&gt; はコンパイル時であることに注意してください。これは、二重引用符で囲まれた文字列内で使用される特殊な形式の文字列定数です。これは、 &lt;code&gt;\N{...}&lt;/code&gt; 内で変数を使用できないことを意味します。同様のランタイム機能が必要な場合は、&lt;a href=&quot;#charnames%3A%3Astring_vianame%28name%29&quot;&gt;charnames :: string_vianame（）を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="0fd4812fc895b96b92cb32be1e45c1db5eaf35e8" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\N{U+&lt;i&gt;...&lt;/i&gt;}&lt;/code&gt;, where the</source>
          <target state="translated">&lt;code&gt;\N{U+&lt;i&gt;...&lt;/i&gt;}&lt;/code&gt; であることに注意してください&lt;i&gt;。&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="591330d2defbab5242891eb86fdca8e3950ac9ed" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\c\&lt;/code&gt; alone at the end of a regular expression (or doubled-quoted string) is not valid. The backslash must be followed by another character. That is, &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; means &lt;code&gt;chr(28) . '&lt;i&gt;X&lt;/i&gt;'&lt;/code&gt; for all characters</source>
          <target state="translated">正規表現（または二重引用符で囲まれた文字列）の末尾の &lt;code&gt;\c\&lt;/code&gt; だけは無効であることに注意してください。バックスラッシュの後には別の文字を続ける必要があります。つまり、 &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; は &lt;code&gt;chr(28) . '&lt;i&gt;X&lt;/i&gt;'&lt;/code&gt; 意味します。すべての文字の「&lt;i&gt;X&lt;/i&gt;」</target>
        </trans-unit>
        <trans-unit id="e1ebc62194ed9270f2f0ded9d5873b50990282bf" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;binmode&lt;/code&gt; is generally not necessary when using normal filehandles; it is provided so that you can control I/O to existing record-structured files when necessary. You can also use the &lt;code&gt;vmsfopen&lt;/code&gt; function in the VMS::Stdio extension to gain finer control of I/O to files and devices with different record structures.</source>
          <target state="translated">通常のファイルハンドルを使用する場合、 &lt;code&gt;binmode&lt;/code&gt; は通常必要ないことに注意してください。必要に応じて、既存のレコード構造化ファイルへのI / Oを制御できるように提供されています。VMS :: &lt;code&gt;vmsfopen&lt;/code&gt; 機能のvmsfopen関数を使用して、さまざまなレコード構造を持つファイルやデバイスへのI / Oをより細かく制御することもできます。</target>
        </trans-unit>
        <trans-unit id="0564917393e190d68550cf153ec3fa749f8ef1c2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;blessed($thing)&lt;/code&gt; will also return false if &lt;code&gt;$thing&lt;/code&gt; has been blessed into a class named &quot;0&quot;. This is a possible, but quite pathological. Don't create a class named &quot;0&quot; unless you know what you're doing.</source>
          <target state="translated">&lt;code&gt;$thing&lt;/code&gt; が &quot;0&quot;という名前のクラスにblessされている場合、 &lt;code&gt;blessed($thing)&lt;/code&gt; もfalseを返すことに注意してください。これは可能ですが、かなり病的です。何をしているのかわからない場合は、「0」という名前のクラスを作成しないでください。</target>
        </trans-unit>
        <trans-unit id="e26f8bbaa602bc77ce825cb115ea483aef29de1d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;cx_pushblock()&lt;/code&gt; sets two new floors: for the args stack (to &lt;code&gt;MARK&lt;/code&gt;) and the temps stack (to &lt;code&gt;PL_tmps_ix&lt;/code&gt;). While executing at this scope level, every &lt;code&gt;nextstate&lt;/code&gt; (amongst others) will reset the args and tmps stack levels to these floors. Note that since &lt;code&gt;cx_pushblock&lt;/code&gt; uses the current value of &lt;code&gt;PL_tmps_ix&lt;/code&gt; rather than it being passed as an arg, this dictates at what point &lt;code&gt;cx_pushblock&lt;/code&gt; should be called. In particular, any new mortals which should be freed only on scope exit (rather than at the next &lt;code&gt;nextstate&lt;/code&gt;) should be created first.</source>
          <target state="translated">&lt;code&gt;cx_pushblock()&lt;/code&gt; は、argsスタック（ &lt;code&gt;MARK&lt;/code&gt; へ）とtempsスタック（ &lt;code&gt;PL_tmps_ix&lt;/code&gt; へ）の2つの新しいフロアを設定することに注意してください。このスコープレベルで実行している間、すべての &lt;code&gt;nextstate&lt;/code&gt; （とりわけ）は、argsおよびtmpsスタックレベルをこれらのフロアにリセットします。 &lt;code&gt;cx_pushblock&lt;/code&gt; は、引数として渡されるのではなく、 &lt;code&gt;PL_tmps_ix&lt;/code&gt; の現在の値を使用するため、これにより、 &lt;code&gt;cx_pushblock&lt;/code&gt; が呼び出されるポイントが決まります。具体的には、（むしろ次よりものみスコープの終了時に解放する必要がある任意の新しい人間 &lt;code&gt;nextstate&lt;/code&gt; は）最初に作成されるべきです。</target>
        </trans-unit>
        <trans-unit id="a119dbc9113a7d44b6376d76a949b8d8575c309d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;gen_delimited_pat&lt;/code&gt; was previously called &lt;code&gt;delimited_pat&lt;/code&gt; . That name may still be used, but is now deprecated.</source>
          <target state="translated">&lt;code&gt;gen_delimited_pat&lt;/code&gt; は以前は &lt;code&gt;delimited_pat&lt;/code&gt; と呼ばれていたことに注意してください。その名前は引き続き使用できますが、現在は非推奨です。</target>
        </trans-unit>
        <trans-unit id="72d7884266eebfa7e1a24e791ad9ea94730bed68" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;gen_delimited_pat&lt;/code&gt; was previously called &lt;code&gt;delimited_pat&lt;/code&gt;. That name may still be used, but is now deprecated.</source>
          <target state="translated">&lt;code&gt;gen_delimited_pat&lt;/code&gt; は以前は &lt;code&gt;delimited_pat&lt;/code&gt; と呼ばれていたことに注意してください。その名前は引き続き使用できますが、現在は非推奨です。</target>
        </trans-unit>
        <trans-unit id="18a865bc718b78b08d20efdc599ac6b3675ef080" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;kill -9&lt;/code&gt; does not work with the current version of EMX.</source>
          <target state="translated">&lt;code&gt;kill -9&lt;/code&gt; は、現在のバージョンのEMXでは機能しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="7dd7dada581d4f39d8fce5c8c1d0ecbac2ea1218" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;localtime&lt;/code&gt; and &lt;code&gt;gmtime&lt;/code&gt; are not listed above. If called as methods on a Time::Piece object, they act as constructors, returning a new Time::Piece object for the current time. In other words: they're not useful as methods.</source>
          <target state="translated">&lt;code&gt;localtime&lt;/code&gt; と &lt;code&gt;gmtime&lt;/code&gt; は上記にリストされていないことに注意してください。Time :: Pieceオブジェクトのメソッドとして呼び出された場合、それらはコンストラクターとして機能し、現在の時刻の新しいTime :: Pieceオブジェクトを返します。言い換えれば、それらはメソッドとしては役に立ちません。</target>
        </trans-unit>
        <trans-unit id="c0da4f2ba6d0cf36f2dd51c6be576bdda729bf43" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;make_source&lt;/code&gt; &amp;amp; &lt;code&gt;make_perl_source&lt;/code&gt; have been</source>
          <target state="translated">ことを注意 &lt;code&gt;make_source&lt;/code&gt; ＆ &lt;code&gt;make_perl_source&lt;/code&gt; がされています</target>
        </trans-unit>
        <trans-unit id="cb4cf0c7c42248024c78a0bb26a98cce7a24f07e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;openlog()&lt;/code&gt; now takes three arguments, just like &lt;code&gt;openlog(3)&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;openlog()&lt;/code&gt; が &lt;code&gt;openlog(3)&lt;/code&gt; と同様に3つの引数をとることに注意してください。</target>
        </trans-unit>
        <trans-unit id="107847c03394449c5b753c11d610306353b4ed86" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;openlog()&lt;/code&gt; now takes three arguments, just like &lt;code&gt;openlog(3)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;openlog()&lt;/code&gt; は、 &lt;code&gt;openlog(3)&lt;/code&gt; と同様に、3つの引数を取るようになったことに注意してください。</target>
        </trans-unit>
        <trans-unit id="20aeb476985aacd52e5f965fd1bbff8fbe0c7c39" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;pad_findlex()&lt;/code&gt; is recursive; it recurses up the chain of CVs, then comes back down, adding fake entries as it goes. It has to be this way because fake names in anon protoypes have to store in &lt;code&gt;xpadn_low&lt;/code&gt; the index into the parent pad.</source>
          <target state="translated">&lt;code&gt;pad_findlex()&lt;/code&gt; は再帰的であることに注意してください。それはCVのチェーンを再帰的に上ってから戻ってきて、偽のエントリを追加します。anonプロトタイプの偽の名前は、親パッドのインデックスを &lt;code&gt;xpadn_low&lt;/code&gt; に格納する必要があるため、この方法である必要があります。</target>
        </trans-unit>
        <trans-unit id="c3174509a7760d68363f8a3d59612b5b0d75c608" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;size&lt;/code&gt; is the full size of the destination buffer and the result is guaranteed to be &lt;code&gt;NUL&lt;/code&gt; -terminated if there is room. Note that room for the &lt;code&gt;NUL&lt;/code&gt; should be included in &lt;code&gt;size&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; は宛先バッファのフルサイズであり、空きがある場合は結果が &lt;code&gt;NUL&lt;/code&gt; で終了することが保証されていることに注意してください。 &lt;code&gt;NUL&lt;/code&gt; のためのスペースは &lt;code&gt;size&lt;/code&gt; に含める必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1eb316f8ef59a8e93ddd67dae614660ddbd436c3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;size&lt;/code&gt; is the full size of the destination buffer and the result is guaranteed to be &lt;code&gt;NUL&lt;/code&gt;-terminated if there is room. Note that room for the &lt;code&gt;NUL&lt;/code&gt; should be included in &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; は宛先バッファーのフルサイズであり、スペースがある場合、結果は &lt;code&gt;NUL&lt;/code&gt; で終了することが保証されていることに注意してください。 &lt;code&gt;NUL&lt;/code&gt; 用のスペースは &lt;code&gt;size&lt;/code&gt; に含める必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f8099742523782e905e75bc531c5f7ea28d83c88" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sort_by&lt;/code&gt; affects all the plain hashes in the data structure. If you need finer control, &lt;code&gt;tie&lt;/code&gt; necessary hashes with a module that implements ordered hash (such as &lt;a href=&quot;Hash::Ordered&quot;&gt;Hash::Ordered&lt;/a&gt; and &lt;a href=&quot;Tie::IxHash&quot;&gt;Tie::IxHash&lt;/a&gt;). &lt;code&gt;canonical&lt;/code&gt; and &lt;code&gt;sort_by&lt;/code&gt; don't affect the key order in &lt;code&gt;tie&lt;/code&gt;d hashes.</source>
          <target state="translated">&lt;code&gt;sort_by&lt;/code&gt; は、データ構造内のすべてのプレーンハッシュに影響することに注意してください。あなたはより細かい制御が必要な場合は、 &lt;code&gt;tie&lt;/code&gt; 実装は、（のようなハッシュを命じたことをモジュールに必要なハッシュを&lt;a href=&quot;Hash::Ordered&quot;&gt;ハッシュ::順序&lt;/a&gt;と&lt;a href=&quot;Tie::IxHash&quot;&gt;タイ:: IxHash&lt;/a&gt;）。 &lt;code&gt;canonical&lt;/code&gt; と &lt;code&gt;sort_by&lt;/code&gt; はでキーの順序には影響しません &lt;code&gt;tie&lt;/code&gt; Dハッシュを。</target>
        </trans-unit>
        <trans-unit id="e1ee97366e8a29ba82d524849876bc9dc36688aa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; are</source>
          <target state="translated">なお &lt;code&gt;source&lt;/code&gt; 、 &lt;code&gt;tap&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; あります</target>
        </trans-unit>
        <trans-unit id="c694dbb84b91dadc0270b7093942a49dccfcd18d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;source&lt;/code&gt;, &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; are</source>
          <target state="translated">なお &lt;code&gt;source&lt;/code&gt; 、 &lt;code&gt;tap&lt;/code&gt; と &lt;code&gt;exec&lt;/code&gt; あります</target>
        </trans-unit>
        <trans-unit id="297cb2762357bcbc37087b287127235df664073c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_magicext&lt;/code&gt; will allow things that &lt;code&gt;sv_magic&lt;/code&gt; will not. In particular, you can add magic to &lt;code&gt;SvREADONLY&lt;/code&gt; SVs, and add more than one instance of the same &lt;code&gt;how&lt;/code&gt;.</source>
          <target state="translated">注意 &lt;code&gt;sv_magicext&lt;/code&gt; がという事を許可する &lt;code&gt;sv_magic&lt;/code&gt; はしません。特に、 &lt;code&gt;SvREADONLY&lt;/code&gt; SVに魔法を追加し、同じ &lt;code&gt;how&lt;/code&gt; 複数のインスタンスを追加できます。</target>
        </trans-unit>
        <trans-unit id="a8a3ab354ef3e6d59f72d20cd807dd1f627a195f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_magicext&lt;/code&gt; will allow things that &lt;code&gt;sv_magic&lt;/code&gt; will not. In particular, you can add magic to SvREADONLY SVs, and add more than one instance of the same 'how'.</source>
          <target state="translated">注意 &lt;code&gt;sv_magicext&lt;/code&gt; がという事を許可する &lt;code&gt;sv_magic&lt;/code&gt; はしません。特に、SvREADONLY SVに魔法を追加し、同じ「方法」の複数のインスタンスを追加できます。</target>
        </trans-unit>
        <trans-unit id="d17fdc7c9d347932f15c81a113739f79e8f9e848" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_setref_pv&lt;/code&gt; copies the pointer while this copies the string.</source>
          <target state="translated">&lt;code&gt;sv_setref_pv&lt;/code&gt; は、文字列をコピーするときにポインタをコピーすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5b6169277ca527d5391cec9228283f0ee301bda5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sv_setref_pvn&lt;/code&gt; copies the string while this copies the pointer.</source>
          <target state="translated">&lt;code&gt;sv_setref_pvn&lt;/code&gt; は文字列をコピーし、これはポインタをコピーすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ca9054fd02ce103d72fc003e486b493405a56eb5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;tr&lt;/code&gt; does &lt;b&gt;not&lt;/b&gt; do regular expression character classes such as &lt;code&gt;\d&lt;/code&gt; or &lt;code&gt;\pL&lt;/code&gt;. The &lt;code&gt;tr&lt;/code&gt; operator is not equivalent to the &lt;code&gt;&lt;a href=&quot;http://man.he.net/man1/tr&quot;&gt;tr(1)&lt;/a&gt;&lt;/code&gt; utility. &lt;code&gt;tr[a-z][A-Z]&lt;/code&gt; will uppercase the 26 letters &quot;a&quot; through &quot;z&quot;, but for case changing not confined to ASCII, use &lt;a href=&quot;perlfunc#lc&quot;&gt;&lt;code&gt;lc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#uc&quot;&gt;&lt;code&gt;uc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#lcfirst&quot;&gt;&lt;code&gt;lcfirst&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#ucfirst&quot;&gt;&lt;code&gt;ucfirst&lt;/code&gt;&lt;/a&gt; (all documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;), or the &lt;a href=&quot;#s%2FPATTERN%2FREPLACEMENT%2Fmsixpodualngcer&quot;&gt;substitution operator &lt;code&gt;s/&lt;i&gt;PATTERN&lt;/i&gt;/&lt;i&gt;REPLACEMENT&lt;/i&gt;/&lt;/code&gt;&lt;/a&gt; (with &lt;code&gt;\U&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, and &lt;code&gt;\l&lt;/code&gt; string-interpolation escapes in the</source>
          <target state="translated">&lt;code&gt;tr&lt;/code&gt; は、 &lt;code&gt;\d&lt;/code&gt; や &lt;code&gt;\pL&lt;/code&gt; などの正規表現文字クラスを実行し&lt;b&gt;ない&lt;/b&gt;ことに注意してください。 &lt;code&gt;tr&lt;/code&gt; オペレータは、と等価ではない &lt;code&gt;&lt;a href=&quot;http://man.he.net/man1/tr&quot;&gt;tr(1)&lt;/a&gt;&lt;/code&gt; ユーティリティ。 &lt;code&gt;tr[a-z][A-Z]&lt;/code&gt; は26文字の「a」から「z」を大文字にしますが、ASCIIに限定されない大文字小文字の変更には、&lt;a href=&quot;perlfunc#lc&quot;&gt; &lt;code&gt;lc&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;perlfunc#uc&quot;&gt; &lt;code&gt;uc&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;perlfunc#lcfirst&quot;&gt; &lt;code&gt;lcfirst&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;perlfunc#ucfirst&quot;&gt; &lt;code&gt;ucfirst&lt;/code&gt; &lt;/a&gt;（すべて&lt;a href=&quot;perlfunc&quot;&gt;perlfuncで&lt;/a&gt;文書化されています）または&lt;a href=&quot;#s%2FPATTERN%2FREPLACEMENT%2Fmsixpodualngcer&quot;&gt;置換演算子&lt;/a&gt; &lt;code&gt;s/&lt;i&gt;PATTERN&lt;/i&gt;/&lt;i&gt;REPLACEMENT&lt;/i&gt;/&lt;/code&gt; &lt;i&gt;パターン&lt;/i&gt;/&lt;i&gt;置換&lt;/i&gt;/（ &lt;code&gt;\U&lt;/code&gt; 、 &lt;code&gt;\u&lt;/code&gt; 、 &lt;code&gt;\L&lt;/code&gt; &lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;、および &lt;code&gt;\l&lt;/code&gt; 文字列補間は</target>
        </trans-unit>
        <trans-unit id="968eb220f1920402825447b300d7614d04828e7d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;uc()&lt;/code&gt;, or &lt;code&gt;\U&lt;/code&gt; in interpolated strings, translates to uppercase, while &lt;code&gt;ucfirst&lt;/code&gt;, or &lt;code&gt;\u&lt;/code&gt; in interpolated strings, translates to titlecase in languages that make the distinction (which is equivalent to uppercase in languages without the distinction).</source>
          <target state="translated">そのノート &lt;code&gt;uc()&lt;/code&gt; 、または &lt;code&gt;\U&lt;/code&gt; 補間文字列では、大文字に変換し、一方 &lt;code&gt;ucfirst&lt;/code&gt; 、又は &lt;code&gt;\u&lt;/code&gt; 補間文字列では、（区別なしの言語で大文字と等価である）の区別を行う言語のタイトルケースに変換されます。</target>
        </trans-unit>
        <trans-unit id="b40c8f91ea36b67ee3cfa45c32946c2ec3844b33" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;undef&lt;/code&gt; is treated much as other numerical operations treat it; it compares equal to zero but additionally produces a warning if such warnings are enabled (&lt;code&gt;use warnings 'uninitialized';&lt;/code&gt;). In addition, an &lt;code&gt;undef&lt;/code&gt; in the returned list is coerced into a numerical zero, so that the entire list of values returned by &lt;code&gt;uniqint&lt;/code&gt; are well-behaved as integers.</source>
          <target state="translated">&lt;code&gt;undef&lt;/code&gt; は、他の数値演算と同じように扱われることに注意してください。ゼロと比較されますが、そのような警告が有効になっている場合はさらに警告が生成されます（ &lt;code&gt;use warnings 'uninitialized';&lt;/code&gt; ）。さらに、返されるリストの &lt;code&gt;undef&lt;/code&gt; は強制的に数値ゼロになるため、 &lt;code&gt;uniqint&lt;/code&gt; によって返される値のリスト全体が整数として適切に動作します。</target>
        </trans-unit>
        <trans-unit id="adf172390d0d301f41e881eb119b5f9d655cba59" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;undef&lt;/code&gt; is treated much as other numerical operations treat it; it compares equal to zero but additionally produces a warning if such warnings are enabled (&lt;code&gt;use warnings 'uninitialized';&lt;/code&gt;). In addition, an &lt;code&gt;undef&lt;/code&gt; in the returned list is coerced into a numerical zero, so that the entire list of values returned by &lt;code&gt;uniqnum&lt;/code&gt; are well-behaved as numbers.</source>
          <target state="translated">&lt;code&gt;undef&lt;/code&gt; は、他の数値演算と同じように扱われることに注意してください。ゼロと比較されますが、そのような警告が有効になっている場合はさらに警告が生成されます（ &lt;code&gt;use warnings 'uninitialized';&lt;/code&gt; ）。さらに、返されるリストの &lt;code&gt;undef&lt;/code&gt; は強制的に数値ゼロになるため、 &lt;code&gt;uniqnum&lt;/code&gt; によって返される値のリスト全体が数値として適切に動作します。</target>
        </trans-unit>
        <trans-unit id="1438af20c640a879b280a807cfcb4c4b1f563f7c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;undef&lt;/code&gt; is treated much as other string operations treat it; it compares equal to the empty string but additionally produces a warning if such warnings are enabled (&lt;code&gt;use warnings 'uninitialized';&lt;/code&gt;). In addition, an &lt;code&gt;undef&lt;/code&gt; in the returned list is coerced into an empty string, so that the entire list of values returned by &lt;code&gt;uniqstr&lt;/code&gt; are well-behaved as strings.</source>
          <target state="translated">&lt;code&gt;undef&lt;/code&gt; は、他の文字列操作と同じように扱われることに注意してください。空の文字列と同等に比較されますが、そのような警告が有効になっている場合はさらに警告が生成されます（ &lt;code&gt;use warnings 'uninitialized';&lt;/code&gt; ）。さらに、返されるリストの &lt;code&gt;undef&lt;/code&gt; は空の文字列に強制変換されるため、 &lt;code&gt;uniqstr&lt;/code&gt; によって返される値のリスト全体が文字列として適切に動作します。</target>
        </trans-unit>
        <trans-unit id="c8b9e5c8595e30b3314518789be3e0f347c198b7" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;utf8::downgrade()&lt;/code&gt; can fail if the string contains characters that don't fit into a byte.</source>
          <target state="translated">バイトに収まらない文字が文字列に含まれている場合、 &lt;code&gt;utf8::downgrade()&lt;/code&gt; が失敗する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="244a344737b42f7a4dc0804c6a1816a678ff0765" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;wait&lt;/code&gt; and &lt;code&gt;exit&lt;/code&gt; are the totals of the wait and exit statuses of each of the tests. These values are totalled only to provide a true value if any of them are non-zero.</source>
          <target state="translated">&lt;code&gt;wait&lt;/code&gt; と &lt;code&gt;exit&lt;/code&gt; は、各テストの待機と終了のステータスの合計であることに注意してください。これらの値は、いずれかがゼロ以外の場合にのみ真の値を提供するために合計されます。</target>
        </trans-unit>
        <trans-unit id="aa060ed1a78be536ec85c38f0f18576d3c573522" translate="yes" xml:space="preserve">
          <source>Note that =end commands must match the currently open =begin command. That is, they must properly nest. For example, this is valid:</source>
          <target state="translated">endコマンドは、現在開いている=beginコマンドと一致しなければならないことに注意してください。つまり、それらは適切にネストしなければなりません。例えば、これは有効です。</target>
        </trans-unit>
        <trans-unit id="eaeb65853d186efa2ac24ebd60591d6679af5af8" translate="yes" xml:space="preserve">
          <source>Note that ASCII characters that don't map to control characters are discouraged, and will generate the warning (when enabled) &lt;a href=&quot;#%22%5Cc%25c%22-is-more-clearly-written-simply-as-%22%25s%22&quot;&gt;&quot;&quot;\c%c&quot; is more clearly written simply as &quot;%s&quot;&quot;&lt;/a&gt;.</source>
          <target state="translated">制御文字にマップされないASCII文字は推奨されておらず、警告が生成されることに注意してください（有効になっている場合）&lt;a href=&quot;#%22%5Cc%25c%22-is-more-clearly-written-simply-as-%22%25s%22&quot;&gt;&quot;&quot; \ c％c &quot;は、単に&quot;％s &quot;&quot;としてより明確に記述され&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="29f1f8d502ed33af80a815e01f2ba72fc747d301" translate="yes" xml:space="preserve">
          <source>Note that ASCII characters that don't map to control characters are discouraged, and will generate the warning (when enabled) &lt;a href=&quot;#%5cc%25c%22-is-more-clearly-written-simply-as-%22%25s&quot;&gt;\c%c is more clearly written simply as %s&lt;/a&gt;.</source>
          <target state="translated">制御文字にマッピングされないASCII文字は推奨されず、警告が生成されることに注意してください（有効になっている場合）&lt;a href=&quot;#%5cc%25c%22-is-more-clearly-written-simply-as-%22%25s&quot;&gt;\ c％cは％sとしてより明確に記述され&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="7f696f805b3c072e83294d03b83db4d7aa8d5f2f" translate="yes" xml:space="preserve">
          <source>Note that E&amp;lt;number&amp;gt;</source>
          <target state="translated">E &amp;lt;数値&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0b2805b17d2c93e101d429684bf1e4cc0ec6e9bf" translate="yes" xml:space="preserve">
          <source>Note that GNU tar earlier than version 1.14 does not cope well with the &lt;code&gt;POSIX header prefix&lt;/code&gt; . If you use such a version, consider setting the &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; variable to &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">バージョン1.14より前のGNU tarは &lt;code&gt;POSIX header prefix&lt;/code&gt; うまく対応しないことに注意してください。そのようなバージョンを使用する場合は、 &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; 変数を &lt;code&gt;true&lt;/code&gt; に設定することを検討してください。</target>
        </trans-unit>
        <trans-unit id="e1703b14dd9d7aca1f4b440f1de3dd5da07ea976" translate="yes" xml:space="preserve">
          <source>Note that GNU tar earlier than version 1.14 does not cope well with the &lt;code&gt;POSIX header prefix&lt;/code&gt;. If you use such a version, consider setting the &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; variable to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">バージョン1.14より前のGNUtarは、 &lt;code&gt;POSIX header prefix&lt;/code&gt; うまく対応できないことに注意してください。このようなバージョンを使用する場合は、 &lt;code&gt;$Archive::Tar::DO_NOT_USE_PREFIX&lt;/code&gt; 変数を &lt;code&gt;true&lt;/code&gt; に設定することを検討してください。</target>
        </trans-unit>
        <trans-unit id="41555ab0bf65d38958a3f14aeb7171b1e0133dfc" translate="yes" xml:space="preserve">
          <source>Note that GNU's gzip/gunzip is not the same as Info-ZIP's zip/unzip package. The former is a simple compression tool; the latter permits creation of multi-file archives.</source>
          <target state="translated">GNU の gzip/gunzip は Info-ZIP の zip/unzip パッケージと同じではないことに注意してください。前者は単純な圧縮ツールですが、後者は複数ファイルのアーカイブを作成することができます。</target>
        </trans-unit>
        <trans-unit id="622ccc1f7f386f33bcd0fe7e88ec0737a974a63d" translate="yes" xml:space="preserve">
          <source>Note that Hash Quality Score would be 1 for an ideal hash, numbers close to and below 1 indicate good hashing, and number significantly above indicate a poor score. In practice it should be around 0.95 to 1.05. It is defined as:</source>
          <target state="translated">ハッシュ品質スコアは、理想的なハッシュであれば1で、1に近いかそれ以下の数値は良いハッシュであることを示し、それ以上の数値は悪いスコアであることを示しています。実際には0.95から1.05程度になるはずです。これは次のように定義されています。</target>
        </trans-unit>
        <trans-unit id="5fc2a35e63a8ddebfc4d138e20ffc7c6e9a57238" translate="yes" xml:space="preserve">
          <source>Note that I could not run successful smokes when initiated by the Synology Task Scheduler. I resorted to initiating the smokes via a cron job run on another system, using ssh:</source>
          <target state="translated">Synology Task Scheduler で起動しても、正常にスモークを実行できなかったことに注意してください。私は、ssh を使用して、別のシステムで実行されている cron ジョブを使用してスモークを開始することに頼りました。</target>
        </trans-unit>
        <trans-unit id="a0b4524e41048103b895691d929d6149e5d9f22f" translate="yes" xml:space="preserve">
          <source>Note that ISO-8859-1-</source>
          <target state="translated">ISO-8859-1-に注意してください。</target>
        </trans-unit>
        <trans-unit id="5a0bd34cdc923419eb75f34bbc27c1a38f42a083" translate="yes" xml:space="preserve">
          <source>Note that META files are expected to be in UTF-8 encoding, only. When converted string data, it must first be decoded from UTF-8.</source>
          <target state="translated">METAファイルは、UTF-8エンコーディングのみであることが予想されることに注意してください。文字列データを変換する場合は、まずUTF-8からデコードする必要があります。</target>
        </trans-unit>
        <trans-unit id="9d701eb861ec485b89d355a1ef6df2a9826d0960" translate="yes" xml:space="preserve">
          <source>Note that MakeMaker actually emits makefiles with different syntax depending on what 'make' it thinks you are using. Therefore, it is important that one of the following values appears in Config.pm:</source>
          <target state="translated">MakeMaker は実際には、使用していると思われる 'make' に応じて異なる構文の makefile を出力することに注意してください。そのため、Config.pm に以下の値のいずれかが表示されていることが重要です。</target>
        </trans-unit>
        <trans-unit id="e57e92f05abaff6b44fad917e7a4948606c4c50b" translate="yes" xml:space="preserve">
          <source>Note that Perl can be compiled and run under either ASCII or EBCDIC (See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;). Most of the documentation (and even comments in the code) ignore the EBCDIC possibility. For almost all purposes the differences are transparent. As an example, under EBCDIC, instead of UTF-8, UTF-EBCDIC is used to encode Unicode strings, and so whenever this documentation refers to &lt;code&gt;utf8&lt;/code&gt; (and variants of that name, including in function names), it also (essentially transparently) means &lt;code&gt;UTF-EBCDIC&lt;/code&gt; . But the ordinals of characters differ between ASCII, EBCDIC, and the UTF- encodings, and a string encoded in UTF-EBCDIC may occupy more bytes than in UTF-8.</source>
          <target state="translated">Perlは、ASCIIまたはEBCDICのいずれかでコンパイルおよび実行できることに注意してください（&lt;a href=&quot;perlebcdic&quot;&gt;perlebcdicを&lt;/a&gt;参照）。ほとんどのドキュメント（およびコード内のコメント）は、EBCDICの可能性を無視しています。ほとんどすべての目的で、違いは透過的です。例として、EBCDICでは、UTF-8の代わりにUTF-EBCDICがUnicode文字列のエンコードに使用されるため、このドキュメントが &lt;code&gt;utf8&lt;/code&gt; （および関数名を含むその名前のバリアント）を参照するときはいつでも（本質的に透過的に） &lt;code&gt;UTF-EBCDIC&lt;/code&gt; を意味します。ただし、文字の序数はASCII、EBCDIC、およびUTF-エンコーディングで異なり、UTF-EBCDICでエンコードされた文字列は、UTF-8よりも多くのバイトを占有する場合があります。</target>
        </trans-unit>
        <trans-unit id="1e8390b60c04725a0174dd4b5588a54acdd18f9b" translate="yes" xml:space="preserve">
          <source>Note that Perl can be compiled and run under either ASCII or EBCDIC (See &lt;a href=&quot;perlebcdic&quot;&gt;perlebcdic&lt;/a&gt;). Most of the documentation (and even comments in the code) ignore the EBCDIC possibility. For almost all purposes the differences are transparent. As an example, under EBCDIC, instead of UTF-8, UTF-EBCDIC is used to encode Unicode strings, and so whenever this documentation refers to &lt;code&gt;utf8&lt;/code&gt; (and variants of that name, including in function names), it also (essentially transparently) means &lt;code&gt;UTF-EBCDIC&lt;/code&gt;. But the ordinals of characters differ between ASCII, EBCDIC, and the UTF- encodings, and a string encoded in UTF-EBCDIC may occupy a different number of bytes than in UTF-8.</source>
          <target state="translated">Perlは、ASCIIまたはEBCDICのいずれかでコンパイルおよび実行できることに注意してください（&lt;a href=&quot;perlebcdic&quot;&gt;perlebcdicを&lt;/a&gt;参照）。ほとんどのドキュメント（およびコード内のコメント）は、EBCDICの可能性を無視しています。ほとんどすべての目的で、違いは透過的です。例として、EBCDICでは、UTF-8の代わりにUTF-EBCDICを使用してUnicode文字列をエンコードするため、このドキュメントで &lt;code&gt;utf8&lt;/code&gt; （および関数名を含むその名前のバリアント）を参照する場合は常に（本質的に透過的に） &lt;code&gt;UTF-EBCDIC&lt;/code&gt; を意味します。ただし、文字の通常はASCII、EBCDIC、およびUTF-エンコーディング間で異なり、UTF-EBCDICでエンコードされた文字列はUTF-8とは異なるバイト数を占める場合があります。</target>
        </trans-unit>
        <trans-unit id="18cd527588221d4d537c9d16a7ea7760668b37e5" translate="yes" xml:space="preserve">
          <source>Note that Perl considers grapheme clusters to be separate characters, so for example</source>
          <target state="translated">Perl は書記素クラスタを個別の文字と考えていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="29139db0e01423398a38202c816ab0163a1e630a" translate="yes" xml:space="preserve">
          <source>Note that Perl does Full case-folding in matching, not Simple:</source>
          <target state="translated">Perl はマッチングの際に、単純な大文字小文字の折り返しではなく、完全な大文字小文字の折り返しを行うことに注意してください。</target>
        </trans-unit>
        <trans-unit id="eab78c95236503996e3835788eca975544654d36" translate="yes" xml:space="preserve">
          <source>Note that Perl doesn't use COMSPEC for this purpose because COMSPEC has a high degree of variability among users, leading to portability concerns. Besides, Perl can use a shell that may not be fit for interactive use, and setting COMSPEC to such a shell may interfere with the proper functioning of other programs (which usually look in COMSPEC to find a shell fit for interactive use).</source>
          <target state="translated">Perl はこの目的のために COMSPEC を使用しないことに注意してください。なぜなら、COMSPEC にはユーザ間での高いばらつきがあり、移植性の問題につながるからです。さらに、Perl は対話的な使用に適していないシェルを使用することができ、COMSPEC をそのようなシェルに設定すると、他のプログラムの適切な機能を妨げる可能性があります (通常、対話的な使用に適したシェルを見つけるために COMSPEC を検索します)。</target>
        </trans-unit>
        <trans-unit id="0b9723f4ea6f4a0b6aceb296908b35e0318ba34c" translate="yes" xml:space="preserve">
          <source>Note that Perl supports passing of up to only 14 arguments to your syscall, which in practice should (usually) suffice.</source>
          <target state="translated">Perl はシステムコールに最大 14 個の引数を渡すことをサポートしていますが、実際には (通常は)これで十分です。</target>
        </trans-unit>
        <trans-unit id="fc038a57f3e25b6eadeaf90180f1c3439e440f0b" translate="yes" xml:space="preserve">
          <source>Note that Perl will start to look for scripts only if OS/2 cannot start the specified application, thus &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'blah'&lt;/code&gt; will not look for a script if there is an executable file</source>
          <target state="translated">OS / 2が指定されたアプリケーションを開始できない場合にのみ、Perlはスクリプトの検索を開始することに注意してください。したがって、実行可能ファイルがある場合、 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; 'blah'&lt;/code&gt; はスクリプトを検索しません。</target>
        </trans-unit>
        <trans-unit id="44957b723edd6e235f882ee4085c7777338d3275" translate="yes" xml:space="preserve">
          <source>Note that Perl will start to look for scripts only if OS/2 cannot start the specified application, thus &lt;code&gt;system 'blah'&lt;/code&gt; will not look for a script if there is an executable file</source>
          <target state="translated">Perlは、OS / 2が指定されたアプリケーションを開始できない場合にのみスクリプトの検索を開始するため、実行可能ファイルがある場合、 &lt;code&gt;system 'blah'&lt;/code&gt; はスクリプトを検索しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="91fa96b82144dedf82260fa9f38047e79dd27888" translate="yes" xml:space="preserve">
          <source>Note that Pod authors may use formatting codes inside the &quot;text&quot; part of &quot;L&amp;lt;text|name&amp;gt;&quot; (and so on for L&amp;lt;text|/&quot;sec&quot;&amp;gt;).</source>
          <target state="translated">ポッドの作成者は、「L &amp;lt;text | name&amp;gt;」の「text」部分内でフォーマットコードを使用する場合があることに注意してください（L &amp;lt;text | / &quot;sec&quot;&amp;gt;の場合も同様）。</target>
        </trans-unit>
        <trans-unit id="e78fad76e523eb715d0d0985d903052e1c5e94f3" translate="yes" xml:space="preserve">
          <source>Note that RFC 1951 data is not a good choice of compression format to use in isolation, especially if you want to auto-detect it.</source>
          <target state="translated">特に自動検出したい場合には、RFC 1951 のデータを分離して使用する圧縮形式は良い選択ではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="9c1a2afa5425cbbe8c2645f8ed66553e6e705923" translate="yes" xml:space="preserve">
          <source>Note that SHA-1 and SHA-2 use</source>
          <target state="translated">SHA-1 と SHA-2 は</target>
        </trans-unit>
        <trans-unit id="5e739101966d2d75e1e2a13b96e1acfc17a54320" translate="yes" xml:space="preserve">
          <source>Note that TODO tests</source>
          <target state="translated">TODOテストに注意</target>
        </trans-unit>
        <trans-unit id="40402ed7efd78d7a86f48194a3b6516e77f57a23" translate="yes" xml:space="preserve">
          <source>Note that Test::Builder ensures that any diagnostics end in a \n and it in earlier versions of Test::Tester it was essential that you have the final \n in your expected diagnostics. From version 0.10 onward, Test::Tester will add the \n if you forgot it. It will not add a \n if you are expecting no diagnostics. See below for help tracking down hard to find space and tab related problems.</source>
          <target state="translated">Test::Builder は、すべての診断が \n で終わることを保証しており、以前のバージョンの Test::Test::Tester では、予想される診断の中に最後の \n が含まれていることが必須であったことに注意してください。バージョン 0.10 以降では、Test::Test::Tester は、忘れてしまった場合、「\n」を追加します。診断を期待していない場合は、追加されません。スペースやタブに関連する問題を見つけるのが難しい場合は、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="adf90b14f7079e4b164d5f4781cb0955f5b8199b" translate="yes" xml:space="preserve">
          <source>Note that Tie::File will only close any filehandles that it opened internally. If you passed it a filehandle as above, you &quot;own&quot; the filehandle, and are responsible for closing it after you have untied the @array.</source>
          <target state="translated">Tie::File は内部で開いたファイルハンドルを閉じるだけであることに注意してください。上記のようにファイルハンドルを渡した場合は、そのファイルハンドルを「所有」していることになります。</target>
        </trans-unit>
        <trans-unit id="0bba5758898958160c86aa3ac20956cb9f092bfd" translate="yes" xml:space="preserve">
          <source>Note that Vietnamese is listed above. Also read &quot;Encoding vs Charset&quot; below. Also note that these are implemented in distinct modules by countries, due to the size concerns (simplified Chinese is mapped to 'CN', continental China, while traditional Chinese is mapped to 'TW', Taiwan). Please refer to their respective documentation pages.</source>
          <target state="translated">ベトナム語が上に記載されていることに注意してください。また、以下の「エンコーディングと文字セット」も読んでください。また、サイズの問題から、これらは国によって異なるモジュールで実装されていることにも注意してください(簡体字中国語は中国大陸の'CN'にマップされ、繁体字中国語は台湾の'TW'にマップされています)。それぞれのドキュメントページを参照してください。</target>
        </trans-unit>
        <trans-unit id="6817ce7211b8227d70ebd744addb1493f99a5309" translate="yes" xml:space="preserve">
          <source>Note that [= =] and [. .] are not currently implemented; they are simply placeholders for future extensions and will cause fatal errors. The &amp;lt;-- HERE shows whereabouts in the regular expression the problem was discovered. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">[==]と[に注意してください。。]現在実装されていません。これらは将来の拡張機能の単なるプレースホルダーであり、致命的なエラーを引き起こします。&amp;lt;-ここに、問題が発見された正規表現の所在を示します。&lt;a href=&quot;perlre&quot;&gt;perlreを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4afe4a651bf63522c9809fb7b99b7a958e429b1d" translate="yes" xml:space="preserve">
          <source>Note that a &quot;=begin</source>
          <target state="translated">注意してほしいのは、&quot;=begin &quot;が</target>
        </trans-unit>
        <trans-unit id="8b724b26e18550406b5e1585fe304e6c44d42b0e" translate="yes" xml:space="preserve">
          <source>Note that a blank line must have no blanks in it. Thus &lt;code&gt;&quot;fred\n \nstuff\n\n&quot;&lt;/code&gt; is one paragraph, but &lt;code&gt;&quot;fred\n\nstuff\n\n&quot;&lt;/code&gt; is two.</source>
          <target state="translated">空白行には空白を入れないでください。したがって、 &lt;code&gt;&quot;fred\n \nstuff\n\n&quot;&lt;/code&gt; は1つの段落ですが、 &lt;code&gt;&quot;fred\n\nstuff\n\n&quot;&lt;/code&gt; は2 つの段落です。</target>
        </trans-unit>
        <trans-unit id="06686ad7be28b42e56c1b53fdf5f7299621f801d" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;a href=&quot;#last-LABEL&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt; can be used to effect an early exit out of such a block.</source>
          <target state="translated">ブロック自体は、1回実行されるループと意味的に同一であることに注意してください。したがって、&lt;a href=&quot;#last-LABEL&quot;&gt; &lt;code&gt;last&lt;/code&gt; &lt;/a&gt;を使用して、そのようなブロックを早期に終了することができます。</target>
        </trans-unit>
        <trans-unit id="c6af33f5ad0150d9ac083cf6a5c7a2b96b3db24b" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; will exit such a block early.</source>
          <target state="translated">ブロック自体は、1回実行されるループと意味的に同一であることに注意してください。したがって、&lt;a href=&quot;#next-LABEL&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;はそのようなブロックを早期に終了します。</target>
        </trans-unit>
        <trans-unit id="a98374e4e319a2a54ea762e6c2ec205f5e2e7d62" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;a href=&quot;#redo-LABEL&quot;&gt;&lt;code&gt;redo&lt;/code&gt;&lt;/a&gt; inside such a block will effectively turn it into a looping construct.</source>
          <target state="translated">ブロック自体は、1回実行されるループと意味的に同一であることに注意してください。したがって、そのようなブロック内で&lt;a href=&quot;#redo-LABEL&quot;&gt; &lt;code&gt;redo&lt;/code&gt; &lt;/a&gt;と、効果的にループ構造に変わります。</target>
        </trans-unit>
        <trans-unit id="488f211edef26ffffb5b05c7e2b69aaf3b6426c8" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; can be used to effect an early exit out of such a block.</source>
          <target state="translated">ブロック自体は、1回実行されるループと意味的に同じであることに注意してください。したがって、 &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; を使用して、そのようなブロックを早期に終了できます。</target>
        </trans-unit>
        <trans-unit id="ca2f98d2c44647b8c6e794a001b57317b63f04d1" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; will exit such a block early.</source>
          <target state="translated">ブロック自体は、1回実行されるループと意味的に同じであることに注意してください。したがって、 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; はそのようなブロックを早期に終了します。</target>
        </trans-unit>
        <trans-unit id="d2013e8e837998ea5b5ded0d68af26e9b66d75ac" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; inside such a block will effectively turn it into a looping construct.</source>
          <target state="translated">ブロック自体は、1回実行されるループと意味的に同じであることに注意してください。したがって、そのようなブロック内で &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 、ブロックをループ構成に効果的に変えることができます。</target>
        </trans-unit>
        <trans-unit id="69d8a2b47ed12c267af9de16d301feaa50d0b140" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; can be used to effect an early exit out of such a block.</source>
          <target state="translated">ブロック自体は、1回実行されるループと意味的に同じであることに注意してください。したがって、 &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; を使用して、そのようなブロックを早期に終了できます。</target>
        </trans-unit>
        <trans-unit id="b7cf9f9549146f3e33d4f74b132eb49835f491f8" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; will exit such a block early.</source>
          <target state="translated">ブロック自体は、1回実行されるループと意味的に同じであることに注意してください。したがって、 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; はそのようなブロックを早期に終了します。</target>
        </trans-unit>
        <trans-unit id="0597bd4ffb228a1e2d68cc747265b06bb6260752" translate="yes" xml:space="preserve">
          <source>Note that a block by itself is semantically identical to a loop that executes once. Thus &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; inside such a block will effectively turn it into a looping construct.</source>
          <target state="translated">ブロック自体は、1回実行されるループと意味的に同じであることに注意してください。したがって、そのようなブロック内で &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; 、ブロックをループ構成に効果的に変えることができます。</target>
        </trans-unit>
        <trans-unit id="3807425ae34b529f2149724bf4de6b8be9e97ec8" translate="yes" xml:space="preserve">
          <source>Note that a character expressed as an octal escape is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">8進数で表現された文字は、正規表現エンジンでは特別な意味を持たない文字とみなされ、&quot;as is &quot;にマッチすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="45cc111c1e3b21172f0f2335e1ae7306a7eb5e16" translate="yes" xml:space="preserve">
          <source>Note that a character expressed as one of these escapes is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">これらのエスケープのいずれかで表現された文字は、正規表現エンジンによって特別な意味を持たない文字とみなされ、&quot;as is &quot;にマッチすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="093e11c1b10d3b91cf6120aba258f5fb6f25eb07" translate="yes" xml:space="preserve">
          <source>Note that a character or character sequence expressed as a named or numbered character is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</source>
          <target state="translated">名前付き文字や番号付き文字として表現された文字や文字列は、正規表現エンジンによって特別な意味を持たない文字とみなされ、&quot;as is &quot;にマッチすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1aed6736ceb1599c4759de82b494ba581fec4d4a" translate="yes" xml:space="preserve">
          <source>Note that a comment can go just about anywhere, except in the middle of an escape sequence. Examples:</source>
          <target state="translated">コメントは、エスケープシーケンスの途中を除いて、ほぼどこにでも行けることに注意してください。例。</target>
        </trans-unit>
        <trans-unit id="5b8eb289741baff1763a39069ed3ea0111511da4" translate="yes" xml:space="preserve">
          <source>Note that a format begins with the letter &quot;a&quot; if and only the property it is for requires adjustments by adding the offsets in multi-element ranges. For all these properties, an entry should be adjusted only if the map is a scalar which is an integer. That is, it must match the regular expression:</source>
          <target state="translated">フォーマットは文字 &quot;a &quot;で始まることに注意してください。これらすべてのプロパティについて、マップが整数であるスカラの場合にのみ、エントリを調整する必要があります。つまり、正規表現と一致しなければなりません。</target>
        </trans-unit>
        <trans-unit id="1afc508afbed8c0f7ac0e4b478337da8478bd121" translate="yes" xml:space="preserve">
          <source>Note that a parser is not expected to distinguish between something that looks like pod, but is in a quoted string, such as a here document.</source>
          <target state="translated">パーサは、ポッドのように見えるものが、引用符で囲まれた文字列の中にあるもの、例えば here 文書のようなものを区別することは期待されていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="277e9c9ef26afafa8762a7902fac38086141ef72" translate="yes" xml:space="preserve">
          <source>Note that a scalar can be made to have both string and numeric content through numeric operations:</source>
          <target state="translated">スカラは数値演算によって文字列と数値の両方の内容を持つようにすることができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7e66da593ccdd13e9412f5c3278043542df9a102" translate="yes" xml:space="preserve">
          <source>Note that a server that is also a domain controller is reported as PRODUCTTYPE 2 (Domaincontroller) and not PRODUCTTYPE 3 (Server).</source>
          <target state="translated">ドメイン コントローラでもあるサーバは、PRODUCTTYPE 3 (サーバ)ではなく PRODUCTTYPE 2 (ドメインコントローラ)として報告されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7ba4f70f6b75455ad6abeb4c11f3ab4b74ce3ab3" translate="yes" xml:space="preserve">
          <source>Note that a shared variable guarantees that if two or more threads try to modify it at the same time, the internal state of the variable will not become corrupted. However, there are no guarantees beyond this, as explained in the next section.</source>
          <target state="translated">共有変数は、2つ以上のスレッドが同時にそれを変更しようとした場合、変数の内部状態が破損しないことを保証することに注意してください。しかし、次のセクションで説明するように、これ以上の保証はありません。</target>
        </trans-unit>
        <trans-unit id="cbf633a93711ea65ac990e0ec5a96e4eb2db906d" translate="yes" xml:space="preserve">
          <source>Note that a side-effect of the above is that &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; are no longer exported at all. This is due to the way the &lt;code&gt;Exporter&lt;/code&gt; module works. If you are migrating a codebase to use the new interface, you will have to list everything explicitly. But that's just good practice anyway.</source>
          <target state="translated">上記の副作用は、 &lt;code&gt;mkpath&lt;/code&gt; と &lt;code&gt;rmtree&lt;/code&gt; がまったくエクスポートされなくなったことです。これは、 &lt;code&gt;Exporter&lt;/code&gt; モジュールの動作方法によるものです。新しいインターフェイスを使用するようにコードベースを移行する場合は、すべてを明示的にリストする必要があります。しかし、それはとにかく良い習慣です。</target>
        </trans-unit>
        <trans-unit id="fabccca2b124b57df72b15874578f07ff3f430bb" translate="yes" xml:space="preserve">
          <source>Note that according to the POSIX 1003.1-1996 the FILENAME may have any number of trailing slashes. Some operating and filesystems do not get this right, so Perl automatically removes all trailing slashes to keep everyone happy.</source>
          <target state="translated">POSIX 1003.1-1996では、FILENAMEにはいくつでも末尾にスラッシュを付けることができることに注意してください。いくつかのオペレーティングシステムやファイルシステムはこれを正しく理解していないので、Perlは自動的にすべての末尾スラッシュを削除して、誰もが満足できるようにしています。</target>
        </trans-unit>
        <trans-unit id="128d061a1fa86fd129c7cba87a1e4d16eaa8deb7" translate="yes" xml:space="preserve">
          <source>Note that all C programs (including the perl interpreter, which is written in C) always have an underlying locale. That locale is the &quot;C&quot; locale unless changed by a call to &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt;. When Perl starts up, it changes the underlying locale to the one which is indicated by the &lt;a href=&quot;#ENVIRONMENT&quot;&gt;&quot;ENVIRONMENT&quot;&lt;/a&gt;. When using the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module or writing XS code, it is important to keep in mind that the underlying locale may be something other than &quot;C&quot;, even if the program hasn't explicitly changed it.</source>
          <target state="translated">すべてのCプログラム（Cで記述されたperlインタープリターを含む）には常に基になるロケールがあることに注意してください。&lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale（）の&lt;/a&gt;呼び出しによって変更されない限り、そのロケールは「C」ロケールです。Perlが起動すると、基礎となるロケールが&lt;a href=&quot;#ENVIRONMENT&quot;&gt;「ENVIRONMENT」で&lt;/a&gt;示されているロケールに変更されます。&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;モジュールを使用したりXSコードを記述したりする場合、プログラムが明示的に変更していなくても、基になるロケールが「C」以外のものである可能性があることに注意することが重要です。</target>
        </trans-unit>
        <trans-unit id="83be315fcf65b1854e9827d37b7aa0e643910e0c" translate="yes" xml:space="preserve">
          <source>Note that all C programs (including the perl interpreter, which is written in C) always have an underlying locale. That locale is the &quot;C&quot; locale unless changed by a call to &lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt;. When Perl starts up, it changes the underlying locale to the one which is indicated by the &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;. When using the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module or writing XS code, it is important to keep in mind that the underlying locale may be something other than &quot;C&quot;, even if the program hasn't explicitly changed it.</source>
          <target state="translated">すべてのCプログラム（Cで記述されたperlインタープリターを含む）には、常に基礎となるロケールがあることに注意してください。&lt;a href=&quot;#The-setlocale-function&quot;&gt;setlocale（）の&lt;/a&gt;呼び出しによって変更されない限り、そのロケールは「C」ロケールです。 Perlが起動すると、基礎となるロケールを&lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENTで&lt;/a&gt;示されるロケールに変更します。&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;モジュールを使用するか、XSコードを作成する場合、プログラムが明示的に変更していなくても、基礎となるロケールが「C」以外である可能性があることに留意することが重要です。</target>
        </trans-unit>
        <trans-unit id="9ab24412bb95107f3eb55078583c0a90d9214b85" translate="yes" xml:space="preserve">
          <source>Note that all Perl API global variables must be referenced with the &lt;code&gt;PL_&lt;/code&gt; prefix. Again, those not listed here are not to be used by extension writers, and can be changed or removed without notice; same with macros. Some macros are provided for compatibility with the older, unadorned names, but this support may be disabled in a future release.</source>
          <target state="translated">すべてのPerl APIグローバル変数は、 &lt;code&gt;PL_&lt;/code&gt; プレフィックスで参照する必要があることに注意してください。繰り返しますが、ここにリストされていないものは拡張機能の作成者が使用するものではなく、予告なく変更または削除できます。マクロと同じです。一部のマクロは、古い、飾り気のない名前との互換性のために提供されていますが、このサポートは将来のリリースで無効になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="89aa7734c4b74b60a4c1310b623d823298b487c6" translate="yes" xml:space="preserve">
          <source>Note that all access is read-only. You cannot modify the internals by using this module. Also, note that the B::OP and B::SV objects created by this module are only valid for as long as the underlying objects exist; their creation doesn't increase the reference counts of the underlying objects. Trying to access the fields of a freed object will give incomprehensible results, or worse.</source>
          <target state="translated">すべてのアクセスは読み取り専用であることに注意してください。このモジュールを使用して内部を変更することはできません。また、このモジュールによって作成された B::OP と B::SV オブジェクトは、基礎となるオブジェクトが存在する限り有効であることに注意してください。解放されたオブジェクトのフィールドにアクセスしようとすると、理解しがたい結果になります。</target>
        </trans-unit>
        <trans-unit id="8decf89662be3764b31363ba5ddb1483e12ddabb" translate="yes" xml:space="preserve">
          <source>Note that all non-essential underscores are removed in the display of the short names below.</source>
          <target state="translated">以下の短縮名の表示では、必須ではないアンダースコアはすべて削除されています。</target>
        </trans-unit>
        <trans-unit id="cbd6c5b0c5e74d46b9b73ec517d66ec65461aeb4" translate="yes" xml:space="preserve">
          <source>Note that all of the above are overridden within the scope of &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt;; but you should be using this pragma only for debugging.</source>
          <target state="translated">上記のすべてが &lt;code&gt;&lt;a href=&quot;bytes&quot;&gt;use bytes&lt;/a&gt;&lt;/code&gt; の範囲内でオーバーライドされることに注意してください。ただし、このプラグマはデバッグにのみ使用してください。</target>
        </trans-unit>
        <trans-unit id="205ec32f1130d522301c48a5f23e3282ae5c3cdd" translate="yes" xml:space="preserve">
          <source>Note that all updates of the %result are additive, the hash will not be cleared before use, thus allowing status results of many installs to be easily aggregated.</source>
          <target state="translated">そのため、多くのインストールのステータス結果を簡単に集約することができます。</target>
        </trans-unit>
        <trans-unit id="36cc92c47c9f292a67886537ca085ec97a646fe9" translate="yes" xml:space="preserve">
          <source>Note that all we have described here in this quick overview is the simplest most straightforward use of &lt;b&gt;Pod::Parser&lt;/b&gt; to do stream-based parsing. It is also possible to use the &lt;b&gt;Pod::Parser::parse_text&lt;/b&gt; function to do more sophisticated tree-based parsing. See &lt;a href=&quot;#TREE-BASED-PARSING&quot;&gt;TREE-BASED PARSING&lt;/a&gt;.</source>
          <target state="translated">このクイック概要でここで説明したのは、ストリームベースの解析を行うための&lt;b&gt;Pod :: Parserの&lt;/b&gt;最も単純で最も簡単な使用法であることに注意してください。&lt;b&gt;Pod :: Parser :: parse_text&lt;/b&gt;関数を使用して、より高度なツリーベースの解析を行うこともできます。&lt;a href=&quot;#TREE-BASED-PARSING&quot;&gt;ツリーベースのパーシングを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="31e72345bf22d6545d4882f14a8418945d8ea12a" translate="yes" xml:space="preserve">
          <source>Note that almost all properties are immune to case-insensitive matching. That is, adding a &lt;code&gt;/i&lt;/code&gt; regular expression modifier does not change what they match. But there are two sets that are affected. The first set is &lt;code&gt;Uppercase_Letter&lt;/code&gt;, &lt;code&gt;Lowercase_Letter&lt;/code&gt;, and &lt;code&gt;Titlecase_Letter&lt;/code&gt;, all of which match &lt;code&gt;Cased_Letter&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. The second set is &lt;code&gt;Uppercase&lt;/code&gt;, &lt;code&gt;Lowercase&lt;/code&gt;, and &lt;code&gt;Titlecase&lt;/code&gt;, all of which match &lt;code&gt;Cased&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case, so they are &lt;code&gt;Cased&lt;/code&gt;, but aren't considered to be letters, so they aren't &lt;code&gt;Cased_Letter&lt;/code&gt;s. They're actually &lt;code&gt;Letter_Number&lt;/code&gt;s.) This set also includes its subsets &lt;code&gt;PosixUpper&lt;/code&gt; and &lt;code&gt;PosixLower&lt;/code&gt;, both of which under &lt;code&gt;/i&lt;/code&gt; match &lt;code&gt;PosixAlpha&lt;/code&gt;.</source>
          <target state="translated">ほとんどすべてのプロパティは、大文字と小文字を区別しないマッチングの影響を受けないことに注意してください。つまり、 &lt;code&gt;/i&lt;/code&gt; 正規表現修飾子を追加しても、一致するものは変更されません。ただし、影響を受けるセットは2つあります。最初のセットである &lt;code&gt;Uppercase_Letter&lt;/code&gt; 、 &lt;code&gt;Lowercase_Letter&lt;/code&gt; 、及び &lt;code&gt;Titlecase_Letter&lt;/code&gt; 一致すべては、 &lt;code&gt;Cased_Letter&lt;/code&gt; を下 &lt;code&gt;/i&lt;/code&gt; マッチング。第二のセットは、 &lt;code&gt;Uppercase&lt;/code&gt; 、 &lt;code&gt;Lowercase&lt;/code&gt; 、および &lt;code&gt;Titlecase&lt;/code&gt; 一致すべては、 &lt;code&gt;Cased&lt;/code&gt; の下 &lt;code&gt;/i&lt;/code&gt; マッチング。 （これらのセットの違いは、ローマ数字などの一部のものは大文字と小文字の両方で提供されるため、 &lt;code&gt;Cased&lt;/code&gt; 、彼らはありませんので、文字とはみなされない &lt;code&gt;Cased_Letter&lt;/code&gt; 秒。これらは実際には &lt;code&gt;Letter_Number&lt;/code&gt; です。）このセットには、サブセット &lt;code&gt;PosixUpper&lt;/code&gt; と &lt;code&gt;PosixLower&lt;/code&gt; も含まれています。どちらも &lt;code&gt;/i&lt;/code&gt; の下でPosixAlphaと一致し &lt;code&gt;PosixAlpha&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b40f1346b332774a6bbe4756105b2451b5aa080" translate="yes" xml:space="preserve">
          <source>Note that almost all properties are immune to case-insensitive matching. That is, adding a &lt;code&gt;/i&lt;/code&gt; regular expression modifier does not change what they match. There are two sets that are affected. The first set is &lt;code&gt;Uppercase_Letter&lt;/code&gt; , &lt;code&gt;Lowercase_Letter&lt;/code&gt; , and &lt;code&gt;Titlecase_Letter&lt;/code&gt; , all of which match &lt;code&gt;Cased_Letter&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. The second set is &lt;code&gt;Uppercase&lt;/code&gt; , &lt;code&gt;Lowercase&lt;/code&gt; , and &lt;code&gt;Titlecase&lt;/code&gt; , all of which match &lt;code&gt;Cased&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; matching. (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case, so they are &lt;code&gt;Cased&lt;/code&gt; , but aren't considered to be letters, so they aren't &lt;code&gt;Cased_Letter&lt;/code&gt; s. They're actually &lt;code&gt;Letter_Number&lt;/code&gt; s.) This set also includes its subsets &lt;code&gt;PosixUpper&lt;/code&gt; and &lt;code&gt;PosixLower&lt;/code&gt; , both of which under &lt;code&gt;/i&lt;/code&gt; match &lt;code&gt;PosixAlpha&lt;/code&gt; .</source>
          <target state="translated">ほとんどすべてのプロパティは、大文字と小文字を区別しないマッチングの影響を受けないことに注意してください。つまり、 &lt;code&gt;/i&lt;/code&gt; 正規表現修飾子を追加しても、一致するものは変更されません。影響を受けるセットは2つあります。最初のセットである &lt;code&gt;Uppercase_Letter&lt;/code&gt; 、 &lt;code&gt;Lowercase_Letter&lt;/code&gt; 、及び &lt;code&gt;Titlecase_Letter&lt;/code&gt; 一致すべては、 &lt;code&gt;Cased_Letter&lt;/code&gt; を下 &lt;code&gt;/i&lt;/code&gt; マッチング。第二のセットは、 &lt;code&gt;Uppercase&lt;/code&gt; 、 &lt;code&gt;Lowercase&lt;/code&gt; 、および &lt;code&gt;Titlecase&lt;/code&gt; 一致すべては、 &lt;code&gt;Cased&lt;/code&gt; の下 &lt;code&gt;/i&lt;/code&gt; マッチング。 （これらのセットの違いは、ローマ数字など、大文字と小文字の両方があるため、 &lt;code&gt;Cased&lt;/code&gt; ですが、文字とは見なされないため、 &lt;code&gt;Cased_Letter&lt;/code&gt; ではありません。これらは実際には &lt;code&gt;Letter_Number&lt;/code&gt; です。）このセットには、サブセット &lt;code&gt;PosixUpper&lt;/code&gt; および &lt;code&gt;PosixLower&lt;/code&gt; も含まれます。これらはどちらも &lt;code&gt;/i&lt;/code&gt; の下で &lt;code&gt;PosixAlpha&lt;/code&gt; に一致します。</target>
        </trans-unit>
        <trans-unit id="410bccdb373a09459be0a143786fbdbb58b254bf" translate="yes" xml:space="preserve">
          <source>Note that although &lt;code&gt;$!&lt;/code&gt; appears to be a dual-valued variable, it is actually implemented as a magical variable inside the interpreter:</source>
          <target state="translated">なおものの &lt;code&gt;$!&lt;/code&gt; 二重値変数のように見えますが、実際にはインタープリター内に魔法の変数として実装されています。</target>
        </trans-unit>
        <trans-unit id="bd7c4807ae2f9f37a6e187d7bd38a50b276ee8ea" translate="yes" xml:space="preserve">
          <source>Note that although &lt;code&gt;$!&lt;/code&gt; appears to be dual-valued variable, it is actually implemented using a tied scalar:</source>
          <target state="translated">ただし、 &lt;code&gt;$!&lt;/code&gt; 二重値変数のように見えますが、実際にはタイスカラーを使用して実装されています。</target>
        </trans-unit>
        <trans-unit id="606458ff6017524382f12a8fd94125b35d1b63bc" translate="yes" xml:space="preserve">
          <source>Note that an &quot;=over&quot; ... &quot;=back&quot; region should have some content. That is, authors should not have an empty region like this:</source>
          <target state="translated">over&quot; ...&quot;=over&quot; ...&quot;=back&quot; リージョンは、何らかの内容を持つべきであることに注意してください。&quot;back&quot; リージョンは何らかの内容を持つべきです。つまり、作者はこのような空の領域を持つべきではありません。</target>
        </trans-unit>
        <trans-unit id="8f873ccce2134d828b1fb4400b87f6f3fdbeb512" translate="yes" xml:space="preserve">
          <source>Note that an INVARIANT character (i.e. ASCII on non-EBCDIC machines) is a valid UTF-8 character.</source>
          <target state="translated">INVARIANT キ ャ ラ ク タ (すなわち非 EBCDIC マシン上の ASCII)は有効な UTF-8 キ ャ ラ ク タ であ る こ と に注意 し て く だ さ い。</target>
        </trans-unit>
        <trans-unit id="587e23eccc6cff27f015e2a6ec6c9aa159cb0d1a" translate="yes" xml:space="preserve">
          <source>Note that an exit() or die() that is compiled 'hushed' because of &quot;use vmsish&quot; is not un-hushed by calling vmsish::hushed(0) at runtime.</source>
          <target state="translated">use vmsish&quot; のために &quot;hashed&quot; コンパイルされた exit()や die()は、実行時に vmsish::hashed(0)を呼び出しても、hashed が解除されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="81d903b0a8613702e9500c6611625b2061527ec5" translate="yes" xml:space="preserve">
          <source>Note that an implication of this form is that there are identifiers only legal under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt;, and vice-versa, for example the identifier &lt;code&gt;$&amp;eacute;tat&lt;/code&gt; is legal under &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt;, but is otherwise considered to be the single character variable &lt;code&gt;$&amp;eacute;&lt;/code&gt; followed by the bareword &lt;code&gt;&quot;tat&quot;&lt;/code&gt;, the combination of which is a syntax error.</source>
          <target state="translated">この形式の意味するところは、 &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; では有効な識別子のみであり、その逆も同様です。たとえば、識別子 &lt;code&gt;$&amp;eacute;tat&lt;/code&gt; は &lt;code&gt;&quot;use utf8&quot;&lt;/code&gt; では有効ですが、それ以外の場合は単一文字変数 &lt;code&gt;$&amp;eacute;&lt;/code&gt; と見なされます。&amp;eacute;の後にベアワード &lt;code&gt;&quot;tat&quot;&lt;/code&gt; が続きます。これらの組み合わせは構文エラーです。</target>
        </trans-unit>
        <trans-unit id="a51bafab03bc7a99a9ff353e9d7023e5249a4ecb" translate="yes" xml:space="preserve">
          <source>Note that any &lt;code&gt;()&lt;/code&gt; constructs enclosed within this one will still capture unless the &lt;code&gt;/n&lt;/code&gt; modifier is in effect.</source>
          <target state="translated">&lt;code&gt;/n&lt;/code&gt; 修飾子が有効になっていない限り、これで囲まれた &lt;code&gt;()&lt;/code&gt; 構造は引き続きキャプチャされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="76d96be8f0f46d40e0807e85460543821cad6f82" translate="yes" xml:space="preserve">
          <source>Note that any filehandle being printed to under UTF-8 must be expecting UTF-8 in order to get good results and avoid Wide-character warnings. One way to do this for typical filehandles is to invoke perl with the &lt;code&gt;-C&lt;/code&gt;&amp;gt; parameter. (See &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;&quot;-C [number/list]&quot; in perlrun&lt;/a&gt;.</source>
          <target state="translated">良好な結果を得てワイド文字の警告を回避するには、UTF-8で出力されるファイルハンドルはUTF-8を予期している必要があることに注意してください。一般的なファイルハンドルに対してこれを行う1つの方法は、 &lt;code&gt;-C&lt;/code&gt; &amp;gt;パラメーターを指定してperlを呼び出すことです。（perlrunの&lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;「-C [番号/リスト]」を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2477a9523ad15c5452b9aa241b6f568c4bd6177" translate="yes" xml:space="preserve">
          <source>Note that any variables and functions that are not documented in this document (or in &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;) are considered for internal use only, and as such are subject to change without notice.</source>
          <target state="translated">このドキュメント（または&lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;）に記載されていない変数や関数は、内部使用のみを目的としており、予告なしに変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a6b66f44f204ce59d376598daa611217f2bbd286" translate="yes" xml:space="preserve">
          <source>Note that any variables and functions that are not documented in this manpages (or in &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;) are considered for internal use only, and as such are subject to change without notice.</source>
          <target state="translated">このマンページ（または&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;）に記載されていない変数や関数は、内部使用のみを目的としており、予告なしに変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ce41211a36e2b403696bfe4a4b1fe54c951c0f65" translate="yes" xml:space="preserve">
          <source>Note that anything inside a &lt;code&gt;\Q...\E&lt;/code&gt; stays unaffected by &lt;code&gt;/x&lt;/code&gt;. And note that &lt;code&gt;/x&lt;/code&gt; doesn't affect space interpretation within a single multi-character construct. For example in &lt;code&gt;\x{...}&lt;/code&gt; , regardless of the &lt;code&gt;/x&lt;/code&gt; modifier, there can be no spaces. Same for a &lt;a href=&quot;#Quantifiers&quot;&gt;quantifier&lt;/a&gt; such as &lt;code&gt;{3}&lt;/code&gt; or &lt;code&gt;{5,}&lt;/code&gt; . Similarly, &lt;code&gt;(?:...)&lt;/code&gt; can't have a space between the &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, and &lt;code&gt;:&lt;/code&gt; . Within any delimiters for such a construct, allowed spaces are not affected by &lt;code&gt;/x&lt;/code&gt;, and depend on the construct. For example, &lt;code&gt;\x{...}&lt;/code&gt; can't have spaces because hexadecimal numbers don't have spaces in them. But, Unicode properties can have spaces, so in &lt;code&gt;\p{...}&lt;/code&gt; there can be spaces that follow the Unicode rules, for which see &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\Q...\E&lt;/code&gt; 内のすべてのものが &lt;code&gt;/x&lt;/code&gt; の影響を受けないことに注意してください。また、 &lt;code&gt;/x&lt;/code&gt; は単一の複数文字構成内のスペースの解釈に影響を与えないことに注意してください。たとえば、 &lt;code&gt;\x{...}&lt;/code&gt; では、 &lt;code&gt;/x&lt;/code&gt; 修飾子に関係なく、スペースを含めることはできません。 &lt;code&gt;{3}&lt;/code&gt; や &lt;code&gt;{5,}&lt;/code&gt; などの&lt;a href=&quot;#Quantifiers&quot;&gt;数量詞&lt;/a&gt;についても同じです。同様に、 &lt;code&gt;(?:...)&lt;/code&gt; は、 &lt;code&gt;(&lt;/code&gt; 、 &lt;code&gt;?&lt;/code&gt; 、 &lt;code&gt;:&lt;/code&gt; の間にスペースを入れることはできません。そのような構成の区切り文字内では、許可されるスペースは &lt;code&gt;/x&lt;/code&gt; の影響を受けず、構成に依存します。たとえば、 &lt;code&gt;\x{...}&lt;/code&gt; 16進数にはスペースが含まれないため、スペースを含めることはできません。ただし、Unicodeプロパティにはスペース&lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;を含める&lt;/a&gt;ことができるため、 &lt;code&gt;\p{...}&lt;/code&gt; にはUnicodeルールに従うスペースを含めることができます。これについては、perlunipropsの\ p {}および\ P {}を介してアクセス可能なプロパティを参照してください。</target>
        </trans-unit>
        <trans-unit id="f395c3581775a33605e1a803ed3454f86e6d0f9b" translate="yes" xml:space="preserve">
          <source>Note that anything inside a &lt;code&gt;\Q...\E&lt;/code&gt; stays unaffected by &lt;code&gt;/x&lt;/code&gt;. And note that &lt;code&gt;/x&lt;/code&gt; doesn't affect space interpretation within a single multi-character construct. For example in &lt;code&gt;\x{...}&lt;/code&gt;, regardless of the &lt;code&gt;/x&lt;/code&gt; modifier, there can be no spaces. Same for a &lt;a href=&quot;#Quantifiers&quot;&gt;quantifier&lt;/a&gt; such as &lt;code&gt;{3}&lt;/code&gt; or &lt;code&gt;{5,}&lt;/code&gt;. Similarly, &lt;code&gt;(?:...)&lt;/code&gt; can't have a space between the &lt;code&gt;&quot;(&quot;&lt;/code&gt;, &lt;code&gt;&quot;?&quot;&lt;/code&gt;, and &lt;code&gt;&quot;:&quot;&lt;/code&gt;. Within any delimiters for such a construct, allowed spaces are not affected by &lt;code&gt;/x&lt;/code&gt;, and depend on the construct. For example, &lt;code&gt;\x{...}&lt;/code&gt; can't have spaces because hexadecimal numbers don't have spaces in them. But, Unicode properties can have spaces, so in &lt;code&gt;\p{...}&lt;/code&gt; there can be spaces that follow the Unicode rules, for which see &lt;a href=&quot;perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;&quot;Properties accessible through \p{} and \P{}&quot; in perluniprops&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\Q...\E&lt;/code&gt; 内のすべてが &lt;code&gt;/x&lt;/code&gt; の影響を受けないことに注意してください。また、 &lt;code&gt;/x&lt;/code&gt; は、単一の複数文字構成内のスペース解釈には影響しないことに注意してください。たとえば、 &lt;code&gt;\x{...}&lt;/code&gt; では、 &lt;code&gt;/x&lt;/code&gt; 修飾子に関係なく、スペースを含めることはできません。 &lt;code&gt;{3}&lt;/code&gt; や &lt;code&gt;{5,}&lt;/code&gt; などの&lt;a href=&quot;#Quantifiers&quot;&gt;数量詞&lt;/a&gt;についても同じです。同様に、 &lt;code&gt;(?:...)&lt;/code&gt; は、 &lt;code&gt;&quot;(&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;?&quot;&lt;/code&gt; 、および &lt;code&gt;&quot;:&quot;&lt;/code&gt; 間にスペースを含めることはできません。このような構成の区切り文字内では、許可されるスペースは &lt;code&gt;/x&lt;/code&gt; の影響を受けず、構成。たとえば、 &lt;code&gt;\x{...}&lt;/code&gt; 16進数にはスペースが含まれていないため、スペースを含めることはできません。ただし、Unicodeプロパティにはスペース&lt;a href=&quot;perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;を含める&lt;/a&gt;ことができるため、 &lt;code&gt;\p{...}&lt;/code&gt; には、Unicodeルールに従うスペースが含まれる場合があります。これについては、perlunipropsの「\ p {}および\ P {}からアクセスできるプロパティ」を参照してください。</target>
        </trans-unit>
        <trans-unit id="0fdc0e788793ca02998116be1ca2d6034cbab69c" translate="yes" xml:space="preserve">
          <source>Note that as of Perl 5.14, &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; will insert the named sequence into double-quoted strings, and &lt;code&gt;charnames::string_vianame(&quot;KATAKANA
LETTER AINU P&quot;)&lt;/code&gt; will return the same string this function does, but will also operate on character names that aren't named sequences, without you having to know which are which. See &lt;a href=&quot;../charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">Perl 5.14以降、 &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; は名前付きシーケンスを二重引用符で囲まれた文字列に挿入し、 &lt;code&gt;charnames::string_vianame(&quot;KATAKANA LETTER AINU P&quot;)&lt;/code&gt; はこの関数と同じ文字列を返しますが、また、シーケンスではない文字名を操作します。どちらがどれであるかを知る必要はありません。&lt;a href=&quot;../charnames&quot;&gt;charnamesを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="27d84df2d91f0e561094d3cfef990178b71accb1" translate="yes" xml:space="preserve">
          <source>Note that as of Perl 5.14, &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; will insert the named sequence into double-quoted strings, and &lt;code&gt;charnames::string_vianame(&quot;KATAKANA LETTER AINU P&quot;)&lt;/code&gt; will return the same string this function does, but will also operate on character names that aren't named sequences, without you having to know which are which. See &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">Perl 5.14以降、 &lt;code&gt;\N{KATAKANA LETTER AINU P}&lt;/code&gt; は名前付きシーケンスを二重引用符で囲まれた文字列に挿入し、 &lt;code&gt;charnames::string_vianame(&quot;KATAKANA LETTER AINU P&quot;)&lt;/code&gt; はこの関数と同じ文字列を返すことに注意してください。また、シーケンスに名前が付けられていない文字名を操作します。どれがどれであるかを知る必要はありません。&lt;a href=&quot;charnames&quot;&gt;charnamesを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e472cfdb1b217c8839b9da7d68aebc2ef451ccc9" translate="yes" xml:space="preserve">
          <source>Note that as of Perl 5.20, literal control characters in variable names are deprecated; and as of Perl 5.22, any other non-graphic characters are also deprecated.</source>
          <target state="translated">Perl 5.20では、変数名の中のリテラル制御文字は非推奨とされ、Perl 5.22ではその他の非図形文字も非推奨とされていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4a675b15092aa8c87c6f30bd02df31fd70694188" translate="yes" xml:space="preserve">
          <source>Note that atan2(0, 0) is not well-defined.</source>
          <target state="translated">atan2(0,0)はよく定義されていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="8fbf5b8aea29a3936ba6fef9526fd98f6b5784c6" translate="yes" xml:space="preserve">
          <source>Note that attribute handlers that are scheduled for the &lt;code&gt;BEGIN&lt;/code&gt; phase are handled as soon as the attribute is detected (i.e. before any subsequently defined &lt;code&gt;BEGIN&lt;/code&gt; blocks are executed).</source>
          <target state="translated">&lt;code&gt;BEGIN&lt;/code&gt; フェーズにスケジュールされている属性ハンドラーは、属性が検出されるとすぐに処理されます（つまり、その後定義された &lt;code&gt;BEGIN&lt;/code&gt; ブロックが実行される前）。</target>
        </trans-unit>
        <trans-unit id="0f24e592f4d8a1a531dda62544ac7d2f7b1bf174" translate="yes" xml:space="preserve">
          <source>Note that because &lt;b&gt;-i&lt;/b&gt; renames or deletes the original file before creating a new file of the same name, Unix-style soft and hard links will not be preserved.</source>
          <target state="translated">&lt;b&gt;-i&lt;/b&gt;は同じ名前の新しいファイルを作成する前に元のファイルの名前を変更または削除するため、Unixスタイルのソフトリンクとハードリンクは保持されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="b8849f4f72b8ea78a7d87446400823a7e27b0cb3" translate="yes" xml:space="preserve">
          <source>Note that because how the floating point formats work out, on the most common platforms signaling payload of zero is best avoided, since it might end up being identical to &lt;code&gt;+Inf&lt;/code&gt;.</source>
          <target state="translated">浮動小数点形式がどのように機能するかについては、最も一般的なプラットフォームでは、 &lt;code&gt;+Inf&lt;/code&gt; と同じになる可能性があるため、ゼロのシグナリングペイロードを回避するのが最善であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="49723b78c25f9f94694a955ddf0fb169c3bb02b1" translate="yes" xml:space="preserve">
          <source>Note that because multiple extensions may be using &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; or &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic, it is important for extensions to take extra care to avoid conflict. Typically only using the magic on objects blessed into the same class as the extension is sufficient. For &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; magic, it is usually a good idea to define an &lt;code&gt;MGVTBL&lt;/code&gt; , even if all its fields will be &lt;code&gt;0&lt;/code&gt; , so that individual &lt;code&gt;MAGIC&lt;/code&gt; pointers can be identified as a particular kind of magic using their magic virtual table. &lt;code&gt;mg_findext&lt;/code&gt; provides an easy way to do that:</source>
          <target state="translated">複数の拡張機能が &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; または &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; マジックを使用している可能性があるため、拡張機能が競合を回避するように細心の注意を払うことが重要です。通常、エクステンションと同じクラスにblessされたオブジェクトにマジックを使用するだけで十分です。 &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; の魔法、定義するために通常は良いアイデアです &lt;code&gt;MGVTBL&lt;/code&gt; をそのすべてのフィールドがされる場合でも、 &lt;code&gt;0&lt;/code&gt; 個々そうという、 &lt;code&gt;MAGIC&lt;/code&gt; のポインタがその魔法の仮想テーブルを使用して、魔法の特定の種類として同定することができます。 &lt;code&gt;mg_findext&lt;/code&gt; はそれを行う簡単な方法を提供します：</target>
        </trans-unit>
        <trans-unit id="cd112df3b0c7a62a90b0cf37e126e846a5257960" translate="yes" xml:space="preserve">
          <source>Note that because multiple extensions may be using &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; or &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic, it is important for extensions to take extra care to avoid conflict. Typically only using the magic on objects blessed into the same class as the extension is sufficient. For &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; magic, it is usually a good idea to define an &lt;code&gt;MGVTBL&lt;/code&gt;, even if all its fields will be &lt;code&gt;0&lt;/code&gt;, so that individual &lt;code&gt;MAGIC&lt;/code&gt; pointers can be identified as a particular kind of magic using their magic virtual table. &lt;code&gt;mg_findext&lt;/code&gt; provides an easy way to do that:</source>
          <target state="translated">複数の拡張機能が &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; または &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; マジックを使用している可能性があるため、拡張機能が競合を回避するために特別な注意を払うことが重要であることに注意してください。通常、拡張機能と同じクラスに祝福されたオブジェクトに魔法を使用するだけで十分です。 &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; の魔法、定義するために通常は良いアイデアです &lt;code&gt;MGVTBL&lt;/code&gt; をそのすべてのフィールドがされる場合でも、 &lt;code&gt;0&lt;/code&gt; 個々そうという、 &lt;code&gt;MAGIC&lt;/code&gt; のポインタがその魔法の仮想テーブルを使用して、魔法の特定の種類として同定することができます。 &lt;code&gt;mg_findext&lt;/code&gt; は、それを行う簡単な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="2432f753e906c1dd9f81b56a7cfbeac9aa989c16" translate="yes" xml:space="preserve">
          <source>Note that because of stupid OS/2 limitations the full path of the perl script is not available when you use &lt;code&gt;extproc&lt;/code&gt; , thus you are forced to use &lt;code&gt;-S&lt;/code&gt; perl switch, and your script should be on the &lt;code&gt;PATH&lt;/code&gt; . As a plus side, if you know a full path to your script, you may still start it with</source>
          <target state="translated">ばかげたOS / 2の制限のため、 &lt;code&gt;extproc&lt;/code&gt; を使用する場合、perlスクリプトのフルパスは使用できないため、 &lt;code&gt;-S&lt;/code&gt; perlスイッチを使用する必要があり、スクリプトは &lt;code&gt;PATH&lt;/code&gt; 上にある必要があります。プラスの面として、スクリプトへの完全なパスがわかっている場合でも、</target>
        </trans-unit>
        <trans-unit id="c787f61f07dfdba933460c5bff80047d250cdab7" translate="yes" xml:space="preserve">
          <source>Note that because of stupid OS/2 limitations the full path of the perl script is not available when you use &lt;code&gt;extproc&lt;/code&gt;, thus you are forced to use &lt;code&gt;-S&lt;/code&gt; perl switch, and your script should be on the &lt;code&gt;PATH&lt;/code&gt;. As a plus side, if you know a full path to your script, you may still start it with</source>
          <target state="translated">愚かなOS / 2の制限のため、 &lt;code&gt;extproc&lt;/code&gt; を使用する場合はperlスクリプトのフルパスを使用できないため、 &lt;code&gt;-S&lt;/code&gt; perlスイッチを使用する必要があり、スクリプトは &lt;code&gt;PATH&lt;/code&gt; 上にある必要があります。プラス面として、スクリプトへのフルパスがわかっている場合でも、次のコマンドで開始できます。</target>
        </trans-unit>
        <trans-unit id="ad5dd4afa174c9cef5b24c559737823b7753c820" translate="yes" xml:space="preserve">
          <source>Note that because this rendering was done on a non-threaded perl, the PADOPs in the previous examples are now SVOPs, and some (but not all) of the square brackets have been replaced by round ones. This is a subtle feature to provide some visual distinction between renderings on threaded and un-threaded perls.</source>
          <target state="translated">このレンダリングはスレッド化されていない Perl で行われたので、前の例の PADOP は SVOP になり、角括弧の一部 (すべてではありませんが)は丸括弧に置き換えられていることに注意してください。これは、スレッド化された Perl とスレッド化されていない Perl でのレンダリングを視覚的に区別するための微妙な機能です。</target>
        </trans-unit>
        <trans-unit id="e6d44ccabe09fa1f4e596936119e58147bb0fd41" translate="yes" xml:space="preserve">
          <source>Note that because we are operating on approximations of real numbers, these errors can happen when merely `too close' to the singularities listed above.</source>
          <target state="translated">我々は実数の近似を行っているので、上記の特異点に「近すぎる」というだけで、これらのエラーが発生することに注意してください。</target>
        </trans-unit>
        <trans-unit id="3cac802226be8e6c597ab4225af3fcdf654d037f" translate="yes" xml:space="preserve">
          <source>Note that both &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; in Perl are implemented directly using &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; in C. If &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) is in force then signed C integers are used, else unsigned C integers are used. Either way, the implementation isn't going to generate results larger than the size of the integer type Perl was built with (32 bits or 64 bits).</source>
          <target state="translated">注両方こと &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; と &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; Perlでは、使用して直接実装されて &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; と &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; C.場合のにおける &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; （参照&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;整数算術を&lt;/a&gt;次に署名されたC整数が使用される力であり、他の符号無しC整数が使用されます）。どちらの方法でも、Perlが構築された整数型のサイズ（32ビットまたは64ビット）よりも大きな結果を生成することはありません。</target>
        </trans-unit>
        <trans-unit id="04cf68d9424884dadb0aa2996784eb6ff505962d" translate="yes" xml:space="preserve">
          <source>Note that both &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; do not increment the reference count of the stored &lt;code&gt;val&lt;/code&gt; , which is the caller's responsibility. If these functions return a NULL value, the caller will usually have to decrement the reference count of &lt;code&gt;val&lt;/code&gt; to avoid a memory leak.</source>
          <target state="translated">&lt;code&gt;hv_store&lt;/code&gt; と &lt;code&gt;hv_store_ent&lt;/code&gt; はどちらも、保存された &lt;code&gt;val&lt;/code&gt; の参照カウントをインクリメントしないことに注意してください。これは、呼び出し側の責任です。これらの関数がNULL値を返す場合、呼び出し元は通常、メモリリークを回避するために &lt;code&gt;val&lt;/code&gt; の参照カウントをデクリメントする必要があります。</target>
        </trans-unit>
        <trans-unit id="621c69fc1e5d56916169e38ace21016b25be56a4" translate="yes" xml:space="preserve">
          <source>Note that both &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; do not increment the reference count of the stored &lt;code&gt;val&lt;/code&gt;, which is the caller's responsibility. If these functions return a NULL value, the caller will usually have to decrement the reference count of &lt;code&gt;val&lt;/code&gt; to avoid a memory leak.</source>
          <target state="translated">&lt;code&gt;hv_store&lt;/code&gt; と &lt;code&gt;hv_store_ent&lt;/code&gt; はどちらも、保存された &lt;code&gt;val&lt;/code&gt; の参照カウントをインクリメントしないことに注意してください。これは呼び出し元の責任です。これらの関数がNULL値を返す場合、呼び出し元は通常、メモリリークを回避するために、 &lt;code&gt;val&lt;/code&gt; の参照カウントをデクリメントする必要があります。</target>
        </trans-unit>
        <trans-unit id="74a9256e12aa22e857528719131785d55699987c" translate="yes" xml:space="preserve">
          <source>Note that both paths are assumed to have a notation that distinguishes a directory path (with trailing ':') from a file path (without trailing ':').</source>
          <target state="translated">どちらのパスも、ディレクトリパス (末尾に ':' を付けたもの)とファイルパス (末尾に ':' を付けないもの)を区別するための表記法を想定していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="faee99938a7847d18bb03c4600be6dd36dc0274e" translate="yes" xml:space="preserve">
          <source>Note that both the &lt;code&gt;CanonicalName&lt;/code&gt; and &lt;code&gt;FilterName&lt;/code&gt; options can modify the value used for the</source>
          <target state="translated">&lt;code&gt;CanonicalName&lt;/code&gt; オプションと &lt;code&gt;FilterName&lt;/code&gt; オプションの両方で、に使用される値を変更できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0e8fd56db9f2f95bb2076209ba3c59af9c411003" translate="yes" xml:space="preserve">
          <source>Note that both the &lt;code&gt;CanonicalName&lt;/code&gt; and &lt;code&gt;FilterName&lt;/code&gt; options can modify the value used for the zip filename header field.</source>
          <target state="translated">&lt;code&gt;CanonicalName&lt;/code&gt; オプションと &lt;code&gt;FilterName&lt;/code&gt; オプションの両方で、zipファイル名のヘッダーフィールドに使用される値を変更できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b4c874fe97ef7da4bd4b4b5db7330a5fe9438bed" translate="yes" xml:space="preserve">
          <source>Note that bsd_glob() deviates from POSIX and FreeBSD glob(3) behaviour by not considering &lt;code&gt;ENOENT&lt;/code&gt; and &lt;code&gt;ENOTDIR&lt;/code&gt; as errors - bsd_glob() will continue processing despite those errors, unless the &lt;code&gt;GLOB_ERR&lt;/code&gt; flag is set.</source>
          <target state="translated">bsd_glob（）は、 &lt;code&gt;ENOENT&lt;/code&gt; および &lt;code&gt;ENOTDIR&lt;/code&gt; をエラーと見なさないことにより、POSIXおよびFreeBSDのglob（3）の動作から逸脱していることに注意してください。bsd_glob（）は、 &lt;code&gt;GLOB_ERR&lt;/code&gt; フラグが設定されていない限り、これらのエラーにもかかわらず処理を続行します。</target>
        </trans-unit>
        <trans-unit id="bacd6d900d14ad3f25c92e37f8d7ca4d2e6dc3f9" translate="yes" xml:space="preserve">
          <source>Note that calling &lt;a href=&quot;perlfunc#delete-EXPR&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt; on array values is strongly discouraged.</source>
          <target state="translated">配列値に対して&lt;a href=&quot;perlfunc#delete-EXPR&quot;&gt; &lt;code&gt;delete&lt;/code&gt; &lt;/a&gt;を呼び出すことは強くお勧めしません。</target>
        </trans-unit>
        <trans-unit id="0c998cb784e028342e5006462f8a42c5345c1974" translate="yes" xml:space="preserve">
          <source>Note that calls to the platform's underlying &lt;code&gt;getaddrinfo(3)&lt;/code&gt; function may block. If &lt;code&gt;IO::Socket::IP&lt;/code&gt; has to perform this lookup, the constructor will block even when in non-blocking mode.</source>
          <target state="translated">プラットフォームの基礎となる &lt;code&gt;getaddrinfo(3)&lt;/code&gt; 関数の呼び出しがブロックされる可能性があることに注意してください。 &lt;code&gt;IO::Socket::IP&lt;/code&gt; がこのルックアップを実行する必要がある場合、コンストラクターは非ブロックモードでもブロックします。</target>
        </trans-unit>
        <trans-unit id="a4b82a298fa226e67135978079ffa22b87e99940" translate="yes" xml:space="preserve">
          <source>Note that capture groups matched inside of recursion are not accessible after the recursion returns, so the extra layer of capturing groups is necessary. Thus &lt;code&gt;$+{NAME_PAT}&lt;/code&gt; would not be defined even though &lt;code&gt;$+{NAME}&lt;/code&gt; would be.</source>
          <target state="translated">再帰の内部で一致したキャプチャグループは、再帰が戻った後はアクセスできないため、キャプチャグループの追加のレイヤーが必要であることに注意してください。したがって、 &lt;code&gt;$+{NAME_PAT}&lt;/code&gt; は &lt;code&gt;$+{NAME}&lt;/code&gt; が定義されていても定義されません。</target>
        </trans-unit>
        <trans-unit id="bc76dc97a1c19045dc8a76b9a6b2095a51024d2b" translate="yes" xml:space="preserve">
          <source>Note that certain exponentiation expressions are ill-defined: these include &lt;code&gt;0**0&lt;/code&gt; , &lt;code&gt;1**Inf&lt;/code&gt; , and &lt;code&gt;Inf**0&lt;/code&gt; . Do not expect any particular results from these special cases, the results are platform-dependent.</source>
          <target state="translated">これらが含まれます：特定の指数表現が不明確であることに注意してください &lt;code&gt;0**0&lt;/code&gt; 、 &lt;code&gt;1**Inf&lt;/code&gt; 、と &lt;code&gt;Inf**0&lt;/code&gt; 。これらの特殊なケースからの特定の結果を期待しないでください。結果はプラットフォームに依存します。</target>
        </trans-unit>
        <trans-unit id="3494a62839407764105a4d292aa5c1e195c2757d" translate="yes" xml:space="preserve">
          <source>Note that certain exponentiation expressions are ill-defined: these include &lt;code&gt;0**0&lt;/code&gt;, &lt;code&gt;1**Inf&lt;/code&gt;, and &lt;code&gt;Inf**0&lt;/code&gt;. Do not expect any particular results from these special cases, the results are platform-dependent.</source>
          <target state="translated">これらが含まれます：特定の指数表現が不明確であることに注意してください &lt;code&gt;0**0&lt;/code&gt; 、 &lt;code&gt;1**Inf&lt;/code&gt; 、と &lt;code&gt;Inf**0&lt;/code&gt; 。これらの特殊なケースから特定の結果を期待しないでください。結果はプラットフォームに依存します。</target>
        </trans-unit>
        <trans-unit id="ae568ca1008d1cccb4f94c7517bbb753d06bd905" translate="yes" xml:space="preserve">
          <source>Note that characters from 128 to 255 (inclusive) are by default internally not encoded as UTF-8 for backward compatibility reasons.</source>
          <target state="translated">128 から 255 までの文字(含む)は、下位互換性の理由から、デフォルトでは内部的に UTF-8 としてエンコードされていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="8a46ebdf91483bc350551ae23b26255499157816" translate="yes" xml:space="preserve">
          <source>Note that checking for a &lt;code&gt;%DOES&lt;/code&gt; hash is an &lt;code&gt;autodie&lt;/code&gt;-only short-cut. Other modules do not use this mechanism for checking roles, although you can use the &lt;code&gt;Class::DOES&lt;/code&gt; module from the CPAN to allow it.</source>
          <target state="translated">&lt;code&gt;%DOES&lt;/code&gt; ハッシュのチェックは、 &lt;code&gt;autodie&lt;/code&gt; ダイのみのショートカットであることに注意してください。他のモジュールはロールのチェックにこのメカニズムを使用しませんが、CPANの &lt;code&gt;Class::DOES&lt;/code&gt; モジュールを使用して許可することができます。</target>
        </trans-unit>
        <trans-unit id="20fe49f9b13e959950bbe4e0a6e4e652aef94a09" translate="yes" xml:space="preserve">
          <source>Note that clients who do not support the &lt;code&gt;GNU Extended Header&lt;/code&gt; feature will not be able to read these archives. Such clients include tars on &lt;code&gt;Solaris&lt;/code&gt; , &lt;code&gt;Irix&lt;/code&gt; and &lt;code&gt;AIX&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;GNU Extended Header&lt;/code&gt; 機能をサポートしていないクライアントは、これらのアーカイブを読み取ることができないことに注意してください。このようなクライアントには、 &lt;code&gt;Solaris&lt;/code&gt; 、 &lt;code&gt;Irix&lt;/code&gt; 、 &lt;code&gt;AIX&lt;/code&gt; のtarが含まれます。</target>
        </trans-unit>
        <trans-unit id="aae32a0db7b8c17096153a5cf305d70abda69477" translate="yes" xml:space="preserve">
          <source>Note that clients who do not support the &lt;code&gt;GNU Extended Header&lt;/code&gt; feature will not be able to read these archives. Such clients include tars on &lt;code&gt;Solaris&lt;/code&gt;, &lt;code&gt;Irix&lt;/code&gt; and &lt;code&gt;AIX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GNU Extended Header&lt;/code&gt; 機能をサポートしていないクライアントは、これらのアーカイブを読み取ることができないことに注意してください。このようなクライアントには、 &lt;code&gt;Solaris&lt;/code&gt; 、 &lt;code&gt;Irix&lt;/code&gt; 、および &lt;code&gt;AIX&lt;/code&gt; 上のtarが含まれます。</target>
        </trans-unit>
        <trans-unit id="1fce890d3f4b569eee4d4fb3d808316a6c987e62" translate="yes" xml:space="preserve">
          <source>Note that codes 6 (rapid blink) and 9 (strike-through) are specified in ANSI X3.64 and ECMA-048 but are not commonly supported by most displays and emulators and therefore aren't supported by this module at the present time. ECMA-048 also specifies a large number of other attributes, including a sequence of attributes for font changes, Fraktur characters, double-underlining, framing, circling, and overlining. As none of these attributes are widely supported or useful, they also aren't currently supported by this module.</source>
          <target state="translated">コード6(急速点滅)と9(ストライクスルー)は、ANSI X3.64とECMA-048で指定されていますが、ほとんどのディスプレイやエミュレータでは一般的にサポートされていないため、現時点ではこのモジュールではサポートされていないことに注意してください。ECMA-048はまた、フォント変更、Fraktur文字、二重下線、フレーミング、丸め、オーバーラインのための一連の属性を含む、多数の他の属性を指定しています。これらの属性はどれも広くサポートされておらず有用ではないので、現在このモジュールではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="d50e349cf31b07ee4610e705d5521fb0f229097d" translate="yes" xml:space="preserve">
          <source>Note that codes 6 (rapid blink) and 9 (strike-through) are specified in ANSI X3.64 and ECMA-048 but are not commonly supported by most displays and emulators and therefore aren't supported by this module. ECMA-048 also specifies a large number of other attributes, including a sequence of attributes for font changes, Fraktur characters, double-underlining, framing, circling, and overlining. As none of these attributes are widely supported or useful, they also aren't currently supported by this module.</source>
          <target state="translated">コード6(ラピッドブリンク)と9(ストライクスルー)は、ANSI X3.64とECMA-048で指定されていますが、ほとんどのディスプレイやエミュレータでは一般的にサポートされていないため、このモジュールではサポートされていないことに注意してください。ECMA-048はまた、フォント変更、Fraktur文字、二重下線、フレーミング、丸め、オーバーラインのための一連の属性を含む、多数の他の属性を指定しています。これらの属性はどれも広くサポートされていないし有用ではないので、現在このモジュールではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="701f822191abdf1e19724503033550d3adb9a3d3" translate="yes" xml:space="preserve">
          <source>Note that coercing an arbitrary scalar into a plain PV will potentially strip useful data from it. For example if the SV was &lt;code&gt;SvROK&lt;/code&gt; , then the referent will have its reference count decremented, and the SV itself may be converted to an &lt;code&gt;SvPOK&lt;/code&gt; scalar with a string buffer containing a value such as &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt; .</source>
          <target state="translated">任意のスカラーをプレーンPVに強制変換すると、そこから有用なデータが削除される可能性があることに注意してください。たとえば、SVが &lt;code&gt;SvROK&lt;/code&gt; の場合、リファレントの参照カウントはデクリメントされ、SV自体は &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt; などの値を含む文字列バッファーを使用して &lt;code&gt;SvPOK&lt;/code&gt; スカラーに変換される場合があります。</target>
        </trans-unit>
        <trans-unit id="a47c04c6a9f8c8144c760b18adcdfe977bf88a30" translate="yes" xml:space="preserve">
          <source>Note that coercing an arbitrary scalar into a plain PV will potentially strip useful data from it. For example if the SV was &lt;code&gt;SvROK&lt;/code&gt;, then the referent will have its reference count decremented, and the SV itself may be converted to an &lt;code&gt;SvPOK&lt;/code&gt; scalar with a string buffer containing a value such as &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt;.</source>
          <target state="translated">任意のスカラーをプレーンPVに強制すると、有用なデータが削除される可能性があることに注意してください。たとえば、SVが &lt;code&gt;SvROK&lt;/code&gt; の場合、指示対象の参照カウントがデクリメントされ、SV自体が &lt;code&gt;&quot;ARRAY(0x1234)&quot;&lt;/code&gt; などの値を含む文字列バッファーを使用して &lt;code&gt;SvPOK&lt;/code&gt; スカラーに変換される場合があります。</target>
        </trans-unit>
        <trans-unit id="c860f546e898e4ab8af10e9688384776e80d8690" translate="yes" xml:space="preserve">
          <source>Note that connected() considers a half-open TCP socket to be &quot;in a connected state&quot;. Specifically, connected() does not distinguish between the &lt;b&gt;ESTABLISHED&lt;/b&gt; and &lt;b&gt;CLOSE-WAIT&lt;/b&gt; TCP states; it returns the peer address, rather than undef, in either case. Thus, in general, connected() cannot be used to reliably learn whether the peer has initiated a graceful shutdown because in most cases (see below) the local TCP state machine remains in &lt;b&gt;CLOSE-WAIT&lt;/b&gt; until the local application calls shutdown() or close(); only at that point does connected() return undef.</source>
          <target state="translated">connected（）は、ハーフオープンのTCPソケットを「接続状態」と見なします。具体的には、connected（）は&lt;b&gt;ESTABLISHED&lt;/b&gt;と&lt;b&gt;CLOSE-WAIT&lt;/b&gt; TCP状態を区別しません。どちらの場合も、undefではなく、ピアアドレスを返します。したがって、一般に、connected（）を使用して、ピアが正常なシャットダウンを開始したかどうかを確実に知ることはできません。これは、ほとんどの場合（下記を参照）、ローカルアプリケーションがshutdown（）またはcloseを呼び出すまで、ローカルTCPステートマシンが&lt;b&gt;CLOSE-WAITの&lt;/b&gt;ままであるためです。 （）;その時点でのみ、connected（）はundefを返します。</target>
        </trans-unit>
        <trans-unit id="4c163cf186643a94245d42938672412776fa5e48" translate="yes" xml:space="preserve">
          <source>Note that currently some test scripts may fail when run in parallel (most notably</source>
          <target state="translated">現在、いくつかのテストスクリプトを並行して実行すると失敗する可能性があることに注意してください(特に</target>
        </trans-unit>
        <trans-unit id="fab55f641e790811b170e8b9128a927c617d8c7b" translate="yes" xml:space="preserve">
          <source>Note that define_alias() will not be able to override the canonical name of encodings. Encodings are first looked up by canonical name before potential aliases are tried.</source>
          <target state="translated">define_alias()はエンコーディングの正規名をオーバーライドできないことに注意してください。エンコーディングは、潜在的なエイリアスが試される前にまず正規名で検索されます。</target>
        </trans-unit>
        <trans-unit id="da1de0e37193fb693b5c5e6bff7827d4423ee163" translate="yes" xml:space="preserve">
          <source>Note that despite the existence of this optag a memory resource attack may still be possible using only :base_core ops.</source>
          <target state="translated">この optag が存在するにもかかわらず、 :base_core ops のみを使用してメモリリソース攻撃が可能である可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8256313554b42c8373b7bc367151c3b74d8cc5fc" translate="yes" xml:space="preserve">
          <source>Note that dot (</source>
          <target state="translated">ドット(</target>
        </trans-unit>
        <trans-unit id="765abb42fa3dbbf2af93a7f1e80231e5f09ac37f" translate="yes" xml:space="preserve">
          <source>Note that due to excessive paranoia, if $Getopt::Std::STANDARD_HELP_VERSION isn't true (the default is false), then the messages are printed on STDERR, and the processing continues after the messages are printed. This being the opposite of the standard-conforming behaviour, it is strongly recommended to set $Getopt::Std::STANDARD_HELP_VERSION to true.</source>
          <target state="translated">過度のパラノイアにより、$Getopt::Std::STANDARD_HELP_VERSIONがtrueでない場合(デフォルトはfalse)、メッセージはSTDERRに出力され、メッセージが出力された後も処理は続行されることに注意してください。これは標準に準拠した動作とは逆で、 $Getopt::Std::STANDARD_HELP_VERSION を true に設定することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="f123bfd592be78aee28a3c608d5e5a65fa7978a4" translate="yes" xml:space="preserve">
          <source>Note that due to how &lt;code&gt;%^H&lt;/code&gt; works, some of these utilities are only useful during the compilation phase of a perl module and relies on the internals of how perl handles references in &lt;code&gt;%^H&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;%^H&lt;/code&gt; がどのように機能するかにより、これらのユーティリティの一部はperlモジュールのコンパイルフェーズでのみ有用であり、perlが &lt;code&gt;%^H&lt;/code&gt; 参照を処理する方法の内部に依存していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1bbc11a7c1c533941b49be5f36414035e1261338" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;pp_&lt;/code&gt; function is expected to return a pointer to the next op. Calls to perl subs (and eval blocks) are handled within the same runops loop, and do not consume extra space on the C stack. For example, &lt;code&gt;pp_entersub&lt;/code&gt; and &lt;code&gt;pp_entertry&lt;/code&gt; just push a &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt; block struct onto the context stack which contain the address of the op following the sub call or eval. They then return the first op of that sub or eval block, and so execution continues of that sub or block. Later, a &lt;code&gt;pp_leavesub&lt;/code&gt; or &lt;code&gt;pp_leavetry&lt;/code&gt; op pops the &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt; , retrieves the return op from it, and returns it.</source>
          <target state="translated">各 &lt;code&gt;pp_&lt;/code&gt; 関数は、次のopへのポインタを返すことが期待されていることに注意してください。 perl subs（およびevalブロック）の呼び出しは、同じrunopsループ内で処理され、Cスタックの余分なスペースを消費しません。たとえば、 &lt;code&gt;pp_entersub&lt;/code&gt; と &lt;code&gt;pp_entertry&lt;/code&gt; は、 &lt;code&gt;CxSUB&lt;/code&gt; または &lt;code&gt;CxEVAL&lt;/code&gt; ブロック構造体を、sub呼び出しまたはevalに続くopのアドレスを含むコンテキストスタックにプッシュするだけです。次に、そのsubまたはevalブロックの最初の操作を返すため、そのsubまたはブロックの実行が続行されます。その後、 &lt;code&gt;pp_leavesub&lt;/code&gt; または &lt;code&gt;pp_leavetry&lt;/code&gt; opは &lt;code&gt;CxSUB&lt;/code&gt; または &lt;code&gt;CxEVAL&lt;/code&gt; をポップし、そこからreturn opを取得して返します。</target>
        </trans-unit>
        <trans-unit id="88c1f48b446d24b42913aa2c3b31a8759cf531cc" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;pp_&lt;/code&gt; function is expected to return a pointer to the next op. Calls to perl subs (and eval blocks) are handled within the same runops loop, and do not consume extra space on the C stack. For example, &lt;code&gt;pp_entersub&lt;/code&gt; and &lt;code&gt;pp_entertry&lt;/code&gt; just push a &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt; block struct onto the context stack which contain the address of the op following the sub call or eval. They then return the first op of that sub or eval block, and so execution continues of that sub or block. Later, a &lt;code&gt;pp_leavesub&lt;/code&gt; or &lt;code&gt;pp_leavetry&lt;/code&gt; op pops the &lt;code&gt;CxSUB&lt;/code&gt; or &lt;code&gt;CxEVAL&lt;/code&gt;, retrieves the return op from it, and returns it.</source>
          <target state="translated">各 &lt;code&gt;pp_&lt;/code&gt; 関数は、次の操作へのポインターを返すことが期待されていることに注意してください。 perl subs（およびevalブロック）の呼び出しは同じrunopsループ内で処理され、Cスタックの余分なスペースを消費しません。たとえば、 &lt;code&gt;pp_entersub&lt;/code&gt; と &lt;code&gt;pp_entertry&lt;/code&gt; は、 &lt;code&gt;CxSUB&lt;/code&gt; または &lt;code&gt;CxEVAL&lt;/code&gt; ブロック構造体を、サブ呼び出しまたはevalに続くopのアドレスを含むコンテキストスタックにプッシュするだけです。次に、そのサブブロックまたは評価ブロックの最初の操作を返すため、そのサブブロックまたはブロックの実行が続行されます。その後、 &lt;code&gt;pp_leavesub&lt;/code&gt; または &lt;code&gt;pp_leavetry&lt;/code&gt; opがポップ &lt;code&gt;CxSUB&lt;/code&gt; または &lt;code&gt;CxEVAL&lt;/code&gt; を、それからの戻りオペアンプを取得し、それを返します。</target>
        </trans-unit>
        <trans-unit id="420d7847072074bbd6eaf28b4c7884f7445e96dd" translate="yes" xml:space="preserve">
          <source>Note that each of these return &lt;code&gt;$self&lt;/code&gt; when you call them as &lt;code&gt;$self-&amp;gt;&lt;i&gt;whatever(value)&lt;/i&gt;&lt;/code&gt;. That's so that you can chain together set-attribute calls like this:</source>
          <target state="translated">&lt;code&gt;$self-&amp;gt;&lt;i&gt;whatever(value)&lt;/i&gt;&lt;/code&gt; &lt;i&gt;whatever（value）&lt;/i&gt;として呼び出すと、これらはそれぞれ &lt;code&gt;$self&lt;/code&gt; 返すことに注意してください。これは、次のようなset-attribute呼び出しをチェーンできるようにするためです。&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="51d2022d4221c4239f7b2040e5d01a22869c3e3c" translate="yes" xml:space="preserve">
          <source>Note that even though SunOS and Solaris are binary compatible, these values are different. Go figure.</source>
          <target state="translated">SunOSとSolarisはバイナリ互換性があるにもかかわらず、これらの値は異なることに注意してください。図にしてみましょう。</target>
        </trans-unit>
        <trans-unit id="8c3fc5526126d228e7dc152e5bae2056ec1d2dd9" translate="yes" xml:space="preserve">
          <source>Note that failed case-changing operations done as a result of case-insensitive &lt;code&gt;/i&lt;/code&gt; regular expression matching will show up in this warning as having the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; operation (as that is what the regular expression engine calls behind the scenes.)</source>
          <target state="translated">大文字と小文字を区別しない &lt;code&gt;/i&lt;/code&gt; 正規表現の一致の結果として実行された失敗した大文字と小文字の変更操作は、 &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 操作があるとこの警告に表示されることに注意してください（これは、正規表現エンジンが舞台裏で呼び出すものです）。</target>
        </trans-unit>
        <trans-unit id="50700c4c785fb49bbf6b2d46cdd32517f497bd69" translate="yes" xml:space="preserve">
          <source>Note that failed case-changing operations done as a result of case-insensitive &lt;code&gt;/i&lt;/code&gt; regular expression matching will show up in this warning as having the &lt;code&gt;fc&lt;/code&gt; operation (as that is what the regular expression engine calls behind the scenes.)</source>
          <target state="translated">大文字と小文字を区別しない &lt;code&gt;/i&lt;/code&gt; 正規表現の一致の結果として行われた失敗した大文字と小文字の変更操作は、この警告に &lt;code&gt;fc&lt;/code&gt; 操作があるものとして表示されることに注意してください（これは、正規表現エンジンがバックグラウンドで呼び出すものです）。</target>
        </trans-unit>
        <trans-unit id="8661f786e43fee3fd71c6daeb5a91a3c5f42f424" translate="yes" xml:space="preserve">
          <source>Note that flushing can seriously degrade the compression ratio, so it should only be used to terminate a decompression (using &lt;code&gt;Z_FINISH&lt;/code&gt; ) or when you want to create a</source>
          <target state="translated">フラッシュは圧縮率を大幅に低下させる可能性があるため、解凍を終了する（ &lt;code&gt;Z_FINISH&lt;/code&gt; を使用して）か、または</target>
        </trans-unit>
        <trans-unit id="4b30f403949fb025e96fa50a8f6344798f310af3" translate="yes" xml:space="preserve">
          <source>Note that flushing can seriously degrade the compression ratio, so it should only be used to terminate a decompression (using &lt;code&gt;Z_FINISH&lt;/code&gt;) or when you want to create a</source>
          <target state="translated">フラッシュは圧縮率を大幅に低下させる可能性があるため、解凍を終了する場合（ &lt;code&gt;Z_FINISH&lt;/code&gt; を使用）または作成する場合にのみ使用する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a95fd032f7a2402cab6502921fb63c15d3283b35" translate="yes" xml:space="preserve">
          <source>Note that for control characters (&lt;code&gt;Gc=cc&lt;/code&gt; ), Unicode's data files have the string &quot;&lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; &quot;, but the real name of each of these characters is the empty string. This function returns that real name, the empty string. (There are names for these characters, but they are considered aliases, not the Name property name, and are contained in the &lt;code&gt;Name_Alias&lt;/code&gt; property.)</source>
          <target state="translated">制御文字（ &lt;code&gt;Gc=cc&lt;/code&gt; ）の場合、Unicodeのデータファイルには文字列 &quot; &lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; &quot;がありますが、これらの各文字の実際の名前は空の文字列です。この関数は、実際の名前である空の文字列を返します。（これらの文字には名前がありますが、それらはNameプロパティ名ではなくエイリアスと見なされ、 &lt;code&gt;Name_Alias&lt;/code&gt; プロパティに含まれています。）</target>
        </trans-unit>
        <trans-unit id="f8932792e5f906f3f8b41da393da4b0b602a3cd6" translate="yes" xml:space="preserve">
          <source>Note that for control characters (&lt;code&gt;Gc=cc&lt;/code&gt;), Unicode's data files have the string &quot;&lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt;&quot;, but the real name of each of these characters is the empty string. This function returns that real name, the empty string. (There are names for these characters, but they are considered aliases, not the Name property name, and are contained in the &lt;code&gt;Name_Alias&lt;/code&gt; property.)</source>
          <target state="translated">制御文字（ &lt;code&gt;Gc=cc&lt;/code&gt; ）の場合、Unicodeのデータファイルには文字列 &quot; &lt;code&gt;&amp;lt;control&amp;gt;&lt;/code&gt; &quot;がありますが、これらの各文字の実際の名前は空の文字列であることに注意してください。この関数は、その実名である空の文字列を返します。（これらの文字には名前がありますが、Nameプロパティ名ではなくエイリアスと見なされ、 &lt;code&gt;Name_Alias&lt;/code&gt; プロパティに含まれています。）</target>
        </trans-unit>
        <trans-unit id="bc65a24a4a2d5395b160b7910a7ec94be07f4893" translate="yes" xml:space="preserve">
          <source>Note that for example the Series 60 2.0 VC SDK installation talks about ActivePerl build 518, which does no more (as of mid-2005) exist at the ActiveState website. The ActivePerl 5.8.4 build 810 was used successfully for compiling Perl on Symbian. The 5.6.x ActivePerls do not work.</source>
          <target state="translated">例えば、Series 60 2.0 VC SDKのインストールでは、ActivePerl build 518について説明していますが、ActiveStateのウェブサイトには(2005年半ばの時点で)存在しません。ActivePerl 5.8.4 build 810 は、Symbian 上で Perl をコンパイルするために正常に使用されました。5.6.xのActivePerlは動作しません。</target>
        </trans-unit>
        <trans-unit id="0ed7cbcc3a273da5d5e361c4e690dfc2af7612b3" translate="yes" xml:space="preserve">
          <source>Note that for internal reasons, all precompiled regexps (&lt;code&gt;qr/.../&lt;/code&gt;) are blessed references; thus &lt;code&gt;ref()&lt;/code&gt; returns the package name string &lt;code&gt;&quot;Regexp&quot;&lt;/code&gt; on these but &lt;code&gt;reftype()&lt;/code&gt; will return the underlying C structure type of &lt;code&gt;&quot;REGEXP&quot;&lt;/code&gt; in all capitals.</source>
          <target state="translated">内部的な理由により、プリコンパイルされたすべての正規表現（ &lt;code&gt;qr/.../&lt;/code&gt; ）は祝福された参照であることに注意してください。したがって、 &lt;code&gt;ref()&lt;/code&gt; はこれらのパッケージ名文字列 &lt;code&gt;&quot;Regexp&quot;&lt;/code&gt; を返しますが、 &lt;code&gt;reftype()&lt;/code&gt; はすべて大文字で &lt;code&gt;&quot;REGEXP&quot;&lt;/code&gt; 基になるC構造タイプを返します。</target>
        </trans-unit>
        <trans-unit id="d3b4cbb1ed8f855f79ca32bff7fc152fc5c21ab5" translate="yes" xml:space="preserve">
          <source>Note that for larger bit-strings, it's more efficient to use the two-argument version</source>
          <target state="translated">より大きなビット文字列の場合は、2引数バージョンの</target>
        </trans-unit>
        <trans-unit id="a191f82c0a0eecf7bccec0288b197819c9c21ed4" translate="yes" xml:space="preserve">
          <source>Note that for simpler testing requirements it will often be possible to replace the above code with a single call to &lt;code&gt;runtests&lt;/code&gt; .</source>
          <target state="translated">より簡単なテスト要件のために、上記のコードを &lt;code&gt;runtests&lt;/code&gt; への単一の呼び出しで置き換えることがしばしば可能であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0d204c8dce6be8d36767ba5943e30dba9a432c61" translate="yes" xml:space="preserve">
          <source>Note that for simpler testing requirements it will often be possible to replace the above code with a single call to &lt;code&gt;runtests&lt;/code&gt;.</source>
          <target state="translated">より単純なテスト要件のために、上記のコードを &lt;code&gt;runtests&lt;/code&gt; への単一の呼び出しに置き換えることがしばしば可能であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="ff6a50ca77c83bd7639e6227860f0a0332790a2f" translate="yes" xml:space="preserve">
          <source>Note that for the &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity and not-a-number) the definition of &quot;numeric&quot; is somewhat unusual: the strings themselves (like &quot;Inf&quot;) are considered numeric, and anything following them is considered non-numeric.</source>
          <target state="translated">&lt;code&gt;Inf&lt;/code&gt; と &lt;code&gt;NaN&lt;/code&gt; （無限大で非数）の場合、「数値」の定義はやや珍しいことに注意してください。文字列自体（「Inf」など）は数値と見なされ、それに続くものはすべて非数値と見なされます。</target>
        </trans-unit>
        <trans-unit id="de25d3b42b2818ebeccffadf90f915562d81e76b" translate="yes" xml:space="preserve">
          <source>Note that formats are treated as anon subs, and are cloned each time write is called (if necessary).</source>
          <target state="translated">フォーマットはアノンサブとして扱われ、writeが呼び出されるたびに(必要に応じて)クローン化されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="be9d64d44ec51b213716f420b24aa9198bccd3c7" translate="yes" xml:space="preserve">
          <source>Note that freezing an object structure and immediately thawing it actually achieves a deep cloning of that structure:</source>
          <target state="translated">オブジェクト構造を凍結してすぐに解凍すると、実際にはその構造の深いクローニングが達成されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="692f49a79ca8c218f709da74928c335686702cff" translate="yes" xml:space="preserve">
          <source>Note that from &lt;a href=&quot;../bigint&quot;&gt;Math::BigInt&lt;/a&gt; v1.76 onwards, FastCalc will be loaded automatically, if possible.</source>
          <target state="translated">&lt;a href=&quot;../bigint&quot;&gt;Math ::&lt;/a&gt; BigInt v1.76以降、可能であればFastCalcが自動的にロードされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8d38bae54b038eb6f174267d0d214d08b91f6765" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; may return huge lists when used on large DBM files. You may prefer to use the &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; function to iterate over large DBM files. Example:</source>
          <target state="translated">&lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;#values-HASH&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;などの関数を大きなDBMファイルで使用すると、巨大なリストが返される場合があることに注意してください。&lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt;関数を使用して、大きなDBMファイルを反復処理することをお勧めします。例：</target>
        </trans-unit>
        <trans-unit id="cded70f7d04a11712cae33c05ba272338aaac47b" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; may return huge lists when used on large objects, like DBM files. You may prefer to use the &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; function to iterate over such. Example:</source>
          <target state="translated">&lt;a href=&quot;#keys-HASH&quot;&gt; &lt;code&gt;keys&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;#values-HASH&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;などの関数をDBMファイルなどの大きなオブジェクトで使用すると、巨大なリストが返される場合があることに注意してください。&lt;a href=&quot;#each-HASH&quot;&gt; &lt;code&gt;each&lt;/code&gt; &lt;/a&gt;関数を使用して、そのようなことを繰り返すことをお勧めします。例：</target>
        </trans-unit>
        <trans-unit id="f6a562b762d80b1c79a4a2e57ae06efed1d20b20" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over large DBM files. Example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; などの関数は、大きなDBMファイルで使用すると、巨大なリストを返す可能性があることに注意してください。大きなDBMファイルを反復処理するには、 &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 関数を使用することをお勧めします。例：</target>
        </trans-unit>
        <trans-unit id="744885e641d2306d4fbe957365af5d32ac0b76f3" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large objects, like DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over such. Example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; などの関数は、DBMファイルなどの大きなオブジェクトで使用すると、巨大なリストを返す可能性があることに注意してください。あなたはその &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; なことを繰り返すためにそれぞれの関数を使うことを好むかもしれません。例：</target>
        </trans-unit>
        <trans-unit id="72ffa6aa03e0b04398c1553e4a97b08735d3745c" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over large DBM files. Example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; などの関数は、大きなDBMファイルで使用すると、巨大なリストを返す可能性があることに注意してください。大きなDBMファイルを反復処理するには、 &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; 関数を使用することをお勧めします。例：</target>
        </trans-unit>
        <trans-unit id="a1b483511502689b9e22b000546db0922817c2d1" translate="yes" xml:space="preserve">
          <source>Note that functions such as &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; may return huge lists when used on large objects, like DBM files. You may prefer to use the &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; function to iterate over such. Example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; などの関数は、DBMファイルなどの大きなオブジェクトで使用すると、巨大なリストを返す可能性があることに注意してください。あなたはその &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; なことを繰り返すためにそれぞれの関数を使うことを好むかもしれません。例：</target>
        </trans-unit>
        <trans-unit id="ae8752600c3751f3c52b44262525865199cca383" translate="yes" xml:space="preserve">
          <source>Note that functions such as keys() and values() may return huge lists when used on large objects, like DBM files. You may prefer to use the each() function to iterate over such. Example:</source>
          <target state="translated">keys()や values()のような関数は、DBM ファイルのような大きなオブジェクトで使用すると、巨大なリストを返す可能性があることに注意してください。そのような場合は each()関数を使用して反復処理を行うことをお勧めします。例を示します。</target>
        </trans-unit>
        <trans-unit id="d8b624d4598897ef720d34e8f550c09e63657b83" translate="yes" xml:space="preserve">
          <source>Note that glibc &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;, etc. are buggy before glibc version 2.17. They won't allow a &lt;code&gt;%.s&lt;/code&gt; format with a precision to create a string that isn't valid UTF-8 if the current underlying locale of the program is UTF-8. What happens is that the &lt;code&gt;%s&lt;/code&gt; and its operand are simply skipped without any notice. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt;.</source>
          <target state="translated">glibcバージョン2.17より前のバージョンでは、glibcの &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; などにバグがあることに注意してください。プログラムの現在の基本的なロケールがUTF-8である場合、精度のある &lt;code&gt;%.s&lt;/code&gt; 形式で有効なUTF-8ではない文字列を作成することはできません。何が起こるかというと、 &lt;code&gt;%s&lt;/code&gt; とそのオペランドは通知なしに単純にスキップされます。&lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1b12e74f81fc8b09d013b39d154bb46d47ab07cc" translate="yes" xml:space="preserve">
          <source>Note that glibc &lt;code&gt;printf()&lt;/code&gt;, &lt;code&gt;sprintf()&lt;/code&gt;, etc. are buggy before glibc version 2.17. They won't allow a &lt;code&gt;%.s&lt;/code&gt; format with a precision to create a string that isn't valid UTF-8 if the current underlying locale of the program is UTF-8. What happens is that the &lt;code&gt;%s&lt;/code&gt; and its operand are simply skipped without any notice. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt;.</source>
          <target state="translated">glibc &lt;code&gt;printf()&lt;/code&gt; 、 &lt;code&gt;sprintf()&lt;/code&gt; などは、glibcバージョン2.17より前ではバグがあることに注意してください。彼らは許可しません &lt;code&gt;%.s&lt;/code&gt; プログラムの現在の根底にあるロケールがUTF-8であれば、有効なUTF-8でない文字列を作成するために、精度のフォーマットを。何が起こるかというと、 &lt;code&gt;%s&lt;/code&gt; とそのオペランドは通知なしに単にスキップされます。&lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&quot;&gt;https://sourceware.org/bugzilla/show_bug.cgi?id=6530&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="622115f32e89cdb0d30c0373c6c70d90996631c4" translate="yes" xml:space="preserve">
          <source>Note that globbing only lists directories explicitly asked for, for example FOO/* will not list FOO/bar/Acme-Sthg-n.nn.tar.gz. This may be regarded as a bug that may be changed in some future version.</source>
          <target state="translated">例えば FOO/*は FOO/bar/Acme-Sthg-n.nn.tar.gz をリストアップしません。これはバグとみなされ、将来のバージョンで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="608b43e88fa71f94e1e6a28718931116afacd602" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; needs external data for it to work, no subroutine call is possible without it. As an example, the standard debugger's &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; depends on the &lt;code&gt;$DB::deep&lt;/code&gt; variable (it defines how many levels of recursion deep into the debugger you can go before a mandatory break). If &lt;code&gt;$DB::deep&lt;/code&gt; is not defined, subroutine calls are not possible, even though &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; exists.</source>
          <target state="translated">&lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; が機能するために外部データが必要な場合、それなしではサブルーチンを呼び出すことができないことに注意してください。例として、標準デバッガーの &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; は &lt;code&gt;$DB::deep&lt;/code&gt; 変数に依存します（必須のブレークの前にデバッガーの奥深くまでいくつのレベルの再帰を実行できるかを定義します）。場合は &lt;code&gt;$DB::deep&lt;/code&gt; 定義されていない、サブルーチン呼び出しがあっても、可能ではない &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; 存在します。</target>
        </trans-unit>
        <trans-unit id="ac18f8ca65d2ef342faed7220894d625a0f93e79" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;CanonicalName&lt;/code&gt; is enabled, a normalized filename will be passed to the sub.</source>
          <target state="translated">&lt;code&gt;CanonicalName&lt;/code&gt; が有効な場合、正規化されたファイル名がサブルーチンに渡されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5f3c24624d3659de7e4c912e62eae398eab95882" translate="yes" xml:space="preserve">
          <source>Note that if a pattern compiled within &lt;code&gt;'strict'&lt;/code&gt; is recompiled, say by interpolating into another pattern, outside of &lt;code&gt;'strict'&lt;/code&gt; , it is not checked again for strictness. This is because if it works under strict it must work under non-strict.</source>
          <target state="translated">&lt;code&gt;'strict'&lt;/code&gt; 内でコンパイルされたパターンが再コンパイルされた場合、たとえば &lt;code&gt;'strict'&lt;/code&gt; 以外の別のパターンに補間されている場合、その厳密性は再度チェックされないことに注意してください。これは、厳格に機能する場合、非厳格で動作する必要があるためです。</target>
        </trans-unit>
        <trans-unit id="5ee9a3d19116b2071dbcf7039492ca7c1889754a" translate="yes" xml:space="preserve">
          <source>Note that if a pattern compiled within &lt;code&gt;'strict'&lt;/code&gt; is recompiled, say by interpolating into another pattern, outside of &lt;code&gt;'strict'&lt;/code&gt;, it is not checked again for strictness. This is because if it works under strict it must work under non-strict.</source>
          <target state="translated">&lt;code&gt;'strict'&lt;/code&gt; 内でコンパイルされたパターンが、たとえば &lt;code&gt;'strict'&lt;/code&gt; の外側の別のパターンに補間することによって再コンパイルされた場合、厳密性が再度チェックされないことに注意してください。これは、厳密に機能する場合は非厳密に機能する必要があるためです。</target>
        </trans-unit>
        <trans-unit id="308556457296cab4f486eee25acd00edabad2290" translate="yes" xml:space="preserve">
          <source>Note that if a string argument starts with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt; , it will be considered an option on itself.</source>
          <target state="translated">文字列引数が &lt;code&gt;-&lt;/code&gt; または &lt;code&gt;--&lt;/code&gt; で始まる場合、それ自体のオプションと見なされます。</target>
        </trans-unit>
        <trans-unit id="b48bf5ef9d46bdb5c44d53b224dcfec68d33eb04" translate="yes" xml:space="preserve">
          <source>Note that if a string argument starts with &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;--&lt;/code&gt;, it will be considered an option on itself.</source>
          <target state="translated">文字列引数が &lt;code&gt;-&lt;/code&gt; または &lt;code&gt;--&lt;/code&gt; で始まる場合、それ自体がオプションと見なされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8c44aba0e7ff586bf06544855993dee92b7ebfb4" translate="yes" xml:space="preserve">
          <source>Note that if a tainted string is added to &lt;code&gt;@INC&lt;/code&gt; , the following problem will be reported:</source>
          <target state="translated">汚染された文字列が &lt;code&gt;@INC&lt;/code&gt; に追加された場合、次の問題が報告されることに注意してください：</target>
        </trans-unit>
        <trans-unit id="a96ea078157000b1da678edf47d2488720c25a67" translate="yes" xml:space="preserve">
          <source>Note that if a tainted string is added to &lt;code&gt;@INC&lt;/code&gt;, the following problem will be reported:</source>
          <target state="translated">汚染された文字列が &lt;code&gt;@INC&lt;/code&gt; に追加されると、次の問題が報告されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9ab97fe678be0eb16cdcbc59a7f09857930450fc" translate="yes" xml:space="preserve">
          <source>Note that if a temp directory is your current directory, it cannot be removed. &lt;code&gt;chdir()&lt;/code&gt; out of the directory first before calling &lt;code&gt;cleanup()&lt;/code&gt;. (For the cleanup at program exit when the CLEANUP flag is set, this happens automatically.)</source>
          <target state="translated">一時ディレクトリが現在のディレクトリである場合、削除できないことに注意してください。 &lt;code&gt;cleanup()&lt;/code&gt; を呼び出す前に、最初にディレクトリから &lt;code&gt;chdir()&lt;/code&gt; を取り出します。（CLEANUPフラグが設定されている場合のプログラム終了時のクリーンアップの場合、これは自動的に行われます。）</target>
        </trans-unit>
        <trans-unit id="9afccffdaaa8763c6bff65d340b0383eec4b2bf1" translate="yes" xml:space="preserve">
          <source>Note that if a temp directory is your current directory, it cannot be removed. C</source>
          <target state="translated">一時ディレクトリがカレントディレクトリの場合は削除できないことに注意してください。C</target>
        </trans-unit>
        <trans-unit id="e3273fcdfd70332486252bf4b49416cc8786a3a4" translate="yes" xml:space="preserve">
          <source>Note that if an initialized scalar variable is used instead the result is different: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh='zzz'; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;($fh, ...)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;( *{'zzz'}, ...)&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'refs'&lt;/code&gt; forbids such practice.</source>
          <target state="translated">初期化されたスカラー変数が代わりに使用される場合、結果は異なることに注意してください： &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $fh='zzz'; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;($fh, ...)&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;( *{'zzz'}, ...)&lt;/code&gt; と同等です。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'refs'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用し&lt;/a&gt;て、そのような慣行を禁止してください。</target>
        </trans-unit>
        <trans-unit id="fa54ff84091944bfa52d0352fb337bc37692f612" translate="yes" xml:space="preserve">
          <source>Note that if an initialized scalar variable is used instead the result is different: &lt;code&gt;my $fh='zzz'; open($fh, ...)&lt;/code&gt; is equivalent to &lt;code&gt;open( *{'zzz'}, ...)&lt;/code&gt;. &lt;code&gt;use strict 'refs'&lt;/code&gt; forbids such practice.</source>
          <target state="translated">代わりに初期化されたスカラー変数を使用すると、結果が異なることに注意してください &lt;code&gt;my $fh='zzz'; open($fh, ...)&lt;/code&gt; は &lt;code&gt;open( *{'zzz'}, ...)&lt;/code&gt; と同等です。 &lt;code&gt;use strict 'refs'&lt;/code&gt; そのような慣行は禁止されます。</target>
        </trans-unit>
        <trans-unit id="6fd8bc012a0b5fd862eb29b81c0bd7a1843836fc" translate="yes" xml:space="preserve">
          <source>Note that if multiple files are parsed for a single POD document (perhaps the result of some future &lt;code&gt;=include&lt;/code&gt; directive) this method is invoked for every file that is parsed. If you wish to perform certain initializations once per document, then you should use &lt;b&gt;begin_pod()&lt;/b&gt;.</source>
          <target state="translated">単一のPODドキュメントについて複数のファイルが解析される場合（おそらく、将来の &lt;code&gt;=include&lt;/code&gt; ディレクティブの結果）、このメソッドは解析されるすべてのファイルに対して呼び出されることに注意してください。ドキュメントごとに特定の初期化を実行する場合は、&lt;b&gt;begin_pod（）&lt;/b&gt;を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="826d10bf58e0edead500c1a2f5a6d8c68eb347e0" translate="yes" xml:space="preserve">
          <source>Note that if no errors are encountered, &lt;code&gt;$err&lt;/code&gt; will reference an empty array. This means that &lt;code&gt;$err&lt;/code&gt; will always end up TRUE; so you need to test &lt;code&gt;@$err&lt;/code&gt; to determine if errors occured.</source>
          <target state="translated">エラーが発生しない場合、 &lt;code&gt;$err&lt;/code&gt; は空の配列を参照することに注意してください。つまり、 &lt;code&gt;$err&lt;/code&gt; は常にTRUEになります。したがって、エラーが発生したかどうかを判断するために &lt;code&gt;@$err&lt;/code&gt; をテストする必要があります。</target>
        </trans-unit>
        <trans-unit id="9bfefb6d862aaaa4bec0b5f0b65d69bbc80cc525" translate="yes" xml:space="preserve">
          <source>Note that if no errors are encountered, &lt;code&gt;$err&lt;/code&gt; will reference an empty array. This means that &lt;code&gt;$err&lt;/code&gt; will always end up TRUE; so you need to test &lt;code&gt;@$err&lt;/code&gt; to determine if errors occurred.</source>
          <target state="translated">エラーが発生しなかった場合、 &lt;code&gt;$err&lt;/code&gt; は空の配列を参照することに注意してください。これは、 &lt;code&gt;$err&lt;/code&gt; が常にTRUEになることを意味します。したがって、 &lt;code&gt;@$err&lt;/code&gt; をテストして、エラーが発生したかどうかを判断する必要があります。</target>
        </trans-unit>
        <trans-unit id="1324e5c55e1f48c00e9179366ddca7ad4be15ea2" translate="yes" xml:space="preserve">
          <source>Note that if tests have a trailing plan, it is not possible to set this property for unplanned tests as we do not know it's unplanned until the plan is reached:</source>
          <target state="translated">テストが後続の計画を持っている場合、計画に達するまで計画されていないことがわからないので、計画されていないテストに対してこのプロパティを設定することはできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="58bd8c74c7de485d278dd761f4ec5c815966b6fe" translate="yes" xml:space="preserve">
          <source>Note that if the cache is a tied hash, &lt;code&gt;flush_cache&lt;/code&gt; will attempt to invoke the &lt;code&gt;CLEAR&lt;/code&gt; method on the hash. If there is no &lt;code&gt;CLEAR&lt;/code&gt; method, this will cause a run-time error.</source>
          <target state="translated">キャッシュがタイドハッシュの場合、 &lt;code&gt;flush_cache&lt;/code&gt; はハッシュに対して &lt;code&gt;CLEAR&lt;/code&gt; メソッドを呼び出そうとします。 &lt;code&gt;CLEAR&lt;/code&gt; メソッドがない場合は、実行時エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="9c084f4d82be664fcc79d00bcef732fc1be8ca28" translate="yes" xml:space="preserve">
          <source>Note that if the filehandle has been marked as &lt;code&gt;:utf8&lt;/code&gt; Unicode characters are read instead of bytes (the LENGTH, OFFSET, and the return value of sysread() are in Unicode characters). The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt;, &lt;a href=&quot;#open&quot;&gt;open&lt;/a&gt;, and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma, &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">ファイルハンドルが &lt;code&gt;:utf8&lt;/code&gt; としてマークされている場合、バイトの代わりにUnicode文字が読み取られることに注意してください（LENGTH、OFFSET、およびsysread（）の戻り値はUnicode文字です）。 &lt;code&gt;:encoding(...)&lt;/code&gt; 層は、暗黙的に紹介する &lt;code&gt;:utf8&lt;/code&gt; レイヤーを。参照&lt;a href=&quot;#binmode&quot;&gt;binmodeを&lt;/a&gt;、&lt;a href=&quot;#open&quot;&gt;オープン&lt;/a&gt;、および &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 、プラグマを&lt;a href=&quot;open&quot;&gt;開きました&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a528a8e216af2d3ed813e217add7c3fe0518eef" translate="yes" xml:space="preserve">
          <source>Note that if the filehandle has been marked as &lt;code&gt;:utf8&lt;/code&gt; Unicode characters are read instead of bytes (the LENGTH, OFFSET, and the return value of sysread() are in Unicode characters). The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;, and the &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma, &lt;a href=&quot;../open&quot;&gt;open&lt;/a&gt;.</source>
          <target state="translated">ファイルハンドルが &lt;code&gt;:utf8&lt;/code&gt; としてマークされている場合、バイトの代わりにUnicode文字が読み取られることに注意してください（LENGTH、OFFSET、およびsysread（）の戻り値はUnicode文字です）。 &lt;code&gt;:encoding(...)&lt;/code&gt; 層は、暗黙的に紹介する &lt;code&gt;:utf8&lt;/code&gt; レイヤーを。参照&lt;a href=&quot;binmode&quot;&gt;binmodeを&lt;/a&gt;、&lt;a href=&quot;open&quot;&gt;オープン&lt;/a&gt;、および &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 、プラグマを&lt;a href=&quot;../open&quot;&gt;開きました&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="64c93021972ce0767115d7755bbd49afcf9ee53b" translate="yes" xml:space="preserve">
          <source>Note that if the filehandle has been marked as &lt;code&gt;:utf8&lt;/code&gt;, &lt;code&gt;sysread&lt;/code&gt; will throw an exception. The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma.</source>
          <target state="translated">ファイルハンドルが &lt;code&gt;:utf8&lt;/code&gt; としてマークされている場合、 &lt;code&gt;sysread&lt;/code&gt; は例外をスローすることに注意してください。 &lt;code&gt;:encoding(...)&lt;/code&gt; 層は、暗黙的に紹介する &lt;code&gt;:utf8&lt;/code&gt; レイヤーを。&lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;プラグマを参照してください。</target>
        </trans-unit>
        <trans-unit id="d14b0f714c8a186567b6c90a5e0bc13fd3099264" translate="yes" xml:space="preserve">
          <source>Note that if the hostname resolves to multiple address candidates, the same timeout will apply to each connection attempt individually, rather than to the operation as a whole. Further note that the timeout does not apply to the initial hostname resolve operation, if connecting by hostname.</source>
          <target state="translated">ホスト名が複数のアドレス候補に解決する場合、同じタイムアウトが操作全体ではなく、それぞれの接続試行に個別に適用されることに注意してください。さらに、ホスト名で接続している場合、タイムアウトは最初のホスト名解決操作には適用されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="0908e03d8ce40c7005e83d17332e47cd6f9ef387" translate="yes" xml:space="preserve">
          <source>Note that if the input text is a read-only string (i.e. a literal), no attempt is made to remove the extracted text.</source>
          <target state="translated">入力テキストが読み取り専用の文字列(すなわちリテラル)の場合は、抽出されたテキストを削除しようとはしないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="34c9b253a358e643fbf719eebaacbe9ee361bc74" translate="yes" xml:space="preserve">
          <source>Note that if the platform doesn't have &lt;code&gt;LC_NUMERIC&lt;/code&gt; and/or &lt;code&gt;LC_MONETARY&lt;/code&gt; available or enabled, the corresponding elements of the hash will be missing.</source>
          <target state="translated">プラットフォームで &lt;code&gt;LC_NUMERIC&lt;/code&gt; や &lt;code&gt;LC_MONETARY&lt;/code&gt; が利用できないか有効になっていない場合、対応するハッシュの要素が失われることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c9c7ab75927f08e77cc4898e73b8aeda27cc0c9a" translate="yes" xml:space="preserve">
          <source>Note that if the regular expression is tainted, then Perl will die rather than calling the subroutine when the name of the subroutine is determined by the tainted data.</source>
          <target state="translated">正規表現が汚染されている場合、汚染されたデータによってサブルーチンの名前が決定されると、Perlはサブルーチンを呼び出すのではなく死んでしまうことに注意してください。</target>
        </trans-unit>
        <trans-unit id="fe055d833210baa880117658e3debc03ef9f92ae" translate="yes" xml:space="preserve">
          <source>Note that if the socket has been marked as &lt;code&gt;:utf8&lt;/code&gt;, &lt;code&gt;recv&lt;/code&gt; will throw an exception. The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ソケットが &lt;code&gt;:utf8&lt;/code&gt; としてマークされている場合、 &lt;code&gt;recv&lt;/code&gt; は例外をスローすることに注意してください。 &lt;code&gt;:encoding(...)&lt;/code&gt; 層は、暗黙的に紹介する &lt;code&gt;:utf8&lt;/code&gt; レイヤーを。&lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7e5d364aee605b39052a767be97bf595da7e180a" translate="yes" xml:space="preserve">
          <source>Note that if the socket has been marked as &lt;code&gt;:utf8&lt;/code&gt;, &lt;code&gt;send&lt;/code&gt; will throw an exception. The &lt;code&gt;:encoding(...)&lt;/code&gt; layer implicitly introduces the &lt;code&gt;:utf8&lt;/code&gt; layer. See &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ソケットが &lt;code&gt;:utf8&lt;/code&gt; としてマークされている場合、 &lt;code&gt;send&lt;/code&gt; は例外をスローすることに注意してください。 &lt;code&gt;:encoding(...)&lt;/code&gt; 層は、暗黙的に紹介する &lt;code&gt;:utf8&lt;/code&gt; レイヤーを。&lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2b2dc5e51258adfa883882440e13a3cae6f294a4" translate="yes" xml:space="preserve">
          <source>Note that if the version of the PM module is an NV (a floating point number), it will be stringified with a possible loss of precision (currently chopping to nine decimal places) so that it may not match the version of the XS module anymore. Quoting the $VERSION declaration to make it a string is recommended if long version numbers are used.</source>
          <target state="translated">PMモジュールのバージョンがNV(浮動小数点数)の場合は、文字列化されて精度が失われる可能性があることに注意してください(現在は小数点以下9桁に切り捨てられています)。長いバージョン番号を使用する場合は、$VERSION宣言を引用して文字列にすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6c6048c09fbd601d5bded4c49f7b53cc961721c5" translate="yes" xml:space="preserve">
          <source>Note that if there was a subroutine call between us and line 29, and we wanted to &lt;b&gt;single-step&lt;/b&gt; through it, we could use the '&lt;b&gt;s&lt;/b&gt;' command, and to step over it we would use '&lt;b&gt;n&lt;/b&gt;' which would execute the sub, but not descend into it for inspection. In this case though, we simply continue down to line 29:</source>
          <target state="translated">私たちと行29の間にサブルーチン呼び出しがあり、それを&lt;b&gt;シングルステップで実行&lt;/b&gt;したい場合は、「&lt;b&gt;s&lt;/b&gt;」コマンドを使用でき、ステップオーバーするには、サブルーチンを実行する「&lt;b&gt;n&lt;/b&gt;」を使用します。検査のためにそこに降りることはできません。ただし、この場合は、29行目まで続けます。</target>
        </trans-unit>
        <trans-unit id="59c2ff6ec5006b141610e96d370fba70e324be70" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; block on the above, it would get executed even on discarded lines. If LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;next EXPR&lt;/code&gt; form, available as of Perl 5.18.0, allows a label name to be computed at run time, being otherwise identical to &lt;code&gt;next LABEL&lt;/code&gt;.</source>
          <target state="translated">上記に&lt;a href=&quot;#continue-BLOCK&quot;&gt; &lt;code&gt;continue&lt;/code&gt; &lt;/a&gt;ブロックがあると、破棄された行でも実行されることに注意してください。LABELを省略した場合、コマンドは最も内側の囲みループを参照します。 &lt;code&gt;next EXPR&lt;/code&gt; Perlの5.18.0のような利用可能な形式は、ラベル名と他の点では同一であり、実行時に計算されることを可能にする &lt;code&gt;next LABEL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f3dd1e37239e5e6990e5357970b72eac4a59098" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above, it would get executed even on discarded lines. If LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; form, available as of Perl 5.18.0, allows a label name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">上記に &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; ブロックがある場合、破棄された行でも実行されることに注意してください。LABELを省略した場合、コマンドは最も内側の囲みループを参照します。 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; Perlの5.18.0のような利用可能な形式は、ラベル名と他の点では同一であり、実行時に計算されることを可能にする &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60ee3cf42536d2e0cc61b8039c6f1a0a75072a6a" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above code, it would get executed only on lines discarded by the regex (since redo skips the continue block). A continue block is often used to reset line counters or &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m?pat?&lt;/a&gt;&lt;/code&gt; one-time matches:</source>
          <target state="translated">上記のコードに &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; ブロックがある場合、正規表現によって破棄された行でのみ実行されます（REDOは継続ブロックをスキップするため）。行ブロックまたは &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m?pat?&lt;/a&gt;&lt;/code&gt; をリセットするために、継続ブロックがよく使用されます。1回限りの一致：</target>
        </trans-unit>
        <trans-unit id="03cca16cecaf26d400e510c53bbfbaac8d0326bf" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block on the above, it would get executed even on discarded lines. If LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; form, available as of Perl 5.18.0, allows a label name to be computed at run time, being otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; .</source>
          <target state="translated">上記に &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; ブロックがある場合、破棄された行でも実行されることに注意してください。LABELを省略した場合、コマンドは最も内側の囲みループを参照します。 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; EXPR&lt;/code&gt; Perlの5.18.0のような利用可能な形式は、ラベル名と他の点では同一であり、実行時に計算されることを可能にする &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; LABEL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d89a8bc172fcf3b8db606f977ce516e0ca56f06e" translate="yes" xml:space="preserve">
          <source>Note that if there were a &lt;code&gt;continue&lt;/code&gt; block on the above code, it would get executed only on lines discarded by the regex (since redo skips the continue block). A continue block is often used to reset line counters or &lt;code&gt;m?pat?&lt;/code&gt; one-time matches:</source>
          <target state="translated">上記のコードに &lt;code&gt;continue&lt;/code&gt; ブロックがあった場合、正規表現によって破棄された行でのみ実行されることに注意してください（redoはcontinueブロックをスキップするため）。継続ブロックは、ラインカウンターまたは &lt;code&gt;m?pat?&lt;/code&gt; をリセットするためによく使用されます。1回限りの試合：</target>
        </trans-unit>
        <trans-unit id="d19c5d18d3d9efa0c0b12037ddf03239e4ec1d14" translate="yes" xml:space="preserve">
          <source>Note that if this module is imported when &lt;a href=&quot;../threads&quot;&gt;threads&lt;/a&gt; has not yet been loaded, then these functions all become no-ops. This makes it possible to write modules that will work in both threaded and non-threaded environments.</source>
          <target state="translated">&lt;a href=&quot;../threads&quot;&gt;スレッド&lt;/a&gt;がまだロードされていないときにこのモジュールがインポートされると、これらの関数はすべてノーオペレーションになります。これにより、スレッド環境と非スレッド環境の両方で機能するモジュールを作成できます。</target>
        </trans-unit>
        <trans-unit id="5fb1ed53a6e66a00d38de3c7beb368af62d0f805" translate="yes" xml:space="preserve">
          <source>Note that if this module is imported when &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; has not yet been loaded, then these functions all become no-ops. This makes it possible to write modules that will work in both threaded and non-threaded environments.</source>
          <target state="translated">&lt;a href=&quot;threads&quot;&gt;スレッド&lt;/a&gt;がまだロードされていないときにこのモジュールがインポートされた場合、これらの関数はすべてno-opsになることに注意してください。これにより、スレッド環境と非スレッド環境の両方で機能するモジュールを作成できます。</target>
        </trans-unit>
        <trans-unit id="a67c2908702a6cdf59ca28b987d8e4a389fc1fa9" translate="yes" xml:space="preserve">
          <source>Note that if this operator is used and NOT inside of an alternation then it acts exactly like the &lt;code&gt;(*PRUNE)&lt;/code&gt; operator.</source>
          <target state="translated">この演算子が使用され、代替内ではない場合、 &lt;code&gt;(*PRUNE)&lt;/code&gt; 演算子とまったく同じように機能することに注意してください。</target>
        </trans-unit>
        <trans-unit id="fdc2bfbf6748eacea8c87035966d754d0f68c5a3" translate="yes" xml:space="preserve">
          <source>Note that if using gcc, starting from Perl 5.9.5 the Perl core source code files (the ones at the top level of the source code distribution, but not e.g. the extensions under ext/) are automatically compiled with as many as possible of the &lt;code&gt;-std=c89&lt;/code&gt; , &lt;code&gt;-ansi&lt;/code&gt; , &lt;code&gt;-pedantic&lt;/code&gt; , and a selection of &lt;code&gt;-W&lt;/code&gt; flags (see cflags.SH).</source>
          <target state="translated">gccを使用している場合、Perl 5.9.5以降、Perlコアソースコードファイル（ソースコード配布のトップレベルにあるファイルですが、ext /の下の拡張などではありません）は、可能な限り多くの &lt;code&gt;-std=c89&lt;/code&gt; 、 &lt;code&gt;-ansi&lt;/code&gt; 、 &lt;code&gt;-pedantic&lt;/code&gt; 、および &lt;code&gt;-W&lt;/code&gt; フラグの選択（cflags.SHを参照）。</target>
        </trans-unit>
        <trans-unit id="ae719f393d44a0bc8f5885617f97e53f1b2edd48" translate="yes" xml:space="preserve">
          <source>Note that if using gcc, starting from Perl 5.9.5 the Perl core source code files (the ones at the top level of the source code distribution, but not e.g. the extensions under ext/) are automatically compiled with as many as possible of the &lt;code&gt;-std=c89&lt;/code&gt;, &lt;code&gt;-ansi&lt;/code&gt;, &lt;code&gt;-pedantic&lt;/code&gt;, and a selection of &lt;code&gt;-W&lt;/code&gt; flags (see cflags.SH).</source>
          <target state="translated">gccを使用する場合、Perl 5.9.5以降、Perlコアソースコードファイル（ソースコードディストリビューションのトップレベルにあるものですが、ext /の下の拡張子は除く）は、可能な限り多くのファイルで自動的にコンパイルされることに注意してください。 &lt;code&gt;-std=c89&lt;/code&gt; 、 &lt;code&gt;-ansi&lt;/code&gt; 、 &lt;code&gt;-pedantic&lt;/code&gt; 、および &lt;code&gt;-W&lt;/code&gt; フラグの選択（cflags.SHを参照）。</target>
        </trans-unit>
        <trans-unit id="dfe5b081a33f6efff2f505814c3590456b24ec50" translate="yes" xml:space="preserve">
          <source>Note that if you do not have Module::Signature installed, no signature checks will be performed at all.</source>
          <target state="translated">Module::Signature がインストールされていない場合、署名チェックは一切行われないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="7890360c193f0760d43a2add9be2d600e6cb6a32" translate="yes" xml:space="preserve">
          <source>Note that if you do not plan to build the perl itself, it may be possible to fool EMX to truncate file names. This is not supported, read EMX docs to see how to do it.</source>
          <target state="translated">なお、Perl 自体をビルドする予定がない場合は、EMX を騙してファイル名を切り捨てることができるかもしれません。これはサポートされていませんので、EMX のドキュメントを読んで方法を確認してください。</target>
        </trans-unit>
        <trans-unit id="7074505ed79917df5e0904da32c456ed53b1b35d" translate="yes" xml:space="preserve">
          <source>Note that if you have</source>
          <target state="translated">を持っている場合は注意してください。</target>
        </trans-unit>
        <trans-unit id="16452a0ac87813870c05c7095ba75ee11a8d9c6d" translate="yes" xml:space="preserve">
          <source>Note that if you have bytes with the eighth bit on in your script (for example embedded Latin-1 in your string literals), &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; will be unhappy since the bytes are most probably not well-formed UTF-X. If you want to have such bytes under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , you can disable this pragma until the end the block (or file, if at top level) by &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8;&lt;/code&gt; .</source>
          <target state="translated">スクリプトに8番目のビットがオンのバイトがある場合（たとえば、文字列リテラルにLatin-1が埋め込まれている場合）、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; を&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;すると不幸になります。バイトはおそらく整形式のUTF-Xではないためです。あなたは下のようにバイトをしたい場合は &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; （トップレベルの場合、またはファイル）、あなたはで最後までブロックを、このプラグマを無効にすることができ &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c4aa42b29cc2c2cbee7d6400738523e5bb46393" translate="yes" xml:space="preserve">
          <source>Note that if you have chdir'ed into the temporary directory and it is subsequently cleaned up (either in the END block or as part of object destruction), then you will get a warning from File::Path::rmtree().</source>
          <target state="translated">テンポラリディレクトリに chdir した後、それがクリーンアップされた場合 (END ブロックまたはオブジェクト破壊の一部として)、File::Path::rmtree()から警告が出ることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b2acb4728d0e1f7a70ad075cf5c70995a564c7a8" translate="yes" xml:space="preserve">
          <source>Note that if you have non-ASCII, non-UTF-8 bytes in your script (for example embedded Latin-1 in your string literals), &lt;code&gt;use utf8&lt;/code&gt; will be unhappy. If you want to have such bytes under &lt;code&gt;use utf8&lt;/code&gt;, you can disable this pragma until the end the block (or file, if at top level) by &lt;code&gt;no utf8;&lt;/code&gt;.</source>
          <target state="translated">スクリプトに非ASCII、非UTF-8バイトがある場合（たとえば、文字列リテラルに埋め込まれたLatin-1）、 &lt;code&gt;use utf8&lt;/code&gt; を使用すると不幸になることに注意してください。このようなバイトを &lt;code&gt;use utf8&lt;/code&gt; で使用したい場合は、ブロック（またはトップレベルの場合はファイル）が終了するまで、utf8を使用せずにこのプラグマを無効にできます &lt;code&gt;no utf8;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f635910faf20c1937408464313d28376fda868a1" translate="yes" xml:space="preserve">
          <source>Note that if you have to look for strings that you don't know till runtime, you can build an entire loop as a string and &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; that to avoid recompiling all your patterns all the time. Together with undefining &lt;code&gt;$/&lt;/code&gt; to input entire files as one record, this can be quite fast, often faster than specialized programs like fgrep(1). The following scans a list of files (&lt;code&gt;@files&lt;/code&gt; ) for a list of words (&lt;code&gt;@words&lt;/code&gt; ), and prints out the names of those files that contain a match:</source>
          <target state="translated">実行時までわからない文字列を探す必要がある場合は、ループ全体を文字列として作成し、すべてのパターンを常に再コンパイルしないように &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ことができます。 &lt;code&gt;$/&lt;/code&gt; を未定義にしてファイル全体を1つのレコードとして入力すると、これはかなり高速になり、fgrep（1）のような特殊なプログラムより高速になることがよくあります。次は、ファイルのリスト（ &lt;code&gt;@files&lt;/code&gt; ）をスキャンして単語のリスト（ &lt;code&gt;@words&lt;/code&gt; ）を探し、一致するファイルの名前を出力します。</target>
        </trans-unit>
        <trans-unit id="563eabb7ceca135c66cd9da9fa7638ecd48fe576" translate="yes" xml:space="preserve">
          <source>Note that if you have to look for strings that you don't know till runtime, you can build an entire loop as a string and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; that to avoid recompiling all your patterns all the time. Together with undefining &lt;code&gt;$/&lt;/code&gt; to input entire files as one record, this can be quite fast, often faster than specialized programs like fgrep(1). The following scans a list of files (&lt;code&gt;@files&lt;/code&gt; ) for a list of words (&lt;code&gt;@words&lt;/code&gt; ), and prints out the names of those files that contain a match:</source>
          <target state="translated">実行時までわからない文字列を探す必要がある場合は、ループ全体を文字列として作成し、すべてのパターンを常に再コンパイルしないように &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ことができます。 &lt;code&gt;$/&lt;/code&gt; を未定義にしてファイル全体を1つのレコードとして入力すると、これはかなり高速になり、fgrep（1）のような特殊なプログラムより高速になることがよくあります。次は、ファイルのリスト（ &lt;code&gt;@files&lt;/code&gt; ）をスキャンして単語のリスト（ &lt;code&gt;@words&lt;/code&gt; ）を探し、一致するファイルの名前を出力します。</target>
        </trans-unit>
        <trans-unit id="472f29cb35dcdd9e0bdaee6718ec77f646cf840a" translate="yes" xml:space="preserve">
          <source>Note that if you take a copy of a scalar with a weakened reference, the copy will be a strong reference.</source>
          <target state="translated">スカラーのコピーを弱めの参照で取ると、そのコピーは強めの参照になるので注意してください。</target>
        </trans-unit>
        <trans-unit id="0e444f4b856d65b2f09fb19cd71f6f782807ee73" translate="yes" xml:space="preserve">
          <source>Note that if you want to do a batch conversion of a lot of Pod documents to HTML, you should see the module &lt;a href=&quot;Pod::Simple::HTMLBatch&quot;&gt;Pod::Simple::HTMLBatch&lt;/a&gt;.</source>
          <target state="translated">多数のポッドドキュメントをHTMLにバッチ変換する場合は、モジュール&lt;a href=&quot;Pod::Simple::HTMLBatch&quot;&gt;Pod :: Simple :: HTMLBatch&lt;/a&gt;が表示されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c4a0c1fef1effc8f82cf7edc96e6b440867de0be" translate="yes" xml:space="preserve">
          <source>Note that if you want to do a batch conversion of a lot of Pod documents to HTML, you should see the module &lt;a href=&quot;htmlbatch&quot;&gt;Pod::Simple::HTMLBatch&lt;/a&gt;.</source>
          <target state="translated">多くのポッドドキュメントをHTMLにバッチ変換する場合は、モジュール&lt;a href=&quot;htmlbatch&quot;&gt;Pod :: Simple :: HTMLBatchが表示されるはず&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="bef8dc28c2922471f2bbf667ac531cc355fd0094" translate="yes" xml:space="preserve">
          <source>Note that if you want to enable a warnings category registered by a module (e.g. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'File::Find'&lt;/code&gt; ), you must have loaded this module first.</source>
          <target state="translated">モジュールによって登録された警告カテゴリを有効にする場合（たとえば &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'File::Find'&lt;/code&gt; ）、このモジュールを最初にロードしておく必要があります。</target>
        </trans-unit>
        <trans-unit id="5e4f1270136e80fe4169f2c75c88690d42981098" translate="yes" xml:space="preserve">
          <source>Note that if you want to enable a warnings category registered by a module (e.g. &lt;code&gt;use warnings 'File::Find'&lt;/code&gt;), you must have loaded this module first.</source>
          <target state="translated">モジュールによって登録された警告カテゴリを有効にする場合（たとえば &lt;code&gt;use warnings 'File::Find'&lt;/code&gt; ）、最初にこのモジュールをロードしておく必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5645d5d10ea8883aafab68e6dc7420fa5396f224" translate="yes" xml:space="preserve">
          <source>Note that if you want to pass on any elements of the C-local environ array to a subprocess which isn't started by fork/exec, or isn't running a C program, you can &quot;promote&quot; them to logical names in the current process, which will then be inherited by all subprocesses, by saying</source>
          <target state="translated">C-local environ 配列の要素を fork/exec で起動していない、あるいは C プログラムを実行していないサブプロセスに渡したい場合は、次のようにして、それらの要素を現在のプロセスの論理名に &quot;プロモート&quot; することができます。</target>
        </trans-unit>
        <trans-unit id="438e992f414c0fb7d0ae67132225f8fb511bf800" translate="yes" xml:space="preserve">
          <source>Note that if you're using Windows, no solution to this vexing issue is even possible. Even though Perl emulates &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;, you'll still be stuck, because Windows does not have an argc/argv-style API.</source>
          <target state="translated">Windowsを使用している場合、この厄介な問題を解決することはできません。Perlは &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; をエミュレートしますが、Windowsにはargc / argvスタイルのAPIがないため、まだ行き詰まっています。</target>
        </trans-unit>
        <trans-unit id="1aa1a6be319ce084016212a914b567d8abc1a457" translate="yes" xml:space="preserve">
          <source>Note that if you're using Windows, no solution to this vexing issue is even possible. Even though Perl emulates &lt;code&gt;fork()&lt;/code&gt;, you'll still be stuck, because Windows does not have an argc/argv-style API.</source>
          <target state="translated">Windowsを使用している場合、この厄介な問題の解決策すら不可能であることに注意してください。Perlは &lt;code&gt;fork()&lt;/code&gt; をエミュレートしますが、Windowsにはargc / argvスタイルのAPIがないため、スタックします。</target>
        </trans-unit>
        <trans-unit id="631593fdac38ac18af70717272a4671c53190f39" translate="yes" xml:space="preserve">
          <source>Note that if your forked child inherits system file descriptors like STDIN and STDOUT that are actually connected by a pipe or socket, even if you exit, then the remote server (such as, say, a CGI script or a backgrounded job launched from a remote shell) won't think you're done. You should reopen those to</source>
          <target state="translated">フォークされた子プロセスが STDIN や STDOUT のようなシステムファイル記述子を継承している場合、たとえ終了したとしても、リモートサーバ (例えば、CGI スクリプトやリモートシェルから起動されたバックグラウンドジョブ)はあなたが終了したとは思わないことに注意してください。それらを開きなおして</target>
        </trans-unit>
        <trans-unit id="70eb4fc52446e8c7cd71ef0fc3bcc0bd68008c67" translate="yes" xml:space="preserve">
          <source>Note that in Perl 5.17.3 and earlier, the last three constants were also used for the caret variants of the variables.</source>
          <target state="translated">Perl 5.17.3以前のバージョンでは、最後の3つの定数は変数のキャレットバリアントにも使用されていたことに注意してください。</target>
        </trans-unit>
        <trans-unit id="8b6ec9401ff25a7e7f20f8f508c8e573ab6cef28" translate="yes" xml:space="preserve">
          <source>Note that in Perl version prior to 5.18 inheritance of the &lt;code&gt;fallback&lt;/code&gt; key was not governed by the above rules. The value of &lt;code&gt;fallback&lt;/code&gt; in the first overloaded ancestor was used. This was fixed in 5.18 to follow the usual rules of inheritance.</source>
          <target state="translated">5.18より前のバージョンのPerlでは、 &lt;code&gt;fallback&lt;/code&gt; キーの継承は上記のルールによって管理されていませんでした。最初のオーバーロードされた祖先の &lt;code&gt;fallback&lt;/code&gt; の値が使用されました。これは5.18で修正され、通常の継承規則に従います。</target>
        </trans-unit>
        <trans-unit id="7dadc679f5466d79da0156797f6b8d65ca1758f1" translate="yes" xml:space="preserve">
          <source>Note that in a few cases this translation can't be perfectly carried back into the source code -- if the loop's initializer declares a my variable, for instance, it won't have the correct scope outside of the loop.</source>
          <target state="translated">いくつかのケースでは、この変換を完全にソースコードに戻すことができないことに注意してください --例えば、ループのイニシャライザがmy変数を宣言している場合、ループの外では正しいスコープを持ちません。</target>
        </trans-unit>
        <trans-unit id="5bedfdd7af45ab7b673c4a8860ff4cc65683c959" translate="yes" xml:space="preserve">
          <source>Note that in a list context, the contents of the original input text (the first argument) are not modified in any way.</source>
          <target state="translated">リストコンテキストでは、元の入力テキスト(第1引数)の内容は一切変更されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="19da40726b3583f6544a1c2e542496723da7a424" translate="yes" xml:space="preserve">
          <source>Note that in all cases of &quot;E&amp;lt;whatever&amp;gt;&quot;,</source>
          <target state="translated">「E &amp;lt;whatever&amp;gt;」のすべてのケースで、</target>
        </trans-unit>
        <trans-unit id="6ce30555742bc236d7228f5681b0d8b9d5625260" translate="yes" xml:space="preserve">
          <source>Note that in contrast with &lt;a href=&quot;#EXAMPLE-1&quot;&gt;&quot;EXAMPLE 1&quot;&lt;/a&gt;, &lt;a href=&quot;#EXAMPLE-2&quot;&gt;&quot;EXAMPLE 2&quot;&lt;/a&gt; and &lt;a href=&quot;#EXAMPLE-3&quot;&gt;&quot;EXAMPLE 3&quot;&lt;/a&gt;, this description does not contain the actual</source>
          <target state="translated">&lt;a href=&quot;#EXAMPLE-1&quot;&gt;「EXAMPLE1」&lt;/a&gt;、&lt;a href=&quot;#EXAMPLE-2&quot;&gt;「EXAMPLE 2」&lt;/a&gt;、&lt;a href=&quot;#EXAMPLE-3&quot;&gt;「EXAMPLE 3」&lt;/a&gt;とは対照的に、この説明には実際の説明が含まれていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="9e72d3882d1c9bd4efe9fc3533a3f5c9da90ccbc" translate="yes" xml:space="preserve">
          <source>Note that in contrast with &lt;a href=&quot;#EXAMPLE-1&quot;&gt;EXAMPLE 1&lt;/a&gt;, &lt;a href=&quot;#EXAMPLE-2&quot;&gt;EXAMPLE 2&lt;/a&gt; and &lt;a href=&quot;#EXAMPLE-3&quot;&gt;EXAMPLE 3&lt;/a&gt;, this description does not contain the actual</source>
          <target state="translated">&lt;a href=&quot;#EXAMPLE-1&quot;&gt;例1&lt;/a&gt;、&lt;a href=&quot;#EXAMPLE-2&quot;&gt;例2&lt;/a&gt;、および&lt;a href=&quot;#EXAMPLE-3&quot;&gt;例3&lt;/a&gt;とは対照的に、この説明には実際の</target>
        </trans-unit>
        <trans-unit id="cc47544345a2ab281008488b23e05567f0a20d81" translate="yes" xml:space="preserve">
          <source>Note that in older versions of this module, the &lt;code&gt;error()&lt;/code&gt; method would return an effectively global value even when called an instance method as above. This has since been fixed, and multiple instances of &lt;code&gt;Archive::Tar&lt;/code&gt; now have separate error strings.</source>
          <target state="translated">このモジュールの古いバージョンでは、上記のようにインスタンスメソッドが呼び出された場合でも、 &lt;code&gt;error()&lt;/code&gt; メソッドは実質的にグローバルな値を返すことに注意してください。この問題は修正され、 &lt;code&gt;Archive::Tar&lt;/code&gt; 複数のインスタンスに個別のエラー文字列が含まれるようになりました。</target>
        </trans-unit>
        <trans-unit id="d8bd3a3217fec8f830ea11bdf3eeaefb81cab80f" translate="yes" xml:space="preserve">
          <source>Note that in scalar and void contexts the value of this argument is automatically reset to 1 (under &lt;code&gt;-w&lt;/code&gt; , a warning is issued if the argument has to be reset).</source>
          <target state="translated">スカラーおよびvoidコンテキストでは、この引数の値は自動的に1にリセットされることに注意してください（ &lt;code&gt;-w&lt;/code&gt; のもとでは、引数をリセットする必要がある場合は警告が発行されます）。</target>
        </trans-unit>
        <trans-unit id="b672aba9889e3334f6f71797b988ee0e00c12f3a" translate="yes" xml:space="preserve">
          <source>Note that in scalar and void contexts the value of this argument is automatically reset to 1 (under &lt;code&gt;-w&lt;/code&gt;, a warning is issued if the argument has to be reset).</source>
          <target state="translated">スカラーおよびvoidコンテキストでは、この引数の値は自動的に1にリセットされることに注意してください（ &lt;code&gt;-w&lt;/code&gt; の下では、引数をリセットする必要がある場合に警告が発行されます）。</target>
        </trans-unit>
        <trans-unit id="41929543f660fb86d6970d86dc2f5cfae1674011" translate="yes" xml:space="preserve">
          <source>Note that in the above cases, &lt;code&gt;thing($foo)&lt;/code&gt; and &lt;code&gt;thing($bar)&lt;/code&gt;</source>
          <target state="translated">上記の場合、 &lt;code&gt;thing($foo)&lt;/code&gt; と &lt;code&gt;thing($bar)&lt;/code&gt; 注意してください</target>
        </trans-unit>
        <trans-unit id="312240e44caf4f031c0d90c515deeb5d10139037" translate="yes" xml:space="preserve">
          <source>Note that in the above example, tests in the first subdirectory will not be run. To run all tests in the intermediary subdirectory preceding the one the test files are in, you need to explicitly note it:</source>
          <target state="translated">上記の例では、最初のサブディレクトリのテストは実行されないことに注意してください。テストファイルがあるディレクトリの前の中間サブディレクトリですべてのテストを実行するには、それを明示的にメモしておく必要があります。</target>
        </trans-unit>
        <trans-unit id="2e34b6badd14d9162b8051b5a13e0d935b53fb3b" translate="yes" xml:space="preserve">
          <source>Note that install() gives no meaningful return value. See uptodate().</source>
          <target state="translated">install()は意味のある戻り値を与えないことに注意してください。uptodate()を参照してください。</target>
        </trans-unit>
        <trans-unit id="275e7ac15e1f8f9535995287531c3b4b0bc12858" translate="yes" xml:space="preserve">
          <source>Note that it</source>
          <target state="translated">それはそれに注意してください。</target>
        </trans-unit>
        <trans-unit id="5f8451b3868737fe3b564168fce4efa0bb98f6a4" translate="yes" xml:space="preserve">
          <source>Note that it is a fatal error for any method (including &lt;code&gt;AUTOLOAD&lt;/code&gt; ) to attempt to redispatch any method that does not have the same name. For example:</source>
          <target state="translated">同じ名前を持たないメソッドを再ディスパッチしようとすると、メソッド（ &lt;code&gt;AUTOLOAD&lt;/code&gt; を含む）が致命的なエラーになることに注意してください。例えば：</target>
        </trans-unit>
        <trans-unit id="4c47d269e31ad3d486ed4d3aa4e0693a8502eee1" translate="yes" xml:space="preserve">
          <source>Note that it is a fatal error for any method (including &lt;code&gt;AUTOLOAD&lt;/code&gt;) to attempt to redispatch any method that does not have the same name. For example:</source>
          <target state="translated">同じ名前を持たないメソッドを再ディスパッチしようとすると、メソッド（ &lt;code&gt;AUTOLOAD&lt;/code&gt; を含む）にとって致命的なエラーになることに注意してください。例えば：</target>
        </trans-unit>
        <trans-unit id="01d339e0f582d233719162f7a04439bf08b5fc04" translate="yes" xml:space="preserve">
          <source>Note that it is generally not a good idea to try to build a perl with INST_DRV and INST_TOP set to a path that already exists from a previous build. In particular, this may cause problems with the lib/ExtUtils/t/Embed.t test, which attempts to build a test program and may end up building against the installed perl's lib/CORE directory rather than the one being tested.</source>
          <target state="translated">INST_DRV と INST_TOP を以前のビルドで既に存在していたパスに設定して perl をビルドしようとするのは、一般的に良い考えではないことに注意してください。特に、テストプログラムをビルドしようとする lib/ExtUtils/t/Embed.t テストで問題が発生する可能性があり、テストされているものではなくインストールされている perl の lib/CORE ディレクトリに対してビルドしてしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="d81b2599960bdecb9620115e70e867f7359ae0c4" translate="yes" xml:space="preserve">
          <source>Note that it is illegal to have code points that are larger than what can fit in an IV on the current machine.</source>
          <target state="translated">現行機のIVに収まるものよりも大きいコードポイントを持つことは違法であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="399a43994f597fec22280e4ffa2bc677a89fdfb6" translate="yes" xml:space="preserve">
          <source>Note that it is important to quote the __CALLER__::Roo identifier because a bug in perl 5.8 will refuse to parse it and cause an unknown error.</source>
          <target state="translated">perl 5.8 のバグで解析が拒否され、未知のエラーが発生するため、 __CALLER__::Roo 識別子を引用することが重要であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7affed7382c3656cc0a49bfbc4f14899cf69001a" translate="yes" xml:space="preserve">
          <source>Note that it is not advisable to access a file handle within a signal handler where that signal has interrupted an I/O operation on that same handle. While perl will at least try hard not to crash, there are no guarantees of data integrity; for example, some data might get dropped or written twice.</source>
          <target state="translated">シグナルハンドラ内のファイルハンドルにアクセスする際に、そのシグナルが同じハンドルのI/O操作を中断している場合には、アクセスしない方が良いことに注意してください。perl は少なくともクラッシュしないように努力しますが、データの完全性は保証されていません。</target>
        </trans-unit>
        <trans-unit id="6d3396c1176b4f12172442de7b35ea46ac2562aa" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to call &lt;code&gt;PUSHMARK&lt;/code&gt; in this instance. This is because</source>
          <target state="translated">この場合、 &lt;code&gt;PUSHMARK&lt;/code&gt; を呼び出す必要がないことに注意してください。それの訳は</target>
        </trans-unit>
        <trans-unit id="2b288b308a1bd032de8fa4a9b9c0a2a922d5b4a8" translate="yes" xml:space="preserve">
          <source>Note that it is okay to create a library which contains a dependent library that is already linked into perl.</source>
          <target state="translated">すでにperlにリンクされている依存ライブラリを含むライブラリを作成しても問題ないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="a2ad638116e9353f8a4dbaec6ebfef4f8d3c123f" translate="yes" xml:space="preserve">
          <source>Note that it is possible that the actions of a destructor called directly or indirectly by freeing an element of the array could cause the reference count of the array itself to be reduced (e.g. by deleting an entry in the symbol table). So it is a possibility that the AV could have been freed (or even reallocated) on return from the call unless you hold a reference to it.</source>
          <target state="translated">配列の要素を解放することによって直接または間接的に呼び出されたデストラクタの動作によって、配列自体の参照カウントが減少する可能性があることに注意してください (例えば、シンボルテーブルのエントリを削除することによって)。そのため、参照を保持していない限り、呼び出しから戻ってきたときに AV が解放されている (あるいは再割り当てされている)可能性があります。</target>
        </trans-unit>
        <trans-unit id="020e05231aab23e5af6e78f2d08d9849390e5ac0" translate="yes" xml:space="preserve">
          <source>Note that it is possible to have &lt;code&gt;__DATA__&lt;/code&gt; tokens in the same package in multiple files, and that the last &lt;code&gt;__DATA__&lt;/code&gt; token in a given package that is encountered by the compiler is the one accessible by the filehandle. This also applies to &lt;code&gt;__END__&lt;/code&gt; and main, i.e. if the 'main' program has an &lt;code&gt;__END__&lt;/code&gt; , but a module 'require'd (_not_ 'use'd) by that program has a 'package main;' declaration followed by an '&lt;code&gt;__DATA__&lt;/code&gt; ', then the &lt;code&gt;DATA&lt;/code&gt; filehandle is set to access the data after the &lt;code&gt;__DATA__&lt;/code&gt; in the module, _not_ the data after the &lt;code&gt;__END__&lt;/code&gt; token in the 'main' program, since the compiler encounters the 'require'd file later.</source>
          <target state="translated">複数のファイルの同じパッケージに &lt;code&gt;__DATA__&lt;/code&gt; トークンを含めることは可能であり、コンパイラーが検出する特定のパッケージの最後の &lt;code&gt;__DATA__&lt;/code&gt; トークンは、ファイルハンドルからアクセスできるトークンであることに注意してください。これもに適用され &lt;code&gt;__END__&lt;/code&gt; 「メイン」プログラムがある場合、メイン、すなわち &lt;code&gt;__END__&lt;/code&gt; を、しかし、そのプログラムは「require'd（_not_」モジュールuse'dが）している『メインパッケージ;』宣言「が続く &lt;code&gt;__DATA__&lt;/code&gt; 」は、 &lt;code&gt;DATA&lt;/code&gt; ファイルハンドルがデータの後のアクセスに設定されている &lt;code&gt;__DATA__&lt;/code&gt; 後のデータ_not_、モジュール内 &lt;code&gt;__END__&lt;/code&gt; コンパイラが「必要」に遭遇するので、「メイン」プログラムにおけるトークンdファイルは後で。</target>
        </trans-unit>
        <trans-unit id="7c22ec5e674939ca7dd16521f1a2590b4ddee243" translate="yes" xml:space="preserve">
          <source>Note that it is possible to have &lt;code&gt;__DATA__&lt;/code&gt; tokens in the same package in multiple files, and that the last &lt;code&gt;__DATA__&lt;/code&gt; token in a given package that is encountered by the compiler is the one accessible by the filehandle. This also applies to &lt;code&gt;__END__&lt;/code&gt; and main, i.e. if the 'main' program has an &lt;code&gt;__END__&lt;/code&gt;, but a module 'require'd (_not_ 'use'd) by that program has a 'package main;' declaration followed by an '&lt;code&gt;__DATA__&lt;/code&gt;', then the &lt;code&gt;DATA&lt;/code&gt; filehandle is set to access the data after the &lt;code&gt;__DATA__&lt;/code&gt; in the module, _not_ the data after the &lt;code&gt;__END__&lt;/code&gt; token in the 'main' program, since the compiler encounters the 'require'd file later.</source>
          <target state="translated">同じパッケージ内の &lt;code&gt;__DATA__&lt;/code&gt; トークンを複数のファイルに &lt;code&gt;__DATA__&lt;/code&gt; ことができ、コンパイラが検出した特定のパッケージ内の最後の__DATA__トークンは、ファイルハンドルからアクセスできるものであることに注意してください。これもに適用され &lt;code&gt;__END__&lt;/code&gt; 「メイン」プログラムがある場合、メイン、すなわち &lt;code&gt;__END__&lt;/code&gt; を、しかし、そのプログラムは「require'd（_not_」モジュールuse'dが）している『メインパッケージ;』宣言「が続く &lt;code&gt;__DATA__&lt;/code&gt; 」は、 &lt;code&gt;DATA&lt;/code&gt; ファイルハンドルがデータの後のアクセスに設定されている &lt;code&gt;__DATA__&lt;/code&gt; 後のデータ_not_、モジュール内 &lt;code&gt;__END__&lt;/code&gt; コンパイラが「必要」に遭遇するので、「メイン」プログラムにおけるトークンdファイルは後で。</target>
        </trans-unit>
        <trans-unit id="e02a747b9a7a24aeffcddaceb1b0a554d3946c9f" translate="yes" xml:space="preserve">
          <source>Note that it is possible to write portable code for these by specifying things in Unicode numbers, and using a conversion function:</source>
          <target state="translated">なお、Unicodeの数値で指定したり、変換関数を利用したりすることで、これらのポータブルなコードを書くことが可能です。</target>
        </trans-unit>
        <trans-unit id="597951c8ec638d515f08de4fa8f2ce8a96e0a9a0" translate="yes" xml:space="preserve">
          <source>Note that it is probably meaningless to call the functions overload::constant() and overload::remove_constant() from anywhere but import() and unimport() methods. From these methods they may be called as</source>
          <target state="translated">関数 overload::constant()と overload::remove_constant()を import()メソッドと unimport()メソッド以外の場所から呼び出すことはおそらく無意味であることに注意してください。これらのメソッドからは</target>
        </trans-unit>
        <trans-unit id="b593f41651d7a872851c870e53e6652c0659531a" translate="yes" xml:space="preserve">
          <source>Note that it isn't a good idea to specify these types of ranges anyway.</source>
          <target state="translated">いずれにせよ、これらのタイプの範囲を指定するのは良い考えではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="5dd80f85677999c53d6b25deeca079eeb865515a" translate="yes" xml:space="preserve">
          <source>Note that it only confirms the bare minimum structure (so as not to get confused by derived classes which may contain additional hash entries):</source>
          <target state="translated">これは最低限の構造を確認するだけであることに注意してください (追加のハッシュエントリを含む可能性のある派生クラスと混同されないように)。</target>
        </trans-unit>
        <trans-unit id="e50d411d2523ee4ff5b0357ec19f1bfed82fa0ca" translate="yes" xml:space="preserve">
          <source>Note that it's perfectly acceptable for some lines to have test numbers and others to not have them. However, when a test number is found, it must be in sequence. The following is also an error:</source>
          <target state="translated">テスト番号を持つ行と持たない行があることは完全に許容されることに注意してください。しかし、テスト番号がある場合は、それが順番に並んでいなければなりません。また、以下のようなエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="9a913045922e1a369e32f6e9094b0a8adfbe43e8" translate="yes" xml:space="preserve">
          <source>Note that it's possible to confuse Perl into thinking &lt;code&gt;//&lt;/code&gt; (the empty regex) is really &lt;code&gt;//&lt;/code&gt; (the defined-or operator). Perl is usually pretty good about this, but some pathological cases might trigger this, such as &lt;code&gt;$x///&lt;/code&gt; (is that &lt;code&gt;($x) / (//)&lt;/code&gt; or &lt;code&gt;$x // /&lt;/code&gt; ?) and &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $fh //&lt;/code&gt; (&lt;code&gt;print $fh(//&lt;/code&gt; or &lt;code&gt;print($fh //&lt;/code&gt;?). In all of these examples, Perl will assume you meant defined-or. If you meant the empty regex, just use parentheses or spaces to disambiguate, or even prefix the empty regex with an &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; (so &lt;code&gt;//&lt;/code&gt; becomes &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;//&lt;/code&gt; （空の正規表現）は実際には &lt;code&gt;//&lt;/code&gt; （定義済みまたは演算子）であるとPerlを混同する可能性があることに注意してください。 Perlは通常、この程度はかなり良いですが、いくつかの病理学的な例は、これをトリガーする可能性がある、など &lt;code&gt;$x///&lt;/code&gt; （ということである &lt;code&gt;($x) / (//)&lt;/code&gt; または &lt;code&gt;$x // /&lt;/code&gt; ？）と &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; $fh //&lt;/code&gt; （ &lt;code&gt;print $fh(//&lt;/code&gt; または &lt;code&gt;print($fh //&lt;/code&gt; ？）。これらすべての例で、Perlは定義された-または-を意味すると想定します。空の正規表現を意味する場合は、括弧またはスペースを使用して明確化するか、 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; を持つ空の正規表現（つまり &lt;code&gt;//&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a12f25b19f578d4ada5cb29c677b041e1603c474" translate="yes" xml:space="preserve">
          <source>Note that it's possible to confuse Perl into thinking &lt;code&gt;//&lt;/code&gt; (the empty regex) is really &lt;code&gt;//&lt;/code&gt; (the defined-or operator). Perl is usually pretty good about this, but some pathological cases might trigger this, such as &lt;code&gt;$x///&lt;/code&gt; (is that &lt;code&gt;($x) / (//)&lt;/code&gt; or &lt;code&gt;$x // /&lt;/code&gt;?) and &lt;code&gt;print $fh //&lt;/code&gt; (&lt;code&gt;print $fh(//&lt;/code&gt; or &lt;code&gt;print($fh //&lt;/code&gt;?). In all of these examples, Perl will assume you meant defined-or. If you meant the empty regex, just use parentheses or spaces to disambiguate, or even prefix the empty regex with an &lt;code&gt;m&lt;/code&gt; (so &lt;code&gt;//&lt;/code&gt; becomes &lt;code&gt;m//&lt;/code&gt;).</source>
          <target state="translated">Perlを &lt;code&gt;//&lt;/code&gt; （空の正規表現）が実際には &lt;code&gt;//&lt;/code&gt; （定義済みまたは演算子）であると誤解する可能性があることに注意してください。 Perlは通常これについてかなり良いですが、 &lt;code&gt;$x///&lt;/code&gt; （ &lt;code&gt;($x) / (//)&lt;/code&gt; または &lt;code&gt;$x // /&lt;/code&gt; ？）や &lt;code&gt;print $fh //&lt;/code&gt; （など、いくつかの病理学的ケースがこれをトリガーする可能性があります &lt;code&gt;print $fh(//&lt;/code&gt; または &lt;code&gt;print($fh //&lt;/code&gt; ？）。これらすべての例で、Perlは定義済みを意味すると想定します-または。空の正規表現を意味する場合は、括弧またはスペースを使用して明確にするか、接頭辞を付けます &lt;code&gt;m&lt;/code&gt; を含む空の正規表現（つまり &lt;code&gt;//&lt;/code&gt; は &lt;code&gt;m//&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="830a684c09bf9bdd212ea3a74c23e24fe820c679" translate="yes" xml:space="preserve">
          <source>Note that just as in C, Perl doesn't define &lt;b&gt;when&lt;/b&gt; the variable is incremented or decremented. You just know it will be done sometime before or after the value is returned. This also means that modifying a variable twice in the same statement will lead to undefined behavior. Avoid statements like:</source>
          <target state="translated">Cと同様に、Perlは変数がインクリメントまたはデクリメントさ&lt;b&gt;れるタイミングを&lt;/b&gt;定義しないことに注意してください。あなたはそれが値が返される前か後にいつか行われることを知っています。これは、同じステートメントで変数を2回変更すると、未定義の動作が発生することも意味します。次のような文は避けてください。</target>
        </trans-unit>
        <trans-unit id="a43f2c8c90c96b6a2393740d3a2acc243f34fc78" translate="yes" xml:space="preserve">
          <source>Note that just because a hash is initialized in that order doesn't mean that it comes out in that order. See &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; for examples of how to arrange for an output ordering.</source>
          <target state="translated">ハッシュがこの順序で初期化されるからといって、その順序でハッシュが出てくるとは限らないことに注意してください。出力の順序を調整する方法の例については、&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7f5a81a69fc5b10cd51900312887345ba64586f5" translate="yes" xml:space="preserve">
          <source>Note that just because a hash is initialized in that order doesn't mean that it comes out in that order. See &lt;a href=&quot;perlfunc#sort&quot;&gt;&quot;sort&quot; in perlfunc&lt;/a&gt; for examples of how to arrange for an output ordering.</source>
          <target state="translated">ハッシュがその順序で初期化されたからといって、それがその順序で出てくるとは限らないことに注意してください。出力順序を調整する方法の例については&lt;a href=&quot;perlfunc#sort&quot;&gt;、perlfuncの「sort」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c24181c497b3bc3da696d72d56d3b63ee4e8b425" translate="yes" xml:space="preserve">
          <source>Note that like all the punctuation variables, you cannot currently use my() on &lt;code&gt;$^W&lt;/code&gt; , only local().</source>
          <target state="translated">すべての句読点変数と同様に、現在 &lt;code&gt;$^W&lt;/code&gt; でmy（）を使用することはできず、local（）のみを使用することに注意してください。</target>
        </trans-unit>
        <trans-unit id="3fe7b7d8a3cbe9873ed0d90c76831403a33df538" translate="yes" xml:space="preserve">
          <source>Note that like all the punctuation variables, you cannot currently use my() on &lt;code&gt;$^W&lt;/code&gt;, only local().</source>
          <target state="translated">すべての句読点変数と同様に、現在 &lt;code&gt;$^W&lt;/code&gt; でmy（）を使用することはできず、local（）のみを使用することに注意してください。</target>
        </trans-unit>
        <trans-unit id="065e7735efe282ba9a9b62697058bf416b3fcc20" translate="yes" xml:space="preserve">
          <source>Note that macros &lt;code&gt;ST(i)&lt;/code&gt; , &lt;code&gt;XST_m*()&lt;/code&gt; and &lt;code&gt;XSRETURN*()&lt;/code&gt; work equally well in CODE: sections and PPCODE: sections.</source>
          <target state="translated">マクロ &lt;code&gt;ST(i)&lt;/code&gt; 、 &lt;code&gt;XST_m*()&lt;/code&gt; 、および &lt;code&gt;XSRETURN*()&lt;/code&gt; は、CODE：セクションとPPCODE：セクションで同様に機能することに注意してください。</target>
        </trans-unit>
        <trans-unit id="590d78c14b1f30644ceca6febcb1f178361e32a4" translate="yes" xml:space="preserve">
          <source>Note that macros &lt;code&gt;ST(i)&lt;/code&gt;, &lt;code&gt;XST_m*()&lt;/code&gt; and &lt;code&gt;XSRETURN*()&lt;/code&gt; work equally well in CODE: sections and PPCODE: sections.</source>
          <target state="translated">マクロ &lt;code&gt;ST(i)&lt;/code&gt; 、 &lt;code&gt;XST_m*()&lt;/code&gt; 、および &lt;code&gt;XSRETURN*()&lt;/code&gt; は、CODE：セクションとPPCODE：セクションで同等に機能することに注意してください。</target>
        </trans-unit>
        <trans-unit id="c14a124574e395835da21cb4f1ebabcb93935e43" translate="yes" xml:space="preserve">
          <source>Note that most Unicode characters don't have a decomposition, so their decomposition type is &lt;code&gt;&quot;None&quot;&lt;/code&gt; .</source>
          <target state="translated">ほとんどのUnicode文字には分解がないため、分解タイプは &lt;code&gt;&quot;None&quot;&lt;/code&gt; ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="5c45d58bad9499717ca648bdb916a02ec0cb0a26" translate="yes" xml:space="preserve">
          <source>Note that most Unicode characters don't have a decomposition, so their decomposition type is &lt;code&gt;&quot;None&quot;&lt;/code&gt;.</source>
          <target state="translated">ほとんどのUnicode文字には分解がないため、分解タイプは &lt;code&gt;&quot;None&quot;&lt;/code&gt; ことに注意してください。</target>
        </trans-unit>
        <trans-unit id="de00dbea9481bda931fa7e30e09096749bd42bf3" translate="yes" xml:space="preserve">
          <source>Note that multiple &quot;front-ends&quot; can latch into this debugging API simultaneously. This is intended to facilitate things like debugging with a command line and GUI at the same time, debugging debuggers etc. [Sounds nice, but this needs some serious support -- GSAR]</source>
          <target state="translated">複数の「フロントエンド」が同時にこのデバッグ API にラッチできることに注意してください。これは、コマンドラインと GUI を同時にデバッグしたり、デバッガをデバッグしたりすることを容易にすることを目的としています。いいように聞こえるが、これにはいくつかの深刻なサポートが必要だ --GSAR</target>
        </trans-unit>
        <trans-unit id="e6f8eb704c4d9544e078aafe993c9c4db8549a7e" translate="yes" xml:space="preserve">
          <source>Note that neither the &lt;b&gt;-w&lt;/b&gt; flag or the &lt;code&gt;$^W&lt;/code&gt; can be used to disable/enable default warnings. They are still mandatory in this case.</source>
          <target state="translated">&lt;b&gt;-w&lt;/b&gt;フラグも &lt;code&gt;$^W&lt;/code&gt; もデフォルトの警告を無効/有効にするために使用できないことに注意してください。この場合でも、これらは必須です。</target>
        </trans-unit>
        <trans-unit id="1452a217985729ac34f931918ed05a2f231bb7c5" translate="yes" xml:space="preserve">
          <source>Note that not all &lt;code&gt;siginfo&lt;/code&gt; values make sense simultaneously (some are valid only for certain signals, for example), and not all values make sense from Perl perspective, you should to consult your system's &lt;code&gt;sigaction&lt;/code&gt; and possibly also &lt;code&gt;siginfo&lt;/code&gt; documentation.</source>
          <target state="translated">すべての &lt;code&gt;siginfo&lt;/code&gt; 値が同時に意味があるわけではないことに注意してください（一部は特定の信号に対してのみ有効です）、Perlの観点からすべての値が意味があるわけではないので、システムの &lt;code&gt;sigaction&lt;/code&gt; や、場合によっては &lt;code&gt;siginfo&lt;/code&gt; のドキュメントも参照してください。</target>
        </trans-unit>
        <trans-unit id="7821dfbc405ad5ec367d208589dca3baa4ef11c2" translate="yes" xml:space="preserve">
          <source>Note that not all attributes are supported by all terminal types, and some terminals may not support any of these sequences. Dark and faint, italic, blink, and concealed in particular are frequently not implemented.</source>
          <target state="translated">すべての属性がすべての端末タイプでサポートされているわけではなく、端末によってはこれらのシーケンスのいずれもサポートしていない場合があることに注意してください。特に暗い・淡い、イタリック、瞬き、隠蔽などは実装されていないことが多いです。</target>
        </trans-unit>
        <trans-unit id="dd77ba7655fe65f19331164b0a905a5ad5a97693" translate="yes" xml:space="preserve">
          <source>Note that not all displays are ISO 6429-compliant, or even X3.64-compliant (or are even attempting to be so). This module will not work as expected on displays that do not honor these escape sequences, such as cmd.exe, 4nt.exe, and command.com under either Windows NT or Windows 2000. They may just be ignored, or they may display as an ESC character followed by some apparent garbage.</source>
          <target state="translated">すべてのディスプレイが ISO 6429 に準拠しているわけではありませんし、X3.64 に準拠しているわけでもありません (あるいは準拠しようとしているわけでもありません)。このモジュールは、Windows NT や Windows 2000 の cmd.exe、4nt.exe、command.com のように、これらのエスケープシーケンスを無視するディスプレイでは期待通りには動作しません。これらは無視されたり、ESC 文字の後にゴミのように表示されたりするかもしれません。</target>
        </trans-unit>
        <trans-unit id="9d7626cfa2c8cb10194e8906a42cfb46307be1b7" translate="yes" xml:space="preserve">
          <source>Note that not all features of Perl are available under these environments. This depends on the features the</source>
          <target state="translated">これらの環境でPerlのすべての機能が利用できるわけではないことに注意してください。これは</target>
        </trans-unit>
        <trans-unit id="b41fed2960927bbd3a7a4879e6c7ebbfd5148f75" translate="yes" xml:space="preserve">
          <source>Note that not all folders are defined on all versions of Windows.</source>
          <target state="translated">Windows のすべてのバージョンですべてのフォルダが定義されているわけではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="6d4d9996a72da721566e95c9b8f64cec116b411b" translate="yes" xml:space="preserve">
          <source>Note that not all incompatibilities are found.</source>
          <target state="translated">すべての非互換性が見つかるわけではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="e354090ffbf1edbb380e0fa597ae3be4af6cb16d" translate="yes" xml:space="preserve">
          <source>Note that not all modules will work with on all platforms. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for more information on portability issues. Read the documentation to see if the module will work on your system. There are basically three categories of modules that will not work &quot;out of the box&quot; with all platforms (with some possibility of overlap):</source>
          <target state="translated">すべてのモジュールがすべてのプラットフォームで機能するわけではないことに注意してください。移植性の問題の詳細については、&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;を参照してください。マニュアルを読んで、モジュールがシステムで機能するかどうかを確認してください。基本的に、すべてのプラットフォームで「そのまま」機能しない（オーバーラップする可能性がある）モジュールの3つのカテゴリーがあります。</target>
        </trans-unit>
        <trans-unit id="8d15a25a2ad944379a4980717687047ae9148ec3" translate="yes" xml:space="preserve">
          <source>Note that not all of the extensions available from CPAN may work in the Windows environment; you should check the information at &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http://www.cpantesters.org/&lt;/a&gt; before investing too much effort into porting modules that don't readily build.</source>
          <target state="translated">CPANから入手できるすべての拡張機能がWindows環境で機能するわけではないことに注意してください。簡単にビルドできないモジュールの移植に多大な労力を費やす前に、&lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;http：&lt;/a&gt; //www.cpantesters.org/で情報を確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="b09aa2530ba4d13d5bf9a219720506b2be0033b4" translate="yes" xml:space="preserve">
          <source>Note that not all of the extensions available from CPAN may work in the Windows environment; you should check the information at &lt;a href=&quot;https://www.cpantesters.org/&quot;&gt;https://www.cpantesters.org/&lt;/a&gt; before investing too much effort into porting modules that don't readily build.</source>
          <target state="translated">CPANから利用できるすべての拡張機能がWindows環境で機能するとは限らないことに注意してください。簡単にビルドできないモジュールの移植に多大な労力を費やす前に、&lt;a href=&quot;https://www.cpantesters.org/&quot;&gt;https：//www.cpantesters.org/で&lt;/a&gt;情報を確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="df4084be0514f39566a9c52b9eaf1e3d0173ba9e" translate="yes" xml:space="preserve">
          <source>Note that not all platforms support disabling this option. Some, at least OpenBSD and MirBSD, will fail with &lt;code&gt;EINVAL&lt;/code&gt; if you attempt to disable it. To determine whether it is possible to disable, you may use the class method</source>
          <target state="translated">すべてのプラットフォームがこのオプションの無効化をサポートしているわけではないことに注意してください。少なくともOpenBSDとMirBSDの中には、無効にしようとすると &lt;code&gt;EINVAL&lt;/code&gt; で失敗するものがあります。無効にできるかどうかを判断するには、クラスメソッドを使用できます</target>
        </trans-unit>
        <trans-unit id="8b6848dffa9b06cabb4c87ddb649c3cc22a5f54c" translate="yes" xml:space="preserve">
          <source>Note that numerical precision has the same meaning as under Perl (so binary to decimal conversion follows the same rules as in Perl, which can differ to other languages). Also, your perl interpreter might expose extensions to the floating point numbers of your platform, such as infinities or NaN's - these cannot be represented in JSON, and it is an error to pass those in.</source>
          <target state="translated">数値精度はPerlと同じ意味を持つことに注意してください(2進数から10進数への変換はPerlと同じルールに従いますが、他の言語とは異なる可能性があります)。また、Perlのインタープリタは、無限大やNaNのようなプラットフォームの浮動小数点数の拡張機能を公開しているかもしれません-これらはJSONでは表現できません。</target>
        </trans-unit>
        <trans-unit id="814895e1fc7075770faad339ecd10e73c24fbc5f" translate="yes" xml:space="preserve">
          <source>Note that numf is called by quant for stringifying all quantifying numbers.</source>
          <target state="translated">numfは、すべての量化数を文字列化するためにquantによって呼ばれていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f0564c5fce02fbef6630b978932f6aa1e763b70b" translate="yes" xml:space="preserve">
          <source>Note that older Pod formatters might not recognize octal or hex numeric escapes, and that many formatters cannot reliably render characters above 255. (Some formatters may even have to use compromised renderings of Latin-1/CP-1252 characters, like rendering &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; as just a plain &quot;e&quot;.)</source>
          <target state="translated">古いポッドフォーマッターは8進数または16進数のエスケープを認識しない可能性があり、多くのフォーマッターは255を超える文字を確実にレンダリングできないことに注意してください。（ &lt;code&gt;E&amp;lt;eacute&amp;gt;&lt;/code&gt; 単なる &quot;e&quot;として。）</target>
        </trans-unit>
        <trans-unit id="4fe6034079ad6a013e5f8b58c3a64f050566c116" translate="yes" xml:space="preserve">
          <source>Note that on Windows, address space allocation granularity is 64 KB, therefore, setting the stack smaller than that on Win32 Perl will not save any more memory.</source>
          <target state="translated">Windowsでは、アドレス空間の割り当ての粒度が64KBなので、Win32のPerlではそれよりもスタックを小さく設定しても、それ以上のメモリの節約にはならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="9b131d252a3bfc8b5c8ad8d09c7187e733df7c40" translate="yes" xml:space="preserve">
          <source>Note that on input (string to number) Perl accepts &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; in many forms. Case is ignored, and the Win32-specific forms like &lt;code&gt;1.#INF&lt;/code&gt; are understood, but on output the values are normalized to &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; .</source>
          <target state="translated">入力（文字列から数値）では、Perlは &lt;code&gt;Inf&lt;/code&gt; と &lt;code&gt;NaN&lt;/code&gt; を多くの形式で受け入れます。大文字と小文字は無視され、 &lt;code&gt;1.#INF&lt;/code&gt; などのWin32固有の形式は理解されますが、出力時には値は &lt;code&gt;Inf&lt;/code&gt; と &lt;code&gt;NaN&lt;/code&gt; に正規化されます。</target>
        </trans-unit>
        <trans-unit id="d6ea49ea44abd8799ce4dfc75293c4bfcb155f89" translate="yes" xml:space="preserve">
          <source>Note that on input (string to number) Perl accepts &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; in many forms. Case is ignored, and the Win32-specific forms like &lt;code&gt;1.#INF&lt;/code&gt; are understood, but on output the values are normalized to &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">入力（文字列から数値）では、Perlは多くの形式で &lt;code&gt;Inf&lt;/code&gt; と &lt;code&gt;NaN&lt;/code&gt; を受け入れることに注意してください。大文字と小文字は区別されず、 &lt;code&gt;1.#INF&lt;/code&gt; などのWin32固有の形式は理解されますが、出力では、値は &lt;code&gt;Inf&lt;/code&gt; と &lt;code&gt;NaN&lt;/code&gt; に正規化されます。</target>
        </trans-unit>
        <trans-unit id="eb6ba392df3d7fde91ed08ef1f5b7c759eb9d39f" translate="yes" xml:space="preserve">
          <source>Note that on some systems, a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped. See &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for details, and for other examples.</source>
          <target state="translated">一部のシステムでは、戻り値が &lt;code&gt;-1&lt;/code&gt; の場合、子プロセスが自動的に取得される可能性があることに注意してください。詳細およびその他の例については、&lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="abc04d7473c212695d1b705a8da3b88080d0bbab" translate="yes" xml:space="preserve">
          <source>Note that on some systems, a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details, and for other examples.</source>
          <target state="translated">一部のシステムでは、戻り値が &lt;code&gt;-1&lt;/code&gt; の場合、子プロセスが自動的に取得される可能性があることに注意してください。詳細およびその他の例については、&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="baef8826a89d43d1f8e9e1ff1d1484160a339674" translate="yes" xml:space="preserve">
          <source>Note that only localized variable changes are undone. Other side effects of code expression execution are permanent. Thus</source>
          <target state="translated">ローカライズされた変数の変更のみが取り消されることに注意してください。コード式の実行による他の副作用は永久的です。したがって</target>
        </trans-unit>
        <trans-unit id="9e8b3ca63f560a2fa0e18c2ef188ef76edc6e881" translate="yes" xml:space="preserve">
          <source>Note that only perl can truly parse Perl, so all such CASE tools fall somewhat short of the mark, especially if you don't program your Perl as a C programmer might.</source>
          <target state="translated">PerlをパースできるのはPerlだけなので、C言語のプログラマーのようにPerlをプログラミングしない場合は、CASEツールのようなツールはどれも少し物足りないということに注意してください。</target>
        </trans-unit>
        <trans-unit id="32ee21a94e6bacfd587283dcf64796ed246e6431" translate="yes" xml:space="preserve">
          <source>Note that op_next is not manipulated, and nodes are not freed; that is the responsibility of the caller. It also won't create a new list op for an empty list etc; use higher-level functions like op_append_elem() for that.</source>
          <target state="translated">op_next は操作されず、ノードも解放されないことに注意してください。また、空のリストなどのために新しいリスト op を作成することもありません;そのためには op_append_elem()のような高レベルの関数を使用してください。</target>
        </trans-unit>
        <trans-unit id="54c807dda3550fe223a1b1c55cd9bed9ee48d31f" translate="yes" xml:space="preserve">
          <source>Note that pad_findlex() is recursive; it recurses up the chain of CVs, then comes back down, adding fake entries as it goes. It has to be this way because fake names in anon protoypes have to store in xlow the index into the parent pad.</source>
          <target state="translated">pad_findlex()は再帰的であることに注意してください.アノン・プロトタイプの偽名は,親パッドへのインデックスを xlow に格納しなければならないため,このようにしなければなりません.</target>
        </trans-unit>
        <trans-unit id="131b045dcad1d95b29a85c93d3a6715d69d24db9" translate="yes" xml:space="preserve">
          <source>Note that parentheses are necessary when you're chomping anything that is not a simple variable. This is because &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; is interpreted as &lt;code&gt;(&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; , rather than as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; which you might expect. Similarly, &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; is interpreted as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; rather than as &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</source>
          <target state="translated">単純な変数ではないものを選択する場合は、括弧が必要であることに注意してください。これは、 &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; &lt;code&gt;(&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; として解釈されます。、あなたが期待するかもしれない &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; としてではなく。同様に、 &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; （$ a、$ b）ではなく &lt;code&gt;&lt;a href=&quot;chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; として解釈されます。</target>
        </trans-unit>
        <trans-unit id="346dbcf702d3c4fdb72e5c159c8678dc946b771c" translate="yes" xml:space="preserve">
          <source>Note that parentheses are necessary when you're chomping anything that is not a simple variable. This is because &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; is interpreted as &lt;code&gt;(&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; , rather than as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; which you might expect. Similarly, &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; is interpreted as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; rather than as &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; .</source>
          <target state="translated">単純な変数ではないものを選択する場合は、括弧が必要であることに注意してください。これは、 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd = `pwd`;&lt;/code&gt; &lt;code&gt;(&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $cwd) = `pwd`;&lt;/code&gt; として解釈されます。、あなたが期待するかもしれない &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;( $cwd = `pwd` )&lt;/code&gt; としてではなく。同様に、 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt; $a, $b&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a, $b)&lt;/code&gt; （$ a、$ b）ではなく &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;($a), $b&lt;/code&gt; として解釈されます。</target>
        </trans-unit>
        <trans-unit id="018c1697a99aff61964cd62c6350adc2116be64d" translate="yes" xml:space="preserve">
          <source>Note that parentheses are necessary when you're chomping anything that is not a simple variable. This is because &lt;code&gt;chomp $cwd = `pwd`;&lt;/code&gt; is interpreted as &lt;code&gt;(chomp $cwd) = `pwd`;&lt;/code&gt;, rather than as &lt;code&gt;chomp( $cwd = `pwd` )&lt;/code&gt; which you might expect. Similarly, &lt;code&gt;chomp $a, $b&lt;/code&gt; is interpreted as &lt;code&gt;chomp($a), $b&lt;/code&gt; rather than as &lt;code&gt;chomp($a, $b)&lt;/code&gt;.</source>
          <target state="translated">単純な変数以外のものを切り刻む場合は、括弧が必要であることに注意してください。これは、 &lt;code&gt;chomp $cwd = `pwd`;&lt;/code&gt; &lt;code&gt;(chomp $cwd) = `pwd`;&lt;/code&gt; として解釈されます。、あなたが期待するかもしれない &lt;code&gt;chomp( $cwd = `pwd` )&lt;/code&gt; としてではなく。同様に、 &lt;code&gt;chomp $a, $b&lt;/code&gt; として解釈さ &lt;code&gt;chomp($a), $b&lt;/code&gt; はなくとして &lt;code&gt;chomp($a, $b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b290990bc28b21efbb6fc62a4d6a7e3869dd2f55" translate="yes" xml:space="preserve">
          <source>Note that parts of this code were derived from &lt;a href=&quot;YAML::Tiny&quot;&gt;YAML::Tiny&lt;/a&gt; with the permission of Adam Kennedy.</source>
          <target state="translated">このコードの一部は、&lt;a href=&quot;YAML::Tiny&quot;&gt;AdamKennedy&lt;/a&gt;の許可を得てYAML :: Tinyから派生したものであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="61028061478cb52a55b53cfd7830a40515024150" translate="yes" xml:space="preserve">
          <source>Note that parts of this code were derived from &lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML::Tiny&lt;/a&gt; with the permission of Adam Kennedy.</source>
          <target state="translated">このコードの一部は、Adam Kennedyの許可を得て&lt;a href=&quot;http://search.cpan.org/perldoc/YAML::Tiny&quot;&gt;YAML :: Tiny&lt;/a&gt;から派生したものであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b192f3ab8b3b79b49c3da2be5c05a7696156013b" translate="yes" xml:space="preserve">
          <source>Note that pod translators should look at only paragraphs beginning with a pod directive (it makes parsing easier), whereas the compiler actually knows to look for pod escapes even in the middle of a paragraph. This means that the following secret stuff will be ignored by both the compiler and the translators.</source>
          <target state="translated">ポッド翻訳者はポッドディレクティブで始まる段落だけを見るべきであることに注意してください(その方が解析が楽になります)。これは、以下の秘密事項はコンパイラと翻訳者の両方に無視されることを意味します。</target>
        </trans-unit>
        <trans-unit id="97f97f44b8a98fafc1d8a756bd8a55c77c58d9e9" translate="yes" xml:space="preserve">
          <source>Note that precision is not accuracy - binary floating point values cannot represent most decimal fractions exactly, and when converting from and to floating point, JSON::PP only guarantees precision up to but not including the least significant bit.</source>
          <target state="translated">精度は精度ではないことに注意してください-2 進浮動小数点値は、ほとんどの小数を正確に表すことはできません。</target>
        </trans-unit>
        <trans-unit id="ff72d3ac5b8dd647a96a960672acd7ebcc2f3ccc" translate="yes" xml:space="preserve">
          <source>Note that reports about bugs in old versions of Perl, especially those which indicate you haven't also tested the current stable release of Perl, are likely to receive less attention from the volunteers who build and maintain Perl than reports about bugs in the current release.</source>
          <target state="translated">古いバージョンのPerlのバグ、特に現在の安定版Perlのリリースをテストしていないことを示すバグの報告は、現在のリリースのバグについての報告よりも、Perlをビルドして保守するボランティアからの注目度が低くなる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c75bcf48cfe25108045a83673fe9bf46dbdb6cb7" translate="yes" xml:space="preserve">
          <source>Note that reversing an array to itself (as in &lt;code&gt;@a = &lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ) will preserve non-existent elements whenever possible; i.e., for non-magical arrays or for tied arrays with &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; methods.</source>
          <target state="translated">配列をそれ自体に反転すると（ &lt;code&gt;@a = &lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ）、存在しない要素は可能な限り保持されます。つまり、非魔法の配列または &lt;code&gt;EXISTS&lt;/code&gt; および &lt;code&gt;DELETE&lt;/code&gt; メソッドを使用した結合配列の場合です。</target>
        </trans-unit>
        <trans-unit id="3279ef396cd3fe9ed1f5c93958f688b3a02be9e7" translate="yes" xml:space="preserve">
          <source>Note that reversing an array to itself (as in &lt;code&gt;@a = &lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ) will preserve non-existent elements whenever possible; i.e., for non-magical arrays or for tied arrays with &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; methods.</source>
          <target state="translated">配列をそれ自体に反転すると（ &lt;code&gt;@a = &lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt; @a&lt;/code&gt; ）、存在しない要素は可能な限り保持されます。つまり、非魔法の配列または &lt;code&gt;EXISTS&lt;/code&gt; および &lt;code&gt;DELETE&lt;/code&gt; メソッドを使用した結合配列の場合です。</target>
        </trans-unit>
        <trans-unit id="cefecfaf8ad606f51bb60e49b8b1e7ead07fd207" translate="yes" xml:space="preserve">
          <source>Note that reversing an array to itself (as in &lt;code&gt;@a = reverse @a&lt;/code&gt;) will preserve non-existent elements whenever possible; i.e., for non-magical arrays or for tied arrays with &lt;code&gt;EXISTS&lt;/code&gt; and &lt;code&gt;DELETE&lt;/code&gt; methods.</source>
          <target state="translated">配列をそれ自体に逆にする（ &lt;code&gt;@a = reverse @a&lt;/code&gt; ）と、可能な限り存在しない要素が保持されることに注意してください。つまり、非魔法の配列、または &lt;code&gt;EXISTS&lt;/code&gt; メソッドと &lt;code&gt;DELETE&lt;/code&gt; メソッドを使用した結合配列の場合です。</target>
        </trans-unit>
        <trans-unit id="a0bebc4223d6e9d86efc4ab961e85c3b37f4d12a" translate="yes" xml:space="preserve">
          <source>Note that rewinddir() has a similar limitation on Windows and will not force readdir() to read the directory again either. Only a newly opened directory handle will reflect changes to the directory.</source>
          <target state="translated">Windows では rewinddir()にも同様の制限があり、 readdir()がディレクトリを再読み込みすることはないことに注意してください。新しく開いたディレクトリハンドルだけがディレクトリへの変更を反映します。</target>
        </trans-unit>
        <trans-unit id="ac3e7d8ec9774f1fc514c0a850fb3669a2dac43e" translate="yes" xml:space="preserve">
          <source>Note that section names might contain markup. I.e., if a section starts with:</source>
          <target state="translated">セクション名にはマークアップが含まれている可能性があることに注意してください。例えば、セクションが.</target>
        </trans-unit>
        <trans-unit id="5cd547b6f9a21623648f43fd2d180495971977d8" translate="yes" xml:space="preserve">
          <source>Note that setting precision and accuracy at the same time is not possible.</source>
          <target state="translated">精度と精度を同時に設定することはできませんのでご注意ください。</target>
        </trans-unit>
        <trans-unit id="2dfa6206994e5b2e572924979f052b36e73802cd" translate="yes" xml:space="preserve">
          <source>Note that several apps spew crap to stderr every time you connect, which can throw off Configure. You may need to monkeypatch the part of Configure that creates &lt;code&gt;run-ssh&lt;/code&gt; to have it discard stderr.</source>
          <target state="translated">いくつかのアプリは、接続するたびにstderrにがらくたを吐き出し、Configureをスローする可能性があることに注意してください。stderrを破棄するために、 &lt;code&gt;run-ssh&lt;/code&gt; を作成するConfigureの部分にモンキーパッチを適用する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="2489b5c14780b59ec0536b9418bfecf1ef230d00" translate="yes" xml:space="preserve">
          <source>Note that since Perl 5.10.0 a // can also be the</source>
          <target state="translated">Perl 5.10.0 以降、 //は</target>
        </trans-unit>
        <trans-unit id="f4f6bc0bb0b72e537a474e9d5b08d81afb1f9c79" translate="yes" xml:space="preserve">
          <source>Note that since Perl 5.8.1 the single-number v-strings (like &lt;code&gt;v65&lt;/code&gt; ) are not v-strings before the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator (which is usually used to separate a hash key from a hash value); instead they are interpreted as literal strings ('v65'). They were v-strings from Perl 5.6.0 to Perl 5.8.0, but that caused more confusion and breakage than good. Multi-number v-strings like &lt;code&gt;v65.66&lt;/code&gt; and &lt;code&gt;65.66.67&lt;/code&gt; continue to be v-strings always.</source>
          <target state="translated">Perl 5.8.1以降、単一番号のv-string（ &lt;code&gt;v65&lt;/code&gt; のような）は &lt;code&gt;=&amp;gt;&lt;/code&gt; 演算子の前のv-stringではないことに注意してください（通常、ハッシュ値からハッシュキーを分離するために使用されます）。代わりに、それらはリテラル文字列（ 'v65'）として解釈されます。それらはPerl 5.6.0からPerl 5.8.0までのv-stringでしたが、それは良いことよりも混乱と破損を引き起こしました。 &lt;code&gt;v65.66&lt;/code&gt; や &lt;code&gt;65.66.67&lt;/code&gt; のような複数番号のv文字列は、引き続きv文字列のままです。</target>
        </trans-unit>
        <trans-unit id="008b6ecd9594a1f31168dc7af3eef7ef69846a54" translate="yes" xml:space="preserve">
          <source>Note that since Perl 5.8.1 the single-number v-strings (like &lt;code&gt;v65&lt;/code&gt;) are not v-strings before the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator (which is usually used to separate a hash key from a hash value); instead they are interpreted as literal strings ('v65'). They were v-strings from Perl 5.6.0 to Perl 5.8.0, but that caused more confusion and breakage than good. Multi-number v-strings like &lt;code&gt;v65.66&lt;/code&gt; and &lt;code&gt;65.66.67&lt;/code&gt; continue to be v-strings always.</source>
          <target state="translated">Perl 5.8.1以降、単一番号のv文字列（ &lt;code&gt;v65&lt;/code&gt; など）は、 &lt;code&gt;=&amp;gt;&lt;/code&gt; 演算子（通常、ハッシュキーをハッシュ値から分離するために使用されます）の前のv文字列ではないことに注意してください。代わりに、リテラル文字列（ 'v65'）として解釈されます。それらはPerl5.6.0からPerl5.8.0までのv文字列でしたが、それは良いよりも多くの混乱と破損を引き起こしました。 &lt;code&gt;v65.66&lt;/code&gt; や &lt;code&gt;65.66.67&lt;/code&gt; のような複数番号のv文字列は、常にv文字列のままです。</target>
        </trans-unit>
        <trans-unit id="19ef149a186b458f11686fd9d31157ce1f5a0ebd" translate="yes" xml:space="preserve">
          <source>Note that since Perl version 5.16 this function has been a no-op, but this might change in a future release.</source>
          <target state="translated">Perl のバージョン 5.16 以降、この関数は動作しないようになっていますが、将来のリリースでは変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6c5b88d706c28965b53567c8427b594ad63f74e3" translate="yes" xml:space="preserve">
          <source>Note that skipping white space applies only to the interior of this construct. There must not be any space between any of the characters that form the initial &lt;code&gt;(?[&lt;/code&gt; . Nor may there be space between the closing &lt;code&gt;])&lt;/code&gt; characters.</source>
          <target state="translated">空白のスキップは、この構成の内部にのみ適用されることに注意してください。最初の &lt;code&gt;(?[&lt;/code&gt; 。終わりの &lt;code&gt;])&lt;/code&gt; 文字の間にスペースがあってはいけません。</target>
        </trans-unit>
        <trans-unit id="545af0b2b09ce2f37c97dabd56794edec8a64fad" translate="yes" xml:space="preserve">
          <source>Note that skipping white space applies only to the interior of this construct. There must not be any space between any of the characters that form the initial &lt;code&gt;(?[&lt;/code&gt;. Nor may there be space between the closing &lt;code&gt;])&lt;/code&gt; characters.</source>
          <target state="translated">空白のスキップは、この構成の内部にのみ適用されることに注意してください。最初の &lt;code&gt;(?[&lt;/code&gt; 。また、終了 &lt;code&gt;])&lt;/code&gt; 文字を形成する文字の間にスペースがあってはなりません。</target>
        </trans-unit>
        <trans-unit id="7426c9a1b07347627eeb1ac1cf62af6a1907ba1a" translate="yes" xml:space="preserve">
          <source>Note that some UNIX mail systems can mess with text attachments containing 'From '. This will fix them up:</source>
          <target state="translated">UNIX のメールシステムの中には、'From' を含むテキストの添付ファイルをいじることができるものがあることに注意してください。これはそれらを修正します。</target>
        </trans-unit>
        <trans-unit id="1c060aa4bbf33c5b1f0215edf2ae5f526f55cd18" translate="yes" xml:space="preserve">
          <source>Note that some URLs have hexadecimal ASCII code points in them in an attempt to overcome character or protocol limitation issues. For example the tilde character is not on every keyboard hence a URL of the form:</source>
          <target state="translated">URLの中には、文字やプロトコルの制限の問題を克服するために16進数のASCIIコードポイントを使用しているものがあることに注意してください。例えば、チルダ文字はすべてのキーボードで使用できるわけではないので、このような形式のURLになっています。</target>
        </trans-unit>
        <trans-unit id="b0ec6733c239960d7ab748fd5e743c87866db919" translate="yes" xml:space="preserve">
          <source>Note that some system &lt;code&gt;an&lt;/code&gt; macro sets assume that the centered footer will be a modification date and will prepend something like &quot;Last modified: &quot;. If this is the case for your target system, you may want to set &lt;b&gt;--release&lt;/b&gt; to the last modified date and &lt;b&gt;--date&lt;/b&gt; to the version number.</source>
          <target state="translated">一部のシステム &lt;code&gt;an&lt;/code&gt; マクロセットでは、中央に配置されたフッターが変更日であると想定し、「最終変更日：」のように先頭に追加することに注意してください。これはあなたのターゲット・システムの場合は、あなたが設定することもできます&lt;b&gt;--release&lt;/b&gt;最終更新日時とに&lt;b&gt;--date&lt;/b&gt;バージョン番号。</target>
        </trans-unit>
        <trans-unit id="5782148c53cb53f800e7cc24f499baa2f09d812f" translate="yes" xml:space="preserve">
          <source>Note that some system &lt;code&gt;an&lt;/code&gt; macro sets assume that the centered footer will be a modification date and will prepend something like &quot;Last modified: &quot;. If this is the case for your target system, you may want to set &lt;code&gt;release&lt;/code&gt; to the last modified date and &lt;code&gt;date&lt;/code&gt; to the version number.</source>
          <target state="translated">一部のシステム &lt;code&gt;an&lt;/code&gt; マクロセットでは、中央に配置されたフッターが変更日であると想定し、「最終変更日：」のように先頭に追加することに注意してください。これがターゲットシステムに当てはまる場合は、 &lt;code&gt;release&lt;/code&gt; を最終変更日に &lt;code&gt;date&lt;/code&gt; し、日付をバージョン番号に設定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="96757558cf943b3af9fec33e5de374cf8022a75a" translate="yes" xml:space="preserve">
          <source>Note that some types of arguments/return-values for functions may result in XSUB-declarations/typemap-entries which need hand-editing. Such may be objects which cannot be converted from/to a pointer (like &lt;code&gt;long long&lt;/code&gt; ), pointers to functions, or arrays. See also the section on &lt;a href=&quot;#LIMITATIONS-of--x&quot;&gt;LIMITATIONS of -x&lt;/a&gt;.</source>
          <target state="translated">関数の引数/戻り値のタイプによっては、手動で編集する必要のあるXSUB-declarations / typemap-entriesが発生する場合があることに注意してください。これには、ポインター（ &lt;code&gt;long long&lt;/code&gt; など）との間で変換できないオブジェクト、関数へのポインター、または配列を使用できます。&lt;a href=&quot;#LIMITATIONS-of--x&quot;&gt;-xの制限&lt;/a&gt;に関するセクションも参照してください。</target>
        </trans-unit>
        <trans-unit id="a6ea1587e3db14d628357c10f80019ced4d3486b" translate="yes" xml:space="preserve">
          <source>Note that some types of arguments/return-values for functions may result in XSUB-declarations/typemap-entries which need hand-editing. Such may be objects which cannot be converted from/to a pointer (like &lt;code&gt;long long&lt;/code&gt;), pointers to functions, or arrays. See also the section on &lt;a href=&quot;#LIMITATIONS-of-x&quot;&gt;&quot;LIMITATIONS of &lt;b&gt;-x&lt;/b&gt;&quot;&lt;/a&gt;.</source>
          <target state="translated">関数の引数/戻り値のタイプによっては、XSUB-declarations / typemap-entriesが発生する可能性があることに注意してください。これには手動での編集が必要です。これは、ポインタ（ &lt;code&gt;long long&lt;/code&gt; など）との間で変換できないオブジェクト、関数へのポインタ、または配列である可能性があります。また、上のセクションを参照してください&lt;a href=&quot;#LIMITATIONS-of-x&quot;&gt;「の限界&lt;b&gt;-xを&lt;/b&gt;」&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fcd18b02b9dc35274d6564c64032ca709a95c4f6" translate="yes" xml:space="preserve">
          <source>Note that spaces in the format argument to &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; do not denote literal spaces. If you have space separated data, you may want &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; のformat引数のスペースは、リテラルスペースを意味しないことに注意してください。スペースで区切られたデータがある場合は、代わりに &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="662d6982ca6578815a4a0f18cc0ec8305ec26773" translate="yes" xml:space="preserve">
          <source>Note that spaces in the format argument to &lt;code&gt;unpack&lt;/code&gt; do not denote literal spaces. If you have space separated data, you may want &lt;code&gt;split&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;unpack&lt;/code&gt; するformat引数のスペースは、リテラルスペースを示していないことに注意してください。スペースで区切られたデータがある場合は、代わりに &lt;code&gt;split&lt;/code&gt; することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a2b6650d0cfdddfa7918a6366723469de7b3aca7" translate="yes" xml:space="preserve">
          <source>Note that splitting an EXPR that evaluates to the empty string always produces zero fields, regardless of the LIMIT specified.</source>
          <target state="translated">空の文字列として評価される EXPR を分割すると、指定された LIMIT に関係なく、常に 0 フィールドが生成されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="77e878278c2299b62e83869de869a2f9253eaf40" translate="yes" xml:space="preserve">
          <source>Note that starting from Perl 5.7.2 (and consequently 5.8.0) and AIX 4.3 or newer Perl uses the AIX native dynamic loading interface in the so called runtime linking mode instead of the emulated interface that was used in Perl releases 5.6.1 and earlier or, for AIX releases 4.2 and earlier. This change does break backward compatibility with compiled modules from earlier Perl releases. The change was made to make Perl more compliant with other applications like Apache/mod_perl which are using the AIX native interface. This change also enables the use of C++ code with static constructors and destructors in Perl extensions, which was not possible using the emulated interface.</source>
          <target state="translated">Perl 5.7.2 (結果として 5.8.0)と AIX 4.3 以降の Perl では、Perl 5.6.1 以前の Perl リリースや AIX 4.2 以前の Perl リリースで使用されていたエミュレートされたインターフェイスの代わりに、いわゆるランタイム・リンキング・モードで AIX ネイティブのダイナミック・ローディング・インターフェイスを使用することに注意してください。この変更により、以前の Perl リリースからコンパイルされたモジュールとの下位互換性が失われます。この変更は、AIX ネイティブインタフェースを使用している Apache/mod_perl のような他のアプリケーションに Perl をより準拠させるために行われました。この変更はまた、エミュレートされたインタフェースを使用していなかった Perl 拡張で静的なコンストラクタとデストラクタを持つ C++コードの使用を可能にします。</target>
        </trans-unit>
        <trans-unit id="e00838249311f81e98bfc06fb08536fb7ec9966f" translate="yes" xml:space="preserve">
          <source>Note that starting in Unicode 6.1, many of the block names have shorter synonyms. These are always given in the new style.</source>
          <target state="translated">Unicode 6.1 からは、ブロック名の多くがより短い同義語を持つようになっていることに注意してください。これらは常に新しいスタイルで与えられます。</target>
        </trans-unit>
        <trans-unit id="2ad7004d8cad106c4c2f0c2a7d60864d3c8b1736" translate="yes" xml:space="preserve">
          <source>Note that strtol() and strtoul() may be disguised as Strtol(), Strtoul(), Atol(), Atoul(). Avoid those, too.</source>
          <target state="translated">strtol()や strtoul()は、Strtol()、Strtoul()、Atol()、Atoul()と偽装されている可能性があることに注意してください。これらも避けましょう。</target>
        </trans-unit>
        <trans-unit id="1f8d123671f8fe6351f73c10ea6c3fa3f4b1a51f" translate="yes" xml:space="preserve">
          <source>Note that tabs and spaces are compared strictly, meaning 1 tab will not match 8 spaces.</source>
          <target state="translated">タブとスペースは厳密に比較され、1つのタブが8つのスペースと一致しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="da058756ddccf3047bc3134e13ea20e3af855473" translate="yes" xml:space="preserve">
          <source>Note that testing is finished. If no plan has been set this will generate a Plan event.</source>
          <target state="translated">テストが終了したことに注意してください。プランが設定されていない場合は、プランイベントが生成されます。</target>
        </trans-unit>
        <trans-unit id="643a90b7cc572aa8f24a2a4aeec18309319e74d7" translate="yes" xml:space="preserve">
          <source>Note that the</source>
          <target state="translated">に注意してください。</target>
        </trans-unit>
        <trans-unit id="6672243740cead8683b9d1445f8ead3531c13383" translate="yes" xml:space="preserve">
          <source>Note that the &quot;default stack&quot; depends on the operating system and on the Perl version, and both the compile-time and runtime configurations of Perl. The default can be overridden by setting the environment variable PERLIO to a space or colon separated list of layers, however this cannot be used to set layers that require loading modules like &lt;code&gt;:encoding&lt;/code&gt;.</source>
          <target state="translated">「デフォルトスタック」は、オペレーティングシステムとPerlのバージョン、およびPerlのコンパイル時とランタイムの両方の構成に依存することに注意してください。デフォルトは、環境変数PERLIOをスペースまたはコロンで区切られたレイヤーのリストに設定することでオーバーライドできますが、これを使用して、 &lt;code&gt;:encoding&lt;/code&gt; などのモジュールのロードが必要なレイヤーを設定することはできません。</target>
        </trans-unit>
        <trans-unit id="94925dc9df0f22c049d74f88d76450a9a690c2cd" translate="yes" xml:space="preserve">
          <source>Note that the 0 index of @{^CAPTURE} is equivalent to $1, the 1 index is equivalent to $2, etc.</source>
          <target state="translated">なお、@{^capture}の0インデックスは$1に相当し、1インデックスは$2に相当します。</target>
        </trans-unit>
        <trans-unit id="06f90013b3209e32ef045a540920a533398fa647" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; emulation of &lt;a href=&quot;http://man.he.net/man3/flock&quot;&gt;flock(3)&lt;/a&gt; requires that FILEHANDLE be open with read intent to use LOCK_SH and requires that it be open with write intent to use LOCK_EX.</source>
          <target state="translated">&lt;a href=&quot;http://man.he.net/man3/flock&quot;&gt;flock（3）&lt;/a&gt;の&lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl（2）&lt;/a&gt;エミュレーションでは、FILEHANDLEがLOCK_SHを使用するために読み取りインテントで開かれている必要があり、LOCK_EXを使用するために書き込みインテントで開かれている必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f6fcc2fd58a5941d9e57fbe4a6f4e6ca8d35d36f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;perlfunc#select-FILEHANDLE&quot;&gt;&lt;code&gt;select FILEHANDLE&lt;/code&gt;&lt;/a&gt; form is generally portable.</source>
          <target state="translated">&lt;a href=&quot;perlfunc#select-FILEHANDLE&quot;&gt; &lt;code&gt;select FILEHANDLE&lt;/code&gt; &lt;/a&gt;フォームは一般的に移植可能であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5879e45ce93c6c3511286267d5813593e72f0a4e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;d&quot;&lt;/code&gt;, &lt;code&gt;&quot;l&quot;&lt;/code&gt;, &lt;code&gt;&quot;p&quot;&lt;/code&gt;, and &lt;code&gt;&quot;u&quot;&lt;/code&gt; modifiers are special in that they can only be enabled, not disabled, and the &lt;code&gt;&quot;a&quot;&lt;/code&gt;, &lt;code&gt;&quot;d&quot;&lt;/code&gt;, &lt;code&gt;&quot;l&quot;&lt;/code&gt;, and &lt;code&gt;&quot;u&quot;&lt;/code&gt; modifiers are mutually exclusive: specifying one de-specifies the others, and a maximum of one (or two &lt;code&gt;&quot;a&quot;&lt;/code&gt;'s) may appear in the construct. Thus, for example, &lt;code&gt;(?-p)&lt;/code&gt; will warn when compiled under &lt;code&gt;use warnings&lt;/code&gt;; &lt;code&gt;(?-d:...)&lt;/code&gt; and &lt;code&gt;(?dl:...)&lt;/code&gt; are fatal errors.</source>
          <target state="translated">&lt;code&gt;&quot;a&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;d&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;l&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;p&quot;&lt;/code&gt; 、および &lt;code&gt;&quot;u&quot;&lt;/code&gt; 修飾子は、有効にすることはでき、無効にすることはできず、 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;d&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;l&quot;&lt;/code&gt; は特別であることに注意してください。、および &lt;code&gt;&quot;u&quot;&lt;/code&gt; 修飾子は相互に排他的です。1つを指定すると、他の修飾子の指定が解除され、最大1つ（または2つの &lt;code&gt;&quot;a&quot;&lt;/code&gt; ）が構成に表示される場合があります。したがって、たとえば、 &lt;code&gt;(?-p)&lt;/code&gt; は、 &lt;code&gt;use warnings&lt;/code&gt; 下でコンパイルされると警告します。 &lt;code&gt;(?-d:...)&lt;/code&gt; と &lt;code&gt;(?dl:...)&lt;/code&gt; は致命的なエラーです。</target>
        </trans-unit>
        <trans-unit id="4a13e460ac63aeef5172c4e67fabd8f175a93e35" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%b&lt;/code&gt; , the short forms of the day of the week and the month of the year, may not necessarily be three characters wide.</source>
          <target state="translated">&lt;code&gt;%a&lt;/code&gt; と &lt;code&gt;%b&lt;/code&gt; は、曜日と月の短い形式であり、必ずしも3文字幅であるとは限らないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="c990c52d20bce03cc1931306413c2445b6287df4" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;-L&lt;/code&gt; and &lt;code&gt;-l&lt;/code&gt; prefixes are &lt;b&gt;not required&lt;/b&gt;, but authors who wish their extensions to be portable to Unix or OS/2 should use the prefixes, since the Unix-OS/2 version of ext() requires them.</source>
          <target state="translated">注こと &lt;code&gt;-L&lt;/code&gt; と &lt;code&gt;-l&lt;/code&gt; プレフィックスがされている&lt;b&gt;必要はありません&lt;/b&gt;が、EXTのUnix系OS / 2版は（）、それらを必要とするため、その拡張子を希望する著者は、接頭辞を使用する必要がありますUnixやOS / 2に移植できるように。</target>
        </trans-unit>
        <trans-unit id="1fb35d0c6e79a4294b3591fc47c05224b1801d3d" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; FILEHANDLE&lt;/code&gt; form is generally portable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt; FILEHANDLE&lt;/code&gt; フォームは一般に移植可能であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9806508e6a2529870cc2037f1710d22cb6ace5d5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;XSOPT&lt;/code&gt; MakeMaker option may be used to add these options to any makefiles generated by MakeMaker.</source>
          <target state="translated">&lt;code&gt;XSOPT&lt;/code&gt; MakeMakerオプションを使用して、これらのオプションをMakeMakerによって生成された任意のメイクファイルに追加できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="86802402b451982daee5eec807ff6ea5529eaefd" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; , and &lt;code&gt;u&lt;/code&gt; modifiers are special in that they can only be enabled, not disabled, and the &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;u&lt;/code&gt; modifiers are mutually exclusive: specifying one de-specifies the others, and a maximum of one (or two &lt;code&gt;a&lt;/code&gt; 's) may appear in the construct. Thus, for example, &lt;code&gt;(?-p)&lt;/code&gt; will warn when compiled under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; ; &lt;code&gt;(?-d:...)&lt;/code&gt; and &lt;code&gt;(?dl:...)&lt;/code&gt; are fatal errors.</source>
          <target state="translated">なお &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;d&lt;/code&gt; 、 &lt;code&gt;l&lt;/code&gt; 、 &lt;code&gt;p&lt;/code&gt; 、および &lt;code&gt;u&lt;/code&gt; の修飾子は、彼らが唯一有効にすることができることを、無効になっていないでは特別であり、 &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;d&lt;/code&gt; 、 &lt;code&gt;l&lt;/code&gt; 、および &lt;code&gt;u&lt;/code&gt; 修飾子が相互に排他的である：1デ指定他人を指定して、また、最大で1つ（または2つの &lt;code&gt;a&lt;/code&gt; ）が構造体に現れる場合があります。したがって、たとえば、 &lt;code&gt;(?-p)&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; でコンパイルされたときに警告します。 &lt;code&gt;(?-d:...)&lt;/code&gt; と &lt;code&gt;(?dl:...)&lt;/code&gt; は致命的なエラーです。</target>
        </trans-unit>
        <trans-unit id="b75233b2e52c1643f13c545ab5448e1216afde19" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the $ctx object is automatically &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; and can be used to calculate another digest value. Call $ctx-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="translated">&lt;code&gt;digest&lt;/code&gt; 操作は事実上、破壊的で読み取りが1回の操作であることに注意してください。実行されると、$ ctxオブジェクトは自動的に &lt;code&gt;&lt;a href=&quot;functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; 、別のダイジェスト値の計算に使用できます。ダイジェストの状態をリセットせずにダイジェストを計算する場合は、$ ctx-&amp;gt; clone-&amp;gt; digestを呼び出します。</target>
        </trans-unit>
        <trans-unit id="ce0a012ac00944b517f4c494f69adcd759afd120" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the $ctx object is automatically &lt;code&gt;reset&lt;/code&gt; and can be used to calculate another digest value. Call $ctx-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="translated">&lt;code&gt;digest&lt;/code&gt; 操作は、事実上、破壊的な1回限りの操作であることに注意してください。実行されると、$ ctxオブジェクトは自動的に &lt;code&gt;reset&lt;/code&gt; 、別のダイジェスト値を計算するために使用できます。ダイジェストの状態をリセットせずにダイジェストを計算する場合は、$ ctx-&amp;gt; clone-&amp;gt; digestを呼び出します。</target>
        </trans-unit>
        <trans-unit id="2e408b4bb22ad308085742938ea428bf4e618d3e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the &lt;code&gt;Digest::MD5&lt;/code&gt; object is automatically &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; and can be used to calculate another digest value. Call $md5-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="translated">&lt;code&gt;digest&lt;/code&gt; 操作は事実上、破壊的で読み取りが1回の操作であることに注意してください。実行されると、 &lt;code&gt;Digest::MD5&lt;/code&gt; オブジェクトは自動的に &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; 、別のダイジェスト値の計算に使用できます。ダイジェストの状態をリセットせずにダイジェストを計算する場合は、$ md5-&amp;gt; clone-&amp;gt; digestを呼び出します。</target>
        </trans-unit>
        <trans-unit id="30d1356fb08343a518e41acb4dd7ec7580812f65" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;digest&lt;/code&gt; operation is effectively a destructive, read-once operation. Once it has been performed, the &lt;code&gt;Digest::MD5&lt;/code&gt; object is automatically &lt;code&gt;reset&lt;/code&gt; and can be used to calculate another digest value. Call $md5-&amp;gt;clone-&amp;gt;digest if you want to calculate the digest without resetting the digest state.</source>
          <target state="translated">&lt;code&gt;digest&lt;/code&gt; 操作は、事実上、破壊的な1回限りの操作であることに注意してください。実行されると、 &lt;code&gt;Digest::MD5&lt;/code&gt; オブジェクトは自動的に &lt;code&gt;reset&lt;/code&gt; 、別のダイジェスト値を計算するために使用できます。ダイジェスト状態をリセットせずにダイジェストを計算する場合は、$ md5-&amp;gt; clone-&amp;gt; digestを呼び出します。</target>
        </trans-unit>
        <trans-unit id="d24eeff32ed6f4a19c0009f5d0e023c636e7a94e" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;to&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; macros in</source>
          <target state="translated">注意 &lt;code&gt;is&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; と &lt;code&gt;to&lt;i&gt;FOO&lt;/i&gt;&lt;/code&gt; 中のマクロ</target>
        </trans-unit>
        <trans-unit id="a2d5c53bebb44c78258b20f3af06f6f909ee7256" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;use Pod::Simple::Debug (\$x, &lt;i&gt;somenum&lt;/i&gt;)&lt;/code&gt; mode will make Pod::Simple (et al) run rather slower, since &amp;amp;Pod::Simple::DEBUG won't be a constant sub anymore, and so Pod::Simple (et al) won't compile with constant-folding.</source>
          <target state="translated">ことを注意 &lt;code&gt;use Pod::Simple::Debug (\$x, &lt;i&gt;somenum&lt;/i&gt;)&lt;/code&gt; モードはポッド:: Simpleは（ら）以来＆ポッド::シンプル:: DEBUGはもう一定のサブではありません、むしろ遅くなるでしょう、そのため、Pod :: Simple（et al）は定数折りたたみでコンパイルされません。</target>
        </trans-unit>
        <trans-unit id="20cd55dfd99c6b7ca8f8c3e96afe94485ab2aeca" translate="yes" xml:space="preserve">
          <source>Note that the API described here changed considerably in perl 5.24; prior to that, big macros like &lt;code&gt;PUSHBLOCK&lt;/code&gt; and &lt;code&gt;POPSUB&lt;/code&gt; were used; in 5.24 they were replaced by the inline static functions described below. In addition, the ordering and detail of how these macros/function work changed in many ways, often subtly. In particular they didn't handle saving the savestack and temps stack positions, and required additional &lt;code&gt;ENTER&lt;/code&gt;, &lt;code&gt;SAVETMPS&lt;/code&gt; and &lt;code&gt;LEAVE&lt;/code&gt; compared to the new functions. The old-style macros will not be described further.</source>
          <target state="translated">ここで説明するAPIは、perl5.24で大幅に変更されていることに注意してください。それ以前は、 &lt;code&gt;PUSHBLOCK&lt;/code&gt; や &lt;code&gt;POPSUB&lt;/code&gt; などの大きなマクロが使用されていました。5.24では、これらは以下に説明するインライン静的関数に置き換えられました。さらに、これらのマクロ/関数がどのように機能するかの順序と詳細は、多くの点で、しばしば微妙に変化しました。特に、savestackとtempsスタックの位置の保存を処理せず、新しい関数と比較して、追加の &lt;code&gt;ENTER&lt;/code&gt; 、 &lt;code&gt;SAVETMPS&lt;/code&gt; 、および &lt;code&gt;LEAVE&lt;/code&gt; が必要でした。古いスタイルのマクロについては、これ以上説明しません。</target>
        </trans-unit>
        <trans-unit id="9551d033cb29a27fd5d6bf1fe4833c6cf7eaf2fe" translate="yes" xml:space="preserve">
          <source>Note that the CPU seconds is the &lt;b&gt;minimum&lt;/b&gt; time: CPU scheduling and other operating system factors may complicate the attempt so that a little bit more time is spent. The benchmark output will, however, also tell the number of &lt;code&gt;$code&lt;/code&gt; runs/second, which should be a more interesting number than the actually spent seconds.</source>
          <target state="translated">CPU秒は&lt;b&gt;最小&lt;/b&gt;時間であることに注意してください。CPUのスケジュールやその他のオペレーティングシステムの要因により、試行が複雑になり、少し時間がかかる場合があります。ただし、ベンチマークの出力は &lt;code&gt;$code&lt;/code&gt; runs / secondの数も示します。これは、実際に費やされた秒数よりも興味深い数値です。</target>
        </trans-unit>
        <trans-unit id="28d680a1e0dab71002ed6eded256a885c900ba34" translate="yes" xml:space="preserve">
          <source>Note that the EXPR can be arbitrarily complicated as long as the final operation is a hash or array key lookup or subroutine name:</source>
          <target state="translated">EXPRは、最終的な操作がハッシュまたは配列のキールックアップまたはサブルーチン名である限り、任意に複雑にすることができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f0084fb8a7b9ce4d56aecba3fadc51d825f62ba8" translate="yes" xml:space="preserve">
          <source>Note that the Encode implementation of GSM0338 does not implement the reuse of Latin capital letters as Greek capital letters (for example, the 0x5A is U+005A (LATIN CAPITAL LETTER Z), not U+0396 (GREEK CAPITAL LETTER ZETA).</source>
          <target state="translated">GSM0338のEncode実装は、ラテン文字の大文字をギリシャ文字として再利用することを実装していないことに注意してください(例えば、0x5AはU+0396(GREEK CAPITAL LETTER ZETA)ではなく、U+005A(LATIN CAPITAL LETTER Z)となります)。</target>
        </trans-unit>
        <trans-unit id="afc125ebc0373a09cca375f9b07fbcd59b2c703e" translate="yes" xml:space="preserve">
          <source>Note that the G_KEEPERR flag does not propagate into inner evals; these may still set &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">G_KEEPERRフラグは内部評価に伝播しないことに注意してください。これらはまだ &lt;code&gt;$@&lt;/code&gt; 設定するかもしれません。</target>
        </trans-unit>
        <trans-unit id="997492b2704e0f5c940f0988ed8b0f1470e9f2f1" translate="yes" xml:space="preserve">
          <source>Note that the G_KEEPERR flag does not propagate into inner evals; these may still set &lt;code&gt;$@&lt;/code&gt;.</source>
          <target state="translated">G_KEEPERRフラグは内部評価に伝播しないことに注意してください。これらはまだ &lt;code&gt;$@&lt;/code&gt; 設定する可能性があります。</target>
        </trans-unit>
        <trans-unit id="1f14f1b3c2ecac55af54ec64471c279be4e1559f" translate="yes" xml:space="preserve">
          <source>Note that the MAP_TARGET value *must* have the &quot;.exe&quot; extension or you will not create a &quot;perl.exe&quot; to replace the one in &lt;code&gt;($DJDIR)/bin&lt;/code&gt; .</source>
          <target state="translated">MAP_TARGET値には「.exe」拡張子が付いている必要があることに注意してください。そうしないと、（perl.exe）を作成して &lt;code&gt;($DJDIR)/bin&lt;/code&gt; あるものと置き換えることはできません。</target>
        </trans-unit>
        <trans-unit id="8caaca0bc214aa98766a1940f6cdf2d7b3d021af" translate="yes" xml:space="preserve">
          <source>Note that the MAP_TARGET value *must* have the &quot;.exe&quot; extension or you will not create a &quot;perl.exe&quot; to replace the one in &lt;code&gt;($DJDIR)/bin&lt;/code&gt;.</source>
          <target state="translated">MAP_TARGET値には「.exe」拡張子が*必要*であることに注意してください。そうしないと、 &lt;code&gt;($DJDIR)/bin&lt;/code&gt; あるものを置き換える「perl.exe」を作成しません。</target>
        </trans-unit>
        <trans-unit id="54136d6700549a5defbb3ceccf1ce74752ff9160" translate="yes" xml:space="preserve">
          <source>Note that the MD5 algorithm is not as strong as it used to be. It has since 2005 been easy to generate different messages that produce the same MD5 digest. It still seems hard to generate messages that produce a given digest, but it is probably wise to move to stronger algorithms for applications that depend on the digest to uniquely identify a message.</source>
          <target state="translated">MD5アルゴリズムは以前ほど強力ではないことに注意してください。2005年以降、同じMD5ダイジェストを生成する異なるメッセージを生成することが容易になりました。与えられたダイジェストを生成するメッセージを生成するのはまだ難しいようですが、メッセージを一意に識別するためにダイジェストに依存するアプリケーションのためには、より強力なアルゴリズムに移行するのが賢明でしょう。</target>
        </trans-unit>
        <trans-unit id="247c1a806843ed2e2d60424a5f01f9ce095fc287" translate="yes" xml:space="preserve">
          <source>Note that the MinGW build currently requires a MinGW runtime version earlier than 3.21 (check __MINGW32_MAJOR_VERSION and __MINGW32_MINOR_VERSION).</source>
          <target state="translated">なお、MinGWのビルドでは、現在のところ3.21以前のMinGWランタイムバージョンが必要です(__MINGW32_MAJOR_VERSIONと__MINGW32_MINOR_VERSIONを確認してください)。</target>
        </trans-unit>
        <trans-unit id="09f5d2315ce8efb902a4b01848317f36e6d46300" translate="yes" xml:space="preserve">
          <source>Note that the PerlIO equivalents of &lt;code&gt;fread&lt;/code&gt; and &lt;code&gt;fwrite&lt;/code&gt; are slightly different from their C library counterparts:</source>
          <target state="translated">PerlIOでの &lt;code&gt;fread&lt;/code&gt; と &lt;code&gt;fwrite&lt;/code&gt; に相当するものは、対応するCライブラリのものとは少し異なります。</target>
        </trans-unit>
        <trans-unit id="b520e7f3d86206ae6fb132d75305e69c64963146" translate="yes" xml:space="preserve">
          <source>Note that the Script_Extensions property is an improved version of the Script property, and you should probably be using that instead, with the &lt;a href=&quot;#charprop%28%29&quot;&gt;&quot;charprop()&quot;&lt;/a&gt; function.</source>
          <target state="translated">Script_ExtensionsプロパティはScriptプロパティの改良版であり、代わりに&lt;a href=&quot;#charprop%28%29&quot;&gt;「charprop（）」&lt;/a&gt;関数を使用する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c898fd225c811d3b33264eb9a5dd3fac5a9a201b" translate="yes" xml:space="preserve">
          <source>Note that the Symbian filesystem is very picky: it strongly prefers the \ instead of the /.</source>
          <target state="translated">Symbian ファイルシステムは非常に慎重であることに注意してください:それは/の代わりに 強く \ を好む。</target>
        </trans-unit>
        <trans-unit id="f053db6da6e575d7b066a2e19e4c949dfd7c2c0f" translate="yes" xml:space="preserve">
          <source>Note that the above implementation shuffles an array in place, unlike the &lt;code&gt;List::Util::shuffle()&lt;/code&gt; which takes a list and returns a new shuffled list.</source>
          <target state="translated">上記の実装は、リストを受け取って新しいシャッフルされたリストを返す &lt;code&gt;List::Util::shuffle()&lt;/code&gt; とは異なり、配列を所定の位置にシャッフルすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b065a3ad25b4fc5b70a8b34ad20e23ed1b7c3cb3" translate="yes" xml:space="preserve">
          <source>Note that the above two invocations will be very verbose as reachable memory and leak-checking is enabled by default. If you want to just see pure errors, try:</source>
          <target state="translated">リーチャブルメモリとリークチェックはデフォルトで有効になっているので、上記の二つの呼び出しは非常に冗長になることに注意してください。純粋なエラーだけを見たいのであれば、試してみてください。</target>
        </trans-unit>
        <trans-unit id="64532abb5f09f86d92c621e51038db0bcc100d92" translate="yes" xml:space="preserve">
          <source>Note that the actual meanings of the various fields are not that well standardized, do not expect any great portability. The &lt;code&gt;$sysname&lt;/code&gt; might be the name of the operating system, the &lt;code&gt;$nodename&lt;/code&gt; might be the name of the host, the &lt;code&gt;$release&lt;/code&gt; might be the (major) release number of the operating system, the &lt;code&gt;$version&lt;/code&gt; might be the (minor) release number of the operating system, and the &lt;code&gt;$machine&lt;/code&gt; might be a hardware identifier. Maybe.</source>
          <target state="translated">さまざまなフィールドの実際の意味はあまり標準化されていないことに注意してください。大きな移植性を期待しないでください。 &lt;code&gt;$sysname&lt;/code&gt; オペレーティングシステムの名前は、あるかもしれない &lt;code&gt;$nodename&lt;/code&gt; 、ホストの名前であるかもしれない &lt;code&gt;$release&lt;/code&gt; 、オペレーティングシステムの（主要な）リリース番号であるかもしれない &lt;code&gt;$version&lt;/code&gt; （マイナー）リリース番号であるかもしれませんオペレーティングシステム、および &lt;code&gt;$machine&lt;/code&gt; はハードウェア識別子である可能性があります。多分。</target>
        </trans-unit>
        <trans-unit id="f2424ff844845a48b6b1b2cd57585ba63cec58ff" translate="yes" xml:space="preserve">
          <source>Note that the alias EU_ALWAYS_COPY will be supported if EU_INSTALL_ALWAYS_COPY is not defined until at least the 1.50 release. Please ensure you use the correct EU_INSTALL_ALWAYS_COPY.</source>
          <target state="translated">少なくとも1.50リリースまでは、EU_INSTALL_ALWAYSが定義されていない場合、エイリアスEU_ALWAYSがサポートされることに注意してください。正しいEU_INSTALL_ALWAYSを使用するようにしてください。</target>
        </trans-unit>
        <trans-unit id="b57c85ca6eca16bd7229db94019acde3ad48fd66" translate="yes" xml:space="preserve">
          <source>Note that the assignment &lt;code&gt;$\ = $/&lt;/code&gt; is done when the switch is processed, so the input record separator can be different than the output record separator if the &lt;b&gt;-l&lt;/b&gt; switch is followed by a &lt;a href=&quot;#-0%5Boctal%2Fhexadecimal%5D&quot;&gt;-0&lt;/a&gt; switch:</source>
          <target state="translated">割り当て &lt;code&gt;$\ = $/&lt;/code&gt; はスイッチの処理時に行われるため、&lt;b&gt;-l&lt;/b&gt;スイッチの後に&lt;a href=&quot;#-0%5Boctal%2Fhexadecimal%5D&quot;&gt;-0&lt;/a&gt;スイッチが続く場合、入力レコード区切り文字は出力レコード区切り文字とは異なる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="26b36cb20c7dae889459ec2f6f9db24992abdb43" translate="yes" xml:space="preserve">
          <source>Note that the assignment &lt;code&gt;$\ = $/&lt;/code&gt; is done when the switch is processed, so the input record separator can be different than the output record separator if the &lt;b&gt;-l&lt;/b&gt; switch is followed by a &lt;b&gt;-0&lt;/b&gt; switch:</source>
          <target state="translated">割り当て &lt;code&gt;$\ = $/&lt;/code&gt; はスイッチが処理されるときに行われるため、&lt;b&gt;-l&lt;/b&gt;スイッチの後に&lt;b&gt;-0&lt;/b&gt;スイッチが続く場合、入力レコードセパレーターは出力レコードセパレーターとは異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="c00bf502c45bde6ba2060e9d911a339007fd5405" translate="yes" xml:space="preserve">
          <source>Note that the backslash itself is special; if you want to match a backslash, you have to escape the backslash with a backslash: &lt;code&gt;/\\/&lt;/code&gt; matches a single backslash.</source>
          <target state="translated">バックスラッシュ自体は特別であることに注意してください。バックスラッシュに一致させたい場合は、バックスラッシュでバックスラッシュをエスケープする必要があります &lt;code&gt;/\\/&lt;/code&gt; は単一のバックスラッシュに一致します。</target>
        </trans-unit>
        <trans-unit id="f6ebed0705c42d69729c70593af8e15098cbc1e9" translate="yes" xml:space="preserve">
          <source>Note that the base64 encoded string returned is not padded to be a multiple of 4 bytes long. If you want interoperability with other base64 encoded md5 digests you might want to append the redundant string &quot;==&quot; to the result.</source>
          <target state="translated">返されるbase64エンコードされた文字列は、4バイトの倍数になるようにパディングされていないことに注意してください。他のbase64エンコードされたmd5ダイジェストとの相互運用性を確保したい場合は、結果に冗長な文字列&quot;==&quot;を追加した方が良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="772992efab68f2396f54e27fdd4bb3868704a8b7" translate="yes" xml:space="preserve">
          <source>Note that the braces are required in Perl, even if you've only got one line in the block. However, there is a clever way of making your one-line conditional blocks more English like:</source>
          <target state="translated">Perlでは、たとえブロック内に一行しかない場合でも、中括弧は必須であることに注意してください。しかし、1行だけの条件付きブロックをより英語風にする巧妙な方法があります。</target>
        </trans-unit>
        <trans-unit id="ece9838263d6bf6e2a7db9094c48c8c8ea6e66ec" translate="yes" xml:space="preserve">
          <source>Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">呼び出し元は、呼び出しの前に &lt;code&gt;val&lt;/code&gt; の参照カウントを適切にインクリメントし、関数が &lt;code&gt;NULL&lt;/code&gt; を返した場合はそれをデクリメントする責任があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6f7f794be85b20ad885b31b3bd4e8712126125c7" translate="yes" xml:space="preserve">
          <source>Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL.</source>
          <target state="translated">呼び出し元は、呼び出しの前に &lt;code&gt;val&lt;/code&gt; の参照カウントを適切にインクリメントし、関数がNULLを返した場合はそれをデクリメントする責任があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4f5d7bcf37a5b2a38715b73f67483220347ce0f3" translate="yes" xml:space="preserve">
          <source>Note that the code might be broken into multiple segments if there are nested formatting codes inside a &lt;code&gt;C&amp;lt;...&amp;gt;&lt;/code&gt; sequence. In between the calls to &lt;code&gt;handle_code&lt;/code&gt; other markup tags might have been emitted in that case. The same is true for verbatim sections if the &lt;code&gt;codes_in_verbatim&lt;/code&gt; option is turned on.</source>
          <target state="translated">&lt;code&gt;C&amp;lt;...&amp;gt;&lt;/code&gt; シーケンス内にネストされたフォーマットコードがある場合、コードが複数のセグメントに分割される可能性があることに注意してください。その場合、 &lt;code&gt;handle_code&lt;/code&gt; の呼び出しの合間に、他のマークアップタグが発行された可能性があります。 &lt;code&gt;codes_in_verbatim&lt;/code&gt; オプションがオンになっている場合、逐語的セクションについても同じことが言えます。</target>
        </trans-unit>
        <trans-unit id="8cd0e4a20a7367cc4b5ead8187ea067b769ad671" translate="yes" xml:space="preserve">
          <source>Note that the effect is compile-time and immutable once defined. However, the subroutines are passed a single parameter, which is 0 if case-sensitive matching is in effect and non-zero if caseless matching is in effect. The subroutine may return different values depending on the value of the flag, and one set of values will immutably be in effect for all case-sensitive matches, and the other set for all case-insensitive matches.</source>
          <target state="translated">この効果はコンパイル時のものであり、一度定義されると不変であることに注意してください。しかし、サブルーチンには単一のパラメータが渡され、大文字小文字を区別しないマッチが有効な場合は0、大文字小文字を区別しないマッチが有効な場合は0以外の値を返します。このサブルーチンはフラグの値に応じて異なる値を返すことがあり、ある値のセットはすべての大文字小文字を区別しないマッチに対して不変的に有効になり、もう一つのセットはすべての大文字小文字を区別しないマッチに対して有効になります。</target>
        </trans-unit>
        <trans-unit id="82a2a038be5dc98f1cb9f3946ca4a644efda3ae0" translate="yes" xml:space="preserve">
          <source>Note that the effect of &lt;code&gt;binmode&lt;/code&gt; differs from that of the binmode() function on operating systems such as Windows and MSDOS, and is not needed to process most types of file.</source>
          <target state="translated">&lt;code&gt;binmode&lt;/code&gt; の効果は、WindowsやMSDOSなどのオペレーティングシステムでのbinmode（）関数の効果とは異なり、ほとんどの種類のファイルを処理するために必要ではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="83d0991fa33934053d27ec9e77b0dcc73eda0b3d" translate="yes" xml:space="preserve">
          <source>Note that the embedded single-quotes in the string don't help in this case, since they have not been specified as acceptable delimiters and are therefore treated as non-delimiter characters (and ignored).</source>
          <target state="translated">文字列の中に埋め込まれたシングルクォートは、この場合には何の役にも立たないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="1a60f273853beeeddbd8dccab4c57df4281d7707" translate="yes" xml:space="preserve">
          <source>Note that the emulation built with &lt;a href=&quot;http://man.he.net/man3/lockf&quot;&gt;lockf(3)&lt;/a&gt; doesn't provide shared locks, and it requires that FILEHANDLE be open with write intent. These are the semantics that &lt;a href=&quot;http://man.he.net/man3/lockf&quot;&gt;lockf(3)&lt;/a&gt; implements. Most if not all systems implement &lt;a href=&quot;http://man.he.net/man3/lockf&quot;&gt;lockf(3)&lt;/a&gt; in terms of &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; locking, though, so the differing semantics shouldn't bite too many people.</source>
          <target state="translated">&lt;a href=&quot;http://man.he.net/man3/lockf&quot;&gt;lockf（3）で&lt;/a&gt;構築されたエミュレーションは共有ロックを提供しないことに注意してください。また、書き込み目的でFILEHANDLEを開く必要があります。これらは、&lt;a href=&quot;http://man.he.net/man3/lockf&quot;&gt;lockf（3）が&lt;/a&gt;実装するセマンティクスです。ただし、すべてではないにしてもほとんどのシステムは、&lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl（2）&lt;/a&gt;ロックに関して&lt;a href=&quot;http://man.he.net/man3/lockf&quot;&gt;lockf（3）を&lt;/a&gt;実装しているため、セマンティクスの違いによって多くの人が噛み付くことはありません。</target>
        </trans-unit>
        <trans-unit id="1eb58ec9da82570c29bbbb5325581cb00b947ded" translate="yes" xml:space="preserve">
          <source>Note that the emulation built with lockf(3) doesn't provide shared locks, and it requires that FILEHANDLE be open with write intent. These are the semantics that lockf(3) implements. Most if not all systems implement lockf(3) in terms of fcntl(2) locking, though, so the differing semantics shouldn't bite too many people.</source>
          <target state="translated">lockf(3)で構築されたエミュレーションは共有ロックを提供せず、FILEHANDLE が書き込み意図を持って開かれていることを必要とすることに注意してください。これらは lockf(3)が実装するセマンティクスです。しかし、すべてのシステムではないにせよ、ほとんどのシステムは fcntl(2)ロックの観点から lockf(3)を実装しているので、異なるセマンティクスが多くの人を悩ませることはないはずです。</target>
        </trans-unit>
        <trans-unit id="07238884ca9ae6e9d1b98c9eab9e8272e50d79b1" translate="yes" xml:space="preserve">
          <source>Note that the encoding itself is &lt;b&gt;not&lt;/b&gt; a formally valid language tag. Note also that you cannot, currently, go from an encoding back to a language tag that it's an encoding of.</source>
          <target state="translated">エンコーディング自体は正式に有効な言語タグでは&lt;b&gt;ない&lt;/b&gt;ことに注意してください。また、現在のところ、エンコーディングから、それがエンコーディングである言語タグに戻ることはできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="5a48ddc9bb68bd34263110aaa842399866ebadf6" translate="yes" xml:space="preserve">
          <source>Note that the expanded form represents the way perl handles such constructions internally -- this option actually turns off the reverse translation that B::Deparse usually does. On the other hand, note that &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; is not the same as &lt;code&gt;$x = $y&lt;/code&gt; : the former makes the value of $y into a string before doing the assignment.</source>
          <target state="translated">拡張された形式は、perlがそのような構造を内部的に処理する方法を表すことに注意してください-このオプションは、実際にはB :: Deparseが通常行う逆変換をオフにします。一方、 &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; は &lt;code&gt;$x = $y&lt;/code&gt; と同じではないことに注意してください。前者は割り当てを行う前に$ yの値を文字列にします。</target>
        </trans-unit>
        <trans-unit id="7363f38426987fddbd769148d6ed0f8d3381792d" translate="yes" xml:space="preserve">
          <source>Note that the expanded form represents the way perl handles such constructions internally -- this option actually turns off the reverse translation that B::Deparse usually does. On the other hand, note that &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; is not the same as &lt;code&gt;$x = $y&lt;/code&gt;: the former makes the value of $y into a string before doing the assignment.</source>
          <target state="translated">展開された形式は、perlがそのような構造を内部的に処理する方法を表すことに注意してください。このオプションは、B :: Deparseが通常行う逆変換を実際にオフにします。一方、 &lt;code&gt;$x = &quot;$y&quot;&lt;/code&gt; は &lt;code&gt;$x = $y&lt;/code&gt; と同じではないことに注意してください。前者は割り当てを行う前に$ yの値を文字列にします。</target>
        </trans-unit>
        <trans-unit id="ce6c91a770707b555d66e4a287e39136a3141726" translate="yes" xml:space="preserve">
          <source>Note that the extraction with the stored paths is still necessary (default with unzip, specify &lt;code&gt;-d&lt;/code&gt; to pkunzip). However, you need to know where to extract the files. You need also to manually change entries in</source>
          <target state="translated">保存されたパスを使用した抽出が依然として必要であることに注意してください（unzipではデフォルト、 &lt;code&gt;-d&lt;/code&gt; をpkunzip に指定）。ただし、ファイルを抽出する場所を知っている必要があります。また、手動でエントリを変更する必要があります</target>
        </trans-unit>
        <trans-unit id="fd97b7e25cb09157d47ba2c7b978a7930b9606b8" translate="yes" xml:space="preserve">
          <source>Note that the fcntl(2) emulation of flock(3) requires that FILEHANDLE be open with read intent to use LOCK_SH and requires that it be open with write intent to use LOCK_EX.</source>
          <target state="translated">flock(3)の fcntl(2)エミュレーションでは、FILEHANDLE は LOCK_SH を使用するために読み込みインテントでオープンされている必要があり、LOCK_EX を使用するために書き込みインテントでオープンされている必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="85ef7ad11abd8bc54af52a716405bd9eb2cc5233" translate="yes" xml:space="preserve">
          <source>Note that the file path is relative to &lt;code&gt;$dir&lt;/code&gt; if that is specified. This &lt;b&gt;must not&lt;/b&gt; be used directly for CPAN META &lt;code&gt;provides&lt;/code&gt;. See the &lt;code&gt;provides&lt;/code&gt; method instead.</source>
          <target state="translated">指定されている場合、ファイルパスは &lt;code&gt;$dir&lt;/code&gt; 基準にしていることに注意してください。これ&lt;b&gt;は&lt;/b&gt;、CPANMETAが &lt;code&gt;provides&lt;/code&gt; 直接使用して&lt;b&gt;は&lt;/b&gt;なり&lt;b&gt;ません&lt;/b&gt;。代わりに &lt;code&gt;provides&lt;/code&gt; メソッドを参照してください。</target>
        </trans-unit>
        <trans-unit id="fe144eb2f290a0a193386ccafda07da2ebb33808" translate="yes" xml:space="preserve">
          <source>Note that the file will not be included twice under the same specified name.</source>
          <target state="translated">同一の指定名で二重に含まれることはありませんのでご注意ください。</target>
        </trans-unit>
        <trans-unit id="7a13c6488a9b380a268109737c1af44124fc53ff" translate="yes" xml:space="preserve">
          <source>Note that the final string may be up to 7 chars longer than pvlim.</source>
          <target state="translated">最終的な文字列はpvlimより7文字まで長くなる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="cd6cdc78eed59a6e15c0c2c30dcc231f761afe79" translate="yes" xml:space="preserve">
          <source>Note that the first argument is required. The section number will be parsed from it, and if it's missing will default to 1. The second argument is currently ignored, as &lt;a href=&quot;http://man.he.net&quot;&gt;man.he.net&lt;/a&gt; does not currently include linkable IDs or anchor names in its pages. Subclass to link to a different man page HTTP server.</source>
          <target state="translated">最初の引数が必須であることに注意してください。セクション番号はそこから解析され、欠落している場合はデフォルトで1になります&lt;a href=&quot;http://man.he.net&quot;&gt;。man.he.netのページに&lt;/a&gt;は現在リンク可能なIDまたはアンカー名が含まれていないため、2番目の引数は現在無視されます。別のマニュアルページHTTPサーバーにリンクするサブクラス。</target>
        </trans-unit>
        <trans-unit id="772ece35cdf290101677cb798018640a9adccf19" translate="yes" xml:space="preserve">
          <source>Note that the first argument is required. The section number will be parsed from it, and if it's missing will default to 1. The second argument is currently ignored, as &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net&quot;&gt;man.he.net&lt;/a&gt; does not currently include linkable IDs or anchor names in its pages. Subclass to link to a different man page HTTP server.</source>
          <target state="translated">最初の引数は必須です。セクション番号はそこから解析され、欠落している場合はデフォルトで1になります&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fman.he.net&quot;&gt;。man.he.net&lt;/a&gt;は現在、リンク可能なIDやアンカー名をページに含めていないため、2番目の引数は現在無視されます。別のmanページのHTTPサーバーにリンクするサブクラス。</target>
        </trans-unit>
        <trans-unit id="0926e8149e0f9908feb624f3205e6ac6e35159d1" translate="yes" xml:space="preserve">
          <source>Note that the first of the above returns a Time::Seconds object, so while examining the object will print the number of seconds (because of the overloading), you can also get the number of minutes, hours, days, weeks and years in that delta, using the Time::Seconds API.</source>
          <target state="translated">上記の最初のものは Time::Seconds オブジェクトを返すので、オブジェクトを調べると秒数が表示されますが (オーバーロードのため)、Time::Seconds API を使用して、そのデルタ内の分、時間、日、週、年の数を取得することもできます。</target>
        </trans-unit>
        <trans-unit id="533bf74078da55d39eeb6299ea8805b9073e8050" translate="yes" xml:space="preserve">
          <source>Note that the general pattern here is that the accessor-methods read the attribute's value with &lt;code&gt;$value = $parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;&lt;/code&gt; and set the attribute's value with &lt;code&gt;$parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;(&lt;i&gt;newvalue&lt;/i&gt;)&lt;/code&gt;. For each accessor, I typically only mention one syntax or another, based on which I think you are actually most likely to use.</source>
          <target state="translated">ここでの一般的なパターンは、accessor-methodsが &lt;code&gt;$value = $parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;&lt;/code&gt; を使用して属性の値を読み取り、 &lt;code&gt;$parser-&amp;gt;&lt;i&gt;attribute&lt;/i&gt;(&lt;i&gt;newvalue&lt;/i&gt;)&lt;/code&gt; して属性の値を設定することに注意してください。各アクセサーについて、通常は1つだけ構文に言及します。これに基づいて、実際に使用する可能性が最も高いと思います。</target>
        </trans-unit>
        <trans-unit id="9c62e8291c3969aab5799ff59674523f531fd071" translate="yes" xml:space="preserve">
          <source>Note that the global variable &lt;code&gt;$B::OP::does_parent&lt;/code&gt; is undefined on older perls that don't support the &lt;code&gt;parent&lt;/code&gt; method, is defined but false on perls that support the method but were built without &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; , and is true otherwise.</source>
          <target state="translated">グローバル変数 &lt;code&gt;$B::OP::does_parent&lt;/code&gt; は、 &lt;code&gt;parent&lt;/code&gt; メソッドをサポートしない古いperlでは未定義であり、定義されていますが、メソッドをサポートするが &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; なしでビルドされたperlではfalseであり、それ以外の場合はtrueであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="33122f52d4f72485938536bba048d13bb9c994d8" translate="yes" xml:space="preserve">
          <source>Note that the global variable &lt;code&gt;$B::OP::does_parent&lt;/code&gt; is undefined on older perls that don't support the &lt;code&gt;parent&lt;/code&gt; method, is defined but false on perls that support the method but were built without &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt;, and is true otherwise.</source>
          <target state="translated">グローバル変数 &lt;code&gt;$B::OP::does_parent&lt;/code&gt; は、 &lt;code&gt;parent&lt;/code&gt; メソッドをサポートしない古いperlでは定義されていませんが、メソッドをサポートしているが &lt;code&gt;-DPERL_OP_PARENT&lt;/code&gt; なしでビルドされたperlではfalseであり、それ以外の場合はtrueであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="255f1a96146684091b1e9cb0690908a053fe1866" translate="yes" xml:space="preserve">
          <source>Note that the implementation of &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; in this module does not provide true random access to a compressed file/buffer. It works by uncompressing data from the current offset in the file/buffer until it reaches the uncompressed offset specified in the parameters to &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;. For very small files this may be acceptable behaviour. For large files it may cause an unacceptable delay.</source>
          <target state="translated">このモジュールでの &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; の実装は、圧縮ファイル/バッファーへの真のランダムアクセスを提供しないことに注意してください。 &lt;code&gt;&lt;a href=&quot;../../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; するパラメーターで指定された非圧縮オフセットに達するまで、ファイル/バッファー内の現在のオフセットからデータを解凍することにより機能します。非常に小さなファイルの場合、これは許容できる動作です。大きなファイルの場合、許容できない遅延が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="c2278932c41e8894955fd432303661d611324abc" translate="yes" xml:space="preserve">
          <source>Note that the implementation of &lt;code&gt;seek&lt;/code&gt; in this module does not provide true random access to a compressed file/buffer. It works by uncompressing data from the current offset in the file/buffer until it reaches the uncompressed offset specified in the parameters to &lt;code&gt;seek&lt;/code&gt;. For very small files this may be acceptable behaviour. For large files it may cause an unacceptable delay.</source>
          <target state="translated">このモジュールでの &lt;code&gt;seek&lt;/code&gt; の実装は、圧縮ファイル/バッファへの真のランダムアクセスを提供しないことに注意してください。これは、ファイル/バッファー内の現在のオフセットから、 &lt;code&gt;seek&lt;/code&gt; するパラメーターで指定された非圧縮オフセットに達するまでデータを解凍することによって機能します。非常に小さいファイルの場合、これは許容できる動作である可能性があります。大きなファイルの場合、許容できない遅延が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="f257e1d0eedfe176e0664704a0289bfea4406fc3" translate="yes" xml:space="preserve">
          <source>Note that the initializer for a nested class may be specified as an object of that class, or as a reference to a hash of initializers that are passed on to the nested struct's constructor.</source>
          <target state="translated">ネストされたクラスのイニシャライザは、そのクラスのオブジェクトとして、またはネストされた構造体のコンストラクタに渡されるイニシャライザのハッシュへの参照として指定することができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="80804b39a5da75cc855890b4a2fe869234b33d17" translate="yes" xml:space="preserve">
          <source>Note that the interaction between alarms and sleeps is unspecified.</source>
          <target state="translated">アラームとスリープの相互作用は不特定であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e8783b348067a3189a0f06125d399031ed3fee39" translate="yes" xml:space="preserve">
          <source>Note that the inversion lists returned by this function can possibly include non-Unicode code points, that is anything above 0x10FFFF. Unicode properties are not defined on such code points. You might wish to change the output to not include these. Simply add 0x110000 at the end of the non-empty returned list if it isn't already that value; and pop that value if it is; like:</source>
          <target state="translated">こ の関数が返す反転リストは、Unicode 以外の コ ー ド 点、 すなわち 0x10FFFF より上の コ ー ド 点を含む可能性があ る こ と に注意 し て く だ さ い。そのようなコードポイントには Unicode プロパティは定義されていません。こ れ ら を含まない よ う に出力を変更 し たい場合があ り ます。返されたリストの最後に 0x110000 を追加してください。</target>
        </trans-unit>
        <trans-unit id="b0e71b8ea159a9c2edf24faa2295a4b51fa39394" translate="yes" xml:space="preserve">
          <source>Note that the inversion maps returned for the &lt;code&gt;Case_Folding&lt;/code&gt; and &lt;code&gt;Simple_Case_Folding&lt;/code&gt; properties do not include the Turkic-locale mappings. Use &lt;a href=&quot;#casefold%28%29&quot;&gt;&quot;casefold()&quot;&lt;/a&gt; for these.</source>
          <target state="translated">&lt;code&gt;Case_Folding&lt;/code&gt; プロパティと &lt;code&gt;Simple_Case_Folding&lt;/code&gt; プロパティに対して返される反転マップには、Turkic-localeマッピングが含まれていないことに注意してください。これらには&lt;a href=&quot;#casefold%28%29&quot;&gt;「casefold（）」&lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="634311f4edf03951c04e577294ff3bbf805ec5ba" translate="yes" xml:space="preserve">
          <source>Note that the inversion maps returned for the &lt;code&gt;Case_Folding&lt;/code&gt; and &lt;code&gt;Simple_Case_Folding&lt;/code&gt; properties do not include the Turkic-locale mappings. Use &lt;a href=&quot;#casefold()&quot;&gt;casefold()&lt;/a&gt; for these.</source>
          <target state="translated">&lt;code&gt;Case_Folding&lt;/code&gt; および &lt;code&gt;Simple_Case_Folding&lt;/code&gt; プロパティに対して返される反転マップには、Turkicロケールのマッピングが含まれていないことに注意してください。これらには、&lt;a href=&quot;#casefold()&quot;&gt;casefold（）&lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="31c86684655a1972f5965e0709faf4f9dbe8bb6a" translate="yes" xml:space="preserve">
          <source>Note that the largest code point in Unicode is U+10FFFF.</source>
          <target state="translated">Unicode の最大コードポイントは U+10FFFF であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="19d81e07df642a7406f056019f52ad26601c1b9e" translate="yes" xml:space="preserve">
          <source>Note that the last two of these are actually competing projects both delivering complete gcc toolchain for MS Windows:</source>
          <target state="translated">このうち最後の 2 つは、実際には MS Windows 用の完全な gcc ツールチェーンを提供している競合プロジェクトであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b9b9a1c26be88f08471aaa216414e6d8395e1d57" translate="yes" xml:space="preserve">
          <source>Note that the leading &quot;:&quot; is removed from the filename, so that</source>
          <target state="translated">先頭の &quot;:&quot; はファイル名から削除されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="df9faf2f3be99fd79d6a15587ce23e5766dfe648" translate="yes" xml:space="preserve">
          <source>Note that the like ordinary associative arrays, the order of the keys retrieved is in an apparently random order.</source>
          <target state="translated">通常の連想配列と同様に、取得されるキーの順序は一見ランダムであることに注意しましょう。</target>
        </trans-unit>
        <trans-unit id="f7e4be377938ec5b2bd579fa7c5058874b5e3a40" translate="yes" xml:space="preserve">
          <source>Note that the line number of the error/warning may refer to the line number of the start of the paragraph in which the error/warning exists, not the line number that the error/warning is on. This bug is present in errors/warnings related to formatting codes.</source>
          <target state="translated">エラー/警告の行番号は、エラー/警告のある行番号ではなく、エラー/警告のある段落の先頭の行番号を参照している場合があることに注意してください。このバグは、書式設定コードに関連するエラー/警告に存在します。</target>
        </trans-unit>
        <trans-unit id="f7eb999d3e69609ef8f64d4732450cbda274eea8" translate="yes" xml:space="preserve">
          <source>Note that the lines are not printed by default. See &lt;a href=&quot;#-p&quot;&gt;&quot;-p&quot;&lt;/a&gt; to have lines printed. If a file named by an argument cannot be opened for some reason, Perl warns you about it and moves on to the next file.</source>
          <target state="translated">デフォルトでは、行は印刷されないことに注意してください。行を印刷するには、&lt;a href=&quot;#-p&quot;&gt;「&lt;/a&gt; - p」を参照してください。引数で指定されたファイルを何らかの理由で開くことができない場合、Perlはそれについて警告し、次のファイルに移動します。</target>
        </trans-unit>
        <trans-unit id="b92b7a5bb51e663f2e21cacb04a99284891d33e2" translate="yes" xml:space="preserve">
          <source>Note that the lines are not printed by default. See &lt;a href=&quot;#-p&quot;&gt;-p&lt;/a&gt; to have lines printed. If a file named by an argument cannot be opened for some reason, Perl warns you about it and moves on to the next file.</source>
          <target state="translated">行はデフォルトでは印刷されないことに注意してください。行を印刷するには、&lt;a href=&quot;#-p&quot;&gt;-p&lt;/a&gt;を参照してください。何らかの理由で引数で指定されたファイルを開くことができない場合、Perlは警告を表示して次のファイルに進みます。</target>
        </trans-unit>
        <trans-unit id="b32153557293284be92deec6168f3ee23705dad2" translate="yes" xml:space="preserve">
          <source>Note that the list form of exec() is emulated since the Win32 API CreateProcess() accepts a simple string rather than an array of command-line arguments. This may have security implications for your code.</source>
          <target state="translated">Win32 API CreateProcess()はコマンドライン引数の配列ではなく単純な文字列を受け入れるので、 exec()のリスト形式がエミュレートされていることに注意してください。これは、あなたのコードにセキュリティ上の意味があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="3f1ea4347f8d164bb526f1210c5912fa3af79feb" translate="yes" xml:space="preserve">
          <source>Note that the list form of system() is emulated since the Win32 API CreateProcess() accepts a simple string rather than an array of command-line arguments. This may have security implications for your code.</source>
          <target state="translated">なぜなら、Win32 API CreateProcess()はコマンドライン引数の配列ではなく単純な文字列を受け入れるからです。これは、あなたのコードにセキュリティ上の意味があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="04e826f7fe166da89c0048f458c19e7bf2982a08" translate="yes" xml:space="preserve">
          <source>Note that the list is not sorted.</source>
          <target state="translated">リストはソートされていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="3e41c72d7fee1ff8c764beabf8a96c567a3b6233" translate="yes" xml:space="preserve">
          <source>Note that the lvalue returned by the three-argument version of &lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt;&lt;code&gt;substr&lt;/code&gt;&lt;/a&gt; acts as a 'magic bullet'; each time it is assigned to, it remembers which part of the original string is being modified; for example:</source>
          <target state="translated">&lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt; &lt;code&gt;substr&lt;/code&gt; の&lt;/a&gt;3つの引数バージョンによって返される左辺値は、「魔法の弾丸」として機能することに注意してください。割り当てられるたびに、元の文字列のどの部分が変更されているかが記憶されます。例えば：</target>
        </trans-unit>
        <trans-unit id="5f163f86087018a673bf93b42c4a0a6c49b0abc8" translate="yes" xml:space="preserve">
          <source>Note that the lvalue returned by the three-argument version of substr() acts as a 'magic bullet'; each time it is assigned to, it remembers which part of the original string is being modified; for example:</source>
          <target state="translated">三引数バージョンの substr()で返される lvalue は「魔法の弾丸」のようなものであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="30652accd17648a773c7cfc6b99b87e2f00a6b4d" translate="yes" xml:space="preserve">
          <source>Note that the mapping is the one that is specified in the Unicode data files, and to get the final decomposition, it may need to be applied recursively.</source>
          <target state="translated">なお、マッピングはUnicodeデータファイルで指定されているものであり、最終的な分解を得るためには再帰的に適用する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="41e59b746c6a84ae0b237b2221463c64daa4df44" translate="yes" xml:space="preserve">
          <source>Note that the mapping is the one that is specified in the Unicode data files, and to get the final decomposition, it may need to be applied recursively. Unicode in fact discourages use of this property except internally in implementations of the Unicode Normalization Algorithm.</source>
          <target state="translated">マッピングは Unicode デー タ フ ァ イ ル内で指定 さ れてい る も のであ り 、 最終的な分解を得るためには再帰的に適用す る 必要があ る こ と に注意 し て く だ さ い。実際、Unicodeでは、内部的にUnicode正規化アルゴリズムを実装している場合を除き、このプロパティの使用を推奨していません。</target>
        </trans-unit>
        <trans-unit id="a840d21a1adb331df5f502ec5cce875d624189ca" translate="yes" xml:space="preserve">
          <source>Note that the minimal matching quantifiers, &lt;code&gt;*?&lt;/code&gt; , &lt;code&gt;+?&lt;/code&gt;, and &lt;code&gt;??&lt;/code&gt; appear to be nested quantifiers, but aren't. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">最小一致量指定子 &lt;code&gt;*?&lt;/code&gt; 、 &lt;code&gt;+?&lt;/code&gt; 、そして &lt;code&gt;??&lt;/code&gt; ネストされた数量詞のように見えますが、そうではありません。&lt;a href=&quot;perlre&quot;&gt;perlreを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9b41b3d83f67f68a69236e54f8aeb3e828ab48b2" translate="yes" xml:space="preserve">
          <source>Note that the minimal matching quantifiers, &lt;code&gt;*?&lt;/code&gt;, &lt;code&gt;+?&lt;/code&gt;, and &lt;code&gt;??&lt;/code&gt; appear to be nested quantifiers, but aren't. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">最小一致数量詞 &lt;code&gt;*?&lt;/code&gt; 、 &lt;code&gt;+?&lt;/code&gt; 、および &lt;code&gt;??&lt;/code&gt; ネストされた数量詞のように見えますが、そうではありません。&lt;a href=&quot;perlre&quot;&gt;perlreを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4c2a0ab30039f9b1189b998b4a9e776dc39a1982" translate="yes" xml:space="preserve">
          <source>Note that the number of exponent digits in the scientific notation produced by &lt;code&gt;%e&lt;/code&gt; , &lt;code&gt;%E&lt;/code&gt; , &lt;code&gt;%g&lt;/code&gt; and &lt;code&gt;%G&lt;/code&gt; for numbers with the modulus of the exponent less than 100 is system-dependent: it may be three or less (zero-padded as necessary). In other words, 1.23 times ten to the 99th may be either &quot;1.23e99&quot; or &quot;1.23e099&quot;. Similarly for &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%A&lt;/code&gt; : the exponent or the hexadecimal digits may float: especially the &quot;long doubles&quot; Perl configuration option may cause surprises.</source>
          <target state="translated">指数の係数が100未満の数値に対して &lt;code&gt;%e&lt;/code&gt; 、 &lt;code&gt;%E&lt;/code&gt; 、 &lt;code&gt;%g&lt;/code&gt; 、および &lt;code&gt;%G&lt;/code&gt; によって生成される科学表記法の指数桁数はシステムに依存することに注意してください。必要に応じて）。つまり、10から99の1.23倍は、「1.23e99」または「1.23e099」のいずれかになります。同様に &lt;code&gt;%a&lt;/code&gt; と &lt;code&gt;%A&lt;/code&gt; の場合：指数または16進数字が浮動する場合があります。特に、「long doubles」のPerl構成オプションは、予期しない結果を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="31bcb562562261f56086728520662f93907434b0" translate="yes" xml:space="preserve">
          <source>Note that the number of exponent digits in the scientific notation produced by &lt;code&gt;%e&lt;/code&gt;, &lt;code&gt;%E&lt;/code&gt;, &lt;code&gt;%g&lt;/code&gt; and &lt;code&gt;%G&lt;/code&gt; for numbers with the modulus of the exponent less than 100 is system-dependent: it may be three or less (zero-padded as necessary). In other words, 1.23 times ten to the 99th may be either &quot;1.23e99&quot; or &quot;1.23e099&quot;. Similarly for &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%A&lt;/code&gt;: the exponent or the hexadecimal digits may float: especially the &quot;long doubles&quot; Perl configuration option may cause surprises.</source>
          <target state="translated">指数のモジュラスが100未満の数値の &lt;code&gt;%e&lt;/code&gt; 、 &lt;code&gt;%E&lt;/code&gt; 、 &lt;code&gt;%g&lt;/code&gt; 、および &lt;code&gt;%G&lt;/code&gt; によって生成される科学的記数法の指数桁数は、システムに依存することに注意してください。3以下（ゼロが埋め込まれる場合があります）必要に応じて）。つまり、10から99までの1.23 xは、「1.23e99」または「1.23e099」のいずれかになります。同様に、 &lt;code&gt;%a&lt;/code&gt; および &lt;code&gt;%A&lt;/code&gt; の場合：指数または16進数が浮動する可能性があります。特に、「longdoubles」Perl構成オプションは予期しない原因となる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a7eeec0bff7c89a12579e992fcf86b0716b7245b" translate="yes" xml:space="preserve">
          <source>Note that the only two changes from the normal way of writing an extension is the addition of a &lt;code&gt;#define PERL_NO_GET_CONTEXT&lt;/code&gt; before including the Perl headers, followed by a &lt;code&gt;dTHX;&lt;/code&gt; declaration at the start of every function that will call the Perl API. (You'll know which functions need this, because the C compiler will complain that there's an undeclared identifier in those functions.) No changes are needed for the XSUBs themselves, because the XS() macro is correctly defined to pass in the implicit context if needed.</source>
          <target state="translated">拡張機能を作成する通常の方法からの2つの変更は、Perlヘッダーを &lt;code&gt;#define PERL_NO_GET_CONTEXT&lt;/code&gt; する前に#define PERL_NO_GET_CONTEXTを追加し、その後にdTHXを追加するだけであることに注意してください &lt;code&gt;dTHX;&lt;/code&gt; Perl APIを呼び出すすべての関数の開始時の宣言。（Cコンパイラはこれらの関数に宣言されていない識別子があると不平を言うので、どの関数がこれを必要とするかがわかります。）XS（）マクロは暗黙的なコンテキストで渡すように正しく定義されているため、XSUB自体を変更する必要はありません。必要に応じて。</target>
        </trans-unit>
        <trans-unit id="81cafeed743ff4607118970eeb67b7b39cfee366" translate="yes" xml:space="preserve">
          <source>Note that the opmask doesn't affect the already compiled code, it only affects any</source>
          <target state="translated">opmask はコンパイル済みのコードには影響しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="50380a5708cf00fd178289610d3bed5ed2c8b5b4" translate="yes" xml:space="preserve">
          <source>Note that the options terminator (default &lt;code&gt;--&lt;/code&gt; ), if present, will also be passed through in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">オプションのターミネーター（デフォルト &lt;code&gt;--&lt;/code&gt; ）が存在する場合は、 &lt;code&gt;@ARGV&lt;/code&gt; でも渡されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9d140eced205e7240d0cac12aab6ec294f45d708" translate="yes" xml:space="preserve">
          <source>Note that the options terminator (default &lt;code&gt;--&lt;/code&gt;), if present, will also be passed through in &lt;code&gt;@ARGV&lt;/code&gt;.</source>
          <target state="translated">オプションターミネータ（デフォルト &lt;code&gt;--&lt;/code&gt; ）が存在する場合は、 &lt;code&gt;@ARGV&lt;/code&gt; でも渡されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="2b99871b0f7ac49ac26656a96e644a594657e984" translate="yes" xml:space="preserve">
          <source>Note that the outer &lt;code&gt;=over&lt;/code&gt; is a block because it has no &lt;code&gt;=item&lt;/code&gt;s but still has content: the inner &lt;code&gt;=over&lt;/code&gt;. The inner &lt;code&gt;=over&lt;/code&gt;, in turn, is completely empty, and is treated as such.</source>
          <target state="translated">外側の &lt;code&gt;=over&lt;/code&gt; は、 &lt;code&gt;=item&lt;/code&gt; がないが、コンテンツが残っているため、ブロックであることに注意してください：内側の &lt;code&gt;=over&lt;/code&gt; 。次に、内側の &lt;code&gt;=over&lt;/code&gt; は完全に空であり、そのように扱われます。</target>
        </trans-unit>
        <trans-unit id="34344d5bf3d39aec43cee250c8b0f5cab594ad8e" translate="yes" xml:space="preserve">
          <source>Note that the parentheses in &lt;code&gt;(?=regexp)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;=regexp)&lt;/code&gt; are non-capturing, since these are zero-width assertions. Thus in the second regexp, the substrings captured are those of the whole regexp itself. Lookahead &lt;code&gt;(?=regexp)&lt;/code&gt; can match arbitrary regexps, but lookbehind &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; only works for regexps of fixed width, i.e., a fixed number of characters long. Thus &lt;code&gt;(?&amp;lt;=(ab|bc))&lt;/code&gt; is fine, but &lt;code&gt;(?&amp;lt;=(ab)*)&lt;/code&gt; is not. The negated versions of the lookahead and lookbehind assertions are denoted by &lt;code&gt;(?!regexp)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;!fixed-regexp)&lt;/code&gt; respectively. They evaluate true if the regexps do</source>
          <target state="translated">&lt;code&gt;(?=regexp)&lt;/code&gt; および &lt;code&gt;(?&amp;lt;=regexp)&lt;/code&gt; の括弧は、ゼロ幅のアサーションであるため、キャプチャされないことに注意してください。したがって、2番目の正規表現では、キャプチャされる部分文字列は、正規表現全体のものです。先読み &lt;code&gt;(?=regexp)&lt;/code&gt; は任意の正規表現に一致でき &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; が、後読み（？&amp;lt;= fixed-regexp）は、固定幅、つまり固定長の文字数の正規表現に対してのみ機能します。したがって、 &lt;code&gt;(?&amp;lt;=(ab|bc))&lt;/code&gt; は問題ありませんが、 &lt;code&gt;(?&amp;lt;=(ab)*)&lt;/code&gt; は問題です。否定アサーションの否定バージョンは、それぞれ &lt;code&gt;(?!regexp)&lt;/code&gt; および &lt;code&gt;(?&amp;lt;!fixed-regexp)&lt;/code&gt; で示されます。正規表現がそうである場合、それらは真と評価されます</target>
        </trans-unit>
        <trans-unit id="b450a76f799fbd2000fb736a0e284dee87f232b7" translate="yes" xml:space="preserve">
          <source>Note that the parentheses in these are non-capturing, since these are zero-width assertions. Thus in the second regexp, the substrings captured are those of the whole regexp itself. Lookahead can match arbitrary regexps, but lookbehind prior to 5.30 &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; only works for regexps of fixed width,</source>
          <target state="translated">これらは幅がゼロのアサーションであるため、これらの括弧はキャプチャされていないことに注意してください。したがって、2番目の正規表現では、キャプチャされた部分文字列は正規表現全体の部分文字列です。先読みは任意の &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; 一致できますが、5.30より前の後読み（？&amp;lt;= fixed-regexp）は、固定幅の正規表現に対してのみ機能します。</target>
        </trans-unit>
        <trans-unit id="69b12314d048529314e48e1e307c0f68902915bd" translate="yes" xml:space="preserve">
          <source>Note that the perl-mode of emacs will have fits with &lt;code&gt;&quot;main'foo&quot;&lt;/code&gt; (single quote), and mess up the indentation and highlighting. You are probably using &lt;code&gt;&quot;main::foo&quot;&lt;/code&gt; in new Perl code anyway, so this shouldn't be an issue.</source>
          <target state="translated">emacsのperlモードは &lt;code&gt;&quot;main'foo&quot;&lt;/code&gt; （一重引用符）に適合し、インデントと強調表示を台無しにすることに注意してください。とにかく新しいPerlコードで &lt;code&gt;&quot;main::foo&quot;&lt;/code&gt; を使用しているので、これは問題になりません。</target>
        </trans-unit>
        <trans-unit id="f5ca7725b131e21f49d7345fcb2f0711a2a47f63" translate="yes" xml:space="preserve">
          <source>Note that the possessive quantifier modifier can not be be combined with the non-greedy modifier. This is because it would make no sense. Consider the follow equivalency table:</source>
          <target state="translated">所有的量詞修飾語は、非greedy修飾語と組み合わせることができないことに注意してください。これは、意味がないからです。次の同値表を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="05a31604712dc06b57292f7d6e6baf36004c8881" translate="yes" xml:space="preserve">
          <source>Note that the possessive quantifier modifier can not be combined with the non-greedy modifier. This is because it would make no sense. Consider the follow equivalency table:</source>
          <target state="translated">所有的量詞修飾語は、非greedy修飾語と組み合わせることができないことに注意してください。これは意味がないからです。次の同値表を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="2853371a63417bfadde728879823337ed5a4d700" translate="yes" xml:space="preserve">
          <source>Note that the process will continue to grow for each file that it uses. In addition, there might be &lt;code&gt;AUTOLOAD&lt;/code&gt; ed subroutines and other conditions that cause Perl's symbol table to grow. You might want to add some logic that keeps track of the process size, or restarts itself after a certain number of requests, to ensure that memory consumption is minimized. You'll also want to scope your variables with &lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; whenever possible.</source>
          <target state="translated">プロセスは、使用するファイルごとに拡大し続けることに注意してください。さらに、 &lt;code&gt;AUTOLOAD&lt;/code&gt; されたサブルーチンや、Perlのシンボルテーブルを拡張するその他の条件が存在する可能性があります。プロセスサイズを追跡するロジックを追加するか、特定の数の要求の後にそれ自体を再起動して、メモリの消費を最小限に抑えることができます。また&lt;a href=&quot;functions/my&quot;&gt;、&lt;/a&gt;可能な限り変数のスコープをmyに設定することもできます。</target>
        </trans-unit>
        <trans-unit id="19133e9511ee15654168135f8179ad57c8de3d7c" translate="yes" xml:space="preserve">
          <source>Note that the process will continue to grow for each file that it uses. In addition, there might be &lt;code&gt;AUTOLOAD&lt;/code&gt;ed subroutines and other conditions that cause Perl's symbol table to grow. You might want to add some logic that keeps track of the process size, or restarts itself after a certain number of requests, to ensure that memory consumption is minimized. You'll also want to scope your variables with &lt;a href=&quot;perlfunc#my&quot;&gt;&quot;my&quot; in perlfunc&lt;/a&gt; whenever possible.</source>
          <target state="translated">プロセスは、使用するファイルごとに拡大し続けることに注意してください。さらに、Perlのシンボルテーブルを大きくする原因となる &lt;code&gt;AUTOLOAD&lt;/code&gt; されたサブルーチンやその他の条件が存在する可能性があります。メモリ消費を最小限に抑えるために、プロセスサイズを追跡するロジックを追加したり、特定の数のリクエストの後に自動的に再起動したりすることができます。また&lt;a href=&quot;perlfunc#my&quot;&gt;、&lt;/a&gt;可能な限り、perlfuncの「my」を使用して変数のスコープを設定することもできます。</target>
        </trans-unit>
        <trans-unit id="1b2e6d6d10b83461736cd9723d9f047ffdd975d1" translate="yes" xml:space="preserve">
          <source>Note that the properties of the algorithms change over time, as the algorithms are analyzed and machines grow faster. If your application for instance depends on it being &quot;impossible&quot; to generate the same digest for a different message it is wise to make it easy to plug in stronger algorithms as the one used grow weaker. Using the interface documented here should make it easy to change algorithms later.</source>
          <target state="translated">アルゴリズムの特性は、アルゴリズムが分析されたり、マシンが高速化したりすると、時間の経過とともに変化することに注意してください。例えば、アプリケーションが異なるメッセージに対して同じダイジェストを生成することが「不可能」であることに依存している場合、使用されるアルゴリズムが弱くなるにつれて、より強力なアルゴリズムを簡単にプラグインできるようにするのが賢明です。ここで説明されているインターフェイスを使えば、後からアルゴリズムを変更するのが簡単になるはずです。</target>
        </trans-unit>
        <trans-unit id="94680bef919b3e58595e50dc2cef254eecd344d5" translate="yes" xml:space="preserve">
          <source>Note that the reason that keys that start with &quot;_&quot; are immune to _AUTO isn't anything generally magical about the underscore character -- I just wanted a way to have most lexicon keys be autoable, except for possibly a few, and I arbitrarily decided to use a leading underscore as a signal to distinguish those few.</source>
          <target state="translated">で始まるキーが _AUTO の影響を受けない理由は、アンダースコア文字が一般的に魔法のようなものではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="c52f10e051f2461220787b7a728deb5d7e62b4bd" translate="yes" xml:space="preserve">
          <source>Note that the said &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; is bound by an implicit scope. As a result any newly introduced lexical variable or any modified capture buffer content is lost after the eval. The debugger is a nice environment to learn Perl, but if you interactively experiment using material which should be in the same scope, stuff it in one line.</source>
          <target state="translated">上記の &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; は暗黙のスコープによってバインドされることに注意してください。その結果、新しく導入された語彙変数または変更されたキャプチャバッファの内容は、評価後に失われます。デバッガーはPerlを学ぶのに最適な環境ですが、同じスコープ内にあるはずのマテリアルを使用してインタラクティブに実験する場合は、1行に詰め込みます。</target>
        </trans-unit>
        <trans-unit id="471933a1768d0ec6bc98ec34dbc5facf0b071a6f" translate="yes" xml:space="preserve">
          <source>Note that the said &lt;code&gt;eval&lt;/code&gt; is bound by an implicit scope. As a result any newly introduced lexical variable or any modified capture buffer content is lost after the eval. The debugger is a nice environment to learn Perl, but if you interactively experiment using material which should be in the same scope, stuff it in one line.</source>
          <target state="translated">上記の &lt;code&gt;eval&lt;/code&gt; は暗黙のスコープによってバインドされていることに注意してください。その結果、新しく導入された字句変数または変更されたキャプチャバッファの内容は、評価後に失われます。デバッガーはPerlを学ぶのに最適な環境ですが、同じスコープ内にあるはずの資料を使用してインタラクティブに実験する場合は、1行に詰め込んでください。</target>
        </trans-unit>
        <trans-unit id="55c5f596ab4d97752de506fd4873b64dd76c61e3" translate="yes" xml:space="preserve">
          <source>Note that the single parameter passed to the</source>
          <target state="translated">に渡されるパラメータが単一であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a34d0fde03ac911613a011adde756943693a9a07" translate="yes" xml:space="preserve">
          <source>Note that the source code is passed as a single string, so any regex that uses &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; to detect line boundaries will need the &lt;code&gt;/m&lt;/code&gt; flag.</source>
          <target state="translated">ソースコードは単一の文字列として渡されるため、行の境界を検出するために &lt;code&gt;^&lt;/code&gt; または &lt;code&gt;$&lt;/code&gt; を使用するすべての正規表現には &lt;code&gt;/m&lt;/code&gt; フラグが必要です。</target>
        </trans-unit>
        <trans-unit id="262f4baab34cdad3f12b64cb0a920818da7a10be" translate="yes" xml:space="preserve">
          <source>Note that the spaces are required around the &lt;code&gt;SVf&lt;/code&gt; in case the code is compiled with C++, to maintain compliance with its standard.</source>
          <target state="translated">コードがC ++でコンパイルされる場合、標準への準拠を維持するために、 &lt;code&gt;SVf&lt;/code&gt; の周囲にスペースが必要であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="edfabff4ba4038a16af2c755df720dc69793c8b2" translate="yes" xml:space="preserve">
          <source>Note that the special variable &lt;code&gt;$^N&lt;/code&gt; is particularly useful with code blocks to capture the results of submatches in variables without having to keep track of the number of nested parentheses. For example:</source>
          <target state="translated">特別な変数 &lt;code&gt;$^N&lt;/code&gt; は、ネストされた括弧の数を追跡する必要なく、変数のサブマッチの結果をキャプチャするコードブロックで特に役立ちます。例えば：</target>
        </trans-unit>
        <trans-unit id="320c096bf4918e52d7bd0e618c2e6a5bc9e4bbc3" translate="yes" xml:space="preserve">
          <source>Note that the specified &lt;code&gt;fail&lt;/code&gt; behaviour applies to nested tags as well.</source>
          <target state="translated">指定された &lt;code&gt;fail&lt;/code&gt; 動作は、ネストされたタグにも適用されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="580a625682b8e1814baa151c5f0f7dc24aff6bf1" translate="yes" xml:space="preserve">
          <source>Note that the specified delimiters are automatically quotemeta'd.</source>
          <target state="translated">指定された区切り文字は自動的にクォーテメタされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1f961077ad91e1f5e608c0720760840050533641" translate="yes" xml:space="preserve">
          <source>Note that the stack is popped using &lt;code&gt;POPs&lt;/code&gt; in the block where &lt;code&gt;SvTRUE(ERRSV)&lt;/code&gt; is true. This is necessary because whenever a</source>
          <target state="translated">スタックは、 &lt;code&gt;SvTRUE(ERRSV)&lt;/code&gt; がtrue であるブロックの &lt;code&gt;POPs&lt;/code&gt; を使用してポップされることに注意してください。これは、</target>
        </trans-unit>
        <trans-unit id="710a5c79e66bbfbe96fbdcb6dc7413e03b66071c" translate="yes" xml:space="preserve">
          <source>Note that the stack is popped using &lt;code&gt;POPs&lt;/code&gt; in the block where &lt;code&gt;SvTRUE(err_tmp)&lt;/code&gt; is true. This is necessary because whenever a</source>
          <target state="translated">スタックは、 &lt;code&gt;SvTRUE(err_tmp)&lt;/code&gt; がtrueであるブロックで &lt;code&gt;POPs&lt;/code&gt; を使用してポップされることに注意してください。これが必要なのは、</target>
        </trans-unit>
        <trans-unit id="6462eb454e096d8a1746fdc113a16165357f8c5b" translate="yes" xml:space="preserve">
          <source>Note that the stringified form of infinity varies between platforms: it can be for example any of</source>
          <target state="translated">無限大の文字列化された形はプラットフォームによって異なることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e2587b73a26222076539535f74b276c7c807272c" translate="yes" xml:space="preserve">
          <source>Note that the syntax here is &lt;code&gt;(?(?{...})&lt;i&gt;yes-regexp&lt;/i&gt;|&lt;i&gt;no-regexp&lt;/i&gt;)&lt;/code&gt;, not &lt;code&gt;(?((?{...}))&lt;i&gt;yes-regexp&lt;/i&gt;|&lt;i&gt;no-regexp&lt;/i&gt;)&lt;/code&gt;. In other words, in the case of a code expression, we don't need the extra parentheses around the conditional.</source>
          <target state="translated">ここでの構文は &lt;code&gt;(?(?{...})&lt;i&gt;yes-regexp&lt;/i&gt;|&lt;i&gt;no-regexp&lt;/i&gt;)&lt;/code&gt; であり、 &lt;code&gt;(?((?{...}))&lt;i&gt;yes-regexp&lt;/i&gt;|&lt;i&gt;no-regexp&lt;/i&gt;)&lt;/code&gt; ことに注意してください。つまり、コード式の場合、条件の前後に余分な括弧は必要ありません。</target>
        </trans-unit>
        <trans-unit id="3205ecbbb1a9fb55e62eda6514162f94f7163bfc" translate="yes" xml:space="preserve">
          <source>Note that the syntax here is &lt;code&gt;(?(?{...})yes-regexp|no-regexp)&lt;/code&gt;, not &lt;code&gt;(?((?{...}))yes-regexp|no-regexp)&lt;/code&gt;. In other words, in the case of a code expression, we don't need the extra parentheses around the conditional.</source>
          <target state="translated">ここでの構文は、 &lt;code&gt;(?(?{...})yes-regexp|no-regexp)&lt;/code&gt; であり、 &lt;code&gt;(?((?{...}))yes-regexp|no-regexp)&lt;/code&gt; ことに注意してください。つまり、コード式の場合、条件を囲む余分な括弧は必要ありません。</target>
        </trans-unit>
        <trans-unit id="56d5a14355f9ba6fa06dc53e561fc21f5fed300e" translate="yes" xml:space="preserve">
          <source>Note that the tag names in &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; don't have the leading ':'.</source>
          <target state="translated">&lt;code&gt;%EXPORT_TAGS&lt;/code&gt; のタグ名には、先頭に「：」がないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="6d0f8cfa5599a4759e632a786adcd5ca20b3cfca" translate="yes" xml:space="preserve">
          <source>Note that the third argument to &lt;code&gt;open&lt;/code&gt; is a string containing the program name (&lt;code&gt;sort&lt;/code&gt;) plus all its arguments: in this case, &lt;code&gt;-u&lt;/code&gt; to specify unqiue sort, and then a fileglob specifying the files to sort. The resulting filehandle &lt;code&gt;$sort_fh&lt;/code&gt; works just like a read-only (&lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt;) filehandle, and your program can subsequently read data from it as if it were opened onto an ordinary, single file.</source>
          <target state="translated">&lt;code&gt;open&lt;/code&gt; 3番目の引数は、プログラム名（ &lt;code&gt;sort&lt;/code&gt; ）とそのすべての引数を含む文字列であることに注意してください。この場合、 &lt;code&gt;-u&lt;/code&gt; はunqiue sortを指定し、次にfileglobはソートするファイルを指定します。結果のファイルハンドル &lt;code&gt;$sort_fh&lt;/code&gt; 、読み取り専用（ &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; ）ファイルハンドルと同じように機能し、プログラムは、通常の単一ファイルで開かれたかのように、データを読み取ることができます。</target>
        </trans-unit>
        <trans-unit id="74bef6f0ef3eec50d14d3b84a1a8afd14c67d76b" translate="yes" xml:space="preserve">
          <source>Note that the third argument, specifying the command that we wish to pipe to, sets up &lt;code&gt;cat&lt;/code&gt; to redirect its output via that &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; symbol into the file &lt;code&gt;numbered.txt&lt;/code&gt;. This can start to look a little tricky, because that same symbol would have meant something entirely different had it showed it in the second argument to &lt;code&gt;open&lt;/code&gt;! But here in the third argument, it's simply part of the shell command that Perl will open the pipe into, and Perl itself doesn't invest any special meaning to it.</source>
          <target state="translated">パイプ先のコマンドを指定する3番目の引数は、その出力をその &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 記号を介してファイル &lt;code&gt;numbered.txt&lt;/code&gt; にリダイレクトするように &lt;code&gt;cat&lt;/code&gt; を設定することに注意してください。これは少しトリッキーに見え始める可能性があります。同じシンボルが、 &lt;code&gt;open&lt;/code&gt; 2番目の引数でそれを示していれば、まったく異なる何かを意味するからです。しかし、ここで3番目の引数では、Perlがパイプを開くのはシェルコマンドの一部であり、Perl自体はそれに特別な意味を投資しません。</target>
        </trans-unit>
        <trans-unit id="0d43c895066c9d58f40f202a5d66994671522d5e" translate="yes" xml:space="preserve">
          <source>Note that the trailing slash is required. This will result in some harmless warnings as Configure is run:</source>
          <target state="translated">最後のスラッシュが必要なことに注意してください。これにより、Configure の実行時に無害な警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="4c26505297a31083f6416749d3b93a6af60fd352" translate="yes" xml:space="preserve">
          <source>Note that the trapping of the restricted operations is not atomic: for example</source>
          <target state="translated">制限された操作のトラップはアトミックではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="ec116afd50e96fd07d539738d536a8676b15709b" translate="yes" xml:space="preserve">
          <source>Note that the two characters on either side of the hyphen are not necessarily both letters or both digits. Any character is possible, although not advisable. &lt;code&gt;['-?]&lt;/code&gt; contains a range of characters, but most people will not know which characters that means. Furthermore, such ranges may lead to portability problems if the code has to run on a platform that uses a different character set, such as EBCDIC.</source>
          <target state="translated">ハイフンの両側にある2つの文字は、必ずしも両方の文字または両方の数字である必要はないことに注意してください。推奨されていませんが、任意の文字が可能です。 &lt;code&gt;['-?]&lt;/code&gt; にはさまざまな文字が含まれますが、ほとんどの人はどの文字が意味するのかわかりません。さらに、EBCDICなどの異なる文字セットを使用するプラットフォームでコードを実行する必要がある場合、このような範囲は移植性の問題を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="4f3b0de1587236bfef6be06a1e0b5de9990d1475" translate="yes" xml:space="preserve">
          <source>Note that the user's arguments are also passed to your plugin's &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; function as a list, eg:</source>
          <target state="translated">ユーザーの引数はプラグインの &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import()&lt;/a&gt;&lt;/code&gt; 関数にもリストとして渡されることに注意してください。例：</target>
        </trans-unit>
        <trans-unit id="b14ba3e78a188703ed0553b34c3137fe88a72a21" translate="yes" xml:space="preserve">
          <source>Note that the user's arguments are also passed to your plugin's &lt;code&gt;import()&lt;/code&gt; function as a list, eg:</source>
          <target state="translated">ユーザーの引数は、プラグインの &lt;code&gt;import()&lt;/code&gt; 関数にもリストとして渡されることに注意してください。例：</target>
        </trans-unit>
        <trans-unit id="1a9f0c91ad407486da2a0bb856a821fce00b3309" translate="yes" xml:space="preserve">
          <source>Note that the value is parsed every time the &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; executes. If EXPR is omitted, evaluates &lt;code&gt;$_&lt;/code&gt; . This form is typically used to delay parsing and subsequent execution of the text of EXPR until run time.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; が実行されるたびに値が解析されることに注意してください。EXPRが省略されている場合、 &lt;code&gt;$_&lt;/code&gt; 評価します。このフォームは通常、実行時までEXPRのテキストの解析とその後の実行を遅らせるために使用されます。</target>
        </trans-unit>
        <trans-unit id="80c8be42c3096c6bc305f155cfa7b7681593f345" translate="yes" xml:space="preserve">
          <source>Note that the value is parsed every time the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; executes. If EXPR is omitted, evaluates &lt;code&gt;$_&lt;/code&gt; . This form is typically used to delay parsing and subsequent execution of the text of EXPR until run time.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; が実行されるたびに値が解析されることに注意してください。EXPRが省略されている場合、 &lt;code&gt;$_&lt;/code&gt; 評価します。このフォームは通常、実行時までEXPRのテキストの解析とその後の実行を遅らせるために使用されます。</target>
        </trans-unit>
        <trans-unit id="2890675e6e5968cd2291073021c2fb93c7f31c50" translate="yes" xml:space="preserve">
          <source>Note that the value of &lt;code&gt;RV&lt;/code&gt; coincides with the numbers we see when we stringify $b. The addresses inside IV() are addresses of &lt;code&gt;X***&lt;/code&gt; structures which hold the current state of an &lt;code&gt;SV&lt;/code&gt; . This address may change during lifetime of an SV.</source>
          <target state="translated">&lt;code&gt;RV&lt;/code&gt; の値は、$ bを文字列化したときに表示される数値と一致することに注意してください。IV（）内のアドレスは、 &lt;code&gt;SV&lt;/code&gt; の現在の状態を保持する &lt;code&gt;X***&lt;/code&gt; 構造体のアドレスです。このアドレスは、SVの存続期間中に変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="66bc2a839853392e6ca68b6e60b0dadd045339b5" translate="yes" xml:space="preserve">
          <source>Note that the value of &lt;code&gt;RV&lt;/code&gt; coincides with the numbers we see when we stringify $b. The addresses inside IV() are addresses of &lt;code&gt;X***&lt;/code&gt; structures which hold the current state of an &lt;code&gt;SV&lt;/code&gt;. This address may change during lifetime of an SV.</source>
          <target state="translated">&lt;code&gt;RV&lt;/code&gt; の値は、$ bを文字列化したときに表示される数値と一致することに注意してください。IV（）内のアドレスは、 &lt;code&gt;SV&lt;/code&gt; の現在の状態を保持する &lt;code&gt;X***&lt;/code&gt; 構造体のアドレスです。このアドレスは、SVの存続期間中に変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="2ef677d9c2b3cc466ca9bce864166dbad6ce21bf" translate="yes" xml:space="preserve">
          <source>Note that the values are not copied, which means modifying them will modify the contents of the hash:</source>
          <target state="translated">値はコピーされないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="ebcf1c39304e5cedc9f3bd9f293f7823399a8398" translate="yes" xml:space="preserve">
          <source>Note that the values for the</source>
          <target state="translated">の値に注意してください。</target>
        </trans-unit>
        <trans-unit id="fa78261a427d9e6af662bdbde0ef46d033f442ef" translate="yes" xml:space="preserve">
          <source>Note that the variables &lt;code&gt;$z0&lt;/code&gt; and &lt;code&gt;$z1&lt;/code&gt; are not substituted when the regexp is compiled, as happens for ordinary variables outside a code expression. Rather, the whole code block is parsed as perl code at the same time as perl is compiling the code containing the literal regexp pattern.</source>
          <target state="translated">正規表現がコンパイルされるとき、変数 &lt;code&gt;$z0&lt;/code&gt; と &lt;code&gt;$z1&lt;/code&gt; は置換されないことに注意してください。これは、コード式の外側の通常の変数で発生します。むしろ、perlがリテラル正規表現パターンを含むコードをコンパイルすると同時に、コードブロック全体がperlコードとして解析されます。</target>
        </trans-unit>
        <trans-unit id="1fe8cdc1e68ec1c1124569f21bcd3994f60be55b" translate="yes" xml:space="preserve">
          <source>Note that there are different &quot;long doubles&quot;: Perl will use whatever the compiler has.</source>
          <target state="translated">異なる「長い倍数」があることに注意してください。Perl はコンパイラが持っているものなら何でも使います。</target>
        </trans-unit>
        <trans-unit id="40ec796a3ab0ba742755eb67dcef2d941aab9225" translate="yes" xml:space="preserve">
          <source>Note that there are platform-specific limitations on the maximum length of &lt;code&gt;$0&lt;/code&gt; . In the most extreme case it may be limited to the space occupied by the original &lt;code&gt;$0&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$0&lt;/code&gt; 最大長にはプラットフォーム固有の制限があることに注意してください。最も極端な場合は、元の &lt;code&gt;$0&lt;/code&gt; が占めるスペースに制限される可能性があります。</target>
        </trans-unit>
        <trans-unit id="3ee80c0ec2ca365e28a84cac33edad0345d62e8d" translate="yes" xml:space="preserve">
          <source>Note that there are platform-specific limitations on the maximum length of &lt;code&gt;$0&lt;/code&gt;. In the most extreme case it may be limited to the space occupied by the original &lt;code&gt;$0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$0&lt;/code&gt; 最大長にはプラットフォーム固有の制限があることに注意してください。最も極端なケースでは、元の &lt;code&gt;$0&lt;/code&gt; が占めるスペースに制限される場合があります。</target>
        </trans-unit>
        <trans-unit id="5f16f6cc7a1d32290bc8fbd0609f6f10bfa51e1b" translate="yes" xml:space="preserve">
          <source>Note that there are quite a few things that are unaffected by the current locale. Any literal character is the native character for the given platform. Hence 'A' means the character at code point 65 on ASCII platforms, and 193 on EBCDIC. That may or may not be an 'A' in the current locale, if that locale even has an 'A'. Similarly, all the escape sequences for particular characters, &lt;code&gt;\n&lt;/code&gt; for example, always mean the platform's native one. This means, for example, that &lt;code&gt;\N&lt;/code&gt; in regular expressions (every character but new-line) works on the platform character set.</source>
          <target state="translated">現在のロケールの影響を受けないものがいくつかあることに注意してください。任意のリテラル文字は、指定されたプラットフォームのネイティブ文字です。したがって、「A」は、ASCIIプラットフォームではコードポイント65、EBCDICでは193の文字を意味します。現在のロケールで 'A'が含まれている場合でも、そのロケールが 'A'である場合とそうでない場合があります。同様に、 &lt;code&gt;\n&lt;/code&gt; など、特定の文字のすべてのエスケープシーケンスは、常にプラットフォームのネイティブエスケープシーケンスを意味します。これは、たとえば、正規表現（改行を除くすべての文字）の &lt;code&gt;\N&lt;/code&gt; がプラットフォームの文字セットで機能することを意味します。</target>
        </trans-unit>
        <trans-unit id="fcd641de5265b4e5cb187918ec80acbf65468caa" translate="yes" xml:space="preserve">
          <source>Note that there is no &lt;code&gt;unlock()&lt;/code&gt; function - the only way to unlock a variable is to allow it to go out of scope.</source>
          <target state="translated">&lt;code&gt;unlock()&lt;/code&gt; 関数はないことに注意してください。変数のロックを解除する唯一の方法は、変数をスコープ外に出すことです。</target>
        </trans-unit>
        <trans-unit id="ee4f05af5f26db870953ddb10f74cf79c107ad1e" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the return value of &lt;code&gt;SvPV()&lt;/code&gt; is equal to &lt;code&gt;SvPVX(sv)&lt;/code&gt; , or that &lt;code&gt;SvPVX(sv)&lt;/code&gt; contains valid data, or that successive calls to &lt;code&gt;SvPV(sv)&lt;/code&gt; will return the same pointer value each time. This is due to the way that things like overloading and Copy-On-Write are handled. In these cases, the return value may point to a temporary buffer or similar. If you absolutely need the SvPVX field to be valid (for example, if you intend to write to it), then see &lt;a href=&quot;#SvPV_force&quot;&gt;SvPV_force&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;SvPV()&lt;/code&gt; の戻り値がSvPVX（ &lt;code&gt;SvPVX(sv)&lt;/code&gt; ）と等しいこと、または &lt;code&gt;SvPVX(sv)&lt;/code&gt; に有効なデータが含まれていること、または &lt;code&gt;SvPV(sv)&lt;/code&gt; への連続した呼び出しが毎回同じポインタ値を返すことは保証されないことに注意してください。これは、オーバーロードやコピーオンライトなどの処理方法が原因です。これらの場合、戻り値は一時バッファなどを指す場合があります。 SvPVXフィールドを有効にする必要がある場合（たとえば、書き込む予定がある場合）は、&lt;a href=&quot;#SvPV_force&quot;&gt;SvPV_force&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7173a3e77270e17008cce0d5bec933c84a84832b" translate="yes" xml:space="preserve">
          <source>Note that there is no guarantee that the return value of &lt;code&gt;SvPV()&lt;/code&gt; is equal to &lt;code&gt;SvPVX(sv)&lt;/code&gt;, or that &lt;code&gt;SvPVX(sv)&lt;/code&gt; contains valid data, or that successive calls to &lt;code&gt;SvPV(sv)&lt;/code&gt; will return the same pointer value each time. This is due to the way that things like overloading and Copy-On-Write are handled. In these cases, the return value may point to a temporary buffer or similar. If you absolutely need the &lt;code&gt;SvPVX&lt;/code&gt; field to be valid (for example, if you intend to write to it), then see &lt;code&gt;&lt;a href=&quot;#SvPV_force&quot;&gt;&quot;SvPV_force&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SvPV()&lt;/code&gt; の戻り値がSvPVX（ &lt;code&gt;SvPVX(sv)&lt;/code&gt; ）と等しい、 &lt;code&gt;SvPVX(sv)&lt;/code&gt; に有効なデータが含まれている、またはSvPV（sv）を連続して呼び出すと &lt;code&gt;SvPV(sv)&lt;/code&gt; 同じポインター値が返されるという保証はないことに注意してください。これは、オーバーロードやコピーオンライトなどの処理方法によるものです。このような場合、戻り値は一時バッファなどを指す場合があります。 &lt;code&gt;SvPVX&lt;/code&gt; フィールドを有効にする必要がある場合（たとえば、書き込みを行う場合）は、 &lt;code&gt;&lt;a href=&quot;#SvPV_force&quot;&gt;&quot;SvPV_force&quot;&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="61e6ff314bcdd26836be58f3e6e1baf7a7a0e0d1" translate="yes" xml:space="preserve">
          <source>Note that there is no longer any need to import the Tie::Cycle module -- Attribute::Handlers takes care of that automagically. You can even pass arguments to the module's &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine, by appending them to the class name. For example:</source>
          <target state="translated">Tie :: Cycleモジュールをインポートする必要がなくなったことに注意してください。Attribute:: Handlersが自動的に処理します。クラス名に引数を追加することで、モジュールの &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; サブルーチンに引数を渡すこともできます。例えば：</target>
        </trans-unit>
        <trans-unit id="7c645ae5150cd4da2a80be90839d213441cd9479" translate="yes" xml:space="preserve">
          <source>Note that there is no longer any need to import the Tie::Cycle module -- Attribute::Handlers takes care of that automagically. You can even pass arguments to the module's &lt;code&gt;import&lt;/code&gt; subroutine, by appending them to the class name. For example:</source>
          <target state="translated">Tie :: Cycleモジュールをインポートする必要がなくなったことに注意してください-Attribute :: Handlersが自動的にそれを処理します。クラス名に引数を追加することで、モジュールの &lt;code&gt;import&lt;/code&gt; サブルーチンに引数を渡すこともできます。例えば：</target>
        </trans-unit>
        <trans-unit id="0baced4cf34e750c502cd9ad3044c3426673e61e" translate="yes" xml:space="preserve">
          <source>Note that there is no method to obtain the filehandle from the &lt;code&gt;File::Temp&lt;/code&gt; object. The object itself acts as a filehandle. The object isa &lt;code&gt;IO::Handle&lt;/code&gt; and isa &lt;code&gt;IO::Seekable&lt;/code&gt; so all those methods are available.</source>
          <target state="translated">&lt;code&gt;File::Temp&lt;/code&gt; オブジェクトからファイルハンドルを取得するメソッドがないことに注意してください。オブジェクト自体がファイルハンドルとして機能します。オブジェクトisaIO &lt;code&gt;IO::Handle&lt;/code&gt; およびisaIO &lt;code&gt;IO::Seekable&lt;/code&gt; ため、これらすべてのメソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="371ae6320cc7816e3fbef9a78451aa3acb900b80" translate="yes" xml:space="preserve">
          <source>Note that there is no method to obtain the filehandle from the C&amp;lt;:temp&amp;gt; object. The object itself acts as a filehandle. The object isa C&amp;lt;:handle&amp;gt; and isa C&amp;lt;:seekable&amp;gt; so all those methods are available.</source>
          <target state="translated">C &amp;lt;：temp&amp;gt;オブジェクトからファイルハンドルを取得する方法がないことに注意してください。オブジェクト自体はファイルハンドルとして機能します。オブジェクトはC &amp;lt;：handle&amp;gt;およびC &amp;lt;：seekable&amp;gt;であるため、これらのすべてのメソッドを使用できます。</target>
        </trans-unit>
        <trans-unit id="d7964282b8c77ed0956498c86928309abbe4d836" translate="yes" xml:space="preserve">
          <source>Note that there is no validation to confirm that the handle is a handle or something that can act like one. Passing something that isn't a handle will cause a exception when trying to read from it. The &lt;code&gt;filename&lt;/code&gt; argument is mandatory or undef will be returned.</source>
          <target state="translated">ハンドルがハンドルまたはハンドルのように機能するものであることを確認するための検証がないことに注意してください。ハンドルではないものを渡すと、それから読み取ろうとしたときに例外が発生します。 &lt;code&gt;filename&lt;/code&gt; 引数は必須ですかundefが返されます。</target>
        </trans-unit>
        <trans-unit id="d8cf101c922aec42258fb611024af08532a1bd0f" translate="yes" xml:space="preserve">
          <source>Note that there's nothing wrong with defining multiple subclasses of a given class. This is both common and safe. For example, we might define &lt;code&gt;File::MP3::FixedBitrate&lt;/code&gt; and &lt;code&gt;File::MP3::VariableBitrate&lt;/code&gt; classes to distinguish between different types of mp3 file.</source>
          <target state="translated">特定のクラスの複数のサブクラスを定義することには何の問題もないことに注意してください。これは一般的で安全です。たとえば、 &lt;code&gt;File::MP3::FixedBitrate&lt;/code&gt; と &lt;code&gt;File::MP3::VariableBitrate&lt;/code&gt; クラスを定義して、さまざまなタイプのmp3ファイルを区別できます。</target>
        </trans-unit>
        <trans-unit id="cea78bd68a577c917916111e5f8f914537b91ae3" translate="yes" xml:space="preserve">
          <source>Note that these configuration options are only used for generating</source>
          <target state="translated">これらの設定オプションは</target>
        </trans-unit>
        <trans-unit id="cf6c8c42d064a6c3523dfd07c74fecf239c950de" translate="yes" xml:space="preserve">
          <source>Note that these functions are compatible with *nix, not with the older ports of '94 - 95. The priorities are absolute, go from 32 to -95, lower is quicker. 0 is the default priority.</source>
          <target state="translated">これらの機能は *nix と互換性があり、'94-95 の古いポートとは互換性がないことに注意してください。優先度は絶対的なもので、32 から -95 までの間で、低いほど速くなります。0 がデフォルトの優先度です。</target>
        </trans-unit>
        <trans-unit id="d791cddf7ffd40104e97e407e1f26e145041f7de" translate="yes" xml:space="preserve">
          <source>Note that these functions take &lt;code&gt;SV*&lt;/code&gt; keys, which simplifies writing of extension code that deals with hash structures. These functions also allow passing of &lt;code&gt;SV*&lt;/code&gt; keys to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; functions without forcing you to stringify the keys (unlike the previous set of functions).</source>
          <target state="translated">これらの関数は &lt;code&gt;SV*&lt;/code&gt; キーを使用することに注意してください。これにより、ハッシュ構造を扱う拡張コードの記述が簡単になります。これらの関数では、 &lt;code&gt;SV*&lt;/code&gt; キーを渡して、キーを文字列化せずに関数を &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; することもできます（前の関数セットとは異なります）。</target>
        </trans-unit>
        <trans-unit id="7cd84224dc690f45347275d943903d70df26fb0c" translate="yes" xml:space="preserve">
          <source>Note that these functions take &lt;code&gt;SV*&lt;/code&gt; keys, which simplifies writing of extension code that deals with hash structures. These functions also allow passing of &lt;code&gt;SV*&lt;/code&gt; keys to &lt;code&gt;tie&lt;/code&gt; functions without forcing you to stringify the keys (unlike the previous set of functions).</source>
          <target state="translated">これらの関数は &lt;code&gt;SV*&lt;/code&gt; キーを使用するため、ハッシュ構造を処理する拡張コードの記述が簡単になることに注意してください。これらの関数を使用すると、 &lt;code&gt;SV*&lt;/code&gt; キーを渡して、キーを文字列化することなく関数を &lt;code&gt;tie&lt;/code&gt; こともできます（以前の関数セットとは異なります）。</target>
        </trans-unit>
        <trans-unit id="ac690cbf2993a60c5814d129da8fb3bc08b59629" translate="yes" xml:space="preserve">
          <source>Note that these macros will only work together within the</source>
          <target state="translated">これらのマクロは</target>
        </trans-unit>
        <trans-unit id="8a5f32d79f24485d8dc52ccd8880da69d87a4d12" translate="yes" xml:space="preserve">
          <source>Note that these problems should not discourage experimenting, since they have a low probability of affecting small programs.</source>
          <target state="translated">これらの問題は、小さなプログラムに影響を与える可能性が低いので、実験の意欲を減退させてはならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="0f02b1ce704f868a5bd6cbc730f85ed167d3d361" translate="yes" xml:space="preserve">
          <source>Note that these routines are</source>
          <target state="translated">これらのルーチンは</target>
        </trans-unit>
        <trans-unit id="5e158a627cf25fb028df016dfe1afff14abe8a74" translate="yes" xml:space="preserve">
          <source>Note that these statistics are summary only. Actual performance will depend on real hit/miss ratios accessing the hash. If you are concerned by hit ratios you are recommended to &quot;oversize&quot; your hash by using something like:</source>
          <target state="translated">これらの統計はあくまでも要約であることに注意してください。実際のパフォーマンスはハッシュにアクセスする実際のヒット/ミスの比率に依存します。もしヒット率が気になる場合は、以下のようにしてハッシュを &quot;オーバーサイズ &quot;にすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="614e9c1a8e14a9fc6d986754f7def273a10af2f8" translate="yes" xml:space="preserve">
          <source>Note that this API requires disambiguation between successful decoding a &lt;code&gt;NUL&lt;/code&gt; character, and an error return (unless the &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; flag is set), as in both cases, 0 is returned, and, depending on the malformation, &lt;code&gt;retlen&lt;/code&gt; may be set to 1. To disambiguate, upon a zero return, see if the first byte of &lt;code&gt;s&lt;/code&gt; is 0 as well. If so, the input was a &lt;code&gt;NUL&lt;/code&gt;; if not, the input had an error. Or you can use &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr_error&quot;&gt;&quot;utf8n_to_uvchr_error&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">このAPIでは、 &lt;code&gt;NUL&lt;/code&gt; 文字のデコードが成功するか、エラーが返されるか（ &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; フラグが設定されていない場合）のあいまいさを解消する必要があることに注意してください。どちらの場合も0が返され、奇形によっては &lt;code&gt;retlen&lt;/code&gt; が1に設定される場合があります。ゼロリターン時に、 &lt;code&gt;s&lt;/code&gt; の最初のバイトも0であるかどうかを明確にします。その場合、入力は &lt;code&gt;NUL&lt;/code&gt; でした。そうでない場合は、入力にエラーがありました。または、 &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr_error&quot;&gt;&quot;utf8n_to_uvchr_error&quot;&lt;/a&gt;&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="73ba985ffd1a15a231f5d43e3ffb4a26ab7bba75" translate="yes" xml:space="preserve">
          <source>Note that this API requires disambiguation between successful decoding a &lt;code&gt;NUL&lt;/code&gt; character, and an error return (unless the UTF8_CHECK_ONLY flag is set), as in both cases, 0 is returned. To disambiguate, upon a zero return, see if the first byte of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; is 0 as well. If so, the input was a &lt;code&gt;NUL&lt;/code&gt; ; if not, the input had an error.</source>
          <target state="translated">このAPIは、 &lt;code&gt;NUL&lt;/code&gt; 文字の正常なデコードとエラー戻り値のあいまいさを解消する必要があることに注意してください（UTF8_CHECK_ONLYフラグが設定されていない場合）。どちらの場合も0が返されます。明確にするために、ゼロが返されたら、 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; の最初のバイトも0 かどうかを確認してください。もしそうなら、入力は &lt;code&gt;NUL&lt;/code&gt; でした。そうでない場合、入力にエラーがありました。</target>
        </trans-unit>
        <trans-unit id="9e7c1fe94057690a3e15fba2814e3a5b075195c1" translate="yes" xml:space="preserve">
          <source>Note that this a lesser issue now when we do not spawn</source>
          <target state="translated">スポーンを行わない場合は、この問題は少なくなります。</target>
        </trans-unit>
        <trans-unit id="b5ca0aab168c321c8270a6107199325edc3cbbd7" translate="yes" xml:space="preserve">
          <source>Note that this behaviour differs from version 1.00 of the Safe module where the root module could be used to change the namespace. That functionality has been withdrawn pending deeper consideration.</source>
          <target state="translated">この動作は、ルートモジュールが名前空間を変更するために使用できる Safe モジュールのバージョン 1.00 とは異なることに注意してください。この機能は、より深い検討を経て撤回されました。</target>
        </trans-unit>
        <trans-unit id="886c9a49ed86dcbe7c33a66300a271b1c555293b" translate="yes" xml:space="preserve">
          <source>Note that this business of escaping a newline is specific to interactive commands typed into the debugger.</source>
          <target state="translated">改行をエスケープすることは、デバッガに入力された対話型コマンドに特有のことであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d9af4c6dbd50132dd9aa57c1076bfc7d75c87275" translate="yes" xml:space="preserve">
          <source>Note that this class also provides (but does not export) the function Pod::Simple::HTMLBatch::go. This is basically just a shortcut for &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt; . It's meant to be handy for calling from the command line.</source>
          <target state="translated">このクラスは、Pod :: Simple :: HTMLBatch :: go関数も提供します（ただし、エクスポートしません）。これは基本的には &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt; 単なるショートカットです。コマンドラインからの呼び出しに便利です。</target>
        </trans-unit>
        <trans-unit id="f83d5136d4b8e93ddca0e990f1293f696287db16" translate="yes" xml:space="preserve">
          <source>Note that this class also provides (but does not export) the function Pod::Simple::HTMLBatch::go. This is basically just a shortcut for &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt;. It's meant to be handy for calling from the command line.</source>
          <target state="translated">このクラスは、関数Pod :: Simple :: HTMLBatch :: goも提供します（ただし、エクスポートはしません）。これは基本的に &lt;code&gt;Pod::Simple::HTMLBatch-&amp;gt;batch_convert(@ARGV)&lt;/code&gt; ショートカットです。これは、コマンドラインから呼び出すのに便利です。</target>
        </trans-unit>
        <trans-unit id="cbd3cc83f76f664edbfed1f74f0bb7a74cadfcdb" translate="yes" xml:space="preserve">
          <source>Note that this does *not* collapse</source>
          <target state="translated">これは崩壊しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="00224048b57a554f368bf0ab411d2ec7b380142b" translate="yes" xml:space="preserve">
          <source>Note that this does not respect any locale that might be in effect; it matches according to the platform's native character set.</source>
          <target state="translated">これは、有効なロケールを尊重しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="c41629303d26db24c4cf7e890ae9d3b978c9901b" translate="yes" xml:space="preserve">
          <source>Note that this example shows the values of the lexicals, whereas the other examples did not (as they're compile-time only).</source>
          <target state="translated">この例では語彙の値が表示されていますが、他の例では表示されていないことに注意してください (コンパイル時のみなので)。</target>
        </trans-unit>
        <trans-unit id="750194633912e1b1b2810b4a6624c08076cb7c4d" translate="yes" xml:space="preserve">
          <source>Note that this feature is currently &lt;a href=&quot;perlpolicy#experimental&quot;&gt;experimental&lt;/a&gt;; using it yields a warning in the &lt;code&gt;experimental::regex_sets&lt;/code&gt; category.</source>
          <target state="translated">この機能は現在&lt;a href=&quot;perlpolicy#experimental&quot;&gt;実験&lt;/a&gt;段階であることに注意してください。これを使用すると、 &lt;code&gt;experimental::regex_sets&lt;/code&gt; カテゴリに警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="fa65d225bcb30ebd19ec0f94b22dc45327203c89" translate="yes" xml:space="preserve">
          <source>Note that this function does</source>
          <target state="translated">この関数は</target>
        </trans-unit>
        <trans-unit id="770403ff8ad9becd7464272640adcfe95f14a6a1" translate="yes" xml:space="preserve">
          <source>Note that this function returns FALSE for inputs that would overflow a UV, or have leading zeros. Thus a single &lt;code&gt;0&lt;/code&gt; is accepted, but not &lt;code&gt;00&lt;/code&gt; nor &lt;code&gt;01&lt;/code&gt;, &lt;code&gt;002&lt;/code&gt;,</source>
          <target state="translated">この関数は、UVをオーバーフローする入力、または先行ゼロを持つ入力に対してFALSEを返すことに注意してください。したがって、単一の &lt;code&gt;0&lt;/code&gt; を受け入れていないが、 &lt;code&gt;00&lt;/code&gt; や &lt;code&gt;01&lt;/code&gt; 、 &lt;code&gt;002&lt;/code&gt; 、</target>
        </trans-unit>
        <trans-unit id="383a0ca4f40d5e081bc8cd1b9b45b6acddf8c873" translate="yes" xml:space="preserve">
          <source>Note that this harness is</source>
          <target state="translated">このハーネスは</target>
        </trans-unit>
        <trans-unit id="26765a3c9e68c0777ae5d0fb4a579c61611c0dca" translate="yes" xml:space="preserve">
          <source>Note that this hash does not include numerics (like &quot;64&quot; or &quot;x981c&quot;).</source>
          <target state="translated">このハッシュには数値は含まれていないことに注意してください(&quot;64&quot; や &quot;x981c&quot; のような)。</target>
        </trans-unit>
        <trans-unit id="d9c356ba63dd81b549b024d31174e2c723d0a6c7" translate="yes" xml:space="preserve">
          <source>Note that this is a backwards incompatible change from version &lt;code&gt;1.36&lt;/code&gt; and before.</source>
          <target state="translated">これはバージョン &lt;code&gt;1.36&lt;/code&gt; 以前からの下位互換性のない変更であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d089b782c3356f4400063cd34b72b66e78bb2e56" translate="yes" xml:space="preserve">
          <source>Note that this is a unary operator, not a list operator.</source>
          <target state="translated">これは単項演算子であり、リスト演算子ではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="dcb3c6a57a75c99d73d6d08c842005a53c2cad92" translate="yes" xml:space="preserve">
          <source>Note that this is an experimental feature which may be changed or removed in a future Perl release.</source>
          <target state="translated">これは実験的な機能であり、将来の Perl リリースで変更または削除される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="504d8cb8d0a49d57ae71301eeedf5cb16096e2bb" translate="yes" xml:space="preserve">
          <source>Note that this is not in general possible in shells of more dubious heritage, as the theoretical</source>
          <target state="translated">これは、理論的には、より疑わしい遺産のある貝殻では一般的には不可能であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9b1de500fa4baebd7c567a7a827d4c48d84fe735" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; , which begins a new dispatch that is restricted to searching the ancestors of the current class. &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; can backtrack past the current class -- to look for a suitable method in other ancestors of &lt;code&gt;$self&lt;/code&gt; -- whereas &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; cannot.</source>
          <target state="translated">これは、現在のクラスの祖先の検索に制限された新しいディスパッチを開始する &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; と同じではないことに注意してください。 &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; は、現在のクラスを越えてバックトラックできます- &lt;code&gt;$self&lt;/code&gt; 他の祖先で適切なメソッドを探すことができますが、 &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; はできません。</target>
        </trans-unit>
        <trans-unit id="511522d55453b336eeec0192506af6b8fb160bde" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt;, which begins a new dispatch that is restricted to searching the ancestors of the current class. &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; can backtrack past the current class -- to look for a suitable method in other ancestors of &lt;code&gt;$self&lt;/code&gt; -- whereas &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; cannot.</source>
          <target state="translated">これは、現在のクラスの祖先の検索に制限された新しいディスパッチを開始する &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; と同じではないことに注意してください。 &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt; の他の祖先で適切な方法を探すために-現在のクラスを過ぎて後戻りすることができます &lt;code&gt;$self&lt;/code&gt; -一方、 &lt;code&gt;$self-&amp;gt;SUPER::m()&lt;/code&gt; することはできません。</target>
        </trans-unit>
        <trans-unit id="fb474ba009e8c7c8d7bdb3779c16f4d2c9b0cba8" translate="yes" xml:space="preserve">
          <source>Note that this is one of the rare cases where you cannot use the same template for &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; because &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; can't determine a repeat count for a &lt;code&gt;()&lt;/code&gt; -group.</source>
          <target state="translated">これは、 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;()&lt;/code&gt; グループの繰り返し回数を決定できないため、 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; に同じテンプレートを使用できないまれなケースの1つであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="31c689cdab9ea9a66fe06d7827f40cae99aad3e2" translate="yes" xml:space="preserve">
          <source>Note that this is one of the rare cases where you cannot use the same template for &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; because &lt;code&gt;pack&lt;/code&gt; can't determine a repeat count for a &lt;code&gt;()&lt;/code&gt;-group.</source>
          <target state="translated">これは、 &lt;code&gt;pack&lt;/code&gt; が &lt;code&gt;()&lt;/code&gt; グループの繰り返し回数を判別できないため、 &lt;code&gt;pack&lt;/code&gt; と &lt;code&gt;unpack&lt;/code&gt; に同じテンプレートを使用できないまれなケースの1つであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="37d289726dbf38f52d7d747a6f498b593946b256" translate="yes" xml:space="preserve">
          <source>Note that this is the</source>
          <target state="translated">であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="051c395ae34aa1a11e3b94b0cb470642628b722b" translate="yes" xml:space="preserve">
          <source>Note that this isn't really a word in the English sense; it's just chunks of consecutive non-whitespace characters.</source>
          <target state="translated">これは英語の意味での単語ではなく、連続した非空白文字の塊であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f98a99684b1c3e2bccd26b3c2631a053bdfaf9be" translate="yes" xml:space="preserve">
          <source>Note that this issue precludes the building of many Macintosh-specific CPAN modules (&lt;code&gt;Mac::*&lt;/code&gt; ), as the required Apple frameworks do not provide PPC64 support. Similarly, downloads from Fink or Darwinports are unlikely to provide 64-bit support; the libraries must be rebuilt from source with the appropriate compiler and linker flags. For further information, see Apple's</source>
          <target state="translated">必要なAppleフレームワークはPPC64サポートを提供しないため、この問題により、多くのMacintosh固有のCPANモジュール（ &lt;code&gt;Mac::*&lt;/code&gt; ）を構築できなくなります。同様に、FinkまたはDarwinportsからのダウンロードでは、64ビットのサポートは提供されない可能性があります。ライブラリは、適切なコンパイラおよびリンカーフラグを使用して、ソースから再構築する必要があります。詳細については、アップルの</target>
        </trans-unit>
        <trans-unit id="e01d7922e9382b1372af232c43cd56d7c9562fcf" translate="yes" xml:space="preserve">
          <source>Note that this issue precludes the building of many Macintosh-specific CPAN modules (&lt;code&gt;Mac::*&lt;/code&gt;), as the required Apple frameworks do not provide PPC64 support. Similarly, downloads from Fink or Darwinports are unlikely to provide 64-bit support; the libraries must be rebuilt from source with the appropriate compiler and linker flags. For further information, see Apple's</source>
          <target state="translated">必要なAppleフレームワークはPPC64をサポートしていないため、この問題により、多くのMacintosh固有のCPANモジュール（ &lt;code&gt;Mac::*&lt;/code&gt; ）を構築できないことに注意してください。同様に、FinkまたはDarwinportsからのダウンロードが64ビットサポートを提供する可能性は低いです。ライブラリは、適切なコンパイラフラグとリンカフラグを使用してソースから再構築する必要があります。詳細については、Appleの</target>
        </trans-unit>
        <trans-unit id="3cf9c28e72f601c60b3c701ee74ca406285e72fe" translate="yes" xml:space="preserve">
          <source>Note that this last example is</source>
          <target state="translated">この最後の例は</target>
        </trans-unit>
        <trans-unit id="d42f0b82dfd8478b8b9451848cff1ed7d60be50b" translate="yes" xml:space="preserve">
          <source>Note that this means that Perl expects other software to work the same way: if Perl has been led to believe that STDIN should be UTF-8, but then STDIN coming in from another command is not UTF-8, Perl will likely complain about the malformed UTF-8.</source>
          <target state="translated">このことは、Perl が他のソフトウェアが同じように動作することを期待していることを意味しています。</target>
        </trans-unit>
        <trans-unit id="eb14855fa34c491b4e9b69501367a6f35eac94cc" translate="yes" xml:space="preserve">
          <source>Note that this means that there is no way for the inner pattern to refer to a capture group defined outside. (The code block itself can use &lt;code&gt;$1&lt;/code&gt; , etc., to refer to the enclosing pattern's capture groups.) Thus, although</source>
          <target state="translated">これは、内部パターンが外部で定義されたキャプチャグループを参照する方法がないことを意味することに注意してください。（コードブロック自体は &lt;code&gt;$1&lt;/code&gt; などを使用して、囲んでいるパターンのキャプチャグループを参照できます。）したがって、</target>
        </trans-unit>
        <trans-unit id="75120e6f9c48966777ee766b66dc5e5bb92f00ed" translate="yes" xml:space="preserve">
          <source>Note that this means that there is no way for the inner pattern to refer to a capture group defined outside. (The code block itself can use &lt;code&gt;$1&lt;/code&gt;,</source>
          <target state="translated">これは、内部パターンが外部で定義されたキャプチャグループを参照する方法がないことを意味することに注意してください。（コードブロック自体は &lt;code&gt;$1&lt;/code&gt; を使用できます、</target>
        </trans-unit>
        <trans-unit id="d85a4e8b339d0e328effdd49337132425d3cb1dc" translate="yes" xml:space="preserve">
          <source>Note that this method considers a half-open TCP socket to be &quot;in a connected state&quot;. Specifically, it does not distinguish between the &lt;b&gt;ESTABLISHED&lt;/b&gt; and &lt;b&gt;CLOSE-WAIT&lt;/b&gt; TCP states; it returns the peer address, rather than &lt;code&gt;undef&lt;/code&gt;, in either case. Thus, in general, it cannot be used to reliably learn whether the peer has initiated a graceful shutdown because in most cases (see below) the local TCP state machine remains in &lt;b&gt;CLOSE-WAIT&lt;/b&gt; until the local application calls &lt;a href=&quot;IO::Socket#shutdown&quot;&gt;&quot;shutdown&quot; in IO::Socket&lt;/a&gt; or &lt;code&gt;close&lt;/code&gt;. Only at that point does this function return &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">この方法では、ハーフオープンTCPソケットが「接続状態」であると見なされることに注意してください。具体的には、&lt;b&gt;ESTABLISHED状態&lt;/b&gt;と&lt;b&gt;CLOSE-WAITTCP&lt;/b&gt;状態を区別しません。いずれの場合も、 &lt;code&gt;undef&lt;/code&gt; ではなくピアアドレスを返します。したがって、ほとんどの場合（以下を参照）、ローカルアプリケーションが&lt;a href=&quot;IO::Socket#shutdown&quot;&gt;IO ::で「シャットダウン」を&lt;/a&gt;呼び出すまで、ローカルTCPステートマシンは&lt;b&gt;CLOSE-WAITの&lt;/b&gt;ままであるため、一般に、ピアがグレースフルシャットダウンを開始したかどうかを確実に学習するために使用することはできません。ソケットまたは &lt;code&gt;close&lt;/code&gt; 。その時点でのみ、この関数は &lt;code&gt;undef&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="cb2f7fa1807b6ef282836388add7c29032688f86" translate="yes" xml:space="preserve">
          <source>Note that this method does not write &lt;code&gt;on the fly&lt;/code&gt; as it were; it still reads all the files into memory before writing out the archive. Consult the FAQ below if this is a problem.</source>
          <target state="translated">このメソッドは &lt;code&gt;on the fly&lt;/code&gt; 書き込むわけではないことに注意してください。アーカイブを書き込む前に、すべてのファイルをメモリに読み込みます。これが問題である場合は、以下のFAQを参照してください。</target>
        </trans-unit>
        <trans-unit id="9ebf1673f6d5cc53332f54347212529a0a096746" translate="yes" xml:space="preserve">
          <source>Note that this method merely returns the comment preceded by a '# '.</source>
          <target state="translated">このメソッドは、単に '#' の前にコメントを返すだけであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e4bf33faadadb73f5033c17a03e0a21d5d47bf67" translate="yes" xml:space="preserve">
          <source>Note that this only affects how most of the arithmetic and relational &lt;b&gt;operators&lt;/b&gt; handle their operands and results, and &lt;b&gt;not&lt;/b&gt; how all numbers everywhere are treated. Specifically, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; has the effect that before computing the results of the arithmetic operators (+, -, *, /, %, +=, -=, *=, /=, %=, and unary minus), the comparison operators (&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, ==, !=, &amp;lt;=&amp;gt;), and the bitwise operators (|, &amp;amp;, ^, &amp;lt;&amp;lt;,&amp;gt;&amp;gt;, |=, &amp;amp;=, ^=, &amp;lt;&amp;lt;=,&amp;gt;&amp;gt;=), the operands have their fractional portions truncated (or floored), and the result will have its fractional portion truncated as well. In addition, the range of operands and results is restricted to that of familiar two's complement integers, i.e., -(2**31) .. (2**31-1) on 32-bit architectures, and -(2**63) .. (2**63-1) on 64-bit architectures. For example, this code</source>
          <target state="translated">これが唯一の算術演算と関係のほとんどどのように影響することに注意してください&lt;b&gt;演算子は&lt;/b&gt;、オペランドと結果を処理し、&lt;b&gt;ない&lt;/b&gt;どこでもどのようにすべての数字が処理されます。具体的には、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用し&lt;/a&gt;ます。算術演算子（+、-、*、/、％、+ =、-=、* =、/ =、％=、および単項マイナス）の結果を計算する前に、比較演算子（&amp;lt;、&amp;lt; =、&amp;gt;、&amp;gt; =、==、！=、&amp;lt;=&amp;gt;）、およびビットごとの演算子（|、＆、^、&amp;lt;&amp;lt;、&amp;gt;&amp;gt;、| =、＆=、^ =、&amp;lt;&amp;lt; =、&amp;gt;&amp;gt; =）、オペランドの小数部分は切り捨てられ（またはフロアされ）、結果の小数部分も切り捨てられます。さらに、オペランドと結果の範囲は、おなじみの2の補数の整数の範囲に制限されます。つまり、32ビットアーキテクチャでは-（2 ** 31）..（2 ** 31-1）、および-（2 ** 63）..（2 ** 63-1）64ビットアーキテクチャ。たとえば、このコード</target>
        </trans-unit>
        <trans-unit id="444b0c1a203433a23ae5410357a56dc9fd46182a" translate="yes" xml:space="preserve">
          <source>Note that this only affects how most of the arithmetic and relational &lt;b&gt;operators&lt;/b&gt; handle their operands and results, and &lt;b&gt;not&lt;/b&gt; how all numbers everywhere are treated. Specifically, &lt;code&gt;use integer;&lt;/code&gt; has the effect that before computing the results of the arithmetic operators (+, -, *, /, %, +=, -=, *=, /=, %=, and unary minus), the comparison operators (&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, ==, !=, &amp;lt;=&amp;gt;), and the bitwise operators (|, &amp;amp;, ^, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, |=, &amp;amp;=, ^=, &amp;lt;&amp;lt;=, &amp;gt;&amp;gt;=), the operands have their fractional portions truncated (or floored), and the result will have its fractional portion truncated as well. In addition, the range of operands and results is restricted to that of familiar two's complement integers, i.e., -(2**31) .. (2**31-1) on 32-bit architectures, and -(2**63) .. (2**63-1) on 64-bit architectures. For example, this code</source>
          <target state="translated">これが唯一の算術演算と関係のほとんどどのように影響することに注意してください&lt;b&gt;演算子は&lt;/b&gt;、オペランドと結果を処理し、&lt;b&gt;ない&lt;/b&gt;どこでもどのようにすべての数字が処理されます。具体的には、 &lt;code&gt;use integer;&lt;/code&gt; 算術演算子（+、-、*、/、％、+ =、-=、* =、/ =、％=、および単項マイナス）の結果を計算する前に、比較演算子（&amp;lt;、&amp;lt; =、&amp;gt;、&amp;gt; =、==、！=、&amp;lt;=&amp;gt;）、およびビット演算子（|、＆、^、&amp;lt;&amp;lt;、&amp;gt;&amp;gt;、| =、＆=、^ =、&amp;lt;&amp;lt; =、&amp;gt;&amp;gt; =）、オペランドの小数部分が切り捨てられます（またはフロアになります）。結果には、小数部分も切り捨てられます。さらに、オペランドと結果の範囲は、使い慣れた2の補数整数の範囲に制限されます。つまり、32ビットアーキテクチャでは-（2 ** 31）..（2 ** 31-1）、-（2 ** 63）..（2 ** 63-1）64ビットアーキテクチャ。たとえば、このコード</target>
        </trans-unit>
        <trans-unit id="ed01a3c9fe729c5926b4311c21dc0630e4d43559" translate="yes" xml:space="preserve">
          <source>Note that this option alone doesn't cause any debugging information to be output. What it does is stop the normal suppression of execution-related debugging information during the matching portion of the compilation of wildcards. You also have to specify which execution debugging information you want, such as by also including the EXECUTE option.</source>
          <target state="translated">このオプションだけではデバッグ情報は出力されないことに注意してください。このオプションが行うのは、ワイルドカードのコンパイルのマッチング部分の間、実行関連のデバッグ情報の通常の抑制を停止することです。また、EXECUTEオプションを含めるなどして、どの実行デバッグ情報を出力したいかを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="641efca71748ee43843d8c870296735b58cb247a" translate="yes" xml:space="preserve">
          <source>Note that this option is probably not useful when converting multiple POD files at once. The convention for Unix man pages for commands is for the man page title to be in all-uppercase even if the command isn't.</source>
          <target state="translated">このオプションは、複数のPODファイルを一度に変換する場合には、おそらく有用ではないことに注意してください。コマンドのための Unix の man ページの慣習は、コマンドがなくても man ページのタイトルをすべて大文字にすることです。</target>
        </trans-unit>
        <trans-unit id="23d0291a11d0e9160102c369e2e83afde2d6c5ee" translate="yes" xml:space="preserve">
          <source>Note that this option only works with Perl 5.8.4 or better.</source>
          <target state="translated">このオプションはPerl 5.8.4以上でのみ動作することに注意してください。</target>
        </trans-unit>
        <trans-unit id="898ae211ecf9d9481d220ef526611f5faf15a726" translate="yes" xml:space="preserve">
          <source>Note that this section does not document what</source>
          <target state="translated">このセクションでは</target>
        </trans-unit>
        <trans-unit id="650a0cb19795021c90db4bffb31d952d9b4b0616" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning an AV*. See also: T_AVREF_REFCOUNT_FIXED</source>
          <target state="translated">このタイプマップは,AV*を返すときに参照カウントをデクリメントしないことに注意してください.こちらも参照してください。T_AVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="75948654033e1807460f39019ce055bccbe6d14b" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning an HV*. See also: T_HVREF_REFCOUNT_FIXED</source>
          <target state="translated">このタイプマップは,HV*を返すときに参照カウントをデクリメントしないことに注意してください.こちらも参照してください。T_HVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="4c5b3cb2ecd59af3fa9332d1a075ffadbd08c0cb" translate="yes" xml:space="preserve">
          <source>Note that this typemap does not decrement the reference count when returning the reference to an SV*. See also: T_SVREF_REFCOUNT_FIXED</source>
          <target state="translated">このタイプマップは、SV*への参照を返す際に参照カウントをデクリメントしないことに注意してください。こちらも参照してください。T_SVREF_REFCOUNT_FIXED</target>
        </trans-unit>
        <trans-unit id="fdb88d672a97dbd887a0e264f45a135e237c14a4" translate="yes" xml:space="preserve">
          <source>Note that this variable was added in Perl 5.14.0. If you want to detect the global destruction phase on older versions of Perl, you can use the &lt;code&gt;Devel::GlobalDestruction&lt;/code&gt; module on CPAN.</source>
          <target state="translated">この変数はPerl 5.14.0で追加されたことに注意してください。古いバージョンのPerlでグローバル破壊フェーズを検出する場合は、CPANで &lt;code&gt;Devel::GlobalDestruction&lt;/code&gt; モジュールを使用できます。</target>
        </trans-unit>
        <trans-unit id="79cbc4907067b711c2733dabb85b47c17c625682" translate="yes" xml:space="preserve">
          <source>Note that this version number is not the same as the version number of the Storable module itself. For instance Storable v0.7 create files in format v2.0 and Storable v2.15 create files in format v2.7. The file format version number only increment when additional features that would confuse older versions of the module are added.</source>
          <target state="translated">このバージョン番号は、Storable モジュールのバージョン番号と同じではないことに注意してください。例えば、Storable v0.7 は v2.0 形式のファイルを作成し、Storable v2.15 は v2.7 形式のファイルを作成します。ファイルフォーマットのバージョン番号は、古いバージョンのモジュールを混乱させるような追加機能が追加された場合にのみインクリメントされます。</target>
        </trans-unit>
        <trans-unit id="c30cc57c265bdbcc01b87c7faff90971cd8cbcd5" translate="yes" xml:space="preserve">
          <source>Note that this will not apply to distributions that failed tests because of missing dependencies. Also, tests can be run regardless of the history using &quot;force&quot;.</source>
          <target state="translated">依存関係がないためにテストに失敗したディストリビューションには適用されないことに注意してください。また、&quot;force &quot;を使えば、履歴に関係なくテストを実行することができます。</target>
        </trans-unit>
        <trans-unit id="4bcf77d3862c68d316c827809d40fa450ae96c79" translate="yes" xml:space="preserve">
          <source>Note that this will not work on uninstalled perls when called with &lt;code&gt;-I/path/to/uninstalled/perl/lib&lt;/code&gt;, but it works when that path is in &lt;code&gt;$PERL5LIB&lt;/code&gt; or in &lt;code&gt;$PERL5OPT&lt;/code&gt;, as paths passed using &lt;code&gt;-I&lt;/code&gt; are not known when the &lt;code&gt;-V&lt;/code&gt; information is collected.</source>
          <target state="translated">これは、 &lt;code&gt;-I/path/to/uninstalled/perl/lib&lt;/code&gt; で呼び出された場合、アンインストールされたperlでは機能しませんが、 &lt;code&gt;-I&lt;/code&gt; を使用して渡されたパスは &lt;code&gt;$PERL5OPT&lt;/code&gt; であるため、そのパスが &lt;code&gt;$PERL5LIB&lt;/code&gt; または$ PERL5OPTにある場合は機能します。 &lt;code&gt;-V&lt;/code&gt; の情報が収集されます。</target>
        </trans-unit>
        <trans-unit id="129dbf47ba2ec65b5d9ac83fd612d686af9cd750" translate="yes" xml:space="preserve">
          <source>Note that this will produce something similar, but it's much harder to read:</source>
          <target state="translated">似たようなものが出てきますが、読みにくいので注意してください。</target>
        </trans-unit>
        <trans-unit id="b8bf897da733e3c7fd8c9b9e480c0bb39918d58f" translate="yes" xml:space="preserve">
          <source>Note that this works only when you &lt;code&gt;decode&lt;/code&gt;. You can set incompatible boolean objects (like &lt;a href=&quot;boolean&quot;&gt;boolean&lt;/a&gt;), but when you &lt;code&gt;encode&lt;/code&gt; a data structure with such boolean objects, you still need to enable &lt;code&gt;convert_blessed&lt;/code&gt; (and add a &lt;code&gt;TO_JSON&lt;/code&gt; method if necessary).</source>
          <target state="translated">これは、を &lt;code&gt;decode&lt;/code&gt; 場合にのみ機能することに注意してください。互換性のないブールオブジェクト（&lt;a href=&quot;boolean&quot;&gt;booleanなど&lt;/a&gt;）を設定できますが、そのようなブールオブジェクトを &lt;code&gt;encode&lt;/code&gt; てデータ構造をエンコードする場合は、 &lt;code&gt;convert_blessed&lt;/code&gt; を有効にする必要があります（必要に応じて &lt;code&gt;TO_JSON&lt;/code&gt; メソッドを追加します）。</target>
        </trans-unit>
        <trans-unit id="76667870087c43a89a0c134d31da84f873df4c85" translate="yes" xml:space="preserve">
          <source>Note that to create Bzip2 content, the module &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; must be installed.</source>
          <target state="translated">Bzip2コンテンツを作成するには、モジュール &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; がインストールされている必要があります。</target>
        </trans-unit>
        <trans-unit id="c112c0c0f309f422ad0d8ea094e2f892edb8359d" translate="yes" xml:space="preserve">
          <source>Note that to create Bzip2 content, the module &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; must be installed. A fatal error will be thrown if you attempt to create Bzip2 content when &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; is not available.</source>
          <target state="translated">Bzip2コンテンツを作成するには、モジュール &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; がインストールされている必要があります。 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; が使用できないときにBzip2コンテンツを作成しようとすると、致命的なエラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="91dea059c3c6adecb3e060a72157c015c80d8709" translate="yes" xml:space="preserve">
          <source>Note that to create LZMA content, the module &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; must be installed.</source>
          <target state="translated">LZMAコンテンツを作成するには、モジュール &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; がインストールされている必要があります。</target>
        </trans-unit>
        <trans-unit id="9d4a2616c449298e5f9b3c703f0555b52ba58730" translate="yes" xml:space="preserve">
          <source>Note that to create Lzma content, the module &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; must be installed. A fatal error will be thrown if you attempt to create Lzma content when &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; is not available.</source>
          <target state="translated">Lzmaコンテンツを作成するには、モジュール &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; がインストールされている必要があります。 &lt;code&gt;IO::Compress::Lzma&lt;/code&gt; が使用できないときにLzmaコンテンツを作成しようとすると、致命的なエラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="59026c8cb18df6e69670873afd609b7b5991b245" translate="yes" xml:space="preserve">
          <source>Note that to delete a breakpoint you use 'B'.</source>
          <target state="translated">ブレークポイントを削除するには、'B'を使用することに注意してください。</target>
        </trans-unit>
        <trans-unit id="ccec21a98f6b093bde7ead086f9b2aa6d9fa5cbe" translate="yes" xml:space="preserve">
          <source>Note that to terminate options processing still requires a double dash &lt;code&gt;--&lt;/code&gt; .</source>
          <target state="translated">オプションの処理を終了するには、引き続き2つのダッシュ &lt;code&gt;--&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="d940f3704d17dd3194fc775422b4ac6a56659d1f" translate="yes" xml:space="preserve">
          <source>Note that to terminate options processing still requires a double dash &lt;code&gt;--&lt;/code&gt;.</source>
          <target state="translated">オプション処理を終了するには、まだ二重ダッシュが必要であることに注意してください &lt;code&gt;--&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f1f1b6c5624a2d3ed9722ba6d811a877dbe016a" translate="yes" xml:space="preserve">
          <source>Note that turning this attribute to true won't suppress one or two kinds of complaints about rarely occurring unrecoverable errors.</source>
          <target state="translated">この属性をtrueにしても、稀に発生する回復不可能なエラーに対する1つや2つの種類の苦情を抑えることはできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="8c769b2bb4c9d14e0051897b1dc06f73914041f2" translate="yes" xml:space="preserve">
          <source>Note that under &lt;code&gt;/i&lt;/code&gt;, a few single characters match two or three other characters. This makes them variable length, and the 255 length applies to the maximum number of characters in the match. For example &lt;code&gt;qr/\N{LATIN SMALL LETTER SHARP S}/i&lt;/code&gt; matches the sequence &lt;code&gt;&quot;ss&quot;&lt;/code&gt;. Your lookbehind assertion could contain 127 Sharp S characters under &lt;code&gt;/i&lt;/code&gt;, but adding a 128th would generate a compilation error, as that could match 256 &lt;code&gt;&quot;s&quot;&lt;/code&gt; characters in a row.</source>
          <target state="translated">&lt;code&gt;/i&lt;/code&gt; の下では、いくつかの単一文字が他の2つまたは3つの文字と一致することに注意してください。これにより、それらは可変長になり、255の長さが一致する最大文字数に適用されます。たとえば、 &lt;code&gt;qr/\N{LATIN SMALL LETTER SHARP S}/i&lt;/code&gt; はシーケンス &lt;code&gt;&quot;ss&quot;&lt;/code&gt; と一致します。後読みアサーションには、 &lt;code&gt;/i&lt;/code&gt; の下に127個のSharpS文字が含まれる可能性がありますが、128番目を追加すると、256個の &lt;code&gt;&quot;s&quot;&lt;/code&gt; 文字が連続して一致する可能性があるため、コンパイルエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="0b40c66bbd4f3571d75ea521000a6cee32083010" translate="yes" xml:space="preserve">
          <source>Note that under Perls older than 5.8.0, &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt; depends on the &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen(3)&lt;/a&gt; C library function. On many Unix systems, &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen(3)&lt;/a&gt; is known to fail when file descriptors exceed a certain value, typically 255. If you need more file descriptors than that, consider using the &lt;a href=&quot;posix#open&quot;&gt;&lt;code&gt;POSIX::open&lt;/code&gt;&lt;/a&gt; function. For Perls 5.8.0 and later, PerlIO is (most often) the default.</source>
          <target state="translated">5.8.0より古いPerlでは、&lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt; &lt;code&gt;sysopen&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen（3）&lt;/a&gt; Cライブラリ関数に依存していることに注意してください。多くのUnixシステムでは、ファイル記述子が特定の値（通常は255）を超えると、&lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen（3）&lt;/a&gt;が失敗することが知られています。それよりも多くのファイル記述子が必要な場合は、&lt;a href=&quot;posix#open&quot;&gt; &lt;code&gt;POSIX::open&lt;/code&gt; &lt;/a&gt;関数の使用を検討してください。Perl 5.8.0以降では、PerlIOが（ほとんどの場合）デフォルトです。</target>
        </trans-unit>
        <trans-unit id="81f7379eb3bd6961a9d597915f1b15a614c4f1c6" translate="yes" xml:space="preserve">
          <source>Note that under Perls older than 5.8.0, Perl uses the standard C library's' &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen(3)&lt;/a&gt; to implement the &lt;code&gt;=&lt;/code&gt; functionality. On many Unix systems, &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen(3)&lt;/a&gt; fails when file descriptors exceed a certain value, typically 255. For Perls 5.8.0 and later, PerlIO is (most often) the default.</source>
          <target state="translated">5.8.0より古いPerlでは、Perlは標準Cライブラリの&lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen（3）&lt;/a&gt;を使用して &lt;code&gt;=&lt;/code&gt; 機能を実装することに注意してください。多くのUnixシステムでは、ファイル記述子が特定の値（通常は255）を超えると、&lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen（3）&lt;/a&gt;が失敗します。Perl5.8.0以降では、PerlIOが（ほとんどの場合）デフォルトです。</target>
        </trans-unit>
        <trans-unit id="6db90d2a3a43a0d1ae1c73a0ecadf4c50a061235" translate="yes" xml:space="preserve">
          <source>Note that under Perls older than 5.8.0, Perl uses the standard C library's' fdopen() to implement the &lt;code&gt;=&lt;/code&gt; functionality. On many Unix systems, fdopen() fails when file descriptors exceed a certain value, typically 255. For Perls 5.8.0 and later, PerlIO is (most often) the default.</source>
          <target state="translated">5.8.0より古いPerlでは、Perlは標準Cライブラリのfdopen（）を使用して &lt;code&gt;=&lt;/code&gt; 機能を実装していることに注意してください。多くのUnixシステムでは、ファイル記述子が特定の値（通常は255）を超えるとfdopen（）が失敗します。Perl5.8.0以降では、PerlIOが（ほとんどの場合）デフォルトです。</target>
        </trans-unit>
        <trans-unit id="ab1035410dccd2a93f4a5e17c32c7a15d00a2658" translate="yes" xml:space="preserve">
          <source>Note that under Win32</source>
          <target state="translated">Win32では、以下のことに注意してください。</target>
        </trans-unit>
        <trans-unit id="914bcfd8302ee9c0b531fac815eb7bd7d964c235" translate="yes" xml:space="preserve">
          <source>Note that under bigint, the result is truncated to an integer.</source>
          <target state="translated">bigintの場合、結果は整数に切り捨てられることに注意してください。</target>
        </trans-unit>
        <trans-unit id="57f113ec30505dad704cf4b4934d930e547970b7" translate="yes" xml:space="preserve">
          <source>Note that under some systems, like OS/2, there may be different flavors of Perl executables, some of which may support fork, some not. Try changing the name you call Perl by to &lt;code&gt;perl_&lt;/code&gt; , &lt;code&gt;perl__&lt;/code&gt; , and so on.</source>
          <target state="translated">OS / 2のような一部のシステムでは、Perl実行可能ファイルのフレーバーが異なる場合があり、フォークをサポートする場合とサポートしない場合があります。Perlの呼び出しに使用する名前を &lt;code&gt;perl_&lt;/code&gt; 、 &lt;code&gt;perl__&lt;/code&gt; などに変更してみてください。</target>
        </trans-unit>
        <trans-unit id="beba1d81b386ec1f5c90abc173f3ea4f03db2d8a" translate="yes" xml:space="preserve">
          <source>Note that under some systems, like OS/2, there may be different flavors of Perl executables, some of which may support fork, some not. Try changing the name you call Perl by to &lt;code&gt;perl_&lt;/code&gt;, &lt;code&gt;perl__&lt;/code&gt;, and so on.</source>
          <target state="translated">OS / 2のようないくつかのシステムでは、Perl実行可能ファイルのフレーバーが異なる場合があり、フォークをサポートするものとサポートしないものがあることに注意してください。Perlを呼び出す名前を &lt;code&gt;perl_&lt;/code&gt; 、 &lt;code&gt;perl__&lt;/code&gt; などに変更してみてください。</target>
        </trans-unit>
        <trans-unit id="6c3fb4d37b79c5b47a3b48e544166fc16ead2f30" translate="yes" xml:space="preserve">
          <source>Note that unfortunately none of the above constants are guaranteed to be available on a particular platform. To be on the safe side you can wrap the import in an eval like this:</source>
          <target state="translated">残念ながら、上記の定数が特定のプラットフォームで利用できることを保証するものではないことに注意してください。安全のために、インポートを次のように eval で囲むことができます。</target>
        </trans-unit>
        <trans-unit id="b70409449e4cf24aa93c5134b0fc7650b311f3ce" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;\s&lt;/code&gt; (and &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; ), &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt; always match the same characters, without regard to other factors, such as the active locale or whether the source string is in UTF-8 format.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; （および &lt;code&gt;\d&lt;/code&gt; と &lt;code&gt;\w&lt;/code&gt; ）とは異なり、 &lt;code&gt;\h&lt;/code&gt; と &lt;code&gt;\v&lt;/code&gt; は、アクティブなロケールやソース文字列がUTF-8形式かどうかなどの他の要因に関係なく、常に同じ文字に一致します。</target>
        </trans-unit>
        <trans-unit id="d708883d1ad8d31236c3f53f155ad26ec2c29df3" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;\s&lt;/code&gt; (and &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt;), &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt; always match the same characters, without regard to other factors, such as the active locale or whether the source string is in UTF-8 format.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; （および &lt;code&gt;\d&lt;/code&gt; と &lt;code&gt;\w&lt;/code&gt; ）とは異なり、 &lt;code&gt;\h&lt;/code&gt; と &lt;code&gt;\v&lt;/code&gt; は、アクティブなロケールやソース文字列がUTF-8形式であるかどうかなどの他の要因に関係なく、常に同じ文字に一致することに注意してください。</target>
        </trans-unit>
        <trans-unit id="772ce79a861dd3251a8090941fe7f7a3f1e9ae60" translate="yes" xml:space="preserve">
          <source>Note that unlike most other regex magic variables there is no single letter equivalent to &lt;code&gt;@{^CAPTURE}&lt;/code&gt;.</source>
          <target state="translated">他のほとんどの正規表現マジック変数とは異なり、 &lt;code&gt;@{^CAPTURE}&lt;/code&gt; 相当する1文字がないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="4e3b99648e034c07d6ccefb2454f1a213adb3a01" translate="yes" xml:space="preserve">
          <source>Note that version 1.00 of the Safe module supported a second optional parameter, MASK. That functionality has been withdrawn pending deeper consideration. Use the permit and deny methods described below.</source>
          <target state="translated">Safe モジュールのバージョン 1.00 では、2 つ目のオプションのパラメータ MASK がサポートされていることに注意してください。この機能は、より詳細な検討が行われている間は取り下げられています。以下に説明する許可および拒否の方法を使用してください。</target>
        </trans-unit>
        <trans-unit id="c573631a77e48c40f9d95496d1ab64657ba98bf8" translate="yes" xml:space="preserve">
          <source>Note that we now have to pass the cycling values as an array reference, since the &lt;code&gt;autotie&lt;/code&gt; mechanism passes &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; a list of arguments as a list (as in the Tie::Whatever example),</source>
          <target state="translated">以来、我々は今、配列リファレンスとしてサイクリング値を通過しなければならないことに留意されたい &lt;code&gt;autotie&lt;/code&gt; の機構が通過 &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; （TIE ::どのような例のように）リストとして引数のリストを、</target>
        </trans-unit>
        <trans-unit id="5b3c2527a47a822b83bab8f40e829ac7eb6aa7b2" translate="yes" xml:space="preserve">
          <source>Note that we now have to pass the cycling values as an array reference, since the &lt;code&gt;autotie&lt;/code&gt; mechanism passes &lt;code&gt;tie&lt;/code&gt; a list of arguments as a list (as in the Tie::Whatever example),</source>
          <target state="translated">以来、我々は今、配列リファレンスとしてサイクリング値を通過しなければならないことに留意されたい &lt;code&gt;autotie&lt;/code&gt; の機構が通過 &lt;code&gt;tie&lt;/code&gt; （TIE ::どのような例のように）リストとして引数のリストを、</target>
        </trans-unit>
        <trans-unit id="97433e963bcde523d9d0fce2f4cd1302dfe4a201" translate="yes" xml:space="preserve">
          <source>Note that when a form of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; that doesn't include all categories is specified, Perl ignores the excluded categories.</source>
          <target state="translated">すべてのカテゴリーを含まない &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 形式が指定されている場合、Perlは除外されたカテゴリーを無視することに注意してください。</target>
        </trans-unit>
        <trans-unit id="5b47f718523df526f757f6266d1dae38d1cc63ec" translate="yes" xml:space="preserve">
          <source>Note that when a form of &lt;code&gt;use locale&lt;/code&gt; that doesn't include all categories is specified, Perl ignores the excluded categories.</source>
          <target state="translated">すべてのカテゴリーを含まない &lt;code&gt;use locale&lt;/code&gt; 形式が指定されている場合、Perlは除外されたカテゴリーを無視することに注意してください。</target>
        </trans-unit>
        <trans-unit id="a50a1c7dfac9f6431a51ba8239dc629a049684b8" translate="yes" xml:space="preserve">
          <source>Note that when a module installs from CPAN to a core library directory rather than the site library directories, the user gains no protection from having installed it.</source>
          <target state="translated">モジュールがサイト・ライブラリ・ディレクトリではなく、CPANからコア・ライブラリ・ディレクトリにインストールされた場合、ユーザーはそれをインストールしたことによる保護を得られないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d5903fec6aa5f11cb69596fd7a3ca663ff0e5fa7" translate="yes" xml:space="preserve">
          <source>Note that when outputting to a file with streaming mode disabled (&lt;code&gt;Stream&lt;/code&gt; is 0), the output file must be seekable.</source>
          <target state="translated">ストリーミングモードが無効（ &lt;code&gt;Stream&lt;/code&gt; が0）のファイルに出力する場合、出力ファイルはシーク可能でなければならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="7344bc816db754cd590cf06e917e5573598a9b73" translate="yes" xml:space="preserve">
          <source>Note that when the zlib sources are built along with this module the &lt;code&gt;&lt;a href=&quot;../../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; flags (bits 24, 25 and 26) should be ignored.</source>
          <target state="translated">このモジュールとともにzlibソースがビルドされる場合、 &lt;code&gt;&lt;a href=&quot;../../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; フラグ（ビット24、25、および26）は無視する必要があります。</target>
        </trans-unit>
        <trans-unit id="726c87af26a5b86094bbbbcff91a0a7370ca0001" translate="yes" xml:space="preserve">
          <source>Note that when the zlib sources are built along with this module the &lt;code&gt;sprintf&lt;/code&gt; flags (bits 24, 25 and 26) should be ignored.</source>
          <target state="translated">このモジュールと一緒にzlibソースをビルドする場合、 &lt;code&gt;sprintf&lt;/code&gt; フラグ（ビット24、25、および26）は無視する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9c5df280c1345062d47399d4030c040fff592e61" translate="yes" xml:space="preserve">
          <source>Note that when there is only a section argument the URL will simply be a link to a section in the current document.</source>
          <target state="translated">セクションの引数だけがある場合、URLは単に現在のドキュメントのセクションへのリンクになることに注意してください。</target>
        </trans-unit>
        <trans-unit id="71260102fd6d68816796fad6d6c8b41eba351c69" translate="yes" xml:space="preserve">
          <source>Note that when using perl in the default build configuration on Win32 (specifically, when perl is built with PERL_IMPLICIT_SYS), each perl interpreter maintains its own copy of the environment and only the main interpreter will update the process environment seen by strftime.</source>
          <target state="translated">Win32のデフォルトのビルド設定でperlを使用している場合(具体的にはperlがPERL_IMPLICIT_SYSでビルドされている場合)は、各perlインタプリタが環境のコピーを保持しており、メインインタプリタのみがstrftimeで見たプロセス環境を更新することに注意してください。</target>
        </trans-unit>
        <trans-unit id="2effebabf11283b202bbac0c8af96deb9da5f75f" translate="yes" xml:space="preserve">
          <source>Note that when using threads and in Linux this is &lt;b&gt;not&lt;/b&gt; a good way to exit a thread because in Linux processes and threads are kind of the same thing (Note: while this is the situation in early 2003 there are projects under way to have threads with more POSIXly semantics in Linux). If you want not to return from a thread, detach the thread.</source>
          <target state="translated">Linuxでスレッドを使用する場合、これはスレッドを終了する良い方法では&lt;b&gt;ない&lt;/b&gt;ことに注意してください。Linuxのプロセスとスレッドは同じものです（注：これは2003年の初めの状況ですが、 LinuxでのPOSIXlyセマンティクスの増加）。スレッドから戻りたくない場合は、スレッドを切り離します。</target>
        </trans-unit>
        <trans-unit id="4736a205597baa102d5326de4253133a227c54d5" translate="yes" xml:space="preserve">
          <source>Note that when you pass in a filehandle, the compression argument is ignored, as all files are printed verbatim to your filehandle. If you wish to enable compression with filehandles, use an &lt;code&gt;IO::Zlib&lt;/code&gt; or &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; filehandle instead.</source>
          <target state="translated">ファイルハンドルを渡すと、すべてのファイルがそのままファイルハンドルに出力されるため、圧縮引数は無視されます。ファイルハンドルによる圧縮を有効にしたい場合は、代わりに &lt;code&gt;IO::Zlib&lt;/code&gt; または &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; ファイルハンドルを使用してください。</target>
        </trans-unit>
        <trans-unit id="3ec13b11833cba251c4e9511d82658d6fc77550f" translate="yes" xml:space="preserve">
          <source>Note that when you pass in a filehandle, the compression argument is ignored, as all files are printed verbatim to your filehandle. If you wish to enable compression with filehandles, use an &lt;code&gt;IO::Zlib&lt;/code&gt;, &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; or &lt;code&gt;IO::Compress::Xz&lt;/code&gt; filehandle instead.</source>
          <target state="translated">ファイルハンドルを渡すと、すべてのファイルがファイルハンドルに逐語的に出力されるため、圧縮引数は無視されることに注意してください。ファイルハンドルを使用した圧縮を有効にする場合は、代わりに &lt;code&gt;IO::Zlib&lt;/code&gt; 、 &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; または &lt;code&gt;IO::Compress::Xz&lt;/code&gt; ファイルハンドルを使用してください。</target>
        </trans-unit>
        <trans-unit id="870efa0c38496f8567ab5707b290598c28081f5a" translate="yes" xml:space="preserve">
          <source>Note that where possible, values should be saved in the context struct rather than on the save stack; it's much faster that way.</source>
          <target state="translated">可能であれば、値は保存スタックではなくコンテキスト構造体に保存すべきであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="bbf20737dd41f077e46c31d590a5ed13707c1390" translate="yes" xml:space="preserve">
          <source>Note that whether &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; gets restarted after signals (say, SIGALRM) is implementation-dependent. See also &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">シグナル（たとえば、SIGALRM）の後に&lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt;が再起動されるかどうかは、実装に依存することに注意してください。&lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt;の移植性に関する注記については、&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="fec466d7589681ffa02822a2ed4bde47bc9a77f7" translate="yes" xml:space="preserve">
          <source>Note that whether &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; gets restarted after signals (say, SIGALRM) is implementation-dependent. See also &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">シグナル（たとえば、SIGALRM）の後に &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; が再起動されるかどうかは、実装に依存することに注意してください。 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; の移植性に関する注意事項については、&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="948671b067e6b6895231193e86d7353898979d1b" translate="yes" xml:space="preserve">
          <source>Note that whether &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; gets restarted after signals (say, SIGALRM) is implementation-dependent. See also &lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt; for notes on the portability of &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">シグナル（たとえば、SIGALRM）の後に &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; が再起動されるかどうかは、実装に依存することに注意してください。 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; の移植性に関する注意事項については、&lt;a href=&quot;../perlport&quot;&gt;perlport&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="6ffc7e69e46e535688eedc16caabf4a74055bdca" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;prove&lt;/code&gt; accepts a list of tests (or things to be tested), &lt;code&gt;new&lt;/code&gt; has a fairly rich set of arguments. You'll probably want to read over this code carefully to see how all of them are being used.</source>
          <target state="translated">Prove はテスト（またはテストするもの）のリストを受け入れますが、 &lt;code&gt;new&lt;/code&gt; にはかなり豊富な引数のセットがある &lt;code&gt;prove&lt;/code&gt; 注意してください。このコードを注意深く読んで、すべてがどのように使用されているかを確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="50e7deab8f4fd86f8154084a7e3b56909e616473" translate="yes" xml:space="preserve">
          <source>Note that while the above category system is presently a strict hierarchy, this should not be assumed.</source>
          <target state="translated">上記のカテゴリシステムは現在のところ厳密な階層構造であるが、これを前提にしてはならないことに注意してほしい。</target>
        </trans-unit>
        <trans-unit id="bc9931d84d19856544f694976f9d6846875a28cb" translate="yes" xml:space="preserve">
          <source>Note that while threads themselves are separate execution threads and Perl data is thread-private unless explicitly shared, the threads can affect process-scope state, affecting all the threads.</source>
          <target state="translated">スレッド自体は別個の実行スレッドであり、Perl のデータは明示的に共有されない限りスレッド・プライベートですが、スレッドはプロセス・スコープの状態に影響を与え、すべてのスレッドに影響を与えることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1aeee605f9778048bf8180ea5497c85eb816a43f" translate="yes" xml:space="preserve">
          <source>Note that while we obtained this value using a nice little script, there is no simple way to</source>
          <target state="translated">小さなスクリプトを使ってこの値を取得していますが、簡単な方法はありません。</target>
        </trans-unit>
        <trans-unit id="91f5f2f1e7150921d4bad701418dc42005b9e8df" translate="yes" xml:space="preserve">
          <source>Note that with a parenthesised list, &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; can be used as a dummy placeholder, for example to skip assignment of initial values:</source>
          <target state="translated">括弧で囲まれたリストを使用すると、&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;をダミーのプレースホルダーとして使用できます。たとえば、初期値の割り当てをスキップできます。</target>
        </trans-unit>
        <trans-unit id="7977096f1b31f6699d5f208fb012da3a5261f7ca" translate="yes" xml:space="preserve">
          <source>Note that with a parenthesised list, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder, for example to skip assignment of initial values:</source>
          <target state="translated">括弧で囲まれたリストでは、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; をダミーのプレースホルダーとして使用できることに注意してください。たとえば、初期値の割り当てをスキップします。</target>
        </trans-unit>
        <trans-unit id="f05ed1d19fb4f3d163934a654b623969a521af79" translate="yes" xml:space="preserve">
          <source>Note that with a parenthesised list, &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; can be used as a dummy placeholder, for example to skip assignment of initial values:</source>
          <target state="translated">括弧で囲まれたリストでは、 &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; をダミーのプレースホルダーとして使用できることに注意してください。たとえば、初期値の割り当てをスキップします。</target>
        </trans-unit>
        <trans-unit id="f837139e0f9184e4fee4005308a9ebc6c5173a19" translate="yes" xml:space="preserve">
          <source>Note that with all the above cases, you can determine which type of &quot;=over&quot; ... &quot;=back&quot; you have, by examining the first (non-&quot;=cut&quot;, non-&quot;=pod&quot;) Pod paragraph after the &quot;=over&quot; command.</source>
          <target state="translated">上記のすべてのケースで、&quot;=over&quot; ...&quot;=back &quot;がどのタイプの&quot;=over&quot; ...&quot;=back &quot;であるかは、&quot;=over &quot;コマンドの後の最初の(非&quot;=cut&quot;、&quot;=pod &quot;ではない)Pod段落を調べることで判断できることに注意してください。back &quot;がどのタイプの&quot;=over &quot;かは、&quot;=over &quot;コマンドの後の最初の(&quot;=cut &quot;ではない、&quot;=pod &quot;ではない)Podの段落を調べればわかります。</target>
        </trans-unit>
        <trans-unit id="47d723b6fa427f34bf483595a539dcd989378967" translate="yes" xml:space="preserve">
          <source>Note that write is</source>
          <target state="translated">書き込みは</target>
        </trans-unit>
        <trans-unit id="83605b35f7f66a38c8e887a3f52c350d6d00fd1c" translate="yes" xml:space="preserve">
          <source>Note that you</source>
          <target state="translated">と注意してください。</target>
        </trans-unit>
        <trans-unit id="f571df233f4fa852ab6d69ef3a354636c953afea" translate="yes" xml:space="preserve">
          <source>Note that you &lt;b&gt;must&lt;/b&gt; quote the version when writing an alpha Decimal version. The stringified form of Decimal versions will always be the same string that was used to initialize the version object.</source>
          <target state="translated">アルファ10進バージョンを作成するときは、バージョンを引用する&lt;b&gt;必要が&lt;/b&gt;あることに注意してください。10進バージョンの文字列化された形式は、常にバージョンオブジェクトの初期化に使用されたものと同じ文字列になります。</target>
        </trans-unit>
        <trans-unit id="4c6cd8d5f09bd8fe8bd4f6cd6ec9d1cc03592811" translate="yes" xml:space="preserve">
          <source>Note that you always have to rethrow an exception that has been caught. Using these macros, it is not possible to just catch the exception and ignore it. If you have to ignore the exception, you have to use the &lt;code&gt;call_*&lt;/code&gt; function.</source>
          <target state="translated">キャッチされた例外は常に再スローする必要があることに注意してください。これらのマクロを使用すると、例外をキャッチして無視することはできません。例外を無視する必要がある場合は、 &lt;code&gt;call_*&lt;/code&gt; 関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="294ab6e75ddb8b55c12bca78ca4c1964234fee2f" translate="yes" xml:space="preserve">
          <source>Note that you can also apply two or more of the same type of filter in a single &lt;code&gt;FILTER_ONLY&lt;/code&gt; . For example, here's a simple macro-preprocessor that is only applied within regexes, with a final debugging pass that prints the resulting source code:</source>
          <target state="translated">1つの &lt;code&gt;FILTER_ONLY&lt;/code&gt; で同じタイプのフィルタを2つ以上適用することもできます。たとえば、次は、正規表現内でのみ適用される単純なマクロプリプロセッサであり、最終的なデバッグパスで結果のソースコードを出力します。</target>
        </trans-unit>
        <trans-unit id="2ed5dd8db2d6301ae073b216ad36ce2358ae0947" translate="yes" xml:space="preserve">
          <source>Note that you can also apply two or more of the same type of filter in a single &lt;code&gt;FILTER_ONLY&lt;/code&gt;. For example, here's a simple macro-preprocessor that is only applied within regexes, with a final debugging pass that prints the resulting source code:</source>
          <target state="translated">1つの &lt;code&gt;FILTER_ONLY&lt;/code&gt; で同じタイプのフィルターを2つ以上適用することもできることに注意してください。たとえば、正規表現内でのみ適用される単純なマクロプリプロセッサと、結果のソースコードを出力する最終的なデバッグパスを次に示します。</target>
        </trans-unit>
        <trans-unit id="2c7b682995e33f0fbc55867b39c415016eb6e0ab" translate="yes" xml:space="preserve">
          <source>Note that you can also call &lt;code&gt;batch_convert&lt;/code&gt; as a class method, like so:</source>
          <target state="translated">&lt;code&gt;batch_convert&lt;/code&gt; ように、クラスメソッドとしてbatch_convertを呼び出すこともできます。</target>
        </trans-unit>
        <trans-unit id="fd91cd131ba58a9a28d1ab6ce3c7b99f825d3515" translate="yes" xml:space="preserve">
          <source>Note that you can also use:</source>
          <target state="translated">も使えることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7f681263fb98ec8c6eb8d4798ad8027fd4826097" translate="yes" xml:space="preserve">
          <source>Note that you can currently &lt;b&gt;not&lt;/b&gt; pass a &lt;code&gt;gzip&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Zlib&lt;/code&gt; , a &lt;code&gt;bzip2&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; , nor a string containing the full archive information (either compressed or uncompressed). These are worth while features, but not currently implemented. See the &lt;code&gt;TODO&lt;/code&gt; section.</source>
          <target state="translated">あなたが現在できることを注意&lt;b&gt;しませ&lt;/b&gt;渡す &lt;code&gt;gzip&lt;/code&gt; で開かれていない圧縮ファイルハンドル、 &lt;code&gt;IO::Zlib&lt;/code&gt; 、 &lt;code&gt;bzip2&lt;/code&gt; で開かれていない圧縮ファイルハンドル、 &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; 、また完全アーカイブ情報を含む文字列（どちらか圧縮または非圧縮）。これらは機能としては価値がありますが、現在実装されていません。 &lt;code&gt;TODO&lt;/code&gt; セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="36599b3f8142ec45ea2057810c7d1951232a084e" translate="yes" xml:space="preserve">
          <source>Note that you can currently &lt;b&gt;not&lt;/b&gt; pass a &lt;code&gt;gzip&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Zlib&lt;/code&gt;, a &lt;code&gt;bzip2&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt;, a &lt;code&gt;xz&lt;/code&gt; compressed filehandle, which is not opened with &lt;code&gt;IO::Uncompress::UnXz&lt;/code&gt;, nor a string containing the full archive information (either compressed or uncompressed). These are worth while features, but not currently implemented. See the &lt;code&gt;TODO&lt;/code&gt; section.</source>
          <target state="translated">現在、 &lt;code&gt;IO::Zlib&lt;/code&gt; で開かれていない &lt;code&gt;gzip&lt;/code&gt; 圧縮ファイルハンドル、 &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; で開かれていない &lt;code&gt;bzip2&lt;/code&gt; 圧縮ファイルハンドル、で開かれていない &lt;code&gt;xz&lt;/code&gt; 圧縮ファイルハンドルを渡すことはでき&lt;b&gt;ない&lt;/b&gt;ことに注意してください。 &lt;code&gt;IO::Uncompress::UnXz&lt;/code&gt; 、または完全なアーカイブ情報（圧縮または非圧縮）を含む文字列。これらは機能として価値がありますが、現在は実装されていません。 &lt;code&gt;TODO&lt;/code&gt; セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="80d20f2cbb1dd523835c53fe8971ba143f49fe81" translate="yes" xml:space="preserve">
          <source>Note that you can define your own properties; see &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;&quot;User-Defined Character Properties&quot; in perlunicode&lt;/a&gt;.</source>
          <target state="translated">独自のプロパティを定義できることに注意してください。&lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;perlunicodeの「ユーザー定義の文字プロパティ」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b5e3d8e2902a442515aac1df82a9b27598246cd6" translate="yes" xml:space="preserve">
          <source>Note that you can define your own properties; see &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;User-Defined Character Properties in perlunicode&lt;/a&gt;.</source>
          <target state="translated">独自のプロパティを定義できることに注意してください。&lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;perlunicodeのユーザー定義の文字プロパティを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="78e5ead015db87b26d2638e6d6d6c409fabb1756" translate="yes" xml:space="preserve">
          <source>Note that you can distinguish URL-links from anything else by the fact that they match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A\w+:[^:\s]\S*\z/&lt;/a&gt;&lt;/code&gt;. So &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.com&quot;&gt;http://www.perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; is a URL, but &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; isn't.</source>
          <target state="translated">URLリンクは、 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A\w+:[^:\s]\S*\z/&lt;/a&gt;&lt;/code&gt; と一致するという事実により、他のものと区別できることに注意してください。したがって、 &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://www.perl.com&quot;&gt;http://www.perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt; はURLですが、 &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; はそうではありません。</target>
        </trans-unit>
        <trans-unit id="64a115a0f7c10604758c941480143a80f74b2845" translate="yes" xml:space="preserve">
          <source>Note that you can distinguish URL-links from anything else by the fact that they match &lt;code&gt;m/\A\w+:[^:\s]\S*\z/&lt;/code&gt;. So &lt;code&gt;L&amp;lt;http://www.perl.com&amp;gt;&lt;/code&gt; is a URL, but &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; isn't.</source>
          <target state="translated">URLリンクは &lt;code&gt;m/\A\w+:[^:\s]\S*\z/&lt;/code&gt; と一致するため、他のものと区別できることに注意してください。したがって、 &lt;code&gt;L&amp;lt;http://www.perl.com&amp;gt;&lt;/code&gt; はURLですが、 &lt;code&gt;L&amp;lt;HTTP::Response&amp;gt;&lt;/code&gt; はURLではありません。</target>
        </trans-unit>
        <trans-unit id="b5601b7465138e046c297f9bd7f032a15e613deb" translate="yes" xml:space="preserve">
          <source>Note that you can modify the encoding of a file opened by File::Temp also by using &lt;code&gt;binmode()&lt;/code&gt;.</source>
          <target state="translated">file :: Tempによって開かれたファイルのエンコーディングは、 &lt;code&gt;binmode()&lt;/code&gt; を使用して変更できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7fe488ce16efed40af87572587352aab8acda941" translate="yes" xml:space="preserve">
          <source>Note that you can modify the encoding of a file opened by File::Temp also by using C</source>
          <target state="translated">File::Temp で開いたファイルのエンコーディングを変更するには、C</target>
        </trans-unit>
        <trans-unit id="11456d05bc1241402ca1d0ee0660f0d072ab6bd4" translate="yes" xml:space="preserve">
          <source>Note that you can use the &lt;code&gt;ls&lt;/code&gt; command to get this path listed.</source>
          <target state="translated">&lt;code&gt;ls&lt;/code&gt; コマンドを使用して、このパスを一覧表示できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a185692d5c427a3444515426bf12dadcf9d46376" translate="yes" xml:space="preserve">
          <source>Note that you can use this to nest &quot;todo&quot; tests</source>
          <target state="translated">これを使って &quot;todo&quot; テストを入れ子にすることができます。</target>
        </trans-unit>
        <trans-unit id="47332c504fbc5ef10c78203997d49e50906b8018" translate="yes" xml:space="preserve">
          <source>Note that you can't reliably block or unblock a signal from its own signal handler if you're using safe signals. Other signals can be blocked or unblocked reliably.</source>
          <target state="translated">安全なシグナルを使用している場合は、それ自身のシグナルハンドラからのシグナルを確実にブロックしたり、ブロックを解除したりすることはできないことに注意してください。他のシグナルは確実にブロックしたり、ブロックを解除することができます。</target>
        </trans-unit>
        <trans-unit id="6eb3e27a2f3b6ca32cee54a3ce38dc4afb062aed" translate="yes" xml:space="preserve">
          <source>Note that you cannot do (de)composition and casing based solely on the</source>
          <target state="translated">のみを基準にした(脱)構成やケーシングはできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="87645c57d8e0d5210e8d3327ae60dc3fe4c988b7" translate="yes" xml:space="preserve">
          <source>Note that you cannot explicitly unlock a variable; you can only wait for the lock to go out of scope. This is most easily accomplished by locking the variable inside a block.</source>
          <target state="translated">変数のロックを明示的に解除することはできないことに注意してください。これは、ブロック内で変数をロックすることで最も簡単に実現できます。</target>
        </trans-unit>
        <trans-unit id="34d896b03c45dc20f0fdc261eccf832e601b1f41" translate="yes" xml:space="preserve">
          <source>Note that you cannot test for &quot;&lt;code&gt;NaN&lt;/code&gt; -ness&quot; with</source>
          <target state="translated">「 &lt;code&gt;NaN&lt;/code&gt; -ness」については、</target>
        </trans-unit>
        <trans-unit id="46d548823c2cd0fd3c7dcc027abf5e4fd2f7c713" translate="yes" xml:space="preserve">
          <source>Note that you cannot test for &quot;&lt;code&gt;NaN&lt;/code&gt;-ness&quot; with</source>
          <target state="translated">「 &lt;code&gt;NaN&lt;/code&gt; らしさ」をテストすることはできないことに注意してください</target>
        </trans-unit>
        <trans-unit id="5b60fe993473449a8705a6ef4eab6f9f10003061" translate="yes" xml:space="preserve">
          <source>Note that you cannot use tags in @EXPORT or @EXPORT_OK.</source>
          <target state="translated">EXPORTや@EXPORT_OKにタグを使用することはできませんのでご注意ください。</target>
        </trans-unit>
        <trans-unit id="c1c43451d9784c36057c8528c7269957014b039f" translate="yes" xml:space="preserve">
          <source>Note that you do not have to use wildcards. You can specify explicitly which subdirectories to run tests in:</source>
          <target state="translated">ワイルドカードを使用する必要はないことに注意してください。テストを実行するサブディレクトリを明示的に指定することができます。</target>
        </trans-unit>
        <trans-unit id="cfbfbe6c89dd9e56f5bfaf163b06f453c16310bb" translate="yes" xml:space="preserve">
          <source>Note that you don't (re-)specify the method name. It forces you to always use the same method name as the method you started in.</source>
          <target state="translated">メソッド名を(再)指定しないことに注意してください。これは、開始したメソッドと同じメソッド名を常に使用することを強制します。</target>
        </trans-unit>
        <trans-unit id="1110cd59b64cb9b7410432e108a9ed2c0c79bda1" translate="yes" xml:space="preserve">
          <source>Note that you have can't handle &lt;a href=&quot;#readline-EXPR&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; errors that way with the &lt;code&gt;ARGV&lt;/code&gt; filehandle. In that case, you have to open each element of &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt; yourself since &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; handles &lt;code&gt;ARGV&lt;/code&gt; differently.</source>
          <target state="translated">&lt;code&gt;ARGV&lt;/code&gt; ファイルハンドルでは&lt;a href=&quot;#readline-EXPR&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt;エラーをそのように処理できないことに注意してください。その場合、あなたは、それぞれの要素開く必要があり&lt;a href=&quot;perlvar#%40ARGV&quot;&gt; &lt;code&gt;@ARGV&lt;/code&gt; &lt;/a&gt;ので、自分で&lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof&lt;/code&gt; &lt;/a&gt;ハンドルが &lt;code&gt;ARGV&lt;/code&gt; 違いました。</target>
        </trans-unit>
        <trans-unit id="765ef1a0a25cf74eb1b9c1fc6e25a760175b0c75" translate="yes" xml:space="preserve">
          <source>Note that you have can't handle &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; errors that way with the &lt;code&gt;ARGV&lt;/code&gt; filehandle. In that case, you have to open each element of &lt;code&gt;@ARGV&lt;/code&gt; yourself since &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; handles &lt;code&gt;ARGV&lt;/code&gt; differently.</source>
          <target state="translated">&lt;code&gt;ARGV&lt;/code&gt; ファイルハンドルでは、 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; エラーをそのように処理できないことに注意してください。その場合、あなたは、それぞれの要素開く必要があり &lt;code&gt;@ARGV&lt;/code&gt; ので、自分で &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; ハンドルが &lt;code&gt;ARGV&lt;/code&gt; 違いました。</target>
        </trans-unit>
        <trans-unit id="1d0c63b615c2a51e338a797bd40525e8af9c8f78" translate="yes" xml:space="preserve">
          <source>Note that you have can't handle &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; errors that way with the &lt;code&gt;ARGV&lt;/code&gt; filehandle. In that case, you have to open each element of &lt;code&gt;@ARGV&lt;/code&gt; yourself since &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; handles &lt;code&gt;ARGV&lt;/code&gt; differently.</source>
          <target state="translated">&lt;code&gt;ARGV&lt;/code&gt; ファイルハンドルでは、 &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; エラーをそのように処理できないことに注意してください。その場合、あなたは、それぞれの要素開く必要があり &lt;code&gt;@ARGV&lt;/code&gt; ので、自分で &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; ハンドルが &lt;code&gt;ARGV&lt;/code&gt; 違いました。</target>
        </trans-unit>
        <trans-unit id="ef1cce341436113e5004762f8ac2a05ec7a6cdad" translate="yes" xml:space="preserve">
          <source>Note that you may have things stored in a lexicon besides just phrases for output: for example, if your program takes input from the keyboard, asking a &quot;(Y/N)&quot; question, you probably need to know what the equivalent of &quot;Y[es]/N[o]&quot; is in whatever language. You probably also need to know what the equivalents of the answers &quot;y&quot; and &quot;n&quot; are. You can store that information in the lexicon (say, under the keys &quot;~answer_y&quot; and &quot;~answer_n&quot;, and the long forms as &quot;~answer_yes&quot; and &quot;~answer_no&quot;, where &quot;~&quot; is just an ad-hoc character meant to indicate to programmers/translators that these are not phrases for output).</source>
          <target state="translated">例えば、あなたのプログラムがキーボードからの入力を受けて &quot;(Y/N)&quot; の質問をする場合、&quot;Y[es]/N[o]がどの言語で何に相当するかを知っておく必要があるでしょう。また、答えの &quot;y&quot; と &quot;n&quot; の等価値が何であるかを知る必要があるでしょう。その情報をレキシコンに保存することができます (例えば、キー &quot;~answer_y&quot; と &quot;~answer_n&quot; の下に、長い形式の &quot;~answer_yes&quot; と &quot;~answer_no&quot; の下に、&quot;~&quot; はプログラマー/翻訳者が出力用のフレーズではないことを示すためのその場しのぎの文字です)。</target>
        </trans-unit>
        <trans-unit id="f229bb516b77586e7a9a248bf3e0f062f311444b" translate="yes" xml:space="preserve">
          <source>Note that you may mix directories and (non-directory) files in the list of directories to be searched by the &lt;code&gt;wanted()&lt;/code&gt; function.</source>
          <target state="translated">Wanted &lt;code&gt;wanted()&lt;/code&gt; 関数で検索するディレクトリのリストに、ディレクトリと（非ディレクトリ）ファイルを混在させることができます。</target>
        </trans-unit>
        <trans-unit id="4cfd4a087008bc37d07992fd270addb262fb108e" translate="yes" xml:space="preserve">
          <source>Note that you might find it useful in some cases to override the &lt;code&gt;maketext&lt;/code&gt; method with an &quot;after method&quot;, if you want to translate encodings, or even scripts:</source>
          <target state="translated">エンコーディングやスクリプトを翻訳したい場合は、 &lt;code&gt;maketext&lt;/code&gt; メソッドを「afterメソッド」でオーバーライドすると便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="253cba6289667637c7fd05a73ad1fdc58ca96c20" translate="yes" xml:space="preserve">
          <source>Note that you must specify a Unix path for $new_name, since per tar standard, all files in the archive must be Unix paths.</source>
          <target state="translated">tar 標準では、アーカイブ内のすべてのファイルは Unix パスでなければならないので、$new_name には Unix パスを指定しなければならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="af5d3ffce4bc0322633d2e85550797429ad732a8" translate="yes" xml:space="preserve">
          <source>Note that you need to install the Module::Signature module to perform this operation.</source>
          <target state="translated">この操作を行うには、Module::Signature モジュールをインストールする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="349c9f55c28f43dcb8274d29802632751096cca6" translate="yes" xml:space="preserve">
          <source>Note that you should load this module</source>
          <target state="translated">このモジュールをロードする必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="50670d23899cdfce7f241f0aebbebf124020da97" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; traps otherwise-fatal errors, it is useful for determining whether a particular feature (such as &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;) is implemented. It is also Perl's exception-trapping mechanism, where the die operator is used to raise exceptions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; は致命的なエラーをトラップするため、特定の機能（ &lt;code&gt;&lt;a href=&quot;socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; など）が実装されているかどうかを判断するのに役立ちます。これはPerlの例外トラッピングメカニズムでもあり、die演算子を使用して例外を発生させます。</target>
        </trans-unit>
        <trans-unit id="b4ffd3921a8026663ffc09712b83a83c559f1527" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; traps otherwise-fatal errors, it is useful for determining whether a particular feature (such as &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;) is implemented. It is also Perl's exception-trapping mechanism, where the die operator is used to raise exceptions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; は致命的なエラーをトラップするため、特定の機能（ &lt;code&gt;&lt;a href=&quot;functions/socket&quot;&gt;socket&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; など）が実装されているかどうかを判断するのに役立ちます。これはPerlの例外トラッピングメカニズムでもあり、die演算子を使用して例外を発生させます。</target>
        </trans-unit>
        <trans-unit id="891df8b540bc28be318d138e0d3e28e333361aa1" translate="yes" xml:space="preserve">
          <source>Note that, because &lt;code&gt;eval&lt;/code&gt; traps otherwise-fatal errors, it is useful for determining whether a particular feature (such as &lt;a href=&quot;#socket-SOCKET%2CDOMAIN%2CTYPE%2CPROTOCOL&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#symlink-OLDFILE%2CNEWFILE&quot;&gt;&lt;code&gt;symlink&lt;/code&gt;&lt;/a&gt;) is implemented. It is also Perl's exception-trapping mechanism, where the &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; operator is used to raise exceptions.</source>
          <target state="translated">&lt;code&gt;eval&lt;/code&gt; は致命的なエラーをトラップするため、特定の機能（&lt;a href=&quot;#socket-SOCKET%2CDOMAIN%2CTYPE%2CPROTOCOL&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;#symlink-OLDFILE%2CNEWFILE&quot;&gt; &lt;code&gt;symlink&lt;/code&gt; &lt;/a&gt;）が実装されているかどうかを判断するのに役立ちます。これはPerlの例外トラップメカニズムでもあり、&lt;a href=&quot;#die-LIST&quot;&gt; &lt;code&gt;die&lt;/code&gt; &lt;/a&gt;演算子を使用して例外を発生させます。</target>
        </trans-unit>
        <trans-unit id="5209cab95dd7fa5e49fd362ada61a9529eae4cb7" translate="yes" xml:space="preserve">
          <source>Note that, because the &lt;code&gt;Cycle&lt;/code&gt; attribute receives its arguments in the &lt;code&gt;$data&lt;/code&gt; variable, if the attribute is given a list of arguments, &lt;code&gt;$data&lt;/code&gt; will consist of a single array reference; otherwise, it will consist of the single argument directly. Since Tie::Cycle requires its cycling values to be passed as an array reference, this means that we need to wrap non-array-reference arguments in an array constructor:</source>
          <target state="translated">&lt;code&gt;Cycle&lt;/code&gt; 属性は &lt;code&gt;$data&lt;/code&gt; 変数で引数を受け取るため、属性に引数のリストが指定されている場合、 &lt;code&gt;$data&lt;/code&gt; は単一の配列参照で構成されます。それ以外の場合は、単一の引数で直接構成されます。Tie :: Cycleでは、その循環値を配列参照として渡す必要があるため、配列参照以外の引数を配列コンストラクターでラップする必要があります。</target>
        </trans-unit>
        <trans-unit id="634d31438b7b96505dfbaf20bfb6d24a32edebe9" translate="yes" xml:space="preserve">
          <source>Note that, for historical compatibility, you can also use &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; instead of &lt;code&gt;NEXT::DISTINCT&lt;/code&gt; .</source>
          <target state="translated">過去の互換性のために、 &lt;code&gt;NEXT::DISTINCT&lt;/code&gt; 代わりにNEXT :: &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; 使用することもできます。</target>
        </trans-unit>
        <trans-unit id="efb52146528e00d45c6657da7bafa7f9366f782d" translate="yes" xml:space="preserve">
          <source>Note that, for historical compatibility, you can also use &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; instead of &lt;code&gt;NEXT::DISTINCT&lt;/code&gt;.</source>
          <target state="translated">履歴の互換性のために、 &lt;code&gt;NEXT::DISTINCT&lt;/code&gt; 代わりにNEXT :: &lt;code&gt;NEXT::UNSEEN&lt;/code&gt; 使用することもできることに注意してください。</target>
        </trans-unit>
        <trans-unit id="cc33ef9021f54e035b56392220cb3acd2d2873be" translate="yes" xml:space="preserve">
          <source>Note that, if you have options &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; , and auto_abbrev enabled, possible arguments and option settings are:</source>
          <target state="translated">オプション &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;l&lt;/code&gt; と &lt;code&gt;all&lt;/code&gt; 、およびauto_abbrevを有効にしている場合、可能な引数とオプション設定は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="49deca6d624d23372bddba3920f15c27d6789299" translate="yes" xml:space="preserve">
          <source>Note that, if you have options &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt;, and auto_abbrev enabled, possible arguments and option settings are:</source>
          <target state="translated">オプション &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;l&lt;/code&gt; 、 &lt;code&gt;all&lt;/code&gt; 、およびauto_abbrevが有効になっている場合、可能な引数とオプション設定は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="35db5062a8071a77478be258b823dc93b2df8d08" translate="yes" xml:space="preserve">
          <source>Note that, if you wish to run Configure non-interactively (see the INSTALL document for details), to have it select the correct hint file, you'll need to provide the argument -Dhintfile=riscos on the Configure command-line.</source>
          <target state="translated">Configure を非対話的に実行したい場合 (詳細は INSTALL ドキュメントを参照)、正しいヒントファイルを選択させるには、Configure コマンドラインで -Dhintfile=riscos という引数を指定する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8223fdc89d45104614b40e3adc04b113ea1e11a1" translate="yes" xml:space="preserve">
          <source>Note that, if your code is running under the recommended &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict
vars&lt;/code&gt; pragma, you will need to declare these package variables with &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">コードが推奨 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict vars&lt;/code&gt; プラグマで実行されている場合は、これらのパッケージ変数を次のように宣言する必要があり &lt;code&gt;&lt;a href=&quot;../functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="399039fd0a4c09c727bec9d6e24cc011d4967d80" translate="yes" xml:space="preserve">
          <source>Note that, if your code is running under the recommended &lt;code&gt;use strict vars&lt;/code&gt; pragma, you will need to declare these package variables with &lt;code&gt;our&lt;/code&gt;:</source>
          <target state="translated">コードが推奨される &lt;code&gt;use strict vars&lt;/code&gt; プラグマの下で実行されている場合は、これらのパッケージ変数を次のように宣言する必要があることに注意して &lt;code&gt;our&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b910d090e427c58d2dd17debf4a1b8bec005d534" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt; , failed &lt;code&gt;when&lt;/code&gt; statements always evaluate to an empty list.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; および &lt;code&gt;unless&lt;/code&gt; とは異なり &lt;code&gt;when&lt;/code&gt; ステートメントが常に空のリストに評価される場合は失敗することに注意してください。</target>
        </trans-unit>
        <trans-unit id="b41c93e43651e0e37405584834ec3d27a0bc44f8" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt;, failed &lt;code&gt;when&lt;/code&gt; statements always evaluate to an empty list.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; および &lt;code&gt;unless&lt;/code&gt; とは異なり &lt;code&gt;when&lt;/code&gt; ステートメントが常に空のリストと評価される場合は失敗することに注意してください。</target>
        </trans-unit>
        <trans-unit id="afd6a1e156c7625206e1247c798d73aecaea5a68" translate="yes" xml:space="preserve">
          <source>Note that, within braces, every character starting with the first non-hexadecimal up to the ending brace is ignored.</source>
          <target state="translated">中括弧内では、最初の非16進数で始まる文字から最後の中括弧までのすべての文字が無視されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="903c4c2bcdceef7b085f257005c8eb256d0f0ea7" translate="yes" xml:space="preserve">
          <source>Note that, within braces, every character starting with the first non-octal up to the ending brace is ignored.</source>
          <target state="translated">中括弧の中では、最初の非オクタルで始まる文字から最後の中括弧までのすべての文字は無視されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7888ceb1fb70ed4eb88480b31893c674d725b49f" translate="yes" xml:space="preserve">
          <source>Note the</source>
          <target state="translated">に注意してください。</target>
        </trans-unit>
        <trans-unit id="b803d84dee50e438348a270e8179c619e96897b0" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;!&lt;/code&gt; after &lt;code&gt;l&lt;/code&gt; : We want to make sure that we pack a long integer as it is compiled by our C compiler. And even now, it will only work for the platforms where the compiler aligns things as above. And somebody somewhere has a platform where it doesn't. [Probably a Cray, where &lt;code&gt;short&lt;/code&gt; s, &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;s and &lt;code&gt;long&lt;/code&gt; s are all 8 bytes. :-)]</source>
          <target state="translated">注意してください &lt;code&gt;!&lt;/code&gt; 後 &lt;code&gt;l&lt;/code&gt; ：Cコンパイラでコンパイルされる長整数をパックすることを確認します。そして今でも、コンパイラが上記のように調整するプラットフォームでのみ機能します。そして、どこかに誰かがそれを持っていないプラットフォームを持っています。[おそらくクレイ、 &lt;code&gt;short&lt;/code&gt; S、 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; sおよび &lt;code&gt;long&lt;/code&gt; sは全て8バイトです。:-)]</target>
        </trans-unit>
        <trans-unit id="0e14a4a995907061486f3bd76c1f023bc121f4f5" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;!&lt;/code&gt; after &lt;code&gt;l&lt;/code&gt;: We want to make sure that we pack a long integer as it is compiled by our C compiler. And even now, it will only work for the platforms where the compiler aligns things as above. And somebody somewhere has a platform where it doesn't. [Probably a Cray, where &lt;code&gt;short&lt;/code&gt;s, &lt;code&gt;int&lt;/code&gt;s and &lt;code&gt;long&lt;/code&gt;s are all 8 bytes. :-)]</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; に注意してください &lt;code&gt;l&lt;/code&gt; の後：Cコンパイラでコンパイルされるときに、長整数をパックするようにします。そして今でも、コンパイラーが上記のように調整するプラットフォームでのみ機能します。そして、誰かがどこかにそれがないプラットフォームを持っています。[おそらくクレイ、 &lt;code&gt;short&lt;/code&gt; S、 &lt;code&gt;int&lt;/code&gt; sおよび &lt;code&gt;long&lt;/code&gt; sは全て8バイトです。:-)]</target>
        </trans-unit>
        <trans-unit id="5b281c2225ddfa8f6c2dd45449bba50edd2d3238" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;$]&lt;/code&gt; in the above is not literal. Substitute whatever version of perl you want to honor that entry, e.g. &lt;code&gt;5.6.0&lt;/code&gt; . Paths must be separated with semicolons, as usual on Windows.</source>
          <target state="translated">上記の &lt;code&gt;$]&lt;/code&gt; はリテラルではないことに注意してください。そのエントリを尊重したいバージョンのperlに置き換えてください（例： &lt;code&gt;5.6.0&lt;/code&gt; )。Windowsでは通常のように、パスはセミコロンで区切る必要があります。</target>
        </trans-unit>
        <trans-unit id="99261696a47484abd841ec0d1ec91dfef269c276" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;$]&lt;/code&gt; in the above is not literal. Substitute whatever version of perl you want to honor that entry, e.g. &lt;code&gt;5.6.0&lt;/code&gt;. Paths must be separated with semicolons, as usual on Windows.</source>
          <target state="translated">上記の &lt;code&gt;$]&lt;/code&gt; はリテラルではないことに注意してください。そのエントリを尊重したいバージョンのperlに置き換えてください（例： &lt;code&gt;5.6.0&lt;/code&gt; )。Windowsの場合と同様に、パスはセミコロンで区切る必要があります。</target>
        </trans-unit>
        <trans-unit id="b760e9a6cdd73c2d052d5f85b1252a43b431d01a" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr//&lt;/a&gt;&lt;/code&gt; expression is surrounded by &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq{}&lt;/a&gt;&lt;/code&gt;. The idea behind this is the same as the classic idiom that makes &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 'interpolate':</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr//&lt;/a&gt;&lt;/code&gt; 式は &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq{}&lt;/a&gt;&lt;/code&gt; 囲まれていることに注意してください。この背後にある考え方は、 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 「補間」する古典的なイディオムと同じです。</target>
        </trans-unit>
        <trans-unit id="d4596391d7dda5f4358c63110663675e031494da" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;s: where autogeneration results in the method for a standard operator which does not change either of its operands, such as &lt;code&gt;-&lt;/code&gt; , being used to implement an operator which changes the operand (&quot;mutators&quot;: here, &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;-=&lt;/code&gt; ), Perl passes undef as the third argument. This still evaluates as FALSE, consistent with the fact that the operands have not been swapped, but gives the subroutine a chance to alter its behaviour in these cases.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; sに注意してください。自動生成では、オペランドを変更しない標準演算子のメソッド（ &lt;code&gt;-&lt;/code&gt; など）が、オペランドを変更する演算子（ &quot;ミューテーター&quot;：ここでは &lt;code&gt;--&lt;/code&gt; および &lt;code&gt;-=&lt;/code&gt; )の実装に使用されます。）、Perlはundefを3番目の引数として渡します。これは、オペランドがスワップされていないという事実と一致して、依然としてFALSEと評価されますが、これらの場合にサブルーチンにその動作を変更する機会を与えます。</target>
        </trans-unit>
        <trans-unit id="200da24930e3f664e651210aeef65207c51b5b78" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;tr//&lt;/code&gt; expression is surrounded by &lt;code&gt;qq{}&lt;/code&gt;. The idea behind this is the same as the classic idiom that makes &lt;code&gt;tr///&lt;/code&gt; 'interpolate':</source>
          <target state="translated">&lt;code&gt;tr//&lt;/code&gt; 式が &lt;code&gt;qq{}&lt;/code&gt; 囲まれていることに注意してください。この背後にある考え方は、 &lt;code&gt;tr///&lt;/code&gt; 'を補間する'を作成する古典的なイディオムと同じです。</target>
        </trans-unit>
        <trans-unit id="8c7ea810ebe5fef24b0b382427a65305a168d9de" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;undef&lt;/code&gt;s: where autogeneration results in the method for a standard operator which does not change either of its operands, such as &lt;code&gt;-&lt;/code&gt;, being used to implement an operator which changes the operand (&quot;mutators&quot;: here, &lt;code&gt;--&lt;/code&gt; and &lt;code&gt;-=&lt;/code&gt;), Perl passes undef as the third argument. This still evaluates as FALSE, consistent with the fact that the operands have not been swapped, but gives the subroutine a chance to alter its behaviour in these cases.</source>
          <target state="translated">メモ &lt;code&gt;undef&lt;/code&gt; などのオペランドのいずれかの変化しない標準的なオペレータのための方法で自動生成の結果は、：S &lt;code&gt;-&lt;/code&gt; 、ここでは、オペランド（「ミューテーター」を変更するオペレータを実装するために使用されているが &lt;code&gt;--&lt;/code&gt; と &lt;code&gt;-=&lt;/code&gt; ）、Perlは3番目の引数としてundefを渡します。これは、オペランドがスワップされていないという事実と一致して、依然としてFALSEと評価されますが、これらの場合にサブルーチンの動作を変更する機会を与えます。</target>
        </trans-unit>
        <trans-unit id="db05bb20e1742aeb610b95cb1ced4c32c7213bb5" translate="yes" xml:space="preserve">
          <source>Note the API instability warning in &lt;a href=&quot;#setpayload&quot;&gt;&quot;setpayload&quot;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#setpayload&quot;&gt;「setpayload」&lt;/a&gt;のAPI不安定性警告に注意してください。</target>
        </trans-unit>
        <trans-unit id="08c6b44fb15bcf48412bfa33391fc2030093296e" translate="yes" xml:space="preserve">
          <source>Note the LIST is prepended whole, not one element at a time, so the prepended elements stay in the same order. Use &lt;a href=&quot;#reverse-LIST&quot;&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/a&gt; to do the reverse.</source>
          <target state="translated">LISTは、一度に1つの要素ではなく、全体に付加されるため、付加される要素は同じ順序のままであることに注意してください。&lt;a href=&quot;#reverse-LIST&quot;&gt; &lt;code&gt;reverse&lt;/code&gt; &lt;/a&gt;を使用してリバースを実行します。</target>
        </trans-unit>
        <trans-unit id="19e6d5e5eedfcc869e45b8ad3dc4833107e51623" translate="yes" xml:space="preserve">
          <source>Note the LIST is prepended whole, not one element at a time, so the prepended elements stay in the same order. Use &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; to do the reverse.</source>
          <target state="translated">LISTは一度に1つの要素ではなく全体が先頭に追加されるため、先頭に追加された要素は同じ順序のままです。 &lt;code&gt;&lt;a href=&quot;functions/reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; を行うには、reverseを使用します。</target>
        </trans-unit>
        <trans-unit id="0964c138a8a06a965bf091caaa6b9ea018efcb97" translate="yes" xml:space="preserve">
          <source>Note the LIST is prepended whole, not one element at a time, so the prepended elements stay in the same order. Use &lt;code&gt;&lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; to do the reverse.</source>
          <target state="translated">LISTは一度に1つの要素ではなく全体が先頭に追加されるため、先頭に追加された要素は同じ順序のままです。 &lt;code&gt;&lt;a href=&quot;reverse&quot;&gt;reverse&lt;/a&gt;&lt;/code&gt; を行うには、reverseを使用します。</target>
        </trans-unit>
        <trans-unit id="ddf2e42d261d53e754661957b5687c8859030118" translate="yes" xml:space="preserve">
          <source>Note the calls to PERL_SET_CONTEXT(). These are necessary to initialize the global state that tracks which interpreter is the &quot;current&quot; one on the particular process or thread that may be running it. It should always be used if you have more than one interpreter and are making perl API calls on both interpreters in an interleaved fashion.</source>
          <target state="translated">PERL_SET_CONTEXT()の呼び出しに注意してください。これらは、それを実行している特定のプロセスやスレッド上で、どのインタプリタが「現在の」インタプリタであるかを追跡するグローバル状態を初期化するために必要です。複数のインタープリタがあり、両方のインタープリタでインタプリタをインターリーブしてPerl APIを呼び出している場合には、常にこの関数を使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="b5b392e74eb48b0aee9cb28bffd1d6dc73cfac7a" translate="yes" xml:space="preserve">
          <source>Note the early capture of &lt;code&gt;PL_savestack_ix&lt;/code&gt; to &lt;code&gt;old_ss_ix&lt;/code&gt;, which is later passed as an arg to &lt;code&gt;cx_pushblock&lt;/code&gt;. In the case of &lt;code&gt;pp_entersub&lt;/code&gt;, this is because, although most values needing saving are stored in fields of the context struct, an extra value needs saving only when the debugger is running, and it doesn't make sense to bloat the struct for this rare case. So instead it is saved on the savestack. Since this value gets calculated and saved before the context is pushed, it is necessary to pass the old value of &lt;code&gt;PL_savestack_ix&lt;/code&gt; to &lt;code&gt;cx_pushblock&lt;/code&gt;, to ensure that the saved value gets freed during scope exit. For most users of &lt;code&gt;cx_pushblock&lt;/code&gt;, where nothing needs pushing on the save stack, &lt;code&gt;PL_savestack_ix&lt;/code&gt; is just passed directly as an arg to &lt;code&gt;cx_pushblock&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PL_savestack_ix&lt;/code&gt; からold_ss_ixへの早期キャプチャに注意して &lt;code&gt;old_ss_ix&lt;/code&gt; 。これは、後で引数として &lt;code&gt;cx_pushblock&lt;/code&gt; に渡されます。 &lt;code&gt;pp_entersub&lt;/code&gt; の場合、これは、保存が必要なほとんどの値がコンテキスト構造体のフィールドに格納されているにもかかわらず、追加の値はデバッガーの実行時にのみ保存が必要であり、このまれな構造体を肥大化させる意味がないためです。場合。したがって、代わりにセーブスタックに保存されます。コンテキストが押される前に、この値が計算され、保存されますので、古い値通過する必要がある &lt;code&gt;PL_savestack_ix&lt;/code&gt; のに &lt;code&gt;cx_pushblock&lt;/code&gt; 保存された値は、スコープ終了時に解放されることを確実にするために、。 &lt;code&gt;cx_pushblock&lt;/code&gt; のほとんどのユーザーの場合、保存スタックをプッシュする必要がない場合、 &lt;code&gt;PL_savestack_ix&lt;/code&gt; は引数として &lt;code&gt;cx_pushblock&lt;/code&gt; に直接渡されます。</target>
        </trans-unit>
        <trans-unit id="86c788344d48bbaf6f108e51a7241322de827d97" translate="yes" xml:space="preserve">
          <source>Note the emphasis on bytes: even if the filehandle has been set to operate on characters (for example using the &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; I/O layer), the &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#sysseek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;sysseek&lt;/code&gt;&lt;/a&gt; family of functions use byte offsets, not character offsets, because seeking to a character offset would be very slow in a UTF-8 file.</source>
          <target state="translated">バイトの強調に注意してください。ファイルハンドルが文字を操作するように設定されている場合でも（たとえば、 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; I / Oレイヤーを使用）、&lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#sysseek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;sysseek&lt;/code&gt; &lt;/a&gt;ファミリーの関数はバイトオフセットを使用します。 UTF-8ファイルでは、文字オフセットの検索が非常に遅くなるため、文字オフセット。</target>
        </trans-unit>
        <trans-unit id="7596eda7b71ff20655d3bc34a84787b053200c0e" translate="yes" xml:space="preserve">
          <source>Note the gaps marked by &quot;*&quot; before several of the byte entries above. These are caused by legal UTF-8 avoiding non-shortest encodings: it is technically possible to UTF-8-encode a single code point in different ways, but that is explicitly forbidden, and the shortest possible encoding should always be used (and that is what Perl does).</source>
          <target state="translated">上のバ イ ト 項目のいくつかの前に「*」でマークされた空白に注意して く ださい。これらは合法的な UTF-8 が最短でないエンコーディングを避けていることに起因しています。</target>
        </trans-unit>
        <trans-unit id="924291c98e268b7826585c54d3c30b3f0159b622" translate="yes" xml:space="preserve">
          <source>Note the semicolon. Except for the code inside not being immediately executed, a &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; is not so much a declaration as it is an operator, like &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt;. (However, no matter how many times you execute that particular line (unless you're in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval(&quot;...&quot;)&lt;/a&gt;&lt;/code&gt;), $coderef will still have a reference to the</source>
          <target state="translated">セミコロンに注意してください。内部のコードがすぐに実行されないことを除いて、 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do{}&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{}&lt;/a&gt;&lt;/code&gt; ような演算子なので、それほど宣言ではありません。（ただし、その特定の行を何回実行しても（ &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval(&quot;...&quot;)&lt;/a&gt;&lt;/code&gt; にいる場合を除き）、$ coderefは引き続き</target>
        </trans-unit>
        <trans-unit id="ba98181394143476434b95cb278177df7d3eab51" translate="yes" xml:space="preserve">
          <source>Note the semicolon. Except for the code inside not being immediately executed, a &lt;code&gt;sub {}&lt;/code&gt; is not so much a declaration as it is an operator, like &lt;code&gt;do{}&lt;/code&gt; or &lt;code&gt;eval{}&lt;/code&gt;. (However, no matter how many times you execute that particular line (unless you're in an &lt;code&gt;eval(&quot;...&quot;)&lt;/code&gt;), $coderef will still have a reference to the</source>
          <target state="translated">セミコロンに注意してください。内部のコードがすぐに実行されないことを除いて、 &lt;code&gt;sub {}&lt;/code&gt; は、 &lt;code&gt;do{}&lt;/code&gt; や &lt;code&gt;eval{}&lt;/code&gt; ように、演算子であるほど宣言ではありません。（ただし、その特定の行を何度実行しても（ &lt;code&gt;eval(&quot;...&quot;)&lt;/code&gt; を使用している場合を除く）、$ coderefには引き続き</target>
        </trans-unit>
        <trans-unit id="245f27d09730a3956ebd88bb73ed91d5802f1f14" translate="yes" xml:space="preserve">
          <source>Note the two following forms:</source>
          <target state="translated">以下の2つの形態に注意してください。</target>
        </trans-unit>
        <trans-unit id="08a39ac9f8eb20d1bc0ac7dda6dd75ffb57ed8d8" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;code&gt;$&lt;/code&gt; instead of &lt;code&gt;\&lt;/code&gt; in the last example. Unlike &lt;b&gt;sed&lt;/b&gt;, we use the \&amp;lt;</source>
          <target state="translated">最後の例では、 &lt;code&gt;\&lt;/code&gt; の代わりに &lt;code&gt;$&lt;/code&gt; を使用していることに注意してください。&lt;b&gt;sed&lt;/b&gt;とは異なり、\ &amp;lt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="774d755cbcc9927f9bd666b04c889ec17f9ec2e7" translate="yes" xml:space="preserve">
          <source>Note the use of the &lt;code&gt;Minimal&lt;/code&gt; option in the code above. When using gzip for Content-Encoding you should</source>
          <target state="translated">上記のコードで &lt;code&gt;Minimal&lt;/code&gt; オプションが使用されていることに注意してください。コンテンツエンコーディングにgzipを使用する場合は、</target>
        </trans-unit>
        <trans-unit id="845bd8d10b7b2e89645294c110cfa223e574f5d5" translate="yes" xml:space="preserve">
          <source>Note there are two distinct steps there: 1) You'll have to create Wild.pm and put it in your perl lib directory. 2) You'll need to set the PERL5OPT environment variable. If you want argv expansion to be the default, just set PERL5OPT in your default startup environment.</source>
          <target state="translated">ここでは二つの異なるステップがあることに注意してください。1)Wild.pm を作成し、それを perl lib ディレクトリに置く必要があります。2)環境変数 PERL5OPT を設定する必要があります。argv 拡張をデフォルトにしたい場合は、デフォルトの起動環境で PERL5OPT を設定してください。</target>
        </trans-unit>
        <trans-unit id="3aa39411508c2033438cf708df8c04c8a846a8d6" translate="yes" xml:space="preserve">
          <source>Note there is a distinction between a capture buffer which matches the empty string a capture buffer which is optional. Eg, &lt;code&gt;(x?)&lt;/code&gt; and &lt;code&gt;(x)?&lt;/code&gt; The latter may be undef, the former not.</source>
          <target state="translated">空の文字列に一致するキャプチャバッファと、オプションのキャプチャバッファには違いがあることに注意してください。例： &lt;code&gt;(x?)&lt;/code&gt; および &lt;code&gt;(x)?&lt;/code&gt; 後者は未定義かもしれませんが、前者はそうではありません。</target>
        </trans-unit>
        <trans-unit id="44c0c7dc0dc0ee1847fe2547270344fd07547c80" translate="yes" xml:space="preserve">
          <source>Note this interface is strongly preferred over &lt;code&gt;gv_stashpvn&lt;/code&gt; for performance reasons.</source>
          <target state="translated">パフォーマンス上の理由から、このインターフェースは &lt;code&gt;gv_stashpvn&lt;/code&gt; よりも強く推奨されています。</target>
        </trans-unit>
        <trans-unit id="3299aefdb3ce5c9a7bffd6e8e1b69e10b1bc969e" translate="yes" xml:space="preserve">
          <source>Note this is current as of patchlevel 0, and could change at any time.</source>
          <target state="translated">これはパッチレベル0の時点での情報であり、いつでも変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="43dee313ad9b91211c8c801e413c783a1b1c90d4" translate="yes" xml:space="preserve">
          <source>Note this may be also triggered for constructs like:</source>
          <target state="translated">のような構造体に対してもトリガされる可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="479333dc136e44b8ccb0606732973018c80236a3" translate="yes" xml:space="preserve">
          <source>Note this move has made \x{D800}-\x{DFFF} into a forbidden zone but perl does not prohibit the use of characters within this range. To perl, every one of \x{0000_0000} up to \x{ffff_ffff} (*) is</source>
          <target state="translated">この動きにより、\x{D800}-\x{DFFF}は禁止区域になりましたが、Perlはこの範囲内の文字の使用を禁止していないことに注意してください。perlにとっては、\x{0000_0000}から\x{ffff_ffff}までの全ての文字が、この範囲内での使用を禁止していません。(*)は</target>
        </trans-unit>
        <trans-unit id="64c26fc0bfdd3e67c9ece7008879dc6d1a01b402" translate="yes" xml:space="preserve">
          <source>Note to those still using Perl 5.18 or earlier: The use of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; will slow down &lt;b&gt;all&lt;/b&gt; regex use within your program. Consult &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for &lt;code&gt;@-&lt;/code&gt; to see equivalent expressions that won't cause slow down. See also &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::SawAmpersand&quot;&gt;Devel::SawAmpersand&lt;/a&gt;. Starting with Perl 5.10, you can also use the equivalent variables &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , but for them to be defined, you have to specify the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier on your regular expression. In Perl 5.20, the use of &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; makes no speed difference.</source>
          <target state="translated">Perl 5.18以前をまだ使用している人への注意： &lt;code&gt;$`&lt;/code&gt; 、 &lt;code&gt;$&amp;amp;&lt;/code&gt; または &lt;code&gt;$'&lt;/code&gt; を使用すると、プログラム内での&lt;b&gt;すべての&lt;/b&gt;正規表現の使用が遅くなります。ご相談&lt;a href=&quot;perlvar&quot;&gt;はperlvarを&lt;/a&gt;するために &lt;code&gt;@-&lt;/code&gt; そのスローダウンは発生しません等価な表現を参照してください。&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::SawAmpersand&quot;&gt;Devel :: SawAmpersand&lt;/a&gt;も参照してください。 Perl 5.10以降では、同等の変数 &lt;code&gt;${^PREMATCH}&lt;/code&gt; 、 &lt;code&gt;${^MATCH}&lt;/code&gt; 、および &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 使用することもできますが、それらを定義するには、 &lt;code&gt;/p&lt;/code&gt; （保存）修飾子を指定する必要があります。正規表現。 Perl 5.20では、 &lt;code&gt;$`&lt;/code&gt; 、 &lt;code&gt;$&amp;amp;&lt;/code&gt; および &lt;code&gt;$'&lt;/code&gt; 速度の違いはありません。</target>
        </trans-unit>
        <trans-unit id="58f853df3fafdf36ed80cd1751e4f069c0f1707d" translate="yes" xml:space="preserve">
          <source>Note to those still using Perl 5.18 or earlier: The use of &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; or &lt;code&gt;$'&lt;/code&gt; will slow down &lt;b&gt;all&lt;/b&gt; regex use within your program. Consult &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for &lt;code&gt;@-&lt;/code&gt; to see equivalent expressions that won't cause slow down. See also &lt;a href=&quot;Devel::SawAmpersand&quot;&gt;Devel::SawAmpersand&lt;/a&gt;. Starting with Perl 5.10, you can also use the equivalent variables &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt;, but for them to be defined, you have to specify the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier on your regular expression. In Perl 5.20, the use of &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; makes no speed difference.</source>
          <target state="translated">Perl 5.18以前をまだ使用している場合の注意： &lt;code&gt;$`&lt;/code&gt; 、 &lt;code&gt;$&amp;amp;&lt;/code&gt; 、または &lt;code&gt;$'&lt;/code&gt; を使用すると、プログラム内での&lt;b&gt;すべての&lt;/b&gt;正規表現の使用が遅くなります。ご相談&lt;a href=&quot;perlvar&quot;&gt;はperlvarを&lt;/a&gt;するために &lt;code&gt;@-&lt;/code&gt; そのスローダウンは発生しません等価な表現を参照してください。&lt;a href=&quot;Devel::SawAmpersand&quot;&gt;Devel :: SawAmpersand&lt;/a&gt;も参照してください。Perl 5.10以降では、同等の変数 &lt;code&gt;${^PREMATCH}&lt;/code&gt; 、 &lt;code&gt;${^MATCH}&lt;/code&gt; 、および &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 使用することもできますが、それらを定義するには、で &lt;code&gt;/p&lt;/code&gt; （保存）修飾子を指定する必要があります。正規表現。Perl 5.20では、 &lt;code&gt;$`&lt;/code&gt; 、 &lt;code&gt;$&amp;amp;&lt;/code&gt; 、および &lt;code&gt;$'&lt;/code&gt; 速度差はありません。</target>
        </trans-unit>
        <trans-unit id="075a00b6d348d2bde80b54d266bd24c03289e88d" translate="yes" xml:space="preserve">
          <source>Note too that, when using the /x modifier on a regex, any comment containing the current pattern delimiter will cause the regex to be immediately terminated. In other words:</source>
          <target state="translated">また、正規表現で /x 修飾子を使用する場合、現在のパターン区切り文字を含むコメントは、その正規表現を直ちに終了させることに注意してください。言い換えれば</target>
        </trans-unit>
        <trans-unit id="a9418a9be85583539aad52da154ad55780878583" translate="yes" xml:space="preserve">
          <source>Note, however, a &quot;=begin</source>
          <target state="translated">ただし、&quot;=begin &quot;に注意してください。</target>
        </trans-unit>
        <trans-unit id="6dfa7aab0d54b245f769489b5d31604d4926ff66" translate="yes" xml:space="preserve">
          <source>Note, however, that (unlike most other OO languages) Perl does not ensure or enforce encapsulation in any way. If you want objects to actually</source>
          <target state="translated">しかし、(他の多くの OO 言語とは異なり)Perl はカプセル化を保証したり強制したりしないことに注意してください。オブジェクトを実際に</target>
        </trans-unit>
        <trans-unit id="9ee559bf7555e3380e5d318f57cb372ff9af8802" translate="yes" xml:space="preserve">
          <source>Note, however, that formatting codes and Z&amp;lt;&amp;gt;'s can occur in any and all parts of an L&amp;lt;...&amp;gt; (i.e., in</source>
          <target state="translated">ただし、フォーマットコードとZ &amp;lt;&amp;gt;は、L &amp;lt;...&amp;gt;のすべての部分（つまり、</target>
        </trans-unit>
        <trans-unit id="1ced7964eb00ec0017dbaa24226307b98c43e3bb" translate="yes" xml:space="preserve">
          <source>Note, however, that sometimes the Pod events aren't processed in exactly the same order as the code lines are -- i.e., if you have a file with Pod, then code, then more Pod, sometimes the code will be processed (via whatever you have code_handler call) before the all of the preceding Pod has been processed.</source>
          <target state="translated">つまり、ファイルにPodがあって、次にコードがあって、さらにPodがある場合、コードが(code_handlerを呼び出して)先行するPodがすべて処理される前に処理されてしまうことがあります。</target>
        </trans-unit>
        <trans-unit id="9e68e1c2898e4995bc610c38829131cae377e27c" translate="yes" xml:space="preserve">
          <source>Note, however, that this does not always work for quoting Perl code:</source>
          <target state="translated">ただし、これはPerlのコードを引用するときには必ずしもうまくいくとは限らないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="daa40807202515240a11e4305fe2938d02dab24c" translate="yes" xml:space="preserve">
          <source>Note, however, that this restricts localization of some values ; for example, the following statement dies, as of perl 5.10.0, with an error</source>
          <target state="translated">しかし、これはいくつかの値のローカライズを制限していることに注意してください。例えば、次の文は perl 5.10.0 ではエラーで終了します。</target>
        </trans-unit>
        <trans-unit id="1d6b51a1f71c0a1abcbedef9280d1a614610364d" translate="yes" xml:space="preserve">
          <source>Note, incidentally, that items in each group are comma-separated, not &lt;code&gt;/\s*,\s*/&lt;/code&gt; -separated. That is, you might expect that this bracket group:</source>
          <target state="translated">ちなみに、各グループの項目は &lt;code&gt;/\s*,\s*/&lt;/code&gt; -separated ではなく、コンマで区切られていることに注意してください。つまり、このブラケットグループは次のようになると期待できます。</target>
        </trans-unit>
        <trans-unit id="c6f16890b60d4dbdb1b39ad263c84c7dffbf2eae" translate="yes" xml:space="preserve">
          <source>Note, incidentally, that items in each group are comma-separated, not &lt;code&gt;/\s*,\s*/&lt;/code&gt;-separated. That is, you might expect that this bracket group:</source>
          <target state="translated">ちなみに、各グループの項目は &lt;code&gt;/\s*,\s*/&lt;/code&gt; 区切られているのではなく、コンマで区切られていることに注意してください。つまり、このブラケットグループは次のようになります。</target>
        </trans-unit>
        <trans-unit id="328da3257aa2be232f47d8215b8ce26d82b79a88" translate="yes" xml:space="preserve">
          <source>Note, it is possible for the version of a module to be unspecified, whereby the value is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, so use &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $version{$foo}{$bar}&lt;/code&gt; if that's what you're testing for.</source>
          <target state="translated">モジュールのバージョンが指定されて &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 、値がundefである可能性があることに注意してください。そのため、テスト対象の場合は、 &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt; $version{$foo}{$bar}&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="0424f392af8ee6773275c7a49c920c35add5c370" translate="yes" xml:space="preserve">
          <source>Note, it is possible for the version of a module to be unspecified, whereby the value is &lt;code&gt;undef&lt;/code&gt;, so use &lt;code&gt;exists $version{$foo}{$bar}&lt;/code&gt; if that's what you're testing for.</source>
          <target state="translated">モジュールのバージョンが指定されていない可能性があることに注意してください。これにより、値は &lt;code&gt;undef&lt;/code&gt; になります。したがって、テスト対象の場合は、 &lt;code&gt;exists $version{$foo}{$bar}&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="48e4009ec57ba2c9432c9aea5b719c678f3436d3" translate="yes" xml:space="preserve">
          <source>Note, prior to 5.25 this function returned what is now returned by the hv_bucket_ratio() function.</source>
          <target state="translated">5.25 より前のバージョンでは、この関数は現在 hv_bucket_ratio()関数で返されているものを返していたことに注意してください。</target>
        </trans-unit>
        <trans-unit id="59b95364ddb70e31cf0aeb6a61be710b24d1414c" translate="yes" xml:space="preserve">
          <source>Note, starting in Perl 5.18, the name &lt;code&gt;BELL&lt;/code&gt; refers to the Unicode character U+1F514, instead of the traditional U+0007. For the latter, use &lt;code&gt;ALERT&lt;/code&gt; or &lt;code&gt;BEL&lt;/code&gt; .</source>
          <target state="translated">Perl 5.18以降、 &lt;code&gt;BELL&lt;/code&gt; という名前は、従来のU + 0007ではなく、Unicode文字U + 1F514を指すことに注意してください。後者の場合は、 &lt;code&gt;ALERT&lt;/code&gt; または &lt;code&gt;BEL&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="610f3ee797f1ad4a61eeefe27944e6e308608f88" translate="yes" xml:space="preserve">
          <source>Note, starting in Perl 5.18, the name &lt;code&gt;BELL&lt;/code&gt; refers to the Unicode character U+1F514, instead of the traditional U+0007. For the latter, use &lt;code&gt;ALERT&lt;/code&gt; or &lt;code&gt;BEL&lt;/code&gt;.</source>
          <target state="translated">Perl 5.18以降、 &lt;code&gt;BELL&lt;/code&gt; という名前は、従来のU + 0007ではなく、Unicode文字U + 1F514を指していることに注意してください。後者の場合は、 &lt;code&gt;ALERT&lt;/code&gt; または &lt;code&gt;BEL&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="bca239c5c2f598100f4661bdcb782662394e6f1d" translate="yes" xml:space="preserve">
          <source>Note, that in both cases the tilde expansion is done by MakeMaker, not by perl by default, nor by make.</source>
          <target state="translated">どちらの場合も、チルダの展開はMakeMakerによって行われ、Perlのデフォルトでもmakeでもなく、MakeMakerによって行われることに注意してください。</target>
        </trans-unit>
        <trans-unit id="557c3756e4a3c96fb446dffbb0c22ffbb956fd7d" translate="yes" xml:space="preserve">
          <source>Note, there is a limitation of this technique. Some compression file formats store extra information along with the compressed data payload. For example, gzip can optionally store the original filename and Zip stores a lot of information about the original file. If the original compressed file contains any of this extra information, it will not be transferred to the new compressed file using the technique above.</source>
          <target state="translated">この技術には制限があることに注意してください。いくつかの圧縮ファイルフォーマットは、圧縮データのペイロードと一緒に余分な情報を保存します。例えば、gzip はオプションで元のファイル名を保存することができ、Zip は元のファイルに関する多くの情報を保存します。元の圧縮ファイルにこの余分な情報が含まれている場合、上記のテクニックを使用して新しい圧縮ファイルに転送されることはありません。</target>
        </trans-unit>
        <trans-unit id="2f4993e4338094ef439d0737bf034f424a4d5b79" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; by default.</source>
          <target state="translated">これらの定数は、デフォルトでは &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; によってインポートされないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="36fe78df4850fd37cfbf75f0174f722ec0a6341e" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; by default.</source>
          <target state="translated">これらの定数は、デフォルトでは &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; によってインポートされないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d62d5837f1b088899c2335c24b7fb00237a5b01e" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; by default.</source>
          <target state="translated">これらの定数は、デフォルトでは &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; によってインポートされないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d3aba16133e84e8f9cf404e250371714dd197ffd" translate="yes" xml:space="preserve">
          <source>Note, these constants are not imported by &lt;code&gt;IO::Compress::Zip&lt;/code&gt; by default.</source>
          <target state="translated">これらの定数は、デフォルトでは &lt;code&gt;IO::Compress::Zip&lt;/code&gt; によってインポートされないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="d20abe192a9c5b05ecdd8b5a009dcb0d1cc347b5" translate="yes" xml:space="preserve">
          <source>Note, use of &lt;code&gt;gv_stashsv&lt;/code&gt; instead of &lt;code&gt;gv_stashpvn&lt;/code&gt; where possible is strongly recommended for performance reasons.</source>
          <target state="translated">注の使用 &lt;code&gt;gv_stashsv&lt;/code&gt; 代わりの &lt;code&gt;gv_stashpvn&lt;/code&gt; 強くパフォーマンス上の理由から推奨される可能。</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="04e9999aa448d4f7736e19660c8cdd3fdd576ad9" translate="yes" xml:space="preserve">
          <source>Note: 'pinyin' is Han in Latin, 'zhuyin' is Han in Bopomofo.</source>
          <target state="translated">注:「ピンイン」はラテン語で漢語、「zhuyin」はボポモフォで漢語。</target>
        </trans-unit>
        <trans-unit id="4cdcc6395bb5bb305f89c21276194ad5f5be7723" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;#unlink-LIST&quot;&gt;&lt;code&gt;unlink&lt;/code&gt;&lt;/a&gt; will not attempt to delete directories unless you are superuser and the &lt;b&gt;-U&lt;/b&gt; flag is supplied to Perl. Even if these conditions are met, be warned that unlinking a directory can inflict damage on your filesystem. Finally, using &lt;a href=&quot;#unlink-LIST&quot;&gt;&lt;code&gt;unlink&lt;/code&gt;&lt;/a&gt; on directories is not supported on many operating systems. Use &lt;a href=&quot;#rmdir-FILENAME&quot;&gt;&lt;code&gt;rmdir&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">注：スーパーユーザーであり、&lt;b&gt;-U&lt;/b&gt;フラグがPerlに提供されていない限り、&lt;a href=&quot;#unlink-LIST&quot;&gt; &lt;code&gt;unlink&lt;/code&gt; &lt;/a&gt;はディレクトリの削除を試みません。これらの条件が満たされている場合でも、ディレクトリのリンクを解除するとファイルシステムに損傷を与える可能性があることに注意してください。最後に、ディレクトリでの&lt;a href=&quot;#unlink-LIST&quot;&gt; &lt;code&gt;unlink&lt;/code&gt; &lt;/a&gt;使用は、多くのオペレーティングシステムでサポートされていません。代わりに&lt;a href=&quot;#rmdir-FILENAME&quot;&gt; &lt;code&gt;rmdir&lt;/code&gt; &lt;/a&gt;を使用してください。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="858564b8eb505f163537f56838925cbe62eeb857" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not attempt to delete directories unless you are superuser and the &lt;b&gt;-U&lt;/b&gt; flag is supplied to Perl. Even if these conditions are met, be warned that unlinking a directory can inflict damage on your filesystem. Finally, using &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; on directories is not supported on many operating systems. Use &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">注：スーパーユーザーで、Perlに&lt;b&gt;-U&lt;/b&gt;フラグが指定されていない限り、 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; はディレクトリの削除を試みません。これらの条件が満たされている場合でも、ディレクトリのリンクを解除するとファイルシステムに損傷を与える可能性があることに注意してください。最後に、ディレクトリでの &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 使用は、多くのオペレーティングシステムでサポートされていません。代わりに &lt;code&gt;&lt;a href=&quot;functions/rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; を使用してください。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5634cda13018c382b3c15c0bf989c4dea07045c1" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; isn't needed in this example: &lt;code&gt;strftime()&lt;/code&gt; is a POSIX function which uses the standard system-supplied &lt;code&gt;libc&lt;/code&gt; function that always obeys the current &lt;code&gt;LC_TIME&lt;/code&gt; locale.</source>
          <target state="translated">注：この例では、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;は必要ありません &lt;code&gt;strftime()&lt;/code&gt; は、常に現在の &lt;code&gt;LC_TIME&lt;/code&gt; ロケールに従う標準のシステム提供の &lt;code&gt;libc&lt;/code&gt; 関数を使用するPOSIX関数です。</target>
        </trans-unit>
        <trans-unit id="bd71952aea843bf37c94c0e84aec5e1493d8dd4a" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; isn't shown in some of these examples because it isn't needed: &lt;code&gt;strcoll()&lt;/code&gt; and &lt;code&gt;strxfrm()&lt;/code&gt; are POSIX functions which use the standard system-supplied &lt;code&gt;libc&lt;/code&gt; functions that always obey the current &lt;code&gt;LC_COLLATE&lt;/code&gt; locale.</source>
          <target state="translated">注： &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; は必要ないため、これらの例の一部では示されていません &lt;code&gt;strcoll()&lt;/code&gt; および &lt;code&gt;strxfrm()&lt;/code&gt; は、常に現在の &lt;code&gt;LC_COLLATE&lt;/code&gt; ロケールに従う標準のシステム提供の &lt;code&gt;libc&lt;/code&gt; 関数を使用するPOSIX関数です。</target>
        </trans-unit>
        <trans-unit id="89c514c1b9de7057dea402c8d0f5122402a932ba" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not attempt to delete directories unless you are superuser and the &lt;b&gt;-U&lt;/b&gt; flag is supplied to Perl. Even if these conditions are met, be warned that unlinking a directory can inflict damage on your filesystem. Finally, using &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; on directories is not supported on many operating systems. Use &lt;code&gt;&lt;a href=&quot;rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">注：スーパーユーザーで、Perlに&lt;b&gt;-U&lt;/b&gt;フラグが指定されていない限り、 &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; はディレクトリの削除を試みません。これらの条件が満たされている場合でも、ディレクトリのリンクを解除するとファイルシステムに損傷を与える可能性があることに注意してください。最後に、ディレクトリでの &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 使用は、多くのオペレーティングシステムでサポートされていません。代わりに &lt;code&gt;&lt;a href=&quot;rmdir&quot;&gt;rmdir&lt;/a&gt;&lt;/code&gt; を使用してください。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="07397ae9451cf5a436657d9cabd9f8d4563f40ae" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; will search the layers for a stdio layer. If it can't find one, it will call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; to generate a new stdio &lt;code&gt;FILE&lt;/code&gt; . Please only call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; if you want a</source>
          <target state="translated">注： &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; は、stdioレイヤーのレイヤーを検索します。見つからない場合は、 &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; を呼び出して新しいstdio &lt;code&gt;FILE&lt;/code&gt; を生成します。必要な場合のみ &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; を呼び出してください</target>
        </trans-unit>
        <trans-unit id="724e5762fee6d350a318fc2fb4b30294baaefc44" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; will search the layers for a stdio layer. If it can't find one, it will call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; to generate a new stdio &lt;code&gt;FILE&lt;/code&gt;. Please only call &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; if you want a</source>
          <target state="translated">注： &lt;code&gt;PerlIO_findFILE()&lt;/code&gt; は、レイヤーでstdioレイヤーを検索します。それがものを見つけることができない場合は、それが呼び出されます &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; 新しいstdioの生成する &lt;code&gt;FILE&lt;/code&gt; 。必要な場合にのみ &lt;code&gt;PerlIO_exportFILE()&lt;/code&gt; を呼び出してください</target>
        </trans-unit>
        <trans-unit id="09f6afd463560b84ea6b975b1be869772594ae4f" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;use locale&lt;/code&gt; isn't needed in this example: &lt;code&gt;strftime()&lt;/code&gt; is a POSIX function which uses the standard system-supplied &lt;code&gt;libc&lt;/code&gt; function that always obeys the current &lt;code&gt;LC_TIME&lt;/code&gt; locale.</source>
          <target state="translated">注：この例では、 &lt;code&gt;use locale&lt;/code&gt; 必要はありません &lt;code&gt;strftime()&lt;/code&gt; は、現在の &lt;code&gt;LC_TIME&lt;/code&gt; ロケールに常に従う標準のシステム提供の &lt;code&gt;libc&lt;/code&gt; 関数を使用するPOSIX関数です。</target>
        </trans-unit>
        <trans-unit id="90f06e6aec634d9ac607b849e5f22d774716a195" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;use locale&lt;/code&gt; isn't shown in some of these examples because it isn't needed: &lt;code&gt;strcoll()&lt;/code&gt; and &lt;code&gt;strxfrm()&lt;/code&gt; are POSIX functions which use the standard system-supplied &lt;code&gt;libc&lt;/code&gt; functions that always obey the current &lt;code&gt;LC_COLLATE&lt;/code&gt; locale.</source>
          <target state="translated">注： &lt;code&gt;use locale&lt;/code&gt; は、必要ないため、これらの例の一部には示されていません &lt;code&gt;strcoll()&lt;/code&gt; および &lt;code&gt;strxfrm()&lt;/code&gt; は、現在の &lt;code&gt;LC_COLLATE&lt;/code&gt; ロケールに常に従う標準のシステム提供の &lt;code&gt;libc&lt;/code&gt; 関数を使用するPOSIX関数です。</target>
        </trans-unit>
        <trans-unit id="f614956265c278721bb12432048ff10b5826efd9" translate="yes" xml:space="preserve">
          <source>Note: Be careful not to modify &lt;code&gt;@_&lt;/code&gt; at all before you call export_to_level - or people using your package will get very unexplained results!</source>
          <target state="translated">注：export_to_levelを呼び出す前に &lt;code&gt;@_&lt;/code&gt; をまったく変更しないように注意してください。そうしないと、パッケージを使用している人が原因不明の結果を受け取ることになります。</target>
        </trans-unit>
        <trans-unit id="fadfe11234c608cf2899bd38b718e46fd2406590" translate="yes" xml:space="preserve">
          <source>Note: Before 5.21.0, the &quot;missing&quot; lexical warnings category was internally defined to be the same as the &quot;uninitialized&quot; category. It is now a top-level category in its own right.</source>
          <target state="translated">注意:5.21.0以前は、&quot;missing&quot; lexical warningsカテゴリは &quot;uninitialized &quot;カテゴリと同じものとして内部的に定義されていました。現在では、このカテゴリはそれ自体がトップレベルのカテゴリとなっています。</target>
        </trans-unit>
        <trans-unit id="78023e67525e4c7a613335c235fa22e549b34845" translate="yes" xml:space="preserve">
          <source>Note: Before Perl 5.8.0, the lexical warnings category &quot;deprecated&quot; was a sub-category of the &quot;syntax&quot; category. It is now a top-level category in its own right.</source>
          <target state="translated">注意:Perl 5.8.0以前は、語彙的警告カテゴリ「deprecated」は「構文」カテゴリのサブカテゴリでした。現在では、それ自体がトップレベルのカテゴリとなっています。</target>
        </trans-unit>
        <trans-unit id="d209ffe48badd4b3ce623fe1073da3a9d734affc" translate="yes" xml:space="preserve">
          <source>Note: Between XSUB and pure Perl, there is an incompatibility about the interpretation of &lt;code&gt;$code_point&lt;/code&gt; as a decimal number. XSUB converts &lt;code&gt;$code_point&lt;/code&gt; to an unsigned integer, but pure Perl does not. Do not use a floating point nor a negative sign in &lt;code&gt;$code_point&lt;/code&gt;.</source>
          <target state="translated">注：XSUBと純粋なPerlの間には、 &lt;code&gt;$code_point&lt;/code&gt; の10進数としての解釈に互換性がありません。 XSUBは &lt;code&gt;$code_point&lt;/code&gt; を符号なし整数に変換しますが、純粋なPerlは変換しません。 &lt;code&gt;$code_point&lt;/code&gt; 浮動小数点や負の符号を使用しないでください。</target>
        </trans-unit>
        <trans-unit id="5227b82d031bced3044e91e5933630d59be9bc12" translate="yes" xml:space="preserve">
          <source>Note: Do not use a floating point nor a negative sign in &lt;code&gt;$code_point&lt;/code&gt; .</source>
          <target state="translated">注： &lt;code&gt;$code_point&lt;/code&gt; 浮動小数点や負符号を使用しないでください。</target>
        </trans-unit>
        <trans-unit id="668a585af93a214a0b5974e95d57e4c940a86f77" translate="yes" xml:space="preserve">
          <source>Note: Due to XS issues the block passed may be able to access the outer @_ directly. This is not intentional and will break under debugger.</source>
          <target state="translated">注意:XS の問題により、渡されたブロックが外側の @_に直接アクセスできる可能性があります。これは意図的なものではなく、デバッガでは壊れてしまいます。</target>
        </trans-unit>
        <trans-unit id="3b7d3334d006afa6b870b1e3ad78d323bdbd6bec" translate="yes" xml:space="preserve">
          <source>Note: Each class has it's own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="translated">注意:各クラスには、Math::BigInt から分離された独自のグローバルがありますが、Math::BigInt をサブクラス化して、サブクラスのグローバルを Math::BigInt からのグローバルのエイリアスにすることができます。</target>
        </trans-unit>
        <trans-unit id="ccd381c6324e161a3ae5c4a254351b2b3b48d1d8" translate="yes" xml:space="preserve">
          <source>Note: Each class has its own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="translated">注意:各クラスは Math::BigInt から分離された独自のグローバルを持っていますが、Math::BigInt をサブクラス化して、サブクラスのグローバルを Math::BigInt からのグローバルのエイリアスにすることができます。</target>
        </trans-unit>
        <trans-unit id="83d9951c1347109cd3bedbb4bb7306286ad1d212" translate="yes" xml:space="preserve">
          <source>Note: FCC is unique, as well as four normalization forms (NF*).</source>
          <target state="translated">注:FCCは、4つの正規化形態(NF*)と同様に一意です。</target>
        </trans-unit>
        <trans-unit id="2bf5a1f9c5d972054186d3e42a82b7b324805893" translate="yes" xml:space="preserve">
          <source>Note: FCD is not always unique, then plural forms may be equivalent each other. &lt;code&gt;FCD()&lt;/code&gt; will return one of these equivalent forms.</source>
          <target state="translated">注：FCDは常に一意であるとは限らないため、複数の形式が互いに同等である場合があります。 &lt;code&gt;FCD()&lt;/code&gt; は、これらの同等の形式の1つを返します。</target>
        </trans-unit>
        <trans-unit id="56040f615b41a7064a5ef1844f423d8b9a40f330" translate="yes" xml:space="preserve">
          <source>Note: For some extensions, Dave Beazley's SWIG system may provide a significantly more convenient mechanism for creating the extension glue code. See &lt;a href=&quot;http://www.swig.org/&quot;&gt;http://www.swig.org/&lt;/a&gt; for more information.</source>
          <target state="translated">注：一部の拡張機能では、Dave BeazleyのSWIGシステムが、拡張グルーコードを作成するための非常に便利なメカニズムを提供する場合があります。詳細については、&lt;a href=&quot;http://www.swig.org/&quot;&gt;http：//www.swig.org/&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b1211fe58a903b5165f5edc276c715ceb521df1e" translate="yes" xml:space="preserve">
          <source>Note: From Mac OS X 10.6 &quot;Snow Leopard&quot; onwards, Apple only supports Intel-based hardware. This means you can safely skip this section unless you have an older Apple computer running on ppc or wish to create a perl binary with backwards compatibility.</source>
          <target state="translated">注意:Mac OS X 10.6 &quot;Snow Leopard&quot; 以降、Apple は Intel ベースのハードウェアのみをサポートしています。つまり、古い Apple コンピュータを ppc で動かしている場合や、下位互換性のある perl バイナリを作成したい場合を除いては、このセクションを飛ばしても問題ありません。</target>
        </trans-unit>
        <trans-unit id="743600644f11d3e8a913feb2e46d0252bdc64043" translate="yes" xml:space="preserve">
          <source>Note: If a string is not in FCD, it must not be in FCC. So &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; should return &lt;code&gt;NO&lt;/code&gt; .</source>
          <target state="translated">注：文字列がFCDにない場合、FCCに含まれていてはなりません。したがって、 &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; は &lt;code&gt;NO&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="1c308958e09dd00a6a549fa78fd5e059fbed4455" translate="yes" xml:space="preserve">
          <source>Note: If a string is not in FCD, it must not be in FCC. So &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; should return &lt;code&gt;NO&lt;/code&gt;.</source>
          <target state="translated">注：文字列がFCDにない場合は、FCCに含まれていてはなりません。したがって、 &lt;code&gt;checkFCC($not_FCD_string)&lt;/code&gt; は &lt;code&gt;NO&lt;/code&gt; を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="9b01b3e05bd18ecfe427fbadc48a1cf9f4918f8c" translate="yes" xml:space="preserve">
          <source>Note: If you turn on &lt;code&gt;Sparseseen&lt;/code&gt; , then you must not rely on the content of the seen hash since its contents will be an implementation detail!</source>
          <target state="translated">注： &lt;code&gt;Sparseseen&lt;/code&gt; をオンにした場合、その内容は実装の詳細になるため、見られたハッシュの内容に依存しないでください。</target>
        </trans-unit>
        <trans-unit id="9f446264c9bfae66320393c5089f48ed5b46e500" translate="yes" xml:space="preserve">
          <source>Note: If you turn on &lt;code&gt;Sparseseen&lt;/code&gt;, then you must not rely on the content of the seen hash since its contents will be an implementation detail!</source>
          <target state="translated">注： &lt;code&gt;Sparseseen&lt;/code&gt; をオンにした場合、表示されたハッシュの内容は実装の詳細になるため、その内容に依存しないでください。</target>
        </trans-unit>
        <trans-unit id="5da841189af3f04f4eb088d72b96bc951d2d81fc" translate="yes" xml:space="preserve">
          <source>Note: Many folks tend to overuse &lt;a href=&quot;#defined-EXPR&quot;&gt;&lt;code&gt;defined&lt;/code&gt;&lt;/a&gt; and are then surprised to discover that the number &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; (the zero-length string) are, in fact, defined values. For example, if you say</source>
          <target state="translated">注：多くの人は&lt;a href=&quot;#defined-EXPR&quot;&gt; &lt;code&gt;defined&lt;/code&gt; &lt;/a&gt;を使いすぎる傾向があり、数字の &lt;code&gt;0&lt;/code&gt; と &lt;code&gt;&quot;&quot;&lt;/code&gt; （長さゼロの文字列）が実際には定義済みの値であることに驚いています。たとえば、あなたが言うなら</target>
        </trans-unit>
        <trans-unit id="a3278502ab348386cdc09a185533e7816e62b07e" translate="yes" xml:space="preserve">
          <source>Note: Many folks tend to overuse &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; and are then surprised to discover that the number &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; (the zero-length string) are, in fact, defined values. For example, if you say</source>
          <target state="translated">注：多くの人々は &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; を使い過ぎる傾向があり、数字の &lt;code&gt;0&lt;/code&gt; と &lt;code&gt;&quot;&quot;&lt;/code&gt; （長さ0の文字列）が実際には定義済みの値であることを知って驚きます。たとえば、あなたが言うなら</target>
        </trans-unit>
        <trans-unit id="72cf554b1f74abf911508263cf2a354d76fd9f1a" translate="yes" xml:space="preserve">
          <source>Note: Many folks tend to overuse &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; and are then surprised to discover that the number &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; (the zero-length string) are, in fact, defined values. For example, if you say</source>
          <target state="translated">注：多くの人々は &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; を使い過ぎる傾向があり、数字の &lt;code&gt;0&lt;/code&gt; と &lt;code&gt;&quot;&quot;&lt;/code&gt; （長さ0の文字列）が実際には定義済みの値であることを知って驚きます。たとえば、あなたが言うなら</target>
        </trans-unit>
        <trans-unit id="a4c4e917877757fb6fc83b2e0f19ffc51d5f6fc8" translate="yes" xml:space="preserve">
          <source>Note: Perl's builtin &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; function returns four values, measured in seconds.</source>
          <target state="translated">注：Perlの組み込み &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; 関数は、秒単位で測定された4つの値を返します。</target>
        </trans-unit>
        <trans-unit id="4f4979746c04c5a2101a3a8cfcb2e0ca83bb94c8" translate="yes" xml:space="preserve">
          <source>Note: Perl's builtin &lt;code&gt;times()&lt;/code&gt; function returns four values, measured in seconds.</source>
          <target state="translated">注：Perlの組み込み &lt;code&gt;times()&lt;/code&gt; 関数は、秒単位で測定された4つの値を返します。</target>
        </trans-unit>
        <trans-unit id="193ad56c42c8c5022f417eca20124d2510809ef1" translate="yes" xml:space="preserve">
          <source>Note: Some folks colloquially refer to this bit of punctuation as a &quot;yada-yada&quot; or &quot;triple-dot&quot;, but its true name is actually an ellipsis.</source>
          <target state="translated">注:一部の人はこの句読点のビットを口語的に「やだやだ」または「トリプルドット」と呼んでいますが、本当の名前は実際には省略形です。</target>
        </trans-unit>
        <trans-unit id="c9a4ed3733a9eeadde05bd081437b7ba9d5fa627" translate="yes" xml:space="preserve">
          <source>Note: Some modules downloaded from CPAN may require NetWare related API in order to build on NetWare. Other modules may however build smoothly with or without minor changes depending on the type of module.</source>
          <target state="translated">注:CPAN からダウンロードしたモジュールの中には、NetWare 上でビルドするために NetWare 関連の API を必要とするものがあります。しかし、その他のモジュールは、モジュールの種類によっては、マイナーチェンジの有無にかかわらず、スムーズにビルドできる場合があります。</target>
        </trans-unit>
        <trans-unit id="e33603b6b52bf5831bfb6cf75b5a9f26f72dc686" translate="yes" xml:space="preserve">
          <source>Note: Some sites have reported problems when using the file-access tests (&lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; ) on files accessed via DEC's DFS. Specifically, since DFS does not currently provide access to the extended file header of files on remote volumes, attempts to examine the ACL fail, and the file tests will return false, with &lt;code&gt;$!&lt;/code&gt; indicating that the file does not exist. You can use &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; on these files, since that checks UIC-based protection only, and then manually check the appropriate bits, as defined by your C compiler's</source>
          <target state="translated">注：一部のサイトでは、DECのDFSを介してアクセスされるファイルに対してファイルアクセステスト（ &lt;code&gt;-r&lt;/code&gt; 、 &lt;code&gt;-w&lt;/code&gt; 、および &lt;code&gt;-x&lt;/code&gt; ）を使用すると問題が報告されています。具体的には、DFSは現在、リモートボリューム上のファイルの拡張ファイルヘッダーへのアクセスを提供していないため、ACLを検査しようとすると失敗し、ファイルテストはfalseを返し、 &lt;code&gt;$!&lt;/code&gt; ファイルが存在しないことを示します。これらのファイルでは &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; を使用できます。これは、UICベースの保護のみをチェックし、Cコンパイラの定義に従って適切なビットを手動でチェックするためです。</target>
        </trans-unit>
        <trans-unit id="31012ee5baab20630d192eb344f3fbf19e1f0ce3" translate="yes" xml:space="preserve">
          <source>Note: Some sites have reported problems when using the file-access tests (&lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, and &lt;code&gt;-x&lt;/code&gt;) on files accessed via DEC's DFS. Specifically, since DFS does not currently provide access to the extended file header of files on remote volumes, attempts to examine the ACL fail, and the file tests will return false, with &lt;code&gt;$!&lt;/code&gt; indicating that the file does not exist. You can use &lt;code&gt;stat&lt;/code&gt; on these files, since that checks UIC-based protection only, and then manually check the appropriate bits, as defined by your C compiler's</source>
          <target state="translated">注：一部のサイトでは、DECのDFSを介してアクセスされるファイルでファイルアクセステスト（ &lt;code&gt;-r&lt;/code&gt; 、 &lt;code&gt;-w&lt;/code&gt; 、および &lt;code&gt;-x&lt;/code&gt; ）を使用すると問題が報告されています。具体的には、DFSは現在、リモートボリューム上のファイルの拡張ファイルヘッダーへのアクセスを提供していないため、ACLの検査に失敗し、ファイルテストは &lt;code&gt;$!&lt;/code&gt; でfalseを返します。ファイルが存在しないことを示します。UICベースの保護のみをチェックし、Cコンパイラで定義されている適切なビットを手動でチェックするため、これらのファイルで &lt;code&gt;stat&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="5b6f6c7fe8a37aa2c65de3e3c606a0b439080ba4" translate="yes" xml:space="preserve">
          <source>Note: Some vendors supply &lt;code&gt;strtod()&lt;/code&gt; and &lt;code&gt;strtol()&lt;/code&gt; but not &lt;code&gt;strtoul()&lt;/code&gt; . Other vendors that do supply &lt;code&gt;strtoul()&lt;/code&gt; parse &quot;-1&quot; as a valid value.</source>
          <target state="translated">注：一部のベンダーは &lt;code&gt;strtod()&lt;/code&gt; および &lt;code&gt;strtol()&lt;/code&gt; を提供していますが、 &lt;code&gt;strtoul()&lt;/code&gt; を提供していません。 &lt;code&gt;strtoul()&lt;/code&gt; を提供する他のベンダーは、「-1」を有効な値として解析します。</target>
        </trans-unit>
        <trans-unit id="09354bfd47c342dd837df1ad765f45f04db5692c" translate="yes" xml:space="preserve">
          <source>Note: Some vendors supply &lt;code&gt;strtod()&lt;/code&gt; and &lt;code&gt;strtol()&lt;/code&gt; but not &lt;code&gt;strtoul()&lt;/code&gt;. Other vendors that do supply &lt;code&gt;strtoul()&lt;/code&gt; parse &quot;-1&quot; as a valid value.</source>
          <target state="translated">注：一部のベンダーは、 &lt;code&gt;strtod()&lt;/code&gt; と &lt;code&gt;strtol()&lt;/code&gt; を提供していますが、 &lt;code&gt;strtoul()&lt;/code&gt; は提供していません。 &lt;code&gt;strtoul()&lt;/code&gt; を提供する他のベンダーは、有効な値として「-1」を解析します。</target>
        </trans-unit>
        <trans-unit id="f41fee180b1c4bc188eb2c171834172ecd8c3be5" translate="yes" xml:space="preserve">
          <source>Note: The functions with names ending in &lt;code&gt;_at_level&lt;/code&gt; were added in Perl 5.28.</source>
          <target state="translated">注：名前が &lt;code&gt;_at_level&lt;/code&gt; で終わる関数は、Perl5.28で追加されました。</target>
        </trans-unit>
        <trans-unit id="e2d1626493358bc3d857173bc6af6ddd2a5fc2da" translate="yes" xml:space="preserve">
          <source>Note: The iterator (&lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt; ) and file test (&lt;code&gt;'-X'&lt;/code&gt; ) operators work as normal: if the operand is not a blessed glob or IO reference then it is converted to a string (using the method for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; , or &lt;code&gt;'bool'&lt;/code&gt; ) to be interpreted as a glob or filename.</source>
          <target state="translated">注：イテレーター（ &lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt; ）およびファイルテスト（ &lt;code&gt;'-X'&lt;/code&gt; ）演算子は通常どおり機能します。オペランドがblessグロブまたはIO参照でない場合は、文字列に変換されます（ &lt;code&gt;'&quot;&quot;'&lt;/code&gt; メソッドを使用）'、 &lt;code&gt;'0+'&lt;/code&gt; 、または &lt;code&gt;'bool'&lt;/code&gt; ）は、グロブまたはファイル名として解釈されます。</target>
        </trans-unit>
        <trans-unit id="e872c50dbea2dd944dd1795cb2d6b5ca0cb3d48d" translate="yes" xml:space="preserve">
          <source>Note: The iterator (&lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt;) and file test (&lt;code&gt;'-X'&lt;/code&gt;) operators work as normal: if the operand is not a blessed glob or IO reference then it is converted to a string (using the method for &lt;code&gt;'&quot;&quot;'&lt;/code&gt;, &lt;code&gt;'0+'&lt;/code&gt;, or &lt;code&gt;'bool'&lt;/code&gt;) to be interpreted as a glob or filename.</source>
          <target state="translated">注：イテレーター（ &lt;code&gt;'&amp;lt;&amp;gt;'&lt;/code&gt; ）およびファイルテスト（ &lt;code&gt;'-X'&lt;/code&gt; ）演算子は通常どおり機能します。オペランドが祝福されたグロブまたはIO参照でない場合は、文字列に変換されます（ &lt;code&gt;'&quot;&quot;'&lt;/code&gt; メソッドを使用）'、 &lt;code&gt;'0+'&lt;/code&gt; 、または &lt;code&gt;'bool'&lt;/code&gt; ）は、globまたはファイル名として解釈されます。</target>
        </trans-unit>
        <trans-unit id="9a7724723655fcca925e8e2780cbc470ea823e12" translate="yes" xml:space="preserve">
          <source>Note: The keyword 'lib' will warn when the requested library could not be loaded. To suppress the warning use 'try' instead:</source>
          <target state="translated">注意:キーワード 'lib' は、要求されたライブラリをロードできなかった場合に警告を発します。警告を表示しないようにするには、代わりに 'try' を使用してください。</target>
        </trans-unit>
        <trans-unit id="9be19f662c327b39a0c7dc7dd26cac18cf3a2650" translate="yes" xml:space="preserve">
          <source>Note: The latest stable version of this specification can always be found at &lt;a href=&quot;http://module-build.sourceforge.net/META-spec-current.html&quot;&gt;http://module-build.sourceforge.net/META-spec-current.html&lt;/a&gt;, and the latest development version (which may include things that won't make it into the stable version can always be found at &lt;a href=&quot;http://module-build.sourceforge.net/META-spec-blead.html&quot;&gt;http://module-build.sourceforge.net/META-spec-blead.html&lt;/a&gt;.</source>
          <target state="translated">注：この仕様の最新の安定バージョンは、常に&lt;a href=&quot;http://module-build.sourceforge.net/META-spec-current.html&quot;&gt;http://module-build.sourceforge.net/META-spec-current.html&lt;/a&gt;にあり、最新の開発バージョン（含まれていないものが含まれている場合があります）にあります。安定バージョンへの移行は、常に&lt;a href=&quot;http://module-build.sourceforge.net/META-spec-blead.html&quot;&gt;http://module-build.sourceforge.net/META-spec-blead.htmlにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="6d7df03e2ca7476b6f129d5fb49ca21db5f16ee3" translate="yes" xml:space="preserve">
          <source>Note: The latest stable version of this specification can always be found at &lt;a href=&quot;http://module-build.sourceforge.net/META-spec-current.html&quot;&gt;http://module-build.sourceforge.net/META-spec-current.html&lt;/a&gt;, and the latest development version (which may include things that won't make it into the stable version) can always be found at &lt;a href=&quot;http://module-build.sourceforge.net/META-spec-blead.html&quot;&gt;http://module-build.sourceforge.net/META-spec-blead.html&lt;/a&gt;.</source>
          <target state="translated">注：この仕様の最新の安定バージョンは、常に&lt;a href=&quot;http://module-build.sourceforge.net/META-spec-current.html&quot;&gt;http://module-build.sourceforge.net/META-spec-current.html&lt;/a&gt;にあり、最新の開発バージョン（含まれていないものが含まれている場合があります）にあります。安定バージョンに）は常に&lt;a href=&quot;http://module-build.sourceforge.net/META-spec-blead.html&quot;&gt;http://module-build.sourceforge.net/META-spec-blead.html&lt;/a&gt;で見つけることができます。</target>
        </trans-unit>
        <trans-unit id="7834aa58e75e083860df15db52ef81cbd8591c51" translate="yes" xml:space="preserve">
          <source>Note: The list &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; returns has originated from your current perl and your current install.</source>
          <target state="translated">注： &lt;code&gt;&lt;a href=&quot;../../functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 返品のリストは、現在のperlと現在のインストールに由来しています。</target>
        </trans-unit>
        <trans-unit id="79a0d5348f570c35ca9be395234112a023471f03" translate="yes" xml:space="preserve">
          <source>Note: The list &lt;code&gt;require&lt;/code&gt; returns has originated from your current perl and your current install.</source>
          <target state="translated">注：リスト &lt;code&gt;require&lt;/code&gt; returnsは現在のperlと現在のインストールから発信されています。</target>
        </trans-unit>
        <trans-unit id="9e555e53c6f7ef659bcb517427e72585e148bddc" translate="yes" xml:space="preserve">
          <source>Note: The policy of using locale rules for code points that can fit in a byte, and Unicode rules for those that can't is not uniformly applied. Pre-v5.12, it was somewhat haphazard; in v5.12 it was applied fairly consistently to regular expression matching except for bracketed character classes; in v5.14 it was extended to all regex matches; and in v5.16 to the casing operations such as &lt;code&gt;\L&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;. For collation, in all releases so far, the system's &lt;code&gt;strxfrm()&lt;/code&gt; function is called, and whatever it does is what you get.</source>
          <target state="translated">注：バイトに収まるコードポイントにはロケールルールを使用し、収まらないコードポイントにはUnicodeルールを使用するというポリシーは一律に適用されません。v5.12より前では、それはやや無計画でした。v5.12では、括弧で囲まれた文字クラスを除いて、正規表現のマッチングにほぼ一貫して適用されました。v5.14では、すべての正規表現一致に拡張されました。v5.16では、 &lt;code&gt;\L&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; などの大文字と小文字の操作に。照合順序については、これまでのすべてのリリースで、システムの &lt;code&gt;strxfrm()&lt;/code&gt; 関数が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="131995001a6829f0723ee9a84a7ecc32cd05fa54" translate="yes" xml:space="preserve">
          <source>Note: The policy of using locale rules for code points that can fit in a byte, and Unicode rules for those that can't is not uniformly applied. Pre-v5.12, it was somewhat haphazard; in v5.12 it was applied fairly consistently to regular expression matching except for bracketed character classes; in v5.14 it was extended to all regex matches; and in v5.16 to the casing operations such as &lt;code&gt;\L&lt;/code&gt; and &lt;code&gt;uc()&lt;/code&gt;. For collation, in all releases so far, the system's &lt;code&gt;strxfrm()&lt;/code&gt; function is called, and whatever it does is what you get. Starting in v5.26, various bugs are fixed with the way perl uses this function.</source>
          <target state="translated">注：バイトに収まるコードポイントにはロケールルールを使用し、収まらないコードポイントにはUnicodeルールを使用するというポリシーは一律に適用されません。v5.12より前では、それはやや無計画でした。v5.12では、括弧で囲まれた文字クラスを除いて、正規表現のマッチングにかなり一貫して適用されていました。v5.14では、すべての正規表現の一致に拡張されました。v5.16では、 &lt;code&gt;\L&lt;/code&gt; や &lt;code&gt;uc()&lt;/code&gt; などのケーシング操作に対応します。照合については、これまでのすべてのリリースで、システムの &lt;code&gt;strxfrm()&lt;/code&gt; 関数が呼び出され、それが行うことは何でも得られます。v5.26以降、perlがこの関数を使用する方法でさまざまなバグが修正されています。</target>
        </trans-unit>
        <trans-unit id="f932c6f37410ce4ebff00172ee521c9f04d25563" translate="yes" xml:space="preserve">
          <source>Note: This feature was introduced in version 5.57 of Exporter, released with perl 5.8.3.</source>
          <target state="translated">注意:この機能は、Perl 5.8.3 でリリースされた Exporter のバージョン 5.57 で導入されました。</target>
        </trans-unit>
        <trans-unit id="cd489e52bffb55133a04f9392b0cef79b71a84a0" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt; . Any other character than &lt;code&gt;U+FFFE&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt; .</source>
          <target state="translated">注：これは &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt; と同等です。 &lt;code&gt;U+FFFE&lt;/code&gt; 以外の文字は、 &lt;code&gt;entry&lt;/code&gt; で調整できます。</target>
        </trans-unit>
        <trans-unit id="287eea86bd8ed6619f824147ed2c55a69584e9bd" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt;. Any other character than &lt;code&gt;U+FFFE&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt;.</source>
          <target state="translated">注：これは &lt;code&gt;(entry =&amp;gt; 'FFFE ; [.0001.0020.0005.FFFE]')&lt;/code&gt; と同等です。 &lt;code&gt;U+FFFE&lt;/code&gt; 以外の文字は、 &lt;code&gt;entry&lt;/code&gt; によって調整できます。</target>
        </trans-unit>
        <trans-unit id="e524e8ba90f8c2eceff3ee2b4fe18bbc36f721be" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt; . Any other character than &lt;code&gt;U+FFFF&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt; .</source>
          <target state="translated">注：これは &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt; と同等です。 &lt;code&gt;U+FFFF&lt;/code&gt; 以外の文字は、 &lt;code&gt;entry&lt;/code&gt; で調整できます。</target>
        </trans-unit>
        <trans-unit id="7fc676f4776bf9d00f6e8ce3ee423f9f2208472e" translate="yes" xml:space="preserve">
          <source>Note: This is equivalent to &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt;. Any other character than &lt;code&gt;U+FFFF&lt;/code&gt; can be tailored by &lt;code&gt;entry&lt;/code&gt;.</source>
          <target state="translated">注：これは &lt;code&gt;(entry =&amp;gt; 'FFFF ; [.FFFE.0020.0005.FFFF]')&lt;/code&gt; と同等です。 &lt;code&gt;U+FFFF&lt;/code&gt; 以外の文字は、 &lt;code&gt;entry&lt;/code&gt; によって調整できます。</target>
        </trans-unit>
        <trans-unit id="0455de4d41cf68eed0be49449f753fd507ce98c3" translate="yes" xml:space="preserve">
          <source>Note: This method is only available if you are running zlib 1.0.6 or better.</source>
          <target state="translated">注意:この方法は zlib 1.0.6 以上を実行している場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="d780f7fe644c15c8098f2ec3e635333d65dac99d" translate="yes" xml:space="preserve">
          <source>Note: This method was required from Math::BigInt version 1.78, but the required API version number was not incremented, so there are older libraries that support API version 1, but do not support &lt;code&gt;_as_oct()&lt;/code&gt; .</source>
          <target state="translated">注：このメソッドはMath :: BigIntバージョン1.78から必要でしたが、必要なAPIバージョン番号が増分されていなかったため、APIバージョン1をサポートしているが &lt;code&gt;_as_oct()&lt;/code&gt; をサポートしていない古いライブラリがあります。</target>
        </trans-unit>
        <trans-unit id="274ea739a039d51482491c2164a8ca995639e789" translate="yes" xml:space="preserve">
          <source>Note: This needs Math::BigInt::GMP installed.</source>
          <target state="translated">注意:これは Math::BigInt::GMP がインストールされている必要があります。</target>
        </trans-unit>
        <trans-unit id="4599f377b1aba694d82426f6489f702538a8bb33" translate="yes" xml:space="preserve">
          <source>Note: When $FTP_PASSIVE is true, &lt;code&gt;ncftp&lt;/code&gt; will not be used to fetch files, since passive mode can only be set interactively for this binary</source>
          <target state="translated">注：$ FTP_PASSIVEがtrueの場合、パッシブモードはこのバイナリに対してインタラクティブにのみ設定できるため、 &lt;code&gt;ncftp&lt;/code&gt; はファイルのフェッチに使用されません</target>
        </trans-unit>
        <trans-unit id="44108fdd62b6b987695d83d0e866909c28a68c2f" translate="yes" xml:space="preserve">
          <source>Note: When called in list context, $isdst, the last value returned by gmtime, is always &lt;code&gt;0&lt;/code&gt; . There is no Daylight Saving Time in GMT.</source>
          <target state="translated">注：リストコンテキストで呼び出された場合、gmtimeによって返される最後の値である$ isdstは常に &lt;code&gt;0&lt;/code&gt; です。GMTには夏時間はありません。</target>
        </trans-unit>
        <trans-unit id="16d88e8a12adc9d5938fa24b2acb9b6eac47525d" translate="yes" xml:space="preserve">
          <source>Note: When called in list context, $isdst, the last value returned by gmtime, is always &lt;code&gt;0&lt;/code&gt;. There is no Daylight Saving Time in GMT.</source>
          <target state="translated">注：リストコンテキストで呼び出された場合、gmtimeによって返される最後の値である$ isdstは常に &lt;code&gt;0&lt;/code&gt; です。GMTには夏時間はありません。</target>
        </trans-unit>
        <trans-unit id="326b015af2e44c2db6ac3ed72580a47dac6e9403" translate="yes" xml:space="preserve">
          <source>Note: Works also for subclasses like &lt;a href=&quot;bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;. Each class has its own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="translated">注：&lt;a href=&quot;bigfloat&quot;&gt;Math :: BigFloat&lt;/a&gt;などのサブクラスでも機能します。各クラスには、Math :: BigIntから分離された独自のグローバルがありますが、Math :: BigIntをサブクラス化し、サブクラスエイリアスのグローバルをMath :: BigIntからのグローバルに作成することが可能です。</target>
        </trans-unit>
        <trans-unit id="f017c3d2e2508b08d7d59dc7727c02f156768d30" translate="yes" xml:space="preserve">
          <source>Note: Works also for subclasses like Math::BigFloat. Each class has it's own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</source>
          <target state="translated">注意:Math::BigFloat のようなサブクラスでも動作します。各クラスは Math::BigInt から分離された独自のグローバルを持っていますが、Math::BigInt をサブクラス化して、サブクラスのグローバルを Math::BigInt からのグローバルのエイリアスにすることができます。</target>
        </trans-unit>
        <trans-unit id="eb7b6e328c4f81408ff1a139ac8eaf2a380ca671" translate="yes" xml:space="preserve">
          <source>Note: You have to modify your man.conf file to search for manpages in the /ade/lib/perl5/man/man3 directory, or the man pages for the perl library will not be found.</source>
          <target state="translated">注意:/ade/lib/perl5/man/man3 ディレクトリにある man ページを検索するように man.conf ファイルを修正しなければなりません。</target>
        </trans-unit>
        <trans-unit id="c7379f095d2d22d8a649d49142d79afd3489318b" translate="yes" xml:space="preserve">
          <source>Note: You probably want to use &lt;a href=&quot;#accuracy%28%29&quot;&gt;&quot;accuracy()&quot;&lt;/a&gt; instead. With &lt;a href=&quot;#accuracy%28%29&quot;&gt;&quot;accuracy()&quot;&lt;/a&gt; you set the number of digits each result should have, with &lt;a href=&quot;#precision%28%29&quot;&gt;&quot;precision()&quot;&lt;/a&gt; you set the place where to round!</source>
          <target state="translated">注：代わりに&lt;a href=&quot;#accuracy%28%29&quot;&gt;「accuracy（）」&lt;/a&gt;を使用することをお勧めします。&lt;a href=&quot;#accuracy%28%29&quot;&gt;「精度（）」&lt;/a&gt;あなたと、それぞれの結果が持つべき桁数を設定する&lt;a href=&quot;#precision%28%29&quot;&gt;「）（精度」&lt;/a&gt;あなたはラウンドに場所を設定しました！</target>
        </trans-unit>
        <trans-unit id="1e7dc83f4d6c9a8b0d3c0b5924caf0806f95cf13" translate="yes" xml:space="preserve">
          <source>Note: You probably want to use &lt;a href=&quot;#accuracy()&quot;&gt;accuracy()&lt;/a&gt; instead. With &lt;a href=&quot;#accuracy()&quot;&gt;accuracy()&lt;/a&gt; you set the number of digits each result should have, with &lt;a href=&quot;#precision()&quot;&gt;precision()&lt;/a&gt; you set the place where to round!</source>
          <target state="translated">注：代わりにおそらく&lt;a href=&quot;#accuracy()&quot;&gt;precision（）&lt;/a&gt;を使用する必要があります。&lt;a href=&quot;#accuracy()&quot;&gt;精度（）&lt;/a&gt;あなたが、それぞれの結果が持つべき桁数を設定する&lt;a href=&quot;#precision()&quot;&gt;（）精度&lt;/a&gt;どこラウンドに場所を設定しました！</target>
        </trans-unit>
        <trans-unit id="d6d84b096f34f15c07402e918e2379728ec1301e" translate="yes" xml:space="preserve">
          <source>Note: choosing anyhing but 'yes' for this option will need Devel::DistnameInfo being installed for taking effect.</source>
          <target state="translated">注意:このオプションに 'yes' 以外を選択すると、有効になるには Devel::DistnameInfo がインストールされている必要があります。</target>
        </trans-unit>
        <trans-unit id="e2e12b5547fb4733f2385741dc84813859d3dd2e" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling&lt;/code&gt; also disables &lt;code&gt;bundling_override&lt;/code&gt; .</source>
          <target state="translated">注：無効に &lt;code&gt;bundling&lt;/code&gt; も無効 &lt;code&gt;bundling_override&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="ec5d46114c3638c4121c26c4c917e18fe48cdbc0" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling&lt;/code&gt; also disables &lt;code&gt;bundling_override&lt;/code&gt;.</source>
          <target state="translated">注：無効に &lt;code&gt;bundling&lt;/code&gt; も無効 &lt;code&gt;bundling_override&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="2dd410d2fbf3af306729dd64454481dab1a79d72" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling_override&lt;/code&gt; also disables &lt;code&gt;bundling&lt;/code&gt; .</source>
          <target state="translated">注：無効 &lt;code&gt;bundling_override&lt;/code&gt; はまた、無効 &lt;code&gt;bundling&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b2b48dd6d444bef92ae0ebb4e15997ba10818fb" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;bundling_override&lt;/code&gt; also disables &lt;code&gt;bundling&lt;/code&gt;.</source>
          <target state="translated">注：無効 &lt;code&gt;bundling_override&lt;/code&gt; はまた、無効 &lt;code&gt;bundling&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d840b005bb09f5240a311bf0713bd815028ba795" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case&lt;/code&gt; also disables &lt;code&gt;ignore_case_always&lt;/code&gt; .</source>
          <target state="translated">注： &lt;code&gt;ignore_case&lt;/code&gt; を無効にすると、ignore_case_alwaysも無効になり &lt;code&gt;ignore_case_always&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57bf189846e7e76bf8482fb5e477ff8f8dfe7b29" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case&lt;/code&gt; also disables &lt;code&gt;ignore_case_always&lt;/code&gt;.</source>
          <target state="translated">注： &lt;code&gt;ignore_case&lt;/code&gt; を無効にすると、ignore_case_alwaysも無効になり &lt;code&gt;ignore_case_always&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0642b203ace91a0c6c6c1c85ec87408d95d51b9c" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case_always&lt;/code&gt; also disables &lt;code&gt;ignore_case&lt;/code&gt; .</source>
          <target state="translated">注： &lt;code&gt;ignore_case_always&lt;/code&gt; を無効にすると、ignore_caseも無効になり &lt;code&gt;ignore_case&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1946def9c6cdf88287ce6da335562aa361a54824" translate="yes" xml:space="preserve">
          <source>Note: disabling &lt;code&gt;ignore_case_always&lt;/code&gt; also disables &lt;code&gt;ignore_case&lt;/code&gt;.</source>
          <target state="translated">注： &lt;code&gt;ignore_case_always&lt;/code&gt; を無効にすると、ignore_caseも無効になり &lt;code&gt;ignore_case&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc88cd76d85c82ca33031114b858a78699d8dccf" translate="yes" xml:space="preserve">
          <source>Note: if the &lt;code&gt;applypatch&lt;/code&gt; program is installed and &lt;code&gt;CPAN::Config&lt;/code&gt; knows about it &lt;b&gt;and&lt;/b&gt; a patch is written by the &lt;code&gt;makepatch&lt;/code&gt; program, then &lt;code&gt;CPAN.pm&lt;/code&gt; lets &lt;code&gt;applypatch&lt;/code&gt; apply the patch. Both &lt;code&gt;makepatch&lt;/code&gt; and &lt;code&gt;applypatch&lt;/code&gt; are available from CPAN in the &lt;code&gt;JV/makepatch-*&lt;/code&gt; distribution.</source>
          <target state="translated">場合：注 &lt;code&gt;applypatch&lt;/code&gt; プログラムがインストールされていると &lt;code&gt;CPAN::Config&lt;/code&gt; それについて知っている&lt;b&gt;し、&lt;/b&gt;パッチがで書かれている &lt;code&gt;makepatch&lt;/code&gt; プログラム、そして &lt;code&gt;CPAN.pm&lt;/code&gt; ができます &lt;code&gt;applypatch&lt;/code&gt; パッチを適用します。 &lt;code&gt;makepatch&lt;/code&gt; と &lt;code&gt;applypatch&lt;/code&gt; の両方は、 &lt;code&gt;JV/makepatch-*&lt;/code&gt; ディストリビューションのCPANから入手できます。</target>
        </trans-unit>
        <trans-unit id="22e2016ea85ed84ee62e9e8de3756c81d1bdf26a" translate="yes" xml:space="preserve">
          <source>Note: if the computation is expensive or the hash has many elements, you may want to look at the Schwartzian Transform to cache the computation results.</source>
          <target state="translated">注意:計算が高い場合やハッシュの要素数が多い場合は、計算結果をキャッシュするためにシュバルツ変換を見てみると良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="29df041b4a10cf81a3e0b4f7f89bd122aed969f0" translate="yes" xml:space="preserve">
          <source>Note: in most cases, particularly the &lt;a href=&quot;#Copy-Constructor&quot;&gt;&quot;Copy Constructor&quot;&lt;/a&gt;, this is unlikely to be appropriate behaviour.</source>
          <target state="translated">注：ほとんどの場合、特に&lt;a href=&quot;#Copy-Constructor&quot;&gt;「コピーコンストラクター」&lt;/a&gt;では、これが適切な動作になる可能性はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="3a9aff6bff93b9cbae48137737db8e4d2881dc6a" translate="yes" xml:space="preserve">
          <source>Note: in most cases, particularly the &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;, this is unlikely to be appropriate behaviour.</source>
          <target state="translated">注：ほとんどの場合、特に&lt;a href=&quot;#Copy-Constructor&quot;&gt;コピーコンストラクター&lt;/a&gt;では、これが適切な動作になることはほとんどありません。</target>
        </trans-unit>
        <trans-unit id="1b33df475ae354b7fb1f3b9c4cafb1584ab7a3e6" translate="yes" xml:space="preserve">
          <source>Note: the behaviour described in this section can be disabled by setting &lt;code&gt;fallback&lt;/code&gt; to FALSE (see &lt;a href=&quot;#fallback&quot;&gt;&quot;fallback&quot;&lt;/a&gt;).</source>
          <target state="translated">注：このセクションで説明する動作は、 &lt;code&gt;fallback&lt;/code&gt; をFALSEに設定することで無効にできます（&lt;a href=&quot;#fallback&quot;&gt;「フォールバック」を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="9947057045b064f583a71d886808757ed0fa7848" translate="yes" xml:space="preserve">
          <source>Note: the behaviour described in this section can be disabled by setting &lt;code&gt;fallback&lt;/code&gt; to FALSE (see &lt;a href=&quot;#fallback&quot;&gt;fallback&lt;/a&gt;).</source>
          <target state="translated">注：このセクションで説明した動作を設定することで無効にすることができ &lt;code&gt;fallback&lt;/code&gt; （参照FALSEに&lt;a href=&quot;#fallback&quot;&gt;フォールバック&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="62b2ca1948759ac7f684eceb704736b180023c07" translate="yes" xml:space="preserve">
          <source>Note: the exact nature of the fancy specifications like &lt;code&gt;&quot;&amp;gt;= 1.2, != 1.5, &amp;lt; 2.0&quot;&lt;/code&gt; is subject to change. Advance notice will be given here. The simple specifications like &lt;code&gt;&quot;1.2&quot;&lt;/code&gt; will not change in format.</source>
          <target state="translated">注： &lt;code&gt;&quot;&amp;gt;= 1.2, != 1.5, &amp;lt; 2.0&quot;&lt;/code&gt; などの派手な仕様の正確な性質は変更される可能性があります。ここで事前に通知します。 &lt;code&gt;&quot;1.2&quot;&lt;/code&gt; ような単純な仕様はフォーマットが変更されません。</target>
        </trans-unit>
        <trans-unit id="11ca88f5d5dc89450fb8556231f6b8efe29797ea" translate="yes" xml:space="preserve">
          <source>Note: the preceding paragraph describes what happens when Perl autogenerates the copy constructor for an object based on a scalar. For other cases, see &lt;a href=&quot;#Copy-Constructor&quot;&gt;&quot;Copy Constructor&quot;&lt;/a&gt;.</source>
          <target state="translated">注：前の段落では、Perlがスカラーに基づいてオブジェクトのコピーコンストラクターを自動生成するとどうなるかについて説明しています。その他の場合は、&lt;a href=&quot;#Copy-Constructor&quot;&gt;「コピーコンストラクタ」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ac4c5c965d1db592391a1881313b9980c7ebcd67" translate="yes" xml:space="preserve">
          <source>Note: the preceding paragraph describes what happens when Perl autogenerates the copy constructor for an object based on a scalar. For other cases, see &lt;a href=&quot;#Copy-Constructor&quot;&gt;Copy Constructor&lt;/a&gt;.</source>
          <target state="translated">注：前の段落では、Perlがスカラーに基づいてオブジェクトのコピーコンストラクターを自動生成するとどうなるかについて説明しました。その他の場合については、「&lt;a href=&quot;#Copy-Constructor&quot;&gt;コピーコンストラクター&lt;/a&gt;」を参照してください。</target>
        </trans-unit>
        <trans-unit id="7c92c751ce0bf80febdd6e38233f67cab09e15ef" translate="yes" xml:space="preserve">
          <source>Note: this config variable is deprecated and will be removed in a future version of CPAN.pm. It will be replaced with the conventions around the family of $LANG and $LC_* environment variables.</source>
          <target state="translated">注意:この設定変数は非推奨で、CPAN.pm の将来のバージョンでは削除される予定です。この変数は、$LANG と $LC_*環境変数のファミリーの規約に置き換えられます。</target>
        </trans-unit>
        <trans-unit id="f59653e6422c3ee295a49f06549f34191c33d033" translate="yes" xml:space="preserve">
          <source>Note: this feature is still in alpha state and may change in future versions of CPAN.pm</source>
          <target state="translated">注意:この機能はまだアルファ状態であり、CPAN.pm の将来のバージョンで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="fb52a79f4bb85f30f68ef37f28e8e379caceb4dc" translate="yes" xml:space="preserve">
          <source>Note: this function has not been specified by POSIX since 1990 and is included only for backwards compatibility. New code should use &lt;a href=&quot;perlfunc#getlogin&quot;&gt;&lt;code&gt;getlogin()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">注：この関数は1990年以降POSIXによって指定されておらず、下位互換性のためにのみ含まれています。新しいコードでは、代わりに&lt;a href=&quot;perlfunc#getlogin&quot;&gt; &lt;code&gt;getlogin()&lt;/code&gt; &lt;/a&gt;を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="8a8ebc616c42eb9b0dd9d07b466e6d2d32bcecea" translate="yes" xml:space="preserve">
          <source>Note: this is a reasonably new addition to the family of socket functions, so all systems may not support this yet. If it is unsupported by the system, an attempt to use this method will abort the program.</source>
          <target state="translated">注意:このメソッドはソケット関数に追加されたばかりのものなので、すべてのシステムではまだサポートされていないかもしれません。システムがサポートしていない場合、このメソッドを使おうとするとプログラムが中止されます。</target>
        </trans-unit>
        <trans-unit id="b27494dc8cf34b92a043ab41a4f74f0c9f2a3ea4" translate="yes" xml:space="preserve">
          <source>Note: this mechanism is not used when use_sqlite is on and SQLLite is running.</source>
          <target state="translated">注意:use_sqliteがオンでSQLLiteが実行されている場合、このメカニズムは使用されません。</target>
        </trans-unit>
        <trans-unit id="13c903538586e11c4ad7bb5502c59a872fdcc9eb" translate="yes" xml:space="preserve">
          <source>Note: this method of setting config variables often provides more explanation about the functioning of a variable than the manpage.</source>
          <target state="translated">注意:この設定変数の設定方法は、manpageよりも多くの場合、変数の機能についての説明を提供しています。</target>
        </trans-unit>
        <trans-unit id="56d243ce60967f77fdfcf106f1d4d7d0a8b3112b" translate="yes" xml:space="preserve">
          <source>Note: using a static or global variable to store the SV isn't thread-safe. You can either use the &lt;code&gt;MY_CXT&lt;/code&gt; mechanism documented in &lt;a href=&quot;perlxs#Safely-Storing-Static-Data-in-XS&quot;&gt;&quot;Safely Storing Static Data in XS&quot; in perlxs&lt;/a&gt; which is fast, or store the values in perl global variables, using get_sv(), which is much slower.</source>
          <target state="translated">注：静的変数またはグローバル変数を使用してSVを格納することは、スレッドセーフではありません。&lt;a href=&quot;perlxs#Safely-Storing-Static-Data-in-XS&quot;&gt;「XSでの静的データの安全な保存」に&lt;/a&gt;記載されている &lt;code&gt;MY_CXT&lt;/code&gt; メカニズムをperlxsで高速に使用するか、get_sv（）を使用して値をperlグローバル変数に格納することができます。</target>
        </trans-unit>
        <trans-unit id="532592c5b33f1b1b988a3bcb06f60ee822f44348" translate="yes" xml:space="preserve">
          <source>Note: when this field is true, post-configuration prerequisites are not guaranteed to bear any relation whatsoever to those stated in the metadata, and relying on them doing so is an error. See also &lt;a href=&quot;#Prerequisites-for-dynamically-configured-distributions&quot;&gt;&quot;Prerequisites for dynamically configured distributions&quot;&lt;/a&gt; in the implementors' notes.</source>
          <target state="translated">注：このフィールドがtrueの場合、構成後の前提条件がメタデータに記載されているものとの関係を保持することは保証されておらず、そうすることに依存することはエラーです。実装者のメモの&lt;a href=&quot;#Prerequisites-for-dynamically-configured-distributions&quot;&gt;「動的に構成さ&lt;/a&gt;れたディストリビューションの前提条件」も参照してください。</target>
        </trans-unit>
        <trans-unit id="20d6330232e8dab848178ce084694142fca2d628" translate="yes" xml:space="preserve">
          <source>Note: you can define up to 20 conversion shortcuts in the gdb section.</source>
          <target state="translated">注意:gdbセクションでは、20個までの変換ショートカットを定義することができます。</target>
        </trans-unit>
        <trans-unit id="1f83b80ea2831e263f522f29c3cbd52e6213eb57" translate="yes" xml:space="preserve">
          <source>Noted explicit support for 'perl' in prerequisites</source>
          <target state="translated">前提条件で 'perl' を明示的にサポートしていることに注目</target>
        </trans-unit>
        <trans-unit id="8922b61958be2a8d272cbf3db875ad134d3a3576" translate="yes" xml:space="preserve">
          <source>Noted that the &lt;a href=&quot;#distribution_type&quot;&gt;&quot;distribution_type&quot;&lt;/a&gt; field is basically meaningless, and shouldn't really be used.</source>
          <target state="translated">述べ&lt;a href=&quot;#distribution_type&quot;&gt;、「distribution_type」&lt;/a&gt;フィールドは、基本的には無意味であり、実際に使用すべきではありません。</target>
        </trans-unit>
        <trans-unit id="03baeca66519780c80b0846ea1bac63e81b58e40" translate="yes" xml:space="preserve">
          <source>Notepad++</source>
          <target state="translated">Notepad++</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="87cfdde76898dd31c7d07ddb886016189457f68b" translate="yes" xml:space="preserve">
          <source>Notes for users of Compress::Zlib version 1</source>
          <target state="translated">Compress::Zlib バージョン 1 をご利用の方への注意事項</target>
        </trans-unit>
        <trans-unit id="60a645effd583025acef3ba80266a7c7168ec1f6" translate="yes" xml:space="preserve">
          <source>Notes on 64-bit Windows</source>
          <target state="translated">64ビットWindowsの注意点</target>
        </trans-unit>
        <trans-unit id="d65415edefc0ebcdd623f3ba5f7c329eeb91e917" translate="yes" xml:space="preserve">
          <source>Notes on Implementing Pod Processors</source>
          <target state="translated">ポッドプロセッサを実装する際の注意点</target>
        </trans-unit>
        <trans-unit id="8f983f019ad00a2df5935875ac129acc0e4daab6" translate="yes" xml:space="preserve">
          <source>Notes, typically rendered to STDOUT.</source>
          <target state="translated">ノート、通常はSTDOUTにレンダリングされます。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="25796957df5d5e9f79fe37e61f8cb9ca4c5a759a" translate="yes" xml:space="preserve">
          <source>Nothing in void context (obviously).</source>
          <target state="translated">ボイドコンテキストには何もない(明らかに)。</target>
        </trans-unit>
        <trans-unit id="945c9d82ead4c25705962fc07336d3f2e51d1d62" translate="yes" xml:space="preserve">
          <source>Nothing is documented.</source>
          <target state="translated">何も文書化されていない。</target>
        </trans-unit>
        <trans-unit id="59fb6d9ec5289836c61476dab6f50fac2154944a" translate="yes" xml:space="preserve">
          <source>Nothing is exported by default. The following tags can be used to have large sets of symbols exported: &lt;code&gt;&quot;:Func&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FuncA&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FuncW&quot;&lt;/code&gt;, &lt;code&gt;&quot;:Misc&quot;&lt;/code&gt;, &lt;code&gt;&quot;:DDD_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:DRIVE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_ATTRIBUTE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_FLAG_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_SHARE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FILE_TYPE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FS_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:FSCTL_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:HANDLE_FLAG_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:IOCTL_STORAGE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:IOCTL_DISK_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:GENERIC_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:MEDIA_TYPE&quot;&lt;/code&gt;, &lt;code&gt;&quot;:MOVEFILE_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:SECURITY_&quot;&lt;/code&gt;, &lt;code&gt;&quot;:SEM_&quot;&lt;/code&gt;, and &lt;code&gt;&quot;:PARTITION_&quot;&lt;/code&gt;.</source>
          <target state="translated">デフォルトでは何もエクスポートされません。次のタグを使用して、大量のシンボルセットをエクスポートできます： &lt;code&gt;&quot;:Func&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;:FuncA&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;:FuncW&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;:Misc&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;:DDD_&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;:DRIVE_&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;:FILE_&quot;&lt;/code&gt; FILE_ &quot;、 &lt;code&gt;&quot;:FILE_ATTRIBUTE_&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;:FILE_FLAG_&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;:FILE_SHARE_&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;:FILE_TYPE_&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;:FS_&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;:FSCTL_&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;:HANDLE_FLAG_&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;:IOCTL_STORAGE_&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;:IOCTL_DISK_&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;:GENERIC_&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;:MEDIA_TYPE&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;:MOVEFILE_&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;:SECURITY_&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;:SEM_&quot;&lt;/code&gt; 、および &lt;code&gt;&quot;:PARTITION_&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e7b42ab74a17af97a37c506518ea42d6cc1e569" translate="yes" xml:space="preserve">
          <source>Nothing is exported by default. You must specify which methods to import, or use the ':ALL' tag.</source>
          <target state="translated">デフォルトでは何もエクスポートされません。インポートするメソッドを指定するか、':ALL' タグを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="b2dc97487d39ef5241bb9dbe74fe894c19016958" translate="yes" xml:space="preserve">
          <source>Nothing is exported. Use fully qualified variable names.</source>
          <target state="translated">何もエクスポートされません。完全修飾された変数名を使用してください。</target>
        </trans-unit>
        <trans-unit id="ab9e54f52e7f7c5402697de9fbd9467e290f0479" translate="yes" xml:space="preserve">
          <source>Nothing too unusual here. You can easily do this if you have a cross-compiler available; A usual Configure invocation when targetting a Solaris x86 looks something like this:</source>
          <target state="translated">ここでは特に変わったことはありません。Solaris x86 をターゲットにしたときの通常の Configure 呼び出しは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="a7b38ed2457b5a248dfea4058e6120cef0a01220" translate="yes" xml:space="preserve">
          <source>Nothing worked - die.</source>
          <target state="translated">何も機能していない-死ね。</target>
        </trans-unit>
        <trans-unit id="1b3f141ab87179d0755abc1d4da67f0c04e3ab7c" translate="yes" xml:space="preserve">
          <source>Nothing.</source>
          <target state="translated">Nothing.</target>
        </trans-unit>
        <trans-unit id="df845adff4c3af8c8d0292f7522181ec1444d9f8" translate="yes" xml:space="preserve">
          <source>Notice also that the warning is reported at the line where the object is first used.</source>
          <target state="translated">警告は、オブジェクトが最初に使用された行で報告されることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="45dd83b2a71782cbd9802b63f62a266f8d43184c" translate="yes" xml:space="preserve">
          <source>Notice also the &lt;code&gt;grok_bin&lt;/code&gt; , &lt;code&gt;grok_hex&lt;/code&gt; , and &lt;code&gt;grok_oct&lt;/code&gt; functions in</source>
          <target state="translated">の &lt;code&gt;grok_bin&lt;/code&gt; 、 &lt;code&gt;grok_hex&lt;/code&gt; 、および &lt;code&gt;grok_oct&lt;/code&gt; 関数にも注意してください</target>
        </trans-unit>
        <trans-unit id="49ebd14076be592270a5d4f9b224fa4d4b89d099" translate="yes" xml:space="preserve">
          <source>Notice also the &lt;code&gt;grok_bin&lt;/code&gt;, &lt;code&gt;grok_hex&lt;/code&gt;, and &lt;code&gt;grok_oct&lt;/code&gt; functions in</source>
          <target state="translated">の &lt;code&gt;grok_bin&lt;/code&gt; 、 &lt;code&gt;grok_hex&lt;/code&gt; 、および &lt;code&gt;grok_oct&lt;/code&gt; 関数にも注意してください。</target>
        </trans-unit>
        <trans-unit id="b0adcbd1247e60edf664089189052bb3a50dcbe1" translate="yes" xml:space="preserve">
          <source>Notice here the LEN is 10. (It may differ on your platform.) Extend the length of the string to one less than 10, and do a substitution:</source>
          <target state="translated">ここでの LEN は 10 であることに注意してください。(あなたのプラットフォームによっては異なるかもしれません。)文字列の長さを10以下に伸ばして、代用してください。</target>
        </trans-unit>
        <trans-unit id="4c9ef71a088f9de85175aa974029dc0d63466c4b" translate="yes" xml:space="preserve">
          <source>Notice how at no point does the value &quot;private&quot; get printed. That's because $var only has that value within the block of the lexical() function, and it is hidden from the called subroutine.</source>
          <target state="translated">private &quot;という値がどこにも表示されていないことに注目してください。これは $var がその値を持つのは lexical()関数のブロック内だけであり、呼び出されたサブルーチンからは隠されているからです。</target>
        </trans-unit>
        <trans-unit id="77c47c9daa0e34a0be8b051a194ec532aabac71d" translate="yes" xml:space="preserve">
          <source>Notice how both parameters to &lt;code&gt;globmap&lt;/code&gt; are strings that are delimited by &amp;lt;&amp;gt;. This is done to make them look more like file globs - it is just syntactic sugar, but it can be handy when you want the strings to be visually distinctive. The enclosing &amp;lt;&amp;gt; are optional, so you don't have to use them - in fact the first thing globmap will do is remove these delimiters if they are present.</source>
          <target state="translated">&lt;code&gt;globmap&lt;/code&gt; の両方のパラメーターが、&amp;lt;&amp;gt;で区切られた文字列であることに注意してください。これは、ファイルグロブのように見えるようにするために行われます。これは単なる構文上の砂糖ですが、文字列を視覚的に区別したい場合に便利です。囲み&amp;lt;&amp;gt;はオプションであるため、使用する必要はありません。実際、グロブマップが最初に行うことは、これらの区切り文字が存在する場合はそれらを削除することです。</target>
        </trans-unit>
        <trans-unit id="ad17ed98712f08fde401be783e01fddfe4c94277" translate="yes" xml:space="preserve">
          <source>Notice how the return value from the &lt;code&gt;new&lt;/code&gt; constructor is used as a filehandle in the &lt;code&gt;while&lt;/code&gt; loop? That's what's called an</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; コンストラクタからの戻り値が、 &lt;code&gt;while&lt;/code&gt; ループのファイルハンドルとしてどのように使用されているかに注意してください。それがいわゆる</target>
        </trans-unit>
        <trans-unit id="ca8aa6acc2aa1f6723f38ec594c204d602c7b4d3" translate="yes" xml:space="preserve">
          <source>Notice how the second substitution stopped matching as soon as it encountered &quot;y &quot;. The &lt;code&gt;*?&lt;/code&gt; quantifier effectively tells the regular expression engine to find a match as quickly as possible and pass control on to whatever is next in line, as you would if you were playing hot potato.</source>
          <target state="translated">2番目の置換が「y」に遭遇するとすぐにマッチングが停止したことに注意してください。 &lt;code&gt;*?&lt;/code&gt; 量指定子は、ホットポテトをプレイしている場合と同様に、正規表現エンジンに一致をできるだけ早く見つけ、次の行に制御を渡すように効果的に指示します。</target>
        </trans-unit>
        <trans-unit id="fa6e91727e4ee365f7ee9460c080c792faaad3e9" translate="yes" xml:space="preserve">
          <source>Notice how this (unprototyped) function doesn't care whether it was passed real scalars or arrays. Perl sees all arguments as one big, long, flat parameter list in &lt;code&gt;@_&lt;/code&gt; . This is one area where Perl's simple argument-passing style shines. The &lt;code&gt;upcase()&lt;/code&gt; function would work perfectly well without changing the &lt;code&gt;upcase()&lt;/code&gt; definition even if we fed it things like this:</source>
          <target state="translated">この（プロトタイプ化されていない）関数は、実際のスカラーまたは配列のどちらが渡されたかに注意しないことに注意してください。Perlはすべての引数を &lt;code&gt;@_&lt;/code&gt; 内の1つの大きくてフラットなパラメーターリストと見なします。これは、Perlの単純な引数渡しスタイルが優れている1つの領域です。 &lt;code&gt;upcase()&lt;/code&gt; 関数は、変更することなく完璧に動作します &lt;code&gt;upcase()&lt;/code&gt; 我々はそれをこのようなものを与えても、定義：</target>
        </trans-unit>
        <trans-unit id="8e53ec417cfc4ffd2c3f588c8323f91d879ae5ac" translate="yes" xml:space="preserve">
          <source>Notice how this (unprototyped) function doesn't care whether it was passed real scalars or arrays. Perl sees all arguments as one big, long, flat parameter list in &lt;code&gt;@_&lt;/code&gt;. This is one area where Perl's simple argument-passing style shines. The &lt;code&gt;upcase()&lt;/code&gt; function would work perfectly well without changing the &lt;code&gt;upcase()&lt;/code&gt; definition even if we fed it things like this:</source>
          <target state="translated">この（プロトタイプ化されていない）関数が、実際のスカラーまたは配列のどちらを渡されたかを気にしないことに注意してください。Perlは、すべての引数を &lt;code&gt;@_&lt;/code&gt; 内の1つの大きくて長くてフラットなパラメーターリストと見なします。これは、Perlの単純な引数受け渡しスタイルが優れている領域の1つです。 &lt;code&gt;upcase()&lt;/code&gt; 関数は、変更することなく完璧に動作します &lt;code&gt;upcase()&lt;/code&gt; 我々はそれをこのようなものを与えても、定義：</target>
        </trans-unit>
        <trans-unit id="0b9d5a5851dd2e8a235f599f76ec00c3eeb19104" translate="yes" xml:space="preserve">
          <source>Notice that &quot;hello&quot; is only printed once, as when Perl sees that the sixth iteration of the outermost &lt;code&gt;(?:)*&lt;/code&gt; matches a zero-length string, it stops the &lt;code&gt;&quot;*&quot;&lt;/code&gt;.</source>
          <target state="translated">Perlは、最も外側の &lt;code&gt;(?:)*&lt;/code&gt; :) *の6番目の反復が長さゼロの文字列と一致することを確認すると、 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 停止するため、「hello」は1回だけ出力されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4444833b9992f40fcab9e968725d8711a413e3d2" translate="yes" xml:space="preserve">
          <source>Notice that &quot;hello&quot; is only printed once, as when Perl sees that the sixth iteration of the outermost &lt;code&gt;(?:)*&lt;/code&gt; matches a zero-length string, it stops the &lt;code&gt;*&lt;/code&gt; .</source>
          <target state="translated">「hello」が1回だけ出力されることに注意してください。Perlが最も外側の &lt;code&gt;(?:)*&lt;/code&gt; の6番目の反復が長さ0の文字列と一致することを確認すると、 &lt;code&gt;*&lt;/code&gt; を停止します。</target>
        </trans-unit>
        <trans-unit id="64a5ba33762b8a3df62c02415bc8d0abd71b566d" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Dump()&lt;/code&gt; prints only elements 10 through 13 in the above code. The following code will print all of the elements.</source>
          <target state="translated">&lt;code&gt;Dump()&lt;/code&gt; は、上記のコードの要素10〜13のみを出力することに注意してください。次のコードは、すべての要素を出力します。</target>
        </trans-unit>
        <trans-unit id="e23423f7c29d56c0d20fc2f34471adb3aea96e69" translate="yes" xml:space="preserve">
          <source>Notice that a file glob pattern &lt;code&gt;*.tar.gz&lt;/code&gt; was used to match the &lt;code&gt;.tar.gz&lt;/code&gt; files, then a fairly similar regular expression was used in the substitute to allow the new filename to be created.</source>
          <target state="translated">ファイルグロブパターン &lt;code&gt;*.tar.gz&lt;/code&gt; を使用して &lt;code&gt;.tar.gz&lt;/code&gt; ファイルを照合した後、かなり類似した正規表現を代わりに使用して、新しいファイル名を作成できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="309a93ea449f47318d5d11f1a3d425f1bac00a22" translate="yes" xml:space="preserve">
          <source>Notice that because of the default behaviour of not doing any conversion upon input if there is no default layer, it is easy to mistakenly write code that keeps on expanding a file by repeatedly encoding the data:</source>
          <target state="translated">デフォルトのレイヤーがない場合は入力時に変換を行わないというデフォルトの振る舞いのため、誤ってデータを繰り返しエンコードしてファイルを展開し続けるコードを書きがちであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="45e2138036f16fd01c487cf4e8627bd64352166d" translate="yes" xml:space="preserve">
          <source>Notice that both times the &lt;code&gt;put&lt;/code&gt; method was used the record index was specified using a variable, &lt;code&gt;$i&lt;/code&gt; , rather than the literal value itself. This is because &lt;code&gt;put&lt;/code&gt; will return the record number of the inserted line via that parameter.</source>
          <target state="translated">&lt;code&gt;put&lt;/code&gt; メソッドが両方使用されたときに、リテラル値自体ではなく、変数 &lt;code&gt;$i&lt;/code&gt; を使用してレコードインデックスが指定されたことに注意してください。これは、 &lt;code&gt;put&lt;/code&gt; がそのパラメーターを介して挿入された行のレコード番号を返すためです。</target>
        </trans-unit>
        <trans-unit id="f8652fa23a6a85d8694e8c330d3634e47750ae09" translate="yes" xml:space="preserve">
          <source>Notice that both times the &lt;code&gt;put&lt;/code&gt; method was used the record index was specified using a variable, &lt;code&gt;$i&lt;/code&gt;, rather than the literal value itself. This is because &lt;code&gt;put&lt;/code&gt; will return the record number of the inserted line via that parameter.</source>
          <target state="translated">&lt;code&gt;put&lt;/code&gt; メソッドが使用されたときはどちらも、リテラル値自体ではなく、変数 &lt;code&gt;$i&lt;/code&gt; を使用してレコードインデックスが指定されていることに注意してください。これは、 &lt;code&gt;put&lt;/code&gt; がそのパラメーターを介して挿入された行のレコード番号を返すためです。</target>
        </trans-unit>
        <trans-unit id="d32eeef01ddef5893487334cb249c7d79c61492e" translate="yes" xml:space="preserve">
          <source>Notice that in these new test cases, the argument passed to round was a scalar variable. You might be wondering if you can round a constant or literal. To see what happens, temporarily add the following line to Mytest.t:</source>
          <target state="translated">これらの新しいテストケースでは、round に渡される引数がスカラ変数であることに注目してください。定数やリテラルを丸めることができるかどうか気になるかもしれません。どうなるかを確認するために、Mytest.tに以下の行を一時的に追加します。</target>
        </trans-unit>
        <trans-unit id="dc0dc28dfd6b3af28d5f3f343ec14d50dc738990" translate="yes" xml:space="preserve">
          <source>Notice that it was necessary to define the variable &lt;code&gt;ax&lt;/code&gt; . This is because the &lt;code&gt;ST&lt;/code&gt; macro expects it to exist. If we were in an XSUB it would not be necessary to define &lt;code&gt;ax&lt;/code&gt; as it is already defined for us.</source>
          <target state="translated">変数 &lt;code&gt;ax&lt;/code&gt; を定義する必要があることに注意してください。これは、 &lt;code&gt;ST&lt;/code&gt; マクロがそれが存在することを期待しているためです。XSUBを使用している場合、 &lt;code&gt;ax&lt;/code&gt; はすでに定義されているため、axを定義する必要はありません。</target>
        </trans-unit>
        <trans-unit id="785ded97619f1dd92d03821ef64bfb7475388f4f" translate="yes" xml:space="preserve">
          <source>Notice that it was necessary to define the variable &lt;code&gt;ax&lt;/code&gt;. This is because the &lt;code&gt;ST&lt;/code&gt; macro expects it to exist. If we were in an XSUB it would not be necessary to define &lt;code&gt;ax&lt;/code&gt; as it is already defined for us.</source>
          <target state="translated">変数 &lt;code&gt;ax&lt;/code&gt; を定義する必要があることに注意してください。これは、 &lt;code&gt;ST&lt;/code&gt; マクロが存在することを想定しているためです。XSUBにいる場合は、すでに定義されている &lt;code&gt;ax&lt;/code&gt; を定義する必要はありません。</target>
        </trans-unit>
        <trans-unit id="5a57f1413b4aba3b4429663d2d0603ce91191839" translate="yes" xml:space="preserve">
          <source>Notice that most of the metacharacters lose their special meaning when they occur in a bracketed character class, except &lt;code&gt;&quot;^&quot;&lt;/code&gt; has a different meaning when it is at the beginning of such a class. And &lt;code&gt;&quot;-&quot;&lt;/code&gt; and &lt;code&gt;&quot;]&quot;&lt;/code&gt; are metacharacters only at restricted positions within bracketed character classes; while &lt;code&gt;&quot;}&quot;&lt;/code&gt; is a metacharacter only when closing a special construct started by &lt;code&gt;&quot;{&quot;&lt;/code&gt;.</source>
          <target state="translated">ほとんどのメタ文字は、括弧で囲まれた文字クラスで発生すると特別な意味を失うことに注意してください。ただし、 &lt;code&gt;&quot;^&quot;&lt;/code&gt; は、そのようなクラスの先頭にある場合は異なる意味を持ちます。また、 &lt;code&gt;&quot;-&quot;&lt;/code&gt; と &lt;code&gt;&quot;]&quot;&lt;/code&gt; は、括弧で囲まれた文字クラス内の制限された位置にあるメタ文字です。一方、 &lt;code&gt;&quot;}&quot;&lt;/code&gt; は、 &lt;code&gt;&quot;{&quot;&lt;/code&gt; 始まる特別な構造を閉じる場合にのみメタ文字です。</target>
        </trans-unit>
        <trans-unit id="4559301041ec62ea61a8a1fd68eda86e54b3ac68" translate="yes" xml:space="preserve">
          <source>Notice that only literals (string or regular expression) having only legacy code points are affected: if you mix data like this</source>
          <target state="translated">レガシーコードポイントのみを持つリテラル(文字列や正規表現)だけが影響を受けることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c0f86b253bff23ee24ee05dba74dabc635ca28ee" translate="yes" xml:space="preserve">
          <source>Notice that the core &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; maybe rounding rather than truncating. What this means is that the core &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; may be reporting the time as one second later than &lt;code&gt;gettimeofday()&lt;/code&gt; and &lt;code&gt;Time::HiRes::time()&lt;/code&gt; .</source>
          <target state="translated">コアの &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; が切り捨てられるのではなく、丸められる可能性があることに注意してください。これは、コア &lt;code&gt;&lt;a href=&quot;../functions/time&quot;&gt;time()&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;gettimeofday()&lt;/code&gt; および &lt;code&gt;Time::HiRes::time()&lt;/code&gt; よりも1秒遅れて時刻を報告している可能性があることを意味します。</target>
        </trans-unit>
        <trans-unit id="786dfe37f34edb4a05a168a69eef1c7edef1b6b6" translate="yes" xml:space="preserve">
          <source>Notice that the core &lt;code&gt;time()&lt;/code&gt; maybe rounding rather than truncating. What this means is that the core &lt;code&gt;time()&lt;/code&gt; may be reporting the time as one second later than &lt;code&gt;gettimeofday()&lt;/code&gt; and &lt;code&gt;Time::HiRes::time()&lt;/code&gt;.</source>
          <target state="translated">コア &lt;code&gt;time()&lt;/code&gt; は、切り捨てではなく丸められる可能性があることに注意してください。これが意味するのは、コア &lt;code&gt;time()&lt;/code&gt; が &lt;code&gt;gettimeofday()&lt;/code&gt; および &lt;code&gt;Time::HiRes::time()&lt;/code&gt; よりも1秒遅れて時間を報告している可能性があるということです。</target>
        </trans-unit>
        <trans-unit id="6ed987720b9a7557460b46e7f6aeb89459c4da26" translate="yes" xml:space="preserve">
          <source>Notice that the final match matched &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;p&lt;/code&gt; , which a match without the &lt;code&gt;\G&lt;/code&gt; anchor would have done. Also note that the final match did not update &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; is only updated on a &lt;code&gt;/g&lt;/code&gt; match. If the final match did indeed match &lt;code&gt;p&lt;/code&gt; , it's a good bet that you're running a very old (pre-5.6.0) version of Perl.</source>
          <target state="translated">最終一致が &lt;code&gt;p&lt;/code&gt; ではなく &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; に一致したことに注意してください。これは、 &lt;code&gt;\G&lt;/code&gt; アンカーなしで一致した場合に起こりました。また、最終一致では &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; が更新されなかったことにも注意してください。 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;/g&lt;/code&gt; の一致でのみ更新されます。最終的な一致が実際に &lt;code&gt;p&lt;/code&gt; と一致した場合は、非常に古い（5.6.0より前の）バージョンのPerlを実行していることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="6288f2ae31ab09194ff1161b00b4b9878a3f7850" translate="yes" xml:space="preserve">
          <source>Notice that the final match matched &lt;code&gt;q&lt;/code&gt; instead of &lt;code&gt;p&lt;/code&gt;, which a match without the &lt;code&gt;\G&lt;/code&gt; anchor would have done. Also note that the final match did not update &lt;code&gt;pos&lt;/code&gt;. &lt;code&gt;pos&lt;/code&gt; is only updated on a &lt;code&gt;/g&lt;/code&gt; match. If the final match did indeed match &lt;code&gt;p&lt;/code&gt;, it's a good bet that you're running an ancient (pre-5.6.0) version of Perl.</source>
          <target state="translated">最終一致が &lt;code&gt;p&lt;/code&gt; ではなく &lt;code&gt;q&lt;/code&gt; に一致したことに注意してください。これは、 &lt;code&gt;\G&lt;/code&gt; アンカーなしの一致で実行されます。また、ファイナルマッチは &lt;code&gt;pos&lt;/code&gt; を更新しなかったことにも注意してください。 &lt;code&gt;pos&lt;/code&gt; は、 &lt;code&gt;/g&lt;/code&gt; の一致でのみ更新されます。最終一致が実際に &lt;code&gt;p&lt;/code&gt; と一致した場合は、古い（5.6.0より前の）バージョンのPerlを実行していることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="11b14f084bcfbcc93f4c728dc8c7063e0ac84985" translate="yes" xml:space="preserve">
          <source>Notice that the outer bracket type has changed, and so our access syntax has also changed. That's because unlike C, in perl you can't freely interchange arrays and references thereto. $ref_to_AoA is a reference to an array, whereas @AoA is an array proper. Likewise, &lt;code&gt;$AoA[2]&lt;/code&gt; is not an array, but an array ref. So how come you can write these:</source>
          <target state="translated">外側のブラケットタイプが変更されたため、アクセス構文も変更されています。これは、Cとは異なり、perlでは配列とその参照を自由に交換できないためです。 $ ref_to_AoAは配列への参照ですが、@ AoAは配列そのものです。同様に、 &lt;code&gt;$AoA[2]&lt;/code&gt; は配列ではなく、配列の参照です。では、どうしてこれらを書くことができるのでしょうか。</target>
        </trans-unit>
        <trans-unit id="4b4bf711776ec92640c01168664a95c86695d9a1" translate="yes" xml:space="preserve">
          <source>Notice that the programmer must supply the C code necessary to have the real rpcb_gettime() function called and to have the return values properly placed on the argument stack.</source>
          <target state="translated">プログラマは、実際の rpcb_gettime()関数が呼び出され、戻り値が引数スタックに適切に配置されるために必要な C コードを提供しなければならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="40afcceb911c695d77d20dfe27b09ee506961834" translate="yes" xml:space="preserve">
          <source>Notice that the resulting directions might be somewhat surprising if you are looking at a flat worldmap: in such map projections the great circles quite often do not look like the shortest routes -- but for example the shortest possible routes from Europe or North America to Asia do often cross the polar regions. (The common Mercator projection does &lt;b&gt;not&lt;/b&gt; show great circles as straight lines: straight lines in the Mercator projection are lines of constant bearing.)</source>
          <target state="translated">フラットな世界地図を見ていると、結果の方向が多少意外になる可能性があることに注意してください。そのようなマップ投影では、大円はほとんどの場合、最短ルートのようには見えませんが、たとえばヨーロッパや北米からアジアへの最短ルートなどしばしば極地を横切る。 （一般的なメルカトル図法では大円は直線として表示されませ&lt;b&gt;ん。&lt;/b&gt;メルカトル図法の直線は一定の方位の線です。）</target>
        </trans-unit>
        <trans-unit id="f84d61c644ea07e321b7e96f57efe6473acd064c" translate="yes" xml:space="preserve">
          <source>Notice that the standard utility methods of &lt;code&gt;Locale::Maketext&lt;/code&gt; are irremediably limited because they could not aim to do everything that could be expected from them in different languages, cultures and applications. So extending &lt;code&gt;numf&lt;/code&gt;, &lt;code&gt;quant&lt;/code&gt;, and &lt;code&gt;sprintf&lt;/code&gt; is natural as soon as your needs exceed what the standard ones do.</source>
          <target state="translated">&lt;code&gt;Locale::Maketext&lt;/code&gt; の標準的なユーティリティメソッドは、さまざまな言語、文化、アプリケーションで期待できるすべてのことを実行することを目的としていないため、修復不可能なほど制限されていることに注意してください。したがって、 &lt;code&gt;numf&lt;/code&gt; 、 &lt;code&gt;quant&lt;/code&gt; 、および &lt;code&gt;sprintf&lt;/code&gt; を拡張することは、ニーズが標準のニーズを超えるとすぐに自然になります。</target>
        </trans-unit>
        <trans-unit id="cf6655a31d0fb590f3023635e120ce3082cf0511" translate="yes" xml:space="preserve">
          <source>Notice that this affects also the return values of the &lt;code&gt;display_format&lt;/code&gt; methods: in list context the whole parameter hash will be returned, as opposed to only the style parameter value. This is a potential incompatibility with earlier versions if you have been calling the &lt;code&gt;display_format&lt;/code&gt; method in list context.</source>
          <target state="translated">これは &lt;code&gt;display_format&lt;/code&gt; メソッドの戻り値にも影響することに注意してください。リストコンテキストでは、スタイルパラメーター値だけではなく、パラメーターハッシュ全体が返されます。リストコンテキストで &lt;code&gt;display_format&lt;/code&gt; メソッドを呼び出している場合、これは以前のバージョンとの非互換性の可能性があります。</target>
        </trans-unit>
        <trans-unit id="7d79b02a2f56a81b2e831febdf1350cedb3c1a70" translate="yes" xml:space="preserve">
          <source>Notice that this example differs from the previous example only in its reference count. Compare this to the next example, where we dump &lt;code&gt;$b&lt;/code&gt; instead of &lt;code&gt;$a&lt;/code&gt; .</source>
          <target state="translated">この例は、参照カウントのみが前の例と異なっていることに注意してください。我々はダンプ次の例で、この比較 &lt;code&gt;$b&lt;/code&gt; の代わりに、 &lt;code&gt;$a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5817d7016f97dd4bc8025a72366ab7b19c39f5b7" translate="yes" xml:space="preserve">
          <source>Notice that this example differs from the previous example only in its reference count. Compare this to the next example, where we dump &lt;code&gt;$b&lt;/code&gt; instead of &lt;code&gt;$a&lt;/code&gt;.</source>
          <target state="translated">この例は、参照カウントのみが前の例と異なることに注意してください。これを次の例と比較してください。次の例では、 &lt;code&gt;$b&lt;/code&gt; 代わりに &lt;code&gt;$a&lt;/code&gt; bをダンプします。</target>
        </trans-unit>
        <trans-unit id="666303811970a38b268d6ae06ec62a57190a710e" translate="yes" xml:space="preserve">
          <source>Notice that we don't use the &lt;code&gt;env&lt;/code&gt; pointer. Normally handed to &lt;code&gt;perl_parse&lt;/code&gt; as its final argument, &lt;code&gt;env&lt;/code&gt; here is replaced by &lt;code&gt;NULL&lt;/code&gt; , which means that the current environment will be used.</source>
          <target state="translated">&lt;code&gt;env&lt;/code&gt; ポインターを使用していないことに注意してください。通常、最後の引数として &lt;code&gt;perl_parse&lt;/code&gt; に渡され、ここの &lt;code&gt;env&lt;/code&gt; は &lt;code&gt;NULL&lt;/code&gt; に置き換えられます。つまり、現在の環境が使用されます。</target>
        </trans-unit>
        <trans-unit id="930214e71214bfe57e424495f1f5252084b336e6" translate="yes" xml:space="preserve">
          <source>Notice that we don't use the &lt;code&gt;env&lt;/code&gt; pointer. Normally handed to &lt;code&gt;perl_parse&lt;/code&gt; as its final argument, &lt;code&gt;env&lt;/code&gt; here is replaced by &lt;code&gt;NULL&lt;/code&gt;, which means that the current environment will be used.</source>
          <target state="translated">&lt;code&gt;env&lt;/code&gt; ポインタを使用していないことに注意してください。通常、最後の引数として &lt;code&gt;perl_parse&lt;/code&gt; に渡され &lt;code&gt;NULL&lt;/code&gt; 、ここでの &lt;code&gt;env&lt;/code&gt; はNULLに置き換えられます。これは、現在の環境が使用されることを意味します。</target>
        </trans-unit>
        <trans-unit id="14ecce29919a6e670ddbfce3528fa1f7984fab4d" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_c&lt;/code&gt; is not equal to &lt;code&gt;$rho_s&lt;/code&gt; .</source>
          <target state="translated">ことに注意してください &lt;code&gt;$z&lt;/code&gt; 0ではない &lt;code&gt;$rho_c&lt;/code&gt; 等しくされていません &lt;code&gt;$rho_s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6a5cef6aa9527100171d0d0994226a5b838b3bc" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_c&lt;/code&gt; is not equal to &lt;code&gt;$rho_s&lt;/code&gt;.</source>
          <target state="translated">ことに注意してください &lt;code&gt;$z&lt;/code&gt; 0ではない &lt;code&gt;$rho_c&lt;/code&gt; 等しくされていません &lt;code&gt;$rho_s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31ec88b4a9dbb1f747340d0b910dcdd339c4815c" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_s&lt;/code&gt; is not equal to &lt;code&gt;$rho_c&lt;/code&gt; .</source>
          <target state="translated">ときということに注意してください &lt;code&gt;$z&lt;/code&gt; ない0 &lt;code&gt;$rho_s&lt;/code&gt; 等しくない &lt;code&gt;$rho_c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01c82dfb0bcf881d438ecf1364082366f27c8820" translate="yes" xml:space="preserve">
          <source>Notice that when &lt;code&gt;$z&lt;/code&gt; is not 0 &lt;code&gt;$rho_s&lt;/code&gt; is not equal to &lt;code&gt;$rho_c&lt;/code&gt;.</source>
          <target state="translated">ときということに注意してください &lt;code&gt;$z&lt;/code&gt; ない0 &lt;code&gt;$rho_s&lt;/code&gt; 等しくない &lt;code&gt;$rho_c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d590cf6b82e4392a2e3299e1af99133b75ac011" translate="yes" xml:space="preserve">
          <source>Notice that you can choose to specify the length of the string to be assigned by using &lt;code&gt;sv_setpvn&lt;/code&gt; , &lt;code&gt;newSVpvn&lt;/code&gt; , or &lt;code&gt;newSVpv&lt;/code&gt; , or you may allow Perl to calculate the length by using &lt;code&gt;sv_setpv&lt;/code&gt; or by specifying 0 as the second argument to &lt;code&gt;newSVpv&lt;/code&gt; . Be warned, though, that Perl will determine the string's length by using &lt;code&gt;strlen&lt;/code&gt; , which depends on the string terminating with a &lt;code&gt;NUL&lt;/code&gt; character, and not otherwise containing NULs.</source>
          <target state="translated">あなたが使用して割り当てられる文字列の長さを指定することを選択できることに注意してください &lt;code&gt;sv_setpvn&lt;/code&gt; 、 &lt;code&gt;newSVpvn&lt;/code&gt; 、または &lt;code&gt;newSVpv&lt;/code&gt; を、またはあなたはPerlが使って長さを計算することを可能にする &lt;code&gt;sv_setpv&lt;/code&gt; をかへの2番目の引数として0を指定することにより、 &lt;code&gt;newSVpv&lt;/code&gt; 。ただし、Perlは &lt;code&gt;strlen&lt;/code&gt; を使用して文字列の長さを決定することに注意してください。これは、 &lt;code&gt;NUL&lt;/code&gt; 文字で終了する文字列に依存し、その他の方法ではNULを含みません。</target>
        </trans-unit>
        <trans-unit id="8388abb49037aa7a9750fb22bcb53bb337bbb687" translate="yes" xml:space="preserve">
          <source>Notice that you can choose to specify the length of the string to be assigned by using &lt;code&gt;sv_setpvn&lt;/code&gt;, &lt;code&gt;newSVpvn&lt;/code&gt;, or &lt;code&gt;newSVpv&lt;/code&gt;, or you may allow Perl to calculate the length by using &lt;code&gt;sv_setpv&lt;/code&gt; or by specifying 0 as the second argument to &lt;code&gt;newSVpv&lt;/code&gt;. Be warned, though, that Perl will determine the string's length by using &lt;code&gt;strlen&lt;/code&gt;, which depends on the string terminating with a &lt;code&gt;NUL&lt;/code&gt; character, and not otherwise containing NULs.</source>
          <target state="translated">あなたが使用して割り当てられる文字列の長さを指定することを選択できることに注意してください &lt;code&gt;sv_setpvn&lt;/code&gt; 、 &lt;code&gt;newSVpvn&lt;/code&gt; 、または &lt;code&gt;newSVpv&lt;/code&gt; を、またはあなたはPerlが使って長さを計算することを可能にする &lt;code&gt;sv_setpv&lt;/code&gt; をかへの2番目の引数として0を指定することにより、 &lt;code&gt;newSVpv&lt;/code&gt; 。ただし、Perlは &lt;code&gt;strlen&lt;/code&gt; を使用して文字列の長さを決定することに注意してください。これは、 &lt;code&gt;NUL&lt;/code&gt; 文字で終了する文字列に依存し、それ以外の場合はNULを含みません。</target>
        </trans-unit>
        <trans-unit id="870ccbb59c66300e9b3ea8f52b5a5f559b3dde16" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;OBJECT&lt;/code&gt; attribute. MakeMaker generates the following variables in</source>
          <target state="translated">&lt;code&gt;OBJECT&lt;/code&gt; 属性に注目してください。MakeMakerは以下の変数を生成します</target>
        </trans-unit>
        <trans-unit id="f8aba368fbb68d7c50d7b29b9babed1e8eb186e8" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;_&lt;/code&gt; in the above &lt;code&gt;&lt;a href=&quot;../functions/int&quot;&gt;int&lt;/a&gt;(-M _)&lt;/code&gt; : the &lt;code&gt;_&lt;/code&gt; is a magical filehandle that caches the information from the preceding &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt;, or filetest.</source>
          <target state="translated">通知 &lt;code&gt;_&lt;/code&gt; 上記で &lt;code&gt;&lt;a href=&quot;../functions/int&quot;&gt;int&lt;/a&gt;(-M _)&lt;/code&gt; ： &lt;code&gt;_&lt;/code&gt; 前回からの情報をキャッシュする魔法のファイルハンドルである &lt;code&gt;&lt;a href=&quot;../functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../functions/lstat&quot;&gt;lstat()&lt;/a&gt;&lt;/code&gt; 、またはファイルテスト。</target>
        </trans-unit>
        <trans-unit id="3649b7d5b5ec60ffba14ae21c7b1c2a9a411dd9a" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;_&lt;/code&gt; in the above &lt;code&gt;int(-M _)&lt;/code&gt;: the &lt;code&gt;_&lt;/code&gt; is a magical filehandle that caches the information from the preceding &lt;code&gt;stat()&lt;/code&gt;, &lt;code&gt;lstat()&lt;/code&gt;, or filetest.</source>
          <target state="translated">通知 &lt;code&gt;_&lt;/code&gt; 上記で &lt;code&gt;int(-M _)&lt;/code&gt; ： &lt;code&gt;_&lt;/code&gt; 前回からの情報をキャッシュする魔法のファイルハンドルである &lt;code&gt;stat()&lt;/code&gt; 、 &lt;code&gt;lstat()&lt;/code&gt; またはファイルテスト。</target>
        </trans-unit>
        <trans-unit id="4bb3a64dceeceb885b9680e4902401cdf9dc4f74" translate="yes" xml:space="preserve">
          <source>Notice the different order of arguments to &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Move&lt;/code&gt; than used in &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;memmove&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;Copy&lt;/code&gt; と &lt;code&gt;Move&lt;/code&gt; 引数の順序が &lt;code&gt;memcpy&lt;/code&gt; と &lt;code&gt;memmove&lt;/code&gt; で使用されている順序と異なることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4cfb16d57b3fc1899ca35729db416deb1a5fcf6d" translate="yes" xml:space="preserve">
          <source>Notice the different order of arguments to &lt;code&gt;Copy&lt;/code&gt; and &lt;code&gt;Move&lt;/code&gt; than used in &lt;code&gt;memcpy&lt;/code&gt; and &lt;code&gt;memmove&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;memcpy&lt;/code&gt; および &lt;code&gt;memmove&lt;/code&gt; で使用されているものとは、 &lt;code&gt;Copy&lt;/code&gt; および &lt;code&gt;Move&lt;/code&gt; の引数の順序が異なることに注意してください。</target>
        </trans-unit>
        <trans-unit id="679c7845eb58a7c2d0b2d8985266c244821c6fe5" translate="yes" xml:space="preserve">
          <source>Notice the last two: you have an undef value, but a defined key!</source>
          <target state="translated">最後の2つに注目してください:未定義の値がありますが、定義されたキーがあります!</target>
        </trans-unit>
        <trans-unit id="448c7dc3dc98fc3fc0f5933ff2892ce9313d9152" translate="yes" xml:space="preserve">
          <source>Notice the two lines commented with &quot;XXXXX&quot;. If you check the first part of the typemap file (or section), you'll see that doubles are of type T_DOUBLE. In the INPUT part of the typemap, an argument that is T_DOUBLE is assigned to the variable arg by calling the routine SvNV on something, then casting it to double, then assigned to the variable arg. Similarly, in the OUTPUT section, once arg has its final value, it is passed to the sv_setnv function to be passed back to the calling subroutine. These two functions are explained in &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;; we'll talk more later about what that &quot;ST(0)&quot; means in the section on the argument stack.</source>
          <target state="translated">「XXXXX」でコメント化された2行に注目してください。タイプマップファイル（またはセクション）の最初の部分をチェックすると、doubleの型がT_DOUBLEであることがわかります。タイプマップのINPUT部分で、T_DOUBLEの引数は、何かでルーチンSvNVを呼び出して変数argに割り当てられ、それをdoubleにキャストしてから、変数argに割り当てられます。同様に、OUTPUTセクションでは、argが最終的な値になると、それはsv_setnv関数に渡され、呼び出し元のサブルーチンに戻されます。これら2つの関数は&lt;a href=&quot;perlguts&quot;&gt;perlgutsで&lt;/a&gt;説明されています。「ST（0）」の意味については、引数スタックのセクションで詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="d783d11df518bc5c15566c5aca0ab336d7d1805f" translate="yes" xml:space="preserve">
          <source>Notice the use of GV_ADD as the second parameter. The new variable can now be set, using the routines appropriate to the data type.</source>
          <target state="translated">2番目のパラメータとしてGV_ADDを使用していることに注目してください。データ型に適したルーチンを使用して、新しい変数を設定することができるようになりました。</target>
        </trans-unit>
        <trans-unit id="08b42440fb285e46d8dc9159db458556192da3bc" translate="yes" xml:space="preserve">
          <source>Notice the white space in these examples. This construct always has the &lt;code&gt;/x&lt;/code&gt; modifier turned on within it.</source>
          <target state="translated">これらの例の空白に注意してください。この構成では、常に &lt;code&gt;/x&lt;/code&gt; 修飾子がオンになっています。</target>
        </trans-unit>
        <trans-unit id="319e2b5eaf07860409d97b11c5611e8f5cc65281" translate="yes" xml:space="preserve">
          <source>Notice the white space in these examples. This construct always has the &lt;code&gt;/xx&lt;/code&gt; modifier turned on within it.</source>
          <target state="translated">これらの例の空白に注意してください。この構成では、常に &lt;code&gt;/xx&lt;/code&gt; 修飾子がオンになっています。</target>
        </trans-unit>
        <trans-unit id="2dd6270a12f8b7eb8c9c200a3723ca7a45c46729" translate="yes" xml:space="preserve">
          <source>Notice we use &lt;code&gt;Perl_pp_add&lt;/code&gt; and not &lt;code&gt;pp_add&lt;/code&gt; - see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;&quot;Internal Functions&quot; in perlguts&lt;/a&gt;. With the breakpoint in place, we can run our program:</source>
          <target state="translated">&lt;code&gt;Perl_pp_add&lt;/code&gt; なく &lt;code&gt;pp_add&lt;/code&gt; を使用していることに注意してください。perlgutsの&lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;「内部関数」を&lt;/a&gt;参照してください。ブレークポイントを設定すると、プログラムを実行できます。</target>
        </trans-unit>
        <trans-unit id="cf19896e6984078f566d31f89bc10d28920f05df" translate="yes" xml:space="preserve">
          <source>Notice we use &lt;code&gt;Perl_pp_add&lt;/code&gt; and not &lt;code&gt;pp_add&lt;/code&gt; - see &lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;Internal Functions in perlguts&lt;/a&gt;. With the breakpoint in place, we can run our program:</source>
          <target state="translated">&lt;code&gt;Perl_pp_add&lt;/code&gt; なく &lt;code&gt;pp_add&lt;/code&gt; を使用していることに注意してください-perlgutsの&lt;a href=&quot;perlguts#Internal-Functions&quot;&gt;内部関数を&lt;/a&gt;参照してください。ブレークポイントを設定したら、プログラムを実行できます。</target>
        </trans-unit>
        <trans-unit id="49e7942c0e9764eb733db50ae6c6f21e34cbe873" translate="yes" xml:space="preserve">
          <source>Notify an according IPv6 MTU.</source>
          <target state="translated">IPv6のMTUに応じた通知を行います。</target>
        </trans-unit>
        <trans-unit id="02cb5b7c921fb7ebbe36d3e0607902dde126730c" translate="yes" xml:space="preserve">
          <source>Notify is used to request Delivery Status Notifications (DSNs), but your SMTP/ESMTP service may not respect this request depending upon its version and your site's SMTP configuration.</source>
          <target state="translated">Notify は配信状況通知 (DSN)を要求するために使用されますが、SMTP/ESMTP サービスのバージョンとサイトの SMTP 設定によっては、この要求が尊重されない場合があります。</target>
        </trans-unit>
        <trans-unit id="da17090b524f51c10e88d0ac9b7049f8740a008e" translate="yes" xml:space="preserve">
          <source>Notify the server that the current message should be sent to all of the addresses given. Each address is sent as a separate command to the server. Should the sending of any address result in a failure then the process is aborted and a</source>
          <target state="translated">与えられたすべてのアドレスに現在のメッセージを送信することをサーバに通知します。それぞれのアドレスは、サーバに個別のコマンドとして送信されます。いずれかのアドレスの送信が失敗した場合、プロセスは中断され</target>
        </trans-unit>
        <trans-unit id="9cbb4030243333159ba8734d1c5fd629386f77ad" translate="yes" xml:space="preserve">
          <source>Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.</source>
          <target state="translated">Novell NetWareはFile::Specの動作をFile::Spec::Win32から継承しています。</target>
        </trans-unit>
        <trans-unit id="f596d3f268eaea786d51ab55e3200ab8fc6af9a4" translate="yes" xml:space="preserve">
          <source>November 13, 2003</source>
          <target state="translated">2003年11月13日</target>
        </trans-unit>
        <trans-unit id="c0ef706a9203ebb1532a39a12c049758f080c8c3" translate="yes" xml:space="preserve">
          <source>November 16, 2003</source>
          <target state="translated">2003年11月16日</target>
        </trans-unit>
        <trans-unit id="7c0d9da26bf041d32a0675226f59b963b86e2fb7" translate="yes" xml:space="preserve">
          <source>November 2006</source>
          <target state="translated">2006年11月</target>
        </trans-unit>
        <trans-unit id="dd6807acb122cd8525edb3b470a139acef9bafbd" translate="yes" xml:space="preserve">
          <source>November, 2007; by Christophe Grosjean: make cmpthese and timestr compute time consistently with style argument, default is 'all' not 'noc' any more.</source>
          <target state="translated">2007年11月;Christophe Grosjeanによる:cmptheseとtimestrはスタイル引数で一貫して時間を計算するようにし、デフォルトは'noc'ではなく'all'にしました。</target>
        </trans-unit>
        <trans-unit id="e3b82040565bb4be6b11f778a2e3df327ed20a3b" translate="yes" xml:space="preserve">
          <source>Now</source>
          <target state="translated">Now</target>
        </trans-unit>
        <trans-unit id="c93d8b194f0c7fe984e291581c08b1052c5f3a15" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;$f1-&amp;gt;($n)&lt;/code&gt; is always 20 plus whatever $n you pass in, whereas &lt;code&gt;$f2-&amp;gt;($n)&lt;/code&gt; is always 555 plus whatever $n you pass in. The $addpiece in the closure sticks around.</source>
          <target state="translated">ここで、 &lt;code&gt;$f1-&amp;gt;($n)&lt;/code&gt; は常に20プラス渡した$ nですが、 &lt;code&gt;$f2-&amp;gt;($n)&lt;/code&gt; は常に555プラス渡したすべての$ nです。クロージャーの$ addpieceはそのまま残ります。</target>
        </trans-unit>
        <trans-unit id="f44dcb817094334da756769457dbdcc2f78729c5" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; customre&lt;/code&gt; enables the new escape in constant regular expressions, i.e., those without any runtime variable interpolations. As documented in &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;, this conversion will work only over literal parts of regular expressions. For &lt;code&gt;\Y|$re\Y|&lt;/code&gt; the variable part of this regular expression needs to be converted explicitly (but only if the special meaning of &lt;code&gt;\Y|&lt;/code&gt; should be enabled inside $re):</source>
          <target state="translated">今度 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; customre&lt;/code&gt; 使用して、定数の正規表現、つまりランタイム変数の補間がないものでの新しいエスケープを有効にします。&lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;に記載されているように、この変換は正規表現のリテラル部分でのみ機能します。以下のための &lt;code&gt;\Y|$re\Y|&lt;/code&gt; この正規表現の変数部分は明示的に変換する必要があります（ただし、$ &lt;code&gt;\Y|&lt;/code&gt; 内で\ Y |の特別な意味を有効にする必要がある場合のみ）：</target>
        </trans-unit>
        <trans-unit id="fade66a80437ba60181e3ddce42855f68a77521c" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;use customre&lt;/code&gt; enables the new escape in constant regular expressions,</source>
          <target state="translated">ここで &lt;code&gt;use customre&lt;/code&gt; 使用すると、定数正規表現で新しいエスケープが有効になります。</target>
        </trans-unit>
        <trans-unit id="b01a23641a218b7388c86b594decd3175ef90f36" translate="yes" xml:space="preserve">
          <source>Now I can run my tests like this</source>
          <target state="translated">これで、以下のようにテストを実行できるようになりました。</target>
        </trans-unit>
        <trans-unit id="e5baf71e7fbf158fd008d8c03a7a8fa212d5b45f" translate="yes" xml:space="preserve">
          <source>Now I'll create a C program,</source>
          <target state="translated">今度はCプログラムを作ってみます。</target>
        </trans-unit>
        <trans-unit id="2b1360bf75473ee9266121d81e1a06dd9911acef" translate="yes" xml:space="preserve">
          <source>Now all those different functions appear to exist independently. You can call red(), RED(), blue(), BLUE(), green(), etc. This technique saves on both compile time and memory use, and is less error-prone as well, since syntax checks happen at compile time. It's critical that any variables in the anonymous subroutine be lexicals in order to create a proper closure. That's the reasons for the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; on the loop iteration variable.</source>
          <target state="translated">現在、これらのさまざまな機能はすべて独立して存在しているように見えます。red（）、RED（）、blue（）、BLUE（）、green（）などを呼び出すことができます。この手法は、コンパイル時間とメモリ使用量の両方を節約し、構文チェックはコンパイル時間。適切なクロージャを作成するためには、無名サブルーチン内のすべての変数が語彙的であることが重要です。これが、ループ上の反復変数 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; の理由です。</target>
        </trans-unit>
        <trans-unit id="fabedd5297cac1df38e4fa79abf11492e74b2a01" translate="yes" xml:space="preserve">
          <source>Now all those different functions appear to exist independently. You can call red(), RED(), blue(), BLUE(), green(), etc. This technique saves on both compile time and memory use, and is less error-prone as well, since syntax checks happen at compile time. It's critical that any variables in the anonymous subroutine be lexicals in order to create a proper closure. That's the reasons for the &lt;code&gt;my&lt;/code&gt; on the loop iteration variable.</source>
          <target state="translated">現在、これらのさまざまな機能はすべて独立して存在しているように見えます。red（）、RED（）、blue（）、BLUE（）、green（）などを呼び出すことができます。この手法は、コンパイル時間とメモリ使用量の両方を節約し、構文チェックがで行われるため、エラーが発生しにくくなります。コンパイル時。適切なクロージャを作成するには、匿名サブルーチン内の変数が字句であることが重要です。これが、 &lt;code&gt;my&lt;/code&gt; on theloop反復変数の理由です。</target>
        </trans-unit>
        <trans-unit id="4fd34829b18de1627725a95c603c191742b917e4" translate="yes" xml:space="preserve">
          <source>Now all you have to do is make.</source>
          <target state="translated">あとは作るだけです。</target>
        </trans-unit>
        <trans-unit id="49b5690000abd466cabd2983e572f96822c8ad4b" translate="yes" xml:space="preserve">
          <source>Now an example using G_EVAL. Below is a Perl subroutine which computes the difference of its 2 parameters. If this would result in a negative result, the subroutine calls</source>
          <target state="translated">G_EVALを使った例です。以下は2つのパラメータの差を計算するPerlのサブルーチンです。もしこれが負の結果になるならば、このサブルーチンは</target>
        </trans-unit>
        <trans-unit id="0107493cf3f67fc1eae2d61845bafd402e29a874" translate="yes" xml:space="preserve">
          <source>Now being maintained by Neil Bowers &amp;lt;neilb@cpan.org&amp;gt;</source>
          <target state="translated">現在、Neil Bowers &amp;lt;neilb@cpan.org&amp;gt;によって管理されています</target>
        </trans-unit>
        <trans-unit id="d0a0f59849b2d6f78aa32cc04ac0bc8777dc3df0" translate="yes" xml:space="preserve">
          <source>Now build an on-the-fly object over a couple of lines (note the backslash):</source>
          <target state="translated">では、数行に渡ってオンザフライのオブジェクトを作成してください(バックスラッシュに注意してください)。</target>
        </trans-unit>
        <trans-unit id="b18a77ba9bd692a2de2351fc4472b7905512dae7" translate="yes" xml:space="preserve">
          <source>Now change that to call a Perl subroutine instead</source>
          <target state="translated">これを変更して、代わりに Perl のサブルーチンを呼び出すようにします。</target>
        </trans-unit>
        <trans-unit id="5eed8faf15fe7e07bcc558e5fbc255c10a771276" translate="yes" xml:space="preserve">
          <source>Now check whether &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec($read,$n,1)&lt;/a&gt;&lt;/code&gt; is true for some &lt;code&gt;$n&lt;/code&gt; .</source>
          <target state="translated">ここで、一部の &lt;code&gt;$n&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/vec&quot;&gt;vec($read,$n,1)&lt;/a&gt;&lt;/code&gt; がtrue かどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="10a01ad64127827e39a88ed3009004d810d71655" translate="yes" xml:space="preserve">
          <source>Now check whether &lt;code&gt;vec($read,$n,1)&lt;/code&gt; is true for some &lt;code&gt;$n&lt;/code&gt;.</source>
          <target state="translated">ここで &lt;code&gt;vec($read,$n,1)&lt;/code&gt; がいくつかの &lt;code&gt;$n&lt;/code&gt; 真であるかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="35cab876c88e9037a6396981d2ddc61575d5495f" translate="yes" xml:space="preserve">
          <source>Now comes the clever bit. Lines in our ledger which are just income and not expenditure might end at column 46. Hence, we don't want to tell our &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; pattern that we &lt;b&gt;need&lt;/b&gt; to find another 12 characters; we'll just say &quot;if there's anything left, take it&quot;. As you might guess from regular expressions, that's what the &lt;code&gt;*&lt;/code&gt; means: &quot;use everything remaining&quot;.</source>
          <target state="translated">さあ、少し賢くなりました。収入であり支出ではない、元帳の行は46列目で終了する場合があります。したがって、 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; パターンに別の12文字を見つける&lt;b&gt;必要&lt;/b&gt;があることを伝えたくありません。「何か残っている場合はそれを取りなさい」と言うだけです。正規表現から推測できるように、それが &lt;code&gt;*&lt;/code&gt; の意味です：「残りすべてを使用する」。</target>
        </trans-unit>
        <trans-unit id="2aed8f2583a2025408738c1655ec69d76cbf4265" translate="yes" xml:space="preserve">
          <source>Now comes the clever bit. Lines in our ledger which are just income and not expenditure might end at column 46. Hence, we don't want to tell our &lt;code&gt;unpack&lt;/code&gt; pattern that we &lt;b&gt;need&lt;/b&gt; to find another 12 characters; we'll just say &quot;if there's anything left, take it&quot;. As you might guess from regular expressions, that's what the &lt;code&gt;*&lt;/code&gt; means: &quot;use everything remaining&quot;.</source>
          <target state="translated">今、賢いビットが来ます。元帳の行が収入であり支出ではない場合、列46で終了する可能性があります。したがって、 &lt;code&gt;unpack&lt;/code&gt; パターンに、さらに12文字を見つける&lt;b&gt;必要&lt;/b&gt;があることを伝えたくありません。「残っているものがあれば、それを持っていってください」とだけ言います。正規表現から推測できるように、 &lt;code&gt;*&lt;/code&gt; は「残りのすべてを使用する」という意味です。</target>
        </trans-unit>
        <trans-unit id="3043847bd2200864abd83a13618a02dee8ec6266" translate="yes" xml:space="preserve">
          <source>Now commit your change locally:</source>
          <target state="translated">変更をローカルでコミットします。</target>
        </trans-unit>
        <trans-unit id="a13bda202e6718f6f18d21a1e47f52cfb3879053" translate="yes" xml:space="preserve">
          <source>Now compile this program (I'll call it</source>
          <target state="translated">では、このプログラムをコンパイルしてみましょう。</target>
        </trans-unit>
        <trans-unit id="c57d72b147b5753e6d9e423d3502ca9248d5f07f" translate="yes" xml:space="preserve">
          <source>Now compile:</source>
          <target state="translated">今すぐコンパイルしてください。</target>
        </trans-unit>
        <trans-unit id="f3d2e76534a9f4dbbaafe0b2d7b2922184fb31d5" translate="yes" xml:space="preserve">
          <source>Now consider floating point numbers with exponents. The key observation here is that</source>
          <target state="translated">ここで、指数を持つ浮動小数点数を考えてみましょう。ここで重要なことは、次のようなことです。</target>
        </trans-unit>
        <trans-unit id="6e69790285fa3d81bdaeedc9a045cae201d21c12" translate="yes" xml:space="preserve">
          <source>Now consider what the code looks like without &lt;code&gt;InputLength&lt;/code&gt;</source>
          <target state="translated">ここで、 &lt;code&gt;InputLength&lt;/code&gt; なしのコードがどのように見えるかを考えてみましょう</target>
        </trans-unit>
        <trans-unit id="ff2a183c3b41e6c536df243f1dce108cb53ffa0f" translate="yes" xml:space="preserve">
          <source>Now edit the Mytest2.t script and change the number of tests to &quot;4&quot;, and add the following lines to the end of the script:</source>
          <target state="translated">ここでMytest2.tスクリプトを編集し、テスト数を「4」に変更し、スクリプトの最後に以下の行を追加します。</target>
        </trans-unit>
        <trans-unit id="2953f00009a89200e277b692ef57868b268aff69" translate="yes" xml:space="preserve">
          <source>Now for an example of dealing with the items returned from a Perl subroutine.</source>
          <target state="translated">では、Perlのサブルーチンから返された項目を扱う例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="0be3c2c5225baac76521af82d8668e34f7dced50" translate="yes" xml:space="preserve">
          <source>Now for something much more complex: &lt;code&gt;/x(?:foo*|b[a][rR])(foo|bar)$/&lt;/code&gt;</source>
          <target state="translated">今度はもっと複雑なもののために： &lt;code&gt;/x(?:foo*|b[a][rR])(foo|bar)$/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92162dfafb815308e37a13a29bc3866c727f49ac" translate="yes" xml:space="preserve">
          <source>Now if $baz is overloaded like this, then &lt;code&gt;$baz&lt;/code&gt; is a reference to a reference to the intermediate array, which keeps a reference to an actual array, and the access hash. The tie()ing object for the access hash is a reference to a reference to the actual array, so</source>
          <target state="translated">$ bazのは、このようにオーバーロードされている場合さて、その後、 &lt;code&gt;$baz&lt;/code&gt; 、実際の配列への参照を保持した中間配列、およびアクセスハッシュへのリファレンスへの参照です。アクセスハッシュのtie（）オブジェクトは実際の配列への参照への参照なので、</target>
        </trans-unit>
        <trans-unit id="442765a41777ec67298b58abdc70ce2f732fb2a5" translate="yes" xml:space="preserve">
          <source>Now if we see a &lt;code&gt;U&lt;/code&gt; which was at the start of the string, we turn on the &lt;code&gt;UTF8&lt;/code&gt; flag for the output SV, &lt;code&gt;cat&lt;/code&gt; :</source>
          <target state="translated">文字列の先頭にある &lt;code&gt;U&lt;/code&gt; が表示された場合、出力SV、 &lt;code&gt;cat&lt;/code&gt; の &lt;code&gt;UTF8&lt;/code&gt; フラグをオンにします。</target>
        </trans-unit>
        <trans-unit id="5914acd073f333e4c23a4d84f2aa14b4552e8013" translate="yes" xml:space="preserve">
          <source>Now if we see a &lt;code&gt;U&lt;/code&gt; which was at the start of the string, we turn on the &lt;code&gt;UTF8&lt;/code&gt; flag for the output SV, &lt;code&gt;cat&lt;/code&gt;:</source>
          <target state="translated">私たちが見る今ならば &lt;code&gt;U&lt;/code&gt; 文字列の先頭にいた、我々はオンに &lt;code&gt;UTF8&lt;/code&gt; の出力SV、フラグ &lt;code&gt;cat&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9aa71504ceae318c2af66092e17c9a82a7deb8c3" translate="yes" xml:space="preserve">
          <source>Now inner() can only be called from within outer(), because of the temporary assignments of the anonymous subroutine. But when it does, it has normal access to the lexical variable $x from the scope of outer() at the time outer is invoked.</source>
          <target state="translated">現在、inner()は、匿名サブルーチンの一時的な代入のため、 outer()の中からしか呼び出すことができません。しかし、inner()が呼び出されたときには、 outer()が呼び出された時点で、 outer()のスコープから辞書変数$xに通常通りアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="f0dd64db78144735f7994758b886eab3a665aa14" translate="yes" xml:space="preserve">
          <source>Now is the time to build statically linked executable</source>
          <target state="translated">今こそ静的にリンクされた実行ファイルを構築する時です</target>
        </trans-unit>
        <trans-unit id="56e8b027d2534e474052d61aa156186a15f1e672" translate="yes" xml:space="preserve">
          <source>Now issue a command all Perl Mongers love:</source>
          <target state="translated">今すぐ、Perl Mongers が大好きなコマンドを発行してください。</target>
        </trans-unit>
        <trans-unit id="5afbbbcc6562eb3dd44ab3aeee5e6e877aac172d" translate="yes" xml:space="preserve">
          <source>Now it always returns &lt;code&gt;NOT_IN_PAD&lt;/code&gt;.</source>
          <target state="translated">これで、常に &lt;code&gt;NOT_IN_PAD&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="a8a1925328e3fa40f64265288667627705914e38" translate="yes" xml:space="preserve">
          <source>Now it really looks like two-dimensional arrays!</source>
          <target state="translated">これで本当に二次元の配列に見えてきました。</target>
        </trans-unit>
        <trans-unit id="6e306ced46a050d218e4778907f520f756de263d" translate="yes" xml:space="preserve">
          <source>Now it's time to print your data structure out. How are you going to do that? Well, if you want only one of the elements, it's trivial:</source>
          <target state="translated">さあ、データ構造をプリントアウトしてみましょう。どうやってそれをするのですか?まあ、要素のうちの1つだけを印刷したいのであれば、それは些細なことです。</target>
        </trans-unit>
        <trans-unit id="54ce2aa34a908b75653982fdea46ab158bc6415a" translate="yes" xml:space="preserve">
          <source>Now just type in any legal Perl code, and it will be immediately evaluated. You can also examine the symbol table, get stack backtraces, check variable values, set breakpoints, and other operations typically found in symbolic debuggers.</source>
          <target state="translated">合法的な Perl コードを入力するだけで、すぐに評価されます。また、シンボルテーブルを調べたり、スタックのバックトレースを取得したり、変数の値をチェックしたり、ブレークポイントを設定したり、その他シンボリックデバッガで一般的に見られる操作を行うこともできます。</target>
        </trans-unit>
        <trans-unit id="71eab03d0589285d163e163d02feef9a891122b5" translate="yes" xml:space="preserve">
          <source>Now let's add to our extension a subroutine that will take a single numeric argument as input and return 1 if the number is even or 0 if the number is odd.</source>
          <target state="translated">さて、この拡張機能にサブルーチンを追加してみましょう。</target>
        </trans-unit>
        <trans-unit id="b25fbca1c3ebbbe365fafa21da05b0bf381c9042" translate="yes" xml:space="preserve">
          <source>Now let's go on with the show!</source>
          <target state="translated">さあ、本番に向けて頑張りましょう!</target>
        </trans-unit>
        <trans-unit id="56c9d0bafceed9745ea4a5c37d241ab5110ecbe0" translate="yes" xml:space="preserve">
          <source>Now let's look over &lt;code&gt;pp_pack&lt;/code&gt; : we take a pattern into &lt;code&gt;pat&lt;/code&gt; , and then loop over the pattern, taking each format character in turn into &lt;code&gt;datum_type&lt;/code&gt; . Then for each possible format character, we swallow up the other arguments in the pattern (a field width, an asterisk, and so on) and convert the next chunk input into the specified format, adding it onto the output SV &lt;code&gt;cat&lt;/code&gt; .</source>
          <target state="translated">次に、 &lt;code&gt;pp_pack&lt;/code&gt; を見てみましょう。パターンを &lt;code&gt;pat&lt;/code&gt; に取り、そのパターンをループして、各フォーマット文字を順に &lt;code&gt;datum_type&lt;/code&gt; に取ります。次に、可能な各フォーマット文字について、パターン内の他の引数（フィールド幅、アスタリスクなど）を飲み込み、次のチャンク入力を指定されたフォーマットに変換して、出力SV &lt;code&gt;cat&lt;/code&gt; に追加します。</target>
        </trans-unit>
        <trans-unit id="72fe90f904deeeb9bda4270aff1109f958440f65" translate="yes" xml:space="preserve">
          <source>Now let's look over &lt;code&gt;pp_pack&lt;/code&gt;: we take a pattern into &lt;code&gt;pat&lt;/code&gt;, and then loop over the pattern, taking each format character in turn into &lt;code&gt;datum_type&lt;/code&gt;. Then for each possible format character, we swallow up the other arguments in the pattern (a field width, an asterisk, and so on) and convert the next chunk input into the specified format, adding it onto the output SV &lt;code&gt;cat&lt;/code&gt;.</source>
          <target state="translated">次に、 &lt;code&gt;pp_pack&lt;/code&gt; を調べてみましょう。パターンを &lt;code&gt;pat&lt;/code&gt; に取り、次にパターンをループして、各フォーマット文字を &lt;code&gt;datum_type&lt;/code&gt; に変換します。そして、出力SVの上にそれを追加し、それぞれの可能なフォーマット文字のために、我々はパターン（フィールド幅、などアスタリスク）で、他の引数を飲み込むと、指定した形式に次のチャンクの入力を変換する &lt;code&gt;cat&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19bfc0dd7ed8b536789ace2adf6482eed3ae9d5d" translate="yes" xml:space="preserve">
          <source>Now let's make a slightly more complex example. This time we want to call a Perl subroutine, &lt;code&gt;LeftString&lt;/code&gt; , which will take 2 parameters--a string ($s) and an integer ($n). The subroutine will simply print the first $n characters of the string.</source>
          <target state="translated">では、もう少し複雑な例を見てみましょう。今回は、Perlサブルーチン &lt;code&gt;LeftString&lt;/code&gt; を呼び出します。これは、文字列（$ s）と整数（$ n）の2つのパラメーターを取ります。サブルーチンは、文字列の最初の$ n文字を出力するだけです。</target>
        </trans-unit>
        <trans-unit id="a1cd28db828b3965b5fb8cb34a20f3c4db616851" translate="yes" xml:space="preserve">
          <source>Now let's make a slightly more complex example. This time we want to call a Perl subroutine, &lt;code&gt;LeftString&lt;/code&gt;, which will take 2 parameters--a string ($s) and an integer ($n). The subroutine will simply print the first $n characters of the string.</source>
          <target state="translated">次に、もう少し複雑な例を作成しましょう。今回は、Perlサブルーチン &lt;code&gt;LeftString&lt;/code&gt; を呼び出します。これは、文字列（$ s）と整数（$ n）の2つのパラメーターを取ります。サブルーチンは、文字列の最初の$ n文字を出力するだけです。</target>
        </trans-unit>
        <trans-unit id="bf057ced369b422ce2c543343cfe6f097b71cc60" translate="yes" xml:space="preserve">
          <source>Now let's see what happens when you try to decode from ISO-2022-JP and the buffer ends in the middle of a character.</source>
          <target state="translated">では、ISO-2022-JPからデコードしようとしたときに、バッファが文字の途中で終わってしまうとどうなるかを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="6354d1ac356f03ba53418ed6480c6b835c8d11e3" translate="yes" xml:space="preserve">
          <source>Now let's try a harder pattern. We will add a quantifier, so now we have the pattern &lt;code&gt;/foo+/&lt;/code&gt; . We will see that &lt;code&gt;regbranch()&lt;/code&gt; calls &lt;code&gt;regpiece()&lt;/code&gt; twice.</source>
          <target state="translated">次に、より難しいパターンを試してみましょう。数量詞を追加して、パターン &lt;code&gt;/foo+/&lt;/code&gt; を作成します。私たちは、その表示されます &lt;code&gt;regbranch()&lt;/code&gt; 呼び出して &lt;code&gt;regpiece()&lt;/code&gt; を2回。</target>
        </trans-unit>
        <trans-unit id="364c0b15409d7672a94bf5ecd988b5c8a1f0315d" translate="yes" xml:space="preserve">
          <source>Now let's try a harder pattern. We will add a quantifier, so now we have the pattern &lt;code&gt;/foo+/&lt;/code&gt;. We will see that &lt;code&gt;regbranch()&lt;/code&gt; calls &lt;code&gt;regpiece()&lt;/code&gt; twice.</source>
          <target state="translated">それでは、もっと難しいパターンを試してみましょう。数量詞を追加するので、パターン &lt;code&gt;/foo+/&lt;/code&gt; ができました。私たちは、その表示されます &lt;code&gt;regbranch()&lt;/code&gt; 呼び出して &lt;code&gt;regpiece()&lt;/code&gt; を2回。</target>
        </trans-unit>
        <trans-unit id="d4cb79a776cb969edc30e88cc6131bd19fb97fb3" translate="yes" xml:space="preserve">
          <source>Now maintained by Perl 5 Porters.</source>
          <target state="translated">現在はPerl 5 Portersによってメンテナンスされています。</target>
        </trans-unit>
        <trans-unit id="889bc56f5635509a3bf0cc79dcaae69476badde9" translate="yes" xml:space="preserve">
          <source>Now maintained by Perl5 Porters.</source>
          <target state="translated">現在はPerl5 Portersによってメンテナンスされています。</target>
        </trans-unit>
        <trans-unit id="2038fc7801848170606c108e5b8808a37af01abf" translate="yes" xml:space="preserve">
          <source>Now numeric value of $c is 5. After &lt;code&gt;$a = 12; $b = 5&lt;/code&gt; the numeric value of $c becomes 13. To insulate the user of the module add a method</source>
          <target state="translated">$ cの数値は5になりました。 &lt;code&gt;$a = 12; $b = 5&lt;/code&gt; 後= 12; $ b = 5 $ cの数値は13になります。モジュールのユーザーを隔離するには、メソッドを追加します</target>
        </trans-unit>
        <trans-unit id="8af21af6d9d9b5497a4644877b2f52927ff73040" translate="yes" xml:space="preserve">
          <source>Now one can access an object using both the array and hash syntax:</source>
          <target state="translated">配列とハッシュ構文の両方を使ってオブジェクトにアクセスできるようになりました。</target>
        </trans-unit>
        <trans-unit id="0d5501fb3c867cabba9520f061ccb7181169320a" translate="yes" xml:space="preserve">
          <source>Now one can change the last line of the script to</source>
          <target state="translated">これで、スクリプトの最後の行を</target>
        </trans-unit>
        <trans-unit id="36a34b3fdc67a4c118c486e51977f9c88c24fbb9" translate="yes" xml:space="preserve">
          <source>Now one can finish the script by</source>
          <target state="translated">これでスクリプトは次のようにして完成します。</target>
        </trans-unit>
        <trans-unit id="fb12351c6667dd534972c89f66e0ea83ea3b515d" translate="yes" xml:space="preserve">
          <source>Now perform the same steps as before, generating a Makefile from the Makefile.PL file, and running make.</source>
          <target state="translated">ここで、前と同じ手順を実行し、Makefile.PLファイルからMakefileを生成し、makeを実行します。</target>
        </trans-unit>
        <trans-unit id="176a110722147c376bebc4313178934ce4ec0c61" translate="yes" xml:space="preserve">
          <source>Now process &quot;A&quot; updates the database and happens to change some of the data held in the initial buffer. Process &quot;A&quot; terminates, flushing all cached data to disk and releasing the database lock. At this point the database on disk will correctly reflect the changes made by process &quot;A&quot;.</source>
          <target state="translated">プロセス「A」はデータベースを更新し、初期バッファに保持されているデータの一部を変更します。プロセス「A」が終了し、すべてのキャッシュされたデータがディスクにフラッシュされ、データベースのロックが解除されます。この時点で、ディスク上のデータベースはプロセス「A」によって行われた変更を正しく反映します。</target>
        </trans-unit>
        <trans-unit id="ef78e970daca9bfe36844c130043d8db552b721e" translate="yes" xml:space="preserve">
          <source>Now re-run make to rebuild our new shared library.</source>
          <target state="translated">新しい共有ライブラリを再構築するために再実行してください。</target>
        </trans-unit>
        <trans-unit id="b502363c9d43a3258b18dcc28321bf168995d38c" translate="yes" xml:space="preserve">
          <source>Now run</source>
          <target state="translated">今すぐ実行</target>
        </trans-unit>
        <trans-unit id="43d39e890e8ba24fba8997c278066f474d3fd060" translate="yes" xml:space="preserve">
          <source>Now run perl on the top-level Makefile.PL. Notice that it also created a Makefile in the mylib directory. Run make and watch that it does cd into the mylib directory and run make in there as well.</source>
          <target state="translated">ここで、トップレベルのMakefile.PLでperlを実行します。mylibディレクトリにもMakefileが作成されていることに注意してください。makeを実行して、mylibディレクトリにcdしてそこでもmakeを実行するのを見てください。</target>
        </trans-unit>
        <trans-unit id="9680a56da8828aa80b4fe46f2d0d313dfaabb116" translate="yes" xml:space="preserve">
          <source>Now run:</source>
          <target state="translated">今すぐに実行してください。</target>
        </trans-unit>
        <trans-unit id="431a120b5d4a3c45e45ae8e764d0243bae7f6294" translate="yes" xml:space="preserve">
          <source>Now suppose we have more than one interpreter instance running at the same time. This is feasible, but only if you used the Configure option &lt;code&gt;-Dusemultiplicity&lt;/code&gt; or the options &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; when building perl. By default, enabling one of these Configure options sets the per-interpreter global variable &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; , so that thorough cleaning is automatic and interpreter variables are initialized correctly. Even if you don't intend to run two or more interpreters at the same time, but to run them sequentially, like in the above example, it is recommended to build perl with the &lt;code&gt;-Dusemultiplicity&lt;/code&gt; option otherwise some interpreter variables may not be initialized correctly between consecutive runs and your application may crash.</source>
          <target state="translated">ここで、同時に実行している複数のインタープリターインスタンスがあるとします。これは実行可能ですが、perlを &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; ときにConfigureオプション &lt;code&gt;-Dusemultiplicity&lt;/code&gt; またはオプション-Dusethreads -Duseithreadsを使用した場合のみです。デフォルトでは、これらの構成オプションの1つを有効にすると、インタープリターごとのグローバル変数 &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; が &lt;code&gt;1&lt;/code&gt; に設定されるため、完全なクリーニングが自動的に行われ、インタープリター変数が正しく初期化されます。 2つ以上のインタープリターを同時に実行するつもりはないが、上記の例のように順次実行する場合でも、 &lt;code&gt;-Dusemultiplicity&lt;/code&gt; を使用してperlをビルドすることをお勧めします。 オプションがないと、連続する実行の間に一部のインタープリター変数が正しく初期化されず、アプリケーションがクラッシュする可能性があります。</target>
        </trans-unit>
        <trans-unit id="f1903abcbcbb8a74636f09d2f5f2bcae4b5c5eed" translate="yes" xml:space="preserve">
          <source>Now suppose we have more than one interpreter instance running at the same time. This is feasible, but only if you used the Configure option &lt;code&gt;-Dusemultiplicity&lt;/code&gt; or the options &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; when building perl. By default, enabling one of these Configure options sets the per-interpreter global variable &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;, so that thorough cleaning is automatic and interpreter variables are initialized correctly. Even if you don't intend to run two or more interpreters at the same time, but to run them sequentially, like in the above example, it is recommended to build perl with the &lt;code&gt;-Dusemultiplicity&lt;/code&gt; option otherwise some interpreter variables may not be initialized correctly between consecutive runs and your application may crash.</source>
          <target state="translated">ここで、同時に複数のインタープリターインスタンスを実行しているとします。これは実行可能ですが、perlを &lt;code&gt;-Dusethreads -Duseithreads&lt;/code&gt; ときにConfigureオプション &lt;code&gt;-Dusemultiplicity&lt;/code&gt; またはオプション-Dusethreads-Duseithreadsを使用した場合に限ります。デフォルトでは、これらの構成オプションの1つを有効にすると、インタープリターごとのグローバル変数 &lt;code&gt;PL_perl_destruct_level&lt;/code&gt; が &lt;code&gt;1&lt;/code&gt; に設定されるため、完全なクリーニングが自動的に行われ、インタープリター変数が正しく初期化されます。 2つ以上のインタープリターを同時に実行するつもりはなく、上記の例のように順番に実行する場合でも、 &lt;code&gt;-Dusemultiplicity&lt;/code&gt; を使用してperlをビルドすることをお勧めします。 そうしないと、一部のインタープリター変数が連続実行間で正しく初期化されず、アプリケーションがクラッシュする可能性があります。</target>
        </trans-unit>
        <trans-unit id="e49fb62e1176de7722979d95af388dc41f0ee3b3" translate="yes" xml:space="preserve">
          <source>Now switch back to blead and merge your smoke-me branch into it:</source>
          <target state="translated">今すぐブリードに切り替えて、そこにスモークミーの枝を合体させてください。</target>
        </trans-unit>
        <trans-unit id="4e1ba3c5bd850f498e4d354eafd68e49756fd894" translate="yes" xml:space="preserve">
          <source>Now take a look at your current directory. It should look like this.</source>
          <target state="translated">では、現在のディレクトリを見てみましょう。このようになっているはずです。</target>
        </trans-unit>
        <trans-unit id="bee8b14e16d518df0acbce192d7aea4caa41e326" translate="yes" xml:space="preserve">
          <source>Now that I know how to subclass and replace TAP::Harness I can replace any other part of the harness. To do that I need to know which classes are responsible for which functionality. Here's a brief guided tour; the default class for each component is shown in parentheses. Normally any replacements I write will be subclasses of these default classes.</source>
          <target state="translated">TAP::Harness をサブクラス化して置き換える方法がわかったので、ハーネスの他の部分を置き換えることができます。そのためには、どのクラスがどの機能を担当しているかを知る必要があります。各コンポーネントのデフォルトクラスは括弧内に表示されています。通常、私が書く置き換えは、これらのデフォルトクラスのサブクラスになります。</target>
        </trans-unit>
        <trans-unit id="afb0ec981d97896d9a67b5f9341746480fee45ab" translate="yes" xml:space="preserve">
          <source>Now that UNTIE exists the class designer can decide which parts of the class functionality are really associated with &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; and which with the object being destroyed. What makes sense for a given class depends on whether the inner references are being kept so that non-tie-related methods can be called on the object. But in most cases it probably makes sense to move the functionality that would have been in DESTROY to the UNTIE method.</source>
          <target state="translated">UNTIEが存在するようになったので、クラス設計者は、クラス機能のどの部分が実際に &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; に関連付けられ、どの部分が破棄されるかを決定できます。与えられたクラスにとって何が意味があるかは、非タイ関連のメソッドがオブジェクトで呼び出せるように内部参照が保持されているかどうかに依存します。しかし、ほとんどの場合、DESTROYにあった機能をUNTIEメソッドに移動することはおそらく意味があります。</target>
        </trans-unit>
        <trans-unit id="7a99ac155b6f06ce4dfb04db2128fc497e50d4a6" translate="yes" xml:space="preserve">
          <source>Now that UNTIE exists the class designer can decide which parts of the class functionality are really associated with &lt;code&gt;untie&lt;/code&gt; and which with the object being destroyed. What makes sense for a given class depends on whether the inner references are being kept so that non-tie-related methods can be called on the object. But in most cases it probably makes sense to move the functionality that would have been in DESTROY to the UNTIE method.</source>
          <target state="translated">今UNTIEが存在することをクラスの設計者は、クラスの機能の一部が実際に関連付けられているかを決定することができ &lt;code&gt;untie&lt;/code&gt; やオブジェクトを破壊されています。特定のクラスにとって意味のあることは、内部参照が保持されているかどうかによって異なります。これにより、タイに関連しないメソッドをオブジェクトで呼び出すことができます。しかし、ほとんどの場合、DESTROYにあったはずの機能をUNTIEメソッドに移動することはおそらく理にかなっています。</target>
        </trans-unit>
        <trans-unit id="e6856d572f5c42bc67bf2b06905ca5effd5d4772" translate="yes" xml:space="preserve">
          <source>Now that basic require() and subroutines are tested, you can use the</source>
          <target state="translated">これで、基本的な require()とサブルーチンがテストされたので</target>
        </trans-unit>
        <trans-unit id="efac8814e4d76977800b30df75313c1fb6bb539a" translate="yes" xml:space="preserve">
          <source>Now that the &quot;native&quot; mechanism is supported by &lt;code&gt;Sys::Syslog&lt;/code&gt; and selected by default, the use of the &lt;code&gt;setlogsock()&lt;/code&gt; function is discouraged because other mechanisms are less portable across operating systems. Authors of modules and programs that use this function, especially its cargo-cult form &lt;code&gt;setlogsock(&quot;unix&quot;)&lt;/code&gt; , are advised to remove any occurrence of it unless they specifically want to use a given mechanism (like TCP or UDP to connect to a remote host).</source>
          <target state="translated">「ネイティブ」メカニズムが &lt;code&gt;Sys::Syslog&lt;/code&gt; サポートされ、デフォルトで選択されたため、他のメカニズムはオペレーティングシステム間で移植性が低いため、 &lt;code&gt;setlogsock()&lt;/code&gt; 関数の使用は推奨されません。この関数を使用するモジュールとプログラムの作成者、特にそのカーゴカルト形式の &lt;code&gt;setlogsock(&quot;unix&quot;)&lt;/code&gt; は、特定のメカニズム（リモートに接続するためのTCPまたはUDPなど）を特に使用したくない場合は、その発生を削除することをお勧めしますホスト）。</target>
        </trans-unit>
        <trans-unit id="d6e5bb6ea11f530904bdc5de7317a278720bcd2a" translate="yes" xml:space="preserve">
          <source>Now that the &quot;native&quot; mechanism is supported by &lt;code&gt;Sys::Syslog&lt;/code&gt; and selected by default, the use of the &lt;code&gt;setlogsock()&lt;/code&gt; function is discouraged because other mechanisms are less portable across operating systems. Authors of modules and programs that use this function, especially its cargo-cult form &lt;code&gt;setlogsock(&quot;unix&quot;)&lt;/code&gt;, are advised to remove any occurrence of it unless they specifically want to use a given mechanism (like TCP or UDP to connect to a remote host).</source>
          <target state="translated">「ネイティブ」メカニズムが &lt;code&gt;Sys::Syslog&lt;/code&gt; サポートされ、デフォルトで選択されるようになったため、他のメカニズムはオペレーティングシステム間での移植性が低いため、 &lt;code&gt;setlogsock()&lt;/code&gt; 関数の使用は推奨されません。この関数を使用するモジュールおよびプログラムの作成者、特にそのカーゴカルトフォーム &lt;code&gt;setlogsock(&quot;unix&quot;)&lt;/code&gt; は、特定のメカニズム（TCPやUDPなどのリモート接続に接続する）を特に使用する場合を除いて、この関数の発生を削除することをお勧めしますホスト）。</target>
        </trans-unit>
        <trans-unit id="2001533940f7a7dc78b5938ec0ecf76cf899fefd" translate="yes" xml:space="preserve">
          <source>Now that the core of Perl is tested, &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; can and should be used. You can also use the full suite of core modules in the tests.</source>
          <target state="translated">Perlのコアがテストされたので、&lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt;を使用できます。テストでは、コアモジュールの完全なスイートを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="24ff55bc098331b9dd0a021350302b6152b1136b" translate="yes" xml:space="preserve">
          <source>Now that there is room on the stack, values can be pushed on it using &lt;code&gt;PUSHs&lt;/code&gt; macro. The pushed values will often need to be &quot;mortal&quot; (See &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;&quot;Reference Counts and Mortality&quot;&lt;/a&gt;):</source>
          <target state="translated">スタックに &lt;code&gt;PUSHs&lt;/code&gt; があるので、PUSHマクロを使用して値をスタックにプッシュできます。プッシュされた値は、多くの場合「致命的」である必要があります（&lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;「参照数と死亡率」を参照&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7692728e97a21b18614fd5385fcbfb77d3648e29" translate="yes" xml:space="preserve">
          <source>Now that there is room on the stack, values can be pushed on it using &lt;code&gt;PUSHs&lt;/code&gt; macro. The pushed values will often need to be &quot;mortal&quot; (See &lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;Reference Counts and Mortality&lt;/a&gt;):</source>
          <target state="translated">スタックにスペースができたので、 &lt;code&gt;PUSHs&lt;/code&gt; マクロを使用してスタックに値をプッシュできます。プッシュされた値は、多くの場合「致命的」である必要があります（参照&lt;a href=&quot;#Reference-Counts-and-Mortality&quot;&gt;カウントと死亡率&lt;/a&gt;を参照）。</target>
        </trans-unit>
        <trans-unit id="db9f415821b5ff335d6377b90972d196cfedc3a0" translate="yes" xml:space="preserve">
          <source>Now that we have everything up to date, we need to create a temporary new branch for these changes and switch into it:</source>
          <target state="translated">これですべてが最新の状態になったので、これらの変更のために一時的に新しいブランチを作成し、それに切り替える必要があります。</target>
        </trans-unit>
        <trans-unit id="30355dc46fa236bc2762d6b874a869adc19e6693" translate="yes" xml:space="preserve">
          <source>Now that we have seen &lt;code&gt;P&lt;/code&gt; at work, we might as well give &lt;code&gt;p&lt;/code&gt; a whirl. Why do we need a second template code for packing pointers at all? The answer lies behind the simple fact that an &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;p&lt;/code&gt; promises a null-terminated string starting at the address taken from the buffer, and that implies a length for the data item to be returned:</source>
          <target state="translated">今、私たちが見てきたことを &lt;code&gt;P&lt;/code&gt; 仕事では、我々としても与えるかもしれない &lt;code&gt;p&lt;/code&gt; 渦を。ポインタをパックするために2番目のテンプレートコードが必要なのはなぜですか？答えは、 &lt;code&gt;p&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; したアンパックがバッファーから取得したアドレスから始まるnullで終了する文字列を約束し、返されるデータ項目の長さを暗示するという単純な事実の背後にあります。</target>
        </trans-unit>
        <trans-unit id="845be3729f8e1471aa9c19871b5191d2af6f12bb" translate="yes" xml:space="preserve">
          <source>Now that we have seen &lt;code&gt;P&lt;/code&gt; at work, we might as well give &lt;code&gt;p&lt;/code&gt; a whirl. Why do we need a second template code for packing pointers at all? The answer lies behind the simple fact that an &lt;code&gt;unpack&lt;/code&gt; with &lt;code&gt;p&lt;/code&gt; promises a null-terminated string starting at the address taken from the buffer, and that implies a length for the data item to be returned:</source>
          <target state="translated">今、私たちが見てきたことを &lt;code&gt;P&lt;/code&gt; 仕事では、我々としても与えるかもしれない &lt;code&gt;p&lt;/code&gt; 渦を。ポインタをパックするために2番目のテンプレートコードが必要なのはなぜですか？答えは、 &lt;code&gt;p&lt;/code&gt; を &lt;code&gt;unpack&lt;/code&gt; してアンパックすると、バッファから取得したアドレスで始まるnullで終了する文字列が約束され、返されるデータ項目の長さを意味するという単純な事実の背後にあります。</target>
        </trans-unit>
        <trans-unit id="3289c147e35201c5816ca81ac2c53e6c21248267" translate="yes" xml:space="preserve">
          <source>Now that we have the &lt;code&gt;*foo{THING}&lt;/code&gt; notation, typeglobs aren't used as much for filehandle manipulations, although they're still needed to pass brand new file and directory handles into or out of functions. That's because &lt;code&gt;*HANDLE{IO}&lt;/code&gt; only works if HANDLE has already been used as a handle. In other words, &lt;code&gt;*FH&lt;/code&gt; must be used to create new symbol table entries; &lt;code&gt;*foo{THING}&lt;/code&gt; cannot. When in doubt, use &lt;code&gt;*FH&lt;/code&gt; .</source>
          <target state="translated">今、私たちが持っている &lt;code&gt;*foo{THING}&lt;/code&gt; 彼らがまだ中に、または機能のうち、ブランドの新しいファイルやディレクトリハンドルを渡すために必要だが、表記を、型グロブは、ファイルハンドルの操作のための多くとして使用されていません。 &lt;code&gt;*HANDLE{IO}&lt;/code&gt; は、HANDLEがすでにハンドルとして使用されている場合にのみ機能するためです。つまり、 &lt;code&gt;*FH&lt;/code&gt; を使用して新しいシンボルテーブルエントリを作成する必要があります。 &lt;code&gt;*foo{THING}&lt;/code&gt; はできません。疑わしい場合は &lt;code&gt;*FH&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="7f7be970c41cd87a6fd574ed69a37113f5eb82d1" translate="yes" xml:space="preserve">
          <source>Now that we have the &lt;code&gt;*foo{THING}&lt;/code&gt; notation, typeglobs aren't used as much for filehandle manipulations, although they're still needed to pass brand new file and directory handles into or out of functions. That's because &lt;code&gt;*HANDLE{IO}&lt;/code&gt; only works if HANDLE has already been used as a handle. In other words, &lt;code&gt;*FH&lt;/code&gt; must be used to create new symbol table entries; &lt;code&gt;*foo{THING}&lt;/code&gt; cannot. When in doubt, use &lt;code&gt;*FH&lt;/code&gt;.</source>
          <target state="translated">今、私たちが持っている &lt;code&gt;*foo{THING}&lt;/code&gt; 彼らがまだ中に、または機能のうち、ブランドの新しいファイルやディレクトリハンドルを渡すために必要だが、表記を、型グロブは、ファイルハンドルの操作のための多くとして使用されていません。これは、 &lt;code&gt;*HANDLE{IO}&lt;/code&gt; が機能するのは、HANDLEがすでにハンドルとして使用されている場合のみであるためです。つまり、新しいシンボルテーブルエントリを作成するには、 &lt;code&gt;*FH&lt;/code&gt; を使用する必要があります。 &lt;code&gt;*foo{THING}&lt;/code&gt; はできません。疑わしい場合は、 &lt;code&gt;*FH&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="94fb438178c3f179a69d1380f1c008b5fe2d33bb" translate="yes" xml:space="preserve">
          <source>Now that we have this pattern stored as a handy string, we might feel tempted to use it as a part of some other pattern:</source>
          <target state="translated">このパターンが便利な文字列として保存されているので、他のパターンの一部として使用したくなるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e29c91f0a31611481726db8f6cd5987db898348a" translate="yes" xml:space="preserve">
          <source>Now that we know the two token types we want to look for in the parser, let's take the piece of</source>
          <target state="translated">パーサで探したい 2 つのトークンの型がわかったので、次は</target>
        </trans-unit>
        <trans-unit id="c183105c83816c48c77d4c827336e4e813e84f27" translate="yes" xml:space="preserve">
          <source>Now that we've covered the basics of threads, it's time for our next topic: Data. Threading introduces a couple of complications to data access that non-threaded programs never need to worry about.</source>
          <target state="translated">さて、スレッドの基本的なことはおさらいしたので、次のトピックに移りましょう。データです。スレッドはデータアクセスにいくつかの複雑さをもたらしますが、スレッド化されていないプログラムでは決して心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="17f47b8aedf9a1b8e0f108087ca6f763b020db20" translate="yes" xml:space="preserve">
          <source>Now that you know what the problem is, what can you do to avoid it? Prior to the introduction of the optional UNTIE method the only way was the good old &lt;code&gt;-w&lt;/code&gt; flag. Which will spot any instances where you call untie() and there are still valid references to the tied object. If the second script above this near the top &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'untie'&lt;/code&gt; or was run with the &lt;code&gt;-w&lt;/code&gt; flag, Perl prints this warning message:</source>
          <target state="translated">問題が何であるかがわかったところで、それを回避するために何ができますか？オプションのUNTIEメソッドが導入される前は、古き良き &lt;code&gt;-w&lt;/code&gt; フラグが唯一の方法でした。これにより、untie（）を呼び出すインスタンスが検出され、tieオブジェクトへの有効な参照がまだ存在します。この上部の2番目のスクリプトが &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'untie'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用する&lt;/a&gt;か「unie」を使用するか、 &lt;code&gt;-w&lt;/code&gt; フラグを指定して実行した場合、Perlは次の警告メッセージを出力します。</target>
        </trans-unit>
        <trans-unit id="9771972202eb1f3782008cf8f55ca4ed0bc679ec" translate="yes" xml:space="preserve">
          <source>Now that you know what the problem is, what can you do to avoid it? Prior to the introduction of the optional UNTIE method the only way was the good old &lt;code&gt;-w&lt;/code&gt; flag. Which will spot any instances where you call untie() and there are still valid references to the tied object. If the second script above this near the top &lt;code&gt;use warnings 'untie'&lt;/code&gt; or was run with the &lt;code&gt;-w&lt;/code&gt; flag, Perl prints this warning message:</source>
          <target state="translated">問題が何であるかがわかったので、それを回避するために何ができますか？オプションのUNTIEメソッドが導入される前は、古き良き &lt;code&gt;-w&lt;/code&gt; フラグが唯一の方法でした。これにより、untie（）を呼び出しても、関連付けられたオブジェクトへの有効な参照が残っているインスタンスが検出されます。この上の2番目のスクリプトが &lt;code&gt;use warnings 'untie'&lt;/code&gt; か、 &lt;code&gt;-w&lt;/code&gt; フラグを指定して実行された場合、Perlは次の警告メッセージを出力します。</target>
        </trans-unit>
        <trans-unit id="38c455331af53bbe930455abd94381aad022a312" translate="yes" xml:space="preserve">
          <source>Now that you understand how &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; looks for files with a bareword argument, there is a little extra functionality going on behind the scenes. Before &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; looks for a</source>
          <target state="translated">&lt;a href=&quot;#require-VERSION&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt;がベアワード引数を持つファイルを検索する方法を理解したので、舞台裏で少し追加の機能が実行されています。前に&lt;a href=&quot;#require-VERSION&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt;Aのルックスを</target>
        </trans-unit>
        <trans-unit id="022bdd2be74a4d788e977f99278118a67ba2ad8d" translate="yes" xml:space="preserve">
          <source>Now that you understand how &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for files with a bareword argument, there is a little extra functionality going on behind the scenes. Before &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for a &quot;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; がベアワード引数を持つファイルを検索する方法を理解したので、舞台裏で少し余分な機能が実行されています。 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 前に、</target>
        </trans-unit>
        <trans-unit id="597f8013d78df265fd55b188a128a0c6cbbf532e" translate="yes" xml:space="preserve">
          <source>Now that you understand how &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for files with a bareword argument, there is a little extra functionality going on behind the scenes. Before &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; looks for a &quot;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; がベアワード引数を持つファイルを検索する方法を理解したので、舞台裏で少し余分な機能が実行されています。 &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 前に、</target>
        </trans-unit>
        <trans-unit id="b76e84f2c33cd5c972aa524cad0960f89f22f060" translate="yes" xml:space="preserve">
          <source>Now the command line may look like:</source>
          <target state="translated">これでコマンドラインは次のようになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="3b566ef89971d6ba2da0e75e174d6b74566a53f9" translate="yes" xml:space="preserve">
          <source>Now the contents of the zip file looks like this</source>
          <target state="translated">これで、zipファイルの内容は以下のようになります。</target>
        </trans-unit>
        <trans-unit id="b70b0be20fc0cb8a073d7d288b92a6e5925d77b2" translate="yes" xml:space="preserve">
          <source>Now the output doesn't have the spaces between the elements because the elements of &lt;code&gt;@animals&lt;/code&gt; simply become part of the list to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">要素ので、今の出力は、要素間のスペースを持っていない &lt;code&gt;@animals&lt;/code&gt; は単純にするために、リストの一部となる &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f6712df82bd0b409fccf382c7eb4775322c433e9" translate="yes" xml:space="preserve">
          <source>Now the output doesn't have the spaces between the elements because the elements of &lt;code&gt;@animals&lt;/code&gt; simply become part of the list to &lt;code&gt;print&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;@animals&lt;/code&gt; の要素は単にリストの一部になって &lt;code&gt;print&lt;/code&gt; ため、出力には要素間にスペースがありません。</target>
        </trans-unit>
        <trans-unit id="3c3e5717f93544ac6beb2dcf88b8c55f969febc1" translate="yes" xml:space="preserve">
          <source>Now the output shows that &lt;code&gt;foo&lt;/code&gt; doesn't get the &lt;code&gt;@_&lt;/code&gt; from its caller.</source>
          <target state="translated">出力は、 &lt;code&gt;foo&lt;/code&gt; が呼び出し元から &lt;code&gt;@_&lt;/code&gt; を取得しないことを示しています。</target>
        </trans-unit>
        <trans-unit id="3fcb9eb262daa67d00f7dccd8fa99c81f713a40e" translate="yes" xml:space="preserve">
          <source>Now the parsing stage is complete, and the finished tree represents the operations that the Perl interpreter needs to perform to execute our program. Next, Perl does a dry run over the tree looking for optimisations: constant expressions such as &lt;code&gt;3 + 4&lt;/code&gt; will be computed now, and the optimizer will also see if any multiple operations can be replaced with a single one. For instance, to fetch the variable &lt;code&gt;$foo&lt;/code&gt; , instead of grabbing the glob &lt;code&gt;*foo&lt;/code&gt; and looking at the scalar component, the optimizer fiddles the op tree to use a function which directly looks up the scalar in question. The main optimizer is &lt;code&gt;peep&lt;/code&gt; in</source>
          <target state="translated">これで解析段階が完了し、完成したツリーは、Perlインタープリターがプログラムを実行するために実行する必要がある操作を表しています。次に、Perlはツリーに対してドライランを実行して最適化を探します。3+ &lt;code&gt;3 + 4&lt;/code&gt; などの定数式が計算され、オプティマイザーは複数の操作を単一の操作に置き換えることができるかどうかも確認します。たとえば、変数 &lt;code&gt;$foo&lt;/code&gt; をフェッチするには、グロブ &lt;code&gt;*foo&lt;/code&gt; を取得してスカラーコンポーネントを調べる代わりに、オプティマイザーがopツリーをいじって、問題のスカラーを直接検索する関数を使用します。主なオプティマイザーは &lt;code&gt;peep&lt;/code&gt; です</target>
        </trans-unit>
        <trans-unit id="81df9ba059e2ff0a47a803c9c1c7ea076906b2e7" translate="yes" xml:space="preserve">
          <source>Now the parsing stage is complete, and the finished tree represents the operations that the Perl interpreter needs to perform to execute our program. Next, Perl does a dry run over the tree looking for optimisations: constant expressions such as &lt;code&gt;3 + 4&lt;/code&gt; will be computed now, and the optimizer will also see if any multiple operations can be replaced with a single one. For instance, to fetch the variable &lt;code&gt;$foo&lt;/code&gt;, instead of grabbing the glob &lt;code&gt;*foo&lt;/code&gt; and looking at the scalar component, the optimizer fiddles the op tree to use a function which directly looks up the scalar in question. The main optimizer is &lt;code&gt;peep&lt;/code&gt; in</source>
          <target state="translated">これで解析段階が完了し、完成したツリーは、Perlインタープリターがプログラムを実行するために実行する必要のある操作を表しています。次に、Perlはツリー上でドライランを実行して最適化を探します &lt;code&gt;3 + 4&lt;/code&gt; などの定数式が計算され、オプティマイザーは複数の操作を1つに置き換えることができるかどうかも確認します。たとえば、変数 &lt;code&gt;$foo&lt;/code&gt; をフェッチするために、glob &lt;code&gt;*foo&lt;/code&gt; を取得してスカラーコンポーネントを調べる代わりに、オプティマイザーはopツリーをいじって、問題のスカラーを直接検索する関数を使用します。主なオプティマイザーは &lt;code&gt;peep&lt;/code&gt; です</target>
        </trans-unit>
        <trans-unit id="0b0d2c80b383fda949460859c7cc860ad47a12c4" translate="yes" xml:space="preserve">
          <source>Now the rpcb_gettime() function can be used from Perl with the following statement.</source>
          <target state="translated">これで、rpcb_gettime()関数がPerlから次のような文で使えるようになりました。</target>
        </trans-unit>
        <trans-unit id="9b44a2219a59e7204e7ee350a2cc75af078d1e4b" translate="yes" xml:space="preserve">
          <source>Now think about</source>
          <target state="translated">今、考えてみてください。</target>
        </trans-unit>
        <trans-unit id="c30cd0c985054472ce92540629db69d82b31ed97" translate="yes" xml:space="preserve">
          <source>Now think of each logical connection between the Perl parser and an individual file as a</source>
          <target state="translated">ここで、Perl パーサと個々のファイルの間の論理的な接続を</target>
        </trans-unit>
        <trans-unit id="c36ab80c850235a2a6535979a5e221cbafe139d7" translate="yes" xml:space="preserve">
          <source>Now to use it:</source>
          <target state="translated">今度はそれを使うために。</target>
        </trans-unit>
        <trans-unit id="63aed2505c6485cbd9c4824f7162c565df48aa33" translate="yes" xml:space="preserve">
          <source>Now type</source>
          <target state="translated">今すぐタイプ</target>
        </trans-unit>
        <trans-unit id="69d98bfb814f8df94eddba674df944be471dcc9f" translate="yes" xml:space="preserve">
          <source>Now we also need to create a typemap because the default Perl doesn't currently support the &lt;code&gt;const char *&lt;/code&gt; type. Include a new TYPEMAP section in your XS code before the above function:</source>
          <target state="translated">デフォルトのPerlは現在 &lt;code&gt;const char *&lt;/code&gt; 型をサポートしていないため、今度はタイプマップも作成する必要があります。上記の関数の前に、新しいTYPEMAPセクションをXSコードに含めます。</target>
        </trans-unit>
        <trans-unit id="ac3c0b8b639b2123b87b956629756b446c6934e9" translate="yes" xml:space="preserve">
          <source>Now we can have a look at that first ($key) variable:</source>
          <target state="translated">さて、最初の変数 ($key)を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="8697ceaf2dd16f4d4adec9ebfeb7ec483f31a8a6" translate="yes" xml:space="preserve">
          <source>Now we can inspect the change:</source>
          <target state="translated">これで変更点の検査ができるようになりました。</target>
        </trans-unit>
        <trans-unit id="185a7b552e431f4b4b46cbef152d792a78593a6f" translate="yes" xml:space="preserve">
          <source>Now we can match the 'a' and the 't'.</source>
          <target state="translated">これで'a'と't'を一致させることができるようになりました。</target>
        </trans-unit>
        <trans-unit id="1a6585115684561f6afa96412beafcc752dc7c11" translate="yes" xml:space="preserve">
          <source>Now we can test bunches of dates by just adding them to &lt;code&gt;%ICal_Dates&lt;/code&gt;. Now that it's less work to test with more dates, you'll be inclined to just throw more in as you think of them. Only problem is, every time we add to that we have to keep adjusting the &lt;code&gt;use Test::More tests =&amp;gt; ##&lt;/code&gt; line. That can rapidly get annoying. There are ways to make this work better.</source>
          <target state="translated">これで、日付の束を &lt;code&gt;%ICal_Dates&lt;/code&gt; に追加するだけでテストできます。より多くの日付でテストする作業が少なくなったので、あなたはそれらについて考えるように、より多くを投入する傾向があります。唯一の問題は、それに追加するたびに、 &lt;code&gt;use Test::More tests =&amp;gt; ##&lt;/code&gt; 行を調整し続ける必要があるということです。それはすぐに迷惑になる可能性があります。これをより良くする方法があります。</target>
        </trans-unit>
        <trans-unit id="2bd64428bd387110ec5af71e395507d7b42d715c" translate="yes" xml:space="preserve">
          <source>Now we can use the subroutine just as any other built-in function:</source>
          <target state="translated">これで、他の組み込み関数と同じようにサブルーチンを使うことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="5dd4060fc442a49be75b77cb5ad37ebb6eff79fc" translate="yes" xml:space="preserve">
          <source>Now we have a special case. The &lt;code&gt;EXACT&lt;/code&gt; regop has a &lt;code&gt;regnext&lt;/code&gt; of 0. This is because if it matches it should try to match itself again. The &lt;code&gt;PLUS&lt;/code&gt; regop handles the actual failure of the &lt;code&gt;EXACT&lt;/code&gt; regop and acts appropriately (going to regnode 6 if the &lt;code&gt;EXACT&lt;/code&gt; matched at least once, or failing if it didn't).</source>
          <target state="translated">今、私たちは特別なケースを持っています。 &lt;code&gt;EXACT&lt;/code&gt; regopはあり &lt;code&gt;regnext&lt;/code&gt; それが一致した場合、それは再び自分自身を一致させるようにしてくださいので、これは0のを。 &lt;code&gt;PLUS&lt;/code&gt; regopハンドルの実際の故障 &lt;code&gt;EXACT&lt;/code&gt; regopおよび（場合6 regnodeしようと適切に作用 &lt;code&gt;EXACT&lt;/code&gt; 少なくとも一度一致、またはそれがなかった場合は失敗）。</target>
        </trans-unit>
        <trans-unit id="9e8623792298834d51348eb8a4e63d54b4322603" translate="yes" xml:space="preserve">
          <source>Now we make the script executable (&lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt; +x hello&lt;/code&gt; ), run the script and we should see the following output:</source>
          <target state="translated">スクリプトを実行可能にして（ &lt;code&gt;&lt;a href=&quot;functions/chmod&quot;&gt;chmod&lt;/a&gt; +x hello&lt;/code&gt; ）、スクリプトを実行すると、次の出力が表示されます。</target>
        </trans-unit>
        <trans-unit id="612f354eccf60522636de9e810f79a1b463240fa" translate="yes" xml:space="preserve">
          <source>Now we make the script executable (&lt;code&gt;chmod +x hello&lt;/code&gt;), run the script and we should see the following output:</source>
          <target state="translated">ここで、スクリプトを実行可能にし（ &lt;code&gt;chmod +x hello&lt;/code&gt; ）、スクリプトを実行すると、次の出力が表示されます。</target>
        </trans-unit>
        <trans-unit id="27be17fcef7387e3ac6e2da3084db2de80fc9a40" translate="yes" xml:space="preserve">
          <source>Now we pass Perl the command line options, and tell it to go:</source>
          <target state="translated">ここで、Perlにコマンドラインオプションを渡して、それを実行するように指示します。</target>
        </trans-unit>
        <trans-unit id="ddfe38df65672eb8cb8bb6b4c2a3925df733b91b" translate="yes" xml:space="preserve">
          <source>Now we read that file in paragraph mode:</source>
          <target state="translated">では、そのファイルをパラグラフモードで読み込んでみましょう。</target>
        </trans-unit>
        <trans-unit id="619205ae318e9243260c596997993412134beb8d" translate="yes" xml:space="preserve">
          <source>Now we skip another character and pick up the next 7 characters:</source>
          <target state="translated">今度は別のキャラを飛ばして、次の7キャラをピックアップします。</target>
        </trans-unit>
        <trans-unit id="00d5b0ef9c96351760d2c5c765c6707b0214ca3c" translate="yes" xml:space="preserve">
          <source>Now we'll continue down into our subroutine, this time rather than by line number, we'll use the subroutine name, followed by the now familiar 'v':</source>
          <target state="translated">今度は行番号ではなく、サブルーチン名と、おなじみの'v'の後に続く'v'を使ってみましょう。</target>
        </trans-unit>
        <trans-unit id="cb9e80e524c6f9e9ce8a182f0f81c0eb761fa3d6" translate="yes" xml:space="preserve">
          <source>Now we'll run &quot;&lt;code&gt;perl Makefile.PL&lt;/code&gt; &quot;. This will create a real Makefile, which make needs. Its output looks something like:</source>
          <target state="translated">次に、「 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 」を実行します。これにより、必要とする実際のMakefileが作成されます。出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="35f5a06d15d5037b074e44b9f8538d07cbd8815f" translate="yes" xml:space="preserve">
          <source>Now we'll run &quot;&lt;code&gt;perl Makefile.PL&lt;/code&gt;&quot;. This will create a real Makefile, which make needs. Its output looks something like:</source>
          <target state="translated">次に、「 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 」を実行します。これにより、ニーズに対応する実際のMakefileが作成されます。その出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="2de2aee884a419878e3de43e61bda1852424c1b9" translate="yes" xml:space="preserve">
          <source>Now we'll test that we got that space-at-the-beginning business right:</source>
          <target state="translated">さて、最初のビジネスのスタート地点であるスペースが正しいかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="ee9f66c8ea145e68aa8eae836da50bbcb17dec57" translate="yes" xml:space="preserve">
          <source>Now we're finally ready to go: we have compiled Perl byte code, and all that's left to do is run it. The actual execution is done by the &lt;code&gt;runops_standard&lt;/code&gt; function in</source>
          <target state="translated">これでようやく準備が整いました。Perlバイトコードをコンパイルしました。あとはそれを実行するだけです。実際の実行は、 &lt;code&gt;runops_standard&lt;/code&gt; 関数によって行われます。</target>
        </trans-unit>
        <trans-unit id="952f473e58faf0d44b6ff273d0893bc5ac586a94" translate="yes" xml:space="preserve">
          <source>Now when you run it, perl complains about the 3 undeclared variables and we get four error messages because one variable is referenced twice:</source>
          <target state="translated">これで実行すると、Perlは3つの未宣言の変数について文句を言い、1つの変数が2回参照されているために4つのエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="fd8037c01a5003f5b294e5c2293670a0337f93e2" translate="yes" xml:space="preserve">
          <source>Now when you run, it's a little different:</source>
          <target state="translated">今は走るとちょっと違う。</target>
        </trans-unit>
        <trans-unit id="0876df351c2b288f71557a0b6c1ab72f84bc0972" translate="yes" xml:space="preserve">
          <source>Now you can add new rows. What about adding new columns? If you're dealing with just matrices, it's often easiest to use simple assignment:</source>
          <target state="translated">これで新しい行を追加できるようになりました。新しい列を追加するにはどうすればいいのでしょうか?行列だけを扱う場合は、単純な代入を使うのが一番簡単です。</target>
        </trans-unit>
        <trans-unit id="2be97d39881315756923220b5afaca5ad300443e" translate="yes" xml:space="preserve">
          <source>Now you can check whether &lt;code&gt;$is_blue{$some_color}&lt;/code&gt; . It might have been a good idea to keep the blues all in a hash in the first place.</source>
          <target state="translated">これで、 &lt;code&gt;$is_blue{$some_color}&lt;/code&gt; かどうかを確認できます。そもそもブルースをすべてハッシュにしておくのは良い考えだったかもしれません。</target>
        </trans-unit>
        <trans-unit id="13e8faf4edbb7badf8e22509c8ca447a6e463db3" translate="yes" xml:space="preserve">
          <source>Now you can check whether &lt;code&gt;$is_blue{$some_color}&lt;/code&gt;. It might have been a good idea to keep the blues all in a hash in the first place.</source>
          <target state="translated">これで、 &lt;code&gt;$is_blue{$some_color}&lt;/code&gt; かどうかを確認できます。そもそもブルースをすべてハッシュにしておくのは良い考えだったかもしれません。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
