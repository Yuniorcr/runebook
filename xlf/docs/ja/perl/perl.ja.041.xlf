<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="d7a3ea6043299cfce500bdda50fb23f6cbea5c5c" translate="yes" xml:space="preserve">
          <source>Initialize MAKE from either a MAKE environment variable or $Config{make}.</source>
          <target state="translated">MAKEをMAKE環境変数または$Config{make}から初期化します。</target>
        </trans-unit>
        <trans-unit id="8a7c7a1b384ad47d60773edd82ad26376d621207" translate="yes" xml:space="preserve">
          <source>Initialize any macros which are for platform specific use only.</source>
          <target state="translated">プラットフォーム固有の使用のためだけのマクロを初期化します。</target>
        </trans-unit>
        <trans-unit id="4476040d6adc770412cdb2150cb39c32735c92d5" translate="yes" xml:space="preserve">
          <source>Initialize macros representing versions of MakeMaker and other tools</source>
          <target state="translated">MakeMakerや他のツールのバージョンを表すマクロを初期化する</target>
        </trans-unit>
        <trans-unit id="fa2a269c8bcaa8f7394ce2454e1f32bd30c51822" translate="yes" xml:space="preserve">
          <source>Initialize macros which have to do with linking.</source>
          <target state="translated">リンクに関係するマクロを初期化します。</target>
        </trans-unit>
        <trans-unit id="cf8b76ad5759b00cf83505f7cf706fcbd53a36ab" translate="yes" xml:space="preserve">
          <source>Initialize the SigSet object to be empty.</source>
          <target state="translated">SigSet オブジェクトを空に初期化します。</target>
        </trans-unit>
        <trans-unit id="553a04fdd695ae3cee805a386f6c72d5ee7c6e5d" translate="yes" xml:space="preserve">
          <source>Initialize the SigSet object to include all signals.</source>
          <target state="translated">すべてのシグナルを含むようにSigSetオブジェクトを初期化します。</target>
        </trans-unit>
        <trans-unit id="7ff28902a2edd7a86041272b550eea681cfd2a0b" translate="yes" xml:space="preserve">
          <source>Initializes AR, AR_STATIC_ARGS, BASEEXT, CONFIG, DISTNAME, DLBASE, EXE_EXT, FULLEXT, FULLPERL, FULLPERLRUN, FULLPERLRUNINST, INST_*, INSTALL*, INSTALLDIRS, LIB_EXT, LIBPERL_A, MAP_TARGET, NAME, OBJ_EXT, PARENT_NAME, PERL, PERL_ARCHLIB, PERL_INC, PERL_LIB, PERL_SRC, PERLRUN, PERLRUNINST, PREFIX, VERSION, VERSION_SYM, XS_VERSION.</source>
          <target state="translated">AR、AR_STATIC_ARGS、BASEEXT、CONFIG、DISTNAME、DLBASE、EXE_EXT、FULLEXT、FULLPERL、FULLPERLRUN、FULLPERLRUNINST、INST_*、INSTALL*、INSTALLDIRS、LIB_EXTを初期化します。LIBPERL_A,MAP_TARGET,NAME,OBJ_EXT,PARENT_NAME,PERL,PERL_ARCHLIB,PERL_INC,PERL_LIB,PERL_SRC,PERLRUN,PERLRUNINST,PREFIX,VERSION,VERSION_SYM,XS_VERSION.</target>
        </trans-unit>
        <trans-unit id="9b0af4794c1652a453537aa4d31bc51217044cfb" translate="yes" xml:space="preserve">
          <source>Initializes MAN1PODS from the list of EXE_FILES.</source>
          <target state="translated">EXE_FILESのリストからMAN1PODSを初期化します。</target>
        </trans-unit>
        <trans-unit id="9908a02e0ec97a9887147642e25f6d00ba2bba87" translate="yes" xml:space="preserve">
          <source>Initializes MAN3PODS from the list of PM files.</source>
          <target state="translated">PMファイルのリストからMAN3PODSを初期化します。</target>
        </trans-unit>
        <trans-unit id="78aa0c8b31d0aa9e4f082b472e25049793a28d4c" translate="yes" xml:space="preserve">
          <source>Initializes PMLIBDIRS and PM from PMLIBDIRS.</source>
          <target state="translated">PMLIBDIRS と PM を PMLIBDIRS から初期化します。</target>
        </trans-unit>
        <trans-unit id="f52193e05865340eb9150e274aa92320b071b3c6" translate="yes" xml:space="preserve">
          <source>Initializes a new Perl interpreter. See &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">新しいPerlインタープリターを初期化します。&lt;a href=&quot;perlembed&quot;&gt;perlembedを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d157e4855cf1cd1f0584d861b76b87bbd1430bbd" translate="yes" xml:space="preserve">
          <source>Initializes a new object. This method is a stub by default, you should override it as appropriate.</source>
          <target state="translated">新しいオブジェクトを初期化します。このメソッドはデフォルトではスタブになっているので、適宜オーバーライドしてください。</target>
        </trans-unit>
        <trans-unit id="9cf6c0c33242d2abf005967a6623b3ae8501f304" translate="yes" xml:space="preserve">
          <source>Initializes the DIRFILESEP macro which is the separator between the directory and filename in a filepath. ie. / on Unix, \ on Win32 and nothing on VMS.</source>
          <target state="translated">ファイルパス内のディレクトリとファイル名の間のセパレータであるDIRFILESEPマクロを初期化します。</target>
        </trans-unit>
        <trans-unit id="1f6be944d9e52d97024d9034508b4cacc682c441" translate="yes" xml:space="preserve">
          <source>Initializes the macro definitions having to do with compiling and linking used by tools_other() and places them in the $MM object.</source>
          <target state="translated">tools_other()で使用するコンパイルとリンクに関わるマクロ定義を初期化し、$MMオブジェクトに配置します。</target>
        </trans-unit>
        <trans-unit id="e775d4b4b0bd3712f9f514299a1d05c1a00cf523" translate="yes" xml:space="preserve">
          <source>Initializes the simple macro definitions used by tools_other() and places them in the $MM object. These use conservative cross platform versions and should be overridden with platform specific versions for performance.</source>
          <target state="translated">tools_other()で使用するシンプルなマクロ定義を初期化し、 $MM オブジェクトに配置します。これらは、保守的なクロスプラットフォームバージョンを使用しており、パフォーマンスのためにプラットフォーム固有のバージョンでオーバーライドする必要があります。</target>
        </trans-unit>
        <trans-unit id="282f9af1f24130bc9182b79671b3debcbe420b2a" translate="yes" xml:space="preserve">
          <source>Initializes tools to use their common (and faster) Unix commands.</source>
          <target state="translated">共通の(より高速な)Unixコマンドを使用するためのツールを初期化します。</target>
        </trans-unit>
        <trans-unit id="7a196e34c731e5f3af1e31be4705513bd9e1800a" translate="yes" xml:space="preserve">
          <source>Initializing Function Parameters</source>
          <target state="translated">関数パラメータの初期化</target>
        </trans-unit>
        <trans-unit id="f762e2df9b5c50638aa3c3cbbaf63d08b1a096ce" translate="yes" xml:space="preserve">
          <source>Initializing with &lt;code&gt;new&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 初期化</target>
        </trans-unit>
        <trans-unit id="5374c9bb7d82a306aff38df30638934a3bedb34d" translate="yes" xml:space="preserve">
          <source>Initializing with new</source>
          <target state="translated">新規での初期化</target>
        </trans-unit>
        <trans-unit id="16e4c7e9d2fa46d1492e494337cfb9b14642fd7d" translate="yes" xml:space="preserve">
          <source>Initiate the sending of the data from the current message.</source>
          <target state="translated">現在のメッセージからデータの送信を開始します。</target>
        </trans-unit>
        <trans-unit id="b6b3360634a6df83161df89335cce0e40b6cc3dd" translate="yes" xml:space="preserve">
          <source>Initiates a TCP connection, for a tcp ping.</source>
          <target state="translated">TCP 接続を開始します。</target>
        </trans-unit>
        <trans-unit id="fe9280fcef1f95066c459792b601f0a568c68ff3" translate="yes" xml:space="preserve">
          <source>Inplace editing &lt;code&gt;perl -i&lt;/code&gt; of files doesn't work without doing a backup of the file being edited &lt;code&gt;perl -i.bak&lt;/code&gt; because of windowish restrictions, therefore Perl adds the suffix &lt;code&gt;.bak&lt;/code&gt; automatically if you use &lt;code&gt;perl -i&lt;/code&gt; without specifying a backup extension.</source>
          <target state="translated">ファイルのインプレース編集 &lt;code&gt;perl -i&lt;/code&gt; は、ウィンドウの制限のため、 &lt;code&gt;perl -i.bak&lt;/code&gt; で編集中のファイルのバックアップを作成しないと機能しません。したがって、バックアップ拡張子を指定せずに &lt;code&gt;perl -i&lt;/code&gt; を使用すると、Perlは自動的に接尾辞 &lt;code&gt;.bak&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="f2166976e1182028cf4a602c00df0206990e4b61" translate="yes" xml:space="preserve">
          <source>Input File Glob</source>
          <target state="translated">入力ファイルグローバル</target>
        </trans-unit>
        <trans-unit id="b6852c995fba635b92f942abb161a06e4a4f682b" translate="yes" xml:space="preserve">
          <source>Input and Output Layers</source>
          <target state="translated">入出力レイヤ</target>
        </trans-unit>
        <trans-unit id="2dc35a576a410b10bc60ae6d2130c68130a12559" translate="yes" xml:space="preserve">
          <source>Input and Output Parameters</source>
          <target state="translated">入出力パラメータ</target>
        </trans-unit>
        <trans-unit id="c77783bb0c7d4d2f9b2b8bd6478b069981c0866f" translate="yes" xml:space="preserve">
          <source>Input and output</source>
          <target state="translated">入力と出力</target>
        </trans-unit>
        <trans-unit id="e6d4856593d1efd1c0cd8430882cae3851f3f706" translate="yes" xml:space="preserve">
          <source>Input and output functions</source>
          <target state="translated">入出力機能</target>
        </trans-unit>
        <trans-unit id="fca6ebb3af2e2ddf731c9ba341152d5ee6d08083" translate="yes" xml:space="preserve">
          <source>Input and output pipes to Perl filehandles are supported; the &quot;file name&quot; is passed to lib$spawn() for asynchronous execution. You should be careful to close any pipes you have opened in a Perl script, lest you leave any &quot;orphaned&quot; subprocesses around when Perl exits.</source>
          <target state="translated">Perl ファイルハンドルへの入出力パイプがサポートされています。Perl スクリプトの中で開いたパイプを閉じる際には注意が必要です。</target>
        </trans-unit>
        <trans-unit id="25e7b83bd15298faf6fd8f002de9128fb08ea38f" translate="yes" xml:space="preserve">
          <source>Input from, or output to, a &lt;b&gt;file&lt;/b&gt; or &lt;b&gt;device&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;ファイル&lt;/b&gt;または&lt;b&gt;デバイス&lt;/b&gt;からの入力、または&lt;b&gt;ファイル&lt;/b&gt;または&lt;b&gt;デバイス&lt;/b&gt;への出力。</target>
        </trans-unit>
        <trans-unit id="78a923bcd93c4171316cc3a1bc09d0aa6f07ef83" translate="yes" xml:space="preserve">
          <source>Input given as scalar numbers might lose precision. Quote your input to ensure that no digits are lost:</source>
          <target state="translated">スカラ数として与えられた入力は、精度を失う可能性があります。桁が失われないように入力を引用してください。</target>
        </trans-unit>
        <trans-unit id="f6047072eebf842c882d2d1ca55ea7667206a889" translate="yes" xml:space="preserve">
          <source>Input library and path specifications are accepted with or without the &lt;code&gt;-l&lt;/code&gt; and &lt;code&gt;-L&lt;/code&gt; prefixes used by Unix linkers.</source>
          <target state="translated">入力ライブラリとパスの指定は、Unixリンカーで使用される &lt;code&gt;-l&lt;/code&gt; および &lt;code&gt;-L&lt;/code&gt; プレフィックスの有無にかかわらず受け入れられます。</target>
        </trans-unit>
        <trans-unit id="db35c0f2c45290c19fd136029a213ad284b80e55" translate="yes" xml:space="preserve">
          <source>Input library and path specifications are accepted with or without the &lt;code&gt;-l&lt;/code&gt; and &lt;code&gt;-L&lt;/code&gt; prefixes used by Unix linkers. If neither prefix is present, a token is considered a directory to search if it is in fact a directory, and a library to search for otherwise. Authors who wish their extensions to be portable to Unix or OS/2 should use the Unix prefixes, since the Unix-OS/2 version of ext() requires them.</source>
          <target state="translated">入力ライブラリとパスの指定は、Unixリンカーで使用される &lt;code&gt;-l&lt;/code&gt; および &lt;code&gt;-L&lt;/code&gt; プレフィックスの有無にかかわらず受け入れられます。どちらのプレフィックスも存在しない場合、トークンは、それが実際にディレクトリである場合は検索するディレクトリと見なされ、そうでない場合は検索するライブラリと見なされます。拡張機能をUnixまたはOS / 2に移植できるようにしたい作者は、Unix-OS / 2バージョンのext（）が必要とするため、Unixプレフィックスを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="a1f8b7d0598aac2b8e4ba4b9244e4a933dc9e6b4" translate="yes" xml:space="preserve">
          <source>Input strings are decode()d then encode()d. A straight two-step implementation.</source>
          <target state="translated">入力文字列は decode()d の後に encode()d となります。ストレートな二段階の実装です。</target>
        </trans-unit>
        <trans-unit id="ff3057c52ba4da6e1ddf88eb538e9f34e59f7ee9" translate="yes" xml:space="preserve">
          <source>Input to these routines are either BigFloat objects, or strings of the following four forms:</source>
          <target state="translated">これらのルーチンへの入力は、BigFloatオブジェクト、または以下の4つの形式の文字列のいずれかです。</target>
        </trans-unit>
        <trans-unit id="84961be9b7c2809d89e0848f01fd0ffc9df02327" translate="yes" xml:space="preserve">
          <source>Input values to these routines may be any scalar number or string that looks like a number and represents a floating point number.</source>
          <target state="translated">これらのルーチンへの入力値は、数値のように見えて浮動小数点数を表す任意のスカラ数または文字列である可能性があります。</target>
        </trans-unit>
        <trans-unit id="2156929b7310422c8528b3fc6dfc3918a5f73f99" translate="yes" xml:space="preserve">
          <source>Input values to these routines may be any scalar number or string that looks like a number and represents an integer.</source>
          <target state="translated">これらのルーチンへの入力値は、数値のように見えて整数を表すスカラ数や文字列であっても構いません。</target>
        </trans-unit>
        <trans-unit id="0c0281be753361164d1d0fc4c9f4d612cf39dd2d" translate="yes" xml:space="preserve">
          <source>Input values to these routines may be any string, that looks like a number and results in an integer, including hexadecimal and binary numbers.</source>
          <target state="translated">これらのルーチンへの入力値は、16進数や2進数を含む、数字のように見えて整数になる任意の文字列にすることができます。</target>
        </trans-unit>
        <trans-unit id="ff508ce692e1254966736e47898113545150b2ac" translate="yes" xml:space="preserve">
          <source>Insecure $ENV{%s} while running %s</source>
          <target state="translated">%s の実行中に $ENV{%s}が安全ではない。</target>
        </trans-unit>
        <trans-unit id="a5f2e8a9a0eb4ece5b87faf1da95aff5e83b5fa4" translate="yes" xml:space="preserve">
          <source>Insecure dependency in %s</source>
          <target state="translated">s での安全でない依存関係</target>
        </trans-unit>
        <trans-unit id="931ce1c7f1f13e481922a26677a26bb4773219c6" translate="yes" xml:space="preserve">
          <source>Insecure directory in %s</source>
          <target state="translated">安全でないディレクトリが %s にあります。</target>
        </trans-unit>
        <trans-unit id="8eb11eae387cd5cce06293624d01344e1072d48a" translate="yes" xml:space="preserve">
          <source>Insecure user-defined property %s</source>
          <target state="translated">安全でないユーザ定義プロパティ %s</target>
        </trans-unit>
        <trans-unit id="09ede375a150e967e64e7e2d887a232d51f368fa" translate="yes" xml:space="preserve">
          <source>Insert LIST elements at the beginning of the array, moving existing elements up to make room.</source>
          <target state="translated">配列の先頭にLIST要素を挿入し、既存の要素を上に移動してスペースを確保します。</target>
        </trans-unit>
        <trans-unit id="8b5af2a8ac2266ac1fdb8694203bf8a7b5999fb5" translate="yes" xml:space="preserve">
          <source>Insert LIST elements at the beginning of the array, moving existing elements up to make room. For example:</source>
          <target state="translated">配列の先頭にLIST要素を挿入し、既存の要素を上に移動してスペースを確保します。例えば</target>
        </trans-unit>
        <trans-unit id="065f57756426a11d3de09e3d897a1322f51a5123" translate="yes" xml:space="preserve">
          <source>Insert characters into the lexer buffer (&lt;a href=&quot;#PL_parser-%3Elinestr&quot;&gt;&quot;PL_parser-&amp;gt;linestr&quot;&lt;/a&gt;), immediately after the current lexing point (&lt;a href=&quot;#PL_parser-%3Ebufptr&quot;&gt;&quot;PL_parser-&amp;gt;bufptr&quot;&lt;/a&gt;), reallocating the buffer if necessary. This means that lexing code that runs later will see the characters as if they had appeared in the input. It is not recommended to do this as part of normal parsing, and most uses of this facility run the risk of the inserted characters being interpreted in an unintended manner.</source>
          <target state="translated">現在の字句解析ポイント（&lt;a href=&quot;#PL_parser-%3Ebufptr&quot;&gt;&quot;PL_parser-&amp;gt; bufptr&quot;&lt;/a&gt;）の直後に文字を字句解析バッファー（&lt;a href=&quot;#PL_parser-%3Elinestr&quot;&gt;&quot;PL_parser-&amp;gt; linestr&quot;&lt;/a&gt;）に挿入し、必要に応じてバッファーを再割り当てします。これは、後で実行される字句解析コードが、入力に表示されたかのように文字を表示することを意味します。通常の解析の一部としてこれを行うことはお勧めしません。この機能のほとんどの使用法では、挿入された文字が意図しない方法で解釈されるリスクがあります。</target>
        </trans-unit>
        <trans-unit id="0c8d991df77bf00e29c21cb93175839fa481ea2b" translate="yes" xml:space="preserve">
          <source>Insert characters into the lexer buffer (&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt;linestr&lt;/a&gt;), immediately after the current lexing point (&lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt;bufptr&lt;/a&gt;), reallocating the buffer if necessary. This means that lexing code that runs later will see the characters as if they had appeared in the input. It is not recommended to do this as part of normal parsing, and most uses of this facility run the risk of the inserted characters being interpreted in an unintended manner.</source>
          <target state="translated">字句解析器バッファー（&lt;a href=&quot;#PL_parser-%3elinestr&quot;&gt;PL_parser-&amp;gt; linestr&lt;/a&gt;）の現在の字句解析ポイント（&lt;a href=&quot;#PL_parser-%3ebufptr&quot;&gt;PL_parser-&amp;gt; bufptr&lt;/a&gt;）の直後に文字を挿入し、必要に応じてバッファーを再割り当てします。つまり、後で実行される字句解析コードは、文字が入力に現れたように見えます。通常の解析の一部としてこれを行うことはお勧めできません。この機能を使用すると、挿入された文字が意図しない方法で解釈される危険があります。</target>
        </trans-unit>
        <trans-unit id="d46d273f43c1298f3a09e3049502d6b87af98707" translate="yes" xml:space="preserve">
          <source>Inserting POD, Comments and C Preprocessor Directives</source>
          <target state="translated">POD、コメント、Cプリプロセッサディレクティブの挿入</target>
        </trans-unit>
        <trans-unit id="3ddc278de0a82017be1546343c053adba747b534" translate="yes" xml:space="preserve">
          <source>Inserting records that</source>
          <target state="translated">以下のようなレコードを挿入します。</target>
        </trans-unit>
        <trans-unit id="762d7f10b7a5cbbfbd3a51bba1f8d6e37c660a81" translate="yes" xml:space="preserve">
          <source>Inserts a string at the specified offset/length within the SV. Similar to the Perl substr() function. Handles get magic.</source>
          <target state="translated">SV 内に指定されたオフセット/長さの文字列を挿入します。Perl の substr()関数に似ています。取得マジックを扱う。</target>
        </trans-unit>
        <trans-unit id="0ae14887402eb591db68a2439f3f3fdfb3b0176f" translate="yes" xml:space="preserve">
          <source>Inserts and/or replaces a string at the specified offset/length within the SV. Similar to the Perl &lt;code&gt;substr()&lt;/code&gt; function, with &lt;code&gt;littlelen&lt;/code&gt; bytes starting at &lt;code&gt;little&lt;/code&gt; replacing &lt;code&gt;len&lt;/code&gt; bytes of the string in &lt;code&gt;bigstr&lt;/code&gt; starting at &lt;code&gt;offset&lt;/code&gt;. Handles get magic.</source>
          <target state="translated">SV内の指定されたオフセット/長さで文字列を挿入および/または置換します。Perlのと同様 &lt;code&gt;substr()&lt;/code&gt; 関数で &lt;code&gt;littlelen&lt;/code&gt; 始まるバイト &lt;code&gt;little&lt;/code&gt; 交換 &lt;code&gt;len&lt;/code&gt; 内の文字列のバイト &lt;code&gt;bigstr&lt;/code&gt; 始まる &lt;code&gt;offset&lt;/code&gt; 。ハンドルは魔法をかけます。</target>
        </trans-unit>
        <trans-unit id="ac3e05759f66cf1dafff1c764cc8c3b6a42a2c61" translate="yes" xml:space="preserve">
          <source>Inserts the sharpbang or equivalent magic number to a set of @files.</source>
          <target state="translated">ファイルの集合にシャープバングまたは同等のマジックナンバーを挿入します。</target>
        </trans-unit>
        <trans-unit id="bfb7a36a7ca33fb28f326fe5eacde6cacf000521" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;(?{...})&lt;/code&gt; block, &lt;code&gt;$_&lt;/code&gt; refers to the string the regular expression is matching against. You can also use &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; to know what is the current position of matching within this string.</source>
          <target state="translated">内部 &lt;code&gt;(?{...})&lt;/code&gt; ブロック、 &lt;code&gt;$_&lt;/code&gt; 正規表現と照合される文字列を指します。また、 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; を使用して、この文字列内で一致する現在の位置を知ることもできます。</target>
        </trans-unit>
        <trans-unit id="9e74660978326d8205b1966918b272dc20370085" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;(?{...})&lt;/code&gt; block, &lt;code&gt;$_&lt;/code&gt; refers to the string the regular expression is matching against. You can also use &lt;code&gt;pos()&lt;/code&gt; to know what is the current position of matching within this string.</source>
          <target state="translated">内部 &lt;code&gt;(?{...})&lt;/code&gt; ブロック、 &lt;code&gt;$_&lt;/code&gt; 正規表現と照合される文字列を指します。 &lt;code&gt;pos()&lt;/code&gt; を使用して、この文字列内の一致の現在の位置を知ることもできます。</target>
        </trans-unit>
        <trans-unit id="a56e96c79858e86c827cc4e174ee077ce93a7306" translate="yes" xml:space="preserve">
          <source>Inside a Perl program, you can use the &lt;a href=&quot;ExtUtils::Installed&quot;&gt;ExtUtils::Installed&lt;/a&gt; module to show all installed distributions, although it can take awhile to do its magic. The standard library which comes with Perl just shows up as &quot;Perl&quot; (although you can get those with &lt;a href=&quot;Module::CoreList&quot;&gt;Module::CoreList&lt;/a&gt;).</source>
          <target state="translated">Perlプログラム内では、&lt;a href=&quot;ExtUtils::Installed&quot;&gt;ExtUtils :: Installed&lt;/a&gt;モジュールを使用して、インストールされているすべてのディストリビューションを表示できますが、その魔法を実行するには時間がかかる場合があります。Perlに付属している標準ライブラリは、「Perl」と表示されます（ただし、&lt;a href=&quot;Module::CoreList&quot;&gt;Module :: CoreList&lt;/a&gt;を使用して取得できます）。</target>
        </trans-unit>
        <trans-unit id="60f1ba3b99ef99e8ed328c9a98bf927d5f0a5518" translate="yes" xml:space="preserve">
          <source>Inside a Perl program, you can use the &lt;a href=&quot;extutils/installed&quot;&gt;ExtUtils::Installed&lt;/a&gt; module to show all installed distributions, although it can take awhile to do its magic. The standard library which comes with Perl just shows up as &quot;Perl&quot; (although you can get those with &lt;a href=&quot;module/corelist&quot;&gt;Module::CoreList&lt;/a&gt;).</source>
          <target state="translated">Perlプログラム内では、&lt;a href=&quot;extutils/installed&quot;&gt;ExtUtils :: Installed&lt;/a&gt;モジュールを使用して、インストールされているすべてのディストリビューションを表示できますが、その魔法を実行するのに時間がかかる場合があります。Perlに付属する標準ライブラリは、「Perl」として表示されます（ただし、&lt;a href=&quot;module/corelist&quot;&gt;Module :: CoreList&lt;/a&gt;を使用して取得できます）。</target>
        </trans-unit>
        <trans-unit id="2ac6e4915bcad5900cd6401a5966f997e137a0c9" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; code block, &lt;code&gt;$?&lt;/code&gt; contains the value that the program is going to pass to &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; to change the exit value of the program. Beware of changing &lt;code&gt;$?&lt;/code&gt; by accident (e.g. by running something via &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;END&lt;/code&gt; コードブロック内では、 &lt;code&gt;$?&lt;/code&gt; プログラムが &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; に渡す値が含まれています。 &lt;code&gt;$?&lt;/code&gt; を変更できますか？プログラムの終了値を変更します。 &lt;code&gt;$?&lt;/code&gt; の変更に注意してください。偶然（たとえば、 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; を介して何かを実行することによる）</target>
        </trans-unit>
        <trans-unit id="bf5fff32ec45447a013d87f1e68934fda177610e" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; code block, &lt;code&gt;$?&lt;/code&gt; contains the value that the program is going to pass to &lt;code&gt;exit()&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; to change the exit value of the program. Beware of changing &lt;code&gt;$?&lt;/code&gt; by accident (e.g. by running something via &lt;code&gt;system&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;END&lt;/code&gt; コードブロック内で、 &lt;code&gt;$?&lt;/code&gt; プログラムが &lt;code&gt;exit()&lt;/code&gt; に渡す値が含まれています。 &lt;code&gt;$?&lt;/code&gt; を変更できますか？プログラムの終了値を変更します。 &lt;code&gt;$?&lt;/code&gt; の変更に注意しますか？偶然（例えば、 &lt;code&gt;system&lt;/code&gt; を介して何かを実行することによって）。</target>
        </trans-unit>
        <trans-unit id="2a3aa49ae51d12807c062f5debba3be515ca72cb" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; subroutine &lt;code&gt;$?&lt;/code&gt; contains the value that is going to be given to &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; in an &lt;code&gt;END&lt;/code&gt; subroutine to change the exit status of your program. For example:</source>
          <target state="translated">インサイド &lt;code&gt;END&lt;/code&gt; のサブルーチン &lt;code&gt;$?&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; に渡される値が含まれています。 &lt;code&gt;$?&lt;/code&gt; を変更できますか？中 &lt;code&gt;END&lt;/code&gt; のサブルーチンプログラムの終了ステータスを変更します。例えば：</target>
        </trans-unit>
        <trans-unit id="ad96dc469c005e6c9269282065dbe2d978332531" translate="yes" xml:space="preserve">
          <source>Inside an &lt;code&gt;END&lt;/code&gt; subroutine &lt;code&gt;$?&lt;/code&gt; contains the value that is going to be given to &lt;code&gt;exit()&lt;/code&gt;. You can modify &lt;code&gt;$?&lt;/code&gt; in an &lt;code&gt;END&lt;/code&gt; subroutine to change the exit status of your program. For example:</source>
          <target state="translated">&lt;code&gt;END&lt;/code&gt; サブルーチン内 &lt;code&gt;$?&lt;/code&gt; &lt;code&gt;exit()&lt;/code&gt; に与えられる値が含まれています。 &lt;code&gt;$?&lt;/code&gt; を変更できますか？中 &lt;code&gt;END&lt;/code&gt; のサブルーチンプログラムの終了ステータスを変更します。例えば：</target>
        </trans-unit>
        <trans-unit id="6a3aafbb284a68739c4fb1ae1f60eb5141dcdda7" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;CHECK&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;CHECK&quot;&lt;/code&gt; .</source>
          <target state="translated">内部 &lt;code&gt;CHECK&lt;/code&gt; ブロック、の値 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; となります &lt;code&gt;&quot;CHECK&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67ca3322bfb1e33afbca0ac9de2636f604c7b47b" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;CHECK&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;CHECK&quot;&lt;/code&gt;.</source>
          <target state="translated">内部 &lt;code&gt;CHECK&lt;/code&gt; ブロック、の値 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; となります &lt;code&gt;&quot;CHECK&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77fd9286042f60d2513d71db2f202e6d15711855" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;END&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;END&quot;&lt;/code&gt; .</source>
          <target state="translated">内部 &lt;code&gt;END&lt;/code&gt; ブロックの値 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; となります &lt;code&gt;&quot;END&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40747b8f72c39fcb02dd5eb53c21ee80332129f2" translate="yes" xml:space="preserve">
          <source>Inside of a &lt;code&gt;END&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;END&quot;&lt;/code&gt;.</source>
          <target state="translated">内部 &lt;code&gt;END&lt;/code&gt; ブロックの値 &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; となります &lt;code&gt;&quot;END&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a193b063515ab15da965bd3478de34c4b7d0830" translate="yes" xml:space="preserve">
          <source>Inside of an &lt;code&gt;INIT&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;INIT&quot;&lt;/code&gt; .</source>
          <target state="translated">内部 &lt;code&gt;INIT&lt;/code&gt; のブロック、の値は &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; となります &lt;code&gt;&quot;INIT&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dee2a938cbad68208b1a78048519d4dcb40a2614" translate="yes" xml:space="preserve">
          <source>Inside of an &lt;code&gt;INIT&lt;/code&gt; block, the value of &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; will be &lt;code&gt;&quot;INIT&quot;&lt;/code&gt;.</source>
          <target state="translated">内部 &lt;code&gt;INIT&lt;/code&gt; のブロック、の値は &lt;code&gt;${^GLOBAL_PHASE}&lt;/code&gt; となります &lt;code&gt;&quot;INIT&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b24121a7266e78f12986b250ed98974d9cfcc24b" translate="yes" xml:space="preserve">
          <source>Inside such a</source>
          <target state="translated">そのような中で</target>
        </trans-unit>
        <trans-unit id="f7a01b93c52f9dee6e4b496cdb9ca5fafa7aa5b5" translate="yes" xml:space="preserve">
          <source>Inside the Perl core (&lt;code&gt;PERL_CORE&lt;/code&gt; defined), you can get at the functions either with or without the &lt;code&gt;Perl_&lt;/code&gt; prefix, thanks to a bunch of defines that live in</source>
          <target state="translated">Perlコア（ &lt;code&gt;PERL_CORE&lt;/code&gt; が定義されている）の内部では、 &lt;code&gt;Perl_&lt;/code&gt; プレフィックスの有無にかかわらず、多数の定義が存在するおかげで関数を取得できます。</target>
        </trans-unit>
        <trans-unit id="0daafc0685af0d01e22cebc44846559b24d94dc9" translate="yes" xml:space="preserve">
          <source>Inside your block, you can use a &lt;code&gt;;&lt;/code&gt; before the ellipsis to denote that the &lt;code&gt;{ ... }&lt;/code&gt; is a block and not a hash reference constructor. Now the ellipsis works:</source>
          <target state="translated">ブロック内では、 &lt;code&gt;;&lt;/code&gt; を使用できます。 &lt;code&gt;{ ... }&lt;/code&gt; がブロックであり、ハッシュ参照コンストラクタではないことを示す省略記号の前。これで省略記号が機能します。</target>
        </trans-unit>
        <trans-unit id="c37269c429f2ad22959db0e60ac4d8827e7e42ce" translate="yes" xml:space="preserve">
          <source>Inside-Out objects</source>
          <target state="translated">インサイドアウトオブジェクト</target>
        </trans-unit>
        <trans-unit id="7a4af927ec1e221d9c738e75cdfca5e119205956" translate="yes" xml:space="preserve">
          <source>Inside-out classes give us freedom of inheritance, but as usual there is a price.</source>
          <target state="translated">インサイドアウトクラスは相続の自由を与えてくれますが、いつものように代償があります。</target>
        </trans-unit>
        <trans-unit id="ec3c84ba848d8b0d780dabe6d5db65999ccfe2b2" translate="yes" xml:space="preserve">
          <source>Inside-out implementation based on the &lt;code&gt;id()&lt;/code&gt; function with explicit object registry. No destructor is needed and objects are thread safe.</source>
          <target state="translated">明示的なオブジェクトレジストリを使用した &lt;code&gt;id()&lt;/code&gt; 関数に基づくインサイドアウト実装。デストラクタは必要なく、オブジェクトはスレッドセーフです。</target>
        </trans-unit>
        <trans-unit id="093639ed82951fb2c05d82fa61065038c4a3f59b" translate="yes" xml:space="preserve">
          <source>Inside-out implementation based on the &lt;code&gt;id()&lt;/code&gt; function. It needs a &lt;code&gt;DESTROY&lt;/code&gt; method. For thread support a &lt;code&gt;CLONE&lt;/code&gt; method (not shown) would also be needed. Instead of &lt;code&gt;Hash::Util::FieldHash::id()&lt;/code&gt; the function &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; could be used with very little functional difference. This is the basic pattern of an inside-out class.</source>
          <target state="translated">&lt;code&gt;id()&lt;/code&gt; 関数に基づくインサイドアウト実装。 &lt;code&gt;DESTROY&lt;/code&gt; メソッドが必要です。スレッドをサポートするには、 &lt;code&gt;CLONE&lt;/code&gt; メソッド（図には示されていません）も必要です。 &lt;code&gt;Hash::Util::FieldHash::id()&lt;/code&gt; の代わりに、関数 &lt;code&gt;Scalar::Util::refaddr&lt;/code&gt; を使用しても、機能上の違いはほとんどありません。これは、裏返しのクラスの基本的なパターンです。</target>
        </trans-unit>
        <trans-unit id="1c8b1c8f4d7d36ee82d3ac919c5d208501a0c13b" translate="yes" xml:space="preserve">
          <source>Insisting on hints</source>
          <target state="translated">ヒントにこだわる</target>
        </trans-unit>
        <trans-unit id="516f54aa115effcfaabedad668e70675fab3e3bf" translate="yes" xml:space="preserve">
          <source>Insisting on hints is</source>
          <target state="translated">ヒントにこだわるのは</target>
        </trans-unit>
        <trans-unit id="26f7dff6871418123fc5bf54019b9bfae13765ed" translate="yes" xml:space="preserve">
          <source>Inspecting &lt;code&gt;$UTF8{Euro}&lt;/code&gt; shows that it contains 3 bytes: &quot;\xe2\x82\xac&quot;. However, it contains only 1 character, number 0x20AC. The round trip can be completed with &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;$UTF8{Euro}&lt;/code&gt; を検査すると、&quot;\ xe2 \ x82 \ xac&quot;の3バイトが含まれていることがわかります。ただし、0x20ACの1文字しか含まれていません。往復は &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; で完了できます。</target>
        </trans-unit>
        <trans-unit id="2b88041bde7425827d8e1b77e408079f51dbc6c2" translate="yes" xml:space="preserve">
          <source>Inspecting &lt;code&gt;$UTF8{Euro}&lt;/code&gt; shows that it contains 3 bytes: &quot;\xe2\x82\xac&quot;. However, it contains only 1 character, number 0x20AC. The round trip can be completed with &lt;code&gt;unpack&lt;/code&gt;:</source>
          <target state="translated">検査 &lt;code&gt;$UTF8{Euro}&lt;/code&gt; 、それは3バイトが含まれていることを示した： &quot;\ XE2 \ X82 \ XAC&quot;。ただし、含まれているのは1文字、数字0x20ACのみです。往復は &lt;code&gt;unpack&lt;/code&gt; で完了することができます：</target>
        </trans-unit>
        <trans-unit id="59207d175da65683910680d9c040a0c388fa1f23" translate="yes" xml:space="preserve">
          <source>Install Visual C++ 2005 first, then the Platform SDK. Setup your environment as follows (assuming default installation locations were chosen):</source>
          <target state="translated">最初にVisual C++2005をインストールし、次にPlatform SDKをインストールします。以下のように環境を設定します(デフォルトのインストール場所を選択したと仮定して)。</target>
        </trans-unit>
        <trans-unit id="33cbab1690c07ca74d0ff29dfe5b56b37a842899" translate="yes" xml:space="preserve">
          <source>Install Visual C++ 2008-2013 Express, then setup your environment using, e.g.</source>
          <target state="translated">Visual C++2008-2013 Express をインストールしてから、例えば、以下のようにして環境を設定します。</target>
        </trans-unit>
        <trans-unit id="64c681793c05d20d47748a1c4848dd27ecc92478" translate="yes" xml:space="preserve">
          <source>Install Visual C++ 2008-2019 Express/Community, then setup your environment using, e.g.</source>
          <target state="translated">Visual C++2008-2019 Express/Community をインストールしてから、例えば、以下のようにして環境を設定します。</target>
        </trans-unit>
        <trans-unit id="2f196edb7ca2b342cfc8b1c8d1c16c051256d43c" translate="yes" xml:space="preserve">
          <source>Install a callback for a named event.</source>
          <target state="translated">名前付きイベントのコールバックをインストールします。</target>
        </trans-unit>
        <trans-unit id="098146decab9cf9682dd20a4b2bc8c4001fb20aa" translate="yes" xml:space="preserve">
          <source>Install a signal mask and suspend process until signal arrives. This uses &lt;code&gt;POSIX::SigSet&lt;/code&gt; objects for the &lt;code&gt;signal_mask&lt;/code&gt; argument. Consult your system's &lt;code&gt;sigsuspend&lt;/code&gt; manpage for details.</source>
          <target state="translated">シグナルマスクをインストールし、シグナルが到着するまでプロセスを一時停止します。これは、使用しています &lt;code&gt;POSIX::SigSet&lt;/code&gt; ためにオブジェクト &lt;code&gt;signal_mask&lt;/code&gt; の引数。詳細については、システムの &lt;code&gt;sigsuspend&lt;/code&gt; マンページを参照してください。</target>
        </trans-unit>
        <trans-unit id="5064d1cdb752ce928134eb0a4e8326765bed0d5e" translate="yes" xml:space="preserve">
          <source>Install all distributions that have been tested successfully but have not yet been installed. See also &lt;code&gt;is_tested&lt;/code&gt; .</source>
          <target state="translated">正常にテストされたがまだインストールされていないすべてのディストリビューションをインストールします。 &lt;code&gt;is_tested&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="30bb41e456f55898b9a816d97d83d13570e789d0" translate="yes" xml:space="preserve">
          <source>Install files from here to there</source>
          <target state="translated">ここからあちこちにファイルをインストールする</target>
        </trans-unit>
        <trans-unit id="be838642bc4439dddc0a654f23d9ebf8387685d2" translate="yes" xml:space="preserve">
          <source>Install my_handler() as the handler for the &lt;b&gt;normal-signals&lt;/b&gt;:</source>
          <target state="translated">&lt;b&gt;通常のシグナルの&lt;/b&gt;ハンドラーとしてmy_handler（）をインストールします。</target>
        </trans-unit>
        <trans-unit id="f8eeec02705f1ef8eb9bf0619d6a4de1e15c32de" translate="yes" xml:space="preserve">
          <source>Install my_handler() as the handler for the normal-signals, provide a Perl stack trace on receipt of one of the error-signals:</source>
          <target state="translated">通常のシグナルのハンドラとして my_handler()をインストールし、エラーシグナルを受信した際に Perl のスタックトレースを提供します。</target>
        </trans-unit>
        <trans-unit id="e64dce2583dfe013eb849f3d2d103a519b4f693d" translate="yes" xml:space="preserve">
          <source>Install the Toolkit first, then the Platform SDK, then the .NET Framework SDK. Setup your environment as follows (assuming default installation locations were chosen):</source>
          <target state="translated">最初にツールキットをインストールし、次にプラットフォームSDKをインストールし、次に.NET Framework SDKをインストールします。以下のように環境を設定します(デフォルトのインストール場所を選択したと仮定して)。</target>
        </trans-unit>
        <trans-unit id="cd990d98fdc32595b067d42fc715d5ce94d57be2" translate="yes" xml:space="preserve">
          <source>Install the bundle &lt;code&gt;Bundle::OS2_default&lt;/code&gt;</source>
          <target state="translated">バンドル &lt;code&gt;Bundle::OS2_default&lt;/code&gt; をインストールします</target>
        </trans-unit>
        <trans-unit id="b20b73b1de67223c2bd9207fae1a1e9b72c2233d" translate="yes" xml:space="preserve">
          <source>Install the bundle file you produced in the first step with something like</source>
          <target state="translated">最初のステップで作成したバンドルファイルを以下のようなものでインストールします。</target>
        </trans-unit>
        <trans-unit id="b2a00c681671c3322d47892ed0695f73370a27ed" translate="yes" xml:space="preserve">
          <source>Install the specified modules. With no other switches, this switch is implied.</source>
          <target state="translated">指定されたモジュールをインストールします。他のスイッチがない状態では、このスイッチが暗黙の了解となります。</target>
        </trans-unit>
        <trans-unit id="a972b5a9d813b2528044bfdb606fb493e85bedb6" translate="yes" xml:space="preserve">
          <source>Install will copy the files into the Windows machine where NetWare Perl is installed and these files may have to be copied to the NetWare server manually. Alternatively, pass</source>
          <target state="translated">Install は、NetWare Perl がインストールされている Windows マシンにファイルをコピーします。別の方法としては</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="5170591ca8711f15e1b20c47f412774e19b0fe70" translate="yes" xml:space="preserve">
          <source>Installation Anomalies with Perl on OS/390</source>
          <target state="translated">OS/390でのPerlのインストールの異常</target>
        </trans-unit>
        <trans-unit id="8744a89757a103643f2c85c220b914d085ffdf88" translate="yes" xml:space="preserve">
          <source>Installation Prefix</source>
          <target state="translated">インストールプレフィックス</target>
        </trans-unit>
        <trans-unit id="a45aaea883d55053b401f0d2cdd7b7f6799182e8" translate="yes" xml:space="preserve">
          <source>Installation of &lt;code&gt;Unicode::Collate::Locale&lt;/code&gt; requires</source>
          <target state="translated">&lt;code&gt;Unicode::Collate::Locale&lt;/code&gt; インストールには</target>
        </trans-unit>
        <trans-unit id="180cc178e07c1743ecf9dbe37bab2bf2dabe5bb5" translate="yes" xml:space="preserve">
          <source>Installation of Perl on DOS</source>
          <target state="translated">DOSでのPerlのインストール</target>
        </trans-unit>
        <trans-unit id="cfb2e768feadc8837cc7fc759954e96ac60a95b5" translate="yes" xml:space="preserve">
          <source>Installation of Perl on Windows</source>
          <target state="translated">WindowsへのPerlのインストール</target>
        </trans-unit>
        <trans-unit id="4ca02b48dd8aa7c8862ef964b8ef23527a77760c" translate="yes" xml:space="preserve">
          <source>Installing Perl Documentation on Plan 9</source>
          <target state="translated">Plan 9 への Perl ドキュメントのインストール</target>
        </trans-unit>
        <trans-unit id="2ae981a52ea5c2d2aafd4355287d2406dc0ef314" translate="yes" xml:space="preserve">
          <source>Installing Perl in OS/400 PASE</source>
          <target state="translated">OS/400のPASEにPerlをインストールする</target>
        </trans-unit>
        <trans-unit id="b61a365b42d75d8e047fa9fe92ff65b4f60e9701" translate="yes" xml:space="preserve">
          <source>Installing Perl on BS2000</source>
          <target state="translated">BS2000へのPerlのインストール</target>
        </trans-unit>
        <trans-unit id="0417ed1ca822a227853883f689e9fa61b7253133" translate="yes" xml:space="preserve">
          <source>Installing dynamic extensions</source>
          <target state="translated">動的拡張機能のインストール</target>
        </trans-unit>
        <trans-unit id="d551e6ba21a76c8b829c9fd66b0f82cb57a2e6c1" translate="yes" xml:space="preserve">
          <source>Installing handlers into UNIVERSAL, makes them...err..universal. For example:</source>
          <target state="translated">ハンドラをUNIVERSALにインストールすると、ユニバーサルになります。例えば</target>
        </trans-unit>
        <trans-unit id="0cfc88ee57d518bf7af556a12ced2b10a8287ca8" translate="yes" xml:space="preserve">
          <source>Installing static extensions</source>
          <target state="translated">静的拡張機能のインストール</target>
        </trans-unit>
        <trans-unit id="257dd2466c69ad9b24149fb3bc3f1813543ba72a" translate="yes" xml:space="preserve">
          <source>Installing the built Perl on AmigaOS</source>
          <target state="translated">ビルドされたPerlをAmigaOSにインストールする</target>
        </trans-unit>
        <trans-unit id="db29ef231e31119424ca9f0f93b9223b833e4152" translate="yes" xml:space="preserve">
          <source>Installing the built perl</source>
          <target state="translated">ビルドされたPerlをインストールする</target>
        </trans-unit>
        <trans-unit id="d904df04db30e9f6033f6ecb3f32eb4c2b0e5b70" translate="yes" xml:space="preserve">
          <source>Installing your Extension</source>
          <target state="translated">拡張機能のインストール</target>
        </trans-unit>
        <trans-unit id="0f18cd63862f3975ca1e7ab7bda9fc335b20e2f1" translate="yes" xml:space="preserve">
          <source>Installs a source filter that substitutes &quot;e&quot; for &quot;o&quot; (witheut regard fer what it might be medifying).</source>
          <target state="translated">e」を「o」に置き換えるソースフィルタをインストールします。</target>
        </trans-unit>
        <trans-unit id="dd4a61ab3dc44ab9b5a205303724a68f74a735a7" translate="yes" xml:space="preserve">
          <source>Instance Methods</source>
          <target state="translated">インスタンスメソッド</target>
        </trans-unit>
        <trans-unit id="8d64e2312c9072080b4302e3445829998f7c6a99" translate="yes" xml:space="preserve">
          <source>Instance method.</source>
          <target state="translated">インスタンスメソッドです。</target>
        </trans-unit>
        <trans-unit id="e18280b32ffbeebedfcc0fc6dbe9b749315b6ea6" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;$a[1]-&amp;gt;[2]&lt;/code&gt; , we can write &lt;code&gt;$a[1][2]&lt;/code&gt; ; it means the same thing. Instead of &lt;code&gt;$a[0]-&amp;gt;[1] = 23&lt;/code&gt; , we can write &lt;code&gt;$a[0][1] = 23&lt;/code&gt; ; it means the same thing.</source>
          <target state="translated">代わりの &lt;code&gt;$a[1]-&amp;gt;[2]&lt;/code&gt; 、我々は書くことができる &lt;code&gt;$a[1][2]&lt;/code&gt; 。同じことを意味します。代わりに &lt;code&gt;$a[0]-&amp;gt;[1] = 23&lt;/code&gt; 、我々は書くことができる &lt;code&gt;$a[0][1] = 23&lt;/code&gt; ; 同じことを意味します。</target>
        </trans-unit>
        <trans-unit id="593a1adb7d7043c40428f2f6f11f755e1eb8603d" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;$a[1]-&amp;gt;[2]&lt;/code&gt;, we can write &lt;code&gt;$a[1][2]&lt;/code&gt;; it means the same thing. Instead of &lt;code&gt;$a[0]-&amp;gt;[1] = 23&lt;/code&gt;, we can write &lt;code&gt;$a[0][1] = 23&lt;/code&gt;; it means the same thing.</source>
          <target state="translated">代わりの &lt;code&gt;$a[1]-&amp;gt;[2]&lt;/code&gt; 、我々は書くことができる &lt;code&gt;$a[1][2]&lt;/code&gt; 。それは同じことを意味します。 &lt;code&gt;$a[0]-&amp;gt;[1] = 23&lt;/code&gt; 代わりに、$ a [ &lt;code&gt;$a[0][1] = 23&lt;/code&gt; ;と書くことができます。それは同じことを意味します。</target>
        </trans-unit>
        <trans-unit id="ba491ba1ec8ef4be8f85786b6a781edf6fccddb7" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; , you can simply use &lt;code&gt;:utf8&lt;/code&gt; , which skips the encoding step if the data was already represented as UTF8 internally. This is widely accepted as good behavior when you're writing, but it can be dangerous when reading, because it causes internal inconsistency when you have invalid byte sequences. Using &lt;code&gt;:utf8&lt;/code&gt; for input can sometimes result in security breaches, so please use &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;:encoding(UTF-8)&lt;/code&gt; の代わりに、単純に &lt;code&gt;:utf8&lt;/code&gt; を使用できます。これにより、データがすでに内部でUTF8として表現されている場合は、エンコード手順がスキップされます。これは、書き込み時には適切な動作として広く受け入れられていますが、無効なバイトシーケンスがあると内部の不整合が発生するため、読み取り時に危険な場合があります。入力に &lt;code&gt;:utf8&lt;/code&gt; を使用すると、セキュリティ違反が発生する場合があるため、代わりに &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="7bfad6bde5b470a60206db3866234b6dfd103110" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;:encoding(UTF-8)&lt;/code&gt;, you can simply use &lt;code&gt;:utf8&lt;/code&gt;, which skips the encoding step if the data was already represented as UTF8 internally. This is widely accepted as good behavior when you're writing, but it can be dangerous when reading, because it causes internal inconsistency when you have invalid byte sequences. Using &lt;code&gt;:utf8&lt;/code&gt; for input can sometimes result in security breaches, so please use &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;:encoding(UTF-8)&lt;/code&gt; の代わりに、単に &lt;code&gt;:utf8&lt;/code&gt; を使用できます。これは、データがすでに内部でUTF8として表されている場合、エンコード手順をスキップします。これは、書き込み中の良好な動作として広く受け入れられていますが、無効なバイトシーケンスがあると内部の不整合が発生するため、読み取り時には危険な場合があります。入力に &lt;code&gt;:utf8&lt;/code&gt; を使用すると、セキュリティ違反が発生する可能性があるため、代わりに &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="77ad0b5725694a222d6ac24da3bbb122aa3a958a" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;decode&lt;/code&gt; and &lt;code&gt;encode&lt;/code&gt; , you could use &lt;code&gt;_utf8_on&lt;/code&gt; and &lt;code&gt;_utf8_off&lt;/code&gt; , but this is considered bad style. Especially &lt;code&gt;_utf8_on&lt;/code&gt; can be dangerous, for the same reason that &lt;code&gt;:utf8&lt;/code&gt; can.</source>
          <target state="translated">&lt;code&gt;decode&lt;/code&gt; して &lt;code&gt;encode&lt;/code&gt; 代わりに、 &lt;code&gt;_utf8_on&lt;/code&gt; および &lt;code&gt;_utf8_off&lt;/code&gt; を使用することもできますが、これは悪いスタイルと見なされます。特に &lt;code&gt;_utf8_on&lt;/code&gt; は、同じ理由で、危険なことが &lt;code&gt;:utf8&lt;/code&gt; することができます。</target>
        </trans-unit>
        <trans-unit id="bdb3493ce203f52a331d6d2854f96ffed217a38c" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;decode&lt;/code&gt; and &lt;code&gt;encode&lt;/code&gt;, you could use &lt;code&gt;_utf8_on&lt;/code&gt; and &lt;code&gt;_utf8_off&lt;/code&gt;, but this is considered bad style. Especially &lt;code&gt;_utf8_on&lt;/code&gt; can be dangerous, for the same reason that &lt;code&gt;:utf8&lt;/code&gt; can.</source>
          <target state="translated">&lt;code&gt;decode&lt;/code&gt; と &lt;code&gt;encode&lt;/code&gt; 代わりに、 &lt;code&gt;_utf8_on&lt;/code&gt; と &lt;code&gt;_utf8_off&lt;/code&gt; を使用できますが、これは悪いスタイルと見なされます。特に &lt;code&gt;_utf8_on&lt;/code&gt; は、 &lt;code&gt;:utf8&lt;/code&gt; と同じ理由で、危険な場合があります。</target>
        </trans-unit>
        <trans-unit id="1f30761f7bbd31f759ef384a9ad19f6187329e7a" translate="yes" xml:space="preserve">
          <source>Instead of a filename, you can also pass it an existing &lt;code&gt;Archive::Tar::File&lt;/code&gt; object from, for example, another archive. The object will be clone, and effectively be a copy of the original, not an alias.</source>
          <target state="translated">ファイル名の代わりに、たとえば別のアーカイブから既存の &lt;code&gt;Archive::Tar::File&lt;/code&gt; オブジェクトを渡すこともできます。オブジェクトは複製され、事実上、エイリアスではなく元のコピーになります。</target>
        </trans-unit>
        <trans-unit id="124160cac15a4b540f3a3a995eeb45e15636d682" translate="yes" xml:space="preserve">
          <source>Instead of a filename, you may specify an external command (plus an optional argument list) or a scalar reference, in order to open filehandles on commands or in-memory scalars, respectively.</source>
          <target state="translated">ファイル名の代わりに、外部コマンド (およびオプションの引数リスト)やスカラ参照を指定して、それぞれコマンドやメモリ内スカラのファイルハンドルを開くことができます。</target>
        </trans-unit>
        <trans-unit id="3d7794c8d2e8209f9cf8a080564bc83932d1de0d" translate="yes" xml:space="preserve">
          <source>Instead of a number, you can use &lt;code&gt;*&lt;/code&gt; to mean &quot;consume everything else left&quot;.</source>
          <target state="translated">数字の代わりに、 &lt;code&gt;*&lt;/code&gt; を使用して「残りすべてを消費する」ことを意味できます。</target>
        </trans-unit>
        <trans-unit id="2d5ef8b3223bf8e72260629cb76365a1c7d119c3" translate="yes" xml:space="preserve">
          <source>Instead of an actual C function that has to fetch the thread context using &lt;code&gt;dTHX&lt;/code&gt; , you can define macros of the same name and avoid the overhead. Also, keep in mind to possibly free the memory allocated by &lt;code&gt;XS_unpack_foo_tPtr&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;dTHX&lt;/code&gt; を使用してスレッドコンテキストをフェッチする必要がある実際のC関数の代わりに、同じ名前のマクロを定義してオーバーヘッドを回避できます。また、 &lt;code&gt;XS_unpack_foo_tPtr&lt;/code&gt; によって割り当てられたメモリを解放する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a07eba34499fa5596b47d75d14fe92d0d0178dc4" translate="yes" xml:space="preserve">
          <source>Instead of an actual C function that has to fetch the thread context using &lt;code&gt;dTHX&lt;/code&gt;, you can define macros of the same name and avoid the overhead. Also, keep in mind to possibly free the memory allocated by &lt;code&gt;XS_unpack_foo_tPtr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dTHX&lt;/code&gt; を使用してスレッドコンテキストをフェッチする必要がある実際のC関数の代わりに、同じ名前のマクロを定義して、オーバーヘッドを回避できます。また、 &lt;code&gt;XS_unpack_foo_tPtr&lt;/code&gt; によって割り当てられたメモリを解放する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="efec145a63aada8917ea862470d1c559b417d5a8" translate="yes" xml:space="preserve">
          <source>Instead of it, do like this:</source>
          <target state="translated">その代わりに、こんな感じで。</target>
        </trans-unit>
        <trans-unit id="18bf50916f725e20e492e415ffe30f1d8deec329" translate="yes" xml:space="preserve">
          <source>Instead of loading feature bundles by name, it is easier to let Perl do implicit loading of a feature bundle for you.</source>
          <target state="translated">機能バンドルを名前でロードするのではなく、機能バンドルの暗黙のロードをPerlに任せる方が簡単です。</target>
        </trans-unit>
        <trans-unit id="19636d7e449d8e4352801adbe196c0e695eced0d" translate="yes" xml:space="preserve">
          <source>Instead of reading the Unicode Database directly from files, as you were able to do for a long time, you are encouraged to use the supplied functions. So, instead of reading &lt;code&gt;Name.pl&lt;/code&gt; directly, which changed formats in 5.32, and may do so again without notice in the future or even disappear, you ought to use &lt;a href=&quot;#prop_invmap%28%29&quot;&gt;&quot;prop_invmap()&quot;&lt;/a&gt; like this:</source>
          <target state="translated">長い間実行できたように、ファイルから直接Unicodeデータベースを読み取る代わりに、提供されている関数を使用することをお勧めします。したがって、5.32でフォーマットを変更した &lt;code&gt;Name.pl&lt;/code&gt; を直接読み取る代わりに、将来通知なしに再度読み取るか、さらには消える可能性がある場合は、次のように&lt;a href=&quot;#prop_invmap%28%29&quot;&gt;「prop_invmap（）」&lt;/a&gt;を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="4549985addea58856a2589a95661e1f3d1246c4e" translate="yes" xml:space="preserve">
          <source>Instead of setting &lt;code&gt;$SIG{ALRM}&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;$SIG{ALRM}&lt;/code&gt; を設定する代わりに：</target>
        </trans-unit>
        <trans-unit id="109c505d57edc356474583bd538981b34aae6661" translate="yes" xml:space="preserve">
          <source>Instead of setting &lt;code&gt;$SIG{ALRM}&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;$SIG{ALRM}&lt;/code&gt; を設定する代わりに：</target>
        </trans-unit>
        <trans-unit id="a4cf4072b6ecd93f69baec56cef0a223f95f5666" translate="yes" xml:space="preserve">
          <source>Instead of specifying the VERSION in the Makefile.PL you can let MakeMaker parse a file to determine the version number. The parsing routine requires that the file named by VERSION_FROM contains one single line to compute the version number. The first line in the file that contains something like a $VERSION assignment or &lt;code&gt;package Name
VERSION&lt;/code&gt; will be used. The following lines will be parsed o.k.:</source>
          <target state="translated">Makefile.PLでVERSIONを指定する代わりに、MakeMakerにファイルを解析させてバージョン番号を決定させることができます。解析ルーチンでは、VERSION_FROMで指定されたファイルに、バージョン番号を計算するための1行が含まれている必要があります。$ VERSION割り当てや &lt;code&gt;package Name VERSION&lt;/code&gt; などを含むファイルの最初の行が使用されます。次の行は問題なく解析されます：</target>
        </trans-unit>
        <trans-unit id="c9d067c5eb0ad6111602fcfc2b4a14a7fd5906ed" translate="yes" xml:space="preserve">
          <source>Instead of the</source>
          <target state="translated">の代わりに</target>
        </trans-unit>
        <trans-unit id="52ef12851a02520ecdc1bb50b94ab80ca32cf34d" translate="yes" xml:space="preserve">
          <source>Instead of the above process, with Filter::Simple the task of setting up a source code filter is reduced to:</source>
          <target state="translated">上記の処理の代わりに Filter::Simple を使うと、ソースコードフィルタを設定する作業が軽減されます。</target>
        </trans-unit>
        <trans-unit id="08d78413d66ea6fc10e343adae82dd66dad36d77" translate="yes" xml:space="preserve">
          <source>Instead of the shell's &lt;code&gt;expand&lt;/code&gt; command, use:</source>
          <target state="translated">シェルの &lt;code&gt;expand&lt;/code&gt; コマンドの代わりに、次を使用します。</target>
        </trans-unit>
        <trans-unit id="c97f35f08c784710202f7afd89947e84d996ff4b" translate="yes" xml:space="preserve">
          <source>Instead of the shell's &lt;code&gt;unexpand -a&lt;/code&gt; command, use:</source>
          <target state="translated">シェルの &lt;code&gt;unexpand -a&lt;/code&gt; コマンドの代わりに、次を使用します。</target>
        </trans-unit>
        <trans-unit id="6ba67eec9e92df05acdf46af85244d2e3cb47ac2" translate="yes" xml:space="preserve">
          <source>Instead of this:</source>
          <target state="translated">これの代わりに</target>
        </trans-unit>
        <trans-unit id="f550302de10f6528309a1269c83c4106b886739f" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;$*&lt;/code&gt; you should use the &lt;code&gt;/m&lt;/code&gt; (and maybe &lt;code&gt;/s&lt;/code&gt;) regexp modifiers. You can enable &lt;code&gt;/m&lt;/code&gt; for a lexical scope (even a whole file) with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/m'&lt;/code&gt; . (In older versions: when &lt;code&gt;$*&lt;/code&gt; was set to a true value then all regular expressions behaved as if they were written using &lt;code&gt;/m&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;$*&lt;/code&gt; を使用する代わりに、 &lt;code&gt;/m&lt;/code&gt; （およびおそらく &lt;code&gt;/s&lt;/code&gt; ）正規表現修飾子を使用する必要があります。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/m'&lt;/code&gt; を&lt;a href=&quot;functions/use&quot;&gt;使用する&lt;/a&gt;と、レキシカルスコープ（ファイル全体でも &lt;code&gt;/m&lt;/code&gt; に対して/ mを有効にできます。（以前のバージョン： &lt;code&gt;$*&lt;/code&gt; がtrue値に設定されている場合、すべての正規表現は &lt;code&gt;/m&lt;/code&gt; を使用して記述されているかのように動作しました。）</target>
        </trans-unit>
        <trans-unit id="d1566aff196e46eef40b411b3e40f33b2eca1868" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;$*&lt;/code&gt; you should use the &lt;code&gt;/m&lt;/code&gt; (and maybe &lt;code&gt;/s&lt;/code&gt;) regexp modifiers. You can enable &lt;code&gt;/m&lt;/code&gt; for a lexical scope (even a whole file) with &lt;code&gt;use re '/m'&lt;/code&gt;. (In older versions: when &lt;code&gt;$*&lt;/code&gt; was set to a true value then all regular expressions behaved as if they were written using &lt;code&gt;/m&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;$*&lt;/code&gt; を使用する代わりに、 &lt;code&gt;/m&lt;/code&gt; （およびおそらく &lt;code&gt;/s&lt;/code&gt; ）の正規表現修飾子を使用する必要があります。 &lt;code&gt;use re '/m'&lt;/code&gt; を使用すると、レキシカルスコープ（ファイル全体でも &lt;code&gt;/m&lt;/code&gt; に対して/ mを有効にできます。（古いバージョン： &lt;code&gt;$*&lt;/code&gt; がtrue値に設定されている場合、すべての正規表現は &lt;code&gt;/m&lt;/code&gt; を使用して記述されているかのように動作しました。）</target>
        </trans-unit>
        <trans-unit id="c1168108b163850f03f0e7b84e90e2a3b75e09dc" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;$Level&lt;/code&gt; to perform a backtrace, Test2 uses a context object. In this sample you create a context object and store it. This locks the context (errors report 1 level up from here) for all wrapped tools to find. You do not need to use the context object, but you do need to store it in a variable. Once the sub ends the &lt;code&gt;$ctx&lt;/code&gt; variable is destroyed which lets future tools find their own.</source>
          <target state="translated">&lt;code&gt;$Level&lt;/code&gt; を使用してバックトレースを実行する代わりに、Test2はコンテキストオブジェクトを使用します。このサンプルでは、​​コンテキストオブジェクトを作成して保存します。これにより、ラップされたすべてのツールが検出できるようにコンテキストがロックされます（エラーはここから1レベル上に報告されます）。コンテキストオブジェクトを使用する必要はありませんが、変数に格納する必要があります。サブが終了すると、 &lt;code&gt;$ctx&lt;/code&gt; 変数が破棄され、将来のツールが独自の変数を見つけられるようになります。</target>
        </trans-unit>
        <trans-unit id="6e1ae30c884ab234189c910ec5202733bc2390ed" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;given()&lt;/code&gt; , you can use a &lt;code&gt;foreach()&lt;/code&gt; loop. For example, here's one way to count how many times a particular string occurs in an array:</source>
          <target state="translated">&lt;code&gt;given()&lt;/code&gt; を使用する代わりに、 &lt;code&gt;foreach()&lt;/code&gt; ループを使用できます。たとえば、配列に特定の文字列が出現する回数をカウントする1つの方法を次に示します。</target>
        </trans-unit>
        <trans-unit id="825297ab548b22ab92e503372aa9e1350b6ae1f8" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;given()&lt;/code&gt;, you can use a &lt;code&gt;foreach()&lt;/code&gt; loop. For example, here's one way to count how many times a particular string occurs in an array:</source>
          <target state="translated">代わりに使用しての &lt;code&gt;given()&lt;/code&gt; 、あなたが使用することができます &lt;code&gt;foreach()&lt;/code&gt; ループを。たとえば、特定の文字列が配列に出現する回数をカウントする1つの方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="aaff3d1d72214bb8cea47592fb5e3c306e475c28" translate="yes" xml:space="preserve">
          <source>Instead of writing an overloaded interface using pure Perl, you can also use the OVERLOAD keyword to define additional Perl names for your functions (like the ALIAS: keyword above). However, the overloaded functions must be defined in such a way as to accept the number of parameters supplied by perl's overload system. For most overload methods, it will be three parameters; for the &lt;code&gt;nomethod&lt;/code&gt; function it will be four. However, the bitwise operators &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt; may be called with three</source>
          <target state="translated">純粋なPerlを使用してオーバーロードされたインターフェースを作成する代わりに、OVERLOADキーワードを使用して、関数の追加のPerl名を定義することもできます（上記のALIAS：キーワードなど）。ただし、オーバーロードされた関数は、perlのオーバーロードシステムによって提供されるパラメーターの数を受け入れるように定義する必要があります。ほとんどのオーバーロードメソッドでは、3つのパラメーターになります。用 &lt;code&gt;nomethod&lt;/code&gt; の機能それは4になります。ただし、ビット演算子 &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; 、 &lt;code&gt;^&lt;/code&gt; 、および &lt;code&gt;~&lt;/code&gt; は3つで呼び出すことができます</target>
        </trans-unit>
        <trans-unit id="ccf329df99c7b872b2b1eb49834514d53120f89e" translate="yes" xml:space="preserve">
          <source>Instead of writing an overloaded interface using pure Perl, you can also use the OVERLOAD keyword to define additional Perl names for your functions (like the ALIAS: keyword above). However, the overloaded functions must be defined with three parameters (except for the nomethod() function which needs four parameters). If any function has the OVERLOAD: keyword, several additional lines will be defined in the c file generated by xsubpp in order to register with the overload magic.</source>
          <target state="translated">純粋な Perl を使用してオーバーロードされたインタフェースを書く代わりに、OVERLOAD キーワードを使用して、関数に追加の Perl 名を定義することもできます (上記の ALIAS:キーワードのように)。ただし、オーバーロードされた関数は 3 つのパラメータで定義する必要があります (4 つのパラメータを必要とする nomethod()関数を除く)。いずれかの関数に OVERLOAD:キーワードがある場合、オーバーロードマジックに登録するために、xsubpp によって生成された c ファイルにいくつかの追加行が定義されます。</target>
        </trans-unit>
        <trans-unit id="638fcabfcb5cd72cef4275780294bf41068d5ea4" translate="yes" xml:space="preserve">
          <source>Instead of writing multiple &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; statements, you may define multiple constants in a single statement by giving, instead of the constant name, a reference to a hash where the keys are the names of the constants to be defined. Obviously, all constants defined using this method must have a single value.</source>
          <target state="translated">複数の &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; ステートメントを作成する代わりに、定数名の代わりに、キーが定義される定数の名前であるハッシュへの参照を与えることにより、単一のステートメントで複数の定数を定義できます。明らかに、このメソッドを使用して定義されたすべての定数は、単一の値を持つ必要があります。</target>
        </trans-unit>
        <trans-unit id="df4a7dbc731cad321f60bc3be4e6304404421661" translate="yes" xml:space="preserve">
          <source>Instead of writing multiple &lt;code&gt;use constant&lt;/code&gt; statements, you may define multiple constants in a single statement by giving, instead of the constant name, a reference to a hash where the keys are the names of the constants to be defined. Obviously, all constants defined using this method must have a single value.</source>
          <target state="translated">複数の &lt;code&gt;use constant&lt;/code&gt; ステートメントを作成する代わりに、定数名の代わりに、キーが定義する定数の名前であるハッシュへの参照を指定することにより、単一のステートメントで複数の定数を定義できます。明らかに、このメソッドを使用して定義されたすべての定数は、単一の値を持っている必要があります。</target>
        </trans-unit>
        <trans-unit id="6782b252ab0c32bd42d86fbd7b3f79af4ff565e5" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toFOLD_utf8&quot;&gt;toFOLD_utf8&lt;/a&gt;.</source>
          <target state="translated">代わりに&lt;a href=&quot;#toFOLD_utf8&quot;&gt;toFOLD_utf8を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="d1f6743fcc3e6286f6e367f0b73ab61c02242a50" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toLOWER_utf8&quot;&gt;toLOWER_utf8&lt;/a&gt;.</source>
          <target state="translated">代わりに&lt;a href=&quot;#toLOWER_utf8&quot;&gt;toLOWER_utf8を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="ef6bd3b06361be7e68d9b7223a3d403afc7f30fb" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toTITLE_utf8&quot;&gt;toTITLE_utf8&lt;/a&gt;.</source>
          <target state="translated">代わりに&lt;a href=&quot;#toTITLE_utf8&quot;&gt;toTITLE_utf8を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="f68321016539906487e3d1b25d1d9b7700cb63a1" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#toUPPER_utf8&quot;&gt;toUPPER_utf8&lt;/a&gt;.</source>
          <target state="translated">代わりに&lt;a href=&quot;#toUPPER_utf8&quot;&gt;toUPPER_utf8を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="c8ee82e6fa25bfd2bc478049adfc2e72d633951e" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_buf&lt;/a&gt;, or rarely, &lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchr&lt;/a&gt;.</source>
          <target state="translated">代わりに&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;utf8_to_uvchr_bufを&lt;/a&gt;使用するか、まれに&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;utf8n_to_uvchrを&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="d5da1022fb23560c08ccb2175ba3ed7594365a4b" translate="yes" xml:space="preserve">
          <source>Instead use &lt;a href=&quot;perlapi#utf8_to_uvchr_buf&quot;&gt;&quot;utf8_to_uvchr_buf&quot; in perlapi&lt;/a&gt;, or rarely, &lt;a href=&quot;perlapi#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot; in perlapi&lt;/a&gt;.</source>
          <target state="translated">代わりに&lt;a href=&quot;perlapi#utf8_to_uvchr_buf&quot;&gt;、perlapi&lt;/a&gt;で「utf8_to_uvchr_buf」を使用するか、まれに、perlapiで&lt;a href=&quot;perlapi#utf8n_to_uvchr&quot;&gt;「utf8n_to_uvchr」を使用し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="3a1e3be314ffd2bc3abc3de781de1fea85191bb5" translate="yes" xml:space="preserve">
          <source>Instead you almost certainly want to use &lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt; or &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;.</source>
          <target state="translated">代わりに、ほぼ確実に&lt;a href=&quot;#uvchr_to_utf8&quot;&gt;uvchr_to_utf8&lt;/a&gt;または&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;uvchr_to_utf8_flags&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="3c1ab72749459dc4de544fac6868597b605f1005" translate="yes" xml:space="preserve">
          <source>Instead you almost certainly want to use &lt;a href=&quot;perlapi#uvchr_to_utf8&quot;&gt;&quot;uvchr_to_utf8&quot; in perlapi&lt;/a&gt; or &lt;a href=&quot;perlapi#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot; in perlapi&lt;/a&gt;.</source>
          <target state="translated">代わりに、あなたはほぼ確実に使用したい&lt;a href=&quot;perlapi#uvchr_to_utf8&quot;&gt;はperlapiで「uvchr_to_utf8を」&lt;/a&gt;か&lt;a href=&quot;perlapi#uvchr_to_utf8_flags&quot;&gt;はperlapiで「uvchr_to_utf8_flags」&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c61a7798941b565eb0ca8902a985ea083443b8b" translate="yes" xml:space="preserve">
          <source>Instead, &lt;code&gt;bytes_to_utf8&lt;/code&gt; will give you a UTF-8-encoded &lt;b&gt;copy&lt;/b&gt; of its string argument. This is useful for having the data available for comparisons and so on, without harming the original SV. There's also &lt;code&gt;utf8_to_bytes&lt;/code&gt; to go the other way, but naturally, this will fail if the string contains any characters above 255 that can't be represented in a single byte.</source>
          <target state="translated">代わりに、 &lt;code&gt;bytes_to_utf8&lt;/code&gt; は文字列引数のUTF-8エンコードされた&lt;b&gt;コピー&lt;/b&gt;を提供します。これは、元のSVを損なうことなく、データを比較などに利用できるようにするのに役立ちます。逆に進むために &lt;code&gt;utf8_to_bytes&lt;/code&gt; もありますが、255を超える1バイトで表現できない文字が文字列に含まれていると、当然これは失敗します。</target>
        </trans-unit>
        <trans-unit id="1d682bf7489c4d815717f3faba809d2c01f4ea4b" translate="yes" xml:space="preserve">
          <source>Instead, all available methods to execute plain text files on Windows rely on the file &quot;extension&quot;. There are three methods to use this to execute perl scripts:</source>
          <target state="translated">代わりに、Windows上でプレーンテキストファイルを実行するために利用できるすべての方法は、ファイルの「拡張子」に依存しています。これを利用してPerlスクリプトを実行する方法は3つあります。</target>
        </trans-unit>
        <trans-unit id="1b6f6bc21ad6a818717c640ad98e7196014d29c9" translate="yes" xml:space="preserve">
          <source>Instead, have it like this:</source>
          <target state="translated">代わりに、こんな感じで。</target>
        </trans-unit>
        <trans-unit id="c21043f535759255fae7da396e1a74414adc0df4" translate="yes" xml:space="preserve">
          <source>Instead, it's recommended one uses &lt;code&gt;state&lt;/code&gt; variables to achieve the same effect:</source>
          <target state="translated">代わりに、 &lt;code&gt;state&lt;/code&gt; 変数を使用して同じ効果を実現することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="3d0ab28444eeb1a3b5d5448f3e8b2d9f9844879d" translate="yes" xml:space="preserve">
          <source>Instead, switch from &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt; to &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;. &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; does everything &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt; does, and more! In fact, &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; does things</source>
          <target state="translated">代わりに、&lt;a href=&quot;Test::Simple&quot;&gt;Test :: Simple&lt;/a&gt;から&lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt;に切り替えてください。&lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt;はすべてを実行します&lt;a href=&quot;Test::Simple&quot;&gt;Test :: Simple&lt;/a&gt;は実行します、そしてもっと！実際、&lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt;はより多くのことを行います</target>
        </trans-unit>
        <trans-unit id="767f1cd6299c67c930c8d9fe765261f308e05da4" translate="yes" xml:space="preserve">
          <source>Instead, the following solution works rather well. The nice things about it are 1) you can start using it right away; 2) it is more powerful, because it will do the right thing with a pattern like */*/*.c; 3) you can decide whether you do/don't want to use it; and 4) you can extend the method to add any customizations (or even entirely different kinds of wildcard expansion).</source>
          <target state="translated">その代わりに、以下の解決策はむしろうまく機能します。これの良いところは、1)すぐに使い始めることができること、2)*/*/*/*.c のようなパターンで正しいことをするので、より強力であること、3)これを使うか使わないかを決めることができること、4)メソッドを拡張して、任意のカスタマイズを追加することができることです (あるいは、全く異なる種類のワイルドカード拡張を追加することもできます)。</target>
        </trans-unit>
        <trans-unit id="029f2d96c54611243fd4f7123ebf76a0e7725aa0" translate="yes" xml:space="preserve">
          <source>Instead, the stack stores information in a variable-length encoding of &lt;code&gt;ANY&lt;/code&gt; structures. The final value pushed is stored in the &lt;code&gt;UV&lt;/code&gt; field which encodes the kind of item held by the preceeding items; the count and types of which will depend on what kind of item is being stored. The kind field is pushed last because that will be the first field to be popped when unwinding items from the stack.</source>
          <target state="translated">代わりに、スタックは &lt;code&gt;ANY&lt;/code&gt; 構造の可変長エンコーディングで情報を格納します。プッシュされた最終値は、前のアイテムによって保持されているアイテムの種類をエンコードする &lt;code&gt;UV&lt;/code&gt; フィールドに格納されます。数と種類は、保存されているアイテムの種類によって異なります。種類フィールドは最後にプッシュされます。これは、スタックからアイテムを巻き戻すときに最初にポップされるフィールドになるためです。</target>
        </trans-unit>
        <trans-unit id="ca3e6ac1b90019684415c1dbba6b4a76bfa88d1e" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;blessed&lt;/code&gt; (in the &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module) for boolean checks, &lt;code&gt;isa&lt;/code&gt; for specific class checks and &lt;code&gt;reftype&lt;/code&gt; (also from &lt;a href=&quot;../scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;) for type checks. (See &lt;a href=&quot;../perlobj&quot;&gt;perlobj&lt;/a&gt; for details and a &lt;code&gt;blessed/isa&lt;/code&gt; example.)</source>
          <target state="translated">代わりに、ブールチェックには &lt;code&gt;blessed&lt;/code&gt; （&lt;a href=&quot;../scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;モジュール内）、特定のクラスチェックには &lt;code&gt;isa&lt;/code&gt; 、型チェックには &lt;code&gt;reftype&lt;/code&gt; （これも&lt;a href=&quot;../scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;から）を使用します。（詳細と &lt;code&gt;blessed/isa&lt;/code&gt; の例については&lt;a href=&quot;../perlobj&quot;&gt;perlobj&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="ff6123faf0e0d43395bbeea664d72b0be06f73ad" translate="yes" xml:space="preserve">
          <source>Instead, use &lt;code&gt;blessed&lt;/code&gt; (in the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; module) for boolean checks, &lt;code&gt;isa&lt;/code&gt; for specific class checks and &lt;code&gt;reftype&lt;/code&gt; (also from &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;) for type checks. (See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for details and a &lt;code&gt;blessed/isa&lt;/code&gt; example.)</source>
          <target state="translated">代わりに、ブールチェックには &lt;code&gt;blessed&lt;/code&gt; （&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;モジュール内）、特定のクラスチェックには &lt;code&gt;isa&lt;/code&gt; 、型チェックには &lt;code&gt;reftype&lt;/code&gt; （これも&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;から）を使用します。（詳細と &lt;code&gt;blessed/isa&lt;/code&gt; の例については&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;を参照してください。）</target>
        </trans-unit>
        <trans-unit id="88561bf4f68d300fba6b47877d2e1d88be295371" translate="yes" xml:space="preserve">
          <source>Instead, use a temporary:</source>
          <target state="translated">その代わり、一時的なものを使いましょう。</target>
        </trans-unit>
        <trans-unit id="4b239d64a76a8342f4a5e3f91a8ae44b81bce472" translate="yes" xml:space="preserve">
          <source>Instead, use double-quotes with a single backslash:</source>
          <target state="translated">代わりに、ダブルクォートにバックスラッシュを1つ入れて使用してください。</target>
        </trans-unit>
        <trans-unit id="d6975d2303b579219cd1ad4ae114ac6792c64260" translate="yes" xml:space="preserve">
          <source>Instead, use the definitions IV, UV, IVSIZE, I32SIZE, and so forth. Avoid things like I32 because they are &lt;b&gt;not&lt;/b&gt; guaranteed to be</source>
          <target state="translated">代わりに、IV、UV、IVSIZE、I32SIZEなどの定義を使用してください。それらがされているため、I32のようなものを避けるため&lt;b&gt;ではない&lt;/b&gt;ことが保証</target>
        </trans-unit>
        <trans-unit id="f29af992c4a56bb38b3dfd00c903703bc13b8ea4" translate="yes" xml:space="preserve">
          <source>Instead, write this using a lexical variable:</source>
          <target state="translated">代わりに、これを語彙変数を使って書きます。</target>
        </trans-unit>
        <trans-unit id="08114352d8e01718b9f4310cee2e4e9e17e09b27" translate="yes" xml:space="preserve">
          <source>Instructions on how to install your module along with any dependencies. Suggested information to include here:</source>
          <target state="translated">モジュールのインストール方法と依存関係の説明。ここに含めるべき情報を提案します。</target>
        </trans-unit>
        <trans-unit id="ecdea140cf34e5fdf5440492ab0f9ef1743393d2" translate="yes" xml:space="preserve">
          <source>Insure that colons marking targets are preceded by space, in order to distinguish the target delimiter from a colon appearing as part of a filespec.</source>
          <target state="translated">ファイルスペックの一部として現れるコロンとターゲットの区切り文字を区別するために、ターゲットをマークするコロンの前にスペースがあることを確認してください。</target>
        </trans-unit>
        <trans-unit id="683987ee4aeb538cfdf37663a8c0ab7ac90a2019" translate="yes" xml:space="preserve">
          <source>Integer Arithmetic</source>
          <target state="translated">整数演算</target>
        </trans-unit>
        <trans-unit id="efbf94ff9c1725858eeaef5462e64f2f9beabf82" translate="yes" xml:space="preserve">
          <source>Integer binary logarithm [C99]</source>
          <target state="translated">整数2進対数 [C99]</target>
        </trans-unit>
        <trans-unit id="0bbddfa82bfc58cb4fa39eff708183ee398ca07e" translate="yes" xml:space="preserve">
          <source>Integer binary logarithm [C99].</source>
          <target state="translated">整数2進対数[C99]。</target>
        </trans-unit>
        <trans-unit id="e9aa0af9187fd5006e57aa5fe9340c513694f8b0" translate="yes" xml:space="preserve">
          <source>Integer overflow in %s number</source>
          <target state="translated">整数オーバーフローが %s 数で発生しました。</target>
        </trans-unit>
        <trans-unit id="6f6b479cc505431a4dd13a180ea73dec5d1ae03c" translate="yes" xml:space="preserve">
          <source>Integer overflow in format string for %s</source>
          <target state="translated">s の書式文字列での整数オーバーフロー</target>
        </trans-unit>
        <trans-unit id="411c0a34661530dce26957f99bd67035b369dd12" translate="yes" xml:space="preserve">
          <source>Integer overflow in srand</source>
          <target state="translated">srandでの整数オーバーフロー</target>
        </trans-unit>
        <trans-unit id="4e060e7583c7facbbad20094c9d4fc91b279e279" translate="yes" xml:space="preserve">
          <source>Integer overflow in version</source>
          <target state="translated">バージョンでの整数オーバーフロー</target>
        </trans-unit>
        <trans-unit id="c0952c0d0ac1f6d4efaf83d1bb17a2ea9130956b" translate="yes" xml:space="preserve">
          <source>Integer overflow in version %d</source>
          <target state="translated">バージョン %d での整数オーバーフロー</target>
        </trans-unit>
        <trans-unit id="d2e40742eb38c2f7d8587ad34912b36536447d35" translate="yes" xml:space="preserve">
          <source>Integer. An optional leading plus or minus sign, followed by a sequence of digits.</source>
          <target state="translated">整数。オプションのプラスまたはマイナス記号の後に連続した数字が続きます。</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="4b35a75e337792a14859048b5fe4c1f4a2d46a86" translate="yes" xml:space="preserve">
          <source>Integrating local directories</source>
          <target state="translated">ローカルディレクトリの統合</target>
        </trans-unit>
        <trans-unit id="1c339f566d96dc4be124c8a012dc09ff7ba394ec" translate="yes" xml:space="preserve">
          <source>Intel C++ Compiler</source>
          <target state="translated">インテル C++コンパイラ</target>
        </trans-unit>
        <trans-unit id="f3a43fe57e64c611c07e7f0722fcf5e81fd02d7e" translate="yes" xml:space="preserve">
          <source>Intel HEX</source>
          <target state="translated">インテルヘックス</target>
        </trans-unit>
        <trans-unit id="283a7688f976826bc81b0d15b139b8fb7bc39125" translate="yes" xml:space="preserve">
          <source>Intel HEX is a file format for representing binary data, mostly for programming various chips, as a text file. (See &lt;a href=&quot;http://en.wikipedia.org/wiki/.hex&quot;&gt;http://en.wikipedia.org/wiki/.hex&lt;/a&gt; for a detailed description, and &lt;a href=&quot;http://en.wikipedia.org/wiki/SREC_&quot;&gt;http://en.wikipedia.org/wiki/SREC_&lt;/a&gt;(file_format) for the Motorola S-record format, which can be unravelled using the same technique.) Each line begins with a colon (':') and is followed by a sequence of hexadecimal characters, specifying a byte count</source>
          <target state="translated">Intel HEXは、バイナリデータを、主にさまざまなチップをプログラミングするために、テキストファイルとして表すためのファイル形式です。（詳細な説明については&lt;a href=&quot;http://en.wikipedia.org/wiki/SREC_&quot;&gt;http://en.wikipedia.org/wiki/.hex&lt;/a&gt;を、モトローラSレコード形式については&lt;a href=&quot;http://en.wikipedia.org/wiki/.hex&quot;&gt;http://en.wikipedia.org/wiki/SREC_（file_format）&lt;/a&gt;を参照してください。同じ手法を使用します。）各行はコロン（ '：'）で始まり、その後にバイト数を指定する一連の16進文字が続きます。</target>
        </trans-unit>
        <trans-unit id="a856ee1a019faac6da0b8db428273065b2de2b57" translate="yes" xml:space="preserve">
          <source>Intel HEX is a file format for representing binary data, mostly for programming various chips, as a text file. (See &lt;a href=&quot;https://en.wikipedia.org/wiki/.hex&quot;&gt;https://en.wikipedia.org/wiki/.hex&lt;/a&gt; for a detailed description, and &lt;a href=&quot;https://en.wikipedia.org/wiki/SREC_(file_format)&quot;&gt;https://en.wikipedia.org/wiki/SREC_(file_format)&lt;/a&gt; for the Motorola S-record format, which can be unravelled using the same technique.) Each line begins with a colon (':') and is followed by a sequence of hexadecimal characters, specifying a byte count</source>
          <target state="translated">Intel HEXは、主にさまざまなチップをプログラミングするためのバイナリデータをテキストファイルとして表すためのファイル形式です。（詳細な説明については&lt;a href=&quot;https://en.wikipedia.org/wiki/.hex&quot;&gt;https://en.wikipedia.org/wiki/.hex&lt;/a&gt;を、詳細な説明については&lt;a href=&quot;https://en.wikipedia.org/wiki/SREC_(file_format)&quot;&gt;https://en.wikipedia.org/wiki/SREC_(file_format）&lt;/a&gt;を参照してください。MotorolaSレコード形式については、解き明かすことができます。同じ手法を使用します。）各行はコロン（ '：'）で始まり、その後にバイト数を指定する16進文字のシーケンスが続きます。</target>
        </trans-unit>
        <trans-unit id="da544d1418799d25bfd09546e06754d3e5b1aeb3" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA</source>
          <target state="translated">IntelliJ IDEA</target>
        </trans-unit>
        <trans-unit id="380d7ac3123e0e68ffb5963fc34784cfb9731163" translate="yes" xml:space="preserve">
          <source>Intended for use on command line with &lt;b&gt;-M&lt;/b&gt; option as a way of testing arbitrary scripts against an uninstalled version of a package.</source>
          <target state="translated">アンインストールされたバージョンのパッケージに対して任意のスクリプトをテストする方法として、&lt;b&gt;-M&lt;/b&gt;オプションを指定してコマンドラインで使用することを目的としています。</target>
        </trans-unit>
        <trans-unit id="d75d6528effe0d95b951e2f70179256a5a75c5b0" translate="yes" xml:space="preserve">
          <source>Interacting with Perl from the Digital Command Language (DCL) shell often requires a different set of quotation marks than Unix shells do. For example:</source>
          <target state="translated">デジタルコマンド言語(DCL)シェルからPerlを操作するには、Unixシェルとは異なる引用符のセットが必要になることがよくあります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="39c574bcdb6de6c0029ded259821021591e578be" translate="yes" xml:space="preserve">
          <source>Interaction with Extensions</source>
          <target state="translated">拡張機能との相互作用</target>
        </trans-unit>
        <trans-unit id="36743263147e4579bf65378679da63cd8385f8a2" translate="yes" xml:space="preserve">
          <source>Interactive Client with IO::Socket</source>
          <target state="translated">IO::Socket を使用した対話型クライアント</target>
        </trans-unit>
        <trans-unit id="a16954cde7a599ddba4d577acd1b685762317ea3" translate="yes" xml:space="preserve">
          <source>Interactive mode:</source>
          <target state="translated">インタラクティブモード。</target>
        </trans-unit>
        <trans-unit id="bdcd0f2bf481dc531fd0fd8a96b470b347913b64" translate="yes" xml:space="preserve">
          <source>Interactive sessions maintain a lockfile, by default &lt;code&gt;~/.cpan/.&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; . Batch jobs can run without a lockfile and not disturb each other.</source>
          <target state="translated">対話型セッションは &lt;code&gt;~/.cpan/.&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; 維持し、デフォルトでは〜/ .cpan /です。ロック。バッチジョブは、ロックファイルなしで実行でき、互いに干渉しません。</target>
        </trans-unit>
        <trans-unit id="4049be05b318660a87d35f9664cb17d1ca51f690" translate="yes" xml:space="preserve">
          <source>Interactively supply an arbitrary &lt;code&gt;expression&lt;/code&gt; using &lt;code&gt;-e&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;-e&lt;/code&gt; を使用してインタラクティブに任意の &lt;code&gt;expression&lt;/code&gt; を指定します。</target>
        </trans-unit>
        <trans-unit id="d9612d7e5106a7533f6eeeb596274a84b741fb5b" translate="yes" xml:space="preserve">
          <source>Interactively supply an arbitrary &lt;code&gt;expression&lt;/code&gt; using &lt;code&gt;-e&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-e&lt;/code&gt; を使用して、任意の &lt;code&gt;expression&lt;/code&gt; をインタラクティブに指定します。</target>
        </trans-unit>
        <trans-unit id="216f7ef95315bf7807890aa65847604f1201542d" translate="yes" xml:space="preserve">
          <source>Interal Utilities for autodie and Fatal! This module is not a part of autodie's public API.</source>
          <target state="translated">autodie と Fatal! このモジュールは autodie の公開 API の一部ではありません。</target>
        </trans-unit>
        <trans-unit id="7f4333051573407ec799c7bafee1c6ca09470f1b" translate="yes" xml:space="preserve">
          <source>Interestingly we get slightly different results, which is mostly because the algorithm which generates the report is different, even though the output file format was allegedly identical. The elapsed, user and system times are clearly showing the time it took for &lt;code&gt;Devel::Profiler&lt;/code&gt; to execute its own run, but the column listings feel more accurate somehow than the ones we had earlier from &lt;code&gt;Devel::DProf&lt;/code&gt; . The 102% figure has disappeared, for example. This is where we have to use the tools at our disposal, and recognise their pros and cons, before using them. Interestingly, the numbers of calls for each subroutine are identical in the two reports, it's the percentages which differ. As the author of &lt;code&gt;Devel::Proviler&lt;/code&gt; writes:</source>
          <target state="translated">興味深いことに、わずかに異なる結果が得られます。これは主に、出力ファイル形式が同一であるとされているにもかかわらず、レポートを生成するアルゴリズムが異なるためです。経過時間、ユーザー時間、システム時間は、 &lt;code&gt;Devel::Profiler&lt;/code&gt; が独自の実行を実行するのにかかった時間を明確に示していますが、列のリストは、以前の &lt;code&gt;Devel::DProf&lt;/code&gt; ものよりも正確に感じられます。たとえば、102％の数値は消えました。これは、私たちが自由にツールを使用し、それらを使用する前に長所と短所を認識しなければならない場所です。興味深いことに、各サブルーチンの呼び出し回数は2つのレポートで同じで、割合が異なります。 &lt;code&gt;Devel::Proviler&lt;/code&gt; 作者は次のように書いています：</target>
        </trans-unit>
        <trans-unit id="80ae20ece05d487021ccd9de0a68139efa803e3c" translate="yes" xml:space="preserve">
          <source>Interestingly we get slightly different results, which is mostly because the algorithm which generates the report is different, even though the output file format was allegedly identical. The elapsed, user and system times are clearly showing the time it took for &lt;code&gt;Devel::Profiler&lt;/code&gt; to execute its own run, but the column listings feel more accurate somehow than the ones we had earlier from &lt;code&gt;Devel::DProf&lt;/code&gt;. The 102% figure has disappeared, for example. This is where we have to use the tools at our disposal, and recognise their pros and cons, before using them. Interestingly, the numbers of calls for each subroutine are identical in the two reports, it's the percentages which differ. As the author of &lt;code&gt;Devel::Proviler&lt;/code&gt; writes:</source>
          <target state="translated">興味深いことに、結果はわずかに異なります。これは主に、出力ファイルの形式が同じであるにもかかわらず、レポートを生成するアルゴリズムが異なるためです。経過時間、ユーザー時間、およびシステム時間は、 &lt;code&gt;Devel::Profiler&lt;/code&gt; が独自の実行を実行するのにかかった時間を明確に示していますが、列のリストは、以前に &lt;code&gt;Devel::DProf&lt;/code&gt; から取得したものよりも正確に感じられます。たとえば、102％の数字は消えました。これは、私たちが自由に使えるツールを使用し、それらを使用する前にそれらの長所と短所を認識しなければならない場所です。興味深いことに、各サブルーチンの呼び出し数は2つのレポートで同じであり、パーセンテージが異なります。 &lt;code&gt;Devel::Proviler&lt;/code&gt; 作者は次のように書いています：</target>
        </trans-unit>
        <trans-unit id="8fe9cc8d59c908d2dfc528838b1b4b5192a00c09" translate="yes" xml:space="preserve">
          <source>Interface Strategy</source>
          <target state="translated">インターフェイス戦略</target>
        </trans-unit>
        <trans-unit id="e9bdbdb9fc26f525c1a8ecbeb7cc8ceb768f4d54" translate="yes" xml:space="preserve">
          <source>Interface between CPAN.pm and Kwalify.pm</source>
          <target state="translated">CPAN.pm と Kwalify.pm の間のインターフェース</target>
        </trans-unit>
        <trans-unit id="7481e39dedf2d2f4c332b82f6502c28043c6929e" translate="yes" xml:space="preserve">
          <source>Interface to Berkeley DB</source>
          <target state="translated">バークレーDBへのインターフェース</target>
        </trans-unit>
        <trans-unit id="8e2ccff2c57048b71f1d307b6edb8f11b2c43b05" translate="yes" xml:space="preserve">
          <source>Interface to cwd from EMX. Used by &lt;code&gt;Cwd::cwd&lt;/code&gt; .</source>
          <target state="translated">EMXからcwdへのインターフェイス。 &lt;code&gt;Cwd::cwd&lt;/code&gt; によって使用されます。</target>
        </trans-unit>
        <trans-unit id="5554dd630fd9035ebceb918f102c567832d75cf6" translate="yes" xml:space="preserve">
          <source>Interface to cwd from EMX. Used by &lt;code&gt;Cwd::cwd&lt;/code&gt;.</source>
          <target state="translated">EMXからcwdへのインターフェース。 &lt;code&gt;Cwd::cwd&lt;/code&gt; によって使用されます。</target>
        </trans-unit>
        <trans-unit id="6adf7d5cbdb0f3010f3086f3f294d7023f460422" translate="yes" xml:space="preserve">
          <source>Interface to get/set environment variables. Returns the current value as a Unicode string. The $uni_key and $uni_value arguments are expected to be Unicode strings as well. Passing &lt;code&gt;undef&lt;/code&gt; as $uni_value deletes the environment variable named $uni_key.</source>
          <target state="translated">環境変数を取得/設定するためのインターフェース。現在の値をUnicode文字列として返します。$ uni_key引数と$ uni_value引数もUnicode文字列であることが期待されています。 &lt;code&gt;undef&lt;/code&gt; を$ uni_valueとして渡すと、$ uni_keyという名前の環境変数が削除されます。</target>
        </trans-unit>
        <trans-unit id="dae2466aff78641921461ec62c4d4ef5f0f5b074" translate="yes" xml:space="preserve">
          <source>Interface to zlib compression library</source>
          <target state="translated">zlib 圧縮ライブラリへのインタフェース</target>
        </trans-unit>
        <trans-unit id="e346886e4b9cdfd6ef396ff466a7b37cd952cc6d" translate="yes" xml:space="preserve">
          <source>Interfaces to / Emulations of Other Programming Languages</source>
          <target state="translated">他のプログラミング言語とのインターフェイス/エミュレーション</target>
        </trans-unit>
        <trans-unit id="2188689d5ae5f33a21007d13b3dcb52813873257" translate="yes" xml:space="preserve">
          <source>Interfaces to some Win32 API Functions</source>
          <target state="translated">Win32 API 関数へのインターフェイス</target>
        </trans-unit>
        <trans-unit id="79cc6bbe2327c1551d1e5d40f07d9b83bc80ae14" translate="yes" xml:space="preserve">
          <source>Interleaving STDOUT/STDERR</source>
          <target state="translated">STDOUT/STDERRのインターリーブ</target>
        </trans-unit>
        <trans-unit id="033764585e80fa1ca47c0451c08faf861b72f44d" translate="yes" xml:space="preserve">
          <source>Intermediary representation of a table for use in specialized &lt;a href=&quot;Test::API::Context&quot;&gt;Test::API::Context&lt;/a&gt; methods which generate &lt;a href=&quot;Test2::EventFacet::Info&quot;&gt;Test2::EventFacet::Info&lt;/a&gt; facets.</source>
          <target state="translated">&lt;a href=&quot;Test2::EventFacet::Info&quot;&gt;Test2 :: EventFacet :: Info&lt;/a&gt;ファセットを生成する特殊な&lt;a href=&quot;Test::API::Context&quot;&gt;Test :: API :: Context&lt;/a&gt;メソッドで使用するためのテーブルの中間表現。</target>
        </trans-unit>
        <trans-unit id="8c3fe500d640cf31fd9a657a78f2b102d9181133" translate="yes" xml:space="preserve">
          <source>Intermediary representation of a table.</source>
          <target state="translated">表の中間的な表現。</target>
        </trans-unit>
        <trans-unit id="e20643cb83b71e3458cd8974c42d3daa3e1288a1" translate="yes" xml:space="preserve">
          <source>Internal Format</source>
          <target state="translated">内部フォーマット</target>
        </trans-unit>
        <trans-unit id="61d67a4869b5e28886ef542cee4befaab340cf82" translate="yes" xml:space="preserve">
          <source>Internal Functions</source>
          <target state="translated">内部機能</target>
        </trans-unit>
        <trans-unit id="0cef48f59f7e2f51840fc46f9024c24cc33d8ed0" translate="yes" xml:space="preserve">
          <source>Internal Utility subroutines for autodie and Fatal</source>
          <target state="translated">autodieとFatalのための内部ユーティリティサブルーチン</target>
        </trans-unit>
        <trans-unit id="5af8acca69afbd9c6d39218e0bb28d32d199f366" translate="yes" xml:space="preserve">
          <source>Internal configuration handling for CPAN.pm</source>
          <target state="translated">CPAN.pm の内部設定処理</target>
        </trans-unit>
        <trans-unit id="0806883110f04db9f91191aca94f31996b0d72ea" translate="yes" xml:space="preserve">
          <source>Internal debugging for CPAN.pm</source>
          <target state="translated">CPAN.pm の内部デバッグ</target>
        </trans-unit>
        <trans-unit id="4c898c3410ed0ae8d99f5b87b9783ee59e1feeaf" translate="yes" xml:space="preserve">
          <source>Internal debugging messages are enabled when $dl_debug is set true. Currently setting $dl_debug only affects the Perl side of the DynaLoader. These messages should help an application developer to resolve any DynaLoader usage problems.</source>
          <target state="translated">dl_debugがtrueに設定されていると、内部デバッグメッセージが有効になります。現在のところ、$dl_debugの設定はDynaLoaderのPerl側のみに影響を与えます。これらのメッセージは、アプリケーション開発者がDynaLoaderの使用上の問題を解決するのに役立つはずです。</target>
        </trans-unit>
        <trans-unit id="c2682bb60ef046fd0af9a65133fafcb74ba078ce" translate="yes" xml:space="preserve">
          <source>Internal disaster in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正規表現の内部災害。&amp;lt;-ここにm /％s /でマーク</target>
        </trans-unit>
        <trans-unit id="49405ebb7fde7f417d0e5c600dc6fa4e232257c1" translate="yes" xml:space="preserve">
          <source>Internal error: %s</source>
          <target state="translated">内部エラー:%s</target>
        </trans-unit>
        <trans-unit id="d873f4a2f97ab05d24f6fa0f06cef45d8aeae3b7" translate="yes" xml:space="preserve">
          <source>Internal format</source>
          <target state="translated">内部フォーマット</target>
        </trans-unit>
        <trans-unit id="a7b06547359f2b157e33961f9b748082a4eb9b46" translate="yes" xml:space="preserve">
          <source>Internal function Hash::Util::FieldHash::_fieldhash</source>
          <target state="translated">内部関数 Hash::Util::FieldHash::_fieldhash</target>
        </trans-unit>
        <trans-unit id="5f0c27e8b0c0bee621d0e3ce9073f2744d23dd75" translate="yes" xml:space="preserve">
          <source>Internal function which adds the filter, based on the &lt;a href=&quot;filter_add&quot;&gt;filter_add&lt;/a&gt; argument type.</source>
          <target state="translated">&lt;a href=&quot;filter_add&quot;&gt;filter_add&lt;/a&gt;引数タイプに基づいて、フィルターを追加する内部関数。</target>
        </trans-unit>
        <trans-unit id="51b9dd26770184bcb91b7be8acd8ff5db510c8df" translate="yes" xml:space="preserve">
          <source>Internal function which adds the filter, based on the &lt;a href=&quot;http://search.cpan.org/perldoc/filter_add&quot;&gt;filter_add&lt;/a&gt; argument type.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/filter_add&quot;&gt;filter_add&lt;/a&gt;引数タイプに基づいてフィルターを追加する内部関数。</target>
        </trans-unit>
        <trans-unit id="5fee2b9c80ad50aec00177a91487a9d17942074f" translate="yes" xml:space="preserve">
          <source>Internal handling of tar archives for CPAN.pm</source>
          <target state="translated">CPAN.pm の tar アーカイブの内部処理</target>
        </trans-unit>
        <trans-unit id="8e0c690a448500e398abe5fb8a070cf47a50330b" translate="yes" xml:space="preserve">
          <source>Internal inconsistency in tracking vforks</source>
          <target state="translated">vforksのトラッキングにおける内部的な不整合</target>
        </trans-unit>
        <trans-unit id="f7017225658a0f9fba19af865f848f427597c31a" translate="yes" xml:space="preserve">
          <source>Internal method for printing errors and warnings. If no options are given, simply prints &quot;@_&quot;. The following options are recognized and used to form the output:</source>
          <target state="translated">エラーや警告を表示するための内部メソッド。オプションが与えられていない場合は、単に &quot;@_&quot; を出力します。以下のオプションが認識され、出力を形成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="d524d9cfc678704c162c4cb4460355871a08ade5" translate="yes" xml:space="preserve">
          <source>Internal object used by Time::gmtime and Time::localtime</source>
          <target state="translated">Time::gmtimeおよびTime::localtimeが使用する内部オブジェクト</target>
        </trans-unit>
        <trans-unit id="dec6a2c45a2bdd64a3ec8fcc2511727cc99b5b26" translate="yes" xml:space="preserve">
          <source>Internal queue support for CPAN.pm</source>
          <target state="translated">CPAN.pm の内部キューのサポート</target>
        </trans-unit>
        <trans-unit id="237da84ead8405b42fa85a7e388ec997365ff6da" translate="yes" xml:space="preserve">
          <source>Internal urp in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正規表現の内部urp; &amp;lt;-ここにm /％s /でマーク</target>
        </trans-unit>
        <trans-unit id="62e13d391ba568ec11cf915e5927275eb2d03a56" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; are implemented with a real tied interface via &lt;a href=&quot;Tie::Hash::NamedCapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt;. The methods in that package will call back into these functions. However the usage of &lt;a href=&quot;Tie::Hash::NamedCapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; for this purpose might change in future releases. For instance this might be implemented by magic instead (would need an extension to mgvtbl).</source>
          <target state="translated">内部的には、 &lt;code&gt;%+&lt;/code&gt; と &lt;code&gt;%-&lt;/code&gt; は、&lt;a href=&quot;Tie::Hash::NamedCapture&quot;&gt;Tie :: Hash :: NamedCaptureを&lt;/a&gt;介して実際に関連付けられたインターフェイスで実装されます。そのパッケージのメソッドは、これらの関数を呼び出します。ただし、この目的での&lt;a href=&quot;Tie::Hash::NamedCapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt;の使用法は、将来のリリースで変更される可能性があります。たとえば、これは代わりに魔法によって実装される可能性があります（mgvtblへの拡張が必要になります）。</target>
        </trans-unit>
        <trans-unit id="1de0eedbd92548d18bf918a068ea4b60732f9cf3" translate="yes" xml:space="preserve">
          <source>Internally &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; are implemented with a real tied interface via &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt;. The methods in that package will call back into these functions. However the usage of &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; for this purpose might change in future releases. For instance this might be implemented by magic instead (would need an extension to mgvtbl).</source>
          <target state="translated">内部的には &lt;code&gt;%+&lt;/code&gt; と &lt;code&gt;%-&lt;/code&gt; は&lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCaptureを&lt;/a&gt;介して実際に結び付けられたインターフェースで実装されます。そのパッケージのメソッドは、これらの関数をコールバックします。ただし、この目的での&lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt;の使用法は、将来のリリースで変更される可能性があります。たとえば、これは代わりに魔法によって実装される可能性があります（mgvtblへの拡張が必要になります）。</target>
        </trans-unit>
        <trans-unit id="1b09ff7b696f900f84f4dabc94d78d0ec9f89714" translate="yes" xml:space="preserve">
          <source>Internally CPAN.pm uses the UTF-8 charset. If your terminal is expecting ISO-8859-1 charset, a converter can be activated by setting term_is_latin to a true value in your config file. One way of doing so would be</source>
          <target state="translated">内部的に CPAN.pm は UTF-8 文字セットを使用します。端末が ISO-8859-1 の文字セットを期待している場合、設定ファイルで term_is_latin を真の値に設定することでコンバータを有効にすることができます。これを行う一つの方法は以下のようになります</target>
        </trans-unit>
        <trans-unit id="80378d1e7d2da0cf424eca7e07458848627808d4" translate="yes" xml:space="preserve">
          <source>Internally Encoding -&amp;gt; Unicode and Unicode -&amp;gt; Encoding Map looks like this;</source>
          <target state="translated">内部エンコード-&amp;gt; UnicodeおよびUnicode-&amp;gt;エンコードマップは次のようになります。</target>
        </trans-unit>
        <trans-unit id="0270a1a0f07e6453af1ad3d10386c0ad1d3a4e99" translate="yes" xml:space="preserve">
          <source>Internally the Benchmark object holds timing values, described in &lt;a href=&quot;#NOTES&quot;&gt;&quot;NOTES&quot;&lt;/a&gt; below. The following methods can be used to access them:</source>
          <target state="translated">内部的には、Benchmarkオブジェクトは、以下の&lt;a href=&quot;#NOTES&quot;&gt;「注」&lt;/a&gt;で説明するタイミング値を保持します。次の方法を使用してそれらにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="8ac21d3e9553672475ffa22a2c6fb0c3420e3cc6" translate="yes" xml:space="preserve">
          <source>Internally the Benchmark object holds timing values, described in &lt;a href=&quot;#NOTES&quot;&gt;NOTES&lt;/a&gt; below. The following methods can be used to access them:</source>
          <target state="translated">内部的に、Benchmarkオブジェクトはタイミング値を保持します。これについては、以下の&lt;a href=&quot;#NOTES&quot;&gt;注&lt;/a&gt;で説明します。次のメソッドを使用してそれらにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="a523262f74789d99cb822f252d727c1f77360575" translate="yes" xml:space="preserve">
          <source>Internally this is set to &lt;code&gt;NULL&lt;/code&gt; unless a custom engine is specified in &lt;code&gt;$^H{regcomp}&lt;/code&gt; , Perl's own set of callbacks can be accessed in the struct pointed to by &lt;code&gt;RE_ENGINE_PTR&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$^H{regcomp}&lt;/code&gt; でカスタムエンジンが指定されていない限り、内部的にこれは &lt;code&gt;NULL&lt;/code&gt; に設定されます。Perl独自のコールバックのセットには、 &lt;code&gt;RE_ENGINE_PTR&lt;/code&gt; が指す構造体でアクセスできます。</target>
        </trans-unit>
        <trans-unit id="c3120174b4db905355a8c95bdaa9494f155c0435" translate="yes" xml:space="preserve">
          <source>Internally this is set to &lt;code&gt;NULL&lt;/code&gt; unless a custom engine is specified in &lt;code&gt;$^H{regcomp}&lt;/code&gt;, Perl's own set of callbacks can be accessed in the struct pointed to by &lt;code&gt;RE_ENGINE_PTR&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$^H{regcomp}&lt;/code&gt; でカスタムエンジンが指定されていない限り、内部的にはこれは &lt;code&gt;NULL&lt;/code&gt; に設定され、Perl独自のコールバックのセットは &lt;code&gt;RE_ENGINE_PTR&lt;/code&gt; が指す構造体でアクセスできます。</target>
        </trans-unit>
        <trans-unit id="1d5951d905f459e1665d8721f731d5fdbea427b7" translate="yes" xml:space="preserve">
          <source>Internally used by Encode</source>
          <target state="translated">Encodeで内部的に使用される</target>
        </trans-unit>
        <trans-unit id="e76ceb49e27718344d5ee1ece08b4b732be4cccc" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::??::ISO_2022_*</source>
          <target state="translated">内部的には Encode:??::ISO_2022_*で使用されます。</target>
        </trans-unit>
        <trans-unit id="2bebc443d25f2caf9161712ece027e6af3e9145b" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::CN</source>
          <target state="translated">内部的には Encode::CN によって使用されます。</target>
        </trans-unit>
        <trans-unit id="449dbdf27f0aebf5b3ec15f606b3cbc5adf19193" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::JP</source>
          <target state="translated">Encode::JP によって内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="c43fcf4d81bc5dc37c2f1693cf4046ad46e8bf06" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::JP::2022_JP*</source>
          <target state="translated">Encode::JP::2022_JP*で内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="b7211781b63a5b485cff3f483aa4493e62335113" translate="yes" xml:space="preserve">
          <source>Internally used by Encode::KR</source>
          <target state="translated">Encode::KR によって内部的に使用されます。</target>
        </trans-unit>
        <trans-unit id="87865024ef8da5f651d4b8f2dfd42f62371e839c" translate="yes" xml:space="preserve">
          <source>Internally, Perl currently uses either whatever the native eight-bit character set of the platform (for example Latin-1) is, defaulting to UTF-8, to encode Unicode strings. Specifically, if all code points in the string are &lt;code&gt;0xFF&lt;/code&gt; or less, Perl uses the native eight-bit character set. Otherwise, it uses UTF-8.</source>
          <target state="translated">内部的には、Perlは現在、プラットフォームのネイティブ8ビット文字セット（たとえば、Latin-1）がデフォルトでUTF-8であるものを使用して、Unicode文字列をエンコードします。特に、文字列内のすべてのコードポイントが &lt;code&gt;0xFF&lt;/code&gt; 以下の場合、Perlはネイティブの8ビット文字セットを使用します。それ以外の場合は、UTF-8を使用します。</target>
        </trans-unit>
        <trans-unit id="5c9c0562b20651bd210573c4a3cd205f4716cb6a" translate="yes" xml:space="preserve">
          <source>Internally, native integer arithmetic (as provided by your C compiler) is used. This means that Perl's own semantics for arithmetic operations may not be preserved. One common source of trouble is the modulus of negative numbers, which Perl does one way, but your hardware may do another.</source>
          <target state="translated">内部的には、ネイティブの整数演算(C コンパイラで提供されている)が使用されます。これは、Perl 自身の算術演算のセマンティクスが保持されていない可能性があることを意味します。よくあるトラブルの原因は負の数のモジュラスですが、これは Perl が一方的に行いますが、ハードウェアが別の方法で行うことがあります。</target>
        </trans-unit>
        <trans-unit id="b7fbfab5bd07346d2a0d188d0642fad2cf67e914" translate="yes" xml:space="preserve">
          <source>Internally, we often set this to an object of class Pod::Simple::Progress. That class is probably undocumented, but you may wish to look at its source.</source>
          <target state="translated">内部的には、これをクラスPod::Simple::Progressのオブジェクトに設定することがよくあります。このクラスはおそらく文書化されていませんが、そのソースを見てみるといいでしょう。</target>
        </trans-unit>
        <trans-unit id="4e1f47a6ca884b2242a2daaec979f4c9e4628f25" translate="yes" xml:space="preserve">
          <source>Internally, your computer represents floating-point numbers in binary. Digital (as in powers of two) computers cannot store all numbers exactly. Some real numbers lose precision in the process. This is a problem with how computers store numbers and affects all computer languages, not just Perl.</source>
          <target state="translated">内部的には、コンピュータは浮動小数点数を2進数で表しています。デジタル(2の累乗のように)コンピュータは、すべての数字を正確に保存することはできません。いくつかの実数はその過程で精度を失ってしまいます。これは、コンピュータが数字を格納する方法の問題であり、Perlだけでなく、すべてのコンピュータ言語に影響を与えます。</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="5b92377b87e725e0dd0672bfd114d434b8fa7df8" translate="yes" xml:space="preserve">
          <source>Internals - Reserved special namespace for internals related functions</source>
          <target state="translated">内部-内部関連関数のために予約された特別な名前空間</target>
        </trans-unit>
        <trans-unit id="f3272f534c54bc991446f61c8eb13e09347dc7ac" translate="yes" xml:space="preserve">
          <source>Internals and C Language Interface</source>
          <target state="translated">内部とC言語インタフェース</target>
        </trans-unit>
        <trans-unit id="221f3b6d81d4077e193de47fb71efa7ac821cbb0" translate="yes" xml:space="preserve">
          <source>International Organization for Standardization &lt;a href=&quot;http://www.iso.ch/&quot;&gt;http://www.iso.ch/&lt;/a&gt;</source>
          <target state="translated">国際標準化機構&lt;a href=&quot;http://www.iso.ch/&quot;&gt;http://www.iso.ch/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56e7980ec1f234461f5c5cc8a7f141d36197c7ac" translate="yes" xml:space="preserve">
          <source>Internationalisation</source>
          <target state="translated">Internationalisation</target>
        </trans-unit>
        <trans-unit id="8f2a515a6b360e659af1aa0a2bbe7a1464bcd610" translate="yes" xml:space="preserve">
          <source>Internationalization (I18N) and localization (L10N) are supported at least in principle even on EBCDIC platforms. The details are system-dependent and discussed under the &lt;a href=&quot;#OS-ISSUES&quot;&gt;&quot;OS ISSUES&quot;&lt;/a&gt; section below.</source>
          <target state="translated">国際化（I18N）とローカリゼーション（L10N）は、少なくとも原則としてEBCDICプラットフォームでもサポートされています。詳細はシステムに依存し、以下の&lt;a href=&quot;#OS-ISSUES&quot;&gt;「OSの問題」&lt;/a&gt;セクションで説明します。</target>
        </trans-unit>
        <trans-unit id="31cadca51461dbf1ea6607e7802c11fbe6ff93d3" translate="yes" xml:space="preserve">
          <source>Internationalization (I18N) and localization (L10N) are supported at least in principle even on EBCDIC platforms. The details are system-dependent and discussed under the &lt;a href=&quot;#OS-ISSUES&quot;&gt;OS ISSUES&lt;/a&gt; section below.</source>
          <target state="translated">国際化（I18N）とローカリゼーション（L10N）は、EBCDICプラットフォームでも少なくとも原則的にはサポートされます。詳細はシステムに依存し、以下の&lt;a href=&quot;#OS-ISSUES&quot;&gt;OSの問題&lt;/a&gt;セクションで説明します。</target>
        </trans-unit>
        <trans-unit id="06442c59ec9f24811c5d9eb359e2f21b42d4c792" translate="yes" xml:space="preserve">
          <source>Internationalization and Locale</source>
          <target state="translated">国際化とロケール</target>
        </trans-unit>
        <trans-unit id="46c7578271b4ab36db28528f49822a53c8afcb81" translate="yes" xml:space="preserve">
          <source>Internationalization, as defined in the C and POSIX standards, can be criticized as incomplete and ungainly. They also have a tendency, like standards groups, to divide the world into nations, when we all know that the world can equally well be divided into bankers, bikers, gamers, and so on.</source>
          <target state="translated">国際化は、CやPOSIX標準で定義されているように、不完全でおごりが悪いと批判されることがあります。また、標準化団体のように、世界を国に分けようとする傾向があります。</target>
        </trans-unit>
        <trans-unit id="f7421cfdcae4df82cd94a16e9b01d52930cf4a8c" translate="yes" xml:space="preserve">
          <source>Internationalization, as defined in the C and POSIX standards, can be criticized as incomplete, ungainly, and having too large a granularity. (Locales apply to a whole process, when it would arguably be more useful to have them apply to a single thread, window group, or whatever.) They also have a tendency, like standards groups, to divide the world into nations, when we all know that the world can equally well be divided into bankers, bikers, gamers, and so on.</source>
          <target state="translated">C や POSIX 標準で定義されている国際化は、不完全で、不必要で、粒度が大きすぎると批判されることがあります (ロケールはプロセス全体に適用されます。(ロケールはプロセス全体に適用されますが、単一のスレッドやウィンドウグループなどに適用させる方が議論の余地なく便利です)。また、ロケールは標準グループのように、世界を国に分ける傾向がありますが、世界は銀行員、バイカー、ゲーマーなどにも同じように分けられることがわかっています。</target>
        </trans-unit>
        <trans-unit id="c150f55df149b9e7642e03589abcd3eb462548e7" translate="yes" xml:space="preserve">
          <source>Internet Assigned Numbers Authority &lt;a href=&quot;http://www.iana.org/&quot;&gt;http://www.iana.org/&lt;/a&gt;</source>
          <target state="translated">Internet Assigned Numbers Authority &lt;a href=&quot;http://www.iana.org/&quot;&gt;http://www.iana.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2e18cc52391003fa5303fbdac90ff76add1db9f3" translate="yes" xml:space="preserve">
          <source>Internet Line Terminators</source>
          <target state="translated">インターネット回線ターミネーター</target>
        </trans-unit>
        <trans-unit id="1ace89f6b9c54bf536f959a6a92a52a0f9188777" translate="yes" xml:space="preserve">
          <source>Internet Protocol, or Intellectual Property.</source>
          <target state="translated">インターネットプロトコル、または知的財産。</target>
        </trans-unit>
        <trans-unit id="6aafd8134caf0f288faa302a3a8189c60711fc0c" translate="yes" xml:space="preserve">
          <source>Internet TCP Clients and Servers</source>
          <target state="translated">インターネットTCPクライアントとサーバー</target>
        </trans-unit>
        <trans-unit id="f4a9147272ff83f2cf2d940d5441a60e554132ae" translate="yes" xml:space="preserve">
          <source>Internet language tags, as defined in RFC 3066, are a formalism for denoting human languages. The two-letter ISO 639-1 language codes are well known (as &quot;en&quot; for English), as are their forms when qualified by a country code (&quot;en-US&quot;). Less well-known are the arbitrary-length non-ISO codes (like &quot;i-mingo&quot;), and the recently (in 2001) introduced three-letter ISO-639-2 codes.</source>
          <target state="translated">インターネット言語タグは、RFC 3066で定義されているように、人間の言語を表現するための形式主義です。2文字のISO 639-1言語コードはよく知られています(英語では &quot;en &quot;のように)。あまり知られていませんが、任意の長さの非ISOコード(&quot;i-mingo &quot;のようなもの)や、最近(2001年に)導入された3文字のISO-639-2コードがあります。</target>
        </trans-unit>
        <trans-unit id="d1f27df0b0f458a0b4241c741d83baaaba6cee55" translate="yes" xml:space="preserve">
          <source>Interoperating with Pbzip2</source>
          <target state="translated">Pbzip2との相互動作</target>
        </trans-unit>
        <trans-unit id="645bb0cb3effc0c464d1fa2ee02c7473d9c16ab6" translate="yes" xml:space="preserve">
          <source>Interpolated scalars and arrays are converted internally to the &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&quot;.&quot;&lt;/code&gt; catenation operations. Thus, &lt;code&gt;&quot;$foo XXX '@arr'&quot;&lt;/code&gt; becomes:</source>
          <target state="translated">補間されたスカラーと配列は、内部的に &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&quot;.&quot;&lt;/code&gt; 変換されます。カテネーション操作。したがって、 &lt;code&gt;&quot;$foo XXX '@arr'&quot;&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="7b7796550c9a05d4af98c0f9b17a2e334cf3e552" translate="yes" xml:space="preserve">
          <source>Interpolated scalars and arrays are converted internally to the &lt;code&gt;join&lt;/code&gt; and &lt;code&gt;&quot;.&quot;&lt;/code&gt; catenation operations. Thus, &lt;code&gt;&quot;$foo XXX '@arr'&quot;&lt;/code&gt; becomes:</source>
          <target state="translated">補間されたスカラーと配列は、内部で &lt;code&gt;join&lt;/code&gt; と &lt;code&gt;&quot;.&quot;&lt;/code&gt; 変換されます。カテネーション操作。したがって、 &lt;code&gt;&quot;$foo XXX '@arr'&quot;&lt;/code&gt; は次のようになります。</target>
        </trans-unit>
        <trans-unit id="1fc8312ce8a1d5c2a7ed5ed38a0c5c565ab477c8" translate="yes" xml:space="preserve">
          <source>Interpolating an array or slice interpolates the elements in order, separated by the value of &lt;code&gt;$&quot;&lt;/code&gt; , so is equivalent to interpolating &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; $&quot;, @array&lt;/code&gt; . &quot;Punctuation&quot; arrays such as &lt;code&gt;@*&lt;/code&gt; are usually interpolated only if the name is enclosed in braces &lt;code&gt;@{*}&lt;/code&gt;, but the arrays &lt;code&gt;@_&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; , and &lt;code&gt;@-&lt;/code&gt; are interpolated even without braces.</source>
          <target state="translated">配列またはスライスの補間は、 &lt;code&gt;$&quot;&lt;/code&gt; の値で区切られた順序で要素を補間するため、 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; $&quot;, @array&lt;/code&gt; 補間と同等です。例えば、「句読点」配列 &lt;code&gt;@*&lt;/code&gt; 名前が括弧で囲まれている場合にのみ、通常、補間される &lt;code&gt;@{*}&lt;/code&gt; が、配列 &lt;code&gt;@_&lt;/code&gt; 、 &lt;code&gt;@+&lt;/code&gt; 、および &lt;code&gt;@-&lt;/code&gt; さえ括弧なしに補間されます。</target>
        </trans-unit>
        <trans-unit id="c89b1d270440efce1fe96c18e4bb21c6ce7e1f28" translate="yes" xml:space="preserve">
          <source>Interpolating an array or slice interpolates the elements in order, separated by the value of &lt;code&gt;$&quot;&lt;/code&gt;, so is equivalent to interpolating &lt;code&gt;join $&quot;, @array&lt;/code&gt;. &quot;Punctuation&quot; arrays such as &lt;code&gt;@*&lt;/code&gt; are usually interpolated only if the name is enclosed in braces &lt;code&gt;@{*}&lt;/code&gt;, but the arrays &lt;code&gt;@_&lt;/code&gt;, &lt;code&gt;@+&lt;/code&gt;, and &lt;code&gt;@-&lt;/code&gt; are interpolated even without braces.</source>
          <target state="translated">配列またはスライスを補間すると、要素が &lt;code&gt;$&quot;&lt;/code&gt; の値で区切られて順番に補間されるため、 &lt;code&gt;join $&quot;, @array&lt;/code&gt; を補間するのと同じです。例えば、「句読点」配列 &lt;code&gt;@*&lt;/code&gt; 名前が括弧で囲まれている場合にのみ、通常、補間される &lt;code&gt;@{*}&lt;/code&gt; が、配列 &lt;code&gt;@_&lt;/code&gt; 、 &lt;code&gt;@+&lt;/code&gt; 、および &lt;code&gt;@-&lt;/code&gt; さえ括弧なしに補間されます。</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="938c8acd8c9d50a2d8734d4eebce781a661d4c88" translate="yes" xml:space="preserve">
          <source>Interpolation in patterns has several quirks: &lt;code&gt;$|&lt;/code&gt; , &lt;code&gt;$(&lt;/code&gt; , &lt;code&gt;$)&lt;/code&gt; , &lt;code&gt;@+&lt;/code&gt; and &lt;code&gt;@-&lt;/code&gt; are not interpolated, and constructs &lt;code&gt;$var[SOMETHING]&lt;/code&gt; are voted (by several different estimators) to be either an array element or &lt;code&gt;$var&lt;/code&gt; followed by an RE alternative. This is where the notation &lt;code&gt;${arr[$bar]}&lt;/code&gt; comes handy: &lt;code&gt;/${arr[0-9]}/&lt;/code&gt; is interpreted as array element &lt;code&gt;-9&lt;/code&gt; , not as a regular expression from the variable &lt;code&gt;$arr&lt;/code&gt; followed by a digit, which would be the interpretation of &lt;code&gt;/$arr[0-9]/&lt;/code&gt; . Since voting among different estimators may occur, the result is not predictable.</source>
          <target state="translated">パターンの補間にはいくつかの癖があります： &lt;code&gt;$|&lt;/code&gt; 、 &lt;code&gt;$(&lt;/code&gt; 、 &lt;code&gt;$)&lt;/code&gt; 、 &lt;code&gt;@+&lt;/code&gt; および &lt;code&gt;@-&lt;/code&gt; は補間されず、構成 &lt;code&gt;$var[SOMETHING]&lt;/code&gt; は（いくつかの異なる推定量によって）配列要素または &lt;code&gt;$var&lt;/code&gt; 後にRE代替が続くものとして投票されます。ここで、表記 &lt;code&gt;${arr[$bar]}&lt;/code&gt; が便利です： &lt;code&gt;/${arr[0-9]}/&lt;/code&gt; は、変数 &lt;code&gt;$arr&lt;/code&gt; 後に数字が続く正規表現としてではなく、配列要素 &lt;code&gt;-9&lt;/code&gt; として解釈されます。 &lt;code&gt;/$arr[0-9]/&lt;/code&gt; の解釈になります。異なる推定者の間で投票が行われる可能性があるため、結果は予測できません。</target>
        </trans-unit>
        <trans-unit id="39ed28583e84f6b41afb2ccf6f513cf965009d02" translate="yes" xml:space="preserve">
          <source>Interpolation in patterns has several quirks: &lt;code&gt;$|&lt;/code&gt;, &lt;code&gt;$(&lt;/code&gt;, &lt;code&gt;$)&lt;/code&gt;, &lt;code&gt;@+&lt;/code&gt; and &lt;code&gt;@-&lt;/code&gt; are not interpolated, and constructs &lt;code&gt;$var[SOMETHING]&lt;/code&gt; are voted (by several different estimators) to be either an array element or &lt;code&gt;$var&lt;/code&gt; followed by an RE alternative. This is where the notation &lt;code&gt;${arr[$bar]}&lt;/code&gt; comes handy: &lt;code&gt;/${arr[0-9]}/&lt;/code&gt; is interpreted as array element &lt;code&gt;-9&lt;/code&gt;, not as a regular expression from the variable &lt;code&gt;$arr&lt;/code&gt; followed by a digit, which would be the interpretation of &lt;code&gt;/$arr[0-9]/&lt;/code&gt;. Since voting among different estimators may occur, the result is not predictable.</source>
          <target state="translated">パターンの補間にはいくつかの癖があります： &lt;code&gt;$|&lt;/code&gt; 、 &lt;code&gt;$(&lt;/code&gt; 、 &lt;code&gt;$)&lt;/code&gt; 、 &lt;code&gt;@+&lt;/code&gt; 、および &lt;code&gt;@-&lt;/code&gt; は補間されず、構成 &lt;code&gt;$var[SOMETHING]&lt;/code&gt; は（いくつかの異なる推定量によって）配列要素または &lt;code&gt;$var&lt;/code&gt; 後にREの代替として投票されます。ここで、表記 &lt;code&gt;${arr[$bar]}&lt;/code&gt; が便利です &lt;code&gt;/${arr[0-9]}/&lt;/code&gt; は、変数 &lt;code&gt;$arr&lt;/code&gt; 後に数字が続く正規表現としてではなく、配列要素 &lt;code&gt;-9&lt;/code&gt; として解釈されます。これは &lt;code&gt;/$arr[0-9]/&lt;/code&gt; の解釈になります。異なる推定量の間で投票が行われる可能性があるため、結果は予測できません。</target>
        </trans-unit>
        <trans-unit id="73b1ed4106cc19f9516b8700eff6b51f8a50bc7e" translate="yes" xml:space="preserve">
          <source>Interpret input as a hexadecimal string. A &quot;0x&quot; or &quot;x&quot; prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">入力を 16 進文字列として解釈します。0x」または「x」の接頭辞はオプションです。プレフィックスの直後、または任意の2桁の間にアンダースコア文字を1文字入れることができる。入力が無効な場合、NaN が返される。</target>
        </trans-unit>
        <trans-unit id="e3c6ad2b94e17e8ed6ad8c9f4b49132292140f2b" translate="yes" xml:space="preserve">
          <source>Interpret input as a hexadecimal string. A prefix (&quot;0b&quot; or &quot;b&quot;, ignoring case) is optional. A single underscore character (&quot;_&quot;) may be placed between any two digits. If the input is invalid, a NaN is returned. The exponent is in base 2 using decimal digits.</source>
          <target state="translated">入力を16進数の文字列として解釈します。接頭辞 (&quot;0b&quot; または &quot;b&quot;,大文字小文字は無視)はオプションです。任意の2桁の間にアンダースコア文字(&quot;_&quot;)を1つ入れることができます。入力が無効な場合は NaN が返されます。指数は10進数を使用して2進数になります。</target>
        </trans-unit>
        <trans-unit id="00ae7a8b8abddae828432695e232afb3455b5e34" translate="yes" xml:space="preserve">
          <source>Interpret input as a hexadecimal string.A prefix (&quot;0x&quot;, &quot;x&quot;, ignoring case) is optional. A single underscore character (&quot;_&quot;) may be placed between any two digits. If the input is invalid, a NaN is returned. The exponent is in base 2 using decimal digits.</source>
          <target state="translated">入力を 16 進文字列として解釈します。 接頭辞 (&quot;0x&quot;,&quot;x&quot;,大文字小文字を無視)はオプションです。任意の2桁の間にアンダースコア文字(&quot;_&quot;)を1つ入れることができます。入力が無効な場合は NaN が返されます。指数は10進数を使用してベース2で表されます。</target>
        </trans-unit>
        <trans-unit id="72044a388d08d12a68e1993790c0be63bb048467" translate="yes" xml:space="preserve">
          <source>Interpret input as an octal string. A single underscore character (&quot;_&quot;) may be placed between any two digits. If the input is invalid, a NaN is returned. The exponent is in base 2 using decimal digits.</source>
          <target state="translated">入力を8進数文字列として解釈します。任意の2桁の間にアンダースコア文字(&quot;_&quot;)を1つ入れることができます。入力が無効な場合は、NaNが返されます。指数は10進数を使用して2進数になります。</target>
        </trans-unit>
        <trans-unit id="70a91bb371c7a5d73707f3bf850be5ff775864c2" translate="yes" xml:space="preserve">
          <source>Interpret results strictly.</source>
          <target state="translated">結果を厳密に解釈する。</target>
        </trans-unit>
        <trans-unit id="7bc19d89b05f97e1ecec77b1cd80333965f8eac8" translate="yes" xml:space="preserve">
          <source>Interpret the input as a binary string. A &quot;0b&quot; or &quot;b&quot; prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">入力をバイナリ文字列として解釈します。0b」または「b」の接頭辞はオプションである。プレフィックスの直後、または任意の2桁の間にアンダースコア文字を1文字入れることができる。入力が無効な場合、NaN が返される。</target>
        </trans-unit>
        <trans-unit id="d76880ffa69808c7f715164c615fdf27a78c1785" translate="yes" xml:space="preserve">
          <source>Interpret the input as a byte string, assuming big endian byte order. The output is always a non-negative, finite integer.</source>
          <target state="translated">入力をバイト文字列として解釈します。出力は常に非負の有限整数です。</target>
        </trans-unit>
        <trans-unit id="453c8b8b13743efe964db57b55ed8957df8eedf7" translate="yes" xml:space="preserve">
          <source>Interpret the input as a value encoded as described in IEEE754-2008. The input can be given as a byte string, hex string or binary string. The input is assumed to be in big-endian byte-order.</source>
          <target state="translated">入力を IEEE754-2008 に記述されているようにエンコードされた値として解釈する。入力は、バイト文字列、16 進文字列、またはバイナリ文字列として与えられる。入力はビッグエンディアンのバイト順であると仮定される。</target>
        </trans-unit>
        <trans-unit id="0fb708839bb76c97a78f59fb0d153db3bcac65ad" translate="yes" xml:space="preserve">
          <source>Interpret the input as an octal string and return the corresponding value. A &quot;0&quot; (zero) prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</source>
          <target state="translated">入力を8進数の文字列として解釈し、対応する値を返します。0&quot; (ゼロ)接頭辞はオプションです。アンダースコア文字がある場合は、接頭辞の直後、または任意の2桁の間に1つのアンダースコア文字を入れることができます。入力が無効な場合は、NaNが返されます。</target>
        </trans-unit>
        <trans-unit id="b29af10220daeb6f80d20ec4774b2643643e00f8" translate="yes" xml:space="preserve">
          <source>Interpretation of the &lt;code&gt;gecos&lt;/code&gt; field varies between systems, but traditionally holds 4 comma-separated fields containing the user's full name, office location, work phone number, and home phone number. An &lt;code&gt;&amp;amp;&lt;/code&gt; in the gecos field should be replaced by the user's properly capitalized login &lt;code&gt;name&lt;/code&gt; . The &lt;code&gt;shell&lt;/code&gt; field, if blank, must be assumed to be</source>
          <target state="translated">&lt;code&gt;gecos&lt;/code&gt; フィールドの解釈はシステムによって異なりますが、従来は、ユーザーのフルネーム、オフィスの場所、勤務先の電話番号、自宅の電話番号を含む4つのコンマ区切りフィールドを保持しています。gecosフィールドの &lt;code&gt;&amp;amp;&lt;/code&gt; は、ユーザーの適切に大文字で書かれたログイン &lt;code&gt;name&lt;/code&gt; 置き換えてください。 &lt;code&gt;shell&lt;/code&gt; フィールドは、空白の場合、であると仮定しなければなりません</target>
        </trans-unit>
        <trans-unit id="0976c6eb851bd29a7c13436a47fce586e64022a2" translate="yes" xml:space="preserve">
          <source>Interpretation of the &lt;code&gt;gecos&lt;/code&gt; field varies between systems, but traditionally holds 4 comma-separated fields containing the user's full name, office location, work phone number, and home phone number. An &lt;code&gt;&amp;amp;&lt;/code&gt; in the gecos field should be replaced by the user's properly capitalized login &lt;code&gt;name&lt;/code&gt;. The &lt;code&gt;shell&lt;/code&gt; field, if blank, must be assumed to be</source>
          <target state="translated">&lt;code&gt;gecos&lt;/code&gt; フィールドの解釈はシステムによって異なりますが、従来は、ユーザーのフルネーム、オフィスの場所、勤務先の電話番号、自宅の電話番号を含む4つのコンマ区切りのフィールドがあります。gecosフィールドの &lt;code&gt;&amp;amp;&lt;/code&gt; は、ユーザーの適切に大文字のログイン &lt;code&gt;name&lt;/code&gt; 置き換える必要があります。 &lt;code&gt;shell&lt;/code&gt; フィールドは、空白の場合、であると仮定しなければなりません</target>
        </trans-unit>
        <trans-unit id="920aa278d5fde4bc26b94a177b294481884c28c0" translate="yes" xml:space="preserve">
          <source>Interpretation of the buffer's octets can be abstracted out by using the slightly higher-level functions &lt;a href=&quot;#lex_peek_unichar&quot;&gt;&quot;lex_peek_unichar&quot;&lt;/a&gt; and &lt;a href=&quot;#lex_read_unichar&quot;&gt;&quot;lex_read_unichar&quot;&lt;/a&gt;.</source>
          <target state="translated">バッファのオクテットの解釈は、少し高レベルの関数&lt;a href=&quot;#lex_peek_unichar&quot;&gt;「lex_peek_unichar」&lt;/a&gt;および&lt;a href=&quot;#lex_read_unichar&quot;&gt;「lex_read_unichar」&lt;/a&gt;を使用して抽象化できます。</target>
        </trans-unit>
        <trans-unit id="f5cfbb6233c7812b488cce8d6bd3af2af9ab5bc6" translate="yes" xml:space="preserve">
          <source>Interpretation of the buffer's octets can be abstracted out by using the slightly higher-level functions &lt;a href=&quot;#lex_peek_unichar&quot;&gt;lex_peek_unichar&lt;/a&gt; and &lt;a href=&quot;#lex_read_unichar&quot;&gt;lex_read_unichar&lt;/a&gt;.</source>
          <target state="translated">バッファのオクテットの解釈は、少しレベルの高い関数&lt;a href=&quot;#lex_peek_unichar&quot;&gt;lex_peek_unichar&lt;/a&gt;と&lt;a href=&quot;#lex_read_unichar&quot;&gt;lex_read_unichar&lt;/a&gt;を使用して抽象化できます。</target>
        </trans-unit>
        <trans-unit id="92d3f8b03230be860eb13ba99ed5e322ec25a6b0" translate="yes" xml:space="preserve">
          <source>Interpreter</source>
          <target state="translated">Interpreter</target>
        </trans-unit>
        <trans-unit id="b588c5a0249a1b98f3880c0e5147ba7d315538dd" translate="yes" xml:space="preserve">
          <source>Interpreter embedded in larger application</source>
          <target state="translated">より大きなアプリケーションに組み込まれたインタープリタ</target>
        </trans-unit>
        <trans-unit id="74e94340be7381aa50cefb2bdc5e7587b72758de" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as a hex string and returns the corresponding numeric value. If EXPR is omitted, uses &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">EXPRを16進文字列として解釈し、対応する数値を返します。EXPRを省略した場合は、&lt;a href=&quot;perlvar#%24_&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="c4c7c558d92a61d6a4e1c001e4a147b288928483" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as a hex string and returns the corresponding value. (To convert strings that might start with either &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; , or &lt;code&gt;0b&lt;/code&gt;, see &lt;a href=&quot;#oct&quot;&gt;oct&lt;/a&gt;.) If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPRを16進文字列として解釈し、対応する値を返します。（いずれかで始まる文字列に変換するには &lt;code&gt;0&lt;/code&gt; 、 &lt;code&gt;0x&lt;/code&gt; 、または &lt;code&gt;0b&lt;/code&gt; 、参照&lt;a href=&quot;#oct&quot;&gt;octの&lt;/a&gt;。）EXPRを省略すると、使用しています &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80995a80c008a9c2a1eb866370afb34599cdd244" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as a hex string and returns the corresponding value. (To convert strings that might start with either &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;0x&lt;/code&gt; , or &lt;code&gt;0b&lt;/code&gt;, see &lt;a href=&quot;oct&quot;&gt;oct&lt;/a&gt;.) If EXPR is omitted, uses &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">EXPRを16進文字列として解釈し、対応する値を返します。（いずれかで始まる文字列に変換するには &lt;code&gt;0&lt;/code&gt; 、 &lt;code&gt;0x&lt;/code&gt; 、または &lt;code&gt;0b&lt;/code&gt; 、参照&lt;a href=&quot;oct&quot;&gt;octの&lt;/a&gt;。）EXPRを省略すると、使用しています &lt;code&gt;$_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58710e925b06b5bcd617d0a02276a6d507de1826" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as an octal string and returns the corresponding value. (If EXPR happens to start off with &lt;code&gt;0x&lt;/code&gt; , interprets it as a hex string. If EXPR starts off with &lt;code&gt;0b&lt;/code&gt;, it is interpreted as a binary string. Leading whitespace is ignored in all three cases.) The following will handle decimal, binary, octal, and hex in standard Perl notation:</source>
          <target state="translated">EXPRを8進文字列として解釈し、対応する値を返します。（EXPRが &lt;code&gt;0x&lt;/code&gt; で始まる場合、16進文字列として解釈されます。EXPRが &lt;code&gt;0b&lt;/code&gt; で始まる場合、2進文字列として解釈されます。先頭の空白は、3つのケースすべてで無視されます。）以下は、10進、2進、 8進数、および標準のPerl表記の16進数：</target>
        </trans-unit>
        <trans-unit id="ae1424465a8d50534920bcc14b8cbe5ef86892ac" translate="yes" xml:space="preserve">
          <source>Interprets EXPR as an octal string and returns the corresponding value. (If EXPR happens to start off with &lt;code&gt;0x&lt;/code&gt;, interprets it as a hex string. If EXPR starts off with &lt;code&gt;0b&lt;/code&gt;, it is interpreted as a binary string. Leading whitespace is ignored in all three cases.) The following will handle decimal, binary, octal, and hex in standard Perl notation:</source>
          <target state="translated">EXPRを8進文字列として解釈し、対応する値を返します。（EXPRがたまたま &lt;code&gt;0x&lt;/code&gt; で始まる場合、16進文字列として解釈されます。EXPRが &lt;code&gt;0b&lt;/code&gt; で始まる場合、バイナリ文字列として解釈されます。先頭の空白は3つのケースすべてで無視されます。）以下は、10進数、2進数、標準のPerl表記の8進数、および16進数：</target>
        </trans-unit>
        <trans-unit id="92d683f7db5d587ede8e14b4d88e6c417a5847d7" translate="yes" xml:space="preserve">
          <source>Interprocess Communication (IPC)</source>
          <target state="translated">プロセス間通信(IPC)</target>
        </trans-unit>
        <trans-unit id="1e11457cea032ab0c21c71c69e4211f081e8849e" translate="yes" xml:space="preserve">
          <source>Interprocess Communication.</source>
          <target state="translated">プロセス間通信。</target>
        </trans-unit>
        <trans-unit id="a5a495c9d0578a0494f49fc6ace5fd6e9fed4e9a" translate="yes" xml:space="preserve">
          <source>Interrupting IO</source>
          <target state="translated">IOの中断</target>
        </trans-unit>
        <trans-unit id="58447a233c711f903a2587b91bb291042f4b45da" translate="yes" xml:space="preserve">
          <source>Intersection is used generally for getting the common characters matched by two (or more) classes. It's important to remember not to use &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; for the first set; that would be intersecting with nothing, resulting in an empty set.</source>
          <target state="translated">Intersectionは一般的に、2つ（またはそれ以上）のクラスで一致する共通の文字を取得するために使用されます。最初のセットに &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; を使用しないことを覚えておくことは重要です。それは何とも交差せず、空のセットになります。</target>
        </trans-unit>
        <trans-unit id="d34174297460fdd67bf61d2f8749421841769688" translate="yes" xml:space="preserve">
          <source>Intersection is used generally for getting the common characters matched by two (or more) classes. It's important to remember not to use &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; for the first set; that would be intersecting with nothing, resulting in an empty set. (Similarly using &lt;code&gt;&quot;-&quot;&lt;/code&gt; for the first set does nothing).</source>
          <target state="translated">交差は通常、2つ（またはそれ以上）のクラスに一致する一般的な文字を取得するために使用されます。最初のセットに &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; を使用しないことを覚えておくことが重要です。それは何とも交差せず、空のセットになります。（同様に、最初のセットに &lt;code&gt;&quot;-&quot;&lt;/code&gt; を使用しても何も起こりません）。</target>
        </trans-unit>
        <trans-unit id="c4724a76d8bc17dfefb1daee3b6d5be588f4c613" translate="yes" xml:space="preserve">
          <source>Introduce the</source>
          <target state="translated">を紹介します。</target>
        </trans-unit>
        <trans-unit id="dde62d185b627cf5b7ce046a41566f84e22267ed" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.005</source>
          <target state="translated">Perl 5.005 で導入</target>
        </trans-unit>
        <trans-unit id="25641bc26420a80c8ddbcf38615ca35ce5d7cb63" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.10.0</source>
          <target state="translated">Perl 5.10.0 で導入</target>
        </trans-unit>
        <trans-unit id="b91aad730399f200ac6a5b6dba6fed9c61c025f5" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.12</source>
          <target state="translated">Perl 5.12 で導入</target>
        </trans-unit>
        <trans-unit id="be57168adcd5cd07b75f1c9b6124df0daf76c3bd" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.14.0</source>
          <target state="translated">Perl 5.14.0 で導入</target>
        </trans-unit>
        <trans-unit id="b294ac0a4f8c5992774c8112441dc302d5816a1f" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.20.0</source>
          <target state="translated">Perl 5.20.0 で導入</target>
        </trans-unit>
        <trans-unit id="0c3a6017cbcf96eeafb4387eedc602152339297c" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.22.0</source>
          <target state="translated">Perl 5.22.0 で導入</target>
        </trans-unit>
        <trans-unit id="7993785cfbc9e7981dcd229895be4a20fdb9620c" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.6.0</source>
          <target state="translated">Perl 5.6.0 で導入</target>
        </trans-unit>
        <trans-unit id="31cd408fa26c1acb52eade6304b9c5ef7d3abe35" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.6.1</source>
          <target state="translated">Perl 5.6.1 で導入</target>
        </trans-unit>
        <trans-unit id="51378bbd1f0bc4027eee05ffb1e7f6b0f83420b0" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.8.0</source>
          <target state="translated">Perl 5.8.0 で導入</target>
        </trans-unit>
        <trans-unit id="79667c9718432940922f2e42f6facd3cdd4d3deb" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.9.0</source>
          <target state="translated">Perl 5.9.0 で導入</target>
        </trans-unit>
        <trans-unit id="bb8c7b3973c6116a9525785ab93801f9d4d4fd02" translate="yes" xml:space="preserve">
          <source>Introduced in Perl 5.9.2</source>
          <target state="translated">Perl 5.9.2 で導入</target>
        </trans-unit>
        <trans-unit id="091f1001c9d6a40187930fa44574a4f653880f2a" translate="yes" xml:space="preserve">
          <source>Introduced in perl 5.25.12.</source>
          <target state="translated">perl 5.25.12 で導入されました。</target>
        </trans-unit>
        <trans-unit id="7ef8951301d241cbc829612e64580020e610d91f" translate="yes" xml:space="preserve">
          <source>Introduced in: 5.11.2</source>
          <target state="translated">で導入されました。5.11.2</target>
        </trans-unit>
        <trans-unit id="a01d17d00de94eaa77554eca767e361f42130168" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.10</source>
          <target state="translated">で導入されました。Perl 5.10</target>
        </trans-unit>
        <trans-unit id="1e5c7e1205af583a405c6c00903c26fad40a5e6a" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.11.2</source>
          <target state="translated">で導入されました。Perl 5.11.2</target>
        </trans-unit>
        <trans-unit id="d272e647109f1769e2b49a3e24be3094dd708435" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.18</source>
          <target state="translated">導入されました。Perl 5.18</target>
        </trans-unit>
        <trans-unit id="a5210098032cc4bc65f6c8263851cc2d7666b61d" translate="yes" xml:space="preserve">
          <source>Introduced in: Perl 5.22.0</source>
          <target state="translated">で導入されました。Perl 5.22.0</target>
        </trans-unit>
        <trans-unit id="5a3a1683287083d64acee02ab986003bcf802274" translate="yes" xml:space="preserve">
          <source>Introduced just after perl5.7.0, this is a re-implementation of the above abstraction which allows perl more control over how IO is done as it decouples IO from the way the operating system and C library choose to do things. For USE_PERLIO PerlIO * has an extra layer of indirection - it is a pointer-to-a-pointer. This allows the PerlIO * to remain with a known value while swapping the implementation around underneath</source>
          <target state="translated">perl5.7.0の直後に導入されましたが、これは上記の抽象化を再実装したもので、IOをオペレーティングシステムやCライブラリの選択した方法から切り離し、IOがどのように行われるかをperlがより制御できるようにしています。USE_PERLIOのために、PerlIO *にはポインタからポインタへの追加の層があります。これにより、PerlIO*は既知の値を保持したまま、下の実装をスワップすることができます。</target>
        </trans-unit>
        <trans-unit id="bc2d2fa71d8eaea749023a72cddaf418fe1cb149" translate="yes" xml:space="preserve">
          <source>Introduces a catch block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;&quot;Exception Handling&quot; in perlguts&lt;/a&gt;.</source>
          <target state="translated">キャッチブロックを導入します。&lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;perlgutsの「例外処理」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="df90fec901ab6b3e3c92b7090f061ccf2d6c4aa2" translate="yes" xml:space="preserve">
          <source>Introduces a catch block. See &lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;Exception Handling in perlguts&lt;/a&gt;.</source>
          <target state="translated">catchブロックを導入します。&lt;a href=&quot;perlguts#Exception-Handling&quot;&gt;perlgutsでの例外処理を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c0c2f1d96cf5d9698341444cc5bc1eb344088014" translate="yes" xml:space="preserve">
          <source>Introducing (non-read-only) globals</source>
          <target state="translated">(読み取り専用ではない)グローバルの導入</target>
        </trans-unit>
        <trans-unit id="154cc0bb0700575719a65b65f0bfb0fc9a438358" translate="yes" xml:space="preserve">
          <source>Introducing read-only (const) globals is okay, as long as you verify with e.g. &lt;code&gt;nm libperl.a|egrep -v ' [TURtr] '&lt;/code&gt; (if your &lt;code&gt;nm&lt;/code&gt; has BSD-style output) that the data you added really is read-only. (If it is, it shouldn't show up in the output of that command.)</source>
          <target state="translated">読み取り専用（const）グローバルの導入は、たとえば &lt;code&gt;nm libperl.a|egrep -v ' [TURtr] '&lt;/code&gt; （ &lt;code&gt;nm&lt;/code&gt; にBSDスタイルの出力がある場合）を使用して、追加したデータが実際に読み取られていることを確認する限り、問題ありません。のみ。（そうであれば、そのコマンドの出力には表示されません。）</target>
        </trans-unit>
        <trans-unit id="dcba11e20d56606a737ad2a86071e282fcf184cf" translate="yes" xml:space="preserve">
          <source>Introducing variables inside for()</source>
          <target state="translated">for()の中に変数を導入する</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="c3cbe25b5093a9e955ec87889df443c3c88a6700" translate="yes" xml:space="preserve">
          <source>Introduction to the context stack</source>
          <target state="translated">コンテキストスタックの紹介</target>
        </trans-unit>
        <trans-unit id="cad0875833b290c88f0275f52c45f410d897ca9f" translate="yes" xml:space="preserve">
          <source>Introductory Texts</source>
          <target state="translated">入門テキスト</target>
        </trans-unit>
        <trans-unit id="35b4535865312e74cc4ee5fddabecf0f89eff7b1" translate="yes" xml:space="preserve">
          <source>Invalid %s attribute: %s</source>
          <target state="translated">無効な %s 属性:%s</target>
        </trans-unit>
        <trans-unit id="f16e49525bf4e99622a920415ffb99daaab7bb8c" translate="yes" xml:space="preserve">
          <source>Invalid %s attributes: %s</source>
          <target state="translated">無効な %s 属性:%s</target>
        </trans-unit>
        <trans-unit id="f278621344da2113b386e7cf493f5b7effda7cb6" translate="yes" xml:space="preserve">
          <source>Invalid =encoding syntax:</source>
          <target state="translated">無効な=エンコード構文です。</target>
        </trans-unit>
        <trans-unit id="92ccfdff90507fec490f3681db3843b0d6286ad3" translate="yes" xml:space="preserve">
          <source>Invalid [] range &quot;%s&quot; in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正規表現の[]範囲 &quot;％s&quot;が無効です。&amp;lt;-ここにm /％s /でマーク</target>
        </trans-unit>
        <trans-unit id="82ca1b8b000c05ddca3141e99f4a127d6bf62783" translate="yes" xml:space="preserve">
          <source>Invalid \0 character in %s for %s: %s\0%s</source>
          <target state="translated">Invalid \0 character in %s for %s:%s0%s</target>
        </trans-unit>
        <trans-unit id="d5167b1a82e18cf454d4bc0f759f3a654b3597c1" translate="yes" xml:space="preserve">
          <source>Invalid alias name %s</source>
          <target state="translated">無効なエイリアス名 %s。</target>
        </trans-unit>
        <trans-unit id="de2a343ef8d4bd75601d86b329b7a01d8c329447" translate="yes" xml:space="preserve">
          <source>Invalid alias name %s in %s</source>
          <target state="translated">無効なエイリアス名 %s が %s にあります。</target>
        </trans-unit>
        <trans-unit id="b8ab829daff8a5e5f6392ceed1cb4afa7bad1191" translate="yes" xml:space="preserve">
          <source>Invalid attribute name %s</source>
          <target state="translated">無効な属性名 %s</target>
        </trans-unit>
        <trans-unit id="6de5bc9920e09cfc5aa332c66ec4d5cfec265952" translate="yes" xml:space="preserve">
          <source>Invalid attribute name %s in %s</source>
          <target state="translated">%s の属性名 %s が無効です。</target>
        </trans-unit>
        <trans-unit id="05e151899283ad3fa0d3b17b289c6f5652fe00d4" translate="yes" xml:space="preserve">
          <source>Invalid character in \N{...}; marked by &amp;lt;-- HERE in \N{%s}</source>
          <target state="translated">\ N {...}の文字が無効です; &amp;lt;-ここで\ N {％s}でマーク</target>
        </trans-unit>
        <trans-unit id="2863c47889763b20775fa1947348a4c08ab6c002" translate="yes" xml:space="preserve">
          <source>Invalid character in charnames alias definition; marked by &amp;lt;-- HERE in '%s</source>
          <target state="translated">charnamesエイリアス定義の文字が無効です。&amp;lt;-ここで '％sでマーク</target>
        </trans-unit>
        <trans-unit id="d71b8ff5c88697d1a550d6673237e1107c606759" translate="yes" xml:space="preserve">
          <source>Invalid conversion in %s: &quot;%s&quot;</source>
          <target state="translated">s での変換が無効です。&quot;%s&quot;</target>
        </trans-unit>
        <trans-unit id="8da241ea775f4ffbb146ef9175cab747e1e17f61" translate="yes" xml:space="preserve">
          <source>Invalid errors setting &quot;%s&quot;</source>
          <target state="translated">&quot;%s&quot; の設定が無効なエラーです。</target>
        </trans-unit>
        <trans-unit id="e88ec4ba5b78e52ef0ab2ed660f408ead1951cbe" translate="yes" xml:space="preserve">
          <source>Invalid escape in the specified encoding in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正規表現で指定されたエンコーディングのエスケープが無効です。&amp;lt;-ここにm /％s /でマーク</target>
        </trans-unit>
        <trans-unit id="519c9635790d830978d5164b3ad7937b453ade67" translate="yes" xml:space="preserve">
          <source>Invalid hexadecimal number in \N{U+...}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe4e943158cfd55f7caa089383100312254493ec" translate="yes" xml:space="preserve">
          <source>Invalid hexadecimal number in \N{U+...} in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正規表現の\ N {U + ...}の16進数が無効です。&amp;lt;-ここにm /％s /でマーク</target>
        </trans-unit>
        <trans-unit id="87131ca7be09c630d75c4fef49d87656455519cb" translate="yes" xml:space="preserve">
          <source>Invalid module name %s with -%c option: contains single ':'</source>
          <target state="translated">c オプションが無効なモジュール名 %s:シングル ':' を含んでいます。</target>
        </trans-unit>
        <trans-unit id="cafc147d5721e32ab438b2e1facd6104c69c8cdb" translate="yes" xml:space="preserve">
          <source>Invalid mro name: '%s'</source>
          <target state="translated">無効な mro 名:'%s' です。</target>
        </trans-unit>
        <trans-unit id="997bb1def2a65589fb34cef75e7877e3c194aa47" translate="yes" xml:space="preserve">
          <source>Invalid negative number (%s) in chr</source>
          <target state="translated">chr に無効な負の数 (%s)があります。</target>
        </trans-unit>
        <trans-unit id="23ebf8d124c561f25f30e95ab6d9cc2965fe72ff" translate="yes" xml:space="preserve">
          <source>Invalid number '%s' for -C option.</source>
          <target state="translated">C オプションには無効な数値 '%s' があります。</target>
        </trans-unit>
        <trans-unit id="06b24f046499eeb08ade4a703bdfb2ca0850444e" translate="yes" xml:space="preserve">
          <source>Invalid quantifier in {,} in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正規表現の{、}の数量詞が無効です。&amp;lt;-ここにm /％s /でマーク</target>
        </trans-unit>
        <trans-unit id="2c55ed435afff8d41b70ade097c0698032d0c012" translate="yes" xml:space="preserve">
          <source>Invalid quote specification &quot;%s&quot;</source>
          <target state="translated">無効な引用符指定「%s」です。</target>
        </trans-unit>
        <trans-unit id="ea5c174cc04f03d39141a30a0cfc0c41bc31bb3f" translate="yes" xml:space="preserve">
          <source>Invalid range &quot;%s&quot; in transliteration operator</source>
          <target state="translated">並進演算子での範囲 &quot;%s&quot; が無効です。</target>
        </trans-unit>
        <trans-unit id="d7bf96d82c63323749d7987b1d0a19d37b194c78" translate="yes" xml:space="preserve">
          <source>Invalid reference to group in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正規表現のグループへの参照が無効です。&amp;lt;-ここにm /％s /でマーク</target>
        </trans-unit>
        <trans-unit id="8b451f3135fd8389070687455f7342fb7a8b6308" translate="yes" xml:space="preserve">
          <source>Invalid separator character %s in PerlIO layer specification %s</source>
          <target state="translated">PerlIO レイヤ仕様 %s での無効なセパレータ文字 %s。</target>
        </trans-unit>
        <trans-unit id="d97ba0ffc9967cd5abf07936f7edcde4477f44be" translate="yes" xml:space="preserve">
          <source>Invalid separator character %s in attribute list</source>
          <target state="translated">属性リスト内の無効なセパレータ文字 %s。</target>
        </trans-unit>
        <trans-unit id="132cab989b11d24a0daa70576a5563553614029c" translate="yes" xml:space="preserve">
          <source>Invalid strict version format (%s)</source>
          <target state="translated">無効な厳密なバージョン形式 (%s)です。</target>
        </trans-unit>
        <trans-unit id="7ac063110370f25128c7648841d4d47e40ca1a6f" translate="yes" xml:space="preserve">
          <source>Invalid type '%s' in %s</source>
          <target state="translated">%s の無効な型 '%s' です。</target>
        </trans-unit>
        <trans-unit id="40fac60217e12bb0c9148c5e13124cc1ea622f52" translate="yes" xml:space="preserve">
          <source>Invalid version format (%s)</source>
          <target state="translated">無効なバージョン形式 (%s)</target>
        </trans-unit>
        <trans-unit id="50a2b722bc1d83834529dc472a04775d93256603" translate="yes" xml:space="preserve">
          <source>Invalid version object</source>
          <target state="translated">無効なバージョンオブジェクト</target>
        </trans-unit>
        <trans-unit id="a7111e9430dac55fd4a6c0b16ea2e92ba2187d8a" translate="yes" xml:space="preserve">
          <source>Invalidates method caching on any child classes of the given stash, so that they might notice the changes in this one.</source>
          <target state="translated">与えられたスタッシュの子クラスに対するメソッドのキャッシュを無効にします。</target>
        </trans-unit>
        <trans-unit id="6254374b19c61ff561460206a4f9194f4bcd1a52" translate="yes" xml:space="preserve">
          <source>Invalidates the method cache of any classes dependent on the given class. This is not normally necessary. The only known case where pure perl code can confuse the method cache is when you manually install a new constant subroutine by using a readonly scalar value, like the internals of &lt;a href=&quot;constant&quot;&gt;constant&lt;/a&gt; do. If you find another case, please report it so we can either fix it or document the exception here.</source>
          <target state="translated">指定されたクラスに依存するクラスのメソッドキャッシュを無効にします。これは通常必要ありません。純粋なperlコードがメソッドキャッシュを混乱させる可能性がある唯一の既知のケースは、&lt;a href=&quot;constant&quot;&gt;定数&lt;/a&gt;の内部のように、読み取り専用のスカラー値を使用して新しい定数サブルーチンを手動でインストールする場合です。別のケースを見つけた場合は、報告してください。修正するか、例外をここに記載します。</target>
        </trans-unit>
        <trans-unit id="c0df4881ff3f493d5106f68dbab35c513534aed4" translate="yes" xml:space="preserve">
          <source>Inventory management of installed modules</source>
          <target state="translated">インストールされたモジュールの在庫管理</target>
        </trans-unit>
        <trans-unit id="14c5c3735ce54ff56e113f2608fb558c2d638a18" translate="yes" xml:space="preserve">
          <source>Inversion lists are a compact way of specifying Unicode property-value definitions. The 0th item in the list is the lowest code point that has the property-value. The next item (item [1]) is the lowest code point beyond that one that does NOT have the property-value. And the next item beyond that ([2]) is the lowest code point beyond that one that does have the property-value, and so on. Put another way, each element in the list gives the beginning of a range that has the property-value (for even numbered elements), or doesn't have the property-value (for odd numbered elements). The name for this data structure stems from the fact that each element in the list toggles (or inverts) whether the corresponding range is or isn't on the list.</source>
          <target state="translated">反転リストは、Unicodeプロパティ値定義をコンパクトに指定する方法です。リ ス ト 内の 0 番目の項目は、 そのプ ロ パテ ィ 値を持つ最下位の コ ー ド 点です。次の項目 (項目 [1])は、 その項目を超えて、そのプロパティ値を持たない最下位のコード点です。そして、その先の次の項目([2])は、プロパティ値を持つその先の最も低いコードポイントであり、そのようにして、プロパティ値を持つその先の最も低いコードポイントである。別の言い方をすれば、リストの各要素は、プロパティ値を持つ範囲(偶数の要素の場合)、またはプロパティ値を持たない範囲(奇数の要素の場合)の始まりを与えます。このデータ構造の名前は、リストの各要素が、対応する範囲がリストにあるかどうかを切り替える(または反転する)ことに由来しています。</target>
        </trans-unit>
        <trans-unit id="65b853d505ac70a8422f3186ac06caa076307275" translate="yes" xml:space="preserve">
          <source>Inverting a character class which contains a multi-character sequence is illegal in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">複数文字のシーケンスを含む文字クラスを反転することは、正規表現では違法です。&amp;lt;-ここにm /％s /でマーク</target>
        </trans-unit>
        <trans-unit id="31204d44a5939448655207a55e393849306b131a" translate="yes" xml:space="preserve">
          <source>Investigate whether &lt;code&gt;POSIX::dup2&lt;/code&gt; upsets BSD's &lt;code&gt;kqueue&lt;/code&gt; watchers, and if so, consider what possible workarounds might be applied.</source>
          <target state="translated">&lt;code&gt;POSIX::dup2&lt;/code&gt; BSDの &lt;code&gt;kqueue&lt;/code&gt; ウォッチャーを混乱させるかどうかを調査し、混乱する場合は、どのような回避策が適用される可能性があるかを検討してください。</target>
        </trans-unit>
        <trans-unit id="d8e6379916ac816d709ea169dcdb0ea2c85538b2" translate="yes" xml:space="preserve">
          <source>Invocation requires the command to be executed or a coderef and optionally a hashref of options:</source>
          <target state="translated">呼び出しには、実行されるコマンド、または coderef とオプションでオプションのハッシュリフが必要です。</target>
        </trans-unit>
        <trans-unit id="9866e55ebd73eaa4dfd6d462e055f3a88a4fa2b2" translate="yes" xml:space="preserve">
          <source>Invoke a magic method (like FETCH).</source>
          <target state="translated">魔法のメソッド(FETCHのような)を呼び出します。</target>
        </trans-unit>
        <trans-unit id="729e0ead914d111524b46b874fed43976337fb94" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_comment&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_comment&lt;/code&gt; がtrueを返した場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="b6d3760550f46e7b28bbf7a09042b6769acf3c7e" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_plan&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_plan&lt;/code&gt; がtrueを返した場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="4d5c6b94ee048c918e4535240e958632aecb1a6d" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_test&lt;/code&gt; がtrueを返した場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="136fe5e37a3fd848b78d877c253e754a822cac52" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_unknown&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_unknown&lt;/code&gt; がtrueを返した場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="632983081cf348fad68b5fcc938bef7d785aa8ce" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_version&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_version&lt;/code&gt; がtrueを返した場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="dab118fbd97b5abfc5d3df38d7cc4bb27d7a5389" translate="yes" xml:space="preserve">
          <source>Invoked if &lt;code&gt;$result-&amp;gt;is_yaml&lt;/code&gt; returns true.</source>
          <target state="translated">&lt;code&gt;$result-&amp;gt;is_yaml&lt;/code&gt; がtrueを返した場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="ad610951e9b392fd2e2ceadbb198a63f8613f82d" translate="yes" xml:space="preserve">
          <source>Invoked when there are no more lines to be parsed. Since there is no accompanying &lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP::Parser::Result&lt;/a&gt; object the &lt;code&gt;TAP::Parser&lt;/code&gt; object is passed instead.</source>
          <target state="translated">解析する行がなくなったときに呼び出されます。付随する&lt;a href=&quot;TAP::Parser::Result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;オブジェクトがないため、代わりに &lt;code&gt;TAP::Parser&lt;/code&gt; オブジェクトが渡されます。</target>
        </trans-unit>
        <trans-unit id="b4fc12fcbbbf739e9ecf3604f9dbc469d9a9587a" translate="yes" xml:space="preserve">
          <source>Invoked when there are no more lines to be parsed. Since there is no accompanying &lt;a href=&quot;parser/result&quot;&gt;TAP::Parser::Result&lt;/a&gt; object the &lt;code&gt;TAP::Parser&lt;/code&gt; object is passed instead.</source>
          <target state="translated">解析する行がなくなると呼び出されます。付随する&lt;a href=&quot;parser/result&quot;&gt;TAP :: Parser :: Result&lt;/a&gt;オブジェクトがないため、代わりに &lt;code&gt;TAP::Parser&lt;/code&gt; オブジェクトが渡されます。</target>
        </trans-unit>
        <trans-unit id="430786511bff9aaafff5936e905ad653f2aebe92" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;mg_get&lt;/code&gt; on an SV if it has 'get' magic. For example, this will call &lt;code&gt;FETCH&lt;/code&gt; on a tied variable. This macro evaluates its argument more than once.</source>
          <target state="translated">「get」マジックがある場合、SVで &lt;code&gt;mg_get&lt;/code&gt; を呼び出します。たとえば、これはタイ変数で &lt;code&gt;FETCH&lt;/code&gt; を呼び出します。このマクロは、その引数を複数回評価します。</target>
        </trans-unit>
        <trans-unit id="63770cbaa11ab2ed8431af406f1283f32bff5b08" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;mg_set&lt;/code&gt; on an SV if it has 'set' magic. This is necessary after modifying a scalar, in case it is a magical variable like &lt;code&gt;$|&lt;/code&gt; or a tied variable (it calls &lt;code&gt;STORE&lt;/code&gt; ). This macro evaluates its argument more than once.</source>
          <target state="translated">「設定」マジックがある場合、SVで &lt;code&gt;mg_set&lt;/code&gt; を呼び出します。 &lt;code&gt;$|&lt;/code&gt; ような魔法の変数である場合、これはスカラーを変更した後に必要です。またはタイ変数（ &lt;code&gt;STORE&lt;/code&gt; を呼び出します）。このマクロは、その引数を複数回評価します。</target>
        </trans-unit>
        <trans-unit id="d8df026416b8e868f3c4d19bec4e4735f833a540" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;mg_set&lt;/code&gt; on an SV if it has 'set' magic. This is necessary after modifying a scalar, in case it is a magical variable like &lt;code&gt;$|&lt;/code&gt; or a tied variable (it calls &lt;code&gt;STORE&lt;/code&gt;). This macro evaluates its argument more than once.</source>
          <target state="translated">SVに「set」マジックがある場合、SVで &lt;code&gt;mg_set&lt;/code&gt; を呼び出します。これは、 &lt;code&gt;$|&lt;/code&gt; ような魔法の変数である場合、スカラーを変更した後に必要です。またはタイ変数（ &lt;code&gt;STORE&lt;/code&gt; を呼び出します）。このマクロは、引数を複数回評価します。</target>
        </trans-unit>
        <trans-unit id="6065fa2fda8beaeb12ea495b85a947dc1c32d666" translate="yes" xml:space="preserve">
          <source>Invokes VMS debugger. (VMS)</source>
          <target state="translated">VMS デバッガを起動します。(VMS)</target>
        </trans-unit>
        <trans-unit id="4a48ee301f0abac2cf4e91d0e45258fd858ca888" translate="yes" xml:space="preserve">
          <source>Invokes debugging mode. Primarily for Encode hackers.</source>
          <target state="translated">デバッグモードを起動します。主にEncodeハッカーのためのものです。</target>
        </trans-unit>
        <trans-unit id="24bad1e8c0ab13d7138af070e6f8fd5104a0af38" translate="yes" xml:space="preserve">
          <source>Invokes the linker to produce a library file from object files. In scalar context, the name of the library file is returned. In list context, the library file and any temporary files created are returned. A required &lt;code&gt;objects&lt;/code&gt; parameter contains the name of the object files to process, either in a string (for one object file) or list reference (for one or more files). The following parameters are optional:</source>
          <target state="translated">リンカーを呼び出して、オブジェクトファイルからライブラリファイルを生成します。スカラーコンテキストでは、ライブラリファイルの名前が返されます。リストコンテキストでは、ライブラリファイルと作成された一時ファイルが返されます。必須の &lt;code&gt;objects&lt;/code&gt; パラメータには、処理するオブジェクトファイルの名前が文字列（1つのオブジェクトファイルの場合）またはリスト参照（1つ以上のファイルの場合）で含まれています。以下のパラメーターはオプションです。</target>
        </trans-unit>
        <trans-unit id="d6dc74aaf36821077c0007a98c7212fc4b3fa1fa" translate="yes" xml:space="preserve">
          <source>Invokes the linker to produce an executable file from object files. In scalar context, the name of the executable file is returned. In list context, the executable file and any temporary files created are returned. A required &lt;code&gt;objects&lt;/code&gt; parameter contains the name of the object files to process, either in a string (for one object file) or list reference (for one or more files). The optional parameters are the same as &lt;code&gt;&lt;a href=&quot;../functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; with exception for</source>
          <target state="translated">リンカーを呼び出して、オブジェクトファイルから実行可能ファイルを生成します。スカラーコンテキストでは、実行可能ファイルの名前が返されます。リストコンテキストでは、実行可能ファイルと作成された一時ファイルが返されます。必須の &lt;code&gt;objects&lt;/code&gt; パラメータには、処理するオブジェクトファイルの名前が文字列（1つのオブジェクトファイルの場合）またはリスト参照（1つ以上のファイルの場合）で含まれています。オプションのパラメータは、以下を除いて &lt;code&gt;&lt;a href=&quot;../functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="79f933cf2af8919cd4f873f791c92f88082706ff" translate="yes" xml:space="preserve">
          <source>Invokes the linker to produce an executable file from object files. In scalar context, the name of the executable file is returned. In list context, the executable file and any temporary files created are returned. A required &lt;code&gt;objects&lt;/code&gt; parameter contains the name of the object files to process, either in a string (for one object file) or list reference (for one or more files). The optional parameters are the same as &lt;code&gt;link&lt;/code&gt; with exception for</source>
          <target state="translated">リンカを呼び出して、オブジェクトファイルから実行可能ファイルを生成します。スカラーコンテキストでは、実行可能ファイルの名前が返されます。リストコンテキストでは、実行可能ファイルと作成された一時ファイルが返されます。必須の &lt;code&gt;objects&lt;/code&gt; パラメーターには、処理するオブジェクトファイルの名前が文字列（1つのオブジェクトファイルの場合）またはリスト参照（1つ以上のファイルの場合）で含まれます。オプションのパラメータは、 &lt;code&gt;link&lt;/code&gt; と同じですが、</target>
        </trans-unit>
        <trans-unit id="b673c6a72896107ce4c1c1720830db2d7090b84b" translate="yes" xml:space="preserve">
          <source>Invoking</source>
          <target state="translated">Invoking</target>
        </trans-unit>
        <trans-unit id="96cd3dba8626073590cef0284f10ba68d27dc29f" translate="yes" xml:space="preserve">
          <source>Invoking C-style &lt;code&gt;open&lt;/code&gt;</source>
          <target state="translated">Cスタイルの &lt;code&gt;open&lt;/code&gt; を呼び出す</target>
        </trans-unit>
        <trans-unit id="ad7d6999362a94f744230122565df0fb30cec02f" translate="yes" xml:space="preserve">
          <source>Invoking Class Methods</source>
          <target state="translated">クラスメソッドの呼び出し</target>
        </trans-unit>
        <trans-unit id="36b849bf1b11efdfda1ba9f83f6937c3f5f3d9b5" translate="yes" xml:space="preserve">
          <source>Invoking Perl</source>
          <target state="translated">Perl の呼び出し</target>
        </trans-unit>
        <trans-unit id="d893e9caa1e5c938c432bca17fd828ff27fd449c" translate="yes" xml:space="preserve">
          <source>Invoking all versions of a method with a single call</source>
          <target state="translated">一度の呼び出しですべてのバージョンのメソッドを呼び出す</target>
        </trans-unit>
        <trans-unit id="24170ec2bba17eb099637b415016216327bba9b2" translate="yes" xml:space="preserve">
          <source>Invoking the test script via &quot;&lt;code&gt;make test&lt;/code&gt; &quot; did something very important. It invoked perl with all those &lt;code&gt;-I&lt;/code&gt; arguments so that it could find the various files that are part of the extension. It is</source>
          <target state="translated">「 &lt;code&gt;make test&lt;/code&gt; 」を介してテストスクリプトを呼び出すことは、非常に重要なことを行いました。拡張機能の一部であるさまざまなファイルを見つけることができるように、これらすべての &lt;code&gt;-I&lt;/code&gt; 引数を使用してperlを呼び出しました。です</target>
        </trans-unit>
        <trans-unit id="2ecba9a37fd38e5bf42e93fcbe6104f64a6dc5ac" translate="yes" xml:space="preserve">
          <source>Invoking the test script via &quot;&lt;code&gt;make test&lt;/code&gt;&quot; did something very important. It invoked perl with all those &lt;code&gt;-I&lt;/code&gt; arguments so that it could find the various files that are part of the extension. It is</source>
          <target state="translated">「maketest」 &lt;code&gt;make test&lt;/code&gt; 介してテストスクリプトを呼び出すと、非常に重要なことが行われました。拡張子の一部であるさまざまなファイルを見つけることができるように、これらすべての &lt;code&gt;-I&lt;/code&gt; 引数を使用してperlを呼び出しました。です</target>
        </trans-unit>
        <trans-unit id="b5657593a133551a2130d25fd548705e5a0d18d8" translate="yes" xml:space="preserve">
          <source>IoFLAGS</source>
          <target state="translated">IoFLAGS</target>
        </trans-unit>
        <trans-unit id="3bb882aae446ce0088800e6387a83d4c1329eedf" translate="yes" xml:space="preserve">
          <source>IoTYPE</source>
          <target state="translated">IoTYPE</target>
        </trans-unit>
        <trans-unit id="889224e3fca24a6ab17d01fe47a45bc82244e938" translate="yes" xml:space="preserve">
          <source>Iran</source>
          <target state="translated">Iran</target>
        </trans-unit>
        <trans-unit id="eb2131ece0efe78ee8bb1ae98af6099114a8df09" translate="yes" xml:space="preserve">
          <source>Ireland</source>
          <target state="translated">Ireland</target>
        </trans-unit>
        <trans-unit id="5a017d9fae08fe8b742594c766cac2cd8dcf3595" translate="yes" xml:space="preserve">
          <source>Irish for the whole McGillicuddy. In Perl culture, a portmanteau of &amp;ldquo;sharp&amp;rdquo; and &amp;ldquo;bang&amp;rdquo;, meaning the &lt;code&gt;#!&lt;/code&gt; sequence that tells the system where to find the interpreter.</source>
          <target state="translated">McGillicuddy全体のアイルランド人。Perlの文化では、「シャープ」と「強打」の &lt;code&gt;#!&lt;/code&gt; 意味するportmanteau です。インタープリターの検索場所をシステムに指示するシーケンス。</target>
        </trans-unit>
        <trans-unit id="15b9752e24986e0f7c7c5303acc5a2830fc9afd6" translate="yes" xml:space="preserve">
          <source>Irix (6.5. What else?)</source>
          <target state="translated">アイリックス(6.5.他には?</target>
        </trans-unit>
        <trans-unit id="eb88b49be9395cb953eb1205ce4b4ea6acad6f1e" translate="yes" xml:space="preserve">
          <source>Irix 5.3</source>
          <target state="translated">Irix 5.3</target>
        </trans-unit>
        <trans-unit id="280a8973708779722e3c6e60a42a133ed8d4613c" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples here are in the public domain. You are permitted and encouraged to use this code and any derivatives thereof in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit to the FAQ would be courteous but is not required.</source>
          <target state="translated">その配布に関わらず、ここにあるすべてのコード例はパブリックドメインです。あなたは、このコードとその派生物を、あなた自身のプログラムで、あなたが適切と考えるように、楽しみのために、または利益のために使用することが許可され、奨励されています。コードの中で、FAQへのクレジットを示すシンプルなコメントは礼儀正しいものですが、必須ではありません。</target>
        </trans-unit>
        <trans-unit id="e6e987fe64dde20e286f30fd90c6b90ffeedb494" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples in these files are hereby placed into the public domain. You are permitted and encouraged to use this code in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit would be courteous but is not required.</source>
          <target state="translated">その配布にかかわらず、これらのファイル内のすべてのコード例は、ここにパブリックドメインに置かれます。あなたはこのコードをあなた自身のプログラムに使用することが許可されていますし、あなたが適切と考えるように、楽しみや利益のためにこのコードを使用することが奨励されています。コードの中にクレジットを与える単純なコメントは礼儀正しいものですが、必須ではありません。</target>
        </trans-unit>
        <trans-unit id="16778fd5503d73f3e7cd989fda95007a4e44c18a" translate="yes" xml:space="preserve">
          <source>Irrespective of its distribution, all code examples in this file are hereby placed into the public domain. You are permitted and encouraged to use this code in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit would be courteous but is not required.</source>
          <target state="translated">その配布にかかわらず、このファイルのすべてのコード例は、ここにパブリックドメインに置かれます。あなたはこのコードをあなた自身のプログラムに使用することが許可されていますし、あなたが適切と考えるように、楽しみや利益のためにこのコードを使用することが奨励されています。コードの中で簡単なコメントをつけることが礼儀ですが、必須ではありません。</target>
        </trans-unit>
        <trans-unit id="3b1335a849872557c30733349f1e4699d629a12c" translate="yes" xml:space="preserve">
          <source>Is Perl difficult to learn?</source>
          <target state="translated">Perlの学習は難しい?</target>
        </trans-unit>
        <trans-unit id="ac0736b6a42e76cbb8b7ea3d82d9347dd47ba779" translate="yes" xml:space="preserve">
          <source>Is better written:</source>
          <target state="translated">書かれている方がいいですね。</target>
        </trans-unit>
        <trans-unit id="9f9ed743f2c1371f19760689c4a59cf333c563af" translate="yes" xml:space="preserve">
          <source>Is it possible to change the file permissions of a file on an FTP server ?</source>
          <target state="translated">FTPサーバー上のファイルのパーミッションを変更することは可能ですか?</target>
        </trans-unit>
        <trans-unit id="32906667b7957f587634c3ad2cf7b982992ddda0" translate="yes" xml:space="preserve">
          <source>Is it safe to return a reference to local or lexical data?</source>
          <target state="translated">ローカルデータや語彙データへの参照を返すのは安全ですか?</target>
        </trans-unit>
        <trans-unit id="a15088679e31d0c4822e89f1a281a86a46e94dee" translate="yes" xml:space="preserve">
          <source>Is it the same? Well, maybe so--and maybe not. The subtle difference is that when you assign something in square brackets, you know for sure it's always a brand new reference with a new</source>
          <target state="translated">同じなの?まあ、そうかもしれませんし、そうでないかもしれません。微妙な違いは、何かを角括弧で囲んで代入したときに、それが常に新しい</target>
        </trans-unit>
        <trans-unit id="c842dccd002c594c47398d7b81a3f350518d446b" translate="yes" xml:space="preserve">
          <source>Is not supported for process identification number of 0 or negative numbers. (VMS)</source>
          <target state="translated">プロセス識別番号が 0 または負の番号の場合はサポートしていません。(VMS)</target>
        </trans-unit>
        <trans-unit id="85e623ea793b61351aedc1f6283751b7266d3791" translate="yes" xml:space="preserve">
          <source>Is supposed to be superseded by &lt;code&gt;IOCTL_STORAGE_GET_MEDIA_TYPES&lt;/code&gt; but is still useful for determining the types of floppy diskette formats that can be produced by a given floppy drive. See</source>
          <target state="translated">&lt;code&gt;IOCTL_STORAGE_GET_MEDIA_TYPES&lt;/code&gt; に取って代わられることになっていますが、特定のフロッピードライブで生成できるフロッピーディスク形式のタイプを判別するのに役立ちます。見る</target>
        </trans-unit>
        <trans-unit id="ed13e4ee416049073be2fb55253aff4db8cf0204" translate="yes" xml:space="preserve">
          <source>Is the disk signature, a unique number assigned by Disk Administrator [</source>
          <target state="translated">ディスク署名は、ディスク管理者によって割り当てられた一意の番号です。</target>
        </trans-unit>
        <trans-unit id="892d60f6405f23f25c6b3ae4379071e72ec47d11" translate="yes" xml:space="preserve">
          <source>Is the feature generic enough?</source>
          <target state="translated">機能は一般的なもので十分ですか?</target>
        </trans-unit>
        <trans-unit id="21550a0f41b5f7c0792d01f174b9eb78bb2eb4ca" translate="yes" xml:space="preserve">
          <source>Is the implementation generic enough to be portable?</source>
          <target state="translated">実装は移植可能なほど汎用的か?</target>
        </trans-unit>
        <trans-unit id="ef5914893715ffaab39210a601dc4f727d6ff4af" translate="yes" xml:space="preserve">
          <source>Is the implementation robust?</source>
          <target state="translated">実装は堅牢なのか?</target>
        </trans-unit>
        <trans-unit id="78090775b623989661f8da8dfe386a79dbfa661d" translate="yes" xml:space="preserve">
          <source>Is the implementation tested?</source>
          <target state="translated">実装はテストされていますか?</target>
        </trans-unit>
        <trans-unit id="7ff173c83692442c34b8acc41b270ff651c2392a" translate="yes" xml:space="preserve">
          <source>Is the scalar handle opened on something?</source>
          <target state="translated">スカラのハンドルが何かに開いているのかな?</target>
        </trans-unit>
        <trans-unit id="a9f6ff8d209700b0f72a5230b6fb85c97fcff80b" translate="yes" xml:space="preserve">
          <source>Is there a pretty-printer (formatter) for Perl?</source>
          <target state="translated">Perl用のプリティプリンタ(フォーマッタ)はありますか?</target>
        </trans-unit>
        <trans-unit id="4de697ef2e229f75e5104bfc892c512110a431a3" translate="yes" xml:space="preserve">
          <source>Is there a way to automatically decode or encode?</source>
          <target state="translated">自動でデコードやエンコードする方法はありますか?</target>
        </trans-unit>
        <trans-unit id="39ca1c79bbe21712b9201250f2255ac5dedb029e" translate="yes" xml:space="preserve">
          <source>Is there a way to hide perl's command line from programs such as &quot;ps&quot;?</source>
          <target state="translated">ps」などのプログラムからperlのコマンドラインを隠す方法はありますか?</target>
        </trans-unit>
        <trans-unit id="3501dfd2cd1d66a0e5956cd00d200fac2bcfba23" translate="yes" xml:space="preserve">
          <source>Is there an IDE or Windows Perl Editor?</source>
          <target state="translated">IDEやWindowsのPerlエディタはありますか?</target>
        </trans-unit>
        <trans-unit id="d38604e1470c164361620c8174e47b26e8405b57" translate="yes" xml:space="preserve">
          <source>Is there another way to do it?</source>
          <target state="translated">他にも方法はあるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="14fcbaecb1fe49a8bbbcabb376a8c49b63c6d0ee" translate="yes" xml:space="preserve">
          <source>Is there anything else I need to know?</source>
          <target state="translated">他に何か知りたいことはありますか?</target>
        </trans-unit>
        <trans-unit id="3079a95c08daf3fbe9a6f4a2b3424c5019e5caa9" translate="yes" xml:space="preserve">
          <source>Is there enough documentation?</source>
          <target state="translated">ドキュメントは十分にあるのか?</target>
        </trans-unit>
        <trans-unit id="a850886339587a195217b1d8cceb0d4cff588e20" translate="yes" xml:space="preserve">
          <source>Is this something that only the submitter wants added to the language, or is it broadly useful? Sometimes, instead of adding a feature with a tight focus, the porters might decide to wait until someone implements the more generalized feature.</source>
          <target state="translated">これは投稿者だけが言語に追加してほしいものなのか、それとも広く有用なものなのか。時には、焦点を絞って機能を追加するのではなく、誰かがより一般化した機能を実装するまで待つことにしてしまうこともあります。</target>
        </trans-unit>
        <trans-unit id="c6c3f322bd4a89ec99cd36027dacc62c0c50b0bf" translate="yes" xml:space="preserve">
          <source>Is this the document you were after?</source>
          <target state="translated">これがお目当ての書類ですか?</target>
        </trans-unit>
        <trans-unit id="c801f4251dba57aee2f236238406c19df06e8971" translate="yes" xml:space="preserve">
          <source>Is this you? Is writing tests right up there with writing documentation and having your fingernails pulled out? Did you open up a test and read</source>
          <target state="translated">これはあなたですか?テストを書くことは、ドキュメントを書くことと同じで、爪を抜かれることと同じですか?テストを開いて</target>
        </trans-unit>
        <trans-unit id="243aed46fb67b26a47f5f82cb478ce344d097065" translate="yes" xml:space="preserve">
          <source>Is your program EMX-compiled with &lt;code&gt;-Zmt -Zcrtdll&lt;/code&gt;?</source>
          <target state="translated">あなたのプログラムは &lt;code&gt;-Zmt -Zcrtdll&lt;/code&gt; - ZcrtdllでEMXコンパイルされていますか？</target>
        </trans-unit>
        <trans-unit id="af501c530066fe2526868f8de57f9ed976517fd9" translate="yes" xml:space="preserve">
          <source>IsContainerPartition</source>
          <target state="translated">IsContainerPartition</target>
        </trans-unit>
        <trans-unit id="c6193261c02de21aac043fe2d15ff95fc2e34dca" translate="yes" xml:space="preserve">
          <source>IsRecognizedPartition</source>
          <target state="translated">IsRecognizedPartition</target>
        </trans-unit>
        <trans-unit id="d95874ba2baf2aa8c816605d15eea330b17427d2" translate="yes" xml:space="preserve">
          <source>IsSTD</source>
          <target state="translated">IsSTD</target>
        </trans-unit>
        <trans-unit id="9f55afe53a666115430d24161c215ea18ed5b9a0" translate="yes" xml:space="preserve">
          <source>Isn't Archive::Tar heavier on memory than /bin/tar?</source>
          <target state="translated">Archive::Tar は /bin/tar よりもメモリが重くないですか?</target>
        </trans-unit>
        <trans-unit id="74a285d7f91e6104f157a9d3d5748d7dac064dcf" translate="yes" xml:space="preserve">
          <source>Isn't Archive::Tar slow?</source>
          <target state="translated">Archive::Tarって遅くないですか?</target>
        </trans-unit>
        <trans-unit id="4c197dfd67f1ed79d11a8b0218cc368bfcce6ccb" translate="yes" xml:space="preserve">
          <source>Israel</source>
          <target state="translated">Israel</target>
        </trans-unit>
        <trans-unit id="71a13751965545486650d22819d11cd32442498c" translate="yes" xml:space="preserve">
          <source>Issue a command as follows;</source>
          <target state="translated">以下のようにコマンドを発行します。</target>
        </trans-unit>
        <trans-unit id="634b2e574e8681fa4bd024f62981fab9bb1e46c1" translate="yes" xml:space="preserve">
          <source>Issue a diagnostics message to STDERR.</source>
          <target state="translated">STDERRに診断メッセージを発行します。</target>
        </trans-unit>
        <trans-unit id="03592f61d67d4b9df2c210af49940f16e407a6d4" translate="yes" xml:space="preserve">
          <source>Issue a diagnostics message to STDOUT.</source>
          <target state="translated">STDOUT に診断メッセージを発行します。</target>
        </trans-unit>
        <trans-unit id="e65cf3242e05b4d2c344ded5e0824a537ad64ec2" translate="yes" xml:space="preserve">
          <source>Issues a &lt;code&gt;ualarm&lt;/code&gt; call; the &lt;code&gt;$interval_useconds&lt;/code&gt; is optional and will be zero if unspecified, resulting in &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;-like behaviour.</source>
          <target state="translated">問題 &lt;code&gt;ualarm&lt;/code&gt; 関数呼び出し。 &lt;code&gt;$interval_useconds&lt;/code&gt; オプションで、指定されていない場合、その結果はゼロになり &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 動作様。</target>
        </trans-unit>
        <trans-unit id="451bb20dde9f17b91d4ea56d923babf92e6ab559" translate="yes" xml:space="preserve">
          <source>Issues a &lt;code&gt;ualarm&lt;/code&gt; call; the &lt;code&gt;$interval_useconds&lt;/code&gt; is optional and will be zero if unspecified, resulting in &lt;code&gt;alarm&lt;/code&gt;-like behaviour.</source>
          <target state="translated">問題 &lt;code&gt;ualarm&lt;/code&gt; 関数呼び出し。 &lt;code&gt;$interval_useconds&lt;/code&gt; オプションで、指定されていない場合、その結果はゼロになり &lt;code&gt;alarm&lt;/code&gt; 動作様。</target>
        </trans-unit>
        <trans-unit id="8f58a9877a43ede1a54c6d1cffca7950a04cb0e9" translate="yes" xml:space="preserve">
          <source>Issues the warning:</source>
          <target state="translated">警告を発します。</target>
        </trans-unit>
        <trans-unit id="d7acc4a63bfa4b603392fb8adfd2d4ca89c11f46" translate="yes" xml:space="preserve">
          <source>It</source>
          <target state="translated">It</target>
        </trans-unit>
        <trans-unit id="38eb0bc8056860c92fb5c583bff73f1456dae838" translate="yes" xml:space="preserve">
          <source>It allows you to fetch any file pointed to by a &lt;code&gt;ftp&lt;/code&gt; , &lt;code&gt;http&lt;/code&gt; , &lt;code&gt;file&lt;/code&gt; , &lt;code&gt;git&lt;/code&gt; or &lt;code&gt;rsync&lt;/code&gt; uri by a number of different means.</source>
          <target state="translated">&lt;code&gt;ftp&lt;/code&gt; 、 &lt;code&gt;http&lt;/code&gt; 、 &lt;code&gt;file&lt;/code&gt; 、 &lt;code&gt;git&lt;/code&gt; 、または &lt;code&gt;rsync&lt;/code&gt; uriが指すファイルをさまざまな方法でフェッチできます。</target>
        </trans-unit>
        <trans-unit id="5f7f3deaf6b10a7e4949b31b699d2af4c0c5c2a4" translate="yes" xml:space="preserve">
          <source>It allows you to fetch any file pointed to by a &lt;code&gt;ftp&lt;/code&gt;, &lt;code&gt;http&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, &lt;code&gt;git&lt;/code&gt; or &lt;code&gt;rsync&lt;/code&gt; uri by a number of different means.</source>
          <target state="translated">これにより、 &lt;code&gt;ftp&lt;/code&gt; 、 &lt;code&gt;http&lt;/code&gt; 、 &lt;code&gt;file&lt;/code&gt; 、 &lt;code&gt;git&lt;/code&gt; 、または &lt;code&gt;rsync&lt;/code&gt; uriが指すファイルをさまざまな方法でフェッチできます。</target>
        </trans-unit>
        <trans-unit id="0b28d021dc9b9966369f90f11dc74db9e607087c" translate="yes" xml:space="preserve">
          <source>It allows you to validate input via a template. The only requirement is that the arguments must be named.</source>
          <target state="translated">テンプレートを使って入力を検証することができます。唯一の要件は、引数に名前を付けなければならないことです。</target>
        </trans-unit>
        <trans-unit id="b9dcbab629dab7b7bb8a9a5c305c5b7edec8fe86" translate="yes" xml:space="preserve">
          <source>It also causes &lt;code&gt;decode&lt;/code&gt; to parse such tagged JSON values and deserialise them via a call to the &lt;code&gt;THAW&lt;/code&gt; method.</source>
          <target state="translated">また、 &lt;code&gt;decode&lt;/code&gt; はそのようなタグ付きJSON値を解析し、 &lt;code&gt;THAW&lt;/code&gt; メソッドの呼び出しを介してそれらを逆シリアル化します。</target>
        </trans-unit>
        <trans-unit id="5e1f97bb7137990bbbfbdc73b45154ab6a87edc2" translate="yes" xml:space="preserve">
          <source>It also flags things that need to behave specially in an lvalue context, such as &lt;code&gt;$$x = 5&lt;/code&gt; which might have to vivify a reference in &lt;code&gt;$x&lt;/code&gt; .</source>
          <target state="translated">また、 &lt;code&gt;$x&lt;/code&gt; 参照を有効にする必要がある可能性がある &lt;code&gt;$$x = 5&lt;/code&gt; など、左辺値コンテキストで特別に動作する必要があるものにフラグを付けます。</target>
        </trans-unit>
        <trans-unit id="f46a706382c3e7f690244335b6067ef888c4bc96" translate="yes" xml:space="preserve">
          <source>It also flags things that need to behave specially in an lvalue context, such as &lt;code&gt;$$x = 5&lt;/code&gt; which might have to vivify a reference in &lt;code&gt;$x&lt;/code&gt;.</source>
          <target state="translated">また、 &lt;code&gt;$x&lt;/code&gt; 内の参照を有効にする必要がある可能性のある &lt;code&gt;$$x = 5&lt;/code&gt; など、左辺値コンテキストで特別に動作する必要があるものにもフラグを立てます。</target>
        </trans-unit>
        <trans-unit id="908ce366021e2b55b694a1cc88f5df405de36e15" translate="yes" xml:space="preserve">
          <source>It also has embedded documentation, so you can use</source>
          <target state="translated">ドキュメントも埋め込まれているので</target>
        </trans-unit>
        <trans-unit id="2ac24af0ec1c7cfa5374898a3526976fbf4e475c" translate="yes" xml:space="preserve">
          <source>It also made it impossible to pass a perl filehandle that wasn't associated with a real filesystem file, like, say, an &lt;code&gt;IO::String&lt;/code&gt; .</source>
          <target state="translated">また、たとえば &lt;code&gt;IO::String&lt;/code&gt; ような実際のファイルシステムファイルに関連付けられていないperlファイルハンドルを渡すことができなくなりました。</target>
        </trans-unit>
        <trans-unit id="affbbcabd9e89330cd688705cb152f75ac31dcc5" translate="yes" xml:space="preserve">
          <source>It also made it impossible to pass a perl filehandle that wasn't associated with a real filesystem file, like, say, an &lt;code&gt;IO::String&lt;/code&gt;.</source>
          <target state="translated">また、 &lt;code&gt;IO::String&lt;/code&gt; など、実際のファイルシステムファイルに関連付けられていないperlファイルハンドルを渡すこともできませんでした。</target>
        </trans-unit>
        <trans-unit id="50072e7f3665a297dafc9a98026d2ece625b9337" translate="yes" xml:space="preserve">
          <source>It also provides a convenient alias via the MM class (I didn't want MakeMaker modules outside of ExtUtils/).</source>
          <target state="translated">また、MMクラスを介して便利なエイリアスを提供してくれます(ExtUtils/以外のMakeMakerモジュールはいらないと思っていました)。</target>
        </trans-unit>
        <trans-unit id="915bbb1cff409394c98921945b825ccfd726cf97" translate="yes" xml:space="preserve">
          <source>It also provides a convenient alias via the MY class.</source>
          <target state="translated">また、MYクラスを介して便利なエイリアスを提供します。</target>
        </trans-unit>
        <trans-unit id="f7728ec4984f8aa9520af281a21430a4fa58511c" translate="yes" xml:space="preserve">
          <source>It also sets the effective names (&lt;code&gt;HvENAME&lt;/code&gt; ) on all the stashes as appropriate.</source>
          <target state="translated">また、必要に応じて、すべてのスタッシュに実効名（ &lt;code&gt;HvENAME&lt;/code&gt; ）を設定します。</target>
        </trans-unit>
        <trans-unit id="fdd0b99c263719f6c7ac54250b06d02a9d280c92" translate="yes" xml:space="preserve">
          <source>It also sets the effective names (&lt;code&gt;HvENAME&lt;/code&gt;) on all the stashes as appropriate.</source>
          <target state="translated">また、必要に応じて、すべてのスタッシュに有効な名前（ &lt;code&gt;HvENAME&lt;/code&gt; ）を設定します。</target>
        </trans-unit>
        <trans-unit id="b1b119a076af514e51ac37bcaf3aa61a59bc6514" translate="yes" xml:space="preserve">
          <source>It also supports tying via a win32 handle (for example, from &lt;code&gt;createFile()&lt;/code&gt;):</source>
          <target state="translated">また、win32ハンドルを介した &lt;code&gt;createFile()&lt;/code&gt; もサポートしています（たとえば、createFile（）から）。</target>
        </trans-unit>
        <trans-unit id="0cefa68e3cb791475c8c4a04f377e9985e23ade2" translate="yes" xml:space="preserve">
          <source>It also turns out that EBCDIC has nearly precise equivalents for the ASCII/Latin1 C0 controls and the DELETE control. (The C0 controls are those whose ASCII code points are 0..0x1F; things like TAB, ACK, BEL, etc.) A mapping is set up between these ASCII/EBCDIC controls. There isn't such a precise mapping between the C1 controls on ASCII platforms and the remaining EBCDIC controls. What has been done is to map these controls, mostly arbitrarily, to some otherwise unmatched character in the other character set. Most of these are very very rarely used nowadays in EBCDIC anyway, and their names have been dropped, without much complaint. For example the EO (Eight Ones) EBCDIC control (consisting of eight one bits = 0xFF) is mapped to the C1 APC control (0x9F), and you can't use the name &quot;EO&quot;.</source>
          <target state="translated">また、EBCDIC は、ASCII/Latin1 の C0 コントロールと DELETE コントロールにほぼ正確な等価物を持っていることがわかりました。(C0 コントロールとは、ASCII コードポイントが 0.0x1F のもので、TAB、ACK、BEL などのようなものです。)これらの ASCII/EBCDIC コントロールの間にマッピングが設定されています。ASCII プラットフォーム上の C1 コントロールと残りの EBCDIC コントロールの間には、このような正確なマッピングはありません。何が行われてきたかというと、これらのコントロールを、ほとんど任意に、他の文字セットの中のマッチしない文字にマッピングすることです。これらのコントロールのほとんどは、最近ではEBCDICではほとんど使われておらず、その名前はあまり文句を言われることなく削除されています。例えば、EO (Eight Ones)EBCDIC コントロール (8 つの 1 ビット=0xFF からなる)は、C1 APC コントロール (0x9F)にマップされており、&quot;EO&quot; という名前を使うことはできません。</target>
        </trans-unit>
        <trans-unit id="6e72af9b0783d77ee6316a243e984feea8033ad2" translate="yes" xml:space="preserve">
          <source>It assumes that pat has the same utf8-ness as sv. It's the caller's responsibility to ensure that this is so.</source>
          <target state="translated">pat は sv と同じ utf8-ness を持っていると仮定しています。これを確認するのは呼び出し側の責任です。</target>
        </trans-unit>
        <trans-unit id="ff9e21d973b85a09332d5d3faae1a519ffea9ab5" translate="yes" xml:space="preserve">
          <source>It attempts to meet all &quot;MUST&quot; requirements of the specification, but does not implement all &quot;SHOULD&quot; requirements. (Note: it was developed against the earlier RFC 2616 specification and may not yet meet the revised RFC 7230-7235 spec.)</source>
          <target state="translated">これは、仕様のすべての「MUST」要件を満たそうとしているが、すべての「SHOULD」要件を実装しているわけではない。(注意:これは以前のRFC2616仕様に対して開発されたもので、改訂されたRFC7230-7235仕様をまだ満たしていないかもしれない)。</target>
        </trans-unit>
        <trans-unit id="fd158a359289156ad701983e580703419c574eb4" translate="yes" xml:space="preserve">
          <source>It becomes more important for perl to know about all the possible locale categories on the platform, even if they aren't apparently used in your program. Perl knows all of the Linux ones. If your platform has others, you can submit an issue at &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt; for inclusion of it in the next release. In the meantime, it is possible to edit the Perl source to teach it about the category, and then recompile. Search for instances of, say, &lt;code&gt;LC_PAPER&lt;/code&gt; in the source, and use that as a template to add the omitted one.</source>
          <target state="translated">プログラムで明らかに使用されていない場合でも、perlがプラットフォームで可能なすべてのロケールカテゴリについて知ることがより重要になります。PerlはLinuxのものをすべて知っています。プラットフォームに他のプラットフォームがある場合は、&lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https：//github.com/Perl/perl5/issues&lt;/a&gt;で問題を送信して、次のリリースに含めることができます。それまでの間、Perlソースを編集してカテゴリについて教えてから、再コンパイルすることができます。たとえば、ソースで &lt;code&gt;LC_PAPER&lt;/code&gt; のインスタンスを検索し、それをテンプレートとして使用して、省略されたインスタンスを追加します。</target>
        </trans-unit>
        <trans-unit id="3c6076aff0ee21a62fd6a390261efc5e5f0afb16" translate="yes" xml:space="preserve">
          <source>It calls &lt;code&gt;croak&lt;/code&gt; on failure.</source>
          <target state="translated">失敗すると &lt;code&gt;croak&lt;/code&gt; と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="04dc7e22ec9e3426f178763cb4c63c8305c033ad" translate="yes" xml:space="preserve">
          <source>It calls several other routines, such as &lt;code&gt;fbm_instr()&lt;/code&gt; which does Fast Boyer Moore matching and &lt;code&gt;find_byclass()&lt;/code&gt; which is responsible for finding the start using the first mandatory regop in the program.</source>
          <target state="translated">それは、次のようないくつかの他のルーチン呼び出し &lt;code&gt;fbm_instr()&lt;/code&gt; 高速ボイヤームーアマッチングとし &lt;code&gt;find_byclass()&lt;/code&gt; プログラムの最初の必須regopを使用して開始を見つけるための責任があります。</target>
        </trans-unit>
        <trans-unit id="497f49c37ce971a4a73fa1723da212a9045a166f" translate="yes" xml:space="preserve">
          <source>It can also be extended to be an application from &lt;b&gt;C&lt;/b&gt; to &lt;b&gt;C&lt;/b&gt;, whilst its restriction to &lt;b&gt;R&lt;/b&gt; behaves as defined above by using the following definition:</source>
          <target state="translated">また、アプリケーションからなるように拡張することができる&lt;b&gt;C&lt;/b&gt;に&lt;b&gt;C&lt;/b&gt;への制限しながら、&lt;b&gt;Rは&lt;/b&gt;以下の定義を使用して、上記で定義した通りに動作します。</target>
        </trans-unit>
        <trans-unit id="037c189042a08e857fa9c25c861179516385e907" translate="yes" xml:space="preserve">
          <source>It can also be that long doubles and doubles are the same thing:</source>
          <target state="translated">ロングダブルスとダブルスが同じものであることもあります。</target>
        </trans-unit>
        <trans-unit id="5a15f67a53851e31c8be84ee1922d871c9c74ea2" translate="yes" xml:space="preserve">
          <source>It can also store the resource directly in a file:</source>
          <target state="translated">また、リソースを直接ファイルに格納することもできます。</target>
        </trans-unit>
        <trans-unit id="2eb713583608cebc3ea2998759255bff9599a6ef" translate="yes" xml:space="preserve">
          <source>It can be called on an object or a class, of course.</source>
          <target state="translated">もちろん、オブジェクトやクラスに対して呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="e5c905f1665a696bdc789794d07c2a84423a378d" translate="yes" xml:space="preserve">
          <source>It can be used in the regular procedural way by calling &lt;code&gt;store&lt;/code&gt; with a reference to the object to be stored, along with the file name where the image should be written.</source>
          <target state="translated">保存するオブジェクトへの参照と、画像を書き込むファイル名を指定して、 &lt;code&gt;store&lt;/code&gt; を呼び出すことにより、通常の手順で使用できます。</target>
        </trans-unit>
        <trans-unit id="1b6d3eb9169140a9a6274f80ff5e86670958b748" translate="yes" xml:space="preserve">
          <source>It can easily be defined like this:</source>
          <target state="translated">このように簡単に定義することができます。</target>
        </trans-unit>
        <trans-unit id="86ba6d37f32935701376ea8939425dea235ee2d1" translate="yes" xml:space="preserve">
          <source>It can load perl dynamic extensions, and it can fork().</source>
          <target state="translated">perlの動的な拡張機能をロードしたり、fork()したりすることができます。</target>
        </trans-unit>
        <trans-unit id="5a3c2d30ca072f4084789964fe3766438b6284d3" translate="yes" xml:space="preserve">
          <source>It can lose track of whether something should be encoded as UTF-8 or not.</source>
          <target state="translated">何かをUTF-8としてエンコードすべきかどうかを見失うことがあります。</target>
        </trans-unit>
        <trans-unit id="64f9135ce7da4c20ac152391823b647cbbeb33a6" translate="yes" xml:space="preserve">
          <source>It can take one of the following forms:</source>
          <target state="translated">以下のいずれかの形態をとることができる。</target>
        </trans-unit>
        <trans-unit id="2f904ea9d1b7cc3495a54fb96cf0850f9e5fd878" translate="yes" xml:space="preserve">
          <source>It can, however, be used as a superclass for other classes. To facilitate this, the generated constructor method uses a two-argument blessing. Furthermore, if the class is hash-based, the key of each element is prefixed with the class name (see</source>
          <target state="translated">しかし、他のクラスのスーパークラスとして使用することもできます。これを容易にするために、生成されるコンストラクタメソッドでは 2 つの引数の blessing を使用します。さらに、クラスがハッシュベースの場合は、各要素のキーの前にクラス名が付けられます (</target>
        </trans-unit>
        <trans-unit id="09d8ef54917c31dc7c7e7dced0a11cfba194a124" translate="yes" xml:space="preserve">
          <source>It combines the features of the</source>
          <target state="translated">の特徴を兼ね備えています。</target>
        </trans-unit>
        <trans-unit id="6de2e6681db9e2aba6bd7eace100b8a569aebcfe" translate="yes" xml:space="preserve">
          <source>It constructs and returns a $treewalker coderef, which when invoked, traverses, or walks, and renders the optrees of the given arguments to STDOUT. You can reuse this, and can change the rendering style used each time; thereafter the coderef renders in the new style.</source>
          <target state="translated">これは $treewalker coderef を構築して返します。これが呼び出されると、トラバースまたはウォークを行い、与えられた引数の optrees を STDOUT にレンダリングします。これを再利用することができ、毎回使用するレンダリングスタイルを変更することができます。</target>
        </trans-unit>
        <trans-unit id="8ee601f689d3bf17ef24ff756daa44f51b167191" translate="yes" xml:space="preserve">
          <source>It creates a database of the profile information that you can turn into reports. The &lt;code&gt;nytprofhtml&lt;/code&gt; command turns the data into an HTML report similar to the &lt;a href=&quot;Devel::Cover&quot;&gt;Devel::Cover&lt;/a&gt; report:</source>
          <target state="translated">レポートに変換できるプロファイル情報のデータベースを作成します。 &lt;code&gt;nytprofhtml&lt;/code&gt; コマンドは次のようにHTMLレポートにデータを回す&lt;a href=&quot;Devel::Cover&quot;&gt;のDevel ::カバー&lt;/a&gt;レポート：</target>
        </trans-unit>
        <trans-unit id="4b00062db32c6f6da9356b09e0e38ccf6b4650d6" translate="yes" xml:space="preserve">
          <source>It creates a database of the profile information that you can turn into reports. The &lt;code&gt;nytprofhtml&lt;/code&gt; command turns the data into an HTML report similar to the &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::Cover&quot;&gt;Devel::Cover&lt;/a&gt; report:</source>
          <target state="translated">レポートに変換できるプロファイル情報のデータベースを作成します。 &lt;code&gt;nytprofhtml&lt;/code&gt; コマンドは次のようにHTMLレポートにデータを回す&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::Cover&quot;&gt;のDevel ::カバー&lt;/a&gt;レポート：</target>
        </trans-unit>
        <trans-unit id="ea6e392f63285a19a0d452d50c54df585744488e" translate="yes" xml:space="preserve">
          <source>It currently does</source>
          <target state="translated">現在のところ</target>
        </trans-unit>
        <trans-unit id="e547a28181c8513c90dab654ebd4bf8ae08d6f97" translate="yes" xml:space="preserve">
          <source>It delivers the correct results for the &lt;code&gt;RADIXCHAR&lt;/code&gt; and &lt;code&gt;THOUSEP&lt;/code&gt; items, without you having to write extra code. The reason for the extra code would be because these are from the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale category, which is normally kept set by Perl so that the radix is a dot, and the separator is the empty string, no matter what the underlying locale is supposed to be, and so to get the expected results, you have to temporarily toggle into the underlying locale, and later toggle back. (You could use plain &lt;code&gt;nl_langinfo&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;&quot;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&lt;/a&gt;&lt;/code&gt; for this but then you wouldn't get the other advantages of &lt;code&gt;Perl_langinfo()&lt;/code&gt;; not keeping &lt;code&gt;LC_NUMERIC&lt;/code&gt; in the C (or equivalent) locale would break a lot of CPAN, which is expecting the radix (decimal point) character to be a dot.)</source>
          <target state="translated">余分なコードを記述することなく、 &lt;code&gt;RADIXCHAR&lt;/code&gt; および &lt;code&gt;THOUSEP&lt;/code&gt; アイテムに対して正しい結果を提供します。余分なコードの理由は、これらが &lt;code&gt;LC_NUMERIC&lt;/code&gt; ロケールカテゴリからのものであるためです。LC_NUMERICロケールカテゴリは、基数がドットであり、区切り文字が空の文字列であるように、通常はPerlによって設定されます。これは、基になるロケールが何であるかは関係ありません。 、など、期待される結果を得るには、一時的に基になるロケールに切り替えてから、後で元に戻す必要があります。 （これにはプレーンな &lt;code&gt;nl_langinfo&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;#STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&gt;&quot;STORE_LC_NUMERIC_FORCE_TO_UNDERLYING&quot;&lt;/a&gt;&lt;/code&gt; を使用できますが、 &lt;code&gt;Perl_langinfo()&lt;/code&gt; の他の利点は得られません; &lt;code&gt;LC_NUMERIC&lt;/code&gt; を維持しない C（または同等の）ロケールでは、基数（小数点）文字がドットであると想定している多くのCPANが壊れます。）</target>
        </trans-unit>
        <trans-unit id="7dad9241afc4fe54f1d9bdea5f00177fb19d962a" translate="yes" xml:space="preserve">
          <source>It depends just what you mean by &quot;escape&quot;. URL escapes are dealt with in &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;. Shell escapes with the backslash (&lt;code&gt;\&lt;/code&gt; ) character are removed with</source>
          <target state="translated">それはあなたが「エスケープ」によって何を意味するかに依存します。URLエスケープは&lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9で&lt;/a&gt;処理されます。バックスラッシュ（ &lt;code&gt;\&lt;/code&gt; ）文字を含むシェルエスケープは、</target>
        </trans-unit>
        <trans-unit id="cdac17a54a39be9556592ce5c191473c9ecfd72c" translate="yes" xml:space="preserve">
          <source>It depends just what you mean by &quot;escape&quot;. URL escapes are dealt with in &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;. Shell escapes with the backslash (&lt;code&gt;\&lt;/code&gt;) character are removed with</source>
          <target state="translated">それはあなたが「脱出」が何を意味するかによります。URLエスケープは&lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9で&lt;/a&gt;処理されます。バックスラッシュ（ &lt;code&gt;\&lt;/code&gt; ）文字を使用したシェルエスケープは、</target>
        </trans-unit>
        <trans-unit id="c581007e3ef08adcb3306414f7f2463e871ac22e" translate="yes" xml:space="preserve">
          <source>It does have the drawback of putting the wrong thing in $-[0] and $+[0], but this usually can be worked around.</source>
          <target state="translated">これは、$-[0]と$+[0]に間違ったものを入れるという欠点がありますが、通常はこれを回避することができます。</target>
        </trans-unit>
        <trans-unit id="79d1a39f53aab3a73596d5fd9d9372e7a56d671b" translate="yes" xml:space="preserve">
          <source>It does implement the full UTS#18 grouping, intersection, union, and removal (subtraction) syntax.</source>
          <target state="translated">UTS#18のグループ化、交差、結合、除去(減算)構文を完全に実装しています。</target>
        </trans-unit>
        <trans-unit id="3283ccec35b62f9d69fc01d0b0127572cdbbfb86" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFC', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">それは &lt;code&gt;normalize_partial('NFC', $unprocessed)&lt;/code&gt; です。 &lt;code&gt;$unprocessed&lt;/code&gt; は副作用として変更されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="25a28128ab3b4005d07e5b53db8c8141489e82c0" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFC', $unprocessed)&lt;/code&gt;. Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">それは次のように行います &lt;code&gt;normalize_partial('NFC', $unprocessed)&lt;/code&gt; 。 &lt;code&gt;$unprocessed&lt;/code&gt; は、副作用として変更されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="781b506fec7893fd5e327ee69d14b0d379ec072d" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFD', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">それは &lt;code&gt;normalize_partial('NFD', $unprocessed)&lt;/code&gt; です。 &lt;code&gt;$unprocessed&lt;/code&gt; は副作用として変更されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="053e3e1bd8bbb865867e84abe6ea50be636b0060" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFD', $unprocessed)&lt;/code&gt;. Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">それは次のように行います &lt;code&gt;normalize_partial('NFD', $unprocessed)&lt;/code&gt; 。 &lt;code&gt;$unprocessed&lt;/code&gt; は、副作用として変更されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="98073979e598afdba9b1edfe5653068ff476e437" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKC', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">それは &lt;code&gt;normalize_partial('NFKC', $unprocessed)&lt;/code&gt; です。 &lt;code&gt;$unprocessed&lt;/code&gt; は副作用として変更されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4bd843b35cf6f524d8898789fded24bf5b532aee" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKC', $unprocessed)&lt;/code&gt;. Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">それは次のように行います &lt;code&gt;normalize_partial('NFKC', $unprocessed)&lt;/code&gt; 。 &lt;code&gt;$unprocessed&lt;/code&gt; は、副作用として変更されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="47a16bde88f189f6ad288e03cf560598f2698ec6" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKD', $unprocessed)&lt;/code&gt; . Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">それは &lt;code&gt;normalize_partial('NFKD', $unprocessed)&lt;/code&gt; です。 &lt;code&gt;$unprocessed&lt;/code&gt; は副作用として変更されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5cfa9126aa95883d132daa2d80bb8c833bb459ad" translate="yes" xml:space="preserve">
          <source>It does like &lt;code&gt;normalize_partial('NFKD', $unprocessed)&lt;/code&gt;. Note that &lt;code&gt;$unprocessed&lt;/code&gt; will be modified as a side-effect.</source>
          <target state="translated">それは次のように行います &lt;code&gt;normalize_partial('NFKD', $unprocessed)&lt;/code&gt; 。 &lt;code&gt;$unprocessed&lt;/code&gt; は、副作用として変更されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="23674d2d232acdb766b500c08327a83816f04c97" translate="yes" xml:space="preserve">
          <source>It does not protect &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; , so that variables can still be substituted.</source>
          <target state="translated">&lt;code&gt;$&lt;/code&gt; や &lt;code&gt;@&lt;/code&gt; は保護されないため、変数を置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="6c7a5ea655e7023099d39c28a9e780a041767575" translate="yes" xml:space="preserve">
          <source>It does not protect &lt;code&gt;'$'&lt;/code&gt; or &lt;code&gt;'@'&lt;/code&gt;, so that variables can still be substituted.</source>
          <target state="translated">&lt;code&gt;'$'&lt;/code&gt; または &lt;code&gt;'@'&lt;/code&gt; は保護されないため、変数を置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="b4b096762458cc1c67705fc722b1b5c19a799e9a" translate="yes" xml:space="preserve">
          <source>It doesn't handle all C constructs, but it does attempt to isolate definitions inside evals so that you can get at the definitions that it can translate.</source>
          <target state="translated">すべてのC構文を扱うわけではありませんが、evals内の定義を分離しようとしているので、翻訳可能な定義を得ることができます。</target>
        </trans-unit>
        <trans-unit id="661f04839377963b6531cde75241eb25f024872a" translate="yes" xml:space="preserve">
          <source>It doesn't matter whether those elements are already there or not: it'll gladly create them for you, setting intervening elements to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as need be.</source>
          <target state="translated">それらの要素がすでにあるかどうかは関係ありません。必要に応じて、介在する要素を &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; に設定して、喜んでそれらを作成します。</target>
        </trans-unit>
        <trans-unit id="fae5276d8d54bb235b88eecab0650a76f813b6ff" translate="yes" xml:space="preserve">
          <source>It doesn't matter whether those elements are already there or not: it'll gladly create them for you, setting intervening elements to &lt;code&gt;undef&lt;/code&gt; as need be.</source>
          <target state="translated">それらの要素がすでに存在するかどうかは関係ありません。必要に応じて、介在する要素を &lt;code&gt;undef&lt;/code&gt; に設定して、喜んで作成します。</target>
        </trans-unit>
        <trans-unit id="e3d56e0602580738fb050f4b637c11809b2b2552" translate="yes" xml:space="preserve">
          <source>It ensures that all items returned from the subroutine will be accessible when control returns from the</source>
          <target state="translated">これは、サブルーチンから制御が戻ってきたときに、サブルーチンから戻ってきたすべての項目にアクセスできるようにします。</target>
        </trans-unit>
        <trans-unit id="257a0d1f1aa9bffe5b6fec0d0193d78bda64cf97" translate="yes" xml:space="preserve">
          <source>It ensures that nothing is actually returned from the subroutine.</source>
          <target state="translated">これは、サブルーチンから実際には何も返されないことを保証します。</target>
        </trans-unit>
        <trans-unit id="9073e4e615d570b658e9c1dc5b31fb9fbc2e51c4" translate="yes" xml:space="preserve">
          <source>It ensures that only a scalar is actually returned from the subroutine. The subroutine can, of course, ignore the</source>
          <target state="translated">これは、実際にはスカラのみがサブルーチンから返されることを保証します。もちろん、このサブルーチンは</target>
        </trans-unit>
        <trans-unit id="c5a8cac5521955b5cf81a85b7f0157a0da48a8fd" translate="yes" xml:space="preserve">
          <source>It evaluates to TRUE if, besides those 4 words, any of the sequences &quot;feed&quot;, &quot;field&quot;, &quot;Defoe&quot;, &quot;fume&quot;, and many others are in &lt;code&gt;$foo&lt;/code&gt;. By judicious use of &lt;code&gt;\b&lt;/code&gt; (or better (because it is designed to handle natural language) &lt;code&gt;\b{wb}&lt;/code&gt;), we can make sure that only the Giant's words are matched:</source>
          <target state="translated">これらの4つの単語に加えて、「feed」、「field」、「Defoe」、「fume」などのシーケンスのいずれかが &lt;code&gt;$foo&lt;/code&gt; 場合、TRUEと評価されます。 &lt;code&gt;\b&lt;/code&gt; （またはそれ以上（自然言語を処理するように設計されているため） &lt;code&gt;\b{wb}&lt;/code&gt; ）を慎重に使用することで、Giantの単語のみが一致することを確認できます。</target>
        </trans-unit>
        <trans-unit id="6ce1e8c1dec22e7fcef7a08df4a73a6d708c188c" translate="yes" xml:space="preserve">
          <source>It exports the following variables:</source>
          <target state="translated">以下の変数をエクスポートします。</target>
        </trans-unit>
        <trans-unit id="c5eede2c3ff2d6a126d9a37fe7b6a2f7c7fef7c9" translate="yes" xml:space="preserve">
          <source>It goes without saying that bundling can be quite confusing.</source>
          <target state="translated">言うまでもなく、束ねることは非常に混乱を招く可能性があります。</target>
        </trans-unit>
        <trans-unit id="3dd9057379828dbfc73545c27db82f9785af3f5b" translate="yes" xml:space="preserve">
          <source>It has not been extensively tested yet and buffered I/O is not yet implemented.</source>
          <target state="translated">これはまだ広範囲にテストされておらず、バッファ付きI/Oはまだ実装されていません。</target>
        </trans-unit>
        <trans-unit id="15f1fa29899dc9be4d2a29da0c1ebb962d996294" translate="yes" xml:space="preserve">
          <source>It implements just a very simple class to manage an array. Apart from the constructor, &lt;code&gt;new&lt;/code&gt; , it declares methods, one static and one virtual. The static method, &lt;code&gt;PrintID&lt;/code&gt; , prints out simply the class name and a version number. The virtual method, &lt;code&gt;Display&lt;/code&gt; , prints out a single element of the array. Here is an all-Perl example of using it.</source>
          <target state="translated">配列を管理するための非常に単純なクラスを実装します。コンストラクタ &lt;code&gt;new&lt;/code&gt; とは別に、1つの静的メソッドと1つの仮想メソッドを宣言します。静的メソッド &lt;code&gt;PrintID&lt;/code&gt; は、クラス名とバージョン番号を出力します。仮想メソッド &lt;code&gt;Display&lt;/code&gt; は、配列の単一の要素を出力します。これは、Perlを使用したAll-Perlの例です。</target>
        </trans-unit>
        <trans-unit id="194ff250d804880fa7aa6c2644ae6036e2023968" translate="yes" xml:space="preserve">
          <source>It implements just a very simple class to manage an array. Apart from the constructor, &lt;code&gt;new&lt;/code&gt;, it declares methods, one static and one virtual. The static method, &lt;code&gt;PrintID&lt;/code&gt;, prints out simply the class name and a version number. The virtual method, &lt;code&gt;Display&lt;/code&gt;, prints out a single element of the array. Here is an all-Perl example of using it.</source>
          <target state="translated">配列を管理するための非常に単純なクラスを実装します。コンストラクター &lt;code&gt;new&lt;/code&gt; とは別に、静的メソッドと仮想メソッドを宣言します。静的メソッド &lt;code&gt;PrintID&lt;/code&gt; は、クラス名とバージョン番号を単純に出力します。仮想メソッド &lt;code&gt;Display&lt;/code&gt; は、配列の1つの要素を出力します。これは、それを使用するすべてのPerlの例です。</target>
        </trans-unit>
        <trans-unit id="4643eacc5a23fd6cfe7dbaa4ae9405cefd594ff8" translate="yes" xml:space="preserve">
          <source>It includes the TAP::Parser Cookbook:</source>
          <target state="translated">TAP::Parser Cookbookが含まれています。</target>
        </trans-unit>
        <trans-unit id="0b24215ad07cf4400cc22f004d70379859a91675" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a list context (if it executes</source>
          <target state="translated">呼び出されたサブルーチンがリストコンテキストで実行されていることを示します。</target>
        </trans-unit>
        <trans-unit id="fd952552f08ee5c64a4b5cd1472fcbc55f52ff32" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a scalar context (if it executes</source>
          <target state="translated">呼び出されたサブルーチンがスカラコンテキストで実行されていることを示します。</target>
        </trans-unit>
        <trans-unit id="d334572d38ec1bf7625437e6802d9ceede41a62a" translate="yes" xml:space="preserve">
          <source>It indicates to the subroutine being called that it is executing in a void context (if it executes</source>
          <target state="translated">呼び出されたサブルーチンがvoidコンテキストで実行されていることを示します。</target>
        </trans-unit>
        <trans-unit id="3dd5d5b49f19e1af8608ede7c4aa585a51f279cb" translate="yes" xml:space="preserve">
          <source>It is</source>
          <target state="translated">それは</target>
        </trans-unit>
        <trans-unit id="4593c265ea2a96fff8349127e24d6f8f64bc8930" translate="yes" xml:space="preserve">
          <source>It is a VIO application.</source>
          <target state="translated">VIOアプリです。</target>
        </trans-unit>
        <trans-unit id="15edb9eea808da9feee1a21d84ef34931e249422" translate="yes" xml:space="preserve">
          <source>It is a common feature of applications (whether run directly, or via the Web) for them to be &quot;localized&quot; -- i.e., for them to a present an English interface to an English-speaker, a German interface to a German-speaker, and so on for all languages it's programmed with. Locale::Maketext is a framework for software localization; it provides you with the tools for organizing and accessing the bits of text and text-processing code that you need for producing localized applications.</source>
          <target state="translated">つまり、英語圏の人には英語のインターフェイスを、ドイツ語圏の人にはドイツ語のインターフェイスを、といったように、プログラムされたすべての言語に対してローカライズされています。Locale::Maketextはソフトウェア・ローカリゼーションのためのフレームワークであり、ローカリゼーションされたアプリケーションを作成するために必要なテキストやテキスト処理コードを整理してアクセスするためのツールを提供します。</target>
        </trans-unit>
        <trans-unit id="dd0c9650fee6ca5253a38ac00e6dc732d4f0e459" translate="yes" xml:space="preserve">
          <source>It is a common problem to want to detect what language(s) the user would prefer output in.</source>
          <target state="translated">ユーザーが出力したい言語を検出したいというのは、よくある問題です。</target>
        </trans-unit>
        <trans-unit id="84d9ffe2b782da4eace968e860a68bb94a1236cb" translate="yes" xml:space="preserve">
          <source>It is a fatal error if an operand contains a character whose ordinal value is above 0xFF, and hence not expressible except in UTF-8. The operation is performed on a non-UTF-8 copy for other operands encoded in UTF-8. See &lt;a href=&quot;perlunicode#Byte-and-Character-Semantics&quot;&gt;&quot;Byte and Character Semantics&quot; in perlunicode&lt;/a&gt;.</source>
          <target state="translated">オペランドに順序値が0xFFを超える文字が含まれているため、UTF-8以外では表現できない場合、致命的なエラーになります。この操作は、UTF-8でエンコードされた他のオペランドのUTF-8以外のコピーで実行されます。&lt;a href=&quot;perlunicode#Byte-and-Character-Semantics&quot;&gt;perlunicodeの「バイトと文字のセマンティクス」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0c07216f6ed146b3d5f5f41f5151571003ed974c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1950 data stream.</source>
          <target state="translated">&lt;code&gt;$output&lt;/code&gt; がRFC 1950データストリームでない場合にこのオプションを使用しようとすると、致命的なエラーになります。</target>
        </trans-unit>
        <trans-unit id="f26fad9b2ea8dad78ce0ae0159c499c446261e46" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1951 data stream.</source>
          <target state="translated">&lt;code&gt;$output&lt;/code&gt; がRFC 1951データストリームでない場合にこのオプションを使用しようとすると、致命的なエラーになります。</target>
        </trans-unit>
        <trans-unit id="f52e23ce1b9c7d458b13fea7c76a357d80aa0ef3" translate="yes" xml:space="preserve">
          <source>It is a fatal error to attempt to use this option when &lt;code&gt;$output&lt;/code&gt; is not an RFC 1952 data stream.</source>
          <target state="translated">&lt;code&gt;$output&lt;/code&gt; がRFC 1952データストリームでない場合にこのオプションを使用しようとすると、致命的なエラーになります。</target>
        </trans-unit>
        <trans-unit id="951fc5c4a5b5cf258c0f54c435f4794f721e0f6c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to call this function except in list context.</source>
          <target state="translated">リストコンテキスト以外でこの関数を呼び出すのは致命的なエラーです。</target>
        </trans-unit>
        <trans-unit id="84e04c4e01865ff456f52f410d5f957caeadfc3c" translate="yes" xml:space="preserve">
          <source>It is a fatal error to register a non-reference $obj. Any non-hashrefs among the following arguments are silently ignored.</source>
          <target state="translated">非参照 $obj を登録するのは致命的なエラーです。以下の引数のうち、ハッシュでないものは無視されます。</target>
        </trans-unit>
        <trans-unit id="62c55db6ed1bb1f62b509a530f9b2d3c904a4f20" translate="yes" xml:space="preserve">
          <source>It is a hash of hashes that is keyed on perl version. Each keyed hash will have the following keys:</source>
          <target state="translated">perlのバージョンでキーが設定されているハッシュです。それぞれの鍵付きハッシュは以下のような鍵を持ちます。</target>
        </trans-unit>
        <trans-unit id="25ddadae24c0653c00410eac3e43d9a6483af1b0" translate="yes" xml:space="preserve">
          <source>It is a little bit easier to do so while</source>
          <target state="translated">をしながら、少しだけ楽になりました。</target>
        </trans-unit>
        <trans-unit id="41ddae9f4920a415092a3be5fefb0262a7109fa2" translate="yes" xml:space="preserve">
          <source>It is a simple matter to expand out an inversion list to a full list of all code points that have the property-value:</source>
          <target state="translated">反転リストを展開して、そのプロパティ値を持つすべてのコードポイントの完全なリストにするのは簡単なことです。</target>
        </trans-unit>
        <trans-unit id="fa408a04e809363f2b269a35a2338df430b18e1f" translate="yes" xml:space="preserve">
          <source>It is a syntax error to use &lt;code&gt;\N{NAME}&lt;/code&gt; where &lt;code&gt;NAME&lt;/code&gt; is unknown.</source>
          <target state="translated">&lt;code&gt;\N{NAME}&lt;/code&gt; を使用するのは構文エラーで、 &lt;code&gt;NAME&lt;/code&gt; は不明です。</target>
        </trans-unit>
        <trans-unit id="3189cdee5a11207a5d4b78afa8dc9c2b8ecc076f" translate="yes" xml:space="preserve">
          <source>It is able to load multiple modules at once or none at all if one of them was not able to load. It also takes care of any error checking and so forth.</source>
          <target state="translated">複数のモジュールを一度にロードすることもできますし、1つのモジュールがロードできなかった場合は全くロードしないこともできます。また、エラーチェックなども行います。</target>
        </trans-unit>
        <trans-unit id="5224d6c644e7d334b02295922c6a21bf88351e6e" translate="yes" xml:space="preserve">
          <source>It is advised that formatnames match the regexp &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A:?[-a-zA-Z0-9_]+\z/&lt;/a&gt;&lt;/code&gt;. Everything following whitespace after the formatname is a parameter that may be used by the formatter when dealing with this region. This parameter must not be repeated in the &quot;=end&quot; paragraph. Implementors should anticipate future expansion in the semantics and syntax of the first parameter to &quot;=begin&quot;/&quot;=end&quot;/&quot;=for&quot;.</source>
          <target state="translated">形式名は正規表現 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A:?[-a-zA-Z0-9_]+\z/&lt;/a&gt;&lt;/code&gt; 一致することをお勧めします。formatnameの後の空白に続くものはすべて、この領域を処理するときにフォーマッターが使用できるパラメーターです。このパラメーターは、「= end」段落で繰り返すことはできません。実装者は、 &quot;= begin&quot; / &quot;= end&quot; / &quot;= for&quot;への最初のパラメーターのセマンティクスと構文の将来の拡張を予期する必要があります。</target>
        </trans-unit>
        <trans-unit id="e650500b6f0231025bf8e8986cda639228e156b4" translate="yes" xml:space="preserve">
          <source>It is advised that formatnames match the regexp &lt;code&gt;m/\A:?[-a-zA-Z0-9_]+\z/&lt;/code&gt;. Everything following whitespace after the formatname is a parameter that may be used by the formatter when dealing with this region. This parameter must not be repeated in the &quot;=end&quot; paragraph. Implementors should anticipate future expansion in the semantics and syntax of the first parameter to &quot;=begin&quot;/&quot;=end&quot;/&quot;=for&quot;.</source>
          <target state="translated">formatnamesは正規表現 &lt;code&gt;m/\A:?[-a-zA-Z0-9_]+\z/&lt;/code&gt; 一致することをお勧めします。formatnameの後の空白に続くすべては、この領域を処理するときにフォーマッターが使用できるパラメーターです。このパラメーターは、「= end」段落で繰り返さないでください。実装者は、最初のパラメーターのセマンティクスと構文が「= begin」/「= end」/「= for」に拡張されることを予測する必要があります。</target>
        </trans-unit>
        <trans-unit id="5bdc4a6dded231914c04e13e61b945f48f5268b4" translate="yes" xml:space="preserve">
          <source>It is also highly desirable that encoding classes inherit from &lt;code&gt;Encode::Encoding&lt;/code&gt; as a base class. This allows that class to define additional behaviour for all encoding objects.</source>
          <target state="translated">エンコーディングクラスが基本クラスとして &lt;code&gt;Encode::Encoding&lt;/code&gt; を継承することも非常に望ましいです。これにより、そのクラスはすべてのエンコーディングオブジェクトに対して追加の動作を定義できます。</target>
        </trans-unit>
        <trans-unit id="04e94392102301dd0cfd3e0e0b7cc900aa1df8a8" translate="yes" xml:space="preserve">
          <source>It is also hoped that the interface will cover the needs of OS/2, NT etc and also allow pseudo-dynamic linking (using &lt;code&gt;ld -A&lt;/code&gt; at runtime).</source>
          <target state="translated">また、インターフェイスがOS / 2、NTなどのニーズをカバーし、疑似動的リンクを可能にする（実行時に &lt;code&gt;ld -A&lt;/code&gt; を使用）ことも期待されます。</target>
        </trans-unit>
        <trans-unit id="c5a799ae9f844383ae213d6362def23a82f89603" translate="yes" xml:space="preserve">
          <source>It is also important to realize that these are default boundary definitions, and that implementations may wish to tailor the results for particular purposes and locales.</source>
          <target state="translated">また、これらはデフォルトの境界定義であり、実装によっては特定の目的やロケールに合わせて結果を調整したい場合があることを理解しておくことも重要です。</target>
        </trans-unit>
        <trans-unit id="71ce07ae3818cf03055cfa783a2edee6c6d417e8" translate="yes" xml:space="preserve">
          <source>It is also important to realize that these are default boundary definitions, and that implementations may wish to tailor the results for particular purposes and locales. For example, some languages, such as Japanese and Thai, require dictionary lookup to accurately determine word boundaries.</source>
          <target state="translated">また、これらはデフォルトの境界定義であり、特定の目的やロケールに合わせて結果を調整したい場合があることを理解しておくことも重要です。例えば、日本語やタイ語などの言語では、単語の境界を正確に決定するために辞書検索が必要な場合があります。</target>
        </trans-unit>
        <trans-unit id="f04f0bafdb5580f449ee2f59e8c42ace66bb7312" translate="yes" xml:space="preserve">
          <source>It is also possible for the reverse to happen: &lt;code&gt;prop_aliases('isc')&lt;/code&gt; returns the list &lt;code&gt;(isc, ISO_Comment)&lt;/code&gt; ; whereas &lt;code&gt;prop_aliases('c')&lt;/code&gt; returns &lt;code&gt;(C, Other)&lt;/code&gt; (the latter being a Perl extension meaning &lt;code&gt;General_Category=Other&lt;/code&gt; . &lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;Properties accessible through Unicode::UCD in perluniprops&lt;/a&gt; lists the available forms, including which ones are discouraged from use.</source>
          <target state="translated">逆のことが起こる可能性もあります： &lt;code&gt;prop_aliases('isc')&lt;/code&gt; はリスト &lt;code&gt;(isc, ISO_Comment)&lt;/code&gt; 返します。一方 &lt;code&gt;prop_aliases('c')&lt;/code&gt; 戻る &lt;code&gt;(C, Other)&lt;/code&gt; （後者は意味Perl拡張である &lt;code&gt;General_Category=Other&lt;/code&gt; 。&lt;a href=&quot;../perluniprops#Properties-accessible-through-Unicode%3a%3aUCD&quot;&gt;ユニコードを介してアクセス可能なプロパティ:: UCD perlunipropsの中に&lt;/a&gt;リストものを使用することから推奨される含む利用可能な形態。</target>
        </trans-unit>
        <trans-unit id="46b4ec4d35947f03a43a47b65cb8093dc3e99125" translate="yes" xml:space="preserve">
          <source>It is also possible for the reverse to happen: &lt;code&gt;prop_aliases('isc')&lt;/code&gt; returns the list &lt;code&gt;(isc, ISO_Comment)&lt;/code&gt;; whereas &lt;code&gt;prop_aliases('c')&lt;/code&gt; returns &lt;code&gt;(C, Other)&lt;/code&gt; (the latter being a Perl extension meaning &lt;code&gt;General_Category=Other&lt;/code&gt;. &lt;a href=&quot;perluniprops#Properties-accessible-through-Unicode%3A%3AUCD&quot;&gt;&quot;Properties accessible through Unicode::UCD&quot; in perluniprops&lt;/a&gt; lists the available forms, including which ones are discouraged from use.</source>
          <target state="translated">逆のことが起こる可能性もあります &lt;code&gt;prop_aliases('isc')&lt;/code&gt; はリスト &lt;code&gt;(isc, ISO_Comment)&lt;/code&gt; 返します。一方 &lt;code&gt;prop_aliases('c')&lt;/code&gt; 戻る &lt;code&gt;(C, Other)&lt;/code&gt; （後者は意味Perl拡張である &lt;code&gt;General_Category=Other&lt;/code&gt; 。&lt;a href=&quot;perluniprops#Properties-accessible-through-Unicode%3A%3AUCD&quot;&gt;perlunipropsの中の「Unicode :: UCDを介してアクセス可能なプロパティ」&lt;/a&gt;リストのものは使用が推奨される含む利用可能な形態。</target>
        </trans-unit>
        <trans-unit id="da8c00abb531749489f64809eab7af330894c553" translate="yes" xml:space="preserve">
          <source>It is also possible to generate Symbian executables for &quot;miniperl&quot; and &quot;perl&quot;, but since there is no standard command line interface for Symbian (nor full keyboards in the devices), these are useful mainly as demonstrations.</source>
          <target state="translated">miniperl&quot; と &quot;perl&quot; のための Symbian 実行ファイルを生成することも可能ですが、Symbian には標準的なコマンドラインインターフェイスがないので(デバイスにはフルキーボードもありません)、これらは主にデモンストレーションとして有用です。</target>
        </trans-unit>
        <trans-unit id="fba88eaeb368c964f0dd8f74cbc321efcbbc3751" translate="yes" xml:space="preserve">
          <source>It is also possible to have a complex number as either argument of the &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; : the appropriate component of the argument will be used.</source>
          <target state="translated">&lt;code&gt;make&lt;/code&gt; 、 &lt;code&gt;emake&lt;/code&gt; 、 &lt;code&gt;cplx&lt;/code&gt; 、および &lt;code&gt;cplxe&lt;/code&gt; のいずれかの引数として複素数を指定することもできます。引数の適切なコンポーネントが使用されます。</target>
        </trans-unit>
        <trans-unit id="5f695912980907c9e4ce8ee64fb36b966f74913d" translate="yes" xml:space="preserve">
          <source>It is also possible to have a complex number as either argument of the &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;emake&lt;/code&gt;, &lt;code&gt;cplx&lt;/code&gt;, and &lt;code&gt;cplxe&lt;/code&gt;: the appropriate component of the argument will be used.</source>
          <target state="translated">&lt;code&gt;make&lt;/code&gt; 、 &lt;code&gt;emake&lt;/code&gt; 、 &lt;code&gt;cplx&lt;/code&gt; 、および &lt;code&gt;cplxe&lt;/code&gt; のいずれかの引数として複素数を使用することもできます。引数の適切なコンポーネントが使用されます。</target>
        </trans-unit>
        <trans-unit id="b1daabab3a866899ef9c74e4b9b632751383e7e2" translate="yes" xml:space="preserve">
          <source>It is also possible to instead list the characters you do not want to match. You can do so by using a caret (&lt;code&gt;^&lt;/code&gt;) as the first character in the character class. For instance, &lt;code&gt;[^a-z]&lt;/code&gt; matches any character that is not a lowercase ASCII letter, which therefore includes more than a million Unicode code points. The class is said to be &quot;negated&quot; or &quot;inverted&quot;.</source>
          <target state="translated">代わりに、一致させたくない文字をリストすることもできます。これを行うには、キャレット（ &lt;code&gt;^&lt;/code&gt; ）を文字クラスの最初の文字として使用します。たとえば、 &lt;code&gt;[^a-z]&lt;/code&gt; は小文字のASCII文字ではないすべての文字に一致するため、100万を超えるUnicodeコードポイントが含まれます。クラスは「否定」または「反転」されていると言われます。</target>
        </trans-unit>
        <trans-unit id="d1b81a5a48e226bc85d367f9c052e3692ba4d679" translate="yes" xml:space="preserve">
          <source>It is also possible to just require Math::BigFloat:</source>
          <target state="translated">Math::BigFloatを要求するだけでも可能です。</target>
        </trans-unit>
        <trans-unit id="3fa6ca91de346d776bfa7cb7677e64152ae10a28" translate="yes" xml:space="preserve">
          <source>It is also possible to keep &lt;code&gt;origin&lt;/code&gt; as a git remote, and add a new remote for ssh access:</source>
          <target state="translated">&lt;code&gt;origin&lt;/code&gt; をgitリモートとして保持し、sshアクセス用の新しいリモートを追加することもできます。</target>
        </trans-unit>
        <trans-unit id="b0f73d924849030d9c9bafff98a0dd19b4f629df" translate="yes" xml:space="preserve">
          <source>It is also possible to omit the filename parameter as well, so the call:</source>
          <target state="translated">ファイル名のパラメータを省略することも可能なので、呼び出しは</target>
        </trans-unit>
        <trans-unit id="c92bd63c5290ef43a80924b5bd4775d90c01eb70" translate="yes" xml:space="preserve">
          <source>It is also possible to return values directly via the parameter list--whether it is actually desirable to do it is another matter entirely.</source>
          <target state="translated">パラメータリストから直接値を返すことも可能ですが、実際にそれが望ましいかどうかは別問題です。</target>
        </trans-unit>
        <trans-unit id="50a5455e17306f508cbf1a77905bc1e3511b26df" translate="yes" xml:space="preserve">
          <source>It is also possible to specify the minimal and maximal number of arguments an option takes. &lt;code&gt;foo=s{2,4}&lt;/code&gt; indicates an option that takes at least two and at most 4 arguments. &lt;code&gt;foo=s{1,}&lt;/code&gt; indicates one or more values; &lt;code&gt;foo:s{,}&lt;/code&gt; indicates zero or more option values.</source>
          <target state="translated">オプションが取る引数の最小数と最大数を指定することもできます。 &lt;code&gt;foo=s{2,4}&lt;/code&gt; は、少なくとも2つ、最大4つの引数を取るオプションを示します。 &lt;code&gt;foo=s{1,}&lt;/code&gt; は1つ以上の値を示します。 &lt;code&gt;foo:s{,}&lt;/code&gt; は0個以上のオプション値を示します。</target>
        </trans-unit>
        <trans-unit id="b77bfd84df66369a6b31eeda1a74a3114d66c160" translate="yes" xml:space="preserve">
          <source>It is also possible to test whether the pre-defined warnings categories are set in the calling module with the &lt;code&gt;warnings::enabled&lt;/code&gt; function. Consider this snippet of code:</source>
          <target state="translated">事前定義された警告カテゴリが、 &lt;code&gt;warnings::enabled&lt;/code&gt; 関数を使用して呼び出しモジュールで設定されているかどうかをテストすることもできます。次のコードスニペットを考えてみます。</target>
        </trans-unit>
        <trans-unit id="3db1f66552fc819722dedb12482e309bce26efa4" translate="yes" xml:space="preserve">
          <source>It is also unique in that all other Perl operators impose a context (usually string or numeric context) on their operands, autoconverting those operands to those imposed contexts. In contrast, smartmatch</source>
          <target state="translated">また、他のすべてのPerl演算子は、そのオペランドにコンテキスト(通常は文字列や数値のコンテキスト)を課し、それらのオペランドを課されたコンテキストに自動変換するという点でもユニークです。対照的に、スマートマッチ</target>
        </trans-unit>
        <trans-unit id="fac8d72d737b1435638a2eef2e2bc6f98342f178" translate="yes" xml:space="preserve">
          <source>It is also worth noting that &lt;code&gt;nextStream&lt;/code&gt; can be called at any time -- you don't have to wait until you have exhausted a compressed data stream before skipping to the next one.</source>
          <target state="translated">また、 &lt;code&gt;nextStream&lt;/code&gt; はいつでも呼び出すことができることにも注意してください。次のデータストリームにスキップする前に、圧縮されたデータストリームを使い果たすまで待つ必要はありません。</target>
        </trans-unit>
        <trans-unit id="fe6480e97532361598fcacd4a646c8dd90b848cc" translate="yes" xml:space="preserve">
          <source>It is an error to refer to a name not defined by a &lt;code&gt;(?&amp;lt;&lt;i&gt;NAME&lt;/i&gt;&amp;gt;)&lt;/code&gt; earlier in the pattern.</source>
          <target state="translated">パターンの前半で &lt;code&gt;(?&amp;lt;&lt;i&gt;NAME&lt;/i&gt;&amp;gt;)&lt;/code&gt; 定義されていない名前を参照するとエラーになります。</target>
        </trans-unit>
        <trans-unit id="acc49eaced7d721523b5bd759190363e32250fa1" translate="yes" xml:space="preserve">
          <source>It is an error to refer to a name not defined by a &lt;code&gt;(?&amp;lt;NAME&amp;gt;)&lt;/code&gt; earlier in the pattern.</source>
          <target state="translated">パターンの前の &lt;code&gt;(?&amp;lt;NAME&amp;gt;)&lt;/code&gt; で定義されていない名前を参照すると、エラーになります。</target>
        </trans-unit>
        <trans-unit id="13ee6665661c6d90800f41308ee104afc7c23af8" translate="yes" xml:space="preserve">
          <source>It is an error to refer to a name that is not declared somewhere in the pattern.</source>
          <target state="translated">パターンのどこかで宣言されていない名前を参照するのはエラーです。</target>
        </trans-unit>
        <trans-unit id="65cfdd54d892c74c51301f814a65bd9d932d410a" translate="yes" xml:space="preserve">
          <source>It is an error to try to</source>
          <target state="translated">をしようとするとエラーになります。</target>
        </trans-unit>
        <trans-unit id="2f0a90fe17f957e846e3b518ba860308d4237cf1" translate="yes" xml:space="preserve">
          <source>It is assumed that if a module name is supplied, that that name matches the file name. Pods are not opened to check for the 'NAME' entry.</source>
          <target state="translated">モジュール名が与えられた場合、その名前がファイル名と一致すると仮定しています。ポッドは 'NAME' エントリをチェックするためには開かれません。</target>
        </trans-unit>
        <trans-unit id="c5af0c152794fef2b12ee8e78572d2cb96b0bb53" translate="yes" xml:space="preserve">
          <source>It is at this stage that &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; silently optimizes &lt;code&gt;/^/&lt;/code&gt; to mean &lt;code&gt;/^/m&lt;/code&gt; .</source>
          <target state="translated">この段階で、 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; はサイレントに &lt;code&gt;/^/&lt;/code&gt; を最適化して &lt;code&gt;/^/m&lt;/code&gt; を意味します。</target>
        </trans-unit>
        <trans-unit id="0f53779f0c0d37544de988c790844edfe4fdb773" translate="yes" xml:space="preserve">
          <source>It is at this stage that &lt;code&gt;split()&lt;/code&gt; silently optimizes &lt;code&gt;/^/&lt;/code&gt; to mean &lt;code&gt;/^/m&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;split()&lt;/code&gt; が &lt;code&gt;/^/&lt;/code&gt; を &lt;code&gt;/^/m&lt;/code&gt; を意味するようにサイレントに最適化するのはこの段階です。</target>
        </trans-unit>
        <trans-unit id="c8c668d4a29eb47ae15a72aa4d1dd8cfb718abf5" translate="yes" xml:space="preserve">
          <source>It is at this step that &lt;code&gt;\1&lt;/code&gt; is begrudgingly converted to &lt;code&gt;$1&lt;/code&gt; in the replacement text of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, in order to correct the incorrigible</source>
          <target state="translated">このステップでは、 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 置換テキストで &lt;code&gt;\1&lt;/code&gt; が不本意ながら &lt;code&gt;$1&lt;/code&gt; に変換され、不正解を修正します。</target>
        </trans-unit>
        <trans-unit id="5668f9f099405dc43b82952ae4d9de3551af43ad" translate="yes" xml:space="preserve">
          <source>It is at this step that &lt;code&gt;\1&lt;/code&gt; is begrudgingly converted to &lt;code&gt;$1&lt;/code&gt; in the replacement text of &lt;code&gt;s///&lt;/code&gt;, in order to correct the incorrigible</source>
          <target state="translated">この段階で、 &lt;code&gt;s///&lt;/code&gt; 置換テキストで、不可解なものを修正するために、 &lt;code&gt;\1&lt;/code&gt; がしぶしぶ &lt;code&gt;$1&lt;/code&gt; に変換されます。</target>
        </trans-unit>
        <trans-unit id="4466ca0969a2662c5b072bf7cd93ebda9f966a8c" translate="yes" xml:space="preserve">
          <source>It is basically equivalent to:</source>
          <target state="translated">基本的にはこれに相当します。</target>
        </trans-unit>
        <trans-unit id="d3008b3fc272ebfbc9d46dd564fe851829fe13a2" translate="yes" xml:space="preserve">
          <source>It is better to restructure your code so the end pointer is passed down so that you know what it actually is at the point of this call, but if that isn't possible, &lt;a href=&quot;#UTF8_CHK_SKIP&quot;&gt;&quot;&lt;code&gt;UTF8_CHK_SKIP&lt;/code&gt;&quot;&lt;/a&gt; can minimize the chance of accessing beyond the end of the input buffer.</source>
          <target state="translated">この呼び出しの時点で実際に何であるかがわかるように、エンドポインターが渡されるようにコードを再構築することをお勧めしますが、それが不可能な場合は、&lt;a href=&quot;#UTF8_CHK_SKIP&quot;&gt;「 &lt;code&gt;UTF8_CHK_SKIP&lt;/code&gt; 」を&lt;/a&gt;使用すると、の終わりを超えてアクセスする可能性を最小限に抑えることができます。入力バッファ。</target>
        </trans-unit>
        <trans-unit id="c77b015f95e7c8d0f9144f6b141dfe36a63eb292" translate="yes" xml:space="preserve">
          <source>It is clear that inline code is going to be faster than subroutine or method calls, because there is less overhead, but this approach has the disadvantage of being less maintainable and comes at the cost of greater memory usage - there is no such thing as a free lunch. If you are searching for an element in a list, it can be more efficient to store the data in a hash structure, and then simply look to see whether the key is defined, rather than to loop through the entire array using grep() for instance. substr() may be (a lot) faster than grep() but not as flexible, so you have another trade-off to access. Your code may contain a line which takes 0.01 of a second to execute which if you call it 1,000 times, quite likely in a program parsing even medium sized files for instance, you already have a 10 second delay, in just one single code location, and if you call that line 100,000 times, your entire program will slow down to an unbearable crawl.</source>
          <target state="translated">インラインコードがサブルーチンやメソッド呼び出しよりも高速であることは明らかですが、このアプローチは保守性が低く、メモリ使用量が多くなるという欠点があります。リストの要素を探している場合は、例えば grep()を使って配列全体をループするよりも、 ハッシュ構造体にデータを格納して、キーが定義されているかどうかを単純に調べた方が効率的かもしれません。あなたのコードには、実行に0.01秒かかる行が含まれているかもしれません。これを1,000回呼び出すと、例えば中程度のサイズのファイルを解析するプログラムでは、一つのコードの場所だけで10秒の遅延が発生します。</target>
        </trans-unit>
        <trans-unit id="f6122f662407715d120a73ec05bd2bbbf07e1b28" translate="yes" xml:space="preserve">
          <source>It is common to simply say &lt;code&gt;$filename = Pod::Simple::Search-&amp;gt; new
-&amp;gt;find(&quot;perlvar&quot;)&lt;/code&gt; so that just the @INC (well, and scriptdir) directories are searched. (This happens because the &lt;code&gt;inc&lt;/code&gt; attribute is true by default.)</source>
          <target state="translated">&lt;code&gt;$filename = Pod::Simple::Search-&amp;gt; new -&amp;gt;find(&quot;perlvar&quot;)&lt;/code&gt; と単純に言うのが一般的であるため、@ INC（wellおよびscriptdir）ディレクトリのみが検索されます。（これは、 &lt;code&gt;inc&lt;/code&gt; 属性がデフォルトでtrueになっているために発生します。）</target>
        </trans-unit>
        <trans-unit id="94fd6736ac13c38aadc8d6ee40bf099cf30a2334" translate="yes" xml:space="preserve">
          <source>It is commonly thought that if a system does not have the capability to dynamically load a library, you cannot build XSUBs. This is incorrect. You</source>
          <target state="translated">一般的に、システムがライブラリを動的にロードする機能を持っていない場合、XSUBを構築することはできないと考えられています。これは正しくありません。あなたは</target>
        </trans-unit>
        <trans-unit id="7b3776ce40b36ce2eb6604faa164797c0a666707" translate="yes" xml:space="preserve">
          <source>It is convenient to think that the indirection operator &lt;code&gt;*&lt;/code&gt; should be considered as a part of the type and the address operator &lt;code&gt;&amp;amp;&lt;/code&gt; should be considered part of the variable. See &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; for more info about handling qualifiers and unary operators in C types.</source>
          <target state="translated">間接演算子 &lt;code&gt;*&lt;/code&gt; は型の一部と見なし、アドレス演算子 &lt;code&gt;&amp;amp;&lt;/code&gt; は変数の一部と見なす必要があると考えると便利です。C型での修飾子と単項演算子の処理の詳細については、&lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e49556be27809812b1f952c88dbd0fb8ac73080a" translate="yes" xml:space="preserve">
          <source>It is conventional to start layer names with a colon (for example, &lt;code&gt;:perlio&lt;/code&gt; ) to emphasize their similarity to variable &quot;attributes&quot;. But the code that parses layer specification strings, which is also used to decode the PERLIO environment variable, treats the colon as a separator.</source>
          <target state="translated">変数名「属性」との類似性を強調するために、レイヤー名をコロン（ &lt;code&gt;:perlio&lt;/code&gt; など）で始めるのが一般的です。ただし、PERLIO環境変数のデコードにも使用されるレイヤー指定文字列を解析するコードは、コロンを区切り文字として扱います。</target>
        </trans-unit>
        <trans-unit id="0a6add6b8448b0bfc8e6cd8b6eca23cb56fc1aa2" translate="yes" xml:space="preserve">
          <source>It is conventional to start layer names with a colon (for example, &lt;code&gt;:perlio&lt;/code&gt;) to emphasize their similarity to variable &quot;attributes&quot;. But the code that parses layer specification strings, which is also used to decode the PERLIO environment variable, treats the colon as a separator.</source>
          <target state="translated">変数の「属性」との類似性を強調するために、レイヤー名をコロン（たとえば &lt;code&gt;:perlio&lt;/code&gt; ）で始めるのが一般的です。ただし、PERLIO環境変数のデコードにも使用されるレイヤー仕様文字列を解析するコードは、コロンを区切り文字として扱います。</target>
        </trans-unit>
        <trans-unit id="9ddbcb8555d7ffc2811c34458dc5e23aebe16a93" translate="yes" xml:space="preserve">
          <source>It is eagerly hoped that in the future, increasing numbers of formats (and formatters) will support Unicode characters directly (as (X)HTML does with &lt;code&gt;&amp;amp;infin;&lt;/code&gt; , &lt;code&gt;&amp;amp;#8734;&lt;/code&gt;, or &lt;code&gt;&amp;amp;#x221E;&lt;/code&gt;), reducing the need for idiosyncratic mappings of Unicode-to-</source>
          <target state="translated">将来的には、（（X）HTMLが &lt;code&gt;&amp;amp;infin;&lt;/code&gt; 、 &lt;code&gt;&amp;amp;#8734;&lt;/code&gt; 、または &lt;code&gt;&amp;amp;#x221E;&lt;/code&gt; で（X）HTMLがサポートするように）ますます多くのフォーマット（およびフォーマッター）がUnicode文字をサポートし、特異性の必要性を減らすことが切望されています Unicode-to-のマッピング</target>
        </trans-unit>
        <trans-unit id="11bfea9ea83d9dc8ba6d1c8b2251fc92f5e63836" translate="yes" xml:space="preserve">
          <source>It is eagerly hoped that in the future, increasing numbers of formats (and formatters) will support Unicode characters directly (as (X)HTML does with &lt;code&gt;&amp;amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;amp;#8734;&lt;/code&gt;, or &lt;code&gt;&amp;amp;#x221E;&lt;/code&gt;), reducing the need for idiosyncratic mappings of Unicode-to-</source>
          <target state="translated">将来的には、ますます多くのフォーマット（およびフォーマッター）がUnicode文字を直接サポートし（（X）HTMLが &lt;code&gt;&amp;amp;infin;&lt;/code&gt; 、 &lt;code&gt;&amp;amp;#8734;&lt;/code&gt; 、または &lt;code&gt;&amp;amp;#x221E;&lt;/code&gt; で行うように）、特異なものの必要性を減らすことが強く望まれます。 Unicodeから-へのマッピング</target>
        </trans-unit>
        <trans-unit id="1feb840e61338fb8d69eab115197ceb6e4d8f195" translate="yes" xml:space="preserve">
          <source>It is easier to see with comments:</source>
          <target state="translated">コメントがあると見やすいです。</target>
        </trans-unit>
        <trans-unit id="deebd2bf2cb329548cf17163d065366c59ebd497" translate="yes" xml:space="preserve">
          <source>It is entirely possible for a subroutine to have both a prototype and a signature. They do different jobs: the prototype affects compilation of calls to the subroutine, and the signature puts argument values into lexical variables at runtime. You can therefore write</source>
          <target state="translated">サブルーチンがプロトタイプとシグネチャの両方を持つことは完全に可能です。プロトタイプはサブルーチンの呼び出しのコンパイルに影響を与え、シグネチャは実行時に引数の値を辞書変数に格納します。したがって、次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="63ae6e7127f1e6349a2992ac6b857022220dd1af" translate="yes" xml:space="preserve">
          <source>It is even possible to give your own names to characters and character sequences by using the &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt; module. These custom names are lexically scoped, and so a given code point may have different names in different scopes. The name used is what is in effect at the time the &lt;code&gt;\N{}&lt;/code&gt; is expanded. For patterns in double-quotish context, that means at the time the pattern is parsed. But for patterns that are delimitted by single quotes, the expansion is deferred until pattern compilation time, which may very well have a different &lt;code&gt;charnames&lt;/code&gt; translator in effect.</source>
          <target state="translated">&lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;モジュールを使用して、文字や文字シーケンスに独自の名前を付けることもできます。これらのカスタム名は字句スコープであるため、特定のコードポイントのスコープが異なる場合があります。使用される名前は、 &lt;code&gt;\N{}&lt;/code&gt; が展開されたときに有効な名前です。二重引用符のコンテキストのパターンの場合、それはパターンが解析される時点を意味します。ただし、一重引用符で囲まれたパターンの場合、展開はパターンのコンパイル時まで延期されます。これにより、異なる &lt;code&gt;charnames&lt;/code&gt; トランスレータが有効になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="e8705c44d271d802e23ff6717b34393b3365f69d" translate="yes" xml:space="preserve">
          <source>It is even possible to give your own names to characters and character sequences. For details, see &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;.</source>
          <target state="translated">文字や文字列に独自の名前を付けることもできます。詳細については、&lt;a href=&quot;charnames&quot;&gt;charnamesを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4c3622fe65f713ae38110b205b49d3188003c82c" translate="yes" xml:space="preserve">
          <source>It is expected that arguments to methods that are not explicitly supposed to be changed are constant (but this is not enforced).</source>
          <target state="translated">明示的に変更されることが想定されていないメソッドの引数は一定であることが期待されています (ただし、これは強制されていません)。</target>
        </trans-unit>
        <trans-unit id="776c3073c10966ce7532e508c1ba6620f8fcb74a" translate="yes" xml:space="preserve">
          <source>It is expected that what exactly &lt;code&gt;'strict'&lt;/code&gt; does will evolve over time as we gain experience with it. This means that programs that compile under it in today's Perl may not compile, or may have more or fewer warnings, in future Perls. There is no backwards compatibility promises with regards to it. Also there are already proposals for an alternate syntax for enabling it. For these reasons, using it will raise a &lt;code&gt;experimental::re_strict&lt;/code&gt; class warning, unless that category is turned off.</source>
          <target state="translated">厳密に &lt;code&gt;'strict'&lt;/code&gt; ことは、経験を積むにつれて時間とともに進化することが予想されます。つまり、今日のPerlでその下でコンパイルされるプログラムは、将来のPerlではコンパイルされないか、警告の数が増減する可能性があります。それに関して後方互換性の約束はありません。また、それを有効にするための代替構文の提案もすでにあります。これらの理由により、このカテゴリをオフにしない限り、これを使用すると、 &lt;code&gt;experimental::re_strict&lt;/code&gt; クラスの警告が発生します。</target>
        </trans-unit>
        <trans-unit id="743ffcd338b65d877bd2bc22191ffd5f5bc78800" translate="yes" xml:space="preserve">
          <source>It is exported upon request.</source>
          <target state="translated">ご要望に応じてエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="fc922ccc86e1ddfa603184a6c1df119e90d551a2" translate="yes" xml:space="preserve">
          <source>It is generally a bad idea to mix non-UTF-8 locales and Unicode, and this issue is one of the reasons why. This warning is raised when Unicode rules would normally cause the result of this operation to contain a character that is in the range specified by the locale, 0..255, and hence is subject to the locale's rules, not Unicode's.</source>
          <target state="translated">一般に、UTF-8 以外のロケールと Unicode を混在させることはよくない考えであり、この問題はその理由のひとつです。この警告は、Unicode のルールにより、通常はこの操作の結果にロケールで指定された 0 ~ 255 の範囲内の文字が含まれている場合に発生します。</target>
        </trans-unit>
        <trans-unit id="4425fdf4018e2e8fba242ccf31d9fb769e12dacd" translate="yes" xml:space="preserve">
          <source>It is guaranteed that</source>
          <target state="translated">それは保証されています。</target>
        </trans-unit>
        <trans-unit id="a6f4741397b5a8e1cbfacb47c2230423a05f8010" translate="yes" xml:space="preserve">
          <source>It is guaranteed that an</source>
          <target state="translated">が保証されています。</target>
        </trans-unit>
        <trans-unit id="13b4603391d295cad7c663188ece67a47ecf1dc6" translate="yes" xml:space="preserve">
          <source>It is hard to understand without digging what exactly matches ranges other than subsets of &lt;code&gt;[A-Z]&lt;/code&gt; , &lt;code&gt;[a-z]&lt;/code&gt; , and &lt;code&gt;[0-9]&lt;/code&gt; . A sound principle is to use only ranges that begin from and end at either alphabetics of equal case ([a-e], [A-E]), or digits ([0-9]). Anything else is unsafe or unclear. If in doubt, spell out the range in full.</source>
          <target state="translated">&lt;code&gt;[A-Z]&lt;/code&gt; 、 &lt;code&gt;[a-z]&lt;/code&gt; 、および &lt;code&gt;[0-9]&lt;/code&gt; のサブセット以外の範囲に正確に一致するものを掘り下げることなく理解することは困難です。正しい原則は、大文字と小文字が等しい（[ae]、[AE]）、または数字（[0-9]）で開始および終了する範囲のみを使用することです。それ以外のものは、安全でないか不明確です。疑問がある場合は、範囲全体を詳しく説明してください。</target>
        </trans-unit>
        <trans-unit id="32102cc598d5c6f1883220e9be88e26b0126c4bb" translate="yes" xml:space="preserve">
          <source>It is highly recommended to use the new interface.</source>
          <target state="translated">新しいインターフェイスを使用することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="ca5fa5ba1e81b193ad6d8416f6d80a9e68a2d380" translate="yes" xml:space="preserve">
          <source>It is however guaranteed that backslash or escape sequences never have a punctuation character following the backslash, not now, and not in a future version of Perl 5. So it is safe to put a backslash in front of a non-word character.</source>
          <target state="translated">しかし、バックスラッシュやエスケープシーケンスの後に句読点文字が続くことはないことが保証されています。 現在も、Perl 5 の将来のバージョンでも、バックスラッシュを単語以外の文字の前に置いても安全です。</target>
        </trans-unit>
        <trans-unit id="77f0274e9c470893b80643add674cf709738754d" translate="yes" xml:space="preserve">
          <source>It is implemented using the standard perl TIEHASH interface. Please see the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; entry in perlfunc(1) and perltie(1) for more information.</source>
          <target state="translated">標準のperl TIEHASHインターフェイスを使用して実装されます。詳細については、perlfunc（1）およびperltie（1）の &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; エントリを参照してください。</target>
        </trans-unit>
        <trans-unit id="af6e31eac027382e54503e05f6d0085165cacf75" translate="yes" xml:space="preserve">
          <source>It is implemented using the standard perl TIEHASH interface. Please see the &lt;code&gt;tie&lt;/code&gt; entry in perlfunc(1) and perltie(1) for more information.</source>
          <target state="translated">これは、標準のperlTIEHASHインターフェースを使用して実装されます。詳細については、perlfunc（1）およびperltie（1）の &lt;code&gt;tie&lt;/code&gt; エントリを参照してください。</target>
        </trans-unit>
        <trans-unit id="53ed786f282bde3aa8de3b1b643efa3bb560a2fd" translate="yes" xml:space="preserve">
          <source>It is important that you read the &lt;a href=&quot;opcode&quot;&gt;Opcode&lt;/a&gt; module documentation for more information, especially for detailed definitions of opnames, optags and opsets.</source>
          <target state="translated">詳細については、特にopname、optags、opsetsの詳細な定義については、&lt;a href=&quot;opcode&quot;&gt;Opcode&lt;/a&gt;モジュールのドキュメントを読むことが重要です。</target>
        </trans-unit>
        <trans-unit id="2977106e878eb3427358dec08f1824351409ba37" translate="yes" xml:space="preserve">
          <source>It is important that you use a supported 'make' program, and ensure Config.pm knows about it. If you don't have nmake, you can either get dmake from the location mentioned earlier or get an old version of nmake reportedly available from:</source>
          <target state="translated">サポートされている 'make' プログラムを使い、Config.pm がそれを知っていることを確認することが重要です。nmake を持っていない場合は、前述の場所から dmake を入手するか、古いバージョンの nmake を以下から入手することができます。</target>
        </trans-unit>
        <trans-unit id="ff64ea14bb1b01f98f924406ee57c3ed5e8b95d4" translate="yes" xml:space="preserve">
          <source>It is important to do &lt;code&gt;make dist&lt;/code&gt; as early as possible. This way you can easily merge(1) your changes to autogenerated files if you decide to edit your &lt;code&gt;.h&lt;/code&gt; files and rerun h2xs.</source>
          <target state="translated">&lt;code&gt;make dist&lt;/code&gt; をできるだけ早く行うことが重要です。これにより、 &lt;code&gt;.h&lt;/code&gt; ファイルを編集してh2xsを再実行する場合に、変更を自動生成されたファイルに簡単にマージ（1）できます。</target>
        </trans-unit>
        <trans-unit id="a9a567c14d6791400f926d0994fcc8f3b056f648" translate="yes" xml:space="preserve">
          <source>It is important to know that these CLIs may behave different when the command line contains special characters, in particular quotes or backslashes. For example, with Unix shells you can use single quotes (&lt;code&gt;'&lt;/code&gt;) and double quotes (&lt;code&gt;&quot;&lt;/code&gt;) to group words together. The following alternatives are equivalent on Unix:</source>
          <target state="translated">コマンドラインに特殊文字、特に引用符やバックスラッシュが含まれている場合、これらのCLIの動作が異なる場合があることを知っておくことが重要です。たとえば、Unixシェルでは、一重引用符（ &lt;code&gt;'&lt;/code&gt; ）と二重引用符（ &lt;code&gt;&quot;&lt;/code&gt; ）を使用して単語をグループ化できます。Unixでは、次の代替案は同等です。</target>
        </trans-unit>
        <trans-unit id="dcb1aa33844e3457c736e676b2e42e15c5425cfa" translate="yes" xml:space="preserve">
          <source>It is important to note that the variable can be notified even if no thread &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; on the variable. It is therefore important to check the value of the variable and go back to waiting if the requirement is not fulfilled. For example, to pause until a shared counter drops to zero:</source>
          <target state="translated">変数にスレッド &lt;code&gt;cond_signal&lt;/code&gt; または &lt;code&gt;cond_broadcast&lt;/code&gt; がない場合でも、変数に通知できることに注意することが重要です。したがって、変数の値を確認し、要件が満たされていない場合は待機に戻ることが重要です。たとえば、共有カウンターがゼロになるまで一時停止するには：</target>
        </trans-unit>
        <trans-unit id="38610253c48ac1bf013b9d6e4c9a87cd05da4c30" translate="yes" xml:space="preserve">
          <source>It is important to note that when called with an item that is recovered by using &lt;code&gt;localeconv&lt;/code&gt;, the buffer from any previous explicit call to &lt;code&gt;localeconv&lt;/code&gt; will be overwritten. This means you must save that buffer's contents if you need to access them after a call to this function. (But note that you might not want to be using &lt;code&gt;localeconv()&lt;/code&gt; directly anyway, because of issues like the ones listed in the second item of this list (above) for &lt;code&gt;RADIXCHAR&lt;/code&gt; and &lt;code&gt;THOUSEP&lt;/code&gt;. You can use the methods given in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; to call &lt;a href=&quot;posix#localeconv&quot;&gt;&quot;localeconv&quot; in POSIX&lt;/a&gt; and avoid all the issues, but then you have a hash to unpack).</source>
          <target state="translated">&lt;code&gt;localeconv&lt;/code&gt; を使用して回復されたアイテムで呼び出された場合、 &lt;code&gt;localeconv&lt;/code&gt; への以前の明示的な呼び出しからのバッファーが上書きされることに注意することが重要です。つまり、この関数の呼び出し後にバッファにアクセスする必要がある場合は、そのバッファの内容を保存する必要があります。 （しかし、あなたが使用することしたくない場合がありますのでご注意 &lt;code&gt;localeconv()&lt;/code&gt; 理由のために、このリスト（上記）の第二号に掲げるもののような問題のため、直接とにかく &lt;code&gt;RADIXCHAR&lt;/code&gt; と &lt;code&gt;THOUSEP&lt;/code&gt; 。あなたには与えられた方法で使用することができます&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;コールにします&lt;a href=&quot;posix#localeconv&quot;&gt;」 POSIXのlocaleconv」を使用して&lt;/a&gt;すべての問題を回避しますが、解凍するハッシュがあります）。</target>
        </trans-unit>
        <trans-unit id="07be512ccc5c73682b884e92456cd275f3ff5ced" translate="yes" xml:space="preserve">
          <source>It is important to realize when you use these Unicode boundaries, that you are taking a risk that a future version of Perl which contains a later version of the Unicode Standard will not work precisely the same way as it did when your code was written. These rules are not considered stable and have been somewhat more subject to change than the rest of the Standard. Unicode reserves the right to change them at will, and Perl reserves the right to update its implementation to Unicode's new rules. In the past, some changes have been because new characters have been added to the Standard which have different characteristics than all previous characters, so new rules are formulated for handling them. These should not cause any backward compatibility issues. But some changes have changed the treatment of existing characters because the Unicode Technical Committee has decided that the change is warranted for whatever reason. This could be to fix a bug, or because they think better results are obtained with the new rule.</source>
          <target state="translated">これらの Unicode 境界線を使用する際に重要なことは、Unicode 標準の後のバージョンを含む Perl の将来のバージョンでは、あなたのコードが書かれた時と正確に同じように動作しないリスクを負っているということを認識しておくことです。これらの規則は安定しているとは考えられず、標準規格の他の部分よりも変更されやすいものです。Unicode はこれらを自由に変更する権利を留保し、Perl は Unicode の新しいルールに合わせて実装を更新する権利を留保します。過去には、いくつかの変更は、以前のすべての文字とは異なる特性を持つ新しい文字が標準に追加されたため、それらを扱うための新しい規則が策定されたことに起因しています。これらによって下位互換性の問題が生じることはないはずです。しかし、Unicode技術委員会が何らかの理由で変更が必要だと判断したために、既存の文字の扱いを変更したものもあります。これは、バグを修正するためだったり、新しいルールの方がより良い結果が得られると考えたためだったりします。</target>
        </trans-unit>
        <trans-unit id="6b377275b56d69ca0e60d3e0cbc10a16f405fe04" translate="yes" xml:space="preserve">
          <source>It is important to remember that &lt;code&gt;yield()&lt;/code&gt; is only a hint to give up the CPU, it depends on your hardware, OS and threading libraries what actually happens. &lt;b&gt;On many operating systems, yield() is a no-op.&lt;/b&gt; Therefore it is important to note that one should not build the scheduling of the threads around &lt;code&gt;yield()&lt;/code&gt; calls. It might work on your platform but it won't work on another platform.</source>
          <target state="translated">&lt;code&gt;yield()&lt;/code&gt; はCPUをあきらめるためのヒントにすぎず、実際に何が発生するかはハードウェア、OS、およびスレッド化ライブラリに依存することを覚えておくことが重要です。&lt;b&gt;多くのオペレーティングシステムでは、yield（）は何もしません。&lt;/b&gt;したがって、 &lt;code&gt;yield()&lt;/code&gt; 呼び出しの周りのスレッドのスケジューリングを構築してはならないことに注意することが重要です。お使いのプラットフォームでは動作する可能性がありますが、別のプラットフォームでは動作しません。</target>
        </trans-unit>
        <trans-unit id="229373f44a4516dbdfee3cc1ec19491aa465bff2" translate="yes" xml:space="preserve">
          <source>It is intended mainly for use in assignments to references (see &lt;a href=&quot;#Assigning-to-References&quot;&gt;&quot;Assigning to References&quot;&lt;/a&gt;, above). It also allows the backslash to be used on just some items in a list of declared variables:</source>
          <target state="translated">これは主に参照への割り当てで使用することを目的としています（上記の&lt;a href=&quot;#Assigning-to-References&quot;&gt;「参照への割り当て」を参照&lt;/a&gt;）。また、宣言された変数のリスト内の一部の項目にバックスラッシュを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="bb902098169f8bf10c78af87761104595e279d51" translate="yes" xml:space="preserve">
          <source>It is intended to be called in this manner:</source>
          <target state="translated">このように呼ばれることを意図しています。</target>
        </trans-unit>
        <trans-unit id="c0729952a79f213dacf0ff4ae76e571d0559ed54" translate="yes" xml:space="preserve">
          <source>It is just like &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr_error&quot;&gt;&quot;utf8n_to_uvchr_error&quot;&lt;/a&gt;&lt;/code&gt; but it takes an extra parameter placed after all the others, &lt;code&gt;msgs&lt;/code&gt;. If this parameter is 0, this function behaves identically to &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr_error&quot;&gt;&quot;utf8n_to_uvchr_error&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise, &lt;code&gt;msgs&lt;/code&gt; should be a pointer to an &lt;code&gt;AV *&lt;/code&gt; variable, in which this function creates a new AV to contain any appropriate messages. The elements of the array are ordered so that the first message that would have been displayed is in the 0th element, and so on. Each element is a hash with three key-value pairs, as follows:</source>
          <target state="translated">それはちょうどのようなものです &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr_error&quot;&gt;&quot;utf8n_to_uvchr_error&quot;&lt;/a&gt;&lt;/code&gt; が、それは他のすべて、後に配置し、余分なパラメータ取る &lt;code&gt;msgs&lt;/code&gt; 。このパラメーターが0の場合、この関数は &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr_error&quot;&gt;&quot;utf8n_to_uvchr_error&quot;&lt;/a&gt;&lt;/code&gt; と同じように動作します。それ以外の場合、 &lt;code&gt;msgs&lt;/code&gt; は &lt;code&gt;AV *&lt;/code&gt; 変数へのポインターである必要があります。この変数では、この関数が適切なメッセージを含む新しいAVを作成します。配列の要素は、表示される最初のメッセージが0番目の要素にあるように順序付けられます。各要素は、次のように3つのキーと値のペアを持つハッシュです。</target>
        </trans-unit>
        <trans-unit id="55b304ade153185375df945a6e52ec74226ffc08" translate="yes" xml:space="preserve">
          <source>It is just like &lt;code&gt;&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot;&lt;/a&gt;&lt;/code&gt; but it takes an extra parameter placed after all the others, &lt;code&gt;msgs&lt;/code&gt;. If this parameter is 0, this function behaves identically to &lt;code&gt;&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise, &lt;code&gt;msgs&lt;/code&gt; should be a pointer to an &lt;code&gt;HV *&lt;/code&gt; variable, in which this function creates a new HV to contain any appropriate messages. The hash has three key-value pairs, as follows:</source>
          <target state="translated">それはちょうどのようなものです &lt;code&gt;&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot;&lt;/a&gt;&lt;/code&gt; が、それは他のすべて、後に配置し、余分なパラメータ取る &lt;code&gt;msgs&lt;/code&gt; 。このパラメーターが0の場合、この関数は &lt;code&gt;&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot;&lt;/a&gt;&lt;/code&gt; と同じように動作します。それ以外の場合、 &lt;code&gt;msgs&lt;/code&gt; は &lt;code&gt;HV *&lt;/code&gt; 変数へのポインターである必要があります。この変数では、この関数が適切なメッセージを含む新しいHVを作成します。ハッシュには、次の3つのキーと値のペアがあります。</target>
        </trans-unit>
        <trans-unit id="6c67b173e9f7ca15b0d9849fa732dc6b9c27b1b9" translate="yes" xml:space="preserve">
          <source>It is legal to intermix calls to &lt;code&gt;gzread&lt;/code&gt; and &lt;code&gt;gzreadline&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;gzread&lt;/code&gt; と &lt;code&gt;gzreadline&lt;/code&gt; の呼び出しを混在させることは合法です。</target>
        </trans-unit>
        <trans-unit id="310546f36d0b89e4ca2512f6a8bbbc58b3213ebb" translate="yes" xml:space="preserve">
          <source>It is legal to intermix calls to &lt;code&gt;gzread&lt;/code&gt; and &lt;code&gt;gzreadline&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gzread&lt;/code&gt; と &lt;code&gt;gzreadline&lt;/code&gt; への呼び出しを混在させることは合法です。</target>
        </trans-unit>
        <trans-unit id="b081e40b0dd1e97c28fc968fc88db21c07110075" translate="yes" xml:space="preserve">
          <source>It is less confusing to either calculate the result fully, and afterwards round it explicitly, or use the additional parameters to the math functions like so:</source>
          <target state="translated">結果を完全に計算してから明示的に丸めるか、数学関数に追加のパラメータを使ってこのようにした方が混乱しません。</target>
        </trans-unit>
        <trans-unit id="1a0e27e331f66d429f8d776eb7eea1b1dc292c9e" translate="yes" xml:space="preserve">
          <source>It is like &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt; but it takes an extra parameter placed after all the others, &lt;code&gt;errors&lt;/code&gt;. If this parameter is 0, this function behaves identically to &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt;. Otherwise, &lt;code&gt;errors&lt;/code&gt; should be a pointer to a &lt;code&gt;U32&lt;/code&gt; variable, which this function sets to indicate any errors found. Upon return, if &lt;code&gt;*errors&lt;/code&gt; is 0, there were no errors found. Otherwise, &lt;code&gt;*errors&lt;/code&gt; is the bit-wise &lt;code&gt;OR&lt;/code&gt; of the bits described in the list below. Some of these bits will be set if a malformation is found, even if the input &lt;code&gt;flags&lt;/code&gt; parameter indicates that the given malformation is allowed; those exceptions are noted:</source>
          <target state="translated">これは &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt; 似ていますが、他のすべての後に配置された追加のパラメーター、 &lt;code&gt;errors&lt;/code&gt; 取ります。このパラメーターが0の場合、この関数は &lt;code&gt;&lt;a href=&quot;#utf8n_to_uvchr&quot;&gt;&quot;utf8n_to_uvchr&quot;&lt;/a&gt;&lt;/code&gt; と同じように動作します。それ以外の場合、 &lt;code&gt;errors&lt;/code&gt; は &lt;code&gt;U32&lt;/code&gt; 変数へのポインターである必要があります。この変数は、検出されたエラーを示すためにこの関数が設定します。戻ったときに、 &lt;code&gt;*errors&lt;/code&gt; が0の場合、エラーは見つかりませんでした。それ以外の場合、 &lt;code&gt;*errors&lt;/code&gt; は以下のリストで説明されているビットのビットごとの &lt;code&gt;OR&lt;/code&gt; です。入力 &lt;code&gt;flags&lt;/code&gt; パラメータが指定された奇形が許可されていることを示している場合でも、奇形が見つかった場合、これらのビットの一部が設定されます。これらの例外は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="4ac2033e4ba80b8d679681b08231b45a9481613f" translate="yes" xml:space="preserve">
          <source>It is more correct and more complete than &lt;a href=&quot;HTTP::Lite&quot;&gt;HTTP::Lite&lt;/a&gt;. It supports proxies and redirection. It also correctly resumes after EINTR.</source>
          <target state="translated">&lt;a href=&quot;HTTP::Lite&quot;&gt;HTTP :: Lite&lt;/a&gt;よりも正確で完全です。プロキシとリダイレクトをサポートします。また、EINTRの後で正しく再開します。</target>
        </trans-unit>
        <trans-unit id="38f913862bf185692af7e2eaaf2148c65356aec6" translate="yes" xml:space="preserve">
          <source>It is most convenient to use in a &lt;code&gt;foreach&lt;/code&gt; loop, for example:</source>
          <target state="translated">たとえば、 &lt;code&gt;foreach&lt;/code&gt; ループで使用するのが最も便利です。</target>
        </trans-unit>
        <trans-unit id="69bffc928e3fa117d0fd3dd3376d4295ace44212" translate="yes" xml:space="preserve">
          <source>It is no longer possible to compile PA-RISC 1.0 executables on either the PA-RISC 1.1 or 2.0 platforms. The command-line flags are accepted, but the resulting executable will not run when transferred to a PA-RISC 1.0 system.</source>
          <target state="translated">PA-RISC 1.1または2.0プラットフォーム上でPA-RISC 1.0の実行ファイルをコンパイルすることができなくなりました。コマンドラインフラグは受け入れられますが、PA-RISC 1.0システムに転送された実行ファイルは実行されません。</target>
        </trans-unit>
        <trans-unit id="09c5f6dc5c28104c8b1496a7745505dfd0c3755b" translate="yes" xml:space="preserve">
          <source>It is no longer possible to link PA-RISC 1.0 shared libraries (even though the command-line flags are still present).</source>
          <target state="translated">PA-RISC 1.0の共有ライブラリをリンクすることができなくなりました(コマンドラインフラグが残っているにもかかわらず)。</target>
        </trans-unit>
        <trans-unit id="5e391513315c3abeec46220661da8fc25e5f09fd" translate="yes" xml:space="preserve">
          <source>It is not considered an error for &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; to return false if it fails due to an &lt;code&gt;EWOULDBLOCK&lt;/code&gt; (or equivalent) condition. This means one can still use the common convention of testing the return value of &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; when called with the &lt;code&gt;LOCK_NB&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;EWOULDBLOCK&lt;/code&gt; （または同等の）条件が原因で失敗した場合に &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; がfalseを返すことは、エラーとは見なされません。これは、 &lt;code&gt;LOCK_NB&lt;/code&gt; オプションを指定して呼び出されたときに、 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; の戻り値をテストするという一般的な規則を引き続き使用できることを意味します。</target>
        </trans-unit>
        <trans-unit id="5203d22c8328a2d0b2cff53631202830f7dc2011" translate="yes" xml:space="preserve">
          <source>It is not considered an error for &lt;code&gt;flock&lt;/code&gt; to return false if it fails due to an &lt;code&gt;EWOULDBLOCK&lt;/code&gt; (or equivalent) condition. This means one can still use the common convention of testing the return value of &lt;code&gt;flock&lt;/code&gt; when called with the &lt;code&gt;LOCK_NB&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;EWOULDBLOCK&lt;/code&gt; （または同等の）条件が原因で失敗した場合に &lt;code&gt;flock&lt;/code&gt; がfalseを返すことはエラーとは見なされません。これは、 &lt;code&gt;LOCK_NB&lt;/code&gt; オプションを指定して呼び出されたときに、 &lt;code&gt;flock&lt;/code&gt; の戻り値をテストするという一般的な規則を引き続き使用できることを意味します。</target>
        </trans-unit>
        <trans-unit id="eb49901ab613cbcc1013bad05870bde6b73a1f49" translate="yes" xml:space="preserve">
          <source>It is not desirable to import the functions &lt;code&gt;fieldhash&lt;/code&gt; and/or &lt;code&gt;fieldhashes&lt;/code&gt; into every class that is going to use them. They are only used once to set up the class. When the class is up and running, these functions serve no more purpose.</source>
          <target state="translated">関数 &lt;code&gt;fieldhash&lt;/code&gt; や &lt;code&gt;fieldhashes&lt;/code&gt; を使用するすべてのクラスにインポートすることは望ましくありません。これらは、クラスのセットアップに1回だけ使用されます。クラスが稼働しているとき、これらの関数はもはや目的を果たしません。</target>
        </trans-unit>
        <trans-unit id="c5fbc8d597bc2a95fe72ba36ecdd3925f81ca3bb" translate="yes" xml:space="preserve">
          <source>It is not necessary for voting to be held on cherry-picking perldelta entries associated with changes that have already been cherry-picked, nor for the maint-pumpking to obtain votes on changes required by the</source>
          <target state="translated">既にチェリーピックされている変更に伴うペルデルタエントリのチェリーピックに関する投票が行われる必要はなく、また、メインパンプキングで必要とされる変更に対する投票を得るために</target>
        </trans-unit>
        <trans-unit id="27e3bb472e9cdfda94e8831e0977881e11fb42e5" translate="yes" xml:space="preserve">
          <source>It is not necessary to include every change meeting these criteria, and in general the focus should be on addressing security issues, crashing bugs, regressions and serious installation issues. The temptation to include a plethora of minor changes that don't affect the installation or execution of perl (e.g. spelling corrections in documentation) should be resisted in order to reduce the overall risk of overlooking something. The intention is to create maintenance releases which are both worthwhile and which users can have full confidence in the stability of. (A secondary concern is to avoid burning out the maint-pumpking or overwhelming other committers voting on changes to be included (see &lt;a href=&quot;#Getting-changes-into-a-maint-branch&quot;&gt;&quot;Getting changes into a maint branch&quot;&lt;/a&gt; below).)</source>
          <target state="translated">これらの基準を満たすすべての変更を含める必要はありません。一般に、セキュリティの問題、クラッシュするバグ、リグレッション、および深刻なインストールの問題に対処することに焦点を当てる必要があります。何かを見落とすリスクを全体的に減らすために、perlのインストールや実行に影響を与えない多数の小さな変更（ドキュメントのスペル修正など）を含めたいという誘惑に抵抗する必要があります。その意図は、価値があり、ユーザーがの安定性に完全に自信を持つことができるメンテナンスリリースを作成することです。 （二次的な懸念は、メイントを焼き尽くしたり、含まれる変更に投票する他のコミッターを圧倒したりしないようにすることです（以下の&lt;a href=&quot;#Getting-changes-into-a-maint-branch&quot;&gt;「メイントブランチへの変更の取得」を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="fee4bc3261e1d5762f4a782cbbcca1c13a9e84eb" translate="yes" xml:space="preserve">
          <source>It is not necessary to include every change meeting these criteria, and in general the focus should be on addressing security issues, crashing bugs, regressions and serious installation issues. The temptation to include a plethora of minor changes that don't affect the installation or execution of perl (e.g. spelling corrections in documentation) should be resisted in order to reduce the overall risk of overlooking something. The intention is to create maintenance releases which are both worthwhile and which users can have full confidence in the stability of. (A secondary concern is to avoid burning out the maint-pumpking or overwhelming other committers voting on changes to be included (see &lt;a href=&quot;#Getting-changes-into-a-maint-branch&quot;&gt;Getting changes into a maint branch&lt;/a&gt; below).)</source>
          <target state="translated">これらの基準を満たすすべての変更を含める必要はありません。一般に、セキュリティの問題、クラッシュするバグ、リグレッション、および深刻なインストールの問題に対処することに焦点を当てる必要があります。 perlのインストールや実行に影響を及ぼさない多くの小さな変更（たとえば、ドキュメントのスペル修正）を含める誘惑は、何かを見落とす全体的なリスクを減らすために抵抗されるべきです。その目的は、価値があり、ユーザーが安定性に完全に自信を持つことができるメンテナンスリリースを作成することです。 （2番目の懸念は、含まれる変更に投票するmaint-pumpingまたは圧倒的な他のコミッターの燃え尽きを避けることです（以下の&lt;a href=&quot;#Getting-changes-into-a-maint-branch&quot;&gt;maintブランチへの変更の取得を&lt;/a&gt;参照）。）</target>
        </trans-unit>
        <trans-unit id="90bcb58fb92d14a7b685940a550af6acd8800f2a" translate="yes" xml:space="preserve">
          <source>It is not necessary to mention DynaLoader or the current extension when filling in INCLUDE_EXT. If the INCLUDE_EXT is mentioned but is empty then only DynaLoader and the current extension will be included in the build.</source>
          <target state="translated">INCLUDE_EXTを記入する際に、DynaLoaderや現在の拡張機能を指定する必要はありません。INCLUDE_EXTが指定されていても空の場合は、DynaLoaderと現在の拡張機能のみがビルドに含まれます。</target>
        </trans-unit>
        <trans-unit id="6c22235436c0d9c88ea34e3651dd185b541bd55a" translate="yes" xml:space="preserve">
          <source>It is not possible to have a subroutine or a keyword with the same name as a constant in the same package. This is probably a Good Thing.</source>
          <target state="translated">定数と同じ名前のサブルーチンやキーワードを同じパッケージ内に持つことはできません。これはおそらく良いことだと思います。</target>
        </trans-unit>
        <trans-unit id="f4712dd85edea86a32c5bfd8ffd1fe49536a91d9" translate="yes" xml:space="preserve">
          <source>It is not possible to pack or unpack bit fields - just integral bytes. &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; always starts at the next byte boundary and &quot;rounds up&quot; to the next multiple of 8 by adding zero bits as required. (If you do want bit fields, there is &lt;a href=&quot;functions/vec&quot;&gt;vec&lt;/a&gt;. Or you could implement bit field handling at the character string level, using split, substr, and concatenation on unpacked bit strings.)</source>
          <target state="translated">ビットフィールドをパックまたはアンパックすることはできません。整数バイトのみです。 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; は常に次のバイト境界から始まり、必要に応じてゼロビットを追加することにより、次の8の倍数に「切り上げ」ます。（ビットフィールドが必要な場合は&lt;a href=&quot;functions/vec&quot;&gt;vecを使用し&lt;/a&gt;ます。または、アンパックされたビット文字列に対してsplit、substr、および連結を使用して、文字列レベルでビットフィールド処理を実装できます。）</target>
        </trans-unit>
        <trans-unit id="39a07790029fea0888a82dfcdbb3f4369b9da3f5" translate="yes" xml:space="preserve">
          <source>It is not possible to pack or unpack bit fields - just integral bytes. &lt;code&gt;pack&lt;/code&gt; always starts at the next byte boundary and &quot;rounds up&quot; to the next multiple of 8 by adding zero bits as required. (If you do want bit fields, there is &lt;a href=&quot;perlfunc#vec&quot;&gt;&quot;vec&quot; in perlfunc&lt;/a&gt;. Or you could implement bit field handling at the character string level, using split, substr, and concatenation on unpacked bit strings.)</source>
          <target state="translated">ビットフィールドをパックまたはアンパックすることはできません。整数バイトのみです。 &lt;code&gt;pack&lt;/code&gt; は常に次のバイト境界から始まり、必要に応じてゼロビットを追加することで次の8の倍数に「切り上げ」ます。 （ビットフィールドが必要な場合は&lt;a href=&quot;perlfunc#vec&quot;&gt;、perlfuncに「vec」&lt;/a&gt;があります。または、解凍されたビット文字列でsplit、substr、および連結を使用して、文字列レベルでビットフィールド処理を実装できます。）</target>
        </trans-unit>
        <trans-unit id="3efe75bc9ad9fbe460b3b9a87287e6aa69baa4d8" translate="yes" xml:space="preserve">
          <source>It is not safe to use the value of &lt;code&gt;$^X&lt;/code&gt; as a path name of a file, as some operating systems that have a mandatory suffix on executable files do not require use of the suffix when invoking a command. To convert the value of &lt;code&gt;$^X&lt;/code&gt; to a path name, use the following statements:</source>
          <target state="translated">&lt;code&gt;$^X&lt;/code&gt; 値をファイルのパス名として使用するのは安全ではありません。実行可能ファイルに必須のサフィックスがあるオペレーティングシステムでは、コマンドを呼び出すときにサフィックスを使用する必要がないためです。 &lt;code&gt;$^X&lt;/code&gt; 値をパス名に変換するには、次のステートメントを使用します。</target>
        </trans-unit>
        <trans-unit id="17f49b3471db481f432117951bcb8866bb533894" translate="yes" xml:space="preserve">
          <source>It is not uncommon to want to match a range of characters. Luckily, instead of listing all characters in the range, one may use the hyphen (&lt;code&gt;-&lt;/code&gt; ). If inside a bracketed character class you have two characters separated by a hyphen, it's treated as if all characters between the two were in the class. For instance, &lt;code&gt;[0-9]&lt;/code&gt; matches any ASCII digit, and &lt;code&gt;[a-m]&lt;/code&gt; matches any lowercase letter from the first half of the ASCII alphabet.</source>
          <target state="translated">ある範囲の文字に一致させたいことは珍しくありません。幸いなことに、範囲内のすべての文字をリストする代わりに、ハイフン（ &lt;code&gt;-&lt;/code&gt; ）を使用できます。括弧で囲まれた文字クラス内に2つの文字がハイフンで区切られている場合、2つの文字の間のすべての文字がクラス内にあるかのように扱われます。たとえば、 &lt;code&gt;[0-9]&lt;/code&gt; は任意のASCII数字に一致し、 &lt;code&gt;[a-m]&lt;/code&gt; はASCIIアルファベットの前半の小文字に一致します。</target>
        </trans-unit>
        <trans-unit id="7607528bdce01b011f213f8ac77cd85f02fbbdd6" translate="yes" xml:space="preserve">
          <source>It is not uncommon to want to match a range of characters. Luckily, instead of listing all characters in the range, one may use the hyphen (&lt;code&gt;-&lt;/code&gt;). If inside a bracketed character class you have two characters separated by a hyphen, it's treated as if all characters between the two were in the class. For instance, &lt;code&gt;[0-9]&lt;/code&gt; matches any ASCII digit, and &lt;code&gt;[a-m]&lt;/code&gt; matches any lowercase letter from the first half of the ASCII alphabet.</source>
          <target state="translated">文字の範囲を一致させたいことは珍しいことではありません。幸い、範囲内のすべての文字をリストする代わりに、ハイフン（ &lt;code&gt;-&lt;/code&gt; ）を使用できます。括弧で囲まれた文字クラス内にハイフンで区切られた2つの文字がある場合、2つの間のすべての文字がクラス内にあるかのように扱われます。たとえば、 &lt;code&gt;[0-9]&lt;/code&gt; は任意のASCII数字に一致し、 &lt;code&gt;[a-m]&lt;/code&gt; はASCIIアルファベットの前半のすべての小文字に一致します。</target>
        </trans-unit>
        <trans-unit id="ea195389d2ab8304dae6a2be37001201928a81bd" translate="yes" xml:space="preserve">
          <source>It is now being maintained separately from the Perl core by Dave Rolsky, &amp;lt;autarch@urth.org&amp;gt;.</source>
          <target state="translated">現在、Dave Rolsky &amp;lt;autarch@urth.org&amp;gt;によって、Perlコアとは別に保守されています。</target>
        </trans-unit>
        <trans-unit id="0a2d81d68cd0e192d7fee2715fc04989d662c22e" translate="yes" xml:space="preserve">
          <source>It is often more readable to use the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator between key/value pairs. The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is mostly just a more visually distinctive synonym for a comma, but it also arranges for its left-hand operand to be interpreted as a string if it's a bareword that would be a legal simple identifier. &lt;code&gt;=&amp;gt;&lt;/code&gt; doesn't quote compound identifiers, that contain double colons. This makes it nice for initializing hashes:</source>
          <target state="translated">キーと値のペア間で &lt;code&gt;=&amp;gt;&lt;/code&gt; 演算子を使用する方が読みやすいことがよくあります。 &lt;code&gt;=&amp;gt;&lt;/code&gt; 演算子は、ほとんどがカンマのためだけの、より視覚的に独特の同義語であるが、それは法的な単純な識別子となり裸の単語だ場合、それはまた、その左側を手配は、文字列として解釈されるオペランド。 &lt;code&gt;=&amp;gt;&lt;/code&gt; は、二重コロンを含む複合識別子を引用しません。これは、ハッシュの初期化に適しています。</target>
        </trans-unit>
        <trans-unit id="c425383e0dcd08da6401882b3bf5fc73ffa2b23f" translate="yes" xml:space="preserve">
          <source>It is often not wise to share an object unless the class itself has been written to support sharing. For example, a shared object's destructor may get called multiple times, once for each thread's scope exit, or may not get called at all if it is embedded inside another shared object. Another issue is that the contents of hash-based objects will be lost due to the above mentioned limitation. See</source>
          <target state="translated">クラス自体が共有をサポートするように書かれていない限り、オブジェクトを共有することは賢明ではないことが多いです。例えば、共有オブジェクトのデストラクタが複数回呼ばれたり、各スレッドのスコープ終了時に一度だけ呼ばれたり、別の共有オブジェクトの内部に埋め込まれている場合は全く呼ばれないかもしれません。もう一つの問題は、上記の制限によりハッシュベースのオブジェクトの内容が失われてしまうことです。以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="ca5507a15a15ea470ddab20bdff08a946fb003e3" translate="yes" xml:space="preserve">
          <source>It is often not wise to share an object unless the class itself has been written to support sharing. For example, an object's destructor may get called multiple times, once for each thread's scope exit. Another danger is that the contents of hash-based objects will be lost due to the above mentioned limitation. See</source>
          <target state="translated">クラス自体が共有をサポートするように書かれていない限り、オブジェクトを共有することは賢明ではないことが多いです。例えば、オブジェクトのデストラクタが複数回呼ばれ、各スレッドのスコープ終了時に一度だけ呼び出されるかもしれません。もう一つの危険は、ハッシュベースのオブジェクトの内容が上記の制限のために失われてしまうことです。以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="c69ba08cbdace146eeaa3088aa2fbd7151747d45" translate="yes" xml:space="preserve">
          <source>It is okay for the lines starting at the &quot;CODE:&quot; line to not be indented. However, for readability purposes, it is suggested that you indent CODE: one level and the lines following one more level.</source>
          <target state="translated">CODE:」の行から始まる行はインデントしなくても構いません。しかし、可読性を考慮して、CODE:は 1 レベル、それに続く行はさらに 1 レベルインデントすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="65df07e3fa6135b82df3a9d6866989ee7ae4d5d2" translate="yes" xml:space="preserve">
          <source>It is only used on OS/2 and Win32.</source>
          <target state="translated">OS/2とWin32でしか使用していません。</target>
        </trans-unit>
        <trans-unit id="3ea8b006ce3e53db87407f2dbaa5815e87ff2f78" translate="yes" xml:space="preserve">
          <source>It is particularly important to have this graft line if any bisecting is done in the area of the &quot;merge&quot; in question.</source>
          <target state="translated">特に、問題の「マージ」の部分に二分法が行われている場合は、このグラフトラインを持つことが重要です。</target>
        </trans-unit>
        <trans-unit id="6661787e0f495e149a6ee0b4ddf2a5d46d4df496" translate="yes" xml:space="preserve">
          <source>It is particularly important to note that neither the shell nor the C runtime do any wildcard expansions of command-line arguments (so wildcards need not be quoted). Also, the quoting behaviours of the shell and the C runtime are rudimentary at best (and may, if you are using a non-standard shell, be inconsistent). The only (useful) quote character is the double quote (&quot;). It can be used to protect spaces and other special characters in arguments.</source>
          <target state="translated">シェルも C ランタイムもコマンドライン引数のワイルドカード展開を行わないことに注意してください(ワイルドカードは引用符で囲む必要はありません)。また、シェルと C ランタイムのクォートの動作は、せいぜい初歩的なものです (標準ではないシェルを使用している場合は、一貫性がないかもしれません)。唯一の(有用な)クォート文字はダブルクォート(&quot;)です。これは、引数に含まれるスペースやその他の特殊文字を保護するために使用できます。</target>
        </trans-unit>
        <trans-unit id="b08f708cd4767406ca484e1891baf6f457b1498f" translate="yes" xml:space="preserve">
          <source>It is possible for the Perl subroutine you are calling to terminate abnormally, e.g., by calling</source>
          <target state="translated">呼び出したPerlのサブルーチンが異常終了する可能性があります。</target>
        </trans-unit>
        <trans-unit id="68748e768505aa715cf11b4ae34ec36bb19593be" translate="yes" xml:space="preserve">
          <source>It is possible that, upon completion, not all arguments in the string have been processed. &lt;code&gt;GetOptionsFromString&lt;/code&gt; will, when called in list context, return both the return status and an array reference to any remaining arguments:</source>
          <target state="translated">完了時に、文字列内のすべての引数が処理されていない可能性があります。 &lt;code&gt;GetOptionsFromString&lt;/code&gt; は、リストコンテキストで呼び出されると、戻りステータスと残りの引数への配列参照の両方を返します。</target>
        </trans-unit>
        <trans-unit id="67c5b12c61d00e32b42a8983e07a796133ebb6eb" translate="yes" xml:space="preserve">
          <source>It is possible to add &lt;a href=&quot;perlmod#BEGIN%2C-UNITCHECK%2C-CHECK%2C-INIT-and-END&quot;&gt;END blocks&lt;/a&gt; to threads by using &lt;a href=&quot;perlfunc#require-VERSION&quot;&gt;require&lt;/a&gt; or &lt;a href=&quot;perlfunc#eval-EXPR&quot;&gt;eval&lt;/a&gt; with the appropriate code. These &lt;code&gt;END&lt;/code&gt; blocks will then be executed when the thread's interpreter is destroyed (i.e., either during a &lt;code&gt;-&amp;gt;join()&lt;/code&gt; call, or at program termination).</source>
          <target state="translated">適切なコードで&lt;a href=&quot;perlfunc#require-VERSION&quot;&gt;require&lt;/a&gt;または&lt;a href=&quot;perlfunc#eval-EXPR&quot;&gt;eval&lt;/a&gt;を使用することにより、スレッドに&lt;a href=&quot;perlmod#BEGIN%2C-UNITCHECK%2C-CHECK%2C-INIT-and-END&quot;&gt;ENDブロック&lt;/a&gt;を追加することができます。これらの &lt;code&gt;END&lt;/code&gt; ブロックは、スレッドのインタープリターが破棄されたとき（つまり、 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 呼び出し中、またはプログラムの終了時）に実行されます。</target>
        </trans-unit>
        <trans-unit id="da1fb645dee4eb2dcf81d78a3bbd52439eec6574" translate="yes" xml:space="preserve">
          <source>It is possible to add &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;END blocks&lt;/a&gt; to threads by using &lt;a href=&quot;functions/require&quot;&gt;require VERSION&lt;/a&gt; or &lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt; with the appropriate code. These &lt;code&gt;END&lt;/code&gt; blocks will then be executed when the thread's interpreter is destroyed (i.e., either during a &lt;code&gt;-&amp;gt;join()&lt;/code&gt; call, or at program termination).</source>
          <target state="translated">適切なコードで&lt;a href=&quot;functions/require&quot;&gt;require VERSION&lt;/a&gt;または&lt;a href=&quot;functions/eval&quot;&gt;eval EXPR&lt;/a&gt;を使用すると、&lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;ENDブロック&lt;/a&gt;をスレッドに追加できます。これらの &lt;code&gt;END&lt;/code&gt; ブロックは、スレッドのインタープリターが破棄されたときに実行されます（つまり、 &lt;code&gt;-&amp;gt;join()&lt;/code&gt; 呼び出し中、またはプログラムの終了時）。</target>
        </trans-unit>
        <trans-unit id="103a4ec3966b9d4c47f8bb4d45cb27898db88b92" translate="yes" xml:space="preserve">
          <source>It is possible to ask for a different method resolution order with the &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; pragma.</source>
          <target state="translated">&lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt;プラグマを使用して、異なるメソッド解決順序を要求することができます。</target>
        </trans-unit>
        <trans-unit id="214e8fa8e052ffd8fef627a3a69587c1d8000f20" translate="yes" xml:space="preserve">
          <source>It is possible to ask for such a statistic at arbitrary points in your execution using the mstat() function out of the standard Devel::Peek module.</source>
          <target state="translated">標準の Devel::Peek モジュールの mstat()関数を使用して、実行中の任意のポイントでそのような統計量を求めることができます。</target>
        </trans-unit>
        <trans-unit id="b3c2ec1b334ee0d70dae2975648b13f78c06cb41" translate="yes" xml:space="preserve">
          <source>It is possible to build a threaded version of perl on Solaris. The entire perl thread implementation is still experimental, however, so beware.</source>
          <target state="translated">Solaris上でスレッド化されたバージョンのperlを構築することは可能です。しかし、Perl のスレッドの実装全体はまだ実験的なものなので、注意が必要です。</target>
        </trans-unit>
        <trans-unit id="5dcdcf19c7450b4c54b9304c481faacc66e7c2fc" translate="yes" xml:space="preserve">
          <source>It is possible to compile a version of threaded Perl on any version of HP-UX before 10.30, but it is strongly suggested that you be running on HP-UX 11.00 at least.</source>
          <target state="translated">10.30以前のどのバージョンのHP-UXでもスレッド付きPerlをコンパイルすることは可能ですが、少なくともHP-UX 11.00で動作することを強く推奨します。</target>
        </trans-unit>
        <trans-unit id="fda7319a695e60b7430ed01765a1f487df41c0cc" translate="yes" xml:space="preserve">
          <source>It is possible to control which characters terminate words by modifying &lt;code&gt;$Text::Wrap::break&lt;/code&gt; . Set this to a string such as &lt;code&gt;'[\s:]'&lt;/code&gt; (to break before spaces or colons) or a pre-compiled regexp such as &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/[\s']/&lt;/a&gt;&lt;/code&gt; (to break before spaces or apostrophes). The default is simply &lt;code&gt;'\s'&lt;/code&gt; ; that is, words are terminated by spaces. (This means, among other things, that trailing punctuation such as full stops or commas stay with the word they are &quot;attached&quot; to.) Setting &lt;code&gt;$Text::Wrap::break&lt;/code&gt; to a regular expression that doesn't eat any characters (perhaps just a forward look-ahead assertion) will cause warnings.</source>
          <target state="translated">&lt;code&gt;$Text::Wrap::break&lt;/code&gt; 変更することで、どの文字が単語を終了させるかを制御できます。これを &lt;code&gt;'[\s:]'&lt;/code&gt; （スペースまたはコロンの前で区切る）などの文字列、または &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/[\s']/&lt;/a&gt;&lt;/code&gt; （スペースまたはアポストロフィの前で区切る）などの事前にコンパイルされた正規表現に設定します。デフォルトは単に &lt;code&gt;'\s'&lt;/code&gt; です。つまり、単語はスペースで終了します。 （これは、とりわけ、フルストップやコンマなどの末尾の句読点は、それらが「付加された」単語にとどまることを意味します。） &lt;code&gt;$Text::Wrap::break&lt;/code&gt; を、文字をまったく使用しない正規表現に設定します（おそらく、先読みのアサーションのみ）は警告を引き起こします。</target>
        </trans-unit>
        <trans-unit id="4b27989d9b82508c46a4fe952eadfb7a10b89ae6" translate="yes" xml:space="preserve">
          <source>It is possible to control which characters terminate words by modifying &lt;code&gt;$Text::Wrap::break&lt;/code&gt;. Set this to a string such as &lt;code&gt;'[\s:]'&lt;/code&gt; (to break before spaces or colons) or a pre-compiled regexp such as &lt;code&gt;qr/[\s']/&lt;/code&gt; (to break before spaces or apostrophes). The default is simply &lt;code&gt;'\s'&lt;/code&gt;; that is, words are terminated by spaces. (This means, among other things, that trailing punctuation such as full stops or commas stay with the word they are &quot;attached&quot; to.) Setting &lt;code&gt;$Text::Wrap::break&lt;/code&gt; to a regular expression that doesn't eat any characters (perhaps just a forward look-ahead assertion) will cause warnings.</source>
          <target state="translated">&lt;code&gt;$Text::Wrap::break&lt;/code&gt; 変更することで、どの文字が単語を終了するかを制御できます。これを &lt;code&gt;'[\s:]'&lt;/code&gt; （スペースやコロンの前で区切る）などの文字列、または &lt;code&gt;qr/[\s']/&lt;/code&gt; （スペースやアポストロフィの前で区切る）などのコンパイル済み正規表現に設定します。デフォルトは単に &lt;code&gt;'\s'&lt;/code&gt; ;です。つまり、単語はスペースで終了します。 （これは、特に、ピリオドやコンマなどの末尾の句読点が、「添付」されている単語にとどまるということを意味します。） &lt;code&gt;$Text::Wrap::break&lt;/code&gt; を、文字をまったく食べない正規表現に設定します（おそらく、先読みアサーションだけが警告を引き起こします。</target>
        </trans-unit>
        <trans-unit id="7fe767cd6ad41a1bf2749df0593b7a56afc9ca68" translate="yes" xml:space="preserve">
          <source>It is possible to create a &quot;circular reference&quot; in Perl, which can lead to memory leaks. A circular reference occurs when two references contain a reference to each other, like this:</source>
          <target state="translated">Perlでは「循環参照」を作成することが可能で、これがメモリリークにつながる可能性があります。循環参照は、次のように、2つの参照がお互いへの参照を含む場合に発生します。</target>
        </trans-unit>
        <trans-unit id="194e4ce07b732bc978b1694be34e6655ffc1b7f6" translate="yes" xml:space="preserve">
          <source>It is possible to determine which character set you are operating under. But first you need to be really really sure you need to do this. Your code will be simpler and probably just as portable if you don't have to test the character set and do different things, depending. There are actually only very few circumstances where it's not easy to write straight-line code portable to all character sets. See &lt;a href=&quot;perluniintro#Unicode-and-EBCDIC&quot;&gt;&quot;Unicode and EBCDIC&quot; in perluniintro&lt;/a&gt; for how to portably specify characters.</source>
          <target state="translated">操作している文字セットを判別することができます。しかし、最初にあなたはあなたがこれをする必要があることを本当に本当に確信する必要があります。文字セットをテストしてさまざまなことを行う必要がない場合は、コードがより単純になり、おそらく同じように移植可能になります。実際には、すべての文字セットに移植可能な直線コードを書くのが簡単ではない状況はごくわずかです。参照してください&lt;a href=&quot;perluniintro#Unicode-and-EBCDIC&quot;&gt;perluniintroで「UnicodeとEBCDICを」&lt;/a&gt;移植可能な文字を指定する方法について。</target>
        </trans-unit>
        <trans-unit id="c791c22192baa95a06c328176e1b85eddd8c69ea" translate="yes" xml:space="preserve">
          <source>It is possible to determine which character set you are operating under. But first you need to be really really sure you need to do this. Your code will be simpler and probably just as portable if you don't have to test the character set and do different things, depending. There are actually only very few circumstances where it's not easy to write straight-line code portable to all character sets. See &lt;a href=&quot;perluniintro#Unicode-and-EBCDIC&quot;&gt;Unicode and EBCDIC in perluniintro&lt;/a&gt; for how to portably specify characters.</source>
          <target state="translated">操作している文字セットを判別することができます。ただし、最初に、これを実行する必要があることを本当に確認する必要があります。文字セットをテストしてさまざまなことを実行する必要がない場合は、コードはより単純になり、おそらく移植性が同じになります。実際には、すべての文字セットに移植可能な直線的なコードを書くのが容易ではない状況はごくわずかです。文字を移植可能に指定する方法について&lt;a href=&quot;perluniintro#Unicode-and-EBCDIC&quot;&gt;は、perluniintroのUnicodeおよびEBCDICを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e0813f66fef4fb95209b9bd5234a37222cb817c4" translate="yes" xml:space="preserve">
          <source>It is possible to explicitly call a parent method from a child:</source>
          <target state="translated">子から明示的に親メソッドを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="c0da326565896926df8bd9bb48dde0df4c98d8f9" translate="yes" xml:space="preserve">
          <source>It is possible to forbid or warn on non-Unicode code points, or those that may be problematic by using &lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;&quot;uvchr_to_utf8_flags&quot;&lt;/a&gt;.</source>
          <target state="translated">Unicode以外のコードポイント、または&lt;a href=&quot;#uvchr_to_utf8_flags&quot;&gt;「uvchr_to_utf8_flags」&lt;/a&gt;を使用して問題が発生する可能性のあるコードポイントを禁止または警告することができます。</target>
        </trans-unit>
        <trans-unit id="d19734113aaf232e977540f9be066f896f4d50e8" translate="yes" xml:space="preserve">
          <source>It is possible to get special treatment for a lone dash. This can be achieved by adding an option specification with an empty name, for example:</source>
          <target state="translated">単独ダッシュに対して特別な扱いを得ることが可能です。これは、例えば空の名前でオプション指定を追加することで実現できます。</target>
        </trans-unit>
        <trans-unit id="0e645006456f020c2cb729a6c316a213de718eec" translate="yes" xml:space="preserve">
          <source>It is possible to import autodie into a different namespace by using &lt;a href=&quot;Import::Into&quot;&gt;Import::Into&lt;/a&gt;. However, you have to pass a &quot;caller depth&quot; (rather than a package name) for this to work correctly.</source>
          <target state="translated">&lt;a href=&quot;Import::Into&quot;&gt;Import :: Into&lt;/a&gt;を使用して、autodieを別の名前空間にインポートすることができます。ただし、これを正しく機能させるには、（パッケージ名ではなく）「呼び出し元の深さ」を渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="484490759459d1a463406a9ec978f4abc6c5898b" translate="yes" xml:space="preserve">
          <source>It is possible to inspect both the string given to RE engine and the resulting finite automaton. See the arguments &lt;code&gt;debug&lt;/code&gt; /&lt;code&gt;debugcolor&lt;/code&gt; in the &lt;code&gt;use &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; pragma, as well as Perl's &lt;b&gt;-Dr&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;Command Switches in perlrun&lt;/a&gt;.</source>
          <target state="translated">REエンジンに与えられた文字列と結果の有限オートマトンの両方を検査することが可能です。 &lt;code&gt;use &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;プラグマの引数 &lt;code&gt;debug&lt;/code&gt; / &lt;code&gt;debugcolor&lt;/code&gt; と、perlrunの&lt;a href=&quot;perlrun#Command-Switches&quot;&gt;コマンドスイッチに&lt;/a&gt;記載されているPerlの&lt;b&gt;-Dr&lt;/b&gt;コマンドラインスイッチを参照してください。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="2de0a7af99e757a8e8485b1376bbc31dd1cac31e" translate="yes" xml:space="preserve">
          <source>It is possible to inspect both the string given to RE engine and the resulting finite automaton. See the arguments &lt;code&gt;debug&lt;/code&gt;/&lt;code&gt;debugcolor&lt;/code&gt; in the &lt;code&gt;use &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; pragma, as well as Perl's &lt;b&gt;-Dr&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun#Command-Switches&quot;&gt;&quot;Command Switches&quot; in perlrun&lt;/a&gt;.</source>
          <target state="translated">REエンジンに与えられた文字列と結果の有限オートマトンの両方を検査することが可能です。引数を参照してください。 &lt;code&gt;debug&lt;/code&gt; / &lt;code&gt;debugcolor&lt;/code&gt; で &lt;code&gt;use &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;&lt;/code&gt; プラグマを、だけでなく、Perlの&lt;b&gt;-Dr&lt;/b&gt;に記載のコマンドラインスイッチ&lt;a href=&quot;perlrun#Command-Switches&quot;&gt;はperlrunに「コマンドスイッチ」&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4987e0746709787de44b276c954d3dc160982cc" translate="yes" xml:space="preserve">
          <source>It is possible to intermix print()s with write()s on the same output channel, but you'll have to handle &lt;code&gt;$-&lt;/code&gt; (&lt;code&gt;$FORMAT_LINES_LEFT&lt;/code&gt; ) yourself.</source>
          <target state="translated">同じ出力チャネルでprint（）とwrite（）を混在させることは可能ですが、 &lt;code&gt;$-&lt;/code&gt; （ &lt;code&gt;$FORMAT_LINES_LEFT&lt;/code&gt; ）を自分で処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="17a6fb8a364afc4c2bb94e7dfbe0964a25366786" translate="yes" xml:space="preserve">
          <source>It is possible to intermix print()s with write()s on the same output channel, but you'll have to handle &lt;code&gt;$-&lt;/code&gt; (&lt;code&gt;$FORMAT_LINES_LEFT&lt;/code&gt;) yourself.</source>
          <target state="translated">同じ出力チャネルでprint（）とwrite（）を混在させることは可能ですが、 &lt;code&gt;$-&lt;/code&gt; （ &lt;code&gt;$FORMAT_LINES_LEFT&lt;/code&gt; ）を自分で処理する必要があります。</target>
        </trans-unit>
        <trans-unit id="8fe4bd11a84db5fbf18822129f597065dac28979" translate="yes" xml:space="preserve">
          <source>It is possible to make &lt;code&gt;NEXT&lt;/code&gt; redispatch more demandingly (i.e. like &lt;code&gt;SUPER&lt;/code&gt; does), so that the redispatch throws an exception if it cannot find a &quot;next&quot; method to call.</source>
          <target state="translated">&lt;code&gt;NEXT&lt;/code&gt; をより要求の厳しい方法で再ディスパッチすることは可能です（つまり、 &lt;code&gt;SUPER&lt;/code&gt; のように）。呼び出す「次の」メソッドが見つからない場合、再ディスパッチは例外をスローします。</target>
        </trans-unit>
        <trans-unit id="41c5e618b60091d8c922ad7e0e5ebbcfaa2cb4df" translate="yes" xml:space="preserve">
          <source>It is possible to manually set &lt;code&gt;@ISA&lt;/code&gt; , and you may see this in older Perl code. Much older code also uses the &lt;a href=&quot;base&quot;&gt;base&lt;/a&gt; pragma. For new code, we recommend that you use the &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; pragma to declare your parents. This pragma will take care of setting &lt;code&gt;@ISA&lt;/code&gt; . It will also load the parent classes and make sure that the package doesn't inherit from itself.</source>
          <target state="translated">&lt;code&gt;@ISA&lt;/code&gt; を手動で設定することは可能であり、古いPerlコードでこれを確認できます。はるかに古いコードでも&lt;a href=&quot;base&quot;&gt;base&lt;/a&gt;プラグマを使用しています。新しいコードの場合は、&lt;a href=&quot;parent&quot;&gt;親&lt;/a&gt;プラグマを使用して親を宣言することをお勧めします。このプラグマは &lt;code&gt;@ISA&lt;/code&gt; の設定を処理します。また、親クラスをロードし、パッケージがそれ自体から継承しないことを確認します。</target>
        </trans-unit>
        <trans-unit id="0bf520fb97ddb7d66d056d630c6c0c7c679c7af2" translate="yes" xml:space="preserve">
          <source>It is possible to omit some or all of the final 4 parameters in the call to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; and let them take default values. As DB_HASH is the most common file format used, the call:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; の呼び出しで最後の4つのパラメーターの一部またはすべてを省略して、それらにデフォルト値を使用させることができます。DB_HASHが最も一般的に使用されるファイル形式であるため、次の呼び出しを行います。</target>
        </trans-unit>
        <trans-unit id="d77ffc116f1345ae65bcfab7b549b42a9b2529d7" translate="yes" xml:space="preserve">
          <source>It is possible to omit some or all of the final 4 parameters in the call to &lt;code&gt;tie&lt;/code&gt; and let them take default values. As DB_HASH is the most common file format used, the call:</source>
          <target state="translated">&lt;code&gt;tie&lt;/code&gt; の呼び出しで、最後の4つのパラメーターの一部またはすべてを省略して、デフォルト値を使用させることができます。DB_HASHは使用される最も一般的なファイル形式であるため、次の呼び出しを行います。</target>
        </trans-unit>
        <trans-unit id="5c4afc212139685087c461e85b80958ff6af0a50" translate="yes" xml:space="preserve">
          <source>It is possible to pass either a subroutine reference (recommended) or a fully qualified subroutine name as the first argument. This means you can set hints on modules that</source>
          <target state="translated">第一引数にサブルーチン参照(推奨)か、完全修飾されたサブルーチン名を渡すことができます。これは、モジュールにヒントを設定することができることを意味します。</target>
        </trans-unit>
        <trans-unit id="4a7b6e646490b1b0de97fffd24d0c15d8fcfff05" translate="yes" xml:space="preserve">
          <source>It is possible to predeclare a lexical subroutine. The &lt;code&gt;sub foo {...}&lt;/code&gt; subroutine definition syntax respects any previous &lt;code&gt;my sub;&lt;/code&gt; or &lt;code&gt;state sub;&lt;/code&gt; declaration. Using this to define recursive subroutines is a bad idea, however:</source>
          <target state="translated">字句サブルーチンを事前に宣言することができます。 &lt;code&gt;sub foo {...}&lt;/code&gt; サブルーチン定義の構文点以前の &lt;code&gt;my sub;&lt;/code&gt; または &lt;code&gt;state sub;&lt;/code&gt; 宣言。ただし、これを使用して再帰的なサブルーチンを定義することはお勧めできません。</target>
        </trans-unit>
        <trans-unit id="03c72d0292032af6dedc904ed64f2438fc661321" translate="yes" xml:space="preserve">
          <source>It is possible to provide aliases that will be displayed in place of the test name by supplying the test as a reference to an array containing &lt;code&gt;[ $test, $alias ]&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;[ $test, $alias ]&lt;/code&gt; を含む配列への参照としてテストを提供することにより、テスト名の代わりに表示されるエイリアスを提供することができます。</target>
        </trans-unit>
        <trans-unit id="47d1a50872b03930e2d6b45fee9f2467c56c1224" translate="yes" xml:space="preserve">
          <source>It is possible to provide aliases that will be displayed in place of the test name by supplying the test as a reference to an array containing &lt;code&gt;[ $test, $alias ]&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;[ $test, $alias ]&lt;/code&gt; を含む配列への参照としてテストを提供することにより、テスト名の代わりに表示されるエイリアスを提供することができます。</target>
        </trans-unit>
        <trans-unit id="25625bc71a3769321141057e7fb45e78f8f3581c" translate="yes" xml:space="preserve">
          <source>It is possible to replace such an alphanumeric name with an expression that returns a reference to the appropriate type. For a description of this, see &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">このような英数字の名前を、適切なタイプへの参照を返す式に置き換えることができます。この説明については、&lt;a href=&quot;perlref&quot;&gt;perlrefを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0f8a33f0d5f0df1acec3703c5fa0463900e9dcf6" translate="yes" xml:space="preserve">
          <source>It is possible to return a modifiable value from a subroutine. To do this, you have to declare the subroutine to return an lvalue.</source>
          <target state="translated">サブルーチンから修正可能な値を返すことができます。そのためには、lvalueを返すサブルーチンを宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="deb2736fd66852d74a632f14d09ceb41fcda537d" translate="yes" xml:space="preserve">
          <source>It is possible to stack multiple here-docs in a row:</source>
          <target state="translated">複数のhere-docを一列に積み重ねることができます。</target>
        </trans-unit>
        <trans-unit id="3f9957642dc32b5a7c0c0eefbd7b6c39d5efef50" translate="yes" xml:space="preserve">
          <source>It is possible to strip the EXEs and DLLs created by the build process. The resulting binaries will be significantly smaller. If you want the binaries to be stripped, you can either add a &lt;b&gt;-s&lt;/b&gt; option when Configure prompts you,</source>
          <target state="translated">ビルドプロセスで作成されたEXEとDLLを取り除くことが可能です。結果のバイナリは大幅に小さくなります。バイナリを削除したい場合は、Configureがプロンプトを表示したときに&lt;b&gt;-s&lt;/b&gt;オプションを追加するか、</target>
        </trans-unit>
        <trans-unit id="0ddc0840c422187183750aec88a33c70a57206b1" translate="yes" xml:space="preserve">
          <source>It is possible to supply arguments to tests. To do so separate them from prove's own arguments with the arisdottle, '::'. For example</source>
          <target state="translated">テストに引数を与えることができます。これを行うには、arrisdottle,':::' で prove 自身の引数と分離してください。例えば</target>
        </trans-unit>
        <trans-unit id="843780a126a92b7260b78a50d262eb7d19529c37" translate="yes" xml:space="preserve">
          <source>It is possible to write custom layers in addition to the above builtin ones, both in C/XS and Perl, as a module named &lt;code&gt;PerlIO::&amp;lt;layer name&amp;gt;&lt;/code&gt;. Some custom layers come with the Perl distribution.</source>
          <target state="translated">上記の組み込みレイヤーに加えて、C / XSとPerlの両方で、 &lt;code&gt;PerlIO::&amp;lt;layer name&amp;gt;&lt;/code&gt; モジュールとしてカスタムレイヤーを作成することができます。一部のカスタムレイヤーにはPerlディストリビューションが付属しています。</target>
        </trans-unit>
        <trans-unit id="aa6e659dc24039769282bd1c1079f9c11cd8c6ba" translate="yes" xml:space="preserve">
          <source>It is possible to write custom layers in addition to the above builtin ones, both in C/XS and Perl. Two such layers (and one example written in Perl using the latter) come with the Perl distribution.</source>
          <target state="translated">C/XS と Perl の両方で、上記のビルトインレイヤーに加えてカスタムレイヤーを書くことができます。そのような 2 つのレイヤ (および後者を使って Perl で書かれた 1 つの例)が Perl ディストリビューションに付属しています。</target>
        </trans-unit>
        <trans-unit id="af11e539efd7b5740f9d5c0eba044f8aebf92a4a" translate="yes" xml:space="preserve">
          <source>It is possible to write:</source>
          <target state="translated">書くことは可能です。</target>
        </trans-unit>
        <trans-unit id="3043edf54589d4a75af8ab5a83729379d66bb57a" translate="yes" xml:space="preserve">
          <source>It is possible, though hard to do, to call &lt;code&gt;POSIX::setlocale&lt;/code&gt; with a locale that it doesn't recognize as syntactically legal, but actually is legal on that system. This should happen only with embedded perls, or if you hand-craft a locale name yourself.</source>
          <target state="translated">実行するのは難しいですが、構文的に正当であると認識されないロケールで &lt;code&gt;POSIX::setlocale&lt;/code&gt; を呼び出すことは可能ですが、実際にはそのシステムでは正当です。これは、埋め込まれたperlを使用する場合、またはロケール名を自分で作成する場合にのみ発生するはずです。</target>
        </trans-unit>
        <trans-unit id="2d15f29d6da4dd3ad23f2444184a1dcb4a66f4b0" translate="yes" xml:space="preserve">
          <source>It is probably best to chose either the Decimal notation or the string notation and stick with it, to reduce confusion. Perl6 version objects &lt;b&gt;may&lt;/b&gt; only support Decimal comparisons. See also &lt;a href=&quot;#Quoting-Rules&quot;&gt;&quot;Quoting Rules&quot;&lt;/a&gt;.</source>
          <target state="translated">混乱を減らすために、10進表記または文字列表記のいずれかを選択し、それを使用するのがおそらく最善です。Perl6バージョンのオブジェクト&lt;b&gt;は&lt;/b&gt;、10進比較のみをサポートする&lt;b&gt;場合があり&lt;/b&gt;ます。&lt;a href=&quot;#Quoting-Rules&quot;&gt;「引用規則」&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="0b89c8d09aeaea53d5ae118db445020ec34e8b36" translate="yes" xml:space="preserve">
          <source>It is probably useful only when combined with &lt;code&gt;(?{})&lt;/code&gt; or &lt;code&gt;(??{})&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;(?{})&lt;/code&gt; または &lt;code&gt;(??{})&lt;/code&gt; と組み合わせた場合にのみ役立つでしょう。</target>
        </trans-unit>
        <trans-unit id="afaea2dff924e16be833d549ac45ba57d1ea538b" translate="yes" xml:space="preserve">
          <source>It is probably useful only when combined with &lt;code&gt;(?{})&lt;/code&gt; or &lt;code&gt;(??{})&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(?{})&lt;/code&gt; または &lt;code&gt;(??{})&lt;/code&gt; と組み合わせた場合にのみ役立つ可能性があります。</target>
        </trans-unit>
        <trans-unit id="cf00d26aa745eb3ee05b04278f9eed1956a14d27" translate="yes" xml:space="preserve">
          <source>It is proposed to change this behavior in a future release of Perl so that whether or not Unicode rules are in effect would not change the behavior: Outside of locale, the POSIX classes would behave like their ASCII-range counterparts. If you wish to comment on this proposal, send email to &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; .</source>
          <target state="translated">Perlの将来のリリースでは、この動作を変更して、Unicodeルールが有効かどうかにかかわらず動作を変更しないようにすることが提案されています。ロケール以外では、POSIXクラスはASCII範囲のクラスのように動作します。この提案にコメントしたい場合は、 &lt;code&gt;perl5-porters@perl.org&lt;/code&gt; にメールを送信してください。</target>
        </trans-unit>
        <trans-unit id="a6c7a14017f055e8f9bd10d510eabf5bf071a9ca" translate="yes" xml:space="preserve">
          <source>It is recommended that for this usage you put the DEFINE block at the end of the pattern, and that you name any subpatterns defined within it.</source>
          <target state="translated">この使用法では、DEFINEブロックをパターンの最後に置き、その中で定義されたサブパターンに名前を付けることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="b57d669e4107366ea65426a960e0887b522f0627" translate="yes" xml:space="preserve">
          <source>It is recommended that you enable this option unless you really need to create a non-standard Zip file.</source>
          <target state="translated">本当に非標準のZipファイルを作成する必要がない限り、このオプションを有効にすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="b5a6bde3e661db2000d4d1c6b83211f16182f9b2" translate="yes" xml:space="preserve">
          <source>It is recommended to &lt;code&gt;use Win32;&lt;/code&gt; before any of these functions; however, for backwards compatibility, those marked as [CORE] will automatically do this for you.</source>
          <target state="translated">&lt;code&gt;use Win32;&lt;/code&gt; を使用することをお勧めします。これらの機能の前。ただし、下位互換性のために、[CORE]とマークされたものは自動的にこれを行います。</target>
        </trans-unit>
        <trans-unit id="fe9f6b9b410e95d779e30fb9ae34ddfb1f7f1185" translate="yes" xml:space="preserve">
          <source>It is reported that the following archives contain enough utils to build perl:</source>
          <target state="translated">以下のアーカイブには、perlをビルドするのに十分なユーティリティが含まれていると報告されています。</target>
        </trans-unit>
        <trans-unit id="eb8af118e1b3c0f503fae4e488d7355647e3de10" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that applications using Opcode should use a leading capital letter on their tag names since lowercase names are reserved for use by the Opcode module. If using Opcode within a module you should prefix your tags names with the name of your module to ensure uniqueness and thus avoid clashes with other modules.</source>
          <target state="translated">小文字の名前はOpcodeモジュールで使用するために予約されているため、Opcodeを使用するアプリケーションでは、タグ名の先頭に大文字を使用することが強く推奨されています。モジュール内でOpcodeを使用する場合は、タグ名の前にモジュールの名前を付けて、独自性を確保し、他のモジュールとの衝突を避けるようにしてください。</target>
        </trans-unit>
        <trans-unit id="2739f66ac90ce9cc53c7717d098a81a175c0dbe7" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that you enable threads via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; as early as possible in your script.</source>
          <target state="translated">スクリプトのできるだけ早い段階で、スレッドを &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; を有効にすることを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="607d6dc00476120329bf70c7f37db42c62c363f4" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that you enable threads via &lt;code&gt;use threads&lt;/code&gt; as early as possible in your script.</source>
          <target state="translated">スクリプトのできるだけ早い段階で、usethreadsを介し &lt;code&gt;use threads&lt;/code&gt; を有効にすることを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="23330295b88e2dfe22f823906399d30b69678a8c" translate="yes" xml:space="preserve">
          <source>It is strongly recommended that you use this flag when you run Configure. If you do not do this, but later answer the question about large files when Configure asks you, you may get a configuration that cannot be compiled, or that does not function as expected.</source>
          <target state="translated">Configure を実行する際には、このフラグを使用することを強くお勧めします。これを行わずに、後になって Configure が大きなファイルについての質問に答えた場合、コンパイルできない設定や期待通りに機能しない設定が得られる可能性があります。</target>
        </trans-unit>
        <trans-unit id="d4398ad9975e0145dd25fc7bc9a7058eb6696304" translate="yes" xml:space="preserve">
          <source>It is suggested that you enable the version of malloc that is distributed with Perl. It keeps pools of various sizes of unallocated memory in order to satisfy allocation requests more quickly. However, on some platforms, it may cause spurious malloc or free errors.</source>
          <target state="translated">Perl で配布されている malloc のバージョンを有効にすることをお勧めします。これは、より迅速に割り当て要求を満たすために、様々なサイズの未割り当てメモリのプールを保持します。しかし、いくつかのプラットフォームでは、これが原因でスプリアス malloc やフリーエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="09d04d7278d56b78f672ffa08fd362fe3b4bb9cb" translate="yes" xml:space="preserve">
          <source>It is the appropriate method to use if you need to get the name of a lexical variable from a padname array. Lexical variable names are always stored with a null terminator, and the length field (CUR) is overloaded for other purposes and can't be relied on here.</source>
          <target state="translated">padname 配列からレキシカル変数の名前を取得する必要がある場合に使用する適切なメソッドです。レキシカル変数名は常にヌルのターミネータで格納され、長さフィールド (CUR)は他の目的のためにオーバーロードされており、ここでは頼りにすることはできません。</target>
        </trans-unit>
        <trans-unit id="6f04d78fbcc86fbb7196577b1692934e2955d725" translate="yes" xml:space="preserve">
          <source>It is therefore strongly recommended that these macros be used by all XS modules that make use of static data.</source>
          <target state="translated">そのため、これらのマクロは、静的データを利用している全てのXSモジュールで利用することを強く推奨します。</target>
        </trans-unit>
        <trans-unit id="6ddce18b6b5d6c4ef9a5cf7c34f05793b72112fd" translate="yes" xml:space="preserve">
          <source>It is typically used to add extra directories to perl's search path so that later &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statements will find modules which are not located on perl's default search path.</source>
          <target state="translated">これは通常、perlの検索パスにディレクトリを追加するために使用されます。これにより、後で &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ステートメントがperlのデフォルトの検索パスにないモジュールを見つけられるようになります。</target>
        </trans-unit>
        <trans-unit id="231d3b33b22966aa08593496a49a29478f187fe4" translate="yes" xml:space="preserve">
          <source>It is typically used to add extra directories to perl's search path so that later &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; statements will find modules which are not located on perl's default search path.</source>
          <target state="translated">これは通常、perlの検索パスにディレクトリを追加するために使用されます。これにより、後で &lt;code&gt;use&lt;/code&gt; または &lt;code&gt;require&lt;/code&gt; ステートメントが、perlのデフォルトの検索パスにないモジュールを検索します。</target>
        </trans-unit>
        <trans-unit id="99fbfb42d30ce39230261b344f6acdd15e39f445" translate="yes" xml:space="preserve">
          <source>It is up to individual Pod formatter to display good judgement when confronted with an unrenderable character (which is distinct from an unknown E&amp;lt;thing&amp;gt; sequence that the parser couldn't resolve to anything, renderable or not). It is good practice to map Latin letters with diacritics (like &quot;E&amp;lt;eacute&amp;gt;&quot;/&quot;E&amp;lt;233&amp;gt;&quot;) to the corresponding unaccented US-ASCII letters (like a simple character 101, &quot;e&quot;), but clearly this is often not feasible, and an unrenderable character may be represented as &quot;?&quot;, or the like. In attempting a sane fallback (as from E&amp;lt;233&amp;gt; to &quot;e&quot;), Pod formatters may use the %Latin1Code_to_fallback table in &lt;a href=&quot;Pod::Escapes&quot;&gt;Pod::Escapes&lt;/a&gt;, or &lt;a href=&quot;Text::Unidecode&quot;&gt;Text::Unidecode&lt;/a&gt;, if available.</source>
          <target state="translated">レンダリング不可能な文字（パーサーがレンダリング可能かどうかに関係なく、何にも解決できなかった未知のE &amp;lt;thing&amp;gt;シーケンスとは異なります）に直面したときに適切な判断を表示するのは、個々のポッドフォーマッター次第です。分音記号付きのラテン文字（ &quot;E &amp;lt;eacute&amp;gt;&quot; / &quot;E &amp;lt;233&amp;gt;&quot;など）を対応するアクセントのないUS-ASCII文字（単純な文字101、 &quot;e&quot;など）にマップすることをお勧めしますが、これは明らかに多くの場合、実行不可能であり、レンダリングできない文字は「？」などで表される場合があります。 （E &amp;lt;233&amp;gt;から &quot;e&quot;へのように）正常なフォールバックを試みる際に、ポッドフォーマッターは&lt;a href=&quot;Pod::Escapes&quot;&gt;Pod :: Escapes&lt;/a&gt;または&lt;a href=&quot;Text::Unidecode&quot;&gt;Text :: Unicode&lt;/a&gt;の％Latin1Code_to_fallbackテーブルを使用できます（利用可能な場合）。</target>
        </trans-unit>
        <trans-unit id="1a7559da192e0561816f87fb94aa112a7e9ecc6d" translate="yes" xml:space="preserve">
          <source>It is up to individual Pod formatter to display good judgement when confronted with an unrenderable character (which is distinct from an unknown E&amp;lt;thing&amp;gt; sequence that the parser couldn't resolve to anything, renderable or not). It is good practice to map Latin letters with diacritics (like &quot;E&amp;lt;eacute&amp;gt;&quot;/&quot;E&amp;lt;233&amp;gt;&quot;) to the corresponding unaccented US-ASCII letters (like a simple character 101, &quot;e&quot;), but clearly this is often not feasible, and an unrenderable character may be represented as &quot;?&quot;, or the like. In attempting a sane fallback (as from E&amp;lt;233&amp;gt; to &quot;e&quot;), Pod formatters may use the %Latin1Code_to_fallback table in &lt;a href=&quot;pod/escapes&quot;&gt;Pod::Escapes&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Unidecode&quot;&gt;Text::Unidecode&lt;/a&gt;, if available.</source>
          <target state="translated">レンダリング不能な文字（パーサーが何も解決できなかった（レンダリング可能かどうかに関係なく）不明なE &amp;lt;thing&amp;gt;シーケンスとは異なる）直面したときに適切な判断を表示するかどうかは、個々のPodフォーマッター次第です。アクセント記号付きのラテン文字（ &quot;E &amp;lt;eacute&amp;gt;&quot; / &quot;E &amp;lt;233&amp;gt;&quot;など）を対応するアクセントなしUS-ASCII文字（単純な文字101、 &quot;e&quot;など）にマップすることをお勧めしますが、これは明らかに多くの場合、実行不可能であり、レンダリングできない文字は「？」などとして表されます。 （E &amp;lt;233&amp;gt;から &quot;e&quot;へのように）正常なフォールバックを試行する際、ポッドフォーマッタは、可能であれば&lt;a href=&quot;pod/escapes&quot;&gt;Pod :: Escapes&lt;/a&gt;または&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Unidecode&quot;&gt;Text :: Unidecode&lt;/a&gt;の％Latin1Code_to_fallbackテーブルを使用できます。</target>
        </trans-unit>
        <trans-unit id="d3fe171c1e178608bc5f92e9c9efc16598ce4a39" translate="yes" xml:space="preserve">
          <source>It is up to you to use this information to populate</source>
          <target state="translated">この情報を使用して、以下の情報を入力するかどうかはあなた次第です。</target>
        </trans-unit>
        <trans-unit id="ce530e54cb38df50f2b9795b42ad1b0802239f94" translate="yes" xml:space="preserve">
          <source>It is usual to pass parameters using global variables (typically $_ for one parameter, or $a and $b for two parameters) rather than via @_. (It is possible to use the @_ mechanism if you know what you're doing, though there is as yet no supported API for it. It's also inherently slower.)</source>
          <target state="translated">パラメータを渡す際には、@_ではなくグローバル変数を使用するのが一般的です (通常、パラメータが一つの場合は $_、二つの場合は $a と $b を使用します)。(何をしているかわかっていれば @_の仕組みを使うことも可能ですが、まだサポートされている API はありません。これは本質的に遅くなります)。</target>
        </trans-unit>
        <trans-unit id="91da970cd331ff859f8e77df6915a3ed4846b274" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to intermix &lt;a href=&quot;#alarm-SECONDS&quot;&gt;&lt;code&gt;alarm&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#sleep-EXPR&quot;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/a&gt; calls, because &lt;a href=&quot;#sleep-EXPR&quot;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/a&gt; may be internally implemented on your system with &lt;a href=&quot;#alarm-SECONDS&quot;&gt;&lt;code&gt;alarm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">これは通常の混在に間違いである&lt;a href=&quot;#alarm-SECONDS&quot;&gt; &lt;code&gt;alarm&lt;/code&gt; &lt;/a&gt;や&lt;a href=&quot;#sleep-EXPR&quot;&gt; &lt;code&gt;sleep&lt;/code&gt; &lt;/a&gt;ので、通話&lt;a href=&quot;#sleep-EXPR&quot;&gt; &lt;code&gt;sleep&lt;/code&gt; &lt;/a&gt;内部であなたのシステム上に実装することができる&lt;a href=&quot;#alarm-SECONDS&quot;&gt; &lt;code&gt;alarm&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="69c5d14186ab57b1e0629e917b8215f824fb1b8c" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to intermix &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; may be internally implemented on your system with &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは通常の混在に間違いである &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; ので、通話 &lt;code&gt;&lt;a href=&quot;sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 内部であなたのシステム上に実装することができる &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18d1691040dfd4fd0aeb2ca9801dad0c1249aa8e" translate="yes" xml:space="preserve">
          <source>It is usually a mistake to intermix &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; calls, because &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; may be internally implemented on your system with &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これは通常の混在に間違いである &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; ので、通話 &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep&lt;/a&gt;&lt;/code&gt; 内部であなたのシステム上に実装することができる &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f94317c7d8a68b955ef8fad7379f1f684a3e243d" translate="yes" xml:space="preserve">
          <source>It is usually impossible to add new syntax to Perl without breaking some existing programs. This pragma provides a way to minimize that risk. New syntactic constructs, or new semantic meanings to older constructs, can be enabled by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'foo'&lt;/code&gt; , and will be parsed only when the appropriate feature pragma is in scope. (Nevertheless, the &lt;code&gt;CORE::&lt;/code&gt; prefix provides access to all Perl keywords, regardless of this pragma.)</source>
          <target state="translated">いくつかの既存のプログラムを壊さずにPerlに新しい構文を追加することは通常不可能です。このプラグマは、そのリスクを最小限に抑える方法を提供します。新しい構文構造、または古い構造に対する新しい意味の意味は、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'foo'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用して&lt;/a&gt;有効にでき、適切な機能プラグマがスコープ内にある場合にのみ解析されます。（それにもかかわらず、 &lt;code&gt;CORE::&lt;/code&gt; プレフィックスは、このプラグマに関係なく、すべてのPerlキーワードへのアクセスを提供します。）</target>
        </trans-unit>
        <trans-unit id="0f612a30494cb1971874c3ee4fc77442da7514cc" translate="yes" xml:space="preserve">
          <source>It is usually impossible to add new syntax to Perl without breaking some existing programs. This pragma provides a way to minimize that risk. New syntactic constructs, or new semantic meanings to older constructs, can be enabled by &lt;code&gt;use feature 'foo'&lt;/code&gt;, and will be parsed only when the appropriate feature pragma is in scope. (Nevertheless, the &lt;code&gt;CORE::&lt;/code&gt; prefix provides access to all Perl keywords, regardless of this pragma.)</source>
          <target state="translated">通常、既存のプログラムを壊さずに新しい構文をPerlに追加することは不可能です。このプラグマは、そのリスクを最小限に抑える方法を提供します。新しい構文構造、または古い構造に対する新しい意味の意味は、 &lt;code&gt;use feature 'foo'&lt;/code&gt; 有効にでき、適切な機能プラグマがスコープ内にある場合にのみ解析されます。（それでも、 &lt;code&gt;CORE::&lt;/code&gt; プレフィックスは、このプラグマに関係なく、すべてのPerlキーワードへのアクセスを提供します。）</target>
        </trans-unit>
        <trans-unit id="8825373ed061df5a7897772f25e6f03f473b0a3c" translate="yes" xml:space="preserve">
          <source>It is very common to want to do encoding transformations when reading or writing files, network connections, pipes etc. If Perl is configured to use the new 'perlio' IO system then &lt;code&gt;Encode&lt;/code&gt; provides a &quot;layer&quot; (see &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;) which can transform data as it is read or written.</source>
          <target state="translated">ファイル、ネットワーク接続、パイプなどの読み取りまたは書き込み時にエンコード変換を実行することは非常に一般的です。Perlが新しい「perlio」IOシステムを使用するように構成されている場合、 &lt;code&gt;Encode&lt;/code&gt; はデータを変換できる「レイヤー」（&lt;a href=&quot;perlio&quot;&gt;PerlIOを&lt;/a&gt;参照）を提供します。読み取りまたは書き込み時に。</target>
        </trans-unit>
        <trans-unit id="60c64d5138091e34ac4e66a3176bc2904d419a6d" translate="yes" xml:space="preserve">
          <source>It is very common when filtering source to only want to apply the filter to the non-character-string parts of the code, or alternatively to</source>
          <target state="translated">ソースをフィルタリングする際に、コードの文字列以外の部分だけにフィルタを適用したい場合や、代わりに</target>
        </trans-unit>
        <trans-unit id="7507ed7a14e59c863596321d293c86dd2f1471ac" translate="yes" xml:space="preserve">
          <source>It is very easy to dead-lock a process using this form of open(), or indeed with any use of pipe() with multiple subprocesses. The example above is &quot;safe&quot; because it is simple and calls exec(). See &lt;a href=&quot;#Avoiding-Pipe-Deadlocks&quot;&gt;&quot;Avoiding Pipe Deadlocks&quot;&lt;/a&gt; for general safety principles, but there are extra gotchas with Safe Pipe Opens.</source>
          <target state="translated">この形式のopen（）を使用して、または実際に複数のサブプロセスでpipe（）を使用すると、プロセスをデッドロックするのは非常に簡単です。上記の例は単純でexec（）を呼び出すため、「安全」です。一般的な安全原則については、&lt;a href=&quot;#Avoiding-Pipe-Deadlocks&quot;&gt;「パイプのデッドロックの回避」を&lt;/a&gt;参照してください。ただし、セーフパイプオープンには追加の落とし穴があります。</target>
        </trans-unit>
        <trans-unit id="7df1696685d7983c694bb3c5409a0395bf0e003f" translate="yes" xml:space="preserve">
          <source>It is very easy to dead-lock a process using this form of open(), or indeed with any use of pipe() with multiple subprocesses. The example above is &quot;safe&quot; because it is simple and calls exec(). See &lt;a href=&quot;#Avoiding-Pipe-Deadlocks&quot;&gt;Avoiding Pipe Deadlocks&lt;/a&gt; for general safety principles, but there are extra gotchas with Safe Pipe Opens.</source>
          <target state="translated">この形式のopen（）を使用してプロセスをデッドロックするのは非常に簡単です。実際、複数のサブプロセスでpipe（）を使用する場合も同様です。上記の例は簡単でexec（）を呼び出すため、「安全」です。一般的な安全原則については、&lt;a href=&quot;#Avoiding-Pipe-Deadlocks&quot;&gt;パイプのデッドロックの回避を&lt;/a&gt;参照してください。ただし、安全なパイプを開くには、余分な問題があります。</target>
        </trans-unit>
        <trans-unit id="1f2733d85a83af59b86ea7ca3eeb7a8a21d68e5a" translate="yes" xml:space="preserve">
          <source>It is very easy to get tripped up using a mixture of other programs, external utilities, and Perl scripts that are in varying states of being able to handle case preservation. For example, a file created by an older version of an archive utility or a build utility such as MMK or MMS may generate a filename in all upper case even on an ODS-5 volume. If this filename is later retrieved by a Perl script or module in a case preserving environment, that upper case name may not match the mixed-case or lower-case expectations of the Perl code. Your best bet is to follow an all-or-nothing approach to case preservation: either don't use it at all, or make sure your entire toolchain and application environment support and use it.</source>
          <target state="translated">大文字小文字の保存を扱える状態が異なる他のプログラム、外部ユーティリティ、Perlスクリプトが混在していると、非常につまずきやすくなります。例えば、古いバージョンのアーカイブユーティリティや MMK や MMS のようなビルドユーティリティによって作成されたファイルは、ODS-5 ボリューム上であっても、すべて大文字でファイル名を生成することがあります。このファイル名が後に大文字小文字を保存した環境で Perl スクリプトやモジュールによって取得された場合、大文字と小文字が混在した Perl コードの期待値と一致しない可能性があります。最善の策は、大文字小文字の区別を一切つけないアプローチに従うことです。</target>
        </trans-unit>
        <trans-unit id="1057ac1e814cd9a3566a8fed96cf94293953ec7a" translate="yes" xml:space="preserve">
          <source>It is very easy to recover the source of Perl programs. You simply feed the program to the perl interpreter and use the modules in the B:: hierarchy. The B::Deparse module should be able to defeat most attempts to hide source. Again, this is not unique to Perl.</source>
          <target state="translated">Perlプログラムのソースを復元するのは非常に簡単です。単にプログラムを perl インタプリタに送り、B::階層のモジュールを使用するだけです。B::Deparse モジュールは、ソースを隠そうとするほとんどの試みを打ち破ることができるはずです。繰り返しになりますが、これは Perl に特有のものではありません。</target>
        </trans-unit>
        <trans-unit id="d5b6f5cbb4ab2d2416457262d0018311cb6ac8d2" translate="yes" xml:space="preserve">
          <source>It is very possible that this document will fall far short of being useful to the casual reader. The reader is expected to understand the material in the first few sections of &lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">このドキュメントは、カジュアルな読者にとってはあまり役に立たない可能性があります。読者は&lt;a href=&quot;../perlguts&quot;&gt;perlgutsの&lt;/a&gt;最初の数セクションの内容を理解することが期待されています。</target>
        </trans-unit>
        <trans-unit id="8bf9b3e35a922a415eaeb6feb2defbf0bc762198" translate="yes" xml:space="preserve">
          <source>It is very possible that this document will fall far short of being useful to the casual reader. The reader is expected to understand the material in the first few sections of &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">このドキュメントは、カジュアルな読者にはあまり役に立たない可能性があります。読者は、&lt;a href=&quot;perlguts&quot;&gt;perlgutsの&lt;/a&gt;最初の数セクションの内容を理解することが期待されています。</target>
        </trans-unit>
        <trans-unit id="055458523774899083238688c776d433516198d1" translate="yes" xml:space="preserve">
          <source>It is worth drawing particular attention to the expected ranges for the values provided. The value for the day of the month is the actual day (i.e. 1..31), while the month is the number of months since January (0..11). This is consistent with the values returned from &lt;code&gt;localtime()&lt;/code&gt; and &lt;code&gt;gmtime()&lt;/code&gt;.</source>
          <target state="translated">提供された値の予想範囲に特に注意を払う価値があります。月の日の値は実際の日（つまり1..31）であり、月は1月からの月数（0..11）です。これは、 &lt;code&gt;localtime()&lt;/code&gt; および &lt;code&gt;gmtime()&lt;/code&gt; から返される値と一致しています。</target>
        </trans-unit>
        <trans-unit id="5424072f53b20136acc827f23a7b8403963d2596" translate="yes" xml:space="preserve">
          <source>It is worth drawing particular attention to the expected ranges for the values provided. The value for the day of the month is the actual day (ie 1..31), while the month is the number of months since January (0..11). This is consistent with the values returned from &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">提供された値の予想範囲に特に注意を払う価値があります。月の日の値は実際の日（つまり1..31）であり、月は1月からの月数（0..11）です。これは、 &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;../functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; から返される値と一致しています。</target>
        </trans-unit>
        <trans-unit id="c12cfe0a130e1abce3e789227eb445dc3d70c311" translate="yes" xml:space="preserve">
          <source>It is worth emphasizing that &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , etc, match single characters, not complete numbers or words. To match a number (that consists of digits), use &lt;code&gt;\d+&lt;/code&gt; ; to match a word, use &lt;code&gt;\w+&lt;/code&gt; . But be aware of the security considerations in doing so, as mentioned above.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 、 &lt;code&gt;\w&lt;/code&gt; などは、完全な数字や単語ではなく単一の文字と一致することを強調しておく価値があります。数字（数字で構成される）を照合するには、 &lt;code&gt;\d+&lt;/code&gt; 使用します。単語に一致させるには、 &lt;code&gt;\w+&lt;/code&gt; 使用します。ただし、上記のように、セキュリティに関する考慮事項に注意してください。</target>
        </trans-unit>
        <trans-unit id="113a0e58d547793b729e9fa965a701228f317998" translate="yes" xml:space="preserve">
          <source>It is worth emphasizing that &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt;, etc, match single characters, not complete numbers or words. To match a number (that consists of digits), use &lt;code&gt;\d+&lt;/code&gt;; to match a word, use &lt;code&gt;\w+&lt;/code&gt;. But be aware of the security considerations in doing so, as mentioned above.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 、 &lt;code&gt;\w&lt;/code&gt; などは、完全な数字や単語ではなく、単一の文字に一致することを強調する価値があります。数字（数字で構成される）を照合するには、 &lt;code&gt;\d+&lt;/code&gt; ;を使用します。単語に一致させるには、 &lt;code&gt;\w+&lt;/code&gt; 使用します。ただし、前述のように、そうする際のセキュリティ上の考慮事項に注意してください。</target>
        </trans-unit>
        <trans-unit id="78ab6d3ec3a28b829b407073297587d950173f49" translate="yes" xml:space="preserve">
          <source>It is worth noting that &lt;code&gt;\G&lt;/code&gt; improperly used can result in an infinite loop. Take care when using patterns that include &lt;code&gt;\G&lt;/code&gt; in an alternation.</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; 不適切に使用すると、無限ループが発生する可能性があることに注意してください。 &lt;code&gt;\G&lt;/code&gt; を含むパターンを交互に使用するときは注意してください。</target>
        </trans-unit>
        <trans-unit id="db9514e6a01f9d85b4ef7b0e350a06b34e756aba" translate="yes" xml:space="preserve">
          <source>It is worth stressing that there are several different sets of digits in Unicode that are equivalent to 0-9 and are matchable by &lt;code&gt;\d&lt;/code&gt; in a regular expression. If they are used in a single language only, they are in that language's &lt;code&gt;Script&lt;/code&gt; and &lt;code&gt;Script_Extension&lt;/code&gt; . If they are used in more than one script, they will be in &lt;code&gt;sc=Common&lt;/code&gt; , but only if they are used in many scripts should they be in &lt;code&gt;scx=Common&lt;/code&gt; .</source>
          <target state="translated">Unicodeには、0〜9に相当し、正規表現の &lt;code&gt;\d&lt;/code&gt; と一致する数字のセットがいくつかあることを強調しておきます。それらが単一の言語でのみ使用されている場合、それらはその言語の &lt;code&gt;Script&lt;/code&gt; および &lt;code&gt;Script_Extension&lt;/code&gt; にあります。それらが複数のスクリプトで使用されている場合、それらは &lt;code&gt;sc=Common&lt;/code&gt; に &lt;code&gt;scx=Common&lt;/code&gt; ますが、多くのスクリプトで使用されている場合のみ、scx = Commonに含まれている必要があります。</target>
        </trans-unit>
        <trans-unit id="c0195b5ac1ee6ed9e15cca2ca1c3622950d2b3cb" translate="yes" xml:space="preserve">
          <source>It is worth stressing that there are several different sets of digits in Unicode that are equivalent to 0-9 and are matchable by &lt;code&gt;\d&lt;/code&gt; in a regular expression. If they are used in a single language only, they are in that language's &lt;code&gt;Script&lt;/code&gt; and &lt;code&gt;Script_Extensions&lt;/code&gt;. If they are used in more than one script, they will be in &lt;code&gt;sc=Common&lt;/code&gt;, but only if they are used in many scripts should they be in &lt;code&gt;scx=Common&lt;/code&gt;.</source>
          <target state="translated">Unicodeには、0〜9に相当し、正規表現の &lt;code&gt;\d&lt;/code&gt; で一致するいくつかの異なる数字のセットがあることを強調する価値があります。それらが単一の言語でのみ使用されている場合、それらはその言語の &lt;code&gt;Script&lt;/code&gt; および &lt;code&gt;Script_Extensions&lt;/code&gt; にあります。それらが複数のスクリプトで使用されている場合、それらは &lt;code&gt;sc=Common&lt;/code&gt; になりますが、多くのスクリプトで使用されている場合にのみ、 &lt;code&gt;scx=Common&lt;/code&gt; にある必要があります。</target>
        </trans-unit>
        <trans-unit id="bb73a60f536c984fec748fd56250217ac857070f" translate="yes" xml:space="preserve">
          <source>It is, after all, just a guess. You should alway be explicit when it comes to encodings. But there are some, especially Japanese, environment that guess-coding is a must. Use this module with care.</source>
          <target state="translated">それは結局のところ、単なる推測に過ぎません。エンコーディングに関しては、常に明示的にする必要があります。しかし、特に日本語の環境によっては推測符号化が必須となる場合があります。このモジュールは注意して使ってください。</target>
        </trans-unit>
        <trans-unit id="b1fd4c29544df6031e0c7f381c345fa955c2ddef" translate="yes" xml:space="preserve">
          <source>It is, however, very simple, pure Perl, and it has no non-core dependencies. It also provides a &quot;Moose-like&quot; API on demand for the features it supports.</source>
          <target state="translated">しかし、これは非常にシンプルで純粋な Perl であり、コアではない依存関係はありません。また、サポートしている機能のために、オンデマンドで &quot;Moe-like&quot; API を提供しています。</target>
        </trans-unit>
        <trans-unit id="358ba9c90802ce677d93df629a1697c0599e5843" translate="yes" xml:space="preserve">
          <source>It isn't possible to create a true reference to an IO handle (filehandle or dirhandle) using the backslash operator. The most you can get is a reference to a typeglob, which is actually a complete symbol table entry. But see the explanation of the &lt;code&gt;*foo{THING}&lt;/code&gt; syntax below. However, you can still use type globs and globrefs as though they were IO handles.</source>
          <target state="translated">バックスラッシュ演算子を使用して、IOハンドル（ファイルハンドルまたはディレクトリハンドル）への真の参照を作成することはできません。取得できるのは、実際には完全なシンボルテーブルエントリであるtypeglobへの参照です。ただし、以下の &lt;code&gt;*foo{THING}&lt;/code&gt; 構文の説明を参照してください。ただし、タイプグロブとグロブリファレンスは、IOハンドルであるかのように使用できます。</target>
        </trans-unit>
        <trans-unit id="be4ec9fbbf231e40204d7019d3f997c286ceaaf0" translate="yes" xml:space="preserve">
          <source>It lets by &lt;code&gt;$(...)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$(...)&lt;/code&gt; でできます。</target>
        </trans-unit>
        <trans-unit id="1272cce995365257b29707c07e056e98c158a0d6" translate="yes" xml:space="preserve">
          <source>It may also be useful to create a batch file called lib.bat in C:\Program Files\Microsoft Visual C++ Toolkit 2003\bin containing:</source>
          <target state="translated">また、C:\Program Files\Microsoft Visual C++Toolkit 2003 に lib.bat というバッチファイルを作成しておくと便利かもしれません。</target>
        </trans-unit>
        <trans-unit id="c3ee59300b49b89fa621ccf66f9ee189105bf2cd" translate="yes" xml:space="preserve">
          <source>It may also indicate a misspelled constant that has been interpreted as a bareword:</source>
          <target state="translated">また、スペルミスをした定数が裸語として解釈されたことを示すこともあります。</target>
        </trans-unit>
        <trans-unit id="fb79d7ce93f65d8007a6c3362149cd125568d552" translate="yes" xml:space="preserve">
          <source>It may be common (for example at your main lexicon) that the hash keys and values coincide. Like that</source>
          <target state="translated">ハッシュキーと値が一致しているのは、よくあることかもしれません(例えば、あなたのメインレキシコンで)。そのような</target>
        </trans-unit>
        <trans-unit id="3d71937f4e01c4691f8ad6115319d1b1a1cc17dc" translate="yes" xml:space="preserve">
          <source>It may be handy to add a function or method to retrieve the number. Use the number in announcements and archive file names when releasing the module (ModuleName-1.02.tar.Z). See perldoc ExtUtils::MakeMaker.pm for details.</source>
          <target state="translated">番号を取得する関数やメソッドを追加しておくと便利かもしれません。モジュール(ModuleName-1.02.tar.Z)をリリースする際に、アナウンスやアーカイブファイル名にこの番号を使用してください。詳細は perldoc ExtUtils::MakeMaker.pm を参照してください。</target>
        </trans-unit>
        <trans-unit id="4aba7fcd954a7d79c58b4c5db5fcca156f49cb64" translate="yes" xml:space="preserve">
          <source>It may be helpful to always use the forked debugger so that script I/O is separated from debugger I/O. You can force the debugger to be forked by assigning a value to the logical name &amp;lt;PERLDB_PIDS&amp;gt; that is not a process identification number.</source>
          <target state="translated">スクリプトI / OがデバッガーI / Oから分離されるように、常にフォークされたデバッガーを使用すると役立つ場合があります。プロセス識別番号ではない論理名&amp;lt;PERLDB_PIDS&amp;gt;に値を割り当てることにより、デバッガーを強制的に分岐させることができます。</target>
        </trans-unit>
        <trans-unit id="c878552ffbfe93e8fcd546e6ba5f54b617695a5d" translate="yes" xml:space="preserve">
          <source>It may be more portable to use the &lt;a href=&quot;File::Copy&quot;&gt;File::Copy&lt;/a&gt; module instead. You just copy to the new file to the new name (checking return values), then delete the old one. This isn't really the same semantically as a &lt;code&gt;rename()&lt;/code&gt;, which preserves meta-information like permissions, timestamps, inode info, etc.</source>
          <target state="translated">代わりに&lt;a href=&quot;File::Copy&quot;&gt;File :: Copy&lt;/a&gt;モジュールを使用する方が移植性が高い場合があります。新しいファイルに新しい名前でコピーし（戻り値を確認）、古いファイルを削除するだけです。これは、権限、タイムスタンプ、iノード情報などのメタ情報を保持する &lt;code&gt;rename()&lt;/code&gt; と意味的には実際には同じではありません。</target>
        </trans-unit>
        <trans-unit id="9cf5a525be6e13a9a7b1dd1dbd184cb474cd50ab" translate="yes" xml:space="preserve">
          <source>It may be more portable to use the &lt;a href=&quot;file/copy&quot;&gt;File::Copy&lt;/a&gt; module instead. You just copy to the new file to the new name (checking return values), then delete the old one. This isn't really the same semantically as a &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt;, which preserves meta-information like permissions, timestamps, inode info, etc.</source>
          <target state="translated">代わりに&lt;a href=&quot;file/copy&quot;&gt;File :: Copy&lt;/a&gt;モジュールを使用する方が移植性が高い場合があります。新しいファイルに新しい名前でコピーし（戻り値を確認）、古いファイルを削除します。これは、パーミッション、タイムスタンプ、inode情報などのメタ情報を保持する &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; と意味的には同じではありません。</target>
        </trans-unit>
        <trans-unit id="db6d5d1cd198cf53911efce9b9d95d5989e30fc0" translate="yes" xml:space="preserve">
          <source>It may be possible to code a simple workaround which would</source>
          <target state="translated">以下のような簡単な回避策をコード化することができるかもしれません。</target>
        </trans-unit>
        <trans-unit id="2d1547ff72328148f73028b4bf53e65cca15e95b" translate="yes" xml:space="preserve">
          <source>It may be possible to use the Entropy Gathering Daemon (written in Perl!), available from &lt;a href=&quot;http://www.lothar.com/tech/crypto/&quot;&gt;http://www.lothar.com/tech/crypto/&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.lothar.com/tech/crypto/&quot;&gt;http://www.lothar.com/tech/crypto/&lt;/a&gt;から入手できる（Perlで書かれた）Entropy Gathering Daemonを使用できる場合があります。</target>
        </trans-unit>
        <trans-unit id="ea7e33e821e865ae246a0ffae0bdba930182de6b" translate="yes" xml:space="preserve">
          <source>It may seem obvious to say, but Perl is useful only when users can easily find it. When possible, it's good for both</source>
          <target state="translated">当たり前のことを言っているように思えるかもしれませんが、Perlはユーザが簡単に見つけられるようになって初めて便利になります。可能であれば</target>
        </trans-unit>
        <trans-unit id="fd3430c5befbd819886aa0fff01863d985392126" translate="yes" xml:space="preserve">
          <source>It might conceivably chdir() you out of a directory that it can't chdir() you back into. If fastcwd encounters a problem it will return undef but will probably leave you in a different directory. For a measure of extra security, if everything appears to have worked, the fastcwd() function will check that it leaves you in the same directory that it started in. If it has changed it will &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with the message &quot;Unstable directory path, current directory changed unexpectedly&quot;. That should never happen.</source>
          <target state="translated">おそらく、chdir（）でディレクトリに戻れず、chdir（）で戻せない可能性があります。fastcwdで問題が発生した場合は、undefが返されますが、別のディレクトリにいる可能性があります。すべてが働いているように見える場合は、余分なセキュリティの対策については、fastcwd（）関数は、それが中に開始したことを同じディレクトリにあなたを残していることを確認します。それがされます変更された場合は &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; メッセージ「不安定なディレクトリパス、現在でディレクトリが予期せず変更されました。」それは決して起こらないはずです。</target>
        </trans-unit>
        <trans-unit id="6269f7c0874b90d11b774dcb29c6ab77d94be05c" translate="yes" xml:space="preserve">
          <source>It might conceivably chdir() you out of a directory that it can't chdir() you back into. If fastcwd encounters a problem it will return undef but will probably leave you in a different directory. For a measure of extra security, if everything appears to have worked, the fastcwd() function will check that it leaves you in the same directory that it started in. If it has changed it will &lt;code&gt;die&lt;/code&gt; with the message &quot;Unstable directory path, current directory changed unexpectedly&quot;. That should never happen.</source>
          <target state="translated">おそらく、あなたをchdir（）に戻すことができないディレクトリからあなたをchdir（）するかもしれません。 fastcwdで問題が発生した場合、undefが返されますが、おそらく別のディレクトリに残ります。すべてが働いているように見える場合は、余分なセキュリティの対策については、fastcwd（）関数は、それが中に開始したことを同じディレクトリにあなたを残していることを確認します。それがされます変更された場合は &lt;code&gt;die&lt;/code&gt; メッセージ「不安定なディレクトリパス、現在でディレクトリが予期せず変更されました」。それは決して起こらないはずです。</target>
        </trans-unit>
        <trans-unit id="4a597e04d91d3290c6b9fa9abe20a400d22f03ff" translate="yes" xml:space="preserve">
          <source>It might seem possible eliminate slab reference counts altogether, by having all ops implicitly attached to &lt;code&gt;PL_compcv&lt;/code&gt; when allocated and freed when the CV is freed. That would also allow &lt;code&gt;op_free&lt;/code&gt; to skip &lt;code&gt;FreeOp&lt;/code&gt; altogether, and thus free ops faster. But that doesn't work in those cases where ops need to survive beyond their CVs, such as re-evals.</source>
          <target state="translated">割り当て時にすべてのopsを &lt;code&gt;PL_compcv&lt;/code&gt; に暗黙的にアタッチし、CVが解放されると解放されることで、スラブ参照カウントを完全に排除できるように思われるかもしれません。これにより、 &lt;code&gt;op_free&lt;/code&gt; は &lt;code&gt;FreeOp&lt;/code&gt; を完全にスキップできるため、opsをより速く解放できます。ただし、再評価など、運用がCVを超えて存続する必要がある場合は機能しません。</target>
        </trans-unit>
        <trans-unit id="642edf6b6e0c22a6bf4368f6631f6fe45a077e55" translate="yes" xml:space="preserve">
          <source>It monkeypatches Test::Builder, and calls it &quot;black magic&quot; in the code.</source>
          <target state="translated">Test::Builderをモンキーパッチして、コードの中で「黒魔術」と呼んでいます。</target>
        </trans-unit>
        <trans-unit id="106694ead18b1135cc07d2ae597d50b20a4d8af6" translate="yes" xml:space="preserve">
          <source>It must be stressed that the DynaLoader, by itself, is practically useless for accessing non-Perl libraries because it provides almost no Perl-to-C 'glue'. There is, for example, no mechanism for calling a C library function or supplying arguments. A C::DynaLib module is available from CPAN sites which performs that function for some common system types. And since the year 2000, there's also Inline::C, a module that allows you to write Perl subroutines in C. Also available from your local CPAN site.</source>
          <target state="translated">強調しておきたいのは、DynaLoaderはそれ自体がPerl以外のライブラリへのアクセスにはほとんど役に立たないということです。例えば、Cライブラリの関数を呼び出したり、引数を与えたりするメカニズムはありません。C::DynaLibモジュールはCPANのサイトから入手可能で、いくつかの一般的なシステムタイプのためにその機能を実行します。また、2000年以降は、PerlのサブルーチンをCで書くことができるモジュールであるInline::Cもあります。</target>
        </trans-unit>
        <trans-unit id="8bc1cb6024aa942bd48b262d31d7cf7f97b8a25f" translate="yes" xml:space="preserve">
          <source>It occurs to you that this is not the prettiest code you've ever written, but this seems the way to go. You mail off to the translators asking for translations for these four cases. The Chinese guy replies with the one phrase that these all translate to in Chinese, and that phrase has two &quot;%g&quot;s in it, as it should -- but there's a problem. He translates it word-for-word back: &quot;In %g directories contains %g files match your query.&quot; The %g slots are in an order reverse to what they are in English. You wonder how you'll get gettext to handle that.</source>
          <target state="translated">これまでに書いたコードの中で一番きれいなコードではないことに気がつきました。あなたは翻訳者にメールを送り、これら4つのケースの翻訳を依頼しました。中国人の男は、これらすべてが中国語に翻訳される1つのフレーズを返信してくれましたが、そのフレーズには2つの&quot;%g &quot;が含まれています。彼はそれを一字一句訳して返します。&quot;%g ディレクトリには、クエリにマッチする %g ファイルが含まれています。&quot; gスロットは英語とは逆の順番になっています。これをどうやってgettextで処理するのかと考えてしまいます。</target>
        </trans-unit>
        <trans-unit id="04aa081b59ff3888239972218e3f56b3b6581f1f" translate="yes" xml:space="preserve">
          <source>It particular, it's important to &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize $_ in any routine that assigns to it. Look out for implicit assignments in &lt;code&gt;while&lt;/code&gt; conditionals.</source>
          <target state="translated">特に、$ _を割り当てるルーチンで$ _ を &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; することが重要です。 &lt;code&gt;while&lt;/code&gt; 条件付きの暗黙の割り当てに注意してください。</target>
        </trans-unit>
        <trans-unit id="e9fad7940bb559b8eb57657aa029f3c734e1bf6b" translate="yes" xml:space="preserve">
          <source>It particular, it's important to &lt;code&gt;local&lt;/code&gt;ize $_ in any routine that assigns to it. Look out for implicit assignments in &lt;code&gt;while&lt;/code&gt; conditionals.</source>
          <target state="translated">これは特に、それはにとって重要な &lt;code&gt;local&lt;/code&gt; 任意のルーチンでIZEの$ _それに割り当てます。 &lt;code&gt;while&lt;/code&gt; 条件文の暗黙的な割り当てに注意してください。</target>
        </trans-unit>
        <trans-unit id="cd14db27f979e38e1e8d4c1576f9b693597877fa" translate="yes" xml:space="preserve">
          <source>It performs the following actions:</source>
          <target state="translated">以下の動作を行います。</target>
        </trans-unit>
        <trans-unit id="3a77cf9922a9fef0374667dd7650f3414798d318" translate="yes" xml:space="preserve">
          <source>It prints (without so many line breaks)</source>
          <target state="translated">印刷されます(改行があまりなくても</target>
        </trans-unit>
        <trans-unit id="f4bd0cc34b746267dc944192fe3c01787ec4e363" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder since print calls &lt;code&gt;bdiv()&lt;/code&gt; in list context. Also, &lt;code&gt;bdiv()&lt;/code&gt; will modify $c, so be careful. You probably want to use</source>
          <target state="translated">printはリストコンテキストで &lt;code&gt;bdiv()&lt;/code&gt; を呼び出すため、商と剰余の両方を出力します。また、 &lt;code&gt;bdiv()&lt;/code&gt; は$ cを変更するため、注意が必要です。おそらく使いたい</target>
        </trans-unit>
        <trans-unit id="eeeedb6aa3743486c6e5b956ff78abba71960946" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder since print works in list context. Also, bdiv() will modify $c, so be careful. You probably want to use</source>
          <target state="translated">printはリストコンテキストで動作するので、商と余りの両方を表示します。また、bdiv()は $c を変更しますので、注意してください。おそらく</target>
        </trans-unit>
        <trans-unit id="f734db0d61221ca40b0fe2bebce3caa4e0b18089" translate="yes" xml:space="preserve">
          <source>It prints both quotient and remainder, since print calls &lt;code&gt;brsft()&lt;/code&gt; in list context. Also, &lt;code&gt;$c-&amp;gt;brsft()&lt;/code&gt; will modify $c, so be careful. You probably want to use</source>
          <target state="translated">printはリストコンテキストで &lt;code&gt;brsft()&lt;/code&gt; を呼び出すため、商と剰余の両方を出力します。また、 &lt;code&gt;$c-&amp;gt;brsft()&lt;/code&gt; は$ cを変更するので注意してください。おそらく使いたい</target>
        </trans-unit>
        <trans-unit id="ce7853179bda4d7415dfcdbc4fb24a48d915ca39" translate="yes" xml:space="preserve">
          <source>It prints both the number of digits in the number and in the fraction part since print calls &lt;code&gt;&lt;a href=&quot;../functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; in list context. Use something like:</source>
          <target state="translated">printはリストコンテキストで &lt;code&gt;&lt;a href=&quot;../functions/length&quot;&gt;length()&lt;/a&gt;&lt;/code&gt; を呼び出しているため、数値と小数部の両方の桁数を出力します。次のようなものを使用してください：</target>
        </trans-unit>
        <trans-unit id="ae3e52e7991a13cb3327228cb99597bd25c0f239" translate="yes" xml:space="preserve">
          <source>It prints both the number of digits in the number and in the fraction part since print calls &lt;code&gt;length()&lt;/code&gt; in list context. Use something like:</source>
          <target state="translated">printはリストコンテキストで &lt;code&gt;length()&lt;/code&gt; を呼び出すため、数値と小数部の両方の桁数を出力します。次のようなものを使用します：</target>
        </trans-unit>
        <trans-unit id="29cdbd5e538c2f505e08e3d1eef02e06fd63d99d" translate="yes" xml:space="preserve">
          <source>It prints the sequence number of each subroutine call and the name of the called subroutine. Note that &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; is being compiled into the package &lt;code&gt;DB&lt;/code&gt; through the use of the &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; directive.</source>
          <target state="translated">各サブルーチン呼び出しのシーケンス番号と呼び出されたサブルーチンの名前を出力します。 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; ディレクティブを使用してパッケージ &lt;code&gt;DB&lt;/code&gt; にコンパイルされていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9851cbd8d563f766b9710d226d03fcd351760c96" translate="yes" xml:space="preserve">
          <source>It prints the sequence number of each subroutine call and the name of the called subroutine. Note that &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; is being compiled into the package &lt;code&gt;DB&lt;/code&gt; through the use of the &lt;code&gt;package&lt;/code&gt; directive.</source>
          <target state="translated">各サブルーチン呼び出しのシーケンス番号と呼び出されたサブルーチンの名前を出力します。 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; は、 &lt;code&gt;package&lt;/code&gt; ディレクティブを使用してパッケージ &lt;code&gt;DB&lt;/code&gt; にコンパイルされていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="8dc0745e2373dd8461369aabf029a5713236cbd6" translate="yes" xml:space="preserve">
          <source>It properly handles the locale radix character, meaning it expects a dot except when called from within the scope of &lt;code&gt;use locale&lt;/code&gt;, in which case the radix character should be that specified by the current locale.</source>
          <target state="translated">ロケールの基数文字を適切に処理します。つまり、 &lt;code&gt;use locale&lt;/code&gt; の範囲内から呼び出された場合を除き、ドットが必要です。この場合、基数文字は現在のロケールで指定されたものである必要があります。</target>
        </trans-unit>
        <trans-unit id="1eb15b033b8c4d79b1e008f6b581eebb8e9cf4d5" translate="yes" xml:space="preserve">
          <source>It provides a number of mechanisms for querying this information.</source>
          <target state="translated">この情報を問い合わせるための多くのメカニズムを提供しています。</target>
        </trans-unit>
        <trans-unit id="b8c1724bc25d41f7c44c94651a6709f709b79e5f" translate="yes" xml:space="preserve">
          <source>It provides default implementations for the methods</source>
          <target state="translated">メソッドのデフォルトの実装を提供します。</target>
        </trans-unit>
        <trans-unit id="991237cf5d3fbec5f0d4f7d308f07d6c33c5c843" translate="yes" xml:space="preserve">
          <source>It rarely happens, but sometimes a harness might encounter 'missing tests:</source>
          <target state="translated">滅多に起こることではありませんが、ハーネスが「ミッシングテスト」に遭遇することがあります。</target>
        </trans-unit>
        <trans-unit id="58b94065e144f3ae0a0ee1916ab6d2ce54ccb558" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property Comp_Ex (Full_Composition_Exclusion). This property is generated from Composition Exclusions + Singletons + Non-Starter Decompositions.</source>
          <target state="translated">派生プロパティ Comp_Ex (Full_Composition_Exclusion)のブール値を返します。このプロパティは、Composition Exclusions+Singletons+Non-Starter Decomposition から生成されます。</target>
        </trans-unit>
        <trans-unit id="2104ee6f115c01f93c99709b67d509e11442417d" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFC_MAYBE (NFC_Quick_Check=Maybe).</source>
          <target state="translated">派生プロパティNFC_MAYBE(NFC_Quick_Check=Maybe)のブール値を返します。</target>
        </trans-unit>
        <trans-unit id="8eddd31c0562defd83827f48a88a17884adf60ac" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFC_NO (NFC_Quick_Check=No).</source>
          <target state="translated">派生プロパティNFC_NO(NFC_Quick_Check=No)のブール値を返します。</target>
        </trans-unit>
        <trans-unit id="5a5415660523b78bb56fd5e9c17b5e348185ce86" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFD_NO (NFD_Quick_Check=No).</source>
          <target state="translated">派生プロパティ NFD_NO (NFD_Quick_Check=No)のブール値を返します。</target>
        </trans-unit>
        <trans-unit id="670fe547c9b7a29b855ab5f7d41534d43d1e9f4c" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKC_MAYBE (NFKC_Quick_Check=Maybe).</source>
          <target state="translated">派生プロパティNFKC_MAYBE(NFKC_Quick_Check=Maybe)のブール値を返します。</target>
        </trans-unit>
        <trans-unit id="904cbf02d71113df93de970071185a11138630e4" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKC_NO (NFKC_Quick_Check=No).</source>
          <target state="translated">派生プロパティNFKC_NO(NFKC_Quick_Check=No)のブール値を返します。</target>
        </trans-unit>
        <trans-unit id="829ea5ef8a5200c844ee7c02042a32bc63c04771" translate="yes" xml:space="preserve">
          <source>It returns a boolean of the derived property NFKD_NO (NFKD_Quick_Check=No).</source>
          <target state="translated">派生プロパティNFKD_NO(NFKD_Quick_Check=No)のブール値を返します。</target>
        </trans-unit>
        <trans-unit id="8784205d909df0b9a984780fc90733905a3103a1" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the character of the specified codepoint may be composed with the previous one in a certain composition (including Hangul Compositions, but excluding Composition Exclusions and Non-Starter Decompositions).</source>
          <target state="translated">これは、指定されたコードポイントの文字が、特定の構図(ハングル構図を含むが、構図除外と非スターター構図を除く)の中で前のものと一緒に構図されてもよいかどうかをブール値で返します。</target>
        </trans-unit>
        <trans-unit id="32fdbc7eddb18b1a419ce2d35092783f07d4af22" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point has Non-Starter Decomposition.</source>
          <target state="translated">コードポイントがNon-Starter Decompositionを持っているかどうかのブール値を返します。</target>
        </trans-unit>
        <trans-unit id="05cafc23e99e3bc76eb241d5b7b7627390e2da71" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point is a composition exclusion.</source>
          <target state="translated">コードポイントが合成除外であるかどうかをブール値で返します。</target>
        </trans-unit>
        <trans-unit id="53705043824b274a980c94b9c5b624aa7db18ac7" translate="yes" xml:space="preserve">
          <source>It returns a boolean whether the code point is a singleton</source>
          <target state="translated">コードポイントがシングルトンであるかどうかのブール値を返します。</target>
        </trans-unit>
        <trans-unit id="3bdd6ab415e1d7803474768a9f82c375da3c7e8f" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$Bzip2Error&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功すると &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; オブジェクトを返し、失敗するとundefを返します。変数 &lt;code&gt;$Bzip2Error&lt;/code&gt; には、失敗時のエラーメッセージが含まれます。</target>
        </trans-unit>
        <trans-unit id="7b202b09f5eedc56f3eae8328563e18bb8bb267b" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$DeflateError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功すると &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; オブジェクトを返し、失敗するとundefを返します。変数 &lt;code&gt;$DeflateError&lt;/code&gt; には、失敗時のエラーメッセージが含まれます。</target>
        </trans-unit>
        <trans-unit id="0d7bf22968af56755cc48cf3e5eb1866df93fb4a" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$GzipError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功すると &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; オブジェクトを返し、失敗するとundefを返します。変数 &lt;code&gt;$GzipError&lt;/code&gt; には、失敗時のエラーメッセージが含まれます。</target>
        </trans-unit>
        <trans-unit id="e02c10ad441b5cb12d98ff7ac04d2bec29b76002" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$RawDeflateError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功すると &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; オブジェクトを返し、失敗するとundefを返します。変数 &lt;code&gt;$RawDeflateError&lt;/code&gt; には、失敗時のエラーメッセージが含まれます。</target>
        </trans-unit>
        <trans-unit id="733e2aec8845350fd889ee56ce6b2b1905e8c50e" translate="yes" xml:space="preserve">
          <source>It returns an &lt;code&gt;IO::Compress::Zip&lt;/code&gt; object on success and undef on failure. The variable &lt;code&gt;$ZipError&lt;/code&gt; will contain an error message on failure.</source>
          <target state="translated">成功すると &lt;code&gt;IO::Compress::Zip&lt;/code&gt; オブジェクトを返し、失敗するとundefを返します。変数 &lt;code&gt;$ZipError&lt;/code&gt; には、失敗時のエラーメッセージが含まれます。</target>
        </trans-unit>
        <trans-unit id="55f5b32339878811a57c6c9adb8fddab3c155d6c" translate="yes" xml:space="preserve">
          <source>It returns an array of four or five scalar values: EXTRALIBS, BSLOADLIBS, LDLOADLIBS, LD_RUN_PATH, and, optionally, a reference to the array of the filenames of actual libraries. Some of these don't mean anything unless on Unix. See the details about those platform specifics below. The list of the filenames is returned only if $need_names argument is true.</source>
          <target state="translated">4つまたは5つのスカラー値の配列を返します。EXTRALIBS,BSLOADLIBS,LDLOADLIBS,LD_RUN_PATH,そしてオプションとして、実際のライブラリのファイル名の配列への参照を返します。これらの中には、Unix 上でなければ何の意味もないものもあります。これらのプラットフォームに関する詳細は以下を参照してください。ファイル名のリストは、 $need_names 引数が真の場合にのみ返されます。</target>
        </trans-unit>
        <trans-unit id="1b60723356123e31c4f819b7b57959bd345247e2" translate="yes" xml:space="preserve">
          <source>It returns falls if &lt;code&gt;PACKAGE&lt;/code&gt; has not been loaded yet and the location from where it is said to be loaded on success.</source>
          <target state="translated">&lt;code&gt;PACKAGE&lt;/code&gt; がまだロードされていない場合は、fallが返され、正常にロードされたと言われる場所が返されます。</target>
        </trans-unit>
        <trans-unit id="ab042aac65d23a49c795444acd76a148a334187c" translate="yes" xml:space="preserve">
          <source>It returns the FCC form (&quot;Fast C Contiguous&quot;; cf. UTN #5).</source>
          <target state="translated">FCCフォーム(「Fast C Contiguous」;cf.UTN #5)を返す。</target>
        </trans-unit>
        <trans-unit id="a80e6baf3c3b2c9535a05b4bf410d7b9c5dde971" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form C (formed by canonical decomposition followed by canonical composition).</source>
          <target state="translated">正規化形式C(正準分解に続いて正準合成によって形成される)を返します。</target>
        </trans-unit>
        <trans-unit id="a2c5e52810047ee1962e46371ac68fc8dc9054e8" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form D (formed by canonical decomposition).</source>
          <target state="translated">正規化形式D(正準分解によって形成された)を返します。</target>
        </trans-unit>
        <trans-unit id="1383c6449aad07f7997fc3ec42b0ae3c98ca4a0b" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form KC (formed by compatibility decomposition followed by &lt;b&gt;canonical&lt;/b&gt; composition).</source>
          <target state="translated">正規化形式KCを返します（互換性分解とそれに続く&lt;b&gt;正規&lt;/b&gt;構成によって形成されます）。</target>
        </trans-unit>
        <trans-unit id="1d675fdcf5ef1f2056866497e81d752934809791" translate="yes" xml:space="preserve">
          <source>It returns the Normalization Form KD (formed by compatibility decomposition).</source>
          <target state="translated">正規化フォームKD(互換性分解によって形成された)を返します。</target>
        </trans-unit>
        <trans-unit id="4b300118aa94b87649f21e9834526f64818158d8" translate="yes" xml:space="preserve">
          <source>It returns the combining class (as an integer) of the character.</source>
          <target state="translated">文字の結合クラス(整数)を返します。</target>
        </trans-unit>
        <trans-unit id="eb22d3dace2d05fa601426312363eea62fa0226b" translate="yes" xml:space="preserve">
          <source>It returns the concatenation of the decomposition of each character in the string.</source>
          <target state="translated">文字列の各文字を分解して連結したものを返します。</target>
        </trans-unit>
        <trans-unit id="8a852534b28496d947f4c8e100a132748793361d" translate="yes" xml:space="preserve">
          <source>It returns the normalization form of &lt;code&gt;$form_name&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$form_name&lt;/code&gt; 正規化形式を返します。</target>
        </trans-unit>
        <trans-unit id="bf3cd095961560034a7b6b2b8569541880d86696" translate="yes" xml:space="preserve">
          <source>It returns the normalization form of &lt;code&gt;$form_name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$form_name&lt;/code&gt; 正規化形式を返します。</target>
        </trans-unit>
        <trans-unit id="b49fbb316b9278a17d532265fe4cd4e754492934" translate="yes" xml:space="preserve">
          <source>It returns the remainder &lt;code&gt;$r = $x - $n*$y&lt;/code&gt; , where &lt;code&gt;$n = trunc($x/$y)&lt;/code&gt; . The &lt;code&gt;$r&lt;/code&gt; has the same sign as &lt;code&gt;$x&lt;/code&gt; and magnitude (absolute value) less than the magnitude of &lt;code&gt;$y&lt;/code&gt; .</source>
          <target state="translated">残りの &lt;code&gt;$r = $x - $n*$y&lt;/code&gt; 返します。ここで、 &lt;code&gt;$n = trunc($x/$y)&lt;/code&gt; です。 &lt;code&gt;$r&lt;/code&gt; 同じ符号有し &lt;code&gt;$x&lt;/code&gt; 未満の大きさ以上と大きさ（絶対値） &lt;code&gt;$y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b96df5a323ccde59c4604283479ada0f880ece8b" translate="yes" xml:space="preserve">
          <source>It returns the remainder &lt;code&gt;$r = $x - $n*$y&lt;/code&gt;, where &lt;code&gt;$n = trunc($x/$y)&lt;/code&gt;. The &lt;code&gt;$r&lt;/code&gt; has the same sign as &lt;code&gt;$x&lt;/code&gt; and magnitude (absolute value) less than the magnitude of &lt;code&gt;$y&lt;/code&gt;.</source>
          <target state="translated">剰余 &lt;code&gt;$r = $x - $n*$y&lt;/code&gt; 返します。ここで、 &lt;code&gt;$n = trunc($x/$y)&lt;/code&gt; です。 &lt;code&gt;$r&lt;/code&gt; 同じ符号有し &lt;code&gt;$x&lt;/code&gt; 未満の大きさ以上と大きさ（絶対値） &lt;code&gt;$y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="837e320b920fba38b4782fb970e5ba4d1738747b" translate="yes" xml:space="preserve">
          <source>It returns the result of canonical composition without applying any decomposition.</source>
          <target state="translated">分解を適用せずに正準合成の結果を返します。</target>
        </trans-unit>
        <trans-unit id="97c8ed595d7942de577ac5b60184bc3e70b57d00" translate="yes" xml:space="preserve">
          <source>It returns the result of reordering the combining characters according to Canonical Ordering Behavior.</source>
          <target state="translated">正準順序動作に従って結合文字を並べ替えた結果を返します。</target>
        </trans-unit>
        <trans-unit id="0c7818f52644428114d7169367d50f2b1f7b0307" translate="yes" xml:space="preserve">
          <source>It returns the same values as run_tests, so you can further examine the test results if you need to.</source>
          <target state="translated">run_testsと同じ値を返すので、必要に応じてテスト結果をさらに調べることができます。</target>
        </trans-unit>
        <trans-unit id="30e13862ba07278e0519e9e4b0230517dc0328cb" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt; ) if &lt;code&gt;YES&lt;/code&gt; ; false (&lt;code&gt;empty string&lt;/code&gt; ) if &lt;code&gt;NO&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;YES&lt;/code&gt; の場合はtrue（ &lt;code&gt;1&lt;/code&gt; ）を返します。 &lt;code&gt;NO&lt;/code&gt; の場合はfalse（ &lt;code&gt;empty string&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b1aae34c500721c408b0788928293058d1fef3fa" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt; ) if &lt;code&gt;YES&lt;/code&gt; ; false (&lt;code&gt;empty string&lt;/code&gt; ) if &lt;code&gt;NO&lt;/code&gt; ; &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;MAYBE&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;YES&lt;/code&gt; の場合はtrue（ &lt;code&gt;1&lt;/code&gt; ）を返します。偽（ &lt;code&gt;empty string&lt;/code&gt; ）であれば &lt;code&gt;NO&lt;/code&gt; 。 &lt;code&gt;MAYBE&lt;/code&gt; の場合は &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e07cc039b9bc283952fe2e0a04d4a341d590f3e7" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt;) if &lt;code&gt;YES&lt;/code&gt;; false (&lt;code&gt;empty string&lt;/code&gt;) if &lt;code&gt;NO&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;YES&lt;/code&gt; の場合はtrue（ &lt;code&gt;1&lt;/code&gt; ）を返します。 &lt;code&gt;NO&lt;/code&gt; の場合はfalse（ &lt;code&gt;empty string&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e00917cf3a6843e18b27b643db79b6a4b69a6e3c" translate="yes" xml:space="preserve">
          <source>It returns true (&lt;code&gt;1&lt;/code&gt;) if &lt;code&gt;YES&lt;/code&gt;; false (&lt;code&gt;empty string&lt;/code&gt;) if &lt;code&gt;NO&lt;/code&gt;; &lt;code&gt;undef&lt;/code&gt; if &lt;code&gt;MAYBE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;YES&lt;/code&gt; の場合はtrue（ &lt;code&gt;1&lt;/code&gt; ）を返します。false（ &lt;code&gt;empty string&lt;/code&gt; ） &lt;code&gt;NO&lt;/code&gt; の場合; &lt;code&gt;MAYBE&lt;/code&gt; の場合は &lt;code&gt;undef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a729a5529269a29252f3c2bf2eddc2d7ae807d5" translate="yes" xml:space="preserve">
          <source>It returns true if everything was ok. Otherwise it will &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; with one of the messages in the DIAGNOSTICS section.</source>
          <target state="translated">すべて問題なければ、trueを返します。それ以外の場合は、DIAGNOSTICSセクションのメッセージの1つで &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; します。</target>
        </trans-unit>
        <trans-unit id="7671ee7cfbfe57f504b6685d32d40a2c22391d50" translate="yes" xml:space="preserve">
          <source>It returns true if everything was ok. Otherwise it will &lt;code&gt;die()&lt;/code&gt; with one of the messages in the DIAGNOSTICS section.</source>
          <target state="translated">すべて問題がなかった場合はtrueを返します。それ以外の場合は、DIAGNOSTICSセクションのメッセージの1つで &lt;code&gt;die()&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="714b64110a6e486db425b221e1f3c962f9afdc59" translate="yes" xml:space="preserve">
          <source>It returns true if the key matched the criteria, or false otherwise.</source>
          <target state="translated">キーが基準にマッチした場合は真、そうでない場合は偽を返します。</target>
        </trans-unit>
        <trans-unit id="cdfcc78500cdaa84a66edd629ca6a9d6469e030b" translate="yes" xml:space="preserve">
          <source>It returns two strings: the first one, &lt;code&gt;$processed&lt;/code&gt; , is a part before the last starter, and the second one, &lt;code&gt;$unprocessed&lt;/code&gt; is another part after the first part. A starter is a character having a combining class of zero (see UAX #15).</source>
          <target state="translated">2つの文字列を返します。最初の文字列 &lt;code&gt;$processed&lt;/code&gt; は最後のスターターの前の部分で、2番目の文字列 &lt;code&gt;$unprocessed&lt;/code&gt; は最初の部分の後の別の部分です。スターターは、結合クラスがゼロの文字です（UAX＃15を参照）。</target>
        </trans-unit>
        <trans-unit id="bcda37fdc9f0662d168c30c5cdca4733a8dcb549" translate="yes" xml:space="preserve">
          <source>It returns two strings: the first one, &lt;code&gt;$processed&lt;/code&gt;, is a part before the last starter, and the second one, &lt;code&gt;$unprocessed&lt;/code&gt; is another part after the first part. A starter is a character having a combining class of zero (see UAX #15).</source>
          <target state="translated">2つの文字列を返します。最初の &lt;code&gt;$processed&lt;/code&gt; は最後のスターターの前の部分であり、2番目の &lt;code&gt;$unprocessed&lt;/code&gt; は最初の部分の後の別の部分です。スターターは、結合クラスがゼロのキャラクターです（UAX＃15を参照）。</target>
        </trans-unit>
        <trans-unit id="e7d95a08ad814a7f6c58669c1b1316d305c90d5a" translate="yes" xml:space="preserve">
          <source>It sets up a class &lt;code&gt;Name&lt;/code&gt; that is a mirror of one of the implementation classes &lt;code&gt;Name_hash&lt;/code&gt; , &lt;code&gt;Name_id&lt;/code&gt; , ..., &lt;code&gt;Name_fieldhash&lt;/code&gt; . That determines which implementation is run.</source>
          <target state="translated">これは、実装クラス &lt;code&gt;Name_hash&lt;/code&gt; 、 &lt;code&gt;Name_id&lt;/code&gt; 、...、 &lt;code&gt;Name_fieldhash&lt;/code&gt; のいずれかのミラーであるクラス &lt;code&gt;Name&lt;/code&gt; を設定します。これにより、実行される実装が決まります。</target>
        </trans-unit>
        <trans-unit id="9e5fad0504d022f42c88d249188952052fecb50c" translate="yes" xml:space="preserve">
          <source>It sets up a class &lt;code&gt;Name&lt;/code&gt; that is a mirror of one of the implementation classes &lt;code&gt;Name_hash&lt;/code&gt;, &lt;code&gt;Name_id&lt;/code&gt;, ..., &lt;code&gt;Name_fieldhash&lt;/code&gt;. That determines which implementation is run.</source>
          <target state="translated">実装クラス &lt;code&gt;Name_hash&lt;/code&gt; 、 &lt;code&gt;Name_id&lt;/code&gt; 、...、 &lt;code&gt;Name_fieldhash&lt;/code&gt; のいずれかのミラーであるクラス &lt;code&gt;Name&lt;/code&gt; を設定します。これにより、実行する実装が決まります。</target>
        </trans-unit>
        <trans-unit id="cb3f907f4536c2412455577e73bc09c598212b95" translate="yes" xml:space="preserve">
          <source>It should be noted that because of the double indirection in a &lt;code&gt;PerlIO *&lt;/code&gt; , a &lt;code&gt;&amp;amp;(perlio-&amp;gt;next)&lt;/code&gt; &quot;is&quot; a &lt;code&gt;PerlIO *&lt;/code&gt; , and so to some degree at least one layer can use the &quot;standard&quot; API on the next layer down.</source>
          <target state="translated">&lt;code&gt;PerlIO *&lt;/code&gt; の二重間接のため、 &lt;code&gt;&amp;amp;(perlio-&amp;gt;next)&lt;/code&gt; は &lt;code&gt;PerlIO *&lt;/code&gt; であり、少なくとも1つの層が次の層の「標準」APIをある程度使用できることに注意してください。ダウン。</target>
        </trans-unit>
        <trans-unit id="c7a2a8bb586f925da0807a643800b85b4622cd20" translate="yes" xml:space="preserve">
          <source>It should be noted that because of the double indirection in a &lt;code&gt;PerlIO *&lt;/code&gt;, a &lt;code&gt;&amp;amp;(perlio-&amp;gt;next)&lt;/code&gt; &quot;is&quot; a &lt;code&gt;PerlIO *&lt;/code&gt;, and so to some degree at least one layer can use the &quot;standard&quot; API on the next layer down.</source>
          <target state="translated">&lt;code&gt;PerlIO *&lt;/code&gt; の二重間接参照のため、 &lt;code&gt;&amp;amp;(perlio-&amp;gt;next)&lt;/code&gt; は &lt;code&gt;PerlIO *&lt;/code&gt; であり、ある程度、少なくとも1つのレイヤーが次のレイヤーで「標準」APIを使用できることに注意してください。ダウン。</target>
        </trans-unit>
        <trans-unit id="b14a8d613d8259f6f9199d94a881c7c7dcdcf9aa" translate="yes" xml:space="preserve">
          <source>It should be noted that the</source>
          <target state="translated">には注意が必要です。</target>
        </trans-unit>
        <trans-unit id="a59ebc15941a0d3262901c5719fbfc123fcebf0b" translate="yes" xml:space="preserve">
          <source>It splits the task of generating the Makefile into several subroutines that can be individually overridden. Each subroutine returns the text it wishes to have written to the Makefile.</source>
          <target state="translated">Makefileを生成するタスクを、個別にオーバーライドできるいくつかのサブルーチンに分割します。各サブルーチンは、Makefileに書きたいテキストを返します。</target>
        </trans-unit>
        <trans-unit id="82c9f4b13f690f80567f90ba2a27e3429f909ad9" translate="yes" xml:space="preserve">
          <source>It starts like a perl module with a package declaration and a $VERSION variable. After that the pod section looks like any other pod with the only difference being that</source>
          <target state="translated">パッケージ宣言と $VERSION 変数を持つ perl モジュールのように始まります。その後、ポッドセクションは他のポッドと同じように見えますが、唯一の違いは</target>
        </trans-unit>
        <trans-unit id="20eae6f6b825ab7ac7ea22eebe86fa7977d3df1a" translate="yes" xml:space="preserve">
          <source>It supports the following options, which are explained in &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt;: alt, indent, loose, quotes, sentence, width</source>
          <target state="translated">&lt;a href=&quot;../text&quot;&gt;Pod :: Textで&lt;/a&gt;説明されている次のオプションをサポートしています：alt、indent、loose、quotes、sentence、width</target>
        </trans-unit>
        <trans-unit id="510b7b9b3f742ecce372251df0c084238337e534" translate="yes" xml:space="preserve">
          <source>It supports the following options, which are explained in &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt;: alt, indent, loose, quotes, sentence, width</source>
          <target state="translated">&lt;a href=&quot;Pod::Text&quot;&gt;Pod :: Textで&lt;/a&gt;説明されている次のオプションをサポートしています：alt、インデント、ルーズ、引用符、文、幅</target>
        </trans-unit>
        <trans-unit id="41aba7727d2b065747551c63f609a3ed9ed9ee45" translate="yes" xml:space="preserve">
          <source>It suppresses duplicates in the column &lt;code&gt;in CPAN file&lt;/code&gt; such that distributions with many upgradeable modules are listed only once.</source>
          <target state="translated">&lt;code&gt;in CPAN file&lt;/code&gt; の列の重複を抑制し、アップグレード可能なモジュールが多数あるディストリビューションが1回だけリストされるようにします。</target>
        </trans-unit>
        <trans-unit id="408685ef311dbc3599ddc558bce5925c12aacf23" translate="yes" xml:space="preserve">
          <source>It takes a Win32 native file handle and returns the size in bytes. Since the size can be a 64 bit value, on non 64 bit integer Perls the value returned will be an object of type &lt;code&gt;Math::BigInt&lt;/code&gt;.</source>
          <target state="translated">Win32ネイティブファイルハンドルを取り、サイズをバイト単位で返します。サイズは64ビット値にすることができるため、64ビット整数以外の &lt;code&gt;Math::BigInt&lt;/code&gt; 、返される値はMath :: BigInt型のオブジェクトになります。</target>
        </trans-unit>
        <trans-unit id="65a26945a658df9dae641582923dd3754dc6d274" translate="yes" xml:space="preserve">
          <source>It takes a hash reference as an argument with two optional keys:</source>
          <target state="translated">これはハッシュ参照を引数に取り、2つのオプションのキーを指定します。</target>
        </trans-unit>
        <trans-unit id="b5a427be1727dabad24c941b3ce2ddc132315b17" translate="yes" xml:space="preserve">
          <source>It takes an optional hashref of options. Valid options include:</source>
          <target state="translated">オプションのハッシュリフを取ります。有効なオプションは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="bc0a17fd215b480661caff5f818c6d1a010f9c4c" translate="yes" xml:space="preserve">
          <source>It takes the same options as &lt;code&gt;new()&lt;/code&gt; but &lt;code&gt;lazy_validation&lt;/code&gt; defaults to true.</source>
          <target state="translated">&lt;code&gt;new()&lt;/code&gt; と同じオプションを取りますが、 &lt;code&gt;lazy_validation&lt;/code&gt; のデフォルトはtrueです。</target>
        </trans-unit>
        <trans-unit id="8e1dcd4bfabeba9ef57034858eb07de6c007a236" translate="yes" xml:space="preserve">
          <source>It takes three arguments:</source>
          <target state="translated">3つの引数が必要です。</target>
        </trans-unit>
        <trans-unit id="a46a1b8abd0b80e91377ad517ddde11f2ad6f67d" translate="yes" xml:space="preserve">
          <source>It tells where the old configuration file was found (if found).</source>
          <target state="translated">古い設定ファイルが見つかった場所を教えてくれます(見つかった場合)。</target>
        </trans-unit>
        <trans-unit id="316a78b3112e7d60b8f4b8e53c96f0951d499e19" translate="yes" xml:space="preserve">
          <source>It turns out that you can actually do this also:</source>
          <target state="translated">実際にこれもできることが判明しました。</target>
        </trans-unit>
        <trans-unit id="674b7a92bd3974a32a6e0bc4ddce519662bb5c8a" translate="yes" xml:space="preserve">
          <source>It used to be legal to use &lt;code&gt;open()&lt;/code&gt; to associate both a filehandle and a dirhandle to the same symbol (glob or scalar). This idiom is likely to be confusing, and it was deprecated in Perl 5.10.</source>
          <target state="translated">&lt;code&gt;open()&lt;/code&gt; を使用して、ファイルハンドルとdirhandleの両方を同じシンボル（グロブまたはスカラー）に関連付けることは、以前は合法でした。このイディオムは混乱を招く可能性があり、Perl5.10では非推奨になりました。</target>
        </trans-unit>
        <trans-unit id="c73ad695b4941117c2fa5c1a0fa146666ac448c3" translate="yes" xml:space="preserve">
          <source>It used to be possible to use &lt;code&gt;tie&lt;/code&gt;, &lt;code&gt;tied&lt;/code&gt; or &lt;code&gt;untie&lt;/code&gt; on a scalar while the scalar holds a typeglob. This caused its filehandle to be tied. It left no way to tie the scalar itself when it held a typeglob, and no way to untie a scalar that had had a typeglob assigned to it.</source>
          <target state="translated">スカラーがtypeglobを保持している間、スカラーで &lt;code&gt;tie&lt;/code&gt; 、 &lt;code&gt;tied&lt;/code&gt; 、 &lt;code&gt;untie&lt;/code&gt; を使用することが可能でした。これにより、ファイルハンドルが拘束されました。タイプグロブを保持しているときにスカラー自体を結合する方法も、タイプグロブが割り当てられているスカラーを分離する方法もありませんでした。</target>
        </trans-unit>
        <trans-unit id="9dce3c39f57e7aba5158e57e9f8e31a1b80c94a8" translate="yes" xml:space="preserve">
          <source>It used to hold the</source>
          <target state="translated">を保持するために使用されていました。</target>
        </trans-unit>
        <trans-unit id="f59c80ea628e681a66374b04e2b703dd5af8c0f4" translate="yes" xml:space="preserve">
          <source>It uses the &lt;code&gt;getaddrinfo(3)&lt;/code&gt; function to convert hostnames and service names or port numbers into sets of possible addresses to connect to or listen on. This allows it to work for IPv6 where the system supports it, while still falling back to IPv4-only on systems which don't.</source>
          <target state="translated">これは、使用して &lt;code&gt;getaddrinfo(3)&lt;/code&gt; に接続するかに聞くことが可能なアドレスのセットに変換するホスト名およびサービス名やポート番号に機能を。これにより、システムがサポートしているIPv6で機能し、サポートしていないシステムでのみIPv4にフォールバックできます。</target>
        </trans-unit>
        <trans-unit id="143c187acc40c6e4dc672359c95beead999d8959" translate="yes" xml:space="preserve">
          <source>It uses these values to set the extended timestamp field (ID is &quot;UT&quot;) in the local zip header using the three values, $atime, $mtime, $ctime. In addition it sets the extended timestamp field in the central zip header using &lt;code&gt;$mtime&lt;/code&gt; .</source>
          <target state="translated">これらの値を使用して、$ atime、$ mtime、$ ctimeの3つの値を使用してローカルzipヘッダーに拡張タイムスタンプフィールド（IDは &quot;UT&quot;）を設定します。さらに、 &lt;code&gt;$mtime&lt;/code&gt; を使用して中央のzipヘッダーに拡張タイムスタンプフィールドを設定します。</target>
        </trans-unit>
        <trans-unit id="79a1b16fce6a4d25801f9ce9e038622522aac3da" translate="yes" xml:space="preserve">
          <source>It uses these values to set the extended timestamp field (ID is &quot;UT&quot;) in the local zip header using the three values, $atime, $mtime, $ctime. In addition it sets the extended timestamp field in the central zip header using &lt;code&gt;$mtime&lt;/code&gt;.</source>
          <target state="translated">これらの値を使用して、$ atime、$ mtime、$ ctimeの3つの値を使用して、ローカルzipヘッダーに拡張タイムスタンプフィールド（IDは「UT」）を設定します。さらに、 &lt;code&gt;$mtime&lt;/code&gt; を使用して中央のzipヘッダーに拡張タイムスタンプフィールドを設定します。</target>
        </trans-unit>
        <trans-unit id="18f46edc5cb632e7fccbb0705e4feec5f3263394" translate="yes" xml:space="preserve">
          <source>It was allowed to use a list of variables in a format, without separating them with commas. This usage has been deprecated for a long time, and as of Perl 5.28, this throws a fatal error.</source>
          <target state="translated">変数のリストをカンマで区切らずにフォーマットで使用することが許可されていました。この使用法は長い間非推奨とされており、Perl 5.28 では致命的なエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="f6d084cee81998d6ff3982adc3ae633d6de17437" translate="yes" xml:space="preserve">
          <source>It was easy to write by having it call the Unix cat(1) command, but it would probably be more portable to open the file manually (and somewhat more efficient). Of course, because dot files are a Unixy concept, we're not that concerned.</source>
          <target state="translated">Unix の cat(1)コマンドを呼ばせることで簡単に書けましたが、手動でファイルを開いた方が移植性が高いでしょう (多少は効率的です)。もちろん、ドットファイルはUnixyの概念なので、そこまで気にすることはありません。</target>
        </trans-unit>
        <trans-unit id="c142dca333e2894efe138704aae3906df8914b33" translate="yes" xml:space="preserve">
          <source>It was extracted to dual-life on CPAN at version 1.95 by Paul Evans &amp;lt;leonerd@leonerd.org.uk&amp;gt;</source>
          <target state="translated">これは、Paul Evans &amp;lt;leonerd@leonerd.org.uk&amp;gt;によってバージョン1.95でCPANのデュアルライフに抽出されました</target>
        </trans-unit>
        <trans-unit id="166bbe1785a329a167c16e63945354e47d32b2c0" translate="yes" xml:space="preserve">
          <source>It was introduced to avoid the potential problems with the other form, available in all Perls. That form consists of a backslash followed by three octal digits. One problem with this form is that it can look exactly like an old-style backreference (see &lt;a href=&quot;#Disambiguation-rules-between-old-style-octal-escapes-and-backreferences&quot;&gt;&quot;Disambiguation rules between old-style octal escapes and backreferences&quot;&lt;/a&gt; below.) You can avoid this by making the first of the three digits always a zero, but that makes \077 the largest code point specifiable.</source>
          <target state="translated">これは、すべてのPerlで利用可能な他のフォームの潜在的な問題を回避するために導入されました。この形式は、円記号とそれに続く3桁の8進数で構成されます。このフォームの問題の1つは、古いスタイルの後方参照とまったく同じように見えることです（以下の&lt;a href=&quot;#Disambiguation-rules-between-old-style-octal-escapes-and-backreferences&quot;&gt;「古いスタイルの8進数エスケープと後方&lt;/a&gt;参照の間の明確化ルール」を参照）。3桁の最初の数字を常にゼロにすることでこれを回避できます。しかし、それは\ 077を指定可能な最大のコードポイントにします。</target>
        </trans-unit>
        <trans-unit id="d62846658b7b31f9fc5efa8815011f4172e2d224" translate="yes" xml:space="preserve">
          <source>It was introduced to avoid the potential problems with the other form, available in all Perls. That form consists of a backslash followed by three octal digits. One problem with this form is that it can look exactly like an old-style backreference (see &lt;a href=&quot;#Disambiguation-rules-between-old-style-octal-escapes-and-backreferences&quot;&gt;Disambiguation rules between old-style octal escapes and backreferences&lt;/a&gt; below.) You can avoid this by making the first of the three digits always a zero, but that makes \077 the largest code point specifiable.</source>
          <target state="translated">これは、すべてのPerlで使用可能な他の形式の潜在的な問題を回避するために導入されました。その形式は、バックスラッシュとそれに続く3つの8進数で構成されます。このフォームの問題の1つは、古いスタイルの後方参照とまったく同じように見えることです（以下の&lt;a href=&quot;#Disambiguation-rules-between-old-style-octal-escapes-and-backreferences&quot;&gt;古いスタイルの8進エスケープと後方&lt;/a&gt;参照の間の明確化ルールを参照してください）。3桁の最初の桁を常にゼロにすることでこれを回避できますが、 \ 077を指定可能な最大のコードポイントにします。</target>
        </trans-unit>
        <trans-unit id="d3ee2a6714e3e6adf556faba68422a058c942c27" translate="yes" xml:space="preserve">
          <source>It will also use a default typemap installed as &lt;code&gt;ExtUtils::typemap&lt;/code&gt; .</source>
          <target state="translated">また、 &lt;code&gt;ExtUtils::typemap&lt;/code&gt; としてインストールされているデフォルトのタイプマップも使用します。</target>
        </trans-unit>
        <trans-unit id="0759e45d98bb4647a58253ee97ba7b77b47a644c" translate="yes" xml:space="preserve">
          <source>It will also use a default typemap installed as &lt;code&gt;ExtUtils::typemap&lt;/code&gt;.</source>
          <target state="translated">また、 &lt;code&gt;ExtUtils::typemap&lt;/code&gt; としてインストールされたデフォルトのタイプマップを使用します。</target>
        </trans-unit>
        <trans-unit id="e39ceb1fd2f53bed50ffdadfd8219def2a0114b8" translate="yes" xml:space="preserve">
          <source>It will also use the &lt;a href=&quot;Win32::Locale&quot;&gt;Win32::Locale&lt;/a&gt; module, if it's installed and IGNORE_WIN32_LOCALE is not set to a true value in the environment.</source>
          <target state="translated">また、&lt;a href=&quot;Win32::Locale&quot;&gt;Win32 :: Locale&lt;/a&gt;モジュールがインストールされていて、IGNORE_WIN32_LOCALEが環境内で真の値に設定されていない場合は、このモジュールを使用します。</target>
        </trans-unit>
        <trans-unit id="49ab6ec702b4749c563dad7126fbebc3ad5a9050" translate="yes" xml:space="preserve">
          <source>It will also use the &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Locale&quot;&gt;Win32::Locale&lt;/a&gt; module, if it's installed.</source>
          <target state="translated">インストールされている場合は、&lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Locale&quot;&gt;Win32 :: Locale&lt;/a&gt;モジュールも使用します。</target>
        </trans-unit>
        <trans-unit id="eebcb44cc4b0d0bb319df0e9deccc15987032c7b" translate="yes" xml:space="preserve">
          <source>It will always have at least one parameter automatically passed by Perl - this corresponds to the name of the package. In the example above it will be &lt;code&gt;&quot;MyFilter&quot;&lt;/code&gt; .</source>
          <target state="translated">Perlによって自動的に渡される少なくとも1つのパラメーターが常にあります-これはパッケージの名前に対応します。上記の例では &lt;code&gt;&quot;MyFilter&quot;&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="a5ac1faf8f9d59ddb0b6351807f16102144c68a8" translate="yes" xml:space="preserve">
          <source>It will always have at least one parameter automatically passed by Perl - this corresponds to the name of the package. In the example above it will be &lt;code&gt;&quot;MyFilter&quot;&lt;/code&gt;.</source>
          <target state="translated">Perlによって自動的に渡される少なくとも1つのパラメーターが常にあります-これはパッケージの名前に対応します。上記の例では、 &lt;code&gt;&quot;MyFilter&quot;&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="9b05bb9d8d6cf0031940a72fb71a5bc98935f18a" translate="yes" xml:space="preserve">
          <source>It will default to the global setting of &lt;code&gt;$IPC::Cmd::VERBOSE&lt;/code&gt; , which by default is 0.</source>
          <target state="translated">デフォルトは &lt;code&gt;$IPC::Cmd::VERBOSE&lt;/code&gt; のグローバル設定で、デフォルトは0です。</target>
        </trans-unit>
        <trans-unit id="f9ce735c72f68600f9b73a9ad2fbc8f2efff3f41" translate="yes" xml:space="preserve">
          <source>It will default to the global setting of &lt;code&gt;$IPC::Cmd::VERBOSE&lt;/code&gt;, which by default is 0.</source>
          <target state="translated">デフォルトでは、グローバル設定の &lt;code&gt;$IPC::Cmd::VERBOSE&lt;/code&gt; になります。これは、デフォルトでは0です。</target>
        </trans-unit>
        <trans-unit id="5c5106e7131ba864011023c16e2d910c408243d8" translate="yes" xml:space="preserve">
          <source>It will exit with 255.</source>
          <target state="translated">255で終了します。</target>
        </trans-unit>
        <trans-unit id="cd3560715bcdcdb5a5493a3c2aa8a0baf196fb75" translate="yes" xml:space="preserve">
          <source>It will look in the environment for a</source>
          <target state="translated">のための環境を探します。</target>
        </trans-unit>
        <trans-unit id="271dd95369c9033872c86c2ed2d28ba5b5a90105" translate="yes" xml:space="preserve">
          <source>It will not attempt to read beyond &lt;code&gt;e - 1&lt;/code&gt;, provided that the constraint &lt;code&gt;s &amp;lt; e&lt;/code&gt; is true (this is asserted for in &lt;code&gt;-DDEBUGGING&lt;/code&gt; builds). If the UTF-8 for the input character is malformed in some way, the program may croak, or the function may return the REPLACEMENT CHARACTER, at the discretion of the implementation, and subject to change in future releases.</source>
          <target state="translated">制約 &lt;code&gt;s &amp;lt; e&lt;/code&gt; が真である場合（これは &lt;code&gt;-DDEBUGGING&lt;/code&gt; ビルドでアサートされます）、 &lt;code&gt;e - 1&lt;/code&gt; を超えて読み取ろうとはしません。入力文字のUTF-8が何らかの形で不正な場合、実装の裁量でプログラムが鳴ったり、関数がREPLACEMENT CHARACTERを返したりする可能性があり、将来のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="11ba08d3329959d8ccf0a41d4bc0caadee83aee8" translate="yes" xml:space="preserve">
          <source>It will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to the &lt;b&gt;same&lt;/b&gt; object and stores it in $y. Thus anything that modifies $x (except overloaded operators) will modify $y, and vice versa. Or in other words, &lt;code&gt;=&lt;/code&gt; is only safe if you modify your BigInts only via overloaded math. As soon as you use a method call it breaks:</source>
          <target state="translated">$ xのコピーを作成するなど、あなたが思うことはしません。代わりに、&lt;b&gt;同じ&lt;/b&gt;オブジェクトへの2番目の参照を作成し、それを$ yに格納します。したがって、$ xを変更するもの（オーバーロードされた演算子を除く）は$ yを変更し、その逆も同様です。または、言い換えると、 &lt;code&gt;=&lt;/code&gt; は、オーバーロードされた数学によってのみBigIntsを変更する場合にのみ安全です。メソッド呼び出しを使用するとすぐに壊れます：</target>
        </trans-unit>
        <trans-unit id="3da306523999d7f8b6c9832cd1c2497b109726eb" translate="yes" xml:space="preserve">
          <source>It will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to the &lt;b&gt;same&lt;/b&gt; object and stores it in $y. Thus anything that modifies $x will modify $y (except overloaded math operators), and vice versa. See &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; for details and how to avoid that.</source>
          <target state="translated">$ xのコピーを作成するなど、あなたが思うことはしません。代わりに、&lt;b&gt;同じ&lt;/b&gt;オブジェクトへの2番目の参照を作成し、それを$ yに格納します。したがって、$ xを変更するものはすべて、$ yを変更します（オーバーロードされた数学演算子を除く）。その逆も同様です。参照してください&lt;a href=&quot;Math::BigInt&quot;&gt;数学:: BigIntの&lt;/a&gt;詳細については、どのようにそれを回避します。</target>
        </trans-unit>
        <trans-unit id="4ef09ffb235f52f01cd3d25c0c384cab0806a14c" translate="yes" xml:space="preserve">
          <source>It will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to the &lt;b&gt;same&lt;/b&gt; object and stores it in $y. Thus anything that modifies $x will modify $y (except overloaded math operators), and vice versa. See &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; for details and how to avoid that.</source>
          <target state="translated">$ xのコピーを作成するなど、あなたが思うことはしません。代わりに、&lt;b&gt;同じ&lt;/b&gt;オブジェクトへの2番目の参照を作成し、それを$ yに格納します。したがって、$ xを変更するものはすべて$ yを変更します（オーバーロードされた数学演算子を除く）。逆も同様です。参照してください&lt;a href=&quot;bigint&quot;&gt;数学:: BigIntの&lt;/a&gt;詳細については、どのようにそれを回避します。</target>
        </trans-unit>
        <trans-unit id="dd48a6ec2ae8cb512d05f750d53684c09ff6166d" translate="yes" xml:space="preserve">
          <source>It will print 'A' and then terminate, as it considers the match to be zero-width, and thus will not match at the same position twice in a row.</source>
          <target state="translated">A' を表示して終了しますが、これはマッチがゼロ幅であることを考慮しているため、同じ位置で2回連続してマッチすることはありません。</target>
        </trans-unit>
        <trans-unit id="478635e0153852c95d172e95b14a9c73a7376ef9" translate="yes" xml:space="preserve">
          <source>It will produce output like this:</source>
          <target state="translated">こんな感じで出力されます。</target>
        </trans-unit>
        <trans-unit id="033bdc255180f8b012ecc3dd8743f6cfc3998050" translate="yes" xml:space="preserve">
          <source>It will return undef if it was not able to find where the module was installed, or a hash reference with the following keys if it was able to find the file:</source>
          <target state="translated">モジュールがインストールされている場所が見つからなかった場合は undef を、ファイルを見つけることができた場合は以下のキーを持つハッシュ参照を返します。</target>
        </trans-unit>
        <trans-unit id="8fd1f4b13738ec21f8b65433f2c797f00d69b112" translate="yes" xml:space="preserve">
          <source>It won't work across a sequence of &lt;code&gt;store&lt;/code&gt; and &lt;code&gt;retrieve&lt;/code&gt; operations, however, because the addresses in the retrieved objects, which are part of the stringified references, will probably differ from the original addresses. The topology of your structure is preserved, but not hidden semantics like those.</source>
          <target state="translated">ただし、文字列化された参照の一部である取得されたオブジェクトのアドレスは、おそらく元のアドレスとは異なるため、一連の &lt;code&gt;store&lt;/code&gt; および &lt;code&gt;retrieve&lt;/code&gt; 操作では機能しません。構造のトポロジは保持されますが、そのような隠されたセマンティクスは保持されません。</target>
        </trans-unit>
        <trans-unit id="d829aa608b7d822354368e8bc717a7f78948e864" translate="yes" xml:space="preserve">
          <source>It works on references, too:</source>
          <target state="translated">リファレンスでも動作します。</target>
        </trans-unit>
        <trans-unit id="063657847573da8f9a48b2f56cfac7e5ef0c0bcc" translate="yes" xml:space="preserve">
          <source>It works this way as of Perl 5.18. Historically, it was inconsistent, and you would have to write</source>
          <target state="translated">Perl 5.18ではこのように動作します。歴史的にこれは矛盾していたので</target>
        </trans-unit>
        <trans-unit id="4c5e6eff5a06238d171586dbb35b0a88b0b974e6" translate="yes" xml:space="preserve">
          <source>It would be even more readable to write that this way:</source>
          <target state="translated">こうやって書くとさらに読みやすくなりますね。</target>
        </trans-unit>
        <trans-unit id="bb356348d0e8eb250c8d665196d735d29e867b02" translate="yes" xml:space="preserve">
          <source>It would be much better if you could ignore the NULL terminations issue in the main application code and have a mechanism that automatically added the terminating NULL to all keys and values whenever you write to the database and have them removed when you read from the database. As I'm sure you have already guessed, this is a problem that DBM Filters can fix very easily.</source>
          <target state="translated">メインアプリケーションのコードでNULL終端の問題を無視して、データベースに書き込むときには必ずすべてのキーと値に終端のNULLを自動的に追加し、データベースから読み出すときにはそれらを削除させる仕組みがあれば、はるかに良いでしょう。もうお察しの通り、これはDBMフィルタが非常に簡単に修正できる問題です。</target>
        </trans-unit>
        <trans-unit id="664879d0a9a8a0187a85ff4778c8dc4aba203972" translate="yes" xml:space="preserve">
          <source>It would be much safer if the &lt;code&gt;upcase_in()&lt;/code&gt; function were written to return a copy of its parameters instead of changing them in place:</source>
          <target state="translated">&lt;code&gt;upcase_in()&lt;/code&gt; 関数がその場所でそれらを変更する代わりにそのパラメータのコピーを返すように書かれているならば、それははるかに安全です：</target>
        </trans-unit>
        <trans-unit id="e4a501eefab1e263f175f9fb282fe6f38bf8d7a7" translate="yes" xml:space="preserve">
          <source>It would be nice if one could leave off the commas around the constants entirely and just say:</source>
          <target state="translated">定数の周りのカンマを完全に省略して、単にこう言えばいいと思います。</target>
        </trans-unit>
        <trans-unit id="7a5b5ee29fb341a3488cf2301ee04c0c66aa8f82" translate="yes" xml:space="preserve">
          <source>It would be nice if we could do this in one fell swoop: unpack a short, back up a little, and then unpack 2 bytes. Since Perl</source>
          <target state="translated">ショートパックを展開して、少しバックして、2バイトを展開するというように、一気にできるといいですね。Perlでは</target>
        </trans-unit>
        <trans-unit id="aaa6174f1be6c791e8b304262469e518ba0d9df6" translate="yes" xml:space="preserve">
          <source>It would be nice to just write:</source>
          <target state="translated">書くだけならいいんですけどね。</target>
        </trans-unit>
        <trans-unit id="dcfbbfc45bc8f20d112951dc582ad08e297b4815" translate="yes" xml:space="preserve">
          <source>It would be nice to support encoding to non-UTF8, such as =?ISO-2022-JP? and =?ISO-8859-1?= but that makes the implementation too complicated. These days major mail agents all support =?UTF-8? so I think it is just good enough.</source>
          <target state="translated">ISO-2022-JP? や =?ISO-8859-1?=のように、UTF8以外へのエンコードに対応しているといいのですが、それでは実装が複雑になりすぎます。最近の主要なメールエージェントはすべて=?UTF-8?をサポートしているので、これで十分だと思います。</target>
        </trans-unit>
        <trans-unit id="33c0be04ddea1d5a74e0dccb69b13ad0c437b131" translate="yes" xml:space="preserve">
          <source>It would put the generated files into needed locations. Manually put</source>
          <target state="translated">生成されたファイルを必要な場所に配置します。手動で</target>
        </trans-unit>
        <trans-unit id="79d53b44344312c7f974c895e0fb0eb2bd88118d" translate="yes" xml:space="preserve">
          <source>It's a Perl 4 style file defining values for system networking constants. Sometimes it is built using &lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt; when Perl is installed, but other times it is not. Modern programs should use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket;&lt;/code&gt; instead.</source>
          <target state="translated">これは、システムのネットワーク定数の値を定義するPerl 4スタイルのファイルです。Perlのインストール時に&lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt;を使用してビルドされることもありますが、そうでない場合もあります。最近のプログラムは &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket;&lt;/code&gt; を使用&lt;a href=&quot;functions/use&quot;&gt;する&lt;/a&gt;必要があります。代わりに。</target>
        </trans-unit>
        <trans-unit id="2788c8ed5f3ec3bf8bed1e36ab8dd36690fbf752" translate="yes" xml:space="preserve">
          <source>It's a Perl 4 style file defining values for system networking constants. Sometimes it is built using &lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt; when Perl is installed, but other times it is not. Modern programs should use &lt;code&gt;use Socket;&lt;/code&gt; instead.</source>
          <target state="translated">これは、システムネットワーク定数の値を定義するPerl4スタイルのファイルです。Perlがインストールされているときに&lt;a href=&quot;h2ph&quot;&gt;h2ph&lt;/a&gt;を使用してビルドされる場合もあれば、そうでない場合もあります。最新のプログラムでは &lt;code&gt;use Socket;&lt;/code&gt; を使用する必要があります。代わりに。</target>
        </trans-unit>
        <trans-unit id="4113134dec0bea10f51321538387f13a1da8743a" translate="yes" xml:space="preserve">
          <source>It's a cardinal sin to break existing Perl programs. New warnings can be contentious--some say that a program that emits warnings is not broken, while others say it is. Adding keywords has the potential to break programs, changing the meaning of existing token sequences or functions might break programs.</source>
          <target state="translated">既存の Perl プログラムを壊すのは大罪です。新しい警告は論争の的になる可能性があります-警告を発するプログラムは壊れていないと言う人もいれば、壊れていると言う人もいます。キーワードを追加することはプログラムを壊す可能性がありますし、既存のトークンシーケンスや関数の意味を変更することはプログラムを壊す可能性があります。</target>
        </trans-unit>
        <trans-unit id="3443bb54ef3fac59b8ef057b86f52fe4980fafa5" translate="yes" xml:space="preserve">
          <source>It's a little tricker with c2ph because you have to get the includes right. I can't know this for your system, but it's not usually too terribly difficult.</source>
          <target state="translated">c2phでは、インクルードを正しく取得しなければならないので、少し厄介です。あなたのシステムのためにこれを知ることはできませんが、通常はそれほど難しいことではありません。</target>
        </trans-unit>
        <trans-unit id="110a6a21060fbfe67381c1323cb9f71073b9732c" translate="yes" xml:space="preserve">
          <source>It's also possible to get into trouble with other operations that don't care whether they use tainted values. Make judicious use of the file tests in dealing with any user-supplied filenames. When possible, do opens and such &lt;b&gt;after&lt;/b&gt; properly dropping any special user (or group!) privileges. Perl doesn't prevent you from opening tainted filenames for reading, so be careful what you print out. The tainting mechanism is intended to prevent stupid mistakes, not to remove the need for thought.</source>
          <target state="translated">また、汚染された値を使用するかどうかを気にしない他の操作で問題が発生する可能性もあります。ユーザー提供のファイル名を処理する場合は、ファイルテストを慎重に使用してください。可能であれば、特別なユーザー（またはグループ！）の特権を適切に削除して&lt;b&gt;から&lt;/b&gt;、opensなどを実行してください。Perlは、汚染されたファイル名を開いて読み取ることを妨げないので、何を出力するかに注意してください。汚染メカニズムは、愚かな間違いを防ぐことを意図しており、思考の必要性を取り除くことを目的としていません。</target>
        </trans-unit>
        <trans-unit id="66317ba5ef9718c34fadba6cc4766d4c890f748d" translate="yes" xml:space="preserve">
          <source>It's also the source of a useful idiom for executing a function or performing an operation in list context and then counting the number of return values, by assigning to an empty list and then using that assignment in scalar context. For example, this code:</source>
          <target state="translated">また、リストコンテキストで関数を実行したり操作を行った後、空のリストに代入して、その代入をスカラコンテキストで使用することで、戻り値の数をカウントするという便利なイディオムの元にもなっています。例えば、このコード。</target>
        </trans-unit>
        <trans-unit id="fb0964e5585557a9c666044136d7fe7eaf45d2a2" translate="yes" xml:space="preserve">
          <source>It's also too slow (despite caching).</source>
          <target state="translated">また、(キャッシングにもかかわらず)遅すぎます。</target>
        </trans-unit>
        <trans-unit id="bfb78b8d261485bbdd288bb61ac4516df58d28f5" translate="yes" xml:space="preserve">
          <source>It's also useful in those cases where you are comparing numbers and &lt;code&gt;is()&lt;/code&gt; 's use of &lt;code&gt;eq&lt;/code&gt; will interfere:</source>
          <target state="translated">また、数値を比較し、 &lt;code&gt;is()&lt;/code&gt; の &lt;code&gt;eq&lt;/code&gt; の使用が妨げられる場合にも役立ちます。</target>
        </trans-unit>
        <trans-unit id="f80232728d1a0e850ad2f6c5b3fdccf6e503f004" translate="yes" xml:space="preserve">
          <source>It's also useful in those cases where you are comparing numbers and &lt;code&gt;is()&lt;/code&gt;'s use of &lt;code&gt;eq&lt;/code&gt; will interfere:</source>
          <target state="translated">また、数値を比較していて、 &lt;code&gt;is()&lt;/code&gt; の &lt;code&gt;eq&lt;/code&gt; の使用が干渉する場合にも役立ちます。</target>
        </trans-unit>
        <trans-unit id="8752339d213c2f85078fabecb615c362db1828df" translate="yes" xml:space="preserve">
          <source>It's also worth taking a moment to explain what happens when you &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize a member of a composite type (i.e. an array or hash element). In this case, the element is &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized</source>
          <target state="translated">また、複合型のメンバー（配列やハッシュ要素など）を &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; するとどうなるかを説明するのにも少し時間がかかります。この場合、要素は &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 化されています</target>
        </trans-unit>
        <trans-unit id="c2abe8691d5cb64abc6ccb815e6052901189c534" translate="yes" xml:space="preserve">
          <source>It's also worth taking a moment to explain what happens when you &lt;code&gt;local&lt;/code&gt;ize a member of a composite type (i.e. an array or hash element). In this case, the element is &lt;code&gt;local&lt;/code&gt;ized</source>
          <target state="translated">それはあなたがときに何が起こるかを説明する瞬間を取っても価値が &lt;code&gt;local&lt;/code&gt; 複合タイプ（つまり、配列やハッシュの要素）のメンバーをIZE。この場合、要素は、 &lt;code&gt;local&lt;/code&gt; 化さ</target>
        </trans-unit>
        <trans-unit id="bd541e8b6a88392365f934744a878ca9f6a497b7" translate="yes" xml:space="preserve">
          <source>It's better to have numerous simple routines than a few monolithic ones. If your routine changes its behaviour significantly based on its arguments, it's a sign that you should have two (or more) separate routines.</source>
          <target state="translated">モノリシックなルーチンをいくつか持つよりも、シンプルなルーチンを多数持つ方が良いでしょう。ルーチンが引数に基づいて動作を大きく変える場合は、2つ(またはそれ以上)の別個のルーチンを持つべきであることを示しています。</target>
        </trans-unit>
        <trans-unit id="f3b2de78648bbd7090bfe684b2c6827590ea2a26" translate="yes" xml:space="preserve">
          <source>It's designed to be used as a handy command line utility:</source>
          <target state="translated">便利なコマンドラインユーティリティとして使えるように設計されています。</target>
        </trans-unit>
        <trans-unit id="96439b3081e445faf2fae88934bbc314011a0c32" translate="yes" xml:space="preserve">
          <source>It's easy to notice the problem in such a short example, but in more complicated code you are looking for trouble if you don't localize changes to the special variables.</source>
          <target state="translated">このような短い例では問題に気づくのは簡単ですが、より複雑なコードでは、変更を特殊な変数にローカライズしないと問題が発生します。</target>
        </trans-unit>
        <trans-unit id="dde0b49167dc00c194116739ebbe7f23d5e20372" translate="yes" xml:space="preserve">
          <source>It's egg-eating all over again: Some think that as a bit string this should be written &quot;10001100&quot; i.e. beginning with the most significant bit, others insist on &quot;00110001&quot;. Well, Perl isn't biased, so that's why we have two bit string codes:</source>
          <target state="translated">これは、卵を食べることの繰り返しです。ある人は、これはビット文字列として &quot;10001100&quot; と書くべきだと考えていますが、他の人は &quot;00110001&quot; と主張しています。まあ、Perl には偏りがないので、2 つのビット文字列コードがあるのはそのためです。</target>
        </trans-unit>
        <trans-unit id="f24807b6184833a23a70254e8f0aebceeb147f40" translate="yes" xml:space="preserve">
          <source>It's especially useful when comparing greater-than or smaller-than relation between values:</source>
          <target state="translated">特に、値の大小関係を比較するときに便利です。</target>
        </trans-unit>
        <trans-unit id="1e3a1b4314f9d6c52bc40629c2fb29defff528f6" translate="yes" xml:space="preserve">
          <source>It's essential to run any timing measurements a sufficient number of times so the numbers settle on a numerical average, otherwise each run will naturally fluctuate due to variations in the environment, to reduce the effect of contention for &lt;code&gt;CPU&lt;/code&gt; resources and network bandwidth for instance. Running the above code for one million iterations, we can take a look at the report output by the &lt;code&gt;Benchmark&lt;/code&gt; module, to see which approach is the most effective.</source>
          <target state="translated">&lt;code&gt;CPU&lt;/code&gt; リソースやネットワーク帯域幅などの競合の影響を減らすために、タイミング測定を十分な回数実行して、数値が平均値に落ち着くようにすることが重要です。そうしないと、実行ごとに環境の変動により自然に変動します。上記のコードを100万回繰り返し実行すると、 &lt;code&gt;Benchmark&lt;/code&gt; モジュールのレポート出力を見て、どのアプローチが最も効果的かを確認できます。</target>
        </trans-unit>
        <trans-unit id="7514b40c5333fb03e3aac77ea8c92f752cf5dd0e" translate="yes" xml:space="preserve">
          <source>It's for</source>
          <target state="translated">のためのものです。</target>
        </trans-unit>
        <trans-unit id="b4b810adc86730679601de6a1493c2a23c259247" translate="yes" xml:space="preserve">
          <source>It's good idea to post an announcement of the availability of your module (or the module itself if small) to the comp.lang.perl.announce Usenet newsgroup. This will at least ensure very wide once-off distribution.</source>
          <target state="translated">あなたのモジュール(またはモジュール自体が小さい場合は)が利用可能になったことを知らせるアナウンスを comp.lang.perl.announcement Usenet ニュースグループに投稿するのは良いアイデアです。これは少なくとも、非常に広い範囲での配布を保証します。</target>
        </trans-unit>
        <trans-unit id="90af562410b60653a0aa18fd2da97246062921f5" translate="yes" xml:space="preserve">
          <source>It's good that you lost track, because you shouldn't depend on the internal format being any specific encoding. But since you asked: by default, the internal format is either ISO-8859-1 (latin-1), or utf8, depending on the history of the string. On EBCDIC platforms, this may be different even.</source>
          <target state="translated">内部フォーマットが特定のエンコーディングであることに依存すべきではないので、迷子になってしまったのは良いことです。しかし、あなたが尋ねたので、デフォルトでは、内部フォーマットは ISO-8859-1 (latin-1)か utf8 のいずれかで、文字列の履歴に依存します。EBCDIC プラットフォームでは、これは異なるかもしれません。</target>
        </trans-unit>
        <trans-unit id="d9d2e12c0d08cbda4c9a91e7d799364ca6410b91" translate="yes" xml:space="preserve">
          <source>It's important that $how_many accurately reflects the number of tests in the SKIP block so the # of tests run will match up with your plan. If your plan is &lt;code&gt;no_plan&lt;/code&gt; $how_many is optional and will default to 1.</source>
          <target state="translated">$ how_manyがSKIPブロック内のテストの数を正確に反映することが重要です。これにより、実行されるテストの数が計画と一致します。プランが &lt;code&gt;no_plan&lt;/code&gt; の場合、$ how_manyはオプションであり、デフォルトで1になります。</target>
        </trans-unit>
        <trans-unit id="1e8b6f334f8979bc29ccd072552302ba947b27dc" translate="yes" xml:space="preserve">
          <source>It's important to know what custom operators won't do for you. They won't let you add new syntax to Perl, directly. They won't even let you add new keywords, directly. In fact, they won't change the way Perl compiles a program at all. You have to do those changes yourself, after Perl has compiled the program. You do this either by manipulating the op tree using a &lt;code&gt;CHECK&lt;/code&gt; block and the &lt;code&gt;B::Generate&lt;/code&gt; module, or by adding a custom peephole optimizer with the &lt;code&gt;optimize&lt;/code&gt; module.</source>
          <target state="translated">カスタムオペレーターが何をしないかを知ることは重要です。Perlに直接新しい構文を追加することはできません。新しいキーワードを直接追加することもできません。実際、Perlがプログラムをコンパイルする方法はまったく変更されません。Perlがプログラムをコンパイルした後で、これらの変更を自分で行う必要があります。これを行うには、 &lt;code&gt;CHECK&lt;/code&gt; ブロックと &lt;code&gt;B::Generate&lt;/code&gt; モジュールを使用してopツリーを操作するか、 &lt;code&gt;optimize&lt;/code&gt; モジュールでカスタムピープホールオプティマイザーを追加します。</target>
        </trans-unit>
        <trans-unit id="885ff1b611d651161375b8dbd778f67a1c287d62" translate="yes" xml:space="preserve">
          <source>It's important to note that locks don't prevent access to the variable in question, only lock attempts. This is in keeping with Perl's longstanding tradition of courteous programming, and the advisory file locking that &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock()&lt;/a&gt;&lt;/code&gt; gives you.</source>
          <target state="translated">ロックは問題の変数へのアクセスを妨げるものではなく、ロックの試行のみを妨げるものではないことに注意することが重要です。これは、丁寧なプログラミングというPerlの長年の伝統と、 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock()&lt;/a&gt;&lt;/code&gt; が提供するアドバイザリファイルロックに準拠しています。</target>
        </trans-unit>
        <trans-unit id="c7c0c2bd9c27ab14c34335de35804fff201f2533" translate="yes" xml:space="preserve">
          <source>It's important to note that locks don't prevent access to the variable in question, only lock attempts. This is in keeping with Perl's longstanding tradition of courteous programming, and the advisory file locking that &lt;code&gt;flock()&lt;/code&gt; gives you.</source>
          <target state="translated">ロックは問題の変数へのアクセスを妨げるものではなく、ロックの試行のみを妨げることに注意することが重要です。これは、Perlの丁寧なプログラミングの長年の伝統と、 &lt;code&gt;flock()&lt;/code&gt; が提供するアドバイザリファイルロックと一致しています。</target>
        </trans-unit>
        <trans-unit id="8b860229e93d14d8905681b2058fe74c37532fe8" translate="yes" xml:space="preserve">
          <source>It's important to note that specifying this parameter as non-null will cause any warnings this function would otherwise generate to be suppressed, and instead be placed in &lt;code&gt;*msgs&lt;/code&gt;. The caller can check the lexical warnings state (or not) when choosing what to do with the returned messages.</source>
          <target state="translated">このパラメーターをnull以外として指定すると、この関数が生成する警告が抑制され、代わりに &lt;code&gt;*msgs&lt;/code&gt; に配置されることに注意することが重要です。呼び出し元は、返されたメッセージをどう処理するかを選択するときに、字句警告の状態を確認できます（または確認できません）。</target>
        </trans-unit>
        <trans-unit id="b2459276db9d22fb9b53f0419f11fb94dbdc78be" translate="yes" xml:space="preserve">
          <source>It's important to note that the resulting string does &lt;b&gt;not&lt;/b&gt; contain the padding characters typical of Base64 encodings. This omission is deliberate, and is done to maintain compatibility with the family of CPAN Digest modules. See &lt;a href=&quot;#PADDING-OF-BASE64-DIGESTS&quot;&gt;&quot;PADDING OF BASE64 DIGESTS&quot;&lt;/a&gt; for details.</source>
          <target state="translated">結果の文字列には、Base64エンコーディングで一般的なパディング文字が含まれてい&lt;b&gt;ない&lt;/b&gt;ことに注意することが重要です。この省略は意図的なものであり、CPANダイジェストモジュールのファミリーとの互換性を維持するために行われます。詳細については、&lt;a href=&quot;#PADDING-OF-BASE64-DIGESTS&quot;&gt;「BASE64ダイジェストのパディング」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b0ddbbe7b1b79fc3086fea949fd8823cad9c01f9" translate="yes" xml:space="preserve">
          <source>It's important to note that the resulting string does &lt;b&gt;not&lt;/b&gt; contain the padding characters typical of Base64 encodings. This omission is deliberate, and is done to maintain compatibility with the family of CPAN Digest modules. See &lt;a href=&quot;#PADDING-OF-BASE64-DIGESTS&quot;&gt;PADDING OF BASE64 DIGESTS&lt;/a&gt; for details.</source>
          <target state="translated">結果の文字列には、Base64エンコーディングの典型的なパディング文字が含まれてい&lt;b&gt;ない&lt;/b&gt;ことに注意することが重要です。この省略は意図的なものであり、CPANダイジェストモジュールのファミリーとの互換性を維持するために行われます。詳しくは、&lt;a href=&quot;#PADDING-OF-BASE64-DIGESTS&quot;&gt;BASE64ダイジェストのパディング&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9b1efa7406cffc0cec49027fa169f45a3bd427b6" translate="yes" xml:space="preserve">
          <source>It's important to point out that if you want your subclass to be automatically used by &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; you'll have to and make sure it gets loaded somehow. If you're using &lt;a href=&quot;prove&quot;&gt;prove&lt;/a&gt; you can write an &lt;a href=&quot;App::Prove&quot;&gt;App::Prove&lt;/a&gt; plugin. If you're using &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; or &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; directly (e.g. through a custom script, &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;, or &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt;) you can use the &lt;code&gt;config&lt;/code&gt; option which will cause &lt;a href=&quot;TAP::Parser::IteratorFactory#load_sources&quot;&gt;&quot;load_sources&quot; in TAP::Parser::IteratorFactory&lt;/a&gt; to load your subclass).</source>
          <target state="translated">サブクラスを&lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parserで&lt;/a&gt;自動的に使用する場合は、何らかの方法でサブクラスが読み込まれるようにする必要があることを指摘しておくことが重要です。&lt;a href=&quot;prove&quot;&gt;証明&lt;/a&gt;を使用している場合は、&lt;a href=&quot;App::Prove&quot;&gt;App :: Prove&lt;/a&gt;プラグインを作成できます。&lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser&lt;/a&gt;または&lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: Harnessを&lt;/a&gt;直接使用している場合（たとえば、カスタムスクリプト、&lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt;、または&lt;a href=&quot;Module::Build&quot;&gt;Module :: Buildを&lt;/a&gt;&lt;a href=&quot;TAP::Parser::IteratorFactory#load_sources&quot;&gt;介して）、TAP :: Parserで「load_sources」&lt;/a&gt;を発生させる &lt;code&gt;config&lt;/code&gt; オプションを使用できます。:: IteratorFactoryを使用してサブクラスをロードします）。</target>
        </trans-unit>
        <trans-unit id="ebc53949ff6cd0c67b2204f9d9fce4d627aed693" translate="yes" xml:space="preserve">
          <source>It's important to realize that there are no bytes in a text string. Of course, Perl has its internal encoding to store the string in memory, but ignore that. If you have to do anything with the number of bytes, it's probably best to move that part to step 3, just after you've encoded the string. Then you know exactly how many bytes it will be in the destination string.</source>
          <target state="translated">テキスト文字列にはバイトがないことを認識することが重要です。もちろん、Perlは文字列をメモリに保存するための内部エンコーディングを持っていますが、それは無視してください。もしバイト数をどうにかしなければならないのであれば、文字列をエンコードした直後のステップ3に移動した方が良いでしょう。そうすれば、それが何バイトの文字列になるのかを正確に知ることができます。</target>
        </trans-unit>
        <trans-unit id="968be3dc629433b16258b1052384042ab95062a2" translate="yes" xml:space="preserve">
          <source>It's important to set a few things straight first. This is the most important part of this tutorial. This view may conflict with other information that you may have found on the web, but that's mostly because many sources are wrong.</source>
          <target state="translated">最初にいくつかのことを整理しておきましょう。これがこのチュートリアルで最も重要な部分です。この見解は、あなたがウェブ上で見つけた他の情報と衝突するかもしれませんが、それは多くのソースが間違っているからです。</target>
        </trans-unit>
        <trans-unit id="6903f2d3d35327d3bebb7683e89ad822d6bff850" translate="yes" xml:space="preserve">
          <source>It's important to understand that we are specifically</source>
          <target state="translated">重要なのは、私たちが具体的に</target>
        </trans-unit>
        <trans-unit id="f9b3935d15d2be2d5136d58cf490c65310c19874" translate="yes" xml:space="preserve">
          <source>It's important you make sure to use the &lt;code&gt;[ ]&lt;/code&gt; array reference constructor. That's because this wouldn't work:</source>
          <target state="translated">&lt;code&gt;[ ]&lt;/code&gt; 配列参照コンストラクタを必ず使用することが重要です。これは機能しないためです。</target>
        </trans-unit>
        <trans-unit id="9fbefe7e70d26e99bc2294921c0de37542709163" translate="yes" xml:space="preserve">
          <source>It's just a first step, but it's usually a good first step.</source>
          <target state="translated">最初の一歩というだけで、大抵の場合は良い最初の一歩です。</target>
        </trans-unit>
        <trans-unit id="134dc1d9bd724d0238c1c1d4c4831e9e7f0b91b6" translate="yes" xml:space="preserve">
          <source>It's likely you'll have to add new data types later.</source>
          <target state="translated">後で新しいデータ型を追加する必要がありそうです。</target>
        </trans-unit>
        <trans-unit id="4696eb464dfb95137de621144fb7f593ad6ebd66" translate="yes" xml:space="preserve">
          <source>It's not (not!) the boundary between whitespace and non-whitespace, and it's not the stuff between words we use to create sentences.</source>
          <target state="translated">ホワイトスペースと非ホワイトスペースの境界ではなく(ない!)、文章を作るのに使う言葉の間のものではない。</target>
        </trans-unit>
        <trans-unit id="6bef3566d208cec3b519ea92214ab4883f383173" translate="yes" xml:space="preserve">
          <source>It's not a good idea to split a construct in the middle like this, and it doesn't work here. Instead use the solution above.</source>
          <target state="translated">このように途中でコンストラクトを分割するのはよくありませんし、ここではうまくいきません。代わりに上記の解決策を使います。</target>
        </trans-unit>
        <trans-unit id="ec66dac5bae6d199b4bd16298b91f74283fac7f8" translate="yes" xml:space="preserve">
          <source>It's not as easy a problem as it looks. How many words do you think are in there? Wait for it... wait for it.... If you answered 5 you're right. Perl words are groups of &lt;code&gt;\w+&lt;/code&gt; , but that's not what you want to capitalize. How is Perl supposed to know not to capitalize that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; after the apostrophe? You could try a regular expression:</source>
          <target state="translated">見た目ほど簡単な問題ではありません。そこには何語あると思いますか？待って&amp;hellip;待って&amp;hellip;5と答えたら正解です。Perlの単語は &lt;code&gt;\w+&lt;/code&gt; グループですが、それを大文字にしたいものではありません。Perlは、アポストロフィ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 後のsを大文字にしないことをどのように知っているはずですか？あなたは正規表現を試すことができます：</target>
        </trans-unit>
        <trans-unit id="4a8bd2e0723c73ceda4c03acccc160b0debe5557" translate="yes" xml:space="preserve">
          <source>It's not as easy a problem as it looks. How many words do you think are in there? Wait for it... wait for it.... If you answered 5 you're right. Perl words are groups of &lt;code&gt;\w+&lt;/code&gt;, but that's not what you want to capitalize. How is Perl supposed to know not to capitalize that &lt;code&gt;s&lt;/code&gt; after the apostrophe? You could try a regular expression:</source>
          <target state="translated">見た目ほど簡単な問題ではありません。そこにはいくつの言葉があると思いますか？それを待つ...それを待つ....あなたが5と答えたならあなたは正しい。 Perlの単語は &lt;code&gt;\w+&lt;/code&gt; グループですが、それはあなたが大文字にしたいものではありません。 Perlは、アポストロフィ &lt;code&gt;s&lt;/code&gt; 後にそれを大文字にしないことをどのように知っているはずですか？正規表現を試すことができます：</target>
        </trans-unit>
        <trans-unit id="8f3fa5386c065511869ec9dc4289bdbe2b8248c4" translate="yes" xml:space="preserve">
          <source>It's not enough to say: &quot;that will make it run faster&quot;, you have to check it. Rerun the code under control of the benchmarking or profiling modules, from the first step above, and check that the new code executed the &lt;b&gt;same task&lt;/b&gt; in</source>
          <target state="translated">「それはそれをより速く実行するでしょう」と言うだけでは十分ではありません、あなたはそれをチェックする必要があります。上記の最初のステップから、ベンチマークまたはプロファイリングモジュールの制御下でコードを再実行し、新しいコードが&lt;b&gt;同じタスク&lt;/b&gt;を実行したことを確認し&lt;b&gt;ます&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ac2ff02b85c831d3f4a6ab13ec2cd187eee43782" translate="yes" xml:space="preserve">
          <source>It's not possible to individually showcase all the performance related code for Perl here, naturally, but here's a short list of modules from the CPAN which deserve further attention.</source>
          <target state="translated">当然ながら、ここで Perl のパフォーマンス関連のコードをすべて個別に紹介することはできませんが、ここでは CPAN のモジュールのうち、さらに注目に値するモジュールの短いリストを紹介しています。</target>
        </trans-unit>
        <trans-unit id="dd227a742cbf3f4b2811cdbf8769ec886d4ea747" translate="yes" xml:space="preserve">
          <source>It's not possible to use this module to embed formatting and color attributes using Perl formats. They replace the escape character with a space (as documented in</source>
          <target state="translated">このモジュールを使用して、Perl のフォーマットを使用してフォーマットや色属性を埋め込むことはできません。これらのモジュールは、エスケープ文字をスペースに置き換えます (</target>
        </trans-unit>
        <trans-unit id="535d143f61fad023b3aec2dac42bd177c0d8265b" translate="yes" xml:space="preserve">
          <source>It's not possible to use this module to embed formatting and color attributes using Perl formats. They replace the escape character with a space (as documented in &lt;a href=&quot;http://man.he.net/man1/perlform&quot;&gt;perlform(1)&lt;/a&gt;), resulting in garbled output from the unrecognized attribute. Even if there were a way around that problem, the format doesn't know that the non-printing escape sequence is zero-length and would incorrectly format the output. For formatted output using color or other attributes, either use sprintf() instead or use formline() and then add the color or other attributes after formatting and before output.</source>
          <target state="translated">このモジュールを使用して、Perl形式を使用して書式設定と色属性を埋め込むことはできません。これらはエスケープ文字をスペースに&lt;a href=&quot;http://man.he.net/man1/perlform&quot;&gt;置き換え（perlform（1）に&lt;/a&gt;記載されているように）、認識されない属性からの出力が文字化けします。その問題を回避する方法があったとしても、フォーマットは非印刷エスケープシーケンスが長さがゼロであることを認識せず、出力を誤ってフォーマットします。色またはその他の属性を使用してフォーマットされた出力の場合は、代わりにsprintf（）を使用するか、formline（）を使用して、フォーマット後および出力前に色またはその他の属性を追加します。</target>
        </trans-unit>
        <trans-unit id="8cf7485885d18503520503d1c1deed4967629127" translate="yes" xml:space="preserve">
          <source>It's not really a barrel of laughs, is it? In fact, it's worse than it may seem; the eagle-eyed may notice that the first field should only be 10 characters wide, and the error has propagated right through the other numbers - which we've had to count by hand. So it's error-prone as well as horribly unfriendly.</source>
          <target state="translated">笑いの樽ではありませんよね? 鷹の目の人は、最初のフィールドの幅が10文字しかないことに気づくかもしれませんが、そのエラーは他の数字にも伝わってしまいます。鷹の目の人は最初のフィールドの幅が10文字しかないことに気づくかもしれませんし、エラーは他の数字にも伝わります。</target>
        </trans-unit>
        <trans-unit id="e0ac4f099ce1bc3e2ec1419213f4e20eba107331" translate="yes" xml:space="preserve">
          <source>It's not scary. Come, hold my hand. We're going to give an example of testing a module. For our example, we'll be testing a date library, &lt;a href=&quot;Date::ICal&quot;&gt;Date::ICal&lt;/a&gt;. It's on CPAN, so download a copy and follow along. [2]</source>
          <target state="translated">怖くないです。さあ、手を握って。モジュールのテストの例を示します。この例では、日付ライブラリ&lt;a href=&quot;Date::ICal&quot;&gt;Date :: ICalを&lt;/a&gt;テストします。CPANにあるので、コピーをダウンロードしてフォローしてください。[2]</target>
        </trans-unit>
        <trans-unit id="a9d4e78b20b4ec5c47ad5e65cf852abb8251388b" translate="yes" xml:space="preserve">
          <source>It's ok for your test to change where STDOUT and STDERR point to, Test::Builder's default output settings will not be affected.</source>
          <target state="translated">Test::Builderのデフォルトの出力設定は影響を受けません。</target>
        </trans-unit>
        <trans-unit id="fa762fbbddcd8f0e9e5679cef69f64552f7bd006" translate="yes" xml:space="preserve">
          <source>It's ok. That's all gone now. We've done all the black magic for you. And here are the tricks...</source>
          <target state="translated">大丈夫だよ もう終わったんだ 私たちはあなたのためにすべての黒魔術を行いました。そして、ここにトリックがあります...</target>
        </trans-unit>
        <trans-unit id="e6c4906faf9dc43631913b5936b5f4e02175738c" translate="yes" xml:space="preserve">
          <source>It's only intended as a rough tool. You may need to dicker with the files produced.</source>
          <target state="translated">あくまでも大まかなツールとしての使用を想定しています。生成されたファイルをいじる必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="4ad5389b057242e5f2754208243d1e536ed13fdf" translate="yes" xml:space="preserve">
          <source>It's only written as a helper module for both CPAN.pm and CPANPLUS.pm.</source>
          <target state="translated">CPAN.pmとCPANPLUS.pmの両方のヘルパーモジュールとして書かれているだけです。</target>
        </trans-unit>
        <trans-unit id="ce38cb5abf7b4d320a0e699a61e26594815c5fdf" translate="yes" xml:space="preserve">
          <source>It's perfectly safe to nest SKIP blocks. Each SKIP block must have the label &lt;code&gt;SKIP&lt;/code&gt; , or Test::More can't work its magic.</source>
          <target state="translated">SKIPブロックをネストすることは完全に安全です。各SKIPブロックには、ラベル &lt;code&gt;SKIP&lt;/code&gt; が必要です。そうでない場合、Test :: Moreはその魔法を働かせることができません。</target>
        </trans-unit>
        <trans-unit id="391da5d64075501c64aecf0b13f021943f8e3a31" translate="yes" xml:space="preserve">
          <source>It's perfectly safe to nest SKIP blocks. Each SKIP block must have the label &lt;code&gt;SKIP&lt;/code&gt;, or Test::More can't work its magic.</source>
          <target state="translated">SKIPブロックをネストするのは完全に安全です。各SKIPブロックはラベル持っている必要があります &lt;code&gt;SKIP&lt;/code&gt; 、またはテスト::詳細はその魔法を動作することはできません。</target>
        </trans-unit>
        <trans-unit id="23089c9252263a75014f4ca3ca447b38592d18ae" translate="yes" xml:space="preserve">
          <source>It's possible that not all modules listed below are installed on your system. For example, the GDBM_File module will not be installed if you don't have the gdbm library.</source>
          <target state="translated">以下に列挙したすべてのモジュールがシステムにインストールされていない可能性があります。例えば、gdbm ライブラリがない場合、GDBM_File モジュールはインストールされません。</target>
        </trans-unit>
        <trans-unit id="9d7827a4cab49cd207c98c793d3174f1c8aaeda1" translate="yes" xml:space="preserve">
          <source>It's possible to change the MRO of a given class either by using &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
mro&lt;/code&gt; as shown in the synopsis, or by using the &lt;a href=&quot;#mro%3a%3aset_mro&quot;&gt;mro::set_mro&lt;/a&gt; function below.</source>
          <target state="translated">概要に示されているように &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; mro&lt;/code&gt; を使用するか、以下の&lt;a href=&quot;#mro%3a%3aset_mro&quot;&gt;mro :: set_mro&lt;/a&gt;関数を使用することにより、特定のクラスのMROを変更できます。</target>
        </trans-unit>
        <trans-unit id="bef95c6240b3ebd6ee3881a4772ff7b1a355b2ea" translate="yes" xml:space="preserve">
          <source>It's possible to change the MRO of a given class either by using &lt;code&gt;use mro&lt;/code&gt; as shown in the synopsis, or by using the &lt;a href=&quot;#mro%3A%3Aset_mro&quot;&gt;&quot;mro::set_mro&quot;&lt;/a&gt; function below.</source>
          <target state="translated">概要に示すように &lt;code&gt;use mro&lt;/code&gt; を使用するか、以下の&lt;a href=&quot;#mro%3A%3Aset_mro&quot;&gt;「mro :: set_mro」&lt;/a&gt;関数を使用して、特定のクラスのMROを変更することができます。</target>
        </trans-unit>
        <trans-unit id="8141ee35a9c20672528ff17c177b18bb4b35dc61" translate="yes" xml:space="preserve">
          <source>It's possible to have a class that does not expose any publicly settable attributes. Not every class has attributes and methods.</source>
          <target state="translated">公開されている属性を一切公開しないクラスがあってもいいと思います。すべてのクラスが属性やメソッドを持っているわけではありません。</target>
        </trans-unit>
        <trans-unit id="fdf6b6ef2b9e4a59b56ec7ba91fcecae99b94163" translate="yes" xml:space="preserve">
          <source>It's possible to load multiple features together, using a</source>
          <target state="translated">複数の機能を一緒にロードすることができます。</target>
        </trans-unit>
        <trans-unit id="66c778a3281518c9b26558498194320e4725fef9" translate="yes" xml:space="preserve">
          <source>It's possible to take the previous idea a little further, by using a compile time &lt;code&gt;DEBUG&lt;/code&gt; constant.</source>
          <target state="translated">コンパイル時の &lt;code&gt;DEBUG&lt;/code&gt; 定数を使用することにより、前のアイデアをさらに進めることができます。</target>
        </trans-unit>
        <trans-unit id="30a0b506f4d59de09c1852a82f659060edd73925" translate="yes" xml:space="preserve">
          <source>It's possible to use simple addition and subtraction of objects:</source>
          <target state="translated">物体の単純な足し算・引き算が可能です。</target>
        </trans-unit>
        <trans-unit id="7c04330ddf6941f6fc338e6607920a6ccb70bb26" translate="yes" xml:space="preserve">
          <source>It's preferable to patch against the latest blead version, since this is where new development occurs for all changes other than critical bug fixes. Critical bug fix patches should be made against the relevant maint branches, or should be submitted with a note indicating all the branches where the fix should be applied.</source>
          <target state="translated">重要なバグフィックス以外のすべての変更については、最新の blead バージョンに対してパッチを適用することが望ましいです。重要なバグ修正のパッチは、関連する maint ブランチに対して行うか、修正が適用されるべきすべてのブランチを示すメモを添えて提出してください。</target>
        </trans-unit>
        <trans-unit id="b2798edf93af2bc08dca21c6c73367266b229901" translate="yes" xml:space="preserve">
          <source>It's probably best to copy one of the existing runops functions and change it to suit your needs. Then, in the BOOT section of your XS file, add the line:</source>
          <target state="translated">既存のrunops関数をコピーして、必要に応じて変更するのが良いでしょう。そして、XSファイルのBOOTセクションで、次の行を追加します。</target>
        </trans-unit>
        <trans-unit id="b340d427890b7b2748a883b3fba121b10e7d2921" translate="yes" xml:space="preserve">
          <source>It's probably best to prototype new functions, not retrofit prototyping into older ones. That's because you must be especially careful about silent impositions of differing list versus scalar contexts. For example, if you decide that a function should take just one parameter, like this:</source>
          <target state="translated">古い関数にプロトタイピングを後付けするのではなく、新しい関数をプロトタイピングするのがベストでしょう。これは、リストとスカラコンテキストの違いによる無言の強制には特に注意しなければならないからです。例えば、ある関数が1つのパラメータだけを取るべきだと決めた場合、次のようになります。</target>
        </trans-unit>
        <trans-unit id="91ff9edf126b862a4aaa943668bacea81314c045" translate="yes" xml:space="preserve">
          <source>It's probably better to always use commas after constant names in order to force the next error.</source>
          <target state="translated">次のエラーを強制的に発生させるために、定数名の後には常にカンマを使った方が良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="16dbf025d239b7a2bc2c7033417d6a18d06e2afb" translate="yes" xml:space="preserve">
          <source>It's probably worth mentioning that if you're going to filetest the return values out of a readdir, you'd better prepend the directory in question. Otherwise, because we didn't chdir() there, it would have been testing the wrong file.</source>
          <target state="translated">readdir からの戻り値をファイルテストする場合は、問題のディレクトリを前置した方が良いということを言っておくと良いでしょう。そうしないと、そこに chdir()を入れていないので、間違ったファイルをテストしてしまうことになります。</target>
        </trans-unit>
        <trans-unit id="e6c512535456a00f2d66365aceea1ac2fa50945d" translate="yes" xml:space="preserve">
          <source>It's quite possible that the target system doesn't have a readily available /tmp, so it's generall safer to do something like this:</source>
          <target state="translated">ターゲットシステムがすぐに利用可能な /tmp を持っていない可能性があるので、このようなことをした方が安全です。</target>
        </trans-unit>
        <trans-unit id="8748833136242804cdf06e42df13a982b1789766" translate="yes" xml:space="preserve">
          <source>It's recommended that you run &lt;code&gt;use_ok()&lt;/code&gt; inside a BEGIN block so its functions are exported at compile-time and prototypes are properly honored.</source>
          <target state="translated">BEGINブロック内で &lt;code&gt;use_ok()&lt;/code&gt; を実行して、その関数がコンパイル時にエクスポートされ、プロトタイプが適切に受け入れられるようにすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="fbc60c6d884b88a267926002dcaceb4adc822c67" translate="yes" xml:space="preserve">
          <source>It's safe, however, to P- or p-pack a string literal, because Perl simply allocates an anonymous variable.</source>
          <target state="translated">しかし、Perl は単に匿名変数を確保するだけなので、文字列リテラルを P-pack したり p-pack したりするのは安全です。</target>
        </trans-unit>
        <trans-unit id="18b132707c62c569a28f6b436602a7bfbd864dfd" translate="yes" xml:space="preserve">
          <source>It's still not quite so clear as prose, but it is very useful for describing the meaning of each part of the pattern.</source>
          <target state="translated">散文としてはまだわかりにくいですが、パターンの各部分の意味を説明するのには非常に便利です。</target>
        </trans-unit>
        <trans-unit id="08057143a2d44a0a378f9cd365b42fe324a68a97" translate="yes" xml:space="preserve">
          <source>It's still up to you to seek out the actual changes, and there might not actually be any. Perhaps all of the changes since you last checked cancelled each other out and left the package in the state it was in before.</source>
          <target state="translated">実際の変更点を探すのはあなた次第ですし、実際には何もないかもしれません。もしかしたら、最後にチェックした時からの変更点がすべてキャンセルされて、パッケージが以前の状態のままになっているのかもしれません。</target>
        </trans-unit>
        <trans-unit id="6aa1b5e370d6ab122fa013735d3b648f88f35f20" translate="yes" xml:space="preserve">
          <source>It's the double quotes, not the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, doing this. Whenever you interpolate an array in a double quote context, Perl joins the elements with spaces (or whatever is in &lt;code&gt;$&quot;&lt;/code&gt; , which is a space by default):</source>
          <target state="translated">これを行うのは、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ではなく、二重引用符です。二重引用符のコンテキストで配列を補間するときはいつでも、Perlは要素をスペース（または &lt;code&gt;$&quot;&lt;/code&gt; にあるもの（デフォルトではスペース））で結合します。</target>
        </trans-unit>
        <trans-unit id="7e186193135a9027584138d266cd6dc740e3d523" translate="yes" xml:space="preserve">
          <source>It's the double quotes, not the &lt;code&gt;print&lt;/code&gt;, doing this. Whenever you interpolate an array in a double quote context, Perl joins the elements with spaces (or whatever is in &lt;code&gt;$&quot;&lt;/code&gt;, which is a space by default):</source>
          <target state="translated">これを行うのは、 &lt;code&gt;print&lt;/code&gt; ではなく二重引用符です。二重引用符のコンテキストで配列を補間する場合は常に、Perlは要素をスペース（またはデフォルトではスペースである &lt;code&gt;$&quot;&lt;/code&gt; にあるもの）で結合します。</target>
        </trans-unit>
        <trans-unit id="faab5a6ebe5c2e1ecdb8d0e0f9a387f835a3623a" translate="yes" xml:space="preserve">
          <source>It's useful if you want to print out the name of a variable. If you restrict yourself to globs which exist at compile-time then the result ought to be unambiguous, because code like &lt;code&gt;${&quot;^G&quot;} = 1&lt;/code&gt; is compiled as two ops - a constant string and a dereference (rv2gv) - so that the glob is created at runtime.</source>
          <target state="translated">変数の名前を出力したい場合に便利です。 &lt;code&gt;${&quot;^G&quot;} = 1&lt;/code&gt; ようなコードは2つのops-定数文字列と逆参照（rv2gv）-としてコンパイルされるため、コンパイル時に存在するグロブに制限すると、結果は明確になるはずです。グロブは実行時に作成されます。</target>
        </trans-unit>
        <trans-unit id="6fb10a58faaab36e9d6bfc07705548b7e33879f9" translate="yes" xml:space="preserve">
          <source>It's very simple to have your tests run under taint mode. Just throw a &lt;code&gt;-T&lt;/code&gt; into the &lt;code&gt;#!&lt;/code&gt; line. &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; will read the switches in &lt;code&gt;#!&lt;/code&gt; and use them to run your tests.</source>
          <target state="translated">テストを汚染モードで実行するのは非常に簡単です。 &lt;code&gt;#!&lt;/code&gt; &lt;code&gt;-T&lt;/code&gt; を入れるだけです！ライン。&lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt;は &lt;code&gt;#!&lt;/code&gt; のスイッチを読み取ります！それらを使用してテストを実行します。</target>
        </trans-unit>
        <trans-unit id="57045aa0891a8e6164538ff7cbd090571f866c1f" translate="yes" xml:space="preserve">
          <source>It's well known that software developers usually fully document the software they write. If, however, the world is in urgent need of your software and there is not enough time to write the full documentation please at least provide a README file containing:</source>
          <target state="translated">ソフトウェア開発者は、通常、自分が書いたソフトウェアを完全に文書化することはよく知られています。しかし、世界があなたのソフトウェアを緊急に必要としており、完全なドキュメントを書くのに十分な時間がない場合は、少なくともREADMEファイルを提供してください。</target>
        </trans-unit>
        <trans-unit id="485b57adcc80650a0f376fe516e0ea35fef68007" translate="yes" xml:space="preserve">
          <source>Italian</source>
          <target state="translated">Italian</target>
        </trans-unit>
        <trans-unit id="4198106b088c5bcb9774e212538d8c15169f58dc" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">固定幅フォントのイタリックバージョン（ほとんどの固定幅フォントには斜体バージョンのみがあり、イタリックバージョンはないため、実際には、誤った名称のようなもの）。デフォルトは &lt;code&gt;CI&lt;/code&gt; です。&lt;b&gt;troff&lt;/b&gt;出力にのみ関係します。</target>
        </trans-unit>
        <trans-unit id="583cdcdfd2a75305b35fba58a53f31af16e8fada" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">固定幅フォントのイタリックバージョン（ほとんどの固定幅フォントには斜体バージョンのみがあり、イタリックバージョンはないため、実際には、誤った名称のようなもの）。デフォルトは &lt;code&gt;CI&lt;/code&gt; です。troff（1）の出力にのみ重要です。</target>
        </trans-unit>
        <trans-unit id="a71960565a249a16493cbd47c7e62585cc7cdbc3" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt;. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">固定幅フォントのイタリックバージョン（実際には、ほとんどの固定幅フォントには斜体バージョンのみがあり、イタリックバージョンはないため、誤称があります）。デフォルトは &lt;code&gt;CI&lt;/code&gt; です。&lt;b&gt;troff&lt;/b&gt;出力にのみ関係します。</target>
        </trans-unit>
        <trans-unit id="49d619f9e66322d8e23851c7238a0c1bf5b94557" translate="yes" xml:space="preserve">
          <source>Italic version of the fixed-width font (actually, something of a misnomer, since most fixed-width fonts only have an oblique version, not an italic version). Defaults to &lt;code&gt;CI&lt;/code&gt;. Only matters for troff(1) output.</source>
          <target state="translated">固定幅フォントのイタリックバージョン（実際には、ほとんどの固定幅フォントには斜体バージョンのみがあり、イタリックバージョンはないため、誤称があります）。デフォルトは &lt;code&gt;CI&lt;/code&gt; です。troff（1）出力にのみ関係します。</target>
        </trans-unit>
        <trans-unit id="ad79ef0f076d3a686ab9738925f4dd2c7e69d7d1" translate="yes" xml:space="preserve">
          <source>Italy</source>
          <target state="translated">Italy</target>
        </trans-unit>
        <trans-unit id="b15ebe35e9c7b71db4b6f242bc6c861b7b404110" translate="yes" xml:space="preserve">
          <source>Itanium Processor Family (IPF) and HP-UX</source>
          <target state="translated">Itanium プロセッサ・ファミリー (IPF)と HP-UX</target>
        </trans-unit>
        <trans-unit id="e54d4abd34db02334ef2ceaf6dadfd1a53f1ce9b" translate="yes" xml:space="preserve">
          <source>Itanium, Itanium 2 &amp;amp; Madison 6</source>
          <target state="translated">Itanium、Itanium 2、Madison 6</target>
        </trans-unit>
        <trans-unit id="2644b5ac3389091857c1fa06a99019df89bdf067" translate="yes" xml:space="preserve">
          <source>Item called without tag</source>
          <target state="translated">タグなしで呼び出されたアイテム</target>
        </trans-unit>
        <trans-unit id="e359180eb8ab875848335db708d277f8c6f86293" translate="yes" xml:space="preserve">
          <source>Item, over, and back require a little more explanation: &quot;=over&quot; starts a region specifically for the generation of a list using &quot;=item&quot; commands, or for indenting (groups of) normal paragraphs. At the end of your list, use &quot;=back&quot; to end it. The</source>
          <target state="translated">Item,over,back はもう少し説明が必要です。&quot;over &quot;は、&quot;=item &quot;コマンドを使ってリストを生成したり、通常の段落のインデント(グループ)を行うための領域を開始します。リストの最後には、&quot;=back&quot; を使って終了させます。リストの最後には、&quot;=back &quot;を使って終わりにします。</target>
        </trans-unit>
        <trans-unit id="839a5a9f576aa03eb6484f3e36f4922e7b29ec1b" translate="yes" xml:space="preserve">
          <source>Items are popped from the stack by the &lt;code&gt;POPMARK&lt;/code&gt; macro. There is also a macro &lt;code&gt;TOPMARK&lt;/code&gt; that inspects the topmost item without removing it. These macros return I32 index values directly. There is also the &lt;code&gt;dMARK&lt;/code&gt; macro which declares a new SV double-pointer variable, called &lt;code&gt;mark&lt;/code&gt;, which points at the marked stack slot; this is the usual macro that C code will use when operating on lists given on the stack.</source>
          <target state="translated">アイテムは、 &lt;code&gt;POPMARK&lt;/code&gt; マクロによってスタックからポップされます。最上位のアイテムを削除せずに検査するマクロ &lt;code&gt;TOPMARK&lt;/code&gt; もあります。これらのマクロは、I32インデックス値を直接返します。マークされたスタックスロットを指す、 &lt;code&gt;mark&lt;/code&gt; と呼ばれる新しいSVダブルポインタ変数を宣言する &lt;code&gt;dMARK&lt;/code&gt; マクロもあります。これは、スタックで指定されたリストを操作するときにCコードが使用する通常のマクロです。</target>
        </trans-unit>
        <trans-unit id="042e4f40b0307417307709cb5473dc322f497e53" translate="yes" xml:space="preserve">
          <source>Items are popped from the stack by using the &lt;code&gt;POPs&lt;/code&gt; macro or its typed versions, There is also a macro &lt;code&gt;TOPs&lt;/code&gt; that inspects the topmost item without removing it.</source>
          <target state="translated">アイテムは、 &lt;code&gt;POPs&lt;/code&gt; マクロまたはその型指定されたバージョンを使用してスタックからポップされます。最上位のアイテムを削除せずに検査するマクロ &lt;code&gt;TOPs&lt;/code&gt; もあります。</target>
        </trans-unit>
        <trans-unit id="cb2734858b1f6df00795c8577aa06b54f6e0816d" translate="yes" xml:space="preserve">
          <source>Items are pushed to the save stack by using the various &lt;code&gt;SAVE...()&lt;/code&gt; macros. Many of these macros take a variable and store both its address and current value on the save stack, ensuring that value gets restored on scope exit.</source>
          <target state="translated">アイテムは、さまざまな &lt;code&gt;SAVE...()&lt;/code&gt; マクロを使用して保存スタックにプッシュされます。これらのマクロの多くは変数を受け取り、そのアドレスと現在の値の両方を保存スタックに格納して、スコープの終了時に値が復元されるようにします。</target>
        </trans-unit>
        <trans-unit id="bb0e07dde86207db19bb7bb39fcc8f34c4917c7f" translate="yes" xml:space="preserve">
          <source>Items are pushed to the stack by using the &lt;code&gt;PUSHMARK()&lt;/code&gt; macro. Even though the stack itself stores (value) stack indices as integers, the &lt;code&gt;PUSHMARK&lt;/code&gt; macro should be given a stack pointer directly; it will calculate the index offset by comparing to the &lt;code&gt;PL_stack_sp&lt;/code&gt; variable. Thus almost always the code to perform this is</source>
          <target state="translated">アイテムは、 &lt;code&gt;PUSHMARK()&lt;/code&gt; マクロを使用してスタックにプッシュされます。スタック自体は（値）スタックインデックスを整数として格納しますが、 &lt;code&gt;PUSHMARK&lt;/code&gt; マクロにはスタックポインタを直接指定する必要があります。 &lt;code&gt;PL_stack_sp&lt;/code&gt; 変数と比較して、インデックスオフセットを計算します。したがって、ほとんどの場合、これを実行するコードは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="b956fed2d730024f43d841fa09eee15223cb553e" translate="yes" xml:space="preserve">
          <source>Items are pushed to the stack by using the &lt;code&gt;PUSHs()&lt;/code&gt; macro or its variants described above; &lt;code&gt;XPUSHs()&lt;/code&gt;, &lt;code&gt;mPUSHs()&lt;/code&gt;, &lt;code&gt;mXPUSHs()&lt;/code&gt; and the typed versions. Note carefully that the non-&lt;code&gt;X&lt;/code&gt; versions of these macros do not check the size of the stack and assume it to be big enough. These must be paired with a suitable check of the stack's size, such as the &lt;code&gt;EXTEND&lt;/code&gt; macro to ensure it is large enough. For example</source>
          <target state="translated">アイテムは、上記の &lt;code&gt;PUSHs()&lt;/code&gt; マクロまたはそのバリアントを使用してスタックにプッシュされます。 &lt;code&gt;XPUSHs()&lt;/code&gt; 、 &lt;code&gt;mPUSHs()&lt;/code&gt; 、 &lt;code&gt;mXPUSHs()&lt;/code&gt; および型指定されたバージョン。これらのマクロの非 &lt;code&gt;X&lt;/code&gt; バージョンはスタックのサイズをチェックせず、十分な大きさであると想定していることに注意してください。これらは、スタックが十分に大きいことを確認するために、 &lt;code&gt;EXTEND&lt;/code&gt; マクロなどのスタックのサイズの適切なチェックと組み合わせる必要があります。例えば</target>
        </trans-unit>
        <trans-unit id="bca788485b73309b9f1f94d8376ab88aa565b95b" translate="yes" xml:space="preserve">
          <source>Iterate raw input without applying any fixes for quirky input syntax.</source>
          <target state="translated">風変わりな入力構文の修正を適用せずに、生の入力を繰り返し処理します。</target>
        </trans-unit>
        <trans-unit id="880d0fdfaa731611203ad90b727f9ad0e4c9d1d5" translate="yes" xml:space="preserve">
          <source>Iterate through it, of course.</source>
          <target state="translated">もちろん、それを反復して</target>
        </trans-unit>
        <trans-unit id="0c168efad25dad6474931abc9c9d01ef4bb67924" translate="yes" xml:space="preserve">
          <source>Iterate through the process output, of course.</source>
          <target state="translated">もちろん、プロセスの出力を反復します。</target>
        </trans-unit>
        <trans-unit id="427ce88c1ea69b3f405aa4f0fa73689dcbd052f7" translate="yes" xml:space="preserve">
          <source>Iterates over necessary shared objects, calling &lt;code&gt;xs_make_dlsyms&lt;/code&gt; method for each with appropriate arguments.</source>
          <target state="translated">必要な共有オブジェクトを反復処理し、適切な引数を使用してそれぞれに対して &lt;code&gt;xs_make_dlsyms&lt;/code&gt; メソッドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="269b5437f5a208443de379288c68fd64af0840d2" translate="yes" xml:space="preserve">
          <source>Iterating over the PADNAMELIST iterates over all possible pad items. Pad slots for targets (&lt;code&gt;SVs_PADTMP&lt;/code&gt;) and GVs end up having &amp;amp;PL_padname_undef &quot;names&quot;, while slots for constants have &lt;code&gt;&amp;amp;PL_padname_const&lt;/code&gt; &quot;names&quot; (see &lt;code&gt;&lt;a href=&quot;#pad_alloc&quot;&gt;&quot;pad_alloc&quot;&lt;/a&gt;&lt;/code&gt;). That &lt;code&gt;&amp;amp;PL_padname_undef&lt;/code&gt; and &lt;code&gt;&amp;amp;PL_padname_const&lt;/code&gt; are used is an implementation detail subject to change. To test for them, use &lt;code&gt;!PadnamePV(name)&lt;/code&gt; and &lt;code&gt;PadnamePV(name) &amp;amp;&amp;amp; !PadnameLEN(name)&lt;/code&gt;, respectively.</source>
          <target state="translated">PADNAMELISTを反復処理すると、考えられるすべてのパッドアイテムが反復処理されます。ターゲット（ &lt;code&gt;SVs_PADTMP&lt;/code&gt; ）とGVのパッドスロットには＆PL_padname_undef &quot;names&quot;があり、定数のスロットには &lt;code&gt;&amp;amp;PL_padname_const&lt;/code&gt; &quot;names&quot;があります（ &lt;code&gt;&lt;a href=&quot;#pad_alloc&quot;&gt;&quot;pad_alloc&quot;&lt;/a&gt;&lt;/code&gt; 参照）。それ &lt;code&gt;&amp;amp;PL_padname_undef&lt;/code&gt; と &lt;code&gt;&amp;amp;PL_padname_const&lt;/code&gt; が使用されている変更の実装の詳細の対象となります。それらをテストするには、それぞれ &lt;code&gt;!PadnamePV(name)&lt;/code&gt; と &lt;code&gt;PadnamePV(name) &amp;amp;&amp;amp; !PadnameLEN(name)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="e92d8ec2d181e1d01333d9fb58638b2b85aed8c4" translate="yes" xml:space="preserve">
          <source>Iterating over the PADNAMELIST iterates over all possible pad items. Pad slots for targets (SVs_PADTMP) and GVs end up having &amp;amp;PL_padname_undef &quot;names&quot;, while slots for constants have &amp;amp;PL_padname_const &quot;names&quot; (see pad_alloc()). That &amp;amp;PL_padname_undef and &amp;amp;PL_padname_const are used is an implementation detail subject to change. To test for them, use &lt;code&gt;!PadnamePV(name)&lt;/code&gt; and &lt;code&gt;PadnamePV(name)
&amp;amp;&amp;amp; !PadnameLEN(name)&lt;/code&gt; , respectively.</source>
          <target state="translated">PADNAMELISTを反復処理すると、可能なすべてのパッド項目が反復処理されます。ターゲット（SVs_PADTMP）とGVのパッドスロットは、最終的に＆PL_padname_undef「名前」を持ちますが、定数のスロットは＆PL_padname_const「名前」を持っています（pad_alloc（）を参照）。＆PL_padname_undefおよび＆PL_padname_constが使用されることは、変更される可能性のある実装の詳細です。それらをテストするには、それぞれ &lt;code&gt;!PadnamePV(name)&lt;/code&gt; および &lt;code&gt;PadnamePV(name) &amp;amp;&amp;amp; !PadnameLEN(name)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="ca668574626a9549ef81113edbe0269d243a6e70" translate="yes" xml:space="preserve">
          <source>Iterator for array-based TAP sources</source>
          <target state="translated">配列ベースのTAPソース用イテレータ</target>
        </trans-unit>
        <trans-unit id="e365acec52938bb4821137a9d3698525ef64c0e6" translate="yes" xml:space="preserve">
          <source>Iterator for filehandle-based TAP sources</source>
          <target state="translated">ファイルハンドルベースの TAP ソース用イテレータ</target>
        </trans-unit>
        <trans-unit id="608949e6615edc46b7788d7e5f71e396c783a95e" translate="yes" xml:space="preserve">
          <source>Iterator for process-based TAP sources</source>
          <target state="translated">プロセスベースの TAP ソース用イテレータ</target>
        </trans-unit>
        <trans-unit id="1fdccc2b2140fc0f61c8fa7efaf9cf9309d438ee" translate="yes" xml:space="preserve">
          <source>IteratorFactory</source>
          <target state="translated">IteratorFactory</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="e11cc17e61cacb91ddb22ab15b88e065056ee12e" translate="yes" xml:space="preserve">
          <source>Ithreads work by cloning the data tree so that no data is shared between different threads. These threads can be used by using the &lt;code&gt;threads&lt;/code&gt; module or by doing fork() on win32 (fake fork() support). When a thread is cloned all Perl data is cloned, however non-Perl data cannot be cloned automatically. Perl after 5.8.0 has support for the &lt;code&gt;CLONE&lt;/code&gt; special subroutine. In &lt;code&gt;CLONE&lt;/code&gt; you can do whatever you need to do, like for example handle the cloning of non-Perl data, if necessary. &lt;code&gt;CLONE&lt;/code&gt; will be called once as a class method for every package that has it defined (or inherits it). It will be called in the context of the new thread, so all modifications are made in the new area. Currently CLONE is called with no parameters other than the invocant package name, but code should not assume that this will remain unchanged, as it is likely that in future extra parameters will be passed in to give more information about the state of cloning.</source>
          <target state="translated">Ithreadは、データツリーを複製することで機能し、異なるスレッド間でデータが共有されないようにします。これらのスレッドは、 &lt;code&gt;threads&lt;/code&gt; モジュールを使用するか、win32でfork（）を実行することによって使用できます（偽のfork（）サポート）。スレッドが複製されると、すべてのPerlデータが複製されますが、Perl以外のデータは自動的に複製できません。 5.8.0以降のPerlは、 &lt;code&gt;CLONE&lt;/code&gt; 特殊サブルーチンをサポートしています。で &lt;code&gt;CLONE&lt;/code&gt; あなたは、必要に応じて、例えば、ハンドルのように、非Perlデータの複製を行う必要があるものは何でも行うことができます。 &lt;code&gt;CLONE&lt;/code&gt; 定義されている（または継承している）すべてのパッケージのクラスメソッドとして一度呼び出されます。新しいスレッドのコンテキストで呼び出されるため、すべての変更は新しい領域で行われます。現在、CLONEは呼び出し元のパッケージ名以外のパラメーターなしで呼び出されますが、コードはこれが変更されないままであることを想定しないでください。将来、追加のパラメーターが渡されてクローンの状態に関する詳細情報が提供される可能性があります。</target>
        </trans-unit>
        <trans-unit id="1fc560e7e4efb5d974d128bd00c3dd33446589b6" translate="yes" xml:space="preserve">
          <source>Its &lt;code&gt;pprivate&lt;/code&gt; and &lt;code&gt;intflags&lt;/code&gt; fields contain data specific to each engine.</source>
          <target state="translated">その &lt;code&gt;pprivate&lt;/code&gt; および &lt;code&gt;intflags&lt;/code&gt; フィールドには、各エンジンに固有のデータが含まれています。</target>
        </trans-unit>
        <trans-unit id="16c6982b7d6141952759d09a7076ec5f4dab57ab" translate="yes" xml:space="preserve">
          <source>Its address can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed. Make sure that you don't try to compare a random sv with &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; . For example when interfacing Perl code, it'll work correctly for:</source>
          <target state="translated">そのアドレスは、 &lt;code&gt;SV*&lt;/code&gt; が必要なときにいつでも使用できます。ランダムなsvを &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; と比較しないでください。たとえば、Perlコードをインターフェースする場合、次の場合に正しく機能します。</target>
        </trans-unit>
        <trans-unit id="09d223f73a742d40d37e0069338730ea57d94138" translate="yes" xml:space="preserve">
          <source>Its address can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed. Make sure that you don't try to compare a random sv with &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt;. For example when interfacing Perl code, it'll work correctly for:</source>
          <target state="translated">そのアドレスは、 &lt;code&gt;SV*&lt;/code&gt; が必要なときにいつでも使用できます。ランダムなsvを &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; と比較しようとしないように注意してください。たとえば、Perlコードをインターフェースする場合、次の場合に正しく機能します。</target>
        </trans-unit>
        <trans-unit id="0881b1abd4c8c0f2683196629616b2be066ab1e5" translate="yes" xml:space="preserve">
          <source>Its advantage over &lt;code&gt;ok()&lt;/code&gt; is when the test fails you'll know what $got and $expected were:</source>
          <target state="translated">&lt;code&gt;ok()&lt;/code&gt; に対するその利点は、テストが失敗したときに、$ gotと$ expectedが何であったかがわかることです。</target>
        </trans-unit>
        <trans-unit id="004b859afb711a2b891500dcf0aac6a8c2d2a9a8" translate="yes" xml:space="preserve">
          <source>Its advantages over &lt;code&gt;ok()&lt;/code&gt; are similar to that of &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; . Better diagnostics on failure.</source>
          <target state="translated">&lt;code&gt;ok()&lt;/code&gt; に対するその利点 &lt;code&gt;is()&lt;/code&gt; 、is（）および &lt;code&gt;isnt()&lt;/code&gt; の利点に似ています。障害の診断が改善されました。</target>
        </trans-unit>
        <trans-unit id="0c8e5bbdfc16ed39f18dc0db649a1798bde0ff44" translate="yes" xml:space="preserve">
          <source>Its advantages over &lt;code&gt;ok()&lt;/code&gt; are similar to that of &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt;. Better diagnostics on failure.</source>
          <target state="translated">&lt;code&gt;ok()&lt;/code&gt; に対するその利点 &lt;code&gt;is()&lt;/code&gt; 、is（）および &lt;code&gt;isnt()&lt;/code&gt; の利点と似ています。障害のより良い診断。</target>
        </trans-unit>
        <trans-unit id="b47f30ae9fc0af2d5174d1161686c5cb48a52d13" translate="yes" xml:space="preserve">
          <source>Its behaviour is identical to using an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; type in XS with T_IV.</source>
          <target state="translated">その動作は、X_SでT_IV を使用して &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 型を使用する場合と同じです。</target>
        </trans-unit>
        <trans-unit id="78ff78bdd00c6e2cf21af3315183fda1a7d0aefd" translate="yes" xml:space="preserve">
          <source>Its behaviour is identical to using an &lt;code&gt;int&lt;/code&gt; type in XS with T_IV.</source>
          <target state="translated">その動作は、XSでT_IVを使用して &lt;code&gt;int&lt;/code&gt; 型を使用する場合と同じです。</target>
        </trans-unit>
        <trans-unit id="fae697da5b215cc5fb762242f2f9d970cf1a4185" translate="yes" xml:space="preserve">
          <source>Its currently very simple and may be expanded sometime in the figure to include more flexible code and switches.</source>
          <target state="translated">現在は非常にシンプルなものですが、将来的には、より柔軟なコードやスイッチを含むように拡張されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="270729f2364ce03a3daacf9b717d32c8a85378b7" translate="yes" xml:space="preserve">
          <source>Its format is not guaranteed not to change over time.</source>
          <target state="translated">そのフォーマットは、経年変化しないことを保証するものではありません。</target>
        </trans-unit>
        <trans-unit id="ab2643af88a544c3d8cf389888d3e8add44c6b63" translate="yes" xml:space="preserve">
          <source>Its name comes from the observation that this operation combined with the alternation operator (&lt;code&gt;&quot;|&quot;&lt;/code&gt;) can be used to create what is essentially a pattern-based if/then/else block:</source>
          <target state="translated">その名前は、この操作を交互演算子（ &lt;code&gt;&quot;|&quot;&lt;/code&gt; ）と組み合わせて、本質的にパターンベースのif / then / elseブロックを作成できるという観察に由来しています。</target>
        </trans-unit>
        <trans-unit id="41db9b49c066a3eed741a13ffe63dcafc0bc1631" translate="yes" xml:space="preserve">
          <source>Its name comes from the observation that this operation combined with the alternation operator (&lt;code&gt;|&lt;/code&gt;) can be used to create what is essentially a pattern-based if/then/else block:</source>
          <target state="translated">その名前は、この操作と代替演算子（ &lt;code&gt;|&lt;/code&gt; ）を組み合わせて使用して、基本的にパターンベースのif / then / elseブロックを作成できるという観察に由来しています。</target>
        </trans-unit>
        <trans-unit id="857df5ce623d367dca94803887ed2679c126a932" translate="yes" xml:space="preserve">
          <source>Its purpose was to allow your non-ASCII Perl scripts not to have to be written in UTF-8; this was useful before editors that worked on UTF-8 encoded text were common, but that was long ago. It caused problems, such as affecting the operation of other modules that weren't expecting it, causing general mayhem.</source>
          <target state="translated">これは UTF-8 エンコードされたテキストを扱うエディタが一般的になる前は便利でしたが、それはずっと前のことです。これは、期待していなかった他のモジュールの動作に影響を与えるなどの問題を引き起こし、大混乱を引き起こしました。</target>
        </trans-unit>
        <trans-unit id="12f8c93b7e3928b82285ec3cb4baed8ba27c22ab" translate="yes" xml:space="preserve">
          <source>Its return buffer is per-thread, so it also is never overwritten by a call to this function from another thread; unlike the function it replaces.</source>
          <target state="translated">この関数の戻り値バッファはスレッドごとに設定されているため、他のスレッドからこの関数を呼び出しても上書きされることはありません。</target>
        </trans-unit>
        <trans-unit id="c1a5e19377208f27c49b06cb17d4ed4cd4b998dc" translate="yes" xml:space="preserve">
          <source>Its use of \x1b (escape) is also very questionable.</source>
          <target state="translated">脱出」の使い方も非常に怪しい。</target>
        </trans-unit>
        <trans-unit id="439b82c22fda8042c3800152aa28934c765e39cf" translate="yes" xml:space="preserve">
          <source>Its value grows rapidly, even for small inputs. For example, A(4, 2) is an integer of 19729 decimal digits.</source>
          <target state="translated">その値は、小さな入力に対しても急速に成長します。例えば、A(4,2)は19729桁の10進数の整数です。</target>
        </trans-unit>
        <trans-unit id="c1782b37a47b28cba886190c0e7c9425d4b8409e" translate="yes" xml:space="preserve">
          <source>Its wrapping is done by &lt;a href=&quot;../../text/wrap&quot;&gt;Text::Wrap&lt;/a&gt;, so you can change &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; as you like.</source>
          <target state="translated">そのラッピングは&lt;a href=&quot;../../text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt;によって行われるため、 &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; を好きなように変更できます。</target>
        </trans-unit>
        <trans-unit id="8279d860cdcd8af715030eac4d6150f64676e6fe" translate="yes" xml:space="preserve">
          <source>Its wrapping is done by &lt;a href=&quot;Text::Wrap&quot;&gt;Text::Wrap&lt;/a&gt;, so you can change &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; as you like.</source>
          <target state="translated">その折り返しは&lt;a href=&quot;Text::Wrap&quot;&gt;Text :: Wrap&lt;/a&gt;によって行われるため、 &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; を好きなように変更できます。</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="d4ca6fbb7f638a8b6b39592979f862bfb9bd67d1" translate="yes" xml:space="preserve">
          <source>J. Nick Koston &amp;lt;nick@cpanel.net&amp;gt;</source>
          <target state="translated">J. Nick Koston &amp;lt;nick@cpanel.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="0769e7614be3e4e1822db4f1f3c8b1ae2f3201ca" translate="yes" xml:space="preserve">
          <source>JAPH</source>
          <target state="translated">JAPH</target>
        </trans-unit>
        <trans-unit id="d7060e173c0374cb8eae482e18306d094b4a274a" translate="yes" xml:space="preserve">
          <source>JAPH stands for &quot;Just another Perl hacker,&quot;, which Randal Schwartz used to sign email and usenet messages starting in the late 1980s. He previously used the phrase with many subjects (&quot;Just another x hacker,&quot;), so to distinguish his JAPH, he started to write them as Perl programs:</source>
          <target state="translated">JAPHは &quot;Just another Perl hacker &quot;の略で、1980年代後半からランダル・シュワルツがメールやユーズネットのメッセージに署名するのに使っていた言葉です。彼は以前、このフレーズを多くの題材(&quot;Just another x hacker,&quot;)で使っていたので、JAPHを区別するためにPerlのプログラムとして書き始めました。</target>
        </trans-unit>
        <trans-unit id="7f3a84b51622bff154d5971f3af29fa8785e389f" translate="yes" xml:space="preserve">
          <source>JIS has not endorsed the full Microsoft standard however. The official &lt;code&gt;Shift_JIS&lt;/code&gt; includes only JIS X 0201 and JIS X 0208 character sets, while Microsoft has always used &lt;code&gt;Shift_JIS&lt;/code&gt; to encode a wider character repertoire. See &lt;code&gt;IANA&lt;/code&gt; registration for &lt;code&gt;Windows-31J&lt;/code&gt;.</source>
          <target state="translated">ただし、JISは完全なMicrosoft標準を承認していません。公式の &lt;code&gt;Shift_JIS&lt;/code&gt; にはJISX0201とJISX 0208の文字セットのみが含まれていますが、Microsoftは常に &lt;code&gt;Shift_JIS&lt;/code&gt; を使用してより幅広い文字レパートリーをエンコードしています。 &lt;code&gt;Windows-31J&lt;/code&gt; の &lt;code&gt;IANA&lt;/code&gt; 登録を参照してください。</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="ab81c25e1d8756ce41a1d0bd153f8a1a9cd26516" translate="yes" xml:space="preserve">
          <source>JSON -&amp;gt; PERL</source>
          <target state="translated">JSON -&amp;gt; PERL</target>
        </trans-unit>
        <trans-unit id="085bf9967f7db3a1e36f211bc12e97fc9c8726e2" translate="yes" xml:space="preserve">
          <source>JSON object. If that is successful, it will return this object, otherwise it will return &lt;code&gt;undef&lt;/code&gt;. If there is a parse error, this method will croak just as &lt;code&gt;decode&lt;/code&gt; would do (one can then use &lt;code&gt;incr_skip&lt;/code&gt; to skip the erroneous part). This is the most common way of using the method.</source>
          <target state="translated">JSONオブジェクト。それが成功した場合は、このオブジェクトを返し &lt;code&gt;undef&lt;/code&gt; 。それ以外の場合は、undefを返します。解析エラーがある場合、このメソッドは &lt;code&gt;decode&lt;/code&gt; と同じように &lt;code&gt;incr_skip&lt;/code&gt; します（その後、incr_skipを使用してエラーのある部分をスキップできます）。これは、この方法を使用する最も一般的な方法です。</target>
        </trans-unit>
        <trans-unit id="0ca97a1ee6b474fcf8884b628a790828e390c7d4" translate="yes" xml:space="preserve">
          <source>JSON, &lt;a href=&quot;http://json.org/&quot;&gt;http://json.org/&lt;/a&gt;</source>
          <target state="translated">JSON, &lt;a href=&quot;http://json.org/&quot;&gt;http://json.org/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74c9214a804f5e0bb364aa23a074ce1bb72d3b90" translate="yes" xml:space="preserve">
          <source>JSON::PP</source>
          <target state="translated">JSON::PP</target>
        </trans-unit>
        <trans-unit id="bc2d16fc45f4fb15b4bd4ac1aaf8b68aeeba40dd" translate="yes" xml:space="preserve">
          <source>JSON::PP (and JSON::XS) trusts what you pass to &lt;code&gt;encode&lt;/code&gt; method (or &lt;code&gt;encode_json&lt;/code&gt; function) is a clean, validated data structure with values that can be represented as valid JSON values only, because it's not from an external data source (as opposed to JSON texts you pass to &lt;code&gt;decode&lt;/code&gt; or &lt;code&gt;decode_json&lt;/code&gt;, which JSON::PP considers tainted and doesn't trust). As JSON::PP doesn't know exactly what you and consumers of your JSON texts want the unexpected values to be (you may want to convert them into null, or to stringify them with or without normalisation (string representation of infinities/NaN may vary depending on platforms), or to croak without conversion), you're advised to do what you and your consumers need before you encode, and also not to numify values that may start with values that look like a number (including infinities/NaN), without validating.</source>
          <target state="translated">JSON :: PP（およびJSON :: XS）は、 &lt;code&gt;encode&lt;/code&gt; メソッド（または &lt;code&gt;encode_json&lt;/code&gt; 関数）に渡すものを信頼します。これは、外部データソースからのものではないため、有効なJSON値としてのみ表すことができる値を持つクリーンで検証済みのデータ構造です。 （ &lt;code&gt;decode&lt;/code&gt; または &lt;code&gt;decode_json&lt;/code&gt; に渡すJSONテキストとは対照的、JSON :: PPは汚染されていると見なし、信頼しません）。JSON :: PPは、JSONテキストのユーザーとコンシューマーが予期しない値をどのように望んでいるかを正確に認識していないため（nullに変換するか、正規化の有無にかかわらず文字列化することができます（無限大の文字列表現/ NaNプラットフォームによって異なります）、または変換せずに鳴く）、エンコードする前にあなたとあなたの消費者が必要とすることを行うことをお勧めします。また、数字のように見える値（無限大/ NaNを含む）で始まる可能性のある値を数値化しないことをお勧めします）、検証せずに。</target>
        </trans-unit>
        <trans-unit id="67000e5008a49c5764c9853d27cf57eee1416888" translate="yes" xml:space="preserve">
          <source>JSON::PP - JSON::XS compatible pure-Perl module.</source>
          <target state="translated">JSON::PP-JSON::XS 互換の純粋な Perl モジュール。</target>
        </trans-unit>
        <trans-unit id="9a6a29e642ee039fc28b8f131cabd5029d088849" translate="yes" xml:space="preserve">
          <source>JSON::PP has been in the Perl core since Perl 5.14, mainly for CPAN toolchain modules to parse META.json.</source>
          <target state="translated">JSON::PPはPerl 5.14からPerlコアにあり、主にMETA.jsonを解析するCPANツールチェーンモジュールのためのものです。</target>
        </trans-unit>
        <trans-unit id="1aaa45ea1b22edf7987707428a94f3b9ee14d933" translate="yes" xml:space="preserve">
          <source>JSON::PP is a pure perl JSON decoder/encoder, and (almost) compatible to much faster &lt;a href=&quot;JSON::XS&quot;&gt;JSON::XS&lt;/a&gt; written by Marc Lehmann in C. JSON::PP works as a fallback module when you use &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; module without having installed JSON::XS.</source>
          <target state="translated">JSON :: PPは純粋なperlJSONデコーダー/エンコーダーであり、MarcLehmannがCで記述したはるかに高速な&lt;a href=&quot;JSON::XS&quot;&gt;JSON :: XS&lt;/a&gt;と（ほぼ）互換性があります。JSON:: PPは、JSONをインストールせずに&lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt;モジュールを使用する場合、フォールバックモジュールとして機能します。 :: XS。</target>
        </trans-unit>
        <trans-unit id="1a1d3eff2890dd7bf9ac851e6d34ec3c432fa2a0" translate="yes" xml:space="preserve">
          <source>JSON::PP will only attempt to parse the JSON text once it is sure it has enough text to get a decisive result, using a very simple but truly incremental parser. This means that it sometimes won't stop as early as the full parser, for example, it doesn't detect mismatched parentheses. The only thing it guarantees is that it starts decoding as soon as a syntactically valid JSON text has been seen. This means you need to set resource limits (e.g. &lt;code&gt;max_size&lt;/code&gt;) to ensure the parser will stop parsing in the presence if syntax errors.</source>
          <target state="translated">JSON :: PPは、非常に単純ですが真にインクリメンタルなパーサーを使用して、決定的な結果を得るのに十分なテキストがあることが確認された場合にのみ、JSONテキストの解析を試みます。これは、完全なパーサーのように早く停止しない場合があることを意味します。たとえば、不一致の括弧は検出されません。それが保証する唯一のことは、構文的に有効なJSONテキストが見られるとすぐにデコードを開始することです。これは、構文エラーが発生した場合にパーサーが解析を停止するように、リソース制限（ &lt;code&gt;max_size&lt;/code&gt; など）を設定する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="4762c702bf2677205442e48ee83f7fae4356feaa" translate="yes" xml:space="preserve">
          <source>JSON::PP::Boolean</source>
          <target state="translated">JSON::PP::Boolean</target>
        </trans-unit>
        <trans-unit id="65c4433f9da239d7a8e60b68a81d180683b869c9" translate="yes" xml:space="preserve">
          <source>JSON::PP::Boolean - dummy module providing JSON::PP::Boolean</source>
          <target state="translated">JSON::PP::Boolean-JSON::PP::Boolean を提供するダミーモジュール</target>
        </trans-unit>
        <trans-unit id="d6a48e124df6419ac5c2d9d111fda43bf7f4a2ad" translate="yes" xml:space="preserve">
          <source>JSON::PP::is_bool</source>
          <target state="translated">JSON::PP::is_bool</target>
        </trans-unit>
        <trans-unit id="3dbefab7107beb14a9168d002d27c476d9979a2f" translate="yes" xml:space="preserve">
          <source>JSON::PP::null</source>
          <target state="translated">JSON::PP::null</target>
        </trans-unit>
        <trans-unit id="d245a16cb70b0da2f6ce2e1cc1b15f6f0108705d" translate="yes" xml:space="preserve">
          <source>JSON::PP::true, JSON::PP::false</source>
          <target state="translated">JSON::PP::true,JSON::PP::false</target>
        </trans-unit>
        <trans-unit id="dced2aceecfe6edc6c5082affb4adef03ec116d9" translate="yes" xml:space="preserve">
          <source>JSON::XS compatible pure-Perl module.</source>
          <target state="translated">JSON::XS 互換の純粋な Perl モジュール。</target>
        </trans-unit>
        <trans-unit id="67cff807001c7900c13019d99056e3c2c5564617" translate="yes" xml:space="preserve">
          <source>JSON::XS indents with three spaces when you &lt;code&gt;encode&lt;/code&gt; (if requested by &lt;code&gt;indent&lt;/code&gt; or &lt;code&gt;pretty&lt;/code&gt;), and the number cannot be changed. JSON::PP allows you to change/get the number of indent spaces with these mutator/accessor. The default number of spaces is three (the same as JSON::XS), and the acceptable range is from &lt;code&gt;0&lt;/code&gt; (no indentation; it'd be better to disable indentation by &lt;code&gt;indent(0)&lt;/code&gt;) to &lt;code&gt;15&lt;/code&gt;.</source>
          <target state="translated">JSON :: XSは、 &lt;code&gt;encode&lt;/code&gt; 時に3つのスペースでインデントし（ &lt;code&gt;indent&lt;/code&gt; または &lt;code&gt;pretty&lt;/code&gt; 要求された場合）、番号は変更できません。JSON :: PPを使用すると、これらのミューテーター/アクセサーを使用してインデントスペースの数を変更/取得できます。デフォルトのスペース数は3（JSON :: XSと同じ）で、許容範囲は &lt;code&gt;0&lt;/code&gt; （インデントなし &lt;code&gt;indent(0)&lt;/code&gt; によるインデントを無効にすることをお勧めします）から &lt;code&gt;15&lt;/code&gt; までです。</target>
        </trans-unit>
        <trans-unit id="b0eeebe1b8d9c88c3dd6a874baff7c46254de947" translate="yes" xml:space="preserve">
          <source>Jacinta Richardson for translating much of my ideas into this documentation.</source>
          <target state="translated">ジャシンタ・リチャードソンは、私のアイデアの多くをこの文書に翻訳してくれました。</target>
        </trans-unit>
        <trans-unit id="46ed50c6d4c26a90edb32bb01d8d5b13b356d708" translate="yes" xml:space="preserve">
          <source>James E Keenan &amp;lt;</source>
          <target state="translated">ジェームズEキーナン&amp;lt;</target>
        </trans-unit>
        <trans-unit id="cc167be5863c0fa54ff8e14b6cf90200815632fb" translate="yes" xml:space="preserve">
          <source>James E. Keenan</source>
          <target state="translated">ジェームズ・E・キーナン</target>
        </trans-unit>
        <trans-unit id="fad8357eef2bb53d17336573edc650a4cf157cf3" translate="yes" xml:space="preserve">
          <source>James E. Keenan &amp;lt;jkeen@verizon.net&amp;gt;</source>
          <target state="translated">ジェームズE.キーナン&amp;lt;jkeen@verizon.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="57cf1bbb2770fa0d885d542ddaca96bfea96011e" translate="yes" xml:space="preserve">
          <source>James Keenan, &amp;lt;jkeenan@cpan.org&amp;gt;</source>
          <target state="translated">James Keenan、&amp;lt;jkeenan@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="2c916c2a6f4627fbe67be340b96ec2857597184a" translate="yes" xml:space="preserve">
          <source>James Raspass &amp;lt;jraspass@gmail.com&amp;gt;</source>
          <target state="translated">James Raspass &amp;lt;jraspass@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="75e4cd2d086a80816fd0c59891fecee24ad1a4c4" translate="yes" xml:space="preserve">
          <source>Jamo_Short_Name</source>
          <target state="translated">Jamo_Short_Name</target>
        </trans-unit>
        <trans-unit id="dc05d77338b63072590a6f49b15e48ec83a7bd95" translate="yes" xml:space="preserve">
          <source>Jan Dubois &amp;lt;jand@activestate.com&amp;gt;</source>
          <target state="translated">Jan Dubois &amp;lt;jand@activestate.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="fcf29f6cad3232704b33e962ef5194fad3b6817b" translate="yes" xml:space="preserve">
          <source>Japan</source>
          <target state="translated">Japan</target>
        </trans-unit>
        <trans-unit id="6ce48d285e726d9be92e6bf68e171d9553e0896e" translate="yes" xml:space="preserve">
          <source>Japanese Encodings</source>
          <target state="translated">日本語エンコード</target>
        </trans-unit>
        <trans-unit id="f0fae5d9347791c2b844b690a046bfe7552e453c" translate="yes" xml:space="preserve">
          <source>Japheth Cleaver added the bits to allow a forced install (-f).</source>
          <target state="translated">Japheth Cleaver さんが強制インストール (-f)を可能にするためのビットを追加しました。</target>
        </trans-unit>
        <trans-unit id="bd6422bf1002562f4885ccb3e7c11949b9fc2f34" translate="yes" xml:space="preserve">
          <source>Japheth Cleaver added the bits to allow a forced install (&lt;code&gt;-f&lt;/code&gt;).</source>
          <target state="translated">Japheth Cleaverは、強制インストールを可能にするビットを追加しました（ &lt;code&gt;-f&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ff7b561acfebbb2aad1864ab89f7d4e5285c6e22" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi</source>
          <target state="translated">ヤルコ・ヒエタニエミ</target>
        </trans-unit>
        <trans-unit id="a9a4e186a4a793bc3fef06e8162fa8ae0f705095" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi &amp;lt;</source>
          <target state="translated">ヤルコ・ヒエタニエミ&amp;lt;</target>
        </trans-unit>
        <trans-unit id="13ce73395e162a5533c6ace927e40c80d2cab8fd" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt;</source>
          <target state="translated">ヤルコヒエタニエミ&amp;lt;jhi@iki.fi&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7adef0fede1e52584837e3b9fe09cbb854d77894" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt; Bryan Logan &amp;lt;bryanlog@us.ibm.com&amp;gt; David Larson &amp;lt;larson1@us.ibm.com&amp;gt;</source>
          <target state="translated">Jarkko Hietaniemi &amp;lt;jhi@iki.fi&amp;gt; Bryan Logan &amp;lt;bryanlog@us.ibm.com&amp;gt; David Larson &amp;lt;larson1@us.ibm.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="276f92ff10492dd51e70f45871039bf3b88b6a4b" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi's original</source>
          <target state="translated">ヤルコ・ヒエタニエミのオリジナル</target>
        </trans-unit>
        <trans-unit id="04cfea13773f0ae1b7ac40ccd517f43dc7dcdad4" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi, &amp;lt;jhi@hut.fi&amp;gt;</source>
          <target state="translated">Jarkko Hietaniemi、&amp;lt;jhi@hut.fi&amp;gt;</target>
        </trans-unit>
        <trans-unit id="c6f1f3b8aba1c1fb078ca69f70f0d3a32db2b05e" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi, &amp;lt;jhi@hut.fi&amp;gt;. Now maintained by Perl 5 porters.</source>
          <target state="translated">Jarkko Hietaniemi、&amp;lt;jhi@hut.fi&amp;gt;。現在、Perl5ポーターによって保守されています。</target>
        </trans-unit>
        <trans-unit id="0bc2a5e3ff31736b8a57665e048886c573a122f3" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi, conversion into libnetcfg for inclusion into Perl 5.8.</source>
          <target state="translated">Jarkko Hietaniemi,Perl 5.8に含めるためのlibnetcfgへの変換。</target>
        </trans-unit>
        <trans-unit id="692b885ac0ff146816113cee07c7dfe2ef0ba0a4" translate="yes" xml:space="preserve">
          <source>Jarkko Hietaniemi. Now maintained by perl5 porters.</source>
          <target state="translated">Jarkko Hietaniemi。現在は perl5 ポータによってメンテナンスされています。</target>
        </trans-unit>
        <trans-unit id="f0bc884e41c8e0399ef072f3aad2d67eaa7fd5aa" translate="yes" xml:space="preserve">
          <source>JavaScript Traps</source>
          <target state="translated">JavaScriptのトラップ</target>
        </trans-unit>
        <trans-unit id="f2ef0f46c9cd103d2be6f2673d4379b347904df1" translate="yes" xml:space="preserve">
          <source>Jean Delvare provided the following table of different common terminal emulators and their support for the various attributes and others have helped me flesh it out:</source>
          <target state="translated">Jean Delvare氏は、様々な一般的なターミナルエミュレータとそのサポートする様々な属性の表を提供してくれました。</target>
        </trans-unit>
        <trans-unit id="27f5b59f8afefe05a200ff5c9949b24e5ca9ea36" translate="yes" xml:space="preserve">
          <source>Jed</source>
          <target state="translated">Jed</target>
        </trans-unit>
        <trans-unit id="b63c65e75871d5c7820e4ea10cfd70f390f74d22" translate="yes" xml:space="preserve">
          <source>Jeff Okamoto &amp;lt;</source>
          <target state="translated">ジェフ・オカモト&amp;lt;</target>
        </trans-unit>
        <trans-unit id="7ec7c5d4610b8dd06ad086eed7d40f5d2aaef1a6" translate="yes" xml:space="preserve">
          <source>Jeff Okamoto, Tim Bunce, Nick Gianniotis, Steve Kelem, Gurusamy Sarathy and Larry Wall.</source>
          <target state="translated">ジェフ・オカモト、ティム・バンス、ニック・ジャンニオティス、スティーブ・ケレム、グルサミー・サラシー、ラリー・ウォール。</target>
        </trans-unit>
        <trans-unit id="2425ad3a84d8960ab9c2915a943fd7e28d7c0291" translate="yes" xml:space="preserve">
          <source>Jeremy Mates &amp;lt;jmates@cpan.org&amp;gt;</source>
          <target state="translated">ジェレミーメイツ&amp;lt;jmates@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="52232653f25fa8c0538602bfc7945ebf9d9b79a7" translate="yes" xml:space="preserve">
          <source>Jerry D. Hedden &amp;lt;jdhedden@cpan.org&amp;gt;</source>
          <target state="translated">Jerry D. Hedden &amp;lt;jdhedden@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b3a656e0d05c4ded5764e8eee0b16063f85446f7" translate="yes" xml:space="preserve">
          <source>Jerry D. Hedden and Reini Urban provided greatly appreciated help to debug and polish &lt;code&gt;Sys::Syslog&lt;/code&gt; under Cygwin.</source>
          <target state="translated">Jerry D. HeddenとReini Urbanは、Cygwinの下で &lt;code&gt;Sys::Syslog&lt;/code&gt; をデバッグおよび洗練するための非常に有望な支援を提供しました。</target>
        </trans-unit>
        <trans-unit id="1a3cecc43a5465fa758b4f88b43cd646e6623b8f" translate="yes" xml:space="preserve">
          <source>Jerry D. Hedden, &amp;lt;jdhedden AT cpan DOT org&amp;gt;</source>
          <target state="translated">Jerry D. Hedden、&amp;lt;jdhedden AT cpan DOT org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e5109d5f0b8672892d9cf43511b2568ff7ce2637" translate="yes" xml:space="preserve">
          <source>Jerry Gay</source>
          <target state="translated">ジェリー・ゲイ</target>
        </trans-unit>
        <trans-unit id="0e7ad312b85f19c8a09454b49798a0382227aa86" translate="yes" xml:space="preserve">
          <source>Jess Robinson &amp;lt;castaway@desert-island.me.uk&amp;gt;</source>
          <target state="translated">ジェス・ロビンソン&amp;lt;castaway@desert-island.me.uk&amp;gt;</target>
        </trans-unit>
        <trans-unit id="a7f1b3fc35d7e705b8692294a866fb025bdc15b4" translate="yes" xml:space="preserve">
          <source>Jim Brandt suggest and provided the initial implementation for the up-to-date and Changes features.</source>
          <target state="translated">Jim Brandtは、最新の機能と変更機能のための初期実装を提案し、提供しました。</target>
        </trans-unit>
        <trans-unit id="549b2243ef15345835dfd4eb22ac64d2df0ea3a8" translate="yes" xml:space="preserve">
          <source>Jim Keenan fixed up various issues with _download</source>
          <target state="translated">Jim Keenan は _download の様々な問題を修正しました。</target>
        </trans-unit>
        <trans-unit id="ef645dbc725c293373ed9661992798b416e9b9b4" translate="yes" xml:space="preserve">
          <source>Joe Smith &amp;lt;Joe.Smith@inwap.com&amp;gt;, using the framework created by Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;.</source>
          <target state="translated">Joe Smith &amp;lt;Joe.Smith@inwap.com&amp;gt;、Russ Allbery &amp;lt;rra@stanford.edu&amp;gt;によって作成されたフレームワークを使用。</target>
        </trans-unit>
        <trans-unit id="c865a479b23a538482933eec4ec96a06755b572a" translate="yes" xml:space="preserve">
          <source>Johan Vromans &amp;lt;jvromans@squirrel.nl&amp;gt;</source>
          <target state="translated">ヨハン・ブロマンス&amp;lt;jvromans@squirrel.nl&amp;gt;</target>
        </trans-unit>
        <trans-unit id="183447aad929b68cdb9a4bc6a0988222e172d912" translate="yes" xml:space="preserve">
          <source>Johan Vromans &amp;lt;jvromans@squirrel.nl&amp;gt; H. Merijn Brand &amp;lt;h.m.brand@xs4all.nl&amp;gt;</source>
          <target state="translated">Johan Vromans &amp;lt;jvromans@squirrel.nl&amp;gt; H. Merijn Brand &amp;lt;h.m.brand@xs4all.nl&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d401e67bf973d127449e78a2dab7a6e33bf82ed1" translate="yes" xml:space="preserve">
          <source>John Lightsey &amp;lt;</source>
          <target state="translated">ジョン・ライトジー&amp;lt;</target>
        </trans-unit>
        <trans-unit id="a93554073e2a9ef40605d8eff344dac817dfa1a9" translate="yes" xml:space="preserve">
          <source>John Peacock &amp;lt;jpeacock@cpan.org&amp;gt;</source>
          <target state="translated">ジョン・ピーコック&amp;lt;jpeacock@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="bdfcbe7345fa5c91aff66147710f3cfd01971e09" translate="yes" xml:space="preserve">
          <source>Joins the separate strings of LIST into a single string with fields separated by the value of EXPR, and returns that new string. Example:</source>
          <target state="translated">LISTの別々の文字列を、EXPRの値でフィールドを区切った単一の文字列に結合し、その新しい文字列を返します。例。</target>
        </trans-unit>
        <trans-unit id="8701a18a17d809f2f5e1d9461286d81392c749a1" translate="yes" xml:space="preserve">
          <source>Jon Orwant</source>
          <target state="translated">ジョン・オルワント</target>
        </trans-unit>
        <trans-unit id="9535723b8f84ea59122230a47649084f0880997b" translate="yes" xml:space="preserve">
          <source>Jon Orwant &amp;lt;</source>
          <target state="translated">ジョン・オーワント&amp;lt;</target>
        </trans-unit>
        <trans-unit id="e683318ce5a68c3c49c2481778c7d3eb5187cf39" translate="yes" xml:space="preserve">
          <source>Jonas B. Nielsen &amp;lt;jonasbn@hoarfrost.local&amp;gt;</source>
          <target state="translated">Jonas B. Nielsen &amp;lt;jonasbn@hoarfrost.local&amp;gt;</target>
        </trans-unit>
        <trans-unit id="77b947fc83a952d44b7572b1e1134cb1af54db24" translate="yes" xml:space="preserve">
          <source>Josh Jore &amp;lt;jjore@cpan.org&amp;gt;</source>
          <target state="translated">Josh Jore &amp;lt;jjore@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ddc19f76e720fe5e2b005501ad08de9eb7175b61" translate="yes" xml:space="preserve">
          <source>Joshua Chamas's Tie::Cache module may be useful as an expiration manager. (If you try this, let me know how it works out.)</source>
          <target state="translated">Joshua ChamasのTie::Cacheモジュールは、期限切れマネージャーとして便利かもしれません。(試してみたら、どうやってうまくいくか教えてください)。</target>
        </trans-unit>
        <trans-unit id="272f944afb073e466e447521f217853887659759" translate="yes" xml:space="preserve">
          <source>Joshua ben Jore &amp;lt;jjore@cpan.org&amp;gt;</source>
          <target state="translated">Joshua ben Jore &amp;lt;jjore@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f8f06875505d336c6444e4ca735af60cc7f95b69" translate="yes" xml:space="preserve">
          <source>Judicious JavaScript programmers should take note of the following:</source>
          <target state="translated">悪意のあるJavaScriptプログラマーは、以下の点に注意してください。</target>
        </trans-unit>
        <trans-unit id="829558e61eb4ee30d56d5ca3997b5726751317c0" translate="yes" xml:space="preserve">
          <source>Juerd Waalboer &amp;lt;#####@juerd.nl&amp;gt;</source>
          <target state="translated">Juerd Waalboer &amp;lt;##### @ juerd.nl&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d89d24d0ba5d206a7a244711764b4287f3aa5c8f" translate="yes" xml:space="preserve">
          <source>Juerd Waalboer &amp;lt;#####@juerd.nl&amp;gt;, with the help of many Perl Monks.</source>
          <target state="translated">Juerd Waalboer &amp;lt;##### @ juerd.nl&amp;gt;、多くのPerlモンクの助けを借りて。</target>
        </trans-unit>
        <trans-unit id="bd209361669e6039e2d46925b98964270ec9db84" translate="yes" xml:space="preserve">
          <source>July 26, 2005</source>
          <target state="translated">2005年7月26日</target>
        </trans-unit>
        <trans-unit id="2b31aa739648b445f7448224142630d141a4270e" translate="yes" xml:space="preserve">
          <source>June 12, 2007</source>
          <target state="translated">2007年6月12日</target>
        </trans-unit>
        <trans-unit id="99a23786af78acf626cd4573fa13a06ed0180b91" translate="yes" xml:space="preserve">
          <source>June 2008</source>
          <target state="translated">2008年6月</target>
        </trans-unit>
        <trans-unit id="76d4e067e5679c035c82b3463849e985c82217de" translate="yes" xml:space="preserve">
          <source>June 2017, for Synology DSM 5.1.5022 and DSM 6.1-15101-4.</source>
          <target state="translated">2017年6月、Synology DSM 5.1.5022およびDSM 6.1-15101-4用。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
