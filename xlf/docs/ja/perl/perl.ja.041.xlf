<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="d8b84d36cdfd8993b5da988b0d1072e922c4f772" translate="yes" xml:space="preserve">
          <source>The distribution metadata for a CPAN dist</source>
          <target state="translated">CPAN distのディストリビューションメタデータ</target>
        </trans-unit>
        <trans-unit id="36683b868091d21c8930b291476202549c6dcddb" translate="yes" xml:space="preserve">
          <source>The distribution of a bundle should follow the same convention as other distributions.</source>
          <target state="translated">束の分布は、他の分布と同じ規則に従うべきです。</target>
        </trans-unit>
        <trans-unit id="51432e8130a916aea0132035b34ce241b04f9cf8" translate="yes" xml:space="preserve">
          <source>The distroprefs system of &lt;code&gt;CPAN.pm&lt;/code&gt; addresses this problem by allowing the user to specify extra informations and recipes in YAML files to either</source>
          <target state="translated">distroprefsシステム &lt;code&gt;CPAN.pm&lt;/code&gt; は、どちらかにYAMLファイルに余分な情報やレシピを指定することを可能にすることにより、この問題に対処します</target>
        </trans-unit>
        <trans-unit id="593a274a7d2141476dcb8b11db34f2f4536141e3" translate="yes" xml:space="preserve">
          <source>The division (/) and the following functions</source>
          <target state="translated">除算(/)と以下の機能</target>
        </trans-unit>
        <trans-unit id="863f717363dbe8d220d352a111c6c709f1a560be" translate="yes" xml:space="preserve">
          <source>The djgpp environment for DOS, &lt;a href=&quot;http://www.delorie.com/djgpp/&quot;&gt;http://www.delorie.com/djgpp/&lt;/a&gt; and &lt;a href=&quot;perldos&quot;&gt;perldos&lt;/a&gt;.</source>
          <target state="translated">DOS、&lt;a href=&quot;http://www.delorie.com/djgpp/&quot;&gt;http：&lt;/a&gt;&lt;a href=&quot;perldos&quot;&gt;//www.delorie.com/djgpp/&lt;/a&gt;およびperldosのdjgpp環境。</target>
        </trans-unit>
        <trans-unit id="02d01132aeec36ca260315fce03b39bb29168535" translate="yes" xml:space="preserve">
          <source>The do-or-die equivalents are set up simply by calling Fatal's &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; routine, passing it the names of the functions to be replaced. You may wrap both user-defined functions and overridable CORE operators (except &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, or any other built-in that cannot be expressed via prototypes) in this way.</source>
          <target state="translated">Do-or-Dieの同等機能は、Fatalの &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ルーチンを呼び出して、置き換える関数の名前を渡すだけで設定されます。このようにして、ユーザー定義関数とオーバーライド可能なCORE演算子（ &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、またはプロトタイプでは表現できないその他の組み込み関数を除く）の両方をラップできます。</target>
        </trans-unit>
        <trans-unit id="467707c3656000f994482e7ea5cafe87685ee6c8" translate="yes" xml:space="preserve">
          <source>The documentation for the Perl API explains what some of the internal functions do, as well as the many macros used in the source.</source>
          <target state="translated">Perl API のドキュメントでは、内部関数のいくつかが何をするのか、ソースで使用されている多くのマクロと同様に説明されています。</target>
        </trans-unit>
        <trans-unit id="fae102196b6b483518d27e0d97d3595cd35f7b66" translate="yes" xml:space="preserve">
          <source>The dot</source>
          <target state="translated">ドット</target>
        </trans-unit>
        <trans-unit id="3f38f6b4980cd9d2e94100bc5fdda9f827f655ac" translate="yes" xml:space="preserve">
          <source>The dot (or period), &lt;code&gt;.&lt;/code&gt; is probably the most used, and certainly the most well-known character class. By default, a dot matches any character, except for the newline. That default can be changed to add matching the newline by using the</source>
          <target state="translated">ドット（ピリオド）、 &lt;code&gt;.&lt;/code&gt; おそらく最もよく使われ、確かに最もよく知られている文字クラスです。デフォルトでは、ドットは改行を除くすべての文字と一致します。このデフォルトを変更して、改行に一致する行を追加することができます。</target>
        </trans-unit>
        <trans-unit id="a8d050074e0d8db225e0ced36924986b2d59e591" translate="yes" xml:space="preserve">
          <source>The dynamic nature of the regular expression variables means that their value is limited to the block that they are in, as demonstrated by this bit of code:</source>
          <target state="translated">正規表現変数の動的な性質は、その値がその中にあるブロックに限定されることを意味します。</target>
        </trans-unit>
        <trans-unit id="4214b1d60eaaef0d8bb7337abe8a20ad57121d02" translate="yes" xml:space="preserve">
          <source>The earliest development of &lt;code&gt;newgetopt.pl&lt;/code&gt; started in 1990, with Perl version 4. As a result, its development, and the development of Getopt::Long, has gone through several stages. Since backward compatibility has always been extremely important, the current version of Getopt::Long still supports a lot of constructs that nowadays are no longer necessary or otherwise unwanted. This section describes briefly some of these 'features'.</source>
          <target state="translated">&lt;code&gt;newgetopt.pl&lt;/code&gt; の最も初期の開発は1990年にPerlバージョン4で始まりました。その結果、その開発とGetopt :: Longの開発はいくつかの段階を経てきました。下位互換性は常に非常に重要であるので、Getopt :: Longの現在のバージョンは、現在ではもはや必要でないか、そうでなければ望ましくない多くの構成をサポートしています。このセクションでは、これらの「機能」のいくつかについて簡単に説明します。</target>
        </trans-unit>
        <trans-unit id="a629fbdcc51d0664a749c16709dba8d145f34d93" translate="yes" xml:space="preserve">
          <source>The easier it is to reproduce your bug, the more likely it will be fixed -- if nobody can duplicate your problem, it probably won't be addressed.</source>
          <target state="translated">バグの再現が容易であればあるほど、修正される可能性が高くなります。</target>
        </trans-unit>
        <trans-unit id="a0f603eb4b75174f5f5f8c92980d04d40846be1f" translate="yes" xml:space="preserve">
          <source>The easier it is to understand a reproducible bug, the more likely it will be fixed. Any insight you can provide into the problem will help a great deal. In other words, try to analyze the problem (to the extent you can) and report your discoveries.</source>
          <target state="translated">再現可能なバグを理解するのが簡単であればあるほど、それが修正される可能性が高くなります。その問題についてあなたが提供できる洞察力があれば、大きな助けになるでしょう。言い換えれば、(できる範囲で)問題を分析し、発見したことを報告するようにしてください。</target>
        </trans-unit>
        <trans-unit id="affd4579291392539b898984b2d64fdfbc46e13c" translate="yes" xml:space="preserve">
          <source>The easiest and most portable option available for creating your own source filter is to write it completely in Perl. To distinguish this from the previous two techniques, I'll call it a Perl source filter.</source>
          <target state="translated">独自のソースフィルタを作成するための最も簡単で移植性の高い方法は、完全に Perl で書くことです。前の二つのテクニックと区別するために、これを Perl ソースフィルタと呼ぶことにします。</target>
        </trans-unit>
        <trans-unit id="74aa13205a264868ad41eb543a1a088589f0736a" translate="yes" xml:space="preserve">
          <source>The easiest conceptual solution is to count the lines in the file then start at the beginning and print the number of lines (minus the last N) to a new file.</source>
          <target state="translated">最も簡単な概念的な解決策は、ファイルの行数を数えて、最初から始めて、行数(最後のNを引いたもの)を新しいファイルに印刷することです。</target>
        </trans-unit>
        <trans-unit id="06308af6d2242e4fa49dd6cd28115c9993df529e" translate="yes" xml:space="preserve">
          <source>The easiest way is to have a module also named CPAN do it for you by using the &lt;code&gt;cpan&lt;/code&gt; command that comes with Perl. You can give it a list of modules to install:</source>
          <target state="translated">最も簡単な方法は、CPANという名前のモジュールに、Perlに付属の &lt;code&gt;cpan&lt;/code&gt; コマンドを使用して実行させることです。インストールするモジュールのリストを与えることができます：</target>
        </trans-unit>
        <trans-unit id="50ecd0af899536563eb76ce8a93b28def2b41789" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is to read a key in nonblocking mode with the &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, passing it an argument of -1 to indicate not to block:</source>
          <target state="translated">これを行う最も簡単な方法は、CPANから&lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt;モジュールを使用して非ブロックモードでキーを読み取り、-1の引数を渡してブロックしないことを示すことです。</target>
        </trans-unit>
        <trans-unit id="8ab82d3c686ea0162144c8d6cfd2e56593a5e530" translate="yes" xml:space="preserve">
          <source>The easiest way to examine the op tree is to stop Perl after it has finished parsing, and get it to dump out the tree. This is exactly what the compiler backends &lt;a href=&quot;b/terse&quot;&gt;B::Terse&lt;/a&gt;, &lt;a href=&quot;b/concise&quot;&gt;B::Concise&lt;/a&gt; and &lt;a href=&quot;b/debug&quot;&gt;B::Debug&lt;/a&gt; do.</source>
          <target state="translated">opツリーを調べる最も簡単な方法は、Perlが解析を完了した後にPerlを停止し、Perlにツリーをダンプさせることです。これは、コンパイラバックエンド&lt;a href=&quot;b/terse&quot;&gt;B :: Terse&lt;/a&gt;、&lt;a href=&quot;b/concise&quot;&gt;B :: Concise&lt;/a&gt;、および&lt;a href=&quot;b/debug&quot;&gt;B :: Debugが&lt;/a&gt;行うこととまったく同じです。</target>
        </trans-unit>
        <trans-unit id="e420b4167196d87c0672e2ec36244ffaaeacf17d" translate="yes" xml:space="preserve">
          <source>The easiest way to get a template set of macros to use is by specifying the &lt;code&gt;-g&lt;/code&gt; (&lt;code&gt;--global&lt;/code&gt; ) option with h2xs (see &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;).</source>
          <target state="translated">使用するマクロのテンプレートセットを取得する最も簡単な方法は、指定してある &lt;code&gt;-g&lt;/code&gt; （ &lt;code&gt;--global&lt;/code&gt; h2xs（参照して）オプションを&lt;a href=&quot;h2xs&quot;&gt;h2xsを&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="40c9c21dcd497445970db52d8583cffea3bdb68e" translate="yes" xml:space="preserve">
          <source>The easiest way to specify an individual typable character is to enclose it in brackets:</source>
          <target state="translated">個々のタイプ可能な文字を指定する最も簡単な方法は、それを括弧で囲むことです。</target>
        </trans-unit>
        <trans-unit id="61b4571e42b1eb8646fcc517dc4040a5571233f2" translate="yes" xml:space="preserve">
          <source>The easiest way to tell if a subroutine was inlined is by using &lt;a href=&quot;b/deparse&quot;&gt;B::Deparse&lt;/a&gt;. Consider this example of two subroutines returning &lt;code&gt;1&lt;/code&gt; , one with a &lt;code&gt;()&lt;/code&gt; prototype causing it to be inlined, and one without (with deparse output truncated for clarity):</source>
          <target state="translated">サブルーチンがインライン化されたかどうかを確認する最も簡単な方法は、&lt;a href=&quot;b/deparse&quot;&gt;B :: Deparse&lt;/a&gt;を使用することです。2つのサブルーチンが &lt;code&gt;1&lt;/code&gt; を返す例を考えてみましょう。1つは &lt;code&gt;()&lt;/code&gt; プロトタイプでインライン化され、もう1つは（明確化のために解析解除出力が切り捨てられて）ありません。</target>
        </trans-unit>
        <trans-unit id="1861cd9be51843a146c51b85f741a8d483f14173" translate="yes" xml:space="preserve">
          <source>The easy answer is &quot;Don't do that!&quot;</source>
          <target state="translated">簡単な答えは「やめろ!」です。</target>
        </trans-unit>
        <trans-unit id="0597cca28cb7230a0e356c17782e46be9384f5c8" translate="yes" xml:space="preserve">
          <source>The effect of using &quot;failure_auto_handler&quot; is like an AUTO lexicon, except that it 1) compiles $key even if it starts with &quot;_&quot;, and 2) you have a record in the new hashref $lh-&amp;gt;{'failure_lex'} of all the keys that have failed for this object. This should avoid your program dying -- as long as your keys aren't actually invalid as bracket code, and as long as they don't try calling methods that don't exist.</source>
          <target state="translated">&quot;failure_auto_handler&quot;を使用する効果は、AUTOレキシコンに似ていますが、1） &quot;_&quot;で始まっていても$ keyをコンパイルします。2）新しいハッシュリファレンス$ lh-&amp;gt; {'failure_lex'}にレコードがあります。このオブジェクトで失敗したすべてのキーの。これにより、プログラムが死ぬのを防ぐことができます-キーがブラケットコードとして実際に無効でない限り、および存在しないメソッドを呼び出そうとしない限り。</target>
        </trans-unit>
        <trans-unit id="e111bef16ba68c39a0b6040a000b635141c8f1f2" translate="yes" xml:space="preserve">
          <source>The effective gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getegid()&lt;/code&gt; , and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt; , one of which may be the same as the first number.</source>
          <target state="translated">このプロセスの有効なgid。あなたは、同時に複数のグループでのサポートメンバーシップは、スペースを与えることをマシン上にある場合は、あなたがしているグループのリストを区切ります。最初の数はで返さ一つです &lt;code&gt;getegid()&lt;/code&gt; によると、それに続くもの &lt;code&gt;getgroups()&lt;/code&gt; 、5月の1最初の番号と同じである。</target>
        </trans-unit>
        <trans-unit id="391c814eb86428160d8ecfb1e5d99a0a23856f18" translate="yes" xml:space="preserve">
          <source>The effective uid of this process. For example:</source>
          <target state="translated">このプロセスの有効なuid。例えば</target>
        </trans-unit>
        <trans-unit id="78e522cbb08752f888e4a4c422be723520118862" translate="yes" xml:space="preserve">
          <source>The element &lt;code&gt;$ENV{DEFAULT}&lt;/code&gt; is special: when read, it returns Perl's current default device and directory, and when set, it resets them, regardless of the definition of</source>
          <target state="translated">要素 &lt;code&gt;$ENV{DEFAULT}&lt;/code&gt; は特別です。読み込まれると、Perlの現在のデフォルトのデバイスとディレクトリが返され、設定されると、定義に関係なくそれらがリセットされます</target>
        </trans-unit>
        <trans-unit id="1927e85810982ff4bedcbd8fe6ac46c4f4acfd36" translate="yes" xml:space="preserve">
          <source>The element is a hash, initialized by default to &lt;code&gt;()&lt;/code&gt; .</source>
          <target state="translated">要素はハッシュであり、デフォルトで &lt;code&gt;()&lt;/code&gt; に初期化されます。</target>
        </trans-unit>
        <trans-unit id="010155a37e502b613f4bf666146b070b50ac9cf2" translate="yes" xml:space="preserve">
          <source>The element is a scalar, and by default is initialized to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (but see &lt;a href=&quot;#Initializing-with-new&quot;&gt;Initializing with new&lt;/a&gt;).</source>
          <target state="translated">要素はスカラーであり、デフォルトでは &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; に初期化されます（ただし&lt;a href=&quot;#Initializing-with-new&quot;&gt;、newによる初期化を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="7c7fe592a2def98474e3260c74013058ff355fc6" translate="yes" xml:space="preserve">
          <source>The element is an array, initialized by default to &lt;code&gt;()&lt;/code&gt; .</source>
          <target state="translated">要素は配列であり、デフォルトで &lt;code&gt;()&lt;/code&gt; に初期化されます。</target>
        </trans-unit>
        <trans-unit id="942bdb865668cc5d25526303c780ec9824d73845" translate="yes" xml:space="preserve">
          <source>The element's value must be a reference blessed to the named class or to one of its subclasses. The element is not initialized by default.</source>
          <target state="translated">要素の値は、指定されたクラスまたはそのサブクラスのいずれかに祝福された参照でなければなりません。要素はデフォルトでは初期化されません。</target>
        </trans-unit>
        <trans-unit id="cfb20ee6aa799cc8c00cade7ca9b921cb0624824" translate="yes" xml:space="preserve">
          <source>The elements we're getting from the array start with a &lt;code&gt;$&lt;/code&gt; because we're getting just a single value out of the array; you ask for a scalar, you get a scalar.</source>
          <target state="translated">配列から取得する要素は &lt;code&gt;$&lt;/code&gt; で始まります。これは、配列から1つの値しか取得しないためです。スカラーを要求すると、スカラーを取得します。</target>
        </trans-unit>
        <trans-unit id="c2d2a5272ddb492896f4b1aa2fdc89f7d8b57cf1" translate="yes" xml:space="preserve">
          <source>The elliptical statement cannot stand in for an expression that is part of a larger statement, since the &lt;code&gt;...&lt;/code&gt; is also the three-dot version of the flip-flop operator (see &lt;a href=&quot;perlop#Range-Operators&quot;&gt;Range Operators in perlop&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;...&lt;/code&gt; はフリップフロップ演算子の3ドットバージョンでもあるので、楕円のステートメントは、より大きなステートメントの一部である式の&lt;a href=&quot;perlop#Range-Operators&quot;&gt;代わりになる&lt;/a&gt;ことはできません（perlopのRange演算子を参照）。</target>
        </trans-unit>
        <trans-unit id="545891d79255fc3bc69760f930c3f25bc8ae8965" translate="yes" xml:space="preserve">
          <source>The email you got when you received your CPAN ID will tell you how to log in to PAUSE, the Perl Authors Upload SErver. From the menus there, you can upload your module to CPAN.</source>
          <target state="translated">CPAN IDを受け取ったときに送られてきたメールには、Perl Authors Upload SErverであるPAUSEへのログイン方法が記載されています。そこにあるメニューから、あなたのモジュールをCPANにアップロードすることができます。</target>
        </trans-unit>
        <trans-unit id="588a9b522600848c7a034e730acfdc94a0b61885" translate="yes" xml:space="preserve">
          <source>The encoding is assumed to be an Encode object, on entry the PV of the sv is assumed to be octets in that encoding, and the sv will be converted into Unicode (and UTF-8).</source>
          <target state="translated">エンコーディングはEncodeオブジェクトであると仮定され、エントリー時にsvのPVはそのエンコーディングのオクテットであると仮定され、svはUnicode(およびUTF-8)に変換されます。</target>
        </trans-unit>
        <trans-unit id="2aac7e4350e18d454240d654ed5501855f5c3e7e" translate="yes" xml:space="preserve">
          <source>The encoding is assumed to be an Encode object, the PV of the ssv is assumed to be octets in that encoding and decoding the input starts from the position which (PV + *offset) pointed to. The dsv will be concatenated the decoded UTF-8 string from ssv. Decoding will terminate when the string tstr appears in decoding output or the input ends on the PV of the ssv. The value which the offset points will be modified to the last input position on the ssv.</source>
          <target state="translated">エンコードはEncodeオブジェクトとし、ssvのPVはそのエンコードにおけるオクテットとし、入力のデコードは(PV+*offset)が指す位置から始まります。dsv は ssv からデコードされた UTF-8 文字列を連結したものになります。デコード出力に文字列 tstr が現れるか、入力が ssv の PV で終了するとデコードは終了します。オフセットが指す値は ssv の最後の入力位置に修正されます。</target>
        </trans-unit>
        <trans-unit id="d3062423073ff3110a760ac5983fd2a737512781" translate="yes" xml:space="preserve">
          <source>The encoding pragma is not supported on EBCDIC platforms.</source>
          <target state="translated">エンコーディング pragma は EBCDIC プラットフォームではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="04abf26a5ca58977d603141fc0ef79876490369d" translate="yes" xml:space="preserve">
          <source>The encoding requested is not supported by the Encode module.</source>
          <target state="translated">要求されたエンコーディングはEncodeモジュールではサポートされていません。</target>
        </trans-unit>
        <trans-unit id="39b0be99c7e0fde92c59a2dde4b75bd2c5e6a66a" translate="yes" xml:space="preserve">
          <source>The encodings of &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;STDOUT&lt;/code&gt; are individually settable by parameters to the pragma:</source>
          <target state="translated">&lt;code&gt;STDIN&lt;/code&gt; および &lt;code&gt;STDOUT&lt;/code&gt; のエンコーディングは、プラグマへのパラメータによって個別に設定できます。</target>
        </trans-unit>
        <trans-unit id="0d58ea5991c657606e31a1ebddfdcbdfe42b5a94" translate="yes" xml:space="preserve">
          <source>The end result of all this is a list of pairs of filenames. By default that is what is returned by &lt;code&gt;globmap&lt;/code&gt; . In this example the data structure returned will look like this</source>
          <target state="translated">これらすべての最終結果は、ファイル名のペアのリストです。デフォルトでは、これは &lt;code&gt;globmap&lt;/code&gt; によって返されるものです。この例では、返されるデータ構造は次のようになります</target>
        </trans-unit>
        <trans-unit id="733a0f46f2e4433da326d8b3d8649ddcec9e6f67" translate="yes" xml:space="preserve">
          <source>The engine implementing pack() Perl function.</source>
          <target state="translated">Perl 関数 pack()を実装したエンジン。</target>
        </trans-unit>
        <trans-unit id="3347858c5b43f539e0e1c803ce10b0c1e284b3a5" translate="yes" xml:space="preserve">
          <source>The engine implementing pack() Perl function. Note: parameters next_in_list and flags are not used. This call should not be used; use packlist instead.</source>
          <target state="translated">Perl 関数 pack()を実装したエンジン。注意:パラメータ next_in_list と flags は使用されません。この呼び出しは使用すべきではありません。</target>
        </trans-unit>
        <trans-unit id="5023a760442586ad60fa18e526984ee22ee1b465" translate="yes" xml:space="preserve">
          <source>The engine implementing the unpack() Perl function.</source>
          <target state="translated">Perl の unpack()関数を実装したエンジン。</target>
        </trans-unit>
        <trans-unit id="23836ad0aab663b81186836eab5aaaa304905073" translate="yes" xml:space="preserve">
          <source>The engine implementing unpack() Perl function. Note: parameters strbeg, new_s and ocnt are not used. This call should not be used, use unpackstring instead.</source>
          <target state="translated">unpack()Perl 関数を実装したエンジン。注意:パラメータ strbeg,new_s,ocnt は使用されません。この呼び出しは使用しないで、代わりに unpackstring を使用してください。</target>
        </trans-unit>
        <trans-unit id="d9382e3775d5db72bf3f9d8d46eb30460f658e51" translate="yes" xml:space="preserve">
          <source>The engine's private copy of the flags the pattern was compiled with. Usually this is the same as &lt;code&gt;extflags&lt;/code&gt; unless the engine chose to modify one of them.</source>
          <target state="translated">パターンがコンパイルされたフラグのエンジンのプライベートコピー。エンジンがそれらのいずれかを変更することを選択しない限り、これは通常、 &lt;code&gt;extflags&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="7e628a3e380b1bb720e0473c9d50225fb2d2a7bf" translate="yes" xml:space="preserve">
          <source>The entire getaddrinfo() subsystem can be exported using the tag &lt;code&gt;:addrinfo&lt;/code&gt; ; this exports the getaddrinfo() and getnameinfo() functions, and all the &lt;code&gt;AI_*&lt;/code&gt; , &lt;code&gt;NI_*&lt;/code&gt; , &lt;code&gt;NIx_*&lt;/code&gt; and &lt;code&gt;EAI_*&lt;/code&gt; constants.</source>
          <target state="translated">getaddrinfo（）サブシステム全体は、タグ &lt;code&gt;:addrinfo&lt;/code&gt; を使用してエクスポートできます。これにより、getaddrinfo（）関数とgetnameinfo（）関数、およびすべての &lt;code&gt;AI_*&lt;/code&gt; 、 &lt;code&gt;NI_*&lt;/code&gt; 、 &lt;code&gt;NIx_*&lt;/code&gt; 、 &lt;code&gt;EAI_*&lt;/code&gt; 定数がエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="425561102978b28bf5fcfefe3513eb2739c2c06d" translate="yes" xml:space="preserve">
          <source>The entire hardware and software context in which a program runs. A program written in a platform-dependent language might break if you change any of the following: machine, operating system, libraries, compiler, or system configuration. The</source>
          <target state="translated">プログラムが動作するハードウェアとソフトウェアのコンテキスト全体。プラットフォームに依存する言語で書かれたプログラムは、マシン、オペレーティングシステム、ライブラリ、コンパイラ、システム設定のいずれかを変更すると壊れてしまう可能性があります。プラットフォームに依存する言語で書かれたプログラムは、マシン、オペレーティングシステム、ライブラリ、コンパイラ、システム構成のいずれかを変更すると壊れてしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="062ee9dd6945c627c0db8805ff34b8bebe56650f" translate="yes" xml:space="preserve">
          <source>The entire upgrading/downgrading is still experimental and might not work as you expect or may even have bugs. You might get errors like this:</source>
          <target state="translated">アップグレード/ダウングレード全体はまだ実験的なものであり、期待通りに動作しないかもしれませんし、バグがあるかもしれません。このようなエラーが出るかもしれません。</target>
        </trans-unit>
        <trans-unit id="5e462b82c7819411d2795ec13fd404d6485cf8ac" translate="yes" xml:space="preserve">
          <source>The environment is not automatically made available as separate scalar variables.</source>
          <target state="translated">環境が自動的に別のスカラー変数として利用可能になるわけではありません。</target>
        </trans-unit>
        <trans-unit id="4a714b26cc76c6e720a2c1944b7c3273669f5c69" translate="yes" xml:space="preserve">
          <source>The environment variable &lt;code&gt;PERL_RL&lt;/code&gt; governs which ReadLine clone is loaded. If the value is false, a dummy interface is used. If the value is true, it should be tail of the name of the package to use, such as &lt;code&gt;Perl&lt;/code&gt; or &lt;code&gt;Gnu&lt;/code&gt; .</source>
          <target state="translated">環境変数 &lt;code&gt;PERL_RL&lt;/code&gt; は、読み込まれるReadLineクローンを管理します。値がfalseの場合、ダミーインターフェイスが使用されます。値がtrueの場合、 &lt;code&gt;Perl&lt;/code&gt; や &lt;code&gt;Gnu&lt;/code&gt; など、使用するパッケージの名前の末尾にする必要があります。</target>
        </trans-unit>
        <trans-unit id="17c8987c252d8945d5eef3157bdde1da3d4677a3" translate="yes" xml:space="preserve">
          <source>The error function [C99].</source>
          <target state="translated">エラー関数[C99]。</target>
        </trans-unit>
        <trans-unit id="c03bfb5951202558a79d3146a129bcd7599c5997" translate="yes" xml:space="preserve">
          <source>The error level, should be 'WARNING' or 'ERROR'.</source>
          <target state="translated">エラーレベルは、'WARNING'または'ERROR'でなければなりません。</target>
        </trans-unit>
        <trans-unit id="489643f4ea640ba730461cfbd32bed09509bae25" translate="yes" xml:space="preserve">
          <source>The error message or object will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak_sv&lt;/code&gt; function never returns normally.</source>
          <target state="translated">エラーメッセージまたはオブジェクトは例外として使用されます。デフォルトでは、最も近い囲んでいる &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; に制御を返しますが、 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; ハンドラーによる変更の対象となります。いずれの場合も、 &lt;code&gt;croak_sv&lt;/code&gt; 関数が正常に戻ることはありません。</target>
        </trans-unit>
        <trans-unit id="664a7836db566d6a3f4c07aec582c78faf8e8984" translate="yes" xml:space="preserve">
          <source>The error message or object will by default be written to standard error, but this is subject to modification by a &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handler.</source>
          <target state="translated">エラーメッセージまたはオブジェクトはデフォルトで標準エラーに書き込まれますが、これは &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; ハンドラーによって変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="b67bc4e2f3fe19fc43d4ef72e9869cbd0c9674e2" translate="yes" xml:space="preserve">
          <source>The error message will be used as an exception, by default returning control to the nearest enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, but subject to modification by a &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; handler. In any case, the &lt;code&gt;croak&lt;/code&gt; function never returns normally.</source>
          <target state="translated">エラーメッセージは例外として使用されます。デフォルトでは、最も近い &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; に制御を返しますが、$ SIG {__ DIE__}ハンドラーによって変更される可能性があります。いずれの場合でも、 &lt;code&gt;croak&lt;/code&gt; 関数は正常に戻りません。</target>
        </trans-unit>
        <trans-unit id="900d77a6d61d64e8af52decba69cafd8be937ac1" translate="yes" xml:space="preserve">
          <source>The error number returned by a &lt;b&gt;syscall&lt;/b&gt; when it fails. Perl refers to the error by the name &lt;code&gt;$!&lt;/code&gt; (or &lt;code&gt;$OS_ERROR&lt;/code&gt; if you use the English module).</source>
          <target state="translated">&lt;b&gt;syscall&lt;/b&gt;が失敗したときに返されるエラー番号。Perlは &lt;code&gt;$!&lt;/code&gt; という名前でエラーを参照します。（英語のモジュールを使用する場合は &lt;code&gt;$OS_ERROR&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="953076d4b6c381c0ffffe4399cd4fbc39f8ceb23" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. If no error occurred it will be zero numerically and an empty string.</source>
          <target state="translated">エラー値はdualvarになります。 &lt;code&gt;EI_*&lt;/code&gt; エラー定数に相当するか、人間が読み取れるエラーメッセージ文字列として出力できます。エラーが発生しなかった場合、数値はゼロで空の文字列になります。</target>
        </trans-unit>
        <trans-unit id="4f48137cede1f63ecf865be7641415458ec370ab" translate="yes" xml:space="preserve">
          <source>The error value will be a dualvar; comparable to the &lt;code&gt;EI_*&lt;/code&gt; error constants, or printable as a human-readable error message string. The host and service names will be plain strings.</source>
          <target state="translated">エラー値はdualvarになります。 &lt;code&gt;EI_*&lt;/code&gt; エラー定数に相当するか、人間が読み取れるエラーメッセージ文字列として出力できます。ホスト名とサービス名はプレーンな文字列になります。</target>
        </trans-unit>
        <trans-unit id="7d1c1519bb36749c3cad434bbe27ce9cca770380" translate="yes" xml:space="preserve">
          <source>The evaluation modifier &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; wraps an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{...}&lt;/a&gt;&lt;/code&gt; around the replacement string and the evaluated result is substituted for the matched substring. Some examples:</source>
          <target state="translated">評価修飾子 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///e&lt;/a&gt;&lt;/code&gt; ラップ &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval{...}&lt;/a&gt;&lt;/code&gt; 置換文字列の周りを、評価結果は、マッチした部分文字列に置換されます。いくつかの例：</target>
        </trans-unit>
        <trans-unit id="b4c657becf62f17dba34f2c0a7892b03eec9664a" translate="yes" xml:space="preserve">
          <source>The exact implementation of this macro varies by architecture and version of perl, and the return value may change per invocation, so the value is only valid for the duration of a single perl process.</source>
          <target state="translated">このマクロの正確な実装はperlのアーキテクチャやバージョンによって異なり、戻り値は呼び出しごとに変更される可能性があるため、値は1つのperlプロセスの間のみ有効です。</target>
        </trans-unit>
        <trans-unit id="77f569ab2ca56d55a753f65526e499d75cae3e5d" translate="yes" xml:space="preserve">
          <source>The exact line number may vary, but if the warning (W) comes from a line line this</source>
          <target state="translated">正確な行番号は異なるかもしれませんが、警告(W)が行番号から来ている場合は、この</target>
        </trans-unit>
        <trans-unit id="995bdcd8d207fa374f9f43b6e279df6bd565026b" translate="yes" xml:space="preserve">
          <source>The exact line numbers may vary between Perl releases. The warnings are benign and can be ignored: in later C compiler releases the warnings should be gone.</source>
          <target state="translated">正確な行番号は Perl のリリースによって異なるかもしれません。これらの警告は無害で無視することができます。</target>
        </trans-unit>
        <trans-unit id="44fc79e864b1257675cf101f1f7fd3a57bf639a9" translate="yes" xml:space="preserve">
          <source>The exact manner in which the address is returned in $symref is not currently defined. The only initial requirement is that $symref can be passed to, and understood by, dl_install_xsub().</source>
          <target state="translated">symref でアドレスが返される正確な方法は、現在のところ定義されていません。唯一の初期条件は、 $symref が dl_install_xsub()に渡され、それを理解できることです。</target>
        </trans-unit>
        <trans-unit id="e70c2ef4d5d588ebbe05350bafa35fc8f80a6a1c" translate="yes" xml:space="preserve">
          <source>The exact meaning of the $gcos field varies but it usually contains the real name of the user (as opposed to the login name) and other information pertaining to the user. Beware, however, that in many system users are able to change this information and therefore it cannot be trusted and therefore the $gcos is tainted (see &lt;a href=&quot;../perlsec&quot;&gt;perlsec&lt;/a&gt;). The $passwd and $shell, user's encrypted password and login shell, are also tainted, for the same reason.</source>
          <target state="translated">$ gcosフィールドの正確な意味はさまざまですが、通常は（ログイン名ではなく）ユーザーの実際の名前とユーザーに関するその他の情報が含まれます。ただし、多くのシステムユーザーはこの情報を変更できるため、信頼できないため、$ gcosが汚染されていることに&lt;a href=&quot;../perlsec&quot;&gt;注意して&lt;/a&gt;ください（perlsecを参照）。同じ理由で、ユーザーの暗号化されたパスワードとログインシェルである$ passwdと$ shellも汚染されています。</target>
        </trans-unit>
        <trans-unit id="d7d6887be4411b65036ddda7abbe1d73b16c3d9f" translate="yes" xml:space="preserve">
          <source>The exact meaning of the $gcos field varies but it usually contains the real name of the user (as opposed to the login name) and other information pertaining to the user. Beware, however, that in many system users are able to change this information and therefore it cannot be trusted and therefore the $gcos is tainted (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;). The $passwd and $shell, user's encrypted password and login shell, are also tainted, for the same reason.</source>
          <target state="translated">$ gcosフィールドの正確な意味はさまざまですが、通常は（ログイン名ではなく）ユーザーの実際の名前とユーザーに関するその他の情報が含まれます。ただし、多くのシステムユーザーはこの情報を変更できるため、信頼できないため、$ gcosが汚染されていることに&lt;a href=&quot;perlsec&quot;&gt;注意して&lt;/a&gt;ください（perlsecを参照）。同じ理由で、ユーザーの暗号化されたパスワードとログインシェルである$ passwdと$ shellも汚染されています。</target>
        </trans-unit>
        <trans-unit id="6462c6eed55545498a4b1274ffec108a59806854" translate="yes" xml:space="preserve">
          <source>The exact rules for how often (??{}) and (?{}) are executed in a pattern are unspecified. In the case of a successful match you can assume that they DWIM and will be executed in left to right order the appropriate number of times in the accepting path of the pattern as would any other meta-pattern. How non-accepting pathways and match failures affect the number of times a pattern is executed is specifically unspecified and may vary depending on what optimizations can be applied to the pattern and is likely to change from version to version.</source>
          <target state="translated">パターンの中で(? マッチに成功した場合、これらはDWIMであり、他のメタパターンと同様に、パターンのアクセプタンスパス内で適切な回数、左から右へと実行されると仮定することができます。非アクセプタンスパスやマッチの失敗がパターンの実行回数にどのような影響を与えるかは特に指定されておらず、どのような最適化がパターンに適用できるかによって変わる可能性があり、バージョンによって変わる可能性があります。</target>
        </trans-unit>
        <trans-unit id="b7beaad311b9cd2e0a10bf6f8d5a018e83ebb91c" translate="yes" xml:space="preserve">
          <source>The exact same effect could, incidentally, be achieved with a single &quot;=for&quot; paragraph:</source>
          <target state="translated">ちなみに、全く同じ効果は、「=for」の段落でも達成できます。</target>
        </trans-unit>
        <trans-unit id="61acc8b78f6506711798cda20b87d0c0557e6d78" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or, starting from Perl 5.8.0, also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;../fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPEとATTRSの正確なセマンティクスとインターフェースはまだ進化しています。 TYPEは現在、 &lt;code&gt;fields&lt;/code&gt; プラグマの使用にバインドされており、属性は &lt;code&gt;attributes&lt;/code&gt; プラグマを使用して、またはPerl 5.8.0以降では &lt;code&gt;Attribute::Handlers&lt;/code&gt; Handlers モジュールを介して処理されます。詳細については、&lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;perlsubのmy（）によるプライベート変数&lt;/a&gt;、&lt;a href=&quot;../fields&quot;&gt;フィールド&lt;/a&gt;、&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;、および&lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute :: &lt;/a&gt;Handlersを参照してください。</target>
        </trans-unit>
        <trans-unit id="90e321854a7d357a33050984753578010a7cc972" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or, starting from Perl 5.8.0, also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPEとATTRSの正確なセマンティクスとインターフェースはまだ進化しています。 TYPEは現在、 &lt;code&gt;fields&lt;/code&gt; プラグマの使用にバインドされており、属性は &lt;code&gt;attributes&lt;/code&gt; プラグマを使用して、またはPerl 5.8.0以降では &lt;code&gt;Attribute::Handlers&lt;/code&gt; Handlers モジュールを介して処理されます。詳細については、&lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;perlsubのmy（）によるプライベート変数&lt;/a&gt;、&lt;a href=&quot;fields&quot;&gt;フィールド&lt;/a&gt;、&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;、および&lt;a href=&quot;attribute/handlers&quot;&gt;Attribute :: &lt;/a&gt;Handlersを参照してください。</target>
        </trans-unit>
        <trans-unit id="a2c046e7769f3ecfcaed8dd98a806a8be83eb888" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE may be a bareword, a constant declared with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; , or &lt;code&gt;__PACKAGE__&lt;/code&gt; . It is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or starting from Perl 5.8.0 also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPEとATTRSの正確なセマンティクスとインターフェースはまだ進化しています。 TYPEは、 &lt;code&gt;__PACKAGE__&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; で宣言された定数、または__PACKAGE__のいずれかです。現在は &lt;code&gt;fields&lt;/code&gt; プラグマの使用にバインドされており、属性は &lt;code&gt;attributes&lt;/code&gt; プラグマを使用して処理されるか、Perl 5.8.0以降、 &lt;code&gt;Attribute::Handlers&lt;/code&gt; Handlers モジュールを介して処理されます。詳細については、&lt;a href=&quot;perlsub#Private-Variables-via-my()&quot;&gt;perlsubのmy（）によるプライベート変数&lt;/a&gt;、&lt;a href=&quot;fields&quot;&gt;フィールド&lt;/a&gt;、&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;、および&lt;a href=&quot;attribute/handlers&quot;&gt;Attribute :: &lt;/a&gt;Handlersを参照してください。</target>
        </trans-unit>
        <trans-unit id="e8bfadb028cf247124d08e25f901567b324753c6" translate="yes" xml:space="preserve">
          <source>The exact semantics and interface of TYPE and ATTRS are still evolving. TYPE may be a bareword, a constant declared with &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; , or &lt;code&gt;&lt;a href=&quot;__package__&quot;&gt;__PACKAGE__&lt;/a&gt;&lt;/code&gt;. It is currently bound to the use of the &lt;code&gt;fields&lt;/code&gt; pragma, and attributes are handled using the &lt;code&gt;attributes&lt;/code&gt; pragma, or starting from Perl 5.8.0 also via the &lt;code&gt;Attribute::Handlers&lt;/code&gt; module. See &lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;Private Variables via my() in perlsub&lt;/a&gt; for details, and &lt;a href=&quot;../fields&quot;&gt;fields&lt;/a&gt;, &lt;a href=&quot;../attributes&quot;&gt;attributes&lt;/a&gt;, and &lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute::Handlers&lt;/a&gt;.</source>
          <target state="translated">TYPEとATTRSの正確なセマンティクスとインターフェースはまだ進化しています。 TYPEは、 &lt;code&gt;&lt;a href=&quot;__package__&quot;&gt;__PACKAGE__&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; で宣言された定数、または__PACKAGE__のいずれかです。現在は &lt;code&gt;fields&lt;/code&gt; プラグマの使用にバインドされており、属性は &lt;code&gt;attributes&lt;/code&gt; プラグマを使用して処理されるか、Perl 5.8.0以降、 &lt;code&gt;Attribute::Handlers&lt;/code&gt; Handlers モジュールを介して処理されます。詳細については、&lt;a href=&quot;../perlsub#Private-Variables-via-my()&quot;&gt;perlsubのmy（）によるプライベート変数&lt;/a&gt;、&lt;a href=&quot;../fields&quot;&gt;フィールド&lt;/a&gt;、&lt;a href=&quot;../attributes&quot;&gt;属性&lt;/a&gt;、および&lt;a href=&quot;../attribute/handlers&quot;&gt;Attribute :: &lt;/a&gt;Handlersを参照してください。</target>
        </trans-unit>
        <trans-unit id="c8d599de382831818fdc3314909d743d15fa4f85" translate="yes" xml:space="preserve">
          <source>The exact set of characters matched by &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; varies depending on various pragma and regular expression modifiers. It is possible to restrict the match to the ASCII range by using the &lt;code&gt;/a&lt;/code&gt; regular expression modifier. See &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 、 &lt;code&gt;\s&lt;/code&gt; 、および &lt;code&gt;\w&lt;/code&gt; と一致する文字の正確なセットは、さまざまなプラグマと正規表現修飾子によって異なります。 &lt;code&gt;/a&lt;/code&gt; 正規表現修飾子を使用して、一致をASCII範囲に制限することができます。&lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclassを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="04c6e96fbcd4407d552a2d3c6f391d06e2768883" translate="yes" xml:space="preserve">
          <source>The example below illustrates this feature using the pattern for floating point numbers that was presented earlier on. The three subpatterns that are used more than once are the optional sign, the digit sequence for an integer and the decimal fraction. The DEFINE group at the end of the pattern contains their definition. Notice that the decimal fraction pattern is the first place where we can reuse the integer pattern.</source>
          <target state="translated">以下の例は、先に紹介した浮動小数点数のパターンを使用して、この機能を説明しています。複数回使用される3つのサブパターンは、任意の符号、整数の桁数列、小数部です。パターンの最後にある DEFINE グループには、それらの定義が含まれています。小数点以下の小数パターンは、整数パターンを再利用できる最初の場所であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="b95b2fc7c1cff73cb10b6820506fd203858d5dd0" translate="yes" xml:space="preserve">
          <source>The example does not untaint &lt;code&gt;$data&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, because the characters matched by &lt;code&gt;\w&lt;/code&gt; are determined by the locale. Perl considers that locale definitions are untrustworthy because they contain data from outside the program. If you are writing a locale-aware program, and want to launder data with a regular expression containing &lt;code&gt;\w&lt;/code&gt; , put &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; ahead of the expression in the same block. See &lt;a href=&quot;perllocale#SECURITY&quot;&gt;SECURITY in perllocale&lt;/a&gt; for further discussion and examples.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 一致する文字はロケールによって決定されるため、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; localeが有効な場合、この例は &lt;code&gt;$data&lt;/code&gt; untaintしません。 Perlは、プログラムの外部からのデータが含まれているため、ロケール定義は信頼できないと見なしています。ロケール対応プログラムを作成していて、 &lt;code&gt;\w&lt;/code&gt; を含む正規表現でデータを洗いたい場合は、同じブロック内の式の前に &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; locale&lt;/code&gt; 配置し&lt;a href=&quot;functions/no&quot;&gt;ないで&lt;/a&gt;ください。さらなる議論と例について&lt;a href=&quot;perllocale#SECURITY&quot;&gt;は、perllocaleのSECURITYを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="bd1c21f507054a9e5bf00808f679503b139b9cd1" translate="yes" xml:space="preserve">
          <source>The examples above use a relative path to the perl interpreter, getting whatever version is first in the user's path. If you want a specific version of Perl, say, perl5.14.1, you should place that directly in the &lt;code&gt;#!&lt;/code&gt; line's path.</source>
          <target state="translated">上記の例では、perlインタープリターへの相対パスを使用して、ユーザーのパスの最初のバージョンを取得しています。Perlの特定のバージョン、たとえばperl5.14.1が必要な場合は、 &lt;code&gt;#!&lt;/code&gt; 直接配置する必要があります。ラインのパス。</target>
        </trans-unit>
        <trans-unit id="ba7768ce3ab49f321e6775f2de42c2a895f7304f" translate="yes" xml:space="preserve">
          <source>The examples given at the start of the document (an error handler and an event driven program) are typical of the two main sorts of flow control that you are likely to encounter with callbacks. There is a very important distinction between them, so pay attention.</source>
          <target state="translated">ドキュメントの冒頭に挙げた例(エラーハンドラとイベントドリブンプログラム)は、コールバックで遭遇する可能性の高い2つの主要なフロー制御の典型的なものです。これらの間には非常に重要な区別がありますので、注意してください。</target>
        </trans-unit>
        <trans-unit id="d5744c543ee5f3d510361cac5aaaa06664739511" translate="yes" xml:space="preserve">
          <source>The examples illustrate several aspects: the first three queries target modules, authors, or distros directly and yield exactly one result. The last two use regular expressions and yield several results. The last one targets all of bundles, modules, authors, and distros simultaneously. When more than one result is available, they are printed in one-line format.</source>
          <target state="translated">最初の3つのクエリはモジュール、作者、またはディストロを直接ターゲットにしており、結果は正確に1つです。最後の2つは正規表現を使用しており、いくつかの結果が得られます。最後の1つは、バンドル、モジュール、著者、ディストロのすべてを同時に対象としています。複数の結果が得られる場合、それらは一行形式で表示されます。</target>
        </trans-unit>
        <trans-unit id="ddf2315db7343aee83255d9099df21a0faac3030" translate="yes" xml:space="preserve">
          <source>The examples in the previous section display an annoying weakness. We were only matching 3-letter words, or chunks of words of 4 letters or less. We'd like to be able to match words or, more generally, strings of any length, without writing out tedious alternatives like &lt;code&gt;\w\w\w\w|\w\w\w|\w\w|\w&lt;/code&gt; .</source>
          <target state="translated">前のセクションの例は、厄介な弱点を示しています。3文字の単語、または4文字以下の単語のチャンクのみを照合しました。 &lt;code&gt;\w\w\w\w|\w\w\w|\w\w|\w&lt;/code&gt; ような面倒な代替を記述せずに、単語またはより一般的には任意の長さの文字列に一致できるようにしたいと考えています。</target>
        </trans-unit>
        <trans-unit id="6a56adef05fecf63fd9cba639dd925bcaf1cb87b" translate="yes" xml:space="preserve">
          <source>The examples show a very simple class that implements a</source>
          <target state="translated">を実装した非常にシンプルなクラスを示しています。</target>
        </trans-unit>
        <trans-unit id="45802eeee4d1f7759548f95073ecb55a63eb7a92" translate="yes" xml:space="preserve">
          <source>The examples show this class implemented with different levels of support by &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; . All supported combinations are shown. The difference between implementations is often quite small. The implementations are:</source>
          <target state="translated">例は、 &lt;code&gt;Hash::Util::FieldHash&lt;/code&gt; によるさまざまなサポートレベルで実装されたこのクラスを示しています。サポートされているすべての組み合わせが表示されます。多くの場合、実装の違いはごくわずかです。実装は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="f51ffd2e5bcc1a6d7d14bd6f95a324550850104d" translate="yes" xml:space="preserve">
          <source>The excellent Calendar FAQ at &lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt;の優れたカレンダーFAQ</target>
        </trans-unit>
        <trans-unit id="b98aabfe9b6ba71ecfd39be082dced0eadaf1cc4" translate="yes" xml:space="preserve">
          <source>The excellent Filter::Util::Call module (by Paul Marquess) provides a usable Perl interface to source filtering, but it is often too powerful and not nearly as simple as it could be.</source>
          <target state="translated">優れた Filter::Util::Call モジュール (by Paul Marquess)は、ソースフィルタリングのための使い勝手の良い Perl インターフェイスを提供していますが、あまりにも強力すぎて、シンプルなものにはなりません。</target>
        </trans-unit>
        <trans-unit id="52ea595fb3e7d2ce456e743df519b555912d5e12" translate="yes" xml:space="preserve">
          <source>The exception is for organization-specific email (e.g. foo@yourcompany.com) where policy can be codified in your program. In that case, you could look at $ENV{USER}, $ENV{LOGNAME}, and getpwuid($&amp;lt;) in scalar context, like so:</source>
          <target state="translated">例外は、プログラムがポリシーを体系化できる組織固有のメール（例：foo@yourcompany.com）です。その場合、次のように、スカラーコンテキストで$ ENV {USER}、$ ENV {LOGNAME}、およびgetpwuid（$ &amp;lt;）を確認できます。</target>
        </trans-unit>
        <trans-unit id="ffc87b76bc5dac6308b19a21f2fb89ffe909a88b" translate="yes" xml:space="preserve">
          <source>The exception to the principle of &quot;one tainted value taints the whole expression&quot; is with the ternary conditional operator &lt;code&gt;?:&lt;/code&gt;. Since code with a ternary conditional</source>
          <target state="translated">「1つの汚染された値が式全体を汚染する」という原則の例外は、3項条件演算子 &lt;code&gt;?:&lt;/code&gt; です。三項条件付きのコードなので</target>
        </trans-unit>
        <trans-unit id="5c4020c3e362c07677c68b98797130c8e33e53fa" translate="yes" xml:space="preserve">
          <source>The exception to this rule are</source>
          <target state="translated">このルールの例外は</target>
        </trans-unit>
        <trans-unit id="06cb57f51318b2c753120a0083873c4679095e1b" translate="yes" xml:space="preserve">
          <source>The exception to this rule is if you are calling a Perl subroutine directly from an XSUB function. In this case it is not necessary to use the &lt;code&gt;dSP&lt;/code&gt; macro explicitly--it will be declared for you automatically.</source>
          <target state="translated">このルールの例外は、XSUB関数から直接Perlサブルーチンを呼び出す場合です。この場合、 &lt;code&gt;dSP&lt;/code&gt; マクロを明示的に使用する必要はありません。自動的に宣言されます。</target>
        </trans-unit>
        <trans-unit id="0d894dabcea23f9b036a1c82348cf80da10ab49b" translate="yes" xml:space="preserve">
          <source>The exceptions are:</source>
          <target state="translated">例外はあります。</target>
        </trans-unit>
        <trans-unit id="3e26c68194190c41dfdad74105f0e492dc235a18" translate="yes" xml:space="preserve">
          <source>The execution order is indicated by &lt;code&gt;===&amp;gt;&lt;/code&gt; marks, thus it is &lt;code&gt;3
4 5 6&lt;/code&gt; (node &lt;code&gt;6&lt;/code&gt; is not included into above listing), i.e., &lt;code&gt;gvsv gvsv add whatever&lt;/code&gt; .</source>
          <target state="translated">実行順序は &lt;code&gt;===&amp;gt;&lt;/code&gt; マークで示されているため、 &lt;code&gt;3 4 5 6&lt;/code&gt; （ノード &lt;code&gt;6&lt;/code&gt; は上記のリストには含まれていません）、つまり &lt;code&gt;gvsv gvsv add whatever&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="68a81e1fe7a2f079c1b9f8b207b9fe9d777e92c5" translate="yes" xml:space="preserve">
          <source>The executive summary: learn how your filesystem works. The permissions on a file say what can happen to the data in that file. The permissions on a directory say what can happen to the list of files in that directory. If you delete a file, you're removing its name from the directory (so the operation depends on the permissions of the directory, not of the file). If you try to write to the file, the permissions of the file govern whether you're allowed to.</source>
          <target state="translated">要旨:ファイルシステムがどのように機能するかを学ぶ。ファイルのパーミッションは、そのファイル内のデータに何が起こるかを述べています。ディレクトリのパーミッションは、そのディレクトリ内のファイルのリストに何ができるかを示しています。ファイルを削除すると、ディレクトリからファイル名を削除することになります(その操作はファイルではなくディレクトリのパーミッションに依存します)。あなたがファイルに書き込みをしようとした場合、ファイルのパーミッションはあなたが許可されているかどうかを支配します。</target>
        </trans-unit>
        <trans-unit id="29fc393062d8546f20ed1b167ba8df5f73019ce5" translate="yes" xml:space="preserve">
          <source>The exit code of the executed program.</source>
          <target state="translated">実行されたプログラムの終了コード。</target>
        </trans-unit>
        <trans-unit id="137ed18115f3228ba7f07a48e55913ee96e30593" translate="yes" xml:space="preserve">
          <source>The exit status value to return.</source>
          <target state="translated">復帰する終了ステータス値。</target>
        </trans-unit>
        <trans-unit id="0c5c8d24f00e7eedd0cb8f1fea1a1b90fbdc8c11" translate="yes" xml:space="preserve">
          <source>The exit() function does not always exit immediately. It calls any defined &lt;code&gt;END&lt;/code&gt; routines first, but these &lt;code&gt;END&lt;/code&gt; routines may not themselves abort the exit. Likewise any object destructors that need to be called are called before the real exit. &lt;code&gt;END&lt;/code&gt; routines and destructors can change the exit status by modifying &lt;code&gt;$?&lt;/code&gt; . If this is a problem, you can call &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; to avoid END and destructor processing. See &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt; for details.</source>
          <target state="translated">exit（）関数は、すぐに終了するとは限りません。最初に定義済みの &lt;code&gt;END&lt;/code&gt; ルーチンを呼び出しますが、これらの &lt;code&gt;END&lt;/code&gt; ルーチン自体が出口を中止することはできません。同様に、呼び出す必要のあるオブジェクトデストラクタは、実際に終了する前に呼び出されます。 &lt;code&gt;END&lt;/code&gt; ルーチンとデストラクタは、 &lt;code&gt;$?&lt;/code&gt; を変更して終了ステータスを変更できます。。これが問題である場合は、 &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; を呼び出して、ENDおよびデストラクタ処理を回避できます。詳細は&lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="680c902ef0b900a40fad1c488731545af94f9d10" translate="yes" xml:space="preserve">
          <source>The exit() function does not always exit immediately. It calls any defined &lt;code&gt;END&lt;/code&gt; routines first, but these &lt;code&gt;END&lt;/code&gt; routines may not themselves abort the exit. Likewise any object destructors that need to be called are called before the real exit. &lt;code&gt;END&lt;/code&gt; routines and destructors can change the exit status by modifying &lt;code&gt;$?&lt;/code&gt; . If this is a problem, you can call &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; to avoid END and destructor processing. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details.</source>
          <target state="translated">exit（）関数は、すぐに終了するとは限りません。最初に定義済みの &lt;code&gt;END&lt;/code&gt; ルーチンを呼び出しますが、これらの &lt;code&gt;END&lt;/code&gt; ルーチン自体が出口を中止することはできません。同様に、呼び出す必要のあるオブジェクトデストラクタは、実際に終了する前に呼び出されます。 &lt;code&gt;END&lt;/code&gt; ルーチンとデストラクタは、 &lt;code&gt;$?&lt;/code&gt; を変更して終了ステータスを変更できます。。これが問題である場合は、 &lt;code&gt;POSIX::_exit($status)&lt;/code&gt; を呼び出して、ENDおよびデストラクタ処理を回避できます。詳細は&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="878ff23487a7f8c43fec8d4483cc1765c4df9eb4" translate="yes" xml:space="preserve">
          <source>The experimental &lt;code&gt;given&lt;/code&gt; statement is</source>
          <target state="translated">実験的に &lt;code&gt;given&lt;/code&gt; ステートメントは</target>
        </trans-unit>
        <trans-unit id="19bd303111f858742510d8d90c5638313c02c5ce" translate="yes" xml:space="preserve">
          <source>The experimental &lt;code&gt;legacy&lt;/code&gt; pragma was swallowed by the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="translated">実験的な &lt;code&gt;legacy&lt;/code&gt; プラグマは、 &lt;code&gt;feature&lt;/code&gt; プラグマによって飲み込まれました。</target>
        </trans-unit>
        <trans-unit id="f321e42a52fdc6b5d89f69bf0fc91962da84c32f" translate="yes" xml:space="preserve">
          <source>The exponent is an &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;E&lt;/code&gt; , followed by an integer. So the exponent regexp is</source>
          <target state="translated">指数は &lt;code&gt;e&lt;/code&gt; または &lt;code&gt;E&lt;/code&gt; であり、その後に整数が続きます。したがって、指数正規表現は</target>
        </trans-unit>
        <trans-unit id="dc560dadf22f2caa4887dcda366e49e8868f1d51" translate="yes" xml:space="preserve">
          <source>The exponentiation operator is &quot;**&quot;, not &quot;^&quot;. &quot;^&quot; is the XOR operator, as in C. (You know, one could get the feeling that &lt;b&gt;awk&lt;/b&gt; is basically incompatible with C.)</source>
          <target state="translated">指数演算子は「^」ではなく「**」です。&quot;^&quot;はCと同様にXOR演算子です（ご存知のように、&lt;b&gt;awk&lt;/b&gt;は基本的にCと互換性がないと感じるかもしれません）。</target>
        </trans-unit>
        <trans-unit id="009dcc9526e9f6902be1b067b6a2b9829ed8f757" translate="yes" xml:space="preserve">
          <source>The expression is evaluated in scalar context. So the following will work:</source>
          <target state="translated">式はスカラコンテキストで評価されます。そのため、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="09c23065a9eeac610af39d5a880a04c9ff912e79" translate="yes" xml:space="preserve">
          <source>The ext/ODBM_File/odbm is known to fail with static builds (Configure -Uusedl) due to a known bug in Tru64's static libdbm library. The good news is that you very probably don't need to ever use the ODBM_File extension since more advanced NDBM_File works fine, not to mention the even more advanced DB_File.</source>
          <target state="translated">ext/ODBM_File/odbm は、Tru64 の静的 libdbm ライブラリの既知のバグにより、静的ビルド (Configure -Uusedl)で失敗することが知られています。良いニュースは、より高度な NDBM_File はもちろんのこと、より高度な DB_File も正常に動作するので、ODBM_File 拡張機能を使用する必要がないということです。</target>
        </trans-unit>
        <trans-unit id="31ec63f172c0fdca1326836d5d87e5fe035f0607" translate="yes" xml:space="preserve">
          <source>The extended filetest functionality is used by Perl only when the argument of the operators is a filename, not when it is a filehandle.</source>
          <target state="translated">拡張ファイルテスト機能は、演算子の引数がファイル名の場合にのみPerlによって使用され、ファイルハンドルの場合には使用されません。</target>
        </trans-unit>
        <trans-unit id="b669bdb080a6675f7c6ed5d24b2ef14539648c80" translate="yes" xml:space="preserve">
          <source>The extension is dynamically linked</source>
          <target state="translated">拡張機能は動的にリンクされています。</target>
        </trans-unit>
        <trans-unit id="f990232badfb418cbf7dd0574833889e9f679aa9" translate="yes" xml:space="preserve">
          <source>The extension is pure perl, so doesn't need linking to the perl executable</source>
          <target state="translated">拡張機能は純粋な perl なので、perl 実行ファイルへのリンクは必要ありません。</target>
        </trans-unit>
        <trans-unit id="13f70d182dd718c2ffdf92971d2248139cbe171e" translate="yes" xml:space="preserve">
          <source>The extension is statically linked to the perl binary</source>
          <target state="translated">拡張モジュールは静的に perl バイナリにリンクされています。</target>
        </trans-unit>
        <trans-unit id="b1beda77ee5a84052f068e6757ef13cea3f36f8f" translate="yes" xml:space="preserve">
          <source>The extracted string, including the specified delimiters. If the extraction fails &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">指定された区切り文字を含む、抽出された文字列。抽出が失敗した場合、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="3130a57897b10b0bc008c6b4f6ef79e3b3444412" translate="yes" xml:space="preserve">
          <source>The extracted termcap entry is available in the object as &lt;code&gt;$self-&amp;gt;{TERMCAP}&lt;/code&gt; .</source>
          <target state="translated">抽出されたtermcapエントリーは、 &lt;code&gt;$self-&amp;gt;{TERMCAP}&lt;/code&gt; としてオブジェクトで使用できます。</target>
        </trans-unit>
        <trans-unit id="c328df413a33fa608e46c6826495b03f8d0ee0f6" translate="yes" xml:space="preserve">
          <source>The extraction process works by applying each extractor in sequence to the text string.</source>
          <target state="translated">抽出処理は、各抽出器をテキスト文字列に順に適用することで動作します。</target>
        </trans-unit>
        <trans-unit id="7ad2005947669b79c8509770fad3b2b296acf5fd" translate="yes" xml:space="preserve">
          <source>The fact that such a FILE * has been 'exported' is recorded, (normally by pushing a new :stdio &quot;layer&quot; onto the PerlIO *), which may affect future PerlIO operations on the original PerlIO *. You should not call &lt;code&gt;fclose()&lt;/code&gt; on the file unless you call &lt;code&gt;PerlIO_releaseFILE()&lt;/code&gt; to disassociate it from the PerlIO *. (Do not use PerlIO_importFILE() for doing the disassociation.)</source>
          <target state="translated">このようなFILE *が「エクスポート」されたという事実が記録されます（通常、新しい：stdio &quot;レイヤー&quot;をPerlIO *にプッシュすることによって）。これは、元のPerlIO *での今後のPerlIO操作に影響を与える可能性があります。あなたは呼び出すべきではありません &lt;code&gt;fclose()&lt;/code&gt; 呼び出す場合を除き、ファイルに &lt;code&gt;PerlIO_releaseFILE()&lt;/code&gt; *はPerlIOから関連付けを解除します。 （関連付けを解除するためにPerlIO_importFILE（）を使用しないでください。）</target>
        </trans-unit>
        <trans-unit id="357aafdac768e27bb52a043649452bd876a53d4d" translate="yes" xml:space="preserve">
          <source>The factory itself is never instantiated (this</source>
          <target state="translated">ファクトリー自体がインスタンス化されることはありません(この</target>
        </trans-unit>
        <trans-unit id="ee17924499933b661b8e0c34b82c36eff25eeaf5" translate="yes" xml:space="preserve">
          <source>The fastgetcwd() function is provided as a synonym for cwd().</source>
          <target state="translated">fastgetcwd()関数は cwd()の同義語として提供されます。</target>
        </trans-unit>
        <trans-unit id="533f832808f430e9fde8557e2b27391f20356a2e" translate="yes" xml:space="preserve">
          <source>The feature logical name DECC$FILENAME_UNIX_REPORT modifies traditional Perl behavior in the conversion of file specifications from Unix to VMS format in order to follow the extended character handling rules now expected by the CRTL. Specifically, when this feature is in effect, the &lt;code&gt;./.../&lt;/code&gt; in a Unix path is now translated to &lt;code&gt;[.^.^.^.]&lt;/code&gt; instead of the traditional VMS &lt;code&gt;[...]&lt;/code&gt; . To be compatible with what MakeMaker expects, if a VMS path cannot be translated to a Unix path, it is passed through unchanged, so &lt;code&gt;unixify(&quot;[...]&quot;)&lt;/code&gt; will return &lt;code&gt;[...]&lt;/code&gt; .</source>
          <target state="translated">機能の論理名DECC $ FILENAME_UNIX_REPORTは、ファイル仕様をUNIXからVMS形式に変換する際の従来のPerlの動作を変更して、現在CRTLで想定されている拡張文字処理規則に従うようにします。具体的には、この機能が有効な場合、Unixパスの &lt;code&gt;./.../&lt;/code&gt; が、従来のVMS &lt;code&gt;[...]&lt;/code&gt; ではなく &lt;code&gt;[.^.^.^.]&lt;/code&gt; に変換されるようになりました。MakeMakerが期待するものと互換性を持たせるために、VMSパスをUnixパスに変換できない場合、パスは変更されずに渡されるため、 &lt;code&gt;unixify(&quot;[...]&quot;)&lt;/code&gt; は &lt;code&gt;[...]&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="98ee4cd3c900fba7f346eaf4d73c2e59283171b2" translate="yes" xml:space="preserve">
          <source>The feature needs to be enabled with &lt;code&gt;Configure -Dusecbacktrace&lt;/code&gt; .</source>
          <target state="translated">この機能は &lt;code&gt;Configure -Dusecbacktrace&lt;/code&gt; で有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="e9967e9df7e264da6bcdb44f5aee030bc917d02a" translate="yes" xml:space="preserve">
          <source>The features you got from your mother and father, mixed together unpredictably. (See also &lt;b&gt;inheritance&lt;/b&gt; and &lt;b&gt;single inheritance&lt;/b&gt;.) In computer languages (including Perl), it is the notion that a given class may have multiple direct ancestors or &lt;b&gt;base classes&lt;/b&gt;.</source>
          <target state="translated">母親と父親から得られた機能は、予測不能に混在しています。（&lt;b&gt;継承&lt;/b&gt;と&lt;b&gt;単一継承&lt;/b&gt;も参照してください。）コンピューター言語（Perlを含む）では、特定のクラスに複数の直接の祖先または&lt;b&gt;基本クラス&lt;/b&gt;がある可能性があるという概念です。</target>
        </trans-unit>
        <trans-unit id="ddb61ef14874404dd766423660c7d397637ace24" translate="yes" xml:space="preserve">
          <source>The features you got from your mother, if she told you that you don&amp;rsquo;t have a father. (See also &lt;b&gt;inheritance&lt;/b&gt; and &lt;b&gt;multiple inheritance&lt;/b&gt;.) In computer languages, the idea that &lt;b&gt;classes&lt;/b&gt; reproduce asexually so that a given class can only have one direct ancestor or &lt;b&gt;base class&lt;/b&gt;. Perl supplies no such restriction, though you may certainly program Perl that way if you like.</source>
          <target state="translated">父親がいないと母親から言われた場合の、母親からの特徴。（&lt;b&gt;継承&lt;/b&gt;と&lt;b&gt;多重継承&lt;/b&gt;も参照してください。）コンピューター言語では、&lt;b&gt;クラスが&lt;/b&gt;無性に複製されるため、特定のクラスは1つの直接の祖先または&lt;b&gt;基本クラス&lt;/b&gt;のみを持つことができます。Perlにはそのような制限はありませんが、必要に応じてPerlをそのようにプログラミングすることもできます。</target>
        </trans-unit>
        <trans-unit id="3a3635eb281607d1f863de82b6a5a308964a4737" translate="yes" xml:space="preserve">
          <source>The field &quot;@*&quot; can be used for printing multi-line, nontruncated values; it should (but need not) appear by itself on a line. A final line feed is chomped off, but all other characters are emitted verbatim.</source>
          <target state="translated">フィールド &quot;@*&quot; は、複数行の、切り捨てられていない値を印刷するために使用することができます。最終的な改行は、切り捨てられますが、他のすべての文字はそのまま出力されます。</target>
        </trans-unit>
        <trans-unit id="38f6e6f64de0d391d989196e8ebb7ddb708ac60a" translate="yes" xml:space="preserve">
          <source>The fields are discussed in more detail below:</source>
          <target state="translated">分野については、以下で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="d21955b9d1337383a18b406fff73dac35d4d6488" translate="yes" xml:space="preserve">
          <source>The fields are tab-separated. The first column is the depth (zero being the innermost non-skipped frame). In the hex:offset, the hex is where the program counter was in S_parse_body, and the :offset (might be missing) tells how much inside the S_parse_body the program counter was.</source>
          <target state="translated">フィールドはタブで区切られています。最初のカラムは深さ(0はスキップされていない一番内側のフレーム)です。hex:offsetでは、16進数はS_parse_bodyの中でプログラムカウンタがどこにあったかを表し、:offsetは(見つからないかもしれませんが)S_parse_bodyの中でプログラムカウンタがどれくらいあったかを表しています。</target>
        </trans-unit>
        <trans-unit id="3aabcb5c5289f7ad819b54aa9417f88080d7fec5" translate="yes" xml:space="preserve">
          <source>The fields of interest which may appear in this line are</source>
          <target state="translated">この行に出てくる可能性のある分野は</target>
        </trans-unit>
        <trans-unit id="04fbc7508d5d457aedc840547581d13fb785d13c" translate="yes" xml:space="preserve">
          <source>The file</source>
          <target state="translated">ファイル</target>
        </trans-unit>
        <trans-unit id="99944ba23fa1671290cc70fdf7f917ecb5343db9" translate="yes" xml:space="preserve">
          <source>The file (name) the error occurred in.</source>
          <target state="translated">エラーが発生したファイル(名前)。</target>
        </trans-unit>
        <trans-unit id="74280467b06cd39e1ebe6f256e50f06eca04fcbe" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;perlio.c&lt;/code&gt; provides the following layers:</source>
          <target state="translated">&lt;code&gt;perlio.c&lt;/code&gt; ファイルは次のレイヤーを提供します：</target>
        </trans-unit>
        <trans-unit id="b4bb1e7661bc100161f83c2b2d4bc9930cd6bed6" translate="yes" xml:space="preserve">
          <source>The file MANIFEST.SKIP may contain regular expressions of files that should be ignored by mkmanifest() and filecheck(). The regular expressions should appear one on each line. Blank lines and lines which start with &lt;code&gt;#&lt;/code&gt; are skipped. Use &lt;code&gt;\#&lt;/code&gt; if you need a regular expression to start with a &lt;code&gt;#&lt;/code&gt; .</source>
          <target state="translated">ファイルMANIFEST.SKIPには、mkmanifest（）およびfilecheck（）で無視されるファイルの正規表現が含まれている場合があります。正規表現は各行に1つ表示されます。空白行と &lt;code&gt;#&lt;/code&gt; で始まる行はスキップされます。使用 &lt;code&gt;\#&lt;/code&gt; あなたが開始するために正規表現を必要とする場合 &lt;code&gt;#&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2791b558da2cb7ec65180cdaeb2459b7a1726fa1" translate="yes" xml:space="preserve">
          <source>The file Makefile.PL should look something like this:</source>
          <target state="translated">Makefile.PLファイルは以下のようになっているはずです。</target>
        </trans-unit>
        <trans-unit id="76e388baaf2a00fb72a8272cf31814ec70994241" translate="yes" xml:space="preserve">
          <source>The file Mytest.pm should start with something like this:</source>
          <target state="translated">Mytest.pmファイルは、以下のようなもので始まるはずです。</target>
        </trans-unit>
        <trans-unit id="a37078c2a2fb3ae7f022a61feee12e4a85c77a67" translate="yes" xml:space="preserve">
          <source>The file Unicode/Collate/allkeys.txt was copied verbatim from &lt;a href=&quot;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&lt;/a&gt;. For this file, Copyright (c) 2001-2012 Unicode, Inc. Distributed under the Terms of Use in &lt;a href=&quot;http://www.unicode.org/copyright.html&quot;&gt;http://www.unicode.org/copyright.html&lt;/a&gt;.</source>
          <target state="translated">ファイルUnicode / Collat​​e / allkeys.txtは、&lt;a href=&quot;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&quot;&gt;http://www.unicode.org/Public/UCA/6.3.0/allkeys.txt&lt;/a&gt;からそのままコピーされました。このファイルについては、著作権（c）2001-2012 Unicode、Inc . が&lt;a href=&quot;http://www.unicode.org/copyright.html&quot;&gt;http://www.unicode.org/copyright.htmlの&lt;/a&gt;利用規約に基づいて配布されています。</target>
        </trans-unit>
        <trans-unit id="1744236e794a4c53bf20da07fd1df8dc62fc8e81" translate="yes" xml:space="preserve">
          <source>The file is</source>
          <target state="translated">ファイルは</target>
        </trans-unit>
        <trans-unit id="79a42520a58ddeeb12292112f2a308b0310a0a00" translate="yes" xml:space="preserve">
          <source>The file is removed when the filehandle is closed or when the program exits. No access to the filename is provided.</source>
          <target state="translated">ファイルは、ファイルハンドルが閉じられたとき、またはプログラムが終了したときに削除されます。ファイル名へのアクセスは提供されません。</target>
        </trans-unit>
        <trans-unit id="5b68113e94418bbe01dba1e8408762baaba90492" translate="yes" xml:space="preserve">
          <source>The file must return true as the last statement to indicate successful execution of any initialization code, so it's customary to end such a file with &lt;code&gt;1;&lt;/code&gt; unless you're sure it'll return true otherwise. But it's better just to put the &lt;code&gt;1;&lt;/code&gt; , in case you add more statements.</source>
          <target state="translated">初期化コードが正常に実行されたことを示すために、ファイルは最後のステートメントとしてtrueを返す必要があるため、このようなファイルは &lt;code&gt;1;&lt;/code&gt; 終了するのが通例です。それ以外の場合はtrueを返すことが確実でない限り。しかし、 &lt;code&gt;1;&lt;/code&gt; を置く方が良いです。、ステートメントを追加する場合。</target>
        </trans-unit>
        <trans-unit id="cda785c206d1d83026d51c7970996f0a544bbd22" translate="yes" xml:space="preserve">
          <source>The file named in VERSION_FROM is not added as a dependency to Makefile. This is not really correct, but it would be a major pain during development to have to rewrite the Makefile for any smallish change in that file. If you want to make sure that the Makefile contains the correct VERSION macro after any change of the file, you would have to do something like</source>
          <target state="translated">VERSION_FROM で指定されたファイルは Makefile の依存関係として追加されません。これは実際には正しくありませんが、そのファイルの小さな変更のために Makefile を書き換えなければならないのは、開発中に大きな苦痛になります。ファイルを変更した後、Makefile に正しい VERSION マクロが含まれていることを確認したい場合は、次のようなことをしなければなりません。</target>
        </trans-unit>
        <trans-unit id="bdaf2cba4d9764ecdf7f47c7aa146b4c33b7bbf0" translate="yes" xml:space="preserve">
          <source>The file redirection characters &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, and &quot;|&quot; can be quoted by double quotes (although there are suggestions that this may not always be true). Single quotes are not treated as quotes by the shell or the C runtime, they don't get stripped by the shell (just to make this type of quoting completely useless). The caret &quot;^&quot; has also been observed to behave as a quoting character, but this appears to be a shell feature, and the caret is not stripped from the command line, so Perl still sees it (and the C runtime phase does not treat the caret as a quote character).</source>
          <target state="translated">ファイルリダイレクト文字「&amp;lt;」、「&amp;gt;」、および「|」二重引用符で囲むことができます（ただし、常にそうであるとは限らないという提案もあります）。単一引用符は、シェルまたはCランタイムでは引用符として扱われません。シェルによって取り除かれることはありません（このタイプの引用符を完全に無用にするため）。キャレット「^」も引用文字として動作することが確認されていますが、これはシェル機能のようであり、キャレットはコマンドラインから削除されないため、Perlはそれを認識します（Cランタイムフェーズでは処理されません）引用符としてのキャレット）。</target>
        </trans-unit>
        <trans-unit id="52fb6cb3aabc05d2c0113ff975b6b538671a53b3" translate="yes" xml:space="preserve">
          <source>The file returned by File::Temp will have been opened in binary mode if such a mode is available. If that is not correct, use the C</source>
          <target state="translated">File::Tempによって返されたファイルは、そのようなモードが利用可能な場合、バイナリモードで開かれています。それが正しくない場合は、C</target>
        </trans-unit>
        <trans-unit id="00c1f1869978b35696fb14c540a8ba10948b7605" translate="yes" xml:space="preserve">
          <source>The file type, or extension, is always present in a VMS-format file specification even if it's zero-length. This means that, by default, &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; will return a trailing dot on a file with no extension, so where you would see &lt;code&gt;&quot;a&quot;&lt;/code&gt; on Unix you'll see &lt;code&gt;&quot;a.&quot;&lt;/code&gt; on VMS. However, the trailing dot may be suppressed by enabling the &lt;code&gt;DECC$READDIR_DROPDOTNOTYPE&lt;/code&gt; feature in the environment (see the CRTL documentation on feature logical names).</source>
          <target state="translated">ファイルタイプまたは拡張子は、長さがゼロであっても、常にVMS形式のファイル仕様に存在します。つまり、デフォルトでは、 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; は拡張子のないファイルの末尾のドットを返すため、Unixで &lt;code&gt;&quot;a&quot;&lt;/code&gt; が表示される場所には「a」が表示されます &lt;code&gt;&quot;a.&quot;&lt;/code&gt; VMSで。ただし、環境で &lt;code&gt;DECC$READDIR_DROPDOTNOTYPE&lt;/code&gt; 機能を有効にすると、末尾のドットが抑制される場合があります（機能の論理名に関するCRTLのドキュメントを参照）。</target>
        </trans-unit>
        <trans-unit id="4023271c9fc7425e571468846ea1d383c9d49eba" translate="yes" xml:space="preserve">
          <source>The file types are:</source>
          <target state="translated">ファイルの種類は</target>
        </trans-unit>
        <trans-unit id="43719b35ec87acc604024ce99c0c8fb60624b26e" translate="yes" xml:space="preserve">
          <source>The file's mode</source>
          <target state="translated">ファイルのモード</target>
        </trans-unit>
        <trans-unit id="a95c16ea1ecea8120f9e1164c67484d409f61395" translate="yes" xml:space="preserve">
          <source>The file's name</source>
          <target state="translated">ファイル名</target>
        </trans-unit>
        <trans-unit id="4b9a5685b1075bc4b20ae964579e2b1d813d620d" translate="yes" xml:space="preserve">
          <source>The filehandle behaves normally for the parent, but I/O to that filehandle is piped from/to the STDOUT/STDIN of the child process. In the child process, the filehandle isn't opened--I/O happens from/to the new STDOUT/STDIN. Typically this is used like the normal piped open when you want to exercise more control over just how the pipe command gets executed, such as when running setuid and you don't want to have to scan shell commands for metacharacters.</source>
          <target state="translated">ファイルハンドルは親プロセスでは正常に動作しますが、そのファイルハンドルへのI/Oは子プロセスのSTDOUT/STDINから/へパイプされます。子プロセスでは、ファイルハンドルはオープンされません --I/Oは新しいSTDOUT/STDINとの間で行われます。通常、これは通常のパイプオープンのように、パイプコマンドがどのように実行されるかをより制御したい場合に使用されます。例えば、setuid を実行していて、メタキャラクタのためにシェルコマンドをスキャンする必要がない場合などです。</target>
        </trans-unit>
        <trans-unit id="82d3d5cbabb04fbe3144e08782ff5dbb8eaf643d" translate="yes" xml:space="preserve">
          <source>The filehandle will be closed when its reference count reaches zero. If it is a lexically scoped variable declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, that usually means the end of the enclosing scope. However, this automatic close does not check for errors, so it is better to explicitly close filehandles, especially those used for writing:</source>
          <target state="translated">参照カウントがゼロに達すると、ファイルハンドルは閉じられます。それが &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; で宣言されたレキシカルスコープの変数である場合、それは通常、囲んでいるスコープの終わりを意味します。ただし、この自動クローズはエラーをチェックしないため、ファイルハンドル、特に書き込みに使用されるものを明示的にクローズすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c6da7495029a8eadd3a9c0429778422e3ffb1d61" translate="yes" xml:space="preserve">
          <source>The filehandle will be closed when its reference count reaches zero. If it is a lexically scoped variable declared with &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, that usually means the end of the enclosing scope. However, this automatic close does not check for errors, so it is better to explicitly close filehandles, especially those used for writing:</source>
          <target state="translated">参照カウントがゼロに達すると、ファイルハンドルは閉じられます。それが &lt;code&gt;&lt;a href=&quot;my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; で宣言されたレキシカルスコープの変数である場合、それは通常、囲んでいるスコープの終わりを意味します。ただし、この自動クローズはエラーをチェックしないため、ファイルハンドル、特に書き込みに使用されるものを明示的にクローズすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f157c14e0e96a0cb19a8e1a0df5c9ee87ca4b5e2" translate="yes" xml:space="preserve">
          <source>The filehandles STDIN, STDOUT, and STDERR are predefined. (The filehandles &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stdout&lt;/code&gt; , and &lt;code&gt;stderr&lt;/code&gt; will also work except in packages, where they would be interpreted as local identifiers rather than global.) Additional filehandles may be created with the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; function, amongst others. See &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt; and &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for details on this.</source>
          <target state="translated">ファイルハンドルSTDIN、STDOUT、およびSTDERRは事前定義されています。（ファイルハンドル &lt;code&gt;stdin&lt;/code&gt; 、 &lt;code&gt;stdout&lt;/code&gt; 、および &lt;code&gt;stderr&lt;/code&gt; も、パッケージがグローバルではなくローカル識別子として解釈される場合を除いて機能します。） &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 関数などを使用して、追加のファイルハンドルを作成できます。参照&lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;と&lt;a href=&quot;functions/open&quot;&gt;開く&lt;/a&gt;この詳細については。</target>
        </trans-unit>
        <trans-unit id="586bcd238ccd4b9fecd344d54e37e9531bdb9cd2" translate="yes" xml:space="preserve">
          <source>The filehandles may also be integers, in which case they are understood as file descriptors.</source>
          <target state="translated">ファイルハンドルは整数である場合もあり、その場合はファイルディスクリプタとして理解されます。</target>
        </trans-unit>
        <trans-unit id="66a7978092f9f45d843d817f4a627ae3fdb00a8b" translate="yes" xml:space="preserve">
          <source>The filename of the data store holding the data that App::Prove::State reads.</source>
          <target state="translated">App::Prove::Stateが読み込んだデータを保持するデータストアのファイル名。</target>
        </trans-unit>
        <trans-unit id="6d594502076d5702a51ff03f260fd4c765a898ae" translate="yes" xml:space="preserve">
          <source>The filename of the perllibrary that will be used together with this extension. Defaults to libperl.a.</source>
          <target state="translated">この拡張モジュールと一緒に使用される perllibrary のファイル名。デフォルトは libperl.a です。</target>
        </trans-unit>
        <trans-unit id="d9b0656face1bd799f2d3aeeb4a33e8ccdb99fbf" translate="yes" xml:space="preserve">
          <source>The filename passed to the one- and two-argument forms of open() will have leading and trailing whitespace deleted and normal redirection characters honored. This property, known as &quot;magic open&quot;, can often be used to good effect. A user could specify a filename of</source>
          <target state="translated">open()の 1 つまたは 2 つの引数形式に渡されたファイル名は、先頭と末尾の空白が削除され、通常のリダイレクト文字が優先されます。このプロパティは &quot;マジックオープン&quot; として知られており、しばしば効果的に使用することができます。ユーザは、ファイル名として</target>
        </trans-unit>
        <trans-unit id="6d720ff4e8b207a8fa86d2d1f6ed053fe36cb247" translate="yes" xml:space="preserve">
          <source>The files</source>
          <target state="translated">ファイル</target>
        </trans-unit>
        <trans-unit id="5e8ac4ea16fdec255bb3d994323e38344f15cd1a" translate="yes" xml:space="preserve">
          <source>The files in the &quot;qnx&quot; directory are:</source>
          <target state="translated">qnx」ディレクトリにあるファイルは、以下の通りです。</target>
        </trans-unit>
        <trans-unit id="ccf1a34f9c5304eccd7056360fe19cfcc880dfc0" translate="yes" xml:space="preserve">
          <source>The filesystem may support neither access timestamp nor change timestamp (meaning that about the only portable timestamp is the modification timestamp), or one second granularity of any timestamps (e.g. the FAT filesystem limits the time granularity to two seconds).</source>
          <target state="translated">ファイルシステムはアクセスタイムスタンプも変更タイムスタンプもサポートしていません(つまり、ポータブルなタイムスタンプは変更タイムスタンプだけです)。</target>
        </trans-unit>
        <trans-unit id="4acc2f4b822151bd730e57f84d225c79d062f507" translate="yes" xml:space="preserve">
          <source>The filesystem may support neither hard links (&lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt;) nor symbolic links (&lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">ファイルシステムは、ハードリンク（ &lt;code&gt;&lt;a href=&quot;functions/link&quot;&gt;link&lt;/a&gt;&lt;/code&gt; ）もシンボリックリンク（ &lt;code&gt;&lt;a href=&quot;functions/symlink&quot;&gt;symlink&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/readlink&quot;&gt;readlink&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/lstat&quot;&gt;lstat&lt;/a&gt;&lt;/code&gt; ）もサポートしない場合があります。</target>
        </trans-unit>
        <trans-unit id="15629c3f6edb637003db8544e5aa317bc95e5e82" translate="yes" xml:space="preserve">
          <source>The filesystem of Symbian devices uses DOSish syntax, &quot;drives&quot; separated from paths by a colon, and backslashes for the path. The exact assignment of the drives probably varies between platforms, but for example in Series 60 you might see C: as the (flash) main memory, D: as the RAM drive, E: as the memory card (MMC), Z: as the ROM. In Series 80 D: is the memory card. As far the devices go the NUL: is the bit bucket, the COMx: are the serial lines, IRCOMx: are the IR ports, TMP: might be C:\System\Temp. Remember to double those backslashes in doublequoted strings.</source>
          <target state="translated">Symbian デバイスのファイルシステムは、DOS のような構文を使用し、「ドライブ」はコロンでパスから分離され、パスにはバックスラッシュを使用します。ドライブの正確な割り当ては、おそらくプラットフォームによって異なりますが、例えば60シリーズでは、C:(フラッシュ)メインメモリ、D:RAMドライブ、E:メモリカード(MMC)、Z:ROMと表示されます。シリーズ80ではD:がメモリカードとなります。デバイスとしては、NUL:はビットバケット、COMx:はシリアルライン、IRCOMx:はIRポート、TMP:はC:かもしれません。ダブルクォートで囲まれた文字列では、バックスラッシュを二重にすることを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="60abfd860ab77072c0ffed33f686231d933f221b" translate="yes" xml:space="preserve">
          <source>The filetest operators &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; are not implemented, as they require more information than just a stat buffer.</source>
          <target state="translated">filetest演算子 &lt;code&gt;-t&lt;/code&gt; 、 &lt;code&gt;-T&lt;/code&gt; 、および &lt;code&gt;-B&lt;/code&gt; は、単なるstatバッファーよりも多くの情報を必要とするため、実装されていません。</target>
        </trans-unit>
        <trans-unit id="a32f19af093b1f7fb24c634263035e297b5a2ba3" translate="yes" xml:space="preserve">
          <source>The filter ensures that Perl parses the code between the &amp;lt;DEBUG_BEGIN&amp;gt; and &lt;code&gt;DEBUG_END&lt;/code&gt; markers only when the &lt;code&gt;DEBUG&lt;/code&gt; environment variable exists. That means that when &lt;code&gt;DEBUG&lt;/code&gt; does exist, the code above should be passed through the filter unchanged. The marker lines can also be passed through as-is, because the Perl parser will see them as comment lines. When &lt;code&gt;DEBUG&lt;/code&gt; isn't set, we need a way to disable the debug code. A simple way to achieve that is to convert the lines between the two markers into comments:</source>
          <target state="translated">フィルターは、 &lt;code&gt;DEBUG&lt;/code&gt; 環境変数が存在する場合にのみ、Perlが&amp;lt;DEBUG_BEGIN&amp;gt; マーカーと &lt;code&gt;DEBUG_END&lt;/code&gt; マーカーの間のコードを解析するようにします。つまり、 &lt;code&gt;DEBUG&lt;/code&gt; が存在する場合、上記のコードは変更されずにフィルターを通過する必要があります。 Perlパーサーはマーカー行をコメント行として認識するため、マーカー行をそのまま渡すこともできます。 &lt;code&gt;DEBUG&lt;/code&gt; が設定されていない場合、デバッグコードを無効にする方法が必要です。これを実現する簡単な方法は、2つのマーカー間の行をコメントに変換することです。</target>
        </trans-unit>
        <trans-unit id="3cfa6a6fd2754ac19a694b001066c8361c789aec" translate="yes" xml:space="preserve">
          <source>The filter included are:</source>
          <target state="translated">付属のフィルターは</target>
        </trans-unit>
        <trans-unit id="06dac022e678c85372a6fa4a8e6e10c155086a90" translate="yes" xml:space="preserve">
          <source>The filter is applied to</source>
          <target state="translated">にフィルターを適用しています。</target>
        </trans-unit>
        <trans-unit id="6311b9692024a04fd6e913eb59f189ec85a241cf" translate="yes" xml:space="preserve">
          <source>The filter is applied to the key</source>
          <target state="translated">フィルタは、キー</target>
        </trans-unit>
        <trans-unit id="edd6196707ee8763311d3aafd47d83821af190dd" translate="yes" xml:space="preserve">
          <source>The filter is applied to the value</source>
          <target state="translated">フィルタが適用されるのは</target>
        </trans-unit>
        <trans-unit id="6693f0e2b9229e67ead2ac6746c8771a8ed55fa9" translate="yes" xml:space="preserve">
          <source>The final &lt;code&gt;PUTBACK&lt;/code&gt; is used to leave the Perl stack in a consistent state before exiting the function. This is necessary because when we popped the return value from the stack with &lt;code&gt;POPi&lt;/code&gt; it updated only our local copy of the stack pointer. Remember, &lt;code&gt;PUTBACK&lt;/code&gt; sets the global stack pointer to be the same as our local copy.</source>
          <target state="translated">最後の &lt;code&gt;PUTBACK&lt;/code&gt; は、関数を終了する前にPerlスタックを一貫した状態にしておくために使用されます。これは、 &lt;code&gt;POPi&lt;/code&gt; を使用してスタックから戻り値をポップしたときに、スタックポインターのローカルコピーのみを更新したためです。覚えておいて、 &lt;code&gt;PUTBACK&lt;/code&gt; は、私たちのローカルコピーと同じになるようにグローバルなスタックポインタを設定します。</target>
        </trans-unit>
        <trans-unit id="6d574089f345d41e6ac1476fc2b80885aa410f07" translate="yes" xml:space="preserve">
          <source>The final character can't be a hyphen, colon, or period. URLs ending with these characters, while allowed by XHTML, can be awkward to extract from plain text.</source>
          <target state="translated">最後の文字はハイフン、コロン、ピリオドにすることはできません。これらの文字で終わるURLは、XHTMLでは許可されていますが、プレーンテキストから抽出するのは厄介です。</target>
        </trans-unit>
        <trans-unit id="0a99e11f3a928dd6413c811829c3b9af3764501f" translate="yes" xml:space="preserve">
          <source>The final difference between regular bracketed character classes and these, is that it is not possible to get these to match a multi-character fold. Thus,</source>
          <target state="translated">通常の括弧付き文字クラスとこれらとの最終的な違いは、これらを複数文字の折り返しに一致させることができないということです。したがって、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="cde87782285bb08650f77bdd2e4ce0e06adc25ff" translate="yes" xml:space="preserve">
          <source>The final element of a list assignment may be an array or a hash:</source>
          <target state="translated">リスト代入の最後の要素は配列かハッシュになります。</target>
        </trans-unit>
        <trans-unit id="b74663d384e88ec12c85ff6a9f4b23592b8a3858" translate="yes" xml:space="preserve">
          <source>The final line (with Index [242]) means that the value for all code points above the legal Unicode maximum code point have the value &quot;No_Block&quot;, which is the term Unicode uses for a non-existing block.</source>
          <target state="translated">最後の行(インデックス [242]を持つ)は、法定 Unicode 最大コードポイント以上のすべてのコードポイントの値が、Unicode が既存でないブロックに対して使う用語である値 &quot;No_Block&quot; を持つことを意味しています。</target>
        </trans-unit>
        <trans-unit id="e6811c076957053b2764757de731f2de38b4111a" translate="yes" xml:space="preserve">
          <source>The final operation uses the backslash character to invalidate the special meaning of an open square bracket &lt;code&gt;[&lt;/code&gt;, the asterisk, backslash or the question mark. Two backslashes in sequence will result in the evaluation of the backslash as a character with no special meaning.</source>
          <target state="translated">最後の操作では、バックスラッシュ文字を使用して、開き角括弧 &lt;code&gt;[&lt;/code&gt; 、アスタリスク、バックスラッシュ、または疑問符の特別な意味を無効にします。円記号を2つ続けて使用すると、円記号は特別な意味のない文字として評価されます。</target>
        </trans-unit>
        <trans-unit id="be0c78c80ebce8da51fa36633d30ae64f567f49f" translate="yes" xml:space="preserve">
          <source>The final semicolon in a block is optional, as is the final comma in a list. Good style (see &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;) says to put them in except for one-liners:</source>
          <target state="translated">リストの最後のコンマと同様に、ブロックの最後のセミコロンはオプションです。良いスタイル（&lt;a href=&quot;perlstyle&quot;&gt;perlstyleを&lt;/a&gt;参照）は、ワンライナーを除いてそれらを入れるように言っています：</target>
        </trans-unit>
        <trans-unit id="16f205f9e57e8503952af3471732d873e8a9fc93" translate="yes" xml:space="preserve">
          <source>The final semicolon, if any, may be omitted from the value of EXPR or within the BLOCK.</source>
          <target state="translated">最後のセミコロンがある場合は、EXPRの値から、またはBLOCK内では省略することができます。</target>
        </trans-unit>
        <trans-unit id="3ee4566a0600358ccd1fe8d6c5a93a6cd48a9d99" translate="yes" xml:space="preserve">
          <source>The final stage is to call &lt;code&gt;test_test&lt;/code&gt; that will simply compare what you predeclared to what &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; actually outputted, and report the results back with a &quot;ok&quot; or &quot;not ok&quot; (with debugging) to the normal output.</source>
          <target state="translated">最後の段階では、 &lt;code&gt;test_test&lt;/code&gt; を呼び出して、事前に宣言した内容と実際に&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;が出力した内容を比較し、結果を「ok」または「not ok」（デバッグ付き）で通常の出力に報告します。</target>
        </trans-unit>
        <trans-unit id="31473d1a074747714a49e0fc3e7edd46729c2ea4" translate="yes" xml:space="preserve">
          <source>The final step involves passing each filename matched by the &lt;code&gt;*.tar.gz&lt;/code&gt; file glob through the derived Perl regular expression in turn and expanding the output fileglob using it.</source>
          <target state="translated">最後のステップでは、 &lt;code&gt;*.tar.gz&lt;/code&gt; 。tar.gzファイルグロブに一致する各ファイル名を、派生したPerl正規表現に渡し、それを使用して出力ファイルグロブを拡張します。</target>
        </trans-unit>
        <trans-unit id="d96d9b1e4edc6c2a13a6362b88a7c6a709b1d43c" translate="yes" xml:space="preserve">
          <source>The final two modifiers we will discuss here, &lt;code&gt;//g&lt;/code&gt; and &lt;code&gt;//c&lt;/code&gt; , concern multiple matches. The modifier &lt;code&gt;//g&lt;/code&gt; stands for global matching and allows the matching operator to match within a string as many times as possible. In scalar context, successive invocations against a string will have &lt;code&gt;//g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">ここで説明する最後の2つの修飾子 &lt;code&gt;//g&lt;/code&gt; と &lt;code&gt;//c&lt;/code&gt; は、複数の一致に関係します。修飾子 &lt;code&gt;//g&lt;/code&gt; はグローバルマッチングを表し、マッチングオペレーターが文字列内で可能な限り何度でもマッチングできるようにします。スカラーコンテキストでは、文字列に対して連続して呼び出しを行うと、文字列内の位置を追跡しながら &lt;code&gt;//g&lt;/code&gt; が一致から一致へジャンプします。 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 関数で位置を取得または設定できます。</target>
        </trans-unit>
        <trans-unit id="69b0c89da94c5764d6322358005c665b7a6ec505" translate="yes" xml:space="preserve">
          <source>The final, fourth element (index [3], assigned to &lt;code&gt;$default&lt;/code&gt; in the &quot;block&quot; example) in the four element list returned by this function is used with the &lt;code&gt;&quot;a&quot;&lt;/code&gt; format types; it may also be useful for applications that wish to convert the returned inversion map data structure into some other, such as a hash. It gives the mapping that most code points map to under the property. If you establish the convention that any code point not explicitly listed in your data structure maps to this value, you can potentially make your data structure much smaller. As you construct your data structure from the one returned by this function, simply ignore those ranges that map to this value. For example, to convert to the data structure searchable by &lt;a href=&quot;#charinrange()&quot;&gt;charinrange()&lt;/a&gt;, you can follow this recipe for properties that don't require adjustments:</source>
          <target state="translated">この関数によって返される4つの要素リストの最後の4番目の要素（「ブロック」の例では &lt;code&gt;$default&lt;/code&gt; に割り当てられている）は、 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 形式タイプで使用されます。また、返された反転マップデータ構造をハッシュなどの他のいくつかに変換したいアプリケーションにも役立ちます。ほとんどのコードポイントがプロパティの下にマップするマッピングを提供します。データ構造に明示的にリストされていないコードポイントがこの値にマップするという規則を確立すると、データ構造を大幅に小さくできる可能性があります。この関数によって返されるデータ構造からデータ構造を構築するときは、この値にマップされる範囲を単に無視してください。たとえば、&lt;a href=&quot;#charinrange()&quot;&gt;charinrange（）で&lt;/a&gt;検索可能なデータ構造に変換するには、調整を必要としないプロパティについては、このレシピに従うことができます。</target>
        </trans-unit>
        <trans-unit id="20c1b5c18477e5291b6b00c55abb0e8a3b781429" translate="yes" xml:space="preserve">
          <source>The find_dup() Method</source>
          <target state="translated">find_dup()メソッド</target>
        </trans-unit>
        <trans-unit id="a4105f4f4646c65f036c1e5edea46eddb3a8418a" translate="yes" xml:space="preserve">
          <source>The first (and now failed) goal of Unicode was to map all character repertoires into a fixed-length integer so that programmers are happy. Since each character is either a</source>
          <target state="translated">ユニコードの最初の(今では失敗した)目標は、プログラマが満足できるように、すべての文字のレパートリーを固定長の整数にマッピングすることでした。各文字は</target>
        </trans-unit>
        <trans-unit id="172226a1c7ce5a6d06797585142c70179c0ec58b" translate="yes" xml:space="preserve">
          <source>The first &lt;b&gt;PAUSE&lt;/b&gt; author to upload a &lt;b&gt;namespace&lt;/b&gt; automatically becomes the &lt;b&gt;primary maintainer&lt;/b&gt; for that namespace. The &amp;ldquo;first come&amp;rdquo; permissions distinguish a &lt;b&gt;primary maintainer&lt;/b&gt; who was assigned that role from one who received it automatically.</source>
          <target state="translated">&lt;b&gt;名前空間&lt;/b&gt;をアップロードした最初の&lt;b&gt;PAUSE作成&lt;/b&gt;者は、自動的にその名前空間の&lt;b&gt;主要なメンテナ&lt;/b&gt;になります。「先着」権限は、そのロールが割り当てられた&lt;b&gt;メインのメンテナ&lt;/b&gt;と、自動的にそれを受け取った&lt;b&gt;メンテナ&lt;/b&gt;を区別します。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="97526a10437e54c9f14361d8f57177e27604beab" translate="yes" xml:space="preserve">
          <source>The first Perl argument to this function would be treated as a char and assigned to the variable a, and its address would be passed into the function foo. The second Perl argument would be treated as a string pointer and assigned to the variable b. The</source>
          <target state="translated">この関数へのPerlの最初の引数はcharとして扱われ、変数aに代入され、そのアドレスは関数fooに渡されます。2 番目の Perl の引数は文字列ポインタとして扱われ、変数 b に代入されます。</target>
        </trans-unit>
        <trans-unit id="e5e4f6464deede9ad4eff50e6de5039522d07e08" translate="yes" xml:space="preserve">
          <source>The first and second arguments may be strings, typeglobs, typeglob references, or objects inheriting from IO::Handle; they are used in all cases to obtain the</source>
          <target state="translated">第一引数と第二引数は文字列、タイプグローブ、タイプグローブ参照、IO::Handleから継承したオブジェクトのいずれかである可能性があります。</target>
        </trans-unit>
        <trans-unit id="f11ee434e9fca49f11d7860f46bcba7e793d3dea" translate="yes" xml:space="preserve">
          <source>The first and second forms explicitly identify the name of the class being created. The third form assumes the current package name as the class name.</source>
          <target state="translated">1 番目と 2 番目のフォームでは、作成されるクラスの名前を明示的に指定します。第三の形式では、現在のパッケージ名をクラス名とします。</target>
        </trans-unit>
        <trans-unit id="1490a2bc188cd4f0f1d7d40df76c523f30ba9b64" translate="yes" xml:space="preserve">
          <source>The first argument &lt;code&gt;pointer&lt;/code&gt; should be the name of a variable that will point to the newly allocated memory.</source>
          <target state="translated">最初の引数 &lt;code&gt;pointer&lt;/code&gt; は、新しく割り当てられたメモリを指す変数の名前である必要があります。</target>
        </trans-unit>
        <trans-unit id="4f43aa625d664f2ba3718ef0a1149ca5df8580dd" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;code&gt;setlocale()&lt;/code&gt; gives the &lt;b&gt;category&lt;/b&gt;, the second the &lt;b&gt;locale&lt;/b&gt;. The category tells in what aspect of data processing you want to apply locale-specific rules. Category names are discussed in &lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;LOCALE CATEGORIES&lt;/a&gt; and &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt;. The locale is the name of a collection of customization information corresponding to a particular combination of language, country or territory, and codeset. Read on for hints on the naming of locales: not all systems name locales as in the example.</source>
          <target state="translated">最初の引数 &lt;code&gt;setlocale()&lt;/code&gt; 与え&lt;b&gt;カテゴリ&lt;/b&gt;、第二&lt;b&gt;のロケールを&lt;/b&gt;。カテゴリは、ロケール固有のルールを適用するデータ処理の側面を示します。カテゴリー名については、&lt;a href=&quot;#LOCALE-CATEGORIES&quot;&gt;LOCALE CATEGORIES&lt;/a&gt;および&lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENTで&lt;/a&gt;説明します。ロケールは、言語、国または地域、およびコードセットの特定の組み合わせに対応するカスタマイズ情報のコレクションの名前です。ロケールの命名に関するヒントを読んでください。例のようにすべてのシステムがロケールに名前を付けるわけではありません。</target>
        </trans-unit>
        <trans-unit id="7d7b3a91ac2b665d00253c60dfd683fd8e3981ca" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;find()&lt;/code&gt; is either a code reference to your &lt;code&gt;&amp;amp;wanted&lt;/code&gt; function, or a hash reference describing the operations to be performed for each file. The code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;The wanted function&lt;/a&gt; below.</source>
          <target state="translated">&lt;code&gt;find()&lt;/code&gt; の最初の引数は、 &lt;code&gt;&amp;amp;wanted&lt;/code&gt; 関数へのコード参照、または各ファイルに対して実行される操作を説明するハッシュ参照です。コードリファレンスについては、以下の&lt;a href=&quot;#The-wanted-function&quot;&gt;「必要な関数」で&lt;/a&gt;説明しています。</target>
        </trans-unit>
        <trans-unit id="4cbf5c859ede86efd02d67b5ed562cbefaa9fa86" translate="yes" xml:space="preserve">
          <source>The first call creates a mortal SV (with no value), the second converts an existing SV to a mortal SV (and thus defers a call to &lt;code&gt;SvREFCNT_dec&lt;/code&gt; ), and the third creates a mortal copy of an existing SV. Because &lt;code&gt;sv_newmortal&lt;/code&gt; gives the new SV no value, it must normally be given one via &lt;code&gt;sv_setpv&lt;/code&gt; , &lt;code&gt;sv_setiv&lt;/code&gt; , etc. :</source>
          <target state="translated">最初の呼び出しは致命的なSV（値なし）を作成し、2番目の呼び出しは既存のSVを致命的なSVに変換し（したがって &lt;code&gt;SvREFCNT_dec&lt;/code&gt; の呼び出しを延期します）、3番目の呼び出しは既存のSVの致命的なコピーを作成します。ので &lt;code&gt;sv_newmortal&lt;/code&gt; は、新しいSVに何も値を与えていない、それは通常を通じて1を与えられなければならない &lt;code&gt;sv_setpv&lt;/code&gt; 、 &lt;code&gt;sv_setiv&lt;/code&gt; など、：</target>
        </trans-unit>
        <trans-unit id="4477498f36568777dd7d39a288f8eb78c180c0b5" translate="yes" xml:space="preserve">
          <source>The first call will cache the result, say 37, in the scalar cache; the second will cach the list &lt;code&gt;(37)&lt;/code&gt; in the list cache. The third call doesn't call the real &lt;code&gt;complicated&lt;/code&gt; function; it gets the value 37 from the scalar cache.</source>
          <target state="translated">最初の呼び出しは、結果（37など）をスカラーキャッシュにキャッシュします。 2番目は、リスト &lt;code&gt;(37)&lt;/code&gt; をリストキャッシュにキャッシュします。 3番目の呼び出しは、実際の &lt;code&gt;complicated&lt;/code&gt; 関数を呼び出しません。スカラーキャッシュから値37を取得します。</target>
        </trans-unit>
        <trans-unit id="cb2fb10ae2990b48a149ecb6c3ef672018aecbe1" translate="yes" xml:space="preserve">
          <source>The first call-back registered is the call back for waiting. It is expected that the callback will call the current event loop until there is something waiting to get on the input filehandle. The parameter passed in is the return value of the second call back.</source>
          <target state="translated">最初に登録されたコールバックは、待ち受けのコールバックです。このコールバックは、入力されたファイルハンドルに何か待ち受けがあるまで、現在のイベントループを呼び出すことが期待されます。渡されたパラメータは、2番目のコールバックの戻り値です。</target>
        </trans-unit>
        <trans-unit id="98e0061b9a6b011cebcff05349c5ac1b63fa9755" translate="yes" xml:space="preserve">
          <source>The first code point of the foldcased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">foldcased版の最初のコードポイントが返されます(ただし、上記で説明したように、もっとあるかもしれないことに注意してください)。</target>
        </trans-unit>
        <trans-unit id="bff810cbc1a30c3df94411ded7219d0513e8678c" translate="yes" xml:space="preserve">
          <source>The first code point of the lowercased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">ローカスケード版の最初のコードポイントが返されます(ただし、上記で説明したように、もっとあるかもしれないことに注意してください)。</target>
        </trans-unit>
        <trans-unit id="caeb3f58f789aa5ac3e09cf711fff7133bd0293e" translate="yes" xml:space="preserve">
          <source>The first code point of the titlecased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">titlecased版の最初のコードポイントが返されます(ただし、上記で説明したように、もっとあるかもしれないことに注意)。</target>
        </trans-unit>
        <trans-unit id="150061371074e1d388cb756c8513ea3bae095580" translate="yes" xml:space="preserve">
          <source>The first code point of the uppercased version is returned (but note, as explained just above, that there may be more.)</source>
          <target state="translated">最初のコードポイントである大文字版のコードポイントが返されます(ただし、上記で説明したように、もっとあるかもしれないことに注意してください)。</target>
        </trans-unit>
        <trans-unit id="b31a69e396cbea336ac162c9e038d50204a60559" translate="yes" xml:space="preserve">
          <source>The first column gives the Unicode code point of the character (in hex format), the second column gives the (Unicode) name. The third column indicates by which class(es) the character is matched (assuming no locale is in effect that changes the &lt;code&gt;\s&lt;/code&gt; matching).</source>
          <target state="translated">最初の列は文字のUnicodeコードポイント（16進形式）を示し、2番目の列は（Unicode）名を示します。 3番目の列は、どのクラスによって文字が一致するかを示します（ &lt;code&gt;\s&lt;/code&gt; 一致を変更するロケールが有効になっていないと想定）。</target>
        </trans-unit>
        <trans-unit id="8beadb10ab71cda6dd02fa1a65287381a215cc85" translate="yes" xml:space="preserve">
          <source>The first column in the table is a name for the property; the second column is an alternative name, if any, plus possibly some annotations. The alternative name is the property's full name, unless that would simply repeat the first column, in which case the second column indicates the property's short name (if different). The annotations are given only in the entry for the full name. If a property is obsolete, etc, the entry will be flagged with the same characters used in the table in the &lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;section above&lt;/a&gt;, like &lt;b&gt;D&lt;/b&gt; or &lt;b&gt;S&lt;/b&gt;.</source>
          <target state="translated">テーブルの最初の列はプロパティの名前です。2列目は代替名（ある場合）と、おそらくいくつかの注釈です。代替名は、プロパティの完全な名前です。ただし、最初の列が単純に繰り返される場合を除きます。その場合、2番目の列はプロパティの短い名前（異なる場合）を示します。注釈は、氏名のエントリでのみ指定されます。プロパティが廃止された場合など、エントリには、&lt;b&gt;D&lt;/b&gt;や&lt;b&gt;S&lt;/b&gt;など、&lt;a href=&quot;#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;上記&lt;/a&gt;のセクションの表で使用されているのと同じ文字でフラグが付けられます。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6b11168c63a090c6a2f9c94f928cd13ec49996f7" translate="yes" xml:space="preserve">
          <source>The first command sends both standard out and standard error to the temporary file. The second command sends only the old standard output there, and the old standard error shows up on the old standard out.</source>
          <target state="translated">最初のコマンドは、標準出力と標準エラーの両方を一時ファイルに送ります。2 番目のコマンドはそこに古い標準出力だけを送り、古い標準エラーは古い標準出力に表示されます。</target>
        </trans-unit>
        <trans-unit id="05c623db7c7d3a79e0f86ce6c1022ffde1e91677" translate="yes" xml:space="preserve">
          <source>The first element of @os_flavor is the major family (ie. Unix, Windows, VMS, OS/2, etc...) and the rest are sub families.</source>
          <target state="translated">OS_flavorの最初の要素はメジャーファミリー(Unix、Windows、VMS、OS/2など)で、残りはサブファミリーです。</target>
        </trans-unit>
        <trans-unit id="4b34621cb98b9f5d1895e9bf56ac10c10fa486de" translate="yes" xml:space="preserve">
          <source>The first example will be driven by an object of the class CPAN::Module, the second by an object of class CPAN::Distribution.</source>
          <target state="translated">最初の例は、クラス CPAN::Module のオブジェクトによって、2番目の例はクラス CPAN::Distribution のオブジェクトによって駆動されます。</target>
        </trans-unit>
        <trans-unit id="0a27c7509a2d370dd780c83c9db9ebfcd9028447" translate="yes" xml:space="preserve">
          <source>The first extension is an embedded comment &lt;code&gt;(?#text)&lt;/code&gt;. This embeds a comment into the regular expression without affecting its meaning. The comment should not have any closing parentheses in the text. An example is</source>
          <target state="translated">最初の拡張子は埋め込みコメント &lt;code&gt;(?#text)&lt;/code&gt; です。これは、その意味に影響を与えずにコメントを正規表現に埋め込みます。コメントのテキストに閉じ括弧を含めないでください。例は</target>
        </trans-unit>
        <trans-unit id="222cb4b3d3e8dffe112445249bb168e941db04b2" translate="yes" xml:space="preserve">
          <source>The first extra instruction sets DJGPP's FNCASE environment variable so that the new perl binary which you must build for an XS-type module will build correctly. The second extra instruction re-builds the perl binary in your module directory before you run &quot;make test&quot;, so that you are testing with the new module code you built with &quot;make&quot;. The third extra instruction installs the perl binary from your module directory into the standard DJGPP binary directory, &lt;code&gt;($DJDIR)/bin&lt;/code&gt; , replacing your previous perl binary.</source>
          <target state="translated">最初の追加の命令は、DJGPPのFNCASE環境変数を設定して、XSタイプのモジュール用にビルドする必要がある新しいperlバイナリが正しくビルドされるようにします。 2番目の追加の命令は、「make test」を実行する前にモジュールディレクトリにperlバイナリを再構築し、「make」で構築した新しいモジュールコードでテストするようにします。 3番目の追加の命令は、perlバイナリをモジュールディレクトリから標準のDJGPPバイナリディレクトリ &lt;code&gt;($DJDIR)/bin&lt;/code&gt; にインストールし、以前のperlバイナリを置き換えます。</target>
        </trans-unit>
        <trans-unit id="34b17d18688be07602898309d70943af3ccee567" translate="yes" xml:space="preserve">
          <source>The first few members of the struct give a function table size for compatibility check &quot;name&quot; for the layer, the size to &lt;code&gt;malloc&lt;/code&gt; for the per-instance data, and some flags which are attributes of the class as whole (such as whether it is a buffering layer), then follow the functions which fall into four basic groups:</source>
          <target state="translated">構造体の最初のいくつかのメンバーは、レイヤーの互換性チェック「名前」の関数テーブルのサイズ、インスタンスごとのデータの &lt;code&gt;malloc&lt;/code&gt; のサイズ、およびクラス全体の属性であるいくつかのフラグ（それがバッファリング層）、次に、4つの基本グループに分類される機能に従います。</target>
        </trans-unit>
        <trans-unit id="5570358324850dc9a5c098d989e656b82d59427c" translate="yes" xml:space="preserve">
          <source>The first five of these are like the escape sequences &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\U&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , and &lt;code&gt;\F&lt;/code&gt; . For Titlecase, see &lt;a href=&quot;#Titlecase&quot;&gt;Titlecase&lt;/a&gt;; For Foldcase, see &lt;a href=&quot;#Foldcase&quot;&gt;Foldcase&lt;/a&gt;.</source>
          <target state="translated">これらの最初の5つは、エスケープシーケンス &lt;code&gt;\L&lt;/code&gt; 、 &lt;code&gt;\l&lt;/code&gt; 、 &lt;code&gt;\U&lt;/code&gt; 、 &lt;code&gt;\u&lt;/code&gt; 、および &lt;code&gt;\F&lt;/code&gt; 似ています。タイトル文字については、&lt;a href=&quot;#Titlecase&quot;&gt;タイトル文字を&lt;/a&gt;。Foldcaseについては、を参照してください&lt;a href=&quot;#Foldcase&quot;&gt;Foldcaseを&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="056eb59b4cd627258e760e1417c53352badda0af" translate="yes" xml:space="preserve">
          <source>The first form causes the most-significant</source>
          <target state="translated">最初のフォームでは、最も重要な</target>
        </trans-unit>
        <trans-unit id="655fd20aca46eac1f13d92b5af802dc31b11d56c" translate="yes" xml:space="preserve">
          <source>The first form is used to request a</source>
          <target state="translated">第1の形態では</target>
        </trans-unit>
        <trans-unit id="37eddcbe0416a7dc5593d702e9505efc3b548dce" translate="yes" xml:space="preserve">
          <source>The first form lists all distribution files in and below an author's CPAN directory as stored in the CHECKSUMS files distributed on CPAN. The listing recurses into subdirectories.</source>
          <target state="translated">最初の形式では、CPANで配布されているCHECKSUMSファイルに格納されているように、著者のCPANディレクトリ以下にあるすべての配布ファイルをリストアップします。リストはサブディレクトリへと再帰する。</target>
        </trans-unit>
        <trans-unit id="46eae92ecd4f74796835635e06aeea1b041739b2" translate="yes" xml:space="preserve">
          <source>The first function calculates the length of the string to be appended by using &lt;code&gt;strlen&lt;/code&gt; . In the second, you specify the length of the string yourself. The third function processes its arguments like &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; and appends the formatted output. The fourth function works like &lt;code&gt;vsprintf&lt;/code&gt; . You can specify the address and length of an array of SVs instead of the va_list argument. The fifth function extends the string stored in the first SV with the string stored in the second SV. It also forces the second SV to be interpreted as a string.</source>
          <target state="translated">最初の関数は、 &lt;code&gt;strlen&lt;/code&gt; を使用して、追加される文字列の長さを計算します。 2番目では、文字列の長さを自分で指定します。 3番目の関数は、 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; のように引数を処理し、フォーマットされた出力を追加します。 4番目の関数は &lt;code&gt;vsprintf&lt;/code&gt; のように機能します。 va_list引数の代わりに、SVの配列のアドレスと長さを指定できます。 5番目の関数は、最初のSVに格納されている文字列を2番目のSVに格納されている文字列で拡張します。また、2番目のSVを強制的に文字列として解釈します。</target>
        </trans-unit>
        <trans-unit id="50f464748e3494ffffc2bddda9e0371a39740923" translate="yes" xml:space="preserve">
          <source>The first function takes a literal string, the second uses the string stored in the SV. Remember that a stash is just a hash table, so you get back an &lt;code&gt;HV*&lt;/code&gt; . The &lt;code&gt;flags&lt;/code&gt; flag will create a new package if it is set to GV_ADD.</source>
          <target state="translated">最初の関数はリテラル文字列を受け取り、2番目の関数はSVに保存されている文字列を使用します。stashは単なるハッシュテーブルであるため、 &lt;code&gt;HV*&lt;/code&gt; が返されることに注意してください。 &lt;code&gt;flags&lt;/code&gt; それはGV_ADDに設定されている場合、フラグは、新しいパッケージを作成します。</target>
        </trans-unit>
        <trans-unit id="835ff098919bab433ee120cffa3fe9f71b92c1c9" translate="yes" xml:space="preserve">
          <source>The first gives data on bucket chain lengths and provides insight on how much work a fetch *miss* will take. In this case we have to inspect every item in a bucket before we can be sure the item is not in the list. The performance for an insert is equivalent to this case, as is a delete where the item is not in the hash.</source>
          <target state="translated">最初のものは、バケットチェーンの長さに関するデータを提供し、フェッチ*miss*がどのくらいの作業量を要するかについての洞察を提供します。この場合、アイテムがリストにないことを確認する前に、バケット内のすべてのアイテムを検査しなければなりません。ハッシュにアイテムがない場合の削除と同様に、挿入のパフォーマンスはこの場合と同等です。</target>
        </trans-unit>
        <trans-unit id="44b1707c0aa3d824f6a27ecfef8a4304420287cd" translate="yes" xml:space="preserve">
          <source>The first interface is an object approach. &lt;code&gt;IO::Dir&lt;/code&gt; provides an object constructor and methods, which are just wrappers around perl's built in directory reading routines.</source>
          <target state="translated">最初のインターフェースはオブジェクトアプローチです。 &lt;code&gt;IO::Dir&lt;/code&gt; は、オブジェクトコンストラクターとメソッドを提供します。これらは、perlの組み込みディレクトリ読み取りルーチンのラッパーにすぎません。</target>
        </trans-unit>
        <trans-unit id="f4941dd26bc8de71bda8bbde95f00b715fc9713b" translate="yes" xml:space="preserve">
          <source>The first is an asterisk &lt;code&gt;*&lt;/code&gt; to match any sequence of zero or more characters.</source>
          <target state="translated">1つ目は、0個以上の文字のシーケンスと一致するアスタリスク &lt;code&gt;*&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e06aed8ca3d744d52c854ac09d0dcc88676f13d3" translate="yes" xml:space="preserve">
          <source>The first is the '*' metacharacter. This will be replaced by the complete filename matched by the input file glob. So</source>
          <target state="translated">最初のものはメタ文字 '*' です。これは、入力ファイルのグロブでマッチした完全なファイル名に置き換えられます。そのため、以下のように</target>
        </trans-unit>
        <trans-unit id="53f5cd295a83b9a3745b8897953b75db40666387" translate="yes" xml:space="preserve">
          <source>The first is the 'default' format, which is used in both basic and exec modes to print all opcodes. The 2nd, goto-format, is used in exec mode when branches are encountered. They're not real opcodes, and are inserted to look like a closing curly brace. The tree-format is tree specific.</source>
          <target state="translated">最初のフォーマットは 'default' フォーマットで、基本モードと exec モードの両方で、すべてのオペコードを表示するために使用されます。2 番目の goto-format は、分岐に遭遇したときに exec モードで使用されます。これらは実際のオペコードではなく、中括弧で閉じるように挿入されます。ツリーフォーマットはツリー固有のものです。</target>
        </trans-unit>
        <trans-unit id="40fe0d63874f53e08f9d51c255d101fe5f08a938" translate="yes" xml:space="preserve">
          <source>The first line (with Index [0]) means that the value for code point 0 is &quot;Basic Latin&quot;. The entry &quot;0x0080&quot; in the @blocks_ranges column in the second line means that the value from the first line, &quot;Basic Latin&quot;, extends to all code points in the range from 0 up to but not including 0x0080, that is, through 127. In other words, the code points from 0 to 127 are all in the &quot;Basic Latin&quot; block. Similarly, all code points in the range from 0x0080 up to (but not including) 0x0100 are in the block named &quot;Latin-1 Supplement&quot;, etc. (Notice that the return is the old-style block names; see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">最初の行（インデックス[0]付き）は、コードポイント0の値が「Basic Latin」であることを意味します。 2行目の@blocks_ranges列のエントリ「0x0080」は、最初の行の「Basic Latin」の値が、0から0x0080を含まない、つまり127までの範囲のすべてのコードポイントに拡張されることを意味します言い換えると、0から127までのコードポイントはすべて「Basic Latin」ブロック内にあります。同様に、0x0080から0x0100まで（ただし含まない）の範囲のすべてのコードポイントは、「Latin-1 Supplement」などの名前のブロック内にあります（戻り値は古いスタイルのブロック名であることに注意してください。&lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;古いスタイルと新しいスタイルのブロック名&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0686c2b572c16f799b84765daa2d3e48250c69f7" translate="yes" xml:space="preserve">
          <source>The first line above defines &lt;code&gt;TIMESTAMP&lt;/code&gt; as a 9-element list, as returned by &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; in list context. To set it to the string returned by &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; in scalar context, an explicit &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; keyword is required.</source>
          <target state="translated">上記の最初の行は、 &lt;code&gt;TIMESTAMP&lt;/code&gt; を9要素のリストとして定義し、リストコンテキストの &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; によって返されます。スカラーコンテキストで &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; によって返される文字列に設定するには、明示的な &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; キーワードが必要です。</target>
        </trans-unit>
        <trans-unit id="9d82ab0cc733d5c69ba599aa083f54d41b0cd704" translate="yes" xml:space="preserve">
          <source>The first line ensures that the errors in your argument specification are found early. When you ship your application you should comment out the first line, since it makes the second one useless.</source>
          <target state="translated">1行目は、引数指定のエラーを早期に発見できるようにします。アプリケーションを出荷するときには、最初の行をコメントアウトしなければなりません。</target>
        </trans-unit>
        <trans-unit id="1d816990178774f44d4b8769d3c845c853e30a87" translate="yes" xml:space="preserve">
          <source>The first line here indicates that the offset/length table contains 45 entries. Each entry is a pair of integers, denoted by &lt;code&gt;offset[&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;]&lt;/code&gt; . Entries are numbered starting with 1, so entry #1 here is &lt;code&gt;1[4]&lt;/code&gt; and entry #12 is &lt;code&gt;5[1]&lt;/code&gt; . &lt;code&gt;1[4]&lt;/code&gt; indicates that the node labeled &lt;code&gt;1:&lt;/code&gt; (the &lt;code&gt;1: ANYOF[bc]&lt;/code&gt;) begins at character position 1 in the pre-compiled form of the regex, and has a length of 4 characters. &lt;code&gt;5[1]&lt;/code&gt; in position 12 indicates that the node labeled &lt;code&gt;12:&lt;/code&gt; (the &lt;code&gt;12: EXACT &amp;lt;d&amp;gt;&lt;/code&gt;) begins at character position 5 in the pre-compiled form of the regex, and has a length of 1 character. &lt;code&gt;12[1]&lt;/code&gt; in position 14 indicates that the node labeled &lt;code&gt;14:&lt;/code&gt; (the &lt;code&gt;14: CURLYX[0] {1,32767}&lt;/code&gt;) begins at character position 12 in the pre-compiled form of the regex, and has a length of 1 character---that is, it corresponds to the &lt;code&gt;+&lt;/code&gt; symbol in the precompiled regex.</source>
          <target state="translated">ここの最初の行は、オフセット/長さテーブルに45のエントリが含まれていることを示しています。各エントリは、 &lt;code&gt;offset[&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;]&lt;/code&gt; で示される整数のペアです。エントリには1から始まる番号が付けられているため、ここのエントリ＃1は &lt;code&gt;1[4]&lt;/code&gt; 、エントリ＃12は &lt;code&gt;5[1]&lt;/code&gt; です。 &lt;code&gt;1[4]&lt;/code&gt; は、 &lt;code&gt;1:&lt;/code&gt; （ &lt;code&gt;1: ANYOF[bc]&lt;/code&gt; ）というラベルの付いたノードが、コンパイル済みの正規表現の文字位置1から始まり、4文字の長さであることを示します。位置12の &lt;code&gt;5[1]&lt;/code&gt; は、 &lt;code&gt;12:&lt;/code&gt; （ &lt;code&gt;12: EXACT &amp;lt;d&amp;gt;&lt;/code&gt; ）というラベルの付いたノードが、コンパイル済みの正規表現の文字位置5から始まり、長さが1文字であることを示します。 &lt;code&gt;12[1]&lt;/code&gt; 位置14の12 [1]は、 &lt;code&gt;14:&lt;/code&gt; （ &lt;code&gt;14: CURLYX[0] {1,32767}&lt;/code&gt; ）というラベルの付いたノードが、コンパイル済みの正規表現の文字位置12から始まり、長さが1文字であることを示します。 ---つまり、プリコンパイルされた正規表現の &lt;code&gt;+&lt;/code&gt; 記号に対応します。</target>
        </trans-unit>
        <trans-unit id="3daa98ec524432df6c19e25f5089a0ae5fbe0898" translate="yes" xml:space="preserve">
          <source>The first line is an abbreviation for the following two lines, except that it doesn't create the superfluous array variable &lt;code&gt;@array&lt;/code&gt; .</source>
          <target state="translated">最初の行は次の2行の省略形ですが、余分な配列変数 &lt;code&gt;@array&lt;/code&gt; は作成されません。</target>
        </trans-unit>
        <trans-unit id="f07b113f7912ed4a47b2646ff4b1fee0ebfd1d07" translate="yes" xml:space="preserve">
          <source>The first line of the commit message should be a short description without a period. It should be no longer than the subject line of an email, 50 characters being a good rule of thumb.</source>
          <target state="translated">コミットメッセージの最初の行は、ピリオドなしの短い説明文にしてください。メールの件名よりも長くならないようにしてください。</target>
        </trans-unit>
        <trans-unit id="ae7ce29a18436b04a3b95f17b59a8ba620a5dab2" translate="yes" xml:space="preserve">
          <source>The first line shows the pre-compiled form of the regex. The second shows the size of the compiled form (in arbitrary units, usually 4-byte words) and the total number of bytes allocated for the offset/length table, usually 4+&lt;code&gt;size&lt;/code&gt; *8. The next line shows the label</source>
          <target state="translated">最初の行は、コンパイル済みの正規表現を示しています。2番目は、コンパイルされたフォームのサイズ（任意の単位、通常は4バイトワード）と、オフセット/長さテーブルに割り当てられた合計バイト数（通常は4+ &lt;code&gt;size&lt;/code&gt; * 8）を示します。次の行はラベルを示しています</target>
        </trans-unit>
        <trans-unit id="c7723c265ae779d21866a1c9e48b6be3d9e2e441" translate="yes" xml:space="preserve">
          <source>The first method takes periodically samples of the CPU program counter, and since the program counter can be correlated with the code generated for functions, we get a statistical view of in which functions the program is spending its time. The caveats are that very small/fast functions have lower probability of showing up in the profile, and that periodically interrupting the program (this is usually done rather frequently, in the scale of milliseconds) imposes an additional overhead that may skew the results. The first problem can be alleviated by running the code for longer (in general this is a good idea for profiling), the second problem is usually kept in guard by the profiling tools themselves.</source>
          <target state="translated">最初の方法では、定期的に CPU プログラムカウンタのサンプルを取得し、プログラムカウンタを関数用に生成されたコードと相関させることができるので、プログラムがどの関数に時間を費やしているかを統計的に把握することができます。注意点としては、非常に小さな/高速な関数はプロファイルに表示される確率が低いことと、プログラムを定期的に中断する(これは通常、ミリ秒単位でかなり頻繁に行われます)ことで、結果が歪む可能性のある追加のオーバーヘッドが発生することが挙げられます。最初の問題は、コードをより長く実行することで緩和されます(一般的には、これはプロファイリングには良いアイデアです)。</target>
        </trans-unit>
        <trans-unit id="108fd116edbd3a8efddc6a912d5c851d634fe27e" translate="yes" xml:space="preserve">
          <source>The first name is called the</source>
          <target state="translated">と呼ばれています。</target>
        </trans-unit>
        <trans-unit id="3c95867addff6e3f2248f91516c23a2994856b3e" translate="yes" xml:space="preserve">
          <source>The first of the three available techniques is to write the filter completely in C. The external module you create interfaces directly with the source filter hooks provided by Perl.</source>
          <target state="translated">3 つの利用可能なテクニックのうち最初のものは、フィルタを完全に C 言語で記述する方法です。</target>
        </trans-unit>
        <trans-unit id="2cf31ee7914fd21827d64f65da992c78e2dd2481" translate="yes" xml:space="preserve">
          <source>The first of these is the operand providing the overloaded operator implementation - in this case, the object whose &lt;code&gt;minus()&lt;/code&gt; method is being called.</source>
          <target state="translated">これらの最初は、オーバーロードされた演算子の実装を提供するオペランドです-この場合、 &lt;code&gt;minus()&lt;/code&gt; メソッドが呼び出されているオブジェクト。</target>
        </trans-unit>
        <trans-unit id="32df19252ad74319d4ce1046b1c9ffb0a16536ba" translate="yes" xml:space="preserve">
          <source>The first of these two functions checks if a hash table entry exists, and the second deletes it.</source>
          <target state="translated">これら2つの関数のうち1つ目はハッシュテーブルエントリが存在するかどうかをチェックし、2つ目はそのハッシュテーブルエントリを削除します。</target>
        </trans-unit>
        <trans-unit id="2baee74dbd5d9705ba409f49c41818c111db8f9c" translate="yes" xml:space="preserve">
          <source>The first one explicitly passes in the context, which is needed for e.g. threaded builds. The second one does that implicitly; do not get them mixed. If you are not passing in a aTHX_, you will need to do a dTHX (or a dVAR) as the first thing in the function.</source>
          <target state="translated">最初のものは明示的にコンテキストを渡しますが、これはスレッドビルドなどで必要になります。2 番目のものは暗黙のうちにそれを行います。aTHX_を渡さない場合は、関数の最初に dTHX (または dVAR)を行う必要があります。</target>
        </trans-unit>
        <trans-unit id="b5d9b746eaf9594387396efaab0691495a0a8b7a" translate="yes" xml:space="preserve">
          <source>The first one is &lt;code&gt;&quot;format&quot;&lt;/code&gt; , which is a sprintf()-style format string to be used for both numeric parts of the complex number(s). The is somewhat system-dependent but most often it corresponds to &lt;code&gt;&quot;%.15g&quot;&lt;/code&gt; . You can revert to the default by setting the &lt;code&gt;&lt;a href=&quot;../functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最初のものは &lt;code&gt;&quot;format&quot;&lt;/code&gt; です。これは、複素数の両方の数値部分に使用されるsprintf（）スタイルのフォーマット文字列です。は多少システム依存ですが、ほとんどの場合 &lt;code&gt;&quot;%.15g&quot;&lt;/code&gt; に対応します。 &lt;code&gt;&lt;a href=&quot;../functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; に設定することにより、デフォルトに戻すことができます。</target>
        </trans-unit>
        <trans-unit id="64110520d33c3683502b6895ec7f686e2b691a83" translate="yes" xml:space="preserve">
          <source>The first one is a B::PADNAMELIST under Perl 5.22, and a B::AV under earlier versions. The rest are currently B::AV objects, but that could change in future versions.</source>
          <target state="translated">最初のものはPerl 5.22ではB::PADNAMELIST、それ以前のバージョンではB::AVです。残りは現在のところ B::AV オブジェクトですが、将来のバージョンでは変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="53ea0aa1b4ed42878caaa6bf56a3d5e35dfb1b12" translate="yes" xml:space="preserve">
          <source>The first parameter to &lt;code&gt;globmap&lt;/code&gt; , &lt;code&gt;*.tar.gz&lt;/code&gt;, is an</source>
          <target state="translated">最初のパラメータ &lt;code&gt;globmap&lt;/code&gt; 、 &lt;code&gt;*.tar.gz&lt;/code&gt; のは、あります</target>
        </trans-unit>
        <trans-unit id="2f7f0d7f3250dff196379a82ef1042cf92584eab" translate="yes" xml:space="preserve">
          <source>The first part of each item is the language tag, between {...}. It is followed by an English name for the language or language-group. Language tags that I judge to be not for general use, are bracketed.</source>
          <target state="translated">各項目の最初の部分は、{...}の間の言語タグです。その後に、その言語または言語グループの英語名が続きます。私が一般的に使用するものではないと判断した言語タグは括弧で囲んでいます。</target>
        </trans-unit>
        <trans-unit id="2850ab20f1390861bb35445270293546335b53f4" translate="yes" xml:space="preserve">
          <source>The first part of the report already shows the critical information regarding which subroutines are using the most time. The next gives some statistics about the source files profiled.</source>
          <target state="translated">レポートの最初の部分では、どのサブルーチンが最も時間を使っているかという重要な情報がすでに表示されています。次の部分では、プロファイルされたソースファイルに関する統計情報を提供します。</target>
        </trans-unit>
        <trans-unit id="397f188600044026c7930c78c4ec45f2d657488a" translate="yes" xml:space="preserve">
          <source>The first pass is finding the end of the quoted construct. This results in saving to a safe location a copy of the text (between the starting and ending delimiters), normalized as necessary to avoid needing to know what the original delimiters were.</source>
          <target state="translated">最初のパスは、引用符で囲まれた構造体の終わりを見つけることです。この結果、安全な場所にテキストのコピー(開始デリミタと終了デリミタの間)を保存し、元のデリミタを知る必要がないように必要に応じて正規化します。</target>
        </trans-unit>
        <trans-unit id="90fe7088bb4f27d081fbb7bc1dcf8f8999b582b8" translate="yes" xml:space="preserve">
          <source>The first quantifier '.*' starts out by matching the whole string 'the cat in the hat'.</source>
          <target state="translated">最初の定量化子 '.*' は、文字列 'the cat in the hat' 全体にマッチすることから始まります。</target>
        </trans-unit>
        <trans-unit id="9c1c8c14ec1e3a07903d82f126aec6635328f772" translate="yes" xml:space="preserve">
          <source>The first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much of the string as possible while still having the regex match. The second quantifier &lt;code&gt;.*&lt;/code&gt; has no string left to it, so it matches 0 times.</source>
          <target state="translated">最初の量指定子 &lt;code&gt;.*&lt;/code&gt; は、正規表現に一致させながら、文字列のできるだけ多くを取得します。 2番目の量指定子 &lt;code&gt;.*&lt;/code&gt; は文字列が残っていないため、0回一致します。</target>
        </trans-unit>
        <trans-unit id="6e528105bd9590f0533aed7b713042470a33b8f6" translate="yes" xml:space="preserve">
          <source>The first reason is that this technique</source>
          <target state="translated">第一の理由は、この手法は</target>
        </trans-unit>
        <trans-unit id="b01253c2ebd001b8b295bfdd61014e6f7807bcd2" translate="yes" xml:space="preserve">
          <source>The first regexp &lt;code&gt;world&lt;/code&gt; doesn't match because regexps are case-sensitive. The second regexp matches because the substring &lt;code&gt;'o W'&lt;/code&gt; occurs in the string &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; . The space character ' ' is treated like any other character in a regexp and is needed to match in this case. The lack of a space character is the reason the third regexp &lt;code&gt;'oW'&lt;/code&gt; doesn't match. The fourth regexp &lt;code&gt;'World '&lt;/code&gt; doesn't match because there is a space at the end of the regexp, but not at the end of the string. The lesson here is that regexps must match a part of the string</source>
          <target state="translated">正規表現では大文字と小文字が区別されるため、最初の正規表現の &lt;code&gt;world&lt;/code&gt; は一致しません。文字列 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; に部分文字列 &lt;code&gt;'o W'&lt;/code&gt; が出現するため、2番目の正規表現が一致します。スペース文字「」は、正規表現の他の文字と同様に扱われ、この場合の一致に必要です。スペース文字がないことが、3番目の正規表現 &lt;code&gt;'oW'&lt;/code&gt; が一致しない理由です。 4番目の正規表現 &lt;code&gt;'World '&lt;/code&gt; は、正規表現の最後にスペースがあるので一致しませんが、文字列の最後にはありません。ここでの教訓は、正規表現は文字列の一部と一致する必要があるということです</target>
        </trans-unit>
        <trans-unit id="ddca4d833894463530776d04e09076c4eab205cd" translate="yes" xml:space="preserve">
          <source>The first regexp doesn't match because the string has more to it than &lt;code&gt;keep&lt;/code&gt; . Since the second regexp is exactly the string, it matches. Using both &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; in a regexp forces the complete string to match, so it gives you complete control over which strings match and which don't. Suppose you are looking for a fellow named bert, off in a string by himself:</source>
          <target state="translated">最初の正規表現は、文字列に &lt;code&gt;keep&lt;/code&gt; よりも多くの文字があるため、一致しません。2番目の正規表現は文字列そのものなので、一致します。正規表現で &lt;code&gt;^&lt;/code&gt; と &lt;code&gt;$&lt;/code&gt; の両方を使用すると、完全な文字列が強制的に一致するため、一致する文字列と一致しない文字列を完全に制御できます。自分で文字列から離れたbertという名前の仲間を探しているとします。</target>
        </trans-unit>
        <trans-unit id="187948592e3895c96d921caa597048a315b504cd" translate="yes" xml:space="preserve">
          <source>The first reports that both those the hashes contain the same data, while the second reports that they do not. Which you prefer is left as an exercise to the reader.</source>
          <target state="translated">最初のレポートは、両方のハッシュが同じデータを含むことを報告し、2番目のレポートは、それらがないことを報告しています。どちらを選ぶかは読者の自由です。</target>
        </trans-unit>
        <trans-unit id="8860a773058066d93bd3eee9e9232f1b245f86d6" translate="yes" xml:space="preserve">
          <source>The first section describes POSIX functions from the 1003.1 specification. The second section describes some classes for signal objects, TTY objects, and other miscellaneous objects. The remaining sections list various constants and macros in an organization which roughly follows IEEE Std 1003.1b-1993.</source>
          <target state="translated">第1節では、1003.1仕様のPOSIX関数について説明します。第2節では、シグナルオブジェクト、TTYオブジェクト、およびその他の雑多なオブジェクトのためのいくつかのクラスについて説明します。残りのセクションでは、IEEE Std 1003.1b-1993にほぼ準拠した構成で、各種の定数やマクロをリストアップしています。</target>
        </trans-unit>
        <trans-unit id="9a3305f1afd295681118d876dec01ed7a5b8a456" translate="yes" xml:space="preserve">
          <source>The first section maps various C data types to a name, which corresponds somewhat with the various Perl types. The second section contains C code which &lt;b&gt;xsubpp&lt;/b&gt; uses to handle input parameters. The third section contains C code which &lt;b&gt;xsubpp&lt;/b&gt; uses to handle output parameters.</source>
          <target state="translated">最初のセクションでは、さまざまなCデータ型を名前にマッピングします。名前は、さまざまなPerl型と多少対応しています。2番目のセクションには、&lt;b&gt;xsubpp&lt;/b&gt;が入力パラメーターを処理するために使用するCコードが含まれています。3番目のセクションには、&lt;b&gt;xsubpp&lt;/b&gt;が出力パラメーターを処理するために使用するCコードが含まれています。</target>
        </trans-unit>
        <trans-unit id="5dec21809b3e94bb56bbf06b1ab08c273929b8df" translate="yes" xml:space="preserve">
          <source>The first section of this document provides an itemized checklist; subsequent sections provide a more detailed discussion of the items on the list. The final section, &quot;Common Pitfalls&quot;, describes some of the most popular mistakes made by CPAN authors.</source>
          <target state="translated">この文書の最初のセクションでは、項目別のチェックリストを提供しており、それ以降のセクションでは、リストの項目についてより詳細に説明している。最後のセクション「共通の落とし穴」では、CPANの執筆者が犯した最も一般的な間違いのいくつかを説明しています。</target>
        </trans-unit>
        <trans-unit id="873fa0119aa76096529ccc05f5ae97f00f810fd3" translate="yes" xml:space="preserve">
          <source>The first set of stats gives some summary statistical information, including the quality score translated into &quot;Good&quot;, &quot;Poor&quot; and &quot;Bad&quot;, (score&amp;lt;=1.05, score&amp;lt;=1.2, score&amp;gt;1.2). See the documentation in bucket_stats() for more details.</source>
          <target state="translated">最初の統計セットは、「良い」、「悪い」、「悪い」に翻訳された品質スコアを含むいくつかの要約統計情報を提供します（スコア&amp;lt;= 1.05、スコア&amp;lt;= 1.2、スコア&amp;gt; 1.2）。詳細については、bucket_stats（）のドキュメントをご覧ください。</target>
        </trans-unit>
        <trans-unit id="da5f31247c2eb407c67afefcfd779d23549ec3df" translate="yes" xml:space="preserve">
          <source>The first situation being much more frequent, it makes sense to rewrite the boilerplate as</source>
          <target state="translated">最初の状況はより頻繁に発生するので、ボイラプレートを次のように書き換えるのが理にかなっています。</target>
        </trans-unit>
        <trans-unit id="ad55dcbd2815a02cf9af8564c1fdb6a55d76bf9e" translate="yes" xml:space="preserve">
          <source>The first state may happen in &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; and &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; handlers.</source>
          <target state="translated">最初の状態は、 &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; および &lt;code&gt;$SIG{__WARN__}&lt;/code&gt; ハンドラーで発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="470d1d04836c0a5dd42cc354e122ff4ddc8f36a3" translate="yes" xml:space="preserve">
          <source>The first step is to add this line:</source>
          <target state="translated">まずはこの行を追加します。</target>
        </trans-unit>
        <trans-unit id="1d92a911344060c6031358fbe99f5d7b26fb10e8" translate="yes" xml:space="preserve">
          <source>The first step of processing such a line is the conversion, to binary, of the hexadecimal data, to obtain the four fields, while checking the checksum. No surprise here: we'll start with a simple &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; call to convert everything to binary:</source>
          <target state="translated">このような行を処理する最初のステップは、チェックサムをチェックしながら4つのフィールドを取得するための16進データのバイナリへの変換です。ここで驚くことはありません。すべてをバイナリに変換する単純な &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 呼び出しから始めます。</target>
        </trans-unit>
        <trans-unit id="a2237935485a4e0e57cc8ab0badea71ce05f470d" translate="yes" xml:space="preserve">
          <source>The first string position that this regexp can match is at the first &lt;code&gt;'m'&lt;/code&gt; in &lt;code&gt;programming&lt;/code&gt; . At this position, the minimal &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}?&lt;/a&gt;&lt;/code&gt; matches just one &lt;code&gt;'m'&lt;/code&gt; . Although the second quantifier &lt;code&gt;.*?&lt;/code&gt; would prefer to match no characters, it is constrained by the end-of-string anchor &lt;code&gt;$&lt;/code&gt; to match the rest of the string.</source>
          <target state="translated">この正規表現が一致できる最初の文字列の位置は、 &lt;code&gt;programming&lt;/code&gt; 最初の &lt;code&gt;'m'&lt;/code&gt; です。この位置で、最小の &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m{1,2}?&lt;/a&gt;&lt;/code&gt; 1つの &lt;code&gt;'m'&lt;/code&gt; にのみ一致します。 2番目の数量詞 &lt;code&gt;.*?&lt;/code&gt; 文字がないと一致することを好むだろう、それは文字列の残りのアンカーと一致するために文字列の終わりのアンカー &lt;code&gt;$&lt;/code&gt; によって制約されます。</target>
        </trans-unit>
        <trans-unit id="fea599d468c324040fff443da5016a605f7268fd" translate="yes" xml:space="preserve">
          <source>The first task in building a regexp is to decide what we want to match and what we want to exclude. In our case, we want to match both integers and floating point numbers and we want to reject any string that isn't a number.</source>
          <target state="translated">正規表現を構築する際の最初の作業は、マッチさせたいものと除外したいものを決めることです。この例では、整数と浮動小数点数の両方にマッチさせたいので、数値ではない文字列はすべて拒否します。</target>
        </trans-unit>
        <trans-unit id="a253a2302f0dd4214c0fa19a3c7600e1aeb7c19f" translate="yes" xml:space="preserve">
          <source>The first thing after the &quot;=over&quot; command should be an &quot;=item&quot;, unless there aren't going to be any items at all in this &quot;=over&quot; ... &quot;=back&quot; region.</source>
          <target state="translated">この&quot;=over&quot; ...&quot;=back &quot;領域にアイテムが全く存在しない場合を除いて、&quot;=over &quot;コマンドの後の最初のものは&quot;=item &quot;でなければなりません。back &quot;領域にアイテムが存在しないのであれば、&quot;=over&quot; ...&quot;=back &quot;領域にアイテムが存在しないのであれば、&quot;=item &quot;でなければなりません。</target>
        </trans-unit>
        <trans-unit id="b4182d2194d7b0a192c4908dabaf70426956c4b1" translate="yes" xml:space="preserve">
          <source>The first thread will grab a lock on &lt;code&gt;$x&lt;/code&gt; , then, after a pause during which the second thread has probably had time to do some work, try to grab a lock on &lt;code&gt;$y&lt;/code&gt; . Meanwhile, the second thread grabs a lock on &lt;code&gt;$y&lt;/code&gt; , then later tries to grab a lock on &lt;code&gt;$x&lt;/code&gt; . The second lock attempt for both threads will block, each waiting for the other to release its lock.</source>
          <target state="translated">最初のスレッドは &lt;code&gt;$x&lt;/code&gt; ロックを取得し、2番目のスレッドが何らかの作業を行う時間のある一時停止の後、 &lt;code&gt;$y&lt;/code&gt; ロックを取得しようとします。一方、2番目のスレッドは &lt;code&gt;$y&lt;/code&gt; のロックを取得し、後で &lt;code&gt;$x&lt;/code&gt; ロックを取得しようとします。両方のスレッドに対する2回目のロック試行はブロックされ、それぞれが他方のロックが解放されるのを待ちます。</target>
        </trans-unit>
        <trans-unit id="97805142bc0d01ba991305a8f5bc28f8f3fcba12" translate="yes" xml:space="preserve">
          <source>The first time through the loop, you will rewrite the entire file, from line 0 through the end. The second time through the loop, you will rewrite the entire file from line 1 through the end. The third time through the loop, you will rewrite the entire file from line 2 to the end. And so on.</source>
          <target state="translated">ループの1回目は、0行目から最後までファイル全体を書き換えます。2回目のループでは、1行目から最後までファイル全体を書き換えます。3回目のループでは、2行目から最後までファイル全体を書き換えます。といった具合です。</target>
        </trans-unit>
        <trans-unit id="579873cee61866ba7eb29c6c1922769d306aac89" translate="yes" xml:space="preserve">
          <source>The first two fields give the total amount of memory perl sbrk(2)ed (ess-broken? :-) and number of sbrk(2)s used. The third number is what perl thinks about continuity of returned chunks. So long as this number is positive, malloc() will assume that it is probable that sbrk(2) will provide continuous memory.</source>
          <target state="translated">最初の2つのフィールドは、perlのsbrk(2)ed(ess-broken? :-)と使用されたsbrk(2)の数の合計メモリ量を与えます。3番目の数値は、返されたチャンクの連続性についてPerlがどう考えているかを示します。この数が正の値である限り、malloc()はsbrk(2)が連続的なメモリを提供する可能性が高いと仮定します。</target>
        </trans-unit>
        <trans-unit id="4becb05f0bd7170201aca65de03c239266000dbc" translate="yes" xml:space="preserve">
          <source>The first two forms return &lt;b&gt;true&lt;/b&gt; if the &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt; should not be produced by composition normalization. For the final two forms to return &lt;b&gt;true&lt;/b&gt;, it is additionally required that this fact not otherwise be determinable from the Unicode data base.</source>
          <target state="translated">最初の2つの形式は、&lt;a href=&quot;#code-point-argument&quot;&gt;コードポイント引数&lt;/a&gt;が構成の正規化によって生成されるべきでない場合に&lt;b&gt;true&lt;/b&gt;を返し&lt;b&gt;ます&lt;/b&gt;。最後の2つのフォームが&lt;b&gt;true&lt;/b&gt;を返すためには、この事実がUnicodeデータベースから判別できないことがさらに必要です。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7edeb46a7cf77b29322b042169fd6545cca7858e" translate="yes" xml:space="preserve">
          <source>The first value to be substituted in the output string ( usually the column in a cursor addressing capability )</source>
          <target state="translated">出力文字列で置換される最初の値(通常はカーソルアドレッシング能力の列)。</target>
        </trans-unit>
        <trans-unit id="6c0a32c5664fb58c1965f29a470eb892918927d8" translate="yes" xml:space="preserve">
          <source>The first version of TAP to include an explicit version number is 13.</source>
          <target state="translated">明示的なバージョン番号を含むTAPの最初のバージョンは13です。</target>
        </trans-unit>
        <trans-unit id="ba908120df7bb5731ed530b89b4f89b55fe9cb39" translate="yes" xml:space="preserve">
          <source>The first version of this document appeared on Perl Monks, where several people had useful suggestions. Thank you, Perl Monks.</source>
          <target state="translated">この文書の最初のバージョンは Perl Monks に掲載され、何人かの人が有益な提案をしてくれました。Perl Monks に感謝します。</target>
        </trans-unit>
        <trans-unit id="af8e62f88abda0ab386f2cc101dff094b50fe117" translate="yes" xml:space="preserve">
          <source>The first version, the one without the indirect object, ran the</source>
          <target state="translated">最初のバージョンでは、間接オブジェクトがないものは</target>
        </trans-unit>
        <trans-unit id="8e5db8a38d2c3f00c90a5e9484dd046d60b873cc" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt; . Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">逐語的テキストとコードに使用する固定幅フォント。デフォルトは &lt;code&gt;CW&lt;/code&gt; です。一部のシステムでは、代わりに &lt;code&gt;CR&lt;/code&gt; が必要な場合があります。&lt;b&gt;troff&lt;/b&gt;出力にのみ関係します。</target>
        </trans-unit>
        <trans-unit id="4411138b75b6f4d0eb399c58a09f8dac2bce859c" translate="yes" xml:space="preserve">
          <source>The fixed-width font to use for verbatim text and code. Defaults to &lt;code&gt;CW&lt;/code&gt; . Some systems may want &lt;code&gt;CR&lt;/code&gt; instead. Only matters for troff(1) output.</source>
          <target state="translated">逐語的テキストとコードに使用する固定幅フォント。デフォルトは &lt;code&gt;CW&lt;/code&gt; です。一部のシステムでは、代わりに &lt;code&gt;CR&lt;/code&gt; が必要な場合があります。troff（1）の出力にのみ重要です。</target>
        </trans-unit>
        <trans-unit id="a5f7fca8c3cfcccf779409e2e759e639d09b18b3" translate="yes" xml:space="preserve">
          <source>The flag SVs_PADSTALE is cleared on lexicals each time the my() is executed, and set on scope exit. This allows the 'Variable $x is not available' warning to be generated in evals, such as</source>
          <target state="translated">SVs_PADSTALE フラグは、my()が実行されるたびにレキシカル上でクリアされ、スコープの終了時に設定されます。これにより、'変数 $x が利用できません' という警告が、次のような evals で生成されるようになります。</target>
        </trans-unit>
        <trans-unit id="b78429f471bd064af1845edc82bca0aa6e6778ce" translate="yes" xml:space="preserve">
          <source>The flags UTF8_WARN_ILLEGAL_INTERCHANGE, UTF8_WARN_SURROGATE, UTF8_WARN_NONCHAR, and UTF8_WARN_SUPER will cause warning messages to be raised for their respective categories, but otherwise the code points are considered valid (not malformations). To get a category to both be treated as a malformation and raise a warning, specify both the WARN and DISALLOW flags. (But note that warnings are not raised if lexically disabled nor if UTF8_CHECK_ONLY is also specified.)</source>
          <target state="translated">UTF8_WARN_ILLEGAL_INTERCHANGE ・ UTF8_WARN_SURROGATE ・ UTF8_WARN_NONCHAR ・ UTF8_WARN_SUPER フラグは、それぞれのカテゴリに対して警告メッセージを発生させますが、それ以外の場合はコードポイントは有効とみなされます (不正ではありません)。カテゴリを奇形として扱うと同時に警告を発生させるには、WARN と DISALLOW フラグの両方を指定します(ただし、警告は奇形ではないことに注意してください)。(ただし、語彙的に無効化されている場合や、UTF8_CHECK_ONLYも指定されている場合は警告は発生しないことに注意してください)。</target>
        </trans-unit>
        <trans-unit id="5e9a6e0acd0b69b277831006219122b07719e738" translate="yes" xml:space="preserve">
          <source>The flags default to zero, if you want something different you can either use &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; on &lt;code&gt;$POSIX::SigRt::SIGACTION_FLAGS&lt;/code&gt; , or you can derive from POSIX::SigRt and define your own &lt;code&gt;new()&lt;/code&gt; (the tied hash STORE method of the &lt;code&gt;%SIGRT&lt;/code&gt; calls &lt;code&gt;new($rtsig, $handler, $SIGACTION_FLAGS)&lt;/code&gt; , where the &lt;code&gt;$rtsig&lt;/code&gt; ranges from zero to &lt;code&gt;SIGRTMAX - SIGRTMIN + 1)&lt;/code&gt; .</source>
          <target state="translated">フラグをゼロにデフォルト、あなたが別の何かをしたい場合は、いずれかを使用することができます &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 上 &lt;code&gt;$POSIX::SigRt::SIGACTION_FLAGS&lt;/code&gt; 、またはあなたがPOSIX :: SigRtから派生し、独自に定義することができます &lt;code&gt;new()&lt;/code&gt; の（結ばハッシュSTORE方法 &lt;code&gt;%SIGRT&lt;/code&gt; は &lt;code&gt;new($rtsig, $handler, $SIGACTION_FLAGS)&lt;/code&gt; &lt;code&gt;$rtsig&lt;/code&gt; ます。ここで、$ rtsigの範囲はゼロから &lt;code&gt;SIGRTMAX - SIGRTMIN + 1)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d13aa1a177f443868b50bc938e7eaafe94399ebc" translate="yes" xml:space="preserve">
          <source>The flags parameter is mandatory. The valid flag values are R_CURSOR, R_FIRST, R_LAST, R_NEXT and R_PREV.</source>
          <target state="translated">flagsパラメータは必須です。有効なフラグ値は R_CURSOR,R_FIRST,R_LAST,R_NEXT,R_PREV です。</target>
        </trans-unit>
        <trans-unit id="3f1710e98626f16d762b28b22c17439d043e302f" translate="yes" xml:space="preserve">
          <source>The flags specify dictionary order and case folding:</source>
          <target state="translated">フラグは、辞書の順番と大文字小文字の折り返しを指定します。</target>
        </trans-unit>
        <trans-unit id="10543ef8424f431d7ff14981f10f88f0c585ac15" translate="yes" xml:space="preserve">
          <source>The flavor</source>
          <target state="translated">味わい</target>
        </trans-unit>
        <trans-unit id="0aa322e2f3acfe06e30a26fc0d60aa65599ac7cd" translate="yes" xml:space="preserve">
          <source>The floating point infinity can be exported as a subroutine Inf():</source>
          <target state="translated">浮動小数点無限大はサブルーチンInf()として書き出すことができます。</target>
        </trans-unit>
        <trans-unit id="2e5e2b0312afcc71cd5da99161e1d75eaff20f77" translate="yes" xml:space="preserve">
          <source>The focus is on elements of style which are visible to the users of a module, rather than those parts which are only seen by the module's developers. However, many of the guidelines presented in this document can be extrapolated and applied successfully to a module's internals.</source>
          <target state="translated">モジュールの開発者にしか見えない部分よりも、モジュールのユーザに見えるスタイルの要素に焦点を当てています。しかし、このドキュメントで提示されたガイドラインの多くは、モジュールの内部に外挿してうまく適用することができます。</target>
        </trans-unit>
        <trans-unit id="9981cb315250daca0797ec1ef39fd43f6c6f6a86" translate="yes" xml:space="preserve">
          <source>The following &quot;public&quot; global names can be read by clients of this API. Beware that these should be considered &quot;readonly&quot;.</source>
          <target state="translated">以下の &quot;パブリック &quot;グローバル名は、このAPIのクライアントが読み取ることができます。これらは &quot;readonly&quot; と見なされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="20617679e0f828efd3412a47a9694c121128bc85" translate="yes" xml:space="preserve">
          <source>The following &quot;virtual&quot; methods can be defined by the client. They will be called by the API at appropriate points. Note that unless specified otherwise, the debug API only defines empty, non-functional default versions of these methods.</source>
          <target state="translated">以下の「仮想的な」メソッドは、クライアントによって定義することができます。これらのメソッドは、適切な場所で API によって呼び出されます。特に指定がない限り、デバッグ API はこれらのメソッドの空の非機能的なデフォルトバージョンのみを定義することに注意してください。</target>
        </trans-unit>
        <trans-unit id="74f1711fbc30180876f2a4788abe7e66574474a6" translate="yes" xml:space="preserve">
          <source>The following (inefficiently) deletes all the values of %HASH and @ARRAY:</source>
          <target state="translated">以下は (非効率的に)%HASH と @ARRAY のすべての値を削除します。</target>
        </trans-unit>
        <trans-unit id="d00c5dd059bf93f0972cfd4b44a56b57fd0caf81" translate="yes" xml:space="preserve">
          <source>The following API list contains functions, thus one needs to provide pointers to the modifiable data explicitly (either C pointers, or Perlish &lt;code&gt;GV *&lt;/code&gt; s). Where the above macros take &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;, a similar function takes &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; .</source>
          <target state="translated">次のAPIリストには関数が含まれているため、変更可能なデータへのポインターを明示的に提供する必要があります（CポインターまたはPerlish &lt;code&gt;GV *&lt;/code&gt; のいずれか）。上記のマクロが &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; を取る場合、同様の関数は &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; *&lt;/code&gt; を取ります。</target>
        </trans-unit>
        <trans-unit id="b1909e3498aef1b158b54d7174bc50b2ee9e5d97" translate="yes" xml:space="preserve">
          <source>The following API uses parts of Perl's internals in the current implementation. As such, they are efficient but may change in a future release.</source>
          <target state="translated">以下のAPIは、現在の実装ではPerlの内部の一部を使用しています。このように、これらは効率的ですが、将来のリリースで変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="36cab3979d794d7afb5425a45a32e9d6f7ad6a57" translate="yes" xml:space="preserve">
          <source>The following NNTP command are unsupported by the package, and there are no plans to do so.</source>
          <target state="translated">以下のNNTPコマンドはパッケージではサポートされておらず、その予定はありません。</target>
        </trans-unit>
        <trans-unit id="2d9e72c95e25f90c1fd2f371c21c4c0499d49748" translate="yes" xml:space="preserve">
          <source>The following RFC959 commands have not been implemented:</source>
          <target state="translated">以下のRFC959コマンドは実装されていません。</target>
        </trans-unit>
        <trans-unit id="237479489ace35ae45dfd88db2279ca4abed31a5" translate="yes" xml:space="preserve">
          <source>The following VMS-specific information applies to the indicated &quot;special&quot; Perl variables, in addition to the general information in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;. Where there is a conflict, this information takes precedence.</source>
          <target state="translated">以下のVMS固有の情報は、&lt;a href=&quot;perlvar&quot;&gt;perlvarの&lt;/a&gt;一般情報に加えて、示された「特別な」Perl変数に適用されます。矛盾がある場合、この情報が優先されます。</target>
        </trans-unit>
        <trans-unit id="a7dd0dcb80676e8669cc8ad178e5203d579a6cf3" translate="yes" xml:space="preserve">
          <source>The following Win32-Methods are built-in:</source>
          <target state="translated">以下のWin32-Methodsが組み込まれています。</target>
        </trans-unit>
        <trans-unit id="1c76188e19e8645c61f6a21008485b728f914f68" translate="yes" xml:space="preserve">
          <source>The following XS code shows the getnetconfigent() function which is used with ONC+ TIRPC. The getnetconfigent() function will return a pointer to a C structure and has the C prototype shown below. The example will demonstrate how the C pointer will become a Perl reference. Perl will consider this reference to be a pointer to a blessed object and will attempt to call a destructor for the object. A destructor will be provided in the XS source to free the memory used by getnetconfigent(). Destructors in XS can be created by specifying an XSUB function whose name ends with the word &lt;b&gt;DESTROY&lt;/b&gt;. XS destructors can be used to free memory which may have been malloc'd by another XSUB.</source>
          <target state="translated">次のXSコードは、ONC + TIRPCで使用されるgetnetconfigent（）関数を示しています。 getnetconfigent（）関数は、C構造体へのポインターを返し、以下に示すCプロトタイプを持っています。この例では、CポインターがPerl参照になる方法を示します。 Perlはこの参照を祝福されたオブジェクトへのポインタと見なし、オブジェクトのデストラクタを呼び出そうとします。 getnetconfigent（）が使用していたメモリを解放するために、XSソースにデストラクタが提供されます。 XSのデストラクタは、名前が&lt;b&gt;DESTROYで&lt;/b&gt;終わるXSUB関数を指定することで作成できます。 XSデストラクタを使用して、別のXSUBによってmallocされた可能性のあるメモリを解放できます。</target>
        </trans-unit>
        <trans-unit id="63aaf3d4311946370f948fe1a874ef3b8b5e106b" translate="yes" xml:space="preserve">
          <source>The following XS file shows an XS subroutine, or XSUB, which demonstrates one possible interface to the rpcb_gettime() function. This XSUB represents a direct translation between C and Perl and so preserves the interface even from Perl. This XSUB will be invoked from Perl with the usage shown above. Note that the first three #include statements, for &lt;code&gt;EXTERN.h&lt;/code&gt; , &lt;code&gt;perl.h&lt;/code&gt; , and &lt;code&gt;XSUB.h&lt;/code&gt; , will always be present at the beginning of an XS file. This approach and others will be expanded later in this document. A #define for &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; should be present to fetch the interpreter context more efficiently, see &lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt; for details.</source>
          <target state="translated">次のXSファイルは、rpcb_gettime（）関数への1つの可能なインターフェースを示すXSサブルーチンまたはXSUBを示しています。このXSUBは、CとPerl間の直接変換を表すため、Perlからのインターフェースも保持します。このXSUBは、上記の使用方法でPerlから呼び出されます。 &lt;code&gt;EXTERN.h&lt;/code&gt; 、 &lt;code&gt;perl.h&lt;/code&gt; 、および &lt;code&gt;XSUB.h&lt;/code&gt; の最初の3つの#includeステートメントは、XSファイルの先頭に常に存在することに注意してください。このアプローチなどは、このドキュメントの後半で拡張されます。インタプリタコンテキストをより効率的にフェッチするには、 &lt;code&gt;PERL_NO_GET_CONTEXT&lt;/code&gt; の#define が存在する必要があります。詳細については&lt;a href=&quot;perlguts#How-multiple-interpreters-and-concurrency-are-supported&quot;&gt;perlguts&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a47250eb8cd4ed87f2a860c613d9258f03e5ab61" translate="yes" xml:space="preserve">
          <source>The following XSUB allows a Perl program to access a C library function called sin(). The XSUB will imitate the C function which takes a single argument and returns a single value.</source>
          <target state="translated">以下の XSUB は、Perl プログラムが sin()と呼ばれる C ライブラリ関数にアクセスできるようにします。このXSUBは,引数を1つ取り,値を1つ返すC言語の関数を模倣しています.</target>
        </trans-unit>
        <trans-unit id="71f3a3c3ea9ed7f75901c1ba18beceaf1cdd2fef" translate="yes" xml:space="preserve">
          <source>The following XSUB is for a C function which requires special handling of its parameters. The Perl usage is given first.</source>
          <target state="translated">以下のXSUBは、パラメータの特別な処理を必要とするC関数のためのものです。Perlの使用法を先に示します。</target>
        </trans-unit>
        <trans-unit id="4f90e96487752832ff267e1d1e37b8167fdf3f66" translate="yes" xml:space="preserve">
          <source>The following XSUB uses the &lt;code&gt;SV *&lt;/code&gt; return type as a mnemonic only, and uses a CODE: block to indicate to the compiler that the programmer has supplied all the necessary code. The sv_newmortal() call will initialize the return value to undef, making that the default return value.</source>
          <target state="translated">次のXSUBは、 &lt;code&gt;SV *&lt;/code&gt; 戻り型をニーモニックとしてのみ使用し、CODE：ブロックを使用して、プログラマーが必要なすべてのコードを提供したことをコンパイラーに示します。sv_newmortal（）呼び出しは戻り値をundefに初期化し、それをデフォルトの戻り値にします。</target>
        </trans-unit>
        <trans-unit id="a1bc7555b268b447bf525bbb361d23e74ba70916" translate="yes" xml:space="preserve">
          <source>The following XSUB will call the C rpcb_gettime() function and will return its two output values, timep and status, to Perl as a single list.</source>
          <target state="translated">以下の XSUB は C の rpcb_gettime()関数を呼び出し、その 2 つの出力値である timep と status を 1 つのリストとして Perl に返します。</target>
        </trans-unit>
        <trans-unit id="a13ba96373d895202485d58b843fc94572bbb6f9" translate="yes" xml:space="preserve">
          <source>The following XSUB will generate incorrect C code. The &lt;b&gt;xsubpp&lt;/b&gt; compiler will turn this into code which calls &lt;code&gt;rpcb_gettime()&lt;/code&gt; with parameters &lt;code&gt;(char
*host, time_t timep)&lt;/code&gt; , but the real &lt;code&gt;rpcb_gettime()&lt;/code&gt; wants the &lt;code&gt;timep&lt;/code&gt; parameter to be of type &lt;code&gt;time_t*&lt;/code&gt; rather than &lt;code&gt;time_t&lt;/code&gt; .</source>
          <target state="translated">次のXSUBは不正なCコードを生成します。&lt;b&gt;xsubppの&lt;/b&gt;コンパイラが呼び出すコードにこれを向けるだろう &lt;code&gt;rpcb_gettime()&lt;/code&gt; パラメータを持つ &lt;code&gt;(char *host, time_t timep)&lt;/code&gt; 、本当 &lt;code&gt;rpcb_gettime()&lt;/code&gt; 欲しい &lt;code&gt;timep&lt;/code&gt; にはパラメータが型であることが &lt;code&gt;time_t*&lt;/code&gt; ではなく、 &lt;code&gt;time_t&lt;/code&gt; の。</target>
        </trans-unit>
        <trans-unit id="72e3e7ea3cadf3d440df4d4dd029f14c329e3532" translate="yes" xml:space="preserve">
          <source>The following are Win32 multilanguage editor/IDEs that support Perl:</source>
          <target state="translated">以下はPerlをサポートするWin32の多言語エディタ/IDEです。</target>
        </trans-unit>
        <trans-unit id="878ebe02234cd6605f8faf412927071c9b53a803" translate="yes" xml:space="preserve">
          <source>The following are additions that have been requested, but I have been reluctant to add due to them being very simple to implement in perl</source>
          <target state="translated">以下はリクエストのあった追加機能ですが、Perl での実装が非常に簡単なため、私は追加には消極的でした。</target>
        </trans-unit>
        <trans-unit id="f30d9daa89e8ddd37f1202a1d64d4bf0b2c5e1f9" translate="yes" xml:space="preserve">
          <source>The following are all accessor methods -- that is, they don't do anything on their own, but just alter the contents of the conversion object, which comprises the options for this particular batch conversion.</source>
          <target state="translated">つまり,それらはそれ自体では何もしませんが,この特定のバッチ変換のためのオプションを構成する変換オブジェクトの内容を変更するだけです。</target>
        </trans-unit>
        <trans-unit id="cd4d07e071310dab311d4b0da4565a6a9fb7c1f6" translate="yes" xml:space="preserve">
          <source>The following are also defined by POSIX/SUSv3, but unfortunately not very widely implemented:</source>
          <target state="translated">以下もPOSIX/SUSv3で定義されていますが、残念ながらあまり広く実装されていません。</target>
        </trans-unit>
        <trans-unit id="5b36027844e4806a69f430d629440d5e7ecab300" translate="yes" xml:space="preserve">
          <source>The following are common causes of compilation and/or execution failures, not common to Perl as such. The C FAQ is good bedtime reading. Please test your changes with as many C compilers and platforms as possible; we will, anyway, and it's nice to save oneself from public embarrassment.</source>
          <target state="translated">以下はコンパイルおよび/または実行の失敗の一般的な原因ですが、Perlには一般的ではありません。C FAQは寝る前に読んでおくと良いでしょう。できるだけ多くの C コンパイラやプラットフォームで変更点をテストしてください。</target>
        </trans-unit>
        <trans-unit id="e2853c6c7f110e3e4c7ed324a99e91a718ca2300" translate="yes" xml:space="preserve">
          <source>The following are exported:</source>
          <target state="translated">以下のようにエクスポートされています。</target>
        </trans-unit>
        <trans-unit id="7791b6ab4309dfc3ea821f7f1d4091cb49b39854" translate="yes" xml:space="preserve">
          <source>The following are fast conversions from ISO 8859-1 (Latin-1) bytes to UTF-8 bytes and back, the code works even with older Perl 5 versions.</source>
          <target state="translated">以下は、ISO 8859-1 (Latin-1)バイトから UTF-8 バイトへの高速変換です。</target>
        </trans-unit>
        <trans-unit id="c852e811877cc6e9c98b0f2d5fb593ccfc901a95" translate="yes" xml:space="preserve">
          <source>The following are methods in the DB base class. A client must access these methods by inheritance (*not* by calling them directly), since the API keeps track of clients through the inheritance mechanism.</source>
          <target state="translated">以下は DB 基底クラスのメソッドです。クライアントはこれらのメソッドに継承によってアクセスしなければなりません (*直接呼び出してはいけません*)。</target>
        </trans-unit>
        <trans-unit id="2b3c274cc89ec17e7b845a436f38d1540dbbe5c4" translate="yes" xml:space="preserve">
          <source>The following are such interfaces. Also, see &lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug&lt;/a&gt;. For all of these interfaces Perl currently (as of v5.16.0) simply assumes byte strings both as arguments and results, or UTF-8 strings if the (deprecated) &lt;code&gt;encoding&lt;/code&gt; pragma has been used.</source>
          <target state="translated">以下はそのようなインターフェースです。また、&lt;a href=&quot;#The-%22Unicode-Bug%22&quot;&gt;Unicode Bugも&lt;/a&gt;参照してください。これらすべてのインターフェースについて、Perlは現在（v5.16.0以降）引数と結果の両方としてバイト文字列、または（非推奨の） &lt;code&gt;encoding&lt;/code&gt; プラグマが使用されている場合はUTF-8文字列を想定しています。</target>
        </trans-unit>
        <trans-unit id="5bd9bb59d1e1fb0197ed7d9b93043408c8c9a510" translate="yes" xml:space="preserve">
          <source>The following are the built-in attributes for subroutines:</source>
          <target state="translated">サブルーチンに組み込まれている属性は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="e8e3f6674cdb74d0958b2c8c99d763306f790276" translate="yes" xml:space="preserve">
          <source>The following are the built-in attributes for variables:</source>
          <target state="translated">変数の組み込み属性は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="9d2f2e3af66effdb52e3d7832a18951cdcafd9d0" translate="yes" xml:space="preserve">
          <source>The following are valid ($t1 and $t2 are Time::Piece objects):</source>
          <target state="translated">以下が有効です($t1と$t2はTime::Pieceオブジェクト)。</target>
        </trans-unit>
        <trans-unit id="f353aa81f91d6dfefc37a9410a376bf8429ba4d4" translate="yes" xml:space="preserve">
          <source>The following attributes may be specified as arguments to WriteMakefile() or as NAME=VALUE pairs on the command line. Attributes that became available with later versions of MakeMaker are indicated.</source>
          <target state="translated">以下の属性は、WriteMakefile()の引数として、またはコマンドラインで NAME=VALUE のペアとして指定することができます。MakeMaker の後のバージョンで利用可能になった属性を示しています。</target>
        </trans-unit>
        <trans-unit id="b84f68ccf7654a835d7d4e99c76422bf128a4813" translate="yes" xml:space="preserve">
          <source>The following blocks are more or less equivalent:</source>
          <target state="translated">以下のブロックは多かれ少なかれ同等である。</target>
        </trans-unit>
        <trans-unit id="8676339e37a5a253bdb0cffb28423c7698d023a0" translate="yes" xml:space="preserve">
          <source>The following boolean methods are useful in determining the</source>
          <target state="translated">を決定する際には、以下のブーリアンメソッドが便利です。</target>
        </trans-unit>
        <trans-unit id="b20d8378cbbcad7ea8e16d1f3872a95fae060afe" translate="yes" xml:space="preserve">
          <source>The following bzip2 constants are exported by this module</source>
          <target state="translated">以下の bzip2 定数はこのモジュールによってエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="f401e4eb4fd748677014cc2aaf006246c60d726e" translate="yes" xml:space="preserve">
          <source>The following checks are currently performed:</source>
          <target state="translated">現在、以下のチェックを行っています。</target>
        </trans-unit>
        <trans-unit id="a62f3d4985ed23dc7ef4b06d5778fb97c9f68862" translate="yes" xml:space="preserve">
          <source>The following code demonstrates how to supply initialization code for function parameters. The initialization code is eval'ed within double quotes by the compiler before it is added to the output so anything which should be interpreted literally [mainly &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , or &lt;code&gt;\\&lt;/code&gt; ] must be protected with backslashes. The variables &lt;code&gt;$var&lt;/code&gt; , &lt;code&gt;$arg&lt;/code&gt; , and &lt;code&gt;$type&lt;/code&gt; can be used as in typemaps.</source>
          <target state="translated">次のコードは、関数パラメーターの初期化コードを提供する方法を示しています。初期化コードは、出力に追加される前にコンパイラーによって二重引用符で囲まれて評価されるため、文字どおりに解釈される必要があるもの（主に &lt;code&gt;$&lt;/code&gt; 、 &lt;code&gt;@&lt;/code&gt; 、または &lt;code&gt;\\&lt;/code&gt; ）はバックスラッシュで保護する必要があります。変数 &lt;code&gt;$var&lt;/code&gt; 、 &lt;code&gt;$arg&lt;/code&gt; 、および &lt;code&gt;$type&lt;/code&gt; は、タイプマップと同じように使用できます。</target>
        </trans-unit>
        <trans-unit id="994718a63d0e6e92c9d2b82a651bf83693f2d577" translate="yes" xml:space="preserve">
          <source>The following code opens up an output handle that will convert any output to a hexadecimal dump of the output bytes: for example &quot;A&quot; will be converted to &quot;41&quot; (on ASCII-based machines, on EBCDIC platforms the &quot;A&quot; will become &quot;c1&quot;)</source>
          <target state="translated">次のコードは出力ハンドルを開き、出力を出力バイトの16進数ダンプに変換します:例えば、&quot;A &quot;は &quot;41 &quot;に変換されます(ASCIIベースのマシンでは、EBCDICプラットフォームでは &quot;A &quot;は &quot;c1 &quot;になります)。</target>
        </trans-unit>
        <trans-unit id="b646612d9dad6d0db0d9ef47258da28b3b64f1c7" translate="yes" xml:space="preserve">
          <source>The following code will build up an ASCII string saying &lt;code&gt;'PerlPerlPerl'&lt;/code&gt; . The comments show the string after each step. Note that this code works in the same way on big-endian or little-endian machines.</source>
          <target state="translated">次のコードは、 &lt;code&gt;'PerlPerlPerl'&lt;/code&gt; というASCII文字列を作成します。コメントは、各ステップの後の文字列を示しています。このコードは、ビッグエンディアンまたはリトルエンディアンのマシンで同じように機能することに注意してください。</target>
        </trans-unit>
        <trans-unit id="b67a84b8d82f9d95c5a2c0536fda7094ec319c8b" translate="yes" xml:space="preserve">
          <source>The following code works for single-level arrays. It uses a stringwise comparison, and does not distinguish defined versus undefined empty strings. Modify if you have other needs.</source>
          <target state="translated">以下のコードは,シングルレベル配列に対して動作します.これは文字列ごとの比較を使用し、定義された空文字列と未定義の空文字列を区別しません。他の必要性があれば修正してください。</target>
        </trans-unit>
        <trans-unit id="b42ca297dfa48bfb8bd9e9eb19ab8d4d7764f6d5" translate="yes" xml:space="preserve">
          <source>The following collations all make sense and you may meet any of them if you &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; .</source>
          <target state="translated">以下の照合順序はすべて意味があり、 &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; する」場合はどの照合順序にも適合する可能性があります。</target>
        </trans-unit>
        <trans-unit id="c5819e2e60b0b7a2348ddc793c274025d6f7880f" translate="yes" xml:space="preserve">
          <source>The following command characters are defined:</source>
          <target state="translated">以下のコマンド文字が定義されています。</target>
        </trans-unit>
        <trans-unit id="94b38038de165a0daa7082711aa19c3a2036cf7d" translate="yes" xml:space="preserve">
          <source>The following command line switches behave differently under VMS than described in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;. Note also that in order to pass uppercase switches to Perl, you need to enclose them in double-quotes on the command line, since the CRTL downcases all unquoted strings.</source>
          <target state="translated">次のコマンドラインスイッチは、VMSでの動作が&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;で説明されているものとは異なります。大文字のスイッチをPerlに渡すには、CRTLが引用符で囲まれていない文字列をすべて小文字にするため、コマンドラインで二重引用符で囲む必要があることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="52448ab44f7b84ff23c0bb42cd9a8e27687108c1" translate="yes" xml:space="preserve">
          <source>The following command shows how to compute digests for typical inputs such as the NIST test vector &quot;abc&quot;:</source>
          <target state="translated">以下のコマンドは、NISTテストベクタ &quot;abc &quot;のような典型的な入力に対してダイジェストを計算する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="ab2ed20fd1e01c9d474d41404b2754af8ec50648" translate="yes" xml:space="preserve">
          <source>The following compilation warnings may happen in HP-UX releases earlier than 11.31 but are harmless:</source>
          <target state="translated">以下のコンパイル警告は、11.31 より前の HP-UX リリースで発生する可能性がありますが、無害です。</target>
        </trans-unit>
        <trans-unit id="3f82c625cf5e705c9b15fb1534c5c11410cab28f" translate="yes" xml:space="preserve">
          <source>The following compiler versions are currently supported by IBM:</source>
          <target state="translated">IBM が現在サポートしているコンパイラのバージョンは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="f0ad64f79a84fc4d8e60a250b5c99592e7f5b9c7" translate="yes" xml:space="preserve">
          <source>The following compound statements may be used to control flow:</source>
          <target state="translated">フローを制御するために、以下の複合文を使用することができる。</target>
        </trans-unit>
        <trans-unit id="cd012592d06772e0ce9bcaaa2cfc233e60576f7d" translate="yes" xml:space="preserve">
          <source>The following constants may be returned by getaddrinfo() or getnameinfo(). Others may be provided by the OS.</source>
          <target state="translated">以下の定数は、getaddrinfo()または getnameinfo()によって返される可能性があります。その他はOSが提供しているかもしれません。</target>
        </trans-unit>
        <trans-unit id="b842779c0173418719ebe5c2a7970e42d7d014a5" translate="yes" xml:space="preserve">
          <source>The following constants may be supplied as $xflags.</source>
          <target state="translated">以下の定数を $xflags として指定することができます。</target>
        </trans-unit>
        <trans-unit id="1be3497b66f11b1f18ed534aa513910c71b80ff0" translate="yes" xml:space="preserve">
          <source>The following debugger is actually useful:</source>
          <target state="translated">実際には以下のようなデバッガが便利です。</target>
        </trans-unit>
        <trans-unit id="c779f6e32c9824a654c3d3bb9768a1c5fd1243ca" translate="yes" xml:space="preserve">
          <source>The following description of methods is still under development. Please refer to the code for not suitably documented sections and complain loudly to the makemaker@perl.org mailing list. Better yet, provide a patch.</source>
          <target state="translated">以下のメソッドの記述はまだ開発中です。ドキュメント化されていない部分についてはコードを参照して、 makemaker@perl.org メーリングリストに大声で文句を言ってください。より良い方法としては、パッチを提供してください。</target>
        </trans-unit>
        <trans-unit id="b3965f0e7b97198aca0dad023bdfa649bc3d7a07" translate="yes" xml:space="preserve">
          <source>The following documentation describes how to use FATAL warnings but the perl5 porters strongly recommend that you understand the risks before doing so, especially for library code intended for use by others, as there is no way for downstream users to change the choice of fatal categories.</source>
          <target state="translated">以下のドキュメントでは FATAL 警告の使用方法を説明していますが、特に他の人が使用することを意図したライブラリコードについては、下流のユーザが致命的なカテゴリの選択を変更する方法がないため、Perl5 移植者は、そうする前にリスクを理解しておくことを強く推奨します。</target>
        </trans-unit>
        <trans-unit id="a7395fbf98116a6fe303ce2ccf2e783d73f2e981" translate="yes" xml:space="preserve">
          <source>The following efficiently counts the number of set bits in a bit vector:</source>
          <target state="translated">以下は、ビットベクトルのセットビット数を効率よくカウントします。</target>
        </trans-unit>
        <trans-unit id="2679279cde508d70a24c6c066ec89faf688d0162" translate="yes" xml:space="preserve">
          <source>The following entries are used during installation &amp;amp; testing on the libnet package</source>
          <target state="translated">次のエントリは、libnetパッケージのインストールとテスト中に使用されます</target>
        </trans-unit>
        <trans-unit id="f9b777d6ecffc2871fa8ad1bd878e3ae6a3e84c6" translate="yes" xml:space="preserve">
          <source>The following environment variables are not specific to Perl: They are part of the standardized (ISO C, XPG4, POSIX 1.c) &lt;code&gt;setlocale()&lt;/code&gt; method for controlling an application's opinion on data. Windows is non-POSIX, but Perl arranges for the following to work as described anyway. If the locale given by an environment variable is not valid, Perl tries the next lower one in priority. If none are valid, on Windows, the system default locale is then tried. If all else fails, the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale is used. If even that doesn't work, something is badly broken, but Perl tries to forge ahead with whatever the locale settings might be.</source>
          <target state="translated">次の環境変数はPerlに固有のものではありません。データに関するアプリケーションの意見を制御するための標準化された（ISO C、XPG4、POSIX 1.c） &lt;code&gt;setlocale()&lt;/code&gt; メソッドの一部です。Windowsは非POSIXですが、Perlは以下のように記述されているように動作するように調整しています。環境変数によって指定されたロケールが有効でない場合、Perlは次に低いロケールを優先的に試みます。有効なものがない場合、Windowsでは、システムのデフォルトロケールが試行されます。他のすべてが失敗した場合、 &lt;code&gt;&quot;C&quot;&lt;/code&gt; ロケールが使用されます。それでもうまくいかない場合は、何かがひどく壊れていますが、Perlはロケール設定が何であれ、何であれ先取りを試みます。</target>
        </trans-unit>
        <trans-unit id="ec33aa555d27541d5a7185de1c1d5ba6a82fafba" translate="yes" xml:space="preserve">
          <source>The following equivalences hold (assuming &lt;code&gt;$#a &amp;gt;= $i&lt;/code&gt; )</source>
          <target state="translated">以下の同値が成立します（ &lt;code&gt;$#a &amp;gt;= $i&lt;/code&gt; 仮定）</target>
        </trans-unit>
        <trans-unit id="85ca43521cd7775d8d33759b4074f5573158c1e6" translate="yes" xml:space="preserve">
          <source>The following error handling mechanism is considered experimental and is subject to change pending feedback from users.</source>
          <target state="translated">以下のエラー処理メカニズムは実験的なものであり、ユーザーからのフィードバックを待って変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="cd63c469244aad9fa5f13ff0ec636281c8ddaf6b" translate="yes" xml:space="preserve">
          <source>The following error occurs because of the Cygwin &lt;code&gt;#define&lt;/code&gt; of &lt;code&gt;_LONG_DOUBLE&lt;/code&gt; :</source>
          <target state="translated">次のエラーは、 &lt;code&gt;_LONG_DOUBLE&lt;/code&gt; の Cygwin &lt;code&gt;#define&lt;/code&gt; が原因で発生します。</target>
        </trans-unit>
        <trans-unit id="e111335c40da2391bb6d2b1d90ed4f7cf911e6e5" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available in constructs that interpolate, and in transliterations:</source>
          <target state="translated">以下のエスケープシーケンスは、補間するコンストラクト、および音訳で利用可能です。</target>
        </trans-unit>
        <trans-unit id="82159e16248ad6f2c09cd225ffdcbbf320f234ef" translate="yes" xml:space="preserve">
          <source>The following escape sequences are available in constructs that interpolate, but not in transliterations.</source>
          <target state="translated">以下のエスケープシーケンスは、補間するコンストラクトでは利用できますが、音訳では利用できません。</target>
        </trans-unit>
        <trans-unit id="62d1bc8a7a340748e143b5a954b697a1e9a92d04" translate="yes" xml:space="preserve">
          <source>The following example contains all supported keywords and structures with the exception of &lt;code&gt;eexpect&lt;/code&gt; which can be used instead of &lt;code&gt;expect&lt;/code&gt; .</source>
          <target state="translated">次の例には、 &lt;code&gt;expect&lt;/code&gt; の代わりに使用できる &lt;code&gt;eexpect&lt;/code&gt; を除いて、サポートされているすべてのキーワードと構造が含まれています。</target>
        </trans-unit>
        <trans-unit id="e8665fd8b339dfb9b20108d0f4ac2879711d7bca" translate="yes" xml:space="preserve">
          <source>The following example counts all the possible matching strings in a pattern (without actually matching any of them).</source>
          <target state="translated">以下の例では、パターン内のマッチする可能性のある文字列をすべてカウントしています(実際にはマッチしません)。</target>
        </trans-unit>
        <trans-unit id="b54547ad1ef83c76b354b1c5c3bcd26f7c112217" translate="yes" xml:space="preserve">
          <source>The following example implements a simple daemon, which restarts itself every time the &lt;code&gt;SIGHUP&lt;/code&gt; signal is received. The actual code is located in the subroutine &lt;code&gt;code()&lt;/code&gt; , which just prints some debugging info to show that it works; it should be replaced with the real code.</source>
          <target state="translated">次の例は、 &lt;code&gt;SIGHUP&lt;/code&gt; シグナルを受信するたびに再起動する単純なデーモンを実装しています。実際のコードは、サブルーチン &lt;code&gt;code()&lt;/code&gt; にあります。サブルーチンcode（）は、デバッグ情報を出力して、機能することを示します。実際のコードに置き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="4db59d80ee391c290c8e0098f7b4cb5a921d343a" translate="yes" xml:space="preserve">
          <source>The following example shows a variation of the rpcb_gettime() function. This function uses the timep variable only as an output variable and does not care about its initial contents.</source>
          <target state="translated">以下の例は、rpcb_gettime()関数のバリエーションを示しています。この関数は timep 変数を出力変数としてのみ使用し、その初期内容は気にしません。</target>
        </trans-unit>
        <trans-unit id="6e5930c0e8a4086018f7b728e0496b7b5959e325" translate="yes" xml:space="preserve">
          <source>The following example shows how the input parameter &lt;code&gt;timep&lt;/code&gt; can be evaluated late, after a PREINIT.</source>
          <target state="translated">次の例は、PREINITの後、入力パラメーター &lt;code&gt;timep&lt;/code&gt; を遅延して評価する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="f2d336b88b655db564d2a7de7cc37f5570d6138e" translate="yes" xml:space="preserve">
          <source>The following example will create aliases &lt;code&gt;FOO::gettime()&lt;/code&gt; and &lt;code&gt;BAR::getit()&lt;/code&gt; for this function.</source>
          <target state="translated">次の例では、この関数のエイリアス &lt;code&gt;FOO::gettime()&lt;/code&gt; および &lt;code&gt;BAR::getit()&lt;/code&gt; を作成します。</target>
        </trans-unit>
        <trans-unit id="97da872b2dd68324aaeb980a55e38dbf65cc1f09" translate="yes" xml:space="preserve">
          <source>The following example will import the &lt;code&gt;langinfo()&lt;/code&gt; function itself and three constants to be used as arguments to &lt;code&gt;langinfo()&lt;/code&gt; : a constant for the abbreviated first day of the week (the numbering starts from Sunday = 1) and two more constants for the affirmative and negative answers for a yes/no question in the current locale.</source>
          <target state="translated">次の例では、インポートされます &lt;code&gt;langinfo()&lt;/code&gt; の引数として使用される機能自体と3つの定数 &lt;code&gt;langinfo()&lt;/code&gt; 週の略称最初の日のための定数（番号は日曜日= 1から始まる）と肯定のための2つの定数。現在のロケールでのはい/いいえの質問に対する否定的な回答。</target>
        </trans-unit>
        <trans-unit id="68fe38084e5e619d96b5a9797595ec407ba06c97" translate="yes" xml:space="preserve">
          <source>The following example will import the langinfo() function itself and three constants to be used as arguments to langinfo(): a constant for the abbreviated first day of the week (the numbering starts from Sunday = 1) and two more constants for the affirmative and negative answers for a yes/no question in the current locale.</source>
          <target state="translated">以下の例では、langinfo()関数自体と langinfo()の引数として使用する 3 つの定数をインポートしています:短縮された週の最初の曜日を表す定数 (日曜日=1 から始まる)と、現在のロケールでの質問の yes/no の肯定・否定の答えを表す 2 つの定数です。</target>
        </trans-unit>
        <trans-unit id="1d1e35923d66b27df87bbd4951c7d28f5e911d07" translate="yes" xml:space="preserve">
          <source>The following example will start the XS code and will place all functions in a package named RPC.</source>
          <target state="translated">以下の例では、XSのコードを開始し、すべての関数をRPCという名前のパッケージに入れます。</target>
        </trans-unit>
        <trans-unit id="dcb1a8c644e732663ae2a1c5ba3b577a1beb1ffa" translate="yes" xml:space="preserve">
          <source>The following examples all demonstrate how &lt;code&gt;reduce&lt;/code&gt; could be used to implement the other list-reduction functions in this module. (They are not in fact implemented like this, but instead in a more efficient manner in individual C functions).</source>
          <target state="translated">以下の例はすべて、 &lt;code&gt;reduce&lt;/code&gt; を使用してこのモジュールの他のリスト削減関数を実装する方法を示しています。（実際にはこのように実装されているのではなく、個々のC関数でより効率的な方法で実装されています）。</target>
        </trans-unit>
        <trans-unit id="887954cfa884d676e908a97b64a1555b23e32dbf" translate="yes" xml:space="preserve">
          <source>The following examples are equivalent, but if the code is using complex typemaps then the first example is safer.</source>
          <target state="translated">以下の例は同等ですが、コードが複雑なタイプマップを使用している場合は、最初の例の方が安全です。</target>
        </trans-unit>
        <trans-unit id="49473e8ccd96036c2dcbbff4100727b567ca00bb" translate="yes" xml:space="preserve">
          <source>The following examples assume</source>
          <target state="translated">以下の例では、以下のように想定しています。</target>
        </trans-unit>
        <trans-unit id="c8963d9d7205dc5eeae0e9a51c29c23916de6bfc" translate="yes" xml:space="preserve">
          <source>The following examples don't attempt to show everything as that would be a monumental task, and, frankly, we don't want this manpage to be an internals document for Perl. The examples do demonstrate some basics of the raw Perl datatypes, and should suffice to get most determined people on their way. There are no guidewires or safety nets, nor blazed trails, so be prepared to travel alone from this point and on and, if at all possible, don't fall into the quicksand (it's bad for business).</source>
          <target state="translated">以下の例では、すべてのものを紹介しようとはしていませんが、それは膨大な作業になるでしょうし、率直に言って、この man ページが Perl の内部文書になることを望んでいません。これらの例は、生のPerlのデータ型のいくつかの基本を示しており、ほとんどの決意のある人が自分の道を歩むのに十分なはずです。ここから先は一人で旅をすることを覚悟し、可能であれば、流砂に落ちないようにしてください(ビジネスに悪影響を及ぼします)。</target>
        </trans-unit>
        <trans-unit id="f93e6ebc989a84ca950fac6b12d34738b1701d5f" translate="yes" xml:space="preserve">
          <source>The following extension layers are bundled with perl:</source>
          <target state="translated">perlには以下の拡張レイヤがバンドルされています。</target>
        </trans-unit>
        <trans-unit id="7106b07b78b7a3440b3c0ad4f4323e11abe72903" translate="yes" xml:space="preserve">
          <source>The following extra operations are supported on both real and complex numbers:</source>
          <target state="translated">以下の追加演算は、実数と複素数の両方でサポートされています。</target>
        </trans-unit>
        <trans-unit id="44559e75149012ee5d0aabd7169096ab8b9b70c9" translate="yes" xml:space="preserve">
          <source>The following feature bundles are available:</source>
          <target state="translated">以下の機能をバンドルしています。</target>
        </trans-unit>
        <trans-unit id="bfb5fd7e91227c5f530d75f35f7920db7fa46141" translate="yes" xml:space="preserve">
          <source>The following file is certain to trigger a few errors at both runtime and compiletime:</source>
          <target state="translated">以下のファイルは、実行時とコンパイル時の両方でいくつかのエラーを発生させることになります。</target>
        </trans-unit>
        <trans-unit id="21aca79b002af6c026c59989c512a774a1e9d423" translate="yes" xml:space="preserve">
          <source>The following files were created.</source>
          <target state="translated">以下のファイルを作成しました。</target>
        </trans-unit>
        <trans-unit id="c2d8b9dded738fa01824e3880baab2ed9227058b" translate="yes" xml:space="preserve">
          <source>The following flag constants are recognised as $flags. Other flag constants may exist as provided by the OS.</source>
          <target state="translated">以下のフラグ定数は、$flagsとして認識されます。その他のフラグ定数は、OSによって提供されているものが存在する可能性があります。</target>
        </trans-unit>
        <trans-unit id="650acaa8d024a737244b8df389c437c35b54545d" translate="yes" xml:space="preserve">
          <source>The following flag constants are recognised in the $hints hash. Other flag constants may exist as provided by the OS.</source>
          <target state="translated">以下のフラグ定数は$hintsハッシュで認識されます。その他のフラグ定数はOSが提供しているものが存在する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8b04fa6f897518e44671c43d372c1d8cbb29d5b0" translate="yes" xml:space="preserve">
          <source>The following flag has been added in the Perl implementation for csh compatibility:</source>
          <target state="translated">csh互換性のためにPerlの実装に以下のフラグが追加されました。</target>
        </trans-unit>
        <trans-unit id="1cd8e3861113caf88d2e286d8b55139fd349b7d0" translate="yes" xml:space="preserve">
          <source>The following flags would be nice to have but they would first need their own Augean stablemaster:</source>
          <target state="translated">次の旗があればいいのですが、まずは自分のアルジェリアの厩務員が必要です。</target>
        </trans-unit>
        <trans-unit id="9100eb4e02b3634a97be9d3c35013fdbb0474e55" translate="yes" xml:space="preserve">
          <source>The following four files sum up all the details discussed so far.</source>
          <target state="translated">これまでに説明した内容をまとめると、以下の4つのファイルになります。</target>
        </trans-unit>
        <trans-unit id="c34a482a0a61764634c9a647354d1ae932661df4" translate="yes" xml:space="preserve">
          <source>The following function copies a string into an SV whose reference is &lt;code&gt;rv&lt;/code&gt; . Set length to 0 to let Perl calculate the string length. SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="translated">次の関数は、参照が &lt;code&gt;rv&lt;/code&gt; であるSVに文字列をコピーします。Perlに文字列の長さを計算させるには、長さを0に設定します。 &lt;code&gt;classname&lt;/code&gt; がnullでない場合、SVは祝福されます。</target>
        </trans-unit>
        <trans-unit id="3c0cf226e396fa1b152052f0820e83e7d855fd95" translate="yes" xml:space="preserve">
          <source>The following function copies the pointer value (</source>
          <target state="translated">次の関数はポインタの値をコピーします(</target>
        </trans-unit>
        <trans-unit id="2e073fa19276cae1009d363a0e5463744a8cdb65" translate="yes" xml:space="preserve">
          <source>The following function is available on Perls built on 64 bit OpenVMS v8.2 with hard links enabled on an ODS-5 formatted build disk. CRTL support is in principle available as of OpenVMS v7.3-1, and better configuration support could detect this.</source>
          <target state="translated">64 ビットの OpenVMS v8.2 でビルドされた Perls で、ODS-5 フォーマットのビルドディスク上でハードリンクを有効にした場合、以下の機能が利用できます。CRTL サポートは OpenVMS v7.3-1 の時点では原則として利用可能であり、より優れた設定サポートによりこれを検出できる可能性があります。</target>
        </trans-unit>
        <trans-unit id="1d791c23038d9fe8780d570ab1f25e41c2c30bfa" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is a reference to a blessed object.</source>
          <target state="translated">以下の関数は、SV が祝福されたオブジェクトへの参照であるかどうかをテストします。</target>
        </trans-unit>
        <trans-unit id="e97d512753d6d3628f54f7cc67945848127ebcd9" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is blessed into the specified class. It does not check inheritance relationships.</source>
          <target state="translated">以下の関数は SV が指定されたクラスに bless されているかどうかをテストします。継承関係のチェックは行いません。</target>
        </trans-unit>
        <trans-unit id="df3aa6043ddcb399a0be1d9f05fb30512b44c0e8" translate="yes" xml:space="preserve">
          <source>The following function tests whether the SV is derived from the specified class. SV can be either a reference to a blessed object or a string containing a class name. This is the function implementing the &lt;code&gt;UNIVERSAL::isa&lt;/code&gt; functionality.</source>
          <target state="translated">次の関数は、SVが指定されたクラスから派生しているかどうかをテストします。SVは、祝福されたオブジェクトへの参照またはクラス名を含む文字列のいずれかです。これは &lt;code&gt;UNIVERSAL::isa&lt;/code&gt; 機能を実装する関数です。</target>
        </trans-unit>
        <trans-unit id="f2556ab0e8df33f1383226a4c6f98cdd750d952a" translate="yes" xml:space="preserve">
          <source>The following function upgrades rv to reference if not already one. Creates a new SV for rv to point to. If &lt;code&gt;classname&lt;/code&gt; is non-null, the SV is blessed into the specified class. SV is returned.</source>
          <target state="translated">次の関数は、rvを参照にアップグレードします（まだ参照していない場合）。rvが指す新しいSVを作成します。 &lt;code&gt;classname&lt;/code&gt; がnullでない場合、SVは指定されたクラスに祝福されます。SVが返されます。</target>
        </trans-unit>
        <trans-unit id="29dc5cc89743cc721a2ee3907403e1585ed5aaa4" translate="yes" xml:space="preserve">
          <source>The following functions</source>
          <target state="translated">以下の機能があります。</target>
        </trans-unit>
        <trans-unit id="d058fd87c96266d5fdc51527ace77cd0d78cdd43" translate="yes" xml:space="preserve">
          <source>The following functions all perform some useful activity on reference values.</source>
          <target state="translated">以下の関数はすべて、参照値に対して何らかの有用な活動を行います。</target>
        </trans-unit>
        <trans-unit id="2911d89162772ba03d36f6973e469a4101bb2cc6" translate="yes" xml:space="preserve">
          <source>The following functions are Perl implementations of the mktemp() family of temp file generation system calls.</source>
          <target state="translated">以下の関数は、一時ファイル生成システムコールのmktemp()ファミリのPerl実装です。</target>
        </trans-unit>
        <trans-unit id="e0a3d6bc866a23a74bfc5cb99a24046225a27424" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on 64 bit OpenVMS v8.2 and later.</source>
          <target state="translated">64bit OpenVMS v8.2以降でビルドされたPerlsでは、以下の機能が利用できます。</target>
        </trans-unit>
        <trans-unit id="c3192aa510cfad4d7ff0a5d49cbe59b87b3bf2ce" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on 64 bit OpenVMS v8.2 and later. CRTL support is in principle available as of OpenVMS v7.3-2, and better configuration support could detect this.</source>
          <target state="translated">64 ビット版 OpenVMS v8.2 以降でビルドされた Perls で以下の機能が利用可能です。CRTL サポートは OpenVMS v7.3-2 の時点では原則として利用可能であり、より良い設定サポートがあれば、これを検出できる可能性があります。</target>
        </trans-unit>
        <trans-unit id="9298194e3e006b8fbe7257f536dde080822b8c50" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls built on VMS 7.2 or greater:</source>
          <target state="translated">VMS 7.2以上で構築されたPerlsでは、以下の機能が利用できます。</target>
        </trans-unit>
        <trans-unit id="5c953c5f1b476c550370e7b30065e8a151627682" translate="yes" xml:space="preserve">
          <source>The following functions are available on Perls compiled with Dec C 5.2 or greater and running VMS 7.0 or greater:</source>
          <target state="translated">以下の関数は、Dec C 5.2以上でコンパイルされ、VMS 7.0以上で動作するPerlsで利用できます。</target>
        </trans-unit>
        <trans-unit id="1e205f409e70ccbdada46ad7374f5371cb998862" translate="yes" xml:space="preserve">
          <source>The following functions are available.</source>
          <target state="translated">以下のような機能があります。</target>
        </trans-unit>
        <trans-unit id="5950979e93d5397c31fbc2a28b94b256eeabee34" translate="yes" xml:space="preserve">
          <source>The following functions are currently undocumented. If you use one of them, you may wish to consider creating and submitting documentation for it.</source>
          <target state="translated">以下の機能は現在のところドキュメント化されていません。これらの関数を使用している場合は、ドキュメントを作成して提出することを検討してみてください。</target>
        </trans-unit>
        <trans-unit id="886ab3bb8b191680b7816c0256fd741faf8bc7ec" translate="yes" xml:space="preserve">
          <source>The following functions are defined in the &lt;code&gt;utf8::&lt;/code&gt; package by the Perl core. You do not need to say &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; to use these and in fact you should not say that unless you really want to have UTF-8 source code.</source>
          <target state="translated">以下の関数はPerlコアによって &lt;code&gt;utf8::&lt;/code&gt; パッケージで定義されています。これらを使用 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; と言う必要はありません。実際に、UTF-8ソースコードが本当に必要な場合を除いて、それを言うべきではありません。</target>
        </trans-unit>
        <trans-unit id="d924d0242f33a4bd7b878adc5df25af14f3fc818" translate="yes" xml:space="preserve">
          <source>The following functions are exported by &lt;code&gt;Filter::Util::Call&lt;/code&gt; :</source>
          <target state="translated">次の関数は &lt;code&gt;Filter::Util::Call&lt;/code&gt; によってエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="aab0faf40d4a413b76ab20e1f7c9c1ce5f8e0b08" translate="yes" xml:space="preserve">
          <source>The following functions are exported by default.</source>
          <target state="translated">デフォルトでは以下の関数がエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="f74d5f0be47eadceddfa059884e47684f407a94a" translate="yes" xml:space="preserve">
          <source>The following functions are exported by this module. Please note that these are functions (not methods) and therefore &lt;code&gt;&lt;a href=&quot;../functions/do&quot;&gt;do&lt;/a&gt; not&lt;/code&gt; take an implicit first argument.</source>
          <target state="translated">次の関数は、このモジュールによってエクスポートされます。したがって、これらの関数（メソッドではない）であることに注意してください &lt;code&gt;&lt;a href=&quot;../functions/do&quot;&gt;do&lt;/a&gt; not&lt;/code&gt; 暗黙の最初の引数を取ります。</target>
        </trans-unit>
        <trans-unit id="ecbe41a265e73d2f25c7e96c76a4a747b067fbd6" translate="yes" xml:space="preserve">
          <source>The following functions are exported by this module: &lt;code&gt;share&lt;/code&gt; , &lt;code&gt;shared_clone&lt;/code&gt; , &lt;code&gt;is_shared&lt;/code&gt; , &lt;code&gt;cond_wait&lt;/code&gt; , &lt;code&gt;cond_timedwait&lt;/code&gt; , &lt;code&gt;cond_signal&lt;/code&gt; and &lt;code&gt;cond_broadcast&lt;/code&gt;</source>
          <target state="translated">：次の関数がこのモジュールによってエクスポートされた &lt;code&gt;share&lt;/code&gt; 、 &lt;code&gt;shared_clone&lt;/code&gt; 、 &lt;code&gt;is_shared&lt;/code&gt; 、 &lt;code&gt;cond_wait&lt;/code&gt; 、 &lt;code&gt;cond_timedwait&lt;/code&gt; 、 &lt;code&gt;cond_signal&lt;/code&gt; や &lt;code&gt;cond_broadcast&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="359dedf5643622ca4347a5ad1835485c0f626223" translate="yes" xml:space="preserve">
          <source>The following functions are exported only by request.</source>
          <target state="translated">以下の関数はリクエストでのみエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="bdb1dbec7cc374a481e866646b73ca4b04e611a0" translate="yes" xml:space="preserve">
          <source>The following functions are now implemented in FastCalc.xs:</source>
          <target state="translated">以下の関数がFastCalc.xsに実装されました。</target>
        </trans-unit>
        <trans-unit id="685959529a3484efa19ac7a3baaeafce45e37b9a" translate="yes" xml:space="preserve">
          <source>The following functions are provided by the &lt;code&gt;Digest::MD5&lt;/code&gt; module. None of these functions are exported by default.</source>
          <target state="translated">次の関数は、 &lt;code&gt;Digest::MD5&lt;/code&gt; モジュールによって提供されます。これらの関数は、デフォルトではエクスポートされません。</target>
        </trans-unit>
        <trans-unit id="b8a73287c5b8efe7a8f104d252583b6712796202" translate="yes" xml:space="preserve">
          <source>The following functions are provided:</source>
          <target state="translated">以下の機能を備えています。</target>
        </trans-unit>
        <trans-unit id="cb80d66061f0196a6ca192d5341a430ee1b0eb26" translate="yes" xml:space="preserve">
          <source>The following functions are supported:</source>
          <target state="translated">以下の機能に対応しています。</target>
        </trans-unit>
        <trans-unit id="89bf61ba64cc618bf2874d4293a3aae6452f1aba" translate="yes" xml:space="preserve">
          <source>The following functions can be imported from this module. No functions are exported by default.</source>
          <target state="translated">このモジュールからは、以下の関数をインポートできます。デフォルトではエクスポートされる関数はありません。</target>
        </trans-unit>
        <trans-unit id="76627ad7f894d0c3e9a81281fe41fe4c1c985047" translate="yes" xml:space="preserve">
          <source>The following functions check whether the string is in that normalization form.</source>
          <target state="translated">以下の関数は、文字列がその正規化形式であるかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="a27da5eeba1599f572e14a8c9329aa08b0e2cd4f" translate="yes" xml:space="preserve">
          <source>The following functions convert between lists of Perl values and packed binary strings representing structures.</source>
          <target state="translated">以下の関数は、Perl の値のリストと、構造体を表すパックされたバイナリ文字列の間で変換します。</target>
        </trans-unit>
        <trans-unit id="2ccfd58b6052a416773b606e17f327b9dd3cd108" translate="yes" xml:space="preserve">
          <source>The following functions have been flagged as part of the public API, but are currently undocumented. Use them at your own risk, as the interfaces are subject to change. Functions that are not listed in this document are not intended for public use, and should NOT be used under any circumstances.</source>
          <target state="translated">以下の関数は公開APIの一部としてフラグが立てられていますが、現在は文書化されていません。インターフェイスは変更される可能性があるので、自己責任で使用してください。このドキュメントに記載されていない関数は公開用ではなく、いかなる状況下でも使用すべきではありません。</target>
        </trans-unit>
        <trans-unit id="8f79fe7f0a766eea8a6363560d09b1b418f37a54" translate="yes" xml:space="preserve">
          <source>The following functions may or may not be implemented, depending on what type of socket support you've built into your copy of Perl:</source>
          <target state="translated">以下の関数は、Perl のコピーに組み込まれているソケットサポートの種類によっては、実装されていないかもしれません。</target>
        </trans-unit>
        <trans-unit id="2d8b2c9f184b69863b362bc365b152ff7d6a2cc5" translate="yes" xml:space="preserve">
          <source>The following functions use &lt;code&gt;$_&lt;/code&gt; as a default argument:</source>
          <target state="translated">次の関数は、デフォルトの引数として &lt;code&gt;$_&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="0dd434c67978a923f9ec0ee28d2a5538ba5682f6" translate="yes" xml:space="preserve">
          <source>The following functions were not implemented in the VMS port, and calling them produces a fatal error (usually) or undefined behavior (rarely, we hope):</source>
          <target state="translated">以下の関数は VMS ポートに実装されておらず、それらを呼び出すと致命的なエラー(通常は)または未定義の動作(まれに)が発生します。</target>
        </trans-unit>
        <trans-unit id="cdfa439e416672c343b7c0368293d837f0c0576b" translate="yes" xml:space="preserve">
          <source>The following functions would all be inlined:</source>
          <target state="translated">以下の関数はすべてインライン化されます。</target>
        </trans-unit>
        <trans-unit id="f04cb90467492e19af66e5b899cfc303ddef4110" translate="yes" xml:space="preserve">
          <source>The following global variables are associated with arenas:</source>
          <target state="translated">以下のグローバル変数がアリーナに関連付けられています。</target>
        </trans-unit>
        <trans-unit id="0d3412aee89bad6343f641caa3a5d4996443527e" translate="yes" xml:space="preserve">
          <source>The following illustrates use of the Benchmark object:</source>
          <target state="translated">以下は、Benchmarkオブジェクトの使用方法を説明しています。</target>
        </trans-unit>
        <trans-unit id="21c5c52868e5d5448c65efac8d8979602bb9419b" translate="yes" xml:space="preserve">
          <source>The following information applies to gcc version 2. Volunteers to update it as appropriately for gcc version 3 would be appreciated.</source>
          <target state="translated">以下の情報は gcc バージョン 2 に適用されます。gccバージョン3に合わせて適切なアップデートをしてくれるボランティアの方を募集します。</target>
        </trans-unit>
        <trans-unit id="62ec6b5e797715143c688dee03c54b63962fd46a" translate="yes" xml:space="preserve">
          <source>The following interfaces are provided for compatibility with existing APIs. They should not be used in new code.</source>
          <target state="translated">以下のインターフェイスは、既存の API との互換性のために提供されています。これらは新しいコードでは使用しないでください。</target>
        </trans-unit>
        <trans-unit id="0bdb13054ff9ef26849b463627b5915db32807ca" translate="yes" xml:space="preserve">
          <source>The following is a long section of miscellaneous requirements and suggestions to do with Pod processing.</source>
          <target state="translated">以下、Podの処理についての雑学的な要求と提案を長々と書いていきます。</target>
        </trans-unit>
        <trans-unit id="9eebaea88bec8281bdda401db84ecb8529c5edbd" translate="yes" xml:space="preserve">
          <source>The following is an example of a typemap that could be used for this C++ example.</source>
          <target state="translated">このC++の例で使用できるタイプマップの例を以下に示します。</target>
        </trans-unit>
        <trans-unit id="a14c2ddd24e4bc7ed4b474606997260d2d723a26" translate="yes" xml:space="preserve">
          <source>The following is the old c2ph.doc documentation by Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt; Date: 25 Jul 91 08:10:21 GMT</source>
          <target state="translated">以下は、Tom Christiansen &amp;lt;tchrist@perl.com&amp;gt;による古いc2ph.docドキュメントです。日付：25 Jul 91 08:10:21 GMT</target>
        </trans-unit>
        <trans-unit id="838c8cc6acec4e734454e6016dba1f13113970de" translate="yes" xml:space="preserve">
          <source>The following is used to &lt;a href=&quot;deprecate&quot;&gt;deprecate&lt;/a&gt; core modules beyond a certain version of Perl:</source>
          <target state="translated">以下は、特定のバージョンのPerlを超えてコアモジュールを&lt;a href=&quot;deprecate&quot;&gt;非推奨にする&lt;/a&gt;ために使用されます。</target>
        </trans-unit>
        <trans-unit id="0c3fbe199ab2c0c87ca2506f58ce4cc1ff1336a3" translate="yes" xml:space="preserve">
          <source>The following keys allowed for callbacks. These keys are case-sensitive.</source>
          <target state="translated">コールバックで使用できるキーは以下の通りです。これらのキーは大文字と小文字を区別します。</target>
        </trans-unit>
        <trans-unit id="ace2dc9ae3a6b314c56205001ea3e99826b29341" translate="yes" xml:space="preserve">
          <source>The following keys are optional.</source>
          <target state="translated">以下のキーはオプションです。</target>
        </trans-unit>
        <trans-unit id="87593abf1938664ef0461a9fc202ad24f5f827db" translate="yes" xml:space="preserve">
          <source>The following keys are recognised in the option hash:</source>
          <target state="translated">オプションハッシュでは、以下のキーが認識されます。</target>
        </trans-unit>
        <trans-unit id="2e29171b7f3395c93aba1c43b176e6a5f79f9da1" translate="yes" xml:space="preserve">
          <source>The following keys in the hash reference $CPAN::Config are currently defined:</source>
          <target state="translated">現在、ハッシュ参照 $CPAN::Config の以下のキーが定義されています。</target>
        </trans-unit>
        <trans-unit id="8faa1306b5e277a45ec730d9a598e8adafe08efc" translate="yes" xml:space="preserve">
          <source>The following layers are currently defined:</source>
          <target state="translated">現在、以下のレイヤーが定義されています。</target>
        </trans-unit>
        <trans-unit id="8819c5fc895570a060c0cc0274e5435ca8214190" translate="yes" xml:space="preserve">
          <source>The following line is taken from the testsuite for &lt;a href=&quot;http://search.cpan.org/perldoc/File::Map&quot;&gt;File::Map&lt;/a&gt;:</source>
          <target state="translated">次の行は&lt;a href=&quot;http://search.cpan.org/perldoc/File::Map&quot;&gt;File :: Mapの&lt;/a&gt;テストスイートから取得されます。</target>
        </trans-unit>
        <trans-unit id="b26a944c006c4ed66106c7db11bb76fd456329ff" translate="yes" xml:space="preserve">
          <source>The following lines are equivalent:</source>
          <target state="translated">以下の行は等価です。</target>
        </trans-unit>
        <trans-unit id="a27fa1a573ac1c2bd0bdaed0b154f8a047e4a778" translate="yes" xml:space="preserve">
          <source>The following list of Unicode supported features for regular expressions describes all features currently directly supported by core Perl. The references to &quot;Level N&quot; and the section numbers refer to the Unicode Technical Standard #18, &quot;Unicode Regular Expressions&quot;, version 13, from August 2008.</source>
          <target state="translated">以下の正規表現の Unicode サポート機能のリストは、現在コア Perl で直接サポートされているすべての機能を記述しています。レベルN」とセクション番号は、2008年8月のUnicode技術標準#18「Unicode正規表現」バージョン13を参照しています。</target>
        </trans-unit>
        <trans-unit id="04d2ac78ac8de1d9653897258388c5a4d402853b" translate="yes" xml:space="preserve">
          <source>The following macros must always be used to access the contents of hash entries. Note that the arguments to these macros must be simple variables, since they may get evaluated more than once. See &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for detailed descriptions of these macros.</source>
          <target state="translated">ハッシュエントリの内容にアクセスするには、次のマクロを常に使用する必要があります。これらのマクロは複数回評価される可能性があるため、これらのマクロの引数は単純な変数でなければならないことに注意してください。これらのマクロの詳細については、&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="54cabd1569f977ca3a4b00bfe48c1954ef75d0d2" translate="yes" xml:space="preserve">
          <source>The following methods all return a boolean value and are to be overridden in the appropriate subclass.</source>
          <target state="translated">以下のメソッドはすべてブーリアン値を返し、適切なサブクラスでオーバーライドされます。</target>
        </trans-unit>
        <trans-unit id="2e28c1a68a0ac1abaa1b238b7c5b433afa448fce" translate="yes" xml:space="preserve">
          <source>The following methods are available for all &lt;code&gt;Digest::&lt;/code&gt; modules:</source>
          <target state="translated">次のメソッドは、すべての &lt;code&gt;Digest::&lt;/code&gt; モジュールで使用できます。</target>
        </trans-unit>
        <trans-unit id="5d1a84015cfed0b396f9aadd71cc3704958e67dc" translate="yes" xml:space="preserve">
          <source>The following methods are available:</source>
          <target state="translated">以下のような方法があります。</target>
        </trans-unit>
        <trans-unit id="7b6f41c232d0f405651a2979e1a726ffd3fbd1cf" translate="yes" xml:space="preserve">
          <source>The following methods are not supported on a per-filehandle basis.</source>
          <target state="translated">以下のメソッドは、ファイルハンドルごとにはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="e3dd1f8a67cafbd7d4b11fa3ef01a32bc5c44916" translate="yes" xml:space="preserve">
          <source>The following methods are ones you may wish to override if you want to subclass &lt;code&gt;TAP::Harness&lt;/code&gt; .</source>
          <target state="translated">次のメソッドは、 &lt;code&gt;TAP::Harness&lt;/code&gt; をサブクラス化したい場合にオーバーライドしたいメソッドです。</target>
        </trans-unit>
        <trans-unit id="679901c8aebeb73a7fa904b450ae5e241ed9cb03" translate="yes" xml:space="preserve">
          <source>The following methods are optional, and can be defined if the underlying lib has a fast way to do them. If undefined, Math::BigInt will use pure Perl (hence slow) fallback routines to emulate these:</source>
          <target state="translated">以下のメソッドはオプションであり、基礎となる lib に高速な方法があれば定義することができます。未定義の場合、Math::BigInt はこれらをエミュレートするために純粋な Perl (したがって遅い)フォールバックルーチンを使用します。</target>
        </trans-unit>
        <trans-unit id="d8157ae492dfb9da4aae902df688ee7d5be628f8" translate="yes" xml:space="preserve">
          <source>The following methods are provided in this module. Each one takes a reference to the object itself as an implicit first parameter.</source>
          <target state="translated">このモジュールでは、以下のメソッドが提供されています。それぞれのメソッドは、暗黙の第一パラメータとしてオブジェクト自体への参照を取ります。</target>
        </trans-unit>
        <trans-unit id="bde2e5da8041f121dd086d0f1594d72494846e0b" translate="yes" xml:space="preserve">
          <source>The following methods are provided:</source>
          <target state="translated">以下のような方法が用意されています。</target>
        </trans-unit>
        <trans-unit id="61fea790abe3137c314afb22029bb574c87067fd" translate="yes" xml:space="preserve">
          <source>The following methods are required for an API version of 2 or greater.</source>
          <target state="translated">APIのバージョンが2以上の場合は、以下のメソッドが必要です。</target>
        </trans-unit>
        <trans-unit id="ec06d96f64f88685f2a77a047bae0d4b9b41fde8" translate="yes" xml:space="preserve">
          <source>The following methods are wrappers for the directory related functions built into perl (the trailing 'dir' has been removed from the names). See &lt;a href=&quot;../perlfunc&quot;&gt;perlfunc&lt;/a&gt; for details of these functions.</source>
          <target state="translated">以下のメソッドは、perlに組み込まれているディレクトリ関連の関数のラッパーです（末尾の「dir」は名前から削除されています）。参照してください&lt;a href=&quot;../perlfunc&quot;&gt;perlfuncの&lt;/a&gt;これらの機能の詳細については。</target>
        </trans-unit>
        <trans-unit id="570150b9609694e95e958423d380ac3c5369cdc3" translate="yes" xml:space="preserve">
          <source>The following methods can be used to manipulate items anywhere in a queue.</source>
          <target state="translated">キュー内の任意の場所でアイテムを操作するには、以下のメソッドを使用することができます。</target>
        </trans-unit>
        <trans-unit id="1cff87e9e5dce6950df4739edc1576de748d33e5" translate="yes" xml:space="preserve">
          <source>The following methods can be used to transfer files between two remote servers, providing that these two servers can connect directly to each other.</source>
          <target state="translated">以下の方法は、これらの2つのサーバが互いに直接接続できることを条件に、2つのリモートサーバ間でファイルを転送するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="d8f54c9acd776fdfe4ac513355a1096a098e49e7" translate="yes" xml:space="preserve">
          <source>The following methods can return different results depending on how they are called. If the user explicitly calls either of the &lt;code&gt;pasv&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; methods then these methods will return a</source>
          <target state="translated">次のメソッドは、呼び出された方法に応じて異なる結果を返す可能性があります。ユーザーが &lt;code&gt;pasv&lt;/code&gt; または &lt;code&gt;port&lt;/code&gt; メソッドのいずれかを明示的に呼び出すと、これらのメソッドは</target>
        </trans-unit>
        <trans-unit id="48671c770c71c327c8f21494ae7c58eef76a7413" translate="yes" xml:space="preserve">
          <source>The following methods can then be used on the compartment object returned by the above constructor. The object argument is implicit in each case.</source>
          <target state="translated">そして、上記のコンストラクタによって返されたコンパートメントオブジェクトに対して、以下のメソッドを使用することができます。オブジェクトの引数は、それぞれのケースで暗黙的に指定されます。</target>
        </trans-unit>
        <trans-unit id="a9334f5feea4574b7400347c313e7ae3bde9f0a9" translate="yes" xml:space="preserve">
          <source>The following methods deal with queues on a FIFO basis.</source>
          <target state="translated">以下のメソッドは、FIFO ベースでキューを処理します。</target>
        </trans-unit>
        <trans-unit id="ee7cc6ee31a4cea12821df3d9ff6b6e073be7714" translate="yes" xml:space="preserve">
          <source>The following methods must be defined in order to support the use by Math::BigInt v1.70 or later.</source>
          <target state="translated">Math::BigInt v1.70 以降での使用をサポートするためには、以下のメソッドを定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="1f23966e0bc23b8a5a278ce7e5e420b3556e28b8" translate="yes" xml:space="preserve">
          <source>The following methods upgrade themselves unconditionally; that is if upgrade is in effect, they will always hand up their work:</source>
          <target state="translated">以下の方法では、無条件に自分自身をアップグレードします。</target>
        </trans-unit>
        <trans-unit id="314022e0b634f0a33992a5bea72595f23a273937" translate="yes" xml:space="preserve">
          <source>The following modules are currently used by bigint:</source>
          <target state="translated">現在 bigint が使用しているモジュールは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="086b35f723ebe590f75a1aea7b6b1150783292e6" translate="yes" xml:space="preserve">
          <source>The following modules are currently used by bignum:</source>
          <target state="translated">現在 bignum が使用しているモジュールは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="d93609e5247b12617e4dd3f00cb7708916287a29" translate="yes" xml:space="preserve">
          <source>The following names have special meaning to Perl. Most punctuation names have reasonable mnemonics, or analogs in the shells. Nevertheless, if you wish to use long variable names, you need only say:</source>
          <target state="translated">以下の名前は Perl にとって特別な意味を持っています。ほとんどの句読点名は、シェルの中では適切なニーモニックやアナログを持っています。それにもかかわらず、長い変数名を使いたい場合は</target>
        </trans-unit>
        <trans-unit id="8937b6a268204b01bd09b0791adaf0dc939c65b5" translate="yes" xml:space="preserve">
          <source>The following options affect what happens with &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; , and &lt;code&gt;x&lt;/code&gt; commands:</source>
          <target state="translated">次のオプションは、 &lt;code&gt;V&lt;/code&gt; 、 &lt;code&gt;X&lt;/code&gt; 、および &lt;code&gt;x&lt;/code&gt; コマンドで何が起こるかに影響します。</target>
        </trans-unit>
        <trans-unit id="87ad7915cdbf5aabf9ec8f4e6f650717a3e51ad5" translate="yes" xml:space="preserve">
          <source>The following options are available:</source>
          <target state="translated">以下のようなオプションがあります。</target>
        </trans-unit>
        <trans-unit id="5530497eb21d4e6a6dcc738d7ea1b33bd3ad244e" translate="yes" xml:space="preserve">
          <source>The following options are pairwise exclusive.</source>
          <target state="translated">以下のオプションはペアワイズエクスクルーシブです。</target>
        </trans-unit>
        <trans-unit id="82fa31556e7811972756a886a4cfa29a126dcd22" translate="yes" xml:space="preserve">
          <source>The following options are passed through to the underlying text formatter. See the manual pages of these modules for more information.</source>
          <target state="translated">以下のオプションは、基礎となるテキストフォーマッタに渡されます。詳細については、これらのモジュールのマニュアルページを参照してください。</target>
        </trans-unit>
        <trans-unit id="407cb3c611809d0d6a4a0229085dace99fab8aca" translate="yes" xml:space="preserve">
          <source>The following options are supported: center, date, fixed, fixedbold, fixeditalic, fixedbolditalic, quotes, release, section</source>
          <target state="translated">次のオプションがサポートされています:center、date、fixed、fixedbold、fixeditalic、fixedbolditalic、quotes、release、section。</target>
        </trans-unit>
        <trans-unit id="f9719c919f328c184200e9a901169faf3fe1692f" translate="yes" xml:space="preserve">
          <source>The following pattern matches a function foo() which may contain balanced parentheses as the argument.</source>
          <target state="translated">以下のパターンは、引数にバランスの取れた括弧を含む可能性のある関数 foo()にマッチします。</target>
        </trans-unit>
        <trans-unit id="88eac117835fd0d5e8fe0a92e17ee881d0f51bb6" translate="yes" xml:space="preserve">
          <source>The following pattern matches a parenthesized group:</source>
          <target state="translated">以下のパターンは、括弧で囲まれたグループと一致します。</target>
        </trans-unit>
        <trans-unit id="9261bf4cae54928a9960941cd2e6c763bb03b07b" translate="yes" xml:space="preserve">
          <source>The following platforms are known to build Perl 5.12 (as of April 2010, its release date) from the standard source code distribution available at &lt;a href=&quot;http://www.cpan.org/src&quot;&gt;http://www.cpan.org/src&lt;/a&gt;</source>
          <target state="translated">次のプラットフォームは、&lt;a href=&quot;http://www.cpan.org/src&quot;&gt;http：//www.cpan.org/srcで&lt;/a&gt;入手できる標準のソースコード配布からPerl 5.12（2010年4月現在、そのリリース日）をビルドすることがわかっています。</target>
        </trans-unit>
        <trans-unit id="3340ff1c2b446edebeb559ea5dd147cf80639131" translate="yes" xml:space="preserve">
          <source>The following platforms have been known to build Perl from source in the past (5.005_03 and earlier), but we haven't been able to verify their status for the current release, either because the hardware/software platforms are rare or because we don't have an active champion on these platforms--or both. They used to work, though, so go ahead and try compiling them, and let perlbug@perl.org of any trouble.</source>
          <target state="translated">以下のプラットフォームは、過去にソースから Perl をビルドすることが知られていますが (5.005_03 およびそれ以前)、現在のリリースではそれらの状態を確認することができませんでした。これらは以前は動作していましたので、コンパイルしてみてください。</target>
        </trans-unit>
        <trans-unit id="8c95fcd90364c113c8743d95c16878f685bbdec9" translate="yes" xml:space="preserve">
          <source>The following platforms have only binaries available via &lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html&lt;/a&gt; :</source>
          <target state="translated">次のプラットフォームには、&lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http&lt;/a&gt; : //www.cpan.org/ports/index.htmlから入手できるバイナリのみがあります。</target>
        </trans-unit>
        <trans-unit id="17f6cd1b99f9d8c8f96a2484ba6123182c8c7ea5" translate="yes" xml:space="preserve">
          <source>The following platforms have their own source code distributions and binaries available via &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt;</source>
          <target state="translated">次のプラットフォームには、独自のソースコードディストリビューションとバイナリがあり、&lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http：&lt;/a&gt; //www.cpan.org/ports/から入手できます。</target>
        </trans-unit>
        <trans-unit id="ba4505bcfd3048861117fe3f1683581b473bc260" translate="yes" xml:space="preserve">
          <source>The following platforms were supported by a previous version of Perl but have been officially removed from Perl's source code as of 5.12:</source>
          <target state="translated">以下のプラットフォームは以前のバージョンの Perl でサポートされていましたが、5.12 の時点で Perl のソースコードから公式に削除されています。</target>
        </trans-unit>
        <trans-unit id="231bce91c0774cb9ac67f2e9bf6e077f99a9edec" translate="yes" xml:space="preserve">
          <source>The following platforms were supported by a previous version of Perl but have been officially removed from Perl's source code as of 5.20:</source>
          <target state="translated">以下のプラットフォームは以前のバージョンのPerlでサポートされていましたが、5.20の時点でPerlのソースコードから公式に削除されています。</target>
        </trans-unit>
        <trans-unit id="ce7175eecbb5cf889a2f2cc3f026e2da7a9136e7" translate="yes" xml:space="preserve">
          <source>The following platforms were supported up to 5.10. They may still have worked in 5.12, but supporting code has been removed for 5.14:</source>
          <target state="translated">以下のプラットフォームは 5.10 までサポートされていました。これらは 5.12 でも動作していたかもしれませんが、5.14 ではサポートされていたコードが削除されています。</target>
        </trans-unit>
        <trans-unit id="446fc2176911919a5044a357259301549c936213" translate="yes" xml:space="preserve">
          <source>The following platforms worked with the previous releases (5.6 and 5.7), but we did not manage either to fix or to test these in time for the 5.8.0 release. There is a very good chance that many of these will work fine with the 5.8.0.</source>
          <target state="translated">以下のプラットフォームは以前のリリース (5.6 と 5.7)で動作しましたが、5.8.0 のリリースに間に合うように修正したり、テストしたりすることはできませんでした。これらの多くは5.8.0でも問題なく動作する可能性が非常に高いです。</target>
        </trans-unit>
        <trans-unit id="637d6920710e051f990eceb2af393917b297b61a" translate="yes" xml:space="preserve">
          <source>The following pragmas are defined (and have their own documentation).</source>
          <target state="translated">以下のプラグマが定義されています(独自のドキュメントを持っています)。</target>
        </trans-unit>
        <trans-unit id="3e891a8176dfddab918a655b139307ab8b66b513" translate="yes" xml:space="preserve">
          <source>The following primary functions are provided:</source>
          <target state="translated">主な機能は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="bbf69375b2075818b8dae7a187b7c74a5295e91b" translate="yes" xml:space="preserve">
          <source>The following problems are encountered with Haiku revision 28311:</source>
          <target state="translated">俳句改訂28311では、以下の問題が発生しています。</target>
        </trans-unit>
        <trans-unit id="d89ada30f3c9b0885c9f6f1b4c7448cd518fcaa4" translate="yes" xml:space="preserve">
          <source>The following returns the &lt;b&gt;names&lt;/b&gt; of the PerlIO layers on a filehandle.</source>
          <target state="translated">以下は、ファイルハンドル上のPerlIOレイヤーの&lt;b&gt;名前&lt;/b&gt;を返します。</target>
        </trans-unit>
        <trans-unit id="1bc9e3e129e691ac04ecb6526cec5a595482fff6" translate="yes" xml:space="preserve">
          <source>The following revisions are supported. The default is 30.</source>
          <target state="translated">以下のリビジョンに対応しています。デフォルトは30です。</target>
        </trans-unit>
        <trans-unit id="c446e9a76c2a849f3d9283f94a02c3c2d25e461d" translate="yes" xml:space="preserve">
          <source>The following routines will be exported into your namespace if you specifically ask that they be imported:</source>
          <target state="translated">以下のルーチンは、特にインポートを要求した場合、ネームスペースにエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="019be2c4bd05e066f928aafadb59663b3afde865" translate="yes" xml:space="preserve">
          <source>The following routines will be exported into your namespace if you use the Benchmark module:</source>
          <target state="translated">以下のルーチンは、Benchmark モジュールを使用している場合、ネームスペースにエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="de855448328b5e9f80cc8ce9168a701f985757d7" translate="yes" xml:space="preserve">
          <source>The following rules apply:</source>
          <target state="translated">以下のルールが適用されます。</target>
        </trans-unit>
        <trans-unit id="c3f236092c86ae50065ffb55ca5283dcb8508783" translate="yes" xml:space="preserve">
          <source>The following rules are available:</source>
          <target state="translated">以下のようなルールがあります。</target>
        </trans-unit>
        <trans-unit id="a8f5fc7c9bec47fa12d0874b935f8fd0b4ed0730" translate="yes" xml:space="preserve">
          <source>The following sample implementation of &lt;code&gt;minus()&lt;/code&gt; (which assumes that &lt;code&gt;Number&lt;/code&gt; objects are simply blessed references to scalars) illustrates the calling conventions:</source>
          <target state="translated">次の &lt;code&gt;minus()&lt;/code&gt; サンプル実装（ &lt;code&gt;Number&lt;/code&gt; オブジェクトは単にblessされたスカラーへの参照であると想定しています）は、呼び出し規約を示しています。</target>
        </trans-unit>
        <trans-unit id="67999be44740f8addea9fce4caf76726233a8acf" translate="yes" xml:space="preserve">
          <source>The following sequences (except &lt;code&gt;\N&lt;/code&gt; ) work within or without a character class. The first six are locale aware, all are Unicode aware. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for details.</source>
          <target state="translated">次のシーケンス（ &lt;code&gt;\N&lt;/code&gt; を除く）は、文字クラス内または文字クラスなしで機能します。最初の6つはロケール対応で、すべてがUnicode対応です。詳細については、&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;および&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6520d28097d378d9470274294d01c67b34c1c70f" translate="yes" xml:space="preserve">
          <source>The following set of functions all reduce a list down to a single value.</source>
          <target state="translated">以下の一連の関数は、すべてリストを1つの値に縮小します。</target>
        </trans-unit>
        <trans-unit id="31f700e59048089f2fca9626afc48c135af0fec0" translate="yes" xml:space="preserve">
          <source>The following set of functions, all inspired by &lt;a href=&quot;http://search.cpan.org/perldoc/List::Pairwise&quot;&gt;List::Pairwise&lt;/a&gt;, consume an even-sized list of pairs. The pairs may be key/value associations from a hash, or just a list of values. The functions will all preserve the original ordering of the pairs, and will not be confused by multiple pairs having the same &quot;key&quot; value - nor even do they require that the first of each pair be a plain string.</source>
          <target state="translated">次の一連の関数は、すべて&lt;a href=&quot;http://search.cpan.org/perldoc/List::Pairwise&quot;&gt;List :: Pairwise&lt;/a&gt;からヒントを得て、偶数サイズのペアのリストを消費します。ペアは、ハッシュからのキー/値の関連付け、または単なる値のリストです。これらの関数はすべて、ペアの元の順序を保持し、同じ「キー」値を持つ複数のペアによって混乱することはありません。各ペアの最初の文字列がプレーンな文字列である必要もありません。</target>
        </trans-unit>
        <trans-unit id="bf58c9289e75f1b85afc527d37ec88624aafe8e0" translate="yes" xml:space="preserve">
          <source>The following setting are currently preserved: history, breakpoints, actions, debugger options, and the Perl command-line options &lt;b&gt;-w&lt;/b&gt;, &lt;b&gt;-I&lt;/b&gt;, and &lt;b&gt;-e&lt;/b&gt;.</source>
          <target state="translated">現在保持されている設定は、履歴、ブレークポイント、アクション、デバッガーオプション、およびPerlコマンドラインオプション&lt;b&gt;-w&lt;/b&gt;、&lt;b&gt;-I&lt;/b&gt;、および&lt;b&gt;-e&lt;/b&gt;です。</target>
        </trans-unit>
        <trans-unit id="2f9e7f8b992aecf2d6263a37f2844fd220110139" translate="yes" xml:space="preserve">
          <source>The following shows how using negative indexing can make it easier to embed recursive patterns inside of a &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; construct for later use:</source>
          <target state="translated">次の例は、負のインデックスを使用して、後で使用するために再帰パターンを &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 構成の中に簡単に埋め込む方法を示しています。</target>
        </trans-unit>
        <trans-unit id="1462e7325e21b0e3087981f44f0af9a643d8599d" translate="yes" xml:space="preserve">
          <source>The following shows the raw form of a reference to a hash.</source>
          <target state="translated">以下は、ハッシュへの参照の生の形を示しています。</target>
        </trans-unit>
        <trans-unit id="967f133103c60d10e71b0c793260fc3ac77b40c4" translate="yes" xml:space="preserve">
          <source>The following single statement:</source>
          <target state="translated">次のような一文があります。</target>
        </trans-unit>
        <trans-unit id="2e884b22f85adb1ade979bfac548d842a78ee34c" translate="yes" xml:space="preserve">
          <source>The following standard quantifiers are recognized:</source>
          <target state="translated">以下の標準的な定量器が認識されています。</target>
        </trans-unit>
        <trans-unit id="f4477e5386cec5d30c1ffdf2df262ef158032a46" translate="yes" xml:space="preserve">
          <source>The following structure is used as the &lt;code&gt;pprivate&lt;/code&gt; struct by perl's regex engine. Since it is specific to perl it is only of curiosity value to other engine implementations.</source>
          <target state="translated">次の構造は、perlの正規表現エンジンによって &lt;code&gt;pprivate&lt;/code&gt; 構造体として使用されます。これはperlに固有であるため、他のエンジン実装にとっては好奇心の価値があります。</target>
        </trans-unit>
        <trans-unit id="89e9367ea2c2e9bf561ef1309852d2cf7361c03c" translate="yes" xml:space="preserve">
          <source>The following subroutines are available for general use once this module has been loaded:</source>
          <target state="translated">このモジュールがロードされると、以下のサブルーチンが一般的に使用できます。</target>
        </trans-unit>
        <trans-unit id="ba25a356d8138d41be0a86a5f5fb1d08b7adedd8" translate="yes" xml:space="preserve">
          <source>The following subsections describe basic locale categories. Beyond these, some combination categories allow manipulation of more than one basic category at a time. See &lt;a href=&quot;#ENVIRONMENT&quot;&gt;ENVIRONMENT&lt;/a&gt; for a discussion of these.</source>
          <target state="translated">次のサブセクションでは、基本的なロケールカテゴリについて説明します。これらを超えて、一部の組み合わせカテゴリでは、一度に複数の基本カテゴリを操作できます。これらの説明については、&lt;a href=&quot;#ENVIRONMENT&quot;&gt;環境&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="00832acd024c7ea26f0714974719f6fe15f3259e" translate="yes" xml:space="preserve">
          <source>The following systems contain with PA-RISC 1.1 chips:</source>
          <target state="translated">以下のシステムにはPA-RISC 1.1チップが含まれています。</target>
        </trans-unit>
        <trans-unit id="6b127f4160144d76492f304d4812a08c409c1ee2" translate="yes" xml:space="preserve">
          <source>The following systems contained PA-RISC 1.0 chips:</source>
          <target state="translated">PA-RISC 1.0チップを搭載した以下のシステム。</target>
        </trans-unit>
        <trans-unit id="c10d1b335971cff8856d57f7108722f96d961255" translate="yes" xml:space="preserve">
          <source>The following table is a complete listing of characters matched by &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt; as of Unicode 6.3.</source>
          <target state="translated">次の表は、Unicode 6.3の時点で &lt;code&gt;\s&lt;/code&gt; 、 &lt;code&gt;\h&lt;/code&gt; 、および &lt;code&gt;\v&lt;/code&gt; と一致する文字の完全なリストです。</target>
        </trans-unit>
        <trans-unit id="b30fe71571a9a6420e717590392f76849f4888c3" translate="yes" xml:space="preserve">
          <source>The following table is from Unicode 3.2.</source>
          <target state="translated">以下の表はUnicode 3.2のものです。</target>
        </trans-unit>
        <trans-unit id="08ac1fd17048e5aaff438c3920650ea36fe28bd5" translate="yes" xml:space="preserve">
          <source>The following table shows the result of the division and the remainder, so that the equation above holds true. Some &quot;ordinary&quot; cases are strewn in to show more clearly the reasoning:</source>
          <target state="translated">次の表は、上の式が真であるように、割り算と余りの結果を示しています。推論をより明確に示すために、いくつかの「普通の」ケースを散りばめています。</target>
        </trans-unit>
        <trans-unit id="3985fef65ba4e91f6d3780d0b3e49df58907d0ee" translate="yes" xml:space="preserve">
          <source>The following table summarizes the default layers on UNIX-like and DOS-like platforms and depending on the setting of &lt;code&gt;$ENV{PERLIO}&lt;/code&gt; :</source>
          <target state="translated">次の表は、 &lt;code&gt;$ENV{PERLIO}&lt;/code&gt; 設定に応じて、UNIXライクおよびDOSライクなプラットフォームのデフォルトレイヤーをまとめたものです。</target>
        </trans-unit>
        <trans-unit id="72667df1c110c1893cb08480bc1c250b48c0cb32" translate="yes" xml:space="preserve">
          <source>The following tables list the ASCII and Latin 1 ordered sets including the subsets: C0 controls (0..31), ASCII graphics (32..7e), delete (7f), C1 controls (80..9f), and Latin-1 (a.k.a. ISO 8859-1) (a0..ff). In the table names of the Latin 1 extensions to ASCII have been labelled with character names roughly corresponding to</source>
          <target state="translated">以下の表は、サブセットを含むASCIIとLatin-1の順序付きセットをリストアップしたものです。C0 コントロール (0...31)、ASCII グラフィックス (32...7e)、削除 (7f)、C1 コントロール (80...9f)、および Latin-1 (別名 ISO 8859-1)(a0...ff)。表の中では、ASCII への Latin 1 拡張の名前には、大体</target>
        </trans-unit>
        <trans-unit id="a992ed291bf59a4f8c8642c8859ba903d7ab1f6d" translate="yes" xml:space="preserve">
          <source>The following tests are still failing for Perl 5.8.1 under QNX 6.2.0:</source>
          <target state="translated">以下のテストは、QNX 6.2.0 の下の Perl 5.8.1 でまだ失敗しています。</target>
        </trans-unit>
        <trans-unit id="679b51afc9785d4ea117543e0a14a59d2cf8f5c2" translate="yes" xml:space="preserve">
          <source>The following tests may report errors under QNX4:</source>
          <target state="translated">以下のテストでは、QNX4 でのエラーが報告されることがあります。</target>
        </trans-unit>
        <trans-unit id="3fcf934fd04c9d50192b3311166eff55a4dd9606" translate="yes" xml:space="preserve">
          <source>The following three functions copy integer, unsigned integer or double into an SV whose reference is &lt;code&gt;rv&lt;/code&gt; . SV is blessed if &lt;code&gt;classname&lt;/code&gt; is non-null.</source>
          <target state="translated">次の3つの関数は、整数、符号なし整数、またはdoubleを、参照が &lt;code&gt;rv&lt;/code&gt; であるSVにコピーします。 &lt;code&gt;classname&lt;/code&gt; がnullでない場合、SVは祝福されます。</target>
        </trans-unit>
        <trans-unit id="ab708869e7683ae4c6749cf27fcceca80c5c3008" translate="yes" xml:space="preserve">
          <source>The following three macros are used to initially allocate memory :</source>
          <target state="translated">以下の 3 つのマクロを使用して、最初にメモリを割り当てます。</target>
        </trans-unit>
        <trans-unit id="2d49873237bd9d666bf47ecb1ff27e7adc795d90" translate="yes" xml:space="preserve">
          <source>The following two calls behave identically:</source>
          <target state="translated">以下の2つの呼び出しは同じように動作します。</target>
        </trans-unit>
        <trans-unit id="2886be86660a6181dbf2332b9a39bde42d1bded2" translate="yes" xml:space="preserve">
          <source>The following types of change are NOT acceptable:</source>
          <target state="translated">以下のような変更は認められません。</target>
        </trans-unit>
        <trans-unit id="000a0a677c5358a2d9618715cbd6c3b2ea88fed1" translate="yes" xml:space="preserve">
          <source>The following types of change may be considered acceptable, as long as they do not also fall into any of the &quot;unacceptable&quot; categories set out below:</source>
          <target state="translated">以下のタイプの変更は、以下の「容認できない」カテゴリーに該当しない限り、容認できると考えられます。</target>
        </trans-unit>
        <trans-unit id="502bd00665528041c42b284ac29aaf12f2929946" translate="yes" xml:space="preserve">
          <source>The following values can be set by passing &lt;code&gt;config()&lt;/code&gt; a reference to a hash:</source>
          <target state="translated">次の値は、 &lt;code&gt;config()&lt;/code&gt; にハッシュへの参照を渡すことで設定できます。</target>
        </trans-unit>
        <trans-unit id="93c42f22f8e09b7cd455ba48443cb114b75d6049" translate="yes" xml:space="preserve">
          <source>The following variables are 'defined' by B::Concise; when they are used in a style, their respective values are plugged into the rendering of each opcode.</source>
          <target state="translated">以下の変数はB::Conciseによって「定義」されています;それらがスタイルで使用されるとき、それぞれの値は各オペコードのレンダリングに差し込まれます。</target>
        </trans-unit>
        <trans-unit id="706034b4d6cc89451a1849a613921860ab0e5afc" translate="yes" xml:space="preserve">
          <source>The following variables need to be set &lt;b&gt;before&lt;/b&gt; the call to the -&amp;gt;new constructor.</source>
          <target state="translated">-&amp;gt; newコンストラクタを呼び出す&lt;b&gt;前に&lt;/b&gt;、次の変数を設定&lt;b&gt;する&lt;/b&gt;必要があります。</target>
        </trans-unit>
        <trans-unit id="182dfc2e543ebf62f55632eff4a16082cef70bfe" translate="yes" xml:space="preserve">
          <source>The following variables work differently:</source>
          <target state="translated">以下の変数の動作が異なります。</target>
        </trans-unit>
        <trans-unit id="076a97e0e26cc34846172ca450710de9a3595069" translate="yes" xml:space="preserve">
          <source>The following were implemented with</source>
          <target state="translated">で実施しました。</target>
        </trans-unit>
        <trans-unit id="79ed55c53c285526808c76c6e4fadf315b9d9ae9" translate="yes" xml:space="preserve">
          <source>The following will determine the maximum length of the longest allowable pathname on the filesystem which holds</source>
          <target state="translated">以下のようにすることで、ファイルシステム上の</target>
        </trans-unit>
        <trans-unit id="d57dd39f43cd00fc9fcf08a3e6ef2330c6e56ff0" translate="yes" xml:space="preserve">
          <source>The following will determine the maximum length of the longest allowable pathname on the filesystem which holds &lt;code&gt;/var&lt;/code&gt;.</source>
          <target state="translated">次の例では、 &lt;code&gt;/var&lt;/code&gt; を保持するファイルシステムで許可される最長のパス名の最大長を決定します。</target>
        </trans-unit>
        <trans-unit id="5cbb13ad67db7840db7c7d12b58ddc55ef0ed900" translate="yes" xml:space="preserve">
          <source>The following will get the machine's clock speed.</source>
          <target state="translated">以下はマシンのクロック速度を取得します。</target>
        </trans-unit>
        <trans-unit id="577c472e2dc0fc4d87aa88d05e48ae7e476e2971" translate="yes" xml:space="preserve">
          <source>The following will probably not do what you expect:</source>
          <target state="translated">以下のようなことは、おそらく期待していた通りにはならないでしょう。</target>
        </trans-unit>
        <trans-unit id="5c8bd82fe901dea332f23983ad9e29577c0fed4c" translate="yes" xml:space="preserve">
          <source>The following will probably not print what you expect:</source>
          <target state="translated">以下は、おそらく期待していたものが印刷されません。</target>
        </trans-unit>
        <trans-unit id="119de64c9692dd9e013f0596370be8f29169b856" translate="yes" xml:space="preserve">
          <source>The following will query the current &lt;code&gt;LC_CTYPE&lt;/code&gt; category. (No second argument means 'query'.)</source>
          <target state="translated">次は、現在の &lt;code&gt;LC_CTYPE&lt;/code&gt; カテゴリを照会します。（2番目の引数は「クエリ」を意味しません。）</target>
        </trans-unit>
        <trans-unit id="5966453b4cde6268559966748dc7d8bf8fdd0ec2" translate="yes" xml:space="preserve">
          <source>The following will set the &lt;code&gt;LC_COLLATE&lt;/code&gt; behaviour to Argentinian Spanish. &lt;b&gt;NOTE&lt;/b&gt;: The naming and availability of locales depends on your operating system. Please consult &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; for how to find out which locales are available in your system.</source>
          <target state="translated">以下は &lt;code&gt;LC_COLLATE&lt;/code&gt; の動作をアルゼンチンのスペイン語に設定します。&lt;b&gt;注&lt;/b&gt;：ロケールの命名と可用性は、オペレーティングシステムによって異なります。システムで使用可能なロケールを確認する方法については、&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5abcdbfe7d0b6ac6ed18a19f7b6cc537b1839b5d" translate="yes" xml:space="preserve">
          <source>The following will set the &lt;code&gt;LC_CTYPE&lt;/code&gt; behaviour according to the locale environment variables (the second argument &lt;code&gt;&quot;&quot;&lt;/code&gt; ). Please see your system's &lt;code&gt;setlocale(3)&lt;/code&gt; documentation for the locale environment variables' meaning or consult &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">以下は、ロケール環境変数（2番目の引数 &lt;code&gt;&quot;&quot;&lt;/code&gt; ）に従って &lt;code&gt;LC_CTYPE&lt;/code&gt; の動作を設定します。ロケールの環境変数の意味については、システムの &lt;code&gt;setlocale(3)&lt;/code&gt; のドキュメントを参照するか、&lt;a href=&quot;perllocale&quot;&gt;perllocaleを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ecbd57a3195c4519fb09fab198f3facf1b32479f" translate="yes" xml:space="preserve">
          <source>The following will set the traditional UNIX system locale behavior (the second argument &lt;code&gt;&quot;C&quot;&lt;/code&gt; ).</source>
          <target state="translated">以下は、従来のUNIXシステムのロケール動作を設定します（2番目の引数 &lt;code&gt;&quot;C&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d394598bfc021311cf0f2bb824273bc318b5797a" translate="yes" xml:space="preserve">
          <source>The following would first try to find Math::BigInt::Foo, then Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:</source>
          <target state="translated">以下は、まず Math::BigInt::Foo を見つけ、次に Math::BigInt::Bar を見つけようとし、これも失敗したら Math::BigInt::Calc に戻します。</target>
        </trans-unit>
        <trans-unit id="9ce20518f56534bcc1118c0bf986d78eef528c90" translate="yes" xml:space="preserve">
          <source>The following:</source>
          <target state="translated">次のようになっています。</target>
        </trans-unit>
        <trans-unit id="678f5358c7187caa2da5eff48aaaa0b704fbae9c" translate="yes" xml:space="preserve">
          <source>The followings items are mostly for reference and general Unicode knowledge, Perl doesn't use these constructs internally.</source>
          <target state="translated">以下の項目は主に参照用と一般的なUnicodeの知識のためのもので、Perlはこれらの構文を内部的に使用していません。</target>
        </trans-unit>
        <trans-unit id="0e4f79728d04ec0471d6bf96e407b112aa0cabf3" translate="yes" xml:space="preserve">
          <source>The foregoing mechanism for overriding built-in is restricted, quite deliberately, to the package that requests the import. There is a second method that is sometimes applicable when you wish to override a built-in everywhere, without regard to namespace boundaries. This is achieved by importing a sub into the special namespace &lt;code&gt;CORE::GLOBAL::&lt;/code&gt; . Here is an example that quite brazenly replaces the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator with something that understands regular expressions.</source>
          <target state="translated">組み込みをオーバーライドする前述のメカニズムは、非常に慎重に、インポートを要求するパッケージに制限されています。名前空間の境界に関係なく、どこでも組み込みをオーバーライドしたい場合に適用できる2番目の方法があります。これは、特別な名前空間 &lt;code&gt;CORE::GLOBAL::&lt;/code&gt; サブをインポートすることで実現されます。これは、 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 演算子を正規表現を理解できるものにかなり勇気なく置き換えた例です。</target>
        </trans-unit>
        <trans-unit id="b85c90a6a43ec9e5bf7a5a11ec769ca8bd55e119" translate="yes" xml:space="preserve">
          <source>The fork() emulation is implemented at the level of the Perl interpreter. What this means in general is that running fork() will actually clone the running interpreter and all its state, and run the cloned interpreter in a separate thread, beginning execution in the new thread just after the point where the fork() was called in the parent. We will refer to the thread that implements this child &quot;process&quot; as the pseudo-process.</source>
          <target state="translated">fork()エミュレーションは Perl インタプリタのレベルで実装されています。これが一般的に意味することは、fork()を実行すると、実際に実行中のインタープリタとそのすべての状態がクローン化され、クローン化されたインタープリタが別のスレッドで実行され、親側で fork()が呼び出されたポイントの直後に新しいスレッドで実行が開始されるということです。この子プロセスを実装したスレッドを疑似プロセスと呼びます。</target>
        </trans-unit>
        <trans-unit id="e04f09879ad602b86af95f9f6d5d371e6757eda4" translate="yes" xml:space="preserve">
          <source>The fork() emulation may not behave as expected when it is executed in an application which embeds a Perl interpreter and calls Perl APIs that can evaluate bits of Perl code. This stems from the fact that the emulation only has knowledge about the Perl interpreter's own data structures and knows nothing about the containing application's state. For example, any state carried on the application's own call stack is out of reach.</source>
          <target state="translated">fork()エミュレーションは、Perl インタプリタを埋め込み、Perl コードのビットを評価できる Perl API を呼び出すアプリケーションで実行されると、期待通りに動作しないことがあります。これは、エミュレーションが Perl インタプリタ自身のデータ構造についてのみ知識を持ち、含まれるアプリケーションの状態については何も知らないという事実に起因しています。例えば、アプリケーション自身のコールスタック上に保持されている状態は、手の届かないところにあります。</target>
        </trans-unit>
        <trans-unit id="0708717756f902c5ff59069bd45289469d28d91c" translate="yes" xml:space="preserve">
          <source>The fork() emulation will not work entirely correctly when called from within a BEGIN block. The forked copy will run the contents of the BEGIN block, but will not continue parsing the source stream after the BEGIN block. For example, consider the following code:</source>
          <target state="translated">fork()エミュレーションは、BEGIN ブロック内から呼び出された場合、完全には正しく動作しません。フォークされたコピーは BEGIN ブロックの内容を実行しますが、BEGIN ブロックの後にソースストリームの解析を続けません。例えば、次のコードを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="15be1c6ce9042f03bee94913baeb82a3ff565ee8" translate="yes" xml:space="preserve">
          <source>The fork() has to come before the setsid() to ensure you aren't a process group leader; the setsid() will fail if you are. If your system doesn't have the setsid() function, open</source>
          <target state="translated">fork()は setsid()の前に来なければならないので、あなたがプロセスグループリーダでないことを確認してください。システムに setsid()関数がない場合は</target>
        </trans-unit>
        <trans-unit id="9d31d094967d18a344cd7885a66ada91947ca8a3" translate="yes" xml:space="preserve">
          <source>The forked debugger requires the environment variable &lt;code&gt;TERM&lt;/code&gt; to be &lt;code&gt;xterm&lt;/code&gt; , and the environment variable &lt;code&gt;DISPLAY&lt;/code&gt; to exist. &lt;code&gt;xterm&lt;/code&gt; must be in lower case.</source>
          <target state="translated">フォークされたデバッガーでは、環境変数 &lt;code&gt;TERM&lt;/code&gt; が &lt;code&gt;xterm&lt;/code&gt; であり、環境変数 &lt;code&gt;DISPLAY&lt;/code&gt; が存在している必要があります。 &lt;code&gt;xterm&lt;/code&gt; は小文字でなければなりません。</target>
        </trans-unit>
        <trans-unit id="90a1b936aa7515813dbe100195592b08e94ebcb1" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;$x **= $y&lt;/code&gt; is faster than &lt;code&gt;$x = $x ** $y;&lt;/code&gt; , though.</source>
          <target state="translated">&lt;code&gt;$x **= $y&lt;/code&gt; の形式は、 &lt;code&gt;$x = $x ** $y;&lt;/code&gt; よりも高速です。、しかし。</target>
        </trans-unit>
        <trans-unit id="ea29df8f31e738f8731934d29265ffb8df1b05f7" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;while/if BLOCK BLOCK&lt;/code&gt;, available in Perl 4, is no longer available. Replace any occurrence of &lt;code&gt;if BLOCK&lt;/code&gt; by &lt;code&gt;if (&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK)&lt;/code&gt; .</source>
          <target state="translated">Perl 4で使用可能な &lt;code&gt;while/if BLOCK BLOCK&lt;/code&gt; の形式は使用できなくなりました。 &lt;code&gt;if BLOCK&lt;/code&gt; の出現箇所を &lt;code&gt;if (&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK)&lt;/code&gt; で置き換えます。</target>
        </trans-unit>
        <trans-unit id="c0d89d2ce75f6dd9a5b033644a202a3e0573863e" translate="yes" xml:space="preserve">
          <source>The formal syntax of a section specification is:</source>
          <target state="translated">セクション指定の正式な構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="feafac52c2f0bb1c62c34d80f1ccae00a8b7bff5" translate="yes" xml:space="preserve">
          <source>The format is roughly the same as a header section except for the fallback flag: | followed by 0..3. The meaning of the possible values is as follows:</source>
          <target state="translated">形式は、フォールバックフラグを除いて、ヘッダ部とほぼ同じです。| の後に0...3が続きます。取り得る値の意味は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="7de51818a43a9eeabc5f149d791bcd953969e5ec" translate="yes" xml:space="preserve">
          <source>The format is the same as PREREQ_PM.</source>
          <target state="translated">フォーマットはPREREQ_PMと同じです。</target>
        </trans-unit>
        <trans-unit id="4a91025674068746c104cf678dff09a87e09a62d" translate="yes" xml:space="preserve">
          <source>The format is:</source>
          <target state="translated">形式になっています。</target>
        </trans-unit>
        <trans-unit id="cab7930ea8f9bb0b5e8551406e705f9d6d55872a" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; コンストラクターの形式を以下に示します。</target>
        </trans-unit>
        <trans-unit id="2b7f4c6f10c021d585a52efc7c38f1f01339227d" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Deflate&lt;/code&gt; コンストラクターの形式を以下に示します。</target>
        </trans-unit>
        <trans-unit id="e03dc6c86b8958f9b62ec7a6a483ad0e4753decb" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Gzip&lt;/code&gt; コンストラクターの形式を以下に示します。</target>
        </trans-unit>
        <trans-unit id="2cd916282c4e6b36ecc3a6af27b028bb638d27b9" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; コンストラクターの形式を以下に示します。</target>
        </trans-unit>
        <trans-unit id="96cf103266184d2ab7c512526262f24222f5b3fa" translate="yes" xml:space="preserve">
          <source>The format of the constructor for &lt;code&gt;IO::Compress::Zip&lt;/code&gt; is shown below</source>
          <target state="translated">&lt;code&gt;IO::Compress::Zip&lt;/code&gt; コンストラクターの形式を以下に示します。</target>
        </trans-unit>
        <trans-unit id="7cddd4e7224584228dd40d8278ce06df26d30be6" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::AnyInflate is shown below</source>
          <target state="translated">IO::Uncompress::AnyInflate のコンストラクタのフォーマットを以下に示します。</target>
        </trans-unit>
        <trans-unit id="f335334476f7fdad7a158077eda96d1e77d620ba" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::AnyUncompress is shown below</source>
          <target state="translated">IO::Uncompress::AnyUncompress のコンストラクタのフォーマットを以下に示します。</target>
        </trans-unit>
        <trans-unit id="d8f9f10c69da3c0a902ce3d0bf3a43a4fe3d0d99" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Bunzip2 is shown below</source>
          <target state="translated">IO::Uncompress::Bunzip2 のコンストラクタのフォーマットを以下に示します。</target>
        </trans-unit>
        <trans-unit id="1aee64e705754fe9513f8b1c5a275541fbf25126" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Gunzip is shown below</source>
          <target state="translated">IO::Uncompress::Gunzip のコンストラクタのフォーマットを以下に示します。</target>
        </trans-unit>
        <trans-unit id="e0479ea0c00c6dbc0391fab896f56792a7f58abf" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Inflate is shown below</source>
          <target state="translated">IO::Uncompress::Inflate のコンストラクタのフォーマットを以下に示します。</target>
        </trans-unit>
        <trans-unit id="abbcd988c20a7a7af1b1b62b62f212c0f098a642" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::RawInflate is shown below</source>
          <target state="translated">IO::Uncompress::RawInflate のコンストラクタのフォーマットを以下に示します。</target>
        </trans-unit>
        <trans-unit id="266217c42524ecb82328e7bc0e8f8cf67f30e119" translate="yes" xml:space="preserve">
          <source>The format of the constructor for IO::Uncompress::Unzip is shown below</source>
          <target state="translated">IO::Uncompress::Unzip のコンストラクタのフォーマットを以下に示します。</target>
        </trans-unit>
        <trans-unit id="6ce17f5dc7d5e6006e0ab81d86bb016be0d29f0f" translate="yes" xml:space="preserve">
          <source>The format of this scalar value is &lt;b&gt;not&lt;/b&gt; locale-dependent but built into Perl. For GMT instead of local time use the &lt;a href=&quot;#gmtime&quot;&gt;gmtime&lt;/a&gt; builtin. See also the &lt;code&gt;Time::Local&lt;/code&gt; module (for converting seconds, minutes, hours, and such back to the integer value returned by time()), and the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module's strftime(3) and mktime(3) functions.</source>
          <target state="translated">このスカラー値の形式はロケールに依存&lt;b&gt;せず&lt;/b&gt;、Perlに組み込まれて&lt;b&gt;い&lt;/b&gt;ます。現地時間ではなくGMTの場合は、組み込みの&lt;a href=&quot;#gmtime&quot;&gt;gmtimeを&lt;/a&gt;使用します。参照してください &lt;code&gt;Time::Local&lt;/code&gt; モジュール（変換秒、分、時間、および時間によって返された整数値（）に、このようなバックのために）、および&lt;a href=&quot;posix&quot;&gt;POSIXの&lt;/a&gt;モジュールのはstrftime（3）とはmktime（3）機能。</target>
        </trans-unit>
        <trans-unit id="e2da41af1cf680b6887d63dd253c6e01471391c6" translate="yes" xml:space="preserve">
          <source>The format of this scalar value is &lt;b&gt;not&lt;/b&gt; locale-dependent but built into Perl. For GMT instead of local time use the &lt;a href=&quot;gmtime&quot;&gt;gmtime&lt;/a&gt; builtin. See also the &lt;code&gt;Time::Local&lt;/code&gt; module (for converting seconds, minutes, hours, and such back to the integer value returned by time()), and the &lt;a href=&quot;../posix&quot;&gt;POSIX&lt;/a&gt; module's strftime(3) and mktime(3) functions.</source>
          <target state="translated">このスカラー値の形式はロケールに依存&lt;b&gt;せず&lt;/b&gt;、Perlに組み込まれて&lt;b&gt;い&lt;/b&gt;ます。現地時間ではなくGMTの場合は、組み込みの&lt;a href=&quot;gmtime&quot;&gt;gmtimeを&lt;/a&gt;使用します。参照してください &lt;code&gt;Time::Local&lt;/code&gt; モジュール（変換秒、分、時間、および時間によって返された整数値（）に、このようなバックのために）、および&lt;a href=&quot;../posix&quot;&gt;POSIXの&lt;/a&gt;モジュールのはstrftime（3）とはmktime（3）機能。</target>
        </trans-unit>
        <trans-unit id="7fb9dcbdf87a920318a01eb480379e8f7c7c3de2" translate="yes" xml:space="preserve">
          <source>The format specifier detection is not complete printf-syntax detection, but it should catch most common cases.</source>
          <target state="translated">フォーマット指定子の検出は完全なprintf-syntax検出ではありませんが、ほとんどの一般的なケースをキャッチできるはずです。</target>
        </trans-unit>
        <trans-unit id="256ecd9d04a27fc1ec23dd2c77863e67bcf5ad16" translate="yes" xml:space="preserve">
          <source>The formats supported are</source>
          <target state="translated">サポートされているフォーマットは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="0577a9efbbb4297e7d5cf847fb8e2a9cc4cdfef4" translate="yes" xml:space="preserve">
          <source>The formats supported are:</source>
          <target state="translated">サポートされているフォーマットは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="f7762b6266ff516b0fab73ac7af6d025adc1f538" translate="yes" xml:space="preserve">
          <source>The formats that can convert characters to numbers and vice versa will be different from their ASCII counterparts when executed on an EBCDIC platform. Examples include:</source>
          <target state="translated">文字を数字に変換できるフォーマットやその逆のフォーマットは、EBCDICプラットフォーム上で実行された場合、ASCII対応のものとは異なります。例としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="5f27c48c4d04704c74b0b5d7d716d5ed43b40c07" translate="yes" xml:space="preserve">
          <source>The former default in which Perl would always use a loose interpretation of UTF-8 has now been overruled:</source>
          <target state="translated">Perl が常に UTF-8 の緩い解釈を使用するという以前のデフォルトは、現在では覆されています。</target>
        </trans-unit>
        <trans-unit id="bacc21ee4934a43e7cffae5409abb3139d8d7444" translate="yes" xml:space="preserve">
          <source>The former is defined to imply Unicode handling; and the latter indicates a Unicode locale, hence a Unicode interpretation of all strings within it.</source>
          <target state="translated">前者はUnicode処理を意味すると定義されており、後者はUnicodeロケールを示し、その中のすべての文字列のUnicode解釈を意味します。</target>
        </trans-unit>
        <trans-unit id="abc8578e218b1958e7644bd43d9d008d1386b618" translate="yes" xml:space="preserve">
          <source>The formerly undocumented STRICT argument sets strictness: if true 'use strict;' is used, otherwise it uses 'no strict;'. &lt;b&gt;Note&lt;/b&gt;: if STRICT is omitted 'no strict;' is the default.</source>
          <target state="translated">以前は文書化されていなかったSTRICT引数は、厳密さを設定します。が使用され、それ以外の場合は「no strict;」が使用されます。&lt;b&gt;注&lt;/b&gt;：STRICTが省略されている場合、「厳密ではありません」。デフォルトです。</target>
        </trans-unit>
        <trans-unit id="e8c48d78ca541fb734f8a681b44e6478f12be1be" translate="yes" xml:space="preserve">
          <source>The forms &lt;code&gt;(?'NAME'pattern)&lt;/code&gt; and &lt;code&gt;(?&amp;lt;NAME&amp;gt;pattern)&lt;/code&gt; are equivalent.</source>
          <target state="translated">&lt;code&gt;(?'NAME'pattern)&lt;/code&gt; と &lt;code&gt;(?&amp;lt;NAME&amp;gt;pattern)&lt;/code&gt; という形式は同等です。</target>
        </trans-unit>
        <trans-unit id="3165776bcfd76f28e0c24205090accd64be6f1e3" translate="yes" xml:space="preserve">
          <source>The formula is from the Red Dragon book (reformulated to use the data available) and is documented at &lt;a href=&quot;http://www.strchr.com/hash_functions&quot;&gt;http://www.strchr.com/hash_functions&lt;/a&gt;</source>
          <target state="translated">式はRed Dragonブック（利用可能なデータを使用するように再構成された）からのものであり、&lt;a href=&quot;http://www.strchr.com/hash_functions&quot;&gt;http：//www.strchr.com/hash_functionsに&lt;/a&gt;文書化されています。</target>
        </trans-unit>
        <trans-unit id="ea332d524efecd12f52e313e0715e604daa7345f" translate="yes" xml:space="preserve">
          <source>The four &lt;code&gt;CPAN::*&lt;/code&gt; Classes: Author, Bundle, Module, Distribution</source>
          <target state="translated">4つの &lt;code&gt;CPAN::*&lt;/code&gt; クラス：Author、Bundle、Module、Distribution</target>
        </trans-unit>
        <trans-unit id="4ebe0eef114ce361363114266a5b30d9fc215c2f" translate="yes" xml:space="preserve">
          <source>The four &lt;code&gt;filter_*&lt;/code&gt; methods shown above are available in all the DBM modules that ship with Perl, namely DB_File, GDBM_File, NDBM_File, ODBM_File and SDBM_File.</source>
          <target state="translated">上記の4つの &lt;code&gt;filter_*&lt;/code&gt; メソッドは、Perlに同梱されているすべてのDBMモジュール、つまりDB_File、GDBM_File、NDBM_File、ODBM_File、SDBM_Fileで使用できます。</target>
        </trans-unit>
        <trans-unit id="a87cd62b5e4a547576560e5204e87547d60f9cfe" translate="yes" xml:space="preserve">
          <source>The four CPAN::* Classes: Author, Bundle, Module, Distribution</source>
          <target state="translated">4つのCPAN::*クラス。作成者、バンドル、モジュール、配布</target>
        </trans-unit>
        <trans-unit id="fe1fb546f60704c6d1d156b3f6fadf776528094a" translate="yes" xml:space="preserve">
          <source>The four element types -- scalar, array, hash, and class -- are represented by strings -- &lt;code&gt;'$'&lt;/code&gt; , &lt;code&gt;'@'&lt;/code&gt; , &lt;code&gt;'%'&lt;/code&gt; , and a class name -- optionally preceded by a &lt;code&gt;'*'&lt;/code&gt; .</source>
          <target state="translated">4つの要素タイプ（スカラー、配列、ハッシュ、およびクラス）は、文字列（ &lt;code&gt;'$'&lt;/code&gt; 、 &lt;code&gt;'@'&lt;/code&gt; 、 &lt;code&gt;'%'&lt;/code&gt; 、およびクラス名）で表され、オプションで &lt;code&gt;'*'&lt;/code&gt; 前に付けることができます。</target>
        </trans-unit>
        <trans-unit id="010d48814dc6637936a58a714f4a5b8ac2c0e5b8" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is 0.</source>
          <target state="translated">この形式で返されるリストの4番目の（インデックス[3]）要素（ &lt;code&gt;$default&lt;/code&gt; ）は0です。</target>
        </trans-unit>
        <trans-unit id="2e817fac52edc4c5e0caee985a6afb86c7862868" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is &lt;code&gt;&quot;NaN&quot;&lt;/code&gt; .</source>
          <target state="translated">この形式で返されるリストの4番目の（インデックス[3]）要素（ &lt;code&gt;$default&lt;/code&gt; ）は &lt;code&gt;&quot;NaN&quot;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d015fffd23c241225267b70dd79dfdb0ced38265" translate="yes" xml:space="preserve">
          <source>The fourth (index [3]) element (&lt;code&gt;$default&lt;/code&gt; ) in the list returned for this format is the empty string.</source>
          <target state="translated">この形式で返されるリストの4番目の（インデックス[3]）要素（ &lt;code&gt;$default&lt;/code&gt; ）は空の文字列です。</target>
        </trans-unit>
        <trans-unit id="3ee5dc54dca610abdb335a6016c33fad310b745e" translate="yes" xml:space="preserve">
          <source>The fourth argument,</source>
          <target state="translated">第四引数。</target>
        </trans-unit>
        <trans-unit id="d46f45156438266dbc454cfdd5c8500aa9cf2dd2" translate="yes" xml:space="preserve">
          <source>The fourth operation is the same as the logical not of the third operation and is specified the same way as the third with the addition of a caret character &lt;code&gt;^&lt;/code&gt; at the beginning of the test string just inside the open square bracket.</source>
          <target state="translated">4番目の演算は、3番目の演算の論理演算と同じであり、3番目と同じ方法で指定されますが、キャレット文字 &lt;code&gt;^&lt;/code&gt; がテスト文字列の先頭に開き角括弧のすぐ内側に追加されます。</target>
        </trans-unit>
        <trans-unit id="c67d6a9240f3ec0e157e3e0a648b8e35a0a7ab23" translate="yes" xml:space="preserve">
          <source>The friends locked into &lt;code&gt;M$&lt;/code&gt; world would appreciate the fact that this executable runs under DOS, Win0.3*, Win0.95 and WinNT with an appropriate extender. See &lt;a href=&quot;#Other-OSes&quot;&gt;Other OSes&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;M$&lt;/code&gt; 世界に閉じ込められた友人は、この実行可能ファイルが適切なエクステンダーを備えたDOS、Win0.3 *、Win0.95、およびWinNTの下で実行されるという事実に感謝します。&lt;a href=&quot;#Other-OSes&quot;&gt;その他のOSを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="043867751e64107d60b95a69e8badcc29251fb84" translate="yes" xml:space="preserve">
          <source>The full circle is 2</source>
          <target state="translated">フルサークルは2</target>
        </trans-unit>
        <trans-unit id="e66fe9d715897deb9cd4770d030e58e58ff7af5a" translate="yes" xml:space="preserve">
          <source>The full list of alternatives is:</source>
          <target state="translated">代替品の完全なリストは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="80a153a5f23194fa493b49953e70a37ba58abfd1" translate="yes" xml:space="preserve">
          <source>The full text of the license can be found in the LICENSE file included with this module.</source>
          <target state="translated">ライセンスの全文は、このモジュールに同梱されているLICENSEファイルに記載されています。</target>
        </trans-unit>
        <trans-unit id="c54557502ca6f64ebd0cff3c9dbc11ca01487c1f" translate="yes" xml:space="preserve">
          <source>The full version number of this package, such as 5.6.1 (or 5_6_1). This combines revision, patchlevel, and subversion to get the full version number, including any possible subversions. This is suitable for use as a directory name, and hence is filesystem dependent.</source>
          <target state="translated">5.6.1 (または 5_6_1)のような、このパッケージの完全なバージョン番号。これは、リビジョン、パッチレベル、サブバージョンを組み合わせたもので、 サブバージョンの可能性も含めた完全なバージョン番号を取得します。これはディレクトリ名として使用するのに適しており、ファイルシステムに依存します。</target>
        </trans-unit>
        <trans-unit id="5bc944c87864f3d28f9f02ec1b783a4a9aacca33" translate="yes" xml:space="preserve">
          <source>The fully qualified method name that was called is available in the &lt;code&gt;$AUTOLOAD&lt;/code&gt; package global for your class. Since this is a global, if you want to refer to do it without a package name prefix under &lt;code&gt;strict
'vars'&lt;/code&gt; , you need to declare it.</source>
          <target state="translated">呼び出された完全修飾メソッド名は、クラスのグローバル &lt;code&gt;$AUTOLOAD&lt;/code&gt; パッケージで使用できます。これはグローバルなので、 &lt;code&gt;strict 'vars'&lt;/code&gt; 下にパッケージ名のプレフィックスを付けずに参照する場合は、宣言する必要があります。</target>
        </trans-unit>
        <trans-unit id="c7c7ff8a6b152356b1c3b87a4fa36cf4002b4367" translate="yes" xml:space="preserve">
          <source>The function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1263ec90688607ca3bc3ec7bfb0fe38e6efd4c6" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8::utf8_upgrade() &lt;/a&gt; can be explicitly used to permanently (unless a subsequent &lt;code&gt;utf8::utf8_downgrade()&lt;/code&gt; is called) cause a string to be treated as Unicode.</source>
          <target state="translated">関数&lt;a href=&quot;utf8#Utility-functions&quot;&gt;utf8 :: utf8_upgrade（）&lt;/a&gt;を明示的に使用して、永続的に（後続の &lt;code&gt;utf8::utf8_downgrade()&lt;/code&gt; が呼び出されない限り）文字列をUnicodeとして扱うことができます。</target>
        </trans-unit>
        <trans-unit id="0110ffd54f081ff34d7394303d2f5fa900a42f45" translate="yes" xml:space="preserve">
          <source>The function &lt;b&gt;pod_find&lt;/b&gt; searches for POD documents in a given set of files and/or directories. It returns a hash with the file names as keys and the POD name as value. The POD name is derived from the file name and its position in the directory tree.</source>
          <target state="translated">関数&lt;b&gt;pod_find&lt;/b&gt;は、特定のファイルやディレクトリのセットでPODドキュメントを検索します。ファイル名をキー、POD名を値とするハッシュを返します。POD名は、ファイル名とディレクトリツリー内での位置から派生​​します。</target>
        </trans-unit>
        <trans-unit id="48cfcd3ef7cb24df407c69f7ab8cfb221b006395" translate="yes" xml:space="preserve">
          <source>The function &lt;b&gt;simplify_name&lt;/b&gt; is equivalent to &lt;b&gt;basename&lt;/b&gt;, but also strips Perl-like extensions (.pm, .pl, .pod) and extensions like</source>
          <target state="translated">機能&lt;b&gt;simplify_nameは&lt;/b&gt;に相当する&lt;b&gt;基本名&lt;/b&gt;が、また、Perlのような拡張機能（.PM、.plという、する.pod）ストリップなどの拡張</target>
        </trans-unit>
        <trans-unit id="977e84004739e29fbaa341106fb1e524db41e10d" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; has been deprecated, so code has been included to display a warning message whenever the calling module has (at least) the &quot;deprecated&quot; warnings category enabled. Something like this, say.</source>
          <target state="translated">関数 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; は非推奨となったため、呼び出しモジュールで（少なくとも）「非推奨」警告カテゴリが有効になっている場合は常に警告メッセージを表示するコードが含まれています。このような何かは言います。</target>
        </trans-unit>
        <trans-unit id="509f0d861d7a99d6a484f51f2a9188a5713a5b35" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;filter_read&lt;/code&gt; takes two forms:</source>
          <target state="translated">関数 &lt;code&gt;filter_read&lt;/code&gt; は2つの形式を取ります：</target>
        </trans-unit>
        <trans-unit id="ecd4d38aee306d70f6097ade577ca383b52839ef" translate="yes" xml:space="preserve">
          <source>The function I18N::LangTags::List::name(...) is not exported.</source>
          <target state="translated">関数 I18N::LangTags::List::name(...)はエクスポートされません。</target>
        </trans-unit>
        <trans-unit id="5583893e9ddd698662f18f40b85c6a69394dd032" translate="yes" xml:space="preserve">
          <source>The function accepts a list of directories to be created. Its behaviour may be tuned by an optional hashref appearing as the last parameter on the call.</source>
          <target state="translated">この関数は、作成するディレクトリのリストを受け取ります。呼び出し時の最後のパラメータとしてオプションのハッシュリフを指定することで、その動作を調整することができます。</target>
        </trans-unit>
        <trans-unit id="4c25ffe36bf18f7f44be765fa3c82188ddbc3925" translate="yes" xml:space="preserve">
          <source>The function accepts a list of directories to be removed. Its behaviour may be tuned by an optional hashref appearing as the last parameter on the call.</source>
          <target state="translated">この関数は削除するディレクトリのリストを受け取ります。呼び出し時の最後のパラメータとしてオプションのハッシュリフを指定することで、その動作を調整することができます。</target>
        </trans-unit>
        <trans-unit id="3ef41ec1c0dbf85f3bcd0cef90f173dc6b18dec6" translate="yes" xml:space="preserve">
          <source>The function call &lt;code&gt;shell&lt;/code&gt; takes two optional arguments: one the prompt, the second the default initial command line (the latter only works if a real ReadLine interface module is installed).</source>
          <target state="translated">関数呼び出し &lt;code&gt;shell&lt;/code&gt; は2つのオプションの引数を取ります。1つはプロンプト、2つ目はデフォルトの初期コマンドラインです（後者は実際のReadLineインターフェイスモジュールがインストールされている場合にのみ機能します）。</target>
        </trans-unit>
        <trans-unit id="f64674aceb9b0908fa74a739ca7fbade2ac2ee6e" translate="yes" xml:space="preserve">
          <source>The function declaration must be visible at compile time. The prototype affects only interpretation of new-style calls to the function, where new-style is defined as not using the &lt;code&gt;&amp;amp;&lt;/code&gt; character. In other words, if you call it like a built-in function, then it behaves like a built-in function. If you call it like an old-fashioned subroutine, then it behaves like an old-fashioned subroutine. It naturally falls out from this rule that prototypes have no influence on subroutine references like &lt;code&gt;\&amp;amp;foo&lt;/code&gt; or on indirect subroutine calls like &lt;code&gt;&amp;amp;{$subref}&lt;/code&gt; or &lt;code&gt;$subref-&amp;gt;()&lt;/code&gt; .</source>
          <target state="translated">関数宣言はコンパイル時に可視でなければなりません。プロトタイプは、関数への新しいスタイルの呼び出しの解釈にのみ影響します。ここで、新しいスタイルは &lt;code&gt;&amp;amp;&lt;/code&gt; 文字を使用しないものとして定義されています。つまり、組み込み関数のように呼び出すと、組み込み関数のように動作します。旧式のサブルーチンのように呼び出すと、旧式のサブルーチンのように動作します。プロトタイプが &lt;code&gt;\&amp;amp;foo&lt;/code&gt; のようなサブルーチン参照や &lt;code&gt;&amp;amp;{$subref}&lt;/code&gt; や &lt;code&gt;$subref-&amp;gt;()&lt;/code&gt; ような間接的なサブルーチン呼び出しに影響を及ぼさないことは、当然このルールから外れます。</target>
        </trans-unit>
        <trans-unit id="46a4f089237c0dd0b61fdd70575a337b465e2308" translate="yes" xml:space="preserve">
          <source>The function extracts the entry of the specified terminal type</source>
          <target state="translated">この関数は,指定された端末タイプのエントリを抽出します.</target>
        </trans-unit>
        <trans-unit id="dbacf36c4d8a578101fa6d12242c4841f7204b60" translate="yes" xml:space="preserve">
          <source>The function interface uses attribute strings to describe the colors and text attributes to assign to text. The recognized non-color attributes are clear, reset, bold, dark, faint, italic, underline, underscore, blink, reverse, and concealed. Clear and reset (reset to default attributes), dark and faint (dim and saturated), and underline and underscore are equivalent, so use whichever is the most intuitive to you.</source>
          <target state="translated">関数インターフェイスは、属性文字列を用いて、テキストに割り当てる色やテキスト属性を記述します。認識できる色以外の属性は、 clear ・ reset ・ bold ・ dark ・ faint ・ italic ・ underline ・ underscore ・ blink ・ reverse ・ concealed です。クリアとリセット(デフォルトの属性にリセット)、ダークとフェイント(薄暗いと飽和)、アンダーラインとアンダースコアは同等なので、自分にとって最も直感的な方を使用してください。</target>
        </trans-unit>
        <trans-unit id="55694c97e9ceb329d9698a51681bd4944db4ba6e" translate="yes" xml:space="preserve">
          <source>The function is called from the tokeniser, whenever a possible keyword is seen. &lt;code&gt;keyword_ptr&lt;/code&gt; points at the word in the parser's input buffer, and &lt;code&gt;keyword_len&lt;/code&gt; gives its length; it is not null-terminated. The function is expected to examine the word, and possibly other state such as &lt;a href=&quot;perlvar#%25%5eH&quot;&gt;%^H&lt;/a&gt;, to decide whether it wants to handle it as an extended keyword. If it does not, the function should return &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; , and the normal parser process will continue.</source>
          <target state="translated">この関数は、可能なキーワードが見つかるたびに、トークナイザーから呼び出されます。 &lt;code&gt;keyword_ptr&lt;/code&gt; はパーサーの入力バッファー内の単語を指し、 &lt;code&gt;keyword_len&lt;/code&gt; はその長さを示します。ヌル終了ではありません。関数は、単語、および場合によっては&lt;a href=&quot;perlvar#%25%5eH&quot;&gt;％^ H&lt;/a&gt;などの他の状態を調べて、拡張キーワードとして処理するかどうかを決定することが期待されています。そうでない場合、関数は &lt;code&gt;KEYWORD_PLUGIN_DECLINE&lt;/code&gt; を返し、通常のパーサープロセスが続行されます。</target>
        </trans-unit>
        <trans-unit id="9306c5da74b3095d5bd155bcdf129a71eee56339" translate="yes" xml:space="preserve">
          <source>The function looks in the symbol table of &lt;code&gt;$package&lt;/code&gt; for the typeglob for &lt;code&gt;$referent&lt;/code&gt; , which is a reference to a variable or subroutine (SCALAR, ARRAY, HASH, or CODE). If it finds the typeglob, it returns it. Otherwise, it returns undef. Note that &lt;code&gt;findsym&lt;/code&gt; memoizes the typeglobs it has previously successfully found, so subsequent calls with the same arguments should be much faster.</source>
          <target state="translated">この関数は、 &lt;code&gt;$package&lt;/code&gt; シンボルテーブルで、変数またはサブルーチン（SCALAR、ARRAY、HASH、またはCODE）への &lt;code&gt;$referent&lt;/code&gt; である$ referentのtypeglobを探します。タイプグロブが見つかると、それを返します。それ以外の場合は、undefを返します。 &lt;code&gt;findsym&lt;/code&gt; は以前に正常に検出された型グロブをメモするため、同じ引数を使用したその後の呼び出しははるかに高速になるはずです。</target>
        </trans-unit>
        <trans-unit id="228b62ac93f3c97adf4846ab7a229490257f21f2" translate="yes" xml:space="preserve">
          <source>The function name and the return type must be placed on separate lines and should be flush left-adjusted.</source>
          <target state="translated">関数名と戻り値の型は別々の行に配置し、左寄せにする必要があります。</target>
        </trans-unit>
        <trans-unit id="497e4c985232c356046790edf3b0a4494724ab06" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;-Name =&amp;gt; value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="translated">この関数は、オプションで、 &lt;code&gt;-Name =&amp;gt; value&lt;/code&gt; ペアとして指定されたいくつかの名前付きオプションを取ります。これにより、パラメーターリストですべてを指定しなくても、個々のオプションを調整できます。</target>
        </trans-unit>
        <trans-unit id="c334e8eba917e7f07e2743dd2e109fa8bab331b7" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;-Name=&amp;gt;value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="translated">この関数は、オプションで、 &lt;code&gt;-Name=&amp;gt;value&lt;/code&gt; ペアとして指定されたいくつかの名前付きオプションを取ります。これにより、パラメーターリストですべてを指定しなくても、個々のオプションを調整できます。</target>
        </trans-unit>
        <trans-unit id="24c3d21a118e57cb0a792d18dd4aca22a45547ff" translate="yes" xml:space="preserve">
          <source>The function optionally takes a number of named options specified as &lt;code&gt;Name =&amp;gt; value&lt;/code&gt; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</source>
          <target state="translated">この関数は、オプションで、 &lt;code&gt;Name =&amp;gt; value&lt;/code&gt; ペアとして指定されたいくつかの名前付きオプションを取ります。これにより、パラメーターリストですべてを指定しなくても、個々のオプションを調整できます。</target>
        </trans-unit>
        <trans-unit id="efd7c1c2cc7bcbc10e2084326d92993267a12ffd" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;TRUE&lt;/code&gt; if the input string is empty, or if the corresponding C function returns &lt;code&gt;TRUE&lt;/code&gt; for every byte in the string.</source>
          <target state="translated">この関数は返す &lt;code&gt;TRUE&lt;/code&gt; 入力文字列が空の場合、または対応するC関数が返す場合 &lt;code&gt;TRUE&lt;/code&gt; 文字列内のすべてのバイトのため。</target>
        </trans-unit>
        <trans-unit id="18bb210a9d041841ab7e7d3f647d6ee1d366da33" translate="yes" xml:space="preserve">
          <source>The function returns a packed string representing the requested socket option, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error, with the reason for the error placed in &lt;code&gt;$!&lt;/code&gt; . Just what is in the packed string depends on LEVEL and OPTNAME; consult getsockopt(2) for details. A common case is that the option is an integer, in which case the result is a packed integer, which you can decode using &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;i&lt;/code&gt; (or &lt;code&gt;I&lt;/code&gt; ) format.</source>
          <target state="translated">関数は、要求されたソケットオプションを表すパックされた文字列、またはエラーの場合は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返し、エラーの理由は &lt;code&gt;$!&lt;/code&gt; 。パックされた文字列の内容は、LEVELとOPTNAMEによって異なります。詳細は、getsockopt（2）を参照してください。一般的なケースは、オプションが整数である場合です。その場合、結果はパックされた整数となり、 &lt;code&gt;i&lt;/code&gt; （または &lt;code&gt;I&lt;/code&gt; ）形式で &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; を使用してデコードできます。</target>
        </trans-unit>
        <trans-unit id="f3bdd5d171fe014406932479dff47095d4169b23" translate="yes" xml:space="preserve">
          <source>The function returns a packed string representing the requested socket option, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; on error, with the reason for the error placed in &lt;code&gt;$!&lt;/code&gt; . Just what is in the packed string depends on LEVEL and OPTNAME; consult getsockopt(2) for details. A common case is that the option is an integer, in which case the result is a packed integer, which you can decode using &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;i&lt;/code&gt; (or &lt;code&gt;I&lt;/code&gt; ) format.</source>
          <target state="translated">関数は、要求されたソケットオプションを表すパックされた文字列、またはエラーの場合は &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返し、エラーの理由は &lt;code&gt;$!&lt;/code&gt; 。パックされた文字列の内容は、LEVELとOPTNAMEによって異なります。詳細は、getsockopt（2）を参照してください。一般的なケースは、オプションが整数である場合です。その場合、結果はパックされた整数となり、 &lt;code&gt;i&lt;/code&gt; （または &lt;code&gt;I&lt;/code&gt; ）形式で &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; を使用してデコードできます。</target>
        </trans-unit>
        <trans-unit id="2c416a15314ff142b876195908cf3e0998cacb0b" translate="yes" xml:space="preserve">
          <source>The function returns a true value if the file was written successfully. Otherwise it returns a false value.</source>
          <target state="translated">この関数は、ファイルが正常に書き込まれた場合に真の値を返します。それ以外の場合は偽の値を返します。</target>
        </trans-unit>
        <trans-unit id="96868ec2f844938f055b367738ce668b3149cb6e" translate="yes" xml:space="preserve">
          <source>The function returns the list of directories actually created during the call; in scalar context the number of directories created.</source>
          <target state="translated">この関数は、呼び出し中に実際に作成されたディレクトリのリストを返します。</target>
        </trans-unit>
        <trans-unit id="6b560ee48a1c4113ae4a064c91e40e3ebfc92205" translate="yes" xml:space="preserve">
          <source>The function should be defined like this:</source>
          <target state="translated">このように関数を定義する必要があります。</target>
        </trans-unit>
        <trans-unit id="af1dfdcedd7b6d95c274f658ea41922443e248ed" translate="yes" xml:space="preserve">
          <source>The function should return a reference to an array containing the parent classes in order. The names of the classes should be the result of calling &lt;code&gt;HvENAME()&lt;/code&gt; on the stash. In those cases where &lt;code&gt;HvENAME()&lt;/code&gt; returns null, &lt;code&gt;HvNAME()&lt;/code&gt; should be used instead.</source>
          <target state="translated">関数は、親クラスを含む配列への参照を順番に返す必要があります。クラスの名前は、 &lt;code&gt;HvENAME()&lt;/code&gt; を呼び出した結果である必要があります。 &lt;code&gt;HvENAME()&lt;/code&gt; がnullを返す場合は、 &lt;code&gt;HvNAME()&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="df40ff756f018edab3521eb313090bdefa039e32" translate="yes" xml:space="preserve">
          <source>The function takes as first argument a key to test against, and as second argument any form of criteria that are also allowed by the &lt;code&gt;allow&lt;/code&gt; key in the template.</source>
          <target state="translated">この関数は、最初の引数としてテストするキーを受け取り、2番目の引数として、テンプレートの &lt;code&gt;allow&lt;/code&gt; キーでも許可されている任意の形式の基準を受け取ります。</target>
        </trans-unit>
        <trans-unit id="f1378c8817cc1e710b51660b130f3baf8dd96ee6" translate="yes" xml:space="preserve">
          <source>The function takes one optional parameter, a reference to a hash. The contents of the hash allow the deflation interface to be tailored.</source>
          <target state="translated">この関数は、ハッシュへの参照という1つのオプションのパラメータを取ります。ハッシュの内容によって、デフレインターフェースをカスタマイズすることができます。</target>
        </trans-unit>
        <trans-unit id="deea19e69043d11a7254610da5a869b1f9452180" translate="yes" xml:space="preserve">
          <source>The function that handles the &lt;code&gt;allow&lt;/code&gt; key in the template is also available for independent use.</source>
          <target state="translated">テンプレート内の &lt;code&gt;allow&lt;/code&gt; キーを処理する関数は、独立して使用することもできます。</target>
        </trans-unit>
        <trans-unit id="efcf392cc09771ca25c0652559e59fca2e7a7c50" translate="yes" xml:space="preserve">
          <source>The function visit() scans the SV arenas list, and calls a specified function for each SV it finds which is still live - ie which has an SvTYPE other than all 1's, and a non-zero SvREFCNT. visit() is used by the following functions (specified as [function that calls visit()] / [function called by visit() for each SV]):</source>
          <target state="translated">関数 visit()は SV アリーナのリストをスキャンし、まだライブ中の SV、つまり SvTYPE がすべて 1 以外で、SvREFCNT が 0 以外の SV に対して指定された関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="19570f411b75d35372886127cc2a69449d9a4b6b" translate="yes" xml:space="preserve">
          <source>The function will croak with &quot;Wide character in subroutine entry&quot; if $bytes contains characters with code above 255. The base64 encoding is only defined for single-byte characters. Use the Encode module to select the byte encoding you want.</source>
          <target state="translated">この関数は、$bytesに255以上のコードを持つ文字が含まれている場合、&quot;サブルーチンエントリにワイド文字が含まれています。base64エンコーディングは、シングルバイト文字に対してのみ定義されています。Encodeモジュールを使用して、必要なバイトエンコーディングを選択してください。</target>
        </trans-unit>
        <trans-unit id="b2a6bb6e55b46f9d735e2cbaab0b636efd193e6e" translate="yes" xml:space="preserve">
          <source>The function,</source>
          <target state="translated">機能です。</target>
        </trans-unit>
        <trans-unit id="56c2336779d3eb8fad6f134e1b3afd4055cf95fc" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_add&lt;/code&gt; , actually installs the filter. It takes one parameter which should be a reference. The kind of reference used will dictate which of the two filter types will be used.</source>
          <target state="translated">関数 &lt;code&gt;filter_add&lt;/code&gt; は、実際にフィルターをインストールします。参照となるパラメータを1つ取ります。使用されるリファレンスの種類によって、2つのフィルタータイプのどちらが使用されるかが決まります。</target>
        </trans-unit>
        <trans-unit id="bd8317ff780b8620fb08e8151dfdbf3a52d2d611" translate="yes" xml:space="preserve">
          <source>The function, &lt;code&gt;filter_del&lt;/code&gt; , is used to disable the current filter. It does not affect the running of the filter. All it does is tell Perl not to call filter any more.</source>
          <target state="translated">関数 &lt;code&gt;filter_del&lt;/code&gt; は、現在のフィルターを無効にするために使用されます。フィルターの実行には影響しません。Perlにfilterを呼び出さないように指示するだけです。</target>
        </trans-unit>
        <trans-unit id="e85467ff647b7ea9bd91bc8fa0103d9ae4aadb9f" translate="yes" xml:space="preserve">
          <source>The functional interface is simply importable functions with the same name as the algorithm. The functions take the message as argument and return the digest. Example:</source>
          <target state="translated">機能インタフェースは、アルゴリズムと同じ名前を持つ単純にインポート可能な関数です。関数はメッセージを引数に取り、ダイジェストを返します。例としては、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="bf5b597fcbc2815c78fabe6a0ba67f38e49a2b3d" translate="yes" xml:space="preserve">
          <source>The functional interface needs Perl5.005 or better.</source>
          <target state="translated">機能的なインターフェースはPerl5.005以上が必要です。</target>
        </trans-unit>
        <trans-unit id="4bdd9d3e5903e6dd1f8e73f664d773008086b093" translate="yes" xml:space="preserve">
          <source>The functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68ff03911b440c28f50688f4c9ab7665ef4a1c34" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;cond_wait()&lt;/code&gt; and &lt;code&gt;cond_signal()&lt;/code&gt; can be used in conjunction with locks to notify co-operating threads that a resource has become available. They are very similar in use to the functions found in &lt;code&gt;pthreads&lt;/code&gt; . However for most purposes, queues are simpler to use and more intuitive. See &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; for more details.</source>
          <target state="translated">関数 &lt;code&gt;cond_wait()&lt;/code&gt; および &lt;code&gt;cond_signal()&lt;/code&gt; をロックと組み合わせて使用​​して、リソースが使用可能になったことを連携スレッドに通知できます。これらは、 &lt;code&gt;pthreads&lt;/code&gt; にある関数と非常によく似ています。ただし、ほとんどの目的で、キューは使いやすく、より直感的です。詳細については、&lt;a href=&quot;threads/shared&quot;&gt;threads :: shared&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="29b4904f96b85af2bf6cf4659323a42dfc8558db" translate="yes" xml:space="preserve">
          <source>The functions and attributes are accessed via the &quot;tab&quot; (for table) member of &lt;code&gt;PerlIOl&lt;/code&gt; . The functions (methods of the layer &quot;class&quot;) are fixed, and are defined by the &lt;code&gt;PerlIO_funcs&lt;/code&gt; type. They are broadly the same as the public &lt;code&gt;PerlIO_xxxxx&lt;/code&gt; functions:</source>
          <target state="translated">関数と属性には、 &lt;code&gt;PerlIOl&lt;/code&gt; の「タブ」（テーブル用）メンバーを介してアクセスします。関数（「クラス」レイヤーのメソッド）は固定されており、 &lt;code&gt;PerlIO_funcs&lt;/code&gt; タイプで定義されています。これらは公開 &lt;code&gt;PerlIO_xxxxx&lt;/code&gt; 関数とおおむね同じです。</target>
        </trans-unit>
        <trans-unit id="641685ab6429ec4eade93850f03823bb632c2710" translate="yes" xml:space="preserve">
          <source>The functions and attributes of the &quot;layer class&quot;.</source>
          <target state="translated">レイヤークラス」の機能と属性。</target>
        </trans-unit>
        <trans-unit id="04a02ab73237464478de303a6921e51a12145bbd" translate="yes" xml:space="preserve">
          <source>The functions are modeled on those in</source>
          <target state="translated">の機能をモデルにしています。</target>
        </trans-unit>
        <trans-unit id="de8f908f8a6f8cbbe7a5d22657a37b7e7e24b80c" translate="yes" xml:space="preserve">
          <source>The functions in this section can serve as terms in an expression. They fall into two major categories: list operators and named unary operators. These differ in their precedence relationship with a following comma. (See the precedence table in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.) List operators take more than one argument, while unary operators can never take more than one argument. Thus, a comma terminates the argument of a unary operator, but merely separates the arguments of a list operator. A unary operator generally provides scalar context to its argument, while a list operator may provide either scalar or list contexts for its arguments. If it does both, scalar arguments come first and list argument follow, and there can only ever be one such list argument. For instance, splice() has three scalar arguments followed by a list, whereas gethostbyname() has four scalar arguments.</source>
          <target state="translated">このセクションの関数は、式の用語として使用できます。それらは2つの主要なカテゴリに分類されます。リスト演算子と名前付き単項演算子です。これらは、次のコンマとの優先関係が異なります。 （&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;の優先順位表を参照してください。）リスト演算子は複数の引数をとりますが、単項演算子は複数の引数をとることはできません。したがって、コンマは単項演算子の引数を終了しますが、リスト演算子の引数を分離するだけです。単項演算子は通常、その引数にスカラーコンテキストを提供しますが、リスト演算子はその引数にスカラーまたはリストコンテキストを提供します。両方を行う場合、スカラー引数が最初に来てリスト引数が続き、そのようなリスト引数は1つしかありません。たとえば、splice（）には3つのスカラー引数とそれに続くリストがありますが、gethostbyname（）には4つのスカラー引数があります。</target>
        </trans-unit>
        <trans-unit id="db44e2533a11b8e3bb17098404db4eb4f6f38bb9" translate="yes" xml:space="preserve">
          <source>The functions not currently implemented include:</source>
          <target state="translated">現在実装されていない機能としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="c91d15f478afdf6edcd21180f278e6de93659c87" translate="yes" xml:space="preserve">
          <source>The functions returns the number of files successfully deleted.</source>
          <target state="translated">この関数は、削除に成功したファイルの数を返します。</target>
        </trans-unit>
        <trans-unit id="c8f00447c143aee7d5d5fe37917ea4e13f05bb95" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wdeclaration-after-statements&lt;/code&gt; scans for such problems (by default on starting from Perl 5.9.4).</source>
          <target state="translated">gccオプション &lt;code&gt;-Wdeclaration-after-statements&lt;/code&gt; は、このような問題をスキャンします（デフォルトでは、Perl 5.9.4以降）。</target>
        </trans-unit>
        <trans-unit id="5ee3a23159a200898de862e7d5879870227625eb" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wendif-labels&lt;/code&gt; warns about the bad variant (by default on starting from Perl 5.9.4).</source>
          <target state="translated">gccオプション &lt;code&gt;-Wendif-labels&lt;/code&gt; は、不正なバリアントについて警告します（デフォルトでは、Perl 5.9.4以降）。</target>
        </trans-unit>
        <trans-unit id="4d2d0d644a6adc7963542dd47a318273c10c274d" translate="yes" xml:space="preserve">
          <source>The gcc option &lt;code&gt;-Wformat&lt;/code&gt; scans for such problems.</source>
          <target state="translated">gccオプション &lt;code&gt;-Wformat&lt;/code&gt; は、このような問題をスキャンします。</target>
        </trans-unit>
        <trans-unit id="db3325d45be5f27fbb2d4ff677421100e7fd8bb0" translate="yes" xml:space="preserve">
          <source>The generated C++ code will call &lt;code&gt;new&lt;/code&gt; .</source>
          <target state="translated">生成されたC ++コードは &lt;code&gt;new&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="d40f7df8e8a0ceca1fdf5c8cc98299f799cdbb11" translate="yes" xml:space="preserve">
          <source>The generated Makefile enables the user of the extension to invoke</source>
          <target state="translated">生成されたMakefileによって、拡張機能のユーザは</target>
        </trans-unit>
        <trans-unit id="ddf93e71778e5593e96208d788b15d2297c9188f" translate="yes" xml:space="preserve">
          <source>The generated singletons are kept around from instantiation until the end of the shell session. &amp;lt;plugin_list&amp;gt; can be reconfigured at any time at run time. While the cpan shell is running, it checks all activated plugins at each of the 8 reference points listed above and runs the respective method if it is implemented for that object. The method is called with the active CPAN::Distribution object passed in as an argument.</source>
          <target state="translated">生成されたシングルトンは、インスタンス化からシェルセッションの終了まで保持されます。&amp;lt;plugin_list&amp;gt;は、実行時にいつでも再構成できます。cpanシェルの実行中に、上記の8つの参照ポイントのそれぞれでアクティブ化されたすべてのプラグインをチェックし、そのオブジェクトに実装されている場合はそれぞれのメソッドを実行します。このメソッドは、アクティブなCPAN :: Distributionオブジェクトを引数として渡して呼び出されます。</target>
        </trans-unit>
        <trans-unit id="04c9e6d408a35a88cbae891becfacfd45984120c" translate="yes" xml:space="preserve">
          <source>The generated trailer for a CODE: section ensures that the number of return values Perl will see is either 0 or 1 (depending on the &lt;code&gt;void&lt;/code&gt; ness of the return value of the C function, and heuristics mentioned in &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;The RETVAL Variable&lt;/a&gt;). The trailer generated for a PPCODE: section is based on the number of return values and on the number of times &lt;code&gt;SP&lt;/code&gt; was updated by &lt;code&gt;[X]PUSH*()&lt;/code&gt; macros.</source>
          <target state="translated">CODE：セクションの生成されたトレーラーは、Perlが参照する戻り値の数が0または1であることを保証します（C関数の戻り値の &lt;code&gt;void&lt;/code&gt; 性、および&lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;RETVAL変数で説明&lt;/a&gt;されているヒューリスティックによる）。PPCODE：セクションに対して生成されるトレーラーは、戻り値の数と、 &lt;code&gt;[X]PUSH*()&lt;/code&gt; マクロによって &lt;code&gt;SP&lt;/code&gt; が更新された回数に基づいています。</target>
        </trans-unit>
        <trans-unit id="147459e5132af1acc303407a971ff312e870e58e" translate="yes" xml:space="preserve">
          <source>The generation number of the name at offset &lt;code&gt;po&lt;/code&gt; in the current compiling pad (lvalue). Note that &lt;code&gt;SvUVX&lt;/code&gt; is hijacked for this purpose.</source>
          <target state="translated">現在のコンパイルパッド（左辺値）のオフセット &lt;code&gt;po&lt;/code&gt; にある名前の世代番号。 &lt;code&gt;SvUVX&lt;/code&gt; がこの目的でハイジャックされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="65beebb121c6a44259be26715db186e4a704f7cf" translate="yes" xml:space="preserve">
          <source>The generic flag bits are a hybrid of &lt;code&gt;O_XXXXX&lt;/code&gt; style flags deduced from the mode string passed to &lt;code&gt;PerlIO_open()&lt;/code&gt; , and state bits for typical buffer layers.</source>
          <target state="translated">汎用フラグビットは、 &lt;code&gt;PerlIO_open()&lt;/code&gt; に渡されたモード文字列から推定された &lt;code&gt;O_XXXXX&lt;/code&gt; スタイルのフラグと、一般的なバッファーレイヤーの状態ビットのハイブリッドです。</target>
        </trans-unit>
        <trans-unit id="9373f74aec3f2b814c36a72b32de7c1df8cce7e8" translate="yes" xml:space="preserve">
          <source>The generic names by which a &lt;b&gt;subroutine&lt;/b&gt; knows its &lt;b&gt;arguments&lt;/b&gt;. In many languages, formal arguments are always given individual names; in Perl, the formal arguments are just the elements of an array. The formal arguments to a Perl program are &lt;code&gt;$ARGV[0]&lt;/code&gt; , &lt;code&gt;$ARGV[1]&lt;/code&gt; , and so on. Similarly, the formal arguments to a Perl subroutine are &lt;code&gt;$_[0]&lt;/code&gt; , &lt;code&gt;$_[1]&lt;/code&gt; , and so on. You may give the arguments individual names by assigning the values to a &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; list. See also &lt;b&gt;actual arguments&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;サブルーチン&lt;/b&gt;がその&lt;b&gt;引数を&lt;/b&gt;知るための総称名。多くの言語では、仮引数には常に個別の名前が付けられます。 Perlでは、仮引数は配列の要素にすぎません。 Perlプログラムへの仮引数は &lt;code&gt;$ARGV[0]&lt;/code&gt; 、 &lt;code&gt;$ARGV[1]&lt;/code&gt; などです。同様に、Perlサブルーチンへの仮引数は &lt;code&gt;$_[0]&lt;/code&gt; 、 &lt;code&gt;$_[1]&lt;/code&gt; などです。 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; リストに値を割り当てることで、引数に個別の名前を付けることができます。&lt;b&gt;実際の引数&lt;/b&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="e34968429c314c796b06ef13d6256c2eed375227" translate="yes" xml:space="preserve">
          <source>The get_dup() Method</source>
          <target state="translated">get_dup()メソッド</target>
        </trans-unit>
        <trans-unit id="777933c68edb9f2b520827371d959a89885f825a" translate="yes" xml:space="preserve">
          <source>The getaddrinfo() function converts a hostname and a service name into a list of structures, each containing a potential way to connect() to the named service on the named host.</source>
          <target state="translated">getaddrinfo()関数は、ホスト名とサービス名を構造体のリストに変換します。</target>
        </trans-unit>
        <trans-unit id="b2567e2f657f48e5ffd91f457d438d649766ac8c" translate="yes" xml:space="preserve">
          <source>The getdcwd() function is also provided on Win32 to get the current working directory on the specified drive, since Windows maintains a separate current working directory for each drive. If no drive is specified then the current drive is assumed.</source>
          <target state="translated">Windows は各ドライブごとに別個のカレント・ワーキング・ディレクトリを保持しているため、指定したドライブのカレント・ワーキング・ディレクトリを取得するための getdcwd()関数も Win32 で提供されています。ドライブが指定されていない場合は、現在のドライブを想定しています。</target>
        </trans-unit>
        <trans-unit id="60ed783ab1755c8923c2106affd806182a9b2682" translate="yes" xml:space="preserve">
          <source>The gethost() function is a simple front-end that forwards a numeric argument to gethostbyaddr() by way of Socket::inet_aton, and the rest to gethostbyname().</source>
          <target state="translated">gethost()関数は、Socket::inet_aton を介して数値引数を gethostbyaddr()に転送し、残りを gethostbyname()に転送するシンプルなフロントエンドです。</target>
        </trans-unit>
        <trans-unit id="91be5f2becab7f44b4c2d8e8646f84ed2e15605f" translate="yes" xml:space="preserve">
          <source>The gethost() functions do this in the Perl core:</source>
          <target state="translated">gethost()関数は、Perl コアでこれを行います。</target>
        </trans-unit>
        <trans-unit id="3d809f6317a210fb06b8763a59c516ccb0250c8f" translate="yes" xml:space="preserve">
          <source>The getnameinfo() function converts a socket address, such as returned by getsockname() or getpeername(), into a pair of human-readable strings representing the address and service name.</source>
          <target state="translated">getnameinfo()関数は getsockname()や getpeername()で返されたソケットアドレスを、アドレスとサービス名を表す人間が読める文字列のペアに変換する。</target>
        </trans-unit>
        <trans-unit id="c7341d184608dfa3d666b4de167cfb9267a092b7" translate="yes" xml:space="preserve">
          <source>The getnet() function is a simple front-end that forwards a numeric argument to getnetbyaddr(), and the rest to getnetbyname().</source>
          <target state="translated">getnet()関数は、数値の引数を getnetbyaddr()に、残りの引数を getnetbyname()に転送するシンプルなフロントエンドです。</target>
        </trans-unit>
        <trans-unit id="a2bc6ce1fe12be1b0104870e6335dfcba678d52a" translate="yes" xml:space="preserve">
          <source>The getnet() functions do this in the Perl core:</source>
          <target state="translated">getnet()関数は、Perl のコアでこれを行います。</target>
        </trans-unit>
        <trans-unit id="723d74402111c283b1693c27eac4e9e45b8e6ed9" translate="yes" xml:space="preserve">
          <source>The getproto() function is a simple front-end that forwards a numeric argument to getprotobyport(), and the rest to getprotobyname().</source>
          <target state="translated">getproto()関数は、数値引数を getprotobyport()に、残りの引数を getprotobyname()に転送するシンプルなフロントエンドです。</target>
        </trans-unit>
        <trans-unit id="7135ce934ee6874d87ad890231c34f496a98c1a0" translate="yes" xml:space="preserve">
          <source>The getpw() function is a simple front-end that forwards a numeric argument to getpwuid() and the rest to getpwnam().</source>
          <target state="translated">getpw()関数は、数値引数を getpwuid()に、残りを getpwnam()に転送するシンプルなフロントエンドです。</target>
        </trans-unit>
        <trans-unit id="0d0b8e4657c6706a0314a90d140b3591ebd5a9bb" translate="yes" xml:space="preserve">
          <source>The getserv() function is a simple front-end that forwards a numeric argument to getservbyport(), and the rest to getservbyname().</source>
          <target state="translated">getserv()関数は、数値引数を getservbyport()に、残りの引数を getservbyname()に転送するシンプルなフロントエンドです。</target>
        </trans-unit>
        <trans-unit id="7b3093ca7aacbd788d18481992e739fec224cedd" translate="yes" xml:space="preserve">
          <source>The given arguments are made consistent as though by calling &lt;code&gt;mktime()&lt;/code&gt; before calling your system's &lt;code&gt;strftime()&lt;/code&gt; function, except that the &lt;code&gt;isdst&lt;/code&gt; value is not affected.</source>
          <target state="translated">与えられた引数は、 &lt;code&gt;isdst&lt;/code&gt; 値が影響を受けないことを除いて、システムの &lt;code&gt;strftime()&lt;/code&gt; 関数を呼び出す前に &lt;code&gt;mktime()&lt;/code&gt; を呼び出すように一貫性があります。</target>
        </trans-unit>
        <trans-unit id="a46f0a3dc0d7705f81eb9d2736f8d38ab0c36cf3" translate="yes" xml:space="preserve">
          <source>The given link to</source>
          <target state="translated">へのリンクが与えられています。</target>
        </trans-unit>
        <trans-unit id="1b7e0113518a74a9ca8cd3adb44721180fc0bb94" translate="yes" xml:space="preserve">
          <source>The glob angle-bracket operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is a pathname generator that implements the rules for file name pattern matching used by Unix-like shells such as the Bourne shell or C shell.</source>
          <target state="translated">glob角括弧演算子 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; は、BourneシェルやCシェルなどのUnixのようなシェルで使用されるファイル名パターンマッチングのルールを実装するパス名ジェネレータです。</target>
        </trans-unit>
        <trans-unit id="5e215c589947f616aa94dd5242e9494420cfca28" translate="yes" xml:space="preserve">
          <source>The glob containing the output field separator - &lt;code&gt;*,&lt;/code&gt; in Perl space.</source>
          <target state="translated">Perlスペースでの出力フィールド区切り文字- &lt;code&gt;*,&lt;/code&gt; を含むグロブ。</target>
        </trans-unit>
        <trans-unit id="72ac12b62c28c3baeece5702a243d181ecdda5a0" translate="yes" xml:space="preserve">
          <source>The glob was stopped because an error was encountered.</source>
          <target state="translated">エラーが発生したため、グロブが停止しました。</target>
        </trans-unit>
        <trans-unit id="f628027fc4ac19b3e64d6b57171d06712a0f4de2" translate="yes" xml:space="preserve">
          <source>The global &lt;code&gt;debug&lt;/code&gt; and &lt;code&gt;debugcolor&lt;/code&gt; pragmas allow one to get detailed debugging info about regexp compilation and execution. &lt;code&gt;debugcolor&lt;/code&gt; is the same as debug, except the debugging information is displayed in color on terminals that can display termcap color sequences. Here is example output:</source>
          <target state="translated">グローバルな &lt;code&gt;debug&lt;/code&gt; および &lt;code&gt;debugcolor&lt;/code&gt; プラグマにより、正規表現のコンパイルと実行に関する詳細なデバッグ情報を取得できます。 &lt;code&gt;debugcolor&lt;/code&gt; は、determineと同じですが、termcapカラーシーケンスを表示できる端末にデバッグ情報がカラーで表示されます。次に出力例を示します。</target>
        </trans-unit>
        <trans-unit id="2364252b351b212be51c3b8e4ec104f73d0c11a2" translate="yes" xml:space="preserve">
          <source>The global variable $Devel::Peek::pv_limit can be set to limit the number of character printed in various string values. Setting it to 0 means no limit.</source>
          <target state="translated">グローバル変数 $Devel::Peek::pv_limit を設定することで、様々な文字列の値に印刷される文字数を制限することができます。0に設定すると制限がないことを意味します。</target>
        </trans-unit>
        <trans-unit id="8c46d35ee4a0a86a8c41ca71ad737aa7e8fc9118" translate="yes" xml:space="preserve">
          <source>The global variables, like &lt;code&gt;@ARGV&lt;/code&gt; or the punctuation variables, must be &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized with &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt;. This block reads in</source>
          <target state="translated">以下のようなグローバル変数、 &lt;code&gt;@ARGV&lt;/code&gt; や句読点変数は、である必要があります &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; で化さ &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; 。このブロックは読み込みます</target>
        </trans-unit>
        <trans-unit id="968cbdca6785865baa2b963e00c7cf59fd1ce4f6" translate="yes" xml:space="preserve">
          <source>The glue code pulls the arguments from the Perl stack, converts these Perl values to the formats expected by a C function, call this C function, transfers the return values of the C function back to Perl. Return values here may be a conventional C return value or any C function arguments that may serve as output parameters. These return values may be passed back to Perl either by putting them on the Perl stack, or by modifying the arguments supplied from the Perl side.</source>
          <target state="translated">グルーコードは、Perlスタックから引数を取り出し、Perlの値をC関数が期待する形式に変換し、このC関数を呼び出し、C関数の戻り値をPerlに転送します。ここでの戻り値は、従来のC関数の戻り値、または出力パラメータとして機能するC関数の引数です。これらの戻り値は、Perl スタックに置くか、Perl 側から供給された引数を変更することで Perl に渡されます。</target>
        </trans-unit>
        <trans-unit id="cfb79bdb1e9bdcf50c5258db72c30cb6aeb1e3e1" translate="yes" xml:space="preserve">
          <source>The gmctime() function provides a way of getting at the scalar sense of the original CORE::gmtime() function.</source>
          <target state="translated">gmctime()関数は、オリジナルの CORE::gmtime()関数のスカラーセンスを取得する方法を提供します。</target>
        </trans-unit>
        <trans-unit id="15e78ea46607c2d827f12212191bcd40dffea850" translate="yes" xml:space="preserve">
          <source>The goal here is to have a testing utility that's simple to learn, quick to use and difficult to trip yourself up with while still providing more flexibility than the existing Test.pm. As such, the names of the most common routines are kept tiny, special cases and magic side-effects are kept to a minimum. WYSIWYG.</source>
          <target state="translated">ここでの目標は、既存の Test.pm よりも柔軟性がありながらも、学ぶのが簡単で、すぐに使えて、自分自身を悩ませるのが難しいテストユーティリティを持つことです。そのため、最も一般的なルーチンの名前は小さく、特殊なケースや魔法のような副作用は最小限に抑えられています。WYSIWYG</target>
        </trans-unit>
        <trans-unit id="a352895328c4895bdf1e088252c7cfc98a73fd07" translate="yes" xml:space="preserve">
          <source>The goal of the CPAN Testers project (&lt;a href=&quot;http://testers.cpan.org/&quot;&gt;http://testers.cpan.org/&lt;/a&gt;) is to test as many CPAN packages as possible on as many platforms as possible. This provides valuable feedback to module authors and potential users to identify bugs or platform compatibility issues and improves the overall quality and value of CPAN.</source>
          <target state="translated">CPAN Testersプロジェクト（&lt;a href=&quot;http://testers.cpan.org/&quot;&gt;http://testers.cpan.org/&lt;/a&gt;）の目標は、できるだけ多くのプラットフォームで、できるだけ多くのCPANパッケージをテストすることです。これは、バグやプラットフォームの互換性の問題を特定するためにモジュールの作成者や潜在的なユーザーに貴重なフィードバックを提供し、CPANの全体的な品質と価値を向上させます。</target>
        </trans-unit>
        <trans-unit id="7c4f9c804c591c85f4c73346c685fe6b75566956" translate="yes" xml:space="preserve">
          <source>The good news is that at least some DBM module should be available, and &lt;code&gt;AnyDBM_File&lt;/code&gt; will use whichever module it can find. Of course, then the code needs to be fairly strict, dropping to the greatest common factor (e.g., not exceeding 1K for each record), so that it will work with any DBM module. See &lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; for more details.</source>
          <target state="translated">良い知らせは、少なくともいくつかのDBMモジュールが利用可能である必要があり、 &lt;code&gt;AnyDBM_File&lt;/code&gt; は、それが見つけることができるモジュールを使用します。もちろん、コードはかなり厳格である必要があり、最大の共通要素（たとえば、各レコードで1Kを超えない）に落とす必要があるため、どのDBMモジュールでも機能します。詳細については、&lt;a href=&quot;anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="0b5a1d8ce58ba1e38f16f3a0f1eb5ac058c6d368" translate="yes" xml:space="preserve">
          <source>The good old C code quality inspector, &lt;code&gt;lint&lt;/code&gt; , is available in several platforms, but please be aware that there are several different implementations of it by different vendors, which means that the flags are not identical across different platforms.</source>
          <target state="translated">古き良きCコード品質インスペクターである &lt;code&gt;lint&lt;/code&gt; はいくつかのプラットフォームで利用できますが、ベンダーによって実装が異なるため、プラットフォーム間でフラグが同一ではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="64a4aa574c2f36a349fb65698d1079a80c8716e6" translate="yes" xml:space="preserve">
          <source>The grammar gives you the following rule: you can make the thing on the left of the colon if you see all the things on the right in sequence. This is called a &quot;reduction&quot;, and the aim of parsing is to completely reduce the input. There are several different ways you can perform a reduction, separated by vertical bars: so, &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;=&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; makes a &lt;code&gt;term&lt;/code&gt; , and &lt;code&gt;term&lt;/code&gt; followed by &lt;code&gt;+&lt;/code&gt; followed by &lt;code&gt;term&lt;/code&gt; can also make a &lt;code&gt;term&lt;/code&gt; .</source>
          <target state="translated">文法には次のルールがあります。右側のすべてのものを順番に見れば、コロンの左側のものを作成できます。これは「削減」と呼ばれ、解析の目的は入力を完全に削減することです。縦棒で区切ってあなたが削減を行うことができますいくつかの異なる方法が、ありますので、 &lt;code&gt;term&lt;/code&gt; 続く &lt;code&gt;=&lt;/code&gt; に続く &lt;code&gt;term&lt;/code&gt; ます &lt;code&gt;term&lt;/code&gt; 、そして &lt;code&gt;term&lt;/code&gt; に続く &lt;code&gt;+&lt;/code&gt; は続い &lt;code&gt;term&lt;/code&gt; も作ることができる &lt;code&gt;term&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f689a3c521cea873db9ec7a159a154a44941fb63" translate="yes" xml:space="preserve">
          <source>The grammar, lines one and three of the snippet above, tells you how to build up more complex forms. These complex forms, &quot;non-terminal symbols&quot; are generally placed in lower case. &lt;code&gt;term&lt;/code&gt; here is a non-terminal symbol, representing a single expression.</source>
          <target state="translated">上記のスニペットの1行目と3行目の文法は、より複雑なフォームを作成する方法を示しています。これらの複雑な形式、「非終端記号」は、通常、小文字で配置されます。ここでの &lt;code&gt;term&lt;/code&gt; は、単一の式を表す非終端記号です。</target>
        </trans-unit>
        <trans-unit id="d748b942ca422b33db3c9c207b20fcf5e35fbf06" translate="yes" xml:space="preserve">
          <source>The great_circle_midpoint() is just a special case of</source>
          <target state="translated">great_circle_midpoint()は、あくまでも</target>
        </trans-unit>
        <trans-unit id="65a277526deeb0c81c0a5dcd559529318f7f89a5" translate="yes" xml:space="preserve">
          <source>The group as a whole is interpreted as follows:</source>
          <target state="translated">グループ全体としては、次のように解釈しています。</target>
        </trans-unit>
        <trans-unit id="fc9b7c0745af45eb8fd74cee86dd53c561106e37" translate="yes" xml:space="preserve">
          <source>The group id owning the file</source>
          <target state="translated">ファイルを所有するグループID</target>
        </trans-unit>
        <trans-unit id="163b6e7222a22b065c1007b2d5c671945f219faa" translate="yes" xml:space="preserve">
          <source>The group name that owns the file</source>
          <target state="translated">ファイルを所有するグループ名</target>
        </trans-unit>
        <trans-unit id="5464b947891c7dfe478004d22eea99e392c2554b" translate="yes" xml:space="preserve">
          <source>The grouping assigns a value to \g1, so that the same 3-letter sequence is used for both parts.</source>
          <target state="translated">このグループ化では、「\g1」に値を割り当て、両方のパートに同じ3文字の文字列が使われるようにしています。</target>
        </trans-unit>
        <trans-unit id="a808380dda4fa48a019446ad652d6dc63c38be3d" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also allow the extraction of the parts of a string that matched. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. They can be used just as ordinary variables:</source>
          <target state="translated">グループ化メタ文字 &lt;code&gt;()&lt;/code&gt; を使用すると、一致した文字列の部分を抽出することもできます。グループ化ごとに、内部で一致した部分が特殊変数 &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; などに入ります。これらは通常の変数と同じように使用できます。</target>
        </trans-unit>
        <trans-unit id="7778e0ad49a7501b63144277c49609f424265cc5" translate="yes" xml:space="preserve">
          <source>The grouping metacharacters &lt;code&gt;()&lt;/code&gt; also serve another completely different function: they allow the extraction of the parts of a string that matched. This is very useful to find out what matched and for text processing in general. For each grouping, the part that matched inside goes into the special variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. They can be used just as ordinary variables:</source>
          <target state="translated">グループ化メタ文字 &lt;code&gt;()&lt;/code&gt; は、別の完全に異なる機能も提供します。これにより、一致した文字列の部分を抽出できます。これは何が一致しているかを見つけるのに、そして一般にテキスト処理にとても便利です。グループ化ごとに、内部で一致した部分が特殊変数 &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; などに入ります。これらは通常の変数と同じように使用できます。</target>
        </trans-unit>
        <trans-unit id="1eece9645dd47cfb0899002c6d7925c002a7646e" translate="yes" xml:space="preserve">
          <source>The guts of &lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt; utility.</source>
          <target state="translated">&lt;a href=&quot;../perldoc&quot;&gt;perldoc&lt;/a&gt;ユーティリティの本質。</target>
        </trans-unit>
        <trans-unit id="31680a03b79cf90dad61ef90684e16f85b576d96" translate="yes" xml:space="preserve">
          <source>The handler names are based on the underlying type of the variable being declared or of the reference passed. Because these attributes are associated with subroutine or variable declarations, this deliberately ignores any possibility of being blessed into some package. Thus, a subroutine declaration uses &quot;CODE&quot; as its</source>
          <target state="translated">ハンドラ名は、宣言される変数や渡される参照の基本的な型に基づいています。これらの属性はサブルーチンや変数宣言に関連付けられているため、何らかのパッケージに祝福される可能性を意図的に無視しています。したがって、サブルーチン宣言では、&quot;CODE &quot;をその</target>
        </trans-unit>
        <trans-unit id="a4c1e3467d4145540134804fd2549f602b627fdd" translate="yes" xml:space="preserve">
          <source>The handler used for subsequently installed signals calls &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (actually &lt;code&gt;croak&lt;/code&gt; ) with a message indicating which signal was caught.</source>
          <target state="translated">後でインストールされるシグナルに使用されるハンドラーは、どのシグナルがキャッチされたかを示すメッセージを伴って &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; （実際には &lt;code&gt;croak&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6f12af1084926ed2ac194950a97f332b400e2448" translate="yes" xml:space="preserve">
          <source>The handler used for subsequently installed signals outputs a Perl stack trace to STDERR and then tries to dump core. This is the default signal handler.</source>
          <target state="translated">その後にインストールされたシグナルに使用されるハンドラは、Perl のスタックトレースを STDERR に出力し、コアをダンプしようとします。これはデフォルトのシグナルハンドラです。</target>
        </trans-unit>
        <trans-unit id="d5126c9fee7d8a5338a4248383236dc9ecb51986" translate="yes" xml:space="preserve">
          <source>The handling of A &amp;amp; P in MBI/MBF (the old core code shipped with Perl versions &amp;lt;= 5.7.2) is like this:</source>
          <target state="translated">MBI / MBF（Perlバージョン5.7.2に付属する古いコアコード）でのA＆Pの処理は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="fc9357967428b2793ab9d519118dce3147a43e76" translate="yes" xml:space="preserve">
          <source>The handling of errors by the layer is not specified. e.g. when $! should be set explicitly, when the error handling should be just delegated to the top layer.</source>
          <target state="translated">例えば、$! を明示的に設定する場合や、エラー処理を最上位のレイヤーに委譲する場合などです。</target>
        </trans-unit>
        <trans-unit id="3b8d0bb90f4b079a36f72ce61ffbf0db337af8a2" translate="yes" xml:space="preserve">
          <source>The handling of hyphens and em dashes is somewhat fragile, and one may get the wrong one under some circumstances. This should only matter for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">ハイフンと全角ダッシュの処理はやや壊れやすく、状況によっては間違ったものになる場合があります。これは&lt;b&gt;troff&lt;/b&gt;出力の場合にのみ問題になります。</target>
        </trans-unit>
        <trans-unit id="de0cf92f651484ad4efbe5f702009188bf5e94e3" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%ENV&lt;/code&gt; contains your current environment. Setting a value in &lt;code&gt;ENV&lt;/code&gt; changes the environment for any child processes you subsequently &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; off.</source>
          <target state="translated">ハッシュ &lt;code&gt;%ENV&lt;/code&gt; には現在の環境が含まれています。 &lt;code&gt;ENV&lt;/code&gt; に値を設定すると、その後に &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; してオフにする子プロセスの環境が変更されます。</target>
        </trans-unit>
        <trans-unit id="3342ea08441abded27300d3bc9cbf7a4f36851e5" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%INC&lt;/code&gt; contains entries for each filename included via the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; operators. The key is the filename you specified (with module names converted to pathnames), and the value is the location of the file found. The &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; operator uses this hash to determine whether a particular file has already been included.</source>
          <target state="translated">ハッシュ &lt;code&gt;%INC&lt;/code&gt; には、 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 演算子を介して含まれる各ファイル名のエントリが含まれます。キーは指定したファイル名（モジュール名をパス名に変換したもの）で、値は見つかったファイルの場所です。 &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; オペレータは、特定のファイルが既に含まれているかどうかを決定するために、このハッシュを使用しています。</target>
        </trans-unit>
        <trans-unit id="ae0c946c442c59fafdf0cc03f5925a7d6a67576e" translate="yes" xml:space="preserve">
          <source>The hash &lt;code&gt;%SIG&lt;/code&gt; contains signal handlers for signals. For example:</source>
          <target state="translated">ハッシュ &lt;code&gt;%SIG&lt;/code&gt; には、シグナルのシグナルハンドラーが含まれています。例えば：</target>
        </trans-unit>
        <trans-unit id="2b378e4f482e4b01f36a8f2a09efa90c92e18352" translate="yes" xml:space="preserve">
          <source>The hash algorithm is defined in the &lt;code&gt;PERL_HASH&lt;/code&gt; macro:</source>
          <target state="translated">ハッシュアルゴリズムは、 &lt;code&gt;PERL_HASH&lt;/code&gt; マクロで定義されます。</target>
        </trans-unit>
        <trans-unit id="eea3de2cc53cbdd71b8b1d8903e357859f8beec1" translate="yes" xml:space="preserve">
          <source>The hash described above is returned for locale-independent casing, where at least one of the mappings has length longer than one. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned, the code point may have mappings, but if so, all are length one, and are returned by &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt;. Note that when this function does return a value, it will be for the complete set of mappings for a code point, even those whose length is one.</source>
          <target state="translated">上記のハッシュは、ロケールに依存しない大文字小文字変換に対して返されます。マッピングの少なくとも1つは、1より長い長さです。場合 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 返され、コード・ポイントは、マッピングを有していてもよく、そのように、全てが長さ1であり、によって返された場合&lt;a href=&quot;#charinfo()&quot;&gt;charinfo（） &lt;/a&gt;。この関数が値を返す場合、長さが1であっても、コードポイントの完全なマッピングセットに対するものであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0c18c1acf75672457070b2eb9996c5075b3edce2" translate="yes" xml:space="preserve">
          <source>The hash does not support exists().</source>
          <target state="translated">ハッシュは exists()をサポートしていません。</target>
        </trans-unit>
        <trans-unit id="8ead17751b61a27f00737722511d4f0a6b122f2d" translate="yes" xml:space="preserve">
          <source>The hash has the same structure as the one returned by Storable::file_magic(). The &lt;code&gt;file&lt;/code&gt; element is true if the image is a file image.</source>
          <target state="translated">ハッシュの構造は、Storable :: file_magic（）によって返されるものと同じです。 &lt;code&gt;file&lt;/code&gt; イメージをファイルイメージである場合、要素はtrueです。</target>
        </trans-unit>
        <trans-unit id="5130b4f9ca4de414c6b75c63b4b5de1f1cac05d9" translate="yes" xml:space="preserve">
          <source>The hash reference returned by the new() function can be used to examine and modify the contents of the .packlist. Items may be added/deleted from the .packlist by modifying the hash. If the value associated with a hash key is a scalar, the entry written to the .packlist by any subsequent write() will be a simple filename. If the value is a hash, the entry written will be the filename followed by the key=value pairs from the hash. Reading back the .packlist will recreate the original entries.</source>
          <target state="translated">new()関数が返すハッシュ参照は、.packlistの内容を調べたり変更したりするために使用することができます。ハッシュを変更することで、.packlist から項目を追加/削除することができます。ハッシュ・キーに関連付けられた値がスカラ値の場合、後続の write()によって .packlist に書き込まれるエントリは単純なファイル名になります。値がハッシュの場合、書き込まれるエントリはファイル名の後にハッシュのキーと値のペアが続きます。.packlist を読み返すと、元のエントリが再現されます。</target>
        </trans-unit>
        <trans-unit id="7516ee71ac16390106261a6b0bbe1da56c817eef" translate="yes" xml:space="preserve">
          <source>The hash returned has the following elements:</source>
          <target state="translated">返されたハッシュは以下の要素を持っています。</target>
        </trans-unit>
        <trans-unit id="43a906eb4ff4eda3db678faefd07c14f14845797" translate="yes" xml:space="preserve">
          <source>The hash variable you want to tie.</source>
          <target state="translated">紐付けたいハッシュ変数。</target>
        </trans-unit>
        <trans-unit id="0ab4ffe148d6038400649049035912b11305e989" translate="yes" xml:space="preserve">
          <source>The head of the chain of deleted ops is returned, or NULL if no ops were deleted.</source>
          <target state="translated">削除された操作の連鎖の先頭が返され、削除されなかった場合はNULLが返されます。</target>
        </trans-unit>
        <trans-unit id="6c336f0d4ef1d936490e8c7b4819c090f6400cf2" translate="yes" xml:space="preserve">
          <source>The header file written by this module, typically</source>
          <target state="translated">このモジュールによって書かれたヘッダファイル、通常は</target>
        </trans-unit>
        <trans-unit id="4c85c6655d7d1206831fdc527a34ff595586e985" translate="yes" xml:space="preserve">
          <source>The header section continues until a line containing the word CHARMAP. This section has a form of</source>
          <target state="translated">ヘッダー部は、CHARMAPという単語を含む行まで続きます。このセクションは</target>
        </trans-unit>
        <trans-unit id="a528e0d6eaf7b88f88a4f152246f56b029cd4490" translate="yes" xml:space="preserve">
          <source>The heart of Storable is written in C for decent speed. Extra low-level optimizations have been made when manipulating perl internals, to sacrifice encapsulation for the benefit of greater speed.</source>
          <target state="translated">Storableの心臓部は、まともな速度を出すためにC言語で書かれています。Perl の内部を操作する際には、より高速にするためにカプセル化を犠牲にして、さらに低レベルの最適化が行われています。</target>
        </trans-unit>
        <trans-unit id="a6afbf6cabde867bd59953ce46fc882087b1bd27" translate="yes" xml:space="preserve">
          <source>The hex number may optionally be prefixed with &quot;0x&quot; or &quot;x&quot; unless &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; is set in</source>
          <target state="translated">16進数には、 &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; が設定されていない限り、オプションで「0x」または「x」をプレフィックスとして付けることができます。</target>
        </trans-unit>
        <trans-unit id="e478860a296847f9fc713c230a9fb9343e5f150e" translate="yes" xml:space="preserve">
          <source>The higher-level loops preserve an additional state between iterations: whether the last match was zero-length. To break the loop, the following match after a zero-length match is prohibited to have a length of zero. This prohibition interacts with backtracking (see &lt;a href=&quot;#Backtracking&quot;&gt;Backtracking&lt;/a&gt;), and so the</source>
          <target state="translated">より高いレベルのループは、反復間の追加の状態、つまり最後の一致が長さゼロであったかどうかを保持します。ループを断ち切るために、長さがゼロの一致の後の次の一致は、長さがゼロになることが禁止されています。この禁止事項は、バックトラック（&lt;a href=&quot;#Backtracking&quot;&gt;バックトラックを&lt;/a&gt;参照）と相互作用します。</target>
        </trans-unit>
        <trans-unit id="9a2214ecae9d593eb49cab164240c89849da3aae" translate="yes" xml:space="preserve">
          <source>The hintsfile is eval()ed immediately after the arguments given to WriteMakefile are stuffed into a hash reference $self but before this reference becomes blessed. So if you want to do the equivalent to override or create an attribute you would say something like</source>
          <target state="translated">hintsfileは、WriteMakefileに与えられた引数がハッシュ参照$selfに詰め込まれた直後にeval()されますが、この参照が祝福される前です。ですから、属性をオーバーライドしたり作成したりするのと同等のことをしたい場合は、次のように言うことになります。</target>
        </trans-unit>
        <trans-unit id="c6b34cade6e81d89b062f256b78cf0c9f72eec68" translate="yes" xml:space="preserve">
          <source>The hook used by perl's &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; operator. &lt;b&gt;ptype&lt;/b&gt; is perl's character for the kind of IO:</source>
          <target state="translated">perlの &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; オペレーターが使用するフック。&lt;b&gt;ptype&lt;/b&gt;は、IOの種類を&lt;b&gt;表す&lt;/b&gt; perlの文字です。</target>
        </trans-unit>
        <trans-unit id="f349975f67add93f8850a9eaf9c6c17fd6d7655e" translate="yes" xml:space="preserve">
          <source>The host name supplied to getaddrinfo() did not provide any usable address data.</source>
          <target state="translated">getaddrinfo()に与えられたホスト名は、使用可能なアドレスデータを提供しませんでした。</target>
        </trans-unit>
        <trans-unit id="26f0f0653cc389e36c588050d688c99bccaa9d07" translate="yes" xml:space="preserve">
          <source>The host name supplied to getaddrinfo() does not exist, or the address supplied to getnameinfo() is not associated with a host name and the &lt;code&gt;NI_NAMEREQD&lt;/code&gt; flag was supplied.</source>
          <target state="translated">getaddrinfo（）に指定されたホスト名が存在しないか、getnameinfo（）に指定されたアドレスがホスト名に関連付けられておらず、 &lt;code&gt;NI_NAMEREQD&lt;/code&gt; フラグが指定されています。</target>
        </trans-unit>
        <trans-unit id="a5eeccb55ae3d60bff3752f2dd5a946e36daa986" translate="yes" xml:space="preserve">
          <source>The hostname in the uri. Will be empty if host was originally 'localhost' for a 'file://' url.</source>
          <target state="translated">URL に含まれるホスト名を指定します。file://' url のホストが元々 'localhost' であった場合は空になります。</target>
        </trans-unit>
        <trans-unit id="2bcd00b585852692b974ea751e079b51540b5b54" translate="yes" xml:space="preserve">
          <source>The hyperbolic sine, cosine, and tangent</source>
          <target state="translated">双曲線のサイン、コサイン、タンジェント</target>
        </trans-unit>
        <trans-unit id="a67744a35db2bbac17aada3b55cebfdff3c8d58f" translate="yes" xml:space="preserve">
          <source>The icmp protocol requires that the program be run as root or that it be setuid to root. The other protocols do not require special privileges, but not all network devices implement tcp or udp echo.</source>
          <target state="translated">icmp プロトコルでは、プログラムを root で実行するか、root に setuid を設定する必要があります。他のプロトコルは特別な権限を必要としませんが、すべてのネットワークデバイスが tcp や udp echo を実装しているわけではありません。</target>
        </trans-unit>
        <trans-unit id="0eb904ac9079537474ee2cc5638a1c5ecde2814c" translate="yes" xml:space="preserve">
          <source>The id must start with a letter (a-z or A-Z)</source>
          <target state="translated">idは文字(a-zまたはA-Z)で始まる必要があります。</target>
        </trans-unit>
        <trans-unit id="28df5f4390b3a084c824acbbd266525edf8be51a" translate="yes" xml:space="preserve">
          <source>The ideal (but a bit ugly) way to never have to think about that is to use &lt;code&gt;BEGIN&lt;/code&gt; blocks. So the first part of the &lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt; code could be rewritten as:</source>
          <target state="translated">それについて決して考える必要がない理想的な（しかし少し醜い）方法は、 &lt;code&gt;BEGIN&lt;/code&gt; ブロックを使用することです。したがって、&lt;a href=&quot;#SYNOPSIS&quot;&gt;SYNOPSIS&lt;/a&gt;コードの最初の部分は次のように書き直すことができます。</target>
        </trans-unit>
        <trans-unit id="c4b5bd1f2c1aa12d8d86dc87b94e48313e6fd68a" translate="yes" xml:space="preserve">
          <source>The immediate, previous releases (i.e. perl5.14.x ) are usually maintained for a while, although not at the same level as the current releases.</source>
          <target state="translated">直前のリリース (すなわち perl5.14.x)は、現在のリリースと同じレベルではありませんが、通常はしばらくの間維持されます。</target>
        </trans-unit>
        <trans-unit id="805f5e34bdac09e91b618eb56a2ba5ac7b88cd61" translate="yes" xml:space="preserve">
          <source>The implementation of &lt;code&gt;:raw&lt;/code&gt; is as a pseudo-layer which when &quot;pushed&quot; pops itself and then any layers which do not declare themselves as suitable for binary data. (Undoing :utf8 and :crlf are implemented by clearing flags rather than popping layers but that is an implementation detail.)</source>
          <target state="translated">&lt;code&gt;:raw&lt;/code&gt; の実装は、「プッシュ」されたときにそれ自体をポップし、次にバイナリデータに適していると宣言しないすべてのレイヤーを擬似レイヤーとして実装します。（：utf8と：crlfを元に戻すことは、レイヤーをポップするのではなくフラグをクリアすることで実装されますが、これは実装の詳細です。）</target>
        </trans-unit>
        <trans-unit id="1868b2d1d8d2925ab9482699d09a63b0f1af9f3c" translate="yes" xml:space="preserve">
          <source>The implementation of individual components of the system is likely to change over time.</source>
          <target state="translated">個々の構成要素の実装は、時間の経過とともに変化する可能性が高い。</target>
        </trans-unit>
        <trans-unit id="6075b5ee16206eda7e75f744a66591ab7ff6ad34" translate="yes" xml:space="preserve">
          <source>The implementation of the C3 MRO and switchable MROs within the perl core was written by Brandon L Black. Nicholas Clark created the pluggable interface, refactored Brandon's implementation to work with it, and wrote this document.</source>
          <target state="translated">perlコア内のC3 MROとswitchable MROの実装はBrandon L Blackによって書かれました。ニコラス・クラークはプラガブルインターフェースを作成し、Brandonの実装をそれで動作するようにリファクタリングし、このドキュメントを書きました。</target>
        </trans-unit>
        <trans-unit id="f92ca5378313f5f6ef2629dcf71bf80c645c279f" translate="yes" xml:space="preserve">
          <source>The implication of the above description is that a pattern containing nested parentheses will result in a call graph which cycles through &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt; , &lt;code&gt;regpiece()&lt;/code&gt; , &lt;code&gt;regatom()&lt;/code&gt; , &lt;code&gt;reg()&lt;/code&gt; , &lt;code&gt;regbranch()&lt;/code&gt;</source>
          <target state="translated">上記の説明の意味は、ネストされた括弧を含むパターンは、 &lt;code&gt;reg()&lt;/code&gt; 、 &lt;code&gt;regbranch()&lt;/code&gt; 、 &lt;code&gt;regpiece()&lt;/code&gt; 、 &lt;code&gt;regatom()&lt;/code&gt; 、 &lt;code&gt;reg()&lt;/code&gt; 、 &lt;code&gt;regbranch()&lt;/code&gt; を循環する呼び出しグラフになるということです</target>
        </trans-unit>
        <trans-unit id="61ca45a7499fa655d95fb3a1c14575987ee3c0c2" translate="yes" xml:space="preserve">
          <source>The implicit iterator variable in the &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; 関数の暗黙の反復子変数。</target>
        </trans-unit>
        <trans-unit id="49df36702f6a3c6192de102a29688dbe9fd4061b" translate="yes" xml:space="preserve">
          <source>The implicit variable of &lt;code&gt;given()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;given()&lt;/code&gt; の暗黙の変数。</target>
        </trans-unit>
        <trans-unit id="04c82ff9343f818ba122f89e2a74fb9d1d0fecda" translate="yes" xml:space="preserve">
          <source>The importance of these tests is proportional to the alleged stability of a module. A module which purports to be stable or which hopes to achieve wide use should adhere to as strict a testing regime as possible.</source>
          <target state="translated">これらのテストの重要性は、モジュールの安定性に比例します。安定していると主張するモジュールや、広く使用されることを望むモジュールは、可能な限り厳格なテスト体制を守るべきです。</target>
        </trans-unit>
        <trans-unit id="09af00710c80d3dd70ebd96fd4367e42313c5d25" translate="yes" xml:space="preserve">
          <source>The importance of writing good test scripts cannot be over-emphasized. You should closely follow the &quot;ok/not ok&quot; style that Perl itself uses, so that it is very easy and unambiguous to determine the outcome of each test case. When you find and fix a bug, make sure you add a test case for it.</source>
          <target state="translated">良いテストスクリプトを書くことの重要性は、強調しすぎることはできません。Perl 自身が使用している「OK/NOT OK」というスタイルに忠実に従うべきです。バグを見つけて修正したら、必ずテストケースを追加してください。</target>
        </trans-unit>
        <trans-unit id="a4561daf93366d570e71e9394fec54f9d31846e6" translate="yes" xml:space="preserve">
          <source>The important and distinguishing feature of run_forked is execution timeout which at first seems to be quite a simple task but if you think that the program which you're spawning might spawn some children itself (which in their turn could do the same and so on) it turns out to be not a simple issue.</source>
          <target state="translated">run_forked の重要で特徴的な機能は実行タイムアウトで、これは最初は非常に単純な作業のように見えますが、もしあなたがスポーンしているプログラムが子プログラム自体をスポーンするかもしれないと考えるならば(その子プログラムが順番に同じようなことをするかもしれない)、それは単純な問題ではないことがわかります。</target>
        </trans-unit>
        <trans-unit id="4973662d6822686f7aa087396e5cfac037bf9b09" translate="yes" xml:space="preserve">
          <source>The important parts of that are the second argument (the increment) to HEAP, and allowing the stack to be &quot;Above the (16M) line&quot;. If the heap increment is too small then when perl (for example loading unicode/Name.pl) tries to create a &quot;big&quot; (400K+) string it cannot fit in a single segment and you get &quot;Out of Memory!&quot; - even if there is still plenty of memory available.</source>
          <target state="translated">その中で重要なのは、HEAPへの第二引数(インクリメント)と、スタックが &quot;Above the (16M)line &quot;になるようにすることです。もしヒープのインクリメントが小さすぎると、perlが(例えばunicode/Name.plをロードして)&quot;大きな &quot;文字列(400K+)を作成しようとしたときに、1つのセグメントに収まりきらず、&quot;Out of Memory!&quot;となります。-と表示されます。</target>
        </trans-unit>
        <trans-unit id="3f69c866bd6b570c0ad67a5d6dcc4f47abb90206" translate="yes" xml:space="preserve">
          <source>The included contents will be inserted into the MANIFEST.SKIP file in between</source>
          <target state="translated">の間にある MANIFEST.SKIP ファイルに同梱されている内容が挿入されます。</target>
        </trans-unit>
        <trans-unit id="02e5563a36b89e14fcbd689f1595a21037cddaee" translate="yes" xml:space="preserve">
          <source>The independent subexpression &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; doesn't care about the rest of the regexp, so it sees an &lt;code&gt;a&lt;/code&gt; and grabs it. Then the rest of the regexp &lt;code&gt;ab&lt;/code&gt; cannot match. Because &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; is independent, there is no backtracking and the independent subexpression does not give up its &lt;code&gt;a&lt;/code&gt; . Thus the match of the regexp as a whole fails. A similar behavior occurs with completely independent regexps:</source>
          <target state="translated">独立した部分式 &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; は、正規表現の残りの部分を考慮しないため、 &lt;code&gt;a&lt;/code&gt; を見てそれを取得します。その後、正規表現 &lt;code&gt;ab&lt;/code&gt; の残りの部分は一致できません。ので &lt;code&gt;(?&amp;gt;a*)&lt;/code&gt; 独立しており、そこにはバックトラックがなく、独立した部分式はあきらめていません &lt;code&gt;a&lt;/code&gt; 。したがって、全体としての正規表現の一致は失敗します。完全に独立した正規表現でも同様の動作が発生します。</target>
        </trans-unit>
        <trans-unit id="d8911df7ecc3a80cd7cb7748b8608afa2215b297" translate="yes" xml:space="preserve">
          <source>The index entry specified contains nothing but whitespace.</source>
          <target state="translated">指定されたインデックス項目には、空白以外の何も含まれていません。</target>
        </trans-unit>
        <trans-unit id="ed2b9d5332f95abb7e28bc54e5124d59c88ac74f" translate="yes" xml:space="preserve">
          <source>The index function searches for one string within another, but without the wildcard-like behavior of a full regular-expression pattern match. It returns the position of the first occurrence of SUBSTR in STR at or after POSITION. If POSITION is omitted, starts searching from the beginning of the string. POSITION before the beginning of the string or after its end is treated as if it were the beginning or the end, respectively. POSITION and the return value are based at zero. If the substring is not found, &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; returns -1.</source>
          <target state="translated">インデックス関数は、ある文字列を別の文字列内で検索しますが、完全な正規表現パターン一致のワイルドカードのような動作はありません。これは、POSITION以降のSTRで最初に出現するSUBSTRの位置を返します。POSITIONを省略すると、文字列の先頭から検索を開始します。文字列の先頭の前または末尾の後のPOSITIONは、それぞれ先頭または末尾であるかのように扱われます。POSITIONと戻り値はゼロを基準とします。部分文字列が見つからない場合、 &lt;code&gt;&lt;a href=&quot;functions/index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; は-1を返します。</target>
        </trans-unit>
        <trans-unit id="052a5a20374b32a9d318c8e657a3fc6d2c067a62" translate="yes" xml:space="preserve">
          <source>The index function searches for one string within another, but without the wildcard-like behavior of a full regular-expression pattern match. It returns the position of the first occurrence of SUBSTR in STR at or after POSITION. If POSITION is omitted, starts searching from the beginning of the string. POSITION before the beginning of the string or after its end is treated as if it were the beginning or the end, respectively. POSITION and the return value are based at zero. If the substring is not found, &lt;code&gt;&lt;a href=&quot;index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; returns -1.</source>
          <target state="translated">インデックス関数は、ある文字列を別の文字列内で検索しますが、完全な正規表現パターン一致のワイルドカードのような動作はありません。これは、POSITION以降のSTRで最初に出現するSUBSTRの位置を返します。POSITIONを省略すると、文字列の先頭から検索を開始します。文字列の先頭の前または末尾の後のPOSITIONは、それぞれ先頭または末尾であるかのように扱われます。POSITIONと戻り値はゼロを基準とします。部分文字列が見つからない場合、 &lt;code&gt;&lt;a href=&quot;index&quot;&gt;index&lt;/a&gt;&lt;/code&gt; は-1を返します。</target>
        </trans-unit>
        <trans-unit id="f9d12f86f44aac2e21ecbe7b61cc95b95675209f" translate="yes" xml:space="preserve">
          <source>The index of the last allocated space in the padlist. Note that the last pad may be in an earlier slot. Any entries following it will be NULL in that case.</source>
          <target state="translated">パッドリストの最後に割り当てられたスペースのインデックス。最後のパッドが以前のスロットにある可能性があることに注意してください。その場合、それに続くエントリはすべて NULL になります。</target>
        </trans-unit>
        <trans-unit id="e58a7f8912fdbd8eaa97b22ef4d5d356a40471d5" translate="yes" xml:space="preserve">
          <source>The index of the last pad entry.</source>
          <target state="translated">最後のパッドエントリのインデックス。</target>
        </trans-unit>
        <trans-unit id="9c1326f686e664ef67aae2567ac4696fd6d57b00" translate="yes" xml:space="preserve">
          <source>The index of the last pad name.</source>
          <target state="translated">最後のパッド名のインデックス。</target>
        </trans-unit>
        <trans-unit id="cda2671ac9e05ad8e30450bd5f169c0ab42ddce2" translate="yes" xml:space="preserve">
          <source>The indexing merely outputs messages via &lt;code&gt;.tm&lt;/code&gt; for each major page, section, subsection, item, and any &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; directives. See &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; for more details.</source>
          <target state="translated">インデックス作成は、メジャーページ、セクション、サブセクション、アイテム、および &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ディレクティブごとに &lt;code&gt;.tm&lt;/code&gt; を介してメッセージを出力するだけです。詳細については、&lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c99d2cd33e1325afbec2e3f58c4236d44c82d895" translate="yes" xml:space="preserve">
          <source>The inferred anchor text is implemented per &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;:</source>
          <target state="translated">推測されたアンカーテキストは&lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;ごとに実装されます：</target>
        </trans-unit>
        <trans-unit id="9dfbacdda04f65b21a64f3fbe8dd597fa30ae2f5" translate="yes" xml:space="preserve">
          <source>The infinity and not-a-number have their own special arithmetic rules. The general rule is that they are &quot;contagious&quot;: &lt;code&gt;Inf&lt;/code&gt; plus one is &lt;code&gt;Inf&lt;/code&gt; , and &lt;code&gt;NaN&lt;/code&gt; plus one is &lt;code&gt;NaN&lt;/code&gt; . Where things get interesting is when you combine infinities and not-a-numbers: &lt;code&gt;Inf&lt;/code&gt; minus &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; divided by &lt;code&gt;INf&lt;/code&gt; are &lt;code&gt;NaN&lt;/code&gt; (while &lt;code&gt;Inf&lt;/code&gt; plus &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;Inf&lt;/code&gt; times &lt;code&gt;Inf&lt;/code&gt; is &lt;code&gt;Inf&lt;/code&gt; ). &lt;code&gt;NaN&lt;/code&gt; is also curious in that it does not equal any number,</source>
          <target state="translated">無限大と非数には、独自の算術規則があります。一般的な規則は、それらが「伝染性」であるということです &lt;code&gt;Inf&lt;/code&gt; プラス1は &lt;code&gt;Inf&lt;/code&gt; であり、 &lt;code&gt;NaN&lt;/code&gt; プラス1は &lt;code&gt;NaN&lt;/code&gt; です。あなたは無限ではなく-番号組み合わせるとどこに物事が面白くはある： &lt;code&gt;Inf&lt;/code&gt; のマイナス &lt;code&gt;Inf&lt;/code&gt; のと &lt;code&gt;Inf&lt;/code&gt; ので割った &lt;code&gt;INf&lt;/code&gt; している &lt;code&gt;NaN&lt;/code&gt; （しながら、 &lt;code&gt;Inf&lt;/code&gt; のプラス &lt;code&gt;Inf&lt;/code&gt; のがされ &lt;code&gt;Inf&lt;/code&gt; のと &lt;code&gt;Inf&lt;/code&gt; の倍 &lt;code&gt;Inf&lt;/code&gt; ある &lt;code&gt;Inf&lt;/code&gt; に）。 &lt;code&gt;NaN&lt;/code&gt; は、どの数とも等しくないという点でも興味深いです。</target>
        </trans-unit>
        <trans-unit id="47e5e47a18eb5768545b57a7c2da190e8c801676" translate="yes" xml:space="preserve">
          <source>The infinity is the result of certain math operations that overflow the floating point range, like 9**9**9. The not-a-number is the result when the result is undefined or unrepresentable. Though note that you cannot get &lt;code&gt;NaN&lt;/code&gt; from some common &quot;undefined&quot; or &quot;out-of-range&quot; operations like dividing by zero, or square root of a negative number, since Perl generates fatal errors for those.</source>
          <target state="translated">無限大は、9 ** 9 ** 9のように、浮動小数点の範囲をオーバーフローする特定の数学演算の結果です。not-a-numberは、結果が未定義または表現できない場合の結果です。ただし、ゼロによる除算や負の数の平方根などの一般的な「未定義」または「範囲外」の操作から &lt;code&gt;NaN&lt;/code&gt; を取得できないことに注意してください。これは、Perlが致命的なエラーを生成するためです。</target>
        </trans-unit>
        <trans-unit id="00c49c340cf01a0ad0057e1d1a4eb69e30e225ff" translate="yes" xml:space="preserve">
          <source>The information in</source>
          <target state="translated">の情報は</target>
        </trans-unit>
        <trans-unit id="477d4eda55a2d3f9993a8441da0761392c6f4bde" translate="yes" xml:space="preserve">
          <source>The init routine asks a few questions and writes a CPAN/Config.pm or CPAN/MyConfig.pm file (depending on what it is currently using).</source>
          <target state="translated">initルーチンはいくつかの質問をして、CPAN/Config.pmまたはCPAN/MyConfig.pmファイルを書き込みます(現在使用しているものによります)。</target>
        </trans-unit>
        <trans-unit id="46a6f162dfe4fd1932efaab095f3ad6c7065353c" translate="yes" xml:space="preserve">
          <source>The initial Haiku port was done by Ingo Weinhold &amp;lt;ingo_weinhold@gmx.de&amp;gt;.</source>
          <target state="translated">最初のHaikuへの移植は、Ingo Weinhold &amp;lt;ingo_weinhold@gmx.de&amp;gt;によって行われました。</target>
        </trans-unit>
        <trans-unit id="30baee764016e0fd1d74fa20302dc7f15e17366e" translate="yes" xml:space="preserve">
          <source>The initial comment shows a contrived, even dangerous example. By overriding &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; globally, you would be forcing the new (and subversive) behavior for the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator for</source>
          <target state="translated">最初のコメントは、不自然で危険な例さえ示しています。 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; をグローバルにオーバーライドすると、 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; 演算子の新しい（そして破壊的な）動作が強制されます。</target>
        </trans-unit>
        <trans-unit id="9bd35ba0a15f59402bf69541a0c2a672b5245bb7" translate="yes" xml:space="preserve">
          <source>The initializer for a class element is an object of the corresponding class, or of one of it's subclasses, or a reference to a hash containing named arguments to be passed to the element's constructor.</source>
          <target state="translated">クラス要素のイニシャライザは、対応するクラスのオブジェクト、あるいはそのサブクラスのオブジェクト、あるいは要素のコンストラクタに渡される名前付き引数を含むハッシュへの参照です。</target>
        </trans-unit>
        <trans-unit id="7270a1d75b517033df50fe18fd9734207c302454" translate="yes" xml:space="preserve">
          <source>The input character at &lt;code&gt;p&lt;/code&gt; is assumed to be well-formed.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; の入力文字は整形式であると見なされます。</target>
        </trans-unit>
        <trans-unit id="5b4da48b1525c95aa66984d855f728baeff9dd23" translate="yes" xml:space="preserve">
          <source>The input data will be read from each file in turn.</source>
          <target state="translated">入力されたデータは、各ファイルから順番に読み込まれていきます。</target>
        </trans-unit>
        <trans-unit id="6a300bdc55cb2694c445f5d77189a272f405a2c8" translate="yes" xml:space="preserve">
          <source>The input number must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; , it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="translated">入力番号は、負でない整数、または &lt;code&gt;&quot;U+&quot;&lt;/code&gt; または &lt;code&gt;&quot;0x&quot;&lt;/code&gt; で始まり、残りが16進整数と見なされる文字列でなければなりません。リテラル数値定数は符号なしでなければなりません。先頭に0が付いているか、10進数以外の16進数が含まれている場合、16進数として解釈されます。それ以外の場合は、10進数として解釈されます。 &lt;code&gt;&quot;U+&quot;&lt;/code&gt; で始まる場合は、Unicodeコードポイントとして解釈されます。それ以外の場合は、ネイティブとして解釈されます。 （256未満のコードポイントのみがUnicodeとネイティブの間で異なる可能性があります。）したがって、 &lt;code&gt;U+41&lt;/code&gt; は常にラテン文字「A」です。ただし、EBCDICプラットフォームでは &lt;code&gt;0x41&lt;/code&gt; を「NO-BREAK SPACE」にすることができます。</target>
        </trans-unit>
        <trans-unit id="74af33c799ba9469f42a06ffc1422c08fe76ab11" translate="yes" xml:space="preserve">
          <source>The input parameter name is loosely matched, which means that white space, hyphens, and underscores are ignored (except for the trailing underscore in the old_form grandfathered-in &lt;code&gt;&quot;L_&quot;&lt;/code&gt; , which is better written as &lt;code&gt;&quot;LC&quot;&lt;/code&gt; , and both of which mean &lt;code&gt;General_Category=Cased Letter&lt;/code&gt; ).</source>
          <target state="translated">入力パラメーター名は大まかに一致します。つまり、空白、ハイフン、およびアンダースコアは無視されます（old_formのグランドファーザードイン &lt;code&gt;&quot;L_&quot;&lt;/code&gt; の末尾のアンダースコアは除きます。&quot; L &quot;の方が &lt;code&gt;&quot;LC&quot;&lt;/code&gt; として記述されますが、どちらも意味します）。 &lt;code&gt;General_Category=Cased Letter&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6e74e0d2d8b749838155344b24b616732216f51a" translate="yes" xml:space="preserve">
          <source>The input record separator - &lt;code&gt;$/&lt;/code&gt; in Perl space.</source>
          <target state="translated">入力レコード区切り文字-Perlスペースの &lt;code&gt;$/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fa23e4762b9d73d4eaf4fe4ff40a6345a28b068" translate="yes" xml:space="preserve">
          <source>The input record separator, newline by default. This influences Perl's idea of what a &quot;line&quot; is. Works like &lt;b&gt;awk&lt;/b&gt;'s RS variable, including treating empty lines as a terminator if set to the null string (an empty line cannot contain any spaces or tabs). You may set it to a multi-character string to match a multi-character terminator, or to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; to read through the end of file. Setting it to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; means something slightly different than setting to &lt;code&gt;&quot;&quot;&lt;/code&gt; , if the file contains consecutive empty lines. Setting to &lt;code&gt;&quot;&quot;&lt;/code&gt; will treat two or more consecutive empty lines as a single empty line. Setting to &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; will blindly assume that the next input character belongs to the next paragraph, even if it's a newline.</source>
          <target state="translated">入力レコードセパレータ、デフォルトでは改行。これは、「行」とは何かに関するPerlの考えに影響を与えます。&lt;b&gt;awk&lt;/b&gt;のRS変数のように機能します。空の行がnull文字列に設定されている場合は空行をターミネーターとして扱います（空の行にスペースやタブを含めることはできません）。これを複数文字の文字列に設定して、複数文字のターミネーターに一致させるか、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; に設定してファイルの終わりまで読み取ることができます。それを設定する &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; に設定するよりもわずかに異なる手段の何か &lt;code&gt;&quot;&quot;&lt;/code&gt; ファイルが連続した空行が含まれている場合は、。 &lt;code&gt;&quot;&quot;&lt;/code&gt; に設定すると、2つ以上の連続した空行が1つの空行として扱われます。設定する &lt;code&gt;&quot;\n\n&quot;&lt;/code&gt; 改行であっても、次の入力文字は次の段落に属していると盲目的に仮定します。</target>
        </trans-unit>
        <trans-unit id="32e2a05c675d83b32cdc798d03f4bd19670bf464" translate="yes" xml:space="preserve">
          <source>The insertion of a scalar or list value somewhere in the middle of another value, such that it appears to have been there all along. In Perl, variable interpolation happens in double-quoted strings and patterns, and list interpolation occurs when constructing the list of values to pass to a list operator or other such construct that takes a</source>
          <target state="translated">スカラ値やリスト値を別の値のどこかに挿入することで、それが最初から存在していたように見えるようにします。Perl では、変数の補間は二重引用符で囲まれた文字列やパターンで行われ、リストの補間はリスト演算子に渡す値のリストを構築するときに行われます。</target>
        </trans-unit>
        <trans-unit id="4d21a2b8d717cbebbeaee5c37e1b249a9b6f4299" translate="yes" xml:space="preserve">
          <source>The inspiration for the stop codon DNA example came from the ZIP code example in chapter 7 of</source>
          <target state="translated">ストップコドンDNAの例のインスピレーションは、『DELEASE』の第7章にあるZIPコードの例から来ています。</target>
        </trans-unit>
        <trans-unit id="4a97f9d9b06cf863773b30ca4503b6a95be51b13" translate="yes" xml:space="preserve">
          <source>The installation paths that you set during the build get compiled into perl, so you don't have to do anything additional to start using that perl (except add its location to your PATH variable).</source>
          <target state="translated">ビルド時に設定したインストールパスはperlにコンパイルされますので、そのperlを使い始めるためには何も追加する必要はありません(PATH変数にその場所を追加する以外は)。</target>
        </trans-unit>
        <trans-unit id="ed7ec50305347f54da6bfda8296e9515a40cfdd4" translate="yes" xml:space="preserve">
          <source>The installer is ancient and has a few bugs on the paths it uses. You will have to fix them later. Basically, some things go into &quot;C:/Program Files/Windows CE Tools&quot;, others go into &quot;C:/Windows CE Tools&quot; regardless of the path you gave to the installer (the default will be &quot;C:/Windows CE Tools&quot;). Reboots will be required for the installer to proceed. Also .c and .h associations with Visual Studio might get overridden when installing EVC4. You have been warned.</source>
          <target state="translated">インストーラは古く、使用するパスにいくつかのバグがあります。後で修正する必要があります。基本的に、あるものは &quot;C:/Program Files/Windows CE Tools&quot; に入り、あるものは &quot;C:/Windows CE Tools&quot; に入り、インストーラに与えたパスに関係なく (デフォルトは &quot;C:/Windows CE Tools&quot; です)、インストーラーを続行するには再起動が必要です。インストーラを続行するには、再起動が必要です。また、EVC4 をインストールする際に、Visual Studio との .c と .h の関連付けがオーバーライドされる可能性があります。警告が出ています。</target>
        </trans-unit>
        <trans-unit id="5b7ef7bcb453733f9ef12df7a7d461832dbe120b" translate="yes" xml:space="preserve">
          <source>The installman script will try to run on OS/390. There will be fewer errors if you have a roff utility installed. You can obtain GNU groff from the Redbook SG24-5944-00 ftp site.</source>
          <target state="translated">installman スクリプトは OS/390 で実行しようとします。roff ユーティリティがインストールされていれば、エラーは少なくなるでしょう。GNU groff は Redbook SG24-5944-00 ftp サイトから入手できます。</target>
        </trans-unit>
        <trans-unit id="85593ec8ae8efa2e0dca43eb532734290d86abb5" translate="yes" xml:space="preserve">
          <source>The integer a computer uses to represent a given character. ASCII codepoints are in the range 0 to 127; Unicode codepoints are in the range 0 to 0x1F_FFFF; and Perl codepoints are in the range 0 to 2&amp;sup3;&amp;sup2;&amp;minus;1 or 0 to 2⁶⁴&amp;minus;1, depending on your native integer size. In Perl Culture, sometimes called &lt;b&gt;ordinals&lt;/b&gt;.</source>
          <target state="translated">コンピュータが特定の文字を表すために使用する整数。ASCIIコードポイントの範囲は0〜127です。Unicodeコードポイントの範囲は0〜0x1F_FFFFです。また、Perlコードポイントは、ネイティブの整数サイズに応じて、0〜2&amp;sup3;&amp;sup2;-1または0〜2⁶⁴-1の範囲にあります。Perl Cultureでは、&lt;b&gt;序数&lt;/b&gt;と呼ばれることもあります。</target>
        </trans-unit>
        <trans-unit id="fffacf90cdbd65b0d80477a60f2e9ed117d5e990" translate="yes" xml:space="preserve">
          <source>The integer formats &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; , and &lt;code&gt;J&lt;/code&gt; are inherently non-portable between processors and operating systems because they obey native byteorder and endianness. For example, a 4-byte integer 0x12345678 (305419896 decimal) would be ordered natively (arranged in and handled by the CPU registers) into bytes as</source>
          <target state="translated">整数形式 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;S&lt;/code&gt; 、 &lt;code&gt;i&lt;/code&gt; 、 &lt;code&gt;I&lt;/code&gt; 、 &lt;code&gt;l&lt;/code&gt; 、 &lt;code&gt;L&lt;/code&gt; 、 &lt;code&gt;j&lt;/code&gt; 、および &lt;code&gt;J&lt;/code&gt; は、ネイティブのバイト順序とエンディアンに従うため、プロセッサとオペレーティングシステム間で本質的に移植できません。たとえば、4バイトの整数0x12345678（10進数で305419896）は、次のようにネイティブに（CPUレジスタに配置されて処理される）バイトに順序付けされます。</target>
        </trans-unit>
        <trans-unit id="c85dc9716f98ce9d26e0b8a1181441b82dd671db" translate="yes" xml:space="preserve">
          <source>The integer formats &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;I&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; , and &lt;code&gt;J&lt;/code&gt; are inherently non-portable between processors and operating systems because they obey native byteorder and endianness. For example, a 4-byte integer 0x12345678 (305419896 decimal) would be ordered natively (arranged in and handled by the CPU registers) into bytes as</source>
          <target state="translated">整数形式 &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;S&lt;/code&gt; 、 &lt;code&gt;i&lt;/code&gt; 、 &lt;code&gt;I&lt;/code&gt; 、 &lt;code&gt;l&lt;/code&gt; 、 &lt;code&gt;L&lt;/code&gt; 、 &lt;code&gt;j&lt;/code&gt; 、および &lt;code&gt;J&lt;/code&gt; は、ネイティブのバイト順序とエンディアンに従うため、プロセッサとオペレーティングシステム間で本質的に移植できません。たとえば、4バイトの整数0x12345678（10進数で305419896）は、次のようにネイティブに（CPUレジスタに配置されて処理される）バイトに順序付けされます。</target>
        </trans-unit>
        <trans-unit id="1696e5627c4e618d6b57f471d56db53f3261ebc8" translate="yes" xml:space="preserve">
          <source>The integer four, not to be confused with six, Tom&amp;rsquo;s favorite editor. IV also means an internal Integer Value of the type a &lt;b&gt;scalar&lt;/b&gt; can hold, not to be confused with an &lt;b&gt;NV&lt;/b&gt;.</source>
          <target state="translated">整数4、6と混同しないでください。トムのお気に入りのエディターです。IVはまたタイプの内部整数値を意味&lt;b&gt;スカラーは&lt;/b&gt;ないと混同し保持することができ、&lt;b&gt;NVが&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="38f7f88bfbbfc7fbb6565adc2a9af0982c4ebbc9" translate="yes" xml:space="preserve">
          <source>The integer or name form of the &lt;code&gt;condition&lt;/code&gt; allows us to choose, with more flexibility, what to match based on what matched earlier in the regexp. This searches for words of the form &lt;code&gt;&quot;$x$x&quot;&lt;/code&gt; or &lt;code&gt;&quot;$x$y$y$x&quot;&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; の整数または名前の形式により、以前の正規表現で一致したものに基づいて、より柔軟に一致するものを選択できます。これは、 &lt;code&gt;&quot;$x$x&quot;&lt;/code&gt; または &lt;code&gt;&quot;$x$y$y$x&quot;&lt;/code&gt; の形式の単語を検索します。</target>
        </trans-unit>
        <trans-unit id="e05de89837820906430d66857198677bee870304" translate="yes" xml:space="preserve">
          <source>The integer types &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;L&lt;/code&gt; may be followed by a &lt;code&gt;!&lt;/code&gt; modifier to specify native shorts or longs. As shown in the example above, a bare &lt;code&gt;l&lt;/code&gt; means exactly 32 bits, although the native &lt;code&gt;long&lt;/code&gt; as seen by the local C compiler may be larger. This is mainly an issue on 64-bit platforms. You can see whether using &lt;code&gt;!&lt;/code&gt; makes any difference this way:</source>
          <target state="translated">整数型 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;S&lt;/code&gt; 、 &lt;code&gt;l&lt;/code&gt; 、および &lt;code&gt;L&lt;/code&gt; の後には &lt;code&gt;!&lt;/code&gt; ネイティブのshortまたはlongを指定する修飾子。上記の例に示すように、ローカルのCコンパイラで見られるネイティブの &lt;code&gt;long&lt;/code&gt; はさらに大きくなる可能性がありますが、ベア &lt;code&gt;l&lt;/code&gt; は正確に32ビットを意味します。これは主に64ビットプラットフォームでの問題です。を使用しているかどうかを確認できます &lt;code&gt;!&lt;/code&gt; この方法で違いが生じます：</target>
        </trans-unit>
        <trans-unit id="e28530f74a983b5b7c88ba8ea81f426cbf7efd7c" translate="yes" xml:space="preserve">
          <source>The integer types &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , and &lt;code&gt;L&lt;/code&gt; may be followed by a &lt;code&gt;!&lt;/code&gt; modifier to specify native shorts or longs. As shown in the example above, a bare &lt;code&gt;l&lt;/code&gt; means exactly 32 bits, although the native &lt;code&gt;long&lt;/code&gt; as seen by the local C compiler may be larger. This is mainly an issue on 64-bit platforms. You can see whether using &lt;code&gt;!&lt;/code&gt; makes any difference this way:</source>
          <target state="translated">整数型 &lt;code&gt;&lt;a href=&quot;s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;S&lt;/code&gt; 、 &lt;code&gt;l&lt;/code&gt; 、および &lt;code&gt;L&lt;/code&gt; の後には &lt;code&gt;!&lt;/code&gt; ネイティブのshortまたはlongを指定する修飾子。上記の例に示すように、ローカルのCコンパイラで見られるネイティブの &lt;code&gt;long&lt;/code&gt; はさらに大きくなる可能性がありますが、ベア &lt;code&gt;l&lt;/code&gt; は正確に32ビットを意味します。これは主に64ビットプラットフォームでの問題です。を使用しているかどうかを確認できます &lt;code&gt;!&lt;/code&gt; この方法で違いが生じます：</target>
        </trans-unit>
        <trans-unit id="ec5708b037f56278734976c0deaf7b452666b9a4" translate="yes" xml:space="preserve">
          <source>The intended purpose of this routine is to concatenate</source>
          <target state="translated">このルーチンの意図された目的は</target>
        </trans-unit>
        <trans-unit id="35499217c3dc076a80a3d7b854f65596514d0493" translate="yes" xml:space="preserve">
          <source>The intent is simplicity of use, not power of expression. Paragraphs look like paragraphs (block format), so that they stand out visually, and so that I could run them through &lt;code&gt;fmt&lt;/code&gt; easily to reformat them (that's F7 in my version of &lt;b&gt;vi&lt;/b&gt;, or Esc Q in my version of &lt;b&gt;emacs&lt;/b&gt;). I wanted the translator to always leave the &lt;code&gt;'&lt;/code&gt; and &lt;code&gt;`&lt;/code&gt; and &lt;code&gt;&quot;&lt;/code&gt; quotes alone, in verbatim mode, so I could slurp in a working program, shift it over four spaces, and have it print out, er, verbatim. And presumably in a monospace font.</source>
          <target state="translated">その意図は、表現の力ではなく、使用の単純さです。段落は段落（ブロック形式）のように見えるため、視覚的に目立つようになり、簡単に &lt;code&gt;fmt&lt;/code&gt; を実行して再フォーマットできます（私のバージョンの&lt;b&gt;vi&lt;/b&gt;ではF7 、または私のバージョンの&lt;b&gt;emacs&lt;/b&gt;ではEsc Q ）。私は翻訳者が常に &lt;code&gt;'&lt;/code&gt; と &lt;code&gt;`&lt;/code&gt; と &lt;code&gt;&quot;&lt;/code&gt; の引用符をそのまま残し、逐語的モードにしたかったので、作業プログラムで丸呑みにして4つのスペースにシフトし、それをそのまま出力することができました。フォント。</target>
        </trans-unit>
        <trans-unit id="e5ab1ae02bd72d53207c68855ddd39b0273ee3a8" translate="yes" xml:space="preserve">
          <source>The intent is to squeeze as much possible information about the likely cause into the limited space of the system exit code. However, as &lt;code&gt;$!&lt;/code&gt; is the value of C's &lt;code&gt;errno&lt;/code&gt; , which can be set by any system call, this means that the value of the exit code used by &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; can be non-predictable, so should not be relied upon, other than to be non-zero.</source>
          <target state="translated">その目的は、考えられる原因に関する可能な限り多くの情報を、システム終了コードの限られたスペースに詰め込むことです。ただし、 &lt;code&gt;$!&lt;/code&gt; Cの &lt;code&gt;errno&lt;/code&gt; の値であり、システムコールで設定できます。つまり、 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; が使用する終了コードの値は予測できない可能性があるため、ゼロ以外であることを除いて、これに依存することはできません。</target>
        </trans-unit>
        <trans-unit id="0547c3f088cded7d6e36027ba3384ed9126a4a35" translate="yes" xml:space="preserve">
          <source>The intent is to squeeze as much possible information about the likely cause into the limited space of the system exit code. However, as &lt;code&gt;$!&lt;/code&gt; is the value of C's &lt;code&gt;errno&lt;/code&gt; , which can be set by any system call, this means that the value of the exit code used by &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; can be non-predictable, so should not be relied upon, other than to be non-zero.</source>
          <target state="translated">その目的は、考えられる原因に関する可能な限り多くの情報を、システム終了コードの限られたスペースに詰め込むことです。ただし、 &lt;code&gt;$!&lt;/code&gt; Cの &lt;code&gt;errno&lt;/code&gt; の値であり、システムコールで設定できます。つまり、 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; が使用する終了コードの値は予測できない可能性があるため、ゼロ以外であることを除いて、これに依存することはできません。</target>
        </trans-unit>
        <trans-unit id="2e91002a8407b92abe1904ddf5c320e2e26254c0" translate="yes" xml:space="preserve">
          <source>The interaction with the Perl compilation happens inside package &lt;code&gt;myint&lt;/code&gt; :</source>
          <target state="translated">Perlコンパイルとの相互作用は、パッケージ &lt;code&gt;myint&lt;/code&gt; 内で発生します。</target>
        </trans-unit>
        <trans-unit id="aa4116edd722cc9f90eb68f17a977fcbd1367d5c" translate="yes" xml:space="preserve">
          <source>The interactive debugger understands the following commands:</source>
          <target state="translated">対話型デバッガは以下のコマンドを理解します。</target>
        </trans-unit>
        <trans-unit id="e70d776f0381bce09991021b76dd2d122db7ce29" translate="yes" xml:space="preserve">
          <source>The interesting thing about &lt;code&gt;&amp;amp;&lt;/code&gt; is that you can generate new syntax with it, provided it's in the initial position:</source>
          <target state="translated">&lt;code&gt;&amp;amp;&lt;/code&gt; の興味深い点は、最初の位置にあれば、それを使用して新しい構文を生成できることです。</target>
        </trans-unit>
        <trans-unit id="2354b426f3be078a3ef57dbce0f8523b4f89323f" translate="yes" xml:space="preserve">
          <source>The interface defined by this module is missing some of the later additions to perl's debugging functionality. As such, this interface should be considered highly experimental and subject to change.</source>
          <target state="translated">このモジュールで定義されているインターフェイスは、perl のデバッグ機能に後から追加されたものがいくつか欠けています。そのため、このインターフェイスは非常に実験的なものであり、変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="6bc76db195856b77ae9c9e32f58ddf5271ff9965" translate="yes" xml:space="preserve">
          <source>The interface exposed by this module is very close to the current implementation of restricted hashes. Over time it is expected that this behavior will be extended and the interface abstracted further.</source>
          <target state="translated">このモジュールによって公開されるインタフェースは、制限付きハッシュの現在の実装に非常に近いものです。時間の経過とともに、この動作は拡張され、インターフェイスはさらに抽象化されることが期待されています。</target>
        </trans-unit>
        <trans-unit id="25ed6271fa2a1e00048e3f70c7ae05b81e869ba4" translate="yes" xml:space="preserve">
          <source>The interface is a bit odd because this is the result of a quick refactoring. Don't rely on it.</source>
          <target state="translated">さらっとリファクタリングした結果なので、インターフェースがちょっと変です。これに頼ってはいけません。</target>
        </trans-unit>
        <trans-unit id="86fb605133e4937943b1ba063015c9eb55c6a1c4" translate="yes" xml:space="preserve">
          <source>The interface provided by version 2 of this module should be 100% backward compatible with version 1. If you find a difference in the expected behaviour please contact the author (See &lt;a href=&quot;#AUTHOR&quot;&gt;AUTHOR&lt;/a&gt;). See &lt;a href=&quot;#GZIP-INTERFACE&quot;&gt;GZIP INTERFACE&lt;/a&gt;</source>
          <target state="translated">このモジュールのバージョン2で提供されるインターフェースは、バージョン1と100％下位互換性があるはずです。予想される動作に違いがある場合は、作成者に連絡してください（「&lt;a href=&quot;#AUTHOR&quot;&gt;AUTHOR&lt;/a&gt;」を参照）。&lt;a href=&quot;#GZIP-INTERFACE&quot;&gt;GZIPインターフェースを&lt;/a&gt;見る</target>
        </trans-unit>
        <trans-unit id="869b0eb21cd8ea8a7cd6e0d3a06abffd6a4f3e9a" translate="yes" xml:space="preserve">
          <source>The interface provides two ways to calculate digests: all-at-once, or in stages. To illustrate, the following short program computes the SHA-256 digest of &quot;hello world&quot; using each approach:</source>
          <target state="translated">インターフェイスは、ダイジェストを計算する 2 つの方法を提供しています:一気に計算する方法と、段階的に計算する方法です。説明するために、以下の短いプログラムは、それぞれの方法で「hello world」の SHA-256 ダイジェストを計算します。</target>
        </trans-unit>
        <trans-unit id="8dedf705c01e5c3576fd3717e147541ecb372f63" translate="yes" xml:space="preserve">
          <source>The internal advisory locking is implemented using Perl's flock() routine. If your system does not support any form of flock(), or if you share your files across NFS, you might wish to use other forms of locking by using modules such as LockFile::Simple which lock a file using a filesystem entry, instead of locking the file descriptor.</source>
          <target state="translated">内部アドバイザリーロックは Perl の flock()ルーチンを使用して実装されています。システムが flock()の形式をサポートしていない場合や、 NFS でファイルを共有している場合は、ファイルディスクリプタをロックするのではなく、 ファイルシステムのエントリを使用してファイルをロックする LockFile::Simple のようなモジュールを使用して、他の形式のロックを使用したいと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="798a90f8fceb3237e533c15e8087d7887afcfeb7" translate="yes" xml:space="preserve">
          <source>The internal variable for debugging support. The meanings of the various bits are subject to change, but currently indicate:</source>
          <target state="translated">デバッグサポートのための内部変数です。様々なビットの意味は変更される可能性がありますが、現在はこれを示しています。</target>
        </trans-unit>
        <trans-unit id="85c386c4c074fc2a85f669eb89082305e3dd4f12" translate="yes" xml:space="preserve">
          <source>The internals automatically clone any name with characters 128-255 but none 256+ (ie one that could be either in bytes or utf8) into a second entry which is utf8 encoded.</source>
          <target state="translated">内部では、128-255文字で256+の文字がない名前(つまり、バイトかutf8のどちらかである可能性のある名前)は、自動的にutf8エンコードされた2番目のエントリにクローンされます。</target>
        </trans-unit>
        <trans-unit id="68038f581434d0080618601485190514733606bb" translate="yes" xml:space="preserve">
          <source>The interpretation of operations and values in Perl sometimes depends on the requirements of the context around the operation or value. There are two major contexts: list and scalar. Certain operations return list values in contexts wanting a list, and scalar values otherwise. If this is true of an operation it will be mentioned in the documentation for that operation. In other words, Perl overloads certain operations based on whether the expected return value is singular or plural. Some words in English work this way, like &quot;fish&quot; and &quot;sheep&quot;.</source>
          <target state="translated">Perlにおける操作や値の解釈は、操作や値の周りのコンテキストの要件に依存することがあります。リストとスカラの2つの主要なコンテキストがあります。特定の操作は、リストを必要とするコンテキストではリスト値を返し、そうでない場合はスカラ値を返します。これがある操作に当てはまる場合は、その操作のドキュメントに記載されています。言い換えれば、Perl は、期待される戻り値が単数形か複数形かに基づいて、特定の操作をオーバーロードします。英語の単語の中には、&quot;fish &quot;や &quot;sheep &quot;のように、このように動作するものもあります。</target>
        </trans-unit>
        <trans-unit id="061664239d0f872c4965463ddd59f598a09d06f0" translate="yes" xml:space="preserve">
          <source>The interpretation of the file permission operators &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; is by default based solely on the mode of the file and the uids and gids of the user. There may be other reasons you can't actually read, write, or execute the file: for example network filesystem access controls, ACLs (access control lists), read-only filesystems, and unrecognized executable formats. Note that the use of these six specific operators to verify if some operation is possible is usually a mistake, because it may be open to race conditions.</source>
          <target state="translated">ファイル許可演算子 &lt;code&gt;-r&lt;/code&gt; 、 &lt;code&gt;-R&lt;/code&gt; 、 &lt;code&gt;-w&lt;/code&gt; 、 &lt;code&gt;-W&lt;/code&gt; 、 &lt;code&gt;-x&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; の解釈は、デフォルトでは、ファイルのモードとユーザーのuidおよびgidのみに基づいています。ファイルを実際に読み取り、書き込み、または実行できない他の理由が考えられます。たとえば、ネットワークファイルシステムのアクセス制御、ACL（アクセス制御リスト）、読み取り専用ファイルシステム、および認識されない実行可能形式です。これらの6つの特定の演算子を使用して、なんらかの操作が可能かどうかを確認することは、競合状態が発生する可能性があるため、通常は誤りです。</target>
        </trans-unit>
        <trans-unit id="de2595dbfaf95d22e9019632865663f297c76092" translate="yes" xml:space="preserve">
          <source>The interpretation of the file permission operators &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; is by default based solely on the mode of the file and the uids and gids of the user. There may be other reasons you can't actually read, write, or execute the file: for example network filesystem access controls, ACLs (access control lists), read-only filesystems, and unrecognized executable formats. Note that the use of these six specific operators to verify if some operation is possible is usually a mistake, because it may be open to race conditions.</source>
          <target state="translated">ファイル許可演算子 &lt;code&gt;-r&lt;/code&gt; 、 &lt;code&gt;-R&lt;/code&gt; 、 &lt;code&gt;-w&lt;/code&gt; 、 &lt;code&gt;-W&lt;/code&gt; 、 &lt;code&gt;-x&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; の解釈は、デフォルトでは、ファイルのモードとユーザーのuidおよびgidのみに基づいています。ファイルを実際に読み取り、書き込み、または実行できない他の理由が考えられます。たとえば、ネットワークファイルシステムのアクセス制御、ACL（アクセス制御リスト）、読み取り専用ファイルシステム、および認識されない実行可能形式です。これらの6つの特定の演算子を使用して、なんらかの操作が可能かどうかを確認することは、競合状態が発生する可能性があるため、通常は誤りです。</target>
        </trans-unit>
        <trans-unit id="c54a39a0dd2a9db45fcc8606c6b9dc540f8d071d" translate="yes" xml:space="preserve">
          <source>The inverse operation - packing byte contents from a string of hexadecimal digits - is just as easily written. For instance:</source>
          <target state="translated">16進数の文字列からバイトの内容をパッキングする逆の操作も、同じように簡単に書くことができます。例えば</target>
        </trans-unit>
        <trans-unit id="8aacdda2a613fe684f7ff0ec49be15c7f7bad342" translate="yes" xml:space="preserve">
          <source>The is the number of bytes that the Storable header occupies.</source>
          <target state="translated">Storableヘッダーが占有するバイト数です。</target>
        </trans-unit>
        <trans-unit id="e08f7fe6dcc4a4ede748bb6d3fcab7c9e89b331c" translate="yes" xml:space="preserve">
          <source>The issue of whether to pass the arguments in a hash or a hashref is largely a matter of personal style.</source>
          <target state="translated">ハッシュで議論を通すか、ハッシュリフで議論を通すかは、個人のスタイルの問題が大きいです。</target>
        </trans-unit>
        <trans-unit id="1270f1d87441c40c65f184813fb9549f6a05140e" translate="yes" xml:space="preserve">
          <source>The item you want to look up. Nested modules (such as &lt;code&gt;File::Basename&lt;/code&gt; ) are specified either as &lt;code&gt;File::Basename&lt;/code&gt; or &lt;code&gt;File/Basename&lt;/code&gt; . You may also give a descriptive name of a page, such as &lt;code&gt;perlfunc&lt;/code&gt; . For URLs, HTTP and HTTPS are the only kind currently supported.</source>
          <target state="translated">調べたいアイテム。ネストされたモジュール（ &lt;code&gt;File::Basename&lt;/code&gt; ）は、 &lt;code&gt;File::Basename&lt;/code&gt; または &lt;code&gt;File/Basename&lt;/code&gt; として指定されます。また、 &lt;code&gt;perlfunc&lt;/code&gt; などのページを説明する名前を付けることもできます。URLの場合、現在サポートされている種類はHTTPとHTTPSのみです。</target>
        </trans-unit>
        <trans-unit id="b950b023ee8eee0b58c44c704206373f4189c22c" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;&quot;~~&quot;&lt;/code&gt; allows you to override the smart matching logic used by the &lt;code&gt;~~&lt;/code&gt; operator and the switch construct (&lt;code&gt;given&lt;/code&gt; /&lt;code&gt;when&lt;/code&gt; ). See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; and &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;.</source>
          <target state="translated">キーは、 &lt;code&gt;&quot;~~&quot;&lt;/code&gt; あなたはで使用されるスマートマッチングロジック上書きすることができます &lt;code&gt;~~&lt;/code&gt; 演算子とスイッチ構築物（ &lt;code&gt;given&lt;/code&gt; / ）。&lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;perlsynのswitchステートメント&lt;/a&gt;と&lt;a href=&quot;feature&quot;&gt;機能を&lt;/a&gt;参照してください。 &lt;code&gt;when&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c40c6befa9e830eefbf95715d61be0cceba411db" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;'-X'&lt;/code&gt; is used to specify a subroutine to handle all the filetest operators (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and so on: see &lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt; for the full list); it is not possible to overload any filetest operator individually. To distinguish them, the letter following the '-' is passed as the second argument (that is, in the slot that for binary operators is used to pass the second operand).</source>
          <target state="translated">キー &lt;code&gt;'-X'&lt;/code&gt; は、すべてのファイルテスト演算子（ &lt;code&gt;-f&lt;/code&gt; 、 &lt;code&gt;-x&lt;/code&gt; など：すべてのリストについては&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;を参照）を処理するサブルーチンを指定するために使用されます。filetestオペレーターを個別にオーバーロードすることはできません。それらを区別するために、「-」に続く文字が2番目の引数として渡されます（つまり、2項演算子を渡すために二項演算子が使用されるスロットで）。</target>
        </trans-unit>
        <trans-unit id="8e57e8aa67b22950a3905dc0aca0c46d976bdaa4" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;key&lt;/code&gt; of &lt;code&gt;hv&lt;/code&gt; is deleted at the end of</source>
          <target state="translated">&lt;code&gt;hv&lt;/code&gt; のキー &lt;code&gt;key&lt;/code&gt; は最後に削除されます</target>
        </trans-unit>
        <trans-unit id="39231120b3a0f9f7321946d1dcf4e67b7cbb06d0" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;neg&lt;/code&gt; is used for unary minus to disambiguate it from binary &lt;code&gt;-&lt;/code&gt; .</source>
          <target state="translated">キー &lt;code&gt;neg&lt;/code&gt; バイナリからそれを明確にするために単項マイナスのために使用されています &lt;code&gt;-&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9af0ef3d95080a656a5a0ae273ae380c9667ee38" translate="yes" xml:space="preserve">
          <source>The key function is</source>
          <target state="translated">キー機能は</target>
        </trans-unit>
        <trans-unit id="890e53c79df507f41db3dd4d31cb915a4367afdd" translate="yes" xml:space="preserve">
          <source>The key here is the &lt;code&gt;nss_delete&lt;/code&gt; call. One workaround for this bug seems to be to create add to the file</source>
          <target state="translated">ここで重要なのは、 &lt;code&gt;nss_delete&lt;/code&gt; 呼び出しです。このバグの1つの回避策は、ファイルに追加を作成することです</target>
        </trans-unit>
        <trans-unit id="f07d5f582b98b9cdfa2323f91d8c44e6ee01e73a" translate="yes" xml:space="preserve">
          <source>The key is specified by</source>
          <target state="translated">キーは</target>
        </trans-unit>
        <trans-unit id="7a4574cc32e125230b635f70eb51279af8024135" translate="yes" xml:space="preserve">
          <source>The keys allowed in each of these pre-defined references is limited to the names used in the equivalent C structure. So, for example, the $DB_HASH reference will only allow keys called &lt;code&gt;bsize&lt;/code&gt; , &lt;code&gt;cachesize&lt;/code&gt; , &lt;code&gt;ffactor&lt;/code&gt; , &lt;code&gt;hash&lt;/code&gt; , &lt;code&gt;lorder&lt;/code&gt; and &lt;code&gt;nelem&lt;/code&gt; .</source>
          <target state="translated">これらの定義済み参照のそれぞれで許可されているキーは、対応するC構造体で使用されている名前に制限されています。したがって、たとえば、$ DB_HASHの参照のみが呼ばれるキーができます &lt;code&gt;bsize&lt;/code&gt; 、 &lt;code&gt;cachesize&lt;/code&gt; 、 &lt;code&gt;ffactor&lt;/code&gt; 、 &lt;code&gt;hash&lt;/code&gt; 、 &lt;code&gt;lorder&lt;/code&gt; と &lt;code&gt;nelem&lt;/code&gt; 個を。</target>
        </trans-unit>
        <trans-unit id="d6ed2e67811ac5de5639075023acf0cc2ec381bf" translate="yes" xml:space="preserve">
          <source>The keys in the bottom layer hash with the meanings of their values are:</source>
          <target state="translated">最下層のハッシュのキーとその値の意味は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="7d244bc64e243794d6821e1a0dcab4a24a9f05ad" translate="yes" xml:space="preserve">
          <source>The keys in the hash with the meanings of their values are:</source>
          <target state="translated">ハッシュ内のキーとその値の意味は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b936421bf8217d2a23b78502c20a19e381f28f92" translate="yes" xml:space="preserve">
          <source>The keys of &lt;code&gt;%-&lt;/code&gt; -like hashes correspond to all buffer names found in the regular expression; the keys of &lt;code&gt;%+&lt;/code&gt; -like hashes list only the names of buffers that have captured (and that are thus associated to defined values).</source>
          <target state="translated">&lt;code&gt;%-&lt;/code&gt; のようなハッシュのキーは、正規表現で見つかったすべてのバッファ名に対応します。 &lt;code&gt;%+&lt;/code&gt; のようなハッシュのキーは、キャプチャした（したがって、定義された値に関連付けられている）バッファの名前のみをリストします。</target>
        </trans-unit>
        <trans-unit id="108fc2066c755818e3590f4d9c35e36d3cb855db" translate="yes" xml:space="preserve">
          <source>The keys of the &lt;code&gt;%+&lt;/code&gt; hash list only the names of buffers that have captured (and that are thus associated to defined values).</source>
          <target state="translated">&lt;code&gt;%+&lt;/code&gt; ハッシュのキーは、キャプチャした（したがって、定義された値に関連付けられている）バッファの名前のみをリストします。</target>
        </trans-unit>
        <trans-unit id="c4094ef8d037d1a4f33eb2e2deddaec00fa1265e" translate="yes" xml:space="preserve">
          <source>The keys of the &lt;code&gt;%-&lt;/code&gt; hash correspond to all buffer names found in the regular expression.</source>
          <target state="translated">&lt;code&gt;%-&lt;/code&gt; ハッシュのキーは、正規表現で見つかったすべてのバッファ名に対応します。</target>
        </trans-unit>
        <trans-unit id="cfdae1829d96426970bd25497a8e45b42e9a79f4" translate="yes" xml:space="preserve">
          <source>The keys of the hash will be the names of the entries in the directory. Reading a value from the hash will be the result of calling &lt;code&gt;File::stat::lstat&lt;/code&gt; . Deleting an element from the hash will delete the corresponding file or subdirectory, provided that &lt;code&gt;DIR_UNLINK&lt;/code&gt; is included in the &lt;code&gt;OPTIONS&lt;/code&gt; .</source>
          <target state="translated">ハッシュのキーは、ディレクトリ内のエントリの名前になります。ハッシュから値を読み取ると、 &lt;code&gt;File::stat::lstat&lt;/code&gt; が呼び出されます。 &lt;code&gt;DIR_UNLINK&lt;/code&gt; が &lt;code&gt;OPTIONS&lt;/code&gt; に含まれている場合、ハッシュから要素を削除すると、対応するファイルまたはサブディレクトリが削除されます。</target>
        </trans-unit>
        <trans-unit id="055987f11411d4374756daa33a787f39e5c8e2e5" translate="yes" xml:space="preserve">
          <source>The keys of this hash are the names of all the known subroutines. Each value is an encoded string that has the sprintf(3) format &lt;code&gt;(&quot;%s:%d-%d&quot;, filename, fromline, toline)&lt;/code&gt; .</source>
          <target state="translated">このハッシュのキーは、すべての既知のサブルーチンの名前です。各値は、sprintf（3）形式 &lt;code&gt;(&quot;%s:%d-%d&quot;, filename, fromline, toline)&lt;/code&gt; エンコードされた文字列です。</target>
        </trans-unit>
        <trans-unit id="3904530800da7eda131d2f33bddbe47a09140ae0" translate="yes" xml:space="preserve">
          <source>The kind of computer you&amp;rsquo;re working on, where one &amp;ldquo;kind of computer&amp;rdquo; means all those computers sharing a compatible machine language. Since Perl programs are (typically) simple text files, not executable images, a Perl program is much less sensitive to the architecture it&amp;rsquo;s running on than programs in other languages, such as C, that are &lt;b&gt;compiled&lt;/b&gt; into machine code. See also &lt;b&gt;platform&lt;/b&gt; and &lt;b&gt;operating system&lt;/b&gt;.</source>
          <target state="translated">作業しているコンピューターの種類。1つの「コンピューターの種類」とは、互換性のある機械語を共有するすべてのコンピューターを意味します。Perlプログラムは（通常）実行可能なイメージではなく単純なテキストファイルであるため、Perlプログラムは、マシンコードに&lt;b&gt;コンパイル&lt;/b&gt;されるCなどの他の言語のプログラムよりも、実行されているアーキテクチャに対する感度がはるかに低くなります。&lt;b&gt;プラットフォーム&lt;/b&gt;と&lt;b&gt;オペレーティングシステム&lt;/b&gt;もご覧ください。</target>
        </trans-unit>
        <trans-unit id="af5d08a24c9445659f44e97ac90d397b8dd843c2" translate="yes" xml:space="preserve">
          <source>The known import symbols are the &lt;code&gt;:gzip_external&lt;/code&gt; , &lt;code&gt;:gzip_read_open&lt;/code&gt; , and &lt;code&gt;:gzip_write_open&lt;/code&gt; . Anything else is not recognized.</source>
          <target state="translated">既知のインポートシンボルは、 &lt;code&gt;:gzip_external&lt;/code&gt; 、 &lt;code&gt;:gzip_read_open&lt;/code&gt; 、および &lt;code&gt;:gzip_write_open&lt;/code&gt; です。それ以外は認識されません。</target>
        </trans-unit>
        <trans-unit id="9ad665994ad3405e05efc579c556de49d4423595" translate="yes" xml:space="preserve">
          <source>The label of the statement or block the OP is the start of, if any.</source>
          <target state="translated">OPが始まる文やブロックのラベルがある場合は、そのラベルが先頭になります。</target>
        </trans-unit>
        <trans-unit id="147bc8ea909cecad4fb730859bb2907f9623910d" translate="yes" xml:space="preserve">
          <source>The lack of processing of &lt;code&gt;\\&lt;/code&gt; creates specific restrictions on the post-processed text. If the delimiter is &lt;code&gt;/&lt;/code&gt;, one cannot get the combination &lt;code&gt;\/&lt;/code&gt; into the result of this step. &lt;code&gt;/&lt;/code&gt; will finish the regular expression, &lt;code&gt;\/&lt;/code&gt; will be stripped to &lt;code&gt;/&lt;/code&gt; on the previous step, and &lt;code&gt;\\/&lt;/code&gt; will be left as is. Because &lt;code&gt;/&lt;/code&gt; is equivalent to &lt;code&gt;\/&lt;/code&gt; inside a regular expression, this does not matter unless the delimiter happens to be character special to the RE engine, such as in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s*foo*bar*&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m[foo]&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;?foo?&lt;/code&gt; ; or an alphanumeric char, as in:</source>
          <target state="translated">&lt;code&gt;\\&lt;/code&gt; の処理がないと、後処理されたテキストに特定の制限が生じます。区切り文字が &lt;code&gt;/&lt;/code&gt; の場合、このステップの結果に &lt;code&gt;\/&lt;/code&gt; の組み合わせを取得できません。 &lt;code&gt;/&lt;/code&gt; は正規表現を終了し、 &lt;code&gt;\/&lt;/code&gt; は前のステップで &lt;code&gt;/&lt;/code&gt; に取り除かれ、 &lt;code&gt;\\/&lt;/code&gt; はそのままになります。 &lt;code&gt;/&lt;/code&gt; は正規表現内では &lt;code&gt;\/&lt;/code&gt; /と同等であるため、区切り文字が &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s*foo*bar*&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m[foo]&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;?foo?&lt;/code&gt; などのREエンジンに固有の文字でない限り、これは重要ではありません。 ;または、次のように英数字を使用します。</target>
        </trans-unit>
        <trans-unit id="329bfa336d3d2c69ff7cf1363d051c82b14482d1" translate="yes" xml:space="preserve">
          <source>The langinfo() function queries various locale information that can be used to localize output and user interfaces. The langinfo() requires one numeric argument that identifies the locale constant to query: if no argument is supplied, &lt;code&gt;$_&lt;/code&gt; is used. The numeric constants appropriate to be used as arguments are exportable from I18N::Langinfo.</source>
          <target state="translated">langinfo（）関数は、出力およびユーザーインターフェイスのローカライズに使用できるさまざまなロケール情報を照会します。 langinfo（）には、クエリするロケール定数を識別する1つの数値引数が必要です。引数が指定されていない場合、 &lt;code&gt;$_&lt;/code&gt; が使用されます。引数として使用するのに適した数値定数は、I18N :: Langinfoからエクスポートできます。</target>
        </trans-unit>
        <trans-unit id="4ed86afb0e8b9f19c52713fc505ca8e2e35f2532" translate="yes" xml:space="preserve">
          <source>The langinfo() is just a wrapper for the C nl_langinfo() interface.</source>
          <target state="translated">langinfo()はCのnl_langinfo()インターフェースのラッパーに過ぎません。</target>
        </trans-unit>
        <trans-unit id="5d6f822e607c368c541adb8e9be9fa017016c7dd" translate="yes" xml:space="preserve">
          <source>The language is intended to be practical (easy to use, efficient, complete) rather than beautiful (tiny, elegant, minimal). It combines (in the author's opinion, anyway) some of the best features of &lt;b&gt;sed&lt;/b&gt;, &lt;b&gt;awk&lt;/b&gt;, and &lt;b&gt;sh&lt;/b&gt;, making it familiar and easy to use for Unix users to whip up quick solutions to annoying problems. Its general-purpose programming facilities support procedural, functional, and object-oriented programming paradigms, making Perl a comfortable language for the long haul on major projects, whatever your bent.</source>
          <target state="translated">この言語は、美しく（小さく、エレガントで、ミニマル）ではなく、実用的（使いやすく、効率的、完全）であることを意図しています。とにかく（著者の意見では）&lt;b&gt;sed&lt;/b&gt;、&lt;b&gt;awk&lt;/b&gt;、および&lt;b&gt;shの&lt;/b&gt;いくつかの優れた機能を組み合わせて、UNIXユーザーが使い慣れた使いやすい方法で、迷惑な問題の迅速な解決策を考案します。その汎用プログラミング機能は、手続き型、関数型、およびオブジェクト指向のプログラミングパラダイムをサポートしているため、Perlは、大規模なプロジェクトの長期にわたる快適な言語であり、どんな目的であっても利用できます。</target>
        </trans-unit>
        <trans-unit id="80a9351ce80597f624479310f1723e625f630d11" translate="yes" xml:space="preserve">
          <source>The language is intended to be practical (easy to use, efficient, complete) rather than beautiful (tiny, elegant, minimal). Its major features are that it's easy to use, supports both procedural and object-oriented (OO) programming, has powerful built-in support for text processing, and has one of the world's most impressive collections of third-party modules.</source>
          <target state="translated">この言語は、美しい(小さな、エレガント、ミニマム)というよりも、実用的(使いやすい、効率的、完全)であることを意図しています。主な特徴は、使いやすく、手続き型とオブジェクト指向 (OO)プログラミングの両方をサポートしていること、テキスト処理の強力な組み込みサポート、世界で最も印象的なサードパーティモジュールのコレクションの1つを持っていることです。</target>
        </trans-unit>
        <trans-unit id="80efcc67009b4f458fbcd0e166207fe80337c34a" translate="yes" xml:space="preserve">
          <source>The language used is chosen from the loc_lang call. If a lookup is not possible, the i-default language will be used. If the lookup is not in the i-default language, then the key will be returned.</source>
          <target state="translated">使用される言語は loc_lang コールから選択されます。検索ができない場合は、i-default言語が使用される。検索がi-default言語でない場合は、キーが返されます。</target>
        </trans-unit>
        <trans-unit id="fba6e11da7ba55d0215680ecc246683e4db3e510" translate="yes" xml:space="preserve">
          <source>The large file compilation environment is obtained with</source>
          <target state="translated">大容量ファイルのコンパイル環境は</target>
        </trans-unit>
        <trans-unit id="7c14ad6f7057f3647ab0ef224e2d72569a519808" translate="yes" xml:space="preserve">
          <source>The largest code point that is representable in UTF-EBCDIC is U+7FFF_FFFF. If you do &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; on a larger value, a runtime error (similar to division by 0) will happen.</source>
          <target state="translated">UTF-EBCDICで表現できる最大のコードポイントはU + 7FFF_FFFFです。その場合は &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; より大きな値に、（0による除算と同様に）実行時エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="81c48ef57866e1c8154c2bdc64ad152dcbc81938" translate="yes" xml:space="preserve">
          <source>The largest code point that is representable in UTF-EBCDIC is U+7FFF_FFFF. If you try to pack a larger value into a character, a runtime error (similar to division by 0) will happen.</source>
          <target state="translated">UTF-EBCDIC で表現可能な最大のコードポイントは U+7FFF_FFFF です。これより大きな値を文字に詰め込もうとすると、実行時エラー(0による除算と同様)が発生します。</target>
        </trans-unit>
        <trans-unit id="e2cfb7719205bc05d873fbbc8977b16754d06f9e" translate="yes" xml:space="preserve">
          <source>The last &lt;b&gt;filehandle&lt;/b&gt; that was designated with &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select(FILEHANDLE)&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;STDOUT&lt;/code&gt; , if no filehandle has been selected.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select(FILEHANDLE)&lt;/a&gt;&lt;/code&gt; で指定された最後の&lt;b&gt;ファイルハンドル&lt;/b&gt;。 &lt;code&gt;STDOUT&lt;/code&gt; （ファイルハンドルが選択されていない場合）。</target>
        </trans-unit>
        <trans-unit id="544feb1340389177d3430ba94574fe7a8a59484b" translate="yes" xml:space="preserve">
          <source>The last argument is always considered to be the file portion. Since &lt;code&gt;catfile()&lt;/code&gt; uses &lt;code&gt;catdir()&lt;/code&gt; (see above) for the concatenation of the directory portions (if any), the following with regard to relative and absolute paths is true:</source>
          <target state="translated">最後の引数は常にファイル部分と見なされます。以来 &lt;code&gt;catfile()&lt;/code&gt; 使用 &lt;code&gt;catdir()&lt;/code&gt; ディレクトリ部分の連結（もしあれば）、相対および絶対パスに関して、以下が真であるため（上記を参照）。</target>
        </trans-unit>
        <trans-unit id="3d5ec4d10744144f22c4f4ea812b28436c8dedd9" translate="yes" xml:space="preserve">
          <source>The last example illustrates another feature of threads. You can spawn off several threads using the same subroutine. Each thread executes the same subroutine, but in a separate thread with a separate environment and potentially separate arguments.</source>
          <target state="translated">最後の例は、スレッドのもう一つの特徴を示しています。同じサブルーチンを使って、複数のスレッドをスポーンオフすることができます。各スレッドは同じサブルーチンを実行しますが、別の環境と別の引数を持つ別のスレッドで実行します。</target>
        </trans-unit>
        <trans-unit id="3a9ec3805e1d8d03ada9f35c7b038f53ba566eb8" translate="yes" xml:space="preserve">
          <source>The last example is very slow and outputs extra progress indicators that break the alignment of the result.</source>
          <target state="translated">最後の例は非常に遅く、結果の整合性を崩す余分な進捗指標を出力します。</target>
        </trans-unit>
        <trans-unit id="d7140144abdabb3a340f6e7a9626f45a3f6e90a9" translate="yes" xml:space="preserve">
          <source>The last example points out that character classes are like alternations of characters. At a given character position, the first alternative that allows the regexp match to succeed will be the one that matches.</source>
          <target state="translated">最後の例は、文字クラスが文字の交互配列のようなものであることを指摘しています。与えられた文字位置では、正規表現のマッチを成功させる最初の選択肢がマッチするものになります。</target>
        </trans-unit>
        <trans-unit id="8ff092050a74224fa6cfcc69192829226bfd39ef" translate="yes" xml:space="preserve">
          <source>The last example should print:</source>
          <target state="translated">最後の例が印刷されるはずです。</target>
        </trans-unit>
        <trans-unit id="d1b1f35817845b0ebf71ac4a0203b5b76bf2839d" translate="yes" xml:space="preserve">
          <source>The last example shows a match with an &lt;code&gt;'i'&lt;/code&gt;&lt;b&gt;modifier&lt;/b&gt;, which makes the match case-insensitive.</source>
          <target state="translated">最後の例は、 &lt;code&gt;'i'&lt;/code&gt; &lt;b&gt;修飾子&lt;/b&gt;を使用した一致を示しています。これにより、大文字と小文字が区別されなくなります。</target>
        </trans-unit>
        <trans-unit id="e71d02e5faff1a1d5185411ef0df70f32d8f6d20" translate="yes" xml:space="preserve">
          <source>The last example shows that &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; can use other delimiters, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt;, and even &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt;. If single quotes are used &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt;, then the regex and replacement are treated as single-quoted strings.</source>
          <target state="translated">最後の例は、 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; などの他の区切り文字を使用できることを示しています!!! および &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt; 、さらには &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt; 。単一引用符が &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; として使用されている場合、正規表現と置換は単一引用符付きの文字列として扱われます。</target>
        </trans-unit>
        <trans-unit id="38175234fbd8da1fcb9cc33577b554c9cf1a8cdf" translate="yes" xml:space="preserve">
          <source>The last four modifiers listed above, added in Perl 5.14, control the character set rules, but &lt;code&gt;/a&lt;/code&gt; is the only one you are likely to want to specify explicitly; the other three are selected automatically by various pragmas.</source>
          <target state="translated">上記の最後の4つの修飾子はPerl 5.14で追加され、文字セットルールを制御しますが、 &lt;code&gt;/a&lt;/code&gt; は明示的に指定する可能性が高い唯一の修飾子です。他の3つは、さまざまなプラグマによって自動的に選択されます。</target>
        </trans-unit>
        <trans-unit id="5b14495e6536f39321b81d2ad45a9b35a4c183b7" translate="yes" xml:space="preserve">
          <source>The last is particularly useful because it knows about machine-dependent architectures. The &lt;code&gt;lib.pm&lt;/code&gt; pragmatic module was first included with the 5.002 release of Perl.</source>
          <target state="translated">最後のものは、マシンに依存するアーキテクチャーを知っているため、特に便利です。 &lt;code&gt;lib.pm&lt;/code&gt; 実用的なモジュールは、最初のPerlの5.002リリースに含まれていました。</target>
        </trans-unit>
        <trans-unit id="dee33a8bbee7fed8c390da45a40b2881511f80ec" translate="yes" xml:space="preserve">
          <source>The last item listed (SUNWhea in this example) is the package you need.</source>
          <target state="translated">最後に記載されている項目(この例ではSUNWhea)が必要なパッケージです。</target>
        </trans-unit>
        <trans-unit id="01f01afddbe80c4c268f0bac95652fd735743f86" translate="yes" xml:space="preserve">
          <source>The last rites performed by a parent &lt;b&gt;process&lt;/b&gt; on behalf of a deceased child process so that it doesn&amp;rsquo;t remain a &lt;b&gt;zombie&lt;/b&gt;. See the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; function calls.</source>
          <target state="translated">&lt;b&gt;ゾンビに&lt;/b&gt;ならないように、亡くなった子プロセスの代わりに親&lt;b&gt;プロセス&lt;/b&gt;によって実行された最後の儀式。 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; 関数呼び出しを参照してください。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6fc5a9dc56cbe77d2375a5e43361dd33676d7edc" translate="yes" xml:space="preserve">
          <source>The last three slots are a recent addition, and for source code compatibility they are only checked for if one of the three flags MGf_COPY, MGf_DUP or MGf_LOCAL is set in mg_flags. This means that most code can continue declaring a vtable as a 5-element value. These three are currently used exclusively by the threading code, and are highly subject to change.</source>
          <target state="translated">最後の 3 つのスロットは最近追加されたもので、ソースコードの互換性を保つために、MGf、MGf_DUP、MGf_LOCAL の 3 つのフラグのいずれかが mg_flags に設定されている場合にのみチェックされます。これは、ほとんどのコードが vtable を 5 要素値として宣言し続けることができることを意味します。これら3つのフラグは、現在のところスレッディングコードでのみ使用されており、変更される可能性が高いです。</target>
        </trans-unit>
        <trans-unit id="0f2130944a7df2b125d5d6b5739b2f67242c3907" translate="yes" xml:space="preserve">
          <source>The last time the test program passed, in seconds from the epoch.</source>
          <target state="translated">テストプログラムが最後に通過したのは、エポックから数秒後のことです。</target>
        </trans-unit>
        <trans-unit id="21878c9b3f2934bab56f2ab1ab4a5f355bfffef3" translate="yes" xml:space="preserve">
          <source>The last time the test suite failed, in seconds from the epoch.</source>
          <target state="translated">テストスイートが最後に失敗した時のエポックからの秒数です。</target>
        </trans-unit>
        <trans-unit id="c8d2323b355b183370e8260c625d724458199602" translate="yes" xml:space="preserve">
          <source>The last topic of Part 1 briefly covers how regexps are used in Perl programs. Where do they fit into Perl syntax?</source>
          <target state="translated">パート1の最後のトピックでは、Perlプログラムで正規表現がどのように使われているかを簡単に説明します。正規表現はPerlの構文の中でどのように使われているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="b9c1bf499a546862f7d3dd462a65d36e8e01021a" translate="yes" xml:space="preserve">
          <source>The last two are a little tricky. In &lt;code&gt;[\$x]&lt;/code&gt; , the backslash protects the dollar sign, so the character class has two members &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; . In &lt;code&gt;[\\$x]&lt;/code&gt; , the backslash is protected, so &lt;code&gt;$x&lt;/code&gt; is treated as a variable and substituted in double quote fashion.</source>
          <target state="translated">最後の2つは少し注意が必要です。で &lt;code&gt;[\$x]&lt;/code&gt; 文字クラスは、二つの部材があるので、バックスラッシュは、ドル記号を保護 &lt;code&gt;$&lt;/code&gt; と &lt;code&gt;x&lt;/code&gt; 。で &lt;code&gt;[\\$x]&lt;/code&gt; 、バックスラッシュが保護されているので、 &lt;code&gt;$x&lt;/code&gt; 変数として扱われ、二重引用符の様式で置換されています。</target>
        </trans-unit>
        <trans-unit id="8a00c9f7ecacbf4d6fa87dfc5eecfd61397b17fd" translate="yes" xml:space="preserve">
          <source>The last two constructs may appear unintuitive to most people. The first repeatedly grows a string, whereas the second allocates a large chunk of memory in one go. On some systems, the second is more efficient than the first.</source>
          <target state="translated">最後の2つの構造は、ほとんどの人には直感的ではないように見えるかもしれません。前者は文字列を繰り返し成長させますが、後者は一度に大量のメモリを確保します。システムによっては、2 番目の方が 1 番目よりも効率が良い場合もあります。</target>
        </trans-unit>
        <trans-unit id="7a3180c758450e8b48f9775fac7e74a8e6da633b" translate="yes" xml:space="preserve">
          <source>The last two examples in each block show the pipe as &quot;list form&quot;, which is not yet supported on all platforms. A good rule of thumb is that if your platform has a real &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; (in other words, if your platform is Unix, including Linux and MacOS X), you can use the list form. You would want to use the list form of the pipe so you can pass literal arguments to the command without risk of the shell interpreting any shell metacharacters in them. However, this also bars you from opening pipes to commands that intentionally contain shell metacharacters, such as:</source>
          <target state="translated">各ブロックの最後の2つの例は、パイプを「リスト形式」として示していますが、これはまだすべてのプラットフォームでサポートされているわけではありません。おおまかな目安としては、プラットフォームに本当の &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; がある場合（つまり、プラットフォームがLinuxやMacOS Xを含むUnixの場合）、リスト形式を使用できます。パイプのリスト形式を使用すると、シェルがシェルのメタ文字を解釈するリスクなしに、コマンドにリテラル引数を渡すことができます。ただし、これにより、パイプを開くことから、次のようなシェルのメタ文字を意図的に含むコマンドにアクセスできなくなります。</target>
        </trans-unit>
        <trans-unit id="224277da0631dd2948d98eac0e58b508ae236071" translate="yes" xml:space="preserve">
          <source>The last two examples in each block show the pipe as &quot;list form&quot;, which is not yet supported on all platforms. A good rule of thumb is that if your platform has a real &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; (in other words, if your platform is Unix, including Linux and MacOS X), you can use the list form. You would want to use the list form of the pipe so you can pass literal arguments to the command without risk of the shell interpreting any shell metacharacters in them. However, this also bars you from opening pipes to commands that intentionally contain shell metacharacters, such as:</source>
          <target state="translated">各ブロックの最後の2つの例は、パイプを「リスト形式」として示していますが、これはまだすべてのプラットフォームでサポートされているわけではありません。おおまかな目安としては、プラットフォームに本当の &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; がある場合（つまり、プラットフォームがLinuxやMacOS Xを含むUnixの場合）、リスト形式を使用できます。パイプのリスト形式を使用すると、シェルがシェルのメタ文字を解釈するリスクなしに、コマンドにリテラル引数を渡すことができます。ただし、これにより、パイプを開くことから、次のようなシェルのメタ文字を意図的に含むコマンドにアクセスできなくなります。</target>
        </trans-unit>
        <trans-unit id="bb538ba5316dfdb33cebda21455c3214d556eb70" translate="yes" xml:space="preserve">
          <source>The last two were added in Perl 5.22.</source>
          <target state="translated">最後の2つはPerl 5.22で追加されました。</target>
        </trans-unit>
        <trans-unit id="ea40dd6a00c5982372bccbdaaeeb63948e0cf1b4" translate="yes" xml:space="preserve">
          <source>The later gives you some idea of what failed. It also makes it easier to find the test in your script, simply search for &quot;simple exponential&quot;.</source>
          <target state="translated">後者の方が、何が失敗したのかのヒントが得られます。また、スクリプトの中でテストを見つけるのが簡単になります。</target>
        </trans-unit>
        <trans-unit id="263e6dbf8c2da6cc4831ea57d73cd01c49808e34" translate="yes" xml:space="preserve">
          <source>The latest</source>
          <target state="translated">最新の</target>
        </trans-unit>
        <trans-unit id="d3a60275112428b3ca0987c2c55a45bca5bde073" translate="yes" xml:space="preserve">
          <source>The latest Net::Ping release can be found at CPAN:</source>
          <target state="translated">Net::Ping の最新リリースは CPAN で確認できます。</target>
        </trans-unit>
        <trans-unit id="874b36774125604150e5f59fd5253e7e8be8da9e" translate="yes" xml:space="preserve">
          <source>The latest Perl release (5.22.0 as of this writing) builds without changes under all versions of Mac OS X from 10.3 &quot;Panther&quot; onwards.</source>
          <target state="translated">最新のPerlリリース(5.22.0)は、10.3 &quot;Panther &quot;以降のMac OS Xのすべてのバージョンで変更なくビルドされます。</target>
        </trans-unit>
        <trans-unit id="abc4f25838809cd7645317e2cc9e7753babbc628" translate="yes" xml:space="preserve">
          <source>The latest source tree is available via cvs:</source>
          <target state="translated">最新のソースツリーは cvs から入手できます.</target>
        </trans-unit>
        <trans-unit id="bf89850a166f6a4ee0978de00ea5e89c74558d84" translate="yes" xml:space="preserve">
          <source>The latest versions are probably the least deployed and widely tested, so you may want to wait a few months after their release and see what problems others have if you are risk averse.</source>
          <target state="translated">最新バージョンはおそらく最も配備が少なく、広くテストされているので、リリース後数ヶ月待って、リスクを嫌う人は他の人がどのような問題を抱えているかを見てみるといいかもしれません。</target>
        </trans-unit>
        <trans-unit id="283b07d7f4b68277645e0b52df897e2c505c20d3" translate="yes" xml:space="preserve">
          <source>The latest versions of perl have more bug fixes.</source>
          <target state="translated">perlの最新バージョンでは、より多くのバグフィックスが行われています。</target>
        </trans-unit>
        <trans-unit id="d373e425dea350cf42b44329f2372765cae74bb5" translate="yes" xml:space="preserve">
          <source>The latter pattern would be a character class consisting of a colon, and the letters &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt; .</source>
          <target state="translated">後者のパターンは、コロンと文字 &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;l&lt;/code&gt; 、 &lt;code&gt;p&lt;/code&gt; および &lt;code&gt;h&lt;/code&gt; で構成される文字クラスになります。</target>
        </trans-unit>
        <trans-unit id="6a94f6519fd2ea2b5da884bb4c80f8058226b090" translate="yes" xml:space="preserve">
          <source>The layer is acceptable to have in a binmode(FH) stack - i.e. it does not (or will configure itself not to) transform bytes passing through it.</source>
          <target state="translated">そのレイヤは binmode(FH)スタックの中にあっても構いません-つまり、そのレイヤはそれを通過するバイトを変換しません (あるいは変換しないように自分自身を設定します)。</target>
        </trans-unit>
        <trans-unit id="1281105f1d2923419cef70eff9c7bbaca9c31ca4" translate="yes" xml:space="preserve">
          <source>The layer is buffered.</source>
          <target state="translated">レイヤーはバッファリングされています。</target>
        </trans-unit>
        <trans-unit id="d2977795d28c25d6eee9e0faa6c0a67b12612914" translate="yes" xml:space="preserve">
          <source>The layers are returned in the order an open() or binmode() call would use them. Note that the &quot;default stack&quot; depends on the operating system and on the Perl version, and both the compile-time and runtime configurations of Perl.</source>
          <target state="translated">レイヤは、open()やbinmode()の呼び出しがそれらを使用する順番で返されます。デフォルトのスタック」は、オペレーティングシステムとPerlのバージョン、Perlのコンパイル時と実行時の設定の両方に依存することに注意してください。</target>
        </trans-unit>
        <trans-unit id="b3e7d5b78b27ea298f2a1cae1408ae86359ba800" translate="yes" xml:space="preserve">
          <source>The lddlflags addition is the only abnormal bit.</source>
          <target state="translated">lddlflagsの加算が唯一の異常ビットです。</target>
        </trans-unit>
        <trans-unit id="eff5a5e9eacb7b6806eb625ddd8923ff29d2efc5" translate="yes" xml:space="preserve">
          <source>The leading &lt;code&gt;+{&lt;/code&gt; and &lt;code&gt;{;&lt;/code&gt; always serve to disambiguate the expression to mean either the HASH reference, or the BLOCK.</source>
          <target state="translated">先頭の &lt;code&gt;+{&lt;/code&gt; および &lt;code&gt;{;&lt;/code&gt; 常にHASH参照またはBLOCKのいずれかを意味する表現を明確にするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="d4369969cfc835357a0f9f590f26252ba7f58c0e" translate="yes" xml:space="preserve">
          <source>The left hand side of the method invocation (or arrow) operator is the object (or class name), and the right hand side is the method name.</source>
          <target state="translated">メソッド呼び出し(または矢印)演算子の左側がオブジェクト(またはクラス名)、右側がメソッド名です。</target>
        </trans-unit>
        <trans-unit id="2a9cac37843dad5a4ff70fbd9f8ea25d75266dcb" translate="yes" xml:space="preserve">
          <source>The left side of the arrow can be any expression returning a reference, including a previous dereference. Note that &lt;code&gt;$array[$x]&lt;/code&gt; is</source>
          <target state="translated">矢印の左側は、以前の逆参照を含め、参照を返す任意の式にすることができます。ことを注意 &lt;code&gt;$array[$x]&lt;/code&gt; あります</target>
        </trans-unit>
        <trans-unit id="eb221cc92a9038eecac3c016886c94b3bdd80217" translate="yes" xml:space="preserve">
          <source>The left-hand character up there indicates the context in which the function was called, with &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; meaning scalar or list contexts respectively, and &lt;code&gt;.&lt;/code&gt; meaning void context (which is actually a sort of scalar context). The display above says that you were in the function &lt;code&gt;main::infested&lt;/code&gt; when you ran the stack dump, and that it was called in scalar context from line 10 of the file</source>
          <target state="translated">左上の文字は、関数が呼び出されたコンテキストを示します。 &lt;code&gt;$&lt;/code&gt; と &lt;code&gt;@&lt;/code&gt; は、それぞれスカラーまたはリストコンテキストを意味し &lt;code&gt;.&lt;/code&gt; voidコンテキストを意味します（実際には一種のスカラーコンテキストです）。上の表示は、スタックダンプを実行したときに関数 &lt;code&gt;main::infested&lt;/code&gt; にいたこと、およびファイルの行10からスカラーコンテキストで呼び出されたことを示しています。</target>
        </trans-unit>
        <trans-unit id="d8cc674eda9906f58ae8371f8d5de07f046d9b51" translate="yes" xml:space="preserve">
          <source>The leftmost delimiter beginning the argument text to the interior sequence (should be &quot;&amp;lt;&quot;).</source>
          <target state="translated">引数テキストを開始し、内部シーケンスへの左端の区切り文字（ &quot;&amp;lt;&quot;である必要があります）。</target>
        </trans-unit>
        <trans-unit id="b2f9e2e6c56a351b6a88108f75341c9d329b9f6c" translate="yes" xml:space="preserve">
          <source>The length at which the argument list is truncated is governed by the next option:</source>
          <target state="translated">引数リストが切り捨てられる長さは、次のオプションによって決まります。</target>
        </trans-unit>
        <trans-unit id="0c237bc1e8c7da08e4bc9cf58175d51b2735fd6c" translate="yes" xml:space="preserve">
          <source>The length of an array is a scalar value. You may find the length of array @days by evaluating &lt;code&gt;$#days&lt;/code&gt; , as in &lt;b&gt;csh&lt;/b&gt;. However, this isn't the length of the array; it's the subscript of the last element, which is a different value since there is ordinarily a 0th element. Assigning to &lt;code&gt;$#days&lt;/code&gt; actually changes the length of the array. Shortening an array this way destroys intervening values. Lengthening an array that was previously shortened does not recover values that were in those elements.</source>
          <target state="translated">配列の長さはスカラー値です。&lt;b&gt;cshの&lt;/b&gt;ように &lt;code&gt;$#days&lt;/code&gt; を評価すると、配列@daysの長さがわかります。ただし、これは配列の長さではありません。これは最後の要素の添え字であり、通常は0番目の要素があるため、異なる値です。 &lt;code&gt;$#days&lt;/code&gt; に割り当てると、実際には配列の長さが変更されます。この方法で配列を短くすると、間にある値が破壊されます。以前に短縮された配列を長くしても、それらの要素にあった値は復元されません。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b1ef5c234e3b75bc352e3b032ce59b9fa1929612" translate="yes" xml:space="preserve">
          <source>The length of the field is supplied by padding out the field with multiple &quot;&amp;lt;&quot;, &quot;&amp;gt;&quot;, or &quot;|&quot; characters to specify a non-numeric field with, respectively, left justification, right justification, or centering. For a regular field, the value (up to the first newline) is taken and printed according to the selected justification, truncating excess characters. If you terminate a text field with &quot;...&quot;, three dots will be shown if the value is truncated. A special text field may be used to do rudimentary multi-line text block filling; see &lt;a href=&quot;#Using-Fill-Mode&quot;&gt;Using Fill Mode&lt;/a&gt; for details.</source>
          <target state="translated">フィールドの長さは、複数の「&amp;lt;」、「&amp;gt;」、または「|」でフィールドを埋め込むことによって提供されます。左揃え、右揃え、または中央揃えでそれぞれ非数値フィールドを指定する文字。通常のフィールドの場合、値（最初の改行まで）が取得され、選択された位置合わせに従って印刷され、余分な文字は切り捨てられます。テキストフィールドを「...」で終了する場合、値が切り捨てられると3つのドットが表示されます。特別なテキストフィールドを使用して、基本的な複数行のテキストブロックを埋めることができます。詳細については、&lt;a href=&quot;#Using-Fill-Mode&quot;&gt;塗りつぶしモードの使用を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="01b66a1a14f6dce4bff1a210ef4e586716a5899b" translate="yes" xml:space="preserve">
          <source>The length of the name.</source>
          <target state="translated">名前の長さ。</target>
        </trans-unit>
        <trans-unit id="696a9e70beeee9b566eace1cd87208a1d5c5089e" translate="yes" xml:space="preserve">
          <source>The length(NAME) Keyword</source>
          <target state="translated">長さ(NAME)キーワード</target>
        </trans-unit>
        <trans-unit id="b958bd03a02b517c3d184dfcfbefe403cc86c37f" translate="yes" xml:space="preserve">
          <source>The level can be changed as follows:</source>
          <target state="translated">レベルは以下のように変更することができます。</target>
        </trans-unit>
        <trans-unit id="64e6e89b4814ce7405192ddfc665d5e521c03538" translate="yes" xml:space="preserve">
          <source>The level constants are not exported by the module.</source>
          <target state="translated">レベル定数はモジュールによってエクスポートされません。</target>
        </trans-unit>
        <trans-unit id="b4c1d901146534759d309f43fe1b8efda46ffa76" translate="yes" xml:space="preserve">
          <source>The level of detail in Perl module documentation generally goes from less detailed to more detailed. Your SYNOPSIS section should contain a minimal example of use (perhaps as little as one line of code; skip the unusual use cases or anything not needed by most users); the DESCRIPTION should describe your module in broad terms, generally in just a few paragraphs; more detail of the module's routines or methods, lengthy code examples, or other in-depth material should be given in subsequent sections.</source>
          <target state="translated">Perl モジュールのドキュメントの詳細レベルは、一般的に詳細ではないものから詳細なものへと変化していきます。SYNOPSIS セクションには最小限の使用例 (たぶん 1 行のコードでもよいでしょう。珍しい使用例やほとんどのユーザが必要としないものは省略してください)を含めるべきです。 DESCRIPTION セクションでは、一般的に数パラグラフでモジュールを大まかに説明し、モジュールのルーチンやメソッドの詳細、長いコード例、その他の詳細な資料は後続のセクションで提供するべきです。</target>
        </trans-unit>
        <trans-unit id="0ce002d9483143d05cc2ba45ea1b81cd48bfc336" translate="yes" xml:space="preserve">
          <source>The lexer can be bypassed as well by creating the pattern from smaller components:</source>
          <target state="translated">小さなコンポーネントからパターンを作成することで、レキサーをバイパスすることもできます。</target>
        </trans-unit>
        <trans-unit id="23265d5a0661d902031b21a8d3925278347efe2b" translate="yes" xml:space="preserve">
          <source>The lexer maintains various &lt;code&gt;char*&lt;/code&gt; pointers to things in the &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; buffer. If &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; is ever reallocated, all of these pointers must be updated. Don't attempt to do this manually, but rather use &lt;a href=&quot;#lex_grow_linestr&quot;&gt;lex_grow_linestr&lt;/a&gt; if you need to reallocate the buffer.</source>
          <target state="translated">レクサーは、 &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; バッファーにあるものへのさまざまな &lt;code&gt;char*&lt;/code&gt; ポインターを維持します。場合 &lt;code&gt;PL_parser-&amp;gt;linestr&lt;/code&gt; が今までに再割り当てされ、これらのポインタのすべてを更新する必要があります。これを手動で行わないでください。バッファーを再割り当てする必要がある場合は、&lt;a href=&quot;#lex_grow_linestr&quot;&gt;lex_grow_linestrを&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="1ed189d83743aeda186a080785030258aac3dd09" translate="yes" xml:space="preserve">
          <source>The libnetcfg utility can be used to configure the libnet. Starting from perl 5.8 libnet is part of the standard Perl distribution, but the libnetcfg can be used for any libnet installation.</source>
          <target state="translated">libnetcfg ユーティリティは libnet の設定に使用できます。perl 5.8 以降の libnet は標準の Perl ディストリビューションの一部ですが、libnetcfg はどの libnet のインストールにも使用できます。</target>
        </trans-unit>
        <trans-unit id="b7cb7266f690af0bb383573e50d303e552d377e1" translate="yes" xml:space="preserve">
          <source>The libraries specified may be a mixture of static libraries and import libraries (to link with DLLs). Since both kinds are used pretty transparently on the Win32 platform, we do not attempt to distinguish between them.</source>
          <target state="translated">指定されたライブラリは、静的ライブラリとインポートライブラリ(DLLとリンクするための)の混合物かもしれません。どちらの種類もWin32プラットフォーム上では透過的に使用されているので、両者を区別することは試みていません。</target>
        </trans-unit>
        <trans-unit id="c99e76c717b720c6c49420484756d2dfcd410c40" translate="yes" xml:space="preserve">
          <source>The library that is loaded last will be used. Note that this can be overwritten at any time by loading a different library, and numbers constructed with different libraries cannot be used in math operations together.</source>
          <target state="translated">最後に読み込まれたライブラリが使用されます。これは別のライブラリを読み込むことでいつでも上書きすることができ、異なるライブラリで構築された数値を数学演算で一緒に使用することはできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="7be37c25dc5d34ce7bba6cfdf56923967183a419" translate="yes" xml:space="preserve">
          <source>The licensing terms of your distribution. Generally it's &quot;perl_5&quot; for the same license as Perl itself.</source>
          <target state="translated">ディストリビューションのライセンス条項。一般的にはPerl自身と同じライセンスである &quot;perl_5 &quot;です。</target>
        </trans-unit>
        <trans-unit id="ee54e36e284ff26a979d2076f6ca4023c3d73825" translate="yes" xml:space="preserve">
          <source>The line above describes the limits of buckets currently in use. Each bucket has two sizes: memory footprint and the maximal size of user data that can fit into this bucket. Suppose in the above example that the smallest bucket were size 4. The biggest bucket would have usable size 8188, and the memory footprint would be 8192.</source>
          <target state="translated">上の行では、現在使用されているバケットの限界を説明しています。各バケットには2つのサイズがあります:メモリフットプリントと、このバケットに収まることができるユーザーデータの最大サイズです。上記の例では、最小のバケットのサイズが4だったとします。最大のバケットは使用可能なサイズが 8188 で、メモリフットプリントは 8192 となります。</target>
        </trans-unit>
        <trans-unit id="ac97bcd51055b69e1b4470987fa154b899ce651a" translate="yes" xml:space="preserve">
          <source>The line number the error occurred in.</source>
          <target state="translated">エラーが発生した行番号。</target>
        </trans-unit>
        <trans-unit id="cc23ac8e14569b4b19694084670492ce2aa4a0c6" translate="yes" xml:space="preserve">
          <source>The line shown is the one that is about to be executed &lt;b&gt;next&lt;/b&gt;, it hasn't happened yet. So while we can print a variable with the letter '&lt;b&gt;p&lt;/b&gt;', at this point all we'd get is an empty (undefined) value back. What we need to do is to step through the next executable statement with an '&lt;b&gt;s&lt;/b&gt;':</source>
          <target state="translated">表示されている行は、&lt;b&gt;次に&lt;/b&gt;実行される行ですが、まだ実行されていません。したがって、文字 ' &lt;b&gt;p&lt;/b&gt; 'を使用して変数を出力できますが、この時点で取得できるのは空の（未定義の）値だけです。私たちがする必要があるのは、 ' &lt;b&gt;s&lt;/b&gt; ' で次の実行可能なステートメントをステップ実行することです：</target>
        </trans-unit>
        <trans-unit id="e54713c2cd710c76f4d69536879402921ef82d04" translate="yes" xml:space="preserve">
          <source>The linearized MRO of a class is an ordered array of all of the classes one would search when resolving a method on that class, starting with the class itself.</source>
          <target state="translated">クラスの線形化された MRO は、そのクラスのメソッドを解決する際に検索するすべてのクラスの順序付き配列です。</target>
        </trans-unit>
        <trans-unit id="f96ce0004635ab8058e21a997ff0fdcac4680ebd" translate="yes" xml:space="preserve">
          <source>The link found cannot be parsed because it does not conform to the syntax described in &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;.</source>
          <target state="translated">見つかったリンクは、&lt;a href=&quot;../perlpod&quot;&gt;perlpodで&lt;/a&gt;説明されている構文に準拠していないため、解析できません。</target>
        </trans-unit>
        <trans-unit id="365c0989adb3aa2936b9a9b37c715ae0175f622e" translate="yes" xml:space="preserve">
          <source>The link-text. If there is none, this must be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. (E.g., in &quot;L&amp;lt;Perl Functions|perlfunc&amp;gt;&quot;, the link-text is &quot;Perl Functions&quot;. In &quot;L&amp;lt;Time::HiRes&amp;gt;&quot; and even &quot;L&amp;lt;|Time::HiRes&amp;gt;&quot;, there is no link text. Note that link text may contain formatting.)</source>
          <target state="translated">リンクテキスト。ない場合、これは &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; でなければなりません。（たとえば、「L &amp;lt;Perl関数| perlfunc&amp;gt;」では、リンクテキストは「Perl関数」です。「L &amp;lt;Time :: HiRes&amp;gt;」や「L &amp;lt;| Time :: HiRes&amp;gt;」でも、リンクテキスト。リンクテキストには書式が含まれている場合があります。）</target>
        </trans-unit>
        <trans-unit id="d43c6585f184d3f50d1ee9b3f3e7c9226f529c8c" translate="yes" xml:space="preserve">
          <source>The list becomes the default for</source>
          <target state="translated">のデフォルトのリストになります。</target>
        </trans-unit>
        <trans-unit id="3deb5bdbb77dae94d3dcc1cd91998f32e0e38f14" translate="yes" xml:space="preserve">
          <source>The list in the second argument means:</source>
          <target state="translated">第二引数のリストが意味します。</target>
        </trans-unit>
        <trans-unit id="e1406e4b9186eac7ca74cdee5b539fc3d6f09c6c" translate="yes" xml:space="preserve">
          <source>The list may well be incomplete, or even wrong in some places. When in doubt, consult the platform-specific README files in the Perl source distribution, and any other documentation resources accompanying a given port.</source>
          <target state="translated">このリストは不完全であるかもしれませんし、場所によっては間違っているかもしれません。疑問がある場合は、Perl のソース・ディストリビューションにあるプラットフォーム固有の README ファイルや、指定されたポートに付随するその他のドキュメント・リソースを参照してください。</target>
        </trans-unit>
        <trans-unit id="47c47cf18ff1538b7e1e7d5d97838485842b3427" translate="yes" xml:space="preserve">
          <source>The list of &lt;b&gt;directories&lt;/b&gt; the system searches to find a program you want to &lt;b&gt;execute&lt;/b&gt;. The list is stored as one of your &lt;b&gt;environment variables&lt;/b&gt;, accessible in Perl as &lt;code&gt;$ENV{PATH}&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;実行する&lt;/b&gt;プログラムを見つけるためにシステムが検索する&lt;b&gt;ディレクトリ&lt;/b&gt;のリスト。リストは&lt;b&gt;環境変数の&lt;/b&gt; 1つとして保存され、Perlで &lt;code&gt;$ENV{PATH}&lt;/code&gt; としてアクセスできます。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="880294bb5af5ca3525238395f901655f64c2020a" translate="yes" xml:space="preserve">
          <source>The list of functions supported by this module.</source>
          <target state="translated">このモジュールがサポートする関数のリスト。</target>
        </trans-unit>
        <trans-unit id="77160ea4e8b3bcdfb5681dd2b39ffff26dc948b8" translate="yes" xml:space="preserve">
          <source>The list of functions that will need to recompiled is: creat, fgetpos, fopen, freopen, fsetpos, fstat, fstatvfs, fstatvfsdev, ftruncate, ftw, lockf, lseek, lstat, mmap, nftw, open, prealloc, stat, statvfs, statvfsdev, tmpfile, truncate, getrlimit, setrlimit</source>
          <target state="translated">再コンパイルが必要な関数のリストは以下の通りです:creat,fgetpos,fopen,freopen,fsetpos,fstat,fstatvfs,fstatvfsdev,ftruncate,ftw,lockf,lseek,lstat,mmap,nftw,open,prealloc,stat,statvfs,statvfsdev,tmpfile,truncate,getrlimit,setrlimit</target>
        </trans-unit>
        <trans-unit id="0ece79552d7d2f7d04e0b952118b609964429027" translate="yes" xml:space="preserve">
          <source>The list of libraries needed by Perl only (any libraries needed by extensions only will by dropped, if using dynamic loading).</source>
          <target state="translated">Perlのみが必要とするライブラリのリスト(ダイナミックロードを使用している場合は、拡張機能のみが必要なライブラリはすべて削除されます)。</target>
        </trans-unit>
        <trans-unit id="e64ca6ece649f2cd25525c8ae9c0d312fa7bfc44" translate="yes" xml:space="preserve">
          <source>The list of moderators will be public knowledge. At present, it is: Aaron Crane, Andy Dougherty, Ricardo Signes, Steffen M&amp;uuml;ller.</source>
          <target state="translated">モデレーターのリストは公開されます。現在のところ、アーロンクレーン、アンディドハティ、リカルドサイン、ステフェンミュラーです。</target>
        </trans-unit>
        <trans-unit id="1addfaddfdb521f7b3277e8c72cb79cc08f13e02" translate="yes" xml:space="preserve">
          <source>The list of output parameters occurs at the very end of the function, just after the OUTPUT: directive. The use of RETVAL tells Perl that you wish to send this value back as the return value of the XSUB function. In Example 3, we wanted the &quot;return value&quot; placed in the original variable which we passed in, so we listed it (and not RETVAL) in the OUTPUT: section.</source>
          <target state="translated">出力パラメータのリストは、関数の最後、OUTPUT:ディレクティブのすぐ後にあります。RETVALの使用は、XSUB関数の戻り値としてこの値を送り返したいことをPerlに伝えます。例3では、&quot;戻り値 &quot;を元の変数に入れたいので、OUTPUT:セクションにリストアップしています(RETVALではなく)。</target>
        </trans-unit>
        <trans-unit id="2539fe270e83e959d35fc853744365007ae544d9" translate="yes" xml:space="preserve">
          <source>The list of subfields can be supplied in any of the following formats</source>
          <target state="translated">サブフィールドのリストは、以下のいずれかの形式で提供することができます。</target>
        </trans-unit>
        <trans-unit id="cbcba41fba02d24fea6ac236d8112cd5b98ebb87" translate="yes" xml:space="preserve">
          <source>The list of the registered CPAN sites follows. Please note that the sorting order is alphabetical on fields:</source>
          <target state="translated">登録されているCPANサイトの一覧は以下の通りです。フィールドの並び順はアルファベット順になっていますのでご注意ください。</target>
        </trans-unit>
        <trans-unit id="e411ef2006039baaa3efb0aa87f085a254587fe2" translate="yes" xml:space="preserve">
          <source>The list of the valid options is shown below. Options not specified will remain unchanged.</source>
          <target state="translated">有効なオプションのリストを以下に示します。指定されていないオプションは変更されません。</target>
        </trans-unit>
        <trans-unit id="cca90ac8d52c301adc0df9b517c693dc0133a8b6" translate="yes" xml:space="preserve">
          <source>The list opened with &lt;code&gt;=over&lt;/code&gt; does not contain any items.</source>
          <target state="translated">&lt;code&gt;=over&lt;/code&gt; で開いたリストにはアイテムが含まれていません。</target>
        </trans-unit>
        <trans-unit id="37870cad335f71a8db1ccbfc9f539b9f8492c3a2" translate="yes" xml:space="preserve">
          <source>The list reference contains one or more strings specifying patterns that are</source>
          <target state="translated">リスト参照には、以下のパターンを指定する1つ以上の文字列が含まれています。</target>
        </trans-unit>
        <trans-unit id="7ecd93d98b44cbb94ca7891c2599a20dc8e75287" translate="yes" xml:space="preserve">
          <source>The list reference contains one or more strings specifying patterns that must</source>
          <target state="translated">リスト参照には、以下のようなパターンを指定する文字列が含まれています。</target>
        </trans-unit>
        <trans-unit id="0da38439f7a00ec9abb7cd8b98624a8251f6fb80" translate="yes" xml:space="preserve">
          <source>The listing below is alphabetical, case insensitive.</source>
          <target state="translated">以下のリストはアルファベット順で、大文字と小文字を区別しません。</target>
        </trans-unit>
        <trans-unit id="768abd184089ae969a2334570319327e5afad505" translate="yes" xml:space="preserve">
          <source>The listing looks something like this:</source>
          <target state="translated">リストはこんな感じです。</target>
        </trans-unit>
        <trans-unit id="a6fd74766ba848460935d167a256b131af8e02ea" translate="yes" xml:space="preserve">
          <source>The lists are ordered (roughly) so the most preferred names come before less preferred ones.</source>
          <target state="translated">リストは(大まかに)順番に並んでいるので、最も好まれる名前は好まれない名前の前に来ます。</target>
        </trans-unit>
        <trans-unit id="c3448e4c57076d015f65b6c72251baf22ba5950b" translate="yes" xml:space="preserve">
          <source>The literal string in the regex can be replaced by a variable:</source>
          <target state="translated">正規表現のリテラル文字列を変数に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="9605e010408c59883a845d8cc68911d04aa028cd" translate="yes" xml:space="preserve">
          <source>The literal string in the regexp can be replaced by a variable:</source>
          <target state="translated">正規表現のリテラル文字列を変数に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="cc87d2f061afcaaa2771f59160c4bc3540da65d9" translate="yes" xml:space="preserve">
          <source>The literal string to be output. If it starts with a number and an optional '*' then the padding will be increased by an amount relative to this number, if the '*' is present then this amount will be multiplied by $cnt. This part of $string is removed before output/</source>
          <target state="translated">出力されるリテラル文字列。数値とオプションの '*' で始まる文字列の場合は、 パディングはこの数値から相対的に増加し、 '*' がある場合はこの数値に $cnt を掛けます。文字列のこの部分は、出力前に削除されます。</target>
        </trans-unit>
        <trans-unit id="67b8f203dc692021f65103823771254ae8d76d5b" translate="yes" xml:space="preserve">
          <source>The literals that are converted are &lt;code&gt;q//, qq//, qr//, qw///, qx//&lt;/code&gt; , and starting in v5.8.1, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. Operations that do conversions include &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;utf8::upgrade&lt;/code&gt; (but not &lt;code&gt;utf8::downgrade&lt;/code&gt; ), and &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">変換されるリテラルは、 &lt;code&gt;q//, qq//, qr//, qw///, qx//&lt;/code&gt; 、v5.8.1以降では &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; です。変換を行う操作には、 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;utf8::upgrade&lt;/code&gt; （ただし &lt;code&gt;utf8::downgrade&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; ）、およびchompが含まれます。</target>
        </trans-unit>
        <trans-unit id="dba36a88aebe7e92337b13757f05491149d1212d" translate="yes" xml:space="preserve">
          <source>The little number the &lt;b&gt;operating system&lt;/b&gt; uses to keep track of which opened &lt;b&gt;file&lt;/b&gt; you&amp;rsquo;re talking about. Perl hides the file descriptor inside a &lt;b&gt;standard I/O&lt;/b&gt; stream and then attaches the stream to a &lt;b&gt;filehandle&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;オペレーティングシステム&lt;/b&gt;が話している開いている&lt;b&gt;ファイル&lt;/b&gt;を追跡するために使用する小さな番号。Perlはファイル記述子を&lt;b&gt;標準のI / O&lt;/b&gt;ストリーム内に隠し、ストリームを&lt;b&gt;ファイルハンドルに&lt;/b&gt;アタッチします。</target>
        </trans-unit>
        <trans-unit id="c45e18376e8b086f8c631b86953dc61fd730ab6e" translate="yes" xml:space="preserve">
          <source>The load function that dl_load_file() calls may require an absolute pathname. The dl_findfile() function and @dl_library_path can be used to search for and return the absolute pathname for the library/object that you wish to load.</source>
          <target state="translated">dl_load_file()が呼び出すロード関数では、絶対パス名が必要な場合があります。dl_findfile()関数と @dl_library_path を使用して、ロードしたいライブラリ/オブジェクトの絶対パス名を検索して返すことができます。</target>
        </trans-unit>
        <trans-unit id="8c46c2259b1d6fa0f7f68fad81b43f4cfbd94e4d" translate="yes" xml:space="preserve">
          <source>The loaded modules are IO::Handle, IO::Seekable, IO::File, IO::Pipe, IO::Socket, IO::Dir. You should instead explicitly import the IO modules you want.</source>
          <target state="translated">ロードされるモジュールは IO::Handle,IO::Seekable,IO::File,IO::Pipe,IO::Socket,IO::Dir です。代わりに、必要なIOモジュールを明示的にインポートする必要があります。</target>
        </trans-unit>
        <trans-unit id="0917a1903587e2d522edafea1a2d6e66a9118a13" translate="yes" xml:space="preserve">
          <source>The local() generated a compile-time error because you just touched a global name without fully qualifying it.</source>
          <target state="translated">local()がコンパイル時エラーを発生させたのは、グローバル名を完全に修飾せずに触ってしまったからです。</target>
        </trans-unit>
        <trans-unit id="0cf7efcc5129f771b3d1f0dd51149aa0de4647fc" translate="yes" xml:space="preserve">
          <source>The localeconv function</source>
          <target state="translated">localeconv関数</target>
        </trans-unit>
        <trans-unit id="ba0cd5497a3f02564f53cc5f3cb0a7c74904a185" translate="yes" xml:space="preserve">
          <source>The locking technique went like this.</source>
          <target state="translated">ロック技術はこのようになりました。</target>
        </trans-unit>
        <trans-unit id="fb02723b6a87664f1d9c172d5d68ee624445a8a4" translate="yes" xml:space="preserve">
          <source>The logarithm of the Gamma function [C99].</source>
          <target state="translated">ガンマ関数の対数[C99]。</target>
        </trans-unit>
        <trans-unit id="12f81008559a10138f818056ec245c593a6400e5" translate="yes" xml:space="preserve">
          <source>The logic of &lt;code&gt;:locale&lt;/code&gt; is described in full in &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt;, but in short it is first trying nl_langinfo(CODESET) and then guessing from the LC_ALL and LANG locale environment variables.</source>
          <target state="translated">&lt;code&gt;:locale&lt;/code&gt; のロジックは&lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt;で完全に説明されていますが、簡単に言うと、最初にnl_langinfo（CODESET）を試し、次にLC_ALLおよびLANGロケール環境変数から推測します。</target>
        </trans-unit>
        <trans-unit id="cf878ca097d48d543ea19885a2629244c15e1017" translate="yes" xml:space="preserve">
          <source>The logic of finding which locale &lt;code&gt;:locale&lt;/code&gt; uses is as follows:</source>
          <target state="translated">&lt;code&gt;:locale&lt;/code&gt; が使用するロケールを見つけるロジックは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="49964803a05917808abe031a83a5e6119fc9d862" translate="yes" xml:space="preserve">
          <source>The lone dot that ends a format can also prematurely end a mail message passing through a misconfigured Internet mailer (and based on experience, such misconfiguration is the rule, not the exception). So when sending format code through mail, you should indent it so that the format-ending dot is not on the left margin; this will prevent SMTP cutoff.</source>
          <target state="translated">また、フォーマットを終了する単独のドットは、誤って設定されたインターネットメーラーを通過するメールメッセージを早々に終了させる可能性があります(経験上、このような誤った設定は例外ではなくルールです)。そのため、メールでフォーマットコードを送信する際には、フォーマット終了ドットが左マージンにないようにインデントする必要があります。</target>
        </trans-unit>
        <trans-unit id="23ac1b0fabb60338fc7595b94617767f0048e6fc" translate="yes" xml:space="preserve">
          <source>The lonesome dash</source>
          <target state="translated">孤独なダッシュ</target>
        </trans-unit>
        <trans-unit id="8acab1ed969d76981aca60d63a3ad2f6189741fb" translate="yes" xml:space="preserve">
          <source>The long answer is that &quot;it depends&quot;, and a good answer cannot be given without knowing (at the very least) the language context. See &lt;a href=&quot;unicode/collate&quot;&gt;Unicode::Collate&lt;/a&gt;, and</source>
          <target state="translated">長い答えは「依存する」ということであり、（少なくとも）言語のコンテキストを知らなければ、良い答えは得られません。参照&lt;a href=&quot;unicode/collate&quot;&gt;のUnicode ::ソート&lt;/a&gt;、および</target>
        </trans-unit>
        <trans-unit id="2b351929b2c368a051a670eae8fde3b6788ce75f" translate="yes" xml:space="preserve">
          <source>The long answer is that you need to consider character normalization and casing issues: see &lt;a href=&quot;unicode/normalize&quot;&gt;Unicode::Normalize&lt;/a&gt;, Unicode Technical Report #15, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2funicode%2freports%2ftr15&quot;&gt;Unicode Normalization Forms&lt;/a&gt; and sections on case mapping in the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org&quot;&gt;Unicode Standard&lt;/a&gt;.</source>
          <target state="translated">長い答えは、文字の正規化と大文字小文字の問題を考慮する必要があるということです&lt;a href=&quot;unicode/normalize&quot;&gt;。Unicode:: Normalize&lt;/a&gt;、Unicode Technical Report＃15、&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2funicode%2freports%2ftr15&quot;&gt;Unicode Normalization Forms&lt;/a&gt;および&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org&quot;&gt;Unicode Standardの&lt;/a&gt;大文字と小文字のマッピングに関するセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="b13e585010c555d0e300d8fe834b6f46a4ae81c6" translate="yes" xml:space="preserve">
          <source>The long answer is the rest of the manpage :-)</source>
          <target state="translated">長い答えはマンページの残りの部分です :-)</target>
        </trans-unit>
        <trans-unit id="31adae3a57b090c57ee3c7e6d1bf3e97b3bf17d2" translate="yes" xml:space="preserve">
          <source>The long name is returned in a form nicely capitalized, suitable for printing.</source>
          <target state="translated">長い名前はきれいに大文字で返され、印刷に適しています。</target>
        </trans-unit>
        <trans-unit id="3088cd686b7b7b0dbd27c6c1543c10f8e12363eb" translate="yes" xml:space="preserve">
          <source>The lookahead and lookbehind assertions are generalizations of the anchor concept. Lookahead and lookbehind are zero-width assertions that let us specify which characters we want to test for. The lookahead assertion is denoted by &lt;code&gt;(?=regexp)&lt;/code&gt; and the lookbehind assertion is denoted by &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt;. Some examples are</source>
          <target state="translated">先読みと後読みのアサーションは、アンカーの概念を一般化したものです。先読みと後読みは、テストする文字を指定できるゼロ幅アサーションです。先読みアサーションは &lt;code&gt;(?=regexp)&lt;/code&gt; で示され、先読みアサーションは &lt;code&gt;(?&amp;lt;=fixed-regexp)&lt;/code&gt; で示されます。いくつかの例は</target>
        </trans-unit>
        <trans-unit id="d6f75c5b0c19aae838064eb95c9b0bb2969329be" translate="yes" xml:space="preserve">
          <source>The lookbehind &lt;code&gt;condition&lt;/code&gt; allows, along with backreferences, an earlier part of the match to influence a later part of the match. For instance,</source>
          <target state="translated">後読み &lt;code&gt;condition&lt;/code&gt; により、後方参照とともに、一致の前の部分が一致の後の部分に影響を与えることができます。例えば、</target>
        </trans-unit>
        <trans-unit id="81e7a5f6a959e62bd2ce3d55576db8abdefeae7e" translate="yes" xml:space="preserve">
          <source>The loop will do the right thing for a while, but it will unexpectedly fail.</source>
          <target state="translated">ループはしばらくは正しいことをしてくれますが、予想外に失敗してしまいます。</target>
        </trans-unit>
        <trans-unit id="45575ec17d57b6c0181a285166eef0dbc45075e3" translate="yes" xml:space="preserve">
          <source>The loop will never terminate.</source>
          <target state="translated">ループが終了することはありません。</target>
        </trans-unit>
        <trans-unit id="ef06996a2f846d6797b75f13080961cc1d5fe17b" translate="yes" xml:space="preserve">
          <source>The low levels of the stack work with the low-level operating system calls (file descriptors in C) getting bytes in and out, the higher layers of the stack buffer, filter, and otherwise manipulate the I/O, and return characters (or bytes) to Perl. Terms</source>
          <target state="translated">スタックの低レベルの層は、低レベルのオペレーティングシステムの呼び出し(C言語ではファイル記述子)がバイトの出し入れを行い、スタックの上位層は、バッファリング、フィルタリング、その他のI/O操作を行い、Perlに文字(またはバイト)を返すように動作します。用語</target>
        </trans-unit>
        <trans-unit id="e618b44ecefc43c73cbcbb761a0be8756b4a11d0" translate="yes" xml:space="preserve">
          <source>The lower-level loops are</source>
          <target state="translated">下位レベルのループは</target>
        </trans-unit>
        <trans-unit id="d49e301cfdcfd0dc30c1292d8446531a39bb2c8d" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;$ref&lt;/code&gt; will be turned into a weak reference. This means that it will not hold a reference count on the object it references. Also when the reference count on that object reaches zero, the reference will be set to undef. This function mutates the lvalue passed as its argument and returns no value.</source>
          <target state="translated">左辺値 &lt;code&gt;$ref&lt;/code&gt; は弱い参照に変換されます。これは、参照するオブジェクトの参照カウントを保持しないことを意味します。また、そのオブジェクトの参照カウントがゼロに達すると、参照はundefに設定されます。この関数は、引数として渡された左辺値を変更し、値を返しません。</target>
        </trans-unit>
        <trans-unit id="6b3f15897ac19338676b9cf56d55755a66f779f6" translate="yes" xml:space="preserve">
          <source>The lvalue &lt;code&gt;REF&lt;/code&gt; will be turned from a weak reference back into a normal (strong) reference again. This function mutates the lvalue passed as its argument and returns no value. This undoes the action performed by &lt;a href=&quot;#weaken&quot;&gt;weaken&lt;/a&gt;.</source>
          <target state="translated">左辺値 &lt;code&gt;REF&lt;/code&gt; は、弱い参照から通常の（強い）参照に戻ります。この関数は、引数として渡された左辺値を変更し、値を返しません。これは、アクションが実行さによって取り消す&lt;a href=&quot;#weaken&quot;&gt;弱めます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8b79adf8cca5ef25d3cb23e673042840fb0ff857" translate="yes" xml:space="preserve">
          <source>The macro to put this target on stack is &lt;code&gt;PUSHTARG&lt;/code&gt; , and it is directly used in some opcodes, as well as indirectly in zillions of others, which use it via &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;.</source>
          <target state="translated">このターゲットをスタックに配置するマクロは &lt;code&gt;PUSHTARG&lt;/code&gt; で、一部のオペコードで直接使用されるほか、 &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt; 介してそれを使用する何十億もの他のオペコードで間接的に使用されます。</target>
        </trans-unit>
        <trans-unit id="bde4ff87d6048995f18afa79c7d92547dd919bf7" translate="yes" xml:space="preserve">
          <source>The macros PERL_SYS_INIT3() and PERL_SYS_TERM() provide system-specific tune up of the C runtime environment necessary to run Perl interpreters; they should only be called once regardless of how many interpreters you create or destroy. Call PERL_SYS_INIT3() before you create your first interpreter, and PERL_SYS_TERM() after you free your last interpreter.</source>
          <target state="translated">PERL_SYS_INIT3()と PERL_SYS_TERM()マクロは、Perl インタプリタの実行に必要な C ランタイム環境のシステム固有の調整を提供します。最初のインタプリタを作成する前に PERL_SYS_INIT3()を、最後のインタプリタを解放した後に PERL_SYS_TERM()を呼び出してください。</target>
        </trans-unit>
        <trans-unit id="d1139ce181f4f4cad2c7f324461583f5984431bd" translate="yes" xml:space="preserve">
          <source>The macros to simplify this type of error propagation are</source>
          <target state="translated">このタイプのエラー伝搬を単純化するマクロは</target>
        </trans-unit>
        <trans-unit id="c70f4757860a22dec9e7cd7195f5c976eb6e087f" translate="yes" xml:space="preserve">
          <source>The mailbox (MBX) that perl can create to communicate with a pipe defaults to a buffer size of 8192 on 64-bit systems, 512 on VAX. The default buffer size is adjustable via the logical name PERL_MBX_SIZE provided that the value falls between 128 and the SYSGEN parameter MAXBUF inclusive. For example, to set the mailbox size to 32767 use &lt;code&gt;$ENV{'PERL_MBX_SIZE'} = 32767;&lt;/code&gt; and then open and use pipe constructs. An alternative would be to issue the command:</source>
          <target state="translated">perlがパイプと通信するために作成できるメールボックス（MBX）は、64ビットシステムではデフォルトで8192、VAXでは512のバッファーサイズになります。デフォルトのバッファサイズは、値が128からSYSGENパラメータMAXBUFまでの範囲内であれば、論理名PERL_MBX_SIZEを介して調整可能です。たとえば、メールボックスのサイズを32767に設定するには、 &lt;code&gt;$ENV{'PERL_MBX_SIZE'} = 32767;&lt;/code&gt; 次に、パイプ構成を開いて使用します。別の方法は、コマンドを発行することです：</target>
        </trans-unit>
        <trans-unit id="0c5ef5a84eaac465306135c82a819527f916862a" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$]&lt;/code&gt; over &lt;code&gt;$^V&lt;/code&gt; is that it works the same on any version of Perl. The disadvantages are that it can't easily be compared to versions in other formats (e.g. literal v-strings, &quot;v1.2.3&quot; or version objects) and numeric comparisons can occasionally fail; it's good for string literal version checks and bad for comparing to a variable that hasn't been sanity-checked.</source>
          <target state="translated">&lt;code&gt;$^V&lt;/code&gt; に対する &lt;code&gt;$]&lt;/code&gt; の主な利点は、どのバージョンのPerlでも同じように機能することです。欠点は、他の形式のバージョン（リテラルv-string、「v1.2.3」、バージョンオブジェクトなど）と簡単に比較できず、数値の比較が失敗する場合があることです。文字列リテラルのバージョンチェックには適していますが、サニティチェックされていない変数との比較には適していません。</target>
        </trans-unit>
        <trans-unit id="fb52b8877c2d456ae00a93e532373fbd1c4c24a5" translate="yes" xml:space="preserve">
          <source>The main advantage of &lt;code&gt;$^V&lt;/code&gt; over &lt;code&gt;$]&lt;/code&gt; is that, for Perl v5.10.0 or later, it overloads operators, allowing easy comparison against other version representations (e.g. decimal, literal v-string, &quot;v1.2.3&quot;, or objects). The disadvantage is that prior to v5.10.0, it was only a literal v-string, which can't be easily printed or compared.</source>
          <target state="translated">主な利点 &lt;code&gt;$^V&lt;/code&gt; を超える &lt;code&gt;$]&lt;/code&gt; はそれは、Perl v5.10.0ため以降、それは他のバージョンの表現（例えば、小数点リテラルV-文字列、「v1.2.3」、またはオブジェクト）に対して容易に比較できるよう、オペレータをオーバーロードであり、 。欠点は、v5.10.0より前のバージョンでは、文字列のv文字列のみであり、簡単に印刷したり比較したりできないことです。</target>
        </trans-unit>
        <trans-unit id="101d1c6f485f1984d68802df9d96ca30aed70d37" translate="yes" xml:space="preserve">
          <source>The main change in &lt;code&gt;Compress::Zlib&lt;/code&gt; version 2.x is that it does not now interface directly to the zlib library. Instead it uses the &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; modules for reading/writing gzip files, and the &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; module for some low-level zlib access.</source>
          <target state="translated">&lt;code&gt;Compress::Zlib&lt;/code&gt; バージョン2.x の主な変更は、zlibライブラリに直接インターフェースしないようになったことです。代わりに、使用する &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; と &lt;code&gt;IO::Uncompress::Gunzip&lt;/code&gt; はgzipファイル、および書き込み/読み出し用のモジュールを &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; いくつかの低レベルzlibのアクセスのためのモジュールを。</target>
        </trans-unit>
        <trans-unit id="372171de4da878145ca85489d35a3856b5f753b3" translate="yes" xml:space="preserve">
          <source>The main difference between this form of the &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; method and the previous one, is that this one will attempt to return</source>
          <target state="translated">この形式の &lt;code&gt;&lt;a href=&quot;../../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; メソッドと以前の形式の主な違いは、このメソッドが返そうとすることです。</target>
        </trans-unit>
        <trans-unit id="506249c3cb5dbdd1518162463cf96d2d3b772f7e" translate="yes" xml:space="preserve">
          <source>The main difference in your code when using &lt;code&gt;LimitOutput&lt;/code&gt; is having to deal with cases where the &lt;code&gt;$input&lt;/code&gt; parameter still contains some uncompressed data that &lt;code&gt;inflate&lt;/code&gt; hasn't processed yet. The status code returned from &lt;code&gt;inflate&lt;/code&gt; will be &lt;code&gt;Z_OK&lt;/code&gt; if uncompression took place and &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; if the output buffer is full.</source>
          <target state="translated">&lt;code&gt;LimitOutput&lt;/code&gt; を使用する場合のコードの主な違いは、 &lt;code&gt;$input&lt;/code&gt; パラメータにまだ処理 &lt;code&gt;inflate&lt;/code&gt; ていない非圧縮データが含まれている場合に対処する必要があることです。返されたステータスコード &lt;code&gt;inflate&lt;/code&gt; なり &lt;code&gt;Z_OK&lt;/code&gt; を解凍は、場所やかかった場合 &lt;code&gt;Z_BUF_ERROR&lt;/code&gt; を出力バッファがいっぱいになった場合。</target>
        </trans-unit>
        <trans-unit id="05152f518d0f3656c0688ee9cee29d35fcced80c" translate="yes" xml:space="preserve">
          <source>The main enhancements over the standard DBM Filter hooks are:</source>
          <target state="translated">標準的なDBMフィルタフックを超える主な機能強化は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="e1f5b26355b7b70560c834756cb61711542dab38" translate="yes" xml:space="preserve">
          <source>The main interface to Perl's documentation is &lt;code&gt;perldoc&lt;/code&gt; , although if you're reading this, it's more than likely that you've already found it.</source>
          <target state="translated">Perlのドキュメントへの主要なインターフェースは &lt;code&gt;perldoc&lt;/code&gt; ですが、これを読んでいる場合は、すでに見つけている可能性が高くなります。</target>
        </trans-unit>
        <trans-unit id="9d35e12fdba0e51aa394bd8618a43431bb51d2f3" translate="yes" xml:space="preserve">
          <source>The main processing loop in the code handles reading of compressed data from STDIN.</source>
          <target state="translated">コード内の主な処理ループは、STDIN からの圧縮データの読み込みを処理します。</target>
        </trans-unit>
        <trans-unit id="46fda3610207ec49730bec59c6f9f9a606bd23ef" translate="yes" xml:space="preserve">
          <source>The main restriction is that everything is a metacharacter. Thus, you cannot refer to single characters by doing something like this:</source>
          <target state="translated">主な制限は、すべてがメタ文字であるということです。したがって、このようなことをして単一の文字を参照することはできません。</target>
        </trans-unit>
        <trans-unit id="5f01e11115c777ec013558e25689beffe8389e6e" translate="yes" xml:space="preserve">
          <source>The main run-time, i.e. the execution of &lt;code&gt;PL_main_root&lt;/code&gt; .</source>
          <target state="translated">メインのランタイム、つまり &lt;code&gt;PL_main_root&lt;/code&gt; の実行。</target>
        </trans-unit>
        <trans-unit id="37fc4f091ec88a6495b33730022421e8180365bf" translate="yes" xml:space="preserve">
          <source>The main thing to bear in mind when comparing Perl's</source>
          <target state="translated">Perl の</target>
        </trans-unit>
        <trans-unit id="c06e6958bf7f6e1def3af629026b1de09d93eea1" translate="yes" xml:space="preserve">
          <source>The main two standard installer modules are the old and well established ExtUtils::MakeMaker (for short: EUMM) which uses the Makefile.PL. And the next generation installer Module::Build (MB) which works with the Build.PL (and often comes with a Makefile.PL too). If a module comes only with one of the two we will use that one but if both are supplied then a decision must be made between EUMM and MB. See also &lt;a href=&quot;http://rt.cpan.org/Ticket/Display.html?id=29235&quot;&gt;http://rt.cpan.org/Ticket/Display.html?id=29235&lt;/a&gt; for a discussion about the right default.</source>
          <target state="translated">主要な2つの標準インストーラーモジュールは、Makefile.PLを使用する、古く確立されたExtUtils :: MakeMaker（略してEUMM）です。そして、Build.PLで動作する次世代インストーラーModule :: Build（MB）（そして多くの場合Makefile.PLも付属しています）。モジュールに2つのうちの1つだけが付属している場合は、その1つを使用しますが、両方が提供されている場合は、EUMMとMBの間で決定を行う必要があります。適切なデフォルトについては、&lt;a href=&quot;http://rt.cpan.org/Ticket/Display.html?id=29235&quot;&gt;http：//rt.cpan.org/Ticket/Display.html？id = 29235&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="b2f8fe511450837b8803ee63b84fd8df2352eb1f" translate="yes" xml:space="preserve">
          <source>The main use of the &lt;code&gt;@_&lt;/code&gt; pass-through feature is to write subroutines whose main job it is to call other subroutines for you. For further details, see &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@_&lt;/code&gt; パススルー機能の主な用途は、他のサブルーチンを呼び出すことを主な目的とするサブルーチンを作成することです。詳細については、&lt;a href=&quot;perlsub&quot;&gt;perlsubを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="53e4e2133c40d29e72103e441a447d5a4a38fc75" translate="yes" xml:space="preserve">
          <source>The main use of typeglobs in modern Perl is create symbol table aliases. This assignment:</source>
          <target state="translated">現代のPerlにおけるタイプグローブの主な使用方法は、シンボルテーブルのエイリアスを作成することです。この割り当て。</target>
        </trans-unit>
        <trans-unit id="69b1898f468b9694e16716e650f4f44f6641ba6b" translate="yes" xml:space="preserve">
          <source>The main way they do this is by abstracting the solution into a Perl module. If you don't know what one of these is, the rest of this document isn't going to be much use to you. You're also missing out on an awful lot of useful code; consider having a look at &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; and &lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstall&lt;/a&gt; before coming back here.</source>
          <target state="translated">彼らがこれを行う主な方法は、Perlモジュールにソリューションを抽象化することです。これらの1つがわからない場合、このドキュメントの残りの部分はあまり役に立ちません。また、非常に多くの有用なコードを見逃しています。ここに戻る前に、&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;、&lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt;、および&lt;a href=&quot;perlmodinstall&quot;&gt;perlmodinstallを&lt;/a&gt;確認することを検討してください。</target>
        </trans-unit>
        <trans-unit id="0f1c38b1c10cfb3cbb67b1b10b401ccad6c0863c" translate="yes" xml:space="preserve">
          <source>The main workhorse. This is a chimera executable: it is compiled as an &lt;code&gt;a.out&lt;/code&gt; -style executable, but is linked with &lt;code&gt;omf&lt;/code&gt; -style dynamic library</source>
          <target state="translated">主な働き者。これはキメラの実行可能ファイルです。これは &lt;code&gt;a.out&lt;/code&gt; スタイルの実行可能ファイルとしてコンパイルされますが、 &lt;code&gt;omf&lt;/code&gt; スタイルの動的ライブラリとリンクされています</target>
        </trans-unit>
        <trans-unit id="3956c803121907ff5d6974bf9c432a88f1cf833c" translate="yes" xml:space="preserve">
          <source>The major headers should be set out using a &lt;code&gt;=head1&lt;/code&gt; directive, and are historically written in the rather startling ALL UPPER CASE format; this is not mandatory, but it's strongly recommended so that sections have consistent naming across different software packages. Minor headers may be included using &lt;code&gt;=head2&lt;/code&gt; , and are typically in mixed case.</source>
          <target state="translated">主要なヘッダーは &lt;code&gt;=head1&lt;/code&gt; ディレクティブを使用して設定する必要があり、歴史的にはかなり驚くべきすべて大文字の形式で記述されています。これは必須ではありませんが、セクションが異なるソフトウェアパッケージ間で一貫した名前を持つようにすることを強くお勧めします。マイナーヘッダーは &lt;code&gt;=head2&lt;/code&gt; を使用して含めることができ、通常は大文字と小文字が混在します。</target>
        </trans-unit>
        <trans-unit id="01d78be692306962b0b26bf44b44f51f19191990" translate="yes" xml:space="preserve">
          <source>The major reference book on Perl, written by the creator of Perl, is</source>
          <target state="translated">Perlの生みの親が書いたPerlの主要な参考書は</target>
        </trans-unit>
        <trans-unit id="13680a9d6e9227284375bc26da8c5530041e38fc" translate="yes" xml:space="preserve">
          <source>The majority of messages from the first three classifications above (W, D &amp;amp; S) can be controlled using the &lt;code&gt;warnings&lt;/code&gt; pragma.</source>
          <target state="translated">上記の最初の3つの分類（W、D、S）からのメッセージの大部分は、 &lt;code&gt;warnings&lt;/code&gt; プラグマを使用して制御できます。</target>
        </trans-unit>
        <trans-unit id="cd369e1f787ef0292f11539410c5f0156585f6b5" translate="yes" xml:space="preserve">
          <source>The make process also creates the Perl extensions as</source>
          <target state="translated">makeプロセスはまた、Perlの拡張モジュールを</target>
        </trans-unit>
        <trans-unit id="6834c3d08e7b64ac9a3d75579db624c6bb6535ce" translate="yes" xml:space="preserve">
          <source>The make process runs only under WinNT shell. The NetWare makefile is located under the NetWare folder. This makes use of miniperl.exe to run some of the Perl scripts. To create miniperl.exe, first set the required paths for Visual c++ compiler (specify vcvars32 location) at the command prompt. Then run nmake from win32 folder through WinNT command prompt. The build process can be stopped after miniperl.exe is created. Then run nmake from NetWare folder through WinNT command prompt.</source>
          <target state="translated">makeプロセスはWinNTシェルの下でのみ実行されます。NetWareのmakefileはNetWareフォルダの下にあります。これは、Perlスクリプトの一部を実行するためにminiperl.exeを利用しています。miniperl.exeを作成するには、まずコマンドプロンプトでVisual c++コンパイラの必要なパスを設定します(vcvars32の場所を指定します)。次に、Win32フォルダからWinNTのコマンドプロンプトからnmakeを実行します。miniperl.exeが作成された後、ビルド処理を停止することができます。その後、NetWareフォルダからWinNTのコマンドプロンプトからnmakeを実行します。</target>
        </trans-unit>
        <trans-unit id="050ece2e16daad9919f83779717a0433d9f5277b" translate="yes" xml:space="preserve">
          <source>The make under /usr/ccs/bin works fine for building perl. If you have the Sun C compilers, you will also have a parallel version of make (dmake). This works fine to build perl, but can sometimes cause problems when running 'make test' due to underspecified dependencies between the different test harness files. The same problem can also affect the building of some add-on modules, so in those cases either specify '-m serial' on the dmake command line, or use /usr/ccs/bin/make instead. If you wish to use GNU make, be sure that the set-group-id bit is not set. If it is, then arrange your PATH so that /usr/ccs/bin/make is before GNU make or else have the system administrator disable the set-group-id bit on GNU make.</source>
          <target state="translated">/usr/ccs/bin 以下の make は perl のビルドには問題なく動作します。Sun C のコンパイラを使っている場合は、並列バージョンの make (dmake)もあります。これはperlをビルドするのには問題なく動作しますが、'make test'を実行する際に、異なるテストハーネスファイル間の依存関係が指定されていないために問題が発生することがあります。同じ問題は、いくつかのアドオンモジュールのビルドにも影響を与えます。GNU makeを使いたい場合は、set-group-idビットが設定されていないことを確認してください。もし設定されていれば、/usr/ccs/bin/makeがGNU makeの前にあるようにPATHをアレンジするか、システム管理者にGNU makeのset-group-idビットを無効にしてもらってください。</target>
        </trans-unit>
        <trans-unit id="093c5a0fa4f10414f0bded11d9711f892cf8d016" translate="yes" xml:space="preserve">
          <source>The makefile for Win32 is used as a reference to create the makefile for NetWare. Also, the make process for NetWare port uses miniperl.exe to run scripts during the make and installation process.</source>
          <target state="translated">Win32用のmakefileを参照してNetWare用のmakefileを作成します。また、NetWareポート用のmake処理では、miniperl.exeを使用して、make処理やインストール処理の際にスクリプトを実行しています。</target>
        </trans-unit>
        <trans-unit id="27e98181ad3a79924d7fd39b526549233ec76d6a" translate="yes" xml:space="preserve">
          <source>The man page documenting the an macro set may be</source>
          <target state="translated">マクロセットを文書化したマニュアルページは、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="d1b2bfc99455c361765a64ae36b53dd690daec7f" translate="yes" xml:space="preserve">
          <source>The man page documenting the man macro set may be</source>
          <target state="translated">マンマクロセットを文書化したマンページは、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="284a6c5b883e0ac48b839ca370726900339633bc" translate="yes" xml:space="preserve">
          <source>The mandatory parameter &lt;code&gt;$input&lt;/code&gt; is used to determine the source of the compressed data. This parameter can take one of three forms.</source>
          <target state="translated">必須パラメーター &lt;code&gt;$input&lt;/code&gt; は、圧縮データのソースを決定するために使用されます。このパラメーターは、3つの形式のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="c485ab3d22837e3f8be3f1796e0e79d8c8f06f1f" translate="yes" xml:space="preserve">
          <source>The mandatory parameter &lt;code&gt;$output&lt;/code&gt; is used to control the destination of the compressed data. This parameter can take one of these forms.</source>
          <target state="translated">必須パラメーター &lt;code&gt;$output&lt;/code&gt; は、圧縮データの宛先を制御するために使用されます。このパラメーターは、次のいずれかの形式を取ることができます。</target>
        </trans-unit>
        <trans-unit id="de616d536d8ef10cc9a3f654a8c90f376abf8093" translate="yes" xml:space="preserve">
          <source>The manual for GNU &lt;code&gt;gettext&lt;/code&gt; . The gettext dist is available in &lt;code&gt;&lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;&lt;/code&gt; -- get a recent gettext tarball and look in its &quot;doc/&quot; directory, there's an easily browsable HTML version in there. The gettext documentation asks lots of questions worth thinking about, even if some of their answers are sometimes wonky, particularly where they start talking about pluralization.</source>
          <target state="translated">GNU &lt;code&gt;gettext&lt;/code&gt; のマニュアル。gettext distは &lt;code&gt;&lt;a href=&quot;ftp://prep.ai.mit.edu/pub/gnu/&quot;&gt;ftp://prep.ai.mit.edu/pub/gnu/&lt;/a&gt;&lt;/code&gt; から入手できます。最近のgettext tarballを取得して、その「doc /」ディレクトリを確認すると、簡単に参照できるHTMLバージョンがあります。gettextのドキュメンテーションは、特に複数形化について話し始めたときに、その答えの一部が時々不安定になる場合でも、考える価値のある多くの質問をします。</target>
        </trans-unit>
        <trans-unit id="154ce4660707f31f1810dc0e3b48188806eef41c" translate="yes" xml:space="preserve">
          <source>The many &lt;code&gt;SO_*&lt;/code&gt; and other constants provide the socket option names for getsockopt() and setsockopt().</source>
          <target state="translated">多くの &lt;code&gt;SO_*&lt;/code&gt; およびその他の定数は、getsockopt（）およびsetsockopt（）のソケットオプション名を提供します。</target>
        </trans-unit>
        <trans-unit id="55aaa52fca491aa374cc9b313f0827cacbb95ed1" translate="yes" xml:space="preserve">
          <source>The map of tags-to-names that it uses is accessible as %I18N::LangTags::List::Name, and it's the same as the list that follows in this documentation, which should be useful to you even if you don't use this module.</source>
          <target state="translated">それが使用するタグから名前へのマップは %I18N::LangTags::List::Name としてアクセス可能で、このドキュメントに続くリストと同じで、このモジュールを使用しない場合でも役に立つはずです。</target>
        </trans-unit>
        <trans-unit id="4ec748c6f374bea6dd407e2a2206dd66cc0ef16e" translate="yes" xml:space="preserve">
          <source>The mapping between the C callback and Perl is stored in the global hash &lt;code&gt;Mapping&lt;/code&gt; this time. Using a hash has the distinct advantage that it allows an unlimited number of callbacks to be registered.</source>
          <target state="translated">CコールバックとPerlの間のマッピングは、今回はグローバルハッシュ &lt;code&gt;Mapping&lt;/code&gt; 保存されます。ハッシュを使用すると、無制限の数のコールバックを登録できるという明確な利点があります。</target>
        </trans-unit>
        <trans-unit id="3b99545de853bbada80b111bce027d144c0231ba" translate="yes" xml:space="preserve">
          <source>The mapping between the C callback and the Perl equivalent is stored in the global variable &lt;code&gt;callback&lt;/code&gt; .</source>
          <target state="translated">Cコールバックと同等のPerl間のマッピングは、グローバル変数 &lt;code&gt;callback&lt;/code&gt; に格納されます。</target>
        </trans-unit>
        <trans-unit id="6a662bfcb14335a42ef03f81101790bf366195df" translate="yes" xml:space="preserve">
          <source>The mapping of &lt;code&gt;U+FFFD&lt;/code&gt; is corrected in Unicode 6.3.0. see &lt;a href=&quot;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&quot;&gt;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&lt;/a&gt; (7.1.4 Trailing Weights). Such a correction is reproduced by this.</source>
          <target state="translated">&lt;code&gt;U+FFFD&lt;/code&gt; のマッピングはUnicode 6.3.0で修正されています。&lt;a href=&quot;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights&quot;&gt;http://www.unicode.org/reports/tr10/tr10-28.html#Trailing_Weights（7.1.4&lt;/a&gt;末尾の重み）を参照してください。これにより、このような修正が再現されます。</target>
        </trans-unit>
        <trans-unit id="c1b1175bc8b4e9784f2300c93388884be8f7673f" translate="yes" xml:space="preserve">
          <source>The maps for almost all properties are simple scalars that should be interpreted as-is. These values are those given in the Unicode-supplied data files, which may be inconsistent as to capitalization and as to which synonym for a property-value is given. The results may be normalized by using the &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function.</source>
          <target state="translated">ほとんどすべてのプロパティのマップは、そのまま解釈する必要がある単純なスカラーです。これらの値は、Unicode提供のデータファイルで指定されている値であり、大文字と小文字、およびプロパティ値の同義語がどのように指定されているかについて一貫性がない場合があります。結果は、&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;関数を使用して正規化できます。</target>
        </trans-unit>
        <trans-unit id="3e4bf89cabbc9315682f2b81d303b6aa4fa34849" translate="yes" xml:space="preserve">
          <source>The markup used to embed documentation into your Perl code. Pod stands for &amp;ldquo;Plain old documentation&amp;rdquo;. See Camel chapter 23, &amp;ldquo;Plain Old Documentation&amp;rdquo;.</source>
          <target state="translated">ドキュメントをPerlコードに埋め込むために使用されるマークアップ。ポッドは「プレーンな古いドキュメント」の略です。Camelの第23章「Plain Old Documentation」を参照してください。</target>
        </trans-unit>
        <trans-unit id="34cc83ddfdc06a0bade5acdcde84b75e2705b198" translate="yes" xml:space="preserve">
          <source>The master web site for CPAN is &lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/&lt;/a&gt;, &lt;a href=&quot;http://www.cpan.org/SITES.html&quot;&gt;http://www.cpan.org/SITES.html&lt;/a&gt; lists all mirrors.</source>
          <target state="translated">CPANのマスターWebサイトは&lt;a href=&quot;http://www.cpan.org/&quot;&gt;http://www.cpan.org/で&lt;/a&gt;、&lt;a href=&quot;http://www.cpan.org/SITES.html&quot;&gt;http：&lt;/a&gt; //www.cpan.org/SITES.htmlはすべてのミラーをリストしています。</target>
        </trans-unit>
        <trans-unit id="3c45f7edc42ff58b499f5e637a319d744b7420b9" translate="yes" xml:space="preserve">
          <source>The match is greedy and non-backtracking, so that the cluster is never broken up into smaller components.</source>
          <target state="translated">マッチは貪欲でバックトラッキングをしないため、クラスタがより小さなコンポーネントに分割されることはありません。</target>
        </trans-unit>
        <trans-unit id="c68736af7f30812a5478f14010c89b4ae65386b0" translate="yes" xml:space="preserve">
          <source>The match operator is &quot;=~&quot;, not &quot;~&quot;. (&quot;~&quot; is the one's complement operator, as in C.)</source>
          <target state="translated">一致演算子は&quot;~&quot;ではなく&quot;=~&quot;です。(&quot;~&quot;はC言語のように1の補数演算子です)</target>
        </trans-unit>
        <trans-unit id="5795a85f98b64dffbf8aba9e904fb2bc93749e98" translate="yes" xml:space="preserve">
          <source>The match operator is a double quote context, so you can interpolate your variable just like a double quoted string. In this case, you read the regular expression as user input and store it in &lt;code&gt;$regex&lt;/code&gt; . Once you have the pattern in &lt;code&gt;$regex&lt;/code&gt; , you use that variable in the match operator.</source>
          <target state="translated">一致演算子は二重引用符のコンテキストなので、二重引用符で囲まれた文字列と同じように変数を補間できます。この場合、ユーザー入力として正規表現を読み取り、それを &lt;code&gt;$regex&lt;/code&gt; 格納します。 &lt;code&gt;$regex&lt;/code&gt; でパターンを取得したら、その変数を一致演算子で使用します。</target>
        </trans-unit>
        <trans-unit id="8ab1da87cbb5d0fd800bfa0309cbbc3c397f76b8" translate="yes" xml:space="preserve">
          <source>The match operator. See &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">一致演算子。&lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;perlopのRegexp引用型演算子を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="23da9f3c77f641f40df01068ee8c7ee0a479ea6c" translate="yes" xml:space="preserve">
          <source>The match operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">一致演算子。&lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlopのRegexp引用型演算子を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f542541549a1bc6970c3286cf46be7af8b4f2d05" translate="yes" xml:space="preserve">
          <source>The match-once behavior is controlled by the match delimiter being &lt;code&gt;?&lt;/code&gt;; with any other delimiter this is the normal &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">一回限りの動作は、一致区切り文字が &lt;code&gt;?&lt;/code&gt; ; 他の区切り文字がある場合、これは通常の &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 演算子です。</target>
        </trans-unit>
        <trans-unit id="eeba81f62bbef449f5b856ee7d56cb86c716867d" translate="yes" xml:space="preserve">
          <source>The matched-pattern variables, &lt;code&gt;$&amp;amp;&lt;/code&gt; , &lt;code&gt;$`&lt;/code&gt; (pre-match), &lt;code&gt;$'&lt;/code&gt; (post-match), and &lt;code&gt;$+&lt;/code&gt; (last match) also are tainted.</source>
          <target state="translated">一致したパターン変数 &lt;code&gt;$&amp;amp;&lt;/code&gt; 、 &lt;code&gt;$`&lt;/code&gt; （一致前）、 &lt;code&gt;$'&lt;/code&gt; （一致後）、および &lt;code&gt;$+&lt;/code&gt; （最後の一致）も汚染されます。</target>
        </trans-unit>
        <trans-unit id="eef4278a734cc2ba9814c78fdf30442bf1892ae1" translate="yes" xml:space="preserve">
          <source>The matching of encoding names is loose: case does not matter, and many encodings have several aliases. Note that the &lt;code&gt;:utf8&lt;/code&gt; layer must always be specified exactly like that; it is</source>
          <target state="translated">エンコーディング名のマッチングは緩やかです。大文字と小文字は区別されず、多くのエンコーディングにはいくつかのエイリアスがあります。 &lt;code&gt;:utf8&lt;/code&gt; レイヤーは常にそのように正確に指定する必要があることに注意してください。それは</target>
        </trans-unit>
        <trans-unit id="906f4ce57c5894760cba731d333a52399d7a0c38" translate="yes" xml:space="preserve">
          <source>The matching of encoding names is loose: case does not matter, and many encodings have several aliases. See &lt;a href=&quot;encode/supported&quot;&gt;Encode::Supported&lt;/a&gt; for details and the list of supported locales.</source>
          <target state="translated">エンコーディング名のマッチングは緩やかです。大文字と小文字は区別されず、多くのエンコーディングにはいくつかのエイリアスがあります。参照&lt;a href=&quot;encode/supported&quot;&gt;エンコードをサポート::&lt;/a&gt;詳細とサポートされているロケールのリストについて。</target>
        </trans-unit>
        <trans-unit id="5401e94f4440b62a9a27d03fcc9d30b1169f66e8" translate="yes" xml:space="preserve">
          <source>The material below is separated into three main sections: main issues of portability (&lt;a href=&quot;#ISSUES&quot;&gt;ISSUES&lt;/a&gt;), platform-specific issues (&lt;a href=&quot;#PLATFORMS&quot;&gt;PLATFORMS&lt;/a&gt;), and built-in Perl functions that behave differently on various ports (&lt;a href=&quot;#FUNCTION-IMPLEMENTATIONS&quot;&gt;FUNCTION IMPLEMENTATIONS&lt;/a&gt;).</source>
          <target state="translated">以下の資料は3つの主要なセクションに分かれています。移植性の主な問題（&lt;a href=&quot;#ISSUES&quot;&gt;ISSUES&lt;/a&gt;）、プラットフォーム固有の問題（&lt;a href=&quot;#PLATFORMS&quot;&gt;PLATFORMS&lt;/a&gt;）、およびさまざまなポートで異なる動作をする組み込みのPerl関数（&lt;a href=&quot;#FUNCTION-IMPLEMENTATIONS&quot;&gt;FUNCTION IMPLEMENTATIONS&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="42a757bded9f533a67a5134eccc21794fdd0b6bd" translate="yes" xml:space="preserve">
          <source>The maximum Unicode code point is &lt;code&gt;U+10FFFF&lt;/code&gt; , and Unicode only defines operations on code points up through that. But Perl works on code points up to the maximum permissible unsigned number available on the platform. However, Perl will not accept these from input streams unless lax rules are being used, and will warn (using the warning category &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; , which is a sub-category of &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; ) if any are output.</source>
          <target state="translated">最大のUnicodeコードポイントは &lt;code&gt;U+10FFFF&lt;/code&gt; であり、Unicodeはそれまでのコードポイントに対する操作のみを定義します。しかし、Perlは、プラットフォームで利用可能な最大許容符号なし数までのコードポイントを処理します。しかし緩いルールが使用されていない限り、Perlは入力ストリームからこれらを受け付けない、及び（警告カテゴリ使用して警告する &lt;code&gt;&quot;non_unicode&quot;&lt;/code&gt; のサブカテゴリであり、 &lt;code&gt;&quot;utf8&quot;&lt;/code&gt; いずれかが出力されている場合）。</target>
        </trans-unit>
        <trans-unit id="6cc1808d3e3fb6de5739d08162d085e4fb2b2c51" translate="yes" xml:space="preserve">
          <source>The maximum number of parallel tests to run at any time. Which tests can be run in parallel is controlled by &lt;code&gt;rules&lt;/code&gt; . The default is to run only one test at a time.</source>
          <target state="translated">常に実行する並列テストの最大数。並行して実行できるテストは、 &lt;code&gt;rules&lt;/code&gt; によって制御されます。デフォルトでは、一度に1つのテストのみを実行します。</target>
        </trans-unit>
        <trans-unit id="0ec24717c6af4893fa65de730b8ddea405e13134" translate="yes" xml:space="preserve">
          <source>The maximum number this construct can express is &lt;code&gt;\777&lt;/code&gt; . If you need a larger one, you need to use &lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;\o{}&lt;/a&gt; instead. If you meant two separate things, you need to separate them:</source>
          <target state="translated">この構成で表現できる最大数は &lt;code&gt;\777&lt;/code&gt; です。より大きなものが必要な場合は、代わりに&lt;a href=&quot;perlrebackslash#Octal-escapes&quot;&gt;\ o {}&lt;/a&gt;を使用する必要があります。2つの別個のものを意味する場合は、それらを分離する必要があります。</target>
        </trans-unit>
        <trans-unit id="823e727fb7ce51ed0c50f11b0b5dce6f9f8c6422" translate="yes" xml:space="preserve">
          <source>The maximum size of a Storable header is currently 21 bytes. If the provided $buffer is only the first part of a Storable image it should at least be this long to ensure that read_magic() will recognize it as such.</source>
          <target state="translated">Storable ヘッダの最大サイズは現在 21 バイトです。提供された $buffer が Storable イメージの最初の部分だけである場合は、 read_magic()がそれをそのように認識するようにするために、少なくともこの長さにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="54655c72af2839e9f037d863fc7638dac7966cf0" translate="yes" xml:space="preserve">
          <source>The maximum size of an extra field 65535 bytes.</source>
          <target state="translated">エクストラフィールドの最大サイズ 65535 バイト。</target>
        </trans-unit>
        <trans-unit id="60da8f51a4ded24731bf101a405dc42107509236" translate="yes" xml:space="preserve">
          <source>The maximum size of the Extra Field 65535 bytes.</source>
          <target state="translated">エクストラフィールドの最大サイズ 65535 バイト。</target>
        </trans-unit>
        <trans-unit id="51d29e4ee16b1b5f77f1b62a7cfc84201aec0810" translate="yes" xml:space="preserve">
          <source>The maximum system file descriptor, ordinarily 2. System file descriptors are passed to &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;ed processes, while higher file descriptors are not. Also, during an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, system file descriptors are preserved even if the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; fails (ordinary file descriptors are closed before the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; is attempted). The close-on-exec status of a file descriptor will be decided according to the value of &lt;code&gt;$^F&lt;/code&gt; when the corresponding file, pipe, or socket was opened, not the time of the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最大システムファイル記述子。通常は2。システムファイル記述子は &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; edプロセスに渡されますが、上位のファイル記述子は渡されません。また、中に &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 、システムファイル記述子があっても保存されている &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 失敗した（通常のファイル記述子が前に閉鎖されている &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; しようとしています）。ファイル記述子のclose-on-execステータスは、 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; の時刻ではなく、対応するファイル、パイプ、またはソケットが開かれたときの &lt;code&gt;$^F&lt;/code&gt; 値に従って決定されます。</target>
        </trans-unit>
        <trans-unit id="db9125f66ae949d81694c6e6210bfeb871e3d64e" translate="yes" xml:space="preserve">
          <source>The mechanism of translation of &lt;code&gt;\N{...}&lt;/code&gt; escapes is general and not hardwired into</source>
          <target state="translated">&lt;code&gt;\N{...}&lt;/code&gt; エスケープの変換メカニズムは一般的であり、ハードワイヤードされていません</target>
        </trans-unit>
        <trans-unit id="15610051fc12501695115ef5aed4c6968c7a9267" translate="yes" xml:space="preserve">
          <source>The members whose names begin with &lt;code&gt;int_p_&lt;/code&gt; and &lt;code&gt;int_n_&lt;/code&gt; were added by POSIX.1-2008 and are only available on systems that support them.</source>
          <target state="translated">名前が &lt;code&gt;int_p_&lt;/code&gt; および &lt;code&gt;int_n_&lt;/code&gt; で始まるメンバーはPOSIX.1-2008によって追加され、それらをサポートするシステムでのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="36545165ac282d6d6bbbc3b54b056ad82f2d5183" translate="yes" xml:space="preserve">
          <source>The message, either sent via &lt;code&gt;datasend&lt;/code&gt; or as the &lt;code&gt;MESSAGE&lt;/code&gt; parameter, must be in the format as described by RFC822 and must contain From:, Newsgroups: and Subject: headers.</source>
          <target state="translated">&lt;code&gt;datasend&lt;/code&gt; を介して、または &lt;code&gt;MESSAGE&lt;/code&gt; パラメータとして送信されるメッセージは、RFC822で記述されている形式である必要があり、From：、Newsgroups :、およびSubject：ヘッダーを含む必要があります。</target>
        </trans-unit>
        <trans-unit id="ee89b7499807e434bb5f68dbb5e73957271240a3" translate="yes" xml:space="preserve">
          <source>The messages are in alphabetical order, without regard to upper or lower-case. Some of these messages are generic. Spots that vary are denoted with a %s or other printf-style escape. These escapes are ignored by the alphabetical order, as are all characters other than letters. To look up your message, just ignore anything that is not a letter.</source>
          <target state="translated">メッセージはアルファベット順で、大文字・小文字に関係なく表示されています。これらのメッセージの中には一般的なものもあります。変化する箇所は %s やその他の printf スタイルのエスケープで示されます。これらのエスケープは、文字以外のすべての文字と同様に、 アルファベット順では無視されます。メッセージを調べるには、文字以外のものは無視してください。</target>
        </trans-unit>
        <trans-unit id="e3b332cdd50b0075e2980a517442567c35047868" translate="yes" xml:space="preserve">
          <source>The messages from error exits from inside the Perl core are generally more serious, and are not suppressed.</source>
          <target state="translated">Perlコア内部からのエラー終了のメッセージは、一般的にはより深刻なものであり、抑制されていません。</target>
        </trans-unit>
        <trans-unit id="1808948aa8eaa300120a3b2e59e72e75d61ea383" translate="yes" xml:space="preserve">
          <source>The metaconfig system has its own git repository. Please see its README file in &lt;a href=&quot;http://perl5.git.perl.org/metaconfig.git/&quot;&gt;http://perl5.git.perl.org/metaconfig.git/&lt;/a&gt; for more details.</source>
          <target state="translated">metaconfigシステムには独自のgitリポジトリがあります。詳細については、&lt;a href=&quot;http://perl5.git.perl.org/metaconfig.git/&quot;&gt;http：&lt;/a&gt; //perl5.git.perl.org/metaconfig.git/にあるREADMEファイルを参照してください。</target>
        </trans-unit>
        <trans-unit id="57044926f6935330105dc7655b75810e4319d78e" translate="yes" xml:space="preserve">
          <source>The metanotation &lt;code&gt;a{b,c,d}e&lt;/code&gt; is a shorthand for &lt;code&gt;abe ace ade&lt;/code&gt; . Left to right order is preserved, with results of matches being sorted separately at a low level to preserve this order. As a special case &lt;code&gt;{&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt; are passed undisturbed.</source>
          <target state="translated">メタ表記 &lt;code&gt;a{b,c,d}e&lt;/code&gt; は &lt;code&gt;abe ace ade&lt;/code&gt; の省略形です。左から右の順序が保持され、一致の結果はこの順序を保持するために低レベルで個別にソートされます。特殊なケースとして、 &lt;code&gt;{&lt;/code&gt; 、 &lt;code&gt;}&lt;/code&gt; 、および &lt;code&gt;{}&lt;/code&gt; がそのまま渡されます。</target>
        </trans-unit>
        <trans-unit id="3047e3773833dff832f2198e8a9edf5e427dcdc4" translate="yes" xml:space="preserve">
          <source>The method &lt;b&gt;simplify_name&lt;/b&gt; is equivalent to &lt;b&gt;basename&lt;/b&gt;, but also strips Perl-like extensions (.pm, .pl, .pod) and extensions like</source>
          <target state="translated">&lt;b&gt;単純化&lt;/b&gt;メソッドは&lt;b&gt;basename&lt;/b&gt;と同等ですが、Perlのような拡張子（.pm、.pl、.pod）と次のような拡張子も取り除きます。</target>
        </trans-unit>
        <trans-unit id="81b66f93d3069f9e60e8cef6e91ea8cf83a141d7" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;pretty&lt;/code&gt; is doing object-to-string conversion, so it is natural to overload the operator &lt;code&gt;&quot;&quot;&lt;/code&gt; using this method. However, inside such a method it is not necessary to pretty-print the</source>
          <target state="translated">メソッド &lt;code&gt;pretty&lt;/code&gt; はオブジェクトから文字列への変換を行うため、このメソッドを使用して演算子 &lt;code&gt;&quot;&quot;&lt;/code&gt; をオーバーロードするのは自然なことです。ただし、そのようなメソッドの内部では、</target>
        </trans-unit>
        <trans-unit id="a6763bc5ce44c1cfaff83e339121fc03fa4b9167" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;survey&lt;/code&gt; searches for POD documents in a given set of files and/or directories. This runs the search according to the various options set by the accessors above. (For example, if the &lt;code&gt;inc&lt;/code&gt; attribute is on, as it is by default, then the perl @INC directories are implicitly added to the list of directories (if any) that you specify.)</source>
          <target state="translated">メソッド &lt;code&gt;survey&lt;/code&gt; は、指定されたファイルやディレクトリのセットでPODドキュメントを検索します。これにより、上記のアクセサーによって設定されたさまざまなオプションに従って検索が実行されます。（たとえば、デフォルトで &lt;code&gt;inc&lt;/code&gt; 属性がオンの場合、perl @INCディレクトリは、指定したディレクトリ（存在する場合）のリストに暗黙的に追加されます。）</target>
        </trans-unit>
        <trans-unit id="c2594fdbf7af0dec9dd0b0469d5ba6b9ac83d4b7" translate="yes" xml:space="preserve">
          <source>The method forms return the object itself when called with arguments, so that they can be chained together nicely.</source>
          <target state="translated">メソッドのフォームは、引数で呼び出されたときにオブジェクト自体を返すので、それらをきれいに連鎖させることができます。</target>
        </trans-unit>
        <trans-unit id="2dce83e2cc72bad00d236d5c3647c5845395811f" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; $scalar, classname&lt;/code&gt; . Associates a new scalar instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="translated">コマンド &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; $scalar, classname&lt;/code&gt; によって呼び出されるメソッド。新しいスカラーインスタンスを指定されたクラスに関連付けます。 &lt;code&gt;LIST&lt;/code&gt; は、関連付けを完了するために必要な追加の引数（&lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt;およびcompatriotsの行に沿った）を表します。</target>
        </trans-unit>
        <trans-unit id="1329855cb3bc4e49bb5ad4447529605d17972380" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; %hash, classname&lt;/code&gt; . Associates a new hash instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="translated">コマンド &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; %hash, classname&lt;/code&gt; によって呼び出されるメソッド。新しいハッシュインスタンスを指定されたクラスに関連付けます。 &lt;code&gt;LIST&lt;/code&gt; は、関連付けを完了するために必要な追加の引数（&lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt;およびcompatriotsの行に沿った）を表します。</target>
        </trans-unit>
        <trans-unit id="f4e115efd5b349da6e5daf0e7907f6b8a0251fea" translate="yes" xml:space="preserve">
          <source>The method invoked by the command &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; *glob, classname&lt;/code&gt; . Associates a new glob instance with the specified class. &lt;code&gt;LIST&lt;/code&gt; would represent additional arguments (along the lines of &lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt; and compatriots) needed to complete the association.</source>
          <target state="translated">コマンド &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt; *glob, classname&lt;/code&gt; によって呼び出されるメソッド。指定されたクラスに新しいグロブインスタンスを関連付けます。 &lt;code&gt;LIST&lt;/code&gt; は、関連付けを完了するために必要な追加の引数（&lt;a href=&quot;../anydbm_file&quot;&gt;AnyDBM_File&lt;/a&gt;およびcompatriotsの行に沿った）を表します。</target>
        </trans-unit>
        <trans-unit id="bf5b5c7ccd1b01e888481ba1e2326ba23ba62558" translate="yes" xml:space="preserve">
          <source>The method may be called as a function (this is the legacy interface) and will then use a singleton as invocant.</source>
          <target state="translated">このメソッドは関数として呼ばれ(これはレガシーインターフェースです)、シングルトンをインボカントとして使用します。</target>
        </trans-unit>
        <trans-unit id="4e8494bae7398a8984704473fee4ce9cba1c67c3" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; are not defined in &lt;b&gt;Tie::Hash&lt;/b&gt;, &lt;b&gt;Tie::StdHash&lt;/b&gt;, or &lt;b&gt;Tie::ExtraHash&lt;/b&gt;. Tied hashes do not require presence of these methods, but if defined, the methods will be called in proper time, see &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt;.</source>
          <target state="translated">メソッド &lt;code&gt;UNTIE&lt;/code&gt; および &lt;code&gt;DESTROY&lt;/code&gt; は、&lt;b&gt;Tie :: Hash&lt;/b&gt;、&lt;b&gt;Tie :: StdHash&lt;/b&gt;、または&lt;b&gt;Tie :: ExtraHashで&lt;/b&gt;定義されていません。タイハッシュはこれらのメソッドの存在を必要としませんが、定義されている場合、メソッドは適切なタイミングで呼び出されます&lt;a href=&quot;../perltie&quot;&gt;。perltieを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="eb0efdfb2d42a690264f248f711dbbf09fd69f9a" translate="yes" xml:space="preserve">
          <source>The methods POP, PUSH, SHIFT, UNSHIFT, SPLICE, DELETE, and EXISTS are required if the perl operator with the corresponding (but lowercase) name is to operate on the tied array. The &lt;b&gt;Tie::Array&lt;/b&gt; class can be used as a base class to implement the first five of these in terms of the basic methods above. The default implementations of DELETE and EXISTS in &lt;b&gt;Tie::Array&lt;/b&gt; simply &lt;code&gt;croak&lt;/code&gt; .</source>
          <target state="translated">POP、PUSH、SHIFT、UNSHIFT、SPLICE、DELETE、およびEXISTSのメソッドは、対応する（小文字の）名前を持つperl演算子が結合配列を操作する場合に必要です。&lt;b&gt;タイ::配列の&lt;/b&gt;クラスは、上記の基本的な方法の点で、これらの最初の5つを実装するための基本クラスとして使用することができます。&lt;b&gt;Tie :: Array&lt;/b&gt;のDELETEおよびEXISTSのデフォルト実装は、単に &lt;code&gt;croak&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3ca020c3e2bd3840f09ecda9c60cedd92ab50da2" translate="yes" xml:space="preserve">
          <source>The methods associated with a file might include &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ファイルに関連付けられたメソッドには、 &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; が含まれる場合があります。</target>
        </trans-unit>
        <trans-unit id="5263ae238fdcff040734aa4eb38a1f937d29acc1" translate="yes" xml:space="preserve">
          <source>The methods make the assumption that there are 24 hours in a day, 7 days in a week, 365.24225 days in a year and 12 months in a year. (from The Calendar FAQ at &lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt;)</source>
          <target state="translated">この方法では、1日は24時間、1週間は7日、1年は365.24225日、1年は12か月であると想定しています。（&lt;a href=&quot;http://www.tondering.dk/claus/calendar.html&quot;&gt;http://www.tondering.dk/claus/calendar.html&lt;/a&gt;のカレンダーFAQから）</target>
        </trans-unit>
        <trans-unit id="04b489e4d842d7bd01e6f982c6cbb73f631b2bc2" translate="yes" xml:space="preserve">
          <source>The methods provided by this package are designed to be used in conjunction with ExtUtils::MakeMaker. When MakeMaker writes a Makefile, it creates one or more objects that inherit their methods from a package &lt;code&gt;MM&lt;/code&gt; . MM itself doesn't provide any methods, but it ISA ExtUtils::MM_Unix class. The inheritance tree of MM lets operating specific packages take the responsibility for all the methods provided by MM_Unix. We are trying to reduce the number of the necessary overrides by defining rather primitive operations within ExtUtils::MM_Unix.</source>
          <target state="translated">このパッケージが提供するメソッドは、ExtUtils :: MakeMakerと組み合わせて使用​​するように設計されています。MakeMakerはMakefileを書き込むときに、パッケージ &lt;code&gt;MM&lt;/code&gt; からメソッドを継承する1つ以上のオブジェクトを作成します。MM自体はメソッドを提供しませんが、ISA ExtUtils :: MM_Unixクラスを提供します。MMの継承ツリーにより、特定のパッケージを操作することで、MM_Unixが提供するすべてのメソッドを担当できます。ExtUtils :: MM_Unix内でかなりプリミティブな操作を定義することにより、必要なオーバーライドの数を削減しようとしています。</target>
        </trans-unit>
        <trans-unit id="8c66ae4f45a17e24ec4e91baabbe3addbe06fe69" translate="yes" xml:space="preserve">
          <source>The methods return a status value. All return 0 on success. All return -1 to signify an error and set &lt;code&gt;$!&lt;/code&gt; to the exact error code. The return code 1 generally (but not always) means that the key specified did not exist in the database.</source>
          <target state="translated">メソッドはステータス値を返します。成功すると、すべて0を返します。エラーを示すために-1を返し、 &lt;code&gt;$!&lt;/code&gt; を設定します。正確なエラーコードに。戻りコード1は、通常（常にではありません）、指定されたキーがデータベースに存在しなかったことを意味します。</target>
        </trans-unit>
        <trans-unit id="fbd4260de22fedf44d365a30940fb70d70e7661e" translate="yes" xml:space="preserve">
          <source>The methods return true if the argument is positive or negative, respectively. &lt;code&gt;NaN&lt;/code&gt; is neither positive nor negative, while &lt;code&gt;+inf&lt;/code&gt; counts as positive, and &lt;code&gt;-inf&lt;/code&gt; is negative. A &lt;code&gt;zero&lt;/code&gt; is neither positive nor negative.</source>
          <target state="translated">引数が正または負の場合、メソッドはそれぞれtrueを返します。 &lt;code&gt;NaN&lt;/code&gt; は正でも負でもありませんが、 &lt;code&gt;+inf&lt;/code&gt; は正としてカウントされ、 &lt;code&gt;-inf&lt;/code&gt; は負です。 &lt;code&gt;zero&lt;/code&gt; どちらも正でも負です。</target>
        </trans-unit>
        <trans-unit id="6c2ef40bc1a0b74efb3bfbccd9cee9239eba6f64" translate="yes" xml:space="preserve">
          <source>The midpoint between London and Tokyo being</source>
          <target state="translated">ロンドンと東京の中間地点である</target>
        </trans-unit>
        <trans-unit id="bbcb1c9041fb73d5b33a27311e97c3d17c5b0e33" translate="yes" xml:space="preserve">
          <source>The minimal implementation of the package &lt;code&gt;MyMaths&lt;/code&gt; would be something like this:</source>
          <target state="translated">&lt;code&gt;MyMaths&lt;/code&gt; パッケージの最小限の実装は次のようになります。</target>
        </trans-unit>
        <trans-unit id="3d4726f2195d659bbd07fd552c77e45ca0215cb6" translate="yes" xml:space="preserve">
          <source>The minimal length of the match.</source>
          <target state="translated">試合の最短距離。</target>
        </trans-unit>
        <trans-unit id="7a86715e4677adbc552d12f74a0aff8aa19f9b9f" translate="yes" xml:space="preserve">
          <source>The minimal string that will allow both the start of the string &lt;code&gt;^&lt;/code&gt; and the alternation to match is &lt;code&gt;Th&lt;/code&gt; , with the alternation &lt;code&gt;e|r&lt;/code&gt; matching &lt;code&gt;e&lt;/code&gt; . The second quantifier &lt;code&gt;.*&lt;/code&gt; is free to gobble up the rest of the string.</source>
          <target state="translated">文字列 &lt;code&gt;^&lt;/code&gt; の開始と代替の一致の両方を可能にする最小の文字列は &lt;code&gt;Th&lt;/code&gt; で、代替 &lt;code&gt;e|r&lt;/code&gt; &lt;code&gt;e&lt;/code&gt; に一致します。2番目の量指定子 &lt;code&gt;.*&lt;/code&gt; は、残りの文字列を自由に移動できます。</target>
        </trans-unit>
        <trans-unit id="e954716b49cb8b56dd5f1434ce35c364bc034cbd" translate="yes" xml:space="preserve">
          <source>The minimum required version of Perl for this distribution.</source>
          <target state="translated">このディストリビューションに必要なPerlの最小バージョン。</target>
        </trans-unit>
        <trans-unit id="8f285323eacf0d3787ce2842089aae064f612899" translate="yes" xml:space="preserve">
          <source>The minimum severity level set by &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; mode may be changed to be ERROR or higher in the future depending on the results of testing and further review.</source>
          <target state="translated">最小重大度レベルセット &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; に &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; のモードは、テストとさらなるレビューの結果に応じて、将来のエラーまたは高くなるように変更することができます。</target>
        </trans-unit>
        <trans-unit id="a0eb7e9cbc117a074d8972fb43eb29ea9f494777" translate="yes" xml:space="preserve">
          <source>The minimum string length (in characters) required for the pattern to match. This is used to prune the search space by not bothering to match any closer to the end of a string than would allow a match. For instance there is no point in even starting the regex engine if the minlen is 10 but the string is only 5 characters long. There is no way that the pattern can match.</source>
          <target state="translated">パターンがマッチするために必要な最小文字列長(文字数)。これは、文字列の末尾に近いものはわざわざマッチさせないようにして、検索スペースを狭くするために使われます。例えば、minlenが10であっても文字列の長さが5文字しかない場合、正規表現エンジンを起動する意味がありません。パターンがマッチするわけがありません。</target>
        </trans-unit>
        <trans-unit id="210162554d25993f24361ef0d0eb6d7705ae9f1e" translate="yes" xml:space="preserve">
          <source>The mkpath() function provide the legacy interface of make_path() with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to make_path().</source>
          <target state="translated">mkpath()関数は、make_path()のレガシーインターフェースを提供し、渡された引数の異なる解釈を提供します。この関数の動作と戻り値は、それ以外は make_path()と同じです。</target>
        </trans-unit>
        <trans-unit id="06ad56158c8fa5ced75a1aebddb172710774c3d6" translate="yes" xml:space="preserve">
          <source>The mode argument should be a string as would be passed to fopen/PerlIO_open. If it is NULL then - for legacy support - the code will (depending upon the platform and the implementation) either attempt to empirically determine the mode in which</source>
          <target state="translated">mode 引数は、fopen/PerlIO_open に渡される文字列でなければなりません。これがNULLの場合、レガシーサポートのため、コードは(プラットフォームと実装に応じて)経験的に</target>
        </trans-unit>
        <trans-unit id="a3c9e181407a3d8dbcbede503e296bb6515c64a6" translate="yes" xml:space="preserve">
          <source>The modern convention for OO modules is to always use &lt;code&gt;new&lt;/code&gt; as the name for the constructor, but there is no requirement to do so. Any subroutine that blesses a data structure into a class is a valid constructor in Perl.</source>
          <target state="translated">OOモジュールの最新の規則では、常に &lt;code&gt;new&lt;/code&gt; をコンストラクターの名前として使用しますが、そうする必要はありません。データ構造をクラスに祝福するすべてのサブルーチンは、Perlで有効なコンストラクターです。</target>
        </trans-unit>
        <trans-unit id="3a53357f11465725d38d814ff941d393401ed024" translate="yes" xml:space="preserve">
          <source>The module</source>
          <target state="translated">モジュール</target>
        </trans-unit>
        <trans-unit id="39e5705c3d4c65fd8c41a20a40b57ad45ad89ac2" translate="yes" xml:space="preserve">
          <source>The module actually implements most of an interface described by Larry Wall on the perl5-porters mailing list here: &lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&quot;&gt;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&lt;/a&gt;</source>
          <target state="translated">このモジュールは実際には、ここのperl5-portersメーリングリストでLarry Wallによって記述されているほとんどのインターフェイスを実装してい&lt;a href=&quot;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html&quot;&gt;ます。http&lt;/a&gt;：//www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2000-01/msg00241.html</target>
        </trans-unit>
        <trans-unit id="4eac150fbe415255f3cdb34d1744497bc9492853" translate="yes" xml:space="preserve">
          <source>The module also lets you save intermediate SHA states to a string. The</source>
          <target state="translated">このモジュールでは、中間的な SHA の状態を文字列に保存することもできます。このモジュールでは、中間的なSHA状態を文字列に保存することもできます。</target>
        </trans-unit>
        <trans-unit id="ee711fa1cc9e23459ad1dea67a4bc2640b9361b2" translate="yes" xml:space="preserve">
          <source>The module and its user have a contract, part of which is common law, and part of which is &quot;written&quot;. Part of the common law contract is that a module doesn't pollute any namespace it wasn't asked to. The written contract for the module (A.K.A. documentation) may make other provisions. But then you know when you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; RedefineTheWorld&lt;/code&gt; that you're redefining the world and willing to take the consequences.</source>
          <target state="translated">モジュールとそのユーザーには契約があり、その一部は慣習法であり、一部は「作成」されています。コモンロー契約の一部は、モジュールが要求されていない名前空間を汚染しないことです。モジュールの書面による契約（別名ドキュメンテーション）は他の規定を作成する場合があります。しかし、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; RedefineTheWorld&lt;/code&gt; を&lt;a href=&quot;functions/use&quot;&gt;使用する&lt;/a&gt;と、世界を再定義し、結果を受け入れる用意があることがわかります。</target>
        </trans-unit>
        <trans-unit id="b0f631dbc58be0710de0b64e0128de801aadc778" translate="yes" xml:space="preserve">
          <source>The module appropriate for the current OS is automatically loaded by File::Spec. Since some modules (like VMS) make use of facilities available only under that OS, it may not be possible to load all modules under all operating systems.</source>
          <target state="translated">現在のOSに適したモジュールは、File::Specによって自動的にロードされます。一部のモジュール(VMSなど)は、そのOSでしか利用できない機能を利用しているため、すべてのOSですべてのモジュールをロードすることはできない場合があります。</target>
        </trans-unit>
        <trans-unit id="f14f53ac2830f28434b0714747d843bf7a9d032c" translate="yes" xml:space="preserve">
          <source>The module author loves to hear how &lt;code&gt;autodie&lt;/code&gt; has made your life better (or worse). Feedback can be sent to &amp;lt;pjf@perltraining.com.au&amp;gt;.</source>
          <target state="translated">モジュールの作成者は、 &lt;code&gt;autodie&lt;/code&gt; があなたの人生をどのように改善（または悪化）させたかを聞くのが大好きです。フィードバックは&amp;lt;pjf@perltraining.com.au&amp;gt;に送信できます。</target>
        </trans-unit>
        <trans-unit id="64e716d94d3201717e95856fa71dba02b691c1e4" translate="yes" xml:space="preserve">
          <source>The module functionality relies on symbolic references, so things will break under 'use strict' unless 'no strict &quot;refs&quot;' is also specified.</source>
          <target state="translated">モジュールの機能はシンボリック参照に依存しているので、'use strict' の下では 'no strict &quot;refs&quot;' が指定されていないと壊れてしまいます。</target>
        </trans-unit>
        <trans-unit id="34dfe6e94b964deab3088dd9f024d26797644959" translate="yes" xml:space="preserve">
          <source>The module is used to replace common UNIX commands. In all cases the functions work from @ARGV rather than taking arguments. This makes them easier to deal with in Makefiles. Call them like this:</source>
          <target state="translated">このモジュールは、一般的な UNIX コマンドを置き換えるために使用されます。すべての場合において、関数は引数を取るのではなく @ARGV から動作します。これにより、Makefile での扱いがより簡単になります。このように呼んでください。</target>
        </trans-unit>
        <trans-unit id="c671baea2f821aba32cfc72c5c947bba8fda15dc" translate="yes" xml:space="preserve">
          <source>The module might issue the following warnings:</source>
          <target state="translated">モジュールは以下のような警告を発することがあります。</target>
        </trans-unit>
        <trans-unit id="06580747828c7d751b4066d4d4c51e0e99e3ed97" translate="yes" xml:space="preserve">
          <source>The module that implements the canned filter can take one of two forms. Here is a template for the first</source>
          <target state="translated">定型フィルタを実装したモジュールは、2つの形式のうちの1つをとることができます。最初の形式のテンプレートは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="aa3f15cb2c51087f06437c33aa4d5adadaa3850c" translate="yes" xml:space="preserve">
          <source>The module will auto-detect which, if any, of the supported compression formats is being used.</source>
          <target state="translated">このモジュールは、サポートされている圧縮フォーマットが使用されている場合には、自動検出します。</target>
        </trans-unit>
        <trans-unit id="f166adc5fd8c563e508f523c65a82ae50be2d86f" translate="yes" xml:space="preserve">
          <source>The month (&lt;code&gt;mon&lt;/code&gt; ), weekday (&lt;code&gt;wday&lt;/code&gt; ), and yearday (&lt;code&gt;yday&lt;/code&gt; ) begin at zero,</source>
          <target state="translated">月（ &lt;code&gt;mon&lt;/code&gt; ）、平日（ &lt;code&gt;wday&lt;/code&gt; ）、および年日（ &lt;code&gt;yday&lt;/code&gt; ）はゼロから始まり、</target>
        </trans-unit>
        <trans-unit id="7976bab032857556f1afeeb5486bc37536242264" translate="yes" xml:space="preserve">
          <source>The months and years can be negative for subtractions. Note that there is some &quot;strange&quot; behaviour when adding and subtracting months at the ends of months. Generally when the resulting month is shorter than the starting month then the number of overlap days is added. For example subtracting a month from 2008-03-31 will not result in 2008-02-31 as this is an impossible date. Instead you will get 2008-03-02. This appears to be consistent with other date manipulation tools.</source>
          <target state="translated">月と年は、引き算ではマイナスになることがあります。月の終わりに月を足したり引いたりするときには、いくつかの &quot;奇妙な &quot;挙動があることに注意してください。一般的に、結果の月が開始月よりも短い場合は、重複日数が加算されます。例えば、2008-03-31 から月を引いても 2008-02-31 にはならないので、2008-02-31 にはなりません。代わりに 2008-03-02 が得られます。これは他の日付操作ツールと一致しているようです。</target>
        </trans-unit>
        <trans-unit id="6b9450d19149fb47c1c53f97698b4be633a15d56" translate="yes" xml:space="preserve">
          <source>The more you think about interfacing between two languages, the more you'll realize that the majority of programmer effort has to go into converting between the data structures that are native to either of the languages involved. This trumps other matter such as differing calling conventions because the problem space is so much greater. There are simply more ways to shove data into memory than there are ways to implement a function call.</source>
          <target state="translated">2 つの言語間のインターフェースについて考えれば考えるほど、プログラマーの努力の大部分は、どちらかの言語に固有のデータ構造間の変換に費やさなければならないことに気づくでしょう。これは、問題空間が非常に大きくなるため、呼び出し規約の違いなどの他の問題に勝るものではありません。関数呼び出しを実装する方法よりも、メモリにデータを押し込む方法の方が単純に多いのです。</target>
        </trans-unit>
        <trans-unit id="8176a4ffeb356c4a7a23ddcef37f49bf2bb9d8e2" translate="yes" xml:space="preserve">
          <source>The mortal routines are not just for SVs; AVs and HVs can be made mortal by passing their address (type-casted to &lt;code&gt;SV*&lt;/code&gt; ) to the &lt;code&gt;sv_2mortal&lt;/code&gt; or &lt;code&gt;sv_mortalcopy&lt;/code&gt; routines.</source>
          <target state="translated">致命的なルーチンはSVだけのものではありません。AVとHVは、それらのアドレス（ &lt;code&gt;SV*&lt;/code&gt; 型キャストされた）を &lt;code&gt;sv_2mortal&lt;/code&gt; または &lt;code&gt;sv_mortalcopy&lt;/code&gt; ルーチンに渡すことで致命的にすることができます。</target>
        </trans-unit>
        <trans-unit id="9a1cfa37e915685db47ff38f6021965013b98c8b" translate="yes" xml:space="preserve">
          <source>The most common CPAN version numbering scheme looks like this:</source>
          <target state="translated">最も一般的なCPANのバージョンナンバリングスキームは次のようになります。</target>
        </trans-unit>
        <trans-unit id="2c4361ab99106fa73a1bb41dd2c636e6a27fcbec" translate="yes" xml:space="preserve">
          <source>The most common example of this is changing the current working directory using &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;. One thread calls &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;, and the working directory of all the threads changes.</source>
          <target state="translated">この最も一般的な例は、 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; を使用して現在の作業ディレクトリを変更することです。1つのスレッドが &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; を呼び出し、すべてのスレッドの作業ディレクトリが変更されます。</target>
        </trans-unit>
        <trans-unit id="9f63cc6de2a2448196e1a86a35300d77fbd9cdf9" translate="yes" xml:space="preserve">
          <source>The most common uses of the interactive modes are</source>
          <target state="translated">インタラクティブモードの最も一般的な使用方法は</target>
        </trans-unit>
        <trans-unit id="3870e4765effd8ab5e5da52360ab236ece22162c" translate="yes" xml:space="preserve">
          <source>The most commonly used of these functions is &lt;code&gt;Perl_sv_dump&lt;/code&gt; ; it's used for dumping SVs, AVs, HVs, and CVs. The &lt;code&gt;Devel::Peek&lt;/code&gt; module calls &lt;code&gt;sv_dump&lt;/code&gt; to produce debugging output from Perl-space, so users of that module should already be familiar with its format.</source>
          <target state="translated">これらの関数の中で最も一般的に使用されるのは &lt;code&gt;Perl_sv_dump&lt;/code&gt; です。SV、AV、HV、CVのダンプに使用されます。 &lt;code&gt;Devel::Peek&lt;/code&gt; モジュールコールは &lt;code&gt;sv_dump&lt;/code&gt; Perlの空間からのデバッグ出力を生成するので、そのモジュールのユーザーは既にそのフォーマットに精通している必要があります。</target>
        </trans-unit>
        <trans-unit id="b3104b20dd3af96ae7f833de8c6d7e1e79108b35" translate="yes" xml:space="preserve">
          <source>The most convenient way of installing a binary distribution of perl is via perl installer</source>
          <target state="translated">perl のバイナリディストリビューションをインストールする最も便利な方法は perl インストーラを使うことです。</target>
        </trans-unit>
        <trans-unit id="8449f9a2d2191f3c7392f9226647d2910704473a" translate="yes" xml:space="preserve">
          <source>The most efficient way is using &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; and &lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;. This is faster than using &lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt; when taking many, many strings. It is slower for just a few.</source>
          <target state="translated">最も効率的な方法は、&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;および&lt;a href=&quot;functions/unpack&quot;&gt;unpackを使用すること&lt;/a&gt;です。これは、多数の文字列を取得するときに&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;を使用するよりも高速です。少しだけ遅いです。</target>
        </trans-unit>
        <trans-unit id="22c40808afd7fc4cc79463965386f4682ff94dfa" translate="yes" xml:space="preserve">
          <source>The most hairy case</source>
          <target state="translated">一番毛が生えているケース</target>
        </trans-unit>
        <trans-unit id="51dfbd93c1252c67b5797f63c0a32f35baffd72d" translate="yes" xml:space="preserve">
          <source>The most important Perl parsing rule is the first one discussed below: when processing a quoted construct, Perl first finds the end of that construct, then interprets its contents. If you understand this rule, you may skip the rest of this section on the first reading. The other rules are likely to contradict the user's expectations much less frequently than this first one.</source>
          <target state="translated">最も重要なPerlの構文解析ルールは、後述する最初のルールです:引用された構文を処理するとき、Perlは最初にその構文の終わりを見つけ、次にその内容を解釈します。このルールを理解していれば、最初の読み物ではこのセクションの残りの部分を読み飛ばしても構いません。他のルールは、この最初のルールよりも、ユーザの期待に反している可能性が高いです。</target>
        </trans-unit>
        <trans-unit id="aef7d8dbf9d828ab96b855e0061e1f04b9541021" translate="yes" xml:space="preserve">
          <source>The most important attribute of a socket, like your telephone&amp;rsquo;s telephone number. Typically an IP address. See also &lt;b&gt;port&lt;/b&gt;.</source>
          <target state="translated">電話の電話番号など、ソケットの最も重要な属性。通常はIPアドレス。&lt;b&gt;ポート&lt;/b&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="8a25c59d901462fca0083edfc964d9c8bf518a04" translate="yes" xml:space="preserve">
          <source>The most important of which are probably GV_ADD and SVf_UTF8.</source>
          <target state="translated">その中で最も重要なのは、おそらくGV_ADDとSVf_UTF8でしょう。</target>
        </trans-unit>
        <trans-unit id="1aae52fef16fc25bcc3b6593dc3391e48196f1ad" translate="yes" xml:space="preserve">
          <source>The most important thing is to run your programs under the &lt;b&gt;-w&lt;/b&gt; flag at all times. You may turn it off explicitly for particular portions of code via the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;code&gt;$^W&lt;/code&gt; variable if you must. You should also always run under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; or know the reason why not. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; sigtrap&lt;/code&gt; and even &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; diagnostics&lt;/code&gt; pragmas may also prove useful.</source>
          <target state="translated">最も重要なことは、プログラムを常に&lt;b&gt;-w&lt;/b&gt;フラグの下で実行することです。必要であれば、 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings&lt;/code&gt; プラグマまたは &lt;code&gt;$^W&lt;/code&gt; 変数を使用して、コードの特定の部分に対して明示的にオフにすることができます。また、常に &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用条件で&lt;/a&gt;実行するか、そうでない理由を知っておく必要があります。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; sigtrap&lt;/code&gt; とさえ &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; diagnostics&lt;/code&gt; プラグマにも有用であろう。</target>
        </trans-unit>
        <trans-unit id="c6be7df730b69bf2abfbfef25c9c73eef66cdf79" translate="yes" xml:space="preserve">
          <source>The most important thing to understand about all data structures in Perl--including multidimensional arrays--is that even though they might appear otherwise, Perl &lt;code&gt;@ARRAY&lt;/code&gt; s and &lt;code&gt;%HASH&lt;/code&gt; es are all internally one-dimensional. They can hold only scalar values (meaning a string, number, or a reference). They cannot directly contain other arrays or hashes, but instead contain</source>
          <target state="translated">Perlのすべてのデータ構造（多次元配列を含む）について理解する最も重要なことは、そうでない場合でも、Perlの &lt;code&gt;@ARRAY&lt;/code&gt; と &lt;code&gt;%HASH&lt;/code&gt; はすべて内部的に1次元であることです。保持できるのはスカラー値（文字列、数値、または参照）だけです。他の配列やハッシュを直接含むことはできませんが、代わりに</target>
        </trans-unit>
        <trans-unit id="ae5f029eca08711d302dd8f17b7e7f9e635b1ec8" translate="yes" xml:space="preserve">
          <source>The most popular books</source>
          <target state="translated">最も人気のある本</target>
        </trans-unit>
        <trans-unit id="c77ae4b23596713f5e5db719e4b12df8a45dd104" translate="yes" xml:space="preserve">
          <source>The most practical use is likely to specify that some tests are not &quot;parallel-ready&quot;. Since mentioning a file with --rules doesn't cause it to be selected to run as a test, you can &quot;set and forget&quot; some rules preferences in your .proverc file. Then you'll be able to take maximum advantage of the performance benefits of parallel testing, while some exceptions are still run in parallel.</source>
          <target state="translated">最も実用的な使い方は、いくつかのテストが &quot;並列処理が可能 &quot;でないことを指定することでしょう。ファイルを --rules で指定してもテストとして実行するために選択されることはないので、.proverc ファイルの中でいくつかのルールの設定を「設定して忘れてしまう」ことができます。そうすれば、いくつかの例外は並列で実行される一方で、並列テストのパフォーマンスの利点を最大限に活用することができます。</target>
        </trans-unit>
        <trans-unit id="6f276b3b1a0cf0e0ed49a901109064669a604004" translate="yes" xml:space="preserve">
          <source>The most preferable one is &quot;The Default Unicode Collation Element Table&quot; (aka DUCET), available from the Unicode Consortium's website:</source>
          <target state="translated">最も好ましいのは、Unicodeコンソーシアムのウェブサイトから入手できる「The Default Unicode Collation Element Table」(別名:DUCET)です。</target>
        </trans-unit>
        <trans-unit id="1a2b184063d0bc0a35feb7fb346e45c3d6648eb5" translate="yes" xml:space="preserve">
          <source>The most recent development releases of Perl have been experimenting with removing Perl's dependency on the &quot;normal&quot; standard I/O suite and allowing other stdio implementations to be used. This involves creating a new abstraction layer that then calls whichever implementation of stdio Perl was compiled with. All XSUBs should now use the functions in the PerlIO abstraction layer and not make any assumptions about what kind of stdio is being used.</source>
          <target state="translated">Perl の最近の開発リリースでは、Perl の「通常の」標準 I/O スイートへの依存性を取り除き、他の stdio の実装を使用できるようにすることを試みてきました。これには、Perl がコンパイルされた stdio の実装を呼び出す新しい抽象化レイヤを作成することが含まれています。すべてのXSUBは、PerlIO抽象化レイヤの関数を使用し、どのような種類のstdioが使用されているかについては何も仮定しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="d790d27d68eef3be56d3d5afa1a5d1f30d794f18" translate="yes" xml:space="preserve">
          <source>The most recent upgrade to the PA-RISC design, it added support for 64-bit integer data.</source>
          <target state="translated">PA-RISCデザインへの最新のアップグレードでは、64ビット整数データのサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="0603f466834b0d6d823bdd46c3606b7ca755f71a" translate="yes" xml:space="preserve">
          <source>The most recent version of this module, including documentation and any news of importance, will be available at</source>
          <target state="translated">ドキュメントや重要なニュースを含むこのモジュールの最新バージョンは、次の場所で利用できます。</target>
        </trans-unit>
        <trans-unit id="f4a085ad231e217eed37777279430f48e1cf87a2" translate="yes" xml:space="preserve">
          <source>The most significant information in the output is about the particular</source>
          <target state="translated">出力の中で最も重要な情報は、特定の</target>
        </trans-unit>
        <trans-unit id="9de43c038dc457f71dc272efc26e8a4eb0e6b17e" translate="yes" xml:space="preserve">
          <source>The most simple options are the ones that take no values. Their mere presence on the command line enables the option. Popular examples are:</source>
          <target state="translated">最もシンプルなオプションは、値を取らないものです。コマンドライン上に存在するだけで、そのオプションが有効になります。よく使われる例は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="fe61ded48d4439fb9787ec0d115995f08935a048" translate="yes" xml:space="preserve">
          <source>The most useful option the cross referencer has is to save the report to a separate file. For instance, to save the report on</source>
          <target state="translated">クロスレファレンサが持つ最も便利なオプションは、レポートを別のファイルに保存することです。例えば、レポートを</target>
        </trans-unit>
        <trans-unit id="762e20af8acff77775848b01e093c2cac3013ec4" translate="yes" xml:space="preserve">
          <source>The most useful types that will be returned are:</source>
          <target state="translated">返される最も便利な型は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="a4f13e9fd0d66b114f604fe2129d7ad6d576d1c5" translate="yes" xml:space="preserve">
          <source>The movement of bits left or right in a computer word, which has the effect of multiplying or dividing by a power of 2.</source>
          <target state="translated">コンピュータのワードの中で、ビットが左右に移動することで、2の累乗または除算の効果があります。</target>
        </trans-unit>
        <trans-unit id="811ee2e71fefd4dbb8ec994c3d2df771d4653871" translate="yes" xml:space="preserve">
          <source>The multiple-bracket form does not affect the interpretation of the contents of the formatting code, only how it must end. That means that the examples above are also exactly the same as this:</source>
          <target state="translated">複数括弧の形式は、書式コードの内容の解釈には影響を与えず、どのように終わらせなければならないかだけです。つまり、上の例もこれと全く同じです。</target>
        </trans-unit>
        <trans-unit id="e2632e91c7e1b901a77d044556dbd4ff9d5c87be" translate="yes" xml:space="preserve">
          <source>The name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f32c3c3ac333fcf1879195759e18947b403def2d" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;new&lt;/code&gt; isn't special. We could name our constructor something else:</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 名前は特別ではありません。コンストラクタに別の名前を付けることができます。</target>
        </trans-unit>
        <trans-unit id="316e7deb3997f109974511d20499a1d93aa6493c" translate="yes" xml:space="preserve">
          <source>The name is returned as a mortal SV.</source>
          <target state="translated">名前は死亡したSVとして返されます。</target>
        </trans-unit>
        <trans-unit id="e84fcc4ee47e1e1b5639888428e055c00959431a" translate="yes" xml:space="preserve">
          <source>The name may contain embedded E&amp;lt;&amp;gt; and Z&amp;lt;&amp;gt; formatting codes, and the section, anchor text, and inferred anchor text may contain any formatting codes. Any double quotes around the section are removed as part of the parsing, as is any leading or trailing whitespace.</source>
          <target state="translated">名前には、埋め込まれたE &amp;lt;&amp;gt;およびZ &amp;lt;&amp;gt;書式コードを含めることができ、セクション、アンカーテキスト、および推定アンカーテキストには、書式コードを含めることができます。セクションを囲む二重引用符は、先頭または末尾の空白と同様に、解析の一部として削除されます。</target>
        </trans-unit>
        <trans-unit id="9f683b00c5db230ebae95056480292ae0fa37d30" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;(*SKIP:NAME)&lt;/code&gt; pattern has special significance. If a &lt;code&gt;(*MARK:NAME)&lt;/code&gt; was encountered while matching, then it is that position which is used as the &quot;skip point&quot;. If no &lt;code&gt;(*MARK)&lt;/code&gt; of that name was encountered, then the &lt;code&gt;(*SKIP)&lt;/code&gt; operator has no effect. When used without a name the &quot;skip point&quot; is where the match point was when executing the (*SKIP) pattern.</source>
          <target state="translated">名前 &lt;code&gt;(*SKIP:NAME)&lt;/code&gt; パターンは特別な意味を持っています。場合 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; はマッチング中に発生し、それは「ポイントをスキップ」として使用される位置です。その名前の &lt;code&gt;(*MARK)&lt;/code&gt; が検出されなかった場合、 &lt;code&gt;(*SKIP)&lt;/code&gt; 演算子は無効です。名前なしで使用した場合、「スキップポイント」は、（* SKIP）パターンを実行したときのマッチポイントの場所です。</target>
        </trans-unit>
        <trans-unit id="4ffbfa835ecb6cb544ad106cd35f35360cfc377b" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;result_class&lt;/code&gt; . Defaults to &lt;code&gt;App::Prove::State::Result&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;result_class&lt;/code&gt; の名前。デフォルトは &lt;code&gt;App::Prove::State::Result&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="689345a6c608b08f0da8c40d1de1f0d6ad537fb4" translate="yes" xml:space="preserve">
          <source>The name of the C subroutine generated which will return the constants. The default is</source>
          <target state="translated">定数を返す生成されたCサブルーチンの名前です。デフォルトは</target>
        </trans-unit>
        <trans-unit id="24928164de71defca77ef40b5800aabbee56b274" translate="yes" xml:space="preserve">
          <source>The name of the Makefile to be produced. This is used for the second Makefile that will be produced for the MAP_TARGET.</source>
          <target state="translated">生成される Makefile の名前です。これは、MAP_TARGET用に生成される2番目のMakefileに使用されます。</target>
        </trans-unit>
        <trans-unit id="586bd0a2b6cddbba1d51a20c05e33d4e435a88ba" translate="yes" xml:space="preserve">
          <source>The name of the OP, or 'ex-foo' if the OP is a null that used to be a foo.</source>
          <target state="translated">OPの名前、OPがnullの場合は'ex-foo'となります。</target>
        </trans-unit>
        <trans-unit id="5c8f940ac3ab77f3cca6bf5d7c2332906bee0772" translate="yes" xml:space="preserve">
          <source>The name of the array containing the &lt;b&gt;argument&lt;/b&gt;&lt;b&gt;vector&lt;/b&gt; from the command line. If you use the empty &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator, &lt;code&gt;ARGV&lt;/code&gt; is the name of both the &lt;b&gt;filehandle&lt;/b&gt; used to traverse the arguments and the &lt;b&gt;scalar&lt;/b&gt; containing the name of the current input file.</source>
          <target state="translated">コマンドラインからの&lt;b&gt;引数&lt;/b&gt;&lt;b&gt;ベクトル&lt;/b&gt;を含む配列の名前。空の &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 演算子を使用する場合、 &lt;code&gt;ARGV&lt;/code&gt; は、引数をトラバースするために使用される&lt;b&gt;ファイルハンドル&lt;/b&gt;と、現在の入力ファイルの名前を含む&lt;b&gt;スカラー&lt;/b&gt;の両方の名前です。</target>
        </trans-unit>
        <trans-unit id="c0ef9637fb40c44d741c359416d9acc461c4754b" translate="yes" xml:space="preserve">
          <source>The name of the capability to be output.</source>
          <target state="translated">出力するケイパビリティの名前。</target>
        </trans-unit>
        <trans-unit id="65cd22adf72a74a4b456151c3e1d9f81b33d09a6" translate="yes" xml:space="preserve">
          <source>The name of the class to use to aggregate test results. The default is &lt;a href=&quot;parser/aggregator&quot;&gt;TAP::Parser::Aggregator&lt;/a&gt;.</source>
          <target state="translated">テスト結果の集計に使用するクラスの名前。デフォルトは&lt;a href=&quot;parser/aggregator&quot;&gt;TAP :: Parser :: Aggregator&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="eaad217bdc2e240c2b5911f874d90cf603ae7ab9" translate="yes" xml:space="preserve">
          <source>The name of the class to use to format output. The default is &lt;a href=&quot;formatter/console&quot;&gt;TAP::Formatter::Console&lt;/a&gt;, or &lt;a href=&quot;formatter/file&quot;&gt;TAP::Formatter::File&lt;/a&gt; if the output isn't a TTY.</source>
          <target state="translated">出力のフォーマットに使用するクラスの名前。デフォルトは&lt;a href=&quot;formatter/console&quot;&gt;TAP :: Formatter :: Console&lt;/a&gt;、または出力がTTYでない場合は&lt;a href=&quot;formatter/file&quot;&gt;TAP :: Formatter :: File&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="72da2c41641715361491c5ff4abc5e20b2230add" translate="yes" xml:space="preserve">
          <source>The name of the class to use to multiplex tests during parallel testing. The default is &lt;a href=&quot;parser/multiplexer&quot;&gt;TAP::Parser::Multiplexer&lt;/a&gt;.</source>
          <target state="translated">並列テスト中にテストを多重化するために使用するクラスの名前。デフォルトは&lt;a href=&quot;parser/multiplexer&quot;&gt;TAP :: Parser :: Multiplexer&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="cf5c1530a58c08454895ba69cebd216b2fda858b" translate="yes" xml:space="preserve">
          <source>The name of the class to use to parse TAP. The default is &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt;.</source>
          <target state="translated">TAPの解析に使用するクラスの名前。デフォルトは&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="9c363903c8b428e2f92b68d74a94f7359ac65693" translate="yes" xml:space="preserve">
          <source>The name of the class to use to schedule test execution. The default is &lt;a href=&quot;parser/scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;.</source>
          <target state="translated">テストの実行をスケジュールするために使用するクラスの名前。デフォルトは&lt;a href=&quot;parser/scheduler&quot;&gt;TAP :: Parser :: Scheduler&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="be46c0fe1db34418e8697bff77cb46ef2046a9fa" translate="yes" xml:space="preserve">
          <source>The name of the constant, as seen by the perl code.</source>
          <target state="translated">perlのコードから見た定数の名前。</target>
        </trans-unit>
        <trans-unit id="4720e470b7493414aa6c88cde788462359384401" translate="yes" xml:space="preserve">
          <source>The name of the current report format for the currently selected output channel. The default format name is the same as the filehandle name. For example, the default format name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is just &lt;code&gt;STDOUT&lt;/code&gt; .</source>
          <target state="translated">現在選択されている出力チャネルの現在のレポート形式の名前。デフォルトのフォーマット名はファイルハンドル名と同じです。たとえば、 &lt;code&gt;STDOUT&lt;/code&gt; ファイルハンドルのデフォルトのフォーマット名は単なる &lt;code&gt;STDOUT&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a6e5170077c0838d812432a43efc57d6e9e83c1c" translate="yes" xml:space="preserve">
          <source>The name of the current top-of-page format for the currently selected output channel. The default is the name of the filehandle with &lt;code&gt;_TOP&lt;/code&gt; appended. For example, the default format top name for the &lt;code&gt;STDOUT&lt;/code&gt; filehandle is &lt;code&gt;STDOUT_TOP&lt;/code&gt; .</source>
          <target state="translated">現在選択されている出力チャネルの現在のページ上部フォーマットの名前。デフォルトは、 &lt;code&gt;_TOP&lt;/code&gt; が追加されたファイルハンドルの名前です。たとえば、 &lt;code&gt;STDOUT&lt;/code&gt; ファイルハンドルのデフォルトのフォーマットのトップ名は &lt;code&gt;STDOUT_TOP&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6379fb4c9e525f705c12afeef2d60c9f65c93af3" translate="yes" xml:space="preserve">
          <source>The name of the default local file, that $ff-&amp;gt;output_file falls back to if it would otherwise return no filename. For example when fetching a URI like &lt;a href=&quot;http://www.abc.net.au/&quot;&gt;http://www.abc.net.au/&lt;/a&gt; the contents retrieved may be from a remote file called 'index.html'. The default value of this attribute is literally 'file_default'.</source>
          <target state="translated">$ ff-&amp;gt; output_fileがファイル名を返さない場合にフォールバックするデフォルトのローカルファイルの名前。たとえば、&lt;a href=&quot;http://www.abc.net.au/&quot;&gt;http：&lt;/a&gt; //www.abc.net.au/のようなURIをフェッチする場合、取得されるコンテンツは「index.html」と呼ばれるリモートファイルから取得される場合があります。この属性のデフォルト値は、文字通り「file_default」です。</target>
        </trans-unit>
        <trans-unit id="1ec9b1148eb41355676951fe5003b4832073d292" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the C code. The default is &lt;code&gt;const-c.inc&lt;/code&gt; . The &lt;code&gt;-&lt;/code&gt; in the name ensures that the file can't be mistaken for anything related to a legitimate perl package name, and not naming the file &lt;code&gt;.c&lt;/code&gt; avoids having to override Makefile.PL's &lt;code&gt;.xs&lt;/code&gt; to &lt;code&gt;.c&lt;/code&gt; rules.</source>
          <target state="translated">Cコードを含む、書き込むファイルの名前。デフォルトは &lt;code&gt;const-c.inc&lt;/code&gt; です。名前の &lt;code&gt;-&lt;/code&gt; は、ファイルが正当なperlパッケージ名に関連するものと間違われないようにし、ファイルに &lt;code&gt;.c&lt;/code&gt; という名前を付けないことで、Makefile.PLの &lt;code&gt;.xs&lt;/code&gt; を &lt;code&gt;.c&lt;/code&gt; ルールにオーバーライドする必要がなくなります。</target>
        </trans-unit>
        <trans-unit id="2bed22db2d9895f574b197dc49845a9793eb5ff4" translate="yes" xml:space="preserve">
          <source>The name of the file to write containing the XS code. The default is &lt;code&gt;const-xs.inc&lt;/code&gt; .</source>
          <target state="translated">XSコードを含む書き込むファイルの名前。デフォルトは &lt;code&gt;const-xs.inc&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a6d500a8c6262466b93b5ca84e3fdd9132c3d42c" translate="yes" xml:space="preserve">
          <source>The name of the file you want to tie to the hash.</source>
          <target state="translated">ハッシュに紐付けたいファイル名。</target>
        </trans-unit>
        <trans-unit id="264313247d929c3123a9e7fe3982f9c4d6734ea2" translate="yes" xml:space="preserve">
          <source>The name of the file.</source>
          <target state="translated">ファイルの名前です。</target>
        </trans-unit>
        <trans-unit id="2fed9b5e3d1ecfa444bc4bf0c0867e79f9d251bc" translate="yes" xml:space="preserve">
          <source>The name of the interior sequence command.</source>
          <target state="translated">内部シーケンスコマンドの名前です。</target>
        </trans-unit>
        <trans-unit id="850e998443ed95a332bbac695731c9e48b93fd64" translate="yes" xml:space="preserve">
          <source>The name of the label is returned in the form of a fresh scalar. If an optional label is absent, a null pointer is returned.</source>
          <target state="translated">ラベルの名前は、新鮮なスカラの形で返されます。オプションのラベルがない場合は、NULLポインタが返されます。</target>
        </trans-unit>
        <trans-unit id="73fad9a569b3c6f7964969b809a10335f9888518" translate="yes" xml:space="preserve">
          <source>The name of the layer whose open() method Perl should invoke on open(). For example if the layer is called APR, you will call:</source>
          <target state="translated">open()で Perl が呼び出すべき open()メソッドを持つレイヤーの名前です。例えば、レイヤーが APR と呼ばれている場合は、このメソッドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="72863e084ba8d90c496ae5c6484f120959926659" translate="yes" xml:space="preserve">
          <source>The name of the method</source>
          <target state="translated">メソッドの名前</target>
        </trans-unit>
        <trans-unit id="e4c23f5fa4cbd2a24c92f584213f4e01a597f939" translate="yes" xml:space="preserve">
          <source>The name of the module you wish to verify -- this is a required key</source>
          <target state="translated">検証したいモジュールの名前 --これは必須キーです。</target>
        </trans-unit>
        <trans-unit id="917bce2995f64faec20b4096ae916c3c8efb0bec" translate="yes" xml:space="preserve">
          <source>The name of the operating system under which this copy of Perl was built, as determined during the configuration process. For examples see &lt;a href=&quot;perlport#PLATFORMS&quot;&gt;PLATFORMS in perlport&lt;/a&gt;.</source>
          <target state="translated">このPerlのコピーが構築されたオペレーティングシステムの名前。設定プロセス中に決定されます。例については&lt;a href=&quot;perlport#PLATFORMS&quot;&gt;、perlportのPLATFORMSを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2040df0b9281e990b52b6ffee0618e248f91a919" translate="yes" xml:space="preserve">
          <source>The name of the output file. This is the same as $ff-&amp;gt;file, but any query parameters are stripped off. For example:</source>
          <target state="translated">出力ファイルの名前。これは$ ff-&amp;gt; fileと同じですが、クエリパラメータはすべて削除されます。例えば：</target>
        </trans-unit>
        <trans-unit id="cbe18d7ad69e81d6c826df352db92d6f22fccd8c" translate="yes" xml:space="preserve">
          <source>The name of the program being documented is conventionally written in bold (using B&amp;lt;&amp;gt;) wherever it occurs, as are all program options. Arguments should be written in italics (I&amp;lt;&amp;gt;). Function names are traditionally written in italics; if you write a function as function(), Pod::Man will take care of this for you. Literal code or commands should be in C&amp;lt;&amp;gt;. References to other man pages should be in the form &lt;code&gt;manpage(section)&lt;/code&gt; or &lt;code&gt;L&amp;lt;manpage(section)&amp;gt;&lt;/code&gt; , and Pod::Man will automatically format those appropriately. The second form, with L&amp;lt;&amp;gt;, is used to request that a POD formatter make a link to the man page if possible. As an exception, one normally omits the section when referring to module documentation since it's not clear what section module documentation will be in; use &lt;code&gt;L&amp;lt;Module::Name&amp;gt;&lt;/code&gt; for module references instead.</source>
          <target state="translated">文書化されているプログラムの名前は、すべてのプログラムオプションと同様に、通常、どこでも、太字で（B &amp;lt;&amp;gt;を使用して）書かれています。引数はイタリック体（I &amp;lt;&amp;gt;）で記述する必要があります。関数名は伝統的にイタリック体で書かれています。 function（）として関数を記述した場合、Pod :: Manがこれを処理します。リテラルコードまたはコマンドはC &amp;lt;&amp;gt;である必要があります。他のmanページへの参照は、 &lt;code&gt;manpage(section)&lt;/code&gt; または &lt;code&gt;L&amp;lt;manpage(section)&amp;gt;&lt;/code&gt; 形式である必要があり、Pod :: Manはそれらを適切に自動的にフォーマットします。 L &amp;lt;&amp;gt;を使用した2番目の形式は、PODフォーマッターが可能であればmanページへのリンクを作成するように要求するために使用されます。例外として、モジュールのドキュメントがどのセクションに含まれるかが明確でないため、モジュールのドキュメントを参照するときは通常セクションを省略します。使用する &lt;code&gt;L&amp;lt;Module::Name&amp;gt;&lt;/code&gt; 代わりにモジュール参照のL &amp;lt;Module :: Name&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="7d1dece7f57632e56f321f082b4b7487de40077a" translate="yes" xml:space="preserve">
          <source>The name of the program currently executing, as typed on the command line. In C, the &lt;b&gt;command&lt;/b&gt; name is passed to the program as the first command-line argument. In Perl, it comes in separately as &lt;code&gt;$0&lt;/code&gt; .</source>
          <target state="translated">コマンドラインで入力された、現在実行中のプログラムの名前。Cでは、&lt;b&gt;コマンド&lt;/b&gt;名は最初のコマンドライン引数としてプログラムに渡されます。Perlでは、 &lt;code&gt;$0&lt;/code&gt; として個別に提供されます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
