<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="3e543092d93dedef30b6a118c959f36cd73b7b20" translate="yes" xml:space="preserve">
          <source>Warns with &lt;code&gt;@message&lt;/code&gt; but the message will appear to come from the point where the original test function was called (&lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt; ).</source>
          <target state="translated">&lt;code&gt;@message&lt;/code&gt; で警告しますが、メッセージは元のテスト関数が呼び出されたポイント（ &lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt; ）から送信されたように見えます。</target>
        </trans-unit>
        <trans-unit id="5d24c39aea457b02505102a29c905de4cac82e99" translate="yes" xml:space="preserve">
          <source>Warns with &lt;code&gt;@message&lt;/code&gt; but the message will appear to come from the point where the original test function was called (&lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;@message&lt;/code&gt; で警告しますが、メッセージは元のテスト関数が呼び出されたポイントから来ているように見えます（ &lt;code&gt;$tb-&amp;gt;caller&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a27a6644654593ac9e5d122b1155ff23752c8073" translate="yes" xml:space="preserve">
          <source>Washington</source>
          <target state="translated">Washington</target>
        </trans-unit>
        <trans-unit id="d321acbea9d4ab268b54e61d4d0b39001cfb34d4" translate="yes" xml:space="preserve">
          <source>Wayne Thompson</source>
          <target state="translated">ウェイン・トンプソン</target>
        </trans-unit>
        <trans-unit id="43464fb1e06d4c1bc9db7081e9ca038cc1269495" translate="yes" xml:space="preserve">
          <source>We &quot;officially&quot; support the two most recent stable release series. 5.16.x and earlier are now out of support. As of the release of 5.22.0, we will &quot;officially&quot; end support for Perl 5.18.x, other than providing security updates as described below.</source>
          <target state="translated">最新の安定版リリースシリーズ2つを「公式に」サポートしています。5.16.x以前のバージョンはサポートを終了します。5.22.0 のリリースをもって、Perl 5.18.x のサポートを「公式に」終了します。</target>
        </trans-unit>
        <trans-unit id="6d4d00accf40364d9a03449bdf5ad7e154d1f316" translate="yes" xml:space="preserve">
          <source>We &quot;officially&quot; support the two most recent stable release series. 5.26.x and earlier are now out of support. As of the release of 5.32.0, we will &quot;officially&quot; end support for Perl 5.28.x, other than providing security updates as described below.</source>
          <target state="translated">最新の安定版リリースシリーズの2つを「公式に」サポートしています。5.26.x以前のバージョンはサポートを終了しました。5.32.0 のリリースと同時に、Perl 5.28.x のサポートを「公式に」終了します。</target>
        </trans-unit>
        <trans-unit id="17a0049b3e8190b56f011a925a65f0578bf35206" translate="yes" xml:space="preserve">
          <source>We already talked about the special &lt;code&gt;@ISA&lt;/code&gt; array and the &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; pragma.</source>
          <target state="translated">特別な &lt;code&gt;@ISA&lt;/code&gt; 配列と&lt;a href=&quot;parent&quot;&gt;親&lt;/a&gt;プラグマについてはすでに説明しました。</target>
        </trans-unit>
        <trans-unit id="99f6d15ea0dac8c570f259e877f08f9c6317a1cf" translate="yes" xml:space="preserve">
          <source>We also recommend using this method to check whether a module has a sufficient version. The internal implementation uses the &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module to make sure that different types of version numbers are compared correctly.</source>
          <target state="translated">また、このメソッドを使用して、モジュールに十分なバージョンがあるかどうかを確認することをお勧めします。内部実装は&lt;a href=&quot;version&quot;&gt;バージョン&lt;/a&gt;モジュールを使用して、異なるタイプのバージョン番号が正しく比較されるようにします。</target>
        </trans-unit>
        <trans-unit id="777641065ef9fefa679b6e058d833646233119c1" translate="yes" xml:space="preserve">
          <source>We are at the end of the regexp, so we are done! We have matched 'abcd' out of the string &quot;abcde&quot;.</source>
          <target state="translated">正規表現が終わったので、これで終了です。文字列 &quot;abcde &quot;のうち'abcd'にマッチしました。</target>
        </trans-unit>
        <trans-unit id="88e6eb598d1ae4c98a1710166c586176804c4ac7" translate="yes" xml:space="preserve">
          <source>We are done!</source>
          <target state="translated">終わった!</target>
        </trans-unit>
        <trans-unit id="b8c42eb02770fa660f067266841b9afabfa1a1c9" translate="yes" xml:space="preserve">
          <source>We are performing only one hash operation in this function, which is storing a new scalar under a key using &lt;code&gt;hv_store&lt;/code&gt; . A hash is represented by an HV* pointer. Like arrays, the functions for manipulating hashes from an XSUB mirror the functionality available from Perl. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; and &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for details.</source>
          <target state="translated">この関数では、 &lt;code&gt;hv_store&lt;/code&gt; を使用してキーの下に新しいスカラーを格納するハッシュ演算を1つだけ実行しています。ハッシュはHV *ポインターで表されます。配列と同様に、XSUBからハッシュを操作するための関数は、Perlから利用可能な機能を反映しています。詳細については&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;と&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3c6308f6a80327169a668ffa81bc777a5db0a8f1" translate="yes" xml:space="preserve">
          <source>We are performing only one hash operation in this function, which is storing a new scalar under a key using &lt;code&gt;hv_store&lt;/code&gt;. A hash is represented by an HV* pointer. Like arrays, the functions for manipulating hashes from an XSUB mirror the functionality available from Perl. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; and &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; for details.</source>
          <target state="translated">この関数では、 &lt;code&gt;hv_store&lt;/code&gt; を使用してキーの下に新しいスカラーを格納するハッシュ操作を1つだけ実行しています。ハッシュはHV *ポインターで表されます。配列と同様に、XSUBからハッシュを操作するための関数は、Perlから利用できる機能を反映しています。詳細については、&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;と&lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="99d6aa4a367d4b3962d66c4c93f795d417974b93" translate="yes" xml:space="preserve">
          <source>We are used to using the term (character)</source>
          <target state="translated">慣れ親しんだ言葉</target>
        </trans-unit>
        <trans-unit id="fd90ced3661ebd845235cda2b54db721e3957aec" translate="yes" xml:space="preserve">
          <source>We aren't interested in anything returned from</source>
          <target state="translated">から返ってきたものには興味がありません。</target>
        </trans-unit>
        <trans-unit id="b554448ff034d8f0532aebe7287733b598ce6629" translate="yes" xml:space="preserve">
          <source>We aren't passing any parameters to</source>
          <target state="translated">には何のパラメータも渡していません。</target>
        </trans-unit>
        <trans-unit id="4e3a929680591b90a57e354fe70746318049b8f9" translate="yes" xml:space="preserve">
          <source>We build perl using GNU make. We tried the native make once and it worked too.</source>
          <target state="translated">私たちはGNU makeを使ってPerlをビルドしています。一度ネイティブのmakeを試してみましたが、それもうまくいきました。</target>
        </trans-unit>
        <trans-unit id="41071245738df49d45438a45bb484058bfc57858" translate="yes" xml:space="preserve">
          <source>We can also dump out this op: the current op is always stored in &lt;code&gt;PL_op&lt;/code&gt; , and we can dump it with &lt;code&gt;Perl_op_dump&lt;/code&gt; . This'll give us similar output to &lt;a href=&quot;b/debug&quot;&gt;B::Debug&lt;/a&gt;.</source>
          <target state="translated">現在のOPは常にに格納されています。我々はまた、このオペアンプをダンプすることができ &lt;code&gt;PL_op&lt;/code&gt; 、私たちはとそれをダンプすることができ &lt;code&gt;Perl_op_dump&lt;/code&gt; 。これにより、&lt;a href=&quot;b/debug&quot;&gt;B :: Debug&lt;/a&gt;と同様の出力が得られます。</target>
        </trans-unit>
        <trans-unit id="6a951916387170e99fc981f4b1d58e4dc7bd8c60" translate="yes" xml:space="preserve">
          <source>We can also dump out this op: the current op is always stored in &lt;code&gt;PL_op&lt;/code&gt;, and we can dump it with &lt;code&gt;Perl_op_dump&lt;/code&gt;. This'll give us similar output to CPAN module B::Debug.</source>
          <target state="translated">現在のOPは常にに格納されています。我々はまた、このオペアンプをダンプすることができ &lt;code&gt;PL_op&lt;/code&gt; 、私たちはとそれをダンプすることができ &lt;code&gt;Perl_op_dump&lt;/code&gt; 。これにより、CPANモジュールB :: Debugと同様の出力が得られます。</target>
        </trans-unit>
        <trans-unit id="961c3c25dd241cffc69783f122b1016732a7e65b" translate="yes" xml:space="preserve">
          <source>We can also use &lt;code&gt;@&lt;/code&gt; to jump to an offset, with 0 being the position where we were when the last &lt;code&gt;(&lt;/code&gt; was encountered:</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; を使用してオフセットにジャンプすることもできます。0は最後の &lt;code&gt;(&lt;/code&gt; が検出されたときの位置です。</target>
        </trans-unit>
        <trans-unit id="dbea0db461430bae70d9c35bb3e6a3ab77cd3179" translate="yes" xml:space="preserve">
          <source>We can also use a variable to store a reference to the data structure that is being blessed as our object:</source>
          <target state="translated">また、私たちのオブジェクトとして祝福されているデータ構造への参照を格納するために変数を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="3ae43a4ae8c47d1af2dad91e0ab8b4c97424cc6a" translate="yes" xml:space="preserve">
          <source>We can also use the transliteration operator, &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. In this example, the search list side of our &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; contains nothing, but the &lt;code&gt;c&lt;/code&gt; option complements that so it contains everything. The replacement list also contains nothing, so the transliteration is almost a no-op since it won't do any replacements (or more exactly, replace the character with itself). However, the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; option squashes duplicated and consecutive characters in the string so a character does not show up next to itself</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 変換演算子tr ///を使用することもできます。この例では、 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; の検索リスト側には何も含まれていませんが、 &lt;code&gt;c&lt;/code&gt; オプションはそれを補完してすべてを含んでいます。置換リストにも何も含まれていないため、文字変換は置換を行わない（正確には文字をそれ自体で置換する）ため、文字変換はほとんど機能しません。ただし、 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; オプションは、文字列内の重複した連続した文字を押しつぶすため、文字が隣に表示されません</target>
        </trans-unit>
        <trans-unit id="0bc5ebb55ff053059629cd57779115c15a2ccce5" translate="yes" xml:space="preserve">
          <source>We can also use the transliteration operator, &lt;code&gt;tr///&lt;/code&gt;. In this example, the search list side of our &lt;code&gt;tr///&lt;/code&gt; contains nothing, but the &lt;code&gt;c&lt;/code&gt; option complements that so it contains everything. The replacement list also contains nothing, so the transliteration is almost a no-op since it won't do any replacements (or more exactly, replace the character with itself). However, the &lt;code&gt;s&lt;/code&gt; option squashes duplicated and consecutive characters in the string so a character does not show up next to itself</source>
          <target state="translated">&lt;code&gt;tr///&lt;/code&gt; 変換演算子tr ///を使用することもできます。この例では、 &lt;code&gt;tr///&lt;/code&gt; の検索リスト側には何も含まれていませんが、 &lt;code&gt;c&lt;/code&gt; オプションはそれを補完するため、すべてが含まれています。置換リストにも何も含まれていないため、文字変換は置換を行わないため（正確には、文字をそれ自体に置き換えます）、ほとんど何も実行されません。ただし、 &lt;code&gt;s&lt;/code&gt; オプションは、文字列内の重複した連続した文字を押しつぶすため、文字がそれ自体の横に表示されません。</target>
        </trans-unit>
        <trans-unit id="0b5deb5cdcf6e21e86d4cfa078a33ffd7c085ef4" translate="yes" xml:space="preserve">
          <source>We can ask autodie to</source>
          <target state="translated">autodieにお願いすることができます。</target>
        </trans-unit>
        <trans-unit id="6dbd56817858a9e2d4db427c7f1f11d2cf2d4b00" translate="yes" xml:space="preserve">
          <source>We can combine the last 3 lines of the above like so:</source>
          <target state="translated">上記の最後の3行をこのように組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="8d9637ace5e985325b750e53a0a2e0777af26ff5" translate="yes" xml:space="preserve">
          <source>We can deal with this by using both an assertion and a negation. We'll say that the first part in $1 must be followed both by a digit and by something that's not &quot;123&quot;. Remember that the look-aheads are zero-width expressions--they only look, but don't consume any of the string in their match. So rewriting this way produces what you'd expect; that is, case 5 will fail, but case 6 succeeds:</source>
          <target state="translated">これを処理するには、アサーションとネガティブの両方を使用します。ここでは、$1 の最初の部分の後には、数字と &quot;123&quot; 以外のものを続けなければならないとします。ルックアヘッドはゼロ幅の式であることを覚えておいてください。つまり、ケース 5 は失敗しますが、ケース 6 は成功します。</target>
        </trans-unit>
        <trans-unit id="337b65de98d527cb6d5b86fba92bc577466c5413" translate="yes" xml:space="preserve">
          <source>We can deal with this by using both an assertion and a negation. We'll say that the first part in &lt;code&gt;$1&lt;/code&gt; must be followed both by a digit and by something that's not &quot;123&quot;. Remember that the lookaheads are zero-width expressions--they only look, but don't consume any of the string in their match. So rewriting this way produces what you'd expect; that is, case 5 will fail, but case 6 succeeds:</source>
          <target state="translated">これは、アサーションと否定の両方を使用して対処できます。 &lt;code&gt;$1&lt;/code&gt; 最初の部分の後には、数字と「123」以外の何かの両方が続く必要があると言います。先読みは幅ゼロの式であることに注意してください。先読みは見た目だけですが、一致する文字列を消費しません。したがって、このように書き直すと、期待どおりの結果が得られます。つまり、ケース5は失敗しますが、ケース6は成功します。</target>
        </trans-unit>
        <trans-unit id="69e73838de4aed15f5d24b688fd13aef192fb3f9" translate="yes" xml:space="preserve">
          <source>We can extend the example above:</source>
          <target state="translated">上記の例を拡張することができます。</target>
        </trans-unit>
        <trans-unit id="84c843f2491ce2ba91f8ea33bd419c025bcac31f" translate="yes" xml:space="preserve">
          <source>We can manipulate &lt;code&gt;@_&lt;/code&gt; in other ways too:</source>
          <target state="translated">&lt;code&gt;@_&lt;/code&gt; は他の方法でも操作できます。</target>
        </trans-unit>
        <trans-unit id="c8e881a1155e87edea33bdbd7aaa36ea47df11e3" translate="yes" xml:space="preserve">
          <source>We can match different character strings with the &lt;b&gt;alternation&lt;/b&gt; metacharacter &lt;code&gt;'|'&lt;/code&gt; . To match &lt;code&gt;dog&lt;/code&gt; or &lt;code&gt;cat&lt;/code&gt; , we form the regex &lt;code&gt;dog|cat&lt;/code&gt; . As before, Perl will try to match the regex at the earliest possible point in the string. At each character position, Perl will first try to match the first alternative, &lt;code&gt;dog&lt;/code&gt; . If &lt;code&gt;dog&lt;/code&gt; doesn't match, Perl will then try the next alternative, &lt;code&gt;cat&lt;/code&gt; . If &lt;code&gt;cat&lt;/code&gt; doesn't match either, then the match fails and Perl moves to the next position in the string. Some examples:</source>
          <target state="translated">さまざまな文字列を&lt;b&gt;代替&lt;/b&gt;メタ文字 &lt;code&gt;'|'&lt;/code&gt; 照合できます 。 &lt;code&gt;dog&lt;/code&gt; または &lt;code&gt;cat&lt;/code&gt; に一致させるために、正規表現 &lt;code&gt;dog|cat&lt;/code&gt; ます。以前と同様に、Perlは文字列の可能な限り早い時点で正規表現に一致しようとします。各文字の位置で、Perlは最初の代替である &lt;code&gt;dog&lt;/code&gt; を最初に照合しようとします。 &lt;code&gt;dog&lt;/code&gt; が一致しない場合、Perlは次の代替である &lt;code&gt;cat&lt;/code&gt; を試行します。 &lt;code&gt;cat&lt;/code&gt; も一致しない場合、一致は失敗し、Perlは文字列の次の位置に移動します。いくつかの例：</target>
        </trans-unit>
        <trans-unit id="d6a0febb21ee098abccab9c8a03b765fef08617d" translate="yes" xml:space="preserve">
          <source>We can match different character strings with the &lt;b&gt;alternation&lt;/b&gt; metacharacter &lt;code&gt;'|'&lt;/code&gt;. To match &lt;code&gt;dog&lt;/code&gt; or &lt;code&gt;cat&lt;/code&gt;, we form the regex &lt;code&gt;dog|cat&lt;/code&gt;. As before, Perl will try to match the regex at the earliest possible point in the string. At each character position, Perl will first try to match the first alternative, &lt;code&gt;dog&lt;/code&gt;. If &lt;code&gt;dog&lt;/code&gt; doesn't match, Perl will then try the next alternative, &lt;code&gt;cat&lt;/code&gt;. If &lt;code&gt;cat&lt;/code&gt; doesn't match either, then the match fails and Perl moves to the next position in the string. Some examples:</source>
          <target state="translated">異なる文字列を&lt;b&gt;交互の&lt;/b&gt;メタ文字 &lt;code&gt;'|'&lt;/code&gt; と一致させることができます。 &lt;code&gt;dog&lt;/code&gt; や &lt;code&gt;cat&lt;/code&gt; に合わせるために、正規表現 &lt;code&gt;dog|cat&lt;/code&gt; ます。以前と同様に、Perlは文字列内の可能な限り早い時点で正規表現を一致させようとします。各文字位置で、Perlは最初に最初の選択肢である &lt;code&gt;dog&lt;/code&gt; との照合を試みます。 &lt;code&gt;dog&lt;/code&gt; が一致しない場合、Perlは次の選択肢である &lt;code&gt;cat&lt;/code&gt; を試します。 &lt;code&gt;cat&lt;/code&gt; も一致しない場合、一致は失敗し、Perlは文字列内の次の位置に移動します。いくつかの例：</target>
        </trans-unit>
        <trans-unit id="ea854225fefa1280a29795bb4f271d273dbd77b0" translate="yes" xml:space="preserve">
          <source>We can modify principle 3 above to take into account non-greedy quantifiers:</source>
          <target state="translated">上の原則3を修正して、非greedyな量詞を考慮に入れることができます。</target>
        </trans-unit>
        <trans-unit id="ab79fcd6910e13f271bf0f10b6fac2de440cb105" translate="yes" xml:space="preserve">
          <source>We can now use &lt;code&gt;Perl_sv_dump&lt;/code&gt; to investigate the SV:</source>
          <target state="translated">これで、 &lt;code&gt;Perl_sv_dump&lt;/code&gt; を使用してSVを調査できます。</target>
        </trans-unit>
        <trans-unit id="9e3ffbb12768a148e4cd9144c59ebb38f57598ff" translate="yes" xml:space="preserve">
          <source>We can override a parent's method in a child class. When we do so, we can still call the parent class's method with the &lt;code&gt;SUPER&lt;/code&gt; pseudo-class.</source>
          <target state="translated">子クラスで親のメソッドをオーバーライドできます。その場合でも、 &lt;code&gt;SUPER&lt;/code&gt; 疑似クラスを使用して親クラスのメソッドを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="2754e3aa57380296cb4f092e33ffe2f92fac593d" translate="yes" xml:space="preserve">
          <source>We can put another break point on any line beginning with a colon, we'll use line 17 as that's just as we come out of the subroutine, and we'd like to pause there later on:</source>
          <target state="translated">コロンで始まる任意の行に別のブレークポイントを置くことができます。17行目はサブルーチンから出てきたところなので、ここで一時停止したいと思います。</target>
        </trans-unit>
        <trans-unit id="8aece3bd543cbe6fe75eaf5ad6965a489841cbb4" translate="yes" xml:space="preserve">
          <source>We can put that into a test file which we can run to check which approach is the fastest, using a global &lt;code&gt;$STR&lt;/code&gt; variable to assign to the &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $str&lt;/code&gt; variable so as to avoid perl trying to optimize any of the work away by noticing it's assigned only the once.</source>
          <target state="translated">これをテストファイルに入れて、どのアプローチが最速かを確認するために実行できます。グローバル &lt;code&gt;$STR&lt;/code&gt; 変数を使用して &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $str&lt;/code&gt; 変数に割り当て、perlがそれに気付くことで作業を最適化しようとしないようにします。一度だけ割り当てられます。</target>
        </trans-unit>
        <trans-unit id="3216d8a5e6dc84b8bbaa513843a9c89d95b551dc" translate="yes" xml:space="preserve">
          <source>We can put that into a test file which we can run to check which approach is the fastest, using a global &lt;code&gt;$STR&lt;/code&gt; variable to assign to the &lt;code&gt;my $str&lt;/code&gt; variable so as to avoid perl trying to optimize any of the work away by noticing it's assigned only the once.</source>
          <target state="translated">これをテストファイルに入れて、どのアプローチが最速かを確認できます。グローバル &lt;code&gt;$STR&lt;/code&gt; 変数を使用して &lt;code&gt;my $str&lt;/code&gt; 変数に割り当て、perlが作業を最適化しようとするのを回避します。一度だけ割り当てられます。</target>
        </trans-unit>
        <trans-unit id="192c194669c26df922a17b7997201101414dafec" translate="yes" xml:space="preserve">
          <source>We can reduce some of the looping through slices</source>
          <target state="translated">スライスを介したループの一部を減らすことができます。</target>
        </trans-unit>
        <trans-unit id="e5d25f7f85d18366ec3d6895017e423d452f3199" translate="yes" xml:space="preserve">
          <source>We can see on line 4 that our token type is &lt;code&gt;ASSIGNOP&lt;/code&gt; (&lt;code&gt;OPERATOR&lt;/code&gt; is a macro, defined in</source>
          <target state="translated">4行目で、トークンタイプが &lt;code&gt;ASSIGNOP&lt;/code&gt; であることがわかります（ &lt;code&gt;OPERATOR&lt;/code&gt; はマクロであり、で定義されています。</target>
        </trans-unit>
        <trans-unit id="4c1ace8b9cc4168efa6505ff7ef438700e9bd607" translate="yes" xml:space="preserve">
          <source>We cannot predict how long the database ping will take so we use Test::More's like() test to check that the diagnostic string is of the right form.</source>
          <target state="translated">データベースのpingにかかる時間を予測することはできないので、Test::Moreのlike()テストを使用して、診断文字列が正しい形式であるかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="661a62faa91fec217313353690ec40805d724e81" translate="yes" xml:space="preserve">
          <source>We check for duplicate entries in the typemap, but do not check for missing &lt;code&gt;TYPEMAP&lt;/code&gt; entries for &lt;code&gt;INPUTMAP&lt;/code&gt; or &lt;code&gt;OUTPUTMAP&lt;/code&gt; entries since these might be hidden in a different typemap.</source>
          <target state="translated">タイプマップで重複するエントリをチェックしますが、 &lt;code&gt;INPUTMAP&lt;/code&gt; または &lt;code&gt;OUTPUTMAP&lt;/code&gt; エントリの &lt;code&gt;TYPEMAP&lt;/code&gt; エントリが欠落していないかどうかはチェックしません。これらは、別のタイプマップで非表示になっている可能性があるためです。</target>
        </trans-unit>
        <trans-unit id="393d2cf123dc0cecdbadd1ca8c26943dc464db54" translate="yes" xml:space="preserve">
          <source>We could get more fancy in the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; block though. Instead of comparing the keys, we can compute a value with them and use that value as the comparison.</source>
          <target state="translated">しかし、 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; ブロックでもっと凝ったものにすることができます。キーを比較する代わりに、キーを使用して値を計算し、その値を比較として使用できます。</target>
        </trans-unit>
        <trans-unit id="1bcc7cd7b768900689b6b050ac1c7aac10dad46e" translate="yes" xml:space="preserve">
          <source>We could get more fancy in the &lt;code&gt;sort()&lt;/code&gt; block though. Instead of comparing the keys, we can compute a value with them and use that value as the comparison.</source>
          <target state="translated">ただし、 &lt;code&gt;sort()&lt;/code&gt; ブロックでもっと凝ったものを得ることができます。キーを比較する代わりに、キーと値を計算し、その値を比較として使用できます。</target>
        </trans-unit>
        <trans-unit id="373abf531902aa68eac45baf244872a1e2626f66" translate="yes" xml:space="preserve">
          <source>We could have both classes inherit from a common parent, like &lt;code&gt;Machine&lt;/code&gt; , but not all machines have on/off switches. We could create a parent class called &lt;code&gt;HasOnOffSwitch&lt;/code&gt; , but that is very artificial. Radios and computers are not specializations of this parent. This parent is really a rather ridiculous creation.</source>
          <target state="translated">&lt;code&gt;Machine&lt;/code&gt; のような共通の親から両方のクラスを継承させることもできますが、すべてのマシンにオン/オフスイッチがあるわけではありません。 &lt;code&gt;HasOnOffSwitch&lt;/code&gt; と呼ばれる親クラスを作成することもできますが、それは非常に人工的なものです。ラジオとコンピューターは、この親の専門分野ではありません。この親は実際にはかなりばかげた創造物です。</target>
        </trans-unit>
        <trans-unit id="859c345eb5fe4bc62f73981c70642999b8e4b03c" translate="yes" xml:space="preserve">
          <source>We could have both classes inherit from a common parent, like &lt;code&gt;Machine&lt;/code&gt;, but not all machines have on/off switches. We could create a parent class called &lt;code&gt;HasOnOffSwitch&lt;/code&gt;, but that is very artificial. Radios and computers are not specializations of this parent. This parent is really a rather ridiculous creation.</source>
          <target state="translated">両方のクラスを &lt;code&gt;Machine&lt;/code&gt; のような共通の親から継承させることもできますが、すべてのマシンにオン/オフスイッチがあるわけではありません。 &lt;code&gt;HasOnOffSwitch&lt;/code&gt; という親クラスを作成することもできますが、それは非常に人為的なものです。ラジオとコンピューターはこの親の専門ではありません。この親は本当にばかげた創造物です。</target>
        </trans-unit>
        <trans-unit id="23ce6432aa57322234fa603b7b093664929a40c6" translate="yes" xml:space="preserve">
          <source>We could have used an unpack template &lt;code&gt;'b12'&lt;/code&gt; just as well, since the last 4 bits can be ignored anyway.</source>
          <target state="translated">最後の4ビットはとにかく無視できるため、アンパックテンプレート &lt;code&gt;'b12'&lt;/code&gt; も使用できます。</target>
        </trans-unit>
        <trans-unit id="737f5642c49143f79a5e632705526d6d3453018c" translate="yes" xml:space="preserve">
          <source>We do this by using the PPCODE: directive, rather than the CODE: directive. This tells &lt;b&gt;xsubpp&lt;/b&gt; that we will be managing the return values that will be put on the argument stack by ourselves.</source>
          <target state="translated">これを行うには、CODE：ディレクティブではなく、PPCODE：ディレクティブを使用します。これは、引数スタックに自分で置く戻り値を管理することを&lt;b&gt;xsubppに&lt;/b&gt;伝えます。</target>
        </trans-unit>
        <trans-unit id="bbf4d60422d93cc3418f9928672ab7a165e0c448" translate="yes" xml:space="preserve">
          <source>We don't have much experience with this yet, but try the following:</source>
          <target state="translated">まだあまり経験がありませんが、以下のようにしてみてください。</target>
        </trans-unit>
        <trans-unit id="3714a8cbbcb3d8e34c4cf78e7eb46446670ccdf4" translate="yes" xml:space="preserve">
          <source>We don't have to hard-code patterns into the match operator (or anything else that works with regular expressions). We can put the pattern in a variable for later use.</source>
          <target state="translated">マッチ演算子にパターンをハードコーディングする必要はありません (正規表現で動作する他の何か)。パターンを変数に入れておけば、後で使えるようになります。</target>
        </trans-unit>
        <trans-unit id="9b9b047b90e6f20cc1587612f1c7f873786eee50" translate="yes" xml:space="preserve">
          <source>We encourage using this rather than calling print directly.</source>
          <target state="translated">プリントに直接電話するのではなく、こちらを利用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="7ef0cc263f45630948ec977db18c296d89495351" translate="yes" xml:space="preserve">
          <source>We encourage vendors to ship the most recent supported release of Perl at the time of their code freeze.</source>
          <target state="translated">私たちは、ベンダーに、Perlの最新のサポートされているリリースをコードフリーズ時に出荷することを奨励しています。</target>
        </trans-unit>
        <trans-unit id="dd33c6dcc68f66e550d47a04957cd34a37a4f9d0" translate="yes" xml:space="preserve">
          <source>We encourage you to play with and evaluate &lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Accessor&quot;&gt;Class::Accessor&lt;/a&gt;, and &lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt; to see which OO system is right for you.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Moose&quot;&gt;Moose&lt;/a&gt;、&lt;a href=&quot;http://search.cpan.org/perldoc/Class::Accessor&quot;&gt;Class :: Accessor&lt;/a&gt;、&lt;a href=&quot;http://search.cpan.org/perldoc/Class::Tiny&quot;&gt;Class :: Tiny&lt;/a&gt;を試して評価し、どのOOシステムが適しているかを確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f6dd2243ed823c9d407fa450eaf7b53699b60af0" translate="yes" xml:space="preserve">
          <source>We encourage you to play with and evaluate &lt;a href=&quot;moose&quot;&gt;Moose&lt;/a&gt;, &lt;a href=&quot;moo&quot;&gt;Moo&lt;/a&gt;, &lt;a href=&quot;Class::Accessor&quot;&gt;Class::Accessor&lt;/a&gt;, and &lt;a href=&quot;Class::Tiny&quot;&gt;Class::Tiny&lt;/a&gt; to see which OO system is right for you.</source>
          <target state="translated">&lt;a href=&quot;moose&quot;&gt;Moose&lt;/a&gt;、&lt;a href=&quot;moo&quot;&gt;Moo&lt;/a&gt;、&lt;a href=&quot;Class::Accessor&quot;&gt;Class :: Accessor&lt;/a&gt;、&lt;a href=&quot;Class::Tiny&quot;&gt;Class :: Tiny&lt;/a&gt;を試して評価し、どのOOシステムが自分に適しているかを確認することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a75ee8e59a59e98ee82483d5a167a8e74430cf9d" translate="yes" xml:space="preserve">
          <source>We fix our quoting: 'tom' =&amp;gt; q(and jerry), and run it again, this time we get our expected output:</source>
          <target state="translated">引用を修正します： 'tom' =&amp;gt; q（およびjerry）、もう一度実行します。今回は期待される出力が得られます。</target>
        </trans-unit>
        <trans-unit id="ad7822a7bc01015524040b6228bd7a714fe0ea5e" translate="yes" xml:space="preserve">
          <source>We have already introduced the matching operator in its default &lt;code&gt;/regexp/&lt;/code&gt; and arbitrary delimiter &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m!regexp!&lt;/a&gt;&lt;/code&gt; forms. We have used the binding operator &lt;code&gt;=~&lt;/code&gt; and its negation &lt;code&gt;!~&lt;/code&gt; to test for string matches. Associated with the matching operator, we have discussed the single line &lt;code&gt;//s&lt;/code&gt; , multi-line &lt;code&gt;//m&lt;/code&gt; , case-insensitive &lt;code&gt;//i&lt;/code&gt; and extended &lt;code&gt;//x&lt;/code&gt; modifiers. There are a few more things you might want to know about matching operators.</source>
          <target state="translated">デフォルトの &lt;code&gt;/regexp/&lt;/code&gt; および任意の区切り文字 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m!regexp!&lt;/a&gt;&lt;/code&gt; に一致する演算子がすでに導入されています。フォーム。バインディング演算子 &lt;code&gt;=~&lt;/code&gt; とその否定 &lt;code&gt;!~&lt;/code&gt; を使用して、文字列の一致をテストしました。マッチング演算子に関連して、単一行 &lt;code&gt;//s&lt;/code&gt; 、複数行 &lt;code&gt;//m&lt;/code&gt; 、大文字小文字を区別しない &lt;code&gt;//i&lt;/code&gt; および拡張 &lt;code&gt;//x&lt;/code&gt; 修飾子について説明しました。一致する演算子について知りたいことがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="4ec0698febe8baf604343239295eca801edc1950" translate="yes" xml:space="preserve">
          <source>We have already introduced the matching operator in its default &lt;code&gt;/regexp/&lt;/code&gt; and arbitrary delimiter &lt;code&gt;m!regexp!&lt;/code&gt; forms. We have used the binding operator &lt;code&gt;=~&lt;/code&gt; and its negation &lt;code&gt;!~&lt;/code&gt; to test for string matches. Associated with the matching operator, we have discussed the single line &lt;code&gt;/s&lt;/code&gt;, multi-line &lt;code&gt;/m&lt;/code&gt;, case-insensitive &lt;code&gt;/i&lt;/code&gt; and extended &lt;code&gt;/x&lt;/code&gt; modifiers. There are a few more things you might want to know about matching operators.</source>
          <target state="translated">デフォルトの &lt;code&gt;/regexp/&lt;/code&gt; と任意の区切り文字 &lt;code&gt;m!regexp!&lt;/code&gt; にマッチング演算子をすでに導入しています。フォーム。文字列の一致をテストするために、バインディング演算子 &lt;code&gt;=~&lt;/code&gt; とその否定 &lt;code&gt;!~&lt;/code&gt; を使用しました。マッチング演算子に関連して、単一行 &lt;code&gt;/s&lt;/code&gt; 、複数行 &lt;code&gt;/m&lt;/code&gt; 、大文字と小文字を区別しない &lt;code&gt;/i&lt;/code&gt; 、および拡張 &lt;code&gt;/x&lt;/code&gt; 修飾子について説明しました。マッチング演算子について知りたいことがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="6e2bfdcf3348ad31286e830869ab5ab9cf57a976" translate="yes" xml:space="preserve">
          <source>We have no nroff on BS2000 POSIX (yet), so we ignored any errors while installing the documentation.</source>
          <target state="translated">BS2000 POSIXのnroffがない(まだ)ので、ドキュメントインストール中のエラーは無視しています。</target>
        </trans-unit>
        <trans-unit id="c5a4c49687cb5b4e725178b1ad770374684a7f19" translate="yes" xml:space="preserve">
          <source>We have to use a &lt;code&gt;CODE&lt;/code&gt; section because &lt;code&gt;PerlIO_puts()&lt;/code&gt; has the arguments reversed compared to &lt;code&gt;fputs()&lt;/code&gt; , and we want to keep the arguments the same.</source>
          <target state="translated">&lt;code&gt;PerlIO_puts()&lt;/code&gt; の引数は &lt;code&gt;fputs()&lt;/code&gt; とは逆になっているため、 &lt;code&gt;CODE&lt;/code&gt; セクションを使用する必要があり、引数を同じに保ちたいと考えています。</target>
        </trans-unit>
        <trans-unit id="094b6bf4440df57d740fc419f243cfd8a6cfc13d" translate="yes" xml:space="preserve">
          <source>We have to use a &lt;code&gt;CODE&lt;/code&gt; section because &lt;code&gt;PerlIO_puts()&lt;/code&gt; has the arguments reversed compared to &lt;code&gt;fputs()&lt;/code&gt;, and we want to keep the arguments the same.</source>
          <target state="translated">&lt;code&gt;PerlIO_puts()&lt;/code&gt; では &lt;code&gt;fputs()&lt;/code&gt; と比較して引数が逆になっているため、 &lt;code&gt;CODE&lt;/code&gt; セクションを使用する必要があり、引数を同じに保ちたいと考えています。</target>
        </trans-unit>
        <trans-unit id="4a78632eb571a6503bee4006e791fffefd6cf4ab" translate="yes" xml:space="preserve">
          <source>We have tried to make Perl aware of both VMS-style and Unix-style file specifications wherever possible. You may use either style, or both, on the command line and in scripts, but you may not combine the two styles within a single file specification. VMS Perl interprets Unix pathnames in much the same way as the CRTL (</source>
          <target state="translated">可能な限り、Perl が VMS スタイルと Unix スタイルの両方のファイル仕様を認識できるようにしています。コマンドラインやスクリプトの中では、どちらかのスタイル、または両方を使用することができますが、一つのファイル指定の中で二つのスタイルを組み合わせることはできません。VMS Perl は Unix パス名を CRTL (</target>
        </trans-unit>
        <trans-unit id="78dd390dcc77c45fe1854b3e48358f0f7f0c1ae7" translate="yes" xml:space="preserve">
          <source>We highly discourage this method. It should only be used if you know what you're doing and specifically need the PREFIX behavior. The PREFIX algorithm is complicated and focused on matching the system installation.</source>
          <target state="translated">この方法は強くお勧めしません。何をしているか分かっていて、特にPREFIXの動作が必要な場合にのみ使用すべきです。PREFIXアルゴリズムは複雑で、システムのインストールとのマッチングに焦点を当てています。</target>
        </trans-unit>
        <trans-unit id="0d078f205cc7733f26f4527b8b9a508a7c925969" translate="yes" xml:space="preserve">
          <source>We highly recommend the install_base method, its the simplest and most closely approximates the expected behavior of an installation prefix.</source>
          <target state="translated">install_base メソッドを強く推奨します。これは最もシンプルで、インストールプレフィックスの期待される動作に最も近いものです。</target>
        </trans-unit>
        <trans-unit id="cf829d6773d2acaf89ace4612301d748f71133de" translate="yes" xml:space="preserve">
          <source>We hope these notes will save you from confusion and lost sleep when writing Perl scripts on VMS. If you find we've missed something you think should appear here, please don't hesitate to drop a line to vmsperl@perl.org.</source>
          <target state="translated">これらの注意事項が、VMS上でPerlスクリプトを書く際の混乱や睡眠不足からあなたを救ってくれることを願っています。ここに掲載すべきだと思われるものを見落としていると思われる場合は、遠慮なく vmsperl@perl.org までご連絡ください。</target>
        </trans-unit>
        <trans-unit id="c62eabab19d963ec1dc9f96b723cb4b48b7d1ebd" translate="yes" xml:space="preserve">
          <source>We implement our own glob-style pattern matching for --rules. Here are the supported patterns:</source>
          <target state="translated">ルールに対して独自のグロブ・スタイルのパターン・マッチングを実装しています。サポートされているパターンは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="f3c2a6f9803dfeb38af1055d966366fc67acbab0" translate="yes" xml:space="preserve">
          <source>We implement our own glob-style pattern matching. Here are the patterns it supports:</source>
          <target state="translated">独自の glob スタイルのパターン・マッチングを実装しています。サポートしているパターンは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="821afd715774631771e27078ffd6e046b44c39d8" translate="yes" xml:space="preserve">
          <source>We know we're going to get &lt;code&gt;6&lt;/code&gt; from this, so let's finish the subroutine:</source>
          <target state="translated">これから &lt;code&gt;6&lt;/code&gt; を取得することがわかっているので、サブルーチンを終了しましょう。</target>
        </trans-unit>
        <trans-unit id="56ac7541ed28a7466aa3352e9da342249eeae09f" translate="yes" xml:space="preserve">
          <source>We looked at this bit of code before, and we said that &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; arranges for two &lt;code&gt;NV&lt;/code&gt; s to be placed into &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; - let's slightly expand it:</source>
          <target state="translated">私たちは前にコードのこのビットを見て、私たちは、と言っ &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; の 2のために並べ &lt;code&gt;NV&lt;/code&gt; sがに配置されるように &lt;code&gt;left&lt;/code&gt; と &lt;code&gt;right&lt;/code&gt; -少しそれを拡張してみましょう：</target>
        </trans-unit>
        <trans-unit id="5ca3334b72be201a6a79c8d27231d9f82fb916a8" translate="yes" xml:space="preserve">
          <source>We looked at this bit of code before, and we said that &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; arranges for two &lt;code&gt;NV&lt;/code&gt;s to be placed into &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; - let's slightly expand it:</source>
          <target state="translated">私たちは前にコードのこのビットを見て、私たちは、と言っ &lt;code&gt;dPOPTOPnnrl_ul&lt;/code&gt; の2のために並べ &lt;code&gt;NV&lt;/code&gt; sがに配置されるように &lt;code&gt;left&lt;/code&gt; と &lt;code&gt;right&lt;/code&gt; -少しそれを拡張してみましょう：</target>
        </trans-unit>
        <trans-unit id="bf8f7ecbf0eb0e715d021c51919b36afbf4f3b1d" translate="yes" xml:space="preserve">
          <source>We maintain the binary incompatibility.</source>
          <target state="translated">バイナリの非互換性を維持しています。</target>
        </trans-unit>
        <trans-unit id="0fd132a408c3e7900b7667b28ffdaffdc2cfda3e" translate="yes" xml:space="preserve">
          <source>We manipulate several arrays in this XSUB. Note that an array is represented internally by an AV* pointer. The functions and macros for manipulating arrays are similar to the functions in Perl: &lt;code&gt;av_top_index&lt;/code&gt; returns the highest index in an AV*, much like $#array; &lt;code&gt;av_fetch&lt;/code&gt; fetches a single scalar value from an array, given its index; &lt;code&gt;av_push&lt;/code&gt; pushes a scalar value onto the end of the array, automatically extending the array as necessary.</source>
          <target state="translated">このXSUBでいくつかの配列を操作します。配列は、AV *ポインターによって内部的に表現されることに注意してください。配列を操作するための関数とマクロは、Perlの関数に似ています &lt;code&gt;av_top_index&lt;/code&gt; は、$＃arrayのように、AV *の最高のインデックスを返します。 &lt;code&gt;av_fetch&lt;/code&gt; は、そのインデックスを指定して、配列から単一のスカラー値をフェッチします。 &lt;code&gt;av_push&lt;/code&gt; はスカラー値を配列の最後にプッシュし、必要に応じて配列を自動的に拡張します。</target>
        </trans-unit>
        <trans-unit id="6201b3e74828151a0b8123986740745576c51a04" translate="yes" xml:space="preserve">
          <source>We may change it so that things that remain legal uses in normal bracketed character classes might become illegal within this experimental construct. One proposal, for example, is to forbid adjacent uses of the same character, as in &lt;code&gt;(?[ [aa] ])&lt;/code&gt; . The motivation for such a change is that this usage is likely a typo, as the second &quot;a&quot; adds nothing.</source>
          <target state="translated">通常の括弧で囲まれた文字クラスで正当に使用されているものは、この実験的構成要素内で違法になるように変更する場合があります。たとえば、 &lt;code&gt;(?[ [aa] ])&lt;/code&gt; ように、同じ文字の隣接する使用を禁止するという提案があります。そのような変更の動機は、2番目の「a」が何も追加しないため、この使用法はおそらくタイプミスであるということです。</target>
        </trans-unit>
        <trans-unit id="6f8e2edefd5e426a509917090b4bcf0d615987a3" translate="yes" xml:space="preserve">
          <source>We may change it so that things that remain legal uses in normal bracketed character classes might become illegal within this experimental construct. One proposal, for example, is to forbid adjacent uses of the same character, as in &lt;code&gt;(?[ [aa] ])&lt;/code&gt;. The motivation for such a change is that this usage is likely a typo, as the second &quot;a&quot; adds nothing.</source>
          <target state="translated">通常の括弧で囲まれた文字クラスで合法的に使用されているものが、この実験的な構成内で違法になるように変更する場合があります。たとえば、1つの提案は、 &lt;code&gt;(?[ [aa] ])&lt;/code&gt; ように、同じ文字の隣接する使用を禁止することです。このような変更の動機は、2番目の「a」が何も追加しないため、この使用法はタイプミスである可能性が高いことです。</target>
        </trans-unit>
        <trans-unit id="9d8db65a7f163486a998a7bf47269c4123bd2dc9" translate="yes" xml:space="preserve">
          <source>We mentioned earlier that most Perl objects are implemented as hashes under the hood. The principle of encapsulation tells us that we should not rely on this. Instead, we should use accessor methods to access the data in that hash. The object systems that we recommend below all automate the generation of accessor methods. If you use one of them, you should never have to access the object as a hash directly.</source>
          <target state="translated">先ほど、Perl のオブジェクトのほとんどがハッシュとして実装されていることを述べました。カプセル化の原理は、これに頼るべきではないことを教えてくれます。その代わりに、そのハッシュ内のデータにアクセスするためにアクセサメソッドを使うべきです。以下で推奨するオブジェクトシステムはすべてアクセサメソッドの生成を自動化しています。それらのうちのどれかを使えば、ハッシュとしてのオブジェクトに直接アクセスする必要はありません。</target>
        </trans-unit>
        <trans-unit id="fd2e3b2237cf2c9ebd6d21ee18dff2f93d4edaee" translate="yes" xml:space="preserve">
          <source>We mentioned multiple inheritance earlier. The main problem with multiple inheritance is that it greatly complicates method resolution. See &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; for more details.</source>
          <target state="translated">多重継承については前述しました。多重継承の主な問題は、メソッドの解決が非常に複雑になることです。詳細については、&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="05de83678232988de23cc08caee2a559bec4d96c" translate="yes" xml:space="preserve">
          <source>We must know how much to read.</source>
          <target state="translated">どれだけ読まれているかを知る必要があります。</target>
        </trans-unit>
        <trans-unit id="786b499d8e7780442a91c12acac79f0bab40bb9c" translate="yes" xml:space="preserve">
          <source>We now compile up Perl, and run it through the test suite. Our new tests pass, hooray!</source>
          <target state="translated">今、Perlをコンパイルして、テストスイートを通して実行します。新しいテストは合格しました。</target>
        </trans-unit>
        <trans-unit id="885cb8f93d773c304687f5c7d8f7995e03fd1f70" translate="yes" xml:space="preserve">
          <source>We now know how to create choices among classes of characters in a regexp. What about choices among words or character strings? Such choices are described in the next section.</source>
          <target state="translated">正規表現で文字のクラス間の選択肢を作成する方法がわかりました。単語や文字列の選択肢はどうでしょうか?そのような選択肢については次の節で説明します。</target>
        </trans-unit>
        <trans-unit id="68e3b46c3317fe81b8a4f43f4375d9dc3eef2342" translate="yes" xml:space="preserve">
          <source>We often refer to inheritance relationships as &lt;b&gt;parent-child&lt;/b&gt; or &lt;code&gt;superclass/subclass&lt;/code&gt; relationships. Sometimes we say that the child has an &lt;b&gt;is-a&lt;/b&gt; relationship with its parent class.</source>
          <target state="translated">継承関係は、&lt;b&gt;親子&lt;/b&gt;関係または &lt;code&gt;superclass/subclass&lt;/code&gt; 関係と呼ばれることがよくあります。ときどき、子供は親クラスと&lt;b&gt;is-a&lt;/b&gt;関係にあると言います。</target>
        </trans-unit>
        <trans-unit id="99514bb04979cf0a47e2cf2b143ea1390fb7e139" translate="yes" xml:space="preserve">
          <source>We often refer to inheritance relationships as &lt;b&gt;parent-child&lt;/b&gt; or &lt;code&gt;superclass&lt;/code&gt;/&lt;code&gt;subclass&lt;/code&gt; relationships. Sometimes we say that the child has an &lt;b&gt;is-a&lt;/b&gt; relationship with its parent class.</source>
          <target state="translated">継承関係は、&lt;b&gt;親子&lt;/b&gt;関係または &lt;code&gt;superclass&lt;/code&gt; / &lt;code&gt;subclass&lt;/code&gt; 関係と呼ばれることがよくあります。時々 、私たちは、子供が持っていると言うこと&lt;b&gt;で、&lt;/b&gt;その親クラスとの関係。</target>
        </trans-unit>
        <trans-unit id="37fd14d3b6f6bb386e0f6cc77e29f8b6538c7a73" translate="yes" xml:space="preserve">
          <source>We recognize that the Perl core, defined as the software distributed with the heart of Perl itself, is a joint project on the part of all of us. From time to time, a script, module, or set of modules (hereafter referred to simply as a &quot;module&quot;) will prove so widely useful and/or so integral to the correct functioning of Perl itself that it should be distributed with the Perl core. This should never be done without the author's explicit consent, and a clear recognition on all parts that this means the module is being distributed under the same terms as Perl itself. A module author should realize that inclusion of a module into the Perl core will necessarily mean some loss of control over it, since changes may occasionally have to be made on short notice or for consistency with the rest of Perl.</source>
          <target state="translated">私たちは、Perlコア(Perlの心臓部と一緒に配布されるソフトウェアとして定義されています)は、私たち全員の共同プロジェクトであることを認識しています。時折、スクリプト、モジュール、またはモジュールのセット(以下、単に「モジュール」と呼ぶ)が、Perlの正しい機能に不可欠であることが証明され、Perlコアと一緒に配布されるべきであることがあります。これは、作者の明示的な同意なしには決して行われるべきではありませんし、これはモジュールが Perl 自体と同じ条件で配布されていることを意味することをすべての部分で明確に認識してください。モジュールの作者は、モジュールを Perl コアに含めるということは、必然的にそれに対する制御を失うことを意味することを理解すべきです。</target>
        </trans-unit>
        <trans-unit id="adbff354730155d973632a844ddac8001f83317b" translate="yes" xml:space="preserve">
          <source>We recommend InfoZIP: &lt;a href=&quot;http://www.info-zip.org/Zip.html&quot;&gt;http://www.info-zip.org/Zip.html&lt;/a&gt;</source>
          <target state="translated">InfoZIPをお勧めします：&lt;a href=&quot;http://www.info-zip.org/Zip.html&quot;&gt;http&lt;/a&gt; : //www.info-zip.org/Zip.html</target>
        </trans-unit>
        <trans-unit id="4f1a977094921f3a67ec1b5d153f5c0398eec08d" translate="yes" xml:space="preserve">
          <source>We recommend ptar from Archive::Tar not older than 1.66 with '-C' option.</source>
          <target state="translated">1.66 よりも古くない Archive::Tar の ptar を、'-C' オプションをつけて使うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="cbe1fc263dadb40ca151eed92966c9248a04de8d" translate="yes" xml:space="preserve">
          <source>We recommend that you avoid this syntax, for several reasons.</source>
          <target state="translated">いくつかの理由から、この構文は避けることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="579e792fc6edac0deca16c23591b561128b4c15e" translate="yes" xml:space="preserve">
          <source>We recommend that you only access attributes via &lt;b&gt;accessor&lt;/b&gt; methods. These are methods that can get or set the value of each attribute. We saw this earlier in the &lt;code&gt;print_info()&lt;/code&gt; example, which calls &lt;code&gt;$self-&amp;gt;path&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;アクセサ&lt;/b&gt;メソッドを介してのみ属性にアクセスすることをお勧めします。これらは、各属性の値を取得または設定できるメソッドです。これは、 &lt;code&gt;print_info()&lt;/code&gt; &lt;code&gt;$self-&amp;gt;path&lt;/code&gt; を呼び出すprint_info（）の例で前に見ました。</target>
        </trans-unit>
        <trans-unit id="3c3f8a0812714182851aed9fbbd140faf18d7041" translate="yes" xml:space="preserve">
          <source>We recommend that you only access attributes via &lt;b&gt;accessor&lt;/b&gt; methods. These are methods that can get or set the value of each attribute. We saw this earlier in the &lt;code&gt;print_info()&lt;/code&gt; example, which calls &lt;code&gt;$self-&amp;gt;path&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;アクセサ&lt;/b&gt;メソッドを介してのみ属性にアクセスすることをお勧めします。これらは、各属性の値を取得または設定できるメソッドです。これは、 &lt;code&gt;print_info()&lt;/code&gt; &lt;code&gt;$self-&amp;gt;path&lt;/code&gt; を呼び出すprint_info（）の例で以前に見ました。</target>
        </trans-unit>
        <trans-unit id="3cd090bb786563ac9394aa0d7f58e631fb54d86e" translate="yes" xml:space="preserve">
          <source>We recommend that you use this method to access another package's version, rather than looking directly at &lt;code&gt;$Package::VERSION&lt;/code&gt; . The package you are looking at could have overridden the &lt;code&gt;VERSION&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;$Package::VERSION&lt;/code&gt; を直接見るのではなく、このメソッドを使用して別のパッケージのバージョンにアクセスすることをお勧めします。表示しているパッケージが &lt;code&gt;VERSION&lt;/code&gt; メソッドをオーバーライドした可能性があります。</target>
        </trans-unit>
        <trans-unit id="6418d5ecc21157f156342ad6f603ad1e78f241b1" translate="yes" xml:space="preserve">
          <source>We recommend that you use this method to access another package's version, rather than looking directly at &lt;code&gt;$Package::VERSION&lt;/code&gt;. The package you are looking at could have overridden the &lt;code&gt;VERSION&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;$Package::VERSION&lt;/code&gt; を直接見るのではなく、この方法を使用して別のパッケージのバージョンにアクセスすることをお勧めします。探しているパッケージが &lt;code&gt;VERSION&lt;/code&gt; メソッドをオーバーライドしている可能性があります。</target>
        </trans-unit>
        <trans-unit id="3584759389d1a5c9463e1916b5f8cba299128724" translate="yes" xml:space="preserve">
          <source>We said that references spring into existence as necessary if they are undefined, but we didn't say what happens if a value used as a reference is already defined, but</source>
          <target state="translated">参照が未定義であれば必要に応じて参照が存在するようになると言いましたが、参照として使われる値が既に定義されている場合はどうなるのかは言いませんでした。</target>
        </trans-unit>
        <trans-unit id="66792931fda90822c58a9263a870978d6e867c09" translate="yes" xml:space="preserve">
          <source>We saw in the section above that there were ordinary characters, which represented themselves, and special characters, which needed a backslash &lt;code&gt;'\'&lt;/code&gt; to represent themselves. The same is true in a character class, but the sets of ordinary and special characters inside a character class are different than those outside a character class. The special characters for a character class are &lt;code&gt;-]\^$&lt;/code&gt; (and the pattern delimiter, whatever it is). &lt;code&gt;']'&lt;/code&gt; is special because it denotes the end of a character class. &lt;code&gt;'$'&lt;/code&gt; is special because it denotes a scalar variable. &lt;code&gt;'\'&lt;/code&gt; is special because it is used in escape sequences, just like above. Here is how the special characters &lt;code&gt;]$\&lt;/code&gt; are handled:</source>
          <target state="translated">上記のセクションで、自分自身を表す通常の文字と、自分自身を表すためにバックスラッシュ &lt;code&gt;'\'&lt;/code&gt; が必要な特殊文字があることがわかりました。同じことが文字クラスにも当てはまりますが、文字クラス内の通常文字と特殊文字のセットは、文字クラス外のものとは異なります。文字クラスの特殊文字は &lt;code&gt;-]\^$&lt;/code&gt; （およびパターン区切り文字です）です。 &lt;code&gt;']'&lt;/code&gt; は、文字クラスの終わりを示すため、特別です。 &lt;code&gt;'$'&lt;/code&gt; はスカラー変数を表すため、特別です。 &lt;code&gt;'\'&lt;/code&gt; は、上記のようにエスケープシーケンスで使用されるため、特別です。特殊文字 &lt;code&gt;]$\&lt;/code&gt; 処理方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="f1e706dab14e9082a067c69407d520e37d14c840" translate="yes" xml:space="preserve">
          <source>We saw in the section above that there were ordinary characters, which represented themselves, and special characters, which needed a backslash &lt;code&gt;\&lt;/code&gt; to represent themselves. The same is true in a character class, but the sets of ordinary and special characters inside a character class are different than those outside a character class. The special characters for a character class are &lt;code&gt;-]\^$&lt;/code&gt; (and the pattern delimiter, whatever it is). &lt;code&gt;]&lt;/code&gt; is special because it denotes the end of a character class. &lt;code&gt;$&lt;/code&gt; is special because it denotes a scalar variable. &lt;code&gt;\&lt;/code&gt; is special because it is used in escape sequences, just like above. Here is how the special characters &lt;code&gt;]$\&lt;/code&gt; are handled:</source>
          <target state="translated">上記のセクションで、自分を表す通常の文字と、自分を表すためにバックスラッシュ &lt;code&gt;\&lt;/code&gt; を必要とする特殊文字があることがわかりました。同じことが文字クラスにも当てはまりますが、文字クラス内の通常文字と特殊文字のセットは、文字クラス外のものとは異なります。文字クラスの特殊文字は &lt;code&gt;-]\^$&lt;/code&gt; （およびパターン区切り文字、それが何であれ）です。 &lt;code&gt;]&lt;/code&gt; は、文字クラスの終わりを示すため、特別です。 &lt;code&gt;$&lt;/code&gt; はスカラー変数を表すため、特別です。 &lt;code&gt;\&lt;/code&gt; は、上記と同様にエスケープシーケンスで使用されるため、特別です。特殊文字 &lt;code&gt;]$\&lt;/code&gt; 処理方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="91ab61be245cfbe060001be5799707fcb012f47d" translate="yes" xml:space="preserve">
          <source>We saw that the norm of &lt;code&gt;z&lt;/code&gt; was noted &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs(z)&lt;/a&gt;&lt;/code&gt; and was defined as the distance to the origin, also known as:</source>
          <target state="translated">&lt;code&gt;z&lt;/code&gt; のノルムは &lt;code&gt;&lt;a href=&quot;../functions/abs&quot;&gt;abs(z)&lt;/a&gt;&lt;/code&gt; で示され、原点までの距離として定義されていることがわかりました。</target>
        </trans-unit>
        <trans-unit id="e2c4be4000d0f7dd961c043239fc9f3b3b2b02bf" translate="yes" xml:space="preserve">
          <source>We saw that the norm of &lt;code&gt;z&lt;/code&gt; was noted &lt;code&gt;abs(z)&lt;/code&gt; and was defined as the distance to the origin, also known as:</source>
          <target state="translated">我々は、のノルムを見 &lt;code&gt;z&lt;/code&gt; が注目された &lt;code&gt;abs(z)&lt;/code&gt; とも呼ば原点までの距離と定義しました。</target>
        </trans-unit>
        <trans-unit id="08920844359a9b99eec6c4ed6a36e0f532af1cca" translate="yes" xml:space="preserve">
          <source>We show the &quot;put&quot; form of the accessors below (i.e., the syntax you use for setting the accessor to a specific value). But you can also call each method with no parameters to get its current value. For example, &lt;code&gt;$self-&amp;gt;contents_file()&lt;/code&gt; returns the current value of the contents_file attribute.</source>
          <target state="translated">アクセサーの「プット」フォームを以下に示します（つまり、アクセサーを特定の値に設定するために使用する構文）。ただし、パラメーターなしで各メソッドを呼び出して、現在の値を取得することもできます。たとえば、 &lt;code&gt;$self-&amp;gt;contents_file()&lt;/code&gt; は、contents_file属性の現在の値を返します。</target>
        </trans-unit>
        <trans-unit id="d711adc8921158fc2754824f56564036d9f3cc37" translate="yes" xml:space="preserve">
          <source>We specify a local port in the &lt;code&gt;LocalPort&lt;/code&gt; argument, which we didn't do for the client. This is service name or port number for which you want to be the server. (Under Unix, ports under 1024 are restricted to the superuser.) In our sample, we'll use port 9000, but you can use any port that's not currently in use on your system. If you try to use one already in used, you'll get an &quot;Address already in use&quot; message. Under Unix, the &lt;code&gt;netstat -a&lt;/code&gt; command will show which services current have servers.</source>
          <target state="translated">&lt;code&gt;LocalPort&lt;/code&gt; 引数でローカルポートを指定しますが、クライアントでは指定していません。これは、サーバーになりたいサービス名またはポート番号です。（Unixでは、1024未満のポートはスーパーユーザーに制限されています。）このサンプルでは、​​ポート9000を使用しますが、システムで現在使用されていない任意のポートを使用できます。すでに使用されているアドレスを使用しようとすると、「アドレスはすでに使用されています」というメッセージが表示されます。Unixでは、 &lt;code&gt;netstat -a&lt;/code&gt; コマンドを実行すると、現在サーバーにあるサービスが表示されます。</target>
        </trans-unit>
        <trans-unit id="d2e82c57891dd489170077bbfa6bd5d7eef124d7" translate="yes" xml:space="preserve">
          <source>We still got a few errors during &lt;code&gt;make test&lt;/code&gt; . Some of them are the result of using bison. Bison prints</source>
          <target state="translated">&lt;code&gt;make test&lt;/code&gt; 中にまだいくつかのエラーが発生しました。それらのいくつかはバイソンを使用した結果です。バイソンプリント</target>
        </trans-unit>
        <trans-unit id="caf05cb06344b1573e32848467a1dff2088a1df3" translate="yes" xml:space="preserve">
          <source>We still got a few errors during &lt;code&gt;make test&lt;/code&gt;. Some of them are the result of using bison. Bison prints</source>
          <target state="translated">&lt;code&gt;make test&lt;/code&gt; 中にまだいくつかのエラーが発生しました。それらのいくつかはバイソンを使用した結果です。バイソンプリント</target>
        </trans-unit>
        <trans-unit id="5d27fd099f66e666f815d6a063eb846b9d1e750a" translate="yes" xml:space="preserve">
          <source>We still use the normal yacc for a2p.y though!!! We made a softlink called byacc to distinguish between the two versions:</source>
          <target state="translated">しかし、a2p.yにはまだ通常のyaccを使っています! この2つのバージョンを区別するために、byaccというソフトリンクを作りました。</target>
        </trans-unit>
        <trans-unit id="f7a01cac535c65877c2cb721bb86383129124455" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use git if possible. It will make your life easier, and ours as well.</source>
          <target state="translated">可能であれば git を使うことを強くお勧めします。そうすることで、あなたの生活が楽になりますし、私たちの生活も楽になります。</target>
        </trans-unit>
        <trans-unit id="c1224f92134a2160e75f8a1e63e0730529cc456d" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use one of these systems. Even the most minimal of them eliminates a lot of repetitive boilerplate. There's really no good reason to write your classes from scratch in Perl.</source>
          <target state="translated">いずれかのシステムを利用することを強くお勧めします。最小限のものであっても、反復的なボイラプレートの多くを排除することができます。Perlでゼロからクラスを書くことには、本当に良い理由はありません。</target>
        </trans-unit>
        <trans-unit id="5f4fa8e578a8c0a7391c3d072ae8a1a053f0a384" translate="yes" xml:space="preserve">
          <source>We tend to avoid this term because it means so many things. It may mean a command-line &lt;b&gt;switch&lt;/b&gt; that takes no argument itself (such as Perl&amp;rsquo;s &lt;code&gt;&amp;ndash;n&lt;/code&gt; and &lt;code&gt;&amp;ndash;p&lt;/code&gt; flags) or, less frequently, a single-bit indicator (such as the &lt;code&gt;O_CREAT&lt;/code&gt; and &lt;code&gt;O_EXCL&lt;/code&gt; flags used in &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;). Sometimes informally used to refer to certain regex modifiers.</source>
          <target state="translated">多くのことを意味するため、この用語は避ける傾向があります。それ自体は引数をとらないコマンドライン&lt;b&gt;スイッチ&lt;/b&gt;（Perlの &lt;code&gt;&amp;ndash;n&lt;/code&gt; フラグや &lt;code&gt;&amp;ndash;p&lt;/code&gt; フラグなど）、または頻度は低いものの、シングルビットインジケーター（ &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; で使用される &lt;code&gt;O_CREAT&lt;/code&gt; および &lt;code&gt;O_EXCL&lt;/code&gt; フラグなど）を意味する場合があります。非公式に特定の正規表現修飾子を参照するために使用されることもあります。</target>
        </trans-unit>
        <trans-unit id="4d3626274dd1f26da66510777516b4ddde9437ec" translate="yes" xml:space="preserve">
          <source>We tend to avoid this term because it means so many things. It may mean a command-line &lt;b&gt;switch&lt;/b&gt; that takes no argument itself (such as Perl&amp;rsquo;s &lt;code&gt;&amp;ndash;n&lt;/code&gt; and &lt;code&gt;&amp;ndash;p&lt;/code&gt; flags) or, less frequently, a single-bit indicator (such as the &lt;code&gt;O_CREAT&lt;/code&gt; and &lt;code&gt;O_EXCL&lt;/code&gt; flags used in &lt;code&gt;sysopen&lt;/code&gt;). Sometimes informally used to refer to certain regex modifiers.</source>
          <target state="translated">この用語は非常に多くのことを意味するため、避ける傾向があります。これは、引数自体を &lt;code&gt;sysopen&lt;/code&gt; ないコマンドライン&lt;b&gt;スイッチ&lt;/b&gt;（Perlの &lt;code&gt;&amp;ndash;n&lt;/code&gt; および &lt;code&gt;&amp;ndash;p&lt;/code&gt; フラグなど）または、頻度は低いですが、シングルビットインジケーター（sysopenで使用される &lt;code&gt;O_CREAT&lt;/code&gt; および &lt;code&gt;O_EXCL&lt;/code&gt; フラグなど）を意味する場合があります。特定の正規表現修飾子を参照するために非公式に使用されることがあります。</target>
        </trans-unit>
        <trans-unit id="8a3b4e98c264bb32d9998c5d96e9cb12719e9b31" translate="yes" xml:space="preserve">
          <source>We then do (always a good idea) a syntax check before we try to run it again:</source>
          <target state="translated">そして、再度実行する前に構文チェックを行います(常に良いアイデアです)。</target>
        </trans-unit>
        <trans-unit id="a54d539385035f7d9714e68587e437b9e809a0a4" translate="yes" xml:space="preserve">
          <source>We use the term &quot;nearly&quot;, because &lt;code&gt;:not_characters&lt;/code&gt; also turns on &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; within its scope. This form is less useful in v5.20 and later, and is described fully in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8&lt;/a&gt;, but briefly, it tells Perl to not use the character portions of the locale definition, that is the &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_COLLATE&lt;/code&gt; categories. Instead it will use the native character set (extended by Unicode). When using this parameter, you are responsible for getting the external character set translated into the native/Unicode one (which it already will be if it is one of the increasingly popular UTF-8 locales). There are convenient ways of doing this, as described in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;Unicode and UTF-8&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;:not_characters&lt;/code&gt; もその範囲内で &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用を&lt;/a&gt;オンにするため、「ほぼ」という用語を使用します。この形式はv5.20以降ではあまり役に立たず、&lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;UnicodeおよびUTF-8&lt;/a&gt;で完全に説明されていますが、簡単に言うと、ロケール定義の文字部分、つまり &lt;code&gt;LC_CTYPE&lt;/code&gt; および &lt;code&gt;LC_COLLATE&lt;/code&gt; カテゴリーを使用しないようにPerlに指示します。代わりに、（Unicodeで拡張された）ネイティブ文字セットを使用します。このパラメーターを使用する場合、外部文字セットをネイティブ/ Unicode文字セットに変換する必要があります（これは、ますます人気のあるUTF-8ロケールの1つである場合は、すでにそうなっています）。&lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;UnicodeとUTF-8で&lt;/a&gt;説明されているように、これを行うには便利な方法があります。。</target>
        </trans-unit>
        <trans-unit id="ff19ea46c35bfebd3ad06b673f58043424fd7951" translate="yes" xml:space="preserve">
          <source>We use the term &quot;nearly&quot;, because &lt;code&gt;:not_characters&lt;/code&gt; also turns on &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; within its scope. This form is less useful in v5.20 and later, and is described fully in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;&quot;Unicode and UTF-8&quot;&lt;/a&gt;, but briefly, it tells Perl to not use the character portions of the locale definition, that is the &lt;code&gt;LC_CTYPE&lt;/code&gt; and &lt;code&gt;LC_COLLATE&lt;/code&gt; categories. Instead it will use the native character set (extended by Unicode). When using this parameter, you are responsible for getting the external character set translated into the native/Unicode one (which it already will be if it is one of the increasingly popular UTF-8 locales). There are convenient ways of doing this, as described in &lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;&quot;Unicode and UTF-8&quot;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;:not_characters&lt;/code&gt; は、スコープ内で &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; もオンにするため、「ほぼ」という用語を使用します。この形式はv5.20以降ではあまり有用ではなく、&lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;「UnicodeおよびUTF-8」&lt;/a&gt;で詳しく説明されていますが、簡単に言うと、ロケール定義の文字部分、つまり &lt;code&gt;LC_CTYPE&lt;/code&gt; および &lt;code&gt;LC_COLLATE&lt;/code&gt; カテゴリを使用しないようにPerlに指示します。代わりに、ネイティブ文字セット（Unicodeで拡張）を使用します。このパラメーターを使用するときは、外部文字セットをネイティブ/ Unicodeのものに変換する必要があります（これは、ますます人気が高まっているUTF-8ロケールの1つである場合はすでに行われます）。&lt;a href=&quot;#Unicode-and-UTF-8&quot;&gt;「UnicodeとUTF-8」で&lt;/a&gt;説明されているように、これを行うには便利な方法があります。。</target>
        </trans-unit>
        <trans-unit id="d72bbd81e111127cc31735e5170b3d3ebdc6c5df" translate="yes" xml:space="preserve">
          <source>We used version 1.2.4, which could be installed out of the box with one failure during 'make check'.</source>
          <target state="translated">バージョン1.2.4を使用していましたが、「make check」の際に1回失敗してもアウトでインストールできるようになりました。</target>
        </trans-unit>
        <trans-unit id="aff45f6c939582aab469b75158efc5869d3a2fcf" translate="yes" xml:space="preserve">
          <source>We want to be able to catch the</source>
          <target state="translated">をキャッチできるようにしたいと考えています。</target>
        </trans-unit>
        <trans-unit id="da129d4b3f31bc7e0cab0dd659997b6d3ef9282c" translate="yes" xml:space="preserve">
          <source>We want to ensure that Perl continues to grow and flourish in the coming years and decades, but not at the expense of our user community.</source>
          <target state="translated">私たちは、Perlが今後何年も何十年も成長し続け、繁栄し続けるようにしたいと考えていますが、ユーザコミュニティを犠牲にしてまでPerlを成長させたいわけではありません。</target>
        </trans-unit>
        <trans-unit id="7602b11fb920ddd30994aa4313930abda93469a9" translate="yes" xml:space="preserve">
          <source>We wanted list context, so G_ARRAY was used.</source>
          <target state="translated">リストコンテキストが欲しかったので、G_ARRAYを使用しました。</target>
        </trans-unit>
        <trans-unit id="8da0820534457147c458ba35d650b1d2014dcd98" translate="yes" xml:space="preserve">
          <source>We will accept 1.00 and 1.75 but not 0.50 or 2.00.</source>
          <target state="translated">1.00、1.75はお受けしますが、0.50、2.00はお受けできません。</target>
        </trans-unit>
        <trans-unit id="3134ffe8598077df7a151748c12e387529c7d2bc" translate="yes" xml:space="preserve">
          <source>We will be calling the test script through the command &quot;&lt;code&gt;make test&lt;/code&gt; &quot;. You should see output that looks something like this:</source>
          <target state="translated">「 &lt;code&gt;make test&lt;/code&gt; 」コマンドを使用してテストスクリプトを呼び出します。次のような出力が表示されます。</target>
        </trans-unit>
        <trans-unit id="bed8e3523336143bfae3d838324a0aad3e70112e" translate="yes" xml:space="preserve">
          <source>We will be calling the test script through the command &quot;&lt;code&gt;make test&lt;/code&gt;&quot;. You should see output that looks something like this:</source>
          <target state="translated">コマンド「maketest」を &lt;code&gt;make test&lt;/code&gt; てテストスクリプトを呼び出します。次のような出力が表示されます。</target>
        </trans-unit>
        <trans-unit id="0a6f3f09fa5bfb41f8f72f761c01531e59969f1d" translate="yes" xml:space="preserve">
          <source>We will not provide security updates or bug fixes for development releases of Perl.</source>
          <target state="translated">Perl の開発リリースのセキュリティアップデートやバグフィックスは提供しません。</target>
        </trans-unit>
        <trans-unit id="788212053c8b040e14cd53eba253eacd9f8cbdce" translate="yes" xml:space="preserve">
          <source>We will now create the main top-level Mytest2 files. Change to the directory above Mytest2 and run the following command:</source>
          <target state="translated">ここでは、メインとなるトップレベルのMytest2ファイルを作成します。Mytest2の上のディレクトリに変更して、以下のコマンドを実行します。</target>
        </trans-unit>
        <trans-unit id="d22caa360403eba16e21b51e9ea68e688fb5cc28" translate="yes" xml:space="preserve">
          <source>We would all love to unmake some mistakes we've made over the past decades. Living with every design error we've ever made can lead to painful stagnation. Unwinding our mistakes is very, very difficult. Doing so without actively harming our users is nearly impossible.</source>
          <target state="translated">過去数十年の間に犯してしまった失敗を、私たちは誰でも取り返したいと思うものです。これまでに犯してきたデザインの失敗をそのままにしていると、痛みを伴う停滞に陥ることがあります。間違いを解きほぐすことは、とても難しいことです。ユーザーに積極的に害を与えないようにすることは、ほぼ不可能です。</target>
        </trans-unit>
        <trans-unit id="461ccef8111ec963260713b6b25723c4d738d9a8" translate="yes" xml:space="preserve">
          <source>We'll come back to this city-country problem later, after we've seen some syntax for managing references.</source>
          <target state="translated">参照を管理するための構文をいくつか見た後、後でこの都市国家の問題に戻ってきます。</target>
        </trans-unit>
        <trans-unit id="25d0051932de21aa64fc90927fc210fd1faca62f" translate="yes" xml:space="preserve">
          <source>We'll get to testing the contents of lists later.</source>
          <target state="translated">リストの内容をテストするのは後回しにします。</target>
        </trans-unit>
        <trans-unit id="7cbf9f8ec2dcbf019622a935f28d55742617ea78" translate="yes" xml:space="preserve">
          <source>We'll get to the meaning of those Perlish-looking variables in a little bit.</source>
          <target state="translated">これらのPerlishな変数の意味を少しずつ説明していきます。</target>
        </trans-unit>
        <trans-unit id="ccbe83524a5012d45f354f697c95fa9a1eb5367f" translate="yes" xml:space="preserve">
          <source>We'll have another string pointer in there:</source>
          <target state="translated">そこにもう一つ文字列ポインタを入れておきます。</target>
        </trans-unit>
        <trans-unit id="5672edbff82e9ae33e95bbfe34109b2db08b3398" translate="yes" xml:space="preserve">
          <source>We'll look at output first. Supposing we already have this structure, how do we print it out?</source>
          <target state="translated">まずは出力について見ていきましょう。すでにこの構造体があるとしたら、どうやって出力するのでしょうか?</target>
        </trans-unit>
        <trans-unit id="8801992116fa36a8b481455c1f17fda02ba0a864" translate="yes" xml:space="preserve">
          <source>We'll see a more tricky example of this when we consider Perl's macros below. &lt;code&gt;POPn&lt;/code&gt; gives you the NV (floating point value) of the top SV on the stack: the &lt;code&gt;$x&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos($x)&lt;/a&gt;&lt;/code&gt;. Then we compute the cosine, and push the result back as an NV. The &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;XPUSHn&lt;/code&gt; means that the stack should be extended if necessary - it can't be necessary here, because we know there's room for one more item on the stack, since we've just removed one! The &lt;code&gt;XPUSH*&lt;/code&gt; macros at least guarantee safety.</source>
          <target state="translated">以下のPerlのマクロを検討すると、このよりトリッキーな例が表示されます。 &lt;code&gt;POPn&lt;/code&gt; はあなたにスタックの先頭のSVのNV（浮動小数点値）を与える： &lt;code&gt;$x&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;functions/cos&quot;&gt;cos($x)&lt;/a&gt;&lt;/code&gt; 。次に、コサインを計算し、結果をNVとして戻します。 &lt;code&gt;XPUSHn&lt;/code&gt; の &lt;code&gt;X&lt;/code&gt; は、必要に応じてスタックを拡張する必要があることを意味します。ここでは必要ありません。スタックに項目を1つ削除したため、スタックに項目が1つ残っていることがわかっているためです。 &lt;code&gt;XPUSH*&lt;/code&gt; マクロは、少なくとも保証の安全性。</target>
        </trans-unit>
        <trans-unit id="56f64cd868fbb648df894ffa687bba0fcd06f58c" translate="yes" xml:space="preserve">
          <source>We'll see a more tricky example of this when we consider Perl's macros below. &lt;code&gt;POPn&lt;/code&gt; gives you the NV (floating point value) of the top SV on the stack: the &lt;code&gt;$x&lt;/code&gt; in &lt;code&gt;cos($x)&lt;/code&gt;. Then we compute the cosine, and push the result back as an NV. The &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;XPUSHn&lt;/code&gt; means that the stack should be extended if necessary - it can't be necessary here, because we know there's room for one more item on the stack, since we've just removed one! The &lt;code&gt;XPUSH*&lt;/code&gt; macros at least guarantee safety.</source>
          <target state="translated">以下のPerlのマクロを検討すると、このよりトリッキーな例がわかります。 &lt;code&gt;POPn&lt;/code&gt; はあなたにスタックの先頭のSVのNV（浮動小数点値）を与える： &lt;code&gt;$x&lt;/code&gt; で &lt;code&gt;cos($x)&lt;/code&gt; 。次に、コサインを計算し、結果をNVとしてプッシュバックします。 &lt;code&gt;XPUSHn&lt;/code&gt; の &lt;code&gt;X&lt;/code&gt; は、必要に応じてスタックを拡張する必要があることを意味します。スタックを削除したばかりなので、スタックにもう1つのアイテムを入れる余地があることがわかっているため、ここでは必要ありません。 &lt;code&gt;XPUSH*&lt;/code&gt; マクロは、少なくとも保証の安全性。</target>
        </trans-unit>
        <trans-unit id="b55bbd57ee31a3c27c5821f6c991f3bb8fbebc65" translate="yes" xml:space="preserve">
          <source>We'll simply continue down to our pre-set breakpoint with a '&lt;b&gt;c&lt;/b&gt;':</source>
          <target state="translated">「&lt;b&gt;c&lt;/b&gt;」を使用して、事前に設定されたブレークポイントまで続けます。</target>
        </trans-unit>
        <trans-unit id="a9a2d405fbc50682e1a3c2bf95879ebe85538d93" translate="yes" xml:space="preserve">
          <source>We'll use &lt;code&gt;gdb&lt;/code&gt; for our examples here; the principles will apply to any debugger (many vendors call their debugger &lt;code&gt;dbx&lt;/code&gt; ), but check the manual of the one you're using.</source>
          <target state="translated">ここでは例として &lt;code&gt;gdb&lt;/code&gt; を使用します。原則はすべてのデバッガーに適用されます（多くのベンダーがデバッガー &lt;code&gt;dbx&lt;/code&gt; を呼び出します）が、使用しているデバッガーのマニュアルを確認してください。</target>
        </trans-unit>
        <trans-unit id="59bfed3e1550313113be0311ae2b9d42ec0cb5e3" translate="yes" xml:space="preserve">
          <source>We'll use &lt;code&gt;gdb&lt;/code&gt; for our examples here; the principles will apply to any debugger (many vendors call their debugger &lt;code&gt;dbx&lt;/code&gt;), but check the manual of the one you're using.</source>
          <target state="translated">ここでは、例として &lt;code&gt;gdb&lt;/code&gt; を使用します。原則はすべてのデバッガーに適用されます（多くのベンダーはデバッガーを &lt;code&gt;dbx&lt;/code&gt; と呼んでいます）が、使用しているデバッガーのマニュアルを確認してください。</target>
        </trans-unit>
        <trans-unit id="dd00180725dcce313c6ef1b86501c9848503c2c0" translate="yes" xml:space="preserve">
          <source>We'll use Jarkko Hietaniemi &amp;lt;</source>
          <target state="translated">Jarkko Hietaniemiを使用します&amp;lt;</target>
        </trans-unit>
        <trans-unit id="f54f2656a6244346ba143809ce965c3e152258c1" translate="yes" xml:space="preserve">
          <source>We're Netware in addition to being Windows.</source>
          <target state="translated">Windowsであることに加えて、ネットウェアであること。</target>
        </trans-unit>
        <trans-unit id="89a6bcd8665abf52d39396f9fea984b5d7d01f5f" translate="yes" xml:space="preserve">
          <source>We're Unix and Cygwin.</source>
          <target state="translated">私たちはUnixとCygwinです。</target>
        </trans-unit>
        <trans-unit id="bae7bf51fd64828a801e9cd04e2c5e1eac38f446" translate="yes" xml:space="preserve">
          <source>We're going to add two more items onto the argument stack: when you have a tied array, the &lt;code&gt;PUSH&lt;/code&gt; subroutine receives the object and the value to be pushed, and that's exactly what we have here - the tied object, retrieved with &lt;code&gt;SvTIED_obj&lt;/code&gt; , and the value, the SV &lt;code&gt;val&lt;/code&gt; .</source>
          <target state="translated">引数スタックにさらに2つの項目を追加します &lt;code&gt;SvTIED_obj&lt;/code&gt; 配列がある場合、 &lt;code&gt;PUSH&lt;/code&gt; サブルーチンはオブジェクトとプッシュされる値を受け取ります。これがまさにここにあるものです-SvTIED_objで取得されたTieオブジェクト値、SV &lt;code&gt;val&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c85ee9a622e2cfbf55a87677c4c0c5ab7baea463" translate="yes" xml:space="preserve">
          <source>We're going to add two more items onto the argument stack: when you have a tied array, the &lt;code&gt;PUSH&lt;/code&gt; subroutine receives the object and the value to be pushed, and that's exactly what we have here - the tied object, retrieved with &lt;code&gt;SvTIED_obj&lt;/code&gt;, and the value, the SV &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">引数スタックにさらに2つの項目を追加します。 &lt;code&gt;SvTIED_obj&lt;/code&gt; れた配列がある場合、 &lt;code&gt;PUSH&lt;/code&gt; サブルーチンはオブジェクトとプッシュされる値を受け取ります。これは、まさにここにあるものです。結合されたオブジェクトは、SvTIED_objで取得されます。値は &lt;code&gt;val&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="81984db06bb6ffc7cc8657839e60eed19d2e59d4" translate="yes" xml:space="preserve">
          <source>We're going to be wanting to test a lot of dates here, trying to trick the code with lots of different edge cases. Does it work before 1970? After 2038? Before 1904? Do years after 10,000 give it trouble? Does it get leap years right? We could keep repeating the code above, or we could set up a little try/expect loop.</source>
          <target state="translated">私たちはここで多くの日付をテストしたいと思っています、多くの異なるエッジケースでコードをトリックしようとしています。1970年以前は?2038年以降?1904年以前?10,000年以降の年は問題ないか?うるう年は正しいのか?上記のコードを繰り返すか、少しだけ試行/期待ループを設定してみましょう。</target>
        </trans-unit>
        <trans-unit id="982b2dd7e00a50956cc41a996392e78491465b29" translate="yes" xml:space="preserve">
          <source>We're going to primarily concentrate on Perl-only modules here, rather than XS modules. XS modules serve a rather different purpose, and you should consider different things before distributing them - the popularity of the library you are gluing, the portability to other operating systems, and so on. However, the notes on preparing the Perl side of the module and packaging and distributing it will apply equally well to an XS module as a pure-Perl one.</source>
          <target state="translated">ここではXSモジュールではなく、主にPerl専用のモジュールに焦点を当てていきます。XS モジュールの役割はかなり異なっていますので、配布する前にいろいろなことを考慮しなければなりません。しかし、モジュールのPerl側の準備やパッケージング、配布に関する注意事項は、純粋なPerlモジュールと同様にXSモジュールにも適用されます。</target>
        </trans-unit>
        <trans-unit id="017f7465d1bdb163c7a89743859d67e419fc8784" translate="yes" xml:space="preserve">
          <source>We've added more detail about what we're testing and the ICal string itself we're trying out to the name. So you get results like:</source>
          <target state="translated">何をテストしているのか、そして名前に試しているICal文字列自体の詳細を追加しました。のような結果が得られるわけですね。</target>
        </trans-unit>
        <trans-unit id="34118bf3962978ee960cb834c23b6a7907e48ac6" translate="yes" xml:space="preserve">
          <source>We've already seen how to print to standard output using &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt;. However, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; can also take an optional first argument specifying which filehandle to print to:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; を使用して標準出力に出力する方法はすでに見てきました。ただし、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print()&lt;/a&gt;&lt;/code&gt; は、印刷するファイルハンドルを指定するオプションの最初の引数を取ることもできます。</target>
        </trans-unit>
        <trans-unit id="a86cb468eaa36ca78f91ded52784d1ac7c3b8af3" translate="yes" xml:space="preserve">
          <source>We've already seen how to print to standard output using &lt;code&gt;print()&lt;/code&gt;. However, &lt;code&gt;print()&lt;/code&gt; can also take an optional first argument specifying which filehandle to print to:</source>
          <target state="translated">&lt;code&gt;print()&lt;/code&gt; を使用して標準出力に出力する方法についてはすでに説明しました。ただし、 &lt;code&gt;print()&lt;/code&gt; は、印刷先のファイルハンドルを指定するオプションの最初の引数を取ることもできます。</target>
        </trans-unit>
        <trans-unit id="01a8063bdaca09993ddd8d252b857fa09a430a49" translate="yes" xml:space="preserve">
          <source>We've also told Perl about the library that we built in the mylib subdirectory. That required only the addition of the &lt;code&gt;MYEXTLIB&lt;/code&gt; variable to the WriteMakefile call and the replacement of the postamble subroutine to cd into the subdirectory and run make. The Makefile.PL for the library is a bit more complicated, but not excessively so. Again we replaced the postamble subroutine to insert our own code. This code simply specified that the library to be created here was a static archive library (as opposed to a dynamically loadable library) and provided the commands to build it.</source>
          <target state="translated">また、mylibサブディレクトリに構築したライブラリについてPerlに通知しました。それには、 &lt;code&gt;MYEXTLIB&lt;/code&gt; 変数をWriteMakefile呼び出しに追加し、ポストアンブルサブルーチンを置き換えて、サブディレクトリにcdしてmakeを実行するだけで済みました。ライブラリのMakefile.PLは少し複雑ですが、それほど複雑ではありません。ここでも、ポストアンブルサブルーチンを置き換えて、独自のコードを挿入しました。このコードは、ここで作成されるライブラリが（動的にロード可能なライブラリではなく）静的アーカイブライブラリであることを単純に指定し、それを構築するコマンドを提供しました。</target>
        </trans-unit>
        <trans-unit id="6afd998315c2c6324bb813d112e9a8f30bf0d582" translate="yes" xml:space="preserve">
          <source>We've covered the workhorse parts of Perl's threading package, and with these tools you should be well on your way to writing threaded code and packages. There are a few useful little pieces that didn't really fit in anyplace else.</source>
          <target state="translated">Perl のスレッド化パッケージの主要な部分をカバーしてきましたが、これらのツールを使えば、スレッド化されたコードやパッケ ージを書くことができるようになるはずです。これらのツールを使えば、スレッド化されたコードやパッケージを書くのに十分な道を歩むことができるはずです。</target>
        </trans-unit>
        <trans-unit id="b4d69ed91d0829df5cfa125f68b479f5de86f05f" translate="yes" xml:space="preserve">
          <source>We've gone past our check (where 'All OK' was printed) and have stopped just before the meat of our task. We could try to print out a couple of variables to see what is happening:</source>
          <target state="translated">チェック('All OK'が印刷されていたところ)を過ぎて、タスクの本質の直前で止まってしまいました。何が起こっているのかを確認するために、いくつかの変数を印刷してみることができます。</target>
        </trans-unit>
        <trans-unit id="33a66a35950ff295dc8b9c6a23c44bcace53edc3" translate="yes" xml:space="preserve">
          <source>We've had Larry's h2ph translator, which helped, but that only works on cpp symbols, not real C, which was also very much needed. What I offer you is a symbolic way of getting at all the C structures. I've couched them in terms of packages and functions. Consider the following program:</source>
          <target state="translated">ラリーの h2ph トランスレータは役に立ちましたが、それは cpp シンボルでしか動作せず、本当の C ではありません。私が提供するのは、すべてのC言語の構造を理解するためのシンボリックな方法です。私はそれらをパッケージと関数で表現しました。以下のプログラムを考えてみてください。</target>
        </trans-unit>
        <trans-unit id="f3af9852bf7e4f70a4af9b26111fb8e3956f866b" translate="yes" xml:space="preserve">
          <source>We've made some changes to Makefile.PL. In this case, we've specified an extra library to be linked into the extension's shared library, the math library libm in this case. We'll talk later about how to write XSUBs that can call every routine in a library.</source>
          <target state="translated">Makefile.PLに変更を加えました。今回は、拡張機能の共有ライブラリ、この場合は数学ライブラリlibmにリンクする追加ライブラリを指定しました。ライブラリ内のすべてのルーチンを呼び出すことができるXSUBの書き方については後述します。</target>
        </trans-unit>
        <trans-unit id="a904b7cf0e87b370c484aeda4a3fd7921273c345" translate="yes" xml:space="preserve">
          <source>We've seen how to encourage good coding practices with &lt;b&gt;use strict&lt;/b&gt; and &lt;b&gt;-w&lt;/b&gt;. We can run the perl debugger &lt;b&gt;perl -d scriptname&lt;/b&gt; to inspect your data from within the perl debugger with the &lt;b&gt;p&lt;/b&gt; and &lt;b&gt;x&lt;/b&gt; commands. You can walk through your code, set breakpoints with &lt;b&gt;b&lt;/b&gt; and step through that code with &lt;b&gt;s&lt;/b&gt; or &lt;b&gt;n&lt;/b&gt;, continue with &lt;b&gt;c&lt;/b&gt; and return from a sub with &lt;b&gt;r&lt;/b&gt;. Fairly intuitive stuff when you get down to it.</source>
          <target state="translated">&lt;b&gt;use strict&lt;/b&gt;および&lt;b&gt;-w&lt;/b&gt;を&lt;b&gt;使用&lt;/b&gt;して、優れたコーディング方法を奨励する方法を見てきました。 perlデバッガー&lt;b&gt;perl -d scriptname&lt;/b&gt;を実行して、&lt;b&gt;p&lt;/b&gt;および&lt;b&gt;x&lt;/b&gt;コマンドを使用してperlデバッガー内からデータを検査できます。コードをウォークスルーし、&lt;b&gt;b&lt;/b&gt;でブレークポイントを設定し、&lt;b&gt;s&lt;/b&gt;または&lt;b&gt;n&lt;/b&gt;でそのコードをステップ実行し、&lt;b&gt;c&lt;/b&gt;で続行し、&lt;b&gt;rで&lt;/b&gt; subから戻ることができます。それに取り掛かると、かなり直感的なものになります。</target>
        </trans-unit>
        <trans-unit id="9f4aba3ac8d090b513bcacbad039797adbe73abe" translate="yes" xml:space="preserve">
          <source>We've taken some pains to construct the template so that it matches the contents of our frame buffer. Otherwise we'd either get undefined values, or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; could not unpack all. If &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; runs out of items, it will supply null strings (which are coerced into zeroes whenever the pack code says so).</source>
          <target state="translated">フレームバッファーの内容と一致するように、テンプレートを作成するために少し苦労しました。それ以外の場合は、未定義の値を取得するか、unpackですべてを &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; できませんでした。場合 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; アイテムを使い果たし、それは（パックコードがそう言う時はいつでもゼロに強制されている）、ヌル文字列を供給します。</target>
        </trans-unit>
        <trans-unit id="f58946de758298d15363eecb7f69802745a7c62d" translate="yes" xml:space="preserve">
          <source>We've taken some pains to construct the template so that it matches the contents of our frame buffer. Otherwise we'd either get undefined values, or &lt;code&gt;unpack&lt;/code&gt; could not unpack all. If &lt;code&gt;pack&lt;/code&gt; runs out of items, it will supply null strings (which are coerced into zeroes whenever the pack code says so).</source>
          <target state="translated">フレームバッファの内容と一致するようにテンプレートを作成するのに少し手間がかかりました。そうしないと、未定義の値を取得するか、unpackですべてを &lt;code&gt;unpack&lt;/code&gt; できませんでした。場合 &lt;code&gt;pack&lt;/code&gt; アイテムを使い果たし、それは（パックコードがそう言う時はいつでもゼロに強制されている）、ヌル文字列を供給します。</target>
        </trans-unit>
        <trans-unit id="37fc93f698eef77381e152ba1261b27e22014722" translate="yes" xml:space="preserve">
          <source>We've tried to make this also work with the TODO: syntax, but it's not guaranteed and its use is also discouraged:</source>
          <target state="translated">これもTODO:構文で動作するようにしてみましたが、保証はされていませんし、使用も推奨されていません。</target>
        </trans-unit>
        <trans-unit id="d057d23b834db4b8d50936a9c8b48cc9bb56ac94" translate="yes" xml:space="preserve">
          <source>We've tried to minimize the dependence of Perl library modules on Unix syntax, but you may find that some of these, as well as some scripts written for Unix systems, will require that you use Unix syntax, since they will assume that '/' is the directory separator,</source>
          <target state="translated">Perl ライブラリモジュールの Unix 構文への依存度を最小限に抑えようとしましたが、これらの中には Unix システム用に書かれたスクリプトと同様に、Unix 構文を使用する必要があることに気づくかもしれません。</target>
        </trans-unit>
        <trans-unit id="f63c6786d8c83343c69f80cf76418c3681700514" translate="yes" xml:space="preserve">
          <source>We've used a hash slice in order to easily handle the fields of each row. Storing the keys in an array makes it easy to operate on them as a group or loop over them with &lt;code&gt;for&lt;/code&gt; . It also avoids polluting the program with global variables and using symbolic references.</source>
          <target state="translated">各行のフィールドを簡単に処理するために、ハッシュスライスを使用しました。キーを配列に格納すると、キーをグループとして操作したり、 &lt;code&gt;for&lt;/code&gt; でループしたりすることが簡単になります。また、プログラムをグローバル変数で汚染したり、シンボリック参照を使用したりすることも避けます。</target>
        </trans-unit>
        <trans-unit id="bf3e9bec5bbd0148b6e7d79050e64cd6c33fa0da" translate="yes" xml:space="preserve">
          <source>We've used a hash slice in order to easily handle the fields of each row. Storing the keys in an array makes it easy to operate on them as a group or loop over them with &lt;code&gt;for&lt;/code&gt;. It also avoids polluting the program with global variables and using symbolic references.</source>
          <target state="translated">各行のフィールドを簡単に処理するために、ハッシュスライスを使用しました。キーを配列に格納すると、キーをグループとして操作したり、 &lt;code&gt;for&lt;/code&gt; を使用してキーをループしたりするのが簡単になります。また、グローバル変数によるプログラムの汚染やシンボリック参照の使用を回避します。</target>
        </trans-unit>
        <trans-unit id="3244b33262d5fd2e0388c2e8910db847842e8800" translate="yes" xml:space="preserve">
          <source>Weak references are not implemented in the version of perl</source>
          <target state="translated">弱い参照は perl のバージョンでは実装されていません。</target>
        </trans-unit>
        <trans-unit id="e147d82cb4cdd9e073d031a1a26cd0222dd868d0" translate="yes" xml:space="preserve">
          <source>Weaken a reference: set the &lt;code&gt;SvWEAKREF&lt;/code&gt; flag on this RV; give the referred-to SV &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; magic if it hasn't already; and push a back-reference to this RV onto the array of backreferences associated with that magic. If the RV is magical, set magic will be called after the RV is cleared.</source>
          <target state="translated">参照を &lt;code&gt;SvWEAKREF&lt;/code&gt; ：このRVにSvWEAKREFフラグを設定します。参照されていないSV &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; マジックをまだ与えていない場合は、それを与えます。そして、このRVへの後方参照を、その魔法に関連付けられた後方参照の配列にプッシュします。RVが魔法の場合、RVがクリアされた後にset magicが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="1b546f1ca2e1f3276683dab2157d9406b01bfa5c" translate="yes" xml:space="preserve">
          <source>Weaken a reference: set the &lt;code&gt;SvWEAKREF&lt;/code&gt; flag on this RV; give the referred-to SV &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; magic if it hasn't already; and push a back-reference to this RV onto the array of backreferences associated with that magic. If the RV is magical, set magic will be called after the RV is cleared. Silently ignores &lt;code&gt;undef&lt;/code&gt; and warns on already-weak references.</source>
          <target state="translated">参照を弱めます：このRVに &lt;code&gt;SvWEAKREF&lt;/code&gt; フラグを設定します。参照 &lt;code&gt;PERL_MAGIC_backref&lt;/code&gt; マジックがまだない場合は、それを与えます。そして、このRVへの後方参照を、その魔法に関連付けられた後方参照の配列にプッシュします。RVが魔法の場合、RVがクリアされた後にセットマジックが呼び出されます。 &lt;code&gt;undef&lt;/code&gt; を黙って無視し、すでに弱い参照について警告します。</target>
        </trans-unit>
        <trans-unit id="6f4b4063ed2668451305a4ea955df5abd08928f3" translate="yes" xml:space="preserve">
          <source>Weakrefs call uvar magic</source>
          <target state="translated">弱い参照は uvar magic を呼び出します。</target>
        </trans-unit>
        <trans-unit id="d99719368087fdb5886c0da04e1ec7aa5bb1e097" translate="yes" xml:space="preserve">
          <source>Web::Simple</source>
          <target state="translated">Web::Simple</target>
        </trans-unit>
        <trans-unit id="a87a48da60ac110880ba420c176bfa3b966a1bbc" translate="yes" xml:space="preserve">
          <source>Websites</source>
          <target state="translated">Websites</target>
        </trans-unit>
        <trans-unit id="c46c01995b645fa6ced7ccd3bd695a2325cf2829" translate="yes" xml:space="preserve">
          <source>Weed out arguments that are not supported and warn about them to the user</source>
          <target state="translated">サポートされていない引数を除外し、ユーザーに警告する</target>
        </trans-unit>
        <trans-unit id="5ff64b425852808bfa9bcc07404d47fe62f5255b" translate="yes" xml:space="preserve">
          <source>Week Number</source>
          <target state="translated">週数</target>
        </trans-unit>
        <trans-unit id="e47cfca7176dccc849b8b9085335ec9965e39788" translate="yes" xml:space="preserve">
          <source>Weighting CJK Unified Ideographs</source>
          <target state="translated">日中韓統一イデオグラフの重み付け</target>
        </trans-unit>
        <trans-unit id="6b33b573e9b7a7f05800470ad22d2691de1ad1d8" translate="yes" xml:space="preserve">
          <source>Weighting JIS KANJI for Unicode::Collate</source>
          <target state="translated">Unicode::CollateのためのJIS漢字の重み付け</target>
        </trans-unit>
        <trans-unit id="b6757ec0e4d4ce4eae1496f199fc7aa0d085efea" translate="yes" xml:space="preserve">
          <source>Weighting may vary depending on collation element table. So ensure the weights defined in &lt;code&gt;entry&lt;/code&gt; will be consistent with those in the collation element table loaded via &lt;code&gt;table&lt;/code&gt; .</source>
          <target state="translated">重み付けは、照合要素テーブルによって異なる場合があります。したがって、 &lt;code&gt;entry&lt;/code&gt; 定義された重みが、tableを介してロードされた照合要素テーブルの重みと一致することを確認して &lt;code&gt;table&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="782d47b6879e710497644ef8bf508107805123e1" translate="yes" xml:space="preserve">
          <source>Weighting may vary depending on collation element table. So ensure the weights defined in &lt;code&gt;entry&lt;/code&gt; will be consistent with those in the collation element table loaded via &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="translated">重み付けは、照合要素テーブルによって異なる場合があります。したがって、 &lt;code&gt;entry&lt;/code&gt; 定義された重みが、tableを介してロードされた照合要素テーブルの重みと一致することを確認して &lt;code&gt;table&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b6bdfd154d71780792f4f6d415a46881c01b84f" translate="yes" xml:space="preserve">
          <source>Weights in reverse order; ex. level 2 (diacritic ordering) in French. If omitted (or &lt;code&gt;$levelNumber&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;\@levelNumbers&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt; ), forwards at all the levels.</source>
          <target state="translated">逆順の重み。例。フランス語のレベル2（発音記号順）。省略した場合（または &lt;code&gt;$levelNumber&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;\@levelNumbers&lt;/code&gt; が &lt;code&gt;[]&lt;/code&gt; の場合）、すべてのレベルで転送します。</target>
        </trans-unit>
        <trans-unit id="07918c7bf0f5c02def4accb22b2496ee08472e26" translate="yes" xml:space="preserve">
          <source>Weights in reverse order; ex. level 2 (diacritic ordering) in French. If omitted (or &lt;code&gt;$levelNumber&lt;/code&gt; is &lt;code&gt;undef&lt;/code&gt; or &lt;code&gt;\@levelNumbers&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;), forwards at all the levels.</source>
          <target state="translated">逆順の重み。例 フランス語のレベル2（発音区別符号）。省略した場合（または &lt;code&gt;$levelNumber&lt;/code&gt; が &lt;code&gt;undef&lt;/code&gt; であるか、 &lt;code&gt;\@levelNumbers&lt;/code&gt; が &lt;code&gt;[]&lt;/code&gt; である場合）、すべてのレベルで転送します。</target>
        </trans-unit>
        <trans-unit id="7cfee8775f2eb957a8724a08c2efd8dbdd2166cc" translate="yes" xml:space="preserve">
          <source>Well it may seem that way, but it does not. The verify method returns true if the command succeeded. If you pass verify an address which the server would normally have to forward to another machine, the command will succeed with something like</source>
          <target state="translated">そのように見えるかもしれませんが、そうではありません。verify メソッドはコマンドが成功した場合に真を返します。通常サーバが別のマシンに転送しなければならないアドレスを verify に渡した場合、コマンドは次のようにして成功します。</target>
        </trans-unit>
        <trans-unit id="1ade9c702a20a6384a7a0b9552d289287a18c722" translate="yes" xml:space="preserve">
          <source>Well, apart from a bare &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; $fh&lt;/code&gt; , you shouldn't treat them specially. (The binmode is needed because otherwise Perl may convert line endings on Win32 systems.)</source>
          <target state="translated">まあ、裸の &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; $fh&lt;/code&gt; は別として、それらを特別に扱うべきではありません。（Win32システムではPerlが行末を変換する可能性があるため、binmodeが必要です。）</target>
        </trans-unit>
        <trans-unit id="48bbf4d297e0c1ca5f48035948fb4a98aa2511d6" translate="yes" xml:space="preserve">
          <source>Well, apart from a bare &lt;code&gt;binmode $fh&lt;/code&gt;, you shouldn't treat them specially. (The binmode is needed because otherwise Perl may convert line endings on Win32 systems.)</source>
          <target state="translated">まあ、裸の &lt;code&gt;binmode $fh&lt;/code&gt; 除いて、それらを特別に扱うべきではありません。（binmodeが必要なのは、そうでない場合、PerlがWin32システムで行末を変換する可能性があるためです。）</target>
        </trans-unit>
        <trans-unit id="504ec4c7237da89364f87b2aad3291cf833f70a8" translate="yes" xml:space="preserve">
          <source>Well, having several executables dynamically linked to the same huge library has its advantages, but this would not substantiate the additional work to make it compile. The reason is the complicated-to-developers but very quick and convenient-to-users &quot;hard&quot; dynamic linking used by OS/2.</source>
          <target state="translated">まあ、同じ巨大なライブラリに動的にリンクされた複数の実行ファイルを持つことには利点がありますが、これではコンパイルするための追加の作業の意味がありません。理由は、開発者にとっては複雑だが、OS/2で使われている「ハード」な動的リンクが非常に速く、ユーザにとっては便利だからだ。</target>
        </trans-unit>
        <trans-unit id="b4bf2ee14e4e81fc05f1087aeed820b042b0028b" translate="yes" xml:space="preserve">
          <source>Well, if you can, upgrade to the most recent, but certainly &lt;code&gt;5.8.1&lt;/code&gt; or newer. The tutorial and FAQ assume the latest release.</source>
          <target state="translated">まあ、可能であれば、最新の、ただし &lt;code&gt;5.8.1&lt;/code&gt; 以降にアップグレードしてください。チュートリアルとFAQは最新のリリースを想定しています。</target>
        </trans-unit>
        <trans-unit id="c922bdb3f23d6c5306883fe0bee806df01fe877f" translate="yes" xml:space="preserve">
          <source>Well, maybe not. Anyway, each op contains a function pointer, which stipulates the function which will actually carry out the operation. This function will return the next op in the sequence - this allows for things like &lt;code&gt;if&lt;/code&gt; which choose the next op dynamically at run time. The &lt;code&gt;PERL_ASYNC_CHECK&lt;/code&gt; makes sure that things like signals interrupt execution if required.</source>
          <target state="translated">まあ、そうではないかもしれません。とにかく、各opには、実際に操作を実行する関数を規定する関数ポインターが含まれています。この関数は、シーケンスの次のopを返します。これにより、実行時に動的に次のopを選択する &lt;code&gt;if&lt;/code&gt; などが可能になります。 &lt;code&gt;PERL_ASYNC_CHECK&lt;/code&gt; は、実行割り込み信号のようなものが必要な場合はことを確認します。</target>
        </trans-unit>
        <trans-unit id="d89d9b138049ae3cace1b14aa62a037a00f5fd6b" translate="yes" xml:space="preserve">
          <source>Well, nowadays Perl DLL should be usable from a differently compiled program too... If you can run Perl code from REXX scripts (see &lt;a href=&quot;OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;), then there are some other aspect of interaction which are overlooked by the current hackish code to support differently-compiled principal programs.</source>
          <target state="translated">さて、最近では、PerlDLLは別の方法でコンパイルされたプログラムからも使用できるはずです... REXXスクリプトからPerlコードを実行できる場合（&lt;a href=&quot;OS2::REXX&quot;&gt;OS2 :: REXXを&lt;/a&gt;参照）、現在のハッキングコードでは見落とされている相互作用の他の側面があります。異なる方法でコンパイルされたプリンシパルプログラムをサポートします。</target>
        </trans-unit>
        <trans-unit id="fb7d8a35468fea02bd934ea87237f211894a5751" translate="yes" xml:space="preserve">
          <source>Well, nowadays Perl DLL should be usable from a differently compiled program too... If you can run Perl code from REXX scripts (see &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;), then there are some other aspect of interaction which are overlooked by the current hackish code to support differently-compiled principal programs.</source>
          <target state="translated">まあ、今日では、Perl DLLは別の方法でコンパイルされたプログラムからも使用できるはずです... REXXスクリプト（&lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2 :: REXXを&lt;/a&gt;参照）からPerlコードを実行できる場合、現在のハッキングコードでは見落とされている相互作用の他の側面があります。異なる方法でコンパイルされた主要なプログラムをサポートします。</target>
        </trans-unit>
        <trans-unit id="61cb10844d83ee77c0e38f0deaf6e76838a94cbb" translate="yes" xml:space="preserve">
          <source>Well, okay, not entirely like C's arrays, actually. C doesn't know how to grow its arrays on demand. Perl does.</source>
          <target state="translated">そうですね,Cの配列のように完全にはいきませんが,実際には Cは必要に応じて配列を成長させる方法を知りません。Perlは知っています。</target>
        </trans-unit>
        <trans-unit id="c4f3fa326a3af64f93426bcdac847f46a94f9b1b" translate="yes" xml:space="preserve">
          <source>Well, that's</source>
          <target state="translated">まあ、それは</target>
        </trans-unit>
        <trans-unit id="bf3871275db74807de50e10189deb9ba1201d5b4" translate="yes" xml:space="preserve">
          <source>Well, that's all fine if you want to send one command and get one answer, but what about setting up something fully interactive, somewhat like the way</source>
          <target state="translated">一つのコマンドを送信して一つの答えを得たいのであれば、それはそれで良いのですが、完全に対話的なものを設定するのはどうでしょうか?</target>
        </trans-unit>
        <trans-unit id="a4fcece5fae45fd55beac8d83dea4ffc7bb1546c" translate="yes" xml:space="preserve">
          <source>Well, that's because the rule is that on adjacent brackets only (whether square or curly), you are free to omit the pointer dereferencing arrow. But you cannot do so for the very first one if it's a scalar containing a reference, which means that $ref_to_AoA always needs it.</source>
          <target state="translated">まあ、それは、隣接するカッコの上でのみ(四角であろうとカーリーであろうと)、ポインタの参照元となる矢印を省略することが自由にできるというルールがあるからです。しかし、それが参照を含むスカラであれば、最初のものについてはそうすることはできません。</target>
        </trans-unit>
        <trans-unit id="5937ea9ee293b2d54cd64fb9f3a778625f679e1c" translate="yes" xml:space="preserve">
          <source>Well, this isn't very easy to read, and using the helpful manual (&lt;b&gt;h h&lt;/b&gt;), the '&lt;b&gt;x&lt;/b&gt;' command looks promising:</source>
          <target state="translated">さて、これは非常に読みやすくありません。役立つマニュアル（&lt;b&gt;hh&lt;/b&gt;）を使用すると、「&lt;b&gt;x&lt;/b&gt;」コマンドは有望に見えます。</target>
        </trans-unit>
        <trans-unit id="81775bcb15e4091e227d731dfdef1462a2bf3f2b" translate="yes" xml:space="preserve">
          <source>Well, you could keep them in sync, but there's no guarantee it will always hold on classes somebody else wrote. Besides, there is little to gain in doing so: a serializing hook could keep only one attribute of an object, which is probably not what should happen during a deep cloning of that same object.</source>
          <target state="translated">まあ、それらを同期させておくことはできますが、誰かが書いたクラスを常に保持できる保証はありません。その上、そうすることで得られるものはほとんどありません:シリアライズフックはオブジェクトの一つの属性だけを保持することができますが、これはおそらく同じオブジェクトを深く複製している間に起こるべきことではないでしょう。</target>
        </trans-unit>
        <trans-unit id="97211a8888128314d9ca34d1005f08cb83ed5d9c" translate="yes" xml:space="preserve">
          <source>What</source>
          <target state="translated">What</target>
        </trans-unit>
        <trans-unit id="c6c58c114eba15fa1fde6b56057cb927734327d9" translate="yes" xml:space="preserve">
          <source>What *is* Unicode, anyway?</source>
          <target state="translated">Unicode とは何ですか?</target>
        </trans-unit>
        <trans-unit id="2948ac1effa2d43a9756f45e31fc4dfaf54b428e" translate="yes" xml:space="preserve">
          <source>What &lt;b&gt;is&lt;/b&gt; Unicode, anyway?</source>
          <target state="translated">とにかく、ユニコードと&lt;b&gt;は&lt;/b&gt;何ですか？</target>
        </trans-unit>
        <trans-unit id="0c27997670ea19d058363ea936f9c5a132d90646" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; does</source>
          <target state="translated">どのような &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; ありません</target>
        </trans-unit>
        <trans-unit id="828c569308e99c356a11f905449002a24faaf00f" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\n&lt;/code&gt; represents depends on the type of file opened. It usually represents &lt;code&gt;\012&lt;/code&gt; but it could also be &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; , &lt;code&gt;\015\012&lt;/code&gt; , &lt;code&gt;\000&lt;/code&gt; , &lt;code&gt;\040&lt;/code&gt; , or nothing depending on the file organization and record format. The &lt;code&gt;VMS::Stdio&lt;/code&gt; module provides access to the special &lt;code&gt;fopen()&lt;/code&gt; requirements of files with unusual attributes on VMS.</source>
          <target state="translated">何 &lt;code&gt;\n&lt;/code&gt; 表しては、開いているファイルの種類によって異なります。これは通常表し &lt;code&gt;\012&lt;/code&gt; が、それはまた、可能性があり &lt;code&gt;\015&lt;/code&gt; 、 &lt;code&gt;\012&lt;/code&gt; 、 &lt;code&gt;\015\012&lt;/code&gt; 、 &lt;code&gt;\000&lt;/code&gt; 、 &lt;code&gt;\040&lt;/code&gt; ファイル編成とレコード形式に応じて、または何も。 &lt;code&gt;VMS::Stdio&lt;/code&gt; モジュールは、特別にアクセスを提供 &lt;code&gt;fopen()&lt;/code&gt; VMS上の異常な属性を持つファイルの要件を。</target>
        </trans-unit>
        <trans-unit id="87fe5c683c90e3c088c772e3615a1786c72c1f86" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\n&lt;/code&gt; represents depends on the type of file opened. It usually represents &lt;code&gt;\012&lt;/code&gt; but it could also be &lt;code&gt;\015&lt;/code&gt;, &lt;code&gt;\012&lt;/code&gt;, &lt;code&gt;\015\012&lt;/code&gt;, &lt;code&gt;\000&lt;/code&gt;, &lt;code&gt;\040&lt;/code&gt;, or nothing depending on the file organization and record format. The &lt;a href=&quot;VMS::Stdio&quot;&gt;&lt;code&gt;VMS::Stdio&lt;/code&gt;&lt;/a&gt; module provides access to the special &lt;code&gt;fopen()&lt;/code&gt; requirements of files with unusual attributes on VMS.</source>
          <target state="translated">何 &lt;code&gt;\n&lt;/code&gt; 表しては、開いているファイルの種類によって異なります。これは通常表し &lt;code&gt;\012&lt;/code&gt; が、それはまた、可能性があり &lt;code&gt;\015&lt;/code&gt; 、 &lt;code&gt;\012&lt;/code&gt; 、 &lt;code&gt;\015\012&lt;/code&gt; 、 &lt;code&gt;\000&lt;/code&gt; 、 &lt;code&gt;\040&lt;/code&gt; ファイル編成とレコード形式に応じて、または何も。&lt;a href=&quot;VMS::Stdio&quot;&gt; &lt;code&gt;VMS::Stdio&lt;/code&gt; &lt;/a&gt;モジュールは、特別にアクセスを提供 &lt;code&gt;fopen()&lt;/code&gt; VMS上の異常な属性を持つファイルの要件を。</target>
        </trans-unit>
        <trans-unit id="fcc1cc41a80c328b4eb792743f378eba1c9a93d1" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\p{Digit}&lt;/code&gt; means (and hence &lt;code&gt;\d&lt;/code&gt; except under the &lt;code&gt;/a&lt;/code&gt; modifier) is &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt; , or synonymously, &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt; . Starting with Unicode version 4.1, this is the same set of characters matched by &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt; . But Unicode also has a different property with a similar name, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; , which matches a completely different set of characters. These characters are things such as &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; or subscripts, or are from writing systems that lack all ten digits.</source>
          <target state="translated">何 &lt;code&gt;\p{Digit}&lt;/code&gt; 手段（したがって &lt;code&gt;\d&lt;/code&gt; 下除く &lt;code&gt;/a&lt;/code&gt; モディファイア）がある &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt; 、同義語、または &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt; 。 Unicodeバージョン4.1以降、これは &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt; 一致する同じ文字セットです。ただし、Unicodeには、同様の名前 &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; を持つ別のプロパティもあり、これは完全に異なる文字セットと一致します。これらの文字は、 &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; や下付き文字などの文字であるか、10桁すべてを欠く書記体系からのものです。</target>
        </trans-unit>
        <trans-unit id="7b5cbb478fdd2453286ebc21496037447f26240f" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;\p{Digit}&lt;/code&gt; means (and hence &lt;code&gt;\d&lt;/code&gt; except under the &lt;code&gt;/a&lt;/code&gt; modifier) is &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt;, or synonymously, &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt;. Starting with Unicode version 4.1, this is the same set of characters matched by &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt;. But Unicode also has a different property with a similar name, &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt;, which matches a completely different set of characters. These characters are things such as &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; or subscripts, or are from writing systems that lack all ten digits.</source>
          <target state="translated">何 &lt;code&gt;\p{Digit}&lt;/code&gt; 手段（したがって &lt;code&gt;\d&lt;/code&gt; 下除く &lt;code&gt;/a&lt;/code&gt; モディファイア）がある &lt;code&gt;\p{General_Category=Decimal_Number}&lt;/code&gt; 、同義語、または &lt;code&gt;\p{General_Category=Digit}&lt;/code&gt; 。Unicodeバージョン4.1以降、これは &lt;code&gt;\p{Numeric_Type=Decimal}&lt;/code&gt; と一致する文字のセットと同じです。ただし、Unicodeには、まったく異なる文字セットに一致する、同様の名前 &lt;code&gt;\p{Numeric_Type=Digit}&lt;/code&gt; 異なるプロパティもあります。これらの文字は、 &lt;code&gt;CIRCLED DIGIT ONE&lt;/code&gt; や下付き文字などであるか、10桁すべてが欠けている書記体系からのものです。</target>
        </trans-unit>
        <trans-unit id="95b14251f22912eca5254f7b79c2a9d632504f9a" translate="yes" xml:space="preserve">
          <source>What &lt;code&gt;import&lt;/code&gt; does</source>
          <target state="translated">どのような &lt;code&gt;import&lt;/code&gt; ありません</target>
        </trans-unit>
        <trans-unit id="23d8154ba31035b162983151d8a78e2e2dc45b35" translate="yes" xml:space="preserve">
          <source>What Compression Types do IO::Compress::Zip &amp;amp; IO::Uncompress::Unzip support?</source>
          <target state="translated">IO :: Compress :: ZipとIO :: Uncompress :: Unzipはどのような圧縮タイプをサポートしていますか？</target>
        </trans-unit>
        <trans-unit id="1e45028df29a344ed3d5dcfe47d49eff1e4e5b3d" translate="yes" xml:space="preserve">
          <source>What Is A Thread Anyway?</source>
          <target state="translated">そもそもスレッドとは何か?</target>
        </trans-unit>
        <trans-unit id="9f3aa83a51cae6aa5da8eadacc3922153fc22ffe" translate="yes" xml:space="preserve">
          <source>What Not to Export</source>
          <target state="translated">輸出してはいけないもの</target>
        </trans-unit>
        <trans-unit id="bcf1ef3ecb402df133384ad31b9f0ab2cd6f6d09" translate="yes" xml:space="preserve">
          <source>What Thread Am I In?</source>
          <target state="translated">私はどのスレッドにいますか?</target>
        </trans-unit>
        <trans-unit id="bdf11c2c3fa2430fc36aec96902da89a7d6631c6" translate="yes" xml:space="preserve">
          <source>What Threads Are Running?</source>
          <target state="translated">どのスレッドが動いているか?</target>
        </trans-unit>
        <trans-unit id="39c91a7f2718b3f82718fcf2f41024f714a5a84f" translate="yes" xml:space="preserve">
          <source>What Unix would call a &quot;character special file&quot;, that is, a device that works on character streams such as a printer port or a console.</source>
          <target state="translated">Unix が「文字専用ファイル」と呼ぶものは、プリンタポートやコンソールのような文字ストリームで動作するデバイスのことです。</target>
        </trans-unit>
        <trans-unit id="4628ec6a65c6ef207e94ed239509a432eb2d40b1" translate="yes" xml:space="preserve">
          <source>What You See Is What You Get. Usually used when something that appears on the screen matches how it will eventually look, like Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; declarations. Also used to mean the opposite of magic because everything works exactly as it appears, as in the three- argument form of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">あなたが見たもの、それがあなたの手に入れたものだ。通常、Perlの &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; 宣言のように、画面に表示されるものが最終的にどのように見えるかと一致する場合に使用されます。 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; の 3引数形式のように、すべてが表示されるとおりに機能するため、魔法の反対を意味するためにも使用されます。</target>
        </trans-unit>
        <trans-unit id="ed80ac1751c25893f1267129f7e46c8160dfe9c8" translate="yes" xml:space="preserve">
          <source>What You See Is What You Get. Usually used when something that appears on the screen matches how it will eventually look, like Perl&amp;rsquo;s &lt;code&gt;format&lt;/code&gt; declarations. Also used to mean the opposite of magic because everything works exactly as it appears, as in the three- argument form of &lt;code&gt;open&lt;/code&gt;.</source>
          <target state="translated">あなたが見たもの、それがあなたの手に入れたものだ。通常、Perlの &lt;code&gt;format&lt;/code&gt; 宣言のように、画面に表示されるものが最終的にどのように見えるかと一致する場合に使用されます。また、 &lt;code&gt;open&lt;/code&gt; の3引数形式のように、すべてが表示どおりに機能するため、魔法の反対を意味するために使用されます。</target>
        </trans-unit>
        <trans-unit id="71fba121999cf66c38da9b22673582805a4f1ef9" translate="yes" xml:space="preserve">
          <source>What a &lt;b&gt;process&lt;/b&gt; does when it has to wait for something: &amp;ldquo;My process blocked waiting for the disk.&amp;rdquo; As an unrelated noun, it refers to a large chunk of data, of a size that the &lt;b&gt;operating system&lt;/b&gt; likes to deal with (normally a power of 2 such as 512 or 8192). Typically refers to a chunk of data that&amp;rsquo;s coming from or going to a disk file.</source>
          <target state="translated">どのような&lt;b&gt;プロセスは、&lt;/b&gt;それが何かを待つ必要がある場合を行います。「私のプロセスは、ディスクを待ってブロックされました。」これは無関係な名詞として、&lt;b&gt;オペレーティングシステム&lt;/b&gt;が扱いたいサイズ（通常は512や8192などの2の累乗）の大きなデータのチャンクを指します。通常は、ディスクファイルで送受信されるデータのチャンクを指します。</target>
        </trans-unit>
        <trans-unit id="2467e6e88d448cacf4a87d364e42c63b7d44c7b4" translate="yes" xml:space="preserve">
          <source>What a Unicode property matches is never subject to locale rules, and if locale rules are not otherwise in effect, the use of a Unicode property will force the regular expression into using Unicode rules, if it isn't already.</source>
          <target state="translated">Unicodeプロパティがマッチするものがロケールルールの対象となることはありません。 ロケールルールが適用されていない場合は、 Unicodeプロパティを使用することで、正規表現は強制的にUnicodeルールを使用するようになります。</target>
        </trans-unit>
        <trans-unit id="bc0f239768e941abba33a14d0c879853b4c42602" translate="yes" xml:space="preserve">
          <source>What about &lt;code&gt;pp_add&lt;/code&gt; , the function we examined earlier to implement the &lt;code&gt;+&lt;/code&gt; operator:</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 演算子を実装するために以前に調べた関数 &lt;code&gt;pp_add&lt;/code&gt; はどうですか？</target>
        </trans-unit>
        <trans-unit id="4f1dc37cecc054d5c9ec7a5642d37fabf7ece164" translate="yes" xml:space="preserve">
          <source>What about &lt;code&gt;pp_add&lt;/code&gt;, the function we examined earlier to implement the &lt;code&gt;+&lt;/code&gt; operator:</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 演算子を実装するために以前に調べた関数である &lt;code&gt;pp_add&lt;/code&gt; についてはどうでしょうか。</target>
        </trans-unit>
        <trans-unit id="f06b49d955a9223ccdbf114f85c4f46fdc429b37" translate="yes" xml:space="preserve">
          <source>What about binary data, like images?</source>
          <target state="translated">画像のようなバイナリデータはどうでしょうか?</target>
        </trans-unit>
        <trans-unit id="904b144e4b71718e8b3ada176614f796ad653d66" translate="yes" xml:space="preserve">
          <source>What about read-write mode? You should probably pretend it doesn't exist, because opening text files in read-write mode is unlikely to do what you would like. See &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; for details.</source>
          <target state="translated">読み書きモードについてはどうですか？テキストファイルを読み取り/書き込みモードで開くと、思いどおりの結果が得られない可能性があるため、存在しないふりをする必要があります。詳細については、&lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a98ea247bf23a0f2706e40c287b52d50377a4b2f" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma?</source>
          <target state="translated">どの程度 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; プラグマ？</target>
        </trans-unit>
        <trans-unit id="b08e1e06d029706420aa4cf6848aa2370810866c" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; pragma?</source>
          <target state="translated">どのような &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; プラグマ？</target>
        </trans-unit>
        <trans-unit id="7033c56c28fec8ae85e45a62981e3d9e75105d87" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;use bytes&lt;/code&gt; pragma?</source>
          <target state="translated">どの程度 &lt;code&gt;use bytes&lt;/code&gt; プラグマ？</target>
        </trans-unit>
        <trans-unit id="a1190a2bf44048aa0cb955f799592720f84eed32" translate="yes" xml:space="preserve">
          <source>What about the &lt;code&gt;use encoding&lt;/code&gt; pragma?</source>
          <target state="translated">&lt;code&gt;use encoding&lt;/code&gt; プラグマの使用についてはどうですか？</target>
        </trans-unit>
        <trans-unit id="3887d9c889fae85aa71ceab4eb1a53b1a8af8aa5" translate="yes" xml:space="preserve">
          <source>What about the use bytes pragma?</source>
          <target state="translated">use bytes pragmaはどうですか?</target>
        </trans-unit>
        <trans-unit id="77d5d80251afa9ef6da60c5e5fbcd215435339d8" translate="yes" xml:space="preserve">
          <source>What about the use encoding pragma?</source>
          <target state="translated">使用エンコーディングのpragmaはどうでしょうか?</target>
        </trans-unit>
        <trans-unit id="9087ece8c32ed3f277ff1480139f31375b459572" translate="yes" xml:space="preserve">
          <source>What about v-strings?</source>
          <target state="translated">Vストリングスは?</target>
        </trans-unit>
        <trans-unit id="20f362258fa45c702309bd2513e61621aa1951d0" translate="yes" xml:space="preserve">
          <source>What are &lt;code&gt;decode_utf8&lt;/code&gt; and &lt;code&gt;encode_utf8&lt;/code&gt; ?</source>
          <target state="translated">&lt;code&gt;decode_utf8&lt;/code&gt; および &lt;code&gt;encode_utf8&lt;/code&gt; とは何ですか？</target>
        </trans-unit>
        <trans-unit id="eb35e14132d10d4b0ffea38066499e7c90c13f72" translate="yes" xml:space="preserve">
          <source>What are &lt;code&gt;decode_utf8&lt;/code&gt; and &lt;code&gt;encode_utf8&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;decode_utf8&lt;/code&gt; と &lt;code&gt;encode_utf8&lt;/code&gt; とは何ですか？</target>
        </trans-unit>
        <trans-unit id="f5cae90cb4f341d083e0d8337510fe30e0b15640" translate="yes" xml:space="preserve">
          <source>What are Perl 4, Perl 5, or Perl 6?</source>
          <target state="translated">Perl4、Perl5、Perl6とは何ですか?</target>
        </trans-unit>
        <trans-unit id="e6127384bd4c0a0328dc9c0ebe31629d55231702" translate="yes" xml:space="preserve">
          <source>What are Perl 4, Perl 5, or Raku (Perl 6)?</source>
          <target state="translated">Perl 4、Perl 5、楽(Perl 6)とは何ですか?</target>
        </trans-unit>
        <trans-unit id="01965e32414f80a123a1d37d107d508fa4c75578" translate="yes" xml:space="preserve">
          <source>What are all these $@%&amp;amp;* punctuation signs, and how do I know when to use them?</source>
          <target state="translated">これらの$ @％＆*句読記号は何ですか、またいつ使用するのかをどのように知ることができますか？</target>
        </trans-unit>
        <trans-unit id="11092e508878fe9b88c670c816521fca7c847f2f" translate="yes" xml:space="preserve">
          <source>What are decode_utf8 and encode_utf8?</source>
          <target state="translated">decode_utf8、encode_utf8とは?</target>
        </trans-unit>
        <trans-unit id="29ffaa3b6cfc90d26e4503a77c7175830b80edb8" translate="yes" xml:space="preserve">
          <source>What are hints?</source>
          <target state="translated">ヒントとは何ですか?</target>
        </trans-unit>
        <trans-unit id="be9717f99f8d2c332a1631b34f3cf973229add73" translate="yes" xml:space="preserve">
          <source>What breaks at what version</source>
          <target state="translated">どのバージョンで何が壊れるか</target>
        </trans-unit>
        <trans-unit id="0a2a28ac7fb746402e9baa692599b97fb2da048e" translate="yes" xml:space="preserve">
          <source>What can you do with a reference once you have it? It's a scalar value, and we've seen that you can store it as a scalar and get it back again just like any scalar. There are just two more ways to use it:</source>
          <target state="translated">一度取得した参照はどうすればいいのでしょうか?これはスカラ値であり、スカラ値として保存しておけば、他のスカラ値と同じように再び取得できることを見てきました。これを使うには、あと2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="36be343f96dfd613d8c5cf587823d859ba4e947b" translate="yes" xml:space="preserve">
          <source>What character encodings does Perl support?</source>
          <target state="translated">Perl はどのような文字エンコーディングをサポートしていますか?</target>
        </trans-unit>
        <trans-unit id="b31fdc311186d7b04a093fc56872b567ad32984f" translate="yes" xml:space="preserve">
          <source>What distribution contains a particular module?</source>
          <target state="translated">どのディストリビューションに特定のモジュールが含まれていますか?</target>
        </trans-unit>
        <trans-unit id="9d7467059fbc01c8f7e5073d6a60b1174890e226" translate="yes" xml:space="preserve">
          <source>What do you do with unsupported filetypes in an archive?</source>
          <target state="translated">アーカイブ内のサポートされていないファイルタイプをどうするか?</target>
        </trans-unit>
        <trans-unit id="d6aa1873fd68eba0f41fb53a3f8a2033690a4a51" translate="yes" xml:space="preserve">
          <source>What do you really want to know? If you merely want to know if one of your filehandles is connected to a terminal, you can try the &lt;code&gt;-t&lt;/code&gt; file test:</source>
          <target state="translated">あなたは本当に何を知りたいですか？ファイルハンドルの1つが端末に接続されているかどうかを知りたいだけの場合は、 &lt;code&gt;-t&lt;/code&gt; ファイルテストを試すことができます。</target>
        </trans-unit>
        <trans-unit id="1c337f8d590673be03d6eb277fa1a70849d518ac" translate="yes" xml:space="preserve">
          <source>What do you think &lt;code&gt;$x&lt;/code&gt; will be? The answer, unfortunately, is</source>
          <target state="translated">&lt;code&gt;$x&lt;/code&gt; はどうなると思いますか？残念ながら、その答えは</target>
        </trans-unit>
        <trans-unit id="72e224b443b5da69c66ac0a14f3f8175aa612a15" translate="yes" xml:space="preserve">
          <source>What does &quot;Bareword 'DB_File' not allowed&quot; mean?</source>
          <target state="translated">裸文字'DB_File'が許可されていない」とはどういう意味ですか?</target>
        </trans-unit>
        <trans-unit id="d0af16451ebfa2bdedb9044267c2bc5c148972de" translate="yes" xml:space="preserve">
          <source>What does &quot;Invalid Argument&quot; mean?</source>
          <target state="translated">無効な引数」とは何を意味するのでしょうか?</target>
        </trans-unit>
        <trans-unit id="f0a7abc8d37e669509493f3435ed1f9575fda404" translate="yes" xml:space="preserve">
          <source>What does &quot;bad interpreter&quot; mean?</source>
          <target state="translated">通訳が悪い」とはどういうことか?</target>
        </trans-unit>
        <trans-unit id="128188e5871787fd7e8d0d232b299acadbde54ca" translate="yes" xml:space="preserve">
          <source>What does &quot;wide character in subroutine entry&quot; mean?</source>
          <target state="translated">サブルーチンエントリのワイド文字」とは何を意味するのでしょうか?</target>
        </trans-unit>
        <trans-unit id="5e47776a0ddea1129634daa43d411c09b05f88dc" translate="yes" xml:space="preserve">
          <source>What does it mean that regexes are greedy? How can I get around it?</source>
          <target state="translated">正規表現が欲張りなのはどういうこと?どうすれば回避できるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="fad85491a61b1ab9b17396e45b64b419ab4c8e77" translate="yes" xml:space="preserve">
          <source>What does this mean for regexps? Well, regexp users don't need to know much about Perl's internal representation of strings. But they do need to know 1) how to represent Unicode characters in a regexp and 2) that a matching operation will treat the string to be searched as a sequence of characters, not bytes. The answer to 1) is that Unicode characters greater than &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(255)&lt;/a&gt;&lt;/code&gt; are represented using the &lt;code&gt;\x{&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;}&lt;/code&gt; notation, because \x hex (without curly braces) doesn't go further than 255. (Starting in Perl 5.14, if you're an octal fan, you can also use &lt;code&gt;\o{&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;}&lt;/code&gt; .)</source>
          <target state="translated">これは正規表現にとって何を意味しますか？まあ、正規表現のユーザーは、Perlの文字列の内部表現について多くを知る必要はありません。ただし、1）正規表現でUnicode文字を表す方法、および2）一致する操作で検索される文字列がバイトではなく文字のシーケンスとして扱われることを知っている必要があります。 1）の答えは、 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(255)&lt;/a&gt;&lt;/code&gt; より大きいUnicode文字は &lt;code&gt;\x{&lt;a href=&quot;functions/hex&quot;&gt;hex&lt;/a&gt;}&lt;/code&gt; 表記を使用して表されるためです。あなたは8進数のファンであり、 &lt;code&gt;\o{&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;}&lt;/code&gt; 使用することもできます。）</target>
        </trans-unit>
        <trans-unit id="975aae02ca21ed8ec96fd5f4735831339586ec7e" translate="yes" xml:space="preserve">
          <source>What does this mean for regexps? Well, regexp users don't need to know much about Perl's internal representation of strings. But they do need to know 1) how to represent Unicode characters in a regexp and 2) that a matching operation will treat the string to be searched as a sequence of characters, not bytes. The answer to 1) is that Unicode characters greater than &lt;code&gt;chr(255)&lt;/code&gt; are represented using the &lt;code&gt;\x{hex}&lt;/code&gt; notation, because &lt;code&gt;\x&lt;/code&gt;</source>
          <target state="translated">これは正規表現にとってどういう意味ですか？まあ、正規表現ユーザーは、Perlの文字列の内部表現について多くを知る必要はありません。ただし、1）正規表現でUnicode文字を表す方法、および2）照合操作によって、検索対象の文字列がバイトではなく文字のシーケンスとして扱われることを知っておく必要があります。1）の答えは、 &lt;code&gt;chr(255)&lt;/code&gt; より大きいUnicode文字は &lt;code&gt;\x{hex}&lt;/code&gt; 表記を使用して表されるということです。 &lt;code&gt;\x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="39fa5db720a03edc1fcba3370635f4d2d4adabe0" translate="yes" xml:space="preserve">
          <source>What exact layers are in this default stack depends on a lot of things: your operating system, Perl version, Perl compile time configuration, and Perl runtime configuration. See &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;, &lt;a href=&quot;perlrun#PERLIO&quot;&gt;&quot;PERLIO&quot; in perlrun&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; for more information.</source>
          <target state="translated">このデフォルトスタックに含まれる正確なレイヤーは、オペレーティングシステム、Perlバージョン、Perlコンパイル時の構成、Perlランタイム構成など多くの要素によって異なります。参照&lt;a href=&quot;perlio&quot;&gt;のPerlIO&lt;/a&gt;、&lt;a href=&quot;perlrun#PERLIO&quot;&gt;perlrunをで「PERLIO」&lt;/a&gt;、および&lt;a href=&quot;open&quot;&gt;オープン&lt;/a&gt;より多くの情報のため。</target>
        </trans-unit>
        <trans-unit id="0d60263af797b45d08166a1e2276365e53b9c7d0" translate="yes" xml:space="preserve">
          <source>What exact layers are in this default stack depends on a lot of things: your operating system, Perl version, Perl compile time configuration, and Perl runtime configuration. See &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;, &lt;a href=&quot;perlrun#PERLIO&quot;&gt;PERLIO in perlrun&lt;/a&gt;, and &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; for more information.</source>
          <target state="translated">このデフォルトスタックの正確な層は、オペレーティングシステム、Perlのバージョン、Perlのコンパイル時の構成、Perlのランタイム構成など、多くの要素によって異なります。参照&lt;a href=&quot;perlio&quot;&gt;のPerlIO&lt;/a&gt;、&lt;a href=&quot;perlrun#PERLIO&quot;&gt;perlrunを中PERLIO&lt;/a&gt;、および&lt;a href=&quot;open&quot;&gt;オープン&lt;/a&gt;より多くの情報のため。</target>
        </trans-unit>
        <trans-unit id="07854a74e069ff620decff4308e92c81d6bd8098" translate="yes" xml:space="preserve">
          <source>What follows are the more advanced, less used, or sometimes esoteric capabilities of Perl regexps. In Part 2, we will assume you are comfortable with the basics and concentrate on the advanced features.</source>
          <target state="translated">以下では、Perl 正規表現のより高度な機能、あまり使われていない機能、時には難解な機能を紹介します。第2部では、基本的なことに慣れていることを前提に、より高度な機能に焦点を当てていきます。</target>
        </trans-unit>
        <trans-unit id="565ee5d3831c954154cf4129999eb2ce193f0752" translate="yes" xml:space="preserve">
          <source>What follows is a detailed guide through these steps.</source>
          <target state="translated">以下は、これらのステップを通じた詳細なガイドです。</target>
        </trans-unit>
        <trans-unit id="75d7e12868bcb8f2565578748be73375fac12333" translate="yes" xml:space="preserve">
          <source>What follows is a statement about artistic control, defined as the ability of authors of packages to guide the future of their code and maintain control over their work. It is a recognition that authors should have control over their work, and that it is a responsibility of the rest of the Perl community to ensure that they retain this control. It is an attempt to document the standards to which we, as Perl developers, intend to hold ourselves. It is an attempt to write down rough guidelines about the respect we owe each other as Perl developers.</source>
          <target state="translated">これは、パッケージの作者が自分のコードの将来を導き、自分の作品に対する制御を維持する能力と定義されている、芸術的な制御に関する声明です。これは、作者が自分の作品を制御するべきであり、この制御を確実に保持することは、Perl コミュニティの残りの部分の責任であるという認識を示しています。これは、Perl の開発者として、私たちが自分たち自身を保持しようとしている基準を文書化する試みです。これは、Perl の開発者としてお互いに敬意を払うことについての大まかなガイドラインを書き留める試みです。</target>
        </trans-unit>
        <trans-unit id="374a8e110bb4c1d9c752734c71a27f6e3e497ea6" translate="yes" xml:space="preserve">
          <source>What follows is subject to change RSN.</source>
          <target state="translated">以下の内容はRSNを変更する場合があります。</target>
        </trans-unit>
        <trans-unit id="24917de591e0d7708ee26a13cd3362afc4f6c7c4" translate="yes" xml:space="preserve">
          <source>What formats output as a form feed. The default is &lt;code&gt;\f&lt;/code&gt; .</source>
          <target state="translated">フォームフィードとして出力する形式。デフォルトは &lt;code&gt;\f&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e7f6f4d84ea57e45f2ca17815f8c029206bd9132" translate="yes" xml:space="preserve">
          <source>What formats output as a form feed. The default is &lt;code&gt;\f&lt;/code&gt;.</source>
          <target state="translated">フォームフィードとして出力するフォーマット。デフォルトは &lt;code&gt;\f&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d479059298a571f524af929b6aea396ec65a05e6" translate="yes" xml:space="preserve">
          <source>What gets returned depends on several factors:</source>
          <target state="translated">何が返ってくるかは、いくつかの要因に左右されます。</target>
        </trans-unit>
        <trans-unit id="8722b12ceccd8e92d99a716a04b297746411e5f8" translate="yes" xml:space="preserve">
          <source>What good is &lt;code&gt;\G&lt;/code&gt; in a regular expression?</source>
          <target state="translated">正規表現で &lt;code&gt;\G&lt;/code&gt; はどのように役立ちますか？</target>
        </trans-unit>
        <trans-unit id="2f0a90d9f77866c3233e1aef1cc7a9560c6ec0c3" translate="yes" xml:space="preserve">
          <source>What good is \G in a regular expression?</source>
          <target state="translated">正規表現で「\G」って何がいいの?</target>
        </trans-unit>
        <trans-unit id="ebf8dc71994cee4560964d904824ac92b27fed19" translate="yes" xml:space="preserve">
          <source>What happens if I add or remove keys from a hash while iterating over it?</source>
          <target state="translated">ハッシュの反復処理中にキーを追加したり削除したりするとどうなりますか?</target>
        </trans-unit>
        <trans-unit id="ff08f48f056287d25a3dc5672938a653f78c0ce3" translate="yes" xml:space="preserve">
          <source>What happens is that after</source>
          <target state="translated">どうなるかというと</target>
        </trans-unit>
        <trans-unit id="630083c407aaeb1fdb11b2f5b1e425a9f1a5879d" translate="yes" xml:space="preserve">
          <source>What happens when &lt;code&gt;JSON::PP&lt;/code&gt; encounters a Perl object depends on the &lt;code&gt;allow_blessed&lt;/code&gt;, &lt;code&gt;convert_blessed&lt;/code&gt;, &lt;code&gt;allow_tags&lt;/code&gt; and &lt;code&gt;allow_bignum&lt;/code&gt; settings, which are used in this order:</source>
          <target state="translated">&lt;code&gt;JSON::PP&lt;/code&gt; がPerlオブジェクトに遭遇したときに何が起こるかは、 &lt;code&gt;allow_blessed&lt;/code&gt; 、 &lt;code&gt;convert_blessed&lt;/code&gt; 、 &lt;code&gt;allow_tags&lt;/code&gt; 、 &lt;code&gt;allow_bignum&lt;/code&gt; の設定によって異なります。これらは次の順序で使用されます。</target>
        </trans-unit>
        <trans-unit id="5b6c83c5563cf3fe722575d6dd30278f0a9d68bc" translate="yes" xml:space="preserve">
          <source>What has gone on?</source>
          <target state="translated">何が続いているのか?</target>
        </trans-unit>
        <trans-unit id="148ce7ffb164566545434b0feef660c7bee4a489" translate="yes" xml:space="preserve">
          <source>What has happened here?</source>
          <target state="translated">ここで何が起こったのか?</target>
        </trans-unit>
        <trans-unit id="21eec199e3d296f021d3cdb05af5afb550abb23b" translate="yes" xml:space="preserve">
          <source>What has happened is that &lt;code&gt;fred&lt;/code&gt; accesses the &lt;code&gt;@_&lt;/code&gt; array which belongs to &lt;code&gt;joe&lt;/code&gt; .</source>
          <target state="translated">何が起こったかというと、 &lt;code&gt;fred&lt;/code&gt; は &lt;code&gt;joe&lt;/code&gt; に属する &lt;code&gt;@_&lt;/code&gt; 配列にアクセスします。</target>
        </trans-unit>
        <trans-unit id="4495f64a5a5a99cc3a0b71199a99723a37e9ed87" translate="yes" xml:space="preserve">
          <source>What has happened is that &lt;code&gt;fred&lt;/code&gt; accesses the &lt;code&gt;@_&lt;/code&gt; array which belongs to &lt;code&gt;joe&lt;/code&gt;.</source>
          <target state="translated">何が起こったのかというと、 &lt;code&gt;fred&lt;/code&gt; は &lt;code&gt;joe&lt;/code&gt; に属する &lt;code&gt;@_&lt;/code&gt; 配列にアクセスします。</target>
        </trans-unit>
        <trans-unit id="1061def72c9d3f6d8d9699c831f84918bba3a0be" translate="yes" xml:space="preserve">
          <source>What if I don't decode?</source>
          <target state="translated">デコードしないとどうなるの?</target>
        </trans-unit>
        <trans-unit id="edc0c9ac4aa8c7b7a3fb61b68506b87d3c69f4bc" translate="yes" xml:space="preserve">
          <source>What if I don't encode?</source>
          <target state="translated">エンコードしないとどうなるの?</target>
        </trans-unit>
        <trans-unit id="0ddebc8779b4a58623bcc03eec19b9fd5bdcc57a" translate="yes" xml:space="preserve">
          <source>What if I don't know which encoding was used?</source>
          <target state="translated">どのエンコードが使われていたかわからない場合はどうすればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="b012d213b447ce5a8b3e4b308232eb1a6c342960" translate="yes" xml:space="preserve">
          <source>What if my question isn't answered in the FAQ?</source>
          <target state="translated">私の質問がFAQで回答されていない場合はどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="30310a64f6e6f73114ef8ff5955e14d7deb5a4c5" translate="yes" xml:space="preserve">
          <source>What if the interface provided by the C callback doesn't contain a parameter which allows the file handle to Perl subroutine mapping? Say in the asynchronous i/o package, the callback function gets passed only the &lt;code&gt;buffer&lt;/code&gt; parameter like this</source>
          <target state="translated">Cコールバックによって提供されるインターフェースに、Perlサブルーチンマッピングへのファイルハンドルを許可するパラメーターが含まれていない場合はどうなりますか？非同期I / Oパッケージで、コールバック関数はこのように &lt;code&gt;buffer&lt;/code&gt; パラメーターのみが渡されると言います</target>
        </trans-unit>
        <trans-unit id="f9002d28fd7ee52f5e73c33c74a403efd3585ddf" translate="yes" xml:space="preserve">
          <source>What import does</source>
          <target state="translated">どのような輸入をするのか</target>
        </trans-unit>
        <trans-unit id="9281510e66c9b036bf0f2b1f98689d5dbd410309" translate="yes" xml:space="preserve">
          <source>What is &quot;the UTF8 flag&quot;?</source>
          <target state="translated">UTF8フラグ」とは何ですか?</target>
        </trans-unit>
        <trans-unit id="48776d293c1cf7b50ee10897815e6e1c09782388" translate="yes" xml:space="preserve">
          <source>What is /o really for?</source>
          <target state="translated">oは本当に何のためにあるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="f799c97279ef39d3426ad309ad7dfc5a7d36fff1" translate="yes" xml:space="preserve">
          <source>What is &lt;code&gt;/o&lt;/code&gt; really for?</source>
          <target state="translated">&lt;code&gt;/o&lt;/code&gt; は本当に何のためのものですか？</target>
        </trans-unit>
        <trans-unit id="4da6343eb07811de611e2143a23a9e42def6f17c" translate="yes" xml:space="preserve">
          <source>What is C3?</source>
          <target state="translated">C3とは?</target>
        </trans-unit>
        <trans-unit id="3f1ecd4984feb033599a0b8b92a1a9741f5b5e8e" translate="yes" xml:space="preserve">
          <source>What is Module::Build and how does it relate to MakeMaker?</source>
          <target state="translated">Module::Build とは何ですか?</target>
        </trans-unit>
        <trans-unit id="bda040c2e08659bcff6001c6dcad6149b2b71af9" translate="yes" xml:space="preserve">
          <source>What is Perl 6?</source>
          <target state="translated">Perl 6とは何ですか?</target>
        </trans-unit>
        <trans-unit id="90e6903f9207d6b5637de9d9ec259575b1877362" translate="yes" xml:space="preserve">
          <source>What is Perl?</source>
          <target state="translated">Perlとは何ですか?</target>
        </trans-unit>
        <trans-unit id="79dc15d896921a5be3532940c7478220c26d76f5" translate="yes" xml:space="preserve">
          <source>What is Plack and PSGI?</source>
          <target state="translated">プラックとPSGIとは?</target>
        </trans-unit>
        <trans-unit id="234e64d864b7e4e19b7d995b815d4db958366917" translate="yes" xml:space="preserve">
          <source>What is Raku (Perl 6)?</source>
          <target state="translated">Raku (Perl 6)とは何ですか?</target>
        </trans-unit>
        <trans-unit id="5c878af8c7031f81a5ddca206fc60a5a12f9ad1d" translate="yes" xml:space="preserve">
          <source>What is Unicode, anyway?</source>
          <target state="translated">そもそもユニコードって何?</target>
        </trans-unit>
        <trans-unit id="387b2d5d4628ca2a97a160cf17017d26f2363e65" translate="yes" xml:space="preserve">
          <source>What is a &quot;wide character&quot;?</source>
          <target state="translated">ワイドキャラ」とは?</target>
        </trans-unit>
        <trans-unit id="6c07c0817bd40c0602c40f4eb163a577c33eb9e2" translate="yes" xml:space="preserve">
          <source>What is a 'record'? By default, the meaning is the same as for the &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; operator: It's a string terminated by &lt;code&gt;$/&lt;/code&gt; , which is probably &lt;code&gt;&quot;\n&quot;&lt;/code&gt; . (Minor exception: on DOS and Win32 systems, a 'record' is a string terminated by &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; .) You may change the definition of &quot;record&quot; by supplying the &lt;code&gt;recsep&lt;/code&gt; option in the &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call:</source>
          <target state="translated">「レコード」とは何ですか？デフォルトでは、意味は &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; 演算子の場合と同じです。これは &lt;code&gt;$/&lt;/code&gt; で終了する文字列で、おそらく &lt;code&gt;&quot;\n&quot;&lt;/code&gt; です。 （マイナー例外：DOSとWin32システム上で、「レコードが」で終わる文字列である &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; 。）あなたが供給することにより、「記録」の定義を変更することがあり &lt;code&gt;recsep&lt;/code&gt; 中にオプションを &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; コール：</target>
        </trans-unit>
        <trans-unit id="046dcad9c1b5d6658ae493e5f69f47ba914f7843" translate="yes" xml:space="preserve">
          <source>What is a 'record'? By default, the meaning is the same as for the &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; operator: It's a string terminated by &lt;code&gt;$/&lt;/code&gt;, which is probably &lt;code&gt;&quot;\n&quot;&lt;/code&gt;. (Minor exception: on DOS and Win32 systems, a 'record' is a string terminated by &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt;.) You may change the definition of &quot;record&quot; by supplying the &lt;code&gt;recsep&lt;/code&gt; option in the &lt;code&gt;tie&lt;/code&gt; call:</source>
          <target state="translated">「レコード」とは何ですか？デフォルトでは、意味は &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; 演算子の場合と同じです。これは &lt;code&gt;$/&lt;/code&gt; で終わる文字列であり、おそらく &lt;code&gt;&quot;\n&quot;&lt;/code&gt; です。 （マイナーな例外：DOSおよびWin32システムでは、「record」は &lt;code&gt;&quot;\r\n&quot;&lt;/code&gt; 終了する文字列です。） &lt;code&gt;tie&lt;/code&gt; 呼び出しで &lt;code&gt;recsep&lt;/code&gt; オプションを指定することにより、「record」の定義を変更できます。</target>
        </trans-unit>
        <trans-unit id="41a841a9e9e59dbc901dca478a52731689558d70" translate="yes" xml:space="preserve">
          <source>What is a DBM Filter?</source>
          <target state="translated">DBMフィルターとは?</target>
        </trans-unit>
        <trans-unit id="75ea94c254fb7320b80e8d79c658d169412a3588" translate="yes" xml:space="preserve">
          <source>What is a JAPH?</source>
          <target state="translated">JAPHとは?</target>
        </trans-unit>
        <trans-unit id="8e7e75800308f6339899e8db69308ae93f0337df" translate="yes" xml:space="preserve">
          <source>What is a regular expression engine?</source>
          <target state="translated">正規表現エンジンとは?</target>
        </trans-unit>
        <trans-unit id="e7e08c44504e895661b69ab0d094008da5741e55" translate="yes" xml:space="preserve">
          <source>What is a regular expression? A regular expression is simply a string that describes a pattern. Patterns are in common use these days; examples are the patterns typed into a search engine to find web pages and the patterns used to list files in a directory, e.g., &lt;code&gt;ls *.txt&lt;/code&gt; or &lt;code&gt;dir *.*&lt;/code&gt;. In Perl, the patterns described by regular expressions are used to search strings, extract desired parts of strings, and to do search and replace operations.</source>
          <target state="translated">正規表現とは何ですか？正規表現は、単にパターンを説明する文字列です。最近、パターンが一般的に使用されています。例としては、Webページを検索するために検索エンジンに入力されるパターンや、 &lt;code&gt;ls *.txt&lt;/code&gt; や &lt;code&gt;dir *.*&lt;/code&gt; などのディレクトリ内のファイルを一覧表示するために使用されるパターンがあります。Perlでは、正規表現で記述されたパターンを使用して、文字列を検索し、文字列の必要な部分を抽出し、検索および置換操作を実行します。</target>
        </trans-unit>
        <trans-unit id="ad1619062d7422922f56678f7cf58c8d2f19d36b" translate="yes" xml:space="preserve">
          <source>What is a regular expression? At its most basic, a regular expression is a template that is used to determine if a string has certain characteristics. The string is most often some text, such as a line, sentence, web page, or even a whole book, but less commonly it could be some binary data as well. Suppose we want to determine if the text in variable, &lt;code&gt;$var&lt;/code&gt; contains the sequence of characters &lt;code&gt;m u s h r o o m&lt;/code&gt; (blanks added for legibility). We can write in Perl</source>
          <target state="translated">正規表現とは何ですか？最も基本的な正規表現は、文字列に特定の特性があるかどうかを判断するために使用されるテンプレートです。文字列は、ほとんどの場合、行、文、Webページ、または本全体などのテキストですが、あまり一般的ではありませんが、バイナリデータの場合もあります。変数のテキスト &lt;code&gt;$var&lt;/code&gt; に、一連の文字の &lt;code&gt;m u s h r o o m&lt;/code&gt; （読みやすくするために空白が追加されている）が含まれているかどうかを判別するとします。Perlで書くことができます</target>
        </trans-unit>
        <trans-unit id="fc1f1924f0cab71521b063802ea721cd9de2bf43" translate="yes" xml:space="preserve">
          <source>What is an &quot;IV&quot;?</source>
          <target state="translated">IV」とは何ですか?</target>
        </trans-unit>
        <trans-unit id="778b266015494167ffcfb5699798ca074f01e4ed" translate="yes" xml:space="preserve">
          <source>What is libnet ?</source>
          <target state="translated">libnetとは何ですか?</target>
        </trans-unit>
        <trans-unit id="8de138e681884a542d6a632e3d45af8060ecf685" translate="yes" xml:space="preserve">
          <source>What is meant here is unclear, as the &lt;code&gt;\N{...}&lt;/code&gt; escape is a sequence of code points, so this is made an error.</source>
          <target state="translated">&lt;code&gt;\N{...}&lt;/code&gt; エスケープはコードポイントのシーケンスであるため、ここでの意味は不明確であり、これはエラーになります。</target>
        </trans-unit>
        <trans-unit id="7e4d744a0a34b3ed6f2bacfcf8917df2728b341f" translate="yes" xml:space="preserve">
          <source>What is much worse, some DLLs change the floating point flags when in _DLLInitTerm() (e.g.,</source>
          <target state="translated">さらに悪いことに、いくつかの DLL は _DLLInitTerm()で浮動小数点フラグを変更します。</target>
        </trans-unit>
        <trans-unit id="b80f71784676643cac72b04d16a86ddd2aad93c3" translate="yes" xml:space="preserve">
          <source>What is perl.com? Perl Mongers? pm.org? perl.org? cpan.org?</source>
          <target state="translated">perl.comとは何ですか?Perl Mongers? pm.org? perl.org?</target>
        </trans-unit>
        <trans-unit id="b4511cf9900e620f3e5c53ed90d05dd1b6347288" translate="yes" xml:space="preserve">
          <source>What is socket.ph and where do I get it?</source>
          <target state="translated">socket.phとは何ですか?</target>
        </trans-unit>
        <trans-unit id="466ca1293cf697f510f855a869e855e56cd9f9c1" translate="yes" xml:space="preserve">
          <source>What is the difference between &quot;state&quot; subs and &quot;my&quot; subs? Each time that execution enters a block when &quot;my&quot; subs are declared, a new copy of each sub is created. &quot;State&quot; subroutines persist from one execution of the containing block to the next.</source>
          <target state="translated">状態」サブと「私の」サブの違いは何ですか?&quot;my &quot;サブが宣言されているときに、その実行がブロックに入るたびに、各サブの新しいコピーが作成されます。&quot;状態 &quot;サブルーチンは、含まれるブロックの1つの実行から次の実行へと持続します。</target>
        </trans-unit>
        <trans-unit id="fc949184376f42b77d53568413143ee5107891ea" translate="yes" xml:space="preserve">
          <source>What is the difference between $array[1] and @array[1]?</source>
          <target state="translated">また、$array[1]と@array[1]の違いは何でしょうか?</target>
        </trans-unit>
        <trans-unit id="e5e94a34863c5b06b0902ba29af6bbdd60a89b26" translate="yes" xml:space="preserve">
          <source>What is the difference between :encoding and :utf8?</source>
          <target state="translated">encoding と :utf8 の違いは何ですか?</target>
        </trans-unit>
        <trans-unit id="87b2e888c908f6842e557ad8d646535f8dd07500" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;:encoding&lt;/code&gt; and &lt;code&gt;:utf8&lt;/code&gt; ?</source>
          <target state="translated">&lt;code&gt;:encoding&lt;/code&gt; と &lt;code&gt;:utf8&lt;/code&gt; の違いは何ですか？</target>
        </trans-unit>
        <trans-unit id="aa686143aeb2276da66fe372809de6163adbd5d8" translate="yes" xml:space="preserve">
          <source>What is the difference between &lt;code&gt;:encoding&lt;/code&gt; and &lt;code&gt;:utf8&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;:encoding&lt;/code&gt; と &lt;code&gt;:utf8&lt;/code&gt; の違いは何ですか？</target>
        </trans-unit>
        <trans-unit id="bdd9348a87a0e037c9116062611c030ca4d85da9" translate="yes" xml:space="preserve">
          <source>What is the difference between a list and an array?</source>
          <target state="translated">リストと配列の違いは何ですか?</target>
        </trans-unit>
        <trans-unit id="aa2dc660c0cced5d46caea2cf443fe5e368244c8" translate="yes" xml:space="preserve">
          <source>What is this Perl statement all about? &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; is a simple double-quoted string. &lt;code&gt;World&lt;/code&gt; is the regular expression and the &lt;code&gt;//&lt;/code&gt; enclosing &lt;code&gt;/World/&lt;/code&gt; tells Perl to search a string for a match. The operator &lt;code&gt;=~&lt;/code&gt; associates the string with the regexp match and produces a true value if the regexp matched, or false if the regexp did not match. In our case, &lt;code&gt;World&lt;/code&gt; matches the second word in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; , so the expression is true. Expressions like this are useful in conditionals:</source>
          <target state="translated">このPerlステートメントはすべて何ですか？ &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; は、単純に二重引用符で囲まれた文字列です。 &lt;code&gt;World&lt;/code&gt; は正規表現であり、 &lt;code&gt;//&lt;/code&gt; を囲む &lt;code&gt;/World/&lt;/code&gt; は、一致する文字列を検索するようPerlに指示します。演算子 &lt;code&gt;=~&lt;/code&gt; は、文字列を正規表現一致に関連付け、正規表現が一致した場合はtrue値を生成し、正規表現が一致しなかった場合はfalseを生成します。この例では、 &lt;code&gt;World&lt;/code&gt; は &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; の 2番目の単語と一致するため、式はtrueです。このような式は条件文で役立ちます。</target>
        </trans-unit>
        <trans-unit id="8288a589c4caf7bd2276d185a7bd5fbf595dc73f" translate="yes" xml:space="preserve">
          <source>What is this Perl statement all about? &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; is a simple double-quoted string. &lt;code&gt;World&lt;/code&gt; is the regular expression and the &lt;code&gt;//&lt;/code&gt; enclosing &lt;code&gt;/World/&lt;/code&gt; tells Perl to search a string for a match. The operator &lt;code&gt;=~&lt;/code&gt; associates the string with the regexp match and produces a true value if the regexp matched, or false if the regexp did not match. In our case, &lt;code&gt;World&lt;/code&gt; matches the second word in &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt;, so the expression is true. Expressions like this are useful in conditionals:</source>
          <target state="translated">このPerlステートメントとは何ですか？ &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; は、単純な二重引用符で囲まれた文字列です。 &lt;code&gt;World&lt;/code&gt; は正規表現であり、 &lt;code&gt;//&lt;/code&gt; 囲んでいる &lt;code&gt;/World/&lt;/code&gt; は、Perlに文字列で一致するものを検索するように指示します。演算子 &lt;code&gt;=~&lt;/code&gt; は、文字列を正規表現の一致に関連付け、正規表現が一致した場合はtrue値を生成し、正規表現が一致しなかった場合はfalseを生成します。この場合、 &lt;code&gt;World&lt;/code&gt; は &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; の2番目の単語と一致するため、式は真です。このような式は、条件文で役立ちます。</target>
        </trans-unit>
        <trans-unit id="c9fb4cb8e09b50cfb90602035114712466d59042" translate="yes" xml:space="preserve">
          <source>What is variable suicide and how can I prevent it?</source>
          <target state="translated">可変性自殺とは何か、どうすれば予防できるのか?</target>
        </trans-unit>
        <trans-unit id="49ac75fc20864efd20e6c484dddbafd73db6a2e3" translate="yes" xml:space="preserve">
          <source>What is your favorite pager program?</source>
          <target state="translated">お気に入りのポケベルプログラムは?</target>
        </trans-unit>
        <trans-unit id="fd63f60b8b6a48f0264ba03539d262e0388b66e2" translate="yes" xml:space="preserve">
          <source>What is your favorite shell?</source>
          <target state="translated">あなたの好きな貝殻は何ですか?</target>
        </trans-unit>
        <trans-unit id="7a785a8e58c6a9e20c1539582a1a9c97e125374e" translate="yes" xml:space="preserve">
          <source>What kind of stuff is contained in this distribution. Most things on CPAN are &lt;code&gt;module&lt;/code&gt;s (which can also mean a collection of modules), but some things are &lt;code&gt;script&lt;/code&gt;s.</source>
          <target state="translated">このディストリビューションにはどのようなものが含まれていますか。CPANのほとんどのものは &lt;code&gt;module&lt;/code&gt; （モジュールのコレクションを意味することもあります）ですが、いくつかのものは &lt;code&gt;script&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3cdeb97ea551b504f3da8bf43202e9fd344363cd" translate="yes" xml:space="preserve">
          <source>What kind of test? Possibilities include, skip, todo etc. See &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; for more details.</source>
          <target state="translated">どんなテスト？可能性には、スキップ、todoなどがあります。詳細については、&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="f41b525bca416a73d68432b879e12cd6ce5cae2d" translate="yes" xml:space="preserve">
          <source>What kind of threads are Perl threads?</source>
          <target state="translated">Perlのスレッドってどんなスレッドですか?</target>
        </trans-unit>
        <trans-unit id="523c42f572591f0bfb9eb624031ecf0ded9f0a2a" translate="yes" xml:space="preserve">
          <source>What library to use?</source>
          <target state="translated">どのような図書館を利用するか?</target>
        </trans-unit>
        <trans-unit id="c9dcfd1a76d749e07495e332956ce4a77d52e8a9" translate="yes" xml:space="preserve">
          <source>What machines support Perl? Where do I get it?</source>
          <target state="translated">Perl をサポートしているマシンは?どこで入手できますか?</target>
        </trans-unit>
        <trans-unit id="f891fe8a2be3f1ffe86b5a80057ef4ca6da1223d" translate="yes" xml:space="preserve">
          <source>What machines support libnet ?</source>
          <target state="translated">libnet をサポートしているマシンは?</target>
        </trans-unit>
        <trans-unit id="602afa592af7887a3bffb104fc775a95a31125b0" translate="yes" xml:space="preserve">
          <source>What mailing lists are there for Perl?</source>
          <target state="translated">Perl のためのメーリングリストはありますか?</target>
        </trans-unit>
        <trans-unit id="4862bb3e93457f890d9e122c5362daa5b89c1284" translate="yes" xml:space="preserve">
          <source>What makes a method special is</source>
          <target state="translated">メソッドを特別なものにしているのは</target>
        </trans-unit>
        <trans-unit id="c65301b41224a5b616b4c8a04b46b840cdda0ef5" translate="yes" xml:space="preserve">
          <source>What makes all of this important is that the Exporter module uses glob aliasing as the import/export mechanism. Whether or not you can properly localize a variable that has been exported from a module depends on how it was exported:</source>
          <target state="translated">これらすべてを重要なものにしているのは、Exporter モジュールが import/export メカニズムとして glob aliasing を使用していることです。モジュールからエクスポートされた変数を適切にローカライズできるかどうかは、どのようにエクスポートされたかに依存します。</target>
        </trans-unit>
        <trans-unit id="8fb5a283f17d0d098d1490569f3aaeb90f52254c" translate="yes" xml:space="preserve">
          <source>What makes for a good patch?</source>
          <target state="translated">何が良いパッチになるのか?</target>
        </trans-unit>
        <trans-unit id="486e1e8fa6072821d31ad344e76845b470464a6d" translate="yes" xml:space="preserve">
          <source>What makes this pass interesting for perl developers is that some optimization may be performed on this pass. This is optimization by so-called &quot;check routines&quot;. The correspondence between node names and corresponding check routines is described in</source>
          <target state="translated">perl開発者にとってこのパスが面白いのは、このパスで何らかの最適化が行われる可能性があるということです。これはいわゆる「チェックルーチン」による最適化です。ノード名と対応するチェックルーチンの対応については</target>
        </trans-unit>
        <trans-unit id="7c3d71cb8c06e618edc314c89194f61b595a4c29" translate="yes" xml:space="preserve">
          <source>What modules and extensions are available for Perl? What is CPAN?</source>
          <target state="translated">Perlにはどのようなモジュールや拡張機能がありますか?CPANとは何ですか?</target>
        </trans-unit>
        <trans-unit id="5eca61ede7bdc9f4a1c178015ba2713ba5ace84a" translate="yes" xml:space="preserve">
          <source>What modules does a particular distribution contain?</source>
          <target state="translated">特定のディストリビューションにはどのようなモジュールが含まれていますか?</target>
        </trans-unit>
        <trans-unit id="709f8e1c07fc1fe28e0f229bb8ce88d468c08c8e" translate="yes" xml:space="preserve">
          <source>What modules shipped with versions of perl</source>
          <target state="translated">perl のバージョンに同梱されているモジュール</target>
        </trans-unit>
        <trans-unit id="bbb49ac4107bc251bf787f21f8a88fe7e30321ce" translate="yes" xml:space="preserve">
          <source>What most people need to know (superclasses on top.)</source>
          <target state="translated">ほとんどの人が知っておくべきこと(上の方のスーパークラス。</target>
        </trans-unit>
        <trans-unit id="1b01351f5f724ad044096c916ace26f9169184a3" translate="yes" xml:space="preserve">
          <source>What other modules do I need ?</source>
          <target state="translated">他にどのようなモジュールが必要ですか?</target>
        </trans-unit>
        <trans-unit id="d5f3978619a4438d900606a19c92b7d1f8afc742" translate="yes" xml:space="preserve">
          <source>What regop is next?</source>
          <target state="translated">次はどんなレゴップ?</target>
        </trans-unit>
        <trans-unit id="88176d2562c5c584253c31b2148c8703789870d4" translate="yes" xml:space="preserve">
          <source>What seems a successful strategy is the combination of &lt;code&gt;reload
cpan&lt;/code&gt; and the debugging switches. Add a new debug statement while running in the shell and then issue a &lt;code&gt;reload cpan&lt;/code&gt; and see the new debugging messages immediately without losing the current context.</source>
          <target state="translated">成功した戦略のように思われるのは、 &lt;code&gt;reload cpan&lt;/code&gt; とデバッグスイッチの組み合わせです。シェルで実行中に新しいデバッグステートメントを追加し、 &lt;code&gt;reload cpan&lt;/code&gt; を発行すると、現在のコンテキストを失うことなく、新しいデバッグメッセージがすぐに表示されます。</target>
        </trans-unit>
        <trans-unit id="494e70de221fde56713efc23ab1ca24064c718dc" translate="yes" xml:space="preserve">
          <source>What should I make into a module?</source>
          <target state="translated">何をモジュールにすればいいの?</target>
        </trans-unit>
        <trans-unit id="0e5fb1910c7b0867ac71d8402069e7fbfc90bc05" translate="yes" xml:space="preserve">
          <source>What some helper &lt;b&gt;process&lt;/b&gt; did to transform the incoming data into a form more suitable for the current process. Often done with an incoming &lt;b&gt;pipe&lt;/b&gt;. See also &lt;b&gt;C preprocessor&lt;/b&gt;.</source>
          <target state="translated">いくつかのヘルパー&lt;b&gt;プロセス&lt;/b&gt;が受信データを現在のプロセスにより適した形式に変換するために行ったこと。多くの場合、着信&lt;b&gt;パイプで&lt;/b&gt;行われます。&lt;b&gt;Cプリプロセッサ&lt;/b&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="05edee69ab0b091485f39a349759f585c24e0340" translate="yes" xml:space="preserve">
          <source>What the program or function returns, if successful. This section can be omitted for programs whose precise exit codes aren't important, provided they return 0 on success and non-zero on failure as is standard. It should always be present for functions. For modules, it may be useful to summarize return values from the module interface here, or it may be more useful to discuss return values separately in the documentation of each function or method the module provides.</source>
          <target state="translated">プログラムや関数が成功した場合に何を返すか。成功した場合は0を返し、失敗した場合は0以外の値を返すという標準的な条件であれば、正確な終了コードが重要ではないプログラムの場合は、このセクションを省略することができます。関数の場合は、常にこのセクションは存在しなければなりません。モジュールの場合は、モジュールのインターフェイスからの戻り値をここにまとめておくと便利ですし、モジュールが提供する各関数やメソッドのドキュメントの中で、戻り値について個別に説明しておくとより便利かもしれません。</target>
        </trans-unit>
        <trans-unit id="b11685dda194db5e13d9f10a2284151cb724112f" translate="yes" xml:space="preserve">
          <source>What this does is creates a new binary op, and feeds it a number of variables. The variables refer to the tokens: &lt;code&gt;$1&lt;/code&gt; is the first token in the input, &lt;code&gt;$2&lt;/code&gt; the second, and so on - think regular expression backreferences. &lt;code&gt;$$&lt;/code&gt; is the op returned from this reduction. So, we call &lt;code&gt;newBINOP&lt;/code&gt; to create a new binary operator. The first parameter to &lt;code&gt;newBINOP&lt;/code&gt; , a function in</source>
          <target state="translated">これにより、新しいバイナリopが作成され、いくつかの変数が提供されます。変数はトークンを参照します。 &lt;code&gt;$1&lt;/code&gt; は入力の最初のトークン、 &lt;code&gt;$2&lt;/code&gt; は2番目のトークンというように、正規表現の後方参照を考えます。 &lt;code&gt;$$&lt;/code&gt; は、この削減から返される演算です。したがって、 &lt;code&gt;newBINOP&lt;/code&gt; を呼び出して新しい2項演算子を作成します。の関数 &lt;code&gt;newBINOP&lt;/code&gt; の最初のパラメータ</target>
        </trans-unit>
        <trans-unit id="b67434e808539a7f62532e0f74741a29eeb423fa" translate="yes" xml:space="preserve">
          <source>What this does is creates a new binary op, and feeds it a number of variables. The variables refer to the tokens: &lt;code&gt;$1&lt;/code&gt; is the first token in the input, &lt;code&gt;$2&lt;/code&gt; the second, and so on - think regular expression backreferences. &lt;code&gt;$$&lt;/code&gt; is the op returned from this reduction. So, we call &lt;code&gt;newBINOP&lt;/code&gt; to create a new binary operator. The first parameter to &lt;code&gt;newBINOP&lt;/code&gt;, a function in</source>
          <target state="translated">これが行うことは、新しいバイナリopを作成し、それにいくつかの変数を供給することです。変数はトークンを参照します。 &lt;code&gt;$1&lt;/code&gt; は入力の最初のトークン、 &lt;code&gt;$2&lt;/code&gt; は2番目、というように続きます。正規表現の後方参照を考えてください。 &lt;code&gt;$$&lt;/code&gt; は、この削減から返される操作です。したがって、 &lt;code&gt;newBINOP&lt;/code&gt; を呼び出して、新しい二項演算子を作成します。 &lt;code&gt;newBINOP&lt;/code&gt; の最初のパラメータ、関数</target>
        </trans-unit>
        <trans-unit id="4cc8ecd0e95182504b6e5e23619c1654db502160" translate="yes" xml:space="preserve">
          <source>What this means is that if you have data written by Storable 1.x running on perl 5.6.0 or 5.6.1 configured with 64 bit integers on Unix or Linux then by default this Storable will refuse to read it, giving the error</source>
          <target state="translated">これは何を意味しているのかというと、Storable 1.x が Unix や Linux 上で perl 5.6.0 や 5.6.1 で 64 ビット整数で設定したデータを実行している場合、デフォルトではこの Storable はそのデータの読み込みを拒否して</target>
        </trans-unit>
        <trans-unit id="c1074e9471d381d1e3fa377b4baeab5a37484773" translate="yes" xml:space="preserve">
          <source>What this means is that unless the &lt;code&gt;/a&lt;/code&gt; modifier is in effect &lt;code&gt;\d&lt;/code&gt; not only matches the digits '0' - '9', but also Arabic, Devanagari, and digits from other languages. This may cause some confusion, and some security issues.</source>
          <target state="translated">つまり、 &lt;code&gt;/a&lt;/code&gt; 修飾子が有効でない限り、 &lt;code&gt;\d&lt;/code&gt; は数字の「0」〜「9」だけでなく、アラビア語、デーバナーガリー文字、および他の言語の数字にも一致します。これにより、混乱やセキュリティ上の問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="024bfa55bc6c90f99bae14081b1ca78d49501b2e" translate="yes" xml:space="preserve">
          <source>What this says is: &lt;code&gt;1..1&lt;/code&gt; &quot;I'm going to run one test.&quot; [1] &lt;code&gt;ok 1&lt;/code&gt; &quot;The first test passed&quot;. And that's about all magic there is to testing. Your basic unit of testing is the</source>
          <target state="translated">これが言うことは： &lt;code&gt;1..1&lt;/code&gt; 「私は1つのテストを実行するつもりです。」 [1] &lt;code&gt;ok 1&lt;/code&gt; 「最初のテストに合格しました」。そして、それはテストにあるすべての魔法についてです。テストの基本単位は</target>
        </trans-unit>
        <trans-unit id="b90ef1b55a5f8c0ad6415f98413e6a092c07a530" translate="yes" xml:space="preserve">
          <source>What to put after &quot;1/crontab&quot; in the URL. This option is not set by default.</source>
          <target state="translated">URLの「1/crontab」の後に何を入れるか。このオプションはデフォルトでは設定されていません。</target>
        </trans-unit>
        <trans-unit id="616a4166af25f3f615ff259d316398355eca1fd7" translate="yes" xml:space="preserve">
          <source>What to put after &quot;Foo%3a%3aBar&quot; in the URL. This option is not set by default.</source>
          <target state="translated">URLの「Foo%3a%3aBar」の後に何を入れるか。このオプションはデフォルトでは設定されていません。</target>
        </trans-unit>
        <trans-unit id="774021bac19bdf5e083a7ddf41b218a869e89eea" translate="yes" xml:space="preserve">
          <source>What to put before and after the title in the head. The values should already be &amp;amp;-escaped.</source>
          <target state="translated">頭のタイトルの前後に何を置くか。値はすでにエスケープされているはずです。</target>
        </trans-unit>
        <trans-unit id="46d727439e117340febafb43135cffaac5ab87fa" translate="yes" xml:space="preserve">
          <source>What utilities shipped with versions of perl</source>
          <target state="translated">perl のバージョンに同梱されているユーティリティ</target>
        </trans-unit>
        <trans-unit id="41d1f562b44341deaff0802951db706e407b9e33" translate="yes" xml:space="preserve">
          <source>What version of Perl you are running?</source>
          <target state="translated">お使いのPerlのバージョンを教えてください。</target>
        </trans-unit>
        <trans-unit id="79f6137e22ba58dcead1d29483955dc880eaf485" translate="yes" xml:space="preserve">
          <source>What was in this chunk of memory? Numbers, characters, or a mixture of both? Assuming that we're on a computer where ASCII (or some similar) encoding is used: hexadecimal values in the range &lt;code&gt;0x40&lt;/code&gt; - &lt;code&gt;0x5A&lt;/code&gt; indicate an uppercase letter, and &lt;code&gt;0x20&lt;/code&gt; encodes a space. So we might assume it is a piece of text, which some are able to read like a tabloid; but others will have to get hold of an ASCII table and relive that firstgrader feeling. Not caring too much about which way to read this, we note that &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the template code &lt;code&gt;H&lt;/code&gt; converts the contents of a sequence of bytes into the customary hexadecimal notation. Since &quot;a sequence of&quot; is a pretty vague indication of quantity, &lt;code&gt;H&lt;/code&gt; has been defined to convert just a single hexadecimal digit unless it is followed by a repeat count. An asterisk for the repeat count means to use whatever remains.</source>
          <target state="translated">このメモリのチャンクには何がありましたか？数字、文字、またはその両方の組み合わせ？範囲の16進数値：我々はASCII（または類似の）符号化が使用されているコンピューターにしていると仮定すると、 &lt;code&gt;0x40&lt;/code&gt; の - &lt;code&gt;0x5A&lt;/code&gt; は、大文字を示し、 &lt;code&gt;0x20&lt;/code&gt; にエンコード空間。したがって、これはテキストの一部であると想定するかもしれません。しかし、ASCIIテーブルを手に入れて、その1年生の感覚を追体験する人もいます。これをどのように読むかについてあまり気にしないで、テンプレートコード &lt;code&gt;H&lt;/code&gt; で &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; と、バイトシーケンスの内容が通常の16進表記に変換されることに注意してください。 「のシーケンス」は量のかなり漠然とした指標なので、 &lt;code&gt;H&lt;/code&gt; 繰り返し回数が続く場合を除いて、1つの16進数のみを変換するように定義されています。繰り返し回数のアスタリスクは、残っているものをすべて使用することを意味します。</target>
        </trans-unit>
        <trans-unit id="0db88274915aa193b8762de0b1150e4497a2898f" translate="yes" xml:space="preserve">
          <source>What was in this chunk of memory? Numbers, characters, or a mixture of both? Assuming that we're on a computer where ASCII (or some similar) encoding is used: hexadecimal values in the range &lt;code&gt;0x40&lt;/code&gt; - &lt;code&gt;0x5A&lt;/code&gt; indicate an uppercase letter, and &lt;code&gt;0x20&lt;/code&gt; encodes a space. So we might assume it is a piece of text, which some are able to read like a tabloid; but others will have to get hold of an ASCII table and relive that firstgrader feeling. Not caring too much about which way to read this, we note that &lt;code&gt;unpack&lt;/code&gt; with the template code &lt;code&gt;H&lt;/code&gt; converts the contents of a sequence of bytes into the customary hexadecimal notation. Since &quot;a sequence of&quot; is a pretty vague indication of quantity, &lt;code&gt;H&lt;/code&gt; has been defined to convert just a single hexadecimal digit unless it is followed by a repeat count. An asterisk for the repeat count means to use whatever remains.</source>
          <target state="translated">このメモリのチャンクには何がありましたか？数字、文字、または両方の混合物？範囲の16進数値：我々はASCII（または類似の）符号化が使用されているコンピューターにしていると仮定すると、 &lt;code&gt;0x40&lt;/code&gt; の- &lt;code&gt;0x5A&lt;/code&gt; は、大文字を示し、 &lt;code&gt;0x20&lt;/code&gt; にエンコード空間。したがって、それはタブロイド紙のように読むことができるテキストの一部であると考えるかもしれません。しかし、他の人はASCIIテーブルを手に入れて、その1年生の気持ちを追体験する必要があります。これをどのように読み取るかについてはあまり気にしないでください。テンプレートコード &lt;code&gt;H&lt;/code&gt; を &lt;code&gt;unpack&lt;/code&gt; して解凍すると、バイトシーケンスの内容が通常の16進表記に変換されることに注意してください。 「のシーケンス」は量のかなり漠然とした指標であるため、 &lt;code&gt;H&lt;/code&gt; 繰り返しカウントが続かない限り、1桁の16進数のみを変換するように定義されています。繰り返し回数のアスタリスクは、残っているものをすべて使用することを意味します。</target>
        </trans-unit>
        <trans-unit id="16a26aa5328e43e90f045fe86149fb674a158916" translate="yes" xml:space="preserve">
          <source>What we actually need to do is expand the width of the fields. The &lt;code&gt;A&lt;/code&gt; format pads any non-existent characters with spaces, so we can use the additional spaces to line up our fields, like this:</source>
          <target state="translated">実際に必要なのは、フィールドの幅を広げることです。 &lt;code&gt;A&lt;/code&gt; のフォーマットパッド、私たちはこのように、私たちのフィールドをラインアップするために追加のスペースを使用することができ、スペースを持つ存在しない文字：</target>
        </trans-unit>
        <trans-unit id="b18ad647190599dbc6f89a0be950252c58677d5e" translate="yes" xml:space="preserve">
          <source>What we have described so far is the single form of the &lt;code&gt;\p{...}&lt;/code&gt; character classes. There is also a compound form which you may run into. These look like &lt;code&gt;\p{&lt;i&gt;name&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; or &lt;code&gt;\p{&lt;i&gt;name&lt;/i&gt;:&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; (the equals sign and colon can be used interchangeably). These are more general than the single form, and in fact most of the single forms are just Perl-defined shortcuts for common compound forms. For example, the script examples in the previous paragraph could be written equivalently as &lt;code&gt;\p{Script_Extensions=Latin}&lt;/code&gt;, &lt;code&gt;\p{Script_Extensions:Greek}&lt;/code&gt;, &lt;code&gt;\p{script_extensions=katakana}&lt;/code&gt;, and &lt;code&gt;\P{script_extensions=balinese}&lt;/code&gt; (case is irrelevant between the &lt;code&gt;{}&lt;/code&gt; braces). You may never have to use the compound forms, but sometimes it is necessary, and their use can make your code easier to understand.</source>
          <target state="translated">これまでに説明したのは、 &lt;code&gt;\p{...}&lt;/code&gt; 文字クラスの単一の形式です。あなたが遭遇するかもしれない複合形もあります。これらは &lt;code&gt;\p{&lt;i&gt;name&lt;/i&gt;=&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; または &lt;code&gt;\p{&lt;i&gt;name&lt;/i&gt;:&lt;i&gt;value&lt;/i&gt;}&lt;/code&gt; ように見えます（等号とコロンは同じ意味で使用できます）。これらは単一フォームよりも一般的であり、実際、単一フォームのほとんどは、一般的な複合フォームのPerl定義のショートカットです。たとえば、前の段落のスクリプト例は、 &lt;code&gt;\p{Script_Extensions=Latin}&lt;/code&gt; 、 &lt;code&gt;\p{Script_Extensions:Greek}&lt;/code&gt; 、 &lt;code&gt;\p{script_extensions=katakana}&lt;/code&gt; 、およびと同等に記述できます。 &lt;code&gt;\P{script_extensions=balinese}&lt;/code&gt; （大文字と小文字は &lt;code&gt;{}&lt;/code&gt; 中括弧の間では関係ありません）。複合フォームを使用する必要はないかもしれませんが、必要な場合があり、それらを使用するとコードが理解しやすくなります。</target>
        </trans-unit>
        <trans-unit id="0c37b176ea3009646e0be80ec6a53f25b8ff9dcd" translate="yes" xml:space="preserve">
          <source>What we have described so far is the single form of the &lt;code&gt;\p{...}&lt;/code&gt; character classes. There is also a compound form which you may run into. These look like &lt;code&gt;\p{name=value}&lt;/code&gt; or &lt;code&gt;\p{name:value}&lt;/code&gt; (the equals sign and colon can be used interchangeably). These are more general than the single form, and in fact most of the single forms are just Perl-defined shortcuts for common compound forms. For example, the script examples in the previous paragraph could be written equivalently as &lt;code&gt;\p{Script=Latin}&lt;/code&gt; , &lt;code&gt;\p{Script:Greek}&lt;/code&gt; , &lt;code&gt;\p{script=katakana}&lt;/code&gt; , and &lt;code&gt;\P{script=balinese}&lt;/code&gt; (case is irrelevant between the &lt;code&gt;{}&lt;/code&gt; braces). You may never have to use the compound forms, but sometimes it is necessary, and their use can make your code easier to understand.</source>
          <target state="translated">これまでに説明したのは、 &lt;code&gt;\p{...}&lt;/code&gt; 文字クラスの単一の形式です。あなたが遭遇するかもしれない複合形もあります。これらは &lt;code&gt;\p{name=value}&lt;/code&gt; または &lt;code&gt;\p{name:value}&lt;/code&gt; ように見えます（等号とコロンは互換的に使用できます）。これらは単一のフォームよりも一般的であり、実際、ほとんどの単一のフォームは一般的な複合フォームの単なるPerl定義のショートカットです。たとえば、前の段落のスクリプト例は、 &lt;code&gt;\p{Script=Latin}&lt;/code&gt; 、 &lt;code&gt;\p{Script:Greek}&lt;/code&gt; 、 &lt;code&gt;\p{script=katakana}&lt;/code&gt; 、および &lt;code&gt;\P{script=balinese}&lt;/code&gt; として同等に書くことができます（ケースは &lt;code&gt;{}&lt;/code&gt; とは無関係ブレース）。複合フォームを使用する必要がない場合もありますが、必要な場合もあり、それらを使用するとコードが理解しやすくなります。</target>
        </trans-unit>
        <trans-unit id="3384939add5296135f386c16a3d5a3c4d7477676" translate="yes" xml:space="preserve">
          <source>What you are told when someone thinks you should Read The Fine Manual.</source>
          <target state="translated">ファインマニュアルを読んだ方がいいと思われた時に言われること</target>
        </trans-unit>
        <trans-unit id="5da1aaeac7913632bcb1c91e0e40a9b8f5b306d1" translate="yes" xml:space="preserve">
          <source>What you can do is calculate the MD5 checksum of the UTF-8 representation of such strings. This is achieved by filtering the string through encode_utf8() function:</source>
          <target state="translated">このような文字列の UTF-8 表現の MD5 チェックサムを計算することができます。これは encode_utf8()関数で文字列をフィルタリングすることで実現します。</target>
        </trans-unit>
        <trans-unit id="bdac7845b72b0a0aaba866c488e59de83492ce2f" translate="yes" xml:space="preserve">
          <source>What you get from your ancestors, genetically or otherwise. If you happen to be a &lt;b&gt;class&lt;/b&gt;, your ancestors are called &lt;b&gt;base classes&lt;/b&gt; and your descendants are called &lt;b&gt;derived classes&lt;/b&gt;. See &lt;b&gt;single inheritance&lt;/b&gt; and &lt;b&gt;multiple inheritance&lt;/b&gt;.</source>
          <target state="translated">先祖から得たもの、遺伝的またはその他。たまたま&lt;b&gt;クラス&lt;/b&gt;になった場合、祖先は&lt;b&gt;基本クラス&lt;/b&gt;と呼ばれ、子孫は&lt;b&gt;派生クラス&lt;/b&gt;と呼ばれ&lt;b&gt;ます&lt;/b&gt;。&lt;b&gt;単一継承&lt;/b&gt;と&lt;b&gt;多重継承を&lt;/b&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2c06f68d01c975c0659982cd1d1ea555fe3696b9" translate="yes" xml:space="preserve">
          <source>What you get when you do &lt;code&gt;Perl++&lt;/code&gt; twice. Doing it only once will curl your hair. You have to increment it eight times to shampoo your hair. Lather, rinse, iterate.</source>
          <target state="translated">&lt;code&gt;Perl++&lt;/code&gt; 2回実行したときに得られるもの。1回だけ行うと、髪がカールします。髪をシャンプーするには、8回インクリメントする必要があります。泡立てて、すすぎ、繰り返します。</target>
        </trans-unit>
        <trans-unit id="d8dd19339629eae0964d65277b9af39d2d940ac8" translate="yes" xml:space="preserve">
          <source>What you probably want instead is this:</source>
          <target state="translated">代わりに欲しいのはこれでしょう。</target>
        </trans-unit>
        <trans-unit id="b04bf6a0eeeb74b4ebb74c0ffdfd7f57764ab34f" translate="yes" xml:space="preserve">
          <source>What you want to use instead is:</source>
          <target state="translated">代わりに使いたいのは</target>
        </trans-unit>
        <trans-unit id="f3ca9a26fe44a59f17183be2ef23ecb124cf272f" translate="yes" xml:space="preserve">
          <source>What's MakeMaker?</source>
          <target state="translated">MakeMakerとは?</target>
        </trans-unit>
        <trans-unit id="42464d9de4a99557d583081f2fb3c257e19a8cfc" translate="yes" xml:space="preserve">
          <source>What's Really Stored in an SV?</source>
          <target state="translated">SVには何が収納されているのか?</target>
        </trans-unit>
        <trans-unit id="8f84a94f1018dae65b2467147ba94f01d14ea50b" translate="yes" xml:space="preserve">
          <source>What's a closure?</source>
          <target state="translated">クロージングってなんだ?</target>
        </trans-unit>
        <trans-unit id="a80aec1f19639cbbb28c71d9ddfac9f28b371cff" translate="yes" xml:space="preserve">
          <source>What's an extension?</source>
          <target state="translated">延長ってなんだ?</target>
        </trans-unit>
        <trans-unit id="96c69ba1e09918b49d4e34120c9bbb2d0968449e" translate="yes" xml:space="preserve">
          <source>What's in Plan 9 Perl</source>
          <target state="translated">Plan 9 Perl の中身</target>
        </trans-unit>
        <trans-unit id="e9c4131b2629bb86dafeed8bcd2c9f6a25583f3a" translate="yes" xml:space="preserve">
          <source>What's in a name?</source>
          <target state="translated">名前に何があるの?</target>
        </trans-unit>
        <trans-unit id="5131dc0eec6cff59e581098235ddc4625176b69a" translate="yes" xml:space="preserve">
          <source>What's new here?</source>
          <target state="translated">何が新しいの?</target>
        </trans-unit>
        <trans-unit id="22ab29c1c9e23b6be4d152ca0fbe8d1fd5003e73" translate="yes" xml:space="preserve">
          <source>What's not in Plan 9 Perl</source>
          <target state="translated">Plan 9 Perl にないもの</target>
        </trans-unit>
        <trans-unit id="5d2b08ade1fd6cb20cb499440eecabb1a859edc0" translate="yes" xml:space="preserve">
          <source>What's that &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;? Well, the arguments to a subroutine are available to us as a special array called &lt;code&gt;@_&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more on that). The default argument to the &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; function just happens to be &lt;code&gt;@_&lt;/code&gt; . So &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $logmessage = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; shifts the first item off the list of arguments and assigns it to &lt;code&gt;$logmessage&lt;/code&gt; .</source>
          <target state="translated">その &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 何ですか？まあ、サブルーチンの引数と呼ばれる特殊な配列として、私たちに用意されてい &lt;code&gt;@_&lt;/code&gt; （参照&lt;a href=&quot;perlvar&quot;&gt;はperlvar&lt;/a&gt;その上の多くのために）。 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 関数のデフォルトの引数はたまたま &lt;code&gt;@_&lt;/code&gt; です。だから &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; $logmessage = &lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;;&lt;/code&gt; 引数のリストから最初の項目をシフトし、それを &lt;code&gt;$logmessage&lt;/code&gt; 割り当てます。</target>
        </trans-unit>
        <trans-unit id="f547a820f19e246c5a238efacc444f158add7954" translate="yes" xml:space="preserve">
          <source>What's that &lt;code&gt;shift&lt;/code&gt;? Well, the arguments to a subroutine are available to us as a special array called &lt;code&gt;@_&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; for more on that). The default argument to the &lt;code&gt;shift&lt;/code&gt; function just happens to be &lt;code&gt;@_&lt;/code&gt;. So &lt;code&gt;my $logmessage = shift;&lt;/code&gt; shifts the first item off the list of arguments and assigns it to &lt;code&gt;$logmessage&lt;/code&gt;.</source>
          <target state="translated">その &lt;code&gt;shift&lt;/code&gt; 何ですか？まあ、サブルーチンの引数と呼ばれる特殊な配列として、私たちに用意されてい &lt;code&gt;@_&lt;/code&gt; （参照&lt;a href=&quot;perlvar&quot;&gt;はperlvar&lt;/a&gt;その上の多くのために）。 &lt;code&gt;shift&lt;/code&gt; 関数のデフォルトの引数はたまたま &lt;code&gt;@_&lt;/code&gt; です。だから &lt;code&gt;my $logmessage = shift;&lt;/code&gt; 最初の項目を引数のリストからシフトし、それを &lt;code&gt;$logmessage&lt;/code&gt; 割り当てます。</target>
        </trans-unit>
        <trans-unit id="46db4fba6102cb384fdb3af284b14f9799d7a634" translate="yes" xml:space="preserve">
          <source>What's the difference between &quot;delete&quot; and &quot;undef&quot; with hashes?</source>
          <target state="translated">ハッシュを使った「delete」と「undef」の違いは?</target>
        </trans-unit>
        <trans-unit id="efcfc0c915c5ced8aa18fe665d7a6bf921317ac3" translate="yes" xml:space="preserve">
          <source>What's the difference between &quot;perl&quot; and &quot;Perl&quot;?</source>
          <target state="translated">perl」と「Perl」の違いは?</target>
        </trans-unit>
        <trans-unit id="63f076d778aa21d0e84626f4c5e0c5b8d663503c" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;UTF-8&lt;/code&gt; and &lt;code&gt;utf8&lt;/code&gt; ?</source>
          <target state="translated">&lt;code&gt;UTF-8&lt;/code&gt; と &lt;code&gt;utf8&lt;/code&gt; の違いは何ですか？</target>
        </trans-unit>
        <trans-unit id="80de415750b641663470a45e8ab912ba377dfdef" translate="yes" xml:space="preserve">
          <source>What's the difference between &lt;code&gt;UTF-8&lt;/code&gt; and &lt;code&gt;utf8&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;UTF-8&lt;/code&gt; と &lt;code&gt;utf8&lt;/code&gt; の違いは何ですか？</target>
        </trans-unit>
        <trans-unit id="9c1cf1781cda10277aefd4a7483c6c07d76809d8" translate="yes" xml:space="preserve">
          <source>What's the difference between UTF-8 and utf8?</source>
          <target state="translated">UTF-8とutf8の違いは?</target>
        </trans-unit>
        <trans-unit id="1a32eae97c19fcd8cd7ae50ba5b1fb91847cfda9" translate="yes" xml:space="preserve">
          <source>What's the difference between calling a function as &amp;amp;foo and foo()?</source>
          <target state="translated">＆fooとfoo（）として関数を呼び出すことの違いは何ですか？</target>
        </trans-unit>
        <trans-unit id="def2247288e4f5204ba55472b4461e996492e2e7" translate="yes" xml:space="preserve">
          <source>What's the difference between deep and shallow binding?</source>
          <target state="translated">深いバインディングと浅いバインディングの違いは?</target>
        </trans-unit>
        <trans-unit id="95fdb9749f45655e65a25dc015c0a84e8ebabe59" translate="yes" xml:space="preserve">
          <source>What's the difference between dynamic and lexical (static) scoping? Between local() and my()?</source>
          <target state="translated">動的スコーピングと語彙的(静的)スコーピングの違いは何ですか?local()とmy()の違いは?</target>
        </trans-unit>
        <trans-unit id="83bcf34d32fd45bb7e4990d1041e30347690cdee" translate="yes" xml:space="preserve">
          <source>What's the difference between require and use?</source>
          <target state="translated">requireとuseの違いは?</target>
        </trans-unit>
        <trans-unit id="623db2e6cf92d9577f09035416d4d1ab6a554bc6" translate="yes" xml:space="preserve">
          <source>What's the minimum perl version required to run Archive::Tar?</source>
          <target state="translated">Archive::Tar を実行するために必要な perl の最小バージョンは?</target>
        </trans-unit>
        <trans-unit id="6475c25e2b2e180b098b671e2a15d671e687b92e" translate="yes" xml:space="preserve">
          <source>What's this</source>
          <target state="translated">これは何ですか?</target>
        </trans-unit>
        <trans-unit id="65cf3a0e365c639b428e364b59520ed78e55a70c" translate="yes" xml:space="preserve">
          <source>What's wrong the with gettext-using code like this...</source>
          <target state="translated">このようなgettextを使うコードのどこが悪いのか...</target>
        </trans-unit>
        <trans-unit id="e20e3ec3698a540277cd6005030f3f2eae027cdc" translate="yes" xml:space="preserve">
          <source>What's wrong with *-w* and $^W</source>
          <target state="translated">何がいけないのかというと、*-w*と$^w</target>
        </trans-unit>
        <trans-unit id="0d7b30ea762ee4ef5180cde544a82675165a0f09" translate="yes" xml:space="preserve">
          <source>What's wrong with -w and $^W</source>
          <target state="translated">wと$^wの何がいけないのか</target>
        </trans-unit>
        <trans-unit id="d8abb891068053380c8e2c57ccfc03bd7f1c3bec" translate="yes" xml:space="preserve">
          <source>What's wrong with &lt;b&gt;-w&lt;/b&gt; and &lt;code&gt;$^W&lt;/code&gt;</source>
          <target state="translated">&lt;b&gt;-w&lt;/b&gt;と &lt;code&gt;$^W&lt;/code&gt; 何が問題になっていますか</target>
        </trans-unit>
        <trans-unit id="86c8915176784b924b124a7df71bcedbc4d5aeac" translate="yes" xml:space="preserve">
          <source>What's wrong with always quoting &quot;$vars&quot;?</source>
          <target state="translated">いつも「$vars」を引用して何が悪いの?</target>
        </trans-unit>
        <trans-unit id="a6b6f35263a6c409ef4d9ea90bf4d23520808808" translate="yes" xml:space="preserve">
          <source>What's wrong with using backticks in a void context?</source>
          <target state="translated">ボイドコンテキストでバックトークを使って何が悪いんだ?</target>
        </trans-unit>
        <trans-unit id="15b450eb4383c04ae9890e63ad467617d37b687c" translate="yes" xml:space="preserve">
          <source>What's wrong with using grep in a void context?</source>
          <target state="translated">voidコンテキストでgrepを使うことの何がいけないのですか?</target>
        </trans-unit>
        <trans-unit id="48dabfbbabfdd23fd6a91f1e79b5b5393e8fc727" translate="yes" xml:space="preserve">
          <source>What's wrong?</source>
          <target state="translated">どうしたの?</target>
        </trans-unit>
        <trans-unit id="81f7ea2721e1db165495605d1bf1128fca1fe7a9" translate="yes" xml:space="preserve">
          <source>Whatever a reference refers to, which may or may not have a name. Common types of referents include scalars, arrays, hashes, and subroutines.</source>
          <target state="translated">参照が参照するものは何であれ、名前があってもなくても構いません。一般的な参照の型には、スカラ、配列、ハッシュ、サブルーチンなどがあります。</target>
        </trans-unit>
        <trans-unit id="088ce6907b9c85d16edc0ae58b2aca12ddc17aac" translate="yes" xml:space="preserve">
          <source>Whatever happens in the RE engine might be better discussed in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;, but for the sake of continuity, we shall do so here.</source>
          <target state="translated">REエンジンで何が起こっても、&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;でよりよく議論されるかもしれませんが、継続性のために、ここでそれを行うことにします。</target>
        </trans-unit>
        <trans-unit id="1858f2d67aca21222e3d2c00cfe67bcfdc61e6f3" translate="yes" xml:space="preserve">
          <source>Whatever the distribution configured with on the releaser's machine at release time</source>
          <target state="translated">リリース時にリリース元のマシンで設定されたディストリビューションが何であれ</target>
        </trans-unit>
        <trans-unit id="f153d99158c54cb43c1d3fc8596ddbfe423f08fe" translate="yes" xml:space="preserve">
          <source>Whatever you want to do with a reference, &lt;b&gt;Use Rule 1&lt;/b&gt; tells you how to do it. You just write the Perl code that you would have written for doing the same thing to a regular array or hash, and then replace the array or hash name with &lt;code&gt;{$reference}&lt;/code&gt; . &quot;How do I loop over an array when all I have is a reference?&quot; Well, to loop over an array, you would write</source>
          <target state="translated">参照で何をしたい場合でも、&lt;b&gt;ルール1を使用する&lt;/b&gt;と、その方法がわかります。通常の配列またはハッシュに同じことを行うために作成したPerlコードを作成し、配列またはハッシュの名前を &lt;code&gt;{$reference}&lt;/code&gt; 置き換えるだけです。「参照がある場合、配列をループするにはどうすればよいですか？」配列をループするには、次のように書きます。</target>
        </trans-unit>
        <trans-unit id="b5090b0a0f33f56f40ebfa24d96ae2ad1f9f57a8" translate="yes" xml:space="preserve">
          <source>Whatever you want to do with a reference, &lt;b&gt;Use Rule 1&lt;/b&gt; tells you how to do it. You just write the Perl code that you would have written for doing the same thing to a regular array or hash, and then replace the array or hash name with &lt;code&gt;{$reference}&lt;/code&gt;. &quot;How do I loop over an array when all I have is a reference?&quot; Well, to loop over an array, you would write</source>
          <target state="translated">参照で何をしたい場合でも、&lt;b&gt;ルール1を使用&lt;/b&gt;してその方法を説明します。通常の配列またはハッシュに対して同じことを行うために記述したPerlコードを記述し、配列またはハッシュ名を &lt;code&gt;{$reference}&lt;/code&gt; 置き換えるだけです。「参照しかない場合、配列をループするにはどうすればよいですか？」さて、配列をループするには、次のように記述します。</target>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="7ae3880ea71f58f5dbf3834e6e0d70053eb70246" translate="yes" xml:space="preserve">
          <source>When &quot;&lt;code&gt;::&lt;/code&gt; &quot; is not in the name, &quot;&lt;code&gt;Encode::&lt;/code&gt; &quot; is assumed.</source>
          <target state="translated">「 &lt;code&gt;::&lt;/code&gt; 」が名前に含まれていない場合、「 &lt;code&gt;Encode::&lt;/code&gt; 」が想定されます。</target>
        </trans-unit>
        <trans-unit id="8cc9e35707e78514053d0fbc759ccaa1c9412305" translate="yes" xml:space="preserve">
          <source>When &quot;&lt;code&gt;::&lt;/code&gt;&quot; is not in the name, &quot;&lt;code&gt;Encode::&lt;/code&gt;&quot; is assumed.</source>
          <target state="translated">名前に「 &lt;code&gt;::&lt;/code&gt; 」が含まれていない場合は、「 &lt;code&gt;Encode::&lt;/code&gt; 」が想定されます。</target>
        </trans-unit>
        <trans-unit id="a89c66deca9575739eac57be484648de00b11290" translate="yes" xml:space="preserve">
          <source>When $data is present, sets the instance data to $data and returns the object itself. Otherwise, the current instance data is returned.</source>
          <target state="translated">dataが存在する場合は、インスタンスデータを$dataに設定し、オブジェクト自体を返します。それ以外の場合は、現在のインスタンスデータを返します。</target>
        </trans-unit>
        <trans-unit id="5ea5db67e72bdcabd78dcc6373fac87d452cfae7" translate="yes" xml:space="preserve">
          <source>When $encoding is omitted, it defaults to utf8 if $data is already in utf8 or &quot;&quot; (empty string) otherwise.</source>
          <target state="translated">エンコーディングが省略された場合、 $data が既に utf8 である場合は utf8 をデフォルトとします。(空文字列)でなければ</target>
        </trans-unit>
        <trans-unit id="3a255f10977ad0e9fd4eef99c75ca5b6bedb2369" translate="yes" xml:space="preserve">
          <source>When $encoding is present, sets the instance encoding to $encoding and returns the object itself. Otherwise, the current instance encoding is returned.</source>
          <target state="translated">エンコーディングが存在する場合は、インスタンスのエンコーディングを $encoding に設定し、オブジェクト自体を返します。それ以外の場合は、現在のインスタンスのエンコーディングを返します。</target>
        </trans-unit>
        <trans-unit id="c1731c29e738a553728a82585755466ae75d0743" translate="yes" xml:space="preserve">
          <source>When $walker is called, it traverses the subroutines supplied when it was created, and renders them using the current style. You can change the style afterwards in several different ways:</source>
          <target state="translated">walkerが呼ばれると、それが作成されたときに与えられたサブルーチンを通過し、現在のスタイルを使ってレンダリングします。その後、いくつかの方法でスタイルを変更することができます。</target>
        </trans-unit>
        <trans-unit id="34501938bea4725e00e5d23af26af9e9de4937a2" translate="yes" xml:space="preserve">
          <source>When 'make clean' or similar is run, the $(FIRST_MAKEFILE) will be backed up at this location.</source>
          <target state="translated">make clean' などを実行すると、$(FIRST_MAKEFILE)がこの場所にバックアップされます。</target>
        </trans-unit>
        <trans-unit id="0abdf7ca0a208a27b487c4c9ab6758614a97566c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt; had a host option, this host will be used. Without &lt;code&gt;$host&lt;/code&gt; argument, all hosts are scanned.</source>
          <target state="translated">ときに&lt;a href=&quot;#new&quot;&gt;「新しい」&lt;/a&gt;ホストオプションを持っていた、このホストが使用されます。 &lt;code&gt;$host&lt;/code&gt; 引数がないと、すべてのホストがスキャンされます。</target>
        </trans-unit>
        <trans-unit id="84e0d783eb05bd44a60d48045d09e1ab76b77d53" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;'s arguments are executed indirectly by the shell, results and return codes are subject to its quirks. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;&quot;`STRING`&quot; in perlop&lt;/a&gt; and &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;#system-LIST&quot;&gt; &lt;code&gt;system&lt;/code&gt; &lt;/a&gt;の引数がシェルによって間接的に実行される場合、結果と戻りコードはその癖の影響を受けます。詳細について&lt;a href=&quot;perlop#%60STRING%60&quot;&gt;は、perlop&lt;/a&gt;および&lt;a href=&quot;#exec-LIST&quot;&gt; &lt;code&gt;exec&lt;/code&gt; の&lt;/a&gt;「 `STRING`」を参照してください。</target>
        </trans-unit>
        <trans-unit id="89a194e79d9bd84bd7e1d0517e4cb70b910eba34" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt; (but not &lt;code&gt;use locale ':not_characters'&lt;/code&gt;) is in effect, &lt;code&gt;sort LIST&lt;/code&gt; sorts LIST according to the current collation locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">ときに&lt;a href=&quot;locale&quot;&gt; &lt;code&gt;use locale&lt;/code&gt; &lt;/a&gt;（ただし、 &lt;code&gt;use locale ':not_characters'&lt;/code&gt; ）が有効である、 &lt;code&gt;sort LIST&lt;/code&gt; 、現在の照合ロケールに従ってリストをソートします。&lt;a href=&quot;perllocale&quot;&gt;perllocaleを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7c7a9b507455bc0f46d9bdf6728d0f728b33492c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; is set to &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;, when &lt;a href=&quot;#readline-EXPR&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; is in scalar context (i.e., file slurp mode), and when an empty file is read, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; subsequently.</source>
          <target state="translated">ときに&lt;a href=&quot;perlvar#%24%2F&quot;&gt; &lt;code&gt;$/&lt;/code&gt; &lt;/a&gt;に設定されている&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; を&lt;/a&gt;するとき、&lt;a href=&quot;#readline-EXPR&quot;&gt; &lt;code&gt;readline&lt;/code&gt; のは&lt;/a&gt;スカラーコンテキストである（つまり、ファイル吸い込みモード）、および空のファイルが読み込まれたとき、それは返す &lt;code&gt;''&lt;/code&gt; に続いて、最初の時間を&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; を&lt;/a&gt;後に。</target>
        </trans-unit>
        <trans-unit id="9a46234156e6749e9bc38b78f59bb3969925d8bf" translate="yes" xml:space="preserve">
          <source>When &lt;b&gt;--compat-version&lt;/b&gt; (&lt;b&gt;-b&lt;/b&gt;) is present the generated tests will use &lt;code&gt;Test::More&lt;/code&gt; rather than &lt;code&gt;Test&lt;/code&gt; which is the default for versions before 5.6.2. &lt;code&gt;Test::More&lt;/code&gt; will be added to PREREQ_PM in the generated &lt;code&gt;Makefile.PL&lt;/code&gt; .</source>
          <target state="translated">場合&lt;b&gt;--compatバージョン&lt;/b&gt;（&lt;b&gt;-bが&lt;/b&gt;）存在する生成されたテストは、使用する &lt;code&gt;Test::More&lt;/code&gt; ではなく、 &lt;code&gt;Test&lt;/code&gt; 5.6.2以前のバージョンのデフォルトです。 &lt;code&gt;Test::More&lt;/code&gt; は、生成された &lt;code&gt;Makefile.PL&lt;/code&gt; の PREREQ_PMに追加されます。</target>
        </trans-unit>
        <trans-unit id="0c72e13c5aa4ae0a2cebdd6d17deca3e4c332c7a" translate="yes" xml:space="preserve">
          <source>When &lt;b&gt;--compat-version&lt;/b&gt; (&lt;b&gt;-b&lt;/b&gt;) is present the generated tests will use &lt;code&gt;Test::More&lt;/code&gt; rather than &lt;code&gt;Test&lt;/code&gt; which is the default for versions before 5.6.2. &lt;code&gt;Test::More&lt;/code&gt; will be added to PREREQ_PM in the generated &lt;code&gt;Makefile.PL&lt;/code&gt;.</source>
          <target state="translated">場合&lt;b&gt;--compatバージョン&lt;/b&gt;（&lt;b&gt;-bが&lt;/b&gt;）存在する生成されたテストは、使用する &lt;code&gt;Test::More&lt;/code&gt; ではなく、 &lt;code&gt;Test&lt;/code&gt; 5.6.2以前のバージョンのデフォルトです。 &lt;code&gt;Test::More&lt;/code&gt; は、生成された &lt;code&gt;Makefile.PL&lt;/code&gt; のPREREQ_PMに追加されます。</target>
        </trans-unit>
        <trans-unit id="63d44d0dc017c71b0f6cb1ffd43c417d3ee2ebe5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&quot;S&quot;&lt;/code&gt; can match, it is a better match than when only &lt;code&gt;&quot;T&quot;&lt;/code&gt; can match.</source>
          <target state="translated">ときに &lt;code&gt;&quot;S&quot;&lt;/code&gt; 一致させることができ、それはときにのみよりも一致で &lt;code&gt;&quot;T&quot;&lt;/code&gt; 一致させることができます。</target>
        </trans-unit>
        <trans-unit id="98323433c84745d96d2f69c24c5375707e53e818" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, when &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; is in scalar context (i.e., file slurp mode), and when an empty file is read, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; subsequently.</source>
          <target state="translated">ときに &lt;code&gt;$/&lt;/code&gt; に設定されている &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; をするとき、 &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; のはスカラーコンテキストである（つまり、ファイル吸い込みモード）、および空のファイルが読み込まれたとき、それは返す &lt;code&gt;''&lt;/code&gt; に続いて、最初の時間を &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を後に。</target>
        </trans-unit>
        <trans-unit id="d7865066f4690dc076b5908415bb1b4ea7d2066d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$/&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, when &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; is in scalar context (i.e., file slurp mode), and when an empty file is read, it returns &lt;code&gt;''&lt;/code&gt; the first time, followed by &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; subsequently.</source>
          <target state="translated">ときに &lt;code&gt;$/&lt;/code&gt; に設定されている &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; をするとき、 &lt;code&gt;&lt;a href=&quot;readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; のはスカラーコンテキストである（つまり、ファイル吸い込みモード）、および空のファイルが読み込まれたとき、それは返す &lt;code&gt;''&lt;/code&gt; に続いて、最初の時間を &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を後に。</target>
        </trans-unit>
        <trans-unit id="a000e25ad164b5a4e8e6e794f33b40196ef9e9c8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$coderef&lt;/code&gt; is omitted or undefined, any existing callback will be removed and &lt;code&gt;decode&lt;/code&gt; will not change the deserialised hash in any way.</source>
          <target state="translated">とき &lt;code&gt;$coderef&lt;/code&gt; 省略または定義されていない、既存のコールバックが削除され、 &lt;code&gt;decode&lt;/code&gt; どのような方法で直列化復元ハッシュは変更されません。</target>
        </trans-unit>
        <trans-unit id="e5cdec40a0b802970de3c22418f7ef1894e05ac3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$coderef&lt;/code&gt; is specified, it will be called from &lt;code&gt;decode&lt;/code&gt; each time it decodes a JSON object. The only argument is a reference to the newly-created hash. If the code references returns a single scalar (which need not be a reference), this value (or rather a copy of it) is inserted into the deserialised data structure. If it returns an empty list (NOTE:</source>
          <target state="translated">&lt;code&gt;$coderef&lt;/code&gt; が指定されている場合、JSONオブジェクトを &lt;code&gt;decode&lt;/code&gt; たびにdecodeから呼び出されます。唯一の引数は、新しく作成されたハッシュへの参照です。コード参照が単一のスカラー（参照である必要はありません）を返す場合、この値（またはそのコピー）が逆シリアル化されたデータ構造に挿入されます。空のリストが返される場合（注：</target>
        </trans-unit>
        <trans-unit id="75765cbe47d6e2730ecd17d719657c6826993abb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple compressed files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer, after uncompression &lt;code&gt;$output_filename_or_reference&lt;/code&gt; will contain a concatenation of all the uncompressed data from each of the input files/buffers.</source>
          <target state="translated">ときに &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 、複数の圧縮ファイル/バッファにマッピングして、 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 解凍後、単一のファイル/バッファである &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 入力ファイル/バッファのそれぞれからの全ての非圧縮データの連結が含まれています。</target>
        </trans-unit>
        <trans-unit id="ead5ec1ebcf9002ff366c3f4b5ecf105bcef3b1c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer the input files/buffers will be stored in &lt;code&gt;$output_filename_or_reference&lt;/code&gt; as a concatenated series of compressed data streams.</source>
          <target state="translated">とき &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 複数のファイル/バッファにマッピングし、 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 単一のファイルである/入力ファイル/バッファをバッファに格納されます &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 圧縮されたデータの連結一連のストリームとして。</target>
        </trans-unit>
        <trans-unit id="42c11e18ef09b7c84100ba9f7d909d637366a78e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$input_filename_or_reference&lt;/code&gt; maps to multiple files/buffers and &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is a single file/buffer the input files/buffers will each be stored in &lt;code&gt;$output_filename_or_reference&lt;/code&gt; as a distinct entry.</source>
          <target state="translated">とき &lt;code&gt;$input_filename_or_reference&lt;/code&gt; 複数のファイル/バッファにマッピングし、 &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 単一のファイルである/入力ファイルをバッファ/バッファは、それぞれに格納されます &lt;code&gt;$output_filename_or_reference&lt;/code&gt; 個別のエントリとして。</target>
        </trans-unit>
        <trans-unit id="161359b9eacea931dac1aa6e52278dc1eae64067" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is an fileglob string, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; must also be a fileglob string. Anything else is an error.</source>
          <target state="translated">とき &lt;code&gt;$output_filename_or_reference&lt;/code&gt; fileglob文字列で、 &lt;code&gt;$input_filename_or_reference&lt;/code&gt; またfileglob文字列でなければなりません。それ以外はエラーです。</target>
        </trans-unit>
        <trans-unit id="d2909a9438238d7274c21eee7293fc99c88b23e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;${^UNICODE}&lt;/code&gt; (available starting in v5.8.2) exists and is non-zero, these options will be completely ignored. See &lt;a href=&quot;perlvar#%24%7B%5EUNICODE%7D&quot;&gt;&quot;&lt;code&gt;${^UNICODE}&lt;/code&gt;&quot; in perlvar&lt;/a&gt; and &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;&quot;&lt;code&gt;-C&lt;/code&gt;&quot; in perlrun&lt;/a&gt; for details.</source>
          <target state="translated">場合 &lt;code&gt;${^UNICODE}&lt;/code&gt; （v5.8.2で入手可能な出発）が存在し、非ゼロである、これらのオプションは完全に無視されます。詳細について&lt;a href=&quot;perlvar#%24%7B%5EUNICODE%7D&quot;&gt;は、perlvarの&lt;/a&gt;「 &lt;code&gt;${^UNICODE}&lt;/code&gt; 」およびperlrunの&lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;「 &lt;code&gt;-C&lt;/code&gt; 」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2506bf0aaa0a66933521706c1367d6dcef56da1b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;${^UNICODE}&lt;/code&gt; (available starting in v5.8.2) exists and is non-zero, these options will be completely ignored. See &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;${^UNICODE} in perlvar&lt;/a&gt; and &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C in perlrun&lt;/a&gt; for details.</source>
          <target state="translated">場合 &lt;code&gt;${^UNICODE}&lt;/code&gt; （v5.8.2で入手可能な出発）が存在し、非ゼロである、これらのオプションは完全に無視されます。詳細について&lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;は、perlvarの$ {^ UNICODE}&lt;/a&gt;およびperlrunの&lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b7dd1602a2fa020d33fb149e95e48b61aba92e31" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s arguments are executed indirectly by the shell, results and return codes are subject to its quirks. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; and &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; の引数がシェルによって間接的に実行される場合、結果と戻りコードはその癖に左右されます。詳細について&lt;a href=&quot;perlop#%60STRING%60&quot;&gt;は、perlop&lt;/a&gt;および&lt;a href=&quot;#exec&quot;&gt;execの&lt;/a&gt;「STRING」を参照してください。</target>
        </trans-unit>
        <trans-unit id="ce37de4fd1569bb63f53c7c4c16cdb716157400b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (but not &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; sorts LIST according to the current collation locale. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">ときに &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; （ただし、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ）有効である、 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; 現在の照合ロケールに従ってリストをソートします。&lt;a href=&quot;perllocale&quot;&gt;perllocaleを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c4b89dec84fb05fc282a0e80acf7739b8c5833a7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/flags'&lt;/code&gt; is specified, the given flags are automatically added to every regular expression till the end of the lexical scope.</source>
          <target state="translated">ときに &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re '/flags'&lt;/code&gt; 指定され、指定したフラグは自動的にレキシカルスコープの終わりまで、すべての正規表現に追加されます。</target>
        </trans-unit>
        <trans-unit id="826f4d022e4908a4bde930341263c135e67935f4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; is in effect, perl emits debugging messages when compiling and using regular expressions. The output is the same as that obtained by running a &lt;code&gt;-DDEBUGGING&lt;/code&gt; -enabled perl interpreter with the &lt;b&gt;-Dr&lt;/b&gt; switch. It may be quite voluminous depending on the complexity of the match. Using &lt;code&gt;debugcolor&lt;/code&gt; instead of &lt;code&gt;debug&lt;/code&gt; enables a form of output that can be used to get a colorful display on terminals that understand termcap color sequences. Set &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; to a comma-separated list of &lt;code&gt;termcap&lt;/code&gt; properties to use for highlighting strings on/off, pre-point part on/off. See &lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;Debugging Regular Expressions in perldebug&lt;/a&gt; for additional info.</source>
          <target state="translated">ときに &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; 有効である正規表現をコンパイルして使用した場合、perlの発するメッセージをデバッグします。出力は、&lt;b&gt;-Dr&lt;/b&gt;スイッチを指定して &lt;code&gt;-DDEBUGGING&lt;/code&gt; が有効な perlインタープリターを実行した場合と同じです。試合の複雑さによってはかなり膨大になる場合があります。使用 &lt;code&gt;debugcolor&lt;/code&gt; をするのではなく &lt;code&gt;debug&lt;/code&gt; はtermcapカラーシーケンスを理解端末上で色鮮やかな表示を取得するために使用することができ、出力の形式を可能にします。セット &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; のカンマ区切りリストへ &lt;code&gt;termcap&lt;/code&gt; オン/オフ文字列を強調表示するために使用するプロパティ、事前点部のオン/オフ。&lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;perldebugでの正規表現のデバッグを&lt;/a&gt;参照してください。&lt;b&gt;&lt;/b&gt; 追加情報については。</target>
        </trans-unit>
        <trans-unit id="6c428ad9961e409888285c5019a1884325617653" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; is in effect, a regexp is allowed to contain &lt;code&gt;(?{ ... })&lt;/code&gt; zero-width assertions and &lt;code&gt;(??{ ... })&lt;/code&gt; postponed subexpressions that are derived from variable interpolation, rather than appearing literally within the regexp. That is normally disallowed, since it is a potential security risk. Note that this pragma is ignored when the regular expression is obtained from tainted data, i.e. evaluation is always disallowed with tainted regular expressions. See &lt;a href=&quot;perlre#(%3f%7b-code-%7d)&quot;&gt;(?{ code }) in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#(%3f%3f%7b-code-%7d)&quot;&gt;(??{ code }) in perlre&lt;/a&gt;.</source>
          <target state="translated">ときに &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'eval'&lt;/code&gt; 効果で、正規表現を含むことが許容される &lt;code&gt;(?{ ... })&lt;/code&gt; ゼロ幅アサーションおよび &lt;code&gt;(??{ ... })&lt;/code&gt; 延期変数補間から誘導される部分式ではなく、が現れます文字通り正規表現の範囲内。これは潜在的なセキュリティリスクであるため、通常は許可されません。汚染されたデータから正規表現が取得される場合、このプラグマは無視されることに注意してください。つまり、汚染された正規表現では評価は常に許可されません。参照&lt;a href=&quot;perlre#(%3f%7b-code-%7d)&quot;&gt;はperlreで（？{コード}）&lt;/a&gt;と&lt;a href=&quot;perlre#(%3f%3f%7b-code-%7d)&quot;&gt;はperlreに（?? {コード}） &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c489bf5f6075f7a85a4147bc159e1965fa8ad2cd" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'strict'&lt;/code&gt; is in effect, stricter checks are applied than otherwise when compiling regular expressions patterns. These may cause more warnings to be raised than otherwise, and more things to be fatal instead of just warnings. The purpose of this is to find and report at compile time some things, which may be legal, but have a reasonable possibility of not being the programmer's actual intent. This automatically turns on the &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; warnings category (if not already on) within its scope.</source>
          <target state="translated">ときに &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'strict'&lt;/code&gt; 有効な正規表現パターンをコンパイルするとき、より厳しいチェックがそうでなければより適用されます。これらにより、他の警告よりも多くの警告が発生し、警告だけでなく致命的な事態が発生する可能性があります。これの目的は、コンパイル時にいくつかのことを見つけて報告することです。これは合法であるかもしれませんが、プログラマーの実際の意図ではない合理的な可能性があります。これにより、スコープ内の &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; 警告カテゴリ（まだオンになっていない場合）が自動的にオンになります。</target>
        </trans-unit>
        <trans-unit id="057f6216fa3faf81b159095b26d348ad7b06bd25" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'taint'&lt;/code&gt; is in effect, and a tainted string is the target of a regexp, the regexp memories (or values returned by the m// operator in list context) are tainted. This feature is useful when regexp operations on tainted data aren't meant to extract safe substrings, but to perform other transformations.</source>
          <target state="translated">ときに &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'taint'&lt;/code&gt; 有効であり、汚染された文字列が正規表現の対象である、正規表現のメモリ（または値はリストコンテキストにおけるm //オペレータによって返さ）汚染されています。この機能は、汚染されたデータに対する正規表現操作が安全な部分文字列を抽出するためではなく、他の変換を実行するために役立つ場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="d35b2d737154679691874d190272f87d34f67d6b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s arguments are executed indirectly by the shell, results and return codes are subject to its quirks. See &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; and &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; の引数がシェルによって間接的に実行される場合、結果と戻りコードはその癖に左右されます。詳細について&lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;は、perlop&lt;/a&gt;および&lt;a href=&quot;exec&quot;&gt;execの&lt;/a&gt;「STRING」を参照してください。</target>
        </trans-unit>
        <trans-unit id="d249161b8d76a85447f9bcf8c19ecaa9c4041708" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; (but not &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ) is in effect, &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; sorts LIST according to the current collation locale. See &lt;a href=&quot;../perllocale&quot;&gt;perllocale&lt;/a&gt;.</source>
          <target state="translated">ときに &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; （ただし、 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale 'not_characters'&lt;/code&gt; ）有効である、 &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt; LIST&lt;/code&gt; 現在の照合ロケールに従ってリストをソートします。&lt;a href=&quot;../perllocale&quot;&gt;perllocaleを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9cb0ac41f5c76b7790f54d079dd94b8ce0665510" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Append&lt;/code&gt; is specified, and set to true, it will</source>
          <target state="translated">場合は &lt;code&gt;Append&lt;/code&gt; 指定し、trueに設定されている、それは意志</target>
        </trans-unit>
        <trans-unit id="74620e73df76b9793a4b5915498c084620ae1197" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutout&lt;/code&gt; is not specified &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; will use as much memory as it takes to write all the uncompressed data it creates by uncompressing the input buffer.</source>
          <target state="translated">&lt;code&gt;LimitOutout&lt;/code&gt; が指定されていない場合、 &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; は、入力バッファーを解凍して作成したすべての非圧縮データを書き込むのに必要なだけのメモリを使用します。</target>
        </trans-unit>
        <trans-unit id="476db1003af9ea2b2d5dff0b4d9aae2335796a1b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutout&lt;/code&gt; is not specified &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; will use as much memory as it takes to write all the uncompressed data it creates by uncompressing the input buffer.</source>
          <target state="translated">&lt;code&gt;LimitOutout&lt;/code&gt; が指定されていない場合、 &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; は、入力バッファーを解凍して作成したすべての非圧縮データを書き込むのに必要なだけのメモリを使用します。</target>
        </trans-unit>
        <trans-unit id="3a29eb1b7605b447e178aa583e1e3d0b18b3e32a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the 16k or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt; , whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="translated">&lt;code&gt;LimitOutput&lt;/code&gt; が使用される場合、使用される出力バッファのサイズは、16kまたは &lt;code&gt;$output&lt;/code&gt; すでに割り当てられているメモリの量のいずれか大きい方になります。利用可能な出力サイズの予測は難しいので、正確な出力バッファーサイズを取得することに依存しないでください。</target>
        </trans-unit>
        <trans-unit id="378bab7c46fb87434a4a31e87bab949c33fee48d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the 16k or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt;, whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="translated">&lt;code&gt;LimitOutput&lt;/code&gt; が使用される場合、使用される出力バッファのサイズは、16kまたは &lt;code&gt;$output&lt;/code&gt; すでに割り当てられているメモリの量のいずれか大きい方になります。使用可能な出力サイズを予測するのは難しいため、正確な出力バッファサイズの取得に依存しないでください。</target>
        </trans-unit>
        <trans-unit id="6884e67243b247f9f83c1056f56446e2954b8717" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the value of the &lt;code&gt;Bufsize&lt;/code&gt; option or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt; , whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="translated">&lt;code&gt;LimitOutput&lt;/code&gt; が使用される場合、使用される出力バッファーのサイズは、 &lt;code&gt;Bufsize&lt;/code&gt; オプションの値か、 &lt;code&gt;$output&lt;/code&gt; 既に割り当てられているメモリーの量のいずれか大きい方になります。利用可能な出力サイズの予測は難しいので、正確な出力バッファーサイズを取得することに依存しないでください。</target>
        </trans-unit>
        <trans-unit id="e109cef898586b284816d1d609f442757d09d9a8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;LimitOutput&lt;/code&gt; is used the size of the output buffer used will either be the value of the &lt;code&gt;Bufsize&lt;/code&gt; option or the amount of memory already allocated to &lt;code&gt;$output&lt;/code&gt;, whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.</source>
          <target state="translated">&lt;code&gt;LimitOutput&lt;/code&gt; が使用される場合、使用される出力バッファーのサイズは、 &lt;code&gt;Bufsize&lt;/code&gt; オプションの値、または &lt;code&gt;$output&lt;/code&gt; 既に割り当てられているメモリーの量のいずれか大きい方になります。使用可能な出力サイズを予測するのは難しいため、正確な出力バッファサイズの取得に依存しないでください。</target>
        </trans-unit>
        <trans-unit id="bd3a312e83feddf95b646900a17ece38db487898" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; is active (see &lt;a href=&quot;#%24%3F&quot;&gt;&quot;$?&quot;&lt;/a&gt; below), the native VMS exit status value will have either one of the &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$^E&lt;/code&gt; or the Unix value 255 encoded into it in a way that the effective original value can be decoded by other programs written in C, including Perl and the GNV package. As per the normal non-VMS behavior of &lt;code&gt;die&lt;/code&gt; if either &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; are non-zero, one of those values will be encoded into a native VMS status value. If both of the Unix status values are 0, and the &lt;code&gt;$^E&lt;/code&gt; value is set one of ERROR or SEVERE_ERROR severity, then the &lt;code&gt;$^E&lt;/code&gt; value will be used as the exit code as is. If none of the above apply, the Unix value of 255 will be encoded into a native VMS exit status value.</source>
          <target state="translated">&lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; がアクティブな場合（以下の&lt;a href=&quot;#%24%3F&quot;&gt;「$？」を&lt;/a&gt;参照）、ネイティブVMSの終了ステータス値には &lt;code&gt;$!&lt;/code&gt; のいずれかが含まれます。または &lt;code&gt;$?&lt;/code&gt; または、PerlやGNVパッケージなど、Cで記述された他のプログラムで有効な元の値をデコードできるように、 &lt;code&gt;$^E&lt;/code&gt; またはそれにエンコードされたUnix値255。 &lt;code&gt;$!&lt;/code&gt; 場合、 &lt;code&gt;die&lt;/code&gt; の通常の非VMS動作に従って！または &lt;code&gt;$?&lt;/code&gt; がゼロ以外の場合、これらの値の1つがネイティブVMSステータス値にエンコードされます。 Unixステータス値が両方とも0で、 &lt;code&gt;$^E&lt;/code&gt; 値がERRORまたはSEVERE_ERROR重大度のいずれかに設定されている場合、 &lt;code&gt;$^E&lt;/code&gt; 値はそのまま終了コードとして使用されます。上記のいずれにも当てはまらない場合、Unix値255はネイティブVMS終了ステータス値にエンコードされます。</target>
        </trans-unit>
        <trans-unit id="f6c4b51758778b88a3620755cd86e2bac9c6c0e5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; is active (see &lt;a href=&quot;#%24%3f&quot;&gt;$?&lt;/a&gt; below), the native VMS exit status value will have either one of the &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; or &lt;code&gt;$^E&lt;/code&gt; or the Unix value 255 encoded into it in a way that the effective original value can be decoded by other programs written in C, including Perl and the GNV package. As per the normal non-VMS behavior of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; if either &lt;code&gt;$!&lt;/code&gt; or &lt;code&gt;$?&lt;/code&gt; are non-zero, one of those values will be encoded into a native VMS status value. If both of the Unix status values are 0, and the &lt;code&gt;$^E&lt;/code&gt; value is set one of ERROR or SEVERE_ERROR severity, then the &lt;code&gt;$^E&lt;/code&gt; value will be used as the exit code as is. If none of the above apply, the Unix value of 255 will be encoded into a native VMS exit status value.</source>
          <target state="translated">&lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; がアクティブな場合（以下の&lt;a href=&quot;#%24%3f&quot;&gt;$？を&lt;/a&gt;参照）、ネイティブVMS終了ステータス値は &lt;code&gt;$!&lt;/code&gt; または &lt;code&gt;$?&lt;/code&gt; または &lt;code&gt;$^E&lt;/code&gt; またはUnix値255をエンコードして、PerlやGNVパッケージなど、Cで記述された他のプログラムで有効な元の値をデコードできるようにします。いずれかの &lt;code&gt;$!&lt;/code&gt; 場合、 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; の通常の非VMS動作に従って！または &lt;code&gt;$?&lt;/code&gt; ゼロ以外の場合、これらの値の1つがネイティブVMSステータス値にエンコードされます。 Unixステータス値が両方とも0で、 &lt;code&gt;$^E&lt;/code&gt; 値がERRORまたはSEVERE_ERROR重大度のいずれかに設定されている場合、 &lt;code&gt;$^E&lt;/code&gt; 値はそのまま終了コードとして使用されます。上記のいずれにも該当しない場合、Unix値の255はネイティブVMS終了ステータス値にエンコードされます。</target>
        </trans-unit>
        <trans-unit id="edf0ae2377a2b22abb92a09c7cbee6dad38f469d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;S&lt;/code&gt; can match, it is a better match than when only &lt;code&gt;T&lt;/code&gt; can match.</source>
          <target state="translated">とき &lt;code&gt;S&lt;/code&gt; を一致させることができ、それはときにのみよりも一致で &lt;code&gt;T&lt;/code&gt; は一致させることができます。</target>
        </trans-unit>
        <trans-unit id="5e7bb6aa4bca28bb16c16381fd1ea0fe317f098c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Strict&lt;/code&gt; is disabled the following behaviour will be policed:</source>
          <target state="translated">とき &lt;code&gt;Strict&lt;/code&gt; 無効になり、次の動作がポリシングされます。</target>
        </trans-unit>
        <trans-unit id="db687c97fb2b33423a8768bd320e4711c5ad7257" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Time::Local&lt;/code&gt; was first written, it was a common practice to represent years as a two-digit value like &lt;code&gt;99&lt;/code&gt; for &lt;code&gt;1999&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;2001&lt;/code&gt;. This caused all sorts of problems (google &quot;Y2K problem&quot; if you're very young) and developers eventually realized that this was a terrible idea.</source>
          <target state="translated">ときに &lt;code&gt;Time::Local&lt;/code&gt; 最初に書かれた、のように2桁の値として年を表すのが一般的だった &lt;code&gt;99&lt;/code&gt; のための &lt;code&gt;1999&lt;/code&gt; または &lt;code&gt;1&lt;/code&gt; のために &lt;code&gt;2001&lt;/code&gt; 。これはあらゆる種類の問題を引き起こし（あなたが非常に若い場合はグーグルの「Y2K問題」）、開発者は最終的にこれがひどい考えであることに気づきました。</target>
        </trans-unit>
        <trans-unit id="792e600779793d69f3a4dfa3dfa3dd30d40ce8a4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt;= 22, the weights of out-of-range values can be overridden. Though &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; are available for them, out-of-range values are too many.</source>
          <target state="translated">場合 &lt;code&gt;UCA_Version&lt;/code&gt; 値を上書きすることができる範囲外の&amp;gt; = 22、重み。けれども &lt;code&gt;table&lt;/code&gt; または &lt;code&gt;entry&lt;/code&gt; 彼らのために利用可能な、範囲外の値があまりにも多くあります。</target>
        </trans-unit>
        <trans-unit id="a8376390a3e85be3e6ac52a52161522985c10ab7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;allow_bignum&lt;/code&gt; is enabled, big integer values and any numeric values will be converted into &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; and &lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt; objects respectively, without becoming string scalars or losing precision.</source>
          <target state="translated">とき &lt;code&gt;allow_bignum&lt;/code&gt; が有効になっている、大きな整数値と任意の数値は変換されます&lt;a href=&quot;Math::BigInt&quot;&gt;数学:: BigIntの&lt;/a&gt;と&lt;a href=&quot;Math::BigFloat&quot;&gt;数学を::ビッグフロートは&lt;/a&gt;、文字列スカラーになることや精度を失うことなく、それぞれのオブジェクト。</target>
        </trans-unit>
        <trans-unit id="a88bdc0c0c759d08c6275afc07854842d8f95efa" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;base&lt;/code&gt; tries to &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; a module, it will not die if it cannot find the module's file, but will die on any other error. After all this, should your base class be empty, containing no symbols, &lt;code&gt;base&lt;/code&gt; will die. This is useful for inheriting from classes in the same file as yourself but where the filename does not match the base module name, like so:</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; がモジュールを &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; しようとしたときに、モジュールのファイルが見つからない場合は停止しませんが、その他のエラーが発生すると停止します。結局のところ、基本クラスが空で、シンボルが含まれていない場合、 &lt;code&gt;base&lt;/code&gt; は停止します。これは、自分と同じファイル内のクラスから継承する場合に便利ですが、次のように、ファイル名がベースモジュール名と一致しません。</target>
        </trans-unit>
        <trans-unit id="7e10e7af3fdfd7341808494145f96d758dfe5848" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;base&lt;/code&gt; tries to &lt;code&gt;require&lt;/code&gt; a module, it will not die if it cannot find the module's file, but will die on any other error. After all this, should your base class be empty, containing no symbols, &lt;code&gt;base&lt;/code&gt; will die. This is useful for inheriting from classes in the same file as yourself but where the filename does not match the base module name, like so:</source>
          <target state="translated">ときに &lt;code&gt;base&lt;/code&gt; しようとする &lt;code&gt;require&lt;/code&gt; モジュールを、それがモジュールのファイルを見つけることができない場合は死ぬことはないが、他のエラーで死んでしまいます。結局、基本クラスが空で、シンボルが含まれていない場合、 &lt;code&gt;base&lt;/code&gt; は死にます。これは、自分と同じファイル内のクラスから継承する場合に役立ちますが、ファイル名がベースモジュール名と一致しない場合は次のようになります。</target>
        </trans-unit>
        <trans-unit id="1801ac03d31183f16ba294ce4fa7c937f1f41d11" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;dynamic_config&lt;/code&gt; is true, it is an error to presume that the prerequisites given in distribution metadata will have any relationship whatsoever to the actual prerequisites of the distribution.</source>
          <target state="translated">とき &lt;code&gt;dynamic_config&lt;/code&gt; が真である、それは流通メタデータで与えられた前提条件が分布の実際の前提条件に一切の関係を持っていることを前提とするとエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="f3f15dbf4bfac8ce422e1183a7c97c2a550a0582" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; are in effect, there is also a &lt;code&gt;$File::Find::fullname&lt;/code&gt; . The function may set &lt;code&gt;$File::Find::prune&lt;/code&gt; to prune the tree unless &lt;code&gt;bydepth&lt;/code&gt; was specified. Unless &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; is specified, for compatibility reasons (find.pl, find2perl) there are in addition the following globals available: &lt;code&gt;$File::Find::topdir&lt;/code&gt; , &lt;code&gt;$File::Find::topdev&lt;/code&gt; , &lt;code&gt;$File::Find::topino&lt;/code&gt; , &lt;code&gt;$File::Find::topmode&lt;/code&gt; and &lt;code&gt;$File::Find::topnlink&lt;/code&gt; .</source>
          <target state="translated">とき &lt;code&gt;follow&lt;/code&gt; や &lt;code&gt;follow_fast&lt;/code&gt; が有効になっている、また、そこにある &lt;code&gt;$File::Find::fullname&lt;/code&gt; 。関数は、 &lt;code&gt;bydepth&lt;/code&gt; が指定されていない限り、ツリーを整理するために &lt;code&gt;$File::Find::prune&lt;/code&gt; を設定できます。 &lt;code&gt;follow&lt;/code&gt; または &lt;code&gt;follow_fast&lt;/code&gt; が指定されていない限り、互換性の理由（find.pl、find2perl）に加えて、次のグローバルも使用できます： &lt;code&gt;$File::Find::topdir&lt;/code&gt; 、 &lt;code&gt;$File::Find::topdev&lt;/code&gt; 、 &lt;code&gt;$File::Find::topino&lt;/code&gt; 、 &lt;code&gt;$File::Find::topmode&lt;/code&gt; および &lt;code&gt;$File::Find::topnlink&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e21f0f2ae6a786fecac14190bdb286ef45b2801" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; are in effect, there is also a &lt;code&gt;$File::Find::fullname&lt;/code&gt;. The function may set &lt;code&gt;$File::Find::prune&lt;/code&gt; to prune the tree unless &lt;code&gt;bydepth&lt;/code&gt; was specified. Unless &lt;code&gt;follow&lt;/code&gt; or &lt;code&gt;follow_fast&lt;/code&gt; is specified, for compatibility reasons (find.pl, find2perl) there are in addition the following globals available: &lt;code&gt;$File::Find::topdir&lt;/code&gt;, &lt;code&gt;$File::Find::topdev&lt;/code&gt;, &lt;code&gt;$File::Find::topino&lt;/code&gt;, &lt;code&gt;$File::Find::topmode&lt;/code&gt; and &lt;code&gt;$File::Find::topnlink&lt;/code&gt;.</source>
          <target state="translated">とき &lt;code&gt;follow&lt;/code&gt; や &lt;code&gt;follow_fast&lt;/code&gt; が有効になっている、また、そこにある &lt;code&gt;$File::Find::fullname&lt;/code&gt; 。この関数は、 &lt;code&gt;bydepth&lt;/code&gt; が指定されていない限り、 &lt;code&gt;$File::Find::prune&lt;/code&gt; を設定してツリーをプルーニングできます。 &lt;code&gt;follow&lt;/code&gt; または &lt;code&gt;follow_fast&lt;/code&gt; が指定されていない限り、互換性の理由（find.pl、find2perl）により、さらに次のグローバルが使用可能です： &lt;code&gt;$File::Find::topdir&lt;/code&gt; 、 &lt;code&gt;$File::Find::topdev&lt;/code&gt; 、 &lt;code&gt;$File::Find::topino&lt;/code&gt; 、 &lt;code&gt;$File::Find::topmode&lt;/code&gt; および &lt;code&gt;$File::Find::topnlink&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c3af0ccfdbd0226b2c1c6a386ea7d1149b898de" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;get_handle&lt;/code&gt; is called with an empty parameter list, magic happens:</source>
          <target state="translated">とき &lt;code&gt;get_handle&lt;/code&gt; は空のパラメータリストで呼ばれ、魔法が起こります。</target>
        </trans-unit>
        <trans-unit id="0587cd71d3cd406da1e34d9f0121a501c139389a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;remove_tree&lt;/code&gt; returned from deleting files in a child directory, a check revealed that the parent directory it returned to wasn't the one it started out from. This is considered a sign of malicious activity.</source>
          <target state="translated">子ディレクトリ内のファイルの削除から &lt;code&gt;remove_tree&lt;/code&gt; が返されたとき、チェックの結果、返された親ディレクトリが元のディレクトリではないことが判明しました。これは悪意のある活動の兆候と見なされます。</target>
        </trans-unit>
        <trans-unit id="0abaa039dcd0b20cc37827ce7e9a425281864469" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;share&lt;/code&gt; is used on arrays, hashes, array refs or hash refs, any data they contain will be lost.</source>
          <target state="translated">ときは &lt;code&gt;share&lt;/code&gt; 配列、ハッシュ、配列リファレンスやハッシュ、参考文献に使用され、そこに含まれるすべてのデータが失われます。</target>
        </trans-unit>
        <trans-unit id="f072734b6ff55766546071395774e151a8cea193" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;test_test&lt;/code&gt; is called and the output that your tests generate does not match that which you declared, &lt;code&gt;test_test&lt;/code&gt; will print out debug information showing the two conflicting versions. As this output itself is debug information it can be confusing which part of the output is from &lt;code&gt;test_test&lt;/code&gt; and which was the original output from your original tests. Also, it may be hard to spot things like extraneous whitespace at the end of lines that may cause your test to fail even though the output looks similar.</source>
          <target state="translated">とき &lt;code&gt;test_test&lt;/code&gt; が呼び出され、あなたのテストが生成する出力は、あなたが宣言されていることと一致しない、 &lt;code&gt;test_test&lt;/code&gt; は、 2つの競合するバージョンを示すデバッグ情報を出力します。この出力自体はデバッグ情報であるため、出力のどの部分が &lt;code&gt;test_test&lt;/code&gt; からのものであり、どの部分が元のテストからの元の出力であったかがわかりにくい場合があります。また、出力が似ていてもテストが失敗する原因となる、行末の無関係な空白などを見つけるのは難しい場合があります。</target>
        </trans-unit>
        <trans-unit id="100cf02e094db7d3754b0f2bd62e72f796e0a652" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re '/&lt;i&gt;flags&lt;/i&gt;'&lt;/code&gt; is specified, the given</source>
          <target state="translated">ときに &lt;code&gt;use re '/&lt;i&gt;flags&lt;/i&gt;'&lt;/code&gt; 指定され、与えられました</target>
        </trans-unit>
        <trans-unit id="2e437612ab773128746c34ed5e2418f0d2432e87" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'debug'&lt;/code&gt; is in effect, perl emits debugging messages when compiling and using regular expressions. The output is the same as that obtained by running a &lt;code&gt;-DDEBUGGING&lt;/code&gt;-enabled perl interpreter with the &lt;b&gt;-Dr&lt;/b&gt; switch. It may be quite voluminous depending on the complexity of the match. Using &lt;code&gt;debugcolor&lt;/code&gt; instead of &lt;code&gt;debug&lt;/code&gt; enables a form of output that can be used to get a colorful display on terminals that understand termcap color sequences. Set &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; to a comma-separated list of &lt;code&gt;termcap&lt;/code&gt; properties to use for highlighting strings on/off, pre-point part on/off. See &lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;&quot;Debugging Regular Expressions&quot; in perldebug&lt;/a&gt; for additional info.</source>
          <target state="translated">ときに &lt;code&gt;use re 'debug'&lt;/code&gt; 有効になっている正規表現をコンパイルして使用した場合、perlの発するメッセージをデバッグします。出力は、&lt;b&gt;-Dr&lt;/b&gt;スイッチを指定して &lt;code&gt;-DDEBUGGING&lt;/code&gt; 対応のperlインタープリターを実行した場合と同じです。試合の複雑さによっては、かなりの量になる場合があります。使用 &lt;code&gt;debugcolor&lt;/code&gt; をするのではなく &lt;code&gt;debug&lt;/code&gt; はtermcapカラーシーケンスを理解端末上で色鮮やかな表示を取得するために使用することができ、出力の形式を可能にします。セット &lt;code&gt;$ENV{PERL_RE_TC}&lt;/code&gt; のカンマ区切りリストへ &lt;code&gt;termcap&lt;/code&gt; オン/オフ文字列を強調表示するために使用するプロパティ、事前点部のオン/オフ。&lt;a href=&quot;perldebug#Debugging-Regular-Expressions&quot;&gt;perldebugの「正規表現のデバッグ」を&lt;/a&gt;参照してください。&lt;b&gt;&lt;/b&gt; 追加情報については。</target>
        </trans-unit>
        <trans-unit id="ffdd2a4a70c97e6482142a6afb44a0c24ab7f2c4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'eval'&lt;/code&gt; is in effect, a regexp is allowed to contain &lt;code&gt;(?{ ... })&lt;/code&gt; zero-width assertions and &lt;code&gt;(??{ ... })&lt;/code&gt; postponed subexpressions that are derived from variable interpolation, rather than appearing literally within the regexp. That is normally disallowed, since it is a potential security risk. Note that this pragma is ignored when the regular expression is obtained from tainted data, i.e. evaluation is always disallowed with tainted regular expressions. See &lt;a href=&quot;perlre#%28%3F%7B-code-%7D%29&quot;&gt;&quot;(?{ code })&quot; in perlre&lt;/a&gt; and &lt;a href=&quot;perlre#%28%3F%3F%7B-code-%7D%29&quot;&gt;&quot;(??{ code })&quot; in perlre&lt;/a&gt;.</source>
          <target state="translated">ときに &lt;code&gt;use re 'eval'&lt;/code&gt; 有効である、正規表現を含むことが許可されている &lt;code&gt;(?{ ... })&lt;/code&gt; ゼロ幅アサーションおよび &lt;code&gt;(??{ ... })&lt;/code&gt; というよりも現れる変数補間から誘導される部分式を延期しました文字通り正規表現内。これは潜在的なセキュリティリスクであるため、通常は許可されていません。正規表現が汚染されたデータから取得される場合、このプラグマは無視されることに注意してください。つまり、汚染された正規表現では評価が常に許可されません。参照&lt;a href=&quot;perlre#%28%3F%7B-code-%7D%29&quot;&gt;&quot;（？{コード}）&quot;はperlre内&lt;/a&gt;と&lt;a href=&quot;perlre#%28%3F%3F%7B-code-%7D%29&quot;&gt;はperlreで&quot;（?? {コード}）&quot;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18d8ac1a2fdcf9c532880e4f21577de40d0e705a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'strict'&lt;/code&gt; is in effect, stricter checks are applied than otherwise when compiling regular expressions patterns. These may cause more warnings to be raised than otherwise, and more things to be fatal instead of just warnings. The purpose of this is to find and report at compile time some things, which may be legal, but have a reasonable possibility of not being the programmer's actual intent. This automatically turns on the &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; warnings category (if not already on) within its scope.</source>
          <target state="translated">ときに &lt;code&gt;use re 'strict'&lt;/code&gt; 有効な正規表現パターンをコンパイルするとき、より厳しいチェックがそうでなければより適用されます。これらにより、他の場合よりも多くの警告が発生し、単なる警告ではなく、より多くの致命的なことが発生する可能性があります。これの目的は、コンパイル時にいくつかのことを見つけて報告することです。これは合法かもしれませんが、プログラマーの実際の意図ではない可能性があります。これにより、スコープ内の &lt;code&gt;&quot;regexp&quot;&lt;/code&gt; 警告カテゴリが自動的にオンになります（まだオンになっていない場合）。</target>
        </trans-unit>
        <trans-unit id="92d597df9736b57e5c279970bfb89c7002422580" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;use re 'taint'&lt;/code&gt; is in effect, and a tainted string is the target of a regexp, the regexp memories (or values returned by the m// operator in list context) are tainted. This feature is useful when regexp operations on tainted data aren't meant to extract safe substrings, but to perform other transformations.</source>
          <target state="translated">ときに &lt;code&gt;use re 'taint'&lt;/code&gt; 有効であり、汚染された文字列が正規表現の対象である、正規表現のメモリ（または値はリストコンテキストにおけるm //オペレータによって返さ）汚染されています。この機能は、汚染されたデータに対するregexp操作が安全な部分文字列を抽出することを目的としておらず、他の変換を実行することを目的としている場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="ea81caddf6f1e1e3901216d09988417e561f49ac" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;utf8&lt;/code&gt; is disabled (the default), then &lt;code&gt;encode&lt;/code&gt;/&lt;code&gt;decode&lt;/code&gt; generate and expect Unicode strings, that is, characters with high ordinal Unicode values (&amp;gt; 255) will be encoded as such characters, and likewise such characters are decoded as-is, no changes to them will be done, except &quot;(re-)interpreting&quot; them as Unicode codepoints or Unicode characters, respectively (to Perl, these are the same thing in strings unless you do funny/weird/dumb stuff).</source>
          <target state="translated">場合 &lt;code&gt;utf8&lt;/code&gt; （デフォルト）無効化され、その後、 &lt;code&gt;encode&lt;/code&gt; / &lt;code&gt;decode&lt;/code&gt; Unicode文字列を生成すると予想される、高い順序Unicode値（&amp;gt; 255）を持つ文字はない、そのような文字としてエンコードされ、同様に、そのような文字をそのまま復号される、ですそれらへの変更は、それぞれUnicodeコードポイントまたはUnicode文字として「（再）解釈」することを除いて行われます（Perlにとって、これらは、面白い/奇妙な/ばかげたものを行わない限り、文字列でも同じです）。</target>
        </trans-unit>
        <trans-unit id="0a8ac650ec538c50bdeb4cf6dbd53747bc753f1f" translate="yes" xml:space="preserve">
          <source>When BE or LE is explicitly stated as the name of encoding, BOM is simply treated as a normal character (ZERO WIDTH NO-BREAK SPACE).</source>
          <target state="translated">エンコーディング名として BE や LE が明示的に記載されている場合、BOM は単に通常のキャラクタ(ZERO WIDTH NO-BREAK SPACE)として扱われます。</target>
        </trans-unit>
        <trans-unit id="68ea7ed2b7146d8c990e48756af545235a644f6f" translate="yes" xml:space="preserve">
          <source>When BE or LE is omitted during decode(), it checks if BOM is at the beginning of the string; if one is found, the endianness is set to what the BOM says.</source>
          <target state="translated">BE や LE が decode()で省略された場合、文字列の先頭に BOM があるかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="0fbaed27da231d1d0f199bebcb75bb30dedc0240" translate="yes" xml:space="preserve">
          <source>When BE or LE is omitted during decode(), it checks if BOM is at the beginning of the string; if one is found, the endianness is set to what the BOM says. If no BOM is found, the routine dies.</source>
          <target state="translated">デコード中に BE または LE が省略されると、文字列の先頭に BOM があるかどうかをチェックします。BOM が見つからない場合、ルーチンは終了します。</target>
        </trans-unit>
        <trans-unit id="420dd2e0afe91753dba538ca831997f9f3a56a48" translate="yes" xml:space="preserve">
          <source>When BE or LE is omitted during encode(), it returns a BE-encoded string with BOM prepended. So when you want to encode a whole text file, make sure you encode() the whole text at once, not line by line or each line, not file, will have a BOM prepended.</source>
          <target state="translated">encode()の際に BE や LE を省略すると、BE エンコードされた文字列に BOM が付加されたものが返されます。つまり、テキストファイル全体をエンコードしたい場合は、一行ずつではなく一度にテキスト全体を encode()するようにしましょう。</target>
        </trans-unit>
        <trans-unit id="dacba9cd09b7954f0b607de2124d67d55cdeb2ac" translate="yes" xml:space="preserve">
          <source>When CPAN runs, it sets the environment variable PERL5_CPAN_IS_RUNNING to the ID of the running process. It also sets PERL5_CPANPLUS_IS_RUNNING to prevent runaway processes which could happen with older versions of Module::Install.</source>
          <target state="translated">CPAN が実行されると、環境変数 PERL5_CPAN_IS_RUNNING に実行中のプロセスの ID を設定します。また、古いバージョンの Module::Install で発生する可能性のあるプロセスの暴走を防ぐために、PERL5_CPANPLUS_IS_RUNNING を設定します。</target>
        </trans-unit>
        <trans-unit id="652978d2789dfa7c2e88ae3ead48735cc4a8b7e9" translate="yes" xml:space="preserve">
          <source>When CPAN.pm extends @INC via PERL5LIB, it prints a list of directories added (or a summary of how many directories are added). Choose 'v' to get this message, 'none' to suppress it.</source>
          <target state="translated">CPAN.pm が PERL5LIB を介して @INC を拡張すると、追加されたディレクトリのリストを表示します (または、追加されたディレクトリの数の要約を表示します)。このメッセージを表示するには 'v' を選択し、表示しないには 'none' を選択します。</target>
        </trans-unit>
        <trans-unit id="ec2c74f66c6e4b429c5d3bf449f05522f381cd48" translate="yes" xml:space="preserve">
          <source>When CPAN.pm loads a module it needs for some optional feature, it usually reports about module name and version. Choose 'v' to get this message, 'none' to suppress it.</source>
          <target state="translated">CPAN.pm がオプション機能のために必要なモジュールをロードすると、通常はモジュール名とバージョンを報告します。このメッセージを表示するには 'v' を選択し、表示しないには 'none' を選択します。</target>
        </trans-unit>
        <trans-unit id="a6c2efe210167d6d16736590efab450901a5223c" translate="yes" xml:space="preserve">
          <source>When CPAN.pm uses the tar command, which switch for the verbosity shall be used? Choose 'none' for quiet operation, 'v' for file name listing, 'vv' for full listing.</source>
          <target state="translated">CPAN.pm が tar コマンドを使用する場合、冗長性のスイッチはどれを使用しますか?静かな動作の場合は 'none'、ファイル名の一覧表示の場合は 'v'、完全な一覧表示の場合は 'vv' を選択してください。</target>
        </trans-unit>
        <trans-unit id="09926237f4d026fd4275fa85769eac33da9c9434" translate="yes" xml:space="preserve">
          <source>When Configure asks about the extensions, I suggest IO and Fcntl, and if you want database handling then SDBM_File or GDBM_File (you need to install gdbm for this one). If you want to use the POSIX extension (this is the default), make sure that the stack size of your</source>
          <target state="translated">Configure が拡張機能について尋ねてきたら、IO と Fcntl、データベース処理が必要なら SDBM_File か GDBM_File (これには gdbm をインストールする必要があります)を勧めます。POSIX 拡張を使いたい場合は (これがデフォルトです)、スタックサイズが</target>
        </trans-unit>
        <trans-unit id="04e0b7cf71399471be99cb867416364c0df9f40e" translate="yes" xml:space="preserve">
          <source>When Democritus gave the word &amp;ldquo;atom&amp;rdquo; to the indivisible bits of matter, he meant literally something that could not be cut:</source>
          <target state="translated">Democritusが問題の分割不可能な部分に「原子」という単語を与えたとき、彼は文字通り切り取ることのできない何かを意味しました：</target>
        </trans-unit>
        <trans-unit id="bed16fa39ff4d380815a5a95de03029e7764deee" translate="yes" xml:space="preserve">
          <source>When G_KEEPERR is used, any error in the called code will terminate the call as usual, and the error will not propagate beyond the call (as usual for G_EVAL), but it will not go into &lt;code&gt;$@&lt;/code&gt; . Instead the error will be converted into a warning, prefixed with the string &quot;\t(in cleanup)&quot;. This can be disabled using &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'misc'&lt;/code&gt; . If there is no error, &lt;code&gt;$@&lt;/code&gt; will not be cleared.</source>
          <target state="translated">G_KEEPERRが使用されている場合、呼び出されたコードのエラーは通常どおり呼び出しを終了し、エラーは呼び出しを超えて（G_EVALの通常のように）伝播しませんが、 &lt;code&gt;$@&lt;/code&gt; は入りません。代わりに、エラーは警告に変換され、文字列 &quot;\ t（in cleanup）&quot;が前に付きます。これは &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'misc'&lt;/code&gt; を使用せずに無効にできます。エラーがない場合、 &lt;code&gt;$@&lt;/code&gt; はクリアされません。</target>
        </trans-unit>
        <trans-unit id="bd0879b5780d10481d395ff78c94006ad9de4758" translate="yes" xml:space="preserve">
          <source>When G_KEEPERR is used, any error in the called code will terminate the call as usual, and the error will not propagate beyond the call (as usual for G_EVAL), but it will not go into &lt;code&gt;$@&lt;/code&gt;. Instead the error will be converted into a warning, prefixed with the string &quot;\t(in cleanup)&quot;. This can be disabled using &lt;code&gt;no warnings 'misc'&lt;/code&gt;. If there is no error, &lt;code&gt;$@&lt;/code&gt; will not be cleared.</source>
          <target state="translated">G_KEEPERRが使用されている場合、呼び出されたコードにエラーがあると、通常どおり呼び出しが終了し、エラーは呼び出しを超えて伝播しません（G_EVALの場合と同様）が、 &lt;code&gt;$@&lt;/code&gt; は入りません。代わりに、エラーは文字列「\ t（クリーンアップ中）」で始まる警告に変換されます。これは &lt;code&gt;no warnings 'misc'&lt;/code&gt; で無効にすることができます 'その他'。エラーがない場合、 &lt;code&gt;$@&lt;/code&gt; はクリアされません。</target>
        </trans-unit>
        <trans-unit id="c6cefe86149d167c60485e01ab068ab4acc1c96d" translate="yes" xml:space="preserve">
          <source>When I install bundles or multiple modules with one command there is too much output to keep track of.</source>
          <target state="translated">バンドルや複数のモジュールを一つのコマンドでインストールすると、出力が多すぎて追跡できません。</target>
        </trans-unit>
        <trans-unit id="96aa2dd484c673b89bb47260df9f770fc3e65459" translate="yes" xml:space="preserve">
          <source>When I run CPAN's shell, I get an error message about things in my &lt;code&gt;/etc/inputrc&lt;/code&gt; (or &lt;code&gt;~/.inputrc&lt;/code&gt;) file.</source>
          <target state="translated">CPANのシェルを実行すると、 &lt;code&gt;/etc/inputrc&lt;/code&gt; （または &lt;code&gt;~/.inputrc&lt;/code&gt; ）ファイルの内容に関するエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="cc4c433cebf4d4f4606a91e341dbbd967898b31d" translate="yes" xml:space="preserve">
          <source>When I run my tests TAP::Harness creates a scheduler (TAP::Parser::Scheduler) to work out the running order for the tests, an aggregator (TAP::Parser::Aggregator) to collect and analyse the test results and a formatter (TAP::Formatter::Console) to display those results.</source>
          <target state="translated">テストを実行するとき、TAP::Harness はテストの実行順序を計算するスケジューラ (TAP::Parser::Scheduler)、テスト結果を収集・分析するアグリゲータ (TAP::Parser::Aggregator)、結果を表示するフォーマッタ (TAP::Formatter::Console)を作成します。</target>
        </trans-unit>
        <trans-unit id="712f9e473dcc2ba74a4ec66b73d3e2f5bccede0e" translate="yes" xml:space="preserve">
          <source>When I run prove it processes its arguments, figures out which test scripts to run and then passes control to TAP::Harness to run the tests, parse, analyse and present the results. By subclassing TAP::Harness I can customise many aspects of the test run.</source>
          <target state="translated">prove を実行すると、引数を処理し、どのテストスクリプトを実行するかを判断し、TAP::Harness に制御を渡して、テストを実行し、解析し、結果を表示します。TAP::Harnessをサブクラス化することで、テスト実行の多くの側面をカスタマイズすることができます。</target>
        </trans-unit>
        <trans-unit id="1064c03f1fc4073f4165a39d84f0e0127c6dd155" translate="yes" xml:space="preserve">
          <source>When I tell prove to save state it writes a file called '.prove' ('_prove' on Windows) in the current directory. It's a YAML document so it's quite easy to write tools of your own that work on the saved test state - but the format isn't officially documented so it might change without (much) warning in the future.</source>
          <target state="translated">proveに状態を保存するように指示すると、カレントディレクトリに'.prove'(Windowsでは'_prove')というファイルを書き出します。これはYAML文書なので、保存されたテスト状態で動作する独自のツールを書くのは非常に簡単です-しかし、フォーマットは公式に文書化されていないので、将来的には(多くの)警告なしに変更されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="6b21be97219bbbb10df79f70e49405f833c3cad4" translate="yes" xml:space="preserve">
          <source>When I tried to run my script, I got this message. What does it mean?</source>
          <target state="translated">スクリプトを実行しようとしたら、こんなメッセージが出てきました。これは何を意味しているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="e4bb48e8ad735dfd3ed959c0444d6089c891d679" translate="yes" xml:space="preserve">
          <source>When I/O, for example &quot;read&quot;, is requested, the request goes from Perl first down the stack using &quot;read&quot; functions of each layer, then at the bottom the input is requested from the operating system services, then the result is returned up the stack, finally being interpreted as Perl data.</source>
          <target state="translated">I/O、例えば「読み込み」が要求された場合、要求はPerlから各レイヤの「読み込み」関数を使ってまずスタックの下の方に行き、下の方ではオペレーティングシステムのサービスから入力が要求され、その結果がスタックの上の方に返され、最終的にPerlのデータとして解釈されます。</target>
        </trans-unit>
        <trans-unit id="e5e8467b062c382be485cbe69584b5d02adf0299" translate="yes" xml:space="preserve">
          <source>When Memoize needs to check to see if an entry is in the cache already, it will invoke &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt; . &lt;code&gt;key&lt;/code&gt; is the normalized function argument. MyExpirePolicy::EXISTS should return 0 if the key is not in the cache, or if it has expired, and 1 if an unexpired value is in the cache. It should</source>
          <target state="translated">Memoizeは、エントリがすでにキャッシュにあるかどうかを確認する必要がある場合、 &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt; を呼び出します。 &lt;code&gt;key&lt;/code&gt; は、正規化された関数の引数です。MyExpirePolicy :: EXISTSは、キーがキャッシュにない場合、またはキーが期限切れの場合は0を返し、期限切れでない値がキャッシュにある場合は1を返します。そうすべき</target>
        </trans-unit>
        <trans-unit id="de4b7c34cbf176c69c5c8a01cb2f47a2ef49c9de" translate="yes" xml:space="preserve">
          <source>When Memoize needs to check to see if an entry is in the cache already, it will invoke &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt;. &lt;code&gt;key&lt;/code&gt; is the normalized function argument. MyExpirePolicy::EXISTS should return 0 if the key is not in the cache, or if it has expired, and 1 if an unexpired value is in the cache. It should</source>
          <target state="translated">Memoizeがエントリがすでにキャッシュにあるかどうかを確認する必要がある場合、 &lt;code&gt;C-&amp;gt;EXISTS(key)&lt;/code&gt; を呼び出します。 &lt;code&gt;key&lt;/code&gt; は正規化された関数の引数です。MyExpirePolicy :: EXISTSは、キーがキャッシュにない場合、またはキーの有効期限が切れている場合は0を返し、有効期限が切れていない値がキャッシュにある場合は1を返す必要があります。そうすべき</target>
        </trans-unit>
        <trans-unit id="ebd887c91b9049b8dfb0bd1e032eea2b43f90690" translate="yes" xml:space="preserve">
          <source>When Perl 5.12 or later encounters an ellipsis statement, it parses this without error, but if and when you should actually try to execute it, Perl throws an exception with the text &lt;code&gt;Unimplemented&lt;/code&gt; :</source>
          <target state="translated">Perl 5.12以降が省略文に遭遇すると、エラーなしでこれを解析しますが、実際に実行しようとすると、Perlは &lt;code&gt;Unimplemented&lt;/code&gt; というテキストで例外をスローします。</target>
        </trans-unit>
        <trans-unit id="5b63aa2881910e0e5509ac7fb04463269b672b02" translate="yes" xml:space="preserve">
          <source>When Perl 5.6.0 was released, the decision was made to provide a transformation between the old-style decimal versions and new-style dotted-decimal versions:</source>
          <target state="translated">Perl 5.6.0がリリースされたとき、旧式の10進法と新式の10進法の間の変換を提供することが決定されました。</target>
        </trans-unit>
        <trans-unit id="ab4ce43e1ebabd776abd8a74c5e1d002b8bd8ffe" translate="yes" xml:space="preserve">
          <source>When Perl compiles the regular expression, it treats the parenthesis as the start of a memory match. When it doesn't find the closing parenthesis, it complains:</source>
          <target state="translated">Perlが正規表現をコンパイルすると、括弧をメモリマッチの開始点として扱います。閉じ括弧が見つからない場合は文句を言います。</target>
        </trans-unit>
        <trans-unit id="53c411ad4e1523024c43c3f84e8d99bfb2921a55" translate="yes" xml:space="preserve">
          <source>When Perl destroys the object referenced by $netconf it will send the object to the supplied XSUB DESTROY function. Perl cannot determine, and does not care, that this object is a C struct and not a Perl object. In this sense, there is no difference between the object created by the getnetconfigent() XSUB and an object created by a normal Perl subroutine.</source>
          <target state="translated">Perl は $netconf で参照されているオブジェクトを破棄すると、そのオブジェクトを指定された XSUB DESTROY 関数に送ります。Perl は、このオブジェクトが C 構造体であり Perl オブジェクトではないことを判断することはできませんし、気にもしません。この意味では、getnetconfigent()XSUBによって作成されたオブジェクトと通常のPerlサブルーチンによって作成されたオブジェクトに違いはありません。</target>
        </trans-unit>
        <trans-unit id="954a1b48bf7dbf510303237ceeb967daf1def196" translate="yes" xml:space="preserve">
          <source>When Perl encounters a wildcard subpattern, (see &lt;a href=&quot;perlunicode#Wildcards-in-Property-Values&quot;&gt;&quot;Wildcards in Property Values&quot; in perlunicode&lt;/a&gt;), it suspends compilation of the main pattern, compiles the subpattern, and then matches that against all legal possibilities to determine the actual code points the subpattern matches. After that it adds these to the main pattern, and continues its compilation.</source>
          <target state="translated">Perlがワイルドカードサブパターンを検出すると（&lt;a href=&quot;perlunicode#Wildcards-in-Property-Values&quot;&gt;perlunicodeの「プロパティ値のワイルドカード」を参照&lt;/a&gt;）、メインパターンのコンパイルを一時停止し、サブパターンをコンパイルしてから、それをすべての正当な可能性と照合して、サブパターンが一致する実際のコードポイントを判別します。その後、これらをメインパターンに追加し、コンパイルを続行します。</target>
        </trans-unit>
        <trans-unit id="e513aa6b4ab015986cab17c857cc3e0082b263e5" translate="yes" xml:space="preserve">
          <source>When Perl exchanges data with an extension, the extension should be able to understand the UTF8 flag and act accordingly. If the extension doesn't recognize that flag, it's likely that the extension will return incorrectly-flagged data.</source>
          <target state="translated">Perl が拡張機能とデータを交換するとき、拡張機能は UTF8 フラグを理解し、それに応じて動作するようにしなければなりません。もし拡張機能がそのフラグを認識していない場合、拡張機能は正しくないフラグのついたデータを返す可能性があります。</target>
        </trans-unit>
        <trans-unit id="4850373be99ff07c49bae45c8a4c6f5b91630080" translate="yes" xml:space="preserve">
          <source>When Perl is being run under a Unix shell on OpenVMS, the defaults at a future time may be more appropriate for it.</source>
          <target state="translated">OpenVMS上のUnixシェルでPerlを実行している場合は、将来のデフォルトの方が適切かもしれません。</target>
        </trans-unit>
        <trans-unit id="f6f1776d7dcd16bb2da8426867ab48b032eaee97" translate="yes" xml:space="preserve">
          <source>When Perl is built with PERL_IMPLICIT_CONTEXT, extensions that call any functions in the Perl API will need to pass the initial context argument somehow. The kicker is that you will need to write it in such a way that the extension still compiles when Perl hasn't been built with PERL_IMPLICIT_CONTEXT enabled.</source>
          <target state="translated">Perl が PERL_IMPLICIT_CONTEXT でビルドされている場合、Perl API の関数を呼び出す拡張機能は、何らかの方法で最初のコンテキスト引数を渡す必要があります。キッカケは、Perl_IMPLICIT_CONTEXTを有効にしてPerlがビルドされていない場合でも、拡張機能がコンパイルできるように記述する必要があるということです。</target>
        </trans-unit>
        <trans-unit id="f6fb72d35777e36edb4c8c03f40429a73f9b258a" translate="yes" xml:space="preserve">
          <source>When Perl is built without options that set PERL_IMPLICIT_CONTEXT, there is no first argument containing the interpreter's context. The trailing underscore in the pTHX_ macro indicates that the macro expansion needs a comma after the context argument because other arguments follow it. If PERL_IMPLICIT_CONTEXT is not defined, pTHX_ will be ignored, and the subroutine is not prototyped to take the extra argument. The form of the macro without the trailing underscore is used when there are no additional explicit arguments.</source>
          <target state="translated">PERL_IMPLICIT_CONTEXTを設定するオプションなしでPerlがビルドされている場合、インタプリタのコンテキストを含む第1引数はありません。pTHX_マクロの末尾のアンダースコアは、他の引数がコンテキスト引数の後に続くため、マクロ展開でコンテキスト引数の後にカンマが必要であることを示しています。PERL_IMPLICIT_CONTEXTが定義されていない場合、pTHX_は無視され、サブルーチンは余分な引数を取るようにプロトタイピングされません。追加の明示的な引数がない場合は、末尾のアンダースコアのないマクロの形式が使用されます。</target>
        </trans-unit>
        <trans-unit id="8079f54267f5c6445383e49837ffc5d08d1d7078" translate="yes" xml:space="preserve">
          <source>When Perl is compiled for a platform, it looks at all of these characters to guess which EBCDIC character set the platform uses, and adapts itself accordingly to that platform. If the platform uses a character set that is not one of the three Perl knows about, Perl will either fail to compile, or mistakenly and silently choose one of the three.</source>
          <target state="translated">Perl があるプラットフォーム用にコンパイルされるとき、Perl はこれらすべての文字を見て、そのプラットフォームがどの EBCDIC 文字セットを使用しているかを推測し、そのプラットフォームに合わせて自分自身を適応させます。プラットフォームが、Perlが知っている3つの文字セットのうちの1つではない文字セットを使用している場合、Perlはコンパイルに失敗するか、誤って3つのうちの1つを選択してしまいます。</target>
        </trans-unit>
        <trans-unit id="80ed2279b39397e0ed205899926800b606fe0a42" translate="yes" xml:space="preserve">
          <source>When Perl is configured to use ithreads, it will use re-entrant library calls in preference to non-re-entrant versions. There is an incompatibility in OpenBSD's &lt;code&gt;getprotobyname_r&lt;/code&gt; and &lt;code&gt;getservbyname_r&lt;/code&gt; function in versions 3.7 and later that will cause a SEGV when called without doing a &lt;code&gt;bzero&lt;/code&gt; on their return structs prior to calling these functions. Current Perl's should handle this problem correctly. Older threaded Perls (5.8.6 or earlier) will run into this problem. If you want to run a threaded Perl on OpenBSD 3.7 or higher, you will need to upgrade to at least Perl 5.8.7.</source>
          <target state="translated">Perlがithreadを使用するように構成されている場合、Perlは非再入可能バージョンよりも再入可能ライブラリー呼び出しを使用します。 OpenBSDの &lt;code&gt;getprotobyname_r&lt;/code&gt; 関数と &lt;code&gt;getservbyname_r&lt;/code&gt; 関数にはバージョン3.7以降の非互換性があり、これらの関数を呼び出す前に、return構造体で &lt;code&gt;bzero&lt;/code&gt; を実行せずに呼び出すと、SEGVが発生します。現在のPerlはこの問題を正しく処理する必要があります。古いスレッドのPerl（5.8.6以前）がこの問題に遭遇します。 OpenBSD 3.7以降でスレッド化されたPerlを実行する場合は、少なくともPerl 5.8.7にアップグレードする必要があります。</target>
        </trans-unit>
        <trans-unit id="df300d221e04eb6da687f72d9bfb0bebe32d3fc0" translate="yes" xml:space="preserve">
          <source>When Perl is processing &quot;binary data&quot;, the programmer wants Perl to process &quot;sequences of bytes&quot;. This is not a problem for Perl: because a byte has 256 possible values, it easily fits in Perl's much larger &quot;logical character&quot;.</source>
          <target state="translated">Perl が「バイナリデータ」を処理するとき、プログラマは Perl に「バイトのシーケンス」を処理させたいと思っています。これはPerlにとっては問題ではありません。バイトには256の値があるので、Perlのはるかに大きな「論理文字」に簡単に収まります。</target>
        </trans-unit>
        <trans-unit id="317f1e48aa507068045f8759d8c8badef1389fb8" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this GV contains the SV which holds the name of the sub being debugged. This is the C variable which corresponds to Perl's $DB::sub variable. See &lt;code&gt;&lt;a href=&quot;#PL_DBsingle&quot;&gt;&quot;PL_DBsingle&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Perlがデバッグモードで&lt;b&gt;-d&lt;/b&gt;スイッチを使用して実行される場合、このGVには、デバッグされるサブの名前を保持するSVが含まれます。これは、Perlの$ DB :: sub変数に対応するC変数です。 &lt;code&gt;&lt;a href=&quot;#PL_DBsingle&quot;&gt;&quot;PL_DBsingle&quot;&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="cc51149dee007d3915d8fd89443c351da938e4a2" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this GV contains the SV which holds the name of the sub being debugged. This is the C variable which corresponds to Perl's $DB::sub variable. See &lt;code&gt;PL_DBsingle&lt;/code&gt; .</source>
          <target state="translated">Perlが&lt;b&gt;-d&lt;/b&gt;スイッチを使用してデバッグモードで実行されている場合、このGVには、デバッグされるサブルーチンの名前を保持するSVが含まれます。これは、Perlの$ DB :: sub変数に対応するC変数です。 &lt;code&gt;PL_DBsingle&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="8a3d6fd090f13b8b7228c62f6dd0eea36d1d1e84" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this SV is a boolean which indicates whether subs are being single-stepped. Single-stepping is automatically turned on after every step. This is the C variable which corresponds to Perl's $DB::single variable. See &lt;code&gt;&lt;a href=&quot;#PL_DBsub&quot;&gt;&quot;PL_DBsub&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Perlがデバッグモードで&lt;b&gt;-d&lt;/b&gt;スイッチを使用して実行されている場合、このSVは、サブがシングルステップであるかどうかを示すブール値です。シングルステップは、すべてのステップの後に自動的にオンになります。これは、Perlの$ DB :: single変数に対応するC変数です。 &lt;code&gt;&lt;a href=&quot;#PL_DBsub&quot;&gt;&quot;PL_DBsub&quot;&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="3590f13940a356a00f485512d64c10323ed9ae31" translate="yes" xml:space="preserve">
          <source>When Perl is run in debugging mode, with the &lt;b&gt;-d&lt;/b&gt; switch, this SV is a boolean which indicates whether subs are being single-stepped. Single-stepping is automatically turned on after every step. This is the C variable which corresponds to Perl's $DB::single variable. See &lt;code&gt;PL_DBsub&lt;/code&gt; .</source>
          <target state="translated">Perlが&lt;b&gt;-d&lt;/b&gt;スイッチを指定してデバッグモードで実行されている場合、このSVは、サブルーチンがシングルステップで実行されているかどうかを示すブール値です。シングルステップは、すべてのステップの後に自動的にオンになります。これは、Perlの$ DB :: single変数に対応するC変数です。 &lt;code&gt;PL_DBsub&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="987fa57f3d6e2d1a009a00d587b9bac8f003a80c" translate="yes" xml:space="preserve">
          <source>When Perl is run with the &lt;b&gt;-Do&lt;/b&gt; switch or its equivalent, overloading induces diagnostic messages.</source>
          <target state="translated">Perlが&lt;b&gt;-Do&lt;/b&gt;スイッチまたはそれと同等のもので実行されている場合、オーバーロードにより診断メッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="0c8a95fea35938379cf32ffa88d674c595c3842a" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system with &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; enabled, a wild card directory name of &lt;code&gt;[...]&lt;/code&gt; cannot be translated to a valid Unix file specification. Also, directory file specifications will have their implied &quot;.dir;1&quot; removed, and a trailing &lt;code&gt;.&lt;/code&gt; character indicating a null extension will be removed.</source>
          <target state="translated">Perlが &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; 有効になっているOpenVMSシステムで実行されている場合、ワイルドカードディレクトリ名 &lt;code&gt;[...]&lt;/code&gt; を有効なUnixファイル仕様に変換できません。また、ディレクトリファイルの仕様では、暗黙の「.dir; 1」が削除され、末尾に &lt;code&gt;.&lt;/code&gt; null拡張子を示す文字は削除されます。</target>
        </trans-unit>
        <trans-unit id="ba82f7be76137263de4d2fc5ab0c4a2f7bd88ccf" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system, if the &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; feature is enabled, this implies that the Unix pathname cannot have a version, and that a path consisting of three dots, &lt;code&gt;./.../&lt;/code&gt;, will be converted to &lt;code&gt;[.^.^.^.]&lt;/code&gt;.</source>
          <target state="translated">PerlがOpenVMSシステムで実行されているときに、 &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; 機能が有効になっている場合、これは、Unixパス名にバージョンを &lt;code&gt;./.../&lt;/code&gt; ことができず、3つのドット./.../で構成されるパスが &lt;code&gt;[.^.^.^.]&lt;/code&gt; に変換されることを意味します。 。^。^。^。]。</target>
        </trans-unit>
        <trans-unit id="180489f22e9451652052bb264b159682d8729956" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system, if the &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; feature is not enabled, extra dots in the file specification will be converted to underscore characters, and the &lt;code&gt;?&lt;/code&gt; character will be converted to a &lt;code&gt;%&lt;/code&gt; character, if a conversion is done.</source>
          <target state="translated">PerlがOpenVMSシステムで実行されているときに、 &lt;code&gt;DECC$EFS_CHARSET&lt;/code&gt; 機能が有効になっていない場合、ファイル仕様の余分なドットはアンダースコア文字に変換され、 &lt;code&gt;?&lt;/code&gt; 変換が行われると、文字は &lt;code&gt;%&lt;/code&gt; 文字に変換されます。</target>
        </trans-unit>
        <trans-unit id="207a022d8cbd197e2ed92d3189e5fa31c10891e3" translate="yes" xml:space="preserve">
          <source>When Perl is running on an OpenVMS system, the following &lt;code&gt;DECC$&lt;/code&gt; feature settings will control how the filename is converted:</source>
          <target state="translated">PerlがOpenVMSシステムで実行されている場合、次の &lt;code&gt;DECC$&lt;/code&gt; 機能設定がファイル名の変換方法を制御します。</target>
        </trans-unit>
        <trans-unit id="31b65aa4a8ccdb59770227d57464bc9d968a6a6c" translate="yes" xml:space="preserve">
          <source>When Perl searches for a method, it caches the lookup so that future calls to the method do not need to search for it again. Changing a class's parent class or adding subroutines to a class will invalidate the cache for that class.</source>
          <target state="translated">Perl はメソッドを検索するとき、その検索結果をキャッシュして、将来そのメソッドを呼び出すときに再度検索する必要がないようにします。クラスの親クラスを変更したり、クラスにサブルーチンを追加したりすると、そのクラスのキャッシュは無効になります。</target>
        </trans-unit>
        <trans-unit id="dc44d70cd8e2f4c150d9b1a250549091ec350dff" translate="yes" xml:space="preserve">
          <source>When Perl sees a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; extension;&lt;/code&gt; , it searches for a file with the same name as the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;'d extension that has a .pm suffix. If that file cannot be found, Perl dies with a fatal error. The default search path is contained in the &lt;code&gt;@INC&lt;/code&gt; array.</source>
          <target state="translated">Perlが &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; extension;&lt;/code&gt; 見つけたとき。、拡張子が.pmの &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 'd拡張子と同じ名前のファイルを検索します。そのファイルが見つからない場合、Perlは致命的なエラーで終了します。デフォルトの検索パスは &lt;code&gt;@INC&lt;/code&gt; 配列に含まれています。</target>
        </trans-unit>
        <trans-unit id="8000e169764f8e2a593f5f0dac76f4976f5abd8f" translate="yes" xml:space="preserve">
          <source>When Perl sees a &lt;code&gt;use extension;&lt;/code&gt;, it searches for a file with the same name as the &lt;code&gt;use&lt;/code&gt;'d extension that has a .pm suffix. If that file cannot be found, Perl dies with a fatal error. The default search path is contained in the &lt;code&gt;@INC&lt;/code&gt; array.</source>
          <target state="translated">Perlが &lt;code&gt;use extension;&lt;/code&gt; 見つけたとき。、それは同じ名前のファイルを検索し &lt;code&gt;use&lt;/code&gt; の.pm接尾辞「を有するD拡張。そのファイルが見つからない場合、Perlは致命的なエラーで終了します。デフォルトの検索パスは &lt;code&gt;@INC&lt;/code&gt; 配列に含まれています。</target>
        </trans-unit>
        <trans-unit id="2733cf2ae6a9ab4b9666de0ca99b049c5b762772" translate="yes" xml:space="preserve">
          <source>When PerlIO receives data from either direction, it fills a buffer (currently with 1024 bytes) and passes the buffer to Encode. Encode tries to convert the valid part and passes it back to PerlIO, leaving invalid parts (usually a partial character) in the buffer. PerlIO then appends more data to the buffer, calls Encode again, and so on until the data stream ends.</source>
          <target state="translated">PerlIO はどちらかの方向からデータを受け取ると、バッファ(現在は 1024 バイト)を埋めて、そのバッファを Encode に渡します。Encodeは有効な部分を変換しようとし、無効な部分(通常は部分的な文字)をバッファに残してPerlIOに戻します。その後、PerlIO はバッファにさらにデータを追加し、再度 Encode を呼び出し、データストリームが終了するまでこれを繰り返します。</target>
        </trans-unit>
        <trans-unit id="c45a181d0244e9e1141094875e09095d6414b083" translate="yes" xml:space="preserve">
          <source>When Pod::Simple sees a &quot;=head1 Hi there&quot;, for example, it basically does this:</source>
          <target state="translated">例えば、Pod::Simpleが&quot;=head1 こんにちは &quot;を見ると、基本的には次のようになります。</target>
        </trans-unit>
        <trans-unit id="1cd158af5ecd016f5844a2f8d5f52d658dbd56fa" translate="yes" xml:space="preserve">
          <source>When STDERR is tied, its PRINT method will be called to issue warnings and error messages. This feature is temporarily disabled during the call, which means you can use &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; inside PRINT without starting a recursive loop. And just like &lt;code&gt;__WARN__&lt;/code&gt; and &lt;code&gt;__DIE__&lt;/code&gt; handlers, STDERR's PRINT method may be called to report parser errors, so the caveats mentioned under &lt;a href=&quot;perlvar#%25SIG&quot;&gt;%SIG in perlvar&lt;/a&gt; apply.</source>
          <target state="translated">STDERRが関連付けられると、そのPRINTメソッドが呼び出され、警告とエラーメッセージが発行されます。この機能は呼び出し中に一時的に無効になります。つまり、再帰ループを開始せずにPRINT内で &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn()&lt;/a&gt;&lt;/code&gt; を使用できます。また、 &lt;code&gt;__DIE__&lt;/code&gt; &lt;code&gt;__WARN__&lt;/code&gt; および__DIE__ハンドラーと同様に、パーサーエラーを報告するためにSTDERRのPRINTメソッドが呼び出される場合があるため、&lt;a href=&quot;perlvar#%25SIG&quot;&gt;perlvarの％SIGで説明&lt;/a&gt;されている警告が適用されます。</target>
        </trans-unit>
        <trans-unit id="22d03f9253db06fc5a737726d6333d6b64f0247b" translate="yes" xml:space="preserve">
          <source>When STDERR is tied, its PRINT method will be called to issue warnings and error messages. This feature is temporarily disabled during the call, which means you can use &lt;code&gt;warn()&lt;/code&gt; inside PRINT without starting a recursive loop. And just like &lt;code&gt;__WARN__&lt;/code&gt; and &lt;code&gt;__DIE__&lt;/code&gt; handlers, STDERR's PRINT method may be called to report parser errors, so the caveats mentioned under &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&quot;%SIG&quot; in perlvar&lt;/a&gt; apply.</source>
          <target state="translated">STDERRが関連付けられている場合、そのPRINTメソッドが呼び出されて警告とエラーメッセージが発行されます。この機能は呼び出し中に一時的に無効になります。つまり、再帰ループを開始せずにPRINT内で &lt;code&gt;warn()&lt;/code&gt; を使用できます。また、 &lt;code&gt;__DIE__&lt;/code&gt; &lt;code&gt;__WARN__&lt;/code&gt; および__DIE__ハンドラーと同様に、パーサーエラーを報告するためにSTDERRのPRINTメソッドが呼び出される場合があるため、&lt;a href=&quot;perlvar#%25SIG&quot;&gt;perlvarの「％SIG」で説明&lt;/a&gt;されている警告が適用されます。</target>
        </trans-unit>
        <trans-unit id="776742a8703e38b8c7c180ad1bc1e1f2ea07cf1b" translate="yes" xml:space="preserve">
          <source>When Storable croaks, it tries to report the error via the &lt;code&gt;logcroak()&lt;/code&gt; routine from the &lt;code&gt;Log::Agent&lt;/code&gt; package, if it is available.</source>
          <target state="translated">Storable croakが発生すると、 &lt;code&gt;Log::Agent&lt;/code&gt; パッケージ（使用可能な場合 &lt;code&gt;logcroak()&lt;/code&gt; のlogcroak（）ルーチンを介してエラーを報告しようとします。</target>
        </trans-unit>
        <trans-unit id="b63f06de34cfd6fe1d49dc6c54c0e1ae5c2131fc" translate="yes" xml:space="preserve">
          <source>When Storable throws the &quot;Max. recursion depth with nested structures exceeded&quot; error we are already out of stack space. Unfortunately on some earlier perl versions cleaning up a recursive data structure recurses into the free calls, which will lead to stack overflows in the cleanup. This data structure is not properly cleaned up then, it will only be destroyed during global destruction.</source>
          <target state="translated">Storable が &quot;Max.recursion depth with nested structures exceeded&quot; エラーをスローしたときには、すでにスタックスペースが不足しています。残念なことに、以前のバージョンのいくつかのperlでは、再帰的なデータ構造をクリーンアップすると、フリーコールに再帰してしまい、クリーンアップの際にスタックオーバーフローが発生します。このデータ構造が適切にクリーンアップされていないと、グローバル破壊の間だけ破壊されてしまいます。</target>
        </trans-unit>
        <trans-unit id="06dc1e20be879a4646c74d93b6d6dde474c28168" translate="yes" xml:space="preserve">
          <source>When UTF-8 becomes the standard source format, this pragma will effectively become a no-op.</source>
          <target state="translated">UTF-8が標準的なソースフォーマットになると、このプラグマは事実上ノーオペになります。</target>
        </trans-unit>
        <trans-unit id="d6016e444b9f013774a61df21cb4a60b0edf43d8" translate="yes" xml:space="preserve">
          <source>When UTF-8 becomes the standard source format, this pragma will effectively become a no-op. For convenience in what follows the term</source>
          <target state="translated">UTF-8が標準ソースフォーマットになると、このプラグマは事実上ノーオペになります。以下では便宜上</target>
        </trans-unit>
        <trans-unit id="1e26f2f78b2d3c5f0bcbde15044bd5212be0247d" translate="yes" xml:space="preserve">
          <source>When Unicode Does Not Happen</source>
          <target state="translated">ユニコードが発生しない場合</target>
        </trans-unit>
        <trans-unit id="7748cfda1edce223207e83e001d28dffb7bf724f" translate="yes" xml:space="preserve">
          <source>When Unicode rules are in effect:</source>
          <target state="translated">Unicodeルールが適用されている場合。</target>
        </trans-unit>
        <trans-unit id="a9436974a6cc23829e6eb2bd840fe00c99d5fdc2" translate="yes" xml:space="preserve">
          <source>When Unicode was first conceived, it was thought that all the world's characters could be represented using a 16-bit word; that is a maximum of &lt;code&gt;0x10000&lt;/code&gt; (or 65,536) characters would be needed, from &lt;code&gt;0x0000&lt;/code&gt; to &lt;code&gt;0xFFFF&lt;/code&gt; . This soon proved to be wrong, and since Unicode 2.0 (July 1996), Unicode has been defined all the way up to 21 bits (&lt;code&gt;0x10FFFF&lt;/code&gt; ), and Unicode 3.1 (March 2001) defined the first characters above &lt;code&gt;0xFFFF&lt;/code&gt; . The first &lt;code&gt;0x10000&lt;/code&gt; characters are called the</source>
          <target state="translated">Unicodeが最初に考案されたとき、世界中のすべての文字は16ビットのワードを使用して表現できると考えられていました。つまり、最大 &lt;code&gt;0x10000&lt;/code&gt; （または65,536）文字（ &lt;code&gt;0x0000&lt;/code&gt; から &lt;code&gt;0xFFFF&lt;/code&gt; まで）が必要になります。これはすぐに誤りであることが判明し、Unicode 2.0（1996年7月）以降、Unicodeは21ビット（ &lt;code&gt;0x10FFFF&lt;/code&gt; ）まで定義され、Unicode 3.1（2001年3月）は &lt;code&gt;0xFFFF&lt;/code&gt; より上の最初の文字を定義しました。最初の &lt;code&gt;0x10000&lt;/code&gt; 文字は</target>
        </trans-unit>
        <trans-unit id="235280477a8ab02cc7856eb55d9945ecaf55e478" translate="yes" xml:space="preserve">
          <source>When Unicode was first conceived, it was thought that all the world's characters could be represented using a 16-bit word; that is a maximum of &lt;code&gt;0x10000&lt;/code&gt; (or 65,536) characters would be needed, from &lt;code&gt;0x0000&lt;/code&gt; to &lt;code&gt;0xFFFF&lt;/code&gt;. This soon proved to be wrong, and since Unicode 2.0 (July 1996), Unicode has been defined all the way up to 21 bits (&lt;code&gt;0x10FFFF&lt;/code&gt;), and Unicode 3.1 (March 2001) defined the first characters above &lt;code&gt;0xFFFF&lt;/code&gt;. The first &lt;code&gt;0x10000&lt;/code&gt; characters are called the</source>
          <target state="translated">Unicodeが最初に考案されたとき、世界中のすべての文字を16ビットワードを使用して表すことができると考えられていました。つまり、 &lt;code&gt;0x0000&lt;/code&gt; から &lt;code&gt;0xFFFF&lt;/code&gt; までの最大 &lt;code&gt;0x10000&lt;/code&gt; （または65,536）文字が必要になります。これはすぐに間違っていることが判明し、Unicode 2.0（1996年7月）以降、Unicodeは21ビット（ &lt;code&gt;0x10FFFF&lt;/code&gt; ）まで定義され、Unicode 3.1（2001年3月）は &lt;code&gt;0xFFFF&lt;/code&gt; より上の最初の文字を定義しました。最初の &lt;code&gt;0x10000&lt;/code&gt; 文字は、</target>
        </trans-unit>
        <trans-unit id="e31ae8f51bc97ba41c3c0ff630526d3a83b94c44" translate="yes" xml:space="preserve">
          <source>When a &quot;=head1 ...&quot; directive is parsed, it produces this event structure:</source>
          <target state="translated">head1 ....&quot; ディレクティブが解析されると、このようなイベント構造を生成します。</target>
        </trans-unit>
        <trans-unit id="824bf2e880285aa9c434d2acac5d910818e02e5d" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;SelectSaver&lt;/code&gt; is destroyed, it re-selects the file handle that was selected when it was created.</source>
          <target state="translated">とき &lt;code&gt;SelectSaver&lt;/code&gt; が破壊され、それが作成されたときに、選択したファイルハンドルを再選択します。</target>
        </trans-unit>
        <trans-unit id="47dccd0143522691a9547f34d1ed5af302d02e22" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;given&lt;/code&gt; statement is also a valid expression (for example, when it's the last statement of a block), it evaluates to:</source>
          <target state="translated">ときに &lt;code&gt;given&lt;/code&gt; 文は（それがブロックの最後の文だとき、例えば）にも有効な式である、それはと評価されます。</target>
        </trans-unit>
        <trans-unit id="a06437bb92809b351f6a5100b5739a7e2454e5a6" translate="yes" xml:space="preserve">
          <source>When a CV has a reference count on its slab (&lt;code&gt;CvSLABBED&lt;/code&gt;), it is responsible for making sure it is freed. (Hence, no two CVs should ever have a reference count on the same slab.) The CV only needs to reference the slab during compilation. Once it is compiled and &lt;code&gt;CvROOT&lt;/code&gt; attached, it has finished its job, so it can forget the slab.</source>
          <target state="translated">CVのスラブに参照カウント（ &lt;code&gt;CvSLABBED&lt;/code&gt; ）がある場合、CVはそれが解放されていることを確認する責任があります。 （したがって、2つのCVが同じスラブで参照カウントを持つことはありません。）CVは、コンパイル中にスラブを参照するだけで済みます。コンパイルされて &lt;code&gt;CvROOT&lt;/code&gt; がアタッチされると、ジョブが終了するため、スラブを忘れることができます。</target>
        </trans-unit>
        <trans-unit id="0af006e8d26663a7078cc20a1292be03a5256d66" translate="yes" xml:space="preserve">
          <source>When a CV has a reference count on its slab (CvSLABBED), it is responsible for making sure it is freed. (Hence, no two CVs should ever have a reference count on the same slab.) The CV only needs to reference the slab during compilation. Once it is compiled and CvROOT attached, it has finished its job, so it can forget the slab.</source>
          <target state="translated">CVがそのスラブに参照カウントを持っている場合(CvSLABBED),そのスラブが解放されていることを確認する責任があります(したがって,2つのCVが同じスラブに参照カウントを持つべきではありません).したがって,2つのCVが同じスラブ上に参照カウントを持つことはありません.いったんコンパイルされ,CvROOTがアタッチされると,CVはその仕事を終了しますので,スラブを忘れることができます.</target>
        </trans-unit>
        <trans-unit id="5c03e144fe4a4613006ecf4b238cfa477e26c49c" translate="yes" xml:space="preserve">
          <source>When a DST change causes a locale clock to skip one hour forward, there will be an hour's worth of local times that don't exist. Again, for the &quot;Europe/Paris&quot; time zone, the local clock jumped from 2001-03-25 01:59:59 to 2001-03-25 03:00:00.</source>
          <target state="translated">DSTの変更により、ロケールの時計が1時間前倒しになると、1時間分のローカルタイムが存在しないことになります。ここでも、「ヨーロッパ/パリ」のタイムゾーンでは、2001-03-25 01:59:59から2001-03-25 03:00:00に現地の時計がジャンプしています。</target>
        </trans-unit>
        <trans-unit id="711842f215653a7ad792c5b86c0dd5c2fc228aee" translate="yes" xml:space="preserve">
          <source>When a L&amp;lt;</source>
          <target state="translated">L &amp;lt;の場合</target>
        </trans-unit>
        <trans-unit id="c34b3c17b138dcee1edbc75a046c702f3a8b9a07" translate="yes" xml:space="preserve">
          <source>When a Pod verbatim paragraph (AKA &quot;codeblock&quot;) is parsed, it produces this event structure:</source>
          <target state="translated">Podの冗長段落(別名「codeblock」)が解析されると、このようなイベント構造を生成します。</target>
        </trans-unit>
        <trans-unit id="4f8b5f7b3a10fd426ef30c3ec83c6b8baa679be4" translate="yes" xml:space="preserve">
          <source>When a block is preceded by a compilation phase keyword such as &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;END&lt;/code&gt;, &lt;code&gt;INIT&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, or &lt;code&gt;UNITCHECK&lt;/code&gt;, then the block will run only during the corresponding phase of execution. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for more details.</source>
          <target state="translated">ブロックの前に &lt;code&gt;BEGIN&lt;/code&gt; 、 &lt;code&gt;END&lt;/code&gt; 、 &lt;code&gt;INIT&lt;/code&gt; 、 &lt;code&gt;CHECK&lt;/code&gt; 、 &lt;code&gt;UNITCHECK&lt;/code&gt; などのコンパイルフェーズキーワードが付いている場合、ブロックは対応する実行フェーズでのみ実行されます。詳細については、&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6c769151f41d9f979bbea6aa6d7a29c398587207" translate="yes" xml:space="preserve">
          <source>When a block is preceding by a compilation phase keyword such as &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;END&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , or &lt;code&gt;UNITCHECK&lt;/code&gt; , then the block will run only during the corresponding phase of execution. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;BEGIN&lt;/code&gt; 、 &lt;code&gt;END&lt;/code&gt; 、 &lt;code&gt;INIT&lt;/code&gt; 、 &lt;code&gt;CHECK&lt;/code&gt; 、 &lt;code&gt;UNITCHECK&lt;/code&gt; などのコンパイルフェーズキーワードがブロックの前にある場合、ブロックは対応する実行フェーズでのみ実行されます。詳細については&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7d61af89d14aac150579ea072baeedb77daecc0a" translate="yes" xml:space="preserve">
          <source>When a class has multiple parents, the method lookup order becomes more complicated.</source>
          <target state="translated">クラスが複数の親を持つ場合、メソッドのルックアップ順が複雑になります。</target>
        </trans-unit>
        <trans-unit id="bbfabd64dc538b19e52659b29026ea44adaac5bb" translate="yes" xml:space="preserve">
          <source>When a class inherits from another class, any methods defined in the parent class are available to the child class. If you attempt to call a method on an object that isn't defined in its own class, Perl will also look for that method in any parent classes it may have.</source>
          <target state="translated">クラスが他のクラスから継承する場合、親クラスで定義されているメソッドはすべて子クラスで利用できます。自分のクラスで定義されていないオブジェクトでメソッドを呼ぼうとした場合、Perl はそのメソッドがあるかもしれない親クラスの中でそのメソッドを探します。</target>
        </trans-unit>
        <trans-unit id="3fbe037b656bddc24c2846062762f1fce297b32a" translate="yes" xml:space="preserve">
          <source>When a comma-separated list of subroutine names is given as options, Showlex prints the lexical variables used in those subroutines. Otherwise, it prints the file-scope lexicals in the file.</source>
          <target state="translated">サブルーチン名のカンマ区切りのリストがオプションとして与えられると、Showlex はそれらのサブルーチンで使用される辞書変数を表示します。それ以外の場合は、ファイル内のファイルスコープ辞書を表示します。</target>
        </trans-unit>
        <trans-unit id="7150e31ab9e9cca66d69c6a47a4d5fc17ee83d01" translate="yes" xml:space="preserve">
          <source>When a constant is used in an expression, Perl replaces it with its value at compile time, and may then optimize the expression further. In particular, any code in an &lt;code&gt;if (CONSTANT)&lt;/code&gt; block will be optimized away if the constant is false.</source>
          <target state="translated">式で定数が使用されている場合、Perlはコンパイル時に定数をその値に置き換え、式をさらに最適化します。特に、定数がfalseの場合、 &lt;code&gt;if (CONSTANT)&lt;/code&gt; ブロック内のコードは最適化されます。</target>
        </trans-unit>
        <trans-unit id="ff12ac8ff6a9fb5ab965d82a8adb8da16c238288" translate="yes" xml:space="preserve">
          <source>When a context for a part of compile tree is known, it is propagated down through the tree. At this time the context can have 5 values (instead of 2 for runtime context): void, boolean, scalar, list, and lvalue. In contrast with the pass 1 this pass is processed from top to bottom: a node's context determines the context for its children.</source>
          <target state="translated">コンパイルツリーの一部のコンテキストが既知の場合、それはツリーを介して伝搬されます。この時、コンテキストは5つの値を持つことができます(ランタイムコンテキストの場合は2つではなく):void、boolean、scalar、list、lvalueです。パス1とは対照的に、このパスは上から下へと処理されます。</target>
        </trans-unit>
        <trans-unit id="d87717a8777688d74cabbb2304d94b51341cc91d" translate="yes" xml:space="preserve">
          <source>When a core function calls another, it must pass the context. This is normally hidden via macros. Consider &lt;code&gt;sv_setiv&lt;/code&gt; . It expands into something like this:</source>
          <target state="translated">コア関数が別の関数を呼び出すとき、コンテキストを渡す必要があります。これは通常、マクロによって非表示になります。 &lt;code&gt;sv_setiv&lt;/code&gt; を検討してください。これは次のように拡張されます。</target>
        </trans-unit>
        <trans-unit id="89bb7cb6afe2aeb318bc31219fdbcf9684114fa1" translate="yes" xml:space="preserve">
          <source>When a core function calls another, it must pass the context. This is normally hidden via macros. Consider &lt;code&gt;sv_setiv&lt;/code&gt;. It expands into something like this:</source>
          <target state="translated">コア関数が別の関数を呼び出すときは、コンテキストを渡す必要があります。これは通常、マクロを介して非表示になります。 &lt;code&gt;sv_setiv&lt;/code&gt; を検討してください。これは次のように展開されます。</target>
        </trans-unit>
        <trans-unit id="40ceceb3dfac228f4dc1ea2316b05b14abb23395" translate="yes" xml:space="preserve">
          <source>When a dictionary is specified</source>
          <target state="translated">辞書を指定した場合</target>
        </trans-unit>
        <trans-unit id="d409b69c538e75e300d571031fe6a755a4d085f3" translate="yes" xml:space="preserve">
          <source>When a distribution has already been tested by CPAN::Reporter on this machine, CPAN can skip the test phase and just rely on the test report history instead.</source>
          <target state="translated">ディストリビューションがこのマシン上でCPAN::Reporterによってすでにテストされている場合、CPANはテストフェーズをスキップして、代わりにテストレポートの履歴だけに頼ることができます。</target>
        </trans-unit>
        <trans-unit id="f71acc218a83c770a92fc1a815404b3d3de498a7" translate="yes" xml:space="preserve">
          <source>When a file is opened it is in either text or binary mode. In text mode a file is subject to CR/LF/Ctrl-Z translations. With Cygwin, the default mode for an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; is determined by the mode of the mount that underlies the file. See &lt;a href=&quot;#Cygwin%3a%3ais_binmount&quot;&gt;Cygwin::is_binmount&lt;/a&gt;(). Perl provides a &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; function to set binary mode on files that otherwise would be treated as text. &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; with the &lt;code&gt;O_TEXT&lt;/code&gt; flag sets text mode on files that otherwise would be treated as binary:</source>
          <target state="translated">ファイルを開くと、テキストモードまたはバイナリモードのいずれかになります。テキストモードでは、ファイルはCR / LF / Ctrl-Z変換の対象になります。 Cygwinでは、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; のデフォルトモードは、ファイルの下にあるマウントのモードによって決まります。&lt;a href=&quot;#Cygwin%3a%3ais_binmount&quot;&gt;Cygwin :: is_binmount&lt;/a&gt;（）を参照してください。 Perlは、他の方法ではテキストとして扱われるファイルにバイナリモードを設定する &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; 関数を提供します。 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; フラグを指定したsysopen（）は、 &lt;code&gt;O_TEXT&lt;/code&gt; はバイナリとして扱われるファイルにテキストモードを設定します。</target>
        </trans-unit>
        <trans-unit id="77b5bb5939b31598184beb720f013a6b65e23bf1" translate="yes" xml:space="preserve">
          <source>When a file is opened it is in either text or binary mode. In text mode a file is subject to CR/LF/Ctrl-Z translations. With Cygwin, the default mode for an &lt;code&gt;open()&lt;/code&gt; is determined by the mode of the mount that underlies the file. See &lt;a href=&quot;#Cygwin%3A%3Ais_binmount&quot;&gt;&quot;Cygwin::is_binmount&quot;&lt;/a&gt;(). Perl provides a &lt;code&gt;binmode()&lt;/code&gt; function to set binary mode on files that otherwise would be treated as text. &lt;code&gt;sysopen()&lt;/code&gt; with the &lt;code&gt;O_TEXT&lt;/code&gt; flag sets text mode on files that otherwise would be treated as binary:</source>
          <target state="translated">ファイルを開くと、テキストモードまたはバイナリモードになります。テキストモードでは、ファイルはCR / LF / Ctrl-Z変換の対象になります。 Cygwinでは、 &lt;code&gt;open()&lt;/code&gt; のデフォルトのモードは、ファイルの基礎となるマウントのモードによって決定されます。&lt;a href=&quot;#Cygwin%3A%3Ais_binmount&quot;&gt;「Cygwin :: is_binmount」&lt;/a&gt;（）を参照してください。 Perlは、そうでなければテキストとして扱われるファイルにバイナリモードを設定する &lt;code&gt;binmode()&lt;/code&gt; 関数を提供します。 &lt;code&gt;sysopen()&lt;/code&gt; と &lt;code&gt;O_TEXT&lt;/code&gt; さもなければバイナリとして扱われるファイルにフラグをセットテキストモード：</target>
        </trans-unit>
        <trans-unit id="973bff9414f9daff4e8ac9353de5be029b42eafe" translate="yes" xml:space="preserve">
          <source>When a handle is so opened, then reads get bytes from the string value of</source>
          <target state="translated">ハンドルがそう開かれている場合は、その後の文字列の値からバイトを取得します。</target>
        </trans-unit>
        <trans-unit id="17e8d47075484fcb067bf9d5f01cdea7dd0c053a" translate="yes" xml:space="preserve">
          <source>When a keyword is being handled, the plugin function must build a tree of &lt;code&gt;OP&lt;/code&gt; structures, representing the code that was parsed. The root of the tree must be stored in &lt;code&gt;*op_ptr&lt;/code&gt; . The function then returns a constant indicating the syntactic role of the construct that it has parsed: &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; if it is a complete statement, or &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; if it is an expression. Note that a statement construct cannot be used inside an expression (except via &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; and similar), and an expression is not a complete statement (it requires at least a terminating semicolon).</source>
          <target state="translated">キーワードが処理されているとき、プラグイン関数は、解析されたコードを表す &lt;code&gt;OP&lt;/code&gt; 構造のツリーを構築する必要があります。ツリーのルートは &lt;code&gt;*op_ptr&lt;/code&gt; に格納する必要があります。 ：この関数は、それが解析されたことコンストラクトの構文上の役割を示す定数を返し &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; を、それは完全なステートメントである場合、または &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; それが表現されている場合。ステートメント構造は式の内部では使用できず（ &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; BLOCK&lt;/code&gt; などを使用する場合を除く）、式は完全なステートメントではありません（少なくとも終了セミコロンが必要です）。</target>
        </trans-unit>
        <trans-unit id="a9174fe1323f2a0785f91a3ab7751748b2c8cde0" translate="yes" xml:space="preserve">
          <source>When a keyword is being handled, the plugin function must build a tree of &lt;code&gt;OP&lt;/code&gt; structures, representing the code that was parsed. The root of the tree must be stored in &lt;code&gt;*op_ptr&lt;/code&gt;. The function then returns a constant indicating the syntactic role of the construct that it has parsed: &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; if it is a complete statement, or &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; if it is an expression. Note that a statement construct cannot be used inside an expression (except via &lt;code&gt;do BLOCK&lt;/code&gt; and similar), and an expression is not a complete statement (it requires at least a terminating semicolon).</source>
          <target state="translated">キーワードが処理されているとき、プラグイン関数は、解析されたコードを表す &lt;code&gt;OP&lt;/code&gt; 構造のツリーを構築する必要があります。ツリーのルートは &lt;code&gt;*op_ptr&lt;/code&gt; に格納する必要があります。 ：この関数は、それが解析されたことコンストラクトの構文上の役割を示す定数を返し &lt;code&gt;KEYWORD_PLUGIN_STMT&lt;/code&gt; を、それは完全なステートメントである場合、または &lt;code&gt;KEYWORD_PLUGIN_EXPR&lt;/code&gt; それが表現されている場合。ステートメント構造は式内で使用できず（ &lt;code&gt;do BLOCK&lt;/code&gt; などを使用する場合を除く）、式は完全なステートメントではないことに注意してください（少なくとも終了セミコロンが必要です）。</target>
        </trans-unit>
        <trans-unit id="9e79d667e2ee3be13474d3de61e4494ae38724c2" translate="yes" xml:space="preserve">
          <source>When a keyword is handled, the plugin function may also have (compile-time) side effects. It may modify &lt;code&gt;%^H&lt;/code&gt; , define functions, and so on. Typically, if side effects are the main purpose of a handler, it does not wish to generate any ops to be included in the normal compilation. In this case it is still required to supply an op tree, but it suffices to generate a single null op.</source>
          <target state="translated">キーワードが処理されると、プラグイン関数には（コンパイル時の）副作用がある場合があります。 &lt;code&gt;%^H&lt;/code&gt; 変更、関数の定義などを行う場合があります。通常、副作用がハンドラーの主な目的である場合、通常のコンパイルに含まれるopを生成することは望んでいません。この場合でも、opツリーを指定する必要がありますが、単一のnull opを生成するだけで十分です。</target>
        </trans-unit>
        <trans-unit id="96150c30b3160f65ac137db96b6444cc4c0b5dee" translate="yes" xml:space="preserve">
          <source>When a keyword is handled, the plugin function may also have (compile-time) side effects. It may modify &lt;code&gt;%^H&lt;/code&gt;, define functions, and so on. Typically, if side effects are the main purpose of a handler, it does not wish to generate any ops to be included in the normal compilation. In this case it is still required to supply an op tree, but it suffices to generate a single null op.</source>
          <target state="translated">キーワードが処理されると、プラグイン関数にも（コンパイル時の）副作用が発生する可能性があります。 &lt;code&gt;%^H&lt;/code&gt; 変更したり、関数を定義したりする場合があります。通常、副作用がハンドラーの主な目的である場合、通常のコンパイルに含まれるopsを生成することは望ましくありません。この場合でも、opツリーを指定する必要がありますが、単一のnullopを生成するだけで十分です。</target>
        </trans-unit>
        <trans-unit id="57d37ded835c420c7b9a32e56975a37c7bb1fd7d" translate="yes" xml:space="preserve">
          <source>When a lexical var hasn't yet been introduced, it already exists from the perspective of duplicate declarations, but not for variable lookups, e.g.</source>
          <target state="translated">辞書的な var がまだ導入されていない場合、重複宣言の観点からすでに存在しているが、変数のルックアップの観点からは存在しない、例えば</target>
        </trans-unit>
        <trans-unit id="57ad4f96e4d1cfbd5bc9ad7761654ce09c743746" translate="yes" xml:space="preserve">
          <source>When a line is rendered, the correct format-spec is copied and scanned for the following items; data is substituted in, and other manipulations like basic indenting are done, for each opcode rendered.</source>
          <target state="translated">行がレンダリングされるときに、正しいフォーマット仕様がコピーされ、以下の項目についてスキャンされ、データが置換され、レンダリングされた各オペコードごとに基本的なインデントなどの操作が行われます。</target>
        </trans-unit>
        <trans-unit id="a843fab343a403fdde443c4b37520ec7d2e838fc" translate="yes" xml:space="preserve">
          <source>When a match has failed, and unless another verb has been involved in failing the match and has provided its own name to use, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="translated">一致が失敗した場合、別の動詞が一致の失敗に関与し、使用する独自の名前を提供していない限り、 &lt;code&gt;$REGERROR&lt;/code&gt; 変数は最後に実行された名前 &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="816633f303f39f0cbcf02a62fbc386a09fe865f3" translate="yes" xml:space="preserve">
          <source>When a match has failed, and unless another verb has been involved in failing the match and has provided its own name to use, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:NAME)&lt;/code&gt;.</source>
          <target state="translated">一致が失敗し、別の動詞が一致の失敗に関与していて、使用する独自の名前を提供していない場合、 &lt;code&gt;$REGERROR&lt;/code&gt; 変数は、最後に実行された名前 &lt;code&gt;(*MARK:NAME)&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="24e6f28f32721a0addc83e91cf8c10e71bc456ee" translate="yes" xml:space="preserve">
          <source>When a match is successful, the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; that was involved in the match.</source>
          <target state="translated">一致が成功すると、 &lt;code&gt;$REGMARK&lt;/code&gt; 変数は、一致に関与した最後に実行された名前 &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="166223375f2bf3db19459da46d44df6881e6c346" translate="yes" xml:space="preserve">
          <source>When a match is successful, the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the most recently executed &lt;code&gt;(*MARK:NAME)&lt;/code&gt; that was involved in the match.</source>
          <target state="translated">一致が成功すると、 &lt;code&gt;$REGMARK&lt;/code&gt; 変数は、一致に関与した最後に実行された &lt;code&gt;(*MARK:NAME)&lt;/code&gt; の名前に設定されます。</target>
        </trans-unit>
        <trans-unit id="4580d4e00986eec91e11abd53ea45f7e741116fe" translate="yes" xml:space="preserve">
          <source>When a module declares another one as a 'build_requires' prerequisite this means that the other module is only needed for building or testing the module but need not be installed permanently. In this case you may wish to install that other module nonetheless or just keep it in the 'build_dir' directory to have it available only temporarily. Installing saves time on future installations but makes the perl installation bigger.</source>
          <target state="translated">モジュールが他のモジュールを 'build_requires' 前提条件として宣言している場合、これは他のモジュールがモジュールのビルドやテストに必要なだけで、恒久的にインストールする必要はないということを意味します。この場合、他のモジュールをインストールするか、または 'build_dir' ディレクトリに入れて一時的に利用できるようにしておくことをお勧めします。インストールすることで今後のインストールの時間を節約できますが、 perl のインストールは大きくなります。</target>
        </trans-unit>
        <trans-unit id="1496adc7bcbe4a50d48879cef9be976a3fb2e9c5" translate="yes" xml:space="preserve">
          <source>When a new language is being encoded, Unicode generally will choose a &lt;code&gt;block&lt;/code&gt; of consecutive unallocated code points for its characters. So far, the number of code points in these blocks has always been evenly divisible by 16. Extras in a block, not currently needed, are left unallocated, for future growth. But there have been occasions when a later release needed more code points than the available extras, and a new block had to allocated somewhere else, not contiguous to the initial one, to handle the overflow. Thus, it became apparent early on that &quot;block&quot; wasn't an adequate organizing principal, and so the &lt;code&gt;Script&lt;/code&gt; property was created. (Later an improved script property was added as well, the &lt;code&gt;Script_Extensions&lt;/code&gt; property.) Those code points that are in overflow blocks can still have the same script as the original ones. The script concept fits more closely with natural language: there is &lt;code&gt;Latin&lt;/code&gt; script, &lt;code&gt;Greek&lt;/code&gt; script, and so on; and there are several artificial scripts, like &lt;code&gt;Common&lt;/code&gt; for characters that are used in multiple scripts, such as mathematical symbols. Scripts usually span varied parts of several blocks. For more information about scripts, see &lt;a href=&quot;perlunicode#Scripts&quot;&gt;Scripts in perlunicode&lt;/a&gt;. The division into blocks exists, but it is almost completely accidental--an artifact of how the characters have been and still are allocated. (Note that this paragraph has oversimplified things for the sake of this being an introduction. Unicode doesn't really encode languages, but the writing systems for them--their scripts; and one script can be used by many languages. Unicode also encodes things that aren't really about languages, such as symbols like &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt; .)</source>
          <target state="translated">新しい言語がエンコードされている場合、Unicodeは通常、その文字に対して連続した未割り当てのコードポイントの &lt;code&gt;block&lt;/code&gt; を選択します。これまでのところ、これらのブロックのコードポイントの数は常に16で割り切れるようになっています。現在必要ではないブロックのエクストラは、将来の成長のために割り当てられないままになっています。しかし、後のリリースで利用可能なエクストラよりも多くのコードポイントが必要になる場合があり、新しいブロックはオーバーフローを処理するために、最初のブロックに隣接していない別の場所に割り当てる必要がありました。したがって、「ブロック」は適切な組織化プリンシパルではないことが初期に明らかになり、 &lt;code&gt;Script&lt;/code&gt; プロパティが作成されました。 （後に、改良されたスクリプトプロパティも追加されました &lt;code&gt;Script_Extensions&lt;/code&gt; プロパティ。）オーバーフローブロック内にあるコードポイントは、元のスクリプトと同じスクリプトを持つことができます。スクリプトの概念は、自然言語とより密接に適合します。 &lt;code&gt;Latin&lt;/code&gt; スクリプト、 &lt;code&gt;Greek&lt;/code&gt; スクリプトなどがあります。また、数学記号など、複数のスクリプトで使用される文字の &lt;code&gt;Common&lt;/code&gt; など、いくつかの人工スクリプトがあります。スクリプトは通常、いくつかのブロックのさまざまな部分にまたがっています。スクリプトの詳細については&lt;a href=&quot;perlunicode#Scripts&quot;&gt;、Perlunicodeの&lt;/a&gt;スクリプトを参照してください。。ブロックへの分割は存在しますが、それはほぼ完全に偶然です-キャラクターがどのように割り当てられているかを示すアーティファクトです。 （このパラグラフは、導入のために単純化していることに注意してください。Unicodeは実際には言語をエンコードしていませんが、それらの書記体系、つまりスクリプトです。1つのスクリプトを多くの言語で使用できます。Unicodeもエンコードしますそれらは実際には言語に関するものではありません。 &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt; などの記号などです。）</target>
        </trans-unit>
        <trans-unit id="f7bd752f648e1f1f371051489dc3b8a7639c7fc7" translate="yes" xml:space="preserve">
          <source>When a new language is being encoded, Unicode generally will choose a &lt;code&gt;block&lt;/code&gt; of consecutive unallocated code points for its characters. So far, the number of code points in these blocks has always been evenly divisible by 16. Extras in a block, not currently needed, are left unallocated, for future growth. But there have been occasions when a later release needed more code points than the available extras, and a new block had to allocated somewhere else, not contiguous to the initial one, to handle the overflow. Thus, it became apparent early on that &quot;block&quot; wasn't an adequate organizing principle, and so the &lt;code&gt;Script&lt;/code&gt; property was created. (Later an improved script property was added as well, the &lt;code&gt;Script_Extensions&lt;/code&gt; property.) Those code points that are in overflow blocks can still have the same script as the original ones. The script concept fits more closely with natural language: there is &lt;code&gt;Latin&lt;/code&gt; script, &lt;code&gt;Greek&lt;/code&gt; script, and so on; and there are several artificial scripts, like &lt;code&gt;Common&lt;/code&gt; for characters that are used in multiple scripts, such as mathematical symbols. Scripts usually span varied parts of several blocks. For more information about scripts, see &lt;a href=&quot;perlunicode#Scripts&quot;&gt;&quot;Scripts&quot; in perlunicode&lt;/a&gt;. The division into blocks exists, but it is almost completely accidental--an artifact of how the characters have been and still are allocated. (Note that this paragraph has oversimplified things for the sake of this being an introduction. Unicode doesn't really encode languages, but the writing systems for them--their scripts; and one script can be used by many languages. Unicode also encodes things that aren't really about languages, such as symbols like &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt;.)</source>
          <target state="translated">新しい言語がエンコードされているとき、Unicodeは通常、その文字に連続する未割り当てのコードポイントの &lt;code&gt;block&lt;/code&gt; を選択します。これまでのところ、これらのブロック内のコードポイントの数は、常に16で割り切れます。ブロック内の余分なものは、現在は必要ありませんが、将来の拡張のために未割り当てのままになっています。ただし、後のリリースで使用可能なエクストラよりも多くのコードポイントが必要になり、オーバーフローを処理するために、新しいブロックを最初のブロックに隣接しない別の場所に割り当てる必要がある場合がありました。したがって、「ブロック」が適切な編成原則ではないことが早い段階で明らかになり、 &lt;code&gt;Script&lt;/code&gt; プロパティが作成されました。 （後で、改善されたスクリプトプロパティも追加されました &lt;code&gt;Script_Extensions&lt;/code&gt; プロパティ。）オーバーフローブロック内にあるこれらのコードポイントは、元のコードと同じスクリプトを持つことができます。スクリプトの概念は、自然言語により密接に適合しています。 &lt;code&gt;Latin&lt;/code&gt; 文字、 &lt;code&gt;Greek&lt;/code&gt; 文字などがあります。また、数学記号など、複数のスクリプトで使用される文字の &lt;code&gt;Common&lt;/code&gt; など、いくつかの人工文字があります。スクリプトは通常、いくつかのブロックのさまざまな部分にまたがっています。スクリプトの詳細について&lt;a href=&quot;perlunicode#Scripts&quot;&gt;は、perlunicodeの「スクリプト」を&lt;/a&gt;参照してください。。ブロックへの分割は存在しますが、それはほぼ完全に偶然です-キャラクターがどのように割り当てられ、現在も割り当てられているかのアーティファクトです。（この段落では、これを紹介するために物事を単純化しすぎていることに注意してください。Unicodeは実際には言語をエンコードしませんが、それらの書記体系（スクリプト）。1つのスクリプトを多くの言語で使用できます。Unicodeも物事をエンコードします。 &lt;code&gt;BAGGAGE CLAIM&lt;/code&gt; のような記号など、実際には言語に関するものではありません。）</target>
        </trans-unit>
        <trans-unit id="3bbe3c04751e10d9bc078e9c200bbf898654f3d9" translate="yes" xml:space="preserve">
          <source>When a package is compiled, a line like this</source>
          <target state="translated">パッケージをコンパイルすると、次のような行が出てきます。</target>
        </trans-unit>
        <trans-unit id="93bffad6a970da997c7854ebcbcae55a405a4802" translate="yes" xml:space="preserve">
          <source>When a perl script assigns a value to $0 then the perl runtime will try to make this value show up as the program name reported by &quot;ps&quot; by updating the memory pointed to by the argv passed to perl_parse() and also calling API functions like setproctitle() where available. This behaviour might not be appropriate when embedding perl and can be disabled by assigning the value &lt;code&gt;1&lt;/code&gt; to the variable &lt;code&gt;PL_origalen&lt;/code&gt; before perl_parse() is called.</source>
          <target state="translated">perlスクリプトが$ 0に値を割り当てると、perlランタイムは、この値が「ps」によって報告されたプログラム名として表示されるようにしようとします。これは、perl_parse（）に渡されたargvが指すメモリを更新し、次のようなAPI関数も呼び出します。利用可能な場合、setproctitle（）。この動作は、perlを埋め込む場合には適切ではない可能性があり、perl_parse（）が呼び出される前に変数 &lt;code&gt;PL_origalen&lt;/code&gt; に値 &lt;code&gt;1&lt;/code&gt; を割り当てることで無効にできます。</target>
        </trans-unit>
        <trans-unit id="5dd94d34aa40052479abfe68a7305a1776af1c6b" translate="yes" xml:space="preserve">
          <source>When a regexp can match a string in several different ways, we can use the principles above to predict which way the regexp will match:</source>
          <target state="translated">正規表現が文字列にいくつかの異なる方法でマッチする場合、上記の原則を使ってどの方法でマッチするかを予測することができます。</target>
        </trans-unit>
        <trans-unit id="5e93e818427f981a20b5cd3c2cdc058e4ee5f4c1" translate="yes" xml:space="preserve">
          <source>When a regexp is compiled, its &lt;code&gt;engine&lt;/code&gt; field is then set to point at the appropriate structure, so that when it needs to be used Perl can find the right routines to do so.</source>
          <target state="translated">正規表現がコンパイルされると、適切な構造を指すように &lt;code&gt;engine&lt;/code&gt; フィールドが設定されます。これにより、正規表現を使用する必要がある場合、Perlは適切なルーチンを見つけることができます。</target>
        </trans-unit>
        <trans-unit id="1ee520116426a3c213440cc6f7664ca3ad684e60" translate="yes" xml:space="preserve">
          <source>When a signal is delivered (e.g., SIGINT from a control-C) the operating system breaks into IO operations like</source>
          <target state="translated">信号が配信されると(例えば、制御CからのSIGINT)、オペレーティング・システムは以下のようなIO操作に切り替わります。</target>
        </trans-unit>
        <trans-unit id="232c6b5f6274d23859408b92a2808f3fc59dd734" translate="yes" xml:space="preserve">
          <source>When a space and a plus sign are given as the flags at once, a plus sign is used to prefix a positive number.</source>
          <target state="translated">フラグとしてスペースとプラス記号を一度に与えた場合、プラス記号は正の数の前に使用されます。</target>
        </trans-unit>
        <trans-unit id="545ab55cd7ca990a06b2c4cf5e80c654c6ee269f" translate="yes" xml:space="preserve">
          <source>When a space and a plus sign are given as the flags at once, the space is ignored.</source>
          <target state="translated">フラグとしてスペースとプラス記号を一度に与えた場合、スペースは無視されます。</target>
        </trans-unit>
        <trans-unit id="74001a7284f9d1373e15b508cdd1efa8fda60fc2" translate="yes" xml:space="preserve">
          <source>When a user-defined subroutine is wrapped by &lt;code&gt;autodie&lt;/code&gt;, it will use hints if they are available, and otherwise reverts to the</source>
          <target state="translated">ユーザー定義のサブルーチンが &lt;code&gt;autodie&lt;/code&gt; でラップされている場合、ヒントが利用可能な場合はヒントを使用し、それ以外の場合はヒントに戻ります。</target>
        </trans-unit>
        <trans-unit id="3497a2701b51a3e1bca0e706937a383957b3a809" translate="yes" xml:space="preserve">
          <source>When a value is returned from a thread through a &lt;code&gt;join&lt;/code&gt; operation, the value and everything that it references is copied across to the joining thread, in much the same way that values are copied upon thread creation. This works fine for most kinds of value, including arrays, hashes, and subroutines. The copying recurses through array elements, reference scalars, variables closed over by subroutines, and other kinds of reference.</source>
          <target state="translated">&lt;code&gt;join&lt;/code&gt; 操作によってスレッドから値が返されると、スレッドの作成時に値がコピーされるのとほぼ同じ方法で、値とそれが参照するすべてのものが結合スレッドにコピーされます。これは、配列、ハッシュ、サブルーチンなど、ほとんどの種類の値に対して正常に機能します。コピーは、配列要素、参照スカラー、サブルーチンによって閉じられた変数、およびその他の種類の参照を介して再帰的に行われます。</target>
        </trans-unit>
        <trans-unit id="d4c0062970171773b2800c4b96cf35e1d153d560" translate="yes" xml:space="preserve">
          <source>When a variable is tied, it is associated with the object which is the return value of the TIESCALAR, TIEARRAY, or TIEHASH function. This object normally has only one reference, namely, the implicit reference from the tied variable. When untie() is called, that reference is destroyed. Then, as in the first example above, the object's destructor (DESTROY) is called, which is normal for objects that have no more valid references; and thus the file is closed.</source>
          <target state="translated">変数が紐付けられているとき、それはTIESCALAR、TIEARRAY、またはTIEHASH関数の戻り値であるオブジェクトに関連付けられています。このオブジェクトは通常、1つの参照しか持ちません。untie()が呼び出されると、その参照は破棄されます。その後、上記の最初の例のように、オブジェクトのデストラクタ(DESTROY)が呼ばれます。これは、これ以上有効な参照を持たないオブジェクトにとっては通常のことで、ファイルは閉じられます。</target>
        </trans-unit>
        <trans-unit id="4c087ed039f3d9aacb0c9c7c411e1eafe86f0a03" translate="yes" xml:space="preserve">
          <source>When a weak reference is stored in an &lt;code&gt;SV&lt;/code&gt; that has &quot;uvar&quot; magic, &lt;code&gt;set&lt;/code&gt; magic is called after the reference has gone stale. This hook can be used to trigger further garbage-collection activities associated with the referenced object.</source>
          <target state="translated">弱参照が「uvar」マジックを持つ &lt;code&gt;SV&lt;/code&gt; に格納されている場合、参照が古くなってから &lt;code&gt;set&lt;/code&gt; magicが呼び出されます。このフックを使用して、参照されるオブジェクトに関連付けられているガベージコレクションアクティビティをさらにトリガーできます。</target>
        </trans-unit>
        <trans-unit id="9a9840147d7f095037a163c370bf370a7676a796" translate="yes" xml:space="preserve">
          <source>When all parsers are exhausted an empty list will be returned.</source>
          <target state="translated">すべてのパーサを使い切ると、空のリストが返されます。</target>
        </trans-unit>
        <trans-unit id="4475cbc9efc3f925a7d535afa9908fb989684e90" translate="yes" xml:space="preserve">
          <source>When an &quot;=over ... =back&quot; block is parsed where the items are a bulleted list, it will produce this event structure:</source>
          <target state="translated">箇条書きのリストである&quot;=over ...=back &quot;ブロックが解析されると、このようなイベント構造が生成されます。</target>
        </trans-unit>
        <trans-unit id="d07ffe1c99de4f1b7f522c65bdd9eecb591a526c" translate="yes" xml:space="preserve">
          <source>When an &quot;=over ... =back&quot; block is parsed where the items are a numbered list, it will produce this event structure:</source>
          <target state="translated">over ...=back&quot; ブロックが解析され、項目が番号付きリストである場合、このイベント構造を生成します。</target>
        </trans-unit>
        <trans-unit id="9420e774841a86eb3869701949ed03c728fe1309" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; enabled function fails, it generates an &lt;code&gt;autodie::exception&lt;/code&gt; object. This can be interrogated to determine further information about the error that occurred.</source>
          <target state="translated">とき&lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt;対応機能に障害が発生し、それが生成 &lt;code&gt;autodie::exception&lt;/code&gt; オブジェクトを。これを調べて、発生したエラーに関する詳細情報を判別できます。</target>
        </trans-unit>
        <trans-unit id="d58a9a2162a7d9db701502c02549ae6467f05b83" translate="yes" xml:space="preserve">
          <source>When an array or an array slice is interpolated into a double-quoted string or a similar context such as &lt;code&gt;/.../&lt;/code&gt; , its elements are separated by this value. Default is a space. For example, this:</source>
          <target state="translated">配列または配列スライスが二重引用符で囲まれた文字列または &lt;code&gt;/.../&lt;/code&gt; などの同様のコンテキストに補間される場合、その要素はこの値で区切られます。デフォルトはスペースです。たとえば、これ：</target>
        </trans-unit>
        <trans-unit id="1cef7d16c561803c2f66d1c8d9b2d86bf2638f56" translate="yes" xml:space="preserve">
          <source>When an array or an array slice is interpolated into a double-quoted string or a similar context such as &lt;code&gt;/.../&lt;/code&gt;, its elements are separated by this value. Default is a space. For example, this:</source>
          <target state="translated">配列または配列スライスが二重引用符で囲まれた文字列または &lt;code&gt;/.../&lt;/code&gt; などの同様のコンテキストに補間される場合、その要素はこの値で区切られます。デフォルトはスペースです。たとえば、これは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="0ada78738410600725bc97a1fe2d577a540f0ef9" translate="yes" xml:space="preserve">
          <source>When an attribute list is present in a declaration, a check is made to see whether an attribute 'modify' handler is present in the appropriate package (or its @ISA inheritance tree). Similarly, when &lt;code&gt;attributes::get&lt;/code&gt; is called on a valid reference, a check is made for an appropriate attribute 'fetch' handler. See &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;EXAMPLES&quot;&lt;/a&gt; to see how the &quot;appropriate package&quot; determination works.</source>
          <target state="translated">属性リストが宣言に存在する場合、属性 'modify'ハンドラーが適切なパッケージ（またはその@ISA継承ツリー）に存在するかどうかを確認するためのチェックが行われます。同様に、 &lt;code&gt;attributes::get&lt;/code&gt; が有効な参照で呼び出されると、適切な属性 'fetch'ハンドラーがチェックされます。参照してください&lt;a href=&quot;#EXAMPLES&quot;&gt;「例」&lt;/a&gt;どのように「適切なパッケージ」決意の作品を見ることを。</target>
        </trans-unit>
        <trans-unit id="e576a7aca6fc0d7ad26c29db1ef25b646d312e24" translate="yes" xml:space="preserve">
          <source>When an attribute list is present in a declaration, a check is made to see whether an attribute 'modify' handler is present in the appropriate package (or its @ISA inheritance tree). Similarly, when &lt;code&gt;attributes::get&lt;/code&gt; is called on a valid reference, a check is made for an appropriate attribute 'fetch' handler. See &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; to see how the &quot;appropriate package&quot; determination works.</source>
          <target state="translated">属性リストが宣言に存在する場合、属性の「変更」ハンドラーが適切なパッケージ（またはその@ISA継承ツリー）に存在するかどうかを確認するためのチェックが行われます。同様に、 &lt;code&gt;attributes::get&lt;/code&gt; が有効な参照で呼び出されると、適切な属性の「フェッチ」ハンドラーがチェックされます。参照&lt;a href=&quot;#EXAMPLES&quot;&gt;使用例を&lt;/a&gt;「適切なパッケージ」決意がどのように動作するかを確認するために。</target>
        </trans-unit>
        <trans-unit id="8cddb5e14177fc6acd8b55e0252f21e912b7951c" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is read, the locations to which</source>
          <target state="translated">&lt;code&gt;%ENV&lt;/code&gt; の要素が読み取られると、</target>
        </trans-unit>
        <trans-unit id="0687a40bbb86ac6f75e3c72f51434b562de688d3" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, the element is looked up as if it were being read, and if it is found, it is deleted. (An item &quot;deleted&quot; from the CRTL &lt;code&gt;environ&lt;/code&gt; array is set to the empty string.) Using &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; to remove an element from &lt;code&gt;%ENV&lt;/code&gt; has a similar effect, but after the element is deleted, another attempt is made to look up the element, so an inner-mode logical name or a name in another location will replace the logical name just deleted. In either case, only the first value found searching PERL_ENV_TABLES is altered. It is not possible at present to define a search list logical name via %ENV.</source>
          <target state="translated">要素場合 &lt;code&gt;%ENV&lt;/code&gt; がに設定されている &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を、それが読まれているし、それが見つかった場合、それが削除されるかのように、要素が検索されます。 （CRTL &lt;code&gt;environ&lt;/code&gt; 配列から「削除された」項目は空の文字列に設定されます。） &lt;code&gt;%ENV&lt;/code&gt; から要素を &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; するために削除を使用すると同様の効果がありますが、要素が削除された後、要素を検索する別の試みが行われます。したがって、内部モードの論理名または別の場所の名前は、削除されたばかりの論理名を置き換えます。どちらの場合も、PERL_ENV_TABLESの検索で見つかった最初の値のみが変更されます。現在のところ、％ENVを使用して検索リストの論理名を定義することはできません。</target>
        </trans-unit>
        <trans-unit id="0c072f9ffbeb43d95b6bbc690c50b27ac90e561f" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is set to &lt;code&gt;undef&lt;/code&gt;, the element is looked up as if it were being read, and if it is found, it is deleted. (An item &quot;deleted&quot; from the CRTL &lt;code&gt;environ&lt;/code&gt; array is set to the empty string.) Using &lt;code&gt;delete&lt;/code&gt; to remove an element from &lt;code&gt;%ENV&lt;/code&gt; has a similar effect, but after the element is deleted, another attempt is made to look up the element, so an inner-mode logical name or a name in another location will replace the logical name just deleted. In either case, only the first value found searching PERL_ENV_TABLES is altered. It is not possible at present to define a search list logical name via %ENV.</source>
          <target state="translated">要素場合 &lt;code&gt;%ENV&lt;/code&gt; がに設定されている &lt;code&gt;undef&lt;/code&gt; を、それが読まれているし、それが見つかった場合、それが削除されるかのように、要素が検索されます。 （CRTL &lt;code&gt;environ&lt;/code&gt; 配列から「削除された」項目は空の文字列に設定されます。） &lt;code&gt;delete&lt;/code&gt; を使用して &lt;code&gt;%ENV&lt;/code&gt; から要素を削除しても同様の効果がありますが、要素が削除された後、別の試みで要素が検索されます。したがって、内部モードの論理名または別の場所の名前が、削除されたばかりの論理名に置き換わります。いずれの場合も、PERL_ENV_TABLESを検索して最初に見つかった値のみが変更されます。現在、％ENVを介して検索リストの論理名を定義することはできません。</target>
        </trans-unit>
        <trans-unit id="f3d5e830d380d586cadba3ebb3b0b5993def5162" translate="yes" xml:space="preserve">
          <source>When an element of &lt;code&gt;%ENV&lt;/code&gt; is set to a defined string, the corresponding definition is made in the location to which the first translation of</source>
          <target state="translated">&lt;code&gt;%ENV&lt;/code&gt; の要素が定義済みの文字列に設定されている場合、対応する定義は最初の翻訳先の場所で行われます。</target>
        </trans-unit>
        <trans-unit id="6e4667405eb0016e589d7ee3b3978551b835b138" translate="yes" xml:space="preserve">
          <source>When an install fails for some reason and then I correct the error condition and retry, CPAN.pm refuses to install the module, saying &lt;code&gt;Already tried without success&lt;/code&gt; .</source>
          <target state="translated">何らかの理由でインストールが失敗した後、エラー条件を修正して再試行すると、CPAN.pmはモジュールのインストールを拒否し、「 &lt;code&gt;Already tried without success&lt;/code&gt; 」と言いました。</target>
        </trans-unit>
        <trans-unit id="88b449cc559ca252d850238032174c7042fa310e" translate="yes" xml:space="preserve">
          <source>When an undefined layer 'foo' is encountered in an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; layer specification then C code performs the equivalent of:</source>
          <target state="translated">未定義のレイヤー「foo」が &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; レイヤー仕様で見つかった場合、Cコードは以下と同等の機能を実行します。</target>
        </trans-unit>
        <trans-unit id="40fb6d5dfd2c6aa613f88a6e49dba73d8dca4cc3" translate="yes" xml:space="preserve">
          <source>When an undefined layer 'foo' is encountered in an &lt;code&gt;open&lt;/code&gt; or &lt;code&gt;binmode&lt;/code&gt; layer specification then C code performs the equivalent of:</source>
          <target state="translated">未定義のレイヤー 'foo'が &lt;code&gt;open&lt;/code&gt; または &lt;code&gt;binmode&lt;/code&gt; レイヤー仕様で検出されると、Cコードは次と同等のことを実行します。</target>
        </trans-unit>
        <trans-unit id="05eb98d8070a762d6a7fd65d464d57e96f47f0ef" translate="yes" xml:space="preserve">
          <source>When an updir path like &quot;:::lib::&quot; is passed as argument, the number of directories to climb up is handled correctly, not removing leading or trailing colons when necessary. E.g.</source>
          <target state="translated">&quot;:::lib::&quot;のようなupdirパスが引数として渡された場合、必要に応じて先頭や末尾のコロンを削除することなく、登ってくるディレクトリの数が正しく処理されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="fc030f96c1c92f54f8dacedeb177bdbc127fdac6" translate="yes" xml:space="preserve">
          <source>When an uppercase and lowercase letter both exist in the table, then the uppercase letter is typically used to represent some kind of composite type (a list or a hash), and the lowercase letter is used to represent an element of that composite type. Some internals code makes use of this case relationship. However, 'v' and 'V' (vec and v-string) are in no way related.</source>
          <target state="translated">大文字と小文字の両方がテーブルに存在する場合、大文字は通常何らかの複合型(リストやハッシュ)を表すために使用され、小文字はその複合型の要素を表すために使用されます。内部コードの中には、この大文字と小文字の関係を利用しているものがあります。しかし、'v' と 'V' (vec と v-string)は関係がありません。</target>
        </trans-unit>
        <trans-unit id="34009ee0cae148f2a1680a702fb847661476a204" translate="yes" xml:space="preserve">
          <source>When and whether to use small caps is somewhat tricky, and Pod::Man doesn't necessarily get it right.</source>
          <target state="translated">スモールキャップを使うタイミングと使うかどうかはややトリッキーで、Pod::Manが必ずしも正しいとは限りません。</target>
        </trans-unit>
        <trans-unit id="50a0e6b3c1e9721563cfa37763282c6acaf8fe8f" translate="yes" xml:space="preserve">
          <source>When applied to the following command line:</source>
          <target state="translated">以下のコマンドラインに適用した場合</target>
        </trans-unit>
        <trans-unit id="a01d1e59657f16ebb14cc78dbc769393ad07bd40" translate="yes" xml:space="preserve">
          <source>When auto-detecting the compressed format, try to test for lzma_alone content using the &lt;code&gt;IO::Uncompress::UnLzma&lt;/code&gt; module.</source>
          <target state="translated">圧縮形式を自動検出する場合は、 &lt;code&gt;IO::Uncompress::UnLzma&lt;/code&gt; モジュールを使用してlzma_aloneコンテンツをテストしてください。</target>
        </trans-unit>
        <trans-unit id="3afc2592b2e6769a24dccd537ec52009da2c39f6" translate="yes" xml:space="preserve">
          <source>When auto-detecting the compressed format, try to test for raw-deflate (RFC 1951) content using the &lt;code&gt;IO::Uncompress::RawInflate&lt;/code&gt; module.</source>
          <target state="translated">圧縮形式を自動検出する場合は、 &lt;code&gt;IO::Uncompress::RawInflate&lt;/code&gt; モジュールを使用してraw-deflate（RFC 1951）コンテンツをテストしてください。</target>
        </trans-unit>
        <trans-unit id="9c2cde96752e55bde69311a35423f2dcc59f8d7b" translate="yes" xml:space="preserve">
          <source>When automatic selection of the nearest cpan mirrors is performed, this option can be used to turn on verbosity during the selection process.</source>
          <target state="translated">最も近い cpan ミラーの自動選択を行う場合、このオプションを使用して、選択処理中に冗長性をオンにすることができます。</target>
        </trans-unit>
        <trans-unit id="6884ba24d0a86a83e3adb2e1fb93cb3394961f06" translate="yes" xml:space="preserve">
          <source>When automatic selection of the nearest cpan mirrors is performed, turn on the use of the external ping via Net::Ping::External. This is recommended in the case the local network has a transparent proxy.</source>
          <target state="translated">最も近い cpan ミラーの自動選択を行う場合は、Net::Ping::External 経由の外部 ping の利用をオンにしてください。これは、ローカルネットワークに透過型プロキシがある場合に推奨されます。</target>
        </trans-unit>
        <trans-unit id="22fe69040aadcae108c71d87a32f8d5b0102ff6a" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;'^'&lt;/code&gt; and &lt;code&gt;'$'&lt;/code&gt; are used at the same time, the regexp has to match both the beginning and the end of the string,</source>
          <target state="translated">両方の場合は &lt;code&gt;'^'&lt;/code&gt; と &lt;code&gt;'$'&lt;/code&gt; 同時に使用され、正規表現は文字列の先頭と末尾の両方に一致する必要があり、</target>
        </trans-unit>
        <trans-unit id="11c4b6b6311800f4181591dd698a41134ea1ef8b" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; are used at the same time, the regexp has to match both the beginning and the end of the string, i.e., the regexp matches the whole string. Consider</source>
          <target state="translated">&lt;code&gt;^&lt;/code&gt; と &lt;code&gt;$&lt;/code&gt; の両方を同時に使用する場合、正規表現は文字列の最初と最後の両方に一致する必要があります。つまり、正規表現は文字列全体に一致します。検討する</target>
        </trans-unit>
        <trans-unit id="0058d0939f56e0836aecac00731cc26dae5c908c" translate="yes" xml:space="preserve">
          <source>When both A and P are undefined, this is used as a fallback accuracy when dividing numbers.</source>
          <target state="translated">AとPの両方が未定義の場合、これは数を割る際の予備精度として使用されます。</target>
        </trans-unit>
        <trans-unit id="060766cfa822ddf97bd7bc65f3fc7e729b274423" translate="yes" xml:space="preserve">
          <source>When building 64-bit modules, it is your responsibility to ensure that linked external libraries and frameworks provide 64-bit support: if they do not, module building may appear to succeed, but attempts to use the module will result in run-time dynamic linking errors, and subsequent test failures. You can use &lt;code&gt;file&lt;/code&gt; to discover the architectures supported by a library:</source>
          <target state="translated">64ビットモジュールをビルドする場合、リンクされた外部ライブラリとフレームワークが64ビットサポートを提供することを確認する必要があります。サポートされていない場合、モジュールのビルドは成功したように見えますが、モジュールを使用しようとするとランタイムダイナミックになりますリンクエラー、およびそれに続くテストの失敗。 &lt;code&gt;file&lt;/code&gt; を使用して、ライブラリでサポートされているアーキテクチャを検出できます。</target>
        </trans-unit>
        <trans-unit id="d21008e482052b445cfd243ad8bc31adfd3249b5" translate="yes" xml:space="preserve">
          <source>When building Perl it will always return true, as nothing is installed yet.</source>
          <target state="translated">Perlをビルドする際には、まだ何もインストールされていないので、常にtrueを返します。</target>
        </trans-unit>
        <trans-unit id="aaf49b07a212f715b8dd8f309b5c78af1bf1e342" translate="yes" xml:space="preserve">
          <source>When built on an ODS-5 volume with symbolic links enabled, Perl by default supports symbolic links when the requisite support is available in the filesystem and CRTL (generally 64-bit OpenVMS v8.3 and later). There are a number of limitations and caveats to be aware of when working with symbolic links on VMS. Most notably, the target of a valid symbolic link must be expressed as a Unix-style path and it must exist on a volume visible from your POSIX root (see the &lt;code&gt;SHOW ROOT&lt;/code&gt; command in DCL help). For further details on symbolic link capabilities and requirements, see chapter 12 of the CRTL manual that ships with OpenVMS v8.3 or later.</source>
          <target state="translated">シンボリックリンクが有効になっているODS-5ボリューム上に構築された場合、Perlは必要なサポートがファイルシステムとCRTL（通常64ビットOpenVMS v8.3以降）で利用可能な場合、デフォルトでシンボリックリンクをサポートします。VMSでシンボリックリンクを使用する場合に注意する必要がある制限と注意事項がいくつかあります。特に、有効なシンボリックリンクのターゲットは、Unixスタイルのパスとして表現する必要があり、POSIXルートから見えるボリュームに存在する必要があります（DCLヘルプの &lt;code&gt;SHOW ROOT&lt;/code&gt; コマンドを参照）。シンボリックリンクの機能と要件の詳細については、OpenVMS v8.3以降に付属のCRTLマニュアルの第12章を参照してください。</target>
        </trans-unit>
        <trans-unit id="3274ae41eb972b48380cd0be38746ee76dc6d9df" translate="yes" xml:space="preserve">
          <source>When bundling is in effect, case is ignored on single-character options also.</source>
          <target state="translated">バンドルが有効な場合、1文字オプションでも大文字小文字は無視されます。</target>
        </trans-unit>
        <trans-unit id="534230020f5629c55b27da34563c08514a84a5c7" translate="yes" xml:space="preserve">
          <source>When calculating specific times, such as for tests in time or date modules, it may be appropriate to calculate an offset for the epoch.</source>
          <target state="translated">時間モジュールや日付モジュールのテストのように、特定の時間を計算するときは、エポックのオフセットを計算するのが適切かもしれません。</target>
        </trans-unit>
        <trans-unit id="9da2af35b4e027fcb57324a97e158a9219d7749d" translate="yes" xml:space="preserve">
          <source>When called from a thread, this behaves like &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; (i.e., the exit status code is ignored).</source>
          <target state="translated">スレッドから呼び出されると、これは &lt;code&gt;threads-&amp;gt;exit()&lt;/code&gt; のように動作します（つまり、終了ステータスコードは無視されます）。</target>
        </trans-unit>
        <trans-unit id="9c8531e379ee34158f961b216941a888acd13144" translate="yes" xml:space="preserve">
          <source>When called from the</source>
          <target state="translated">から呼び出された場合</target>
        </trans-unit>
        <trans-unit id="43350391a792d394d51fbfdf3323ff9bf611b150" translate="yes" xml:space="preserve">
          <source>When called in a scalar context &lt;code&gt;strtod&lt;/code&gt; returns the parsed number.</source>
          <target state="translated">スカラーコンテキストで呼び出されると、 &lt;code&gt;strtod&lt;/code&gt; は解析された数値を返します。</target>
        </trans-unit>
        <trans-unit id="da1211ed8e0b63c4bc2cdd7832083442b210dfa8" translate="yes" xml:space="preserve">
          <source>When called in a scalar context &lt;code&gt;strtol&lt;/code&gt; returns the parsed number.</source>
          <target state="translated">スカラーコンテキストで呼び出されると、 &lt;code&gt;strtol&lt;/code&gt; は解析された数値を返します。</target>
        </trans-unit>
        <trans-unit id="cd23c4a922c775b095b3cd879f0e839934775a17" translate="yes" xml:space="preserve">
          <source>When called in list context, a filehandle to the open file and a filename are returned. This is achieved by calling mkstemp() after constructing a suitable template.</source>
          <target state="translated">リストコンテキストで呼び出されると、開いているファイルへのファイルハンドルとファイル名が返されます。これは適切なテンプレートを構築した後に mkstemp()を呼び出すことで実現されます。</target>
        </trans-unit>
        <trans-unit id="c3dee4680a21f3b47b4b6c94d86c7920c11b3ca5" translate="yes" xml:space="preserve">
          <source>When called in scalar context, returns the full name (including path) of a temporary file (uses mktemp()). The only check is that the file does not already exist, but there is no guarantee that that condition will continue to apply.</source>
          <target state="translated">スカラコンテキストで呼び出されると、一時ファイルのフルネーム(パスを含む)を返します(mktemp()を使用します)。唯一のチェックは、そのファイルが既に存在していないかどうかということですが、その条件が適用され続ける保証はありません。</target>
        </trans-unit>
        <trans-unit id="a89727e96b1fd47a54daec87adf9ead3599db8aa" translate="yes" xml:space="preserve">
          <source>When called on a hash in list context, returns a 2-element list consisting of the key and value for the next element of a hash. In Perl 5.12 and later only, it will also return the index and value for the next element of an array so that you can iterate over it; older Perls consider this a syntax error. When called in scalar context, returns only the key (not the value) in a hash, or the index in an array.</source>
          <target state="translated">リストコンテキストでハッシュに対して呼び出された場合、 ハッシュの次の要素のキーと値からなる2つの要素のリストを返します。Perl 5.12以降では、配列の次の要素のインデックスと値も返します。スカラコンテキストで呼び出された場合、ハッシュのキー(値ではなく)か配列のインデックスのみを返します。</target>
        </trans-unit>
        <trans-unit id="a0114581d0437322ee0322acd573e8db3818a675" translate="yes" xml:space="preserve">
          <source>When called with a port number, the port number used to ping is set to $port_number rather than using the echo port. It also has the effect of calling &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; causing a ping to return a successful response only if that specific port is accessible. This function returns the value of the port that &lt;code&gt;ping()&lt;/code&gt; will connect to.</source>
          <target state="translated">ポート番号を指定して呼び出されると、pingに使用されるポート番号は、エコーポートを使用するのではなく、$ port_numberに設定されます。また、 &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; を呼び出して、特定のポートにアクセスできる場合にのみpingが正常な応答を返すようにする効果もあります。この関数は、 &lt;code&gt;ping()&lt;/code&gt; が接続するポートの値を返します。</target>
        </trans-unit>
        <trans-unit id="bb2e5aa5eca539163667dc50950bd9be7faf4a0e" translate="yes" xml:space="preserve">
          <source>When called with a port number, the port number used to ping is set to &lt;code&gt;$port_number&lt;/code&gt; rather than using the echo port. It also has the effect of calling &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; causing a ping to return a successful response only if that specific port is accessible. This function returns the value of the port that &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; will connect to.</source>
          <target state="translated">ポート番号で呼び出された場合、pingに使用されるポート番号は、エコーポートを使用するのではなく、 &lt;code&gt;$port_number&lt;/code&gt; 設定されます。また、 &lt;code&gt;$p-&amp;gt;service_check(1)&lt;/code&gt; を呼び出すと、その特定のポートにアクセスできる場合にのみpingが正常な応答を返すようになります。この関数は、&lt;a href=&quot;#ping&quot;&gt;「ping」&lt;/a&gt;が接続するポートの値を返します。</target>
        </trans-unit>
        <trans-unit id="f7e732b0f6b3939ab5bc51276cb4115c5f3c0e3c" translate="yes" xml:space="preserve">
          <source>When called with a property that is a Perl extension that isn't expressible in a compound form, this function currently returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, as the only two possible values are</source>
          <target state="translated">複合形式で表現できないPerl拡張であるプロパティで呼び出されると、この関数は現在、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="2e2733df3349090a28007f289ac824ddf07cc93b" translate="yes" xml:space="preserve">
          <source>When called with a property that is a Perl extension that isn't expressible in a compound form, this function currently returns &lt;code&gt;undef&lt;/code&gt;, as the only two possible values are</source>
          <target state="translated">複合形式で表現できないPerl拡張機能であるプロパティを使用して呼び出された場合、この関数は現在 &lt;code&gt;undef&lt;/code&gt; を返します。これは、可能な値が2つしかないためです。</target>
        </trans-unit>
        <trans-unit id="d7f088f6cc700d00236d5621c430de681ccc4d48" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;Mksymlists&lt;/code&gt; , one should always specify the NAME attribute. In most cases, this is all that's necessary. In the case of unusual extensions, however, the other attributes can be used to provide additional information to the linker.</source>
          <target state="translated">&lt;code&gt;Mksymlists&lt;/code&gt; を呼び出すときは、常にNAME属性を指定する必要があります。ほとんどの場合、これで十分です。ただし、通常とは異なる拡張機能の場合、他の属性を使用して、リンカーに追加情報を提供できます。</target>
        </trans-unit>
        <trans-unit id="07b982cff05e80c95f9bd4378e83247343baa2a1" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;Mksymlists&lt;/code&gt;, one should always specify the NAME attribute. In most cases, this is all that's necessary. In the case of unusual extensions, however, the other attributes can be used to provide additional information to the linker.</source>
          <target state="translated">&lt;code&gt;Mksymlists&lt;/code&gt; を呼び出すときは、常にNAME属性を指定する必要があります。ほとんどの場合、必要なのはこれだけです。ただし、異常な拡張機能の場合は、他の属性を使用してリンカーに追加情報を提供できます。</target>
        </trans-unit>
        <trans-unit id="af437b4f9240cadad3ac33b8f68ddc8397121022" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;open&lt;/code&gt; with three or more arguments, the second argument -- labeled MODE here -- defines the</source>
          <target state="translated">3つ以上の引数を指定して &lt;code&gt;open&lt;/code&gt; を呼び出す場合、2番目の引数（ここではMODEとラベル付けされています）は、</target>
        </trans-unit>
        <trans-unit id="fb764d0e74f6cde0aeec88532fcd886bfa4b9853" translate="yes" xml:space="preserve">
          <source>When choosing a language you should also be influenced by the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;resources&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpantesters.org%2f&quot;&gt;testing culture&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fcommunity.html&quot;&gt;community&lt;/a&gt; which surrounds it.</source>
          <target state="translated">言語を選択するときは、その言語を取り巻く&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org%2f&quot;&gt;リソース&lt;/a&gt;、&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpantesters.org%2f&quot;&gt;テスト文化&lt;/a&gt;、&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fcommunity.html&quot;&gt;コミュニティに&lt;/a&gt;も影響を受けるはずです。</target>
        </trans-unit>
        <trans-unit id="951b540f9fcad327b03714e446667ac4225ce0b0" translate="yes" xml:space="preserve">
          <source>When choosing a language you should also be influenced by the &lt;a href=&quot;http://www.cpan.org/&quot;&gt;resources&lt;/a&gt;, &lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;testing culture&lt;/a&gt; and &lt;a href=&quot;http://www.perl.org/community.html&quot;&gt;community&lt;/a&gt; which surrounds it.</source>
          <target state="translated">言語を選択するときは、&lt;a href=&quot;http://www.cpan.org/&quot;&gt;リソース&lt;/a&gt;、&lt;a href=&quot;http://www.cpantesters.org/&quot;&gt;テスト文化&lt;/a&gt;、およびそれを取り巻く&lt;a href=&quot;http://www.perl.org/community.html&quot;&gt;コミュニティに&lt;/a&gt;も影響を受ける必要があります。</target>
        </trans-unit>
        <trans-unit id="28fc2ee6241766189106d0612895f0d6c35cb4ac" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; accepts.</source>
          <target state="translated">新しいソルトを選択するとき、文字がセット &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; に由来するランダムな2文字の文字列を作成します（ &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt; '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ）。この文字セットは単なる推奨です。 saltで許可される文字はシステムのcryptライブラリにのみ依存し、Perlはsalt &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; が受け入れるものを制限できません。</target>
        </trans-unit>
        <trans-unit id="8df52c6dbe1d57b617631599c530a100984708ce" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt; '', ('.',
'/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; accepts.</source>
          <target state="translated">新しいソルトを選択するとき、文字がセット &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; に由来するランダムな2文字の文字列を作成します（ &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt; '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64, &lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt; 64]&lt;/code&gt; ）。この文字セットは単なる推奨です。 saltで許可される文字はシステムのcryptライブラリにのみ依存し、Perlはsalt &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt()&lt;/a&gt;&lt;/code&gt; が受け入れるものを制限できません。</target>
        </trans-unit>
        <trans-unit id="e49bb7c565d73664ea0f3cf904e4a0b82673adbe" translate="yes" xml:space="preserve">
          <source>When choosing a new salt create a random two character string whose characters come from the set &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; (like &lt;code&gt;join '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]&lt;/code&gt;). This set of characters is just a recommendation; the characters allowed in the salt depend solely on your system's crypt library, and Perl can't restrict what salts &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; accepts.</source>
          <target state="translated">新しいソルトを選択するときは、文字列がセット &lt;code&gt;[./0-9A-Za-z]&lt;/code&gt; からのものであるランダムな2文字の文字列を作成します（ &lt;code&gt;join '', ('.', '/', 0..9, 'A'..'Z', 'a'..'z')[rand 64, rand 64]&lt;/code&gt; ）。この文字セットは単なる推奨事項です。saltで許可される文字は、システムのcryptライブラリにのみ依存し、Perlは&lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt; &lt;code&gt;crypt&lt;/code&gt; が&lt;/a&gt;受け入れる塩を制限できません。</target>
        </trans-unit>
        <trans-unit id="e45013cd9275f891a2dc688887309ce7d0907108" translate="yes" xml:space="preserve">
          <source>When combined with variable declaration, simple assignment to &lt;code&gt;state&lt;/code&gt; variables (as in &lt;code&gt;state $x = 42&lt;/code&gt;) is executed only the first time. When such statements are evaluated subsequent times, the assignment is ignored. The behavior of assignment to &lt;code&gt;state&lt;/code&gt; declarations where the left hand side of the assignment involves any parentheses is currently undefined.</source>
          <target state="translated">変数宣言と組み合わせると、 &lt;code&gt;state&lt;/code&gt; 変数への単純な割り当て（ &lt;code&gt;state $x = 42&lt;/code&gt; ）は最初にのみ実行されます。このようなステートメントが後で評価される場合、割り当ては無視されます。割り当ての左側に括弧が含まれる &lt;code&gt;state&lt;/code&gt; 宣言への割り当ての動作は、現在定義されていません。</target>
        </trans-unit>
        <trans-unit id="ba90a2d042a133e843c0ea1363bae85f48e8fd9f" translate="yes" xml:space="preserve">
          <source>When combined with variable declaration, simple scalar assignment to &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables (as in &lt;code&gt;state $x = 42&lt;/code&gt; ) is executed only the first time. When such statements are evaluated subsequent times, the assignment is ignored. The behavior of this sort of assignment to non-scalar variables is undefined.</source>
          <target state="translated">変数宣言と組み合わせると、 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 変数への単純なスカラー割り当て（ &lt;code&gt;state $x = 42&lt;/code&gt; ）が初めて実行されます。そのようなステートメントがその後評価されるとき、割り当ては無視されます。この種の非スカラー変数への割り当ての動作は未定義です。</target>
        </trans-unit>
        <trans-unit id="8723e913d037ae6e1a9af1f510a75733eba10e88" translate="yes" xml:space="preserve">
          <source>When comparing &lt;code&gt;$]&lt;/code&gt; , string comparison operators are &lt;b&gt;highly recommended&lt;/b&gt;. The inherent limitations of binary floating point representation can sometimes lead to incorrect comparisons for some numbers on some architectures.</source>
          <target state="translated">&lt;code&gt;$]&lt;/code&gt; を比較するときは、文字列比較演算子を使用することを&lt;b&gt;強くお勧めし&lt;/b&gt;ます。2進浮動小数点表現の固有の制限により、一部のアーキテクチャーでは、一部の数値の比較が不正確になる場合があります。</target>
        </trans-unit>
        <trans-unit id="d63ec10981e83d5b4bca0c38c0d5eae2039c39d3" translate="yes" xml:space="preserve">
          <source>When comparing &lt;code&gt;$]&lt;/code&gt;, numeric comparison operators should be used, but the variable should be stringified first to avoid issues where its original numeric value is inaccurate.</source>
          <target state="translated">&lt;code&gt;$]&lt;/code&gt; を比較するときは、数値比較演算子を使用する必要がありますが、元の数値が不正確であるという問題を回避するために、変数を最初に文字列化する必要があります。</target>
        </trans-unit>
        <trans-unit id="65db1f7efa45a9d6174eb5b40e9d8d8f3e843e34" translate="yes" xml:space="preserve">
          <source>When compiled within the scope of &lt;code&gt;use locale&lt;/code&gt; (or the &lt;code&gt;/l&lt;/code&gt; regex modifier), this construct assumes that the execution-time locale will be a UTF-8 one, and the generated pattern always uses Unicode rules. What gets matched or not thus isn't dependent on the actual runtime locale, so tainting is not enabled. But a &lt;code&gt;locale&lt;/code&gt; category warning is raised if the runtime locale turns out to not be UTF-8.</source>
          <target state="translated">&lt;code&gt;use locale&lt;/code&gt; （または &lt;code&gt;/l&lt;/code&gt; 正規表現修飾子）の範囲内でコンパイルされる場合、この構成は実行時ロケールがUTF-8ロケールであると想定し、生成されたパターンは常にUnicodeルールを使用します。したがって、一致するかどうかは実際のランタイムロケールに依存しないため、汚染は有効になりません。ただし、ランタイムロケールがUTF-8でないことが判明した場合、 &lt;code&gt;locale&lt;/code&gt; カテゴリの警告が発生します。</target>
        </trans-unit>
        <trans-unit id="9cb0233568f5abd1d88fb8340be5337623b26d31" translate="yes" xml:space="preserve">
          <source>When compiling Perl in Tru64 you may (depending on the compiler release) see two warnings like this</source>
          <target state="translated">Tru64 で Perl をコンパイルすると、(コンパイラのリリースによっては)以下のような 2 つの警告が表示されることがあります。</target>
        </trans-unit>
        <trans-unit id="bfc6666c4c5744908a4efd082506a76f331670ff" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. AIX does not ship an ANSI compliant C compiler with AIX by default, but binary builds of gcc for AIX are widely available. A version of gcc is also included in the AIX Toolbox which is shipped with AIX.</source>
          <target state="translated">Perlをコンパイルする際には、ANSI Cコンパイラを使用する必要があります。AIX には ANSI 準拠の C コンパイラはデフォルトでは同梱されていませんが、AIX 用の gcc のバイナリビルドは広く利用可能です。gcc のバージョンは AIX に同梱されている AIX Toolbox にも含まれています。</target>
        </trans-unit>
        <trans-unit id="f65988610c7d74b5ae9b07dd95c21b84e89fdc66" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. AIX does not ship an ANSI compliant C-compiler with AIX by default, but binary builds of gcc for AIX are widely available.</source>
          <target state="translated">Perlをコンパイルする際には、ANSI Cコンパイラを使用する必要があります。AIX には ANSI 準拠の C コンパイラはデフォルトでは搭載されていませんが、AIX 用の gcc のバイナリビルドは広く利用可能です。</target>
        </trans-unit>
        <trans-unit id="e54d0f630f4052fa4f5e8949b94bd1a858274b61" translate="yes" xml:space="preserve">
          <source>When compiling Perl, you must use an ANSI C compiler. The C compiler that ships with all HP-UX systems is a K&amp;amp;R compiler that should only be used to build new kernels.</source>
          <target state="translated">Perlをコンパイルするときは、ANSI Cコンパイラを使用する必要があります。すべてのHP-UXシステムに同梱されているCコンパイラはK＆Rコンパイラであり、新しいカーネルの構築にのみ使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="396066667b73652500c61d9a6b382668c31190fa" translate="yes" xml:space="preserve">
          <source>When compiling in PASE, there is no &quot;oslevel&quot; command. Therefore, you may want to create a script called &quot;oslevel&quot; that echoes the level of AIX that your version of PASE runtime supports. If you're unsure, consult your documentation or use &quot;4.3.3.0&quot;.</source>
          <target state="translated">PASEでコンパイルする場合、&quot;oslevel &quot;コマンドはありません。そのため、あなたのバージョンの PASE ランタイムがサポートしている AIX のレベルをエコーする &quot;oslevel&quot; というスクリプトを作成するとよいでしょう。よくわからない場合は、ドキュメントを参照するか、&quot;4.3.3.3.0 &quot;を使用してください。</target>
        </trans-unit>
        <trans-unit id="975dca0ce3b92270da7ce263ccd6670142595f91" translate="yes" xml:space="preserve">
          <source>When complementing strings, if all characters have ordinal values under 256, then their complements will, also. But if they do not, all characters will be in either 32- or 64-bit complements, depending on your architecture. So for example, &lt;code&gt;~&quot;\x{3B1}&quot;&lt;/code&gt; is &lt;code&gt;&quot;\x{FFFF_FC4E}&quot;&lt;/code&gt; on 32-bit machines and &lt;code&gt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&lt;/code&gt; on 64-bit machines.</source>
          <target state="translated">文字列を補完するとき、すべての文字に256未満の序数値がある場合、それらの補完も同様です。ただし、そうでない場合は、アーキテクチャに応じて、すべての文字が32ビットまたは64ビットの補数になります。そう例えば、 &lt;code&gt;~&quot;\x{3B1}&quot;&lt;/code&gt; である &lt;code&gt;&quot;\x{FFFF_FC4E}&quot;&lt;/code&gt; 32ビットマシンとに &lt;code&gt;&quot;\x{FFFF_FFFF_FFFF_FC4E}&quot;&lt;/code&gt; 64ビットマシン。</target>
        </trans-unit>
        <trans-unit id="927dc05b306a20a322eed6c8168ca784ea3ed41b" translate="yes" xml:space="preserve">
          <source>When configured for bundling, single-character options are matched case sensitive while long options are matched case insensitive. To have the single-character options matched case insensitive as well, use:</source>
          <target state="translated">バンドル用に構成されている場合、1 文字のオプションは大文字と小文字が区別されますが、長いオプションは大文字と小文字が区別されません。一文字のオプションも大文字小文字を区別せずに一致させるには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="0832ec483e29be38d2d70bb452597a0c3e196f7f" translate="yes" xml:space="preserve">
          <source>When converting POD source from standard input, the name will be set to &lt;code&gt;STDIN&lt;/code&gt; if this option is not provided. Providing this option is strongly recommended to set a meaningful manual page name.</source>
          <target state="translated">PODソースを標準入力から変換する &lt;code&gt;STDIN&lt;/code&gt; 、このオプションが指定されていない場合、名前はSTDINに設定されます。意味のあるマニュアルページ名を設定するには、このオプションを指定することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="c4fb4623ce7c6c321834d001ce6f813a2fa89505" translate="yes" xml:space="preserve">
          <source>When creating and extending application programming interfaces (APIs) for Symbian or Series 60 or Series 80 or Series 90 it is suggested that trademarks, registered trademarks, or trade names are not used in the API names. Instead, developers should consider basing the API naming in the existing (C++, or maybe Java) public component and API naming, modified as appropriate by the rules of the programming language the new APIs are for.</source>
          <target state="translated">Symbian、Series 60、Series 80、Series 90 のためのアプリケーション・プログラミング・インターフェース(API)を作成したり拡張したりするとき、商標、登録商標、または商号を API 名に使用しないことが提案されています。代わりに、開発者は、既存の (C++、または多分 Java)パブリックコンポーネントと API の名前をベースにして、新しい API が対象とするプログラミング言語のルールによって適切に修正された API の名前を検討するべきです。</target>
        </trans-unit>
        <trans-unit id="6e1a716be153bacd455cdea13693b585d200816e" translate="yes" xml:space="preserve">
          <source>When data are cleaned and standardized, missing or invalid fields will be replaced with sensible defaults when possible. This may be lossy or imprecise. For example, some badly structured META.yml files on CPAN have prerequisite modules listed as both keys and values:</source>
          <target state="translated">データがクリーンアップされ、標準化されると、欠落しているフィールドや無効なフィールドは、可能な限り賢明なデフォルト値に置き換えられます。これは、損失が大きかったり、不正確だったりすることがあります。例えば、CPANのMETA.ymlファイルの中には、構造化されていないものがあり、前提条件モジュールがキーと値の両方としてリストアップされているものがあります。</target>
        </trans-unit>
        <trans-unit id="8dc80c71b0aa717f38046cb0d740616e9bd6381f" translate="yes" xml:space="preserve">
          <source>When dealing with C structures one should select either &lt;b&gt;T_PTROBJ&lt;/b&gt; or &lt;b&gt;T_PTRREF&lt;/b&gt; for the XS type. Both types are designed to handle pointers to complex objects. The T_PTRREF type will allow the Perl object to be unblessed while the T_PTROBJ type requires that the object be blessed. By using T_PTROBJ one can achieve a form of type-checking because the XSUB will attempt to verify that the Perl object is of the expected type.</source>
          <target state="translated">C構造体を扱う場合、XSタイプには&lt;b&gt;T_PTROBJ&lt;/b&gt;または&lt;b&gt;T_PTRREF&lt;/b&gt;を選択する必要があります。どちらのタイプも、複雑なオブジェクトへのポインタを処理するように設計されています。T_PTRREF型では、Perlオブジェクトをunblessすることができますが、T_PTROBJ型では、オブジェクトをblessする必要があります。T_PTROBJを使用することにより、XSUBはPerlオブジェクトが予期されたタイプであることを確認しようと試みるため、タイプチェックの形式を実現できます。</target>
        </trans-unit>
        <trans-unit id="5ef807c417305a11bdb217741916eb3c09e8b5cd" translate="yes" xml:space="preserve">
          <source>When dealing with binary files (or text files in binary mode) be sure to explicitly set $/ to the appropriate value for your file format before using &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">バイナリファイル（またはバイナリモードのテキストファイル）を扱う場合は、 &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; を使用する前に、$ /をファイル形式に適切な値に明示的に設定してください。</target>
        </trans-unit>
        <trans-unit id="c2eed87ac3725b6497a344941a7436efeb6e56a3" translate="yes" xml:space="preserve">
          <source>When dealing with binary files (or text files in binary mode) be sure to explicitly set &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; to the appropriate value for your file format before using &lt;a href=&quot;perlfunc#chomp-VARIABLE&quot;&gt;&lt;code&gt;chomp&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">バイナリファイル（またはバイナリモードのテキストファイル）を処理する場合は、&lt;a href=&quot;perlfunc#chomp-VARIABLE&quot;&gt; &lt;code&gt;chomp&lt;/code&gt; &lt;/a&gt;を使用する前に、必ず&lt;a href=&quot;perlvar#%24%2F&quot;&gt; &lt;code&gt;$/&lt;/code&gt; &lt;/a&gt;をファイル形式に適した値に明示的に設定してください。</target>
        </trans-unit>
        <trans-unit id="d089cbb7da6fb1de4b8e802beb51489b821fccc7" translate="yes" xml:space="preserve">
          <source>When dealing with references, it is important to handle them with caution. The &lt;code&gt;INIT:&lt;/code&gt; block first calls SvGETMAGIC(paths), in case paths is a tied variable. Then it checks that &lt;code&gt;SvROK&lt;/code&gt; returns true, which indicates that paths is a valid reference. (Simply checking &lt;code&gt;SvROK&lt;/code&gt; won't trigger FETCH on a tied variable.) It then verifies that the object referenced by paths is an array, using &lt;code&gt;SvRV&lt;/code&gt; to dereference paths, and &lt;code&gt;SvTYPE&lt;/code&gt; to discover its type. As an added test, it checks that the array referenced by paths is non-empty, using the &lt;code&gt;av_top_index&lt;/code&gt; function (which returns -1 if the array is empty). The XSRETURN_UNDEF macro is used to abort the XSUB and return the undefined value whenever all three of these conditions are not met.</source>
          <target state="translated">参照を処理するときは、注意して扱うことが重要です。 &lt;code&gt;INIT:&lt;/code&gt; ブロックは、最初のケースパスに縛ら変数である、SvGETMAGIC（パス）を呼び出します。次に、 &lt;code&gt;SvROK&lt;/code&gt; がtrueを返すことを確認します。これは、パスが有効な参照であることを示します。 （ &lt;code&gt;SvROK&lt;/code&gt; を単純にチェックしても、関連付けられた変数のFETCHはトリガーされません。）次に、パスによって参照されるオブジェクトが配列であることを確認し、 &lt;code&gt;SvRV&lt;/code&gt; を使用してパスを逆参照し、 &lt;code&gt;SvTYPE&lt;/code&gt; を使用してそのタイプを検出します。追加のテストとして、 &lt;code&gt;av_top_index&lt;/code&gt; を使用して、パスによって参照される配列が空でないことを確認します関数（配列が空の場合は-1を返します）。XSRETURN_UNDEFマクロを使用して、XSUBを中止し、これら3つの条件がすべて満たされない場合は常に未定義の値を返します。</target>
        </trans-unit>
        <trans-unit id="38a7bf875048ed175efb40337595a64499d137a5" translate="yes" xml:space="preserve">
          <source>When dealing with strings containing characters that cannot be represented using an eight-bit character set, perl uses an internal representation that is a permissive version of Unicode's UTF-8 encoding[2]. This uses single bytes to represent characters from the ASCII character set, and sequences of two or more bytes for all other characters. (See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more information about the relationship between UTF-8 and perl's encoding, utf8. The difference isn't important for this discussion.)</source>
          <target state="translated">8ビット文字セットを使用して表現できない文字を含む文字列を処理する場合、perlはUnicodeのUTF-8エンコーディングの許容バージョンである内部表現を使用します[2]。これは、1バイトを使用してASCII文字セットの文字を表し、他のすべての文字には2バイト以上のシーケンスを使用します。（UTF-8とperlのエンコーディングutf8の関係についての詳細は、&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;を参照してください。この説明では、違いは重要ではありません。）</target>
        </trans-unit>
        <trans-unit id="ec373fa59b49b953efac841d6f570fdf4b7bbe64" translate="yes" xml:space="preserve">
          <source>When debugging a script that uses #! and is thus normally found in $PATH, the -S option causes perl to search $PATH for it, so you don't have to type the path or &lt;code&gt;which $scriptname&lt;/code&gt; .</source>
          <target state="translated">＃！を使用するスクリプトをデバッグするとき したがって、通常は$ PATHにありますが、-Sオプションを指定すると、perlは$ PATHを検索して、パスや &lt;code&gt;which $scriptname&lt;/code&gt; を入力する必要がなくなります。</target>
        </trans-unit>
        <trans-unit id="defb50e120fb7902c1ad7735f710efb52d461bf8" translate="yes" xml:space="preserve">
          <source>When debugging a script that uses #! and is thus normally found in $PATH, the -S option causes perl to search $PATH for it, so you don't have to type the path or &lt;code&gt;which $scriptname&lt;/code&gt;.</source>
          <target state="translated">＃！を使用するスクリプトをデバッグする場合 したがって、通常は$ PATHにあり、-Sオプションを指定するとperlは$ PATHでそれを検索するため、パスや &lt;code&gt;which $scriptname&lt;/code&gt; を入力する必要はありません。</target>
        </trans-unit>
        <trans-unit id="c091d3205ab1a4db30cd1f652d642a63585b86ed" translate="yes" xml:space="preserve">
          <source>When defined, remove the legacy</source>
          <target state="translated">定義されている場合は、レガシー</target>
        </trans-unit>
        <trans-unit id="ffd1aac87a1a4ead57eced3127ad85f26b16823a" translate="yes" xml:space="preserve">
          <source>When defining hints, you can either supply both &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;scalar&lt;/code&gt; keywords,</source>
          <target state="translated">ヒントを定義するときは、 &lt;code&gt;list&lt;/code&gt; キーワードと &lt;code&gt;scalar&lt;/code&gt; キーワードの両方を指定できます。</target>
        </trans-unit>
        <trans-unit id="f6fa41bd97a298d1cd8b0e0f363528cda01ea2a0" translate="yes" xml:space="preserve">
          <source>When defining multiple constants, you cannot use the values of other constants defined in the same declaration. This is because the calling package doesn't know about any constant within that group until</source>
          <target state="translated">複数の定数を定義する場合、同じ宣言で定義された他の定数の値を使用することはできません。これは、呼び出し元のパッケージがそのグループ内の定数について</target>
        </trans-unit>
        <trans-unit id="ffb15fb0d6730c3726c9bf86322c62258c95b95a" translate="yes" xml:space="preserve">
          <source>When deleting a definition, this bit causes each &lt;code&gt;$sTargetPath&lt;/code&gt; to be compared to the full-length definition when searching for the most recently added match. If this bit is not set, then &lt;code&gt;$sTargetPath&lt;/code&gt; only needs to match a prefix of the definition.</source>
          <target state="translated">定義を削除する場合、このビットにより、最後に追加された一致を検索するときに、各 &lt;code&gt;$sTargetPath&lt;/code&gt; が完全長の定義と比較されます。このビットが設定されていない場合、 &lt;code&gt;$sTargetPath&lt;/code&gt; は定義のプレフィックスと一致する必要があるだけです。</target>
        </trans-unit>
        <trans-unit id="5777270f296102b587f7b9de510c0b0ddda1bbd9" translate="yes" xml:space="preserve">
          <source>When describing the merge commit, explain the purpose of the branch, and keep in mind that this description will probably be used by the eventual release engineer when reviewing the next perldelta document.</source>
          <target state="translated">マージコミットを記述する際には、ブランチの目的を説明し、この記述は最終的なリリースエンジニアが次の perldelta ドキュメントをレビューする際に使用することになることを念頭に置いてください。</target>
        </trans-unit>
        <trans-unit id="9d9045da0fde8e0464c72a9687c675b21416ee8e" translate="yes" xml:space="preserve">
          <source>When designing Maketext, I chose to plan its main features in terms of &quot;buzzword compliance&quot;. And here are the buzzwords:</source>
          <target state="translated">Maketextを設計するとき、私はその主な機能を「バズワード・コンプライアンス」の観点から計画することにしました。そして、ここにそのバズワードがあります。</target>
        </trans-unit>
        <trans-unit id="4723c71ed09d6ef17fa09da9076bcc24872495e5" translate="yes" xml:space="preserve">
          <source>When designing an interface between Perl and a C library a straight translation from C to XS (such as created by &lt;code&gt;h2xs -x&lt;/code&gt; ) is often sufficient. However, sometimes the interface will look very C-like and occasionally nonintuitive, especially when the C function modifies one of its parameters, or returns failure inband (as in &quot;negative return values mean failure&quot;). In cases where the programmer wishes to create a more Perl-like interface the following strategy may help to identify the more critical parts of the interface.</source>
          <target state="translated">PerlとCライブラリ間のインターフェースを設計する場合、CからXSへの直接変換（たとえば &lt;code&gt;h2xs -x&lt;/code&gt; によって作成されたもの）で十分なことがよくあります。ただし、特にC関数がそのパラメーターの1つを変更したり、帯域内で障害を返す場合（特に、「負の戻り値は障害を意味する」のように）、インターフェイスは非常にCのように見え、ときには直感的でない場合があります。プログラマーがよりPerlに似たインターフェースを作成したい場合は、以下の戦略がインターフェースのより重要な部分を識別するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="aa2910d5c8edb2a11952d853cabc19faa12f6ab8" translate="yes" xml:space="preserve">
          <source>When designing an interface between Perl and a C library a straight translation from C to XS (such as created by &lt;code&gt;h2xs -x&lt;/code&gt;) is often sufficient. However, sometimes the interface will look very C-like and occasionally nonintuitive, especially when the C function modifies one of its parameters, or returns failure inband (as in &quot;negative return values mean failure&quot;). In cases where the programmer wishes to create a more Perl-like interface the following strategy may help to identify the more critical parts of the interface.</source>
          <target state="translated">PerlとCライブラリ間のインターフェースを設計する場合、CからXSへの直接変換（ &lt;code&gt;h2xs -x&lt;/code&gt; によって作成されるなど）で十分なことがよくあります。ただし、特にC関数がパラメーターの1つを変更したり、障害インバンドを返したりする場合（「負の戻り値は障害を意味する」のように）、インターフェイスが非常にCに似ており、直感的でない場合があります。プログラマーがよりPerlに似たインターフェースを作成したい場合、以下の戦略がインターフェースのより重要な部分を特定するのに役立つかもしれません。</target>
        </trans-unit>
        <trans-unit id="1a3b14a33a7328d3c4446b4818b46b0e10681a93" translate="yes" xml:space="preserve">
          <source>When developing interactive and/or potentially long-running applications, it's a good idea to maintain a persistent interpreter rather than allocating and constructing a new interpreter multiple times. The major reason is speed: since Perl will only be loaded into memory once.</source>
          <target state="translated">インタラクティブなアプリケーションや、長期的に動作する可能性のあるアプリケーションを開発する場合、新しいインタプリタを何度も割り当てて構築するよりも、永続的なインタプリタを維持することをお勧めします。主な理由は、Perl がメモリにロードされるのは一度だけだからです。</target>
        </trans-unit>
        <trans-unit id="fbc30eeb77b449fcef99048d57b0caf5a9160153" translate="yes" xml:space="preserve">
          <source>When do I use SKIP vs. TODO?</source>
          <target state="translated">SKIP vs.TODOはいつ使うの?</target>
        </trans-unit>
        <trans-unit id="bf6878bf07602f9398e0aebf78788b970eee0437" translate="yes" xml:space="preserve">
          <source>When doing XS / Symbian C++ programming include first the Symbian headers, then any standard C/POSIX headers, then Perl headers, and finally any application headers.</source>
          <target state="translated">XS/Symbian C++プログラミングを行う際には、最初に Symbian ヘッダ、次に標準的な C/POSIX ヘッダ、Perl ヘッダ、そして最後にアプリケーションヘッダを含めるようにしてください。</target>
        </trans-unit>
        <trans-unit id="68e541a18f2f1ca2cdf86c535b1f959438918ee4" translate="yes" xml:space="preserve">
          <source>When downloading from CPAN, save your file with a &lt;code&gt;.tgz&lt;/code&gt; extension instead of &lt;code&gt;.tar.gz&lt;/code&gt;. All other periods in the filename should be replaced with underscores. For example, &lt;code&gt;Your-Module-1.33.tar.gz&lt;/code&gt; should be downloaded as &lt;code&gt;Your-Module-1_33.tgz&lt;/code&gt;.</source>
          <target state="translated">CPANからダウンロードする場合は、ファイルを &lt;code&gt;.tar.gz&lt;/code&gt; ではなく &lt;code&gt;.tgz&lt;/code&gt; 拡張子で保存します。ファイル名の他のピリオドはすべてアンダースコアに置き換える必要があります。たとえば、 &lt;code&gt;Your-Module-1.33.tar.gz&lt;/code&gt; は &lt;code&gt;Your-Module-1_33.tgz&lt;/code&gt; としてダウンロードする必要があります。</target>
        </trans-unit>
        <trans-unit id="7a4bca7ef82b244e2bfab60f9ed2d006dc99b5fe" translate="yes" xml:space="preserve">
          <source>When each filter is called by Perl, a local copy of &lt;code&gt;$_&lt;/code&gt; will contain the key or value to be filtered. Filtering is achieved by modifying the contents of &lt;code&gt;$_&lt;/code&gt; . The return code from the filter is ignored.</source>
          <target state="translated">Perlによって各フィルターが呼び出されると、 &lt;code&gt;$_&lt;/code&gt; ローカルコピーにフィルターされるキーまたは値が含まれます。フィルタリングは、 &lt;code&gt;$_&lt;/code&gt; の内容を変更することによって実現されます。フィルターからの戻りコードは無視されます。</target>
        </trans-unit>
        <trans-unit id="37bc6f2fee508f42f859a937c741e1314dc47c4d" translate="yes" xml:space="preserve">
          <source>When each filter is called by Perl, a local copy of &lt;code&gt;$_&lt;/code&gt; will contain the key or value to be filtered. Filtering is achieved by modifying the contents of &lt;code&gt;$_&lt;/code&gt;. The return code from the filter is ignored.</source>
          <target state="translated">各フィルターがPerlによって呼び出されると、 &lt;code&gt;$_&lt;/code&gt; ローカルコピーにフィルターされるキーまたは値が含まれます。フィルタリングは、 &lt;code&gt;$_&lt;/code&gt; の内容を変更することで実現されます。フィルタからの戻りコードは無視されます。</target>
        </trans-unit>
        <trans-unit id="d0a0c84572d5c8f36ddeeedc2b34034d9368a3d3" translate="yes" xml:space="preserve">
          <source>When embedded code is quantified, successful matches will call the code once for each matched iteration of the quantifier. For example:</source>
          <target state="translated">埋め込まれたコードが定量化されている場合、一致したコードは、定量化子の一致した繰り返しごとに一度だけコードを呼び出します。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="b2de387631853c970d098f700c90774516567311" translate="yes" xml:space="preserve">
          <source>When evaluated, the typeglob produces a scalar value that represents all the objects of that name, including any filehandle, format, or subroutine. When assigned to, it causes the name mentioned to refer to whatever &lt;code&gt;*&lt;/code&gt; value was assigned to it. Example:</source>
          <target state="translated">評価されると、typeglobは、ファイルハンドル、フォーマット、またはサブルーチンを含む、その名前のすべてのオブジェクトを表すスカラー値を生成します。割り当てられている場合は、名前が何を参照するために言及した原因 &lt;code&gt;*&lt;/code&gt; それに割り当てられた値。例：</target>
        </trans-unit>
        <trans-unit id="4c69b020552d0b8ae9319c611f51330e0fd5df99" translate="yes" xml:space="preserve">
          <source>When exec() is called inside a pseudo-process then DESTROY methods and END blocks will still be called after the external process returns.</source>
          <target state="translated">exec()が疑似プロセス内で呼び出された場合、外部プロセスが戻ってきた後も DESTROY メソッドと END ブロックが呼び出されます。</target>
        </trans-unit>
        <trans-unit id="8c7eebc997f4f93f028327a4f1ff0c0608dc29e2" translate="yes" xml:space="preserve">
          <source>When execution of the program reaches a subroutine call, a call to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; (</source>
          <target state="translated">プログラムの実行がサブルーチン呼び出しに到達すると、 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; （</target>
        </trans-unit>
        <trans-unit id="e34ca66c0a813d790613eb9e5cc3ba8d52f5c3fa" translate="yes" xml:space="preserve">
          <source>When execution of the program reaches a subroutine call, a call to &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt;(</source>
          <target state="translated">プログラムの実行がサブルーチン呼び出しに達すると、 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; （</target>
        </trans-unit>
        <trans-unit id="1b8b87da2107f5f6b07c4ad0b8f0c3bd9b3e2787" translate="yes" xml:space="preserve">
          <source>When execution of the program uses &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; to enter a non-XS subroutine and the 0x80 bit is set in &lt;code&gt;$^P&lt;/code&gt; , a call to &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; is made, with &lt;code&gt;$DB::sub&lt;/code&gt; holding the name of the subroutine being entered.</source>
          <target state="translated">プログラムの実行で &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; を使用して非XSサブルーチンを開始し、 &lt;code&gt;$^P&lt;/code&gt; に0x80ビットが設定されている場合、 &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; への呼び出しが行われ、 &lt;code&gt;$DB::sub&lt;/code&gt; に入力されたサブルーチンの名前が保持されます。</target>
        </trans-unit>
        <trans-unit id="46697cf78f9bb3bd5dc8972ced50ec3e3d6c90ea" translate="yes" xml:space="preserve">
          <source>When execution of the program uses &lt;code&gt;goto&lt;/code&gt; to enter a non-XS subroutine and the 0x80 bit is set in &lt;code&gt;$^P&lt;/code&gt;, a call to &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; is made, with &lt;code&gt;$DB::sub&lt;/code&gt; set to identify the subroutine being entered. The call to &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; does not replace the &lt;code&gt;goto&lt;/code&gt;; the requested subroutine will still be entered once &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; has returned. &lt;code&gt;$DB::sub&lt;/code&gt; normally holds the name of the subroutine being entered, if it has one. Failing that, &lt;code&gt;$DB::sub&lt;/code&gt; will hold a reference to the subroutine being entered. Unlike when &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; is called, it is not guaranteed that &lt;code&gt;$DB::sub&lt;/code&gt; can be used as a reference to operate on the subroutine being entered.</source>
          <target state="translated">プログラムの実行で &lt;code&gt;goto&lt;/code&gt; を使用して非XSサブルーチンを入力し、0x80ビットが &lt;code&gt;$^P&lt;/code&gt; 設定されている場合、 &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; が呼び出され、 &lt;code&gt;$DB::sub&lt;/code&gt; 設定されて入力されているサブルーチンが識別されます。 &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; の呼び出しは、 &lt;code&gt;goto&lt;/code&gt; を置き換えません。 &lt;code&gt;&amp;amp;DB::goto&lt;/code&gt; が返されると、要求されたサブルーチンは引き続き入力されます。 &lt;code&gt;$DB::sub&lt;/code&gt; は通常、入力されているサブルーチンの名前を保持します（存在する場合）。それができない場合、 &lt;code&gt;$DB::sub&lt;/code&gt; は入力されているサブルーチンへの参照を保持します。 &lt;code&gt;&amp;amp;DB::sub&lt;/code&gt; が呼び出された場合とは異なり、 &lt;code&gt;$DB::sub&lt;/code&gt; が呼び出されるとは限りません。 入力されているサブルーチンを操作するための参照として使用できます。</target>
        </trans-unit>
        <trans-unit id="a7780be4ab5e34307ca9834bebf3c5ea11f2bda2" translate="yes" xml:space="preserve">
          <source>When exitcode is non-zero, a message box appears, otherwise the console closes, so you might have to catch an exit with status 0 in your program to see any output.</source>
          <target state="translated">exitcode が 0 以外の場合はメッセージボックスが表示され、そうでない場合はコンソールが閉じます。</target>
        </trans-unit>
        <trans-unit id="6f3c5ccbe8b2049e627d85f2a9ec69ec19650c45" translate="yes" xml:space="preserve">
          <source>When false the information is not considered critical and may not be rendered in less-verbose modes.</source>
          <target state="translated">虚偽の場合、その情報はクリティカルとはみなされず、より控えめなモードでは表示されないことがあります。</target>
        </trans-unit>
        <trans-unit id="b361c8c46cd947899ffa296e187a289b54d8046a" translate="yes" xml:space="preserve">
          <source>When field hashes are used, the basic structure remains the same. Each lexical hash will be made a field hash. The call to &lt;code&gt;refaddr&lt;/code&gt; can be omitted from the accessor methods. DESTROY and CLONE methods are not necessary.</source>
          <target state="translated">フィールドハッシュを使用しても、基本的な構造は変わりません。各字句ハッシュはフィールドハッシュになります。 &lt;code&gt;refaddr&lt;/code&gt; の呼び出しは、アクセサーメソッドから省略できます。DESTROYメソッドとCLONEメソッドは必要ありません。</target>
        </trans-unit>
        <trans-unit id="7ff1c534eb53fb9adf1f1f7cdd902bdbfec52451" translate="yes" xml:space="preserve">
          <source>When finding a program to run, Perl first asks the OS to look for executables on &lt;code&gt;PATH&lt;/code&gt; (OS/2 adds extension</source>
          <target state="translated">実行するプログラムを見つけると、Perlは最初にOSに &lt;code&gt;PATH&lt;/code&gt; で実行可能ファイルを探すように要求します（OS / 2は拡張子を追加します</target>
        </trans-unit>
        <trans-unit id="13a2688e14421cbafe067aeaa351f65e3474e11f" translate="yes" xml:space="preserve">
          <source>When finished, &lt;code&gt;$input&lt;/code&gt; will be completely processed (assuming there were no errors). If the deflation was successful it writes the deflated data to &lt;code&gt;$output&lt;/code&gt; and returns a status value of &lt;code&gt;Z_OK&lt;/code&gt; .</source>
          <target state="translated">終了すると、 &lt;code&gt;$input&lt;/code&gt; は完全に処理されます（エラーがなかった場合）。デフレが成功した場合、デフレしたデータを &lt;code&gt;$output&lt;/code&gt; に書き込み、ステータス値 &lt;code&gt;Z_OK&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="98115fd081a8900c4523336f3adbeaa8265d8ece" translate="yes" xml:space="preserve">
          <source>When finished, &lt;code&gt;$input&lt;/code&gt; will be completely processed (assuming there were no errors). If the deflation was successful it writes the deflated data to &lt;code&gt;$output&lt;/code&gt; and returns a status value of &lt;code&gt;Z_OK&lt;/code&gt;.</source>
          <target state="translated">終了すると、 &lt;code&gt;$input&lt;/code&gt; は完全に処理されます（エラーがなかったと仮定）。デフレーションが成功した場合、デフレーションされたデータを &lt;code&gt;$output&lt;/code&gt; に書き込み、ステータス値 &lt;code&gt;Z_OK&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="1fcfed4a8d779393f6607570b9bb7471da1de1d1" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; is actually a flow control statement rather than a function. If there is a &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt;), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; statement (which is similar to the C &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; statement).</source>
          <target state="translated">BLOCKが後に続く場合、&lt;a href=&quot;#continue-BLOCK&quot;&gt; &lt;code&gt;continue&lt;/code&gt; &lt;/a&gt;は実際には関数ではなくフロー制御ステートメントです。BLOCKにアタッチされた&lt;a href=&quot;#continue-BLOCK&quot;&gt; &lt;code&gt;continue&lt;/code&gt; BLOCK&lt;/a&gt;がある場合（通常は &lt;code&gt;while&lt;/code&gt; または &lt;code&gt;foreach&lt;/code&gt; ）、Cの &lt;code&gt;for&lt;/code&gt; ループの3番目の部分と同様に、条件が再度評価される直前に常に実行されます。&lt;a href=&quot;#next-LABEL&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;ステートメント（Cの&lt;a href=&quot;#continue-BLOCK&quot;&gt; &lt;code&gt;continue&lt;/code&gt; &lt;/a&gt;ステートメントと同様）を介してループが継続されている場合でも、ループ変数をインクリメントするために使用されます。</target>
        </trans-unit>
        <trans-unit id="3d09ef2037aaa8553df4a9d1d56e3501c5f5a619" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is actually a flow control statement rather than a function. If there is a &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt; ), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement (which is similar to the C &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement).</source>
          <target state="translated">BLOCKが後に続く場合、 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; は実際には関数ではなくフロー制御ステートメントです。BLOCKに接続された &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK がある場合（通常、 &lt;code&gt;while&lt;/code&gt; または &lt;code&gt;foreach&lt;/code&gt; で）、Cの &lt;code&gt;for&lt;/code&gt; ループの3番目の部分のように、条件が再び評価される直前に常に実行されます。ループが &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ステートメント（C &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; ステートメントに似ています）を介して継続されている場合でも、ループ変数をインクリメントするために使用されます。</target>
        </trans-unit>
        <trans-unit id="2cd67d2b65a87b65d002d9fa075eef11fc3372a5" translate="yes" xml:space="preserve">
          <source>When followed by a BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is actually a flow control statement rather than a function. If there is a &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK attached to a BLOCK (typically in a &lt;code&gt;while&lt;/code&gt; or &lt;code&gt;foreach&lt;/code&gt; ), it is always executed just before the conditional is about to be evaluated again, just like the third part of a &lt;code&gt;for&lt;/code&gt; loop in C. Thus it can be used to increment a loop variable, even when the loop has been continued via the &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement (which is similar to the C &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement).</source>
          <target state="translated">BLOCKが後に続く場合、 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; は実際には関数ではなくフロー制御ステートメントです。BLOCKに接続された &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; BLOCK がある場合（通常、 &lt;code&gt;while&lt;/code&gt; または &lt;code&gt;foreach&lt;/code&gt; で）、Cの &lt;code&gt;for&lt;/code&gt; ループの3番目の部分のように、条件が再び評価される直前に常に実行されます。ループが &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ステートメント（C &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; ステートメントに似ています）を介して継続されている場合でも、ループ変数をインクリメントするために使用されます。</target>
        </trans-unit>
        <trans-unit id="aa8159a0d83694276288a2a5fe07fe61d16edc97" translate="yes" xml:space="preserve">
          <source>When functions within an XS source file must be separated into packages the PACKAGE keyword should be used. This keyword is used with the MODULE keyword and must follow immediately after it when used.</source>
          <target state="translated">XSソースファイル内の関数をパッケージに分けなければならない場合は、 PACKAGEキーワードを使用しなければなりません。このキーワードはMODULEキーワードと一緒に使用され、使用時には直後に続く必要があります。</target>
        </trans-unit>
        <trans-unit id="c6f577a0659ee785a75d16bfb954974346b28a9b" translate="yes" xml:space="preserve">
          <source>When given an ambiguous local time, the timelocal() function should always return the epoch for the</source>
          <target state="translated">曖昧なローカル時刻が与えられた場合、timelocal()関数は常に</target>
        </trans-unit>
        <trans-unit id="905210e566be8553d344f14d5ca8c62a30b6a0a2" translate="yes" xml:space="preserve">
          <source>When handling output parameters with a PPCODE section, be sure to handle 'set' magic properly. See &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; for details about 'set' magic.</source>
          <target state="translated">PPCODEセクションで出力パラメーターを処理するときは、「設定」マジックを適切に処理してください。「セット」マジックの詳細については&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5bd61549e044c4efead59e04ed6605311709e2f3" translate="yes" xml:space="preserve">
          <source>When in doubt, before you do anything else, check your status and read it carefully, many questions are answered directly by the git status output.</source>
          <target state="translated">疑問があるときは、何かをする前に自分の状態を確認してよく読んでみると、多くの疑問はgitのステータス出力で直接答えが出てきます。</target>
        </trans-unit>
        <trans-unit id="76666973f161e896d15ace4d3f87a7a9c3ef5759" translate="yes" xml:space="preserve">
          <source>When in doubt, parenthesize. At the very least it will let some poor schmuck bounce on the % key in &lt;b&gt;vi&lt;/b&gt;.</source>
          <target state="translated">疑問がある場合は括弧で囲みます。少なくとも、&lt;b&gt;viの&lt;/b&gt;％キーで貧弱なシュマックが跳ね返ることはあります。</target>
        </trans-unit>
        <trans-unit id="b4688043e9a06a71613858ea73f001a633497cb7" translate="yes" xml:space="preserve">
          <source>When in doubt, run the &lt;b&gt;awk&lt;/b&gt; construct through &lt;b&gt;a2p&lt;/b&gt; and see what it gives you.</source>
          <target state="translated">疑わしい場合は、&lt;b&gt;a2p&lt;/b&gt;を介して&lt;b&gt;awk&lt;/b&gt;構文を実行し、何が得られるかを確認してください。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0c9ab777cdba3a81e6f12be90b090ea8b365cf98" translate="yes" xml:space="preserve">
          <source>When in doubt, you can use</source>
          <target state="translated">迷ったときは</target>
        </trans-unit>
        <trans-unit id="6948014018e5357f830915cd0ed311117487ecb2" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;`perl -MExtUtils::Embed -e ldopts --`&lt;/code&gt; the following options are recognized:</source>
          <target state="translated">&lt;code&gt;`perl -MExtUtils::Embed -e ldopts --`&lt;/code&gt; として呼び出されると、次のオプションが認識されます。</target>
        </trans-unit>
        <trans-unit id="cc36b4e11ce2156b2b41d828826a07de94fcec39" translate="yes" xml:space="preserve">
          <source>When invoked as &lt;code&gt;`perl -MExtUtils::Embed -e xsinit --`&lt;/code&gt; the following options are recognized:</source>
          <target state="translated">&lt;code&gt;`perl -MExtUtils::Embed -e xsinit --`&lt;/code&gt; として呼び出されると、次のオプションが認識されます。</target>
        </trans-unit>
        <trans-unit id="ee150951d5eb2b6fd45fd97edec569546ed48f9b" translate="yes" xml:space="preserve">
          <source>When invoked using a single string, &lt;b&gt;parseopts&lt;/b&gt; treats the string as the name of a parse-option and returns its corresponding value if it exists (returns &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if it doesn't).</source>
          <target state="translated">単一の文字列を使用して呼び出されると、&lt;b&gt;parseopts&lt;/b&gt;は文字列を解析オプションの名前として扱い、対応する値が存在する場合はそれを返し &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; （存在しない場合はundefを返します）。</target>
        </trans-unit>
        <trans-unit id="7277cd46617f74f2842ee4af54a1d49db21e598b" translate="yes" xml:space="preserve">
          <source>When invoked with multiple arguments, &lt;b&gt;parseopts&lt;/b&gt; treats them as key/value pairs and the specified parse-option names are set to the given values. Any unspecified parse-options are unaffected.</source>
          <target state="translated">複数の引数を指定して呼び出されると、&lt;b&gt;parseopts&lt;/b&gt;はそれらをキー/値のペアとして扱い、指定された解析オプション名は指定された値に設定されます。指定されていない解析オプションは影響を受けません。</target>
        </trans-unit>
        <trans-unit id="f1033de63c389a24f6517627a4b9b4657247752f" translate="yes" xml:space="preserve">
          <source>When invoked with no additional arguments, &lt;b&gt;parseopts&lt;/b&gt; returns a hashtable of all the current parsing options.</source>
          <target state="translated">追加の引数なしで呼び出されると、&lt;b&gt;parseopts&lt;/b&gt;は現在のすべての解析オプションのハッシュテーブルを返します。</target>
        </trans-unit>
        <trans-unit id="8a84fb9fbc48134e4aa29a0c0010fa21ec733eeb" translate="yes" xml:space="preserve">
          <source>When invoked with parameters the following are accepted and optional:</source>
          <target state="translated">パラメータを指定して起動した場合、以下の内容が受け入れられ、オプションとなります。</target>
        </trans-unit>
        <trans-unit id="3db92287943a254b1a1b0d74b4c460a69a45306e" translate="yes" xml:space="preserve">
          <source>When is a bool not a bool?</source>
          <target state="translated">boolがboolでないのはいつですか?</target>
        </trans-unit>
        <trans-unit id="7b77a4a5d5b65846fa5a3f0440157e545f392596" translate="yes" xml:space="preserve">
          <source>When it appears singly, it causes the sequences &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt; , and the Posix character classes to match only in the ASCII range. They thus revert to their pre-5.6, pre-Unicode meanings. Under &lt;code&gt;/a&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; always means precisely the digits &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &lt;code&gt;&quot;9&quot;&lt;/code&gt; ; &lt;code&gt;\s&lt;/code&gt; means the five characters &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; , and starting in Perl v5.18, the vertical tab; &lt;code&gt;\w&lt;/code&gt; means the 63 characters &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; ; and likewise, all the Posix classes such as &lt;code&gt;[[:print:]]&lt;/code&gt; match only the appropriate ASCII-range characters.</source>
          <target state="translated">単独で表示される場合、シーケンス &lt;code&gt;\d&lt;/code&gt; 、 &lt;code&gt;\s&lt;/code&gt; 、 &lt;code&gt;\w&lt;/code&gt; 、およびPosix文字クラスはASCII範囲でのみ一致します。したがって、5.6より前の、Unicodeより前の意味に戻ります。 &lt;code&gt;/a&lt;/code&gt; の下では、 &lt;code&gt;\d&lt;/code&gt; 常に正確に &lt;code&gt;&quot;0&quot;&lt;/code&gt; から &lt;code&gt;&quot;9&quot;&lt;/code&gt; までの数字を意味します。 &lt;code&gt;\s&lt;/code&gt; は5文字 &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; 意味し、Perl v5.18以降、垂直タブです。 &lt;code&gt;\w&lt;/code&gt; は63文字を意味します &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; ;同様に、 &lt;code&gt;[[:print:]]&lt;/code&gt; などのすべてのPosixクラスは、適切なASCII範囲の文字のみに一致します。</target>
        </trans-unit>
        <trans-unit id="1727801b4e8e5e0fc9f27e13c40d768e93c5839d" translate="yes" xml:space="preserve">
          <source>When it appears singly, it causes the sequences &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt;, and the Posix character classes to match only in the ASCII range. They thus revert to their pre-5.6, pre-Unicode meanings. Under &lt;code&gt;/a&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt; always means precisely the digits &lt;code&gt;&quot;0&quot;&lt;/code&gt; to &lt;code&gt;&quot;9&quot;&lt;/code&gt;; &lt;code&gt;\s&lt;/code&gt; means the five characters &lt;code&gt;[ \f\n\r\t]&lt;/code&gt;, and starting in Perl v5.18, the vertical tab; &lt;code&gt;\w&lt;/code&gt; means the 63 characters &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;; and likewise, all the Posix classes such as &lt;code&gt;[[:print:]]&lt;/code&gt; match only the appropriate ASCII-range characters.</source>
          <target state="translated">単独で表示される場合、シーケンス &lt;code&gt;\d&lt;/code&gt; 、 &lt;code&gt;\s&lt;/code&gt; 、 &lt;code&gt;\w&lt;/code&gt; 、およびPosix文字クラスはASCII範囲でのみ一致します。したがって、5.6より前のUnicodeより前の意味に戻ります。 &lt;code&gt;/a&lt;/code&gt; の下では、 &lt;code&gt;\d&lt;/code&gt; 常に正確に &lt;code&gt;&quot;0&quot;&lt;/code&gt; から &lt;code&gt;&quot;9&quot;&lt;/code&gt; までの数字を意味します。 &lt;code&gt;\s&lt;/code&gt; は、5文字 &lt;code&gt;[ \f\n\r\t]&lt;/code&gt; 意味し、Perl v5.18以降、垂直タブです。 &lt;code&gt;\w&lt;/code&gt; は63文字を意味します &lt;code&gt;[A-Za-z0-9_]&lt;/code&gt; ;同様に、 &lt;code&gt;[[:print:]]&lt;/code&gt; などのすべてのPosixクラスは、適切なASCII範囲の文字にのみ一致します。</target>
        </trans-unit>
        <trans-unit id="d7e96b083a5b2fe4b1dd3f7bbb3653cb24d7adf0" translate="yes" xml:space="preserve">
          <source>When it comes to altering the behaviour of the test harness there's more than one way to do it. Which way is best depends on my requirements. In general if I only want to observe test execution without changing the harness' behaviour (for example to log test results to a database) I choose callbacks. If I want to make the harness behave differently subclassing gives me more control.</source>
          <target state="translated">テストハーネスの動作を変更する場合、方法は一つではありません。どの方法がベストなのかは、私の要求に依存します。一般的には、ハーネスの動作を変更せずにテストの実行のみを観察したい場合(例えば、テスト結果をデータベースに記録するなど)はコールバックを選択します。もしハーネスの動作を変えたい場合は、サブクラス化することでより多くの制御が可能になります。</target>
        </trans-unit>
        <trans-unit id="ae018fd8a3823b08fc79c33ba2f6c60484d5a434" translate="yes" xml:space="preserve">
          <source>When it comes to time-space tradeoffs, Perl nearly always prefers to throw memory at a problem. Scalars in Perl use more memory than strings in C, arrays take more than that, and hashes use even more. While there's still a lot to be done, recent releases have been addressing these issues. For example, as of 5.004, duplicate hash keys are shared amongst all hashes using them, so require no reallocation.</source>
          <target state="translated">時間空間のトレードオフに関して言えば、Perl はほとんどの場合、問題にメモリを投入することを好みます。Perl のスカラは C の文字列よりも多くのメモリを使用し、配列はそれよりも多くのメモリを使用し、ハッシュはさらに多くのメモリを使用します。まだまだやるべきことはたくさんありますが、最近のリリースではこれらの問題に対処しています。例えば、5.004では、重複したハッシュキーは、それらを使用している全てのハッシュの間で共有されるため、再割り当ては必要ありません。</target>
        </trans-unit>
        <trans-unit id="e21264012009a4f52f16ff3209c2f52a03a6b032" translate="yes" xml:space="preserve">
          <source>When it comes to undefined variables that would trigger a warning under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , you can promote the warning to an error.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; で警告をトリガーする未定義の変数に関しては、警告をエラーに昇格させることができます。</target>
        </trans-unit>
        <trans-unit id="f4053c4973cee39e429495f57f5734c7c3b59da1" translate="yes" xml:space="preserve">
          <source>When it comes to undefined variables that would trigger a warning under &lt;code&gt;use warnings&lt;/code&gt;, you can promote the warning to an error.</source>
          <target state="translated">&lt;code&gt;use warnings&lt;/code&gt; 下で警告をトリガーする未定義の変数に関しては、警告をエラーに昇格させることができます。</target>
        </trans-unit>
        <trans-unit id="ea78a63efa4e07bcbad222b4b53d8108119efd5b" translate="yes" xml:space="preserve">
          <source>When it converges, you got a functional variant of</source>
          <target state="translated">それが収束すると、関数的には</target>
        </trans-unit>
        <trans-unit id="079267d57082e05e5aa6528a39e11837b4f6a244" translate="yes" xml:space="preserve">
          <source>When it starts, the debugger reads your rc file (</source>
          <target state="translated">起動すると、デバッガはあなたの rc ファイル (</target>
        </trans-unit>
        <trans-unit id="ab2f1658320564cc0ad685bee8d4cc13fa19d54b" translate="yes" xml:space="preserve">
          <source>When items collide into a given hash bucket the order they are stored in the chain is no longer predictable in Perl 5.18. This has the intention to make it harder to observe a collision. This behavior can be overridden by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;&quot;PERL_PERTURB_KEYS&quot; in perlrun&lt;/a&gt;.</source>
          <target state="translated">アイテムが特定のハッシュバケットに衝突すると、チェーンに格納される順序はPerl5.18では予測できなくなります。これは、衝突を観察しにくくすることを目的としています。この動作は、PERL_PERTURB_KEYS環境変数を使用してオーバーライドできます。perlrunの&lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;「PERL_PERTURB_KEYS」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f1e1e6def162fe17764cc69d6d5531c8389ffa63" translate="yes" xml:space="preserve">
          <source>When items collide into a given hash bucket the order they are stored in the chain is no longer predictable in Perl 5.18. This has the intention to make it harder to observe a collision. This behavior can be overridden by using the PERL_PERTURB_KEYS environment variable, see &lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;PERL_PERTURB_KEYS in perlrun&lt;/a&gt;.</source>
          <target state="translated">アイテムが特定のハッシュバケットに衝突すると、チェーンに格納される順序はPerl 5.18では予測できなくなります。これは、衝突を観察しにくくすることを目的としています。この動作は、PERL_PERTURB_KEYS環境変数を使用してオーバーライドできます&lt;a href=&quot;perlrun#PERL_PERTURB_KEYS&quot;&gt;。perlrunのPERL_PERTURB_KEYSを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="65043d3a1d3f5988941ccbcf07e25510773d1e57" translate="yes" xml:space="preserve">
          <source>When loading &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;, you must &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; before you &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . (&lt;code&gt;threads&lt;/code&gt; will emit a warning if you do it the other way around.)</source>
          <target state="translated">ロードすると&lt;a href=&quot;threads/shared&quot;&gt;スレッドが::共有&lt;/a&gt;、あなたがしなければならない &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; あなたが前に &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; 。（逆にすると、 &lt;code&gt;threads&lt;/code&gt; は警告を発します。）</target>
        </trans-unit>
        <trans-unit id="ad743799b7c94d4ac0b3c71cf0ab2ce52219a004" translate="yes" xml:space="preserve">
          <source>When loading &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt;, you must &lt;code&gt;use threads&lt;/code&gt; before you &lt;code&gt;use threads::shared&lt;/code&gt;. (&lt;code&gt;threads&lt;/code&gt; will emit a warning if you do it the other way around.)</source>
          <target state="translated">&lt;a href=&quot;threads::shared&quot;&gt;thread :: sharedを&lt;/a&gt;ロードするときは、threads :: sharedを &lt;code&gt;use threads::shared&lt;/code&gt; 前に &lt;code&gt;use threads&lt;/code&gt; を使用する必要があります。（逆の場合、 &lt;code&gt;threads&lt;/code&gt; は警告を発します。）</target>
        </trans-unit>
        <trans-unit id="541e2da58c9337557a4530af689d0206150a39ea" translate="yes" xml:space="preserve">
          <source>When local patches are applied with smoke testing, the test driver will automatically request regeneration of certain tables after the patches are applied. The Synology supplied Perl 5.8.6 (at least on the DS413) &lt;b&gt;is NOT capable&lt;/b&gt; of generating these tables. It will generate opcodes with bogus values, causing the build to fail.</source>
          <target state="translated">ローカルパッチがスモークテストで適用されると、パッチが適用された後、テストドライバーは特定のテーブルの再生成を自動的に要求します。Synologyが提供するPerl5.8.6（少なくともDS413では）&lt;b&gt;は&lt;/b&gt;これらのテーブルを生成&lt;b&gt;できません&lt;/b&gt;。偽の値を持つオペコードが生成され、ビルドが失敗します。</target>
        </trans-unit>
        <trans-unit id="4d97ad32fbcc62b0394446ba4a901eea150b590d" translate="yes" xml:space="preserve">
          <source>When looking for &lt;code&gt;DBD::Oracle&lt;/code&gt; relative to a search path, we should find</source>
          <target state="translated">探しているときに &lt;code&gt;DBD::Oracle&lt;/code&gt; 検索パスに対して、我々は見つける必要があります</target>
        </trans-unit>
        <trans-unit id="e429da2f9f9d1870d8a34d9bf7c8fc15e19b17ad" translate="yes" xml:space="preserve">
          <source>When matching files are extracted, ignore the directory path from the archive and write to the current directory using the basename of the file from the archive. Beware: if two matching files in the archive have the same basename, the second file extracted will overwrite the first.</source>
          <target state="translated">一致するファイルが抽出された場合、アーカイブからのディレクトリパスは無視して、アーカイブからのファイルのベースネームを使ってカレントディレクトリに書き込みます。注意:アーカイブ内の2つの一致するファイルが同じベースネームを持つ場合、抽出された2番目のファイルが最初のファイルを上書きしてしまいます。</target>
        </trans-unit>
        <trans-unit id="4eeb796371e192f654f19b82f3385e933e7f2600" translate="yes" xml:space="preserve">
          <source>When moving backward it will not move before &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="translated">後方に移動すると、 &lt;code&gt;start&lt;/code&gt; 前に移動しません。</target>
        </trans-unit>
        <trans-unit id="c3206ee6854b0880fdd3279a57398bcb52c78786" translate="yes" xml:space="preserve">
          <source>When moving forward it will not move beyond &lt;code&gt;end&lt;/code&gt;.</source>
          <target state="translated">前進するとき、それは &lt;code&gt;end&lt;/code&gt; を超えて移動しません。</target>
        </trans-unit>
        <trans-unit id="d1306624a66d42061de8cb1de14bb165b2e9253e" translate="yes" xml:space="preserve">
          <source>When naming your module, consider the following:</source>
          <target state="translated">モジュールの名前を付ける際には、以下のことを考慮してください。</target>
        </trans-unit>
        <trans-unit id="52dec4ed188cfa5b52a02969dbe527c5dc433e3b" translate="yes" xml:space="preserve">
          <source>When no BOM is found, Encode 2.76 and blow croaked. Since Encode 2.77, it falls back to BE accordingly to RFC2781 and the Unicode Standard version 8.0</source>
          <target state="translated">BOMが見つからない場合は、Encode 2.76とブロークロークします。エンコード2.77以降は、RFC2781とUnicode標準バージョン8.0に合わせてBEにフォールバックします。</target>
        </trans-unit>
        <trans-unit id="a2f6fa234dea48f4123a74cda1902ae1a1335eb2" translate="yes" xml:space="preserve">
          <source>When no destination is specified for an option, GetOptions will store the resultant value in a global variable named &lt;code&gt;opt_&lt;/code&gt;</source>
          <target state="translated">オプションの宛先が指定されていない場合、GetOptionsは結果の値を &lt;code&gt;opt_&lt;/code&gt; という名前のグローバル変数に格納します</target>
        </trans-unit>
        <trans-unit id="d995d17f45ad38c16e65d9df03d9013a6e8bd451" translate="yes" xml:space="preserve">
          <source>When non-&lt;code&gt;NULL&lt;/code&gt; , the function pointed by this variable will be called each time an OP is freed with the corresponding OP as the argument. This allows extensions to free any extra attribute they have locally attached to an OP. It is also assured to first fire for the parent OP and then for its kids.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 以外の場合、この変数が指す関数は、対応するOPを引数としてOPが解放されるたびに呼び出されます。これにより、拡張機能はローカルでOPに接続されている追加の属性を解放できます。また、最初に親OPに、次にその子供に発砲することも保証されています。</target>
        </trans-unit>
        <trans-unit id="ff599e171f439dd0c6a6547247e21662b9941e75" translate="yes" xml:space="preserve">
          <source>When non-&lt;code&gt;NULL&lt;/code&gt;, the function pointed by this variable will be called each time an OP is freed with the corresponding OP as the argument. This allows extensions to free any extra attribute they have locally attached to an OP. It is also assured to first fire for the parent OP and then for its kids.</source>
          <target state="translated">&lt;code&gt;NULL&lt;/code&gt; 以外の場合、この変数が指す関数は、対応するOPを引数としてOPが解放されるたびに呼び出されます。これにより、拡張機能は、OPにローカルにアタッチされている余分な属性を解放できます。また、最初に親OPに対して発砲し、次にその子供に対して発砲することも保証されています。</target>
        </trans-unit>
        <trans-unit id="fda14717d0ef780a84b7072c8af4b8c2a6e41355" translate="yes" xml:space="preserve">
          <source>When non-zero this options will make bzip2 use a decompression algorithm that uses less memory at the expense of increasing the amount of time taken for decompression.</source>
          <target state="translated">このオプションが 0 以外の場合、このオプションは bzip2 に、より少ないメモリ使用量で、伸長にかかる時間を増加させることを犠牲にして、より少ないメモリ使用量の伸長アルゴリズムを使用するようにする。</target>
        </trans-unit>
        <trans-unit id="0ddf8b539ea05fcfe6aec1dc58d559038d4a8742" translate="yes" xml:space="preserve">
          <source>When not using &lt;code&gt;\o{...}&lt;/code&gt;, you wrote something like &lt;code&gt;\08&lt;/code&gt;, or &lt;code&gt;\179&lt;/code&gt; in a double-quotish string. The resolution is as indicated, with all but the last digit treated as a single character, specified in octal. The last digit is the next character in the string. To tell Perl that this is indeed what you want, you can use the &lt;code&gt;\o{ }&lt;/code&gt; syntax, or use exactly three digits to specify the octal for the character.</source>
          <target state="translated">&lt;code&gt;\o{...}&lt;/code&gt; を使用しない場合は、 &lt;code&gt;\08&lt;/code&gt; や &lt;code&gt;\179&lt;/code&gt; ようなものを二重引用符で囲んで記述します。解像度は示されているとおりで、最後の桁を除くすべてが1文字として扱われ、8進数で指定されます。最後の桁は、文字列の次の文字です。これが本当に必要なものであることをPerlに伝えるには、 &lt;code&gt;\o{ }&lt;/code&gt; 構文を使用するか、正確に3桁を使用して文字の8進数を指定します。</target>
        </trans-unit>
        <trans-unit id="53e144afe4dd441bf4ca7ad26c550e29a83fc4df" translate="yes" xml:space="preserve">
          <source>When open() is given an explicit list of layers (with the three-arg syntax), they override the list declared using this pragma. open() can also be given a single colon (:) for a layer name, to override this pragma and use the default (&lt;code&gt;:raw&lt;/code&gt; on Unix, &lt;code&gt;:crlf&lt;/code&gt; on Windows).</source>
          <target state="translated">open（）に（3つの引数の構文を使用して）レイヤーの明示的なリストを指定すると、このプラグマを使用して宣言されたリストがオーバーライドされます。オープン（）も（1つのコロンを与えることができます:)レイヤ名のために、このプラグマを上書きすると、デフォルト（使用 &lt;code&gt;:raw&lt;/code&gt; Unixで、 &lt;code&gt;:crlf&lt;/code&gt; Windowsの場合）。</target>
        </trans-unit>
        <trans-unit id="c34ab00add652f226c09c30c65ec7e49ad76d8a0" translate="yes" xml:space="preserve">
          <source>When open() is given an explicit list of layers (with the three-arg syntax), they override the list declared using this pragma. open() can also be given a single colon (:) for a layer name, to override this pragma and use the default as detailed in &lt;a href=&quot;perlio#Defaults-and-how-to-override-them&quot;&gt;&quot;Defaults and how to override them&quot; in PerlIO&lt;/a&gt;.</source>
          <target state="translated">open（）にレイヤーの明示的なリスト（3つの引数の構文を使用）が与えられると、これらはこのプラグマを使用して宣言されたリストをオーバーライドします。open（）には、レイヤー名に単一のコロン（:)を指定して、このプラグマ&lt;a href=&quot;perlio#Defaults-and-how-to-override-them&quot;&gt;をオーバーライドし、PerlIOの「デフォルトとそのオーバーライド方法」で&lt;/a&gt;説明されているデフォルトを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="ea26acaec78382fd2c97d3e0f9466f873120022e" translate="yes" xml:space="preserve">
          <source>When opened for writing, empty parts of the file will have NULL (0x00) bytes written to them.</source>
          <target state="translated">書き込み用にオープンした場合、ファイルの空の部分には NULL (0x00)バイトが書き込まれます。</target>
        </trans-unit>
        <trans-unit id="4a6b9011509d11da3fcfb04f15c06a413aa28bf6" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is frequently used with &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. Even if &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; won't do what you want (say, in a CGI script, where you want to format a suitable error message (but there are modules that can help with that problem)) always check the return value from opening a file.</source>
          <target state="translated">ファイルを開くとき、要求が失敗した場合に続行することはめったにないので、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; で頻繁に使用されます。 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; が希望どおりに動作しない場合でも（たとえば、CGIスクリプトで、適切なエラーメッセージをフォーマットする必要があります（ただし、その問題に役立つモジュールがあります））、常にファイルを開いたときの戻り値を確認してください。</target>
        </trans-unit>
        <trans-unit id="713d157f79aa607cdf5ba0f3803c5ba5ac49d060" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; is frequently used with &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. Even if &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; won't do what you want (say, in a CGI script, where you want to format a suitable error message (but there are modules that can help with that problem)) always check the return value from opening a file.</source>
          <target state="translated">ファイルを開くとき、要求が失敗した場合に続行することはめったにないので、 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; で頻繁に使用されます。 &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; が希望どおりに動作しない場合でも（たとえば、CGIスクリプトで、適切なエラーメッセージをフォーマットする必要があります（ただし、その問題に役立つモジュールがあります））、常にファイルを開いたときの戻り値を確認してください。</target>
        </trans-unit>
        <trans-unit id="162aabd310aabb9968a3811cefafecae90daf2da" translate="yes" xml:space="preserve">
          <source>When opening a file, it's seldom a good idea to continue if the request failed, so &lt;code&gt;open&lt;/code&gt; is frequently used with &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt;. Even if you want your code to do something other than &lt;code&gt;die&lt;/code&gt; on a failed open, you should still always check the return value from opening a file.</source>
          <target state="translated">ファイルを開くとき、リクエストが失敗した場合に続行することはめったに良い考えではないので、 &lt;code&gt;open&lt;/code&gt; は&lt;a href=&quot;#die-LIST&quot;&gt; &lt;code&gt;die&lt;/code&gt; で&lt;/a&gt;頻繁に使用されます。あなたのコード以外の何かをしたい場合でも &lt;code&gt;die&lt;/code&gt; 上のオープン失敗、あなたはまだ、常にファイルを開くからの戻り値をチェックする必要があります。</target>
        </trans-unit>
        <trans-unit id="892216513454a34d10fa999d477dbcc5ddbab374" translate="yes" xml:space="preserve">
          <source>When opening a handle, it will be opened with any layers specified explicitly in the open() call (or the platform defaults, if specified as a colon with no following layers).</source>
          <target state="translated">ハンドルを開く際には、open()の呼び出しで明示的に指定されたすべてのレイヤ (または、コロンで指定されていて後続のレイヤがない場合はプラットフォームのデフォルト)で開かれます。</target>
        </trans-unit>
        <trans-unit id="136d8820f5385aeb92b2b0d8596ed06c40a27f32" translate="yes" xml:space="preserve">
          <source>When passed a single hash-ref, &lt;b&gt;parseopts&lt;/b&gt; uses that hash to completely reset the existing parse-options, all previous parse-option values are lost.</source>
          <target state="translated">単一のハッシュ参照が渡されると、&lt;b&gt;parseopts&lt;/b&gt;はそのハッシュを使用して既存の解析オプションを完全にリセットし、以前のすべての解析オプション値は失われます。</target>
        </trans-unit>
        <trans-unit id="47b91ab5f28f979fd8b5568f2d0f9b2f727e616c" translate="yes" xml:space="preserve">
          <source>When perl begins to parse any block construct that provides a lexical scope (e.g., eval body, required file, subroutine body, loop body, or conditional block), the existing value of &lt;code&gt;$^H&lt;/code&gt; is saved, but its value is left unchanged. When the compilation of the block is completed, it regains the saved value. Between the points where its value is saved and restored, code that executes within BEGIN blocks is free to change the value of &lt;code&gt;$^H&lt;/code&gt; .</source>
          <target state="translated">perlが字句スコープを提供するブロック構造（たとえば、eval本体、必要なファイル、サブルーチン本体、ループ本体、または条件付きブロック）の解析を開始すると、 &lt;code&gt;$^H&lt;/code&gt; 既存の値は保存されますが、その値は変更されません。ブロックのコンパイルが完了すると、保存された値が復元されます。値が保存および復元されるポイント間で、BEGINブロック内で実行されるコードは &lt;code&gt;$^H&lt;/code&gt; 値を自由に変更できます。</target>
        </trans-unit>
        <trans-unit id="ae5f7f62c62b7d34f56ec3574375a08840be5dee" translate="yes" xml:space="preserve">
          <source>When perl begins to parse any block construct that provides a lexical scope (e.g., eval body, required file, subroutine body, loop body, or conditional block), the existing value of &lt;code&gt;$^H&lt;/code&gt; is saved, but its value is left unchanged. When the compilation of the block is completed, it regains the saved value. Between the points where its value is saved and restored, code that executes within BEGIN blocks is free to change the value of &lt;code&gt;$^H&lt;/code&gt;.</source>
          <target state="translated">perlが字句スコープを提供するブロック構造（eval本体、必要なファイル、サブルーチン本体、ループ本体、条件付きブロックなど）の解析を開始すると、 &lt;code&gt;$^H&lt;/code&gt; 既存の値が保存されますが、その値は変更されません。ブロックのコンパイルが完了すると、保存された値に戻ります。その値が保存および復元されるポイント間で、BEGINブロック内で実行されるコードは &lt;code&gt;$^H&lt;/code&gt; 値を自由に変更できます。</target>
        </trans-unit>
        <trans-unit id="8e10e03e69e1ff5f3a594f297790818dcb4b2f72" translate="yes" xml:space="preserve">
          <source>When perl executes something like &lt;code&gt;addop&lt;/code&gt; , how does it pass on its results to the next op? The answer is, through the use of stacks. Perl has a number of stacks to store things it's currently working on, and we'll look at the three most important ones here.</source>
          <target state="translated">perlが &lt;code&gt;addop&lt;/code&gt; のようなものを実行するとき、その結果を次のopにどのように渡しますか？答えは、スタックを使用することです。Perlには、現在作業しているものを格納するための多数のスタックがあります。ここでは、最も重要な3つのスタックについて説明します。</target>
        </trans-unit>
        <trans-unit id="0ad42676f2cea160c10d6e67d7270b962893b05d" translate="yes" xml:space="preserve">
          <source>When perl executes something like &lt;code&gt;addop&lt;/code&gt;, how does it pass on its results to the next op? The answer is, through the use of stacks. Perl has a number of stacks to store things it's currently working on, and we'll look at the three most important ones here.</source>
          <target state="translated">perlが &lt;code&gt;addop&lt;/code&gt; のようなものを実行するとき、その結果を次のopにどのように渡しますか？答えは、スタックを使用することです。Perlには、現在作業中のものを格納するためのスタックがいくつかあります。ここでは、最も重要な3つのスタックについて説明します。</target>
        </trans-unit>
        <trans-unit id="b736497c10b0a6402c79bf644d3d7290bca7e8df" translate="yes" xml:space="preserve">
          <source>When perl executes the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; expression, it translates the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; calls in the C run-time library and thence to the operating system kernel. perl sets &lt;code&gt;$!&lt;/code&gt; to the C library's &lt;code&gt;errno&lt;/code&gt; if one of these calls fails.</source>
          <target state="translated">perlが &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 式を実行すると、Cランタイムライブラリ内の &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; の各呼び出しが、オペレーティングシステムカーネルに変換されます。perlが &lt;code&gt;$!&lt;/code&gt; 設定します！これらの呼び出しの1つが失敗した場合は、Cライブラリの &lt;code&gt;errno&lt;/code&gt; に。</target>
        </trans-unit>
        <trans-unit id="36c7954ee59f65366eedb8f27e4e9a6ca8de87ae" translate="yes" xml:space="preserve">
          <source>When perl executes the &lt;code&gt;eval()&lt;/code&gt; expression, it translates the &lt;code&gt;open()&lt;/code&gt;, &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt;, and &lt;code&gt;close&lt;/code&gt; calls in the C run-time library and thence to the operating system kernel. perl sets &lt;code&gt;$!&lt;/code&gt; to the C library's &lt;code&gt;errno&lt;/code&gt; if one of these calls fails.</source>
          <target state="translated">perlが &lt;code&gt;eval()&lt;/code&gt; 式を実行すると、 &lt;code&gt;open()&lt;/code&gt; 、 &lt;code&gt;&amp;lt;PIPE&amp;gt;&lt;/code&gt; 、およびCランタイムライブラリ内の &lt;code&gt;close&lt;/code&gt; 呼び出しを変換し、そこからオペレーティングシステムカーネルに変換します。perlは &lt;code&gt;$!&lt;/code&gt; 設定します！これらの呼び出しの1つが失敗した場合、Cライブラリの &lt;code&gt;errno&lt;/code&gt; に送られます。</target>
        </trans-unit>
        <trans-unit id="42ce54f632d505238352e1c6b81e21cf7c3c75f1" translate="yes" xml:space="preserve">
          <source>When perl is built with debugging enabled, there is a second part to this stack storing human-readable string names describing the type of stack context. Each push operation saves the name as well as the height of the save stack, and each pop operation checks the topmost name with what is expected, causing an assertion failure if the name does not match.</source>
          <target state="translated">デバッグを有効にしてPerlがビルドされている場合、スタックのコンテキストのタイプを記述した人間が読める文字列名を保存するスタックの第二部分があります。各プッシュ操作は名前と保存スタックの高さを保存し、各ポップ操作は一番上の名前を期待されるものでチェックし、名前が一致しない場合はアサーションの失敗を引き起こします。</target>
        </trans-unit>
        <trans-unit id="c23db1f0df62364b5b67f120eb77a3d581033b3c" translate="yes" xml:space="preserve">
          <source>When perl is compiled with support for memory footprint debugging (default with Perl's malloc()), Devel::Peek provides an access to this API.</source>
          <target state="translated">perlがメモリフットプリントデバッグをサポートしてコンパイルされている場合(Perlのmalloc()でデフォルト)、Devel::PeekはこのAPIへのアクセスを提供します。</target>
        </trans-unit>
        <trans-unit id="215e17f5873c9b21cb203952a3ef2363b112bec3" translate="yes" xml:space="preserve">
          <source>When perl is configured to use ithreads, it will use re-entrant library calls in preference to non-re-entrant versions. There is a bug in FreeBSD's &lt;code&gt;readdir_r&lt;/code&gt; function in versions 4.5 and earlier that can cause a SEGV when reading large directories. A patch for FreeBSD libc is available (see &lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&lt;/a&gt; ) which has been integrated into FreeBSD 4.6.</source>
          <target state="translated">perlがithreadsを使用するように構成されている場合、非再入可能バージョンよりも再入可能ライブラリー呼び出しが優先されます。FreeBSDのバージョン4.5以前の &lt;code&gt;readdir_r&lt;/code&gt; 関数には、大きなディレクトリを読み取るときにSEGVを引き起こす可能性のあるバグがあります。FreeBSD 4.6に統合されたFreeBSD libcのパッチが利用可能です（&lt;a href=&quot;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631&quot;&gt;http://www.freebsd.org/cgi/query-pr.cgi?pr=misc/30631を参照&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="09323de6d789f44fb18ba022fc8c8c24e89843b3" translate="yes" xml:space="preserve">
          <source>When present this option will limit the number of compressed bytes read from the input file/buffer to &lt;code&gt;$size&lt;/code&gt; . This option can be used in the situation where there is useful data directly after the compressed data stream and you know beforehand the exact length of the compressed data stream.</source>
          <target state="translated">このオプションを指定すると、入力ファイル/バッファーから読み取られる圧縮バイト数が &lt;code&gt;$size&lt;/code&gt; 制限されます。このオプションは、圧縮データストリームの直後に有用なデータがあり、事前に圧縮データストリームの正確な長さがわかっている場合に使用できます。</target>
        </trans-unit>
        <trans-unit id="000c8ae4987a475c6136e4e54de88628f059caa6" translate="yes" xml:space="preserve">
          <source>When present this option will limit the number of compressed bytes read from the input file/buffer to &lt;code&gt;$size&lt;/code&gt;. This option can be used in the situation where there is useful data directly after the compressed data stream and you know beforehand the exact length of the compressed data stream.</source>
          <target state="translated">このオプションが存在する場合、入力ファイル/バッファーから読み取られる圧縮バイト数を &lt;code&gt;$size&lt;/code&gt; 制限します。このオプションは、圧縮データストリームの直後に有用なデータがあり、圧縮データストリームの正確な長さが事前にわかっている場合に使用できます。</target>
        </trans-unit>
        <trans-unit id="2ede0a2d2bf6a5a00a9412db1d402428ce441463" translate="yes" xml:space="preserve">
          <source>When presented with something that might have several different interpretations, Perl uses the &lt;b&gt;DWIM&lt;/b&gt; (that's &quot;Do What I Mean&quot;) principle to pick the most probable interpretation. This strategy is so successful that Perl programmers often do not suspect the ambivalence of what they write. But from time to time, Perl's notions differ substantially from what the author honestly meant.</source>
          <target state="translated">いくつかの異なる解釈があるかもしれない何かが提示されると、Perlは&lt;b&gt;DWIM&lt;/b&gt;（「何を意味するか」）の原則を使用して、最も可能性の高い解釈を選択します。この戦略は非常に成功しているため、Perlプログラマーは多くの場合、自分が書いたもののあいまいさを疑うことはありません。しかし、時々、Perlの概念は作者が正直に言ったものとは大幅に異なります。</target>
        </trans-unit>
        <trans-unit id="3ad187dab51002d9f1db84c4af0c7454d06b80be" translate="yes" xml:space="preserve">
          <source>When printed, a complex number is usually shown under its cartesian style</source>
          <target state="translated">印刷される場合、複素数は通常、その直交スタイルの下に表示されます。</target>
        </trans-unit>
        <trans-unit id="5caa7cd7539097bbbb349ec1e585b2c803d154a7" translate="yes" xml:space="preserve">
          <source>When prompted, pick a subject that summarizes your changes.</source>
          <target state="translated">プロンプトが表示されたら、あなたの変更点を要約する件名を選択します。</target>
        </trans-unit>
        <trans-unit id="0c308dc95015b79380949643660ba2048891c6cf" translate="yes" xml:space="preserve">
          <source>When putting items into &lt;code&gt;%^H&lt;/code&gt; , in order to avoid conflicting with other users of the hash there is a convention regarding which keys to use. A module should use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; .</source>
          <target state="translated">アイテムを &lt;code&gt;%^H&lt;/code&gt; 入れるとき、ハッシュの他のユーザーとの競合を避けるために、どのキーを使用するかに関する規約があります。モジュールは、モジュールの名前（メインパッケージの名前）と &quot;/&quot;文字で始まるキーのみを使用する必要があります。たとえば、モジュール &lt;code&gt;Foo::Bar&lt;/code&gt; は &lt;code&gt;Foo::Bar/baz&lt;/code&gt; などのキーを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="5a9430143108ce24dc19010d3dec0a88276a16a9" translate="yes" xml:space="preserve">
          <source>When putting items into &lt;code&gt;%^H&lt;/code&gt;, in order to avoid conflicting with other users of the hash there is a convention regarding which keys to use. A module should use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt;.</source>
          <target state="translated">アイテムを &lt;code&gt;%^H&lt;/code&gt; 入れるとき、ハッシュの他のユーザーとの競合を避けるために、使用するキーに関する規則があります。モジュールは、モジュールの名前（メインパッケージの名前）と「/」文字で始まるキーのみを使用する必要があります。たとえば、モジュール &lt;code&gt;Foo::Bar&lt;/code&gt; は、 &lt;code&gt;Foo::Bar/baz&lt;/code&gt; などのキーを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="97c16015d247b91d71c9d2f79344302034231eb3" translate="yes" xml:space="preserve">
          <source>When reading from a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before reading.</source>
          <target state="translated">ファイルまたはファイルハンドルから読み取る場合は、読み取る前に &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; を設定します。</target>
        </trans-unit>
        <trans-unit id="0711f567d0b9b4a99904ebf4ffdf5f0a6e3dd27c" translate="yes" xml:space="preserve">
          <source>When reading from a socket, remember that the default input record separator &lt;a href=&quot;perlvar#%24%2F&quot;&gt;&lt;code&gt;$/&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;\n&lt;/code&gt;, but robust socket code will recognize as either &lt;code&gt;\012&lt;/code&gt; or &lt;code&gt;\015\012&lt;/code&gt; as end of line:</source>
          <target state="translated">ソケットから読み取る場合、デフォルトの入力レコード区切り文字&lt;a href=&quot;perlvar#%24%2F&quot;&gt; &lt;code&gt;$/&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;\n&lt;/code&gt; ですが、堅牢なソケットコードは行末として &lt;code&gt;\012&lt;/code&gt; または &lt;code&gt;\015\012&lt;/code&gt; として認識されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f0130766d53ae0779f7ffce6dac2883bf210c349" translate="yes" xml:space="preserve">
          <source>When reading from a socket, remember that the default input record separator &lt;code&gt;$/&lt;/code&gt; is &lt;code&gt;\n&lt;/code&gt; , but robust socket code will recognize as either &lt;code&gt;\012&lt;/code&gt; or &lt;code&gt;\015\012&lt;/code&gt; as end of line:</source>
          <target state="translated">ソケットから読み取る場合、デフォルトの入力レコード区切り記号 &lt;code&gt;$/&lt;/code&gt; は &lt;code&gt;\n&lt;/code&gt; ですが、堅牢なソケットコードは行の終わりとして &lt;code&gt;\012&lt;/code&gt; または &lt;code&gt;\015\012&lt;/code&gt; として認識します。</target>
        </trans-unit>
        <trans-unit id="ff12069c161fb8190739473ed34f724f30594524" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::AnyInflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">圧縮された入力データを読み取るとき、IO :: Uncompress :: AnyInflateは &lt;code&gt;$num&lt;/code&gt; バイトのブロックでそれを読み取ります。</target>
        </trans-unit>
        <trans-unit id="16d4e8c4e7b7384f70b2f1766cc139537265740d" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::AnyUncompress will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">圧縮された入力データを読み取るとき、IO :: Uncompress :: AnyUncompressは &lt;code&gt;$num&lt;/code&gt; バイトのブロックでそれを読み取ります。</target>
        </trans-unit>
        <trans-unit id="32ca9aeb1f06332449d6eb9320261dff0e66b312" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Bunzip2 will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">圧縮された入力データを読み取るとき、IO :: Uncompress :: Bunzip2は &lt;code&gt;$num&lt;/code&gt; バイトのブロックでそれを読み取ります。</target>
        </trans-unit>
        <trans-unit id="50715bb3c754686d721e8aea919c37db141e1994" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Gunzip will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">圧縮された入力データを読み取るとき、IO :: Uncompress :: Gunzipは &lt;code&gt;$num&lt;/code&gt; バイトのブロックでそれを読み取ります。</target>
        </trans-unit>
        <trans-unit id="59f000056402b83ac85f2986c043bbc1a33d0339" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Inflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">圧縮された入力データを読み取るとき、IO :: Uncompress :: Inflateは &lt;code&gt;$num&lt;/code&gt; バイトのブロックでそれを読み取ります。</target>
        </trans-unit>
        <trans-unit id="07686b740fde1338aeadfd29d15b206d9e710502" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::RawInflate will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">圧縮された入力データを読み取るとき、IO :: Uncompress :: RawInflateは &lt;code&gt;$num&lt;/code&gt; バイトのブロックでそれを読み取ります。</target>
        </trans-unit>
        <trans-unit id="f6933aca30493bfe2ae64d115f3d25c9d4614976" translate="yes" xml:space="preserve">
          <source>When reading the compressed input data, IO::Uncompress::Unzip will read it in blocks of &lt;code&gt;$num&lt;/code&gt; bytes.</source>
          <target state="translated">圧縮された入力データを読み取るとき、IO :: Uncompress :: Unzipは &lt;code&gt;$num&lt;/code&gt; バイトのブロックでそれを読み取ります。</target>
        </trans-unit>
        <trans-unit id="4d74245b43f70a678ebe3b1f9167c1e1ba7b4408" translate="yes" xml:space="preserve">
          <source>When referenced, &lt;code&gt;$!&lt;/code&gt; retrieves the current value of the C &lt;code&gt;errno&lt;/code&gt; integer variable. If &lt;code&gt;$!&lt;/code&gt; is assigned a numerical value, that value is stored in &lt;code&gt;errno&lt;/code&gt; . When referenced as a string, &lt;code&gt;$!&lt;/code&gt; yields the system error string corresponding to &lt;code&gt;errno&lt;/code&gt; .</source>
          <target state="translated">参照されると、 &lt;code&gt;$!&lt;/code&gt; C &lt;code&gt;errno&lt;/code&gt; 整数変数の現在の値を取得します。もし &lt;code&gt;$!&lt;/code&gt; 数値が割り当てられている場合、その値は &lt;code&gt;errno&lt;/code&gt; に格納されます。文字列として参照される場合、 &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;errno&lt;/code&gt; に対応するシステムエラー文字列を生成します。</target>
        </trans-unit>
        <trans-unit id="f4a6f2c4dbed65f11dd2dadedd0a40b92fb0de8b" translate="yes" xml:space="preserve">
          <source>When referenced, &lt;code&gt;$!&lt;/code&gt; retrieves the current value of the C &lt;code&gt;errno&lt;/code&gt; integer variable. If &lt;code&gt;$!&lt;/code&gt; is assigned a numerical value, that value is stored in &lt;code&gt;errno&lt;/code&gt;. When referenced as a string, &lt;code&gt;$!&lt;/code&gt; yields the system error string corresponding to &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">参照される場合、 &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;errno&lt;/code&gt; 整数変数の現在の値を取得します。 &lt;code&gt;$!&lt;/code&gt; なら！数値が割り当てられ、その値は &lt;code&gt;errno&lt;/code&gt; に格納されます。文字列として参照される場合、 &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;errno&lt;/code&gt; に対応するシステムエラー文字列を生成します。</target>
        </trans-unit>
        <trans-unit id="27e9bf02eb38760deb66646d65b7d40e7944e879" translate="yes" xml:space="preserve">
          <source>When referring to characters by using a E&amp;lt;n&amp;gt; numeric code, numbers in the range 32-126 refer to those well known US-ASCII characters (also defined there by Unicode, with the same meaning), which all Pod formatters must render faithfully. Characters whose E&amp;lt;&amp;gt; numbers are in the ranges 0-31 and 127-159 should not be used (neither as literals, nor as E&amp;lt;number&amp;gt; codes), except for the literal byte-sequences for newline (ASCII 13, ASCII 13 10, or ASCII 10), and tab (ASCII 9).</source>
          <target state="translated">E &amp;lt;n&amp;gt;数値コードを使用して文字を参照する場合、32〜126の範囲の数字は、すべてのポッドフォーマッタが忠実にレンダリングする必要がある、よく知られているUS-ASCII文字（同じ意味でUnicodeでも定義されています）を参照します。 。改行のリテラルバイトシーケンス（ASCII 13、ASCII 13）を除いて、E &amp;lt;&amp;gt;番号が0-31および127-159の範囲にある文字は使用できません（リテラルとしてもE &amp;lt;number&amp;gt;コードとしても） 10、またはASCII 10）、およびタブ（ASCII 9）。</target>
        </trans-unit>
        <trans-unit id="df6e47ff65713a910476ca008419bf15d9f92656" translate="yes" xml:space="preserve">
          <source>When registering new categories of warning, you can supply more names to warnings::register like this:</source>
          <target state="translated">警告の新しいカテゴリを登録する際には、以下のようにwarnings::registerにさらに多くの名前を与えることができます。</target>
        </trans-unit>
        <trans-unit id="59e513d53fd0a8e9868f35002e2f8f73a3de8302" translate="yes" xml:space="preserve">
          <source>When removing directory trees, if you want to examine each file to decide whether to delete it (and possibly leaving large swathes alone),</source>
          <target state="translated">ディレクトリツリーを削除する際に、各ファイルを調べて削除するかどうかを決めたい場合(そして、場合によっては大きなスワースだけを残す場合もあります)には、ディレクトリツリーを削除します。</target>
        </trans-unit>
        <trans-unit id="ca0ea7cec59778756e53aaa7191d9a85c0fefd1a" translate="yes" xml:space="preserve">
          <source>When rendering Pod to a format that allows comments (i.e., to nearly any format other than plaintext), a Pod formatter must insert comment text identifying its name and version number, and the name and version numbers of any modules it might be using to process the Pod. Minimal examples:</source>
          <target state="translated">Podをコメントを許可する形式にレンダリングする場合(つまり、プレーンテキスト以外のほぼすべての形式にレンダリングする場合)、Podのフォーマッタは、その名前とバージョン番号、Podを処理するために使用している可能性のあるモジュールの名前とバージョン番号を示すコメントテキストを挿入しなければなりません。最小限の例を示します。</target>
        </trans-unit>
        <trans-unit id="2ad27da5819e821c8cd5bf0434eaf270b819ceff" translate="yes" xml:space="preserve">
          <source>When rendering Pod to a format that has two kinds of hyphens (-), one that's a non-breaking hyphen, and another that's a breakable hyphen (as in &quot;object-oriented&quot;, which can be split across lines as &quot;object-&quot;, newline, &quot;oriented&quot;), formatters are encouraged to generally translate &quot;-&quot; to non-breaking hyphen, but may apply heuristics to convert some of these to breaking hyphens.</source>
          <target state="translated">2種類のハイフン(-)を持つフォーマットにPodをレンダリングする際には、非区切りハイフンと区切りハイフン(「object-oriented」のように、「object-&quot;,newline,&quot;oriented &quot;のように線をまたいで分割することができます)の2種類のハイフンを持つフォーマットでは、フォーマッタは一般的に&quot;-&quot;を非区切りハイフンに変換することが推奨されますが、これらの一部を区切りハイフンに変換するためにヒューリスティックを適用しても構いません。</target>
        </trans-unit>
        <trans-unit id="f52c5a574eb5f1fd47869d07460df5abd7dd5137" translate="yes" xml:space="preserve">
          <source>When reporting a bug, please run through this checklist:</source>
          <target state="translated">バグを報告する際には、このチェックリストを実行してください。</target>
        </trans-unit>
        <trans-unit id="8b6bb8cb7867586650585befc2c1fd8387be0539" translate="yes" xml:space="preserve">
          <source>When reporting bugs/problems please include as much information as possible. It may be difficult for me to reproduce the problem as almost every setup is different.</source>
          <target state="translated">バグや問題を報告する際には、できるだけ多くの情報を記載してください。ほとんどすべての設定が異なるため、問題を再現するのは難しいかもしれません。</target>
        </trans-unit>
        <trans-unit id="f2af35fcfc2870add3a574f13c6598d925c1d896" translate="yes" xml:space="preserve">
          <source>When resolving a request for a global DLL, the table of already-loaded specific DLLs is (effectively) ignored; moreover, specific DLLs are</source>
          <target state="translated">グローバル DLL のリクエストを解決するとき、すでにロードされている特定の DLL のテーブルは (事実上)無視されます。</target>
        </trans-unit>
        <trans-unit id="62379e9d05e773d7f9a20bc63493ce786aebefd0" translate="yes" xml:space="preserve">
          <source>When returning a C array to Perl the XS writer must provide an integer variable called &lt;code&gt;size_$var&lt;/code&gt; containing the number of elements in the array. This is used to determine how many elements should be pushed onto the return argument stack. This is not required on input since Perl knows how many arguments are on the stack when the routine is called. Ordinarily this variable would be called &lt;code&gt;size_RETVAL&lt;/code&gt; .</source>
          <target state="translated">C配列をPerlに返すとき、XSライターは配列の要素数を含む &lt;code&gt;size_$var&lt;/code&gt; と呼ばれる整数変数を提供する必要があります。これは、戻り引数スタックにプッシュされる要素の数を決定するために使用されます。ルーチンが呼び出されたとき、Perlはスタックにある引数の数を知っているため、これは入力では必要ありません。通常、この変数は &lt;code&gt;size_RETVAL&lt;/code&gt; と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="977e07d16b270182693f540dd1711d684d80c08a" translate="yes" xml:space="preserve">
          <source>When returning a C array to Perl the XS writer must provide an integer variable called &lt;code&gt;size_$var&lt;/code&gt; containing the number of elements in the array. This is used to determine how many elements should be pushed onto the return argument stack. This is not required on input since Perl knows how many arguments are on the stack when the routine is called. Ordinarily this variable would be called &lt;code&gt;size_RETVAL&lt;/code&gt;.</source>
          <target state="translated">C配列をPerlに返す場合、XSライターは、配列内の要素の数を含む &lt;code&gt;size_$var&lt;/code&gt; という整数変数を提供する必要があります。これは、戻り引数スタックにプッシュする要素の数を決定するために使用されます。Perlは、ルーチンが呼び出されたときにスタック上にある引数の数を知っているため、これは入力では必要ありません。通常、この変数は &lt;code&gt;size_RETVAL&lt;/code&gt; と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="8ca08b2641f1d92e43e0d4ac166dca80cda23751" translate="yes" xml:space="preserve">
          <source>When returning a non-null result the type of the return is relevant. If it is an AV then the elements of the AV are the weak reference RVs which point at this item. If it is any other type then the item itself is the weak reference.</source>
          <target state="translated">非ヌルでない結果を返す場合、戻り値の型が関係しています。それがAVであれば、AVの要素はこのアイテムを指す弱い参照RVになります。それが他の型であれば、その項目自体が弱い参照です。</target>
        </trans-unit>
        <trans-unit id="97489cccab69eb1d35c1a341e128a78067c55f21" translate="yes" xml:space="preserve">
          <source>When rounding a number, different 'styles' or 'kinds' of rounding are possible. (Note that random rounding, as in Math::Round, is not implemented.)</source>
          <target state="translated">数値を丸めるときには、さまざまな「スタイル」や「種類」の丸めが可能です。(Math::Round のようなランダム丸めは実装されていないことに注意してください)。</target>
        </trans-unit>
        <trans-unit id="b2582b20778ca5521eeab7f1f747014dfe26c89f" translate="yes" xml:space="preserve">
          <source>When run it produces this output</source>
          <target state="translated">実行すると、以下のような出力が得られます。</target>
        </trans-unit>
        <trans-unit id="160ab26c7ebae1afd875b8a69bb2544386a0a133" translate="yes" xml:space="preserve">
          <source>When run, the script will produce this error message:</source>
          <target state="translated">スクリプトを実行すると、このようなエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="5d4a1a1df4c481bafe8952728953b7a8106417f0" translate="yes" xml:space="preserve">
          <source>When running &lt;code&gt;perl Makefile.PL&lt;/code&gt; , the environment variable &lt;code&gt;PERL5_CPAN_IS_EXECUTING&lt;/code&gt; is set to the full path of the &lt;code&gt;Makefile.PL&lt;/code&gt; that is being executed. This prevents runaway processes with newer versions of Module::Install.</source>
          <target state="translated">実行している場合 &lt;code&gt;perl Makefile.PL&lt;/code&gt; 、環境変数 &lt;code&gt;PERL5_CPAN_IS_EXECUTING&lt;/code&gt; はの完全なパスに設定されている &lt;code&gt;Makefile.PL&lt;/code&gt; 実行されています。これにより、新しいバージョンのModule :: Installで暴走するプロセスが防止されます。</target>
        </trans-unit>
        <trans-unit id="89350694f65316ce98eae1ce7d3a0891e9c042c8" translate="yes" xml:space="preserve">
          <source>When running as the superuser, don't attempt drop privileges for security. This option is implied with &lt;b&gt;-F&lt;/b&gt;.</source>
          <target state="translated">スーパーユーザーとして実行しているときは、セキュリティのために特権を削除しようとしないでください。このオプションは&lt;b&gt;-F&lt;/b&gt;で暗示されます。</target>
        </trans-unit>
        <trans-unit id="04666da2a46dba8c376f71b404386c5bd13c8146" translate="yes" xml:space="preserve">
          <source>When running taint checks, either because the program was running setuid or setgid, or the &lt;a href=&quot;#-T&quot;&gt;&quot;-T&quot;&lt;/a&gt; or &lt;a href=&quot;#-t&quot;&gt;&quot;-t&quot;&lt;/a&gt; switch was specified, neither PERL5LIB nor &lt;a href=&quot;#PERLLIB&quot;&gt;&quot;PERLLIB&quot;&lt;/a&gt; is consulted. The program should instead say:</source>
          <target state="translated">プログラムがsetuidまたはsetgidを実行していたか、&lt;a href=&quot;#-T&quot;&gt;「-T」&lt;/a&gt;または&lt;a href=&quot;#-t&quot;&gt;「-t」&lt;/a&gt;スイッチが指定されていたために汚染チェックを実行する場合、PERL5LIBも&lt;a href=&quot;#PERLLIB&quot;&gt;「PERLLIB」&lt;/a&gt;も参照されません。プログラムは代わりに言うべきです：</target>
        </trans-unit>
        <trans-unit id="2495ae50df460c2e127a2a6fc0eec9930e9be952" translate="yes" xml:space="preserve">
          <source>When running taint checks, either because the program was running setuid or setgid, or the &lt;b&gt;-T&lt;/b&gt; or &lt;b&gt;-t&lt;/b&gt; switch was specified, neither PERL5LIB nor PERLLIB is consulted. The program should instead say:</source>
          <target state="translated">汚染チェックを実行するとき、プログラムがsetuidまたはsetgidを実行しているか、&lt;b&gt;-T&lt;/b&gt;または&lt;b&gt;-t&lt;/b&gt;スイッチが指定されていたため、PERL5LIBもPERLLIBも参照されません。プログラムは代わりに言うべきです：</target>
        </trans-unit>
        <trans-unit id="7b3cb45c9a7da578dedba06cdb9f023a384333cd" translate="yes" xml:space="preserve">
          <source>When running this program, redirect &lt;code&gt;STDOUT&lt;/code&gt; so it is possible to check the output is correct from following test runs and use the system &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; utility to check the overall runtime.</source>
          <target state="translated">このプログラムを実行するときは、 &lt;code&gt;STDOUT&lt;/code&gt; をリダイレクトして、以下のテスト実行から出力が正しいことを確認し、システム &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; ユーティリティを使用して全体的なランタイムを確認できるようにします。</target>
        </trans-unit>
        <trans-unit id="206d7f06e0a05581fe8e0f140b59c4f2ebd75b9b" translate="yes" xml:space="preserve">
          <source>When running this program, redirect &lt;code&gt;STDOUT&lt;/code&gt; so it is possible to check the output is correct from following test runs and use the system &lt;code&gt;time&lt;/code&gt; utility to check the overall runtime.</source>
          <target state="translated">このプログラムを実行するときは、 &lt;code&gt;STDOUT&lt;/code&gt; をリダイレクトして、次のテスト実行から出力が正しいことを確認し、システム &lt;code&gt;time&lt;/code&gt; ユーティリティを使用して全体の実行時間を確認できるようにします。</target>
        </trans-unit>
        <trans-unit id="7975efeb25c8aaa03ac880e03163e48a54218208" translate="yes" xml:space="preserve">
          <source>When running under Eunice this variable contains a command which will convert a shell script to the proper form of text file for it to be executable by the shell. On other systems it is a no-op.</source>
          <target state="translated">Eunice の下で実行している場合、この変数にはシェルスクリプトを適切な形式のテキストファイルに変換し、シェルが実行できるようにするコマンドが含まれています。他のシステムでは、この変数は何もしません。</target>
        </trans-unit>
        <trans-unit id="e969971baf41c84189fecb4a510a18aaa7b43b6a" translate="yes" xml:space="preserve">
          <source>When running with taint checks enabled, indicates via &lt;code&gt;maybe_tainted&lt;/code&gt; if results are untrustworthy (often due to the use of locales).</source>
          <target state="translated">汚染チェックを有効にして実行している場合、結果が信頼できないかどうかを &lt;code&gt;maybe_tainted&lt;/code&gt; 経由で示します（多くの場合、ロケールの使用が原因です）。</target>
        </trans-unit>
        <trans-unit id="6d6a46b32d19b77f807e82e4b0a5dbfd16227ea7" translate="yes" xml:space="preserve">
          <source>When safe signals is in effect (the default behavior - see &lt;a href=&quot;#Unsafe-signals&quot;&gt;&quot;Unsafe signals&quot;&lt;/a&gt; for more details), then signals may be sent and acted upon by individual threads.</source>
          <target state="translated">安全なシグナルが有効な場合（デフォルトの動作-詳細については&lt;a href=&quot;#Unsafe-signals&quot;&gt;「安全でないシグナル」&lt;/a&gt;を参照）、シグナルが送信され、個々のスレッドによって処理される場合があります。</target>
        </trans-unit>
        <trans-unit id="401f0ab26dc2fddd741da0955da0f9c560a5d28d" translate="yes" xml:space="preserve">
          <source>When safe signals is in effect (the default behavior - see &lt;a href=&quot;#Unsafe-signals&quot;&gt;Unsafe signals&lt;/a&gt; for more details), then signals may be sent and acted upon by individual threads.</source>
          <target state="translated">安全な信号が有効な場合（デフォルトの動作-詳細については「&lt;a href=&quot;#Unsafe-signals&quot;&gt;安全でない信号」&lt;/a&gt;を参照）、信号が送信され、個々のスレッドによって処理されます。</target>
        </trans-unit>
        <trans-unit id="dba60ff6fd07f256c35eeeb0201541b7eaafeee0" translate="yes" xml:space="preserve">
          <source>When satisfied with the results, rerun the &lt;code&gt;installcmd&lt;/code&gt; target. Now you can copy &lt;code&gt;perl5.8.2.exe&lt;/code&gt; to &lt;code&gt;perl.exe&lt;/code&gt; , and install the other OMF-build executables: &lt;code&gt;perl__.exe&lt;/code&gt; etc. They are ready to be used.</source>
          <target state="translated">結果に満足したら、 &lt;code&gt;installcmd&lt;/code&gt; ターゲットを再実行します。これで、 &lt;code&gt;perl5.8.2.exe&lt;/code&gt; を &lt;code&gt;perl.exe&lt;/code&gt; にコピーして、他のOMFビルド実行可能ファイル（ &lt;code&gt;perl__.exe&lt;/code&gt; など）をインストールできます。これらは使用する準備ができています。</target>
        </trans-unit>
        <trans-unit id="f3274597eb7d5805f670851614bcfbd7d2f840a5" translate="yes" xml:space="preserve">
          <source>When satisfied with the results, rerun the &lt;code&gt;installcmd&lt;/code&gt; target. Now you can copy &lt;code&gt;perl5.8.2.exe&lt;/code&gt; to &lt;code&gt;perl.exe&lt;/code&gt;, and install the other OMF-build executables: &lt;code&gt;perl__.exe&lt;/code&gt; etc. They are ready to be used.</source>
          <target state="translated">結果に満足したら、 &lt;code&gt;installcmd&lt;/code&gt; ターゲットを再実行します。これで、 &lt;code&gt;perl5.8.2.exe&lt;/code&gt; を &lt;code&gt;perl.exe&lt;/code&gt; にコピーし、他のOMFビルド実行可能ファイル（ &lt;code&gt;perl__.exe&lt;/code&gt; など）をインストールできます。これらはすぐに使用できます。</target>
        </trans-unit>
        <trans-unit id="64d487e30347818adf665d0d1f254f13a4106809" translate="yes" xml:space="preserve">
          <source>When saving source, include evals that generate no subroutines.</source>
          <target state="translated">ソースを保存する際には、サブルーチンを生成しないエバールを含めます。</target>
        </trans-unit>
        <trans-unit id="c90d39de52f44bc4955e7d1999e5bc6bf1c25af5" translate="yes" xml:space="preserve">
          <source>When saving source, include source that did not compile.</source>
          <target state="translated">ソースを保存する際に、コンパイルされなかったソースを含めるようにしました。</target>
        </trans-unit>
        <trans-unit id="398d8ece97f780e7acaac52b6e525bbaea7d6236" translate="yes" xml:space="preserve">
          <source>When searching for single-character delimiters, escaped delimiters and &lt;code&gt;\\&lt;/code&gt; are skipped. For example, while searching for terminating &lt;code&gt;/&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\/&lt;/code&gt; are skipped. If the delimiters are bracketing, nested pairs are also skipped. For example, while searching for a closing &lt;code&gt;]&lt;/code&gt; paired with the opening &lt;code&gt;[&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; , &lt;code&gt;\]&lt;/code&gt;, and &lt;code&gt;\[&lt;/code&gt; are all skipped, and nested &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; are skipped as well. However, when backslashes are used as the delimiters (like &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq\\&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr\\\&lt;/a&gt;&lt;/code&gt;), nothing is skipped. During the search for the end, backslashes that escape delimiters or other backslashes are removed (exactly speaking, they are not copied to the safe location).</source>
          <target state="translated">単一文字の区切り文字を検索する場合、エスケープされた区切り文字と &lt;code&gt;\\&lt;/code&gt; はスキップされます。たとえば、終端の &lt;code&gt;/&lt;/code&gt; を検索しているとき、 &lt;code&gt;\\&lt;/code&gt; と &lt;code&gt;\/&lt;/code&gt; 組み合わせはスキップされます。区切り文字がブラケットの場合、ネストされたペアもスキップされます。たとえば、開始 &lt;code&gt;[&lt;/code&gt; と組み合わせて終了 &lt;code&gt;]&lt;/code&gt; を検索する場合、 &lt;code&gt;\\&lt;/code&gt; 、 &lt;code&gt;\]&lt;/code&gt; 、および &lt;code&gt;\[&lt;/code&gt; 組み合わせはすべてスキップされ、ネストされた &lt;code&gt;[&lt;/code&gt; および &lt;code&gt;]&lt;/code&gt; もスキップされます。ただし、バックスラッシュが区切り文字として使用されている場合（ &lt;code&gt;&lt;a href=&quot;functions/qq&quot;&gt;qq\\&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr\\\&lt;/a&gt;&lt;/code&gt; ）、何もスキップされません。末尾の検索中に、区切り文字やその他のバックスラッシュをエスケープするバックスラッシュが削除されます（正確には、安全な場所にコピーされません）。</target>
        </trans-unit>
        <trans-unit id="15bd46317800c6a271d171bbf86328e23d6c92d4" translate="yes" xml:space="preserve">
          <source>When searching for single-character delimiters, escaped delimiters and &lt;code&gt;\\&lt;/code&gt; are skipped. For example, while searching for terminating &lt;code&gt;/&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt; and &lt;code&gt;\/&lt;/code&gt; are skipped. If the delimiters are bracketing, nested pairs are also skipped. For example, while searching for a closing &lt;code&gt;]&lt;/code&gt; paired with the opening &lt;code&gt;[&lt;/code&gt;, combinations of &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;\]&lt;/code&gt;, and &lt;code&gt;\[&lt;/code&gt; are all skipped, and nested &lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt; are skipped as well. However, when backslashes are used as the delimiters (like &lt;code&gt;qq\\&lt;/code&gt; and &lt;code&gt;tr\\\&lt;/code&gt;), nothing is skipped. During the search for the end, backslashes that escape delimiters or other backslashes are removed (exactly speaking, they are not copied to the safe location).</source>
          <target state="translated">1文字の区切り文字を検索する場合、エスケープされた区切り文字と &lt;code&gt;\\&lt;/code&gt; はスキップされます。たとえば、終了 &lt;code&gt;/&lt;/code&gt; を検索している間、 &lt;code&gt;\\&lt;/code&gt; と &lt;code&gt;\/&lt;/code&gt; 組み合わせはスキップされます。区切り文字が括弧で囲まれている場合、ネストされたペアもスキップされます。たとえば、開始 &lt;code&gt;[&lt;/code&gt; 、とペアになっている終了 &lt;code&gt;]&lt;/code&gt; を検索する場合、 &lt;code&gt;\\&lt;/code&gt; 、 &lt;code&gt;\]&lt;/code&gt; 、および &lt;code&gt;\[&lt;/code&gt; 組み合わせはすべてスキップされ、ネストされた &lt;code&gt;[&lt;/code&gt; および &lt;code&gt;]&lt;/code&gt; もスキップされます。ただし、バックスラッシュが区切り文字として使用されている場合（ &lt;code&gt;qq\\&lt;/code&gt; や &lt;code&gt;tr\\\&lt;/code&gt; ）、何もスキップされません。末尾の検索中に、区切り文字をエスケープするバックスラッシュまたはその他のバックスラッシュが削除されます（正確に言えば、それらは安全な場所にコピーされません）。</target>
        </trans-unit>
        <trans-unit id="680861791c99e55f56913fa6b0dc2bd7ba150950" translate="yes" xml:space="preserve">
          <source>When sending an initial request to the security email address, please don't Cc any other parties, because if they reply to all, the reply will generate yet another new ticket. Once you have received an initial reply with a &lt;code&gt;[perl #NNNNNN]&lt;/code&gt; ticket number in the headline, it's okay to Cc subsequent replies to third parties: all emails to the perl5-security-report address with the ticket number in the subject line will be added to the ticket; without it, a new ticket will be created.</source>
          <target state="translated">セキュリティメールアドレスに最初のリクエストを送信するときは、他のパーティをCcしないでください。全員に返信すると、返信によってさらに別の新しいチケットが生成されます。見出しに &lt;code&gt;[perl #NNNNNN]&lt;/code&gt; チケット番号が記載された最初の返信を受け取ったら、その後のサードパーティへの返信は問題ありません。件名にチケット番号が記載されたperl5-security-reportアドレスへのすべてのメールはチケットに追加されました。それがないと、新しいチケットが作成されます。</target>
        </trans-unit>
        <trans-unit id="32c34df309dbf3ee7f15cd5785f504c8f035d38f" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;&quot;1&quot;&lt;/code&gt; or &lt;code&gt;&quot;RANDOM&quot;&lt;/code&gt; then traversing keys will be randomized. Every time a hash is inserted into the key order will change in a random fashion. The order may not be repeatable in a following program run even if the PERL_HASH_SEED has been specified. This is the default mode for perl.</source>
          <target state="translated">&lt;code&gt;&quot;1&quot;&lt;/code&gt; または &lt;code&gt;&quot;RANDOM&quot;&lt;/code&gt; 設定すると、移動キーがランダム化されます。ハッシュがキーの順序に挿入されるたびに、ランダムに変化します。PERL_HASH_SEEDが指定されている場合でも、次のプログラムの実行では順序を繰り返すことができない場合があります。これはperlのデフォルトモードです。</target>
        </trans-unit>
        <trans-unit id="04d0e5e2f5a4ede1100f0e4584215cbbf899e23b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;&quot;2&quot;&lt;/code&gt; or &lt;code&gt;&quot;DETERMINISTIC&quot;&lt;/code&gt; then inserting keys into a hash will cause the key order to change, but in a way that is repeatable from program run to program run.</source>
          <target state="translated">&lt;code&gt;&quot;2&quot;&lt;/code&gt; または &lt;code&gt;&quot;DETERMINISTIC&quot;&lt;/code&gt; 設定した場合、ハッシュにキーを挿入すると、キーの順序が変更されますが、プログラムの実行ごとに繰り返すことができます。</target>
        </trans-unit>
        <trans-unit id="9e7128c2c7dce5a0a3a9029329df5cbd50b2f0b7" translate="yes" xml:space="preserve">
          <source>When set to a true value, will cause &lt;code&gt;remove_tree&lt;/code&gt; to skip the files for which the process lacks the required privileges needed to delete files, such as delete privileges on VMS. In other words, the code will make no attempt to alter file permissions. Thus, if the process is interrupted, no filesystem object will be left in a more permissive mode.</source>
          <target state="translated">trueに設定すると、 &lt;code&gt;remove_tree&lt;/code&gt; は、VMSでの削除特権など、ファイルを削除するために必要な特権がプロセスに不足しているファイルをスキップします。つまり、コードはファイルのアクセス許可を変更しようとしません。したがって、プロセスが中断された場合、ファイルシステムオブジェクトはより寛容なモードのままになることはありません。</target>
        </trans-unit>
        <trans-unit id="c7f5dc6825eff7e1f171e69f42059c82111432c0" translate="yes" xml:space="preserve">
          <source>When set to a true value, will cause all files and subdirectories to be removed, except the initially specified directories. This comes in handy when cleaning out an application's scratch directory.</source>
          <target state="translated">true に設定すると、最初に指定したディレクトリ以外のすべてのファイルとサブディレクトリが削除されます。これは、アプリケーションのスクラッチディレクトリをクリーンアウトするときに便利です。</target>
        </trans-unit>
        <trans-unit id="a98ff16a4db26e40074379a02c1ac4736cef2e29" translate="yes" xml:space="preserve">
          <source>When set to true (default is false) this will reject any facets where a facet class cannot be found. Normally facets without classes are assumed to be custom and are ignored.</source>
          <target state="translated">true に設定されている場合(デフォルトは false)、これは、切子クラスが見つからない切子を拒否します。通常、クラスのない切子はカスタムとみなされ無視されます。</target>
        </trans-unit>
        <trans-unit id="2ff22a09dbb1fd01f1d9e27ed6ec106512c2eedc" translate="yes" xml:space="preserve">
          <source>When set, Data::Dumper will emit single, non-self-referential values as atoms/terms rather than statements. This means that the &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">設定すると、Data :: Dumperはステートメントではなく、アトム/用語として単一の非自己参照値を出力します。つまり、 &lt;code&gt;$VAR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fe8e786dd3039d8dd6d2bfab15396a2a2af496f5" translate="yes" xml:space="preserve">
          <source>When set, controls the network timeout (counted in seconds).</source>
          <target state="translated">設定すると、ネットワークのタイムアウトを制御します(秒単位でカウントされます)。</target>
        </trans-unit>
        <trans-unit id="b5e8c42abd62cd10178b1f40a287ed255997e01d" translate="yes" xml:space="preserve">
          <source>When set, enables the use of double quotes for representing string values. Whitespace other than space will be represented as &lt;code&gt;[\n\t\r]&lt;/code&gt; , &quot;unsafe&quot; characters will be backslashed, and unprintable characters will be output as quoted octal integers. The default is 0.</source>
          <target state="translated">設定すると、文字列値を表すための二重引用符の使用が有効になります。スペース以外の空白は &lt;code&gt;[\n\t\r]&lt;/code&gt; として表され、「安全でない」文字はバックスラッシュが付けられ、印刷できない文字は引用符付きの8進整数として出力されます。デフォルトは0です。</target>
        </trans-unit>
        <trans-unit id="9d1d9ef1336068db5d1ba9928d2591d51c52c62c" translate="yes" xml:space="preserve">
          <source>When set, enables the use of double quotes for representing string values. Whitespace other than space will be represented as &lt;code&gt;[\n\t\r]&lt;/code&gt;, &quot;unsafe&quot; characters will be backslashed, and unprintable characters will be output as quoted octal integers. The default is 0.</source>
          <target state="translated">設定すると、文字列値を表すために二重引用符を使用できるようになります。スペース以外の空白は &lt;code&gt;[\n\t\r]&lt;/code&gt; として表され、「安全でない」文字はバックスラッシュされ、印刷できない文字は引用符で囲まれた8進整数として出力されます。デフォルトは0です。</target>
        </trans-unit>
        <trans-unit id="e7c58b77eb133eea8c15ca3a9398533c775f314b" translate="yes" xml:space="preserve">
          <source>When should I decode or encode?</source>
          <target state="translated">いつデコードするか、エンコードするか?</target>
        </trans-unit>
        <trans-unit id="1dc62984ecca7c09ade87153ed4ccd6695dd04ce" translate="yes" xml:space="preserve">
          <source>When shouldn't I program in Perl?</source>
          <target state="translated">Perlでプログラミングをしてはいけないのはいつですか?</target>
        </trans-unit>
        <trans-unit id="ab11b33195a0de9ef0d3f4bb14477223addc7e28" translate="yes" xml:space="preserve">
          <source>When some mandatory fields are missing or invalid, the conversion will attempt to provide a sensible default or will fill them with a value of 'unknown'. For example a missing or unrecognized &lt;code&gt;license&lt;/code&gt; field will result in a &lt;code&gt;license&lt;/code&gt; field of 'unknown'. Fields that may get an 'unknown' include:</source>
          <target state="translated">一部の必須フィールドが欠落しているか無効である場合、変換は適切なデフォルトを提供しようとするか、「不明」の値でそれらを埋めます。たとえば、 &lt;code&gt;license&lt;/code&gt; フィールドがないか認識されない場合、 &lt;code&gt;license&lt;/code&gt; フィールドは「不明」になります。「不明」になる可能性のあるフィールドは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="38a0e44be6c1f4e08e2750d9d92dbacbb5e6685b" translate="yes" xml:space="preserve">
          <source>When something is contained in something else, particularly when that might be considered surprising: &amp;ldquo;I&amp;rsquo;ve embedded a complete Perl interpreter in my editor!&amp;rdquo;</source>
          <target state="translated">何かが別の何かに含まれている場合、特にそれが意外と考えられる場合：「エディターに完全なPerlインタープリターを組み込んだ！」</target>
        </trans-unit>
        <trans-unit id="0a4af2a22b89ee59f46fa6ec1a2f89f7c8de8e00" translate="yes" xml:space="preserve">
          <source>When speaking about regexes we need to distinguish between their source code form and their internal form. In this document we will use the term &quot;pattern&quot; when we speak of their textual, source code form, and the term &quot;program&quot; when we speak of their internal representation. These correspond to the terms</source>
          <target state="translated">正規表現について話すときには、ソースコードの形式と内部の形式を区別する必要があります。このドキュメントでは、テキスト的なソース・コードの形式について話すときは「パターン」という用語を使用し、内部的な表現について話すときは「プログラム」という用語を使用します。これらは、以下の用語に対応しています。</target>
        </trans-unit>
        <trans-unit id="71fc37572f09658b981cd729d4958d3d9535564d" translate="yes" xml:space="preserve">
          <source>When specified (localised) in a module's</source>
          <target state="translated">モジュールの</target>
        </trans-unit>
        <trans-unit id="0b48aaafd2407a97f05ee6a676562dca0cfeebf8" translate="yes" xml:space="preserve">
          <source>When starting scripts directly, Perl uses exactly the same algorithm as for the search of script given by &lt;b&gt;-S&lt;/b&gt; command-line option: it will look in the current directory, then on components of &lt;code&gt;$ENV{PATH}&lt;/code&gt; using the following order of appended extensions: no extension,</source>
          <target state="translated">スクリプトを直接開始する場合、Perlは&lt;b&gt;-S&lt;/b&gt;コマンドラインオプションで指定されたスクリプトの検索とまったく同じアルゴリズムを使用します。現在のディレクトリを検索し、次に &lt;code&gt;$ENV{PATH}&lt;/code&gt; コンポーネントを次の順序で追加された拡張子で検索します。：拡張子なし、</target>
        </trans-unit>
        <trans-unit id="31501718ea48b1c7c96923d7f9ebcfb80e76fc7d" translate="yes" xml:space="preserve">
          <source>When storing doubles in network order, their value is stored as text. However, you should also not expect non-numeric floating-point values such as infinity and &quot;not a number&quot; to pass successfully through a nstore()/retrieve() pair.</source>
          <target state="translated">ネットワーク順にダブルスを格納する場合、その値はテキストとして格納されます。しかし、無限大や &quot;数ではない &quot;といった浮動小数点の数値以外の値が nstore()/retrieve()のペアを正常に通過することは期待しない方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="4e11b655699381504305f7887609ab8d634e504a" translate="yes" xml:space="preserve">
          <source>When stringified, &lt;code&gt;autodie::exception::system&lt;/code&gt; objects currently use the message generated by &lt;a href=&quot;IPC::System::Simple&quot;&gt;IPC::System::Simple&lt;/a&gt;.</source>
          <target state="translated">文字列化されると、 &lt;code&gt;autodie::exception::system&lt;/code&gt; オブジェクトは現在、&lt;a href=&quot;IPC::System::Simple&quot;&gt;IPC :: System :: Simple&lt;/a&gt;によって生成されたメッセージを使用します。</target>
        </trans-unit>
        <trans-unit id="85058aaefb4d2e0a77cba44540a9a1fa5a2d7ef7" translate="yes" xml:space="preserve">
          <source>When submitting a bug or request, please include a test-file or a patch to an existing test-file that illustrates the bug or desired feature.</source>
          <target state="translated">バグや要望を提出する際には、バグや希望する機能を説明するテストファイルや既存のテストファイルへのパッチを添付してください。</target>
        </trans-unit>
        <trans-unit id="aadbffec66a30c1a002a47c90a7b1248371d0324" translate="yes" xml:space="preserve">
          <source>When testing applications, often you find yourself needing to provide functionality in your test environment that would usually be provided by external modules. Rather than munging the &lt;code&gt;%INC&lt;/code&gt; by hand to mark these external modules as loaded, so they are not attempted to be loaded by perl, this module offers you a very simple way to mark modules as loaded and/or unloaded.</source>
          <target state="translated">アプリケーションをテストするとき、多くの場合、通常は外部モジュールによって提供される機能をテスト環境で提供する必要があることに気づきます。むしろいじるよりも、 &lt;code&gt;%INC&lt;/code&gt; を彼らはperlのでロードしようとしていないので、ロードされたとして、これらの外部モジュールをマークするために手で、マーク・モジュールにこのモジュールの提供あなたは非常に簡単な方法は、ロードおよび/またはアンロードとして。</target>
        </trans-unit>
        <trans-unit id="2ecf844cc9f858984bae81698225ab3522c9600d" translate="yes" xml:space="preserve">
          <source>When that is parsed and events are about to be called on it, it may actually seem to be four different text events, one right after another: one event for &quot;I just LOVE &quot;, one for &quot;hot&quot;, one for &quot; &quot;, and one for &quot;apple pie!&quot;. But if you have merge_text on, then you're guaranteed that it will be fired as one text event: &quot;I just LOVE hot apple pie!&quot;.</source>
          <target state="translated">これが解析されてイベントが呼び出されようとしたとき、実際には四つの異なるテキストイベントが次々と発生しているように見えるかもしれません:&quot;I just LOVE&quot; のイベント、&quot;hot&quot; のイベント、&quot; &quot; &quot; そして &quot;apple pie!&quot; のイベントです。しかし、merge_text をオンにしている場合は、一つのテキストイベントとして実行されることが保証されます。&quot;I just LOVE hot apple pie!</target>
        </trans-unit>
        <trans-unit id="961c445e33a9a31bd9e2652fe106daffb549bbdf" translate="yes" xml:space="preserve">
          <source>When that string is compiled from bracket notation into a real Perl sub, it's basically turned into:</source>
          <target state="translated">その文字列がブラケット記法から実際のPerlのサブにコンパイルされると、基本的には</target>
        </trans-unit>
        <trans-unit id="956082e29333281c1000de72a422a6d173c77cc1" translate="yes" xml:space="preserve">
          <source>When the # flag and a precision are given in the %o conversion, the precision is incremented if it's necessary for the leading &quot;0&quot;.</source>
          <target state="translated">#フラグと精度が%o変換で与えられた場合、先頭の &quot;0 &quot;が必要な場合は精度がインクリメントされます。</target>
        </trans-unit>
        <trans-unit id="aa880a320400827152fdc9bea63191360399d514" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;CVf_SLABBED&lt;/code&gt; flag is set, the CV takes responsibility for freeing the slab. If &lt;code&gt;CvROOT&lt;/code&gt; is not set when the CV is freed or undeffed, it is assumed that a compilation error has occurred, so the op slab is traversed and all the ops are freed.</source>
          <target state="translated">とき &lt;code&gt;CVf_SLABBED&lt;/code&gt; のフラグが設定され、CVはスラブを解放するための責任を取ります。CVが解放またはアンフェフされたときに &lt;code&gt;CvROOT&lt;/code&gt; が設定されていない場合は、コンパイルエラーが発生したと見なされるため、opスラブがトラバースされ、すべてのopsが解放されます。</target>
        </trans-unit>
        <trans-unit id="b4c77bd95ba1c8037180b07d06856855d317ef69" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is omitted or false, then the tied hash elements will be the contents of the leftmost defined buffer with the name of the associated hash key. In other words, the tied hash will behave as &lt;code&gt;%+&lt;/code&gt; .</source>
          <target state="translated">場合は &lt;code&gt;all&lt;/code&gt; パラメータを省略またはfalseをされ、その後、結ばれたハッシュ要素は、関連するハッシュキーの名前の一番左の定義されたバッファの内容になります。つまり、結合ハッシュは &lt;code&gt;%+&lt;/code&gt; として動作します。</target>
        </trans-unit>
        <trans-unit id="b92065de5607bb0c7a77a48e1cfce97eed7a26ac" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is omitted or false, then the tied hash elements will be the contents of the leftmost defined buffer with the name of the associated hash key. In other words, the tied hash will behave as &lt;code&gt;%+&lt;/code&gt;.</source>
          <target state="translated">場合は &lt;code&gt;all&lt;/code&gt; パラメータを省略またはfalseをされ、その後、結ばれたハッシュ要素は、関連するハッシュキーの名前の一番左の定義されたバッファの内容になります。つまり、タイハッシュは &lt;code&gt;%+&lt;/code&gt; として動作します。</target>
        </trans-unit>
        <trans-unit id="d840453ed70b6c8cd04f568b5e24263c8a47ca21" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is provided, then the tied hash elements will be array refs listing the contents of each capture buffer whose name is the same as the associated hash key. If none of these buffers were involved in the match, the contents of that array ref will be as many &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; values as there are capture buffers with that name. In other words, the tied hash will behave as &lt;code&gt;%-&lt;/code&gt; .</source>
          <target state="translated">場合 &lt;code&gt;all&lt;/code&gt; パラメータが提供され、その後、tieされたハッシュ要素は、名前、関連するハッシュキーと同じであり、各キャプチャバッファの内容をリストする配列リファレンスであろう。これらのバッファーのいずれも一致に関与しなかった場合、その配列refの内容は、その名前のキャプチャバッファーと同じ数の &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 値になります。つまり、結合ハッシュは &lt;code&gt;%-&lt;/code&gt; として動作します。</target>
        </trans-unit>
        <trans-unit id="7e2197c6d3b3d6c61f6564ab44ac2b44c0344d23" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;all&lt;/code&gt; parameter is provided, then the tied hash elements will be array refs listing the contents of each capture buffer whose name is the same as the associated hash key. If none of these buffers were involved in the match, the contents of that array ref will be as many &lt;code&gt;undef&lt;/code&gt; values as there are capture buffers with that name. In other words, the tied hash will behave as &lt;code&gt;%-&lt;/code&gt;.</source>
          <target state="translated">場合 &lt;code&gt;all&lt;/code&gt; パラメータが提供され、その後、tieされたハッシュ要素は、名前、関連するハッシュキーと同じであり、各キャプチャバッファの内容をリストする配列リファレンスであろう。これらのバッファのいずれも一致に関与していなかった場合、その配列refの内容は、その名前のキャプチャバッファと同じ数の &lt;code&gt;undef&lt;/code&gt; 値になります。つまり、タイハッシュは &lt;code&gt;%-&lt;/code&gt; として動作します。</target>
        </trans-unit>
        <trans-unit id="ad645af5beffff4dcf298e97bda326c957e193d6" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnix2&lt;/code&gt; option is present it will trigger the creation of a Unix2 extra field (ID is &quot;Ux&quot;) in the local zip header. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . An empty Unix2 extra field will also be created in the central zip header.</source>
          <target state="translated">とき &lt;code&gt;exUnix2&lt;/code&gt; のオプションが存在することは、ローカルのzipヘッダ内（IDは「UXの」です）Unix2余分なフィールドの作成をトリガーします。これには &lt;code&gt;$uid&lt;/code&gt; と &lt;code&gt;$gid&lt;/code&gt; が入力されます。空のUnix2追加フィールドも中央のzipヘッダーに作成されます。</target>
        </trans-unit>
        <trans-unit id="0db2965770fe8514e3fb9dd21cb17bd93496e99e" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnix2&lt;/code&gt; option is present it will trigger the creation of a Unix2 extra field (ID is &quot;Ux&quot;) in the local zip header. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt;. An empty Unix2 extra field will also be created in the central zip header.</source>
          <target state="translated">とき &lt;code&gt;exUnix2&lt;/code&gt; のオプションが存在することは、ローカルのzipヘッダ内（IDは「UXの」です）Unix2余分なフィールドの作成をトリガーします。これには、 &lt;code&gt;$uid&lt;/code&gt; と &lt;code&gt;$gid&lt;/code&gt; が入力されます。空のUnix2追加フィールドも中央のzipヘッダーに作成されます。</target>
        </trans-unit>
        <trans-unit id="40f9a81cf7aa8b00ade31d3ca1a070fc29516dbb" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnixN&lt;/code&gt; option is present it will trigger the creation of a UnixN extra field (ID is &quot;ux&quot;) in both the local and central zip headers. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt; . The UID &amp;amp; GID are stored as 32-bit integers.</source>
          <target state="translated">とき &lt;code&gt;exUnixN&lt;/code&gt; のオプションが存在している、それは両方のローカルおよび中央のジッパーヘッダー内（IDは「UX」である）UnixN余分なフィールドの作成をトリガーします。これには &lt;code&gt;$uid&lt;/code&gt; と &lt;code&gt;$gid&lt;/code&gt; が入力されます。UIDとGIDは32ビット整数として格納されます。</target>
        </trans-unit>
        <trans-unit id="f94a510aaa8dc7a162e9738895fa3812cc690de5" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;exUnixN&lt;/code&gt; option is present it will trigger the creation of a UnixN extra field (ID is &quot;ux&quot;) in both the local and central zip headers. This will be populated with &lt;code&gt;$uid&lt;/code&gt; and &lt;code&gt;$gid&lt;/code&gt;. The UID &amp;amp; GID are stored as 32-bit integers.</source>
          <target state="translated">とき &lt;code&gt;exUnixN&lt;/code&gt; のオプションが存在している、それは両方のローカルおよび中央のジッパーヘッダー内（IDは「UX」である）UnixN余分なフィールドの作成をトリガーします。これには、 &lt;code&gt;$uid&lt;/code&gt; と &lt;code&gt;$gid&lt;/code&gt; が入力されます。UIDとGIDは32ビット整数として保存されます。</target>
        </trans-unit>
        <trans-unit id="97ce970ca586eb9f9dd65ce4eb91d435bcb2b455" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;frame&lt;/code&gt; option is set, the debugger would print entered (and optionally exited) subroutines in different styles. See &lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt; for incredibly long examples of these.</source>
          <target state="translated">場合 &lt;code&gt;frame&lt;/code&gt; オプションがセットされ、デバッガは異なるスタイルで入力された（および必要に応じて終了）のサブルーチンを印刷することになります。これらの非常に長い例については、&lt;a href=&quot;perldebguts&quot;&gt;perldebguts&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="801df7cc1a118615aee66edb536ee9e06cf840b5" translate="yes" xml:space="preserve">
          <source>When the CPAN module is used for the first time, a configuration dialogue tries to determine a couple of site specific options. The result of the dialog is stored in a hash reference &lt;code&gt; $CPAN::Config &lt;/code&gt; in a file CPAN/Config.pm.</source>
          <target state="translated">CPANモジュールが初めて使用されるとき、構成ダイアログはいくつかのサイト固有のオプションを決定しようとします。ダイアログの結果は、ファイルCPAN / Config.pmのハッシュ参照 &lt;code&gt; $CPAN::Config &lt;/code&gt; に保存されます。</target>
        </trans-unit>
        <trans-unit id="7cb924f6e524bd0e1830b8259c680c4e75924eac" translate="yes" xml:space="preserve">
          <source>When the CPAN shell enters a subshell via the look command, it sets the environment CPAN_SHELL_LEVEL to 1, or increments that variable if it is already set.</source>
          <target state="translated">CPANシェルがlookコマンドを使用してサブシェルに入ると、環境CPAN_SHELL_LEVELを1に設定するか、すでに設定されている場合はその変数をインクリメントする。</target>
        </trans-unit>
        <trans-unit id="3650ff6a9d15f4cddf8e012952c2eb6d79121733" translate="yes" xml:space="preserve">
          <source>When the CPAN shell is started it normally displays a greeting message that contains the running version and the status of readline support.</source>
          <target state="translated">CPANシェルが起動すると、通常、実行中のバージョンと読取線サポートのステータスを含むグリーティングメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="3b2e82923d74c1d230a5130604df06c8f537a860" translate="yes" xml:space="preserve">
          <source>When the SV is read from or written to, the &lt;code&gt;uf_val&lt;/code&gt; or &lt;code&gt;uf_set&lt;/code&gt; function will be called with &lt;code&gt;uf_index&lt;/code&gt; as the first arg and a pointer to the SV as the second. A simple example of how to add &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic is shown below. Note that the ufuncs structure is copied by sv_magic, so you can safely allocate it on the stack.</source>
          <target state="translated">SVが読み書きされるとき、 &lt;code&gt;uf_val&lt;/code&gt; または &lt;code&gt;uf_set&lt;/code&gt; 関数は、最初の引数として &lt;code&gt;uf_index&lt;/code&gt; を使用し、2番目の引数としてSVへのポインターを使用して呼び出されます。 &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; マジックを追加する簡単な例を以下に示します。ufuncs構造体はsv_magicによってコピーされるため、スタックに安全に割り当てることができることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7cf75e5eda3afd46688cf75f69b185773f733453" translate="yes" xml:space="preserve">
          <source>When the Storable engine does not find any &lt;code&gt;STORABLE_thaw&lt;/code&gt; hook routine, it tries to load the class by requiring the package dynamically (using the blessed package name), and then re-attempts the lookup. If at that time the hook cannot be located, the engine croaks. Note that this mechanism will fail if you define several classes in the same file, but &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; warned you.</source>
          <target state="translated">Storableエンジンは、 &lt;code&gt;STORABLE_thaw&lt;/code&gt; フックルーチンを見つけられない場合、（bless されたパッケージ名を使用して）パッケージを動的に要求することによりクラスをロードしようとし、その後、ルックアップを再試行します。その時点でフックが見つからない場合、エンジンが鳴きます。同じファイルで複数のクラスを定義するとこのメカニズムは失敗しますが、&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;は警告を出します。</target>
        </trans-unit>
        <trans-unit id="d71b47dffe6d13e95919a44f8b1aab3c74c9a2ad" translate="yes" xml:space="preserve">
          <source>When the Windows and Arm DLLs are built do not be scared by a very long messages whizzing by: it is the &quot;export freeze&quot; phase where the whole (rather large) API of Perl is listed.</source>
          <target state="translated">WindowsとArmのDLLがビルドされているときには、非常に長いメッセージが飛び交っているので、怖がらないでください。</target>
        </trans-unit>
        <trans-unit id="44a6516f88b32cd0929f74947668f35c10106658" translate="yes" xml:space="preserve">
          <source>When the actual VMS termination status of the child is an error, internally the &lt;code&gt;$!&lt;/code&gt; value will be set to the closest Unix errno value to that error so that Perl scripts that test for error messages will see the expected Unix style error message instead of a VMS message.</source>
          <target state="translated">子の実際のVMS終了ステータスがエラーの場合、内部的に &lt;code&gt;$!&lt;/code&gt; valueは、そのエラーに最も近いUnix errno値に設定されるため、エラーメッセージをテストするPerlスクリプトは、VMSメッセージではなく、予期されるUnixスタイルのエラーメッセージを表示します。</target>
        </trans-unit>
        <trans-unit id="2e8f0d2ae12a2e39fe8c86870d0da6c283532175" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; for details.</source>
          <target state="translated">引数がシステムシェルを介して実行される場合、結果はその癖や機能の影響を受けます。詳細については&lt;a href=&quot;../perlop#%60STRING%60&quot;&gt;、perlopの「STRING」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ca28137b7d4a24f80f2a308158da006f7dc35dce" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;&quot;`STRING`&quot; in perlop&lt;/a&gt; for details.</source>
          <target state="translated">引数がシステムシェルを介して実行されると、結果はその癖と機能の影響を受けます。詳細については&lt;a href=&quot;perlop#%60STRING%60&quot;&gt;、perlopの「 `STRING`」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1fb744771cfcd60aec9ab66ef08b4b0d1508a2fd" translate="yes" xml:space="preserve">
          <source>When the arguments get executed via the system shell, results are subject to its quirks and capabilities. See &lt;a href=&quot;perlop#%60STRING%60&quot;&gt;`STRING` in perlop&lt;/a&gt; for details.</source>
          <target state="translated">引数がシステムシェルを介して実行される場合、結果はその癖や機能の影響を受けます。詳細については&lt;a href=&quot;perlop#%60STRING%60&quot;&gt;、perlopの「STRING」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7a639b80ea13083bb656ad3ace22f1641521ba99" translate="yes" xml:space="preserve">
          <source>When the base greater than 36, and no collation sequence is given, the default collation sequence contains both uppercase and lowercase letters, so the letter case in the input is not ignored:</source>
          <target state="translated">ベースが36よりも大きく、照合順序が与えられていない場合、デフォルトの照合順序には大文字と小文字の両方が含まれているため、入力中の文字の大文字小文字は無視されません。</target>
        </trans-unit>
        <trans-unit id="569274b14b45a92ddaed7462d32bdd3f4354e2b9" translate="yes" xml:space="preserve">
          <source>When the base is less than or equal to 36, and no collation sequence is given, the letter case is ignored, so both of these also return 250:</source>
          <target state="translated">ベースが36以下で、照合順序が与えられていない場合、文字の大文字小文字は無視されるので、どちらも250を返します。</target>
        </trans-unit>
        <trans-unit id="98ba3a0afa8ccd6c06c8d4acfe9a1d04b1ddc937" translate="yes" xml:space="preserve">
          <source>When the build environment has been set up, building and testing Perl is straightforward. The only thing you need to do is download the sources as usual, and add a file Policy.sh as follows:</source>
          <target state="translated">ビルド環境が整ったら、Perlのビルドとテストは簡単です。いつものようにソースをダウンロードして、以下のようにPolicy.shというファイルを追加するだけです。</target>
        </trans-unit>
        <trans-unit id="f8ca0edd57c85a2b69cd25fb457d6653721de135" translate="yes" xml:space="preserve">
          <source>When the class is inverted (&lt;code&gt;[^...]&lt;/code&gt;)</source>
          <target state="translated">クラスが反転したとき（ &lt;code&gt;[^...]&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="af5d3dc3800fc64d81a21bf6e187c8743b336401" translate="yes" xml:space="preserve">
          <source>When the class is to match caselessly under &lt;code&gt;/i&lt;/code&gt; matching rules, and a character that is explicitly mentioned inside the class matches a multiple-character sequence caselessly under Unicode rules, the class will also match that sequence. For example, Unicode says that the letter &lt;code&gt;LATIN SMALL LETTER SHARP S&lt;/code&gt; should match the sequence &lt;code&gt;ss&lt;/code&gt; under &lt;code&gt;/i&lt;/code&gt; rules. Thus,</source>
          <target state="translated">&lt;code&gt;/i&lt;/code&gt; マッチングルールでクラスが大文字と小文字を区別せずに一致し、クラス内で明示的に言及されている文字がUnicodeルールで大文字と小文字を区別せずに一致する場合、クラスもそのシーケンスに一致します。たとえば、Unicodeは文字がいることを言う &lt;code&gt;LATIN SMALL LETTER SHARP S&lt;/code&gt; 、シーケンス一致する必要があり &lt;code&gt;ss&lt;/code&gt; 下 &lt;code&gt;/i&lt;/code&gt; ルール。したがって、</target>
        </trans-unit>
        <trans-unit id="4739858b160d44355cadf7e584ea672d7f556732" translate="yes" xml:space="preserve">
          <source>When the code will run on only two or three operating systems, you may need to consider only the differences of those particular systems. The important thing is to decide where the code will run and to be deliberate in your decision.</source>
          <target state="translated">コードが2つか3つのオペレーティング・システムでしか実行されない場合、それらの特定のシステムの違いだけを考慮する必要があるかもしれません。重要なのは、コードを実行する場所を決め、慎重に決定することです。</target>
        </trans-unit>
        <trans-unit id="dfc1084fa585e179656ac972bdfbaccc526f6fbd" translate="yes" xml:space="preserve">
          <source>When the config variable ftp_passive is set, all downloads will be run with the environment variable FTP_PASSIVE set to this value. This is in general a good idea as it influences both Net::FTP and LWP based connections. The same effect can be achieved by starting the cpan shell with this environment variable set. For Net::FTP alone, one can also always set passive mode by running libnetcfg.</source>
          <target state="translated">設定変数 ftp_passive が設定されている場合、すべてのダウンロードは環境変数 FTP_PASSIVE がこの値に設定された状態で実行される。これは、Net::FTP と LWP ベースの接続の両方に影響を与えるので、一般的には良い考えです。この環境変数を設定した状態で cpan シェルを起動しても同じ効果が得られる。Net::FTP のみの場合、libnetcfg を実行して常にパッシブモードを設定することもできる。</target>
        </trans-unit>
        <trans-unit id="b1c69bf3ddadf947bad50c1663c482207ed7bb54" translate="yes" xml:space="preserve">
          <source>When the database contains only UTF-8, a wrapper function or method is a convenient way to replace all your &lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt; calls. A wrapper function will also make it easier to adapt to future enhancements in your database driver. Note that at the time of this writing (January 2012), the DBI has no standardized way to deal with UTF-8 data. Please check the &lt;a href=&quot;dbi&quot;&gt;DBI documentation&lt;/a&gt; to verify if that is still true.</source>
          <target state="translated">データベースにUTF-8のみが含まれている場合、ラッパー関数またはメソッドは、すべての &lt;code&gt;fetchrow_array&lt;/code&gt; および &lt;code&gt;fetchrow_hashref&lt;/code&gt; 呼び出しを置き換える便利な方法です。ラッパー関数を使用すると、データベースドライバーの将来の拡張機能への適応も容易になります。この記事の執筆時点（2012年1月）では、DBIにはUTF-8データを処理するための標準化された方法がないことに注意してください。&lt;a href=&quot;dbi&quot;&gt;DBIのドキュメント&lt;/a&gt;をチェックして、それがまだ当てはまるかどうかを確認してください。</target>
        </trans-unit>
        <trans-unit id="78466bcc2cdd4ead9e6349b03cf49de5263729eb" translate="yes" xml:space="preserve">
          <source>When the database contains only UTF-8, a wrapper function or method is a convenient way to replace all your &lt;code&gt;fetchrow_array&lt;/code&gt; and &lt;code&gt;fetchrow_hashref&lt;/code&gt; calls. A wrapper function will also make it easier to adapt to future enhancements in your database driver. Note that at the time of this writing (January 2012), the DBI has no standardized way to deal with UTF-8 data. Please check the &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI documentation&lt;/a&gt; to verify if that is still true.</source>
          <target state="translated">データベースにUTF-8のみが含まれている場合、ラッパー関数またはメソッドは、すべての &lt;code&gt;fetchrow_array&lt;/code&gt; および &lt;code&gt;fetchrow_hashref&lt;/code&gt; 呼び出しを置き換える便利な方法です。ラッパー関数は、データベースドライバーの将来の拡張機能への適応を容易にします。この記事の執筆時点（2012年1月）では、DBIにはUTF-8データを処理するための標準化された方法がないことに注意してください。それがまだ当てはまるかどうかを確認するには、&lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBIのドキュメント&lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="424c9b91abc16b60883f34954f20bc0920b45171" translate="yes" xml:space="preserve">
          <source>When the execution of your program reaches a point that can hold a breakpoint, the &lt;code&gt;DB::DB()&lt;/code&gt; subroutine is called if any of the variables &lt;code&gt;$DB::trace&lt;/code&gt; , &lt;code&gt;$DB::single&lt;/code&gt; , or &lt;code&gt;$DB::signal&lt;/code&gt; is true. These variables are not &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;izable. This feature is disabled when executing inside &lt;code&gt;DB::DB()&lt;/code&gt; , including functions called from it unless &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; is true.</source>
          <target state="translated">プログラムの実行がブレークポイントを保持できるポイントに到達すると、変数 &lt;code&gt;$DB::trace&lt;/code&gt; 、 &lt;code&gt;$DB::single&lt;/code&gt; 、または &lt;code&gt;$DB::signal&lt;/code&gt; いずれかがtrueの場合、 &lt;code&gt;DB::DB()&lt;/code&gt; サブルーチンが呼び出されます。 。これらの変数は、 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 変更可能ではありません。 &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; がtrue でない限り、 &lt;code&gt;DB::DB()&lt;/code&gt; 内から実行されるとき、この機能は、この機能から呼び出されたときに無効になります。</target>
        </trans-unit>
        <trans-unit id="203a255f166a15d5d314005ac0db0ee5bd633f84" translate="yes" xml:space="preserve">
          <source>When the execution of your program reaches a point that can hold a breakpoint, the &lt;code&gt;DB::DB()&lt;/code&gt; subroutine is called if any of the variables &lt;code&gt;$DB::trace&lt;/code&gt;, &lt;code&gt;$DB::single&lt;/code&gt;, or &lt;code&gt;$DB::signal&lt;/code&gt; is true. These variables are not &lt;code&gt;local&lt;/code&gt;izable. This feature is disabled when executing inside &lt;code&gt;DB::DB()&lt;/code&gt;, including functions called from it unless &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; is true.</source>
          <target state="translated">プログラムの実行がブレークポイントを保持できるポイントに達すると、変数 &lt;code&gt;$DB::trace&lt;/code&gt; 、 &lt;code&gt;$DB::single&lt;/code&gt; 、または &lt;code&gt;$DB::signal&lt;/code&gt; いずれかがtrueの場合、 &lt;code&gt;DB::DB()&lt;/code&gt; サブルーチンが呼び出されます。 。これらの変数は &lt;code&gt;local&lt;/code&gt; 化できません。 &lt;code&gt;$^D &amp;amp; (1&amp;lt;&amp;lt;30)&lt;/code&gt; が真でない限り、 &lt;code&gt;DB::DB()&lt;/code&gt; 内で実行される場合、この機能は無効になります。これには、DB :: DB（）から呼び出される関数も含まれます。</target>
        </trans-unit>
        <trans-unit id="b4013fd718fab58c3590b6ef9433727cc8d4f1b2" translate="yes" xml:space="preserve">
          <source>When the file</source>
          <target state="translated">ファイルの場合</target>
        </trans-unit>
        <trans-unit id="0e9d22cf15c89f0be579b7cac8b2920cd0618fca" translate="yes" xml:space="preserve">
          <source>When the files you're processing are small, it doesn't much matter which way you do it, but it makes a huge difference when they start getting larger.</source>
          <target state="translated">処理しているファイルが小さいときは、どちらの方法で処理してもあまり問題になりませんが、ファイルが大きくなり始めると大きな違いが出てきます。</target>
        </trans-unit>
        <trans-unit id="d42ad95e8f7eb1ea8f7a7febcc136ac0e51ac7e9" translate="yes" xml:space="preserve">
          <source>When the first bad commit is isolated, &lt;code&gt;git bisect&lt;/code&gt; will tell you so:</source>
          <target state="translated">最初の不正なコミットが分離されると、 &lt;code&gt;git bisect&lt;/code&gt; はそのように通知します。</target>
        </trans-unit>
        <trans-unit id="2fc397f7438e86b99c564236153e8faa95f5c6e3" translate="yes" xml:space="preserve">
          <source>When the first parameter is a scalar containing a value that either is a PV string or can be forced into one, the return value is the number of bytes occupied by the first character of that string; or 0 if that first character is the wide NUL character; or negative if there is an error. This is based on the locale that currently underlies the program, regardless of whether or not the function is called from Perl code that is within the scope of &lt;code&gt;use locale&lt;/code&gt;. Perl makes no attempt at hiding from your code any differences in the &lt;code&gt;errno&lt;/code&gt; setting between &lt;code&gt;mblen&lt;/code&gt; and &lt;code&gt;mbrlen&lt;/code&gt;. It does set &lt;code&gt;errno&lt;/code&gt; to 0 before calling them.</source>
          <target state="translated">最初のパラメーターがPV文字列であるか、強制的に1つにできる値を含むスカラーである場合、戻り値はその文字列の最初の文字が占めるバイト数です。または、最初の文字がワイドNUL文字の場合は0。またはエラーがある場合は負。これは、 &lt;code&gt;use locale&lt;/code&gt; 範囲内にあるPerlコードから関数が呼び出されるかどうかに関係なく、現在プログラムの基礎となっているロケールに基づいています。 Perlは、 &lt;code&gt;mblen&lt;/code&gt; と &lt;code&gt;mbrlen&lt;/code&gt; の間の &lt;code&gt;errno&lt;/code&gt; 設定の違いをコードから隠そうとはしません。これは、設定されない &lt;code&gt;errno&lt;/code&gt; それらを呼び出す前に0に。</target>
        </trans-unit>
        <trans-unit id="41f6d7004331625d3362cc91973ffa26e2885b63" translate="yes" xml:space="preserve">
          <source>When the first parameter is a scalar, the code point contained in the scalar second parameter is converted into a multi-byte string and stored into the first parameter scalar. This is based on the locale that currently underlies the program, regardless of whether or not the function is called from Perl code that is within the scope of &lt;code&gt;use locale&lt;/code&gt;. The return value is the number of bytes stored; or negative if the code point isn't representable in the current locale. Perl makes no attempt at hiding from your code any differences in the &lt;code&gt;errno&lt;/code&gt; setting between &lt;code&gt;wctomb&lt;/code&gt; and &lt;code&gt;wcrtomb&lt;/code&gt;. It does set &lt;code&gt;errno&lt;/code&gt; to 0 before calling them.</source>
          <target state="translated">最初のパラメーターがスカラーの場合、スカラーの2番目のパラメーターに含まれるコードポイントはマルチバイト文字列に変換され、最初のパラメーターのスカラーに格納されます。これは、 &lt;code&gt;use locale&lt;/code&gt; 範囲内にあるPerlコードから関数が呼び出されるかどうかに関係なく、現在プログラムの基礎となっているロケールに基づいています。戻り値は、格納されているバイト数です。コードポイントが現在のロケールで表現できない場合は負の値。 Perlは、 &lt;code&gt;wctomb&lt;/code&gt; と &lt;code&gt;wcrtomb&lt;/code&gt; の間の &lt;code&gt;errno&lt;/code&gt; 設定の違いをコードから隠そうとはしません。これは、設定されない &lt;code&gt;errno&lt;/code&gt; それらを呼び出す前に0に。</target>
        </trans-unit>
        <trans-unit id="a67993cdc0054c70b8cf1f3b164eab66d68fabca" translate="yes" xml:space="preserve">
          <source>When the hash is tied dispatches through to the SCALAR method, otherwise returns a mortal SV containing the number of keys in the hash.</source>
          <target state="translated">ハッシュが紐付けられている場合はSCALARメソッドにディスパッチされ、そうでない場合はハッシュに含まれるキーの数を含んだSVを返します。</target>
        </trans-unit>
        <trans-unit id="3edca323b0aa2a8c22d79426f73f2c12bb6d2e6d" translate="yes" xml:space="preserve">
          <source>When the inner subroutine is called, it will see the value of the outer subroutine's lexical subroutine as it was before and during the *first* call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the lexical subroutine. In other words, it will no longer be shared. This will especially make a difference if the lexical subroutines accesses lexical variables declared in its surrounding scope.</source>
          <target state="translated">内側のサブルーチンが呼び出されると、外側のサブルーチンの語彙サブルーチンの値は、外側のサブルーチンへの*最初の*呼び出しの前とその間にあったものを見ることになります;この場合、外側のサブルーチンへの最初の呼び出しが完了した後、内側のサブルーチンと外側のサブルーチンは、もはや語彙サブルーチンの共通の値を共有しなくなります。言い換えれば、もはや共有されなくなります。これは特に、語彙的サブルーチンがその周囲のスコープで宣言された語彙的変数にアクセスする場合に違いが出てきます。</target>
        </trans-unit>
        <trans-unit id="c8e896e8cfb6883a198899b3b354096b8ef21889" translate="yes" xml:space="preserve">
          <source>When the inner subroutine is called, it will see the value of the outer subroutine's variable as it was before and during the *first* call to the outer subroutine; in this case, after the first call to the outer subroutine is complete, the inner and outer subroutines will no longer share a common value for the variable. In other words, the variable will no longer be shared.</source>
          <target state="translated">内側のサブルーチンが呼び出されると、外側のサブルーチンの変数の値は、外側のサブルーチンへの*最初の*呼び出しの前と呼び出し中に、外側のサブルーチンの変数の値を見ることになります;この場合、外側のサブルーチンへの最初の呼び出しが完了した後、内側のサブルーチンと外側のサブルーチンは、もはや変数のための共通の値を共有しません。言い換えれば、変数はもはや共有されません。</target>
        </trans-unit>
        <trans-unit id="631ef295238142aad88b3365a36b169f7f950bf1" translate="yes" xml:space="preserve">
          <source>When the last reference to an object goes away, the object is destroyed. If you only have one reference to an object stored in a lexical scalar, the object is destroyed when that scalar goes out of scope. If you store the object in a package global, that object may not go out of scope until the program exits.</source>
          <target state="translated">オブジェクトへの最後の参照がなくなると、そのオブジェクトは破棄されます。レキシカルスカラに格納されているオブジェクトへの参照が一つしかない場合、そのスカラがスコープ外になるとオブジェクトは破棄されます。オブジェクトをグローバルパッケージに格納している場合、そのオブジェクトはプログラムが終了するまでスコープ外にならないかもしれません。</target>
        </trans-unit>
        <trans-unit id="c4bd6e1ab0ed4ba3f062fe2340aa266f01cbc661" translate="yes" xml:space="preserve">
          <source>When the layer is pushed as part of an &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; call, &lt;code&gt;PUSHED&lt;/code&gt; will be called</source>
          <target state="translated">レイヤーが &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; コールの一部としてプッシュされると、 &lt;code&gt;PUSHED&lt;/code&gt; が呼び出されます</target>
        </trans-unit>
        <trans-unit id="01a59251b1866e239efdc75d52f126badadf6773" translate="yes" xml:space="preserve">
          <source>When the layer is pushed as part of an &lt;code&gt;open&lt;/code&gt; call, &lt;code&gt;PUSHED&lt;/code&gt; will be called</source>
          <target state="translated">&lt;code&gt;open&lt;/code&gt; コールの一部としてレイヤーがプッシュされると、 &lt;code&gt;PUSHED&lt;/code&gt; が呼び出されます</target>
        </trans-unit>
        <trans-unit id="0128971f85240b4f39abca0c6ce4a11b4e096972" translate="yes" xml:space="preserve">
          <source>When the layer is pushed, the current value of &lt;code&gt;$PerlIO::encoding::fallback&lt;/code&gt; is saved and used as the CHECK argument when calling the Encode methods encode() and decode().</source>
          <target state="translated">レイヤーがプッシュされると、 &lt;code&gt;$PerlIO::encoding::fallback&lt;/code&gt; の現在の値が保存され、Encodeメソッドencode（）およびdecode（）を呼び出すときにCHECK引数として使用されます。</target>
        </trans-unit>
        <trans-unit id="8cb85b7bdde203de76612ce7dec71db2d2570629" translate="yes" xml:space="preserve">
          <source>When the lib module is first loaded it records the current value of @INC in an array &lt;code&gt;@lib::ORIG_INC&lt;/code&gt; . To restore @INC to that value you can say</source>
          <target state="translated">libモジュールが最初にロードされると、 &lt;code&gt;@lib::ORIG_INC&lt;/code&gt; に@INCの現在の値が記録されます。@INCをその値に戻すには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="e9f47c78a4b7c6bf48658f90ad7bb90a6f2c2f03" translate="yes" xml:space="preserve">
          <source>When the lib module is first loaded it records the current value of @INC in an array &lt;code&gt;@lib::ORIG_INC&lt;/code&gt;. To restore @INC to that value you can say</source>
          <target state="translated">libモジュールが最初にロードされると、@ INCの現在の値が配列 &lt;code&gt;@lib::ORIG_INC&lt;/code&gt; ます。@INCをその値に復元するには、次のように言うことができます</target>
        </trans-unit>
        <trans-unit id="415f4830f0a5c60f55a1d0556cdab8350fdd12bf" translate="yes" xml:space="preserve">
          <source>When the match runs, the first part of the regular expression (&lt;code&gt;\b(foo)&lt;/code&gt; ) finds a possible match right at the beginning of the string, and loads up $1 with &quot;Foo&quot;. However, as soon as the matching engine sees that there's no whitespace following the &quot;Foo&quot; that it had saved in $1, it realizes its mistake and starts over again one character after where it had the tentative match. This time it goes all the way until the next occurrence of &quot;foo&quot;. The complete regular expression matches this time, and you get the expected output of &quot;table follows foo.&quot;</source>
          <target state="translated">一致が実行されると、正規表現の最初の部分（ &lt;code&gt;\b(foo)&lt;/code&gt; ）が文字列の先頭で一致の可能性を見つけ、$ 1に &quot;Foo&quot;をロードします。ただし、マッチングエンジンは、$ 1に保存した &quot;Foo&quot;の後に空白がないことを確認するとすぐに、その誤りを認識し、仮の一致があった場所の1文字後にもう一度やり直します。今回は次の &quot;foo&quot;が現れるまで続きます。今回は完全な正規表現が一致し、「table follows foo」の期待される出力が得られます。</target>
        </trans-unit>
        <trans-unit id="59438c31be63ed00a2828de2f2dbb82ccfc7a3c2" translate="yes" xml:space="preserve">
          <source>When the match runs, the first part of the regular expression (&lt;code&gt;\b(foo)&lt;/code&gt;) finds a possible match right at the beginning of the string, and loads up &lt;code&gt;$1&lt;/code&gt; with &quot;Foo&quot;. However, as soon as the matching engine sees that there's no whitespace following the &quot;Foo&quot; that it had saved in &lt;code&gt;$1&lt;/code&gt;, it realizes its mistake and starts over again one character after where it had the tentative match. This time it goes all the way until the next occurrence of &quot;foo&quot;. The complete regular expression matches this time, and you get the expected output of &quot;table follows foo.&quot;</source>
          <target state="translated">一致が実行されると、正規表現の最初の部分（ &lt;code&gt;\b(foo)&lt;/code&gt; ）は、文字列の先頭で一致する可能性のあるものを見つけ、「Foo」で &lt;code&gt;$1&lt;/code&gt; をロードします。ただし、マッチングエンジンは、 &lt;code&gt;$1&lt;/code&gt; で節約した「Foo」の後に空白がないことを確認するとすぐに、その間違いを認識し、暫定的なマッチングが行われた後、1文字をやり直します。今回は、次の「foo」の出現までずっと続きます。今回は完全な正規表現が一致し、「tablefollowsfoo」という期待どおりの出力が得られます。</target>
        </trans-unit>
        <trans-unit id="c8a3d6c13049ca137ffa9c8c06a835f3079e4b4a" translate="yes" xml:space="preserve">
          <source>When the object goes out of scope, the destructor is called. This destructor will attempt to unlink the file (using &lt;a href=&quot;#unlink1&quot;&gt;unlink1&lt;/a&gt;) if the constructor was called with UNLINK set to 1 (the default state if UNLINK is not specified).</source>
          <target state="translated">オブジェクトがスコープ外になると、デストラクタが呼び出されます。このデストラクタは、コンストラクタが&lt;a href=&quot;#unlink1&quot;&gt;UNLINK&lt;/a&gt;を1に設定して呼び出された場合（UNLINKが指定されていない場合のデフォルト状態）、ファイルのリンクを解除しようとします（unlink1を使用）。</target>
        </trans-unit>
        <trans-unit id="3d9aa22c95db143c4f71ce6060fc0fa951e547b8" translate="yes" xml:space="preserve">
          <source>When the object goes out of scope, the destructor is called. This destructor will attempt to unlink the file (using L</source>
          <target state="translated">オブジェクトがスコープ外になると、デストラクタが呼ばれます。このデストラクタはファイルのリンクを解除しようとします (L</target>
        </trans-unit>
        <trans-unit id="08260b550e8cbd87b7894a9886c2e5f84f74a639" translate="yes" xml:space="preserve">
          <source>When the optimisation criteria have been satisfied, &lt;code&gt;reg_try()&lt;/code&gt; is called to perform the match.</source>
          <target state="translated">最適化基準が満たされると、 &lt;code&gt;reg_try()&lt;/code&gt; が呼び出されて一致が実行されます。</target>
        </trans-unit>
        <trans-unit id="5ec2c96e37a54667487e24f12619de8d206380fe" translate="yes" xml:space="preserve">
          <source>When the output is a filename, it will truncate the contents of the file before writing any compressed data. If the output is a filehandle its position will not be changed. If the output is a buffer, it will be wiped before any compressed data is output.</source>
          <target state="translated">出力がファイル名の場合は、圧縮データを書き込む前にファイルの内容を切り詰めます。出力がファイルハンドルの場合、その位置は変更されません。出力がバッファの場合は、圧縮データが出力される前に消去されます。</target>
        </trans-unit>
        <trans-unit id="490632792a6bd230d4b7574b0a1ce3af888c0fe9" translate="yes" xml:space="preserve">
          <source>When the output is a filename, it will truncate the contents of the file before writing any uncompressed data. If the output is a filehandle its position will not be changed. If the output is a buffer, it will be wiped before any uncompressed data is output.</source>
          <target state="translated">出力がファイル名の場合には、 非圧縮デー タ を書き出す前に、 フ ァ イ ルの内容を切り詰めます。出力がファイルハンドルの場合は、その位置は変更されません。出力がバッファの場合は、非圧縮データが出力される前に消去されます。</target>
        </trans-unit>
        <trans-unit id="923167a1de1c89698b7cefa97410f6784a41b41c" translate="yes" xml:space="preserve">
          <source>When the program has terminated, the output may be examined and sorted using any standard text filtering utilities. Something like the following may be sufficient:</source>
          <target state="translated">プログラムが終了したら、標準的なテキストフィルタリングユーティリティを使って出力を調べたり、ソートしたりすることができます。以下のようなもので十分かもしれません。</target>
        </trans-unit>
        <trans-unit id="a2704235b2d8eb8f428696670573c7525bbfe494" translate="yes" xml:space="preserve">
          <source>When the script ends, and you want to change some values in the generated</source>
          <target state="translated">スクリプトが終了し、生成された</target>
        </trans-unit>
        <trans-unit id="116008ef85147614241af5722a4a2daf4c0fac34" translate="yes" xml:space="preserve">
          <source>When the script terminates the profiler will create a database of the profile information that you can turn into reports using the profiler's tools. See &amp;lt;perlperf&amp;gt; for details.</source>
          <target state="translated">スクリプトが終了すると、プロファイラーは、プロファイラーのツールを使用してレポートに変換できるプロファイル情報のデータベースを作成します。詳細については、&amp;lt;perlperf&amp;gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="bd423c011519f7f605565c27b285e9b7433164a6" translate="yes" xml:space="preserve">
          <source>When the second parameter is a scalar containing a value that either is a PV string or can be forced into one, the return value is the number of bytes occupied by the first character of that string; or 0 if that first character is the wide NUL character; or negative if there is an error. This is based on the locale that currently underlies the program, regardless of whether or not the function is called from Perl code that is within the scope of &lt;code&gt;use locale&lt;/code&gt;. Perl makes no attempt at hiding from your code any differences in the &lt;code&gt;errno&lt;/code&gt; setting between &lt;code&gt;mbtowc&lt;/code&gt; and &lt;code&gt;mbrtowc&lt;/code&gt;. It does set &lt;code&gt;errno&lt;/code&gt; to 0 before calling them.</source>
          <target state="translated">2番目のパラメーターがPV文字列であるか、強制的に1つにできる値を含むスカラーである場合、戻り値はその文字列の最初の文字が占めるバイト数です。または、最初の文字がワイドNUL文字の場合は0。またはエラーがある場合は負。これは、 &lt;code&gt;use locale&lt;/code&gt; 範囲内にあるPerlコードから関数が呼び出されるかどうかに関係なく、現在プログラムの基礎となっているロケールに基づいています。 Perlは、 &lt;code&gt;mbtowc&lt;/code&gt; と &lt;code&gt;mbrtowc&lt;/code&gt; の間の &lt;code&gt;errno&lt;/code&gt; 設定の違いをコードから隠そうとはしません。これは、設定されない &lt;code&gt;errno&lt;/code&gt; それらを呼び出す前に0に。</target>
        </trans-unit>
        <trans-unit id="d7811c9ae79cafa461b23dd21d92c2852fa57021" translate="yes" xml:space="preserve">
          <source>When the string contains a Unicode named code point &lt;code&gt;\N{...}&lt;/code&gt;</source>
          <target state="translated">文字列にUnicode名前付きコードポイント &lt;code&gt;\N{...}&lt;/code&gt; が含まれている場合</target>
        </trans-unit>
        <trans-unit id="219689a8c46c6da015ee7181b846d635f06ea57d" translate="yes" xml:space="preserve">
          <source>When the string contains a Unicode-only code point</source>
          <target state="translated">文字列にユニコードのみのコードポイントが含まれている場合</target>
        </trans-unit>
        <trans-unit id="dff4dc2cfa7ab4f3143ca1c8cea9659a2fba0df1" translate="yes" xml:space="preserve">
          <source>When the string has been upgraded to UTF-8</source>
          <target state="translated">文字列がUTF-8にアップグレードされている場合</target>
        </trans-unit>
        <trans-unit id="c5aaa6f97ab5589891e81e58fbc94f58509000ee" translate="yes" xml:space="preserve">
          <source>When the string has come from an external source marked as Unicode</source>
          <target state="translated">文字列が Unicode としてマークされた外部ソースから来ている場合</target>
        </trans-unit>
        <trans-unit id="33e82ba1ad1caecfef00b667970977ee30c1a1ff" translate="yes" xml:space="preserve">
          <source>When the taint mode (&lt;code&gt;-T&lt;/code&gt; ) is in effect, the &quot;.&quot; directory is removed from &lt;code&gt;@INC&lt;/code&gt; , and the environment variables &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;PERLLIB&lt;/code&gt; are ignored by Perl. You can still adjust &lt;code&gt;@INC&lt;/code&gt; from outside the program by using the &lt;code&gt;-I&lt;/code&gt; command line option as explained in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;. The two environment variables are ignored because they are obscured, and a user running a program could be unaware that they are set, whereas the &lt;code&gt;-I&lt;/code&gt; option is clearly visible and therefore permitted.</source>
          <target state="translated">汚染モード（ &lt;code&gt;-T&lt;/code&gt; ）が有効な場合、「。」ディレクトリは &lt;code&gt;@INC&lt;/code&gt; から削除され、環境変数 &lt;code&gt;PERL5LIB&lt;/code&gt; および &lt;code&gt;PERLLIB&lt;/code&gt; はPerlによって無視されます。あなたはまだ調整でき &lt;code&gt;@INC&lt;/code&gt; を使用してプログラムの外部から &lt;code&gt;-I&lt;/code&gt; で説明したように、コマンドラインオプションを&lt;a href=&quot;perlrun&quot;&gt;perlrunを&lt;/a&gt;。 2つの環境変数は隠されているため無視され、プログラムを実行しているユーザーはそれらが設定されていることに気づかない可能性がありますが、 &lt;code&gt;-I&lt;/code&gt; オプションは明確に表示されるため許可されます。</target>
        </trans-unit>
        <trans-unit id="e34514e5e3372fed96ae586191867c70ca14aae4" translate="yes" xml:space="preserve">
          <source>When the taint mode (&lt;code&gt;-T&lt;/code&gt;) is in effect, the environment variables &lt;code&gt;PERL5LIB&lt;/code&gt; and &lt;code&gt;PERLLIB&lt;/code&gt; are ignored by Perl. You can still adjust &lt;code&gt;@INC&lt;/code&gt; from outside the program by using the &lt;code&gt;-I&lt;/code&gt; command line option as explained in &lt;a href=&quot;perlrun#-Idirectory&quot;&gt;perlrun&lt;/a&gt;. The two environment variables are ignored because they are obscured, and a user running a program could be unaware that they are set, whereas the &lt;code&gt;-I&lt;/code&gt; option is clearly visible and therefore permitted.</source>
          <target state="translated">汚染モード（ &lt;code&gt;-T&lt;/code&gt; ）が有効な場合、環境変数 &lt;code&gt;PERL5LIB&lt;/code&gt; および &lt;code&gt;PERLLIB&lt;/code&gt; はPerlによって無視されます。あなたはまだ調整でき &lt;code&gt;@INC&lt;/code&gt; を使用してプログラムの外部から &lt;code&gt;-I&lt;/code&gt; で説明したように、コマンドラインオプションを&lt;a href=&quot;perlrun#-Idirectory&quot;&gt;perlrunを&lt;/a&gt;。 2つの環境変数は隠されているため無視され、プログラムを実行しているユーザーはそれらが設定されていることに気付かない可能性がありますが、 &lt;code&gt;-I&lt;/code&gt; オプションは明確に表示されるため、許可されます。</target>
        </trans-unit>
        <trans-unit id="05614cc2a7184900b0ce6634ffcfa41b43df8b62" translate="yes" xml:space="preserve">
          <source>When the test file finishes, outputs the summary, together.</source>
          <target state="translated">テストファイルが終了したら、まとめて出力します。</target>
        </trans-unit>
        <trans-unit id="5d3ce74817cdede8942c8b771dd9c729dbff5404" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;given&lt;/code&gt;. In Perl 5.14 and earlier, this form of &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; was only available when the &lt;a href=&quot;feature#The-%27switch%27-feature&quot;&gt;&lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature&lt;/a&gt; was enabled. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;&quot;Switch Statements&quot; in perlsyn&lt;/a&gt; for more information.</source>
          <target state="translated">BLOCKがない場合、&lt;a href=&quot;#continue-BLOCK&quot;&gt; &lt;code&gt;continue&lt;/code&gt; &lt;/a&gt;は、動的に囲む &lt;code&gt;foreach&lt;/code&gt; を繰り返したり、字句的に囲んでいる &lt;code&gt;given&lt;/code&gt; 終了する代わりに、現在の &lt;code&gt;when&lt;/code&gt; または &lt;code&gt;default&lt;/code&gt; ブロックを通過する関数です。Perl 5.14以前では、この形式の&lt;a href=&quot;#continue-BLOCK&quot;&gt; &lt;code&gt;continue&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;feature#The-%27switch%27-feature&quot;&gt; &lt;code&gt;&quot;switch&quot;&lt;/code&gt; &lt;/a&gt;機能が有効になっている場合にのみ使用可能でした。詳細について&lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;は、perlsynの&lt;/a&gt;&lt;a href=&quot;feature&quot;&gt;機能&lt;/a&gt;と「SwitchStatements」を参照してください。</target>
        </trans-unit>
        <trans-unit id="4c7dc2674104ea2267f99aaaacf86ff6b7f8474b" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;&lt;a href=&quot;given&quot;&gt;given&lt;/a&gt;&lt;/code&gt;. In Perl 5.14 and earlier, this form of &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; was only available when the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature was enabled. See &lt;a href=&quot;../feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more information.</source>
          <target state="translated">BLOCKがない場合、 &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; は、動的に囲む &lt;code&gt;foreach&lt;/code&gt; を繰り返したり、字句的に囲まれた &lt;code&gt;&lt;a href=&quot;given&quot;&gt;given&lt;/a&gt;&lt;/code&gt; を終了したりする代わりに、現在の &lt;code&gt;when&lt;/code&gt; または &lt;code&gt;default&lt;/code&gt; ブロックを通過する関数です。 Perl 5.14以前では、この形式の &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 機能が有効になっている場合にのみ使用できました。詳細について&lt;a href=&quot;../perlsyn#Switch-Statements&quot;&gt;は、perlsynの&lt;/a&gt;&lt;a href=&quot;../feature&quot;&gt;機能&lt;/a&gt;とスイッチステートメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="d0601e1c27a0dc14d5d3038756194559ec0b7177" translate="yes" xml:space="preserve">
          <source>When there is no BLOCK, &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; is a function that falls through the current &lt;code&gt;when&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt; block instead of iterating a dynamically enclosing &lt;code&gt;foreach&lt;/code&gt; or exiting a lexically enclosing &lt;code&gt;given&lt;/code&gt; . In Perl 5.14 and earlier, this form of &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; was only available when the &lt;code&gt;&quot;switch&quot;&lt;/code&gt; feature was enabled. See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt; and &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt; for more information.</source>
          <target state="translated">BLOCKがない場合、 &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; は、動的に囲む &lt;code&gt;foreach&lt;/code&gt; を繰り返したり、字句的に囲まれた &lt;code&gt;given&lt;/code&gt; を終了したりする代わりに、現在の &lt;code&gt;when&lt;/code&gt; または &lt;code&gt;default&lt;/code&gt; ブロックを通過する関数です。Perl 5.14以前では、この形式の &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;&quot;switch&quot;&lt;/code&gt; 機能が有効になっている場合にのみ使用できました。詳細について&lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;は、perlsynの&lt;/a&gt;&lt;a href=&quot;feature&quot;&gt;機能&lt;/a&gt;とスイッチステートメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="d14e56899b59096c05cd14ff3a8ecfb95a7d60b7" translate="yes" xml:space="preserve">
          <source>When there is no method, it takes the method name as the name of the encoding and encodes the instance</source>
          <target state="translated">メソッドがない場合は、メソッド名をエンコード名とし、インスタンスをエンコードします。</target>
        </trans-unit>
        <trans-unit id="b009ed76d6586de96f41fbede53e1b376b816ad5" translate="yes" xml:space="preserve">
          <source>When these are embedded in another pattern, what they match does not change, regardless of parenthesization or what modifiers are in effect in that outer pattern.</source>
          <target state="translated">これらが別のパターンに埋め込まれている場合は、括弧で囲まれていても、その外側のパターンでどのような修飾子が有効であるかにかかわらず、それらが一致するものは変わりません。</target>
        </trans-unit>
        <trans-unit id="dc5872b9a322af5576c1ac03e71331c1716252c8" translate="yes" xml:space="preserve">
          <source>When these are embedded in another pattern, what they match does not change, regardless of parenthesization or what modifiers are in effect in that outer pattern. If you fail to compile the subcomponents, you can get some nasty surprises. For example:</source>
          <target state="translated">これらが別のパターンに埋め込まれていても、括弧で囲まれていたり、その外側のパターンでどのような修飾子が有効であるかにかかわらず、それらが一致するものは変わりません。サブコンポーネントのコンパイルに失敗すると、いくつかの厄介な驚きを得ることができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="1810832e010e811c7366d9b862298011ff2e0aa6" translate="yes" xml:space="preserve">
          <source>When this bit is set, &lt;code&gt;$sNewName&lt;/code&gt; can be &lt;code&gt;[]&lt;/code&gt; [for &lt;code&gt;NULL&lt;/code&gt;] to indicate that &lt;code&gt;$sOldName&lt;/code&gt; should be deleted during the next boot rather than renamed.</source>
          <target state="translated">このビットが設定されている場合、 &lt;code&gt;$sNewName&lt;/code&gt; を &lt;code&gt;[]&lt;/code&gt; [for &lt;code&gt;NULL&lt;/code&gt; ]にして、名前を変更するのではなく、次回の起動時に &lt;code&gt;$sOldName&lt;/code&gt; を削除する必要があることを示すことができます。</target>
        </trans-unit>
        <trans-unit id="e1c33d2bb86243cd92baa102e04bd026d16cffb4" translate="yes" xml:space="preserve">
          <source>When this code is executed there is no output. Here's why:</source>
          <target state="translated">このコードを実行しても何も出力されません。これが理由です。</target>
        </trans-unit>
        <trans-unit id="7f61484b00c940e7437bf32bc5684d2e69d1807c" translate="yes" xml:space="preserve">
          <source>When this code is run only the &lt;code&gt;Derived&lt;/code&gt; object, &lt;code&gt;$b&lt;/code&gt; , will generate a warning.</source>
          <target state="translated">このコードを実行すると、 &lt;code&gt;Derived&lt;/code&gt; オブジェクト &lt;code&gt;$b&lt;/code&gt; のみが警告を生成します。</target>
        </trans-unit>
        <trans-unit id="9309453554803d7d3570d025f7e35cec80cda5d1" translate="yes" xml:space="preserve">
          <source>When this code is run only the &lt;code&gt;Derived&lt;/code&gt; object, &lt;code&gt;$b&lt;/code&gt;, will generate a warning.</source>
          <target state="translated">このコードを実行すると、 &lt;code&gt;Derived&lt;/code&gt; オブジェクト &lt;code&gt;$b&lt;/code&gt; のみが警告を生成します。</target>
        </trans-unit>
        <trans-unit id="917174880fc77c13ccda7d2e62ec7ea358e2a066" translate="yes" xml:space="preserve">
          <source>When this code is run with the &lt;b&gt;-w&lt;/b&gt; flag, a warning will be produced for the &lt;code&gt;$a&lt;/code&gt; line: &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt; .</source>
          <target state="translated">このコードを&lt;b&gt;-w&lt;/b&gt;フラグを指定して実行すると、 &lt;code&gt;$a&lt;/code&gt; 行に対して警告が生成されます： &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2388e2ced3b75ec3bd369e3152eae13dfe498282" translate="yes" xml:space="preserve">
          <source>When this code is run with the &lt;b&gt;-w&lt;/b&gt; flag, a warning will be produced for the &lt;code&gt;$a&lt;/code&gt; line: &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt;.</source>
          <target state="translated">このコードを&lt;b&gt;-w&lt;/b&gt;フラグを指定して実行すると、 &lt;code&gt;$a&lt;/code&gt; 行に対して &lt;code&gt;&quot;Reversed += operator&quot;&lt;/code&gt; という警告が生成されます。</target>
        </trans-unit>
        <trans-unit id="16748736985dd4c981bc264b989b01547f68e378" translate="yes" xml:space="preserve">
          <source>When this form of the pragma is used, only the non-character portions of locales are used by Perl, for example &lt;code&gt;LC_NUMERIC&lt;/code&gt; . Perl assumes that you have translated all the characters it is to operate on into Unicode (actually the platform's native character set (ASCII or EBCDIC) plus Unicode). For data in files, this can conveniently be done by also specifying</source>
          <target state="translated">この形式のプラグマが使用される場合、ロケールの文字以外の部分（たとえば &lt;code&gt;LC_NUMERIC&lt;/code&gt; )のみが Perlによって使用されます。Perlは、操作対象のすべての文字をUnicode（実際にはプラットフォームのネイティブ文字セット（ASCIIまたはEBCDIC）に加えてUnicode）に変換したと見なします。ファイル内のデータの場合、これも指定することで便利に実行できます</target>
        </trans-unit>
        <trans-unit id="db1567ebb35e094978d64dee42e25f3b2f3257aa" translate="yes" xml:space="preserve">
          <source>When this form of the pragma is used, only the non-character portions of locales are used by Perl, for example &lt;code&gt;LC_NUMERIC&lt;/code&gt;. Perl assumes that you have translated all the characters it is to operate on into Unicode (actually the platform's native character set (ASCII or EBCDIC) plus Unicode). For data in files, this can conveniently be done by also specifying</source>
          <target state="translated">この形式のプラグマを使用する場合、Perlはロケールの文字以外の部分のみを使用します（例： &lt;code&gt;LC_NUMERIC&lt;/code&gt; )。Perlは、操作対象のすべての文字をUnicode（実際にはプラットフォームのネイティブ文字セット（ASCIIまたはEBCDIC）とUnicode）に変換したことを前提としています。ファイル内のデータの場合、これは次のように指定することで簡単に実行できます</target>
        </trans-unit>
        <trans-unit id="f3b915026102758b5ff7da846b6098df7e775168" translate="yes" xml:space="preserve">
          <source>When this function is called, the function referenced by</source>
          <target state="translated">この関数が呼び出されると</target>
        </trans-unit>
        <trans-unit id="e9e65ea3d452091e9942f0f5039cb9a617322586" translate="yes" xml:space="preserve">
          <source>When this function is called, the function referenced by &lt;code&gt;new_checker&lt;/code&gt; must be ready to be called, except for &lt;code&gt;*old_checker_p&lt;/code&gt; being unfilled. In a threading situation, &lt;code&gt;new_checker&lt;/code&gt; may be called immediately, even before this function has returned. &lt;code&gt;*old_checker_p&lt;/code&gt; will always be appropriately set before &lt;code&gt;new_checker&lt;/code&gt; is called. If &lt;code&gt;new_checker&lt;/code&gt; decides not to do anything special with an op that it is given (which is the usual case for most uses of op check hooking), it must chain the check function referenced by &lt;code&gt;*old_checker_p&lt;/code&gt;.</source>
          <target state="translated">この関数を呼び出すときは、 &lt;code&gt;*old_checker_p&lt;/code&gt; が入力されていないことを除いて、 &lt;code&gt;new_checker&lt;/code&gt; によって参照される関数を呼び出す準備ができている必要があります。スレッド化の状況では、この関数が返される前であっても、 &lt;code&gt;new_checker&lt;/code&gt; がすぐに呼び出される場合があります。 &lt;code&gt;*old_checker_p&lt;/code&gt; は、 &lt;code&gt;new_checker&lt;/code&gt; が呼び出される前に常に適切に設定されます。 &lt;code&gt;new_checker&lt;/code&gt; が、指定されたopに対して特別なことを行わないことを決定した場合（これは、opチェックフックのほとんどの使用で通常のケースです）、 &lt;code&gt;*old_checker_p&lt;/code&gt; によって参照されるチェック関数をチェーンする必要があります。</target>
        </trans-unit>
        <trans-unit id="3dc4ee6516decf05e05dd9bd8fd17984cd79424b" translate="yes" xml:space="preserve">
          <source>When this function is called, the function referenced by &lt;code&gt;new_plugin&lt;/code&gt; must be ready to be called, except for &lt;code&gt;*old_plugin_p&lt;/code&gt; being unfilled. In a threading situation, &lt;code&gt;new_plugin&lt;/code&gt; may be called immediately, even before this function has returned. &lt;code&gt;*old_plugin_p&lt;/code&gt; will always be appropriately set before &lt;code&gt;new_plugin&lt;/code&gt; is called. If &lt;code&gt;new_plugin&lt;/code&gt; decides not to do anything special with the identifier that it is given (which is the usual case for most calls to a keyword plugin), it must chain the plugin function referenced by &lt;code&gt;*old_plugin_p&lt;/code&gt;.</source>
          <target state="translated">この関数を呼び出すときは、 &lt;code&gt;*old_plugin_p&lt;/code&gt; が入力されていないことを除いて、 &lt;code&gt;new_plugin&lt;/code&gt; によって参照される関数を呼び出す準備ができている必要があります。スレッド化の状況では、この関数が返される前であっても、 &lt;code&gt;new_plugin&lt;/code&gt; がすぐに呼び出される場合があります。 &lt;code&gt;*old_plugin_p&lt;/code&gt; は、 &lt;code&gt;new_plugin&lt;/code&gt; が呼び出される前に常に適切に設定されます。 &lt;code&gt;new_plugin&lt;/code&gt; が、指定された識別子に対して特別なことを行わないことを決定した場合（これは、キーワードプラグインへのほとんどの呼び出しで通常のケースです）、 &lt;code&gt;*old_plugin_p&lt;/code&gt; によって参照されるプラグイン関数をチェーンする必要があります。</target>
        </trans-unit>
        <trans-unit id="7fa02f2fe554bd2a9b6a103fe9beb89d9b4e4476" translate="yes" xml:space="preserve">
          <source>When this happens, you can just</source>
          <target state="translated">このような時には</target>
        </trans-unit>
        <trans-unit id="01472604570ddd05a81c224b83daf7199b2292ca" translate="yes" xml:space="preserve">
          <source>When this is set to &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;OBJECT&lt;/code&gt; will be automagically derived from &lt;code&gt;O_FILES&lt;/code&gt; .</source>
          <target state="translated">これが &lt;code&gt;1&lt;/code&gt; に設定されている場合、 &lt;code&gt;OBJECT&lt;/code&gt; は自動的に &lt;code&gt;O_FILES&lt;/code&gt; から派生します。</target>
        </trans-unit>
        <trans-unit id="447329d526fb82114543e70fb22d4772337fe346" translate="yes" xml:space="preserve">
          <source>When this is set to &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;OBJECT&lt;/code&gt; will be automagically derived from &lt;code&gt;O_FILES&lt;/code&gt;.</source>
          <target state="translated">これを &lt;code&gt;1&lt;/code&gt; に設定すると、 &lt;code&gt;OBJECT&lt;/code&gt; は &lt;code&gt;O_FILES&lt;/code&gt; から自動的に派生します。</target>
        </trans-unit>
        <trans-unit id="4611cd8d92449087862ca322a574ebe794802885" translate="yes" xml:space="preserve">
          <source>When this is set to &lt;code&gt;1&lt;/code&gt;, multiple XS files may be placed under</source>
          <target state="translated">これを &lt;code&gt;1&lt;/code&gt; に設定すると、複数のXSファイルが下に配置される場合があります</target>
        </trans-unit>
        <trans-unit id="5e7dd367eef2d9f8124f8f23ef52e931a536491c" translate="yes" xml:space="preserve">
          <source>When this is true, CPAN will set PERL_MM_USE_DEFAULT to a true value. This causes ExtUtils::MakeMaker (and compatible) prompts to use default values instead of stopping to prompt you to answer questions. It also sets NONINTERACTIVE_TESTING to a true value to signal more generally that distributions should not try to interact with you.</source>
          <target state="translated">これが真の場合、CPAN は PERL_MM_USE_DEFAULT を真の値に設定します。これにより、ExtUtils::MakeMaker (および互換性のある)プロンプトは、質問への回答を促すために停止するのではなく、デフォルト値を使用するようになります。また、NONINTERACTIVE_TESTING を真の値に設定して、ディストリビューションがあなたと対話しようとしないことをより一般的に知らせるようにします。</target>
        </trans-unit>
        <trans-unit id="e48ad08805e823db4cab572ed48a495b3413c960" translate="yes" xml:space="preserve">
          <source>When this option is set to true AND the zip archive being read has the &quot;Language Encoding Flag&quot; (EFS) set, the member name is assumed to be encoded in UTF-8.</source>
          <target state="translated">このオプションが true に設定されていて、かつ読み込まれる zip アーカイブに「言語エンコーディングフラグ」(EFS)が設定されている場合、メンバー名は UTF-8 でエンコードされているものとみなされます。</target>
        </trans-unit>
        <trans-unit id="d2ca05f5323dff5f446952bd69ac6477b5186d11" translate="yes" xml:space="preserve">
          <source>When to Still Use local()</source>
          <target state="translated">それでも local()を使用する場合</target>
        </trans-unit>
        <trans-unit id="84389d029ef5726370dd8c2cf19105277288fbc8" translate="yes" xml:space="preserve">
          <source>When to Use OO</source>
          <target state="translated">OOを使用する場合</target>
        </trans-unit>
        <trans-unit id="7fe9c30c4e2d69806274da4a183bd0637abe22d6" translate="yes" xml:space="preserve">
          <source>When true the entire test should be skipped. This is usually paired with an explanation in the &lt;code&gt;details&lt;/code&gt; field, and a &lt;code&gt;control&lt;/code&gt; facet that has &lt;code&gt;terminate&lt;/code&gt; set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">trueの場合、テスト全体をスキップする必要があります。これは通常、 &lt;code&gt;details&lt;/code&gt; フィールドの説明とペアになっており、 &lt;code&gt;terminate&lt;/code&gt; た &lt;code&gt;control&lt;/code&gt; ファセットは &lt;code&gt;0&lt;/code&gt; に設定されています。</target>
        </trans-unit>
        <trans-unit id="1aff41766b1c1facad70ba1087945ce4b9ff69fd" translate="yes" xml:space="preserve">
          <source>When true this parameter will set the FLG.FHCRC bit to 1 in the gzip header and set the CRC16 header field to the CRC of the complete gzip header except the CRC16 field itself.</source>
          <target state="translated">真の場合、このパラメータはgzipヘッダのFLG.FHCRCビットを1に設定し、 CRC16ヘッダフィールドをCRC16フィールド自体を除く完全なgzipヘッダのCRCに設定する。</target>
        </trans-unit>
        <trans-unit id="71e94facdb69a355a340449fba8e5c34fbd178ec" translate="yes" xml:space="preserve">
          <source>When true, perform the generation and addition to the MANIFEST of the SIGNATURE file in the distdir during 'make distdir', via 'cpansign -s'.</source>
          <target state="translated">true の場合、'make distdir' の間に、'cpansign -s' を通して distdir にある SIGNATURE ファイルの MANIFEST の生成と追加を行います。</target>
        </trans-unit>
        <trans-unit id="2f8d8efe7dc5d620dd4b31a7d176203c2784135f" translate="yes" xml:space="preserve">
          <source>When true, suppresses the appending of installations to &lt;code&gt;perllocal&lt;/code&gt; .</source>
          <target state="translated">trueの場合、インストールの &lt;code&gt;perllocal&lt;/code&gt; への追加を抑制します。</target>
        </trans-unit>
        <trans-unit id="ff5bff80188d068a00e6b218733a6d5345f2c3a2" translate="yes" xml:space="preserve">
          <source>When true, suppresses the appending of installations to &lt;code&gt;perllocal&lt;/code&gt;.</source>
          <target state="translated">trueの場合、 &lt;code&gt;perllocal&lt;/code&gt; へのインストールの追加を抑制します。</target>
        </trans-unit>
        <trans-unit id="92a480e39d3219d70893b100f9cf0554ca8d0e6e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the generation and addition to the MANIFEST of the META.yml and META.json module meta-data files during 'make distdir'.</source>
          <target state="translated">true の場合、'make distdir' の間に META.yml と META.json モジュールのメタデータファイルの生成と MANIFEST への追加を抑制します。</target>
        </trans-unit>
        <trans-unit id="8f0d56eaaf65617686939dad5c1d3b6bcfce688e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the generation of MYMETA.yml and MYMETA.json module meta-data files during 'perl Makefile.PL'.</source>
          <target state="translated">trueの場合、'perl Makefile.PL'の間にMYMETA.ymlとMYMETA.jsonモジュールのメタデータファイルの生成を抑制します。</target>
        </trans-unit>
        <trans-unit id="b0686c4aa533a7288139fdb7b691343d38cb093e" translate="yes" xml:space="preserve">
          <source>When true, suppresses the writing of &lt;code&gt;packlist&lt;/code&gt; files for installs.</source>
          <target state="translated">trueの場合、インストール用の &lt;code&gt;packlist&lt;/code&gt; ファイルの書き込みを抑制します。</target>
        </trans-unit>
        <trans-unit id="72af2071def396f7be81fd1ce806195fb7b786b5" translate="yes" xml:space="preserve">
          <source>When true, the tempdir used by the IPC driver will not be deleted when the test is done.</source>
          <target state="translated">trueの場合、IPCドライバが使用しているtempdirはテスト時には削除されません。</target>
        </trans-unit>
        <trans-unit id="f79c2493f27b952ee97bbc3534495620a8d27f41" translate="yes" xml:space="preserve">
          <source>When trying to explain stacks, most computer science textbooks mumble something about spring-loaded columns of cafeteria plates: the last thing you pushed on the stack is the first thing you pop off. That'll do for our purposes: your C program will push some arguments onto &quot;the Perl stack&quot;, shut its eyes while some magic happens, and then pop the results--the return value of your Perl subroutine--off the stack.</source>
          <target state="translated">スタックを説明しようとするとき、ほとんどのコンピュータサイエンスの教科書は、カフェテリアの皿のバネのついた列について何かをつぶやいています:スタックに最後に押したものは、最初に飛び出すものです。あなたのCプログラムは、引数を &quot;Perlスタック &quot;にプッシュして、魔法のようなことが起こるまで目を閉じて、その結果(Perlサブルーチンの戻り値)をスタックからポップします。</target>
        </trans-unit>
        <trans-unit id="d64835545d5a37bef9d2f55b36f2fe943d1540a7" translate="yes" xml:space="preserve">
          <source>When tying a handle, the first argument to &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; should begin with an asterisk. So, if you are tying STDOUT, use &lt;code&gt;*STDOUT&lt;/code&gt; . If you have assigned it to a scalar variable, say &lt;code&gt;$handle&lt;/code&gt; , use &lt;code&gt;*$handle&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; $handle&lt;/code&gt; ties the scalar variable &lt;code&gt;$handle&lt;/code&gt; , not the handle inside it.</source>
          <target state="translated">ハンドルを結ぶとき、 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; の最初の引数はアスタリスクで始める必要があります。したがって、STDOUTを使用する場合は、 &lt;code&gt;*STDOUT&lt;/code&gt; を使用します。 &lt;code&gt;$handle&lt;/code&gt; などのスカラー変数に割り当てた場合は、 &lt;code&gt;*$handle&lt;/code&gt; 使用します。 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt; $handle&lt;/code&gt; は、内部の &lt;code&gt;$handle&lt;/code&gt; ではなく、スカラー変数$ handleを結び付けます。</target>
        </trans-unit>
        <trans-unit id="db73b1d8c34ba44728cad3d2b1f319f02e5b59fc" translate="yes" xml:space="preserve">
          <source>When tying a handle, the first argument to &lt;code&gt;tie&lt;/code&gt; should begin with an asterisk. So, if you are tying STDOUT, use &lt;code&gt;*STDOUT&lt;/code&gt;. If you have assigned it to a scalar variable, say &lt;code&gt;$handle&lt;/code&gt;, use &lt;code&gt;*$handle&lt;/code&gt;. &lt;code&gt;tie $handle&lt;/code&gt; ties the scalar variable &lt;code&gt;$handle&lt;/code&gt;, not the handle inside it.</source>
          <target state="translated">ハンドルを結ぶ場合は、最初の引数 &lt;code&gt;tie&lt;/code&gt; アスタリスクで開始する必要があります。したがって、STDOUTを結び付ける場合は、 &lt;code&gt;*STDOUT&lt;/code&gt; を使用します。 &lt;code&gt;$handle&lt;/code&gt; などのスカラー変数に割り当てた場合は、 &lt;code&gt;*$handle&lt;/code&gt; 使用します。 &lt;code&gt;tie $handle&lt;/code&gt; ネクタイスカラー変数 &lt;code&gt;$handle&lt;/code&gt; ではなく、それインサイドハンドルを。</target>
        </trans-unit>
        <trans-unit id="dec3ae376ab632badfb7a32a894228e134f3e11c" translate="yes" xml:space="preserve">
          <source>When uncompressing with &lt;code&gt;IO-Uncompress-Unzip&lt;/code&gt;, it will automatically detect if the zip file is zip64.</source>
          <target state="translated">で解凍すると &lt;code&gt;IO-Uncompress-Unzip&lt;/code&gt; zipファイルがZIP64であれば、それは自動的に検出します。</target>
        </trans-unit>
        <trans-unit id="47eb3f77b1aa39c24f8302cc0873a61651a1ff55" translate="yes" xml:space="preserve">
          <source>When used as a class method (&lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt; , sometimes referred to as a static method), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">クラスメソッドとして使用する場合（ &lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt; 、時には静的メソッドと呼ぶ） &lt;code&gt;isa&lt;/code&gt; 戻ります</target>
        </trans-unit>
        <trans-unit id="1f0c66833fbe6e1b03af60ec0fe15b9334c1979b" translate="yes" xml:space="preserve">
          <source>When used as a class method (&lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt;, sometimes referred to as a static method), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">クラスメソッド（ &lt;code&gt;CLASS-&amp;gt;isa( TYPE )&lt;/code&gt; 、静的メソッドと呼ばれることもあります）として使用すると、 &lt;code&gt;isa&lt;/code&gt; は戻り値を返します。</target>
        </trans-unit>
        <trans-unit id="fd75a54bcbf3526f0df59166b3d1ecbeabab7eb5" translate="yes" xml:space="preserve">
          <source>When used as a class method the &lt;code&gt;\%facet_data&lt;/code&gt; argument is required.</source>
          <target state="translated">クラスメソッドとして使用する場合は、 &lt;code&gt;\%facet_data&lt;/code&gt; 引数が必要です。</target>
        </trans-unit>
        <trans-unit id="162b9c04aadf8419ca082eaa8547d0e2ff3e950b" translate="yes" xml:space="preserve">
          <source>When used as a filter we want to invoke it like this:</source>
          <target state="translated">フィルタとして使用する場合はこのように呼び出したいと思います。</target>
        </trans-unit>
        <trans-unit id="b4db60389b8735ef282c0fba599e707380d0e9b0" translate="yes" xml:space="preserve">
          <source>When used as an instance or class method (&lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt; ), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">インスタンスまたはクラスメソッドとして使用（ &lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt; ）、 &lt;code&gt;isa&lt;/code&gt; 戻り</target>
        </trans-unit>
        <trans-unit id="0c835a1bdea740af7b69e93efd47e9739cc62c50" translate="yes" xml:space="preserve">
          <source>When used as an instance or class method (&lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt;), &lt;code&gt;isa&lt;/code&gt; returns</source>
          <target state="translated">インスタンスまたはクラスのメソッド（ &lt;code&gt;$obj-&amp;gt;isa( TYPE )&lt;/code&gt; ）として使用すると、 &lt;code&gt;isa&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="ee80d9e31f7273254ea3de17e8c9cb461c0c08a0" translate="yes" xml:space="preserve">
          <source>When used as an object method the &lt;code&gt;\%facet_data&lt;/code&gt; argument may be omitted.</source>
          <target state="translated">オブジェクトメソッドとして使用する場合、 &lt;code&gt;\%facet_data&lt;/code&gt; 引数は省略できます。</target>
        </trans-unit>
        <trans-unit id="3dac020145ba791bbcde686e21207104ab4efac0" translate="yes" xml:space="preserve">
          <source>When used as methods, all these subroutines call &lt;code&gt;$e-&amp;gt;facet_data()&lt;/code&gt;. The default &lt;code&gt;facet_data()&lt;/code&gt; method in &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt; relies on the legacy methods this module emulates in order to work. As a result of this it is very easy to create infinite recursion bugs.</source>
          <target state="translated">メソッドとして使用する場合、これらのサブルーチンはすべて &lt;code&gt;$e-&amp;gt;facet_data()&lt;/code&gt; 呼び出します。&lt;a href=&quot;Test2::Event&quot;&gt;Test2 :: Event&lt;/a&gt;のデフォルトの &lt;code&gt;facet_data()&lt;/code&gt; メソッドは、このモジュールが機能するためにエミュレートするレガシーメソッドに依存しています。この結果、無限再帰バグを作成するのは非常に簡単です。</target>
        </trans-unit>
        <trans-unit id="5e6ec0259043a949cd69ad7f24d41a6b32189cc3" translate="yes" xml:space="preserve">
          <source>When used like this, options and their possible values are removed from &lt;code&gt;@myopts&lt;/code&gt; , the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched at all.</source>
          <target state="translated">このように使用すると、オプションとその可能な値が &lt;code&gt;@myopts&lt;/code&gt; から削除され、グローバル &lt;code&gt;@ARGV&lt;/code&gt; はまったく影響を受けません。</target>
        </trans-unit>
        <trans-unit id="80c8f7c123cd2630d333f7d9131c53ccb92cec1a" translate="yes" xml:space="preserve">
          <source>When used like this, options and their possible values are removed from &lt;code&gt;@myopts&lt;/code&gt;, the global &lt;code&gt;@ARGV&lt;/code&gt; is not touched at all.</source>
          <target state="translated">このように使用すると、オプションとその可能な値が &lt;code&gt;@myopts&lt;/code&gt; から削除され、グローバル &lt;code&gt;@ARGV&lt;/code&gt; はまったく変更されません。</target>
        </trans-unit>
        <trans-unit id="ea41fdab3a3ea375bf5d28665d083eb7efcab0b4" translate="yes" xml:space="preserve">
          <source>When used like this:</source>
          <target state="translated">こんな風に使うと</target>
        </trans-unit>
        <trans-unit id="55e5fa91bb111ccb9cef7a1998ea49cd864765f0" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;#exists&quot;&gt;exists&lt;/a&gt; for the latter purpose.</source>
          <target state="translated">ハッシュ要素で使用すると、キーがハッシュに存在するかどうかではなく、値が定義されているかどうかがわかります。後者の目的で使用され&lt;a href=&quot;#exists&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ea5744253b0aebebea0a675efdda097478c50c9" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;#exists-EXPR&quot;&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/a&gt; for the latter purpose.</source>
          <target state="translated">ハッシュ要素で使用すると、キーがハッシュに存在するかどうかではなく、値が定義されているかどうかがわかります。後者の目的での使用&lt;a href=&quot;#exists-EXPR&quot;&gt; &lt;code&gt;exists&lt;/code&gt; &lt;/a&gt;します。</target>
        </trans-unit>
        <trans-unit id="9b6188971c7d17d6c416874631a361633fc0e0a7" translate="yes" xml:space="preserve">
          <source>When used on a hash element, it tells you whether the value is defined, not whether the key exists in the hash. Use &lt;a href=&quot;exists&quot;&gt;exists&lt;/a&gt; for the latter purpose.</source>
          <target state="translated">ハッシュ要素で使用すると、キーがハッシュに存在するかどうかではなく、値が定義されているかどうかがわかります。後者の目的で使用され&lt;a href=&quot;exists&quot;&gt;ます&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="50c2719662a96956c6434b730a2ed7499859c514" translate="yes" xml:space="preserve">
          <source>When used on an element of an array or hash, &lt;code&gt;is_shared&lt;/code&gt; checks if the specified element belongs to a shared array or hash. (It does not check the contents of that element.)</source>
          <target state="translated">&lt;code&gt;is_shared&lt;/code&gt; は、配列またはハッシュの要素で使用すると、指定した要素が共有配列またはハッシュに属しているかどうかを確認します。（その要素の内容はチェックしません。）</target>
        </trans-unit>
        <trans-unit id="4c68152ee142aad2a08fe0b7ebba2ea1aa45f4fa" translate="yes" xml:space="preserve">
          <source>When used to pass a perl list to C the XS writer must provide a function (named after the array type but with 'Ptr' substituted for '*') to allocate the memory required to hold the list. A pointer should be returned. It is up to the XS writer to free the memory on exit from the function. The variable &lt;code&gt;ix_$var&lt;/code&gt; is set to the number of elements in the new array.</source>
          <target state="translated">PerlリストをCに渡すために使用する場合、XSライターは、リストを保持するために必要なメモリを割り当てる関数（配列タイプにちなんで名前が「*」の代わりに「Ptr」が使用されている）を提供する必要があります。ポインタが返されます。関数の終了時にメモリを解放するのはXSライターの責任です。変数 &lt;code&gt;ix_$var&lt;/code&gt; は、新しい配列の要素数に設定されます。</target>
        </trans-unit>
        <trans-unit id="39279e0ab9adf92c0d9845ce33153aaae548b141" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;.&lt;/code&gt;, the repeat count determines the starting position to calculate the value offset as follows:</source>
          <target state="translated">で使用し &lt;code&gt;.&lt;/code&gt; 場合。、繰り返し回数は、次のようにオフセット値を計算するための開始位置を決定します。</target>
        </trans-unit>
        <trans-unit id="059dd6ca0ad7f29f71f81bb70c2d0a3da8cc3820" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;@&lt;/code&gt; , the repeat count represents an offset from the start of the innermost &lt;code&gt;()&lt;/code&gt; group.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; と一緒に使用すると、繰り返し数は最も内側の &lt;code&gt;()&lt;/code&gt; グループの先頭からのオフセットを表します。</target>
        </trans-unit>
        <trans-unit id="452ac7244192f1d1049652316194fb25f11bd124" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;@&lt;/code&gt;, the repeat count represents an offset from the start of the innermost &lt;code&gt;()&lt;/code&gt; group.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; とともに使用すると、繰り返し回数は最も内側の &lt;code&gt;()&lt;/code&gt; グループの先頭からのオフセットを表します。</target>
        </trans-unit>
        <trans-unit id="745e9758fddddfd17b1f8070f37c73b6ef6dd2f4" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;Z&lt;/code&gt; , a &lt;code&gt;*&lt;/code&gt; as the repeat count is guaranteed to add a trailing null byte, so the resulting string is always one byte longer than the byte length of the item itself.</source>
          <target state="translated">で使用した場合 &lt;code&gt;Z&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 結果の文字列は、アイテム自体のバイト長より1台のバイト長く常にあるので、繰り返し回数としては、末尾のヌル・バイトを追加することが保証されています。</target>
        </trans-unit>
        <trans-unit id="3e309ae810b7ba69caf1b083747a6f0e33a6ad11" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;Z&lt;/code&gt;, a &lt;code&gt;*&lt;/code&gt; as the repeat count is guaranteed to add a trailing null byte, so the resulting string is always one byte longer than the byte length of the item itself.</source>
          <target state="translated">で使用した場合 &lt;code&gt;Z&lt;/code&gt; 、 &lt;code&gt;*&lt;/code&gt; 結果の文字列は、アイテム自体のバイト長より1台のバイト長く常にあるので、繰り返し回数としては、末尾のヌル・バイトを追加することが保証されています。</target>
        </trans-unit>
        <trans-unit id="501ee2b6d5b82410bf49c6ef557d5b8111f9b9e9" translate="yes" xml:space="preserve">
          <source>When used with class methods, the problem is even worse. Because Perl allows subroutine names to be written as barewords, Perl has to guess whether the bareword after the method is a class name or subroutine name. In other words, Perl can resolve the syntax as either &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt;&lt;b&gt;or&lt;/b&gt;&lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; .</source>
          <target state="translated">クラスメソッドで使用すると、問題はさらに悪化します。Perlではサブルーチン名をベアワードとして書き込むことができるため、Perlはメソッドの後のベアワードがクラス名かサブルーチン名かを推測する必要があります。言い換えれば、Perlは構文を &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt; &lt;b&gt;または&lt;/b&gt; &lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; として解決できます。</target>
        </trans-unit>
        <trans-unit id="a4f8a19419e9cae531fd00a5faf3b4b95c08f01c" translate="yes" xml:space="preserve">
          <source>When used with class methods, the problem is even worse. Because Perl allows subroutine names to be written as barewords, Perl has to guess whether the bareword after the method is a class name or subroutine name. In other words, Perl can resolve the syntax as either &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt;&lt;b&gt;or&lt;/b&gt;&lt;code&gt;new( File( $path, $data ) )&lt;/code&gt;.</source>
          <target state="translated">クラスメソッドと一緒に使用すると、問題はさらに悪化します。Perlではサブルーチン名をベアワードとして書き込むことができるため、Perlはメソッドの後のベアワードがクラス名であるかサブルーチン名であるかを推測する必要があります。言い換えると、Perlは構文を &lt;code&gt;File-&amp;gt;new( $path, $data )&lt;/code&gt; &lt;b&gt;または&lt;/b&gt; &lt;code&gt;new( File( $path, $data ) )&lt;/code&gt; いずれかとして解決できます。</target>
        </trans-unit>
        <trans-unit id="f87eff678443c76527dd2ab6f92ce339964a9f84" translate="yes" xml:space="preserve">
          <source>When used with command line options:</source>
          <target state="translated">コマンドラインオプションで使用する場合。</target>
        </trans-unit>
        <trans-unit id="034d2956d3ab35d5d0a3009bf9f647819ce96d9f" translate="yes" xml:space="preserve">
          <source>When userelocatableinc is true, this variable holds the location that make install should copy the perl binary to, with all the run-time relocatable paths calculated from this at install time. When used, it is initialized to the original value of binexp, and then binexp is set to</source>
          <target state="translated">userelocatableinc が真の場合、この変数は make install が perl バイナリをコピーする場所を保持します。使用される場合は、binexp の元の値に初期化され、binexp が</target>
        </trans-unit>
        <trans-unit id="52d8c19f5d99981fe4c4d2fcb09c34b0b19ca9a0" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; on a &lt;code&gt;()&lt;/code&gt; group, this affects all types inside the group that accept byte-order modifiers, including all subgroups. It is silently ignored for all other types. You are not allowed to override the byte-order within a group that already has a byte-order modifier suffix.</source>
          <target state="translated">使用する場合 &lt;code&gt;&amp;gt;&lt;/code&gt; または &lt;code&gt;&amp;lt;&lt;/code&gt; 上 &lt;code&gt;()&lt;/code&gt; 群、これはすべてのサブグループを含む、バイト順修飾子を受け入れるグループ内のすべてのタイプに影響を与えます。他のすべてのタイプでは、黙って無視されます。既にバイト順修飾子のサフィックスが付いているグループ内のバイト順を上書きすることはできません。</target>
        </trans-unit>
        <trans-unit id="834a7e8ec8b7da2f955444b22e5081d5fee5d139" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Exporter&lt;/code&gt; with the standard &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; pragmas, the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; keyword is needed to declare the package variables &lt;code&gt;@EXPORT_OK&lt;/code&gt; , &lt;code&gt;@EXPORT&lt;/code&gt; , &lt;code&gt;@ISA&lt;/code&gt; , etc.</source>
          <target state="translated">使用する場合は &lt;code&gt;Exporter&lt;/code&gt; 規格に &lt;code&gt;strict&lt;/code&gt; と &lt;code&gt;warnings&lt;/code&gt; プラグマ、 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; キーワードは、パッケージ変数を宣言するために必要とされる &lt;code&gt;@EXPORT_OK&lt;/code&gt; 、 &lt;code&gt;@EXPORT&lt;/code&gt; 、 &lt;code&gt;@ISA&lt;/code&gt; など</target>
        </trans-unit>
        <trans-unit id="ff82b6a088bd3949701c2e9690b32b71bbe25933" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Exporter&lt;/code&gt; with the standard &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;warnings&lt;/code&gt; pragmas, the &lt;code&gt;our&lt;/code&gt; keyword is needed to declare the package variables &lt;code&gt;@EXPORT_OK&lt;/code&gt;, &lt;code&gt;@EXPORT&lt;/code&gt;, &lt;code&gt;@ISA&lt;/code&gt;, etc.</source>
          <target state="translated">使用する場合は &lt;code&gt;Exporter&lt;/code&gt; 規格に &lt;code&gt;strict&lt;/code&gt; と &lt;code&gt;warnings&lt;/code&gt; プラグマ、 &lt;code&gt;our&lt;/code&gt; キーワードは、パッケージ変数を宣言するために必要とされる &lt;code&gt;@EXPORT_OK&lt;/code&gt; 、 &lt;code&gt;@EXPORT&lt;/code&gt; 、 &lt;code&gt;@ISA&lt;/code&gt; など</target>
        </trans-unit>
        <trans-unit id="098b7ca0910242ebfe289953bb787b86df641163" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Open3&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, it is assumed to be appropriately escaped. You can use the &lt;code&gt;QUOTE&lt;/code&gt; constant to use as a portable quote character (see above). However, if you provide an array reference, special rules apply:</source>
          <target state="translated">使用する場合は &lt;code&gt;IPC::Open3&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;../functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 、あなたのように文字列を提供する場合、 &lt;code&gt;command&lt;/code&gt; 引数、適切にエスケープされているものとします。 &lt;code&gt;QUOTE&lt;/code&gt; 定数を使用して、移植可能な引用文字として使用できます（上記を参照）。ただし、配列参照を提供する場合は、特別な規則が適用されます。</target>
        </trans-unit>
        <trans-unit id="d2f0399c3e8df8b441dc7a3e6752ac0ac539b907" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Open3&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, it is assumed to be appropriately escaped. You can use the &lt;code&gt;QUOTE&lt;/code&gt; constant to use as a portable quote character (see above). However, if you provide an array reference, special rules apply:</source>
          <target state="translated">使用する場合は &lt;code&gt;IPC::Open3&lt;/code&gt; や &lt;code&gt;system&lt;/code&gt; 、あなたのように文字列を提供する場合、 &lt;code&gt;command&lt;/code&gt; 引数、適切にエスケープされているものとします。 &lt;code&gt;QUOTE&lt;/code&gt; 定数を使用して、移植可能な引用符文字として使用できます（上記を参照）。ただし、配列参照を指定すると、特別な規則が適用されます。</target>
        </trans-unit>
        <trans-unit id="ac72f6ccde75b586d99f93dce2fef690fbdd778e" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Run&lt;/code&gt; , if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, the string will be split on whitespace to determine the individual elements of your command. Although this will usually just Do What You Mean, it may break if you have files or commands with whitespace in them.</source>
          <target state="translated">&lt;code&gt;IPC::Run&lt;/code&gt; を使用する場合、 &lt;code&gt;command&lt;/code&gt; 引数として文字列を指定すると、コマンドの個々の要素を決定するために文字列が空白で分割されます。これは通常、意味を実行するだけですが、空白を含むファイルまたはコマンドがある場合は、機能しなくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="cb299ab15bb95a67fd9da59509a66d398c459654" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;IPC::Run&lt;/code&gt;, if you provide a string as the &lt;code&gt;command&lt;/code&gt; argument, the string will be split on whitespace to determine the individual elements of your command. Although this will usually just Do What You Mean, it may break if you have files or commands with whitespace in them.</source>
          <target state="translated">&lt;code&gt;IPC::Run&lt;/code&gt; を使用する場合、 &lt;code&gt;command&lt;/code&gt; 引数として文字列を指定すると、文字列は空白で分割され、コマンドの個々の要素が決定されます。これは通常、あなたが意味することを実行するだけですが、空白を含むファイルやコマンドがあると壊れることがあります。</target>
        </trans-unit>
        <trans-unit id="9bd114611c2ad871f0c8eb7b6bb0b00563bb8b3c" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Perl_langinfo&lt;/code&gt; on systems that don't have a native &lt;code&gt;nl_langinfo()&lt;/code&gt;, you must</source>
          <target state="translated">使用している場合 &lt;code&gt;Perl_langinfo&lt;/code&gt; をネイティブ持っていないシステム上 &lt;code&gt;nl_langinfo()&lt;/code&gt; 、次の操作が必要</target>
        </trans-unit>
        <trans-unit id="887f4ef11aea133bd95f7e158dd018aa1d9071b1" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;autodie&lt;/code&gt; or &lt;code&gt;Fatal&lt;/code&gt; with user subroutines, the declaration of those subroutines must appear before the first use of &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; , or have been exported from a module. Attempting to use &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; on other user subroutines will result in a compile-time error.</source>
          <target state="translated">使用する場合 &lt;code&gt;autodie&lt;/code&gt; または &lt;code&gt;Fatal&lt;/code&gt; ユーザサブルーチンとを、それらのサブルーチンの宣言は、最初の使用の前に現れなければならない &lt;code&gt;Fatal&lt;/code&gt; または &lt;code&gt;autodie&lt;/code&gt; 、またはモジュールからエクスポートされています。他のユーザーサブルーチンで &lt;code&gt;Fatal&lt;/code&gt; または &lt;code&gt;autodie&lt;/code&gt; を使用しようとすると、コンパイル時エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="d38b1b6fe53eaefb297f9d879236a334c99468e3" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;autodie&lt;/code&gt; or &lt;code&gt;Fatal&lt;/code&gt; with user subroutines, the declaration of those subroutines must appear before the first use of &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt;, or have been exported from a module. Attempting to use &lt;code&gt;Fatal&lt;/code&gt; or &lt;code&gt;autodie&lt;/code&gt; on other user subroutines will result in a compile-time error.</source>
          <target state="translated">使用する場合 &lt;code&gt;autodie&lt;/code&gt; または &lt;code&gt;Fatal&lt;/code&gt; ユーザサブルーチンとを、それらのサブルーチンの宣言は、最初の使用の前に現れなければならない &lt;code&gt;Fatal&lt;/code&gt; または &lt;code&gt;autodie&lt;/code&gt; 、またはモジュールからエクスポートされています。他のユーザーサブルーチンで &lt;code&gt;Fatal&lt;/code&gt; または &lt;code&gt;autodie&lt;/code&gt; を使用しようとすると、コンパイル時エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="8ea0745997af7ee70fec196994401476b7830212" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fd_retrieve&lt;/code&gt; , objects are retrieved in sequence, one object (i.e. one recursive tree) per associated &lt;code&gt;store_fd&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;fd_retrieve&lt;/code&gt; を使用すると、オブジェクトは順番に取得され、関連付けられた &lt;code&gt;store_fd&lt;/code&gt; ごとに1つのオブジェクト（つまり、1つの再帰的ツリー）が取得されます。</target>
        </trans-unit>
        <trans-unit id="12e3df8bd541ba3c998025aaa4430e3500847d06" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;fd_retrieve&lt;/code&gt;, objects are retrieved in sequence, one object (i.e. one recursive tree) per associated &lt;code&gt;store_fd&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fd_retrieve&lt;/code&gt; を使用する場合、オブジェクトは順番に取得されます。関連付けられた &lt;code&gt;store_fd&lt;/code&gt; ごとに1つのオブジェクト（つまり、1つの再帰ツリー）です。</target>
        </trans-unit>
        <trans-unit id="e2d48fc5105eb38ba5d5e3af6a3868bf8d76aac7" translate="yes" xml:space="preserve">
          <source>When using GCC, that entry specifies that MakeMaker should first look for &lt;code&gt;libgl.a&lt;/code&gt; (followed by &lt;code&gt;gl.a&lt;/code&gt; ) in all the locations specified by &lt;code&gt;$Config{libpth}&lt;/code&gt; .</source>
          <target state="translated">GCCを使用する場合、そのエントリは、MakeMakerが最初に &lt;code&gt;$Config{libpth}&lt;/code&gt; 指定されたすべての場所で &lt;code&gt;libgl.a&lt;/code&gt; （後に &lt;code&gt;gl.a&lt;/code&gt; ）を探すように指定します。</target>
        </trans-unit>
        <trans-unit id="2c8cc8b7dc989aa2e0c54fa773dd36d96d318229" translate="yes" xml:space="preserve">
          <source>When using GCC, that entry specifies that MakeMaker should first look for &lt;code&gt;libgl.a&lt;/code&gt; (followed by &lt;code&gt;gl.a&lt;/code&gt;) in all the locations specified by &lt;code&gt;$Config{libpth}&lt;/code&gt;.</source>
          <target state="translated">GCCを使用する場合、そのエントリは、MakeMakerが最初に &lt;code&gt;$Config{libpth}&lt;/code&gt; 指定されたすべての場所で &lt;code&gt;libgl.a&lt;/code&gt; （続いて &lt;code&gt;gl.a&lt;/code&gt; ）を検索する必要があることを指定します。</target>
        </trans-unit>
        <trans-unit id="d3c3fbdf4905ed574790e43ad2b1e958281ade4d" translate="yes" xml:space="preserve">
          <source>When using Module::Build, this will usually be:</source>
          <target state="translated">Module::Buildを使用する場合、通常はこれになります。</target>
        </trans-unit>
        <trans-unit id="04e10d3b847f5d46ec45809bdc9654ea510527e6" translate="yes" xml:space="preserve">
          <source>When using PUSHCOLOR, POPCOLOR, and LOCALCOLOR, it's particularly important to not put commas between the constants.</source>
          <target state="translated">PUSHCOLOR、POPCOLOR、LOCALCOLORを使用する場合は、定数の間にカンマを入れないことが特に重要です。</target>
        </trans-unit>
        <trans-unit id="0fcdfebaed2e26ac7b40fe2bc2a6520f86b06a73" translate="yes" xml:space="preserve">
          <source>When using Term::ReadLine, you can turn ornaments on so that your input stands out against the output from CPAN.pm.</source>
          <target state="translated">Term::ReadLineを使用している場合、CPAN.pmからの出力に対して入力が目立つように装飾をオンにすることができます。</target>
        </trans-unit>
        <trans-unit id="3bb24a915046f34ce04a56f60336d0fb58d6c025" translate="yes" xml:space="preserve">
          <source>When using Unix or MSDOS syntax this emulates the &lt;code&gt;dirname(1)&lt;/code&gt; shell function which is subtly different from how &lt;code&gt;fileparse()&lt;/code&gt; works. It returns all but the last level of a file path even if the last level is clearly a directory. In effect, it is not returning the directory portion but simply the path one level up acting like &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; for file paths.</source>
          <target state="translated">UnixまたはMSDOS構文を使用する場合、 &lt;code&gt;fileparse()&lt;/code&gt; の動作とは微妙に異なる &lt;code&gt;dirname(1)&lt;/code&gt; シェル関数をエミュレートします。最後のレベルが明らかにディレクトリであっても、ファイルパスの最後のレベルを除くすべてを返します。実際には、それはディレクトリ部分を返すのではなく、ファイルパスの &lt;code&gt;&lt;a href=&quot;../functions/chop&quot;&gt;chop()&lt;/a&gt;&lt;/code&gt; のように機能する1レベル上のパスを返します。</target>
        </trans-unit>
        <trans-unit id="83acdc7454980247f70cca18686669a6056893a4" translate="yes" xml:space="preserve">
          <source>When using Unix or MSDOS syntax this emulates the &lt;code&gt;dirname(1)&lt;/code&gt; shell function which is subtly different from how &lt;code&gt;fileparse()&lt;/code&gt; works. It returns all but the last level of a file path even if the last level is clearly a directory. In effect, it is not returning the directory portion but simply the path one level up acting like &lt;code&gt;chop()&lt;/code&gt; for file paths.</source>
          <target state="translated">UnixまたはMSDOS構文を使用する場合、これは &lt;code&gt;dirname(1)&lt;/code&gt; シェル関数をエミュレートしますが、これは &lt;code&gt;fileparse()&lt;/code&gt; の動作とは微妙に異なります。最後のレベルが明らかにディレクトリであっても、ファイルパスの最後のレベルを除くすべてを返します。実際には、ディレクトリ部分を返すのではなく、ファイルパスの &lt;code&gt;chop()&lt;/code&gt; のように機能する1レベル上のパスを返すだけです。</target>
        </trans-unit>
        <trans-unit id="cd36b103bb843eb67404d1ba086bba3444a9a91a" translate="yes" xml:space="preserve">
          <source>When using a compiler other than GCC, the above entry will search for &lt;code&gt;gl.lib&lt;/code&gt; (followed by &lt;code&gt;libgl.lib&lt;/code&gt; ).</source>
          <target state="translated">GCC以外のコンパイラを使用する場合、上記のエントリは &lt;code&gt;gl.lib&lt;/code&gt; を検索します（その後に &lt;code&gt;libgl.lib&lt;/code&gt; が続きます）。</target>
        </trans-unit>
        <trans-unit id="c33d34fd00e0ffeecdde05351cb8111bf653102c" translate="yes" xml:space="preserve">
          <source>When using a compiler other than GCC, the above entry will search for &lt;code&gt;gl.lib&lt;/code&gt; (followed by &lt;code&gt;libgl.lib&lt;/code&gt;).</source>
          <target state="translated">GCC以外のコンパイラを使用する場合、上記のエントリは &lt;code&gt;gl.lib&lt;/code&gt; を検索します（その後に &lt;code&gt;libgl.lib&lt;/code&gt; が続きます）。</target>
        </trans-unit>
        <trans-unit id="a204d7a3df2c41a83e110893f714e673583621f8" translate="yes" xml:space="preserve">
          <source>When using a custom engine that doesn't support the &lt;code&gt;(?:)&lt;/code&gt; construct for inline modifiers, it's probably best to have &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</source>
          <target state="translated">インライン修飾子の &lt;code&gt;(?:)&lt;/code&gt; 構成をサポートしないカスタムエンジンを使用する場合、 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; を指定のパターンに文字列化するのがおそらく最善です。これにより、次のような場合に望ましくないパターンが作成されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5336937191442d7debf67f5b96f41e967c4d55af" translate="yes" xml:space="preserve">
          <source>When using a custom engine that doesn't support the &lt;code&gt;(?:)&lt;/code&gt; construct for inline modifiers, it's probably best to have &lt;code&gt;qr//&lt;/code&gt; stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</source>
          <target state="translated">インライン修飾子の &lt;code&gt;(?:)&lt;/code&gt; 構文をサポートしないカスタムエンジンを使用する場合は、 &lt;code&gt;qr//&lt;/code&gt; を指定されたパターンに文字列化するのがおそらく最善です。これにより、次のような場合に望ましくないパターンが作成されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="aa29772ff0d1046f60f263e930495cc6300916c4" translate="yes" xml:space="preserve">
          <source>When using a signature, the arguments are still available in the special array variable &lt;code&gt;@_&lt;/code&gt; , in addition to the lexical variables of the signature. There is a difference between the two ways of accessing the arguments: &lt;code&gt;@_&lt;/code&gt;</source>
          <target state="translated">署名を使用する場合、引数は、署名の字句変数に加えて、特別な配列変数 &lt;code&gt;@_&lt;/code&gt; でも引き続き使用できます。引数にアクセスする2つの方法には違いがあります： &lt;code&gt;@_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e523513d7b0658b27eb8124687617b728e5c9ac2" translate="yes" xml:space="preserve">
          <source>When using a signature, the arguments are still available in the special array variable &lt;code&gt;@_&lt;/code&gt;, in addition to the lexical variables of the signature. There is a difference between the two ways of accessing the arguments: &lt;code&gt;@_&lt;/code&gt;</source>
          <target state="translated">署名を使用する場合、引数は、署名の字句変数に加えて、特別な配列変数 &lt;code&gt;@_&lt;/code&gt; で引き続き使用できます。引数にアクセスする2つの方法には違いがあります： &lt;code&gt;@_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="551ef8173c29847114a58bb1f60332f351498c93" translate="yes" xml:space="preserve">
          <source>When using any of these routines (except &lt;code&gt;call_argv&lt;/code&gt; ), the programmer must manipulate the Perl stack. These include the following macros and functions:</source>
          <target state="translated">これらのルーチン（ &lt;code&gt;call_argv&lt;/code&gt; を除く）を使用する場合、プログラマーはPerlスタックを操作する必要があります。これらには、次のマクロと関数が含まれます。</target>
        </trans-unit>
        <trans-unit id="b91da188fa3782ad027e51e622e75b65bd3a446d" translate="yes" xml:space="preserve">
          <source>When using any of these routines (except &lt;code&gt;call_argv&lt;/code&gt;), the programmer must manipulate the Perl stack. These include the following macros and functions:</source>
          <target state="translated">これらのルーチン（ &lt;code&gt;call_argv&lt;/code&gt; を除く）のいずれかを使用する場合、プログラマーはPerlスタックを操作する必要があります。これらには、次のマクロと関数が含まれます。</target>
        </trans-unit>
        <trans-unit id="b83deb7885e7123190175e707dccaec554d080b8" translate="yes" xml:space="preserve">
          <source>When using look-ahead assertions and negations, this can all get even trickier. Imagine you'd like to find a sequence of non-digits not followed by &quot;123&quot;. You might try to write that as</source>
          <target state="translated">先読みアサーションや否定を使用すると、これがさらに厄介になることがあります。123&quot; の後に &quot;123 &quot;が続いていない非数値の連続を見つけたいと想像してみてください。次のように書いてみましょう。</target>
        </trans-unit>
        <trans-unit id="8056637c2c9cbcfa303f8f1dbc6790e418dcb403" translate="yes" xml:space="preserve">
          <source>When using lookahead assertions and negations, this can all get even trickier. Imagine you'd like to find a sequence of non-digits not followed by &quot;123&quot;. You might try to write that as</source>
          <target state="translated">ルックヘッドアサーションや否定を使用すると、これがさらに厄介になることがあります。123&quot; の後に &quot;123 &quot;が続かない非数値の連続を見つけたいとしましょう。次のように書いてみましょう。</target>
        </trans-unit>
        <trans-unit id="f069b81fc03a5abd7bd819f6288faad34de8014e" translate="yes" xml:space="preserve">
          <source>When using non-blocking mode, the caller must repeatedly check for writeability on the filehandle (for instance using &lt;code&gt;select&lt;/code&gt; or &lt;code&gt;IO::Poll&lt;/code&gt;). Each time the filehandle is ready to write, the &lt;code&gt;connect&lt;/code&gt; method must be called, with no arguments. Note that some operating systems, most notably &lt;code&gt;MSWin32&lt;/code&gt; do not report a &lt;code&gt;connect()&lt;/code&gt; failure using write-ready; so you must also &lt;code&gt;select()&lt;/code&gt; for exceptional status.</source>
          <target state="translated">非ブロッキングモードを使用する場合、呼び出し元はファイルハンドルの書き込み可能性を繰り返しチェックする必要があります（たとえば、 &lt;code&gt;select&lt;/code&gt; または &lt;code&gt;IO::Poll&lt;/code&gt; ）。ファイルハンドルを書き込む準備ができるたびに、引数なしで &lt;code&gt;connect&lt;/code&gt; メソッドを呼び出す必要があります。一部のオペレーティングシステム、特に &lt;code&gt;MSWin32&lt;/code&gt; は、write-readyを使用して &lt;code&gt;connect()&lt;/code&gt; の失敗を報告しないことに注意してください。したがって、例外的なステータスの場合は &lt;code&gt;select()&lt;/code&gt; も必要です。</target>
        </trans-unit>
        <trans-unit id="104bb1d18df407b49f695cf681f4f8244f6c16f3" translate="yes" xml:space="preserve">
          <source>When using perl on OS/390 please keep in mind that the EBCDIC and ASCII character sets are different. See perlebcdic.pod for more on such character set issues. Perl builtin functions that may behave differently under EBCDIC are also mentioned in the perlport.pod document.</source>
          <target state="translated">OS/390 で perl を使うときは、EBCDIC と ASCII の文字セットが異なることを覚えておいてください。そのような文字セットの問題については perlebcdic.pod を参照してください。EBCDIC の下で異なる動作をするかもしれない Perl の組み込み関数は、perlport.pod のドキュメントにも記載されています。</target>
        </trans-unit>
        <trans-unit id="1ef7e739e319a736386db6464491dd098d4f2bf1" translate="yes" xml:space="preserve">
          <source>When using perldoc in it's &lt;code&gt;-m&lt;/code&gt; mode (display module source code), &lt;code&gt;perldoc&lt;/code&gt; will attempt to use the pager set in &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; . A useful setting for this command is your favorite editor as in &lt;code&gt;/usr/bin/nano&lt;/code&gt; . (Don't judge me.)</source>
          <target state="translated">それの中にはperldoc使用する場合は &lt;code&gt;-m&lt;/code&gt; モード（ディスプレイモジュールのソースコードを）、 &lt;code&gt;perldoc&lt;/code&gt; のは、ページャのセットを使用しようとします &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; 。このコマンドの便利な設定は、 &lt;code&gt;/usr/bin/nano&lt;/code&gt; にあるようなお気に入りのエディターです。（私を判断しないでください。）</target>
        </trans-unit>
        <trans-unit id="ca44e9fc9c83d8e97acbec5970188d530099b61d" translate="yes" xml:space="preserve">
          <source>When using perldoc in it's &lt;code&gt;-m&lt;/code&gt; mode (display module source code), &lt;code&gt;perldoc&lt;/code&gt; will attempt to use the pager set in &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt;. A useful setting for this command is your favorite editor as in &lt;code&gt;/usr/bin/nano&lt;/code&gt;. (Don't judge me.)</source>
          <target state="translated">perldocを &lt;code&gt;-m&lt;/code&gt; モード（ディスプレイモジュールのソースコード）で使用すると、 &lt;code&gt;perldoc&lt;/code&gt; は &lt;code&gt;PERLDOC_SRC_PAGER&lt;/code&gt; で設定されたページャーを使用しようとします。このコマンドの便利な設定は、 &lt;code&gt;/usr/bin/nano&lt;/code&gt; のようなお気に入りのエディターです。 （私を判断しないでください。）</target>
        </trans-unit>
        <trans-unit id="6f3d08e19ee9978bf8615d5e1fb391a30ff5fc30" translate="yes" xml:space="preserve">
          <source>When using the &quot;syn&quot; protocol, use this method to determine the reachability of the remote host. This method is meant to be called up to as many times as ping() was called. Each call returns the host (as passed to ping()) that came back with the TCP ACK. The order in which the hosts are returned may not necessarily be the same order in which they were SYN queued using the ping() method. If the timeout is reached before the TCP ACK is received, or if the remote host is not listening on the port attempted, then the TCP connection will not be established and ack() will return undef. In list context, the host, the ack time, and the dotted ip string will be returned instead of just the host. If the optional $host argument is specified, the return value will be pertaining to that host only. This call simply does nothing if you are using any protocol other than syn.</source>
          <target state="translated">syn&quot; プロトコルを使用する場合、このメソッドを使用してリモートホストの到達可能性を判断します。このメソッドは、ping()が呼び出された回数だけ呼び出されることを意味します。各呼び出しは、TCP ACK を返してきたホスト (ping()に渡されたホスト)を返します。ホストが返される順番は、必ずしも ping()メソッドを使用して SYN キューに入れられた順番と同じとは限りません。TCP ACK を受信する前にタイムアウトに達した場合や、リモートホストが試みたポートをリッスンしていない場合は、TCP 接続は確立されず、 ack()は undef を返します。リストコンテキストでは、ホストだけではなく、ホスト、ACK時間、点線付きのIP文字列が返されます。オプションの $host 引数が指定された場合は、そのホストに関するものだけが返されます。syn 以外のプロトコルを使っている場合、この呼び出しは何もしません。</target>
        </trans-unit>
        <trans-unit id="420afa8aef5868ada909527b4d0cf95eed4c31dc" translate="yes" xml:space="preserve">
          <source>When using the &quot;syn&quot; protocol, use this method to determine the reachability of the remote host. This method is meant to be called up to as many times as ping() was called. Each call returns the host (as passed to ping()) that came back with the TCP ACK. The order in which the hosts are returned may not necessarily be the same order in which they were SYN queued using the ping() method. If the timeout is reached before the TCP ACK is received, or if the remote host is not listening on the port attempted, then the TCP connection will not be established and ack() will return undef. In list context, the host, the ack time, the dotted ip string, and the port number will be returned instead of just the host. If the optional &lt;code&gt;$host&lt;/code&gt; argument is specified, the return value will be pertaining to that host only. This call simply does nothing if you are using any protocol other than &quot;syn&quot;.</source>
          <target state="translated">「syn」プロトコルを使用する場合は、この方法を使用してリモートホストの到達可能性を判断します。このメソッドは、ping（）が呼び出された回数まで呼び出されることを意図しています。各呼び出しは、TCP ACKで戻ってきたホスト（ping（）に渡されたもの）を返します。ホストが返される順序は、必ずしもping（）メソッドを使用してSYNキューに入れられた順序と同じであるとは限りません。 TCP ACKを受信する前にタイムアウトに達した場合、またはリモートホストが試行されたポートをリッスンしていない場合、TCP接続は確立されず、ack（）はundefを返します。リストコンテキストでは、ホストだけでなく、ホスト、ACK時間、点線のIP文字列、およびポート番号が返されます。オプションの &lt;code&gt;$host&lt;/code&gt; 場合引数が指定されている場合、戻り値はそのホストのみに関係します。「syn」以外のプロトコルを使用している場合、この呼び出しは何もしません。</target>
        </trans-unit>
        <trans-unit id="8669a447d2a5338b38de691880feda228a223459" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;+&lt;/code&gt; prototype, your function must check that the argument is of an acceptable type.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; プロトタイプを使用する場合、関数は引数が受け入れ可能なタイプであることを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="665e3521b5bde08e89b6fb412400db5ea3876686" translate="yes" xml:space="preserve">
          <source>When using the Borland compiler, the second item is returned as &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt;, and MakeMaker takes care of moving the &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; to the correct place in the linker command line.</source>
          <target state="translated">Borlandコンパイラを使用する場合、2番目の項目は &lt;code&gt;-Ld:\mesalibs mesa.lib user32.lib&lt;/code&gt; として返され、MakeMakerが &lt;code&gt;-Ld:\mesalibs&lt;/code&gt; をリンカーコマンドラインの正しい場所に移動します。</target>
        </trans-unit>
        <trans-unit id="182973d530ef056d12686b9b768cbe121c56d846" translate="yes" xml:space="preserve">
          <source>When using the GUI version of SAM, click on the Kernel Configuration icon, then the Configurable Parameters icon. Scroll down and select the maxdsiz line. From the Actions menu, select the Modify Configurable Parameter item. Insert the new formula into the Formula/Value box. Then follow the instructions to rebuild your kernel and reboot your system.</source>
          <target state="translated">GUI 版の SAM を使用する場合は、[Kernel Configuration]アイコンをクリックし、[Configurable Parameters]アイコンをクリックします。下にスクロールして、maxdsiz 行を選択します。Actions」メニューから「Modify Configurable Parameter」項目を選択します。Formula/Value ボックスに新しい式を挿入します。その後、指示に従ってカーネルを再構築し、システムを再起動します。</target>
        </trans-unit>
        <trans-unit id="7f3f457ad81c7a19053f3621a5ae319fe9cb4521" translate="yes" xml:space="preserve">
          <source>When using the Visual C compiler, the second item is returned as &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt;.</source>
          <target state="translated">Visual Cコンパイラーを使用する場合、2番目の項目は &lt;code&gt;-libpath:d:\mesalibs mesa.lib user32.lib&lt;/code&gt; として返されます。</target>
        </trans-unit>
        <trans-unit id="fa76c289706bb600b3c9b3e3777d7935b3662cb5" translate="yes" xml:space="preserve">
          <source>When using the constants, if you don't want to have to remember to add the &lt;code&gt;, RESET&lt;/code&gt; at the end of each print line, you can set $Term::ANSIColor::AUTORESET to a true value. Then, the display mode will automatically be reset if there is no comma after the constant. In other words, with that variable set:</source>
          <target state="translated">定数を使用するときに、各印刷行の最後に &lt;code&gt;, RESET&lt;/code&gt; を追加することを忘れたくない場合は、 $ Term :: ANSIColor :: AUTORESETをtrue値に設定できます。その後、定数の後にコンマがない場合、表示モードは自動的にリセットされます。つまり、その変数を設定すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="a51c1c8c0eb3074d9df3759b3281e7508c8091a5" translate="yes" xml:space="preserve">
          <source>When using this compiler to build Perl, you should make sure that the flag -Aa is added to the cpprun and cppstdin variables in the config.sh file (though see the section on 64-bit perl below). If you are using a recent version of the Perl distribution, these flags are set automatically.</source>
          <target state="translated">このコンパイラを使用して Perl をビルドする場合、config.sh ファイルの cpprun と cppstdin 変数に -Aa フラグが追加されていることを確認する必要があります (ただし、下記の 64-bit perl のセクションを参照してください)。最近のバージョンの Perl ディストリビューションを使用している場合、これらのフラグは自動的に設定されます。</target>
        </trans-unit>
        <trans-unit id="a190d4d20525775f69d139675c3dc51cef5fb8f2" translate="yes" xml:space="preserve">
          <source>When using tools like &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; that can generate the &lt;code&gt;provides&lt;/code&gt; mapping for your distribution automatically, make sure you examine what it generates to make sure it makes sense - indexers will usually trust the &lt;code&gt;provides&lt;/code&gt; field if it's present, rather than scanning through the distribution files themselves to figure out packages and versions. This is a good thing, because it means you can use the &lt;code&gt;provides&lt;/code&gt; field to tell the indexers precisely what you want indexed about your distribution, rather than relying on them to essentially guess what you want indexed.</source>
          <target state="translated">ディストリビューションのprovidesマッピングを自動的に生成できる&lt;a href=&quot;Module::Build&quot;&gt;Module :: Build&lt;/a&gt;などのツールを使用する場合 &lt;code&gt;provides&lt;/code&gt; 、生成されるものを調べて、意味があることを確認してください。インデクサーは通常、ディストリビューションをスキャンするのではなく、providesフィールドが存在する場合はそれを信頼し &lt;code&gt;provides&lt;/code&gt; パッケージとバージョンを把握するためにファイル自体。それはあなたが使用できることを意味しますので、これは、良いことです &lt;code&gt;provides&lt;/code&gt; ではなく、本質的にあなたがインデックスさ欲しいものを推測するためにそれらに頼るよりも、あなたのディストリビューションについてのインデックス付けたいものを正確にインデクサを伝えるために、フィールドを。</target>
        </trans-unit>
        <trans-unit id="9d278a4b7e876e4a2527267176d89369b93fdace" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">既存のダイジェスト文字列を検証するときは、ダイジェストをソルトとして使用する必要があります（ &lt;code&gt;&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ）。ダイジェストの作成に使用されたSALTは、ダイジェストの一部として表示されます。これにより、crypt（）は新しい文字列をダイジェストと同じソルトでハッシュします。これにより、コードを標準の&lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt;とよりエキゾチックな実装で動作させることができます。つまり、返される文字列自体や、SALTの何バイトが問題になるかについては何も想定しないでください。</target>
        </trans-unit>
        <trans-unit id="1154d04d428d0c152c2ffba2d49aad6c93079515" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ). The SALT used to create the digest is visible as part of the digest. This ensures crypt() will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">既存のダイジェスト文字列を検証するときは、ダイジェストをソルトとして使用する必要があります（ &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;($plain, $digest) eq $digest&lt;/code&gt; ）。ダイジェストの作成に使用されたSALTは、ダイジェストの一部として表示されます。これにより、crypt（）は新しい文字列をダイジェストと同じソルトでハッシュします。これにより、コードを標準の&lt;a href=&quot;#crypt&quot;&gt;crypt&lt;/a&gt;とよりエキゾチックな実装で動作させることができます。つまり、返される文字列自体や、SALTの何バイトが問題になるかについては何も想定しないでください。</target>
        </trans-unit>
        <trans-unit id="213bdf210d4174fda29ca99ffa2edc52c2a2b3fb" translate="yes" xml:space="preserve">
          <source>When verifying an existing digest string you should use the digest as the salt (like &lt;code&gt;crypt($plain, $digest) eq $digest&lt;/code&gt;). The SALT used to create the digest is visible as part of the digest. This ensures &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; will hash the new string with the same salt as the digest. This allows your code to work with the standard &lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; and with more exotic implementations. In other words, assume nothing about the returned string itself nor about how many bytes of SALT may matter.</source>
          <target state="translated">既存のダイジェスト文字列を検証するときは、ダイジェストをソルトとして使用する必要があります（ &lt;code&gt;crypt($plain, $digest) eq $digest&lt;/code&gt; ）。ダイジェストの作成に使用されたSALTは、ダイジェストの一部として表示されます。これにより、&lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt; &lt;code&gt;crypt&lt;/code&gt; &lt;/a&gt;はダイジェストと同じソルトで新しい文字列をハッシュします。これにより、コードを標準の&lt;a href=&quot;#crypt-PLAINTEXT%2CSALT&quot;&gt; &lt;code&gt;crypt&lt;/code&gt; &lt;/a&gt;およびよりエキゾチックな実装で動作させることができます。言い換えると、返される文字列自体についても、SALTのバイト数についても何も想定していません。</target>
        </trans-unit>
        <trans-unit id="3ffe4a395b717a174f8af1eb199172f9bf8e1018" translate="yes" xml:space="preserve">
          <source>When we bless something, we are not blessing the variable which contains a reference to that thing, nor are we blessing the reference that the variable stores; we are blessing the thing that the variable refers to (sometimes known as the</source>
          <target state="translated">私たちが何かを祝福するとき、私たちはそのものへの参照を含む変数を祝福しているのではありませんし、変数が格納する参照を祝福しているのでもありません。</target>
        </trans-unit>
        <trans-unit id="7f1d89cf9a7bec3f0e241604b9f6d2928198590e" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; on a variable, we are actually blessing the underlying data structure that the variable refers to. We are not blessing the reference itself, nor the variable that contains that reference. That's why the second call to &lt;code&gt;blessed( $bar )&lt;/code&gt; returns false. At that point &lt;code&gt;$bar&lt;/code&gt; is no longer storing a reference to an object.</source>
          <target state="translated">変数に対して &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; を呼び出すと、実際には、変数が参照する基本的なデータ構造が祝福されます。参照自体も、その参照を含む変数も祝福していません。そのため、 &lt;code&gt;blessed( $bar )&lt;/code&gt; への2番目の呼び出しはfalseを返します。その時点で、 &lt;code&gt;$bar&lt;/code&gt; はオブジェクトへの参照を格納していません。</target>
        </trans-unit>
        <trans-unit id="6555170698fd78a17d09b080573745f1fb3e931d" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;bless&lt;/code&gt; on a variable, we are actually blessing the underlying data structure that the variable refers to. We are not blessing the reference itself, nor the variable that contains that reference. That's why the second call to &lt;code&gt;blessed( $bar )&lt;/code&gt; returns false. At that point &lt;code&gt;$bar&lt;/code&gt; is no longer storing a reference to an object.</source>
          <target state="translated">変数に対して &lt;code&gt;bless&lt;/code&gt; を呼び出すと、実際には、変数が参照する基になるデータ構造を祝福します。参照自体も、その参照を含む変数も祝福していません。これが、 &lt;code&gt;blessed( $bar )&lt;/code&gt; への2回目の呼び出しがfalseを返す理由です。その時点で、 &lt;code&gt;$bar&lt;/code&gt; はオブジェクトへの参照を格納しなくなります。</target>
        </trans-unit>
        <trans-unit id="c70879bf53ea832ca0790a74069f648240179f77" translate="yes" xml:space="preserve">
          <source>When we make a method call, Perl arranges for the method's &lt;b&gt;invocant&lt;/b&gt; to be passed as the first argument. &lt;b&gt;Invocant&lt;/b&gt; is a fancy name for the thing on the left side of the arrow. The invocant can either be a class name or an object. We can also pass additional arguments to the method:</source>
          <target state="translated">私たちは、メソッドの呼び出しを行う場合は、この方法のためのPerl並べ&lt;b&gt;インボカントは、&lt;/b&gt;最初の引数として渡されます。&lt;b&gt;Invocant&lt;/b&gt;は、矢印の左側にあるもののファンシーな名前です。呼び出し元は、クラス名またはオブジェクトのいずれかです。メソッドに追加の引数を渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="8e5660d78c1c3767afae15f24a83c561307c4b20" translate="yes" xml:space="preserve">
          <source>When we say &quot;Mac OS&quot; below, we mean Mac OS 7, 8, and 9, and</source>
          <target state="translated">以下、「Mac OS」というと、Mac OS 7、8、9のことであり</target>
        </trans-unit>
        <trans-unit id="32e492af43a84b7607b727f8ffe43ea47c5296c8" translate="yes" xml:space="preserve">
          <source>When we want to place values to be returned to the caller onto the stack, we use the series of macros that begin with &quot;XPUSH&quot;. There are five different versions, for placing integers, unsigned integers, doubles, strings, and Perl scalars on the stack. In our example, we placed a Perl scalar onto the stack. (In fact this is the only macro which can be used to return multiple values.)</source>
          <target state="translated">呼び出し元に返す値をスタックに配置したい場合は、&quot;XPUSH &quot;で始まる一連のマクロを使います。スタック上に整数、符号なし整数、倍数、文字列、Perl スカラを配置するための 5 つのバージョンがあります。この例では、Perlのスカラをスタックに配置しています。(実際には、これは複数の値を返すために使用できる唯一のマクロです)。</target>
        </trans-unit>
        <trans-unit id="5c32617504af087d7eaf74d60f9f81f18d15e5a1" translate="yes" xml:space="preserve">
          <source>When words that are longer than &lt;code&gt;$columns&lt;/code&gt; are encountered, they are broken up. &lt;code&gt;wrap()&lt;/code&gt; adds a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at column &lt;code&gt;$columns&lt;/code&gt; . This behavior can be overridden by setting &lt;code&gt;$huge&lt;/code&gt; to 'die' or to 'overflow'. When set to 'die', large words will cause &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; to be called. When set to 'overflow', large words will be left intact.</source>
          <target state="translated">&lt;code&gt;$columns&lt;/code&gt; より長い単語が検出されると、それらは分割されます。 &lt;code&gt;wrap()&lt;/code&gt; は、列 &lt;code&gt;$columns&lt;/code&gt; &lt;code&gt;&quot;\n&quot;&lt;/code&gt; を追加します。この動作は、 &lt;code&gt;$huge&lt;/code&gt; を「die」または「overflow」に設定することでオーバーライドできます。「die」に設定されている場合、大きな単語によって &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; が呼び出されます。「オーバーフロー」に設定すると、大きな単語はそのまま残ります。</target>
        </trans-unit>
        <trans-unit id="5ebaaddfa0e00536f0f1b77f056696aff48f065e" translate="yes" xml:space="preserve">
          <source>When words that are longer than &lt;code&gt;$columns&lt;/code&gt; are encountered, they are broken up. &lt;code&gt;wrap()&lt;/code&gt; adds a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at column &lt;code&gt;$columns&lt;/code&gt;. This behavior can be overridden by setting &lt;code&gt;$huge&lt;/code&gt; to 'die' or to 'overflow'. When set to 'die', large words will cause &lt;code&gt;die()&lt;/code&gt; to be called. When set to 'overflow', large words will be left intact.</source>
          <target state="translated">&lt;code&gt;$columns&lt;/code&gt; より長い単語が見つかると、それらは分割されます。 &lt;code&gt;wrap()&lt;/code&gt; は、列 &lt;code&gt;$columns&lt;/code&gt; &lt;code&gt;&quot;\n&quot;&lt;/code&gt; を追加します。この動作は、 &lt;code&gt;$huge&lt;/code&gt; を「die」または「overflow」に設定することでオーバーライドできます。'die'に設定すると、単語が大きいと &lt;code&gt;die()&lt;/code&gt; が呼び出されます。'overflow'に設定すると、大きな単語はそのまま残ります。</target>
        </trans-unit>
        <trans-unit id="52a8fd5862d63d0243193e3a0106e35c7816b525" translate="yes" xml:space="preserve">
          <source>When writing a DBM filter it is</source>
          <target state="translated">DBMフィルタを書くときは</target>
        </trans-unit>
        <trans-unit id="6e29ef5da6dd2ada1107f66b4d19daef44972a34" translate="yes" xml:space="preserve">
          <source>When writing a Perl extension for general consumption, one should expect that the extension will be used with versions of Perl different from the version available on your machine. Since you are reading this document, the version of Perl on your machine is probably 5.005 or later, but the users of your extension may have more ancient versions.</source>
          <target state="translated">一般消費のためにPerlの拡張機能を書く場合、その拡張機能はあなたのマシンで利用可能なバージョンとは異なるPerlのバージョンで使用されることを期待しなければなりません。あなたがこのドキュメントを読んでいるので、あなたのマシン上のPerlのバージョンはおそらく5.005以降ですが、あなたの拡張機能のユーザはもっと古いバージョンを持っているかもしれません。</target>
        </trans-unit>
        <trans-unit id="b339c5d874b742d033a9c15bc59a2eb32b3fde03" translate="yes" xml:space="preserve">
          <source>When writing a character UV to a UTF-8 string, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;uvchr_to_utf8&lt;/code&gt; , unless &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; in which case you can use &lt;code&gt;*s = uv&lt;/code&gt; .</source>
          <target state="translated">文字UVをUTF-8ストリングに書き込むときは、&lt;b&gt;常に&lt;/b&gt; &lt;code&gt;uvchr_to_utf8&lt;/code&gt; &lt;b&gt;を&lt;/b&gt;使用します。ただし、 &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; の場合は &lt;code&gt;*s = uv&lt;/code&gt; 使用できます。</target>
        </trans-unit>
        <trans-unit id="7ffec04c54d59e59616907c7e9e4db0144cb75f4" translate="yes" xml:space="preserve">
          <source>When writing a character UV to a UTF-8 string, &lt;b&gt;always&lt;/b&gt; use &lt;code&gt;uvchr_to_utf8&lt;/code&gt;, unless &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; in which case you can use &lt;code&gt;*s = uv&lt;/code&gt;.</source>
          <target state="translated">文字UVをUTF-8文字列に書き込むときは、&lt;b&gt;常に&lt;/b&gt; &lt;code&gt;uvchr_to_utf8&lt;/code&gt; &lt;b&gt;を&lt;/b&gt;使用します。ただし、 &lt;code&gt;UVCHR_IS_INVARIANT(uv))&lt;/code&gt; の場合は、 &lt;code&gt;*s = uv&lt;/code&gt; 使用できます。</target>
        </trans-unit>
        <trans-unit id="8f50a991a4544cc3b4a29ac32fb9e95a158b8cf9" translate="yes" xml:space="preserve">
          <source>When writing a gzip file this interface will</source>
          <target state="translated">gzip ファイルを書くとき、このインターフェイスは</target>
        </trans-unit>
        <trans-unit id="bb628954db56a328fb9c77ac1ab1c6c9e5566f04" translate="yes" xml:space="preserve">
          <source>When writing to a file or filehandle, set &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; before writing to the file.</source>
          <target state="translated">ファイルまたはファイルハンドルに書き込むときは、ファイルに書き込む前に &lt;code&gt;&lt;a href=&quot;../../functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; を設定します。</target>
        </trans-unit>
        <trans-unit id="b83d473ca051f901386a9b5075ab3cc8642b96d1" translate="yes" xml:space="preserve">
          <source>When you</source>
          <target state="translated">あなたが</target>
        </trans-unit>
        <trans-unit id="2677cbf7ed31e30ff85aaafd2211c14bcf4260ba" translate="yes" xml:space="preserve">
          <source>When you are content with suspects list, you can now</source>
          <target state="translated">あなたが容疑者のリストに満足している場合は、今すぐにすることができます。</target>
        </trans-unit>
        <trans-unit id="2f2f89e3cbdda44107d5b7350f0150202920760d" translate="yes" xml:space="preserve">
          <source>When you are done, the XS-module install process will have added information to your &quot;perllocal&quot; information telling that the perl binary has been replaced, and what module was installed. You can view this information at any time by using the command:</source>
          <target state="translated">XSモジュールのインストールが完了すると、XSモジュールのインストール処理では、perlバイナリが置き換えられたことと、どのモジュールがインストールされたかを示す情報が &quot;perllocal &quot;情報に追加されます。この情報はコマンドを使うことでいつでも見ることができます。</target>
        </trans-unit>
        <trans-unit id="b326342faabbb3f551d027918413fb764e7ae496" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself (if you feel masochistic enough) from the sources (available from e.g. &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="translated">GNU Cコンパイラ（gcc）を使用する予定で、まだgccを持っていない場合は、ソース（&lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http：//gcc.gnuなど&lt;/a&gt;から入手可能）から自分でビルドすることができます（マゾヒスティックであると感じる場合）。 .org / mirrors.html）または、HPポーティングセンター（&lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search）&lt;/a&gt;またはDSPP（必要なもの）からビルド済みのバイナリをフェッチします。メンバー）であることを&lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt;同じの多くの場合、複数のバージョンが存在するため、（リストを参照しパッケージが利用可能）。</target>
        </trans-unit>
        <trans-unit id="081b49cdc45047c15c231503ee57d721c9ac98ea" translate="yes" xml:space="preserve">
          <source>When you are going to use the GNU C compiler (gcc), and you don't have gcc yet, you can either build it yourself from the sources (available from e.g. &lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http://gcc.gnu.org/mirrors.html&lt;/a&gt;) or fetch a prebuilt binary from the HP porting center at &lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&lt;/a&gt; or from the DSPP (you need to be a member) at &lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&lt;/a&gt; (Browse through the list, because there are often multiple versions of the same package available).</source>
          <target state="translated">GNU Cコンパイラ（gcc）を使用する予定で、まだgccを持っていない場合は、ソースから自分でビルドすることもできます（例：&lt;a href=&quot;http://gcc.gnu.org/mirrors.html&quot;&gt;http&lt;/a&gt; : //gcc.gnu.org/mirrors.htmlから入手可能）または、&lt;a href=&quot;http://hpux.connect.org.uk/hppd/cgi-bin/search?term=gcc&amp;amp;Search=Search&quot;&gt;http：&lt;/a&gt; //hpux.connect.org.uk/hppd/cgi-bin/search？term = gcc＆Search = Search のHPポーティングセンターから、またはhttpのDSPP（メンバーである必要があります）からビルド済みのバイナリをフェッチし&lt;a href=&quot;http://h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801?ciid=2a08725cc2f02110725cc2f02110275d6e10RCRD&amp;amp;jumpid=reg_r1002_usen_c-001_title_r0001&quot;&gt;ます。 ：//h21007.www2.hp.com/portal/site/dspp/menuitem.863c3e4cbcdc3f3515b49c108973a801？ciid = 2a08725cc2f02110725cc2f02110275d6e10RCRD＆jumpid = reg_r1002_usen_c-001_title_r0001&lt;/a&gt;（複数のバージョンを使用できるため、パッケージを参照できます）。</target>
        </trans-unit>
        <trans-unit id="1e1fba30b9427287c1016e2b2ee037287889c225" translate="yes" xml:space="preserve">
          <source>When you are manually creating a UCM file, you should copy ascii.ucm or an existing encoding which is close to yours, rather than write your own from scratch.</source>
          <target state="translated">UCM ファイルを手動で作成する場合は、自分のものをゼロから書くのではなく、ascii.ucm や自分のものに近い既存のエンコーディングをコピーするべきです。</target>
        </trans-unit>
        <trans-unit id="4780d196081ec9146c3e56c719b52c3ce1654983" translate="yes" xml:space="preserve">
          <source>When you are satisfied with the results of tests, install the build C libraries for extensions:</source>
          <target state="translated">テストの結果に納得できたら、拡張機能用のビルドCライブラリをインストールします。</target>
        </trans-unit>
        <trans-unit id="a59f72a1e66eb8909341fcc7e63f4b0c726287dd" translate="yes" xml:space="preserve">
          <source>When you are sure that only a few subdirectories lead to failures, you may want to add &lt;code&gt;-j4&lt;/code&gt; option to &lt;code&gt;make&lt;/code&gt; to speed up skipping subdirectories with already finished build.</source>
          <target state="translated">いくつかのサブディレクトリだけが失敗につながると確信している場合は、 &lt;code&gt;-j4&lt;/code&gt; オプションを追加して、ビルドがすでに完了しているサブディレクトリのスキップを高速化する &lt;code&gt;make&lt;/code&gt; ができます。</target>
        </trans-unit>
        <trans-unit id="7b2f8e90d6f4d4294f6e2dcda859cd96193b4ae7" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;icmp&quot; protocol, this call permit to change the message type to 'echo' or 'timestamp' (only for IPv4, see RFC 792).</source>
          <target state="translated">icmp&quot; プロトコルを使用している場合、このコールはメッセージのタイプを 'echo' または 'timestamp' に変更することを許可します (IPv4 のみ、RFC 792 を参照してください)。</target>
        </trans-unit>
        <trans-unit id="c0610c400691e07d6b5c5967ea7cb5f197bdd7da" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;stream&quot; protocol, this call pre-opens the tcp socket. It's only necessary to do this if you want to provide a different timeout when creating the connection, or remove the overhead of establishing the connection from the first ping. If you don't call &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, the connection is automatically opened the first time &lt;code&gt;ping()&lt;/code&gt; is called. This call simply does nothing if you are using any protocol other than stream.</source>
          <target state="translated">「ストリーム」プロトコルを使用している場合、この呼び出しはtcpソケットを事前に開きます。接続の作成時に別のタイムアウトを指定する場合、または最初のpingから接続を確立するオーバーヘッドを削除する場合にのみ、これを行う必要があります。 &lt;code&gt;&lt;a href=&quot;../functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; を呼び出さない場合、最初に &lt;code&gt;ping()&lt;/code&gt; が呼び出されたときに接続が自動的に開かれます。ストリーム以外のプロトコルを使用している場合、この呼び出しは単に何もしません。</target>
        </trans-unit>
        <trans-unit id="53d7ace59a255ce0dee603a0e82c9350ed60c845" translate="yes" xml:space="preserve">
          <source>When you are using the &quot;stream&quot; protocol, this call pre-opens the tcp socket. It's only necessary to do this if you want to provide a different timeout when creating the connection, or remove the overhead of establishing the connection from the first ping. If you don't call &lt;code&gt;open()&lt;/code&gt;, the connection is automatically opened the first time &lt;code&gt;ping()&lt;/code&gt; is called. This call simply does nothing if you are using any protocol other than stream.</source>
          <target state="translated">「ストリーム」プロトコルを使用している場合、この呼び出しはtcpソケットを事前に開きます。これを行う必要があるのは、接続の作成時に別のタイムアウトを指定する場合、または最初のpingから接続を確立するオーバーヘッドを削除する場合のみです。 &lt;code&gt;open()&lt;/code&gt; を呼び出さない場合、 &lt;code&gt;ping()&lt;/code&gt; が最初に呼び出されたときに接続が自動的に開かれます。ストリーム以外のプロトコルを使用している場合、この呼び出しは何もしません。</target>
        </trans-unit>
        <trans-unit id="19030bdd1652e63fb5fe9a91af20f3234d06d23f" translate="yes" xml:space="preserve">
          <source>When you assign a list of scalars to an array, all previous values in that array are wiped out and the number of elements in the array will now be equal to the number of elements in the right-hand list -- the list from which assignment was made. The array will automatically resize itself to precisely accommodate each element in the right-hand list.</source>
          <target state="translated">スカラのリストを配列に代入すると,それまでの配列内のすべての値が消去され,配列内の要素数は,代入されたリストである右側のリストの要素数と等しくなります.配列は,右側のリストの各要素に正確に対応するように自動的にサイズが変更されます.</target>
        </trans-unit>
        <trans-unit id="a9fd269eddc721c08a06a789973e8783627db576" translate="yes" xml:space="preserve">
          <source>When you build modules, tell Perl where to install the modules.</source>
          <target state="translated">モジュールをビルドする際に、Perlにモジュールをインストールする場所を指定します。</target>
        </trans-unit>
        <trans-unit id="d2efe854f0b34964ee2879b9748bb899c2079d18" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;bar&lt;/code&gt; with arguments, you see that &lt;code&gt;foo&lt;/code&gt; got the same &lt;code&gt;@_&lt;/code&gt; :</source>
          <target state="translated">引数を指定して &lt;code&gt;bar&lt;/code&gt; を呼び出すと、 &lt;code&gt;foo&lt;/code&gt; が同じ &lt;code&gt;@_&lt;/code&gt; を取得したことがわかります。</target>
        </trans-unit>
        <trans-unit id="c91152667ee3ebf07dbc40066530c9ec19f3697d" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;bar&lt;/code&gt; with arguments, you see that &lt;code&gt;foo&lt;/code&gt; got the same &lt;code&gt;@_&lt;/code&gt;:</source>
          <target state="translated">引数を指定して &lt;code&gt;bar&lt;/code&gt; を呼び出すと、 &lt;code&gt;foo&lt;/code&gt; が同じ &lt;code&gt;@_&lt;/code&gt; を取得したことがわかります。</target>
        </trans-unit>
        <trans-unit id="835f87385a105654b52b3b81d31156a333d91b09" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;open&lt;/code&gt; this way, Perl invokes the given command directly, bypassing the shell. As such, the shell won't try to interpret any special characters within the command's argument list, which might overwise have unwanted effects. This can make for safer, less error-prone &lt;code&gt;open&lt;/code&gt; calls, useful in cases such as passing in variables as arguments, or even just referring to filenames with spaces in them.</source>
          <target state="translated">この方法で &lt;code&gt;open&lt;/code&gt; を呼び出すと、Perlはシェルをバイパスして、指定されたコマンドを直接呼び出します。そのため、シェルはコマンドの引数リスト内の特殊文字を解釈しようとはしません。これは、過度に望ましくない影響を与える可能性があります。これにより、より安全でエラーが発生しにくい &lt;code&gt;open&lt;/code&gt; コールが可能になり、変数を引数として渡す場合や、スペースを含むファイル名を参照する場合にも役立ちます。</target>
        </trans-unit>
        <trans-unit id="685020a1713f908c5ec69a7f573fc741004b77c1" translate="yes" xml:space="preserve">
          <source>When you call Perl's &lt;code&gt;open&lt;/code&gt; to set a Perl file handle [like &lt;code&gt;STDOUT&lt;/code&gt;], Perl calls C's &lt;code&gt;fopen&lt;/code&gt; to set a stdio &lt;code&gt;FILE *&lt;/code&gt;. C's &lt;code&gt;fopen&lt;/code&gt; calls something like Unix's &lt;code&gt;open&lt;/code&gt;, that is, Win32's &lt;code&gt;_sopen&lt;/code&gt;, to get an integer file descriptor [where 0 is for &lt;code&gt;STDIN&lt;/code&gt;, 1 for &lt;code&gt;STDOUT&lt;/code&gt;, etc.]. Win32's &lt;code&gt;_sopen&lt;/code&gt; calls &lt;code&gt;CreateFile&lt;/code&gt; to set a &lt;code&gt;HANDLE&lt;/code&gt;, a Win32 native file handle. So every Perl file handle [like &lt;code&gt;STDOUT&lt;/code&gt;] has an integer file descriptor associated with it that you can get via &lt;code&gt;fileno&lt;/code&gt;. And, under Win32, every file descriptor has a Win32 native file handle associated with it. &lt;code&gt;FdGetOsFHandle&lt;/code&gt; lets you get access to that.</source>
          <target state="translated">Perlの &lt;code&gt;open&lt;/code&gt; を呼び出して[ &lt;code&gt;STDOUT&lt;/code&gt; のような] Perlファイルハンドルを設定すると、PerlはCの &lt;code&gt;fopen&lt;/code&gt; を呼び出してstdio &lt;code&gt;FILE *&lt;/code&gt; を設定します。 Cの &lt;code&gt;fopen&lt;/code&gt; は、Unixの &lt;code&gt;open&lt;/code&gt; のようなもの、つまりWin32の &lt;code&gt;_sopen&lt;/code&gt; を呼び出して、整数のファイル記述子を取得します[0は &lt;code&gt;STDIN&lt;/code&gt; 、1は &lt;code&gt;STDOUT&lt;/code&gt; など]。 Win32の &lt;code&gt;_sopen&lt;/code&gt; は、 &lt;code&gt;CreateFile&lt;/code&gt; を呼び出して、Win32ネイティブファイルハンドルである &lt;code&gt;HANDLE&lt;/code&gt; を設定します。したがって、[ &lt;code&gt;STDOUT&lt;/code&gt; のような]すべてのPerlファイルハンドルには、 &lt;code&gt;fileno&lt;/code&gt; を介して取得できる整数のファイル記述子が関連付けられています。。また、Win32では、すべてのファイル記述子にWin32ネイティブファイルハンドルが関連付けられています。 &lt;code&gt;FdGetOsFHandle&lt;/code&gt; を使用すると、それにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="0e313737a6b3963a3bf8908006a0a820d6e4555f" translate="yes" xml:space="preserve">
          <source>When you call a fully qualified method name like &lt;code&gt;File::save&lt;/code&gt;, the method resolution search for the &lt;code&gt;save&lt;/code&gt; method starts in the &lt;code&gt;File&lt;/code&gt; class, skipping any &lt;code&gt;save&lt;/code&gt; method the &lt;code&gt;File::MP3&lt;/code&gt; class may have defined. It still searches the &lt;code&gt;File&lt;/code&gt; class's parents if necessary.</source>
          <target state="translated">あなたのような完全修飾メソッド名を呼び出すときに &lt;code&gt;File::save&lt;/code&gt; するための方法の解像度検索 &lt;code&gt;save&lt;/code&gt; 方法はで開始し &lt;code&gt;File&lt;/code&gt; いずれかをスキップし、クラス &lt;code&gt;save&lt;/code&gt; 方法 &lt;code&gt;File::MP3&lt;/code&gt; クラスが定義されている可能性があります。必要に応じて、 &lt;code&gt;File&lt;/code&gt; クラスの親を検索します。</target>
        </trans-unit>
        <trans-unit id="010f5217ea46f708fe21b0efa65632329708b27e" translate="yes" xml:space="preserve">
          <source>When you call a method, the thing on the left side of the arrow is passed as the first argument to the method. That means when we call &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; , the &lt;code&gt;new()&lt;/code&gt; method receives the string &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; as its first argument. When we call &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; , the &lt;code&gt;$fred&lt;/code&gt; variable is passed as the first argument to &lt;code&gt;speak()&lt;/code&gt; .</source>
          <target state="translated">メソッドを呼び出すと、矢印の左側にあるものが最初の引数としてメソッドに渡されます。つまり、 &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; を呼び出すと、 &lt;code&gt;new()&lt;/code&gt; メソッドは最初の引数として文字列 &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; を受け取ります。 &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; を呼び出すと、 &lt;code&gt;$fred&lt;/code&gt; 変数は、 &lt;code&gt;speak()&lt;/code&gt; の最初の引数として渡されます。</target>
        </trans-unit>
        <trans-unit id="fae81431a82ed2b7245ab26b577216b20acfee24" translate="yes" xml:space="preserve">
          <source>When you call a method, the thing on the left side of the arrow is passed as the first argument to the method. That means when we call &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt;, the &lt;code&gt;new()&lt;/code&gt; method receives the string &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; as its first argument. When we call &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt;, the &lt;code&gt;$fred&lt;/code&gt; variable is passed as the first argument to &lt;code&gt;speak()&lt;/code&gt;.</source>
          <target state="translated">メソッドを呼び出すと、矢印の左側にあるものがメソッドの最初の引数として渡されます。つまり、 &lt;code&gt;Critter-&amp;gt;new()&lt;/code&gt; を呼び出すと、 &lt;code&gt;new()&lt;/code&gt; メソッドは最初の引数として文字列 &lt;code&gt;&quot;Critter&quot;&lt;/code&gt; を受け取ります。 &lt;code&gt;$fred-&amp;gt;speak()&lt;/code&gt; を呼び出すと、 &lt;code&gt;$fred&lt;/code&gt; 変数が &lt;code&gt;speak()&lt;/code&gt; の最初の引数として渡されます。</target>
        </trans-unit>
        <trans-unit id="210c4bda966e8ba5f3d3dd89593f4b86c57dc0ef" translate="yes" xml:space="preserve">
          <source>When you call the &lt;code&gt;tie&lt;/code&gt; function to bind an associative array to this package, you may specify as an optional argument the symbol table in which you wish to create and delete symbols. If the argument is the string 'GLOBAL', then the global symbol table is used; any other string causes the local symbol table to be used. Note that this argument does not affect attempts to read symbols; if a symbol with the specified name exists in the local symbol table, it is always returned in preference to a symbol by the same name in the global symbol table.</source>
          <target state="translated">&lt;code&gt;tie&lt;/code&gt; 関数を呼び出して連想配列をこのパッケージにバインドする場合、オプションの引数として、シンボルを作成および削除するシンボルテーブルを指定できます。引数が文字列 'GLOBAL'の場合、グローバルシンボルテーブルが使用されます。その他の文字列を使用すると、ローカルシンボルテーブルが使用されます。この引数は、シンボルを読み取ろうとする試みには影響しないことに注意してください。指定された名前のシンボルがローカルシンボルテーブルに存在する場合、グローバルシンボルテーブル内の同じ名前のシンボルよりも常に優先して返されます。</target>
        </trans-unit>
        <trans-unit id="f9ac7d5348373bdb94113353aa9433d2aa26a56e" translate="yes" xml:space="preserve">
          <source>When you change a &lt;b&gt;value&lt;/b&gt; as it is being copied. [From French &amp;ldquo;in passing&amp;rdquo;, as in the exotic pawn-capturing maneuver in chess.]</source>
          <target state="translated">コピー中に&lt;b&gt;値&lt;/b&gt;を変更したとき。[チェスでのエキゾチックなポーン捕獲マニューバのように、「通過中」のフランス語から。]</target>
        </trans-unit>
        <trans-unit id="f19e6c82fbc2b2542cdae76f95f1a0c2e0deb19b" translate="yes" xml:space="preserve">
          <source>When you chop() a mathemagical object it is promoted to a string and its mathemagical properties are lost. The same can happen with other operations as well.</source>
          <target state="translated">数学的オブジェクトを chop()すると、それは文字列に昇格し、その数学的プロパティは失われます。他の操作でも同じことが起こります。</target>
        </trans-unit>
        <trans-unit id="ffb591449d98f90fa2f19a8fc5d8c220dd517b21" translate="yes" xml:space="preserve">
          <source>When you combine legacy data and Unicode, the legacy data needs to be upgraded to Unicode. Normally the legacy data is assumed to be ISO 8859-1 (or EBCDIC, if applicable).</source>
          <target state="translated">レガシーデータとユニコードを組み合わせる場合、レガシーデータをユニコードにアップグレードする必要があります。通常、レガシーデータは ISO 8859-1 (該当する場合は EBCDIC)を前提としています。</target>
        </trans-unit>
        <trans-unit id="177eeefc399a73cfd5bfb70b98c9df5de8601114" translate="yes" xml:space="preserve">
          <source>When you create a map, you SHOULD make your mappings round-trip safe. That is, &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq
$data&lt;/code&gt; stands for all characters that are marked as &lt;code&gt;|0&lt;/code&gt;. Here is how to make sure:</source>
          <target state="translated">マップを作成するときは、マッピングを安全に往復できるようにする必要があります。つまり、 &lt;code&gt;encode('your-encoding', decode('your-encoding', $data)) eq $data&lt;/code&gt; は、 &lt;code&gt;|0&lt;/code&gt; としてマークされているすべての文字を表します。確認方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="bb9cd7b8a4ff60818aa2eb01184f94103173f0c2" translate="yes" xml:space="preserve">
          <source>When you declare a constant such as &lt;code&gt;PI&lt;/code&gt; using the method shown above, each machine your script runs upon can have as many digits of accuracy as it can use. Also, your program will be easier to read, more likely to be maintained (and maintained correctly), and far less likely to send a space probe to the wrong planet because nobody noticed the one equation in which you wrote &lt;code&gt;3.14195&lt;/code&gt; .</source>
          <target state="translated">上記の方法を使用して &lt;code&gt;PI&lt;/code&gt; などの定数を宣言する場合、スクリプトを実行する各マシンは、使用できる最大桁数の精度を持つことができます。また、 &lt;code&gt;3.14195&lt;/code&gt; を記述した方程式に誰も気付いていないため、プログラムは読みやすく、維持される可能性が高く（正しく維持され）、間違った惑星に宇宙探査機を送信する可能性がはるかに低くなります。</target>
        </trans-unit>
        <trans-unit id="4e2b5a1dcab630574856b807ba52f00dea975f20" translate="yes" xml:space="preserve">
          <source>When you declare a constant such as &lt;code&gt;PI&lt;/code&gt; using the method shown above, each machine your script runs upon can have as many digits of accuracy as it can use. Also, your program will be easier to read, more likely to be maintained (and maintained correctly), and far less likely to send a space probe to the wrong planet because nobody noticed the one equation in which you wrote &lt;code&gt;3.14195&lt;/code&gt;.</source>
          <target state="translated">上記の方法を使用して &lt;code&gt;PI&lt;/code&gt; などの定数を宣言すると、スクリプトを実行する各マシンは、使用できる数桁の精度を持つことができます。また、あなたのプログラムは読みやすく、維持される（そして正しく維持される）可能性が高く、 &lt;code&gt;3.14195&lt;/code&gt; を書いた1つの方程式に誰も気づかなかったため、宇宙探査機を間違った惑星に送る可能性ははるかに低くなります。</target>
        </trans-unit>
        <trans-unit id="34ad5430f738cd6a6ba4f6afa7a8297067c10fdd" translate="yes" xml:space="preserve">
          <source>When you decode(=?</source>
          <target state="translated">デコード(=?</target>
        </trans-unit>
        <trans-unit id="1f9cd5bf8b9a9dc5c6c543459671e6a174da6ded" translate="yes" xml:space="preserve">
          <source>When you decode, &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; is inserted for a malformed character, where</source>
          <target state="translated">デコードすると、不正な文字に &lt;code&gt;\x&lt;i&gt;HH&lt;/i&gt;&lt;/code&gt; が挿入されます。</target>
        </trans-unit>
        <trans-unit id="3c3e41e00e97aaa41946f9404604a3e16daeabbf" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; object, you might get an object of this class.</source>
          <target state="translated">&lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;オブジェクトで$ parser-&amp;gt; get_tokenを実行すると、このクラスのオブジェクトを取得する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8903ce8817b2306a386e9e7bf122e6808d15508e" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you might get an object of this class.</source>
          <target state="translated">&lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;で$ parser-&amp;gt; get_tokenを実行すると、このクラスのオブジェクトを取得する可能性があります。</target>
        </trans-unit>
        <trans-unit id="c7b2a9b37643890f116ac0184e9ac142f63cbe26" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you should get an object of a subclass of Pod::Simple::PullParserToken.</source>
          <target state="translated">&lt;a href=&quot;Pod::Simple::PullParser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;で$ parser-&amp;gt; get_tokenを実行すると、Pod :: Simple :: PullParserTokenのサブクラスのオブジェクトを取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="8f3fe5c47178db8be10e4d3c50152806e0a7dfbf" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt; object, you might get an object of this class.</source>
          <target state="translated">&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;オブジェクトに対して$ parser-&amp;gt; get_tokenを実行すると、このクラスのオブジェクトが取得される場合があります。</target>
        </trans-unit>
        <trans-unit id="fdee2ab8e3f283c88595afe8fae4920b1af2e43f" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you might get an object of this class.</source>
          <target state="translated">&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;で$ parser-&amp;gt; get_tokenを実行すると、このクラスのオブジェクトが取得される場合があります。</target>
        </trans-unit>
        <trans-unit id="e49f09f58c9d01d7e0d1ab18e02275ef3d85f650" translate="yes" xml:space="preserve">
          <source>When you do $parser-&amp;gt;get_token on a &lt;a href=&quot;pullparser&quot;&gt;Pod::Simple::PullParser&lt;/a&gt;, you should get an object of a subclass of Pod::Simple::PullParserToken.</source>
          <target state="translated">&lt;a href=&quot;pullparser&quot;&gt;Pod :: Simple :: PullParser&lt;/a&gt;で$ parser-&amp;gt; get_tokenを実行すると、Pod :: Simple :: PullParserTokenのサブクラスのオブジェクトを取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="e5d10bb84f2ae2965aec52096372e0823e1ccc9f" translate="yes" xml:space="preserve">
          <source>When you do an open() and specify extra PerlIO layers to be deployed, the layers you specify are &quot;pushed&quot; on top of the already existing default stack. One way to see it is that &quot;operating system is on the left&quot; and &quot;Perl is on the right&quot;.</source>
          <target state="translated">open()を行い、デプロイする PerlIO の追加レイヤを指定すると、指定したレイヤは既に存在するデフォルトのスタックの上に「プッシュ」されます。これを見る方法の一つは、「オペレーティングシステムは左に、Perl は右に」ということです。</target>
        </trans-unit>
        <trans-unit id="deae100a89ba77dc88cb549c116cc2863e7500d7" translate="yes" xml:space="preserve">
          <source>When you do so, make sure you leave at least &lt;b&gt;U0000&lt;/b&gt; to &lt;b&gt;U0020&lt;/b&gt; as is, unless your environment is EBCDIC.</source>
          <target state="translated">その場合、環境がEBCDICでない限り、少なくとも&lt;b&gt;U0000&lt;/b&gt;から&lt;b&gt;U0020を&lt;/b&gt;そのままにしてください。</target>
        </trans-unit>
        <trans-unit id="5f9d98bf0fca35661c7810840d0018afb1d2ce55" translate="yes" xml:space="preserve">
          <source>When you do this, you replace ordinary Perl ops with custom ops by creating ops with the type &lt;code&gt;OP_CUSTOM&lt;/code&gt; and the &lt;code&gt;op_ppaddr&lt;/code&gt; of your own PP function. This should be defined in XS code, and should look like the PP ops in &lt;code&gt;pp_*.c&lt;/code&gt;. You are responsible for ensuring that your op takes the appropriate number of values from the stack, and you are responsible for adding stack marks if necessary.</source>
          <target state="translated">これを行うと、タイプ &lt;code&gt;OP_CUSTOM&lt;/code&gt; と独自のPP関数の &lt;code&gt;op_ppaddr&lt;/code&gt; を使用してopsを作成することにより、通常のPerl opsをカスタムopsに置き換えます。これはXSコードで定義する必要があり、 &lt;code&gt;pp_*.c&lt;/code&gt; PP opsのようになります。自分の操作がスタックから適切な数の値を取得するようにする責任があり、必要に応じてスタックマークを追加する責任があります。</target>
        </trans-unit>
        <trans-unit id="f0737e549db78c3f56b6cebadc591bd894132914" translate="yes" xml:space="preserve">
          <source>When you encode, it just encodes UTF-8 string with</source>
          <target state="translated">エンコードするときは、UTF-8の文字列を</target>
        </trans-unit>
        <trans-unit id="2cb93abd34cd25594e79f391f2b423cc436f1f2e" translate="yes" xml:space="preserve">
          <source>When you execute this script, Perl creates a source stream for the file. Before the parser processes any of the lines from the file, the source stream looks like this:</source>
          <target state="translated">このスクリプトを実行すると、Perl はファイルのソース・ストリームを作成します。パーサがファイルの行を処理する前に、ソース・ストリームは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="c978bab6e05df288a1696970dbd630fd132c029f" translate="yes" xml:space="preserve">
          <source>When you get tired of writing a custom print for your data structures, you might look at the standard &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; or &lt;a href=&quot;Data::Dumper&quot;&gt;Data::Dumper&lt;/a&gt; modules. The former is what the Perl debugger uses, while the latter generates parsable Perl code. For example:</source>
          <target state="translated">データ構造のカスタム印刷を書くのに飽きたら、標準の&lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt;または&lt;a href=&quot;Data::Dumper&quot;&gt;Data :: &lt;/a&gt;Dumperモジュールを見るかもしれません。前者はPerlデバッガーが使用するものであり、後者は解析可能なPerlコードを生成します。例えば：</target>
        </trans-unit>
        <trans-unit id="542d61dee2b7e163e5110ea366ba8573d821b115" translate="yes" xml:space="preserve">
          <source>When you get tired of writing a custom print for your data structures, you might look at the standard &lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt; or &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; modules. The former is what the Perl debugger uses, while the latter generates parsable Perl code. For example:</source>
          <target state="translated">データ構造のカスタムプリントの作成に飽きたら、標準の&lt;a href=&quot;dumpvalue&quot;&gt;Dumpvalue&lt;/a&gt;モジュールまたは&lt;a href=&quot;data/dumper&quot;&gt;Data :: &lt;/a&gt;Dumperモジュールを確認します。前者はPerlデバッガーが使用するもので、後者は解析可能なPerlコードを生成します。例えば：</target>
        </trans-unit>
        <trans-unit id="18b18f51c5b3a1ef29698b4db45e17c63b163a2a" translate="yes" xml:space="preserve">
          <source>When you have Module::Build installed and a module comes with both a Makefile.PL and a Build.PL, which shall have precedence?</source>
          <target state="translated">Module::Buildがインストールされていて、Makefile.PLとBuild.PLの両方がモジュールに付属している場合、どちらが優先されますか?</target>
        </trans-unit>
        <trans-unit id="90be52d2f2a07a95a09a611578f9d43f7cd9edea" translate="yes" xml:space="preserve">
          <source>When you have Term::ANSIColor installed, you can turn on colorized output to have some visual differences between normal CPAN.pm output, warnings, debugging output, and the output of the modules being installed. Set your favorite colors after some experimenting with the Term::ANSIColor module.</source>
          <target state="translated">Term::ANSIColorがインストールされている場合、通常のCPAN.pmの出力、警告、デバッグ出力、インストールされているモジュールの出力と視覚的な違いを持たせるために、色付きの出力を有効にすることができます。Term::ANSIColorモジュールを使って試してみて、好みの色を設定してみてください。</target>
        </trans-unit>
        <trans-unit id="805d35dab8fe4274cb0dab9ee72a05d301e431cf" translate="yes" xml:space="preserve">
          <source>When you have a &lt;code&gt;$normalized&lt;/code&gt; string and an &lt;code&gt;$unnormalized&lt;/code&gt; string following it, a simple concatenation is wrong:</source>
          <target state="translated">あなたが持っている場合は &lt;code&gt;$normalized&lt;/code&gt; た文字列と &lt;code&gt;$unnormalized&lt;/code&gt; 、それを次の文字列を、簡単な連結は間違っています：</target>
        </trans-unit>
        <trans-unit id="5fc33624ab4cb034a50a1d77e4381e870301d931" translate="yes" xml:space="preserve">
          <source>When you have a duplicate entry, mark either one with '|1' or '|3'.</source>
          <target state="translated">重複している場合は、'|1'または'|3'でマークしてください。</target>
        </trans-unit>
        <trans-unit id="c0776eaeac3f4218a7b8598aad81420ef0246911" translate="yes" xml:space="preserve">
          <source>When you list the arguments to the XSUB in the .xs file, that tells &lt;b&gt;xsubpp&lt;/b&gt; which argument corresponds to which of the argument stack (i.e., the first one listed is the first argument, and so on). You invite disaster if you do not list them in the same order as the function expects them.</source>
          <target state="translated">.xsファイルにXSUBへの引数をリストすると、それはどの引数がどの引数スタックに対応するかを&lt;b&gt;xsubpp&lt;/b&gt;に伝えます（つまり、リストされている最初の引数が最初の引数である、など）。関数が期待するのと同じ順序でそれらをリストしないと、災害を招きます。</target>
        </trans-unit>
        <trans-unit id="4fe7c5d2090255d1c2f0cf1a507f4b889f93bbfd" translate="yes" xml:space="preserve">
          <source>When you make a script executable, in order to make it usable as a command, the system will pass switches to perl from the script's #! line. Perl checks that any command line switches given to a setuid (or setgid) script actually match the ones set on the #! line. Some Unix and Unix-like environments impose a one-switch limit on the #! line, so you may need to use something like &lt;code&gt;-wU&lt;/code&gt; instead of &lt;code&gt;-w -U&lt;/code&gt; under such systems. (This issue should arise only in Unix or Unix-like environments that support #! and setuid or setgid scripts.)</source>
          <target state="translated">スクリプトを実行可能にすると、コマンドとして使用できるようにするために、システムはスクリプトの＃からスイッチをperlに渡します。ライン。 Perlは、setuid（またはsetgid）スクリプトに指定されたコマンドラインスイッチが実際に＃に設定されたものと一致することを確認します。ライン。一部のUnixおよびUnixのような環境では、＃に1スイッチの制限が課されます。そのようなシステムでは、 &lt;code&gt;-w -U&lt;/code&gt; の代わりに &lt;code&gt;-wU&lt;/code&gt; のようなものを使用する必要があるかもしれません。 （この問題は、＃！およびsetuidまたはsetgidスクリプトをサポートするUnixまたはUnixのような環境でのみ発生します。）</target>
        </trans-unit>
        <trans-unit id="66b392aea5e0dde426270cd749894810ea22ea80" translate="yes" xml:space="preserve">
          <source>When you obtain a context object it is made specifically for your tool and any tools nested within. If you pass a context around you run the risk of polluting other tools with incorrect context information.</source>
          <target state="translated">コンテキストオブジェクトを取得すると、それはあなたのツールとその中に入れ子になっているすべてのツールのために特別に作られます。コンテキストを渡してしまうと、間違ったコンテキスト情報で他のツールを汚染してしまう危険性があります。</target>
        </trans-unit>
        <trans-unit id="b95cff40ad5c3e10b014358530a3857e4311a17f" translate="yes" xml:space="preserve">
          <source>When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; function with an argument of &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (see &lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;).</source>
          <target state="translated">組み込みをオーバーライドする場合、置き換えは組み込みのネイティブ構文と（可能な場合）一貫している必要があります。これは、適切なプロトタイプを使用して実現できます。オーバーライド可能な組み込みのプロトタイプを取得するには、 &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; 引数を指定して &lt;code&gt;&lt;a href=&quot;functions/prototype&quot;&gt;prototype&lt;/a&gt;&lt;/code&gt; 関数を使用します（&lt;a href=&quot;functions/prototype&quot;&gt;プロトタイプを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="403deb8cf132584282b80991028fcc8f4fae8ae6" translate="yes" xml:space="preserve">
          <source>When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the &lt;code&gt;prototype&lt;/code&gt; function with an argument of &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; (see &lt;a href=&quot;perlfunc#prototype&quot;&gt;&quot;prototype&quot; in perlfunc&lt;/a&gt;).</source>
          <target state="translated">ビルトインをオーバーライドする場合、置換は（可能であれば）ビルトインのネイティブ構文と一致している必要があります。これは、適切なプロトタイプを使用することで実現できます。オーバーライド可能なビルトインのプロトタイプを取得するには、 &lt;code&gt;&quot;CORE::builtin_name&quot;&lt;/code&gt; 引数を指定して &lt;code&gt;prototype&lt;/code&gt; 関数を使用します（&lt;a href=&quot;perlfunc#prototype&quot;&gt;perlfuncの「prototype」を参照&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="cde2c695557d23e73e52834a17ed471dd59562aa" translate="yes" xml:space="preserve">
          <source>When you replace this variable, it is considered a good practice to store the possibly previously installed hook and that you recall it inside your own.</source>
          <target state="translated">この変数を置き換えるとき、それは可能性のある以前にインストールされたフックを格納し、あなた自身の中でそれをリコールすることは良い習慣と考えられています。</target>
        </trans-unit>
        <trans-unit id="582bd31e20cc087ebfe2ecd8d499eadfcfa005d7" translate="yes" xml:space="preserve">
          <source>When you run Makefile.PL, it makes a Makefile. That's the whole point of MakeMaker. The Makefile.PL is a simple program which loads ExtUtils::MakeMaker and runs the WriteMakefile() function to generate a Makefile.</source>
          <target state="translated">Makefile.PLを実行するとMakefileを作成します。これがMakeMakerの真骨頂です。Makefile.PLは、ExtUtils::MakeMakerをロードしてWriteMakefile()関数を実行してMakefileを生成するシンプルなプログラムです。</target>
        </trans-unit>
        <trans-unit id="b579e440e9d1d7b9d0889bfe36abfaf0be29b72d" translate="yes" xml:space="preserve">
          <source>When you run a Perl script, something else is running the script for you, and that something else may output error messages. The script might emit its own warnings and error messages. Most of the time you cannot tell who said what.</source>
          <target state="translated">Perl スクリプトを実行すると、他の何かがあなたのためにスクリプトを実行しており、その何かがエラーメッセージを出力することがあります。スクリプトは独自の警告やエラーメッセージを出力するかもしれません。ほとんどの場合、誰が何を言ったのかわからないことが多いです。</target>
        </trans-unit>
        <trans-unit id="b459c97000689bfb2a9636d9e9707ca71827210e" translate="yes" xml:space="preserve">
          <source>When you run this program, you should get something back that looks like this:</source>
          <target state="translated">このプログラムを実行すると、以下のようなものが返ってくるはずです。</target>
        </trans-unit>
        <trans-unit id="a4188abf09b28b37cfb9f20a3ac1868d9c6a543c" translate="yes" xml:space="preserve">
          <source>When you say &quot;make test&quot;, Perl uses the</source>
          <target state="translated">make test」と言うと、Perlは</target>
        </trans-unit>
        <trans-unit id="76a6e68fd11c4b70b5a87d525381faf69633be4b" translate="yes" xml:space="preserve">
          <source>When you say &lt;code&gt;make test&lt;/code&gt; it will run with taint mode on.</source>
          <target state="translated">&lt;code&gt;make test&lt;/code&gt; と言うと、汚染モードがオンの状態で実行されます。</target>
        </trans-unit>
        <trans-unit id="7919c60f354343e7a5369000b965c8d2d0632381" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=gb2312&lt;/code&gt; on mails and web pages, they really mean &lt;code&gt;euc-cn&lt;/code&gt; encodings. To fix that, &lt;code&gt;gb2312&lt;/code&gt; is aliased to &lt;code&gt;euc-cn&lt;/code&gt; . Use &lt;code&gt;gb2312-raw&lt;/code&gt; when you really mean it.</source>
          <target state="translated">メールやWebページに &lt;code&gt;charset=gb2312&lt;/code&gt; が表示される場合、それらは実際には &lt;code&gt;euc-cn&lt;/code&gt; エンコーディングを意味しています。これを修正するために、 &lt;code&gt;gb2312&lt;/code&gt; は &lt;code&gt;euc-cn&lt;/code&gt; にエイリアスされています。本当の意味で &lt;code&gt;gb2312-raw&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="8c4e1c3fce7decd6f02607f653534397608ae09a" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=gb2312&lt;/code&gt; on mails and web pages, they really mean &lt;code&gt;euc-cn&lt;/code&gt; encodings. To fix that, &lt;code&gt;gb2312&lt;/code&gt; is aliased to &lt;code&gt;euc-cn&lt;/code&gt;. Use &lt;code&gt;gb2312-raw&lt;/code&gt; when you really mean it.</source>
          <target state="translated">メールやWebページに &lt;code&gt;charset=gb2312&lt;/code&gt; が表示されている場合、それらは実際には &lt;code&gt;euc-cn&lt;/code&gt; エンコーディングを意味します。これを修正するために、 &lt;code&gt;gb2312&lt;/code&gt; は &lt;code&gt;euc-cn&lt;/code&gt; にエイリアスされます。本当に意味がある場合は、 &lt;code&gt;gb2312-raw&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="17139aebb0fce79faa8dece070270ecb6b39cc8b" translate="yes" xml:space="preserve">
          <source>When you see &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; on mails and web pages, they really mean &quot;cp949&quot; encodings. To fix that, the following aliases are set;</source>
          <target state="translated">メールおよびWebページに &lt;code&gt;charset=ks_c_5601-1987&lt;/code&gt; が表示される場合、それらは実際には「cp949」エンコーディングを意味します。これを修正するために、次のエイリアスが設定されています。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
