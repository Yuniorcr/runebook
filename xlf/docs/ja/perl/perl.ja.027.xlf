<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="8b9146b4f38600ca0e41fb96135f743cfdb11eec" translate="yes" xml:space="preserve">
          <source>BUG REPORTING</source>
          <target state="translated">バグ報告</target>
        </trans-unit>
        <trans-unit id="664f572fef857b1dfc7d6e286d22026a2508e1e5" translate="yes" xml:space="preserve">
          <source>BUG REPORTS</source>
          <target state="translated">バグレポート</target>
        </trans-unit>
        <trans-unit id="5dda8c520f4fbfda1830a8a497556d722a3fd113" translate="yes" xml:space="preserve">
          <source>BUGS</source>
          <target state="translated">BUGS</target>
        </trans-unit>
        <trans-unit id="9f989473548a594a947b969757db7fc06ca6a262" translate="yes" xml:space="preserve">
          <source>BUGS AND CAVEATS</source>
          <target state="translated">バグとケイバット</target>
        </trans-unit>
        <trans-unit id="fe771929835192040a55c6b146d4bbdcf0038546" translate="yes" xml:space="preserve">
          <source>BUGS AND IRRITATIONS</source>
          <target state="translated">欠陥と苛立ち</target>
        </trans-unit>
        <trans-unit id="affef23bcfe821a649489c10e4d45ae3607b1ccb" translate="yes" xml:space="preserve">
          <source>BUGS AND LIMITATIONS</source>
          <target state="translated">不具合と制限</target>
        </trans-unit>
        <trans-unit id="118a34d613c11c790c196c946968113aa8bc32aa" translate="yes" xml:space="preserve">
          <source>BUGS AND PITFALLS</source>
          <target state="translated">不具合と欠点</target>
        </trans-unit>
        <trans-unit id="a16fd7f9de623a809defab1d94048e0eded9677b" translate="yes" xml:space="preserve">
          <source>BUGS AND WARNINGS</source>
          <target state="translated">不具合と警告</target>
        </trans-unit>
        <trans-unit id="2f8e6e225c82badf6f8a92aed6ef242d4dc4d03b" translate="yes" xml:space="preserve">
          <source>BUGS ON CYGWIN</source>
          <target state="translated">CYGWINのバグ</target>
        </trans-unit>
        <trans-unit id="11f69a17d772a3f0d39aa116f097397dc1dac971" translate="yes" xml:space="preserve">
          <source>BUGS and CAVEATS</source>
          <target state="translated">BUGSとCAVEATS</target>
        </trans-unit>
        <trans-unit id="6c450a35b54bd0a62e732cbab24c3d7221d9a194" translate="yes" xml:space="preserve">
          <source>BUGS is an email or url to post bug reports. For modules with UPSTREAM =&amp;gt; 'blead', use &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;mailto:perl5-porters@perl.org&lt;/a&gt;. rt.cpan.org appears to automatically provide a URL for CPAN modules; any value given here overrides the default: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=%24ModuleName&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=$ModuleName&lt;/a&gt;</source>
          <target state="translated">バグは、バグレポートを投稿するための電子メールまたはURLです。UPSTREAM =&amp;gt; 'blead'のモジュールの場合は、&lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;mailto：perl5-porters@perl.orgを&lt;/a&gt;使用します。rt.cpan.orgは、CPANモジュールのURLを自動的に提供しているようです。ここで指定された値はデフォルトを上書きします：&lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=%24ModuleName&quot;&gt;http&lt;/a&gt;：//rt.cpan.org/Public/Dist/Display.html？Name = $ ModuleName</target>
        </trans-unit>
        <trans-unit id="ccf8d27dca59cf8914b7de42279bcf54b381c80d" translate="yes" xml:space="preserve">
          <source>BUGS is an email or url to post bug reports. For modules with UPSTREAM =&amp;gt; 'blead', use perl5-porters@perl.org. rt.cpan.org appears to automatically provide a URL for CPAN modules; any value given here overrides the default: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=&lt;/a&gt;$ModuleName</source>
          <target state="translated">バグは、バグレポートを投稿するための電子メールまたはURLです。UPSTREAM =&amp;gt; 'blead'のモジュールの場合、perl5-porters @ perl.orgを使用します。rt.cpan.orgは、CPANモジュールのURLを自動的に提供するようです。ここで指定した値はデフォルトを上書きします：&lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=&quot;&gt;http&lt;/a&gt; : //rt.cpan.org/Public/Dist/Display.html?Name= $ ModuleName</target>
        </trans-unit>
        <trans-unit id="4fa4a173033ffa9b27f16cd2d7b309c255617591" translate="yes" xml:space="preserve">
          <source>BUGS/CAVEATS/etc</source>
          <target state="translated">BUGS/CAVEATS/etc</target>
        </trans-unit>
        <trans-unit id="9b8dfdff736c5b1dbf956b89d8a9d4fd925dacd2" translate="yes" xml:space="preserve">
          <source>BUILD</source>
          <target state="translated">BUILD</target>
        </trans-unit>
        <trans-unit id="0e162e98df920882beaaa37c9fd3fd9860be2bff" translate="yes" xml:space="preserve">
          <source>BUILD AND INSTALL</source>
          <target state="translated">ビルドとインストール</target>
        </trans-unit>
        <trans-unit id="80ef3501d89bb441f42a9aac769a351966bde435" translate="yes" xml:space="preserve">
          <source>BUILD NEW EXTENSIONS</source>
          <target state="translated">新しい拡張機能を構築する</target>
        </trans-unit>
        <trans-unit id="915ac3e12b39990a3ff0eb519c7c070afd799641" translate="yes" xml:space="preserve">
          <source>BUILDING</source>
          <target state="translated">BUILDING</target>
        </trans-unit>
        <trans-unit id="a5d9fc029fc161e583884fa605ea5dd4bf5b0226" translate="yes" xml:space="preserve">
          <source>BUILDING AND INSTALLING MODULES ON DOS</source>
          <target state="translated">DOS でのモジュールの構築とインストール</target>
        </trans-unit>
        <trans-unit id="68c9d11aacf08e68cf9222616220471f55a4230e" translate="yes" xml:space="preserve">
          <source>BUILDING PERL FOR OPENVOS</source>
          <target state="translated">OPENVOSのためのPERLの構築</target>
        </trans-unit>
        <trans-unit id="b603dd0f789cea0b71cf17b9cadf6a885369ee6d" translate="yes" xml:space="preserve">
          <source>BUILDING PERL ON AMIGAOS</source>
          <target state="translated">アミガオスにペルを建てる</target>
        </trans-unit>
        <trans-unit id="d40a175e7a653e9eaa67c4da87c76fc937184284" translate="yes" xml:space="preserve">
          <source>BUILD_REQUIRES</source>
          <target state="translated">BUILD_REQUIRES</target>
        </trans-unit>
        <trans-unit id="d5bdc31108d4219c97e8c1b7e29e0629da746aa9" translate="yes" xml:space="preserve">
          <source>BUNDLES</source>
          <target state="translated">BUNDLES</target>
        </trans-unit>
        <trans-unit id="92b48cc3d13ac12b362038111cf08e5cf8b03696" translate="yes" xml:space="preserve">
          <source>Back before Perl had the XS system for connecting with C libraries, programmers used to get library constants by reading through the C header files. You may still see &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'syscall.ph'&lt;/code&gt; or similar around - the</source>
          <target state="translated">PerlがCライブラリに接続するためのXSシステムを持っていた以前は、プログラマーはCヘッダーファイルを読み取ってライブラリ定数を取得していました。まだ &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'syscall.ph'&lt;/code&gt; または同様のものが&lt;a href=&quot;functions/require&quot;&gt;必要と&lt;/a&gt;表示される場合があります -</target>
        </trans-unit>
        <trans-unit id="a14d8f418667d750d655e37f8fb2aa536926510a" translate="yes" xml:space="preserve">
          <source>Back before Perl had the XS system for connecting with C libraries, programmers used to get library constants by reading through the C header files. You may still see &lt;code&gt;require 'syscall.ph'&lt;/code&gt; or similar around - the</source>
          <target state="translated">PerlがCライブラリに接続するためのXSシステムを使用する前は、プログラマーはCヘッダーファイルを読み取ることによってライブラリ定数を取得していました。あなたはまだ &lt;code&gt;require 'syscall.ph'&lt;/code&gt; または同様のものを見るかもしれません-</target>
        </trans-unit>
        <trans-unit id="4a3e95e64a0aa298ba1dcd060974643f7be2839b" translate="yes" xml:space="preserve">
          <source>Back then, the range 0xD800-0xDFFF was not allocated. Let's split that range in half and use the first half to represent the &lt;code&gt;upper
half of a character&lt;/code&gt; and the second half to represent the &lt;code&gt;lower
half of a character&lt;/code&gt; . That way, you can represent 1024 * 1024 = 1048576 more characters. Now we can store character ranges up to \x{10ffff} even with 16-bit encodings. This pair of half-character is now called a</source>
          <target state="translated">当時、範囲0xD800-0xDFFFは割り当てられていませんでした。その範囲を半分に分割し、前半を使用し &lt;code&gt;upper half of a character&lt;/code&gt; を表し、後半を使用して文字の &lt;code&gt;lower half of a character&lt;/code&gt; を表します。これにより、1024 * 1024 = 1048576個の文字を表すことができます。これで、16ビットエンコーディングでも\ x {10ffff}までの文字範囲を保存できます。この半文字のペアは、現在、</target>
        </trans-unit>
        <trans-unit id="8b862d333105bea92e016a8abca6974a21d6cf0e" translate="yes" xml:space="preserve">
          <source>Back then, the range 0xD800-0xDFFF was not allocated. Let's split that range in half and use the first half to represent the &lt;code&gt;upper half of a character&lt;/code&gt; and the second half to represent the &lt;code&gt;lower half of a character&lt;/code&gt;. That way, you can represent 1024 * 1024 = 1048576 more characters. Now we can store character ranges up to \x{10ffff} even with 16-bit encodings. This pair of half-character is now called a</source>
          <target state="translated">当時、範囲0xD800-0xDFFFは割り当てられていませんでした。その範囲を半分に分割し、前半を使用し &lt;code&gt;upper half of a character&lt;/code&gt; を表し、後半を使用して文字の &lt;code&gt;lower half of a character&lt;/code&gt; を表します。このようにして、1024 * 1024 = 1048576以上の文字を表すことができます。これで、16ビットエンコーディングでも最大\ x {10ffff}の文字範囲を格納できます。このハーフキャラクターのペアは現在、</target>
        </trans-unit>
        <trans-unit id="bbe6515e366531ac45779e3d5c9b5a456560e812" translate="yes" xml:space="preserve">
          <source>Back to</source>
          <target state="translated">戻る</target>
        </trans-unit>
        <trans-unit id="1f9a2a8bbfa8f04b97f0739e8cee87c19e9a7b1a" translate="yes" xml:space="preserve">
          <source>Back to converting data. If you have (or want) data in your system's native 8-bit encoding (e.g. Latin-1, EBCDIC, etc.), you can use pack/unpack to convert to/from Unicode.</source>
          <target state="translated">データの変換に戻ります。システムのネイティブの 8 ビットエンコーディング (Latin-1 や EBCDIC など)のデータを持っている (または持っていたい)場合、pack/unpack を使って Unicode に変換することができます。</target>
        </trans-unit>
        <trans-unit id="917eb438525299e66d70b4deb11770f40a27eeaa" translate="yes" xml:space="preserve">
          <source>Backend for building test libraries</source>
          <target state="translated">テストライブラリを構築するためのバックエンド</target>
        </trans-unit>
        <trans-unit id="60865a55d575470308929e5970d44edcbdb31366" translate="yes" xml:space="preserve">
          <source>Background Processes</source>
          <target state="translated">バックグラウンドプロセス</target>
        </trans-unit>
        <trans-unit id="777d367a0813af1945dd6a57f416558fa99c5a72" translate="yes" xml:space="preserve">
          <source>Background and PERL_IMPLICIT_CONTEXT</source>
          <target state="translated">背景とPERL_IMPLICIT_CONTEXT</target>
        </trans-unit>
        <trans-unit id="82139f465e7bfd51be69bcd2ba2252de65152f38" translate="yes" xml:space="preserve">
          <source>Background yourself like this:</source>
          <target state="translated">このように自分を背景にして</target>
        </trans-unit>
        <trans-unit id="fec43a1301d416fe4b43d921e7178671d812a1b8" translate="yes" xml:space="preserve">
          <source>Background: &lt;code&gt;atoi&lt;/code&gt; has severe problems with illegal inputs, it cannot be used for incremental parsing, and therefore should be avoided &lt;code&gt;atoi&lt;/code&gt; and &lt;code&gt;strtol&lt;/code&gt; are also affected by locale settings, which can also be seen as a bug (global state controlled by user environment).</source>
          <target state="translated">背景： &lt;code&gt;atoi&lt;/code&gt; には不正な入力に関する深刻な問題があり、増分解析には使用できないため、回避する必要があります &lt;code&gt;atoi&lt;/code&gt; と &lt;code&gt;strtol&lt;/code&gt; はロケール設定の影響も受けますが、これはバグ（ユーザー環境によって制御されるグローバル状態）と見なされることもあります。</target>
        </trans-unit>
        <trans-unit id="eced385684cc6954de21105c9b174aaf3bba4295" translate="yes" xml:space="preserve">
          <source>Backported version unknown</source>
          <target state="translated">バックポートされたバージョンは不明</target>
        </trans-unit>
        <trans-unit id="422ea69f009b9513c410e1c50a5058f352b88507" translate="yes" xml:space="preserve">
          <source>Backreference to a named capture group. Equivalent to &lt;code&gt;\g{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;.</source>
          <target state="translated">名前付きキャプチャグループへの後方参照。 &lt;code&gt;\g{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; 同等です。</target>
        </trans-unit>
        <trans-unit id="1c7bd776caf410341796f267d0b5a33a3e4a0364" translate="yes" xml:space="preserve">
          <source>Backreference to a named capture group. Equivalent to &lt;code&gt;\g{NAME}&lt;/code&gt; .</source>
          <target state="translated">名前付きキャプチャグループへの後方参照。 &lt;code&gt;\g{NAME}&lt;/code&gt; 同等です。</target>
        </trans-unit>
        <trans-unit id="1b67830d6a194880657acd61864c65e3027fb02e" translate="yes" xml:space="preserve">
          <source>Backreferences</source>
          <target state="translated">Backreferences</target>
        </trans-unit>
        <trans-unit id="89d9017aad56d057f4819297fea6ec35a3d1c796" translate="yes" xml:space="preserve">
          <source>Backreferences in substitutions use &quot;$&quot; rather than &quot;\&quot;.</source>
          <target state="translated">置換の際の後方参照には、&quot;\&quot;ではなく&quot;$&quot;を使用します。</target>
        </trans-unit>
        <trans-unit id="f6f78ea4ce7c5612a0f7211383bd0176dfc079e5" translate="yes" xml:space="preserve">
          <source>Backslash Operator</source>
          <target state="translated">バックスラッシュ演算子</target>
        </trans-unit>
        <trans-unit id="c5cf510bfb36856574ecae34fa00822be8b9c589" translate="yes" xml:space="preserve">
          <source>Backslash Sequences</source>
          <target state="translated">バックスラッシュシーケンス</target>
        </trans-unit>
        <trans-unit id="db35629fab3798cdd79f1bf42fa413127bebc425" translate="yes" xml:space="preserve">
          <source>Backslash is used, as usual, to escape the next character.</source>
          <target state="translated">バックスラッシュは通常通り、次の文字をエスケープするために使用されます。</target>
        </trans-unit>
        <trans-unit id="046c786ef212957156a16429eb6f369b2064b79d" translate="yes" xml:space="preserve">
          <source>Backslash sequence character classes cannot form one of the endpoints of a range. Thus, you can't say:</source>
          <target state="translated">バックスラッシュシーケンス文字クラスは、範囲の終点の一つを形成することはできません。したがって、言うことはできません。</target>
        </trans-unit>
        <trans-unit id="9900e3acb0e0a2eba6b592f80668e5cc6828f6c1" translate="yes" xml:space="preserve">
          <source>Backslash sequences</source>
          <target state="translated">バックスラッシュシーケンス</target>
        </trans-unit>
        <trans-unit id="c61c0b16c1836e4070c1986f40a121b830a65cf5" translate="yes" xml:space="preserve">
          <source>Backslashed characters are either replaced with corresponding literal strings (as with &lt;code&gt;\{&lt;/code&gt;), or else they generate special nodes in the finite automaton (as with &lt;code&gt;\b&lt;/code&gt; ). Characters special to the RE engine (such as &lt;code&gt;|&lt;/code&gt;) generate corresponding nodes or groups of nodes. &lt;code&gt;(?#...)&lt;/code&gt; comments are ignored. All the rest is either converted to literal strings to match, or else is ignored (as is whitespace and &lt;code&gt;#&lt;/code&gt; -style comments if &lt;code&gt;/x&lt;/code&gt; is present).</source>
          <target state="translated">バックスラッシュ文字は、対応するリテラル文字列（ &lt;code&gt;\{&lt;/code&gt; ）に置き換えられるか、有限オートマトン（ &lt;code&gt;\b&lt;/code&gt; ）で特殊なノードを生成します。 REエンジンに特有の文字（ &lt;code&gt;|&lt;/code&gt; など）は、対応するノードまたはノードのグループを生成します。 &lt;code&gt;(?#...)&lt;/code&gt; コメントは無視されます。残りはすべて、一致するようにリテラル文字列に変換されるか、無視されます（ &lt;code&gt;/x&lt;/code&gt; が存在する場合の空白や &lt;code&gt;#&lt;/code&gt; スタイルのコメントと同様）。</target>
        </trans-unit>
        <trans-unit id="5aeb8eb150f9b708f4b9ee0e63969a864d6fc87f" translate="yes" xml:space="preserve">
          <source>Backslashed characters are either replaced with corresponding literal strings (as with &lt;code&gt;\{&lt;/code&gt;), or else they generate special nodes in the finite automaton (as with &lt;code&gt;\b&lt;/code&gt;). Characters special to the RE engine (such as &lt;code&gt;|&lt;/code&gt;) generate corresponding nodes or groups of nodes. &lt;code&gt;(?#...)&lt;/code&gt; comments are ignored. All the rest is either converted to literal strings to match, or else is ignored (as is whitespace and &lt;code&gt;#&lt;/code&gt;-style comments if &lt;code&gt;/x&lt;/code&gt; is present).</source>
          <target state="translated">バックスラッシュ文字は、対応するリテラル文字列に置き換えられるか（ &lt;code&gt;\{&lt;/code&gt; ）、または有限オートマトンに特別なノードを生成します（ &lt;code&gt;\b&lt;/code&gt; ）。REエンジンに固有の文字（ &lt;code&gt;|&lt;/code&gt; など）は、対応するノードまたはノードのグループを生成します。 &lt;code&gt;(?#...)&lt;/code&gt; コメントは無視されます。残りはすべて、一致するようにリテラル文字列に変換されるか、無視されます（ &lt;code&gt;/x&lt;/code&gt; が存在する場合は空白および &lt;code&gt;#&lt;/code&gt; スタイルのコメントも同様です）。</target>
        </trans-unit>
        <trans-unit id="396b0c95d21c97a92647624c67163f81645740c9" translate="yes" xml:space="preserve">
          <source>Backslashed metacharacters in Perl are alphanumeric, such as &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; . Unlike some other regular expression languages, there are no backslashed symbols that aren't alphanumeric. So anything that looks like \\, \(, \), \[, \], \{, or \} is always interpreted as a literal character, not a metacharacter. This was once used in a common idiom to disable or quote the special meanings of regular expression metacharacters in a string that you want to use for a pattern. Simply quote all non-&quot;word&quot; characters:</source>
          <target state="translated">Perlのバックスラッシュ付きメタ文字は、 &lt;code&gt;\b&lt;/code&gt; 、 &lt;code&gt;\w&lt;/code&gt; 、 &lt;code&gt;\n&lt;/code&gt; などの英数字です。他の一部の正規表現言語とは異なり、英数字以外のバックスラッシュ記号はありません。したがって、\\、\（、\）、\ [、\]、\ {、\}のようなものは、常にメタ文字ではなくリテラル文字として解釈されます。これはかつて、パターンに使用したい文字列内の正規表現のメタ文字の特別な意味を無効にするか引用するために一般的なイディオムで使用されていました。「単語」以外のすべての文字を単に引用します。</target>
        </trans-unit>
        <trans-unit id="a9e4564a4cffc22857c4489a19486bf89ae25eff" translate="yes" xml:space="preserve">
          <source>Backslashed metacharacters in Perl are alphanumeric, such as &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;. Unlike some other regular expression languages, there are no backslashed symbols that aren't alphanumeric. So anything that looks like &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;\(&lt;/code&gt;, &lt;code&gt;\)&lt;/code&gt;, &lt;code&gt;\[&lt;/code&gt;, &lt;code&gt;\]&lt;/code&gt;, &lt;code&gt;\{&lt;/code&gt;, or &lt;code&gt;\}&lt;/code&gt; is always interpreted as a literal character, not a metacharacter. This was once used in a common idiom to disable or quote the special meanings of regular expression metacharacters in a string that you want to use for a pattern. Simply quote all non-&quot;word&quot; characters:</source>
          <target state="translated">Perlのバックスラッシュされたメタ文字は、 &lt;code&gt;\b&lt;/code&gt; 、 &lt;code&gt;\w&lt;/code&gt; 、 &lt;code&gt;\n&lt;/code&gt; などの英数字です。他の正規表現言語とは異なり、英数字以外のバックスラッシュ記号はありません。したがって、 &lt;code&gt;\\&lt;/code&gt; 、 &lt;code&gt;\(&lt;/code&gt; 、 &lt;code&gt;\)&lt;/code&gt; 、 &lt;code&gt;\[&lt;/code&gt; 、 &lt;code&gt;\]&lt;/code&gt; 、 &lt;code&gt;\{&lt;/code&gt; 、または &lt;code&gt;\}&lt;/code&gt; のように見えるものはすべて、メタ文字ではなく、常にリテラル文字として解釈されます。これはかつて、パターンに使用する文字列内の正規表現メタ文字の特別な意味を無効化または引用するために、一般的なイディオムで使用されていました。 「単語」以外のすべての文字を引用するだけです。</target>
        </trans-unit>
        <trans-unit id="5ad3bd6856b2f78166ba432a9cdf4da8413a4090" translate="yes" xml:space="preserve">
          <source>Backslashes parentheses &lt;code&gt;()&lt;/code&gt; in command line arguments. Doesn't handle recursive Makefile &lt;code&gt;$(...)&lt;/code&gt; constructs, but handles simple ones.</source>
          <target state="translated">コマンドライン引数のバックスラッシュ括弧 &lt;code&gt;()&lt;/code&gt; 。再帰的なMakefile &lt;code&gt;$(...)&lt;/code&gt; 構成を処理しませんが、単純な構成を処理します。</target>
        </trans-unit>
        <trans-unit id="a44d458ea8adc4ce2457e80d59480bf2444b0e2c" translate="yes" xml:space="preserve">
          <source>Backticks</source>
          <target state="translated">Backticks</target>
        </trans-unit>
        <trans-unit id="cada2d153702b188c804c9ed93a320132370a768" translate="yes" xml:space="preserve">
          <source>Backticks &lt;code&gt;``&lt;/code&gt; (see &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt;) with the command which contains redirection or shell meta-characters;</source>
          <target state="translated">リダイレクトまたは&lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;シェルメタ&lt;/a&gt;文字を含むコマンドを使用したバックティック &lt;code&gt;``&lt;/code&gt; （perlopの「I / O演算子」を参照）。</target>
        </trans-unit>
        <trans-unit id="8ef1c0d1318e1460dedacce3731d309fc7ffbb8a" translate="yes" xml:space="preserve">
          <source>Backticks &lt;code&gt;``&lt;/code&gt; (see &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;) with the command which contains redirection or shell meta-characters;</source>
          <target state="translated">バッククォート &lt;code&gt;``&lt;/code&gt; （参照&lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;はperlopにI / O演算子を&lt;/a&gt;リダイレクトまたはシェルのメタ文字が含まれているコマンドを使用）。</target>
        </trans-unit>
        <trans-unit id="6e2b605f65ba36a3d929c62881915b96a794f8f1" translate="yes" xml:space="preserve">
          <source>Backticks create a subprocess, and pass the enclosed string to it for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt; , any valid DCL command string may be specified.</source>
          <target state="translated">バッククォートはサブプロセスを作成し、囲まれた文字列をサブプロセスに渡して、DCLコマンドとして実行します。サブプロセスは &lt;code&gt;lib$spawn()&lt;/code&gt; を介して直接作成されるため、有効なDCLコマンド文字列を指定できます。</target>
        </trans-unit>
        <trans-unit id="93a46463866e4337a557918eb7f92cb737fcdb4d" translate="yes" xml:space="preserve">
          <source>Backticks create a subprocess, and pass the enclosed string to it for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt;, any valid DCL command string may be specified.</source>
          <target state="translated">バックティックはサブプロセスを作成し、DCLコマンドとして実行するために囲まれた文字列をサブプロセスに渡します。サブプロセスは &lt;code&gt;lib$spawn()&lt;/code&gt; を介して直接作成されるため、任意の有効なDCLコマンド文字列を指定できます。</target>
        </trans-unit>
        <trans-unit id="34532d18ad2d0f70e2d7b957fabc96ee06bc62fe" translate="yes" xml:space="preserve">
          <source>Backtracking</source>
          <target state="translated">Backtracking</target>
        </trans-unit>
        <trans-unit id="6e522c194b60635ece31d387544d1195051e629c" translate="yes" xml:space="preserve">
          <source>Backtracking control verbs</source>
          <target state="translated">バックトラッキング制御動詞</target>
        </trans-unit>
        <trans-unit id="14496432005368ea983df3ea81b1252443b8ee8b" translate="yes" xml:space="preserve">
          <source>Backtracking during the relentless search for a match may be a waste of time, particularly when the match is bound to fail. Consider the simple pattern</source>
          <target state="translated">一致するものを執拗に探している間にバックトラッキングするのは時間の無駄かもしれませんが、特に一致したものが失敗することが予想される場合には、時間の無駄かもしれません。単純なパターンを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="0bce7971052281b2bb5edb4f3a21f79dd6904b31" translate="yes" xml:space="preserve">
          <source>Backtracking is more efficient than repeated tries with different regular expressions. If there are several regular expressions and a match with any of them is acceptable, then it is possible to combine them into a set of alternatives. If the individual expressions are input data, this can be done by programming a join operation. We'll exploit this idea in an improved version of the &lt;code&gt;simple_grep&lt;/code&gt; program: a program that matches multiple patterns:</source>
          <target state="translated">バックトラッキングは、異なる正規表現で繰り返し試行するよりも効率的です。いくつかの正規表現があり、それらのいずれかとの一致が許容できる場合は、それらを組み合わせて代替のセットにすることができます。個々の式が入力データである場合、これは結合操作をプログラミングすることで実行できます。 &lt;code&gt;simple_grep&lt;/code&gt; プログラムの改良版でこのアイデアを利用します：複数のパターンに一致するプログラム：</target>
        </trans-unit>
        <trans-unit id="fd4a1f65749d89056abcaeac3722a7b7a8fe75a1" translate="yes" xml:space="preserve">
          <source>Backward Compatibility</source>
          <target state="translated">下位互換性</target>
        </trans-unit>
        <trans-unit id="23a7808b48afc84b0dceb9136590ca7bfdbb9b77" translate="yes" xml:space="preserve">
          <source>Backward compatibility</source>
          <target state="translated">下位互換性</target>
        </trans-unit>
        <trans-unit id="ec09211f4889a2c8a77bac08067eb8783a4cd974" translate="yes" xml:space="preserve">
          <source>Backward compatible boilerplate</source>
          <target state="translated">下位互換性のあるボイラプレート</target>
        </trans-unit>
        <trans-unit id="8fd78925dba59eef91afba0cdabe923520e5ee69" translate="yes" xml:space="preserve">
          <source>Backwards compatibility</source>
          <target state="translated">下位互換性</target>
        </trans-unit>
        <trans-unit id="7d01557ea44942b942393d66060697fec065318a" translate="yes" xml:space="preserve">
          <source>Bad arg length for %s, is %u, should be %d</source>
          <target state="translated">%s の不正な arg の長さは %u で、%d であるべきです。</target>
        </trans-unit>
        <trans-unit id="165656139a26613694c64dbf201f062c5151055a" translate="yes" xml:space="preserve">
          <source>Bad color mapping %s</source>
          <target state="translated">不適切なカラーマッピング %s</target>
        </trans-unit>
        <trans-unit id="71ab08a2349cea719fd65e95a92efa2f68979a67" translate="yes" xml:space="preserve">
          <source>Bad escape sequence %s</source>
          <target state="translated">不正なエスケープシーケンス %s</target>
        </trans-unit>
        <trans-unit id="97e53bd47a32a9c5ca5b26c7f73e5af6cefd27e1" translate="yes" xml:space="preserve">
          <source>Bad evalled substitution pattern</source>
          <target state="translated">悪いエヴェールの代用パターン</target>
        </trans-unit>
        <trans-unit id="9cec2366e742bda57450610acf903181d2989bf8" translate="yes" xml:space="preserve">
          <source>Bad example:</source>
          <target state="translated">悪い例だ</target>
        </trans-unit>
        <trans-unit id="6b1ede25e2d280b57ab0ce582f6faf1b35cf90a7" translate="yes" xml:space="preserve">
          <source>Bad exit or wait status</source>
          <target state="translated">出口が悪い、または待機状態</target>
        </trans-unit>
        <trans-unit id="390acb944960513fda956a00da4e57aecfbdc40d" translate="yes" xml:space="preserve">
          <source>Bad filehandle: %s</source>
          <target state="translated">悪いファイルハンドル:%s</target>
        </trans-unit>
        <trans-unit id="2545bb8b8757d12600ee0fd7c8d21fd5ad24ec74" translate="yes" xml:space="preserve">
          <source>Bad free() ignored</source>
          <target state="translated">悪い free()は無視されました。</target>
        </trans-unit>
        <trans-unit id="d801fbd5f10bc4ae72d676efa25b3f102ac7bc5e" translate="yes" xml:space="preserve">
          <source>Bad hash</source>
          <target state="translated">バッドハッシュ</target>
        </trans-unit>
        <trans-unit id="4e025cf017a8d1ec1929f0fe963368b8537306db" translate="yes" xml:space="preserve">
          <source>Bad name after %s</source>
          <target state="translated">%s の後のバッドネーム</target>
        </trans-unit>
        <trans-unit id="fc9adf2eb1c251e659c032b900434bcbefd880c7" translate="yes" xml:space="preserve">
          <source>Bad plugin affecting keyword '%s'</source>
          <target state="translated">キーワード '%s' に影響を与える悪いプラグインです。</target>
        </trans-unit>
        <trans-unit id="ec81356ab8541823884a0a82a618613aa9cbd7b4" translate="yes" xml:space="preserve">
          <source>Bad realloc() ignored</source>
          <target state="translated">悪い realloc()は無視されました。</target>
        </trans-unit>
        <trans-unit id="6da31fb3200e756607d3e2e50254f7cea20fa96d" translate="yes" xml:space="preserve">
          <source>Bad subroutine name for Fatal: %s</source>
          <target state="translated">Fatal:%s のサブルーチン名が間違っています。</target>
        </trans-unit>
        <trans-unit id="42447de9c1418f0e2c311d00634195d77eb4c7e0" translate="yes" xml:space="preserve">
          <source>Bad symbol for array</source>
          <target state="translated">配列に対する不正なシンボル</target>
        </trans-unit>
        <trans-unit id="d65b92f2abbe5aa53ce089c4d6d379ebd454bfc3" translate="yes" xml:space="preserve">
          <source>Bad symbol for dirhandle</source>
          <target state="translated">dirhandleの悪いシンボル</target>
        </trans-unit>
        <trans-unit id="b66844a23804f5fa9fb3dbb57550acc9e7e5e7dd" translate="yes" xml:space="preserve">
          <source>Bad symbol for filehandle</source>
          <target state="translated">ファイルハンドルの不正なシンボル</target>
        </trans-unit>
        <trans-unit id="d7f407c0868b2e3ed85e66aedb4e0f3e18c18e11" translate="yes" xml:space="preserve">
          <source>Bad symbol for hash</source>
          <target state="translated">ハッシュの悪い記号</target>
        </trans-unit>
        <trans-unit id="08cf554f79f8dc5600aa8436990c34983c96cb70" translate="yes" xml:space="preserve">
          <source>Bad symbol for scalar</source>
          <target state="translated">スカラーの悪い記号</target>
        </trans-unit>
        <trans-unit id="c1bd2e42ef1c41d1f7a37013a433505cff6f0d53" translate="yes" xml:space="preserve">
          <source>Badly placed ()'s</source>
          <target state="translated">下手くそな()の</target>
        </trans-unit>
        <trans-unit id="9f60e950209318c3cca05ba1dcb8123b97e1b18f" translate="yes" xml:space="preserve">
          <source>Bailout</source>
          <target state="translated">Bailout</target>
        </trans-unit>
        <trans-unit id="55cc23ba5301ba2564daa62213188ebb8c917e57" translate="yes" xml:space="preserve">
          <source>Bailout result token.</source>
          <target state="translated">ベイルアウト結果トークン。</target>
        </trans-unit>
        <trans-unit id="2e1aced5d91a77947ec0c1e15905db2c6dabdd2d" translate="yes" xml:space="preserve">
          <source>Bailout!</source>
          <target state="translated">Bailout!</target>
        </trans-unit>
        <trans-unit id="c9c7caaefe38d5bc0e42cffe87236c93a6e055ee" translate="yes" xml:space="preserve">
          <source>Bal&amp;aacute;zs Szab&amp;oacute; (dLux), dlux@kapu.hu</source>
          <target state="translated">Bal&amp;aacute;zsSzab&amp;oacute;（dLux）、dlux @ kapu.hu</target>
        </trans-unit>
        <trans-unit id="fa6c3752cd00f7f1277fd7e5604ab8d2edaf26b8" translate="yes" xml:space="preserve">
          <source>Bangladesh</source>
          <target state="translated">Bangladesh</target>
        </trans-unit>
        <trans-unit id="528dadc6eada08b37b8564a84bbd615fedfa3a6d" translate="yes" xml:space="preserve">
          <source>Bar.pm</source>
          <target state="translated">Bar.pm</target>
        </trans-unit>
        <trans-unit id="991cc000e0ed51287d06994419ec5b5150b2fbbf" translate="yes" xml:space="preserve">
          <source>Bar.xs</source>
          <target state="translated">Bar.xs</target>
        </trans-unit>
        <trans-unit id="38e31cd750cd9c5c8abfa83e3cc07bbe5eb34dbc" translate="yes" xml:space="preserve">
          <source>Bare here-document terminators</source>
          <target state="translated">剥き出しのドキュメントターミネーター</target>
        </trans-unit>
        <trans-unit id="8f2f9eceeee98d7bac9099dfb477548bd0d00fe3" translate="yes" xml:space="preserve">
          <source>Bareword &quot;%s&quot; not allowed while &quot;strict subs&quot; in use</source>
          <target state="translated">strict subs&quot; が使用されている間は、裸語 &quot;%s&quot; は許可されません。</target>
        </trans-unit>
        <trans-unit id="74184baa622016b052c2c66c26dc81d35681d05a" translate="yes" xml:space="preserve">
          <source>Bareword &quot;%s&quot; refers to nonexistent package</source>
          <target state="translated">裸語 &quot;%s&quot; は存在しないパッケージを指します。</target>
        </trans-unit>
        <trans-unit id="a3f9425456098bc5db3b65fe0b670ee4dc328cf5" translate="yes" xml:space="preserve">
          <source>Bareword found in conditional</source>
          <target state="translated">条件付きで見つけられたバージョワード</target>
        </trans-unit>
        <trans-unit id="b3c6c09ca8e54434a9e30a3ee7363deeca4c4687" translate="yes" xml:space="preserve">
          <source>Bareword in require contains &quot;%s&quot;</source>
          <target state="translated">require には、&quot;%s&quot; が含まれています。</target>
        </trans-unit>
        <trans-unit id="99617bf4b7525e79f27dc14c638f75b9b86decd2" translate="yes" xml:space="preserve">
          <source>Bareword in require maps to disallowed filename &quot;%s&quot;</source>
          <target state="translated">require マップでは、許可されていないファイル名 &quot;%s&quot; へのキーワードを指定しています。</target>
        </trans-unit>
        <trans-unit id="e217673de1982c957abdb450217720b611015045" translate="yes" xml:space="preserve">
          <source>Bareword in require maps to empty filename</source>
          <target state="translated">空のファイル名にマップする必要がある場合には、そのファイル名の中にあるキーワードを使用しています。</target>
        </trans-unit>
        <trans-unit id="7b08d7d96976813240018e31332af5b98b35fa0d" translate="yes" xml:space="preserve">
          <source>Bareword in require must not start with a double-colon: &quot;%s&quot;</source>
          <target state="translated">require に含まれる裸語は、ダブルコロンで始めてはいけません。&quot;%s&quot;</target>
        </trans-unit>
        <trans-unit id="4d1ae41c7e90ad9133f0cec4b012d051f81574f4" translate="yes" xml:space="preserve">
          <source>Barewords</source>
          <target state="translated">Barewords</target>
        </trans-unit>
        <trans-unit id="6be542a3a79d103a3744357ed20ec40db010c97c" translate="yes" xml:space="preserve">
          <source>Barewords are not covered by overloaded string constants.</source>
          <target state="translated">裸語は、オーバーロードされた文字列定数ではカバーされません。</target>
        </trans-unit>
        <trans-unit id="a58b8ede3c3c15995119146605014af774c7bcd7" translate="yes" xml:space="preserve">
          <source>Base Class for IO::Compress modules</source>
          <target state="translated">IO::Compress モジュールの基底クラス</target>
        </trans-unit>
        <trans-unit id="1aecc52f6145193c99cc41e745488c8d94f4db0b" translate="yes" xml:space="preserve">
          <source>Base Class for IO::Uncompress modules</source>
          <target state="translated">IO::Uncompress モジュールの基底クラス</target>
        </trans-unit>
        <trans-unit id="9410f6a2867439548603d6c52d5c59ef4562fa7b" translate="yes" xml:space="preserve">
          <source>Base Structures</source>
          <target state="translated">ベース構造</target>
        </trans-unit>
        <trans-unit id="082fae7b28f65e5cb911e0f3f3f15b07bb66cbb1" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied handles</source>
          <target state="translated">タイドハンドルの基本クラス定義</target>
        </trans-unit>
        <trans-unit id="007ee9121a8b9e57fcd866ceebd36b23a00f0fde" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied hashes</source>
          <target state="translated">タイドハッシュの基本クラス定義</target>
        </trans-unit>
        <trans-unit id="b6b455ad8f579493b53af2265bc184f2ba6c6cbb" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied scalars</source>
          <target state="translated">紐付きスカラの基底クラス定義</target>
        </trans-unit>
        <trans-unit id="9cae4a150d12d8ffc0b3fa77692959a6c4bfb799" translate="yes" xml:space="preserve">
          <source>Base class for ALL classes (blessed references)</source>
          <target state="translated">すべてのクラスの基底クラス (祝福された参照)</target>
        </trans-unit>
        <trans-unit id="35cd310da77bd29a53a2d4932d2eb92ae62a2b7e" translate="yes" xml:space="preserve">
          <source>Base class for CPAN shell extensions</source>
          <target state="translated">CPAN シェル拡張のための基底クラス</target>
        </trans-unit>
        <trans-unit id="c3e0f91a5e302404f6913115b1263f4db4575024" translate="yes" xml:space="preserve">
          <source>Base class for ExtUtils::Constant objects</source>
          <target state="translated">ExtUtils::Constant オブジェクトの基底クラス</target>
        </trans-unit>
        <trans-unit id="5ce69fa0ba6f632f7e9c5c2e2e7602e063a7c7a9" translate="yes" xml:space="preserve">
          <source>Base class for TAP source iterators</source>
          <target state="translated">TAPソースイテレータの基底クラス</target>
        </trans-unit>
        <trans-unit id="37eb343993cd16220ab0f185a716f5c376429394" translate="yes" xml:space="preserve">
          <source>Base class for TAP::Parser output objects</source>
          <target state="translated">TAP::Parser 出力オブジェクトの基底クラス</target>
        </trans-unit>
        <trans-unit id="a0880f8d682b9138475bd47a938947c12338445c" translate="yes" xml:space="preserve">
          <source>Base class for Test2 IPC drivers.</source>
          <target state="translated">Test2 IPCドライバの基底クラス。</target>
        </trans-unit>
        <trans-unit id="9cde81f5a0639d96966be94bffabdcc2cee72d19" translate="yes" xml:space="preserve">
          <source>Base class for all event facets.</source>
          <target state="translated">すべてのイベントファセットの基底クラス。</target>
        </trans-unit>
        <trans-unit id="28ab0f65808322aafffdf4f4c4569b0ca559cecd" translate="yes" xml:space="preserve">
          <source>Base class for all event objects that get passed through &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;test2&quot;&gt;Test2を&lt;/a&gt;通過するすべてのイベントオブジェクトの基本クラス。</target>
        </trans-unit>
        <trans-unit id="b8befc5059605409ade42b4d099e397b207c906b" translate="yes" xml:space="preserve">
          <source>Base class for creating POD filters and translators</source>
          <target state="translated">POD フィルタおよびトランスレータを作成するための基底クラス</target>
        </trans-unit>
        <trans-unit id="78eefd2e412b4d4df740ff4fbfcce92bad174022" translate="yes" xml:space="preserve">
          <source>Base class for different TAP source handlers</source>
          <target state="translated">さまざまな TAP ソースハンドラのための基底クラス</target>
        </trans-unit>
        <trans-unit id="6d6b96a9e4df11d307d7125ce342fa82d8eb0fc3" translate="yes" xml:space="preserve">
          <source>Base class for events</source>
          <target state="translated">イベントの基底クラス</target>
        </trans-unit>
        <trans-unit id="e4dfc8dbeda31aa613f1ab98bcf6af5cdb80223d" translate="yes" xml:space="preserve">
          <source>Base class for harness output delegates</source>
          <target state="translated">ハーネス出力デリゲートの基底クラス</target>
        </trans-unit>
        <trans-unit id="7a74e67740b1a1d00bee0be3088f31fbc10821ea" translate="yes" xml:space="preserve">
          <source>Base class for test modules</source>
          <target state="translated">テストモジュールの基底クラス</target>
        </trans-unit>
        <trans-unit id="78996d2c61d5e3e13d981dd6371495a7dc1b0695" translate="yes" xml:space="preserve">
          <source>Base class for tied arrays</source>
          <target state="translated">紐付き配列の基底クラス</target>
        </trans-unit>
        <trans-unit id="4c8eae847ee205298317c9b96e374f69e5e9feb1" translate="yes" xml:space="preserve">
          <source>Base class package &quot;%s&quot; is empty.</source>
          <target state="translated">基底クラス・パッケージ &quot;%s&quot; は空です。</target>
        </trans-unit>
        <trans-unit id="5134fdf6155e7a9843c83a26849d1aff846f4d88" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parserに&lt;/a&gt;共通の機能を提供する基本クラス</target>
        </trans-unit>
        <trans-unit id="8811ba419e75aa7afad3c58a4392ff34e2f70b65" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to &lt;a href=&quot;tap/parser&quot;&gt;TAP::Parser&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;tap/parser&quot;&gt;TAP :: Parserに&lt;/a&gt;共通の機能を提供する基本クラス</target>
        </trans-unit>
        <trans-unit id="0808d28ca43c79c7220c0b66b8832ca8877ecfdc" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to all &lt;code&gt;TAP::*&lt;/code&gt; modules</source>
          <target state="translated">すべての &lt;code&gt;TAP::*&lt;/code&gt; モジュールに共通の機能を提供する基本クラス</target>
        </trans-unit>
        <trans-unit id="7a76be2c1588f2035fb74a3a61c2be909fdefa70" translate="yes" xml:space="preserve">
          <source>Base for Pod::Perldoc formatters</source>
          <target state="translated">Pod::Perldocのフォーマッタ用ベース</target>
        </trans-unit>
        <trans-unit id="bf06e03b88934d434a87ce7787240b8e99aae0b0" translate="yes" xml:space="preserve">
          <source>Based on Stevan Little's &lt;a href=&quot;Class::C3&quot;&gt;Class::C3&lt;/a&gt;</source>
          <target state="translated">StevanLittleの&lt;a href=&quot;Class::C3&quot;&gt;Class :: C3に&lt;/a&gt;基づく</target>
        </trans-unit>
        <trans-unit id="2291e71c9ac6320d0a4640a773f789651e805f6a" translate="yes" xml:space="preserve">
          <source>Based on Stevan Little's &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class::C3&lt;/a&gt;</source>
          <target state="translated">Stevan Littleの&lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class :: C3に&lt;/a&gt;基づく</target>
        </trans-unit>
        <trans-unit id="560c120ffa51ce8d2dc3b95d35311dd465a3c278" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text::pod2text()&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;によって記述された&lt;b&gt;Pod :: Text :: pod2text（）の&lt;/b&gt;コードに基づく</target>
        </trans-unit>
        <trans-unit id="25b805dbff71baab76550b6af4db1656526ccb89" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text::pod2text(1)&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;によって記述された&lt;b&gt;Pod :: Text :: pod2text（1）の&lt;/b&gt;コードに基づく</target>
        </trans-unit>
        <trans-unit id="b781efd9c14a9bf17ea0a940b2c65ad0a21bc5c6" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;によって記述された&lt;b&gt;Pod :: Textの&lt;/b&gt;コードに基づく</target>
        </trans-unit>
        <trans-unit id="d91768d646bf2b1ba37683cf7ff89c9b306d5b4f" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;pod2text(1)&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;によって書かれた&lt;b&gt;pod2text（1）の&lt;/b&gt;コードに基づく</target>
        </trans-unit>
        <trans-unit id="e809a71bc55e573d735398064fa73868c841b25e" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;pod2text&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;によって書かれた&lt;b&gt;pod2textの&lt;/b&gt;コードに基づく</target>
        </trans-unit>
        <trans-unit id="23082a2ee1ef553f8b8e9cc56e439b97636f01bf" translate="yes" xml:space="preserve">
          <source>Based on code written by Shigio Yamaguchi.</source>
          <target state="translated">山口茂雄氏が書いたコードを元にしています。</target>
        </trans-unit>
        <trans-unit id="8e0d5bb83e47c2192346afc47fe774052eb51e39" translate="yes" xml:space="preserve">
          <source>Based on example that was initially added to MIME::QuotedPrint.pm for the 5.8.0 distribution of Perl.</source>
          <target state="translated">Perl の 5.8.0 ディストリビューション用に MIME::QuotedPrint.pm に最初に追加された例に基づいています。</target>
        </trans-unit>
        <trans-unit id="a800ab4559098c87aba7a8e90188704683d129b8" translate="yes" xml:space="preserve">
          <source>Based on ideas from Tim Bunce &amp;lt;&lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;gt; and</source>
          <target state="translated">Tim Bunce &amp;lt; &lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;gt;および</target>
        </trans-unit>
        <trans-unit id="01bb16997fde52e47c429c6fd628c8c4ddf3054c" translate="yes" xml:space="preserve">
          <source>Based on ideas from Tim Bunce &amp;lt;&lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt;&amp;gt; and</source>
          <target state="translated">Tim Bunce &amp;lt; &lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;gt;からのアイデアに基づく</target>
        </trans-unit>
        <trans-unit id="ef4b57022699f0d3f5da98a8d57cddc66db361df" translate="yes" xml:space="preserve">
          <source>Based on the &lt;code&gt;:perlio&lt;/code&gt; layer.</source>
          <target state="translated">&lt;code&gt;:perlio&lt;/code&gt; レイヤーに基づいています。</target>
        </trans-unit>
        <trans-unit id="6189eca4d6c06b60af97bb9ce0c1f1fc615c134d" translate="yes" xml:space="preserve">
          <source>Based on the &lt;code&gt;ExtUtils::xsubpp&lt;/code&gt; code by Larry Wall and the Perl 5 Porters, which was released under the same license terms.</source>
          <target state="translated">同じライセンス条項に基づいてリリースされた、Larry WallとPerl 5 Portersによる &lt;code&gt;ExtUtils::xsubpp&lt;/code&gt; コードに基づいています。</target>
        </trans-unit>
        <trans-unit id="da8636da22477810e470724d83ddc721d3335da8" translate="yes" xml:space="preserve">
          <source>Based on the Glossary of</source>
          <target state="translated">の用語集に基づいて</target>
        </trans-unit>
        <trans-unit id="f28c9a8ac3d744f82801c7cfbb9de24801e7c563" translate="yes" xml:space="preserve">
          <source>Based on xsubpp code, written by Larry Wall.</source>
          <target state="translated">Larry Wallによって書かれたxsubppのコードをベースにしています。</target>
        </trans-unit>
        <trans-unit id="02905231fdcd4472df63f80b291fb153344c31cd" translate="yes" xml:space="preserve">
          <source>Basic BLOCKs</source>
          <target state="translated">基本的なBLOCK</target>
        </trans-unit>
        <trans-unit id="901e56ace2d31ac4485efe2aa588116787957443" translate="yes" xml:space="preserve">
          <source>Basic IO operations</source>
          <target state="translated">基本的なIO操作</target>
        </trans-unit>
        <trans-unit id="8422cb1795fcef709d3e089320f56308fec39046" translate="yes" xml:space="preserve">
          <source>Basic Multilingual Plane</source>
          <target state="translated">基本的な多言語の平面</target>
        </trans-unit>
        <trans-unit id="ccecd116866361404babdb87c039096fbb71e99c" translate="yes" xml:space="preserve">
          <source>Basic Structure</source>
          <target state="translated">基本構造</target>
        </trans-unit>
        <trans-unit id="39bbc4bee9f4a75c10797a6d328f733ea1124880" translate="yes" xml:space="preserve">
          <source>Basic Thread Support</source>
          <target state="translated">基本スレッドサポート</target>
        </trans-unit>
        <trans-unit id="17f89c170a632afd0c0b0383dacf728c05a89851" translate="yes" xml:space="preserve">
          <source>Basic Utilities for Programmers</source>
          <target state="translated">プログラマーのための基本的なユーティリティ</target>
        </trans-unit>
        <trans-unit id="148d2121cd077901af2d5cbf9aa363677304a06b" translate="yes" xml:space="preserve">
          <source>Basic commands:</source>
          <target state="translated">基本的なコマンドです。</target>
        </trans-unit>
        <trans-unit id="7308cb8418c068204c128968b5967fdf3606cc09" translate="yes" xml:space="preserve">
          <source>Basic methods</source>
          <target state="translated">基本的な方法</target>
        </trans-unit>
        <trans-unit id="874d9df75ebdafc19870b90059bb69c04cb1fce7" translate="yes" xml:space="preserve">
          <source>Basic read operation.</source>
          <target state="translated">基本的な読み取り操作を行います。</target>
        </trans-unit>
        <trans-unit id="c4901220ad10be08f037f204182ab7f0bb55ef8b" translate="yes" xml:space="preserve">
          <source>Basic semaphores</source>
          <target state="translated">基本的なセマフォ</target>
        </trans-unit>
        <trans-unit id="cf61d93532db2a473529a2856c70f230829513f8" translate="yes" xml:space="preserve">
          <source>Basic syntax overview</source>
          <target state="translated">基本構文の概要</target>
        </trans-unit>
        <trans-unit id="ce7944aa05e48b110f9c5b8903d70aed90358355" translate="yes" xml:space="preserve">
          <source>Basic utilities for writing tests.</source>
          <target state="translated">テストを書くための基本的なユーティリティ。</target>
        </trans-unit>
        <trans-unit id="62b9ac85afbcfa7bd7a8e867b1f51756e30ca7d7" translate="yes" xml:space="preserve">
          <source>Basic write operation.</source>
          <target state="translated">基本的な書き込み操作。</target>
        </trans-unit>
        <trans-unit id="04e2b1373d1c985716d261c139c35de4bc421d62" translate="yes" xml:space="preserve">
          <source>Basically, Intel and VAX CPUs are little-endian, while everybody else, including Motorola m68k/88k, PPC, Sparc, HP PA, Power, and Cray, are big-endian. Alpha and MIPS can be either: Digital/Compaq uses (well, used) them in little-endian mode, but SGI/Cray uses them in big-endian mode.</source>
          <target state="translated">基本的に、IntelとVAXのCPUはリトルエンディアンで、Motorola m68k/88k、PPC、Sparc、HP PA、Power、Crayなどの他のCPUはビッグエンディアンです。AlphaやMIPSはどちらでもいい。Digital/Compaq はリトルエンディアンモードで使用していますが、SGI/Cray はビッグエンディアンモードで使用しています。</target>
        </trans-unit>
        <trans-unit id="1f10fe5797c3d1f7733a7eb604c9de17cf9d91ac" translate="yes" xml:space="preserve">
          <source>Basically, you fetch individual results from the TAP. The six types, with examples of each, are as follows:</source>
          <target state="translated">基本的にはTAPから個別の結果を取得します。6つのタイプがあり、それぞれの例を挙げると以下のようになります。</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="4beb8f757ba4e13e29ffb8c6a2d654b5eee3dc8e" translate="yes" xml:space="preserve">
          <source>Baud rate values</source>
          <target state="translated">ボーレート値</target>
        </trans-unit>
        <trans-unit id="3764ce6b277261088796ef6723dbaafdda0e32f0" translate="yes" xml:space="preserve">
          <source>Be aware of two important points:</source>
          <target state="translated">重要な2つのポイントを意識しましょう。</target>
        </trans-unit>
        <trans-unit id="9042cbc9bb8a8748d18e82d265eee86b54008013" translate="yes" xml:space="preserve">
          <source>Be aware that all exceptions are stringified during construction.</source>
          <target state="translated">工事中はすべての例外が文字列化されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="e4436a305cd04dc72f8078b037e6c2a662f1fa1d" translate="yes" xml:space="preserve">
          <source>Be aware that all filenames returned from File::Glob are tainted.</source>
          <target state="translated">File::Glob から返されるファイル名はすべて汚染されていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="3297ac638d07f74b1cf62949925d4b3e23422ec7" translate="yes" xml:space="preserve">
          <source>Be aware that many files in the distribution are derivative--avoid patching them, because git won't see the changes to them, and the build process will overwrite them. Patch the originals instead. Most utilities (like perldoc) are in this category, i.e. patch</source>
          <target state="translated">ディストリビューションに含まれる多くのファイルは派生ファイルであることに注意しましょう。代わりに元のファイルにパッチを当てましょう。(perldoc のような)ほとんどのユーティリティはこのカテゴリに属します。</target>
        </trans-unit>
        <trans-unit id="60f217633ac67f75e40713203caa69acc0ee5347" translate="yes" xml:space="preserve">
          <source>Be aware that setting &lt;code&gt;@DB::args&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;@DB::args&lt;/code&gt; 設定は</target>
        </trans-unit>
        <trans-unit id="667b9a553537bba23ef30dd15f8a2bf40c9a72d6" translate="yes" xml:space="preserve">
          <source>Be aware that the digest routines silently convert UTF-8 input into its equivalent byte sequence in the native encoding (cf. utf8::downgrade). This side effect influences only the way Perl stores the data internally, but otherwise leaves the actual value of the data intact.</source>
          <target state="translated">ダイジェストルーチンは、UTF-8入力をネイティブエンコーディングの等価なバイト列に無言で変換することに注意してください(utf8::downngrade参照)。この副作用は Perl が内部的にデータを保存する方法にのみ影響を与えますが、それ以外の場合はデータの実際の値をそのまま残します。</target>
        </trans-unit>
        <trans-unit id="167d28f752fc336f0724d4becf42fb8c17cf60ad" translate="yes" xml:space="preserve">
          <source>Be aware that the file's type/creator and resource fork will be lost, which is usually what you want in cross-platform archives.</source>
          <target state="translated">ファイルの type/creator と resource fork が失われることに注意してください。</target>
        </trans-unit>
        <trans-unit id="64b3ff265c6f33aa278b5fc7ab5adbd6a628d376" translate="yes" xml:space="preserve">
          <source>Be aware that the main value of this module is its simplicity. Note that there are already more ambitious modules out there, such as &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;Test::Unit&quot;&gt;Test::Unit&lt;/a&gt;.</source>
          <target state="translated">このモジュールの主な価値はその単純さであることに注意してください。&lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt;や&lt;a href=&quot;Test::Unit&quot;&gt;Test :: Unit&lt;/a&gt;など、もっと野心的なモジュールがすでに存在することに注意してください。</target>
        </trans-unit>
        <trans-unit id="2a627d6aeb5bb9832269cd11d71094ebccabe8d0" translate="yes" xml:space="preserve">
          <source>Be aware that the main value of this module is its simplicity. Note that there are already more ambitious modules out there, such as &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Unit&quot;&gt;Test::Unit&lt;/a&gt;.</source>
          <target state="translated">このモジュールの主な価値はその単純さであることに注意してください。&lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt;や&lt;a href=&quot;http://search.cpan.org/perldoc/Test::Unit&quot;&gt;Test :: Unit&lt;/a&gt;など、意欲的なモジュールがすでに存在していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="f073a8ab4396a4ea1a82c329831db3a4c81e7bb9" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;a href=&quot;#caller-EXPR&quot;&gt;&lt;code&gt;caller&lt;/code&gt;&lt;/a&gt; had a chance to get the information. That means that &lt;code&gt;caller(N)&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt;. In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;a href=&quot;#caller-EXPR&quot;&gt;&lt;code&gt;caller&lt;/code&gt;&lt;/a&gt; was called.</source>
          <target state="translated">オプティマイザは、&lt;a href=&quot;#caller-EXPR&quot;&gt; &lt;code&gt;caller&lt;/code&gt; &lt;/a&gt;が情報を取得する前に、コールフレームを最適化した可能性があることに注意してください。つまり、 &lt;code&gt;N &amp;gt; 1&lt;/code&gt; 場合、 &lt;code&gt;caller(N)&lt;/code&gt; は期待するコールフレームに関する情報を返さない可能性があります。特に、 &lt;code&gt;@DB::args&lt;/code&gt; は、&lt;a href=&quot;#caller-EXPR&quot;&gt; &lt;code&gt;caller&lt;/code&gt; &lt;/a&gt;が前回呼び出されたときの情報が含まれている場合があります。</target>
        </trans-unit>
        <trans-unit id="31de5d87ee0c0608b86806f39ac15e28011be167" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; had a chance to get the information. That means that &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; が情報を取得する前に、オプティマイザが呼び出しフレームを最適化していた可能性があることに注意してください。つまり、 &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;N &amp;gt; 1&lt;/code&gt; 場合、期待する呼び出しフレームに関する情報を返さない可能性があります。特に、 &lt;code&gt;@DB::args&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; が以前に呼び出されたときの情報が含まれている場合があります。</target>
        </trans-unit>
        <trans-unit id="956f008e111339a547685e28f223bd6fbcba83d9" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; had a chance to get the information. That means that &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; が情報を取得する前に、オプティマイザが呼び出しフレームを最適化していた可能性があることに注意してください。つまり、 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;N &amp;gt; 1&lt;/code&gt; 場合、期待する呼び出しフレームに関する情報を返さない可能性があります。特に、 &lt;code&gt;@DB::args&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; が以前に呼び出されたときの情報が含まれている場合があります。</target>
        </trans-unit>
        <trans-unit id="fd6d74606bcc17d1eb7f4b9d0cbb233b2fce04be" translate="yes" xml:space="preserve">
          <source>Be aware that the option to follow symbolic links can be dangerous. Depending on the structure of the directory tree (including symbolic links to directories) you might traverse a given (physical) directory more than once (only if &lt;code&gt;follow_fast&lt;/code&gt; is in effect). Furthermore, deleting or changing files in a symbolically linked directory might cause very unpleasant surprises, since you delete or change files in an unknown directory.</source>
          <target state="translated">シンボリックリンクをたどるオプションは危険な場合があることに注意してください。ディレクトリツリーの構造（ディレクトリへのシンボリックリンクを含む）によっては、特定の（物理）ディレクトリを複数回トラバースする場合があります（ &lt;code&gt;follow_fast&lt;/code&gt; が有効な場合のみ）。さらに、シンボリックリンクされたディレクトリのファイルを削除または変更すると、不明なディレクトリのファイルを削除または変更するため、非常に不愉快な驚きが生じる可能性があります。</target>
        </trans-unit>
        <trans-unit id="b81ba14d3ce3de8180275845ca38e42a572b2c9a" translate="yes" xml:space="preserve">
          <source>Be aware that these operations are full Unix forks, which means they may not be correctly implemented on all alien systems.</source>
          <target state="translated">これらの操作は完全な Unix のフォークであり、すべてのエイリアンシステムで正しく実装されているわけではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="edbf362a8476b23d76d24466d122396a40549047" translate="yes" xml:space="preserve">
          <source>Be aware that these operations are full Unix forks, which means they may not be correctly implemented on all alien systems. See &lt;a href=&quot;perlport#open&quot;&gt;&quot;open&quot; in perlport&lt;/a&gt; for portability details.</source>
          <target state="translated">これらの操作は完全なUnixフォークであることに注意してください。つまり、すべてのエイリアンシステムに正しく実装されていない可能性があります。参照&lt;a href=&quot;perlport#open&quot;&gt;はperlportで「オープン」&lt;/a&gt;の移植の詳細について。</target>
        </trans-unit>
        <trans-unit id="5d4c04a6ec8f48645b28a87376c9f6999c39b61b" translate="yes" xml:space="preserve">
          <source>Be aware that this option makes you accept invalid JSON texts as if they were valid!</source>
          <target state="translated">このオプションを指定すると、無効なJSONテキストをあたかも有効であるかのように受け入れてしまうことに注意してください。</target>
        </trans-unit>
        <trans-unit id="9573a203063d54f5dc27408bed7844c1be7ddce6" translate="yes" xml:space="preserve">
          <source>Be aware that this will export ANSI_COLORS_DISABLED to any child processes of your program as well.</source>
          <target state="translated">ANSI_COLORS_DISABLEDは、プログラムの子プロセスにもエクスポートされるので注意してください。</target>
        </trans-unit>
        <trans-unit id="9011ae4d69e158b2d5d9fa7d3f0fa4181ed416ab" translate="yes" xml:space="preserve">
          <source>Be aware that writing a multi-threaded application will not be portable to a platform which lacks the native thread-safe locale support. On systems that do have it, you automatically get this behavior for threaded perls, without having to do anything. If for some reason, you don't want to use this capability (perhaps the POSIX 2008 support is buggy on your system), you can manually compile Perl to use the old non-thread-safe implementation by passing the argument &lt;code&gt;-Accflags='-DNO_THREAD_SAFE_LOCALE'&lt;/code&gt; to</source>
          <target state="translated">マルチスレッドアプリケーションの作成は、ネイティブのスレッドセーフロケールサポートがないプラットフォームに移植できないことに注意してください。それを持っているシステムでは、何もしなくても、スレッド化されたperlに対してこの動作を自動的に取得します。何らかの理由でこの機能を使用したくない場合（おそらくPOSIX 2008のサポートがシステムでバグがある場合）、引数 &lt;code&gt;-Accflags='-DNO_THREAD_SAFE_LOCALE'&lt;/code&gt; を渡すことにより、Perlを手動でコンパイルして古い非スレッドセーフ実装を使用できます。-DNO_THREAD_SAFE_LOCALE 'から</target>
        </trans-unit>
        <trans-unit id="6dac6d64c1feff1fddea48f799c315f06283805b" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source must be properly declared unless it is US-ASCII or Latin-1. POD input without an &lt;code&gt;=encoding&lt;/code&gt; command will be assumed to be in Latin-1, and if it's actually in UTF-8, the output will be double-encoded. See</source>
          <target state="translated">このオプションを使用する場合、US-ASCIIまたはLatin-1でない限り、PODソースの入力エンコーディングを適切に宣言する必要があることに注意してください。 &lt;code&gt;=encoding&lt;/code&gt; コマンドのないPOD入力はLatin-1であると想定され、実際にUTF-8である場合、出力は二重にエンコードされます。見る</target>
        </trans-unit>
        <trans-unit id="112ebc66d2bbad303aae87da4af1076cd40b1dbe" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source should be properly declared unless it's US-ASCII. Pod::Simple will attempt to guess the encoding and may be successful if it's Latin-1 or UTF-8, but it will produce warnings. Use the &lt;code&gt;=encoding&lt;/code&gt; command to declare the encoding. See &lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod(1)&lt;/a&gt; for more information.</source>
          <target state="translated">このオプションを使用する場合、US-ASCIIでない限り、PODソースの入力エンコーディングを適切に宣言する必要があることに注意してください。 Pod :: Simpleはエンコーディングを推測しようとし、Latin-1またはUTF-8の場合は成功する可能性がありますが、警告が表示されます。 &lt;code&gt;=encoding&lt;/code&gt; コマンドを使用して、エンコーディングを宣言します。詳細については、&lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod（1）&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="14539a0200a018d8bfd0c01f3ce67edac22b2e5e" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source should be properly declared unless it's US-ASCII. Pod::Simple will attempt to guess the encoding and may be successful if it's Latin-1 or UTF-8, but it will warn, which by default results in a &lt;b&gt;pod2man&lt;/b&gt; failure. Use the &lt;code&gt;=encoding&lt;/code&gt; command to declare the encoding. See &lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod(1)&lt;/a&gt; for more information.</source>
          <target state="translated">このオプションを使用する場合、US-ASCIIでない限り、PODソースの入力エンコーディングを適切に宣言する必要があることに注意してください。 Pod :: Simpleはエンコーディングを推測しようとし、Latin-1またはUTF-8の場合は成功する可能性がありますが、警告が表示され、デフォルトで&lt;b&gt;pod2manが&lt;/b&gt;失敗します。 &lt;code&gt;=encoding&lt;/code&gt; コマンドを使用して、エンコーディングを宣言します。詳細については、&lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod（1）&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b528c0888545102ae09966c077f548f42a0a07e8" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source should be properly declared unless it's US-ASCII. Pod::Simple will attempt to guess the encoding and may be successful if it's Latin-1 or UTF-8, but it will warn, which by default results in a &lt;b&gt;pod2text&lt;/b&gt; failure. Use the &lt;code&gt;=encoding&lt;/code&gt; command to declare the encoding. See &lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod(1)&lt;/a&gt; for more information.</source>
          <target state="translated">このオプションを使用する場合、US-ASCIIでない限り、PODソースの入力エンコーディングを適切に宣言する必要があることに注意してください。Pod :: Simpleはエンコーディングを推測しようとし、Latin-1またはUTF-8の場合は成功する可能性がありますが、警告が表示され、デフォルトで&lt;b&gt;pod2textが&lt;/b&gt;失敗します。 &lt;code&gt;=encoding&lt;/code&gt; コマンドを使用して、エンコーディングを宣言します。詳細については、&lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod（1）&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8e54fdab18656cd50e15f88c4bd2cd505cbcafa9" translate="yes" xml:space="preserve">
          <source>Be aware, moreover, that even among Unix-ish systems there are variations.</source>
          <target state="translated">さらに、Unix 系のシステムの中にもバリエーションがあることに注意してください。</target>
        </trans-unit>
        <trans-unit id="56eaa37568b649078a87e40ea7bc8697501ac281" translate="yes" xml:space="preserve">
          <source>Be careful about the syntax,</source>
          <target state="translated">構文には気をつけましょう。</target>
        </trans-unit>
        <trans-unit id="f8fdb4158175acb38dcf577960ceb71bd1d96eb9" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;a href=&quot;#formline-PICTURE%2CLIST&quot;&gt;&lt;code&gt;formline&lt;/code&gt;&lt;/a&gt; always returns true. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; 文字は配列名の先頭を意味すると解釈される可能性があるため、画像を二重引用符で囲む場合は注意してください。&lt;a href=&quot;#formline-PICTURE%2CLIST&quot;&gt; &lt;code&gt;formline&lt;/code&gt; は&lt;/a&gt;常にtrueを返します。他の例については、&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b3f347eeb5e9dd5ad6442952b1aeb5c318d4fa11" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; always returns true. See &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">画像を二重引用符で囲む場合は注意してください。 &lt;code&gt;@&lt;/code&gt; 文字は配列名の始まりを意味すると解釈される場合があります。 &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; は常にtrueを返します。他の例については&lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6906a7867a27a79ea2a227d91624d262e203f04e" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; always returns true. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">画像を二重引用符で囲む場合は注意してください。 &lt;code&gt;@&lt;/code&gt; 文字は配列名の始まりを意味すると解釈される場合があります。 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; は常にtrueを返します。他の例については&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4aaaf54937dcd1947fa04a848c937575a75bb3aa" translate="yes" xml:space="preserve">
          <source>Be careful in the tests you supply with your module or programs. Module code may be fully portable, but its tests might not be. This often happens when tests spawn off other processes or call external programs to aid in the testing, or when (as noted above) the tests assume certain things about the filesystem and paths. Be careful not to depend on a specific output style for errors, such as when checking &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; after a failed system call. Using &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; for anything else than displaying it as output is doubtful (though see the &lt;a href=&quot;errno&quot;&gt;&lt;code&gt;Errno&lt;/code&gt;&lt;/a&gt; module for testing reasonably portably for error value). Some platforms expect a certain output format, and Perl on those platforms may have been adjusted accordingly. Most specifically, don't anchor a regex when testing an error value.</source>
          <target state="translated">モジュールまたはプログラムで提供するテストには注意してください。モジュールコードは完全に移植可能かもしれませんが、そのテストはそうではないかもしれません。これは、テストが他のプロセスを生成したり、テストを支援するために外部プログラムを呼び出したりする場合、または（上記のように）テストがファイルシステムとパスに関する特定のことを想定している場合によく発生します。&lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;チェックするときなど、エラーについて特定の出力スタイルに依存しないように注意してください。システムコールが失敗した後。&lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;を使用して！出力として表示する以外のことについては疑わしいです（ただし、エラー値について合理的に移植可能にテストするための&lt;a href=&quot;errno&quot;&gt; &lt;code&gt;Errno&lt;/code&gt; &lt;/a&gt;モジュールを参照してください）。一部のプラットフォームは特定の出力形式を期待しており、それらのプラットフォームのPerlはそれに応じて調整されている可能性があります。具体的には、エラー値をテストするときに正規表現を固定しないでください。</target>
        </trans-unit>
        <trans-unit id="a9293d7623c3a63a2528c6144b0e2f16fd9c21b7" translate="yes" xml:space="preserve">
          <source>Be careful in the tests you supply with your module or programs. Module code may be fully portable, but its tests might not be. This often happens when tests spawn off other processes or call external programs to aid in the testing, or when (as noted above) the tests assume certain things about the filesystem and paths. Be careful not to depend on a specific output style for errors, such as when checking &lt;code&gt;$!&lt;/code&gt; after a failed system call. Using &lt;code&gt;$!&lt;/code&gt; for anything else than displaying it as output is doubtful (though see the &lt;code&gt;Errno&lt;/code&gt; module for testing reasonably portably for error value). Some platforms expect a certain output format, and Perl on those platforms may have been adjusted accordingly. Most specifically, don't anchor a regex when testing an error value.</source>
          <target state="translated">モジュールまたはプログラムで提供するテストには注意してください。モジュールコードは完全に移植可能かもしれませんが、そのテストはそうではないかもしれません。これは、テストが他のプロセスを生成したり、外部プログラムを呼び出してテストを支援したり、（上記のように）テストがファイルシステムとパスについて特定のことを想定したりするときによく発生します。 &lt;code&gt;$!&lt;/code&gt; をチェックするときなど、エラーを特定の出力スタイルに依存しないように注意してください。システムコールが失敗した後。 &lt;code&gt;$!&lt;/code&gt; を使用する出力として表示する以外は何も疑わしいです（ただし、エラー値の移植性を合理的にテストするには、 &lt;code&gt;Errno&lt;/code&gt; モジュールを参照してください）。一部のプラットフォームは特定の出力形式を想定しており、それらのプラットフォームのPerlはそれに応じて調整されている可能性があります。最も具体的には、エラー値をテストするときに正規表現を固定しないでください。</target>
        </trans-unit>
        <trans-unit id="ae93e14e0d1be510a7665d0a55ac6aa4f668df14" translate="yes" xml:space="preserve">
          <source>Be careful to check that what you pass to chdir() is defined and not blank, else you might find yourself in your home directory.</source>
          <target state="translated">chdir()に渡すものが定義されていて、空白になっていないことを確認するように注意してください。</target>
        </trans-unit>
        <trans-unit id="c85ebb348de7431489e7e78b8e62158b4eaa9740" translate="yes" xml:space="preserve">
          <source>Be careful to check the return values from both open() and close(). If you're</source>
          <target state="translated">open()とclose()の両方からの戻り値を確認するように注意しましょう。もし、あなたが</target>
        </trans-unit>
        <trans-unit id="aee2df458bcc4bef02091d782f8436bc138473c7" translate="yes" xml:space="preserve">
          <source>Be careful to repeat this procedure every time you recompile an extension, unless you are sure the AFS installation directories are still valid.</source>
          <target state="translated">AFSのインストールディレクトリが有効であることを確認しない限り、拡張機能を再コンパイルするたびにこの手順を繰り返すように注意してください。</target>
        </trans-unit>
        <trans-unit id="fe76e94f1a35b852ed4a509f3683ff3f6a306181" translate="yes" xml:space="preserve">
          <source>Be careful when using the branch reset pattern in combination with named captures. Named captures are implemented as being aliases to numbered groups holding the captures, and that interferes with the implementation of the branch reset pattern. If you are using named captures in a branch reset pattern, it's best to use the same names, in the same order, in each of the alternations:</source>
          <target state="translated">ブランチリセットパターンを名前付きキャプチャと組み合わせて使用する場合は注意が必要です。名前付きキャプチャは、キャプチャを保持する番号付きグループへのエイリアスとして実装されており、ブランチリセットパターンの実装を妨害します。ブランチリセットパターンで名前付きキャプチャを使用する場合は、交互に同じ名前を同じ順番で使用するのがベストです。</target>
        </trans-unit>
        <trans-unit id="8f8df673aaa9f753cd8e9cf23c8cbbd3b2574c49" translate="yes" xml:space="preserve">
          <source>Be careful, though, to never combine text strings with binary strings. If you need text in a binary stream, encode your text strings first using the appropriate encoding, then join them with binary strings. See also: &quot;What if I don't encode?&quot;.</source>
          <target state="translated">ただし、テキスト文字列とバイナリ文字列を組み合わせないように注意してください。バイナリストリームのテキストが必要な場合は、まず適切なエンコーディングを使用してテキスト文字列をエンコードしてから、バイナリ文字列と結合します。こちらも参照してください。&quot;エンコードしない場合は?</target>
        </trans-unit>
        <trans-unit id="cef4ef62c32e58e84f80436ec819bfd5a7afa02c" translate="yes" xml:space="preserve">
          <source>Be careful: qx(), system(), and some modules for calling external commands do a fork(), then wait() for the result. Thus, your signal handler will be called. Because wait() was already called by system() or qx(), the wait() in the signal handler will see no more zombies and will therefore block.</source>
          <target state="translated">注意してください:qx()、system()、そして外部コマンドを呼び出すためのいくつかのモジュールは fork()を行い、その後、結果を待つための wait()を行います。そのため、シグナルハンドラが呼び出されます。wait()は system()や qx()によって既に呼び出されていたので、シグナルハンドラの wait()はそれ以上のゾンビを見ないので、ブロックされてしまいます。</target>
        </trans-unit>
        <trans-unit id="02350f9e1a884f10cacbddf6be8d623a44b68fcb" translate="yes" xml:space="preserve">
          <source>Be consistent with existing modules.</source>
          <target state="translated">既存のモジュールとの整合性をとる。</target>
        </trans-unit>
        <trans-unit id="8f9f60dfc3f60d9409a16936419f8f9c34030221" translate="yes" xml:space="preserve">
          <source>Be consistent.</source>
          <target state="translated">一貫していること。</target>
        </trans-unit>
        <trans-unit id="0657b8fedf171a48206a6318d37358a77e53c6fb" translate="yes" xml:space="preserve">
          <source>Be descriptive (i.e. accurately describes the purpose of the module).</source>
          <target state="translated">記述的であること(すなわち、モジュールの目的を正確に説明すること)。</target>
        </trans-unit>
        <trans-unit id="4866ce84e5913e3bbf14d1ef419eb24f1d72a52e" translate="yes" xml:space="preserve">
          <source>Be it &lt;code&gt;Compress::Zlib&lt;/code&gt; , &lt;code&gt;Apache::Request&lt;/code&gt; or any extension that has no mention of Unicode in the manpage, you need to make sure that the UTF8 flag is stripped off. Note that at the time of this writing (January 2012) the mentioned modules are not UTF-8-aware. Please check the documentation to verify if this is still true.</source>
          <target state="translated">それは &lt;code&gt;Compress::Zlib&lt;/code&gt; 、 &lt;code&gt;Apache::Request&lt;/code&gt; やマニュアルページにUnicodeの言及を持っていない任意の拡張子、あなたはUTF8フラグが剥ぎ取られていることを確認する必要があります。この記事の執筆時点（2012年1月）では、上記のモジュールはUTF-8に対応していません。これがまだ当てはまるかどうかを確認するには、ドキュメントを確認してください。</target>
        </trans-unit>
        <trans-unit id="9583b4e268c09c5404dc953e2a7280e9a611066c" translate="yes" xml:space="preserve">
          <source>Be it &lt;code&gt;Compress::Zlib&lt;/code&gt;, &lt;code&gt;Apache::Request&lt;/code&gt; or any extension that has no mention of Unicode in the manpage, you need to make sure that the UTF8 flag is stripped off. Note that at the time of this writing (January 2012) the mentioned modules are not UTF-8-aware. Please check the documentation to verify if this is still true.</source>
          <target state="translated">それは &lt;code&gt;Compress::Zlib&lt;/code&gt; 、 &lt;code&gt;Apache::Request&lt;/code&gt; やマニュアルページにUnicodeの言及を持っていない任意の拡張子、あなたはUTF8フラグが剥ぎ取られていることを確認する必要があります。この記事の執筆時点（2012年1月）では、言及されているモジュールはUTF-8に対応していないことに注意してください。ドキュメントをチェックして、これがまだ当てはまるかどうかを確認してください。</target>
        </trans-unit>
        <trans-unit id="fec8bd9db93426cc5f677cbbc44d58f990b4ce4f" translate="yes" xml:space="preserve">
          <source>Be nice.</source>
          <target state="translated">いい子にしてね</target>
        </trans-unit>
        <trans-unit id="455d700825e4b9a7601c1ce54b47786ce81ebe18" translate="yes" xml:space="preserve">
          <source>Be sure not to use a bareword as the name of a signal handler, lest you inadvertently call it.</source>
          <target state="translated">誤って信号ハンドラの名前として bareword を使用しないように注意してください。</target>
        </trans-unit>
        <trans-unit id="adcfe790c3214b8902aa2d9bdbc7f166d3aa2497" translate="yes" xml:space="preserve">
          <source>Be sure that your yacc installation is in place including any necessary parser template files. If you have not already done so then be sure to:</source>
          <target state="translated">必要なパーサーテンプレートファイルを含めて、yaccのインストールが適切に行われていることを確認してください。もしまだ行っていなければ、必ず行ってください。</target>
        </trans-unit>
        <trans-unit id="7a2fea634f3d3c3b87d0ddfbb5348eeeda046aad" translate="yes" xml:space="preserve">
          <source>Be sure to adequately comment your code. While commenting every line is unnecessary, anything that takes advantage of side effects of operators, that creates changes that will be felt outside of the function being patched, or that others may find confusing should be documented. If you are going to err, it is better to err on the side of adding too many comments than too few.</source>
          <target state="translated">コードには適切なコメントをつけてください。すべての行にコメントをつけることは不要ですが、演算子の副作用を利用したり、パッチを適用している関数の外で変化を感じたり、他の人が混乱するようなことがあれば、文書化しておくべきです。もしエラーを起こすのであれば、コメント数が少なすぎるよりも、多すぎるコメントを追加しない方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="df103353e12184ad2bab2c528d00c711c155c484" translate="yes" xml:space="preserve">
          <source>Be sure to include the &lt;b&gt;exact&lt;/b&gt; error messages, if any. &quot;Perl gave an error&quot; is not an exact error message.</source>
          <target state="translated">&lt;b&gt;正確な&lt;/b&gt;エラーメッセージがある場合は、必ず含めてください。「Perlがエラーを出しました」は正確なエラーメッセージではありません。</target>
        </trans-unit>
        <trans-unit id="fb3f786d0833cb9684920951669ea14a5f8c452b" translate="yes" xml:space="preserve">
          <source>Be sure to read &lt;a href=&quot;#ENCODING&quot;&gt;&quot;ENCODING&quot;&lt;/a&gt; if your Pod contains non-ASCII characters.</source>
          <target state="translated">ポッドにASCII以外の文字が含まれている場合は、必ず&lt;a href=&quot;#ENCODING&quot;&gt;「ENCODING」&lt;/a&gt;をお読みください。</target>
        </trans-unit>
        <trans-unit id="b5cbd612657dfbf7a92d6606e16853c43b77addf" translate="yes" xml:space="preserve">
          <source>Be sure to read &lt;a href=&quot;#ENCODING&quot;&gt;ENCODING&lt;/a&gt; if your Pod contains non-ASCII characters.</source>
          <target state="translated">ポッドに非ASCII文字が含まれている場合は、必ず&lt;a href=&quot;#ENCODING&quot;&gt;エンコードを&lt;/a&gt;お読みください。</target>
        </trans-unit>
        <trans-unit id="2984603dd54138b13d352a1e3fd61b6408be6b9f" translate="yes" xml:space="preserve">
          <source>Be sure to read the instructions near the top of the makefiles carefully.</source>
          <target state="translated">makefileの上部近くにある説明書をよく読んでください。</target>
        </trans-unit>
        <trans-unit id="7f00ff2068b10342c9156aa44f6e62fb9656c3bb" translate="yes" xml:space="preserve">
          <source>Be sure to specify Perl version requirements both in Makefile.PL or Build.PL and with &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 5.6.1&lt;/code&gt; or similar. See the section on &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; of &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for details.</source>
          <target state="translated">Makefile.PLまたはBuild.PL中との両方でPerlのバージョン要件を指定してください &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 5.6.1&lt;/code&gt; または類似。詳細は&lt;a href=&quot;functions/require&quot;&gt;requireの&lt;/a&gt; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; の&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;に関するセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="395569931cbd630cae76e8ec72604be440821c6b" translate="yes" xml:space="preserve">
          <source>Be sure to specify Perl version requirements both in Makefile.PL or Build.PL and with &lt;code&gt;require 5.6.1&lt;/code&gt; or similar. See the section on &lt;code&gt;use VERSION&lt;/code&gt; of &lt;a href=&quot;perlfunc#require&quot;&gt;&quot;require&quot; in perlfunc&lt;/a&gt; for details.</source>
          <target state="translated">必ずMakefile.PLまたはBuild.PLの両方でPerlバージョン要件を指定し &lt;code&gt;require 5.6.1&lt;/code&gt; などを必要とします。上のセクションを参照してください &lt;code&gt;use VERSION&lt;/code&gt; の&lt;a href=&quot;perlfunc#require&quot;&gt;はperlfuncで「必要」&lt;/a&gt;詳細については、を。</target>
        </trans-unit>
        <trans-unit id="c733e8a30868a3838b1dfa41af03cf511ee097ca" translate="yes" xml:space="preserve">
          <source>Be sure to use a tar program compiled under Solaris (not SunOS 4.x) to extract the perl-5.x.x.tar.gz file. Do not use GNU tar compiled for SunOS4 on Solaris. (GNU tar compiled for Solaris should be fine.) When you run SunOS4 binaries on Solaris, the run-time system magically alters pathnames matching m#lib/locale# so that when tar tries to create lib/locale.pm, a file named lib/oldlocale.pm gets created instead. If you found this advice too late and used a SunOS4-compiled tar anyway, you must find the incorrectly renamed file and move it back to lib/locale.pm.</source>
          <target state="translated">ここでは必ず Solaris (SunOS 4.x ではない)でコンパイルされた tar プログラムを使用してください。SunOS4 用にコンパイルされた GNU tar を Solaris 上で使わないでください (Solaris 用にコンパイルされた GNU tar は問題ないはずです)。(Solaris 用にコンパイルされた GNU tar は問題ありません。)SunOS4 のバイナリを Solaris 上で実行すると、ランタイムシステムは m#lib/locale#にマッチするパス名を魔法のように変更し、tar が lib/locale.pm を作成しようとすると、代わりに lib/oldlocale.pm という名前のファイルが作成されるようにします。このアドバイスに気づくのが遅すぎて、SunOS4 でコンパイルされた tar を使っていた場合は、間違ってリネームされたファイルを見つけて、それを lib/locale.pm に戻さなければなりません。</target>
        </trans-unit>
        <trans-unit id="5d818ab86968387d2a89aaa4ecb39ab429064672" translate="yes" xml:space="preserve">
          <source>Be sure to use the libraries and modules shipped with the version being tested, not those that were already installed.</source>
          <target state="translated">すでにインストールされているライブラリやモジュールではなく、テストされるバージョンに同梱されているライブラリやモジュールを使用するようにしてください。</target>
        </trans-unit>
        <trans-unit id="e3d356b4e65052f33c752664cb97b29222d4870b" translate="yes" xml:space="preserve">
          <source>Be very careful with Perl operations that change the value of the variable. Appending something to the variable, for instance, might require reallocation of its storage, leaving you with a pointer into no-man's land.</source>
          <target state="translated">変数の値を変更するPerlの操作には十分注意してください。例えば、変数に何かを追加すると、ストレージの再割り当てが必要になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="a9df705eca9ff235f56efac76a8ae2aff600e09f" translate="yes" xml:space="preserve">
          <source>Be warned that neither creation nor deletion of files is guaranteed to be an atomic operation over NFS. That is, two processes might both successfully create or unlink the same file! Therefore O_EXCL isn't as exclusive as you might wish.</source>
          <target state="translated">ファイルの作成も削除も、NFS 上ではアトミックな操作であることが保証されていないことに注意してください。つまり、2 つのプロセスが同じファイルの作成やリンク解除に成功する可能性があるということです。そのため、O_EXCL は思ったほど排他的ではありません。</target>
        </trans-unit>
        <trans-unit id="15b58e5a1a4863b537d4c8fb01a3a9bfffd23c29" translate="yes" xml:space="preserve">
          <source>Be warned that proxying an &lt;code&gt;https&lt;/code&gt; connection opens you to the risk of a man-in-the-middle attack by the proxy server.</source>
          <target state="translated">&lt;code&gt;https&lt;/code&gt; 接続をプロキシすると、プロキシサーバーによるman-in-the-middle攻撃のリスクにさらされることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7184ad30ab6a73d32aaec035835bc55ad15b3389" translate="yes" xml:space="preserve">
          <source>Be warned that some formatters cannot reliably render characters outside 32-126; and many are able to handle 32-126 and 160-255, but nothing above 255.</source>
          <target state="translated">フォーマッタの中には32-126以外の文字を確実にレンダリングできないものがあり、多くは32-126と160-255は扱えますが、255以上は扱えないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="8235118c9cdc1cd037bd4ff9c8b6234c4eceb334" translate="yes" xml:space="preserve">
          <source>Be warned that this feature is considered experimental, and may be changed without notice.</source>
          <target state="translated">この機能は実験的なものであり、予告なく変更されることがありますのでご注意ください。</target>
        </trans-unit>
        <trans-unit id="f60dd616afaa8860904852bce46c16c4c9385db0" translate="yes" xml:space="preserve">
          <source>Be warned, though, that unlike regular expressions, if the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; template doesn't match the incoming data, Perl will scream and die.</source>
          <target state="translated">ただし、正規表現とは異なり、 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; テンプレートが受信データと一致しない場合、Perlは悲鳴を上げて死ぬことに注意してください。</target>
        </trans-unit>
        <trans-unit id="02d6d74dc9a4db2057c5683472b9fbbb7012f2b3" translate="yes" xml:space="preserve">
          <source>Be warned, though, that unlike regular expressions, if the &lt;code&gt;unpack&lt;/code&gt; template doesn't match the incoming data, Perl will scream and die.</source>
          <target state="translated">ただし、正規表現とは異なり、 &lt;code&gt;unpack&lt;/code&gt; テンプレートが受信データと一致しない場合、Perlは悲鳴を上げて死ぬことに注意してください。</target>
        </trans-unit>
        <trans-unit id="f34bea745032a10b52d62f12a9de185a88d00d76" translate="yes" xml:space="preserve">
          <source>Be warned: just as the C-preprocessor doesn't know C, the Debug filter doesn't know Perl. It can be fooled quite easily:</source>
          <target state="translated">注意:C プリプロセッサが C を知らないのと同様に、デバッグフィルタも Perl を知らないので注意してください。簡単に騙されてしまいます。</target>
        </trans-unit>
        <trans-unit id="29bff63d2a655090d41ce27755886c450bf1e989" translate="yes" xml:space="preserve">
          <source>BeOS is BeOS.</source>
          <target state="translated">BeOSはBeOSです。</target>
        </trans-unit>
        <trans-unit id="7127634cd20ce1300143c5a508c993ef4fdbd8f4" translate="yes" xml:space="preserve">
          <source>Because &quot;perlio.h&quot; is a thin layer (for efficiency) the semantics of these functions are somewhat dependent on the underlying implementation. Where these variations are understood they are noted below.</source>
          <target state="translated">perlio.h &quot;は(効率化のために)薄い層になっているため、これらの関数のセマンティクスは、基礎となる実装に多少依存します。これらの違いが理解できるところでは、以下に説明します。</target>
        </trans-unit>
        <trans-unit id="370f88e98782bfa7f114dbe532b100225210e150" translate="yes" xml:space="preserve">
          <source>Because 1 + 1 is 2, it prints:</source>
          <target state="translated">1+1は2なので、プリントします。</target>
        </trans-unit>
        <trans-unit id="8e172ead13ccd2d2e8aa5c2a8960bb8d1e75406d" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;#scalar-EXPR&quot;&gt;&lt;code&gt;scalar&lt;/code&gt;&lt;/a&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">&lt;a href=&quot;#scalar-EXPR&quot;&gt; &lt;code&gt;scalar&lt;/code&gt; &lt;/a&gt;は単項演算子であるため、誤ってEXPRに括弧で囲まれたリストを使用すると、これはスカラーコンマ式として動作し、voidコンテキストの最後の要素を除くすべてを評価し、スカラーコンテキストで評価された最後の要素を返します。これはめったにあなたが望むものではありません。</target>
        </trans-unit>
        <trans-unit id="f3b453ad82fa85092fb1368c3fb85257f0cedd1e" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">&lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt;はコンパイル時に有効になるため、コンパイルされるコードの通常のフロー制御を尊重しません。特に、条件文のfalseブランチ内に&lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt;を入れても、処理が妨げられることはありません。モジュールまたはプラグマを条件付きでロードするだけでよい場合、これは&lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;プラグマを使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="3ddac942d8eb120d517202681a1ab56648b51a75" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; is a global variable, be careful that analyzing an exception caught by &lt;code&gt;eval&lt;/code&gt; doesn't replace the reference in the global variable. It's easiest to make a local copy of the reference before any manipulations. Here's an example:</source>
          <target state="translated">ので&lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt;グローバル変数である、でキャッチ例外分析することに注意すること &lt;code&gt;eval&lt;/code&gt; グローバル変数内の参照を置き換えるものではありません。操作の前に、参照のローカルコピーを作成するのが最も簡単です。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="b63ce495f650d704c02d64d23b111efdfe40cd61" translate="yes" xml:space="preserve">
          <source>Because &lt;b&gt;perldoc&lt;/b&gt; does not run properly tainted, and is known to have security issues, when run as the superuser it will attempt to drop privileges by setting the effective and real IDs to nobody's or nouser's account, or -2 if unavailable. If it cannot relinquish its privileges, it will not run.</source>
          <target state="translated">ので&lt;b&gt;はperldocが&lt;/b&gt;適切に汚染を実行していない、およびセキュリティ上の問題を有することが知られているスーパーユーザーとして実行したとき、それは誰のかNOUSERの口座に効果的かつ現実のIDを設定することで、権限を削除しようと、あるいはだろう-2利用できない場合。特権を放棄できない場合は、実行されません。</target>
        </trans-unit>
        <trans-unit id="400d81a8582d02a7d364c167bb3655c111853cb4" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; trigger interpolation, you'll need to use something like &lt;code&gt;/\Quser\E\@\Qhost/&lt;/code&gt; to match them literally.</source>
          <target state="translated">ので &lt;code&gt;$&lt;/code&gt; または &lt;code&gt;@&lt;/code&gt; のようなトリガー補間、あなたが何かを使用する必要があります &lt;code&gt;/\Quser\E\@\Qhost/&lt;/code&gt; 文字通り、それらを一致させます。</target>
        </trans-unit>
        <trans-unit id="b667c475fa92312c7083687d2886a12150dc73b8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$sv&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when the &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; operator is applied to it, the transliteration won't actually execute and the program won't &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. This is different to how 5.8 and earlier versions behaved since the capture variables were READONLY variables then; now they'll just die when assigned to in the default engine.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 演算子を適用すると &lt;code&gt;$sv&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; であるため、文字変換は実際には実行されず、プログラムは &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ません。この場合、キャプチャ変数はREADONLY変数だったため、5.8以前のバージョンの動作とは異なります。これで、デフォルトのエンジンで割り当てられたときに、それらはただ死んでしまいます。</target>
        </trans-unit>
        <trans-unit id="6c984d748d72c5bb3b2196996f098ba27134cde9" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$sv&lt;/code&gt; is &lt;code&gt;undef&lt;/code&gt; when the &lt;code&gt;y///&lt;/code&gt; operator is applied to it, the transliteration won't actually execute and the program won't &lt;code&gt;die&lt;/code&gt;. This is different to how 5.8 and earlier versions behaved since the capture variables were READONLY variables then; now they'll just die when assigned to in the default engine.</source>
          <target state="translated">ので &lt;code&gt;$sv&lt;/code&gt; ある &lt;code&gt;undef&lt;/code&gt; をするとき &lt;code&gt;y///&lt;/code&gt; 演算子がそれに適用され、音訳が実際に実行されず、プログラムはありません &lt;code&gt;die&lt;/code&gt; 。これは、キャプチャ変数がREADONLY変数であったため、5.8以前のバージョンの動作とは異なります。これで、デフォルトのエンジンに割り当てられたときに死ぬだけです。</target>
        </trans-unit>
        <trans-unit id="b914e32b809fa7c48d9ec627188d82ebed09a33b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt;. The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt;s from the input list.</source>
          <target state="translated">いずれかのオペランドが &lt;code&gt;NaN&lt;/code&gt; （数値ではない）の場合、 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; は&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; を&lt;/a&gt;返すため &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; ような比較関数を使用してソートする場合は、 &lt;code&gt;NaN&lt;/code&gt; を含む可能性のあるリストに注意してください。次の例では、という利点を取る &lt;code&gt;NaN != NaN&lt;/code&gt; どんな排除するため &lt;code&gt;NaN&lt;/code&gt; 入力リストから秒。</target>
        </trans-unit>
        <trans-unit id="5addc5234910932f591ed79ef1118cfac8717e21" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt; . The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt; s from the input list.</source>
          <target state="translated">いずれかのオペランドが &lt;code&gt;NaN&lt;/code&gt; （非数）の場合、 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返すため &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; ような比較関数でソートするときは、 &lt;code&gt;NaN&lt;/code&gt; を含む可能性のあるリストに注意してください。次の例では、という利点を取る &lt;code&gt;NaN != NaN&lt;/code&gt; どんな排除するため &lt;code&gt;NaN&lt;/code&gt; 入力リストから秒。</target>
        </trans-unit>
        <trans-unit id="dbfd747a0cfe35cb8ad11b2926956f99d4f77a54" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt; . The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt; s from the input list.</source>
          <target state="translated">いずれかのオペランドが &lt;code&gt;NaN&lt;/code&gt; （非数）の場合、 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返すため &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; ような比較関数でソートするときは、 &lt;code&gt;NaN&lt;/code&gt; を含む可能性のあるリストに注意してください。次の例では、という利点を取る &lt;code&gt;NaN != NaN&lt;/code&gt; どんな排除するため &lt;code&gt;NaN&lt;/code&gt; 入力リストから秒。</target>
        </trans-unit>
        <trans-unit id="89d0f8e67a21f5d12b3d2f9f3bbfa73cf7cb9115" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.&lt;/code&gt; is special in regular expressions, and can match any single character, the regex &lt;code&gt;P.&lt;/code&gt; here has matched the &amp;lt;Pl&amp;gt; in the original string.</source>
          <target state="translated">なぜなら &lt;code&gt;.&lt;/code&gt; 正規表現では特別であり、任意の1文字に一致できます &lt;code&gt;P.&lt;/code&gt; 正規表現Pは、元の文字列の&amp;lt;Pl&amp;gt;に一致しています。</target>
        </trans-unit>
        <trans-unit id="19a20b9f3a218df5a7c84d8e40e3cdca6928cac3" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.&lt;/code&gt; was in use as a directory separator and filenames could not be assumed to be unique after 10 characters, Acorn implemented the C compiler to strip the trailing &lt;code&gt;.c&lt;/code&gt;&lt;code&gt;.h&lt;/code&gt;&lt;code&gt;.s&lt;/code&gt; and &lt;code&gt;.o&lt;/code&gt; suffix from filenames specified in source code and store the respective files in subdirectories named after the suffix. Hence files are translated:</source>
          <target state="translated">なぜなら &lt;code&gt;.&lt;/code&gt; ディレクトリ区切り文字として使用されていて、ファイル名は10文字の後に一意であると想定できませんでした。AcornはCコンパイラを実装して、ソースコードで指定されたファイル名から末尾の &lt;code&gt;.c&lt;/code&gt; &lt;code&gt;.h&lt;/code&gt; &lt;code&gt;.s&lt;/code&gt; および &lt;code&gt;.o&lt;/code&gt; サフィックスを取り除き、それぞれのファイルを保存しましたサフィックスにちなんで名付けられたサブディレクトリ内。したがって、ファイルは翻訳されます。</target>
        </trans-unit>
        <trans-unit id="daf7ef166b9a7929b988f6a60b2c3afc2523b46d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; is a run-time operator, it gets executed each time through a loop. Consequently, it's more efficient to localize your variables outside the loop.</source>
          <target state="translated">ので &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 、実行時のオペレータである、それはループを通るたびに実行されます。したがって、ループの外で変数をローカライズする方が効率的です。</target>
        </trans-unit>
        <trans-unit id="2f69348654d069c347e7c5732088634fa13b4fd6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">ので &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 単項演算子であるあなたが誤っEXPRのために括弧付きのリストを使用している場合、スカラコンマ式のように、この振る舞いは、無効コンテキスト内のすべてのが、最後の要素を評価し、スカラーコンテキストで評価最後の要素を返します。これはめったにあなたが望むものではありません。</target>
        </trans-unit>
        <trans-unit id="f2af4d959eb62b1a9bf83d9e5254d41aa11be74b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; はコンパイル時に有効になるため、コンパイルされるコードの通常のフロー制御は考慮されません。特に、条件のfalseブランチ内に &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; を置いても、処理が妨げられることはありません。モジュールまたはプラグマを条件付きでのみロードする必要がある場合、これは&lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;プラグマを使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="4bb9a434db491939507421e019d5c81a08c7de9d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">ので &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; 単項演算子であるあなたが誤っEXPRのために括弧付きのリストを使用している場合、スカラコンマ式のように、この振る舞いは、無効コンテキスト内のすべてのが、最後の要素を評価し、スカラーコンテキストで評価最後の要素を返します。これはめったにあなたが望むものではありません。</target>
        </trans-unit>
        <trans-unit id="c409d5f2e3bc5948e94957a82aeec5c28556f99d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; はコンパイル時に有効になるため、コンパイルされるコードの通常のフロー制御は考慮されません。特に、条件のfalseブランチ内に &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; を置いても、処理が妨げられることはありません。モジュールまたはプラグマを条件付きでのみロードする必要がある場合、これは&lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt;プラグマを使用して実行できます。</target>
        </trans-unit>
        <trans-unit id="3f563a9178b31c7b0b34b9e11ab4a6bde66fbd45" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;DESTROY&lt;/code&gt; methods can be called at any time, you should localize any global status variables that might be set by anything you do in your &lt;code&gt;DESTROY&lt;/code&gt; method. If you are in doubt about a particular status variable, it doesn't hurt to localize it. There are five global status variables, and the safest way is to localize all five of them:</source>
          <target state="translated">ので &lt;code&gt;DESTROY&lt;/code&gt; メソッドはいつでも呼び出すことができ、あなたはあなたにあなたが何によって設定されることがあります任意のグローバルステータス変数ローカライズすべき &lt;code&gt;DESTROY&lt;/code&gt; メソッドを。特定のステータス変数について疑問がある場合でも、それをローカライズしても問題はありません。5つのグローバルステータス変数があり、最も安全な方法は、5つすべてをローカライズすることです。</target>
        </trans-unit>
        <trans-unit id="f7ea34c50bf47a71dd29a5e22af22a7376e9666b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;DESTROY&lt;/code&gt; methods can be called at any time, you should localize any global variables you might update in your &lt;code&gt;DESTROY&lt;/code&gt; . In particular, if you use &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; you should localize &lt;code&gt;$@&lt;/code&gt; , and if you use &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or backticks you should localize &lt;code&gt;$?&lt;/code&gt; .</source>
          <target state="translated">ので &lt;code&gt;DESTROY&lt;/code&gt; メソッドはいつでも呼び出すことができ、あなたはあなたに更新する可能性のあるグローバル変数ローカライズする必要があり &lt;code&gt;DESTROY&lt;/code&gt; を。特に、 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; を使用する場合は &lt;code&gt;$@&lt;/code&gt; をローカライズし、 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; またはバックティックを使用する場合は &lt;code&gt;$?&lt;/code&gt; をローカライズする必要があります。。</target>
        </trans-unit>
        <trans-unit id="1b1a7e8c9b3926d0057e1f91a59eec1bca6ac0fe" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PERL5LIB&lt;/code&gt; is often used during testing to add build directories to &lt;code&gt;@INC&lt;/code&gt; prove passes the names of any directories found in &lt;code&gt;PERL5LIB&lt;/code&gt; as -I switches. The net effect of this is that &lt;code&gt;PERL5LIB&lt;/code&gt; is honoured even when prove is run in taint mode.</source>
          <target state="translated">ので &lt;code&gt;PERL5LIB&lt;/code&gt; には、多くの場合に、ビルドディレクトリを追加するために、テスト中に使用されている &lt;code&gt;@INC&lt;/code&gt; で見つかった任意のディレクトリの名前渡し証明 &lt;code&gt;PERL5LIB&lt;/code&gt; -Iスイッチとしては。これの正味の効果は、proveが汚染モードで実行されている場合でも、 &lt;code&gt;PERL5LIB&lt;/code&gt; が受け入れられることです。</target>
        </trans-unit>
        <trans-unit id="8d8b86b2aa791fa81fa4a800514b6911cd4cea09" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PERL5LIB&lt;/code&gt; is often used during testing to add build directories to &lt;code&gt;@INC&lt;/code&gt;&lt;code&gt;Test::Harness&lt;/code&gt; passes the names of any directories found in &lt;code&gt;PERL5LIB&lt;/code&gt; as -I switches. The net effect of this is that &lt;code&gt;PERL5LIB&lt;/code&gt; is honoured even in taint mode.</source>
          <target state="translated">ので &lt;code&gt;PERL5LIB&lt;/code&gt; が、多くの場合に、ビルドディレクトリを追加するために、テスト中に使用されている &lt;code&gt;@INC&lt;/code&gt; &lt;code&gt;Test::Harness&lt;/code&gt; 任意のディレクトリの名前がで見つかっ渡し &lt;code&gt;PERL5LIB&lt;/code&gt; -Iスイッチとして。これの正味の効果は、汚染モードでも &lt;code&gt;PERL5LIB&lt;/code&gt; が尊重されることです。</target>
        </trans-unit>
        <trans-unit id="528ed40a74786c9daeb579970bad493df64c4a75" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PL_restartop&lt;/code&gt; is non-null, &lt;code&gt;run_body&lt;/code&gt; starts a new runops loop and execution continues.</source>
          <target state="translated">ので &lt;code&gt;PL_restartop&lt;/code&gt; が非nullで、 &lt;code&gt;run_body&lt;/code&gt; は新しいrunopsループを開始し、実行が継続されます。</target>
        </trans-unit>
        <trans-unit id="add12825d3665c5532bcf2a78d2469e31a8a7e9f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;STORABLE_attach&lt;/code&gt; is passed the class (rather than an object), it also returns the object directly, rather than modifying the passed object.</source>
          <target state="translated">&lt;code&gt;STORABLE_attach&lt;/code&gt; には（オブジェクトではなく）クラスが渡されるため、渡されたオブジェクトを変更するのではなく、オブジェクトを直接返します。</target>
        </trans-unit>
        <trans-unit id="65e2bf1b173528f8a073f03b46510698c20426ce" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;local&lt;/code&gt; is a run-time operator, it gets executed each time through a loop. Consequently, it's more efficient to localize your variables outside the loop.</source>
          <target state="translated">ので &lt;code&gt;local&lt;/code&gt; 、実行時のオペレータである、それはループを通るたびに実行されます。したがって、変数をループの外側にローカライズする方が効率的です。</target>
        </trans-unit>
        <trans-unit id="308ec40cfa786d712d62a1e76733c4c3028b3e68" translate="yes" xml:space="preserve">
          <source>Because Acorns use ASCII with newlines (&lt;code&gt;\n&lt;/code&gt; ) in text files as &lt;code&gt;\012&lt;/code&gt; like Unix, and because Unix filename emulation is turned on by default, most simple scripts will probably work &quot;out of the box&quot;. The native filesystem is modular, and individual filesystems are free to be case-sensitive or insensitive, and are usually case-preserving. Some native filesystems have name length limits, which file and directory names are silently truncated to fit. Scripts should be aware that the standard filesystem currently has a name length limit of &lt;b&gt;10&lt;/b&gt; characters, with up to 77 items in a directory, but other filesystems may not impose such limitations.</source>
          <target state="translated">Acornsは、ASCIIをテキストファイル内の改行（ &lt;code&gt;\n&lt;/code&gt; ）とともにUNIXのような &lt;code&gt;\012&lt;/code&gt; として使用し、Unixファイル名エミュレーションはデフォルトでオンになっているため、ほとんどの単純なスクリプトは「そのまま」機能します。ネイティブファイルシステムはモジュール式であり、個々のファイルシステムは大文字と小文字を区別するか区別しないかは自由で、通常は大文字と小文字を区別します。一部のネイティブファイルシステムには名前の長さの制限があり、ファイル名とディレクトリ名は収まるように自動的に切り捨てられます。スクリプトは、標準のファイルシステムの名前の長さが&lt;b&gt;10&lt;/b&gt;文字に制限されており、ディレクトリ内に最大77個のアイテムがあることを認識しておく必要がありますが、他のファイルシステムではこのような制限を課さない場合があります。</target>
        </trans-unit>
        <trans-unit id="28c382ede78c908c2143af19dbf455bab6188b9c" translate="yes" xml:space="preserve">
          <source>Because Acorns use ASCII with newlines (&lt;code&gt;\n&lt;/code&gt;) in text files as &lt;code&gt;\012&lt;/code&gt; like Unix, and because Unix filename emulation is turned on by default, most simple scripts will probably work &quot;out of the box&quot;. The native filesystem is modular, and individual filesystems are free to be case-sensitive or insensitive, and are usually case-preserving. Some native filesystems have name length limits, which file and directory names are silently truncated to fit. Scripts should be aware that the standard filesystem currently has a name length limit of &lt;b&gt;10&lt;/b&gt; characters, with up to 77 items in a directory, but other filesystems may not impose such limitations.</source>
          <target state="translated">AcornsはUnixのようにテキストファイルの改行（ &lt;code&gt;\n&lt;/code&gt; ）でASCIIを &lt;code&gt;\012&lt;/code&gt; として使用し、Unixファイル名のエミュレーションはデフォルトでオンになっているため、ほとんどの単純なスクリプトはおそらく「箱から出して」動作します。ネイティブファイルシステムはモジュール式であり、個々のファイルシステムでは大文字と小文字が区別されたり、区別されなかったりすることがあり、通常は大文字と小文字が区別されます。一部のネイティブファイルシステムには名前の長さの制限があり、ファイル名とディレクトリ名はそれに合わせてサイレントに切り捨てられます。スクリプトは、標準のファイルシステムには現在&lt;b&gt;10&lt;/b&gt;文字の名前の長さの制限があり、ディレクトリには最大77の項目があることに注意する必要がありますが、他のファイルシステムではそのような制限が課されない場合があります。</target>
        </trans-unit>
        <trans-unit id="828cb90cec8613e5d83ab546b1c59479cecb4072" translate="yes" xml:space="preserve">
          <source>Because C has no builtin function for integer exponentiation, let's make Perl's ** operator available to it (this is less useful than it sounds, because Perl implements ** with C's</source>
          <target state="translated">C には整数の指数計算のための関数が組み込まれていないので、Perl の **演算子を利用できるようにしてみましょう(Perl は C の</target>
        </trans-unit>
        <trans-unit id="9459aa14a3cec514837284733b6c7f9c5dcb8910" translate="yes" xml:space="preserve">
          <source>Because Perl allows you to use barewords for package names and subroutine names, it sometimes interprets a bareword's meaning incorrectly. For example, the construct &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; can be interpreted as either &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; or &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; . In English, that second interpretation reads as &quot;call a subroutine named Class(), then call new() as a method on the return value of Class()&quot;. If there is a subroutine named &lt;code&gt;Class()&lt;/code&gt; in the current namespace, Perl will always interpret &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; as the second alternative: a call to &lt;code&gt;new()&lt;/code&gt; on the object returned by a call to &lt;code&gt;Class()&lt;/code&gt;</source>
          <target state="translated">Perlでは、パッケージ名とサブルーチン名にベアワードを使用できるため、ベアワードの意味が誤って解釈されることがあります。たとえば、 &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; は &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; または &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; として解釈できます。英語では、その2番目の解釈は「Class（）という名前のサブルーチンを呼び出してから、Class（）の戻り値のメソッドとしてnew（）を呼び出す」と解釈します。名前のサブルーチンがある場合は &lt;code&gt;Class()&lt;/code&gt; 現在の名前空間では、Perlは常に解釈する &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; 第二の代替として：への呼び出し &lt;code&gt;new()&lt;/code&gt; の呼び出しによって返されるオブジェクトの &lt;code&gt;Class()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0ebaa0b26d8e2869e78f420c4e273d09ec93726" translate="yes" xml:space="preserve">
          <source>Because Perl allows you to use barewords for package names and subroutine names, it sometimes interprets a bareword's meaning incorrectly. For example, the construct &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; can be interpreted as either &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; or &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt;. In English, that second interpretation reads as &quot;call a subroutine named Class(), then call new() as a method on the return value of Class()&quot;. If there is a subroutine named &lt;code&gt;Class()&lt;/code&gt; in the current namespace, Perl will always interpret &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; as the second alternative: a call to &lt;code&gt;new()&lt;/code&gt; on the object returned by a call to &lt;code&gt;Class()&lt;/code&gt;</source>
          <target state="translated">Perlではパッケージ名とサブルーチン名にベアワードを使用できるため、ベアワードの意味を誤って解釈することがあります。たとえば、構成 &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; は、 &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; または &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; のいずれかとして解釈できます。英語では、その2番目の解釈は、「Class（）という名前のサブルーチンを呼び出してから、Class（）の戻り値のメソッドとしてnew（）を呼び出す」と読みます。名前のサブルーチンがある場合は &lt;code&gt;Class()&lt;/code&gt; 現在の名前空間では、Perlは常に解釈する &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; 第二の代替として：への呼び出し &lt;code&gt;new()&lt;/code&gt; の呼び出しによって返されるオブジェクトの &lt;code&gt;Class()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aadc88ee4df674055a8e46229f25dab587fc29ec" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;../overload&quot;&gt;overload&lt;/a&gt; for details about that.</source>
          <target state="translated">Perlはキャッチされていない例外メッセージを表示する前に文字列化するため、例外オブジェクトに対する文字列化操作をオーバーロードする必要があるでしょう。詳細については、&lt;a href=&quot;../overload&quot;&gt;オーバーロード&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e1c5024f83c23d4c6dafd0e63d9f2e92824de07b" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; for details about that.</source>
          <target state="translated">Perlはキャッチされていない例外メッセージを表示する前に文字列化するため、例外オブジェクトに対する文字列化操作をオーバーロードする必要があるでしょう。詳細については、&lt;a href=&quot;overload&quot;&gt;オーバーロード&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="451d2525676f60927dbbc662f71037a75004b879" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; for details about that. The stringified message should be non-empty, and should end in a newline, in order to fit in with the treatment of string exceptions. Also, because an exception object reference cannot be stringified without destroying it, Perl doesn't attempt to append location or other information to a reference exception. If you want location information with a complex exception object, you'll have to arrange to put the location information into the object yourself.</source>
          <target state="translated">Perlは、キャッチされなかった例外メッセージを表示する前に文字列化するため、例外オブジェクトに対する文字列化操作をオーバーロードすることをお勧めします。詳細については、&lt;a href=&quot;overload&quot;&gt;オーバーロード&lt;/a&gt;を参照してください。文字列例外の処理に適合するために、文字列化されたメッセージは空ではなく、改行で終了する必要があります。また、例外オブジェクト参照は破棄せずに文字列化できないため、Perlは場所やその他の情報を参照例外に追加しようとはしません。複雑な例外オブジェクトを含む位置情報が必要な場合は、位置情報をオブジェクトに自分で配置するように調整する必要があります。</target>
        </trans-unit>
        <trans-unit id="2faaff7512cd20cbdff5d0e25efe8bfe139f7156" translate="yes" xml:space="preserve">
          <source>Because Perl uses doubles (or long doubles, if configured) internally for all numeric calculation, converting from double into float and thence to double again loses precision, so &lt;code&gt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&lt;/code&gt;) will not in general equal $foo.</source>
          <target state="translated">Perlはすべての数値計算に内部的にdouble（または構成されている場合はlong double）を使用するため、doubleからfloatに変換すると、再びdoubleに精度が失われるため、 &lt;code&gt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&lt;/code&gt; ）は一般に$ fooと同じです。</target>
        </trans-unit>
        <trans-unit id="398f8b38f72125ad882bed6f196a0775e260d2ad" translate="yes" xml:space="preserve">
          <source>Because UTF-8 is one of Perl's internal formats, you can often just skip the encoding or decoding step, and manipulate the UTF8 flag directly.</source>
          <target state="translated">UTF-8 は Perl の内部フォーマットの一つなので、エンコーディングやデコーディングのステップをスキップして、UTF8 フラグを直接操作することができます。</target>
        </trans-unit>
        <trans-unit id="6847617d71c84ec40d27c1365086ed8c20f1449c" translate="yes" xml:space="preserve">
          <source>Because UTF-EBCDIC is so similar to UTF-8, the differences are mostly hidden from you; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; (and NOT something like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utfebcdic&lt;/code&gt; ) declares the the script is in the platform's &quot;native&quot; 8-bit encoding of Unicode. (Similarly for the &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; layer.)</source>
          <target state="translated">UTF-EBCDICはUTF-8に非常に似ているため、その違いはほとんどユーザーには見えません。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; （および &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utfebcdic&lt;/code&gt; のようなものではない）は、スクリプトがプラットフォームの「ネイティブ」8ビットエンコーディングのUnicodeであることを宣言します。（ &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; レイヤーも同様です。）</target>
        </trans-unit>
        <trans-unit id="f78470b23c3e4057a6f3bfa3fb579763a7c89c67" translate="yes" xml:space="preserve">
          <source>Because UTF-EBCDIC is so similar to UTF-8, the differences are mostly hidden from you; &lt;code&gt;use utf8&lt;/code&gt; (and NOT something like &lt;code&gt;use utfebcdic&lt;/code&gt;) declares the script is in the platform's &quot;native&quot; 8-bit encoding of Unicode. (Similarly for the &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; layer.)</source>
          <target state="translated">UTF-EBCDICはUTF-8に非常に似ているため、違いはほとんど隠されています。 &lt;code&gt;use utf8&lt;/code&gt; （ &lt;code&gt;use utfebcdic&lt;/code&gt; のようなものではありません）は、スクリプトがプラットフォームの「ネイティブ」な8ビットUnicodeエンコーディングであることを宣言します。（ &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; レイヤーの場合も同様です。）</target>
        </trans-unit>
        <trans-unit id="237849b1b007b545cf9244e10de8226da0ca3773" translate="yes" xml:space="preserve">
          <source>Because VMS's exit codes are much, much different than the rest of the universe, and perl does horrible mangling to them that gets in my way, it works like this on VMS.</source>
          <target state="translated">VMS の終了コードは他の宇宙のものとはかなり違っていて、Perl は私の邪魔になるようなひどいマングリングをしているので、VMS ではこのように動作しています。</target>
        </trans-unit>
        <trans-unit id="815d9b38e08d4ff6dad9bd30fba64b1ec6e8aeb8" translate="yes" xml:space="preserve">
          <source>Because XS modules require re-linking of the perl binary, you need both the perl binary distribution and the perl source distribution to build an XS extension module. In addition, you will have to have built your perl binary from the source distribution so that all of the components of the perl binary are available for the required link step.</source>
          <target state="translated">XSモジュールはperlバイナリの再リンクが必要なので、XS拡張モジュールを構築するには、perlバイナリとperlソースの両方が必要です。さらに、必要なリンクステップに必要な perl バイナリのすべてのコンポーネントが利用できるように、ソース・ディストリビューションから perl バイナリをビルドしておく必要があります。</target>
        </trans-unit>
        <trans-unit id="b57c6e3153bc9c89950406d1bdb5e4a01632a292" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; match doesn't reset the offset, the return from &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; won't change either in this case. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; 一致に失敗してもオフセットはリセットされないため、この場合も &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; からの戻り値は変わりません。&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;と&lt;a href=&quot;perlop&quot;&gt;perlopを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="aac46af0a65c30c1278fb04116da06849260131d" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;&lt;a href=&quot;m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; match doesn't reset the offset, the return from &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; won't change either in this case. See &lt;a href=&quot;../perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; 一致に失敗してもオフセットはリセットされないため、この場合も &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; からの戻り値は変わりません。&lt;a href=&quot;../perlre&quot;&gt;perlre&lt;/a&gt;と&lt;a href=&quot;../perlop&quot;&gt;perlopを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f7ae901f4727ecaa2d777b8bd8dde60ff479daae" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;m//gc&lt;/code&gt; match doesn't reset the offset, the return from &lt;a href=&quot;#pos-SCALAR&quot;&gt;&lt;code&gt;pos&lt;/code&gt;&lt;/a&gt; won't change either in this case. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;m//gc&lt;/code&gt; 一致に失敗してもオフセットはリセットされないため、この場合も&lt;a href=&quot;#pos-SCALAR&quot;&gt; &lt;code&gt;pos&lt;/code&gt; &lt;/a&gt;からの戻りは変更されません。&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;および&lt;a href=&quot;perlop&quot;&gt;perlopを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9eb2a05168485f04f9e352bc656013c7106c3b67" translate="yes" xml:space="preserve">
          <source>Because a list of potential candidates is returned, the &lt;code&gt;while&lt;/code&gt; loop tries each in turn until it finds one that succeeds both the socket() and connect() calls.</source>
          <target state="translated">潜在的な候補のリストが返されるので、 &lt;code&gt;while&lt;/code&gt; ループは、socket（）呼び出しとconnect（）呼び出しの両方に成功する候補が見つかるまで、順番に試行します。</target>
        </trans-unit>
        <trans-unit id="93bb95979fc3bb902bf7566626913de80d560dcc" translate="yes" xml:space="preserve">
          <source>Because a name correction may be added in future Unicode releases, the name that &lt;code&gt;viacode&lt;/code&gt; returns may change as a result. This is a rare event, but it does happen.</source>
          <target state="translated">名前の修正は将来のUnicodeリリースで追加される可能性があるため、 &lt;code&gt;viacode&lt;/code&gt; が返す名前は結果として変更される可能性があります。これはまれなイベントですが、発生します。</target>
        </trans-unit>
        <trans-unit id="284e0db6a72cf3c4c7c4890513562109eb2a9995" translate="yes" xml:space="preserve">
          <source>Because a period is a metacharacter, it needs to be escaped to match as an ordinary period. Because, for example, &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; are sets of characters, it is incorrect to think of &lt;code&gt;[^\d\w]&lt;/code&gt; as &lt;code&gt;[\D\W]&lt;/code&gt; ; in fact &lt;code&gt;[^\d\w]&lt;/code&gt; is the same as &lt;code&gt;[^\w]&lt;/code&gt;, which is the same as &lt;code&gt;[\W]&lt;/code&gt; . Think DeMorgan's laws.</source>
          <target state="translated">ピリオドはメタ文字であるため、通常のピリオドと一致するようにエスケープする必要があります。たとえば、 &lt;code&gt;\d&lt;/code&gt; と &lt;code&gt;\w&lt;/code&gt; は文字のセットであるため、 &lt;code&gt;[^\d\w]&lt;/code&gt; を &lt;code&gt;[\D\W]&lt;/code&gt; と考えるのは誤りです。実際、 &lt;code&gt;[^\d\w]&lt;/code&gt; は &lt;code&gt;[^\w]&lt;/code&gt; と同じで、 &lt;code&gt;[\W]&lt;/code&gt; と同じです。DeMorganの法則を考えてみてください。</target>
        </trans-unit>
        <trans-unit id="7b8b1120df9a594afd2813233aa665ec7f417ba1" translate="yes" xml:space="preserve">
          <source>Because a period is a metacharacter, it needs to be escaped to match as an ordinary period. Because, for example, &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; are sets of characters, it is incorrect to think of &lt;code&gt;[^\d\w]&lt;/code&gt; as &lt;code&gt;[\D\W]&lt;/code&gt;; in fact &lt;code&gt;[^\d\w]&lt;/code&gt; is the same as &lt;code&gt;[^\w]&lt;/code&gt;, which is the same as &lt;code&gt;[\W]&lt;/code&gt;. Think DeMorgan's laws.</source>
          <target state="translated">ピリオドはメタ文字であるため、通常のピリオドと一致させるにはエスケープする必要があります。たとえば、 &lt;code&gt;\d&lt;/code&gt; と &lt;code&gt;\w&lt;/code&gt; は文字のセットであるため、 &lt;code&gt;[^\d\w]&lt;/code&gt; を &lt;code&gt;[\D\W]&lt;/code&gt; と考えるのは誤りです。実際、 &lt;code&gt;[^\d\w]&lt;/code&gt; は &lt;code&gt;[^\w]&lt;/code&gt; と同じであり、 &lt;code&gt;[\W]&lt;/code&gt; と同じです。ド・モルガンの法則を考えてください。</target>
        </trans-unit>
        <trans-unit id="4df556755141c60db4ee1a86c658450735dbe881" translate="yes" xml:space="preserve">
          <source>Because a url like &lt;code&gt;http://myrepo.example.com/&lt;/code&gt; is ambiguous as to type, producers should provide a &lt;code&gt;type&lt;/code&gt; whenever a &lt;code&gt;url&lt;/code&gt; key is given. The &lt;code&gt;type&lt;/code&gt; field should be the name of the most common program used to work with the repository, e.g. &lt;code&gt;git&lt;/code&gt;, &lt;code&gt;svn&lt;/code&gt;, &lt;code&gt;cvs&lt;/code&gt;, &lt;code&gt;darcs&lt;/code&gt;, &lt;code&gt;bzr&lt;/code&gt; or &lt;code&gt;hg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;http://myrepo.example.com/&lt;/code&gt; のようなURLはタイプに関してあいまいであるため、プロデューサーは &lt;code&gt;url&lt;/code&gt; キーが指定されるたびに &lt;code&gt;type&lt;/code&gt; を提供する必要があります。 &lt;code&gt;type&lt;/code&gt; フィールドは、リポジトリ、例えばとの仕事に使用される最も一般的なプログラムの名前でなければなりません &lt;code&gt;git&lt;/code&gt; の、 &lt;code&gt;svn&lt;/code&gt; 、 &lt;code&gt;cvs&lt;/code&gt; 、 &lt;code&gt;darcs&lt;/code&gt; の、 &lt;code&gt;bzr&lt;/code&gt; または &lt;code&gt;hg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="934c60da6f18a9def8d944b8bcb6ee8755c35fe6" translate="yes" xml:space="preserve">
          <source>Because access() does not invoke stat() (at least not in a way visible to Perl), &lt;b&gt;the stat result cache &quot;_&quot; is not set&lt;/b&gt;. This means that the outcome of the following two tests is different. The first has the stat bits of</source>
          <target state="translated">access（）はstat（）を呼び出さないため（少なくともPerlから見える方法で&lt;b&gt;は&lt;/b&gt;）、&lt;b&gt;統計結果キャッシュ &quot;_&quot;は設定されません&lt;/b&gt;。つまり、次の2つのテストの結果は異なります。1つ目の統計ビットは</target>
        </trans-unit>
        <trans-unit id="390a39256a176624bc85b17cecc4ce28e0fc7e67" translate="yes" xml:space="preserve">
          <source>Because assignment of a reference to a typeglob creates an alias, this can be used to create what is effectively a local function, or at least, a local alias.</source>
          <target state="translated">タイプグローブへの参照を代入するとエイリアスが作成されるので、これを使用して実質的にローカルな関数、あるいは少なくともローカルなエイリアスを作成することができます。</target>
        </trans-unit>
        <trans-unit id="0fe40d9c5df21e57c6ec455bae627177153c51cf" translate="yes" xml:space="preserve">
          <source>Because backticks do not affect standard error, use shell file descriptor syntax (assuming the shell supports this) if you care to address this. To capture a command's STDERR and STDOUT together:</source>
          <target state="translated">バックロックは標準エラーには影響しないので、これに対処したい場合は、シェルファイル記述子構文を使用してください(シェルがこれをサポートしていると仮定して)。コマンドのSTDERRとSTDOUTを一緒にキャプチャするには</target>
        </trans-unit>
        <trans-unit id="58a3a4b137a2ac3042f5ce6d5ed31ccf52919b18" translate="yes" xml:space="preserve">
          <source>Because both CRLF and LF end in LF, the input record separator can be set to LF and any CR stripped later. Better to write:</source>
          <target state="translated">CRLFもLFもLFで終わるので、入力レコードのセパレータをLFに設定して、後からCRを剥ぎ取ることができます。書いた方が良い。</target>
        </trans-unit>
        <trans-unit id="a49e08801e09e4ade1a0feed4948dfc00925efc8" translate="yes" xml:space="preserve">
          <source>Because curly brackets (braces) are used for several other things including BLOCKs, you may occasionally have to disambiguate braces at the beginning of a statement by putting a &lt;code&gt;+&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in front so that Perl realizes the opening brace isn't starting a BLOCK. The economy and mnemonic value of using curlies is deemed worth this occasional extra hassle.</source>
          <target state="translated">中かっこ（中かっこ）は、BLOCKを含む他のいくつかのものに使用されるため、ステートメントの先頭で &lt;code&gt;+&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; を前に置くことにより、中かっこを明確にする必要がある場合があります。。カーリーを使用することの経済的および記憶的価値は、この時折の余分な面倒の価値があると見なされます。</target>
        </trans-unit>
        <trans-unit id="06e52ad8990a21a081873c75e0650e648002cb3f" translate="yes" xml:space="preserve">
          <source>Because curly brackets (braces) are used for several other things including BLOCKs, you may occasionally have to disambiguate braces at the beginning of a statement by putting a &lt;code&gt;+&lt;/code&gt; or a &lt;code&gt;return&lt;/code&gt; in front so that Perl realizes the opening brace isn't starting a BLOCK. The economy and mnemonic value of using curlies is deemed worth this occasional extra hassle.</source>
          <target state="translated">中括弧（中括弧）はBLOCKを含む他のいくつかのものに使用されるため、Perlが開始中括弧がブロックを開始していないことを認識できるように、ステートメントの先頭で &lt;code&gt;+&lt;/code&gt; または &lt;code&gt;return&lt;/code&gt; を前に置いて中括弧を明確にする必要がある場合があります。。カーリーを使用することの経済性とニーモニック値は、この時折余分な手間をかける価値があると見なされます。</target>
        </trans-unit>
        <trans-unit id="b7b830bba46d3c56bd91aa88ed2e25a2ca316287" translate="yes" xml:space="preserve">
          <source>Because depending on a directory to just ensure it exists doesn't work too well (the modified time changes too often) dir_target() creates a .exists file in the created directory. It is this you should depend on. For portability purposes you should use the $(DIRFILESEP) macro rather than a '/' to separate the directory from the file.</source>
          <target state="translated">ディレクトリに依存して存在を確認するだけではあまりうまくいかないので(変更時刻が頻繁に変わるので)、dir_target()は作成されたディレクトリに.existsファイルを作成します。これに依存すべきです。移植性のためには、ディレクトリとファイルを分離するために'/'ではなく、$(DIRFILESEP)マクロを使うべきです。</target>
        </trans-unit>
        <trans-unit id="e43a24b825ab27b01432c41cd607e2f4d3328c51" translate="yes" xml:space="preserve">
          <source>Because each operand is evaluated in integer form, &lt;code&gt;2.18 .. 3.14&lt;/code&gt; will return two elements in list context.</source>
          <target state="translated">各オペランドは整数形式で評価されるため、 &lt;code&gt;2.18 .. 3.14&lt;/code&gt; はリストコンテキストで2つの要素を返します。</target>
        </trans-unit>
        <trans-unit id="d594331311925ecf9da3e16eb2cdc66b10c06327" translate="yes" xml:space="preserve">
          <source>Because even on non-Unix ports, Perl's glob function follows standard Unix globbing semantics. You'll need &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob(&quot;*&quot;)&lt;/a&gt;&lt;/code&gt; to get all (non-hidden) files. This makes glob() portable even to legacy systems. Your port may include proprietary globbing functions as well. Check its documentation for details.</source>
          <target state="translated">非Unixポートでも、Perlのglob関数は標準のUnixグロビングセマンティクスに従います。すべての（非表示でない）ファイルを取得するには、 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob(&quot;*&quot;)&lt;/a&gt;&lt;/code&gt; が必要です。これにより、glob（）はレガシーシステムにも移植可能になります。ポートには、独自のグロビング機能も含まれている場合があります。詳細については、ドキュメントを確認してください。</target>
        </trans-unit>
        <trans-unit id="4527823ffed4457ee7db37d2aeb7752e646692c1" translate="yes" xml:space="preserve">
          <source>Because even on non-Unix ports, Perl's glob function follows standard Unix globbing semantics. You'll need &lt;code&gt;glob(&quot;*&quot;)&lt;/code&gt; to get all (non-hidden) files. This makes glob() portable even to legacy systems. Your port may include proprietary globbing functions as well. Check its documentation for details.</source>
          <target state="translated">非Unixポートでも、Perlのglob関数は標準のUnixグロブセマンティクスに従うためです。すべての（隠されていない）ファイルを取得するには、 &lt;code&gt;glob(&quot;*&quot;)&lt;/code&gt; が必要です。これにより、glob（）はレガシーシステムにも移植可能になります。ポートには、独自のグロビング機能も含まれている場合があります。詳細については、ドキュメントを確認してください。</target>
        </trans-unit>
        <trans-unit id="a019fec3551e537f7d797537de86770f8cb583e9" translate="yes" xml:space="preserve">
          <source>Because historically some operating systems silently chopped off kernel interpretation of the &lt;code&gt;#!&lt;/code&gt; line after 32 characters, some switches may be passed in on the command line, and some may not; you could even get a &quot;-&quot; without its letter, if you're not careful. You probably want to make sure that all your switches fall either before or after that 32-character boundary. Most switches don't actually care if they're processed redundantly, but getting a &quot;-&quot; instead of a complete switch could cause Perl to try to execute standard input instead of your program. And a partial &lt;a href=&quot;#-Idirectory&quot;&gt;-I&lt;/a&gt; switch could also cause odd results.</source>
          <target state="translated">歴史的に、一部のオペレーティングシステムは、 &lt;code&gt;#!&lt;/code&gt; のカーネル解釈を黙って切り落としていたためです。 32文字以降の行では、コマンドラインで渡されるスイッチと渡されないスイッチがあります。注意しないと、文字なしで「-」を取得することもできます。おそらく、すべてのスイッチがその32文字の境界の前または後にあることを確認する必要があります。ほとんどのスイッチは、冗長に処理されているかどうかを実際には気にしませんが、完全なスイッチの代わりに「-」を取得すると、Perlがプログラムではなく標準入力を実行しようとする可能性があります。また、部分的な&lt;a href=&quot;#-Idirectory&quot;&gt;-I&lt;/a&gt;スイッチも奇妙な結果を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="2981f551145cc9ed169b464d8c0a095e7cf58a72" translate="yes" xml:space="preserve">
          <source>Because historically some operating systems silently chopped off kernel interpretation of the &lt;code&gt;#!&lt;/code&gt; line after 32 characters, some switches may be passed in on the command line, and some may not; you could even get a &quot;-&quot; without its letter, if you're not careful. You probably want to make sure that all your switches fall either before or after that 32-character boundary. Most switches don't actually care if they're processed redundantly, but getting a &quot;-&quot; instead of a complete switch could cause Perl to try to execute standard input instead of your program. And a partial &lt;b&gt;-I&lt;/b&gt; switch could also cause odd results.</source>
          <target state="translated">歴史的に一部のオペレーティングシステムは、 &lt;code&gt;#!&lt;/code&gt; カーネル解釈を黙って切り刻んだからです。32文字の後の行では、コマンドラインで渡されるスイッチと渡されないスイッチがあります。注意しないと、文字なしで &quot;-&quot;を受け取ることもできます。おそらく、すべてのスイッチがその32文字の境界の前または後のいずれかにあることを確認する必要があります。ほとんどのスイッチは、冗長に処理されているかどうかを実際には気にしませんが、完全なスイッチの代わりに「-」を取得すると、Perlがプログラムの代わりに標準入力を実行しようとする可能性があります。また、部分的な&lt;b&gt;-I&lt;/b&gt;スイッチも奇妙な結果を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="0e93d867e0e61a9f65c5551095616b09fa36af42" translate="yes" xml:space="preserve">
          <source>Because if _1 is one, you get &quot;1 document &lt;b&gt;were&lt;/b&gt; matched&quot;. An acceptable hack here is to do something like this:</source>
          <target state="translated">_1が1の場合、「1つのドキュメント&lt;b&gt;が&lt;/b&gt;一致した」という結果&lt;b&gt;が&lt;/b&gt;得られるためです。ここで許容できるハックは、次のようなことです。</target>
        </trans-unit>
        <trans-unit id="14e83724617636cdff52bc89c9135eb24a32b2c3" translate="yes" xml:space="preserve">
          <source>Because it is not possible to reliably tell UTF-8 from native 8 bit encodings, you need either a Byte Order Mark at the beginning of your source code, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; , to instruct perl.</source>
          <target state="translated">UTF-8をネイティブの8ビットエンコーディングから確実に区別することはできないため、ソースコードの先頭にバイトオーダーマークを付けるか、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用する&lt;/a&gt;必要があります。、perlに指示します。</target>
        </trans-unit>
        <trans-unit id="ad4161b2b0cababc93ea492bc495fcb997c97d88" translate="yes" xml:space="preserve">
          <source>Because it is not possible to reliably tell UTF-8 from native 8 bit encodings, you need either a Byte Order Mark at the beginning of your source code, or &lt;code&gt;use utf8;&lt;/code&gt;, to instruct perl.</source>
          <target state="translated">ネイティブの8ビットエンコーディングからUTF-8を確実に区別することはできないため、ソースコードの先頭にバイト順マークを付けるか、 &lt;code&gt;use utf8;&lt;/code&gt; 、perlに指示します。</target>
        </trans-unit>
        <trans-unit id="2126d70bfd6541291d6dfdce3ec02ad289bb688a" translate="yes" xml:space="preserve">
          <source>Because it's a module, not an integral part of the interpreter, &lt;code&gt;NEXT&lt;/code&gt; has to guess where the surrounding call was found in the method look-up sequence. In the presence of diamond inheritance patterns it occasionally guesses wrong.</source>
          <target state="translated">これはモジュールであり、インタープリターの不可欠な部分ではないため、 &lt;code&gt;NEXT&lt;/code&gt; は、メソッドルックアップシーケンスのどこで周囲の呼び出しが見つかったかを推測する必要があります。ダイヤモンド継承パターンが存在する場合、それは時々間違って推測します。</target>
        </trans-unit>
        <trans-unit id="8c9a76f6de0976ec0aec1cbf80b933b451074248" translate="yes" xml:space="preserve">
          <source>Because it's a module, not an integral part of the interpreter, NEXT.pm has to guess where the surrounding call was found in the method look-up sequence. In the presence of diamond inheritance patterns it occasionally guesses wrong.</source>
          <target state="translated">これはモジュールであってインタプリタの不可欠な部分ではないので、NEXT.pm はメソッドのルックアップシーケンスの中で周囲の呼び出しがどこで見つかったかを推測しなければなりません。ダイアモンド継承パターンの存在下では、時折間違った推測をします。</target>
        </trans-unit>
        <trans-unit id="24e659fa848838e6ef33ca050446877416a84202" translate="yes" xml:space="preserve">
          <source>Because literal conversions also work on empty strings, it may surprise some people:</source>
          <target state="translated">リテラル変換は空文字列でも動作するため、一部の人は驚くかもしれません。</target>
        </trans-unit>
        <trans-unit id="1b07afd521e75a07298e5e250bb27a3b27578dea" translate="yes" xml:space="preserve">
          <source>Because loading in the &lt;code&gt;IO::Handle&lt;/code&gt; class is an expensive operation, you should learn how to use the regular built-in variables.</source>
          <target state="translated">&lt;code&gt;IO::Handle&lt;/code&gt; クラスのロードは負荷の高い操作であるため、通常の組み込み変数の使用方法を学ぶ必要があります。</target>
        </trans-unit>
        <trans-unit id="fb1b328dbd0a94624aa3c89dafc392fc30581afd" translate="yes" xml:space="preserve">
          <source>Because many operating systems permit anyone with read access to the Perl program file to make a copy of it, patch the copy, and then execute the copy, the security-conscious Perl programmer should take care to invoke the installed copy of perl, not the copy referenced by &lt;code&gt;$^X&lt;/code&gt; . The following statements accomplish this goal, and produce a pathname that can be invoked as a command or referenced as a file.</source>
          <target state="translated">多くのオペレーティングシステムでは、Perlプログラムファイルへの読み取りアクセス権を持つすべてのユーザーがファイルのコピーを作成し、コピーにパッチを適用してから、コピーを実行できるため、セキュリティを意識したPerlプログラマは、インストールされているperlのコピーではなく、perlのインストールされたコピーを呼び出す必要があります。 &lt;code&gt;$^X&lt;/code&gt; によって参照されるコピー。次のステートメントは、この目的を達成し、コマンドとして呼び出したり、ファイルとして参照したりできるパス名を生成します。</target>
        </trans-unit>
        <trans-unit id="dd84b64cdc62e50ad281c65222f1464d48cdcca2" translate="yes" xml:space="preserve">
          <source>Because many operating systems permit anyone with read access to the Perl program file to make a copy of it, patch the copy, and then execute the copy, the security-conscious Perl programmer should take care to invoke the installed copy of perl, not the copy referenced by &lt;code&gt;$^X&lt;/code&gt;. The following statements accomplish this goal, and produce a pathname that can be invoked as a command or referenced as a file.</source>
          <target state="translated">多くのオペレーティングシステムでは、Perlプログラムファイルへの読み取りアクセス権を持つすべての人がそのコピーを作成し、コピーにパッチを適用してからコピーを実行することを許可しているため、セキュリティに敏感なPerlプログラマーは、インストールされているperlのコピーではなくperlのインストールされたコピーを呼び出すように注意する必要があります。 &lt;code&gt;$^X&lt;/code&gt; によって参照されるコピー。次のステートメントはこの目標を達成し、コマンドとして呼び出したり、ファイルとして参照したりできるパス名を生成します。</target>
        </trans-unit>
        <trans-unit id="9fda5ef27e15d5bae07e31ec0802921ed805374c" translate="yes" xml:space="preserve">
          <source>Because native operating system filehandles are global and are currently allocated down from 255, with 0 being a reserved value, the Unix emulation library emulates Unix filehandles. Consequently, you can't rely on passing &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , or &lt;code&gt;STDERR&lt;/code&gt; to your children.</source>
          <target state="translated">ネイティブオペレーティングシステムのファイルハンドルはグローバルであり、現在255から割り当てられており、0は予約済みの値であるため、UnixエミュレーションライブラリはUnixファイルハンドルをエミュレートします。したがって、子供に &lt;code&gt;STDIN&lt;/code&gt; 、 &lt;code&gt;STDOUT&lt;/code&gt; 、または &lt;code&gt;STDERR&lt;/code&gt; を渡すことはできません。</target>
        </trans-unit>
        <trans-unit id="775710224a556c9491575c5fd5adccb463f6fd25" translate="yes" xml:space="preserve">
          <source>Because native operating system filehandles are global and are currently allocated down from 255, with 0 being a reserved value, the Unix emulation library emulates Unix filehandles. Consequently, you can't rely on passing &lt;code&gt;STDIN&lt;/code&gt;, &lt;code&gt;STDOUT&lt;/code&gt;, or &lt;code&gt;STDERR&lt;/code&gt; to your children.</source>
          <target state="translated">ネイティブオペレーティングシステムのファイルハンドルはグローバルであり、現在255から割り当てられており、0は予約値であるため、UnixエミュレーションライブラリはUnixファイルハンドルをエミュレートします。したがって、 &lt;code&gt;STDIN&lt;/code&gt; 、 &lt;code&gt;STDOUT&lt;/code&gt; 、または &lt;code&gt;STDERR&lt;/code&gt; を子供に渡すことに依存することはできません。</target>
        </trans-unit>
        <trans-unit id="f5e62ec9329120e24ef0d8c20f22f5389de7c7e2" translate="yes" xml:space="preserve">
          <source>Because objects in Perl are implemented as references, it's possible to have circular references with objects as well. Imagine a TreeNode class where each node references its parent and child nodes. Any node with a parent will be part of a circular reference.</source>
          <target state="translated">Perl のオブジェクトは参照として実装されているため、オブジェクトでも循環参照を行うことができます。各ノードがその親ノードと子ノードを参照する TreeNode クラスを想像してみてください。親ノードを持つノードはすべて循環参照の一部になります。</target>
        </trans-unit>
        <trans-unit id="0bd5958f518c949c2219a905e834fb00df87ae4a" translate="yes" xml:space="preserve">
          <source>Because of DST changes, there are many time zones where the same local time occurs for two different GMT times on the same day. For example, in the &quot;Europe/Paris&quot; time zone, the local time of 2001-10-28 02:30:00 can represent either 2001-10-28 00:30:00 GMT, &lt;b&gt;or&lt;/b&gt; 2001-10-28 01:30:00 GMT.</source>
          <target state="translated">DSTが変更されているため、同じローカル時刻が同じ日の2つの異なるGMT時間で発生する多くのタイムゾーンがあります。たとえば、「ヨーロッパ/パリ」のタイムゾーンでは、2001-10-28 02:30:00の現地時間は2001-10-28 00:30:00 GMT &lt;b&gt;または&lt;/b&gt; 2001-10-28 01のいずれかを表すことができます。 30:00 GMT。</target>
        </trans-unit>
        <trans-unit id="65864a7a85dc93ea309cdec582c118e5dd979f14" translate="yes" xml:space="preserve">
          <source>Because of a bug in perl (#19213), at least in version 5.6.1, we have to hardcode the path separator for a require on Win32 to be &lt;code&gt;/&lt;/code&gt;, like on Unix rather than the Win32 &lt;code&gt;\&lt;/code&gt; . Otherwise perl will not read its own %INC accurately double load files if they are required again, or in the worst case, core dump.</source>
          <target state="translated">そのためのperlのバグ（＃19213）の、バージョン5.6.1で、少なくとも、私たちがするのWin32上で必要とするためにパス区切りをハードコーディングする必要が &lt;code&gt;/&lt;/code&gt; 、Unixのではなく、Win32の上のような &lt;code&gt;\&lt;/code&gt; 。そうしないと、perlは、再度必要になった場合、または最悪の場合はコアダンプの場合に、独自の％INCダブルロードファイルを正確に読み取りません。</target>
        </trans-unit>
        <trans-unit id="bddbdae97f197ffe17554a082cd1e7f07c2861e6" translate="yes" xml:space="preserve">
          <source>Because of a bug in perl (#19213), at least in version 5.6.1, we have to hardcode the path separator for a require on Win32 to be &lt;code&gt;/&lt;/code&gt;, like on Unix rather than the Win32 &lt;code&gt;\&lt;/code&gt;. Otherwise perl will not read its own %INC accurately double load files if they are required again, or in the worst case, core dump.</source>
          <target state="translated">perl（＃19213）のバグのため、少なくともバージョン5.6.1では、Win32 &lt;code&gt;\&lt;/code&gt; ではなくUnixのように、Win32のrequireのパス区切り文字を &lt;code&gt;/&lt;/code&gt; にハードコーディングする必要があります。そうしないと、perlは、ファイルが再度必要になった場合、または最悪の場合、コアダンプが発生した場合に、独自の％INCで正確にダブルロードファイルを読み取れません。</target>
        </trans-unit>
        <trans-unit id="4f334a2266086aa81e3afdad8578b63a9a352bf3" translate="yes" xml:space="preserve">
          <source>Because of a lack of anything better, this module uses its own routines to pack and unpack ICMP packets. It would be better for a separate module to be written which understands all of the different kinds of ICMP packets.</source>
          <target state="translated">このモジュールでは、ICMPパケットのパックとアンパックに独自のルーチンを使用しています。ICMP パケットの種類をすべて理解できるような別のモジュールを書いた方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="c6dcc7b169aa07008925e53db149a044f2ea93db" translate="yes" xml:space="preserve">
          <source>Because of all the alias issues, and because in the general case encodings have state, &quot;Encode&quot; uses an encoding object internally once an operation is in progress.</source>
          <target state="translated">すべてのエイリアスの問題と、一般的な場合のエンコードはステートを持っているため、&quot;Encode&quot; は操作が進行中になると内部的にエンコードオブジェクトを使用します。</target>
        </trans-unit>
        <trans-unit id="c50ff3946dd738899f690c4bd5e562356a6223d1" translate="yes" xml:space="preserve">
          <source>Because of all these problems, starting in v5.22, Perl will raise a warning if a multi-byte (hence Unicode) code point is used when a single-byte locale is in effect. (Although it doesn't check for this if doing so would unreasonably slow execution down.)</source>
          <target state="translated">このような問題があったため、v5.22 以降、Perl はシングルバイトのロケールを使用しているときにマルチバイト (つまり Unicode)のコードポイントを使用すると警告を出すようになりました (ただし、そうすると実行速度が不当に遅くなるかどうかはチェックしていません)。(ただし、そうすると実行速度が不当に遅くなるかどうかはチェックしていません)。</target>
        </trans-unit>
        <trans-unit id="7eca024239d85bdb38cb09ea249ea5b41add05bc" translate="yes" xml:space="preserve">
          <source>Because of backward compatibility with legacy encodings, the &quot;a unique number for every character&quot; idea breaks down a bit: instead, there is &quot;at least one number for every character&quot;. The same character could be represented differently in several legacy encodings. The converse is not true: some code points do not have an assigned character. Firstly, there are unallocated code points within otherwise used blocks. Secondly, there are special Unicode control characters that do not represent true characters.</source>
          <target state="translated">レガシーエンコーディングとの下位互換性のため、「すべての文字に固有の番号」という考えは少し崩れています。同じ文字でも、複数のレガシーエンコーディングでは異なる表現になる可能性があります。逆もまた真ではありません:いくつかのコードポイントには割り当てられた文字がありません。第一に、 そうでなければ使われていないブ ロ ッ ク の中には、 割り当てられていない コ ー ド 点があ り ます。第二に、真のキ ャ ラ ク タ を表現 し ない特殊な Unicode 制御キ ャ ラ ク タ があ り ます。</target>
        </trans-unit>
        <trans-unit id="6c5cc2c32fa019382bf3152d3598a8ccd6be4473" translate="yes" xml:space="preserve">
          <source>Because of being able to omit the curlies for the simple case of &lt;code&gt;$$x&lt;/code&gt; , people often make the mistake of viewing the dereferencing symbols as proper operators, and wonder about their precedence. If they were, though, you could use parentheses instead of braces. That's not the case. Consider the difference below; case 0 is a short-hand version of case 1,</source>
          <target state="translated">&lt;code&gt;$$x&lt;/code&gt; 単純なケースでは中括弧を省略できるため、逆参照記号を適切な演算子として表示することを誤解し、それらの優先順位に疑問を感じることがよくあります。ただし、そうであれば、中括弧の代わりに括弧を使用できます。そうではありません。以下の違いを考慮してください。ケース0はケース1の簡略版です。</target>
        </trans-unit>
        <trans-unit id="e8951f412eada97de516eafdeec177d3c0f76b4b" translate="yes" xml:space="preserve">
          <source>Because of being able to omit the curlies for the simple case of &lt;code&gt;$$x&lt;/code&gt;, people often make the mistake of viewing the dereferencing symbols as proper operators, and wonder about their precedence. If they were, though, you could use parentheses instead of braces. That's not the case. Consider the difference below; case 0 is a short-hand version of case 1,</source>
          <target state="translated">&lt;code&gt;$$x&lt;/code&gt; 単純なケースではカーリーを省略できるため、間接参照記号を適切な演算子と見なすのを間違え、優先順位について疑問に思うことがよくあります。ただし、中括弧の代わりに括弧を使用することもできます。そうではありません。以下の違いを考慮してください。ケース0は、ケース1の短縮版です。</target>
        </trans-unit>
        <trans-unit id="e900a4e123821bf1949cbdd4fb9b5da407117914" translate="yes" xml:space="preserve">
          <source>Because of clock granularity, expiration times may occur up to one second sooner than you expect. For example, suppose you store a value with a lifetime of ten seconds, and you store it at 12:00:00.998 on a certain day. Memoize will look at the clock and see 12:00:00. Then 9.01 seconds later, at 12:00:10.008 you try to read it back. Memoize will look at the clock and see 12:00:10 and conclude that the value has expired. This will probably not occur if you have &lt;code&gt;Time::HiRes&lt;/code&gt; installed.</source>
          <target state="translated">クロックの細分性のため、有効期限は予想よりも最大1秒早く発生する場合があります。たとえば、ライフタイムが10秒の値を格納し、特定の日の12：00：00.998に格納するとします。 Memoizeは時計を見て、12：00：00を参照します。次に9.01秒後の12：00：10.008に、それを読み返そうとします。 Memoizeは時計を見て12:00:10を確認し、値が期限切れであると結論付けます。 &lt;code&gt;Time::HiRes&lt;/code&gt; インストールされている場合、これはおそらく発生しません。</target>
        </trans-unit>
        <trans-unit id="c6e7a0449744f95f7025dc0e8c4838b8d0860c99" translate="yes" xml:space="preserve">
          <source>Because of idiosyncrasies of OS/2 one cannot have all the eggs in the same basket (though EMX environment tries hard to overcome this limitations, so the situation may somehow improve). There are 4 executables for Perl provided by the distribution:</source>
          <target state="translated">OS/2 の特殊性のため、すべての卵を同じバスケットに入れることはできません (ただし、EMX 環境はこの制限を克服しようと努力していますので、状況は何とか改善されるかもしれません)。ディストリビューションで提供されている Perl の実行ファイルは 4 つあります。</target>
        </trans-unit>
        <trans-unit id="38b54108e9558724b240349ad9589f54bf027fa2" translate="yes" xml:space="preserve">
          <source>Because of its global effect, this setting should not be used inside modules or the like.</source>
          <target state="translated">グローバルな効果があるため、この設定はモジュールなどの内部では使用しないでください。</target>
        </trans-unit>
        <trans-unit id="cc4be6e39aa524fd29878685a03b1168c2bf5d9f" translate="yes" xml:space="preserve">
          <source>Because of our problems with the native yacc we used GNU bison to generate a pure (=reentrant) parser for perly.y. So our yacc is really the following script:</source>
          <target state="translated">ネイティブyaccの問題があったので、perly.y用の純粋な(=reentrant)パーサを生成するためにGNU bisonを使用しました。</target>
        </trans-unit>
        <trans-unit id="57e65a7490f61f523f42c4deffd151e416a21006" translate="yes" xml:space="preserve">
          <source>Because of the &quot;text&quot; mode translation, DOSish perls have limitations in using &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; on a file accessed in &quot;text&quot; mode. Stick to &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;-ing to locations you got from &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; (and no others), and you are usually free to use &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; even in &quot;text&quot; mode. Using &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; or other file operations may be non-portable. If you use &lt;a href=&quot;perlfunc#binmode-FILEHANDLE&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; on a file, however, you can usually &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; with arbitrary values safely.</source>
          <target state="translated">「テキスト」モードの変換のため、DOSish perlsには、「テキスト」モードでアクセスされるファイルでの&lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt;アンド&lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt;使用に制限があります。&lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt;から取得した場所（他の場所ではない）に&lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt;することに固執します。通常、「テキスト」モードでも&lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt;自由に使用できます。使用して&lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt;か、&lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt;たり、他のファイル操作は非ポータブルかもしれません。ただし、ファイルで&lt;a href=&quot;perlfunc#binmode-FILEHANDLE&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt;を使用する場合は、通常、任意の値で安全に&lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; &lt;/a&gt;して&lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt;ことができます。</target>
        </trans-unit>
        <trans-unit id="9835e5c9cd0a637bdd223f60f76a72232d5d4783" translate="yes" xml:space="preserve">
          <source>Because of the &quot;text&quot; mode translation, DOSish perls have limitations in using &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; on a file accessed in &quot;text&quot; mode. Stick to &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;-ing to locations you got from &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; (and no others), and you are usually free to use &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; even in &quot;text&quot; mode. Using &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; or other file operations may be non-portable. If you use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; on a file, however, you can usually &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; with arbitrary values safely.</source>
          <target state="translated">「テキスト」モードの変換のため、DOSish perlは「テキスト」モードでアクセスされたファイルで &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; アンド &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; を使用する際に制限があります。 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; から取得した場所（他の場所ではない）に &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; することに固執します。通常、「テキスト」モードでも &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; アンド &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 自由に使用できます。 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; 、またはその他のファイル操作の使用は、移植できない場合があります。ただし、ファイルで &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; を使用すると、通常は任意の値を安全に &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; して &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; ことができます。</target>
        </trans-unit>
        <trans-unit id="86b041b8cdbf2e2a44b563d3f9086435ec867343" translate="yes" xml:space="preserve">
          <source>Because of the 16-bitness, UTF-16 is byte-order dependent. UTF-16 itself can be used for in-memory computations, but if storage or transfer is required either UTF-16BE (big-endian) or UTF-16LE (little-endian) encodings must be chosen.</source>
          <target state="translated">16 ビ ッ ト ネスのため、 UTF-16 はバ イ ト 順序に依存 し ます。UTF-16 自体は メ モ リ 内計算に使えますが、 保存ま たは転送が必要な場合は UTF-16BE (ビ ッ グエンデ ィ ア ン)か UTF-16LE (リトルエンデ ィ ア ン)エン コ ーデ ィ ン グ を選ぶ必要があ り ます。</target>
        </trans-unit>
        <trans-unit id="ddcee3f7b2710d631ab7d25c7c6ccf7f643a3fe9" translate="yes" xml:space="preserve">
          <source>Because of the algorithm used, ISO-8859 series and other single-byte encodings do not work well unless either one of ISO-8859 is the only one suspect (besides ascii and utf8).</source>
          <target state="translated">アルゴリズムが使われているため、ISO-8859シリーズなどのシングルバイトエンコーディングは、(asciiやutf8以外にも)ISO-8859のどちらか1つだけが疑われない限り、うまく動作しません。</target>
        </trans-unit>
        <trans-unit id="5cf1c92c7c06c92a6e6b33e7b9bd233615db8e45" translate="yes" xml:space="preserve">
          <source>Because of the nature of the Perl parsing and tokenizing routines, certain initialization values &lt;b&gt;must&lt;/b&gt; be quoted in order to correctly parse as the intended version, especially when using the &lt;code&gt;declare&lt;/code&gt; or &lt;a href=&quot;#qv%28%29&quot;&gt;&quot;qv()&quot;&lt;/a&gt; methods. While you do not have to quote decimal numbers when creating version objects, it is always safe to quote &lt;b&gt;all&lt;/b&gt; initial values when using version.pm methods, as this will ensure that what you type is what is used.</source>
          <target state="translated">Perlの解析およびトークン化ルーチンの性質上、特に &lt;code&gt;declare&lt;/code&gt; または&lt;a href=&quot;#qv%28%29&quot;&gt;&quot;qv（）&quot;&lt;/a&gt;メソッドを使用する場合は、目的のバージョンとして正しく解析するために、特定の初期化値を引用符で囲む&lt;b&gt;必要&lt;/b&gt;が&lt;b&gt;あり&lt;/b&gt;ます。バージョンオブジェクトを作成するときに10進数を引用する必要はありませんが、version.pmメソッドを使用するときは、&lt;b&gt;すべての&lt;/b&gt;初期値を引用するのが常に安全です。これにより、入力した内容が使用されたものになります。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0e124c1c916c9b7a769264558af430e4f129d0a7" translate="yes" xml:space="preserve">
          <source>Because of the nature of the features it enables, forward compatibility can not be guaranteed in any way.</source>
          <target state="translated">それが可能にする機能の性質上、前方互換性を保証するものではありません。</target>
        </trans-unit>
        <trans-unit id="89787285641f86ade5feb7e0702432198446d5b1" translate="yes" xml:space="preserve">
          <source>Because of the overhead associated with obtaining the list of defined symbols for the tied hash iterator, it is only done once, and the list is reused for subsequent iterations. Changes to symbols made through this package are recorded, but in the rare event that someone changes the process' symbol table from outside (as is possible using some software from the net), the iterator will be out of sync with the symbol table. If you expect this to happen, you can reset the cache by calling this method. In addition, if you pass a FALSE value as the first argument, caching will be disabled. It can be re-enabled later by calling &lt;code&gt;clearcache&lt;/code&gt; again with a TRUE value as the first argument. It returns TRUE or FALSE to indicate whether caching was previously enabled or disabled, respectively.</source>
          <target state="translated">タイハッシュイテレータの定義済みシンボルのリストの取得に関連するオーバーヘッドのため、これは1回だけ実行され、リストは後続の反復で再利用されます。このパッケージを介して行われたシンボルへの変更は記録されますが、まれに誰かがプロセスのシンボルテーブルを外部から変更した場合（ネットの一部のソフトウェアを使用して可能）、イテレータはシンボルテーブルと同期しなくなります。これが発生することが予想される場合は、このメソッドを呼び出すことでキャッシュをリセットできます。さらに、最初の引数としてFALSE値を渡すと、キャッシュが無効になります。最初の引数としてTRUE値を &lt;code&gt;clearcache&lt;/code&gt; してclearcacheを再度呼び出すことにより、後で再度有効にすることができます。キャッシュが以前に有効にされたか無効にされたかを示すために、それぞれTRUEまたはFALSEを返します。</target>
        </trans-unit>
        <trans-unit id="46fd1b6b9fa8982a77e6c457f5e31e6dd1a8e6bb" translate="yes" xml:space="preserve">
          <source>Because of the unexpected behaviors associated with this modifier, you probably should only explicitly use it to maintain weird backward compatibilities.</source>
          <target state="translated">この修飾子に関連した予期せぬ振る舞いがあるため、奇妙な下位互換性を維持するためだけに明示的に使用すべきでしょう。</target>
        </trans-unit>
        <trans-unit id="11b9a9053f80eaf386518a04692ab13e4782146b" translate="yes" xml:space="preserve">
          <source>Because of the unexpected behaviors associated with this modifier, you probably should only use it to maintain weird backward compatibilities.</source>
          <target state="translated">この修飾子に関連した予期せぬ動作があるため、奇妙な下位互換性を維持するためだけに使うべきでしょう。</target>
        </trans-unit>
        <trans-unit id="033d419ed47a31e5b1999d8b2e6265eaff662dc3" translate="yes" xml:space="preserve">
          <source>Because of their special use by sort(), the variables $a and $b are exempted from this check.</source>
          <target state="translated">sort()で特別に使用されるため、変数 $a と $b はこのチェックから除外されます。</target>
        </trans-unit>
        <trans-unit id="79393165c5e367768108e6eb51a718f96e4510a4" translate="yes" xml:space="preserve">
          <source>Because of this fallback feature of JSON.pm, JSON::PP tries not to be more JavaScript-friendly than JSON::XS (i.e. not to escape extra characters such as U+2028 and U+2029, etc), in order for you not to lose such JavaScript-friendliness silently when you use JSON.pm and install JSON::XS for speed or by accident. If you need JavaScript-friendly RFC7159-compliant pure perl module, try &lt;a href=&quot;JSON::Tiny&quot;&gt;JSON::Tiny&lt;/a&gt;, which is derived from &lt;a href=&quot;mojolicious&quot;&gt;Mojolicious&lt;/a&gt; web framework and is also smaller and faster than JSON::PP.</source>
          <target state="translated">JSON.pmのこのフォールバック機能のため、JSON :: PPはJSON :: XSよりもJavaScriptに適したものにならないようにします（つまり、U +2028やU + 2029などの余分な文字をエスケープしないようにします）。 JSON.pmを使用してJSON :: XSをインストールするときに、そのようなJavaScriptの使いやすさを黙って失わないようにしてください。JavaScript対応のRFC7159準拠の純粋なperlモジュールが必要な場合は、&lt;a href=&quot;JSON::Tiny&quot;&gt;JSON :: Tinyを&lt;/a&gt;試してください。これは、&lt;a href=&quot;mojolicious&quot;&gt;Mojolicious&lt;/a&gt; Webフレームワークから派生し、JSON :: PPよりも小さく高速です。</target>
        </trans-unit>
        <trans-unit id="b4c8809b3046a08b3452bb5931521fe0616806ce" translate="yes" xml:space="preserve">
          <source>Because of this mechanism it is important that &lt;b&gt;AutoLoader&lt;/b&gt; is always &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;d and not &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d.</source>
          <target state="translated">このメカニズムのため、&lt;b&gt;オートローダー&lt;/b&gt;が常にdを &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; dを &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; としないことが重要です。</target>
        </trans-unit>
        <trans-unit id="915eb569e5cd5ca772dbf6184e1e9e7f7c40e009" translate="yes" xml:space="preserve">
          <source>Because of this mechanism it is important that &lt;b&gt;AutoLoader&lt;/b&gt; is always &lt;code&gt;use&lt;/code&gt;d and not &lt;code&gt;require&lt;/code&gt;d.</source>
          <target state="translated">このメカニズムのため、&lt;b&gt;AutoLoader&lt;/b&gt;は常にdを &lt;code&gt;use&lt;/code&gt; dを &lt;code&gt;require&lt;/code&gt; としないことが重要です。</target>
        </trans-unit>
        <trans-unit id="cf9b61922d31b09cb33aab7bed1a50c499c2933e" translate="yes" xml:space="preserve">
          <source>Because of those two, the code paging approach used use in ucm-based Encoding SOMETIMES fails so this module was written.</source>
          <target state="translated">この2つのため、ucm-based Encoding SOMETIMESで使用されているコードページングアプローチは失敗するので、このモジュールが書かれました。</target>
        </trans-unit>
        <trans-unit id="4732978c8da8f3cf527ff9f22b157a0776b9721a" translate="yes" xml:space="preserve">
          <source>Because patterns are processed as double-quoted strings, the following also work:</source>
          <target state="translated">パターンは二重引用符で囲まれた文字列として処理されるため、以下のようにも動作します。</target>
        </trans-unit>
        <trans-unit id="e94cf9546dd5c84d3c599b01ef4e83754d69c340" translate="yes" xml:space="preserve">
          <source>Because perl needs to parse the script before applying this pragma, such encodings as Shift_JIS and Big-5 that may contain &lt;code&gt;'\'&lt;/code&gt; (BACKSLASH; &lt;code&gt;\x5c&lt;/code&gt; ) in the second byte fail because the second byte may accidentally escape the quoting character that follows.</source>
          <target state="translated">perlはこのプラグマを適用する前にスクリプトを解析する必要があるため、2番目のバイトに続く引用文字を誤ってエスケープする可能性があるため、2番目のバイトに &lt;code&gt;'\'&lt;/code&gt; （ &lt;code&gt;\x5c&lt;/code&gt; ; \ x5c）を含む可能性があるShift_JISやBig-5などのエンコーディングは失敗します。</target>
        </trans-unit>
        <trans-unit id="e3192cbde985ba3a61564abae80a07c49199034c" translate="yes" xml:space="preserve">
          <source>Because perl needs to parse the script before applying this pragma, such encodings as Shift_JIS and Big-5 that may contain &lt;code&gt;'\'&lt;/code&gt; (BACKSLASH; &lt;code&gt;\x5c&lt;/code&gt;) in the second byte fail because the second byte may accidentally escape the quoting character that follows.</source>
          <target state="translated">perlはこのプラグマを適用する前にスクリプトを解析する必要があるため、2番目のバイトに &lt;code&gt;'\'&lt;/code&gt; （ &lt;code&gt;\x5c&lt;/code&gt; ; \ x5c）が含まれる可能性のあるShift_JISやBig-5などのエンコーディングは、2番目のバイトが誤って後続の引用文字をエスケープする可能性があるため失敗します。</target>
        </trans-unit>
        <trans-unit id="00d20d737f3e8559e674f183083581c5bd074a26" translate="yes" xml:space="preserve">
          <source>Because pointer size does not necessarily equal integer size, use the follow macros to do it right.</source>
          <target state="translated">ポインタのサイズは必ずしも整数サイズとは限らないので、以下のマクロを使って正しく実行してください。</target>
        </trans-unit>
        <trans-unit id="1ab7d92c18b253929d90277eb1a2787d5ea83ae7" translate="yes" xml:space="preserve">
          <source>Because scripts differ in their directionality (Hebrew and Arabic are written right to left, for example) Unicode supplies a &lt;code&gt;Bidi_Class&lt;/code&gt; property. Some of the values this property can have are:</source>
          <target state="translated">スクリプトは方向性が異なるため（たとえば、ヘブライ語とアラビア語は右から左に書かれます）、Unicodeは &lt;code&gt;Bidi_Class&lt;/code&gt; プロパティを提供します。このプロパティが持つことができる値のいくつかは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="5783acfed14f8a18cb2ce82232df112d8f4b39d0" translate="yes" xml:space="preserve">
          <source>Because taintedness is associated with each scalar value, some elements of an array or hash can be tainted and others not. The keys of a hash are &lt;b&gt;never&lt;/b&gt; tainted.</source>
          <target state="translated">汚染度は各スカラー値に関連付けられているため、配列またはハッシュの一部の要素は汚染され、その他の要素は汚染されません。ハッシュのキーは&lt;b&gt;決して&lt;/b&gt;汚染され&lt;b&gt;ません&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="43efff829e58f5a1345657268ce9125ae02a8e64" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;../functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;ed value will have the separator reattached when it is written back to the file. There is no way to create a file whose trailing record separator string is missing.</source>
          <target state="translated">それは、ファイルに書き戻されるときに、 &lt;code&gt;&lt;a href=&quot;../functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; 値にセパレーターが再接続されるためです。末尾のレコード区切り文字列が欠落しているファイルを作成する方法はありません。</target>
        </trans-unit>
        <trans-unit id="1a39cf872a3f7b6aa066ba9c7802115aead55d6e" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; at end of file or upon error, you will sometimes see it used this way:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 関数はファイルの終わりまたはエラー時に &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返すため、次のように使用されることがあります。</target>
        </trans-unit>
        <trans-unit id="2d7cdbb67a74f8d2c9c047551149590e9752d672" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement implies a &lt;code&gt;BEGIN&lt;/code&gt; block, the importing of semantics happens as soon as the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement is compiled, before the rest of the file is compiled. This is how it is able to function as a pragma mechanism, and also how modules are able to declare subroutines that are then visible as list or unary operators for the rest of the current file. This will not work if you use &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;. With &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; you can get into this problem:</source>
          <target state="translated">ので &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 文は意味 &lt;code&gt;BEGIN&lt;/code&gt; ブロックをすぐにとして、セマンティクスのインポートが起こるの &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ファイルの残りがコンパイルされる前に、文は、コンパイルされます。これは、プラグマメカニズムとして機能する方法と、現在のファイルの残りのリストまたは単項演算子として表示されるサブルーチンをモジュールが宣言する方法です。あなたが使用している場合、これは動作しません &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; の代わりに &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 。で &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; あなたはこの問題に入ることができます。</target>
        </trans-unit>
        <trans-unit id="3c3e36ebc253e6320dfa90cfe5b728b065ce3f37" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;chomp&lt;/code&gt;ed value will have the separator reattached when it is written back to the file. There is no way to create a file whose trailing record separator string is missing.</source>
          <target state="translated">ので &lt;code&gt;chomp&lt;/code&gt; ED値は、それがファイルに書き戻されたときに再び取り付け、セパレータを持つことになります。末尾のレコード区切り文字列が欠落しているファイルを作成する方法はありません。</target>
        </trans-unit>
        <trans-unit id="af2ba8c1f36d75fd963bdb6706751e36d03bae43" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;here&lt;/code&gt; is before the &lt;code&gt;.*&lt;/code&gt; in the pattern, its position can be determined exactly. That's not true, however, for the &lt;code&gt;there&lt;/code&gt; ; it could appear at any point after where the anchored string appeared. Perl uses both for its optimisations, preferring the longer, or, if they are equal, the floating.</source>
          <target state="translated">&lt;code&gt;here&lt;/code&gt; はパターンの &lt;code&gt;.*&lt;/code&gt; 前にあるため、その位置を正確に決定できます。それはのために、しかし、真実ではないのです &lt;code&gt;there&lt;/code&gt; 。アンカー文字列が出現した後の任意の時点で出現する可能性があります。Perlは最適化に両方を使用し、長い方を好むか、等しい場合はフローティングを使用します。</target>
        </trans-unit>
        <trans-unit id="fef986661cf1ec507db2ffa4c44fc0d6ca39bba4" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;here&lt;/code&gt; is before the &lt;code&gt;.*&lt;/code&gt; in the pattern, its position can be determined exactly. That's not true, however, for the &lt;code&gt;there&lt;/code&gt;; it could appear at any point after where the anchored string appeared. Perl uses both for its optimisations, preferring the longer, or, if they are equal, the floating.</source>
          <target state="translated">&lt;code&gt;here&lt;/code&gt; はパターンの &lt;code&gt;.*&lt;/code&gt; 前にあるため、その位置を正確に決定できます。それはのために、しかし、真実ではないのです &lt;code&gt;there&lt;/code&gt; 。アンカーされた文字列が表示された後の任意の時点で表示される可能性があります。 Perlは最適化のために両方を使用し、より長いもの、または等しい場合はフローティングを優先します。</target>
        </trans-unit>
        <trans-unit id="a2431412f653ac2d48b2590f72b1ae7bed247322" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;mark&lt;/code&gt; variable is converted to a pointer on the value stack, extra care must be taken if &lt;code&gt;EXTEND&lt;/code&gt; or any of the &lt;code&gt;XPUSH&lt;/code&gt; macros are invoked within the function, because the stack may need to be moved to extend it and so the existing pointer will now be invalid. If this may be a problem, a possible solution is to track the mark offset as an integer and track the mark itself later on after the stack had been moved.</source>
          <target state="translated">&lt;code&gt;mark&lt;/code&gt; 変数は値スタック上のポインターに変換されるため、 &lt;code&gt;EXTEND&lt;/code&gt; または &lt;code&gt;XPUSH&lt;/code&gt; マクロのいずれかが関数内で呼び出される場合は、スタックを拡張するためにスタックを移動する必要があり、既存のポインターが現在は無効です。これが問題になる可能性がある場合、考えられる解決策は、マークオフセットを整数として追跡し、スタックが移動された後でマーク自体を追跡することです。</target>
        </trans-unit>
        <trans-unit id="28a1dea2b8dc5fa2f3798b76ce3f11a720999a6b" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;readline&lt;/code&gt; function returns &lt;code&gt;undef&lt;/code&gt; at end of file or upon error, you will sometimes see it used this way:</source>
          <target state="translated">&lt;code&gt;readline&lt;/code&gt; 関数はファイルの終わりまたはエラー時に &lt;code&gt;undef&lt;/code&gt; を返すため、次のように使用されていることがあります。</target>
        </trans-unit>
        <trans-unit id="206300e9a9cae7d4d33910fad6d81cd5f5d5cc80" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;use&lt;/code&gt; statement implies a &lt;code&gt;BEGIN&lt;/code&gt; block, the importing of semantics happens as soon as the &lt;code&gt;use&lt;/code&gt; statement is compiled, before the rest of the file is compiled. This is how it is able to function as a pragma mechanism, and also how modules are able to declare subroutines that are then visible as list or unary operators for the rest of the current file. This will not work if you use &lt;code&gt;require&lt;/code&gt; instead of &lt;code&gt;use&lt;/code&gt;. With &lt;code&gt;require&lt;/code&gt; you can get into this problem:</source>
          <target state="translated">&lt;code&gt;use&lt;/code&gt; ステートメントは &lt;code&gt;BEGIN&lt;/code&gt; ブロックを意味するため、セマンティクスのインポートは、 &lt;code&gt;use&lt;/code&gt; ステートメントがコンパイルされるとすぐに、ファイルの残りの部分がコンパイルされる前に行われます。これは、プラグマメカニズムとして機能する方法であり、モジュールがサブルーチンを宣言する方法でもあります。サブルーチンは、現在のファイルの残りの部分のリスト演算子または単項演算子として表示されます。あなたが使用している場合、これは動作しません &lt;code&gt;require&lt;/code&gt; の代わりに &lt;code&gt;use&lt;/code&gt; 。で &lt;code&gt;require&lt;/code&gt; あなたはこの問題に入ることができます。</target>
        </trans-unit>
        <trans-unit id="9cb97ff89f00546d3eb19d15e7c154022a6e40c9" translate="yes" xml:space="preserve">
          <source>Because the L&amp;lt;...&amp;gt; is the most complex construct in the language, it should not surprise you that the events it generates are the most complex in the language. Most of complexity is hidden away in the attribute values, so for those of you writing a Pod formatter that produces a non-hypertextual format, you can just ignore the attributes and treat an L event structure like a formatting element that (presumably) doesn't actually produce a change in formatting. That is, the content of the L event structure (as opposed to its attributes) is always what text should be displayed.</source>
          <target state="translated">L &amp;lt;...&amp;gt;は言語で最も複雑な構造であるため、L &amp;lt;...&amp;gt;が生成するイベントが言語で最も複雑であることは驚くべきことではありません。複雑さのほとんどは属性値に隠されているため、ハイパーテキスト以外の形式を生成するポッドフォーマッターを作成している場合は、属性を無視して、Lイベント構造を（おそらく）フォーマット要素のように扱うことができます。 tは実際にフォーマットの変更を生成します。つまり、Lイベント構造のコンテンツ（属性ではなく）は、常に表示されるテキストです。</target>
        </trans-unit>
        <trans-unit id="fe1ecaef6dcc4b2b01535ebf9f55c2fce3a55dd0" translate="yes" xml:space="preserve">
          <source>Because the arithmetic operators all have fixed arity and are postfixed, there is no need for operator precedence, nor for a grouping operator to override precedence. This is half of the point of RPN.</source>
          <target state="translated">算術演算子は、すべての演算子が固定されていて、後付けなので、演算子の優先順位も、グルーピング演算子が優先順位を上書きする必要もありません。これが RPN のポイントの半分です。</target>
        </trans-unit>
        <trans-unit id="77f9c95f62f2ca8f51dfcabf085dd8aa40d54fc6" translate="yes" xml:space="preserve">
          <source>Because the assignment copies the values, this also has the effect of turning call-by-reference into call-by-value. Otherwise a function is free to do in-place modifications of &lt;code&gt;@_&lt;/code&gt; and change its caller's values.</source>
          <target state="translated">割り当ては値をコピーするため、参照による呼び出しを値による呼び出しに変換する効果もあります。それ以外の場合、関数は &lt;code&gt;@_&lt;/code&gt; のインプレース変更を自由に行い、呼び出し元の値を変更できます。</target>
        </trans-unit>
        <trans-unit id="ef6e720933c8cfb7b84641d15fcb0ddf15b2f13b" translate="yes" xml:space="preserve">
          <source>Because the bytes pragma breaks encapsulation (i.e. it exposes the innards of how the perl executable currently happens to store a string), the byte values that result are in an unspecified encoding.</source>
          <target state="translated">bytes pragmaはカプセル化を破るので(つまり、Perlの実行ファイルが現在どのようにして文字列を格納しているかの内部を公開しています)、結果として得られるバイト値は不特定のエンコーディングになります。</target>
        </trans-unit>
        <trans-unit id="6c5cdf7c11299fa442df7b9179d8baed60991f7f" translate="yes" xml:space="preserve">
          <source>Because the conversion happens in place, the data to be converted cannot be a string constant: it must be a scalar variable.</source>
          <target state="translated">変換はその場で行われるので、変換されるデータは文字列定数にすることはできません:それはスカラ変数でなければなりません。</target>
        </trans-unit>
        <trans-unit id="9be0ebeeed384a0006842b7e5b00f870be61a55a" translate="yes" xml:space="preserve">
          <source>Because the current implementation uses the table and key sizes for the hashing algorithm, there is no means by which to dynamically change the value of any of the initialization parameters.</source>
          <target state="translated">現在の実装では、ハッシュアルゴリズムにテーブルとキーサイズを使用しているため、初期化パラメータの値を動的に変更する手段がありません。</target>
        </trans-unit>
        <trans-unit id="a16d069c72d0455b6bbcd09050d9c581b9a31d6b" translate="yes" xml:space="preserve">
          <source>Because the intent of this feature is primarily to let you define subroutines that work like built-in functions, here are prototypes for some other functions that parse almost exactly like the corresponding built-in.</source>
          <target state="translated">この機能の意図は、主に組み込み関数のように動作するサブルーチンを定義することにありますので、ここでは、対応する組み込み関数とほぼ同じようにパースする他の関数のプロトタイプをいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="286b10724045d4807f7e79831cdfb01b70d2bd21" translate="yes" xml:space="preserve">
          <source>Because the internal format is often UTF-8, these bugs are hard to spot, because UTF-8 is usually the encoding you wanted! But don't be lazy, and don't use the fact that Perl's internal format is UTF-8 to your advantage. Encode explicitly to avoid weird bugs, and to show to maintenance programmers that you thought this through.</source>
          <target state="translated">内部フォーマットが UTF-8 であることが多いので、これらのバグを発見するのは難しいでしょう。しかし、怠け者にならず、Perl の内部フォーマットが UTF-8 であるという事実を利用しないでください。奇妙なバグを避けるために明示的にエンコードしてください。</target>
        </trans-unit>
        <trans-unit id="92b5a68a7f930a6d97c59ffe2faa9fff5db40d0e" translate="yes" xml:space="preserve">
          <source>Because the magical increment only works on non-empty strings matching &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt;, the following will only return an alpha:</source>
          <target state="translated">魔法のインクリメントは &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt; に一致する空でない文字列でのみ機能するため、以下はアルファのみを返します。</target>
        </trans-unit>
        <trans-unit id="2a9f9af112f672f597ba8d8590f5548d9330b12e" translate="yes" xml:space="preserve">
          <source>Because the mode contains both the file type and its permissions, you should mask off the file type portion and (s)printf using a &lt;code&gt;&quot;%o&quot;&lt;/code&gt; if you want to see the real permissions.</source>
          <target state="translated">モードにはファイルタイプとそのアクセス許可の両方が含まれているため、実際のアクセス許可を表示するには、ファイルタイプの部分と（s）printfを &lt;code&gt;&quot;%o&quot;&lt;/code&gt; を使用してマスクする必要があります。</target>
        </trans-unit>
        <trans-unit id="f2423ea47c406258a59791ed602061d34ce7d19b" translate="yes" xml:space="preserve">
          <source>Because the result of &lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; has all metacharacters quoted, there is no way to insert a literal &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; inside a &lt;code&gt;\Q\E&lt;/code&gt; pair. If protected by &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; will be quoted to become &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; ; if not, it is interpreted as the start of an interpolated scalar.</source>
          <target state="translated">&lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; の結果にはすべてのメタ文字が引用されているため、 &lt;code&gt;\Q\E&lt;/code&gt; ペア内にリテラル &lt;code&gt;$&lt;/code&gt; または &lt;code&gt;@&lt;/code&gt; を挿入する方法はありません。 &lt;code&gt;\&lt;/code&gt; で保護されている場合、 &lt;code&gt;$&lt;/code&gt; は &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; になるように引用されます。そうでない場合は、補間されたスカラーの開始として解釈されます。</target>
        </trans-unit>
        <trans-unit id="097258c8be4cbb48ed4be0fc9859bc5c3825bc9a" translate="yes" xml:space="preserve">
          <source>Because the result of &lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; has all metacharacters quoted, there is no way to insert a literal &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; inside a &lt;code&gt;\Q\E&lt;/code&gt; pair. If protected by &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;$&lt;/code&gt; will be quoted to become &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt;; if not, it is interpreted as the start of an interpolated scalar.</source>
          <target state="translated">&lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; の結果にはすべてのメタ文字が引用されているため、 &lt;code&gt;\Q\E&lt;/code&gt; ペア内にリテラルの &lt;code&gt;$&lt;/code&gt; または &lt;code&gt;@&lt;/code&gt; を挿入する方法はありません。 &lt;code&gt;\&lt;/code&gt; で保護されている場合、 &lt;code&gt;$&lt;/code&gt; は &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; になるように引用されます。そうでない場合は、補間されたスカラーの開始として解釈されます。</target>
        </trans-unit>
        <trans-unit id="d152f048af7d90769fe2fc306e54559a9ec00ef1" translate="yes" xml:space="preserve">
          <source>Because the smartmatch operator recurses on nested arrays, this will still report that &quot;red&quot; is in the array.</source>
          <target state="translated">スマートマッチ演算子は入れ子になった配列に対して再帰するので、この場合でも &quot;red &quot;が配列の中にあることが報告されます。</target>
        </trans-unit>
        <trans-unit id="2efc41902e93fe5cc4de4d763dfe32a371a96fe2" translate="yes" xml:space="preserve">
          <source>Because the standard failure message that &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; produces whenever a test fails will be a common occurrence in your test error output, and because it has changed between Test::Builder versions, rather than forcing you to call &lt;code&gt;test_err&lt;/code&gt; with the string all the time like so</source>
          <target state="translated">テストが失敗するたびに&lt;a href=&quot;../builder&quot;&gt;Test :: Builderが&lt;/a&gt;生成する標準の失敗メッセージは、テストエラー出力で一般的に発生し、すべての文字列で &lt;code&gt;test_err&lt;/code&gt; を呼び出すことを強制するのではなく、Test :: Builderバージョン間で変更されたためです。そのような時間</target>
        </trans-unit>
        <trans-unit id="87490af32e5b48ef0bb10c89847f02a1cf0e7677" translate="yes" xml:space="preserve">
          <source>Because the standard failure message that &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; produces whenever a test fails will be a common occurrence in your test error output, and because it has changed between Test::Builder versions, rather than forcing you to call &lt;code&gt;test_err&lt;/code&gt; with the string all the time like so</source>
          <target state="translated">&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt;がテストに失敗するたびに生成する標準の失敗メッセージは、テストエラー出力でよく発生するため、また、すべての文字列を &lt;code&gt;test_err&lt;/code&gt; してtest_errを呼び出すのではなく、Test :: Builderのバージョン間で変更されているためです。そのような時間</target>
        </trans-unit>
        <trans-unit id="4ad62b1bf690da795c5cc2f593aa204a22c3e54b" translate="yes" xml:space="preserve">
          <source>Because the target is reused, you must be careful when pushing multiple values on the stack. The following code will not do what you think:</source>
          <target state="translated">ターゲットは再利用されるので、スタックに複数の値をプッシュする場合は注意が必要です。以下のコードでは、思ったようなことができません。</target>
        </trans-unit>
        <trans-unit id="bdc28270d2ca87731131681df34d184cd0aea361" translate="yes" xml:space="preserve">
          <source>Because the transliteration table is built at compile time, neither the</source>
          <target state="translated">翻字テーブルはコンパイル時に構築されるので</target>
        </trans-unit>
        <trans-unit id="c4a2190965562aceb584191519393c161752b237" translate="yes" xml:space="preserve">
          <source>Because the value of &lt;a href=&quot;config#archname&quot;&gt;&lt;code&gt;$Config{archname}&lt;/code&gt;&lt;/a&gt; may depend on the hardware architecture, it can vary more than the value of &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;config#archname&quot;&gt; &lt;code&gt;$Config{archname}&lt;/code&gt; &lt;/a&gt;の値はハードウェアアーキテクチャに依存する可能性があるため、&lt;a href=&quot;perlvar#%24%5EO&quot;&gt; &lt;code&gt;$^O&lt;/code&gt; &lt;/a&gt;値よりも大きく異なる可能性があります。</target>
        </trans-unit>
        <trans-unit id="2e5bc19b54b9930fd5e2dcb3e6dfb795d20462ff" translate="yes" xml:space="preserve">
          <source>Because the value of &lt;code&gt;$Config{archname}&lt;/code&gt; may depend on the hardware architecture, it can vary more than the value of &lt;code&gt;$^O&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$Config{archname}&lt;/code&gt; の値はハードウェアアーキテクチャに依存する可能性があるため、 &lt;code&gt;$^O&lt;/code&gt; 値よりも変動する可能性があります。</target>
        </trans-unit>
        <trans-unit id="e90ed527002ad403540a55eb78d4c5ab847fcd41" translate="yes" xml:space="preserve">
          <source>Because the values line may contain arbitrary expressions (for at fields, not caret fields), you can farm out more sophisticated processing to other functions, like sprintf() or one of your own. For example:</source>
          <target state="translated">値の行には任意の式が含まれている可能性があるので (キャレットフィールドではなくアットフィールドに対して)、より洗練された処理を他の関数 (sprintf()や独自の関数のいずれか)に委託することができます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="d8bc8ec23c88de9efd45beeefb8be0639f500936" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">変数は &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; の直後に有効になるため、その名前の変数がすでにスコープ内にない限り、同じステートメント内でもパッケージ変数を再び参照できます。</target>
        </trans-unit>
        <trans-unit id="da44b03f12b50aea312686ca3a3d0b93a5cee3d2" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">変数は &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; の直後に有効になるため、その名前の変数がすでにスコープ内にない限り、同じステートメント内でもパッケージ変数を再び参照できます。</target>
        </trans-unit>
        <trans-unit id="10adcfecf1a02c362d02294237aa3b65ee35acfd" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;use strict 'vars'&lt;/code&gt;, so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">変数は、 &lt;code&gt;use strict 'vars'&lt;/code&gt; とすぐに有効になるため、その名前の変数が既にスコープ内にない限り、同じステートメント内でもパッケージ変数を再度参照できます。</target>
        </trans-unit>
        <trans-unit id="1213676c8b2ebcfdeacd60c8eeb78e070a8906e8" translate="yes" xml:space="preserve">
          <source>Because there are more than three arguments to open(), forks the ps(1) command</source>
          <target state="translated">open()には 3 つ以上の引数があるので、ps(1)コマンドをフォーク。</target>
        </trans-unit>
        <trans-unit id="327e12e185eccd28ae382163925adec0406495ff" translate="yes" xml:space="preserve">
          <source>Because there are more than three arguments to open(), it forks the ps(1) command</source>
          <target state="translated">open()には三つ以上の引数があるので、ps(1)コマンドをフォークします。</target>
        </trans-unit>
        <trans-unit id="63c371b01d835f1b3e60dfea4284b4178cc48a57" translate="yes" xml:space="preserve">
          <source>Because there are people who have their precise expectations about who may install where in the @INC path and who uses which @INC array. In fine tuned environments &lt;code&gt;UNINST=1&lt;/code&gt; can cause damage.</source>
          <target state="translated">なぜなら、@ INCパスのどこに誰がインストールし、どの@INC配列を使用するかについて、正確な期待を持つ人がいるからです。微調整された環境では、 &lt;code&gt;UNINST=1&lt;/code&gt; は損傷を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="61339e91fc8e465df58897366d437a1f422fcc97" translate="yes" xml:space="preserve">
          <source>Because there is currently no way for a distribution to specify a dependency on an optional feature of another dependency, the use of &lt;code&gt;optional_feature&lt;/code&gt; is discouraged. Instead, create a separate, installable distribution that ensures the desired feature is available. For example, if &lt;code&gt;Foo::Bar&lt;/code&gt; has a &lt;code&gt;Baz&lt;/code&gt; feature, release a separate &lt;code&gt;Foo-Bar-Baz&lt;/code&gt; distribution that satisfies requirements for the feature.</source>
          <target state="translated">現在、別の依存関係のオプション機能への依存を指定する配布方法はありませんので、使用 &lt;code&gt;optional_feature&lt;/code&gt; が推奨されていません。代わりに、目的の機能が確実に利用できるように、個別のインストール可能なディストリビューションを作成してください。たとえば、 &lt;code&gt;Foo::Bar&lt;/code&gt; に &lt;code&gt;Baz&lt;/code&gt; 機能がある場合は、その機能の要件を満たす別の &lt;code&gt;Foo-Bar-Baz&lt;/code&gt; ディストリビューションをリリースします。</target>
        </trans-unit>
        <trans-unit id="b691163394a932e3f6d352ebd6e7cd633110d322" translate="yes" xml:space="preserve">
          <source>Because these resource objects are considered to be owned by the entire process/system, and not the &quot;property&quot; of whatever is being serialized, no references underneath the object should be included in the serialized string. Thus, in any class that implements &lt;code&gt;STORABLE_attach&lt;/code&gt; , the &lt;code&gt;STORABLE_freeze&lt;/code&gt; method cannot return any references, and &lt;code&gt;Storable&lt;/code&gt; will throw an error if &lt;code&gt;STORABLE_freeze&lt;/code&gt; tries to return references.</source>
          <target state="translated">これらのリソースオブジェクトは、シリアル化されているものの「プロパティ」ではなく、プロセス/システム全体によって所有されていると見なされるため、オブジェクトの下の参照をシリアル化された文字列に含めないでください。したがって、 &lt;code&gt;STORABLE_attach&lt;/code&gt; を実装するクラスでは、 &lt;code&gt;STORABLE_freeze&lt;/code&gt; メソッドは参照を返すことができず、 &lt;code&gt;Storable&lt;/code&gt; が参照を &lt;code&gt;STORABLE_freeze&lt;/code&gt; うとすると、Storableはエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="26af08e2f43bfef9b9e40cba2b2ed696b0549e29" translate="yes" xml:space="preserve">
          <source>Because these resource objects are considered to be owned by the entire process/system, and not the &quot;property&quot; of whatever is being serialized, no references underneath the object should be included in the serialized string. Thus, in any class that implements &lt;code&gt;STORABLE_attach&lt;/code&gt;, the &lt;code&gt;STORABLE_freeze&lt;/code&gt; method cannot return any references, and &lt;code&gt;Storable&lt;/code&gt; will throw an error if &lt;code&gt;STORABLE_freeze&lt;/code&gt; tries to return references.</source>
          <target state="translated">これらのリソースオブジェクトは、シリアル化されているものの「プロパティ」ではなく、プロセス/システム全体によって所有されていると見なされるため、オブジェクトの下の参照をシリアル化された文字列に含めることはできません。したがって、 &lt;code&gt;STORABLE_attach&lt;/code&gt; を実装するクラスでは、 &lt;code&gt;STORABLE_freeze&lt;/code&gt; メソッドは参照を返すことができず、 &lt;code&gt;Storable&lt;/code&gt; が参照を &lt;code&gt;STORABLE_freeze&lt;/code&gt; うとすると、Storableはエラーをスローします。</target>
        </trans-unit>
        <trans-unit id="e58a7f2a84e13b9fada5ed77ade53adda8ab6513" translate="yes" xml:space="preserve">
          <source>Because this command is in some senses new, a warning is issued if you appear to have accidentally entered a block instead. If that's what you mean to do, write it as with &lt;code&gt;;{ ... }&lt;/code&gt; or even &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { ... }&lt;/code&gt; .</source>
          <target state="translated">このコマンドはある意味で新しいため、誤ってブロックを入力したように見える場合は警告が発行されます。それはあなたがする何を意味するかだ場合は、のようにそれを書く &lt;code&gt;;{ ... }&lt;/code&gt; あるいは &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { ... }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74266b6323d7ce62912d6c101e78cdb916449da7" translate="yes" xml:space="preserve">
          <source>Because this command is in some senses new, a warning is issued if you appear to have accidentally entered a block instead. If that's what you mean to do, write it as with &lt;code&gt;;{ ... }&lt;/code&gt; or even &lt;code&gt;do { ... }&lt;/code&gt;.</source>
          <target state="translated">このコマンドはある意味で新しいため、代わりに誤ってブロックに入ったように見える場合は警告が発行されます。それがあなたの意図することであるなら、 &lt;code&gt;;{ ... }&lt;/code&gt; ように書くか、{...}を &lt;code&gt;do { ... }&lt;/code&gt; てください。</target>
        </trans-unit>
        <trans-unit id="afe0d4d00dfd6cabe863bda5f9354b347e13a163" translate="yes" xml:space="preserve">
          <source>Because this construct compiles under &lt;a href=&quot;re#%27strict%27-mode&quot;&gt;&lt;code&gt;use re 'strict&lt;/code&gt;&lt;/a&gt;, unrecognized escapes that generate warnings in normal classes are fatal errors here, as well as all other warnings from these class elements, as well as some practices that don't currently warn outside &lt;code&gt;re 'strict'&lt;/code&gt;. For example you cannot say</source>
          <target state="translated">このコンストラクトはre'strictを&lt;a href=&quot;re#%27strict%27-mode&quot;&gt; &lt;code&gt;use re 'strict&lt;/code&gt; &lt;/a&gt;してコンパイルされるため、通常のクラスで警告を生成する認識されないエスケープは、ここでは致命的なエラーであり、これらのクラス要素からの他のすべての警告、および現在re'strict &lt;code&gt;re 'strict'&lt;/code&gt; 外部で警告しないいくつかのプラクティスです。。たとえば、あなたは言うことはできません</target>
        </trans-unit>
        <trans-unit id="e618c1116f848d64cf69ade37db078db462072bd" translate="yes" xml:space="preserve">
          <source>Because this function operates at the byte level, and because of the inherent characteristics of UTF-8 (or UTF-EBCDIC), it will work properly if both the needle and the haystack are strings with the same UTF-8ness, but not if the UTF-8ness differs.</source>
          <target state="translated">この関数はバイトレベルで動作し、UTF-8(またはUTF-EBCDIC)に固有の特性があるため、針と干し草の両方が同じUTF-8度の文字列であれば正常に動作しますが、UTF-8度が異なる場合は動作しません。</target>
        </trans-unit>
        <trans-unit id="efa88e36be50b169e959caa4254fea74155063be" translate="yes" xml:space="preserve">
          <source>Because this function uses mktemp(), it can suffer from race conditions.</source>
          <target state="translated">この関数は mktemp()を使用するため、競合状態に陥る可能性があります。</target>
        </trans-unit>
        <trans-unit id="2478181856508c1cc91e32c539a156e07c17eb63" translate="yes" xml:space="preserve">
          <source>Because this information is not stored within the perl executable itself it is possible (but unlikely) that the information does not relate to the actual perl binary which is being used to access it.</source>
          <target state="translated">この情報はPerl実行ファイル自体の中には保存されていないので、情報がアクセスに使用されている実際のPerlバイナリに関連していない可能性があります(可能性は低いですが)。</target>
        </trans-unit>
        <trans-unit id="ad52e097251691a48fd57b8bdbc852cffc9bb5f6" translate="yes" xml:space="preserve">
          <source>Because this is a wide-open interface, pragmas (compiler directives) are also implemented this way. Currently implemented pragmas are:</source>
          <target state="translated">これはオープンなインターフェイスなので、プラグマ(コンパイラディレクティブ)もこのように実装されています。現在実装されているプラグマは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="872c328b526f9b9864d2cfe0b4165fd06ef13624" translate="yes" xml:space="preserve">
          <source>Because this is a wide-open interface, pragmas (compiler directives) are also implemented this way. Some of the currently implemented pragmas are:</source>
          <target state="translated">これはオープンなインターフェイスなので、プラグマ(コンパイラディレクティブ)もこのように実装されています。現在実装されているプラグマのいくつかを紹介します。</target>
        </trans-unit>
        <trans-unit id="e8055a645160d58d1aa3758824d7f3046e3cd0a9" translate="yes" xml:space="preserve">
          <source>Because this operator produces an assignable result, using assignments without parentheses will get you in trouble. For example, this:</source>
          <target state="translated">この演算子は代入可能な結果を生成するので、括弧なしの代入を使用すると問題が発生します。例えば、これは</target>
        </trans-unit>
        <trans-unit id="cda353c8b2d143f02b4da6818d79c64f57fb0765" translate="yes" xml:space="preserve">
          <source>Because this promotes action at a distance, this counterintuitive behavior may be fixed in a future release.</source>
          <target state="translated">これは距離を置いて行動することを促進するため、この直観的でない動作は将来のリリースで修正される可能性があります。</target>
        </trans-unit>
        <trans-unit id="ece57b9cb9008cd6f8ed94726d6205b9428981dc" translate="yes" xml:space="preserve">
          <source>Because thread creation and thread joining may occur in different contexts, it may be desirable to state the context explicitly to the thread's entry point function. This may be done by calling &lt;code&gt;-&amp;gt;create()&lt;/code&gt; with a hash reference as the first argument:</source>
          <target state="translated">スレッドの作成と結合は異なるコンテキストで発生する可能性があるため、スレッドのエントリポイント関数にコンテキストを明示的に示すことが望ましい場合があります。これは、最初の引数としてハッシュ参照を指定して &lt;code&gt;-&amp;gt;create()&lt;/code&gt; を呼び出すことで実行できます。</target>
        </trans-unit>
        <trans-unit id="a311abdd84d17ec36b9f35316e74bcbefa1ccdb8" translate="yes" xml:space="preserve">
          <source>Because variable references always start with '$', '@', or '%', the &quot;reserved&quot; words aren't in fact reserved with respect to variable names. They</source>
          <target state="translated">変数参照は常に '$'、'@'、または '%' で始まるので、「予約済み」の単語は実際には変数名に関して予約されているわけではありません。予約されているのは</target>
        </trans-unit>
        <trans-unit id="cf7852aa0f7da3fa109ef4464da14b644fe19dd6" translate="yes" xml:space="preserve">
          <source>Because various errors may only be detected by close() (e.g. buffering could allow the &lt;code&gt;print&lt;/code&gt; in this example to return true even when the disk is full), it is dangerous to ignore its result. So when it happens implicitly, perl will signal errors by warning.</source>
          <target state="translated">さまざまなエラーはclose（）によってのみ検出される可能性があるため（たとえば、バッファリングにより、ディスクがいっぱいの場合でもこの例の出力がtrueを返す可能性があり &lt;code&gt;print&lt;/code&gt; ）、その結果を無視するのは危険です。したがって、暗黙的に発生すると、perlは警告によってエラーを通知します。</target>
        </trans-unit>
        <trans-unit id="0ac64477279b51b2f8ca41484de7b49285b3815c" translate="yes" xml:space="preserve">
          <source>Because we are now concerned with the return value from</source>
          <target state="translated">からの戻り値に注目しています。</target>
        </trans-unit>
        <trans-unit id="9befd612f9b4e3c124f9ec128a96394cb71cf6fb" translate="yes" xml:space="preserve">
          <source>Because we are using an SV to call</source>
          <target state="translated">を呼び出すためにSVを使用しているため</target>
        </trans-unit>
        <trans-unit id="ded04a0cee8ca9e46b88306d00153b5faa51a410" translate="yes" xml:space="preserve">
          <source>Because we created temporary values (by means of sv_2mortal() calls) we will have to tidy up the Perl stack and dispose of mortal SVs.</source>
          <target state="translated">(sv_2mortal()の呼び出しによって)一時的な値を作成したので、Perl のスタックを整理して、死亡した SV を処分しなければなりません。</target>
        </trans-unit>
        <trans-unit id="aa34046474e322c81f9b04585e1a1d3d975224ac" translate="yes" xml:space="preserve">
          <source>Because we specified G_DISCARD, it is not necessary to check the value returned from</source>
          <target state="translated">G_DISCARDを指定しているので</target>
        </trans-unit>
        <trans-unit id="941fe97debd1bfb6b702aacc07a44435ca4e56b7" translate="yes" xml:space="preserve">
          <source>Because when &lt;code&gt;autochomp&lt;/code&gt; is disabled, &lt;code&gt;$a[10]&lt;/code&gt; will read back as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (or whatever the record separator string is.)</source>
          <target state="translated">&lt;code&gt;autochomp&lt;/code&gt; が無効になっている場合、 &lt;code&gt;$a[10]&lt;/code&gt; は &lt;code&gt;&quot;\n&quot;&lt;/code&gt; （またはレコード区切り文字列が何であれ）として読み返されます。</target>
        </trans-unit>
        <trans-unit id="b0a17ee4f4c080e1c09fd835e1c924855560fcaf" translate="yes" xml:space="preserve">
          <source>Because you just moved the existing &lt;b&gt;stdout&lt;/b&gt; to somewhere else.</source>
          <target state="translated">既存の&lt;b&gt;標準出力&lt;/b&gt;を別の場所に移動しただけだからです。</target>
        </trans-unit>
        <trans-unit id="aa628e92b3c4d485e932ec48525c963ebb2f9c63" translate="yes" xml:space="preserve">
          <source>Because you're using something like this, which truncates the file</source>
          <target state="translated">というのも、このようにファイルを切り捨てるようなものを使っているからです。</target>
        </trans-unit>
        <trans-unit id="230b0b84c4580dce513ede6c977fdc5dbaffa5e2" translate="yes" xml:space="preserve">
          <source>Before Perl 5.10, setting &lt;code&gt;$*&lt;/code&gt; to a true value globally enabled multi-line matching within a string. This relique from the past lost its special meaning in 5.10. Use of this variable will be a fatal error in Perl 5.30, freeing the variable up for a future special meaning.</source>
          <target state="translated">Perl 5.10より前では、 &lt;code&gt;$*&lt;/code&gt; をtrue値に設定すると、文字列内でグローバルに有効化された複数行のマッチングが可能になりました。過去からのこの聖遺物は5.10でその特別な意味を失いました。この変数を使用すると、Perl 5.30で致命的なエラーが発生し、将来の特別な意味のために変数が解放されます。</target>
        </trans-unit>
        <trans-unit id="973ca6acb768a5dd6330a5eade0b5d4dbc53ee84" translate="yes" xml:space="preserve">
          <source>Before Perl 5.10.0 and 5.8.8, PERL5SHELL was not taint checked when running external commands. It is recommended that you explicitly set (or delete) &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; when running in taint mode under Windows.</source>
          <target state="translated">Perl 5.10.0および5.8.8より前のバージョンでは、外部コマンドの実行時にPERL5SHELLは汚染チェックされませんでした。Windowsで汚染モードで実行する場合は、 &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; を明示的に設定（または削除）することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ebab29b2af9a7a7c7ceefc18fae2257d84323d02" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the assignment to &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; occurred before restoration of localized variables, which means that for your code to run on older versions, a temporary is required if you want to mask some, but not all errors:</source>
          <target state="translated">Perl 5.14より前では、&lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt;への割り当てはローカライズされた変数の復元前に発生していました。つまり、コードを古いバージョンで実行するには、すべてではなく一部のエラーをマスクする場合に一時的なものが必要です。</target>
        </trans-unit>
        <trans-unit id="36d386f00504590e35abdcaf1bc115cbe7c02503" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the assignment to &lt;code&gt;$@&lt;/code&gt; occurred before restoration of localized variables, which means that for your code to run on older versions, a temporary is required if you want to mask some but not all errors:</source>
          <target state="translated">Perl 5.14 より前は、ローカライズされた変数を復元する前に &lt;code&gt;$@&lt;/code&gt; への割り当てが行われていました。つまり、古いバージョンでコードを実行するには、すべてではなく一部のエラーをマスクしたい場合に一時ファイルが必要です。</target>
        </trans-unit>
        <trans-unit id="512488ae279d498c1ee81f682f1f53229da4c6e2" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the relation between overloading and tie()ing was broken. Overloading was triggered or not based on the</source>
          <target state="translated">Perl 5.14 より前のバージョンでは、オーバーロードと tie()ing の関係が壊れていました。オーバーロードは</target>
        </trans-unit>
        <trans-unit id="b34cea36bce317a875588bd1ba293a621fd141d4" translate="yes" xml:space="preserve">
          <source>Before Perl 5.18, &lt;code&gt;given(EXPR)&lt;/code&gt; assigned the value of</source>
          <target state="translated">Perl 5.18より前では、 &lt;code&gt;given(EXPR)&lt;/code&gt; は次の値を割り当てました</target>
        </trans-unit>
        <trans-unit id="8ed431b288a3361b742578011935581f2edfcced" translate="yes" xml:space="preserve">
          <source>Before Perl 5.28, the returned values are unreliable for the &lt;code&gt;RADIXCHAR&lt;/code&gt; and &lt;code&gt;THOUSEP&lt;/code&gt; locale constants.</source>
          <target state="translated">Perl 5.28より前では、戻り値は &lt;code&gt;RADIXCHAR&lt;/code&gt; および &lt;code&gt;THOUSEP&lt;/code&gt; ロケール定数に対して信頼できません。</target>
        </trans-unit>
        <trans-unit id="0ba6dd90f594f9b5d19255a91f0ae4487b358318" translate="yes" xml:space="preserve">
          <source>Before Perl 5.6, you had to use the &lt;code&gt;*FH&lt;/code&gt; or &lt;code&gt;\*FH&lt;/code&gt; notations. These are &quot;typeglobs&quot;--see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;&quot;Typeglobs and Filehandles&quot; in perldata&lt;/a&gt; and especially &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;&quot;Pass by Reference&quot; in perlsub&lt;/a&gt; for more information.</source>
          <target state="translated">Perl 5.6より前は、 &lt;code&gt;*FH&lt;/code&gt; または &lt;code&gt;\*FH&lt;/code&gt; 表記を使用する必要がありました。これらは「&lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;typeglobs&lt;/a&gt;」です。詳細については、perldataの「Typeglobsand Filehandles」、特に&lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;perlsubの「&lt;/a&gt;PassbyReference 」を参照してください。</target>
        </trans-unit>
        <trans-unit id="54445efd0dc2c1e8891bd0fe2ff854e28637df1f" translate="yes" xml:space="preserve">
          <source>Before Perl 5.6, you had to use the &lt;code&gt;*FH&lt;/code&gt; or &lt;code&gt;\*FH&lt;/code&gt; notations. These are &quot;typeglobs&quot;--see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;Typeglobs and Filehandles in perldata&lt;/a&gt; and especially &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;Pass by Reference in perlsub&lt;/a&gt; for more information.</source>
          <target state="translated">Perl 5.6以前は、 &lt;code&gt;*FH&lt;/code&gt; または &lt;code&gt;\*FH&lt;/code&gt; 表記を使用する必要がありました。これらは「&lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;タイプ&lt;/a&gt;グロブ」です。詳細については、perldataのタイプグロブとファイルハンドル、特に&lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;perlsubの参照渡しを参照し&lt;/a&gt;てください。</target>
        </trans-unit>
        <trans-unit id="2df4fb0a98f840a2555a3347deeff121cc142591" translate="yes" xml:space="preserve">
          <source>Before Perl 5.8.0, installing Perl code to deal with signals exposed you to danger from two things. First, few system library functions are re-entrant. If the signal interrupts while Perl is executing one function (like malloc(3) or printf(3)), and your signal handler then calls the same function again, you could get unpredictable behavior--often, a core dump. Second, Perl isn't itself re-entrant at the lowest levels. If the signal interrupts Perl while Perl is changing its own internal data structures, similarly unpredictable behavior may result.</source>
          <target state="translated">Perl 5.8.0以前では、シグナルを扱うためにPerlのコードをインストールすると、2つのことから危険にさらされていました。まず、いくつかのシステムライブラリ関数がリエントラントになっています。Perl がある関数(malloc(3)や printf(3)のような)を実行している間にシグナルが割り込み、シグナルハンドラが同じ関数を再び呼び出すと、予測不可能な動作をする可能性があり、しばしばコアダンプが発生します。第二に、Perl は最低レベルではそれ自体がリエントラントではありません。Perl が内部データ構造を変更している間にシグナルが Perl を割り込み、同様に予測不可能な動作をする可能性があります。</target>
        </trans-unit>
        <trans-unit id="870cc998eebf778ddd06bc7ed2f1805b37f31d55" translate="yes" xml:space="preserve">
          <source>Before Perl v5.8.0, the use of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; was used to declare that operations in the current block or file would be Unicode-aware. This model was found to be wrong, or at least clumsy: the &quot;Unicodeness&quot; is now carried with the data, instead of being attached to the operations. Starting with Perl v5.8.0, only one case remains where an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
utf8&lt;/code&gt; is needed: if your Perl script itself is encoded in UTF-8, you can use UTF-8 in your identifier names, and in string and regular expression literals, by saying &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; . This is not the default because scripts with legacy 8-bit data in them would break. See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;.</source>
          <target state="translated">Perl v5.8.0より前は、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; を使用して、現在のブロックまたはファイルでの操作がUnicode対応であることを宣言していました。このモデルは間違っているか、少なくとも不器用であることがわかりました。「Unicodeness」は、操作に添付されるのではなく、データとともに保持されるようになりました。 Perl v5.8.0以降、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 明示的に&lt;a href=&quot;functions/use&quot;&gt;使用する&lt;/a&gt;必要があるケースは1つだけ残っています。Perl スクリプト自体がUTF-8でエンコードされている場合、識別子名と文字列および正規表現リテラルでUTF-8を使用できます。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; と言ってください。レガシー8ビットデータが含まれているスクリプトは破損するため、これはデフォルトではありません。&lt;a href=&quot;utf8&quot;&gt;utf8を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4fa99c9f82e7be9fceb5a0c188011fae1cb7cad5" translate="yes" xml:space="preserve">
          <source>Before Perl v5.8.0, the use of &lt;code&gt;use utf8&lt;/code&gt; was used to declare that operations in the current block or file would be Unicode-aware. This model was found to be wrong, or at least clumsy: the &quot;Unicodeness&quot; is now carried with the data, instead of being attached to the operations. Starting with Perl v5.8.0, only one case remains where an explicit &lt;code&gt;use utf8&lt;/code&gt; is needed: if your Perl script itself is encoded in UTF-8, you can use UTF-8 in your identifier names, and in string and regular expression literals, by saying &lt;code&gt;use utf8&lt;/code&gt;. This is not the default because scripts with legacy 8-bit data in them would break. See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;.</source>
          <target state="translated">Perl v5.8.0より前は、 &lt;code&gt;use utf8&lt;/code&gt; を使用して、現在のブロックまたはファイルでの操作がUnicode対応であることを宣言していました。このモデルは間違っているか、少なくとも不器用であることが判明しました。「ユニコードネス」は、操作に関連付けられるのではなく、データとともに運ばれるようになりました。 Perl v5.8.0以降、 &lt;code&gt;use utf8&lt;/code&gt; 明示的に使用する必要があるケースは1つだけです。Perlスクリプト自体がUTF-8でエンコードされている場合は、識別子名、文字列、正規表現リテラルでUTF-8を使用できます。 &lt;code&gt;use utf8&lt;/code&gt; すると言うことによって。従来の8ビットデータを含むスクリプトが破損するため、これはデフォルトではありません。&lt;a href=&quot;utf8&quot;&gt;utf8を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="04e04ef0cf482846e31d6720b49ae41928208ea3" translate="yes" xml:space="preserve">
          <source>Before Unicode, most encodings used 8 bits (a single byte) to encode each character. Thus a character was a byte, and a byte was a character, and there could be only 256 or fewer possible characters. &quot;Byte Semantics&quot; in the title of this section refers to this behavior. There was no need to distinguish between &quot;Byte&quot; and &quot;Character&quot;.</source>
          <target state="translated">Unicode以前は、ほとんどのエンコーディングは各文字をエンコードするために8ビット(1バイト)を使用していました。したがって、1 文字は 1 バイトであり、1 バイトは 1 文字であり、可能な文字は 256 文字かそれ以下しかありませんでした。このセクションのタイトルにある &quot;Byte Semantics &quot;は、この動作を指しています。バイト」と「文字」を区別する必要はありませんでした。</target>
        </trans-unit>
        <trans-unit id="98f333eb7b1048c01de83e53fdf2f8f76121657f" translate="yes" xml:space="preserve">
          <source>Before Unicode, when a character was a byte was a character, Perl knew only about the 128 characters defined by ASCII, code points 0 through 127 (except for under &lt;a href=&quot;perllocale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt;). That left the code points 128 to 255 as unassigned, and available for whatever use a program might want. The only semantics they have is their ordinal numbers, and that they are members of none of the non-negative character classes. None are considered to match &lt;code&gt;\w&lt;/code&gt; for example, but all match &lt;code&gt;\W&lt;/code&gt;.</source>
          <target state="translated">Unicodeの前は、文字がバイトである場合、PerlはASCIIで定義された128文字、コードポイント0〜127（&lt;a href=&quot;perllocale&quot;&gt; &lt;code&gt;use locale&lt;/code&gt; &lt;/a&gt;を除く）についてのみ知っていました。そのため、コードポイント128〜255は割り当てられておらず、プログラムが必要とするあらゆる用途に使用できます。それらが持つ唯一のセマンティクスは序数であり、それらは非負の文字クラスのいずれのメンバーでもありません。たとえば、 &lt;code&gt;\w&lt;/code&gt; に一致すると見なされるものはありませんが、すべて &lt;code&gt;\W&lt;/code&gt; 一致します。</target>
        </trans-unit>
        <trans-unit id="290d67ae3ee387c5e4e99c79148af4efc4e204f2" translate="yes" xml:space="preserve">
          <source>Before Unicode, when a character was a byte was a character, Perl knew only about the 128 characters defined by ASCII, code points 0 through 127 (except for under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ). That left the code points 128 to 255 as unassigned, and available for whatever use a program might want. The only semantics they have is their ordinal numbers, and that they are members of none of the non-negative character classes. None are considered to match &lt;code&gt;\w&lt;/code&gt; for example, but all match &lt;code&gt;\W&lt;/code&gt; .</source>
          <target state="translated">文字はバイトが文字であったときUnicodeの前に、PerlはASCIIのみによって定義された128個の文字を知っていた、コードポイント0〜127（下を除いて &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ）。これにより、コードポイント128〜255が割り当てられず、プログラムが必要とするあらゆる用途に使用できるようになりました。それらが持つ唯一のセマンティクスは序数であり、非負の文字クラスのメンバーではありません。たとえば、 &lt;code&gt;\w&lt;/code&gt; と一致するとは見なされませんが、すべて &lt;code&gt;\W&lt;/code&gt; 一致します。</target>
        </trans-unit>
        <trans-unit id="d690a12b540a565baadfa57c599d5a868691200d" translate="yes" xml:space="preserve">
          <source>Before any command has executed or if an unexpected error occurs &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return undef.</source>
          <target state="translated">コマンドが実行される前、または予期しないエラーが発生した場合、 &lt;code&gt;code()&lt;/code&gt; は &quot;421&quot;（一時的な接続障害 &lt;code&gt;message()&lt;/code&gt; を返し、message（）はundefを返します。</target>
        </trans-unit>
        <trans-unit id="752f8552c1f4e0b002a40cffe2d75752a7a074d6" translate="yes" xml:space="preserve">
          <source>Before anything else, you need a testing plan. This basically declares how many tests your script is going to run to protect against premature failure.</source>
          <target state="translated">何かをする前に、テスト計画が必要です。これは基本的に、早期の失敗を防ぐためにスクリプトを実行するテストの数を宣言するものです。</target>
        </trans-unit>
        <trans-unit id="62bd9b6df52b51e065387fd43e36061f890b0944" translate="yes" xml:space="preserve">
          <source>Before calling copy() or move() on a filehandle, the caller should close or flush() the file to avoid writes being lost. Note that this is the case even for move(), because it may actually copy the file, depending on the OS-specific implementation, and the underlying filesystem(s).</source>
          <target state="translated">ファイルハンドル上で copy()や move()を呼び出す前に、呼び出し元は書き込みが失われないようにファイルを閉じるか flush()しなければなりません。これは、move()の場合でも同様であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="4bb0c278106c5fac84e8a238d47e490b85a41fa5" translate="yes" xml:space="preserve">
          <source>Before installing the patches to the IBM C-compiler you need to know the level of patching for the Operating System. IBM's command 'oslevel' will show the base, but is not always complete (in this example oslevel shows 4.3.NULL, whereas the system might run most of 4.3.THREE):</source>
          <target state="translated">IBM C-コンパイラにパッチをインストールする前に、オペレーティングシステムのパッチのレベルを知る必要があります。IBM のコマンド 'oslevel' はベースを表示しますが、必ずしも完全ではありません (この例では oslevel は 4.3.NULL を表示していますが、システムは 4.3.THREE のほとんどを実行しているかもしれません)。</target>
        </trans-unit>
        <trans-unit id="b46ac14ab9ac97916ee87fb2735b65fa3bcb3084" translate="yes" xml:space="preserve">
          <source>Before perl5.6, you had to deal with various typeglob idioms which you may see in older code.</source>
          <target state="translated">perl5.6以前では、古いコードで見られるような様々なタイプグローブイディオムを扱う必要がありました。</target>
        </trans-unit>
        <trans-unit id="cb7ffbda991b922f283aad1fac8b7fea6f1f3918" translate="yes" xml:space="preserve">
          <source>Before pushing</source>
          <target state="translated">押す前に</target>
        </trans-unit>
        <trans-unit id="84ceb0c5361b0c57292563baaff9c21803203fbb" translate="yes" xml:space="preserve">
          <source>Before pushing any change to a maint version, make sure you've satisfied the steps in &lt;a href=&quot;#Committing-to-blead&quot;&gt;&quot;Committing to blead&quot;&lt;/a&gt; above.</source>
          <target state="translated">maintバージョンへの変更をプッシュする前に、上記の&lt;a href=&quot;#Committing-to-blead&quot;&gt;「コミットする」&lt;/a&gt;の手順を満たしていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="4d24253ab2fd2c805f0d6bcaca41ee8bd8627285" translate="yes" xml:space="preserve">
          <source>Before release 5 of Perl it was difficult to represent complex data structures, because all references had to be symbolic--and even then it was difficult to refer to a variable instead of a symbol table entry. Perl now not only makes it easier to use symbolic references to variables, but also lets you have &quot;hard&quot; references to any piece of data or code. Any scalar may hold a hard reference. Because arrays and hashes contain scalars, you can now easily build arrays of arrays, arrays of hashes, hashes of arrays, arrays of hashes of functions, and so on.</source>
          <target state="translated">Perl のリリース 5 以前は、複雑なデータ構造を表現することは困難でした。なぜなら、すべての参照はシンボリックでなければならなかったからです。Perlでは、変数へのシンボリック参照をより簡単に使えるようになっただけでなく、どんなデータやコードに対しても「ハード」参照を持つことができるようになりました。どんなスカラでもハード参照を保持することができます。配列やハッシュにはスカラが含まれているので、配列の配列、ハッシュの配列、配列のハッシュ、関数のハッシュの配列などを簡単に作ることができるようになりました。</target>
        </trans-unit>
        <trans-unit id="ef266fb9e8f6dafd9b23077a1b88d8327a3a9667" translate="yes" xml:space="preserve">
          <source>Before submitting a bug, please make sure that the traditional method of building a Perl module package from a shell by following the installation instructions of that package still works in your environment.</source>
          <target state="translated">バグを提出する前に、シェルからPerlモジュールパッケージを構築する従来の方法が、そのパッケージのインストール手順に従っているかどうかを、あなたの環境で動作することを確認してください。</target>
        </trans-unit>
        <trans-unit id="852a62fb5185caad446c6f66da79350d77dac37e" translate="yes" xml:space="preserve">
          <source>Before terminating, the &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function must explicitly install the filter by calling &lt;code&gt;filter_add&lt;/code&gt; .</source>
          <target state="translated">終了する前に、 &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 関数は &lt;code&gt;filter_add&lt;/code&gt; を呼び出してフィルターを明示的にインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="c19a9bcc3d0fce58bd4d9d25f82f4cb8c5d35503" translate="yes" xml:space="preserve">
          <source>Before terminating, the &lt;code&gt;import&lt;/code&gt; function must explicitly install the filter by calling &lt;code&gt;filter_add&lt;/code&gt;.</source>
          <target state="translated">終了する前に、 &lt;code&gt;import&lt;/code&gt; 関数は &lt;code&gt;filter_add&lt;/code&gt; を呼び出してフィルターを明示的にインストールする必要があります。</target>
        </trans-unit>
        <trans-unit id="f512253f81c2fd706ba28a9ad84dc13dc48c3eb8" translate="yes" xml:space="preserve">
          <source>Before the Perl interpreter can execute a Perl script, it must first read it from a file into memory for parsing and compilation. If that script itself includes other scripts with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement, then each of those scripts will have to be read from their respective files as well.</source>
          <target state="translated">Perlインタプリタは、Perlスクリプトを実行する前に、まず解析してコンパイルするためにファイルからメモリに読み込む必要があります。そのスクリプト自体に、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ステートメントを含む他のスクリプトが含まれている場合、それらの各スクリプトは、それぞれのファイルからも読み取る必要があります。</target>
        </trans-unit>
        <trans-unit id="c6081a0bc2c6ca5d40e9bce0501b5e221be236ae" translate="yes" xml:space="preserve">
          <source>Before the Perl interpreter can execute a Perl script, it must first read it from a file into memory for parsing and compilation. If that script itself includes other scripts with a &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; statement, then each of those scripts will have to be read from their respective files as well.</source>
          <target state="translated">PerlインタプリタがPerlスクリプトを実行する前に、解析とコンパイルのために、まずファイルからメモリにスクリプトを読み込む必要があります。そのスクリプト自体に &lt;code&gt;use&lt;/code&gt; または &lt;code&gt;require&lt;/code&gt; ステートメントを含む他のスクリプトが含まれている場合、それらの各スクリプトもそれぞれのファイルから読み取る必要があります。</target>
        </trans-unit>
        <trans-unit id="7056378ac690eaab80565ece696557496384c5bd" translate="yes" xml:space="preserve">
          <source>Before the introduction of Unicode support in Perl, The &lt;code&gt;eq&lt;/code&gt; operator just compared the strings represented by two scalars. Beginning with Perl 5.8, &lt;code&gt;eq&lt;/code&gt; compares two strings with simultaneous consideration of</source>
          <target state="translated">PerlでUnicodeサポートが導入される前は、 &lt;code&gt;eq&lt;/code&gt; 演算子は2つのスカラーで表される文字列を比較していました。Perl 5.8以降、 &lt;code&gt;eq&lt;/code&gt; は 2つの文字列を比較し、同時に</target>
        </trans-unit>
        <trans-unit id="07d7d02c48129829b963f0f9c3efb3625c646877" translate="yes" xml:space="preserve">
          <source>Before the introduction of lexical warnings, Perl had two classes of warnings: mandatory and optional.</source>
          <target state="translated">語彙的警告が導入される前は、Perl には必須とオプションの 2 つの警告がありました。</target>
        </trans-unit>
        <trans-unit id="759cf8f89c69b1e5d0ddf3e544f843b8c5c70ae3" translate="yes" xml:space="preserve">
          <source>Before we even start scraping out the code, there are a few things we'll want to do in advance.</source>
          <target state="translated">コードを掻き出す前に、事前にやっておきたいことがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="a2896a2a84e6fb1618d5a02150eb4f976c910264" translate="yes" xml:space="preserve">
          <source>Before we go any further, you'll want to know how to quit the debugger: use just the letter '&lt;b&gt;q&lt;/b&gt;', not the words 'quit' or 'exit':</source>
          <target state="translated">先に進む前に、デバッガを終了する方法を知っておく必要があります。「quit」や「exit」という単語ではなく、「&lt;b&gt;q&lt;/b&gt;」という文字だけを使用してください。</target>
        </trans-unit>
        <trans-unit id="10af6d27d8d05a680d682b1087a82d6e520c2fff" translate="yes" xml:space="preserve">
          <source>Before writing XS, read the &lt;a href=&quot;#CAVEATS&quot;&gt;&quot;CAVEATS&quot;&lt;/a&gt; section below.</source>
          <target state="translated">XSを作成する前に、以下の&lt;a href=&quot;#CAVEATS&quot;&gt;「警告」&lt;/a&gt;セクションをお読みください。</target>
        </trans-unit>
        <trans-unit id="8a4b62fae1d0e77e031397754824b30119b2b62a" translate="yes" xml:space="preserve">
          <source>Before writing XS, read the &lt;a href=&quot;#CAVEATS&quot;&gt;CAVEATS&lt;/a&gt; section below.</source>
          <target state="translated">XSを作成する前に、以下の「&lt;a href=&quot;#CAVEATS&quot;&gt;警告」&lt;/a&gt;セクションをお読みください。</target>
        </trans-unit>
        <trans-unit id="1b5bba6a088484e3f244c7ed2d3c63206cbf13d5" translate="yes" xml:space="preserve">
          <source>Before you consider posting a bug report, please consult, and possibly post a message to the discussion forum to see if what you've encountered is a known problem.</source>
          <target state="translated">バグ報告を投稿することを検討する前に、相談してみてください。</target>
        </trans-unit>
        <trans-unit id="528e582d94b55449ac3523f64dd0d0e5c7486531" translate="yes" xml:space="preserve">
          <source>Before you continue, note the sort order for variables. In general, we first list the variables in case-insensitive, almost-lexigraphical order (ignoring the &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt; preceding words, as in &lt;code&gt;${^UNICODE}&lt;/code&gt; or &lt;code&gt;$^T&lt;/code&gt; ), although &lt;code&gt;$_&lt;/code&gt; and &lt;code&gt;@_&lt;/code&gt; move up to the top of the pile. For variables with the same identifier, we list it in order of scalar, array, hash, and bareword.</source>
          <target state="translated">続行する前に、変数の並べ替え順序に注意してください。一般に、最初に変数を大文字と小文字を区別せず、字句順に並べます（ &lt;code&gt;${^UNICODE}&lt;/code&gt; や &lt;code&gt;$^T&lt;/code&gt; ように、 &lt;code&gt;{&lt;/code&gt; または &lt;code&gt;^&lt;/code&gt; の前の単語は無視します）。ただし、 &lt;code&gt;$_&lt;/code&gt; と &lt;code&gt;@_&lt;/code&gt; は上に移動します。パイルの。同じ識別子を持つ変数については、スカラー、配列、ハッシュ、ベアワードの順にリストします。</target>
        </trans-unit>
        <trans-unit id="e90a6f007e6fb64dd92c6079f36a3d06c252dda3" translate="yes" xml:space="preserve">
          <source>Before you continue, note the sort order for variables. In general, we first list the variables in case-insensitive, almost-lexigraphical order (ignoring the &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt; preceding words, as in &lt;code&gt;${^UNICODE}&lt;/code&gt; or &lt;code&gt;$^T&lt;/code&gt;), although &lt;code&gt;$_&lt;/code&gt; and &lt;code&gt;@_&lt;/code&gt; move up to the top of the pile. For variables with the same identifier, we list it in order of scalar, array, hash, and bareword.</source>
          <target state="translated">続行する前に、変数の並べ替え順序に注意してください。一般に、 &lt;code&gt;$_&lt;/code&gt; と &lt;code&gt;@_&lt;/code&gt; は上に移動しますが、最初に変数を大文字と小文字を区別せず、ほぼ辞書式順序でリストします（ &lt;code&gt;${^UNICODE}&lt;/code&gt; または &lt;code&gt;$^T&lt;/code&gt; ように &lt;code&gt;{&lt;/code&gt; または &lt;code&gt;^&lt;/code&gt; の前の単語を無視します）。山の。同じ識別子を持つ変数の場合、スカラー、配列、ハッシュ、ベアワードの順にリストします。</target>
        </trans-unit>
        <trans-unit id="29b11945139a380af16d5d49212f0306507606fb" translate="yes" xml:space="preserve">
          <source>Before you decide to merge two hashes, you have to decide what to do if both hashes contain keys that are the same and if you want to leave the original hashes as they were.</source>
          <target state="translated">2つのハッシュをマージする前に、両方のハッシュに同じキーが含まれている場合にどうするか、元のハッシュをそのままにしたい場合にどうするかを決めなければなりません。</target>
        </trans-unit>
        <trans-unit id="7b25edaa05329b202d8bbb719df130a305f9a0e7" translate="yes" xml:space="preserve">
          <source>Before you do anything else, you can help yourself by ensuring that you let Perl tell you about problem areas in your code. By turning on warnings and strictures, you can head off many problems before they get too big. You can find out more about these in &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">他のことをする前に、Perlにコード内の問題のある領域について通知させることで、自分自身を助けることができます。警告と制限をオンにすることで、多くの問題が大きくなる前に回避できます。これらの詳細については、&lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt;および&lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;で確認できます。</target>
        </trans-unit>
        <trans-unit id="054a146795bb49c5d92e2d968e739a1f63c7604c" translate="yes" xml:space="preserve">
          <source>Before you do that, first make sure the alias is nonexistent using &lt;code&gt;resolve_alias()&lt;/code&gt; , which returns the canonical name thereof. For example:</source>
          <target state="translated">その前に、まず &lt;code&gt;resolve_alias()&lt;/code&gt; を使用してエイリアスが存在しないことを確認します。これにより、その正規名が返されます。例えば：</target>
        </trans-unit>
        <trans-unit id="9fa55498f41c7cd4663e8d59ae7b91ebb05c3bad" translate="yes" xml:space="preserve">
          <source>Before you do that, first make sure the alias is nonexistent using &lt;code&gt;resolve_alias()&lt;/code&gt;, which returns the canonical name thereof. For example:</source>
          <target state="translated">その前に、 &lt;code&gt;resolve_alias()&lt;/code&gt; を使用してエイリアスが存在しないことを確認してください。resolve_alias（）はその正規名を返します。例えば：</target>
        </trans-unit>
        <trans-unit id="ea4eb9d8b93fbec8607b4df5d4d1083567318fe5" translate="yes" xml:space="preserve">
          <source>Before you launch yourself head first into the rest of this document, it would be a good idea to have read the following two documents--&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">このドキュメントの残りの部分に&lt;a href=&quot;perlxs&quot;&gt;進む前に&lt;/a&gt;、perlxsと&lt;a href=&quot;perlguts&quot;&gt;perlgutsの&lt;/a&gt; 2つのドキュメントを読んでおくことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="dde9d3bcf2359cbba92e26ac6718964bcaacd3c3" translate="yes" xml:space="preserve">
          <source>Before you panic, know that many people do use &lt;code&gt;Moose&lt;/code&gt; for command-line tools and other startup-sensitive code. We encourage you to try &lt;code&gt;Moose&lt;/code&gt; out first before worrying about startup speed.</source>
          <target state="translated">パニックになる前に、多くの人がコマンドラインツールやその他の起動に敏感なコードに &lt;code&gt;Moose&lt;/code&gt; を使用していることを知ってください。起動速度を気にする前に、まず &lt;code&gt;Moose&lt;/code&gt; を試してみることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2c445dd5994fd48a7f879efa85cd15aa5394f95f" translate="yes" xml:space="preserve">
          <source>Before you start</source>
          <target state="translated">始める前に</target>
        </trans-unit>
        <trans-unit id="fa35a8236ca3aecdca56f64d9f3832c8bf9e0996" translate="yes" xml:space="preserve">
          <source>Before you start, it's important to know a few things:</source>
          <target state="translated">始める前に、いくつかのことを知っておくことが大切です。</target>
        </trans-unit>
        <trans-unit id="85435e88ea012cea6ee5f0e38fd4d12329633e18" translate="yes" xml:space="preserve">
          <source>Before you start, you should glance through the README file found in the top-level directory to which the Perl distribution was extracted. Make sure you read and understand the terms under which this software is being distributed.</source>
          <target state="translated">始める前に、Perl の配布物が展開されたトップレベルのディレクトリにある README ファイルに目を通しておくべきです。このソフトウェアが配布されている条件を読み、理解していることを確認してください。</target>
        </trans-unit>
        <trans-unit id="82f236c12f0a7b2bfa05bcc6c77fce0d5554f74c" translate="yes" xml:space="preserve">
          <source>Before you start, you should glance through the README file found in the top-level directory where the Perl distribution was extracted. Make sure you read and understand the terms under which this software is being distributed.</source>
          <target state="translated">始める前に、Perl の配布物が展開されたトップレベルのディレクトリにある README ファイルに目を通しておくべきです。このソフトウェアが配布されている条件を読み、理解していることを確認してください。</target>
        </trans-unit>
        <trans-unit id="e6dc5aa054869bdc5776548930fba90056a049b5" translate="yes" xml:space="preserve">
          <source>Begin the retrieval of a file called &lt;code&gt;FILE&lt;/code&gt; from the remote server.</source>
          <target state="translated">リモートサーバーから &lt;code&gt;FILE&lt;/code&gt; というファイルの取得を開始します。</target>
        </trans-unit>
        <trans-unit id="d1bae729fa6ba19a84ae13329bfa79bbfaf77e9b" translate="yes" xml:space="preserve">
          <source>Beginner note: In example 2, above &lt;code&gt;$columns&lt;/code&gt; is imported into the local namespace, and set locally. In example 3, &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; is set in its own namespace without importing it.</source>
          <target state="translated">初心者向けメモ：例2では、​​上記の &lt;code&gt;$columns&lt;/code&gt; がローカルの名前空間にインポートされ、ローカルに設定されます。例3では、 &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; はインポートせずに独自のネームスペースに設定されています。</target>
        </trans-unit>
        <trans-unit id="8c50d29cf088569a469311ef83bf39d51d30a011" translate="yes" xml:space="preserve">
          <source>Beginners often think they want to have a variable contain the name of a variable.</source>
          <target state="translated">初心者の方は、変数に変数名を含ませたいと考えることが多いです。</target>
        </trans-unit>
        <trans-unit id="ddd5e0ea97f5ceda3171fdb3abe535bc421229c3" translate="yes" xml:space="preserve">
          <source>Beginning in Perl 5.12, Perl accepts an ellipsis, &quot;&lt;code&gt;...&lt;/code&gt; &quot;, as a placeholder for code that you haven't implemented yet. This form of ellipsis, the unimplemented statement, should not be confused with the binary flip-flop &lt;code&gt;...&lt;/code&gt; operator. One is a statement and the other an operator. (Perl doesn't usually confuse them because usually Perl can tell whether it wants an operator or a statement, but see below for exceptions.)</source>
          <target state="translated">Perl 5.12から、Perlは省略記号「 &lt;code&gt;...&lt;/code&gt; 」を、まだ実装していないコードのプレースホルダーとして受け入れます。実装されていないステートメントであるこの形式の省略は、バイナリフリップフロップ &lt;code&gt;...&lt;/code&gt; 演算子と混同しないでください。1つはステートメントで、もう1つは演算子です。（通常、Perlは演算子とステートメントのどちらが必要かを判断できるため、Perlが混乱することはありませんが、例外については以下を参照してください。）</target>
        </trans-unit>
        <trans-unit id="dc88deeacfc5c23c60a84d0e355d8d08bad0853c" translate="yes" xml:space="preserve">
          <source>Beginning in Perl 5.12, Perl accepts an ellipsis, &quot;&lt;code&gt;...&lt;/code&gt;&quot;, as a placeholder for code that you haven't implemented yet. When Perl 5.12 or later encounters an ellipsis statement, it parses this without error, but if and when you should actually try to execute it, Perl throws an exception with the text &lt;code&gt;Unimplemented&lt;/code&gt;:</source>
          <target state="translated">Perl 5.12以降、Perlは、まだ実装していないコードのプレースホルダーとして省略記号「 &lt;code&gt;...&lt;/code&gt; 」を受け入れます。Perl 5.12以降で省略記号が検出されると、エラーなしでこれが解析されますが、実際に実行を試みる必要がある場合、Perlは「 &lt;code&gt;Unimplemented&lt;/code&gt; ：」というテキストで例外をスローします。</target>
        </trans-unit>
        <trans-unit id="90c724bcc9cdece1aeab2aab45c2518eb7791435" translate="yes" xml:space="preserve">
          <source>Beginning in Perl 5.28, multi-threaded locale operation is supported on systems that implement either the POSIX 2008 or Windows-specific thread-safe locale operations. Many modern systems, such as various Unix variants and Darwin do have this.</source>
          <target state="translated">Perl 5.28 以降、POSIX 2008 または Windows 固有のスレッドセーフなロケール操作を実装したシステムでは、マルチスレッドのロケール操作がサポートされています。最近のシステムでは、さまざまな Unix の変種や Darwin など、多くのシステムがこれをサポートしています。</target>
        </trans-unit>
        <trans-unit id="5a346d69c5ac7465ea021c968ddc77fd7f137feb" translate="yes" xml:space="preserve">
          <source>Beginning in v5.20.0, a postfix syntax for using references is available. It behaves as described in &lt;a href=&quot;#Using-References&quot;&gt;&quot;Using References&quot;&lt;/a&gt;, but instead of a prefixed sigil, a postfixed sigil-and-star is used.</source>
          <target state="translated">v5.20.0以降、参照を使用するための接尾辞構文が使用可能になりました。&lt;a href=&quot;#Using-References&quot;&gt;「参照の使用」で&lt;/a&gt;説明されているように動作しますが、接頭辞付きの印章の代わりに、接頭辞付きの印章と星が使用されます。</target>
        </trans-unit>
        <trans-unit id="82d48c3b20d2f80bac7595523990a9132ad0e311" translate="yes" xml:space="preserve">
          <source>Beginning in v5.20.0, a postfix syntax for using references is available. It behaves as described in &lt;a href=&quot;#Using-References&quot;&gt;Using References&lt;/a&gt;, but instead of a prefixed sigil, a postfixed sigil-and-star is used.</source>
          <target state="translated">v5.20.0以降では、参照を使用するためのPostfix構文が利用可能です。「&lt;a href=&quot;#Using-References&quot;&gt;参照の使用」で&lt;/a&gt;説明されているように動作しますが、接頭辞付きの印章の代わりに、接尾辞付きの印章と星印が使用されます。</target>
        </trans-unit>
        <trans-unit id="e4fd9d1748abdc28d0efb1f242a157236c1c9529" translate="yes" xml:space="preserve">
          <source>Beginning in v5.22.0, the referencing operator can be assigned to. It performs an aliasing operation, so that the variable name referenced on the left-hand side becomes an alias for the thing referenced on the right-hand side:</source>
          <target state="translated">v5.22.0 以降、参照演算子を割り当てることができます。これはエイリアス演算を行い、左側で参照されている変数名が右側で参照されているもののエイリアスになるようにします。</target>
        </trans-unit>
        <trans-unit id="ffa0956923ab92c4c7492c5469e046b41154fb80" translate="yes" xml:space="preserve">
          <source>Beginning in v5.26.0, the referencing operator can come after &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt;, or &lt;code&gt;local&lt;/code&gt;. This syntax must be enabled with &lt;code&gt;use feature 'declared_refs'&lt;/code&gt;. It is experimental, and will warn by default unless &lt;code&gt;no warnings 'experimental::refaliasing'&lt;/code&gt; is in effect.</source>
          <target state="translated">v5.26.0以降、参照演算子は、 &lt;code&gt;my&lt;/code&gt; 、 &lt;code&gt;state&lt;/code&gt; 、 &lt;code&gt;our&lt;/code&gt; 、または &lt;code&gt;local&lt;/code&gt; の後に来ることができます。この構文は、 &lt;code&gt;use feature 'declared_refs'&lt;/code&gt; 有効にする必要があります。これは実験的なものであり &lt;code&gt;no warnings 'experimental::refaliasing'&lt;/code&gt; が有効になっていない限り、デフォルトで警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="54f7bcfa82e1deb0e3342e8510b04a376681f2a5" translate="yes" xml:space="preserve">
          <source>Beginning with HP-UX 11.00, programs compiled under HP-UX can take advantage of the LP64 programming environment (LP64 means Longs and Pointers are 64 bits wide), in which scalar variables will be able to hold numbers larger than 2^32 with complete precision. Perl has proven to be consistent and reliable in 64bit mode since 5.8.1 on all HP-UX 11.xx.</source>
          <target state="translated">HP-UX 11.00 以降、HP-UX でコンパイルされたプログラムは LP64 プログラミング環境(LP64 は Longs と Pointers が 64 ビット幅であることを意味します)を利用することができます。Perl は 5.8.1 以降、すべての HP-UX 11.xx で 64bit モードで一貫性と信頼性があることが証明されています。</target>
        </trans-unit>
        <trans-unit id="7f252bceac885ebc51d1278ef820d426befd060f" translate="yes" xml:space="preserve">
          <source>Beginning with HP-UX version 10.20, files larger than 2GB (2^31 bytes) may be created and manipulated. Three separate methods of doing this are available. Of these methods, the best method for Perl is to compile using the -Duselargefiles flag to Configure. This causes Perl to be compiled using structures and functions in which these are 64 bits wide, rather than 32 bits wide. (Note that this will only work with HP's ANSI C compiler. If you want to compile Perl using gcc, you will have to get a version of the compiler that supports 64-bit operations. See above for where to find it.)</source>
          <target state="translated">HP-UX バージョン 10.20 以降では、2GB (2^31 バイト)を超えるファイルを作成して操作することができます。これには3つの方法があります。これらの方法のうち、Perl にとっての最良の方法は、Configure に -Duselargefiles フラグを指定してコンパイルすることです。これにより、Perl は 32 ビット幅ではなく 64 ビット幅の構造体と関数を使ってコンパイルされます。(HPのANSI Cコンパイラでのみ動作することに注意してください。gccを使ってPerlをコンパイルしたい場合は、64ビット演算をサポートするコンパイラを入手する必要があります。それがどこにあるかは上記を参照してください。)</target>
        </trans-unit>
        <trans-unit id="7b1997a711dcb385772e62932a24b63be2ca5162" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.10.0, you can declare variables with the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword in place of &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. For that to work, though, you must have enabled that feature beforehand, either by using the &lt;code&gt;feature&lt;/code&gt; pragma, or by using &lt;code&gt;-E&lt;/code&gt; on one-liners (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;). Beginning with Perl 5.16, the &lt;code&gt;CORE::state&lt;/code&gt; form does not require the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="translated">Perl 5.10.0以降では &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 代わりに &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; キーワードを使用して変数を宣言できます。ただし、これを機能させるには、 &lt;code&gt;feature&lt;/code&gt; プラグマを使用するか、ワンライナーで &lt;code&gt;-E&lt;/code&gt; を使用して（&lt;a href=&quot;feature&quot;&gt;featureを&lt;/a&gt;参照）、その機能を事前に有効にしておく必要があります。Perl 5.16から、 &lt;code&gt;CORE::state&lt;/code&gt; フォームは &lt;code&gt;feature&lt;/code&gt; プラグマを必要としません。</target>
        </trans-unit>
        <trans-unit id="043ad372200ab11184230c8b464cbbec604d0f73" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.10.0, you can declare variables with the &lt;code&gt;state&lt;/code&gt; keyword in place of &lt;code&gt;my&lt;/code&gt;. For that to work, though, you must have enabled that feature beforehand, either by using the &lt;code&gt;feature&lt;/code&gt; pragma, or by using &lt;code&gt;-E&lt;/code&gt; on one-liners (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;). Beginning with Perl 5.16, the &lt;code&gt;CORE::state&lt;/code&gt; form does not require the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="translated">Perl 5.10.0以降では &lt;code&gt;my&lt;/code&gt; 代わりに &lt;code&gt;state&lt;/code&gt; キーワードを使用して変数を宣言できます。ただし、これを機能させるには、 &lt;code&gt;feature&lt;/code&gt; プラグマを使用するか、ワンライナーで &lt;code&gt;-E&lt;/code&gt; を使用して、その機能を事前に有効にしておく必要があります（&lt;a href=&quot;feature&quot;&gt;機能を&lt;/a&gt;参照）。Perl 5.16以降、 &lt;code&gt;CORE::state&lt;/code&gt; フォームは &lt;code&gt;feature&lt;/code&gt; プラグマを必要としません。</target>
        </trans-unit>
        <trans-unit id="fd848af5e7c989b28a26cc1aec55564025fc4af9" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.18, you can declare a private subroutine with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;. As with state variables, the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword is only available under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'state'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.010&lt;/code&gt; or higher.</source>
          <target state="translated">Perl 5.18以降では、プライベートサブルーチンを &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; で宣言できます。状態変数と同じように、 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; キーワードが下にのみ使用できます &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'state'&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.010&lt;/code&gt; 以上です。</target>
        </trans-unit>
        <trans-unit id="4f40c1f7eb582d4b15076061b6d0a8e085b355dc" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.18, you can declare a private subroutine with &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;state&lt;/code&gt;. As with state variables, the &lt;code&gt;state&lt;/code&gt; keyword is only available under &lt;code&gt;use feature 'state'&lt;/code&gt; or &lt;code&gt;use 5.010&lt;/code&gt; or higher.</source>
          <target state="translated">Perl 5.18以降では &lt;code&gt;my&lt;/code&gt; または &lt;code&gt;state&lt;/code&gt; を使用してプライベートサブルーチンを宣言できます。状態変数と同様に、 &lt;code&gt;state&lt;/code&gt; キーワードは、 &lt;code&gt;use feature 'state'&lt;/code&gt; または &lt;code&gt;use 5.010&lt;/code&gt; 以降でのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="eb06f268b9e85c6ee8127ae9f07256660624d8e4" translate="yes" xml:space="preserve">
          <source>Beginning with Perl version 5.26, a much simpler and cleaner way to write indented here documents has been added to the language: the tilde (~) modifier. See &lt;a href=&quot;perlop#Indented-Here-docs&quot;&gt;&quot;Indented Here-docs&quot; in perlop&lt;/a&gt; for details.</source>
          <target state="translated">Perlバージョン5.26から、インデントされたヒアドキュメントを書くためのはるかに簡単でクリーンな方法が言語に追加されました：チルダ（〜）修飾子。詳細については&lt;a href=&quot;perlop#Indented-Here-docs&quot;&gt;、perlopの「IndentedHere-docs」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2eca9f03e4044bf99d10838840f25a5c4ae464b9" translate="yes" xml:space="preserve">
          <source>Beginning with perl 5.10.0, you can also use &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables to have lexicals that are initialized only once (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;):</source>
          <target state="translated">perl 5.10.0以降では、 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 変数を使用して、1回だけ初期化されるレキシカルを使用することもできます（&lt;a href=&quot;feature&quot;&gt;機能を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="62b599a702a0e45efa83ae9abd2c72ac9e40e2f7" translate="yes" xml:space="preserve">
          <source>Beginning with perl 5.10.0, you can also use &lt;code&gt;state&lt;/code&gt; variables to have lexicals that are initialized only once (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;):</source>
          <target state="translated">perl 5.10.0以降では、 &lt;code&gt;state&lt;/code&gt; 変数を使用して、一度だけ初期化される字句を使用することもできます（&lt;a href=&quot;feature&quot;&gt;機能を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="d269396692530a4c995cb59a2555fae5ff4dd172" translate="yes" xml:space="preserve">
          <source>Beginning with version 5.004, the following functions are also supported:</source>
          <target state="translated">バージョン5.004からは、以下の機能にも対応しています。</target>
        </trans-unit>
        <trans-unit id="5a1a2270a454451ac22b568bca58999ca2a57b3c" translate="yes" xml:space="preserve">
          <source>Beginning/End of line positions</source>
          <target state="translated">開始/終了ライン位置</target>
        </trans-unit>
        <trans-unit id="f2dfcf5f267b41370cad897910ad80d037ac22ab" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;a href=&quot;#newCONSTSUB_flags&quot;&gt;&quot;newCONSTSUB_flags&quot;&lt;/a&gt;, except that &lt;code&gt;name&lt;/code&gt; is nul-terminated rather than of counted length, and no flags are set. (This means that &lt;code&gt;name&lt;/code&gt; is always interpreted as Latin-1.)</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; がカウントされた長さではなくヌル&lt;a href=&quot;#newCONSTSUB_flags&quot;&gt;文字で&lt;/a&gt;終了し、フラグが設定されていないことを除いて、「newCONSTSUB_flags」のように動作します。（これは、 &lt;code&gt;name&lt;/code&gt; が常にラテン語-1として解釈されることを意味します。）</target>
        </trans-unit>
        <trans-unit id="5b6fd5b0516beaff8d8429855f694694659eb195" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;a href=&quot;http://man.he.net/man2/wait&quot;&gt;wait(2)&lt;/a&gt; on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt;&lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt;&lt;/a&gt;. Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">システムでは&lt;a href=&quot;http://man.he.net/man2/wait&quot;&gt;wait（2）の&lt;/a&gt;ように動作します。子プロセスが終了するのを待って、死亡したプロセスのpidを返します。子プロセスがない場合は &lt;code&gt;-1&lt;/code&gt; を返します。ステータスは&lt;a href=&quot;perlvar#%24%3F&quot;&gt; &lt;code&gt;$?&lt;/code&gt; &lt;/a&gt;で返されますか？および&lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt; &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; &lt;/a&gt;。戻り値 &lt;code&gt;-1&lt;/code&gt; は、&lt;a href=&quot;perlipc&quot;&gt;perlipcで&lt;/a&gt;説明されているように、子プロセスが自動的に刈り取られていることを意味する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="fb78858d773149c7141146370197d2f530d8902f" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;$_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$_&lt;/code&gt; ように動作します。</target>
        </trans-unit>
        <trans-unit id="34133685a790f2f2b5caab0cdf19417a300c4bef" translate="yes" xml:space="preserve">
          <source>Behaves like wait(2) on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">システムのwait（2）のように動作します。子プロセスが終了するのを待ち、死亡したプロセスのpidを返します。子プロセスがない場合は &lt;code&gt;-1&lt;/code&gt; を返します。ステータスは &lt;code&gt;$?&lt;/code&gt; で返されますか？および &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 。 &lt;code&gt;-1&lt;/code&gt; の戻り値は、&lt;a href=&quot;../perlipc&quot;&gt;perlipcで&lt;/a&gt;説明されているように、子プロセスが自動的に取得されることを意味する場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0f0c5491ce914759629c95815e914e921b25062e" translate="yes" xml:space="preserve">
          <source>Behaves like wait(2) on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">システムのwait（2）のように動作します。子プロセスが終了するのを待ち、死亡したプロセスのpidを返します。子プロセスがない場合は &lt;code&gt;-1&lt;/code&gt; を返します。ステータスは &lt;code&gt;$?&lt;/code&gt; で返されますか？および &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; 。 &lt;code&gt;-1&lt;/code&gt; の戻り値は、&lt;a href=&quot;perlipc&quot;&gt;perlipcで&lt;/a&gt;説明されているように、子プロセスが自動的に取得されることを意味する場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="756aaec531bd197c8baf40355b6e7560606340ee" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak&quot;&gt;&quot;croak&quot;&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">戻り値の型を除いて、&lt;a href=&quot;#croak&quot;&gt;「croak」&lt;/a&gt;と同じように動作します。 &lt;code&gt;OP *&lt;/code&gt; 戻り値の型が必要な場合にのみ使用してください。関数が実際に戻ることはありません。</target>
        </trans-unit>
        <trans-unit id="0be599b479dc1a9d62fd33cd4b25ae6147cf1069" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">戻り値の型を除いて、&lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;と同じように動作します。 &lt;code&gt;OP *&lt;/code&gt; 戻り型が必要な場合にのみ使用してください。関数が実際に戻ることはありません。</target>
        </trans-unit>
        <trans-unit id="e3b8ea26eb4d496c3c9598880a77b0e504f2a647" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak_sv&quot;&gt;&quot;croak_sv&quot;&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">戻り値の型を除いて、&lt;a href=&quot;#croak_sv&quot;&gt;「croak_sv」&lt;/a&gt;と同じように動作します。 &lt;code&gt;OP *&lt;/code&gt; 戻り値の型が必要な場合にのみ使用してください。関数が実際に戻ることはありません。</target>
        </trans-unit>
        <trans-unit id="4c49c08082a231774a342ac5391eebbc26cb4596" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">戻り値の型を除いて、&lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt;と同じように動作します。 &lt;code&gt;OP *&lt;/code&gt; 戻り型が必要な場合にのみ使用してください。関数が実際に戻ることはありません。</target>
        </trans-unit>
        <trans-unit id="fbf9c5863d4bbe3bd2490f1ad8ab93b461cdea43" translate="yes" xml:space="preserve">
          <source>Behavior of other Perl features in forked pseudo-processes</source>
          <target state="translated">フォークされた疑似プロセスにおける他のPerl機能の挙動</target>
        </trans-unit>
        <trans-unit id="546fd299e317f0cfab072f158d53c6046d080ef9" translate="yes" xml:space="preserve">
          <source>Behavior of this function varies wildly depending on your system implementation. For example, it will usually not work across file system boundaries, even though the system</source>
          <target state="translated">この関数の動作は、システムの実装によって大きく異なります。例えば、ファイルシステムの境界を越えて動作することは通常ありません。</target>
        </trans-unit>
        <trans-unit id="6296c0acaf0c68b8a708c260d5e620e45c188c21" translate="yes" xml:space="preserve">
          <source>Behaviour since version 2.11</source>
          <target state="translated">バージョン2.11以降の動作</target>
        </trans-unit>
        <trans-unit id="fc99a03494d30ac32472278376507c26adfb39ce" translate="yes" xml:space="preserve">
          <source>Behind The Scenes</source>
          <target state="translated">舞台裏</target>
        </trans-unit>
        <trans-unit id="8e234f329fb33ee94403565f619b16d72bc67919" translate="yes" xml:space="preserve">
          <source>Behind the scenes the &lt;code&gt;globmap&lt;/code&gt; function does a combination of a file glob to match existing filenames followed by a substitute to create the new filenames.</source>
          <target state="translated">バックグラウンドで &lt;code&gt;globmap&lt;/code&gt; 関数は、既存のファイル名に一致するファイルグロブと、新しいファイル名を作成するための代替ファイルの組み合わせを実行します。</target>
        </trans-unit>
        <trans-unit id="4f88b0aecf2344cf177fb22c2c1e4809d60f491d" translate="yes" xml:space="preserve">
          <source>Being Perl-specific, this function has evolved along time. It can currently be called as follow:</source>
          <target state="translated">この関数は Perl 固有のものであり、時間の経過とともに進化してきました。現在は以下のように呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="0fc303a764ff6b60a94ad6969ea173a3382e1620" translate="yes" xml:space="preserve">
          <source>Being a mechanical process pl2pm is not bullet proof. The converted code will need careful checking, especially any package statements. Don't delete the original .pl file till the new .pm one works!</source>
          <target state="translated">機械的なプロセスである pl2pm は、防弾性があるわけではありません。変換されたコードは注意深くチェックする必要があります。新しい .pm が動くまで、元の .pl ファイルを削除しないでください!</target>
        </trans-unit>
        <trans-unit id="7f0407ad618a0bd51d559ec6185eae8ed67ffedb" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt;. If you do just &lt;code&gt;open(my $A, &quot;&amp;gt;&amp;gt;&amp;amp;&quot;, $B)&lt;/code&gt;, the filehandle &lt;code&gt;$A&lt;/code&gt; will not have the same file descriptor as &lt;code&gt;$B&lt;/code&gt;, and therefore &lt;code&gt;flock($A)&lt;/code&gt; will not &lt;code&gt;flock($B)&lt;/code&gt; nor vice versa. But with &lt;code&gt;open(my $A, &quot;&amp;gt;&amp;gt;&amp;amp;=&quot;, $B)&lt;/code&gt;, the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">たとえば、&lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt; &lt;code&gt;flock&lt;/code&gt; &lt;/a&gt;を使用したロックなど、ファイル記述子に依存しているものがある場合など、ファイルハンドルを節約することも役立ちます（節約するだけでなく）。あなたが行う場合は、単に &lt;code&gt;open(my $A, &quot;&amp;gt;&amp;gt;&amp;amp;&quot;, $B)&lt;/code&gt; 、ファイルハンドル &lt;code&gt;$A&lt;/code&gt; 同じファイルディスクリプタはありません &lt;code&gt;$B&lt;/code&gt; 、したがって、 &lt;code&gt;flock($A)&lt;/code&gt; ません &lt;code&gt;flock($B)&lt;/code&gt; も逆に。ただし、 &lt;code&gt;open(my $A, &quot;&amp;gt;&amp;gt;&amp;amp;=&quot;, $B)&lt;/code&gt; と、ファイルハンドルは同じ基になるシステムファイル記述子を共有します。</target>
        </trans-unit>
        <trans-unit id="e98f301c8128b87a5492d5177997df433005bc22" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using flock(). If you do just &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , the filehandle A will not have the same file descriptor as B, and therefore flock(A) will not flock(B) nor vice versa. But with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">たとえば、flock（）を使用したロックなど、ファイル記述子に依存している場合など、ファイルハンドルを節約することも（節約すること以外にも）便利です。 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; &lt;a href=&quot;functions/open&quot;&gt;開く&lt;/a&gt;だけの場合、ファイルハンドルAはBと同じファイル記述子を持たないため、flock（A）はflock（B）を実行せず、その逆も同様です。しかし、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; と、ファイルハンドルは同じ基本的なシステムファイル記述子を共有します。</target>
        </trans-unit>
        <trans-unit id="eb7d6ff0d012000fe6eccb3c989a4ceae1efb833" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using flock(). If you do just &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , the filehandle A will not have the same file descriptor as B, and therefore flock(A) will not flock(B) nor vice versa. But with &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">たとえば、flock（）を使用したロックなど、ファイル記述子に依存している場合など、ファイルハンドルを節約することも（節約すること以外にも）便利です。 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; &lt;a href=&quot;open&quot;&gt;開く&lt;/a&gt;だけの場合、ファイルハンドルAはBと同じファイル記述子を持たないため、flock（A）はflock（B）を実行せず、その逆も同様です。しかし、 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; と、ファイルハンドルは同じ基本的なシステムファイル記述子を共有します。</target>
        </trans-unit>
        <trans-unit id="027a12c2fc8568e8b70b07ff536faf288a013670" translate="yes" xml:space="preserve">
          <source>Belarus</source>
          <target state="translated">Belarus</target>
        </trans-unit>
        <trans-unit id="5cb4c9d828175ed3931ec52305b32f47173a8e04" translate="yes" xml:space="preserve">
          <source>Belgium</source>
          <target state="translated">Belgium</target>
        </trans-unit>
        <trans-unit id="1b8a9f965c18d647b7a7bff03b9e0c4a68361224" translate="yes" xml:space="preserve">
          <source>Bell sounds when word completion fails.</source>
          <target state="translated">単語補完に失敗するとベルが鳴ります。</target>
        </trans-unit>
        <trans-unit id="74d2e1c77a10412bd2a923bb84c1c65e97a50e55" translate="yes" xml:space="preserve">
          <source>Below are a few examples of globmaps</source>
          <target state="translated">以下に globmaps の例を示します。</target>
        </trans-unit>
        <trans-unit id="8b537b36a224ab3855e5388cf5af4a7324861d08" translate="yes" xml:space="preserve">
          <source>Below comes a verbose discussion of these flags. Note that a &quot;codeset&quot; is simply an abstract set of character-codepoint pairs, while an encoding takes those codepoint numbers and</source>
          <target state="translated">以下では、これらのフラグについて詳しく説明します。コードセット」は単に文字とコードポイントのペアの抽象的な集合であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d6238547f660d516d0fdf40f8de1337807f2955e" translate="yes" xml:space="preserve">
          <source>Below is a</source>
          <target state="translated">以下は</target>
        </trans-unit>
        <trans-unit id="eab1a70d36b9d2b495b3781776947aeb4b2fc004" translate="yes" xml:space="preserve">
          <source>Below is a list of a few frameworks with comments which might help you in making a decision, depending on your specific requirements. Start by reading the docs, then ask questions on the relevant mailing list or IRC channel.</source>
          <target state="translated">以下は、あなたの特定の要件に応じて、あなたが決定する際に役立つかもしれないコメント付きのいくつかのフレームワークのリストです。まずドキュメントを読んでから、関連するメーリングリストや IRC チャンネルで質問をしてください。</target>
        </trans-unit>
        <trans-unit id="1f47cec9db1010fb960d67042b7e30d1824cca4b" translate="yes" xml:space="preserve">
          <source>Below is a list of the files in the Unicode data base that Perl doesn't currently use, along with very brief descriptions of their purposes. Some of the names of the files have been shortened from those that Unicode uses, in order to allow them to be distinguishable from similarly named files on file systems for which only the first 8 characters of a name are significant.</source>
          <target state="translated">以下に、Perl が現在使用していない Unicode データベース内のファイルのリストと、それらの目的についての非常に簡単な説明を示します。ファイル名のいくつかは、名前の最初の 8 文字だけが重要なファイルシステム上の同様の名前のファイルと区別できるように、Unicode が使用しているものから短縮されています。</target>
        </trans-unit>
        <trans-unit id="80905719173a37bfcc2cab267e8366cac44b82fa" translate="yes" xml:space="preserve">
          <source>Below is a list of the methods available.</source>
          <target state="translated">以下、利用できる方法の一覧です。</target>
        </trans-unit>
        <trans-unit id="a5ddbb5a4ded78a58dd050a0a7bd8f09a53b44f8" translate="yes" xml:space="preserve">
          <source>Below is a list of the valid options:</source>
          <target state="translated">以下、有効な選択肢の一覧です。</target>
        </trans-unit>
        <trans-unit id="f51c6d51b727cf7e1f4d3849980abd064bedf568" translate="yes" xml:space="preserve">
          <source>Below is a mapping of what utilities will be used in what order for what schemes, if available:</source>
          <target state="translated">以下は、利用可能な場合、どのようなスキームでどのようなユーティリティがどのような順序で使用されるかのマッピングです。</target>
        </trans-unit>
        <trans-unit id="19c0c3663e2dbbc758912a1313a649285c7d7339" translate="yes" xml:space="preserve">
          <source>Below is a mod_perl Apache compression module, called &lt;code&gt;Apache::GZip&lt;/code&gt;, taken from &lt;a href=&quot;http://perl.apache.org/docs/tutorials/tips/mod_perl_tricks/mod_perl_tricks.html#On_the_Fly_Compression&quot;&gt;http://perl.apache.org/docs/tutorials/tips/mod_perl_tricks/mod_perl_tricks.html#On_the_Fly_Compression&lt;/a&gt;</source>
          <target state="translated">以下は、&lt;a href=&quot;http://perl.apache.org/docs/tutorials/tips/mod_perl_tricks/mod_perl_tricks.html#On_the_Fly_Compression&quot;&gt;http &lt;/a&gt; &lt;code&gt;Apache::GZip&lt;/code&gt; から取得したApache :: GZipと呼ばれるmod_perlApache圧縮モジュールです。</target>
        </trans-unit>
        <trans-unit id="beba98866f16c9dd2863b4a3ebd6b7ee815c3c45" translate="yes" xml:space="preserve">
          <source>Below is a possible implementation of a script to carry out the rename (error cases have been omitted)</source>
          <target state="translated">以下に、リネームを実行するスクリプトの実装例を示します(エラーの場合は省略しています)。</target>
        </trans-unit>
        <trans-unit id="58a01ebfbc11cd115ad51487cc4a5f70ba63da00" translate="yes" xml:space="preserve">
          <source>Below is a script which makes use of &lt;code&gt;gzreadline&lt;/code&gt; . It implements a very simple</source>
          <target state="translated">以下は &lt;code&gt;gzreadline&lt;/code&gt; を利用するスクリプトです。非常にシンプルな</target>
        </trans-unit>
        <trans-unit id="dc35361ae28756350bcadeedc93fea7a717eda63" translate="yes" xml:space="preserve">
          <source>Below is a script which makes use of &lt;code&gt;gzreadline&lt;/code&gt;. It implements a very simple</source>
          <target state="translated">以下は、 &lt;code&gt;gzreadline&lt;/code&gt; を利用するスクリプトです。非常にシンプルな実装です</target>
        </trans-unit>
        <trans-unit id="7ffed42afdfaf25df4c7e5e8645b31ce92ca54e6" translate="yes" xml:space="preserve">
          <source>Below is a simple &quot;rename&quot; script that uses &lt;code&gt;globmap&lt;/code&gt; to determine the source and destination filenames.</source>
          <target state="translated">以下は、 &lt;code&gt;globmap&lt;/code&gt; を使用してソースと宛先のファイル名を決定する単純な「名前変更」スクリプトです。</target>
        </trans-unit>
        <trans-unit id="1ec37797cdff4399757b58637d8bd54b7066dfec" translate="yes" xml:space="preserve">
          <source>Below is an example module that makes use of the macros.</source>
          <target state="translated">以下にマクロを利用したモジュールの例を示します。</target>
        </trans-unit>
        <trans-unit id="2be2899025a1fe4d200821c4ccbd79eabb3ab414" translate="yes" xml:space="preserve">
          <source>Below is an example program, &lt;code&gt;cpp_test&lt;/code&gt; , which makes use of this filter. Line numbers have been added to allow specific lines to be referenced easily.</source>
          <target state="translated">以下は、このフィルターを使用するサンプルプログラム &lt;code&gt;cpp_test&lt;/code&gt; です。特定の行を簡単に参照できるように、行番号が追加されました。</target>
        </trans-unit>
        <trans-unit id="b304a8ff907f2b83be9fd715d004cdf9a531f584" translate="yes" xml:space="preserve">
          <source>Below is an example program, &lt;code&gt;cpp_test&lt;/code&gt;, which makes use of this filter. Line numbers have been added to allow specific lines to be referenced easily.</source>
          <target state="translated">以下は、このフィルターを使用するサンプルプログラム &lt;code&gt;cpp_test&lt;/code&gt; です。特定の行を簡単に参照できるように、行番号が追加されました。</target>
        </trans-unit>
        <trans-unit id="4e2cc23005bf69f272f1f19d9851308543cafdff" translate="yes" xml:space="preserve">
          <source>Below is just one example, illustrating the control verb &lt;code&gt;(*FAIL)&lt;/code&gt; , which may be abbreviated as &lt;code&gt;(*F)&lt;/code&gt; . If this is inserted in a regexp it will cause it to fail, just as it would at some mismatch between the pattern and the string. Processing of the regexp continues as it would after any &quot;normal&quot; failure, so that, for instance, the next position in the string or another alternative will be tried. As failing to match doesn't preserve capture groups or produce results, it may be necessary to use this in combination with embedded code.</source>
          <target state="translated">以下は、制御動詞 &lt;code&gt;(*FAIL)&lt;/code&gt; を示す1つの例にすぎません。 &lt;code&gt;(*F)&lt;/code&gt; と省略できます。これが正規表現に挿入されると、パターンと文字列の間の不一致と同様に、失敗します。正規表現の処理は、「通常の」障害の後と同様に続行されるため、たとえば、文字列の次の位置または別の位置が試行されます。一致しない場合、キャプチャグループが保持されないか、結果が生成されないため、埋め込みコードと組み合わせて使用​​する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="8dfcb4bdf0851e123d1da057d122d3eaadab35bd" translate="yes" xml:space="preserve">
          <source>Below is just one example, illustrating the control verb &lt;code&gt;(*FAIL)&lt;/code&gt;, which may be abbreviated as &lt;code&gt;(*F)&lt;/code&gt;. If this is inserted in a regexp it will cause it to fail, just as it would at some mismatch between the pattern and the string. Processing of the regexp continues as it would after any &quot;normal&quot; failure, so that, for instance, the next position in the string or another alternative will be tried. As failing to match doesn't preserve capture groups or produce results, it may be necessary to use this in combination with embedded code.</source>
          <target state="translated">以下は一例であり、制御動詞 &lt;code&gt;(*FAIL)&lt;/code&gt; を示しています。これは &lt;code&gt;(*F)&lt;/code&gt; と省略される場合があります。これを正規表現に挿入すると、パターンと文字列が一致しない場合と同じように、失敗します。正規表現の処理は、「通常の」失敗の後と同じように続行されるため、たとえば、文字列内の次の位置または別の代替が試行されます。一致しないとキャプチャグループが保持されないか、結果が生成されないため、埋め込みコードと組み合わせて使用​​する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="994ae30ab39b91782977e3601a4b1c5958c55b6d" translate="yes" xml:space="preserve">
          <source>Below is the sample of what to do to reproduce the configuration on my machine. In</source>
          <target state="translated">以下は、私のマシンで設定を再現するために何をするかのサンプルです。での</target>
        </trans-unit>
        <trans-unit id="8d0833a6280a2357c9ec993c9c38bf06fc8a81e8" translate="yes" xml:space="preserve">
          <source>Below is typical code that shows how to use &lt;code&gt;LimitOutput&lt;/code&gt; .</source>
          <target state="translated">以下は、 &lt;code&gt;LimitOutput&lt;/code&gt; の使用方法を示す典型的なコードです。</target>
        </trans-unit>
        <trans-unit id="b7690c7bdc8f256fde6341fc38dc8edeb2bb2bde" translate="yes" xml:space="preserve">
          <source>Below is typical code that shows how to use &lt;code&gt;LimitOutput&lt;/code&gt;.</source>
          <target state="translated">以下は、 &lt;code&gt;LimitOutput&lt;/code&gt; の使用方法を示す典型的なコードです。</target>
        </trans-unit>
        <trans-unit id="4f28ac791ee08fb184476e4de12d634a0a1d7498" translate="yes" xml:space="preserve">
          <source>Ben Tilly</source>
          <target state="translated">ベン・ティリー</target>
        </trans-unit>
        <trans-unit id="e231863abeba6b63203ae12c8ced1dd832bf1e27" translate="yes" xml:space="preserve">
          <source>Ben Tilly &amp;lt;btilly@gmail.com&amp;gt;</source>
          <target state="translated">ベンティリー&amp;lt;btilly@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="9a552526ddac8fc37648130a16d1381a6f9ad6fb" translate="yes" xml:space="preserve">
          <source>Benchmark - benchmark running times of Perl code</source>
          <target state="translated">Benchmark-Perl コードの実行時間をベンチマークする</target>
        </trans-unit>
        <trans-unit id="c6133998f601e0eb9b2fbe0a853d3f9116d43ce3" translate="yes" xml:space="preserve">
          <source>Benchmark Object</source>
          <target state="translated">ベンチマークオブジェクト</target>
        </trans-unit>
        <trans-unit id="0ff60c3e395ce6dcfa9869e330a91fa3d0e1a335" translate="yes" xml:space="preserve">
          <source>Benchmark inherits from no other class, except of course from Exporter.</source>
          <target state="translated">Benchmarkは、Exporterはもちろんですが、他のクラスを継承していません。</target>
        </trans-unit>
        <trans-unit id="bf40ff62878fab85612abb7b1055df933f606399" translate="yes" xml:space="preserve">
          <source>Benchmark running times of Perl code</source>
          <target state="translated">Perl コードの実行時間のベンチマーク</target>
        </trans-unit>
        <trans-unit id="4b02607a2ea9a6953d07f941016201f155b468af" translate="yes" xml:space="preserve">
          <source>Benjamin Holzman contributed the tied variable support, Andrew Ford contributed the canonical order for hashes, and Gisle Aas fixed a few misunderstandings of mine regarding the perl internals, and optimized the emission of &quot;tags&quot; in the output streams by simply counting the objects instead of tagging them (leading to a binary incompatibility for the Storable image starting at version 0.6--older images are, of course, still properly understood). Murray Nesbitt made Storable thread-safe. Marc Lehmann added overloading and references to tied items support. Benjamin Holzman added a performance improvement for overloaded classes; thanks to Grant Street Group for footing the bill.</source>
          <target state="translated">Benjamin Holzman は tied 変数のサポートに貢献し、Andrew Ford はハッシュの正準順序に貢献し、Gisle Aas は perl の内部に関する私のいくつかの誤解を修正し、出力ストリームにおける「タグ」の放出を、タグを付ける代わりにオブジェクトを単純にカウントすることで最適化しました (バージョン 0.6 からの Storable イメージのバイナリ非互換性につながりますが、古いイメージはもちろんまだ適切に理解されています)。Murray Nesbitt は Storable をスレッドセーフにしました。Marc Lehmann は、オーバーロードと紐付きアイテムへの参照のサポートを追加しました。Benjamin Holzman は、オーバーロードされたクラスのパフォーマンスを改善しました。</target>
        </trans-unit>
        <trans-unit id="97adf5b0f3e282d4b4c33cdd224636f12368207c" translate="yes" xml:space="preserve">
          <source>Benjamin Holzman contributed the tied variable support, Andrew Ford contributed the canonical order for hashes, and Gisle Aas fixed a few misunderstandings of mine regarding the perl internals, and optimized the emission of &quot;tags&quot; in the output streams by simply counting the objects instead of tagging them (leading to a binary incompatibility for the Storable image starting at version 0.6--older images are, of course, still properly understood). Murray Nesbitt made Storable thread-safe. Marc Lehmann added overloading and references to tied items support. Benjamin Holzman added a performance improvement for overloaded classes; thanks to Grant Street Group for footing the bill. Reini Urban took over maintainance from p5p, and added security fixes and huge object support.</source>
          <target state="translated">Benjamin Holzman は tied 変数のサポートに貢献し、Andrew Ford はハッシュの正準順序に貢献し、Gisle Aas は perl の内部に関する私のいくつかの誤解を修正し、出力ストリームにおける「タグ」の放出を、タグを付ける代わりにオブジェクトを単純にカウントすることで最適化しました (バージョン 0.6 からの Storable イメージのバイナリ非互換性につながりますが、古いイメージはもちろんまだ適切に理解されています)。Murray Nesbitt は Storable をスレッドセーフにしました。Marc Lehmann は、オーバーロードと紐付きアイテムへの参照のサポートを追加しました。Benjamin Holzman はオーバーロードされたクラスのパフォーマンスを改善しました。Reini Urban は p5p の保守を引き継ぎ、セキュリティの修正と巨大オブジェクトのサポートを追加しました。</target>
        </trans-unit>
        <trans-unit id="ce63cc3b1fa95fc4c74ca1cad11a70531a58a69f" translate="yes" xml:space="preserve">
          <source>Benjamin Noggle &amp;lt;agwind@users.noreply.github.com&amp;gt;</source>
          <target state="translated">ベンジャミンノグル&amp;lt;agwind@users.noreply.github.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="75fc540bc0a50aa81831bc474ec860350d0bca6e" translate="yes" xml:space="preserve">
          <source>Berkeley DB allows the creation of in-memory databases by using NULL (that is, a &lt;code&gt;(char *)0&lt;/code&gt; in C) in place of the filename. &lt;b&gt;DB_File&lt;/b&gt; uses &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; instead of NULL to provide this functionality.</source>
          <target state="translated">Berkeley DBでは、ファイル名の代わりにNULL（つまり、Cの &lt;code&gt;(char *)0&lt;/code&gt; )を使用して、メモリ内データベースを作成できます。&lt;b&gt;DB_File&lt;/b&gt;は、この機能を提供するためにNULLではなく &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="b44f74f0eaff4623bb4f32a3bc9a77a5a293d873" translate="yes" xml:space="preserve">
          <source>Berkeley DB allows the creation of in-memory databases by using NULL (that is, a &lt;code&gt;(char *)0&lt;/code&gt; in C) in place of the filename. &lt;b&gt;DB_File&lt;/b&gt; uses &lt;code&gt;undef&lt;/code&gt; instead of NULL to provide this functionality.</source>
          <target state="translated">Berkeley DBでは、ファイル名の代わりにNULL（つまり、Cでは &lt;code&gt;(char *)0&lt;/code&gt; )を使用して、インメモリデータベースを作成できます。&lt;b&gt;DB_File&lt;/b&gt;は、この機能を提供するためにNULLではなく &lt;code&gt;undef&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="9268b246582cb1f8cd7166d3bdd75afc5afe74a7" translate="yes" xml:space="preserve">
          <source>Berkeley DB is a C library which provides a consistent interface to a number of database formats. &lt;b&gt;DB_File&lt;/b&gt; provides an interface to all three of the database types currently supported by Berkeley DB.</source>
          <target state="translated">Berkeley DBは、多くのデータベース形式への一貫したインターフェースを提供するCライブラリです。&lt;b&gt;DB_File&lt;/b&gt;は、Berkeley DBで現在サポートされている3つのデータベースタイプすべてへのインターフェースを提供します。</target>
        </trans-unit>
        <trans-unit id="434964490ac8a77af87035de9e77b760d4b578ea" translate="yes" xml:space="preserve">
          <source>Berkeley DB uses the function dbopen() to open or create a database. Here is the C prototype for dbopen():</source>
          <target state="translated">Berkeley DBでは、データベースを開いたり作成したりするためにdbopen()という関数を使用します。ここに dbopen()の C プロトタイプがあります。</target>
        </trans-unit>
        <trans-unit id="cbcc04a4e53af70d968fb1854369b92c28068d53" translate="yes" xml:space="preserve">
          <source>BerkeleyDB is available for Cygwin.</source>
          <target state="translated">CygwinではBerkeleyDBが利用できます。</target>
        </trans-unit>
        <trans-unit id="994ccae3d03329e5f7c9f11ecf6157dc38d89408" translate="yes" xml:space="preserve">
          <source>Beside import() and AUTOLOAD() there are only a few other methods.</source>
          <target state="translated">import()と AUTOLOAD()の他には、いくつかのメソッドがあります。</target>
        </trans-unit>
        <trans-unit id="8eaf9c16309e0e030fec414bcececf296c9fd80c" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#Metacharacters&quot;&gt;&lt;code&gt;&quot;^&quot;&lt;/code&gt; and &lt;code&gt;&quot;$&quot;&lt;/code&gt;&lt;/a&gt;, Perl defines the following zero-width assertions:</source>
          <target state="translated">ほかに&lt;a href=&quot;#Metacharacters&quot;&gt; &lt;code&gt;&quot;^&quot;&lt;/code&gt; と &lt;code&gt;&quot;$&quot;&lt;/code&gt; &lt;/a&gt;、Perlは以下のゼロ幅アサーションを定義しています。</target>
        </trans-unit>
        <trans-unit id="9ba06ebae884c8bbbcddfe487f2f73c4f3cbe88a" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#decode&quot;&gt;&quot;decode&quot;&lt;/a&gt; and &lt;a href=&quot;#encode&quot;&gt;&quot;encode&quot;&lt;/a&gt;, other methods are available as well. For instance, &lt;code&gt;name()&lt;/code&gt; returns the canonical name of the encoding object.</source>
          <target state="translated">他に&lt;a href=&quot;#decode&quot;&gt;「デコード」&lt;/a&gt;および&lt;a href=&quot;#encode&quot;&gt;「コード」&lt;/a&gt;、他の方法が同様に利用可能です。たとえば、 &lt;code&gt;name()&lt;/code&gt; は、エンコーディングオブジェクトの正規名を返します。</target>
        </trans-unit>
        <trans-unit id="0cc3e4e79500c47fb5b02fd6bd36bb30830d4b93" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#decode&quot;&gt;decode&lt;/a&gt; and &lt;a href=&quot;#encode&quot;&gt;encode&lt;/a&gt;, other methods are available as well. For instance, &lt;code&gt;name()&lt;/code&gt; returns the canonical name of the encoding object.</source>
          <target state="translated">他に&lt;a href=&quot;#decode&quot;&gt;、デコード&lt;/a&gt;と&lt;a href=&quot;#encode&quot;&gt;エンコード&lt;/a&gt;、他の方法が同様に利用可能です。たとえば、 &lt;code&gt;name()&lt;/code&gt; は、エンコーディングオブジェクトの正規名を返します。</target>
        </trans-unit>
        <trans-unit id="c3f604e026977938c21e0b164fdc42c9575f5038" translate="yes" xml:space="preserve">
          <source>Besides being a metacharacter, the &lt;code&gt;&quot;.&quot;&lt;/code&gt; is an example of a &quot;character class&quot;, something that can match any single character of a given set of them. In its case, the set is just about all possible characters. Perl predefines several character classes besides the &lt;code&gt;&quot;.&quot;&lt;/code&gt;; there is a separate reference page about just these, &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">メタ文字であることに加えて、 &lt;code&gt;&quot;.&quot;&lt;/code&gt; は「文字クラス」の例であり、特定のセットの任意の1文字に一致するものです。その場合、セットはほぼすべての可能な文字です。 Perlは、 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 以外にいくつかの文字クラスを事前定義しています。 ;これらについては、&lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;という別のリファレンスページがあります。</target>
        </trans-unit>
        <trans-unit id="212828aa9819262a5dba3e04d7db334b30f00e96" translate="yes" xml:space="preserve">
          <source>Besides being able to say &lt;code&gt;\p{Name=...}&lt;/code&gt;, the Name and Name_Aliases properties are accessible through the &lt;code&gt;\N{}&lt;/code&gt; interpolation in double-quoted strings and regular expressions; and functions &lt;code&gt;charnames::viacode()&lt;/code&gt;, &lt;code&gt;charnames::vianame()&lt;/code&gt;, and &lt;code&gt;charnames::string_vianame()&lt;/code&gt; (which require a &lt;code&gt;use charnames ();&lt;/code&gt; to be specified.</source>
          <target state="translated">&lt;code&gt;\p{Name=...}&lt;/code&gt; と言うことができることに加えて、NameプロパティとName_Aliasesプロパティには、二重引用符で囲まれた文字列と正規表現の &lt;code&gt;\N{}&lt;/code&gt; 補間を介してアクセスできます。および関数 &lt;code&gt;charnames::viacode()&lt;/code&gt; 、 &lt;code&gt;charnames::vianame()&lt;/code&gt; 、および &lt;code&gt;charnames::string_vianame()&lt;/code&gt; （ &lt;code&gt;use charnames ();&lt;/code&gt; を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="a7e42697322af6c9745acd371b634a7d3de7f9ce" translate="yes" xml:space="preserve">
          <source>Besides checking existing XS code, the script can also be used to retrieve compatibility information for various API calls using the &lt;code&gt;--api-info&lt;/code&gt; command line switch. For example:</source>
          <target state="translated">スクリプトは、既存のXSコードをチェックするだけでなく、 &lt;code&gt;--api-info&lt;/code&gt; コマンドラインスイッチを使用して、さまざまなAPI呼び出しの互換性情報を取得するためにも使用できます。例えば：</target>
        </trans-unit>
        <trans-unit id="38c540b359fe4177c8733f2554f7c8aac1cf7755" translate="yes" xml:space="preserve">
          <source>Besides many other tests, it will test every locale it finds on your system to see if they conform to the POSIX standard. If any have errors, it will include a summary near the end of the output of which locales passed all its tests, and which failed, and why.</source>
          <target state="translated">他の多くのテストに加えて、システム上で見つけたすべてのロケールが POSIX 標準に準拠しているかどうかをテストします。エラーがあった場合は、出力の最後にどのロケールがすべてのテストに合格し、 どのロケールが失敗したのか、その理由をまとめて出力します。</target>
        </trans-unit>
        <trans-unit id="eaf1b9544c43d438f9e6f77acb1ab9f9247ce8b8" translate="yes" xml:space="preserve">
          <source>Besides putting the cross-compiler and the rest of the toolchain in your PATH, this will also provide the QNX_TARGET variable, which we will pass to Configure through -Dsysroot.</source>
          <target state="translated">クロスコンパイラとツールチェーンの残りの部分を PATH に配置するだけでなく、QNX_TARGET 変数も提供されます。</target>
        </trans-unit>
        <trans-unit id="8731a27dfb4cb7bb97f8e5e387722a8377af9b68" translate="yes" xml:space="preserve">
          <source>Besides saving these hashes as the hashref attributes &lt;code&gt;name2path&lt;/code&gt; and &lt;code&gt;path2name&lt;/code&gt; , calling this function also returns these hashrefs. In list context, the return value of &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; is the list &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; . In scalar context, the return value is &lt;code&gt;\%name2path&lt;/code&gt; . Or you can just call this in void context.</source>
          <target state="translated">これらのハッシュをhashref属性 &lt;code&gt;name2path&lt;/code&gt; および &lt;code&gt;path2name&lt;/code&gt; として保存するほかに、この関数を呼び出すと、これらのハッシュ参照も返されます。リストのコンテキストでは、 &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; の戻り値はリスト &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; です。スカラーコンテキストでは、戻り値は &lt;code&gt;\%name2path&lt;/code&gt; です。または、これをvoidコンテキストで呼び出すこともできます。</target>
        </trans-unit>
        <trans-unit id="68eae0359edab349209444648a1ef905188cfbd0" translate="yes" xml:space="preserve">
          <source>Besides saving these hashes as the hashref attributes &lt;code&gt;name2path&lt;/code&gt; and &lt;code&gt;path2name&lt;/code&gt;, calling this function also returns these hashrefs. In list context, the return value of &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; is the list &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt;. In scalar context, the return value is &lt;code&gt;\%name2path&lt;/code&gt;. Or you can just call this in void context.</source>
          <target state="translated">これらのハッシュをhashref属性 &lt;code&gt;name2path&lt;/code&gt; および &lt;code&gt;path2name&lt;/code&gt; として保存することに加えて、この関数を呼び出すと、これらのハッシュ参照も返されます。リストコンテキストでは、 &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; の戻り値はリスト（\％name2path、\％path2name）です。スカラーコンテキストでは、戻り値は &lt;code&gt;\%name2path&lt;/code&gt; です。または、これをvoidコンテキストで呼び出すこともできます。</target>
        </trans-unit>
        <trans-unit id="6db52c932112966f376fe8b88f42b909a1d77f94" translate="yes" xml:space="preserve">
          <source>Besides taking away the special meaning of a metacharacter, a prefixed backslash changes some letter and digit characters away from matching just themselves to instead have special meaning. These are called &quot;escape sequences&quot;, and all such are described in &lt;a href=&quot;perlrebackslash&quot;&gt;perlrebackslash&lt;/a&gt;. A backslash sequence (of a letter or digit) that doesn't currently have special meaning to Perl will raise a warning if warnings are enabled, as those are reserved for potential future use.</source>
          <target state="translated">メタ文字の特別な意味を取り除くことに加えて、接頭辞付きの円記号は、一部の文字と数字の文字を、それ自体と一致するのではなく、特別な意味を持つように変更します。これらは「エスケープシーケンス」と呼ばれ、そのすべてが&lt;a href=&quot;perlrebackslash&quot;&gt;perlrebackslashで&lt;/a&gt;説明されています。現在Perlにとって特別な意味を持たない（文字または数字の）円記号シーケンスは、警告が有効になっている場合、将来の使用のために予約されているため、警告を発します。</target>
        </trans-unit>
        <trans-unit id="d17cf41d34eb6f4b37b1b9cc872817585f3b1ca4" translate="yes" xml:space="preserve">
          <source>Besides the &lt;code&gt;$|&lt;/code&gt; special variable, you can use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to give your filehandle a &lt;code&gt;:unix&lt;/code&gt; layer, which is unbuffered:</source>
          <target state="translated">&lt;code&gt;$|&lt;/code&gt; 以外にも 特別な変数の場合、 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; を使用して、ファイルハンドルに &lt;code&gt;:unix&lt;/code&gt; レイヤーを与えることができます。</target>
        </trans-unit>
        <trans-unit id="28b7e372985d4c31ff927994e7e34211eb124b71" translate="yes" xml:space="preserve">
          <source>Besides the &lt;code&gt;$|&lt;/code&gt; special variable, you can use &lt;code&gt;binmode&lt;/code&gt; to give your filehandle a &lt;code&gt;:unix&lt;/code&gt; layer, which is unbuffered:</source>
          <target state="translated">ほかに &lt;code&gt;$|&lt;/code&gt; 特別な変数 &lt;code&gt;binmode&lt;/code&gt; を使用して、ファイルハンドルに &lt;code&gt;:unix&lt;/code&gt; レイヤーを与えることができます。これはバッファリングされていません：</target>
        </trans-unit>
        <trans-unit id="c874def12573a04b6982ff2c45bf57742f038615" translate="yes" xml:space="preserve">
          <source>Besides the NBSP character discussed above, implementors are reminded of the existence of the other &quot;special&quot; character in Latin-1, the &quot;soft hyphen&quot; character, also known as &quot;discretionary hyphen&quot;, i.e. &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ). This character expresses an optional hyphenation point. That is, it normally renders as nothing, but may render as a &quot;-&quot; if a formatter breaks the word at that point. Pod formatters should, as appropriate, do one of the following: 1) render this with a code with the same meaning (e.g., &quot;\-&quot; in RTF), 2) pass it through in the expectation that the formatter understands this character as such, or 3) delete it.</source>
          <target state="translated">上記のNBSP文字に加えて、実装者はLatin-1に他の「特殊」文字、「ソフトハイフン」文字、つまり「任意ハイフン」としても知られている、つまり &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ）。この文字は、オプションのハイフネーションポイントを表します。つまり、通常は何もレンダリングされませんが、フォーマッターがその時点で単語を分割すると、「-」としてレンダリングされる可能性があります。ポッドフォーマッターは、必要に応じて、次のいずれかを実行する必要があります。1）これを同じ意味のコード（たとえば、RTFの「\-」）でレンダリングします。2）フォーマッターがこの文字を次のように理解することを期待してパススルーしますそのような、または3）それを削除します。</target>
        </trans-unit>
        <trans-unit id="fb9d8bd5854ba8b088687eedfedb188dbc42540c" translate="yes" xml:space="preserve">
          <source>Besides the NBSP character discussed above, implementors are reminded of the existence of the other &quot;special&quot; character in Latin-1, the &quot;soft hyphen&quot; character, also known as &quot;discretionary hyphen&quot;, i.e. &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt;). This character expresses an optional hyphenation point. That is, it normally renders as nothing, but may render as a &quot;-&quot; if a formatter breaks the word at that point. Pod formatters should, as appropriate, do one of the following: 1) render this with a code with the same meaning (e.g., &quot;\-&quot; in RTF), 2) pass it through in the expectation that the formatter understands this character as such, or 3) delete it.</source>
          <target state="translated">上記のNBSP文字に加えて、実装者は、Latin-1の他の「特殊」文字、「任意のハイフン」としても知られる「ソフトハイフン」文字、つまり &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ）。この文字は、オプションのハイフネーションポイントを表します。つまり、通常は何も表示されませんが、フォーマッターがその時点で単語を分割すると、「-」として表示される場合があります。ポッドフォーマッタは、必要に応じて、次のいずれかを実行する必要があります。1）同じ意味のコードでこれをレンダリングします（たとえば、RTFの「\-」）。2）フォーマッタがこの文字を次のように理解することを期待してパススルーします。そのような、または3）それを削除します。</target>
        </trans-unit>
        <trans-unit id="383f64e6a803d40e90542694df252e926486880e" translate="yes" xml:space="preserve">
          <source>Besides the normal array index looping, &lt;code&gt;for&lt;/code&gt; can lend itself to many other interesting applications. Here's one that avoids the problem you get into if you explicitly test for end-of-file on an interactive file descriptor causing your program to appear to hang.</source>
          <target state="translated">通常の配列インデックスのループの他に、 &lt;code&gt;for&lt;/code&gt; は他の多くの興味深いアプリケーションに役立ちます。これは、対話型ファイル記述子でファイルの終わりを明示的にテストしてプログラムがハングしているように見える場合に発生する問題を回避するものです。</target>
        </trans-unit>
        <trans-unit id="b788aba9c107e5a4eaba0767ff3be57caf43c88d" translate="yes" xml:space="preserve">
          <source>Besides the obvious documents, source code can be instructive. Some pathological examples of the use of references can be found in the</source>
          <target state="translated">明白な文書以外にも、ソースコードは有益です。リファレンスの使用に関するいくつかの病的な例は</target>
        </trans-unit>
        <trans-unit id="3cd8fe6552552b50530c70ff871d9df229c4d203" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man also takes care of formatting func(), func(3), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; makes C++ look right, puts a little space between double underscores, makes ALLCAPS a teeny bit smaller in &lt;b&gt;troff&lt;/b&gt;, and escapes stuff that *roff treats as special so that you don't have to.</source>
          <target state="translated">明白なポッド変換の他に、Pod :: Manは、func（）、func（3）、および$ fooや@barなどの単純な変数参照のフォーマットも処理するため、コードエスケープを使用する必要はありません。ただし、 &lt;code&gt;$fred{'stuff'}&lt;/code&gt; などの複雑な式はエスケープする必要があります。また、ハイフンとして使用されていないダッシュをenダッシュに変換し、このように長いダッシュを適切なemダッシュに変換し、「ペアの引用符」を修正し、C ++を正しく見せるようにし、二重下線の間に少しスペースを入れ、ALLCAPSを作成します。&lt;b&gt;troff&lt;/b&gt;は少し小さく、* roffが特別なものとして扱うものをエスケープします。</target>
        </trans-unit>
        <trans-unit id="5bb351a96d9e7856a11971d899903843a4ce13f1" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man, and therefore pod2man also takes care of formatting func(), func(n), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; and takes care of several other troff-specific tweaks. See &lt;a href=&quot;Pod::Man&quot;&gt;Pod::Man&lt;/a&gt; for complete information.</source>
          <target state="translated">明らかなポッド変換に加えて、Pod :: Man、したがってpod2manは、func（）、func（n）、および$ fooや@barなどの単純な変数参照のフォーマットも処理するため、コードエスケープを使用する必要はありません。 ; ただし、 &lt;code&gt;$fred{'stuff'}&lt;/code&gt; ような複雑な式はエスケープする必要があります。また、ハイフンとして使用されていないダッシュをenダッシュに変換し、このように長いダッシュを適切なemダッシュに変換し、「ペア引用符」を修正し、その他のいくつかのtroff固有の調整を処理します。詳細については、&lt;a href=&quot;Pod::Man&quot;&gt;Pod :: Man&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a063aa374e8d2e7cef3baa1877fd812efaeadbc4" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man, and therefore pod2man also takes care of formatting func(), func(n), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; and takes care of several other troff-specific tweaks. See &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; for complete information.</source>
          <target state="translated">明白なポッド変換に加えて、Pod :: Man、したがってpod2manは、func（）、func（n）、および$ fooや@barなどの単純な変数参照のフォーマットも処理するため、コードエスケープを使用する必要はありません。 ; ただし、 &lt;code&gt;$fred{'stuff'}&lt;/code&gt; などの複雑な式はエスケープする必要があります。また、ハイフンとして使用されていないダッシュをenダッシュに変換し、このように長いダッシュを適切なemダッシュに変換し、「ペアの引用符」を修正し、その他のいくつかのtroff固有の調整を処理します。詳細については、&lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2b7e5467e3e0ec9a6b2fff1ef3ee081c7b986017" translate="yes" xml:space="preserve">
          <source>Besides the well-known &quot;E&amp;lt;lt&amp;gt;&quot; and &quot;E&amp;lt;gt&amp;gt;&quot; codes for less-than and greater-than, Pod parsers must understand &quot;E&amp;lt;sol&amp;gt;&quot; for &quot;/&quot; (solidus, slash), and &quot;E&amp;lt;verbar&amp;gt;&quot; for &quot;|&quot; (vertical bar, pipe). Pod parsers should also understand &quot;E&amp;lt;lchevron&amp;gt;&quot; and &quot;E&amp;lt;rchevron&amp;gt;&quot; as legacy codes for characters 171 and 187, i.e., &quot;left-pointing double angle quotation mark&quot; = &quot;left pointing guillemet&quot; and &quot;right-pointing double angle quotation mark&quot; = &quot;right pointing guillemet&quot;. (These look like little &quot;&amp;lt;&amp;lt;&quot; and &quot;&amp;gt;&amp;gt;&quot;, and they are now preferably expressed with the HTML/XHTML codes &quot;E&amp;lt;laquo&amp;gt;&quot; and &quot;E&amp;lt;raquo&amp;gt;&quot;.)</source>
          <target state="translated">小なりと大なりのよく知られた「E &amp;lt;lt&amp;gt;」と「E &amp;lt;gt&amp;gt;」のコードに加えて、ポッドパーサーは「/」（固相線、スラッシュ）の「E &amp;lt;sol&amp;gt;」、および「 E &amp;lt;verbar&amp;gt; &quot;for&quot; | &quot; （垂直バー、パイプ）。ポッドパーサーは、「E &amp;lt;lchevron&amp;gt;」と「E &amp;lt;rchevron&amp;gt;」を文字171と187のレガシーコードとして理解する必要もあります。つまり、「左向きの二重角引用符」=「左向きのギレメット」と「右向きの二重」角度引用符 &quot;=&quot;右向きギレメット &quot;。 （これらは小さな「&amp;lt;&amp;lt;」と「&amp;gt;&amp;gt;」のように見えますが、HTML / XHTMLコード「E &amp;lt;laquo&amp;gt;」と「E &amp;lt;raquo&amp;gt;」で表現されることが望ましいです。）</target>
        </trans-unit>
        <trans-unit id="860a34f94eb6573e4bc9c4a64ff033a99b23eda5" translate="yes" xml:space="preserve">
          <source>Besides these, all the Unicode character properties mentioned above (except for those marked as for internal use by Perl) are also accessible by &lt;a href=&quot;Unicode::UCD#prop_invlist%28%29&quot;&gt;&quot;prop_invlist()&quot; in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">これらに加えて、上記のすべてのUnicode文字プロパティ（Perlによる内部使用としてマークされたものを除く）は&lt;a href=&quot;Unicode::UCD#prop_invlist%28%29&quot;&gt;、Unicode :: UCDの「prop_invlist（）」から&lt;/a&gt;もアクセスできます。</target>
        </trans-unit>
        <trans-unit id="5b2158802b148a274c615dff49ad8ceaf2fe4a86" translate="yes" xml:space="preserve">
          <source>Besides these, all the Unicode character properties mentioned above (except for those marked as for internal use by Perl) are also accessible by &lt;a href=&quot;unicode/ucd#prop_invlist()&quot;&gt;prop_invlist() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">これらに加えて、上記のすべてのUnicode文字プロパティ（Perlによる内部使用としてマークされているものを除く）は&lt;a href=&quot;unicode/ucd#prop_invlist()&quot;&gt;、Unicode :: UCDのprop_invlist（）から&lt;/a&gt;もアクセスできます。</target>
        </trans-unit>
        <trans-unit id="708a3f784c168edb7cbbe1a181dbe5bffd40a3cc" translate="yes" xml:space="preserve">
          <source>Besides whole phrases meant for output, anything language-dependent should be put into the class Projname::L10N::en_us, whether as methods, or as lexicon entries -- this is discussed in the section &quot;Entries in Each Lexicon&quot;, above.</source>
          <target state="translated">出力のためのフレーズ全体の他に、言語に依存するものは、メソッドとしても、レキシコンのエントリとしても、クラスProjname::L10N::en_usに入れなければなりません --これは、上記の &quot;各レキシコンのエントリ &quot;のセクションで議論されています。</target>
        </trans-unit>
        <trans-unit id="ab1d9532fa300263b037333b93fafef9210c8c57" translate="yes" xml:space="preserve">
          <source>Besides, I don't know how to write the damned things.</source>
          <target state="translated">それに、どうやって書けばいいのかわからない。</target>
        </trans-unit>
        <trans-unit id="cd7916b96afe381cf04fb2aeca341eed5cca3a69" translate="yes" xml:space="preserve">
          <source>Best practices for making a new module.</source>
          <target state="translated">新しいモジュールを作るためのベストプラクティス</target>
        </trans-unit>
        <trans-unit id="ae28545952ad516171bc8541be8a3d6e7dcf583f" translate="yes" xml:space="preserve">
          <source>Better diagnostics capabilities.</source>
          <target state="translated">診断機能が向上しました。</target>
        </trans-unit>
        <trans-unit id="80d4f16c5fc7da807c79c20a2575508b93d90392" translate="yes" xml:space="preserve">
          <source>Between &lt;code&gt;pairs&lt;/code&gt; and &lt;code&gt;unpairs&lt;/code&gt;, a higher-order list function can be used to operate on the pairs as single scalars; such as the following near-equivalents of the other &lt;code&gt;pair*&lt;/code&gt; higher-order functions:</source>
          <target state="translated">&lt;code&gt;pairs&lt;/code&gt; と &lt;code&gt;unpairs&lt;/code&gt; 間では、高階リスト関数を使用して、ペアを単一のスカラーとして操作できます。他の &lt;code&gt;pair*&lt;/code&gt; 高階関数の次のほぼ同等のものなど：</target>
        </trans-unit>
        <trans-unit id="5f9760622e022594213ec306985fb05bd7325740" translate="yes" xml:space="preserve">
          <source>Between Mac OS X 10.3 &quot;Panther&quot; and 10.6 &quot;Snow Leopard&quot;, the 'Command Line Tools' bundle was called 'unix tools', and was usually supplied with Mac OS install DVDs.</source>
          <target state="translated">Mac OS X 10.3 &quot;Panther &quot;から10.6 &quot;Snow Leopard &quot;までの間、「コマンドラインツール」バンドルは「unix tools」と呼ばれ、通常はMac OSのインストールDVDに付属していました。</target>
        </trans-unit>
        <trans-unit id="6249e6fb239ee6aed11ccf460f154f4ff6f24738" translate="yes" xml:space="preserve">
          <source>Between the &lt;code&gt;%&lt;/code&gt; and the format letter, you may specify several additional attributes controlling the interpretation of the format. In order, these are:</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; とフォーマット文字の間に、フォーマットの解釈を制御するいくつかの追加属性を指定できます。順に、次のとおりです。</target>
        </trans-unit>
        <trans-unit id="b8011f36b2088bc97398915695cf8abfb01b5b1d" translate="yes" xml:space="preserve">
          <source>Beware also of the order of more complicated expressions like:</source>
          <target state="translated">のような、より複雑な表現の順番にも注意してください。</target>
        </trans-unit>
        <trans-unit id="6cfef1757642ae2cc2b58e48199cf1ffe99563dc" translate="yes" xml:space="preserve">
          <source>Beware of casting the entire expression, as this would cast the result, at which point it is too late:</source>
          <target state="translated">表現全体をキャストすることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6c100dc724a3253ddc31a97cdb43e9fdb264b604" translate="yes" xml:space="preserve">
          <source>Beware of simple &quot;casting&quot; the entire expression, this would only convert the already computed result:</source>
          <target state="translated">式全体を単純に「キャスト」することに注意してください。</target>
        </trans-unit>
        <trans-unit id="993aa75891c2224a1f9c297f58bf1ffa758e779f" translate="yes" xml:space="preserve">
          <source>Beware of the &quot;else syndrome&quot;:</source>
          <target state="translated">else症候群」にご用心。</target>
        </trans-unit>
        <trans-unit id="1a9c3aa0cee4b1c15e1e5a6a65e3ca3cde192e4e" translate="yes" xml:space="preserve">
          <source>Beware of using &lt;code&gt;&quot;$&quot;&lt;/code&gt; to indicate to match the end of the string. It can too easily be interpreted as being a punctuation variable, like &lt;code&gt;$/&lt;/code&gt;.</source>
          <target state="translated">文字列の終わりに一致することを示すために &lt;code&gt;&quot;$&quot;&lt;/code&gt; を使用することに注意してください。 &lt;code&gt;$/&lt;/code&gt; ような句読点変数として簡単に解釈できます。</target>
        </trans-unit>
        <trans-unit id="c8bc77265aea976e7b646f3af43c05662f7e17da" translate="yes" xml:space="preserve">
          <source>Beware of:</source>
          <target state="translated">気をつけてください。</target>
        </trans-unit>
        <trans-unit id="6bac55531c21ad380bc95de89addf1faea92b643" translate="yes" xml:space="preserve">
          <source>Beware that if you put literal backslashes (those not inside interpolated variables) between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; , double-quotish backslash interpolation may lead to confusing results. If you</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; と &lt;code&gt;\E&lt;/code&gt; 間にリテラルのバックスラッシュ（補間変数の内部にないもの）を置くと、二重引用符のバックスラッシュの補間が結果を混乱させる可能性があることに注意してください。もし、あんたが</target>
        </trans-unit>
        <trans-unit id="eebfc88db53433dbd95a0208b9c35bedb078dc7e" translate="yes" xml:space="preserve">
          <source>Beware that if you put literal backslashes (those not inside interpolated variables) between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt;, double-quotish backslash interpolation may lead to confusing results. If you</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; と &lt;code&gt;\E&lt;/code&gt; 間にリテラルバックスラッシュ（補間された変数内にないもの）を配置すると、二重引用符のバックスラッシュ補間によって混乱する結果が生じる可能性があることに注意してください。もし、あんたが</target>
        </trans-unit>
        <trans-unit id="5349c42e3fc571db11577ff5f6cb8d88af8429b8" translate="yes" xml:space="preserve">
          <source>Beware that in a UTF-8 locale, anything you pass to this function must be in UTF-8; and when not in a UTF-8 locale, anything passed must not be UTF-8 encoded.</source>
          <target state="translated">UTF-8ロケールの場合、この関数に渡すものはすべてUTF-8でなければならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="6ca66f864461fdc36869edeb4abd6935993616b0" translate="yes" xml:space="preserve">
          <source>Beware that some command shells may place restrictions on the length of the command line. You must ensure your strings don't exceed this limit after any necessary interpolations. See the platform-specific release notes for more details about your particular environment.</source>
          <target state="translated">コマンドシェルによっては、コマンドラインの長さに制限がある場合があるので注意してください。必要な補間を行った後は、文字列がこの制限を超えないようにしなければなりません。特定の環境の詳細については、プラットフォーム固有のリリースノートを参照してください。</target>
        </trans-unit>
        <trans-unit id="9cd8d5856a80822f4c1d90c9c02e95de943bc843" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#join-EXPR%2CLIST&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt;とは異なり、&lt;a href=&quot;#join-EXPR%2CLIST&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt;は最初の引数としてパターンをとらないことに注意してください。&lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt;比較します。</target>
        </trans-unit>
        <trans-unit id="1bd1204f447158c3ff1bfbe82d9a707a81d4fa56" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;#split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; とは異なり、 &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; は最初の引数としてパターンを取りません。&lt;a href=&quot;#split&quot;&gt;分割を&lt;/a&gt;比較します。</target>
        </trans-unit>
        <trans-unit id="bc2144e8f71ac4bf9140995eea7dc924e6bdda59" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; とは異なり、 &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; は最初の引数としてパターンを取りません。&lt;a href=&quot;split&quot;&gt;分割を&lt;/a&gt;比較します。</target>
        </trans-unit>
        <trans-unit id="c39aa460c8cfb8c3295132732d48ee06e763b200" translate="yes" xml:space="preserve">
          <source>Beware: This feature is not fully implemented yet.</source>
          <target state="translated">ご注意ください。この機能はまだ完全には実装されていません。</target>
        </trans-unit>
        <trans-unit id="d3f2ff6e4b3a254c248f8c186f3f0868a1b1e7b1" translate="yes" xml:space="preserve">
          <source>Beware: This list is not complete.</source>
          <target state="translated">注意してください。このリストは完全ではありません。</target>
        </trans-unit>
        <trans-unit id="85c248dc6ba19bfc8397a2d612c997c46ad24985" translate="yes" xml:space="preserve">
          <source>Beware: after this function returns, &lt;code&gt;ptr&lt;/code&gt; and SvPVX_const(sv) may no longer refer to the same chunk of data.</source>
          <target state="translated">注意：この関数が戻った後、 &lt;code&gt;ptr&lt;/code&gt; とSvPVX_const（sv）は同じデータのチャンクを参照できなくなります。</target>
        </trans-unit>
        <trans-unit id="40ca4e03748bbc6d9d8fdf7c985dd464c29b4a02" translate="yes" xml:space="preserve">
          <source>Beyond Unicode code points</source>
          <target state="translated">Unicodeコードポイントを超えて</target>
        </trans-unit>
        <trans-unit id="8d2086dee2d46aa5a491374a05ac5325e10530d7" translate="yes" xml:space="preserve">
          <source>Beyond make test</source>
          <target state="translated">テストを作って下さい</target>
        </trans-unit>
        <trans-unit id="16881dc1b286f9fd89e3c68a1307509ea4208790" translate="yes" xml:space="preserve">
          <source>Beyond raw access to the API calls and related constants, this module handles smart buffer allocation and translation of return codes.</source>
          <target state="translated">API 呼び出しと関連する定数への生のアクセスに加えて、このモジュールはスマートバッファの割り当てとリターンコードの翻訳を処理します。</target>
        </trans-unit>
        <trans-unit id="7071855c582934ec0ec68ba51cead15591289a64" translate="yes" xml:space="preserve">
          <source>Beyond that help, the urllist config parameter is yours. You can add and remove sites at will. You should find out which sites have the best up-to-dateness, bandwidth, reliability, etc. and are topologically close to you. Some people prefer fast downloads, others up-to-dateness, others reliability. You decide which to try in which order.</source>
          <target state="translated">そのヘルプを超えて、urllistの設定パラメータはあなたのものです。サイトの追加や削除は自由に行えます。どのサイトが最新性、帯域幅、信頼性などが最も優れていて、トポロジカルにあなたの近くにあるのかを見つけるべきです。高速ダウンロードを好む人もいれば、最新性を好む人もいれば、信頼性を好む人もいます。どの順番で試すかはあなたが決めてください。</target>
        </trans-unit>
        <trans-unit id="3f05839b089d755d215e2ff3af4aafe1ec68679d" translate="yes" xml:space="preserve">
          <source>Beyond that, the simplest debugger is the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function. Use it to look at values as you run your program:</source>
          <target state="translated">さらに、最も簡単なデバッガは &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 機能です。これを使用して、プログラムを実行しながら値を確認します。</target>
        </trans-unit>
        <trans-unit id="cc8c0bdbbf061aa1132ad0db52bd5ab409c1d5c4" translate="yes" xml:space="preserve">
          <source>Beyond that, the simplest debugger is the &lt;code&gt;print&lt;/code&gt; function. Use it to look at values as you run your program:</source>
          <target state="translated">それを超えて、最も単純なデバッガーは &lt;code&gt;print&lt;/code&gt; 機能です。これを使用して、プログラムの実行時に値を確認します。</target>
        </trans-unit>
        <trans-unit id="3981fa65dd4a5a67077c84cbcab0e6d7e62ef4b1" translate="yes" xml:space="preserve">
          <source>Beyond that, you have to consider several things and decide which is best for you.</source>
          <target state="translated">その先には、いくつかのことを考えて、どれが自分にとってベストなのかを決める必要があります。</target>
        </trans-unit>
        <trans-unit id="44d69eda49b459248ce90b6917e4f918be54d8d4" translate="yes" xml:space="preserve">
          <source>Beyond the normal measures described to make general Perl programs faster or smaller, a CGI program has additional issues. It may be run several times per second. Given that each time it runs it will need to be re-compiled and will often allocate a megabyte or more of system memory, this can be a killer. Compiling into C &lt;b&gt;isn't going to help you&lt;/b&gt; because the process start-up overhead is where the bottleneck is.</source>
          <target state="translated">一般的なPerlプログラムを高速化または小型化するために説明されている通常の対策に加えて、CGIプログラムには追加の問題があります。1秒間に数回実行される場合があります。実行するたびに再コンパイルする必要があり、メガバイト以上のシステムメモリが割り当てられることが多いため、これはキラーになる可能性があります。Cにコンパイルし&lt;b&gt;ても&lt;/b&gt;、プロセスの起動オーバーヘッドがボトルネックになるため、&lt;b&gt;役に立ちません&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="213d672c8ec1c5c132adb8f810eb6a5d6ae1c84f" translate="yes" xml:space="preserve">
          <source>Beyond the obvious problems that stem from giving special privileges to systems as flexible as scripts, on many versions of Unix, set-id scripts are inherently insecure right from the start. The problem is a race condition in the kernel. Between the time the kernel opens the file to see which interpreter to run and when the (now-set-id) interpreter turns around and reopens the file to interpret it, the file in question may have changed, especially if you have symbolic links on your system.</source>
          <target state="translated">スクリプトのように柔軟性のあるシステムに特別な権限を与えることに起因する明白な問題に加えて、多くのバージョンの Unix では、set-id スクリプトは最初から本質的に安全ではありません。問題はカーネル内の競合状態です。カーネルがどのインタプリタを実行するかを確認するためにファイルを開いてから、 (現在設定されている)インタプリタがそれを解釈するためにファイルを開き直すまでの間に、問題のファイルが変更されている可能性があります (特にシステム上にシンボリックリンクがある場合)。</target>
        </trans-unit>
        <trans-unit id="cfa5b349eaf3622485b4949d5b4c1629b7136aa6" translate="yes" xml:space="preserve">
          <source>BhkDISABLE</source>
          <target state="translated">BhkDISABLE</target>
        </trans-unit>
        <trans-unit id="097eaa76fb990cb3c085617a09bb68f2d2dd28d0" translate="yes" xml:space="preserve">
          <source>BhkENABLE</source>
          <target state="translated">BhkENABLE</target>
        </trans-unit>
        <trans-unit id="56657a5c49e88295c9fdbd426498620306255970" translate="yes" xml:space="preserve">
          <source>BhkENTRY</source>
          <target state="translated">BhkENTRY</target>
        </trans-unit>
        <trans-unit id="eed78c8324c929e21a7725f018dc13f233941d2d" translate="yes" xml:space="preserve">
          <source>BhkENTRY_set</source>
          <target state="translated">BhkENTRY_set</target>
        </trans-unit>
        <trans-unit id="6303b515a179b4880dfa9b0c5bdeef24554d4d0d" translate="yes" xml:space="preserve">
          <source>BhkFLAGS</source>
          <target state="translated">BhkFLAGS</target>
        </trans-unit>
        <trans-unit id="619d65e1ae1a2704aa306451ac2a75a0cde345a8" translate="yes" xml:space="preserve">
          <source>Bibliography</source>
          <target state="translated">Bibliography</target>
        </trans-unit>
        <trans-unit id="c81d74ec4f5774b83707b81c40273f9931cc6799" translate="yes" xml:space="preserve">
          <source>BidiCharacterTest.txt</source>
          <target state="translated">BidiCharacterTest.txt</target>
        </trans-unit>
        <trans-unit id="69ecda50c93df6838e91e9e521a5ea42b19e7e09" translate="yes" xml:space="preserve">
          <source>BidiTest.txt</source>
          <target state="translated">BidiTest.txt</target>
        </trans-unit>
        <trans-unit id="603c926318562657586c9e1146fc9dbe3c25c988" translate="yes" xml:space="preserve">
          <source>Bidirectional Character Types</source>
          <target state="translated">双方向文字タイプ</target>
        </trans-unit>
        <trans-unit id="b4412d2ae1aa691608b316e9ad2227f4c8f05c5f" translate="yes" xml:space="preserve">
          <source>Bidirectional Communication with Another Process</source>
          <target state="translated">他プロセスとの双方向通信</target>
        </trans-unit>
        <trans-unit id="20453df9f611f7ce81199fe2171f3b15f7db6ba1" translate="yes" xml:space="preserve">
          <source>Bidirectional Communication with Yourself</source>
          <target state="translated">自分との双方向コミュニケーション</target>
        </trans-unit>
        <trans-unit id="de1698114af4355c5ccd60424049fded636df6a2" translate="yes" xml:space="preserve">
          <source>Big5</source>
          <target state="translated">Big5</target>
        </trans-unit>
        <trans-unit id="aaec1a206ed8540735d6653165ead4690d690a5c" translate="yes" xml:space="preserve">
          <source>BigInt's bcmp() routine currently returns undef to signal that a NaN was involved in a comparison. However, the overload code turns that into either 1 or '' and thus operations like &lt;code&gt;NaN != NaN&lt;/code&gt; might return wrong values.</source>
          <target state="translated">BigIntのbcmp（）ルーチンは現在、undefを返し、NaNが比較に関与したことを通知します。ただし、オーバーロードコードはそれを1または ''のいずれかに変換するため、 &lt;code&gt;NaN != NaN&lt;/code&gt; ような操作は誤った値を返す可能性があります。</target>
        </trans-unit>
        <trans-unit id="b68a65a4af953b7e6ff32f4e519ad10e0c7af47b" translate="yes" xml:space="preserve">
          <source>Bigger Numbers</source>
          <target state="translated">数字を大きくする</target>
        </trans-unit>
        <trans-unit id="98032da695f3e799620752e98882e414e0196f49" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!=&quot;&lt;/code&gt; returns true if the left argument is numerically not equal to the right argument.</source>
          <target state="translated">左側の引数が数値的に右側の引数と等しくない場合、バイナリ &lt;code&gt;&quot;!=&quot;&lt;/code&gt; はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="0806ad998452d5851f139bbe3f01d7066c39cefd" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; is just like &lt;code&gt;&quot;=~&quot;&lt;/code&gt; except the return value is negated in the logical sense.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;!~&quot;&lt;/code&gt; は、戻り値が論理的に否定されることを除いて、 &lt;code&gt;&quot;=~&quot;&lt;/code&gt; 〜&quot;と同じです。</target>
        </trans-unit>
        <trans-unit id="958b8a1169468f4a63917c7ca8496d2c631c8da0" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; with a non-destructive substitution (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt;) or transliteration (&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt;) is a syntax error.</source>
          <target state="translated">非破壊的な置換（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; ）または音訳（ &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt; ）を含むバイナリ &lt;code&gt;&quot;!~&quot;&lt;/code&gt; は構文エラーです。</target>
        </trans-unit>
        <trans-unit id="669b5730a4de160e3201236f63831582ab97b4ad" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; with a non-destructive substitution (&lt;code&gt;s///r&lt;/code&gt;) or transliteration (&lt;code&gt;y///r&lt;/code&gt;) is a syntax error.</source>
          <target state="translated">非破壊置換（ &lt;code&gt;s///r&lt;/code&gt; ）または音訳（ &lt;code&gt;y///r&lt;/code&gt; ）を使用したバイナリ &lt;code&gt;&quot;!~&quot;&lt;/code&gt; は構文エラーです。</target>
        </trans-unit>
        <trans-unit id="f26c16627064dbaf94b2accf763da8c7ea571aa3" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;%&quot;&lt;/code&gt; is the modulo operator, which computes the division remainder of its first argument with respect to its second argument. Given integer operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; : If &lt;code&gt;$n&lt;/code&gt; is positive, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the largest multiple of &lt;code&gt;$n&lt;/code&gt; less than or equal to &lt;code&gt;$m&lt;/code&gt; . If &lt;code&gt;$n&lt;/code&gt; is negative, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the smallest multiple of &lt;code&gt;$n&lt;/code&gt; that is not less than &lt;code&gt;$m&lt;/code&gt; (that is, the result will be less than or equal to zero). If the operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; are floating point values and the absolute value of &lt;code&gt;$n&lt;/code&gt; (that is &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt;) is less than &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , only the integer portion of &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; will be used in the operation (Note: here &lt;code&gt;UV_MAX&lt;/code&gt; means the maximum of the unsigned integer type). If the absolute value of the right operand (&lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt;) is greater than or equal to &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; computes the floating-point remainder &lt;code&gt;$r&lt;/code&gt; in the equation &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; where &lt;code&gt;$i&lt;/code&gt; is a certain integer that makes &lt;code&gt;$r&lt;/code&gt; have the same sign as the right operand &lt;code&gt;$n&lt;/code&gt; (&lt;b&gt;not&lt;/b&gt; as the left operand &lt;code&gt;$m&lt;/code&gt; like C function &lt;code&gt;fmod()&lt;/code&gt; ) and the absolute value less than that of &lt;code&gt;$n&lt;/code&gt; . Note that when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; is in scope, &lt;code&gt;&quot;%&quot;&lt;/code&gt; gives you direct access to the modulo operator as implemented by your C compiler. This operator is not as well defined for negative operands, but it will execute faster.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;%&quot;&lt;/code&gt; は、2番目の引数に対する最初の引数の除算剰余を計算するモジュロ演算子です。整数オペランド所与 &lt;code&gt;$m&lt;/code&gt; および &lt;code&gt;$n&lt;/code&gt; ：場合 &lt;code&gt;$n&lt;/code&gt; 正である場合、 &lt;code&gt;$m % $n&lt;/code&gt; であり、 &lt;code&gt;$m&lt;/code&gt; マイナスの最大複数 &lt;code&gt;$n&lt;/code&gt; より小さいか等しい &lt;code&gt;$m&lt;/code&gt; 。場合 &lt;code&gt;$n&lt;/code&gt; 負で、その後で &lt;code&gt;$m % $n&lt;/code&gt; で &lt;code&gt;$m&lt;/code&gt; マイナスの最小複数 &lt;code&gt;$n&lt;/code&gt; 未満でない &lt;code&gt;$m&lt;/code&gt; （すなわち、結果未満またはゼロに等しいであろう）。オペランド &lt;code&gt;$m&lt;/code&gt; と &lt;code&gt;$n&lt;/code&gt; は浮動小数点値であり、 &lt;code&gt;$n&lt;/code&gt; 絶対値（つまり &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt; ）は &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; 未満です。 &lt;code&gt;$m&lt;/code&gt; と &lt;code&gt;$n&lt;/code&gt; 整数部分のみが操作で使用されます（注：ここで &lt;code&gt;UV_MAX&lt;/code&gt; は、符号なし整数型の最大値を意味します）。右のオペランドの絶対値（ &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt; ）が &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; 以上の場合、 &lt;code&gt;&quot;%&quot;&lt;/code&gt; は、式 &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; の浮動小数点剰余 &lt;code&gt;$r&lt;/code&gt; を計算します* $ N） &lt;code&gt;$i&lt;/code&gt; なる特定の整数であり、 &lt;code&gt;$r&lt;/code&gt; 右のオペランドと同じ符号を有しているが &lt;code&gt;$n&lt;/code&gt; （C関数 &lt;code&gt;fmod()&lt;/code&gt; のような左のオペランド &lt;code&gt;$m&lt;/code&gt; としてでは&lt;b&gt;なく&lt;/b&gt;）および &lt;code&gt;$n&lt;/code&gt; 絶対値より小さい絶対値。ときに注意 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 整数がスコープ内にある、 &lt;code&gt;&quot;%&quot;&lt;/code&gt; 、あなたのCコンパイラによって実装されるあなたのモジュロ演算子への直接アクセスを提供します。この演算子は負のオペランドに対しては十分に定義されていませんが、実行速度は速くなります。</target>
        </trans-unit>
        <trans-unit id="41e316d0ff24f3ca1a3464d44861dfcd88d324d8" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;%&quot;&lt;/code&gt; is the modulo operator, which computes the division remainder of its first argument with respect to its second argument. Given integer operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt;: If &lt;code&gt;$n&lt;/code&gt; is positive, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the largest multiple of &lt;code&gt;$n&lt;/code&gt; less than or equal to &lt;code&gt;$m&lt;/code&gt;. If &lt;code&gt;$n&lt;/code&gt; is negative, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the smallest multiple of &lt;code&gt;$n&lt;/code&gt; that is not less than &lt;code&gt;$m&lt;/code&gt; (that is, the result will be less than or equal to zero). If the operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; are floating point values and the absolute value of &lt;code&gt;$n&lt;/code&gt; (that is &lt;code&gt;abs($n)&lt;/code&gt;) is less than &lt;code&gt;(UV_MAX + 1)&lt;/code&gt;, only the integer portion of &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; will be used in the operation (Note: here &lt;code&gt;UV_MAX&lt;/code&gt; means the maximum of the unsigned integer type). If the absolute value of the right operand (&lt;code&gt;abs($n)&lt;/code&gt;) is greater than or equal to &lt;code&gt;(UV_MAX + 1)&lt;/code&gt;, &lt;code&gt;&quot;%&quot;&lt;/code&gt; computes the floating-point remainder &lt;code&gt;$r&lt;/code&gt; in the equation &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; where &lt;code&gt;$i&lt;/code&gt; is a certain integer that makes &lt;code&gt;$r&lt;/code&gt; have the same sign as the right operand &lt;code&gt;$n&lt;/code&gt; (&lt;b&gt;not&lt;/b&gt; as the left operand &lt;code&gt;$m&lt;/code&gt; like C function &lt;code&gt;fmod()&lt;/code&gt;) and the absolute value less than that of &lt;code&gt;$n&lt;/code&gt;. Note that when &lt;code&gt;use integer&lt;/code&gt; is in scope, &lt;code&gt;&quot;%&quot;&lt;/code&gt; gives you direct access to the modulo operator as implemented by your C compiler. This operator is not as well defined for negative operands, but it will execute faster.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;%&quot;&lt;/code&gt; はモジュロ演算子であり、2番目の引数に対する最初の引数の除算剰余を計算します。整数オペランド所与 &lt;code&gt;$m&lt;/code&gt; および &lt;code&gt;$n&lt;/code&gt; ：場合 &lt;code&gt;$n&lt;/code&gt; 正である場合、 &lt;code&gt;$m % $n&lt;/code&gt; であり、 &lt;code&gt;$m&lt;/code&gt; マイナスの最大複数 &lt;code&gt;$n&lt;/code&gt; より小さいか等しい &lt;code&gt;$m&lt;/code&gt; 。場合 &lt;code&gt;$n&lt;/code&gt; 負で、その後で &lt;code&gt;$m % $n&lt;/code&gt; で &lt;code&gt;$m&lt;/code&gt; マイナスの最小複数 &lt;code&gt;$n&lt;/code&gt; 未満でない &lt;code&gt;$m&lt;/code&gt; （すなわち、結果未満またはゼロに等しいであろう）。オペランド &lt;code&gt;$m&lt;/code&gt; および &lt;code&gt;$n&lt;/code&gt; は浮動小数点値であり、 &lt;code&gt;$n&lt;/code&gt; 絶対値（つまり &lt;code&gt;abs($n)&lt;/code&gt; ）は &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; 未満であり、操作では &lt;code&gt;$m&lt;/code&gt; と &lt;code&gt;$n&lt;/code&gt; 整数部分のみが使用されます（注：ここでは &lt;code&gt;UV_MAX&lt;/code&gt; 符号なし整数型の最大値を意味します）。右オペランドの絶対値（ &lt;code&gt;abs($n)&lt;/code&gt; ）が &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; 以上の場合、 &lt;code&gt;&quot;%&quot;&lt;/code&gt; は式 &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; の浮動小数点剰余 &lt;code&gt;$r&lt;/code&gt; を計算します。* $ n）ここで、 &lt;code&gt;$i&lt;/code&gt; は、 &lt;code&gt;$r&lt;/code&gt; が右のオペランドと同じ符号を持つようにする特定の整数です。 &lt;code&gt;$n&lt;/code&gt; （C関数 &lt;code&gt;fmod()&lt;/code&gt; のような左オペランド &lt;code&gt;$m&lt;/code&gt; としてでは&lt;b&gt;なく&lt;/b&gt;）および &lt;code&gt;$n&lt;/code&gt; 絶対値よりも小さい絶対値。 &lt;code&gt;use integer&lt;/code&gt; がスコープ内にある場合、 &lt;code&gt;&quot;%&quot;&lt;/code&gt; を使用すると、Cコンパイラーによって実装されたモジュロ演算子に直接アクセスできることに注意してください。この演算子は、負のオペランドに対してはあまり定義されていませんが、実行速度は速くなります。</target>
        </trans-unit>
        <trans-unit id="a8a326cd0bd8e1d3d414fab02e5019eeeb66d4b5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; returns its operands ANDed together bit by bit. Although no warning is currently raised, the result is not well defined when this operation is performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot;&lt;/a&gt;).</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; は、オペランドをビットごとにAND演算して返します。現在警告は出されていませんが、数値（&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;「整数演算」を&lt;/a&gt;参照）でも&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;ビット文字列&lt;/a&gt;（「ビット単位の文字列演算子」を参照）でもないオペランドでこの演算を実行すると、結果は明確に定義されません。</target>
        </trans-unit>
        <trans-unit id="68ed9e30d3d6543dd0a9f75b291cbc79357b65a9" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; returns its operands ANDed together bit by bit. Although no warning is currently raised, the result is not well defined when this operation is performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;).</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; は、ビットごとにAND演算されたオペランドを返します。現在警告は出されていませんが、数値（&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;整数演算を&lt;/a&gt;参照）または&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;ビット文字列&lt;/a&gt;（ビットごとの文字列演算子を参照）ではないオペランドに対してこの演算を実行すると、結果は明確に定義されません。</target>
        </trans-unit>
        <trans-unit id="c0937405123294a033856c6fea7344af89470f86" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt; performs a short-circuit logical AND operation. That is, if the left operand is false, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt; は、短絡論理AND演算を実行します。つまり、左のオペランドがfalseの場合、右のオペランドは評価されません。スカラーまたはリストコンテキストは、評価された場合、右側のオペランドまで伝播します。</target>
        </trans-unit>
        <trans-unit id="1f3f00bc4d3f1107e73b1aeb90803d21d2f7f5a5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; returns true if the left argument is numerically greater than the right argument.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; は、左側の引数が右側の引数よりも数値的に大きい場合にtrueを返します。</target>
        </trans-unit>
        <trans-unit id="7b8b841de5eb99d0ccb88b329de6ee433524b771" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; returns the value of its left argument shifted right by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;.)</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; は、右の引数で指定されたビット数だけ右にシフトされた左の引数の値を返します。引数は整数である必要があります。（&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;「整数演算」&lt;/a&gt;も参照してください。）</target>
        </trans-unit>
        <trans-unit id="6a8e5f64ce960724d668657e4a1ad5261d933577" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; returns the value of its left argument shifted right by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;.)</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; は、右の引数で指定されたビット数だけ右にシフトされた左の引数の値を返します。引数は整数でなければなりません。（&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;整数演算&lt;/a&gt;も参照してください。）</target>
        </trans-unit>
        <trans-unit id="9de554883aaffe5a62d4c8a36deea3a837fcd80d" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; returns true if the left argument is numerically greater than or equal to the right argument.</source>
          <target state="translated">左側の引数が数値的に右側の引数以上の場合、バイナリ &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="a7454742c96c82ff2ca0ce93cf67bcd19286a557" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; returns true if the left argument is numerically less than the right argument.</source>
          <target state="translated">左側の引数が右側の引数よりも数値的に小さい場合、バイナリ &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="699e70a5fa87498319583ad7600759912b343d42" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; returns the value of its left argument shifted left by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;.)</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; は、右の引数で指定されたビット数だけ左にシフトされた左の引数の値を返します。引数は整数である必要があります。 （&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;「整数演算」&lt;/a&gt;も参照してください。）</target>
        </trans-unit>
        <trans-unit id="e6d03b55098c5e945a6cff21988ea84460d71573" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; returns the value of its left argument shifted left by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;.)</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; は、右の引数で指定されたビット数だけ左にシフトされた左の引数の値を返します。引数は整数でなければなりません。（&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;整数演算&lt;/a&gt;も参照してください。）</target>
        </trans-unit>
        <trans-unit id="b5e75cae74350bd47fe89e9c43a86148805f25b1" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; returns true if the left argument is numerically less than or equal to the right argument.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; は、左側の引数が数値的に右側の引数以下の場合にtrueを返します。</target>
        </trans-unit>
        <trans-unit id="c4b96fdd4c2b42fee6d143e7f60bc5e53b9a1f53" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is numerically less than, equal to, or greater than the right argument. If your platform supports &lt;code&gt;NaN&lt;/code&gt; 's (not-a-numbers) as numeric values, using them with &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns undef. &lt;code&gt;NaN&lt;/code&gt; is not &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;==&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; or &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; anything (even &lt;code&gt;NaN&lt;/code&gt; ), so those 5 return false. &lt;code&gt;NaN != NaN&lt;/code&gt; returns true, as does &lt;code&gt;NaN !=&lt;/code&gt;</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; は、左側の引数が数値的に右側の引数より小さいか、等しいか、大きいかによって、-1、0、または1を返します。プラットフォームが数値として &lt;code&gt;NaN&lt;/code&gt; （非数）をサポートしている場合、それらを &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; で使用するとundefが返されます。 &lt;code&gt;NaN&lt;/code&gt; は &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;==&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; または &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; のいずれでもない（ &lt;code&gt;NaN&lt;/code&gt; も含む）ため、これら5はfalseを返します。 &lt;code&gt;NaN != NaN&lt;/code&gt; 同様に、NaNはtrueを返します &lt;code&gt;NaN !=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac04a45698769168d1350bede297cc638685f279" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is numerically less than, equal to, or greater than the right argument. If your platform supports &lt;code&gt;NaN&lt;/code&gt;'s (not-a-numbers) as numeric values, using them with &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns undef. &lt;code&gt;NaN&lt;/code&gt; is not &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt;, &lt;code&gt;&quot;==&quot;&lt;/code&gt;, &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt;, &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; or &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; anything (even &lt;code&gt;NaN&lt;/code&gt;), so those 5 return false. &lt;code&gt;NaN != NaN&lt;/code&gt; returns true, as does &lt;code&gt;NaN !=&lt;/code&gt;</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; は、左の引数が右の引数よりも数値的に小さいか、等しいか、大きいかに応じて、-1、0、または1を返します。プラットフォームが &lt;code&gt;NaN&lt;/code&gt; （数値ではない）を数値としてサポートしている場合、それらを &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; とともに使用するとundefが返されます。 &lt;code&gt;NaN&lt;/code&gt; は &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;==&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; または &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; ではないので（ &lt;code&gt;NaN&lt;/code&gt; であっても）、これら5つはfalseを返します。 &lt;code&gt;NaN != NaN&lt;/code&gt; 同様に、NaNはtrueを返します &lt;code&gt;NaN !=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d0148c51849abf03e9b94e765faa605e272cbf6" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;*&quot;&lt;/code&gt; multiplies two numbers.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;*&quot;&lt;/code&gt; は2つの数値を乗算します。</target>
        </trans-unit>
        <trans-unit id="01756f918936276dfa8f0de39e3d878d679ba39b" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;**&quot;&lt;/code&gt; is the exponentiation operator. It binds even more tightly than unary minus, so &lt;code&gt;-2**4&lt;/code&gt; is &lt;code&gt;-(2**4)&lt;/code&gt; , not &lt;code&gt;(-2)**4&lt;/code&gt; . (This is implemented using C's &lt;code&gt;pow(3)&lt;/code&gt; function, which actually works on doubles internally.)</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;**&quot;&lt;/code&gt; は指数演算子です。単項マイナスよりも強く結合するため、 &lt;code&gt;-2**4&lt;/code&gt; は &lt;code&gt;-(2**4)&lt;/code&gt; であり、 &lt;code&gt;(-2)**4&lt;/code&gt; ではありません。（これは、Cの &lt;code&gt;pow(3)&lt;/code&gt; 関数を使用して実装されており、これは実際には内部でdoubleに対して機能します。）</target>
        </trans-unit>
        <trans-unit id="ea1f5488b58109753bdbb42f40a1d426d3469962" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;**&quot;&lt;/code&gt; is the exponentiation operator. It binds even more tightly than unary minus, so &lt;code&gt;-2**4&lt;/code&gt; is &lt;code&gt;-(2**4)&lt;/code&gt;, not &lt;code&gt;(-2)**4&lt;/code&gt;. (This is implemented using C's &lt;code&gt;pow(3)&lt;/code&gt; function, which actually works on doubles internally.)</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;**&quot;&lt;/code&gt; はべき乗演算子です。単項マイナスよりもさらに緊密に結合するため、 &lt;code&gt;-2**4&lt;/code&gt; は &lt;code&gt;-(2**4)&lt;/code&gt; であり、 &lt;code&gt;(-2)**4&lt;/code&gt; ではありません。 （これは、実際には内部でdoubleで機能するCの &lt;code&gt;pow(3)&lt;/code&gt; 関数を使用して実装されます。）</target>
        </trans-unit>
        <trans-unit id="e565dc6efc9becadb2f620e3b56356ece28d9ea9" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;+&quot;&lt;/code&gt; returns the sum of two numbers.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;+&quot;&lt;/code&gt; は、2つの数値の合計を返します。</target>
        </trans-unit>
        <trans-unit id="d264c2219fd49edff5b7c850ac6db5ce0ccf6345" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;,&quot;&lt;/code&gt; is the comma operator. In scalar context it evaluates its left argument, throws that value away, then evaluates its right argument and returns that value. This is just like C's comma operator.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;,&quot;&lt;/code&gt; はコンマ演算子です。スカラーコンテキストでは、左側の引数を評価し、その値を破棄してから、右側の引数を評価してその値を返します。これは、Cのコンマ演算子と同じです。</target>
        </trans-unit>
        <trans-unit id="afc59f330a0626c101e37690bb504039ec265210" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;-&quot;&lt;/code&gt; returns the difference of two numbers.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;-&quot;&lt;/code&gt; は、2つの数値の差を返します。</target>
        </trans-unit>
        <trans-unit id="843c8445f5431d5cdfeffedb703a08e101bb0fa7" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;.&quot;&lt;/code&gt; concatenates two strings.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;.&quot;&lt;/code&gt; 2つの文字列を連結します。</target>
        </trans-unit>
        <trans-unit id="20b0ad876d72e0a4e92413d3b855b37c16cdc3ee" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;..&quot;&lt;/code&gt; is the range operator, which is really two different operators depending on the context. In list context, it returns a list of values counting (up by ones) from the left value to the right value. If the left value is greater than the right value then it returns the empty list. The range operator is useful for writing &lt;code&gt;foreach (1..10)&lt;/code&gt; loops and for doing slice operations on arrays. In the current implementation, no temporary array is created when the range operator is used as the expression in &lt;code&gt;foreach&lt;/code&gt; loops, but older versions of Perl might burn a lot of memory when you write something like this:</source>
          <target state="translated">二項 &lt;code&gt;&quot;..&quot;&lt;/code&gt; は範囲演算子であり、実際にはコンテキストに応じて2つの異なる演算子です。リストコンテキストでは、左の値から右の値まで（1ずつ）カウントする値のリストを返します。左の値が右の値より大きい場合、空のリストを返します。範囲演算子は、 &lt;code&gt;foreach (1..10)&lt;/code&gt; ループを記述したり、配列に対してスライス操作を実行したりするのに役立ちます。現在の実装では、範囲演算子が &lt;code&gt;foreach&lt;/code&gt; ループの式として使用されている場合、一時的な配列は作成されませんが、古いバージョンのPerlは、次のようなものを書き込むと大量のメモリを消費する可能性があります。</target>
        </trans-unit>
        <trans-unit id="11d1e4ec8e23351f5601e3a5d4e0c431e5c430e4" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;/&quot;&lt;/code&gt; divides two numbers.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;/&quot;&lt;/code&gt; は2つの数値を除算します。</target>
        </trans-unit>
        <trans-unit id="f0b12adb8c84721a8d6934894abc35e4121a8c82" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;==&quot;&lt;/code&gt; returns true if the left argument is numerically equal to the right argument.</source>
          <target state="translated">左側の引数が数値的に右側の引数と等しい場合、バイナリ &lt;code&gt;&quot;==&quot;&lt;/code&gt; はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="e8178e90952cecccc1b319f7d1d8a9d3454e685e" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;=~&quot;&lt;/code&gt; binds a scalar expression to a pattern match. Certain operations search or modify the string &lt;code&gt;$_&lt;/code&gt; by default. This operator makes that kind of operation work on some other string. The right argument is a search pattern, substitution, or transliteration. The left argument is what is supposed to be searched, substituted, or transliterated instead of the default &lt;code&gt;$_&lt;/code&gt; . When used in scalar context, the return value generally indicates the success of the operation. The exceptions are substitution (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;) and transliteration (&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) with the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option, which cause the &lt;b&gt;r&lt;/b&gt;eturn value to be the result of the substitution. Behavior in list context depends on the particular operator. See &lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators&lt;/a&gt; for details and &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; for examples using these operators.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;=~&quot;&lt;/code&gt; は、スカラー式をパターン一致にバインドします。特定の操作では、デフォルトで文字列 &lt;code&gt;$_&lt;/code&gt; 検索または変更します。この演算子は、その種の操作を他の文字列に対して機能させます。正しい引数は、検索パターン、置換、または音訳です。左の引数は、デフォルトの &lt;code&gt;$_&lt;/code&gt; ではなく、検索、置換、または音訳されることになっています。スカラーコンテキストで使用する場合、戻り値は通常、操作の成功を示します。例外は、 &lt;code&gt;/r&lt;/code&gt; （非破壊）オプションを使用した置換（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; ）と音訳（ &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; ）です。これにより、&lt;b&gt;r&lt;/b&gt;&lt;b&gt;&lt;/b&gt;置換の結果となる戻り値。リストコンテキストでの動作は、特定の演算子によって異なります。詳細については&lt;a href=&quot;perlretut&quot;&gt;正規表現の&lt;/a&gt;&lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;見積もりの​​ような演算子&lt;/a&gt;を、これらの演算子の使用例についてはperlretutを参照してください。</target>
        </trans-unit>
        <trans-unit id="79a4495643878d498724e64ed7f89a0f4674d534" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;=~&quot;&lt;/code&gt; binds a scalar expression to a pattern match. Certain operations search or modify the string &lt;code&gt;$_&lt;/code&gt; by default. This operator makes that kind of operation work on some other string. The right argument is a search pattern, substitution, or transliteration. The left argument is what is supposed to be searched, substituted, or transliterated instead of the default &lt;code&gt;$_&lt;/code&gt;. When used in scalar context, the return value generally indicates the success of the operation. The exceptions are substitution (&lt;code&gt;s///&lt;/code&gt;) and transliteration (&lt;code&gt;y///&lt;/code&gt;) with the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option, which cause the &lt;b&gt;r&lt;/b&gt;eturn value to be the result of the substitution. Behavior in list context depends on the particular operator. See &lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot;&lt;/a&gt; for details and &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; for examples using these operators.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;=~&quot;&lt;/code&gt; は、スカラー式をパターンマッチにバインドします。特定の操作は、デフォルトで文字列 &lt;code&gt;$_&lt;/code&gt; 検索または変更します。この演算子は、その種の操作を他の文字列で機能させます。正しい引数は、検索パターン、置換、または音訳です。左の引数は、デフォルトの &lt;code&gt;$_&lt;/code&gt; 代わりに、検索、置換、または音訳されることになっているものです。スカラーコンテキストで使用される場合、戻り値は通常、操作の成功を示します。例外は、 &lt;code&gt;/r&lt;/code&gt; （非破壊）オプションによる置換（ &lt;code&gt;s///&lt;/code&gt; ）と音訳（ &lt;code&gt;y///&lt;/code&gt; ）であり、&lt;b&gt;r&lt;/b&gt;が発生します。&lt;b&gt;&lt;/b&gt;置換の結果であるeturn値。リストコンテキストでの動作は、特定の演算子によって異なります。詳細については&lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;「&lt;/a&gt;&lt;a href=&quot;perlretut&quot;&gt;RegexpQuote &lt;/a&gt;- LikeOperators 」を、これらの演算子を使用した例についてはperlretutを参照してください。</target>
        </trans-unit>
        <trans-unit id="aa78120f553c43180d2a32604d493af25ed233d4" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;^&quot;&lt;/code&gt; returns its operands XORed together bit by bit.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;^&quot;&lt;/code&gt; は、ビットごとにXORされたオペランドを返します。</target>
        </trans-unit>
        <trans-unit id="671e2c4625e970e48a9399520aaa4fa28b907022" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;and&quot;&lt;/code&gt; returns the logical conjunction of the two surrounding expressions. It's equivalent to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; except for the very low precedence. This means that it short-circuits: the right expression is evaluated only if the left expression is true.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;and&quot;&lt;/code&gt; は、2つの周囲の式の論理結合を返します。優先度が非常に低いことを除いて、 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; と同等です。これは、短絡することを意味します。右の式は、左の式が真の場合にのみ評価されます。</target>
        </trans-unit>
        <trans-unit id="d3c04971ab5e03274c19bebb1ecd8b4175eeef29" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;cmp&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is stringwise less than, equal to, or greater than the right argument.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;cmp&quot;&lt;/code&gt; は、左の引数が文字列ごとに右の引数よりも小さいか、等しいか、大きいかによって、-1、0、または1を返します。</target>
        </trans-unit>
        <trans-unit id="1aa12faad44cec6a4de324dfb2d0d28e5041c165" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;eq&quot;&lt;/code&gt; returns true if the left argument is stringwise equal to the right argument.</source>
          <target state="translated">バイナリの &lt;code&gt;&quot;eq&quot;&lt;/code&gt; は、左側の引数が文字列ごとに右側の引数と等しい場合にtrueを返します。</target>
        </trans-unit>
        <trans-unit id="72766e64c0f2ce882d1581bc9a5363e487361650" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;ge&quot;&lt;/code&gt; returns true if the left argument is stringwise greater than or equal to the right argument.</source>
          <target state="translated">バイナリの &lt;code&gt;&quot;ge&quot;&lt;/code&gt; は、左側の引数が文字列ごとに右側の引数以上である場合にtrueを返します。</target>
        </trans-unit>
        <trans-unit id="8cbbb7f7848eee7ea44e5adae43d5c8ad553b087" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;gt&quot;&lt;/code&gt; returns true if the left argument is stringwise greater than the right argument.</source>
          <target state="translated">バイナリの &lt;code&gt;&quot;gt&quot;&lt;/code&gt; は、左の引数が文字列ごとに右の引数より大きい場合にtrueを返します。</target>
        </trans-unit>
        <trans-unit id="cbde6b024ab1e652daab583508091dcc611a1886" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;le&quot;&lt;/code&gt; returns true if the left argument is stringwise less than or equal to the right argument.</source>
          <target state="translated">バイナリの &lt;code&gt;&quot;le&quot;&lt;/code&gt; は、左の引数が文字列ごとに右の引数以下である場合にtrueを返します。</target>
        </trans-unit>
        <trans-unit id="98038977bb137332bb318c163315bf5cd770bdda" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;lt&quot;&lt;/code&gt; returns true if the left argument is stringwise less than the right argument.</source>
          <target state="translated">左側の引数が文字列ごとに右側の引数よりも小さい場合、バイナリ &lt;code&gt;&quot;lt&quot;&lt;/code&gt; はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="3426ef0b6b1032306f9e34d92f3217cb3cb8f9b5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;ne&quot;&lt;/code&gt; returns true if the left argument is stringwise not equal to the right argument.</source>
          <target state="translated">バイナリの &lt;code&gt;&quot;ne&quot;&lt;/code&gt; は、左の引数が文字列ごとに右の引数と等しくない場合にtrueを返します。</target>
        </trans-unit>
        <trans-unit id="6e48afc6b41691d3b8112c62d6f3d75de7761a17" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;or&quot;&lt;/code&gt; returns the logical disjunction of the two surrounding expressions. It's equivalent to &lt;code&gt;||&lt;/code&gt; except for the very low precedence. This makes it useful for control flow:</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;or&quot;&lt;/code&gt; は、2つの周囲の式の論理和を返します。 &lt;code&gt;||&lt;/code&gt; と同等です 優先度が非常に低い場合を除きます。これにより、制御フローに役立ちます。</target>
        </trans-unit>
        <trans-unit id="6eadcc721bf945b4975372194a62fd2f4732fb22" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;x&quot;&lt;/code&gt; is the repetition operator. In scalar context or if the left operand is not enclosed in parentheses, it returns a string consisting of the left operand repeated the number of times specified by the right operand. In list context, if the left operand is enclosed in parentheses or is a list formed by &lt;code&gt;qw/&lt;i&gt;STRING&lt;/i&gt;/&lt;/code&gt;, it repeats the list. If the right operand is zero or negative (raising a warning on negative), it returns an empty string or an empty list, depending on the context.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;x&quot;&lt;/code&gt; は繰り返し演算子です。スカラーコンテキストで、または左のオペランドが括弧で囲まれていない場合、右のオペランドで指定された回数だけ繰り返された左のオペランドで構成される文字列を返します。リストのコンテキストでは、左のオペランドが括弧で囲まれているか、 &lt;code&gt;qw/&lt;i&gt;STRING&lt;/i&gt;/&lt;/code&gt; によって形成されたリストである場合、リストを繰り返します。右のオペランドがゼロまたは負の場合（負の場合に警告を出す）、コンテキストに応じて空の文字列または空のリストを返します。</target>
        </trans-unit>
        <trans-unit id="9999af54fad183fd5d0cedce55d894dad6f9d4fe" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;xor&quot;&lt;/code&gt; returns the exclusive-OR of the two surrounding expressions. It cannot short-circuit (of course).</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;xor&quot;&lt;/code&gt; は、2つの周囲の式の排他的論理和を返します。（もちろん）短絡することはできません。</target>
        </trans-unit>
        <trans-unit id="878a38ea354402b8caaeaced244837f05ba0dd57" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;|&quot;&lt;/code&gt; returns its operands ORed together bit by bit.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;|&quot;&lt;/code&gt; オペランドをビットごとにORで返します。</target>
        </trans-unit>
        <trans-unit id="b1489d43a3216d7ad2c82c2a95acd60755df1162" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;||&quot;&lt;/code&gt; performs a short-circuit logical OR operation. That is, if the left operand is true, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;||&quot;&lt;/code&gt; 短絡論理OR演算を実行します。つまり、左のオペランドが真の場合、右のオペランドは評価されません。スカラーまたはリストコンテキストは、評価された場合、右側のオペランドまで伝播します。</target>
        </trans-unit>
        <trans-unit id="f92bb398898c648f24279f387f99c6d49704c347" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;~~&quot;&lt;/code&gt; does a smartmatch between its arguments. Smart matching is described in the next section.</source>
          <target state="translated">バイナリ &lt;code&gt;&quot;~~&quot;&lt;/code&gt; は、引数間でスマートマッチを実行します。スマートマッチングについては、次のセクションで説明します。</target>
        </trans-unit>
        <trans-unit id="474b37cbe0d6e0c72ec20c7e955273bab42d36ef" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;isa&lt;/code&gt; evaluates to true when the left argument is an object instance of the class (or a subclass derived from that class) given by the right argument. If the left argument is not defined, not a blessed object instance, nor does not derive from the class given by the right argument, the operator evaluates as false. The right argument may give the class either as a bareword or a scalar expression that yields a string class name:</source>
          <target state="translated">左の引数が右の引数によって与えられたクラス（またはそのクラスから派生したサブクラス）のオブジェクトインスタンスである場合、バイナリ &lt;code&gt;isa&lt;/code&gt; はtrueと評価されます。左側の引数が定義されていない場合、祝福されたオブジェクトインスタンスではない場合、または右側の引数で指定されたクラスから派生していない場合、演算子はfalseと評価されます。正しい引数は、文字列クラス名を生成するベアワードまたはスカラー式としてクラスを与えることができます。</target>
        </trans-unit>
        <trans-unit id="47cc7ad1e48a139eed3a38cd085aae1011cbc98f" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;x&lt;/code&gt; is the repetition operator. In scalar context, or if the left operand is neither enclosed in parentheses nor a &lt;code&gt;qw//&lt;/code&gt; list, it performs a string repetition. In that case it supplies scalar context to the left operand, and returns a string consisting of the left operand string repeated the number of times specified by the right operand. If the &lt;code&gt;x&lt;/code&gt; is in list context, and the left operand is either enclosed in parentheses or a &lt;code&gt;qw//&lt;/code&gt; list, it performs a list repetition. In that case it supplies list context to the left operand, and returns a list consisting of the left operand list repeated the number of times specified by the right operand. If the right operand is zero or negative (raising a warning on negative), it returns an empty string or an empty list, depending on the context.</source>
          <target state="translated">バイナリ &lt;code&gt;x&lt;/code&gt; は繰り返し演算子です。スカラーコンテキストでは、または左側のオペランドが括弧でも &lt;code&gt;qw//&lt;/code&gt; リストでも囲まれていない場合は、文字列の繰り返しを実行します。その場合、左オペランドにスカラーコンテキストを提供し、右オペランドで指定された回数繰り返された左オペランド文字列で構成される文字列を返します。場合 &lt;code&gt;x&lt;/code&gt; はリストコンテキストであり、そして左のオペランドはどちらかの括弧やで囲まれている &lt;code&gt;qw//&lt;/code&gt; リスト、それはリストの繰り返しを実行します。その場合、左のオペランドにリストコンテキストを提供し、右のオペランドで指定された回数繰り返された左のオペランドリストで構成されるリストを返します。右のオペランドがゼロまたは負の場合（負の場合に警告が発生する）、コンテキストに応じて、空の文字列または空のリストが返されます。</target>
        </trans-unit>
        <trans-unit id="39d7bf96b3a657465e5f87b07b34fa4dafeb1ef4" translate="yes" xml:space="preserve">
          <source>Binary backward compatibility; this function is a macro but also has a &lt;code&gt;Perl_&lt;/code&gt; implementation (which is exported).</source>
          <target state="translated">バイナリ下位互換性。この関数はマクロですが、 &lt;code&gt;Perl_&lt;/code&gt; 実装（エクスポートされている）も持っています。</target>
        </trans-unit>
        <trans-unit id="be16b35ee218fa359867cb0e97728996cffd42bc" translate="yes" xml:space="preserve">
          <source>Binary distributions for some proprietary platforms can be found &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt; directory. Because these are not part of the standard distribution, they may and in fact do differ from the base perl port in a variety of ways. You'll have to check their respective release notes to see just what the differences are. These differences can be either positive (e.g. extensions for the features of the particular platform that are not supported in the source release of perl) or negative (e.g. might be based upon a less current source release of perl).</source>
          <target state="translated">一部のプロプライエタリプラットフォーム用のバイナリディストリビューションは、&lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http：//www.cpan.org/ports/&lt;/a&gt;ディレクトリにあります。これらは標準ディストリビューションの一部ではないため、さまざまな点でベースperlポートと異なる場合があります。それぞれのリリースノートを確認して、違いを確認する必要があります。これらの違いは、ポジティブ（たとえば、特定のプラットフォームの機能の拡張で、perlのソースリリースでサポートされていない）またはネガティブ（たとえば、現在のソースリリースが少ないperlに基づいている）のどちらかです。</target>
        </trans-unit>
        <trans-unit id="55fd3c0a11bb58bb23e20465875244f2ca59b441" translate="yes" xml:space="preserve">
          <source>Binary installer also creates a folder on your desktop with some useful objects. If you need to change some aspects of the work of the binary installer, feel free to edit the file</source>
          <target state="translated">バイナリインストーラはまた、デスクトップ上にいくつかの便利なオブジェクトを持つフォルダを作成します。バイナリインストーラの動作の一部を変更する必要がある場合は、ファイル</target>
        </trans-unit>
        <trans-unit id="b3b1f88d8a58f93a423339c57b3f74f2d820a432" translate="yes" xml:space="preserve">
          <source>Binary number &amp;gt; 0b11111111111111111111111111111111 non-portable</source>
          <target state="translated">2進数&amp;gt; 0b11111111111111111111111111111111ポータブルではありません</target>
        </trans-unit>
        <trans-unit id="a1c1ba08fb761b34a695ec927e7b1037b80a83ca" translate="yes" xml:space="preserve">
          <source>Binary strings (byte strings)</source>
          <target state="translated">バイナリ文字列(バイト文字列</target>
        </trans-unit>
        <trans-unit id="9a138af365fa894e34cab06b679f370e8157841c" translate="yes" xml:space="preserve">
          <source>Binding Operators</source>
          <target state="translated">バインディングオペレータ</target>
        </trans-unit>
        <trans-unit id="73bb8553f0429ab1a4f3db6aa26eab8529fc1962" translate="yes" xml:space="preserve">
          <source>Binding together several statements in a macro</source>
          <target state="translated">マクロ内の複数のステートメントを結合する</target>
        </trans-unit>
        <trans-unit id="be19add4d0d70fd9e2b19a5940d1ed397561b92a" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as &lt;a href=&quot;http://man.he.net/man2/bind&quot;&gt;bind(2)&lt;/a&gt; does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;&quot;Sockets: Client/Server Communication&quot; in perlipc&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://man.he.net/man2/bind&quot;&gt;bind（2）と&lt;/a&gt;同様に、ネットワークアドレスをソケットにバインドします。成功した場合はtrueを返し、それ以外の場合はfalseを返します。NAMEは、ソケットに適切なタイプのパックされたアドレスである必要があります。&lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;perlipcの「ソケット：クライアント/サーバー通信」&lt;/a&gt;の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="5ee51bd7870301b5b50c94bd801894ab927735dc" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as &lt;code&gt;bind(2)&lt;/code&gt; does. Returns true if it succeeded, false otherwise. You should provide a packed address of the appropriate type for the socket.</source>
          <target state="translated">&lt;code&gt;bind(2)&lt;/code&gt; と同様に、ネットワークアドレスをソケットにバインドします。成功した場合はtrueを返し、それ以外の場合はfalseを返します。ソケットに適切なタイプのパックされたアドレスを提供する必要があります。</target>
        </trans-unit>
        <trans-unit id="5549ae8d615ef700c81551ae6af123d2f95aacb7" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as bind(2) does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">bind（2）と同じように、ネットワークアドレスをソケットにバインドします。成功した場合はtrue、それ以外の場合はfalseを返します。NAMEは、ソケットに適したタイプのパックアドレスでなければなりません。「&lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;ソケット：perlipcのクライアント/サーバー通信&lt;/a&gt;」の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="9fa331f367a4577bd9809395dd5e94974930bded" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as bind(2) does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">bind（2）と同じように、ネットワークアドレスをソケットにバインドします。成功した場合はtrue、それ以外の場合はfalseを返します。NAMEは、ソケットに適したタイプのパックアドレスでなければなりません。「&lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;ソケット：perlipcのクライアント/サーバー通信&lt;/a&gt;」の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="1d4a984a59802112ea9e0afc9140f13f4e5333e8" translate="yes" xml:space="preserve">
          <source>Binmode</source>
          <target state="translated">Binmode</target>
        </trans-unit>
        <trans-unit id="6974d8c4576a73016b6ecc19f5a2ebc538fab746" translate="yes" xml:space="preserve">
          <source>Birrell, Andrew D. An Introduction to Programming with Threads. Digital Equipment Corporation, 1989, DEC-SRC Research Report #35 online as &lt;a href=&quot;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&quot;&gt;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&lt;/a&gt; (highly recommended)</source>
          <target state="translated">Birrell、Andrew D.スレッドによるプログラミングの紹介。Digital Equipment Corporation、1989、DEC-SRC Research Report＃35 online as &lt;a href=&quot;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&quot;&gt;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&lt;/a&gt;（強く推奨）</target>
        </trans-unit>
        <trans-unit id="36b5cf92c2fb97a05ef7bf770fab59d48c1cb050" translate="yes" xml:space="preserve">
          <source>Birrell, Andrew D. An Introduction to Programming with Threads. Digital Equipment Corporation, 1989, DEC-SRC Research Report #35 online as &lt;a href=&quot;https://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-35.pdf&quot;&gt;https://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-35.pdf&lt;/a&gt; (highly recommended)</source>
          <target state="translated">Birrell、AndrewD。スレッドを使用したプログラミング入門。Digital Equipment Corporation、1989年、DEC-SRC Research Report＃35オンライン&lt;a href=&quot;https://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-35.pdf&quot;&gt;https://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-35.pdf&lt;/a&gt;（強く推奨）</target>
        </trans-unit>
        <trans-unit id="a110cc2137a88f53fa983eabf18c6a369cdd6cc9" translate="yes" xml:space="preserve">
          <source>Bisecting</source>
          <target state="translated">Bisecting</target>
        </trans-unit>
        <trans-unit id="f6106638b60c4b72e8832174afe58ef2d3da9922" translate="yes" xml:space="preserve">
          <source>Bit Complement Operator ~ And vec()</source>
          <target state="translated">ビット補数演算子 ~ そして vec()</target>
        </trans-unit>
        <trans-unit id="c5e74747e30dab25d0878fbe61b78c61e44df4c0" translate="yes" xml:space="preserve">
          <source>Bit Strings</source>
          <target state="translated">ビット文字列</target>
        </trans-unit>
        <trans-unit id="ba34e7ebde4a9f60d96348693e30b97a898d1671" translate="yes" xml:space="preserve">
          <source>Bit vector size &amp;gt; 32 non-portable</source>
          <target state="translated">ビットベクトルサイズ&amp;gt; 32非ポータブル</target>
        </trans-unit>
        <trans-unit id="833619884d42232d65498c141d5b13c648753213" translate="yes" xml:space="preserve">
          <source>Bits are the atoms in the memory world. Access to individual bits may have to be used either as a last resort or because it is the most convenient way to handle your data. Bit string (un)packing converts between strings containing a series of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; characters and a sequence of bytes each containing a group of 8 bits. This is almost as simple as it sounds, except that there are two ways the contents of a byte may be written as a bit string. Let's have a look at an annotated byte:</source>
          <target state="translated">ビットはメモリの世界のアトムです。個々のビットへのアクセスは、最後の手段として、またはデータを処理するための最も便利な方法であるため、使用する必要がある場合があります。ビット文字列（非）パッキングは、一連の &lt;code&gt;0&lt;/code&gt; と &lt;code&gt;1&lt;/code&gt; の文字を含む文字列と、それぞれが8ビットのグループを含むバイトのシーケンスの間で変換します。これは、バイトの内容をビット文字列として書き込む方法が2つあることを除いて、見た目と同じくらい簡単です。注釈付きバイトを見てみましょう：</target>
        </trans-unit>
        <trans-unit id="8d8367155a1b407dd5a8766f2b3e58679136cc71" translate="yes" xml:space="preserve">
          <source>Bits that the &lt;b&gt;owner&lt;/b&gt; of a file sets or unsets to allow or disallow access to other people. These flag bits are part of the &lt;b&gt;mode&lt;/b&gt; word returned by the &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; built-in when you ask about a file. On Unix systems, you can check the</source>
          <target state="translated">ファイルの&lt;b&gt;所有者&lt;/b&gt;が他の人へのアクセスを許可または禁止するために設定または設定解除するビット。これらのフラグビットは、ファイルについて尋ねたときに組み込みの &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; によって返される&lt;b&gt;モード&lt;/b&gt;ワードの一部です。Unixシステムでは、</target>
        </trans-unit>
        <trans-unit id="aca05ef0109989b493ae0975df5c4747401f63d8" translate="yes" xml:space="preserve">
          <source>Bits that the &lt;b&gt;owner&lt;/b&gt; of a file sets or unsets to allow or disallow access to other people. These flag bits are part of the &lt;b&gt;mode&lt;/b&gt; word returned by the &lt;code&gt;stat&lt;/code&gt; built-in when you ask about a file. On Unix systems, you can check the</source>
          <target state="translated">ファイルの&lt;b&gt;所有者&lt;/b&gt;が他の人へのアクセスを許可または禁止するために設定または設定解除するビット。これらのフラグビットは、ファイルについて質問したときに組み込みの &lt;code&gt;stat&lt;/code&gt; によって返される&lt;b&gt;モード&lt;/b&gt;ワードの一部です。Unixシステムでは、次のことを確認できます。</target>
        </trans-unit>
        <trans-unit id="9166fa867213d69681d8dc9ba4c66e0e28bd7ae5" translate="yes" xml:space="preserve">
          <source>Bitstrings of any size may be manipulated by the bitwise operators (&lt;code&gt;~ | &amp;amp; ^&lt;/code&gt;).</source>
          <target state="translated">任意のサイズのビット文字列は、ビット演算子（ &lt;code&gt;~ | &amp;amp; ^&lt;/code&gt; ）で操作できます。</target>
        </trans-unit>
        <trans-unit id="55bcce66fdecceeb947a789cd32be9b93c7eca65" translate="yes" xml:space="preserve">
          <source>Bitwise And</source>
          <target state="translated">ビットワイズと</target>
        </trans-unit>
        <trans-unit id="b636b8ad1b24ac557aa4eb2c5b388de819e1c9dc" translate="yes" xml:space="preserve">
          <source>Bitwise Or and Exclusive Or</source>
          <target state="translated">ビット単位のOrと排他的なOr</target>
        </trans-unit>
        <trans-unit id="e12b00fd649b7b2d92cbde1fe11e2e094a03730b" translate="yes" xml:space="preserve">
          <source>Bitwise String Operators</source>
          <target state="translated">ビットごとの文字列演算子</target>
        </trans-unit>
        <trans-unit id="60dab14d1038a5ab6653c6e814d064d60e1699d8" translate="yes" xml:space="preserve">
          <source>Bitwise methods</source>
          <target state="translated">ビット単位のメソッド</target>
        </trans-unit>
        <trans-unit id="3dc97888788cc1b09dac9d2412a98d54e24f8b1e" translate="yes" xml:space="preserve">
          <source>Bitwise operators</source>
          <target state="translated">ビット演算子</target>
        </trans-unit>
        <trans-unit id="8a7fb7c64ed6d34c679867c6172b911e0f987e0b" translate="yes" xml:space="preserve">
          <source>Bitwise operators during &lt;code&gt;use integer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;use integer&lt;/code&gt; 中のビット演算子</target>
        </trans-unit>
        <trans-unit id="ca6124b539fbe18e72605192e10e84abc660b435" translate="yes" xml:space="preserve">
          <source>Bizarre SvTYPE [%d]</source>
          <target state="translated">奇妙なSvTYPE [%d]</target>
        </trans-unit>
        <trans-unit id="6569857bf0d6ff7a8e148a4adb3a9e8ee5c017ec" translate="yes" xml:space="preserve">
          <source>Bizarre copy of %s</source>
          <target state="translated">sの奇妙なコピー</target>
        </trans-unit>
        <trans-unit id="d97eb984318634f0d968a3f61bf23fd2faf3f45b" translate="yes" xml:space="preserve">
          <source>Bizarre space in item</source>
          <target state="translated">アイテム内の奇妙な空間</target>
        </trans-unit>
        <trans-unit id="ea2480b20b616fff68feba2feb22ee1344013e9a" translate="yes" xml:space="preserve">
          <source>Blank lines between chunks that do different things.</source>
          <target state="translated">異なることをするチャンク間の空白線。</target>
        </trans-unit>
        <trans-unit id="920da8ab7902a7645d8456f5c8da1988c54e0d83" translate="yes" xml:space="preserve">
          <source>Blessed References and Class Objects</source>
          <target state="translated">祝福された参照とクラスオブジェクト</target>
        </trans-unit>
        <trans-unit id="68214e18c0b1867aaa68202e63eba7567e9b30a9" translate="yes" xml:space="preserve">
          <source>Blessed objects are not directly representable in JSON, but &lt;code&gt;JSON::PP&lt;/code&gt; allows various ways of handling objects. See &lt;a href=&quot;#OBJECT-SERIALISATION&quot;&gt;&quot;OBJECT SERIALISATION&quot;&lt;/a&gt;, below, for details.</source>
          <target state="translated">祝福されたオブジェクトはJSONで直接表現できませんが、 &lt;code&gt;JSON::PP&lt;/code&gt; ではオブジェクトをさまざまな方法で処理できます。詳細については、以下の&lt;a href=&quot;#OBJECT-SERIALISATION&quot;&gt;「オブジェクトのシリアル化」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="79c23f408055d193d91f1b67442a45565695178a" translate="yes" xml:space="preserve">
          <source>Blesses an SV into a specified package. The SV must be an RV. The package must be designated by its stash (see &lt;code&gt;&lt;a href=&quot;#gv_stashpv&quot;&gt;&quot;gv_stashpv&quot;&lt;/a&gt;&lt;/code&gt;). The reference count of the SV is unaffected.</source>
          <target state="translated">指定されたパッケージにSVを祝福します。SVはRVでなければなりません。パッケージは、その隠し場所で指定する必要があります（ &lt;code&gt;&lt;a href=&quot;#gv_stashpv&quot;&gt;&quot;gv_stashpv&quot;&lt;/a&gt;&lt;/code&gt; 参照）。SVの参照カウントは影響を受けません。</target>
        </trans-unit>
        <trans-unit id="7954a73ad696d763789ec0de2fb44af6092e878a" translate="yes" xml:space="preserve">
          <source>Blesses an SV into a specified package. The SV must be an RV. The package must be designated by its stash (see &lt;code&gt;gv_stashpv()&lt;/code&gt; ). The reference count of the SV is unaffected.</source>
          <target state="translated">SVを指定されたパッケージに祝福します。SVはRVでなければなりません。パッケージはstashで指定する必要があります（ &lt;code&gt;gv_stashpv()&lt;/code&gt; を参照）。SVの参照カウントは影響を受けません。</target>
        </trans-unit>
        <trans-unit id="e54f1e0cbee429156b492ed8b4b751701cbcbd26" translate="yes" xml:space="preserve">
          <source>Blessing</source>
          <target state="translated">Blessing</target>
        </trans-unit>
        <trans-unit id="548174d374d3a6d330e0dce28420c09b6c8a9390" translate="yes" xml:space="preserve">
          <source>Blessing a shared item after it has been nested in another shared item does not propagate the blessing to the shared reference:</source>
          <target state="translated">他の共有アイテムに入れ子になった後に共有アイテムを祝福しても、その祝福は共有参照には伝わりません。</target>
        </trans-unit>
        <trans-unit id="e84551f3c75d4af55438233d1c2c7909c862fc3b" translate="yes" xml:space="preserve">
          <source>Blindly passing va_list</source>
          <target state="translated">盲目的に va_list を渡す</target>
        </trans-unit>
        <trans-unit id="929de0b7c4802448411e951e5153fd25660c3b1f" translate="yes" xml:space="preserve">
          <source>Blindly using variadic macros</source>
          <target state="translated">変形マクロを盲目的に使う</target>
        </trans-unit>
        <trans-unit id="82dd2cdf36f9436d89f404454654ad3e53fd428d" translate="yes" xml:space="preserve">
          <source>Block</source>
          <target state="translated">Block</target>
        </trans-unit>
        <trans-unit id="3df7eee072ad8f186abf1b2d2565ea2787bb93b4" translate="yes" xml:space="preserve">
          <source>Block eval</source>
          <target state="translated">ブロック評価</target>
        </trans-unit>
        <trans-unit id="9bf3b25756dcb70819ec2e3fa0ac57e7ce3a0990" translate="yes" xml:space="preserve">
          <source>Block names are matched in the compound form, like &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; or &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt; . Unlike most other properties, only a few block names have a Unicode-defined short name. But Perl does provide a (slight, no longer recommended) shortcut: You can say, for example &lt;code&gt;\p{In_Arrows}&lt;/code&gt; or &lt;code&gt;\p{In_Hebrew}&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;\p{Block: Arrows}&lt;/code&gt; や &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt; ように、ブロック名は複合形式で照合されます。他のほとんどのプロパティとは異なり、Unicodeで定義された短い名前を持つブロック名はごくわずかです。しかし、Perlは（やや推奨されなくなりました）ショートカットを提供しています。たとえば、 &lt;code&gt;\p{In_Arrows}&lt;/code&gt; または &lt;code&gt;\p{In_Hebrew}&lt;/code&gt; と言うことができます。</target>
        </trans-unit>
        <trans-unit id="75cda6989df1a079fcf560c9e780003cd931ab30" translate="yes" xml:space="preserve">
          <source>Block names are matched in the compound form, like &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; or &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt;. Unlike most other properties, only a few block names have a Unicode-defined short name.</source>
          <target state="translated">ブロック名は、 &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; や &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt; ように複合形式で照合されます。他のほとんどのプロパティとは異なり、Unicodeで定義された短い名前を持つブロック名はごくわずかです。</target>
        </trans-unit>
        <trans-unit id="d785c0d4b3b9c24878b62f64a7bcf78e9506ab27" translate="yes" xml:space="preserve">
          <source>Blocking</source>
          <target state="translated">Blocking</target>
        </trans-unit>
        <trans-unit id="bbaa0510707f42633a5b2810cc339df2222d09f5" translate="yes" xml:space="preserve">
          <source>Blocking =&amp;gt; BOOL</source>
          <target state="translated">ブロッキング=&amp;gt; BOOL</target>
        </trans-unit>
        <trans-unit id="54c45c033f5eb914fae27a646cbd9e23d3750d19" translate="yes" xml:space="preserve">
          <source>Blocks</source>
          <target state="translated">Blocks</target>
        </trans-unit>
        <trans-unit id="91c2278276bfdf926da91f0d87d6f0041b36f310" translate="yes" xml:space="preserve">
          <source>Blocks versus Scripts</source>
          <target state="translated">ブロックとスクリプト</target>
        </trans-unit>
        <trans-unit id="06992d2c6a4fd06aa405eff11e7109cec33fa12f" translate="yes" xml:space="preserve">
          <source>Blueprint</source>
          <target state="translated">Blueprint</target>
        </trans-unit>
        <trans-unit id="9febcf64ddd4a1c589fafb6acc27a333296a03c8" translate="yes" xml:space="preserve">
          <source>Body of the report. If not included on the command line, or in a file with &lt;b&gt;-f&lt;/b&gt;, you will get a chance to edit the message.</source>
          <target state="translated">レポートの本文。コマンドラインまたは&lt;b&gt;-fを使用&lt;/b&gt;したファイルに含まれていない場合は、メッセージを編集する機会があります。</target>
        </trans-unit>
        <trans-unit id="b1b26c9b3704fe7427bfc6aa57886af38bc8fd15" translate="yes" xml:space="preserve">
          <source>Body of the report. If not included on the command line, or in a file with &lt;b&gt;-f&lt;/b&gt;, you will get a chance to edit the report.</source>
          <target state="translated">レポートの本文。コマンドラインまたは&lt;b&gt;-f&lt;/b&gt;を含むファイルに含まれていない場合は、レポートを編集する機会があります。</target>
        </trans-unit>
        <trans-unit id="d2dcad692e8a39400b913368019fc7eef1d73269" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt; . Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">固定幅フォントの太字のイタリック（おそらく実際には斜め）バージョン。Pod :: Manはこれがあるとは想定しておらず、デフォルトで &lt;code&gt;CB&lt;/code&gt; になります。一部のシステム（Solarisなど）では、このフォントを &lt;code&gt;CX&lt;/code&gt; として使用できます。&lt;b&gt;troff&lt;/b&gt;出力にのみ関係します。</target>
        </trans-unit>
        <trans-unit id="9e34e43ca3b41295b323939a7bd9811db605af24" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt; . Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">固定幅フォントの太字のイタリック（おそらく実際には斜め）バージョン。Pod :: Manはこれがあるとは想定しておらず、デフォルトで &lt;code&gt;CB&lt;/code&gt; になります。一部のシステム（Solarisなど）では、このフォントを &lt;code&gt;CX&lt;/code&gt; として使用できます。troff（1）の出力にのみ重要です。</target>
        </trans-unit>
        <trans-unit id="feeb11edec497ca4f54c665a95df5130b4c829b2" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt;. Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt;. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">固定幅フォントの太字のイタリック（おそらく実際には斜め）バージョン。Pod :: Manは、これがあるとは想定せず、デフォルトで &lt;code&gt;CB&lt;/code&gt; になります。一部のシステム（Solarisなど）では、このフォントを &lt;code&gt;CX&lt;/code&gt; として使用できます。&lt;b&gt;troff&lt;/b&gt;出力にのみ関係します。</target>
        </trans-unit>
        <trans-unit id="302306e8a29ac5f2d9ddbda14d6dbb86f08c19c5" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt;. Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt;. Only matters for troff(1) output.</source>
          <target state="translated">固定幅フォントの太字のイタリック（おそらく実際には斜め）バージョン。Pod :: Manは、これがあるとは想定せず、デフォルトで &lt;code&gt;CB&lt;/code&gt; になります。一部のシステム（Solarisなど）では、このフォントを &lt;code&gt;CX&lt;/code&gt; として使用できます。troff（1）出力にのみ関係します。</target>
        </trans-unit>
        <trans-unit id="b9abc1cd480871c700b51d43c9a44b554d40d55c" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">太字の固定幅フォント。デフォルトは &lt;code&gt;CB&lt;/code&gt; です。&lt;b&gt;troff&lt;/b&gt;出力にのみ関係します。</target>
        </trans-unit>
        <trans-unit id="73204c593462d6c14f32f02ba63b55da40420528" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">太字の固定幅フォント。デフォルトは &lt;code&gt;CB&lt;/code&gt; です。troff（1）の出力にのみ重要です。</target>
        </trans-unit>
        <trans-unit id="4826fec0f048131f813dc8e60e9509d935802a38" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt;. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">固定幅フォントの太字。デフォルトは &lt;code&gt;CB&lt;/code&gt; です。&lt;b&gt;troff&lt;/b&gt;出力にのみ関係します。</target>
        </trans-unit>
        <trans-unit id="21be102197e929754c4d027624958a11458b8256" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt;. Only matters for troff(1) output.</source>
          <target state="translated">固定幅フォントの太字。デフォルトは &lt;code&gt;CB&lt;/code&gt; です。troff（1）出力にのみ関係します。</target>
        </trans-unit>
        <trans-unit id="ca3cddd25bd8f6bc4ce35a262e2e1398541ecf3d" translate="yes" xml:space="preserve">
          <source>Bookmarks</source>
          <target state="translated">Bookmarks</target>
        </trans-unit>
        <trans-unit id="fbe3448227f9beab3e352c0b7e28a363ba97c273" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, failing to have the required modules (or the right versions thereof) will be fatal. &lt;code&gt;perl Makefile.PL&lt;/code&gt; will &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; instead of simply informing the user of the missing dependencies.</source>
          <target state="translated">ブール。このパラメーターがtrueの場合、必要なモジュール（またはその適切なバージョン）を使用できないと致命的になります。 &lt;code&gt;perl Makefile.PL&lt;/code&gt; は、不足している依存関係を単にユーザーに通知 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; なく、終了します。</target>
        </trans-unit>
        <trans-unit id="aa02db7b0e1536fcc3f6de1b2a7dcf01412dc0c6" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, failing to have the required modules (or the right versions thereof) will be fatal. &lt;code&gt;perl Makefile.PL&lt;/code&gt; will &lt;code&gt;die&lt;/code&gt; instead of simply informing the user of the missing dependencies.</source>
          <target state="translated">ブール。このパラメーターがtrueの場合、必要なモジュール（またはその適切なバージョン）がないと致命的です。 &lt;code&gt;perl Makefile.PL&lt;/code&gt; なり &lt;code&gt;die&lt;/code&gt; 単に不足している依存関係をユーザに通知するのではなく。</target>
        </trans-unit>
        <trans-unit id="1a706d5f747a56fb59b2b20adabd115aadfc3ab6" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, the prerequisites will be printed to stdout and MakeMaker will exit. The output format is an evalable hash ref.</source>
          <target state="translated">ブール値。このパラメータが true の場合、前提条件が標準出力に出力され、MakeMaker は終了します。出力形式は evalable ハッシュ ref.</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="09eca632f0dfa4476bacf2f878b87c41a27eb16f" translate="yes" xml:space="preserve">
          <source>Boolean context</source>
          <target state="translated">ブールコンテキスト</target>
        </trans-unit>
        <trans-unit id="02eefeb78b1690ec4b9fb5543382dba69c8c96d9" translate="yes" xml:space="preserve">
          <source>Boolean logic</source>
          <target state="translated">ブールロジック</target>
        </trans-unit>
        <trans-unit id="cee421eba15aa24904646f6184653841c5c549d1" translate="yes" xml:space="preserve">
          <source>Boolean methods</source>
          <target state="translated">ブールメソッド</target>
        </trans-unit>
        <trans-unit id="02774d2bd49b309c70bcbf1cd2d7f51fdc3d2b2f" translate="yes" xml:space="preserve">
          <source>Boolean operators</source>
          <target state="translated">ブール演算子</target>
        </trans-unit>
        <trans-unit id="55aef5e3c5e0b75d499308ca6279e82ab808182b" translate="yes" xml:space="preserve">
          <source>Boolean operators &lt;code&gt;is_zero()&lt;/code&gt;, &lt;code&gt;is_one()&lt;/code&gt;, &lt;code&gt;is_inf()&lt;/code&gt;, etc. return true or false.</source>
          <target state="translated">ブール演算子 &lt;code&gt;is_zero()&lt;/code&gt; 、 &lt;code&gt;is_one()&lt;/code&gt; 、 &lt;code&gt;is_inf()&lt;/code&gt; などはtrueまたはfalseを返します。</target>
        </trans-unit>
        <trans-unit id="1e109ffb226c19879bd546df66c824f1e645625c" translate="yes" xml:space="preserve">
          <source>Boolean options:</source>
          <target state="translated">ブール値のオプション。</target>
        </trans-unit>
        <trans-unit id="c8c3f1d753ec555418a750eeff6d7eaeba2abf76" translate="yes" xml:space="preserve">
          <source>Boolean value. If false, disables the &lt;code&gt;X/Y&lt;/code&gt; test count which shows up while tests are running.</source>
          <target state="translated">ブール値。falseの場合、テストの実行中に表示される &lt;code&gt;X/Y&lt;/code&gt; テストカウントを無効にします。</target>
        </trans-unit>
        <trans-unit id="f6906832f4c5efb1eff6981bd8a551cf05deba12" translate="yes" xml:space="preserve">
          <source>Boolean which tells MakeMaker that it should include the rules to make a perl. This is handled automatically as a switch by MakeMaker. The user normally does not need it.</source>
          <target state="translated">MakeMakerにPerlを作るためのルールを含めるべきかどうかを指示するブール値。これは、MakeMakerによって自動的にスイッチとして処理されます。ユーザーは通常必要ありません。</target>
        </trans-unit>
        <trans-unit id="a3aa9ead54da3d9f1481bd131dbbec1f59ea0c12" translate="yes" xml:space="preserve">
          <source>Boolean. Attribute to inhibit descending into subdirectories.</source>
          <target state="translated">ブール値。サブディレクトリへの降順を禁止する属性。</target>
        </trans-unit>
        <trans-unit id="09273e0b3502cd35874b01a3ba91c106f87a667f" translate="yes" xml:space="preserve">
          <source>Bootstrapping</source>
          <target state="translated">Bootstrapping</target>
        </trans-unit>
        <trans-unit id="62ac59b7255ce5ff9fee8ac49157bdd9bc4445e2" translate="yes" xml:space="preserve">
          <source>Bosnia and Herzegovina</source>
          <target state="translated">ボスニア・ヘルツェゴビナ</target>
        </trans-unit>
        <trans-unit id="7cf7bb36f8e532fed41b905555bc401b988f86c8" translate="yes" xml:space="preserve">
          <source>Boss/Worker</source>
          <target state="translated">Boss/Worker</target>
        </trans-unit>
        <trans-unit id="80bcf52e7840ffd18cf3865b5ebb50a306bef71b" translate="yes" xml:space="preserve">
          <source>Both &quot;objects&quot; which are blessed into the class &lt;code&gt;two_refs1&lt;/code&gt; are references to a reference to an array, thus references to a</source>
          <target state="translated">クラス &lt;code&gt;two_refs1&lt;/code&gt; にblessされた両方の「オブジェクト」は、配列への参照への参照です。したがって、</target>
        </trans-unit>
        <trans-unit id="fdd5582984ca6c53c867eacfa38935bd769631ff" translate="yes" xml:space="preserve">
          <source>Both #1 and #2 make $data consist of a completely valid UTF-8 string, but only #2 turns the UTF8 flag on. #1 is equivalent to:</source>
          <target state="translated">1 と #2 の両方とも、$data は完全に有効な UTF-8 文字列で構成されていますが、#2 だけは UTF8 フラグをオンにしています。#1は次のようになります。</target>
        </trans-unit>
        <trans-unit id="e055e854ed20a46d2f7df7544241f7588b51f8b0" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;bsstr()&lt;/code&gt; as well as automated stringify via overload now drop the leading '+'. The old code would return '+3', the new returns '3'. This is to be consistent with Perl and to make &lt;code&gt;cmp&lt;/code&gt; (especially with overloading) to work as you expect. It also solves problems with &lt;code&gt;Test.pm&lt;/code&gt; and &lt;a href=&quot;../test/more&quot;&gt;Test::More&lt;/a&gt;, which stringify arguments before comparing them.</source>
          <target state="translated">&lt;code&gt;bstr()&lt;/code&gt; と &lt;code&gt;bsstr()&lt;/code&gt; の両方、およびオーバーロードによる自動文字列化で、先頭の「+」が削除されるようになりました。古いコードは「+3」を返し、新しいコードは「3」を返します。これは、Perlとの一貫性を保ち、 &lt;code&gt;cmp&lt;/code&gt; （特にオーバーロード）が期待どおりに機能するようにするためです。また、引数を比較する前に引数を文字 &lt;code&gt;Test.pm&lt;/code&gt; するTest.pmと&lt;a href=&quot;../test/more&quot;&gt;Test :: Moreの&lt;/a&gt;問題も解決します。</target>
        </trans-unit>
        <trans-unit id="a620ebe99c93fe5ad5f0770d99e27217bee38fe8" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;bsstr()&lt;/code&gt; as well as stringify via overload drop the leading '+'. This is to be consistent with Perl and to make &lt;code&gt;cmp&lt;/code&gt; (especially with overloading) to work as you expect. It also solves problems with &lt;code&gt;Test.pm&lt;/code&gt; and &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;, which stringify arguments before comparing them.</source>
          <target state="translated">&lt;code&gt;bstr()&lt;/code&gt; と &lt;code&gt;bsstr()&lt;/code&gt; の両方、およびオーバーロードを介した文字列化により、先頭の「+」が削除されます。これは、Perlと一貫性を保ち、 &lt;code&gt;cmp&lt;/code&gt; （特にオーバーロード）を期待どおりに機能させるためです。また、比較する前に引数を文字 &lt;code&gt;Test.pm&lt;/code&gt; するTest.pmと&lt;a href=&quot;Test::More&quot;&gt;Test :: Moreの&lt;/a&gt;問題も解決します。</target>
        </trans-unit>
        <trans-unit id="eaeb9ffa94e14cf78c87073a072611e3232fa148" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; and &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; will return &lt;code&gt;MAYBE&lt;/code&gt; . &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is not in NFC (its NFC is &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt; ), while &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is in NFC.</source>
          <target state="translated">両方 &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; と &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; が返されます &lt;code&gt;MAYBE&lt;/code&gt; 。 &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; はNFCにありません（NFCは &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt; ）、 &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; はNFCにあります。</target>
        </trans-unit>
        <trans-unit id="4a5a39017b338373b526416f145175959e75a080" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; and &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; will return &lt;code&gt;MAYBE&lt;/code&gt;. &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is not in NFC (its NFC is &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt;), while &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is in NFC.</source>
          <target state="translated">両方 &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; と &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; が返されます &lt;code&gt;MAYBE&lt;/code&gt; 。 &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; はNFCにありません（そのNFCは &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt; ）が、 &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; はNFCにあります。</target>
        </trans-unit>
        <trans-unit id="d0dc99557ca052a1f52b6aa9fe01653c0b56cfaf" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;cmp&lt;/code&gt; and &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; operators perform the same comparison between terms (upgrading to a version object automatically). Perl automatically generates all of the other comparison operators based on those two. In addition to the obvious equalities listed below, appending a single trailing 0 term does not change the value of a version for comparison purposes. In other words &quot;v1.2&quot; and &quot;1.2.0&quot; will compare as identical.</source>
          <target state="translated">&lt;code&gt;cmp&lt;/code&gt; 演算子と &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 演算子はどちらも、用語間で同じ比較を実行します（バージョンオブジェクトに自動的にアップグレードします）。Perlは、これら2つに基づいて他のすべての比較演算子を自動的に生成します。以下にリストされている明らかな同等性に加えて、単一の後続0項を追加しても、比較のためにバージョンの値は変更されません。つまり、「v1.2」と「1.2.0」は同じものとして比較されます。</target>
        </trans-unit>
        <trans-unit id="24cf9e2240da639243f4502d5aa3bda3947c5953" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; croak if given dates outside the supported range.</source>
          <target state="translated">サポートされている範囲外の日付を指定した場合、 &lt;code&gt;timelocal()&lt;/code&gt; と &lt;code&gt;timegm()&lt;/code&gt; の両方が鳴きます。</target>
        </trans-unit>
        <trans-unit id="9b6b1830495cedccd8298426103e7c2b6bedc5b6" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;wrap()&lt;/code&gt; and &lt;code&gt;fill()&lt;/code&gt; return a single string.</source>
          <target state="translated">&lt;code&gt;wrap()&lt;/code&gt; と &lt;code&gt;fill()&lt;/code&gt; はどちらも単一の文字列を返します。</target>
        </trans-unit>
        <trans-unit id="a3b45c366057bea34b5a8bb7824f2e8dd99b7496" translate="yes" xml:space="preserve">
          <source>Both Perl functions will expect an object as the first parameter. In the generated C++ code the object is called &lt;code&gt;THIS&lt;/code&gt; , and the method call will be performed on this object. So in the C++ code the blue() and set_blue() methods will be called as this:</source>
          <target state="translated">両方のPerl関数は、最初のパラメーターとしてオブジェクトを予期します。生成されたC ++コードでは、オブジェクトは &lt;code&gt;THIS&lt;/code&gt; と呼ばれ、このオブジェクトに対してメソッド呼び出しが実行されます。したがって、C ++コードでは、blue（）およびset_blue（）メソッドは次のように呼び出されます。</target>
        </trans-unit>
        <trans-unit id="7be927e1ed4202312ce2dde8192f9556312f51fd" translate="yes" xml:space="preserve">
          <source>Both Perl functions will expect an object as the first parameter. In the generated C++ code the object is called &lt;code&gt;THIS&lt;/code&gt;, and the method call will be performed on this object. So in the C++ code the blue() and set_blue() methods will be called as this:</source>
          <target state="translated">どちらのPerl関数も、最初のパラメーターとしてオブジェクトを想定しています。生成されたC ++コードでは、オブジェクトは &lt;code&gt;THIS&lt;/code&gt; と呼ばれ、メソッド呼び出しはこのオブジェクトに対して実行されます。したがって、C ++コードでは、blue（）メソッドとset_blue（）メソッドは次のように呼び出されます。</target>
        </trans-unit>
        <trans-unit id="642b008f0bb09ab02b4608dfe561ba3f906e665d" translate="yes" xml:space="preserve">
          <source>Both YAML.pm and YAML::Syck are capable of deserialising code. As this requires a string eval, which might be a security risk, you can use this option to enable or disable the deserialisation of code via CPAN::DeferredCode. (Note: This does not work under perl 5.6)</source>
          <target state="translated">YAML.pmとYAML::Syckは両方ともコードのデシリアライズが可能です。これは文字列のevalを必要としますが、これはセキュリティ上のリスクとなりますので、このオプションを使ってCPAN::DeferredCode経由でコードのデシリアライズを有効にしたり無効にしたりすることができます。(注意:これはperl 5.6では動作しません)</target>
        </trans-unit>
        <trans-unit id="1092e6af8de8fc50cc6d06fd73a32b5d8423a7e9" translate="yes" xml:space="preserve">
          <source>Both are bad, and broken, and unportable. Use the PTR2IV() macro that does it right. (Likewise, there are PTR2UV(), PTR2NV(), INT2PTR(), and NUM2PTR().)</source>
          <target state="translated">どちらもダメで、壊れていて、移植性がありません。それを正しく行う PTR2IV()マクロを使用してください。(同様に、PTR2UV()、PTR2NV()、INT2PTR()、NUM2PTR()があります)。</target>
        </trans-unit>
        <trans-unit id="e8f3fbafa937e38c34348185c6cef931d0a050c2" translate="yes" xml:space="preserve">
          <source>Both colored() and many uses of the color constants will add the reset escape sequence after a newline. If a program mixes colored output to standard output with output to standard error, this can result in the standard error text having the wrong color because the reset escape sequence hasn't yet been flushed to the display (since standard output to a terminal is line-buffered by default). To avoid this, either set autoflush() on STDOUT or set $Term::ANSIColor::EACHLINE to &lt;code&gt;&quot;\n&quot;&lt;/code&gt;.</source>
          <target state="translated">Colored（）と色定数の多くの使用法の両方で、改行の後にリセットエスケープシーケンスが追加されます。プログラムが色付き出力から標準出力への出力と標準エラーへの出力を混合する場合、リセットエスケープシーケンスがまだディスプレイにフラッシュされていないため、標準エラーテキストの色が間違っている可能性があります（端末への標準出力はラインであるため） -デフォルトでバッファリングされます）。これを回避するには、STDOUTでautoflush（）を設定するか、$ Term :: ANSIColor :: EACHLINEを &lt;code&gt;&quot;\n&quot;&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="d3767903b8fab9710d5f5dbf8d10a9f6252cdd29" translate="yes" xml:space="preserve">
          <source>Both efforts welcome volunteers. In order to get involved in smoke testing of the perl itself visit &lt;a href=&quot;http://search.cpan.org/dist/Test-Smoke/&quot;&gt;http://search.cpan.org/dist/Test-Smoke/&lt;/a&gt;. In order to start smoke testing CPAN modules visit &lt;a href=&quot;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&quot;&gt;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/dist/minismokebox/&quot;&gt;http://search.cpan.org/dist/minismokebox/&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/dist/CPAN-Reporter/&quot;&gt;http://search.cpan.org/dist/CPAN-Reporter/&lt;/a&gt;.</source>
          <target state="translated">どちらの取り組みもボランティアを歓迎します。perl自体の煙のテストに参加するには、&lt;a href=&quot;http://search.cpan.org/dist/Test-Smoke/&quot;&gt;http:&lt;/a&gt; //search.cpan.org/dist/Test-Smoke/にアクセスしてください。CPANモジュールのスモークテストを開始するには、&lt;a href=&quot;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&quot;&gt;http：//search.cpan.org/dist/CPANPLUS-YACSmoke/&lt;/a&gt;または&lt;a href=&quot;http://search.cpan.org/dist/minismokebox/&quot;&gt;http://search.cpan.org/dist/minismokebox/&lt;/a&gt;または&lt;a href=&quot;http://search.cpan.org/dist/CPAN-Reporter/&quot;&gt;http://search.cpan.orgに&lt;/a&gt;アクセスしてください。 / dist / CPAN-Reporter /。</target>
        </trans-unit>
        <trans-unit id="ae562d3087c6e461927df57072977056d07bc9d8" translate="yes" xml:space="preserve">
          <source>Both efforts welcome volunteers. In order to get involved in smoke testing of the perl itself visit &lt;a href=&quot;https://metacpan.org/release/Test-Smoke&quot;&gt;https://metacpan.org/release/Test-Smoke&lt;/a&gt;. In order to start smoke testing CPAN modules visit &lt;a href=&quot;https://metacpan.org/release/CPANPLUS-YACSmoke&quot;&gt;https://metacpan.org/release/CPANPLUS-YACSmoke&lt;/a&gt; or &lt;a href=&quot;https://metacpan.org/release/minismokebox&quot;&gt;https://metacpan.org/release/minismokebox&lt;/a&gt; or &lt;a href=&quot;https://metacpan.org/release/CPAN-Reporter&quot;&gt;https://metacpan.org/release/CPAN-Reporter&lt;/a&gt;.</source>
          <target state="translated">どちらの取り組みもボランティアを歓迎します。Perl自体のスモークテストに参加するには、&lt;a href=&quot;https://metacpan.org/release/Test-Smoke&quot;&gt;https：&lt;/a&gt; //metacpan.org/release/Test-Smokeにアクセスしてください。スモークテストCPANモジュールを開始するには、&lt;a href=&quot;https://metacpan.org/release/CPANPLUS-YACSmoke&quot;&gt;https：//metacpan.org/release/CPANPLUS-YACSmoke&lt;/a&gt;または&lt;a href=&quot;https://metacpan.org/release/minismokebox&quot;&gt;https://metacpan.org/release/minismokebox&lt;/a&gt;または&lt;a href=&quot;https://metacpan.org/release/CPAN-Reporter&quot;&gt;https://metacpan.org/release/CPAN-Reporterにアクセスしてください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55d4c4d23a88d207ea9fa065963f476f871b153f" translate="yes" xml:space="preserve">
          <source>Both encode and decode methods propagate &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;CHECK flags&lt;/a&gt; when encoding and decoding the MIME charset.</source>
          <target state="translated">エンコードとデコードの両方のメソッドは、MIME文字セットをエンコードおよびデコードするときに&lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;CHECKフラグを&lt;/a&gt;伝播します。</target>
        </trans-unit>
        <trans-unit id="5a1c59ffc42033f2c98187249f767826197ba8a8" translate="yes" xml:space="preserve">
          <source>Both forms are equivalent.</source>
          <target state="translated">どちらの形態も同等です。</target>
        </trans-unit>
        <trans-unit id="143f2cf2fc37f6046de22ba46473032b532447b9" translate="yes" xml:space="preserve">
          <source>Both functions return equivalent information (like &lt;code&gt;gettimeofday&lt;/code&gt; ) but with different representations. The names &lt;code&gt;NVtime&lt;/code&gt; and &lt;code&gt;U2time&lt;/code&gt; were selected mainly because they are operating system independent. (&lt;code&gt;gettimeofday&lt;/code&gt; is Unix-centric, though some platforms like Win32 and VMS have emulations for it.)</source>
          <target state="translated">どちらの関数も（ &lt;code&gt;gettimeofday&lt;/code&gt; などの）同等の情報を返しますが、表現は異なります。 &lt;code&gt;NVtime&lt;/code&gt; および &lt;code&gt;U2time&lt;/code&gt; という名前は、主にオペレーティングシステムに依存しないために選択されました。（ &lt;code&gt;gettimeofday&lt;/code&gt; はUnix中心ですが、Win32やVMSなどの一部のプラットフォームではエミュレーションがあります。）</target>
        </trans-unit>
        <trans-unit id="5c4e6f175302e55e83c34f1bf1849d831a9de257" translate="yes" xml:space="preserve">
          <source>Both functions return equivalent information (like &lt;code&gt;gettimeofday&lt;/code&gt;) but with different representations. The names &lt;code&gt;NVtime&lt;/code&gt; and &lt;code&gt;U2time&lt;/code&gt; were selected mainly because they are operating system independent. (&lt;code&gt;gettimeofday&lt;/code&gt; is Unix-centric, though some platforms like Win32 and VMS have emulations for it.)</source>
          <target state="translated">どちらの関数も同等の情報（ &lt;code&gt;gettimeofday&lt;/code&gt; など）を返しますが、表現は異なります。 &lt;code&gt;NVtime&lt;/code&gt; と &lt;code&gt;U2time&lt;/code&gt; という名前は、主にオペレーティングシステムに依存しないために選択されました。（ &lt;code&gt;gettimeofday&lt;/code&gt; はUnix中心ですが、Win32やVMSなどの一部のプラットフォームにはエミュレーションがあります。）</target>
        </trans-unit>
        <trans-unit id="0b934a70ce89ebfca7d59daaef7b8bcbcd00a0ef" translate="yes" xml:space="preserve">
          <source>Both install() and uninstall() are specific to the way ExtUtils::MakeMaker handles the installation and deinstallation of perl modules. They are not designed as general purpose tools.</source>
          <target state="translated">install()と uninstall()は共に ExtUtils::MakeMaker が perl モジュールのインストールとデインストールを処理する方法に特化したものです。これらは汎用ツールとして設計されたものではありません。</target>
        </trans-unit>
        <trans-unit id="5627699dd1ad2924464995985beca5c6cf35ef97" translate="yes" xml:space="preserve">
          <source>Both methods will prevent the import() method from firing and exporting the &lt;code&gt;qv()&lt;/code&gt; sub.</source>
          <target state="translated">どちらのメソッドも、import（）メソッドが &lt;code&gt;qv()&lt;/code&gt; サブを起動してエクスポートするのを防ぎます。</target>
        </trans-unit>
        <trans-unit id="9733ec84f2ee4e84fe6e0d43084959736e1c222c" translate="yes" xml:space="preserve">
          <source>Both numeric and string values are accepted, but note that string values are case sensitive. The default for this setting is &quot;RANDOM&quot; or 1.</source>
          <target state="translated">数値と文字列のどちらも受け入れられますが、文字列の値は大文字と小文字を区別することに注意してください。この設定のデフォルトは &quot;RANDOM &quot;または1です。</target>
        </trans-unit>
        <trans-unit id="4cf5f58736e6000e5a6bd77d8280326d1b82a931" translate="yes" xml:space="preserve">
          <source>Both of the above match the characters &lt;code&gt;\N{U+00}&lt;/code&gt;&lt;code&gt;\N{U+01}&lt;/code&gt; , ... &lt;code&gt;\N{U+08}&lt;/code&gt; , &lt;code&gt;\N{U+09}&lt;/code&gt; , but the &lt;code&gt;\x09&lt;/code&gt; looks like it could be a mistake so the warning is raised (under &lt;code&gt;re 'strict'&lt;/code&gt; ) for it.</source>
          <target state="translated">上記の両方が文字 &lt;code&gt;\N{U+00}&lt;/code&gt; &lt;code&gt;\N{U+01}&lt;/code&gt; 、... &lt;code&gt;\N{U+08}&lt;/code&gt; 、 &lt;code&gt;\N{U+09}&lt;/code&gt; と &lt;code&gt;\x09&lt;/code&gt; ますが、\ x09は次のようになります間違いのため、警告は（ &lt;code&gt;re 'strict'&lt;/code&gt; の下で）発生します。</target>
        </trans-unit>
        <trans-unit id="6cba8f2c40b0b7e7464484e646fc77656ccf2181" translate="yes" xml:space="preserve">
          <source>Both of the above match the characters &lt;code&gt;\N{U+00}&lt;/code&gt;&lt;code&gt;\N{U+01}&lt;/code&gt;, ... &lt;code&gt;\N{U+08}&lt;/code&gt;, &lt;code&gt;\N{U+09}&lt;/code&gt;, but the &lt;code&gt;\x09&lt;/code&gt; looks like it could be a mistake so the warning is raised (under &lt;code&gt;re 'strict'&lt;/code&gt;) for it.</source>
          <target state="translated">上記は両方とも文字 &lt;code&gt;\N{U+00}&lt;/code&gt; &lt;code&gt;\N{U+01}&lt;/code&gt; 、... &lt;code&gt;\N{U+08}&lt;/code&gt; 、 &lt;code&gt;\N{U+09}&lt;/code&gt; と &lt;code&gt;\x09&lt;/code&gt; ますが、\ x09は次のようになります。間違いなので、警告が表示されます（ &lt;code&gt;re 'strict'&lt;/code&gt; 下で）。</target>
        </trans-unit>
        <trans-unit id="19034866ba0e5cf040b7023a16a969fddf08ed53" translate="yes" xml:space="preserve">
          <source>Both of the provided scalars are already compiled as regular expressions and do not contain either anchors or implicit groupings, so they can be included in your own regular expressions freely. For example, consider the following code:</source>
          <target state="translated">提供されているスカラはどちらも既に正規表現としてコンパイルされており、アンカーも暗黙のグルーピングも含まれていないので、独自の正規表現に自由に含めることができます。例えば、次のコードを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="e6fc8a94496c661c5e9f86f3352074c1b6a4eef2" translate="yes" xml:space="preserve">
          <source>Both of these methods will produce similar version objects, in that the default stringification will yield the version &lt;a href=&quot;#Normal-Form&quot;&gt;&quot;Normal Form&quot;&lt;/a&gt; only if required:</source>
          <target state="translated">これらのメソッドはどちらも、必要な場合にのみデフォルトの文字列化によってバージョン&lt;a href=&quot;#Normal-Form&quot;&gt;「正規形」&lt;/a&gt;が生成されるという点で、同様のバージョンオブジェクトを生成します。</target>
        </trans-unit>
        <trans-unit id="2a103cc718ae6b6f4898e4597463858c0b08dfa7" translate="yes" xml:space="preserve">
          <source>Both or neither range ends should be Unicode in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">範囲の両端またはどちらも正規表現ではUnicodeである必要があります。&amp;lt;-ここにm /％s /でマーク</target>
        </trans-unit>
        <trans-unit id="d4874cd0d5b99351b1bf775f190f16f304b87eaf" translate="yes" xml:space="preserve">
          <source>Both read and write access.</source>
          <target state="translated">読み取りアクセスと書き込みアクセスの両方に対応しています。</target>
        </trans-unit>
        <trans-unit id="e56fad1d57355bf08ff94859ec86b0170dc6755c" translate="yes" xml:space="preserve">
          <source>Both routines return a reference to the hash operated on.</source>
          <target state="translated">どちらのルーチンも操作されたハッシュへの参照を返します。</target>
        </trans-unit>
        <trans-unit id="7a1480fdf3f98f2170cd256ce3b56c618e9acd2d" translate="yes" xml:space="preserve">
          <source>Both signify the monospace (c[ode] style) text consisting of &quot;$x&quot;, one space, &quot;?&quot;, one space, &quot;:&quot;, one space, &quot;$z&quot;. The difference is that in the latter, with the S code, those spaces are not &quot;normal&quot; spaces, but instead are non-breaking spaces.</source>
          <target state="translated">どちらも、&quot;$x&quot;、1つのスペース、&quot;?&quot;、1つのスペース、&quot;:&quot;、1つのスペース、&quot;$z &quot;で構成される等幅(c[ode]スタイル)テキストを意味します。違いは、後者では、Sコードでは、これらのスペースは「通常の」スペースではなく、代わりに非改行スペースであるということです。</target>
        </trans-unit>
        <trans-unit id="ed699d8c766ffac9fc7609020189bb30a788c2d9" translate="yes" xml:space="preserve">
          <source>Both stringify and bstr() now drop the leading '+'. The old code would return '+1.23', the new returns '1.23'. See the documentation in &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; for reasoning and details.</source>
          <target state="translated">stringifyとbstr（）の両方で、先頭の「+」が削除されるようになりました。古いコードは「+1.23」を返し、新しいコードは「1.23」を返します。理由と詳細については、&lt;a href=&quot;Math::BigInt&quot;&gt;Math :: BigIntの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="ce9280ff05f374fc2e82bcdbf91ea7cf106541bf" translate="yes" xml:space="preserve">
          <source>Both stringify and bstr() now drop the leading '+'. The old code would return '+1.23', the new returns '1.23'. See the documentation in &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; for reasoning and details.</source>
          <target state="translated">stringifyとbstr（）の両方が先頭の '+'を削除するようになりました。古いコードは「+1.23」を返し、新しいコードは「1.23」を返します。理由と詳細については、&lt;a href=&quot;bigint&quot;&gt;Math :: BigIntの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="6e26a4aa31b6884fed4ace8e2ed5cfef52233768" translate="yes" xml:space="preserve">
          <source>Both styles work with either objects or typeglobs of real filehandles. (They might also work with strings under some circumstances, but this is risky.)</source>
          <target state="translated">どちらのスタイルも、実際のファイルハンドルのオブジェクトかタイプグローブのどちらかで動作します。(状況によっては文字列でも動作するかもしれませんが、これは危険です)。</target>
        </trans-unit>
        <trans-unit id="40008ef1178df5187f4e9e86678b099b5c9935cc" translate="yes" xml:space="preserve">
          <source>Both subroutines here are called in a scalar context, while in:</source>
          <target state="translated">ここでのサブルーチンはどちらもスカラコンテキストで呼び出されますが、inではスカラコンテキストで呼び出されます。</target>
        </trans-unit>
        <trans-unit id="88a5a602af253e21581322ee44c47e54f2ad5148" translate="yes" xml:space="preserve">
          <source>Both sysread() and recv() currently use only the &lt;code&gt;:utf8&lt;/code&gt; flag for the stream, ignoring the actual layers. Since sysread() and recv() do no UTF-8 validation they can end up creating invalidly encoded scalars.</source>
          <target state="translated">現在、sysread（）とrecv（）はどちらも、実際のレイヤーを無視して、ストリームに &lt;code&gt;:utf8&lt;/code&gt; フラグのみを使用しています。sysread（）とrecv（）はUTF-8検証を行わないため、無効にエンコードされたスカラーを作成してしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="5b8819b78d506b9303c55ca1c6cd1ccf91f01b90" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;$key&lt;/code&gt; and &lt;code&gt;$value&lt;/code&gt; parameters will be set to the key/value pair read from the database.</source>
          <target state="translated">&lt;code&gt;$key&lt;/code&gt; パラメータと &lt;code&gt;$value&lt;/code&gt; パラメータの両方が、データベースから読み取られたキーと値のペアに設定されます。</target>
        </trans-unit>
        <trans-unit id="65ffa77ee21f2f134768654239d413a7ca561444" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;FETCH&lt;/code&gt; ing function and the &lt;code&gt;EXISTS&lt;/code&gt; functions have the same signature: the arguments are &lt;code&gt;$key, $data&lt;/code&gt; ; $data is the same value as given as argument during tie()ing. Both functions should return an empty list if the value does not exist. If &lt;code&gt;EXISTS&lt;/code&gt; function is different from the &lt;code&gt;FETCH&lt;/code&gt; ing function, it should return a TRUE value on success. The &lt;code&gt;FETCH&lt;/code&gt; ing function should return the intended value if the key is valid.</source>
          <target state="translated">&lt;code&gt;FETCH&lt;/code&gt; ing関数と &lt;code&gt;EXISTS&lt;/code&gt; 関数の両方に同じシグネチャがあります。引数は &lt;code&gt;$key, $data&lt;/code&gt; です。 $ dataは、tie（）中に引数として指定されたものと同じ値です。値が存在しない場合、どちらの関数も空のリストを返す必要があります。場合 &lt;code&gt;EXISTS&lt;/code&gt; 機能が異なっている &lt;code&gt;FETCH&lt;/code&gt; INGの機能、それが成功した場合にTRUE値を返す必要があります。 &lt;code&gt;FETCH&lt;/code&gt; キーが有効な場合INGの機能が意図した値を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="26d9da8f5ad7069914e20430c62d4e761633b2e9" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;FETCH&lt;/code&gt;ing function and the &lt;code&gt;EXISTS&lt;/code&gt; functions have the same signature: the arguments are &lt;code&gt;$key, $data&lt;/code&gt;; $data is the same value as given as argument during tie()ing. Both functions should return an empty list if the value does not exist. If &lt;code&gt;EXISTS&lt;/code&gt; function is different from the &lt;code&gt;FETCH&lt;/code&gt;ing function, it should return a TRUE value on success. The &lt;code&gt;FETCH&lt;/code&gt;ing function should return the intended value if the key is valid.</source>
          <target state="translated">どちらの &lt;code&gt;FETCH&lt;/code&gt; INGの機能をと &lt;code&gt;EXISTS&lt;/code&gt; の機能は同じシグネチャを持っている：引数は、 &lt;code&gt;$key, $data&lt;/code&gt; 。$ dataは、tie（）ing中に引数として指定された値と同じです。値が存在しない場合、両方の関数は空のリストを返す必要があります。場合 &lt;code&gt;EXISTS&lt;/code&gt; 機能が異なっている &lt;code&gt;FETCH&lt;/code&gt; INGの機能、それが成功した場合にTRUE値を返す必要があります。 &lt;code&gt;FETCH&lt;/code&gt; キーが有効な場合INGの機能が意図した値を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="a6ed4eca63dc77f9c5ab93bb8224d63244af078a" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;\p&lt;/code&gt; counterparts always assume Unicode rules are in effect. On ASCII platforms, this means they assume that the code points from 128 to 255 are Latin-1, and that means that using them under locale rules is unwise unless the locale is guaranteed to be Latin-1 or UTF-8. In contrast, the POSIX character classes are useful under locale rules. They are affected by the actual rules in effect, as follows:</source>
          <target state="translated">&lt;code&gt;\p&lt;/code&gt; 両方の対応物は、常にUnicodeルールが有効であることを前提としています。これは、ASCIIプラットフォームでは、128から255までのコードポイントがLatin-1であると想定しているため、ロケールがLatin-1またはUTF-8であることが保証されていない限り、それらをロケールルールの下で使用することは賢明ではないことを意味します。対照的に、POSIX文字クラスはロケール規則の下で役立ちます。次のように、実際のルールの影響を受けます。</target>
        </trans-unit>
        <trans-unit id="ce95f2fe752d4b23fc80e241799a0c7676e9a5d9" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;filter&lt;/code&gt; method used with a</source>
          <target state="translated">で使用される両方の &lt;code&gt;filter&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="16bb52db9f75f89e8e102ba17368f296bd30bb0a" translate="yes" xml:space="preserve">
          <source>Both the Store and Fetch filters manipulate &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">StoreフィルターとFetchフィルターはどちらも &lt;code&gt;$_&lt;/code&gt; 操作します。</target>
        </trans-unit>
        <trans-unit id="4fb703f0b0c3a852ad76e2cb00f9c501f48f8ec4" translate="yes" xml:space="preserve">
          <source>Both the Store and Fetch filters manipulate &lt;code&gt;$_&lt;/code&gt;.</source>
          <target state="translated">StoreフィルターとFetchフィルターの両方が &lt;code&gt;$_&lt;/code&gt; 操作します。</target>
        </trans-unit>
        <trans-unit id="76973f944d78d30e634a5b0ebc6b4adb75da6f43" translate="yes" xml:space="preserve">
          <source>Both the functions can import the functions that are specified.</source>
          <target state="translated">どちらの関数も指定した関数をインポートすることができます。</target>
        </trans-unit>
        <trans-unit id="2ad856a815b0ce3afb8156093d09ab25a9afd217" translate="yes" xml:space="preserve">
          <source>Both the main process and any child processes it forks share the same STDIN, STDOUT, and STDERR filehandles. If both processes try to access them at once, strange things can happen. You may also want to close or reopen the filehandles for the child. You can get around this by opening your pipe with open(), but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="translated">メインプロセスとそれがフォークするすべての子プロセスは、同じ STDIN、STDOUT、STDERR ファイルハンドルを共有しています。両方のプロセスが同時にアクセスしようとすると、奇妙なことが起こる可能性があります。また、子プロセスのファイルハンドルを閉じたり、開き直したりする必要があるかもしれません。これは open()でパイプを開くことで回避できますが、システムによっては子プロセスが親プロセスより長生きできないことを意味します。</target>
        </trans-unit>
        <trans-unit id="449435c9cac23bf8a94ca4fcd8681004ec825181" translate="yes" xml:space="preserve">
          <source>Both the main process and the backgrounded one (the &quot;child&quot; process) share the same STDIN, STDOUT and STDERR filehandles. If both try to access them at once, strange things can happen. You may want to close or reopen these for the child. You can get around this with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;ing a pipe (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;) but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="translated">メインプロセスとバックグラウンドプロセス（「子」プロセス）は、同じSTDIN、STDOUT、およびSTDERRファイルハンドルを共有します。両方が一度にそれらにアクセスしようとすると、奇妙なことが起こる可能性があります。あなたは子供のためにこれらを閉じるか、または再開することができます。パイプを &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; と（&lt;a href=&quot;functions/open&quot;&gt;openを&lt;/a&gt;参照）、これを回避できますが、一部のシステムでは、これは子プロセスが親より長く存続できないことを意味します。</target>
        </trans-unit>
        <trans-unit id="f7d92bf0fef8c6d376360d3e96b538b59d69f577" translate="yes" xml:space="preserve">
          <source>Both the main process and the backgrounded one (the &quot;child&quot; process) share the same STDIN, STDOUT and STDERR filehandles. If both try to access them at once, strange things can happen. You may want to close or reopen these for the child. You can get around this with &lt;code&gt;open&lt;/code&gt;ing a pipe (see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;) but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="translated">メインプロセスとバックグラウンドプロセス（「子」プロセス）の両方が、同じSTDIN、STDOUT、およびSTDERRファイルハンドルを共有します。両方が同時にそれらにアクセスしようとすると、奇妙なことが起こる可能性があります。あなたは子供のためにこれらを閉じたり、再び開いたりしたいかもしれません。パイプを &lt;code&gt;open&lt;/code&gt; ことでこれを回避できますが（&lt;a href=&quot;perlfunc#open&quot;&gt;perlfuncの「open」を参照&lt;/a&gt;）、一部のシステムでは、これは子プロセスが親よりも長生きできないことを意味します。</target>
        </trans-unit>
        <trans-unit id="d89a0af2055da02fc83d8afed6e917b5cc66d525" translate="yes" xml:space="preserve">
          <source>Both the native cc and gcc seem to consume lots of memory when building Perl. toke.c is a known trouble spot when optimizing: 256 megabytes of data section seems to be enough. Another known trouble spot is the mktables script which builds the Unicode support tables. The default setting of the process data section in Tru64 should be one gigabyte, but some sites/setups might have lowered that. The configuration process of Perl checks for too low process limits, and lowers the optimization for the toke.c if necessary, and also gives advice on how to raise the process limits (for example: &lt;code&gt;ulimit -d 262144&lt;/code&gt;)</source>
          <target state="translated">ネイティブccとgccはどちらも、Perlをビルドするときに大量のメモリを消費するようです。toke.cは、最適化する際の既知の問題点です。256メガバイトのデータセクションで十分なようです。もう1つの既知の問題点は、Unicodeサポートテーブルを作成するmktablesスクリプトです。Tru64のプロセスデータセクションのデフォルト設定は1ギガバイトである必要がありますが、一部のサイト/セットアップではそれが低くなっている可能性があります。Perlの構成プロセスは、プロセス制限が低すぎるかどうかをチェックし、必要に応じてtoke.cの最適化を下げ、プロセス制限を上げる方法についてのアドバイスも提供します（例： &lt;code&gt;ulimit -d 262144&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="12969a7fe698e5db30d6dfa2ac116b77818d15ac" translate="yes" xml:space="preserve">
          <source>Both the special and normal mappings are stored in</source>
          <target state="translated">特別なマッピングと通常のマッピングの両方が</target>
        </trans-unit>
        <trans-unit id="e87bc450de2089bfd62a5bd96629fc5b32ff6be9" translate="yes" xml:space="preserve">
          <source>Both these XS declarations correspond to the &lt;code&gt;char*&lt;/code&gt; C type, but they have different semantics, see &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;&quot;The &amp;amp; Unary Operator&quot;&lt;/a&gt;.</source>
          <target state="translated">これらのXS宣言は両方とも &lt;code&gt;char*&lt;/code&gt; Cタイプに対応しますが、セマンティクスが異なります。&lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;「The＆UnaryOperator」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1a5aa8697bdd1c4c4522254cc3fbbee82434df88" translate="yes" xml:space="preserve">
          <source>Both these XS declarations correspond to the &lt;code&gt;char*&lt;/code&gt; C type, but they have different semantics, see &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The &amp;amp; Unary Operator&lt;/a&gt;.</source>
          <target state="translated">これらのXS宣言は両方とも &lt;code&gt;char*&lt;/code&gt; C型に対応していますが、セマンティクスは異なります。&lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;＆＆単項演算子を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="457d0ea6cab97df36f6f6888a3f8a1c477cbe9c0" translate="yes" xml:space="preserve">
          <source>Both these methods insert &lt;code&gt;&quot;:full&quot;&lt;/code&gt; automatically as the first argument (if no other argument is given), and you can give the &lt;code&gt;&quot;:full&quot;&lt;/code&gt; explicitly as well, like</source>
          <target state="translated">これらのメソッドはどちらも、最初の引数として &lt;code&gt;&quot;:full&quot;&lt;/code&gt; 自動的に挿入し（他の引数が指定されていない場合）、次のように &lt;code&gt;&quot;:full&quot;&lt;/code&gt; 明示的に指定することもできます。</target>
        </trans-unit>
        <trans-unit id="a673297be17d984a1ebfc2f484aa63db04fb7bb3" translate="yes" xml:space="preserve">
          <source>Both these problems can be cured. Say, if we want to overload hash dereference on a reference to an object which is</source>
          <target state="translated">これらの問題はどちらも解決できます。以下のようなオブジェクトへの参照に対してハッシュ参照をオーバーロードしたいとします。</target>
        </trans-unit>
        <trans-unit id="c67dbd5c074e12563a96469c299bb554a98bb89b" translate="yes" xml:space="preserve">
          <source>Both wdayname (day) and monname (month) allow passing in a list to use to index the name of the days against. This can be useful if you need to implement some form of localisation without actually installing or using locales.</source>
          <target state="translated">wdayname (日)と monname (月)の両方とも、リストを渡すことで、日の名前をインデックス化するために使用することができます。これは、実際にロケールをインストールしたり使用したりせずに、何らかの形でローカリゼーションを実装する必要がある場合に便利です。</target>
        </trans-unit>
        <trans-unit id="7251257be5507cef24fe3fb21a50fe67755c29b8" translate="yes" xml:space="preserve">
          <source>Both wdayname (day) and monname (month) allow passing in a list to use to index the name of the days against. This can be useful if you need to implement some form of localisation without actually installing or using locales. Note that this is a global override and will affect all Time::Piece instances.</source>
          <target state="translated">wdayname (日)と monname (月)の両方とも、リストを渡すことで、日の名前をインデックス化するために使用することができます。これは、実際にロケールをインストールしたり使用したりせずに、何らかの形でローカライズを実装する必要がある場合に便利です。これはグローバルなオーバーライドであり、すべてのTime::Pieceインスタンスに影響することに注意してください。</target>
        </trans-unit>
        <trans-unit id="5f50d687ceecfadfb877f247a6453725043a7ffb" translate="yes" xml:space="preserve">
          <source>Bottom level UTF-8 decode routine. Returns the native code point value of the first character in the string &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, which is assumed to be in UTF-8 (or UTF-EBCDIC) encoding, and no longer than &lt;code&gt;curlen&lt;/code&gt; bytes; &lt;code&gt;*retlen&lt;/code&gt; (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) will be set to the length, in bytes, of that character.</source>
          <target state="translated">最下位レベルのUTF-8デコードルーチン。文字列 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; の最初の文字のネイティブコードポイント値を返します。これはUTF-8（またはUTF-EBCDIC）エンコーディングで、 &lt;code&gt;curlen&lt;/code&gt; バイト以下であると想定されています。 &lt;code&gt;*retlen&lt;/code&gt; （ &lt;code&gt;retlen&lt;/code&gt; がNULLでない場合）は、その文字の長さ（バイト単位）に設定されます。</target>
        </trans-unit>
        <trans-unit id="dfa04ba4cca5e78047dc43990129bc3ae3f19bff" translate="yes" xml:space="preserve">
          <source>Bottom level UTF-8 decode routine. Returns the native code point value of the first character in the string &lt;code&gt;s&lt;/code&gt;, which is assumed to be in UTF-8 (or UTF-EBCDIC) encoding, and no longer than &lt;code&gt;curlen&lt;/code&gt; bytes; &lt;code&gt;*retlen&lt;/code&gt; (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) will be set to the length, in bytes, of that character.</source>
          <target state="translated">最下位レベルのUTF-8デコードルーチン。文字列 &lt;code&gt;s&lt;/code&gt; の最初の文字のネイティブコードポイント値を返します。これは、UTF-8（またはUTF-EBCDIC）エンコーディングであり、 &lt;code&gt;curlen&lt;/code&gt; バイト以下であると見なされます。 &lt;code&gt;*retlen&lt;/code&gt; （ &lt;code&gt;retlen&lt;/code&gt; がNULLでない場合）は、その文字の長さ（バイト単位）に設定されます。</target>
        </trans-unit>
        <trans-unit id="5ffac88340ff426b9b20077ea20bd37ed9bc04e3" translate="yes" xml:space="preserve">
          <source>Boundaries of Hangul syllables are determined according to conjoining Jamo behavior in</source>
          <target state="translated">ハングルの音節の境界線は、接続ジャモの動作に応じて決定されます。</target>
        </trans-unit>
        <trans-unit id="fa3c7716ef77e2c3385fc102b1a731781237c324" translate="yes" xml:space="preserve">
          <source>Boykin, Joseph, David Kirschen, Alan Langerman, and Susan LoVerso. Programming under Mach. Addison-Wesley, 1994, ISBN 0-201-52739-1.</source>
          <target state="translated">Boykin,Joseph,David Kirschen,Alan Langerman,and Susan LoVerso.マッハの下でのプログラミング.Addison-Wesley,1994,ISBN 0-201-52739-1.</target>
        </trans-unit>
        <trans-unit id="cbed39e2d9457a27b38ac123d4072c095875ce37" translate="yes" xml:space="preserve">
          <source>Brace yourself for thanks, bug reports, hate mail and spam coming as result of the previous step. No good deed should remain unpunished!</source>
          <target state="translated">前のステップの結果として来る感謝、バグ報告、ヘイトメール、スパムに備えてください。どんな善行も罰せられるべきではありません。</target>
        </trans-unit>
        <trans-unit id="5fde9354c8205697f6414265780ed0c53484415c" translate="yes" xml:space="preserve">
          <source>Braces are required in referring to named capture groups, but are optional for absolute or relative numbered ones. Braces are safer when creating a regex by concatenating smaller strings. For example if you have &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt; , you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="translated">名前付きキャプチャグループを参照する場合は中括弧が必要ですが、絶対番号または相対番号のグループでは省略可能です。小さい文字列を連結して正規表現を作成する場合、中括弧はより安全です。たとえば、 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt; があり、 &lt;code&gt;$a&lt;/code&gt; に &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; 含まれ、 &lt;code&gt;$b&lt;/code&gt; に &lt;code&gt;&quot;37&quot;&lt;/code&gt; が含まれている場合、 &lt;code&gt;/\g137/&lt;/code&gt; が得られますが、これはおそらく意図したものではありません。</target>
        </trans-unit>
        <trans-unit id="18fd4ec0e937de91c70828b19eb3454f88d75941" translate="yes" xml:space="preserve">
          <source>Braces are required in referring to named capture groups, but are optional for absolute or relative numbered ones. Braces are safer when creating a regex by concatenating smaller strings. For example if you have &lt;code&gt;qr/$a$b/&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt;, and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt;, you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="translated">名前付きキャプチャグループを参照するには中括弧が必要ですが、絶対番号または相対番号の場合はオプションです。小さい文字列を連結して正規表現を作成する場合は、中括弧の方が安全です。たとえば、 &lt;code&gt;qr/$a$b/&lt;/code&gt; があり、 &lt;code&gt;$a&lt;/code&gt; に &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; 含まれ、 &lt;code&gt;$b&lt;/code&gt; に &lt;code&gt;&quot;37&quot;&lt;/code&gt; 含まれている場合、 &lt;code&gt;/\g137/&lt;/code&gt; が得られますが、これはおそらく意図したものではありません。</target>
        </trans-unit>
        <trans-unit id="2fa9a0b57b5dc549e8decf6cc394f53167efa53b" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a crucial feature of Locale::Maketext. I mean Bracket Notation to provide a replacement for the use of sprintf formatting. Everything you do with Bracket Notation could be done with a sub block, but bracket notation is meant to be much more concise.</source>
          <target state="translated">ブラケット記法はLocale::Maketextの重要な機能です。ブラケット記法は、sprintfフォーマットの代わりを提供するためのものです。ブラケット記法で行うことはすべてサブブロックで行うことができますが、ブラケット記法はより簡潔になるように意図されています。</target>
        </trans-unit>
        <trans-unit id="bb9b16ff2deefe21cce7105f1030ffe04c9ef94b" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a like a miniature &quot;template&quot; system (in the sense of &lt;a href=&quot;Text::Template&quot;&gt;Text::Template&lt;/a&gt;, not in the sense of C++ templates), where normal text is passed thru basically as is, but text in special regions is specially interpreted. In Bracket Notation, you use square brackets (&quot;[...]&quot;), not curly braces (&quot;{...}&quot;) to note sections that are specially interpreted.</source>
          <target state="translated">ブラケット表記は、ミニチュアの「テンプレート」システム（&lt;a href=&quot;Text::Template&quot;&gt;Text :: Template&lt;/a&gt;の意味で、C ++テンプレートの意味ではありません）のようなもので、通常のテキストは基本的にそのまま渡されますが、特別な領域のテキストは特別に解釈されます。ブラケット表記では、中括弧（ &quot;{...}&quot;）ではなく、角括弧（ &quot;[...]&quot;）を使用して、特別に解釈されるセクションに注意します。</target>
        </trans-unit>
        <trans-unit id="7d31b6dcf28abb8afbf24fa97f7391fe87364415" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a like a miniature &quot;template&quot; system (in the sense of &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text::Template&lt;/a&gt;, not in the sense of C++ templates), where normal text is passed thru basically as is, but text in special regions is specially interpreted. In Bracket Notation, you use square brackets (&quot;[...]&quot;), not curly braces (&quot;{...}&quot;) to note sections that are specially interpreted.</source>
          <target state="translated">ブラケット表記は、通常のテキストは基本的にそのまま渡されますが、特別な領域のテキストは特別に解釈される、小さな「テンプレート」システムのようなものです（&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text :: Template&lt;/a&gt;の意味で、C ++テンプレートの意味ではありません）。ブラケット表記では、中括弧（ &quot;{...}&quot;）ではなく角括弧（ &quot;[...]&quot;）を使用して、特別に解釈されるセクションに注意します。</target>
        </trans-unit>
        <trans-unit id="c69ae72aa90270486c045c7a6541cf13d55632e9" translate="yes" xml:space="preserve">
          <source>Bracket Notation is discussed in a later section. Note that trying to compile a string into Bracket Notation can throw an exception if the string is not syntactically valid (say, by not balancing brackets right.)</source>
          <target state="translated">ブラケット記法については後のセクションで説明します。文字列を Bracket Notation にコンパイルしようとすると、文字列が構文的に有効でない場合に例外が発生することに注意してください (例えば、括弧のバランスが正しくない場合など)。</target>
        </trans-unit>
        <trans-unit id="046d4b6cd34c3e66bcd55c31ba3d01db5f8bac76" translate="yes" xml:space="preserve">
          <source>Bracket groups that are empty, or which consist only of whitespace, are ignored. (Examples: &quot;[]&quot;, &quot;[ ]&quot;, or a [ and a ] with returns and/or tabs and/or spaces between them.</source>
          <target state="translated">空であったり、空白のみで構成されているブラケットグループは無視されます。(例。例:&quot;[]&quot;,&quot;[]&quot;、またはリターンやタブやスペースを含む[とa]。</target>
        </trans-unit>
        <trans-unit id="d96a703ba2e31ec739345b11c90028f276d06d37" translate="yes" xml:space="preserve">
          <source>Bracketed Character Classes</source>
          <target state="translated">括弧付き文字クラス</target>
        </trans-unit>
        <trans-unit id="1d6defc184cd831ef1a40a992a7bc00f4a08d7aa" translate="yes" xml:space="preserve">
          <source>Bracketed Character Classes and the /xx pattern modifier</source>
          <target state="translated">ブラケット付き文字クラスと /xx パターン修飾子</target>
        </trans-unit>
        <trans-unit id="56159ead51e4e16a6e6e36a9eba26b713462d135" translate="yes" xml:space="preserve">
          <source>Bracketed Character Classes and the &lt;code&gt;/xx&lt;/code&gt; pattern modifier</source>
          <target state="translated">括弧で囲まれた文字クラスと &lt;code&gt;/xx&lt;/code&gt; パターン修飾子</target>
        </trans-unit>
        <trans-unit id="7fd31d2f7c96c6ebd02a583681a9f9dd8128bde2" translate="yes" xml:space="preserve">
          <source>Bracketed character classes are represented by &lt;code&gt;regnode_charclass&lt;/code&gt; structures, which have a four-byte argument and then a 32-byte (256-bit) bitmap indicating which characters in the Latin1 range are included in the class.</source>
          <target state="translated">&lt;code&gt;regnode_charclass&lt;/code&gt; れた文字クラスは、regnode_charclass構造体で表されます。この構造体には、4バイトの引数があり、次に、クラスに含まれるLatin1範囲の文字を示す32バイト（256ビット）のビットマップがあります。</target>
        </trans-unit>
        <trans-unit id="4f10c5c48b8ce584bf50338e9ce1774e2c591ba3" translate="yes" xml:space="preserve">
          <source>Brackets around a symbolic reference can simply serve to isolate an identifier or variable name from the rest of an expression, just as they always have within a string. For example,</source>
          <target state="translated">記号参照の周りの括弧は、文字列の中では常にそうであるように、識別子や変数名を式の残りの部分から分離するのに役立ちます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="ee4272402a91677e15417810bffa7f99811d776d" translate="yes" xml:space="preserve">
          <source>Brackets must be balanced -- every openbracket must have one matching closebracket, and vice versa. So these are all &lt;b&gt;invalid&lt;/b&gt;:</source>
          <target state="translated">ブラケットはバランスが取れている必要があります。すべてのオープンブラケットには、対応する1つのクローズブラケットが必要です。逆も同様です。したがって、これらはすべて&lt;b&gt;無効&lt;/b&gt;です：</target>
        </trans-unit>
        <trans-unit id="078f4a9c2a661144675f9e2bfab86b75d63064df" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;</source>
          <target state="translated">ブラッド・アップルトン&amp;lt;bradapp@enteract.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="976a94f14824f930d58b9616017f2abefc3253d5" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt; (initial version), Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</source>
          <target state="translated">Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;（初期バージョン）、Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6593228df02466d50b8cc0c36e813c08ba422fcb" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt; (initial version), Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;, Marc Green &amp;lt;marcgreen@cpan.org&amp;gt; (port to Pod::Simple) Ricardo Signes &amp;lt;rjbs@cpan.org&amp;gt; (more porting to Pod::Simple) Karl Williamson &amp;lt;khw@cpan.org&amp;gt; (more porting to Pod::Simple)</source>
          <target state="translated">Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;（初期バージョン）、Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;、Marc Green &amp;lt;marcgreen@cpan.org&amp;gt;（Pod :: Simpleへの移植）Ricardo Signes &amp;lt;rjbs@cpan.org&amp;gt; （Pod :: Simpleへのより多くの移植）Karl Williamson &amp;lt;khw@cpan.org&amp;gt;（Pod :: Simpleへのより多くの移植）</target>
        </trans-unit>
        <trans-unit id="bd85e7290aa8473e575a87a5fd8b95386788c86e" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;, Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</source>
          <target state="translated">Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;、Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ace391da91b3b622751d8ebf145fd4091f241ba4" translate="yes" xml:space="preserve">
          <source>Brad Gilbert &amp;lt;bgills@cpan.org&amp;gt;</source>
          <target state="translated">ブラッド・ギルバート&amp;lt;bgills@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="3ae43dcfe840a5e3a18a13f5b3acd9cb0f221ef8" translate="yes" xml:space="preserve">
          <source>Brandon Browning,</source>
          <target state="translated">ブランドン・ブラウニング</target>
        </trans-unit>
        <trans-unit id="c7ea19e07547da7e5f6a43b6c0892e4265aeebb1" translate="yes" xml:space="preserve">
          <source>Brandon L. Black, &amp;lt;blblack@gmail.com&amp;gt;</source>
          <target state="translated">Brandon L. Black、&amp;lt;blblack@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6fb6fe57c36bfedd5ff6f16a948fc45d01c7d083" translate="yes" xml:space="preserve">
          <source>Branislav Zahradnik &amp;lt;barney@cpan.org&amp;gt;</source>
          <target state="translated">Branislav Zahradnik &amp;lt;barney@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="37497aa5a2272c49714aee1b07e8edf973a95f59" translate="yes" xml:space="preserve">
          <source>Brazil</source>
          <target state="translated">Brazil</target>
        </trans-unit>
        <trans-unit id="eca2fc6f92666147ac6a607129bb8a0811237538" translate="yes" xml:space="preserve">
          <source>Break out of a &lt;code&gt;given()&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;given()&lt;/code&gt; ブロックから抜け出します。</target>
        </trans-unit>
        <trans-unit id="70e84e284b7238bd647c1d2ad9dae3dcf040b2c5" translate="yes" xml:space="preserve">
          <source>Break out of a &lt;code&gt;given&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;given&lt;/code&gt; ブロックから抜け出します。</target>
        </trans-unit>
        <trans-unit id="03d93607f829e7fe2aafd920d3e1c2e3753bb301" translate="yes" xml:space="preserve">
          <source>Break the execution of your program if the module you &lt;code&gt;autouse&lt;/code&gt; d has some initialization which it expects to be done early.</source>
          <target state="translated">&lt;code&gt;autouse&lt;/code&gt; するモジュールdに初期化が必要な初期化がある場合は、プログラムの実行を中断します。</target>
        </trans-unit>
        <trans-unit id="848f64a4802a4e63379bfcaf66c37f0f07a8afee" translate="yes" xml:space="preserve">
          <source>Break the execution of your program if the module you &lt;code&gt;autouse&lt;/code&gt;d has some initialization which it expects to be done early.</source>
          <target state="translated">&lt;code&gt;autouse&lt;/code&gt; するモジュールに、早期に実行されると予想される初期化がある場合は、プログラムの実行を中断します。</target>
        </trans-unit>
        <trans-unit id="75e308eb5b16f38422b4dd55b2c10339c108233c" translate="yes" xml:space="preserve">
          <source>Break up text into lines according to Unicode rules.</source>
          <target state="translated">Unicode の規則に従ってテキストを行に分割します。</target>
        </trans-unit>
        <trans-unit id="5ad0b6bff702cd07f8dbaf1cb4107d1095e60662" translate="yes" xml:space="preserve">
          <source>Break-out the reusable code into one or more separate module files.</source>
          <target state="translated">再利用可能なコードを1つ以上の別々のモジュールファイルに分割します。</target>
        </trans-unit>
        <trans-unit id="f19f6b051659b65527c1cf48996b006f5fcd4db1" translate="yes" xml:space="preserve">
          <source>Breakable lines are marked with &lt;code&gt;:&lt;/code&gt; . Lines with breakpoints are marked by &lt;code&gt;b&lt;/code&gt; and those with actions by &lt;code&gt;a&lt;/code&gt; . The line that's about to be executed is marked by &lt;code&gt;==&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">分割可能な行には次のマークが付いてい &lt;code&gt;:&lt;/code&gt; 。ブレークポイントのある行は &lt;code&gt;b&lt;/code&gt; でマークされ &lt;code&gt;a&lt;/code&gt; アクションのある行はaでマークされます。実行されようとしている行は、 &lt;code&gt;==&amp;gt;&lt;/code&gt; でマークされています。</target>
        </trans-unit>
        <trans-unit id="4cca55190538278526fdb090660eae35486629fc" translate="yes" xml:space="preserve">
          <source>Breakable lines are marked with &lt;code&gt;:&lt;/code&gt;. Lines with breakpoints are marked by &lt;code&gt;b&lt;/code&gt; and those with actions by &lt;code&gt;a&lt;/code&gt;. The line that's about to be executed is marked by &lt;code&gt;==&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">壊れやすい線は &lt;code&gt;:&lt;/code&gt; でマークされています。ブレークポイントのある行は &lt;code&gt;b&lt;/code&gt; でマークされ &lt;code&gt;a&lt;/code&gt; アクションのある行はaでマークされます。実行されようとしている行は &lt;code&gt;==&amp;gt;&lt;/code&gt; でマークされています。</target>
        </trans-unit>
        <trans-unit id="73cb8429b43020f4d84d456449c4c5b228dde417" translate="yes" xml:space="preserve">
          <source>Breaking gettext</source>
          <target state="translated">gettextを壊す</target>
        </trans-unit>
        <trans-unit id="02352bb0ba7c8d9b86acca1b53f9d1e7553bf956" translate="yes" xml:space="preserve">
          <source>Breaking out</source>
          <target state="translated">脱獄</target>
        </trans-unit>
        <trans-unit id="b58f4abd812365aa3e9bf665a84c1fa3c88cdbc5" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a DBM file and a hash.</source>
          <target state="translated">DBMファイルとハッシュの結合を解除します。</target>
        </trans-unit>
        <trans-unit id="fece5a66de93443d7bff991c12beae4eb8074f61" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a variable and a package. (See &lt;a href=&quot;#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt;tie&lt;/a&gt;.) Has no effect if the variable is not tied.</source>
          <target state="translated">変数とパッケージの間のバインディングを解除します。（&lt;a href=&quot;#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt;同点を&lt;/a&gt;参照してください。）変数が同点でない場合は効果がありません。</target>
        </trans-unit>
        <trans-unit id="4964084eb3d73be96dd1eeb1af8495c4dc61d5f9" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a variable and a package. (See &lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;tie&lt;/a&gt;.) Has no effect if the variable is not tied.</source>
          <target state="translated">変数とパッケージの間のバインディングを解除します。（&lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;tieを&lt;/a&gt;参照してください。）変数が関連付けられていない場合、効果はありません。</target>
        </trans-unit>
        <trans-unit id="ebcffdb904889257c266769aa18189925f0f7c13" translate="yes" xml:space="preserve">
          <source>Brent Powers has a &lt;code&gt;Memoize::ExpireLRU&lt;/code&gt; module that was designed to work with Memoize and provides expiration of least-recently-used data. The cache is held at a fixed number of entries, and when new data comes in, the least-recently used data is expired. See &lt;a href=&quot;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&quot;&gt;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&lt;/a&gt;.</source>
          <target state="translated">Brent Powersには &lt;code&gt;Memoize::ExpireLRU&lt;/code&gt; モジュールがあり、Memoizeで動作するように設計されており、最近使用されていないデータの有効期限を提供します。キャッシュは一定数のエントリで保持され、新しいデータが入ると、最も最近使用されたデータが期限切れになります。&lt;a href=&quot;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&quot;&gt;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRUを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c27cf707cf417ff0a776233c5044d0c0f1f7ca1a" translate="yes" xml:space="preserve">
          <source>Brian Fraser &amp;lt;fraserbn@gmail.com&amp;gt;</source>
          <target state="translated">ブライアンフレイザー&amp;lt;fraserbn@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1f48c0d1bc27a1a6d3322c34a40dc48ed4836827" translate="yes" xml:space="preserve">
          <source>Brian Mowrey &amp;lt;brian@drlabs.org&amp;gt;</source>
          <target state="translated">ブライアン・モーリー&amp;lt;brian@drlabs.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d67acd53896f7915d6e2dc925e202a5731fc6800" translate="yes" xml:space="preserve">
          <source>Briefly, &lt;code&gt;/l&lt;/code&gt; sets the character set to that of whatever &lt;b&gt;L&lt;/b&gt;ocale is in effect at the time of the execution of the pattern match.</source>
          <target state="translated">簡単に言うには、 &lt;code&gt;/l&lt;/code&gt; は何のそれに文字セットを設定し、&lt;b&gt;L&lt;/b&gt; ocaleは、パターンマッチを実行する際に有効です。</target>
        </trans-unit>
        <trans-unit id="617a3fbf545ee5333943d4e71b255277bef3b51a" translate="yes" xml:space="preserve">
          <source>Broadcast =&amp;gt; BOOL</source>
          <target state="translated">ブロードキャスト=&amp;gt; BOOL</target>
        </trans-unit>
        <trans-unit id="4f1d6e87ca75e40a64b990a2d32b737b491cbea9" translate="yes" xml:space="preserve">
          <source>Broadly speaking, performing a match of a string against a pattern involves the following steps:</source>
          <target state="translated">大まかに言えば、パターンに対する文字列のマッチを実行するには、次のような手順があります。</target>
        </trans-unit>
        <trans-unit id="b0f84539efd4151eb704c02dcc4f761c1702c86d" translate="yes" xml:space="preserve">
          <source>Broken systems</source>
          <target state="translated">壊れたシステム</target>
        </trans-unit>
        <trans-unit id="1def5ba77699f04961452989de376f438210ae2b" translate="yes" xml:space="preserve">
          <source>Bucket Order Perturbance</source>
          <target state="translated">バケットオーダーの摂動</target>
        </trans-unit>
        <trans-unit id="d93b6657484eea5e944049ac0b3ddce1a19d87f5" translate="yes" xml:space="preserve">
          <source>Buffer overflow in prime_env_iter: %s</source>
          <target state="translated">prime_env_iter でのバッファオーバーフロー:%s</target>
        </trans-unit>
        <trans-unit id="fe6990bb386cb0f2d9d5ad6fab5909ce4fbcb2fd" translate="yes" xml:space="preserve">
          <source>Buffer scalar containing the chunk currently under consideration of the text currently being lexed. This is always a plain string scalar (for which &lt;code&gt;SvPOK&lt;/code&gt; is true). It is not intended to be used as a scalar by normal scalar means; instead refer to the buffer directly by the pointer variables described below.</source>
          <target state="translated">現在字句解析されているテキストを現在検討しているチャンクを含むバッファースカラー。これは常にプレーンな文字列スカラーです（ &lt;code&gt;SvPOK&lt;/code&gt; がtrueの場合）。通常のスカラー手段によるスカラーとしての使用は意図されていません。代わりに、以下で説明するポインタ変数によってバッファを直接参照してください。</target>
        </trans-unit>
        <trans-unit id="aaf695eeaf0754918bfdf3c63ed153867d69dfcf" translate="yes" xml:space="preserve">
          <source>Bug reports and other feedback are most welcome.</source>
          <target state="translated">バグ報告やその他のフィードバックは大歓迎です。</target>
        </trans-unit>
        <trans-unit id="4a6ed58e35768beb4922face36916e3eb34ceb32" translate="yes" xml:space="preserve">
          <source>Bug reports should be submitted to the GitHub issue tracker at &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;. The &lt;b&gt;perlbug@perl.org&lt;/b&gt; address no longer automatically opens tickets. You can use this tool to compose your report and save it to a file which you can then submit to the issue tracker.</source>
          <target state="translated">バグレポートは、&lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https：//github.com/Perl/perl5/issuesの&lt;/a&gt;GitHub課題追跡システムに送信する必要があります。&lt;b&gt;perlbug@perl.org&lt;/b&gt;アドレスは、もはや自動的にチケットを開きません。このツールを使用してレポートを作成し、ファイルに保存して、問題追跡システムに送信できます。</target>
        </trans-unit>
        <trans-unit id="f3dfa0b6c5b9a870507e0243e43fe93803edb544" translate="yes" xml:space="preserve">
          <source>Bug reports, patches, and nagging provided by lots of folks-- thanks everybody! Special thanks to Michael Schwern &amp;lt;schwern@envirolink.org&amp;gt; for assuring me that a &amp;amp;nested_quotewords() would be useful, and to Jeff Friedl &amp;lt;jfriedl@yahoo-inc.com&amp;gt; for telling me not to worry about error-checking (sort of-- you had to be there).</source>
          <target state="translated">多くの人々から提供されたバグレポート、パッチ、およびしつこい-すべての人に感謝！＆nested_quotewords（）が有用であることを保証してくれたMichael Schwern &amp;lt;schwern@envirolink.org&amp;gt;と、エラーチェックを心配しないように言ってくれたJeff Friedl &amp;lt;jfriedl@yahoo-inc.com&amp;gt;に特に感謝します（ある種の-あなたはそこにいなければなりませんでした）。</target>
        </trans-unit>
        <trans-unit id="829fe5647d6ef5dc40cbf31334f7d303909516a7" translate="yes" xml:space="preserve">
          <source>Bug-fixing by Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt; 2010-2011.</source>
          <target state="translated">Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt; 2010-2011によるバグ修正。</target>
        </trans-unit>
        <trans-unit id="238715da3b418db89372b9015297a37b9b381344" translate="yes" xml:space="preserve">
          <source>Bug-fixing by Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt; 2010-2016.</source>
          <target state="translated">Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt; 2010-2016によるバグ修正。</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="60757698bb42548c3dda76e0d4ec377b0dd06d65" translate="yes" xml:space="preserve">
          <source>Bugs (and requests for new features) can be reported to the author though GitHub: &lt;a href=&quot;https://github.com/Test-More/test-more/issues&quot;&gt;https://github.com/Test-More/test-more/issues&lt;/a&gt;</source>
          <target state="translated">バグ（および新機能のリクエスト）は、GitHubを通じて作成者に報告できます：&lt;a href=&quot;https://github.com/Test-More/test-more/issues&quot;&gt;https&lt;/a&gt;：//github.com/Test-More/test-more/issues</target>
        </trans-unit>
        <trans-unit id="5f308ba7fc80d9c9a972b67a64671b669a27d16c" translate="yes" xml:space="preserve">
          <source>Bugs (and requests for new features) can be reported to the author though the CPAN RT system: &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&lt;/a&gt;</source>
          <target state="translated">バグ（および新機能のリクエスト）は、CPAN RTシステムを通じて作成者に報告できます&lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&quot;&gt;。http&lt;/a&gt;：//rt.cpan.org/NoAuth/ReportBug.html？Queue = Test-Builder-Tester</target>
        </trans-unit>
        <trans-unit id="888b6006f2872d22aaa1cd6bce9e12ccb31d9655" translate="yes" xml:space="preserve">
          <source>Bugs / Feature Requests</source>
          <target state="translated">バグ/機能リクエスト</target>
        </trans-unit>
        <trans-unit id="58d170e283eb8eb2d13abdce7bd1aa5026377f10" translate="yes" xml:space="preserve">
          <source>Bugs may be submitted at &lt;a href=&quot;https://github.com/houseabsolute/Time-Local/issues&quot;&gt;https://github.com/houseabsolute/Time-Local/issues&lt;/a&gt;.</source>
          <target state="translated">バグは&lt;a href=&quot;https://github.com/houseabsolute/Time-Local/issues&quot;&gt;https://github.com/houseabsolute/Time-Local/issues&lt;/a&gt;で送信できます。</target>
        </trans-unit>
        <trans-unit id="a450dc1be8865ad9e376ea507387ccd3c0e65886" translate="yes" xml:space="preserve">
          <source>Bugs may be submitted through &lt;a href=&quot;https://rt.cpan.org/Public/Dist/Display.html?Name=File-Temp&quot;&gt;the RT bug tracker&lt;/a&gt; (or &lt;a href=&quot;mailto:bug-File-Temp@rt.cpan.org&quot;&gt;bug-File-Temp@rt.cpan.org&lt;/a&gt;).</source>
          <target state="translated">バグは&lt;a href=&quot;https://rt.cpan.org/Public/Dist/Display.html?Name=File-Temp&quot;&gt;、RTバグトラッカー&lt;/a&gt;（または&lt;a href=&quot;mailto:bug-File-Temp@rt.cpan.org&quot;&gt;bug-File-Temp@rt.cpan.org&lt;/a&gt;）から送信できます。</target>
        </trans-unit>
        <trans-unit id="147820deb7b5b2f1e33d540237db5f728a826fed" translate="yes" xml:space="preserve">
          <source>Bugs may be submitted through &lt;a href=&quot;https://rt.cpan.org/Public/Dist/Display.html?Name=Module-Metadata&quot;&gt;the RT bug tracker&lt;/a&gt; (or &lt;a href=&quot;mailto:bug-Module-Metadata@rt.cpan.org&quot;&gt;bug-Module-Metadata@rt.cpan.org&lt;/a&gt;).</source>
          <target state="translated">バグは&lt;a href=&quot;https://rt.cpan.org/Public/Dist/Display.html?Name=Module-Metadata&quot;&gt;、RTバグトラッカー&lt;/a&gt;（または&lt;a href=&quot;mailto:bug-Module-Metadata@rt.cpan.org&quot;&gt;bug-Module-Metadata@rt.cpan.org&lt;/a&gt;）から送信できます。</target>
        </trans-unit>
        <trans-unit id="798e9f12ff638512bcd89953d3735c6b7ab1cee3" translate="yes" xml:space="preserve">
          <source>Bugs you don't plan to fix. :-)</source>
          <target state="translated">直すつもりのないバグ。)</target>
        </trans-unit>
        <trans-unit id="bbd80cf7e2ded5efed8f4ee9151ab57a8ab66392" translate="yes" xml:space="preserve">
          <source>Build</source>
          <target state="translated">Build</target>
        </trans-unit>
        <trans-unit id="a3c79824d95086093512b52d7ab25ad53dd0d923" translate="yes" xml:space="preserve">
          <source>Build Anomalies with Perl on OS/390</source>
          <target state="translated">OS/390でPerlを使って異常値をビルドする</target>
        </trans-unit>
        <trans-unit id="8197039c73f48aefe4687141c68ac9ca58ef8d5e" translate="yes" xml:space="preserve">
          <source>Build FAQ</source>
          <target state="translated">ビルドFAQ</target>
        </trans-unit>
        <trans-unit id="4f1a5b2e8fc6f3c96b77575a0eaa73b7619bef70" translate="yes" xml:space="preserve">
          <source>Build Prerequisites for Perl on AmigaOS</source>
          <target state="translated">AmigaOS上でPerlをビルドするための前提条件</target>
        </trans-unit>
        <trans-unit id="431713be1df25e40d76ce4972f5897bc2ac46f53" translate="yes" xml:space="preserve">
          <source>Build an iterator which finds distroprefs files in the tree below the given directory. Within the tree directories matching &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m/^[._]/&lt;/a&gt;&lt;/code&gt; are pruned.</source>
          <target state="translated">指定されたディレクトリの下のツリーでdistroprefsファイルを見つけるイテレータを構築します。ツリー内では、 &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m/^[._]/&lt;/a&gt;&lt;/code&gt; 一致するディレクトリが整理されます。</target>
        </trans-unit>
        <trans-unit id="1f5e8d7b401e7067eefc5a283830fcc846d1ee9e" translate="yes" xml:space="preserve">
          <source>Build an iterator which finds distroprefs files in the tree below the given directory. Within the tree directories matching &lt;code&gt;m/^[._]/&lt;/code&gt; are pruned.</source>
          <target state="translated">指定されたディレクトリの下のツリーでdistroprefsファイルを見つけるイテレータを作成します。ツリーディレクトリ内で、 &lt;code&gt;m/^[._]/&lt;/code&gt; 一致するものが削除されます。</target>
        </trans-unit>
        <trans-unit id="39f0d013521af98c935739685e85fd389eb57d10" translate="yes" xml:space="preserve">
          <source>Build hash based classes.</source>
          <target state="translated">ハッシュベースのクラスを構築します。</target>
        </trans-unit>
        <trans-unit id="025fef91894be2ceb7f450be64f484f9a3dfd148" translate="yes" xml:space="preserve">
          <source>Build instructions for OS/2, &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;</source>
          <target state="translated">OS / 2、&lt;a href=&quot;perlos2&quot;&gt;perlos2の&lt;/a&gt;ビルド手順</target>
        </trans-unit>
        <trans-unit id="6a0c26b6e73b4a14e003052fbfb474ae81ddeb3d" translate="yes" xml:space="preserve">
          <source>Build instructions for Win32 in &lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt;, or under the Cygnus environment in &lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt;.</source>
          <target state="translated">でWin32用のビルド命令&lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt;、または中Cygnusの環境下&lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec272960803bf0c1141ddb2cc450b8e7bb399d9c" translate="yes" xml:space="preserve">
          <source>Build man pages, too</source>
          <target state="translated">マンページも構築</target>
        </trans-unit>
        <trans-unit id="6e79e48e57f84dbe7fa157bde2a3fead704bb75d" translate="yes" xml:space="preserve">
          <source>Build system</source>
          <target state="translated">ビルドシステム</target>
        </trans-unit>
        <trans-unit id="857fee8f38d36d4d66b3ca310ad74ff4223ccbe4" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the UTF-8 encoded string &lt;code&gt;spv&lt;/code&gt;, length &lt;code&gt;len&lt;/code&gt;, the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &lt;code&gt;&quot;...&quot;&lt;/code&gt; will be appended).</source>
          <target state="translated">スカラー &lt;code&gt;dsv&lt;/code&gt; に、UTF-8でエンコードされた文字列 &lt;code&gt;spv&lt;/code&gt; 、長さ &lt;code&gt;len&lt;/code&gt; の表示可能なバージョンを &lt;code&gt;pvlim&lt;/code&gt; ます。表示可能なバージョンは、最大でpvlimバイトの長さです（それより長い場合、残りは切り捨てられ、 &lt;code&gt;&quot;...&quot;&lt;/code&gt; が追加されます）。</target>
        </trans-unit>
        <trans-unit id="f324587551677d6f64a6a55d81e5c02c33aaa350" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the scalar &lt;code&gt;sv&lt;/code&gt; , the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="translated">スカラー &lt;code&gt;dsv&lt;/code&gt; にスカラー &lt;code&gt;sv&lt;/code&gt; の表示可能なバージョンを &lt;code&gt;pvlim&lt;/code&gt; ます。表示可能なバージョンは最大でpvlimバイトの長さです（長い場合、残りは切り捨てられ、「...」が追加されます）。</target>
        </trans-unit>
        <trans-unit id="46af0313d23f0c460bfa1f3a9e5387975e8b2b74" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the scalar &lt;code&gt;sv&lt;/code&gt;, the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="translated">スカラー &lt;code&gt;dsv&lt;/code&gt; にスカラー &lt;code&gt;sv&lt;/code&gt; の表示可能なバージョンを &lt;code&gt;pvlim&lt;/code&gt; ます。表示可能なバージョンの長さは最大でpvlimバイトです（それより長い場合、残りは切り捨てられ、「...」が追加されます）。</target>
        </trans-unit>
        <trans-unit id="cc42dbdb87c5e71f504c4dbe80214e6754c41fcb" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the string &lt;code&gt;spv&lt;/code&gt; , length &lt;code&gt;len&lt;/code&gt; , the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="translated">スカラー &lt;code&gt;dsv&lt;/code&gt; に、文字列 &lt;code&gt;spv&lt;/code&gt; 、長さ &lt;code&gt;len&lt;/code&gt; の表示可能なバージョンを &lt;code&gt;pvlim&lt;/code&gt; ます。表示可能なバージョンは最大でpvlimバイトの長さです（長い場合、残りは切り捨てられ、「...」が追加されます）。</target>
        </trans-unit>
        <trans-unit id="c6bd3f51881e4d26f104fbcd7a9347aa8d6d5282" translate="yes" xml:space="preserve">
          <source>Build, Configure, Make, Install</source>
          <target state="translated">ビルド、設定、作成、インストール</target>
        </trans-unit>
        <trans-unit id="4c215cd495fbe90044cc607bb79e970dde2b9028" translate="yes" xml:space="preserve">
          <source>Build, Test, Install Perl on OS/390</source>
          <target state="translated">OS/390でのPerlのビルド、テスト、インストール</target>
        </trans-unit>
        <trans-unit id="249199540ceee6ec6b4a1f1daa24666f4aa042eb" translate="yes" xml:space="preserve">
          <source>Build.PL</source>
          <target state="translated">Build.PL</target>
        </trans-unit>
        <trans-unit id="4759bf14d7a511508e86c343c934894b6e8db533" translate="yes" xml:space="preserve">
          <source>Builder</source>
          <target state="translated">Builder</target>
        </trans-unit>
        <trans-unit id="52b5e661f9ecf45eed9a8b41756d5844802fbce9" translate="yes" xml:space="preserve">
          <source>Builder class for Windows platforms</source>
          <target state="translated">Windows プラットフォーム用ビルダークラス</target>
        </trans-unit>
        <trans-unit id="9d914bfcf1c5bc9e6b83d3232349cae23d392f30" translate="yes" xml:space="preserve">
          <source>Building</source>
          <target state="translated">Building</target>
        </trans-unit>
        <trans-unit id="2ed0dadcc70796d33055d55283657d04fb0c039a" translate="yes" xml:space="preserve">
          <source>Building 32-bit Perl in Irix</source>
          <target state="translated">Irixで32ビットPerlを構築する</target>
        </trans-unit>
        <trans-unit id="977f968c44ef127f7e68a4bbd06a3bc09d574a03" translate="yes" xml:space="preserve">
          <source>Building 64-bit Perl in Irix</source>
          <target state="translated">Irixでの64ビットPerlの構築</target>
        </trans-unit>
        <trans-unit id="a68801656d21c1742976b2a26b0d97ca179190db" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on AIX</source>
          <target state="translated">AIX上での動的拡張機能の構築</target>
        </trans-unit>
        <trans-unit id="cdc5004f31232806335a1cd820513add0b5ef95f" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on AIX &amp;lt; 5L</source>
          <target state="translated">AIX &amp;lt;5Lでの動的拡張の構築</target>
        </trans-unit>
        <trans-unit id="60eeab40d6adc2fe265d128c48b6aa4e93a2fcb8" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on HP-UX</source>
          <target state="translated">HP-UX上での動的拡張機能の構築</target>
        </trans-unit>
        <trans-unit id="e3d2578989b066f6d4e0e3d492f28b294aef6801" translate="yes" xml:space="preserve">
          <source>Building Extensions</source>
          <target state="translated">建物の拡張</target>
        </trans-unit>
        <trans-unit id="2cca0ab4039ae032282d3c4fa53d7e82995e8594" translate="yes" xml:space="preserve">
          <source>Building Non-XS Modules on DOS</source>
          <target state="translated">DOS上での非XSモジュールの構築</target>
        </trans-unit>
        <trans-unit id="e58f39330e280e7de8b3b247f8f97aeb868e7743" translate="yes" xml:space="preserve">
          <source>Building Perl for WinCE</source>
          <target state="translated">WinCE用のPerlの構築</target>
        </trans-unit>
        <trans-unit id="9e84e0a9f11037f0b7fccbdd30b3def3e1270535" translate="yes" xml:space="preserve">
          <source>Building Perl on DOS</source>
          <target state="translated">DOS上でのPerlの構築</target>
        </trans-unit>
        <trans-unit id="107439a62a7c6f42562b678d76f2e80c36c5eb66" translate="yes" xml:space="preserve">
          <source>Building Prerequisites for Perl on DOS</source>
          <target state="translated">DOS上でPerlの前提条件を構築する</target>
        </trans-unit>
        <trans-unit id="b5ced49870fdf0851779593a86211e669aed437d" translate="yes" xml:space="preserve">
          <source>Building XS Modules on DOS</source>
          <target state="translated">DOS上でのXSモジュールの構築</target>
        </trans-unit>
        <trans-unit id="16ea3711da90cdc1ad8b70bb59bd87c31033d7af" translate="yes" xml:space="preserve">
          <source>Building a 64-bit capable gcc on PA-RISC from source is possible only when you have the HP C-ANSI C compiler or an already working 64-bit binary of gcc available. Best performance for perl is achieved with HP's native compiler.</source>
          <target state="translated">PA-RISC上で64ビット対応のgccをソースからビルドするには、HP C-ANSI Cコンパイラか、すでに動作している64ビットのgccバイナリがある場合にのみ可能です。perl の最高のパフォーマンスは HP のネイティブコンパイラで達成されます。</target>
        </trans-unit>
        <trans-unit id="b06d77f19e3d0e1947de8d417eb97b9240aba5fe" translate="yes" xml:space="preserve">
          <source>Building a binary distribution</source>
          <target state="translated">二値分布の構築</target>
        </trans-unit>
        <trans-unit id="5eaf641b2cc432d339298d2d7667c55e1df71877" translate="yes" xml:space="preserve">
          <source>Building a regexp</source>
          <target state="translated">正規表現の構築</target>
        </trans-unit>
        <trans-unit id="4f3097c147e745c265a4f8606c6e810a7ad5d9f4" translate="yes" xml:space="preserve">
          <source>Building an LP64 perl</source>
          <target state="translated">LP64 perl のビルド</target>
        </trans-unit>
        <trans-unit id="d601de14ddca518b95c2c6d816b3b797646fe162" translate="yes" xml:space="preserve">
          <source>Building custom</source>
          <target state="translated">カスタムの構築</target>
        </trans-unit>
        <trans-unit id="38b3b94607428da1a192459760b9b24f29336537" translate="yes" xml:space="preserve">
          <source>Building custom .EXE files</source>
          <target state="translated">カスタム .EXE ファイルの作成</target>
        </trans-unit>
        <trans-unit id="94d1d0131bb7b5bab11d8fd5a13a49d41b119105" translate="yes" xml:space="preserve">
          <source>Building custom _.EXE_ files</source>
          <target state="translated">カスタム_.EXE_ファイルの作成</target>
        </trans-unit>
        <trans-unit id="e10bbd8c13474666bee2a919ca9d0cf777bfbdb2" translate="yes" xml:space="preserve">
          <source>Building debugging-enabled binaries (with -g or -g3) will increase the chance of getting these errors. Prevent -g if possible.</source>
          <target state="translated">デバッグ可能なバイナリを (-g や -g3 で)ビルドすると、これらのエラーが発生する可能性が高くなります。可能であれば -g を使用しないようにしてください。</target>
        </trans-unit>
        <trans-unit id="60333d2c51f8933ea40f3711d31effe77527e1a4" translate="yes" xml:space="preserve">
          <source>Building perl at older commits</source>
          <target state="translated">古いコミットでの perl のビルド</target>
        </trans-unit>
        <trans-unit id="58685fabffe8d566dcf90fc429e9988b44fb72cb" translate="yes" xml:space="preserve">
          <source>Building should proceed differently depending on whether the version of perl you install is already present and used on your system, or is a new version not yet used. The description below assumes that the version is new, so installing its DLLs and</source>
          <target state="translated">インストールするperlのバージョンが既に存在し、システム上で使用されているのか、それともまだ使用されていない新しいバージョンなのかによって、ビルドの進め方が異なるはずです。以下の説明では、そのバージョンが新しいものであることを前提としていますので、そのDLLや</target>
        </trans-unit>
        <trans-unit id="25399d44a6d52942b965d7741dfbe5b98c44e3b6" translate="yes" xml:space="preserve">
          <source>Building with threads in Irix</source>
          <target state="translated">Irixでスレッドを使ったビルド</target>
        </trans-unit>
        <trans-unit id="c882cff5cf66c8bc0ee9d0ac391aee6b3e4faba4" translate="yes" xml:space="preserve">
          <source>Buildtype.bat</source>
          <target state="translated">Buildtype.bat</target>
        </trans-unit>
        <trans-unit id="167534462e1810e98824021557fb475fd2cb9f52" translate="yes" xml:space="preserve">
          <source>Built-in Attributes</source>
          <target state="translated">ビルトイン属性</target>
        </trans-unit>
        <trans-unit id="03c641eb4ff3905fcf16d5ff9fd329806e0d8127" translate="yes" xml:space="preserve">
          <source>Built-in Encodings</source>
          <target state="translated">内蔵エンコーディング</target>
        </trans-unit>
        <trans-unit id="a254cda26c62367280124a0a97ba97ac0047a0c1" translate="yes" xml:space="preserve">
          <source>Builtin operators and functions</source>
          <target state="translated">組み込みの演算子と機能</target>
        </trans-unit>
        <trans-unit id="82bac8de7c475e9a140fc89ca8b2ed3375482576" translate="yes" xml:space="preserve">
          <source>Builtin types include:</source>
          <target state="translated">ビルトインタイプが含まれています。</target>
        </trans-unit>
        <trans-unit id="5c77726358c5daf98ad9cdccd0882bca0f718b88" translate="yes" xml:space="preserve">
          <source>Bulgaria</source>
          <target state="translated">Bulgaria</target>
        </trans-unit>
        <trans-unit id="572f7127eed71e662d147110ecd2618b7d80c972" translate="yes" xml:space="preserve">
          <source>Bultibuffer count</source>
          <target state="translated">マルチバッファー数</target>
        </trans-unit>
        <trans-unit id="56c511a735d99d5e1aad2b7d21a4ed9e5dff3aca" translate="yes" xml:space="preserve">
          <source>Bumped version.</source>
          <target state="translated">バンプ版。</target>
        </trans-unit>
        <trans-unit id="fbadec79c760a0615a7745522920ce54712b347a" translate="yes" xml:space="preserve">
          <source>Bundle/Snapshot_2012_05_21_00.pm</source>
          <target state="translated">Bundle/Snapshot_2012_05_21_00.pm</target>
        </trans-unit>
        <trans-unit id="c1d562515d11cd030821deea9c673716499b48ca" translate="yes" xml:space="preserve">
          <source>Bundled Encode::Locale</source>
          <target state="translated">バンドルされた Encode::Locale</target>
        </trans-unit>
        <trans-unit id="9a033a116a34993104733ddb8e62da3f808f4b18" translate="yes" xml:space="preserve">
          <source>Bundles</source>
          <target state="translated">Bundles</target>
        </trans-unit>
        <trans-unit id="57402f7215532c14b5a4891e2bc99d5f27572992" translate="yes" xml:space="preserve">
          <source>Bundles are treated specially in the CPAN package. If you say 'install Bundle::Tkkit' (assuming such a bundle exists), CPAN will install all the modules in the CONTENTS section of the pod. You can install your own Bundles locally by placing a conformant Bundle file somewhere into your @INC path. The autobundle() command which is available in the shell interface does that for you by including all currently installed modules in a snapshot bundle file.</source>
          <target state="translated">バンドルはCPANパッケージ内で特別に扱われます。install Bundle::Tkkit」と言うと(そのようなバンドルが存在すると仮定して)、CPANはポッドのCONTENTSセクションにあるすべてのモジュールをインストールします。適合するBundleファイルを@INCパスのどこかに置くことで、独自のBundleをローカルにインストールすることができます。シェルインターフェイスで利用できるautobundle()コマンドは、現在インストールされているすべてのモジュールをスナップショットバンドルファイルに含めることで、これを代行してくれる。</target>
        </trans-unit>
        <trans-unit id="654a81f2d3a7234ab3c1e3ba078dd1e95b9d8acf" translate="yes" xml:space="preserve">
          <source>Bundling</source>
          <target state="translated">Bundling</target>
        </trans-unit>
        <trans-unit id="d01b7bc2d8bcb3e8147c5617d5cc44c01b525846" translate="yes" xml:space="preserve">
          <source>But</source>
          <target state="translated">But</target>
        </trans-unit>
        <trans-unit id="4409f482ed69df6dea8ad78ddaf1fc21ee472c98" translate="yes" xml:space="preserve">
          <source>But (for the foreseeable future), Pod does not provide any way for Pod authors to distinguish which grouping is meant by the above &quot;=item&quot;-cluster structure. So formatters should format it like so:</source>
          <target state="translated">しかし、(当面の間は)Podは、Podの作者が上記の&quot;=item &quot;クラスタ構造がどのグループ化を意味するのかを区別する方法を提供していません。そのため、フォーマッタは以下のようにフォーマットする必要があります。</target>
        </trans-unit>
        <trans-unit id="90e0c4e431de8ceb3ea88d2476b9cdf6b06e1777" translate="yes" xml:space="preserve">
          <source>But I consider that somewhat of a distraction from the work of getting the main code working -- to say nothing of the fact that I often have to play with the program a few times before I can decide exactly what wording I want in the messages (which in this case would require me to go changing three lines of code: the call to maketext with that key, and then the two lines in ThisProject/I18N/en.pm).</source>
          <target state="translated">しかし、それはメインコードを動作させる作業の気晴らしになると思っています --メッセージの中の言葉遣いを正確に決めるためには、プログラムを何度か弄らなければならないことが多いという事実は言うまでもありません (この場合、3行のコードを変更する必要があります:そのキーを使った maketext への呼び出し、そして ThisProject/I18N/ja.pm の 2行です)。</target>
        </trans-unit>
        <trans-unit id="68ec332e5b845e28e04fd0941baf17f046ea1744" translate="yes" xml:space="preserve">
          <source>But Perl treats &lt;code&gt;\n&lt;/code&gt; as the start- and end-line delimiter, whereas Unicode specifies more characters that should be so-interpreted.</source>
          <target state="translated">ただし、Perlは &lt;code&gt;\n&lt;/code&gt; を開始行と終了行の区切り文字として扱いますが、Unicodeはそのように解釈する必要のあるより多くの文字を指定します。</target>
        </trans-unit>
        <trans-unit id="ab00dd7d452b56d9f0d69d34971f4ee775260627" translate="yes" xml:space="preserve">
          <source>But Unicode's intent is to unify the existing character set standards and practices, and several pre-existing standards have single characters that mean the same thing as some of these combinations, like ISO-8859-1, which has quite a few of them. For example, &lt;code&gt;&quot;LATIN CAPITAL LETTER E
WITH ACUTE&quot;&lt;/code&gt; was already in this standard when Unicode came along. Unicode therefore added it to its repertoire as that single character. But this character is considered by Unicode to be equivalent to the sequence consisting of the character &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; followed by the character &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt; .</source>
          <target state="translated">しかし、Unicodeの目的は、既存の文字セットの標準と慣行を統一することであり、既存の標準には、これらの組み合わせのいくつかと同じ意味を持つ単一の文字があります。たとえば、Unicodeが登場したとき、 &lt;code&gt;&quot;LATIN CAPITAL LETTER E WITH ACUTE&quot;&lt;/code&gt; はすでにこの標準にありました。したがって、ユニコードはそれをその単一文字としてレパートリーに追加しました。ただし、この文字はUnicode によって、文字 &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt; &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; それに続く文字「複合アクセント」で構成されるシーケンスと同等であると見なされます。</target>
        </trans-unit>
        <trans-unit id="cc372f6b713e0d837f8396fac1cbf07d86470ffa" translate="yes" xml:space="preserve">
          <source>But Unicode's intent is to unify the existing character set standards and practices, and several pre-existing standards have single characters that mean the same thing as some of these combinations, like ISO-8859-1, which has quite a few of them. For example, &lt;code&gt;&quot;LATIN CAPITAL LETTER E WITH ACUTE&quot;&lt;/code&gt; was already in this standard when Unicode came along. Unicode therefore added it to its repertoire as that single character. But this character is considered by Unicode to be equivalent to the sequence consisting of the character &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; followed by the character &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt;.</source>
          <target state="translated">しかし、Unicodeの目的は、既存の文字セットの標準と慣行を統合することであり、いくつかの既存の標準には、ISO-8859-1のように、それらの組み合わせのいくつかと同じことを意味する単一の文字があります。たとえば、 &lt;code&gt;&quot;LATIN CAPITAL LETTER E WITH ACUTE&quot;&lt;/code&gt; は、Unicodeが登場したときにすでにこの標準に含まれていました。したがって、Unicodeはそれをその単一文字としてレパートリーに追加しました。ただし、Unicodeでは、この文字は、文字 &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt; 」の後に文字「COMBININGACUTEACCENT 」が続くシーケンスと同等であると見なされます。</target>
        </trans-unit>
        <trans-unit id="5e01ae5e7eb5b2bd27e52f97c45f989f3f7c27c0" translate="yes" xml:space="preserve">
          <source>But a warning is in order. When using the following to make a copy of a number, only a shallow copy will be made.</source>
          <target state="translated">しかし、注意事項があります。以下のような使い方をして数字のコピーをすると、浅いコピーしかできません。</target>
        </trans-unit>
        <trans-unit id="402f2e961d9afb45626c390dcfdcf325381214c3" translate="yes" xml:space="preserve">
          <source>But any modifiers will still apply to all the components:</source>
          <target state="translated">しかし、すべての修飾子はすべてのコンポーネントに適用されます。</target>
        </trans-unit>
        <trans-unit id="066f97bc3c6fb6f4f0d1613419193dc5c411fa60" translate="yes" xml:space="preserve">
          <source>But as you might well imagine, this can get pretty rough on the reader.</source>
          <target state="translated">しかし、あなたがよく想像するように、これは読者にかなり荒れる可能性があります。</target>
        </trans-unit>
        <trans-unit id="52f632f5c831c8135e210771e0889bbe7f7800a2" translate="yes" xml:space="preserve">
          <source>But assignment of weight for CJK unified ideographs in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed explicitly as the value for this key, weights for CJK unified ideographs are treated as undefined. However when &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8, &lt;code&gt;(overrideCJK =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; has no special meaning.</source>
          <target state="translated">ただし、 &lt;code&gt;table&lt;/code&gt; または &lt;code&gt;entry&lt;/code&gt; CJK統一表意文字の重みの割り当ては引き続き有効です。 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; がこのキーの値として明示的に渡される場合、CJK統一表意文字の重みは未定義として扱われます。ただし、 &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8の場合 &lt;code&gt;(overrideCJK =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; には特別な意味はありません。</target>
        </trans-unit>
        <trans-unit id="3d36eb62a097e882438bf9a3637e15c6d9e493e5" translate="yes" xml:space="preserve">
          <source>But assignment of weight for CJK unified ideographs in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid. If &lt;code&gt;undef&lt;/code&gt; is passed explicitly as the value for this key, weights for CJK unified ideographs are treated as undefined. However when &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8, &lt;code&gt;(overrideCJK =&amp;gt; undef)&lt;/code&gt; has no special meaning.</source>
          <target state="translated">ただし、 &lt;code&gt;table&lt;/code&gt; または &lt;code&gt;entry&lt;/code&gt; でのCJK統合漢字の重みの割り当ては引き続き有効です。場合 &lt;code&gt;undef&lt;/code&gt; このキーの値として明示的に渡され、CJK統合漢字のための重みは未定義として扱われます。ただし、 &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8の場合 &lt;code&gt;(overrideCJK =&amp;gt; undef)&lt;/code&gt; は特別な意味はありません。</target>
        </trans-unit>
        <trans-unit id="c1e716943619b45aa9ba23cbbf0f24483f934af2" translate="yes" xml:space="preserve">
          <source>But be quite sure that &lt;code&gt;ok&lt;/code&gt; is called exactly as many times in the first block as &lt;code&gt;skip&lt;/code&gt; is called in the second block.</source>
          <target state="translated">ただし、2番目のブロックで &lt;code&gt;skip&lt;/code&gt; が呼び出されるのと同じように、最初のブロックで &lt;code&gt;ok&lt;/code&gt; が正確に何度も呼び出されることを十分に確認してください。</target>
        </trans-unit>
        <trans-unit id="6a9db2da200feea27e3e89ec89ca9f8bf249bcbc" translate="yes" xml:space="preserve">
          <source>But both are slower than assigning the empty list or undefining %HASH or @ARRAY, which is the customary way to empty out an aggregate:</source>
          <target state="translated">しかし、どちらも空のリストを代入したり、定義していない %HASH や @ARRAY を代入したりするよりも遅くなります。</target>
        </trans-unit>
        <trans-unit id="527a74597b28c7ec00ae7d09430ff9201f3f5a87" translate="yes" xml:space="preserve">
          <source>But don't bother him, he's retired.</source>
          <target state="translated">でも気にするなよ、引退したんだから。</target>
        </trans-unit>
        <trans-unit id="04440d595d2cdff8c05a9e9393436d8792f429f8" translate="yes" xml:space="preserve">
          <source>But don't put</source>
          <target state="translated">しかし、それを置いてはいけない</target>
        </trans-unit>
        <trans-unit id="9491e2071e60f65ae593369952ca1ddd75bbfad0" translate="yes" xml:space="preserve">
          <source>But due to an unfixable bug (fixing it would break lots of existing CPAN modules) in the typemap file, the reference count of the &lt;code&gt;AV *&lt;/code&gt; is not properly decremented. Thus, the above XSUB would leak memory whenever it is being called. The same problem exists for &lt;code&gt;HV *&lt;/code&gt; , &lt;code&gt;CV *&lt;/code&gt; , and &lt;code&gt;SVREF&lt;/code&gt; (which indicates a scalar reference, not a general &lt;code&gt;SV *&lt;/code&gt; ). In XS code on perls starting with perl 5.16, you can override the typemaps for any of these types with a version that has proper handling of refcounts. In your &lt;code&gt;TYPEMAP&lt;/code&gt; section, do</source>
          <target state="translated">しかし、タイプマップファイルの修正不可能なバグ（修正すると既存のCPANモジュールの多くが壊れる）のため、 &lt;code&gt;AV *&lt;/code&gt; の参照カウントは適切に減らされません。したがって、上記のXSUBは、呼び出されるたびにメモリをリークします。同じ問題が &lt;code&gt;HV *&lt;/code&gt; 、 &lt;code&gt;CV *&lt;/code&gt; 、および &lt;code&gt;SVREF&lt;/code&gt; （一般的な &lt;code&gt;SV *&lt;/code&gt; ではなくスカラー参照を示す）にも存在します。 perl 5.16から始まるperlのXSコードでは、refcountが適切に処理されるバージョンでこれらのタイプのタイプマップをオーバーライドできます。あなたに &lt;code&gt;TYPEMAP&lt;/code&gt; のセクション、やります</target>
        </trans-unit>
        <trans-unit id="3bda93cc7a8a89f24895e1ee457675fc5ec79f7f" translate="yes" xml:space="preserve">
          <source>But due to an unfixable bug (fixing it would break lots of existing CPAN modules) in the typemap file, the reference count of the &lt;code&gt;AV *&lt;/code&gt; is not properly decremented. Thus, the above XSUB would leak memory whenever it is being called. The same problem exists for &lt;code&gt;HV *&lt;/code&gt;, &lt;code&gt;CV *&lt;/code&gt;, and &lt;code&gt;SVREF&lt;/code&gt; (which indicates a scalar reference, not a general &lt;code&gt;SV *&lt;/code&gt;). In XS code on perls starting with perl 5.16, you can override the typemaps for any of these types with a version that has proper handling of refcounts. In your &lt;code&gt;TYPEMAP&lt;/code&gt; section, do</source>
          <target state="translated">ただし、タイプマップファイルの修正不可能なバグ（修正すると既存のCPANモジュールの多くが破損する）が原因で、 &lt;code&gt;AV *&lt;/code&gt; の参照カウントが適切にデクリメントされません。したがって、上記のXSUBは、呼び出されるたびにメモリをリークします。同じ問題が &lt;code&gt;HV *&lt;/code&gt; 、 &lt;code&gt;CV *&lt;/code&gt; 、および &lt;code&gt;SVREF&lt;/code&gt; （一般的な &lt;code&gt;SV *&lt;/code&gt; ではなくスカラー参照を示す）にも存在します。 perl 5.16以降のperlのXSコードでは、これらのタイプのタイプマップを、refcountを適切に処理するバージョンでオーバーライドできます。あなたに &lt;code&gt;TYPEMAP&lt;/code&gt; のセクション、やります</target>
        </trans-unit>
        <trans-unit id="be9ca11f359e927d9da9a4e640717e37037c1c98" translate="yes" xml:space="preserve">
          <source>But easiest is, if the character is specifiable as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt; or &lt;code&gt;&quot;%&quot;&lt;/code&gt; , to use that; if not so specificable, you can use use &lt;code&gt;\N{}&lt;/code&gt; , if the side effects aren't troublesome. Simply specify all your characters in hex, using &lt;code&gt;\N{U+ZZ}&lt;/code&gt; instead of &lt;code&gt;\xZZ&lt;/code&gt; . &lt;code&gt;\N{}&lt;/code&gt; is the Unicode name, and so it always gives you the Unicode character. &lt;code&gt;\N{U+41}&lt;/code&gt; is the character whose Unicode code point is &lt;code&gt;0x41&lt;/code&gt; , hence is &lt;code&gt;'A'&lt;/code&gt; on all platforms. The side effects are:</source>
          <target state="translated">しかし、最も簡単なのは、文字が &lt;code&gt;&quot;A&quot;&lt;/code&gt; や &lt;code&gt;&quot;%&quot;&lt;/code&gt; などのリテラルとして指定できる場合、それを使用することです。それほど具体的でない場合は、副作用が問題にならない場合は &lt;code&gt;\N{}&lt;/code&gt; 使用できます。 &lt;code&gt;\xZZ&lt;/code&gt; 代わりに\ &lt;code&gt;\N{U+ZZ}&lt;/code&gt; を使用して、すべての文字を16進数で指定するだけです。 &lt;code&gt;\N{}&lt;/code&gt; はUnicode名であるため、常にUnicode文字が得られます。 &lt;code&gt;\N{U+41}&lt;/code&gt; は、Unicodeコードポイントが &lt;code&gt;0x41&lt;/code&gt; の文字であるため、すべてのプラットフォームで &lt;code&gt;'A'&lt;/code&gt; です。副作用は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="2d7d9f0491fdf8f26d2ae8e336ebfac29d297c05" translate="yes" xml:space="preserve">
          <source>But easiest is, if the character is specifiable as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt; or &lt;code&gt;&quot;%&quot;&lt;/code&gt;, to use that; if not so specificable, you can use &lt;code&gt;\N{}&lt;/code&gt; , if the side effects aren't troublesome. Simply specify all your characters in hex, using &lt;code&gt;\N{U+ZZ}&lt;/code&gt; instead of &lt;code&gt;\xZZ&lt;/code&gt;. &lt;code&gt;\N{}&lt;/code&gt; is the Unicode name, and so it always gives you the Unicode character. &lt;code&gt;\N{U+41}&lt;/code&gt; is the character whose Unicode code point is &lt;code&gt;0x41&lt;/code&gt;, hence is &lt;code&gt;'A'&lt;/code&gt; on all platforms. The side effects are:</source>
          <target state="translated">ただし、文字が &lt;code&gt;&quot;A&quot;&lt;/code&gt; や &lt;code&gt;&quot;%&quot;&lt;/code&gt; などのリテラルとして指定できる場合は、それを使用するのが最も簡単です。それほど具体的でない場合は、副作用が問題にならないのであれば、 &lt;code&gt;\N{}&lt;/code&gt; 使用できます。 &lt;code&gt;\xZZ&lt;/code&gt; 代わりに\ &lt;code&gt;\N{U+ZZ}&lt;/code&gt; を使用して、すべての文字を16進数で指定するだけです。 &lt;code&gt;\N{}&lt;/code&gt; はUnicode名であるため、常にUnicode文字が使用されます。 &lt;code&gt;\N{U+41}&lt;/code&gt; は、Unicodeコードポイントが &lt;code&gt;0x41&lt;/code&gt; である文字であるため、すべてのプラットフォームで &lt;code&gt;'A'&lt;/code&gt; になります。副作用は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="4e336391004e93bf9adbf972f876990718b27f63" translate="yes" xml:space="preserve">
          <source>But failure_handler_auto, instead of dying or anything, compiles $key, caching it in</source>
          <target state="translated">しかし、failure_handler_autoは死んだりするのではなく、$keyをコンパイルして</target>
        </trans-unit>
        <trans-unit id="d44c97279f7f106146fa21778196b89c19981fbb" translate="yes" xml:space="preserve">
          <source>But fear not, there's a simple solution. The module &lt;code&gt;Sub::Name&lt;/code&gt; will reach into the perl internals and assign a name to an anonymous subroutine for you. Simply do this:</source>
          <target state="translated">しかし、恐れないでください。簡単な解決策があります。モジュール &lt;code&gt;Sub::Name&lt;/code&gt; はperl内部に到達し、匿名のサブルーチンに名前を割り当てます。単にこれを行う：</target>
        </trans-unit>
        <trans-unit id="6c88ebcfc6d7c83b843d2d6f3e737b05e79bf378" translate="yes" xml:space="preserve">
          <source>But for &quot;directory&quot;, you'd want &lt;code&gt;&quot;[quant,_1,directory,directories]&quot;&lt;/code&gt; so that our elementary &lt;code&gt;quant&lt;/code&gt; method doesn't think that the plural of &quot;directory&quot; is &quot;directorys&quot;. And you might find that the output may sound better if you specify a negative form, as in:</source>
          <target state="translated">しかし、「ディレクトリ」の場合は、 &lt;code&gt;&quot;[quant,_1,directory,directories]&quot;&lt;/code&gt; 使用して、基本的な &lt;code&gt;quant&lt;/code&gt; メソッドが「ディレクトリ」の複数形が「ディレクトリ」であるとは見なさないようにします。また、次のように否定形を指定すると、出力の音が良くなる場合があります。</target>
        </trans-unit>
        <trans-unit id="490b6f6af7c2374cd5fd42c108629dc25f1e6fdb" translate="yes" xml:space="preserve">
          <source>But for now, let's look at general issues common to all these types of data structures.</source>
          <target state="translated">しかし、ここでは、これらすべてのタイプのデータ構造に共通する一般的な問題を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="44e2925861f8472f51f5341cbaaf661343ddc11e" translate="yes" xml:space="preserve">
          <source>But for other languages (as is discussed at length in &lt;a href=&quot;Locale::Maketext::TPJ13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;), simple &lt;code&gt;quant&lt;/code&gt;/&lt;code&gt;numf&lt;/code&gt; is not enough. For the particularly problematic Slavic languages, what you may need is a method which you provide with the number, the citation form of the noun to quantify, and the case and gender that the sentence's syntax projects onto that noun slot. The method would then be responsible for determining what grammatical number that numeral projects onto its noun phrase, and what case and gender it may override the normal case and gender with; and then it would look up the noun in a lexicon providing all needed inflected forms.</source>
          <target state="translated">ただし、他の言語の場合（&lt;a href=&quot;Locale::Maketext::TPJ13&quot;&gt;Locale :: Maketext :: TPJ13で詳細に&lt;/a&gt;説明されているように）、単純な &lt;code&gt;quant&lt;/code&gt; / &lt;code&gt;numf&lt;/code&gt; では不十分です。特に問題のあるスラブ言語の場合、必要なのは、数、定量化する名詞の引用形式、および文の構文がその名詞スロットに投影する大文字と小文字と性別を指定する方法です。このメソッドは、その数字が名詞句に投影される文法番号と、通常の格と性別を上書きする可能性のある格と性別を決定する責任があります。次に、必要なすべての屈折形を提供するレキシコンで名詞を検索します。</target>
        </trans-unit>
        <trans-unit id="38fcb950a418ab15715107f772519ba0899f4c7c" translate="yes" xml:space="preserve">
          <source>But for other languages (as is discussed at length in &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;), simple &lt;code&gt;quant&lt;/code&gt; /&lt;code&gt;numf&lt;/code&gt; is not enough. For the particularly problematic Slavic languages, what you may need is a method which you provide with the number, the citation form of the noun to quantify, and the case and gender that the sentence's syntax projects onto that noun slot. The method would then be responsible for determining what grammatical number that numeral projects onto its noun phrase, and what case and gender it may override the normal case and gender with; and then it would look up the noun in a lexicon providing all needed inflected forms.</source>
          <target state="translated">しかし、他の言語（&lt;a href=&quot;maketext/tpj13&quot;&gt;Locale :: Maketext :: TPJ13で詳しく&lt;/a&gt;説明されている）では、単純な &lt;code&gt;quant&lt;/code&gt; / &lt;code&gt;numf&lt;/code&gt; では不十分です。特に問題のあるスラブ言語の場合、必要なのは、数値、定量化する名詞の引用形式、および文の構文がその名詞スロットに投影する大文字と小文字と性別を指定する方法です。次に、メソッドは、その数字がその名詞句に射影する文法上の番号、および通常のケースと性別をオーバーライドできるケースと性別を決定する責任があります。そして、必要なすべての活用形を提供する辞書で名詞を検索します。</target>
        </trans-unit>
        <trans-unit id="ef8dab0f4d9389f9bb5dc21779fdfd4e9a160e11" translate="yes" xml:space="preserve">
          <source>But for some processors/formats this cannot be easily controlled; as with the HTML example, the behavior of multiple ambiguous &amp;lt;a name=&quot;</source>
          <target state="translated">ただし、一部のプロセッサ/フォーマットでは、これを簡単に制御することができません。HTMLの例と同様に、あいまいな複数の&amp;lt;a name = &quot;の動作</target>
        </trans-unit>
        <trans-unit id="8b46bf6bc073f2a792b2de8dc4b3f11e31f9c12f" translate="yes" xml:space="preserve">
          <source>But generally, a block is delimited by curly brackets, also known as braces. We will call this syntactic construct a BLOCK.</source>
          <target state="translated">しかし、一般的にブロックは中括弧とも呼ばれる中括弧で区切られます。この構文構成を BLOCK と呼ぶことにします。</target>
        </trans-unit>
        <trans-unit id="12fcc42a7dd22316cac44e40d51daa68deca033b" translate="yes" xml:space="preserve">
          <source>But generally, a block is delimited by curly brackets, also known as braces. We will call this syntactic construct a BLOCK. Because enclosing braces are also the syntax for hash reference constructor expressions (see &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;), you may occasionally need to disambiguate by placing a &lt;code&gt;;&lt;/code&gt; immediately after an opening brace so that Perl realises the brace is the start of a block. You will more frequently need to disambiguate the other way, by placing a &lt;code&gt;+&lt;/code&gt; immediately before an opening brace to force it to be interpreted as a hash reference constructor expression. It is considered good style to use these disambiguating mechanisms liberally, not only when Perl would otherwise guess incorrectly.</source>
          <target state="translated">ただし、一般的に、ブロックは中括弧とも呼ばれる中括弧で区切られます。この構文構造をBLOCKと呼びます。中括弧はハッシュ参照コンストラクター式の構文でもあるため（&lt;a href=&quot;perlref&quot;&gt;perlrefを&lt;/a&gt;参照）、;を配置して明確にする必要がある場合があり &lt;code&gt;;&lt;/code&gt; 中括弧がブロックの始まりであることをPerlが認識するように、中括弧を開いた直後。開始中括弧の直前に &lt;code&gt;+&lt;/code&gt; を配置して、ハッシュ参照コンストラクター式として解釈されるように強制することにより、他の方法でより頻繁に明確にする必要があります。 Perlが誤って推測する場合だけでなく、これらの曖昧性解消メカニズムを自由に使用することは良いスタイルと考えられています。</target>
        </trans-unit>
        <trans-unit id="ccefce54f83b7f4c3b397919dd3e84e700ff50bd" translate="yes" xml:space="preserve">
          <source>But if the client asks for &quot;i-Mingo&quot; or &quot;x-mingo&quot;, or &quot;Fr&quot;, then the lookup in %greetings fails. That's the Wrong Thing.</source>
          <target state="translated">しかし、クライアントが &quot;i-mingo &quot;や &quot;x-mingo&quot;、&quot;Fr &quot;を尋ねると、%greetingsでの検索は失敗します。これは間違っています。</target>
        </trans-unit>
        <trans-unit id="ec6083b91636d75d0495261998b67a37e19945dc" translate="yes" xml:space="preserve">
          <source>But if the document starts out:</source>
          <target state="translated">しかし、文書が始まってしまうと</target>
        </trans-unit>
        <trans-unit id="018410255214e3cce3a8b05ae3d7d99e0330f4d0" translate="yes" xml:space="preserve">
          <source>But if you subclass Pod::Simple::Methody, it will instead do this when it sees a &quot;=head1 Hi there&quot;:</source>
          <target state="translated">しかし、Pod::Simple::Methodyをサブクラス化すると、代わりに&quot;=head1 こんにちは &quot;を見たときにこのような処理をしてくれます。</target>
        </trans-unit>
        <trans-unit id="0cf73c47906927595e3043b178988fd87c4d5b4a" translate="yes" xml:space="preserve">
          <source>But if you try this:</source>
          <target state="translated">でも、これをやってみたら</target>
        </trans-unit>
        <trans-unit id="90ee606d0538a1d21fc1f464d165e33c56162b66" translate="yes" xml:space="preserve">
          <source>But if you want nested occurrences of &lt;code&gt;START&lt;/code&gt; through &lt;code&gt;END&lt;/code&gt; , you'll run up against the problem described in the question in this section on matching balanced text.</source>
          <target state="translated">しかし、 &lt;code&gt;START&lt;/code&gt; から &lt;code&gt;END&lt;/code&gt; のネストされたオカレンスが必要な場合は、バランスの取れたテキストの照合に関するこのセクションの質問で説明されている問題に出くわします。</target>
        </trans-unit>
        <trans-unit id="3edd5ad7f10118d3c50f146510574f8277f3c749" translate="yes" xml:space="preserve">
          <source>But if you want nested occurrences of &lt;code&gt;START&lt;/code&gt; through &lt;code&gt;END&lt;/code&gt;, you'll run up against the problem described in the question in this section on matching balanced text.</source>
          <target state="translated">ただし、 &lt;code&gt;START&lt;/code&gt; から &lt;code&gt;END&lt;/code&gt; までのネストされたオカレンスが必要な場合は、バランスの取れたテキストのマッチングに関するこのセクションの質問で説明されている問題に直面します。</target>
        </trans-unit>
        <trans-unit id="95d91fb2e9c31e4e480c3aa19de7d332e4a9c236" translate="yes" xml:space="preserve">
          <source>But if you write code that uses &lt;code&gt;\005&lt;/code&gt; to mean a TAB or &lt;code&gt;\xC1&lt;/code&gt; to mean an &quot;A&quot;, or &lt;code&gt;\xDF&lt;/code&gt; to mean a &quot;&amp;yuml;&quot; (small &lt;code&gt;&quot;y&quot;&lt;/code&gt; with a diaeresis), then your code may well work on your EBCDIC platform, but not on an ASCII one. That's fine to do if no one will ever want to run your code on an ASCII platform; but the bias in this document will be in writing code portable between EBCDIC and ASCII systems. Again, if every character you care about is easily enterable from your keyboard, you don't have to know anything about ASCII, but many keyboards don't easily allow you to directly enter, say, the character &lt;code&gt;\xDF&lt;/code&gt; , so you have to specify it indirectly, such as by using the &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; escape sequence. In those cases it's easiest to know something about the ASCII/Unicode character sets. If you know that the small &quot;&amp;yuml;&quot; is &lt;code&gt;U+00FF&lt;/code&gt; , then you can instead specify it as &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt; , and have the computer automatically translate it to &lt;code&gt;\xDF&lt;/code&gt; on your platform, and leave it as &lt;code&gt;\xFF&lt;/code&gt; on ASCII ones. Or you could specify it by name, &lt;code&gt;\N{LATIN
SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; and not have to know the numbers. Either way works, but require familiarity with Unicode.</source>
          <target state="translated">しかし、あなたが使用するコード記述した場合 &lt;code&gt;\005&lt;/code&gt; TABを意味するか、 &lt;code&gt;\xC1&lt;/code&gt; 「A」を意味する、または &lt;code&gt;\xDF&lt;/code&gt; 「Y」（小意味する &lt;code&gt;&quot;y&quot;&lt;/code&gt; ダイエレシス付き）を、その後、あなたのコードがあなたにうまく動作するかもしれをEBCDICプラットフォームですが、ASCIIプラットフォームではありません。 ASCIIプラットフォームでコードを実行したくない場合は、これで問題ありません。しかし、このドキュメントのバイアスは、EBCDICシステムとASCIIシステム間で移植可能なコードを書くことにあります。繰り返しになりますが、気になるすべての文字がキーボードから簡単に入力できる場合は、ASCIIについて何も知る必要はありませんが、多くのキーボードでは、たとえば文字 &lt;code&gt;\xDF&lt;/code&gt; を直接入力することが簡単にできないので、 &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; などを使用して間接的に指定するエスケープシーケンス。それらの場合、ASCII / Unicode文字セットについて何かを知るのが最も簡単です。あなたは小さな「Y」があることがわかっている場合は &lt;code&gt;U+00FF&lt;/code&gt; 、あなたはその代わりとして、それを指定することができます &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt; 、およびコンピュータが自動的にそれを翻訳してい &lt;code&gt;\xDF&lt;/code&gt; ご使用のプラットフォーム上で、及びそのまま &lt;code&gt;\xFF&lt;/code&gt; ASCIIのxFF。または、名前で指定することもできます（ &lt;code&gt;\N{LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; 。数字を知っている必要はありません。どちらの方法でも機能しますが、Unicodeに精通している必要があります。</target>
        </trans-unit>
        <trans-unit id="8c5b9a3f892143e75b663a18f94ea6753bbb8def" translate="yes" xml:space="preserve">
          <source>But if you write code that uses &lt;code&gt;\005&lt;/code&gt; to mean a TAB or &lt;code&gt;\xC1&lt;/code&gt; to mean an &quot;A&quot;, or &lt;code&gt;\xDF&lt;/code&gt; to mean a &quot;&amp;yuml;&quot; (small &lt;code&gt;&quot;y&quot;&lt;/code&gt; with a diaeresis), then your code may well work on your EBCDIC platform, but not on an ASCII one. That's fine to do if no one will ever want to run your code on an ASCII platform; but the bias in this document will be towards writing code portable between EBCDIC and ASCII systems. Again, if every character you care about is easily enterable from your keyboard, you don't have to know anything about ASCII, but many keyboards don't easily allow you to directly enter, say, the character &lt;code&gt;\xDF&lt;/code&gt;, so you have to specify it indirectly, such as by using the &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; escape sequence. In those cases it's easiest to know something about the ASCII/Unicode character sets. If you know that the small &quot;&amp;yuml;&quot; is &lt;code&gt;U+00FF&lt;/code&gt;, then you can instead specify it as &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt;, and have the computer automatically translate it to &lt;code&gt;\xDF&lt;/code&gt; on your platform, and leave it as &lt;code&gt;\xFF&lt;/code&gt; on ASCII ones. Or you could specify it by name, &lt;code&gt;\N{LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; and not have to know the numbers. Either way works, but both require familiarity with Unicode.</source>
          <target state="translated">ただし、 &lt;code&gt;\005&lt;/code&gt; を使用してTABを意味するか、 &lt;code&gt;\xC1&lt;/code&gt; を使用して「A」を意味するか、 &lt;code&gt;\xDF&lt;/code&gt; を使用して「&amp;yuml;」（分音記号付きの小さな &lt;code&gt;&quot;y&quot;&lt;/code&gt; ）を意味するコードを記述した場合、コードはEBCDICプラットフォームですが、ASCIIプラットフォームではありません。誰もASCIIプラットフォームでコードを実行したくない場合は、これで問題ありません。ただし、このドキュメントのバイアスは、EBCDICシステムとASCIIシステム間で移植可能なコードを作成することです。繰り返しますが、気になるすべての文字がキーボードから簡単に入力できる場合は、ASCIIについて何も知る必要はありませんが、多くのキーボードでは、たとえば文字 &lt;code&gt;\xDF&lt;/code&gt; を直接入力することは簡単にできないため、次のようにする必要があります。 &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; を使用するなど、間接的に指定しますエスケープシーケンス。そのような場合、ASCII / Unicode文字セットについて何かを知るのが最も簡単です。あなたは小さな「Y」があることがわかっている場合は &lt;code&gt;U+00FF&lt;/code&gt; 、あなたはその代わりとして、それを指定することができます &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt; 、およびコンピュータが自動的にそれを翻訳してい &lt;code&gt;\xDF&lt;/code&gt; ご使用のプラットフォーム上で、及びそのまま &lt;code&gt;\xFF&lt;/code&gt; ASCIIのもののxFF。または、名前で指定することもできます。 &lt;code&gt;\N{LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; で、番号を知る必要はありません。どちらの方法でも機能しますが、どちらもUnicodeに精通している必要があります。</target>
        </trans-unit>
        <trans-unit id="8cb0a7929d9be6d467d0702a4ca1482bdad00292" translate="yes" xml:space="preserve">
          <source>But if you're a perl programmer, then for you I have something much more wondrous than just a structure offset printer.</source>
          <target state="translated">しかし、あなたがPerlプログラマであるならば、私はあなたのために、単に構造体のオフセットプリンタよりもはるかに素晴らしいものを持っています。</target>
        </trans-unit>
        <trans-unit id="b5d1347e7974f3a5c8f6ee662fc96a7143711f4b" translate="yes" xml:space="preserve">
          <source>But if you're using &lt;code&gt;PerlIO_printf()&lt;/code&gt;, it's less typing and visual clutter to use the &lt;code&gt;%z&lt;/code&gt; length modifier (for</source>
          <target state="translated">ただし、 &lt;code&gt;PerlIO_printf()&lt;/code&gt; を使用している場合は、 &lt;code&gt;%z&lt;/code&gt; 長さ修飾子を使用する方が入力や視覚的な混乱が少なくなります（</target>
        </trans-unit>
        <trans-unit id="95c71d4b40a76244fed8568f06f2e4623c952ed6" translate="yes" xml:space="preserve">
          <source>But in any case, try to keep the features and operating systems separate.</source>
          <target state="translated">しかし、いずれにしても、機能とOSは分けておくようにしましょう。</target>
        </trans-unit>
        <trans-unit id="f86252e7b4ed24cc14ced10c8828354685807171" translate="yes" xml:space="preserve">
          <source>But in case you find the need to...</source>
          <target state="translated">でも、万が一、必要性を感じた場合には...</target>
        </trans-unit>
        <trans-unit id="3425ba57841c54a0c594ad2ebd352f7a60dfde42" translate="yes" xml:space="preserve">
          <source>But in general, such surprises are rare when entire sentences are being translated, especially when the functional context is restricted to that of a computer interacting with a user either to convey a fact or to prompt for a piece of information. So, for purposes of localization, translation by phrase (generally by sentence) is both the simplest and the least problematic.</source>
          <target state="translated">しかし、一般的には、文全体を翻訳する場合には、このようなサプライズは稀であり、特に、機能的な文脈が、事実を伝えるため、または情報を求めるためにユーザーと対話するコンピュータの文脈に限定されている場合には、そのようなサプライズはありません。したがって、ローカリゼーションを目的とする場合は、フレーズによる翻訳(一般的には文による翻訳)が最も簡単で問題が少ないといえます。</target>
        </trans-unit>
        <trans-unit id="8e2d7167267546a3345c93288a69c7eaaae59c46" translate="yes" xml:space="preserve">
          <source>But in many cases, especially multi-byte CJK encodings, you have to tweak a little more. Your network connection may not accept any data with the Most Significant Bit set, and your computer may not be able to tell if a given byte is a whole character or just half of it. So you have to</source>
          <target state="translated">しかし、多くの場合、特にマルチバイトの日中韓エンコーディングでは、もう少し手を加えなければなりません。ネットワーク接続では最上位ビットが設定されたデータを受け付けない場合がありますし、コンピュータは指定されたバイトが全体の文字なのか半分だけなのかを見分けられない場合があります。そのため、次のようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="56073db003479cbcc5aa02dbdcbc3839993740e4" translate="yes" xml:space="preserve">
          <source>But in other cases, it just is that no one has implemented support yet. Patches welcome! Some elements are ported backward for some releases, but not all the way to 5.003_07.</source>
          <target state="translated">しかし、他のケースでは、まだ誰もサポートを実装していないだけです。パッチを歓迎します。いくつかのリリースでは、いくつかの要素が後方に移植されていますが、5.003_07までは移植されていません。</target>
        </trans-unit>
        <trans-unit id="ca1b980e76b99df2ec3833fb22b3d48a26eb466f" translate="yes" xml:space="preserve">
          <source>But in this particular example, you probably really want</source>
          <target state="translated">しかし、この特定の例では、おそらく、あなたは本当は</target>
        </trans-unit>
        <trans-unit id="3cee8270da886ebc5c44d683d110f389adb2e169" translate="yes" xml:space="preserve">
          <source>But it actually compiles as this:</source>
          <target state="translated">しかし、実際にはこのようにコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="823e1d2128bc470581c23a9dfa7a058a23c8a7f1" translate="yes" xml:space="preserve">
          <source>But it also puts the same information in certain fields of the XSUB itself:</source>
          <target state="translated">しかし、それはまた、XSUB自体の特定のフィールドに同じ情報を入れます。</target>
        </trans-unit>
        <trans-unit id="f5f796fef481b4bfaedc4fb27aaba8e13316d437" translate="yes" xml:space="preserve">
          <source>But it also works on lexically declared aggregates.</source>
          <target state="translated">しかし、語彙的に宣言された集合体でも動作します。</target>
        </trans-unit>
        <trans-unit id="bce306df93e9efe810cd4909bfa7982e26681041" translate="yes" xml:space="preserve">
          <source>But it could equally well be a discussion of three (related or equivalent) items, &quot;Neque&quot;, &quot;Porro&quot;, and &quot;Quisquam Est&quot;, followed by a paragraph explaining them all, and then a new item &quot;Ut Enim&quot;. In that case, you'd probably want to format it like so:</source>
          <target state="translated">しかし、「Neque」、「Porro」、「Quisquam Est」という3つの(関連する、または同等の)項目についての議論の後に、それらをすべて説明する段落が続き、その後に新しい項目「Ut Enim」が追加される、というような形でもよいでしょう。その場合は、次のような形式にするとよいでしょう。</target>
        </trans-unit>
        <trans-unit id="ad75a36ebc7396598ae4020570b59b4dddb1d077" translate="yes" xml:space="preserve">
          <source>But it doesn't work at all in Perl 6. Instead, you should use the (parallelizable) &lt;code&gt;any&lt;/code&gt; operator:</source>
          <target state="translated">ただし、Perl 6ではまったく機能しません。代わりに、（並列化可能な） &lt;code&gt;any&lt;/code&gt; 演算子を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="5bdbc1f908497576f552335e7ff9cc35570484f5" translate="yes" xml:space="preserve">
          <source>But it doesn't work at all in Raku. Instead, you should use the (parallelizable) &lt;code&gt;any&lt;/code&gt; operator:</source>
          <target state="translated">しかし、楽ではまったく機能しません。代わりに、（並列化可能な） &lt;code&gt;any&lt;/code&gt; 演算子を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="bf7fd3170743bf29faac8bcfc9396e4e0b2afa0e" translate="yes" xml:space="preserve">
          <source>But it will croak if:</source>
          <target state="translated">でも、もしもの時には鳴きます。</target>
        </trans-unit>
        <trans-unit id="934319e95a665a2a7425edac031de11ea5229dad" translate="yes" xml:space="preserve">
          <source>But most importantly, it works on systems that don't have &lt;code&gt;nl_langinfo&lt;/code&gt;, such as Windows, hence makes your code more portable. Of the fifty-some possible items specified by the POSIX 2008 standard, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html&quot;&gt;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html&lt;/a&gt;, only one is completely unimplemented, though on non-Windows platforms, another significant one is also not implemented). It uses various techniques to recover the other items, including calling &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/localeconv&quot;&gt;localeconv(3)&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/strftime&quot;&gt;strftime(3)&lt;/a&gt;&lt;/code&gt;, both of which are specified in C89, so should be always be available. Later &lt;code&gt;strftime()&lt;/code&gt; versions have additional capabilities; &lt;code&gt;&quot;&quot;&lt;/code&gt; is returned for those not available on your system.</source>
          <target state="translated">しかし、最も重要なことは、Windowsなどの &lt;code&gt;nl_langinfo&lt;/code&gt; を持たないシステムで機能するため、コードの移植性が向上することです。 POSIX 2008標準&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html&quot;&gt;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html&lt;/a&gt;で指定されている可能性のある50項目のうち、完全に実装されていないのは1つだけですが、Windows以外のプラットフォームでは別の重要なものも実装されていません）。これは、 &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/localeconv&quot;&gt;localeconv(3)&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/strftime&quot;&gt;strftime(3)&lt;/a&gt;&lt;/code&gt; の呼び出しなど、さまざまな手法を使用して他のアイテムを回復します。これらは両方ともC89で指定されているため、常に使用可能である必要があります。それ以降の &lt;code&gt;strftime()&lt;/code&gt; バージョンには追加機能があります。システムで使用できないものについては、 &lt;code&gt;&quot;&quot;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="ac22b7287d2aed5e7462242749c989d65753c887" translate="yes" xml:space="preserve">
          <source>But never use the bare &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; without having set up a default encoding first. Otherwise, Perl cannot know which of the many, many, many possible flavors of text file you have, and Perl will have no idea how to correctly map the data in your file into actual characters it can work with. Other common encoding formats including &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt; , &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt; , &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt; , and even &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt; . See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more about encodings.</source>
          <target state="translated">ただし、最初にデフォルトのエンコーディングを設定せずに、裸の &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; を使用しないでください。そうしないと、Perlは、テキストファイルのさまざまなフレーバーのどれを持っているかを知ることができず、Perlはファイル内のデータを操作可能な実際の文字に正しくマッピングする方法を知りません。 &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt; 、さらには &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt; など、その他の一般的なエンコード形式。エンコーディングの詳細については&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a0747e69fd78e083ffa59b04def2af91b0c7abf3" translate="yes" xml:space="preserve">
          <source>But never use the bare &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; without having set up a default encoding first. Otherwise, Perl cannot know which of the many, many, many possible flavors of text file you have, and Perl will have no idea how to correctly map the data in your file into actual characters it can work with. Other common encoding formats including &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt;, &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt;, &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt;, &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt;, &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt;, and even &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt;. See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more about encodings.</source>
          <target state="translated">ただし、最初にデフォルトのエンコーディングを設定せずに、裸の &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; を使用しないでください。そうでなければ、Perlはあなたが持っているテキストファイルの多くの、多くの、多くのフレーバーのどれを知ることができず、Perlはあなたのファイルのデータをそれが扱うことができる実際の文字に正しくマッピングする方法を知りません。 &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt; 、さらには &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt; を含むその他の一般的なエンコード形式。エンコーディングの詳細については、&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="eca085acb0ddeeb52a224b25677bc101217dcb2a" translate="yes" xml:space="preserve">
          <source>But note that these last three macros are valid only if &lt;code&gt;SvPOK()&lt;/code&gt; is true.</source>
          <target state="translated">ただし、これらの最後の3つのマクロは、 &lt;code&gt;SvPOK()&lt;/code&gt; がtrueの場合にのみ有効であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="5960a3f75e9619ab812c7dea1d6e781ac954880e" translate="yes" xml:space="preserve">
          <source>But note that this doesn't mean that any of the characters in the string are necessary UTF-8 encoded, or that any of the characters have code points greater than 0xFF (255) or even 0x80 (128), or that the string has any characters at all. All the &lt;code&gt;is_utf8()&lt;/code&gt; does is to return the value of the internal &quot;utf8ness&quot; flag attached to the &lt;code&gt;$string&lt;/code&gt; . If the flag is off, the bytes in the scalar are interpreted as a single byte encoding. If the flag is on, the bytes in the scalar are interpreted as the (variable-length, potentially multi-byte) UTF-8 encoded code points of the characters. Bytes added to a UTF-8 encoded string are automatically upgraded to UTF-8. If mixed non-UTF-8 and UTF-8 scalars are merged (double-quoted interpolation, explicit concatenation, or printf/sprintf parameter substitution), the result will be UTF-8 encoded as if copies of the byte strings were upgraded to UTF-8: for example,</source>
          <target state="translated">ただし、これは、文字列のいずれかの文字が必要なUTF-8エンコードであること、またはいずれかの文字のコードポイントが0xFF（255）または0x80（128）よりも大きいこと、または文字列がすべての文字。すべて &lt;code&gt;is_utf8()&lt;/code&gt; ありませんがにつけられている内部の「utf8ness」フラグの値を返すことです &lt;code&gt;$string&lt;/code&gt; 。フラグがオフの場合、スカラーのバイトはシングルバイトエンコーディングとして解釈されます。フラグがオンの場合、スカラー内のバイトは、文字の（可変長、場合によってはマルチバイト）UTF-8エンコードされたコードポイントとして解釈されます。UTF-8エンコードされた文字列に追加されたバイトは、自動的にUTF-8にアップグレードされます。非UTF-8とUTF-8の混合スカラーがマージされる場合（二重引用符で囲まれた補間、明示的な連結、またはprintf / sprintfパラメーター置換）、バイト文字列のコピーがUTFにアップグレードされたかのように、結果はUTF-8エンコードされます-8：たとえば、</target>
        </trans-unit>
        <trans-unit id="f3b88a9932e49bdc61514a0893c4a2b1cc99c884" translate="yes" xml:space="preserve">
          <source>But note that this doesn't mean that any of the characters in the string are necessary UTF-8 encoded, or that any of the characters have code points greater than 0xFF (255) or even 0x80 (128), or that the string has any characters at all. All the &lt;code&gt;is_utf8()&lt;/code&gt; does is to return the value of the internal &quot;utf8ness&quot; flag attached to the &lt;code&gt;$string&lt;/code&gt;. If the flag is off, the bytes in the scalar are interpreted as a single byte encoding. If the flag is on, the bytes in the scalar are interpreted as the (variable-length, potentially multi-byte) UTF-8 encoded code points of the characters. Bytes added to a UTF-8 encoded string are automatically upgraded to UTF-8. If mixed non-UTF-8 and UTF-8 scalars are merged (double-quoted interpolation, explicit concatenation, or printf/sprintf parameter substitution), the result will be UTF-8 encoded as if copies of the byte strings were upgraded to UTF-8: for example,</source>
          <target state="translated">ただし、これは、文字列内の文字のいずれかがUTF-8でエンコードされる必要があること、文字のいずれかが0xFF（255）または0x80（128）より大きいコードポイントを持っていること、または文字列が持っていることを意味しないことに注意してくださいすべての文字。すべて &lt;code&gt;is_utf8()&lt;/code&gt; ありませんがにつけられている内部の「utf8ness」フラグの値を返すことです &lt;code&gt;$string&lt;/code&gt; 。フラグがオフの場合、スカラーのバイトはシングルバイトエンコーディングとして解釈されます。フラグがオンの場合、スカラーのバイトは、文字の（可変長、場合によってはマルチバイトの）UTF-8エンコードされたコードポイントとして解釈されます。UTF-8でエンコードされた文字列に追加されたバイトは、自動的にUTF-8にアップグレードされます。非UTF-8とUTF-8の混合スカラーがマージされる場合（二重引用符による補間、明示的な連結、またはprintf / sprintfパラメーター置換）、結果は、バイト文字列のコピーがUTFにアップグレードされたかのようにUTF-8でエンコードされます。 -8：たとえば、</target>
        </trans-unit>
        <trans-unit id="3ed10f08c2a7b806d29712ea53fb65371e6dda25" translate="yes" xml:space="preserve">
          <source>But prior to v5.16, you must be explicit about which set of charnames you want. The &lt;code&gt;:full&lt;/code&gt; names are the official Unicode character name, alias, or sequence, which all share a namespace.</source>
          <target state="translated">ただし、v5.16より前のバージョンでは、必要な文字名のセットを明示する必要があります。 &lt;code&gt;:full&lt;/code&gt; 名前は、公式のUnicode文字名、別名、またはシーケンス、すべての共有の名前空間です。</target>
        </trans-unit>
        <trans-unit id="6ea0e56fa9cef58c93ebf2b8ef0ed82782b2271a" translate="yes" xml:space="preserve">
          <source>But recall that not all operating systems support forking or capturing of the output of commands, so this complex statement may not be portable.</source>
          <target state="translated">しかし、すべてのオペレーティングシステムがコマンドの出力のフォークやキャプチャをサポートしているわけではないことを思い出してください。</target>
        </trans-unit>
        <trans-unit id="80db3d6002a0ea4be473c7d7a0631f6d66de4e4e" translate="yes" xml:space="preserve">
          <source>But second off, it's not isomorphic -- the &quot;solution&quot; (i.e., the phrasebook entries) for Chinese maps from these four English phrases to the one Chinese phrase that fits for all of them. In other words, the informal solution would be &quot;The way to say what you want in Chinese is with the one phrase 'For your question, in Y directories you would find X files'&quot; -- and so the implemented solution should be, isomorphically, just a straightforward way to spit out that one phrase, with numerals properly interpolated. It shouldn't have to map from the complexity of other languages to the simplicity of this one.</source>
          <target state="translated">しかし、第二に、それは同型ではありません --中国語のための「解決策」(すなわち、フレーズブックのエントリ)は、これらの4つの英語フレーズから、それらのすべてに適合する1つの中国語フレーズへとマップします。言い換えれば、非公式な解決策は、&quot;The way to say what you want in Chinese is with the one phrase 'For your question,in Y directories you would find X files'&quot;であり、実装された解決策は、同型的に、数字が適切に補間された、その1つのフレーズを吐き出す単純な方法でなければなりません。他の言語の複雑さを、この言語のシンプルさにマップする必要はありません。</target>
        </trans-unit>
        <trans-unit id="f098d4fba29dcb8c3c77666f8cde3d29b4074e10" translate="yes" xml:space="preserve">
          <source>But some modules cannot be built with this mantra. They try to get some extra data from the user via the environment, extra arguments, or interactively--thus disturbing the installation of large bundles like Phalanx100 or modules with many dependencies like Plagger.</source>
          <target state="translated">しかし、このマントラではビルドできないモジュールもあります。彼らは、環境や引数、対話的にユーザーから余分なデータを取得しようとします --そのため、Phalanx100 のような大きなバンドルや Plagger のような多くの依存関係を持つモジュールのインストールを妨害します。</target>
        </trans-unit>
        <trans-unit id="b9343448796744b38fdcc31c04963c50f230e565" translate="yes" xml:space="preserve">
          <source>But stringify it and you get just the text content:</source>
          <target state="translated">しかし、それを文字列化すると、テキストの内容だけを得ることができます。</target>
        </trans-unit>
        <trans-unit id="420149069302ad928f47370a01dc8262cabda22d" translate="yes" xml:space="preserve">
          <source>But take care not to pass it as, for example</source>
          <target state="translated">しかし、例えば</target>
        </trans-unit>
        <trans-unit id="f5ed605cf911baa94f53b7f6af1d782e89ccd2f6" translate="yes" xml:space="preserve">
          <source>But testing for taintedness gets you only so far. Sometimes you have just to clear your data's taintedness. Values may be untainted by using them as keys in a hash; otherwise the only way to bypass the tainting mechanism is by referencing subpatterns from a regular expression match. Perl presumes that if you reference a substring using $1, $2, etc. in a non-tainting pattern, that you knew what you were doing when you wrote that pattern. That means using a bit of thought--don't just blindly untaint anything, or you defeat the entire mechanism. It's better to verify that the variable has only good characters (for certain values of &quot;good&quot;) rather than checking whether it has any bad characters. That's because it's far too easy to miss bad characters that you never thought of.</source>
          <target state="translated">しかし、汚染されているかどうかのテストでは、ここまでしかできません。時には、データが汚染されていないことを確認しなければならないこともあります。値をハッシュのキーとして使用することで汚染されていないかもしれません。そうでなければ、汚染のメカニズムを回避する唯一の方法は、正規表現のマッチからサブパターンを参照することです。Perl は、汚染されていないパターンで $1,$2,などを使って部分文字列を参照する場合、そのパターンを書いたときに何をしているか知っていると仮定しています。盲目的に何でもかんでも汚染を解除してはいけません。変数に悪い文字があるかどうかをチェックするよりも、(特定の「良い」の値に対して)良い文字だけを持っているかどうかを確認する方が良いでしょう。それは、思いもよらない悪い文字を見落とすことがあまりにも簡単だからです。</target>
        </trans-unit>
        <trans-unit id="07ab01a33d4e7c1814e10d3a1451c86fcb0fab16" translate="yes" xml:space="preserve">
          <source>But that can produce ambiguous syntax in certain cases, so it's often better to use the direct method invocation approach:</source>
          <target state="translated">しかし、これでは場合によっては曖昧な構文になってしまうこともあるので、直接メソッドを呼び出すアプローチを使用した方が良い場合もあります。</target>
        </trans-unit>
        <trans-unit id="4081f5e36560816f0b341323008a11e961519754" translate="yes" xml:space="preserve">
          <source>But that isn't going to match; at least, not the way you're hoping. It claims that there is no 123 in the string. Here's a clearer picture of why that pattern matches, contrary to popular expectations:</source>
          <target state="translated">しかし、それは一致しません。少なくとも、あなたが期待している方法ではありません。これは文字列に123がないと主張しています。これは一般的な予想に反して そのパターンが一致する理由をより明確に示しています</target>
        </trans-unit>
        <trans-unit id="07b885fe74e23c15de33bcf3d35cb8fafefcc846" translate="yes" xml:space="preserve">
          <source>But that second &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; is rushing ahead. It isn't using a simple literal string for the template. So maybe we should introduce...</source>
          <target state="translated">しかし、その2番目の &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; は急いでいます。テンプレートに単純なリテラル文字列を使用していません。だから多分導入する必要があります...</target>
        </trans-unit>
        <trans-unit id="ebd21a1f53afcb90bb2e6fa1c3ee1beda8c1e31a" translate="yes" xml:space="preserve">
          <source>But that second &lt;code&gt;unpack&lt;/code&gt; is rushing ahead. It isn't using a simple literal string for the template. So maybe we should introduce...</source>
          <target state="translated">しかし、その2番目の &lt;code&gt;unpack&lt;/code&gt; は急いでいます。テンプレートに単純なリテラル文字列を使用していません。だから多分私たちは紹介する必要があります...</target>
        </trans-unit>
        <trans-unit id="861b5be1d3b22e874a1fd22ed51f10196d9c89e5" translate="yes" xml:space="preserve">
          <source>But that's not terribly pretty. You may find it simpler or clearer in the long run to just do things like this:</source>
          <target state="translated">しかし、それはひどくきれいなものではありません。こんな感じでやった方が長い目で見てシンプルというかスッキリするかもしれません。</target>
        </trans-unit>
        <trans-unit id="5d68c723e2845ae1a2c75f9213f2beec623c2f67" translate="yes" xml:space="preserve">
          <source>But that's rather inefficient. A better way to do it is to start your program with:</source>
          <target state="translated">しかし、それはかなり非効率的です。より良い方法は、プログラムを開始することです。</target>
        </trans-unit>
        <trans-unit id="3c5623d3d8f73ddcc75bce9ec5d80243561beb13" translate="yes" xml:space="preserve">
          <source>But the Arabic translator is the next to write back. First off, your code for &quot;I scanned %g directory.&quot; or &quot;I scanned %g directories.&quot; assumes there's only singular or plural. But, to use linguistic jargon again, Arabic has grammatical number, like English (but unlike Chinese), but it's a three-term category: singular, dual, and plural. In other words, the way you say &quot;directory&quot; depends on whether there's one directory, or</source>
          <target state="translated">しかし、アラビア語の翻訳者が次に書き返してきます。まず、&quot;I scanned %g directory.&quot; や &quot;I scanned %g directories.&quot; のあなたのコードは、単数形か複数形しかないと仮定しています。しかし、もう一度言語学的専門用語を使うと、アラビア語には英語と同じように(中国語とは違いますが)文法的な数がありますが、単数形、二重形、複数形の3つのカテゴリーがあります。つまり、「ディレクトリ」の言い方は、1つのディレクトリがあるのか、それとも</target>
        </trans-unit>
        <trans-unit id="b0666cc872d80abdc9e23386d6ece439d18c0915" translate="yes" xml:space="preserve">
          <source>But the HERE_TARGET must still be flush against the margin. If you want that indented also, you'll have to quote in the indentation.</source>
          <target state="translated">しかし、HERE_TARGETはマージンと同じ位置になければなりません。インデントもしたい場合は、インデントの中に引用符を入れなければなりません。</target>
        </trans-unit>
        <trans-unit id="3261d19f3d27e578566dcbff378ffaa4781a7162" translate="yes" xml:space="preserve">
          <source>But the following code is quite bad:</source>
          <target state="translated">しかし、以下のコードはかなりヤバいです。</target>
        </trans-unit>
        <trans-unit id="903f25d05dc48316bba755ecdc1e7944baec6c3c" translate="yes" xml:space="preserve">
          <source>But the marked code isn't syntactically correct to be such an interpolated class.</source>
          <target state="translated">しかし、マークされたコードは、そのような補間されたクラスであることは、構文的に正しくありません。</target>
        </trans-unit>
        <trans-unit id="ce9ae2e6c3f8a198a1ff872d901ef6ec6abf0329" translate="yes" xml:space="preserve">
          <source>But there are some cases where only this solution works (like &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;maybe::next::method&lt;/code&gt; );</source>
          <target state="translated">ただし、このソリューションのみが機能する場合があります（ &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;maybe::next::method&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f444a7ccc18a957e30bdbe83f2e4500327151823" translate="yes" xml:space="preserve">
          <source>But there are some cases where only this solution works (like &lt;code&gt;goto &amp;amp;maybe::next::method&lt;/code&gt;);</source>
          <target state="translated">ただし、このソリューションのみが機能する場合もあります（ &lt;code&gt;goto &amp;amp;maybe::next::method&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6bbd2ecd4d2700eece4600f310be07e3be1c2ebf" translate="yes" xml:space="preserve">
          <source>But there are some cases where you may want to know which character set you are running under. One possible example is doing &lt;a href=&quot;#SORTING&quot;&gt;sorting&lt;/a&gt; in inner loops where performance is critical.</source>
          <target state="translated">ただし、実行中の文字セットを知りたい場合があります。考えられる1つの例は、パフォーマンスが重要な内部ループでの&lt;a href=&quot;#SORTING&quot;&gt;並べ替え&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="79f382a399e7acdac77923f9261c190aa9a11824" translate="yes" xml:space="preserve">
          <source>But there's no real need for &lt;b&gt;both&lt;/b&gt; to be tempfiles... the following should work just as well, without deadlocking:</source>
          <target state="translated">しかし、&lt;b&gt;両方&lt;/b&gt;が一時ファイルである必要はありません...以下はデッドロックなしで同様に機能するはずです：</target>
        </trans-unit>
        <trans-unit id="5a55d83408434c70f23ed8c60b8e212b2bfead28" translate="yes" xml:space="preserve">
          <source>But they may be arbitrarily long:</source>
          <target state="translated">しかし、それらは任意に長いかもしれません。</target>
        </trans-unit>
        <trans-unit id="47bd7edd758647409df600b782dfd569cb2795d8" translate="yes" xml:space="preserve">
          <source>But they may span several (non-blank) lines:</source>
          <target state="translated">しかし、それらは複数の(ブランクのない)行にまたがっている場合があります。</target>
        </trans-unit>
        <trans-unit id="af1031e39fec41022cade090893d6211ac853b17" translate="yes" xml:space="preserve">
          <source>But this does not have the effect that someone reading the code would likely expect, as the intersection applies just to &lt;code&gt;\p{Thai}&lt;/code&gt; , excluding the Laotian. Pitfalls like this can be avoided by parenthesizing the component pieces:</source>
          <target state="translated">しかし、これはラオス &lt;code&gt;\p{Thai}&lt;/code&gt; を除いて\ p {Thai}にのみ交差が適用されるため、コードを読んでいる人が期待するであろう効果はありません。このような落とし穴は、コンポーネントを括弧でくくることによって回避できます。</target>
        </trans-unit>
        <trans-unit id="3e961579d9e8252ea504999636a1d461e186d84b" translate="yes" xml:space="preserve">
          <source>But this does not have the effect that someone reading the source code would likely expect, as the intersection applies just to &lt;code&gt;\p{Thai}&lt;/code&gt;, excluding the Laotian. Its best to compile the subcomponents, but you could also parenthesize the component pieces:</source>
          <target state="translated">ただし、交差点はラオス &lt;code&gt;\p{Thai}&lt;/code&gt; を除いて\ p {Thai}にのみ適用されるため、これはソースコードを読んでいる人が期待するような効果はありません。サブコンポーネントをコンパイルするのが最善ですが、コンポーネントの断片を括弧で囲むこともできます。</target>
        </trans-unit>
        <trans-unit id="5e39b52a31dfee971d175ae42a65864bfa50aedc" translate="yes" xml:space="preserve">
          <source>But this doesn't match, at least not the way one might expect. Only after inserting the interpolated &lt;code&gt;$a99a&lt;/code&gt; and looking at the resulting full text of the regexp is it obvious that the backreferences have backfired. The subexpression &lt;code&gt;(\w+)&lt;/code&gt; has snatched number 1 and demoted the groups in &lt;code&gt;$a99a&lt;/code&gt; by one rank. This can be avoided by using relative backreferences:</source>
          <target state="translated">しかし、これは少なくとも、予想される方法とは異なります。補間された &lt;code&gt;$a99a&lt;/code&gt; を挿入し、結果として得られる正規表現の全文を調べた後でないと、後方参照がバックファイアされたことは明らかです。部分式 &lt;code&gt;(\w+)&lt;/code&gt; は数値1を奪い、 &lt;code&gt;$a99a&lt;/code&gt; のグループを1ランク下げました。これは、相対後方参照を使用することで回避できます。</target>
        </trans-unit>
        <trans-unit id="6783211af3a27626c9e0e73fe10e75f068ecbc7b" translate="yes" xml:space="preserve">
          <source>But this is not guaranteed to work.</source>
          <target state="translated">しかし、これは動作を保証するものではありません。</target>
        </trans-unit>
        <trans-unit id="3d71f7e1b353d405d0ac11988a391e51c106c8d8" translate="yes" xml:space="preserve">
          <source>But this is not:</source>
          <target state="translated">しかし、これは違います。</target>
        </trans-unit>
        <trans-unit id="b33d301cbe486111cdb963daebee73c9ce3e8834" translate="yes" xml:space="preserve">
          <source>But to avoid portability warnings (see &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;), you may prefer:</source>
          <target state="translated">ただし、移植性の警告を回避するために（&lt;a href=&quot;functions/use&quot;&gt;useを&lt;/a&gt;参照）、次のことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f9f8099c8d1ed2b0fc4c9abd170ecd56ff0e63b5" translate="yes" xml:space="preserve">
          <source>But to avoid portability warnings (see &lt;a href=&quot;perlfunc#use&quot;&gt;&quot;use&quot; in perlfunc&lt;/a&gt;), you may prefer:</source>
          <target state="translated">ただし、移植性の警告（&lt;a href=&quot;perlfunc#use&quot;&gt;perlfuncの「使用」を参照&lt;/a&gt;）を回避するために、次のことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="020939326fc990dde03b1b00ce335dbc09c9fc3e" translate="yes" xml:space="preserve">
          <source>But wait: doesn't &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; just return a sequence of bytes? How can we pass this string of bytes to some C code expecting a pointer which is, after all, nothing but a number? The answer is simple: We have to obtain the numeric address from the bytes returned by &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">しかし、待ってください： &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; はバイトのシーケンスを返すだけではありませんか？このバイト文字列を、結局のところ、数値でしかないポインタを期待するCコードに渡すにはどうすればよいでしょうか。答えは簡単です：私たちはで返されたバイトから数値アドレス取得する必要が &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d8b172e82350b535193e00efe170bf43ca91d34" translate="yes" xml:space="preserve">
          <source>But wait: doesn't &lt;code&gt;pack&lt;/code&gt; just return a sequence of bytes? How can we pass this string of bytes to some C code expecting a pointer which is, after all, nothing but a number? The answer is simple: We have to obtain the numeric address from the bytes returned by &lt;code&gt;pack&lt;/code&gt;.</source>
          <target state="translated">しかし待ってください： &lt;code&gt;pack&lt;/code&gt; はバイトのシーケンスを返すだけではありませんか？結局のところ、数字に過ぎないポインタを期待して、このバイト文字列をCコードに渡すにはどうすればよいでしょうか。答えは簡単です：私たちはで返されたバイトから数値アドレス取得する必要が &lt;code&gt;pack&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="681fa12b5aa88395e6be12e5639cef0794d6ebaa" translate="yes" xml:space="preserve">
          <source>But what about user-defined subroutines from modules? If you use &lt;code&gt;autodie&lt;/code&gt; on a user-defined subroutine then it assumes the following behaviour to demonstrate failure:</source>
          <target state="translated">しかし、モジュールからのユーザー定義のサブルーチンはどうですか？ユーザー定義のサブルーチンで &lt;code&gt;autodie&lt;/code&gt; を使用する場合、失敗を示すために次の動作を想定しています。</target>
        </trans-unit>
        <trans-unit id="1178148d2666470319bf944b3a6373f8bd5ec43c" translate="yes" xml:space="preserve">
          <source>But what happens if your test program dies halfway through?! Since we didn't say how many tests we're going to run, how can we know it failed? No problem, &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; employs some magic to catch that death and turn the test into a failure, even if every test passed up to that point.</source>
          <target state="translated">しかし、テストプログラムが途中で終了した場合はどうなりますか？！実行するテストの数を指定しなかったので、失敗したことをどのようにして知ることができますか？問題ありません、&lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt;は、すべてのテストがその時点まで合格したとしても、その死を捕らえてテストを失敗に変えるためにいくつかの魔法を採用しています。</target>
        </trans-unit>
        <trans-unit id="97c582aeb02e8310ccc2268a23e2a13586d2230f" translate="yes" xml:space="preserve">
          <source>But what if we had an indeterminate number of words? This is the sort of task &lt;code&gt;//g&lt;/code&gt; was made for. To extract all words, form the simple regexp &lt;code&gt;(\w+)&lt;/code&gt; and loop over all matches with &lt;code&gt;/(\w+)/g&lt;/code&gt; :</source>
          <target state="translated">しかし、不確定な数の単語があった場合はどうなるでしょうか。これは &lt;code&gt;//g&lt;/code&gt; が作成された種類のタスクです。すべての単語を抽出するには、単純な正規表現 &lt;code&gt;(\w+)&lt;/code&gt; を作成し、すべての一致を &lt;code&gt;/(\w+)/g&lt;/code&gt; ループします。</target>
        </trans-unit>
        <trans-unit id="90358bd78c20e742086dbdc6ea3490a9deb3bfcc" translate="yes" xml:space="preserve">
          <source>But what if we had an indeterminate number of words? This is the sort of task &lt;code&gt;/g&lt;/code&gt; was made for. To extract all words, form the simple regexp &lt;code&gt;(\w+)&lt;/code&gt; and loop over all matches with &lt;code&gt;/(\w+)/g&lt;/code&gt;:</source>
          <target state="translated">しかし、単語の数が不確定な場合はどうなるでしょうか。これは、 &lt;code&gt;/g&lt;/code&gt; が作成された種類のタスクです。すべての単語を抽出するには、単純な正規表現 &lt;code&gt;(\w+)&lt;/code&gt; を作成し、 &lt;code&gt;/(\w+)/g&lt;/code&gt; すべての一致をループします。</target>
        </trans-unit>
        <trans-unit id="ae7271808fc8fe6737543912e6a4f4345f08e046" translate="yes" xml:space="preserve">
          <source>But when &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; is used instead of &lt;code&gt;&quot;autotie&quot;&lt;/code&gt; :</source>
          <target state="translated">ただし、 &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; 代わりに &lt;code&gt;&quot;autotie&quot;&lt;/code&gt; 使用すると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="818681641ebe6c47ebb66c7080c5a8f6b3070c54" translate="yes" xml:space="preserve">
          <source>But when &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; is used instead of &lt;code&gt;&quot;autotie&quot;&lt;/code&gt;:</source>
          <target state="translated">しかし、とき &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; の代わりに使用されている &lt;code&gt;&quot;autotie&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a237c274e15fc51e976c2366d2b1cd3f9bba3c7c" translate="yes" xml:space="preserve">
          <source>But when the following lines are added at the end:</source>
          <target state="translated">しかし、最後に次のような行が追加されると</target>
        </trans-unit>
        <trans-unit id="b3a7682b246bb8254bfcb416501b69b76a746fd6" translate="yes" xml:space="preserve">
          <source>But with the actual compile tree for &lt;code&gt;$a = $b + $c&lt;/code&gt; it is different: some nodes</source>
          <target state="translated">しかし、 &lt;code&gt;$a = $b + $c&lt;/code&gt; の実際のコンパイルツリーでは異なります。いくつかのノード</target>
        </trans-unit>
        <trans-unit id="4db6b75d323cb14de03fc556f71c215fa0254459" translate="yes" xml:space="preserve">
          <source>But won't work when called as:</source>
          <target state="translated">でも、名前を呼ばれたときには動作しません。</target>
        </trans-unit>
        <trans-unit id="41f61e687d338fbf08bd8ac1adb4bd20048487aa" translate="yes" xml:space="preserve">
          <source>But you don't actually have to make two pipe calls. If you have the socketpair() system call, it will do this all for you.</source>
          <target state="translated">しかし、実際には2つのパイプコールをする必要はありません。socketpair()システムコールがあれば、これをすべて代行してくれます。</target>
        </trans-unit>
        <trans-unit id="eb429c70b04342714cf4d23c433974bea348e678" translate="yes" xml:space="preserve">
          <source>But you put it aside for the moment, and optimistically hope that the other translators won't have this problem, and that their languages will be better behaved -- i.e., that they will be just like English.</source>
          <target state="translated">しかし、あなたはそれをとりあえず脇に置いて、楽観的に、他の翻訳者がこの問題を抱えていないこと、そして、彼らの言語がより良い振る舞いをすること、つまり、英語と同じようになることを願っています。</target>
        </trans-unit>
        <trans-unit id="8bc61709d9d36e283fe251c9894f7f9c70eff276" translate="yes" xml:space="preserve">
          <source>But you still cannot make assumptions about whether this is correct, unless your policy says it is. You really are best off asking the user.</source>
          <target state="translated">しかし、あなたのポリシーがそうでない限り、これが正しいかどうかを推測することはできません。ユーザーに聞いてみるのが一番です。</target>
        </trans-unit>
        <trans-unit id="4b9905ad0aeb95ca50441bf7c28631173d039f82" translate="yes" xml:space="preserve">
          <source>But you still have those funny select()s. So just use the FileHandle module. Now, you can access these special variables using lowercase method names instead:</source>
          <target state="translated">しかし、おかしな select()があることに変わりはありません。ですから、FileHandle モジュールを使用してください。これで、これらの特別な変数には小文字のメソッド名を使ってアクセスできるようになりました。</target>
        </trans-unit>
        <trans-unit id="c127d3080f3bd57d92c9f856e712493975078203" translate="yes" xml:space="preserve">
          <source>But you still have to localize it for all the languages you're producing this software for, so you pull Locale::gettext off of CPAN so you can access the &lt;code&gt;gettext&lt;/code&gt; C functions you've heard are standard for localization tasks.</source>
          <target state="translated">ただし、このソフトウェアを作成しているすべての言語にローカライズする必要があるため、CPANからLocale :: gettextをプルして、ローカリゼーションタスクの標準であると聞いた &lt;code&gt;gettext&lt;/code&gt; C関数にアクセスできるようにします。</target>
        </trans-unit>
        <trans-unit id="77a3c4f45d8b18ec4a584229683442d84d642772" translate="yes" xml:space="preserve">
          <source>But you then read in the gettext manual (Drepper, Miller, and Pinard 1995) that this is not a good idea, since how a single word like &quot;directory&quot; or &quot;directories&quot; is translated may depend on context -- and this is true, since in a case language like German or Russian, you'd may need these words with a different case ending in the first instance (where the word is the object of a verb) than in the second instance, which you haven't even gotten to yet (where the word is the object of a preposition, &quot;in %g directories&quot;) -- assuming these keep the same syntax when translated into those languages.</source>
          <target state="translated">しかし、gettext のマニュアル (Drepper,Miller,and Pinard 1995)を読むと、これは良い考えではないと書かれています。なぜなら、&quot;directory&quot; や &quot;directories&quot; のような単一の単語がどのように翻訳されるかは文脈に依存するからです。これらの単語は、最初のインスタンス (単語が動詞の目的語である場合)と、2 番目のインスタンス (単語が前置詞の目的語である場合、&quot;in %g ディレクトリ&quot; のような)とでは、異なるケースの語尾を持つ単語が必要になるかもしれません --これらの言語に翻訳されたときに同じ構文を維持すると仮定します。</target>
        </trans-unit>
        <trans-unit id="d919612387e489786e93250f1cb6101f4eb4f66e" translate="yes" xml:space="preserve">
          <source>But!</source>
          <target state="translated">But!</target>
        </trans-unit>
        <trans-unit id="45dd0cd91dc6886148fd373bfb4f17c3a9594ab0" translate="yes" xml:space="preserve">
          <source>But, by extracting the directive using &lt;code&gt;extract_codeblock($text, '{}', &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, '&amp;lt;&amp;gt;')&lt;/code&gt; the '&amp;gt;' character is only treated as a delimited at the outermost level of the code block, so the directive is parsed correctly.</source>
          <target state="translated">ただし、 &lt;code&gt;extract_codeblock($text, '{}', &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;, '&amp;lt;&amp;gt;')&lt;/code&gt; を使用してディレクティブを抽出すると、 '&amp;gt;'文字はコードブロックの最も外側のレベルで区切られたものとしてのみ扱われるため、ディレクティブは正しく解析されます。</target>
        </trans-unit>
        <trans-unit id="30f80e7cf502991565c61822cae8756f6fbb85c6" translate="yes" xml:space="preserve">
          <source>But, by extracting the directive using &lt;code&gt;extract_codeblock($text, '{}', undef, '&amp;lt;&amp;gt;')&lt;/code&gt; the '&amp;gt;' character is only treated as a delimited at the outermost level of the code block, so the directive is parsed correctly.</source>
          <target state="translated">ただし、 &lt;code&gt;extract_codeblock($text, '{}', undef, '&amp;lt;&amp;gt;')&lt;/code&gt; を使用してディレクティブを抽出することにより、 '&amp;gt;'文字はコードブロックの最も外側のレベルで区切られたものとしてのみ扱われるため、ディレクティブは正しく解析されます。 。</target>
        </trans-unit>
        <trans-unit id="d9550f9852e2d8ab541a52ef7f81900ea09883af" translate="yes" xml:space="preserve">
          <source>But, even for portable ranges, it is not generally obvious what is included without having to look things up in the manual. A sound principle is to use only ranges that both begin from, and end at, either ASCII alphabetics of equal case (&lt;code&gt;b-e&lt;/code&gt;, &lt;code&gt;B-E&lt;/code&gt;), or digits (&lt;code&gt;1-4&lt;/code&gt;). Anything else is unclear (and unportable unless &lt;code&gt;\N{...}&lt;/code&gt; is used). If in doubt, spell out the character sets in full.</source>
          <target state="translated">しかし、ポータブルレンジの場合でも、マニュアルで調べなくても、何が含まれているのかは一般的に明らかではありません。健全な原則は、大文字と小文字が等しいASCIIアルファベット（ &lt;code&gt;b-e&lt;/code&gt; 、 &lt;code&gt;B-E&lt;/code&gt; ）または数字（ &lt;code&gt;1-4&lt;/code&gt; ）のいずれかで始まり、終わる範囲のみを使用することです。それ以外は不明確です（ &lt;code&gt;\N{...}&lt;/code&gt; を使用しない限り移植できません）。疑わしい場合は、文字セットを完全に説明してください。</target>
        </trans-unit>
        <trans-unit id="64523236f0a5dcac7b40cdaff74c2e2dc5991adf" translate="yes" xml:space="preserve">
          <source>But, starting with Perl v5.28, locales are thread-safe on platforms that support this functionality. Windows has this starting with Visual Studio 2005. Many other modern platforms support the thread-safe POSIX 2008 functions. The C &lt;code&gt;#define&lt;/code&gt;&lt;code&gt;USE_THREAD_SAFE_LOCALE&lt;/code&gt; will be defined iff this build is using these. From Perl-space, the read-only variable &lt;code&gt;${SAFE_LOCALES}&lt;/code&gt; is 1 if either the build is not threaded, or if &lt;code&gt;USE_THREAD_SAFE_LOCALE&lt;/code&gt; is defined; otherwise it is 0.</source>
          <target state="translated">ただし、Perl v5.28以降、ロケールはこの機能をサポートするプラットフォームでスレッドセーフになります。 Windowsには、Visual Studio 2005以降のこれがあります。他の多くの最新プラットフォームは、スレッドセーフなPOSIX2008関数をサポートしています。 Cの &lt;code&gt;#define&lt;/code&gt; &lt;code&gt;USE_THREAD_SAFE_LOCALE&lt;/code&gt; は、これらを使用している場合に限っこのビルドに定義されます。 Perlスペースから、ビルドがスレッド化されていない場合、または &lt;code&gt;USE_THREAD_SAFE_LOCALE&lt;/code&gt; が定義されている場合、読み取り専用変数 &lt;code&gt;${SAFE_LOCALES}&lt;/code&gt; は1です。それ以外の場合は0です。</target>
        </trans-unit>
        <trans-unit id="adebbf716096e26741f223bcfa719eec45495d73" translate="yes" xml:space="preserve">
          <source>Buzzword: Concision</source>
          <target state="translated">バズワード:精確</target>
        </trans-unit>
        <trans-unit id="b968913e712f1017ea8c46a9442142f5b0258e4f" translate="yes" xml:space="preserve">
          <source>Buzzword: Inheritance</source>
          <target state="translated">バズワード:相続</target>
        </trans-unit>
        <trans-unit id="ca9a9237da961c2681cd1e9d5c45f274b009d9f4" translate="yes" xml:space="preserve">
          <source>Buzzword: Isomorphism</source>
          <target state="translated">バズワード:同型性</target>
        </trans-unit>
        <trans-unit id="caad58d09c49a59cd7461be6687704deef207767" translate="yes" xml:space="preserve">
          <source>Buzzwords: Abstraction and Encapsulation</source>
          <target state="translated">バズワード。抽象化とカプセル化</target>
        </trans-unit>
        <trans-unit id="25b354100dcfbea76bd0e9e5a69bf58ebc32ab47" translate="yes" xml:space="preserve">
          <source>By calling the class method &lt;code&gt;Math::Complex::display_format&lt;/code&gt; and supplying either &lt;code&gt;&quot;polar&quot;&lt;/code&gt; or &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; as an argument, you override the default display style, which is &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; . Not supplying any argument returns the current settings.</source>
          <target state="translated">クラスメソッド &lt;code&gt;Math::Complex::display_format&lt;/code&gt; を呼び出し、引数として &lt;code&gt;&quot;polar&quot;&lt;/code&gt; または &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; を指定すると、デフォルトの表示スタイルである &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; をオーバーライドします。引数を指定しないと、現在の設定が返されます。</target>
        </trans-unit>
        <trans-unit id="43dd785845dcbec8cafe7f755ed628d733e41645" translate="yes" xml:space="preserve">
          <source>By calling the class method &lt;code&gt;Math::Complex::display_format&lt;/code&gt; and supplying either &lt;code&gt;&quot;polar&quot;&lt;/code&gt; or &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; as an argument, you override the default display style, which is &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt;. Not supplying any argument returns the current settings.</source>
          <target state="translated">クラスメソッド &lt;code&gt;Math::Complex::display_format&lt;/code&gt; を呼び出し、引数として &lt;code&gt;&quot;polar&quot;&lt;/code&gt; または &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; を指定することにより、デフォルトの表示スタイルである &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; をオーバーライドします。引数を指定しないと、現在の設定が返されます。</target>
        </trans-unit>
        <trans-unit id="cfd6475e714f8f18a3dfbb9986cb52d7a25b9828" translate="yes" xml:space="preserve">
          <source>By carefully looking at the encoded byte sequence, you can find that the byte sequence conforms a unique number. In that sense, EUC is a CCS generated by a CES above from up to four CCS (complicated?). UTF-8 falls into this category. See &lt;a href=&quot;perlunicode#UTF-8&quot;&gt;&quot;UTF-8&quot; in perlUnicode&lt;/a&gt; to find out how UTF-8 maps Unicode to a byte sequence.</source>
          <target state="translated">エンコードされたバイトシーケンスを注意深く見ると、バイトシーケンスが一意の番号に準拠していることがわかります。その意味で、EUCは、最大4つのCCSから上記のCESによって生成されたCCSです（複雑ですか？）。UTF-8はこのカテゴリに分類されます。UTF-8がUnicodeをバイトシーケンスにマップする方法について&lt;a href=&quot;perlunicode#UTF-8&quot;&gt;は、perlUnicodeの「UTF-8」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="27d08c1f941525ad751e4a25955a26ef38161991" translate="yes" xml:space="preserve">
          <source>By contrast, if</source>
          <target state="translated">対照的に</target>
        </trans-unit>
        <trans-unit id="d13b7913a7d5727103d5a0ff02bb43cd904ec898" translate="yes" xml:space="preserve">
          <source>By convention, CPAN Digest modules do &lt;b&gt;not&lt;/b&gt; pad their Base64 output. Problems can occur when feeding such digests to other software that expects properly padded Base64 encodings.</source>
          <target state="translated">慣例により、CPANダイジェストモジュールはBase64出力をパディングしませ&lt;b&gt;ん&lt;/b&gt;。適切にパディングされたBase64エンコーディングを期待する他のソフトウェアにそのようなダイジェストを供給するとき、問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="fa63c3f7831848cc55dec885e0aadbe7e110091f" translate="yes" xml:space="preserve">
          <source>By convention, all the calls to OS/2 API should indicate their failures by resetting $^E. All the Perl-accessible functions which call OS/2 API may be broken into two classes: some die()s when an API error is encountered, the other report the error via a false return value (of course, this does not concern Perl-accessible functions which</source>
          <target state="translated">慣例では、OS/2 APIへのすべての呼び出しは、$^Eをリセットすることで失敗を示すべきです。OS/2 APIを呼び出すすべてのPerlアクセス可能な関数は、2つのクラスに分けることができます:いくつかはAPIエラーが発生したときにdie()し、もう一つはfalseの戻り値を使ってエラーを報告します(もちろん、これは</target>
        </trans-unit>
        <trans-unit id="98616871ec55526e1b310a455ba5f2d84e33363e" translate="yes" xml:space="preserve">
          <source>By convention, check routines have names &lt;code&gt;ck_*&lt;/code&gt; . They are usually called from &lt;code&gt;new*OP&lt;/code&gt; subroutines (or &lt;code&gt;convert&lt;/code&gt; ) (which in turn are called from</source>
          <target state="translated">慣例により、チェックルーチンの名前は &lt;code&gt;ck_*&lt;/code&gt; です。これらは通常、 &lt;code&gt;new*OP&lt;/code&gt; サブルーチン（または &lt;code&gt;convert&lt;/code&gt; ）から呼び出されます（これらは次に呼び出されます）</target>
        </trans-unit>
        <trans-unit id="21e06347ae19cac9895adb4f7e858bf0ed8086b5" translate="yes" xml:space="preserve">
          <source>By convention, check routines have names &lt;code&gt;ck_*&lt;/code&gt;. They are usually called from &lt;code&gt;new*OP&lt;/code&gt; subroutines (or &lt;code&gt;convert&lt;/code&gt;) (which in turn are called from</source>
          <target state="translated">慣例により、チェックルーチンの名前は &lt;code&gt;ck_*&lt;/code&gt; です。これらは通常、 &lt;code&gt;new*OP&lt;/code&gt; サブルーチン（または &lt;code&gt;convert&lt;/code&gt; ）から呼び出されます（これらは、から呼び出されます）</target>
        </trans-unit>
        <trans-unit id="3ac2669af1abb44ebf6531e7e05b8563aa92056a" translate="yes" xml:space="preserve">
          <source>By convention, each test is assigned a number in order. This is largely done automatically for you. However, it's often very useful to assign a name to each test. Which would you rather see:</source>
          <target state="translated">慣例では、各テストには順番に番号が割り当てられています。これは大抵の場合、自動的に行われます。しかし、各テストに名前を割り当てることは非常に便利なことがよくあります。あなたはどちらを見たいですか?</target>
        </trans-unit>
        <trans-unit id="9314c5f036387917642398c26237bf03490cfd4b" translate="yes" xml:space="preserve">
          <source>By default</source>
          <target state="translated">デフォルトでは</target>
        </trans-unit>
        <trans-unit id="a90acddb58b18220dbe08ab0b09969aa5f8ece27" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;$i-&amp;gt;inflate($input, $output)&lt;/code&gt; will uncompress</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;$i-&amp;gt;inflate($input, $output)&lt;/code&gt; は解凍されます</target>
        </trans-unit>
        <trans-unit id="2b6ad4cdfaab155648e7ab26ef526a2e2f9bb93e" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; will build with a private copy of version 1.2.5 of the zlib library. (See the</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;Compress::Raw::Zlib&lt;/code&gt; は、zlibライブラリのバージョン1.2.5のプライベートコピーを使用してビルドします。（を参照してください</target>
        </trans-unit>
        <trans-unit id="13d1bc9ce24c11cc5f6efdcd3fee51a91c8038f7" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Hash::Util&lt;/code&gt; does not export anything.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;Hash::Util&lt;/code&gt; は何もエクスポートしません。</target>
        </trans-unit>
        <trans-unit id="62c898d4495e40824d05af53004d3c74a134ca35" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; will</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;IO::Uncompress::Bunzip2&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="7bbc45d166d6a142bcf7adafd5a3ff246af5dec6" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;IO::Uncompress::Bzip2&lt;/code&gt; will only uncompress the first bzip2 data stream in a pbzip2 file. To uncompress the complete pbzip2 file you must include the &lt;code&gt;MultiStream&lt;/code&gt; option, like this.</source>
          <target state="translated">デフォルトでは、 &lt;code&gt;IO::Uncompress::Bzip2&lt;/code&gt; はpbzip2ファイルの最初のbzip2データストリームのみを解凍します。完全pbzip2ファイルを解凍するには、含まれている必要があり &lt;code&gt;MultiStream&lt;/code&gt; 、このようなオプションを、。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
