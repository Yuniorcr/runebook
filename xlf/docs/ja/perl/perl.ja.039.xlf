<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="f0a36e2858858b02958d2f9bb2e7a02778b6e7c8" translate="yes" xml:space="preserve">
          <source>If you haven't already, before reading this document, you should become familiar with both &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; and &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">このドキュメントを読む前に、&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;と&lt;a href=&quot;perluniintro&quot;&gt;perluniintroの&lt;/a&gt;両方に慣れておく必要があります。</target>
        </trans-unit>
        <trans-unit id="4f5cd5895b74e660a355a89bb89cfe0d64a65e68" translate="yes" xml:space="preserve">
          <source>If you haven't read &lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt; and &lt;a href=&quot;perlhacktut&quot;&gt;perlhacktut&lt;/a&gt; yet, you might want to do that first.</source>
          <target state="translated">&lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt;と&lt;a href=&quot;perlhacktut&quot;&gt;perlhacktutを&lt;/a&gt;まだ読んでいない場合は、最初にそれを読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="9d18cc6d1bb045c22ff75a5143e7edc7882d3f36" translate="yes" xml:space="preserve">
          <source>If you haven't read &lt;a href=&quot;perlhack&quot;&gt;perlhack&lt;/a&gt; yet, go do that first! You might also want to read through &lt;a href=&quot;perlsource&quot;&gt;perlsource&lt;/a&gt; too.</source>
          <target state="translated">まだ&lt;a href=&quot;perlhack&quot;&gt;perlhackを&lt;/a&gt;読んでいない場合は、最初に読んでください！また、&lt;a href=&quot;perlsource&quot;&gt;perlsource&lt;/a&gt;も一読することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="0c78c6e524a1994f83a33a6fe7a18f30be9a7fce" translate="yes" xml:space="preserve">
          <source>If you haven't used regular expressions before, a quick-start introduction is available in &lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt;, and a longer tutorial introduction is available in &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;.</source>
          <target state="translated">以前に正規表現を使用したことがない場合は、クイックスタートの&lt;a href=&quot;perlrequick&quot;&gt;概要がperlrequick&lt;/a&gt;で利用でき、より長いチュートリアルの&lt;a href=&quot;perlretut&quot;&gt;概要がperlretut&lt;/a&gt;で利用できます。</target>
        </trans-unit>
        <trans-unit id="523b01060cd2a1e79d110af4dcfaa137536eb9a5" translate="yes" xml:space="preserve">
          <source>If you haven't used regular expressions before, a tutorial introduction is available in &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt;. If you know just a little about them, a quick-start introduction is available in &lt;a href=&quot;perlrequick&quot;&gt;perlrequick&lt;/a&gt;.</source>
          <target state="translated">これまで正規表現を使用したことがない場合は、&lt;a href=&quot;perlretut&quot;&gt;perlretutで&lt;/a&gt;チュートリアルの紹介を利用できます。それらについて少し知っている場合は、&lt;a href=&quot;perlrequick&quot;&gt;perlrequickで&lt;/a&gt;クイックスタートの紹介を利用できます。</target>
        </trans-unit>
        <trans-unit id="3a7a1d83ca677617a38c3a7af6a10c7ed341f9e8" translate="yes" xml:space="preserve">
          <source>If you haven't yet moved &lt;code&gt;perl*.dll&lt;/code&gt; onto LIBPATH, do it now.</source>
          <target state="translated">&lt;code&gt;perl*.dll&lt;/code&gt; をまだLIBPATHに移動していない場合は、ここで移動してください。</target>
        </trans-unit>
        <trans-unit id="83593b846f63af31e001bdf82839b9a46da47025" translate="yes" xml:space="preserve">
          <source>If you ignore all the error checking that most of the code does, the essence of the filter is as follows:</source>
          <target state="translated">コードのほとんどが行っているエラーチェックをすべて無視すると、フィルタの本質は次のようになります。</target>
        </trans-unit>
        <trans-unit id="4660b183b00b39c6b2b92484fb7503359beb8635" translate="yes" xml:space="preserve">
          <source>If you import &lt;code&gt;:constants256&lt;/code&gt; , you can use the following constants directly:</source>
          <target state="translated">&lt;code&gt;:constants256&lt;/code&gt; をインポートする場合、次の定数を直接使用できます。</target>
        </trans-unit>
        <trans-unit id="6fb29858655e86b9cd846e89d6a53be9482baa8e" translate="yes" xml:space="preserve">
          <source>If you import &lt;code&gt;:constants256&lt;/code&gt;, you can use the following constants directly:</source>
          <target state="translated">&lt;code&gt;:constants256&lt;/code&gt; をインポートする場合、次の定数を直接使用できます。</target>
        </trans-unit>
        <trans-unit id="ed57c7ce00df9ba4b19fb6493a06d874c07ba72a" translate="yes" xml:space="preserve">
          <source>If you insist on using bare v-strings with Perl &amp;gt; 5.6.0, be aware of the following limitations:</source>
          <target state="translated">Perl&amp;gt; 5.6.0で裸のv文字列を使用することを主張する場合は、次の制限に注意してください。</target>
        </trans-unit>
        <trans-unit id="f87b608eeb1cdc6eb4d8977d4b889a03e6d083dd" translate="yes" xml:space="preserve">
          <source>If you intend making use of the object returned from either tie() or tied(), and if the tie's target class defines a destructor, there is a subtle gotcha you</source>
          <target state="translated">tie()または tied()から返されたオブジェクトを使用したい場合で、 tie のターゲットクラスがデストラクタを定義している場合は、微妙なガチャがあります。</target>
        </trans-unit>
        <trans-unit id="dbdc31314e86dc1060f92b8ed429f69bdf25f6be" translate="yes" xml:space="preserve">
          <source>If you intend to manipulate the Zip64 zip files created with &lt;code&gt;IO-Compress-Zip&lt;/code&gt; using an external zip/unzip, make sure that it supports Zip64.</source>
          <target state="translated">&lt;code&gt;IO-Compress-Zip&lt;/code&gt; で作成されたZip64zipファイルを外部のzip / unzipを使用して操作する場合は、Zip64がサポートされていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="8bc6f9a7f0a4b90e4946e190029eff70ef889753" translate="yes" xml:space="preserve">
          <source>If you intend to manipulate the Zip64 zip files created with this module using an external zip/unzip, make sure that it supports Zip64.</source>
          <target state="translated">このモジュールで作成された Zip64 zip ファイルを外部の zip/unzip を使って操作する場合は、それが Zip64 をサポートしていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="fd3a1f6a190142b4a94b8f1071ccacb0e45694c8" translate="yes" xml:space="preserve">
          <source>If you intend to run only on FAT (or if using AnyDBM_File on FAT), run Configure with the -Ui_ndbm and -Ui_dbm options to prevent NDBM_File and ODBM_File being built.</source>
          <target state="translated">FAT上でのみ実行する場合(またはFAT上でAnyDBM_Fileを使用している場合)は、-Ui_ndbmと-Ui_dbmオプションを指定してConfigureを実行し、NDBM_FileとODBM_Fileがビルドされないようにしてください。</target>
        </trans-unit>
        <trans-unit id="3f04b70c5edf0d8a2ff6b52a2e5a3c4237fee493" translate="yes" xml:space="preserve">
          <source>If you intend using the Filter::Call functionality, I would strongly recommend that you check out Damian Conway's excellent Filter::Simple module. Damian's module provides a much cleaner interface than Filter::Util::Call. Although it doesn't allow the fine control that Filter::Util::Call does, it should be adequate for the majority of applications. It's available at</source>
          <target state="translated">Filter::Call の機能を使うつもりなら、Damian Conway の優れた Filter::Simple モジュールをチェックすることを強くお勧めします。Damian のモジュールは Filter::Util::Call よりもはるかにクリーンなインターフェイスを提供しています。Filter::Util::Call のような細かい制御はできませんが、大多数のアプリケーションには十分でしょう。このモジュールは</target>
        </trans-unit>
        <trans-unit id="e2cffac6976f9820e2e90021e812ad7d58d0f5b4" translate="yes" xml:space="preserve">
          <source>If you intended for the subroutine to be eligible for inlining, then make sure the variable is not referenced elsewhere, possibly by copying it:</source>
          <target state="translated">サブルーチンがインライン化の対象になるように意図しているのであれば、その変数が他の場所で参照されていないことを確認してください。</target>
        </trans-unit>
        <trans-unit id="9dab4bde5120fee3a0a7f6db844ef859c18d4c68" translate="yes" xml:space="preserve">
          <source>If you invoke Concise more than once in a program, you should know that the options are 'sticky'. This means that the options you provide in the first call will be remembered for the 2nd call, unless you re-specify or change them.</source>
          <target state="translated">プログラムの中で Concise を何度も起動した場合、オプションは「スティッキー」であることを知っておく必要があります。これは、最初の呼び出しで指定したオプションは2回目の呼び出しでも記憶されることを意味します。</target>
        </trans-unit>
        <trans-unit id="50093622d9b6b20299be5b789440addca54eb16b" translate="yes" xml:space="preserve">
          <source>If you invoke Perl with the &lt;b&gt;-d&lt;/b&gt; switch, your script runs under the Perl source debugger. This works like an interactive Perl environment, prompting for debugger commands that let you examine source code, set breakpoints, get stack backtraces, change the values of variables, etc. This is so convenient that you often fire up the debugger all by itself just to test out Perl constructs interactively to see what they do. For example:</source>
          <target state="translated">&lt;b&gt;-d&lt;/b&gt;スイッチを使用してPerlを呼び出す場合、スクリプトはPerlソースデバッガーの下で実行されます。これはインタラクティブなPerl環境のように機能し、ソースコードの調査、ブレークポイントの設定、スタックのバックトレースの取得、変数の値の変更などを可能にするデバッガーコマンドを要求します。 Perl構造を対話的にテストして、それらが何をするかを確認します。例えば：</target>
        </trans-unit>
        <trans-unit id="5f165a45e66d1014a54e531d87cac35b6f25f848" translate="yes" xml:space="preserve">
          <source>If you iterate through the hash with each(), you can delete the key most recently returned without worrying about it. If you delete or add other keys, the iterator may skip or double up on them since perl may rearrange the hash table. See the entry for &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">each（）でハッシュを反復処理する場合、心配することなく、最後に返されたキーを削除できます。他のキーを削除または追加すると、perlがハッシュテーブルを再配置する可能性があるため、イテレータがそれらのキーをスキップまたは倍にする可能性があります。&lt;a href=&quot;perlfunc&quot;&gt;perlfuncの&lt;/a&gt; &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; のエントリを参照してください。</target>
        </trans-unit>
        <trans-unit id="1d81db3e7b1b60ae3b2c12b8158af75032cae4b4" translate="yes" xml:space="preserve">
          <source>If you iterate through the hash with each(), you can delete the key most recently returned without worrying about it. If you delete or add other keys, the iterator may skip or double up on them since perl may rearrange the hash table. See the entry for &lt;code&gt;each()&lt;/code&gt; in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">each（）を使用してハッシュを反復処理すると、最後に返されたキーを気にせずに削除できます。他のキーを削除または追加すると、perlがハッシュテーブルを再配置する可能性があるため、イテレータはそれらをスキップまたは2倍にする可能性があります。&lt;a href=&quot;perlfunc&quot;&gt;perlfuncの&lt;/a&gt; &lt;code&gt;each()&lt;/code&gt; のエントリを参照してください。</target>
        </trans-unit>
        <trans-unit id="e23dd3433d5c0c9ce07c89417e11d9a477ce1b1b" translate="yes" xml:space="preserve">
          <source>If you just need to customize the objects on creation, subclass &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_iterator_factory&quot;&gt;&quot;make_iterator_factory&quot;&lt;/a&gt;.</source>
          <target state="translated">作成時にオブジェクトをカスタマイズする必要がある場合は、&lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser&lt;/a&gt;をサブクラス化し、&lt;a href=&quot;#make_iterator_factory&quot;&gt;「make_iterator_factory」&lt;/a&gt;をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="96bb290aa78bc388524149987ffa684a6cd88006" translate="yes" xml:space="preserve">
          <source>If you just need to customize the objects on creation, subclass &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_iterator_factory&quot;&gt;make_iterator_factory&lt;/a&gt;.</source>
          <target state="translated">作成時にオブジェクトをカスタマイズするだけの場合は、&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt;をサブクラス化し、&lt;a href=&quot;#make_iterator_factory&quot;&gt;make_iterator_factory&lt;/a&gt;をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="8d8b361c59c621bac0b0795b77d82ce0376ae0d6" translate="yes" xml:space="preserve">
          <source>If you just want the bytes printed in a 7bit NUL-terminated string, you can just use &lt;code&gt;%s&lt;/code&gt; (assuming they are all really only 7bit). But if there is a possibility the value will be encoded as UTF-8 or contains bytes above &lt;code&gt;0x7F&lt;/code&gt; (and therefore 8bit), you should instead use the &lt;code&gt;UTF8f&lt;/code&gt; format. And as its parameter, use the &lt;code&gt;UTF8fARG()&lt;/code&gt; macro:</source>
          <target state="translated">バイトを7ビットのNULで終了する文字列で出力するだけの場合は、 &lt;code&gt;%s&lt;/code&gt; を使用できます（すべてが実際には7ビットのみであると想定）。ただし、値がUTF-8としてエンコードされるか、 &lt;code&gt;0x7F&lt;/code&gt; （したがって8ビット）を超えるバイトが含まれる可能性がある場合は、代わりに &lt;code&gt;UTF8f&lt;/code&gt; 形式を使用する必要があります。そして、そのパラメーターとして、 &lt;code&gt;UTF8fARG()&lt;/code&gt; マクロを使用します。</target>
        </trans-unit>
        <trans-unit id="1eae7a7eb8bcc1fc11d062386801944953ed61fe" translate="yes" xml:space="preserve">
          <source>If you just want to extract, use the &lt;code&gt;extract_archive&lt;/code&gt; class method instead. It will optimize and write to disk immediately.</source>
          <target state="translated">抽出するだけの場合は、代わりに &lt;code&gt;extract_archive&lt;/code&gt; クラスメソッドを使用します。それは最適化し、すぐにディスクに書き込みます。</target>
        </trans-unit>
        <trans-unit id="205b6c9376bdc41030a3ba0411b3c133175a1cfb" translate="yes" xml:space="preserve">
          <source>If you just want to know how to use the utilities described here,</source>
          <target state="translated">ここで説明されているユーティリティの使い方を知りたいだけならば</target>
        </trans-unit>
        <trans-unit id="5ca84053d1241bb168ed3733abf9fe5fef328612" translate="yes" xml:space="preserve">
          <source>If you just want to load a module in a test, we recommend simply using &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; directly. It will cause the test to stop.</source>
          <target state="translated">テストでモジュールをロードするだけの場合は、単に &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; を直接使用することをお勧めします。テストが停止します。</target>
        </trans-unit>
        <trans-unit id="2c70a28f88935f71d3cc2f51d7cbe4011451f638" translate="yes" xml:space="preserve">
          <source>If you just want to load a module in a test, we recommend simply using &lt;code&gt;use&lt;/code&gt; directly. It will cause the test to stop.</source>
          <target state="translated">テストでモジュールをロードするだけの場合は、 &lt;code&gt;use&lt;/code&gt; を直接使用することをお勧めします。テストが停止します。</target>
        </trans-unit>
        <trans-unit id="b5383a5a1f3fb1c8ecb11208a275376f630d5aac" translate="yes" xml:space="preserve">
          <source>If you just want to sort keys (names) in JSON objects when you &lt;code&gt;encode&lt;/code&gt;, enable &lt;code&gt;canonical&lt;/code&gt; option (see above) that allows you to sort object keys alphabetically.</source>
          <target state="translated">&lt;code&gt;encode&lt;/code&gt; 時にJSONオブジェクトのキー（名前）を並べ替えるだけの場合は、オブジェクトキーをアルファベット順に並べ替えることができる &lt;code&gt;canonical&lt;/code&gt; オプション（上記を参照）を有効にします。</target>
        </trans-unit>
        <trans-unit id="58d9e2fc3089c3ee91bde03c8a168aabda14adca" translate="yes" xml:space="preserve">
          <source>If you just want to submit a single small patch like a pod fix, a test for a bug, comment fixes, etc., it's easy! Here's how:</source>
          <target state="translated">ポッドの修正、バグのテスト、コメントの修正など、小さなパッチを一つ提出したいだけなら、簡単です! 方法は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="a3962095233ae6bded8cb1555c84a52ea4fc9a0c" translate="yes" xml:space="preserve">
          <source>If you just want to test a module can be loaded, use &lt;code&gt;require_ok&lt;/code&gt; .</source>
          <target state="translated">ロードしたいモジュールをテストしたいだけなら &lt;code&gt;require_ok&lt;/code&gt; を使ってください。</target>
        </trans-unit>
        <trans-unit id="3978204bccf1fd47b9da04f6a2bf931fa35286f6" translate="yes" xml:space="preserve">
          <source>If you just want to test a module can be loaded, use &lt;code&gt;require_ok&lt;/code&gt;.</source>
          <target state="translated">モジュールをロードできるかどうかをテストするだけの場合は、 &lt;code&gt;require_ok&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="42e3b970aadb68ea3a8923d019f70d26e7a5a350" translate="yes" xml:space="preserve">
          <source>If you know</source>
          <target state="translated">もしあなたが知っているなら</target>
        </trans-unit>
        <trans-unit id="9c14b8eb60486ad1003f5f292ba8d0aaf7f2284e" translate="yes" xml:space="preserve">
          <source>If you know one name for a Unicode property, you can use &lt;code&gt;prop_aliases&lt;/code&gt; to find either the long name (when called in scalar context), or a list of all of the names, somewhat ordered so that the short name is in the 0th element, the long name in the next element, and any other synonyms are in the remaining elements, in no particular order.</source>
          <target state="translated">Unicodeプロパティの名前が1 &lt;code&gt;prop_aliases&lt;/code&gt; ている場合は、prop_aliasesを使用して、長い名前（スカラーコンテキストで呼び出された場合）またはすべての名前のリストを検索できます。これらの名前は、短い名前が0番目の要素になるように並べられています。次の要素のロングネームとその他の同義語は、残りの要素に特定の順序で含まれていません。</target>
        </trans-unit>
        <trans-unit id="cb42b2ab34d9ba0baed912ade71e395e6b67b39f" translate="yes" xml:space="preserve">
          <source>If you know that &lt;code&gt;$compressedLength&lt;/code&gt; isn't that big then using temporary storage won't be a problem. But if &lt;code&gt;$compressedLength&lt;/code&gt; is very large or you are writing an application that other people will use, and so have no idea how big &lt;code&gt;$compressedLength&lt;/code&gt; will be, it could be an issue.</source>
          <target state="translated">&lt;code&gt;$compressedLength&lt;/code&gt; がそれほど大きくないことがわかっている場合は、一時ストレージを使用しても問題はありません。ただし、 &lt;code&gt;$compressedLength&lt;/code&gt; が非常に大きい場合、または他の人が使用するアプリケーションを作成している場合、 &lt;code&gt;$compressedLength&lt;/code&gt; 大きさがわからない場合は問題になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="4a59a33095f0058eebdfd05ced2318493337053a" translate="yes" xml:space="preserve">
          <source>If you know the columns that contain the data, you can use &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; to extract a single column.</source>
          <target state="translated">データを含む列がわかっている場合は、 &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr&lt;/a&gt;&lt;/code&gt; を使用して単一の列を抽出できます。</target>
        </trans-unit>
        <trans-unit id="06cfb464d41fe790822610afbdaa468a829c60a7" translate="yes" xml:space="preserve">
          <source>If you know the columns that contain the data, you can use &lt;code&gt;substr&lt;/code&gt; to extract a single column.</source>
          <target state="translated">データを含む列がわかっている場合は、 &lt;code&gt;substr&lt;/code&gt; を使用して単一の列を抽出できます。</target>
        </trans-unit>
        <trans-unit id="9eb4c97e122131b8720d6a259fed14fb554c1b02" translate="yes" xml:space="preserve">
          <source>If you know the directory already, you can add it to &lt;code&gt;@INC&lt;/code&gt; as you would for any other directory. You might &amp;lt;use lib&amp;gt; if you know the directory at compile time:</source>
          <target state="translated">ディレクトリがすでにわかっている場合は、他のディレクトリと &lt;code&gt;@INC&lt;/code&gt; ように@INCに追加できます。コンパイル時にディレクトリがわかっている場合は、&amp;lt;libを使用&amp;gt;できます。</target>
        </trans-unit>
        <trans-unit id="a3a965f3de203e872ac1dbbc0191ed03e5d04a74" translate="yes" xml:space="preserve">
          <source>If you know the directory already, you can add it to &lt;code&gt;@INC&lt;/code&gt; as you would for any other directory. You might &lt;code&gt;use lib&lt;/code&gt; if you know the directory at compile time:</source>
          <target state="translated">ディレクトリがすでにわかっている場合は、他のディレクトリの場合と &lt;code&gt;@INC&lt;/code&gt; ように@INCに追加できます。コンパイル時にディレクトリがわかっている場合は &lt;code&gt;use lib&lt;/code&gt; できます。</target>
        </trans-unit>
        <trans-unit id="e98e61c08f8371d445ada91d42b0a6e31509fa7c" translate="yes" xml:space="preserve">
          <source>If you know the exact length in bits, it can be used in place of the &lt;code&gt;*&lt;/code&gt; .</source>
          <target state="translated">ビット単位で正確な長さがわかっている場合は、 &lt;code&gt;*&lt;/code&gt; の代わりに使用できます。</target>
        </trans-unit>
        <trans-unit id="6be1b2dd7aa390ceb8d695be13eb24892efb660c" translate="yes" xml:space="preserve">
          <source>If you know the exact length in bits, it can be used in place of the &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">ビット単位の正確な長さがわかっている場合は、 &lt;code&gt;*&lt;/code&gt; の代わりに使用できます。</target>
        </trans-unit>
        <trans-unit id="927bf5e4096ddfb3b14c96fc89123708e7ddad90" translate="yes" xml:space="preserve">
          <source>If you know the length of the compressed data stream before you start uncompressing, you can avoid having to use &lt;code&gt;trailingData&lt;/code&gt; by setting the &lt;code&gt;InputLength&lt;/code&gt; option in the constructor.</source>
          <target state="translated">圧縮 &lt;code&gt;InputLength&lt;/code&gt; を開始する前に圧縮データストリームの長さがわかっている場合は、コンストラクターでInputLengthオプションを設定することにより、 &lt;code&gt;trailingData&lt;/code&gt; を使用する必要を回避できます。</target>
        </trans-unit>
        <trans-unit id="f21638ec12744a0da920d55488938e9726007614" translate="yes" xml:space="preserve">
          <source>If you know the length of the compressed data stream before you start uncompressing, you can avoid having to use &lt;code&gt;trailingData&lt;/code&gt; by setting the &lt;code&gt;InputLength&lt;/code&gt; option.</source>
          <target state="translated">圧縮 &lt;code&gt;InputLength&lt;/code&gt; を開始する前に圧縮データストリームの長さがわかっている場合は、InputLengthオプションを設定することにより、 &lt;code&gt;trailingData&lt;/code&gt; を使用する必要がなくなります。</target>
        </trans-unit>
        <trans-unit id="d2ae57604fb0c858677a8a7bba0d622df68f1d53" translate="yes" xml:space="preserve">
          <source>If you know the name of a hash variable, you can get a pointer to its HV by using the following:</source>
          <target state="translated">ハッシュ変数の名前がわかれば、以下のようにしてHVへのポインタを取得することができます。</target>
        </trans-unit>
        <trans-unit id="eb63e6aa11dc04fb3c005505a5dc56980b836dee" translate="yes" xml:space="preserve">
          <source>If you know the name of a scalar variable, you can get a pointer to its SV by using the following:</source>
          <target state="translated">スカラ変数の名前がわかれば、以下のようにしてそのSVへのポインタを取得することができます。</target>
        </trans-unit>
        <trans-unit id="71cc5e317d663fb79a1bf1ed454222ec34ef184d" translate="yes" xml:space="preserve">
          <source>If you know the name of an array variable, you can get a pointer to its AV by using the following:</source>
          <target state="translated">配列変数の名前がわかれば、以下のようにしてそのAVへのポインタを取得することができます。</target>
        </trans-unit>
        <trans-unit id="cd318c8126ae3cf5cfc9e3d9345bc2d0fc779cdb" translate="yes" xml:space="preserve">
          <source>If you know what you are doing you can turn off this warning by &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'non_unicode';&lt;/code&gt; .</source>
          <target state="translated">何をしているのかわかっている場合は、 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'non_unicode';&lt;/code&gt; &lt;a href=&quot;functions/no&quot;&gt;という&lt;/a&gt;警告を表示せずにこの警告をオフにできます。。</target>
        </trans-unit>
        <trans-unit id="b884b7f1740fc7317e54fef08f2f9cd3cb14f5e3" translate="yes" xml:space="preserve">
          <source>If you know what you are doing you can turn off this warning by &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'surrogate';&lt;/code&gt; .</source>
          <target state="translated">何をしているのかわかっている場合は、 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'surrogate';&lt;/code&gt; &lt;a href=&quot;functions/no&quot;&gt;なしで&lt;/a&gt;この警告をオフにできます。。</target>
        </trans-unit>
        <trans-unit id="450cdd3bb7c30208da61bb587dafc55dbfb2d416" translate="yes" xml:space="preserve">
          <source>If you know what you are doing you can turn off this warning by &lt;code&gt;no warnings 'non_unicode';&lt;/code&gt;.</source>
          <target state="translated">何をしているのかがわかっている場合は、警告 &lt;code&gt;no warnings 'non_unicode';&lt;/code&gt; この警告をオフにすることができます 'non_unicode'; 。</target>
        </trans-unit>
        <trans-unit id="0bdb6f8f972275104dbb956312abdb2698ecb912" translate="yes" xml:space="preserve">
          <source>If you know what you are doing you can turn off this warning by &lt;code&gt;no warnings 'surrogate';&lt;/code&gt;.</source>
          <target state="translated">何をしているのかがわかっている場合は、警告 &lt;code&gt;no warnings 'surrogate';&lt;/code&gt; この警告をオフにすることができます 'サロゲート'; 。</target>
        </trans-unit>
        <trans-unit id="9e7e8e09f3e73c52948b41c1fa2c3d1d138db3f3" translate="yes" xml:space="preserve">
          <source>If you know you are only going to use a system that does correctly implement appending (i.e. not Win32) then you can omit the &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; from the code in the previous answer.</source>
          <target state="translated">付加を正しく実装する（つまり、Win32ではない）システムのみを使用することがわかっている場合は、前の回答のコードから &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; を省略できます。</target>
        </trans-unit>
        <trans-unit id="ba755cafcf3fda0933750ad2082aef00aba43d16" translate="yes" xml:space="preserve">
          <source>If you know you are only going to use a system that does correctly implement appending (i.e. not Win32) then you can omit the &lt;code&gt;seek&lt;/code&gt; from the code in the previous answer.</source>
          <target state="translated">追加を正しく実装する（つまり、Win32ではない）システムのみを使用することがわかっている場合は、前の回答のコードから &lt;code&gt;seek&lt;/code&gt; を省略できます。</target>
        </trans-unit>
        <trans-unit id="1148f14b2fe4053075a5db927cd2f992ce530c8c" translate="yes" xml:space="preserve">
          <source>If you know you are only writing code to run on an OS and filesystem that does implement append mode correctly (a local filesystem on a modern Unix for example), and you keep the file in block-buffered mode and you write less than one buffer-full of output between each manual flushing of the buffer then each bufferload is almost guaranteed to be written to the end of the file in one chunk without getting intermingled with anyone else's output. You can also use the &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; function which is simply a wrapper around your system's &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write(2)&lt;/a&gt;&lt;/code&gt; system call.</source>
          <target state="translated">追加モードを正しく実装するOSおよびファイルシステム（たとえば、最新のUnixのローカルファイルシステム）で実行するコードのみを記述していて、ファイルをブロックバッファーモードで保持し、1つ未満のバッファーを書き込む場合-手動でバッファをフラッシュするまでの出力でいっぱいになると、各バッファロードが他の人の出力と混ざることなく、1つのチャンクでファイルの最後に書き込まれることがほぼ保証されます。システムの &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write(2)&lt;/a&gt;&lt;/code&gt; システムコールの単なるラッパーである &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; 関数を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="602b87bd77bf909ec7f1749e9c4b42785a2cd907" translate="yes" xml:space="preserve">
          <source>If you know you are only writing code to run on an OS and filesystem that does implement append mode correctly (a local filesystem on a modern Unix for example), and you keep the file in block-buffered mode and you write less than one buffer-full of output between each manual flushing of the buffer then each bufferload is almost guaranteed to be written to the end of the file in one chunk without getting intermingled with anyone else's output. You can also use the &lt;code&gt;syswrite&lt;/code&gt; function which is simply a wrapper around your system's &lt;code&gt;write(2)&lt;/code&gt; system call.</source>
          <target state="translated">追加モードを正しく実装するOSとファイルシステム（たとえば、最新のUnixのローカルファイルシステム）で実行するコードのみを記述していて、ファイルをブロックバッファーモードに保ち、書き込むバッファーが1つ未満の場合-バッファの各手動フラッシュの間に出力がいっぱいになると、各バッファロードは、他の人の出力と混ざり合うことなく、1つのチャンクでファイルの最後に書き込まれることがほぼ保証されます。システムの &lt;code&gt;write(2)&lt;/code&gt; システムコールの単なるラッパーである &lt;code&gt;syswrite&lt;/code&gt; 関数を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="01c8e667e3ed1b51f8f2d44670f827394972704b" translate="yes" xml:space="preserve">
          <source>If you know your package, you can just mention it explicitly, as in $Some_Pack::var. Note that the notation $::var is &lt;b&gt;not&lt;/b&gt; the dynamic $var in the current package, but rather the one in the &quot;main&quot; package, as though you had written $main::var.</source>
          <target state="translated">パッケージがわかっている場合は、$ Some_Pack :: varのように、明示的に言及するだけです。表記$ :: varがあることに注意して&lt;b&gt;いない&lt;/b&gt;あなたは$メイン書かれていたかのように、現在のパッケージ内の動的の$ VARではなく、「メイン」のパッケージに1 :: VAR。</target>
        </trans-unit>
        <trans-unit id="283a4b9fbff3cde02d8b49d7e007e0e9915125fc" translate="yes" xml:space="preserve">
          <source>If you like a more web-like approach, a good start point can be &lt;a href=&quot;http://www14.software.ibm.com/webapp/download/downloadaz.jsp&quot;&gt;http://www14.software.ibm.com/webapp/download/downloadaz.jsp&lt;/a&gt; and click &quot;C for AIX&quot;, and follow the instructions.</source>
          <target state="translated">よりWebのようなアプローチが必要な場合は、&lt;a href=&quot;http://www14.software.ibm.com/webapp/download/downloadaz.jsp&quot;&gt;http：//www14.software.ibm.com/webapp/download/downloadaz.jsp&lt;/a&gt;から開始して「C for AIX」をクリックし、指示に従ってください。</target>
        </trans-unit>
        <trans-unit id="f15eb42f4edad457922247251c5d7e7bc14ff512" translate="yes" xml:space="preserve">
          <source>If you like the &lt;code&gt;prove&lt;/code&gt; utility and &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; but you want your own harness, all you need to do is write one and provide &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;runtests&lt;/code&gt; methods. Then you can use the &lt;code&gt;prove&lt;/code&gt; utility like so:</source>
          <target state="translated">あなたが好きなら &lt;code&gt;prove&lt;/code&gt; ユーティリティおよび&lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parserの&lt;/a&gt;が、あなたがあなた自身のハーネスをしたい、あなたがする必要があるのは、書き込み一つであり、提供 &lt;code&gt;new&lt;/code&gt; と &lt;code&gt;runtests&lt;/code&gt; と書い方法を。次に、次のように &lt;code&gt;prove&lt;/code&gt; rユーティリティを使用できます。</target>
        </trans-unit>
        <trans-unit id="b95d71103315a260f526ee0388cdf401d8ff3b71" translate="yes" xml:space="preserve">
          <source>If you like the &lt;code&gt;prove&lt;/code&gt; utility and &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; but you want your own harness, all you need to do is write one and provide &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;runtests&lt;/code&gt; methods. Then you can use the &lt;code&gt;prove&lt;/code&gt; utility like so:</source>
          <target state="translated">あなたが好きなら &lt;code&gt;prove&lt;/code&gt; ユーティリティおよび&lt;a href=&quot;parser&quot;&gt;TAP :: Parserの&lt;/a&gt;が、あなたがあなた自身のハーネスをしたい、あなたがする必要があるのは、書き込み一つであり、提供 &lt;code&gt;new&lt;/code&gt; と &lt;code&gt;runtests&lt;/code&gt; と書い方法を。その後、次のように &lt;code&gt;prove&lt;/code&gt; ユーティリティを使用できます。</target>
        </trans-unit>
        <trans-unit id="fbd3ba27ff3a08207feb966e075b2fa08e7cf809" translate="yes" xml:space="preserve">
          <source>If you like, you can store these filehandles in an array or a hash. If you access them directly, they aren't simple scalars and you need to give &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; a little help by placing the filehandle reference in braces. Perl can only figure it out on its own when the filehandle reference is a simple scalar.</source>
          <target state="translated">必要に応じて、これらのファイルハンドルを配列またはハッシュに保存できます。それらに直接アクセスする場合、それらは単純なスカラーではないため、ファイルハンドル参照を中括弧で囲んで &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; に少し助けを与える必要があります。Perlは、ファイルハンドル参照が単純なスカラーである場合にのみ、それ自体を理解できます。</target>
        </trans-unit>
        <trans-unit id="27d5798184dd1af5697105e7a8d7e3bef1780f00" translate="yes" xml:space="preserve">
          <source>If you like, you can store these filehandles in an array or a hash. If you access them directly, they aren't simple scalars and you need to give &lt;code&gt;print&lt;/code&gt; a little help by placing the filehandle reference in braces. Perl can only figure it out on its own when the filehandle reference is a simple scalar.</source>
          <target state="translated">必要に応じて、これらのファイルハンドルを配列またはハッシュに格納できます。それらに直接アクセスする場合、それらは単純なスカラーではないため、ファイルハンドル参照を中かっこで囲んで &lt;code&gt;print&lt;/code&gt; に少し役立つ必要があります。Perlは、ファイルハンドル参照が単純なスカラーである場合にのみ、それを単独で理解できます。</target>
        </trans-unit>
        <trans-unit id="d730d69794a1a0d8df4bc0eb2edfe8040f78af15" translate="yes" xml:space="preserve">
          <source>If you localize a special variable, you'll be giving a new value to it, but its magic won't go away. That means that all side-effects related to this magic still work with the localized value.</source>
          <target state="translated">特殊な変数をローカライズした場合、新しい値を与えることになりますが、そのマジックは消えません。つまり、このマジックに関連するすべての副作用は、ローカライズされた値でも機能するということです。</target>
        </trans-unit>
        <trans-unit id="c90f343f24019c1da72c48d70c317941a7498b61" translate="yes" xml:space="preserve">
          <source>If you localize an exported variable in a module, its exported value will not change. The local name becomes an alias to a new value but the external name is still an alias for the original.</source>
          <target state="translated">モジュール内でエクスポートされた変数をローカライズしても、エクスポートされた値は変わりません。ローカル名は新しい値のエイリアスになりますが、外部名は元の値のエイリアスのままです。</target>
        </trans-unit>
        <trans-unit id="dafcf35a82f601b489cfb5dd0eef86e45cb1372b" translate="yes" xml:space="preserve">
          <source>If you look at its source, you'll see that open2() uses low-level primitives like the pipe() and exec() syscalls to create all the connections. Although it might have been more efficient by using socketpair(), this would have been even less portable than it already is. The open2() and open3() functions are unlikely to work anywhere except on a Unix system, or at least one purporting POSIX compliance.</source>
          <target state="translated">そのソースを見てみると、open2()は pipe()や exec()のような低レベルのプリミティブを使ってすべての接続を作成していることがわかります。socketpair()を使うことでより効率的になったかもしれませんが、これは既にあるものよりも移植性が低いものになってしまいます。open2()と open3()関数は、Unix システムか、少なくとも POSIX 準拠を謳うシステム以外では動作しないでしょう。</target>
        </trans-unit>
        <trans-unit id="dba57ac6d2e87e59b7cd30bc2efe7662859d4f78" translate="yes" xml:space="preserve">
          <source>If you look at the contents of a database file created by DB_File, there can sometimes be part of a Perl script included in it.</source>
          <target state="translated">DB_Fileで作成されたデータベースファイルの内容を見ると、Perlスクリプトの一部が含まれていることがあります。</target>
        </trans-unit>
        <trans-unit id="9ffeef0f67f605dc88b0c1746d2c0bfb6febb326" translate="yes" xml:space="preserve">
          <source>If you make any changes that affect miniperl or core routines that have different code paths for miniperl, be sure to run &lt;code&gt;make minitest&lt;/code&gt;. This will catch problems that even the full test suite will not catch because it runs a subset of tests under miniperl rather than perl.</source>
          <target state="translated">miniperlまたはminiperlのコードパスが異なるコアルーチンに影響する変更を加える場合は、必ず &lt;code&gt;make minitest&lt;/code&gt; を実行してください。これにより、perlではなくminiperlでテストのサブセットを実行するため、完全なテストスイートでも検出できない問題が検出されます。</target>
        </trans-unit>
        <trans-unit id="6e077c0b0a12316fa45027aa958a68eefe5eb38b" translate="yes" xml:space="preserve">
          <source>If you make use of the Berkeley DB API, it is</source>
          <target state="translated">Berkeley DB APIを利用する場合は</target>
        </trans-unit>
        <trans-unit id="044615c04770ac7a0002f5e8d4d8dd2908b76278" translate="yes" xml:space="preserve">
          <source>If you may assume POSIX (a rather large assumption), you may read more about the POSIX locale system from &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;. The locale system at least attempts to make things a little bit more portable, or at least more convenient and native-friendly for non-English users. The system affects character sets and encoding, and date and time formatting--amongst other things.</source>
          <target state="translated">POSIX（かなり大規模な仮定）を想定している場合は、POSIXロケールシステムの詳細を&lt;a href=&quot;perllocale&quot;&gt;perllocaleで&lt;/a&gt;読むことができます。ロケールシステムは、少なくとも、移植性を少し高めようとするか、少なくとも英語以外のユーザーにとってより便利でネイティブフレンドリーになるようにします。システムは、文字セット、エンコーディング、日付と時刻のフォーマットなどに影響を与えます。</target>
        </trans-unit>
        <trans-unit id="a25944da5356d5910252ea9238bbb196b425ee18" translate="yes" xml:space="preserve">
          <source>If you memoize &lt;code&gt;getusers&lt;/code&gt; here, it will work right exactly once. The reference to the users list will be stored in the memo table. &lt;code&gt;main&lt;/code&gt; will discard the first element from the referenced list. The next time you invoke &lt;code&gt;main&lt;/code&gt; , &lt;code&gt;Memoize&lt;/code&gt; will not call &lt;code&gt;getusers&lt;/code&gt; ; it will just return the same reference to the same list it got last time. But this time the list has already had its head removed; &lt;code&gt;main&lt;/code&gt; will erroneously remove another element from it. The list will get shorter and shorter every time you call &lt;code&gt;main&lt;/code&gt; .</source>
          <target state="translated">ここでgetusersを &lt;code&gt;getusers&lt;/code&gt; すると、1回だけ正しく動作します。ユーザーリストへの参照は、メモテーブルに格納されます。 &lt;code&gt;main&lt;/code&gt; は、参照リストから最初の要素を破棄します。あなたが次に起動するとき &lt;code&gt;main&lt;/code&gt; 、 &lt;code&gt;Memoize&lt;/code&gt; は呼び出しません &lt;code&gt;getusers&lt;/code&gt; を。前回取得したのと同じリストへの同じ参照を返すだけです。しかし、今回はリストの頭がすでに取り除かれています。 &lt;code&gt;main&lt;/code&gt; は誤って別の要素を削除します。リストは &lt;code&gt;main&lt;/code&gt; を呼び出すたびに短くなります。</target>
        </trans-unit>
        <trans-unit id="ccab2ece05cb5161b728c7c08be08148f8aa1e6f" translate="yes" xml:space="preserve">
          <source>If you memoize &lt;code&gt;getusers&lt;/code&gt; here, it will work right exactly once. The reference to the users list will be stored in the memo table. &lt;code&gt;main&lt;/code&gt; will discard the first element from the referenced list. The next time you invoke &lt;code&gt;main&lt;/code&gt;, &lt;code&gt;Memoize&lt;/code&gt; will not call &lt;code&gt;getusers&lt;/code&gt;; it will just return the same reference to the same list it got last time. But this time the list has already had its head removed; &lt;code&gt;main&lt;/code&gt; will erroneously remove another element from it. The list will get shorter and shorter every time you call &lt;code&gt;main&lt;/code&gt;.</source>
          <target state="translated">ここでgetusersを &lt;code&gt;getusers&lt;/code&gt; すると、1回だけ正しく機能します。ユーザーリストへの参照はメモテーブルに保存されます。 &lt;code&gt;main&lt;/code&gt; は、参照リストの最初の要素を破棄します。あなたが次に起動するとき &lt;code&gt;main&lt;/code&gt; 、 &lt;code&gt;Memoize&lt;/code&gt; は呼び出しません &lt;code&gt;getusers&lt;/code&gt; を。前回取得したのと同じリストへの同じ参照を返すだけです。しかし今回は、リストの頭がすでに削除されています。 &lt;code&gt;main&lt;/code&gt; は、誤って別の要素を削除します。 &lt;code&gt;main&lt;/code&gt; を呼び出すたびに、リストはどんどん短くなります。</target>
        </trans-unit>
        <trans-unit id="cdcd78cb5551e89b0a93e6ea03193603933b2916" translate="yes" xml:space="preserve">
          <source>If you must obtain a context in a sub deeper than your entry point you can use this to tell it how many EXTRA stack frames to look back. If this option is not provided the default of &lt;code&gt;0&lt;/code&gt; is used.</source>
          <target state="translated">エントリポイントよりも深いサブでコンテキストを取得する必要がある場合は、これを使用して、振り返るEXTRAスタックフレームの数を指定できます。このオプションが指定されていない場合、デフォルトの &lt;code&gt;0&lt;/code&gt; が使用されます。</target>
        </trans-unit>
        <trans-unit id="69b7671e8edf51721ce7a662449c478e8b97bd95" translate="yes" xml:space="preserve">
          <source>If you need a copy of the string, see &lt;a href=&quot;#bytes_from_utf8&quot;&gt;&quot;bytes_from_utf8&quot;&lt;/a&gt;.</source>
          <target state="translated">文字列のコピーが必要な場合は、&lt;a href=&quot;#bytes_from_utf8&quot;&gt;「bytes_from_utf8」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="babf77ebcd09b5b6b24f3181921a88c6ea58626a" translate="yes" xml:space="preserve">
          <source>If you need a copy of the string, see &lt;a href=&quot;#bytes_from_utf8&quot;&gt;bytes_from_utf8&lt;/a&gt;.</source>
          <target state="translated">文字列のコピーが必要な場合は、&lt;a href=&quot;#bytes_from_utf8&quot;&gt;bytes_from_utf8を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e5f94b7a22fe122cef06ac242e6fea05a7455fe1" translate="yes" xml:space="preserve">
          <source>If you need a notation that's that powerful, use normal Perl:</source>
          <target state="translated">それほど強力な記法が必要な場合は、通常のPerlを使用してください。</target>
        </trans-unit>
        <trans-unit id="d3c247b2226d86ce39340fe5128412de0478e397" translate="yes" xml:space="preserve">
          <source>If you need an empty attribute list, for example in a code generator, add a space before the &lt;code&gt;=&lt;/code&gt; .</source>
          <target state="translated">コードジェネレーターなどで空の属性リストが必要な場合は、 &lt;code&gt;=&lt;/code&gt; の前にスペースを追加します。</target>
        </trans-unit>
        <trans-unit id="9ec51b16d80aba23cb27eed2f37d008fc8bfa32a" translate="yes" xml:space="preserve">
          <source>If you need an empty attribute list, for example in a code generator, add a space before the &lt;code&gt;=&lt;/code&gt;.</source>
          <target state="translated">コードジェネレーターなどで空の属性リストが必要な場合は、 &lt;code&gt;=&lt;/code&gt; の前にスペースを追加します。</target>
        </trans-unit>
        <trans-unit id="5df082bfa03c81e3a347168ac51e900439925f13" translate="yes" xml:space="preserve">
          <source>If you need both &lt;code&gt;next&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;, you have to do both and also use a loop label:</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; と &lt;code&gt;last&lt;/code&gt; の両方が必要な場合は、両方を実行し、ループラベルも使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="5bff095055ae8196964fe851c387b6ea9ca66a7f" translate="yes" xml:space="preserve">
          <source>If you need more advanced management of what runs in parallel vs in sequence, see the associated 'rules' documentation in &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; and &lt;a href=&quot;TAP::Parser::Scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;. If what's possible directly through &lt;code&gt;prove&lt;/code&gt; is not sufficient, you can write your own harness to access these features directly.</source>
          <target state="translated">並行して実行されるものと順番に実行されるもののより高度な管理が必要な場合は、&lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: Harness&lt;/a&gt;および&lt;a href=&quot;TAP::Parser::Scheduler&quot;&gt;TAP :: Parser :: Scheduler&lt;/a&gt;の関連する「ルール」のドキュメントを参照してください。 &lt;code&gt;prove&lt;/code&gt; を通じて直接可能であることが十分でない場合は、これらの機能に直接アクセスするための独自のハーネスを作成できます。</target>
        </trans-unit>
        <trans-unit id="82f75e54b3d41cd48a9f47dcdc6a65f36e63ccd0" translate="yes" xml:space="preserve">
          <source>If you need more advanced management of what runs in parallel vs in sequence, see the associated 'rules' documentation in &lt;a href=&quot;tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; and &lt;a href=&quot;tap/parser/scheduler&quot;&gt;TAP::Parser::Scheduler&lt;/a&gt;. If what's possible directly through &lt;code&gt;prove&lt;/code&gt; is not sufficient, you can write your own harness to access these features directly.</source>
          <target state="translated">並列実行と順次実行のより高度な管理が必要な場合は、&lt;a href=&quot;tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt;および&lt;a href=&quot;tap/parser/scheduler&quot;&gt;TAP :: Parser :: Scheduler&lt;/a&gt;の関連する「ルール」ドキュメントを参照してください。 &lt;code&gt;prove&lt;/code&gt; を介して直接実行できることが十分でない場合は、これらの機能に直接アクセスするための独自のハーネスを作成できます。</target>
        </trans-unit>
        <trans-unit id="bcc2262a79a5dbdf9359e3765fbc56f15e34b33f" translate="yes" xml:space="preserve">
          <source>If you need more fine-grained control over shared variable access, see &lt;a href=&quot;../thread/semaphore&quot;&gt;Thread::Semaphore&lt;/a&gt;.</source>
          <target state="translated">シェア変数アクセスをよりきめ細かく制御する必要がある場合は、&lt;a href=&quot;../thread/semaphore&quot;&gt;Thread :: Semaphoreを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="64caf20ebddb6770dbd779252f4ceb1cec9300bf" translate="yes" xml:space="preserve">
          <source>If you need more fine-grained control over shared variable access, see &lt;a href=&quot;Thread::Semaphore&quot;&gt;Thread::Semaphore&lt;/a&gt;.</source>
          <target state="translated">共有変数アクセスをよりきめ細かく制御する必要がある場合は、&lt;a href=&quot;Thread::Semaphore&quot;&gt;Thread :: Semaphoreを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="06a1402305f2d5c348929119dfbe7d1b16bea038" translate="yes" xml:space="preserve">
          <source>If you need more memory (larger data segment) for your Perl programs you can set:</source>
          <target state="translated">Perl プログラムのために、より多くのメモリ(より大きなデータセグメント)が必要な場合は、設定することができます。</target>
        </trans-unit>
        <trans-unit id="a733f66f7ebcddfc5bced382948b822560f8102b" translate="yes" xml:space="preserve">
          <source>If you need non-ASCII characters in your source code, make it a UTF-8 encoded file and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; .</source>
          <target state="translated">ソースコードに非ASCII文字が必要な場合は、それをUTF-8エンコードファイルにし &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="d0a3470b5eeb6f4646e842f332fe5e001c0f8638" translate="yes" xml:space="preserve">
          <source>If you need non-ASCII characters in your source code, make it a UTF-8 encoded file and &lt;code&gt;use utf8&lt;/code&gt;.</source>
          <target state="translated">ソースコードに非ASCII文字が必要な場合は、UTF-8でエンコードされたファイルにして、 &lt;code&gt;use utf8&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="de2791275bc33103874a494cba3668a34d497a88" translate="yes" xml:space="preserve">
          <source>If you need not it (say, in the case when you need not handle any combining characters), assign &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; explicitly.</source>
          <target state="translated">必要でない場合（たとえば、結合文字を処理する必要がない場合など）は、 &lt;code&gt;(normalization =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; 明示的に割り当てます。</target>
        </trans-unit>
        <trans-unit id="f59efc7843078cafcac070fa0d339e2add569c59" translate="yes" xml:space="preserve">
          <source>If you need not it (say, in the case when you need not handle any combining characters), assign &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt; explicitly.</source>
          <target state="translated">必要がない場合（たとえば、結合文字を処理する必要がない場合）、明示的に &lt;code&gt;(normalization =&amp;gt; undef)&lt;/code&gt; 割り当てます。</target>
        </trans-unit>
        <trans-unit id="a2c63ba89d54a209534c04c157c983b92a890aeb" translate="yes" xml:space="preserve">
          <source>If you need something like this functionality, it is recommended that use you a simple source filter, such as &lt;a href=&quot;Filter::Encoding&quot;&gt;Filter::Encoding&lt;/a&gt;.</source>
          <target state="translated">このような機能が必要な場合は、&lt;a href=&quot;Filter::Encoding&quot;&gt;Filter :: Encoding&lt;/a&gt;などの単純なソースフィルターを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="4d24eea4a069716d3cfb8ce322b04914e0b52151" translate="yes" xml:space="preserve">
          <source>If you need something like this functionality, you should use the &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; pragma, which is also deprecated, but has fewer nasty side effects.</source>
          <target state="translated">この機能のようなものが必要な場合は、&lt;a href=&quot;encoding&quot;&gt;エンコーディング&lt;/a&gt;プラグマを使用する必要があります。これも非推奨ですが、厄介な副作用はほとんどありません。</target>
        </trans-unit>
        <trans-unit id="988729c3d7bb2f3f6d6060c234bddde42b00f5a7" translate="yes" xml:space="preserve">
          <source>If you need something much more sophisticated and controllable, Leon Brocard's &lt;a href=&quot;Devel::ebug&quot;&gt;Devel::ebug&lt;/a&gt; (which you can call with the &lt;code&gt;-D&lt;/code&gt; switch as &lt;code&gt;-Debug&lt;/code&gt;) gives you the programmatic hooks into everything you need to write your own (without too much pain and suffering).</source>
          <target state="translated">より洗練された制御可能なものが必要な場合は、&lt;a href=&quot;Devel::ebug&quot;&gt;LeonBrocard&lt;/a&gt;のDevel :: ebug（ &lt;code&gt;-D&lt;/code&gt; スイッチで &lt;code&gt;-Debug&lt;/code&gt; として呼び出すことができます）を使用すると、自分で作成する必要があるすべてのものにプログラムでフックできます（あまり苦痛や苦痛を感じることはありません）。 ）。</target>
        </trans-unit>
        <trans-unit id="74399fe1ce7a1f4f506a06b60ded39ec27cea334" translate="yes" xml:space="preserve">
          <source>If you need something much more sophisticated and controllable, Leon Brocard's &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::ebug&quot;&gt;Devel::ebug&lt;/a&gt; (which you can call with the &lt;code&gt;-D&lt;/code&gt; switch as &lt;code&gt;-Debug&lt;/code&gt; ) gives you the programmatic hooks into everything you need to write your own (without too much pain and suffering).</source>
          <target state="translated">より洗練された制御可能なものが必要な場合は、Leon Brocardの&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::ebug&quot;&gt;Devel :: ebug&lt;/a&gt;（ &lt;code&gt;-D&lt;/code&gt; スイッチを &lt;code&gt;-Debug&lt;/code&gt; として呼び出すことができます）を使用すると、独自に記述するために必要なすべてにプログラムのフックを（あまり苦痛を伴うことなく）提供できます。 ）。</target>
        </trans-unit>
        <trans-unit id="77f3f2631a368e380813c177575d4bf78bb0f7fd" translate="yes" xml:space="preserve">
          <source>If you need the string representation of a character that doesn't have a mnemonic name in C, you should add it to the list in</source>
          <target state="translated">C言語ではニーモニック名を持たない文字の文字列表現が必要な場合は、それを</target>
        </trans-unit>
        <trans-unit id="c2b8ba636abce4657c8c0f922660904cfc7228c1" translate="yes" xml:space="preserve">
          <source>If you need to be able to read a block which has an exact size, you can use the function &lt;code&gt;filter_read_exact&lt;/code&gt; . It works identically to &lt;code&gt;filter_read&lt;/code&gt; in block mode, except it will try to read a block which is exactly &lt;code&gt;$size&lt;/code&gt; bytes in length. The only circumstances when it will not return a block which is &lt;code&gt;$size&lt;/code&gt; bytes long is on EOF or error.</source>
          <target state="translated">正確なサイズのブロックを読み取る必要がある場合は、関数 &lt;code&gt;filter_read_exact&lt;/code&gt; を使用できます。ブロックモードの &lt;code&gt;filter_read&lt;/code&gt; と同じように機能しますが、長さが &lt;code&gt;$size&lt;/code&gt; バイトのブロックを読み取ろうとします。 &lt;code&gt;$size&lt;/code&gt; バイト長のブロックを返さない唯一の状況は、EOFまたはエラー時です。</target>
        </trans-unit>
        <trans-unit id="8c813a030a97b2b5bb47766e284a0379dde73e25" translate="yes" xml:space="preserve">
          <source>If you need to be able to read a block which has an exact size, you can use the function &lt;code&gt;filter_read_exact&lt;/code&gt;. It works identically to &lt;code&gt;filter_read&lt;/code&gt; in block mode, except it will try to read a block which is exactly &lt;code&gt;$size&lt;/code&gt; bytes in length. The only circumstances when it will not return a block which is &lt;code&gt;$size&lt;/code&gt; bytes long is on EOF or error.</source>
          <target state="translated">正確なサイズのブロックを読み取れるようにする必要がある場合は、関数 &lt;code&gt;filter_read_exact&lt;/code&gt; を使用できます。ブロックモードの &lt;code&gt;filter_read&lt;/code&gt; と同じように機能しますが、正確に &lt;code&gt;$size&lt;/code&gt; バイトの長さのブロックを読み取ろうとする点が異なります。 &lt;code&gt;$size&lt;/code&gt; バイトの長さのブロックを返さない唯一の状況は、EOFまたはエラーです。</target>
        </trans-unit>
        <trans-unit id="18a6ebad8222234ffca6c9871e53dc4619a2ca40" translate="yes" xml:space="preserve">
          <source>If you need to bless or re-bless an object you can use the following function:</source>
          <target state="translated">オブジェクトを祝福または再祝福する必要がある場合は、以下の関数を使用することができます。</target>
        </trans-unit>
        <trans-unit id="ac05679aaf52c29544dd930529212ccf723e35df" translate="yes" xml:space="preserve">
          <source>If you need to compare version numbers, but can't be sure whether they are expressed as numbers, strings, v-strings or version objects, then you should use version.pm to parse them all into objects for comparison.</source>
          <target state="translated">バージョン番号を比較する必要があるが、それが数字なのか文字列なのかv-stringなのかバージョンオブジェクトなのかわからない場合は、version.pmを使ってそれらをすべてオブジェクトにパースして比較するべきです。</target>
        </trans-unit>
        <trans-unit id="8a20b3786b554786904a5b1cfd2ed611798a9441" translate="yes" xml:space="preserve">
          <source>If you need to customize the objects on creation, subclass &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_grammar&quot;&gt;&quot;make_grammar&quot;&lt;/a&gt;</source>
          <target state="translated">作成時にオブジェクトをカスタマイズする必要がある場合は、&lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser&lt;/a&gt;をサブクラス化し、&lt;a href=&quot;#make_grammar&quot;&gt;「make_grammar」&lt;/a&gt;をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="8826419639cfccd71d1ef977c6d4164c1055d8a9" translate="yes" xml:space="preserve">
          <source>If you need to customize the objects on creation, subclass &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_result&quot;&gt;&quot;make_result&quot;&lt;/a&gt;.</source>
          <target state="translated">作成時にオブジェクトをカスタマイズする必要がある場合は、&lt;a href=&quot;TAP::Parser&quot;&gt;TAP :: Parser&lt;/a&gt;をサブクラス化し、&lt;a href=&quot;#make_result&quot;&gt;「make_result」&lt;/a&gt;をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="d70c6e2df233bb6ffd0181bcff94f18d3b389825" translate="yes" xml:space="preserve">
          <source>If you need to customize the objects on creation, subclass &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_grammar&quot;&gt;make_grammar&lt;/a&gt;</source>
          <target state="translated">作成時にオブジェクトをカスタマイズする必要がある場合は、&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt;をサブクラス化し、&lt;a href=&quot;#make_grammar&quot;&gt;make_grammar&lt;/a&gt;をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="28d9937fb82713ba1f2c783a5af6bd5ed96f1469" translate="yes" xml:space="preserve">
          <source>If you need to customize the objects on creation, subclass &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; and override &lt;a href=&quot;#make_result&quot;&gt;make_result&lt;/a&gt;.</source>
          <target state="translated">作成時にオブジェクトをカスタマイズする必要がある場合は、&lt;a href=&quot;parser&quot;&gt;TAP :: Parser&lt;/a&gt;をサブクラス化し、&lt;a href=&quot;#make_result&quot;&gt;make_result&lt;/a&gt;をオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="9bf36336c456165d1f557c63d917cf367e24c8a2" translate="yes" xml:space="preserve">
          <source>If you need to distinguish between endian architectures you could use either of the variables set like so:</source>
          <target state="translated">エンディアンアーキテクチャを区別する必要がある場合は、このように設定された変数のいずれかを使用することができます。</target>
        </trans-unit>
        <trans-unit id="74fb9c00d6d39f0efb84e3bc0ddfd5cbf2ea27a0" translate="yes" xml:space="preserve">
          <source>If you need to do something more complicated, the &lt;a href=&quot;HTTP::Tiny&quot;&gt;HTTP::Tiny&lt;/a&gt; object can be customized by setting attributes, or you can use &lt;a href=&quot;LWP::UserAgent&quot;&gt;LWP::UserAgent&lt;/a&gt; from the libwww-perl distribution or &lt;a href=&quot;Mojo::UserAgent&quot;&gt;Mojo::UserAgent&lt;/a&gt; from the Mojolicious distribution to make common tasks easier. If you want to simulate an interactive web browser, you can use the &lt;a href=&quot;WWW::Mechanize&quot;&gt;WWW::Mechanize&lt;/a&gt; module.</source>
          <target state="translated">より複雑なことを行う必要がある場合は、属性を設定して&lt;a href=&quot;HTTP::Tiny&quot;&gt;HTTP :: Tiny&lt;/a&gt;オブジェクトをカスタマイズするか、libwww-perlディストリビューションの&lt;a href=&quot;LWP::UserAgent&quot;&gt;LWP :: UserAgent&lt;/a&gt;またはMojoliciousディストリビューションの&lt;a href=&quot;Mojo::UserAgent&quot;&gt;Mojo :: UserAgent&lt;/a&gt;を使用して一般的なタスクを簡単にすることができます。 。インタラクティブなWebブラウザーをシミュレートする場合は、&lt;a href=&quot;WWW::Mechanize&quot;&gt;WWW :: Mechanize&lt;/a&gt;モジュールを使用できます。</target>
        </trans-unit>
        <trans-unit id="a6c8b4493aa37d00a1808e45469530aac89fd5c8" translate="yes" xml:space="preserve">
          <source>If you need to do something more complicated, you can use &lt;a href=&quot;http://search.cpan.org/perldoc/LWP::UserAgent&quot;&gt;LWP::UserAgent&lt;/a&gt; module to create your own user-agent (e.g. browser) to get the job done. If you want to simulate an interactive web browser, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW::Mechanize&lt;/a&gt; module.</source>
          <target state="translated">もっと複雑なことが必要な場合は、&lt;a href=&quot;http://search.cpan.org/perldoc/LWP::UserAgent&quot;&gt;LWP :: UserAgent&lt;/a&gt;モジュールを使用して独自のユーザーエージェント（ブラウザなど）を作成し、ジョブを完了できます。インタラクティブなWebブラウザをシミュレートする場合は、&lt;a href=&quot;http://search.cpan.org/perldoc/WWW::Mechanize&quot;&gt;WWW :: Mechanize&lt;/a&gt;モジュールを使用できます。</target>
        </trans-unit>
        <trans-unit id="a7852e983dc45b1c4fb37cf3f05367219e6ca843" translate="yes" xml:space="preserve">
          <source>If you need to do this check often, define your own macro like this:</source>
          <target state="translated">このチェックを頻繁に行う必要がある場合は、このように独自のマクロを定義します。</target>
        </trans-unit>
        <trans-unit id="6466ffd2aaaebc3946b351828c459bde58bed891" translate="yes" xml:space="preserve">
          <source>If you need to include C code or C library interfaces use h2xs. h2xs will create the module distribution structure and the initial interface files. &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; explain the details.</source>
          <target state="translated">CコードまたはCライブラリインターフェイスを含める必要がある場合は、h2xsを使用します。h2xsは、モジュール配布構造と初期インターフェースファイルを作成します。詳細は&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;と&lt;a href=&quot;perlxstut&quot;&gt;perlxstutで&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="132d01927536564513220be940287f0a7e0711cd" translate="yes" xml:space="preserve">
          <source>If you need to make sure your diagnostics are displayed in the correct order relative to test results you can use the &lt;code&gt;--merge&lt;/code&gt; option to merge the test scripts' STDERR into their STDOUT.</source>
          <target state="translated">診断がテスト結果に対して正しい順序で表示されることを確認する必要がある場合は、 &lt;code&gt;--merge&lt;/code&gt; オプションを使用して、テストスクリプトのSTDERRをSTDOUTにマージできます。</target>
        </trans-unit>
        <trans-unit id="f121bbe2a75e4529feda5970b07f0e59291a1000" translate="yes" xml:space="preserve">
          <source>If you need to pad with a character other than blank or zero you can use one of the following methods. They all generate a pad string with the &lt;code&gt;x&lt;/code&gt; operator and combine that with &lt;code&gt;$text&lt;/code&gt; . These methods do not truncate &lt;code&gt;$text&lt;/code&gt; .</source>
          <target state="translated">空白またはゼロ以外の文字を埋め込む必要がある場合は、次のいずれかの方法を使用できます。これらはすべて、 &lt;code&gt;x&lt;/code&gt; 演算子を使用して埋め込み文字列を生成し、それを &lt;code&gt;$text&lt;/code&gt; と組み合わせます。これらのメソッドは &lt;code&gt;$text&lt;/code&gt; 切り捨てません。</target>
        </trans-unit>
        <trans-unit id="281d15e2e9e38bc2d44d9e73a83267de2350b440" translate="yes" xml:space="preserve">
          <source>If you need to pad with a character other than blank or zero you can use one of the following methods. They all generate a pad string with the &lt;code&gt;x&lt;/code&gt; operator and combine that with &lt;code&gt;$text&lt;/code&gt;. These methods do not truncate &lt;code&gt;$text&lt;/code&gt;.</source>
          <target state="translated">空白またはゼロ以外の文字で埋める必要がある場合は、次のいずれかの方法を使用できます。これらはすべて、 &lt;code&gt;x&lt;/code&gt; 演算子を使用してパッド文字列を生成し、それを &lt;code&gt;$text&lt;/code&gt; と組み合わせます。これらのメソッドは &lt;code&gt;$text&lt;/code&gt; 切り捨てません。</target>
        </trans-unit>
        <trans-unit id="aed2c6c4464c8d7cdb6c519c251d4778b6623f9b" translate="yes" xml:space="preserve">
          <source>If you need to pass the handle to something that expects a filename then on a unix system you can use &lt;code&gt;&quot;/dev/fd/&quot; . fileno($fh)&lt;/code&gt; for arbitrary programs. Perl code that uses the 2-argument version of &lt;code&gt;open&lt;/code&gt; can be passed &lt;code&gt;&quot;+&amp;lt;=&amp;amp;&quot; . fileno($fh)&lt;/code&gt;. Otherwise you will need to pass the filename. You will have to clear the close-on-exec bit on that file descriptor before passing it to another process.</source>
          <target state="translated">ファイル名を期待するものにハンドルを渡す必要がある場合は、UNIXシステムで &lt;code&gt;&quot;/dev/fd/&quot; . fileno($fh)&lt;/code&gt; 使用できます。任意のプログラムの場合はfileno（$ fh）。 2引数バージョンの &lt;code&gt;open&lt;/code&gt; を使用するPerlコードには、 &lt;code&gt;&quot;+&amp;lt;=&amp;amp;&quot; . fileno($fh)&lt;/code&gt; 渡すことができます。 fileno（$ fh）。それ以外の場合は、ファイル名を渡す必要があります。別のプロセスに渡す前に、そのファイル記述子のclose-on-execビットをクリアする必要があります。</target>
        </trans-unit>
        <trans-unit id="5db19b81a16545df9a2691c134fe238aff01db6b" translate="yes" xml:space="preserve">
          <source>If you need to pass the handle to something that expects a filename then on a unix system you can use C for arbitrary programs. Perl code that uses the 2-argument version of C&amp;lt;&amp;lt; open &amp;gt;&amp;gt; can be passed C&amp;lt;&amp;lt; &quot;+&amp;lt;=&amp;amp;&quot; . fileno($fh) &amp;gt;&amp;gt;. Otherwise you will need to pass the filename. You will have to clear the close-on-exec bit on that file descriptor before passing it to another process.</source>
          <target state="translated">ファイル名を期待するものにハンドルを渡す必要がある場合、UNIXシステムでは任意のプログラムにCを使用できます。C &amp;lt;&amp;lt; open &amp;gt;&amp;gt;の2引数バージョンを使用するPerlコードには、C &amp;lt;&amp;lt; &quot;+ &amp;lt;=＆&quot;を渡すことができます。fileno（$ fh）&amp;gt;&amp;gt;。それ以外の場合は、ファイル名を渡す必要があります。別のプロセスに渡す前に、そのファイル記述子のclose-on-execビットをクリアする必要があります。</target>
        </trans-unit>
        <trans-unit id="a1479a86a7c4f92b2a893038ca84d0e7634155ed" translate="yes" xml:space="preserve">
          <source>If you need to perform any preprocessing of input before it is parsed you may want to override one or more of &lt;b&gt;preprocess_line()&lt;/b&gt; and/or &lt;b&gt;preprocess_paragraph()&lt;/b&gt;.</source>
          <target state="translated">入力が解析される前に入力の前​​処理を実行する必要がある場合は、&lt;b&gt;preprocess_line（）&lt;/b&gt;および/または&lt;b&gt;preprocess_paragraph（）の&lt;/b&gt; 1つ以上をオーバーライドすることができます。</target>
        </trans-unit>
        <trans-unit id="6fb6f27c51e4262718886f54bfa50ac616a6eb28" translate="yes" xml:space="preserve">
          <source>If you need to push multiple different values then you should either use the &lt;code&gt;(X)PUSHs&lt;/code&gt; macros, or else use the new &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; macros, none of which make use of &lt;code&gt;TARG&lt;/code&gt; . The &lt;code&gt;(X)PUSHs&lt;/code&gt; macros simply push an SV* on the stack, which, as noted under &lt;a href=&quot;#XSUBs-and-the-Argument-Stack&quot;&gt;XSUBs and the Argument Stack&lt;/a&gt;, will often need to be &quot;mortal&quot;. The new &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; macros make this a little easier to achieve by creating a new mortal for you (via &lt;code&gt;(X)PUSHmortal&lt;/code&gt;), pushing that onto the stack (extending it if necessary in the case of the &lt;code&gt;mXPUSH[iunp]&lt;/code&gt; macros), and then setting its value. Thus, instead of writing this to &quot;fix&quot; the example above:</source>
          <target state="translated">あなたが複数の異なる値をプッシュする必要があるなら、あなたはどちらか使用する必要があります &lt;code&gt;(X)PUSHs&lt;/code&gt; のマクロ、または他の使用の新しい &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; マクロ、メイクの使用のどれも &lt;code&gt;TARG&lt;/code&gt; を。 &lt;code&gt;(X)PUSHs&lt;/code&gt; マクロ単に押すSV *の下で述べたように、スタック、上&lt;a href=&quot;#XSUBs-and-the-Argument-Stack&quot;&gt;のXSUBと引数スタック&lt;/a&gt;、しばしば「死す」が必要になります。新しい &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m(X)PUSH[iunp]&lt;/a&gt;&lt;/code&gt; マクロを使用すると、 &lt;code&gt;(X)PUSHmortal&lt;/code&gt; を介して）新しいモータルを作成し、それをスタックにプッシュする（ &lt;code&gt;mXPUSH[iunp]&lt;/code&gt; マクロ）、次にその値を設定します。したがって、上記の例を「修正」するためにこれを書く代わりに：</target>
        </trans-unit>
        <trans-unit id="dcfff33a227c9b4b0446369038ec69edba6230b7" translate="yes" xml:space="preserve">
          <source>If you need to push multiple different values then you should either use the &lt;code&gt;(X)PUSHs&lt;/code&gt; macros, or else use the new &lt;code&gt;m(X)PUSH[iunp]&lt;/code&gt; macros, none of which make use of &lt;code&gt;TARG&lt;/code&gt;. The &lt;code&gt;(X)PUSHs&lt;/code&gt; macros simply push an SV* on the stack, which, as noted under &lt;a href=&quot;#XSUBs-and-the-Argument-Stack&quot;&gt;&quot;XSUBs and the Argument Stack&quot;&lt;/a&gt;, will often need to be &quot;mortal&quot;. The new &lt;code&gt;m(X)PUSH[iunp]&lt;/code&gt; macros make this a little easier to achieve by creating a new mortal for you (via &lt;code&gt;(X)PUSHmortal&lt;/code&gt;), pushing that onto the stack (extending it if necessary in the case of the &lt;code&gt;mXPUSH[iunp]&lt;/code&gt; macros), and then setting its value. Thus, instead of writing this to &quot;fix&quot; the example above:</source>
          <target state="translated">あなたが複数の異なる値をプッシュする必要があるなら、あなたはどちらか使用する必要があります &lt;code&gt;(X)PUSHs&lt;/code&gt; のマクロ、または他の使用の新しい &lt;code&gt;m(X)PUSH[iunp]&lt;/code&gt; マクロ、メイクの使用のどれも &lt;code&gt;TARG&lt;/code&gt; を。 &lt;code&gt;(X)PUSHs&lt;/code&gt; の下で述べたように、スタック、上のマクロ単に押すSV * &lt;a href=&quot;#XSUBs-and-the-Argument-Stack&quot;&gt;「なXSUBと引数スタックは、」&lt;/a&gt;、多くの場合、「死す」が必要になります。新しい &lt;code&gt;m(X)PUSH[iunp]&lt;/code&gt; マクロは、 &lt;code&gt;(X)PUSHmortal&lt;/code&gt; を介して）新しいモルタルを作成し、それをスタックにプッシュする（ &lt;code&gt;mXPUSH[iunp]&lt;/code&gt; 場合は必要に応じて拡張する）ことで、これを少し簡単に実現できます。 iunp]マクロ）、次にその値を設定します。したがって、上記の例を「修正」するためにこれを書く代わりに、次のようにします。</target>
        </trans-unit>
        <trans-unit id="5f2c24c8a5106b97dd605e7836d7f3b3f6f05f0c" translate="yes" xml:space="preserve">
          <source>If you need to run code under taint mode, updating to the latest &lt;a href=&quot;File::Spec&quot;&gt;File::Spec&lt;/a&gt; is highly recommended. On Windows, if the directory given by &lt;a href=&quot;File::Spec::tmpdir&quot;&gt;File::Spec::tmpdir&lt;/a&gt; isn't writable, File::Temp will attempt to fallback to the user's local application data directory or croak with an error.</source>
          <target state="translated">汚染モードでコードを実行する必要がある場合は、最新の&lt;a href=&quot;File::Spec&quot;&gt;File :: Spec&lt;/a&gt;に更新することを強くお勧めします。Windowsでは、&lt;a href=&quot;File::Spec::tmpdir&quot;&gt;File :: Spec :: tmpdirで指定&lt;/a&gt;されたディレクトリが書き込み可能でない場合、File :: Tempはユーザーのローカルアプリケーションデータディレクトリにフォールバックしようとするか、エラーでクロークします。</target>
        </trans-unit>
        <trans-unit id="b45e0c901cd619f7527093c4d9dc59b922de91c4" translate="yes" xml:space="preserve">
          <source>If you need to run code under taint mode, updating to the latest L&amp;lt;:spec&amp;gt; is highly recommended.</source>
          <target state="translated">汚染モードでコードを実行する必要がある場合は、最新のL &amp;lt;：spec&amp;gt;に更新することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="0a26debdab35f4d9006770f7ff9dd97352bd60fc" translate="yes" xml:space="preserve">
          <source>If you need to set the encoding for STDIN, STDOUT, and STDERR, for example based on the user's locale, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">たとえばユーザーのロケールに基づいて、STDIN、STDOUT、およびSTDERRのエンコーディングを設定する必要がある場合は、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用し&lt;/a&gt; ます。</target>
        </trans-unit>
        <trans-unit id="870260c0c362207468a98bb8f507e2cc87fb2a13" translate="yes" xml:space="preserve">
          <source>If you need to set the encoding for STDIN, STDOUT, and STDERR, for example based on the user's locale, &lt;code&gt;use open&lt;/code&gt;.</source>
          <target state="translated">たとえば、ユーザーのロケールに基づいて、STDIN、STDOUT、およびSTDERRのエンコーディングを設定する必要がある場合は、 &lt;code&gt;use open&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6d6ae28c61f9ab4be958ec28b43ea876d12f0ac" translate="yes" xml:space="preserve">
          <source>If you need to sort on several fields, the following paradigm is useful.</source>
          <target state="translated">複数のフィールドでソートする必要がある場合は、以下のパラダイムが便利です。</target>
        </trans-unit>
        <trans-unit id="f3d49b98b395f07c8fa5d476950e74044c830e9d" translate="yes" xml:space="preserve">
          <source>If you need to test whether a version object has been initialized, you can simply test it directly:</source>
          <target state="translated">バージョンオブジェクトが初期化されたかどうかをテストする必要がある場合は、直接テストすればいいだけです。</target>
        </trans-unit>
        <trans-unit id="bcb30e833a46ba05085b508093073afbb52be3c6" translate="yes" xml:space="preserve">
          <source>If you need to use</source>
          <target state="translated">を使用する必要がある場合は</target>
        </trans-unit>
        <trans-unit id="dd52c7b44ac55aa77cc0e377ad21781b36b65218" translate="yes" xml:space="preserve">
          <source>If you need to use Perl in the ILE environment, you may want to consider using Qp2RunPase() to call the PASE version of Perl.</source>
          <target state="translated">ILE 環境で Perl を使用する必要がある場合は、PASE バージョンの Perl を呼び出すために Qp2RunPase()を使用することを検討するとよいでしょう。</target>
        </trans-unit>
        <trans-unit id="b4808d5e77c37aaf035853f43eef1fd731c05497" translate="yes" xml:space="preserve">
          <source>If you need to, your program can pass parameters to the subroutine as part of the thread startup. Just include the list of parameters as part of the &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; call, like this:</source>
          <target state="translated">必要に応じて、プログラムはスレッドの起動の一部としてサブルーチンにパラメーターを渡すことができます。次のように、 &lt;code&gt;threads-&amp;gt;create()&lt;/code&gt; 呼び出しの一部としてパラメーターのリストを含めるだけです。</target>
        </trans-unit>
        <trans-unit id="1710a33b911c663eb696834835df2f1e23df21c3" translate="yes" xml:space="preserve">
          <source>If you needed to know the length of the string in bytes, now's the perfect time for that. Because &lt;code&gt;$body&lt;/code&gt; is now a byte string, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; will report the number of bytes, instead of the number of characters. The number of characters is no longer known, because characters only exist in text strings.</source>
          <target state="translated">文字列の長さをバイト単位で知る必要がある場合は、今がその絶好の機会です。 &lt;code&gt;$body&lt;/code&gt; がバイト文字列になったため、 &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; は文字数ではなくバイト数を報告します。文字はテキスト文字列にのみ存在するため、文字数は不明です。</target>
        </trans-unit>
        <trans-unit id="f897865d444575124f537cfaf9274fd31883caca" translate="yes" xml:space="preserve">
          <source>If you needed to know the length of the string in bytes, now's the perfect time for that. Because &lt;code&gt;$body&lt;/code&gt; is now a byte string, &lt;code&gt;length&lt;/code&gt; will report the number of bytes, instead of the number of characters. The number of characters is no longer known, because characters only exist in text strings.</source>
          <target state="translated">文字列の長さをバイト単位で知る必要がある場合は、今がそのための最適なタイミングです。 &lt;code&gt;$body&lt;/code&gt; はバイト文字列になっているため、 &lt;code&gt;length&lt;/code&gt; は文字数ではなくバイト数を報告します。文字はテキスト文字列にのみ存在するため、文字数は不明になりました。</target>
        </trans-unit>
        <trans-unit id="be13b7e49abdf9671c1c203318c86c5b390da880" translate="yes" xml:space="preserve">
          <source>If you now say</source>
          <target state="translated">今、あなたが言うなら</target>
        </trans-unit>
        <trans-unit id="4e07afe42e8e4906b74c8de7f97562b41c673c72" translate="yes" xml:space="preserve">
          <source>If you only have to do this once, you can print individually to each filehandle.</source>
          <target state="translated">一度だけなら、ファイルハンドルごとに個別に印刷することができます。</target>
        </trans-unit>
        <trans-unit id="4fedbe813a9df1931afb6723a023d133df40e372" translate="yes" xml:space="preserve">
          <source>If you only want to cancel some uncommitted edits, you can use &lt;code&gt;git checkout&lt;/code&gt; and give it a list of files to be reverted, or &lt;code&gt;git checkout -f&lt;/code&gt; to revert them all.</source>
          <target state="translated">コミットされていない編集のみをキャンセルしたい場合は、 &lt;code&gt;git checkout&lt;/code&gt; を使用して元に戻すファイルのリストを指定するか、 &lt;code&gt;git checkout -f&lt;/code&gt; を使用してすべてを元に戻すことができます。</target>
        </trans-unit>
        <trans-unit id="41a207a0fbb92e170fc7384b498a52e214bc5156" translate="yes" xml:space="preserve">
          <source>If you open a pipe on the command &lt;code&gt;-&lt;/code&gt; (that is, specify either &lt;code&gt;|-&lt;/code&gt; or &lt;code&gt;-|&lt;/code&gt; with the one- or two-argument forms of &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;), an implicit &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; is done, so &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; returns twice: in the parent process it returns the pid of the child process, and in the child process it returns (a defined) &lt;code&gt;0&lt;/code&gt;. Use &lt;code&gt;defined($pid)&lt;/code&gt; or &lt;code&gt;//&lt;/code&gt; to determine whether the open was successful.</source>
          <target state="translated">あなたは、コマンドにパイプを開くと &lt;code&gt;-&lt;/code&gt; （つまり、いずれかの指定 &lt;code&gt;|-&lt;/code&gt; または &lt;code&gt;-|&lt;/code&gt; の一次元又は二引数のフォームを&lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;）、暗黙の&lt;a href=&quot;#fork&quot;&gt; &lt;code&gt;fork&lt;/code&gt; &lt;/a&gt;行われているので、&lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;二回戻り値：親プロセスでそれを返します子プロセスのpidであり、子プロセスでは（定義された） &lt;code&gt;0&lt;/code&gt; を返します。使用すると、 &lt;code&gt;defined($pid)&lt;/code&gt; または &lt;code&gt;//&lt;/code&gt; オープンが成功したかどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="ef4f1155d60201a5a642377c105def023a28c8a3" translate="yes" xml:space="preserve">
          <source>If you open a pipe on the command &lt;code&gt;-&lt;/code&gt; (that is, specify either &lt;code&gt;|-&lt;/code&gt; or &lt;code&gt;-|&lt;/code&gt; with the one- or two-argument forms of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;), an implicit &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is done, so &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; returns twice: in the parent process it returns the pid of the child process, and in the child process it returns (a defined) &lt;code&gt;0&lt;/code&gt; . Use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;//&lt;/code&gt; to determine whether the open was successful.</source>
          <target state="translated">あなたは、コマンドにパイプを開くと &lt;code&gt;-&lt;/code&gt; （つまり、いずれかの指定 &lt;code&gt;|-&lt;/code&gt; または &lt;code&gt;-|&lt;/code&gt; の一次元又は二引数のフォームを &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ）、暗黙の &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 行われているので、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 二回戻り値：親プロセスでそれを返します子プロセスのpid、および子プロセスでは（定義された） &lt;code&gt;0&lt;/code&gt; を返します。使用すると、 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;//&lt;/code&gt; オープンが成功したかどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="3ae4797a620c0cf454989f9d7b82f21950740479" translate="yes" xml:space="preserve">
          <source>If you open a pipe on the command &lt;code&gt;-&lt;/code&gt; (that is, specify either &lt;code&gt;|-&lt;/code&gt; or &lt;code&gt;-|&lt;/code&gt; with the one- or two-argument forms of &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;), an implicit &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is done, so &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; returns twice: in the parent process it returns the pid of the child process, and in the child process it returns (a defined) &lt;code&gt;0&lt;/code&gt; . Use &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;//&lt;/code&gt; to determine whether the open was successful.</source>
          <target state="translated">あなたは、コマンドにパイプを開くと &lt;code&gt;-&lt;/code&gt; （つまり、いずれかの指定 &lt;code&gt;|-&lt;/code&gt; または &lt;code&gt;-|&lt;/code&gt; の一次元又は二引数のフォームを &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; ）、暗黙の &lt;code&gt;&lt;a href=&quot;fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 行われているので、 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 二回戻り値：親プロセスでそれを返します子プロセスのpid、および子プロセスでは（定義された） &lt;code&gt;0&lt;/code&gt; を返します。使用すると、 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined($pid)&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;//&lt;/code&gt; オープンが成功したかどうかを判断します。</target>
        </trans-unit>
        <trans-unit id="b60263df2e1568250aacc0155390b54bbc574b26" translate="yes" xml:space="preserve">
          <source>If you opted to uncomment &lt;code&gt;INST_VER&lt;/code&gt; and &lt;code&gt;INST_ARCH&lt;/code&gt; in the makefile then the installation structure is a little more complicated and you will need to add two new PATH components instead: &lt;code&gt;$INST_TOP\$INST_VER\bin&lt;/code&gt; and &lt;code&gt;$INST_TOP\$INST_VER\bin\$ARCHNAME&lt;/code&gt; , e.g.</source>
          <target state="translated">あなたはコメントを解除することを選んだ場合は &lt;code&gt;INST_VER&lt;/code&gt; と &lt;code&gt;INST_ARCH&lt;/code&gt; メイクファイルで、インストールの構造は、もう少し複雑になると、あなたは代わりに二つの新しいPATHコンポーネントを追加する必要があります： &lt;code&gt;$INST_TOP\$INST_VER\bin&lt;/code&gt; と &lt;code&gt;$INST_TOP\$INST_VER\bin\$ARCHNAME&lt;/code&gt; 、例えば</target>
        </trans-unit>
        <trans-unit id="bad570e796041b2f5592838887a3faca1802a117" translate="yes" xml:space="preserve">
          <source>If you opted to uncomment &lt;code&gt;INST_VER&lt;/code&gt; and &lt;code&gt;INST_ARCH&lt;/code&gt; in the makefile then the installation structure is a little more complicated and you will need to add two new PATH components instead: &lt;code&gt;$INST_TOP\$INST_VER\bin&lt;/code&gt; and &lt;code&gt;$INST_TOP\$INST_VER\bin\$ARCHNAME&lt;/code&gt;, e.g.</source>
          <target state="translated">makefileで &lt;code&gt;INST_VER&lt;/code&gt; と &lt;code&gt;INST_ARCH&lt;/code&gt; のコメントを解除することを選択した場合、インストール構造は少し複雑になり、代わりに2つの新しいPATHコンポーネントを追加する必要があります： &lt;code&gt;$INST_TOP\$INST_VER\bin&lt;/code&gt; と &lt;code&gt;$INST_TOP\$INST_VER\bin\$ARCHNAME&lt;/code&gt; 、例えば</target>
        </trans-unit>
        <trans-unit id="3281995d9866c6fc2125672694920f44e26bcb98" translate="yes" xml:space="preserve">
          <source>If you override this method, it should never throw an exception.</source>
          <target state="translated">このメソッドをオーバーライドすると、例外が発生することはありません。</target>
        </trans-unit>
        <trans-unit id="a202baf38183d44995c2fcf3449035cd37813ae8" translate="yes" xml:space="preserve">
          <source>If you pass a perl version you get the release date for that version only.</source>
          <target state="translated">perlのバージョンを渡すと、そのバージョンのリリース日のみを取得します。</target>
        </trans-unit>
        <trans-unit id="d2654ab11aa24c5cd7986448b88f2571bec7a12a" translate="yes" xml:space="preserve">
          <source>If you pass a port number to Net::FTP then it assumes this is the port number of the final destination. By default Net::FTP will always try to connect to the firewall on port 21.</source>
          <target state="translated">Net::FTP にポート番号を渡すと、そのポート番号が最終的な宛先のポート番号であると見なされます。デフォルトでは、Net::FTP は常にポート 21 でファイアウォールに接続しようとします。</target>
        </trans-unit>
        <trans-unit id="1538bf7a76ecb948f65bf6e3cd597e0fef6beddd" translate="yes" xml:space="preserve">
          <source>If you pass a version argument (value of &lt;code&gt;$]&lt;/code&gt; , like &lt;code&gt;5.00503&lt;/code&gt; or &lt;code&gt;5.008008&lt;/code&gt; ), you get a list of all the modules and their respective versions. (If you have the &lt;code&gt;version&lt;/code&gt; module, you can also use new-style version numbers, like &lt;code&gt;5.8.8&lt;/code&gt; .)</source>
          <target state="translated">バージョン引数（ &lt;code&gt;5.00503&lt;/code&gt; や &lt;code&gt;5.008008&lt;/code&gt; などの &lt;code&gt;$]&lt;/code&gt; を渡すと、すべてのモジュールとそれぞれのバージョンのリストが表示されます。（ &lt;code&gt;version&lt;/code&gt; モジュールがある場合は、 &lt;code&gt;5.8.8&lt;/code&gt; のような新しいスタイルのバージョン番号を使用することもできます。）</target>
        </trans-unit>
        <trans-unit id="7bc630f7bd97f46ece9c6618008aa09db386949e" translate="yes" xml:space="preserve">
          <source>If you pass a version argument (value of &lt;code&gt;$]&lt;/code&gt;, like &lt;code&gt;5.00503&lt;/code&gt; or &lt;code&gt;5.008008&lt;/code&gt;), you get a list of all the modules and their respective versions. (If you have the &lt;code&gt;version&lt;/code&gt; module, you can also use new-style version numbers, like &lt;code&gt;5.8.8&lt;/code&gt;.)</source>
          <target state="translated">バージョン引数（ &lt;code&gt;5.00503&lt;/code&gt; や &lt;code&gt;5.008008&lt;/code&gt; などの &lt;code&gt;$]&lt;/code&gt; 値）を渡すと、すべてのモジュールとそれぞれのバージョンのリストが表示されます。（ &lt;code&gt;version&lt;/code&gt; モジュールがある場合は、 &lt;code&gt;5.8.8&lt;/code&gt; などの新しいスタイルのバージョン番号を使用することもできます。）</target>
        </trans-unit>
        <trans-unit id="93bac64f7444e2412e1719cee4ee931ff2c82b7b" translate="yes" xml:space="preserve">
          <source>If you pass the &lt;code&gt;-q&lt;/code&gt; option to the module, then the STDOUT filehandle will be redirected into the variable &lt;code&gt;$O::BEGIN_output&lt;/code&gt; during compilation. This has the effect that any output printed to STDOUT by BEGIN blocks or use'd modules will be stored in this variable rather than printed. It's useful with those backends which produce output themselves (&lt;code&gt;Deparse&lt;/code&gt; , &lt;code&gt;Concise&lt;/code&gt; etc), so that their output is not confused with that generated by the code being compiled.</source>
          <target state="translated">&lt;code&gt;-q&lt;/code&gt; オプションをモジュールに渡すと、コンパイル中にSTDOUTファイルハンドルが変数 &lt;code&gt;$O::BEGIN_output&lt;/code&gt; にリダイレクトされます。これにより、BEGINブロックまたは使用されたモジュールによってSTDOUTに出力される出力は、出力されるのではなく、この変数に格納されます。それ自体が出力を生成するバックエンド（ &lt;code&gt;Deparse&lt;/code&gt; 、 &lt;code&gt;Concise&lt;/code&gt; など）で役立ち、コンパイルされるコードによって生成される出力と混同されないようにします。</target>
        </trans-unit>
        <trans-unit id="2b02265881df71310516615b75c10b272c997131" translate="yes" xml:space="preserve">
          <source>If you pass the &lt;code&gt;-q&lt;/code&gt; option to the module, then the STDOUT filehandle will be redirected into the variable &lt;code&gt;$O::BEGIN_output&lt;/code&gt; during compilation. This has the effect that any output printed to STDOUT by BEGIN blocks or use'd modules will be stored in this variable rather than printed. It's useful with those backends which produce output themselves (&lt;code&gt;Deparse&lt;/code&gt;, &lt;code&gt;Concise&lt;/code&gt; etc), so that their output is not confused with that generated by the code being compiled.</source>
          <target state="translated">モジュールに &lt;code&gt;-q&lt;/code&gt; オプションを渡すと、コンパイル中にSTDOUTファイルハンドルが変数 &lt;code&gt;$O::BEGIN_output&lt;/code&gt; にリダイレクトされます。これには、BEGINブロックまたはuse'dモジュールによってSTDOUTに出力される出力は、出力されるのではなく、この変数に格納されるという効果があります。これは、出力自体を生成するバックエンド（ &lt;code&gt;Deparse&lt;/code&gt; 、 &lt;code&gt;Concise&lt;/code&gt; など）で役立ちます。そのため、それらの出力は、コンパイルされているコードによって生成された出力と混同されません。</target>
        </trans-unit>
        <trans-unit id="eb6ebb2e5d7084d0bbbc51b71dbc71d3b131a896" translate="yes" xml:space="preserve">
          <source>If you perform a new installation, then (a newer) Perl will be installed automatically. Pre-installed HP-UX systems now have more recent versions of Perl and the updated modules.</source>
          <target state="translated">新規インストールを実行すると、(新しい)Perlが自動的にインストールされます。プリインストールされた HP-UX システムには、Perl の最新バージョンと更新されたモジュールがインストールされています。</target>
        </trans-unit>
        <trans-unit id="3e9cb6c101da46aadecf5f8c5c109de4412a1005" translate="yes" xml:space="preserve">
          <source>If you pick the right test function, you'll usually get a good idea of what went wrong when it failed. But sometimes it doesn't work out that way. So here we have ways for you to write your own diagnostic messages which are safer than just &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; STDERR&lt;/code&gt; .</source>
          <target state="translated">適切なテスト関数を選択すると、通常、失敗したときに何が問題であったかがよくわかります。しかし、時々それはそのようにうまくいかない。そこでここではあなただけよりも安全です、あなた自身の診断メッセージを書くための方法を持っている &lt;code&gt;&lt;a href=&quot;../functions/print&quot;&gt;print&lt;/a&gt; STDERR&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bdb193abf588e1053390563380a45f43172b81e" translate="yes" xml:space="preserve">
          <source>If you pick the right test function, you'll usually get a good idea of what went wrong when it failed. But sometimes it doesn't work out that way. So here we have ways for you to write your own diagnostic messages which are safer than just &lt;code&gt;print STDERR&lt;/code&gt;.</source>
          <target state="translated">適切なテスト機能を選択すると、通常、失敗したときに何がうまくいかなかったのかがわかります。しかし、時々それはそのようにうまくいかない。したがって、ここでは、 &lt;code&gt;print STDERR&lt;/code&gt; するよりも安全な独自の診断メッセージを作成する方法があります。</target>
        </trans-unit>
        <trans-unit id="e1f8c3042df990d0caf7e15fec6410a8229928ec" translate="yes" xml:space="preserve">
          <source>If you plan on doing serious C hacking, make sure to read this.</source>
          <target state="translated">本気でC言語のハッキングをしようと思っている人は、必ずこれを読んでください。</target>
        </trans-unit>
        <trans-unit id="81013dc1ad1ba24b43d69b63d40b9239df928ef7" translate="yes" xml:space="preserve">
          <source>If you plan to link Perl to any module that requires thread-support, like DBD::Oracle, it is better to use the _r version of the compiler. This will not build a threaded Perl, but a thread-enabled Perl. See also &lt;a href=&quot;#Threaded-Perl&quot;&gt;&quot;Threaded Perl&quot;&lt;/a&gt; later on.</source>
          <target state="translated">DBD :: Oracleなど、スレッドサポートを必要とするモジュールにPerlをリンクする場合は、コンパイラの_rバージョンを使用することをお勧めします。これはスレッド化されたPerlを構築しませんが、スレッド対応のPerlを構築します。後の&lt;a href=&quot;#Threaded-Perl&quot;&gt;「スレッド化されたPerl」&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="ea674be45f6eda0998926e34d1adb1941baadfc8" translate="yes" xml:space="preserve">
          <source>If you plan to link Perl to any module that requires thread-support, like DBD::Oracle, it is better to use the _r version of the compiler. This will not build a threaded Perl, but a thread-enabled Perl. See also &lt;a href=&quot;#Threaded-Perl&quot;&gt;Threaded Perl&lt;/a&gt; later on.</source>
          <target state="translated">PerlをDBD :: Oracleなどのスレッドサポートを必要とするモジュールにリンクする場合は、_rバージョンのコンパイラを使用することをお勧めします。これはスレッド化されたPerlではなく、スレッド対応のPerlを構築します。&lt;a href=&quot;#Threaded-Perl&quot;&gt;スレッド化されたPerl&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="f3ae83db0cc3f44bcbcecf136bd4e7799904f67e" translate="yes" xml:space="preserve">
          <source>If you prefer &quot;regex&quot; over &quot;regexp&quot; in this tutorial, you could use the following program to replace it:</source>
          <target state="translated">このチュートリアルで &quot;regexp &quot;よりも &quot;regex &quot;の方が好きな場合は、以下のプログラムを使って置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="a59862b4b635be40786928d6e580b97f5fccb229" translate="yes" xml:space="preserve">
          <source>If you prefer 'regex' over 'regexp' in this tutorial, you could use the following program to replace it:</source>
          <target state="translated">このチュートリアルでは、'regexp'よりも'regex'の方が好きな場合は、以下のプログラムを使って置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="e975a86edf7cf3f2a85267ea19c5e7fb97348443" translate="yes" xml:space="preserve">
          <source>If you prefer &lt;code&gt;CPANPLUS&lt;/code&gt; , it's just as easy:</source>
          <target state="translated">&lt;code&gt;CPANPLUS&lt;/code&gt; を好むなら、それも同じくらい簡単です。</target>
        </trans-unit>
        <trans-unit id="7a50be93857181d27ad3f82440855d08d5614eb6" translate="yes" xml:space="preserve">
          <source>If you prefer &lt;code&gt;CPANPLUS&lt;/code&gt;, it's just as easy:</source>
          <target state="translated">&lt;code&gt;CPANPLUS&lt;/code&gt; を好む場合は、同じように簡単です。</target>
        </trans-unit>
        <trans-unit id="88b2286238e8c1ea0536c07d5d33ab84bc86bbaa" translate="yes" xml:space="preserve">
          <source>If you prefer not to import these routines into your namespace, you can call them as:</source>
          <target state="translated">これらのルーチンをネームスペースにインポートしたくない場合は、以下のように呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="02b429d0fbb0524681e65be7d6f8ab7830a0723a" translate="yes" xml:space="preserve">
          <source>If you prefer something more legible, use the File::stat module (part of the standard distribution in version 5.004 and later):</source>
          <target state="translated">より読みやすいものをお望みならば、File::statモジュール(バージョン5.004以降の標準ディストリビューションの一部)を使用してください。</target>
        </trans-unit>
        <trans-unit id="f0813e4f27c28bf6e883076eecebd37913fd5b51" translate="yes" xml:space="preserve">
          <source>If you prefer to do it more in a programmerish style in one single process, something like this may better suit you:</source>
          <target state="translated">一つのプロセスの中で、もっとプログラマー的なスタイルでやりたいという方には、このようなものの方が似合うかもしれません。</target>
        </trans-unit>
        <trans-unit id="ec90d5c6994006bb5fd89f190c78b5cdc340ee30" translate="yes" xml:space="preserve">
          <source>If you prefer to run your program first and look at its problem afterwards, do this:</source>
          <target state="translated">最初にプログラムを実行してから問題を見たい場合は、このようにします。</target>
        </trans-unit>
        <trans-unit id="aacba9db61987e99507860e0fb4bb65d12a9bd0f" translate="yes" xml:space="preserve">
          <source>If you prefer to use colour as a means of finding tricky whitespace characters then you can set the &lt;code&gt;TESTTESTCOLOUR&lt;/code&gt; environment variable to a comma separated pair of colours, the first for the foreground, the second for the background. For example &quot;white,red&quot; will print white text on a red background. This requires the Term::ANSIColor module. You can specify any colour that would be acceptable to the Term::ANSIColor::color function.</source>
          <target state="translated">トリッキーな空白文字を見つける手段として色を使用したい場合は、 &lt;code&gt;TESTTESTCOLOUR&lt;/code&gt; 環境変数を、最初は前景用、2番目は背景用のコンマ区切りの色のペアに設定できます。たとえば、「white、red」は、赤い背景に白いテキストを印刷します。これには、Term :: ANSIColorモジュールが必要です。Term :: ANSIColor :: color関数で使用できる任意の色を指定できます。</target>
        </trans-unit>
        <trans-unit id="3870b14accf24c65cf812dc3594ebf250f4f78e6" translate="yes" xml:space="preserve">
          <source>If you properly encode your strings for output, none of this is of your concern, and you can just &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; dumped data as always.</source>
          <target state="translated">出力用に文字列を適切にエンコードする場合、これは問題ではなく、ダンプデータをいつものように &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; できます。</target>
        </trans-unit>
        <trans-unit id="e766f156c26878a70aac60fe8090c0a4f6df2f3f" translate="yes" xml:space="preserve">
          <source>If you properly encode your strings for output, none of this is of your concern, and you can just &lt;code&gt;eval&lt;/code&gt; dumped data as always.</source>
          <target state="translated">出力用に文字列を適切にエンコードすれば、これは問題にならず、ダンプされたデータをいつものように &lt;code&gt;eval&lt;/code&gt; できます。</target>
        </trans-unit>
        <trans-unit id="065fd2bf37d0cb46e6971e495f8f9b0d94012ccb" translate="yes" xml:space="preserve">
          <source>If you provide a $name, that will be printed along with the &quot;ok/not ok&quot; to make it easier to find your test when if fails (just search for the name). It also makes it easier for the next guy to understand what your test is for. It's highly recommended you use test names.</source>
          <target state="translated">もし $name を指定すると、失敗したときにテストを見つけやすくするために &quot;OK/NG&quot; と一緒に表示されます (名前を検索してください)。また、次の人があなたのテストが何のためのものなのかを理解しやすくなります。それはあなたがテスト名を使用することを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="b7880cf2049cee53a05bb2b9ece1c4d6f2c66f65" translate="yes" xml:space="preserve">
          <source>If you put a &lt;code&gt;\&lt;/code&gt; in front of a variable, you get a reference to that variable.</source>
          <target state="translated">変数の前に &lt;code&gt;\&lt;/code&gt; を置くと、その変数への参照が得られます。</target>
        </trans-unit>
        <trans-unit id="34b57973357474bb06b6216c6a1396c52f47b8be" translate="yes" xml:space="preserve">
          <source>If you put extensions in unusual places, you can set PERL5LIB to a list of paths separated by semicolons where you want perl to look for libraries. Look for descriptions of other environment variables you can set in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">通常とは異なる場所に拡張機能を配置する場合は、PERLでライブラリを検索するセミコロンで区切られたパスのリストにPERL5LIBを設定できます。&lt;a href=&quot;perlrun&quot;&gt;perlrunで&lt;/a&gt;設定できる他の環境変数の説明を探します。</target>
        </trans-unit>
        <trans-unit id="4498166e1dac5738a547d2b9e86da7f11d00c4e8" translate="yes" xml:space="preserve">
          <source>If you put two contiguous tilde characters &quot;~~&quot; anywhere into a line, the line will be repeated until all the fields on the line are exhausted, i.e. undefined. For special (caret) text fields this will occur sooner or later, but if you use a text field of the at variety, the expression you supply had better not give the same value every time forever! (&lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@f)&lt;/a&gt;&lt;/code&gt; is a simple example that would work.) Don't use a regular (at) numeric field in such lines, because it will never go blank.</source>
          <target state="translated">連続する2つのチルダ文字「~~」を行のどこかに置くと、行のすべてのフィールドがなくなるまで、つまり未定義になるまで、行が繰り返されます。特殊な（キャレット）テキストフィールドの場合、これは遅かれ早かれ発生しますが、さまざまなテキストフィールドを使用する場合、指定する式が毎回同じ値を永久に与えない方がよいでしょう。（ &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift(@f)&lt;/a&gt;&lt;/code&gt; は機能する単純な例です。）このような行では通常の（at）数値フィールドを使用しないでください。空白になることはありません。</target>
        </trans-unit>
        <trans-unit id="5c6b6a167ca19e1425e3b4fcf8a618d7dce2d0b2" translate="yes" xml:space="preserve">
          <source>If you put two contiguous tilde characters &quot;~~&quot; anywhere into a line, the line will be repeated until all the fields on the line are exhausted, i.e. undefined. For special (caret) text fields this will occur sooner or later, but if you use a text field of the at variety, the expression you supply had better not give the same value every time forever! (&lt;code&gt;shift(@f)&lt;/code&gt; is a simple example that would work.) Don't use a regular (at) numeric field in such lines, because it will never go blank.</source>
          <target state="translated">2つの連続するチルダ文字「~~」を行の任意の場所に配置すると、行のすべてのフィールドが使い果たされるまで、つまり未定義になるまで、行が繰り返されます。特別な（キャレット）テキストフィールドの場合、これは遅かれ早かれ発生しますが、さまざまなテキストフィールドを使用する場合は、指定する式で毎回同じ値を指定しない方がよいでしょう。（ &lt;code&gt;shift(@f)&lt;/code&gt; は機能する単純な例です。）このような行では通常の（at）数値フィールドを使用しないでください。空白になることはありません。</target>
        </trans-unit>
        <trans-unit id="131e6f1801bde966ebc62c17a25904f6f6c22132" translate="yes" xml:space="preserve">
          <source>If you re-run &lt;code&gt;git status&lt;/code&gt;, you should see something like this:</source>
          <target state="translated">&lt;code&gt;git status&lt;/code&gt; を再実行すると、次のように表示されます。</target>
        </trans-unit>
        <trans-unit id="a6608312c76270dd048459022213c207db61db43" translate="yes" xml:space="preserve">
          <source>If you really do mean it, explicitly numify your reference, like so: &lt;code&gt;$array[0+$ref]&lt;/code&gt; . This warning is not given for overloaded objects, however, because you can overload the numification and stringification operators and then you presumably know what you are doing.</source>
          <target state="translated">あなたが本当にそれを意味する場合は、次のように明示的に参照を数値化してください： &lt;code&gt;$array[0+$ref]&lt;/code&gt; 。ただし、数値化演算子と文字列化演算子をオーバーロードでき、おそらく何をしているのかわかっているので、この警告はオーバーロードされたオブジェクトに対しては出されません。</target>
        </trans-unit>
        <trans-unit id="3f20955fb9ac108dca46685f37b1cba8f9e1d54b" translate="yes" xml:space="preserve">
          <source>If you really do mean it, explicitly numify your reference, like so: &lt;code&gt;$array[0+$ref]&lt;/code&gt;. This warning is not given for overloaded objects, however, because you can overload the numification and stringification operators and then you presumably know what you are doing.</source>
          <target state="translated">本当に意味がある場合は、 &lt;code&gt;$array[0+$ref]&lt;/code&gt; ように、参照を明示的に数値化します。ただし、この警告は、オーバーロードされたオブジェクトには表示されません。これは、数値化演算子と文字列化演算子をオーバーロードでき、おそらく何をしているのかがわかるためです。</target>
        </trans-unit>
        <trans-unit id="9b04e2e2f5675cd2c5905d17662a57b68104214b" translate="yes" xml:space="preserve">
          <source>If you really insist on using version.pm with an ordinary decimal version, use &lt;code&gt;parse()&lt;/code&gt; instead of declare. See the &lt;a href=&quot;#PARSING-AND-COMPARING-VERSIONS&quot;&gt;&quot;PARSING AND COMPARING VERSIONS&quot;&lt;/a&gt; for details.</source>
          <target state="translated">通常の10進バージョンでversion.pmを使用することを本当に主張する場合は、declareの代わりに &lt;code&gt;parse()&lt;/code&gt; を使用してください。詳細については、&lt;a href=&quot;#PARSING-AND-COMPARING-VERSIONS&quot;&gt;「バージョンの解析と比較」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="1013051a31faa052729be2f388df420c87199413" translate="yes" xml:space="preserve">
          <source>If you really need to see whether the change has been accepted simply examine the return value of &lt;code&gt;safe_level&lt;/code&gt;.</source>
          <target state="translated">変更が受け入れられたかどうかを本当に確認する必要がある場合は、 &lt;code&gt;safe_level&lt;/code&gt; の戻り値を調べるだけです。</target>
        </trans-unit>
        <trans-unit id="2e6ee3c0e5f77f2901d0e16f7c2a62b5dc496ad9" translate="yes" xml:space="preserve">
          <source>If you really need to see whether the change has been accepted simply examine the return value of C</source>
          <target state="translated">変更が受け入れられたかどうかを本当に確認する必要がある場合は、C</target>
        </trans-unit>
        <trans-unit id="dd150284dfc14b1b33a794d882418a56b32b28b6" translate="yes" xml:space="preserve">
          <source>If you really want a subroutine with a &lt;code&gt;()&lt;/code&gt; prototype that returns a lexical variable you can easily force it to not be inlined by adding an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">字句変数を返す &lt;code&gt;()&lt;/code&gt; プロトタイプを持つサブルーチンが本当に必要な場合は、明示的な &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; を追加することで、インライン化しないように簡単に強制できます。</target>
        </trans-unit>
        <trans-unit id="35a28f2c0d08eecba0c0e0394cdcfb91fe1c86b5" translate="yes" xml:space="preserve">
          <source>If you really want a subroutine with a &lt;code&gt;()&lt;/code&gt; prototype that returns a lexical variable you can easily force it to not be inlined by adding an explicit &lt;code&gt;return&lt;/code&gt;:</source>
          <target state="translated">字句変数を返す &lt;code&gt;()&lt;/code&gt; プロトタイプを持つサブルーチンが本当に必要な場合は、明示的な &lt;code&gt;return&lt;/code&gt; 追加することで、インライン化されないように簡単に強制できます。</target>
        </trans-unit>
        <trans-unit id="f0166a5725d2770573e3a305750b9dd3edf5c05f" translate="yes" xml:space="preserve">
          <source>If you really want comments, build your list the old-fashioned way, with quotes and commas:</source>
          <target state="translated">本当にコメントが欲しいのであれば、引用符とカンマを使って昔ながらの方法でリストを作成しましょう。</target>
        </trans-unit>
        <trans-unit id="f8aa3dfe02cc827e79905e1ddc0f6d36b724e3c5" translate="yes" xml:space="preserve">
          <source>If you really want just plain byte strings, use my_snprintf() and my_vsnprintf() instead, which will try to use snprintf() and vsnprintf() if those safer APIs are available. If you want something fancier than a plain byte string, use &lt;a href=&quot;perlapi#form&quot;&gt;&lt;code&gt;Perl_form&lt;/code&gt;()&lt;/a&gt; or SVs and &lt;a href=&quot;perlapi#sv_catpvf&quot;&gt;&lt;code&gt;Perl_sv_catpvf()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">プレーンバイト文字列だけが本当に必要な場合は、代わりにmy_snprintf（）とmy_vsnprintf（）を使用します。これらのより安全なAPIが利用可能な場合は、snprintf（）とvsnprintf（）を使用しようとします。プレーンなバイト文字列よりも凝ったものが必要な場合は、&lt;a href=&quot;perlapi#form&quot;&gt; &lt;code&gt;Perl_form&lt;/code&gt; （）&lt;/a&gt;またはSVと&lt;a href=&quot;perlapi#sv_catpvf&quot;&gt; &lt;code&gt;Perl_sv_catpvf()&lt;/code&gt; を使用してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb99b666d9e169ba81737784680da343f375dd69" translate="yes" xml:space="preserve">
          <source>If you really want just plain byte strings, use my_snprintf() and my_vsnprintf() instead, which will try to use snprintf() and vsnprintf() if those safer APIs are available. If you want something fancier than a plain byte string, use &lt;a href=&quot;perlapi#form&quot;&gt;Perl_form ()&lt;/a&gt; or SVs and &lt;a href=&quot;perlapi#sv_catpvf&quot;&gt;Perl_sv_catpvf() &lt;/a&gt;.</source>
          <target state="translated">プレーンバイト文字列だけが本当に必要な場合は、代わりにmy_snprintf（）とmy_vsnprintf（）を使用してください。これらの安全なAPIが利用可能な場合は、snprintf（）とvsnprintf（）を使用しようとします。プレーンバイト文字列よりも洗練されたものが必要な場合は、&lt;a href=&quot;perlapi#form&quot;&gt;Perl_form（）&lt;/a&gt;またはSVおよび&lt;a href=&quot;perlapi#sv_catpvf&quot;&gt;Perl_sv_catpvf（）を使用し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="1c2d9e52e0617d90849665511b4fb2b333643750" translate="yes" xml:space="preserve">
          <source>If you really want to be international, you should consider Unicode. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt; and &lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt; for more information.</source>
          <target state="translated">本当に国際的になりたいのであれば、Unicodeを検討すべきです。詳細については、&lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;および&lt;a href=&quot;perlunicode&quot;&gt;perlunicode&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7a1586770541996a5a05c7da504fe6b4a6bdef4c" translate="yes" xml:space="preserve">
          <source>If you really want to do this, you can use &lt;code&gt;ExtUtils::Manifest::manifind()&lt;/code&gt; to read the MANIFEST and File::Find to delete the files. But you have to be careful. Here's a script to do that. Use at your own risk. Have fun blowing holes in your foot.</source>
          <target state="translated">これを本当に実行したい場合は、 &lt;code&gt;ExtUtils::Manifest::manifind()&lt;/code&gt; を使用してMANIFESTを読み取り、File :: Findを使用してファイルを削除できます。ただし、注意が必要です。これを行うスクリプトは次のとおりです。自己責任。足の穴を吹いて楽しんでください。</target>
        </trans-unit>
        <trans-unit id="a9347a0885d5cc8b4c2356aaadf69fb6797e3c1b" translate="yes" xml:space="preserve">
          <source>If you really want to, you can use the standard open2() from the &lt;a href=&quot;IPC::Open2&quot;&gt;IPC::Open2&lt;/a&gt; module to catch both ends. There's also an open3() in &lt;a href=&quot;IPC::Open3&quot;&gt;IPC::Open3&lt;/a&gt; for tridirectional I/O so you can also catch your child's STDERR, but doing so would then require an awkward select() loop and wouldn't allow you to use normal Perl input operations.</source>
          <target state="translated">本当に必要な場合は、&lt;a href=&quot;IPC::Open2&quot;&gt;IPC :: Open2&lt;/a&gt;モジュールの標準のopen2（）を使用して、両端をキャッチできます。&lt;a href=&quot;IPC::Open3&quot;&gt;IPC :: Open3に&lt;/a&gt;は3方向I / O用のopen3（）もあるので、お子様のSTDERRをキャッチすることもできますが、そうすると厄介なselect（）ループが必要になり、通常のPerl入力操作を使用できなくなります。</target>
        </trans-unit>
        <trans-unit id="bd0128791efed65e3bbb8d082044be49dfce046e" translate="yes" xml:space="preserve">
          <source>If you really want to, you can use the standard open2() from the &lt;code&gt;IPC::Open2&lt;/code&gt; module to catch both ends. There's also an open3() in &lt;code&gt;IPC::Open3&lt;/code&gt; for tridirectional I/O so you can also catch your child's STDERR, but doing so would then require an awkward select() loop and wouldn't allow you to use normal Perl input operations.</source>
          <target state="translated">本当にやりたい場合は、 &lt;code&gt;IPC::Open2&lt;/code&gt; モジュールの標準のopen2（）を使用して両端をキャッチできます。 &lt;code&gt;IPC::Open3&lt;/code&gt; 、三方向I / O用のopen3（）もあるので、子のSTDERRをキャッチすることもできますが、そうすると、厄介なselect（）ループが必要になり、通常のPerl入力操作を使用できなくなります。</target>
        </trans-unit>
        <trans-unit id="3c3fc1f61dc62bd06eef70c14d9957a3cba43c99" translate="yes" xml:space="preserve">
          <source>If you receive this error with a subroutine that has a real name, then you may have found a bug in autodie. See &lt;a href=&quot;autodie#BUGS&quot;&gt;&quot;BUGS&quot; in autodie&lt;/a&gt; for how to report this.</source>
          <target state="translated">本名のサブルーチンでこのエラーが発生した場合は、autodieにバグが見つかった可能性があります。これを報告する方法について&lt;a href=&quot;autodie#BUGS&quot;&gt;は、autodieの「バグ」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="53be29d9aa606768bcbe9e3309afe9ba5b57da03" translate="yes" xml:space="preserve">
          <source>If you recognized the quote about the Road above, you're in luck.</source>
          <target state="translated">上の道路に関する引用を認識していたならば、あなたは運が良いです。</target>
        </trans-unit>
        <trans-unit id="39a2ad311b79ed3072c37af199bf41f9f9aebf15" translate="yes" xml:space="preserve">
          <source>If you redefine a subroutine that was eligible for inlining, you'll get a warning by default. You can use this warning to tell whether or not a particular subroutine is considered inlinable, since it's different than the warning for overriding non-inlined subroutines:</source>
          <target state="translated">インライン化の対象となっていたサブルーチンを再定義すると、デフォルトで警告が表示されます。この警告は、インライン化されていないサブルーチンをオーバーライドする際の警告とは異なるので、特定のサブルーチンがインライン化可能とみなされるかどうかを知るために使うことができます。</target>
        </trans-unit>
        <trans-unit id="ef0afdd765138635cef800ba6a31de68edaeb90c" translate="yes" xml:space="preserve">
          <source>If you require more flexibility than</source>
          <target state="translated">よりも柔軟性が必要な場合は</target>
        </trans-unit>
        <trans-unit id="432e76406abd8db96136b5a2df1a568bbdde9d3f" translate="yes" xml:space="preserve">
          <source>If you resize the array with deferred writing enabled, the file will be resized immediately, but deferred records will not be written. This has a surprising consequence: &lt;code&gt;@a = (...)&lt;/code&gt; erases the file immediately, but the writing of the actual data is deferred. This might be a bug. If it is a bug, it will be fixed in a future version.</source>
          <target state="translated">遅延書き込みを有効にして配列のサイズを変更すると、ファイルはすぐにサイズ変更されますが、遅延レコードは書き込まれません。これには驚くべき結果があります。 &lt;code&gt;@a = (...)&lt;/code&gt; はファイルをすぐに消去しますが、実際のデータの書き込みは延期されます。これはバグかもしれません。バグの場合は、将来のバージョンで修正される予定です。</target>
        </trans-unit>
        <trans-unit id="21c1c9d8d7fcdca9d7bb7cd7ffec5848c2f729ce" translate="yes" xml:space="preserve">
          <source>If you run Perl with the &lt;a href=&quot;warnings&quot;&gt;&lt;code&gt;use warnings&lt;/code&gt;&lt;/a&gt; pragma, it can warn you about this. For example, the third line above produces:</source>
          <target state="translated">&lt;a href=&quot;warnings&quot;&gt; &lt;code&gt;use warnings&lt;/code&gt; &lt;/a&gt;プラグマを使用してPerlを実行すると、これについて警告することができます。たとえば、上記の3行目は次のようになります。</target>
        </trans-unit>
        <trans-unit id="b95da308b81d0840cacd6821e3c3f91e04b82e8a" translate="yes" xml:space="preserve">
          <source>If you run Perl with the &lt;b&gt;-w&lt;/b&gt; switch it can warn you about this. For example, the third line above produces:</source>
          <target state="translated">&lt;b&gt;-w&lt;/b&gt;スイッチを指定してPerlを実行すると、警告が表示されます。たとえば、上記の3行目は以下を生成します。</target>
        </trans-unit>
        <trans-unit id="1983e4f73a942cb1a7c7741631cd3c3e344c8e03" translate="yes" xml:space="preserve">
          <source>If you run the script with the &lt;code&gt;-w&lt;/code&gt; flag the error message becomes:</source>
          <target state="translated">&lt;code&gt;-w&lt;/code&gt; フラグを指定してスクリプトを実行すると、エラーメッセージは次のようになります。</target>
        </trans-unit>
        <trans-unit id="a9ad6a9bb0a2be45f4030cad900647a4bc2c1db1" translate="yes" xml:space="preserve">
          <source>If you run this code twice, the contents of the</source>
          <target state="translated">このコードを2回実行すると</target>
        </trans-unit>
        <trans-unit id="80dfce6f2a878c8f488ddf11e051d8fa78b7f75e" translate="yes" xml:space="preserve">
          <source>If you run your program with the &lt;code&gt;-w&lt;/code&gt; switch, or if you use the &lt;code&gt;warnings&lt;/code&gt; pragma, File::Find will report warnings for several weird situations. You can disable these warnings by putting the statement</source>
          <target state="translated">&lt;code&gt;-w&lt;/code&gt; スイッチを指定してプログラムを実行する場合、または &lt;code&gt;warnings&lt;/code&gt; プラグマを使用する場合、File :: Findはいくつかの奇妙な状況の警告を報告します。次のステートメントを入力して、これらの警告を無効にすることができます</target>
        </trans-unit>
        <trans-unit id="714149520d778ab4a3aa775aef45bdd606216fd6" translate="yes" xml:space="preserve">
          <source>If you say</source>
          <target state="translated">もしあなたが言うなら</target>
        </trans-unit>
        <trans-unit id="84e83e7869cb30f17fc9ab2b3dafef8f917abf86" translate="yes" xml:space="preserve">
          <source>If you say yes to the following question, CPAN will try to store enough information about the build process so that it can pick up in future sessions at the same state of affairs as it left a previous session.</source>
          <target state="translated">以下の質問に「はい」と答えた場合、CPANはビルドプロセスに関する十分な情報を保存して、将来のセッションで前のセッションを離れたときと同じ状態でピックアップできるようにします。</target>
        </trans-unit>
        <trans-unit id="3a116108872049154f6c27d6353e551d6d6917b4" translate="yes" xml:space="preserve">
          <source>If you see &quot;bad interpreter - no such file or directory&quot;, the first line in your perl script (the &quot;shebang&quot; line) does not contain the right path to perl (or any other program capable of running scripts). Sometimes this happens when you move the script from one machine to another and each machine has a different path to perl--/usr/bin/perl versus /usr/local/bin/perl for instance. It may also indicate that the source machine has CRLF line terminators and the destination machine has LF only: the shell tries to find /usr/bin/perl&amp;lt;CR&amp;gt;, but can't.</source>
          <target state="translated">「悪いインタプリタ-そのようなファイルやディレクトリはありません」と表示される場合、perlスクリプトの最初の行（「shebang」行）には、perl（またはスクリプトを実行できる他のプログラム）への正しいパスが含まれていません。これは、スクリプトをあるマシンから別のマシンに移動し、各マシンがperlへの異なるパスを持っている場合に発生することがあります-/ usr / bin / perlと/ usr / local / bin / perlなど。また、ソースマシンにCRLF行ターミネーターがあり、宛先マシンにLFしかないことを示す場合もあります。シェルは/ usr / bin / perl &amp;lt;CR&amp;gt;を見つけようとしますが、できません。</target>
        </trans-unit>
        <trans-unit id="2f85a9726440183decd897c1fff5988cce63ccf9" translate="yes" xml:space="preserve">
          <source>If you see &quot;bad interpreter: Permission denied&quot;, you need to make your script executable.</source>
          <target state="translated">bad interpreter.Permission denied」と表示されたら、スクリプトを実行可能にする必要があります。</target>
        </trans-unit>
        <trans-unit id="8de6b12e8e3d869536fad39850a1db08fd9bac7f" translate="yes" xml:space="preserve">
          <source>If you see in a debugger a memory area mysteriously full of 0xABABABAB or 0xEFEFEFEF, you may be seeing the effect of the Poison() macros, see &lt;a href=&quot;perlclib&quot;&gt;perlclib&lt;/a&gt;.</source>
          <target state="translated">デバッガーで0xABABABABまたは0xEFEFEFEFの不思議ないっぱいのメモリ領域が表示される場合は、Poison（）マクロの効果が表示されている可能性があります&lt;a href=&quot;perlclib&quot;&gt;。perlclibを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="8d3df616229a0ebfcb7922d24bec233001d332f4" translate="yes" xml:space="preserve">
          <source>If you see right after &quot;make&quot; this</source>
          <target state="translated">make」の直後に表示されている場合は</target>
        </trans-unit>
        <trans-unit id="d8e7a131ddc6c256b7162ac7f1766e22fd038d65" translate="yes" xml:space="preserve">
          <source>If you see that you're leaking memory at runtime, but neither valgrind nor &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; will find anything, you're probably leaking SVs that are still reachable and will be properly cleaned up during destruction of the interpreter. In such cases, using the &lt;code&gt;-Dm&lt;/code&gt; switch can point you to the source of the leak. If the executable was built with &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; , &lt;code&gt;-Dm&lt;/code&gt; will output SV allocations in addition to memory allocations. Each SV allocation has a distinct serial number that will be written on creation and destruction of the SV. So if you're executing the leaking code in a loop, you need to look for SVs that are created, but never destroyed between each cycle. If such an SV is found, set a conditional breakpoint within &lt;code&gt;new_SV()&lt;/code&gt; and make it break only when &lt;code&gt;PL_sv_serial&lt;/code&gt; is equal to the serial number of the leaking SV. Then you will catch the interpreter in exactly the state where the leaking SV is allocated, which is sufficient in many cases to find the source of the leak.</source>
          <target state="translated">実行時にメモリをリークしているのに、valgrindも &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; も何も検出しない場合は、おそらく到達可能なSVをリークしており、インタープリターの破棄中に適切にクリーンアップされます。このような場合、 &lt;code&gt;-Dm&lt;/code&gt; スイッチを使用すると、リークの原因を特定できます。実行可能ファイルが構築されていた場合 &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; 、 &lt;code&gt;-Dm&lt;/code&gt; メモリ割り当てに加えてSV割り当てを出力します。各SV割り当てには、SVの作成および破棄時に書き込まれる個別のシリアル番号があります。したがって、リークしているコードをループで実行している場合は、作成されたSVを探す必要がありますが、各サイクル間で破棄されることはありません。そのようなSVが見つかった場合は、 &lt;code&gt;new_SV()&lt;/code&gt; 内に条件付きブレークポイントを設定し、 &lt;code&gt;PL_sv_serial&lt;/code&gt; がリークしているSVのシリアル番号と等しい場合にのみブレークポイントを解除します。次に、リークしているSVが割り当てられている状態でインタプリタを正確にキャッチします。これは、多くの場合、リークのソースを見つけるのに十分です。</target>
        </trans-unit>
        <trans-unit id="00d516d64e31e37eefa736f20d08e45a8565422c" translate="yes" xml:space="preserve">
          <source>If you see that you're leaking memory at runtime, but neither valgrind nor &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; will find anything, you're probably leaking SVs that are still reachable and will be properly cleaned up during destruction of the interpreter. In such cases, using the &lt;code&gt;-Dm&lt;/code&gt; switch can point you to the source of the leak. If the executable was built with &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt;, &lt;code&gt;-Dm&lt;/code&gt; will output SV allocations in addition to memory allocations. Each SV allocation has a distinct serial number that will be written on creation and destruction of the SV. So if you're executing the leaking code in a loop, you need to look for SVs that are created, but never destroyed between each cycle. If such an SV is found, set a conditional breakpoint within &lt;code&gt;new_SV()&lt;/code&gt; and make it break only when &lt;code&gt;PL_sv_serial&lt;/code&gt; is equal to the serial number of the leaking SV. Then you will catch the interpreter in exactly the state where the leaking SV is allocated, which is sufficient in many cases to find the source of the leak.</source>
          <target state="translated">実行時にメモリリークが発生しているのに、valgrindも &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; も何も検出されない場合は、おそらく到達可能であり、インタプリタの破棄中に適切にクリーンアップされるSVをリークしています。このような場合、 &lt;code&gt;-Dm&lt;/code&gt; スイッチを使用すると、リークの原因を特定できます。実行可能ファイルが構築されていた場合 &lt;code&gt;-DDEBUG_LEAKING_SCALARS&lt;/code&gt; 、 &lt;code&gt;-Dm&lt;/code&gt; メモリ割り当てに加えてSV割り当てを出力します。各SV割り当てには、SVの作成と破棄時に書き込まれる個別のシリアル番号があります。したがって、リークしているコードをループで実行している場合は、作成されているが、各サイクル間で破棄されていないSVを探す必要があります。そのようなSVが見つかった場合は、 &lt;code&gt;new_SV()&lt;/code&gt; 内に条件付きブレークポイントを設定し、 &lt;code&gt;PL_sv_serial&lt;/code&gt; がリークしているSVのシリアル番号と等しい場合にのみブレークさせます。次に、リークしているSVが割り当てられている状態でインタプリタを正確にキャッチします。これは、多くの場合、リークの原因を見つけるのに十分です。</target>
        </trans-unit>
        <trans-unit id="2bbf4110deb94dbc624ccee947cca19c596a9010" translate="yes" xml:space="preserve">
          <source>If you see this</source>
          <target state="translated">これを見たら</target>
        </trans-unit>
        <trans-unit id="4203dc6863ea2ff3c77a2428ddc46eaf1f7849d3" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;$DB::single&lt;/code&gt; to 2, it's equivalent to having just typed the &lt;code&gt;n&lt;/code&gt; command, whereas a value of 1 means the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; command. The &lt;code&gt;$DB::trace&lt;/code&gt; variable should be set to 1 to simulate having typed the &lt;code&gt;t&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;$DB::single&lt;/code&gt; を2に設定すると、 &lt;code&gt;n&lt;/code&gt; コマンドを入力したのと同じことになりますが、値1は &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; コマンドを意味します。 &lt;code&gt;$DB::trace&lt;/code&gt; 変数は、型付きたシミュレートするために、1に設定する必要があります &lt;code&gt;t&lt;/code&gt; コマンドを。</target>
        </trans-unit>
        <trans-unit id="7b33b418b3104ec5416e5681959ccdc2c9bea5af" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;$DB::single&lt;/code&gt; to 2, it's equivalent to having just typed the &lt;code&gt;n&lt;/code&gt; command, whereas a value of 1 means the &lt;code&gt;s&lt;/code&gt; command. The &lt;code&gt;$DB::trace&lt;/code&gt; variable should be set to 1 to simulate having typed the &lt;code&gt;t&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;$DB::single&lt;/code&gt; を2に設定した場合、 &lt;code&gt;n&lt;/code&gt; コマンドを入力したのと同じですが、値1は &lt;code&gt;s&lt;/code&gt; コマンドを意味します。 &lt;code&gt;t&lt;/code&gt; コマンドを入力したことをシミュレートするには、 &lt;code&gt;$DB::trace&lt;/code&gt; 変数を1に設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="a5d30ba8967fd6c8924240ee40d5a140a986b280" translate="yes" xml:space="preserve">
          <source>If you set a value for this attribute, the value is expected to be an object (probably of a class that you define) that has a &lt;code&gt;reach&lt;/code&gt; method and a &lt;code&gt;done&lt;/code&gt; method. This is meant for reporting progress during the search, if you don't want to use a simple callback.</source>
          <target state="translated">この属性に値を設定する場合、その値は、 &lt;code&gt;reach&lt;/code&gt; メソッドと &lt;code&gt;done&lt;/code&gt; メソッドを持つオブジェクト（おそらく、定義したクラスのオブジェクト）であると想定されます。これは、単純なコールバックを使用したくない場合に、検索中に進行状況を報告するためのものです。</target>
        </trans-unit>
        <trans-unit id="bcde195e379d8e8445763e6616418aa0a7c91d66" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;parse_characters&lt;/code&gt; option to a true value the parser will expect characters rather than octets; will ignore any &lt;code&gt;=encoding&lt;/code&gt; ; and will make no attempt to decode the input.</source>
          <target state="translated">&lt;code&gt;parse_characters&lt;/code&gt; オプションをtrue値に設定すると、パーサーはオクテットではなく文字を予期します。 &lt;code&gt;=encoding&lt;/code&gt; は無視されます。そして、入力をデコードしようとはしません。</target>
        </trans-unit>
        <trans-unit id="f6202a4ce3a92187f86730903457c240d414eaac" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;parse_characters&lt;/code&gt; option to a true value the parser will expect characters rather than octets; will ignore any &lt;code&gt;=encoding&lt;/code&gt;; and will make no attempt to decode the input.</source>
          <target state="translated">&lt;code&gt;parse_characters&lt;/code&gt; オプションをtrue値に設定すると、パーサーはオクテットではなく文字を期待します。 &lt;code&gt;=encoding&lt;/code&gt; を無視します; 入力をデコードしようとはしません。</target>
        </trans-unit>
        <trans-unit id="24318749936760c8c43beac827cb9d11fbd59672" translate="yes" xml:space="preserve">
          <source>If you set this attribute to a true value, it will send reports of parsing errors to STDERR. By default, this attribute's value is false, meaning that no output is sent to STDERR.</source>
          <target state="translated">この属性を真の値に設定すると、解析エラーのレポートを STDERR に送信します。デフォルトでは、この属性の値はfalseであり、STDERRに出力が送られないことを意味します。</target>
        </trans-unit>
        <trans-unit id="230572eb4ee772d17d86eabe528a430137c47e2e" translate="yes" xml:space="preserve">
          <source>If you set this attribute to a true value, the parser will try to preserve whitespace in the output. This means that such formatting conventions as two spaces after periods will be preserved by the parser. This is primarily useful for output formats that treat whitespace as significant (such as text or *roff, but not HTML).</source>
          <target state="translated">この属性を真の値に設定すると、パーサは出力で空白を保存しようとします。これは、ピリオドの後にスペースが2つあるような書式規則がパーサによって保存されることを意味します。これは主に、空白を重要なものとして扱う出力フォーマット(HTMLではなく、テキストや*roffなど)に便利です。</target>
        </trans-unit>
        <trans-unit id="b5b8252659bce51d0b80d2e62f37a533a1cac341" translate="yes" xml:space="preserve">
          <source>If you set this attribute to a true value, you will stop the parser from generating a &quot;POD ERRORS&quot; section at the end of the document. By default, this attribute's value is false, meaning that an errata section will be generated, as necessary.</source>
          <target state="translated">この属性を true に設定すると、パーサがドキュメントの最後に &quot;POD ERRORS&quot; セクションを生成しないようにします。デフォルトでは、この属性の値は false で、必要に応じて正誤表セクションが生成されます。</target>
        </trans-unit>
        <trans-unit id="551f3a0a87736ea2dc54ed40fd31f1fb500e9541" translate="yes" xml:space="preserve">
          <source>If you set this attribute to a true value, you will suppress the parser's complaints about irregularities in the Pod coding. By default, this attribute's value is false, meaning that irregularities will be reported.</source>
          <target state="translated">この属性の値をtrueに設定すると、Podコーディングの不規則性に対するパーサからの苦情を抑制します。デフォルトでは、この属性の値はfalseであり、不規則性が報告されることを意味します。</target>
        </trans-unit>
        <trans-unit id="e0f5cb1c277b98516d80bdfac1209f73af95fdc5" translate="yes" xml:space="preserve">
          <source>If you set this flag, all keys passed in the following manner:</source>
          <target state="translated">このフラグを設定すると、以下のようにすべてのキーが渡されます。</target>
        </trans-unit>
        <trans-unit id="90adec0aabd8555567c00e54faf42cc1c5fd95da" translate="yes" xml:space="preserve">
          <source>If you set this flag, unknown options will still be present in the return value, rather than filtered out. This is useful if your subroutine is only interested in a few arguments, and wants to pass the rest on blindly to perhaps another subroutine.</source>
          <target state="translated">このフラグを設定した場合、未知のオプションはフィルタリングされるのではなく、戻り値に存在します。これは、あなたのサブルーチンがいくつかの引数にしか興味がなく、残りの部分を他のサブルーチンに渡したい場合に便利です。</target>
        </trans-unit>
        <trans-unit id="71c1c224b5079dff6437c4c296c3882a0dbe0842" translate="yes" xml:space="preserve">
          <source>If you set this value to 0, these processes will wait forever. This is the default and recommended setting.</source>
          <target state="translated">この値を 0 に設定すると、これらのプロセスは永遠に待機します。これはデフォルトで推奨される設定です。</target>
        </trans-unit>
        <trans-unit id="57bb7a66b14f683a002bf6e9ed419bdbfaba4540" translate="yes" xml:space="preserve">
          <source>If you simply need to check quickly to see if a module is available, you can check for its documentation. If you can read the documentation the module is most likely installed. If you cannot read the documentation, the module might not have any (in rare cases):</source>
          <target state="translated">モジュールが利用可能かどうかを素早く確認する必要がある場合は、そのモジュールのドキュメントをチェックすることができます。ドキュメントを読むことができれば、そのモジュールはインストールされている可能性が高いです。ドキュメントが読めない場合は、モジュールは何も持っていないかもしれません (まれに)。</target>
        </trans-unit>
        <trans-unit id="62a930272a7b67c86c0db7dd61a11f4230b11d14" translate="yes" xml:space="preserve">
          <source>If you simply want &lt;code&gt;TAP::Parser&lt;/code&gt; to handle a new source of TAP you probably don't need to subclass &lt;code&gt;TAP::Parser&lt;/code&gt; itself. Rather, you'll need to create a new &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; class, and just plug it into the parser using the</source>
          <target state="translated">&lt;code&gt;TAP::Parser&lt;/code&gt; にTAPの新しいソースを処理させたいだけの場合は、おそらく &lt;code&gt;TAP::Parser&lt;/code&gt; 自体をサブクラス化する必要はありません。むしろ、新しい&lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;クラスを作成し、それを使用してパーサーにプラグインする必要があります。</target>
        </trans-unit>
        <trans-unit id="8217a1604a7e6dedea6a0a5e3eee8fea23c61b15" translate="yes" xml:space="preserve">
          <source>If you simply want &lt;code&gt;TAP::Parser&lt;/code&gt; to handle a new source of TAP you probably don't need to subclass &lt;code&gt;TAP::Parser&lt;/code&gt; itself. Rather, you'll need to create a new &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt; class, and just plug it into the parser using the</source>
          <target state="translated">&lt;code&gt;TAP::Parser&lt;/code&gt; にTAPの新しいソースを処理させたいだけの場合は、おそらく &lt;code&gt;TAP::Parser&lt;/code&gt; 自体をサブクラス化する必要はありません。代わりに、新しい&lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;クラスを作成し、それを使用してパーサーにプラグインする必要があります。</target>
        </trans-unit>
        <trans-unit id="bccc23097030849c37e4990da975ad564b128d6e" translate="yes" xml:space="preserve">
          <source>If you simply want to check that a variable contains an object reference, we recommend that you use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; blessed($object)&lt;/code&gt; , since &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; returns true values for all references, not just objects.</source>
          <target state="translated">あなたは、単に変数がオブジェクト参照が含まれていることを確認したい場合は、我々はあなたが使用することをお勧めし &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; blessed($object)&lt;/code&gt; 、以来、 &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; のすべての参照のために戻って真の値だけではなく、オブジェクト。</target>
        </trans-unit>
        <trans-unit id="0eff4b8cc8d1302b285b2ea0f2efb3650eee76be" translate="yes" xml:space="preserve">
          <source>If you simply want to check that a variable contains an object reference, we recommend that you use &lt;code&gt;defined blessed($object)&lt;/code&gt;, since &lt;code&gt;ref&lt;/code&gt; returns true values for all references, not just objects.</source>
          <target state="translated">変数にオブジェクト参照が含まれていることを確認したいだけの場合は、 &lt;code&gt;defined blessed($object)&lt;/code&gt; を使用することをお勧めします。これは、 &lt;code&gt;ref&lt;/code&gt; がオブジェクトだけでなくすべての参照に対してtrue値を返すためです。</target>
        </trans-unit>
        <trans-unit id="775bfc9c0c8443d71c6d6889e2281bdebabd0a98" translate="yes" xml:space="preserve">
          <source>If you simply want to do a little tweaking of how the tests behave, you can access the underlying &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; object like so:</source>
          <target state="translated">テストの動作を少し調整したいだけの場合は、次のように、基になる&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt;オブジェクトにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="538504cf71c29fca71496cb30f3e2c1293640623" translate="yes" xml:space="preserve">
          <source>If you simply want to do a little tweaking of how the tests behave, you can access the underlying &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; object like so:</source>
          <target state="translated">テストの動作を少し調整したいだけの場合は、以下のように、基になる&lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt;オブジェクトにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="529d627921bb06c8d7af89d86ac316fcc827cff3" translate="yes" xml:space="preserve">
          <source>If you simply want to intercept all results instead of letting them go to TAP, you should look at the &lt;a href=&quot;Test2::API&quot;&gt;Test2::API&lt;/a&gt; docs and read about pushing a new hub onto the hub stack. Replacing the hub temporarily is now the correct way to intercept results.</source>
          <target state="translated">結果をTAPに&lt;a href=&quot;Test2::API&quot;&gt;送るの&lt;/a&gt;ではなく、単にすべての結果をインターセプトしたい場合は、Test2 :: APIのドキュメントを参照して、新しいハブをハブスタックにプッシュする方法について読んでください。ハブを一時的に交換することが、結果を傍受する正しい方法になりました。</target>
        </trans-unit>
        <trans-unit id="e8d0959c4e3749a28ef9e062bf2ea64f531c9a4d" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;'&amp;lt;&amp;amp;=X'&lt;/code&gt; , where &lt;code&gt;X&lt;/code&gt; is a file descriptor number or a filehandle, then Perl will do an equivalent of C's &lt;code&gt;fdopen&lt;/code&gt; of that file descriptor (and not call &lt;code&gt;dup(2)&lt;/code&gt; ); this is more parsimonious of file descriptors. For example:</source>
          <target state="translated">&lt;code&gt;'&amp;lt;&amp;amp;=X'&lt;/code&gt; （ &lt;code&gt;X&lt;/code&gt; はファイル記述子番号またはファイルハンドル）を指定した場合、Perlはそのファイル記述子のCの &lt;code&gt;fdopen&lt;/code&gt; と同等の処理を行います（ &lt;code&gt;dup(2)&lt;/code&gt; を呼び出さない）。これは、ファイル記述子のより簡潔です。例えば：</target>
        </trans-unit>
        <trans-unit id="374cb57ad3f006566ce6e2725d54d8c62c1dbbdd" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;'&amp;lt;&amp;amp;=X'&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is a file descriptor number or a filehandle, then Perl will do an equivalent of C's &lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen(3)&lt;/a&gt; of that file descriptor (and not call &lt;a href=&quot;http://man.he.net/man2/dup&quot;&gt;dup(2)&lt;/a&gt;); this is more parsimonious of file descriptors. For example:</source>
          <target state="translated">&lt;code&gt;'&amp;lt;&amp;amp;=X'&lt;/code&gt; を指定すると、 &lt;code&gt;X&lt;/code&gt; はファイル記述子番号またはファイルハンドルであり、Perlはそのファイル記述子のCの&lt;a href=&quot;http://man.he.net/man3/fdopen&quot;&gt;fdopen（3）&lt;/a&gt;と同等の処理を実行します（&lt;a href=&quot;http://man.he.net/man2/dup&quot;&gt;dup（2）&lt;/a&gt;は呼び出さない）。これはファイル記述子をより節約します。例えば：</target>
        </trans-unit>
        <trans-unit id="180f2fd51c0d498482504f1f96654a60c731b6ff" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;NUM_USES&lt;/code&gt; with an argument of</source>
          <target state="translated">&lt;code&gt;NUM_USES&lt;/code&gt; を引数として指定した場合</target>
        </trans-unit>
        <trans-unit id="8d4306b9666c2a3ba16744fba22e147888a1f901" translate="yes" xml:space="preserve">
          <source>If you specify COMPRESS, then SUFFIX should also be altered, as it is needed to tell make the target file of the compression. Setting DIST_CP to ln can be useful, if you need to preserve the timestamps on your files. DIST_CP can take the values 'cp', which copies the file, 'ln', which links the file, and 'best' which copies symbolic links and links the rest. Default is 'best'.</source>
          <target state="translated">COMPRESSを指定した場合、SUFFIXも変更する必要があります。DIST_CP を ln に設定すると、ファイルのタイムスタンプを保存する必要がある場合に便利です。DIST_CP には、ファイルをコピーする 'cp'、ファイルをリンクする 'ln'、シンボリックリンクをコピーして残りをリンクする 'best' の値を取ることができます。デフォルトは 'best' です。</target>
        </trans-unit>
        <trans-unit id="fc451ad5db1446b8366614b6922be5421ce289a8" translate="yes" xml:space="preserve">
          <source>If you specify LIB or any INSTALL* variables they will not be affected by the PREFIX.</source>
          <target state="translated">LIBやINSTALL*変数を指定した場合、それらはPREFIXの影響を受けません。</target>
        </trans-unit>
        <trans-unit id="9241abdeaef157dc233bd737d1c5964fbf4c453e" translate="yes" xml:space="preserve">
          <source>If you specify both arguments, data will be discarded from the cache when either expiration condition holds.</source>
          <target state="translated">両方の引数を指定した場合、どちらかの期限切れ条件が満たされたときにデータはキャッシュから破棄されます。</target>
        </trans-unit>
        <trans-unit id="4155cee8fa3d0e362aaa00b0200498bfa23f6764" translate="yes" xml:space="preserve">
          <source>If you specify the &lt;code&gt;'class' =&amp;gt; $class&lt;/code&gt; argument, the new hub will be an instance of the specified class.</source>
          <target state="translated">あなたが指定した場合は &lt;code&gt;'class' =&amp;gt; $class&lt;/code&gt; 引数を、新しいハブは、指定されたクラスのインスタンスになります。</target>
        </trans-unit>
        <trans-unit id="63159230c4deaa2cf08d944e8f0464cc9f6ef86a" translate="yes" xml:space="preserve">
          <source>If you spell colour differently, that's no problem. The &lt;code&gt;TESTTESTERCOLOR&lt;/code&gt; variable also works (if both are set then the British spelling wins out).</source>
          <target state="translated">色のつづりが違っていても問題ありません。 &lt;code&gt;TESTTESTERCOLOR&lt;/code&gt; の変数は、（両方が設定されている場合、英国のスペルが出て勝利）動作します。</target>
        </trans-unit>
        <trans-unit id="ec224c3d56f48a286860fa26eb84c5ac4d399f4c" translate="yes" xml:space="preserve">
          <source>If you start with bullets or numbers, stick with them, as formatters use the first &quot;=item&quot; type to decide how to format the list.</source>
          <target state="translated">箇条書きや数字で始める場合は、それらに固執してください。フォーマッタは最初の&quot;=item &quot;タイプを使ってリストのフォーマット方法を決定するからです。</target>
        </trans-unit>
        <trans-unit id="583108dc3c7ca5413e3c465d6f2c5b41f57d07b1" translate="yes" xml:space="preserve">
          <source>If you still need a different solution, try to develop another subroutine that fits your needs and submit the diffs to &lt;code&gt;makemaker@perl.org&lt;/code&gt;</source>
          <target state="translated">それでも別のソリューションが必要な場合は、ニーズに合った別のサブルーチンを開発して、差分を &lt;code&gt;makemaker@perl.org&lt;/code&gt; に送信してください。</target>
        </trans-unit>
        <trans-unit id="a47b80b17f146bdd2f697c181154024073445f0f" translate="yes" xml:space="preserve">
          <source>If you still need commercial support &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.activestate.com%2factiveperl&quot;&gt;ActiveState&lt;/a&gt; offers this.</source>
          <target state="translated">まだ商用サポートが必要な場合は、&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.activestate.com%2factiveperl&quot;&gt;ActiveState&lt;/a&gt;がこれを提供します。</target>
        </trans-unit>
        <trans-unit id="e6da1990bc50d152e699b894b1f49c6c5a3821a0" translate="yes" xml:space="preserve">
          <source>If you still need commercial support &lt;a href=&quot;http://www.activestate.com/activeperl&quot;&gt;ActiveState&lt;/a&gt; offers this.</source>
          <target state="translated">それでも商用サポートが必要な場合は、&lt;a href=&quot;http://www.activestate.com/activeperl&quot;&gt;ActiveState&lt;/a&gt;がこれを提供します。</target>
        </trans-unit>
        <trans-unit id="c36c7ee3bb3bd53d4ea9fd7168cf498f48087d02" translate="yes" xml:space="preserve">
          <source>If you still think you need this outside of debugging, testing or dealing with filenames, you should probably read &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; and &lt;a href=&quot;perlunifaq#What-is-%22the-UTF8-flag%22%3F&quot;&gt;&quot;What is &quot;the UTF8 flag&quot;?&quot; in perlunifaq&lt;/a&gt;.</source>
          <target state="translated">ファイル名のデバッグ、テスト、または処理以外でこれが必要だと思われる場合は、&lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt;と&lt;a href=&quot;perlunifaq#What-is-%22the-UTF8-flag%22%3F&quot;&gt;「「UTF8フラグ」とは何ですか？」を&lt;/a&gt;読む必要があります。perlunifaqで。</target>
        </trans-unit>
        <trans-unit id="5b1b0c04cf56825c214a1e0c17a804ce5039d636" translate="yes" xml:space="preserve">
          <source>If you supply a code reference the subroutine will be called once for each line of output with the line as its only argument. Passed lines will have no trailing newline.</source>
          <target state="translated">コード参照を与えた場合、サブルーチンはその行を唯一の引数として、出力の各行に対して一度だけ呼び出されます。渡された行には最後の改行はありません。</target>
        </trans-unit>
        <trans-unit id="9c870447a33109e08d6ac4807e8b39152cd8060a" translate="yes" xml:space="preserve">
          <source>If you supply a function name with &lt;code&gt;INSTALL&lt;/code&gt; , memoize will install the new, memoized version of the function under the name you give. For example,</source>
          <target state="translated">&lt;code&gt;INSTALL&lt;/code&gt; で関数名を指定すると、memoizeは指定された名前で新しいメモ化されたバージョンの関数をインストールします。例えば、</target>
        </trans-unit>
        <trans-unit id="d57aa0246bfd4cdc05d4e778a00fbcc8da325130" translate="yes" xml:space="preserve">
          <source>If you supply a function name with &lt;code&gt;INSTALL&lt;/code&gt;, memoize will install the new, memoized version of the function under the name you give. For example,</source>
          <target state="translated">&lt;code&gt;INSTALL&lt;/code&gt; で関数名を指定すると、memoizeは、指定した名前で関数の新しいメモ化バージョンをインストールします。例えば、</target>
        </trans-unit>
        <trans-unit id="f6165205f1f599d384067c9f25ff1f7dd1d17430" translate="yes" xml:space="preserve">
          <source>If you supply data which is not valid (month 27, second 1,000) the results will be unpredictable (so don't do that).</source>
          <target state="translated">有効ではないデータ(月27、2回目の1000)を提供すると、結果が予測できなくなります(だからやめておきましょう)。</target>
        </trans-unit>
        <trans-unit id="f2f171e34560b51f24a2295b658a384f71202d5b" translate="yes" xml:space="preserve">
          <source>If you think geographically the</source>
          <target state="translated">地理的に考えると</target>
        </trans-unit>
        <trans-unit id="50a6625675c788b39661b9a604d74414a739f593" translate="yes" xml:space="preserve">
          <source>If you think that you want to add a new command to Pod (like, say, a &quot;=biblio&quot; command), consider whether you could get the same effect with a for or begin/end sequence: &quot;=for biblio ...&quot; or &quot;=begin biblio&quot; ... &quot;=end biblio&quot;. Pod processors that don't understand &quot;=for biblio&quot;, etc, will simply ignore it, whereas they may complain loudly if they see &quot;=biblio&quot;.</source>
          <target state="translated">Podに新しいコマンド(例えば&quot;=biblio &quot;コマンドなど)を追加したいと考えている場合、forやbegin/endシーケンスで同じ効果が得られるかどうかを考えてみましょう。&quot;=for biblio ...&quot;または&quot;=begin biblio&quot; ...&quot;=end biblio &quot;のようになります。&quot;=for biblio &quot;などを理解していないPodプロセッサは、単に無視してしまうのに対し、&quot;=biblio &quot;を見たら大声で文句を言うかもしれません。</target>
        </trans-unit>
        <trans-unit id="0dc7def89e2edc18a212cddb050ecfe26b36c107" translate="yes" xml:space="preserve">
          <source>If you trust the archive, or have other reasons to allow the archive to write files outside your current working directory, set this variable to &lt;code&gt;true&lt;/code&gt; .</source>
          <target state="translated">アーカイブを信頼する場合、またはアーカイブが現在の作業ディレクトリ外にファイルを書き込むことを許可するその他の理由がある場合は、この変数を &lt;code&gt;true&lt;/code&gt; に設定します。</target>
        </trans-unit>
        <trans-unit id="4bec0c73790b3c3d05f6a3152a00361a5cd4bae9" translate="yes" xml:space="preserve">
          <source>If you trust the archive, or have other reasons to allow the archive to write files outside your current working directory, set this variable to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">アーカイブを信頼する場合、またはアーカイブが現在の作業ディレクトリの外部にファイルを書き込むことを許可するその他の理由がある場合は、この変数を &lt;code&gt;true&lt;/code&gt; に設定します。</target>
        </trans-unit>
        <trans-unit id="c6aec72dc70a1ee4a43ad060e5bdfa6e98825b4f" translate="yes" xml:space="preserve">
          <source>If you try &lt;code&gt;Moose&lt;/code&gt; and find that one of these issues is preventing you from using &lt;code&gt;Moose&lt;/code&gt; , we encourage you to consider &lt;a href=&quot;http://search.cpan.org/perldoc/Moo&quot;&gt;Moo&lt;/a&gt; next. &lt;code&gt;Moo&lt;/code&gt; implements a subset of &lt;code&gt;Moose&lt;/code&gt; 's functionality in a simpler package. For most features that it does implement, the end-user API is</source>
          <target state="translated">&lt;code&gt;Moose&lt;/code&gt; を試してみて、これらの問題の1つが &lt;code&gt;Moose&lt;/code&gt; の使用を妨げていることに気付いた場合は、次に&lt;a href=&quot;http://search.cpan.org/perldoc/Moo&quot;&gt;Moo&lt;/a&gt;を検討することをお勧めします。 &lt;code&gt;Moo&lt;/code&gt; は &lt;code&gt;Moose&lt;/code&gt; の機能のサブセットをよりシンプルなパッケージで実装しています。それが実装するほとんどの機能では、エンドユーザーAPIは</target>
        </trans-unit>
        <trans-unit id="8196054f51c09e40b22436127d72432408c8b94d" translate="yes" xml:space="preserve">
          <source>If you try &lt;code&gt;Moose&lt;/code&gt; and find that one of these issues is preventing you from using &lt;code&gt;Moose&lt;/code&gt;, we encourage you to consider &lt;a href=&quot;moo&quot;&gt;Moo&lt;/a&gt; next. &lt;code&gt;Moo&lt;/code&gt; implements a subset of &lt;code&gt;Moose&lt;/code&gt;'s functionality in a simpler package. For most features that it does implement, the end-user API is</source>
          <target state="translated">&lt;code&gt;Moose&lt;/code&gt; を試してみて、これらの問題の1つが &lt;code&gt;Moose&lt;/code&gt; の使用を妨げていることがわかった場合は、次に&lt;a href=&quot;moo&quot;&gt;Moo&lt;/a&gt;を検討することをお勧めします。 &lt;code&gt;Moo&lt;/code&gt; は、 &lt;code&gt;Moose&lt;/code&gt; の機能のサブセットをよりシンプルなパッケージに実装しています。実装するほとんどの機能について、エンドユーザーAPIは</target>
        </trans-unit>
        <trans-unit id="ce64d2eb6b26fca2ba64557ff812899e21e2cf8b" translate="yes" xml:space="preserve">
          <source>If you try to add a file to @INC as follows:</source>
          <target state="translated">以下のように@incにファイルを追加しようとすると</target>
        </trans-unit>
        <trans-unit id="e1047e2245ed732ddd158d44ef63171c1040f4d7" translate="yes" xml:space="preserve">
          <source>If you try to dereference the key, it won't do a hard dereference, and you won't accomplish what you're attempting. You might want to do something more like</source>
          <target state="translated">キーをディファレンス解除しようとしても、ハードディファレンスは行われず、あなたの試みは達成されません。もっと次のようなことをしたほうがいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="b64e549b9d0f70c710cd7ee8a843df08eb7e123c" translate="yes" xml:space="preserve">
          <source>If you try to do something insecure, you will get a fatal error saying something like &quot;Insecure dependency&quot; or &quot;Insecure $ENV{PATH}&quot;.</source>
          <target state="translated">安全ではないことをしようとすると、「安全ではない依存関係」とか「安全ではない $ENV{PATH}」といった致命的なエラーが出ます。</target>
        </trans-unit>
        <trans-unit id="baaf467929bddd8fa5b7aa6c26404c219da0153b" translate="yes" xml:space="preserve">
          <source>If you try to do the same thing with what you think is a list, you get a quite different result. Although it looks like you have a list on the righthand side, Perl actually sees a bunch of scalars separated by a comma:</source>
          <target state="translated">リストと思われるもので同じことをしようとすると、全く異なる結果が得られます。右側にリストがあるように見えますが、Perl は実際にはカンマで区切られたスカラの束を見ています。</target>
        </trans-unit>
        <trans-unit id="e39b81693bb33881d5354ed40ab1aa5e5e421f38" translate="yes" xml:space="preserve">
          <source>If you try to import an unimplemented function in the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement it will fail at compile time.</source>
          <target state="translated">未実装の関数を &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ステートメントでインポートしようとすると、コンパイル時に失敗します。</target>
        </trans-unit>
        <trans-unit id="4b4406a29e69d0fe589df66b2d19e5926b365127" translate="yes" xml:space="preserve">
          <source>If you try to import an unimplemented function in the &lt;code&gt;use&lt;/code&gt; statement it will fail at compile time.</source>
          <target state="translated">実装されていない関数を &lt;code&gt;use&lt;/code&gt; ステートメントにインポートしようとすると、コンパイル時に失敗します。</target>
        </trans-unit>
        <trans-unit id="d15d030c497334de4682713f89a5eeaabfcfb4a3" translate="yes" xml:space="preserve">
          <source>If you try to read from the child's stdout writer and their stderr writer, you'll have problems with blocking, which means you'll want to use select() or &lt;a href=&quot;IO::Select&quot;&gt;IO::Select&lt;/a&gt;, which means you'd best use sysread() instead of readline() for normal stuff.</source>
          <target state="translated">子のstdoutライターとそのstderrライターから読み取ろうとすると、ブロックに問題が発生します。つまり、select（）または&lt;a href=&quot;IO::Select&quot;&gt;IO :: Select&lt;/a&gt;を使用する必要があります。つまり、sysread（）を使用するのが最適です。通常のもののreadline（）の代わりに。</target>
        </trans-unit>
        <trans-unit id="ce84b9139b9e943d624385f2da9d34f42bd6117a" translate="yes" xml:space="preserve">
          <source>If you try to read from the child's stdout writer and their stderr writer, you'll have problems with blocking, which means you'll want to use select() or the IO::Select, which means you'd best use sysread() instead of readline() for normal stuff.</source>
          <target state="translated">子の標準出力ライタとその子の標準エラーライタから読み込もうとすると、ブロッキングの問題が発生するので、select()やIO::Selectを使いたくなります。</target>
        </trans-unit>
        <trans-unit id="8629095d12898edeef813ea5adb0d8466406ccc7" translate="yes" xml:space="preserve">
          <source>If you try to use a reference like a string, you get strings like</source>
          <target state="translated">参照を文字列のように使おうとすると、次のような文字列が出てきます。</target>
        </trans-unit>
        <trans-unit id="39dd9c9407d1478c40154f713c3d3db1f745db97" translate="yes" xml:space="preserve">
          <source>If you try to use an alphanumeric sequence in a prototype you will generate an optional warning - &quot;Illegal character in prototype...&quot;. Unfortunately earlier versions of Perl allowed the prototype to be used as long as its prefix was a valid prototype. The warning may be upgraded to a fatal error in a future version of Perl once the majority of offending code is fixed.</source>
          <target state="translated">もしプロトタイプの中で英数字のシーケンスを使おうとすると、オプションで &quot;Illegal character in prototype...&quot;という警告が表示されます。残念ながら、以前のバージョンのPerlでは、接頭辞が有効なプロトタイプであれば、プロトタイプを使用することができました。この警告は、問題のあるコードの大部分が修正された後、将来のPerlのバージョンでは致命的なエラーにアップグレードされるかもしれません。</target>
        </trans-unit>
        <trans-unit id="fe9a752d3dfb5ae4ddbce9b50462b1f6d85d68b3" translate="yes" xml:space="preserve">
          <source>If you try to use code expressions where the code text is contained within an interpolated variable, rather than appearing literally in the pattern, Perl may surprise you:</source>
          <target state="translated">文字通りパターンの中に現れるのではなく、補間された変数の中にコードテキストが含まれているコード式を使おうとすると、Perlはあなたを驚かせるかもしれません。</target>
        </trans-unit>
        <trans-unit id="11e25dd065a3c2e65ba069546d65a87869f3ab69" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; in your handler for &lt;a href=&quot;perlvar#%25SIG&quot;&gt;&lt;code&gt;$SIG{CHLD}&lt;/code&gt;&lt;/a&gt;, it may accidentally wait for the child created by &lt;a href=&quot;#qx%2FSTRING%2F&quot;&gt;&lt;code&gt;qx&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">あなたが使用している場合は&lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;するためにあなたのハンドラで&lt;a href=&quot;perlvar#%25SIG&quot;&gt; &lt;code&gt;$SIG{CHLD}&lt;/code&gt; &lt;/a&gt;、それは偶然によって作成された子を待つことができる&lt;a href=&quot;#qx%2FSTRING%2F&quot;&gt; &lt;code&gt;qx&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#system-LIST&quot;&gt; &lt;code&gt;system&lt;/code&gt; &lt;/a&gt;。詳細については、&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b74ccad2ea9ca8d857dc7afb6d54fa03395dd0f9" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; in your handler for $SIG{CHLD}, it may accidentally wait for the child created by qx() or system(). See &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">$ SIG {CHLD}のハンドラーで &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; を使用すると、qx（）またはsystem（）によって作成された子を誤って待機する可能性があります。詳細については、&lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="5f489bb10b3438e3010da06cd3b95ce427029dc2" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; in your handler for $SIG{CHLD}, it may accidentally wait for the child created by qx() or system(). See &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; for details.</source>
          <target state="translated">$ SIG {CHLD}のハンドラーで &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; を使用すると、qx（）またはsystem（）によって作成された子を誤って待機する可能性があります。詳細については、&lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="46bb44efb62948225ccf4e92dee64ae61f103a13" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;FilterName&lt;/code&gt; to modify the filename, it is your responsibility to keep the filename in Unix format.</source>
          <target state="translated">&lt;code&gt;FilterName&lt;/code&gt; を使用してファイル名を変更する場合は、ファイル名をUnix形式で保持する必要があります。</target>
        </trans-unit>
        <trans-unit id="16f11d3777f6f8b6ecfda56c2150f1df3c1a440a" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;harness&lt;/code&gt; for testing, you have several command line options available to you. The arguments are as follows, and are in the order that they must appear if used together.</source>
          <target state="translated">テストに &lt;code&gt;harness&lt;/code&gt; を使用する場合、いくつかのコマンドラインオプションを使用できます。引数は次のとおりであり、一緒に使用した場合に現れる必要がある順序です。</target>
        </trans-unit>
        <trans-unit id="5dace6a8fabe0f3fff4268587985038c8aa60a8e" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;man&lt;/code&gt; , either move the installed</source>
          <target state="translated">&lt;code&gt;man&lt;/code&gt; を使用する場合は、インストールされているものを移動するか、</target>
        </trans-unit>
        <trans-unit id="2526f763683e8e3d761dca9fc7d00f94a999cd3a" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;man&lt;/code&gt;, either move the installed</source>
          <target state="translated">&lt;code&gt;man&lt;/code&gt; を使用する場合は、インストールされているものを移動します</target>
        </trans-unit>
        <trans-unit id="f77d31c25362c9be9687e6ee59543d3904970c3a" translate="yes" xml:space="preserve">
          <source>If you use Sun's C compiler, make sure the correct directory (usually /opt/SUNWspro/bin/) is in your PATH (before /usr/ucb/).</source>
          <target state="translated">Sun の C コンパイラを使用している場合は、正しいディレクトリ (通常は /opt/SUNWspro/bin/)が PATH (/usr/ucb/の前)にあることを確認してください。</target>
        </trans-unit>
        <trans-unit id="694a362a82c6e3cfa50f1318ad85b6fb37d17685" translate="yes" xml:space="preserve">
          <source>If you use a Unicode editor to edit your program, Unicode characters may occur directly within the literal strings in UTF-8 encoding, or UTF-16. (The former requires a &lt;code&gt;BOM&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; , the latter requires a &lt;code&gt;BOM&lt;/code&gt; .)</source>
          <target state="translated">Unicodeエディタを使用してプログラムを編集する場合、Unicode文字は、UTF-8エンコーディングまたはUTF-16のリテラル文字列内で直接発生する可能性があります。（前者には &lt;code&gt;BOM&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用する&lt;/a&gt;必要があり、後者には &lt;code&gt;BOM&lt;/code&gt; が必要です。）</target>
        </trans-unit>
        <trans-unit id="12733393a4777e2904da336b9a9ac1c8e8988972" translate="yes" xml:space="preserve">
          <source>If you use a Unicode editor to edit your program, Unicode characters may occur directly within the literal strings in UTF-8 encoding, or UTF-16. (The former requires a &lt;code&gt;use utf8&lt;/code&gt;, the latter may require a &lt;code&gt;BOM&lt;/code&gt;.)</source>
          <target state="translated">Unicodeエディタを使用してプログラムを編集する場合、Unicode文字はUTF-8エンコーディングまたはUTF-16のリテラル文字列内に直接出現する可能性があります。（前者は &lt;code&gt;use utf8&lt;/code&gt; する必要があり、後者は &lt;code&gt;BOM&lt;/code&gt; を必要とする場合があります。）</target>
        </trans-unit>
        <trans-unit id="87cf615c227432610de49accfafc5d497f5d3f61" translate="yes" xml:space="preserve">
          <source>If you use a deprecated feature or module and believe that its removal from the Perl core would be a mistake, please contact the perl5-porters mailinglist and plead your case. We don't deprecate things without a good reason, but sometimes there's a counterargument we haven't considered. Historically, we did not distinguish between &quot;deprecated&quot; and &quot;discouraged&quot; features.</source>
          <target state="translated">非推奨の機能やモジュールを使っていて、Perlコアから削除するのは間違いだと思うならば、 perl5-porters メーリングリストに連絡して、あなたの主張を訴えてください。正当な理由なしに非推奨にすることはありませんが、時には、私たちが考えもしなかった反論があることもあります。歴史的に、私たちは「非推奨」と「推奨されない」機能を区別していませんでした。</target>
        </trans-unit>
        <trans-unit id="5dd282c0cc211cebd60be34d73466e199fdff472" translate="yes" xml:space="preserve">
          <source>If you use a here-doc within a delimited construct, such as in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///eg&lt;/a&gt;&lt;/code&gt;, the quoted material must still come on the line following the &lt;code&gt;&amp;lt;&amp;lt;FOO&lt;/code&gt; marker, which means it may be inside the delimited construct:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///eg&lt;/a&gt;&lt;/code&gt; ように、区切られた構成内でhere-docを使用する場合、引用された資料は &lt;code&gt;&amp;lt;&amp;lt;FOO&lt;/code&gt; マーカーの次の行にある必要があります。つまり、区切り構成内にある可能性があります。</target>
        </trans-unit>
        <trans-unit id="ef85aed564f520195de79872cb8f400e6839cfe4" translate="yes" xml:space="preserve">
          <source>If you use a here-doc within a delimited construct, such as in &lt;code&gt;s///eg&lt;/code&gt;, the quoted material must still come on the line following the &lt;code&gt;&amp;lt;&amp;lt;FOO&lt;/code&gt; marker, which means it may be inside the delimited construct:</source>
          <target state="translated">&lt;code&gt;s///eg&lt;/code&gt; ように、区切られた構成内でヒアドキュメントを使用する場合、引用された資料は、 &lt;code&gt;&amp;lt;&amp;lt;FOO&lt;/code&gt; マーカーに続く行にある必要があります。つまり、区切られた構成内にある可能性があります。</target>
        </trans-unit>
        <trans-unit id="f880ff17098bf984e1784381aefee800c2614214" translate="yes" xml:space="preserve">
          <source>If you use a mathematic formula that resolves to a floating point number, you are dependent on Perl's conversion routines to yield the version you expect. You are pretty safe by dividing by a power of 10, for example, but other operations are not likely to be what you intend. For example:</source>
          <target state="translated">浮動小数点数に変換される数学式を使用する場合、Perl の変換ルーチンに依存することになります。例えば、10の累乗で割ることは安全ですが、その他の演算は意図したものではない可能性があります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="328cd5a18e409f3686cf9b70d3830474d172c463" translate="yes" xml:space="preserve">
          <source>If you use deferred writing (See &lt;a href=&quot;#Deferred-Writing&quot;&gt;&quot;Deferred Writing&quot;&lt;/a&gt;, below) then data you write into the array will not be written directly to the file; instead, it will be saved in the</source>
          <target state="translated">遅延書き込みを使用する場合（以下の&lt;a href=&quot;#Deferred-Writing&quot;&gt;「遅延書き込み」&lt;/a&gt;を参照）、配列に書き込むデータはファイルに直接書き込まれません。代わりに、に保存されます</target>
        </trans-unit>
        <trans-unit id="6ae0c0867250fd5a479e543aea928a9a77d11b83" translate="yes" xml:space="preserve">
          <source>If you use deferred writing (See &lt;a href=&quot;#Deferred-Writing&quot;&gt;Deferred Writing&lt;/a&gt;, below) then data you write into the array will not be written directly to the file; instead, it will be saved in the</source>
          <target state="translated">遅延書き込みを使用する場合（下記の&lt;a href=&quot;#Deferred-Writing&quot;&gt;遅延書き込み&lt;/a&gt;を参照）、配列に書き込むデータはファイルに直接書き込まれません。代わりに、それはに保存されます</target>
        </trans-unit>
        <trans-unit id="4f2793be84e03f881815cfd6cbd437f560ace728" translate="yes" xml:space="preserve">
          <source>If you use either the R_IAFTER or R_IBEFORE flags, the &lt;code&gt;$key&lt;/code&gt; parameter will have the record number of the inserted key/value pair set.</source>
          <target state="translated">R_IAFTERまたはR_IBEFOREフラグのいずれかを使用する場合、 &lt;code&gt;$key&lt;/code&gt; パラメーターには、挿入されたキー/値のペアセットのレコード番号が含まれます。</target>
        </trans-unit>
        <trans-unit id="7804e89f419dfb4afe57d175e577f649678035a8" translate="yes" xml:space="preserve">
          <source>If you use gcc, make sure your installation is recent and complete. perl versions since 5.6.0 build fine with gcc &amp;gt; 2.8.1 on Solaris &amp;gt;= 2.6.</source>
          <target state="translated">gccを使用する場合は、インストールが最新かつ完全であることを確認してください。5.6.0以降のperlバージョンは、Solaris上でgcc&amp;gt; 2.8.1&amp;gt; = 2.6で正常にビルドされます。</target>
        </trans-unit>
        <trans-unit id="c133e612772c5c91ca38653bb618cdde5ecf7eea" translate="yes" xml:space="preserve">
          <source>If you use one of the undocumented functions below, you may wish to consider creating and submitting documentation for it. If your patch is accepted, this will indicate that the interface is stable (unless it is explicitly marked otherwise).</source>
          <target state="translated">以下の文書化されていない関数を使っている場合は、ドキュメントを作成して提出することを検討してみてはいかがでしょうか。あなたのパッチが受け入れられた場合、これはインターフェイスが安定していることを示します (特に明記されていない限り)。</target>
        </trans-unit>
        <trans-unit id="97a1d75ada82bbf9f654420e7c70ad3899b98121" translate="yes" xml:space="preserve">
          <source>If you use preprocessor directives to choose one of two versions of a function, use</source>
          <target state="translated">プリプロセッサディレクティブを使って関数の2つのバージョンのどちらかを選択する場合は</target>
        </trans-unit>
        <trans-unit id="32e7fdaa4b2e816b8b9a792f2d7c56bbe0d52ad7" translate="yes" xml:space="preserve">
          <source>If you use the 4DOS/NT or similar command shell, note that &quot;pl2bat&quot; uses the &quot;%*&quot; variable in the generated batch file to refer to all the command line arguments, so you may need to make sure that construct works in batch files. As of this writing, 4DOS/NT users will need a &quot;ParameterChar = *&quot; statement in their 4NT.INI file or will need to execute &quot;setdos /p*&quot; in the 4DOS/NT startup file to enable this to work.</source>
          <target state="translated">4DOS/NTまたは同様のコマンドシェルを使用する場合、&quot;pl2bat &quot;は生成されたバッチファイルの&quot;%*&quot;変数を使用してすべてのコマンドライン引数を参照するので、バッチファイルでその構文が動作することを確認する必要があるかもしれないことに注意してください。この記事を書いている時点では、4DOS/NTユーザーは4NT.INIファイルに &quot;ParameterChar=*&quot;文を記述するか、4DOS/NTのスタートアップファイルで &quot;setdos /p*&quot;を実行して、これを有効にする必要があります。</target>
        </trans-unit>
        <trans-unit id="91300f437c633a42a75ef31ebaae0d2065c281bd" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; PerlIO layer for input, invalid byte sequences are handled gracefully, but if you use &lt;code&gt;:utf8&lt;/code&gt; , the flag is set without validating the data, possibly resulting in this error message.</source>
          <target state="translated">入力に &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; PerlIOレイヤーを使用する場合、無効なバイトシーケンスは正常に処理されますが、 &lt;code&gt;:utf8&lt;/code&gt; を使用する場合、データを検証せずにフラグが設定されるため、このエラーメッセージが表示される可能性があります。</target>
        </trans-unit>
        <trans-unit id="c99f058cbb6ca20108d91c09dfe4c9c7ca4b2109" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; PerlIO layer for input, invalid byte sequences are handled gracefully, but if you use &lt;code&gt;:utf8&lt;/code&gt;, the flag is set without validating the data, possibly resulting in this error message.</source>
          <target state="translated">使用する場合 &lt;code&gt;:encoding(UTF-8)&lt;/code&gt; 入力のためにはPerlIO層を、無効なバイトシーケンスが正常に処理されていますが、使用する場合 &lt;code&gt;:utf8&lt;/code&gt; 、フラグは、おそらくこのエラーメッセージで、その結果、データを検証することなく、設定されています。</target>
        </trans-unit>
        <trans-unit id="3eecf6412d7114c8844a3dfb8554c44c0eb8598c" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;SA_SIGINFO&lt;/code&gt; flag, the signal handler will in addition to the first argument, the signal name, also receive a second argument, a hash reference, inside which are the following keys with the following semantics, as defined by POSIX/SUSv3:</source>
          <target state="translated">&lt;code&gt;SA_SIGINFO&lt;/code&gt; フラグを使用すると、シグナルハンドラーは最初の引数であるシグナル名に加えて、POSIX / SUSv3で定義されている次のセマンティクスを持つ次のキーである2番目の引数、ハッシュ参照も受け取ります。</target>
        </trans-unit>
        <trans-unit id="dc06c253841f15b9de0c355618356ed5550da10d" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;\G&lt;/code&gt; anchor, you force the match after &lt;code&gt;22&lt;/code&gt; to start with the &lt;code&gt;a&lt;/code&gt; . The regular expression cannot match there since it does not find a digit, so the next match fails and the match operator returns the pairs it already found.</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; アンカーを使用する場合、 &lt;code&gt;22&lt;/code&gt; の後に &lt;code&gt;a&lt;/code&gt; で始まるように強制的に一致させます。正規表現は数字を見つけられないため、そこでは一致できません。そのため、次の一致は失敗し、一致演算子はすでに見つかったペアを返します。</target>
        </trans-unit>
        <trans-unit id="b510ad2eb535862884ae7cf62a7e26f96276ab1c" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;\G&lt;/code&gt; anchor, you force the match after &lt;code&gt;22&lt;/code&gt; to start with the &lt;code&gt;a&lt;/code&gt;. The regular expression cannot match there since it does not find a digit, so the next match fails and the match operator returns the pairs it already found.</source>
          <target state="translated">&lt;code&gt;\G&lt;/code&gt; アンカーを使用する場合は、 &lt;code&gt;22&lt;/code&gt; 以降の一致を強制的に &lt;code&gt;a&lt;/code&gt; で開始します。正規表現は数字が見つからないため、そこで一致できません。そのため、次の一致は失敗し、一致演算子は既に見つかったペアを返します。</target>
        </trans-unit>
        <trans-unit id="fbb20a66ed661494874fa5e98a73f246a9cc34cc" translate="yes" xml:space="preserve">
          <source>If you use the English module, you can even read the variable names:</source>
          <target state="translated">英語モジュールを使えば、変数名まで読めるようになります。</target>
        </trans-unit>
        <trans-unit id="5c03e0261fc0b7da7836c0a3093ff6c1dacfba33" translate="yes" xml:space="preserve">
          <source>If you use the VC IDE, you will have to run</source>
          <target state="translated">VC IDEを使用している場合は</target>
        </trans-unit>
        <trans-unit id="abbbac8010fcf4e1f8177dc8b18103356d7c1579" translate="yes" xml:space="preserve">
          <source>If you use the form &lt;code&gt;\N{&lt;i&gt;character name&lt;/i&gt;}&lt;/code&gt;, the &lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt; module gets automatically loaded. This may not be suitable for the test level you are doing.</source>
          <target state="translated">&lt;code&gt;\N{&lt;i&gt;character name&lt;/i&gt;}&lt;/code&gt; の形式を使用すると、&lt;a href=&quot;charnames&quot;&gt;charnames&lt;/a&gt;モジュールが自動的にロードされます。これは、実行しているテストレベルには適していない場合があります。</target>
        </trans-unit>
        <trans-unit id="b6639f5cfc711b71b35423e81c784a209aabfc93" translate="yes" xml:space="preserve">
          <source>If you use the hash syntax, you have no control over the order in which the ExtraSubFields are stored, plus you cannot have SubFields with duplicate ID.</source>
          <target state="translated">ハッシュ構文を使用した場合、ExtraSubFieldsの格納順序を制御することはできませんし、重複するIDを持つSubFieldsを持つこともできません。</target>
        </trans-unit>
        <trans-unit id="cf9048b3298377c86c20ad5d8b5d02655bc3f8b6" translate="yes" xml:space="preserve">
          <source>If you use the raw format, and the &lt;code&gt;Strict&lt;/code&gt; option is enabled, &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; will check that &lt;code&gt;$rawdata&lt;/code&gt; consists of zero or more conformant sub-fields. When &lt;code&gt;Strict&lt;/code&gt; is disabled, &lt;code&gt;$rawdata&lt;/code&gt; can consist of any arbitrary byte stream.</source>
          <target state="translated">raw形式を使用し、 &lt;code&gt;Strict&lt;/code&gt; オプションが有効になっている場合、 &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; は &lt;code&gt;$rawdata&lt;/code&gt; が0個以上の適合サブフィールドで構成されていることを確認します。 &lt;code&gt;Strict&lt;/code&gt; が無効になっている場合、 &lt;code&gt;$rawdata&lt;/code&gt; は任意のバイトストリームで構成できます。</target>
        </trans-unit>
        <trans-unit id="c067123fb137430de0f256b297d516b2001d264a" translate="yes" xml:space="preserve">
          <source>If you use utf8 or other non-ASCII characters with Test::More you might get a &quot;Wide character in print&quot; warning. Using &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt; STDOUT, &quot;:utf8&quot;&lt;/code&gt; will not fix it. &lt;a href=&quot;builder&quot;&gt;Test::Builder&lt;/a&gt; (which powers Test::More) duplicates STDOUT and STDERR. So any changes to them, including changing their output disciplines, will not be seem by Test::More.</source>
          <target state="translated">Test :: Moreでutf8または他の非ASCII文字を使用すると、「ワイド文字が印刷されます」という警告が表示される場合があります。 &lt;code&gt;&lt;a href=&quot;../functions/binmode&quot;&gt;binmode&lt;/a&gt; STDOUT, &quot;:utf8&quot;&lt;/code&gt; を使用すると、 &quot;：utf8&quot;はそれを修正しません。&lt;a href=&quot;builder&quot;&gt;Test :: Builder&lt;/a&gt;（Test :: Moreの機能）は、STDOUTとSTDERRを複製します。したがって、出力の専門分野の変更を含む、それらへの変更はTest :: Moreからは見えません。</target>
        </trans-unit>
        <trans-unit id="d00aea3e7b59229d34e146319ce9c85454b14e11" translate="yes" xml:space="preserve">
          <source>If you use utf8 or other non-ASCII characters with Test::More you might get a &quot;Wide character in print&quot; warning. Using &lt;code&gt;binmode STDOUT, &quot;:utf8&quot;&lt;/code&gt; will not fix it. &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; (which powers Test::More) duplicates STDOUT and STDERR. So any changes to them, including changing their output disciplines, will not be seen by Test::More.</source>
          <target state="translated">Test :: Moreでutf8またはその他の非ASCII文字を使用すると、「ワイド文字が印刷されます」という警告が表示される場合があります。 &lt;code&gt;binmode STDOUT, &quot;:utf8&quot;&lt;/code&gt; を使用すると、「：utf8」はそれを修正しません。&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt;（Test :: Moreを強化する）はSTDOUTとSTDERRを複製します。したがって、出力分野の変更を含む、それらへの変更は、Test :: Moreでは表示されません。</target>
        </trans-unit>
        <trans-unit id="630840ae944c06429550447e9540c0ca707dbc1a" translate="yes" xml:space="preserve">
          <source>If you used WinZip, this was already done for you.</source>
          <target state="translated">WinZipを使用している場合は、すでにこれが行われています。</target>
        </trans-unit>
        <trans-unit id="8c53b3ef6362ad03c7dbea52d0c4786e608f8e77" translate="yes" xml:space="preserve">
          <source>If you used git to check out the Perl source, then using &lt;code&gt;git
format-patch&lt;/code&gt; will produce a patch in a style suitable for Perl. The &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format-patch&lt;/a&gt;&lt;/code&gt; command produces one patch file for each commit you made. If you prefer to send a single patch for all commits, you can use &lt;code&gt;git diff&lt;/code&gt; .</source>
          <target state="translated">gitを使用してPerlソースをチェックアウトした場合、 &lt;code&gt;git format-patch&lt;/code&gt; を使用すると、Perlに適したスタイルのパッチが生成されます。 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format-patch&lt;/a&gt;&lt;/code&gt; コマンドは、それぞれあなたが作ったコミットのための1つのパッチファイルを生成します。すべてのコミットに対して単一のパッチを送信したい場合は、 &lt;code&gt;git diff&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="005c2baa346d58318121715604db7b7de9beda44" translate="yes" xml:space="preserve">
          <source>If you used git to check out the Perl source, then using &lt;code&gt;git format-patch&lt;/code&gt; will produce a patch in a style suitable for Perl. The &lt;code&gt;format-patch&lt;/code&gt; command produces one patch file for each commit you made. If you prefer to send a single patch for all commits, you can use &lt;code&gt;git diff&lt;/code&gt;.</source>
          <target state="translated">gitを使用してPerlソースをチェックアウトした場合、 &lt;code&gt;git format-patch&lt;/code&gt; を使用すると、Perlに適したスタイルのパッチが生成されます。 &lt;code&gt;format-patch&lt;/code&gt; コマンドは、それぞれあなたが作ったコミットのための1つのパッチファイルを生成します。すべてのコミットに対して単一のパッチを送信する場合は、 &lt;code&gt;git diff&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="2bc21e512fb418bd39c6e536f3bdd95478cb7d3c" translate="yes" xml:space="preserve">
          <source>If you want $x to have a certain sign, use one of the following methods:</source>
          <target state="translated">x に特定の符号を付けたい場合は、以下のいずれかの方法を使用します。</target>
        </trans-unit>
        <trans-unit id="1553678828e2328fa0aa14746ccfdd7229ce26f6" translate="yes" xml:space="preserve">
          <source>If you want *.ucm installed together with the modules, do as follows;</source>
          <target state="translated">モジュールと一緒に *.ucm をインストールしたい場合は、以下のようにしてください。</target>
        </trans-unit>
        <trans-unit id="3a9e72b266b57bba86c6eccbfed06538dcba5011" translate="yes" xml:space="preserve">
          <source>If you want a &quot;real&quot; C &lt;a href=&quot;http://man.he.net/man2/open&quot;&gt;open(2)&lt;/a&gt;, then you should use the &lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt;&lt;code&gt;sysopen&lt;/code&gt;&lt;/a&gt; function, which involves no such magic (but uses different filemodes than Perl &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt;, which corresponds to C &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen(3)&lt;/a&gt;). This is another way to protect your filenames from interpretation. For example:</source>
          <target state="translated">「実際の」&lt;a href=&quot;#sysopen-FILEHANDLE%2CFILENAME%2CMODE&quot;&gt; &lt;code&gt;sysopen&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;http://man.he.net/man2/open&quot;&gt;（2）&lt;/a&gt;が必要な場合は、そのような魔法を必要としないsysopen関数を使用する必要があります（ただし、C &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen（3）に&lt;/a&gt;対応するPerl &lt;a href=&quot;#open-FILEHANDLE%2CMODE%2CEXPR&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;とは異なるファイルモードを使用します）。これは、ファイル名を解釈から保護するもう1つの方法です。例えば：</target>
        </trans-unit>
        <trans-unit id="791324333537699862b9ce903fa1af5980ed496f" translate="yes" xml:space="preserve">
          <source>If you want a &quot;real&quot; C &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; (see</source>
          <target state="translated">「実際の」C &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; が必要な場合（参照</target>
        </trans-unit>
        <trans-unit id="c13df57b95397c5f1d723459f0b855e899e41a8a" translate="yes" xml:space="preserve">
          <source>If you want a &quot;real&quot; C &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; (see</source>
          <target state="translated">「実際の」C &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; が必要な場合（参照</target>
        </trans-unit>
        <trans-unit id="cb1d7bd468d379f255df6d0a8a45090fecae8882" translate="yes" xml:space="preserve">
          <source>If you want a Perl application to process and present your data according to a particular locale, the application code should include the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; pragma (see &lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;The use locale pragma&lt;/a&gt;) where appropriate, and &lt;b&gt;at least one&lt;/b&gt; of the following must be true:</source>
          <target state="translated">あなたは、プロセスへのPerlアプリケーションをしたいし、特定のロケールに応じてデータを提示した場合は、アプリケーション・コードが含まれている必要があり &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; プラグマ（参照&lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;用ロケールプラグマを&lt;/a&gt;）適切、かつ&lt;b&gt;少なくとも1で&lt;/b&gt;、次の条件を満たす必要があります。</target>
        </trans-unit>
        <trans-unit id="7f64cf3c950fcdad95bf25b3cb5fe1e64c6e318a" translate="yes" xml:space="preserve">
          <source>If you want a Perl application to process and present your data according to a particular locale, the application code should include the &lt;code&gt;use locale&lt;/code&gt; pragma (see &lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;&quot;The &quot;use locale&quot; pragma&quot;&lt;/a&gt;) where appropriate, and &lt;b&gt;at least one&lt;/b&gt; of the following must be true:</source>
          <target state="translated">あなたは、プロセスへのPerlアプリケーションをしたいし、特定のロケールに応じてデータを提示した場合は、アプリケーション・コードが含まれている必要があり &lt;code&gt;use locale&lt;/code&gt; （参照プラグマを&lt;a href=&quot;#The-%22use-locale%22-pragma&quot;&gt;「『使用のロケール』プラグマ」を&lt;/a&gt;、適切な場合）、および&lt;b&gt;少なくとも1で&lt;/b&gt;、次のでなければなりませんtrue：</target>
        </trans-unit>
        <trans-unit id="dc8f1faa6c36903ecd5d1abeecfdbd92380ab3a3" translate="yes" xml:space="preserve">
          <source>If you want a better approximation of the square root, then use:</source>
          <target state="translated">平方根をよりよく近似したい場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="409579e935815d3f9b1b191e4808eba939430e40" translate="yes" xml:space="preserve">
          <source>If you want a completely new Test::Builder object different from the singleton, use &lt;code&gt;create&lt;/code&gt; .</source>
          <target state="translated">シングルトンとは完全に異なるTest :: Builderオブジェクトが必要な場合は、 &lt;code&gt;create&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="9078ce92d169ba5491de791cf112f90cf0081697" translate="yes" xml:space="preserve">
          <source>If you want a completely new Test::Builder object different from the singleton, use &lt;code&gt;create&lt;/code&gt;.</source>
          <target state="translated">シングルトンとは異なる完全に新しいTest :: Builderオブジェクトが必要な場合は、 &lt;code&gt;create&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="04cafbc1f6bcd93d15d82018f51a268c90603bc8" translate="yes" xml:space="preserve">
          <source>If you want a list of all of the Perl module filenames, you can use &lt;a href=&quot;File::Find::Rule&quot;&gt;File::Find::Rule&lt;/a&gt;:</source>
          <target state="translated">すべてのPerlモジュールファイル名のリストが必要な場合は、&lt;a href=&quot;File::Find::Rule&quot;&gt;File :: Find :: Rule&lt;/a&gt;：を使用できます。</target>
        </trans-unit>
        <trans-unit id="364287807494857e0923c716161b8323aaaa85ad" translate="yes" xml:space="preserve">
          <source>If you want a list of all of the Perl module filenames, you can use &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;File::Find::Rule&lt;/a&gt;:</source>
          <target state="translated">すべてのPerlモジュールのファイル名のリストが必要な場合は、&lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;File :: Find :: Ruleを&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="20d03f9f8d59c035c39fd85e8955d33568507a9f" translate="yes" xml:space="preserve">
          <source>If you want a real Perl scalar, use &lt;code&gt;numify()&lt;/code&gt; :</source>
          <target state="translated">あなたが本当のPerlスカラーをしたい場合は、使用 &lt;code&gt;numify()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b8b877d7756b903200810e1071cc23b772cf0635" translate="yes" xml:space="preserve">
          <source>If you want a real Perl scalar, use &lt;code&gt;numify()&lt;/code&gt;:</source>
          <target state="translated">実際のPerlスカラーが必要な場合は、 &lt;code&gt;numify()&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="9309fd012fc6beaef72da428ac578230d08f400e" translate="yes" xml:space="preserve">
          <source>If you want a supported version of perl for OpenVOS, purchase the OpenVOS GNU Tools product from Stratus Technologies, along with a support contract (or from anyone else who will sell you support).</source>
          <target state="translated">OpenVOS 用の perl のサポートされたバージョンが欲しい場合は、Stratus Technologies から OpenVOS GNU Tools 製品をサポート契約と一緒に購入してください (または、サポートを販売する他の人からも購入できます)。</target>
        </trans-unit>
        <trans-unit id="6584c0a384e584f13abe302cec979af6b67c1d61" translate="yes" xml:space="preserve">
          <source>If you want a true copy of $x, use:</source>
          <target state="translated">x の真のコピーを取得したい場合は、$x を使用します。</target>
        </trans-unit>
        <trans-unit id="2bd3ed425ef919c14360d525b51cc98be9af477c" translate="yes" xml:space="preserve">
          <source>If you want access to threads, you must &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; before you &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; . &lt;a href=&quot;../threads&quot;&gt;threads&lt;/a&gt; will emit a warning if you use it after &lt;a href=&quot;shared&quot;&gt;threads::shared&lt;/a&gt;.</source>
          <target state="translated">スレッドにアクセスしたい場合は、 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads::shared&lt;/code&gt; を&lt;a href=&quot;../functions/use&quot;&gt;使用する&lt;/a&gt;前に &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; threads&lt;/code&gt; を使用する必要があり&lt;a href=&quot;../functions/use&quot;&gt;ます&lt;/a&gt;。&lt;a href=&quot;../threads&quot;&gt;threads &lt;/a&gt;&lt;a href=&quot;shared&quot;&gt;:: sharedの&lt;/a&gt;後に使用すると、スレッドは警告を発します。</target>
        </trans-unit>
        <trans-unit id="e8a2798b257a3670f42de6843d7775eac47d562b" translate="yes" xml:space="preserve">
          <source>If you want access to threads, you must &lt;code&gt;use threads&lt;/code&gt; before you &lt;code&gt;use threads::shared&lt;/code&gt;. &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; will emit a warning if you use it after &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt;.</source>
          <target state="translated">スレッドにアクセスする場合は、 &lt;code&gt;use threads::shared&lt;/code&gt; を使用する前に &lt;code&gt;use threads&lt;/code&gt; を使用する必要があります。&lt;a href=&quot;threads&quot;&gt;thread &lt;/a&gt;&lt;a href=&quot;threads::shared&quot;&gt;:: sharedの&lt;/a&gt;後に使用すると、スレッドは警告を発します。</target>
        </trans-unit>
        <trans-unit id="2ffb4d0fb6b209221b80f1da704496ad8ce1ebe0" translate="yes" xml:space="preserve">
          <source>If you want an IDE, check the following (in alphabetical order, not order of preference):</source>
          <target state="translated">IDEが欲しい場合は、以下をチェックしてみてください(アルファベット順、好みの順ではありません)。</target>
        </trans-unit>
        <trans-unit id="0cc35691082ef1d0bc8a1a1a8c2c6b40d9490aba" translate="yes" xml:space="preserve">
          <source>If you want anything fancier, consider overriding this with something that uses &lt;a href=&quot;Number::Format&quot;&gt;Number::Format&lt;/a&gt;, or does something else entirely.</source>
          <target state="translated">もっと凝ったものが必要な場合は、&lt;a href=&quot;Number::Format&quot;&gt;Number :: Format&lt;/a&gt;を使用するか、まったく別のことを行うものでこれをオーバーライドすることを検討してください。</target>
        </trans-unit>
        <trans-unit id="fe93301108d8dca54392bf8f900a5e24a5258416" translate="yes" xml:space="preserve">
          <source>If you want anything fancier, consider overriding this with something that uses &lt;a href=&quot;http://search.cpan.org/perldoc/Number::Format&quot;&gt;Number::Format&lt;/a&gt;, or does something else entirely.</source>
          <target state="translated">より洗練されたものが必要な場合は、これを&lt;a href=&quot;http://search.cpan.org/perldoc/Number::Format&quot;&gt;Number :: Format&lt;/a&gt;を使用するものでオーバーライドするか、または何か他のことを完全に行うことを検討してください。</target>
        </trans-unit>
        <trans-unit id="03e2f095ee9c1b96484a23c04f5e5dfef232e04c" translate="yes" xml:space="preserve">
          <source>If you want build some core extensions statically into perl's dll, specify them in the STATIC_EXT macro.</source>
          <target state="translated">いくつかのコア拡張をperlのdllに静的に構築したい場合は、STATIC_EXTマクロで指定します。</target>
        </trans-unit>
        <trans-unit id="18b0e9b36c2f4eaca25552fa7c7631a4398f6336" translate="yes" xml:space="preserve">
          <source>If you want finer granularity than the 1 second that the &lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; function provides, the easiest way is to use the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; function as documented in &lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;. Try the &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; and the &lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Itimer&quot;&gt;BSD::Itimer&lt;/a&gt; modules (available from CPAN, and starting from Perl 5.8 &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; is part of the standard distribution).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/sleep&quot;&gt;sleep()&lt;/a&gt;&lt;/code&gt; 関数が提供する1秒よりも細かい精度が必要な場合、最も簡単な方法は、 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; 記載されているselect（）関数を使用&lt;a href=&quot;functions/select&quot;&gt;すること&lt;/a&gt;です。&lt;a href=&quot;time/hires&quot;&gt;Time :: HiRes&lt;/a&gt;および&lt;a href=&quot;http://search.cpan.org/perldoc/BSD::Itimer&quot;&gt;BSD :: Itimer&lt;/a&gt;モジュールを試してください（CPANから入手可能で、Perl 5.8から開始&lt;a href=&quot;time/hires&quot;&gt;：Time :: HiRes&lt;/a&gt;は標準ディストリビューションの一部です）。</target>
        </trans-unit>
        <trans-unit id="938f7da4d45d138e899952c66b47a7d1e1a162f3" translate="yes" xml:space="preserve">
          <source>If you want finer granularity than the 1 second that the &lt;code&gt;sleep()&lt;/code&gt; function provides, the easiest way is to use the &lt;code&gt;select()&lt;/code&gt; function as documented in &lt;a href=&quot;perlfunc#select&quot;&gt;&quot;select&quot; in perlfunc&lt;/a&gt;. Try the &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; and the &lt;a href=&quot;BSD::Itimer&quot;&gt;BSD::Itimer&lt;/a&gt; modules (available from CPAN, and starting from Perl 5.8 &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; is part of the standard distribution).</source>
          <target state="translated">&lt;code&gt;sleep()&lt;/code&gt; 関数が提供する1秒よりも細かい粒度が必要な場合、最も簡単な方法は&lt;a href=&quot;perlfunc#select&quot;&gt;、perlfuncの「select」に&lt;/a&gt;記載されている &lt;code&gt;select()&lt;/code&gt; 関数を使用することです。&lt;a href=&quot;Time::HiRes&quot;&gt;Time :: HiRes&lt;/a&gt;および&lt;a href=&quot;BSD::Itimer&quot;&gt;BSD :: Itimer&lt;/a&gt;モジュールを試してください（CPANから入手可能で、Perl5.8以降&lt;a href=&quot;Time::HiRes&quot;&gt;Time :: HiRes&lt;/a&gt;は標準ディストリビューションの一部です）。</target>
        </trans-unit>
        <trans-unit id="e14afa459a95e2ee1097bdb5d465fc670f04bf72" translate="yes" xml:space="preserve">
          <source>If you want it to be a Unicode string (because you want character semantics with operations like regular expression matching), you need to decode the UTF8-encoded content and have Perl convert it into a Unicode string:</source>
          <target state="translated">Unicode 文字列にしたい場合 (正規表現マッチングのような操作で文字のセマンティクスが必要なため)、UTF8 でエンコードされた内容をデコードして Perl に Unicode 文字列に変換させる必要があります。</target>
        </trans-unit>
        <trans-unit id="b68288a6982fc2b55a1d1fa4ad5b3ecc68be5d47" translate="yes" xml:space="preserve">
          <source>If you want more flexibility, you need to configure your CPAN client for your particular situation.</source>
          <target state="translated">より柔軟性を求める場合は、特定の状況に合わせてCPANクライアントを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="212545de9d894bed7fa89be5bf884693fe7c603b" translate="yes" xml:space="preserve">
          <source>If you want no headers or footers output in the HTML, set these options to the empty string.</source>
          <target state="translated">HTMLにヘッダーやフッターを出力しないようにしたい場合は、これらのオプションを空文字列に設定します。</target>
        </trans-unit>
        <trans-unit id="c2f8c74db8ed8406f2f6e08a05e2a2be5038e9a9" translate="yes" xml:space="preserve">
          <source>If you want perl to use globbing that emulates the quirks of DOS filename conventions, you might want to consider using File::DosGlob to override the internal glob() implementation. See &lt;a href=&quot;File::DosGlob&quot;&gt;File::DosGlob&lt;/a&gt; for details.</source>
          <target state="translated">perlでDOSファイル名規則の癖をエミュレートするglobbingを使用する場合は、File :: DosGlobを使用して内部glob（）実装をオーバーライドすることを検討してください。詳細については、&lt;a href=&quot;File::DosGlob&quot;&gt;File :: DosGlob&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="2be3f922578397a2f9698c9c71abc2a55e6ed43d" translate="yes" xml:space="preserve">
          <source>If you want perl to use globbing that emulates the quirks of DOS filename conventions, you might want to consider using File::DosGlob to override the internal glob() implementation. See &lt;a href=&quot;file/dosglob&quot;&gt;File::DosGlob&lt;/a&gt; for details.</source>
          <target state="translated">perlがDOSファイル名規則の癖をエミュレートするグロビングを使用するようにしたい場合は、File :: DosGlobを使用して内部glob（）実装をオーバーライドすることを検討してください。詳細は&lt;a href=&quot;file/dosglob&quot;&gt;File :: DosGlob&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="08c46a24da2bb06c6e1c6ef38a1abe76f47d9a13" translate="yes" xml:space="preserve">
          <source>If you want read lines, you must read in list context.</source>
          <target state="translated">行を読みたい場合は、リストコンテキストで読む必要があります。</target>
        </trans-unit>
        <trans-unit id="9bfb8a43a2ce5fcca125d20e873c4c7b11aed7e7" translate="yes" xml:space="preserve">
          <source>If you want the &lt;code&gt;atexit()&lt;/code&gt; syntax (and an &lt;code&gt;rmexit()&lt;/code&gt; as well), try the &lt;code&gt;AtExit&lt;/code&gt; module available from CPAN.</source>
          <target state="translated">あなたがしたい場合 &lt;code&gt;atexit()&lt;/code&gt; 構文（および &lt;code&gt;rmexit()&lt;/code&gt; と同様に）、試す &lt;code&gt;AtExit&lt;/code&gt; CPANからモジュールが利用可能。</target>
        </trans-unit>
        <trans-unit id="124ea0ab66186e4216274d303cbf33e4b47044f9" translate="yes" xml:space="preserve">
          <source>If you want the array index, use the &lt;code&gt;firstidx()&lt;/code&gt; function from &lt;code&gt;List::MoreUtils&lt;/code&gt; :</source>
          <target state="translated">配列のインデックスが必要な場合は、 &lt;code&gt;List::MoreUtils&lt;/code&gt; &lt;code&gt;firstidx()&lt;/code&gt; 関数を使用します。</target>
        </trans-unit>
        <trans-unit id="7239c9f8360ace04be0d87fc661805fd9a93d6bc" translate="yes" xml:space="preserve">
          <source>If you want the array index, use the &lt;code&gt;firstidx()&lt;/code&gt; function from &lt;code&gt;List::MoreUtils&lt;/code&gt;:</source>
          <target state="translated">配列インデックスが必要な場合は、 &lt;code&gt;List::MoreUtils&lt;/code&gt; ：の &lt;code&gt;firstidx()&lt;/code&gt; 関数を使用してください。</target>
        </trans-unit>
        <trans-unit id="7615fa2a66b55733775cb5d887a00d84846653ee" translate="yes" xml:space="preserve">
          <source>If you want the code to die instead of falling back, use &lt;code&gt;only&lt;/code&gt; instead:</source>
          <target state="translated">フォールバックせずにコードを終了させたい場合は、代わりに &lt;code&gt;only&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="5f643e51c29ad1dcf8382df154f107e9e891d49b" translate="yes" xml:space="preserve">
          <source>If you want the code to die instead, replace &quot;try&quot; with &quot;only&quot;:</source>
          <target state="translated">代わりにコードを死なせたい場合は、&quot;try &quot;を &quot;only &quot;に置き換えてください。</target>
        </trans-unit>
        <trans-unit id="444d833c4fe34c4ebf55ce0643031f3aa4615d34" translate="yes" xml:space="preserve">
          <source>If you want the equivalent of &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Foo ()&lt;/code&gt; , use a module but not import anything, use &lt;code&gt;require_ok&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Foo ()&lt;/code&gt; と同等の機能が必要な場合、モジュールを使用し、何もインポートしない場合は、 &lt;code&gt;require_ok&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="cd47c89733a2d362efea4a574e386c3bfd848c97" translate="yes" xml:space="preserve">
          <source>If you want the equivalent of &lt;code&gt;use Foo ()&lt;/code&gt;, use a module but not import anything, use &lt;code&gt;require_ok&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;use Foo ()&lt;/code&gt; の使用と同等のものが必要な場合は、モジュールを使用しますが、何もインポートしない場合は、 &lt;code&gt;require_ok&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="0ebff181122cf920b540aa12f6f2468119acea8d" translate="yes" xml:space="preserve">
          <source>If you want the old signal behavior back despite possible memory corruption, set the environment variable &lt;code&gt;PERL_SIGNALS&lt;/code&gt; to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; . This feature first appeared in Perl 5.8.1.</source>
          <target state="translated">メモリが破損している可能性があるにもかかわらず、古い信号の動作を元に戻すには、環境変数 &lt;code&gt;PERL_SIGNALS&lt;/code&gt; を &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; に設定します。この機能はPerl 5.8.1ではじめて登場しました。</target>
        </trans-unit>
        <trans-unit id="829231163ed3602e1f949c7395523d09b04596b6" translate="yes" xml:space="preserve">
          <source>If you want the old signal behavior back despite possible memory corruption, set the environment variable &lt;code&gt;PERL_SIGNALS&lt;/code&gt; to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt;. This feature first appeared in Perl 5.8.1.</source>
          <target state="translated">メモリが破損している可能性があるにもかかわらず、古いシグナルの動作を元に戻したい場合は、環境変数 &lt;code&gt;PERL_SIGNALS&lt;/code&gt; を &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; に設定します。この機能は、Perl5.8.1で最初に登場しました。</target>
        </trans-unit>
        <trans-unit id="35e2e89a1af9e4f4ab883e1fb265f28d997edb48" translate="yes" xml:space="preserve">
          <source>If you want these output in a sorted order, see &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;: &quot;How do I sort a hash (optionally by value instead of key)?&quot;.</source>
          <target state="translated">これらの出力をソートしたい場合は、&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;：「ハッシュを（オプションでキーではなく値で）ソートするにはどうすればよいですか？」を参照してください。</target>
        </trans-unit>
        <trans-unit id="7b0e9370dc85f7e9dd08b608d45bee75d87d8584" translate="yes" xml:space="preserve">
          <source>If you want this event to cause the test to exit you should return the exit code here. Exit code of 0 means exit success, any other integer means exit with failure.</source>
          <target state="translated">このイベントでテストを終了させたい場合は、ここに終了コードを返す必要があります。0 の終了コードは成功を意味し、それ以外の整数は失敗で終了することを意味します。</target>
        </trans-unit>
        <trans-unit id="d12a2eb6658b08fd22781ffd73216531f2e651bd" translate="yes" xml:space="preserve">
          <source>If you want this feature, check out Yanick Champoux's &lt;code&gt;Git::CPAN::Patch&lt;/code&gt; distribution.</source>
          <target state="translated">この機能が必要な場合は、YanickChampouxの &lt;code&gt;Git::CPAN::Patch&lt;/code&gt; ディストリビューションを確認してください。</target>
        </trans-unit>
        <trans-unit id="1340d84f704d5f6a74163cc5fe06ae9be150fb8b" translate="yes" xml:space="preserve">
          <source>If you want to &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; into a string, you just have to &amp;lt;open&amp;gt; a filehandle to a string, which Perl has been able to do since Perl 5.6:</source>
          <target state="translated">文字列に &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; たい場合は、文字列へのファイルハンドルを&amp;lt;open&amp;gt;する必要があります。これは、Perl 5.6以降、Perlで実行できました。</target>
        </trans-unit>
        <trans-unit id="1004705c5f21359bd47871c5e63f216b6160306f" translate="yes" xml:space="preserve">
          <source>If you want to &lt;code&gt;write&lt;/code&gt; into a string, you just have to &amp;lt;open&amp;gt; a filehandle to a string, which Perl has been able to do since Perl 5.6:</source>
          <target state="translated">文字列に &lt;code&gt;write&lt;/code&gt; たい場合は、ファイルハンドルを文字列に&amp;lt;開く&amp;gt;必要があります。これは、Perl5.6以降Perlが実行できるようになっています。</target>
        </trans-unit>
        <trans-unit id="7953e238f104e2cdb7abf22e43568bf172380a8b" translate="yes" xml:space="preserve">
          <source>If you want to CLONE all objects you will need to keep track of them per package. This is simply done using a hash and Scalar::Util::weaken().</source>
          <target state="translated">すべてのオブジェクトをCLONEしたい場合は、パッケージごとに追跡する必要があります。これはハッシュと Scalar::Util::weaken()を使って簡単に行えます。</target>
        </trans-unit>
        <trans-unit id="8a750f90ba1cfc2d81f044342057667c6ac1726e" translate="yes" xml:space="preserve">
          <source>If you want to actually extract the matching elements, simply use grep in list context.</source>
          <target state="translated">実際にマッチする要素を抽出したい場合は、リストコンテキストで grep を使用するだけです。</target>
        </trans-unit>
        <trans-unit id="d026b5d2f0b8d0ebf6352db336c8a293bea0fac9" translate="yes" xml:space="preserve">
          <source>If you want to add your encoding to Encode's demand-loading list (so you don't have to &quot;use Encode::YourEncoding&quot;), run</source>
          <target state="translated">あなたのエンコーディングを Encode のデマンドロードリストに追加したい場合 (そうすれば &quot;Encode::YourEncoding&quot; を使う必要はありません)、次のように実行してください。</target>
        </trans-unit>
        <trans-unit id="3ceac82578bb19fb50532d7256faa44ce8c265df" translate="yes" xml:space="preserve">
          <source>If you want to append something to the end of string stored in an &lt;code&gt;SV*&lt;/code&gt; , you can use the following functions:</source>
          <target state="translated">&lt;code&gt;SV*&lt;/code&gt; 格納されている文字列の最後に何かを追加したい場合は、次の関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="20a16bcf2cf6427a4518ce31b1b9b97af29e8c74" translate="yes" xml:space="preserve">
          <source>If you want to append something to the end of string stored in an &lt;code&gt;SV*&lt;/code&gt;, you can use the following functions:</source>
          <target state="translated">&lt;code&gt;SV*&lt;/code&gt; 格納されている文字列の末尾に何かを追加する場合は、次の関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="abff1ef9e65ec72186150da0b667016af8485105" translate="yes" xml:space="preserve">
          <source>If you want to be sure that you're calling &lt;code&gt;isa&lt;/code&gt; as a method, not a class, check the invocand with &lt;code&gt;blessed&lt;/code&gt; from &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar::Util&lt;/a&gt; first:</source>
          <target state="translated">あなたが呼び出していることを確認したい場合は &lt;code&gt;isa&lt;/code&gt; 方法ではなく、クラスとして、とinvocandチェック &lt;code&gt;blessed&lt;/code&gt; から&lt;a href=&quot;Scalar::Util&quot;&gt;スカラー:: Utilの&lt;/a&gt;最初に：</target>
        </trans-unit>
        <trans-unit id="5fbae8e9319ec5948bcc63aa24cae46d2c786676" translate="yes" xml:space="preserve">
          <source>If you want to be sure that you're calling &lt;code&gt;isa&lt;/code&gt; as a method, not a class, check the invocand with &lt;code&gt;blessed&lt;/code&gt; from &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; first:</source>
          <target state="translated">あなたが呼び出していることを確認したい場合は &lt;code&gt;isa&lt;/code&gt; 方法ではなく、クラスとして、とinvocandチェック &lt;code&gt;blessed&lt;/code&gt; から&lt;a href=&quot;scalar/util&quot;&gt;スカラー:: Utilの&lt;/a&gt;最初に：</target>
        </trans-unit>
        <trans-unit id="363081145dde14f7c8fd4e2bf011a936ad34c73a" translate="yes" xml:space="preserve">
          <source>If you want to break apart an entire line of fixed columns, you can use &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; with the A (ASCII) format. By using a number after the format specifier, you can denote the column width. See the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; entries in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for more details.</source>
          <target state="translated">固定列の行全体を &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; したい場合は、A（ASCII）形式でunpackを使用できます。書式指定子の後に数値を使用すると、列幅を示すことができます。詳細については、&lt;a href=&quot;perlfunc&quot;&gt;perlfuncの&lt;/a&gt; &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; エントリを参照してください。</target>
        </trans-unit>
        <trans-unit id="619aad3b3e732995b6ff437174735944e21882dc" translate="yes" xml:space="preserve">
          <source>If you want to break apart an entire line of fixed columns, you can use &lt;code&gt;unpack&lt;/code&gt; with the A (ASCII) format. By using a number after the format specifier, you can denote the column width. See the &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; entries in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for more details.</source>
          <target state="translated">固定列の行全体を &lt;code&gt;unpack&lt;/code&gt; する場合は、A（ASCII）形式でunpackを使用できます。フォーマット指定子の後に数字を使用することで、列幅を示すことができます。詳細については、&lt;a href=&quot;perlfunc&quot;&gt;perlfuncの&lt;/a&gt; &lt;code&gt;pack&lt;/code&gt; および &lt;code&gt;unpack&lt;/code&gt; エントリを参照してください。</target>
        </trans-unit>
        <trans-unit id="10e8c447f2a79196fb827a87399f6352fddeb35d" translate="yes" xml:space="preserve">
          <source>If you want to build the docs yourself, and have</source>
          <target state="translated">自分でドキュメントを構築したい場合、そして</target>
        </trans-unit>
        <trans-unit id="3016ac8f3431196221d3334c73f10b4a58c7afce" translate="yes" xml:space="preserve">
          <source>If you want to call C from Perl, start with &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;, moving on to &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;, &lt;a href=&quot;xsubpp&quot;&gt;xsubpp&lt;/a&gt;, and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;. If you want to call Perl from C, then read &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;, &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;, and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;. Don't forget that you can learn a lot from looking at how the authors of existing extension modules wrote their code and solved their problems.</source>
          <target state="translated">PerlからCを呼び出したい場合は、&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;から&lt;a href=&quot;perlxs&quot;&gt;始めて&lt;/a&gt;、perlxs、&lt;a href=&quot;xsubpp&quot;&gt;xsubpp&lt;/a&gt;、および&lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;に移ります。CからPerlを呼び出したい場合は、&lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;、&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;、および&lt;a href=&quot;perlguts&quot;&gt;perlgutsをお&lt;/a&gt;読みください。既存の拡張モジュールの作成者がコードをどのように記述して問題を解決したかを見ると、多くのことを学ぶことができることを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="315a4534923af9a32596760e1e243392c92b8033" translate="yes" xml:space="preserve">
          <source>If you want to cancel one or several commits, you can use &lt;code&gt;git reset&lt;/code&gt;.</source>
          <target state="translated">1つまたは複数のコミットをキャンセルする場合は、 &lt;code&gt;git reset&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="548a69c6108c24555301c111e716c92968ea1230" translate="yes" xml:space="preserve">
          <source>If you want to check exactly, compare the string with its NFC/NFKC/FCC.</source>
          <target state="translated">正確に確認したい場合は、その文字列をNFC/NFKC/FCCと比較してください。</target>
        </trans-unit>
        <trans-unit id="59c2fb7af17b706fe9c70e8baa09126e5a3d250b" translate="yes" xml:space="preserve">
          <source>If you want to compress all</source>
          <target state="translated">すべての</target>
        </trans-unit>
        <trans-unit id="4a7c9a973da32835e6a4f4be3eeeb0d732a06249" translate="yes" xml:space="preserve">
          <source>If you want to configure your module files for local conditions, or to automatically insert a version number, you can use EUMM's &lt;code&gt;PL_FILES&lt;/code&gt; capability, where it will automatically run each</source>
          <target state="translated">モジュールファイルをローカル条件に合わせて構成する場合、またはバージョン番号を自動的に挿入する場合は、EUMMの &lt;code&gt;PL_FILES&lt;/code&gt; 機能を使用して、それぞれを自動的に実行できます。</target>
        </trans-unit>
        <trans-unit id="6bcfdbb5379f221cca1d97f7787d1bc312424003" translate="yes" xml:space="preserve">
          <source>If you want to control warnings on the fly, do something like this. Make sure you do the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; first, or you won't be able to get at the enable() or disable() methods.</source>
          <target state="translated">警告をその場で制御したい場合は、次のようにします。最初に &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ことを確認してください。そうしないと、enable（）またはdisable（）メソッドにアクセスできなくなります。</target>
        </trans-unit>
        <trans-unit id="20be3407cc52b51a764f0e8c0b7ea78b6fd0df8b" translate="yes" xml:space="preserve">
          <source>If you want to control warnings on the fly, do something like this. Make sure you do the &lt;code&gt;use&lt;/code&gt; first, or you won't be able to get at the enable() or disable() methods.</source>
          <target state="translated">警告をその場で制御したい場合は、次のようにします。必ず最初に &lt;code&gt;use&lt;/code&gt; してください。そうしないと、enable（）またはdisable（）メソッドを取得できなくなります。</target>
        </trans-unit>
        <trans-unit id="a42c1db2cee198b239c3cde06a946cab4e064353" translate="yes" xml:space="preserve">
          <source>If you want to control what functions Test::More will export, you have to use the 'import' option. For example, to import everything but 'fail', you'd do:</source>
          <target state="translated">Test::Moreがエクスポートする関数を制御したい場合は、'import'オプションを使用する必要があります。例えば、'fail'以外のすべての関数をインポートするには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="be1e5234b80eb1f923a376bc3491ec3ca6b109b2" translate="yes" xml:space="preserve">
          <source>If you want to convert the returned map to entirely scalar numbers, you can use something like this:</source>
          <target state="translated">返されたマップを完全にスカラ数に変換したい場合は、次のようなものを使用できます。</target>
        </trans-unit>
        <trans-unit id="7adae9875339a373afa10e8d5fe3748778b7c17f" translate="yes" xml:space="preserve">
          <source>If you want to convert to UTF-8 from encodings other than the native (Latin1 or EBCDIC), see &lt;a href=&quot;#sv_recode_to_utf8&quot;&gt;&quot;sv_recode_to_utf8&quot;&lt;/a&gt;().</source>
          <target state="translated">ネイティブ（Latin1またはEBCDIC）以外のエンコーディングからUTF-8に変換する場合は、&lt;a href=&quot;#sv_recode_to_utf8&quot;&gt;「sv_recode_to_utf8」&lt;/a&gt;（）を参照してください。</target>
        </trans-unit>
        <trans-unit id="5ba04eeea7231f6480afed51584cd45a160a944a" translate="yes" xml:space="preserve">
          <source>If you want to convert to UTF-8 from encodings other than the native (Latin1 or EBCDIC), see &lt;a href=&quot;#sv_recode_to_utf8&quot;&gt;sv_recode_to_utf8&lt;/a&gt;().</source>
          <target state="translated">ネイティブ（Latin1またはEBCDIC）以外のエンコーディングからUTF-8に変換する場合は、&lt;a href=&quot;#sv_recode_to_utf8&quot;&gt;sv_recode_to_utf8&lt;/a&gt;（）を参照してください。</target>
        </trans-unit>
        <trans-unit id="228fa3459a576d7c7cf5495612539d6810b0138e" translate="yes" xml:space="preserve">
          <source>If you want to create a zip64 zip file with the OO interface you must specify the &lt;code&gt;Zip64&lt;/code&gt; option.</source>
          <target state="translated">OOインターフェイスを使用してzip64zipファイルを作成する場合は、 &lt;code&gt;Zip64&lt;/code&gt; オプションを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="53c24008e3ed2beeee61bb3c00b23e9cec000bd1" translate="yes" xml:space="preserve">
          <source>If you want to create many anonymous handles, you should check out the Symbol or IO::Handle modules.</source>
          <target state="translated">多くの匿名ハンドルを作成したい場合は、SymbolやIO::Handleモジュールをチェックしてください。</target>
        </trans-unit>
        <trans-unit id="d3f92af00462a48927ab51881cd3156c2dfab08a" translate="yes" xml:space="preserve">
          <source>If you want to create the file if it does not already exist then bitwise-OR (&lt;code&gt;|&lt;/code&gt;) &lt;code&gt;O_CREAT&lt;/code&gt; too. If you omit &lt;code&gt;O_CREAT&lt;/code&gt; and the database does not already exist then the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call will fail.</source>
          <target state="translated">ファイルがまだ存在しない場合にファイルを作成する場合は、ビット単位OR（ &lt;code&gt;|&lt;/code&gt; ） &lt;code&gt;O_CREAT&lt;/code&gt; も使用します。 &lt;code&gt;O_CREAT&lt;/code&gt; を省略し、データベースがまだ存在しない場合、 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 呼び出しは失敗します。</target>
        </trans-unit>
        <trans-unit id="fc98ab804f43ba09ba7d693b95e26eb63a6ad833" translate="yes" xml:space="preserve">
          <source>If you want to create the file if it does not already exist then bitwise-OR (&lt;code&gt;|&lt;/code&gt;) &lt;code&gt;O_CREAT&lt;/code&gt; too. If you omit &lt;code&gt;O_CREAT&lt;/code&gt; and the database does not already exist then the &lt;code&gt;tie&lt;/code&gt; call will fail.</source>
          <target state="translated">ファイルがまだ存在しない場合にファイルを作成する場合は、ビット単位でOR（ &lt;code&gt;|&lt;/code&gt; ） &lt;code&gt;O_CREAT&lt;/code&gt; も実行します。 &lt;code&gt;O_CREAT&lt;/code&gt; を省略し、データベースがまだ存在しない場合、 &lt;code&gt;tie&lt;/code&gt; 呼び出しは失敗します。</target>
        </trans-unit>
        <trans-unit id="a116b633c8c619c49052dbd9a5c72113a8975d85" translate="yes" xml:space="preserve">
          <source>If you want to create the file if it does not exist, add &lt;code&gt;O_CREAT&lt;/code&gt; to any of these, as in the example. If you omit &lt;code&gt;O_CREAT&lt;/code&gt; and the file does not already exist, the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call will fail.</source>
          <target state="translated">ファイルが存在しない場合に作成する場合は、例のように、これらのいずれかに &lt;code&gt;O_CREAT&lt;/code&gt; を追加します。 &lt;code&gt;O_CREAT&lt;/code&gt; を省略し、ファイルがまだ存在しない場合、 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 呼び出しは失敗します。</target>
        </trans-unit>
        <trans-unit id="95ab7bc04f484a14dcd9279bd03d23b179493ba9" translate="yes" xml:space="preserve">
          <source>If you want to create the file if it does not exist, add &lt;code&gt;O_CREAT&lt;/code&gt; to any of these, as in the example. If you omit &lt;code&gt;O_CREAT&lt;/code&gt; and the file does not already exist, the &lt;code&gt;tie&lt;/code&gt; call will fail.</source>
          <target state="translated">ファイルが存在しない場合にファイルを作成する場合は、例のように、これらのいずれかに &lt;code&gt;O_CREAT&lt;/code&gt; を追加します。 &lt;code&gt;O_CREAT&lt;/code&gt; を省略し、ファイルがまだ存在しない場合、 &lt;code&gt;tie&lt;/code&gt; 呼び出しは失敗します。</target>
        </trans-unit>
        <trans-unit id="0e3b712f48285cffa7900ceeb1af82270cd7a609" translate="yes" xml:space="preserve">
          <source>If you want to cycle through an array endlessly, you can increment the index modulo the number of elements in the array:</source>
          <target state="translated">配列を無限に循環させたい場合は、配列の要素数に応じてインデックスをインクリメントすることができます。</target>
        </trans-unit>
        <trans-unit id="6cfb6d26bc5df670c402213d4036f3bf58558df4" translate="yes" xml:space="preserve">
          <source>If you want to debug some other testfile, set the &lt;code&gt;TEST_FILE&lt;/code&gt; variable thusly:</source>
          <target state="translated">他の &lt;code&gt;TEST_FILE&lt;/code&gt; をデバッグしたい場合は、TEST_FILE変数を次のように設定します。</target>
        </trans-unit>
        <trans-unit id="6048d807c79fe8c274777ea98164bb2677fd3a0f" translate="yes" xml:space="preserve">
          <source>If you want to delete your temporary branch, you may do so with:</source>
          <target state="translated">一時的なブランチを削除したい場合は、以下のようにしてください。</target>
        </trans-unit>
        <trans-unit id="b931492f8ba265d923d9e6b394913c2adf2d8e1f" translate="yes" xml:space="preserve">
          <source>If you want to disallow any rearrangement, pass &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;[]&lt;/code&gt; (a reference to empty list) as the value for this key.</source>
          <target state="translated">再配置を許可しない場合は、このキーの値として &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;[]&lt;/code&gt; （空のリストへの参照）を渡します。</target>
        </trans-unit>
        <trans-unit id="54957337acd4e58dbb0d89d2b021227b45f4fede" translate="yes" xml:space="preserve">
          <source>If you want to disallow any rearrangement, pass &lt;code&gt;undef&lt;/code&gt; or &lt;code&gt;[]&lt;/code&gt; (a reference to empty list) as the value for this key.</source>
          <target state="translated">再配置を禁止する場合は、このキーの値として &lt;code&gt;undef&lt;/code&gt; または &lt;code&gt;[]&lt;/code&gt; （空のリストへの参照）を渡します。</target>
        </trans-unit>
        <trans-unit id="e399c3f8eff9b2e3be1dfd1cb3c6e184f3c80005" translate="yes" xml:space="preserve">
          <source>If you want to do something when the object is destroyed, you can define a &lt;code&gt;DESTROY&lt;/code&gt; method in your class. This method will always be called by Perl at the appropriate time, unless the method is empty.</source>
          <target state="translated">オブジェクトが破棄されたときに何かしたい場合は、クラスに &lt;code&gt;DESTROY&lt;/code&gt; メソッドを定義できます。このメソッドは、メソッドが空でない限り、常に適切なタイミングでPerlによって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="028499023abecf52141490b3dc52996a2e6540e8" translate="yes" xml:space="preserve">
          <source>If you want to do something with the REGEXP* later use SvRX instead and check for NULL.</source>
          <target state="translated">後でREGEXP*を使って何かをしたい場合は、代わりにSvRXを使ってNULLをチェックしてください。</target>
        </trans-unit>
        <trans-unit id="5bec0b0d71b7e3b535fad4f2a98d0fdea0b5611d" translate="yes" xml:space="preserve">
          <source>If you want to do the same thing to modify the values of the hash, you can use the &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; function. As of Perl 5.6 the values are not copied, so if you modify $orbit (in this case), you modify the value.</source>
          <target state="translated">同じことを行ってハッシュの値を変更したい場合は、 &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; 関数を使用できます。Perl 5.6以降、値はコピーされないため、$ orbit（この場合）を変更すると、値が変更されます。</target>
        </trans-unit>
        <trans-unit id="935f14135388c5b598f55e1dc3d822934fdf377b" translate="yes" xml:space="preserve">
          <source>If you want to do the same thing to modify the values of the hash, you can use the &lt;code&gt;values&lt;/code&gt; function. As of Perl 5.6 the values are not copied, so if you modify $orbit (in this case), you modify the value.</source>
          <target state="translated">同じことを実行してハッシュの値を変更する場合は、 &lt;code&gt;values&lt;/code&gt; 関数を使用できます。Perl 5.6以降、値はコピーされないため、$ orbit（この場合）を変更すると、値が変更されます。</target>
        </trans-unit>
        <trans-unit id="1befe6f0c8cce90a523721cdcb6a3e759a8bf613" translate="yes" xml:space="preserve">
          <source>If you want to downgrade a warning that has been escalated into a fatal error back to a normal warning, you can use the &quot;NONFATAL&quot; keyword. For example, the code below will promote all warnings into fatal errors, except for those in the &quot;syntax&quot; category.</source>
          <target state="translated">致命的なエラーにエスカレートした警告を通常の警告に戻したい場合は、&quot;NONFATAL &quot;キーワードを使用することができます。例えば、以下のコードは、「構文」カテゴリのものを除いて、すべての警告を致命的なエラーに昇格させます。</target>
        </trans-unit>
        <trans-unit id="aaac7464ef1e41e8e3656bb3c9f1373b9810c3d2" translate="yes" xml:space="preserve">
          <source>If you want to encode a large file, you should encode it in chunks that are a multiple of 57 bytes. This ensures that the base64 lines line up and that you do not end up with padding in the middle. 57 bytes of data fills one complete base64 line (76 == 57*4/3):</source>
          <target state="translated">大きなファイルをエンコードしたい場合は、57 バイトの倍数のチャンクでエンコードする必要があります。そうすることで、base64 の行が一直線に並び、途中でパディングが発生しないようになります。57 バイトのデータは、完全な base64 行 (76 ==57*4/3)を埋めます。</target>
        </trans-unit>
        <trans-unit id="526764856cb11f1625c51adabbc0827d170cf65b" translate="yes" xml:space="preserve">
          <source>If you want to enter a multi-line command, such as a subroutine definition with several statements or a format, escape the newline that would normally end the debugger command with a backslash. Here's an example:</source>
          <target state="translated">複数のステートメントを持つサブルーチン定義やフォーマットなど、複数行のコマンドを入力したい場合は、通常はデバッガコマンドを終了する改行をバックスラッシュでエスケープしてください。以下に例を示します。</target>
        </trans-unit>
        <trans-unit id="1c27e6ce335738d835ec3fdd82f6c0809ffefc5e" translate="yes" xml:space="preserve">
          <source>If you want to find out how many characters are waiting, there's also the FIONREAD ioctl call to be looked at. The</source>
          <target state="translated">何文字待機しているかを知りたい場合は、FIONREADのioctl呼び出しも見てみましょう。呼び出しを行うための</target>
        </trans-unit>
        <trans-unit id="1da1084e18df9224120de5015e0f47b55cae04d1" translate="yes" xml:space="preserve">
          <source>If you want to find out how many entries have a defined value, that's a bit different. You have to check each value. A &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; is handy:</source>
          <target state="translated">定義された値を持つエントリの数を確認する場合は、少し異なります。各値を確認する必要があります。 &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; が便利です。</target>
        </trans-unit>
        <trans-unit id="0d72620df0696cc4732b993d293ab2b11520eef6" translate="yes" xml:space="preserve">
          <source>If you want to find out how many entries have a defined value, that's a bit different. You have to check each value. A &lt;code&gt;grep&lt;/code&gt; is handy:</source>
          <target state="translated">定義された値を持つエントリの数を知りたい場合は、少し異なります。それぞれの値を確認する必要があります。 &lt;code&gt;grep&lt;/code&gt; が便利です。</target>
        </trans-unit>
        <trans-unit id="308cd4ff0bf951ae1c4968d0825997ff4ae0e702" translate="yes" xml:space="preserve">
          <source>If you want to find the package calling your code, perhaps to give better diagnostics as &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; does, use the &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; built-in:</source>
          <target state="translated">コードを呼び出しているパッケージを見つけたい場合、おそらく&lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt;が行うように診断を改善したい場合は、組み込みの &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="7e82876e02cb96090e26d86eedc47e176c7a8339" translate="yes" xml:space="preserve">
          <source>If you want to find the package calling your code, perhaps to give better diagnostics as &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; does, use the &lt;code&gt;caller&lt;/code&gt; built-in:</source>
          <target state="translated">コードを呼び出すパッケージを見つけたい場合、おそらく&lt;a href=&quot;carp&quot;&gt;Carpの&lt;/a&gt;ようにより良い診断を提供するために、組み込みの &lt;code&gt;caller&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="3665b99091562c54c0340f04e5f55207f573bbfd" translate="yes" xml:space="preserve">
          <source>If you want to force strings to be interpreted as numbers, you could say</source>
          <target state="translated">文字列を強制的に数値として解釈したい場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="db0a89fa31368a04df7fab37ca05a2304cb913c7" translate="yes" xml:space="preserve">
          <source>If you want to generate new style events, events that do many things at once, then you want the &lt;code&gt;*ev2*&lt;/code&gt; methods. These let you directly specify which facets you wish to use.</source>
          <target state="translated">新しいスタイルのイベント、つまり一度に多くのことを実行するイベントを生成する場合は、 &lt;code&gt;*ev2*&lt;/code&gt; メソッドが必要です。これらを使用すると、使用するファセットを直接指定できます。</target>
        </trans-unit>
        <trans-unit id="e1f109680f15bd3886268c0dd93d91471450a599" translate="yes" xml:space="preserve">
          <source>If you want to get at a slice (part of a row) in a multidimensional array, you're going to have to do some fancy subscripting. That's because while we have a nice synonym for single elements via the pointer arrow for dereferencing, no such convenience exists for slices.</source>
          <target state="translated">多次元配列のスライス(行の一部)を取得するには、ちょっとした添え字が必要になります。これは、参照元を変更するためのポインタ矢印を使った単一要素の同義語がある一方で、スライスにはそのような便利な機能が存在しないからです。</target>
        </trans-unit>
        <trans-unit id="ac8d06c0714514adee4900ccc907acf01c17734d" translate="yes" xml:space="preserve">
          <source>If you want to get warned when the fallback occurs, replace &quot;try&quot; with &quot;lib&quot;:</source>
          <target state="translated">フォールバックが発生したときに警告を受けたい場合は、&quot;try &quot;を &quot;lib &quot;に置き換えてください。</target>
        </trans-unit>
        <trans-unit id="c34f1861cd969edfd158d72b53e2b8bf861c0838" translate="yes" xml:space="preserve">
          <source>If you want to have arrays of constant strings, note carefully the right combination of &lt;code&gt;const&lt;/code&gt; s:</source>
          <target state="translated">定数文字列の配列が必要な場合は、 &lt;code&gt;const&lt;/code&gt; の正しい組み合わせに注意してください。</target>
        </trans-unit>
        <trans-unit id="356345ab0ce94a5efc2714f6ef0d68b5cc2c3066" translate="yes" xml:space="preserve">
          <source>If you want to have arrays of constant strings, note carefully the right combination of &lt;code&gt;const&lt;/code&gt;s:</source>
          <target state="translated">定数文字列の配列が必要な場合は、 &lt;code&gt;const&lt;/code&gt; の正しい組み合わせに注意してください。</target>
        </trans-unit>
        <trans-unit id="cc85c01bbb2e5546a912901548bde68e7f312959" translate="yes" xml:space="preserve">
          <source>If you want to have static strings, make them constant:</source>
          <target state="translated">静的な文字列を持ちたい場合は定数にします。</target>
        </trans-unit>
        <trans-unit id="5f28aad16a41ad668dc6d2a20ee81e5f9b0af321" translate="yes" xml:space="preserve">
          <source>If you want to have your cake and eat it too, you need a more complicated boilerplate.</source>
          <target state="translated">ケーキも食べたい、食べたいと思ったら、もっと複雑なボイチャが必要です。</target>
        </trans-unit>
        <trans-unit id="732754bf3b16a13d947b836156896a3b2cedc031" translate="yes" xml:space="preserve">
          <source>If you want to indent the text in the here document, you can do this:</source>
          <target state="translated">ここの文書のテキストをインデントしたい場合は、このようにします。</target>
        </trans-unit>
        <trans-unit id="d6b9e98bf75fad13fa324d37df3fb0822a303c98" translate="yes" xml:space="preserve">
          <source>If you want to influence compilation of calls to a specific subroutine, then use &lt;a href=&quot;#cv_set_call_checker&quot;&gt;cv_set_call_checker&lt;/a&gt; rather than hooking checking of all &lt;code&gt;entersub&lt;/code&gt; ops.</source>
          <target state="translated">特定のサブルーチンへの呼び出しのコンパイルに影響を与えたい場合は、すべての &lt;code&gt;entersub&lt;/code&gt; 操作のチェックをフックするのではなく、&lt;a href=&quot;#cv_set_call_checker&quot;&gt;cv_set_call_checker&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="e66b9245a42c5136074f90bbcaa24c2089883633" translate="yes" xml:space="preserve">
          <source>If you want to influence compilation of calls to a specific subroutine, then use &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;&quot;cv_set_call_checker_flags&quot;&lt;/a&gt; rather than hooking checking of all &lt;code&gt;entersub&lt;/code&gt; ops.</source>
          <target state="translated">特定のサブルーチンへの呼び出しのコンパイルに影響を与えたい場合は、すべての &lt;code&gt;entersub&lt;/code&gt; opsのチェックをフックするのではなく、&lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;「cv_set_call_checker_flags」を&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="48d06034c9b20f332ef6d3aafef878e55cf37779" translate="yes" xml:space="preserve">
          <source>If you want to inherit the parent thread's locale, you can, in the parent, set a variable like so:</source>
          <target state="translated">親スレッドのロケールを継承したい場合は、親スレッドで以下のように変数を設定します。</target>
        </trans-unit>
        <trans-unit id="168d6eb05b72021bb2cefd5586f5642721fb25b0" translate="yes" xml:space="preserve">
          <source>If you want to install a distribution from the current directory, you can tell &lt;code&gt;CPAN.pm&lt;/code&gt; to install &lt;code&gt;.&lt;/code&gt; (the full stop):</source>
          <target state="translated">現在のディレクトリからディストリビューションをインストールする場合は、 &lt;code&gt;CPAN.pm&lt;/code&gt; にをインストールするように指示できます &lt;code&gt;.&lt;/code&gt; （終点）：</target>
        </trans-unit>
        <trans-unit id="33e2d2f8b434b4a1cc7c6346d405264c8380bf51" translate="yes" xml:space="preserve">
          <source>If you want to install modules for your own use, the easiest way might be &lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local::lib&lt;/a&gt;, which you can download from CPAN. It sets various installation settings for you, and uses those same settings within your programs.</source>
          <target state="translated">自分で使用するためにモジュールをインストールする場合、最も簡単な方法は&lt;a href=&quot;http://search.cpan.org/perldoc/local::lib&quot;&gt;local :: libで&lt;/a&gt;、CPANからダウンロードできます。さまざまなインストール設定を設定し、プログラム内で同じ設定を使用します。</target>
        </trans-unit>
        <trans-unit id="b3dae34f8c2a04f0b25691fed783ebc83dba7816" translate="yes" xml:space="preserve">
          <source>If you want to install modules for your own use, the easiest way might be &lt;a href=&quot;local::lib&quot;&gt;local::lib&lt;/a&gt;, which you can download from CPAN. It sets various installation settings for you, and uses those same settings within your programs.</source>
          <target state="translated">自分で使用するためにモジュールをインストールする場合、最も簡単な方法は、CPANからダウンロードできる&lt;a href=&quot;local::lib&quot;&gt;local :: lib&lt;/a&gt;です。さまざまなインストール設定を設定し、プログラム内で同じ設定を使用します。</target>
        </trans-unit>
        <trans-unit id="58d2dc539671f427bbae58845aceababd0159c6c" translate="yes" xml:space="preserve">
          <source>If you want to know as little about Perl as possible but need to add a new encoding, just read this chapter and forget the rest.</source>
          <target state="translated">Perl のことを少しでも知りたいが、新しいエンコーディングを追加する必要がある場合は、この章を読んであとは忘れてください。</target>
        </trans-unit>
        <trans-unit id="56e1fbcaca6130206229f6c3c8cb0c2d52fb54b7" translate="yes" xml:space="preserve">
          <source>If you want to know how Perl OO works under the hood, the &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt; document explains the nitty gritty details.</source>
          <target state="translated">Perl OOが&lt;a href=&quot;perlobj&quot;&gt;内部&lt;/a&gt;でどのように動作するかを知りたい場合は、perlobjドキュメントに詳細な説明があります。</target>
        </trans-unit>
        <trans-unit id="9f23a106d53e80c8c0f8d1f2b0c84d08d1054140" translate="yes" xml:space="preserve">
          <source>If you want to know how to handle automated testing for your distribution, you can check the environment. The CPAN Testers, for instance, set the value of &lt;code&gt;AUTOMATED_TESTING&lt;/code&gt; :</source>
          <target state="translated">ディストリビューションの自動テストの処理方法を知りたい場合は、環境を確認できます。たとえば、CPANテスターは &lt;code&gt;AUTOMATED_TESTING&lt;/code&gt; の値を設定します。</target>
        </trans-unit>
        <trans-unit id="9b495e524dc71177b8e643e1224800f20371e451" translate="yes" xml:space="preserve">
          <source>If you want to know how to handle automated testing for your distribution, you can check the environment. The CPAN Testers, for instance, set the value of &lt;code&gt;AUTOMATED_TESTING&lt;/code&gt;:</source>
          <target state="translated">ディストリビューションの自動テストの処理方法を知りたい場合は、環境を確認できます。たとえば、CPANテスターは &lt;code&gt;AUTOMATED_TESTING&lt;/code&gt; の値を設定します。</target>
        </trans-unit>
        <trans-unit id="1a57ed6abdc67a27c928054414c38fcc1c565d58" translate="yes" xml:space="preserve">
          <source>If you want to know if the scalar value is TRUE, you can use:</source>
          <target state="translated">スカラ値がTRUEかどうかを知りたい場合は</target>
        </trans-unit>
        <trans-unit id="f0f2be398a4f429a704b8881af39ff31858188bb" translate="yes" xml:space="preserve">
          <source>If you want to know if this variable (or any other SV) is actually &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt;, you can call:</source>
          <target state="translated">この変数（または他のSV）が実際に &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; ているかどうかを知りたい場合は、次を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="daea143b4968577fdbd42832858949f2fd1cdff0" translate="yes" xml:space="preserve">
          <source>If you want to know if this variable (or any other SV) is actually &lt;code&gt;defined&lt;/code&gt;, you can call:</source>
          <target state="translated">この変数（または他のSV）が実際に &lt;code&gt;defined&lt;/code&gt; ているかどうかを知りたい場合は、次のように呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="3c60925561c19aa1767251e2aee467af3279de6f" translate="yes" xml:space="preserve">
          <source>If you want to know whether a particular scalar refers to an object, you can use the &lt;code&gt;blessed&lt;/code&gt; function exported by &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar::Util&lt;/a&gt;, which is shipped with the Perl core.</source>
          <target state="translated">特定のスカラーがオブジェクトを参照しているかどうかを知りたい場合は、Perlコアに付属している&lt;a href=&quot;Scalar::Util&quot;&gt;Scalar :: Util&lt;/a&gt;によってエクスポートされた &lt;code&gt;blessed&lt;/code&gt; 関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="4282549729bb35373ef94d2e2b64ea8af51a5d06" translate="yes" xml:space="preserve">
          <source>If you want to know whether a particular scalar refers to an object, you can use the &lt;code&gt;blessed&lt;/code&gt; function exported by &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt;, which is shipped with the Perl core.</source>
          <target state="translated">特定のスカラーがオブジェクトを参照しているかどうかを知りたい場合は、Perlコアに同梱されている&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;によってエクスポートされた &lt;code&gt;blessed&lt;/code&gt; された関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="056d8ddf16a11d708261878d4f200cc28e75de75" translate="yes" xml:space="preserve">
          <source>If you want to learn more about Perl 6, or have a desire to help in the crusade to make Perl a better place then read the Perl 6 developers page at &lt;a href=&quot;http://www.perl6.org/&quot;&gt;http://www.perl6.org/&lt;/a&gt; and get involved.</source>
          <target state="translated">Perl 6についてさらに学びたい場合や、Perlをより良い場所にするための運動に協力したい場合は、&lt;a href=&quot;http://www.perl6.org/&quot;&gt;http：//www.perl6.org/の&lt;/a&gt; Perl 6開発者ページを読んで参加してください。</target>
        </trans-unit>
        <trans-unit id="00255f60e5cd77d55f44acd05aa25f0d59366611" translate="yes" xml:space="preserve">
          <source>If you want to learn the basics of Perl, you might start with the Llama book, which assumes that you already know a little about programming:</source>
          <target state="translated">Perlの基礎を学びたいのであれば、すでにプログラミングを少し知っていることを前提としたLlamaの本から始めるといいかもしれません。</target>
        </trans-unit>
        <trans-unit id="b59f1075805db9d0b1d16e3fcdbf9d21e65a49a6" translate="yes" xml:space="preserve">
          <source>If you want to limit yourself to a much more narrow definition of what a version string constitutes, &lt;code&gt;is_strict()&lt;/code&gt; is limited to version strings like the following list:</source>
          <target state="translated">バージョン文字列が構成するもののより狭い定義に自分自身を制限したい場合、 &lt;code&gt;is_strict()&lt;/code&gt; は次のリストのようなバージョン文字列に制限されます。</target>
        </trans-unit>
        <trans-unit id="859f839c744c136d7bdf5037e58bd0e9887e2618" translate="yes" xml:space="preserve">
          <source>If you want to load a subclass from a file that &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; would not consider an eligible filename (that is, it does not end in either &lt;code&gt;.pm&lt;/code&gt; or &lt;code&gt;.pmc&lt;/code&gt;), use the following code:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; ファイルを必要としない（つまり、 &lt;code&gt;.pm&lt;/code&gt; または &lt;code&gt;.pmc&lt;/code&gt; で終わっていない）ファイルからサブクラスをロードする場合は、次のコードを使用します。</target>
        </trans-unit>
        <trans-unit id="1e6ddafbd419154de1f46300a143dfff13d40dbc" translate="yes" xml:space="preserve">
          <source>If you want to load a subclass from a file that &lt;code&gt;require&lt;/code&gt; would not consider an eligible filename (that is, it does not end in either &lt;code&gt;.pm&lt;/code&gt; or &lt;code&gt;.pmc&lt;/code&gt;), use the following code:</source>
          <target state="translated">適格なファイル名を考慮しない &lt;code&gt;require&lt;/code&gt; がある（つまり、 &lt;code&gt;.pm&lt;/code&gt; または &lt;code&gt;.pmc&lt;/code&gt; で終わらない）ファイルからサブクラスをロードする場合は、次のコードを使用します。</target>
        </trans-unit>
        <trans-unit id="b43171de60cc7817f0c0ddd386dd67107ef6f821" translate="yes" xml:space="preserve">
          <source>If you want to load the entire file, you can use the &lt;a href=&quot;Path::Tiny&quot;&gt;Path::Tiny&lt;/a&gt; module to do it in one simple and efficient step:</source>
          <target state="translated">ファイル全体をロードする場合は、&lt;a href=&quot;Path::Tiny&quot;&gt;Path :: Tiny&lt;/a&gt;モジュールを使用して、1つの簡単で効率的な手順でロードできます。</target>
        </trans-unit>
        <trans-unit id="63bacba7c0db3c9f406fbf3ba9dec50a07c74303" translate="yes" xml:space="preserve">
          <source>If you want to load the entire file, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Path::Tiny&quot;&gt;Path::Tiny&lt;/a&gt; module to do it in one simple and efficient step:</source>
          <target state="translated">ファイル全体をロードしたい場合は、&lt;a href=&quot;http://search.cpan.org/perldoc/Path::Tiny&quot;&gt;Path :: Tiny&lt;/a&gt;モジュールを使用して、1つのシンプルで効率的なステップで実行できます。</target>
        </trans-unit>
        <trans-unit id="b17927939e60f1cedd222b2461104e02f72f02d9" translate="yes" xml:space="preserve">
          <source>If you want to make a real copy, use the following:</source>
          <target state="translated">本格的にコピーしたい場合は、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="85008415a7eb8c5259c1befce3f088e509e6063e" translate="yes" xml:space="preserve">
          <source>If you want to make changes to someone else's topic branch, you should check with its creator before making any change to it.</source>
          <target state="translated">他の人のトピックブランチに変更を加えたい場合は、変更を加える前にその作成者に確認してください。</target>
        </trans-unit>
        <trans-unit id="011cab076badf929a664e79819f2251ac21c5335" translate="yes" xml:space="preserve">
          <source>If you want to make the SV drop its string buffer, use &lt;code&gt;sv_force_normal_flags(sv, SV_COW_DROP_PV)&lt;/code&gt; or simply &lt;code&gt;sv_setsv(sv, NULL)&lt;/code&gt; .</source>
          <target state="translated">SVに文字列バッファをドロップさせる場合は、 &lt;code&gt;sv_force_normal_flags(sv, SV_COW_DROP_PV)&lt;/code&gt; または単に &lt;code&gt;sv_setsv(sv, NULL)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="e876f29c89b13d2955e7ddc7b720fb71debcd99e" translate="yes" xml:space="preserve">
          <source>If you want to make the SV drop its string buffer, use &lt;code&gt;sv_force_normal_flags(sv, SV_COW_DROP_PV)&lt;/code&gt; or simply &lt;code&gt;sv_setsv(sv, NULL)&lt;/code&gt;.</source>
          <target state="translated">SVに文字列バッファを削除させる場合は、 &lt;code&gt;sv_force_normal_flags(sv, SV_COW_DROP_PV)&lt;/code&gt; または単に &lt;code&gt;sv_setsv(sv, NULL)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="686e0dae9b58a50551e5307de1a432fa51bae3cd" translate="yes" xml:space="preserve">
          <source>If you want to make use of the new features available in Berkeley DB 2.x or greater, use the Perl module &lt;a href=&quot;https://metacpan.org/pod/BerkeleyDB&quot;&gt;BerkeleyDB&lt;/a&gt; instead.</source>
          <target state="translated">Berkeley DB 2.x以降で利用可能な新機能を利用する場合は、代わりにPerlモジュール&lt;a href=&quot;https://metacpan.org/pod/BerkeleyDB&quot;&gt;BerkeleyDBを&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="4b7523637fc2645186f899696d73931e051d6c52" translate="yes" xml:space="preserve">
          <source>If you want to make use of the new features available in Berkeley DB 2.x or greater, use the Perl module &lt;b&gt;BerkeleyDB&lt;/b&gt; instead.</source>
          <target state="translated">Berkeley DB 2.x以降で利用可能な新機能を利用したい場合は、代わりにPerlモジュール&lt;b&gt;BerkeleyDBを&lt;/b&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="610bb38fb99d325c8e7fefe0a23a02b343634382" translate="yes" xml:space="preserve">
          <source>If you want to modify the debugger, copy</source>
          <target state="translated">デバッガを変更したい場合は</target>
        </trans-unit>
        <trans-unit id="68a89277cf24a3194f901f3f723f1840c4c2f27b" translate="yes" xml:space="preserve">
          <source>If you want to open either STDIN or STDOUT with &lt;code&gt;gzopen&lt;/code&gt; , you can now optionally use the special filename &quot;&lt;code&gt;-&lt;/code&gt; &quot; as a synonym for &lt;code&gt;\*STDIN&lt;/code&gt; and &lt;code&gt;\*STDOUT&lt;/code&gt; .</source>
          <target state="translated">STDINまたはSTDOUTのいずれかを &lt;code&gt;gzopen&lt;/code&gt; で開く場合は、オプションで特別なファイル名「 &lt;code&gt;-&lt;/code&gt; 」を &lt;code&gt;\*STDIN&lt;/code&gt; および &lt;code&gt;\*STDOUT&lt;/code&gt; の同義語として使用できます。</target>
        </trans-unit>
        <trans-unit id="47c9bd4478a0c2ce9ccca6507ec4f47c10afe7d5" translate="yes" xml:space="preserve">
          <source>If you want to open either STDIN or STDOUT with &lt;code&gt;gzopen&lt;/code&gt;, you can now optionally use the special filename &quot;&lt;code&gt;-&lt;/code&gt;&quot; as a synonym for &lt;code&gt;\*STDIN&lt;/code&gt; and &lt;code&gt;\*STDOUT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gzopen&lt;/code&gt; を使用してSTDINまたはSTDOUTのいずれかを開く場合は、オプションで特別なファイル名「 &lt;code&gt;-&lt;/code&gt; 」を &lt;code&gt;\*STDIN&lt;/code&gt; および &lt;code&gt;\*STDOUT&lt;/code&gt; の同義語として使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="e41fd5af244837759f6e880c0fa8c36bc7f07f26" translate="yes" xml:space="preserve">
          <source>If you want to overload a Perl operator, such as &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;**&lt;/code&gt; , then you'll want to use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; pragma, documented in &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; や &lt;code&gt;**&lt;/code&gt; などのPerl演算子をオーバーロードする場合は、&lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;に記載されている &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; プラグマを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="71a40071766dc5d5747b55ec51fa1862eac4c688" translate="yes" xml:space="preserve">
          <source>If you want to overload a Perl operator, such as &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;**&lt;/code&gt;, then you'll want to use the &lt;code&gt;use overload&lt;/code&gt; pragma, documented in &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;.</source>
          <target state="translated">あなたのような、Perlの演算子をオーバーロードしたい場合は &lt;code&gt;+&lt;/code&gt; または &lt;code&gt;**&lt;/code&gt; 、あなたが使用したいと思う &lt;code&gt;use overload&lt;/code&gt; に記載プラグマ、&lt;a href=&quot;overload&quot;&gt;過負荷を&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="42ce9bc615c09fb69253d86037255e2b78a92d09" translate="yes" xml:space="preserve">
          <source>If you want to override a predefined function, such as open(), then you'll have to import the new definition from a different module. See &lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;&quot;Overriding Built-in Functions&quot; in perlsub&lt;/a&gt;.</source>
          <target state="translated">open（）などの事前定義された関数をオーバーライドする場合は、別のモジュールから新しい定義をインポートする必要があります。&lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;perlsubの「組み込み関数のオーバーライド」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="945aa8bcea0076aea35d4a81e4ba840ff11ec82e" translate="yes" xml:space="preserve">
          <source>If you want to override a predefined function, such as open(), then you'll have to import the new definition from a different module. See &lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;Overriding Built-in Functions in perlsub&lt;/a&gt;.</source>
          <target state="translated">open（）などの事前定義された関数をオーバーライドする場合は、別のモジュールから新しい定義をインポートする必要があります。&lt;a href=&quot;perlsub#Overriding-Built-in-Functions&quot;&gt;perlsubの組み込み関数のオーバーライドを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="fa48921f25a631295f915526fc8a70c73af7fbf8" translate="yes" xml:space="preserve">
          <source>If you want to override the mapping of Hangul syllables, NFD and NFKD are not appropriate, since NFD and NFKD will decompose Hangul syllables before overriding. FCD may decompose Hangul syllables as the case may be.</source>
          <target state="translated">ハングル音節のマッピングをオーバーライドしたい場合は、オーバーライドする前に NFD や NFKD がハングル音節を分解してしまうので、NFD や NFKD は適切ではありません。FCDは場合によってはハングルのシラブルを分解することもあります。</target>
        </trans-unit>
        <trans-unit id="a2d7808a54f71b111b57ef9e68ce46ce86f7a686" translate="yes" xml:space="preserve">
          <source>If you want to package the Perl DLLs (one for WINS, one for ARMI), the headers, and the documentation:</source>
          <target state="translated">Perl DLL (1つはWINS用、もう1つはARMI用)、ヘッダ、ドキュメントをパッケージ化したい場合。</target>
        </trans-unit>
        <trans-unit id="1e047de81a230edfe4349188d5e8044f9337baa8" translate="yes" xml:space="preserve">
          <source>If you want to package the PerlApp sources:</source>
          <target state="translated">PerlAppのソースをパッケージ化する場合。</target>
        </trans-unit>
        <trans-unit id="ab41e5eda5a02ddfb48b24411170b91dc8f23c72" translate="yes" xml:space="preserve">
          <source>If you want to package the perl.exe and miniperl.exe, you can use the perlexe.sis and miniperlexe.sis make targets. You also probably want the perllib.sis for the libraries and maybe even the perlapp.sis for the recognizer.</source>
          <target state="translated">perl.exeとminiperl.exeをパッケージ化したい場合は、perlexe.sisとminiperlexe.sisを使用してターゲットを作成することができます。また、ライブラリにはperllib.sis、認識器にはperlapp.sisが必要でしょう。</target>
        </trans-unit>
        <trans-unit id="5c827c3a5508b73a4c675d093f91220233b7dc11" translate="yes" xml:space="preserve">
          <source>If you want to pass arguments to the Perl subroutine, you can add strings to the &lt;code&gt;NULL&lt;/code&gt; -terminated &lt;code&gt;args&lt;/code&gt; list passed to</source>
          <target state="translated">引数をPerlサブルーチンに渡したい場合は、渡された &lt;code&gt;NULL&lt;/code&gt; で終了する &lt;code&gt;args&lt;/code&gt; リストに文字列を追加できます。</target>
        </trans-unit>
        <trans-unit id="9fe959ed77f2d03a4c32411d66f89a3b169a2e6b" translate="yes" xml:space="preserve">
          <source>If you want to pass arguments to the Perl subroutine, you can add strings to the &lt;code&gt;NULL&lt;/code&gt;-terminated &lt;code&gt;args&lt;/code&gt; list passed to</source>
          <target state="translated">Perlサブルーチンに引数を渡したい場合は、渡された &lt;code&gt;NULL&lt;/code&gt; で終了する &lt;code&gt;args&lt;/code&gt; リストに文字列を追加できます。</target>
        </trans-unit>
        <trans-unit id="5c0b08e235edf0d26d308eb349b59ea3ef72cb9d" translate="yes" xml:space="preserve">
          <source>If you want to pass more than one array or hash into a function--or return them from it--and have them maintain their integrity, then you're going to have to use an explicit pass-by-reference. Before you do that, you need to understand references as detailed in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. This section may not make much sense to you otherwise.</source>
          <target state="translated">複数の配列またはハッシュを関数に渡す（または関数から返す）必要があり、それらの整合性を維持したい場合は、明示的な参照渡しを使用する必要があります。その前に、&lt;a href=&quot;perlref&quot;&gt;perlrefで&lt;/a&gt;詳述されているリファレンスを理解する必要があります。そうでない場合、このセクションはあまり意味がありません。</target>
        </trans-unit>
        <trans-unit id="c8a70766df71ba2d4b4ce04954ec69dff30a7c0f" translate="yes" xml:space="preserve">
          <source>If you want to pass switches into your script, you can use one of the &lt;code&gt;Getopts&lt;/code&gt; modules or put a loop on the front like this:</source>
          <target state="translated">スイッチをスクリプトに渡す場合は、 &lt;code&gt;Getopts&lt;/code&gt; モジュールの1つを使用するか、次のようにループを前面に配置します。</target>
        </trans-unit>
        <trans-unit id="d40edffb04fe413946f227532d6ff1f352d417e2" translate="yes" xml:space="preserve">
          <source>If you want to port your own favourite C library for big numbers to the Math::BigInt interface, you can take any of the already existing modules as a rough guideline. You should really wrap up the latest Math::BigInt and Math::BigFloat testsuites with your module, and replace in them any of the following:</source>
          <target state="translated">大数のための独自のお気に入りの C ライブラリを Math::BigInt インターフェイスに移植したい場合は、既存のモジュールのいずれかを大まかなガイドラインとすることができます。最新の Math::BigInt と Math::BigFloat テストスイートをあなたのモジュールで包み込み、以下のいずれかを置き換えてください。</target>
        </trans-unit>
        <trans-unit id="f4bd2c5192aedd065d255be14f3583448bb4e171" translate="yes" xml:space="preserve">
          <source>If you want to port your own favourite c-lib for big numbers to the Math::BigInt interface, you can take any of the already existing modules as a rough guideline. You should really wrap up the latest BigInt and BigFloat testsuites with your module, and replace in them any of the following:</source>
          <target state="translated">大数のためのお気に入りの c-lib を Math::BigInt インターフェイスに移植したい場合は、既存のモジュールのどれかを大まかなガイドラインとすることができます。最新の BigInt と BigFloat のテストスイートをモジュールで包み込み、以下のいずれかを置き換えてください。</target>
        </trans-unit>
        <trans-unit id="edf16417cd93b7c19e3e333701fc067e37f8d0a5" translate="yes" xml:space="preserve">
          <source>If you want to position the file for &lt;a href=&quot;#sysread-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt;&lt;code&gt;sysread&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#syswrite-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt;&lt;code&gt;syswrite&lt;/code&gt;&lt;/a&gt;, don't use &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;, because buffering makes its effect on the file's read-write position unpredictable and non-portable. Use &lt;a href=&quot;#sysseek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;sysseek&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;a href=&quot;#sysread-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt; &lt;code&gt;sysread&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;#syswrite-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt; &lt;code&gt;syswrite&lt;/code&gt; &lt;/a&gt;用にファイルを配置する場合は、&lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;seek&lt;/code&gt; を&lt;/a&gt;使用しないでください。バッファリングにより、ファイルの読み取り/書き込み位置への影響が予測できず、移植できないためです。代わりに&lt;a href=&quot;#sysseek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;sysseek&lt;/code&gt; &lt;/a&gt;を使用してください。</target>
        </trans-unit>
        <trans-unit id="376b22a241cce9ba252fd1c8a6df064f6b6eac08" translate="yes" xml:space="preserve">
          <source>If you want to position the file for &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;, don't use &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, because buffering makes its effect on the file's read-write position unpredictable and non-portable. Use &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">ファイルを &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; に配置する場合は、 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 使用しないでください。バッファリングにより、ファイルの読み取り/書き込み位置への影響が予測できなくなり、移植できなくなります。代わりに &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="ab53baa73269bc54f793e2d56860c5115ebd11f4" translate="yes" xml:space="preserve">
          <source>If you want to position the file for &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;, don't use &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, because buffering makes its effect on the file's read-write position unpredictable and non-portable. Use &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">ファイルを &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; に配置する場合は、 &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 使用しないでください。バッファリングにより、ファイルの読み取り/書き込み位置への影響が予測できなくなり、移植できなくなります。代わりに &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="a0c3e6b22044730d55d9a0c06443157660dba6ef" translate="yes" xml:space="preserve">
          <source>If you want to preserve any existing contents, then you want to open the file in append mode. As in the shell, in Perl you use &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; to open an existing file in append mode. &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; creates the file if it does not already exist.</source>
          <target state="translated">既存のコンテンツを保持する場合は、ファイルを追加モードで開きます。シェルと同様に、Perlでは &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; を使用して既存のファイルを追加モードで開きます。 &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; は、ファイルが存在しない場合は作成します。</target>
        </trans-unit>
        <trans-unit id="17bd731415d5d66dc3d1ddceae18e6e16a628145" translate="yes" xml:space="preserve">
          <source>If you want to preserve the original hashes, copy one hash (&lt;code&gt;%hash1&lt;/code&gt; ) to a new hash (&lt;code&gt;%new_hash&lt;/code&gt; ), then add the keys from the other hash (&lt;code&gt;%hash2&lt;/code&gt; to the new hash. Checking that the key already exists in &lt;code&gt;%new_hash&lt;/code&gt; gives you a chance to decide what to do with the duplicates:</source>
          <target state="translated">あなたは、元のハッシュを保存したい場合は、1つのハッシュ（コピー &lt;code&gt;%hash1&lt;/code&gt; 新しいハッシュ（へ） &lt;code&gt;%new_hash&lt;/code&gt; ）、その後、（他のハッシュからキーを追加 &lt;code&gt;%hash2&lt;/code&gt; 新しいハッシュする。キーが既に存在していることをチェック &lt;code&gt;%new_hash&lt;/code&gt; 重複をどうするかを決める機会を与えます：</target>
        </trans-unit>
        <trans-unit id="63a3234ab9d086d5117080e1694d17f6063efd88" translate="yes" xml:space="preserve">
          <source>If you want to preserve the original hashes, copy one hash (&lt;code&gt;%hash1&lt;/code&gt;) to a new hash (&lt;code&gt;%new_hash&lt;/code&gt;), then add the keys from the other hash (&lt;code&gt;%hash2&lt;/code&gt; to the new hash. Checking that the key already exists in &lt;code&gt;%new_hash&lt;/code&gt; gives you a chance to decide what to do with the duplicates:</source>
          <target state="translated">元のハッシュを保持する場合は、1つのハッシュ（ &lt;code&gt;%hash1&lt;/code&gt; ）を新しいハッシュ（ &lt;code&gt;%new_hash&lt;/code&gt; ）にコピーしてから、他のハッシュ（ &lt;code&gt;%hash2&lt;/code&gt; から新しいハッシュにキーを追加します。キーが &lt;code&gt;%new_hash&lt;/code&gt; に既に存在することを確認します。重複をどうするかを決める機会を与えてくれます：</target>
        </trans-unit>
        <trans-unit id="50f7b3c025841bfcdb1aab514c8e2d8e36fbc766" translate="yes" xml:space="preserve">
          <source>If you want to print the whole thing, though, you can't say</source>
          <target state="translated">とはいえ、丸ごと印刷したい場合は</target>
        </trans-unit>
        <trans-unit id="a688a8a7ff8d4400e1c5937f70dbd49815b89f90" translate="yes" xml:space="preserve">
          <source>If you want to process all sections, even if they're not targeted for you, call this before you start parsing:</source>
          <target state="translated">対象外のセクションであっても、すべてのセクションを処理したい場合は、パースを開始する前にこれを呼び出します。</target>
        </trans-unit>
        <trans-unit id="93f1e3a9ebfe45627e0241306de345142f514db8" translate="yes" xml:space="preserve">
          <source>If you want to provide config to the source you can use:</source>
          <target state="translated">ソースにconfigを提供したい場合は、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="9f3a66952ab51429c329502faae26a704977a338" translate="yes" xml:space="preserve">
          <source>If you want to read a gzip file a line at a time and have it respect the &lt;code&gt;$/&lt;/code&gt; variable (or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; , or &lt;code&gt;$RS&lt;/code&gt; when &lt;code&gt;English&lt;/code&gt; is in use) see &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt;.</source>
          <target state="translated">一度に1行ずつgzipファイルを読み取り、 &lt;code&gt;$/&lt;/code&gt; 変数（または &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; 、または &lt;code&gt;English&lt;/code&gt; が使用されている場合は &lt;code&gt;$RS&lt;/code&gt; ）を尊重する場合は、&lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO :: Uncompress :: Gunzipを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="0160e4f5dbef362c1a03e51ec2cddded373c9cc7" translate="yes" xml:space="preserve">
          <source>If you want to read a gzip file a line at a time and have it respect the &lt;code&gt;$/&lt;/code&gt; variable (or &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt;, or &lt;code&gt;$RS&lt;/code&gt; when &lt;code&gt;English&lt;/code&gt; is in use) see &lt;a href=&quot;IO::Uncompress::Gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt;.</source>
          <target state="translated">gzipファイルを一度に1行ずつ読み取り、 &lt;code&gt;$/&lt;/code&gt; 変数（または &lt;code&gt;$INPUT_RECORD_SEPARATOR&lt;/code&gt; または &lt;code&gt;English&lt;/code&gt; が使用されている場合は &lt;code&gt;$RS&lt;/code&gt; ）を尊重する場合は、&lt;a href=&quot;IO::Uncompress::Gunzip&quot;&gt;IO :: Uncompress :: Gunzipを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7d31f53859a4168c72e90a2128210958319d4f50" translate="yes" xml:space="preserve">
          <source>If you want to read from a text file, first open it in read-only mode like this:</source>
          <target state="translated">テキストファイルから読みたい場合は、まずこのように読み取り専用モードで開きます。</target>
        </trans-unit>
        <trans-unit id="87011e177a00565655904726c281857b45b374f1" translate="yes" xml:space="preserve">
          <source>If you want to rebase a personal topic branch, you will have to delete your existing topic branch and push as a new version of it. You can do this via the following formula (see the explanation about &lt;code&gt;refspec&lt;/code&gt;'s in the git push documentation for details) after you have rebased your branch:</source>
          <target state="translated">個人のトピックブランチをリベースする場合は、既存のトピックブランチを削除して、新しいバージョンとしてプッシュする必要があります。 &lt;code&gt;refspec&lt;/code&gt; した後、次の式を使用してこれを行うことができます（詳細については、git pushのドキュメントのrefspecに関する説明を参照してください）。</target>
        </trans-unit>
        <trans-unit id="d4ab6b15624972e8c18a42d8d83c1cd6a30cfb30" translate="yes" xml:space="preserve">
          <source>If you want to release a 'beta' or 'alpha' version of a module but don't want CPAN.pm to list it as most recent use an '_' after the regular version number followed by at least 2 digits, eg. 1.20_01. If you do this, the following idiom is recommended:</source>
          <target state="translated">モジュールの 'beta' や 'alpha' バージョンをリリースしたいが、CPAN.pm に最新版としてリストアップさせたくない場合は、通常のバージョン番号の後に '_' を付けて、少なくとも 2 桁の数字を付けてください。この場合、以下の慣用句を使うことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="aec7d886a6e5c93bd394402ec290052fc195c585" translate="yes" xml:space="preserve">
          <source>If you want to remove the line terminator from your here-docs, use &lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/chomp&quot;&gt;chomp()&lt;/a&gt;&lt;/code&gt; ドキュメントから行末記号を削除したい場合は、chomp（）を使用してください。</target>
        </trans-unit>
        <trans-unit id="272ecc9c9621686a80692664d0c1217296386dd2" translate="yes" xml:space="preserve">
          <source>If you want to remove the line terminator from your here-docs, use &lt;code&gt;chomp()&lt;/code&gt;.</source>
          <target state="translated">here-docsから &lt;code&gt;chomp()&lt;/code&gt; を削除する場合は、chomp（）を使用します。</target>
        </trans-unit>
        <trans-unit id="01b69a42c3c7880bfb1671d398c3d54c0775a7ac" translate="yes" xml:space="preserve">
          <source>If you want to report a bug in Perl, or browse existing Perl bugs and patches, use the GitHub issue tracker at &lt;a href=&quot;https://github.com/perl/perl5/issues&quot;&gt;https://github.com/perl/perl5/issues&lt;/a&gt;.</source>
          <target state="translated">Perlのバグを報告したり、既存のPerlのバグやパッチを参照したりする場合は、&lt;a href=&quot;https://github.com/perl/perl5/issues&quot;&gt;https：//github.com/perl/perl5/issuesに&lt;/a&gt;あるGitHub課題追跡システムを使用してください。</target>
        </trans-unit>
        <trans-unit id="db615c188722d8560c52e776e317416a34e011c1" translate="yes" xml:space="preserve">
          <source>If you want to report a bug in Perl, you must use the</source>
          <target state="translated">Perl のバグを報告したい場合は</target>
        </trans-unit>
        <trans-unit id="f2154f64aff6e9940c9fb796b1289c8d854d7ca5" translate="yes" xml:space="preserve">
          <source>If you want to represent quotation marks inside a quotation-mark-delimited field, escape them with backslashes (eg, &lt;code&gt;&quot;like \&quot;this\&quot;&quot;&lt;/code&gt; .</source>
          <target state="translated">引用符で区切られたフィールド内で引用符を表す場合は、バックスラッシュでエスケープします（例： &lt;code&gt;&quot;like \&quot;this\&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="addfd131b393c5c4b432b77bcfe15c8060aec494" translate="yes" xml:space="preserve">
          <source>If you want to represent quotation marks inside a quotation-mark-delimited field, escape them with backslashes (eg, &lt;code&gt;&quot;like \&quot;this\&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">引用符で区切られたフィールド内で引用符を表す場合は、バックスラッシュでエスケープします（たとえば、 &lt;code&gt;&quot;like \&quot;this\&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="824f7654e0ed811f4acc48396871cdac5a94cdda" translate="yes" xml:space="preserve">
          <source>If you want to retain the UTF-x code points then in script form you might want to write:</source>
          <target state="translated">UTF-x コードポイントを保持したい場合は、スクリプト形式で書くとよいでしょう。</target>
        </trans-unit>
        <trans-unit id="2c2c9c1a65a810709ccd4ab8e9bc83e0091df0bc" translate="yes" xml:space="preserve">
          <source>If you want to retrieve the time at which the file was last read, written, or had its meta-data (owner, etc) changed, you use the &lt;b&gt;-A&lt;/b&gt;, &lt;b&gt;-M&lt;/b&gt;, or &lt;b&gt;-C&lt;/b&gt; file test operations as documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;. These retrieve the age of the file (measured against the start-time of your program) in days as a floating point number. Some platforms may not have all of these times. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for details. To retrieve the &quot;raw&quot; time in seconds since the epoch, you would call the stat function, then use &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;POSIX::strftime()&lt;/code&gt; to convert this into human-readable form.</source>
          <target state="translated">ファイルが最後に読み取られた、書き込まれた、またはそのメタデータ（所有者など）が変更された時刻を取得する場合は、&lt;a href=&quot;perlfunc&quot;&gt;perlfuncに&lt;/a&gt;記載されている&lt;b&gt;-A&lt;/b&gt;、&lt;b&gt;-M&lt;/b&gt;、または&lt;b&gt;-C&lt;/b&gt;ファイルテスト操作を使用します。これらは、浮動小数点数としてファイルの経過時間（プログラムの開始時間に対して測定）を日数で取得します。一部のプラットフォームでは、これらのすべての時間が存在しない場合があります。詳細は&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;を参照してください。エポックからの「生」時間を秒単位で取得するには、stat関数を呼び出してから、 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;POSIX::strftime()&lt;/code&gt; を使用して、これを人が読める形式に変換します。</target>
        </trans-unit>
        <trans-unit id="3c0db177b448ef2ea4c3aecad4e767f4cc4d9798" translate="yes" xml:space="preserve">
          <source>If you want to retrieve the time at which the file was last read, written, or had its meta-data (owner, etc) changed, you use the &lt;b&gt;-A&lt;/b&gt;, &lt;b&gt;-M&lt;/b&gt;, or &lt;b&gt;-C&lt;/b&gt; file test operations as documented in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;. These retrieve the age of the file (measured against the start-time of your program) in days as a floating point number. Some platforms may not have all of these times. See &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; for details. To retrieve the &quot;raw&quot; time in seconds since the epoch, you would call the stat function, then use &lt;code&gt;localtime()&lt;/code&gt;, &lt;code&gt;gmtime()&lt;/code&gt;, or &lt;code&gt;POSIX::strftime()&lt;/code&gt; to convert this into human-readable form.</source>
          <target state="translated">ファイルが最後に読み取られた、書き込まれた、またはメタデータ（所有者など）が変更された時刻を取得する場合は、&lt;a href=&quot;perlfunc&quot;&gt;perlfuncに&lt;/a&gt;記載されているように、&lt;b&gt;-A&lt;/b&gt;、&lt;b&gt;-M&lt;/b&gt;、または&lt;b&gt;-C&lt;/b&gt;ファイルテスト操作を使用します。これらは、ファイルの経過時間（プログラムの開始時刻に対して測定）を浮動小数点数として日数で取得します。一部のプラットフォームでは、これらすべての時間がない場合があります。詳細については、&lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;を参照してください。エポックからの「生の」時間を秒単位で取得するには、stat関数を呼び出してから、 &lt;code&gt;localtime()&lt;/code&gt; 、 &lt;code&gt;gmtime()&lt;/code&gt; 、または &lt;code&gt;POSIX::strftime()&lt;/code&gt; を使用して、これを人間が読める形式に変換します。</target>
        </trans-unit>
        <trans-unit id="ea86bc2e0842c32d086b82e0b936c78284136301" translate="yes" xml:space="preserve">
          <source>If you want to run an external command and still keep your Perl process going, look at a piped &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">外部コマンドを実行し、Perlプロセスを続行する場合は、パイプで &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; れたopen、 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; を調べます。</target>
        </trans-unit>
        <trans-unit id="e3f78cfe37d3db27661bac9c838b06f1955541c1" translate="yes" xml:space="preserve">
          <source>If you want to run an external command and still keep your Perl process going, look at a piped &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;fork&lt;/code&gt;, or &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">外部コマンドを実行してもPerlプロセスを続行したい場合は、パイプで &lt;code&gt;open&lt;/code&gt; 、 &lt;code&gt;fork&lt;/code&gt; 、または &lt;code&gt;system&lt;/code&gt; 調べてください。</target>
        </trans-unit>
        <trans-unit id="5ec243e8883915ce98e61a2fb629a6bec35df46c" translate="yes" xml:space="preserve">
          <source>If you want to run any of the tests yourself manually using e.g. valgrind, please note that by default perl &lt;b&gt;does not&lt;/b&gt; explicitly cleanup all the memory it has allocated (such as global memory arenas) but instead lets the exit() of the whole program &quot;take care&quot; of such allocations, also known as &quot;global destruction of objects&quot;.</source>
          <target state="translated">valgrindなどを使用して手動でテストを実行する場合、デフォルトでは、perl は割り当てたすべてのメモリ（グローバルメモリアリーナなど）を明示的にクリーンアップ&lt;b&gt;せず&lt;/b&gt;、プログラム全体のexit（）を許可します。 「オブジェクトのグローバル破壊」とも呼ばれる、このような割り当てに注意してください。</target>
        </trans-unit>
        <trans-unit id="c579d4f4691b7da6dbe69f3dde05c84842ed87a2" translate="yes" xml:space="preserve">
          <source>If you want to run particular test files, set the &lt;code&gt;TEST_FILES&lt;/code&gt; variable. It is possible to use globbing with this mechanism.</source>
          <target state="translated">特定のテストファイルを実行する場合は、 &lt;code&gt;TEST_FILES&lt;/code&gt; 変数を設定します。このメカニズムでグロビングを使用することが可能です。</target>
        </trans-unit>
        <trans-unit id="cab446873fde6bc4766b7caa4c1c83cdf5ad957d" translate="yes" xml:space="preserve">
          <source>If you want to see the command History, type an '&lt;b&gt;H&lt;/b&gt;':</source>
          <target state="translated">コマンドの履歴を表示するには、「&lt;b&gt;H&lt;/b&gt;」と入力します。</target>
        </trans-unit>
        <trans-unit id="852c71f5265989b791fcb0bad50a31c13ad56ee6" translate="yes" xml:space="preserve">
          <source>If you want to see what perl is doing when parsing/lexing your code, you can use &lt;code&gt;BEGIN {}&lt;/code&gt; :</source>
          <target state="translated">コードを解析/字句解析するときにperlが何をしているかを確認したい場合は、 &lt;code&gt;BEGIN {}&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="5bcd47e1ec20a6f03629c4df1db050e464bbba10" translate="yes" xml:space="preserve">
          <source>If you want to see what perl is doing when parsing/lexing your code, you can use &lt;code&gt;BEGIN {}&lt;/code&gt;:</source>
          <target state="translated">コードを解析/字句解析するときにperlが何をしているのかを知りたい場合は、 &lt;code&gt;BEGIN {}&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="3175d2c86530c83d13669e65994d9eb74402053d" translate="yes" xml:space="preserve">
          <source>If you want to see what the parser/lexer is doing inside of &lt;code&gt;if&lt;/code&gt; blocks and the like you need to be a little trickier:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; ブロックなどの中でパーサー/レクサーが何をしているかを確認したい場合は、少しトリッキーにする必要があります。</target>
        </trans-unit>
        <trans-unit id="8bca41d076fff99126cd66f621ea4770f98d22fe" translate="yes" xml:space="preserve">
          <source>If you want to select on many filehandles, you may wish to write a subroutine like this:</source>
          <target state="translated">多くのファイルハンドルで選択したい場合は、このようなサブルーチンを書くとよいでしょう。</target>
        </trans-unit>
        <trans-unit id="933790916a521b582a0514fa93b65b7620fb02f6" translate="yes" xml:space="preserve">
          <source>If you want to separate your lines with something other than &lt;code&gt;\n&lt;/code&gt; then set &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; to your preference. This replaces all newlines with &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; . If you just want to preserve existing newlines but add new breaks with something else, set &lt;code&gt;$Text::Wrap::separator2&lt;/code&gt; instead.</source>
          <target state="translated">行を &lt;code&gt;\n&lt;/code&gt; 以外の行で区切る場合は、 &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; を好みに設定します。これにより、すべての改行が &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; 置き換えられます。既存の改行を保持するだけで、別の改行を追加する場合は、代わりに &lt;code&gt;$Text::Wrap::separator2&lt;/code&gt; を設定します。</target>
        </trans-unit>
        <trans-unit id="60f1d3455cd48b5c9113f562dbd29843400fd015" translate="yes" xml:space="preserve">
          <source>If you want to separate your lines with something other than &lt;code&gt;\n&lt;/code&gt; then set &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; to your preference. This replaces all newlines with &lt;code&gt;$Text::Wrap::separator&lt;/code&gt;. If you just want to preserve existing newlines but add new breaks with something else, set &lt;code&gt;$Text::Wrap::separator2&lt;/code&gt; instead.</source>
          <target state="translated">行を &lt;code&gt;\n&lt;/code&gt; 以外で区切る場合は、 &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; を好みに設定します。これにより、すべての改行が &lt;code&gt;$Text::Wrap::separator&lt;/code&gt; 置き換えられます。既存の改行を保持したいが、他の何かで新しい改行を追加したい場合は、代わりに &lt;code&gt;$Text::Wrap::separator2&lt;/code&gt; を設定します。</target>
        </trans-unit>
        <trans-unit id="f22c0f1a9c1e2e9b3f3593f17d9d5d341e79a144" translate="yes" xml:space="preserve">
          <source>If you want to set &lt;code&gt;@ARGV&lt;/code&gt; to your own list of files, go right ahead. This sets &lt;code&gt;@ARGV&lt;/code&gt; to all plain text files if no &lt;code&gt;@ARGV&lt;/code&gt; was given:</source>
          <target state="translated">&lt;code&gt;@ARGV&lt;/code&gt; を独自のファイルリストに設定する場合は、先に進んでください。このセットは &lt;code&gt;@ARGV&lt;/code&gt; 何の場合は、すべてのテキストファイルに &lt;code&gt;@ARGV&lt;/code&gt; が与えられませんでした。</target>
        </trans-unit>
        <trans-unit id="003bfc7ab07433c173e20140a008ce04554b2602" translate="yes" xml:space="preserve">
          <source>If you want to set this to true, you should probably also set &lt;code&gt;no_whining&lt;/code&gt; or at least &lt;code&gt;no_errata_section&lt;/code&gt; to true.</source>
          <target state="translated">これをtrueに設定する場合は、おそらく &lt;code&gt;no_whining&lt;/code&gt; または少なくとも &lt;code&gt;no_errata_section&lt;/code&gt; もtrueに設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="ec4550a1aa8d843e1070b1e888de468d819935e7" translate="yes" xml:space="preserve">
          <source>If you want to set your encoding layers based on your locale environment variables, you can use the &lt;code&gt;:locale&lt;/code&gt; pseudo-layer. For example:</source>
          <target state="translated">ロケール環境変数に基づいてエンコーディングレイヤーを設定する場合は、 &lt;code&gt;:locale&lt;/code&gt; 疑似レイヤーを使用できます。例えば：</target>
        </trans-unit>
        <trans-unit id="c597fab938b142e9f257da003c8529a2b550cc0b" translate="yes" xml:space="preserve">
          <source>If you want to set your encoding layers based on your locale environment variables, you can use the &lt;code&gt;:locale&lt;/code&gt; tag. For example:</source>
          <target state="translated">ロケール環境変数に基づいてエンコーディングレイヤーを設定する場合は、 &lt;code&gt;:locale&lt;/code&gt; タグを使用できます。例えば：</target>
        </trans-unit>
        <trans-unit id="58f89c017aa82e00c2db2aafdcc4c822b860fb98" translate="yes" xml:space="preserve">
          <source>If you want to smoke test Perl, install &lt;code&gt;Perl&lt;/code&gt;.</source>
          <target state="translated">Perlのスモークテストを行う場合は、Perlをインストールして &lt;code&gt;Perl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d56ce2ac72e38205347248835f6ba0461360176f" translate="yes" xml:space="preserve">
          <source>If you want to smoke test Perl, install &lt;code&gt;patch&lt;/code&gt;.</source>
          <target state="translated">Perlのスモークテストを行う場合は、 &lt;code&gt;patch&lt;/code&gt; インストールしてください。</target>
        </trans-unit>
        <trans-unit id="a51e8012104c70a0c9ac8e8247b5e7beb2e02a77" translate="yes" xml:space="preserve">
          <source>If you want to specify a full module name you use the '+' prefix:</source>
          <target state="translated">完全なモジュール名を指定したい場合は、プレフィックス '+' を使用します。</target>
        </trans-unit>
        <trans-unit id="f93a5a664c0fedc0848a47a9e0bdfdba8a57c6b9" translate="yes" xml:space="preserve">
          <source>If you want to specify perl options &lt;code&gt;-my_opts&lt;/code&gt; to the perl itself (as opposed to your program), use</source>
          <target state="translated">（プログラムではなく）perl自体にperlオプション &lt;code&gt;-my_opts&lt;/code&gt; を指定する場合は、次を使用します。</target>
        </trans-unit>
        <trans-unit id="16a2b27e854284e5624b52325615871e56858329" translate="yes" xml:space="preserve">
          <source>If you want to specify the version of Perl, but don't care about the version of the module, pass &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for the module version:</source>
          <target state="translated">Perlのバージョンを指定したいが、モジュールのバージョンは気にしない場合は、モジュールバージョンに &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を渡します。</target>
        </trans-unit>
        <trans-unit id="3e15a1112b03a30e2e96987ec4625cc5601ef943" translate="yes" xml:space="preserve">
          <source>If you want to specify the version of Perl, but don't care about the version of the module, pass &lt;code&gt;undef&lt;/code&gt; for the module version:</source>
          <target state="translated">Perlのバージョンを指定したいが、モジュールのバージョンを気にしない場合は、モジュールのバージョンに &lt;code&gt;undef&lt;/code&gt; を渡します。</target>
        </trans-unit>
        <trans-unit id="4170c2908419d9f1f4a325cd881e413a4558b490" translate="yes" xml:space="preserve">
          <source>If you want to suppress man page installation for all modules you have to reconfigure Perl and tell it 'none' when it asks where to install man pages.</source>
          <target state="translated">すべてのモジュールへの man ページのインストールを抑制したい場合は、Perl を再設定し、 man ページのインストール先を尋ねられたときに 'none' と答える必要があります。</target>
        </trans-unit>
        <trans-unit id="73be2d5223229972e63c46363d25a8b4ecd5d388" translate="yes" xml:space="preserve">
          <source>If you want to take advantage of this new implicit dereferencing behavior, go right ahead: it makes code easier on the eye and wrist. Just understand that older releases will choke on it during compilation. Whenever you make use of something that works only in some given release of Perl and later, but not earlier, you should place a prominent</source>
          <target state="translated">この新しい暗黙の参照解除の動作を利用したいのであれば、すぐに実行してください。ただ、古いリリースではコンパイル時に詰まってしまうことを理解しておいてください。Perl やそれ以前のリリースではなく、それ以降のリリースでしか動作しないものを使用するときは、常に、目立つように</target>
        </trans-unit>
        <trans-unit id="57200b37088a74d0cf2864498f9f2df2310c106a" translate="yes" xml:space="preserve">
          <source>If you want to take into account the &lt;a href=&quot;bytes&quot;&gt;bytes&lt;/a&gt; pragma, use &lt;code&gt;&lt;a href=&quot;#DO_UTF8&quot;&gt;&quot;DO_UTF8&quot;&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;a href=&quot;bytes&quot;&gt;バイト&lt;/a&gt;プラグマを考慮したい場合は、代わりに &lt;code&gt;&lt;a href=&quot;#DO_UTF8&quot;&gt;&quot;DO_UTF8&quot;&lt;/a&gt;&lt;/code&gt; 使用してください。</target>
        </trans-unit>
        <trans-unit id="e1677e0d939fbca31e3c5c86eaef838b1e761cee" translate="yes" xml:space="preserve">
          <source>If you want to take into account the &lt;a href=&quot;bytes&quot;&gt;bytes&lt;/a&gt; pragma, use &lt;code&gt;&lt;a href=&quot;#DO_UTF8&quot;&gt;DO_UTF8&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;a href=&quot;bytes&quot;&gt;bytes&lt;/a&gt;プラグマを考慮する場合は、代わりに &lt;code&gt;&lt;a href=&quot;#DO_UTF8&quot;&gt;DO_UTF8&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="3a26b59839e0fcf13a53cc201bc8166040a47a6c" translate="yes" xml:space="preserve">
          <source>If you want to test what the limits are, the</source>
          <target state="translated">限界が何なのかをテストしたいのであれば</target>
        </trans-unit>
        <trans-unit id="be8af06e2253191bf1cfa1761503b16d4281bf21" translate="yes" xml:space="preserve">
          <source>If you want to trap errors when loading an XS module, some problems with the binary interface (such as Perl version skew) may be fatal even with &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; unless &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; is set. See &lt;a href=&quot;../perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">XSモジュールのロード時にエラーをトラップしたい場合、 &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; が設定されていない限り、 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; を使用しても、バイナリインターフェースに関するいくつかの問題（Perlバージョンのスキューなど）が致命的な場合があります。&lt;a href=&quot;../perlrun&quot;&gt;perlrunを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7dc2a0aef2f5b8c2b438b365b49a4c2f0d40f6ac" translate="yes" xml:space="preserve">
          <source>If you want to trap errors when loading an XS module, some problems with the binary interface (such as Perl version skew) may be fatal even with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; unless &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; is set. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">XSモジュールのロード時にエラーをトラップしたい場合、 &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; が設定されていない限り、 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; を使用しても、バイナリインターフェースに関するいくつかの問題（Perlバージョンのスキューなど）が致命的な場合があります。&lt;a href=&quot;perlrun&quot;&gt;perlrunを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e07434ddfb0dc6b8d6999cae38187552629bd142" translate="yes" xml:space="preserve">
          <source>If you want to trap errors when loading an XS module, some problems with the binary interface (such as Perl version skew) may be fatal even with &lt;code&gt;eval&lt;/code&gt; unless &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; is set. See &lt;a href=&quot;perlrun#PERL_DL_NONLAZY&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">XSモジュールのロード時にエラーをトラップしたい場合は、 &lt;code&gt;$ENV{PERL_DL_NONLAZY}&lt;/code&gt; が設定されていない限り、 &lt;code&gt;eval&lt;/code&gt; を使用してもバイナリインターフェイスの問題（Perlバージョンスキューなど）が致命的となる可能性があります。&lt;a href=&quot;perlrun#PERL_DL_NONLAZY&quot;&gt;perlrunを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b6ffd07b12749a1692d47d579873dc74d6c4dfaf" translate="yes" xml:space="preserve">
          <source>If you want to try to install a distribution by yourself, resolving all dependencies on your own, you follow one of two possible build paths.</source>
          <target state="translated">ディストリビューションを自分でインストールして、依存関係をすべて自分で解決したい場合は、2つの可能なビルドパスのうちの1つに従うことになります。</target>
        </trans-unit>
        <trans-unit id="c7b6e4ceeebb57e710804bd7d8e9ec8adbeff637" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;a href=&quot;#alarm-SECONDS&quot;&gt;&lt;code&gt;alarm&lt;/code&gt;&lt;/a&gt; to time out a system call you need to use an &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; pair. You can't rely on the alarm causing the system call to fail with &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; set to &lt;code&gt;EINTR&lt;/code&gt; because Perl sets up signal handlers to restart system calls on some systems. Using &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; always works, modulo the caveats given in &lt;a href=&quot;perlipc#Signals&quot;&gt;&quot;Signals&quot; in perlipc&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#alarm-SECONDS&quot;&gt; &lt;code&gt;alarm&lt;/code&gt; &lt;/a&gt;を使用してシステムコールをタイムアウトする場合は、&lt;a href=&quot;#eval-EXPR&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#die-LIST&quot;&gt; &lt;code&gt;die&lt;/code&gt; &lt;/a&gt;ペアを使用する必要があります。システムコールが&lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;失敗する原因となるアラームに頼ることはできません！Perlは一部のシステムでシステムコールを再開するようにシグナルハンドラーを設定するため、 &lt;code&gt;EINTR&lt;/code&gt; に設定します。&lt;a href=&quot;#eval-EXPR&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#die-LIST&quot;&gt; &lt;code&gt;die&lt;/code&gt; &lt;/a&gt;を使用すると、&lt;a href=&quot;perlipc#Signals&quot;&gt;perlipcの「Signals」に記載さ&lt;/a&gt;れている警告を法として常に機能します。</target>
        </trans-unit>
        <trans-unit id="fbe14747549d8ad4516b4e89ba086fe45d5bc952" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;$.&lt;/code&gt; , you can reduce it to a simple one-liner, like one of these:</source>
          <target state="translated">&lt;code&gt;$.&lt;/code&gt; を使用したい場合。、次のような単純なワンライナーに減らすことができます。</target>
        </trans-unit>
        <trans-unit id="82a547affa563deb5ba9f50355b601f3dc49971a" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;$.&lt;/code&gt;, you can reduce it to a simple one-liner, like one of these:</source>
          <target state="translated">&lt;code&gt;$.&lt;/code&gt; を使用したい場合。、次のいずれかのように、単純なワンライナーに縮小できます。</target>
        </trans-unit>
        <trans-unit id="638caf8fdb384503ed24e0af4c2fa1fdaedcfe89" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; to time out a system call you need to use an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; pair. You can't rely on the alarm causing the system call to fail with &lt;code&gt;$!&lt;/code&gt; set to &lt;code&gt;EINTR&lt;/code&gt; because Perl sets up signal handlers to restart system calls on some systems. Using &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; always works, modulo the caveats given in &lt;a href=&quot;../perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; を使用してシステムコールをタイムアウトする場合は、 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ペアを使用する必要があります。システムコールが &lt;code&gt;$!&lt;/code&gt; 失敗する原因となるアラームに依存することはできません。 &lt;code&gt;EINTR&lt;/code&gt; に設定します。これは、Perlが一部のシステムでシステムコールを再起動するようにシグナルハンドラを設定するためです。 &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; を使用すると、常に機能&lt;a href=&quot;../perlipc#Signals&quot;&gt;します。perlipcのシグナルで&lt;/a&gt;与えられた警告を法として使用します。</target>
        </trans-unit>
        <trans-unit id="47fc081d4f98f1098211a1c78312dbb51873804c" translate="yes" xml:space="preserve">
          <source>If you want to use &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; to time out a system call you need to use an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; pair. You can't rely on the alarm causing the system call to fail with &lt;code&gt;$!&lt;/code&gt; set to &lt;code&gt;EINTR&lt;/code&gt; because Perl sets up signal handlers to restart system calls on some systems. Using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; always works, modulo the caveats given in &lt;a href=&quot;perlipc#Signals&quot;&gt;Signals in perlipc&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; を使用してシステムコールをタイムアウトする場合は、 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; ペアを使用する必要があります。システムコールが &lt;code&gt;$!&lt;/code&gt; 失敗する原因となるアラームに依存することはできません。 &lt;code&gt;EINTR&lt;/code&gt; に設定します。これは、Perlが一部のシステムでシステムコールを再起動するようにシグナルハンドラを設定するためです。 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; を使用すると、常に機能&lt;a href=&quot;perlipc#Signals&quot;&gt;します。perlipcのシグナルで&lt;/a&gt;与えられた警告を法として使用します。</target>
        </trans-unit>
        <trans-unit id="b5d0b0984ed944888f7b73a2ab2ac582618153b1" translate="yes" xml:space="preserve">
          <source>If you want to use Perl on a non-z/OS EBCDIC machine, please let us know at &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="translated">z / OS以外のEBCDICマシンでPerlを使用する場合は、&lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https：//github.com/Perl/perl5/issuesで&lt;/a&gt;お知らせください。</target>
        </trans-unit>
        <trans-unit id="95a0ee4afc73cc3c28bb4ee34fc5e5c78c608e7d" translate="yes" xml:space="preserve">
          <source>If you want to use Perl on a non-z/OS EBCDIC machine, please let us know by sending mail to perlbug@perl.org</source>
          <target state="translated">z/OS以外のEBCDICマシンでPerlを使いたい場合は、perlbug@perl.org までメールでお知らせください。</target>
        </trans-unit>
        <trans-unit id="e5b580ca1f65ec0f5a604fbeb668e8741070d520" translate="yes" xml:space="preserve">
          <source>If you want to use Perl on the Hurd, I recommend using the Debian GNU/Hurd distribution ( see &lt;a href=&quot;http://www.debian.org/&quot;&gt;http://www.debian.org/&lt;/a&gt; ), even if an official, stable release has not yet been made. The old &quot;gnu-0.2&quot; binary distribution will most certainly have additional problems.</source>
          <target state="translated">HurdでPerlを使用する場合は、公式の安定したリリースがまだ作成されていない場合でも、Debian GNU / Hurdディストリビューション（&lt;a href=&quot;http://www.debian.org/&quot;&gt;http://www.debian.org/を参照&lt;/a&gt;）を使用することをお勧めします。古い &quot;gnu-0.2&quot;バイナリ配布には、間違いなく追加の問題があります。</target>
        </trans-unit>
        <trans-unit id="189532095e3e00417c9441e09145ca9ef2976e21" translate="yes" xml:space="preserve">
          <source>If you want to use Perl on the Hurd, I recommend using the Debian GNU/Hurd distribution ( see &lt;a href=&quot;https://www.debian.org/&quot;&gt;https://www.debian.org/&lt;/a&gt; ), even if an official, stable release has not yet been made. The old &quot;gnu-0.2&quot; binary distribution will most certainly have additional problems.</source>
          <target state="translated">HurdでPerlを使用したい場合は、公式の安定したリリースがまだ作成されていなくても、Debian GNU / Hurdディストリビューション（&lt;a href=&quot;https://www.debian.org/&quot;&gt;https://www.debian.org/を&lt;/a&gt;参照）を使用することをお勧めします。古い「gnu-0.2」バイナリ配布には、間違いなく追加の問題があります。</target>
        </trans-unit>
        <trans-unit id="7811171164463a43cee04445a18ab7a656878768" translate="yes" xml:space="preserve">
          <source>If you want to use a module, try the &lt;code&gt;uniq&lt;/code&gt; function from &lt;a href=&quot;List::MoreUtils&quot;&gt;List::MoreUtils&lt;/a&gt;. In list context it returns the unique elements, preserving their order in the list. In scalar context, it returns the number of unique elements.</source>
          <target state="translated">モジュールを使用する場合は、&lt;a href=&quot;List::MoreUtils&quot;&gt;List :: MoreUtilsの&lt;/a&gt; &lt;code&gt;uniq&lt;/code&gt; 関数を試してください。リストコンテキストでは、一意の要素を返し、リスト内の順序を保持します。スカラーコンテキストでは、一意の要素の数を返します。</target>
        </trans-unit>
        <trans-unit id="7687d514ed5fdcc15efde5d3bf9ba63b53f53add" translate="yes" xml:space="preserve">
          <source>If you want to use a module, try the &lt;code&gt;uniq&lt;/code&gt; function from &lt;a href=&quot;http://search.cpan.org/perldoc/List::MoreUtils&quot;&gt;List::MoreUtils&lt;/a&gt;. In list context it returns the unique elements, preserving their order in the list. In scalar context, it returns the number of unique elements.</source>
          <target state="translated">モジュールを使用したい場合は、&lt;a href=&quot;http://search.cpan.org/perldoc/List::MoreUtils&quot;&gt;List :: MoreUtilsの&lt;/a&gt; &lt;code&gt;uniq&lt;/code&gt; 関数を試してください。リストのコンテキストでは、リスト内での順序を維持しながら、一意の要素を返します。スカラーコンテキストでは、一意の要素の数を返します。</target>
        </trans-unit>
        <trans-unit id="655bd3463f5ce3b5ada699426719c6ddc69d4f2a" translate="yes" xml:space="preserve">
          <source>If you want to use multiple patterns, e.g. &lt;code&gt;bsd_glob(&quot;a* b*&quot;)&lt;/code&gt; , you should probably throw them in a set as in &lt;code&gt;bsd_glob(&quot;{a*,b*}&quot;)&lt;/code&gt; . This is because the argument to bsd_glob() isn't subjected to parsing by the C shell. Remember that you can use a backslash to escape things.</source>
          <target state="translated">たとえば &lt;code&gt;bsd_glob(&quot;a* b*&quot;)&lt;/code&gt; ように複数のパターンを使用したい場合は、おそらく &lt;code&gt;bsd_glob(&quot;{a*,b*}&quot;)&lt;/code&gt; ように、それらをセットでスローする必要があります。これは、bsd_glob（）の引数がCシェルによる解析を受けないためです。バックスラッシュを使用してエスケープできることに注意してください。</target>
        </trans-unit>
        <trans-unit id="de3b637ffc15b7fdc6a8a524ee7e6cebe2311614" translate="yes" xml:space="preserve">
          <source>If you want to use multiple patterns, e.g. &lt;code&gt;bsd_glob(&quot;a* b*&quot;)&lt;/code&gt;, you should probably throw them in a set as in &lt;code&gt;bsd_glob(&quot;{a*,b*}&quot;)&lt;/code&gt;. This is because the argument to bsd_glob() isn't subjected to parsing by the C shell. Remember that you can use a backslash to escape things.</source>
          <target state="translated">&lt;code&gt;bsd_glob(&quot;a* b*&quot;)&lt;/code&gt; ように複数のパターンを使用する場合は、 &lt;code&gt;bsd_glob(&quot;{a*,b*}&quot;)&lt;/code&gt; ようにそれらをセットでスローする必要があります。これは、bsd_glob（）への引数がCシェルによる解析の対象にならないためです。バックスラッシュを使用して物事をエスケープできることを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="daaf83327da114b41b8c24aa71d08a4f5617620d" translate="yes" xml:space="preserve">
          <source>If you want to use non-ASCII bytes (outside the bytes 0x00..0x7f) in the &quot;source code&quot; of your code, to be portable you have to be explicit about what bytes they are. Someone might for example be using your code under a UTF-8 locale, in which case random native bytes might be illegal (&quot;Malformed UTF-8 ...&quot;) This means that for example embedding ISO 8859-1 bytes beyond 0x7f into your strings might cause trouble later. If the bytes are native 8-bit bytes, you can use the &lt;code&gt;bytes&lt;/code&gt; pragma. If the bytes are in a string (regular expressions being curious strings), you can often also use the &lt;code&gt;\xHH&lt;/code&gt; or more portably, the &lt;code&gt;\N{U+HH}&lt;/code&gt; notations instead of embedding the bytes as-is. If you want to write your code in UTF-8, you can use &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;.</source>
          <target state="translated">コードの「ソースコード」で非ASCIIバイト（バイト0x00..0x7fの外）を使用したい場合は、移植可能にするために、それらのバイトを明示する必要があります。たとえば、誰かがUTF-8ロケールでコードを使用している可能性があります。その場合、ランダムなネイティブバイトは不正である可能性があります（「不正なUTF-8 ...」）。たとえば、0x7fを超えるISO 8859-1バイトを文字列は後で問題を引き起こす可能性があります。バイトがネイティブの8ビットバイトの場合、 &lt;code&gt;bytes&lt;/code&gt; プラグマを使用できます。バイトが文字列内にある場合（正規表現は奇妙な文字列です）、バイトをそのまま埋め込む代わりに、 &lt;code&gt;\xHH&lt;/code&gt; またはより移植性の高い &lt;code&gt;\N{U+HH}&lt;/code&gt; 表記を使用することもできます。コードをUTF-8で記述したい場合は、&lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="bfe339f2912f8f17fbf2b42472a9d509e3a576bf" translate="yes" xml:space="preserve">
          <source>If you want to use the same literal digits (644) in Perl, you have to tell Perl to treat them as octal numbers either by prefixing the digits with a &lt;code&gt;0&lt;/code&gt; or using &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Perlで同じリテラル数字（644）を使用する場合は、数字の前に &lt;code&gt;0&lt;/code&gt; を付けるか、 &lt;code&gt;&lt;a href=&quot;functions/oct&quot;&gt;oct&lt;/a&gt;&lt;/code&gt; を使用して、それらを8進数として扱うようにPerlに指示する必要があります。</target>
        </trans-unit>
        <trans-unit id="1dae8918eb32c3f3b5353faf9a6fd2771293c0e6" translate="yes" xml:space="preserve">
          <source>If you want to use the same literal digits (644) in Perl, you have to tell Perl to treat them as octal numbers either by prefixing the digits with a &lt;code&gt;0&lt;/code&gt; or using &lt;code&gt;oct&lt;/code&gt;:</source>
          <target state="translated">Perlで同じリテラル数字（644）を使用する場合は、数字の前に &lt;code&gt;0&lt;/code&gt; を付けるか、 &lt;code&gt;oct&lt;/code&gt; を使用して、それらを8進数として扱うようにPerlに指示する必要があります。</target>
        </trans-unit>
        <trans-unit id="ee36968e514e749df3ac1a70b3903aee1ab0ec1b" translate="yes" xml:space="preserve">
          <source>If you want to use threads, you should primarily use the Perl 5.8.0 threads model by running Configure with -Duseithreads.</source>
          <target state="translated">スレッドを使用したい場合は、Perl 5.8.0 のスレッドモデルを使用し、 Configure を -Duseithreads と実行してください。</target>
        </trans-unit>
        <trans-unit id="3a5e52fc579dc6791582e6cfe54da362246b660d" translate="yes" xml:space="preserve">
          <source>If you want to work with comma-separated values, don't do this since that format is a bit more complicated. Use one of the modules that handle that format, such as &lt;a href=&quot;Text::CSV&quot;&gt;Text::CSV&lt;/a&gt;, &lt;a href=&quot;Text::CSV_XS&quot;&gt;Text::CSV_XS&lt;/a&gt;, or &lt;a href=&quot;Text::CSV_PP&quot;&gt;Text::CSV_PP&lt;/a&gt;.</source>
          <target state="translated">カンマ区切りの値を使用する場合は、その形式が少し複雑になるため、これを行わないでください。などのモジュール、そのハンドルその形式、のいずれかを使用&lt;a href=&quot;Text::CSV&quot;&gt;テキスト:: CSV&lt;/a&gt;、&lt;a href=&quot;Text::CSV_XS&quot;&gt;テキスト:: CSV_XS&lt;/a&gt;、または&lt;a href=&quot;Text::CSV_PP&quot;&gt;テキスト:: CSV_PP&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f0b79aac4ab0e44b3e5cf20ea8795f9b26be612e" translate="yes" xml:space="preserve">
          <source>If you want to work with comma-separated values, don't do this since that format is a bit more complicated. Use one of the modules that handle that format, such as &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV&quot;&gt;Text::CSV&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_XS&quot;&gt;Text::CSV_XS&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_PP&quot;&gt;Text::CSV_PP&lt;/a&gt;.</source>
          <target state="translated">コンマで区切られた値を処理したい場合は、フォーマットを少し複雑にするため、これを行わないでください。などのモジュール、そのハンドルその形式、のいずれかを使用&lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV&quot;&gt;テキスト:: CSV&lt;/a&gt;、&lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_XS&quot;&gt;テキスト:: CSV_XS&lt;/a&gt;、または&lt;a href=&quot;http://search.cpan.org/perldoc/Text::CSV_PP&quot;&gt;テキスト:: CSV_PP&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1eaaa5db8078515a0b75d0e6992dfcf80e5ff6b" translate="yes" xml:space="preserve">
          <source>If you want to work with formatted dates, the &lt;a href=&quot;Date::Manip&quot;&gt;Date::Manip&lt;/a&gt;, &lt;a href=&quot;Date::Calc&quot;&gt;Date::Calc&lt;/a&gt;, or &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; modules can help you.</source>
          <target state="translated">フォーマットされた日付を操作する場合は、&lt;a href=&quot;Date::Manip&quot;&gt;Date :: Manip&lt;/a&gt;、&lt;a href=&quot;Date::Calc&quot;&gt;Date :: Calc&lt;/a&gt;、または&lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt;モジュールが役立ちます。</target>
        </trans-unit>
        <trans-unit id="37acc7e93925635a2960bac98f19ec762c55738f" translate="yes" xml:space="preserve">
          <source>If you want to work with formatted dates, the &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Manip&quot;&gt;Date::Manip&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt;, or &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; modules can help you.</source>
          <target state="translated">書式設定された日付を使用する場合は、&lt;a href=&quot;http://search.cpan.org/perldoc/Date::Manip&quot;&gt;Date :: Manip&lt;/a&gt;、&lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date :: Calc&lt;/a&gt;、または&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt;モジュールが役立ちます。</target>
        </trans-unit>
        <trans-unit id="c337db840462e094257c46f34c19710018f93799" translate="yes" xml:space="preserve">
          <source>If you want to write to an existing SV's buffer and set its value to a string, use SvPV_force() or one of its variants to force the SV to be a PV. This will remove any of various types of non-stringness from the SV while preserving the content of the SV in the PV. This can be used, for example, to append data from an API function to a buffer without extra copying:</source>
          <target state="translated">既存の SV のバッファに書き込み、その値を文字列に設定したい場合は、SvPV_force()またはその亜種の一つを使用して SV を強制的に PV にします。これにより、SV の内容を PV に保持しつつ、SV から様々なタイプの非文字列性を削除することができます。これは、例えば、API 関数からのデータを余分なコピーなしでバッファに追加するために使用することができます。</target>
        </trans-unit>
        <trans-unit id="17fab6cd5cfc4d3a8699ee4d492a9132990d5dbf" translate="yes" xml:space="preserve">
          <source>If you want to zap all predefined aliases, you can use</source>
          <target state="translated">定義済みのエイリアスをすべてザッピングしたい場合は</target>
        </trans-unit>
        <trans-unit id="6dad17422598919d77ad32018e1ee73ac029ac1c" translate="yes" xml:space="preserve">
          <source>If you want your code to be portable, your format (&lt;code&gt;fmt&lt;/code&gt; ) argument should use only the conversion specifiers defined by the ANSI C standard (C89, to play safe). These are &lt;code&gt;aAbBcdHIjmMpSUwWxXyYZ%&lt;/code&gt; . But even then, the &lt;b&gt;results&lt;/b&gt; of some of the conversion specifiers are non-portable. For example, the specifiers &lt;code&gt;aAbBcpZ&lt;/code&gt; change according to the locale settings of the user, and both how to set locales (the locale names) and what output to expect are non-standard. The specifier &lt;code&gt;c&lt;/code&gt; changes according to the timezone settings of the user and the timezone computation rules of the operating system. The &lt;code&gt;Z&lt;/code&gt; specifier is notoriously unportable since the names of timezones are non-standard. Sticking to the numeric specifiers is the safest route.</source>
          <target state="translated">コードを移植可能にしたい場合は、format（ &lt;code&gt;fmt&lt;/code&gt; ）引数でANSI C標準（C89、安全に再生する）で定義された変換指定子のみを使用する必要があります。これらは &lt;code&gt;aAbBcdHIjmMpSUwWxXyYZ%&lt;/code&gt; です。ただし、それでも、一部の変換指定子の&lt;b&gt;結果&lt;/b&gt;は移植できません。たとえば、指定子 &lt;code&gt;aAbBcpZ&lt;/code&gt; は、ユーザーのロケール設定に従って変化し、ロケール（ロケール名）の設定方法と期待される出力はどちらも非標準です。指定子 &lt;code&gt;c&lt;/code&gt; は、ユーザーのタイムゾーン設定とオペレーティングシステムのタイムゾーン計算規則に従って変化します。 &lt;code&gt;Z&lt;/code&gt; タイムゾーンの名前は標準ではないため、指定子は移植性がないことで有名です。数値指定子を使用するのが最も安全な方法です。</target>
        </trans-unit>
        <trans-unit id="45c7504bca4d1a8d8abed6fce6e884966dc05bc6" translate="yes" xml:space="preserve">
          <source>If you want your code to be portable, your format (&lt;code&gt;fmt&lt;/code&gt;) argument should use only the conversion specifiers defined by the ANSI C standard (C89, to play safe). These are &lt;code&gt;aAbBcdHIjmMpSUwWxXyYZ%&lt;/code&gt;. But even then, the &lt;b&gt;results&lt;/b&gt; of some of the conversion specifiers are non-portable. For example, the specifiers &lt;code&gt;aAbBcpZ&lt;/code&gt; change according to the locale settings of the user, and both how to set locales (the locale names) and what output to expect are non-standard. The specifier &lt;code&gt;c&lt;/code&gt; changes according to the timezone settings of the user and the timezone computation rules of the operating system. The &lt;code&gt;Z&lt;/code&gt; specifier is notoriously unportable since the names of timezones are non-standard. Sticking to the numeric specifiers is the safest route.</source>
          <target state="translated">コードを移植可能にする場合は、format（ &lt;code&gt;fmt&lt;/code&gt; ）引数で、ANSI C標準（C89、安全に再生するため）で定義されている変換指定子のみを使用する必要があります。これらは &lt;code&gt;aAbBcdHIjmMpSUwWxXyYZ%&lt;/code&gt; です。ただし、それでも、一部の変換指定子の&lt;b&gt;結果&lt;/b&gt;は移植できません。たとえば、指定子 &lt;code&gt;aAbBcpZ&lt;/code&gt; はユーザーのロケール設定に応じて変化し、ロケールの設定方法（ロケール名）と期待される出力の両方が非標準です。指定子 &lt;code&gt;c&lt;/code&gt; は、ユーザーのタイムゾーン設定とオペレーティングシステムのタイムゾーン計算ルールに従って変更されます。 &lt;code&gt;Z&lt;/code&gt; タイムゾーンの名前が非標準であるため、指定子は移植性がないことで有名です。数値指定子に固執するのが最も安全な方法です。</target>
        </trans-unit>
        <trans-unit id="b8922cb8873f110b4ceb1333b3f31e99ca5b2eb1" translate="yes" xml:space="preserve">
          <source>If you want your encoding to work with &lt;a href=&quot;../encoding&quot;&gt;encoding&lt;/a&gt; pragma, you should also implement the method below.</source>
          <target state="translated">エンコーディングを&lt;a href=&quot;../encoding&quot;&gt;エンコーディング&lt;/a&gt;プラグマと連動させる場合は、以下のメソッドも実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="f0a7770b35604635306837054c149681539eca02" translate="yes" xml:space="preserve">
          <source>If you want your encoding to work with &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; pragma, you should also implement the method below.</source>
          <target state="translated">エンコーディングを&lt;a href=&quot;encoding&quot;&gt;エンコーディング&lt;/a&gt;プラグマと連携させたい場合は、以下のメソッドも実装する必要があります。</target>
        </trans-unit>
        <trans-unit id="3bbf6500eb6902acebc3435f4b4dd55c522837bc" translate="yes" xml:space="preserve">
          <source>If you want your here-docs to be indented with the rest of the code, use the &lt;code&gt;&amp;lt;&amp;lt;~FOO&lt;/code&gt; construct described under &lt;a href=&quot;#Indented-Here-docs&quot;&gt;&quot;Indented Here-docs&quot;&lt;/a&gt;:</source>
          <target state="translated">here-docsを残りのコードでインデントする場合は、&lt;a href=&quot;#Indented-Here-docs&quot;&gt;「IndentedHere-docs」で&lt;/a&gt;説明されている &lt;code&gt;&amp;lt;&amp;lt;~FOO&lt;/code&gt; 構造を使用します。</target>
        </trans-unit>
        <trans-unit id="e7210c4e7ce82b46e9e62a14e14a71ab868752cc" translate="yes" xml:space="preserve">
          <source>If you want your here-docs to be indented with the rest of the code, you'll need to remove leading whitespace from each line manually:</source>
          <target state="translated">もし、heere-docs を残りのコードと一緒にインデントさせたい場合は、各行の先頭の空白を手動で削除する必要があります。</target>
        </trans-unit>
        <trans-unit id="eb763454ad4db2bd6193f7e99d444faca44a82eb" translate="yes" xml:space="preserve">
          <source>If you want your program to be compatible with versions of Perl before 5.20, you must use &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; instead. (In previous versions of Perl, the behavior of the statements &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'NONFATAL';&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; was unspecified; they did not behave as if they included the &lt;code&gt;=&amp;gt; 'all'&lt;/code&gt; portion. As of 5.20, they do.)</source>
          <target state="translated">プログラムに5.20より前のバージョンのPerlとの互換性を持たせたい場合は、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; 使用する必要があります。代わりに。（Perlの以前のバージョンでは、ステートメントの振る舞いが &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'NONFATAL';&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; warnings 'FATAL';&lt;/code&gt; 未指定だった;彼らが含まれているかのよう彼らは動作しませんでした &lt;code&gt;=&amp;gt; 'all'&lt;/code&gt; 部分を。5.20の時点でサポートされています。）</target>
        </trans-unit>
        <trans-unit id="2539f4ee77683fe9463e9a882a260d320b1f9535" translate="yes" xml:space="preserve">
          <source>If you want your program to be compatible with versions of Perl before 5.20, you must use &lt;code&gt;use warnings FATAL =&amp;gt; 'all';&lt;/code&gt; instead. (In previous versions of Perl, the behavior of the statements &lt;code&gt;use warnings 'FATAL';&lt;/code&gt;, &lt;code&gt;use warnings 'NONFATAL';&lt;/code&gt; and &lt;code&gt;no warnings 'FATAL';&lt;/code&gt; was unspecified; they did not behave as if they included the &lt;code&gt;=&amp;gt; 'all'&lt;/code&gt; portion. As of 5.20, they do.)</source>
          <target state="translated">プログラムを5.20より前のバージョンのPerlと互換性があるように &lt;code&gt;use warnings FATAL =&amp;gt; 'all';&lt;/code&gt; 使用を使用する必要がありますFATAL =&amp;gt; 'all';代わりに。 （Perlの以前のバージョンでは、文の動作が &lt;code&gt;use warnings 'FATAL';&lt;/code&gt; 、 &lt;code&gt;use warnings 'NONFATAL';&lt;/code&gt; と &lt;code&gt;no warnings 'FATAL';&lt;/code&gt; 未指定だった;彼らが含まれているかのよう彼らは動作しませんでした &lt;code&gt;=&amp;gt; 'all'&lt;/code&gt; 部分を。5.20の時点で、そうです。）</target>
        </trans-unit>
        <trans-unit id="3d68917c192fee56b1141df74b8f16f9fa5100fe" translate="yes" xml:space="preserve">
          <source>If you want, you may make low-level pipe() and fork() syscalls to stitch this together by hand. This example only talks to itself, but you could reopen the appropriate handles to STDIN and STDOUT and call other processes. (The following example lacks proper error checking.)</source>
          <target state="translated">必要であれば、低レベルの pipe()や fork()のシステムコールを作成して、これを手でつなぎ合わせることもできます。この例では自分自身としか話しませんが、STDIN や STDOUT に適切なハンドルを開いて他のプロセスを呼び出すことができます。(以下の例では、適切なエラーチェックを欠いています)。</target>
        </trans-unit>
        <trans-unit id="9a78398c052f882736bece8b1553a1b8e0dc056b" translate="yes" xml:space="preserve">
          <source>If you wanted just to append to a row, you'd have to do something a bit funnier looking:</source>
          <target state="translated">行に追加するだけなら、もう少し見た目が楽しいものにしないと。</target>
        </trans-unit>
        <trans-unit id="2260da4124856b0020df29775382e24cb7c28087" translate="yes" xml:space="preserve">
          <source>If you wanted text and not lines, you would use</source>
          <target state="translated">行ではなくテキストにしたい場合は、次のようにします。</target>
        </trans-unit>
        <trans-unit id="b649b444ce3825b2b868566f3609222a2cd25baa" translate="yes" xml:space="preserve">
          <source>If you wanted the commas preserved as separate fields (i.e. like split does if your split pattern has capturing parentheses), you would just make the last parameter undefined (or remove it).</source>
          <target state="translated">カンマを別のフィールドとして保存したい場合 (つまり、分割パターンにキャプチャ用の括弧がある場合の split のように)、最後のパラメータを未定義にする (または削除する)だけです。</target>
        </trans-unit>
        <trans-unit id="5fba67ea1fbf1509f7d61f0bae5321559a412330" translate="yes" xml:space="preserve">
          <source>If you wanted to do the same thing for lines, you wouldn't need a regular expression:</source>
          <target state="translated">行に対しても同じことをしたいのであれば、正規表現は必要ないでしょう。</target>
        </trans-unit>
        <trans-unit id="ed640c7d7a4ae2cd65ac815fdaa4ce3af7479470" translate="yes" xml:space="preserve">
          <source>If you wanted to have a $ref_to_AoA variable as a reference to an array, you'd have to do something like this:</source>
          <target state="translated">変数 $ref_to_AoA を配列への参照として使用したい場合は、次のようにしなければなりません。</target>
        </trans-unit>
        <trans-unit id="fed8c5d580fcbca1e699420a58d9ad3cd67321fd" translate="yes" xml:space="preserve">
          <source>If you wanted to keep track of subscripts, you might do this:</source>
          <target state="translated">購読者を記録しておきたい場合はこうするといいかもしれません。</target>
        </trans-unit>
        <trans-unit id="fbf69379e2b3dc67cd59111850ee63e9c65dd9db" translate="yes" xml:space="preserve">
          <source>If you wanted to see the inverse tables, you would first have to sort on the desired numbers column as in recipes 4, 5 or 6, then take the output of the first numbers column.</source>
          <target state="translated">逆表を見たい場合は、まずレシピ4,5,6のように希望する数字列でソートし、最初の数字列の出力を取る必要があります。</target>
        </trans-unit>
        <trans-unit id="1d598a9db20ad75da95def7772f5c1aab9645a1d" translate="yes" xml:space="preserve">
          <source>If you were into Schwartzian Transforms, you would probably have selected map for that</source>
          <target state="translated">もしあなたがシュバルツ変換に興味を持っていたら、そのためにマップを選択していたでしょう。</target>
        </trans-unit>
        <trans-unit id="ad840be29267c1ff305e523c8e88cf5317d35dc5" translate="yes" xml:space="preserve">
          <source>If you were to set &lt;code&gt;$b[3] = 4&lt;/code&gt; , then instead of reporting that &quot;a and b are deep copies of each other&quot;, it now reports that &lt;code&gt;&quot;b smartmatches in a&quot;&lt;/code&gt; . That's because the corresponding position in &lt;code&gt;@a&lt;/code&gt; contains an array that (eventually) has a 4 in it.</source>
          <target state="translated">&lt;code&gt;$b[3] = 4&lt;/code&gt; を設定した場合、「aとbは互いのディープコピーである」と報告するのではなく、 &lt;code&gt;&quot;b smartmatches in a&quot;&lt;/code&gt; 報告するようになりました。これは、 &lt;code&gt;@a&lt;/code&gt; の対応する位置に、（最終的に）4を持つ配列が含まれているためです。</target>
        </trans-unit>
        <trans-unit id="e625042d34a802ff63347451c799c769cd7bb028" translate="yes" xml:space="preserve">
          <source>If you were to set &lt;code&gt;$b[3] = 4&lt;/code&gt;, then instead of reporting that &quot;a and b are deep copies of each other&quot;, it now reports that &lt;code&gt;&quot;b smartmatches in a&quot;&lt;/code&gt;. That's because the corresponding position in &lt;code&gt;@a&lt;/code&gt; contains an array that (eventually) has a 4 in it.</source>
          <target state="translated">&lt;code&gt;$b[3] = 4&lt;/code&gt; に設定した場合、「aとbはお互いのディープコピーである」と報告する代わりに、 &lt;code&gt;&quot;b smartmatches in a&quot;&lt;/code&gt; 報告するようになりました。これは、 &lt;code&gt;@a&lt;/code&gt; の対応する位置に、（最終的には）4が含まれる配列が含まれているためです。</target>
        </trans-unit>
        <trans-unit id="25e66b6a4d3408c5b81e396702004bd84b8fbf9d" translate="yes" xml:space="preserve">
          <source>If you wish to compile with the Socket extension, you need to have the TCP/IP toolkit, and you need to make sure that -lsocket locates the correct copy of socket3r.lib. Beware that the Watcom compiler ships with a stub version of socket3r.lib which has very little functionality. Also beware the order in which wlink searches directories for libraries. You may have /usr/lib/socket3r.lib pointing to the correct library, but wlink may pick up /usr/watcom/10.6/usr/lib/socket3r.lib instead. Make sure they both point to the correct library, that is, /usr/tcptk/current/usr/lib/socket3r.lib.</source>
          <target state="translated">Socket 拡張機能を使ってコンパイルしたい場合は、TCP/IP ツールキットが必要で、-lsocket が正しい socket3r.lib のコピーを見つけることを確認する必要があります。Watcom コンパイラは、ほとんど機能を持たない socket3r.lib のスタブ版を出荷していることに注意してください。また、wlink がライブラリのディレクトリを検索する順番にも注意してください。/usr/lib/socket3r.lib が正しいライブラリを指しているかもしれませんが、wlink は /usr/watcom/10.6/usr/lib/socket3r.lib の代わりに /usr/watcom/10.6/usr/lib/socket3r.lib を拾ってくるかもしれません。両方とも正しいライブラリ、つまり /usr/tcptk/current/usr/lib/socket3r.lib を指していることを確認してください。</target>
        </trans-unit>
        <trans-unit id="743a9842bd7eb1c587a8ceb73e47cc40eff3e0ec" translate="yes" xml:space="preserve">
          <source>If you wish to install perl versions for all architectures (68020, mips, sparc and 386) run:</source>
          <target state="translated">すべてのアーキテクチャ (68020,mips,sparc,386)に perl のバージョンをインストールしたい場合は、以下を実行してください。</target>
        </trans-unit>
        <trans-unit id="8c3f20eaf91a5deff73dd9c45659c91402df0ac2" translate="yes" xml:space="preserve">
          <source>If you wish to supply an alternative debugger for Perl to run, invoke your script with a colon and a package argument given to the &lt;b&gt;-d&lt;/b&gt; flag. Perl's alternative debuggers include a Perl profiler, &lt;a href=&quot;Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt;, which is available separately as a CPAN distribution. To profile your Perl program in the file</source>
          <target state="translated">Perlを実行するための代替デバッガーを提供する場合は、コロンと&lt;b&gt;-d&lt;/b&gt;フラグに指定されたパッケージ引数を使用してスクリプトを呼び出します。Perlの代替デバッガーには、Perlプロファイラーである&lt;a href=&quot;Devel::NYTProf&quot;&gt;Devel :: NYTProf&lt;/a&gt;が含まれています。これは、CPANディストリビューションとして個別に入手できます。ファイル内のPerlプログラムをプロファイリングするには</target>
        </trans-unit>
        <trans-unit id="fe0f0e4408b545cb1ecebca491d9be266bb67e8f" translate="yes" xml:space="preserve">
          <source>If you wish to supply an alternative debugger for Perl to run, invoke your script with a colon and a package argument given to the &lt;b&gt;-d&lt;/b&gt; flag. Perl's alternative debuggers include a Perl profiler, &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt;, which is available separately as a CPAN distribution. To profile your Perl program in the file</source>
          <target state="translated">Perlを実行するための代替デバッガーを提供する場合は、&lt;b&gt;-d&lt;/b&gt;フラグにコロンとパッケージ引数を指定してスクリプトを呼び出します。Perlの代替デバッガーには、Perlプロファイラー&lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel :: NYTProf&lt;/a&gt;が含まれています。これは、CPANディストリビューションとして個別に入手できます。ファイル内のPerlプログラムをプロファイルするには</target>
        </trans-unit>
        <trans-unit id="b105ef1f647cb2687215fb2803b65285f6c51529" translate="yes" xml:space="preserve">
          <source>If you wish to turn an entire POD document into a parse-tree, that process is fairly straightforward. The &lt;b&gt;parse_text()&lt;/b&gt; method is the key to doing this successfully. Every paragraph-callback (i.e. the polymorphic methods for &lt;b&gt;command()&lt;/b&gt;, &lt;b&gt;verbatim()&lt;/b&gt;, and &lt;b&gt;textblock()&lt;/b&gt; paragraphs) takes a &lt;b&gt;Pod::Paragraph&lt;/b&gt; object as an argument. Each paragraph object has a &lt;b&gt;parse_tree()&lt;/b&gt; method that can be used to get or set a corresponding parse-tree. So for each of those paragraph-callback methods, simply call &lt;b&gt;parse_text()&lt;/b&gt; with the options you desire, and then use the returned parse-tree to assign to the given paragraph object.</source>
          <target state="translated">PODドキュメント全体を解析ツリーに変換したい場合、そのプロセスはかなり簡単です。&lt;b&gt;parse_text（）&lt;/b&gt;メソッドが正常にこれを実行するための鍵です。すべての段落コールバック（つまり、&lt;b&gt;command（）&lt;/b&gt;、&lt;b&gt;verbatim（）&lt;/b&gt;、および&lt;b&gt;textblock（）&lt;/b&gt;段落のポリモーフィックメソッド）は、引数として&lt;b&gt;Pod :: Paragraph&lt;/b&gt;オブジェクトを取ります。各段落オブジェクトには、対応する解析ツリーを取得または設定するために使用できる&lt;b&gt;parse_tree（）&lt;/b&gt;メソッドがあります。したがって、これらの段落コールバックメソッドのそれぞれについて、必要なオプションを指定して&lt;b&gt;parse_text（）&lt;/b&gt;を呼び出し、返された解析ツリーを使用して、指定された段落オブジェクトに割り当てます。</target>
        </trans-unit>
        <trans-unit id="77c82d86f4fb285fcd145d9c870b966041509421" translate="yes" xml:space="preserve">
          <source>If you wish to use GNU ld, then you need to pass it the -Wl,-E flag. The hints/solaris_2.sh file tries to do this automatically by setting the following Configure variables:</source>
          <target state="translated">GNU ldを使いたい場合は、-Wl,-Eフラグを渡す必要があります。hints/solaris_2.shファイルは、以下のConfigure変数を設定することで自動的にこれを行おうとします。</target>
        </trans-unit>
        <trans-unit id="5c10ef4b4d7cf77ba9367b0a5ba13535a2314b3d" translate="yes" xml:space="preserve">
          <source>If you wish to use gcc to build add-on modules for use with the perl shipped with Solaris, you should use the Solaris::PerlGcc module which is available from CPAN. The perl shipped with Solaris is configured and built with the Sun compilers, and the compiler configuration information stored in Config.pm is therefore only relevant to the Sun compilers. The Solaris:PerlGcc module contains a replacement Config.pm that is correct for gcc - see the module for details.</source>
          <target state="translated">Solaris に同梱されている perl で使用するアドオンモジュールを構築するために gcc を使用したい場合は、CPAN から入手可能な Solaris::PerlGcc モジュールを使用する必要があります。Solaris に同梱されている perl は Sun コンパイラで構成およびビルドされているため、Config.pm に保存されているコンパイラ構成情報は Sun コンパイラにのみ関連しています。Solaris:PerlGcc モジュールには、gcc 用に正しい代替 Config.pm が含まれています。</target>
        </trans-unit>
        <trans-unit id="461c22560c9b4e2d096c9a209fc41fbc9b8e1805" translate="yes" xml:space="preserve">
          <source>If you wonder what complex numbers are, they were invented to be able to solve the following equation:</source>
          <target state="translated">複素数ってなんだろうと思ったら、次の式を解けるように発明されたんですね。</target>
        </trans-unit>
        <trans-unit id="58f2be2cb41014bdf8c7d1f6da3d5ed7b3a57878" translate="yes" xml:space="preserve">
          <source>If you wonder why defaults for conversion are different for str() and num(), note how easy it was to write the symbolic calculator. This simplicity is due to an appropriate choice of defaults. One extra note: due to the explicit recursion num() is more fragile than sym(): we need to explicitly check for the type of $a and $b. If components $a and $b happen to be of some related type, this may lead to problems.</source>
          <target state="translated">なぜ str()と num()で変換のデフォルトが異なるのかと思ったら、 記号計算機を書くのがいかに簡単だったかに注目してください。このシンプルさは、適切なデフォルトの選択によるものです。もうひとつ注意点があります:明示的な再帰のため、 num()は sym()よりも壊れやすいです。コンポーネント $a と $b がたまたま関連する型であった場合、問題が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="f88d82472c17285676b32563ec0b930b79f27b19" translate="yes" xml:space="preserve">
          <source>If you would like to know about a version dependency before you start running the program, put something like this at its top:</source>
          <target state="translated">プログラムを実行する前にバージョン依存関係を知りたい場合は、プログラムの先頭に次のような記述をしてください。</target>
        </trans-unit>
        <trans-unit id="c3bc63e78a724b45aa4c8fcf7d5d3a90c3663440" translate="yes" xml:space="preserve">
          <source>If you would like to print out a lot of man page continuously, you probably want to set the C and D registers to set contiguous page numbering and even/odd paging, at least on some versions of man(7).</source>
          <target state="translated">もし、大量の man ページを連続して印刷したいのであれば、少なくともいくつかのバージョンの man(7)では、C と D レジスタに連続ページ番号と偶数/奇数ページングを設定したいと思うでしょう。</target>
        </trans-unit>
        <trans-unit id="47a4a5157ecac47010f3fc4d031a714df9cdb1ae" translate="yes" xml:space="preserve">
          <source>If you would like, you can pass in a hashref instead of pairs. When you do so the hashref will be copied, and the copy will be returned blessed as an object. There is no way to ask HashBase to bless a specific hashref.</source>
          <target state="translated">必要であれば、ペアの代わりにハッシュリフを渡すことができます。そうするとハッシュrefがコピーされ、そのコピーはオブジェクトとして祝福されて返されます。特定のハッシュrefを祝福するようにHashBaseに求める方法はありません。</target>
        </trans-unit>
        <trans-unit id="4e270feabb28d65fb97bce6b5a62077129b3eed4" translate="yes" xml:space="preserve">
          <source>If you would rather see it in CCSID 1047 order then change the number 34 in the last line to 39, like this:</source>
          <target state="translated">もしCCSID 1047の順番で見たいのであれば、最後の行の34を39に変更してください。</target>
        </trans-unit>
        <trans-unit id="7ab3cc4dd9f42b386f286d85d40432c48d4dbc0d" translate="yes" xml:space="preserve">
          <source>If you would rather see it in POSIX-BC order then change the number 34 in the last line to 44, like this:</source>
          <target state="translated">POSIX-BC順で見たい場合は、最後の行の34を44に変更してください。</target>
        </trans-unit>
        <trans-unit id="4685079e88ddb435b412b9c5b1c049410dc612d3" translate="yes" xml:space="preserve">
          <source>If you would rather see the above table in CCSID 0037 order rather than ASCII + Latin-1 order then run the table through:</source>
          <target state="translated">もし上記のテーブルをASCII+Latin-1の順ではなく、CCSID 0037の順で見たいのであれば、このテーブルを実行してください。</target>
        </trans-unit>
        <trans-unit id="32ccbee06ab47d2346ade36365b388768fa75f8c" translate="yes" xml:space="preserve">
          <source>If you would rather see this table listing hexadecimal values then run the table through:</source>
          <target state="translated">16進数の値のリストを見たい場合は、このテーブルを実行してください。</target>
        </trans-unit>
        <trans-unit id="ee951a76c16a66932dc3802ba31a24c5d5d45366" translate="yes" xml:space="preserve">
          <source>If you write just &lt;code&gt;[]&lt;/code&gt; , you get a new, empty anonymous array. If you write just &lt;code&gt;{}&lt;/code&gt; , you get a new, empty anonymous hash.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; だけを記述すると、新しい空の無名配列が作成されます。 &lt;code&gt;{}&lt;/code&gt; だけを書くと、新しい空の匿名ハッシュが得られます。</target>
        </trans-unit>
        <trans-unit id="4638b3569a9b4f06615d1c5e8e4772e5510c4692" translate="yes" xml:space="preserve">
          <source>If you write just &lt;code&gt;[]&lt;/code&gt;, you get a new, empty anonymous array. If you write just &lt;code&gt;{}&lt;/code&gt;, you get a new, empty anonymous hash.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; だけを書くと、新しい空の匿名配列が得られます。 &lt;code&gt;{}&lt;/code&gt; だけを書くと、新しい空の匿名ハッシュが得られます。</target>
        </trans-unit>
        <trans-unit id="6e5ce930a64c177374e0a87543a2b84b1ca0633d" translate="yes" xml:space="preserve">
          <source>If you write your own test, use the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2ftestanything.org&quot;&gt;Test Anything Protocol&lt;/a&gt;.</source>
          <target state="translated">独自のテストを作成する場合は、&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2ftestanything.org&quot;&gt;Test Anything Protocolを&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="7e006dae20780e3ea05d021931a4db8875b19d01" translate="yes" xml:space="preserve">
          <source>If you write your own test, use the &lt;a href=&quot;https://testanything.org&quot;&gt;Test Anything Protocol&lt;/a&gt;.</source>
          <target state="translated">独自のテストを作成する場合は、&lt;a href=&quot;https://testanything.org&quot;&gt;Test AnythingProtocolを&lt;/a&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="b4b7f29b396f8216559006548d8b8987bccc01b5" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a C or C++ programmer, you might be looking for Perl&amp;rsquo;s &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword.</source>
          <target state="translated">CまたはC ++プログラマーであれば、Perlの &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; キーワードを探しているかもしれません。</target>
        </trans-unit>
        <trans-unit id="6c0a86670223bfdb26cb68751ec4a4f37f760ea9" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a C or C++ programmer, you might be looking for Perl&amp;rsquo;s &lt;code&gt;state&lt;/code&gt; keyword.</source>
          <target state="translated">CまたはC ++プログラマーの場合は、Perlの &lt;code&gt;state&lt;/code&gt; キーワードを探している可能性があります。</target>
        </trans-unit>
        <trans-unit id="65480a92112439353360a0f2410e7e3031db6948" translate="yes" xml:space="preserve">
          <source>If you'd like a graphical user interface and you have &lt;a href=&quot;http://search.cpan.org/perldoc/Tk&quot;&gt;Tk&lt;/a&gt;, you can use &lt;code&gt;ptkdb&lt;/code&gt; . It's on CPAN and available for free.</source>
          <target state="translated">グラフィカルユーザーインターフェイスが必要で&lt;a href=&quot;http://search.cpan.org/perldoc/Tk&quot;&gt;Tk&lt;/a&gt;がある場合は、 &lt;code&gt;ptkdb&lt;/code&gt; を使用できます。CPANにあり、無料で利用できます。</target>
        </trans-unit>
        <trans-unit id="6666466d25080d49716b3f38912878857c8e62b2" translate="yes" xml:space="preserve">
          <source>If you'd like a graphical user interface and you have &lt;a href=&quot;tk&quot;&gt;Tk&lt;/a&gt;, you can use &lt;code&gt;ptkdb&lt;/code&gt;. It's on CPAN and available for free.</source>
          <target state="translated">グラフィカルユーザーインターフェイスが必要で、&lt;a href=&quot;tk&quot;&gt;Tk&lt;/a&gt;がある場合は、 &lt;code&gt;ptkdb&lt;/code&gt; を使用できます。CPANにあり、無料で利用できます。</target>
        </trans-unit>
        <trans-unit id="c82ff6955ec720dbffdb6e597947e26e8c52b3d3" translate="yes" xml:space="preserve">
          <source>If you'd like to disable the use of one or more of these utilities and/or modules, see the &lt;code&gt;$BLACKLIST&lt;/code&gt; variable further down.</source>
          <target state="translated">これらのユーティリティやモジュールの使用を無効にしたい場合は、さらに下の &lt;code&gt;$BLACKLIST&lt;/code&gt; 変数を参照してください。</target>
        </trans-unit>
        <trans-unit id="2745d17cd01ce3bb020e0554868598f0ea306839" translate="yes" xml:space="preserve">
          <source>If you'd like to make &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt; (and many other bits of Perl) die on error, have a look at the &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; pragma.</source>
          <target state="translated">&lt;a href=&quot;#system-LIST&quot;&gt; &lt;code&gt;system&lt;/code&gt; &lt;/a&gt;（およびPerlの他の多くのビット）をエラーで終了させたい場合は、&lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt;プラグマを参照してください。</target>
        </trans-unit>
        <trans-unit id="52486225415552ac3d601c87ba41d238a14d5679" translate="yes" xml:space="preserve">
          <source>If you'd like to make &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; (and many other bits of Perl) die on error, have a look at the &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; pragma.</source>
          <target state="translated">あなたが作るしたい場合 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; （Perlは、他の多くのビット）を、エラー時に死んで見てい&lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt;プラグマを。</target>
        </trans-unit>
        <trans-unit id="1efbce8f9e88ed4ba8cc94bb84af468b14e5c10a" translate="yes" xml:space="preserve">
          <source>If you'd like to make &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; (and many other bits of Perl) die on error, have a look at the &lt;a href=&quot;../autodie&quot;&gt;autodie&lt;/a&gt; pragma.</source>
          <target state="translated">あなたが作るしたい場合 &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; （Perlは、他の多くのビット）を、エラー時に死んで見てい&lt;a href=&quot;../autodie&quot;&gt;autodie&lt;/a&gt;プラグマを。</target>
        </trans-unit>
        <trans-unit id="31f9c1e59db4aaf2455c75e99d8c0e4aa26479c4" translate="yes" xml:space="preserve">
          <source>If you'd like to manually inspect &lt;a href=&quot;#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt;'s failure, you can check all possible failure modes by inspecting &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; like this:</source>
          <target state="translated">&lt;a href=&quot;#system-LIST&quot;&gt; &lt;code&gt;system&lt;/code&gt; &lt;/a&gt;の障害を手動で検査したい場合は、&lt;a href=&quot;perlvar#%24%3F&quot;&gt; &lt;code&gt;$?&lt;/code&gt; を&lt;/a&gt;検査することで考えられるすべての障害モードを確認できます。このような：</target>
        </trans-unit>
        <trans-unit id="73a95e0734804b8dcc4d934eb0b4ac64271a89fa" translate="yes" xml:space="preserve">
          <source>If you'd like to manually inspect &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s failure, you can check all possible failure modes by inspecting &lt;code&gt;$?&lt;/code&gt; like this:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; の障害を手動で検査したい場合は、 &lt;code&gt;$?&lt;/code&gt; を検査して、考えられるすべての障害モードを確認できます。このような：</target>
        </trans-unit>
        <trans-unit id="c50262b9b752d6c3a022a1f95bc5efa143b999d6" translate="yes" xml:space="preserve">
          <source>If you'd like to manually inspect &lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;'s failure, you can check all possible failure modes by inspecting &lt;code&gt;$?&lt;/code&gt; like this:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; の障害を手動で検査したい場合は、 &lt;code&gt;$?&lt;/code&gt; を検査して、考えられるすべての障害モードを確認できます。このような：</target>
        </trans-unit>
        <trans-unit id="b7d0d2c6ab654703248e935ebd07682399b01f80" translate="yes" xml:space="preserve">
          <source>If you'd like to see the raw output of your tests, set the &lt;code&gt;TEST_VERBOSE&lt;/code&gt; variable to true.</source>
          <target state="translated">テストの生の出力を確認する場合は、 &lt;code&gt;TEST_VERBOSE&lt;/code&gt; 変数をtrueに設定します。</target>
        </trans-unit>
        <trans-unit id="15cb39149b7ad3616c39f88b2becd39a6aed03b0" translate="yes" xml:space="preserve">
          <source>If you'd rather treat each line individually, you can do that, too, by just transforming them in-place in the code reference and returning &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. Say that you don't want</source>
          <target state="translated">各行を個別に処理する場合も、コード参照でインプレースで変換して &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返すだけで、それを行うことができます。あなたがしたくないと言う</target>
        </trans-unit>
        <trans-unit id="6e65ba1455e726ff251279d7a46229f815e23af8" translate="yes" xml:space="preserve">
          <source>If you'd rather treat each line individually, you can do that, too, by just transforming them in-place in the code reference and returning &lt;code&gt;undef&lt;/code&gt;. Say that you don't want</source>
          <target state="translated">各行を個別に処理したい場合は、コード参照のインプレースで変換して &lt;code&gt;undef&lt;/code&gt; を返すだけで、それを行うこともできます。あなたがしたくないと言う</target>
        </trans-unit>
        <trans-unit id="a6c0d6d1d9d7ffd617e3fd0512c67d0a724859e3" translate="yes" xml:space="preserve">
          <source>If you're a plugin author, you'll be interested in how to &lt;a href=&quot;#register_handler&quot;&gt;&quot;register_handler&quot;&lt;/a&gt;s, how &lt;a href=&quot;#detect_source&quot;&gt;&quot;detect_source&quot;&lt;/a&gt; works.</source>
          <target state="translated">プラグインの作成者であれば、&lt;a href=&quot;#register_handler&quot;&gt;「register_handler」&lt;/a&gt;の方法、&lt;a href=&quot;#detect_source&quot;&gt;「detect_source」の&lt;/a&gt;しくみに興味があるでしょう。</target>
        </trans-unit>
        <trans-unit id="ffd95bdd9903099e5f9ecacdcf9a08a9aec1e1ad" translate="yes" xml:space="preserve">
          <source>If you're a plugin author, you'll be interested in how to &lt;a href=&quot;#register_handler&quot;&gt;register_handler&lt;/a&gt;s, how &lt;a href=&quot;#detect_source&quot;&gt;detect_source&lt;/a&gt; works.</source>
          <target state="translated">プラグインの作成者であれば、&lt;a href=&quot;#register_handler&quot;&gt;register_handler&lt;/a&gt;の方法、&lt;a href=&quot;#detect_source&quot;&gt;detect_sourceの&lt;/a&gt;動作に興味があります。</target>
        </trans-unit>
        <trans-unit id="ec02db45e6d3a34d0a303395b0efb8490d821d7c" translate="yes" xml:space="preserve">
          <source>If you're committed to creating a temporary file by hand, use the process ID and/or the current time-value. If you need to have many temporary files in one process, use a counter:</source>
          <target state="translated">テンポラリファイルを手作業で作成することにコミットしている場合は、プロセスIDおよび/または現在の時間値を使用します。1つのプロセス内に多数の一時ファイルが必要な場合は、カウンタを使用します。</target>
        </trans-unit>
        <trans-unit id="6a57c8d5168852184b3e7f9eacd5e84a511755f4" translate="yes" xml:space="preserve">
          <source>If you're concerned about 8-bit textual data then see &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;. If you want to deal with multibyte characters, however, there are some gotchas. See the section on Regular Expressions.</source>
          <target state="translated">8ビットのテキストデータが気になる場合は、&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;を参照してください。ただし、マルチバイト文字を扱いたい場合は、いくつかの落とし穴があります。正規表現のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="a4a17aeb59ac658e17124a0d2eb0b805c011e3c8" translate="yes" xml:space="preserve">
          <source>If you're concerned about people profiting from your code, then the bottom line is that nothing but a restrictive license will give you legal security. License your software and pepper it with threatening statements like &quot;This is unpublished proprietary software of XYZ Corp. Your access to it does not give you permission to use it blah blah blah.&quot; We are not lawyers, of course, so you should see a lawyer if you want to be sure your license's wording will stand up in court.</source>
          <target state="translated">あなたのコードから利益を得ている人々のことを心配しているのであれば、要は、制限的なライセンス以外の何物でもないことが、あなたに法的な安全性を与えるということです。あなたのソフトウェアにライセンスを与え、「これはXYZ Corp.の未発表のプロプライエタリなソフトウェアです。それへのあなたのアクセスは、それを使用するための許可を与えていません blah blah blah blah&quot; 私たちはもちろん弁護士ではありませんので、ライセンスの文言が法廷で通用するかどうかを確認したい場合は、弁護士に相談してください。</target>
        </trans-unit>
        <trans-unit id="20f5afeb7883b43b071ad0d90c989471842051d6" translate="yes" xml:space="preserve">
          <source>If you're concerned about people profiting from your code, then the bottom line is that nothing but a restrictive license will give you legal security. License your software and pepper it with threatening statements like &quot;This is unpublished proprietary software of XYZ Corp. Your access to it does not give you permission to use it blah blah blah.&quot; You should see a lawyer to be sure your license's wording will stand up in court.</source>
          <target state="translated">あなたのコードから利益を得ている人々のことを心配しているのであれば、要は、制限的なライセンス以外の何物でもないことが、あなたに法的な安全性を与えるということです。あなたのソフトウェアにライセンスを与え、「これはXYZ Corp.の未発表のプロプライエタリなソフトウェアです。それへのあなたのアクセスは、それを使用するための許可を与えていません blah blah blah blah.&quot; あなたのライセンスの言葉遣いが法廷で通用するかどうかを確認するために、弁護士に相談してください。</target>
        </trans-unit>
        <trans-unit id="28d412e72884dbac279b68cd8636bc53150a9095" translate="yes" xml:space="preserve">
          <source>If you're confused about why you use an '@' there on a hash slice instead of a '%', think of it like this. The type of bracket (square or curly) governs whether it's an array or a hash being looked at. On the other hand, the leading symbol ('$' or '@') on the array or hash indicates whether you are getting back a singular value (a scalar) or a plural one (a list).</source>
          <target state="translated">なぜハッシュスライスで '%' の代わりに '@' を使うのかについて混乱しているのであれば、次のように考えてみてください。括弧のタイプ(四角か巻き字か)によって、それが配列なのかハッシュなのかが決まります。一方、配列やハッシュの先頭の記号 ('$' や '@')は、単数形の値 (スカラ)を返すのか複数形の値 (リスト)を返すのかを示します。</target>
        </trans-unit>
        <trans-unit id="2fdaeb94f7920871da7274b75b49a557aeabaf4a" translate="yes" xml:space="preserve">
          <source>If you're creating a completely new result</source>
          <target state="translated">全く新しい結果を作成する場合</target>
        </trans-unit>
        <trans-unit id="6e2a7b543e2f454e92700f7b1967ab94c4b894e7" translate="yes" xml:space="preserve">
          <source>If you're currently linking your perl executable to a shared</source>
          <target state="translated">現在、Perl の実行ファイルを共有の</target>
        </trans-unit>
        <trans-unit id="5ae9e7742fc3a996e99839cc61f7b8352d875d18" translate="yes" xml:space="preserve">
          <source>If you're debugging a script that uses #!, and normally relies on the shell's $PATH search, the -S option causes perl to do that search, so you don't have to type the path or &lt;code&gt;`which $scriptname`&lt;/code&gt; .</source>
          <target state="translated">＃！を使用するスクリプトをデバッグしていて、通常はシェルの$ PATH検索に依存している場合、-Sオプションを指定するとperlがその検索を実行するため、パスや &lt;code&gt;`which $scriptname`&lt;/code&gt; を入力する必要はありません。</target>
        </trans-unit>
        <trans-unit id="51555a51b8314a910d76003d95e2f0fdc40d94bc" translate="yes" xml:space="preserve">
          <source>If you're debugging a script that uses #!, and normally relies on the shell's $PATH search, the -S option causes perl to do that search, so you don't have to type the path or &lt;code&gt;`which $scriptname`&lt;/code&gt;.</source>
          <target state="translated">＃！を使用するスクリプトをデバッグしていて、通常はシェルの$ PATH検索に依存している場合、-Sオプションを使用するとperlがその検索を実行するため、パスや &lt;code&gt;`which $scriptname`&lt;/code&gt; を入力する必要はありません。</target>
        </trans-unit>
        <trans-unit id="c253632d224aa0744dad2b2922eca154c4278dec" translate="yes" xml:space="preserve">
          <source>If you're deprecating a feature with the intent of later simplifying another bit of code, say so. If you're fixing a performance problem or adding a new feature to support some other bit of the core, mention that.</source>
          <target state="translated">後で別のコードを単純化することを意図して機能を廃止する場合は、そう言ってください。パフォーマンスの問題を修正したり、コアの他の部分をサポートするために新しい機能を追加したりする場合は、その旨を述べてください。</target>
        </trans-unit>
        <trans-unit id="b41a3856c0dbc6e888db5696272009c4533b95af" translate="yes" xml:space="preserve">
          <source>If you're developing a CPAN distribution using XS, you may add your own file called</source>
          <target state="translated">XSを使ってCPANのディストリビューションを開発している場合は、独自の</target>
        </trans-unit>
        <trans-unit id="897c140e9db65d769b3515a8af2bf69889950440" translate="yes" xml:space="preserve">
          <source>If you're getting this error from a here-document, you may have included unseen whitespace before or after your closing tag or there may not be a linebreak after it. A good programmer's editor will have a way to help you find these characters (or lack of characters). See &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for the full details on here-documents.</source>
          <target state="translated">ヒアドキュメントからこのエラーが発生した場合は、終了タグの前後に見えない空白が含まれているか、改行がない可能性があります。優れたプログラマーのエディターには、これらの文字（または文字の欠如）を見つけるのに役立つ方法があります。here-documentsの詳細については、&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="a4fd5cbfd79a1c891c020d447f65eef0d65886a8" translate="yes" xml:space="preserve">
          <source>If you're going to put your Pod at the end of the file, and you're using an &lt;code&gt;__END__&lt;/code&gt; or &lt;code&gt;__DATA__&lt;/code&gt; cut mark, make sure to put an empty line there before the first Pod command.</source>
          <target state="translated">あなたはファイルの最後にあなたのポッドを置くつもりだ、とあなたが使用している場合は &lt;code&gt;__END__&lt;/code&gt; や &lt;code&gt;__DATA__&lt;/code&gt; カットマークを、最初のポッドコマンドの前に空行が置くことを確認してください。</target>
        </trans-unit>
        <trans-unit id="0fef8c8a09918fb182d2a0653d091964fe4d5654" translate="yes" xml:space="preserve">
          <source>If you're in a slow syscall (like &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;ing, &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt;ing, or &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;ing from your keyboard or a socket) and haven't set up your own &lt;code&gt;$SIG{INT}&lt;/code&gt; handler, then you won't be able to CTRL-C your way back to the debugger, because the debugger's own &lt;code&gt;$SIG{INT}&lt;/code&gt; handler doesn't understand that it needs to raise an exception to longjmp(3) out of slow syscalls.</source>
          <target state="translated">遅いsyscall（ &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt; 、またはキーボードやソケットからの &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; など）を実行していて、独自の &lt;code&gt;$SIG{INT}&lt;/code&gt; ハンドラーを設定していない場合、CTRLを実行できません。 -Cデバッガに戻る方法。デバッガの独自の &lt;code&gt;$SIG{INT}&lt;/code&gt; ハンドラは、遅いシステムコールからlongjmp（3）に例外を発生させる必要があることを理解していないためです。</target>
        </trans-unit>
        <trans-unit id="d57cc5349a6b3818d37de5b1a80ef5bad92c827e" translate="yes" xml:space="preserve">
          <source>If you're in a slow syscall (like &lt;code&gt;wait&lt;/code&gt;ing, &lt;code&gt;accept&lt;/code&gt;ing, or &lt;code&gt;read&lt;/code&gt;ing from your keyboard or a socket) and haven't set up your own &lt;code&gt;$SIG{INT}&lt;/code&gt; handler, then you won't be able to CTRL-C your way back to the debugger, because the debugger's own &lt;code&gt;$SIG{INT}&lt;/code&gt; handler doesn't understand that it needs to raise an exception to longjmp(3) out of slow syscalls.</source>
          <target state="translated">あなたが遅いシステムコールにいる場合（のような &lt;code&gt;wait&lt;/code&gt; ING、 &lt;code&gt;accept&lt;/code&gt; する、または &lt;code&gt;read&lt;/code&gt; 、キーボードやソケットからINGの）と、独自に設定していない &lt;code&gt;$SIG{INT}&lt;/code&gt; ハンドラを、あなたはCTRLすることができません-デバッガーに戻る方法。デバッガー自体の &lt;code&gt;$SIG{INT}&lt;/code&gt; ハンドラーは、遅いsyscallからlongjmp（3）への例外を発生させる必要があることを理解していないためです。</target>
        </trans-unit>
        <trans-unit id="14f4284650d0a24b2d57ce770464abe6b8363cfa" translate="yes" xml:space="preserve">
          <source>If you're just trying to get a print out of each line of Perl code as it executes, the way that &lt;code&gt;sh -x&lt;/code&gt; provides for shell scripts, you can't use Perl's &lt;b&gt;-D&lt;/b&gt; switch. Instead do this</source>
          <target state="translated">実行時にPerlコードの各行から出力を取得するだけの場合、 &lt;code&gt;sh -x&lt;/code&gt; がシェルスクリプトに提供する方法では、Perlの&lt;b&gt;-D&lt;/b&gt;スイッチを使用できません。代わりにこれを行う</target>
        </trans-unit>
        <trans-unit id="e1d724a87dfd2f97b8c95cc8c3b05426d4d76542" translate="yes" xml:space="preserve">
          <source>If you're just trying to patch a binary, in many cases something as simple as this works:</source>
          <target state="translated">バイナリにパッチを当てようとしているだけなら、多くの場合、このようなシンプルなものが動作します。</target>
        </trans-unit>
        <trans-unit id="e27c869b95726ef20f74a953d6e15ab7c271a595" translate="yes" xml:space="preserve">
          <source>If you're looking for an EBNF grammar, see &lt;a href=&quot;TAP::Parser::Grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt;.</source>
          <target state="translated">EBNF文法を探している場合は、&lt;a href=&quot;TAP::Parser::Grammar&quot;&gt;TAP :: Parser :: Grammarを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="beae682a73c10931e4ab41819afea65e05d531cf" translate="yes" xml:space="preserve">
          <source>If you're looking for an EBNF grammar, see &lt;a href=&quot;parser/grammar&quot;&gt;TAP::Parser::Grammar&lt;/a&gt;.</source>
          <target state="translated">EBNF文法を探している場合は、&lt;a href=&quot;parser/grammar&quot;&gt;TAP :: Parser :: Grammarを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="55c4ac9978b7084a6172dad11c1733f741ff1455" translate="yes" xml:space="preserve">
          <source>If you're looking for something a bit more rigorous, try &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;.</source>
          <target state="translated">もう少し厳密なものを探している場合は、&lt;a href=&quot;perlootut&quot;&gt;perlootutを&lt;/a&gt;試してください。</target>
        </trans-unit>
        <trans-unit id="f56748dfc66ac6cba325f7661836f7de96b1136a" translate="yes" xml:space="preserve">
          <source>If you're looking for the information on how to use here-documents, which used to be here, that's been moved to &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;&quot;Quote and Quote-like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="translated">ヒアドキュメントの使用方法に関する情報を探している場合は&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;、以前はヒアドキュメント&lt;/a&gt;でしたが、perlopの「QuoteandQuote-likeOperators」に移動されました。</target>
        </trans-unit>
        <trans-unit id="7091178e821abb2a7bce9c92cae74d109146a9a0" translate="yes" xml:space="preserve">
          <source>If you're looking for the information on how to use here-documents, which used to be here, that's been moved to &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">ここにあった以前のヒアドキュメントの使用方法に関する情報を探している場合、それ&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;はperlopの引用および引用のような演算子に移動しました&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a2047473a3643e10d45494d0ba2e46e4f3bb5994" translate="yes" xml:space="preserve">
          <source>If you're looking for the nitty gritty details of how the debugger is</source>
          <target state="translated">デバッガがどのように動作しているかの詳細を知りたい場合は、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="889cd4ec91070da4d939fc8ed6a3a8c2e2067138" translate="yes" xml:space="preserve">
          <source>If you're looking to write your own object system, or you need to maintain code which implements objects from scratch then this document will help you understand exactly how Perl does object orientation.</source>
          <target state="translated">独自のオブジェクトシステムを書きたい場合や、ゼロからオブジェクトを実装したコードをメンテナンスする必要がある場合、このドキュメントはPerlがどのようにオブジェクト指向を行うかを正確に理解するのに役立つでしょう。</target>
        </trans-unit>
        <trans-unit id="ddf0bc3794c8ee98c81f65ada98d73c84a0b3b0d" translate="yes" xml:space="preserve">
          <source>If you're lucky enough to be using a system that supports non-blocking reads (most Unixish systems do), you need only to use the &lt;code&gt;O_NDELAY&lt;/code&gt; or &lt;code&gt;O_NONBLOCK&lt;/code&gt; flag from the &lt;code&gt;Fcntl&lt;/code&gt; module in conjunction with &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">幸運なことに、ノンブロッキング読み取りをサポートするシステムを使用している場合（ほとんどのUnixishシステムがサポートしています）、 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen()&lt;/a&gt;&lt;/code&gt; と組み合わせてFcntlモジュールの &lt;code&gt;O_NDELAY&lt;/code&gt; または &lt;code&gt;O_NONBLOCK&lt;/code&gt; フラグを使用するだけで &lt;code&gt;Fcntl&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="b92a61260d6789cb413228b4875aba877645cd63" translate="yes" xml:space="preserve">
          <source>If you're lucky enough to be using a system that supports non-blocking reads (most Unixish systems do), you need only to use the &lt;code&gt;O_NDELAY&lt;/code&gt; or &lt;code&gt;O_NONBLOCK&lt;/code&gt; flag from the &lt;code&gt;Fcntl&lt;/code&gt; module in conjunction with &lt;code&gt;sysopen()&lt;/code&gt;:</source>
          <target state="translated">幸運にも非ブロッキング読み取りをサポートするシステムを使用できる場合（ほとんどのUnixishシステムはサポートしています）、 &lt;code&gt;Fcntl&lt;/code&gt; モジュールの &lt;code&gt;O_NDELAY&lt;/code&gt; または &lt;code&gt;O_NONBLOCK&lt;/code&gt; フラグを &lt;code&gt;sysopen()&lt;/code&gt; と組み合わせて使用するだけで済みます。</target>
        </trans-unit>
        <trans-unit id="1442d0654a360821d205030d12b7c46d2249369f" translate="yes" xml:space="preserve">
          <source>If you're lucky you should see &quot;All tests successful&quot;. But there can be a few failed subtests (less than 5 hopefully) depending on some external conditions (e.g. some subtests fail under linux/dosemu or plain dos with short filenames only).</source>
          <target state="translated">運が良ければ &quot;All tests successful&quot; と表示されるはずです。しかし、外部の条件によっては、いくつかのサブテストが失敗することがあります (例えば、linux/dosemu や短いファイル名のみのプレイン ド dos で失敗するサブテストもあります)。</target>
        </trans-unit>
        <trans-unit id="81d8181270fe0a221e4cfe0273d672eeca038de7" translate="yes" xml:space="preserve">
          <source>If you're matching against &lt;code&gt;$_&lt;/code&gt; , the &lt;code&gt;$_ =~&lt;/code&gt; part can be omitted:</source>
          <target state="translated">&lt;code&gt;$_&lt;/code&gt; と照合する場合は、 &lt;code&gt;$_ =~&lt;/code&gt; 部分を省略できます。</target>
        </trans-unit>
        <trans-unit id="11ac83319ace4cc9c28ca859dfddf15f3ecfbd18" translate="yes" xml:space="preserve">
          <source>If you're matching against &lt;code&gt;$_&lt;/code&gt;, the &lt;code&gt;$_ =~&lt;/code&gt; part can be omitted:</source>
          <target state="translated">&lt;code&gt;$_&lt;/code&gt; と照合する場合は、 &lt;code&gt;$_ =~&lt;/code&gt; 部分を省略できます。</target>
        </trans-unit>
        <trans-unit id="8dff24fd1b5ec5a9dffa27b27da41b1f996870a7" translate="yes" xml:space="preserve">
          <source>If you're matching against the special default variable &lt;code&gt;$_&lt;/code&gt; , the &lt;code&gt;$_ =~&lt;/code&gt; part can be omitted:</source>
          <target state="translated">特別なデフォルト変数 &lt;code&gt;$_&lt;/code&gt; と照合する場合は、 &lt;code&gt;$_ =~&lt;/code&gt; 部分を省略できます。</target>
        </trans-unit>
        <trans-unit id="8117f4845259fee2b7568d80ed0d4624414390b8" translate="yes" xml:space="preserve">
          <source>If you're matching against the special default variable &lt;code&gt;$_&lt;/code&gt;, the &lt;code&gt;$_ =~&lt;/code&gt; part can be omitted:</source>
          <target state="translated">特別なデフォルト変数 &lt;code&gt;$_&lt;/code&gt; と照合する場合は、 &lt;code&gt;$_ =~&lt;/code&gt; 部分を省略できます。</target>
        </trans-unit>
        <trans-unit id="426f58876b20aa644c87cac6d34c02796b1541e8" translate="yes" xml:space="preserve">
          <source>If you're mixing UTF-8 and non-UTF-8 strings, it is necessary to upgrade the non-UTF-8 strings to UTF-8. If you've got an SV, the easiest way to do this is:</source>
          <target state="translated">UTF-8とUTF-8以外の文字列を混在させている場合は、UTF-8以外の文字列をUTF-8にアップグレードする必要があります。SVを持っていれば、一番簡単な方法は</target>
        </trans-unit>
        <trans-unit id="adb368df84ed73d15e6f01f5748e1a829c2701dc" translate="yes" xml:space="preserve">
          <source>If you're more familiar with writing in HTML than with writing in Pod, you can try your hand at writing documentation in simple HTML, and converting it to Pod with the experimental &lt;a href=&quot;Pod::HTML2Pod&quot;&gt;Pod::HTML2Pod&lt;/a&gt; module, (available in CPAN), and looking at the resulting code. The experimental &lt;a href=&quot;Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt; module in CPAN might also be useful.</source>
          <target state="translated">Podで書くよりもHTMLで書くことに慣れている場合は、簡単なHTMLでドキュメントを作成し、実験的な&lt;a href=&quot;Pod::HTML2Pod&quot;&gt;Pod :: HTML2Pod&lt;/a&gt;モジュール（CPANで利用可能）を使用してPodに変換し、確認することができます。結果のコードで。CPANの実験的な&lt;a href=&quot;Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt;モジュールも役立つかもしれません。</target>
        </trans-unit>
        <trans-unit id="0b4dc2534030724a7fd2a22ed631de91b923d0d4" translate="yes" xml:space="preserve">
          <source>If you're more familiar with writing in HTML than with writing in Pod, you can try your hand at writing documentation in simple HTML, and converting it to Pod with the experimental &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::HTML2Pod&quot;&gt;Pod::HTML2Pod&lt;/a&gt; module, (available in CPAN), and looking at the resulting code. The experimental &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt; module in CPAN might also be useful.</source>
          <target state="translated">ポッドでの記述よりもHTMLでの記述に精通している場合は、簡単なHTMLでドキュメントを記述し、実験的な&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::HTML2Pod&quot;&gt;Pod :: HTML2Pod&lt;/a&gt;モジュール（CPANで利用可能）を使用してそれをポッドに変換し、結果のコードで。CPAN の実験的な&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt;モジュールも役立つかもしれません。</target>
        </trans-unit>
        <trans-unit id="661a15733b02e1bde18a48ee6f26023806e52abe" translate="yes" xml:space="preserve">
          <source>If you're more from the object-oriented camp, you can inherit from Storable and directly store your objects by invoking &lt;code&gt;store&lt;/code&gt; as a method. The fact that the root of the to-be-stored tree is a blessed reference (i.e. an object) is special-cased so that the retrieve does not provide a reference to that object but rather the blessed object reference itself. (Otherwise, you'd get a reference to that blessed object).</source>
          <target state="translated">あなたはより多くのオブジェクト指向陣営からであれば、あなたにStorableを継承し、直接呼び出すことによって、あなたのオブジェクトを格納することができます &lt;code&gt;store&lt;/code&gt; 方法として。格納されるツリーのルートが祝福された参照（つまり、オブジェクト）であるという事実は特殊なケースであり、検索によってそのオブジェクトへの参照が提供されるのではなく、祝福されたオブジェクト参照自体が提供されます。（そうでなければ、その祝福されたオブジェクトへの参照が得られます）。</target>
        </trans-unit>
        <trans-unit id="f63fe5eb4649dbb1987379a78d0fe4e091aa300f" translate="yes" xml:space="preserve">
          <source>If you're new to Perl, you should start by running &lt;a href=&quot;perlintro&quot;&gt;&lt;code&gt;perldoc perlintro&lt;/code&gt;&lt;/a&gt;, which is a general intro for beginners and provides some background to help you navigate the rest of Perl's extensive documentation. Run &lt;a href=&quot;perldoc&quot;&gt;&lt;code&gt;perldoc perldoc&lt;/code&gt;&lt;/a&gt; to learn more things you can do with</source>
          <target state="translated">Perlを初めて使用する場合は、&lt;a href=&quot;perlintro&quot;&gt; &lt;code&gt;perldoc perlintro&lt;/code&gt; を&lt;/a&gt;実行することから始める必要があります。これは、初心者向けの一般的なイントロであり、Perlのその他の広範なドキュメントをナビゲートするのに役立つ背景を提供します。&lt;a href=&quot;perldoc&quot;&gt; &lt;code&gt;perldoc perldoc&lt;/code&gt; &lt;/a&gt;を実行して、でできることをさらに学びましょう</target>
        </trans-unit>
        <trans-unit id="90c11316b76d508e073f9fc77a3e623b3eada282" translate="yes" xml:space="preserve">
          <source>If you're new to Perl, you should start by running &lt;code&gt;perldoc perlintro&lt;/code&gt; , which is a general intro for beginners and provides some background to help you navigate the rest of Perl's extensive documentation. Run &lt;code&gt;perldoc
perldoc&lt;/code&gt; to learn more things you can do with</source>
          <target state="translated">Perlを初めて使用する場合は、 &lt;code&gt;perldoc perlintro&lt;/code&gt; を実行することから始めてください。これは、初心者向けの一般的なイントロであり、Perlの他の広範なドキュメントをナビゲートするのに役立つ背景を提供します。 &lt;code&gt;perldoc perldoc&lt;/code&gt; を実行して、あなたができることをもっと学びましょう</target>
        </trans-unit>
        <trans-unit id="744942d070c981ce6cf7077125a9b1fdb8807cc7" translate="yes" xml:space="preserve">
          <source>If you're new to the Perl debugger, you may prefer to read &lt;a href=&quot;perldebtut&quot;&gt;perldebtut&lt;/a&gt;, which is a tutorial introduction to the debugger.</source>
          <target state="translated">Perlデバッガーを初めて使用する場合は、デバッガーのチュートリアルの紹介である&lt;a href=&quot;perldebtut&quot;&gt;perldebtut&lt;/a&gt;を読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="c2727aad3001460d90c1014c2e79041ef3c0a256" translate="yes" xml:space="preserve">
          <source>If you're not running VMS, this module does nothing.</source>
          <target state="translated">VMS を実行していない場合、このモジュールは何もしません。</target>
        </trans-unit>
        <trans-unit id="57b30f05d7f8cbe152533a07743b1d8313aa4f82" translate="yes" xml:space="preserve">
          <source>If you're not sure what you have (the &lt;code&gt;VAL&lt;/code&gt; case), wrap the method call in an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; block to catch the exception if &lt;code&gt;VAL&lt;/code&gt; is undefined.</source>
          <target state="translated">何があるかわからない場合（ &lt;code&gt;VAL&lt;/code&gt; の場合）、 &lt;code&gt;VAL&lt;/code&gt; が未定義の場合、メソッド呼び出しを &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ブロックでラップして例外をキャッチします。</target>
        </trans-unit>
        <trans-unit id="4b417f2069d829972fc28b99377df4b969284461" translate="yes" xml:space="preserve">
          <source>If you're not sure what you have (the &lt;code&gt;VAL&lt;/code&gt; case), wrap the method call in an &lt;code&gt;eval&lt;/code&gt; block to catch the exception if &lt;code&gt;VAL&lt;/code&gt; is undefined.</source>
          <target state="translated">持っているものがわからない場合（ &lt;code&gt;VAL&lt;/code&gt; の場合）、 &lt;code&gt;VAL&lt;/code&gt; が定義されていない場合は、メソッド呼び出しを &lt;code&gt;eval&lt;/code&gt; ブロックでラップして、例外をキャッチします。</target>
        </trans-unit>
        <trans-unit id="92ef540b5bff7fa8b60e3b8701e23d84d3552eb5" translate="yes" xml:space="preserve">
          <source>If you're not the Perl administrator you probably don't have permission to install a module to its default location. Then you should install it for your own use into your home directory like so:</source>
          <target state="translated">あなたが Perl の管理者でない場合、おそらくモジュールをデフォルトの場所にインストールする権限がないでしょう。その場合は、以下のようにホームディレクトリに自分用のモジュールをインストールしてください。</target>
        </trans-unit>
        <trans-unit id="247917b0ada3108323df59e4327b62f819afb4ad" translate="yes" xml:space="preserve">
          <source>If you're not the Perl administrator you probably don't have permission to install a module to its default location. Ways of handling this with a &lt;b&gt;lot&lt;/b&gt; less manual effort on your part are &lt;a href=&quot;perlbrew&quot;&gt;perlbrew&lt;/a&gt; and &lt;a href=&quot;local::lib&quot;&gt;local::lib&lt;/a&gt;.</source>
          <target state="translated">Perl管理者でない場合は、モジュールをデフォルトの場所にインストールする権限がない可能性があります。手作業を&lt;b&gt;大幅に&lt;/b&gt;減らしてこれを処理する方法は、&lt;a href=&quot;perlbrew&quot;&gt;perlbrew&lt;/a&gt;と&lt;a href=&quot;local::lib&quot;&gt;local :: lib&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f33fa0120e14a08b5aff452dd882c3994193525a" translate="yes" xml:space="preserve">
          <source>If you're not used to reading BNF grammars, this is how it works: You're fed certain things by the tokeniser, which generally end up in upper case. &lt;code&gt;ADDOP&lt;/code&gt; and &lt;code&gt;ASSIGNOP&lt;/code&gt; are examples of &quot;terminal symbols&quot;, because you can't get any simpler than them.</source>
          <target state="translated">BNF文法を読むことに慣れていない場合は、次のように機能します。トークナイザーから特定のものが供給されますが、通常は大文字になります。 &lt;code&gt;ADDOP&lt;/code&gt; と &lt;code&gt;ASSIGNOP&lt;/code&gt; は、「終端記号」の例です。これらよりも単純なものは得られないためです。</target>
        </trans-unit>
        <trans-unit id="9feed406758bc42352583f962fb6765533ea27d0" translate="yes" xml:space="preserve">
          <source>If you're not used to reading BNF grammars, this is how it works: You're fed certain things by the tokeniser, which generally end up in upper case. Here, &lt;code&gt;ADDOP&lt;/code&gt; , is provided when the tokeniser sees &lt;code&gt;+&lt;/code&gt; in your code. &lt;code&gt;ASSIGNOP&lt;/code&gt; is provided when &lt;code&gt;=&lt;/code&gt; is used for assigning. These are &quot;terminal symbols&quot;, because you can't get any simpler than them.</source>
          <target state="translated">BNF文法を読むのに慣れていない場合は、次のように機能します。トークン化によって特定のものが提供されますが、トークン化は通常大文字になります。ここで、 &lt;code&gt;ADDOP&lt;/code&gt; は、トークナイザーがコード内で &lt;code&gt;+&lt;/code&gt; を見つけたときに提供されます。 &lt;code&gt;ASSIGNOP&lt;/code&gt; は、 &lt;code&gt;=&lt;/code&gt; が割り当てに使用されている場合に提供されます。これらは「ターミナルシンボル」です。これより簡単なものはないからです。</target>
        </trans-unit>
        <trans-unit id="d41cee3341b958945c48519633ed1e0a770e7261" translate="yes" xml:space="preserve">
          <source>If you're not writing a server/client for an existing protocol like NNTP or SMTP, you should give some thought to how your server will know when the client has finished talking, and vice-versa. Most protocols are based on one-line messages and responses (so one party knows the other has finished when a &quot;\n&quot; is received) or multi-line messages and responses that end with a period on an empty line (&quot;\n.\n&quot; terminates a message/response).</source>
          <target state="translated">NNTPやSMTPのような既存のプロトコル用のサーバ/クライアントを書いていない場合、クライアントが話し終わったことをサーバがどうやって知るのか、またその逆も考えておくべきです。ほとんどのプロトコルは、1行のメッセージと応答(つまり、&quot;\n &quot;が受信されたときに、一方の当事者は他方が終了したことを知っている)か、空行のピリオドで終わる複数行のメッセージと応答に基づいています。</target>
        </trans-unit>
        <trans-unit id="1904985e3da30cf5eb915cfb278068985854bae1" translate="yes" xml:space="preserve">
          <source>If you're not writing such a tool, then whether you accept noncharacters as input is up to you (though the Standard recommends that you not). If you do strict input stream checking with Perl, these code points continue to be forbidden. This is to maintain backward compatibility (otherwise potential security holes could open up, as an unsuspecting application that was written assuming the noncharacters would be filtered out before getting to it, could now, without warning, start getting them). To do strict checking, you can use the layer &lt;code&gt;:encoding('UTF-8')&lt;/code&gt; .</source>
          <target state="translated">そのようなツールを作成していない場合、非文字を入力として受け入れるかどうかはあなた次第です（ただし、標準ではそうしないことを推奨しています）。 Perlで厳密な入力ストリームチェックを行う場合、これらのコードポイントは引き続き禁止されます。これは、下位互換性を維持するためです（そうしないと、非文字が到達する前にフィルターで除外されることを想定して書かれた無防備なアプリケーションが警告なしにそれらを取得し始める可能性があるため、潜在的なセキュリティホールが開く可能性があります）。厳密なチェックを行うには、レイヤー &lt;code&gt;:encoding('UTF-8')&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="d77310220e2c4362538cbb9513e4d5aa5a72b313" translate="yes" xml:space="preserve">
          <source>If you're not writing such a tool, then whether you accept noncharacters as input is up to you (though the Standard recommends that you not). If you do strict input stream checking with Perl, these code points continue to be forbidden. This is to maintain backward compatibility (otherwise potential security holes could open up, as an unsuspecting application that was written assuming the noncharacters would be filtered out before getting to it, could now, without warning, start getting them). To do strict checking, you can use the layer &lt;code&gt;:encoding('UTF-8')&lt;/code&gt;.</source>
          <target state="translated">そのようなツールを作成していない場合、入力として文字以外を受け入れるかどうかはあなた次第です（ただし、標準ではそうしないことを推奨しています）。 Perlで厳密な入力ストリームチェックを行う場合、これらのコードポイントは引き続き禁止されます。これは、下位互換性を維持するためです（そうしないと、非文字が到達する前にフィルターで除外されると想定して作成された疑いのないアプリケーションが、警告なしに取得を開始する可能性があるため、潜在的なセキュリティホールが開く可能性があります）。厳密なチェックを行うには、レイヤー &lt;code&gt;:encoding('UTF-8')&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="6e740be7e86f98ca86a316e7e6f108d26ec4db83" translate="yes" xml:space="preserve">
          <source>If you're on Unix, you already have an IDE--Unix itself. The Unix philosophy is the philosophy of several small tools that each do one thing and do it well. It's like a carpenter's toolbox.</source>
          <target state="translated">あなたがUnixを使っているのであれば、すでにIDE--Unixそのものを持っています。Unixの哲学は、いくつかの小さなツールがそれぞれ一つのことを行い、それをうまくこなすという哲学です。大工さんの道具箱のようなものです。</target>
        </trans-unit>
        <trans-unit id="27b6c4407588281e5e7fdb718dd9826644dbabc0" translate="yes" xml:space="preserve">
          <source>If you're on a POSIX system, Perl supports the &lt;code&gt;POSIX::strtod&lt;/code&gt; function for converting strings to doubles (and also &lt;code&gt;POSIX::strtol&lt;/code&gt; for longs). Its semantics are somewhat cumbersome, so here's a &lt;code&gt;getnum&lt;/code&gt; wrapper function for more convenient access. This function takes a string and returns the number it found, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for input that isn't a C float. The &lt;code&gt;is_numeric&lt;/code&gt; function is a front end to &lt;code&gt;getnum&lt;/code&gt; if you just want to say, &quot;Is this a float?&quot;</source>
          <target state="translated">POSIXシステムを使用している場合、Perlは文字列をdoubleに変換するための &lt;code&gt;POSIX::strtod&lt;/code&gt; 関数をサポートします（longの場合は &lt;code&gt;POSIX::strtol&lt;/code&gt; もサポートします）。そのセマンティクスは多少扱いにくいので、より便利なアクセスのための &lt;code&gt;getnum&lt;/code&gt; ラッパー関数を次に示します。この関数は文字列を取り、それが見つけた数を返すか、Cのfloatでない入力の場合は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。 &lt;code&gt;is_numeric&lt;/code&gt; 機能は、フロントエンドである &lt;code&gt;getnum&lt;/code&gt; あなたが言いたい場合は、「これはフロートですか？」</target>
        </trans-unit>
        <trans-unit id="47aff00cb7b46f5bee1ecbbd614c85d2d65bb4f4" translate="yes" xml:space="preserve">
          <source>If you're on a POSIX system, Perl supports the &lt;code&gt;POSIX::strtod&lt;/code&gt; function for converting strings to doubles (and also &lt;code&gt;POSIX::strtol&lt;/code&gt; for longs). Its semantics are somewhat cumbersome, so here's a &lt;code&gt;getnum&lt;/code&gt; wrapper function for more convenient access. This function takes a string and returns the number it found, or &lt;code&gt;undef&lt;/code&gt; for input that isn't a C float. The &lt;code&gt;is_numeric&lt;/code&gt; function is a front end to &lt;code&gt;getnum&lt;/code&gt; if you just want to say, &quot;Is this a float?&quot;</source>
          <target state="translated">POSIXシステムを使用している場合、Perlは文字列をdoubleに変換するための &lt;code&gt;POSIX::strtod&lt;/code&gt; 関数（およびlongの場合は &lt;code&gt;POSIX::strtol&lt;/code&gt; ）をサポートします。そのセマンティクスはやや面倒なので、より便利なアクセスのための &lt;code&gt;getnum&lt;/code&gt; ラッパー関数を次に示します。この関数は文字列を受け取り、見つかった数値を返します。Cフロートではない入力の場合は &lt;code&gt;undef&lt;/code&gt; を返します。 &lt;code&gt;is_numeric&lt;/code&gt; 機能は、フロントエンドである &lt;code&gt;getnum&lt;/code&gt; あなたが言いたい場合は、「これはフロートですか？」</target>
        </trans-unit>
        <trans-unit id="fe652d8671f9747b2b27fba3ba0a6953bf5a58ab" translate="yes" xml:space="preserve">
          <source>If you're only a C programmer, than this is the end of the message for you. You can quit right now, and if you care to, save off the source and run it when you feel like it. Or not.</source>
          <target state="translated">もしあなたがC言語のプログラマーでしかないのであれば、このメッセージはここまでにしましょう。今すぐ辞めてもいいし、気になったらソースを保存して、気が向いたときに実行してみてください。あるいは、そうでない場合も。</target>
        </trans-unit>
        <trans-unit id="5f443393381ebb2ba3b4781af2f167f994444b4f" translate="yes" xml:space="preserve">
          <source>If you're passing a filehandle to a function, you can write the function in two ways:</source>
          <target state="translated">関数にファイルハンドルを渡す場合は、2つの方法で関数を書くことができます。</target>
        </trans-unit>
        <trans-unit id="3681c9d29e3cea8b052a12522cde089c668422cf" translate="yes" xml:space="preserve">
          <source>If you're passing around filehandles, you could usually just use the bare typeglob, like &lt;code&gt;*STDOUT&lt;/code&gt; , but typeglobs references work, too. For example:</source>
          <target state="translated">ファイルハンドルを渡す場合、通常は &lt;code&gt;*STDOUT&lt;/code&gt; のように裸のtypeglobを使用できますが、typeglobs参照も機能します。例えば：</target>
        </trans-unit>
        <trans-unit id="298de4014a3a85ac5b8366c5095b3672193b40a2" translate="yes" xml:space="preserve">
          <source>If you're passing around filehandles, you could usually just use the bare typeglob, like &lt;code&gt;*STDOUT&lt;/code&gt;, but typeglobs references work, too. For example:</source>
          <target state="translated">ファイルハンドルを渡す場合は、通常、 &lt;code&gt;*STDOUT&lt;/code&gt; のような裸のtypeglobを使用できますが、typeglobs参照も機能します。例えば：</target>
        </trans-unit>
        <trans-unit id="8f816f45cbfc0eef6f9ae6c1011d3c4a6ca61924" translate="yes" xml:space="preserve">
          <source>If you're planning on generating new filehandles, you could do this. Notice to pass back just the bare *FH, not its reference.</source>
          <target state="translated">新しいファイルハンドルを生成しようと思っているのであれば、このようにすることができます。参照ではなく、ただの *FH を渡すことに注意してください。</target>
        </trans-unit>
        <trans-unit id="e8bfd94e153d8978fbc196c7118de9fb39d2dab3" translate="yes" xml:space="preserve">
          <source>If you're planning to do more extensive work than a single small fix, we encourage you to read the documentation below. This will help you focus your work and make your patches easier to incorporate into the Perl source.</source>
          <target state="translated">単一の小さな修正よりも大規模な作業を計画しているのであれば、以下のドキュメントを読むことをお勧めします。これはあなたの作業を集中させ、パッチを Perl のソースに組み込むのを容易にするのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="2a89224882a8273613d6c7a7a7b1c88a5cbcd4d7" translate="yes" xml:space="preserve">
          <source>If you're planning to filetest the return values out of a &lt;a href=&quot;#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt;, you'd better prepend the directory in question. Otherwise, because we didn't &lt;a href=&quot;#chdir-EXPR&quot;&gt;&lt;code&gt;chdir&lt;/code&gt;&lt;/a&gt; there, it would have been testing the wrong file.</source>
          <target state="translated">&lt;a href=&quot;#readdir-DIRHANDLE&quot;&gt; &lt;code&gt;readdir&lt;/code&gt; &lt;/a&gt;からの戻り値をファイルテストすることを計画している場合は、問題のディレクトリの前に追加することをお勧めします。そうでなければ、そこで&lt;a href=&quot;#chdir-EXPR&quot;&gt; &lt;code&gt;chdir&lt;/code&gt; &lt;/a&gt;を実行しなかったため、間違ったファイルをテストしていたでしょう。</target>
        </trans-unit>
        <trans-unit id="304b9d32f29eb0f2f218ff94e8f5f53580345dcb" translate="yes" xml:space="preserve">
          <source>If you're planning to filetest the return values out of a &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, you'd better prepend the directory in question. Otherwise, because we didn't &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; there, it would have been testing the wrong file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; からの戻り値をファイルテストする場合は、問題のディレクトリを先頭に追加することをお勧めします。それ以外の場合は、そこに &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; を実行しなかったため、間違ったファイルがテストされていました。</target>
        </trans-unit>
        <trans-unit id="f907870b50e1902094cd7a51307296876f77264b" translate="yes" xml:space="preserve">
          <source>If you're planning to filetest the return values out of a &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, you'd better prepend the directory in question. Otherwise, because we didn't &lt;code&gt;&lt;a href=&quot;chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; there, it would have been testing the wrong file.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; からの戻り値をファイルテストする場合は、問題のディレクトリを先頭に追加することをお勧めします。それ以外の場合は、そこに &lt;code&gt;&lt;a href=&quot;chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; を実行しなかったため、間違ったファイルがテストされていました。</target>
        </trans-unit>
        <trans-unit id="a8c4c2e820002b650e8d2ecdec056a32fb436bfd" translate="yes" xml:space="preserve">
          <source>If you're reading this document because you want to write a formatter subclass, continue reading it and then read &lt;a href=&quot;Pod::Simple::Subclassing&quot;&gt;Pod::Simple::Subclassing&lt;/a&gt;, and then possibly even read &lt;a href=&quot;perlpodspec&quot;&gt;perlpodspec&lt;/a&gt; (some of which is for parser-writers, but much of which is notes to formatter-writers).</source>
          <target state="translated">フォーマッターサブクラスを作成したいためにこのドキュメントを読んでいる場合は、読み続けてから&lt;a href=&quot;Pod::Simple::Subclassing&quot;&gt;Pod :: Simple :: Subclassingを&lt;/a&gt;読んでから、&lt;a href=&quot;perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;（パーサーライター向けのものもありますが、その多くはフォーマッターライターへのメモです）。</target>
        </trans-unit>
        <trans-unit id="fcece448e0aa8ee8873fb9b13cee8077eaed1e18" translate="yes" xml:space="preserve">
          <source>If you're reading this document because you want to write a formatter subclass, continue reading it and then read &lt;a href=&quot;simple/subclassing&quot;&gt;Pod::Simple::Subclassing&lt;/a&gt;, and then possibly even read &lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt; (some of which is for parser-writers, but much of which is notes to formatter-writers).</source>
          <target state="translated">フォーマッタサブクラスを作成する必要があるためにこのドキュメントを読んでいる場合は、引き続き読み、次に&lt;a href=&quot;simple/subclassing&quot;&gt;Pod :: Simple :: Subclassingを&lt;/a&gt;読んでから、おそらく&lt;a href=&quot;../perlpodspec&quot;&gt;perlpodspec&lt;/a&gt;も読んでください（一部はパーサーライター向けですが、その多くはフォーマッタライターへのメモです）。</target>
        </trans-unit>
        <trans-unit id="3eca1cf4cac957f4047c12a2cccf4d8bf7c0618e" translate="yes" xml:space="preserve">
          <source>If you're reading this document just because you have a Pod-processing subclass that you want to use, this document (plus the documentation for the subclass) is probably all you need to read.</source>
          <target state="translated">Pod-processingのサブクラスを使いたいからといってこのドキュメントを読むのであれば、このドキュメント(とサブクラスのドキュメント)だけで十分でしょう。</target>
        </trans-unit>
        <trans-unit id="b7d2d7b7f7d3b1824419996342901896caf3e1ec" translate="yes" xml:space="preserve">
          <source>If you're running Perl on a system that distinguishes between text files and binary files, then you should check out &lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt; for tips for dealing with this. The key distinction between systems that need &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; and those that don't is their text file formats. Systems like Unix, Mac OS, and Plan 9, that end lines with a single character and encode that character in C as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; do not need &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt;. The rest need it.</source>
          <target state="translated">テキストファイルとバイナリファイルを区別するシステムでPerlを実行している場合は、&lt;a href=&quot;#binmode&quot;&gt;binmode&lt;/a&gt;をチェックして、これに対処するためのヒントを確認してください。 &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; を必要とするシステムとそれを必要としないシステムの主な違いは、テキストファイル形式です。Unix、Mac OS、Plan 9などのシステムでは、単一の文字で行を終了し、その文字をCで &lt;code&gt;&quot;\n&quot;&lt;/code&gt; としてエンコードします &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; は必要ありません。残りはそれを必要とします。</target>
        </trans-unit>
        <trans-unit id="ffabd87b995f6de8b55fa057fefd0560b9ffddaf" translate="yes" xml:space="preserve">
          <source>If you're running Perl on a system that distinguishes between text files and binary files, then you should check out &lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt; for tips for dealing with this. The key distinction between systems that need &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; and those that don't is their text file formats. Systems like Unix, Mac OS, and Plan 9, that end lines with a single character and encode that character in C as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; do not need &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt;. The rest need it.</source>
          <target state="translated">テキストファイルとバイナリファイルを区別するシステムでPerlを実行している場合は、&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;をチェックして、これに対処するためのヒントを確認してください。 &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; を必要とするシステムとそれを必要としないシステムの主な違いは、テキストファイル形式です。Unix、Mac OS、Plan 9などのシステムでは、単一の文字で行を終了し、その文字をCで &lt;code&gt;&quot;\n&quot;&lt;/code&gt; としてエンコードします &lt;code&gt;&lt;a href=&quot;binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; は必要ありません。残りはそれを必要とします。</target>
        </trans-unit>
        <trans-unit id="c1457648c4ce0280355f7ef1bc996151dcbc9e3b" translate="yes" xml:space="preserve">
          <source>If you're running under VMS, the routines in this package are special, in that they're automatically made available to any Perl script, whether you're running</source>
          <target state="translated">VMS を実行している場合、本パッケージのルーチンは特別です。</target>
        </trans-unit>
        <trans-unit id="39c1b50b544a3df322b75f65dc11d5ac4c69a35f" translate="yes" xml:space="preserve">
          <source>If you're storing handles in an array or hash, or in general whenever you're using any expression more complex than a bareword handle or a plain, unsubscripted scalar variable to retrieve it, you will have to use a block returning the filehandle value instead, in which case the LIST may not be omitted:</source>
          <target state="translated">配列やハッシュにハンドルを格納している場合や、一般的にはベアワードハンドルよりも複雑な式や、それを取得するためにプレーンでサブスクリプトされていないスカラ変数を使用している場合には、代わりにファイルハンドルの値を返すブロックを使用しなければなりませんが、その場合にはLISTを省略することはできません。</target>
        </trans-unit>
        <trans-unit id="1ed2a4901ca871ef8cee85b2ad371ae78f316632" translate="yes" xml:space="preserve">
          <source>If you're submitting values using the GET method, create a URL and encode the form using the &lt;code&gt;query_form&lt;/code&gt; method:</source>
          <target state="translated">GETメソッドを使用して値を送信する場合は、URLを作成し、 &lt;code&gt;query_form&lt;/code&gt; メソッドを使用してフォームをエンコードします。</target>
        </trans-unit>
        <trans-unit id="8589815d02edc83abce0f57d2f0a5efb5068a683" translate="yes" xml:space="preserve">
          <source>If you're submitting values using the GET method, create a URL and encode the form using the &lt;code&gt;www_form_urlencode&lt;/code&gt; method from &lt;a href=&quot;HTTP::Tiny&quot;&gt;HTTP::Tiny&lt;/a&gt;:</source>
          <target state="translated">GETメソッドを使用して値を送信する場合は、URLを作成し、&lt;a href=&quot;HTTP::Tiny&quot;&gt;HTTP :: Tiny&lt;/a&gt;：から &lt;code&gt;www_form_urlencode&lt;/code&gt; メソッドを使用してフォームをエンコードします。</target>
        </trans-unit>
        <trans-unit id="3997ad77a6ffe99bd09989a635705961b00c6f35" translate="yes" xml:space="preserve">
          <source>If you're talking about obscuring method calls in parent classes, see &lt;a href=&quot;perlootut#Overriding-methods-and-method-resolution&quot;&gt;&quot;Overriding methods and method resolution&quot; in perlootut&lt;/a&gt;.</source>
          <target state="translated">親クラスのメソッド呼び出しを隠すことについて話している場合は&lt;a href=&quot;perlootut#Overriding-methods-and-method-resolution&quot;&gt;、perlootutの「メソッドとメソッド解決のオーバーライド」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d5f5ca288d27f19393728db02ea58b007b723ea8" translate="yes" xml:space="preserve">
          <source>If you're talking about obscuring method calls in parent classes, see &lt;a href=&quot;perlootut#Overriding-methods-and-method-resolution&quot;&gt;Overriding methods and method resolution in perlootut&lt;/a&gt;.</source>
          <target state="translated">親クラスでのメソッド呼び出しの不明瞭化について話している場合は&lt;a href=&quot;perlootut#Overriding-methods-and-method-resolution&quot;&gt;、perlootutでのメソッドとメソッド解決のオーバーライドを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f9fb0313a494e266734d606dab0fb4c3f5c1638a" translate="yes" xml:space="preserve">
          <source>If you're trying to do variable interpolation, it's definitely better to use the &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; function, because the older notation can cause people to become confused with the indirect filehandle notation.</source>
          <target state="translated">変数の補間を行う場合は、 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob()&lt;/a&gt;&lt;/code&gt; 関数を使用する方が確実に優れています。古い表記では、間接的なファイルハンドル表記と混同される可能性があるためです。</target>
        </trans-unit>
        <trans-unit id="6bfd1f418444ef167b4c1d82e3071f7953fa2d61" translate="yes" xml:space="preserve">
          <source>If you're trying to do variable interpolation, it's definitely better to use the &lt;code&gt;glob()&lt;/code&gt; function, because the older notation can cause people to become confused with the indirect filehandle notation.</source>
          <target state="translated">変数の補間を行おうとしている場合は、 &lt;code&gt;glob()&lt;/code&gt; 関数を使用することをお勧めします。古い表記では、間接的なファイルハンドル表記と混同される可能性があるためです。</target>
        </trans-unit>
        <trans-unit id="b2f801c8c750d6402e7dad5eddfca92a856a8093" translate="yes" xml:space="preserve">
          <source>If you're unsure of the meaning of an error message you've run across, &lt;b&gt;perldoc&lt;/b&gt;&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; for an explanation. If the message isn't in perldiag, it probably isn't generated by Perl. You may have luck consulting your operating system documentation instead.</source>
          <target state="translated">遭遇したエラーメッセージの意味がわからない場合は、&lt;b&gt;perldoc &lt;/b&gt;&lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt;を参照してください。メッセージがperldiagにない場合、おそらくPerlによって生成されていません。代わりに、オペレーティングシステムのドキュメントを調べて運がよいかもしれません。</target>
        </trans-unit>
        <trans-unit id="4b93133a107f3dc1672015bebe523f72dafb6b9f" translate="yes" xml:space="preserve">
          <source>If you're uploading to CPAN, the automated gremlins will extract the README file and place that in your CPAN directory. It'll also appear in the main</source>
          <target state="translated">CPANにアップロードしている場合、自動化されたグレムリンがREADMEファイルを抽出し、CPANディレクトリに配置します。また、メインの</target>
        </trans-unit>
        <trans-unit id="3ad89e38e60f381b4a7eacce6c02e2db727251db" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;Archive::Tar&lt;/code&gt; 's &lt;code&gt;extract()&lt;/code&gt; method, &lt;code&gt;setcwd()&lt;/code&gt; will be called for you.</source>
          <target state="translated">&lt;code&gt;Archive::Tar&lt;/code&gt; の &lt;code&gt;extract()&lt;/code&gt; メソッドを使用している場合、 &lt;code&gt;setcwd()&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="c63cdfe81388f5792f978ef625e22f4f10866e25" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;Archive::Tar&lt;/code&gt;'s &lt;code&gt;extract()&lt;/code&gt; method, &lt;code&gt;setcwd()&lt;/code&gt; will be called for you.</source>
          <target state="translated">&lt;code&gt;Archive::Tar&lt;/code&gt; の &lt;code&gt;extract()&lt;/code&gt; メソッドを使用している場合は、 &lt;code&gt;setcwd()&lt;/code&gt; が呼び出されます。</target>
        </trans-unit>
        <trans-unit id="0cc14a892bad71218591bbe7bbef35b81fe36647" translate="yes" xml:space="preserve">
          <source>If you're using VMStar:</source>
          <target state="translated">VMStarを使っているのであれば</target>
        </trans-unit>
        <trans-unit id="907bb15f43743b61b1d7e7cd7fb29070f01e69a0" translate="yes" xml:space="preserve">
          <source>If you're using a module that's not thread-safe for some reason, you can protect yourself by using it from one, and only one thread at all. If you need multiple threads to access such a module, you can use semaphores and lots of programming discipline to control access to it. Semaphores are covered in &lt;a href=&quot;#Basic-semaphores&quot;&gt;&quot;Basic semaphores&quot;&lt;/a&gt;.</source>
          <target state="translated">何らかの理由でスレッドセーフではないモジュールを使用している場合は、1つだけのスレッドからモジュールを使用することで、自分自身を保護できます。このようなモジュールにアクセスするために複数のスレッドが必要な場合は、セマフォと多くのプログラミング分野を使用して、モジュールへのアクセスを制御できます。セマフォについては、&lt;a href=&quot;#Basic-semaphores&quot;&gt;「基本的なセマフォ」で説明してい&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="76511f6d042eedee604ffae23aa88974c6f04729" translate="yes" xml:space="preserve">
          <source>If you're using a module that's not thread-safe for some reason, you can protect yourself by using it from one, and only one thread at all. If you need multiple threads to access such a module, you can use semaphores and lots of programming discipline to control access to it. Semaphores are covered in &lt;a href=&quot;#Basic-semaphores&quot;&gt;Basic semaphores&lt;/a&gt;.</source>
          <target state="translated">なんらかの理由でスレッドセーフではないモジュールを使用している場合は、1つのスレッドからモジュールを使用することで自分自身を保護できます。そのようなモジュールにアクセスするために複数のスレッドが必要な場合は、セマフォと多くのプログラミング規則を使用して、そのモジュールへのアクセスを制御できます。セマフォについては、&lt;a href=&quot;#Basic-semaphores&quot;&gt;基本的なセマフォで説明してい&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="9aa1259aa5ab1edcbb7c8ec755fbb7d9933607e8" translate="yes" xml:space="preserve">
          <source>If you're using a version of Perl before 5.004, you must call &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; once at the start of your program to seed the random number generator.</source>
          <target state="translated">5.004より前のバージョンのPerlを使用している場合は、プログラムの開始時に一度 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; を呼び出して、乱数ジェネレータをシードする必要があります。</target>
        </trans-unit>
        <trans-unit id="45f120602aeb67edc0215d28ccd9011716655e69" translate="yes" xml:space="preserve">
          <source>If you're using a version of Perl before 5.004, you must call &lt;code&gt;srand&lt;/code&gt; once at the start of your program to seed the random number generator.</source>
          <target state="translated">5.004より前のバージョンのPerlを使用している場合は、プログラムの開始時に &lt;code&gt;srand&lt;/code&gt; を1回呼び出して、乱数ジェネレーターをシードする必要があります。</target>
        </trans-unit>
        <trans-unit id="9ff91ee4a99e5bbc7fa9f896e9934c1f57633ce3" translate="yes" xml:space="preserve">
          <source>If you're using localization in an application that keeps a configuration file, you might consider something like this in your project class:</source>
          <target state="translated">設定ファイルを保持するアプリケーションでローカリゼーションを使用している場合、プロジェクトクラスで以下のようなことを考えるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e98919158b85262f93e6e1cca66f69e28561af51" translate="yes" xml:space="preserve">
          <source>If you're using references as keys within your hash tables, you're bound to be disappointed when retrieving your data. Indeed, Perl stringifies references used as hash table keys. If you later wish to access the items via another reference stringification (i.e. using the same reference that was used for the key originally to record the value into the hash table), it will work because both references stringify to the same string.</source>
          <target state="translated">ハッシュテーブルの中で参照をキーとして使用している場合、データを取得する際に失望することになるでしょう。実際、Perlはハッシュテーブルのキーとして使用される参照を文字列化します。後で別の参照の文字列化を使ってアクセスしたい場合(つまり、ハッシュテーブルに値を記録するために最初にキーに使用されたのと同じ参照を使用する)、両方の参照が同じ文字列に文字列化されるので、それはうまくいきます。</target>
        </trans-unit>
        <trans-unit id="cda64e05edf4afefc7befad6697f98377f63d5c2" translate="yes" xml:space="preserve">
          <source>If you're using strict, you</source>
          <target state="translated">厳密な使い方をしているのであれば</target>
        </trans-unit>
        <trans-unit id="5149a95571d7bad870cf9d14644f05c40d4e4c11" translate="yes" xml:space="preserve">
          <source>If you're using the POST method, create your own user agent and encode the content appropriately.</source>
          <target state="translated">POSTメソッドを使用している場合は、独自のユーザーエージェントを作成し、適切に内容をエンコードしてください。</target>
        </trans-unit>
        <trans-unit id="aa3146750972f670c3e28f005d36e51430c4e4f6" translate="yes" xml:space="preserve">
          <source>If you're using the POST method, the &lt;code&gt;post_form&lt;/code&gt; method will encode the content appropriately.</source>
          <target state="translated">POSTメソッドを使用している場合、 &lt;code&gt;post_form&lt;/code&gt; メソッドはコンテンツを適切にエンコードします。</target>
        </trans-unit>
        <trans-unit id="94dea5f329a320df5b1676d594bbe7ddb6af4d25" translate="yes" xml:space="preserve">
          <source>If you're using untarzipme or StuffIt, the archive should be extracted now. &lt;b&gt;Or&lt;/b&gt;, you can use the freeware &lt;b&gt;suntar&lt;/b&gt; or</source>
          <target state="translated">untarzipmeまたはStuffItを使用している場合は、ここでアーカイブを抽出する必要があります。&lt;b&gt;または&lt;/b&gt;、フリーウェアの&lt;b&gt;suntar&lt;/b&gt;または</target>
        </trans-unit>
        <trans-unit id="03aaa8fe5a352318fc187dc162360b47448bfe8d" translate="yes" xml:space="preserve">
          <source>If you're working with globs at runtime, and need to disambiguate *^G from *{&quot;^G&quot;}, then you should use the raw NAME method.</source>
          <target state="translated">実行時にグロブを使用していて、*{&quot;^G&quot;}と *^G を区別する必要がある場合は、生の NAME メソッドを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="86326ce985c6268f6aa266be33a273db0ac99980" translate="yes" xml:space="preserve">
          <source>If you're worried about users selecting bad passwords, you should proactively check when they try to change their password (by modifying</source>
          <target state="translated">ユーザーが不正なパスワードを選択することを心配しているのであれば、ユーザーがパスワードを変更しようとしたときに積極的にチェックすべきです (</target>
        </trans-unit>
        <trans-unit id="bc54d6339a6f99949e77b0d38ee469b66f200a38" translate="yes" xml:space="preserve">
          <source>If you're worried about users selecting bad passwords, you should proactively check when they try to change their password (by modifying &lt;a href=&quot;http://man.he.net/man1/passwd&quot;&gt;passwd(1)&lt;/a&gt;, for example).</source>
          <target state="translated">ユーザーが不正なパスワードを選択することを心配している場合は、ユーザーがパスワードを変更しようとするタイミングを事前に確認する必要があります（たとえば、&lt;a href=&quot;http://man.he.net/man1/passwd&quot;&gt;passwd（1）を&lt;/a&gt;変更するなど）。</target>
        </trans-unit>
        <trans-unit id="c631e014f0d55506d4df289cf9b8b44d3544afb4" translate="yes" xml:space="preserve">
          <source>If you're writing code, such as an editor, that is supposed to be able to handle any Unicode text data, then you shouldn't be using these code points yourself, and instead allow them in the input. If you need sentinels, they should instead be something that isn't legal Unicode. For UTF-8 data, you can use the bytes 0xC1 and 0xC2 as sentinels, as they never appear in well-formed UTF-8. (There are equivalents for UTF-EBCDIC). You can also store your Unicode code points in integer variables and use negative values as sentinels.</source>
          <target state="translated">エディタのように、どんなUnicodeテキストデータも扱えることになっているコードを書いているのであれば、これらのコードポイントを自分で使うべきではなく、代わりに入力の中で許可すべきです。センティネルが必要な場合は、その代わりに合法的なUnicodeではないものにすべきです。UTF-8 データの場合、0xC1 と 0xC2 バイトをセンティネルとして使うことができます。UTF-EBCDIC には同等のものがあります)。Unicode コードポイントを整数変数に格納して、負の値をセンティネルとして使用することもできます。</target>
        </trans-unit>
        <trans-unit id="ddd87126ab7eec259a7e6ec167a9a1ed6e855f3d" translate="yes" xml:space="preserve">
          <source>If you're writing your own &lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, you may need to create your own iterators too. If so you'll need to subclass &lt;a href=&quot;TAP::Parser::Iterator&quot;&gt;TAP::Parser::Iterator&lt;/a&gt;.</source>
          <target state="translated">独自の&lt;a href=&quot;TAP::Parser::SourceHandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;を作成している場合は、独自のイテレータも作成する必要があります。その場合は、&lt;a href=&quot;TAP::Parser::Iterator&quot;&gt;TAP :: Parser :: Iterator&lt;/a&gt;をサブクラス化する必要があります。</target>
        </trans-unit>
        <trans-unit id="a276dfc7f44e7268960d2975b30664b78a301f5a" translate="yes" xml:space="preserve">
          <source>If you're writing your own &lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP::Parser::SourceHandler&lt;/a&gt;, you may need to create your own iterators too. If so you'll need to subclass &lt;a href=&quot;parser/iterator&quot;&gt;TAP::Parser::Iterator&lt;/a&gt;.</source>
          <target state="translated">独自の&lt;a href=&quot;parser/sourcehandler&quot;&gt;TAP :: Parser :: SourceHandler&lt;/a&gt;を作成している場合は、独自のイテレータも作成する必要がある場合があります。もしそうなら、あなたは&lt;a href=&quot;parser/iterator&quot;&gt;TAP :: Parser :: Iterator&lt;/a&gt;をサブクラス化する必要があります。</target>
        </trans-unit>
        <trans-unit id="6d3ca82cb6d85e36f098b04f831321b68f9f28ab" translate="yes" xml:space="preserve">
          <source>If you're writing your own documentation in POD, the</source>
          <target state="translated">PODで独自のドキュメントを書いている場合は</target>
        </trans-unit>
        <trans-unit id="7e39071fa8860b1c165c3510aa6e985ec88eb293" translate="yes" xml:space="preserve">
          <source>If you've already got some other kind of email object, consider passing it to &lt;a href=&quot;Email::Abstract&quot;&gt;Email::Abstract&lt;/a&gt; and then using its cast method to get an &lt;a href=&quot;Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; object:</source>
          <target state="translated">他の種類の電子メールオブジェクトをすでに持っている場合は、それを&lt;a href=&quot;Email::Abstract&quot;&gt;Email :: Abstractに&lt;/a&gt;渡し、そのキャストメソッドを使用して&lt;a href=&quot;Email::MIME&quot;&gt;Email :: MIME&lt;/a&gt;オブジェクトを取得することを検討してください。</target>
        </trans-unit>
        <trans-unit id="609941eec97975f4a0354cdbfbac32c60f31f261" translate="yes" xml:space="preserve">
          <source>If you've already got some other kind of email object, consider passing it to &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Abstract&quot;&gt;Email::Abstract&lt;/a&gt; and then using its cast method to get an &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; object:</source>
          <target state="translated">他の種類の電子メールオブジェクトを既に取得している場合は、それを&lt;a href=&quot;http://search.cpan.org/perldoc/Email::Abstract&quot;&gt;Email :: Abstractに&lt;/a&gt;渡してから、そのキャストメソッドを使用して&lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email :: MIME&lt;/a&gt;オブジェクトを取得することを検討してください。</target>
        </trans-unit>
        <trans-unit id="49b89fe4b531fe550fa8cdc2584e0b4d10940e84" translate="yes" xml:space="preserve">
          <source>If you've been around Perl a while, all this talk of escape sequences may seem familiar. Similar escape sequences are used in double-quoted strings and in fact the regexps in Perl are mostly treated as double-quoted strings. This means that variables can be used in regexps as well. Just like double-quoted strings, the values of the variables in the regexp will be substituted in before the regexp is evaluated for matching purposes. So we have:</source>
          <target state="translated">Perl をよく知っている人であれば、エスケープシーケンスの話はよく知られているように思えるかもしれません。同様のエスケープシーケンスは二重引用符で囲まれた文字列でも使用されており、実際、Perl の正規表現はほとんどが二重引用符で囲まれた文字列として扱われています。これは、変数が正規表現でも使用できることを意味します。二重引用符で囲まれた文字列と同じように、正規表現の中の変数の値は、マッチングのために正規表現が評価される前に置換されます。ということで、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="3fd6cd86298d336909fb8326200590d5396e0f52" translate="yes" xml:space="preserve">
          <source>If you've chosen to use vac 4, be sure to run 4.4.0.3. Older versions will turn up nasty later on. For vac 5 be sure to run at least 5.0.1.0, but vac 5.0.2.6 or up is highly recommended. Note that since IBM has removed vac 5.0.2.1 through 5.0.2.5 from the software depot, these versions should be considered obsolete.</source>
          <target state="translated">vac 4を選択した場合は、4.4.4.0.3を必ず実行してください。古いバージョンは後で厄介なことになります。vac 5 の場合は、少なくとも 5.0.1.0 を実行してくださいが、 vac 5.0.2.6 以降を強く推奨します。IBM は vac 5.0.2.1 から 5.0.2.5 までをソフトウェアデポから削除したので、これらのバージョンは廃止されたものと考えてください。</target>
        </trans-unit>
        <trans-unit id="d7141035b834e9d56f2958df18eb9cabc9003c5d" translate="yes" xml:space="preserve">
          <source>If you've found a bug with the perl interpreter or one of the modules in the standard library (those that come with Perl), you can submit a bug report to the GitHub issue tracker at &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="translated">perlインタープリターまたは標準ライブラリ内のモジュールの1つ（Perlに付属しているもの）にバグを見つけた場合は、&lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https：//github.com/Perl/の&lt;/a&gt;GitHub課題追跡システムにバグレポートを送信できます。 perl5 / issues。</target>
        </trans-unit>
        <trans-unit id="7f36de392e6562a98fef168bd0f4fd2b6d55a056" translate="yes" xml:space="preserve">
          <source>If you've found a bug with the perl interpreter or one of the modules in the standard library (those that come with Perl), you can use the &lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt; utility that comes with Perl (&amp;gt;= 5.004). It collects information about your installation to include with your message, then sends the message to the right place.</source>
          <target state="translated">perlインタプリタまたは標準ライブラリのモジュールの1つ（Perlに付属するもの）にバグを見つけた場合は、Perlに付属する&lt;a href=&quot;perlbug&quot;&gt;perlbug&lt;/a&gt;ユーティリティ（&amp;gt; = 5.004）を使用できます。インストールに関する情報を収集してメッセージに含め、メッセージを適切な場所に送信します。</target>
        </trans-unit>
        <trans-unit id="b588af6702d40920fe6ce77142ddd4be23c82335" translate="yes" xml:space="preserve">
          <source>If you've just implemented a new feature, complete with doc, tests and well-commented code, a brief commit message will often suffice. If, however, you've just changed a single character deep in the parser or lexer, you might need to write a small novel to ensure that future readers understand what you did and why you did it.</source>
          <target state="translated">新しい機能を実装したばかりで、doc、テスト、コメント付きのコードであれば、簡単なコミットメッセージで十分です。しかし、パーサやレキサーの奥深くで一文字を変更しただけの場合は、何をしたのか、なぜそれをしたのかを読者に理解してもらうために、小さな小説を書く必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="f8a6a3763262120fa20c3dbe30b8abff9d5efbc9" translate="yes" xml:space="preserve">
          <source>If you've played with the examples above and tried to embed a script that</source>
          <target state="translated">上記の例で遊んでみて、スクリプトを埋め込んでみたら</target>
        </trans-unit>
        <trans-unit id="b894c5ed183f4f7ceceb8937af0c436c24867f7d" translate="yes" xml:space="preserve">
          <source>If you've read all the documentation in the document and the ones listed above, you're more than ready to hack on Perl.</source>
          <target state="translated">このドキュメントと上記のドキュメントをすべて読めば、Perl でハックする準備は十分にできています。</target>
        </trans-unit>
        <trans-unit id="f7a6adb80f0b785d2ca1e30e58d59926760d3865" translate="yes" xml:space="preserve">
          <source>If you've read this far in the docs, you've seen this:</source>
          <target state="translated">ドキュンでここまで読んでくれた人は</target>
        </trans-unit>
        <trans-unit id="a5397b1b280e497ccfa7136829a3dcfe46903bd5" translate="yes" xml:space="preserve">
          <source>If you've selected VMS syntax, and the file specification you pass to one of these routines contains a &quot;/&quot;, they assume you are using Unix emulation and apply the Unix syntax rules instead, for that function call only.</source>
          <target state="translated">VMS構文を選択していて、これらのルーチンに渡すファイル仕様に&quot;/&quot;が含まれている場合、Unixエミュレーションを使用していると見なされ、代わりにUnix構文ルールが適用され、その関数呼び出しにのみ適用されます。</target>
        </trans-unit>
        <trans-unit id="33caaa832315103fc3c31014628789c923502260" translate="yes" xml:space="preserve">
          <source>If you, as a user, do not need explicit access to the &quot;seen&quot; hash, then you can set the &lt;code&gt;Sparseseen&lt;/code&gt; option to allow Data::Dumper to eschew building the &quot;seen&quot; hash for scalars that are known not to possess more than one reference. This speeds up serialization considerably if you use the XS implementation.</source>
          <target state="translated">あなたは、ユーザとして、「見て」、ハッシュへの明示的なアクセスを必要としない場合は、設定することができ &lt;code&gt;Sparseseen&lt;/code&gt; データ:: Dumperを超える所持しないことが知られているスカラーのために、「見た」のハッシュを構築避けることを可能にするオプションを1つの参照。XS実装を使用すると、これによりシリアライゼーションが大幅にスピードアップします。</target>
        </trans-unit>
        <trans-unit id="5641fffcc326bff3bce0a7d7f55bb29dc536ec90" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;DESTROY&lt;/code&gt; method issues a warning during global destruction, the Perl interpreter will append the string &quot; during global destruction&quot; to the warning.</source>
          <target state="translated">&lt;code&gt;DESTROY&lt;/code&gt; メソッドがグローバル破棄中に警告を発行した場合、Perlインタープリターは「グローバル破棄中」という文字列を警告に追加します。</target>
        </trans-unit>
        <trans-unit id="e35bc3de6478c74b3aa05b11b90d2c08a9c1eb35" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;DESTROY&lt;/code&gt; method throws an error, this error will be ignored. It will not be sent to &lt;code&gt;STDERR&lt;/code&gt; and it will not cause the program to die. However, if your destructor is running inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; block, then the error will change the value of &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;DESTROY&lt;/code&gt; メソッドがエラーをスローした場合、このエラーは無視されます。 &lt;code&gt;STDERR&lt;/code&gt; には送信されず、プログラムが停止することもありません。ただし、デストラクタが &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; ブロック内で実行されている場合、エラーによって &lt;code&gt;$@&lt;/code&gt; 値が変更されます。</target>
        </trans-unit>
        <trans-unit id="fc569fc556abfc5922ff5d102893edd09c51cd29" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;DESTROY&lt;/code&gt; method throws an exception, this will not cause any control transfer beyond exiting the method. The exception will be reported to &lt;code&gt;STDERR&lt;/code&gt; as a warning, marked &quot;(in cleanup)&quot;, and Perl will continue with whatever it was doing before.</source>
          <target state="translated">&lt;code&gt;DESTROY&lt;/code&gt; メソッドが例外をスローした場合、メソッドを終了する以外に制御が転送されることはありません。例外は「（クリーンアップ中）」とマークされた警告として &lt;code&gt;STDERR&lt;/code&gt; に報告され、Perlは以前と同じように続行します。</target>
        </trans-unit>
        <trans-unit id="bd8f1a46e80e1b05c149003c578cc17ee1529e3e" translate="yes" xml:space="preserve">
          <source>If your AIX is installed with 64-bit support, you can expect 64-bit configurations to work. In combination with threads some tests might still fail.</source>
          <target state="translated">お使いの AIX が 64 ビットをサポートしてインストールされている場合は、64 ビットの設定が動作することが期待できます。スレッドとの組み合わせでは、いくつかのテストはまだ失敗するかもしれません。</target>
        </trans-unit>
        <trans-unit id="91cec945ceabbd679cf0509d145b2a724547b098" translate="yes" xml:space="preserve">
          <source>If your AIX system is installed with 64-bit support, you can expect 64-bit configurations to work. If you want to use 64-bit Perl on AIX 6.1 you need an APAR for a libc.a bug which affects (n)dbm_XXX functions. The APAR number for this problem is IZ39077.</source>
          <target state="translated">お使いの AIX システムが 64 ビットサポートでインストールされている場合、64 ビット構成でも動作することが期待できます。AIX 6.1 で 64 ビット Perl を使用したい場合、(n)dbm_XXX 関数に影響を与える libc.a バグに対する APAR が必要です。この問題の APAR 番号は IZ39077 です。</target>
        </trans-unit>
        <trans-unit id="70f3f72afc2e138648aa89e71840c2969a866fbe" translate="yes" xml:space="preserve">
          <source>If your EXISTS function returns true, Memoize will try to fetch the cached value by invoking &lt;code&gt;C-&amp;gt;FETCH(key)&lt;/code&gt; . MyExpirePolicy::FETCH should return the cached value. Otherwise, Memoize will call the memoized function to compute the appropriate value, and will store it into the cache by calling &lt;code&gt;C-&amp;gt;STORE(key, value)&lt;/code&gt; .</source>
          <target state="translated">EXISTS関数がtrueを返す場合、Memoizeは &lt;code&gt;C-&amp;gt;FETCH(key)&lt;/code&gt; を呼び出して、キャッシュされた値をフェッチしようとします。MyExpirePolicy :: FETCHはキャッシュされた値を返す必要があります。それ以外の場合、Memoizeはメモ化された関数を呼び出して適切な値を計算し、 &lt;code&gt;C-&amp;gt;STORE(key, value)&lt;/code&gt; 呼び出してキャッシュに保存します。</target>
        </trans-unit>
        <trans-unit id="24acb5b4fe58034fbc714327d4b7fa709ac07a2e" translate="yes" xml:space="preserve">
          <source>If your EXISTS function returns true, Memoize will try to fetch the cached value by invoking &lt;code&gt;C-&amp;gt;FETCH(key)&lt;/code&gt;. MyExpirePolicy::FETCH should return the cached value. Otherwise, Memoize will call the memoized function to compute the appropriate value, and will store it into the cache by calling &lt;code&gt;C-&amp;gt;STORE(key, value)&lt;/code&gt;.</source>
          <target state="translated">EXISTS関数がtrueを返す場合、メモ化は &lt;code&gt;C-&amp;gt;FETCH(key)&lt;/code&gt; を呼び出してキャッシュされた値をフェッチしようとします。MyExpirePolicy :: FETCHは、キャッシュされた値を返す必要があります。それ以外の場合、メモ化はメモ化された関数を呼び出して適切な値を計算し、 &lt;code&gt;C-&amp;gt;STORE(key, value)&lt;/code&gt; 呼び出してそれをキャッシュに保存します。</target>
        </trans-unit>
        <trans-unit id="0e28af787c875d4ef84c9b0c4d899259d2721791" translate="yes" xml:space="preserve">
          <source>If your PO and MO files are under a path elsewhere than &lt;code&gt;auto/&lt;/code&gt; , you may specify it using the &lt;code&gt;Path&lt;/code&gt; option.</source>
          <target state="translated">POファイルとMOファイルが &lt;code&gt;auto/&lt;/code&gt; 以外のパスの下にある場合は、 &lt;code&gt;Path&lt;/code&gt; オプションを使用して指定できます。</target>
        </trans-unit>
        <trans-unit id="6409d07584753033defae54495b9d4c75a783436" translate="yes" xml:space="preserve">
          <source>If your PO and MO files are under a path elsewhere than &lt;code&gt;auto/&lt;/code&gt;, you may specify it using the &lt;code&gt;Path&lt;/code&gt; option.</source>
          <target state="translated">POファイルとMOファイルが &lt;code&gt;auto/&lt;/code&gt; 以外のパスの下にある場合は、[ &lt;code&gt;Path&lt;/code&gt; ]オプションを使用して指定できます。</target>
        </trans-unit>
        <trans-unit id="58c89e96cd32d30e30553bcd6fbdd11d2690ecc7" translate="yes" xml:space="preserve">
          <source>If your Perl book isn't listed and you think it should be, let us know.</source>
          <target state="translated">もしあなたのPerlの本がリストになく、リストにあるべきだと思われる場合は、私たちに知らせてください。</target>
        </trans-unit>
        <trans-unit id="6d6e9b58c49da08447f00e52e9068c5bb7576426" translate="yes" xml:space="preserve">
          <source>If your Perl script is itself encoded in &lt;a href=&quot;#Unicode-Encodings&quot;&gt;UTF-8&lt;/a&gt;, the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma must be explicitly included to enable recognition of that (in string or regular expression literals, or in identifier names). &lt;b&gt;This is the only time when an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
utf8&lt;/code&gt; is needed.&lt;/b&gt; (See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;).</source>
          <target state="translated">Perlスクリプト自体が&lt;a href=&quot;#Unicode-Encodings&quot;&gt;UTF-8&lt;/a&gt;でエンコードされている &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 、use utf8プラグマを明示的に含めて、それを認識できるようにする必要があります（文字列または正規表現リテラル、または識別子名で）。&lt;b&gt; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; &lt;/b&gt;&lt;b&gt;明示的に&lt;a href=&quot;functions/use&quot;&gt;使用する&lt;/a&gt;必要があるのは、このときだけです。&lt;/b&gt;（&lt;a href=&quot;utf8&quot;&gt;utf8を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="17170cc5afbf6627bb42f8bd492f952db9b4e546" translate="yes" xml:space="preserve">
          <source>If your Perl script is itself encoded in &lt;a href=&quot;#Unicode-Encodings&quot;&gt;UTF-8&lt;/a&gt;, the &lt;code&gt;use utf8&lt;/code&gt; pragma must be explicitly included to enable recognition of that (in string or regular expression literals, or in identifier names). &lt;b&gt;This is the only time when an explicit &lt;code&gt;use utf8&lt;/code&gt; is needed.&lt;/b&gt; (See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;).</source>
          <target state="translated">Perlスクリプト自体が&lt;a href=&quot;#Unicode-Encodings&quot;&gt;UTF-8&lt;/a&gt;でエンコードされている &lt;code&gt;use utf8&lt;/code&gt; プラグマの使用を明示的に含めて、それを認識できるようにする必要があります（文字列または正規表現リテラル、あるいは識別子名で）。&lt;b&gt; &lt;code&gt;use utf8&lt;/code&gt; &lt;/b&gt;&lt;b&gt;明示的に使用する必要があるのはこれだけです。&lt;/b&gt;（&lt;a href=&quot;utf8&quot;&gt;utf8を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="1456eed38b989e671412e5dabebc6b17a35fdee8" translate="yes" xml:space="preserve">
          <source>If your Perl success stories and testimonials may be of help to others who wish to advocate the use of Perl in their applications, or if you wish to simply express your gratitude to Larry and the Perl developers, please write to perl-thanks@perl.org .</source>
          <target state="translated">あなたのPerlのサクセスストーリーや証言が、アプリケーションでPerlの使用を推奨したいと考えている他の人の助けになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="bb4511b53500ce7e796c6be816fd150d579ce6bd" translate="yes" xml:space="preserve">
          <source>If your Perl was configured with &lt;b&gt;-Accflags=-DPERL_MEM_LOG&lt;/b&gt;, setting the environment variable &lt;code&gt;PERL_MEM_LOG&lt;/code&gt; enables logging debug messages. The value has the form &lt;code&gt;&amp;lt;&lt;i&gt;number&lt;/i&gt;&amp;gt;[m][s][t]&lt;/code&gt;, where &lt;code&gt;&lt;i&gt;number&lt;/i&gt;&lt;/code&gt; is the file descriptor number you want to write to (2 is default), and the combination of letters specifies that you want information about (m)emory and/or (s)v, optionally with (t)imestamps. For example, &lt;code&gt;PERL_MEM_LOG=1mst&lt;/code&gt; logs all information to stdout. You can write to other opened file descriptors in a variety of ways:</source>
          <target state="translated">Perlが&lt;b&gt;-Accflags = -DPERL_MEM_LOG&lt;/b&gt;で構成されている場合、環境変数 &lt;code&gt;PERL_MEM_LOG&lt;/code&gt; を設定すると、デバッグメッセージのロギングが有効になります。値の形式は &lt;code&gt;&amp;lt;&lt;i&gt;number&lt;/i&gt;&amp;gt;[m][s][t]&lt;/code&gt; で、 &lt;code&gt;&lt;i&gt;number&lt;/i&gt;&lt;/code&gt; は書き込み先のファイル記述子番号（2がデフォルト）であり、文字の組み合わせは（m）に関する情報が必要であることを指定しますemoryおよび/または（s）v、オプションで（t）imestamps。たとえば、 &lt;code&gt;PERL_MEM_LOG=1mst&lt;/code&gt; は、すべての情報をstdoutに記録します。開いている他のファイル記述子にさまざまな方法で書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="283276e9d183ad9eef7a4c2f27ba79df3995c5ec" translate="yes" xml:space="preserve">
          <source>If your algorithm requires that &lt;code&gt;reduce&lt;/code&gt; produce an identity value, then make sure that you always pass that identity value as the first argument to prevent &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; being returned</source>
          <target state="translated">アルゴリズムで &lt;code&gt;reduce&lt;/code&gt; がID値を生成する必要がある場合は、必ずそのID値を最初の引数として渡して、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されないようにしてください</target>
        </trans-unit>
        <trans-unit id="0fc2dbb19ef8bc25dbcf8ac8f222951284588b99" translate="yes" xml:space="preserve">
          <source>If your algorithm requires that &lt;code&gt;reduce&lt;/code&gt; produce an identity value, then make sure that you always pass that identity value as the first argument to prevent &lt;code&gt;undef&lt;/code&gt; being returned</source>
          <target state="translated">アルゴリズムで &lt;code&gt;reduce&lt;/code&gt; がID値を生成する必要がある場合は、 &lt;code&gt;undef&lt;/code&gt; が返されないように、常にそのID値を最初の引数として渡すようにしてください。</target>
        </trans-unit>
        <trans-unit id="711905ae29609d52da565bc6443425ee76c015f8" translate="yes" xml:space="preserve">
          <source>If your application requires accepting data from untrusted sources, you are best off with a less powerful and more-likely safe serialization format and implementation. If your data is sufficiently simple, &lt;a href=&quot;Cpanel::JSON::XS&quot;&gt;Cpanel::JSON::XS&lt;/a&gt;, &lt;a href=&quot;Data::MessagePack&quot;&gt;Data::MessagePack&lt;/a&gt; or &lt;a href=&quot;sereal&quot;&gt;Sereal&lt;/a&gt; are the best choices and offer maximum interoperability, but note that Sereal is &lt;a href=&quot;Sereal::Decoder#ROBUSTNESS&quot;&gt;unsafe by default&lt;/a&gt;.</source>
          <target state="translated">アプリケーションで信頼できないソースからのデータを受け入れる必要がある場合は、それほど強力ではなく、安全性の高いシリアル化形式と実装を使用するのが最善です。データが十分に単純な場合は、&lt;a href=&quot;Cpanel::JSON::XS&quot;&gt;Cpanel :: JSON :: XS&lt;/a&gt;、&lt;a href=&quot;Data::MessagePack&quot;&gt;Data :: MessagePack、&lt;/a&gt;または&lt;a href=&quot;sereal&quot;&gt;Sereal&lt;/a&gt;が最良の選択であり、最大限の相互運用性を提供&lt;a href=&quot;Sereal::Decoder#ROBUSTNESS&quot;&gt;します&lt;/a&gt;が、Serealはデフォルトでは安全ではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="826651d97de1fb76050036181700ee31a9d7cf34" translate="yes" xml:space="preserve">
          <source>If your application requires accepting data from untrusted sources, you are best off with a less powerful and more-likely safe serialization format and implementation. If your data is sufficiently simple, JSON is a good choice and offers maximum interoperability.</source>
          <target state="translated">アプリケーションが信頼されていないソースからデータを受け取る必要がある場合は、あまり強力ではなく、より安全なシリアライズフォーマットと実装を使用するのが良いでしょう。データが十分に単純な場合は、JSONが良い選択であり、最大限の相互運用性を提供します。</target>
        </trans-unit>
        <trans-unit id="6fedf0cadcf133b09c8efb7dc310cff7b7302cdf" translate="yes" xml:space="preserve">
          <source>If your changes are in a single git commit, run the following commands to generate the patch file and attach it to your bug report:</source>
          <target state="translated">変更内容が単一の git コミットにある場合は、以下のコマンドを実行してパッチファイルを生成し、それをバグレポートに添付します。</target>
        </trans-unit>
        <trans-unit id="db2c1fd426ed9f2c60db2929723c4b3e4c8b99fa" translate="yes" xml:space="preserve">
          <source>If your changes are in multiple commits, generate a patch file for each one and provide them to perlbug's &lt;code&gt;-p&lt;/code&gt; option separated by commas:</source>
          <target state="translated">変更が複数のコミットにある場合は、それぞれのパッチファイルを生成し、それらをカンマで区切ってperlbugの &lt;code&gt;-p&lt;/code&gt; オプションに提供します。</target>
        </trans-unit>
        <trans-unit id="e23115cc45aeaf527b25ea3227a4ca58a4bbcf8b" translate="yes" xml:space="preserve">
          <source>If your class does have an &lt;code&gt;AUTOLOAD&lt;/code&gt; method, we strongly recommend that you override &lt;code&gt;can&lt;/code&gt; in your class as well. Your overridden &lt;code&gt;can&lt;/code&gt; method should return a subroutine reference for any method that your &lt;code&gt;AUTOLOAD&lt;/code&gt; responds to.</source>
          <target state="translated">クラスに &lt;code&gt;AUTOLOAD&lt;/code&gt; メソッドがある場合は、クラスでも &lt;code&gt;can&lt;/code&gt; をオーバーライドすることを強くお勧めします。オーバーライドされた &lt;code&gt;can&lt;/code&gt; メソッドは、 &lt;code&gt;AUTOLOAD&lt;/code&gt; が応答するすべてのメソッドのサブルーチン参照を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="94e34cf5528ccd5dcdb342c8820f7f03af06ab35" translate="yes" xml:space="preserve">
          <source>If your class has a better way of doing roles, then you should not load this class and instead simply say that your class</source>
          <target state="translated">もしあなたのクラスがロールを行うためのより良い方法を持っているならば、このクラスをロードせず、代わりにあなたのクラスが</target>
        </trans-unit>
        <trans-unit id="ce7692bb0712bd055e295162eb35d771d86fcad6" translate="yes" xml:space="preserve">
          <source>If your class responds to method calls via &lt;code&gt;AUTOLOAD&lt;/code&gt; , you may want to overload &lt;code&gt;can&lt;/code&gt; to return a subroutine reference for methods which your &lt;code&gt;AUTOLOAD&lt;/code&gt; method handles.</source>
          <target state="translated">クラスが &lt;code&gt;AUTOLOAD&lt;/code&gt; を介したメソッド呼び出しに応答する場合、 &lt;code&gt;AUTOLOAD&lt;/code&gt; メソッドが処理するメソッドのサブルーチン参照を返すように &lt;code&gt;can&lt;/code&gt; をオーバーロードすることができます。</target>
        </trans-unit>
        <trans-unit id="d2801f0953803749827f324dc366675780126e87" translate="yes" xml:space="preserve">
          <source>If your class responds to method calls via &lt;code&gt;AUTOLOAD&lt;/code&gt;, you may want to overload &lt;code&gt;can&lt;/code&gt; to return a subroutine reference for methods which your &lt;code&gt;AUTOLOAD&lt;/code&gt; method handles.</source>
          <target state="translated">クラスが &lt;code&gt;AUTOLOAD&lt;/code&gt; を介してメソッド呼び出しに応答する場合は、 &lt;code&gt;can&lt;/code&gt; をオーバーロードして、 &lt;code&gt;AUTOLOAD&lt;/code&gt; メソッドが処理するメソッドのサブルーチン参照を返すことができます。</target>
        </trans-unit>
        <trans-unit id="7cb0c308f5c747cd8786d190dad063cb23775dff" translate="yes" xml:space="preserve">
          <source>If your code expects an octet sequence this can be used to validate that you've received one:</source>
          <target state="translated">コードがオクテットシーケンスを期待している場合は、これを使用して受信したことを検証することができます。</target>
        </trans-unit>
        <trans-unit id="d51ef4c74c99126a798f834a23d66ffbb341d516" translate="yes" xml:space="preserve">
          <source>If your code is destined for systems with severely constrained (or missing!) virtual memory systems then you want to be</source>
          <target state="translated">もしあなたのコードが、非常に制約の多い(あるいは不足している)仮想メモリシステム向けのものであるならば、次のようにしたいと思います。</target>
        </trans-unit>
        <trans-unit id="b8ec960b62faa8f2d9e01172beeee1747d962ecd" translate="yes" xml:space="preserve">
          <source>If your code is to run on Perl versions earlier than 5.20, it is worthwhile to note that using &lt;code&gt;$`&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; slows down regexp matching quite a bit, while &lt;code&gt;$&amp;amp;&lt;/code&gt; slows it down to a lesser extent, because if they are used in one regexp in a program, they are generated for</source>
          <target state="translated">コードが5.20より前のバージョンのPerlで実行される場合、 &lt;code&gt;$`&lt;/code&gt; と &lt;code&gt;$'&lt;/code&gt; を使用すると、正規表現のマッチングがかなり遅くなりますが、 &lt;code&gt;$&amp;amp;&lt;/code&gt; を使用すると、速度が遅くなることに注意してください。プログラム内の1つの正規表現、それらは生成されます</target>
        </trans-unit>
        <trans-unit id="4b7710e8f3ca27397097d7cc62e45c608961218a" translate="yes" xml:space="preserve">
          <source>If your code is to run on various platforms, keep in mind that the upper limit depends on the platform. It is much larger on 64-bit word sizes than 32-bit ones.</source>
          <target state="translated">あなたのコードが様々なプラットフォームで動作する場合、その上限はプラットフォームによって異なることを覚えておいてください。32ビットよりも64ビットのワードサイズの方がはるかに大きくなります。</target>
        </trans-unit>
        <trans-unit id="c17494161785039e334258f44851b99624e54807" translate="yes" xml:space="preserve">
          <source>If your code is to run on various platforms, keep in mind that the upper limit depends on the platform. It is much larger on 64-bit word sizes than 32-bit ones. For 32-bit integers, &lt;code&gt;IV_MAX&lt;/code&gt; equals &lt;code&gt;0x7FFFFFFF&lt;/code&gt;, for 64-bit integers, &lt;code&gt;IV_MAX&lt;/code&gt; equals &lt;code&gt;0x7FFFFFFFFFFFFFFF&lt;/code&gt;.</source>
          <target state="translated">コードをさまざまなプラットフォームで実行する場合、上限はプラットフォームによって異なることに注意してください。64ビットのワードサイズでは、32ビットのワードサイズよりもはるかに大きくなります。32ビット整数の場合、 &lt;code&gt;IV_MAX&lt;/code&gt; は &lt;code&gt;0x7FFFFFFF&lt;/code&gt; に等しく、64ビット整数の場合、 &lt;code&gt;IV_MAX&lt;/code&gt; は &lt;code&gt;0x7FFFFFFFFFFFFFFF&lt;/code&gt; に等しくなります。</target>
        </trans-unit>
        <trans-unit id="f35b1b808d1504007b3ea085214451b1ee61358c" translate="yes" xml:space="preserve">
          <source>If your code just uses the 52 letters A-Z and a-z, plus SPACE, the digits 0-9, and the punctuation characters that Perl uses, plus a few controls that are denoted by escape sequences like &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\t&lt;/code&gt; , then there's nothing special about using Perl, and your code may very well work on an ASCII machine without change.</source>
          <target state="translated">コードが52文字のAZとaz、およびSPACE、数字0-9、およびPerlが使用する句読文字、さらに &lt;code&gt;\n&lt;/code&gt; や &lt;code&gt;\t&lt;/code&gt; などのエスケープシーケンスで示されるいくつかのコントロールを使用している場合、特別なことは何もありません。 Perlの使用について、そしてあなたのコードは変更なしでASCIIマシン上で非常にうまく機能するかもしれません。</target>
        </trans-unit>
        <trans-unit id="fd44ae53a2c35816d36a21d629151afa4456598c" translate="yes" xml:space="preserve">
          <source>If your code just uses the 52 letters A-Z and a-z, plus SPACE, the digits 0-9, and the punctuation characters that Perl uses, plus a few controls that are denoted by escape sequences like &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\t&lt;/code&gt;, then there's nothing special about using Perl, and your code may very well work on an ASCII machine without change.</source>
          <target state="translated">コードでAZとazの52文字、スペース、0〜9の数字、Perlが使用する句読文字、および &lt;code&gt;\n&lt;/code&gt; や &lt;code&gt;\t&lt;/code&gt; などのエスケープシーケンスで示されるいくつかのコントロールを使用している場合、特別なことは何もありません。 Perlの使用について、コードは変更なしでASCIIマシンで非常にうまく機能する可能性があります。</target>
        </trans-unit>
        <trans-unit id="bc20635c4dbc0c4a81b5c97270c1432edba3070f" translate="yes" xml:space="preserve">
          <source>If your code needs to be compatible with versions of perl without &lt;code&gt;use feature 'unicode_strings';&lt;/code&gt;, you can force Unicode semantics on a given string:</source>
          <target state="translated">コードが &lt;code&gt;use feature 'unicode_strings';&lt;/code&gt; を使用せずにperlのバージョンと互換性がある必要がある場合。、特定の文字列にUnicodeセマンティクスを強制できます。</target>
        </trans-unit>
        <trans-unit id="8e9b4a996206aa3ecbfc36df229dca4fb6c7a7b5" translate="yes" xml:space="preserve">
          <source>If your code still needs to run on older versions, stick to &lt;code&gt;foreach&lt;/code&gt; for your topicalizer and you will be less unhappy.</source>
          <target state="translated">それでも古いバージョンでコードを実行する必要がある場合は、ト &lt;code&gt;foreach&lt;/code&gt; を使用すると、不満が減ります。</target>
        </trans-unit>
        <trans-unit id="dcc0823ff9797cfd85918a8c234e7eca9a51dc4f" translate="yes" xml:space="preserve">
          <source>If your command contains &lt;b&gt;special characters&lt;/b&gt; (&amp;lt; &amp;gt; | &amp;amp;), it will be internally stringified before executing the command, to avoid that these special characters are escaped and passed as arguments instead of retaining their special meaning.</source>
          <target state="translated">コマンドに&lt;b&gt;特殊文字&lt;/b&gt;（&amp;lt;&amp;gt; |＆）が含まれている場合、コマンドを実行する前に内部で文字列化され、これらの特殊文字が特殊な意味を保持する代わりにエスケープされて引数として渡されるのを回避します。</target>
        </trans-unit>
        <trans-unit id="43394cfe59583c3fd94893ba6ef409bba1f68bbd" translate="yes" xml:space="preserve">
          <source>If your computer can grow the character set without further processing, you can go ahead and use it. This is called a</source>
          <target state="translated">コンピュータがそれ以上の処理をせずに文字セットを成長させることができるならば と呼ばれています。</target>
        </trans-unit>
        <trans-unit id="cf42d5b15f10438a9ce2c86e1004158d46b18003" translate="yes" xml:space="preserve">
          <source>If your copy of Perl is recent enough to contain this documentation (version 5.002 or later), then the perl library (and</source>
          <target state="translated">Perl のコピーがこのドキュメントを含むのに十分な最新のものであれば (バージョン 5.002 以降)、Perl ライブラリ (と</target>
        </trans-unit>
        <trans-unit id="2f8c2d2817394bbcc4a451c1a33b9dff96a282f0" translate="yes" xml:space="preserve">
          <source>If your device is not rooted, you may still be in luck. Try running this:</source>
          <target state="translated">お使いのデバイスがルート化されていない場合は、まだ運が良いかもしれません。これを実行してみてください。</target>
        </trans-unit>
        <trans-unit id="2fc9b0cc9eec68d672ffff71ad1ff12aed25c2cc" translate="yes" xml:space="preserve">
          <source>If your encoding can work with PerlIO but needs line buffering, you MUST define this method so it returns true. 7bit ISO-2022 encodings are one example that needs this. When this method is missing, false is assumed.</source>
          <target state="translated">エンコーディングが PerlIO で動作するが、行バッファリングが必要な場合は、このメソッドを定義して true を返すようにしなければなりません(MUST)。7bit ISO-2022 エンコーディングは、これを必要とする一例です。このメソッドがない場合は false と見なされます。</target>
        </trans-unit>
        <trans-unit id="d924438284770c83006ec82d036605b95adc1613" translate="yes" xml:space="preserve">
          <source>If your encoding does not support PerlIO for some reasons, just;</source>
          <target state="translated">何らかの理由でエンコーディングがPerlIOをサポートしていない場合は、ただ。</target>
        </trans-unit>
        <trans-unit id="67ac503167790c1d42d0fa145e05ebf3299a6484" translate="yes" xml:space="preserve">
          <source>If your event needs to have extra effects on the &lt;a href=&quot;Test2::Hub&quot;&gt;Test2::Hub&lt;/a&gt; you can override this method.</source>
          <target state="translated">イベントが&lt;a href=&quot;Test2::Hub&quot;&gt;Test2 :: Hubに&lt;/a&gt;追加の影響を与える必要がある場合は、このメソッドをオーバーライドできます。</target>
        </trans-unit>
        <trans-unit id="1bb14712099b199ef0cd902ac0e502361e5d3ab8" translate="yes" xml:space="preserve">
          <source>If your executables start with something like #!perl or #!/usr/bin/perl MakeMaker will change this to the path of the perl 'Makefile.PL' was invoked with so the programs will be sure to run properly even if perl is not in /usr/bin/perl.</source>
          <target state="translated">実行ファイルが #!perl や #!/usr/bin/perl で始まっている場合、MakeMaker はこのパスを 'Makefile.PL' が起動されたときの perl のパスに変更するので、たとえ perl が /usr/bin/perl になくてもプログラムは正しく動作します。</target>
        </trans-unit>
        <trans-unit id="0c644837e9e9bd2635823c6fa674e7d01fcd0f60" translate="yes" xml:space="preserve">
          <source>If your extension uses some features of Perl which are not available on older releases of Perl, your users would appreciate an early meaningful warning. You would probably put this information into the</source>
          <target state="translated">あなたの拡張機能が古いリリースの Perl で利用できない Perl の機能を使用している場合、ユーザは早期の意味のある警告を評価するでしょう。おそらく、この情報を</target>
        </trans-unit>
        <trans-unit id="adbe147193e70e68bb2371038fd445f29bb86c7b" translate="yes" xml:space="preserve">
          <source>If your function already returns a reference, you don't need to create the reference yourself.</source>
          <target state="translated">関数がすでに参照を返している場合は、自分で参照を作成する必要はありません。</target>
        </trans-unit>
        <trans-unit id="8e3814e00e4bd2f311a16402f4ba979bbd48ac96" translate="yes" xml:space="preserve">
          <source>If your gcc is configured to use GNU as and ld but you want to use the Solaris ones instead to build perl, then you'll need to add -B/usr/ccs/bin/ to the gcc command line. One convenient way to do that is with</source>
          <target state="translated">gccがGNU asとldを使うように設定されているが、代わりにSolarisのものを使ってperlをビルドしたい場合は、-B/usr/ccs/bin/をgccコマンドラインに追加する必要があります。これを行う便利な方法の一つは</target>
        </trans-unit>
        <trans-unit id="c36d951537cc72fb144d389f8c16c06615d06bc8" translate="yes" xml:space="preserve">
          <source>If your goal is purely monitoring of events use the &lt;code&gt;Test2::Hub-&amp;gt;listen()&lt;/code&gt; method exported by Test::More to watch events as they are fired. If you wish to modify results before they go to TAP look at the &lt;code&gt;Test2::Hub-&amp;gt;filter()&lt;/code&gt; method.</source>
          <target state="translated">目標が純粋にイベントの監視である場合は、Test :: Moreによってエクスポートされた &lt;code&gt;Test2::Hub-&amp;gt;listen()&lt;/code&gt; メソッドを使用して、イベントが発生したときにイベントを監視します。結果をTAPに移動する前に変更する場合は、 &lt;code&gt;Test2::Hub-&amp;gt;filter()&lt;/code&gt; メソッドを確認してください。</target>
        </trans-unit>
        <trans-unit id="5872fc905315842d011082a682a6367cfb7ca9e6" translate="yes" xml:space="preserve">
          <source>If your hash could have repeated values, the methods above will only find one of the associated keys. This may or may not worry you. If it does worry you, you can always reverse the hash into a hash of arrays instead:</source>
          <target state="translated">ハッシュの値が繰り返される可能性がある場合、上記の方法は関連するキーのうちの1つしか見つけられません。これは気になるかもしれませんし、気にならないかもしれません。もし心配ならば、代わりにハッシュを配列のハッシュに逆引きすることもできます。</target>
        </trans-unit>
        <trans-unit id="ef30095e54f0686dc32e619850a74327f603829f" translate="yes" xml:space="preserve">
          <source>If your host system's architecture is 32 bits, remember to change the &lt;code&gt;x86_64&lt;/code&gt;'s below to &lt;code&gt;x86&lt;/code&gt;'s. On a similar vein, the examples below use the 4.8 toolchain; if you want to use something older or newer (for example, the 4.4.3 toolchain included in the 8th revision of the NDK), just change those to the relevant version.</source>
          <target state="translated">ホストシステムのアーキテクチャが32ビットの場合は、以下の &lt;code&gt;x86_64&lt;/code&gt; を &lt;code&gt;x86&lt;/code&gt; に変更することを忘れないでください。同様に、以下の例では4.8ツールチェーンを使用しています。古いものや新しいもの（たとえば、NDKの8番目のリビジョンに含まれている4.4.3ツールチェーン）を使用する場合は、それらを関連するバージョンに変更するだけです。</target>
        </trans-unit>
        <trans-unit id="a7de42f17abf69fc8056c809db5d175a47bd9c23" translate="yes" xml:space="preserve">
          <source>If your input is binary, and is supposed to remain binary, you shouldn't decode it to a text string, of course. But in all other cases, you should decode it.</source>
          <target state="translated">入力がバイナリであり、バイナリのままであることが前提となっている場合、もちろんそれをテキスト文字列にデコードすべきではありません。しかし、それ以外の場合はデコードしなければなりません。</target>
        </trans-unit>
        <trans-unit id="d2667a072564b25eaaca13a334f7f9d262c4dc4d" translate="yes" xml:space="preserve">
          <source>If your lexicon is a tied hash the simple act of caching the compiled value can be fatal.</source>
          <target state="translated">辞書がタイドハッシュの場合、コンパイルされた値をキャッシュするという単純な行為は致命的なものになります。</target>
        </trans-unit>
        <trans-unit id="84a874bfb13cfbdc7a992429f47c0892596ec6c2" translate="yes" xml:space="preserve">
          <source>If your locale environment variables (&lt;code&gt;LC_ALL&lt;/code&gt; , &lt;code&gt;LC_CTYPE&lt;/code&gt; , &lt;code&gt;LANG&lt;/code&gt; ) contain the strings 'UTF-8' or 'UTF8' (case-insensitive matching), the default encoding of your &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , and &lt;code&gt;STDERR&lt;/code&gt; , and of &lt;b&gt;any subsequent file open&lt;/b&gt;, is UTF-8.</source>
          <target state="translated">ロケール環境変数（場合 &lt;code&gt;LC_ALL&lt;/code&gt; 、 &lt;code&gt;LC_CTYPE&lt;/code&gt; 、 &lt;code&gt;LANG&lt;/code&gt; が）文字列「UTF8」または「UTF8」（大文字と小文字を区別しないマッチング）を含有し、デフォルトのあなたのエンコーディング &lt;code&gt;STDIN&lt;/code&gt; 、 &lt;code&gt;STDOUT&lt;/code&gt; 、および &lt;code&gt;STDERR&lt;/code&gt; 、との&lt;b&gt;それ以降のファイルのオープン&lt;/b&gt;、 UTF-8です。</target>
        </trans-unit>
        <trans-unit id="48763bb2696546d08447fe45d15a3762e501f27c" translate="yes" xml:space="preserve">
          <source>If your locale environment variables (&lt;code&gt;LC_ALL&lt;/code&gt;, &lt;code&gt;LC_CTYPE&lt;/code&gt;, &lt;code&gt;LANG&lt;/code&gt;) contain the strings 'UTF-8' or 'UTF8' (case-insensitive matching), the default encoding of your &lt;code&gt;STDIN&lt;/code&gt;, &lt;code&gt;STDOUT&lt;/code&gt;, and &lt;code&gt;STDERR&lt;/code&gt;, and of &lt;b&gt;any subsequent file open&lt;/b&gt;, is UTF-8.</source>
          <target state="translated">ロケール環境変数（ &lt;code&gt;LC_ALL&lt;/code&gt; 、 &lt;code&gt;LC_CTYPE&lt;/code&gt; 、 &lt;code&gt;LANG&lt;/code&gt; ）に文字列「UTF-8」または「UTF8」（大文字と小文字を区別しない一致）が含まれている &lt;code&gt;STDIN&lt;/code&gt; 、STDIN、 &lt;code&gt;STDOUT&lt;/code&gt; 、 &lt;code&gt;STDERR&lt;/code&gt; 、および&lt;b&gt;その後に開くファイル&lt;/b&gt;のデフォルトのエンコーディング、 UTF-8です。</target>
        </trans-unit>
        <trans-unit id="6549b9662c9333f9038a43e101cb863214588ba8" translate="yes" xml:space="preserve">
          <source>If your locale is a UTF-8 locale, starting in Perl v5.20, Perl works well for all categories except &lt;code&gt;LC_COLLATE&lt;/code&gt; dealing with sorting and the &lt;code&gt;cmp&lt;/code&gt; operator.</source>
          <target state="translated">ロケールは、PerlのV5.20以降でUTF-8ロケールであれば、Perlは除くすべてのカテゴリに適しています &lt;code&gt;LC_COLLATE&lt;/code&gt; のソートを扱うと &lt;code&gt;cmp&lt;/code&gt; 演算子。</target>
        </trans-unit>
        <trans-unit id="7ca7f425bac55c9b318a8c22ef06af377bf476b0" translate="yes" xml:space="preserve">
          <source>If your locale is a UTF-8 locale, starting in Perl v5.26, Perl works well for all categories; before this, starting with Perl v5.20, it works for all categories but &lt;code&gt;LC_COLLATE&lt;/code&gt;, which deals with sorting and the &lt;code&gt;cmp&lt;/code&gt; operator. But note that the standard &lt;code&gt;&lt;a href=&quot;Unicode::Collate&quot;&gt;Unicode::Collate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;Unicode::Collate::Locale&quot;&gt;Unicode::Collate::Locale&lt;/a&gt;&lt;/code&gt; modules offer much more powerful solutions to collation issues, and work on earlier releases.</source>
          <target state="translated">ロケールがUTF-8ロケールである場合、Perl v5.26以降、Perlはすべてのカテゴリで適切に機能します。これ以前は、Perl v5.20以降、並べ替えと &lt;code&gt;cmp&lt;/code&gt; 演算子を処理する &lt;code&gt;LC_COLLATE&lt;/code&gt; を除くすべてのカテゴリで機能します。ただし、標準の &lt;code&gt;&lt;a href=&quot;Unicode::Collate&quot;&gt;Unicode::Collate&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;Unicode::Collate::Locale&quot;&gt;Unicode::Collate::Locale&lt;/a&gt;&lt;/code&gt; モジュールは、照合の問題に対してはるかに強力なソリューションを提供し、以前のリリースで機能することに注意してください。</target>
        </trans-unit>
        <trans-unit id="b3b150d3cc1b32cbef03e749b88c3f5c90012ceb" translate="yes" xml:space="preserve">
          <source>If your newly minted styles refer to any new #variables, you'll need to define a callback subroutine that will populate (or modify) those variables. They are then available for use in the style you've chosen.</source>
          <target state="translated">新たに作成したスタイルが新しい#変数を参照している場合、それらの変数を入力(または修正)するコールバックサブルーチンを定義する必要があります。これらの変数は、あなたが選択したスタイルで使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="db09b35e2a7d627ad25d25e5e66ae789bbe364b8" translate="yes" xml:space="preserve">
          <source>If your operating system supports a proper mv(1) utility or its functional equivalent, this works:</source>
          <target state="translated">オペレーティングシステムが適切な mv(1)ユーティリティやその機能的な等価物をサポートしていれば、これは動作します。</target>
        </trans-unit>
        <trans-unit id="3bc865c47f68e828a2747632075834057f8b741e" translate="yes" xml:space="preserve">
          <source>If your parser object has been set to accept other formatting codes, then they will be presented like these B/C/F/I codes -- i.e., without any attributes.</source>
          <target state="translated">パーサオブジェクトが他のフォーマットコードを受け入れるように設定されている場合、これらのB/C/F/Iコードのように表示されます。</target>
        </trans-unit>
        <trans-unit id="b728e9092f3f9368f8a8be6c5ce7886b0a62de25" translate="yes" xml:space="preserve">
          <source>If your patch changes code (rather than just changing documentation), you should also include one or more test cases which illustrate the bug you're fixing or validate the new functionality you're adding. In general, you should update an existing test file rather than create a new one.</source>
          <target state="translated">パッチでコードを変更する場合 (ドキュメントを変更するだけではなく)、修正するバグを説明したり、追加する新機能を検証するためのテストケースを一つ以上含めるべきです。一般的には、新しいテストファイルを作成するよりも既存のテストファイルを更新するべきです。</target>
        </trans-unit>
        <trans-unit id="1c8689164a8ea6c3d7088da54ac1d855f027a272" translate="yes" xml:space="preserve">
          <source>If your perl does not support times larger than &lt;code&gt;2^31&lt;/code&gt; seconds then this module is likely to fail at processing dates beyond the year 2038. There are moves afoot to fix that in perl. Alternatively use 64 bit perl. Or if none of those are options, use the &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; module which has support for years well into the future and past.</source>
          <target state="translated">perlが &lt;code&gt;2^31&lt;/code&gt; 秒を超える時間をサポートしていない場合、このモジュールは2038年以降の処理日に失敗する可能性があります。perlでそれを修正するための動きがあります。または、64ビットのperlを使用します。または、これらのいずれもオプションではない場合は、将来および過去の何年にもわたってサポートされている&lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt;モジュールを使用してください。</target>
        </trans-unit>
        <trans-unit id="78a3de11301e669e248cee7c9e70b2562ff6e9f5" translate="yes" xml:space="preserve">
          <source>If your perl does not support times larger than &lt;code&gt;2^31&lt;/code&gt; seconds then this module is likely to fail at processing dates beyond the year 2038. There are moves afoot to fix that in perl. Alternatively use 64 bit perl. Or if none of those are options, use the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module which has support for years well into the future and past.</source>
          <target state="translated">perlが &lt;code&gt;2^31&lt;/code&gt; 秒より長い時間をサポートしていない場合、このモジュールは2038年を超える日付の処理で失敗する可能性があります。perlでそれを修正する動きが進行中です。または、64ビットperlを使用します。または、これらのいずれもオプションではない場合は、将来および過去まで何年​​もサポートされている&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt;モジュールを使用します。</target>
        </trans-unit>
        <trans-unit id="b5f6d77f27ea6c645390efe18bf989b76fa95e9b" translate="yes" xml:space="preserve">
          <source>If your perl is compiled with &lt;code&gt;-DDEBUGGING&lt;/code&gt; , you may use the &lt;b&gt;-Dr&lt;/b&gt; flag on the command line.</source>
          <target state="translated">perlが &lt;code&gt;-DDEBUGGING&lt;/code&gt; でコンパイルされている場合、コマンドラインで&lt;b&gt;-Dr&lt;/b&gt;フラグを使用できます。</target>
        </trans-unit>
        <trans-unit id="4c77f5e67615687160ce5a2c5aa3da747ca2d11d" translate="yes" xml:space="preserve">
          <source>If your perl is compiled with &lt;code&gt;-DDEBUGGING&lt;/code&gt;, you may use the &lt;b&gt;-Dr&lt;/b&gt; flag on the command line, and &lt;code&gt;-Drv&lt;/code&gt; for more verbose information.</source>
          <target state="translated">perlが &lt;code&gt;-DDEBUGGING&lt;/code&gt; を使用してコンパイルされている場合は、コマンドラインで&lt;b&gt;-Dr&lt;/b&gt;フラグを使用し、詳細情報については &lt;code&gt;-Drv&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="6fb3bbcc486c0ac676b28f725bda572e8ce7d210" translate="yes" xml:space="preserve">
          <source>If your perl is using Perl's malloc() and was compiled with the necessary switches (this is the default), then it will print memory usage statistics after compiling your code when &lt;code&gt;$ENV{PERL_DEBUG_MSTATS}
&amp;gt; 1&lt;/code&gt; , and before termination of the program when &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt;= 1&lt;/code&gt; . The report format is similar to the following example:</source>
          <target state="translated">perlがPerlのmalloc（）を使用していて、必要なスイッチ（これがデフォルトです）を使用してコンパイルされている場合、 &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt; 1&lt;/code&gt; ときにコードをコンパイルした後、次のときにプログラムを終了する前に、メモリ使用統計を出力します &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt;= 1&lt;/code&gt; 。レポートの形式は次の例のようになります。</target>
        </trans-unit>
        <trans-unit id="3b5e6d64fef920594f60da6d6dc6a30084b30ce5" translate="yes" xml:space="preserve">
          <source>If your perl is using Perl's malloc() and was compiled with the necessary switches (this is the default), then it will print memory usage statistics after compiling your code when &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt; 1&lt;/code&gt;, and before termination of the program when &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt;= 1&lt;/code&gt;. The report format is similar to the following example:</source>
          <target state="translated">perlがPerlのmalloc（）を使用していて、必要なスイッチを使用してコンパイルされている場合（これがデフォルトです）、 &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt; 1&lt;/code&gt; 場合はコードをコンパイルした後、プログラムが終了する前にメモリ使用量の統計を出力します。 &lt;code&gt;$ENV{PERL_DEBUG_MSTATS} &amp;gt;= 1&lt;/code&gt; 。レポートの形式は、次の例のようになります。</target>
        </trans-unit>
        <trans-unit id="a0ec21abacef113106404f37c8ffeaf0991584f3" translate="yes" xml:space="preserve">
          <source>If your perl supports &lt;code&gt;PerlIO&lt;/code&gt; (which is the default), you can use a &lt;code&gt;PerlIO&lt;/code&gt; layer to decode and encode directly via a filehandle. The following two examples are fully identical in functionality:</source>
          <target state="translated">Perlが &lt;code&gt;PerlIO&lt;/code&gt; （デフォルト）をサポートしている場合は、 &lt;code&gt;PerlIO&lt;/code&gt; レイヤーを使用して、ファイルハンドルを介して直接デコードおよびエンコードできます。次の2つの例は、機能がまったく同じです。</target>
        </trans-unit>
        <trans-unit id="605c431eb189340e08603e962b29cd94bebb00d6" translate="yes" xml:space="preserve">
          <source>If your platform does not support disabling this option but you still want to listen for both &lt;code&gt;AF_INET&lt;/code&gt; and &lt;code&gt;AF_INET6&lt;/code&gt; connections you will have to create two listening sockets, one bound to each protocol.</source>
          <target state="translated">プラットフォームがこのオプションの無効化をサポートしていないが、 &lt;code&gt;AF_INET&lt;/code&gt; 接続とAF_INET6接続の両方をリッスンしたい &lt;code&gt;AF_INET6&lt;/code&gt; 、各プロトコルにバインドされた2つのリッスンソケットを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="f282d94e305f215eb5d8388f1861231e1f9e48da" translate="yes" xml:space="preserve">
          <source>If your program does not need compatibility for Perl 5.6 and earlier, the recommended approach is to apply appropriate IO disciplines, so all data in your program become unicode-strings. See &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; and &lt;a href=&quot;perlfunc#binmode&quot;&gt;&quot;binmode&quot; in perlfunc&lt;/a&gt; for how.</source>
          <target state="translated">プログラムがPerl5.6以前との互換性を必要としない場合、推奨されるアプローチは、適切なIO規律を適用することです。これにより、プログラム内のすべてのデータがUnicode文字列になります。方法について&lt;a href=&quot;perlfunc#binmode&quot;&gt;は、perlfuncの&lt;/a&gt;&lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt;、&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;、および「binmode」を参照してください。</target>
        </trans-unit>
        <trans-unit id="9b23131a86f1ea3c3da4be4496eb45f056a245b0" translate="yes" xml:space="preserve">
          <source>If your program is using the POSIX 2008 multi-thread locale functionality, you should switch into the global locale and set that up properly before starting the Perl interpreter. It will then properly switch back to using the thread-safe functions.</source>
          <target state="translated">POSIX 2008 のマルチスレッドロケール機能を使用している場合は、Perl インタプリタを起動する前にグローバルロケールに切り替えて適切に設定する必要があります。そうすれば、スレッドセーフ関数の使用に適切に切り替わるでしょう。</target>
        </trans-unit>
        <trans-unit id="091f7db96070043c9514e8ee2a91acbe99a23b27" translate="yes" xml:space="preserve">
          <source>If your rc file contains:</source>
          <target state="translated">rcファイルに含まれている場合。</target>
        </trans-unit>
        <trans-unit id="1cc732c143d69a605c4a486fe1919dbc8511b3b7" translate="yes" xml:space="preserve">
          <source>If your routine iterates through some kind of list (such as a list of files, or records in a database) you may consider providing a callback so that users can manipulate each element of the list in turn. File::Find provides an example of this with its &lt;code&gt;find(\&amp;amp;wanted, $dir)&lt;/code&gt; syntax.</source>
          <target state="translated">ルーチンがある種のリスト（ファイルのリストやデータベース内のレコードなど）を反復処理する場合は、ユーザーがリストの各要素を順番に操作できるようにコールバックを提供することを検討できます。File :: Findは、 &lt;code&gt;find(\&amp;amp;wanted, $dir)&lt;/code&gt; 構文でこの例を提供します。</target>
        </trans-unit>
        <trans-unit id="fa4660b471bef6e2a6cf6ca593555a146c22ffd2" translate="yes" xml:space="preserve">
          <source>If your script works with huge numbers and Calc is too slow for them, you can also for the loading of one of these libraries and if none of them can be used, the code dies:</source>
          <target state="translated">あなたのスクリプトは巨大な数字で動作し、Calcはそれらのために遅すぎる場合は、これらのライブラリのいずれかのロードのためにもできますし、それらのいずれかを使用することができない場合は、コードが死ぬ。</target>
        </trans-unit>
        <trans-unit id="20d69711a4dff3eb5c2c54e4925f7a2d49b42d0e" translate="yes" xml:space="preserve">
          <source>If your script works with huge numbers and Calc is too slow for them, you can also for the loading of one of these libraries and if none of them can be used, the code will die:</source>
          <target state="translated">あなたのスクリプトは巨大な数字で動作し、Calcはそれらのために遅すぎる場合は、これらのライブラリのいずれかをロードするためにもできますし、それらのいずれかを使用することができない場合は、コードが死ぬでしょう。</target>
        </trans-unit>
        <trans-unit id="686d70af0d50a3bff3e29e104e2f82c37c794acd" translate="yes" xml:space="preserve">
          <source>If your stdio requires a seek or eof between reads and writes on a particular stream, so does Perl. (This doesn't apply to sysread() and syswrite().)</source>
          <target state="translated">stdio が特定のストリームの読み込みと書き込みの間にシークや eof を必要とする場合、Perl も同様です(これは sysread()と syswrite()には適用されません)。(これは sysread()と syswrite()には適用されません)。</target>
        </trans-unit>
        <trans-unit id="93c7fafa71ca8ecee9c4bc6ffa3da0deecf48bf5" translate="yes" xml:space="preserve">
          <source>If your sub-class does not also derive from &lt;code&gt;IO::Socket::INET&lt;/code&gt; or similar (e.g. &lt;code&gt;IO::Socket::IP&lt;/code&gt;, &lt;code&gt;IO::Socket::INET6&lt;/code&gt; or &lt;code&gt;IO::Socket::SSL&lt;/code&gt;) then you must provide the following methods by other means yourself: &lt;code&gt;close()&lt;/code&gt; and &lt;code&gt;timeout()&lt;/code&gt;.</source>
          <target state="translated">サブクラスが &lt;code&gt;IO::Socket::INET&lt;/code&gt; などからも派生していない場合（例： &lt;code&gt;IO::Socket::IP&lt;/code&gt; 、 &lt;code&gt;IO::Socket::INET6&lt;/code&gt; または &lt;code&gt;IO::Socket::SSL&lt;/code&gt; ）、他の手段による次のメソッド： &lt;code&gt;close()&lt;/code&gt; および &lt;code&gt;timeout()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34ff0a2e68bd649cc4624def7ce4b58902e2e24e" translate="yes" xml:space="preserve">
          <source>If your subsecond sleeping is implemented with &lt;code&gt;nanosleep()&lt;/code&gt; instead of &lt;code&gt;usleep()&lt;/code&gt; , you can mix subsecond sleeping with signals since &lt;code&gt;nanosleep()&lt;/code&gt; does not use signals. This, however, is not portable, and you should first check for the truth value of &lt;code&gt;&amp;amp;Time::HiRes::d_nanosleep&lt;/code&gt; to see whether you have nanosleep, and then carefully read your &lt;code&gt;nanosleep()&lt;/code&gt; C API documentation for any peculiarities.</source>
          <target state="translated">サブスリープのスリープが &lt;code&gt;usleep()&lt;/code&gt; &lt;code&gt;nanosleep()&lt;/code&gt; ではなくnanosleep（）で実装されている場合、ナノ &lt;code&gt;nanosleep()&lt;/code&gt; はシグナルを使用しないため、サブセカンドスリープとシグナルを混在させることができます。ただし、これは移植性がありません。最初に &lt;code&gt;&amp;amp;Time::HiRes::d_nanosleep&lt;/code&gt; の真の値をチェックして、nanosleepがあるかどうかを確認してから、 &lt;code&gt;nanosleep()&lt;/code&gt; C APIのドキュメントを読んで、特殊性がないか確認してください。</target>
        </trans-unit>
        <trans-unit id="eaecaa38de7e044e0f0abcb184f5c42e588cde80" translate="yes" xml:space="preserve">
          <source>If your subsecond sleeping is implemented with &lt;code&gt;nanosleep()&lt;/code&gt; instead of &lt;code&gt;usleep()&lt;/code&gt;, you can mix subsecond sleeping with signals since &lt;code&gt;nanosleep()&lt;/code&gt; does not use signals. This, however, is not portable, and you should first check for the truth value of &lt;code&gt;&amp;amp;Time::HiRes::d_nanosleep&lt;/code&gt; to see whether you have nanosleep, and then carefully read your &lt;code&gt;nanosleep()&lt;/code&gt; C API documentation for any peculiarities.</source>
          <target state="translated">&lt;code&gt;usleep()&lt;/code&gt; がusleep &lt;code&gt;nanosleep()&lt;/code&gt; ではなくnanosleep（）で実装されている場合、 &lt;code&gt;nanosleep()&lt;/code&gt; はシグナルを使用しないため、サブセカンドスリープをシグナルと混合できます。ただし、これは移植性がないため、最初に &lt;code&gt;&amp;amp;Time::HiRes::d_nanosleep&lt;/code&gt; の真理値をチェックして、nanosleepがあるかどうかを確認してから、 &lt;code&gt;nanosleep()&lt;/code&gt; CAPIドキュメントで特殊性を注意深く読んでください。</target>
        </trans-unit>
        <trans-unit id="86c582512684ef5d894959bd9f55e416e8035f6a" translate="yes" xml:space="preserve">
          <source>If your system does not support &lt;code&gt;sockatmark&lt;/code&gt;, the &lt;code&gt;use&lt;/code&gt; declaration will fail at compile time.</source>
          <target state="translated">システムが &lt;code&gt;sockatmark&lt;/code&gt; をサポートしていない場合、 &lt;code&gt;use&lt;/code&gt; 宣言はコンパイル時に失敗します。</target>
        </trans-unit>
        <trans-unit id="0fe6bd7053ca68da494e6d40d10fb833af71cceb" translate="yes" xml:space="preserve">
          <source>If your system doesn't support dynamic loading, you still probably ought to use &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;. See &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; and &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; for more information (in brief, just use &lt;b&gt;make perl&lt;/b&gt; instead of a plain &lt;b&gt;make&lt;/b&gt; to rebuild perl with a new static extension).</source>
          <target state="translated">システムが動的ロードをサポートしていない場合でも、おそらく&lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;を使用する必要があります。詳細については、&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;および&lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt;を参照してください（簡単に言うと、新しい静的拡張でperlを再構築&lt;b&gt;する&lt;/b&gt;には、プレーン&lt;b&gt;makeの&lt;/b&gt;代わりに&lt;b&gt;make perl&lt;/b&gt;を使用します）。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7033933f15e134ae512f052ac986d8b0ac72a9af" translate="yes" xml:space="preserve">
          <source>If your system doesn't support dynamic loading, you still probably ought to use &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;. See &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; and &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; for more information (in brief, just use &lt;b&gt;make perl&lt;/b&gt; instead of a plain &lt;b&gt;make&lt;/b&gt; to rebuild perl with a new static extension).</source>
          <target state="translated">システムが動的ロードをサポートしていない場合でも、おそらく&lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;を使用する必要があります。詳細については、&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;および&lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt;を参照してください（簡単に言うと、単純な&lt;b&gt;make&lt;/b&gt;ではなく&lt;b&gt;make perl&lt;/b&gt;を使用して、新しい静的拡張機能でperlを再構築します）。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="976a5d23704d8a7827f274e64a1b65ab7ed369e5" translate="yes" xml:space="preserve">
          <source>If your system has a strange pointer size--meaning a pointer is neither as big as an int nor as big as a long--it may not be possible to pack or unpack pointers in big- or little-endian byte order. Attempting to do so raises an exception.</source>
          <target state="translated">お使いのシステムが奇妙なポインタサイズを持っている場合、つまりポインタがintほど大きくもなくlongほど大きくもない場合、ポインタをビッグエンディアンやリトルエンディアンのバイトオーダーでパックしたり展開したりすることができないかもしれません。そうしようとすると例外が発生します。</target>
        </trans-unit>
        <trans-unit id="c8f634435d2540d4ac325a2965a4ae17a54489a6" translate="yes" xml:space="preserve">
          <source>If your system has the &lt;code&gt;sigaction()&lt;/code&gt; function then signal handlers are installed using it. This means you get reliable signal handling.</source>
          <target state="translated">システムに &lt;code&gt;sigaction()&lt;/code&gt; 関数がある場合、それを使用してシグナルハンドラがインストールされます。つまり、信頼性の高い信号処理を行うことができます。</target>
        </trans-unit>
        <trans-unit id="fd4695d7aa352602cd4c4febe7f1355134b6280c" translate="yes" xml:space="preserve">
          <source>If your system lacks &lt;code&gt;gettimeofday()&lt;/code&gt; or an emulation of it you don't get &lt;code&gt;gettimeofday()&lt;/code&gt; or the one-argument form of &lt;code&gt;tv_interval()&lt;/code&gt; . If your system lacks all of &lt;code&gt;nanosleep()&lt;/code&gt; , &lt;code&gt;usleep()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;poll&lt;/code&gt; , you don't get &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; , &lt;code&gt;Time::HiRes::nanosleep()&lt;/code&gt; , or &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; . If your system lacks both &lt;code&gt;ualarm()&lt;/code&gt; and &lt;code&gt;setitimer()&lt;/code&gt; you don't get &lt;code&gt;Time::HiRes::ualarm()&lt;/code&gt; or &lt;code&gt;Time::HiRes::alarm()&lt;/code&gt; .</source>
          <target state="translated">システムに &lt;code&gt;gettimeofday()&lt;/code&gt; またはそのエミュレーションがない場合は、 &lt;code&gt;gettimeofday()&lt;/code&gt; または引数が1つの形式の &lt;code&gt;tv_interval()&lt;/code&gt; を取得できません。システムにすべての &lt;code&gt;nanosleep()&lt;/code&gt; 、 &lt;code&gt;usleep()&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select()&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;poll&lt;/code&gt; がない場合、 &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; 、 &lt;code&gt;Time::HiRes::nanosleep()&lt;/code&gt; 、または &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; 取得できません。HiRes :: sleep（）。システムに &lt;code&gt;ualarm()&lt;/code&gt; と &lt;code&gt;setitimer()&lt;/code&gt; の両方がない場合、 &lt;code&gt;Time::HiRes::ualarm()&lt;/code&gt; または &lt;code&gt;Time::HiRes::alarm()&lt;/code&gt; 取得できません。</target>
        </trans-unit>
        <trans-unit id="ff14b6674e60e3293827358011cc8a222c542ec1" translate="yes" xml:space="preserve">
          <source>If your system lacks &lt;code&gt;gettimeofday()&lt;/code&gt; or an emulation of it you don't get &lt;code&gt;gettimeofday()&lt;/code&gt; or the one-argument form of &lt;code&gt;tv_interval()&lt;/code&gt;. If your system lacks all of &lt;code&gt;nanosleep()&lt;/code&gt;, &lt;code&gt;usleep()&lt;/code&gt;, &lt;code&gt;select()&lt;/code&gt;, and &lt;code&gt;poll&lt;/code&gt;, you don't get &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt;, &lt;code&gt;Time::HiRes::nanosleep()&lt;/code&gt;, or &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt;. If your system lacks both &lt;code&gt;ualarm()&lt;/code&gt; and &lt;code&gt;setitimer()&lt;/code&gt; you don't get &lt;code&gt;Time::HiRes::ualarm()&lt;/code&gt; or &lt;code&gt;Time::HiRes::alarm()&lt;/code&gt;.</source>
          <target state="translated">システムに &lt;code&gt;gettimeofday()&lt;/code&gt; またはそのエミュレーションがない場合、 &lt;code&gt;gettimeofday()&lt;/code&gt; または1引数形式の &lt;code&gt;tv_interval()&lt;/code&gt; を取得できません。システムに &lt;code&gt;nanosleep()&lt;/code&gt; 、 &lt;code&gt;usleep()&lt;/code&gt; 、 &lt;code&gt;select()&lt;/code&gt; 、 &lt;code&gt;poll&lt;/code&gt; のすべてがない場合、 &lt;code&gt;Time::HiRes::usleep()&lt;/code&gt; 、 &lt;code&gt;Time::HiRes::nanosleep()&lt;/code&gt; 、または &lt;code&gt;Time::HiRes::sleep()&lt;/code&gt; は取得されません。HiRes :: sleep（）。システムに &lt;code&gt;ualarm()&lt;/code&gt; と &lt;code&gt;setitimer()&lt;/code&gt; の両方がない場合、 &lt;code&gt;Time::HiRes::ualarm()&lt;/code&gt; または &lt;code&gt;Time::HiRes::alarm()&lt;/code&gt; は取得されません。</target>
        </trans-unit>
        <trans-unit id="a3404e2a55faf84740517a5a0e24d39c3bdace4c" translate="yes" xml:space="preserve">
          <source>If your system supports dynamic loading, for reasons of portability and sanity you probably ought to use &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt; (also part of the standard perl distribution). This tool converts C header files to Perl extensions. See &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; for how to get started with &lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;.</source>
          <target state="translated">システムが動的ロードをサポートしている場合、移植性と健全性の理由から、おそらく&lt;a href=&quot;h2xs&quot;&gt;h2xs&lt;/a&gt;（これも標準のperlディストリビューションの一部）を使用する必要があります。このツールは、CヘッダーファイルをPerl拡張に変換します。&lt;a href=&quot;h2xs&quot;&gt;h2xsを&lt;/a&gt;使い始める方法については&lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c32ad1b9a818a02634ef64d7fbd9495e5b9eebf0" translate="yes" xml:space="preserve">
          <source>If your system supports the portable operating system programming interface (POSIX), you can use the following code, which you'll note turns off echo processing as well.</source>
          <target state="translated">システムがポータブルオペレーティングシステムプログラミングインターフェイス (POSIX)をサポートしている場合は、以下のコードを使用することができます。</target>
        </trans-unit>
        <trans-unit id="8aa741c7264a81c87bbbe88de85bd0da9b62830f" translate="yes" xml:space="preserve">
          <source>If your version control system supports revision numbers (git doesn't easily), the simplest way to do it automatically is to use its revision number (you are using version control, right?).</source>
          <target state="translated">バージョン管理システムがリビジョン番号をサポートしている場合 (git は簡単にはサポートしていません)、そのリビジョン番号を使って自動的に行う最も簡単な方法は、そのリビジョン番号を使うことです (バージョン管理を使っていますよね?)。</target>
        </trans-unit>
        <trans-unit id="cf51a5f9f685e20ec9fa41065bc4bbf9f512757f" translate="yes" xml:space="preserve">
          <source>If z is a pure real number (i.e. &lt;code&gt;b == 0&lt;/code&gt; ), then the above yields:</source>
          <target state="translated">zが純粋な実数（つまり &lt;code&gt;b == 0&lt;/code&gt; ）の場合、上記の結果は次のようになります。</target>
        </trans-unit>
        <trans-unit id="4b680ec7961a3ae6c6b5a4223fc07bd86a65a488" translate="yes" xml:space="preserve">
          <source>If z is a pure real number (i.e. &lt;code&gt;b == 0&lt;/code&gt;), then the above yields:</source>
          <target state="translated">zが純粋な実数（つまり &lt;code&gt;b == 0&lt;/code&gt; ）の場合、上記の結果は次のようになります。</target>
        </trans-unit>
        <trans-unit id="866f3e73958b23adbe3e41bd3c02c8704cd81475" translate="yes" xml:space="preserve">
          <source>If, and only if, a token is a bailout token, you can get an &quot;explanation&quot; via this method. The explanation is the text after the mystical &quot;Bail out!&quot; words which appear in the tap output.</source>
          <target state="translated">トークンがベイルアウト・トークンである場合、そしてその場合に限り、この方法で「説明」を得ることができます。説明」とは、タップ出力に出てくる神秘的な「Bail out!」という言葉の後に表示されるテキストのことです。</target>
        </trans-unit>
        <trans-unit id="4f07d749cb3d9f280003a3874694f44dd0f9a196" translate="yes" xml:space="preserve">
          <source>If, at the end of a run you get the message</source>
          <target state="translated">実行の最後にメッセージが表示された場合</target>
        </trans-unit>
        <trans-unit id="748ad1a2344142dff26b49b0321a5e20db97e62e" translate="yes" xml:space="preserve">
          <source>If, for a given file, Perl is unable to create the backup file as specified in the extension then it will skip that file and continue on with the next one (if it exists).</source>
          <target state="translated">与えられたファイルに対して、Perl は拡張子で指定されたバックアップファイルを作成できない場合、そのファイルをスキップして次のファイル (存在する場合)に進みます。</target>
        </trans-unit>
        <trans-unit id="3190be8312e8fef021a8d99a686331f02896c645" translate="yes" xml:space="preserve">
          <source>If, for some odd reason, you really want to see the whole file at once rather than processing line-by-line, you can slurp it in (as long as you can fit the whole thing in memory!):</source>
          <target state="translated">何らかの奇妙な理由で、行ごとに処理するのではなく、ファイル全体を一度に見たい場合は、(メモリに全体を収めることができるのであれば)ファイルをスラスラと見ることができます。</target>
        </trans-unit>
        <trans-unit id="8294d55294098cd1496efb3523c86ff173cf45ca" translate="yes" xml:space="preserve">
          <source>If, for some reason, you have a file descriptor instead of a filehandle (perhaps you used &lt;code&gt;POSIX::open&lt;/code&gt; ), you can use the &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; function from the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module:</source>
          <target state="translated">何らかの理由で、ファイルハンドルではなくファイル記述子がある場合（おそらく &lt;code&gt;POSIX::open&lt;/code&gt; を使用した場合）、&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;モジュールの &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="47aebbdcad1bcff07c1f3a89cb274cc12375e577" translate="yes" xml:space="preserve">
          <source>If, for some reason, you have a file descriptor instead of a filehandle (perhaps you used &lt;code&gt;POSIX::open&lt;/code&gt;), you can use the &lt;code&gt;close()&lt;/code&gt; function from the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module:</source>
          <target state="translated">何らかの理由で、ファイルハンドルの代わりにファイル記述子がある場合（おそらく &lt;code&gt;POSIX::open&lt;/code&gt; を使用した場合）、&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;モジュールから &lt;code&gt;close()&lt;/code&gt; 関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="e7db8cc8d76b7ab2eda9890eb0170658ba11e9d0" translate="yes" xml:space="preserve">
          <source>If, surprisingly, the implementor of a Pod formatter can't find a satisfactory pre-existing table mapping from Unicode characters to escapes in the target format (e.g., a decent table of Unicode characters to *roff escapes), it will be necessary to build such a table. If you are in this circumstance, you should begin with the characters in the range 0x00A0 - 0x00FF, which is mostly the heavily used accented characters. Then proceed (as patience permits and fastidiousness compels) through the characters that the (X)HTML standards groups judged important enough to merit mnemonics for. These are declared in the (X)HTML specifications at the www.W3.org site. At time of writing (September 2001), the most recent entity declaration files are:</source>
          <target state="translated">驚くべきことに、Podフォーマッタの実装者が、ターゲットフォーマットのUnicode文字からエスケープへの十分なマッピングを既存のテーブルで見つけることができない場合(例えば、Unicode文字から*roffエスケープへのまともなテーブル)、そのようなテーブルを構築する必要があります。このような状況にある場合は、0x00A0 から 0x00FF の範囲の文字から始めるべきです。それから、(忍耐が許す限り、また、几帳面さが要求するように)(X)HTML標準化グループがニーモニックに値するほど重要であると判断した文字を進めてください。これらは、www.W3.org サイトの (X)HTML 仕様書で宣言されています。執筆時(2001年9月)の最新の実体宣言ファイルは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="3906f56da4298c4e536de3ebef7105b8dabd75e9" translate="yes" xml:space="preserve">
          <source>Ignore &lt;code&gt;dSP&lt;/code&gt; and &lt;code&gt;PUSHMARK(SP)&lt;/code&gt; for now. They will be discussed in the next example.</source>
          <target state="translated">&lt;code&gt;dSP&lt;/code&gt; 、dSPと &lt;code&gt;PUSHMARK(SP)&lt;/code&gt; は無視してください。それらについては、次の例で説明します。</target>
        </trans-unit>
        <trans-unit id="51be86b7131a2f6dd784631a551ad5a124bca532" translate="yes" xml:space="preserve">
          <source>Ignore ASCII vs. EBCDIC sort differences.</source>
          <target state="translated">ASCIIとEBCDICのソートの違いは無視してください。</target>
        </trans-unit>
        <trans-unit id="be1854061543f14642d8f6508b59d601baedc0d4" translate="yes" xml:space="preserve">
          <source>Ignore case.</source>
          <target state="translated">ケースは無視して</target>
        </trans-unit>
        <trans-unit id="2e352eadd6b1808d1d1be87c9129c2b0edb3ffba" translate="yes" xml:space="preserve">
          <source>Ignore the message about missing &lt;code&gt;ln&lt;/code&gt; , and about &lt;code&gt;-c&lt;/code&gt; option to tr</source>
          <target state="translated">&lt;code&gt;ln&lt;/code&gt; の欠落、およびtrの &lt;code&gt;-c&lt;/code&gt; オプションに関するメッセージを無視する</target>
        </trans-unit>
        <trans-unit id="72b96e98da641687751a87c43bd0316c4d008be2" translate="yes" xml:space="preserve">
          <source>Ignore the message about missing &lt;code&gt;ln&lt;/code&gt;, and about &lt;code&gt;-c&lt;/code&gt; option to tr</source>
          <target state="translated">&lt;code&gt;ln&lt;/code&gt; がないこと、およびtrの &lt;code&gt;-c&lt;/code&gt; オプションについてのメッセージを無視します。</target>
        </trans-unit>
        <trans-unit id="28a9d1669608fdb03cba836ec390fdcfb1aebfee" translate="yes" xml:space="preserve">
          <source>Ignore the warning.</source>
          <target state="translated">警告は無視してください。</target>
        </trans-unit>
        <trans-unit id="2789be88625c10d2c36088f497ee1c896ef071b5" translate="yes" xml:space="preserve">
          <source>Ignore them: in IRIX 5.3 there is no way to quieten ld about this.</source>
          <target state="translated">Ignore them:IRIX 5.3では、このことについてLDを黙らせる方法はありません。</target>
        </trans-unit>
        <trans-unit id="a8788733d30e5e6ffc336904ff3697b5a05072af" translate="yes" xml:space="preserve">
          <source>Ignored if perl is run setuid or setgid. Used only for some limited startup randomization (hash keys) if &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-t&lt;/code&gt; perl is started with tainting enabled.</source>
          <target state="translated">perlがsetuidまたはsetgidで実行されている場合は無視されます。場合のみ、一部の限られたスタートアップのランダム化（ハッシュキー）に使用さ &lt;code&gt;-T&lt;/code&gt; または &lt;code&gt;-t&lt;/code&gt; のperlが有効に汚染ポリシーで開始されます。</target>
        </trans-unit>
        <trans-unit id="2b4603ab54eaf129f7b585f0908e9724e9831b25" translate="yes" xml:space="preserve">
          <source>Ignores any arguments and returns a new &lt;code&gt;TAP::Parser::Scheduler::Spinner&lt;/code&gt; object.</source>
          <target state="translated">引数をすべて無視し、新しい &lt;code&gt;TAP::Parser::Scheduler::Spinner&lt;/code&gt; オブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="870e1aa14cd979f7f1df9488b978998300179625" translate="yes" xml:space="preserve">
          <source>Ignoring A Thread</source>
          <target state="translated">スレッドを無視する</target>
        </trans-unit>
        <trans-unit id="c345599472f697123763177ed798b710a78992e1" translate="yes" xml:space="preserve">
          <source>Ignoring zero length \N{} in character class in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正規表現の文字クラスで長さゼロの\ N {}を無視します。&amp;lt;-ここにm /％s /でマーク</target>
        </trans-unit>
        <trans-unit id="c9e1853ac655507e727a7ecfa474945c84b582ca" translate="yes" xml:space="preserve">
          <source>Ill-formed CRTL environ value &quot;%s&quot;</source>
          <target state="translated">CRTL エンバイロン値 &quot;%s&quot; が誤って形成されています。</target>
        </trans-unit>
        <trans-unit id="a98f3b9adc99d6eca5487e3635466c7897d1e208" translate="yes" xml:space="preserve">
          <source>Ill-formed message in prime_env_iter: |%s|</source>
          <target state="translated">prime_env_iter でのメッセージの形式が正しくありません。|%s|</target>
        </trans-unit>
        <trans-unit id="9b8d69f56b24624da5f02c3105fccc4af1aafcfd" translate="yes" xml:space="preserve">
          <source>Illegal %s digit '%c' ignored</source>
          <target state="translated">不正な %s 桁 '%c' は無視されました。</target>
        </trans-unit>
        <trans-unit id="36e60a32732ccee2f9f27142f8031ba26b8d7dc3" translate="yes" xml:space="preserve">
          <source>Illegal binary digit '%c'</source>
          <target state="translated">違法な 2 進数 '%c' です。</target>
        </trans-unit>
        <trans-unit id="a0069ddda69becb8f7b322dfab0d91887d6b38cf" translate="yes" xml:space="preserve">
          <source>Illegal character \%o (carriage return)</source>
          <target state="translated">♪♪ ♪♪~ 違法文字</target>
        </trans-unit>
        <trans-unit id="15a9e7d5d6c79cbead9e7a219edc1cf3115b4e4c" translate="yes" xml:space="preserve">
          <source>Illegal character after '_' in prototype for %s : %s</source>
          <target state="translated">s のプロトタイプで '_' の後の文字が不正です:%s</target>
        </trans-unit>
        <trans-unit id="ac523c566b2bdb256c5d3bdfff364808f4e23fbd" translate="yes" xml:space="preserve">
          <source>Illegal character following sigil in a subroutine signature</source>
          <target state="translated">サブルーチン署名のシグネチャに続く不正な文字</target>
        </trans-unit>
        <trans-unit id="9714b34609d4e303cabdd33bab8c4221880bccec" translate="yes" xml:space="preserve">
          <source>Illegal character in prototype for %s : %s</source>
          <target state="translated">プロトタイプ内の %s の不正な文字:%s</target>
        </trans-unit>
        <trans-unit id="403f39532270d448d0836526af86ee2840377440" translate="yes" xml:space="preserve">
          <source>Illegal declaration of anonymous subroutine</source>
          <target state="translated">匿名サブルーチンの不正宣言</target>
        </trans-unit>
        <trans-unit id="8441ad3dcf356cbc9055eaec17cb99c6b40b3f60" translate="yes" xml:space="preserve">
          <source>Illegal declaration of subroutine %s</source>
          <target state="translated">サブルーチン %s の不正な宣言</target>
        </trans-unit>
        <trans-unit id="b402a1aef9fad4e86bc75fa0d98c8b6064013045" translate="yes" xml:space="preserve">
          <source>Illegal division by zero</source>
          <target state="translated">違法なゼロによる除算</target>
        </trans-unit>
        <trans-unit id="dc34fa84665015bf956a8d0f9e7eab7f7b556cb7" translate="yes" xml:space="preserve">
          <source>Illegal modulus zero</source>
          <target state="translated">違法な弾性率ゼロ</target>
        </trans-unit>
        <trans-unit id="44efc0fd61ea8302183ad4e06ae2e1a20b915b53" translate="yes" xml:space="preserve">
          <source>Illegal number of bits in vec</source>
          <target state="translated">vec での異常なビット数</target>
        </trans-unit>
        <trans-unit id="def84612dec0b9b85613fc3abd33e76ff6143abb" translate="yes" xml:space="preserve">
          <source>Illegal octal digit '%c'</source>
          <target state="translated">違法な 8 進数 '%c' です。</target>
        </trans-unit>
        <trans-unit id="e3dffed7bacaff2750f20d75c00b10e5dda311cc" translate="yes" xml:space="preserve">
          <source>Illegal operator following parameter in a subroutine signature</source>
          <target state="translated">サブルーチン署名のパラメータに続く不正な演算子</target>
        </trans-unit>
        <trans-unit id="c16a63da830be887556e1c445a15cd94836e397c" translate="yes" xml:space="preserve">
          <source>Illegal pattern in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正規表現の不正なパターン。&amp;lt;-ここにm /％s /でマーク</target>
        </trans-unit>
        <trans-unit id="91183d6c24353dd4efc4edca2cf3d736c588f3ed" translate="yes" xml:space="preserve">
          <source>Illegal suidscript</source>
          <target state="translated">違法な suidscript</target>
        </trans-unit>
        <trans-unit id="a61cca4d5acdb186d61af82a2d57012a7e14f42a" translate="yes" xml:space="preserve">
          <source>Illegal switch in PERL5OPT: -%c</source>
          <target state="translated">PERL5OPT での不正なスイッチ:-%c</target>
        </trans-unit>
        <trans-unit id="579239231de5fef3bb30ece4ec0c3be4f3f8e3dc" translate="yes" xml:space="preserve">
          <source>Illegal user-defined property name</source>
          <target state="translated">違法なユーザー定義プロパティ名</target>
        </trans-unit>
        <trans-unit id="8ee7b0829696083ec110a0ef1b14678e7a72b39d" translate="yes" xml:space="preserve">
          <source>Illegal.</source>
          <target state="translated">Illegal.</target>
        </trans-unit>
        <trans-unit id="31b9d2eef058fc852ec75440518312fc6b32dcd0" translate="yes" xml:space="preserve">
          <source>Illinois</source>
          <target state="translated">Illinois</target>
        </trans-unit>
        <trans-unit id="817c7ffeee7200e3277cebf23a0b3dcda06d9829" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &amp;lt;</source>
          <target state="translated">イリヤザハレビッチ&amp;lt;</target>
        </trans-unit>
        <trans-unit id="91b2e058cf65f0cabffee0e92051934b87d3bc3b" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich (ilya@math.ohio-state.edu)</source>
          <target state="translated">イリヤ・ザハレヴィッチ (ilya@math.ohio-state.edu)</target>
        </trans-unit>
        <trans-unit id="031c817d16973027b8790762eb4b0c35cafca1e9" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &lt;a href=&quot;mailto:ilyaz@cpan.org&quot;&gt;mailto:ilyaz@cpan.org&lt;/a&gt;.</source>
          <target state="translated">Ilya Zakharevich &lt;a href=&quot;mailto:ilyaz@cpan.org&quot;&gt;mailto：ilyaz@cpan.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="afff5ba88102f80e4aa07d73498f8952aca29188" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &lt;a href=&quot;mailto:perl-module-hash-memoize@ilyaz.org&quot;&gt;mailto:perl-module-hash-memoize@ilyaz.org&lt;/a&gt;.</source>
          <target state="translated">Ilya Zakharevich &lt;a href=&quot;mailto:perl-module-hash-memoize@ilyaz.org&quot;&gt;mailto：perl-module-hash-memoize@ilyaz.org&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4248a84d563fa7da7c5bae89f2669c77f908cab3" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt;</source>
          <target state="translated">イリヤザ &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; ビッチilya@math.ohio-state.edu</target>
        </trans-unit>
        <trans-unit id="33d5a3e7b454b4e36eb89767df3980ae73e9890b" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich ilya@math.ohio-state.edu</source>
          <target state="translated">Ilya Zakharevich ilya@math.ohio-state.edu</target>
        </trans-unit>
        <trans-unit id="0182df78996d3eb0a76431c398a0f49f0059b1f4" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich originally extracted &lt;code&gt;XSLoader&lt;/code&gt; from &lt;code&gt;DynaLoader&lt;/code&gt; .</source>
          <target state="translated">Ilya Zakharevichは元々 &lt;code&gt;XSLoader&lt;/code&gt; から &lt;code&gt;DynaLoader&lt;/code&gt; 抽出しました。</target>
        </trans-unit>
        <trans-unit id="317e8b465d1e45c2334fa7d0b49224fc7b0d2b79" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich originally extracted &lt;code&gt;XSLoader&lt;/code&gt; from &lt;code&gt;DynaLoader&lt;/code&gt;.</source>
          <target state="translated">Ilya Zakharevichは、もともと &lt;code&gt;XSLoader&lt;/code&gt; から &lt;code&gt;DynaLoader&lt;/code&gt; 抽出しました。</target>
        </trans-unit>
        <trans-unit id="7b5ae6dbba6c0391c239461a326224f80e808d8a" translate="yes" xml:space="preserve">
          <source>Ilya Zakharevich, cpan@ilyaz.org</source>
          <target state="translated">イリヤ・ザハレヴィッチ cpan@ilyaz.org</target>
        </trans-unit>
        <trans-unit id="f84c916319b1f129948f110816b58ce5079819de" translate="yes" xml:space="preserve">
          <source>Images, Pixmap and Bitmap Manipulation, Drawing, and Graphing</source>
          <target state="translated">画像、ピクスマップとビットマップの操作、描画、グラフ作成</target>
        </trans-unit>
        <trans-unit id="6a42b9040934c9280685a56f5dc127e9e6ee5b8d" translate="yes" xml:space="preserve">
          <source>Imagine that the here-doc end marker is at the beginning of the line. Now you can use &lt;code&gt;\p{InKana}&lt;/code&gt; and &lt;code&gt;\P{InKana}&lt;/code&gt; .</source>
          <target state="translated">ヒアドキュメントの終了マーカーが行の先頭にあると想像してください。 &lt;code&gt;\p{InKana}&lt;/code&gt; と &lt;code&gt;\P{InKana}&lt;/code&gt; を使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="b72c2258352d34a102a5998755a0b68fcb5627e1" translate="yes" xml:space="preserve">
          <source>Imagine that the here-doc end marker is at the beginning of the line. Now you can use &lt;code&gt;\p{InKana}&lt;/code&gt; and &lt;code&gt;\P{InKana}&lt;/code&gt;.</source>
          <target state="translated">ヒアドキュメントの終了マーカーが行の先頭にあると想像してください。これで、 &lt;code&gt;\p{InKana}&lt;/code&gt; と &lt;code&gt;\P{InKana}&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="6a8481d644af6cfb14cd0962521a958539b26e54" translate="yes" xml:space="preserve">
          <source>Imagine that your task for the day is to localize a piece of software -- and luckily for you, the only output the program emits is two messages, like this:</source>
          <target state="translated">その日のあなたの仕事がソフトウェアの一部をローカライズすることだと想像してみてください-幸いなことに、プログラムが出力するのはこのような2つのメッセージだけです。</target>
        </trans-unit>
        <trans-unit id="6fae6fb5571f38013c7696bd62a49c387d5a5d68" translate="yes" xml:space="preserve">
          <source>Immediate Filters</source>
          <target state="translated">即時フィルター</target>
        </trans-unit>
        <trans-unit id="8a696df97fa48af3310dcba0d55250b2371b7422" translate="yes" xml:space="preserve">
          <source>Immediate filters are useful for one-off situations. For more generic problems it can be useful to package the filter up in its own module.</source>
          <target state="translated">即時フィルタはその場限りの状況に有用です。より一般的な問題には、フィルタを独自のモジュールにパッケージ化しておくと便利です。</target>
        </trans-unit>
        <trans-unit id="42b04d9e2ede4faefd5e97013f894508883e5ac4" translate="yes" xml:space="preserve">
          <source>Immediately after the check routine is called the returned node is checked for being compile-time executable. If it is (the value is judged to be constant) it is immediately executed, and a</source>
          <target state="translated">チェック・ルーチンが呼ばれた直後に、返されたノードがコンパイル時に実行可能かどうかがチェックされます。そうであれば(値が一定であると判断された場合)すぐに実行され</target>
        </trans-unit>
        <trans-unit id="5d2ecc7281cc6015d762f885a1871742572e70d2" translate="yes" xml:space="preserve">
          <source>Immediately after the filter has been applied to the source, Filter::Simple will pass control to Exporter, so it can do its magic too.</source>
          <target state="translated">フィルタがソースに適用された直後、Filter::Simple は Exporter に制御を渡します。</target>
        </trans-unit>
        <trans-unit id="a1efac3e1e3b83ccf445505de1c905ec4e317003" translate="yes" xml:space="preserve">
          <source>Implement $PREFER_BIN</source>
          <target state="translated">PREFER_BIN を実装します。</target>
        </trans-unit>
        <trans-unit id="10353737d8f43f937641dff0028a206109a7686a" translate="yes" xml:space="preserve">
          <source>Implementation can adjust its idea of number of bytes in the buffer. Do not use this - use PerlIO_fast_gets.</source>
          <target state="translated">実装は、バッファ内のバイト数のアイデアを調整することができます。これは使用しないでください-PerlIO_fast_getsを使用してください。</target>
        </trans-unit>
        <trans-unit id="2c98a52672a4f466f688e44c536060b9826553e9" translate="yes" xml:space="preserve">
          <source>Implementation can return pointer to current position in the &quot;buffer&quot; and a count of bytes available in the buffer. Do not use this - use PerlIO_fast_gets.</source>
          <target state="translated">実装では、&quot;バッファ &quot;内の現在位置へのポインタと、バッファ内で利用可能なバイト数を返すことができます。これは使用しないでください-PerlIO_fast_getsを使用してください。</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">実施内容</target>
        </trans-unit>
        <trans-unit id="6b3873cf8e5251aa728a3e54318ec3a5f273e5f0" translate="yes" xml:space="preserve">
          <source>Implementation of &lt;code&gt;sv_copypv&lt;/code&gt; and &lt;code&gt;sv_copypv_nomg&lt;/code&gt;. Calls get magic iff flags has the &lt;code&gt;SV_GMAGIC&lt;/code&gt; bit set.</source>
          <target state="translated">&lt;code&gt;sv_copypv&lt;/code&gt; および &lt;code&gt;sv_copypv_nomg&lt;/code&gt; の実装。フラグに &lt;code&gt;SV_GMAGIC&lt;/code&gt; ビットが設定されている場合、呼び出しは魔法になります。</target>
        </trans-unit>
        <trans-unit id="867f93d010e1413848b9511b5f08d11efe452a94" translate="yes" xml:space="preserve">
          <source>Implementation of sv_copypv and sv_copypv_nomg. Calls get magic iff flags include SV_GMAGIC.</source>
          <target state="translated">sv_copypv と sv_copypv_nomg の実装。呼び出しは、フラグに SV_GMAGIC が含まれている場合にマジックを取得します。</target>
        </trans-unit>
        <trans-unit id="93a44ec01f30940976c8468009fd696e0d07c0cd" translate="yes" xml:space="preserve">
          <source>Implementations of mktemp(), tmpnam(), and tempnam() are provided, but should be used with caution since they return only a filename that was valid when function was called, so cannot guarantee that the file will not exist by the time the caller opens the filename.</source>
          <target state="translated">mktemp(),tmpnam(),tempnam()の実装が提供されていますが、これらは関数が呼び出された時に有効だったファイル名のみを返すため、呼び出し元がファイル名を開くまでにファイルが存在しないことを保証できないため、注意して使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="472357ef916af9461389e46cdf6fcf7419adc52b" translate="yes" xml:space="preserve">
          <source>Implementations should detect the error as soon as it occurs in any of the other functions and save the corresponding message for later retrieval. This will avoid problems on some platforms (such as SunOS) where the error message is very temporary (e.g., dlerror()).</source>
          <target state="translated">実装は、他の関数でエラーが発生したらすぐにそれを検出し、後から取得できるように対応するメッセージを保存しなければなりません。これにより、エラーメッセージが非常に一時的なものであるプラットフォーム (SunOS など)での問題を避けることができます (例:dlerror()など)。</target>
        </trans-unit>
        <trans-unit id="40dac3861d28b66aac73bee4c06a53c216044f0c" translate="yes" xml:space="preserve">
          <source>Implemented as a post-test hook, this plugin writes a specfile after every successful test run. The content is also written to the terminal.</source>
          <target state="translated">テスト後のフックとして実装されており、このプラグインはテスト実行が成功するたびに specfile を書き込みます。その内容はターミナルにも書き込まれます。</target>
        </trans-unit>
        <trans-unit id="7772f795eb98ffae1df16f5f22b8f9f0482251d7" translate="yes" xml:space="preserve">
          <source>Implemented on 64 bit VMS 8.3. VMS requires the symbolic link to be in Unix syntax if it is intended to resolve to a valid path.</source>
          <target state="translated">64 ビットの VMS 8.3 で実装されました。VMS は、有効なパスへの解決を意図している場合、シンボリックリンクが Unix 構文であることを要求します。</target>
        </trans-unit>
        <trans-unit id="5c327b5ffaa641fc9ab42ad686d92c062f812101" translate="yes" xml:space="preserve">
          <source>Implementing PerlIO Layers</source>
          <target state="translated">PerlIOレイヤの実装</target>
        </trans-unit>
        <trans-unit id="d1d235ff6e6c8fe294165e40ee8fb7af96b238c6" translate="yes" xml:space="preserve">
          <source>Implements a customized option parser used for &lt;a href=&quot;../perldoc&quot;&gt;Pod::Perldoc&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../perldoc&quot;&gt;Pod :: Perldocに&lt;/a&gt;使用されるカスタマイズされたオプションパーサーを実装します。</target>
        </trans-unit>
        <trans-unit id="4749a3581afc8d4807ca8e3900d478b2535dbbee" translate="yes" xml:space="preserve">
          <source>Implements a customized option parser used for &lt;a href=&quot;Pod::Perldoc&quot;&gt;Pod::Perldoc&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;Pod::Perldoc&quot;&gt;Pod :: Perldocに&lt;/a&gt;使用されるカスタマイズされたオプションパーサーを実装します。</target>
        </trans-unit>
        <trans-unit id="4b6d8e1ab41db2682597810f350ac0e642396e48" translate="yes" xml:space="preserve">
          <source>Implements default import method for modules</source>
          <target state="translated">モジュールのデフォルトのインポート方法を実装</target>
        </trans-unit>
        <trans-unit id="10190ba45fe863f85939478d9d5bb36cd51cea87" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; function. You'll probably have to say</source>
          <target state="translated">&lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl（2）&lt;/a&gt;関数を実装します。あなたはおそらく言わなければならないでしょう</target>
        </trans-unit>
        <trans-unit id="f78f1509e14fc5b2d56dfd77b72b8f3900e010b5" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;http://man.he.net/man2/ioctl&quot;&gt;ioctl(2)&lt;/a&gt; function. You'll probably first have to say</source>
          <target state="translated">&lt;a href=&quot;http://man.he.net/man2/ioctl&quot;&gt;ioctl（2）&lt;/a&gt;関数を実装します。あなたはおそらく最初に言わなければならないでしょう</target>
        </trans-unit>
        <trans-unit id="600b4d0a91fb59ceef4048c760197d5c6d1f4db1" translate="yes" xml:space="preserve">
          <source>Implements the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;prove&lt;/code&gt; コマンドを実装します。</target>
        </trans-unit>
        <trans-unit id="500351adb27caa795501b65867b0b58aab9da04f" translate="yes" xml:space="preserve">
          <source>Implements the fcntl(2) function. You'll probably have to say</source>
          <target state="translated">fcntl(2)関数をインプリメント。と言わざるを得ないでしょう。</target>
        </trans-unit>
        <trans-unit id="345a4b053fd3ba6ba91b9b4a311d01970f38b745" translate="yes" xml:space="preserve">
          <source>Implements the ioctl(2) function. You'll probably first have to say</source>
          <target state="translated">ioctl(2)関数をインプリメント。おそらく最初に</target>
        </trans-unit>
        <trans-unit id="df5a374f83ddf1099a63647567a472d00b3049d5" translate="yes" xml:space="preserve">
          <source>Implicit array</source>
          <target state="translated">暗黙の配列</target>
        </trans-unit>
        <trans-unit id="a755dd53c48e0431df0fb3c83a53268941625f80" translate="yes" xml:space="preserve">
          <source>Implicit context</source>
          <target state="translated">暗黙のコンテキスト</target>
        </trans-unit>
        <trans-unit id="1590ca248f9ea87b12d0a25ed72d75a33b540b98" translate="yes" xml:space="preserve">
          <source>Implicit upgrading for byte-strings</source>
          <target state="translated">バイト文字列の暗黙のアップグレード</target>
        </trans-unit>
        <trans-unit id="690e1538d5a86cb3fc7e71c1d7249c0d6e3e0181" translate="yes" xml:space="preserve">
          <source>Import all symbolic constants. Same as doing this</source>
          <target state="translated">すべてのシンボリック定数をインポートします。これを行うのと同じ</target>
        </trans-unit>
        <trans-unit id="5941fc0651c5b1f4209500ab16a699a919ff2f79" translate="yes" xml:space="preserve">
          <source>Important Caveat</source>
          <target state="translated">重要なケイバット</target>
        </trans-unit>
        <trans-unit id="f641b0147eed755158e9f661a30e441db68a2b9a" translate="yes" xml:space="preserve">
          <source>Important Caveats</source>
          <target state="translated">重要な注意事項</target>
        </trans-unit>
        <trans-unit id="49b3bb070775e7c46535f7d9ea2b7446b904f0e4" translate="yes" xml:space="preserve">
          <source>Important platform-specific changes</source>
          <target state="translated">プラットフォーム固有の重要な変更</target>
        </trans-unit>
        <trans-unit id="cea7c754b6d173704074c0b8cc88cfc7c1f173d8" translate="yes" xml:space="preserve">
          <source>Imported with the &lt;code&gt;:sys_resource_h&lt;/code&gt; tag.</source>
          <target state="translated">&lt;code&gt;:sys_resource_h&lt;/code&gt; タグを付けてインポートします。</target>
        </trans-unit>
        <trans-unit id="90ab5ed3bb3e27748d586ad9b9b11e2ab9efaaf8" translate="yes" xml:space="preserve">
          <source>Importing</source>
          <target state="translated">Importing</target>
        </trans-unit>
        <trans-unit id="a56aac727c58f5874136fceda15607b87290a37d" translate="yes" xml:space="preserve">
          <source>Importing a particular constant may not be very portable, because the import will fail on platforms that do not have that constant. A more portable way to set &lt;code&gt;$!&lt;/code&gt; to a valid value is to use:</source>
          <target state="translated">特定の定数のインポートは、その定数を持たないプラットフォームでは失敗するため、移植性が低い場合があります。 &lt;code&gt;$!&lt;/code&gt; を設定するよりポータブルな方法！有効な値にするには、次を使用します：</target>
        </trans-unit>
        <trans-unit id="e0f171764942008e4afa9ec8365fe319dc1a1bf4" translate="yes" xml:space="preserve">
          <source>Importing autodie into another namespace than &quot;caller&quot;</source>
          <target state="translated">autodie を &quot;caller&quot; 以外の名前空間にインポートする</target>
        </trans-unit>
        <trans-unit id="d4eab83913c9890e5e3e1ea6b76a702ac39df78f" translate="yes" xml:space="preserve">
          <source>Importing this module causes the subroutine color in Test::Builder::Tester to be called with a true value causing colour highlighting to be turned on in debug output.</source>
          <target state="translated">このモジュールをインポートすると、Test::Builder::Tester のサブルーチン color が真の値で呼び出され、デバッグ出力でカラーハイライトがオンになります。</target>
        </trans-unit>
        <trans-unit id="b94be8f7a2bde6a23ee55b54ee8fc9eb76bd786e" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;anyinflate&lt;/code&gt; and &lt;code&gt;$AnyInflateError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">&lt;code&gt;anyinflate&lt;/code&gt; および &lt;code&gt;$AnyInflateError&lt;/code&gt; インポートします。これと同じ</target>
        </trans-unit>
        <trans-unit id="ac0d700aba31089d6a5c86842474af1ccd35ee48" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;anyinflate&lt;/code&gt; and &lt;code&gt;$AnyInflateError&lt;/code&gt;. Same as doing this</source>
          <target state="translated">&lt;code&gt;anyinflate&lt;/code&gt; と &lt;code&gt;$AnyInflateError&lt;/code&gt; インポートします。これを行うのと同じ</target>
        </trans-unit>
        <trans-unit id="a47d4827ba5d67c837818053a8d62f3b22e590b8" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;anyuncompress&lt;/code&gt; and &lt;code&gt;$AnyUncompressError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">&lt;code&gt;anyuncompress&lt;/code&gt; および &lt;code&gt;$AnyUncompressError&lt;/code&gt; インポートします。これと同じ</target>
        </trans-unit>
        <trans-unit id="c5f3df7452ee0e7ac2933d668a54ce6d80e2d969" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;anyuncompress&lt;/code&gt; and &lt;code&gt;$AnyUncompressError&lt;/code&gt;. Same as doing this</source>
          <target state="translated">&lt;code&gt;anyuncompress&lt;/code&gt; と &lt;code&gt;$AnyUncompressError&lt;/code&gt; インポートします。これを行うのと同じ</target>
        </trans-unit>
        <trans-unit id="95b77142aa14b6211216f5a16e3e213d0c392505" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;bunzip2&lt;/code&gt; and &lt;code&gt;$Bunzip2Error&lt;/code&gt; . Same as doing this</source>
          <target state="translated">&lt;code&gt;bunzip2&lt;/code&gt; と &lt;code&gt;$Bunzip2Error&lt;/code&gt; インポートします。これと同じ</target>
        </trans-unit>
        <trans-unit id="ed5276b55d1c3e705615754b5592030b3f86448a" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;bunzip2&lt;/code&gt; and &lt;code&gt;$Bunzip2Error&lt;/code&gt;. Same as doing this</source>
          <target state="translated">&lt;code&gt;bunzip2&lt;/code&gt; と &lt;code&gt;$Bunzip2Error&lt;/code&gt; インポートします。これを行うのと同じ</target>
        </trans-unit>
        <trans-unit id="611c05e07552b8091c699fb7c8b34e627de5035f" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;bzip2&lt;/code&gt; and &lt;code&gt;$Bzip2Error&lt;/code&gt; . Same as doing this</source>
          <target state="translated">&lt;code&gt;bzip2&lt;/code&gt; および &lt;code&gt;$Bzip2Error&lt;/code&gt; インポートします。これと同じ</target>
        </trans-unit>
        <trans-unit id="f33038725fdf461a70610da87643ccfeafbb78d0" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;bzip2&lt;/code&gt; and &lt;code&gt;$Bzip2Error&lt;/code&gt;. Same as doing this</source>
          <target state="translated">&lt;code&gt;bzip2&lt;/code&gt; と &lt;code&gt;$Bzip2Error&lt;/code&gt; インポートします。これを行うのと同じ</target>
        </trans-unit>
        <trans-unit id="0f1d5114934adc139dbbd5be66e7aa4d256c7031" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;deflate&lt;/code&gt; , &lt;code&gt;$DeflateError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; . Same as doing this</source>
          <target state="translated">&lt;code&gt;deflate&lt;/code&gt; 、 &lt;code&gt;$DeflateError&lt;/code&gt; 、および &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; で使用できるすべての記号定数をインポートします。これと同じ</target>
        </trans-unit>
        <trans-unit id="0d4974d2c5596367cb5cebb1930f3c2825ac5e43" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;deflate&lt;/code&gt;, &lt;code&gt;$DeflateError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Deflate&lt;/code&gt;. Same as doing this</source>
          <target state="translated">&lt;code&gt;deflate&lt;/code&gt; 、 &lt;code&gt;$DeflateError&lt;/code&gt; 、および &lt;code&gt;IO::Compress::Deflate&lt;/code&gt; で使用できるすべてのシンボリック定数をインポートします。これを行うのと同じ</target>
        </trans-unit>
        <trans-unit id="c0b3cbf51bdd7f4f367077b86b68d9bc7e23e42e" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;gunzip&lt;/code&gt; and &lt;code&gt;$GunzipError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">&lt;code&gt;gunzip&lt;/code&gt; と &lt;code&gt;$GunzipError&lt;/code&gt; インポートします。これと同じ</target>
        </trans-unit>
        <trans-unit id="a1c53346bb70d2ef53cbff855bff6bf49a03d218" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;gunzip&lt;/code&gt; and &lt;code&gt;$GunzipError&lt;/code&gt;. Same as doing this</source>
          <target state="translated">&lt;code&gt;gunzip&lt;/code&gt; と &lt;code&gt;$GunzipError&lt;/code&gt; インポートします。これを行うのと同じ</target>
        </trans-unit>
        <trans-unit id="d34135d0717f9ce2e7a0257450b1f62fae7932dc" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;gzip&lt;/code&gt; , &lt;code&gt;$GzipError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; . Same as doing this</source>
          <target state="translated">&lt;code&gt;gzip&lt;/code&gt; 、 &lt;code&gt;$GzipError&lt;/code&gt; 、および &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; Gzipで使用できるすべての記号定数をインポートします。これと同じ</target>
        </trans-unit>
        <trans-unit id="61371e25038e3f4ac705613da33881c8f7d476ca" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;gzip&lt;/code&gt;, &lt;code&gt;$GzipError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Gzip&lt;/code&gt;. Same as doing this</source>
          <target state="translated">&lt;code&gt;gzip&lt;/code&gt; 、 &lt;code&gt;$GzipError&lt;/code&gt; 、および &lt;code&gt;IO::Compress::Gzip&lt;/code&gt; Gzipで使用できるすべてのシンボリック定数をインポートします。これを行うのと同じ</target>
        </trans-unit>
        <trans-unit id="115a4b04735017c59cebd861430122e98ed196f8" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;inflate&lt;/code&gt; and &lt;code&gt;$InflateError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">&lt;code&gt;inflate&lt;/code&gt; と &lt;code&gt;$InflateError&lt;/code&gt; インポートします。これと同じ</target>
        </trans-unit>
        <trans-unit id="4b984a68fd009c415920f89995a62d37da4180f5" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;inflate&lt;/code&gt; and &lt;code&gt;$InflateError&lt;/code&gt;. Same as doing this</source>
          <target state="translated">&lt;code&gt;inflate&lt;/code&gt; と &lt;code&gt;$InflateError&lt;/code&gt; インポートします。これを行うのと同じ</target>
        </trans-unit>
        <trans-unit id="1ee8ff5937f6a57c492292c874195f1b43a7fe78" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;rawdeflate&lt;/code&gt; , &lt;code&gt;$RawDeflateError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; . Same as doing this</source>
          <target state="translated">輸入は &lt;code&gt;rawdeflate&lt;/code&gt; 、 &lt;code&gt;$RawDeflateError&lt;/code&gt; で使用することができ、すべてのシンボリック定数 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 。これと同じ</target>
        </trans-unit>
        <trans-unit id="6fb62da169da61d1904623e4014ec13f30b31ac3" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;rawdeflate&lt;/code&gt;, &lt;code&gt;$RawDeflateError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt;. Same as doing this</source>
          <target state="translated">輸入は &lt;code&gt;rawdeflate&lt;/code&gt; 、 &lt;code&gt;$RawDeflateError&lt;/code&gt; で使用することができ、すべてのシンボリック定数 &lt;code&gt;IO::Compress::RawDeflate&lt;/code&gt; 。これを行うのと同じ</target>
        </trans-unit>
        <trans-unit id="e767570633f5f871775c917a3828a5e9681f4ffd" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;rawinflate&lt;/code&gt; and &lt;code&gt;$RawInflateError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">&lt;code&gt;rawinflate&lt;/code&gt; と &lt;code&gt;$RawInflateError&lt;/code&gt; インポートします。これと同じ</target>
        </trans-unit>
        <trans-unit id="b57975e38dfb8b63c09125b45981ce41089d4b46" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;rawinflate&lt;/code&gt; and &lt;code&gt;$RawInflateError&lt;/code&gt;. Same as doing this</source>
          <target state="translated">&lt;code&gt;rawinflate&lt;/code&gt; と &lt;code&gt;$RawInflateError&lt;/code&gt; インポートします。これを行うのと同じ</target>
        </trans-unit>
        <trans-unit id="fce5310acfbe49b368b9871554a40ed6e277e8c4" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;unzip&lt;/code&gt; and &lt;code&gt;$UnzipError&lt;/code&gt; . Same as doing this</source>
          <target state="translated">&lt;code&gt;unzip&lt;/code&gt; および &lt;code&gt;$UnzipError&lt;/code&gt; インポートします。これと同じ</target>
        </trans-unit>
        <trans-unit id="8dce59d7727e957411b6cb73347061a330ebfafc" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;unzip&lt;/code&gt; and &lt;code&gt;$UnzipError&lt;/code&gt;. Same as doing this</source>
          <target state="translated">&lt;code&gt;unzip&lt;/code&gt; と &lt;code&gt;$UnzipError&lt;/code&gt; インポートします。これを行うのと同じ</target>
        </trans-unit>
        <trans-unit id="1c2f9178eea45bfd7d471760d92c394f1bace450" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;zip&lt;/code&gt; , &lt;code&gt;$ZipError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Zip&lt;/code&gt; . Same as doing this</source>
          <target state="translated">&lt;code&gt;zip&lt;/code&gt; 、 &lt;code&gt;$ZipError&lt;/code&gt; 、および &lt;code&gt;IO::Compress::Zip&lt;/code&gt; で使用できるすべての記号定数をインポートします。これと同じ</target>
        </trans-unit>
        <trans-unit id="847ef311d8decfad6e9ddb6bbcfbc5b8302cb9bd" translate="yes" xml:space="preserve">
          <source>Imports &lt;code&gt;zip&lt;/code&gt;, &lt;code&gt;$ZipError&lt;/code&gt; and all symbolic constants that can be used by &lt;code&gt;IO::Compress::Zip&lt;/code&gt;. Same as doing this</source>
          <target state="translated">&lt;code&gt;zip&lt;/code&gt; 、 &lt;code&gt;$ZipError&lt;/code&gt; 、および &lt;code&gt;IO::Compress::Zip&lt;/code&gt; で使用できるすべてのシンボリック定数をインポートします。これを行うのと同じ</target>
        </trans-unit>
        <trans-unit id="2699b28db29be60d4c03ef4c15f7b6c27c20980d" translate="yes" xml:space="preserve">
          <source>Imports all the functions.</source>
          <target state="translated">すべての機能をインポートします。</target>
        </trans-unit>
        <trans-unit id="4e34e9af4ba46ea0c9c8bc6002dd0b4972427661" translate="yes" xml:space="preserve">
          <source>Imports some semantics into the current package from the named module, generally by aliasing certain subroutine or variable names into your package. It is exactly equivalent to</source>
          <target state="translated">一般的には、特定のサブルーチン名や変数名をパッケージにエイリアスすることで、名前のついたモジュールから現在のパッケージにセマンティクスをインポートします。これは正確には</target>
        </trans-unit>
        <trans-unit id="3c2be47729bab4d065b481df08ff204f1f40d914" translate="yes" xml:space="preserve">
          <source>Imports the selected functions.</source>
          <target state="translated">選択した関数をインポートします。</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="66efb842734060cc12c6ce77c7726200d42dc777" translate="yes" xml:space="preserve">
          <source>In '(*...)', the '(' and '*' must be adjacent in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">'（* ...）'では、 '（'と '*'は正規表現で隣接している必要があります; &amp;lt;-ここでm /％s /でマークされています</target>
        </trans-unit>
        <trans-unit id="04ead423246f254590da876fbfcf30de3598d538" translate="yes" xml:space="preserve">
          <source>In '(*VERB...)', the '(' and '*' must be adjacent in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">'（* VERB ...）'では、 '（'と '*'は正規表現で隣接している必要があります; &amp;lt;-ここでm /％s /でマークされています</target>
        </trans-unit>
        <trans-unit id="281e0bcccb215aefbdb7e011061a9ea9aefb2638" translate="yes" xml:space="preserve">
          <source>In '(?...)', the '(' and '?' must be adjacent in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">'（？...）'では、 '（'と '？'は正規表現で隣接している必要があります; &amp;lt;-HERE in m /％s /でマークされています</target>
        </trans-unit>
        <trans-unit id="82367e72d0131f5c3fc8d23d0d42328c1c0cde9a" translate="yes" xml:space="preserve">
          <source>In 5.000 to 5.003 perls, trigonometry was done in the &lt;a href=&quot;Math::Complex&quot;&gt;Math::Complex&lt;/a&gt; module. With 5.004, the &lt;a href=&quot;Math::Trig&quot;&gt;Math::Trig&lt;/a&gt; module (part of the standard Perl distribution) implements the trigonometric functions. Internally it uses the &lt;a href=&quot;Math::Complex&quot;&gt;Math::Complex&lt;/a&gt; module and some functions can break out from the real axis into the complex plane, for example the inverse sine of 2.</source>
          <target state="translated">5.000〜5.003 perlsでは、&lt;a href=&quot;Math::Complex&quot;&gt;Math :: Complex&lt;/a&gt;モジュールで三角法が実行されました。5.004では、&lt;a href=&quot;Math::Trig&quot;&gt;Math :: Trig&lt;/a&gt;モジュール（標準のPerlディストリビューションの一部）が三角関数を実装しています。内部的には&lt;a href=&quot;Math::Complex&quot;&gt;Math :: Complex&lt;/a&gt;モジュールを使用し、一部の関数は実軸から複素平面に分割できます。たとえば、2の逆正弦です。</target>
        </trans-unit>
        <trans-unit id="e283b44852c55b8cc7c5d3c10f2fb1158a34c408" translate="yes" xml:space="preserve">
          <source>In 5.000 to 5.003 perls, trigonometry was done in the &lt;a href=&quot;math/complex&quot;&gt;Math::Complex&lt;/a&gt; module. With 5.004, the &lt;a href=&quot;math/trig&quot;&gt;Math::Trig&lt;/a&gt; module (part of the standard Perl distribution) implements the trigonometric functions. Internally it uses the &lt;a href=&quot;math/complex&quot;&gt;Math::Complex&lt;/a&gt; module and some functions can break out from the real axis into the complex plane, for example the inverse sine of 2.</source>
          <target state="translated">5.000から5.003のperlsでは、三角法は&lt;a href=&quot;math/complex&quot;&gt;Math :: Complex&lt;/a&gt;モジュールで行われました。5.004では、&lt;a href=&quot;math/trig&quot;&gt;Math :: Trig&lt;/a&gt;モジュール（標準Perl配布の一部）が三角関数を実装します。内部的には、&lt;a href=&quot;math/complex&quot;&gt;Math :: Complex&lt;/a&gt;モジュールを使用し、2の逆サインなど、一部の関数は実軸から複素平面にブレークアウトできます。</target>
        </trans-unit>
        <trans-unit id="391231c66e45cffb8636a5bb3b30c41c9673affc" translate="yes" xml:space="preserve">
          <source>In 5.9.3, &lt;code&gt;newSV()&lt;/code&gt; replaces the older &lt;code&gt;NEWSV()&lt;/code&gt; API, and drops the first parameter,</source>
          <target state="translated">5.9.3では、 &lt;code&gt;newSV()&lt;/code&gt; が古い &lt;code&gt;NEWSV()&lt;/code&gt; APIを置き換え、最初のパラメーターを削除します。</target>
        </trans-unit>
        <trans-unit id="608cccc0c9bbe325204a599a0810ba75fef50b66" translate="yes" xml:space="preserve">
          <source>In 5.9.3, Newx() and friends replace the older New() API, and drops the first parameter,</source>
          <target state="translated">5.9.3 では、Newx()とその仲間は古い New()API を置き換え、最初のパラメータを削除しています。</target>
        </trans-unit>
        <trans-unit id="05edeadfa5f882c58e75733f9ca5c3ffa7b75300" translate="yes" xml:space="preserve">
          <source>In 5.9.3, newSV() replaces the older NEWSV() API, and drops the first parameter,</source>
          <target state="translated">5.9.3 では、newSV()は古い NEWSV()API を置き換え、最初のパラメータを削除しました。</target>
        </trans-unit>
        <trans-unit id="91471efa4c1c6dedd1aca89f914cfd68ba91a793" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#EXAMPLE-4&quot;&gt;&quot;EXAMPLE 4&quot;&lt;/a&gt; the second part of .xs file contained the following description of an XSUB:</source>
          <target state="translated">&lt;a href=&quot;#EXAMPLE-4&quot;&gt;「実施例4」&lt;/a&gt; .xsファイルの第2の部分はXSUBの以下の説明を含んでいました。</target>
        </trans-unit>
        <trans-unit id="a0bd3ec2d46f47a7c53bb5eb7fb75ed665e3e0d8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#EXAMPLE-4&quot;&gt;EXAMPLE 4&lt;/a&gt; the second part of .xs file contained the following description of an XSUB:</source>
          <target state="translated">&lt;a href=&quot;#EXAMPLE-4&quot;&gt;実施例4&lt;/a&gt; .xsファイルの第2の部分は、XSUBの以下の説明を含んでいました。</target>
        </trans-unit>
        <trans-unit id="7e5fcf76d62ca3c453f917d125d255840ab14460" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#Use-Rule-1&quot;&gt;&lt;b&gt;Use Rule 1&lt;/b&gt;&lt;/a&gt;, you can omit the curly brackets whenever the thing inside them is an atomic scalar variable like &lt;code&gt;$aref&lt;/code&gt;. For example, &lt;code&gt;@$aref&lt;/code&gt; is the same as &lt;code&gt;@{$aref}&lt;/code&gt;, and &lt;code&gt;$$aref[1]&lt;/code&gt; is the same as &lt;code&gt;${$aref}[1]&lt;/code&gt;. If you're just starting out, you may want to adopt the habit of always including the curly brackets.</source>
          <target state="translated">で&lt;a href=&quot;#Use-Rule-1&quot;&gt;&lt;b&gt;使用ルール1&lt;/b&gt;&lt;/a&gt;、それらの内部の事のようなアトミックスカラー変数である時はいつでも、あなたは、中括弧を省略することができます &lt;code&gt;$aref&lt;/code&gt; 。たとえば、 &lt;code&gt;@$aref&lt;/code&gt; は &lt;code&gt;@{$aref}&lt;/code&gt; と同じであり、 &lt;code&gt;$$aref[1]&lt;/code&gt; は &lt;code&gt;${$aref}[1]&lt;/code&gt; と同じです。始めたばかりの場合は、常に中括弧を含める習慣を身に付けたいと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="410447fdc9620665a31407179d6df63d2c4b3f50" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;perlfunc#split&quot;&gt;&lt;code&gt;split&lt;/code&gt;'s special-case whitespace splitting&lt;/a&gt;.</source>
          <target state="translated">では&lt;a href=&quot;perlfunc#split&quot;&gt; &lt;code&gt;split&lt;/code&gt; の特殊なケースの空白分割&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f10507678ddeb0946365b72294700c17d41e824f" translate="yes" xml:space="preserve">
          <source>In &lt;b&gt;Use Rule 1&lt;/b&gt;, you can omit the curly brackets whenever the thing inside them is an atomic scalar variable like &lt;code&gt;$aref&lt;/code&gt; . For example, &lt;code&gt;@$aref&lt;/code&gt; is the same as &lt;code&gt;@{$aref}&lt;/code&gt; , and &lt;code&gt;$$aref[1]&lt;/code&gt; is the same as &lt;code&gt;${$aref}[1]&lt;/code&gt; . If you're just starting out, you may want to adopt the habit of always including the curly brackets.</source>
          <target state="translated">で&lt;b&gt;使用ルール1&lt;/b&gt;、それらの内部の事のようなアトミックスカラー変数である時はいつでも、あなたは、中括弧を省略することができます &lt;code&gt;$aref&lt;/code&gt; 。たとえば、 &lt;code&gt;@$aref&lt;/code&gt; は &lt;code&gt;@{$aref}&lt;/code&gt; と同じであり、 &lt;code&gt;$$aref[1]&lt;/code&gt; は &lt;code&gt;${$aref}[1]&lt;/code&gt; と同じです。始めたばかりの場合は、中かっこを常に含めるという習慣を採用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="557547e0e5d90bb8da914cf09cde8cf85870da5a" translate="yes" xml:space="preserve">
          <source>In &lt;b&gt;shell&lt;/b&gt; programming, the syntactic combination of a program name and its arguments. More loosely, anything you type to a shell (a command interpreter) that starts it doing something. Even more loosely, a Perl &lt;b&gt;statement&lt;/b&gt;, which might start with a &lt;b&gt;label&lt;/b&gt; and typically ends with a semicolon.</source>
          <target state="translated">では&lt;b&gt;シェル&lt;/b&gt;プログラミング、プログラム名とその引数の構文の組み合わせ。より大まかに言えば、何かを実行するシェル（コマンドインタープリター）に入力するものすべて。さらに緩く、Perlの&lt;b&gt;声明&lt;/b&gt;を開始する可能性があります、&lt;b&gt;ラベル&lt;/b&gt;と通常セミコロンで終了します。</target>
        </trans-unit>
        <trans-unit id="53ee753ac80ffc3ee3ab0c0d4d2f6ebc840fe7cc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;(?...)&lt;/code&gt; both absolute and relative backreferences may be used. The entire pattern can be reinserted with &lt;code&gt;(?R)&lt;/code&gt; or &lt;code&gt;(?0)&lt;/code&gt;. If you prefer to name your groups, you can use &lt;code&gt;(?&amp;amp;&lt;i&gt;name&lt;/i&gt;)&lt;/code&gt; to recurse into that group.</source>
          <target state="translated">で &lt;code&gt;(?...)&lt;/code&gt; の両方の絶対的及び相対後方参照を使用することができます。パターン全体を &lt;code&gt;(?R)&lt;/code&gt; または &lt;code&gt;(?0)&lt;/code&gt; で再挿入できます。グループに名前を付ける場合は、 &lt;code&gt;(?&amp;amp;&lt;i&gt;name&lt;/i&gt;)&lt;/code&gt; を使用してそのグループに戻ることができます。</target>
        </trans-unit>
        <trans-unit id="893925583fca341ee58483bd99d5162198b9d0c6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;(?...)&lt;/code&gt; both absolute and relative backreferences may be used. The entire pattern can be reinserted with &lt;code&gt;(?R)&lt;/code&gt; or &lt;code&gt;(?0)&lt;/code&gt;. If you prefer to name your groups, you can use &lt;code&gt;(?&amp;amp;name)&lt;/code&gt; to recurse into that group.</source>
          <target state="translated">で &lt;code&gt;(?...)&lt;/code&gt; の両方の絶対的及び相対後方参照を使用することができます。パターン全体は &lt;code&gt;(?R)&lt;/code&gt; または &lt;code&gt;(?0)&lt;/code&gt; で再挿入できます。グループに名前を付けたい場合は、 &lt;code&gt;(?&amp;amp;name)&lt;/code&gt; を使用してそのグループに再帰できます。</target>
        </trans-unit>
        <trans-unit id="b10785862bf5b38351d62f7106b1ad5b616fb632" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;::INET&lt;/code&gt;, supplying a timeout overrides the non-blocking behaviour, meaning that the &lt;code&gt;connect()&lt;/code&gt; operation will still block despite that the caller asked for a non-blocking socket. This is not explicitly specified in its documentation, nor does this author believe that is a useful behaviour - it appears to come from a quirk of implementation.</source>
          <target state="translated">で &lt;code&gt;::INET&lt;/code&gt; 、タイムアウトを供給することを意味し、非ブロック動作を無効にし &lt;code&gt;connect()&lt;/code&gt; 操作はまだ呼び出し側が非ブロックソケットを求めていることにもかかわらず、ブロックします。これはそのドキュメントで明示的に指定されておらず、この作者はそれが有用な動作であるとは信じていません-それは実装の癖から来ているようです。</target>
        </trans-unit>
        <trans-unit id="8e4a1ba97b2988d6a2be557e546a113f04c6f316" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;::IP&lt;/code&gt; therefore, the &lt;code&gt;Blocking&lt;/code&gt; parameter takes precedence - if a non-blocking socket is requested, no operation will block. The &lt;code&gt;Timeout&lt;/code&gt; parameter here simply defines the maximum time that a blocking &lt;code&gt;connect()&lt;/code&gt; call will wait, if it blocks at all.</source>
          <target state="translated">で &lt;code&gt;::IP&lt;/code&gt; ので、 &lt;code&gt;Blocking&lt;/code&gt; のパラメータが優先されます-非ブロックソケットが要求された場合、何も操作はブロックされません。ここでの &lt;code&gt;Timeout&lt;/code&gt; パラメーターは、ブロックしている &lt;code&gt;connect()&lt;/code&gt; 呼び出しがブロックされた場合に待機する最大時間を定義するだけです。</target>
        </trans-unit>
        <trans-unit id="38fa69a28fd92dcbb1d20c664855898c29a90ccb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; or its inline equivalent &lt;code&gt;\Q&lt;/code&gt; .</source>
          <target state="translated">で &lt;code&gt;&lt;a href=&quot;functions/quotemeta&quot;&gt;quotemeta&lt;/a&gt;&lt;/code&gt; またはそのインライン同等 &lt;code&gt;\Q&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d1fe5fe4877107e3688ff937058cd386854f2587" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Compress::Zlib&lt;/code&gt; version 1.x, &lt;code&gt;gzopen&lt;/code&gt; used the zlib library to open the underlying file. This made things especially tricky when a Perl filehandle was passed to &lt;code&gt;gzopen&lt;/code&gt; . Behind the scenes the numeric C file descriptor had to be extracted from the Perl filehandle and this passed to the zlib library.</source>
          <target state="translated">で &lt;code&gt;Compress::Zlib&lt;/code&gt; バージョン1.x、 &lt;code&gt;gzopen&lt;/code&gt; 根底にあるファイルを開くにはzlibライブラリを使用。これにより、Perlファイルハンドルが &lt;code&gt;gzopen&lt;/code&gt; に渡されたときに、特に注意が必要になります。裏では、数値Cファイル記述子をPerlファイルハンドルから抽出し、これをzlibライブラリに渡す必要がありました。</target>
        </trans-unit>
        <trans-unit id="97042f19f30bdce3cf114acbac1fee77bdb7a505" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Compress::Zlib&lt;/code&gt; version 1.x, &lt;code&gt;gzopen&lt;/code&gt; used the zlib library to open the underlying file. This made things especially tricky when a Perl filehandle was passed to &lt;code&gt;gzopen&lt;/code&gt;. Behind the scenes the numeric C file descriptor had to be extracted from the Perl filehandle and this passed to the zlib library.</source>
          <target state="translated">で &lt;code&gt;Compress::Zlib&lt;/code&gt; バージョン1.x、 &lt;code&gt;gzopen&lt;/code&gt; 根底にあるファイルを開くにはzlibライブラリを使用。これにより、Perlファイルハンドルが &lt;code&gt;gzopen&lt;/code&gt; に渡されたときに特に注意が必要になりました。舞台裏では、数値のCファイル記述子をPerlファイルハンドルから抽出する必要があり、これがzlibライブラリに渡されました。</target>
        </trans-unit>
        <trans-unit id="bccc4f78696454721af791a75896e8b3d0106582" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Compress::Zlib&lt;/code&gt; version 2.x, the &lt;code&gt;gzopen&lt;/code&gt; interface has been completely rewritten to use the &lt;a href=&quot;../io/compress/gzip&quot;&gt;IO::Compress::Gzip&lt;/a&gt; for writing gzip files and &lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt; for reading gzip files. None of the limitations mentioned above apply.</source>
          <target state="translated">で &lt;code&gt;Compress::Zlib&lt;/code&gt; バージョン2.x、 &lt;code&gt;gzopen&lt;/code&gt; インタフェースを完全に使用するようにリライトされた&lt;a href=&quot;../io/compress/gzip&quot;&gt;IOを::圧縮:: Gzipで&lt;/a&gt;のgzipファイルを書き込むためおよび&lt;a href=&quot;../io/uncompress/gunzip&quot;&gt;IO ::解凍:: Gunzipの&lt;/a&gt; GZIPファイルを読み込むため。上記の制限は適用されません。</target>
        </trans-unit>
        <trans-unit id="114d7ddba5b93cb861ecd5013f29d98f83ffbb88" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Compress::Zlib&lt;/code&gt; version 2.x, the &lt;code&gt;gzopen&lt;/code&gt; interface has been completely rewritten to use the &lt;a href=&quot;IO::Compress::Gzip&quot;&gt;IO::Compress::Gzip&lt;/a&gt; for writing gzip files and &lt;a href=&quot;IO::Uncompress::Gunzip&quot;&gt;IO::Uncompress::Gunzip&lt;/a&gt; for reading gzip files. None of the limitations mentioned above apply.</source>
          <target state="translated">で &lt;code&gt;Compress::Zlib&lt;/code&gt; バージョン2.x、 &lt;code&gt;gzopen&lt;/code&gt; インタフェースを完全に使用するようにリライトされた&lt;a href=&quot;IO::Compress::Gzip&quot;&gt;IOを::圧縮:: Gzipで&lt;/a&gt;のgzipファイルを書き込むためおよび&lt;a href=&quot;IO::Uncompress::Gunzip&quot;&gt;IO ::解凍:: Gunzipの&lt;/a&gt;GZIPファイルを読み込むため。上記の制限はいずれも適用されません。</target>
        </trans-unit>
        <trans-unit id="e00aec70e3db954ff900ae2d1de9b4a90ac0844b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Encode&lt;/code&gt; 2.10 or later, &lt;code&gt;LEAVE_SRC&lt;/code&gt; is also implied.</source>
          <target state="translated">で &lt;code&gt;Encode&lt;/code&gt; 2.10以降、 &lt;code&gt;LEAVE_SRC&lt;/code&gt; をも暗示されています。</target>
        </trans-unit>
        <trans-unit id="51676bb8ef9795bee4bcbafed10516b2d6301ddf" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;native floating point --&amp;gt; native integer&lt;/code&gt; conversions the magnitude of the result is less than or equal to the magnitude of the source. (</source>
          <target state="translated">&lt;code&gt;native floating point --&amp;gt; native integer&lt;/code&gt; 変換は、結果の大きさは、以下のソースの大きさに等しいです。（</target>
        </trans-unit>
        <trans-unit id="7be347ab93d082d1dfdcfb29ae91a2b4d0db0749" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;quotemeta&lt;/code&gt; or its inline equivalent &lt;code&gt;\Q&lt;/code&gt;.</source>
          <target state="translated">で &lt;code&gt;quotemeta&lt;/code&gt; またはそのインライン同等 &lt;code&gt;\Q&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67145b5258ab605d487808bb8f38203833e35128" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;simple_replace&lt;/code&gt; we used the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; modifier to replace all occurrences of the regexp on each line. (Even though the regular expression appears in a loop, Perl is smart enough to compile it only once.) As with &lt;code&gt;simple_grep&lt;/code&gt; , both the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/$regexp/$replacement/g&lt;/a&gt;&lt;/code&gt; use &lt;code&gt;$_&lt;/code&gt; implicitly.</source>
          <target state="translated">で &lt;code&gt;simple_replace&lt;/code&gt; 我々は、使用 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; 各行の正規表現のすべての出現を置き換えるために修飾子を。（正規表現がループ内にある場合でも、Perlは1回だけコンパイルするのに十分スマートです。） &lt;code&gt;simple_grep&lt;/code&gt; と同様に、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s/$regexp/$replacement/g&lt;/a&gt;&lt;/code&gt; 両方が暗黙的に &lt;code&gt;$_&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="7c4415b354d21581248c9b504615aa6c75b8d907" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;simple_replace&lt;/code&gt; we used the &lt;code&gt;s///g&lt;/code&gt; modifier to replace all occurrences of the regexp on each line. (Even though the regular expression appears in a loop, Perl is smart enough to compile it only once.) As with &lt;code&gt;simple_grep&lt;/code&gt;, both the &lt;code&gt;print&lt;/code&gt; and the &lt;code&gt;s/$regexp/$replacement/g&lt;/code&gt; use &lt;code&gt;$_&lt;/code&gt; implicitly.</source>
          <target state="translated">で &lt;code&gt;simple_replace&lt;/code&gt; 我々は、使用 &lt;code&gt;s///g&lt;/code&gt; 各行の正規表現のすべての出現を置き換えるために修飾子を。 （正規表現はループ内に表示されますが、Perlはそれを1回だけコンパイルするのに十分賢いです。） &lt;code&gt;simple_grep&lt;/code&gt; と同様に、 &lt;code&gt;print&lt;/code&gt; と &lt;code&gt;s/$regexp/$replacement/g&lt;/code&gt; replace / gの両方が暗黙的に &lt;code&gt;$_&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="d077e5ff0102748fbe2d5e45a0e1e202f0802167" translate="yes" xml:space="preserve">
          <source>In AIX 4.2 Perl extensions that use C++ functions that use statics may have problems in that the statics are not getting initialized. In newer AIX releases this has been solved by linking Perl with the libC_r library, but unfortunately in AIX 4.2 the said library has an obscure bug where the various functions related to time (such as time() and gettimeofday()) return broken values, and therefore in AIX 4.2 Perl is not linked against the libC_r.</source>
          <target state="translated">AIX 4.2 では、C++の関数を使用してスタティックを使用する Perl の拡張機能は、スタティックが初期化されないという問題があるかもしれません。しかし、残念ながら AIX 4.2 では、時間に関連する様々な関数 (time()や gettimeofday()など)が壊れた値を返すという不明瞭なバグがあるため、AIX 4.2 では Perl は libC_r に対してリンクされていません。</target>
        </trans-unit>
        <trans-unit id="5c64677f24dcacb245231383a983d4852fe14280" translate="yes" xml:space="preserve">
          <source>In BigInt, all numbers except &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; and &lt;code&gt;-inf&lt;/code&gt; are integers.</source>
          <target state="translated">&lt;code&gt;-inf&lt;/code&gt; では、 &lt;code&gt;NaN&lt;/code&gt; 、 &lt;code&gt;+inf&lt;/code&gt; および-infを除くすべての数値は整数です。</target>
        </trans-unit>
        <trans-unit id="f83bdc44eedb56878bfa30e1ea8c050d2167ca73" translate="yes" xml:space="preserve">
          <source>In BigInt, unless upgrading is in effect, the result is truncated to an integer.</source>
          <target state="translated">BigInt では、アップグレードが有効でない限り、結果は整数に切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="a6200922eb25a34272b79346b2b9f5be87e701ac" translate="yes" xml:space="preserve">
          <source>In CVS and RCS version 1.9 is followed by 1.10. Since CPAN compares version numbers numerically we use a sprintf() to convert 1.9 to 1.009 and 1.10 to 1.010 which compare properly.</source>
          <target state="translated">CVSとRCSでは、バージョン1.9の後に1.10が続きます。CPANはバージョン番号を数値で比較するので、sprintf()を使って1.9を1.009に、1.10を1.010に変換しています。</target>
        </trans-unit>
        <trans-unit id="e6d98db49c1b068959bb3c31358e246a1630b67a" translate="yes" xml:space="preserve">
          <source>In CVS, RCS and SVN you use $Revision$ (see the documentation of your version control system for details). Every time the file is checked in the $Revision$ will be updated, updating your $VERSION.</source>
          <target state="translated">CVS、RCS、SVN では $Revision$ を使用します (詳細はバージョン管理システムのドキュメントを参照してください)。ファイルがチェックインされるたびに $Revision$ が更新され、$VERSION が更新されます。</target>
        </trans-unit>
        <trans-unit id="562c80499b9073a3905b98e95f6a9c71ca119547" translate="yes" xml:space="preserve">
          <source>In Cray UNICOS there is some strange numerical instability that results in root(), cos(), sin(), cosh(), sinh(), losing accuracy fast. Beware. The bug may be in UNICOS math libs, in UNICOS C compiler, in Math::Complex. Whatever it is, it does not manifest itself anywhere else where Perl runs.</source>
          <target state="translated">Cray UNICOSでは、奇妙な数値的不安定性があり、その結果、root(),cos(),sin(),cosh(),sinh()の精度が早く失われてしまいます。注意してください。このバグはUNICOSの数学ライブラリ、UNICOSのCコンパイラ、Math::Complexにあるかもしれません。それが何であれ、Perl が動作する他の場所では、このバグは現れません。</target>
        </trans-unit>
        <trans-unit id="c2148313df160c8d66540765266d0deaea355ab2" translate="yes" xml:space="preserve">
          <source>In DUCET v4.0.0, primary weight of &lt;code&gt;C&lt;/code&gt; is &lt;code&gt;0E60&lt;/code&gt; and that of &lt;code&gt;D&lt;/code&gt; is &lt;code&gt;0E6D&lt;/code&gt; . So setting primary weight of &lt;code&gt;CH&lt;/code&gt; to &lt;code&gt;0E6A&lt;/code&gt; (as a value between &lt;code&gt;0E60&lt;/code&gt; and &lt;code&gt;0E6D&lt;/code&gt; ) makes ordering as &lt;code&gt;C &amp;lt; CH &amp;lt; D&lt;/code&gt; . Exactly speaking DUCET already has some characters between &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; : &lt;code&gt;small capital C&lt;/code&gt; (&lt;code&gt;U+1D04&lt;/code&gt;) with primary weight &lt;code&gt;0E64&lt;/code&gt; , &lt;code&gt;c-hook/C-hook&lt;/code&gt; (&lt;code&gt;U+0188/U+0187&lt;/code&gt;) with &lt;code&gt;0E65&lt;/code&gt; , and &lt;code&gt;c-curl&lt;/code&gt; (&lt;code&gt;U+0255&lt;/code&gt; ) with &lt;code&gt;0E69&lt;/code&gt; . Then primary weight &lt;code&gt;0E6A&lt;/code&gt; for &lt;code&gt;CH&lt;/code&gt; makes &lt;code&gt;CH&lt;/code&gt; ordered between &lt;code&gt;c-curl&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; .</source>
          <target state="translated">DUCET v4.0.0では、 &lt;code&gt;C&lt;/code&gt; のプライマリウェイトは &lt;code&gt;0E60&lt;/code&gt; で、 &lt;code&gt;D&lt;/code&gt; のプライマリウェイトは &lt;code&gt;0E6D&lt;/code&gt; です。したがって、 &lt;code&gt;CH&lt;/code&gt; のプライマリウェイトを &lt;code&gt;0E6A&lt;/code&gt; に（ &lt;code&gt;0E60&lt;/code&gt; と &lt;code&gt;0E6D&lt;/code&gt; の間の値として）設定すると、 &lt;code&gt;C &amp;lt; CH &amp;lt; D&lt;/code&gt; 順序になります。正確に言えばDUCETは既にの間にいくつかの文字を有する &lt;code&gt;C&lt;/code&gt; および &lt;code&gt;D&lt;/code&gt; ： &lt;code&gt;small capital C&lt;/code&gt; （ &lt;code&gt;U+1D04&lt;/code&gt; 主要量を有する） &lt;code&gt;0E64&lt;/code&gt; 、 &lt;code&gt;c-hook/C-hook&lt;/code&gt; （ &lt;code&gt;U+0188/U+0187&lt;/code&gt; ）と &lt;code&gt;0E65&lt;/code&gt; 、および &lt;code&gt;c-curl&lt;/code&gt; （ &lt;code&gt;U+0255&lt;/code&gt; ） &lt;code&gt;0E69&lt;/code&gt; で。次いで、一次重量 &lt;code&gt;0E6A&lt;/code&gt; 用 &lt;code&gt;CH&lt;/code&gt; になり &lt;code&gt;CH&lt;/code&gt; が間順序付け &lt;code&gt;c-curl&lt;/code&gt; 及び &lt;code&gt;D&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9108a2eddf4a9c8b757bb1b0b2974cb82775ee81" translate="yes" xml:space="preserve">
          <source>In DUCET v4.0.0, primary weight of &lt;code&gt;C&lt;/code&gt; is &lt;code&gt;0E60&lt;/code&gt; and that of &lt;code&gt;D&lt;/code&gt; is &lt;code&gt;0E6D&lt;/code&gt;. So setting primary weight of &lt;code&gt;CH&lt;/code&gt; to &lt;code&gt;0E6A&lt;/code&gt; (as a value between &lt;code&gt;0E60&lt;/code&gt; and &lt;code&gt;0E6D&lt;/code&gt;) makes ordering as &lt;code&gt;C &amp;lt; CH &amp;lt; D&lt;/code&gt;. Exactly speaking DUCET already has some characters between &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt;: &lt;code&gt;small capital C&lt;/code&gt; (&lt;code&gt;U+1D04&lt;/code&gt;) with primary weight &lt;code&gt;0E64&lt;/code&gt;, &lt;code&gt;c-hook/C-hook&lt;/code&gt; (&lt;code&gt;U+0188/U+0187&lt;/code&gt;) with &lt;code&gt;0E65&lt;/code&gt;, and &lt;code&gt;c-curl&lt;/code&gt; (&lt;code&gt;U+0255&lt;/code&gt;) with &lt;code&gt;0E69&lt;/code&gt;. Then primary weight &lt;code&gt;0E6A&lt;/code&gt; for &lt;code&gt;CH&lt;/code&gt; makes &lt;code&gt;CH&lt;/code&gt; ordered between &lt;code&gt;c-curl&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt;.</source>
          <target state="translated">DUCET v4.0.0では、 &lt;code&gt;C&lt;/code&gt; のプライマリウェイトは &lt;code&gt;0E60&lt;/code&gt; で、 &lt;code&gt;D&lt;/code&gt; のプライマリウェイトは &lt;code&gt;0E6D&lt;/code&gt; です。したがって、 &lt;code&gt;CH&lt;/code&gt; の一次重みを &lt;code&gt;0E6A&lt;/code&gt; に設定すると（ &lt;code&gt;0E60&lt;/code&gt; と &lt;code&gt;0E6D&lt;/code&gt; の間の値として）、 &lt;code&gt;C &amp;lt; CH &amp;lt; D&lt;/code&gt; として順序付けされます。正確に言えば、DUCETにはすでに &lt;code&gt;C&lt;/code&gt; と &lt;code&gt;D&lt;/code&gt; の間にいくつかの文字があります： &lt;code&gt;small capital C&lt;/code&gt; （ &lt;code&gt;U+1D04&lt;/code&gt; ）、プライマリウェイト &lt;code&gt;0E64&lt;/code&gt; 、 &lt;code&gt;c-hook/C-hook&lt;/code&gt; （ &lt;code&gt;U+0188/U+0187&lt;/code&gt; ）、 &lt;code&gt;0E65&lt;/code&gt; 、および &lt;code&gt;c-curl&lt;/code&gt; （ &lt;code&gt;U+0255&lt;/code&gt; ） &lt;code&gt;0E69&lt;/code&gt; を使用します。次に、 &lt;code&gt;CH&lt;/code&gt; のプライマリウェイト &lt;code&gt;0E6A&lt;/code&gt; により、 &lt;code&gt;CH&lt;/code&gt; は &lt;code&gt;c-curl&lt;/code&gt; と &lt;code&gt;D&lt;/code&gt; の間で順序付けられます。</target>
        </trans-unit>
        <trans-unit id="3cbd5bc5a38769b2182dd3a8ac3c64a575d3f230" translate="yes" xml:space="preserve">
          <source>In English grammar, a short noun phrase between a verb and its direct object indicating the beneficiary or recipient of the action. In Perl, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; STDOUT &quot;$foo\n&quot;;&lt;/code&gt; can be understood as &amp;ldquo;verb indirect-object object&amp;rdquo;, where &lt;code&gt;STDOUT&lt;/code&gt; is the recipient of the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; action, and &lt;code&gt;&quot;$foo&quot;&lt;/code&gt; is the object being printed. Similarly, when invoking a &lt;b&gt;method&lt;/b&gt;, you might place the invocant in the dative slot between the method and its arguments:</source>
          <target state="translated">英語の文法で、動詞とその直接のオブジェクトの間の短い名詞句で、アクションの受益者または受信者を示します。Perlでは、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt; STDOUT &quot;$foo\n&quot;;&lt;/code&gt; 「動詞間接オブジェクトオブジェクト」として理解できます。ここで、 &lt;code&gt;STDOUT&lt;/code&gt; は &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; アクションの受信者であり、 &lt;code&gt;&quot;$foo&quot;&lt;/code&gt; は印刷されるオブジェクトです。呼び出すとき同様、&lt;b&gt;この方法を&lt;/b&gt;、あなたはメソッドとその引数の間の配位のスロットにインボカントを置くかもしれません。</target>
        </trans-unit>
        <trans-unit id="06b568eacf88b97c4f6196a1f9c16a7ddc571968" translate="yes" xml:space="preserve">
          <source>In English grammar, a short noun phrase between a verb and its direct object indicating the beneficiary or recipient of the action. In Perl, &lt;code&gt;print STDOUT &quot;$foo\n&quot;;&lt;/code&gt; can be understood as &amp;ldquo;verb indirect-object object&amp;rdquo;, where &lt;code&gt;STDOUT&lt;/code&gt; is the recipient of the &lt;code&gt;print&lt;/code&gt; action, and &lt;code&gt;&quot;$foo&quot;&lt;/code&gt; is the object being printed. Similarly, when invoking a &lt;b&gt;method&lt;/b&gt;, you might place the invocant in the dative slot between the method and its arguments:</source>
          <target state="translated">英文法において、動詞とその直接目的語の間の短い名詞句は、アクションの受益者または受信者を示します。Perlでは、 &lt;code&gt;print STDOUT &quot;$foo\n&quot;;&lt;/code&gt; 「動詞間接目的語オブジェクト」として理解できます。ここで、 &lt;code&gt;STDOUT&lt;/code&gt; は &lt;code&gt;print&lt;/code&gt; アクションの受信者であり、 &lt;code&gt;&quot;$foo&quot;&lt;/code&gt; は印刷されるオブジェクトです。呼び出すとき同様、&lt;b&gt;この方法を&lt;/b&gt;、あなたはメソッドとその引数の間の配位のスロットにインボカントを置くかもしれません。</target>
        </trans-unit>
        <trans-unit id="30d7750b76c1912ccfb266e5802e9aeb1ba6b515" translate="yes" xml:space="preserve">
          <source>In February 2017 the cPanel Security Team reported an additional vulnerability in File-Path. The &lt;code&gt;chmod()&lt;/code&gt; logic to make directories traversable can be abused to set the mode on an attacker-chosen file to an attacker-chosen value. This is due to the time-of-check-to-time-of-use (TOCTTOU) race condition (&lt;a href=&quot;https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use&quot;&gt;https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use&lt;/a&gt;) between the &lt;code&gt;stat()&lt;/code&gt; that decides the inode is a directory and the &lt;code&gt;chmod()&lt;/code&gt; that tries to make it user-rwx. CPAN versions 2.13 and later incorporate a patch provided by John Lightsey to address this problem. This vulnerability has been reported as CVE-2017-6512.</source>
          <target state="translated">2017年2月、cPanelセキュリティチームはFile-Pathに追加の脆弱性を報告しました。 &lt;code&gt;chmod()&lt;/code&gt; のロジックは、攻撃者が選択した値に攻撃者が選択したファイルにモードを設定するために悪用される可能性が一筆ディレクトリを作成します。これは、iノードがディレクトリであると判断する &lt;code&gt;stat()&lt;/code&gt; 間のtime-of-check-to-time-of-use（TOCTTOU）の競合状態（&lt;a href=&quot;https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use&quot;&gt;https://en.wikipedia.org/wiki/Time_of_check_to_time_of_use&lt;/a&gt;）によるものです。そしてそれをuser-rwxにしようとする &lt;code&gt;chmod()&lt;/code&gt; 。CPANバージョン2.13以降には、この問題に対処するためにJohnLightseyが提供するパッチが組み込まれています。この脆弱性はCVE-2017-6512として報告されています。</target>
        </trans-unit>
        <trans-unit id="217cde63e66af3805baaae8b61bf234934e3a17f" translate="yes" xml:space="preserve">
          <source>In IRIX 5.3 and with Perl 5.8.1 (Perl 5.8.0 didn't compile in IRIX 5.3) the following failures are known.</source>
          <target state="translated">IRIX 5.3およびPerl 5.8.1では(IRIX 5.3ではPerl 5.8.0はコンパイルされませんでした)、以下のような障害が発生することが知られています。</target>
        </trans-unit>
        <trans-unit id="ae875351a921c55e10385097f1ce568f0cc36c5c" translate="yes" xml:space="preserve">
          <source>In MakeMaker-based installations,</source>
          <target state="translated">MakeMaker ベースのインストールでは。</target>
        </trans-unit>
        <trans-unit id="9c3daa3a40c6c633fa39ff2200e0ca157291c425" translate="yes" xml:space="preserve">
          <source>In Math::BigFloat, &lt;code&gt;as_float()&lt;/code&gt; has the same effect as &lt;code&gt;copy()&lt;/code&gt;.</source>
          <target state="translated">Math :: BigFloatでは、 &lt;code&gt;as_float()&lt;/code&gt; は &lt;code&gt;copy()&lt;/code&gt; と同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="5e41060b8b4a1259b3e9cbe537abe5b49f3f3c1c" translate="yes" xml:space="preserve">
          <source>In Math::BigInt, &lt;code&gt;as_int()&lt;/code&gt; has the same effect as &lt;code&gt;copy()&lt;/code&gt;.</source>
          <target state="translated">Math :: &lt;code&gt;as_int()&lt;/code&gt; では、as_int（）は &lt;code&gt;copy()&lt;/code&gt; と同じ効果があります。</target>
        </trans-unit>
        <trans-unit id="a8ca889adcc661187e58d592f4912a7f93ee302a" translate="yes" xml:space="preserve">
          <source>In Math::BigInt, passing a negative number precision has no effect since no numbers have digits after the dot. In &lt;a href=&quot;bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;, it will round all results to P digits after the dot.</source>
          <target state="translated">Math :: BigIntでは、ドットの後に数字がないため、負の数値精度を渡しても効果はありません。で&lt;a href=&quot;bigfloat&quot;&gt;数学::ビッグフロート&lt;/a&gt;、それはドットの後にPの桁にすべての結果を丸めます。</target>
        </trans-unit>
        <trans-unit id="e908380ff562833ce5edafb0da699c167037b50c" translate="yes" xml:space="preserve">
          <source>In Math::BigInt, this method is identical to &lt;code&gt;parts()&lt;/code&gt;.</source>
          <target state="translated">Math :: BigIntでは、このメソッドは &lt;code&gt;parts()&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="4d74a3513f84eb343c782544d1a1cd43c3880330" translate="yes" xml:space="preserve">
          <source>In Math::BigInt, unless upgrading is in effect, the result is truncated to an integer.</source>
          <target state="translated">Math::BigInt では、アップグレードが有効でない限り、結果は整数に切り捨てられます。</target>
        </trans-unit>
        <trans-unit id="846e78092ad74f765fcf7c9c94ce51c84e742d1b" translate="yes" xml:space="preserve">
          <source>In Memory Databases</source>
          <target state="translated">インメモリーデータベース</target>
        </trans-unit>
        <trans-unit id="3f860bffab3d111dbe427091c4d724eab7972b48" translate="yes" xml:space="preserve">
          <source>In Part 1 we mentioned that Perl compiles a regexp into a compact sequence of opcodes. Thus, a compiled regexp is a data structure that can be stored once and used again and again. The regexp quote &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; does exactly that: &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/string/&lt;/a&gt;&lt;/code&gt; compiles the &lt;code&gt;string&lt;/code&gt; as a regexp and transforms the result into a form that can be assigned to a variable:</source>
          <target state="translated">パート1で、Perlは正規表現をコンパクトな一連のopcodeにコンパイルすることを述べました。したがって、コンパイルされた正規表現は、一度保存して何度も使用できるデータ構造です。正規表現の引用 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; はまさにそれを行います： &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/string/&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;string&lt;/code&gt; を正規表現としてコンパイルし、結果を変数に割り当てることができる形式に変換します。</target>
        </trans-unit>
        <trans-unit id="9f422c71ad852c82f393abc6d42d6ed23387e826" translate="yes" xml:space="preserve">
          <source>In Part 1 we mentioned that Perl compiles a regexp into a compact sequence of opcodes. Thus, a compiled regexp is a data structure that can be stored once and used again and again. The regexp quote &lt;code&gt;qr//&lt;/code&gt; does exactly that: &lt;code&gt;qr/string/&lt;/code&gt; compiles the &lt;code&gt;string&lt;/code&gt; as a regexp and transforms the result into a form that can be assigned to a variable:</source>
          <target state="translated">パート1では、Perlが正規表現をコンパクトなオペコードシーケンスにコンパイルすることを説明しました。したがって、コンパイルされた正規表現は、一度保存して何度も使用できるデータ構造です。正規表現の引用符 &lt;code&gt;qr//&lt;/code&gt; は、まさにそれを実行します &lt;code&gt;qr/string/&lt;/code&gt; は、 &lt;code&gt;string&lt;/code&gt; を正規表現としてコンパイルし、結果を変数に割り当てることができる形式に変換します。</target>
        </trans-unit>
        <trans-unit id="b8e23998d4d31cf53431494db737762f35860793" translate="yes" xml:space="preserve">
          <source>In Perl 5.005, the thread model was that all data is implicitly shared, and shared access to data has to be explicitly synchronized. This model is called</source>
          <target state="translated">Perl 5.005では、すべてのデータが暗黙のうちに共有され、データへの共有アクセスは明示的に同期されなければならないというスレッドモデルでした。このモデルは</target>
        </trans-unit>
        <trans-unit id="0ef40fb67bd5325ef3bc9871c79bffa2a2f9def8" translate="yes" xml:space="preserve">
          <source>In Perl 5.10, declare the variable with &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; declaration creates the lexical variable that persists between calls to the subroutine:</source>
          <target state="translated">Perl 5.10では、変数を &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; で宣言します。 &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 宣言は、そのサブルーチンの呼び出しの間持続するレキシカル変数を作成します。</target>
        </trans-unit>
        <trans-unit id="a8b8dc6512fddc6a912b0cbfde84c91f304428a9" translate="yes" xml:space="preserve">
          <source>In Perl 5.10, declare the variable with &lt;code&gt;state&lt;/code&gt;. The &lt;code&gt;state&lt;/code&gt; declaration creates the lexical variable that persists between calls to the subroutine:</source>
          <target state="translated">Perl 5.10では、 &lt;code&gt;state&lt;/code&gt; して変数を宣言します。 &lt;code&gt;state&lt;/code&gt; 宣言は、そのサブルーチンの呼び出しの間持続するレキシカル変数を作成します。</target>
        </trans-unit>
        <trans-unit id="fcad1e403285c6c0597be1e44d89e383fc28fe4e" translate="yes" xml:space="preserve">
          <source>In Perl 5.10, the</source>
          <target state="translated">Perl 5.10では</target>
        </trans-unit>
        <trans-unit id="3754647e31be439690cdc120d0f37bbfc1ee49d5" translate="yes" xml:space="preserve">
          <source>In Perl 5.10, use the &lt;code&gt;given-when&lt;/code&gt; construct described in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;:</source>
          <target state="translated">Perl 5.10では、&lt;a href=&quot;perlsyn&quot;&gt;perlsynで&lt;/a&gt;説明されている指定された &lt;code&gt;given-when&lt;/code&gt; 構文を使用します。</target>
        </trans-unit>
        <trans-unit id="ef6f20b95a614e3c70a519351a658bbdee2e34af" translate="yes" xml:space="preserve">
          <source>In Perl 5.10.0 the &lt;code&gt;/p&lt;/code&gt; match operator flag and the &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; , and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables were introduced, that allowed you to suffer the penalties only on patterns marked with &lt;code&gt;/p&lt;/code&gt;.</source>
          <target state="translated">Perl 5.10.0では、 &lt;code&gt;/p&lt;/code&gt; 一致演算子フラグと &lt;code&gt;${^PREMATCH}&lt;/code&gt; 、 &lt;code&gt;${^MATCH}&lt;/code&gt; 、および &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 変数が導入され、 &lt;code&gt;/p&lt;/code&gt; でマークされたパターンでのみペナルティを被ることができました。</target>
        </trans-unit>
        <trans-unit id="0f3e250c35c16ed5beded9eecafc97e7f7748952" translate="yes" xml:space="preserve">
          <source>In Perl 5.10.0 the &lt;code&gt;/p&lt;/code&gt; match operator flag and the &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt;, and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables were introduced, that allowed you to suffer the penalties only on patterns marked with &lt;code&gt;/p&lt;/code&gt;.</source>
          <target state="translated">Perl 5.10.0では、 &lt;code&gt;/p&lt;/code&gt; 一致演算子フラグと &lt;code&gt;${^PREMATCH}&lt;/code&gt; 、 &lt;code&gt;${^MATCH}&lt;/code&gt; 、および &lt;code&gt;${^POSTMATCH}&lt;/code&gt; 変数が導入され、 &lt;code&gt;/p&lt;/code&gt; でマークされたパターンでのみペナルティを受けることができました。</target>
        </trans-unit>
        <trans-unit id="bfdfceeeffa73fd56622a7e4fbcd615a7de619f1" translate="yes" xml:space="preserve">
          <source>In Perl 5.16 and earlier, copy-on-write (see the next section) shared a flag bit with read-only scalars. So the only way to test whether &lt;code&gt;sv_setsv&lt;/code&gt; , etc., will raise a &quot;Modification of a read-only value&quot; error in those versions is:</source>
          <target state="translated">Perl 5.16以前では、copy-on-write（次のセクションを参照）はフラグビットを読み取り専用スカラーと共有していました。したがって、これらのバージョンで &lt;code&gt;sv_setsv&lt;/code&gt; などが「読み取り専用値の変更」エラーを発生させるかどうかをテストする唯一の方法は、次のとおりです。</target>
        </trans-unit>
        <trans-unit id="2de270c18c4d05efea842690bbe0309208ec91c2" translate="yes" xml:space="preserve">
          <source>In Perl 5.16 and earlier, copy-on-write (see the next section) shared a flag bit with read-only scalars. So the only way to test whether &lt;code&gt;sv_setsv&lt;/code&gt;, etc., will raise a &quot;Modification of a read-only value&quot; error in those versions is:</source>
          <target state="translated">Perl 5.16以前では、コピーオンライト（次のセクションを参照）はフラグビットを読み取り専用スカラーと共有していました。したがって、 &lt;code&gt;sv_setsv&lt;/code&gt; などがこれらのバージョンで「読み取り専用値の変更」エラーを発生させるかどうかをテストする唯一の方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="9c29d499be725da440aa9799fa65cef604b0abdb" translate="yes" xml:space="preserve">
          <source>In Perl 5.18.0 onwards, perl started noting the presence of each of the three variables separately, and only copied that part of the string required; so in</source>
          <target state="translated">Perl 5.18.0以降では、Perlは3つの変数のそれぞれの存在を個別に記録するようになり、必要な文字列の一部だけをコピーするようになりました。</target>
        </trans-unit>
        <trans-unit id="bb6846bd814a1146dc2f695e71c44bd7e9fb3806" translate="yes" xml:space="preserve">
          <source>In Perl 5.20 and 5.22, this syntax must be enabled with &lt;code&gt;use feature 'postderef'&lt;/code&gt;. As of Perl 5.24, no feature declarations are required to make it available.</source>
          <target state="translated">Perl 5.20および5.22では、この構文は &lt;code&gt;use feature 'postderef'&lt;/code&gt; で有効にする必要があります。Perl 5.24以降、それを利用可能にするために機能宣言は必要ありません。</target>
        </trans-unit>
        <trans-unit id="ac74f29244f42c123f550a223146503cf87cca65" translate="yes" xml:space="preserve">
          <source>In Perl 5.20 and earlier, the only pragmas to be completely supported are: &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; . (&lt;code&gt;$[&lt;/code&gt; , which behaves like a pragma, is also supported.)</source>
          <target state="translated">Perlの5.20およびそれ以前では、唯一のプラグマは完全にサポートされるべきである： &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; 。（プラグマのように動作する &lt;code&gt;$[&lt;/code&gt; もサポートされています。）</target>
        </trans-unit>
        <trans-unit id="a99daea546c9fc521d28b295e0227c75c1c77163" translate="yes" xml:space="preserve">
          <source>In Perl 5.20 and higher this is ignored. Due to a new copy-on-write mechanism, ${^PREMATCH}, ${^MATCH}, and ${^POSTMATCH} will be available after the match regardless of the modifier.</source>
          <target state="translated">Perl 5.20以降では無視されます。新しいコピーオンライトの仕組みにより、マッチ後は修飾子に関係なく${^PREMATCH},${^MATCH},${^POSTMATCH}が利用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="c2e345cc084802e472e843021a52be876a248694" translate="yes" xml:space="preserve">
          <source>In Perl 5.20 and higher this is ignored. Due to a new copy-on-write mechanism, &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt;, and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; will be available after the match regardless of the modifier.</source>
          <target state="translated">Perl 5.20以降では、これは無視されます。新しいコピーオンライトメカニズムにより、修飾子に関係なく、一致後に &lt;code&gt;${^PREMATCH}&lt;/code&gt; 、 &lt;code&gt;${^MATCH}&lt;/code&gt; 、および &lt;code&gt;${^POSTMATCH}&lt;/code&gt; が使用可能になります。</target>
        </trans-unit>
        <trans-unit id="5dd87335d7944293ee760ce3fce6d463be42dedd" translate="yes" xml:space="preserve">
          <source>In Perl 5.20.0 a new copy-on-write system was enabled by default, which finally fixes all performance issues with these three variables, and makes them safe to use anywhere.</source>
          <target state="translated">Perl 5.20.0 では、新しいコピーオンライトシステムがデフォルトで有効になっており、これら 3 つの変数のパフォーマンスの問題をすべて修正し、どこでも安全に使用できるようになりました。</target>
        </trans-unit>
        <trans-unit id="f3bfdc8baf280a72c47cbbea941ae21c16b028e7" translate="yes" xml:space="preserve">
          <source>In Perl 5.20.0 this was changed so that it would be &lt;b&gt;exactly&lt;/b&gt; the same as setting &lt;code&gt;$/&lt;/code&gt; to undef, with the exception that this warning would be thrown.</source>
          <target state="translated">Perl 5.20.0 では、この警告がスローされることを除いて、 &lt;code&gt;$/&lt;/code&gt; をundefに設定するのと&lt;b&gt;まったく&lt;/b&gt;同じになるように変更されました。</target>
        </trans-unit>
        <trans-unit id="b9a5cb481a025f6680fe2e560f757bef411f0354" translate="yes" xml:space="preserve">
          <source>In Perl 5.22 and later, all groups within a regexp can be set to non-capturing by using the new &lt;code&gt;/n&lt;/code&gt; flag:</source>
          <target state="translated">Perl 5.22以降では、新しい &lt;code&gt;/n&lt;/code&gt; フラグを使用して、正規表現内のすべてのグループを非キャプチャに設定できます。</target>
        </trans-unit>
        <trans-unit id="8c05f57b472f3633ffbc63a5a1677bbf1fd5199a" translate="yes" xml:space="preserve">
          <source>In Perl 5.30 and earlier, lookbehind is allowed only for subexpressions whose length is fixed and known at compile time. For positive lookbehind, you can use the &lt;code&gt;\K&lt;/code&gt; regex construct as a way to get the equivalent functionality. See &lt;a href=&quot;perlre#%5CK&quot;&gt;(?&amp;lt;=pattern) and \K in perlre&lt;/a&gt;.</source>
          <target state="translated">Perl 5.30以前では、ルックビハインドは、長さが固定され、コンパイル時に認識されている部分式に対してのみ許可されます。前向きな後読みのために、同等の機能を取得する方法として &lt;code&gt;\K&lt;/code&gt; Kregex構造を使用できます。&lt;a href=&quot;perlre#%5CK&quot;&gt;perlreの（？&amp;lt;= pattern）と\ Kを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="015d46ab8b3eb1374b9c9159b3586fa11c13b7fc" translate="yes" xml:space="preserve">
          <source>In Perl 5.30, it will no longer be possible to use sysread(), recv(), syswrite() or send() to read or send bytes from/to :utf8 handles.</source>
          <target state="translated">Perl 5.30 では、sysread()、recv()、syswrite()、send()を使用して :utf8 ハンドルとの間でバイトの読み取りや送信を行うことができなくなります。</target>
        </trans-unit>
        <trans-unit id="829f62b5d0005de3966076a8745c273476071683" translate="yes" xml:space="preserve">
          <source>In Perl 5.6 and some books the &lt;code&gt;:raw&lt;/code&gt; layer (previously sometimes also referred to as a &quot;discipline&quot;) is documented as the inverse of the &lt;code&gt;:crlf&lt;/code&gt; layer. That is no longer the case - other layers which would alter the binary nature of the stream are also disabled. If you want UNIX line endings on a platform that normally does CRLF translation, but still want UTF-8 or encoding defaults, the appropriate thing to do is to add &lt;code&gt;:perlio&lt;/code&gt; to the PERLIO environment variable.</source>
          <target state="translated">Perl 5.6および一部の書籍では、 &lt;code&gt;:raw&lt;/code&gt; レイヤー（以前は「規律」とも呼ばれていました）は、 &lt;code&gt;:crlf&lt;/code&gt; レイヤーの逆として文書化されています。それはもう当てはまりません-ストリームのバイナリの性質を変更する他のレイヤーも無効になります。通常CRLF変換を行うプラットフォームでUNIXの行末が必要で、UTF-8またはエンコードのデフォルトが必要な場合は、PERLIO環境変数に &lt;code&gt;:perlio&lt;/code&gt; を追加するのが適切です。</target>
        </trans-unit>
        <trans-unit id="fad3da3a77d2a8e0c192dfbe3d758d620ee24b00" translate="yes" xml:space="preserve">
          <source>In Perl 5.6 and some books the &lt;code&gt;:raw&lt;/code&gt; layer is documented as the inverse of the &lt;code&gt;:crlf&lt;/code&gt; layer. That is no longer the case - other layers which would alter the binary nature of the stream are also disabled. If you want UNIX line endings on a platform that normally does CRLF translation, but still want UTF-8 or encoding defaults, the appropriate thing to do is to add &lt;code&gt;:perlio&lt;/code&gt; to the PERLIO environment variable, or open the handle explicitly with that layer, to replace the platform default of &lt;code&gt;:crlf&lt;/code&gt;.</source>
          <target state="translated">Perl 5.6および一部の書籍では、 &lt;code&gt;:raw&lt;/code&gt; レイヤーは &lt;code&gt;:crlf&lt;/code&gt; レイヤーの逆として文書化されています。これはもはや当てはまりません。ストリームのバイナリの性質を変更する他のレイヤーも無効になります。通常はCRLF変換を行うプラットフォームでUNIXの行末が必要であるが、UTF-8またはエンコードのデフォルトが必要な場合は、PERLIO環境変数に &lt;code&gt;:perlio&lt;/code&gt; を追加するか、そのレイヤーでハンドルを明示的に開くことをお勧めします。プラットフォームのデフォルトの &lt;code&gt;:crlf&lt;/code&gt; を置き換えます。</target>
        </trans-unit>
        <trans-unit id="8fac8c7e82a994285a91ea520c95723e026d4360" translate="yes" xml:space="preserve">
          <source>In Perl 5.6, a new model was introduced in which all is was thread local and shared access to data has to be explicitly declared. This model is called</source>
          <target state="translated">Perl 5.6では、すべてがスレッドローカルであり、データへの共有アクセスは明示的に宣言されなければならないという新しいモデルが導入されました。このモデルは</target>
        </trans-unit>
        <trans-unit id="c2abdf6c9d513612683e10abfef7f22af8c5271f" translate="yes" xml:space="preserve">
          <source>In Perl 5.6, the</source>
          <target state="translated">Perl 5.6では</target>
        </trans-unit>
        <trans-unit id="26c0c53508feac78fbf5a2c99792e045ffa03c8a" translate="yes" xml:space="preserve">
          <source>In Perl 5.6.0 the &lt;code&gt;@-&lt;/code&gt; and &lt;code&gt;@+&lt;/code&gt; dynamic arrays were introduced that supply the indices of successful matches. So you could for example do this:</source>
          <target state="translated">Perl 5.6.0では、 &lt;code&gt;@-&lt;/code&gt; および &lt;code&gt;@+&lt;/code&gt; 動的配列が導入され、成功した一致のインデックスを提供します。したがって、たとえば次のようにすることができます。</target>
        </trans-unit>
        <trans-unit id="523c10b75565b9e0e195e0700fdbbd2ed237ae32" translate="yes" xml:space="preserve">
          <source>In Perl 5.8, the</source>
          <target state="translated">Perl 5.8では</target>
        </trans-unit>
        <trans-unit id="a58322d6122d01dd67612b6444328927a4d69bfc" translate="yes" xml:space="preserve">
          <source>In Perl 5.8.0 the slowness was often quite spectacular; in Perl 5.8.1 a caching scheme was introduced which improved the situation. In general, operations with UTF-8 encoded strings are still slower. As an example, the Unicode properties (character classes) like &lt;code&gt;\p{Nd}&lt;/code&gt; are known to be quite a bit slower (5-20 times) than their simpler counterparts like &lt;code&gt;[0-9]&lt;/code&gt; (then again, there are hundreds of Unicode characters matching &lt;code&gt;Nd&lt;/code&gt; compared with the 10 ASCII characters matching &lt;code&gt;[0-9]&lt;/code&gt; ).</source>
          <target state="translated">Perl 5.8.0では、その速度の遅さはしばしば見事なものでした。 Perl 5.8.1では、状況を改善するキャッシング方式が導入されました。一般に、UTF-8でエンコードされた文字列を使用した操作はさらに低速です。例として、 &lt;code&gt;\p{Nd}&lt;/code&gt; ようなUnicodeプロパティ（文字クラス）は、 &lt;code&gt;[0-9]&lt;/code&gt; のような単純な対応物（5〜20倍）よりもかなり遅い（5〜20倍）と知られています（ここでも、数百のUnicodeがあります）。 &lt;code&gt;Nd&lt;/code&gt; に一致する文字と &lt;code&gt;[0-9]&lt;/code&gt; に一致する10個のASCII文字）</target>
        </trans-unit>
        <trans-unit id="e439fc7cf20010bb9655a79250e2e3dd1a376ddd" translate="yes" xml:space="preserve">
          <source>In Perl 5.8.0 the slowness was often quite spectacular; in Perl 5.8.1 a caching scheme was introduced which improved the situation. In general, operations with UTF-8 encoded strings are still slower. As an example, the Unicode properties (character classes) like &lt;code&gt;\p{Nd}&lt;/code&gt; are known to be quite a bit slower (5-20 times) than their simpler counterparts like &lt;code&gt;[0-9]&lt;/code&gt; (then again, there are hundreds of Unicode characters matching &lt;code&gt;Nd&lt;/code&gt; compared with the 10 ASCII characters matching &lt;code&gt;[0-9]&lt;/code&gt;).</source>
          <target state="translated">Perl 5.8.0では、速度が非常に遅いことがよくありました。 Perl 5.8.1では、状況を改善するキャッシュスキームが導入されました。一般に、UTF-8でエンコードされた文字列を使用した操作はさらに低速です。例として、 &lt;code&gt;\p{Nd}&lt;/code&gt; ようなUnicodeプロパティ（文字クラス）は、 &lt;code&gt;[0-9]&lt;/code&gt; のような単純なプロパティ（さらに数百のUnicodeがあります）よりもかなり遅い（5〜20倍）ことが知られています。 &lt;code&gt;[0-9]&lt;/code&gt; に一致する10個のASCII文字と比較した &lt;code&gt;Nd&lt;/code&gt; に一致する文字）。</target>
        </trans-unit>
        <trans-unit id="0c85305fdff4b0749bfcf24c2c7a107269854de9" translate="yes" xml:space="preserve">
          <source>In Perl 6, &lt;code&gt;when()&lt;/code&gt; will always do an implicit smartmatch with its argument, while in Perl 5 it is convenient (albeit potentially confusing) to suppress this implicit smartmatch in various rather loosely-defined situations, as roughly outlined above. (The difference is largely because Perl 5 does not have, even internally, a boolean type.)</source>
          <target state="translated">Perl 6では、 &lt;code&gt;when()&lt;/code&gt; は常に引数を使用して暗黙的なスマートマッチを実行しますが、Perl 5では、上で概説したように、さまざまに緩やかに定義された状況でこの暗黙的なスマートマッチを抑制することが（混乱を招く可能性があります）便利です。 （主な違いは、Perl 5には内部的にもブール型がないためです。）</target>
        </trans-unit>
        <trans-unit id="ca97d510355543881848d3f320ae7ab2b8841db0" translate="yes" xml:space="preserve">
          <source>In Perl most objects are hashes, but the OO systems we recommend keep you from having to worry about this. In practice, it's best to consider an object's internal data structure opaque.</source>
          <target state="translated">Perl では、ほとんどのオブジェクトはハッシュですが、私たちが推奨する OO システムはこれを心配する必要はありません。実際には、オブジェクトの内部データ構造は不透明と考えるのがベストです。</target>
        </trans-unit>
        <trans-unit id="6fcb11a99abfcbef52ae2fdd52d4cd8656bbc249" translate="yes" xml:space="preserve">
          <source>In Perl regular expressions, most regexp elements &quot;eat up&quot; a certain amount of string when they match. For instance, the regexp element &lt;code&gt;[abc]&lt;/code&gt; eats up one character of the string when it matches, in the sense that Perl moves to the next character position in the string after the match. There are some elements, however, that don't eat up characters (advance the character position) if they match. The examples we have seen so far are the anchors. The anchor &lt;code&gt;'^'&lt;/code&gt; matches the beginning of the line, but doesn't eat any characters. Similarly, the word boundary anchor &lt;code&gt;\b&lt;/code&gt; matches wherever a character matching &lt;code&gt;\w&lt;/code&gt; is next to a character that doesn't, but it doesn't eat up any characters itself. Anchors are examples of</source>
          <target state="translated">Perl正規表現では、ほとんどのregexp要素は、一致したときに一定量の文字列を「食い尽くし」ます。たとえば、正規表現要素 &lt;code&gt;[abc]&lt;/code&gt; は、Perlが一致後に文字列内の次の文字位置に移動するという意味で、一致すると文字列の1文字を消費します。ただし、一致した場合に文字を食い尽くさない（文字の位置を進める）要素がいくつかあります。これまでに見た例はアンカーです。アンカー &lt;code&gt;'^'&lt;/code&gt; は行の先頭に一致しますが、文字を食べません。同様に、単語境界アンカー &lt;code&gt;\b&lt;/code&gt; は、 &lt;code&gt;\w&lt;/code&gt; 一致する文字が一致しない文字の隣にある場合は常に一致しますが、文字自体を消費することはありません。アンカーはの例です</target>
        </trans-unit>
        <trans-unit id="243bad753f535e22807612697dcecab4311e323e" translate="yes" xml:space="preserve">
          <source>In Perl regular expressions, most regexp elements 'eat up' a certain amount of string when they match. For instance, the regexp element &lt;code&gt;[abc}]&lt;/code&gt; eats up one character of the string when it matches, in the sense that Perl moves to the next character position in the string after the match. There are some elements, however, that don't eat up characters (advance the character position) if they match. The examples we have seen so far are the anchors. The anchor &lt;code&gt;^&lt;/code&gt; matches the beginning of the line, but doesn't eat any characters. Similarly, the word boundary anchor &lt;code&gt;\b&lt;/code&gt; matches wherever a character matching &lt;code&gt;\w&lt;/code&gt; is next to a character that doesn't, but it doesn't eat up any characters itself. Anchors are examples of</source>
          <target state="translated">Perl正規表現では、ほとんどのregexp要素は、一致すると特定の量の文字列を「食い尽くします」。たとえば、正規表現要素 &lt;code&gt;[abc}]&lt;/code&gt; は、一致したときにPerlが文字列の次の文字位置に移動するという意味で、一致すると文字列の1文字を消費します。ただし、一致した場合に文字を消費しない（文字の位置を進める）要素がいくつかあります。これまで見てきた例はアンカーです。アンカー &lt;code&gt;^&lt;/code&gt; は行の先頭に一致しますが、文字は何も食べません。同様に、単語境界アンカー &lt;code&gt;\b&lt;/code&gt; は、 &lt;code&gt;\w&lt;/code&gt; と一致する文字が、一致しない文字の隣にある場合はどこでも一致しますが、文字自体を消費しません。アンカーは、</target>
        </trans-unit>
        <trans-unit id="905e1c7e56de580fc4af4b17e4c486804586d33e" translate="yes" xml:space="preserve">
          <source>In Perl terms this means that supplying the usual Perl numbers (also known as scalars, please see &lt;a href=&quot;../perldata&quot;&gt;perldata&lt;/a&gt;) as input for the trigonometric functions might produce as output results that no more are simple real numbers: instead they are complex numbers.</source>
          <target state="translated">Perlの用語では、これは通常のPerlの数値（スカラーとも呼ばれます&lt;a href=&quot;../perldata&quot;&gt;。perldata&lt;/a&gt;を参照してください）を指定すると、三角関数の入力として出力結果として単純な実数ではなく、複素数になります。</target>
        </trans-unit>
        <trans-unit id="c89c1933f929227bc6d7b434996b4c3d5312db42" translate="yes" xml:space="preserve">
          <source>In Perl terms this means that supplying the usual Perl numbers (also known as scalars, please see &lt;a href=&quot;perldata&quot;&gt;perldata&lt;/a&gt;) as input for the trigonometric functions might produce as output results that no more are simple real numbers: instead they are complex numbers.</source>
          <target state="translated">Perlの用語では、これは、三角関数の入力として通常のPerl数値（スカラーとも呼ばれます&lt;a href=&quot;perldata&quot;&gt;。perldata&lt;/a&gt;を参照してください）を出力結果として提供すると、単純な実数ではなく、複素数になる可能性があることを意味します。</target>
        </trans-unit>
        <trans-unit id="7f326f4fd32f12380a2d175a436e985d3f4c2edf" translate="yes" xml:space="preserve">
          <source>In Perl v5.14, all non-ASCII characters are quoted in non-UTF-8-encoded strings, but not quoted in UTF-8 strings.</source>
          <target state="translated">Perl v5.14 では、UTF-8 エンコードされていない文字列ではすべての非 ASCII 文字が引用されますが、UTF-8 文字列では引用されません。</target>
        </trans-unit>
        <trans-unit id="0ffdb19ef413239753228d33908dad38e29d542e" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^MATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$MATCH&lt;/code&gt; .</source>
          <target state="translated">Perl v5.18以前では、パターンが &lt;code&gt;/p&lt;/code&gt; 修飾子を使用してコンパイルまたは実行された場合にのみ、定義された値を返すことが保証されていました。Perl v5.20では、 &lt;code&gt;/p&lt;/code&gt; 修飾子は何もしないので、 &lt;code&gt;${^MATCH}&lt;/code&gt; は &lt;code&gt;$MATCH&lt;/code&gt; と同じことを行います。</target>
        </trans-unit>
        <trans-unit id="057abcd6479cca74c3b9fb3d3dd6b27878d1413e" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^MATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$MATCH&lt;/code&gt;.</source>
          <target state="translated">Perl v5.18以前では、パターンが &lt;code&gt;/p&lt;/code&gt; 修飾子を使用してコンパイルまたは実行された場合にのみ、定義された値を返すことが保証されています。Perl v5.20では、 &lt;code&gt;/p&lt;/code&gt; 修飾子は何も実行しないため、 &lt;code&gt;${^MATCH}&lt;/code&gt; は &lt;code&gt;$MATCH&lt;/code&gt; と同じことを実行します。</target>
        </trans-unit>
        <trans-unit id="b4dbbc56c5f11021be8e37601f6986f49dc8e148" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^POSTMATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$POSTMATCH&lt;/code&gt; .</source>
          <target state="translated">Perl v5.18以前では、パターンが &lt;code&gt;/p&lt;/code&gt; 修飾子を使用してコンパイルまたは実行された場合にのみ、定義された値を返すことが保証されていました。Perl v5.20では、 &lt;code&gt;/p&lt;/code&gt; 修飾子は何もしないので、 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; は &lt;code&gt;$POSTMATCH&lt;/code&gt; と同じことを行います。</target>
        </trans-unit>
        <trans-unit id="7db6a7a5d2c710c4176385519a525c382964c439" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^POSTMATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$POSTMATCH&lt;/code&gt;.</source>
          <target state="translated">Perl v5.18以前では、パターンが &lt;code&gt;/p&lt;/code&gt; 修飾子を使用してコンパイルまたは実行された場合にのみ、定義された値を返すことが保証されています。Perl v5.20では、 &lt;code&gt;/p&lt;/code&gt; 修飾子は何も実行しないため、 &lt;code&gt;${^POSTMATCH}&lt;/code&gt; は &lt;code&gt;$POSTMATCH&lt;/code&gt; と同じことを実行します。</target>
        </trans-unit>
        <trans-unit id="05c22186f7acbb5a1c00ca1269cc907a18af05f8" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^PREMATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$PREMATCH&lt;/code&gt; .</source>
          <target state="translated">Perl v5.18以前では、パターンが &lt;code&gt;/p&lt;/code&gt; 修飾子を使用してコンパイルまたは実行された場合にのみ、定義された値を返すことが保証されていました。Perl v5.20では、 &lt;code&gt;/p&lt;/code&gt; 修飾子は何もしないので、 &lt;code&gt;${^PREMATCH}&lt;/code&gt; は &lt;code&gt;$PREMATCH&lt;/code&gt; と同じことを行います。</target>
        </trans-unit>
        <trans-unit id="dd3dd771da7118a3415ee7efa43387081550b359" translate="yes" xml:space="preserve">
          <source>In Perl v5.18 and earlier, it is only guaranteed to return a defined value when the pattern was compiled or executed with the &lt;code&gt;/p&lt;/code&gt; modifier. In Perl v5.20, the &lt;code&gt;/p&lt;/code&gt; modifier does nothing, so &lt;code&gt;${^PREMATCH}&lt;/code&gt; does the same thing as &lt;code&gt;$PREMATCH&lt;/code&gt;.</source>
          <target state="translated">Perl v5.18以前では、パターンが &lt;code&gt;/p&lt;/code&gt; 修飾子を使用してコンパイルまたは実行された場合にのみ、定義された値を返すことが保証されています。Perl v5.20では、 &lt;code&gt;/p&lt;/code&gt; 修飾子は何も実行しないため、 &lt;code&gt;${^PREMATCH}&lt;/code&gt; は &lt;code&gt;$PREMATCH&lt;/code&gt; と同じことを実行します。</target>
        </trans-unit>
        <trans-unit id="5432c77569fd0514eaa8844532d6c5cc637bdaa6" translate="yes" xml:space="preserve">
          <source>In Perl versions 5.6 and earlier the quicksort algorithm was used to implement &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt;, but in Perl 5.8 a mergesort algorithm was also made available, mainly to guarantee worst case O(N log N) behaviour: the worst case of quicksort is O(N**2). In Perl 5.8 and later, quicksort defends against quadratic behaviour by shuffling large arrays before sorting.</source>
          <target state="translated">Perlバージョン5.6以前では、 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; を実装するためにクイックソートアルゴリズムが使用されていましたが、Perl 5.8では、主にワーストケースO（N log N）動作を保証するためにマージソートアルゴリズムも利用可能になりました：クイックソートの最悪ケースはO（ N ** 2）。Perl 5.8以降では、クイックソートは、ソートする前に大きな配列をシャッフルすることにより、2次動作から保護します。</target>
        </trans-unit>
        <trans-unit id="b8d70ec01f0ffe74da5bcdba9c1b84357d80b78c" translate="yes" xml:space="preserve">
          <source>In Perl versions prior to 5.26, this feature enabled declaration of subroutines via &lt;code&gt;my sub foo&lt;/code&gt;, &lt;code&gt;state sub foo&lt;/code&gt; and &lt;code&gt;our sub foo&lt;/code&gt; syntax. See &lt;a href=&quot;perlsub#Lexical-Subroutines&quot;&gt;&quot;Lexical Subroutines&quot; in perlsub&lt;/a&gt; for details.</source>
          <target state="translated">5.26より前のPerlバージョンでは、この機能により &lt;code&gt;my sub foo&lt;/code&gt; 、 &lt;code&gt;state sub foo&lt;/code&gt; 、および &lt;code&gt;our sub foo&lt;/code&gt; 構文を介したサブルーチンの宣言が可能になりました。詳細については&lt;a href=&quot;perlsub#Lexical-Subroutines&quot;&gt;、perlsubの「字句サブルーチン」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8b481016607f0afb6a75f448e44a95f87a802232" translate="yes" xml:space="preserve">
          <source>In Perl you will get a floating point value if you do one of the following:</source>
          <target state="translated">Perlでは、以下のいずれかを実行すると浮動小数点値を取得します。</target>
        </trans-unit>
        <trans-unit id="7d663b5a48798d90608073d23eaf6d6597db1534" translate="yes" xml:space="preserve">
          <source>In Perl, &lt;code&gt;else if&lt;/code&gt; is spelled &lt;code&gt;elsif&lt;/code&gt; .</source>
          <target state="translated">Perlでは、 &lt;code&gt;else if&lt;/code&gt; は &lt;code&gt;elsif&lt;/code&gt; と綴られます。</target>
        </trans-unit>
        <trans-unit id="5a2652823d74ae993d4eef83bf52682f95c98945" translate="yes" xml:space="preserve">
          <source>In Perl, &lt;code&gt;else if&lt;/code&gt; is spelled &lt;code&gt;elsif&lt;/code&gt;.</source>
          <target state="translated">Perlでは、 &lt;code&gt;else if&lt;/code&gt; 綴られ &lt;code&gt;elsif&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49774beef30ebf83ad6beb68cfd55f59cc0e76e3" translate="yes" xml:space="preserve">
          <source>In Perl, a class is just a package, and methods are just subroutines. Perl doesn't get more formal than that and lets you set up the package just the way that you like it (that is, it doesn't set up anything for you).</source>
          <target state="translated">Perlでは、クラスは単なるパッケージであり、メソッドは単なるサブルーチンです。Perl はこれ以上正式なものはなく、あなたの好きなようにパッケージを設定することができます (つまり、あなたのために何かを設定することはありません)。</target>
        </trans-unit>
        <trans-unit id="983e915935b5fb68c2f1bb82bb4cf04272a6754a" translate="yes" xml:space="preserve">
          <source>In Perl, a sequence of statements that defines a scope is called a block. Sometimes a block is delimited by the file containing it (in the case of a required file, or the program as a whole), and sometimes a block is delimited by the extent of a string (in the case of an eval).</source>
          <target state="translated">Perlでは、スコープを定義する一連の文をブロックと呼びます。ブロックはそれを含むファイルで区切られることもあれば (必須ファイルの場合やプログラム全体で区切られることもあります)、文字列の範囲で区切られることもあります (evalの場合)。</target>
        </trans-unit>
        <trans-unit id="476c5432e1fcd1b2c55042740329df48b50efcfd" translate="yes" xml:space="preserve">
          <source>In Perl, an object is a blessed reference. The standard way of associating data with an object is to store the data inside the object's body, that is, the piece of data pointed to by the reference.</source>
          <target state="translated">Perl では、オブジェクトは祝福された参照です。データをオブジェクトに関連付ける標準的な方法は、データをオブジェクトの本体、つまり参照によって指されたデータの一部の内部に格納することです。</target>
        </trans-unit>
        <trans-unit id="6459245c83006474d0636721805e8f89399cea54" translate="yes" xml:space="preserve">
          <source>In Perl, any package can be a class. The difference between a package which is a class and one which isn't is based on how the package is used. Here's our &quot;class declaration&quot; for the &lt;code&gt;File&lt;/code&gt; class:</source>
          <target state="translated">Perlでは、任意のパッケージをクラスにすることができます。クラスであるパッケージとそうでないパッケージの違いは、パッケージの使用方法に基づいています。 &lt;code&gt;File&lt;/code&gt; クラスの「クラス宣言」は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="935b815c5b098d8ca1c1e87b1e728cb47b24fb51" translate="yes" xml:space="preserve">
          <source>In Perl, any value that would look like &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;&quot;0&quot;&lt;/code&gt; if evaluated in a string context. Since undefined values evaluate to &lt;code&gt;&quot;&quot;&lt;/code&gt; , all undefined values are false, but not all false values are undefined.</source>
          <target state="translated">Perlでは、文字列コンテキストで評価した場合に &lt;code&gt;&quot;&quot;&lt;/code&gt; または &lt;code&gt;&quot;0&quot;&lt;/code&gt; ように見える値。未定義の値は &lt;code&gt;&quot;&quot;&lt;/code&gt; と評価されるため、すべての未定義の値はfalseですが、すべてのfalse値が未定義であるとは限りません。</target>
        </trans-unit>
        <trans-unit id="9c0e1a8a489587a81c3737b4c92da909aea6a8ed" translate="yes" xml:space="preserve">
          <source>In Perl, any value that would look like &lt;code&gt;&quot;&quot;&lt;/code&gt; or &lt;code&gt;&quot;0&quot;&lt;/code&gt; if evaluated in a string context. Since undefined values evaluate to &lt;code&gt;&quot;&quot;&lt;/code&gt;, all undefined values are false, but not all false values are undefined.</source>
          <target state="translated">Perlでは、文字列コンテキストで評価された場合に &lt;code&gt;&quot;&quot;&lt;/code&gt; または &lt;code&gt;&quot;0&quot;&lt;/code&gt; ように見える値。未定義の値は &lt;code&gt;&quot;&quot;&lt;/code&gt; と評価されるため、すべての未定義の値はfalseですが、すべてのfalse値が未定義であるとは限りません。</target>
        </trans-unit>
        <trans-unit id="56beb88cb62afd75b5b76cfb0ba20b6ebe456c89" translate="yes" xml:space="preserve">
          <source>In Perl, binary &lt;code&gt;+&lt;/code&gt; is always addition. &lt;code&gt;$string1 + $string2&lt;/code&gt; converts both strings to numbers and then adds them. To concatenate two strings, use the &lt;code&gt;.&lt;/code&gt; operator.</source>
          <target state="translated">Perlでは、バイナリ &lt;code&gt;+&lt;/code&gt; は常に加算されます。 &lt;code&gt;$string1 + $string2&lt;/code&gt; 、両方の文字列を数値に変換してから追加します。2つの文字列を連結するには、を使用し &lt;code&gt;.&lt;/code&gt; オペレーター。</target>
        </trans-unit>
        <trans-unit id="45dacae9ba665d20910caab3291e37d91f82dce5" translate="yes" xml:space="preserve">
          <source>In Perl, dynamic scoping refers to the runtime nesting of things like subroutine calls, evals etc, as well as the entering and exiting of block scopes. For example, the restoring of a &lt;code&gt;local&lt;/code&gt;ised variable is determined by the dynamic scope.</source>
          <target state="translated">Perlでは、動的スコープとは、サブルーチン呼び出し、評価などの実行時のネスト、およびブロックスコープの開始と終了を指します。たとえば、 &lt;code&gt;local&lt;/code&gt; ised変数の復元は、動的スコープによって決定されます。</target>
        </trans-unit>
        <trans-unit id="a33a4933eab4c192832e758c7f44c0a0303ba50a" translate="yes" xml:space="preserve">
          <source>In Perl, methods are simply subroutines that live in a class's package. Methods are always written to receive the object as their first argument:</source>
          <target state="translated">Perlでは、メソッドはクラスのパッケージの中にあるサブルーチンです。メソッドは常に第一引数としてオブジェクトを受け取るように書かれています。</target>
        </trans-unit>
        <trans-unit id="ea72a9a423acf3df90a345514eea4421a19ceb17" translate="yes" xml:space="preserve">
          <source>In Perl, the debugger is not a separate program the way it usually is in the typical compiled environment. Instead, the &lt;b&gt;-d&lt;/b&gt; flag tells the compiler to insert source information into the parse trees it's about to hand off to the interpreter. That means your code must first compile correctly for the debugger to work on it. Then when the interpreter starts up, it preloads a special Perl library file containing the debugger.</source>
          <target state="translated">Perlでは、デバッガーは通常のコンパイルされた環境で通常行われるような独立したプログラムではありません。代わりに、&lt;b&gt;-d&lt;/b&gt;フラグは、インタープリターに渡そうとしている解析ツリーにソース情報を挿入するようコンパイラーに指示します。つまり、デバッガーが機能するためには、まずコードを正しくコンパイルする必要があります。次に、インタプリタが起動すると、デバッガを含む特別なPerlライブラリファイルをプリロードします。</target>
        </trans-unit>
        <trans-unit id="3c642476c3d73c23016f66bc533c3f6f2db6cded" translate="yes" xml:space="preserve">
          <source>In Perl, the operator determines what operation is performed, independent of the type of the operands. For example &lt;code&gt;$x + $y&lt;/code&gt; is always a numeric addition, and if &lt;code&gt;$x&lt;/code&gt; or &lt;code&gt;$y&lt;/code&gt; do not contain numbers, an attempt is made to convert them to numbers first.</source>
          <target state="translated">Perlでは、演算子は、オペランドのタイプに関係なく、実行される操作を決定します。たとえば、 &lt;code&gt;$x + $y&lt;/code&gt; は常に数値の加算であり、 &lt;code&gt;$x&lt;/code&gt; または &lt;code&gt;$y&lt;/code&gt; 数値が含まれていない場合は、まず数値に変換しようとします。</target>
        </trans-unit>
        <trans-unit id="05577297c46ae0d2cd55a130e9e49792d0bf233a" translate="yes" xml:space="preserve">
          <source>In Perl, there is no special keyword for constructing an object. However, most OO modules on CPAN use a method named &lt;code&gt;new()&lt;/code&gt; to construct a new object:</source>
          <target state="translated">Perlでは、オブジェクトを作成するための特別なキーワードはありません。ただし、CPANのほとんどのOOモジュールは、 &lt;code&gt;new()&lt;/code&gt; というメソッドを使用して新しいオブジェクトを構築します。</target>
        </trans-unit>
        <trans-unit id="5e186db9710e48217d6288a83b8e0190d6d543fb" translate="yes" xml:space="preserve">
          <source>In Perl, unlike C, a string of characters may generally contain embedded &lt;code&gt;NUL&lt;/code&gt; characters. Sometimes in the documentation a Perl string is referred to as a &quot;buffer&quot; to distinguish it from a C string, but sometimes they are both just referred to as strings.</source>
          <target state="translated">Perlでは、Cとは異なり、文字列には通常、埋め込まれた &lt;code&gt;NUL&lt;/code&gt; 文字が含まれる場合があります。ドキュメントでは、Perl文字列をC文字列と区別するために「バッファ」と呼ばれることもありますが、両方とも単に文字列と呼ばれることもあります。</target>
        </trans-unit>
        <trans-unit id="e4aecd76031e1346a21238102ea29667311ebe2a" translate="yes" xml:space="preserve">
          <source>In Perl, you just can't access memory at random, but the structural and representational conversion provided by &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; is an excellent alternative. The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function converts values to a byte sequence containing representations according to a given specification, the so-called &quot;template&quot; argument. &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; is the reverse process, deriving some values from the contents of a string of bytes. (Be cautioned, however, that not all that has been packed together can be neatly unpacked - a very common experience as seasoned travellers are likely to confirm.)</source>
          <target state="translated">Perlでは、ランダムにメモリにアクセスすることはできませんが、 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; によって提供される構造変換と表現変換は優れた代替手段です。 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 関数変換値を所定の仕様、いわゆる「テンプレート」引数に従って表現を含むバイト配列。 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; は逆のプロセスで、バイト文字列の内容からいくつかの値を導出します。（ただし、一緒に梱包されたものすべてがきちんと開梱できるわけではないことに注意してください。熟練した旅行者が確認する可能性が高いため、非常に一般的な経験です。）</target>
        </trans-unit>
        <trans-unit id="6336086c91498a8e5594063230b55c879e95d340" translate="yes" xml:space="preserve">
          <source>In Perl, you just can't access memory at random, but the structural and representational conversion provided by &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; is an excellent alternative. The &lt;code&gt;pack&lt;/code&gt; function converts values to a byte sequence containing representations according to a given specification, the so-called &quot;template&quot; argument. &lt;code&gt;unpack&lt;/code&gt; is the reverse process, deriving some values from the contents of a string of bytes. (Be cautioned, however, that not all that has been packed together can be neatly unpacked - a very common experience as seasoned travellers are likely to confirm.)</source>
          <target state="translated">Perlでは、ランダムにメモリにアクセスすることはできませんが、 &lt;code&gt;pack&lt;/code&gt; と &lt;code&gt;unpack&lt;/code&gt; によって提供される構造的および表現的な変換は優れた代替手段です。 &lt;code&gt;pack&lt;/code&gt; 関数変換値を所定の仕様、いわゆる「テンプレート」引数に従って表現を含むバイト配列。 &lt;code&gt;unpack&lt;/code&gt; は逆のプロセスであり、バイト文字列の内容からいくつかの値を取得します。 （ただし、一緒に梱包されたものすべてをきちんと開梱できるわけではないことに注意してください。経験豊富な旅行者が確認する可能性が高いため、非常に一般的な経験です。）</target>
        </trans-unit>
        <trans-unit id="3a69ee0657acfe60fc783ea37121861ef3e8b2c7" translate="yes" xml:space="preserve">
          <source>In Practice</source>
          <target state="translated">実践では</target>
        </trans-unit>
        <trans-unit id="eb46744ebe1873e93242a02b5eecee5b509f89c1" translate="yes" xml:space="preserve">
          <source>In Raku, &lt;code&gt;when()&lt;/code&gt; will always do an implicit smartmatch with its argument, while in Perl 5 it is convenient (albeit potentially confusing) to suppress this implicit smartmatch in various rather loosely-defined situations, as roughly outlined above. (The difference is largely because Perl 5 does not have, even internally, a boolean type.)</source>
          <target state="translated">Rakuでは、 &lt;code&gt;when()&lt;/code&gt; は常にその引数を使用して暗黙のスマートマッチを実行しますが、Perl 5では、上で大まかに概説したように、さまざまなかなり大まかに定義された状況でこの暗黙のスマートマッチを抑制すると便利です（混乱する可能性があります）。（違いは主に、Perl 5には内部的にもブール型がないためです。）</target>
        </trans-unit>
        <trans-unit id="9c9de61f162399b6dd1501b64047f173f7ebabe0" translate="yes" xml:space="preserve">
          <source>In SVN, $Revision$ should be the same for every file in the project so they would all have the same $VERSION. CVS and RCS have a different $Revision$ per file so each file will have a different $VERSION. Distributed version control systems, such as SVK, may have a different $Revision$ based on who checks out the file, leading to a different $VERSION on each machine! Finally, some distributed version control systems, such as darcs, have no concept of revision number at all.</source>
          <target state="translated">SVN では、$Revision$ はプロジェクト内のすべてのファイルに対して同じでなければならないので、すべてのファイルが同じ $VERSION を持つことになります。CVS と RCS はファイルごとに異なる $Revision$ を持っているので、各ファイルは異なる $VERSION を持つことになります。SVK のような分散バージョン管理システムは、誰がファイルをチェックアウトするかによって異なる $Revision$ を持つことがあり、各マシンで異なる $VERSION を持つことになります。最後に、darcs のようないくつかの分散バージョン管理システムは、リビジョン番号の概念を全く持っていません。</target>
        </trans-unit>
        <trans-unit id="90d2162f62558275ce1491c594305e3a7a9057a0" translate="yes" xml:space="preserve">
          <source>In Settings, add the following Package Sources:</source>
          <target state="translated">設定で、以下のパッケージソースを追加します。</target>
        </trans-unit>
        <trans-unit id="35c376db5dd46f66500036f6b8bff5133701d987" translate="yes" xml:space="preserve">
          <source>In SunOS 4.x you most probably want to use the SunOS ld, /usr/bin/ld, since the more recent versions of GNU ld (like 2.13) do not seem to work for building Perl anymore. When linking the extensions, the GNU ld gets very unhappy and spews a lot of errors like this</source>
          <target state="translated">SunOS 4.xでは、おそらくSunOSのld、/usr/bin/ldを使いたいと思うでしょう。拡張機能をリンクするとき、GNU ldは非常に不機嫌になり、以下のようなエラーをたくさん吐き出します。</target>
        </trans-unit>
        <trans-unit id="6b9fdb7061782483bb0e3d2f43e0f1d23f2b17f3" translate="yes" xml:space="preserve">
          <source>In Taiwan, Japan, and Korea, it is common for text to have a mixture of characters from their native scripts and base Chinese. Perl follows Unicode's UTS 39 (&lt;a href=&quot;https://unicode.org/reports/tr39/&quot;&gt;https://unicode.org/reports/tr39/&lt;/a&gt;) Unicode Security Mechanisms in allowing such mixtures. For example, the Japanese scripts Katakana and Hiragana are commonly mixed together in practice, along with some Chinese characters, and hence are treated as being in a single script run by Perl.</source>
          <target state="translated">台湾、日本、韓国では、テキストにネイティブスクリプトの文字と中国語をベースにした文字が混在しているのが一般的です。Perlは、UnicodeのUTS 39（&lt;a href=&quot;https://unicode.org/reports/tr39/&quot;&gt;https://unicode.org/reports/tr39/&lt;/a&gt;）Unicodeセキュリティメカニズムに従って、このような混合を許可します。たとえば、日本語のスクリプトのカタカナとひらがなは、実際にはいくつかの漢字と一緒に混合されるのが一般的であるため、Perlによって実行される単一のスクリプトとして扱われます。</target>
        </trans-unit>
        <trans-unit id="ef1e3aace4bede70eba3cee6d6eb0864ab35df15" translate="yes" xml:space="preserve">
          <source>In Tru64 Perl is automatically able to use large files, that is, files larger than 2 gigabytes, there is no need to use the Configure -Duselargefiles option as described in INSTALL (though using the option is harmless).</source>
          <target state="translated">Tru64 では、Perl は自動的に大きなファイル、つまり 2 ギガバイトを超えるファイルを使用することができるので、INSTALL で説明した Configure -Duselargefiles オプションを使用する必要はありません (ただし、このオプションを使用しても害はありません)。</target>
        </trans-unit>
        <trans-unit id="cc19255447bc355361ae2f45799e7311a851742c" translate="yes" xml:space="preserve">
          <source>In Tru64 Perl's integers are automatically 64-bit wide, there is no need to use the Configure -Duse64bitint option as described in INSTALL. Similarly, there is no need for -Duse64bitall since pointers are automatically 64-bit wide.</source>
          <target state="translated">Tru64 Perl の整数は自動的に 64 ビット幅なので、INSTALL で説明した Configure -Duse64bitint オプションを使用する必要はありません。同様に、ポインタは自動的に 64 ビット幅なので、-Duse64bitall は必要ありません。</target>
        </trans-unit>
        <trans-unit id="92e8004abe586abe7845a841b1a5b8acbf9b5035" translate="yes" xml:space="preserve">
          <source>In Tru64 V5 (at least V5.1A, V5.1B) you cannot build threaded Perl with gcc because the system header &amp;lt;pthread.h&amp;gt; explicitly checks for supported C compilers, gcc (at least 3.2.2) not being one of them. But the system C compiler should work just fine.</source>
          <target state="translated">Tru64 V5（少なくともV5.1A、V5.1B）では、システムヘッダー&amp;lt;pthread.h&amp;gt;がサポートされているCコンパイラを明示的にチェックするため、gcc（少なくとも3.2.2）がそれらの1つではないため、gccを使用してスレッド化Perlを構築できません。 。しかし、システムのCコンパイラは問題なく動作するはずです。</target>
        </trans-unit>
        <trans-unit id="6303bf4cf60f3cd73bbb5bee3d92ebf1b27db248" translate="yes" xml:space="preserve">
          <source>In UTF-8 mode, it is not guaranteed that the lexer buffer actually contains valid UTF-8. Lexing code must be robust in the face of invalid encoding.</source>
          <target state="translated">UTF-8 モードでは、レキサーバッファが実際に有効な UTF-8 を含んでいるかどうかは保証されません。レキシングコードは、無効なエンコーディングに直面してもロバストでなければなりません。</target>
        </trans-unit>
        <trans-unit id="5587dff620034120288215aaa5eec31db833ac28" translate="yes" xml:space="preserve">
          <source>In Unicode 4.1.0, the definition D2 of canonical composition (which affects NFC and NFKC) has been changed (see Public Review Issue #29 and recent UAX #15). This module has used the newer definition since the version 0.07 (Oct 31, 2001). This module will not support the normalization according to the older definition, even if the Unicode version implemented by perl is lower than 4.1.0.</source>
          <target state="translated">Unicode 4.1.0 では、正準合成の定義 D2 (NFC と NFKC に影響を与えます)が変更されました (パブリックレビュー課題 #29 と最近の UAX #15 を参照してください)。このモジュールはバージョン0.07(2001年10月31日)から新しい定義を使用しています。このモジュールは、perl で実装されている Unicode のバージョンが 4.1.0 以下であっても、古い定義に従った正規化をサポートしません。</target>
        </trans-unit>
        <trans-unit id="4add5639cbd0356c9e63afa54113a4c2eb6433cf" translate="yes" xml:space="preserve">
          <source>In Unicode terminology a</source>
          <target state="translated">Unicode用語では</target>
        </trans-unit>
        <trans-unit id="f8ecaf55c52d72cac38172d4d214a7acd326645e" translate="yes" xml:space="preserve">
          <source>In Unicode, not just characters with the General Category of Lowercase Letter, but any character with the Lowercase property, including Modifier Letters, Letter Numbers, some Other Symbols, and one Combining Mark.</source>
          <target state="translated">Unicodeでは、小文字の一般的なカテゴリを持つ文字だけでなく、修飾文字、文字番号、いくつかのその他の記号、および1つの結合マークを含む、小文字プロパティを持つすべての文字が含まれています。</target>
        </trans-unit>
        <trans-unit id="6d6e7c6b62a7207f53debc7941773b1adb72b5b5" translate="yes" xml:space="preserve">
          <source>In Unicode, not just characters with the General Category of Uppercase Letter, but any character with the Uppercase property, including some Letter Numbers and Symbols. Not to be confused with &lt;b&gt;titlecase&lt;/b&gt;.</source>
          <target state="translated">Unicodeでは、大文字の一般カテゴリの文字だけでなく、一部の文字番号や記号など、大文字のプロパティを持つ文字。&lt;b&gt;タイトルケース&lt;/b&gt;と混同しないで&lt;b&gt;ください&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="b113bf75921160dcb55ede1f720912618b376337" translate="yes" xml:space="preserve">
          <source>In Unix, a sequence of zero or more nonnewline characters terminated with a &lt;b&gt;newline&lt;/b&gt; character. On non-Unix machines, this is emulated by the C library even if the underlying &lt;b&gt;operating system&lt;/b&gt; has different ideas.</source>
          <target state="translated">Unixでは、ゼロ以上の非&lt;b&gt;改行&lt;/b&gt;文字のシーケンスが&lt;b&gt;改行&lt;/b&gt;文字で終了し&lt;b&gt;ます&lt;/b&gt;。非UNIXマシンでは、これは、基礎となる&lt;b&gt;オペレーティングシステムの&lt;/b&gt;考え方が異なっていても、Cライブラリによってエミュレートされます。</target>
        </trans-unit>
        <trans-unit id="1bf9694eb8cd962c6afbe1434566f7218f970b1f" translate="yes" xml:space="preserve">
          <source>In Windows platforms, &lt;code&gt;$^O&lt;/code&gt; is not very helpful: since it is always &lt;code&gt;MSWin32&lt;/code&gt; , it doesn't tell the difference between 95/98/ME/NT/2000/XP/CE/.NET. Use &lt;code&gt;Win32::GetOSName()&lt;/code&gt; or Win32::GetOSVersion() (see &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt; and &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;) to distinguish between the variants.</source>
          <target state="translated">Windowsプラットフォームでは、 &lt;code&gt;$^O&lt;/code&gt; はあまり役に立ちません。常に &lt;code&gt;MSWin32&lt;/code&gt; であるため、95/98 / ME / NT / 2000 / XP / CE / .NETの違いはわかりません。使用 &lt;code&gt;Win32::GetOSName()&lt;/code&gt; やWin32 :: GetOSVersion（）（参照&lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;のWin32&lt;/a&gt;と&lt;a href=&quot;perlport&quot;&gt;はperlportを&lt;/a&gt;変種を区別します）。</target>
        </trans-unit>
        <trans-unit id="571c9a8187f8f9b92939078e49787860d6c5b703" translate="yes" xml:space="preserve">
          <source>In Windows platforms, &lt;code&gt;$^O&lt;/code&gt; is not very helpful: since it is always &lt;code&gt;MSWin32&lt;/code&gt;, it doesn't tell the difference between 95/98/ME/NT/2000/XP/CE/.NET. Use &lt;code&gt;Win32::GetOSName()&lt;/code&gt; or Win32::GetOSVersion() (see &lt;a href=&quot;win32&quot;&gt;Win32&lt;/a&gt; and &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt;) to distinguish between the variants.</source>
          <target state="translated">Windowsプラットフォームでは、 &lt;code&gt;$^O&lt;/code&gt; はあまり役に立ちません。常に &lt;code&gt;MSWin32&lt;/code&gt; であるため、95/98 / ME / NT / 2000 / XP / CE /.NETの違いはわかりません。使用 &lt;code&gt;Win32::GetOSName()&lt;/code&gt; やWin32 :: GetOSVersion（）（参照&lt;a href=&quot;win32&quot;&gt;のWin32&lt;/a&gt;と&lt;a href=&quot;perlport&quot;&gt;はperlportを&lt;/a&gt;変種を区別します）。</target>
        </trans-unit>
        <trans-unit id="91f9d78321013250cfcb8d441316ea8cae8423a1" translate="yes" xml:space="preserve">
          <source>In XS code, use of &lt;code&gt;to_utf8_case()&lt;/code&gt;</source>
          <target state="translated">XSコードでは、 &lt;code&gt;to_utf8_case()&lt;/code&gt; を使用します</target>
        </trans-unit>
        <trans-unit id="ab390a067e67919faf228f1feaba13aa8739d9a5" translate="yes" xml:space="preserve">
          <source>In XS code, use of to_utf8_case()</source>
          <target state="translated">XS コードでは、to_utf8_case()を使用します。</target>
        </trans-unit>
        <trans-unit id="864cceec0c178a3fbde977cff7807849ea71044b" translate="yes" xml:space="preserve">
          <source>In XS code, use of various macros dealing with UTF-8.</source>
          <target state="translated">XSコードでは、UTF-8を扱う様々なマクロを使用しています。</target>
        </trans-unit>
        <trans-unit id="d8d2f9cdc2abce1c37c00210e5a99994671e5e54" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt; code, text may contain formatting codes for formatting or for E&amp;lt;...&amp;gt; escapes, as in:</source>
          <target state="translated">では &lt;code&gt;L&amp;lt;text|...&amp;gt;&lt;/code&gt; コード、テキストのように、フォーマットするためまたはE &amp;lt;...&amp;gt;エスケープのためのコードをフォーマット含めることができます。</target>
        </trans-unit>
        <trans-unit id="282340f2a1ffb453132562968ecc8729e762ed24" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; loop, &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;eof(ARGV)&lt;/code&gt; can be used to detect the end of each file, whereas &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof()&lt;/code&gt;&lt;/a&gt; will detect the end of the very last file only. Examples:</source>
          <target state="translated">&lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; ループ、&lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof&lt;/code&gt; &lt;/a&gt;または &lt;code&gt;eof(ARGV)&lt;/code&gt; 、各ファイルの終わりを検出するために使用することができ、一方、&lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof()&lt;/code&gt; &lt;/a&gt;のみ非常に最後のファイルの終わりを検出します。例：</target>
        </trans-unit>
        <trans-unit id="01e19714f7b922e3746b1633bf7eecd4c7104aed" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; loop, &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; can be used to detect the end of each file, whereas &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; will detect the end of the very last file only. Examples:</source>
          <target state="translated">&lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; ループ、 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; 、各ファイルの終わりを検出するために使用することができ、一方、 &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; のみ非常に最後のファイルの終わりを検出します。例：</target>
        </trans-unit>
        <trans-unit id="41690d136fbd264eb140c8b8c6cc615177c5eb14" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; loop, &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; can be used to detect the end of each file, whereas &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; will detect the end of the very last file only. Examples:</source>
          <target state="translated">&lt;code&gt;while (&amp;lt;&amp;gt;)&lt;/code&gt; ループ、 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(ARGV)&lt;/a&gt;&lt;/code&gt; 、各ファイルの終わりを検出するために使用することができ、一方、 &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; のみ非常に最後のファイルの終わりを検出します。例：</target>
        </trans-unit>
        <trans-unit id="bc099e33e27d3f3cccb59648c75894207f5a15fa" translate="yes" xml:space="preserve">
          <source>In a Perl built for debugging, some buckets may have negative usable size. This means that these buckets cannot (and will not) be used. For larger buckets, the memory footprint may be one page greater than a power of 2. If so, the corresponding power of two is printed in the &lt;code&gt;APPROX&lt;/code&gt; field above.</source>
          <target state="translated">デバッグ用にビルドされたPerlでは、一部のバケットは使用可能な負のサイズを持つ場合があります。つまり、これらのバケットは使用できません（使用されません）。大きいバケットの場合、メモリフットプリントは2の累乗よりも1ページ大きくなる場合があります。その場合、対応する2の &lt;code&gt;APPROX&lt;/code&gt; 上の[ APPROX]フィールドに出力されます。</target>
        </trans-unit>
        <trans-unit id="9d530f843344f7a394d5586d561f13c274faa0f4" translate="yes" xml:space="preserve">
          <source>In a Perl version number such as 5.6.2, this is the 2. Values greater than 50 represent potentially unstable development subversions. This value is manually set in</source>
          <target state="translated">5.6.2 のような Perl のバージョン番号では、これは 2 になります。 50 より大きい値は、潜在的に不安定な開発サブバージョンを表します。この値は、手動で</target>
        </trans-unit>
        <trans-unit id="0f808181882ea1893d708887496cf67865ae159d" translate="yes" xml:space="preserve">
          <source>In a Perl version number such as 5.6.2, this is the 5. This value is manually set in</source>
          <target state="translated">5.6.2のようなPerlのバージョン番号では、これは5です。 この値は、手動で</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
