<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="bed16d4ef44043e0ee787c3f181832f24be03ea6" translate="yes" xml:space="preserve">
          <source>When you speak one language and the computer thinks you&amp;rsquo;re speaking another. You&amp;rsquo;ll see odd translations when you send UTF‑8, for instance, but the computer thinks you sent Latin-1, showing all sorts of weird characters instead. The term is written 「文字化け」in Japanese and means &amp;ldquo;character rot&amp;rdquo;, an apt description. Pronounced [&lt;code&gt;modʑibake&lt;/code&gt; ] in standard &lt;b&gt;IPA&lt;/b&gt; phonetics, or approximately &amp;ldquo;moh-jee-bah-keh&amp;rdquo;.</source>
          <target state="translated">ある言語を話し、コンピュータが別の言語を話していると考えているとき。たとえば、UTF‑8を送信すると奇妙な翻訳が表示されますが、コンピューターはLatin-1を送信したと見なし、代わりにあらゆる種類の奇妙な文字を表示します。言葉は「文字化け」と日本語で書かれており、適切な説明である「文字腐敗」を意味します。標準の&lt;b&gt;IPA&lt;/b&gt;音声で[ &lt;code&gt;modʑibake&lt;/code&gt; ]と発音されるか、ほぼ「moh-jee-bah-keh」と発音します。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7ef09f89e47adf28a99fbbb7052a436221dbcca0" translate="yes" xml:space="preserve">
          <source>When you speak one language and the computer thinks you&amp;rsquo;re speaking another. You&amp;rsquo;ll see odd translations when you send UTF‑8, for instance, but the computer thinks you sent Latin-1, showing all sorts of weird characters instead. The term is written 「文字化け」in Japanese and means &amp;ldquo;character rot&amp;rdquo;, an apt description. Pronounced [&lt;code&gt;modʑibake&lt;/code&gt;] in standard &lt;b&gt;IPA&lt;/b&gt; phonetics, or approximately &amp;ldquo;moh-jee-bah-keh&amp;rdquo;.</source>
          <target state="translated">あなたが1つの言語を話し、コンピューターがあなたが別の言語を話していると見なすとき。たとえば、UTF‑8を送信すると奇妙な翻訳が表示されますが、コンピュータはラテン語-1を送信したと見なし、代わりにあらゆる種類の奇妙な文字を表示します。この用語は日本語で「文字化け」と書かれており、適切な説明である「文字の腐敗」を意味します。標準の&lt;b&gt;IPA&lt;/b&gt;音声学では、[ &lt;code&gt;modʑibake&lt;/code&gt; ]と発音されます。または、ほぼ「moh-jee-bah-keh」と発音されます。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="665a5769943788c4623d27cfed3bae7f7e133317" translate="yes" xml:space="preserve">
          <source>When you specify arguments to routines in the .xs file, you are really passing three pieces of information for each argument listed. The first piece is the order of that argument relative to the others (first, second, etc). The second is the type of argument, and consists of the type declaration of the argument (e.g., int, char*, etc). The third piece is the calling convention for the argument in the call to the library function.</source>
          <target state="translated">.xs ファイルでルーチンの引数を指定するとき、リストされている各引数に対して、実際には 3 つの情報を渡すことになります。最初の情報は、他の引数との相対的な引数の順番です(最初、2番目など)。2つ目は引数の型で、引数の型宣言(例えば、int、char*など)で構成されています。3番目の部分は、ライブラリ関数を呼び出す際の引数の呼び出し規則です。</target>
        </trans-unit>
        <trans-unit id="92bc744ea7824ccea4eeb23e82728fbc4ddab899" translate="yes" xml:space="preserve">
          <source>When you supply a separate display name it becomes possible to run a test more than once; the display name is effectively the alias by which the test is known inside the harness. The harness doesn't care if it runs the same test more than once when each invocation uses a different name.</source>
          <target state="translated">別々の表示名を指定すると、テストを複数回実行することが可能になります。表示名は事実上、ハーネス内部でテストを知るためのエイリアスです。ハーネスは、各呼び出しが異なる名前を使用している場合、同じテストを複数回実行しても気にしません。</target>
        </trans-unit>
        <trans-unit id="f5d8e81bcb99e99cbe008b301dbaa4156e030e10" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; to lock the file, &lt;code&gt;Tie::File&lt;/code&gt; assumes that the read cache is no longer trustworthy, because another process might have modified the file since the last time it was read. Therefore, a successful call to &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; discards the contents of the read cache and the internal record offset table.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; を使用してファイルをロックすると、 &lt;code&gt;Tie::File&lt;/code&gt; は、最後に読み取られてから別のプロセスがファイルを変更した可能性があるため、読み取りキャッシュが信頼できないものと見なします。したがって、 &lt;code&gt;&lt;a href=&quot;../functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; の呼び出しが成功すると、読み取りキャッシュの内容と内部レコードオフセットテーブルが破棄されます。</target>
        </trans-unit>
        <trans-unit id="86d314b9ffee5484e299c428ac086a5864115f83" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;flock&lt;/code&gt; to lock the file, &lt;code&gt;Tie::File&lt;/code&gt; assumes that the read cache is no longer trustworthy, because another process might have modified the file since the last time it was read. Therefore, a successful call to &lt;code&gt;flock&lt;/code&gt; discards the contents of the read cache and the internal record offset table.</source>
          <target state="translated">&lt;code&gt;flock&lt;/code&gt; を使用してファイルをロックすると、 &lt;code&gt;Tie::File&lt;/code&gt; は、最後に読み取られてから別のプロセスがファイルを変更した可能性があるため、読み取りキャッシュが信頼できないと見なします。したがって、 &lt;code&gt;flock&lt;/code&gt; の呼び出しが成功すると、読み取りキャッシュと内部レコードオフセットテーブルの内容が破棄されます。</target>
        </trans-unit>
        <trans-unit id="de1ea55b20ff67d97a482097e7d303cd94b1b34c" translate="yes" xml:space="preserve">
          <source>When you use Perl from C, your C program will--usually--allocate, &quot;run&quot;, and deallocate a</source>
          <target state="translated">CからPerlを使用する場合、Cプログラムは通常</target>
        </trans-unit>
        <trans-unit id="5b4b7e46fe751c099868927c5d1568ad4f11af65" translate="yes" xml:space="preserve">
          <source>When you use the &lt;b&gt;-n&lt;/b&gt; and &lt;b&gt;-p&lt;/b&gt; switches to Perl, &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; work just as they do in &lt;b&gt;awk&lt;/b&gt;, as a degenerate case. Both &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;CHECK&lt;/code&gt; blocks are run when you use the &lt;b&gt;-c&lt;/b&gt; switch for a compile-only syntax check, although your main code is not.</source>
          <target state="translated">&lt;b&gt;-n&lt;/b&gt;および&lt;b&gt;-p&lt;/b&gt;スイッチをPerlに使用すると、 &lt;code&gt;BEGIN&lt;/code&gt; と &lt;code&gt;END&lt;/code&gt; は、&lt;b&gt;awk&lt;/b&gt;と同じように機能します。&lt;b&gt;-c&lt;/b&gt;スイッチを使用してコンパイルのみの構文チェックを実行すると、 &lt;code&gt;BEGIN&lt;/code&gt; ブロックと &lt;code&gt;CHECK&lt;/code&gt; ブロックの両方が実行されますが、メインコードは実行されません。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="6e7c5168dc3e4d09a86a5c07db61ae55b067c306" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or Perl's &lt;b&gt;-w&lt;/b&gt; command-line option, you may see warnings about useless uses of constants or functions in &quot;void context&quot;. Void context just means the value has been discarded, such as a statement containing only &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid(0);&lt;/a&gt;&lt;/code&gt;. It still counts as scalar context for functions that care whether or not they're being called in list context.</source>
          <target state="translated">あなたが使用する場合 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; プラグマやPerlの&lt;b&gt;-w&lt;/b&gt;コマンドラインオプションを、あなたは「無効コンテキスト」での定数や関数の無用な使用に関する警告が表示されます。 Voidコンテキストは、 &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; のみを含むステートメントなど、値が破棄されたことを意味します。または &lt;code&gt;&lt;a href=&quot;functions/getpwuid&quot;&gt;getpwuid(0);&lt;/a&gt;&lt;/code&gt; 。リストコンテキストで呼び出されているかどうかを気にする関数のスカラーコンテキストとしてカウントされます。</target>
        </trans-unit>
        <trans-unit id="21a0f043d5bac1b816d417902a549ec51099c064" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;use warnings&lt;/code&gt; pragma or Perl's &lt;b&gt;-w&lt;/b&gt; command-line option, you may see warnings about useless uses of constants or functions in &quot;void context&quot;. Void context just means the value has been discarded, such as a statement containing only &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; or &lt;code&gt;getpwuid(0);&lt;/code&gt;. It still counts as scalar context for functions that care whether or not they're being called in list context.</source>
          <target state="translated">あなたが使用する場合 &lt;code&gt;use warnings&lt;/code&gt; プラグマやPerlの&lt;b&gt;-w&lt;/b&gt;コマンドラインオプションを、あなたは「無効コンテキスト」での定数や関数の無用な使用に関する警告が表示されます。無効なコンテキストは、 &lt;code&gt;&quot;fred&quot;;&lt;/code&gt; のみを含むステートメントなど、値が破棄されたことを意味します。または &lt;code&gt;getpwuid(0);&lt;/code&gt; 。それでも、リストコンテキストで呼び出されているかどうかを気にする関数のスカラーコンテキストとしてカウントされます。</target>
        </trans-unit>
        <trans-unit id="f561cbf428cfa38a570f079c8fe3f1e6c4934924" translate="yes" xml:space="preserve">
          <source>When you want to encode Unicode for mails and web pages, however, do not use UTF-7 unless you are sure your recipients and readers can handle it. Very few MUAs and WWW Browsers support these days (only Mozilla seems to support one). For general cases, use UTF-8 for message body and MIME-Header for header instead.</source>
          <target state="translated">ただし、メールやウェブページをUnicodeでエンコードしたい場合は、受信者や読者がそれを扱えると確信していない限り、UTF-7は使わないようにしてください。最近ではMUAやWWWブラウザがサポートしているものはほとんどありません(Mozillaだけがサポートしているようです)。一般的なケースでは、メッセージの本文には UTF-8、ヘッダには MIME-Header を使用してください。</target>
        </trans-unit>
        <trans-unit id="d1594b9a6f30c884e42aa7810e12c05455ffa364" translate="yes" xml:space="preserve">
          <source>When you want to write to a file, you first have to decide what to do about any existing contents of that file. You have two basic choices here: to preserve or to clobber.</source>
          <target state="translated">ファイルに書き込みたいときは、まず、そのファイルの既存の内容をどうするかを決めなければなりません。ここでは基本的に2つの選択肢があります。</target>
        </trans-unit>
        <trans-unit id="f729e16e6d70d308845c4e263f4f5d66444de2cc" translate="yes" xml:space="preserve">
          <source>When you're done with your filehandles, you should &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; them (though to be honest, Perl will clean up after you if you forget):</source>
          <target state="translated">ファイルハンドルを使い終わったら、それらを &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; する必要があります（正直なところ、忘れた場合はPerlがクリーンアップします）。</target>
        </trans-unit>
        <trans-unit id="1488b5ce874430f2891cff85427abec3fe4ed92a" translate="yes" xml:space="preserve">
          <source>When you're done with your filehandles, you should &lt;code&gt;close()&lt;/code&gt; them (though to be honest, Perl will clean up after you if you forget):</source>
          <target state="translated">ファイルハンドルを使い終わったら、それらを &lt;code&gt;close()&lt;/code&gt; する必要があります（正直なところ、忘れるとPerlがクリーンアップします）：</target>
        </trans-unit>
        <trans-unit id="f855bc56e9b2d1a2f4296535cb927b2c13c9dd7d" translate="yes" xml:space="preserve">
          <source>When you're using RETVAL to return an &lt;code&gt;SV *&lt;/code&gt; , there's some magic going on behind the scenes that should be mentioned. When you're manipulating the argument stack using the ST(x) macro, for example, you usually have to pay special attention to reference counts. (For more about reference counts, see &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.) To make your life easier, the typemap file automatically makes &lt;code&gt;RETVAL&lt;/code&gt; mortal when you're returning an &lt;code&gt;SV *&lt;/code&gt; . Thus, the following two XSUBs are more or less equivalent:</source>
          <target state="translated">RETVALを使用して &lt;code&gt;SV *&lt;/code&gt; を返す場合、言及する必要がある舞台裏でいくつかの魔法が起こっています。たとえば、ST（x）マクロを使用して引数スタックを操作する場合、通常、参照カウントに特別な注意を払う必要があります。（参照カウントの詳細については、&lt;a href=&quot;perlguts&quot;&gt;perlgutsを&lt;/a&gt;参照してください。）生活を楽にするために、 &lt;code&gt;SV *&lt;/code&gt; を返すときに &lt;code&gt;RETVAL&lt;/code&gt; マップファイルは自動的にRETVALを致命的にします。したがって、次の2つのXSUBはほぼ同等です。</target>
        </trans-unit>
        <trans-unit id="aff47fe5db562b3d2dbc867dc1c147d97de9621a" translate="yes" xml:space="preserve">
          <source>When you're using RETVAL to return an &lt;code&gt;SV *&lt;/code&gt;, there's some magic going on behind the scenes that should be mentioned. When you're manipulating the argument stack using the ST(x) macro, for example, you usually have to pay special attention to reference counts. (For more about reference counts, see &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.) To make your life easier, the typemap file automatically makes &lt;code&gt;RETVAL&lt;/code&gt; mortal when you're returning an &lt;code&gt;SV *&lt;/code&gt;. Thus, the following two XSUBs are more or less equivalent:</source>
          <target state="translated">RETVALを使用して &lt;code&gt;SV *&lt;/code&gt; を返す場合、言及する必要のある舞台裏でいくつかの魔法が起こっています。たとえば、ST（x）マクロを使用して引数スタックを操作する場合、通常は参照カウントに特別な注意を払う必要があります。（参照カウントの詳細については、&lt;a href=&quot;perlguts&quot;&gt;perlgutsを&lt;/a&gt;参照してください。） &lt;code&gt;RETVAL&lt;/code&gt; 楽にするために、 &lt;code&gt;SV *&lt;/code&gt; を返すときに、タイプマップファイルによって自動的にRETVALが致命的になります。したがって、次の2つのXSUBはほぼ同等です。</target>
        </trans-unit>
        <trans-unit id="5829efde6fb988f406fa62c8ae4c250e14e41e30" translate="yes" xml:space="preserve">
          <source>When you've found that there isn't a module available for what you're trying to do, and you've had to write the code yourself, consider packaging up the solution into a module and uploading it to CPAN so that others can benefit.</source>
          <target state="translated">自分がやろうとしていることに利用できるモジュールがなく、自分でコードを書かなければならなかった場合は、ソリューションをモジュールにパッケージ化してCPANにアップロードすることを検討してみましょう。</target>
        </trans-unit>
        <trans-unit id="6b113771452e06c12bd2750d8700f91d2cc72def" translate="yes" xml:space="preserve">
          <source>When you've got your name sorted out and you're sure that your module is wanted and not currently available, it's time to start coding.</source>
          <target state="translated">名前を整理して、モジュールが必要とされていて現在利用できないことを確認したら、コーディングを開始しましょう。</target>
        </trans-unit>
        <trans-unit id="baa149e5f728be9fcf5c842fafa04ad779a77d18" translate="yes" xml:space="preserve">
          <source>When your child is done running tests, you must call &lt;code&gt;finalize&lt;/code&gt; to clean up and tell the parent your pass/fail status.</source>
          <target state="translated">子供がテストの実行を終えたら、 &lt;code&gt;finalize&lt;/code&gt; を呼び出してクリーンアップして、親に合格/不合格のステータスを通知する必要があります。</target>
        </trans-unit>
        <trans-unit id="701f121f0767fb048f9a1e9cdd7bcb29143a3d18" translate="yes" xml:space="preserve">
          <source>When your module encounters an error it should do one or more of:</source>
          <target state="translated">モジュールがエラーに遭遇した場合、次のうちの1つ以上を実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="7d300f1dcd786450162ec26ef8c71857af330be4" translate="yes" xml:space="preserve">
          <source>When, &lt;code&gt;$Archive::Tar::CHMOD&lt;/code&gt; is enabled, this setting controls whether the permissions on files from the archive are used without modification of if they are filtered by removing any setid bits and applying the current umask.</source>
          <target state="translated">場合は、 &lt;code&gt;$Archive::Tar::CHMOD&lt;/code&gt; 有効になっている、アーカイブからファイルのパーミッションかどうか、この設定を制御し、それらがどのSETIDビットを削除し、現在のumaskを適用することにより、フィルタリングされた場合の修正なしで使用されています。</target>
        </trans-unit>
        <trans-unit id="c7c9dae84175d878d430d8cca64e61d718171eab" translate="yes" xml:space="preserve">
          <source>When, however, you assign a list of scalars to another list of scalars, the results differ according to whether the left-hand list -- the list being assigned to -- has the same, more or fewer elements than the right-hand list.</source>
          <target state="translated">しかし、スカラのリストを別のスカラのリストに代入した場合、代入先のリストである左手のリストが右手のリストと同じ要素を持っているか、持っている要素が多いか、少ないかによって結果が異なります。</target>
        </trans-unit>
        <trans-unit id="d830d827614f19bd45afae435d976e89279e08bd" translate="yes" xml:space="preserve">
          <source>Whenever JSON allows whitespace, C++-style one-line comments are additionally allowed. They are terminated by the first carriage-return or line-feed character, after which more white-space and comments are allowed.</source>
          <target state="translated">JSONが空白を許可している場合はいつでも、C++スタイルの1行コメントも追加で許可されます。これらのコメントは、最初のキャリッジリターン文字または改行文字で終了し、その後、より多くの空白とコメントが許可されます。</target>
        </trans-unit>
        <trans-unit id="042aae650b0c414ca1cd41812840fd2d72dec204" translate="yes" xml:space="preserve">
          <source>Whenever JSON allows whitespace, C-style multiple-line comments are additionally allowed. Everything between &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt; is a comment, after which more white-space and comments are allowed.</source>
          <target state="translated">JSONで空白が許可されている場合は常に、Cスタイルの複数行コメントが追加で許可されます。 &lt;code&gt;/*&lt;/code&gt; と &lt;code&gt;*/&lt;/code&gt; の間はすべてコメントであり、その後は空白とコメントを追加できます。</target>
        </trans-unit>
        <trans-unit id="99a2ef40caf9ba8f64a09af2f45cf33737585968" translate="yes" xml:space="preserve">
          <source>Whenever JSON allows whitespace, shell-style comments are additionally allowed. They are terminated by the first carriage-return or line-feed character, after which more white-space and comments are allowed.</source>
          <target state="translated">JSONが空白を許可している場合はいつでも、シェル形式のコメントも許可されます。これらのコメントは、最初のキャリッジリターン文字またはラインフィード文字で終了し、その後、より多くの空白とコメントが許可されます。</target>
        </trans-unit>
        <trans-unit id="cabccb147592c137e487eb001cea479dffb70830" translate="yes" xml:space="preserve">
          <source>Whenever a Berkeley DB function returns data via one of its parameters, the equivalent &lt;b&gt;DB_File&lt;/b&gt; method does exactly the same.</source>
          <target state="translated">Berkeley DB関数がパラメーターの1つを介してデータを返すときはいつでも、同等の&lt;b&gt;DB_File&lt;/b&gt;メソッドがまったく同じことを行います。</target>
        </trans-unit>
        <trans-unit id="6a800aba7242513688fb7365bc61881077cd8882" translate="yes" xml:space="preserve">
          <source>Whenever a Perl subroutine is called using one of the</source>
          <target state="translated">Perl のサブルーチンが呼び出されるたびに</target>
        </trans-unit>
        <trans-unit id="6344d70f52ab5669e0f868bcc4766007019f0e1c" translate="yes" xml:space="preserve">
          <source>Whenever a reference is used as a field hash key, the object registry is checked and a new entry is made if necessary. The field hash is then added to the list of fields this reference has used.</source>
          <target state="translated">参照がフィールドハッシュキーとして使用されるたびに、オブジェクトレジストリがチェックされ、必要に応じて新しいエントリが作成されます。フィールドハッシュは、この参照が使用したフィールドのリストに追加されます。</target>
        </trans-unit>
        <trans-unit id="ac59cb12b90f854e158e9f7e8d962f434ede4764" translate="yes" xml:space="preserve">
          <source>Whenever control returns from the</source>
          <target state="translated">から制御が戻るたびに</target>
        </trans-unit>
        <trans-unit id="56847d63f6da95857482dd3497381b06019beb12" translate="yes" xml:space="preserve">
          <source>Whenever metadata consumers merge prerequisites, either from different phases or from &lt;code&gt;optional_features&lt;/code&gt;, they should merged in a way which preserves the intended semantics of the prerequisite structure. Generally, this means concatenating the version specifications using commas, as described in the &lt;a href=&quot;#Version-Ranges&quot;&gt;&quot;Version Ranges&quot;&lt;/a&gt; section.</source>
          <target state="translated">メタデータコンシューマーは、異なるフェーズまたは &lt;code&gt;optional_features&lt;/code&gt; のいずれかから前提条件をマージする場合は常に、前提条件構造の意図されたセマンティクスを保持する方法でマージする必要があります。通常、これは、&lt;a href=&quot;#Version-Ranges&quot;&gt;「バージョン範囲」&lt;/a&gt;セクションで説明されているように、コンマを使用してバージョン仕様を連結することを意味します。</target>
        </trans-unit>
        <trans-unit id="58a47aafac8fca0c788807bc11f865583b9a79dd" translate="yes" xml:space="preserve">
          <source>Whenever possible, new features should be prototyped in a CPAN module before they will be considered for the core.</source>
          <target state="translated">可能な限り、新機能はCPANモジュールでプロトタイプを作成してからコアのために検討してください。</target>
        </trans-unit>
        <trans-unit id="a368a6c064c79ec6ec1d84f92fa7a58354e83dad" translate="yes" xml:space="preserve">
          <source>Whenever this is applied to a string which doesn't quite meet the pattern's expectations such as &lt;code&gt;&quot;abc  &quot;&lt;/code&gt; or &lt;code&gt;&quot;abc  def &quot;&lt;/code&gt; , the regex engine will backtrack, approximately once for each character in the string. But we know that there is no way around taking</source>
          <target state="translated">これが &lt;code&gt;&quot;abc &quot;&lt;/code&gt; や &lt;code&gt;&quot;abc def &quot;&lt;/code&gt; などのパターンの期待に完全に一致しない文字列に適用される場合は常に、正規表現エンジンは文字列内の各文字に対して約1回バックトラックします。しかし、私たちは取る方法がないことを知っています</target>
        </trans-unit>
        <trans-unit id="ff79b096fb177b1f29c2b3cfee678fdb53ec5582" translate="yes" xml:space="preserve">
          <source>Whenever this is applied to a string which doesn't quite meet the pattern's expectations such as &lt;code&gt;&quot;abc &quot;&lt;/code&gt; or &lt;code&gt;&quot;abc def &quot;&lt;/code&gt;, the regexp engine will backtrack, approximately once for each character in the string. But we know that there is no way around taking</source>
          <target state="translated">これが &lt;code&gt;&quot;abc &quot;&lt;/code&gt; や &lt;code&gt;&quot;abc def &quot;&lt;/code&gt; 」などのパターンの期待を完全に満たしていない文字列に適用されると、正規表現エンジンは文字列内の各文字に対して約1回バックトラックします。しかし、私たちは取る方法がないことを知っています</target>
        </trans-unit>
        <trans-unit id="1d972aca2274b3be6437814e7f18c3f8fdf56c12" translate="yes" xml:space="preserve">
          <source>Whenever you do I/O on a file in Perl, you do so through what in Perl is called a &lt;b&gt;filehandle&lt;/b&gt;. A filehandle is an internal name for an external file. It is the job of the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; function to make the association between the internal name and the external name, and it is the job of the &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; function to break that association.</source>
          <target state="translated">Perlでファイルに対してI / Oを実行するときはいつでも、Perlでは&lt;b&gt;ファイルハンドル&lt;/b&gt;と呼ばれる方法でこれを行い&lt;b&gt;ます&lt;/b&gt;。ファイルハンドルは、外部ファイルの内部名です。内部名と外部名の関連付けを行うのは &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 関数の仕事であり、その関連付けを解除するのは &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; 関数の仕事です。</target>
        </trans-unit>
        <trans-unit id="2609a2feff469b602ec869a4ded1b4330334544b" translate="yes" xml:space="preserve">
          <source>Whenever you do I/O on a file in Perl, you do so through what in Perl is called a &lt;b&gt;filehandle&lt;/b&gt;. A filehandle is an internal name for an external file. It is the job of the &lt;code&gt;open&lt;/code&gt; function to make the association between the internal name and the external name, and it is the job of the &lt;code&gt;close&lt;/code&gt; function to break that association.</source>
          <target state="translated">Perlでファイルに対してI / Oを実行するときは常に、Perlでは&lt;b&gt;ファイルハンドル&lt;/b&gt;と呼ばれるものを介して実行し&lt;b&gt;ます&lt;/b&gt;。ファイルハンドルは、外部ファイルの内部名です。内部名と外部名を関連付けるのは &lt;code&gt;open&lt;/code&gt; 関数の仕事であり、その関連付けを解除するのは &lt;code&gt;close&lt;/code&gt; 関数の仕事です。</target>
        </trans-unit>
        <trans-unit id="ed7093ca3cc4a3c897e96991516ce1f4f0fcfd4e" translate="yes" xml:space="preserve">
          <source>Whenever you have more than one subprocess, you must be careful that each closes whichever half of any pipes created for interprocess communication it is not using. This is because any child process reading from the pipe and expecting an EOF will never receive it, and therefore never exit. A single process closing a pipe is not enough to close it; the last process with the pipe open must close it for it to read EOF.</source>
          <target state="translated">複数のサブプロセスがある場合は、プロセス間通信のために作成されたパイプのうち、使用していないパイプの半分をそれぞれが閉じるように注意しなければなりません。これは、パイプから読み込んでEOFを期待している子プロセスがパイプを受け取ることはなく、決して終了しないからです。1つのプロセスがパイプを閉じるだけではパイプを閉じることはできません。</target>
        </trans-unit>
        <trans-unit id="cd1ee0eb738b950d883ab6c08ca29be20ef06df7" translate="yes" xml:space="preserve">
          <source>Whenever you're communicating text with anything that is external to your perl process, like a database, a text file, a socket, or another program. Even if the thing you're communicating with is also written in Perl.</source>
          <target state="translated">データベース、テキストファイル、ソケット、他のプログラムなど、Perlプロセスの外部にあるものとテキストを通信しているときはいつもそうです。通信相手がPerlで書かれたものであってもです。</target>
        </trans-unit>
        <trans-unit id="cc31f890f5831db8c47f9104a5fd72a40a9b958c" translate="yes" xml:space="preserve">
          <source>Whenever your encoded, binary string is used together with a text string, Perl will assume that your binary string was encoded with ISO-8859-1, also known as latin-1. If it wasn't latin-1, then your data is unpleasantly converted. For example, if it was UTF-8, the individual bytes of multibyte characters are seen as separate characters, and then again converted to UTF-8. Such double encoding can be compared to double HTML encoding (&lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ), or double URI encoding (&lt;code&gt;%253E&lt;/code&gt; ).</source>
          <target state="translated">エンコードされたバイナリ文字列がテキスト文字列と一緒に使用されるときはいつでも、Perlはバイナリ文字列がlatin-1としても知られるISO-8859-1でエンコードされたと想定します。latin-1でない場合、データは不快に変換されます。たとえば、UTF-8の場合、マルチバイト文字の個々のバイトは個別の文字として認識され、その後再びUTF-8に変換されます。このような二重エンコーディングは、二重HTMLエンコーディング（ &lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ）または二重URIエンコーディング（ &lt;code&gt;%253E&lt;/code&gt; ）と比較できます。</target>
        </trans-unit>
        <trans-unit id="b8d5a9055801b14712a33d32b68e49a7db91b2d3" translate="yes" xml:space="preserve">
          <source>Whenever your encoded, binary string is used together with a text string, Perl will assume that your binary string was encoded with ISO-8859-1, also known as latin-1. If it wasn't latin-1, then your data is unpleasantly converted. For example, if it was UTF-8, the individual bytes of multibyte characters are seen as separate characters, and then again converted to UTF-8. Such double encoding can be compared to double HTML encoding (&lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt;), or double URI encoding (&lt;code&gt;%253E&lt;/code&gt;).</source>
          <target state="translated">エンコードされたバイナリ文字列がテキスト文字列と一緒に使用される場合は常に、Perlはバイナリ文字列がISO-8859-1（latin-1とも呼ばれる）でエンコードされていると見なします。latin-1でない場合、データは不快に変換されます。たとえば、UTF-8の場合、マルチバイト文字の個々のバイトは個別の文字と見なされ、再びUTF-8に変換されます。このような二重エンコードは、二重HTMLエンコード（ &lt;code&gt;&amp;amp;amp;gt;&lt;/code&gt; ）または二重URIエンコード（ &lt;code&gt;%253E&lt;/code&gt; ）と比較できます。</target>
        </trans-unit>
        <trans-unit id="e1d629f115a3e97bf6ae620fc76d3801dd8ef401" translate="yes" xml:space="preserve">
          <source>Whenever your program accesses data or resources that can be accessed by other threads, you must take steps to coordinate access or risk data inconsistency and race conditions. Note that Perl will protect its internals from your race conditions, but it won't protect you from you.</source>
          <target state="translated">あなたのプログラムが他のスレッドからアクセス可能なデータやリソースにアクセスするときはいつでも、アクセスを調整するための措置を取らなければなりません。Perlは、あなたのレース条件から内部を保護しますが、あなたをあなたから守ることはできないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="525f61b6729229b1a8854a9e50bcaa52ea96b131" translate="yes" xml:space="preserve">
          <source>Where</source>
          <target state="translated">Where</target>
        </trans-unit>
        <trans-unit id="59d37a0123152108bee6e05a64e55d45d68bc028" translate="yes" xml:space="preserve">
          <source>Where $directory_count % 10 is 1 (&quot;%&quot; for modulo, remember), assuming $directory count is an integer, and except where $directory_count % 100 is 11, &quot;directories&quot; is forced to become grammatically singular, which means it gets the ending for the accusative singular... You begin to visualize the code it'd take to test for the problem so far,</source>
          <target state="translated">ディレクトリ数が整数であると仮定して、$directory_count % 10 が 1 (&quot;%&quot; は modulo を意味します、覚えておいてください)の場合、$directory_count % 100 が 11 の場合を除いて、&quot;directory&quot; は文法的に単数形になるように強制されます。これまでの問題をテストするために必要なコードを可視化し始めます。</target>
        </trans-unit>
        <trans-unit id="fb9b184246f9c47c2085ba5fb400e91c6332924c" translate="yes" xml:space="preserve">
          <source>Where 1 is the position of the first char in the string. Note that position can be 0, or larger than the actual length of the pattern, likewise length can be zero.</source>
          <target state="translated">ここで 1 は文字列の最初の文字の位置です。位置は0か、パターンの実際の長さよりも大きくすることができ、同様に長さも0にすることができます。</target>
        </trans-unit>
        <trans-unit id="73e22419719a01d34b548da9ec30ecb83ae08c13" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's.</source>
          <target state="translated">ここで &lt;code&gt;$id1&lt;/code&gt; 、 &lt;code&gt;$id2&lt;/code&gt; 2つのバイトのサブフィールドIDのです。</target>
        </trans-unit>
        <trans-unit id="b9cb4e493b9dc9b7340611ceb99bc1cecceb2405" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt; , &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's. The second byte of the ID cannot be 0, unless the &lt;code&gt;Strict&lt;/code&gt; option has been disabled.</source>
          <target state="translated">ここで &lt;code&gt;$id1&lt;/code&gt; 、 &lt;code&gt;$id2&lt;/code&gt; 2つのバイトのサブフィールドIDのです。 &lt;code&gt;Strict&lt;/code&gt; オプションが無効になっていない限り、IDの2番目のバイトを0にすることはできません。</target>
        </trans-unit>
        <trans-unit id="77383c70462fa701aace92ef9b074251586e9457" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt;, &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's.</source>
          <target state="translated">ここで、 &lt;code&gt;$id1&lt;/code&gt; 、 &lt;code&gt;$id2&lt;/code&gt; は2バイトのサブフィールドIDです。</target>
        </trans-unit>
        <trans-unit id="2a738c1e73fe6ddbf768fa126f517ebb72454b3e" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$id1&lt;/code&gt;, &lt;code&gt;$id2&lt;/code&gt; are two byte subfield ID's. The second byte of the ID cannot be 0, unless the &lt;code&gt;Strict&lt;/code&gt; option has been disabled.</source>
          <target state="translated">ここで、 &lt;code&gt;$id1&lt;/code&gt; 、 &lt;code&gt;$id2&lt;/code&gt; は2バイトのサブフィールドIDです。 &lt;code&gt;Strict&lt;/code&gt; オプションが無効になっていない限り、IDの2番目のバイトを0にすることはできません。</target>
        </trans-unit>
        <trans-unit id="de8d3be1468ab688b0e6e35d8cea1268cae0caa0" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;$r1&lt;/code&gt; can be a reference to any kind of data structure you'd like. It will be deeply copied. Because &lt;code&gt;dclone&lt;/code&gt; takes and returns references, you'd have to add extra punctuation if you had a hash of arrays that you wanted to copy.</source>
          <target state="translated">ここで、 &lt;code&gt;$r1&lt;/code&gt; は、任意の種類のデータ構造への参照にすることができます。深くコピーされます。 &lt;code&gt;dclone&lt;/code&gt; は参照を取得して返すため、コピーする配列のハッシュがある場合は、句読点を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="29126cbcaebf3032a0f200bdad16fd67b9d2ca9f" translate="yes" xml:space="preserve">
          <source>Where a &lt;b&gt;compiler&lt;/b&gt; remembers symbols. A program like Perl must somehow remember all the names of all the &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;filehandles&lt;/b&gt;, and &lt;b&gt;subroutines&lt;/b&gt; you&amp;rsquo;ve used. It does this by placing the names in a symbol table, which is implemented in Perl using a &lt;b&gt;hash table&lt;/b&gt;. There is a separate symbol table for each &lt;b&gt;package&lt;/b&gt; to give each package its own &lt;b&gt;namespace&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;コンパイラー&lt;/b&gt;がシンボルを記憶する場所。Perlのようなプログラムは、使用したすべての&lt;b&gt;変数&lt;/b&gt;、&lt;b&gt;ファイルハンドル&lt;/b&gt;、および&lt;b&gt;サブルーチンの&lt;/b&gt;すべての名前を何らかの方法で記憶する必要があります。これは、&lt;b&gt;ハッシュテーブル&lt;/b&gt;を使用してPerlで実装されているシンボルテーブルに名前を配置することで行われ&lt;b&gt;ます&lt;/b&gt;。各パッケージに独自の&lt;b&gt;名前空間&lt;/b&gt;を与えるために、&lt;b&gt;パッケージ&lt;/b&gt;ごとに個別のシンボルテーブルがあり&lt;b&gt;ます&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="c27a5a0858ef6e994699b8e168fe5635708702fa" translate="yes" xml:space="preserve">
          <source>Where a layer opens or takes ownership of a file descriptor, that layer is responsible for getting the file descriptor's close-on-exec flag into the correct state. The flag should be clear for a file descriptor numbered less than or equal to &lt;code&gt;PL_maxsysfd&lt;/code&gt;, and set for any file descriptor numbered higher. For thread safety, when a layer opens a new file descriptor it should if possible open it with the close-on-exec flag initially set.</source>
          <target state="translated">レイヤーがファイル記述子を開くか所有権を取得する場合、そのレイヤーはファイル記述子の実行時クローズフラグを正しい状態にする責任があります。 &lt;code&gt;PL_maxsysfd&lt;/code&gt; 以下の番号のファイル記述子の場合はフラグをクリアし、それより大きい番号のファイル記述子の場合はフラグを設定する必要があります。スレッドセーフのために、レイヤーが新しいファイル記述子を開くときは、可能であれば、close-on-execフラグを最初に設定して開く必要があります。</target>
        </trans-unit>
        <trans-unit id="841b8cfbd59c36bfe89c29e0da6a4675a6abce15" translate="yes" xml:space="preserve">
          <source>Where are modules installed?</source>
          <target state="translated">モジュールはどこに設置されていますか?</target>
        </trans-unit>
        <trans-unit id="77cc20dcc0c42287d0cc6c95ce660feb0b4c5aeb" translate="yes" xml:space="preserve">
          <source>Where can I buy a commercial version of Perl?</source>
          <target state="translated">Perlの商用版はどこで買えますか?</target>
        </trans-unit>
        <trans-unit id="08cf7f142b0ee15a977fe964d0ddcdb1002739ae" translate="yes" xml:space="preserve">
          <source>Where can I get Perl macros for vi?</source>
          <target state="translated">vi用のPerlマクロはどこで入手できますか?</target>
        </trans-unit>
        <trans-unit id="406cbb0495a55956cb84611a8d86c9d721557519" translate="yes" xml:space="preserve">
          <source>Where can I get information on Perl?</source>
          <target state="translated">Perlの情報はどこで手に入りますか?</target>
        </trans-unit>
        <trans-unit id="c63d9dfa4f6d6dcfc8103ea7650db10cd8e27fea" translate="yes" xml:space="preserve">
          <source>Where can I get perl-mode or cperl-mode for emacs?</source>
          <target state="translated">emacsのperl-modeやperl-modeはどこで入手できますか?</target>
        </trans-unit>
        <trans-unit id="b85fdb935a7a614522614b7feed541611e8d0a3e" translate="yes" xml:space="preserve">
          <source>Where can I get the latest libnet release</source>
          <target state="translated">最新の libnet リリースはどこで入手できますか?</target>
        </trans-unit>
        <trans-unit id="f0f1c9d2159564047b740e7956f5640af04f1e3c" translate="yes" xml:space="preserve">
          <source>Where can I learn about CGI or Web programming in Perl?</source>
          <target state="translated">PerlのCGIやWebプログラミングはどこで学べますか?</target>
        </trans-unit>
        <trans-unit id="703366e9bd37f95d6d2b90762995773aff84d67e" translate="yes" xml:space="preserve">
          <source>Where can I learn about linking C with Perl?</source>
          <target state="translated">CとPerlの連携についてはどこで学べますか?</target>
        </trans-unit>
        <trans-unit id="ed8bfc60bd9d8b7923b8341ed07d83afc289bc35" translate="yes" xml:space="preserve">
          <source>Where can I learn about object-oriented Perl programming?</source>
          <target state="translated">オブジェクト指向のPerlプログラミングはどこで学べますか?</target>
        </trans-unit>
        <trans-unit id="210221a52d88064b34135e9105ebfd5d49152b00" translate="yes" xml:space="preserve">
          <source>Where can I post questions?</source>
          <target state="translated">質問はどこに投稿できますか?</target>
        </trans-unit>
        <trans-unit id="34466094d5547ae836abe0422810851106c8e987" translate="yes" xml:space="preserve">
          <source>Where do I get the include files to do ioctl() or syscall()?</source>
          <target state="translated">ioctl()や syscall()を実行するためのインクルードファイルはどこにありますか?</target>
        </trans-unit>
        <trans-unit id="ae774b74efc34a0e83321577caf18754079572a2" translate="yes" xml:space="preserve">
          <source>Where do I send bug reports?</source>
          <target state="translated">バグレポートはどこに送ればいいですか?</target>
        </trans-unit>
        <trans-unit id="566e06889afcd4a7979069c8b0fd2da4dd9ed19e" translate="yes" xml:space="preserve">
          <source>Where file systems interfaces pass file names in and out of the program we also need care. The trend is for operating systems to use a fixed file encoding that don't actually depend on the locale; and this module determines the most appropriate encoding for file names. The &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module will know this encoding under the name &quot;locale_fs&quot;. For traditional Unix systems this will be an alias to the same encoding as &quot;locale&quot;.</source>
          <target state="translated">ファイルシステムインターフェイスがプログラムの内外でファイル名を渡す場合も、注意が必要です。オペレーティングシステムは、実際にはロケールに依存しない固定ファイルエンコーディングを使用する傾向があります。このモジュールは、ファイル名の最も適切なエンコーディングを決定します。&lt;a href=&quot;encode&quot;&gt;エンコード&lt;/a&gt;モジュールは、名称「locale_fs」の下で、このエンコーディングを知っています。従来のUnixシステムの場合、これは「ロケール」と同じエンコーディングのエイリアスになります。</target>
        </trans-unit>
        <trans-unit id="93218aab454721cc4e38fe91ac1668248deeae63" translate="yes" xml:space="preserve">
          <source>Where is the implementation?</source>
          <target state="translated">どこに実装されているのか?</target>
        </trans-unit>
        <trans-unit id="8a78c0649556030e4985847b409471ca9ebd9274" translate="yes" xml:space="preserve">
          <source>Where people get into trouble is here:</source>
          <target state="translated">人が困るところは、ここにあります。</target>
        </trans-unit>
        <trans-unit id="f616a42d8ce8b58cf95a9bfc5e5383c6c84dc620" translate="yes" xml:space="preserve">
          <source>Where prereqs are concerned, if META_MERGE is used, prerequisites are merged with their counterpart &lt;code&gt;WriteMakefile()&lt;/code&gt; argument (PREREQ_PM is merged into {prereqs}{runtime}{requires}, BUILD_REQUIRES into &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; , CONFIGURE_REQUIRES into &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; , and TEST_REQUIRES into &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; . When prereqs are specified with META_ADD, the only prerequisites added to the file come from the metadata, not &lt;code&gt;WriteMakefile()&lt;/code&gt; arguments.</source>
          <target state="translated">前提条件が関係している場合、META_MERGEを使用すると、前提条件は対応する &lt;code&gt;WriteMakefile()&lt;/code&gt; 引数とマージされます（PREREQ_PMは{prereqs} {runtime} {requires}にマージされ、BUILD_REQUIRESは &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; に、CONFIGURE_REQUIRESは &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; とTEST_REQUIRESを &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; に入れます。前提条件がMETA_ADDで指定されている場合、ファイルに追加される唯一の前提条件は、 &lt;code&gt;WriteMakefile()&lt;/code&gt; 引数ではなくメタデータから取得されます。</target>
        </trans-unit>
        <trans-unit id="9262bb4032137f4bd07b4f1a031c40996bf22f95" translate="yes" xml:space="preserve">
          <source>Where prereqs are concerned, if META_MERGE is used, prerequisites are merged with their counterpart &lt;code&gt;WriteMakefile()&lt;/code&gt; argument (PREREQ_PM is merged into {prereqs}{runtime}{requires}, BUILD_REQUIRES into &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt;, CONFIGURE_REQUIRES into &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt;, and TEST_REQUIRES into &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt;. When prereqs are specified with META_ADD, the only prerequisites added to the file come from the metadata, not &lt;code&gt;WriteMakefile()&lt;/code&gt; arguments.</source>
          <target state="translated">前提条件が関係する場合、META_MERGEが使用されると、前提条件は対応する &lt;code&gt;WriteMakefile()&lt;/code&gt; 引数とマージされます（PREREQ_PMは{prereqs} {runtime} {requires}にマージされ、BUILD_REQUIRESは &lt;code&gt;{prereqs}{build}{requires}&lt;/code&gt; にマージされ、CONFIGURE_REQUIRESは &lt;code&gt;{prereqs}{configure}{requires}&lt;/code&gt; 、およびTEST_REQUIRESを &lt;code&gt;{prereqs}{test}{requires})&lt;/code&gt; に。 META_ADDで前提条件が指定されている場合、ファイルに追加される前提条件は、 &lt;code&gt;WriteMakefile()&lt;/code&gt; 引数ではなく、メタデータからのみです。</target>
        </trans-unit>
        <trans-unit id="2578ad2cf7eb4212c4c2f76a99c66a64a699a6f4" translate="yes" xml:space="preserve">
          <source>Where the $way is a value from zero ($theta0, $phi0) to one ($theta1, $phi1). Note that antipodal points (where their distance is</source>
          <target state="translated">ここで、$way は、0 ($theta0,$phi0)から 1 ($theta1,$phi1)までの値です。対蹠点(その距離が</target>
        </trans-unit>
        <trans-unit id="fd6d6e78410be236f0ee8b2e37126d4a25f62f65" translate="yes" xml:space="preserve">
          <source>Where the 'DSLIP' characters have the following meanings:</source>
          <target state="translated">ここで、「DSLIP」文字は以下の意味を持つ。</target>
        </trans-unit>
        <trans-unit id="843828ced3164063fc4c650d4b6af29aa8f9cb2c" translate="yes" xml:space="preserve">
          <source>Where the two must be separate, initially set the type to &lt;code&gt;CXt_NULL&lt;/code&gt; or &lt;code&gt;CXt_BLOCK&lt;/code&gt;, and later change it to &lt;code&gt;CXt_foo&lt;/code&gt; when doing the &lt;code&gt;cx_pushfoo&lt;/code&gt;. This is exactly what &lt;code&gt;pp_enteriter&lt;/code&gt; does, once it's determined which type of loop it's pushing.</source>
          <target state="translated">二つは別々でなければならない場合には、当初のタイプを設定し &lt;code&gt;CXt_NULL&lt;/code&gt; または &lt;code&gt;CXt_BLOCK&lt;/code&gt; 、以降に変更し &lt;code&gt;CXt_foo&lt;/code&gt; 行う際 &lt;code&gt;cx_pushfoo&lt;/code&gt; を。プッシュしているループのタイプが決定されると、これはまさに &lt;code&gt;pp_enteriter&lt;/code&gt; が行うことです。</target>
        </trans-unit>
        <trans-unit id="3a57b05d69f49e2636c91eefc4c6774814129e12" translate="yes" xml:space="preserve">
          <source>Where there is only one operand (or only one operand with overloading) the checks in respect of the other operand above are skipped.</source>
          <target state="translated">オペランドが1つしかない場合(またはオーバーロードされたオペランドが1つしかない場合)、上記の他のオペランドに関するチェックはスキップされます。</target>
        </trans-unit>
        <trans-unit id="293c942f397777e729937e1824d906951d88e087" translate="yes" xml:space="preserve">
          <source>Where these steps occur in the actual execution of a perl program is determined by whether the pattern involves interpolating any string variables. If interpolation occurs, then compilation happens at run time. If it does not, then compilation is performed at compile time. (The &lt;code&gt;/o&lt;/code&gt; modifier changes this, as does &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; to a certain extent.) The engine doesn't really care that much.</source>
          <target state="translated">Perlプログラムの実際の実行でこれらのステップがどこで発生するかは、パターンが文字列変数の補間を含むかどうかによって決まります。補間が行われる場合、コンパイルは実行時に行われます。そうでない場合、コンパイルはコンパイル時に実行されます。（ &lt;code&gt;/o&lt;/code&gt; 修飾子はこれを変更し、 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; ある程度変更します。）エンジンはそれほど気にしません。</target>
        </trans-unit>
        <trans-unit id="eb41b8cee1215605643716ae7b75d6423a86bb03" translate="yes" xml:space="preserve">
          <source>Where these steps occur in the actual execution of a perl program is determined by whether the pattern involves interpolating any string variables. If interpolation occurs, then compilation happens at run time. If it does not, then compilation is performed at compile time. (The &lt;code&gt;/o&lt;/code&gt; modifier changes this, as does &lt;code&gt;qr//&lt;/code&gt; to a certain extent.) The engine doesn't really care that much.</source>
          <target state="translated">これらのステップがperlプログラムの実際の実行で発生する場所は、パターンに文字列変数の補間が含まれるかどうかによって決まります。補間が発生すると、実行時にコンパイルが発生します。そうでない場合は、コンパイル時にコンパイルが実行されます。（ &lt;code&gt;/o&lt;/code&gt; 修飾子は、 &lt;code&gt;qr//&lt;/code&gt; と同様に、これをある程度変更します。）エンジンはそれほど気にしません。</target>
        </trans-unit>
        <trans-unit id="cca423190a1a1c785b9d576f8083e40dd5389585" translate="yes" xml:space="preserve">
          <source>Where to Find the Community</source>
          <target state="translated">コミュニティを探す場所</target>
        </trans-unit>
        <trans-unit id="536ef5aba264e8d2aec71ea10430b9efa22dfe0c" translate="yes" xml:space="preserve">
          <source>Where to find the perlfaq</source>
          <target state="translated">perlfaqを探す場所</target>
        </trans-unit>
        <trans-unit id="93683b8b8083dba6e071465301ae1d1c45028dec" translate="yes" xml:space="preserve">
          <source>Where to get this document</source>
          <target state="translated">このドキュメントの入手先</target>
        </trans-unit>
        <trans-unit id="4af9617f74f3fb16e775a0d165421fe00441bc1b" translate="yes" xml:space="preserve">
          <source>Where to start?</source>
          <target state="translated">何から始めればいいの?</target>
        </trans-unit>
        <trans-unit id="74e10717c102dd0c9df4c18b5606b9aaf6912d10" translate="yes" xml:space="preserve">
          <source>Where you look to find a pointer to information somewhere else. (See &lt;b&gt;indirection&lt;/b&gt;.) References come in two flavors: &lt;b&gt;symbolic references&lt;/b&gt; and &lt;b&gt;hard references&lt;/b&gt;.</source>
          <target state="translated">他の場所への情報へのポインタを探す場所。（&lt;b&gt;間接&lt;/b&gt;参照を参照してください。）参照には、&lt;b&gt;シンボリック参照&lt;/b&gt;と&lt;b&gt;ハード参照の&lt;/b&gt; 2種類があり&lt;b&gt;ます&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="500583f76e5e2a57eb1022812ab875f23db70975" translate="yes" xml:space="preserve">
          <source>Where's the catch? Padding is neither required before the first field &lt;code&gt;count&lt;/code&gt; , nor between this and the next field &lt;code&gt;glyph&lt;/code&gt; , so why can't we simply pack like this:</source>
          <target state="translated">キャッチはどこですか？最初のフィールド &lt;code&gt;count&lt;/code&gt; 前や、このフィールド &lt;code&gt;glyph&lt;/code&gt; と次のフィールドグリフの間にパディングは必要ないので、次のように単純にパックできないのはなぜですか。</target>
        </trans-unit>
        <trans-unit id="2bdd0a720834494322577f4ab7718daee200802f" translate="yes" xml:space="preserve">
          <source>Where's the catch? Padding is neither required before the first field &lt;code&gt;count&lt;/code&gt;, nor between this and the next field &lt;code&gt;glyph&lt;/code&gt;, so why can't we simply pack like this:</source>
          <target state="translated">キャッチはどこですか？最初のフィールド &lt;code&gt;count&lt;/code&gt; 前にも、このフィールド &lt;code&gt;glyph&lt;/code&gt; と次のフィールドグリフの間にもパディングは必要ありません。したがって、次のように単純にパックできないのはなぜですか。</target>
        </trans-unit>
        <trans-unit id="85ff01499d11ce21062a9b96027ab58ee226aad3" translate="yes" xml:space="preserve">
          <source>Where,</source>
          <target state="translated">Where,</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="4d453f1163fdbba0e62b8cfe55db1c43bd938110" translate="yes" xml:space="preserve">
          <source>Whereas a QP decoder that works on both ASCII and EBCDIC platforms would look somewhat like the following:</source>
          <target state="translated">一方、ASCII と EBCDIC の両方のプラットフォームで動作する QP デコーダは、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="4c1007108b497a2f8b15b3dc9255f03fbd82a20c" translate="yes" xml:space="preserve">
          <source>Whereas here's how a Perl programmer more comfortable with the idiom might do it:</source>
          <target state="translated">一方、ここでは、このイディオムに慣れたPerlプログラマがどのようにそれを行うかを説明します。</target>
        </trans-unit>
        <trans-unit id="5db7dff8fd1589f3c435af6d45d16e0816b2e9c4" translate="yes" xml:space="preserve">
          <source>Whereas if you comment out the two lines I said you might wish to, then it shows it to you this way instead:</source>
          <target state="translated">私が言った2行をコメントアウトすると、その代わりにこのように表示されます。</target>
        </trans-unit>
        <trans-unit id="ab440f8d11b8fd4e9e75cd6104ac553e6f04002a" translate="yes" xml:space="preserve">
          <source>Whereas other perl internal stacks store individual items all of the same type (usually SV pointers or integers), the items pushed to the save stack are formed of many different types, having multiple fields to them. For example, the &lt;code&gt;SAVEt_INT&lt;/code&gt; type needs to store both the address of the &lt;code&gt;int&lt;/code&gt; variable to restore, and the value to restore it to. This information could have been stored using fields of a &lt;code&gt;struct&lt;/code&gt;, but would have to be large enough to store three pointers in the largest case, which would waste a lot of space in most of the smaller cases.</source>
          <target state="translated">他のperl内部スタックはすべて同じタイプ（通常はSVポインターまたは整数）の個々のアイテムを格納しますが、保存スタックにプッシュされるアイテムは多くの異なるタイプで形成され、複数のフィールドがあります。たとえば、 &lt;code&gt;SAVEt_INT&lt;/code&gt; タイプは、復元する &lt;code&gt;int&lt;/code&gt; 変数のアドレスと、復元先の値の両方を格納する必要があります。この情報は、 &lt;code&gt;struct&lt;/code&gt; フィールドを使用して格納できますが、最大のケースでは3つのポインタを格納するのに十分な大きさである必要があり、ほとんどの小さいケースでは多くのスペースを浪費します。</target>
        </trans-unit>
        <trans-unit id="aa7a6da1ef7f2699440e362142ae5565af060786" translate="yes" xml:space="preserve">
          <source>Wherever a list of operators can be given you can use one or more opsets. See also Manipulating Opsets below.</source>
          <target state="translated">演算子のリストが与えられる場合はどこでも、1つ以上の演算子を使用することができます。後述のオペセットの操作も参照してください。</target>
        </trans-unit>
        <trans-unit id="c457c17dce216494419135c71949242b8d09d0bb" translate="yes" xml:space="preserve">
          <source>Wherever possible, shareable images are preferred to object libraries, and object libraries to plain object files. In accordance with VMS naming conventions, ext() looks for files named</source>
          <target state="translated">可能な限り、オブジェクトライブラリよりも共有可能な画像を、オブジェクトライブラリよりもプレーンなオブジェクトファイルを優先します。VMS の命名規則に従って、ext()は</target>
        </trans-unit>
        <trans-unit id="a5ce0b5c076605e513279f0c54d153294cc237e9" translate="yes" xml:space="preserve">
          <source>Whether PadnamePV is in UTF-8. Currently, this is always true.</source>
          <target state="translated">PadnamePVがUTF-8であるかどうか。現在、これは常にtrueです。</target>
        </trans-unit>
        <trans-unit id="60f21be64cee3c558562d0924a678b1007587a17" translate="yes" xml:space="preserve">
          <source>Whether PadnamePV is in UTF8. Currently, this is always true.</source>
          <target state="translated">PadnamePVがUTF8かどうか。現在、これは常にtrueです。</target>
        </trans-unit>
        <trans-unit id="0971615da14029bdca88814940e8de90b6be5147" translate="yes" xml:space="preserve">
          <source>Whether a &quot;signaling&quot; NaN is in any way different from a &quot;quiet&quot; NaN, depends on the platform. Also note that the payload of the default NaN (no argument to nan()) is not necessarily zero, use &lt;code&gt;setpayload&lt;/code&gt; to explicitly set the payload. On some platforms like the 32-bit x86, (unless using the 80-bit long doubles) the signaling bit is not supported at all.</source>
          <target state="translated">「シグナリング」NaNが「静かな」NaNと何らかの形で異なるかどうかは、プラットフォームによって異なります。また、デフォルトのNaN（nan（）への引数なし）のペイロードは必ずしもゼロではないことに &lt;code&gt;setpayload&lt;/code&gt; してください。ペイロードを明示的に設定するには、setpayloadを使用してください。32ビットx86などの一部のプラットフォームでは（80ビットのlong doubleを使用しない限り）、シグナリングビットはまったくサポートされていません。</target>
        </trans-unit>
        <trans-unit id="63b3304921bf73755f27746fb53954b4a8c4de93" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is disabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;require_order&lt;/code&gt; is enabled.</source>
          <target state="translated">コマンドライン引数をオプションと混合できるかどうか。環境変数POSIXLY_CORRECTが設定されていない限り、デフォルトは無効です。この場合、 &lt;code&gt;require_order&lt;/code&gt; が有効になります。</target>
        </trans-unit>
        <trans-unit id="faea90df33f36630a481da4cad34e4c79bf52fc5" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;permute&lt;/code&gt; is disabled. Note that &lt;code&gt;permute&lt;/code&gt; is the opposite of &lt;code&gt;require_order&lt;/code&gt; .</source>
          <target state="translated">コマンドライン引数をオプションと混合できるかどうか。環境変数POSIXLY_CORRECTが設定されていない限り、デフォルトは有効です。この場合、 &lt;code&gt;permute&lt;/code&gt; は無効になります。 &lt;code&gt;permute&lt;/code&gt; は &lt;code&gt;require_order&lt;/code&gt; の逆であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7872b2f4a897e4a8ef1ea13c927afbc5f8e9bb5d" translate="yes" xml:space="preserve">
          <source>Whether command line arguments are allowed to be mixed with options. Default is enabled unless environment variable POSIXLY_CORRECT has been set, in which case &lt;code&gt;permute&lt;/code&gt; is disabled. Note that &lt;code&gt;permute&lt;/code&gt; is the opposite of &lt;code&gt;require_order&lt;/code&gt;.</source>
          <target state="translated">コマンドライン引数をオプションと混在させることができるかどうか。環境変数POSIXLY_CORRECTが設定されていない限り、デフォルトが有効になります。設定されている場合、 &lt;code&gt;permute&lt;/code&gt; は無効になります。 &lt;code&gt;permute&lt;/code&gt; は &lt;code&gt;require_order&lt;/code&gt; の反対であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="457d6cfb1888790c7832bd27b66465f0cdcbd754" translate="yes" xml:space="preserve">
          <source>Whether dtrace accepts -xnolibs. If available we call dtrace -h and dtrace -G with -xnolibs to allow dtrace to run in a jail on FreeBSD.</source>
          <target state="translated">dtrace が -xnolibs を受け入れるかどうか。可能であれば、dtrace -h と dtrace -G を -xnolibs と一緒に呼ぶことで、FreeBSD 上の jail で dtrace を実行できるようにします。</target>
        </trans-unit>
        <trans-unit id="bf16a187d3ac8048da2c0a9f49f8874167f5a83b" translate="yes" xml:space="preserve">
          <source>Whether or not the op has been optimized by the peephole optimizer.</source>
          <target state="translated">オペがのぞき穴オプティマイザによって最適化されているかどうか。</target>
        </trans-unit>
        <trans-unit id="99e430c2678f913bd7c7b93452d560622af7b626" translate="yes" xml:space="preserve">
          <source>Whether or not the test should output numbers. That is, this if true:</source>
          <target state="translated">テストが数値を出力するかどうか。つまり、真であればこれです。</target>
        </trans-unit>
        <trans-unit id="5f8067023624d336e348da355a79650c3095a919" translate="yes" xml:space="preserve">
          <source>Whether or not to be verbose about what it is doing -- it will default to $Module::Load::Conditional::VERBOSE</source>
          <target state="translated">何をしているかについて冗長にするかどうか --デフォルトは $Module::Load::Conditional::VERBOSE になります。</target>
        </trans-unit>
        <trans-unit id="835c4d9838e01fba8d1ac35f378ff2857c3bbf2f" translate="yes" xml:space="preserve">
          <source>Whether sorting is stable by default is an accident of implementation that can change (and has changed) between Perl versions. If stability is important, be sure to say so with a</source>
          <target state="translated">ソートがデフォルトで安定しているかどうかは、Perl のバージョン間で変更される可能性がある (変更されている)実装の事故です。安定性が重要な場合は、必ず</target>
        </trans-unit>
        <trans-unit id="a8f7f78ec0e44e67b9396390cd1ee3bcf0e5e14e" translate="yes" xml:space="preserve">
          <source>Whether this entry belongs to an outer pad. Entries for which this is true are often referred to as 'fake'.</source>
          <target state="translated">このエントリが外側のパッドに属しているかどうか。これが真であるエントリーは、しばしば「偽物」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="6283322d116e1d51f7edcd1ec872a9eed355ceb1" translate="yes" xml:space="preserve">
          <source>Whether this is a &quot;state&quot; variable.</source>
          <target state="translated">これが「状態」変数であるかどうか。</target>
        </trans-unit>
        <trans-unit id="e7034c09da28fdb3d58392534621cc03eebbd14d" translate="yes" xml:space="preserve">
          <source>Whether this is an &quot;our&quot; variable.</source>
          <target state="translated">これが「私たちの」変数であるかどうか。</target>
        </trans-unit>
        <trans-unit id="c084cfe6eeb06cc1ff5160c3c990367fe4946569" translate="yes" xml:space="preserve">
          <source>Whether this type of partition is support under Win32.</source>
          <target state="translated">このタイプのパーティションがWin32でサポートされているかどうか。</target>
        </trans-unit>
        <trans-unit id="8fe93610e6b23e15b98198b34ad48105c383339a" translate="yes" xml:space="preserve">
          <source>Whether to abort printing if debugger signal flag is raised.</source>
          <target state="translated">デバッガシグナルフラグが立った場合に印刷を中止するかどうか。</target>
        </trans-unit>
        <trans-unit id="2985490d3101108f328098168c5a21b3bc3c5a70" translate="yes" xml:space="preserve">
          <source>Whether to add a table-of-contents at the top of each page (called an index for the sake of tradition).</source>
          <target state="translated">各ページの一番上に目次をつけるかどうか(伝統のために索引と呼ばれる</target>
        </trans-unit>
        <trans-unit id="3a911a7e2bce47416920de6f21016acd3029366b" translate="yes" xml:space="preserve">
          <source>Whether to anchor every definition &lt;code&gt;=item&lt;/code&gt; directive. This needs to be enabled if you want to be able to link to specific &lt;code&gt;=item&lt;/code&gt; directives, which are output as &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; elements. Disabled by default.</source>
          <target state="translated">すべての定義を固定するかどうか &lt;code&gt;=item&lt;/code&gt; ディレクティブ。 &lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt; 要素として出力される特定の &lt;code&gt;=item&lt;/code&gt; ディレクティブにリンクできるようにする場合は、これを有効にする必要があります。デフォルトでは無効になっています。</target>
        </trans-unit>
        <trans-unit id="626413839d3d50a20deaaad85828e47d347f236c" translate="yes" xml:space="preserve">
          <source>Whether to call these extended grapheme clusters &quot;characters&quot; depends on your point of view. If you are a programmer, you probably would tend towards seeing each element in the sequences as one unit, or &quot;character&quot;. However from the user's point of view, the whole sequence could be seen as one &quot;character&quot; since that's probably what it looks like in the context of the user's language. In this document, we take the programmer's point of view: one &quot;character&quot; is one Unicode code point.</source>
          <target state="translated">これらの拡張された書記素クラスタを「文字」と呼ぶかどうかは、あなたの視点に依存します。あなたがプログラマーであれば、おそらくシーケンスの各要素を一つの単位、つまり「文字」として見る傾向があるでしょう。しかし、ユーザの視点から見れば、シーケンス全体を1つの「文字」として見ることができるでしょう。この文書では、プログラマの視点から見た場合、1つの「文字」が1つのUnicodeコードポイントになります。</target>
        </trans-unit>
        <trans-unit id="ee66335b9db0c1d5103deb721dc40777dd212c3c" translate="yes" xml:space="preserve">
          <source>Whether to print chars with high bit set in binary or &quot;as is&quot;.</source>
          <target state="translated">バイナリで高ビットが設定されている文字を表示するか、「そのまま」で表示するか。</target>
        </trans-unit>
        <trans-unit id="238ca87137bc56748ce05a002a71d9a6db9c7ebe" translate="yes" xml:space="preserve">
          <source>Whether to print contents of globs.</source>
          <target state="translated">グローブの内容を印刷するかどうか。</target>
        </trans-unit>
        <trans-unit id="d3a12643fc63beef0ef6ccef6dae848daa691587" translate="yes" xml:space="preserve">
          <source>Whether to try to find the subroutine name given the reference.</source>
          <target state="translated">参照元に与えられたサブルーチン名を検索しようとするかどうか。</target>
        </trans-unit>
        <trans-unit id="bfd0c6dfe7d4e4cba4e02f1a0ab33700dc1c327f" translate="yes" xml:space="preserve">
          <source>Whether to turn every =head1 directive into a link pointing to the top of the page (specifically, the opening body tag).</source>
          <target state="translated">すべての =head1 ディレクティブを、ページの先頭 (具体的には冒頭のボディタグ)を指すリンクにするかどうか。</target>
        </trans-unit>
        <trans-unit id="c12251b6a52be9785616abd5b79f50c9699026bb" translate="yes" xml:space="preserve">
          <source>Whether to update this partition information. This field is not used by &lt;code&gt;IOCTL_DISK_GET_PARTITION_INFO&lt;/code&gt;. For &lt;code&gt;IOCTL_DISK_SET_DRIVE_LAYOUT&lt;/code&gt;, you must set this field to a true value for any partitions you wish to have changed, added, or deleted.</source>
          <target state="translated">このパーティション情報を更新するかどうか。このフィールドは、 &lt;code&gt;IOCTL_DISK_GET_PARTITION_INFO&lt;/code&gt; では使用されません。 &lt;code&gt;IOCTL_DISK_SET_DRIVE_LAYOUT&lt;/code&gt; 、あなたは、変更、追加、または削除していることを望む任意のパーティションに対する真の値にこのフィールドを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="d26288162f4ab8ff9ae48923849befc89334a4a3" translate="yes" xml:space="preserve">
          <source>Whether to write the non-overloaded form of the stringify-overloaded objects.</source>
          <target state="translated">文字列化されたオブジェクトのオーバーロードされていない形式を書くかどうか。</target>
        </trans-unit>
        <trans-unit id="db40c6156e22d6cc6531821dd75bdcb0d45e3842" translate="yes" xml:space="preserve">
          <source>Whether various library calls are thread-safe is outside the control of Perl. Calls often suffering from not being thread-safe include: &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt;, functions fetching user, group and network information (such as &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent()&lt;/a&gt;&lt;/code&gt; and so on), &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt;. In general, calls that depend on some global external state.</source>
          <target state="translated">さまざまなライブラリ呼び出しがスレッドセーフであるかどうかは、Perlの制御外です。スレッドセーフではないことがよくある呼び出しには、 &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; 、ユーザー、グループ、およびネットワーク情報を取得する関数（ &lt;code&gt;&lt;a href=&quot;functions/getgrent&quot;&gt;getgrent()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/gethostent&quot;&gt;gethostent()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/getnetent&quot;&gt;getnetent()&lt;/a&gt;&lt;/code&gt; など）、 &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand()&lt;/a&gt;&lt;/code&gt; 。一般に、いくつかのグローバルな外部状態に依存する呼び出し。</target>
        </trans-unit>
        <trans-unit id="d56e1a6230da252ffdc8d6662ae566d3f6b5ee2f" translate="yes" xml:space="preserve">
          <source>Whether various library calls are thread-safe is outside the control of Perl. Calls often suffering from not being thread-safe include: &lt;code&gt;localtime()&lt;/code&gt;, &lt;code&gt;gmtime()&lt;/code&gt;, functions fetching user, group and network information (such as &lt;code&gt;getgrent()&lt;/code&gt;, &lt;code&gt;gethostent()&lt;/code&gt;, &lt;code&gt;getnetent()&lt;/code&gt; and so on), &lt;code&gt;readdir()&lt;/code&gt;, &lt;code&gt;rand()&lt;/code&gt;, and &lt;code&gt;srand()&lt;/code&gt;. In general, calls that depend on some global external state.</source>
          <target state="translated">さまざまなライブラリ呼び出しがスレッドセーフであるかどうかは、Perlの制御外です。スレッドセーフではないことが多い呼び出しには、 &lt;code&gt;localtime()&lt;/code&gt; 、 &lt;code&gt;gmtime()&lt;/code&gt; 、ユーザー、グループ、ネットワーク情報をフェッチする関数（ &lt;code&gt;getgrent()&lt;/code&gt; 、 &lt;code&gt;gethostent()&lt;/code&gt; 、 &lt;code&gt;getnetent()&lt;/code&gt; など）、 &lt;code&gt;readdir()&lt;/code&gt; 、 &lt;code&gt;rand()&lt;/code&gt; 、および &lt;code&gt;srand()&lt;/code&gt; 。一般に、グローバルな外部状態に依存する呼び出し。</target>
        </trans-unit>
        <trans-unit id="465a32753eace035273aaef17e2c639421b02dff" translate="yes" xml:space="preserve">
          <source>Whether we need to build an object file with the dtrace tool.</source>
          <target state="translated">dtraceツールでオブジェクトファイルを構築する必要があるかどうか。</target>
        </trans-unit>
        <trans-unit id="201246e3611962dc1ed1a9edc779811bfcd3278b" translate="yes" xml:space="preserve">
          <source>Whether you are using NIS does not matter. Amazingly enough, the same bug also affects Solaris.</source>
          <target state="translated">NISを使っているかどうかは関係ありません。驚くべきことに、同じバグが Solaris にも影響を与えています。</target>
        </trans-unit>
        <trans-unit id="f8e039fc339d1036f86bd64ce844762f9417fe8b" translate="yes" xml:space="preserve">
          <source>Whether you use &lt;code&gt;perlbug&lt;/code&gt; or send the email manually, please make your Subject line informative. &quot;a bug&quot; is not informative. Neither is &quot;perl crashes&quot; nor is &quot;HELP!!!&quot;. These don't help. A compact description of what's wrong is fine.</source>
          <target state="translated">&lt;code&gt;perlbug&lt;/code&gt; を使用する場合でも、手動で電子メールを送信する場合でも、件名を参考にしてください。「バグ」は有益ではありません。「perl crashes」でも「HELP !!!」でもありません。これらは役に立ちません。何が悪いのかを簡潔に説明すれば問題ありません。</target>
        </trans-unit>
        <trans-unit id="0cde069a15e713b9fe4a9a6b7078fade7daf5170" translate="yes" xml:space="preserve">
          <source>Whew! That is all the rest of the characters and character classes.</source>
          <target state="translated">ふぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇぇ 残りのキャラとキャラクラスは以上です。</target>
        </trans-unit>
        <trans-unit id="27e5de2ca1964d94a9ea629b708a58094f2d855e" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;Tie::Hash&quot;&gt;Tie::Hash&lt;/a&gt; operation is being performed from the Perl level on &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt;, if any:</source>
          <target state="translated">どの&lt;a href=&quot;Tie::Hash&quot;&gt;タイ::ハッシュ&lt;/a&gt;操作は上のPerlのレベルから実行されている &lt;code&gt;%+&lt;/code&gt; または &lt;code&gt;%+&lt;/code&gt; 、もしあれば：</target>
        </trans-unit>
        <trans-unit id="56043e0fa27cef8d93950adbdc599597748f590d" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; operation is being performed from the Perl level on &lt;code&gt;%+&lt;/code&gt; or &lt;code&gt;%+&lt;/code&gt; , if any:</source>
          <target state="translated">どの&lt;a href=&quot;tie/hash&quot;&gt;タイ::ハッシュ&lt;/a&gt;操作は上のPerlのレベルから実行されている &lt;code&gt;%+&lt;/code&gt; または &lt;code&gt;%+&lt;/code&gt; 、もしあれば：</target>
        </trans-unit>
        <trans-unit id="babf69836d4addec6f5a5308cb5825c678eb405e" translate="yes" xml:space="preserve">
          <source>Which Perl blogs should I read?</source>
          <target state="translated">どのPerlブログを読めばいいのか?</target>
        </trans-unit>
        <trans-unit id="54a12a94c6d59fab4aeefed76c9781df10879a85" translate="yes" xml:space="preserve">
          <source>Which YAML implementation would you prefer?</source>
          <target state="translated">どのYAML実装がいいですか?</target>
        </trans-unit>
        <trans-unit id="88e9358d41b432fbb58126174b7979a4235a746a" translate="yes" xml:space="preserve">
          <source>Which architecture dependent directory?</source>
          <target state="translated">どのアーキテクチャに依存するディレクトリ?</target>
        </trans-unit>
        <trans-unit id="b7506b68ee68fa595a60659e338ae77c9646b01d" translate="yes" xml:space="preserve">
          <source>Which character set modifier is in effect?</source>
          <target state="translated">どの文字セット修飾子が有効になっているか?</target>
        </trans-unit>
        <trans-unit id="ee9b43c6b4875ca7c0a8fea57558205fc2e727ab" translate="yes" xml:space="preserve">
          <source>Which commit added the first file to match this regex?</source>
          <target state="translated">どのコミットがこの正規表現にマッチする最初のファイルを追加しましたか?</target>
        </trans-unit>
        <trans-unit id="d004402710bbe1f74279bca91591607062854495" translate="yes" xml:space="preserve">
          <source>Which commit caused this example code to break?</source>
          <target state="translated">どのコミットがこの例のコードを壊したのでしょうか?</target>
        </trans-unit>
        <trans-unit id="dd77891b19f04e8f4749d5465e616c7d548783ec" translate="yes" xml:space="preserve">
          <source>Which commit caused this example code to start working?</source>
          <target state="translated">この例のコードが動作を開始する原因となったのはどのコミットですか?</target>
        </trans-unit>
        <trans-unit id="e0816de4aeeb375a395f682785a672eb7143a573" translate="yes" xml:space="preserve">
          <source>Which commit removed the last file to match this regex?</source>
          <target state="translated">この正規表現にマッチする最後のファイルを削除したのはどのコミットですか?</target>
        </trans-unit>
        <trans-unit id="dc6d9abe75ea380074d1386fb6bc4638c51ca405" translate="yes" xml:space="preserve">
          <source>Which is checked first, &lt;code&gt;nomethod&lt;/code&gt; or &lt;code&gt;fallback&lt;/code&gt; ? If the two operands of an operator are of different types and both overload the operator, which implementation is used? The following are the precedence rules:</source>
          <target state="translated">最初にチェックされるのは、 &lt;code&gt;nomethod&lt;/code&gt; または &lt;code&gt;fallback&lt;/code&gt; ですか？演算子の2つのオペランドの型が異なり、両方が演算子をオーバーロードする場合、どの実装が使用されますか？優先ルールは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="26892517e1a24be563151c63ed23ba887d7067cd" translate="yes" xml:space="preserve">
          <source>Which is checked first, &lt;code&gt;nomethod&lt;/code&gt; or &lt;code&gt;fallback&lt;/code&gt;? If the two operands of an operator are of different types and both overload the operator, which implementation is used? The following are the precedence rules:</source>
          <target state="translated">最初にチェックされるのは、 &lt;code&gt;nomethod&lt;/code&gt; と &lt;code&gt;fallback&lt;/code&gt; どちらですか？演算子の2つのオペランドが異なるタイプであり、両方が演算子をオーバーロードする場合、どちらの実装が使用されますか？優先ルールは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="2db62588fd2906af96c2fa483b06db407a80424f" translate="yes" xml:space="preserve">
          <source>Which is effectively just:</source>
          <target state="translated">それは事実上、ただの</target>
        </trans-unit>
        <trans-unit id="b3fbe5ee09cb06684cac7d1a3e427f0dd899daef" translate="yes" xml:space="preserve">
          <source>Which is what we might expect, the match finds the only &lt;code&gt;cat&lt;/code&gt; in the string and locks onto it. Consider, however, this regexp:</source>
          <target state="translated">これは私たちが予想することですが、一致は文字列内の唯一の &lt;code&gt;cat&lt;/code&gt; を見つけて、それにロックします。ただし、次の正規表現について考えてみます。</target>
        </trans-unit>
        <trans-unit id="b248b8b60b90917a66aeb94063d05f7d477a94bd" translate="yes" xml:space="preserve">
          <source>Which magazines have Perl content?</source>
          <target state="translated">Perlのコンテンツがある雑誌は?</target>
        </trans-unit>
        <trans-unit id="786c2c13e1b48f509ddfa13fe457e7ade1e2d5c4" translate="yes" xml:space="preserve">
          <source>Which makes $richard and $dick the same variable, but leaves @richard and @dick as separate arrays. Tricky, eh?</source>
          <target state="translated">これで$richardと$dickは同じ変数になりますが、@richardと@dickは別々の配列になります。難しいでしょ?</target>
        </trans-unit>
        <trans-unit id="c62379639a4b05982ed9a5d227696146f851a074" translate="yes" xml:space="preserve">
          <source>Which of the various &lt;code&gt;*OP&lt;/code&gt; structures this op uses. This should be one of the &lt;code&gt;OA_*&lt;/code&gt; constants from</source>
          <target state="translated">このopが使用するさまざまな &lt;code&gt;*OP&lt;/code&gt; 構造。これは、 &lt;code&gt;OA_*&lt;/code&gt; 定数のいずれかである必要があります</target>
        </trans-unit>
        <trans-unit id="a891db1882ed2a728a47d9d75117f36a4ff2a006" translate="yes" xml:space="preserve">
          <source>Which of these modifiers is in effect at any given point in a regular expression depends on a fairly complex set of interactions. These have been designed so that in general you don't have to worry about it, but this section gives the gory details. As explained below in &lt;a href=&quot;#Extended-Patterns&quot;&gt;&quot;Extended Patterns&quot;&lt;/a&gt; it is possible to explicitly specify modifiers that apply only to portions of a regular expression. The innermost always has priority over any outer ones, and one applying to the whole expression has priority over any of the default settings that are described in the remainder of this section.</source>
          <target state="translated">これらの修飾子のどれが正規表現の任意の時点で有効であるかは、かなり複雑な相互作用のセットに依存します。これらは、一般的に心配する必要がないように設計されていますが、このセクションでは、厄介な詳細を説明します。以下の&lt;a href=&quot;#Extended-Patterns&quot;&gt;「拡張パターン」&lt;/a&gt;で説明するように、正規表現の一部にのみ適用される修飾子を明示的に指定することができます。最も内側のものは常に外側のものよりも優先され、式全体に適用されるものは、このセクションの残りの部分で説明するデフォルト設定のいずれよりも優先されます。</target>
        </trans-unit>
        <trans-unit id="9c28a2fc8be0459fa3248ceb80936f8aba82ccd2" translate="yes" xml:space="preserve">
          <source>Which of these modifiers is in effect at any given point in a regular expression depends on a fairly complex set of interactions. These have been designed so that in general you don't have to worry about it, but this section gives the gory details. As explained below in &lt;a href=&quot;#Extended-Patterns&quot;&gt;Extended Patterns&lt;/a&gt; it is possible to explicitly specify modifiers that apply only to portions of a regular expression. The innermost always has priority over any outer ones, and one applying to the whole expression has priority over any of the default settings that are described in the remainder of this section.</source>
          <target state="translated">これらの修飾子のどれが正規表現の任意の時点で有効であるかは、かなり複雑な一連の相互作用に依存します。これらは、一般に心配する必要がないように設計されていますが、このセクションでは詳細を説明します。以下の「&lt;a href=&quot;#Extended-Patterns&quot;&gt;拡張パターン」&lt;/a&gt;で説明するように、正規表現の一部にのみ適用される修飾子を明示的に指定できます。最も内側のものが常に外側のものよりも優先され、式全体に適用されるものは、このセクションの残りの部分で説明されるデフォルト設定のどれよりも優先されます。</target>
        </trans-unit>
        <trans-unit id="3d81e570041b9ef8c3716fd625de2184bc9fcbe4" translate="yes" xml:space="preserve">
          <source>Which one you pick depends on which of these expressions better reflects the above specification of comments.</source>
          <target state="translated">どちらを選ぶかは、これらの表現が上記のコメントの仕様をよりよく反映しているかどうかにかかっています。</target>
        </trans-unit>
        <trans-unit id="79ee8492b912fab00990fc318850246c7ab7a4ba" translate="yes" xml:space="preserve">
          <source>Which perhaps unexpectedly yields:</source>
          <target state="translated">おそらく予想外の結果になるだろう</target>
        </trans-unit>
        <trans-unit id="05c36e4547159a2f896e1c4c828cfe54c70d84ef" translate="yes" xml:space="preserve">
          <source>Which rules apply are determined as described in &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3F&quot;&gt;&quot;Which character set modifier is in effect?&quot; in perlre&lt;/a&gt;.</source>
          <target state="translated">適用されるルールは、&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3F&quot;&gt;「どの文字セット修飾子が有効ですか？」で&lt;/a&gt;説明されているように決定されます。perlreで。</target>
        </trans-unit>
        <trans-unit id="4e550746bad7dcee6b1162b28bf7aedac094cd1e" translate="yes" xml:space="preserve">
          <source>Which rules apply are determined as described in &lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;Which character set modifier is in effect? in perlre&lt;/a&gt;.</source>
          <target state="translated">どの&lt;a href=&quot;perlre#Which-character-set-modifier-is-in-effect%3f&quot;&gt;文字セット修飾子が有効であるかで&lt;/a&gt;説明されているように、どのルールが適用されますか？perlreで。</target>
        </trans-unit>
        <trans-unit id="b4ea6c1227777eb0d0611636fc0f0ce8660134f3" translate="yes" xml:space="preserve">
          <source>Which substring to check first.</source>
          <target state="translated">どの部分文字列を最初にチェックするか。</target>
        </trans-unit>
        <trans-unit id="627f14bbed51912496b6fb85cde41b9d90202d10" translate="yes" xml:space="preserve">
          <source>Which tar should I use on Windows?</source>
          <target state="translated">Windowsではどのtarを使えばいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="2f094ffb275753431ba594c04d0d66a718fa1eda" translate="yes" xml:space="preserve">
          <source>Which text formatter to use. Default is &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt;, or for very old Perl versions &lt;a href=&quot;Pod::PlainText&quot;&gt;Pod::PlainText&lt;/a&gt;. An alternative would be e.g. &lt;a href=&quot;Pod::Text::Termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">使用するテキストフォーマッタ。デフォルトは&lt;a href=&quot;Pod::Text&quot;&gt;Pod :: Text&lt;/a&gt;、または非常に古いPerlバージョンの場合は&lt;a href=&quot;Pod::PlainText&quot;&gt;Pod :: PlainText&lt;/a&gt;です。別の方法は、例えば&lt;a href=&quot;Pod::Text::Termcap&quot;&gt;Pod :: Text :: Termcap&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="4b26c1ae972001db5809b34aeb5a2c0bda11feda" translate="yes" xml:space="preserve">
          <source>Which text formatter to use. Default is &lt;a href=&quot;pod/text&quot;&gt;Pod::Text&lt;/a&gt;, or for very old Perl versions &lt;a href=&quot;pod/plaintext&quot;&gt;Pod::PlainText&lt;/a&gt;. An alternative would be e.g. &lt;a href=&quot;pod/text/termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">使用するテキストフォーマッター。デフォルトは&lt;a href=&quot;pod/text&quot;&gt;Pod :: Text&lt;/a&gt;、または非常に古いPerlバージョンの場合は&lt;a href=&quot;pod/plaintext&quot;&gt;Pod :: PlainText&lt;/a&gt;です。別の例としては、&lt;a href=&quot;pod/text/termcap&quot;&gt;Pod :: Text :: Termcapがあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="9b8afbe233aaf49239a07d2a4536a6d9be415fc8" translate="yes" xml:space="preserve">
          <source>Which version of Perl should I use?</source>
          <target state="translated">どのバージョンのPerlを使えばいいですか?</target>
        </trans-unit>
        <trans-unit id="ed3642f21edcd8b0db0bc9f8cee4ac46473a253a" translate="yes" xml:space="preserve">
          <source>Which version of perl do I need ?</source>
          <target state="translated">どのバージョンのperlが必要ですか?</target>
        </trans-unit>
        <trans-unit id="32a93a6b75c99229f45ca5666bf0720d67cc2e24" translate="yes" xml:space="preserve">
          <source>Which version of perl should I use?</source>
          <target state="translated">どのバージョンのperlを使えばいいですか?</target>
        </trans-unit>
        <trans-unit id="7631d79fe8017e212e81e096dcea8cb82517cdbf" translate="yes" xml:space="preserve">
          <source>Which web framework should I use?</source>
          <target state="translated">どのWebフレームワークを使えばいいですか?</target>
        </trans-unit>
        <trans-unit id="ca95e2a8ef78e8e65dfe2ee661d1738206c25df7" translate="yes" xml:space="preserve">
          <source>Which will create the directory we need, and you can move on to the next step.</source>
          <target state="translated">これで必要なディレクトリが作成され、次のステップに進むことができます。</target>
        </trans-unit>
        <trans-unit id="1bd7ff93be76f4f655ab909493a6705c72660d9c" translate="yes" xml:space="preserve">
          <source>Which will print</source>
          <target state="translated">どちらが印刷されますか?</target>
        </trans-unit>
        <trans-unit id="03d7614f12de55df0b888753d3fa1d0fb28069d7" translate="yes" xml:space="preserve">
          <source>Which would attempt to set breakpoints on lines 4 and 6 immediately after debugger initialization. Note that @DB::typeahead is not a supported interface and is subject to change in future releases.</source>
          <target state="translated">これは、デバッガの初期化直後の 4 行目と 6 行目にブレークポイントを設定しようとします。DB::typeahead はサポートされているインターフェイスではなく、将来のリリースで変更される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="c966532947a1e874f5fbb5570050ef3e1254690b" translate="yes" xml:space="preserve">
          <source>Which would generate a format looking something like this:</source>
          <target state="translated">このようなフォーマットを生成します。</target>
        </trans-unit>
        <trans-unit id="d885d5ead32cef5d0d07c15652290de0ab57655a" translate="yes" xml:space="preserve">
          <source>Which zip should I use on Windows for '[ndg]make zipdist'?</source>
          <target state="translated">Windowsで'ndg]make zipdist'を実行するには、どのzipを使えばいいですか?</target>
        </trans-unit>
        <trans-unit id="91c0db76a3c1130f40e63caacba5a278833ffb99" translate="yes" xml:space="preserve">
          <source>Which, in the degenerate case of using only ordinary arrays, gives you multidimensional arrays just like C's:</source>
          <target state="translated">これは,通常の配列だけを使う退化したケースでは,Cの配列と同じように多次元配列が得られます.</target>
        </trans-unit>
        <trans-unit id="49233da44986d650dd0c62f9412171689ae74192" translate="yes" xml:space="preserve">
          <source>Whichever version is used, the actual methods are called in the same context (list, scalar, or void) as the original call via &lt;code&gt;EVERY&lt;/code&gt; , and return:</source>
          <target state="translated">どちらのバージョンを使用しても、実際のメソッドは、 &lt;code&gt;EVERY&lt;/code&gt; を介した元の呼び出しと同じコンテキスト（リスト、スカラー、またはvoid）で呼び出され、次を返します。</target>
        </trans-unit>
        <trans-unit id="07d57e57f3a8ced4fc446692cf92ed5425c3284f" translate="yes" xml:space="preserve">
          <source>Whichever version is used, the actual methods are called in the same context (list, scalar, or void) as the original call via &lt;code&gt;EVERY&lt;/code&gt;, and return:</source>
          <target state="translated">どちらのバージョンが使用されても、実際のメソッドは、 &lt;code&gt;EVERY&lt;/code&gt; を介した元の呼び出しと同じコンテキスト（リスト、スカラー、またはvoid）で呼び出され、次を返します。</target>
        </trans-unit>
        <trans-unit id="fed29deaf6c9f70efd08af26605d88141ad2586b" translate="yes" xml:space="preserve">
          <source>While $FORMAT_TOP_NAME contains the name of the current header format, there is no corresponding mechanism to automatically do the same thing for a footer. Not knowing how big a format is going to be until you evaluate it is one of the major problems. It's on the TODO list.</source>
          <target state="translated">format_top_nameには現在のヘッダフォーマットの名前が含まれていますが、フッタに対して同じことを自動的に行う対応する仕組みはありません。評価するまでフォーマットがどのくらいの大きさになるのかわからないのは、大きな問題の一つです。これはTODOリストにあります。</target>
        </trans-unit>
        <trans-unit id="b0cd08c49ca70b961592a79d7ad5531909d37f26" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; provides integer-only arithmetic, there is no analogous mechanism to provide automatic rounding or truncation to a certain number of decimal places. For rounding to a certain number of digits, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; is usually the easiest route. See &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;.</source>
          <target state="translated">ながら &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; 整数のみの演算提供、小数点以下の特定の番号に自動的に丸めまたは切り捨てを提供するいかなる類似のメカニズムは存在しません。特定の桁数に丸めるには、通常、 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf()&lt;/a&gt;&lt;/code&gt; が最も簡単な方法です。&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="01f836f2c1198b05b58549da2eae8767a49ca6a1" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;STORABLE_freeze&lt;/code&gt; and &lt;code&gt;STORABLE_thaw&lt;/code&gt; are useful for classes where each instance is independent, this mechanism has difficulty (or is incompatible) with objects that exist as common process-level or system-level resources, such as singleton objects, database pools, caches or memoized objects.</source>
          <target state="translated">ながら &lt;code&gt;STORABLE_freeze&lt;/code&gt; と &lt;code&gt;STORABLE_thaw&lt;/code&gt; が各インスタンスは独立しているクラスのために有用である、このメカニズムは困難である（または互換性がない）そのようなシングルトン・オブジェクト、データベース・プール、キャッシュまたはメモ化オブジェクトなどの一般的なプロセスレベル又はシステムレベルのリソースとして存在するオブジェクトと。</target>
        </trans-unit>
        <trans-unit id="d9b242bc936842344ffd618aab5876b2850c2c1b" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;connect&lt;/code&gt; returns false, the value of &lt;code&gt;$!&lt;/code&gt; indicates whether it should be tried again (by being set to the value &lt;code&gt;EINPROGRESS&lt;/code&gt;, or &lt;code&gt;EWOULDBLOCK&lt;/code&gt; on MSWin32), or whether a permanent error has occurred (e.g. &lt;code&gt;ECONNREFUSED&lt;/code&gt;).</source>
          <target state="translated">しばらく &lt;code&gt;connect&lt;/code&gt; falseを返し、値 &lt;code&gt;$!&lt;/code&gt; 再試行する必要があるかどうか（値 &lt;code&gt;EINPROGRESS&lt;/code&gt; 、またはMSWin32では &lt;code&gt;EWOULDBLOCK&lt;/code&gt; に設定することにより）、または永続的なエラーが発生したかどうか（ &lt;code&gt;ECONNREFUSED&lt;/code&gt; など）を示します。</target>
        </trans-unit>
        <trans-unit id="b9a9af13c711e35bbea687932bfa0e243bef5296" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;s///&lt;/code&gt; accepts the &lt;code&gt;/c&lt;/code&gt; flag, it has no effect beyond producing a warning if warnings are enabled.</source>
          <target state="translated">一方で &lt;code&gt;s///&lt;/code&gt; 受け入れる &lt;code&gt;/c&lt;/code&gt; フラグが、それは警告が有効になっている場合に警告を生成超えても効果はありません。</target>
        </trans-unit>
        <trans-unit id="b8eb5c19a610d348554e2fa519e5457ab307a063" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;use integer&lt;/code&gt; provides integer-only arithmetic, there is no analogous mechanism to provide automatic rounding or truncation to a certain number of decimal places. For rounding to a certain number of digits, &lt;code&gt;sprintf()&lt;/code&gt; or &lt;code&gt;printf()&lt;/code&gt; is usually the easiest route. See &lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;use integer&lt;/code&gt; を使用すると整数のみの算術演算が提供されますが、特定の小数点以下の桁数に自動丸めまたは切り捨てを提供する類似のメカニズムはありません。特定の桁数に丸めるには、通常、 &lt;code&gt;sprintf()&lt;/code&gt; または &lt;code&gt;printf()&lt;/code&gt; が最も簡単なルートです。&lt;a href=&quot;perlfaq4&quot;&gt;perlfaq4を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4a400d769e405e7503768315d8de6e5c08fa4438" translate="yes" xml:space="preserve">
          <source>While B::Deparse goes to some lengths to try to figure out what your original program was doing, some parts of the language can still trip it up; it still fails even on some parts of Perl's own test suite. If you encounter a failure other than the most common ones described in the BUGS section below, you can help contribute to B::Deparse's ongoing development by submitting a bug report with a small example.</source>
          <target state="translated">B::Deparseは元のプログラムが何をしていたのかを理解しようとするためにある程度の努力をしているが、言語のいくつかの部分では失敗する可能性がある。以下のBUGSセクションで説明されている最も一般的なもの以外の失敗に遭遇した場合は、小さな例を挙げてバグレポートを提出することで、B::Deparseの継続的な開発に貢献することができます。</target>
        </trans-unit>
        <trans-unit id="1fb4e05a5830c846a9dc5981bceec998799ac3ed" translate="yes" xml:space="preserve">
          <source>While BigInt has extensive handling of inf and NaN, certain quirks remain.</source>
          <target state="translated">BigIntはinfとNaNを広範囲に扱っていますが、ある種の癖が残っています。</target>
        </trans-unit>
        <trans-unit id="fd702ed1f93515e973caeb556144e84284909d1e" translate="yes" xml:space="preserve">
          <source>While C guarantees the ordering specified in the struct definition, between different platforms the definitions might differ</source>
          <target state="translated">C は構造体の定義で指定された順序を保証していますが、異なるプラットフォーム間では定義が異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="cc4691f27fe5f793a7b1a252b87e1f8adf7ae71b" translate="yes" xml:space="preserve">
          <source>While Dan Kogai retains the copyright as a maintainer, credit should go to all those involved. See AUTHORS for a list of those who submitted code to the project.</source>
          <target state="translated">Dan Kogaiはメンテナとしての著作権を保持していますが、クレジットはすべての関係者に帰属します。プロジェクトにコードを提出した人のリストはAUTHORSを参照してください。</target>
        </trans-unit>
        <trans-unit id="5c4e91143f9c9ac2ab71808110a8709426a9bc1f" translate="yes" xml:space="preserve">
          <source>While Google doesn't provide a native toolchain for Android, you can still get one from the Play Store.</source>
          <target state="translated">GoogleはAndroid用のネイティブツールチェーンを提供していませんが、Playストアから入手することは可能です。</target>
        </trans-unit>
        <trans-unit id="c1a13f1442da82f36b90f68d9debc0cec8f1fff2" translate="yes" xml:space="preserve">
          <source>While Math::BigInt has extensive handling of inf and NaN, certain quirks remain.</source>
          <target state="translated">Math::BigInt は inf と NaN を広範囲に扱っていますが、特定の癖が残っています。</target>
        </trans-unit>
        <trans-unit id="e79628255662d7502ebd0e9fa4c3c1aca53d77c4" translate="yes" xml:space="preserve">
          <source>While Perl attempts to keep the vaxc$errno value to be current, if errno is not EVMSERR, it may not be from the current operation.</source>
          <target state="translated">Perl は vaxc$errno の値を現在のものにしようとしますが、 errno が EVMSERR でない場合は、現在の操作ではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="82ff355555ab6d2ce0a2840754c6edfffe9b0329" translate="yes" xml:space="preserve">
          <source>While Perl passes arguments to functions by reference, C passes arguments by value; to implement a C function which modifies data of one of the &quot;arguments&quot;, the actual argument of this C function would be a pointer to the data. Thus two C functions with declarations</source>
          <target state="translated">Perlが参照によって関数に引数を渡すのに対し、C言語は値によって引数を渡します。「引数」の1つのデータを変更するC言語の関数を実装するには、このC言語の関数の実際の引数はデータへのポインタになります。したがって、次のような宣言を持つ2つのC関数があります。</target>
        </trans-unit>
        <trans-unit id="c23f9c83568988309005d4ebe9f3a7a4c7b974ed" translate="yes" xml:space="preserve">
          <source>While System V IPC isn't so widely used as sockets, it still has some interesting uses. However, you cannot use SysV IPC or Berkeley mmap() to have a variable shared amongst several processes. That's because Perl would reallocate your string when you weren't wanting it to. You might look into the &lt;code&gt;IPC::Shareable&lt;/code&gt; or &lt;code&gt;threads::shared&lt;/code&gt; modules for that.</source>
          <target state="translated">System V IPCはソケットとしてそれほど広く使用されていませんが、それでも興味深い用途がいくつかあります。ただし、SysV IPCまたはBerkeley mmap（）を使用して、複数のプロセス間で変数を共有することはできません。これは、Perlが望まないときに文字列を再割り当てするためです。そのためには、 &lt;code&gt;IPC::Shareable&lt;/code&gt; または &lt;code&gt;threads::shared&lt;/code&gt; モジュールを調べる必要があります。</target>
        </trans-unit>
        <trans-unit id="95ba383e6ad59d1d5877dab883127e0598dee045" translate="yes" xml:space="preserve">
          <source>While a nice extension, it's not portable. The Perl code does admittedly use them if available to gain some extra speed (essentially as a funky form of inlining), but you shouldn't.</source>
          <target state="translated">素晴らしい拡張機能ですが、移植性はありません。Perl のコードでは、速度を向上させるために (基本的にはインライン化のファンキーな形式として)利用可能な場合にはそれを使用していますが、使用すべきではありません。</target>
        </trans-unit>
        <trans-unit id="98ac33662fa3d3f638b9cfcc69effe66a6af5d40" translate="yes" xml:space="preserve">
          <source>While a search is in progress, the progress object's &lt;code&gt;reach&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; methods are called like this:</source>
          <target state="translated">検索の進行中、progressオブジェクトの &lt;code&gt;reach&lt;/code&gt; および &lt;code&gt;done&lt;/code&gt; メソッドは次のように呼び出されます：</target>
        </trans-unit>
        <trans-unit id="5af2731519a4e72226e3efaa5ed68cb8f21ac8fa" translate="yes" xml:space="preserve">
          <source>While apparently a whole nuther program,</source>
          <target state="translated">どうやら全く別のプログラムのようだが</target>
        </trans-unit>
        <trans-unit id="2192d44f9e946df5ee1f8628bb7cf84591b693e7" translate="yes" xml:space="preserve">
          <source>While building Perl some changes may be necessary to your Cygwin setup so that Perl builds cleanly. These changes are &lt;b&gt;not&lt;/b&gt; required for normal Perl usage.</source>
          <target state="translated">Perlをビルドしている間、Perlをきれいにビルドするために、Cygwinセットアップにいくつかの変更が必要になる場合があります。これらの変更は、Perlの通常の使用に&lt;b&gt;は&lt;/b&gt;必要あり&lt;b&gt;ません&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="917e67f81e56107e856d601af96f9ace961e9a9a" translate="yes" xml:space="preserve">
          <source>While checking, this module collects document properties, e.g. the nodes for hyperlinks (&lt;code&gt;=headX&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; ) and index entries (&lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ). POD translators can use this feature to syntax-check and get the nodes in a first pass before actually starting to convert. This is expensive in terms of execution time, but allows for very robust conversions.</source>
          <target state="translated">チェック中、このモジュールはドキュメントのプロパティ、たとえばハイパーリンクのノード（ &lt;code&gt;=headX&lt;/code&gt; 、 &lt;code&gt;=item&lt;/code&gt; ）とインデックスエントリ（ &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ）を収集します。PODトランスレータはこの機能を使用して構文チェックを行い、実際に変換を開始する前の最初のパスでノードを取得できます。これは実行時間の点でコストがかかりますが、非常に堅牢な変換が可能です。</target>
        </trans-unit>
        <trans-unit id="0b363ec28aa87cd5d2d84a791b40d48ed17d175f" translate="yes" xml:space="preserve">
          <source>While checking, this module collects document properties, e.g. the nodes for hyperlinks (&lt;code&gt;=headX&lt;/code&gt;, &lt;code&gt;=item&lt;/code&gt;) and index entries (&lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt;). POD translators can use this feature to syntax-check and get the nodes in a first pass before actually starting to convert. This is expensive in terms of execution time, but allows for very robust conversions.</source>
          <target state="translated">このモジュールは、チェック中に、ドキュメントのプロパティ（ハイパーリンクのノード（ &lt;code&gt;=headX&lt;/code&gt; 、 &lt;code&gt;=item&lt;/code&gt; ）やインデックスエントリ（ &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; ）など）を収集します。PODトランスレータは、この機能を使用して、実際に変換を開始する前に、最初のパスでノードの構文チェックと取得を行うことができます。これは実行時間の点でコストがかかりますが、非常に堅牢な変換が可能になります。</target>
        </trans-unit>
        <trans-unit id="ba738010d28065fd95a055094f45e1d958083828" translate="yes" xml:space="preserve">
          <source>While civility is required, kindness is encouraged; if you have any doubt about whether you are being civil, simply ask yourself, &quot;Am I being kind?&quot; and aspire to that.</source>
          <target state="translated">礼節は必要ですが、親切は奨励されています。自分が礼節を守っているかどうか疑問がある場合は、「私は親切にしているか」と自問し、それを目指しましょう。</target>
        </trans-unit>
        <trans-unit id="c337ad00b019970748effb87047bdf42ffb16bea" translate="yes" xml:space="preserve">
          <source>While experts may argue about these idioms, a novice to Perl guts may prefer a way which is as little Perl-guts-specific as possible, meaning automatic conversion and automatic call generation, as in &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;&quot;Getting the fat out of XSUBs&quot;&lt;/a&gt;. This approach has the additional benefit of protecting the XSUB writer from future changes to the Perl API.</source>
          <target state="translated">専門家はこれらのイディオムについて議論するかもしれませんが、Perlガッツの初心者は、&lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;「XSUBから脂肪を取り除く」の&lt;/a&gt;ように、Perlガッツ固有の方法をできるだけ少なくすることを好むかもしれません。つまり、自動変換と自動呼び出し生成を意味します。このアプローチには、PerlAPIへの将来の変更からXSUBライターを保護するという追加の利点があります。</target>
        </trans-unit>
        <trans-unit id="6234d5fa2f6fac6ddbcf991bea921371b64250cc" translate="yes" xml:space="preserve">
          <source>While experts may argue about these idioms, a novice to Perl guts may prefer a way which is as little Perl-guts-specific as possible, meaning automatic conversion and automatic call generation, as in &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;Getting the fat out of XSUBs&lt;/a&gt;. This approach has the additional benefit of protecting the XSUB writer from future changes to the Perl API.</source>
          <target state="translated">専門家はこれらの慣用句について議論することができるが、Perlの根性に初心者はのように自動変換と自動呼び出し世代、つまり、できるだけ少しのPerl-根性固有のような方法を好むかもしれ&lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;なXSUBの脂肪アウトを取得します&lt;/a&gt;。このアプローチには、Perl APIに対する将来の変更からXSUBライターを保護するという追加の利点があります。</target>
        </trans-unit>
        <trans-unit id="601070e02f682375d5e25990b39de3389f3b8c49" translate="yes" xml:space="preserve">
          <source>While in principle the &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; operator could be implemented via (and with the same rather severe limitations as) the CRTL &lt;code&gt;vfork()&lt;/code&gt; routine, and while some internal support to do just that is in place, the implementation has never been completed, making &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; currently unavailable. A true kernel &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; is expected in a future version of VMS, and the pseudo-fork based on interpreter threads may be available in a future version of Perl on VMS (see &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;). In the meantime, use &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;, backticks, or piped filehandles to create subprocesses.</source>
          <target state="translated">原則として、 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 演算子はCRTL &lt;code&gt;vfork()&lt;/code&gt; ルーチンを介して（そして同じようにかなり厳しい制限付きで）実装できますが、それを行うための内部サポートはいくつかありますが、実装はまだ完了しておらず、 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; は現在利用できません。真のカーネル &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; は、VMSの将来のバージョンで期待されており、インタープリタースレッドに基づく疑似フォークは、VMS上のPerlの将来のバージョンで利用可能になる可能性があります（&lt;a href=&quot;perlfork&quot;&gt;perlforkを&lt;/a&gt;参照）。それまでの間、 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 、backticks、またはパイプ処理されたファイルハンドルを使用してサブプロセスを作成してください。</target>
        </trans-unit>
        <trans-unit id="99369babd08034c16995edf0279e157f7f0775da" translate="yes" xml:space="preserve">
          <source>While in principle the &lt;code&gt;fork&lt;/code&gt; operator could be implemented via (and with the same rather severe limitations as) the CRTL &lt;code&gt;vfork()&lt;/code&gt; routine, and while some internal support to do just that is in place, the implementation has never been completed, making &lt;code&gt;fork&lt;/code&gt; currently unavailable. A true kernel &lt;code&gt;fork()&lt;/code&gt; is expected in a future version of VMS, and the pseudo-fork based on interpreter threads may be available in a future version of Perl on VMS (see &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;). In the meantime, use &lt;code&gt;system&lt;/code&gt;, backticks, or piped filehandles to create subprocesses.</source>
          <target state="translated">原則として、 &lt;code&gt;fork&lt;/code&gt; 演算子はCRTL &lt;code&gt;vfork()&lt;/code&gt; ルーチンを介して（そしてそれと同じかなり厳しい制限付きで）実装できますが、それを実行するための内部サポートがいくつか実施されていますが、実装は完了しておらず、現在 &lt;code&gt;fork&lt;/code&gt; 作成しています利用できません。真のカーネル &lt;code&gt;fork()&lt;/code&gt; はVMSの将来のバージョンで期待されており、インタープリタースレッドに基づく疑似フォークはVMS上のPerlの将来のバージョンで利用可能になる可能性があります（&lt;a href=&quot;perlfork&quot;&gt;perlforkを&lt;/a&gt;参照）。それまでの間、 &lt;code&gt;system&lt;/code&gt; 、バックティック、またはパイプファイルハンドルを使用してサブプロセスを作成してください。</target>
        </trans-unit>
        <trans-unit id="a11b15d87bb1f9501075e6254f16292a57b123f0" translate="yes" xml:space="preserve">
          <source>While in this mode, Perl takes special precautions called</source>
          <target state="translated">このモードでは、Perl は特別な注意事項として</target>
        </trans-unit>
        <trans-unit id="177c27cbc619ded10f5ed086056984752bc53bbb" translate="yes" xml:space="preserve">
          <source>While it is common to see these two macros in pairs within an &lt;code&gt;ENTER&lt;/code&gt;/ &lt;code&gt;LEAVE&lt;/code&gt; pair, it is not necessary to match them. It is permitted to invoke &lt;code&gt;FREETMPS&lt;/code&gt; multiple times since the most recent &lt;code&gt;SAVETMPS&lt;/code&gt;; for example in a loop iterating over elements of a list. While you can invoke &lt;code&gt;SAVETMPS&lt;/code&gt; multiple times within a scope pair, it is unlikely to be useful. Subsequent invocations will move the temporaries floor further up, thus effectively trapping the existing temporaries to only be released at the end of the scope.</source>
          <target state="translated">これらの2つのマクロは、 &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; ペア内でペアで表示されるのが一般的ですが、一致させる必要はありません。最新の &lt;code&gt;SAVETMPS&lt;/code&gt; 以降、 &lt;code&gt;FREETMPS&lt;/code&gt; を複数回呼び出すことが許可されています。たとえば、リストの要素を反復処理するループ内。スコープペア内で &lt;code&gt;SAVETMPS&lt;/code&gt; を複数回呼び出すことはできますが、役に立たない可能性があります。後続の呼び出しにより、一時フロアがさらに上に移動し、既存の一時がスコープの最後でのみ解放されるように効果的にトラップされます。</target>
        </trans-unit>
        <trans-unit id="7c260f0d64ec7ed3061fae8a4547b586a55f37c5" translate="yes" xml:space="preserve">
          <source>While it is permissible to &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; a FileCache managed file, do not do so if you are calling &lt;code&gt;FileCache::cacheout&lt;/code&gt; from a package other than which it was imported, or with another module which overrides &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;. If you must, use &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; .</source>
          <target state="translated">FileCacheマネージドファイルを &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; ことは許可されていますが、インポートされたもの以外のパッケージから、または &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; をオーバーライドする別のモジュールで &lt;code&gt;FileCache::cacheout&lt;/code&gt; を呼び出す場合は、行わないでください。必要な場合は、 &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; 使用してください。</target>
        </trans-unit>
        <trans-unit id="9b707b74369a586a0cf2d7bbc0374b51314db5a7" translate="yes" xml:space="preserve">
          <source>While it is permissible to &lt;code&gt;close&lt;/code&gt; a FileCache managed file, do not do so if you are calling &lt;code&gt;FileCache::cacheout&lt;/code&gt; from a package other than which it was imported, or with another module which overrides &lt;code&gt;close&lt;/code&gt;. If you must, use &lt;code&gt;FileCache::cacheout_close&lt;/code&gt;.</source>
          <target state="translated">FileCache管理対象ファイルを &lt;code&gt;close&lt;/code&gt; ことは許可されていますが、 &lt;code&gt;FileCache::cacheout&lt;/code&gt; れたパッケージ以外のパッケージから、または &lt;code&gt;close&lt;/code&gt; をオーバーライドする別のモジュールを使用してFileCache :: cacheoutを呼び出す場合は、閉じないでください。必要に &lt;code&gt;FileCache::cacheout_close&lt;/code&gt; 、FileCache :: cacheout_closeを使用してください。</target>
        </trans-unit>
        <trans-unit id="41a78b4c64649b65dd4cad30d6943b6a01e662f0" translate="yes" xml:space="preserve">
          <source>While it would be nice to make this the default behavior, that would almost certainly break a lot of code, so you must explicitly import these subs and use them instead of the default &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt;.</source>
          <target state="translated">これをデフォルトの動作にするのは良いことですが、それはほぼ確実に多くのコードを壊すので、これらのサブを明示的にインポートして、デフォルトの &lt;code&gt;timelocal()&lt;/code&gt; と &lt;code&gt;timegm()&lt;/code&gt; の代わりに使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="959732eaecdd2fded6d5f4730815e7ecfbb3c6a3" translate="yes" xml:space="preserve">
          <source>While it's not necessary for documentation changes, new tests or trivial patches, it's often worth explaining how your change works. Even if it's clear to you today, it may not be clear to a porter next month or next year.</source>
          <target state="translated">ドキュメントの変更、新しいテストや些細なパッチには必要ないことですが、変更がどのように機能するのかを説明する価値があることがよくあります。今日あなたには明らかであっても、来月や来年にはポーターには明らかではないかもしれません。</target>
        </trans-unit>
        <trans-unit id="44568ef65eee77bd20a0348b5e9b725eb8d8f779" translate="yes" xml:space="preserve">
          <source>While it's possible to refer directly to these hash keys outside of the class, it's considered a best practice to wrap all access to the attribute with accessor methods.</source>
          <target state="translated">クラスの外でこれらのハッシュキーを直接参照することは可能ですが、属性へのすべてのアクセスをアクセサメソッドでラップすることがベストプラクティスと考えられています。</target>
        </trans-unit>
        <trans-unit id="d0849418f5c8269f5aff84704c4d9acb674dcdcc" translate="yes" xml:space="preserve">
          <source>While it's true that Perl's regular expressions resemble the DFAs (deterministic finite automata) of the egrep(1) program, they are in fact implemented as NFAs (non-deterministic finite automata) to allow backtracking and backreferencing. And they aren't POSIX-style either, because those guarantee worst-case behavior for all cases. (It seems that some people prefer guarantees of consistency, even when what's guaranteed is slowness.) See the book &quot;Mastering Regular Expressions&quot; (from O'Reilly) by Jeffrey Friedl for all the details you could ever hope to know on these matters (a full citation appears in &lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;).</source>
          <target state="translated">Perlの正規表現がegrep（1）プログラムのDFA（確定的有限オートマトン）に似ていることは事実ですが、実際にはそれらはNFA（非確定的有限オートマトン）として実装されており、バックトラックとバックリファレンスが可能です。また、すべてのケースで最悪の場合の動作を保証するため、POSIXスタイルでもありません。 （一部の人々は、保証されているものが低速であっても、一貫性の保証を好むようです。）これらの問題について知りたいと思っているすべての詳細については、Jeffrey Friedl著「Mastering Regular Expressions」（O'Reillyから）を参照してください（完全な引用は&lt;a href=&quot;perlfaq2&quot;&gt;perlfaq2&lt;/a&gt;）に表示されます。</target>
        </trans-unit>
        <trans-unit id="3329779b59b299850e8b68832610b0b339dc0b1f" translate="yes" xml:space="preserve">
          <source>While it's true that this documentation is somewhat subserious, if you use a program named</source>
          <target state="translated">このドキュメントがやや従属的であることは事実ですが、もしあなたが</target>
        </trans-unit>
        <trans-unit id="10a36fcf99a8e338089d469f203ab0168ce94e49" translate="yes" xml:space="preserve">
          <source>While literal lists and named arrays are often interchangeable, that's not the case for hashes. Just because you can subscript a list value like a normal array does not mean that you can subscript a list value as a hash. Likewise, hashes included as parts of other lists (including parameters lists and return lists from functions) always flatten out into key/value pairs. That's why it's good to use references sometimes.</source>
          <target state="translated">リテラルリストと名前付き配列はしばしば互換性がありますが、ハッシュの場合はそうではありません。通常の配列のようにリスト値を添え字で添字することができるからといって、リスト値をハッシュとして添え字することができるわけではありません。同様に、他のリスト(パラメータリストや関数の戻り値リストを含む)の一部として含まれるハッシュは、常にキーと値のペアに平坦化されます。だからこそ、たまには参照を使うのが良いのです。</target>
        </trans-unit>
        <trans-unit id="eca6e56d146060aa14a3a670fa7ed2185164c9b5" translate="yes" xml:space="preserve">
          <source>While most important values in this file</source>
          <target state="translated">このファイルで最も重要な値は</target>
        </trans-unit>
        <trans-unit id="8f9b053b8a7e4dedb3bcc2addb9bbd5ef56b5365" translate="yes" xml:space="preserve">
          <source>While no_index tells you what must be ignored when indexing, this spec holds no opinion on how you should get your initial candidate list of things to possibly index. For &quot;normal&quot; distributions you might consider simply indexing the contents of lib/, but there are many fascinating oddities on CPAN and many dists from the days when it was normal to put the main .pm file in the root of the distribution archive - so PAUSE currently indexes all .pm and .PL files that are not either (a) specifically excluded by no_index (b) in &lt;code&gt;inc&lt;/code&gt;, &lt;code&gt;xt&lt;/code&gt;, or &lt;code&gt;t&lt;/code&gt; directories, or common 'mistake' directories such as &lt;code&gt;perl5&lt;/code&gt;.</source>
          <target state="translated">no_indexは、インデックスを作成するときに無視する必要があるものを示していますが、この仕様には、インデックスを作成するための最初の候補リストを取得する方法についての意見はありません。 「通常の」ディストリビューションの場合、lib /のコンテンツにインデックスを付けることを検討するかもしれませんが、CPANには多くの魅力的な奇妙な点があり、メインの.pmファイルをディストリビューションアーカイブのルートに置くのが通常だった時代とは異なります。 PAUSEは現在、（a） &lt;code&gt;inc&lt;/code&gt; 、 &lt;code&gt;xt&lt;/code&gt; 、または &lt;code&gt;t&lt;/code&gt; ディレクトリ内のno_index（b）によって明確に除外されていないすべての.pmファイルと.PLファイル、または &lt;code&gt;perl5&lt;/code&gt; などの一般的な「間違い」ディレクトリにインデックスを付けます。</target>
        </trans-unit>
        <trans-unit id="393059c305b4f9157627b86935072088d84089d3" translate="yes" xml:space="preserve">
          <source>While none of the built-in data types have any arbitrary size limits (apart from memory size), there are still a few arbitrary limits: a given variable name may not be longer than 251 characters. Line numbers displayed by diagnostics are internally stored as short integers, so they are limited to a maximum of 65535 (higher numbers usually being affected by wraparound).</source>
          <target state="translated">組み込みのデータ型にはいずれも任意のサイズ制限はありませんが(メモリ・サイズは別として)、いくつかの任意の制限があります。診断で表示される行番号は、内部的に短い整数として格納されているため、最大65535までに制限されています(それ以上の数値は通常、ラップアラウンドの影響を受けます)。</target>
        </trans-unit>
        <trans-unit id="b09324869be41d3f63ee219787db6a6f9e7b0b52" translate="yes" xml:space="preserve">
          <source>While not currently implemented, it is possible that in the future this function will convert only parts of the path to FILENAME to a short form.</source>
          <target state="translated">現在は実装されていませんが、将来的にはFILENAMEへのパスの一部のみを短縮形に変換する可能性があります。</target>
        </trans-unit>
        <trans-unit id="1f300b76b4f41dcdc512a5b3661d8c1aa39ba74e" translate="yes" xml:space="preserve">
          <source>While not entirely limited to Unix-derived operating systems (e.g., WinSock on PCs provides socket support, as do some VMS libraries), you might not have sockets on your system, in which case this section probably isn't going to do you much good. With sockets, you can do both virtual circuits like TCP streams and datagrams like UDP packets. You may be able to do even more depending on your system.</source>
          <target state="translated">Unix 由来のオペレーティングシステムに完全に限定されているわけではありませんが (例えば、PC の WinSock はソケットをサポートしていますし、いくつかの VMS ライブラリもソケットをサポートしています)、あなたのシステムではソケットを使用していないかもしれません。ソケットを使えば、TCP ストリームのような仮想回路と UDP パケットのようなデータグラムの両方を行うことができます。お使いのシステムによっては、さらに多くのことができるかもしれません。</target>
        </trans-unit>
        <trans-unit id="6ad3cf3a478c4f24fb9ef9675cf14d8e5c5a06f1" translate="yes" xml:space="preserve">
          <source>While running Configure and when building, you are likely to get quite a few of these warnings:</source>
          <target state="translated">Configureを実行しているときやビルド中に、これらの警告がいくつか出てくることがあります。</target>
        </trans-unit>
        <trans-unit id="9b58fa2736239282292bc4dda51122cd95ae2910" translate="yes" xml:space="preserve">
          <source>While short identifiers like &lt;code&gt;$gotit&lt;/code&gt; are probably ok, use underscores to separate words in longer identifiers. It is generally easier to read &lt;code&gt;$var_names_like_this&lt;/code&gt; than &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; , especially for non-native speakers of English. It's also a simple rule that works consistently with &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$gotit&lt;/code&gt; ような短い識別子はおそらく大丈夫ですが、アンダースコアを使用して長い識別子の単語を区切ります。一般的に、特に英語を母国語としない人にとっては、 &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; よりも &lt;code&gt;$var_names_like_this&lt;/code&gt; を読む方が簡単です。これは、 &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; と一貫して機能する単純なルールでもあります。</target>
        </trans-unit>
        <trans-unit id="3d9fa3ada3b6c731a34ad67160b19f8a88213b51" translate="yes" xml:space="preserve">
          <source>While short identifiers like &lt;code&gt;$gotit&lt;/code&gt; are probably ok, use underscores to separate words in longer identifiers. It is generally easier to read &lt;code&gt;$var_names_like_this&lt;/code&gt; than &lt;code&gt;$VarNamesLikeThis&lt;/code&gt;, especially for non-native speakers of English. It's also a simple rule that works consistently with &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$gotit&lt;/code&gt; ような短い識別子はおそらく問題ありませんが、長い識別子の単語を区切るにはアンダースコアを使用してください。特に英語を母国語としない人にとっては、一般的に &lt;code&gt;$VarNamesLikeThis&lt;/code&gt; よりも &lt;code&gt;$var_names_like_this&lt;/code&gt; を読む方が簡単です。これは、 &lt;code&gt;VAR_NAMES_LIKE_THIS&lt;/code&gt; と一貫して機能する単純なルールでもあります。</target>
        </trans-unit>
        <trans-unit id="ae3268e08a1d3bd058ed6f797f7794fd47fc37b4" translate="yes" xml:space="preserve">
          <source>While some developers find fatalizing some warnings to be a useful defensive programming technique, using &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; to fatalize all possible warning categories -- including custom ones -- is particularly risky. Therefore, the use of &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; is &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;.</source>
          <target state="translated">一部の開発者はいくつかの警告を致命的にすることは有用な防御的プログラミング手法であると考えていますが、 &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; を使用してすべての可能な警告カテゴリ（カスタムのものを含む）を致命的にすることは特に危険です。したがって、 &lt;code&gt;FATAL =&amp;gt; 'all'&lt;/code&gt; は&lt;a href=&quot;perlpolicy#discouraged&quot;&gt;お勧めしません&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f10f744968048551bad6ee098cf44a11a372745" translate="yes" xml:space="preserve">
          <source>While still in that directory, type:</source>
          <target state="translated">そのディレクトリにいる間に、次のように入力します。</target>
        </trans-unit>
        <trans-unit id="42ffebb3bbe4e65d94b8f907df7dc389a8053ee0" translate="yes" xml:space="preserve">
          <source>While the GNU project includes Perl in its distributions, there's no such thing as &quot;GNU Perl&quot;. Perl is not produced nor maintained by the Free Software Foundation. Perl's licensing terms are also more open than GNU software's tend to be.</source>
          <target state="translated">GNUプロジェクトはそのディストリビューションにPerlを含んでいますが、&quot;GNU Perl &quot;のようなものは存在しません。Perlはフリーソフトウェアファウンデーションによって制作されたり、保守されたりしていません。Perlのライセンス条項はGNUソフトウェアのものよりもオープンです。</target>
        </trans-unit>
        <trans-unit id="84896ae82951e28a26020293e6f0af332fef1cca" translate="yes" xml:space="preserve">
          <source>While the Unicode Standard defines two additional forms of casefolding, one for Turkic languages and one that never maps one character into multiple characters, these are not provided by the Perl core. However, the CPAN module &lt;a href=&quot;Unicode::Casing&quot;&gt;&lt;code&gt;Unicode::Casing&lt;/code&gt;&lt;/a&gt; may be used to provide an implementation.</source>
          <target state="translated">Unicode標準では、ケースフォールディングの2つの追加形式が定義されています。1つはトルコ語用で、もう1つは1つの文字を複数の文字にマップしないものですが、これらはPerlコアでは提供されません。ただし、CPANモジュール&lt;a href=&quot;Unicode::Casing&quot;&gt; &lt;code&gt;Unicode::Casing&lt;/code&gt; &lt;/a&gt;を使用して実装を提供することができます。</target>
        </trans-unit>
        <trans-unit id="bcb3c100d2dfc2d28078ac3b93ee7e431111c075" translate="yes" xml:space="preserve">
          <source>While the Unicode Standard defines two additional forms of casefolding, one for Turkic languages and one that never maps one character into multiple characters, these are not provided by the Perl core; However, the CPAN module &lt;code&gt;Unicode::Casing&lt;/code&gt; may be used to provide an implementation.</source>
          <target state="translated">Unicode標準は、2つの追加の形式の大文字小文字変換を定義していますが、1つはTurkic言語用で、もう1つは1文字を複数の文字にマップしませんが、Perlコアでは提供されません。ただし、CPANモジュール &lt;code&gt;Unicode::Casing&lt;/code&gt; を使用して実装を提供できます。</target>
        </trans-unit>
        <trans-unit id="761ba2f6d0a7dac9fb4c5d145960b451d6d26420" translate="yes" xml:space="preserve">
          <source>While the key must be a string value (since that's a basic restriction that Perl places on hash keys), the value in the lexicon can currently be of several types: a defined scalar, scalarref, or coderef. The use of these is explained above, in the section 'The &quot;maketext&quot; Method', and Bracket Notation for strings is discussed in the next section.</source>
          <target state="translated">キーは文字列の値でなければなりませんが(これは Perl がハッシュキーに課す基本的な制限なので)、レキシコン内の値は現在のところいくつかのタイプがあります:定義されたスカラ、スカラref、または coderef です。これらの使用法については上記の'maketext'メソッドのセクションで説明し、文字列のブラケット記法については次のセクションで説明します。</target>
        </trans-unit>
        <trans-unit id="d08b05105bcedd2fb07dc0399888e4c9d241f3f1" translate="yes" xml:space="preserve">
          <source>While the list of arguments might work fine for one, two or even three arguments, any more arguments become hard for the module user to remember, and hard for the module author to manage. If you want to add a new parameter you will have to add it to the end of the list for backward compatibility, and this will probably make your list order unintuitive. Also, if many elements may be undefined you may see the following unattractive method calls:</source>
          <target state="translated">引数リストは1つ、2つ、あるいは3つの引数であれば問題なく動作するかもしれませんが、それ以上の引数はモジュールのユーザにとっては覚えにくく、モジュールの作者にとっては管理が難しくなります。新しいパラメータを追加したい場合は、下位互換性のためにリストの最後に追加しなければなりません。また、多くの要素が未定義の場合、以下のような魅力的でないメソッドコールが表示されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="019950bbf16db8b6543648ebb335d2eaf049366f" translate="yes" xml:space="preserve">
          <source>While the mapping &quot;infin&quot; to the character &quot;\x{221E}&quot; will (hopefully) have been already handled by the Pod parser, the presence of the character in this file means that it's reasonably important enough to include in a formatter's table that maps from notable Unicode characters to the codes necessary for rendering them. So for a Unicode-to-*roff mapping, for example, this would merit the entry:</source>
          <target state="translated">infin &quot;と文字&quot;\x{221E}&quot;のマッピングは(うまくいけば)すでにPodパーサによって処理されているでしょうが、このファイルにこの文字があるということは、注目すべきUnicode文字からそれらをレンダリングするために必要なコードへのマッピングを行うフォーマッタのテーブルに含めるのに十分なほど重要であるということを意味します。つまり、例えばUnicode-to-*roffのマッピングの場合、このファイルはエントリに値するということになります。</target>
        </trans-unit>
        <trans-unit id="549c813f59b3276935336cbd28f55b4770622941" translate="yes" xml:space="preserve">
          <source>While the two classes may differ in many ways, when it comes to the &lt;code&gt;print_content()&lt;/code&gt; method, they are the same. This means that we can try to call the &lt;code&gt;print_content()&lt;/code&gt; method on an object of either class, and &lt;b&gt;we don't have to know what class the object belongs to!&lt;/b&gt;</source>
          <target state="translated">2つのクラスは多くの点で異なる場合がありますが、 &lt;code&gt;print_content()&lt;/code&gt; メソッドに関しては同じです。これは、どちらかのクラスのオブジェクトで &lt;code&gt;print_content()&lt;/code&gt; メソッドを呼び出そうとすることができ、オブジェクトが&lt;b&gt;どのクラスに属しているかを知る必要がないことを意味します。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="76ea82c5269a1424cf449fcf0bff6de44af4f6d8" translate="yes" xml:space="preserve">
          <source>While the word combination &lt;code&gt;character set&lt;/code&gt; has lost this meaning in MIME context since [RFC 2130], the &lt;code&gt;charset&lt;/code&gt; abbreviation has retained it. This is how [RFC 2277] and [RFC 2278] bless &lt;code&gt;charset&lt;/code&gt;:</source>
          <target state="translated">[RFC 2130]以降、単語の組み合わせ &lt;code&gt;character set&lt;/code&gt; はMIMEコンテキストでこの意味を失いましたが、 &lt;code&gt;charset&lt;/code&gt; 略語はそれを保持しています。これは、[RFC2277]と[RFC2278]が &lt;code&gt;charset&lt;/code&gt; 祝福する方法です。</target>
        </trans-unit>
        <trans-unit id="b178eba62086e85a4d0b937f4f56029a87c5eae0" translate="yes" xml:space="preserve">
          <source>While there are Pod codes E&amp;lt;...&amp;gt; and Z&amp;lt;&amp;gt;, these</source>
          <target state="translated">ポッドコードE &amp;lt;...&amp;gt;とZ &amp;lt;&amp;gt;がありますが、これらは</target>
        </trans-unit>
        <trans-unit id="05f8c54acc4d9406822b250e87f501917fa0a683" translate="yes" xml:space="preserve">
          <source>While there are currently no architecture-specific extensions or modules distributed with perl, the following directories can be used to hold such files (replace the string VERSION by the appropriate version number):</source>
          <target state="translated">現在のところ、perlで配布されているアーキテクチャ固有の拡張機能やモジュールはありませんが、以下のディレクトリを使用して、そのようなファイルを保持することができます(VERSIONという文字列を適切なバージョン番号に置き換えてください)。</target>
        </trans-unit>
        <trans-unit id="0c8516dbb58fd38e067d471797d458e282eb5b87" translate="yes" xml:space="preserve">
          <source>While these operations are not questions of life and death, they are needed for a lot of useful scripts. This forces &lt;code&gt;a.out&lt;/code&gt; -style compile of</source>
          <target state="translated">これらの操作は生と死の問題ではありませんが、多くの便利なスクリプトに必要です。これにより、 &lt;code&gt;a.out&lt;/code&gt; スタイルのコンパイルが強制されます</target>
        </trans-unit>
        <trans-unit id="3d2455a51c401e0d0b17f4da15388c28c0528ee2" translate="yes" xml:space="preserve">
          <source>While these operations are not questions of life and death, they are needed for a lot of useful scripts. This forces &lt;code&gt;a.out&lt;/code&gt;-style compile of</source>
          <target state="translated">これらの操作は生死の問題ではありませんが、多くの便利なスクリプトに必要です。これにより、 &lt;code&gt;a.out&lt;/code&gt; スタイルのコンパイルが強制されます。</target>
        </trans-unit>
        <trans-unit id="1849a634e96a61e2b3cdef3b11aa962d9aad4c39" translate="yes" xml:space="preserve">
          <source>While this actually can be done, it's much harder than you'd think. For example, this one-liner</source>
          <target state="translated">これは実際には可能ですが、思ったよりもずっと難しいです。例えば、このワンライナー</target>
        </trans-unit>
        <trans-unit id="c8b72cb61463146c67f31be1d892fe7495f6bd9f" translate="yes" xml:space="preserve">
          <source>While this allows some (significant?) performance advantages, this makes life much harder for developers, since the above scheme makes it impossible for a DLL to be &quot;linked&quot; to a symbol in the</source>
          <target state="translated">これにより、いくつかの(重要な?)パフォーマンス上の利点が得られる一方で、開発者にとっては非常に困難になります。</target>
        </trans-unit>
        <trans-unit id="5a4ded2cb5289b97c3775e062e86790bf5432277" translate="yes" xml:space="preserve">
          <source>While this class is currently implemented using the Class::Struct module to build a struct-like class, you shouldn't rely upon this.</source>
          <target state="translated">現在、このクラスは Class::Structure モジュールを使って構造体のようなクラスを作るために実装されていますが、これに頼るべきではありません。</target>
        </trans-unit>
        <trans-unit id="e68b146940f9324cc2fc3ad49971a5aa379db2a9" translate="yes" xml:space="preserve">
          <source>While this compiles and runs happily, it probably won't do what's expected, namely it doesn't print &quot;Hello World\n&quot; at all; It will on the other hand do exactly what it was told to do, computers being a bit that way inclined. That is, it will print out a newline character, and you'll get what looks like a blank line. It looks like there's 2 variables when (because of the typo) there's really 3:</source>
          <target state="translated">これはコンパイルして楽しく動いていますが、おそらく期待されていることはできないでしょう、つまり、&quot;Hello World &quot;を全く印刷しません。つまり、改行文字を出力して、空白の行のように見えるものを得るでしょう。変数が2つあるように見えますが、(タイプミスのために)実際には3つあります。</target>
        </trans-unit>
        <trans-unit id="b959fa7d0d0730d45d9d80c8527dc6a6d9341163" translate="yes" xml:space="preserve">
          <source>While this currently exists in all three implementations perl itself does not use it.</source>
          <target state="translated">これは現在、3つの実装すべてに存在していますが、Perl自身はこれを使用していません。</target>
        </trans-unit>
        <trans-unit id="386467fc98e2754e0e58a98e1b2d3e8dc8fa8075" translate="yes" xml:space="preserve">
          <source>While this currently exists in both implementations, perl itself does not use it.</source>
          <target state="translated">これは現在両方の実装に存在していますが、perl自身はこれを使用していません。</target>
        </trans-unit>
        <trans-unit id="f084942a5c159bd226784a38fd066229baa22988" translate="yes" xml:space="preserve">
          <source>While this document is intended to be useful to all module authors, it is particularly aimed at authors who wish to publish their modules on CPAN.</source>
          <target state="translated">この文書はすべてのモジュール作成者に役立つことを意図していますが、特にCPANでモジュールを公開したいと考えている作成者を対象としています。</target>
        </trans-unit>
        <trans-unit id="66c1c2ee830cc759765d36b85a240cf7d1bab82e" translate="yes" xml:space="preserve">
          <source>While this feature is most commonly used to explicitly call methods inherited from an ancestor class, there is no technical restriction that enforces this:</source>
          <target state="translated">この機能は、祖先クラスから継承されたメソッドを明示的に呼び出すために最も一般的に使用されますが、これを強制する技術的な制限はありません。</target>
        </trans-unit>
        <trans-unit id="1785d6466e3128c272757d8a3931f08ab9e01f53" translate="yes" xml:space="preserve">
          <source>While this is legal practice, it is certainly dubious, and downright fatal in at least one platform: for example VMS cc considers this a fatal error. One cause for people often making this mistake is that a &quot;naked char&quot; and therefore dereferencing a &quot;naked char pointer&quot; have an undefined signedness: it depends on the compiler and the flags of the compiler and the underlying platform whether the result is signed or unsigned. For this very same reason using a 'char' as an array index is bad.</source>
          <target state="translated">これは法律上の慣行ではありますが、少なくとも1つのプラットフォームでは確かに怪しく、致命的なエラーとなります。人々がしばしばこの間違いを犯す原因の一つは、&quot;naked char &quot;とそのために &quot;naked char ポインタ &quot;を参照していると、未定義の符号付きになってしまうことです。これと全く同じ理由で、配列のインデックスとして 'char' を使うのは良くありません。</target>
        </trans-unit>
        <trans-unit id="40200d6701039334e5e5bffbb6cca8ab91bc30ff" translate="yes" xml:space="preserve">
          <source>While this is true on the surface, it's much more efficient to process the file one line or record at a time because then you don't have to read the whole thing into memory at once. It also gives you finer control of the whole process, letting you kill off the child process early if you'd like.</source>
          <target state="translated">これは表面上はそうですが、ファイルを一度に一行またはレコードごとに処理する方がはるかに効率的です。また、プロセス全体をより細かく制御することができるので、子プロセスを早期に終了させることができます。</target>
        </trans-unit>
        <trans-unit id="9790d6e959def47c7e50e558f607fe7ba4374a90" translate="yes" xml:space="preserve">
          <source>While this might be too cumbersome to implement in event-based Pod parsers, it is straightforward for parsers that return parse trees.</source>
          <target state="translated">これはイベントベースのPodパーサに実装するには煩雑すぎるかもしれませんが、パースツリーを返すパーサでは簡単です。</target>
        </trans-unit>
        <trans-unit id="81aa0dd02571c7973cd68f4d9f805b1c67ff2c9c" translate="yes" xml:space="preserve">
          <source>While this might by accident work in some platform (where IV happens to be an &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;), in general it cannot. IV might be something larger. Even worse the situation is with more specific types (defined by Perl's configuration step in</source>
          <target state="translated">これは偶然に一部のプラットフォーム（IVがたまたま &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; ）で機能する可能性がありますが、一般的には機能しません。IVはもっと大きいかもしれません。さらに悪い状況は、より具体的なタイプ（Perlの構成ステップで定義されている）</target>
        </trans-unit>
        <trans-unit id="7f1683bf56a3090bff1bb086f826f7e09370112c" translate="yes" xml:space="preserve">
          <source>While this might by accident work in some platform (where IV happens to be an &lt;code&gt;int&lt;/code&gt;), in general it cannot. IV might be something larger. Even worse the situation is with more specific types (defined by Perl's configuration step in</source>
          <target state="translated">これは偶然に一部のプラットフォーム（IVが &lt;code&gt;int&lt;/code&gt; である場合）で機能する可能性がありますが、一般的には機能しません。IVはもっと大きいかもしれません。さらに悪いことに、状況はより具体的なタイプの場合です（Perlの構成ステップで定義されています</target>
        </trans-unit>
        <trans-unit id="82be9c7a2de102e2677bf88ba7443091644097cd" translate="yes" xml:space="preserve">
          <source>While this works reasonably well for unidirectional communication, what about bidirectional communication? The most obvious approach doesn't work:</source>
          <target state="translated">これは一方向通信ではそれなりに機能しますが、双方向通信ではどうでしょうか?最も明白なアプローチはうまくいかない。</target>
        </trans-unit>
        <trans-unit id="26ea84a69e787188d7dfd7dc7bac4a8b95950ee8" translate="yes" xml:space="preserve">
          <source>While threads bring a new set of useful tools, they also bring a number of pitfalls. One pitfall is the race condition:</source>
          <target state="translated">スレッドは新しい便利なツールのセットをもたらす一方で、多くの落とし穴ももたらします。落とし穴の一つは、レース条件です。</target>
        </trans-unit>
        <trans-unit id="0369ef7f3a86c9ade18a8f113608ef11b27c9fcb" translate="yes" xml:space="preserve">
          <source>While thumbing through the &lt;a href=&quot;Date::ICal&quot;&gt;Date::ICal&lt;/a&gt; man page, I came across this:</source>
          <target state="translated">&lt;a href=&quot;Date::ICal&quot;&gt;Date :: ICalの&lt;/a&gt;マニュアルページをざっと見ていると、次のことに気づきました。</target>
        </trans-unit>
        <trans-unit id="8fb55e176d75bb6afa2c9779e5d12c3767454404" translate="yes" xml:space="preserve">
          <source>While trying to read from his caller-id box, the notorious Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; , after much gnashing of teeth and fighting with &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, POSIX's &lt;code&gt;tcgetattr&lt;/code&gt; business, and various other functions that go bump in the night, finally came up with this:</source>
          <target state="translated">悪名高いJamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; は、発信者IDのボックスから読み込もうとしている間に、 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; 、POSIXの &lt;code&gt;tcgetattr&lt;/code&gt; ビジネス、および夜間に衝突するその他のさまざまな関数との戦いを繰り返しました。最後にこれを思い付きました：</target>
        </trans-unit>
        <trans-unit id="3d9a29cb2e71d84a90b207c5a091106e69ab3f88" translate="yes" xml:space="preserve">
          <source>While trying to read from his caller-id box, the notorious Jamie Zawinski &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt;, after much gnashing of teeth and fighting with &lt;code&gt;sysread&lt;/code&gt;, &lt;code&gt;sysopen&lt;/code&gt;, POSIX's &lt;code&gt;tcgetattr&lt;/code&gt; business, and various other functions that go bump in the night, finally came up with this:</source>
          <target state="translated">悪名高いジェイミー・ &lt;code&gt;&amp;lt;jwz@netscape.com&amp;gt;&lt;/code&gt; 、彼の発信者IDボックスから読み込もうとしているときに、歯を &lt;code&gt;sysread&lt;/code&gt; 、 &lt;code&gt;sysopen&lt;/code&gt; 、POSIXの &lt;code&gt;tcgetattr&lt;/code&gt; ビジネス、および夜にぶつかるその他のさまざまな機能と戦った後、ついにこれを思いついた：</target>
        </trans-unit>
        <trans-unit id="6d7592c228741a449aa83d6358c7b5dbac2c422e" translate="yes" xml:space="preserve">
          <source>While trying to resolve method call %s-&amp;gt;%s() can not locate package &quot;%s&quot; yet it is mentioned in @%s::ISA (perhaps you forgot to load &quot;%s&quot;?)</source>
          <target state="translated">メソッド呼び出しを解決しようとしている間、％s-&amp;gt;％s（）はパッケージ &quot;％s&quot;を見つけることができませんが、@％s :: ISAに記載されています（おそらく &quot;％s&quot;をロードするのを忘れましたか？）</target>
        </trans-unit>
        <trans-unit id="5ffa8b7afc028fdbcdab4b6dea3d1eb48e0f55ad" translate="yes" xml:space="preserve">
          <source>While using the standard</source>
          <target state="translated">標準で使用している間は</target>
        </trans-unit>
        <trans-unit id="c059f6308f685a568f9b74b626f917b18a45a114" translate="yes" xml:space="preserve">
          <source>While version objects overload stringification, to portably convert &lt;code&gt;$^V&lt;/code&gt; into its string representation, use &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt;'s &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; conversion, which works for both v-strings or version objects:</source>
          <target state="translated">バージョンオブジェクトは文字列化をオーバーロードしますが、 &lt;code&gt;$^V&lt;/code&gt; をその文字列表現に移植可能に変換するには、 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf()&lt;/a&gt;&lt;/code&gt; の &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; 変換を使用します。これは、v文字列またはバージョンオブジェクトの両方で機能します。</target>
        </trans-unit>
        <trans-unit id="7e7742e29582b552f48253992f05bd5349646ba9" translate="yes" xml:space="preserve">
          <source>While version objects overload stringification, to portably convert &lt;code&gt;$^V&lt;/code&gt; into its string representation, use &lt;code&gt;sprintf()&lt;/code&gt;'s &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; conversion, which works for both v-strings or version objects:</source>
          <target state="translated">バージョンオブジェクトは文字列化をオーバーロードしますが、 &lt;code&gt;$^V&lt;/code&gt; をその文字列表現に移植可能に変換するには、 &lt;code&gt;sprintf()&lt;/code&gt; の &lt;code&gt;&quot;%vd&quot;&lt;/code&gt; 変換を使用します。これはv文字列またはバージョンオブジェクトの両方で機能します。</target>
        </trans-unit>
        <trans-unit id="3a5995cddc89ffbbaa6e8a0013934033bfcd3e1f" translate="yes" xml:space="preserve">
          <source>While versions earlier than 5.8.1 had threads they contain too many bugs to support.</source>
          <target state="translated">5.8.1 より前のバージョンにはスレッドがありましたが、サポートするにはあまりにも多くのバグを含んでいます。</target>
        </trans-unit>
        <trans-unit id="daa9a857c615b0eef13a54df6fdfd26532388959" translate="yes" xml:space="preserve">
          <source>While we normally think of patterns as being delimited with &lt;code&gt;/&lt;/code&gt; characters, they can be delimited by almost any character. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; describes this. For example, the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; above uses braces as delimiters. Selecting another delimiter can avoid quoting the delimiter within the pattern:</source>
          <target state="translated">通常、パターンは &lt;code&gt;/&lt;/code&gt; 文字で区切られていると考えていますが、ほとんどすべての文字で区切ることができます。&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;はこれについて説明しています。たとえば、上記 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; は中括弧を区切り文字として使用します。別の区切り文字を選択すると、パターン内の区切り文字を引用符で囲むのを回避できます。</target>
        </trans-unit>
        <trans-unit id="39f1ea1d3e2074839c9819aaf86819467fb5bb22" translate="yes" xml:space="preserve">
          <source>While we normally think of patterns as being delimited with &lt;code&gt;/&lt;/code&gt; characters, they can be delimited by almost any character. &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; describes this. For example, the &lt;code&gt;s///&lt;/code&gt; above uses braces as delimiters. Selecting another delimiter can avoid quoting the delimiter within the pattern:</source>
          <target state="translated">通常、パターンは &lt;code&gt;/&lt;/code&gt; 文字で区切られていると考えられていますが、ほとんどすべての文字で区切ることができます。&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;はこれについて説明しています。たとえば、上記 &lt;code&gt;s///&lt;/code&gt; は、区切り文字として中括弧を使用します。別の区切り文字を選択すると、パターン内で区切り文字を引用することを回避できます。</target>
        </trans-unit>
        <trans-unit id="09af51d2e240602d6d93896cb9f587c7a82f4e64" translate="yes" xml:space="preserve">
          <source>While we strongly suggest you don't build your objects from scratch, you should know the term &lt;b&gt;bless&lt;/b&gt;. A &lt;b&gt;blessed&lt;/b&gt; data structure (aka &quot;a referent&quot;) is an object. We sometimes say that an object has been &quot;blessed into a class&quot;.</source>
          <target state="translated">オブジェクトを最初から構築しないことを強くお勧めしますが、&lt;b&gt;bless&lt;/b&gt;という用語&lt;b&gt;を&lt;/b&gt;知っておく必要があります。&lt;b&gt;祝福&lt;/b&gt;データ構造（別名「参照先」）が目的です。オブジェクトは「クラスに祝福されている」と私たちは時々言います。</target>
        </trans-unit>
        <trans-unit id="562c113d1f1007e0a6502247b3772bac3c2d33a2" translate="yes" xml:space="preserve">
          <source>While we usually think of quotes as literal values, in Perl they function as operators, providing various kinds of interpolating and pattern matching capabilities. Perl provides customary quote characters for these behaviors, but also provides a way for you to choose your quote character for any of them. In the following table, a &lt;code&gt;{}&lt;/code&gt; represents any pair of delimiters you choose.</source>
          <target state="translated">通常、引用符はリテラル値と見なされますが、Perlでは演算子として機能し、さまざまな種類の補間およびパターンマッチング機能を提供します。Perlはこれらの振る舞いに慣習的な引用文字を提供しますが、それらのいずれかの引用文字を選択する方法も提供します。次の表では、 &lt;code&gt;{}&lt;/code&gt; は選択した区切り文字のペアを表します。</target>
        </trans-unit>
        <trans-unit id="34200b2d58936bc37828d3e87d2eebbab2c0f898" translate="yes" xml:space="preserve">
          <source>While we're here, take a closer look at the '&lt;b&gt;x&lt;/b&gt;' command, it's really useful and will merrily dump out nested references, complete objects, partial objects - just about whatever you throw at it:</source>
          <target state="translated">ここにいる間、 ' &lt;b&gt;x&lt;/b&gt; 'コマンドを詳しく見てみましょう。これは非常に便利であり、ネストされた参照、完全なオブジェクト、部分的なオブジェクトなど、何を投げても大丈夫です。</target>
        </trans-unit>
        <trans-unit id="00e2fed4a06f99f6100461a2d8cbb333f4d09501" translate="yes" xml:space="preserve">
          <source>While you can mix double colons with singles quotes, the quotes must come after the colons: &lt;code&gt;$::::'foo&lt;/code&gt; and &lt;code&gt;$foo::'bar&lt;/code&gt; are legal, but &lt;code&gt;$::'::foo&lt;/code&gt; and &lt;code&gt;$foo'::bar&lt;/code&gt; are not.</source>
          <target state="translated">二重コロンと単一引用符を混在させることはできますが、引用符はコロンの後に置く必要があります： &lt;code&gt;$::::'foo&lt;/code&gt; と &lt;code&gt;$foo::'bar&lt;/code&gt; は正当ですが、 &lt;code&gt;$::'::foo&lt;/code&gt; と &lt;code&gt;$foo'::bar&lt;/code&gt; そうではありません。</target>
        </trans-unit>
        <trans-unit id="078d591b0ade8bcb579420345c7df7b2c236f00e" translate="yes" xml:space="preserve">
          <source>While you can use arbitrary unique IDs for lexicon keys (like &quot;_min_larger_max_error&quot;), it is often useful for if an entry's key is itself a valid value, like this example error message:</source>
          <target state="translated">レキシコンキーには任意のユニークなIDを使用することができますが(「_min_larger_max_error」のように)、この例のエラーメッセージのように、エントリのキー自体が有効な値であるかどうかを確認するのに便利なことがよくあります。</target>
        </trans-unit>
        <trans-unit id="59ac30a04c89545845f0a1e87ea492a8c9c597ff" translate="yes" xml:space="preserve">
          <source>While you're doing that, make really sure you haven't missed a module similar to the one you're about to write.</source>
          <target state="translated">そうしている間に、これから書こうとしているものと似たようなモジュールを見逃していないか、本当に確認してください。</target>
        </trans-unit>
        <trans-unit id="95a6dc4463afddf0b399fee2185874a12ea0df02" translate="yes" xml:space="preserve">
          <source>While:</source>
          <target state="translated">While:</target>
        </trans-unit>
        <trans-unit id="c6568ae799534002dc040ff86ba3511a9bd4bd58" translate="yes" xml:space="preserve">
          <source>Whilst control is in the library, an error condition occurs. You have previously set up a Perl callback to handle this situation, so it will get executed. Once the callback has finished, control will drop back to Perl again. Here is what the flow of control will be like in that situation</source>
          <target state="translated">制御がライブラリ内にあるときに、エラー状態が発生します。この状況を処理するためにPerlのコールバックを設定していますので、それが実行されます。コールバックが終了すると、制御は再びPerlに戻ります。その場合の制御の流れは次のようになります。</target>
        </trans-unit>
        <trans-unit id="80e9be96d98a6599b821f35e0fd1d6289ce559ee" translate="yes" xml:space="preserve">
          <source>White space, hyphens, and underscores ARE significant except for:</source>
          <target state="translated">空白、ハイフン、アンダースコアは例外を除いて重要です。</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="44c1e2cd5ccb90bd73774fc5e53e7773e341381c" translate="yes" xml:space="preserve">
          <source>Whitespace and IPC::Open3 / system()</source>
          <target state="translated">ホワイトスペースとIPC::Open3/system()</target>
        </trans-unit>
        <trans-unit id="82098c40334ef85fcca05587546e9cc28f23e2a9" translate="yes" xml:space="preserve">
          <source>Whitespace and IPC::Run</source>
          <target state="translated">ホワイトスペースとIPC::Run</target>
        </trans-unit>
        <trans-unit id="974608074eb6dc3e2345e2aa4e42c412340d3d49" translate="yes" xml:space="preserve">
          <source>Whitespace and special characters in the filename argument</source>
          <target state="translated">ファイル名の引数の空白文字と特殊文字</target>
        </trans-unit>
        <trans-unit id="e3b1deb6ad1643a6518bffe011e47a1bbf2cd01d" translate="yes" xml:space="preserve">
          <source>Whitespace does not delimit fileglobs.</source>
          <target state="translated">空白はファイルグロブを区切りません。</target>
        </trans-unit>
        <trans-unit id="df7fa704cbceacef574fb86983159dfe4b06ae43" translate="yes" xml:space="preserve">
          <source>Whitespace in filenames is tolerated on most systems, but not all, and even on systems where it might be tolerated, some utilities might become confused by such whitespace.</source>
          <target state="translated">ファイル名の空白は、ほとんどのシステムでは許容されていますが、すべてのシステムでは許容されていません。</target>
        </trans-unit>
        <trans-unit id="baf39f9fbe05bd8902b826d4b1716bd33c1e5022" translate="yes" xml:space="preserve">
          <source>Whitespace is ignored.</source>
          <target state="translated">空白は無視されます。</target>
        </trans-unit>
        <trans-unit id="5899e5ae54fc72cc82eec99924af8577c33c2cbc" translate="yes" xml:space="preserve">
          <source>Whitespace is ignored. The alias value can be a single attribute or a space-separated list of attributes.</source>
          <target state="translated">空白は無視されます。エイリアスの値は、単一の属性か、スペースで区切られた属性のリストにすることができます。</target>
        </trans-unit>
        <trans-unit id="09822d18c062da75d056f267dd113eb02444df2b" translate="yes" xml:space="preserve">
          <source>Whitespace is irrelevant:</source>
          <target state="translated">空白は関係ありません。</target>
        </trans-unit>
        <trans-unit id="e6027b651e819925aa47dc4c27f8a2f557b14aae" translate="yes" xml:space="preserve">
          <source>Who Needs Complicated Data Structures?</source>
          <target state="translated">複雑なデータ構造を必要とするのは誰か?</target>
        </trans-unit>
        <trans-unit id="ce404d98012c2a69e116523288638e2bddf0b8c2" translate="yes" xml:space="preserve">
          <source>Who supports Perl? Who develops it? Why is it free?</source>
          <target state="translated">誰がPerlをサポートしていますか?誰が開発しているの?なぜ無料なのか?</target>
        </trans-unit>
        <trans-unit id="6272068bf74683d289db3b55d0ea826c2bd453e3" translate="yes" xml:space="preserve">
          <source>Who wrote it (use AUTHORS for multiple people). It's a good idea to include your current e-mail address (or some e-mail address to which bug reports should be sent) or some other contact information so that users have a way of contacting you. Remember that program documentation tends to roam the wild for far longer than you expect and pick a contact method that's likely to last.</source>
          <target state="translated">誰が書いたのか (複数人の場合は AUTHORS を使ってください)。あなたの現在の電子メールアドレス (あるいはバグ報告を送るべき電子メールアドレス)やその他の連絡先を記載して、 ユーザがあなたに連絡できるようにするのが良いでしょう。プログラムのドキュメントは、あなたが思っている以上に長く野放しにされている傾向があることを覚えておいて、長持ちする可能性の高い連絡方法を選んでください。</target>
        </trans-unit>
        <trans-unit id="cf619e0d870f5f00d0e62715b2fa9d9354bf3093" translate="yes" xml:space="preserve">
          <source>Whoops! Looks like it's unimplemented. Assume you don't have the time to fix this. [11] Normally, you'd just comment out the test and put a note in a todo list somewhere. Instead, explicitly state &quot;this test will fail&quot; by wrapping it in a &lt;code&gt;TODO&lt;/code&gt; block:</source>
          <target state="translated">おっと！実装されていないようです。これを修正する時間がないとします。[11]通常は、テストをコメントアウトして、ToDoリストのどこかにメモを入れます。代わりに、 &lt;code&gt;TODO&lt;/code&gt; ブロックでラップして、「このテストは失敗します」と明示的に記述します。</target>
        </trans-unit>
        <trans-unit id="d4357002b49a216cedec63d85f662f9560e6c2af" translate="yes" xml:space="preserve">
          <source>Whoops! You just put a tab and a formfeed into that filename! Remember that within double quoted strings (&quot;like\this&quot;), the backslash is an escape character. The full list of these is in &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;&quot;Quote and Quote-like Operators&quot; in perlop&lt;/a&gt;. Unsurprisingly, you don't have a file called &quot;c:(tab)emp(formfeed)oo&quot; or &quot;c:(tab)emp(formfeed)oo.exe&quot; on your legacy DOS filesystem.</source>
          <target state="translated">おっと！そのファイル名にタブとフォームフィードを入れるだけです！二重引用符で囲まれた文字列（ &quot;like \ this&quot;）内では、円記号はエスケープ文字であることに注意してください。これらの完全なリストは&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;、perlopの「QuoteおよびQuote-likeOperators」にあり&lt;/a&gt;ます。当然のことながら、従来のDOSファイルシステムには「c：（tab）emp（formfeed）oo」または「c：（tab）emp（formfeed）oo.exe」というファイルがありません。</target>
        </trans-unit>
        <trans-unit id="b22ef207f555182408b6d1958c0f8d72d42ebbcf" translate="yes" xml:space="preserve">
          <source>Whoops! You just put a tab and a formfeed into that filename! Remember that within double quoted strings (&quot;like\this&quot;), the backslash is an escape character. The full list of these is in &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;. Unsurprisingly, you don't have a file called &quot;c:(tab)emp(formfeed)oo&quot; or &quot;c:(tab)emp(formfeed)oo.exe&quot; on your legacy DOS filesystem.</source>
          <target state="translated">おっと！そのファイル名にタブとフォームフィードを挿入するだけです！二重引用符で囲まれた文字列（ &quot;like \ this&quot;）内では、バックスラッシュがエスケープ文字であることを覚えておいてください。これらの完全なリストは&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;、perlopのQuoteおよびQuote-like Operatorsにあり&lt;/a&gt;ます。当然のことながら、レガシーDOSファイルシステムに「c：（tab）emp（formfeed）oo」または「c：（tab）emp（formfeed）oo.exe」というファイルはありません。</target>
        </trans-unit>
        <trans-unit id="4b60ac899852ccb4f23a0cc5a329b0dd058c1185" translate="yes" xml:space="preserve">
          <source>Whoops, a failure! [4] &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt; helpfully lets us know on what line the failure occurred, but not much else. We were supposed to get 17, but we didn't. What did we get?? Dunno. You could re-run the test in the debugger or throw in some print statements to find out.</source>
          <target state="translated">おっと、失敗！[4] &lt;a href=&quot;Test::Simple&quot;&gt;Test :: Simple&lt;/a&gt;は、障害が発生した行を教えてくれますが、それ以外はあまりわかりません。私たちは17を得ることになっていたが、そうではなかった。何を手に入れたの？ダンノ。デバッガーでテストを再実行するか、いくつかのprintステートメントをスローして調べることができます。</target>
        </trans-unit>
        <trans-unit id="8c0f41e4219d3445a18de71b89eb22ea90d39e82" translate="yes" xml:space="preserve">
          <source>Whoops. You should instead use this, which will fail if the file doesn't exist:</source>
          <target state="translated">おっと。これはファイルが存在しない場合に失敗します。</target>
        </trans-unit>
        <trans-unit id="21e2caea4476d26af34541ca7c909c7ff2fa4a7f" translate="yes" xml:space="preserve">
          <source>Why</source>
          <target state="translated">Why</target>
        </trans-unit>
        <trans-unit id="9560992747d1a6605928cb6a17f56014fb292bd8" translate="yes" xml:space="preserve">
          <source>Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?</source>
          <target state="translated">なぜ私は、本来取得すべき数字(例:19.95)ではなく、長い小数点以下の数字(例:19.9499999999999)を取得しているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="dc84c992e3edcd39e94928310a7c42a03b0e34c8" translate="yes" xml:space="preserve">
          <source>Why aren't my random numbers random?</source>
          <target state="translated">なぜ私の乱数はランダムじゃないの?</target>
        </trans-unit>
        <trans-unit id="55451ebd45b1e100db71c6105ddc04433d37cb2f" translate="yes" xml:space="preserve">
          <source>Why can't I get the output of a command with system()?</source>
          <target state="translated">なぜ system()でコマンドの出力を取得できないのですか?</target>
        </trans-unit>
        <trans-unit id="6283f33f8240aceff8b5bf7c89ea62586d7996ea" translate="yes" xml:space="preserve">
          <source>Why can't I just open(FH, &quot;&amp;gt;file.lock&quot;)?</source>
          <target state="translated">なぜ単に開くことができないのですか（FH、 &quot;&amp;gt; file.lock&quot;）？</target>
        </trans-unit>
        <trans-unit id="45f36238b104ed9ce41136ab2cd5676c9546b754" translate="yes" xml:space="preserve">
          <source>Why can't I use &quot;C:\temp\foo&quot; in DOS paths? Why doesn't `C:\temp\foo.exe` work?</source>
          <target state="translated">DOSパスで &quot;C:\temp\foo&quot; が使えないのはなぜ?なぜ `C:tempemp\foo.exe` が動かないのでしょうか?</target>
        </trans-unit>
        <trans-unit id="7cf9bf3687394740ded1b7a3b49b00f8b7f479e0" translate="yes" xml:space="preserve">
          <source>Why can't a method included in this same file be found?</source>
          <target state="translated">同じファイルに含まれるメソッドが見つからないのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="c1b368f947117e2802b241b52fd0f345164c6250" translate="yes" xml:space="preserve">
          <source>Why can't my script read from STDIN after I gave it EOF (^D on Unix, ^Z on MS-DOS)?</source>
          <target state="translated">なぜ私のスクリプトはEOF (Unixでは^D、MS-DOSでは^Z)を与えた後、STDINから読み込めないのでしょうか?</target>
        </trans-unit>
        <trans-unit id="12d1b0fba90164d9432c0961ee9c0f59f511f752" translate="yes" xml:space="preserve">
          <source>Why can't the part of an Email address after the @ be used as the hostname ?</source>
          <target state="translated">メールアドレスの@の後の部分がホスト名として使えないのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="4a35a43f2543633bf09ecfd8ed381f93a2e351c4" translate="yes" xml:space="preserve">
          <source>Why chimera build?</source>
          <target state="translated">なぜキメラビルドなのか?</target>
        </trans-unit>
        <trans-unit id="4ad29870738240c44cf5d008e9ef6e5a830b4811" translate="yes" xml:space="preserve">
          <source>Why did MakeMaker reinvent the build configuration wheel? Why not just use autoconf or automake or ppm or Ant or ...</source>
          <target state="translated">なぜ MakeMaker はビルド設定ホイールを再発明したのでしょうか?なぜ autoconf や automake や ppm や Ant や ...を使わないのか?</target>
        </trans-unit>
        <trans-unit id="9c94cf8ad35b8d40bcd1d8a24897df534e24a65c" translate="yes" xml:space="preserve">
          <source>Why do I get asked the same questions every time I start the shell?</source>
          <target state="translated">シェルを起動するたびに同じ質問をされるのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="88d20a17cd64b1f5b322facdeee78dd428855e4f" translate="yes" xml:space="preserve">
          <source>Why do I get weird spaces when I print an array of lines?</source>
          <target state="translated">行の配列を印刷すると変なスペースが出るのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="22c242ee2f7e6a5499b05c8e9ef2302a328d950b" translate="yes" xml:space="preserve">
          <source>Why do I sometimes get an &quot;Argument list too long&quot; when I use &amp;lt;*&amp;gt;?</source>
          <target state="translated">&amp;lt;*&amp;gt;を使用すると、「引数リストが長すぎる」ことが時々あるのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="b24284283ebf1fc2287cf9d0bdc0093551feae63" translate="yes" xml:space="preserve">
          <source>Why do I sometimes get an &quot;Argument list too long&quot; when I use ?</source>
          <target state="translated">を使用すると、&quot;Argument list too long&quot; というメッセージが表示されることがあります。</target>
        </trans-unit>
        <trans-unit id="63e6abc6f1a440467925da9b75e53aa88bf445d6" translate="yes" xml:space="preserve">
          <source>Why do Perl operators have different precedence than C operators?</source>
          <target state="translated">なぜPerlの演算子はCの演算子とは優先順位が異なるのですか?</target>
        </trans-unit>
        <trans-unit id="ef2253bfbc8ad66388d03d0bb9e87b886d907b29" translate="yes" xml:space="preserve">
          <source>Why do regex character classes sometimes match only in the ASCII range?</source>
          <target state="translated">正規表現の文字クラスがASCIIの範囲内でしか一致しないことがあるのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="fe1dc5c347574cf3a08e8eebfbeb7750b39e6b8c" translate="yes" xml:space="preserve">
          <source>Why do setuid perl scripts complain about kernel problems?</source>
          <target state="translated">なぜ setuid perl スクリプトはカーネルの問題について文句を言うのですか?</target>
        </trans-unit>
        <trans-unit id="026df39820ea4af121bee1f807b65636d02b2c10" translate="yes" xml:space="preserve">
          <source>Why do some characters not uppercase or lowercase correctly?</source>
          <target state="translated">大文字や小文字が正しくない文字があるのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="c99d6ee81fb9e8a95f7bcc8c77d79b83dd80d118" translate="yes" xml:space="preserve">
          <source>Why do you want to do that? :-)</source>
          <target state="translated">なぜそんなことをしたいのか :-)</target>
        </trans-unit>
        <trans-unit id="72bb63a51859ce8a03efe317ce769e0ebbe394ee" translate="yes" xml:space="preserve">
          <source>Why does Net::FTP not implement mput and mget methods</source>
          <target state="translated">Net::FTP が mput および mget メソッドを実装していないのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="c2f2d2fc2e6067abbcff0c6297133f00fea08094" translate="yes" xml:space="preserve">
          <source>Why does Net::SMTP not do DNS MX lookups ?</source>
          <target state="translated">Net::SMTP が DNS MX 検索をしないのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="bd94a8382da48e70b41ef67567b746b186c9a0e6" translate="yes" xml:space="preserve">
          <source>Why does Perl let me delete read-only files? Why does -i clobber protected files? Isn't this a bug in Perl?</source>
          <target state="translated">なぜPerlは読み取り専用のファイルを削除できるのですか?なぜ-iは保護されたファイルを削除しないのですか?これはPerlのバグではないのですか?</target>
        </trans-unit>
        <trans-unit id="cc878c7b17c2f51ef8a429a9375cb383410dd74c" translate="yes" xml:space="preserve">
          <source>Why does Perl let me delete read-only files? Why does &lt;code&gt;-i&lt;/code&gt; clobber protected files? Isn't this a bug in Perl?</source>
          <target state="translated">なぜPerlでは読み取り専用ファイルを削除できるのですか？ &lt;code&gt;-i&lt;/code&gt; clobberがファイルを保護するのはなぜですか？これはPerlのバグではありませんか？</target>
        </trans-unit>
        <trans-unit id="cab7997afd3e855e0bc949d3ba08b5a07d77bad2" translate="yes" xml:space="preserve">
          <source>Why does defined() return true on empty arrays and hashes?</source>
          <target state="translated">defined()が空の配列やハッシュに対して真を返すのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="a9078f034de31f1b296232dfb6a8a4e24d9d3fe0" translate="yes" xml:space="preserve">
          <source>Why does passing a subroutine an undefined element in a hash create it?</source>
          <target state="translated">なぜサブルーチンに未定義の要素を渡すとハッシュが作成されるのか?</target>
        </trans-unit>
        <trans-unit id="7586fa4c0b5fc90f209bbbf4172abb17863eb05e" translate="yes" xml:space="preserve">
          <source>Why does using $&amp;amp;, $`, or $' slow my program down?</source>
          <target state="translated">$＆、$ `、または$ 'を使用するとプログラムが遅くなるのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="d0d6812625a87b8571932c2c534a16df1d30c46a" translate="yes" xml:space="preserve">
          <source>Why doesn't &quot;my($foo) = &amp;lt;$fh&amp;gt;;&quot; work right?</source>
          <target state="translated">「my（$ foo）= &amp;lt;$ fh&amp;gt;;」にならないのはなぜですか 正しいですか？</target>
        </trans-unit>
        <trans-unit id="dce612b6a2414fd18ba042c0e4b6d8009b148ed5" translate="yes" xml:space="preserve">
          <source>Why doesn't &quot;my($foo) = ;&quot; work right?</source>
          <target state="translated">my($foo)=;」が正しく動作しないのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="5027566591e947a691e8c94cf6484817ceca1f52" translate="yes" xml:space="preserve">
          <source>Why doesn't &amp;amp; work the way I want it to?</source>
          <target state="translated">なぜ、思い通りに動作しないのですか？</target>
        </trans-unit>
        <trans-unit id="4cf8f75bbab1ae3d6a9b3cc517f4738f093df66a" translate="yes" xml:space="preserve">
          <source>Why doesn't glob(&quot;*.*&quot;) get all the files?</source>
          <target state="translated">なぜ glob(&quot;*.*&quot;)はすべてのファイルを取得しないのですか?</target>
        </trans-unit>
        <trans-unit id="2deaa0032d55ad3bbe4d463b92dc4d6876271de7" translate="yes" xml:space="preserve">
          <source>Why doesn't my sockets program work under System V (Solaris)? What does the error message &quot;Protocol not supported&quot; mean?</source>
          <target state="translated">システム V (Solaris)でソケットプログラムが動作しないのはなぜですか? エラーメッセージ「プロトコルがサポートされていません」は何を意味しますか?</target>
        </trans-unit>
        <trans-unit id="94b7e3ba62840111acddb7ecbcec36ba2e7bc4b2" translate="yes" xml:space="preserve">
          <source>Why doesn't open() return an error when a pipe open fails?</source>
          <target state="translated">パイプのオープンに失敗したときにopen()がエラーを返さないのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="39d80c781157cb75a05623de25db34f558131470" translate="yes" xml:space="preserve">
          <source>Why don't Perl one-liners work on my DOS/Mac/VMS system?</source>
          <target state="translated">なぜ私のDOS/Mac/VMSシステムでPerlのワンライナーが動作しないのですか?</target>
        </trans-unit>
        <trans-unit id="7efb6bacfd459d208d2e83d3ccd6f5a6e06b31a2" translate="yes" xml:space="preserve">
          <source>Why don't my &amp;lt;</source>
          <target state="translated">なぜ私の&amp;lt;</target>
        </trans-unit>
        <trans-unit id="d55b9cceedd9f6975831dcd97371f91faa17e9ba" translate="yes" xml:space="preserve">
          <source>Why don't my &amp;lt;&amp;lt;HERE documents work?</source>
          <target state="translated">&amp;lt;&amp;lt; HEREドキュメントが機能しないのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="1b729d456f5e2de755ce9ca47664753dfbd6fc06" translate="yes" xml:space="preserve">
          <source>Why don't my tied hashes make the defined/exists distinction?</source>
          <target state="translated">なぜ私のタイドハッシュは定義された/存在の区別をしないのですか?</target>
        </trans-unit>
        <trans-unit id="ec879bc347cf004a28479d385b991508d06231e9" translate="yes" xml:space="preserve">
          <source>Why don't word-boundary searches with &lt;code&gt;\b&lt;/code&gt; work for me?</source>
          <target state="translated">&lt;code&gt;\b&lt;/code&gt; を使用した単語境界検索が機能しないのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="123e5244abcc6475513e58c7be3baf1e624a09b7" translate="yes" xml:space="preserve">
          <source>Why don't word-boundary searches with \b work for me?</source>
          <target state="translated">Why don't work with \b with word-boundary search for me?</target>
        </trans-unit>
        <trans-unit id="aa0f337d4d9c4331ea81d21ad3497b56fec40614" translate="yes" xml:space="preserve">
          <source>Why dynamic linking?</source>
          <target state="translated">なぜダイナミックリンクなのか?</target>
        </trans-unit>
        <trans-unit id="4dfd253727c4f99a421a3b97c6c33e70ca139825" translate="yes" xml:space="preserve">
          <source>Why is int() broken?</source>
          <target state="translated">なぜ int()は壊れているのですか?</target>
        </trans-unit>
        <trans-unit id="a9539bbca1f0e44580627232613c4e6433a9dda3" translate="yes" xml:space="preserve">
          <source>Why is there Perl source in my database?</source>
          <target state="translated">なぜ私のデータベースにPerlのソースがあるのですか?</target>
        </trans-unit>
        <trans-unit id="5376410df92e4e194b5ef26e3120b8356d39f687" translate="yes" xml:space="preserve">
          <source>Why isn't my octal data interpreted correctly?</source>
          <target state="translated">私の八進数データが正しく解釈されないのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="76e636f7e8860a670fadde05e6d7c8a9de0467dd" translate="yes" xml:space="preserve">
          <source>Why not just use &amp;lt;insert other build config tool here&amp;gt;?</source>
          <target state="translated">&amp;lt;ここに他のビルド構成ツールを挿入&amp;gt;を使用しないのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="8adf1b58b38027864f2d28cd98aeb834dee11ea7" translate="yes" xml:space="preserve">
          <source>Why strange names?</source>
          <target state="translated">なぜ変な名前なのか?</target>
        </trans-unit>
        <trans-unit id="d2f963c70a1ed1fc561f572fe023203fb76a83ae" translate="yes" xml:space="preserve">
          <source>Why the heck Encode API is different?</source>
          <target state="translated">なぜEncode APIは違うのか?</target>
        </trans-unit>
        <trans-unit id="2d967f841c57d824cac2c9266688fd2aa1c5db9c" translate="yes" xml:space="preserve">
          <source>Why use ppport.h?</source>
          <target state="translated">なぜppport.hを使うのか?</target>
        </trans-unit>
        <trans-unit id="df4212a2d988730cb90863e6978ac9cd91d10bdc" translate="yes" xml:space="preserve">
          <source>Why would you want a hash of lists? Let's take a simple example: You have a file of city and country names, like this:</source>
          <target state="translated">なぜリストのハッシュが欲しいのか?簡単な例を見てみましょう。あなたはこのような都市名と国名のファイルを持っています。</target>
        </trans-unit>
        <trans-unit id="7f3771c096b7c324730a1a8a01295eb54a206ffa" translate="yes" xml:space="preserve">
          <source>Why, you may ask, would you need a chunk of memory containing some values in binary representation? One good reason is input and output accessing some file, a device, or a network connection, whereby this binary representation is either forced on you or will give you some benefit in processing. Another cause is passing data to some system call that is not available as a Perl function: &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; requires you to provide parameters stored in the way it happens in a C program. Even text processing (as shown in the next section) may be simplified with judicious usage of these two functions.</source>
          <target state="translated">なぜあなたは尋ねるかもしれませんが、バイナリ表現のいくつかの値を含むメモリのチャンクが必要なのでしょうか？適切な理由の1つは、入出力が何らかのファイル、デバイス、またはネットワーク接続にアクセスすることです。これにより、このバイナリ表現が強制されるか、処理に何らかの利点がもたらされます。もう1つの原因は、Perl関数として使用できないシステムコールにデータを渡すことです &lt;code&gt;&lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;&lt;/code&gt; では、Cプログラムで発生する方法で格納されたパラメーターを提供する必要があります。これらの2つの関数を適切に使用することで、テキスト処理（次のセクションに示す）も簡略化できます。</target>
        </trans-unit>
        <trans-unit id="6ab0396ba481d1f15a966e8a80a53c0fff8a6b1e" translate="yes" xml:space="preserve">
          <source>Why, you may ask, would you need a chunk of memory containing some values in binary representation? One good reason is input and output accessing some file, a device, or a network connection, whereby this binary representation is either forced on you or will give you some benefit in processing. Another cause is passing data to some system call that is not available as a Perl function: &lt;code&gt;syscall&lt;/code&gt; requires you to provide parameters stored in the way it happens in a C program. Even text processing (as shown in the next section) may be simplified with judicious usage of these two functions.</source>
          <target state="translated">なぜ、バイナリ表現でいくつかの値を含むメモリのチャンクが必要なのかと疑問に思うかもしれません。正当な理由の1つは、ファイル、デバイス、またはネットワーク接続にアクセスする入出力です。これにより、このバイナリ表現が強制されるか、処理に何らかの利点がもたらされます。もう1つの原因は、Perl関数として使用できないシステムコールにデータを渡すことです &lt;code&gt;syscall&lt;/code&gt; では、Cプログラムで発生する方法で格納されたパラメーターを指定する必要があります。 （次のセクションで示すように）テキスト処理でさえ、これら2つの関数を適切に使用することで簡略化できます。</target>
        </trans-unit>
        <trans-unit id="d1b95af46a7dc5483f3c0502e26f80b536b33809" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;can&lt;/code&gt; returns a coderef to mean &quot;yes it can (and the method is this...)&quot;, and then &lt;code&gt;ok&lt;/code&gt; sees a coderef and thinks you're passing a function that you want it to call and consider the truth of the result of! I.e., just like:</source>
          <target state="translated">どうして？ので &lt;code&gt;can&lt;/code&gt; 意味するようにコードリファレンスを返します。「はい、それはすることができます（この方法はこれです...）」、次に &lt;code&gt;ok&lt;/code&gt; コードリファレンスを見て、あなたはそれが結果の真実を呼び出すと考えたいという関数を渡していると考えての！つまり、次のように：</target>
        </trans-unit>
        <trans-unit id="c682a5bde8a3f0f1d13f9a9af66f849014ab6208" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;nasty_break()&lt;/code&gt; modifies &lt;code&gt;$\&lt;/code&gt; without localizing it first. The value you set in &lt;code&gt;nasty_break()&lt;/code&gt; is still there when you return. The fix is to add &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; so the value doesn't leak out of &lt;code&gt;nasty_break()&lt;/code&gt; :</source>
          <target state="translated">どうして？ &lt;code&gt;nasty_break()&lt;/code&gt; は、最初にローカライズせずに &lt;code&gt;$\&lt;/code&gt; を変更するためです。 &lt;code&gt;nasty_break()&lt;/code&gt; で設定した値は、戻ったときも残っています。修正は、値が &lt;code&gt;nasty_break()&lt;/code&gt; からリークしないように &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local()&lt;/a&gt;&lt;/code&gt; を追加することです。</target>
        </trans-unit>
        <trans-unit id="a6faa641a92e7908b2759e3d399e519a97396eeb" translate="yes" xml:space="preserve">
          <source>Why? Because &lt;code&gt;nasty_break()&lt;/code&gt; modifies &lt;code&gt;$\&lt;/code&gt; without localizing it first. The value you set in &lt;code&gt;nasty_break()&lt;/code&gt; is still there when you return. The fix is to add &lt;code&gt;local()&lt;/code&gt; so the value doesn't leak out of &lt;code&gt;nasty_break()&lt;/code&gt;:</source>
          <target state="translated">どうして？ &lt;code&gt;nasty_break()&lt;/code&gt; は、最初にローカライズせずに &lt;code&gt;$\&lt;/code&gt; を変更するためです。 &lt;code&gt;nasty_break()&lt;/code&gt; で設定した値は、戻ってもそのままです。修正は、値が &lt;code&gt;nasty_break()&lt;/code&gt; からリークしないように &lt;code&gt;local()&lt;/code&gt; を追加することです：</target>
        </trans-unit>
        <trans-unit id="e2a097ba046d774750c25655e60293a973b6be9d" translate="yes" xml:space="preserve">
          <source>Wide character (U+%X) in %s</source>
          <target state="translated">%s のワイド文字 (U+%X)</target>
        </trans-unit>
        <trans-unit id="745ada6d8a512f870963c08fe697c0dd823de817" translate="yes" xml:space="preserve">
          <source>Wide character in %s</source>
          <target state="translated">%s のワイド文字</target>
        </trans-unit>
        <trans-unit id="59af40d4a351e635fdbe369d7b681d20a590a23a" translate="yes" xml:space="preserve">
          <source>Wildcard expansion</source>
          <target state="translated">ワイルドカード拡張</target>
        </trans-unit>
        <trans-unit id="47c9b4ee449bd8455aec29f4590e9aaa03c049f4" translate="yes" xml:space="preserve">
          <source>Wildcards in Property Values</source>
          <target state="translated">プロパティ値のワイルドカード</target>
        </trans-unit>
        <trans-unit id="70477b387f14e0143de5873f3a9e791508ea1046" translate="yes" xml:space="preserve">
          <source>Will My Old Scripts Break?</source>
          <target state="translated">古いスクリプトは壊れますか?</target>
        </trans-unit>
        <trans-unit id="2873c6e6e5880b670c065bcdc4a78243fbadf06c" translate="yes" xml:space="preserve">
          <source>Will Sheppard &amp;lt;</source>
          <target state="translated">シェパード&amp;lt;</target>
        </trans-unit>
        <trans-unit id="2758b8d4c9377404295cf137b65b7a19678f3231" translate="yes" xml:space="preserve">
          <source>Will add a file to the in-memory archive, with name &lt;code&gt;$filename&lt;/code&gt; and content &lt;code&gt;$data&lt;/code&gt; . Specific properties can be set using &lt;code&gt;$opthashref&lt;/code&gt; . The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type. (On MacOS, the file's path and modification times are converted to Unix equivalents.)</source>
          <target state="translated">名前が &lt;code&gt;$filename&lt;/code&gt; でコンテンツが &lt;code&gt;$data&lt;/code&gt; ファイルをメモリ内アーカイブに追加します。 &lt;code&gt;$opthashref&lt;/code&gt; を使用して特定のプロパティを設定できます。プロパティの次のリストがサポートされています：名前、サイズ、mtime（最終更新日）、モード、uid、gid、linkname、uname、gname、devmajor、devminor、プレフィックス、タイプ。（MacOSでは、ファイルのパスと変更時刻はUnixの同等のものに変換されます。）</target>
        </trans-unit>
        <trans-unit id="93e582e568148c77bec33609334f756f428deffa" translate="yes" xml:space="preserve">
          <source>Will add a file to the in-memory archive, with name &lt;code&gt;$filename&lt;/code&gt; and content &lt;code&gt;$data&lt;/code&gt;. Specific properties can be set using &lt;code&gt;$opthashref&lt;/code&gt;. The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type. (On MacOS, the file's path and modification times are converted to Unix equivalents.)</source>
          <target state="translated">名前が &lt;code&gt;$filename&lt;/code&gt; でコンテンツが &lt;code&gt;$data&lt;/code&gt; ファイルをメモリ内アーカイブに追加します。 &lt;code&gt;$opthashref&lt;/code&gt; を使用して、特定のプロパティを設定できます。次のプロパティのリストがサポートされています：name、size、mtime（最終変更日）、mode、uid、gid、linkname、uname、gname、devmajor、devminor、prefix、type。（MacOSでは、ファイルのパスと変更時間は同等のUnixに変換されます。）</target>
        </trans-unit>
        <trans-unit id="af66cccfd8aea183b531eebc0a74a7e923052ebf" translate="yes" xml:space="preserve">
          <source>Will be called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens. (See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; が発生すると呼び出されます。（下記&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;のuntie Gotchaを&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="3135cfa6b9641d632048427137e9d839208222a7" translate="yes" xml:space="preserve">
          <source>Will be called when &lt;code&gt;untie&lt;/code&gt; happens. (See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&quot;The &lt;code&gt;untie&lt;/code&gt; Gotcha&quot;&lt;/a&gt; below.)</source>
          <target state="translated">&lt;code&gt;untie&lt;/code&gt; が発生したときに呼び出されます。（下記の&lt;a href=&quot;#The-untie-Gotcha&quot;&gt;「 &lt;code&gt;untie&lt;/code&gt; ゴッチャ」を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="5c123e132f25bf178be9ea2aca72fafe2969081c" translate="yes" xml:space="preserve">
          <source>Will be loaded on demand and called automatically by BigInt.</source>
          <target state="translated">必要に応じてロードされ、BigIntによって自動的に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="a669aaf9a433f6903c152ca38a90c9c7cb258f3e" translate="yes" xml:space="preserve">
          <source>Will be prepended to each install path.</source>
          <target state="translated">各インストールパスの前に付加されます。</target>
        </trans-unit>
        <trans-unit id="4532ff2be2d0615be4c0aa19707d4e886e5a1789" translate="yes" xml:space="preserve">
          <source>Will be set to a uuid if uuid tagging was enabled.</source>
          <target state="translated">uuidタグ付けが有効になっている場合、uuidに設定されます。</target>
        </trans-unit>
        <trans-unit id="9f18d29650d7b716edb7780278b512b0a8a59170" translate="yes" xml:space="preserve">
          <source>Will be used to modify the padding applied to string as described above.</source>
          <target state="translated">上記のように文字列に適用されるパディングを変更するために使用されます。</target>
        </trans-unit>
        <trans-unit id="4e827c2a869b099543f874a4407588358567998d" translate="yes" xml:space="preserve">
          <source>Will both leave the sentence as is. Normally, when accepting literal string input from the user, &lt;a href=&quot;#quotemeta-EXPR&quot;&gt;&lt;code&gt;quotemeta&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;\Q&lt;/code&gt; must be used.</source>
          <target state="translated">どちらも文をそのままにします。通常、ユーザーからのリテラル文字列入力を受け入れる場合は、&lt;a href=&quot;#quotemeta-EXPR&quot;&gt; &lt;code&gt;quotemeta&lt;/code&gt; &lt;/a&gt;または &lt;code&gt;\Q&lt;/code&gt; 使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="a659ce6bd28efeb251560042f49a1924dca7c4a4" translate="yes" xml:space="preserve">
          <source>Will both leave the sentence as is. Normally, when accepting literal string input from the user, quotemeta() or &lt;code&gt;\Q&lt;/code&gt; must be used.</source>
          <target state="translated">どちらもそのまま文を残します。通常、ユーザーからリテラル文字列入力を受け入れる場合は、quotemeta（）または &lt;code&gt;\Q&lt;/code&gt; 使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="10fbb1ac2af71320cfd2110a94f422695cba5311" translate="yes" xml:space="preserve">
          <source>Will cause &lt;code&gt;$sentence&lt;/code&gt; to become &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; .</source>
          <target state="translated">原因となります &lt;code&gt;$sentence&lt;/code&gt; になることを &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10dc8768858451ca68c298fbc7a5ad46babe9c5d" translate="yes" xml:space="preserve">
          <source>Will cause &lt;code&gt;$sentence&lt;/code&gt; to become &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt;.</source>
          <target state="translated">原因となります &lt;code&gt;$sentence&lt;/code&gt; になることを &lt;code&gt;'The big bad wolf jumped over...'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66fbedfbffb0f55bc116220f01908ca58f12e965" translate="yes" xml:space="preserve">
          <source>Will croak() if there is an error.</source>
          <target state="translated">エラーが発生した場合は croak()を実行します。</target>
        </trans-unit>
        <trans-unit id="a89e6d7112dafb5b2ad3a46406c0ced36b7d13b7" translate="yes" xml:space="preserve">
          <source>Will die() if called on r-magic.</source>
          <target state="translated">r-magic で呼び出された場合は die()します。</target>
        </trans-unit>
        <trans-unit id="0768298b9a0627e90df27324883d97a236031b2a" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Handy for things like...</source>
          <target state="translated">リファレンスの内容を人間が読める形式でダンプします。以下のような場合に便利です。</target>
        </trans-unit>
        <trans-unit id="481a8de568a61f103c3af4da9f82b1f103a46712" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Usually you want to pass this into &lt;code&gt;note&lt;/code&gt; or &lt;code&gt;diag&lt;/code&gt; .</source>
          <target state="translated">参照の内容を人間が読める形式でダンプします。通常、これを &lt;code&gt;note&lt;/code&gt; または &lt;code&gt;diag&lt;/code&gt; に渡します。</target>
        </trans-unit>
        <trans-unit id="cdc14d4349b2640a0197394413323e6c4dc94091" translate="yes" xml:space="preserve">
          <source>Will dump the contents of any references in a human readable format. Usually you want to pass this into &lt;code&gt;note&lt;/code&gt; or &lt;code&gt;diag&lt;/code&gt;.</source>
          <target state="translated">参照の内容を人間が読める形式でダンプします。通常、これを &lt;code&gt;note&lt;/code&gt; または &lt;code&gt;diag&lt;/code&gt; に渡します。</target>
        </trans-unit>
        <trans-unit id="75f83221407c4472808dc0bb2139500f5229338d" translate="yes" xml:space="preserve">
          <source>Will force the generation of test code that uses the older &lt;code&gt;Test&lt;/code&gt; module.</source>
          <target state="translated">古い &lt;code&gt;Test&lt;/code&gt; モジュールを使用するテストコードを強制的に生成します。</target>
        </trans-unit>
        <trans-unit id="a329a554ce0cef11ca3198cc6cf9ba23c8d4f77f" translate="yes" xml:space="preserve">
          <source>Will incorrectly print</source>
          <target state="translated">不正確に印刷されます</target>
        </trans-unit>
        <trans-unit id="fe4d3313b3f93ee1361d2d67710393a85713398e" translate="yes" xml:space="preserve">
          <source>Will invoke a sub at the end of a (compile-time) scope. The sub is called once with no arguments. Can be called multiple times (even in the same &quot;compile-time&quot; scope) to install multiple subs. Subs are called in a &quot;first-in-last-out&quot;-order (FILO or &quot;stack&quot;-order).</source>
          <target state="translated">(コンパイル時の)スコープの最後にサブを呼び出します。サブは、引数なしで一度だけ呼び出されます。 サブは、&quot;first-in-last-out&quot; オーダー (FILO または &quot;stack&quot; オーダー)で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="c610d24bbac520a7e0e174e12fe1f23a3ae5f9e4" translate="yes" xml:space="preserve">
          <source>Will make sure that =head1 will become &amp;lt;h3&amp;gt; and =head2 will become &amp;lt;h4&amp;gt; etc...</source>
          <target state="translated">= head1が&amp;lt;h3&amp;gt;になり、= head2が&amp;lt;h4&amp;gt;になることを確認します...</target>
        </trans-unit>
        <trans-unit id="49024b4120de3dd67c62575e0a4eb5f193ed6c22" translate="yes" xml:space="preserve">
          <source>Will not cause &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; to re-read the directory stream. The entries already read before the &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; call will just be returned again from a cache buffer. (Win32)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; がディレクトリストリームを再度読み取ることはありません。 &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir()&lt;/a&gt;&lt;/code&gt; 呼び出しの前にすでに読み込まれたエントリは、キャッシュバッファから再び返されるだけです。（Win32）</target>
        </trans-unit>
        <trans-unit id="845d623fd40095b89ded11a672446e7d8d2933f3" translate="yes" xml:space="preserve">
          <source>Will not exceed this limit even if the string is not valid &quot;UTF-8&quot;.</source>
          <target state="translated">文字列が &quot;UTF-8 &quot;でない場合でも、この制限を超えません。</target>
        </trans-unit>
        <trans-unit id="7706e40a252d341368a094f13349cb965c7bcf44" translate="yes" xml:space="preserve">
          <source>Will not exceed those limits even if the string is not valid &quot;UTF-8&quot;.</source>
          <target state="translated">文字列が &quot;UTF-8 &quot;でない場合でも、その制限を超えることはありません。</target>
        </trans-unit>
        <trans-unit id="0b4b57e33203662ee1ddac498725ec0cbd902da5" translate="yes" xml:space="preserve">
          <source>Will not work on platforms that do not support the &lt;code&gt;-k&lt;/code&gt; test for sticky bit.</source>
          <target state="translated">スティッキービットの &lt;code&gt;-k&lt;/code&gt; テストをサポートしていないプラットフォームでは機能しません。</target>
        </trans-unit>
        <trans-unit id="aff13c5ad9d691f5f29f20db0a92fc55a16499de" translate="yes" xml:space="preserve">
          <source>Will not work on platforms that do not support the C test for sticky bit.</source>
          <target state="translated">スティッキービットのCテストをサポートしていないプラットフォームでは動作しません。</target>
        </trans-unit>
        <trans-unit id="19ad79cf64559535aa01bc2039517ce48ed1f305" translate="yes" xml:space="preserve">
          <source>Will output 2, not 1. This is particularly important if you intend to compile the definitions with the &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator, and later interpolate them in another pattern.</source>
          <target state="translated">1ではなく2を出力します。これは、 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 演算子を使用して定義をコンパイルし、後で別のパターンで補間する場合に特に重要です。</target>
        </trans-unit>
        <trans-unit id="d7ba12340e687f11ed70710aaea6e46b38d77b8f" translate="yes" xml:space="preserve">
          <source>Will output 2, not 1. This is particularly important if you intend to compile the definitions with the &lt;code&gt;qr//&lt;/code&gt; operator, and later interpolate them in another pattern.</source>
          <target state="translated">1ではなく2を出力します。これは、 &lt;code&gt;qr//&lt;/code&gt; 演算子を使用して定義をコンパイルし、後で別のパターンで補間する場合に特に重要です。</target>
        </trans-unit>
        <trans-unit id="10021ccb8e306fb831263dee40b8f7ca24084b5a" translate="yes" xml:space="preserve">
          <source>Will prevent the automatic use of INSTALL.SKIP as the install skip file.</source>
          <target state="translated">インストールスキップファイルとして INSTALL.SKIP が自動的に使用されないようにします。</target>
        </trans-unit>
        <trans-unit id="897aeeccb9736732e15f96f20d971e76dcd3a8ff" translate="yes" xml:space="preserve">
          <source>Will print &lt;code&gt;2&lt;/code&gt; , because &lt;code&gt;$string&lt;/code&gt; is upgraded as UTF-8. Without &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding 'utf8';&lt;/code&gt; , it will print &lt;code&gt;4&lt;/code&gt; instead, since &lt;code&gt;$string&lt;/code&gt; is three octets when interpreted as Latin-1.</source>
          <target state="translated">印刷される &lt;code&gt;2&lt;/code&gt; をするので、 &lt;code&gt;$string&lt;/code&gt; UTF-8としてアップグレードされます。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding 'utf8';&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用し&lt;/a&gt;ない場合 ; 、 &lt;code&gt;$string&lt;/code&gt; はLatin-1として解釈されると3オクテットであるため、代わりに &lt;code&gt;4&lt;/code&gt; を出力します。</target>
        </trans-unit>
        <trans-unit id="c7912cc2705e39fd55074c6583f91d53d1be3b82" translate="yes" xml:space="preserve">
          <source>Will print &lt;code&gt;2&lt;/code&gt;, because &lt;code&gt;$string&lt;/code&gt; is upgraded as UTF-8. Without &lt;code&gt;use encoding 'utf8';&lt;/code&gt;, it will print &lt;code&gt;4&lt;/code&gt; instead, since &lt;code&gt;$string&lt;/code&gt; is three octets when interpreted as Latin-1.</source>
          <target state="translated">印刷される &lt;code&gt;2&lt;/code&gt; をするので、 &lt;code&gt;$string&lt;/code&gt; UTF-8としてアップグレードされます。 &lt;code&gt;use encoding 'utf8';&lt;/code&gt; せずに'utf8'; 、Latin-1として解釈される場合、 &lt;code&gt;$string&lt;/code&gt; は3オクテットであるため、代わりに &lt;code&gt;4&lt;/code&gt; が出力されます。</target>
        </trans-unit>
        <trans-unit id="ceca318096ebec569ca5ded9c24fde055f72cece" translate="yes" xml:space="preserve">
          <source>Will print just the value of &lt;code&gt;$x&lt;/code&gt;, believing that &lt;code&gt;$y&lt;/code&gt; is a numerically- equivalent value. This bug does not affect &lt;code&gt;uniqstr()&lt;/code&gt;, which will correctly observe that the two values stringify to different strings.</source>
          <target state="translated">&lt;code&gt;$y&lt;/code&gt; が数値的に同等の値であると信じて、 &lt;code&gt;$x&lt;/code&gt; の値だけを出力します。このバグは &lt;code&gt;uniqstr()&lt;/code&gt; には影響しません。これは、2つの値が異なる文字列に文字列化されることを正しく監視します。</target>
        </trans-unit>
        <trans-unit id="f950740e9c08c94cdc9c22017e9c8d9e11964004" translate="yes" xml:space="preserve">
          <source>Will produce something like this:</source>
          <target state="translated">このようなものができあがります。</target>
        </trans-unit>
        <trans-unit id="73c023c285973466729ee2bf21a0f578281a6002" translate="yes" xml:space="preserve">
          <source>Will return a list of two sockets created (read and write), or an empty list on failure.</source>
          <target state="translated">作成された2つのソケットのリスト(読み書き)、または失敗した場合は空のリストを返します。</target>
        </trans-unit>
        <trans-unit id="b2e73c78b5d339922fd7fb53696709fc79fcc290" translate="yes" xml:space="preserve">
          <source>Will use &lt;a href=&quot;TAP::Harness::Archive&quot;&gt;TAP::Harness::Archive&lt;/a&gt; as the harness class, and save the TAP to &lt;code&gt;file.tgz&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;TAP::Harness::Archive&quot;&gt;TAP :: Harness :: Archive&lt;/a&gt;をハーネスクラスとして使用し、TAPを &lt;code&gt;file.tgz&lt;/code&gt; に保存します</target>
        </trans-unit>
        <trans-unit id="db8fa98164c98267f0158f423a3da70d388112fe" translate="yes" xml:space="preserve">
          <source>Will use &lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Harness::Archive&quot;&gt;TAP::Harness::Archive&lt;/a&gt; as the harness class, and save the TAP to &lt;code&gt;file.tgz&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/TAP::Harness::Archive&quot;&gt;TAP :: Harness :: Archive&lt;/a&gt;をハーネスクラスとして使用し、TAPを &lt;code&gt;file.tgz&lt;/code&gt; に保存します</target>
        </trans-unit>
        <trans-unit id="7b653c1a1342f29b6e1ca16ef44b1d14c98a11e3" translate="yes" xml:space="preserve">
          <source>Win32</source>
          <target state="translated">Win32</target>
        </trans-unit>
        <trans-unit id="193cb801459c22b68d471c2735c8916bade862e2" translate="yes" xml:space="preserve">
          <source>Win32 - Interfaces to some Win32 API Functions</source>
          <target state="translated">Win32-いくつかの Win32 API 関数へのインターフェイス</target>
        </trans-unit>
        <trans-unit id="d2fdadddae42eb18256ba3d6c7445968142a4fd2" translate="yes" xml:space="preserve">
          <source>Win32 CORE function stubs</source>
          <target state="translated">Win32 コア関数のスタブ</target>
        </trans-unit>
        <trans-unit id="0cab5c56f7d1ce7bc278eb6ee5c4a8575346a7ef" translate="yes" xml:space="preserve">
          <source>Win32 implementation</source>
          <target state="translated">ウィン32実装</target>
        </trans-unit>
        <trans-unit id="c331f9a552ce93a52bd3bbd4fbac9c58a662301b" translate="yes" xml:space="preserve">
          <source>Win32 support for Sys::Syslog</source>
          <target state="translated">Sys::Syslog の Win32 サポート</target>
        </trans-unit>
        <trans-unit id="263a800b140dc4fe3448979f4261e583bcee830e" translate="yes" xml:space="preserve">
          <source>Win32 users should use the real slash. If you really want to use backslashes, consider using Sarathy's File::DosGlob, which comes with the standard Perl distribution.</source>
          <target state="translated">Win32ユーザは本当のスラッシュを使うべきです。本当にバックスラッシュを使いたいのであれば、標準の Perl ディストリビューションに付属している Sarathy の File::DosGlob の使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="6d0e1038c340ca3cf2b59ac852b5f2ef7407e5c9" translate="yes" xml:space="preserve">
          <source>Win32::AbortSystemShutdown(MACHINE)</source>
          <target state="translated">Win32::AbortSystemShutdown(MACHINE)</target>
        </trans-unit>
        <trans-unit id="6f12fa420b1205100cabb4570f237b3d345d86ca" translate="yes" xml:space="preserve">
          <source>Win32::BuildNumber()</source>
          <target state="translated">Win32::BuildNumber()</target>
        </trans-unit>
        <trans-unit id="99f20893b3ea998d83c35a43b1ddcaefd97d6b9f" translate="yes" xml:space="preserve">
          <source>Win32::CopyFile(FROM, TO, OVERWRITE)</source>
          <target state="translated">Win32::CopyFile(FROM,TO,OVERWRITE)</target>
        </trans-unit>
        <trans-unit id="d269bfa64c0a58bda1986a24d2c54a63190e288a" translate="yes" xml:space="preserve">
          <source>Win32::CreateDirectory(DIRECTORY)</source>
          <target state="translated">Win32::CreateDirectory(DIRECTORY)</target>
        </trans-unit>
        <trans-unit id="7a7983d24568164c28a76c5bb077686f88dad153" translate="yes" xml:space="preserve">
          <source>Win32::CreateFile(FILE)</source>
          <target state="translated">Win32::CreateFile(FILE)</target>
        </trans-unit>
        <trans-unit id="fa7c1f0bbed5b785d5607e1311dcb11968fd8fe9" translate="yes" xml:space="preserve">
          <source>Win32::DomainName()</source>
          <target state="translated">Win32::DomainName()</target>
        </trans-unit>
        <trans-unit id="1c453bb935414d8146aa602c45dd5159dab45ade" translate="yes" xml:space="preserve">
          <source>Win32::ExpandEnvironmentStrings(STRING)</source>
          <target state="translated">Win32::ExpandEnvironmentStrings(STRING)</target>
        </trans-unit>
        <trans-unit id="88134ad369f40cbd5ed8e6414b571501a615d721" translate="yes" xml:space="preserve">
          <source>Win32::FormatMessage(ERRORCODE)</source>
          <target state="translated">Win32::FormatMessage(ERRORCODE)</target>
        </trans-unit>
        <trans-unit id="02c33521b3e0cfb9be57585db645c4568be060cf" translate="yes" xml:space="preserve">
          <source>Win32::FreeLibrary(HANDLE)</source>
          <target state="translated">Win32::FreeLibrary(HANDLE)</target>
        </trans-unit>
        <trans-unit id="ec6d95684a511580632674e1e5dce99eca02ed2c" translate="yes" xml:space="preserve">
          <source>Win32::FsType()</source>
          <target state="translated">Win32::FsType()</target>
        </trans-unit>
        <trans-unit id="fdfbfe52059c529a42a7f79b351a29683dd786d2" translate="yes" xml:space="preserve">
          <source>Win32::GUI</source>
          <target state="translated">Win32::GUI</target>
        </trans-unit>
        <trans-unit id="cc575cb0ebbd64ea43f9c9ccc56237b0705f9732" translate="yes" xml:space="preserve">
          <source>Win32::GetACP()</source>
          <target state="translated">Win32::GetACP()</target>
        </trans-unit>
        <trans-unit id="7798f250e449938fcf7dadf70c029ad54f636245" translate="yes" xml:space="preserve">
          <source>Win32::GetANSIPathName(FILENAME)</source>
          <target state="translated">Win32::GetANSIPathName(FILENAME)</target>
        </trans-unit>
        <trans-unit id="58ac17861a87852820b146e725b1e3c3e23cbe3e" translate="yes" xml:space="preserve">
          <source>Win32::GetArchName()</source>
          <target state="translated">Win32::GetArchName()</target>
        </trans-unit>
        <trans-unit id="3834fcd21d4e7fa28d350d64b78639660bbeb2c1" translate="yes" xml:space="preserve">
          <source>Win32::GetChipName()</source>
          <target state="translated">Win32::GetChipName()</target>
        </trans-unit>
        <trans-unit id="202596ea6840cbe9f281840b431aa41aec8424c4" translate="yes" xml:space="preserve">
          <source>Win32::GetConsoleCP()</source>
          <target state="translated">Win32::GetConsoleCP()</target>
        </trans-unit>
        <trans-unit id="8aaff4afc4c9f3d83ba6558614d36b7f40e38e33" translate="yes" xml:space="preserve">
          <source>Win32::GetConsoleOutputCP()</source>
          <target state="translated">Win32::GetConsoleOutputCP()</target>
        </trans-unit>
        <trans-unit id="ebc6f60b70df25fd8c32e53de9a7c9ba577f15ee" translate="yes" xml:space="preserve">
          <source>Win32::GetCurrentProcessId()</source>
          <target state="translated">Win32::GetCurrentProcessId()</target>
        </trans-unit>
        <trans-unit id="41cb4ff89334195c85ec80a4293eee0fe84b1c77" translate="yes" xml:space="preserve">
          <source>Win32::GetCurrentThreadId()</source>
          <target state="translated">Win32::GetCurrentThreadId()</target>
        </trans-unit>
        <trans-unit id="06fb2ae0e34c762652f91cc4b24d288d543148dd" translate="yes" xml:space="preserve">
          <source>Win32::GetCwd()</source>
          <target state="translated">Win32::GetCwd()</target>
        </trans-unit>
        <trans-unit id="424bc0808437c0c40f8b8eca83c71486de0c2ce3" translate="yes" xml:space="preserve">
          <source>Win32::GetFileVersion(FILENAME)</source>
          <target state="translated">Win32::GetFileVersion(FILENAME)</target>
        </trans-unit>
        <trans-unit id="bd89672cc22e170bdb15759f5b2c202ee866d3af" translate="yes" xml:space="preserve">
          <source>Win32::GetFolderPath(FOLDER [, CREATE])</source>
          <target state="translated">Win32::GetFolderPath(FOLDER [,CREATE])</target>
        </trans-unit>
        <trans-unit id="f7750debc5964ef700caa1d205774c5c516e86b5" translate="yes" xml:space="preserve">
          <source>Win32::GetFullPathName(FILENAME)</source>
          <target state="translated">Win32::GetFullPathName(FILENAME)</target>
        </trans-unit>
        <trans-unit id="1779b4a74c4e9c74750b4883d1c3a13e7f082821" translate="yes" xml:space="preserve">
          <source>Win32::GetLastError()</source>
          <target state="translated">Win32::GetLastError()</target>
        </trans-unit>
        <trans-unit id="c1d2be25cd4c6103e621d159ba09f9b5f7b7f66d" translate="yes" xml:space="preserve">
          <source>Win32::GetLongPathName(PATHNAME)</source>
          <target state="translated">Win32::GetLongPathName(PATHNAME)</target>
        </trans-unit>
        <trans-unit id="9a5b08237dd1d9c044b42e330417a8ee6c2fddc5" translate="yes" xml:space="preserve">
          <source>Win32::GetNextAvailDrive()</source>
          <target state="translated">Win32::GetNextAvailDrive()</target>
        </trans-unit>
        <trans-unit id="424731cf281e1dda51d3e9681cc85bb2740bbe76" translate="yes" xml:space="preserve">
          <source>Win32::GetOEMCP()</source>
          <target state="translated">Win32::GetOEMCP()</target>
        </trans-unit>
        <trans-unit id="1015f265e18dde79b1939bf46d05753e1cb1fc0a" translate="yes" xml:space="preserve">
          <source>Win32::GetOSDisplayName()</source>
          <target state="translated">Win32::GetOSDisplayName()</target>
        </trans-unit>
        <trans-unit id="e9e643f122af1698a8771b07d042a8eb421add6b" translate="yes" xml:space="preserve">
          <source>Win32::GetOSName()</source>
          <target state="translated">Win32::GetOSName()</target>
        </trans-unit>
        <trans-unit id="9ac415285a2a80e417f87a22967bf20ef2c63935" translate="yes" xml:space="preserve">
          <source>Win32::GetOSVersion()</source>
          <target state="translated">Win32::GetOSVersion()</target>
        </trans-unit>
        <trans-unit id="bbb14f64d25ca5875dac81a570aa2578d64fe870" translate="yes" xml:space="preserve">
          <source>Win32::GetProcAddress(INSTANCE, PROCNAME)</source>
          <target state="translated">Win32::GetProcAddress(INSTANCE,PROCNAME)</target>
        </trans-unit>
        <trans-unit id="0d4519c40934e76bc7c24e8acfe3fe14ba43d63f" translate="yes" xml:space="preserve">
          <source>Win32::GetProductInfo(OSMAJOR, OSMINOR, SPMAJOR, SPMINOR)</source>
          <target state="translated">Win32::GetProductInfo(OSMAJOR,OSMINOR,SPMAJOR,SPMINOR)</target>
        </trans-unit>
        <trans-unit id="976bea2f0bcf19569dea7f3dcd696ad17b85b2c9" translate="yes" xml:space="preserve">
          <source>Win32::GetShortPathName(PATHNAME)</source>
          <target state="translated">Win32::GetShortPathName(PATHNAME)</target>
        </trans-unit>
        <trans-unit id="85686486692a83787d94a67516a3d3724180155d" translate="yes" xml:space="preserve">
          <source>Win32::GetSystemMetrics(INDEX)</source>
          <target state="translated">Win32::GetSystemMetrics(INDEX)</target>
        </trans-unit>
        <trans-unit id="da2531353eddaf6094a844bf9d9cb759ae2af1e8" translate="yes" xml:space="preserve">
          <source>Win32::GetTickCount()</source>
          <target state="translated">Win32::GetTickCount()</target>
        </trans-unit>
        <trans-unit id="ae35ac71f2f974fbd4820718cb015468050c4f6c" translate="yes" xml:space="preserve">
          <source>Win32::GuidGen()</source>
          <target state="translated">Win32::GuidGen()</target>
        </trans-unit>
        <trans-unit id="6c1bb229532a2f942fc09792beca570bb3feca1b" translate="yes" xml:space="preserve">
          <source>Win32::InitiateSystemShutdown</source>
          <target state="translated">Win32::InitiateSystemShutdown</target>
        </trans-unit>
        <trans-unit id="f9fa2b44699da87d011d8d62354503f774420ab1" translate="yes" xml:space="preserve">
          <source>Win32::IsAdminUser()</source>
          <target state="translated">Win32::IsAdminUser()</target>
        </trans-unit>
        <trans-unit id="fe185f7f6aa0888454156f6b1dd0647b97f1c985" translate="yes" xml:space="preserve">
          <source>Win32::IsWin95()</source>
          <target state="translated">Win32::IsWin95()</target>
        </trans-unit>
        <trans-unit id="1f8c102705f38e11ded9cb1693b6ba04ed8d2aac" translate="yes" xml:space="preserve">
          <source>Win32::IsWinNT()</source>
          <target state="translated">Win32::IsWinNT()</target>
        </trans-unit>
        <trans-unit id="75e8f5dee14a6d1c4d34f99cde2cd05959a202c6" translate="yes" xml:space="preserve">
          <source>Win32::LoadLibrary(LIBNAME)</source>
          <target state="translated">Win32::LoadLibrary(LIBNAME)</target>
        </trans-unit>
        <trans-unit id="33e6daf26026220d0161fea28893d1e652b68f17" translate="yes" xml:space="preserve">
          <source>Win32::LoginName()</source>
          <target state="translated">Win32::LoginName()</target>
        </trans-unit>
        <trans-unit id="b7203bf8251626a9d020ee5f4922ecd6ff013788" translate="yes" xml:space="preserve">
          <source>Win32::LookupAccountName(SYSTEM, ACCOUNT, DOMAIN, SID, SIDTYPE)</source>
          <target state="translated">Win32::LookupAccountName(SYSTEM,ACCOUNT,DOMAIN,SID,SIDTYPE)</target>
        </trans-unit>
        <trans-unit id="e02105130675ffb73c863f2651d7886f32ce699c" translate="yes" xml:space="preserve">
          <source>Win32::LookupAccountSID(SYSTEM, SID, ACCOUNT, DOMAIN, SIDTYPE)</source>
          <target state="translated">Win32::LookupAccountSID(SYSTEM,SID,ACCOUNT,DOMAIN,SIDTYPE)</target>
        </trans-unit>
        <trans-unit id="c0b3757407e5968fe8497224d610a6b05e0fb867" translate="yes" xml:space="preserve">
          <source>Win32::MsgBox(MESSAGE [, FLAGS [, TITLE]])</source>
          <target state="translated">Win32::MsgBox(MESSAGE [,FLAGS [,TITLE]])</target>
        </trans-unit>
        <trans-unit id="e3c6c757d1a1e7f6e540ff3306434ee9703babbe" translate="yes" xml:space="preserve">
          <source>Win32::NodeName()</source>
          <target state="translated">Win32::NodeName()</target>
        </trans-unit>
        <trans-unit id="2712cf0c3d41deb65f7212a8f31b3f82a4ae6a9e" translate="yes" xml:space="preserve">
          <source>Win32::OutputDebugString(STRING)</source>
          <target state="translated">Win32::OutputDebugString(STRING)</target>
        </trans-unit>
        <trans-unit id="75ef631d3c7ea178f0c26bc47d12483cd8c3ea5d" translate="yes" xml:space="preserve">
          <source>Win32::RegisterServer(LIBRARYNAME)</source>
          <target state="translated">Win32::RegisterServer(LIBRARYNAME)</target>
        </trans-unit>
        <trans-unit id="ce0d098c41c01fd9b4d42374933b719c4874605c" translate="yes" xml:space="preserve">
          <source>Win32::SetChildShowWindow(SHOWWINDOW)</source>
          <target state="translated">Win32::SetChildShowWindow(SHOWWINDOW)</target>
        </trans-unit>
        <trans-unit id="6ec2ec156820380d471d8b8902107f69d0c48aac" translate="yes" xml:space="preserve">
          <source>Win32::SetConsoleCP(ID)</source>
          <target state="translated">Win32::SetConsoleCP(ID)</target>
        </trans-unit>
        <trans-unit id="d56fdac00362d0844cebe19c2fbea7797556a862" translate="yes" xml:space="preserve">
          <source>Win32::SetConsoleOutputCP(ID)</source>
          <target state="translated">Win32::SetConsoleOutputCP(ID)</target>
        </trans-unit>
        <trans-unit id="8ff2683659839e8f5dba46b5d4a8ac3aa4a62e14" translate="yes" xml:space="preserve">
          <source>Win32::SetCwd(NEWDIRECTORY)</source>
          <target state="translated">Win32::SetCwd(NEWDIRECTORY)</target>
        </trans-unit>
        <trans-unit id="721ad14df20038a886cdbbad6ec515e2dfd8ef41" translate="yes" xml:space="preserve">
          <source>Win32::SetLastError(ERROR)</source>
          <target state="translated">Win32::SetLastError(ERROR)</target>
        </trans-unit>
        <trans-unit id="70d34dd79a3d13ab005b5f95a3a341dc634b545c" translate="yes" xml:space="preserve">
          <source>Win32::Sleep(TIME)</source>
          <target state="translated">Win32::Sleep(TIME)</target>
        </trans-unit>
        <trans-unit id="0bd78719dddc468413b0b8cae64f7604c9b0760f" translate="yes" xml:space="preserve">
          <source>Win32::Spawn(COMMAND, ARGS, PID)</source>
          <target state="translated">Win32::Spawn(COMMAND,ARGS,PID)</target>
        </trans-unit>
        <trans-unit id="55cf1f14b3a9fb47a3d099c943c81a86f3bab76e" translate="yes" xml:space="preserve">
          <source>Win32::UnregisterServer(LIBRARYNAME)</source>
          <target state="translated">Win32::UnregisterServer(LIBRARYNAME)</target>
        </trans-unit>
        <trans-unit id="aa21f521370d6a588509094452635266c4468ce9" translate="yes" xml:space="preserve">
          <source>Win32API::File</source>
          <target state="translated">Win32API::File</target>
        </trans-unit>
        <trans-unit id="88c0b190dbad57a17cc677f51fa9c1ba74db87d0" translate="yes" xml:space="preserve">
          <source>Win32API::File - Low-level access to Win32 system API calls for files/dirs.</source>
          <target state="translated">Win32API::File-ファイル/ディレクトリのための Win32 システム API 呼び出しへの低レベルアクセス。</target>
        </trans-unit>
        <trans-unit id="b0a0edd9f797c147e0eca61b93c9942a6aada686" translate="yes" xml:space="preserve">
          <source>Win32CORE</source>
          <target state="translated">Win32CORE</target>
        </trans-unit>
        <trans-unit id="674b29c781e27ee904b0a31e2bca19f160dacd50" translate="yes" xml:space="preserve">
          <source>Win32CORE - Win32 CORE function stubs</source>
          <target state="translated">Win32CORE-Win32 CORE 関数のスタブ</target>
        </trans-unit>
        <trans-unit id="823301860ab873ab455e9a7adb1aa457e7019586" translate="yes" xml:space="preserve">
          <source>Win32CORE was created to provide on cygwin those Win32:: functions that for regular win32 builds were provided by default in perl. In cygwin perl releases prior to 5.8.6, this module was standalone and had to be explicitly used. In 5.8.6 and later, it was statically linked into cygwin perl so this would no longer be necessary.</source>
          <target state="translated">Win32CORE は、通常の Win32 ビルド用に perl でデフォルトで提供されている Win32::関数を cygwin 上で提供するために作られました。5.8.6以前のcygwin perlリリースでは、このモジュールはスタンドアロンで、明示的に使用しなければなりませんでした。5.8.6以降では、このモジュールは静的にcygwin perlにリンクされるようになったので、この必要はなくなりました。</target>
        </trans-unit>
        <trans-unit id="a64d38eb25949cf47b772e208780c5548dc84962" translate="yes" xml:space="preserve">
          <source>Win95 and Win98 and WinME are collectively Win9x and Win32</source>
          <target state="translated">Win95、Win98、WinMEは、総称してWin9xとWin32です。</target>
        </trans-unit>
        <trans-unit id="ea8db18a138027d52bc49a4789f983c73ef0f94f" translate="yes" xml:space="preserve">
          <source>Win95/NT</source>
          <target state="translated">Win95/NT</target>
        </trans-unit>
        <trans-unit id="38d123584917edd3d65a1c41ab99a9088beb8b64" translate="yes" xml:space="preserve">
          <source>Win98 chokes on things like Encode if we set the max length to nmake's max of 2K. So we go for a more conservative value of 1K.</source>
          <target state="translated">Win98では、nmakeの最大長を2Kに設定するとEncodeのようなものが窒息してしまいます。そこで、より保守的な1Kの値にしています。</target>
        </trans-unit>
        <trans-unit id="7e7afec2ee076635c5bdb3c20b397b563733e6cf" translate="yes" xml:space="preserve">
          <source>Win9x and &lt;code&gt;d_eofnblk&lt;/code&gt;</source>
          <target state="translated">Win9xおよび &lt;code&gt;d_eofnblk&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcb6e2235a0d088883e2901a983ef0e7377f83c0" translate="yes" xml:space="preserve">
          <source>Win9x can not &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; an open file (although WinNT can).</source>
          <target state="translated">Win9xは開いているファイルを &lt;code&gt;&lt;a href=&quot;functions/rename&quot;&gt;rename()&lt;/a&gt;&lt;/code&gt; できません（ WinNTはできます）。</target>
        </trans-unit>
        <trans-unit id="de40f5b5690a0bb23e1bf760363cb6a5e8443821" translate="yes" xml:space="preserve">
          <source>Win9x can not &lt;code&gt;rename()&lt;/code&gt; an open file (although WinNT can).</source>
          <target state="translated">Win9xは開いているファイルの &lt;code&gt;rename()&lt;/code&gt; できません（ WinNTはできますが）。</target>
        </trans-unit>
        <trans-unit id="1865487f835d74c1a32dc51f7e3fd10d2bb1c87c" translate="yes" xml:space="preserve">
          <source>Win9x does not correctly report &lt;code&gt;EOF&lt;/code&gt; with a non-blocking read on a closed pipe. You will see the following messages:</source>
          <target state="translated">Win9xは、閉じたパイプでの非ブロッキング読み取りで &lt;code&gt;EOF&lt;/code&gt; を正しく報告しません。次のメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="468c4f1d38914eeba7915aa856cfac9060a7a5fe" translate="yes" xml:space="preserve">
          <source>Win9x support was added in 5.6 (Benjamin Stuhl).</source>
          <target state="translated">5.6(Benjamin Stuhl)でWin9xのサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="38c0fc63bcb91fe3116f8590745de1626f0dd16a" translate="yes" xml:space="preserve">
          <source>WinDisk.exe</source>
          <target state="translated">WinDisk.exe</target>
        </trans-unit>
        <trans-unit id="c816e89ffa10335823ff2ffbfd171adf35cada45" translate="yes" xml:space="preserve">
          <source>WinError.h</source>
          <target state="translated">WinError.h</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="bf4f5bc6b10d099fc4024cb19c3bd9cf757e522e" translate="yes" xml:space="preserve">
          <source>Windows .NET Server supports the LLP64 data model on the Intel Itanium architecture.</source>
          <target state="translated">Windows .NET Serverは、Intel Itaniumアーキテクチャ上のLLP64データモデルをサポートしています。</target>
        </trans-unit>
        <trans-unit id="f6a28970a521e035e5e254c78ec61c1026703f9b" translate="yes" xml:space="preserve">
          <source>Windows 2000</source>
          <target state="translated">ウィンドウズ20000</target>
        </trans-unit>
        <trans-unit id="94cada20ad68e1ffe3678826da4a09dc6377e803" translate="yes" xml:space="preserve">
          <source>Windows 7</source>
          <target state="translated">ウィンドウズセブン</target>
        </trans-unit>
        <trans-unit id="cca1d54534e769c83a6c85f5e6241a2523f2592c" translate="yes" xml:space="preserve">
          <source>Windows 95</source>
          <target state="translated">ウィンドウズ95</target>
        </trans-unit>
        <trans-unit id="bdae4500dcdb3f86e38c3347c9fe418dd6deff32" translate="yes" xml:space="preserve">
          <source>Windows 98</source>
          <target state="translated">ウィンドウズ98</target>
        </trans-unit>
        <trans-unit id="6578fbd48a0229e823dac38105b1950bd25957b3" translate="yes" xml:space="preserve">
          <source>Windows Event Log, &lt;a href=&quot;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&lt;/a&gt;</source>
          <target state="translated">Windowsイベントログ、&lt;a href=&quot;http://msdn.microsoft.com/library/default.asp?url=/library/en-us/wes/wes/windows_event_log.asp&quot;&gt;http：//msdn.microsoft.com/library/default.asp？url = / library / en-us / wes / wes / windows_event_log.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08fe8b7597a09dd3a844091de7163268dfe54cc6" translate="yes" xml:space="preserve">
          <source>Windows ME</source>
          <target state="translated">ウィンドウズミー</target>
        </trans-unit>
        <trans-unit id="83dc416748ad54d778d6b19e9f7fde1b7af83339" translate="yes" xml:space="preserve">
          <source>Windows NT4</source>
          <target state="translated">ウィンドウズエヌティーフォー</target>
        </trans-unit>
        <trans-unit id="7d80809b5e98653b28bad4f8f5c33d52237b9226" translate="yes" xml:space="preserve">
          <source>Windows Server 2003</source>
          <target state="translated">ウィンドウズサーバー2003</target>
        </trans-unit>
        <trans-unit id="2504575346cece1887f998d2d76408a38af5141e" translate="yes" xml:space="preserve">
          <source>Windows Server 2008</source>
          <target state="translated">ウィンドウズサーバー2008</target>
        </trans-unit>
        <trans-unit id="7dc44c44b7a030798f3e511dc741ab9400f590ae" translate="yes" xml:space="preserve">
          <source>Windows Vista</source>
          <target state="translated">ウィンドウズビスタ</target>
        </trans-unit>
        <trans-unit id="76f20bccfe3512339ad2cea01fc1c7809e7d3d15" translate="yes" xml:space="preserve">
          <source>Windows XP</source>
          <target state="translated">ウィンドウズエックスピー</target>
        </trans-unit>
        <trans-unit id="3c2af17044bb2c5164875672fc2938f1968ed3a3" translate="yes" xml:space="preserve">
          <source>Windows has basically 2 sets of APIs. A wide API (based on passing UTF-16 strings) and a byte based API based a character set called ANSI. The regular Perl interfaces to the OS currently only uses the ANSI APIs. Unfortunately ANSI is not a single character set.</source>
          <target state="translated">Windowsには基本的に2つのAPIがあります。ワイドAPI(UTF-16文字列を渡すことに基づく)と、ANSIと呼ばれる文字セットに基づくバイトベースのAPIです。OSへの通常のPerlインターフェイスは、現在のところANSI APIのみを使用しています。残念ながら、ANSIは単一の文字セットではありません。</target>
        </trans-unit>
        <trans-unit id="32384d85bc892c2cec1cd8f151b8007b98fa13ff" translate="yes" xml:space="preserve">
          <source>Windows is Win32.</source>
          <target state="translated">WindowsはWin32です。</target>
        </trans-unit>
        <trans-unit id="15932d7727c0d0850847ee4a3aea588d05fd6a45" translate="yes" xml:space="preserve">
          <source>Windows is Windows telnet, Cygwin SSH is the OpenSSH implementation under Cygwin on Windows NT, and Mac Terminal is the Terminal application in Mac OS X. Where the entry is other than yes or no, that emulator displays the given attribute as something else instead. Note that on an aixterm, clear doesn't reset colors; you have to explicitly set the colors back to what you want. More entries in this table are welcome.</source>
          <target state="translated">Windows は Windows telnet、Cygwin SSH は Windows NT 上の Cygwin の OpenSSH 実装、Mac Terminal は Mac OS X の Terminal アプリケーションです。エントリが yes か no 以外の場合、そのエミュレータは指定された属性を他のものとして表示します。aixtermでは、clearは色をリセットしないことに注意してください。この表の他のエントリを歓迎します。</target>
        </trans-unit>
        <trans-unit id="a8033e193c1409f4bd5db90d9880ca01290431d4" translate="yes" xml:space="preserve">
          <source>Windows systems also operate with another byte based character set. It's called the OEM code page. This is the encoding that the Console takes as input and output. It's common for the OEM code page to differ from the ANSI code page.</source>
          <target state="translated">Windows システムは、別のバイトベースの文字セットでも動作します。これは OEM コードページと呼ばれています。これは Console が入出力として使用するエンコーディングです。OEM コードページは ANSI コードページとは異なるのが一般的です。</target>
        </trans-unit>
        <trans-unit id="3093bbeb765cee856b62debb98821ba39f27fcc6" translate="yes" xml:space="preserve">
          <source>Windows users who are using &lt;code&gt;nmake&lt;/code&gt; should note that due to a bug in &lt;code&gt;nmake&lt;/code&gt; , when specifying &lt;code&gt;TEST_FILES&lt;/code&gt; you must use back-slashes instead of forward-slashes.</source>
          <target state="translated">使用しているWindowsユーザー &lt;code&gt;nmake&lt;/code&gt; 原因のバグにいることに注意してください &lt;code&gt;nmake&lt;/code&gt; を指定する際に、 &lt;code&gt;TEST_FILES&lt;/code&gt; をあなたはバックスラッシュの代わりに、フォワードスラッシュを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="db6ab0003d513d80fd8056684fe349106fcdab74" translate="yes" xml:space="preserve">
          <source>Windows users who are using &lt;code&gt;nmake&lt;/code&gt; should note that due to a bug in &lt;code&gt;nmake&lt;/code&gt;, when specifying &lt;code&gt;TEST_FILES&lt;/code&gt; you must use back-slashes instead of forward-slashes.</source>
          <target state="translated">使用しているWindowsユーザー &lt;code&gt;nmake&lt;/code&gt; 原因のバグにいることに注意してください &lt;code&gt;nmake&lt;/code&gt; を指定する際に、 &lt;code&gt;TEST_FILES&lt;/code&gt; をあなたはバックスラッシュの代わりに、フォワードスラッシュを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="968c4aaba72bd2883444cce7386789debafb547b" translate="yes" xml:space="preserve">
          <source>Windows-specific tests.</source>
          <target state="translated">Windowsに特化したテスト。</target>
        </trans-unit>
        <trans-unit id="52b2489ffd6eceb9bd13b6a8f90eac373db50b35" translate="yes" xml:space="preserve">
          <source>Wisconsin</source>
          <target state="translated">Wisconsin</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="a51957fd22adb3afd697fb8ab328d3922f130d4b" translate="yes" xml:space="preserve">
          <source>With $k chosen carefully, and likely to be a small number like 1 or 2. In theory the larger the bucket array the less chance of collision.</source>
          <target state="translated">kは慎重に選ばれ、1や2のような小さな数になる可能性があります。理論的には、バケット配列が大きくなるほど衝突の可能性は低くなります。</target>
        </trans-unit>
        <trans-unit id="8a3fad0711b1021538f5283d00839025799b6dad" translate="yes" xml:space="preserve">
          <source>With 1 causes this module to use Time::HiRes module, allowing milliseconds to be returned by subsequent calls to ping().</source>
          <target state="translated">1 を指定すると、このモジュールは Time::HiRes モジュールを使用するようになり、後続の ping()の呼び出しでミリ秒が返されるようになります。</target>
        </trans-unit>
        <trans-unit id="6185bdea28758a42fc320398e067ab2654617d96" translate="yes" xml:space="preserve">
          <source>With 5005threads, you could also &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; a sub such that any calls to that sub from another thread would block until the lock was released.</source>
          <target state="translated">5005 スレッドでは、別のスレッドからのそのサブルーチンへの呼び出しがロックが解放されるまでブロックされるように、サブルーチンを &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock&lt;/a&gt;&lt;/code&gt; することもできます。</target>
        </trans-unit>
        <trans-unit id="a8d11fe55a26fb99c192c4c169dd330b2ce5c5d6" translate="yes" xml:space="preserve">
          <source>With 5005threads, you could also &lt;code&gt;lock&lt;/code&gt; a sub such that any calls to that sub from another thread would block until the lock was released.</source>
          <target state="translated">5005スレッドでは、別のスレッドからそのサブへの呼び出しがロックが解除されるまでブロックされるように、サブを &lt;code&gt;lock&lt;/code&gt; することもできます。</target>
        </trans-unit>
        <trans-unit id="c2c741524004c7f8613fe0df95f2304ad27bfaf6" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;/a&lt;/code&gt; , one can write &lt;code&gt;\d&lt;/code&gt; with confidence that it will only match ASCII characters, and should the need arise to match beyond ASCII, you can instead use &lt;code&gt;\p{Digit}&lt;/code&gt; (or &lt;code&gt;\p{Word}&lt;/code&gt; for &lt;code&gt;\w&lt;/code&gt; ). There are similar &lt;code&gt;\p{...}&lt;/code&gt; constructs that can match beyond ASCII both white space (see &lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;Whitespace in perlrecharclass&lt;/a&gt;), and Posix classes (see &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;). Thus, this modifier doesn't mean you can't use Unicode, it means that to get Unicode matching you must explicitly use a construct (&lt;code&gt;\p{}&lt;/code&gt; , &lt;code&gt;\P{}&lt;/code&gt; ) that signals Unicode.</source>
          <target state="translated">&lt;code&gt;/a&lt;/code&gt; 、1を書くことができます &lt;code&gt;\d&lt;/code&gt; あなたの代わりに使用することができ、それはASCII文字のみと一致することを自信を持って、そしてASCIIを超えて一致させるために発生する必要がある場合 &lt;code&gt;\p{Digit}&lt;/code&gt; （または &lt;code&gt;\p{Word}&lt;/code&gt; のために &lt;code&gt;\w&lt;/code&gt; ）。ホワイトスペース（&lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;perlrecharclassのホワイトスペースを参照&lt;/a&gt;）とPosixクラス（&lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclassのPOSIX文字クラスを&lt;/a&gt;参照）の両方でASCIIを超えて一致できる同様の &lt;code&gt;\p{...}&lt;/code&gt; 構成があります。したがって、この修飾子は、Unicodeを使用できないことを意味するのではなく、Unicodeマッチングを取得するには、Unicodeを通知する構成（ &lt;code&gt;\p{}&lt;/code&gt; 、 &lt;code&gt;\P{}&lt;/code&gt; ）を明示的に使用する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="d8c642a61a993b2822d327b2f6d2aa5b5cdb0c33" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;/a&lt;/code&gt;, one can write &lt;code&gt;\d&lt;/code&gt; with confidence that it will only match ASCII characters, and should the need arise to match beyond ASCII, you can instead use &lt;code&gt;\p{Digit}&lt;/code&gt; (or &lt;code&gt;\p{Word}&lt;/code&gt; for &lt;code&gt;\w&lt;/code&gt;). There are similar &lt;code&gt;\p{...}&lt;/code&gt; constructs that can match beyond ASCII both white space (see &lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;&quot;Whitespace&quot; in perlrecharclass&lt;/a&gt;), and Posix classes (see &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;). Thus, this modifier doesn't mean you can't use Unicode, it means that to get Unicode matching you must explicitly use a construct (&lt;code&gt;\p{}&lt;/code&gt;, &lt;code&gt;\P{}&lt;/code&gt;) that signals Unicode.</source>
          <target state="translated">&lt;code&gt;/a&lt;/code&gt; 、1を書くことができます &lt;code&gt;\d&lt;/code&gt; あなたの代わりに使用することができ、それはASCII文字のみと一致することを自信を持って、そしてASCIIを超えて一致させるために発生する必要がある場合 &lt;code&gt;\p{Digit}&lt;/code&gt; （または &lt;code&gt;\p{Word}&lt;/code&gt; のために &lt;code&gt;\w&lt;/code&gt; ）。ASCIIを超えて一致できる同様の &lt;code&gt;\p{...}&lt;/code&gt; 構造があり、&lt;a href=&quot;perlrecharclass#Whitespace&quot;&gt;空白&lt;/a&gt;（perlrecharclassの「空白」を参照）とPosixクラス（&lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclassの「POSIX文字クラス」を参照&lt;/a&gt;）の両方に一致します。したがって、この修飾子は、Unicodeを使用できないことを意味するのではなく、Unicodeマッチングを取得するには、Unicodeを通知する構造（ &lt;code&gt;\p{}&lt;/code&gt; 、 &lt;code&gt;\P{}&lt;/code&gt; ）を明示的に使用する必要があることを意味します。</target>
        </trans-unit>
        <trans-unit id="5132b5fe6c695f29613169cf8ff9a2c949197d0f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, you get around this by using a block and an expression where you would place the filehandle:</source>
          <target state="translated">で &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; して &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; の、あなたはブロックし、ファイルハンドルを置くだろう表現を使用することによってこの問題を回避します：</target>
        </trans-unit>
        <trans-unit id="487baf6c93470e20c12688608403c20fbdb8e8f3" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt;, both STDOUT and STDERR will go the same place as the script's STDOUT and STDERR, unless the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; command redirects them. Backticks and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; read &lt;b&gt;only&lt;/b&gt; the STDOUT of your command.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; しない限り、STDOUTとSTDERRの両方が、スクリプトのSTDOUTとSTDERRと同じ場所に行く &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; コマンドはそれらをリダイレクトします。バックティックと &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; は、コマンドのSTDOUT &lt;b&gt;のみを&lt;/b&gt;読み取ります。</target>
        </trans-unit>
        <trans-unit id="e6ba4c518cc989a85f1859e34fe5315e0670671f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Class::Tiny&lt;/code&gt; , all accessors are read-write. It generates a constructor for you, as well as the accessors you define.</source>
          <target state="translated">&lt;code&gt;Class::Tiny&lt;/code&gt; 、すべてのアクセサは読み書きをしています。コンストラクタと、定義したアクセサを生成します。</target>
        </trans-unit>
        <trans-unit id="30133336b461bf131bf440d3b8937ae3c7286e54" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Class::Tiny&lt;/code&gt;, all accessors are read-write. It generates a constructor for you, as well as the accessors you define.</source>
          <target state="translated">&lt;code&gt;Class::Tiny&lt;/code&gt; 、すべてのアクセサは読み書きをしています。コンストラクターと、定義したアクセサーを生成します。</target>
        </trans-unit>
        <trans-unit id="c6b55e3069c1cf271c20c8804a7b8c0dbfbb1f17" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ignore_case&lt;/code&gt; , option specifications for options that only differ in case, e.g., &lt;code&gt;&quot;foo&quot;&lt;/code&gt; and &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; , will be flagged as duplicates.</source>
          <target state="translated">&lt;code&gt;ignore_case&lt;/code&gt; 、大文字と小文字の区別だけが異なるオプションのためのオプション仕様は、例えば、 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; および &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; 、重複としてフラグが設定されます。</target>
        </trans-unit>
        <trans-unit id="912c5dbb25de4eb33c760222cb62f248afb75050" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ignore_case&lt;/code&gt;, option specifications for options that only differ in case, e.g., &lt;code&gt;&quot;foo&quot;&lt;/code&gt; and &lt;code&gt;&quot;Foo&quot;&lt;/code&gt;, will be flagged as duplicates.</source>
          <target state="translated">&lt;code&gt;ignore_case&lt;/code&gt; 、大文字と小文字の区別だけが異なるオプションのためのオプション仕様は、例えば、 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; および &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; 、重複としてフラグが設定されます。</target>
        </trans-unit>
        <trans-unit id="2fffc08f49ded4afbdfb2c00f9dcdbc7da340301" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;latin1&lt;/code&gt; (or &lt;code&gt;ascii&lt;/code&gt;) enabled, &lt;code&gt;encode&lt;/code&gt; will escape characters with ordinal values &amp;gt; 255 (&amp;gt; 127 with &lt;code&gt;ascii&lt;/code&gt;) and encode the remaining characters as specified by the &lt;code&gt;utf8&lt;/code&gt; flag.</source>
          <target state="translated">&lt;code&gt;latin1&lt;/code&gt; （または &lt;code&gt;ascii&lt;/code&gt; ）有効、 &lt;code&gt;encode&lt;/code&gt; &amp;gt;序数値を持つ文字をエスケープします255（と&amp;gt; 127 &lt;code&gt;ascii&lt;/code&gt; ）とによって指定されるように、残りの文字をエンコード &lt;code&gt;utf8&lt;/code&gt; フラグ。</target>
        </trans-unit>
        <trans-unit id="ee71de233ae712db3a62ad0a5f3c845bcb07690d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;pass_through&lt;/code&gt; anything that is unknown, ambiguous or supplied with an invalid option will not be flagged as an error. Instead the unknown option(s) will be passed to the catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; if present, otherwise through to &lt;code&gt;@ARGV&lt;/code&gt; . This makes it possible to write wrapper scripts that process only part of the user supplied command line arguments, and pass the remaining options to some other program.</source>
          <target state="translated">&lt;code&gt;pass_through&lt;/code&gt; 不明であるもの、あいまいなまたは無効なオプションに付属のはエラーとしてフラグ付けされることはありません。代わりに、未知のオプション（複数可）に渡されますキャッチオール &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; もし存在するならば、そうでない場合に通じ &lt;code&gt;@ARGV&lt;/code&gt; 。これにより、ユーザーが指定したコマンドライン引数の一部のみを処理するラッパースクリプトを記述し、残りのオプションを他のプログラムに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="f4663d47991fc6ad8f19a68b7dbd43ec5db93e1f" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;pass_through&lt;/code&gt; anything that is unknown, ambiguous or supplied with an invalid option will not be flagged as an error. Instead the unknown option(s) will be passed to the catchall &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; if present, otherwise through to &lt;code&gt;@ARGV&lt;/code&gt;. This makes it possible to write wrapper scripts that process only part of the user supplied command line arguments, and pass the remaining options to some other program.</source>
          <target state="translated">&lt;code&gt;pass_through&lt;/code&gt; 不明であるもの、あいまいなまたは無効なオプションに付属のはエラーとしてフラグ付けされることはありません。代わりに、不明なオプションが存在する場合はキャッチオール &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; に渡され、存在しない場合は &lt;code&gt;@ARGV&lt;/code&gt; に渡されます。これにより、ユーザーが指定したコマンドライン引数の一部のみを処理するラッパースクリプトを記述し、残りのオプションを他のプログラムに渡すことができます。</target>
        </trans-unit>
        <trans-unit id="e21e85e4f08ba1ed663f7825a392d047ce118ae8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;print&lt;/code&gt; and &lt;code&gt;printf&lt;/code&gt;, you get around this by using a block and an expression where you would place the filehandle:</source>
          <target state="translated">で &lt;code&gt;print&lt;/code&gt; して &lt;code&gt;printf&lt;/code&gt; の、あなたはブロックし、ファイルハンドルを置くだろう表現を使用することによってこの問題を回避します：</target>
        </trans-unit>
        <trans-unit id="161b6ff35bc50314a49d188535255f199fcc9bb0" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;system()&lt;/code&gt;, both STDOUT and STDERR will go the same place as the script's STDOUT and STDERR, unless the &lt;code&gt;system()&lt;/code&gt; command redirects them. Backticks and &lt;code&gt;open()&lt;/code&gt; read &lt;b&gt;only&lt;/b&gt; the STDOUT of your command.</source>
          <target state="translated">&lt;code&gt;system()&lt;/code&gt; しない限り、STDOUTとSTDERRの両方が、スクリプトのSTDOUTとSTDERRと同じ場所に行く &lt;code&gt;system()&lt;/code&gt; コマンドはそれらをリダイレクトします。バックティックと &lt;code&gt;open()&lt;/code&gt; は、コマンドのSTDOUT&lt;b&gt;のみを&lt;/b&gt;読み取ります。</target>
        </trans-unit>
        <trans-unit id="fb95ac886e1d528b24773e6c70b3ed1c1613335e" translate="yes" xml:space="preserve">
          <source>With EXPR, it returns some extra information that the debugger uses to print a stack trace. The value of EXPR indicates how many call frames to go back before the current one.</source>
          <target state="translated">EXPR を使用すると、デバッガがスタックトレースを表示するために使用する追加情報を返します。EXPR の値は、現在のコールフレームの前に何個のコールフレームを遡るかを示します。</target>
        </trans-unit>
        <trans-unit id="a55096d08b5ad2fe54fd898185c93fb2c1c7dfdd" translate="yes" xml:space="preserve">
          <source>With Mac OS X 10.4 &quot;Tiger&quot; and newer, there is almost no performance penalty for non-prebound libraries. Earlier releases will suffer a greater load time than either the static library, or Apple's pre-bound dynamic library.</source>
          <target state="translated">Mac OS X 10.4 &quot;Tiger &quot;以降では、プリバウンドしていないライブラリのパフォーマンスペナルティはほとんどありません。それ以前のリリースでは、静的ライブラリやAppleのプリバウンドされた動的ライブラリのいずれかよりも大きなロードタイムに悩まされることになります。</target>
        </trans-unit>
        <trans-unit id="5f9d3d0136d8a2d2276cb1a4c4f0bb0c82be3696" translate="yes" xml:space="preserve">
          <source>With NTFS (and no CYGWIN=nontsec), there should be no problems even if perl was built on FAT.</source>
          <target state="translated">NTFS(しかもCYGWIN=nontsecではない)であれば、perlがFAT上に構築されていても問題ないはずです。</target>
        </trans-unit>
        <trans-unit id="783aaaca75cc72bad41475003df821affc75b7c5" translate="yes" xml:space="preserve">
          <source>With OO style, you can break the message arbitrarily. This means that we are no longer limited to have space for the whole message in memory, i.e. we can handle messages of any size.</source>
          <target state="translated">OO スタイルでは、メッセージを任意に分割することができます。これは、メモリ上にメッセージ全体のためのスペースを持つことに制限されなくなったことを意味します。</target>
        </trans-unit>
        <trans-unit id="aa5707019a9c4f2624f176a48761ef4f1b3f5952" translate="yes" xml:space="preserve">
          <source>With Perl &amp;gt;= 5.6.2, you can also use a line like this:</source>
          <target state="translated">Perl&amp;gt; = 5.6.2の場合、次のような行を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="c1bf2f77022cd9fed463a5704b297d6ff88b00d5" translate="yes" xml:space="preserve">
          <source>With Perl 5.004 you can also use the TIEHANDLE interface to access compressed files just like ordinary files:</source>
          <target state="translated">Perl 5.004では、TIEHANDLEインターフェイスを使用して、通常のファイルのように圧縮ファイルにアクセスすることもできます。</target>
        </trans-unit>
        <trans-unit id="9f110b40627d54799c1a5b4c023b449d3f05b59d" translate="yes" xml:space="preserve">
          <source>With Perl 5.10 and later, the smart match operator can give you the answer with the least amount of work:</source>
          <target state="translated">Perl 5.10以降では、スマートマッチ演算子を使用することで、最小限の作業で答えを出すことができます。</target>
        </trans-unit>
        <trans-unit id="4e55c608e124b42bf25bf02c154381796e1d9852" translate="yes" xml:space="preserve">
          <source>With a</source>
          <target state="translated">を使って</target>
        </trans-unit>
        <trans-unit id="cf7bad50138d4a906e034cdc8232445a6a34e8fb" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;, &lt;code&gt;charscript()&lt;/code&gt; returns the</source>
          <target state="translated">&lt;a href=&quot;#code-point-argument&quot;&gt;「コードポイント引数」&lt;/a&gt;、 &lt;code&gt;charscript()&lt;/code&gt; を返します</target>
        </trans-unit>
        <trans-unit id="ca805fd21b2d73d6d3fa38629cb4d7c77aac2c21" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;&quot;code point argument&quot;&lt;/a&gt;&lt;code&gt;charblock()&lt;/code&gt; returns the</source>
          <target state="translated">&lt;a href=&quot;#code-point-argument&quot;&gt;「コードポイント引数」&lt;/a&gt; &lt;code&gt;charblock()&lt;/code&gt; を返します</target>
        </trans-unit>
        <trans-unit id="f458d9e5c6b401d23a0ff93a93cac73ffa40d782" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;, &lt;code&gt;charscript()&lt;/code&gt; returns the</source>
          <target state="translated">&lt;a href=&quot;#code-point-argument&quot;&gt;コードポイント引数&lt;/a&gt;、 &lt;code&gt;charscript()&lt;/code&gt; リターン</target>
        </trans-unit>
        <trans-unit id="7cfd816e3af239ee8e3392fa5dd4b28e10c2cbf9" translate="yes" xml:space="preserve">
          <source>With a &lt;a href=&quot;#code-point-argument&quot;&gt;code point argument&lt;/a&gt;&lt;code&gt;charblock()&lt;/code&gt; returns the</source>
          <target state="translated">&lt;a href=&quot;#code-point-argument&quot;&gt;コードポイント引数&lt;/a&gt; &lt;code&gt;charblock()&lt;/code&gt; リターン</target>
        </trans-unit>
        <trans-unit id="cc06a9c18caf674053e4b44b132356a1c540f757" translate="yes" xml:space="preserve">
          <source>With a little extra work, you can get all of the groups in angle brackets even if they are in other angle brackets too. Each time you get a balanced match, remove its outer delimiter (that's the one you just matched so don't match it again) and add it to a queue of strings to process. Keep doing that until you get no matches:</source>
          <target state="translated">少し余分な作業をすれば、たとえそれらが他の角括弧に入っていたとしても、すべてのグループを角括弧に入れることができます。バランスのとれたマッチを得るたびに、その外側の区切り文字を削除して (これは今マッチしたものなので二度とマッチしないようにしてください)、それを処理する文字列のキューに追加します。マッチしなくなるまでこれを続けてください。</target>
        </trans-unit>
        <trans-unit id="a69059588956460f70f3f90c71a968d5af85c118" translate="yes" xml:space="preserve">
          <source>With a non-&lt;code&gt;DEBUGGING&lt;/code&gt; perl, the buckets starting from &lt;code&gt;128&lt;/code&gt; have a 4-byte overhead, and thus an 8192-long bucket may take up to 8188-byte allocations.</source>
          <target state="translated">非 &lt;code&gt;DEBUGGING&lt;/code&gt; perlの場合、 &lt;code&gt;128&lt;/code&gt; から始まるバケットには4バイトのオーバーヘッドがあるため、8192の長さのバケットには最大8188バイトの割り当てが必要になる場合があります。</target>
        </trans-unit>
        <trans-unit id="3f782793180910fe0c252c5c5e6b40299dd75d89" translate="yes" xml:space="preserve">
          <source>With a slurpy parameter in the signature, there is no upper limit on how many arguments may be passed. A slurpy array parameter may be nameless just like a positional parameter, in which case its only effect is to turn off the argument limit that would otherwise apply:</source>
          <target state="translated">シグネチャにslurpyパラメータがある場合、引数の数に上限はありません。スラーピーな配列パラメータは、位置パラメータのように名前を持たないこともありますが、その場合は引数の制限を無効にするだけです。</target>
        </trans-unit>
        <trans-unit id="f9508f16c80ad6889c699daf40f43720b8251d92" translate="yes" xml:space="preserve">
          <source>With a technique called copy-on-write, the cost of copying with overload could be minimized or even completely avoided. A test implementation of COW did show performance gains for overloaded math, but introduced a performance loss due to a constant overhead for all other operations. So Math::BigInt does currently not COW.</source>
          <target state="translated">コピーオンライトと呼ばれる技術では、オーバーロードでのコピーのコストを最小化したり、完全に回避したりすることができました。COW のテスト実装では、オーバーロードされた数学の性能向上が示されましたが、他のすべての操作のために一定のオーバーヘッドによる性能低下が導入されました。そのため、Math::BigInt は現在のところ COW を行っていません。</target>
        </trans-unit>
        <trans-unit id="338611254651b6fbb00a03edfd8b2e0209a2413c" translate="yes" xml:space="preserve">
          <source>With a todo block, the tests inside are expected to fail. Test::More will run the tests normally, but print out special flags indicating they are &quot;todo&quot;. &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret failures as being ok. Should anything succeed, it will report it as an unexpected success. You then know the thing you had todo is done and can remove the TODO flag.</source>
          <target state="translated">todoブロックを使用すると、内部のテストは失敗することが予想されます。Test :: Moreは通常どおりテストを実行しますが、「todo」であることを示す特別なフラグを出力します。&lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt;は、失敗を問題ないと解釈します。何かが成功した場合、それは予期しない成功として報告されます。これで、やらなければならなかったことが完了したことがわかり、TODOフラグを削除できます。</target>
        </trans-unit>
        <trans-unit id="0ebe6d7c43f224246d4ca3387c92f6cc94b15954" translate="yes" xml:space="preserve">
          <source>With a todo block, the tests inside are expected to fail. Test::More will run the tests normally, but print out special flags indicating they are &quot;todo&quot;. &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret failures as being ok. Should anything succeed, it will report it as an unexpected success. You then know the thing you had todo is done and can remove the TODO flag.</source>
          <target state="translated">todoブロックを使用すると、内部のテストは失敗することが予想されます。Test :: Moreはテストを通常どおり実行しますが、「todo」であることを示す特別なフラグを出力します。&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt;は失敗を大丈夫と解釈します。何かが成功した場合は、予期しない成功として報告されます。これで、todoを実行したことが完了し、TODOフラグを削除できます。</target>
        </trans-unit>
        <trans-unit id="039f5d96db075baf2e35a9428955065fad856e3f" translate="yes" xml:space="preserve">
          <source>With all of the previous done, you're now ready to call Configure.</source>
          <target state="translated">これで、Configureを呼び出す準備ができました。</target>
        </trans-unit>
        <trans-unit id="2be7163284f82da14a87936dad63fbf983833559" translate="yes" xml:space="preserve">
          <source>With all of the regexes above, if the regex matched anywhere in the string, it was considered a match. To specify</source>
          <target state="translated">上記のすべての正規表現では、その正規表現が文字列のどこかにマッチしていれば、それはマッチしているとみなされます。を指定するには、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="a49675e374380fe043aff3a5f63d6512021ecfd9" translate="yes" xml:space="preserve">
          <source>With all of the regexps above, if the regexp matched anywhere in the string, it was considered a match. Sometimes, however, we'd like to specify</source>
          <target state="translated">上記のすべての正規表現では、正規表現が文字列のどこかにマッチした場合、それはマッチしたとみなされます。しかし、時には</target>
        </trans-unit>
        <trans-unit id="544d324c6a361c56f15aa84b4f308989bea67735" translate="yes" xml:space="preserve">
          <source>With an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, you should be especially careful to remember what's being looked at when:</source>
          <target state="translated">では &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; を、あなたは時に見されているものを覚えておくことは特に注意する必要があります：</target>
        </trans-unit>
        <trans-unit id="250cfbca6e5e22d4d573a90cd37797d2cb8d3ac5" translate="yes" xml:space="preserve">
          <source>With an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, you should be especially careful to remember what's being looked at when:</source>
          <target state="translated">では &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; を、あなたは時に見されているものを覚えておくことは特に注意する必要があります：</target>
        </trans-unit>
        <trans-unit id="8175ced4a0fd9d7cc491a3c946926864742f09d4" translate="yes" xml:space="preserve">
          <source>With an argument, can be used to generate a NaN with</source>
          <target state="translated">引数を指定すると、NaNを生成するために</target>
        </trans-unit>
        <trans-unit id="28933cd0405c565c32304d3c729c7e6f31006ad2" translate="yes" xml:space="preserve">
          <source>With any of these, you can change file descriptors before the call:</source>
          <target state="translated">これらのいずれかを使用すると、呼び出しの前にファイルディスクリプタを変更することができます。</target>
        </trans-unit>
        <trans-unit id="944f492857a1db6c839174233fd1c02f59c056dd" translate="yes" xml:space="preserve">
          <source>With any version of Perl 5 you can use the basic OO interface:</source>
          <target state="translated">Perl 5 のどのバージョンでも、基本的な OO インターフェースを使用することができます。</target>
        </trans-unit>
        <trans-unit id="d9bf5579433ea6ddabc4d916f0dbd99e9c0f39ff" translate="yes" xml:space="preserve">
          <source>With argument force $ENCODING_... variables to set to the given value.</source>
          <target state="translated">引数で強制的に $ENCODING_...変数に与えられた値を設定します。</target>
        </trans-unit>
        <trans-unit id="aaaac305ec8d42934372356813b4624fa49a8ffc" translate="yes" xml:space="preserve">
          <source>With argument sets the option. Without returns the option value.</source>
          <target state="translated">引数を指定すると、オプションを設定します。引数なしの場合は、オプションの値を返します。</target>
        </trans-unit>
        <trans-unit id="108bd0cf30895e3a18d32866a5ada0ba72c0b2d2" translate="yes" xml:space="preserve">
          <source>With bundling it is possible to set several single-character options at once. For example if &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; are all valid options,</source>
          <target state="translated">バンドルを使用すると、複数の単一文字オプションを同時に設定できます。たとえば、 &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;v&lt;/code&gt; 、 &lt;code&gt;x&lt;/code&gt; がすべて有効なオプションである場合、</target>
        </trans-unit>
        <trans-unit id="6a3391ab50835b72ad746f9bc70f0861004cbe03" translate="yes" xml:space="preserve">
          <source>With bundling it is possible to set several single-character options at once. For example if &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; are all valid options,</source>
          <target state="translated">バンドルを使用すると、一度に複数の単一文字オプションを設定できます。たとえば、 &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;v&lt;/code&gt; 、 &lt;code&gt;x&lt;/code&gt; がすべて有効なオプションである場合、</target>
        </trans-unit>
        <trans-unit id="bf9c20d6876f103320c9d9424556b25f81d7af24" translate="yes" xml:space="preserve">
          <source>With earlier versions of Perl, you have to do a bit more work. If you are going to make this query many times over arbitrary string values, the fastest way is probably to invert the original array and maintain a hash whose keys are the first array's values:</source>
          <target state="translated">以前のバージョンのPerlでは、もう少し作業をしなければなりません。このクエリを任意の文字列の値に対して何度も実行する場合は、元の配列を反転させて、最初の配列の値をキーとするハッシュを保持するのが一番早い方法でしょう。</target>
        </trans-unit>
        <trans-unit id="089c9811008b67cdbb35efdae3d3f3034c15c2b2" translate="yes" xml:space="preserve">
          <source>With excerpts from Perl, and contributions and suggestions from Ronald J. Kimball, Dave Mitchell, Dominic Dunlop, Mark Jason Dominus, Stephen McCamant, and David Landgren.</source>
          <target state="translated">Perl からの抜粋と、Ronald J.Kimball、Dave Mitchell、Dominic Dunlop、Mark Jason Dominus、Stephen McCamant、David Landgren からの寄稿と提案。</target>
        </trans-unit>
        <trans-unit id="312cf396f9e4b4f5d83643b7fda95efc6c88ff9d" translate="yes" xml:space="preserve">
          <source>With hooks comes the ability to recurse back to the Storable engine. Indeed, hooks are regular Perl code, and Storable is convenient when it comes to serializing and deserializing things, so why not use it to handle the serialization string?</source>
          <target state="translated">フックを使うと、Storableエンジンへのリカーシングが可能になります。実際、フックは通常のPerlのコードであり、Storableはシリアライズやデシリアライズを行う際に便利です。</target>
        </trans-unit>
        <trans-unit id="2092bcf7558e6632164a74cbb09d09cc7943a0d7" translate="yes" xml:space="preserve">
          <source>With lots of help and suggestions from Dean Roehrich, Malcolm Beattie, Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer, Stephen McCamant, and Gurusamy Sarathy.</source>
          <target state="translated">Dean Roehrich、Malcolm Beattie、Andreas Koenig、Paul Hudson、Ilya Zakharevich、Paul Marquess、Neil Bowers、Matthew Green、Tim Bunce、Spider Boardman、Ulrich Pfeifer、Stephen McCamant、そしてGurusamy Sarathyからの多くの助けと提案があります。</target>
        </trans-unit>
        <trans-unit id="2f32ef7ca32db627a2acbe157dc6fb77e5ecddfd" translate="yes" xml:space="preserve">
          <source>With methods 2 and 3, Perl starts parsing the input file from the beginning, unless you've specified a &lt;a href=&quot;#-x&quot;&gt;&quot;-x&quot;&lt;/a&gt; switch, in which case it scans for the first line starting with &lt;code&gt;#!&lt;/code&gt; and containing the word &quot;perl&quot;, and starts there instead. This is useful for running a program embedded in a larger message. (In this case you would indicate the end of the program using the &lt;code&gt;__END__&lt;/code&gt; token.)</source>
          <target state="translated">メソッド2および3では、&lt;a href=&quot;#-x&quot;&gt;「-x」&lt;/a&gt;スイッチを指定していない限り、Perlは入力ファイルの解析を最初から開始します。指定した場合は、 &lt;code&gt;#!&lt;/code&gt; 始まる最初の行をスキャンします。「perl」という単語を含み、代わりにそこから始まります。これは、より大きなメッセージに埋め込まれたプログラムを実行する場合に役立ちます。（この場合、 &lt;code&gt;__END__&lt;/code&gt; トークンを使用してプログラムの終了を示します。）</target>
        </trans-unit>
        <trans-unit id="6a2d0cebca8f8c753e2f714f5c39699038d3b25f" translate="yes" xml:space="preserve">
          <source>With methods 2 and 3, Perl starts parsing the input file from the beginning, unless you've specified a &lt;b&gt;-x&lt;/b&gt; switch, in which case it scans for the first line starting with &lt;code&gt;#!&lt;/code&gt; and containing the word &quot;perl&quot;, and starts there instead. This is useful for running a program embedded in a larger message. (In this case you would indicate the end of the program using the &lt;code&gt;__END__&lt;/code&gt; token.)</source>
          <target state="translated">方法2と3では、&lt;b&gt;-x&lt;/b&gt;スイッチを指定していない限り、Perlは最初から入力ファイルの解析を開始します。&lt;b&gt;-x&lt;/b&gt;スイッチを指定した場合は、 &lt;code&gt;#!&lt;/code&gt; で始まる最初の行をスキャンします。「perl」という単語を含み、代わりにそこから始まります。これは、より大きなメッセージに埋め込まれたプログラムを実行するのに役立ちます。（この場合、 &lt;code&gt;__END__&lt;/code&gt; トークンを使用してプログラムの終了を示します。）</target>
        </trans-unit>
        <trans-unit id="6316d5824ca52c312f770e770e783e4a6d5033d6" translate="yes" xml:space="preserve">
          <source>With mod_perl and the Apache::Registry module (distributed with mod_perl), httpd will run with an embedded Perl interpreter which pre-compiles your script and then executes it within the same address space without forking. The Apache extension also gives Perl access to the internal server API, so modules written in Perl can do just about anything a module written in C can. For more on mod_perl, see &lt;a href=&quot;http://perl.apache.org/&quot;&gt;http://perl.apache.org/&lt;/a&gt;</source>
          <target state="translated">mod_perlとApache :: Registryモジュール（mod_perlで配布）を使用すると、httpdは埋め込みPerlインタープリターで実行され、スクリプトをプリコンパイルし、フォークせずに同じアドレススペース内で実行します。Apache拡張機能は、Perlに内部サーバーAPIへのアクセスも提供するため、Perlで作成されたモジュールは、Cで作成されたモジュールが実行できるほぼすべてのことを実行できます。mod_perlの詳細については、&lt;a href=&quot;http://perl.apache.org/&quot;&gt;http：&lt;/a&gt; //perl.apache.org/を参照してください</target>
        </trans-unit>
        <trans-unit id="cc2eb3f9b78400953fa9a4ff9c87b68e20c7b681" translate="yes" xml:space="preserve">
          <source>With much assistance regarding shared libraries from Marc Sabatella.</source>
          <target state="translated">Marc Sabatella氏から共有ライブラリに関する多くの支援をいただきました。</target>
        </trans-unit>
        <trans-unit id="b462e2e8ccefffa9756bd47bbfa7c723db9b9b54" translate="yes" xml:space="preserve">
          <source>With negative offsets, it remembers its position from the end of the string when the target string is modified:</source>
          <target state="translated">負のオフセットでは、対象の文字列が変更されたときに、文字列の末尾からの位置を記憶します。</target>
        </trans-unit>
        <trans-unit id="00344cc849fc9376fff9de99085e79fa3cd552d0" translate="yes" xml:space="preserve">
          <source>With no MASK argument present, it returns the current operator mask of the compartment.</source>
          <target state="translated">MASK 引数がない場合、コンパートメントの現在の演算子マスクを返します。</target>
        </trans-unit>
        <trans-unit id="a35650496b577c95afdac0e1ebb0191fd46fd2e0" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole array (whether or not the element was specified as &lt;code&gt;'@'&lt;/code&gt; or &lt;code&gt;'*@'&lt;/code&gt; ).</source>
          <target state="translated">引数なしの場合、アクセサーは要素の配列全体への参照を返します（要素が &lt;code&gt;'@'&lt;/code&gt; または &lt;code&gt;'*@'&lt;/code&gt; として指定されているかどうかに関係なく）。</target>
        </trans-unit>
        <trans-unit id="a8ef3568dccdeee73b65f3996dd1707e6feb3878" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole array (whether or not the element was specified as &lt;code&gt;'@'&lt;/code&gt; or &lt;code&gt;'*@'&lt;/code&gt;).</source>
          <target state="translated">引数がない場合、アクセサは要素の配列全体への参照を返します（要素が &lt;code&gt;'@'&lt;/code&gt; または &lt;code&gt;'*@'&lt;/code&gt; として指定されているかどうかに関係なく）。</target>
        </trans-unit>
        <trans-unit id="3a4963e3a2e84181fb9a499ef49896fdab34cd7c" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole hash (whether or not the element was specified as &lt;code&gt;'%'&lt;/code&gt; or &lt;code&gt;'*%'&lt;/code&gt; ).</source>
          <target state="translated">引数がない場合、アクセサは要素のハッシュ全体への参照を返します（要素が &lt;code&gt;'%'&lt;/code&gt; または &lt;code&gt;'*%'&lt;/code&gt; として指定されているかどうかは関係ありません）。</target>
        </trans-unit>
        <trans-unit id="988bcaf50ce8ee9902f007f6fc6c2b44abddd67d" translate="yes" xml:space="preserve">
          <source>With no argument, the accessor returns a reference to the element's whole hash (whether or not the element was specified as &lt;code&gt;'%'&lt;/code&gt; or &lt;code&gt;'*%'&lt;/code&gt;).</source>
          <target state="translated">引数がない場合、アクセサは要素のハッシュ全体への参照を返します（要素が &lt;code&gt;'%'&lt;/code&gt; または &lt;code&gt;'*%'&lt;/code&gt; として指定されているかどうかに関係なく）。</target>
        </trans-unit>
        <trans-unit id="6bae0e18d43bcb818e56d07261a055232eff0bf8" translate="yes" xml:space="preserve">
          <source>With no arguments (or using &lt;code&gt;threads::all&lt;/code&gt; ) and in a list context, returns a list of all non-joined, non-detached</source>
          <target state="translated">引数なしで（または &lt;code&gt;threads::all&lt;/code&gt; を使用して）リストコンテキストで、結合されていない、分離されていないすべてのリストを返します。</target>
        </trans-unit>
        <trans-unit id="9a2c5169b8859351e115fccd32105029ad3b3e99" translate="yes" xml:space="preserve">
          <source>With no arguments (or using &lt;code&gt;threads::all&lt;/code&gt;) and in a list context, returns a list of all non-joined, non-detached</source>
          <target state="translated">引数なし（または &lt;code&gt;threads::all&lt;/code&gt; を使用）で、リストコンテキストで、すべての非結合、非分離のリストを返します</target>
        </trans-unit>
        <trans-unit id="18cf8c9e6afcd23474d7fb3a81386e0988d7bd68" translate="yes" xml:space="preserve">
          <source>With older versions of Perl, the &lt;a href=&quot;IO::String&quot;&gt;IO::String&lt;/a&gt; module provides similar functionality.</source>
          <target state="translated">古いバージョンのPerlでは、&lt;a href=&quot;IO::String&quot;&gt;IO :: String&lt;/a&gt;モジュールが同様の機能を提供します。</target>
        </trans-unit>
        <trans-unit id="d4cfb999178855ab18f46ce9c518e1bd1ef50096" translate="yes" xml:space="preserve">
          <source>With older versions of Perl, the &lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO::String&lt;/a&gt; module provides similar functionality.</source>
          <target state="translated">古いバージョンのPerlでは、&lt;a href=&quot;http://search.cpan.org/perldoc/IO::String&quot;&gt;IO :: String&lt;/a&gt;モジュールが同様の機能を提供します。</target>
        </trans-unit>
        <trans-unit id="789c0f1114004fe97c889b4fd162dac50dbb4785" translate="yes" xml:space="preserve">
          <source>With one exception (below), if both strings look like numbers to Perl, the magic increment will not be applied, and the strings will be treated as numbers (more specifically, integers) instead.</source>
          <target state="translated">1つの例外を除いて(下記)、両方の文字列がPerlにとって数字のように見える場合、マジックインクリメントは適用されず、文字列は代わりに数字(より具体的には整数)として扱われます。</target>
        </trans-unit>
        <trans-unit id="c467eeeb4f15846c2e3c26d1b4d74776d4da75d4" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is a key specifying one element of the hash; the second argument, if present, is assigned to the hash element. If the element type is &lt;code&gt;'%'&lt;/code&gt; , the accessor returns the hash element value. If the element type is &lt;code&gt;'*%'&lt;/code&gt; , a reference to the hash element is returned.</source>
          <target state="translated">1つまたは2つの引数がある場合、最初の引数はハッシュの1つの要素を指定するキーです。2番目の引数が存在する場合は、ハッシュ要素に割り当てられます。要素タイプが &lt;code&gt;'%'&lt;/code&gt; の場合、アクセサはハッシュ要素値を返します。要素タイプが &lt;code&gt;'*%'&lt;/code&gt; の場合、ハッシュ要素への参照が返されます。</target>
        </trans-unit>
        <trans-unit id="0bd4bcbdb7945f28a4390fecea625c7a59fd6d00" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is a key specifying one element of the hash; the second argument, if present, is assigned to the hash element. If the element type is &lt;code&gt;'%'&lt;/code&gt;, the accessor returns the hash element value. If the element type is &lt;code&gt;'*%'&lt;/code&gt;, a reference to the hash element is returned.</source>
          <target state="translated">1つまたは2つの引数がある場合、最初の引数はハッシュの1つの要素を指定するキーです。2番目の引数が存在する場合は、ハッシュ要素に割り当てられます。要素タイプが &lt;code&gt;'%'&lt;/code&gt; の場合、アクセサーはハッシュ要素値を返します。要素タイプが &lt;code&gt;'*%'&lt;/code&gt; の場合、ハッシュ要素への参照が返されます。</target>
        </trans-unit>
        <trans-unit id="043fe821df73a58116e971eada4906da49321cca" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is an index specifying one element of the array; the second argument, if present, is assigned to the array element. If the element type is &lt;code&gt;'@'&lt;/code&gt; , the accessor returns the array element value. If the element type is &lt;code&gt;'*@'&lt;/code&gt; , a reference to the array element is returned.</source>
          <target state="translated">1つまたは2つの引数がある場合、最初の引数は配列の1つの要素を指定するインデックスです。 2番目の引数が存在する場合は、配列要素に割り当てられます。要素タイプが &lt;code&gt;'@'&lt;/code&gt; の場合、アクセサは配列要素の値を返します。要素タイプが &lt;code&gt;'*@'&lt;/code&gt; の場合、配列要素への参照が返されます。</target>
        </trans-unit>
        <trans-unit id="eca88cd532fb52622336dc15fcd9f2fe4531eda4" translate="yes" xml:space="preserve">
          <source>With one or two arguments, the first argument is an index specifying one element of the array; the second argument, if present, is assigned to the array element. If the element type is &lt;code&gt;'@'&lt;/code&gt;, the accessor returns the array element value. If the element type is &lt;code&gt;'*@'&lt;/code&gt;, a reference to the array element is returned.</source>
          <target state="translated">1つまたは2つの引数がある場合、最初の引数は配列の1つの要素を指定するインデックスです。2番目の引数が存在する場合は、配列要素に割り当てられます。要素タイプが &lt;code&gt;'@'&lt;/code&gt; 場合、アクセサーは配列要素の値を返します。要素タイプが &lt;code&gt;'*@'&lt;/code&gt; の場合、配列要素への参照が返されます。</target>
        </trans-unit>
        <trans-unit id="d82587a9e3d9d950371c40dd7e06719bffb84440" translate="yes" xml:space="preserve">
          <source>With option -exec, walks tree in execute order, otherwise in basic order.</source>
          <target state="translated">オプション -exec を指定すると、ツリーを実行順に歩き、そうでない場合は基本順に歩きます。</target>
        </trans-unit>
        <trans-unit id="57d705a8d20354296c55ade02ce168e9aba3ea9c" translate="yes" xml:space="preserve">
          <source>With overloaded math, only the first two variants will result in a BigFloat:</source>
          <target state="translated">オーバーロードされた数学では、最初の2つのバリアントだけがBigFloatになります。</target>
        </trans-unit>
        <trans-unit id="04cbc8f37da7397c953eb4dca3b6f0e0eee0dac0" translate="yes" xml:space="preserve">
          <source>With overloaded operators, it is the first (dominating) operand that determines which method is called. Here are some examples showing what actually gets called in various cases.</source>
          <target state="translated">オーバーロードされた演算子では、どのメソッドが呼び出されるかを決定するのは、最初の(支配的な)オペランドです。ここでは、様々なケースで実際に呼び出されるものを示す例をいくつか挙げています。</target>
        </trans-unit>
        <trans-unit id="a2b46b3274ff332d0d8381195e802b804512dbcd" translate="yes" xml:space="preserve">
          <source>With proper care you may mix package and my (or state) &lt;code&gt;$a&lt;/code&gt; and/or &lt;code&gt;$b&lt;/code&gt;:</source>
          <target state="translated">適切な注意を払えば、パッケージと私の（または州の） &lt;code&gt;$a&lt;/code&gt; および/または &lt;code&gt;$b&lt;/code&gt; 混在させることができます：</target>
        </trans-unit>
        <trans-unit id="f7d4085fcb09a164c92639ac09b2aa2b53f4f318" translate="yes" xml:space="preserve">
          <source>With respect to character matching, there are a few more points you need to know about. First of all, not all characters can be used &quot;as is&quot; in a match. Some characters, called</source>
          <target state="translated">キャラクターのマッチングに関しては、もう少し知っておくべきポイントがあります。まず第一に、すべての文字がマッチで「そのまま」使用できるわけではありません。と呼ばれる一部の文字は</target>
        </trans-unit>
        <trans-unit id="549d9ba8c522ce4226592827b058814ec17aafc9" translate="yes" xml:space="preserve">
          <source>With respect to character matching, there are a few more points you need to know about. First of all, not all characters can be used 'as is' in a match. Some characters, called</source>
          <target state="translated">文字のマッチングに関しては、もう少し知っておくべきポイントがあります。まず第一に、すべての文字がマッチで「そのまま」使用できるわけではありません。と呼ばれる一部の文字は</target>
        </trans-unit>
        <trans-unit id="f52704b066745f4539042b4ca42ac5911b1eae8e" translate="yes" xml:space="preserve">
          <source>With respect to files, one that has the proper permission bit set to let you access the file. With respect to computer programs, one that&amp;rsquo;s written well enough that someone has a chance of figuring out what it&amp;rsquo;s trying to do.</source>
          <target state="translated">ファイルに関しては、ファイルにアクセスできるように適切な許可ビットが設定されているファイル。コンピュータプログラムに関しては、誰かがそれが何をしようとしているのかを理解する可能性があるほど十分に書かれているもの。</target>
        </trans-unit>
        <trans-unit id="3dc4eefad3d29ef780cb07bfc36df49d416959b4" translate="yes" xml:space="preserve">
          <source>With respect to loading &lt;code&gt;Exporter&lt;/code&gt; and inheriting, there are alternatives with the use of modules like &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;parent&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;Exporter&lt;/code&gt; ロードと継承に関しては、 &lt;code&gt;base&lt;/code&gt; や &lt;code&gt;parent&lt;/code&gt; などのモジュールを使用する代替手段があります。</target>
        </trans-unit>
        <trans-unit id="6ddfefdcb8919ff4ad4881cdfab3eb3ea6c93a49" translate="yes" xml:space="preserve">
          <source>With respect to loading &lt;code&gt;Exporter&lt;/code&gt; and inheriting, there are alternatives with the use of modules like &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;parent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Exporter&lt;/code&gt; のロードと継承に関しては、 &lt;code&gt;base&lt;/code&gt; や &lt;code&gt;parent&lt;/code&gt; などのモジュールを使用する代替手段があります。</target>
        </trans-unit>
        <trans-unit id="64aab757411e3efe138dbb9f7787c6359c1eec8b" translate="yes" xml:space="preserve">
          <source>With some firewalls active mode does not work as the server cannot connect to your machine (because you are behind a firewall) and the firewall does not re-write the command. In this case you should set &lt;code&gt;ftp_ext_passive&lt;/code&gt; to a</source>
          <target state="translated">一部のファイアウォールでは、サーバーがマシンに接続できず（ファイアウォールの背後にいるため）、ファイアウォールがコマンドを再書き込みしないため、アクティブモードは機能しません。この場合、 &lt;code&gt;ftp_ext_passive&lt;/code&gt; をaに設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="39e7b288b06e2af98b83632e08ab80e03b9bf7c3" translate="yes" xml:space="preserve">
          <source>With source filters, you can store the text of your script compressed and use a source filter to uncompress it for Perl's parser:</source>
          <target state="translated">ソースフィルタを使うと、スクリプトのテキストを圧縮して保存し、ソースフィルタを使って Perl のパーサ用に圧縮を解除することができます。</target>
        </trans-unit>
        <trans-unit id="f3d0833032fe049783c845044de2a75767e40f62" translate="yes" xml:space="preserve">
          <source>With support for &lt;code&gt;LIBPATHSTRICT&lt;/code&gt; this may be circumvented - unless one of DLLs is started from</source>
          <target state="translated">&lt;code&gt;LIBPATHSTRICT&lt;/code&gt; のサポートにより、これは回避される可能性があります-DLLの 1つが</target>
        </trans-unit>
        <trans-unit id="741296e189dd1627ab6af5dc824e2c81acff153a" translate="yes" xml:space="preserve">
          <source>With that trick MakeMaker will only read the first line and thus read the underscore, while the perl interpreter will evaluate the $VERSION and convert the string into a number. Later operations that treat $VERSION as a number will then be able to do so without provoking a warning about $VERSION not being a number.</source>
          <target state="translated">このトリックを使うと、MakeMaker は最初の行だけを読み込んでアンダースコアを読みますが、Perl インタプリタは $VERSION を評価して文字列を数値に変換します。後になって $VERSION を数値として扱う操作を行っても、$VERSION が数値ではないという警告を表示することなく行うことができるようになります。</target>
        </trans-unit>
        <trans-unit id="fa542340f7199357b9ddb7d211923c323666ef12" translate="yes" xml:space="preserve">
          <source>With the &quot;tcp&quot; protocol the ping() method attempts to establish a connection to the remote host's echo port. If the connection is successfully established, the remote host is considered reachable. No data is actually echoed. This protocol does not require any special privileges but has higher overhead than the &quot;udp&quot; and &quot;icmp&quot; protocols.</source>
          <target state="translated">tcp&quot; プロトコルでは、ping()メソッドはリモートホストの echo ポートへの接続の確立を試みます。接続が確立された場合は、リモートホストに到達可能であるとみなされます。実際にはデータはエコーされません。このプロトコルは特別な権限を必要としませんが、 &quot;udp&quot; や &quot;icmp&quot; プロトコルよりも高いオーバーヘッドを持ちます。</target>
        </trans-unit>
        <trans-unit id="0c9c2cd66698ade01d6241c0c3475076fe41182f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma you can use the &lt;code&gt;:locale&lt;/code&gt; layer</source>
          <target state="translated">では &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; プラグマを使用でき &lt;code&gt;:locale&lt;/code&gt; レイヤーを</target>
        </trans-unit>
        <trans-unit id="e4721b12184df4c626e83aff44b61b424dee2894" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , etc. are immediately available for use in the replacement expression. With the global modifier, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; will search and replace all occurrences of the regex in the string:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; 演算子、マッチ変数 &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; などは、置換式ですぐに使用可能です。グローバル修飾子を使用すると、 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; は文字列内のすべての正規表現を検索して置換します。</target>
        </trans-unit>
        <trans-unit id="a5f3ac7301bb1927406401553bc7979a7058d48f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; pragma you can control the behaviour of the builtin &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">で &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; プラグマあなたは、組み込み用の動作を制御することができます &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort()&lt;/a&gt;&lt;/code&gt; 関数を。</target>
        </trans-unit>
        <trans-unit id="ed30d894507576a6aff023249124e00f485a0445" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;IN&lt;/code&gt; subpragma you can declare the default layers of input streams, and with the &lt;code&gt;OUT&lt;/code&gt; subpragma you can declare the default layers of output streams. With the &lt;code&gt;IO&lt;/code&gt; subpragma (may be omitted for &lt;code&gt;:utf8&lt;/code&gt;, &lt;code&gt;:locale&lt;/code&gt;, or &lt;code&gt;:encoding&lt;/code&gt;) you can control both input and output streams simultaneously.</source>
          <target state="translated">&lt;code&gt;IN&lt;/code&gt; サブプラグマあなたは、入力ストリームのデフォルト層を宣言することができ、かつと &lt;code&gt;OUT&lt;/code&gt; のサブプラグマあなたは、出力ストリームのデフォルト層を宣言することができます。 &lt;code&gt;IO&lt;/code&gt; のサブプラグマ（のために省略されてもよい &lt;code&gt;:utf8&lt;/code&gt; 、 &lt;code&gt;:locale&lt;/code&gt; 、または &lt;code&gt;:encoding&lt;/code&gt; ）を使用すると、入力と出力の両方を制御することができ、同時にストリーム。</target>
        </trans-unit>
        <trans-unit id="640e6849be58e830210cdb457742bd0e5d46239f" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;IN&lt;/code&gt; subpragma you can declare the default layers of input streams, and with the &lt;code&gt;OUT&lt;/code&gt; subpragma you can declare the default layers of output streams. With the &lt;code&gt;IO&lt;/code&gt; subpragma you can control both input and output streams simultaneously.</source>
          <target state="translated">&lt;code&gt;IN&lt;/code&gt; サブプラグマあなたは、入力ストリームのデフォルト層を宣言することができ、かつと &lt;code&gt;OUT&lt;/code&gt; のサブプラグマあなたは、出力ストリームのデフォルト層を宣言することができます。 &lt;code&gt;IO&lt;/code&gt; のサブプラグマあなたは、入力と出力の両方が同時にストリームを制御することができます。</target>
        </trans-unit>
        <trans-unit id="9a9bb48f29cda9ceed93d7949280d0a2ae7a947b" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; logical name defined as &quot;ENABLE&quot;, setting &lt;code&gt;$?&lt;/code&gt; will cause the new value to be encoded into &lt;code&gt;$^E&lt;/code&gt; so that either the original parent or child exit status values 0 to 255 can be automatically recovered by C programs expecting _POSIX_EXIT behavior. If both a parent and a child exit value are non-zero, then it will be assumed that this is actually a VMS native status value to be passed through. The special value of 0xFFFF is almost a NOOP as it will cause the current native VMS status in the C library to become the current native Perl VMS status, and is handled this way as it is known to not be a valid native VMS status value. It is recommend that only values in the range of normal Unix parent or child status numbers, 0 to 255 are used.</source>
          <target state="translated">「ENABLE」として定義された &lt;code&gt;PERL_VMS_POSIX_EXIT&lt;/code&gt; 論理名を使用して、 &lt;code&gt;$?&lt;/code&gt; 新しい値が &lt;code&gt;$^E&lt;/code&gt; エンコードされるので、元の親または子の終了ステータス値0〜255は、_POSIX_EXIT動作を期待するCプログラムによって自動的に回復できます。親と子の両方の終了値がゼロ以外の場合、これは実際に渡されるVMSネイティブステータス値であると見なされます。特別な値0xFFFFは、Cライブラリの現在のネイティブVMSステータスを現在のネイティブPerl VMSステータスにするため、ほぼNOOPであり、有効なネイティブVMSステータス値ではないことがわかっているため、このように処理されます。通常のUnixの親または子のステータス番号の範囲（0〜255）の値のみを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d83714fab9481b19a76857b0c66b38bb676d9244" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;open&lt;/code&gt; pragma you can use the &lt;code&gt;:locale&lt;/code&gt; layer</source>
          <target state="translated">では &lt;code&gt;open&lt;/code&gt; プラグマを使用でき &lt;code&gt;:locale&lt;/code&gt; レイヤーを</target>
        </trans-unit>
        <trans-unit id="5aef762dfae7dd14d56c63866d88c9f9105ac20d" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;s///&lt;/code&gt; operator, the matched variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc. are immediately available for use in the replacement expression. With the global modifier, &lt;code&gt;s///g&lt;/code&gt; will search and replace all occurrences of the regex in the string:</source>
          <target state="translated">&lt;code&gt;s///&lt;/code&gt; 演算子、マッチ変数 &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; などは、置換式ですぐに使用可能です。グローバル修飾子を使用すると、 &lt;code&gt;s///g&lt;/code&gt; は、文字列内の正規表現のすべての出現箇所を検索して置き換えます。</target>
        </trans-unit>
        <trans-unit id="2822b5f3a724906c266471a5abc1878fe1a5daf9" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;sort&lt;/code&gt; pragma you can control the behaviour of the builtin &lt;code&gt;sort()&lt;/code&gt; function.</source>
          <target state="translated">で &lt;code&gt;sort&lt;/code&gt; プラグマあなたは、組み込み用の動作を制御することができます &lt;code&gt;sort()&lt;/code&gt; 関数を。</target>
        </trans-unit>
        <trans-unit id="d85c0b58283979a05b1d958cf7b8e77666b21187" translate="yes" xml:space="preserve">
          <source>With the C-style operators that would have been written like this:</source>
          <target state="translated">こんな感じで書かれていたであろうCスタイルの演算子を使うと</target>
        </trans-unit>
        <trans-unit id="12231f536f1fde7f945e73b86c0bb0963f5133af" translate="yes" xml:space="preserve">
          <source>With the FCGI module (from CPAN) and the mod_fastcgi module (available from &lt;a href=&quot;http://www.fastcgi.com/&quot;&gt;http://www.fastcgi.com/&lt;/a&gt; ) each of your Perl programs becomes a permanent CGI daemon process.</source>
          <target state="translated">FCGIモジュール（CPANから）およびmod_fastcgiモジュール（&lt;a href=&quot;http://www.fastcgi.com/&quot;&gt;http://www.fastcgi.com/&lt;/a&gt;から入手可能）を使用すると、Perlプログラムのそれぞれが永続的なCGIデーモンプロセスになります。</target>
        </trans-unit>
        <trans-unit id="e9f0f761b750ef587b104ca22707f7d417110d25" translate="yes" xml:space="preserve">
          <source>With the MASK argument present, it sets the operator mask for the compartment (equivalent to calling the deny_only method).</source>
          <target state="translated">引数MASKが存在する場合、コンパートメントの演算子マスクを設定します(deny_onlyメソッドを呼び出すのと同等です)。</target>
        </trans-unit>
        <trans-unit id="a26ddc37c924b20873cf0fb8deaac6c02f3c0643" translate="yes" xml:space="preserve">
          <source>With the _POSIX_EXIT macro set, the Unix exit value of zero is represented as a VMS native status of 1, and the Unix values from 2 to 255 are encoded by the equation:</source>
          <target state="translated">POSIX_EXIT マクロが設定されている場合、Unix の終了値ゼロは VMS ネイティブのステータス 1 として表現され、2 から 255 までの Unix の値は式でエンコードされます。</target>
        </trans-unit>
        <trans-unit id="ca23bf605fbab54b13a6b11fd9b026fcad525316" translate="yes" xml:space="preserve">
          <source>With the above regexp all content following (and including) any of the given &lt;code&gt;=head1&lt;/code&gt; headings will be shown. It is possible to restrict the output to particular subsections only, e.g.:</source>
          <target state="translated">上記の正規表現を使用すると、指定された &lt;code&gt;=head1&lt;/code&gt; 見出しのいずれかに続く（およびそれを含む）すべてのコンテンツが表示されます。出力を特定のサブセクションのみに制限することができます。例：</target>
        </trans-unit>
        <trans-unit id="b04e80858e882edcc84d0f324c4fa0f1bc41eaae" translate="yes" xml:space="preserve">
          <source>With the check_sigs parameter you can turn signature checking on and off. The default is off for now because the whole tool chain for the functionality is not yet considered mature by some. The author of CPAN.pm would recommend setting it to true most of the time and turning it off only if it turns out to be annoying.</source>
          <target state="translated">check_sigs パラメータで署名チェックのオンオフを切り替えることができます。機能のためのツールチェーン全体がまだ成熟していないと考える人もいるので、今のところデフォルトはoffです。CPAN.pm の作者はこのパラメータをほとんどの場合 true に設定して、面倒な場合のみ off にすることを推奨しています。</target>
        </trans-unit>
        <trans-unit id="65d6f831578499e9dbe5b97d3e54d9d6970d12d6" translate="yes" xml:space="preserve">
          <source>With the completion of Example 4, we now have an easy way to simulate some real-life libraries whose interfaces may not be the cleanest in the world. We shall now continue with a discussion of the arguments passed to the &lt;b&gt;xsubpp&lt;/b&gt; compiler.</source>
          <target state="translated">例4が完了すると、インターフェイスが世界で最もクリーンではない可能性のある実際のライブラリを簡単にシミュレートできるようになりました。次に、&lt;b&gt;xsubpp&lt;/b&gt;コンパイラーに渡される引数の説明を続けます。</target>
        </trans-unit>
        <trans-unit id="1f205214a6ba2cf07a234149bf2d1460c5296c50" translate="yes" xml:space="preserve">
          <source>With the creation of the &lt;code&gt;IO::Compress&lt;/code&gt; and &lt;code&gt;IO::Uncompress&lt;/code&gt; modules no new features are planned for &lt;code&gt;Compress::Zlib&lt;/code&gt; - the new modules do everything that &lt;code&gt;Compress::Zlib&lt;/code&gt; does and then some. Development on &lt;code&gt;Compress::Zlib&lt;/code&gt; will be limited to bug fixes only.</source>
          <target state="translated">&lt;code&gt;IO::Compress&lt;/code&gt; および &lt;code&gt;IO::Uncompress&lt;/code&gt; モジュールの作成により、 &lt;code&gt;Compress::Zlib&lt;/code&gt; の新機能は計画されていません。新しいモジュールは、 &lt;code&gt;Compress::Zlib&lt;/code&gt; が実行するすべての機能を実行し、その後いくつかの機能を実行します。 &lt;code&gt;Compress::Zlib&lt;/code&gt; 開発は、バグ修正のみに限定されます。</target>
        </trans-unit>
        <trans-unit id="257b1120ebcd7fe1453a131da8ee68f42d2f7003" translate="yes" xml:space="preserve">
          <source>With the default setting of &lt;code&gt;$Storable::flags&lt;/code&gt; = 6, creating or destroying random objects, even renamed objects can be controlled by an attacker. See CVE-2015-1592 and its metasploit module.</source>
          <target state="translated">&lt;code&gt;$Storable::flags&lt;/code&gt; = 6のデフォルト設定では、ランダムなオブジェクトを作成または破棄し、名前が変更されたオブジェクトでさえ攻撃者によって制御される可能性があります。CVE-2015-1592とそのmetasploitモジュールを参照してください。</target>
        </trans-unit>
        <trans-unit id="23f3553b9522af30d1dac804157bedd65e6495d3" translate="yes" xml:space="preserve">
          <source>With the default setting the size is limited to 128MB. The -1 removes this limit. If the &quot;make test&quot; fails please change your /etc/security/limits as stated above.</source>
          <target state="translated">デフォルトの設定では、サイズは128MBに制限されています。1はこの制限を解除します。make test&quot; が失敗した場合は、上記のように /etc/security/limits を変更してください。</target>
        </trans-unit>
        <trans-unit id="9b9699d8827c96371e7103bd01aa95e9549d18da" translate="yes" xml:space="preserve">
          <source>With the example above, you knew to look for &lt;code&gt;Perl_pp_add&lt;/code&gt; , but what if there were multiple calls to it all over the place, or you didn't know what the op was you were looking for?</source>
          <target state="translated">上記の例では、 &lt;code&gt;Perl_pp_add&lt;/code&gt; を探すことはわかっていましたが、その場所全体で複数の呼び出しがあった場合や、探している操作がわからない場合はどうでしょうか。</target>
        </trans-unit>
        <trans-unit id="cfa6b797e8e5233002fffa69434e7ca138b4ff32" translate="yes" xml:space="preserve">
          <source>With the example above, you knew to look for &lt;code&gt;Perl_pp_add&lt;/code&gt;, but what if there were multiple calls to it all over the place, or you didn't know what the op was you were looking for?</source>
          <target state="translated">上記の例では、 &lt;code&gt;Perl_pp_add&lt;/code&gt; を探すことは知っていましたが、あちこちで複数の呼び出しがあった場合、または探している操作がわからなかった場合はどうでしょうか。</target>
        </trans-unit>
        <trans-unit id="65607d779f766d1b6b4828b7428d0ded3d690325" translate="yes" xml:space="preserve">
          <source>With the following options you get a Perl version which passes all make tests in 32-bit mode.</source>
          <target state="translated">以下のオプションを使用すると、32ビットモードですべてのmakeテストに合格するPerlバージョンが得られます。</target>
        </trans-unit>
        <trans-unit id="a8358873bd6ba12b8e2a5bea80bf9adbb46e0a6e" translate="yes" xml:space="preserve">
          <source>With the following options you get a Perl version which passes all make tests in 64-bit mode.</source>
          <target state="translated">以下のオプションを使用すると、64 ビットモードですべての make テストに合格する Perl バージョンが得られます。</target>
        </trans-unit>
        <trans-unit id="26bc1ab7fe70714950b9630e3ca1a3522b890186" translate="yes" xml:space="preserve">
          <source>With the following options you get a threaded Perl version which passes all make tests in 64-bit mode.</source>
          <target state="translated">以下のオプションを使用すると、64 ビットモードですべての make テストをパスするスレッド型 Perl バージョンが得られます。</target>
        </trans-unit>
        <trans-unit id="653ecd70c393a4f98976d6cf49198158a3d68bae" translate="yes" xml:space="preserve">
          <source>With the following options you get a threaded Perl version which passes all make tests in threaded 32-bit mode, which is the default configuration for the Perl builds that AIX ships with.</source>
          <target state="translated">以下のオプションを使用すると、AIX で出荷されている Perl ビルドのデフォルト設定であるスレッド 32 ビットモードですべての make テストをパスするスレッド付き Perl バージョンが得られます。</target>
        </trans-unit>
        <trans-unit id="aeae9f602df12b1cbf706e0ffe90fc7d11fa8d65" translate="yes" xml:space="preserve">
          <source>With the help of Jarkko Hietaniemi the Configure system has been tweaked to run under abc-shell so the recommend build process is as follows.</source>
          <target state="translated">Jarkko Hietaniemi の助けを借りて、Configure システムが abc-shell で動作するように調整されたので、推奨ビルドプロセスは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="826dec98b275c7a952ab77d69c22223ec197d3b5" translate="yes" xml:space="preserve">
          <source>With the introduction of lexical warnings, mandatory warnings now become</source>
          <target state="translated">語彙的警告の導入により、強制的な警告は、現在では</target>
        </trans-unit>
        <trans-unit id="cb83c7552e22c7b5119774691db23c4fd72dba00" translate="yes" xml:space="preserve">
          <source>With the introduction of the</source>
          <target state="translated">の導入に伴い</target>
        </trans-unit>
        <trans-unit id="dd358809edabd87f2081065d37eb93940f155fac" translate="yes" xml:space="preserve">
          <source>With the lock released, process &quot;B&quot; can now continue. It also updates the database and unfortunately it too modifies the data that was in its initial buffer. Once that data gets flushed to disk it will overwrite some/all of the changes process &quot;A&quot; made to the database.</source>
          <target state="translated">ロックが解除されたことで、プロセス「B」は続行できるようになりました。また、データベースを更新しますが、残念ながら、初期バッファにあったデータも変更されます。一旦そのデータがディスクにフラッシュされると、プロセス「A」がデータベースに加えた変更の一部またはすべてを上書きしてしまいます。</target>
        </trans-unit>
        <trans-unit id="b4b71a45e3d179fe5db4257fdf8f0f1934140fcb" translate="yes" xml:space="preserve">
          <source>With the release 5.003_01 the dynamically loadable libraries should be rebuilt when a different version of Perl is compiled. In particular, DLLs (including</source>
          <target state="translated">リリース5.003_01では、異なるバージョンのPerlがコンパイルされたときに、動的にロード可能なライブラリが再構築されるようになっています。特に、DLL (</target>
        </trans-unit>
        <trans-unit id="a313290bcf78e6ca63c8b821c60748978a4d212c" translate="yes" xml:space="preserve">
          <source>With this keyword present &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;&quot;The RETVAL Variable&quot;&lt;/a&gt; is created, and in the generated call to the subroutine this variable is assigned to, but the value of this variable is not going to be used in the auto-generated code.</source>
          <target state="translated">このキーワードが存在すると、&lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;「RETVAL変数」&lt;/a&gt;が作成され、サブルーチンへの生成された呼び出しでこの変数が割り当てられますが、この変数の値は自動生成されたコードでは使用されません。</target>
        </trans-unit>
        <trans-unit id="5325c34a4ae29cf34042f77f365e0b89df2159a0" translate="yes" xml:space="preserve">
          <source>With this keyword present &lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;The RETVAL Variable&lt;/a&gt; is created, and in the generated call to the subroutine this variable is assigned to, but the value of this variable is not going to be used in the auto-generated code.</source>
          <target state="translated">このキーワードを指定すると&lt;a href=&quot;#The-RETVAL-Variable&quot;&gt;、RETVAL変数&lt;/a&gt;が作成され、サブルーチンへの生成された呼び出しでこの変数が割り当てられますが、この変数の値は自動生成コードでは使用されません。</target>
        </trans-unit>
        <trans-unit id="92fdd49156ba7199f10cc8d72686bcba30a111b6" translate="yes" xml:space="preserve">
          <source>With this method you can specify your own boolean values for decoding - on decode, JSON &lt;code&gt;false&lt;/code&gt; will be decoded as a copy of &lt;code&gt;$false&lt;/code&gt;, and JSON &lt;code&gt;true&lt;/code&gt; will be decoded as &lt;code&gt;$true&lt;/code&gt; (&quot;copy&quot; here is the same thing as assigning a value to another variable, i.e. &lt;code&gt;$copy = $false&lt;/code&gt;).</source>
          <target state="translated">この方法を使用すると、復号化するために独自のブール値を指定することができます-デコードに、JSONの &lt;code&gt;false&lt;/code&gt; のコピーとしてデコードされます &lt;code&gt;$false&lt;/code&gt; 、およびJSON &lt;code&gt;true&lt;/code&gt; としてデコードされます &lt;code&gt;$true&lt;/code&gt; 「コピー」（ここでは値を割り当てることと同じです別の変数に、つまり &lt;code&gt;$copy = $false&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="666c6c1292ea8eefe8526f26c75c36dbe91118ff" translate="yes" xml:space="preserve">
          <source>With this module, simply change all &lt;code&gt;use_ok&lt;/code&gt; in test scripts to &lt;code&gt;use ok&lt;/code&gt;, and they will be executed at &lt;code&gt;BEGIN&lt;/code&gt; time.</source>
          <target state="translated">このモジュールでは、テストスクリプトのすべての &lt;code&gt;use_ok&lt;/code&gt; を &lt;code&gt;use ok&lt;/code&gt; を使用するように変更するだけで、 &lt;code&gt;BEGIN&lt;/code&gt; 時に実行されます。</target>
        </trans-unit>
        <trans-unit id="153c87b7fb53ffdf16b2513e4ef9fbf84bb1453a" translate="yes" xml:space="preserve">
          <source>With this module, simply change all &lt;code&gt;use_ok&lt;/code&gt; in test scripts to &lt;code&gt;use ok&lt;/code&gt;, and they will be executed at &lt;code&gt;BEGIN&lt;/code&gt; time. The explicit space after &lt;code&gt;use&lt;/code&gt; makes it clear that this is a single compile-time action.</source>
          <target state="translated">このモジュールでは、テストスクリプトのすべての &lt;code&gt;use_ok&lt;/code&gt; を &lt;code&gt;use ok&lt;/code&gt; を使用するように変更するだけで、 &lt;code&gt;BEGIN&lt;/code&gt; 時に実行されます。 &lt;code&gt;use&lt;/code&gt; 後の明示的なスペースにより、これが単一のコンパイル時アクションであることが明確になります。</target>
        </trans-unit>
        <trans-unit id="1f7c25b6745f51eae37c62a2374f7ba131484e1b" translate="yes" xml:space="preserve">
          <source>With this option, the rendering of each statement (starting with the nextstate OP) will be preceded by the 1st line of source code that generates it. For example:</source>
          <target state="translated">このオプションを使用すると、各ステートメントのレンダリング(nextstate OPで始まる)の前には、それを生成するソースコードの1行目が表示されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="8f18c563efb0b7956e6e194500e98dba172fcbe5" translate="yes" xml:space="preserve">
          <source>With this syntax, the whitespace character(s) after the &quot;C&amp;lt;&amp;lt;&amp;lt;&quot; and before the &quot;&amp;gt;&amp;gt;&amp;gt;&quot; (or whatever letter) are</source>
          <target state="translated">この構文では、 &quot;C &amp;lt;&amp;lt;&amp;lt;&quot;の後、 &quot;&amp;gt;&amp;gt;&amp;gt;&quot;（または任意の文字）の前の空白文字は</target>
        </trans-unit>
        <trans-unit id="9b739cdb3f9d5a8eac7c3872d89896d374a02d63" translate="yes" xml:space="preserve">
          <source>With this, &quot;somepackage&quot; will be required, then the stash is inspected, and each function is rendered.</source>
          <target state="translated">これで、&quot;somepackage &quot;が必要になり、その後、stashを検査し、各関数をレンダリングします。</target>
        </trans-unit>
        <trans-unit id="a5fec2f4d5db8c4f13f212d9ea51033367a444e6" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;charinrange()&lt;/code&gt; will return &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if its input code point maps to &lt;code&gt;$default&lt;/code&gt; . You can avoid this by omitting the &lt;code&gt;&lt;a href=&quot;../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement, and adding a line after the loop to handle the final element of the inversion map.</source>
          <target state="translated">これにより、 &lt;code&gt;charinrange()&lt;/code&gt; は、その入力コードポイントが &lt;code&gt;$default&lt;/code&gt; マップされている場合、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。これを回避するには、 &lt;code&gt;&lt;a href=&quot;../functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; ステートメントを省略し、ループの後に反転マップの最後の要素を処理する行を追加します。</target>
        </trans-unit>
        <trans-unit id="1fa4ea5d2b0cc15e776882f8e7626028cc55d8d1" translate="yes" xml:space="preserve">
          <source>With this, &lt;code&gt;charinrange()&lt;/code&gt; will return &lt;code&gt;undef&lt;/code&gt; if its input code point maps to &lt;code&gt;$default&lt;/code&gt;. You can avoid this by omitting the &lt;code&gt;next&lt;/code&gt; statement, and adding a line after the loop to handle the final element of the inversion map.</source>
          <target state="translated">これにより、 &lt;code&gt;charinrange()&lt;/code&gt; は、入力コードポイントが &lt;code&gt;$default&lt;/code&gt; マップされている場合、 &lt;code&gt;undef&lt;/code&gt; を返します。これを回避するには、 &lt;code&gt;next&lt;/code&gt; ステートメントを省略し、ループの後に行を追加して、反転マップの最後の要素を処理します。</target>
        </trans-unit>
        <trans-unit id="cf65bbf1a94d413d2ba7d4e9b042fb1c11c5b955" translate="yes" xml:space="preserve">
          <source>With those two in hand, you should add</source>
          <target state="translated">この2つが揃った状態で</target>
        </trans-unit>
        <trans-unit id="6dae05359217975cb78e41e5b34deca474650edf" translate="yes" xml:space="preserve">
          <source>With threads one must be careful to make sure they all have a chance to run to completion, assuming that is what you want.</source>
          <target state="translated">スレッドで1つは、彼らはすべてあなたが望むものであると仮定して、完了するために実行する機会を持っていることを確認するように注意しなければなりません。</target>
        </trans-unit>
        <trans-unit id="caa257633e4cd0d103eaaa262d9da80593127c23" translate="yes" xml:space="preserve">
          <source>With todo tests, it's best to have the tests actually run. That way you'll know when they start passing. Sometimes this isn't possible. Often a failing test will cause the whole program to die or hang, even inside an &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; with and using &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt;. In these extreme cases you have no choice but to skip over the broken tests entirely.</source>
          <target state="translated">todoテストでは、テストを実際に実行するのが最善です。そうすれば、彼らがいつ通り過ぎるかがわかります。時々これは不可能です。多くの場合、テストに失敗すると、 &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; を使用した &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt; BLOCK&lt;/code&gt; 内でも、プログラム全体が停止またはハングします。これらの極端なケースでは、壊れたテストを完全にスキップするしかありません。</target>
        </trans-unit>
        <trans-unit id="72faa2ea768ae70d5c7c6ca8ac92ad17c2ec51b0" translate="yes" xml:space="preserve">
          <source>With todo tests, it's best to have the tests actually run. That way you'll know when they start passing. Sometimes this isn't possible. Often a failing test will cause the whole program to die or hang, even inside an &lt;code&gt;eval BLOCK&lt;/code&gt; with and using &lt;code&gt;alarm&lt;/code&gt;. In these extreme cases you have no choice but to skip over the broken tests entirely.</source>
          <target state="translated">ToDoテストでは、実際にテストを実行するのが最善です。そうすれば、彼らがいつ通過し始めるかを知ることができます。時々これは不可能です。多くの場合、テストが失敗すると、 &lt;code&gt;alarm&lt;/code&gt; 使用されている &lt;code&gt;eval BLOCK&lt;/code&gt; 内であっても、プログラム全体が停止またはハングします。これらの極端なケースでは、壊れたテストを完全にスキップする以外に選択肢はありません。</target>
        </trans-unit>
        <trans-unit id="ec0e094c2438c09cc3dbc2cdfeb2a697dd782dc5" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;(?[ ])&lt;/code&gt; , no literal characters are allowed unless they are within an inner pair of square brackets, like</source>
          <target state="translated">&lt;code&gt;(?[ ])&lt;/code&gt; 内では、リテラル文字は、次のように内側の大括弧のペア内にある場合を除き、許可されません。</target>
        </trans-unit>
        <trans-unit id="2c0a661c629aabc7b0ae903d13c19ad238648286" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;(?[ ])&lt;/code&gt;, no literal characters are allowed unless they are within an inner pair of square brackets, like</source>
          <target state="translated">&lt;code&gt;(?[ ])&lt;/code&gt; 内では、リテラル文字は、次のように角括弧の内側のペア内にない限り許可されません。</target>
        </trans-unit>
        <trans-unit id="2e8425db1df10e66ba739a46b6d044fcd9cc27fd" translate="yes" xml:space="preserve">
          <source>Within Perl, you may use this directly:</source>
          <target state="translated">Perl内では、これを直接使用することができます。</target>
        </trans-unit>
        <trans-unit id="34e265601157e7965a7e7bfdb3408a61baf139df" translate="yes" xml:space="preserve">
          <source>Within USS your /etc/profile or $HOME/.profile may limit your ulimit settings. Check that the following command returns reasonable values:</source>
          <target state="translated">USS 内では、/etc/profile や $HOME/.profile が ulimit の設定を制限している場合があります。以下のコマンドが妥当な値を返していることを確認してください。</target>
        </trans-unit>
        <trans-unit id="a1b6f4407e8eee6ed8eafbd79c8d18589c6adc10" translate="yes" xml:space="preserve">
          <source>Within []-length '%c' not allowed</source>
          <target state="translated">長さ '%c' は許可されません。</target>
        </trans-unit>
        <trans-unit id="29ba20619ba09719c47471e336e4ab5403150666" translate="yes" xml:space="preserve">
          <source>Within a Pod block, there are &lt;b&gt;Pod paragraphs&lt;/b&gt;. A Pod paragraph consists of non-blank lines of text, separated by one or more blank lines.</source>
          <target state="translated">ポッドブロック内には、&lt;b&gt;ポッドの段落があり&lt;/b&gt;ます。ポッドの段落は、1行以上の空白行で区切られた非空白行のテキストで構成されます。</target>
        </trans-unit>
        <trans-unit id="e21031e24f9ec987f957a61688b27e62b9c110c1" translate="yes" xml:space="preserve">
          <source>Within a character class:</source>
          <target state="translated">文字クラス内。</target>
        </trans-unit>
        <trans-unit id="40c178236d58dee9559c7a2a4195e7fba2bd546e" translate="yes" xml:space="preserve">
          <source>Within a pattern, you may designate subpatterns for later reference by enclosing them in parentheses, and you may refer back to the</source>
          <target state="translated">パターン内では、後から参照するためにサブパターンを括弧で囲んで指定することができます。</target>
        </trans-unit>
        <trans-unit id="0cfdb7962d912e72a66b4f3d5343b1e5e212ac27" translate="yes" xml:space="preserve">
          <source>Within a subroutine the array &lt;code&gt;@_&lt;/code&gt; contains the parameters passed to that subroutine. Inside a subroutine, &lt;code&gt;@_&lt;/code&gt; is the default array for the array operators &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">サブルーチン内では、配列 &lt;code&gt;@_&lt;/code&gt; には、そのサブルーチンに渡されるパラメーターが含まれています。サブルーチン内では、 &lt;code&gt;@_&lt;/code&gt; が配列演算子 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; のデフォルト配列です。</target>
        </trans-unit>
        <trans-unit id="e22e0024e5aeb5956fe2008749d86a9a403a100c" translate="yes" xml:space="preserve">
          <source>Within a subroutine the array &lt;code&gt;@_&lt;/code&gt; contains the parameters passed to that subroutine. Inside a subroutine, &lt;code&gt;@_&lt;/code&gt; is the default array for the array operators &lt;code&gt;pop&lt;/code&gt; and &lt;code&gt;shift&lt;/code&gt;.</source>
          <target state="translated">サブルーチン内では、配列 &lt;code&gt;@_&lt;/code&gt; にそのサブルーチンに渡されるパラメーターが含まれています。サブルーチン内では、 &lt;code&gt;@_&lt;/code&gt; は配列演算子 &lt;code&gt;pop&lt;/code&gt; および &lt;code&gt;shift&lt;/code&gt; のデフォルトの配列です。</target>
        </trans-unit>
        <trans-unit id="61eb6fb3f1061f743841ee282bbf0ef293486491" translate="yes" xml:space="preserve">
          <source>Within each function inside each Xsub, print to the</source>
          <target state="translated">各Xsub内の各関数内で</target>
        </trans-unit>
        <trans-unit id="2ab4fe9703eceeab90b6dcb41e63f66c50a795d5" translate="yes" xml:space="preserve">
          <source>Within search patterns (which also undergo double-quotish substitution) there is an unfortunate ambiguity: Is &lt;code&gt;/$foo[bar]/&lt;/code&gt; to be interpreted as &lt;code&gt;/${foo}[bar]/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is a character class for the regular expression) or as &lt;code&gt;/${foo[bar]}/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is the subscript to array @foo)? If @foo doesn't otherwise exist, then it's obviously a character class. If @foo exists, Perl takes a good guess about &lt;code&gt;[bar]&lt;/code&gt; , and is almost always right. If it does guess wrong, or if you're just plain paranoid, you can force the correct interpretation with curly braces as above.</source>
          <target state="translated">検索パターン（二重引用符の置換も受ける）内には、あいにくあいまいさがあります： &lt;code&gt;/$foo[bar]/&lt;/code&gt; は &lt;code&gt;/${foo}[bar]/&lt;/code&gt; として解釈されます（ &lt;code&gt;[bar]&lt;/code&gt; は、正規表現）または &lt;code&gt;/${foo[bar]}/&lt;/code&gt; （ &lt;code&gt;[bar]&lt;/code&gt; は配列@fooの添え字）として？ @fooが他に存在しない場合、それは明らかに文字クラスです。 @fooが存在する場合、Perlは &lt;code&gt;[bar]&lt;/code&gt; について適切な推測を行い、ほとんどの場合正しい。推測が間違っている場合、または単なる偏執狂である場合は、上記のように中括弧で正しい解釈を強制できます。</target>
        </trans-unit>
        <trans-unit id="7cb74f80aa6eb14f52d2f4452df6c30aa1982c05" translate="yes" xml:space="preserve">
          <source>Within search patterns (which also undergo double-quotish substitution) there is an unfortunate ambiguity: Is &lt;code&gt;/$foo[bar]/&lt;/code&gt; to be interpreted as &lt;code&gt;/${foo}[bar]/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is a character class for the regular expression) or as &lt;code&gt;/${foo[bar]}/&lt;/code&gt; (where &lt;code&gt;[bar]&lt;/code&gt; is the subscript to array @foo)? If @foo doesn't otherwise exist, then it's obviously a character class. If @foo exists, Perl takes a good guess about &lt;code&gt;[bar]&lt;/code&gt;, and is almost always right. If it does guess wrong, or if you're just plain paranoid, you can force the correct interpretation with curly braces as above.</source>
          <target state="translated">（また、ダブルquotish置換を受ける）検索パターン内不幸曖昧さがある：ある &lt;code&gt;/$foo[bar]/&lt;/code&gt; として解釈されるべき &lt;code&gt;/${foo}[bar]/&lt;/code&gt; （ &lt;code&gt;[bar]&lt;/code&gt; の文字クラスであります正規表現）または &lt;code&gt;/${foo[bar]}/&lt;/code&gt; （ &lt;code&gt;[bar]&lt;/code&gt; は配列@fooの添え字）として？@fooが他に存在しない場合、それは明らかに文字クラスです。@fooが存在する場合、Perlは &lt;code&gt;[bar]&lt;/code&gt; について適切な推測を行い、ほとんどの場合正しいです。推測が間違っている場合、または単に妄想的である場合は、上記のように中括弧を使用して正しい解釈を強制できます。</target>
        </trans-unit>
        <trans-unit id="d84dbb525d8c49a11b671ff1144decfba831a5a9" translate="yes" xml:space="preserve">
          <source>Within strings that are to be displayed in a fixed-length text field, each control character is substituted by a space. (But remember the special meaning of &lt;code&gt;\r&lt;/code&gt; when using fill mode.) This is done to avoid misalignment when control characters &quot;disappear&quot; on some output media.</source>
          <target state="translated">固定長テキストフィールドに表示される文字列内では、各制御文字はスペースに置き換えられます。（ただし、塗りつぶしモードを使用するときは、 &lt;code&gt;\r&lt;/code&gt; 特別な意味を覚えておいてください。）これは、一部の出力メディアで制御文字が「消える」ときの調整不良を回避するために行われます。</target>
        </trans-unit>
        <trans-unit id="4456754ccf74e411d5ea49ec8792a5f2c7c3945a" translate="yes" xml:space="preserve">
          <source>Within that basic form, add the parts that you need to insert, change, or delete lines.</source>
          <target state="translated">その基本フォームの中に、行の挿入、変更、削除に必要な部分を追加します。</target>
        </trans-unit>
        <trans-unit id="8cbc5afc548aa028061d92c2e27d708ba5cdc361" translate="yes" xml:space="preserve">
          <source>Within that module, create an &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine.</source>
          <target state="translated">そのモジュール内で、 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; サブルーチンを作成します。</target>
        </trans-unit>
        <trans-unit id="dff20e9d902ef01082006d18ff0c36d8795b519a" translate="yes" xml:space="preserve">
          <source>Within that module, create an &lt;code&gt;import&lt;/code&gt; subroutine.</source>
          <target state="translated">そのモジュール内に、 &lt;code&gt;import&lt;/code&gt; サブルーチンを作成します。</target>
        </trans-unit>
        <trans-unit id="8c44a88f26bc68b39089193962c587ad7e818543" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine do a call to &lt;code&gt;filter_add&lt;/code&gt; , passing it either a subroutine reference.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; サブルーチン内で &lt;code&gt;filter_add&lt;/code&gt; を呼び出し、サブルーチン参照のいずれかを渡します。</target>
        </trans-unit>
        <trans-unit id="5abecf0e7e2c92cb0f99df6a077dc9ac3a61e15b" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;import&lt;/code&gt; subroutine do a call to &lt;code&gt;filter_add&lt;/code&gt;, passing it either a subroutine reference.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; サブルーチン内で &lt;code&gt;filter_add&lt;/code&gt; を呼び出し、サブルーチン参照を渡します。</target>
        </trans-unit>
        <trans-unit id="66ccfeaad3b7f2de2f94c5b7b2a2afe57c62216c" translate="yes" xml:space="preserve">
          <source>Within the alternative numbering group, group numbers start at the same position for each alternative. After the group, numbering continues with one higher than the maximum reached across all the alternatives.</source>
          <target state="translated">代替番号付けグループ内では、グループ番号は各代替案の同じ位置から始まる。グループの後、番号付けは、すべての代替案で到達した最大値よりも1つ高い番号で継続される。</target>
        </trans-unit>
        <trans-unit id="bee307dd55ae8e02f4730b754c6aca4828fa5f41" translate="yes" xml:space="preserve">
          <source>Within the anonymous subroutine or block that is passed to &lt;code&gt;FILTER&lt;/code&gt; , process the contents of $_ to change the source code in the desired manner.</source>
          <target state="translated">&lt;code&gt;FILTER&lt;/code&gt; に渡される匿名のサブルーチンまたはブロック内で、$ _の内容を処理して、ソースコードを目的の方法で変更します。</target>
        </trans-unit>
        <trans-unit id="f2c9c97c479e458c15e3c5d21939c42abe0d2569" translate="yes" xml:space="preserve">
          <source>Within the anonymous subroutine or block that is passed to &lt;code&gt;FILTER&lt;/code&gt;, process the contents of $_ to change the source code in the desired manner.</source>
          <target state="translated">&lt;code&gt;FILTER&lt;/code&gt; に渡される匿名のサブルーチンまたはブロック内で、$ _の内容を処理して、ソースコードを目的の方法で変更します。</target>
        </trans-unit>
        <trans-unit id="4dffaf4183817eca592a98bbc21aa16f78f04d43" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;use feature 'unicode_strings'&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt; &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; &lt;/a&gt;範囲内機能「unicode_strings」</target>
        </trans-unit>
        <trans-unit id="00c20e56f1d9e34b6bd5de0acc2c9d7db7958c51" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;use feature 'unicode_strings' &lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;feature#The-'unicode_strings'-feature&quot;&gt;使用機能「unicode_strings」の&lt;/a&gt;範囲内</target>
        </trans-unit>
        <trans-unit id="4f89e477d30d08ce7cdab550d7ebf952c865e297" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;locale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt;, all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">&lt;a href=&quot;locale&quot;&gt; &lt;code&gt;use locale&lt;/code&gt; &lt;/a&gt;の範囲内で、文字列がUTF-8としてエンコードされているかどうかに関係なく、すべての非ASCIILatin1コードポイントが引用符で囲まれます。上記のように、ロケールはASCII範囲の文字の引用には影響しません。これにより、 &lt;code&gt;&quot;|&quot;&lt;/code&gt; などの文字が含まれるロケールから保護されます。単語文字と見なされます。</target>
        </trans-unit>
        <trans-unit id="5cdd83d3707c192ff676dcfeb7f714897a412bb4" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;&lt;code&gt;use locale 'not_characters'&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;perllocale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt; and the current locale is a UTF-8 locale.</source>
          <target state="translated">&lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt; &lt;code&gt;use locale 'not_characters'&lt;/code&gt; &lt;/a&gt;のスコープ内、または&lt;a href=&quot;perllocale&quot;&gt; &lt;code&gt;use locale&lt;/code&gt; &lt;/a&gt;で、現在のロケールはUTF-8ロケールです。</target>
        </trans-unit>
        <trans-unit id="db5115b248b9b3a92796783fe0ad72c64d3ee250" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;use locale 'not_characters' &lt;/a&gt;, or &lt;a href=&quot;perllocale&quot;&gt;use locale &lt;/a&gt; and the current locale is a UTF-8 locale.</source>
          <target state="translated">範囲内で&lt;a href=&quot;perllocale#Unicode-and-UTF-8&quot;&gt;使用するロケール「not_characters」&lt;/a&gt;、または&lt;a href=&quot;perllocale&quot;&gt;使用ロケール&lt;/a&gt;と現在のロケールUTF-8ロケールです。</target>
        </trans-unit>
        <trans-unit id="4b75686c25d4349996112a3e43d160bed9377b64" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; or higher</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.012&lt;/code&gt; 範囲5.012以上</target>
        </trans-unit>
        <trans-unit id="921e8cdb506222d3c5cb715870308743278f73c9" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; の範囲内では、文字列がUTF-8としてエンコードされているかどうかに関係なく、すべての非ASCII Latin1コードポイントが引用されます。上記のように、ロケールはASCII範囲の文字の引用に影響を与えません。これにより、 &lt;code&gt;&quot;|&quot;&lt;/code&gt; などの文字が含まれるロケールから保護されます。単語文字と見なされます。</target>
        </trans-unit>
        <trans-unit id="7f97b0baeb5c1f48ecb7c6036a913594c0cf832a" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 範囲内utf8</target>
        </trans-unit>
        <trans-unit id="6c6da8dacdcff581b760f12d305142c260f19722" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , all non-ASCII Latin1 code points are quoted whether the string is encoded as UTF-8 or not. As mentioned above, locale does not affect the quoting of ASCII-range characters. This protects against those locales where characters such as &lt;code&gt;&quot;|&quot;&lt;/code&gt; are considered to be word characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; の範囲内では、文字列がUTF-8としてエンコードされているかどうかに関係なく、すべての非ASCII Latin1コードポイントが引用されます。上記のように、ロケールはASCII範囲の文字の引用に影響を与えません。これにより、 &lt;code&gt;&quot;|&quot;&lt;/code&gt; などの文字が含まれるロケールから保護されます。単語文字と見なされます。</target>
        </trans-unit>
        <trans-unit id="9be64790ef4be673df7cd3468e821cd802e4c982" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;use 5.012&lt;/code&gt; or higher</source>
          <target state="translated">&lt;code&gt;use 5.012&lt;/code&gt; 範囲5.012以上</target>
        </trans-unit>
        <trans-unit id="c2f08cf765adbbec5334990e6d1e73f436a06d62" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;use re 'strict'&lt;/code&gt; in a regular expression pattern, you included an unescaped &lt;code&gt;}&lt;/code&gt; or &lt;code&gt;]&lt;/code&gt; which was interpreted literally. These two characters are sometimes metacharacters, and sometimes literals, depending on what precedes them in the pattern. This is unlike the similar &lt;code&gt;)&lt;/code&gt; which is always a metacharacter unless escaped.</source>
          <target state="translated">正規表現パターンのre'strict &lt;code&gt;use re 'strict'&lt;/code&gt; の使用範囲内に、文字通りに解釈されたエスケープされていない &lt;code&gt;}&lt;/code&gt; または &lt;code&gt;]&lt;/code&gt; を含めました。これらの2つの文字は、パターン内で先行するものに応じて、メタ文字である場合とリテラルである場合があります。これは、エスケープされない限り常にメタ文字である同様の &lt;code&gt;)&lt;/code&gt; とは異なります。</target>
        </trans-unit>
        <trans-unit id="872708d75ba2c62155c9282b19d1ffd74c4ecb87" translate="yes" xml:space="preserve">
          <source>Within the scope of &lt;code&gt;use utf8&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;use utf8&lt;/code&gt; 範囲内utf8</target>
        </trans-unit>
        <trans-unit id="b93e8b9c84e9c172138891ffbac960fd8330a481" translate="yes" xml:space="preserve">
          <source>Within the subroutine reference, call &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; to &quot;prime&quot; $_ with source code data from the source file that will &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; your module. Check the status value returned to see if any source code was actually read in.</source>
          <target state="translated">サブルーチン参照内で、 &lt;code&gt;filter_read&lt;/code&gt; または &lt;code&gt;filter_read_exact&lt;/code&gt; を呼び出して、モジュールを &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; するソースファイルからのソースコードデータで$ _を「準備」します。返されたステータス値をチェックして、ソースコードが実際に読み込まれたかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="de9983c2f6aa6265b66999a54845fc283501a6b7" translate="yes" xml:space="preserve">
          <source>Within the subroutine reference, call &lt;code&gt;filter_read&lt;/code&gt; or &lt;code&gt;filter_read_exact&lt;/code&gt; to &quot;prime&quot; $_ with source code data from the source file that will &lt;code&gt;use&lt;/code&gt; your module. Check the status value returned to see if any source code was actually read in.</source>
          <target state="translated">サブルーチンリファレンス内で、 &lt;code&gt;filter_read&lt;/code&gt; または &lt;code&gt;filter_read_exact&lt;/code&gt; を呼び出して、モジュールを &lt;code&gt;use&lt;/code&gt; するソースファイルのソースコードデータを使用して$ _を「プライミング」します。返されたステータス値をチェックして、ソースコードが実際に読み込まれたかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="7d5ec220eb3f4bb73f8ef5f923e39ec8ab09a071" translate="yes" xml:space="preserve">
          <source>Within the while loop we call accept() and check to see if it returns a false value. This would normally indicate a system error needs to be reported. However, the introduction of safe signals (see &lt;a href=&quot;#Deferred-Signals-%28Safe-Signals%29&quot;&gt;&quot;Deferred Signals (Safe Signals)&quot;&lt;/a&gt; above) in Perl 5.8.0 means that accept() might also be interrupted when the process receives a signal. This typically happens when one of the forked subprocesses exits and notifies the parent process with a CHLD signal.</source>
          <target state="translated">whileループ内で、accept（）を呼び出し、false値を返すかどうかを確認します。これは通常、システムエラーを報告する必要があることを示します。ただし、Perl 5.8.0での安全なシグナル（上記の&lt;a href=&quot;#Deferred-Signals-%28Safe-Signals%29&quot;&gt;「遅延シグナル（安全なシグナル）」を&lt;/a&gt;参照）の導入は、プロセスがシグナルを受信したときにaccept（）も中断される可能性があることを意味します。これは通常、フォークされたサブプロセスの1つが終了し、CHLDシグナルで親プロセスに通知するときに発生します。</target>
        </trans-unit>
        <trans-unit id="4f5dc8da9477105396ff0284ea2a7a7433b232a3" translate="yes" xml:space="preserve">
          <source>Within the while loop we call accept() and check to see if it returns a false value. This would normally indicate a system error needs to be reported. However, the introduction of safe signals (see &lt;a href=&quot;#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals)&lt;/a&gt; above) in Perl 5.8.0 means that accept() might also be interrupted when the process receives a signal. This typically happens when one of the forked subprocesses exits and notifies the parent process with a CHLD signal.</source>
          <target state="translated">whileループ内で、accept（）を呼び出し、false値を返すかどうかを確認します。これは通常、システムエラーを報告する必要があることを示します。ただし、Perl 5.8.0 での安全なシグナル（上記の&lt;a href=&quot;#Deferred-Signals-(Safe-Signals)&quot;&gt;遅延シグナル（安全なシグナル）を&lt;/a&gt;参照）の導入により、プロセスがシグナルを受信すると、accept（）も中断される可能性があります。これは通常、分岐したサブプロセスの1つが終了し、CHLDシグナルで親プロセスに通知するときに発生します。</target>
        </trans-unit>
        <trans-unit id="17b7808b8c8156fa9926b089d73ad2021671fe67" translate="yes" xml:space="preserve">
          <source>Without Readline support you may see the symbols &quot;^[[A&quot;, &quot;^[[C&quot;, &quot;^[[B&quot;, &quot;^[[D&quot;&quot;, &quot;^H&quot;, ... when using the arrow keys and/or the backspace key.</source>
          <target state="translated">Readlineをサポートしていない場合、矢印キーやバックスペースキーを使用すると、&quot;^[[A&quot;,&quot;^[[C&quot;,&quot;^[[B&quot;,&quot;^[[D&quot;,&quot;^H&quot;,...&quot;という記号が表示されることがあります。</target>
        </trans-unit>
        <trans-unit id="7a72072ff5468f365a1052f00033c60b07221002" translate="yes" xml:space="preserve">
          <source>Without additional configuration, GetOptions() will ignore the case of option names, and allow the options to be abbreviated to uniqueness.</source>
          <target state="translated">追加の設定がなければ、 GetOptions()はオプション名の大文字小文字を無視し、オプションを一意に省略できるようにします。</target>
        </trans-unit>
        <trans-unit id="6c913350e18f669953ddd82b1ef504eb99115e6c" translate="yes" xml:space="preserve">
          <source>Without any such configuration, or if Perl itself is built using the system's own IO, then write operations assume that the file handle accepts only</source>
          <target state="translated">そのような設定がない場合、あるいは Perl 自体がシステム独自の IO を使用して構築されている場合、書き込み操作はファイルハンドルが</target>
        </trans-unit>
        <trans-unit id="298442b657e2392a0a1bf4ca9f3ba61c68419ef3" translate="yes" xml:space="preserve">
          <source>Without argument, it returns the currently used icmp protocol message type. By default, it returns 'echo'.</source>
          <target state="translated">引数を指定しない場合は、現在使用されている icmp プロトコルのメッセージタイプを返します。デフォルトでは、'echo' を返します。</target>
        </trans-unit>
        <trans-unit id="d5efb30492f1c199d1a2c0cf117a4ad4a638df64" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves a regular expression for simplifying the individual item strings once the list type has been determined. Usage: E.g. when converting to HTML, one might strip the leading number in an ordered list as &lt;code&gt;&amp;lt;OL&amp;gt;&lt;/code&gt; already prints numbers itself. This must have been set before by either specifying &lt;b&gt;-rx&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;rx()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">引数がない場合、リストタイプが決定されたら、個々のアイテム文字列を簡略化するために正規表現を取得します。使用法：たとえば、HTMLに変換する場合、 &lt;code&gt;&amp;lt;OL&amp;gt;&lt;/code&gt; はすでに数値自体を出力しているため、順序付きリストの先頭の数値を削除する場合があります。これは、&lt;b&gt;new（）&lt;/b&gt;メソッドで&lt;b&gt;-rx&lt;/b&gt;を指定するか、スカラー引数を指定して&lt;b&gt;rx（）&lt;/b&gt;メソッドを呼び出すことにより、&lt;b&gt;事前&lt;/b&gt;に設定しておく必要があります。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="18657a3de0c78898530507337e291d8dba0f72cc" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves information about the list tag, which can be any scalar. This must have been set before by either specifying &lt;b&gt;-tag&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;tag()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">引数なしで、任意のスカラーのリストタグに関する情報を取得します。これは、&lt;b&gt;new（）&lt;/b&gt;メソッドで&lt;b&gt;-tag&lt;/b&gt;を指定するか、スカラー引数を指定して&lt;b&gt;tag（）&lt;/b&gt;メソッドを呼び出すことにより、&lt;b&gt;事前&lt;/b&gt;に設定しておく必要があります。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8ccc25a668b5326c657bc2f5c79197991b145ee7" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves information about the parent holding this list, which is represented as an arbitrary scalar. This must have been set before by either specifying &lt;b&gt;-parent&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;parent()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">引数なしで、このリストを保持する親に関する情報を取得します。これは、任意のスカラーとして表されます。これは、&lt;b&gt;new（）&lt;/b&gt;メソッドで&lt;b&gt;-parent&lt;/b&gt;を指定するか、スカラー引数を指定して&lt;b&gt;parent（）&lt;/b&gt;メソッドを呼び出すことにより、&lt;b&gt;事前&lt;/b&gt;に設定しておく必要があります。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c9f5dc6cba8c17ba8a8e789cb997502b75241827" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the array of the items in this list. The items may be represented by any scalar. If an argument has been given, it is pushed on the list of items.</source>
          <target state="translated">引数なしで、このリストの項目の配列を取得します。項目は任意のスカラーで表現することができます。引数が与えられた場合は、それがアイテムのリストにプッシュされます。</target>
        </trans-unit>
        <trans-unit id="b13b7cf761d2e7e6717a0226cb08e73a66d55812" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the file name the list is in. This must have been set before by either specifying &lt;b&gt;-file&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;file()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">引数なしで、リストが含まれているファイル名を取得します。これは、&lt;b&gt;new（）&lt;/b&gt;メソッドで&lt;b&gt;-file&lt;/b&gt;を指定するか、スカラー引数を指定して&lt;b&gt;file（）&lt;/b&gt;メソッドを呼び出すことにより、事前に設定しておく必要があります。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1b1eba0344418f60cab2e73b154b51b8cc2fd939" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the indent level of the list as specified in &lt;code&gt;=over n&lt;/code&gt; . This must have been set before by either specifying &lt;b&gt;-indent&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;indent()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">引数なしで、 &lt;code&gt;=over n&lt;/code&gt; で指定されたリストのインデントレベルを取得します。これは、&lt;b&gt;new（）&lt;/b&gt;メソッドで&lt;b&gt;-indent&lt;/b&gt;を指定するか、スカラー引数を指定して&lt;b&gt;indent（）&lt;/b&gt;メソッドを呼び出すことにより、&lt;b&gt;事前&lt;/b&gt;に設定しておく必要があります。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c3a863e0f35dbdfaea66e845edf4708bb6d53918" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the line number where the list started. This must have been set before by either specifying &lt;b&gt;-start&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;start()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">引数なしで、リストが始まった行番号を取得します。これは、&lt;b&gt;new（）&lt;/b&gt;メソッドで&lt;b&gt;-start&lt;/b&gt;を指定するか、スカラー引数を指定して&lt;b&gt;start（）&lt;/b&gt;メソッドを呼び出すことにより、事前に設定しておく必要があります。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="914d0fa2ff8badbccd79dfd30e292a8ed73be0c1" translate="yes" xml:space="preserve">
          <source>Without argument, retrieves the list type, which can be an arbitrary value, e.g. &lt;code&gt;OL&lt;/code&gt; , &lt;code&gt;UL&lt;/code&gt; , ... when thinking the HTML way. This must have been set before by either specifying &lt;b&gt;-type&lt;/b&gt; in the &lt;b&gt;new()&lt;/b&gt; method or by calling the &lt;b&gt;type()&lt;/b&gt; method with a scalar argument.</source>
          <target state="translated">引数なしで、リストのタイプを取得します。これは、HTMLの方法を考えるときに、 &lt;code&gt;OL&lt;/code&gt; 、 &lt;code&gt;UL&lt;/code&gt; などの任意の値にすることができます。これは、&lt;b&gt;new（）&lt;/b&gt;メソッドで&lt;b&gt;-type&lt;/b&gt;を指定するか、&lt;b&gt;type（）&lt;/b&gt;メソッドをスカラー引数で呼び出して、事前に設定しておく必要があります。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0c21aaff33380d9ba14cee3094239dfc4fb494ab" translate="yes" xml:space="preserve">
          <source>Without arguments libnetcfg displays the current configuration.</source>
          <target state="translated">引数なしでは libnetcfg は現在の設定を表示します。</target>
        </trans-unit>
        <trans-unit id="4decffda157c9d482865e95a2bef98fbdd07c180" translate="yes" xml:space="preserve">
          <source>Without autodie (and assuming BAREWORD is an open filehandle/dirhandle) this is a valid call to chdir. But under autodie, &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; will behave like it had the prototype &quot;;$&quot; and thus BAREWORD will be a syntax error (under &quot;use strict&quot;. Without strict, it will interpreted as a filename).</source>
          <target state="translated">autodieがなければ（BAREWORDが開いているファイルハンドル/ディレクトリハンドルであると仮定して）、これはchdirへの有効な呼び出しです。しかし、autodieでは、 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; はプロトタイプ「; $」の場合と同様に動作するため、BAREWORDは構文エラーになります（「use strict」では。strictがないと、ファイル名として解釈されます）。</target>
        </trans-unit>
        <trans-unit id="4f60150307dd02c8b93f0a67955bd9770e2759c8" translate="yes" xml:space="preserve">
          <source>Without autodie (and assuming BAREWORD is an open filehandle/dirhandle) this is a valid call to chdir. But under autodie, &lt;code&gt;chdir&lt;/code&gt; will behave like it had the prototype &quot;;$&quot; and thus BAREWORD will be a syntax error (under &quot;use strict&quot;. Without strict, it will interpreted as a filename).</source>
          <target state="translated">autodieがない場合（そしてBAREWORDが開いているfilehandle / dirhandleであると仮定すると）、これはchdirへの有効な呼び出しです。ただし、autodieでは、 &lt;code&gt;chdir&lt;/code&gt; はプロトタイプ &quot;; $&quot;のように動作するため、BAREWORDは構文エラーになります（ &quot;use strict&quot;では。strictがないと、ファイル名として解釈されます）。</target>
        </trans-unit>
        <trans-unit id="157dc325ab3004964dba8cb99f25c548e59c3ee6" translate="yes" xml:space="preserve">
          <source>Without binmode this happens to work but without binmode, print() fails instead of write().</source>
          <target state="translated">binmodeを使用しない場合、これは動作しますが、binmodeを使用しない場合、write()ではなくprint()が失敗します。</target>
        </trans-unit>
        <trans-unit id="9fae572f92ad00688736431e8db34f7e13e97183" translate="yes" xml:space="preserve">
          <source>Without compiling a special Perl, there is no way to get the exact same behavior of any versions prior to Perl 5.18.0. The closest one can get is by setting PERL_PERTURB_KEYS to 0 and setting the PERL_HASH_SEED to a known value. We do not advise those settings for production use due to the above security considerations.</source>
          <target state="translated">特別なPerlをコンパイルしなければ、Perl 5.18.0以前のバージョンと全く同じ動作を得る方法はありません。最も近いのは、PERL_PERTURB_KEYSを0に設定し、PERL_HASH_SEEDを既知の値に設定することです。上記のセキュリティ上の配慮から、本番環境での使用はお勧めしません。</target>
        </trans-unit>
        <trans-unit id="40d89b93ede452cf3a3abe5db73cc3f6990cb465" translate="yes" xml:space="preserve">
          <source>Without sending mail to the address and seeing whether there's a human on the other end to answer you, you cannot fully answer part</source>
          <target state="translated">アドレスにメールを送って、相手に返事をしてくれる人間がいるかどうかを見ないと、一部を完全に答えることはできません。</target>
        </trans-unit>
        <trans-unit id="9dc761ae6cda1ca106ca429a9b91481691a414c5" translate="yes" xml:space="preserve">
          <source>Without tests provided by the original author, how can anyone else changing perl in the future be sure that they haven't unwittingly broken the behaviour the patch implements? And without tests, how can the patch's author be confident that his/her hard work put into the patch won't be accidentally thrown away by someone in the future?</source>
          <target state="translated">オリジナルの作者が提供したテストがなければ、将来Perlを変更する人が、そのパッチが実装している動作を知らず知らずのうちに壊していないことをどうやって確信できるでしょうか? また、テストがなければ、パッチの作者は、将来誰かに誤って捨てられてしまうことのないように、パッチに費やした苦労をどうやって自信を持つことができるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="c1443d621edad5afbf828f718460ec1c38b6ccbc" translate="yes" xml:space="preserve">
          <source>Without that empty line before the &quot;=head1&quot;, many translators wouldn't have recognized the &quot;=head1&quot; as starting a Pod block.</source>
          <target state="translated">head1」の前の空行がなければ、多くの翻訳者は「=head1」をPodブロックの始まりとして認識しなかったでしょう。</target>
        </trans-unit>
        <trans-unit id="d67d28a004691a2df73ec622342b344f42349502" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $AUTOLOAD&lt;/code&gt; declaration, this code will not compile under the &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; pragma.</source>
          <target state="translated">なければ &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt; $AUTOLOAD&lt;/code&gt; 宣言、このコードは下コンパイルされません&lt;a href=&quot;strict&quot;&gt;厳格な&lt;/a&gt;プラグマ。</target>
        </trans-unit>
        <trans-unit id="e556997c8bdf4cc597d6477622db2033d0112438" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;our $AUTOLOAD&lt;/code&gt; declaration, this code will not compile under the &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; pragma.</source>
          <target state="translated">なければ &lt;code&gt;our $AUTOLOAD&lt;/code&gt; 宣言、このコードは下コンパイルされません&lt;a href=&quot;strict&quot;&gt;厳格な&lt;/a&gt;プラグマ。</target>
        </trans-unit>
        <trans-unit id="8106389e31f882e4de34e6fb1c8fa83f4529f426" translate="yes" xml:space="preserve">
          <source>Without the \ before the #, we'd have the start of a Makefile comment, and the macro would be incorrectly defined.</source>
          <target state="translated">の前に「#」がないと、Makefileのコメントが始まってしまい、マクロが正しく定義されません。</target>
        </trans-unit>
        <trans-unit id="9862e56ba4382f4550c0a053a28a9edc67cb29a8" translate="yes" xml:space="preserve">
          <source>Without the \\ before the #, we'd have the start of a Makefile comment, and the macro would be incorrectly defined.</source>
          <target state="translated">の前に「\」がないと、Makefileのコメントが始まってしまい、マクロの定義がおかしくなってしまいます。</target>
        </trans-unit>
        <trans-unit id="c652adb6df9438fc28974e5263002f95713055c4" translate="yes" xml:space="preserve">
          <source>Without the all-critical &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; declaration, putting UTF‑8 in your literals and identifiers won&amp;rsquo;t work right. If you used the standard preamble just given above, this already happened. If you did, you can do things like this:</source>
          <target state="translated">all-critical &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; 宣言がないと、UTF and8をリテラルと識別子に入れても正しく機能しません。上記の標準プリアンブルを使用した場合、これはすでに起こりました。もしそうなら、あなたはこのようなことをすることができます：</target>
        </trans-unit>
        <trans-unit id="022916bda3b0da7053428b82057c474802fe172c" translate="yes" xml:space="preserve">
          <source>Without the all-critical &lt;code&gt;use utf8&lt;/code&gt; declaration, putting UTF‑8 in your literals and identifiers won&amp;rsquo;t work right. If you used the standard preamble just given above, this already happened. If you did, you can do things like this:</source>
          <target state="translated">&lt;code&gt;use utf8&lt;/code&gt; 宣言をすべて重要に使用しないと、リテラルと識別子にUTF‑8を挿入しても正しく機能しません。上記の標準の前文を使用した場合、これはすでに発生しています。行った場合は、次のようなことができます。</target>
        </trans-unit>
        <trans-unit id="a805f73e432af03c931e3e4ebc6e43febdbb1b0f" translate="yes" xml:space="preserve">
          <source>Without the braces, Perl would have looked for a $whospeak, a &lt;code&gt;$who::0&lt;/code&gt; , and a &lt;code&gt;$who's&lt;/code&gt; variable. The last two would be the $0 and the $s variables in the (presumably) non-existent package &lt;code&gt;who&lt;/code&gt; .</source>
          <target state="translated">中括弧がなければ、Perlは$ whospeak、 &lt;code&gt;$who::0&lt;/code&gt; 、および &lt;code&gt;$who's&lt;/code&gt; 変数を探していました。最後の2つは、（おそらく）存在しないパッケージ &lt;code&gt;who&lt;/code&gt; の$ 0変数と$ s変数です。</target>
        </trans-unit>
        <trans-unit id="b59ba0c86d5008d327ba4145261903f48586e59b" translate="yes" xml:space="preserve">
          <source>Without the braces, Perl would have looked for a $whospeak, a &lt;code&gt;$who::0&lt;/code&gt;, and a &lt;code&gt;$who's&lt;/code&gt; variable. The last two would be the $0 and the $s variables in the (presumably) non-existent package &lt;code&gt;who&lt;/code&gt;.</source>
          <target state="translated">中括弧がなければ、Perlは$ whospeak、 &lt;code&gt;$who::0&lt;/code&gt; 、および &lt;code&gt;$who's&lt;/code&gt; 変数を探していたでしょう。最後の2つは、（おそらく）存在しないパッケージの$ 0変数と$ s変数 &lt;code&gt;who&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b7119185642381b4835e616a2adfce6407060de" translate="yes" xml:space="preserve">
          <source>Without the file handle there is no straightforward way to map from the C callback to the Perl subroutine.</source>
          <target state="translated">ファイルハンドルがないと、CのコールバックからPerlのサブルーチンにマッピングする簡単な方法がありません。</target>
        </trans-unit>
        <trans-unit id="557fc723a913d1e3b2505b4094298be8eec2001a" translate="yes" xml:space="preserve">
          <source>Without the quotes Perl would convert the large number to a floating point constant at compile time and then hand the result to BigInt, which results in an truncated result or a NaN.</source>
          <target state="translated">引用符がない場合、Perlはコンパイル時に大きな数値を浮動小数点定数に変換し、その結果をBigIntに渡します。</target>
        </trans-unit>
        <trans-unit id="cd8dcbc5d0ba46dab27a245d8542910769851151" translate="yes" xml:space="preserve">
          <source>Without the quotes Perl would convert the large number to a floating point constant at compile time and then hand the result to Math::BigInt, which results in an truncated result or a NaN.</source>
          <target state="translated">引用符がない場合、Perl はコンパイル時に大きな数値を浮動小数点定数に変換し、その結果を Math::BigInt に渡します。</target>
        </trans-unit>
        <trans-unit id="44d0e0ada47acb90500aed8583377dc7e9485f05" translate="yes" xml:space="preserve">
          <source>Without this function call, threads that use the &lt;a href=&quot;setlocale(3)&quot;&gt;&lt;code&gt;setlocale(3)&lt;/code&gt;&lt;/a&gt; system function will not work properly, as all the locale-sensitive functions will look at the per-thread locale, and &lt;code&gt;setlocale&lt;/code&gt; will have no effect on this thread.</source>
          <target state="translated">この関数呼び出しがないと、&lt;a href=&quot;setlocale(3)&quot;&gt; &lt;code&gt;setlocale(3)&lt;/code&gt; &lt;/a&gt;システム関数を使用するスレッドは正しく機能しません。これは、ロケールに依存するすべての関数がスレッドごとのロケールを調べ、 &lt;code&gt;setlocale&lt;/code&gt; がこのスレッドに影響を与えないためです。</target>
        </trans-unit>
        <trans-unit id="ebd1a191c5e0195ae68815f767eadf66793aed3f" translate="yes" xml:space="preserve">
          <source>Without this pragma, if strings operating under byte semantics and strings with Unicode character data are concatenated, the new string will be created by decoding the byte strings as</source>
          <target state="translated">このプラグマがない場合、バイトセマンティクスで動作する文字列と Unicode 文字データを持つ文字列が連結されている場合、バイト文字列を</target>
        </trans-unit>
        <trans-unit id="4e3240128cc4ac6294817aa01c1437d4416b9150" translate="yes" xml:space="preserve">
          <source>Word characters</source>
          <target state="translated">単語の文字</target>
        </trans-unit>
        <trans-unit id="c1ab804bf377c2d02f25ebababbe5112fca26b12" translate="yes" xml:space="preserve">
          <source>Work Crew</source>
          <target state="translated">作業員</target>
        </trans-unit>
        <trans-unit id="73f4875bffaeefb6bc4c9e5de5982f1c956b5814" translate="yes" xml:space="preserve">
          <source>Work around DCL's 255 character limit several times,and use VMS-style command line quoting in a few cases.</source>
          <target state="translated">DCLの255文字制限を何度か回避し、VMSスタイルのコマンドラインの引用符を使用することもあります。</target>
        </trans-unit>
        <trans-unit id="beb03a8c30af39505328c268c1180c75604701a0" translate="yes" xml:space="preserve">
          <source>Work for the pumpking, work for Perl programmers, work for module authors, ... Perl is supposed to be easy.</source>
          <target state="translated">パンプキンの仕事、Perlプログラマの仕事、モジュール作成者の仕事、...Perlは簡単なはずです。</target>
        </trans-unit>
        <trans-unit id="91f920f3d44c34d2ff6c9dd9603498397730bf04" translate="yes" xml:space="preserve">
          <source>Worked by applying a role that wrapped &lt;code&gt;Test::Builder-&amp;gt;_print_comment&lt;/code&gt;. Fixed by adding an event filter that modifies the message instead when running under Test2.</source>
          <target state="translated">&lt;code&gt;Test::Builder-&amp;gt;_print_comment&lt;/code&gt; をラップしたロールを適用することで機能しました。Test2で実行しているときに、代わりにメッセージを変更するイベントフィルターを追加することで修正されました。</target>
        </trans-unit>
        <trans-unit id="b837e4f0aacd9d9f6074d443ecd309cef87e661e" translate="yes" xml:space="preserve">
          <source>Working code is always preferred to pie-in-the-sky ideas. A patch to add a feature stands a much higher chance of making it to the language than does a random feature request, no matter how fervently argued the request might be. This ties into &quot;Will it be useful?&quot;, as the fact that someone took the time to make the patch demonstrates a strong desire for the feature.</source>
          <target state="translated">机上の空論のアイデアよりも、実際のコードの方が常に優先されます。機能を追加するためのパッチは、どんなに熱心に主張された要求であっても、無作為な機能要求よりも、言語に反映される可能性がはるかに高いのです。これは、誰かが時間をかけてパッチを作ったという事実が、その機能に対する強い欲求を示しているということであり、「役に立つかどうか」と関係しています。</target>
        </trans-unit>
        <trans-unit id="791f0cf1a4866efe09fa052199378fd87a29a636" translate="yes" xml:space="preserve">
          <source>Working with AVs</source>
          <target state="translated">AVとの連携</target>
        </trans-unit>
        <trans-unit id="fcf77865e202a40f39e6dc4633dec2c1c8b8542a" translate="yes" xml:space="preserve">
          <source>Working with HVs</source>
          <target state="translated">HVとの連携</target>
        </trans-unit>
        <trans-unit id="9ba6b91bf263dc667dda1becd81a9fbef7358bbd" translate="yes" xml:space="preserve">
          <source>Working with Net::FTP</source>
          <target state="translated">Net::FTP での作業</target>
        </trans-unit>
        <trans-unit id="9522f5ef01714aab2e2d70111bf52346aa9851c3" translate="yes" xml:space="preserve">
          <source>Working with SVs</source>
          <target state="translated">SVとの連携</target>
        </trans-unit>
        <trans-unit id="acaa1f9e891f841e4f55280185da1c9a0bc87b80" translate="yes" xml:space="preserve">
          <source>Working with files</source>
          <target state="translated">ファイルの操作</target>
        </trans-unit>
        <trans-unit id="7efe528e837c3e9dd842174c934d74e9c8e8af64" translate="yes" xml:space="preserve">
          <source>Works currently only for integers.</source>
          <target state="translated">現在は整数でのみ動作します。</target>
        </trans-unit>
        <trans-unit id="c9cb7c59dae1a78441bca64b16b41d57dc70c3e5" translate="yes" xml:space="preserve">
          <source>Works exactly as &lt;code&gt;like()&lt;/code&gt; , only it checks if $got &lt;b&gt;does not&lt;/b&gt; match the given pattern.</source>
          <target state="translated">&lt;code&gt;like()&lt;/code&gt; とまったく同じように&lt;b&gt;機能し&lt;/b&gt;、$ got &lt;b&gt;が&lt;/b&gt;指定されたパターンに一致&lt;b&gt;しない&lt;/b&gt;かどうかを確認するだけです。</target>
        </trans-unit>
        <trans-unit id="6ffef90261775bf1446d64de441c14b751512d3c" translate="yes" xml:space="preserve">
          <source>Works exactly as &lt;code&gt;like()&lt;/code&gt;, only it checks if $got &lt;b&gt;does not&lt;/b&gt; match the given pattern.</source>
          <target state="translated">&lt;code&gt;like()&lt;/code&gt; とまったく同じように機能しますが、$ got&lt;b&gt;が&lt;/b&gt;指定されたパターンと一致&lt;b&gt;しない&lt;/b&gt;かどうかをチェックするだけです。</target>
        </trans-unit>
        <trans-unit id="54f0dce4381260fc309ade54b455e20a83cc12f0" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;#index-STR%2CSUBSTR%2CPOSITION&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; except that it returns the position of the</source>
          <target state="translated">&lt;a href=&quot;#index-STR%2CSUBSTR%2CPOSITION&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt;の位置を返すことを除いて、インデックスと同じように機能します</target>
        </trans-unit>
        <trans-unit id="9232c0576386ef7db9a66e0f3312f80aa2ae0362" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;#localtime&quot;&gt;localtime&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">&lt;a href=&quot;#localtime&quot;&gt;localtimeと&lt;/a&gt;同じように機能しますが、戻り値は標準のグリニッジタイムゾーンにローカライズされます。</target>
        </trans-unit>
        <trans-unit id="9839a604fd52293ec52fedd95d5b5d8df3818c2c" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;#localtime-EXPR&quot;&gt;&lt;code&gt;localtime&lt;/code&gt;&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">ちょうど同じように動作し&lt;a href=&quot;#localtime-EXPR&quot;&gt; &lt;code&gt;localtime&lt;/code&gt; の&lt;/a&gt;が、返された値は、標準グリニッジタイムゾーンにローカライズされています。</target>
        </trans-unit>
        <trans-unit id="69a4f2f77bbe0fae40d114143aa5065b6ddabd02" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;cmp_ok()&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;Test::More&quot;&gt;Test :: More&lt;/a&gt;の &lt;code&gt;cmp_ok()&lt;/code&gt; と同じように機能します。</target>
        </trans-unit>
        <trans-unit id="63d895f5ba3197e6e250fa353d94a31dc5531f0f" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt; but the returned values are localized for the standard Greenwich time zone.</source>
          <target state="translated">&lt;a href=&quot;localtime&quot;&gt;localtimeと&lt;/a&gt;同じように機能しますが、戻り値は標準のグリニッジタイムゾーンにローカライズされます。</target>
        </trans-unit>
        <trans-unit id="59edd54160d7f94a92175d3ce89e67babbe534fb" translate="yes" xml:space="preserve">
          <source>Works just like &lt;a href=&quot;more&quot;&gt;Test::More&lt;/a&gt;'s &lt;code&gt;cmp_ok()&lt;/code&gt; .</source>
          <target state="translated">&lt;a href=&quot;more&quot;&gt;Test :: More&lt;/a&gt;の &lt;code&gt;cmp_ok()&lt;/code&gt; と同じように機能します。</target>
        </trans-unit>
        <trans-unit id="b054b39e72ec238653744e3a117cbf2b7bacaa18" translate="yes" xml:space="preserve">
          <source>Works just like index() except that it returns the position of the</source>
          <target state="translated">の位置を返すことを除いては index()と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="ff14a89d24955b4d292116a9dd09815095b69cb7" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_catpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;&lt;a href=&quot;#sv_setpvf_mg&quot;&gt;&quot;sv_setpvf_mg&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sv_catpvf&lt;/code&gt; と同様に機能しますが、テキストを追加する代わりにSVにコピーします。'set'マジックを処理しません。 &lt;code&gt;&lt;a href=&quot;#sv_setpvf_mg&quot;&gt;&quot;sv_setpvf_mg&quot;&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="62b7e0373549dae581f58b37784d19f9d489170e" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_catpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;sv_setpvf_mg&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;sv_catpvf&lt;/code&gt; のように機能しますが、テキストを追加するのではなく、SVにコピーします。「セット」マジックを処理しません。 &lt;code&gt;sv_setpvf_mg&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="c14d76b99d10ba25b831daac8203cd025304f5fc" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;&lt;a href=&quot;#sv_vsetpvf_mg&quot;&gt;&quot;sv_vsetpvf_mg&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sv_vcatpvf&lt;/code&gt; と同様に機能しますが、テキストを追加する代わりにSVにコピーします。 'set'マジックを処理しません。 &lt;code&gt;&lt;a href=&quot;#sv_vsetpvf_mg&quot;&gt;&quot;sv_vsetpvf_mg&quot;&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="43ccfff897978a36d025fbdd87f7f80f29da36e5" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvf&lt;/code&gt; but copies the text into the SV instead of appending it. Does not handle 'set' magic. See &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;sv_vcatpvf&lt;/code&gt; のように機能しますが、テキストを追加するのではなく、SVにコピーします。「セット」マジックを処理しません。 &lt;code&gt;sv_vsetpvf_mg&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="ce9ad1c2559537d328f2e9ae5ccf06d2341106d3" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;sv_vcatpvfn&lt;/code&gt; but copies the text into the SV instead of appending it.</source>
          <target state="translated">&lt;code&gt;sv_vcatpvfn&lt;/code&gt; のように機能しますが、テキストを追加するのではなく、SVにコピーします。</target>
        </trans-unit>
        <trans-unit id="97569be8c378569cf569a2abd589e6182aac8aca" translate="yes" xml:space="preserve">
          <source>Works remotely similar to &lt;code&gt;filter_json_object&lt;/code&gt;, but is only called for JSON objects having a single key named &lt;code&gt;$key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filter_json_object&lt;/code&gt; とリモートで同様に機能しますが、 &lt;code&gt;$key&lt;/code&gt; という名前の単一のキーを持つJSONオブジェクトに対してのみ呼び出されます。</target>
        </trans-unit>
        <trans-unit id="e28088b9057a774cbeb7647c942ba983be39b65a" translate="yes" xml:space="preserve">
          <source>Workshops</source>
          <target state="translated">Workshops</target>
        </trans-unit>
        <trans-unit id="aca31ad78f24eb8f34a6f1515e5ad96783f7a4c5" translate="yes" xml:space="preserve">
          <source>World Wide Web, HTML, HTTP, CGI, MIME</source>
          <target state="translated">ワールドワイドウェブ、HTML、HTTP、CGI、MIME</target>
        </trans-unit>
        <trans-unit id="dc354627de17c28e4a463874cb49fb69cf80c2d0" translate="yes" xml:space="preserve">
          <source>Worse still, if you've got a language like Chinese or Japanese that has hundreds or thousands of characters, then you really can't fit them into a mere 256, so they had to forget about ASCII altogether, and build their own systems using pairs of numbers to refer to one character.</source>
          <target state="translated">さらに悪いことに、中国語や日本語のように何百、何千もの文字がある言語では、たった256文字では収まりきらないので、ASCIIを完全に忘れて、1つの文字を参照するための数字のペアを使って独自のシステムを構築しなければなりませんでした。</target>
        </trans-unit>
        <trans-unit id="c5bfba3d49e2ee674235e330da88197da31a7c79" translate="yes" xml:space="preserve">
          <source>Would print '1', because &lt;code&gt;$foo&lt;/code&gt; holds a reference to the</source>
          <target state="translated">&lt;code&gt;$foo&lt;/code&gt; はへの参照を保持しているため、「1」を出力します</target>
        </trans-unit>
        <trans-unit id="193007f64c59b1fb13236d0c41a89912a80da741" translate="yes" xml:space="preserve">
          <source>Would produce an event structure that does &lt;b&gt;not&lt;/b&gt; have the</source>
          <target state="translated">ないイベント構造生じるであろう&lt;b&gt;ではない&lt;/b&gt;持っているが</target>
        </trans-unit>
        <trans-unit id="cb47f1ed4bc872fb3335bdefcb281f4424715abe" translate="yes" xml:space="preserve">
          <source>Would run bin/foobar.PL like this:</source>
          <target state="translated">bin/foobar.PLをこのように実行します。</target>
        </trans-unit>
        <trans-unit id="ead2351e2ba0bd4c816a4c94cc5152ad666ddb3d" translate="yes" xml:space="preserve">
          <source>Wrapper around CPAN.pm without using any XS module</source>
          <target state="translated">XS モジュールを使わない CPAN.pm のラッパー</target>
        </trans-unit>
        <trans-unit id="84ac379977c898d123ab3b5be8e7d1ebcc793262" translate="yes" xml:space="preserve">
          <source>Wrapper around Config.pm</source>
          <target state="translated">Config.pm のラッパー</target>
        </trans-unit>
        <trans-unit id="5e2ec9565586c686048d53d457fe37527f6aad30" translate="yes" xml:space="preserve">
          <source>Wrapper class for calling subs at end of scope</source>
          <target state="translated">スコープの終了時にサブを呼び出すためのラッパークラス</target>
        </trans-unit>
        <trans-unit id="49754b3431fd16ae1cf0d382c55b7fa7149dd942" translate="yes" xml:space="preserve">
          <source>Wrapping all die calls in a handler routine can be useful to see how, and from where, they're being called, &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; has more information:</source>
          <target state="translated">ハンドラールーチンですべてのdie呼び出しをラップすると、どのように、そしてどこから呼び出されているかを確認するのに役立ちます&lt;a href=&quot;perlvar&quot;&gt;。perlvarに&lt;/a&gt;は詳細情報があります。</target>
        </trans-unit>
        <trans-unit id="c2c61b8accf065e529ff818a1a9f4549b7fc54ab" translate="yes" xml:space="preserve">
          <source>Wrapping with parenthesis allows the wildcard parts of the Input File Glob to be referenced by the second parameter to &lt;code&gt;globmap&lt;/code&gt; , &lt;code&gt;#1.tgz&lt;/code&gt; , the</source>
          <target state="translated">括弧で &lt;code&gt;globmap&lt;/code&gt; と、入力ファイルグロブのワイルドカード部分を、2番目のパラメーターglobmap、 &lt;code&gt;#1.tgz&lt;/code&gt; 、</target>
        </trans-unit>
        <trans-unit id="17f822b6bdf6bec5271484d235680d74774f32cb" translate="yes" xml:space="preserve">
          <source>Wrapping with parenthesis allows the wildcard parts of the Input File Glob to be referenced by the second parameter to &lt;code&gt;globmap&lt;/code&gt;, &lt;code&gt;#1.tgz&lt;/code&gt;, the</source>
          <target state="translated">括弧付きラッピングは、入力ファイルグロブのワイルドカードの部分は2番目のパラメータによって参照することができます &lt;code&gt;globmap&lt;/code&gt; 、 &lt;code&gt;#1.tgz&lt;/code&gt; 、</target>
        </trans-unit>
        <trans-unit id="53f5b426a0effa25adf0da16850506b6dbd0cdcc" translate="yes" xml:space="preserve">
          <source>Wraps any CODE references found within the arguments by replacing each with the result of calling &lt;a href=&quot;#wrap_code_ref&quot;&gt;&quot;wrap_code_ref&quot;&lt;/a&gt; on the CODE reference. Any ARRAY or HASH references in the arguments are inspected recursively.</source>
          <target state="translated">引数内で見つかったCODE参照を、CODE参照で&lt;a href=&quot;#wrap_code_ref&quot;&gt;「wrap_code_ref」&lt;/a&gt;を呼び出した結果に置き換えることでラップします。引数内のARRAYまたはHASH参照は、再帰的に検査されます。</target>
        </trans-unit>
        <trans-unit id="7ee0be976deb11b8b1d2de7c10091a2cf26d9d3d" translate="yes" xml:space="preserve">
          <source>Wraps any CODE references found within the arguments by replacing each with the result of calling &lt;a href=&quot;#wrap_code_ref&quot;&gt;wrap_code_ref&lt;/a&gt; on the CODE reference. Any ARRAY or HASH references in the arguments are inspected recursively.</source>
          <target state="translated">CODE参照で&lt;a href=&quot;#wrap_code_ref&quot;&gt;wrap_code_ref&lt;/a&gt;を呼び出した結果でそれぞれを置き換えることにより、引数内で見つかったすべてのCODE参照をラップします。引数内のARRAYまたはHASH参照は再帰的に検査されます。</target>
        </trans-unit>
        <trans-unit id="c3415b34e4326194b5c5e94f65779568f9ab9142" translate="yes" xml:space="preserve">
          <source>Wraps up an op tree with some additional ops so that at runtime a dynamic scope will be created. The original ops run in the new dynamic scope, and then, provided that they exit normally, the scope will be unwound. The additional ops used to create and unwind the dynamic scope will normally be an &lt;code&gt;enter&lt;/code&gt; /&lt;code&gt;leave&lt;/code&gt; pair, but a &lt;code&gt;scope&lt;/code&gt; op may be used instead if the ops are simple enough to not need the full dynamic scope structure.</source>
          <target state="translated">実行時に動的スコープが作成されるように、いくつかの追加のopsでopツリーをラップします。元の操作は新しい動的スコープで実行され、正常に終了すると、スコープが展開されます。動的スコープの作成と巻き戻しに使用される追加のopsは通常、 &lt;code&gt;enter&lt;/code&gt; / &lt;code&gt;leave&lt;/code&gt; ペアですが、完全な動的スコープ構造を必要としないほど単純な場合は、代わりに &lt;code&gt;scope&lt;/code&gt; opを使用できます。</target>
        </trans-unit>
        <trans-unit id="2c03a1841c6b03c290cd48f7ec63334ea2671fbe" translate="yes" xml:space="preserve">
          <source>Wraps up an op tree with some additional ops so that at runtime a dynamic scope will be created. The original ops run in the new dynamic scope, and then, provided that they exit normally, the scope will be unwound. The additional ops used to create and unwind the dynamic scope will normally be an &lt;code&gt;enter&lt;/code&gt;/&lt;code&gt;leave&lt;/code&gt; pair, but a &lt;code&gt;scope&lt;/code&gt; op may be used instead if the ops are simple enough to not need the full dynamic scope structure.</source>
          <target state="translated">実行時に動的スコープが作成されるように、いくつかの追加の操作で操作ツリーをラップします。元のopsは新しい動的スコープで実行され、正常に終了すると、スコープが巻き戻されます。追加のOPSは普通になり、動的スコープを作成してくつろぐために使用される &lt;code&gt;enter&lt;/code&gt; / &lt;code&gt;leave&lt;/code&gt; ペアが、 &lt;code&gt;scope&lt;/code&gt; OPSはフルダイナミックスコープの構造を必要としないためのシンプルな十分であればopは代わりに使用することができます。</target>
        </trans-unit>
        <trans-unit id="4a48932789d199bbed709777e2d743ca2bafdc6c" translate="yes" xml:space="preserve">
          <source>Write</source>
          <target state="translated">Write</target>
        </trans-unit>
        <trans-unit id="665e91485da7b1f4da854eb4a64d72b175917c29" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes of data from &lt;code&gt;BUFFER&lt;/code&gt; to the server, also performing any &amp;lt;CRLF&amp;gt; translation necessary. &lt;code&gt;TIMEOUT&lt;/code&gt; is optional, if not given, the timeout value from the command connection will be used.</source>
          <target state="translated">&lt;code&gt;BUFFER&lt;/code&gt; からサーバーに &lt;code&gt;SIZE&lt;/code&gt; バイトのデータを書き込み、必要な&amp;lt;CRLF&amp;gt;変換も実行します。 &lt;code&gt;TIMEOUT&lt;/code&gt; はオプションです。指定しない場合、コマンド接続からのタイムアウト値が使用されます。</target>
        </trans-unit>
        <trans-unit id="9e9970521c52eb1a81f415505a29f59eba7d4c0c" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes to the shared memory segment at &lt;code&gt;POS&lt;/code&gt; . Returns true if successful, or false if there is an error. See &lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwrite&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;SIZE&lt;/code&gt; バイトを &lt;code&gt;POS&lt;/code&gt; の共有メモリセグメントに書き込みます。成功した場合はtrue、エラーが発生した場合はfalseを返します。&lt;a href=&quot;../functions/shmwrite&quot;&gt;shmwriteを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e52c0034fc1cfc407469f1ff131f1cb98c7f427d" translate="yes" xml:space="preserve">
          <source>Write &lt;code&gt;SIZE&lt;/code&gt; bytes to the shared memory segment at &lt;code&gt;POS&lt;/code&gt;. Returns true if successful, or false if there is an error. See &lt;a href=&quot;shmwrite&quot;&gt;shmwrite&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;POS&lt;/code&gt; の共有メモリセグメントに &lt;code&gt;SIZE&lt;/code&gt; バイトを書き込みます。成功した場合はtrueを返し、エラーが発生した場合はfalseを返します。&lt;a href=&quot;shmwrite&quot;&gt;shmwriteを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c4d6106f35288022310ffee038cda3aae849b282" translate="yes" xml:space="preserve">
          <source>Write MYMETA information to MYMETA.json and MYMETA.yml.</source>
          <target state="translated">MYMETA.jsonとMYMETA.ymlにMYMETA情報を書き込む。</target>
        </trans-unit>
        <trans-unit id="a9b6c91570493bdee3be6eef5a6b183ad756cdab" translate="yes" xml:space="preserve">
          <source>Write RFC 1950 files/buffers</source>
          <target state="translated">RFC 1950 のファイル/バッファを書き込む</target>
        </trans-unit>
        <trans-unit id="0909abf68380a212e21e5479f6396ce54f63b785" translate="yes" xml:space="preserve">
          <source>Write RFC 1951 files/buffers</source>
          <target state="translated">RFC 1951 のファイル/バッファを書き込む</target>
        </trans-unit>
        <trans-unit id="0a1ef998109ed3777e0f667818ad2c1c3ea0b70e" translate="yes" xml:space="preserve">
          <source>Write RFC 1952 files/buffers</source>
          <target state="translated">RFC 1952 のファイル/バッファを書き込む</target>
        </trans-unit>
        <trans-unit id="e52a7d8ae8bb89850d8b0bad0931a61da15a6992" translate="yes" xml:space="preserve">
          <source>Write YAMLish data</source>
          <target state="translated">YAMLishデータの書き込み</target>
        </trans-unit>
        <trans-unit id="77878a047db48550e0d5361bfb44d185b930e978" translate="yes" xml:space="preserve">
          <source>Write a formatter as a Pod::Simple subclass</source>
          <target state="translated">Pod::Simpleのサブクラスとしてフォーマッタを書く</target>
        </trans-unit>
        <trans-unit id="bc54db5c1b3d5ac212fb800fdd56f965140da3e5" translate="yes" xml:space="preserve">
          <source>Write access via git</source>
          <target state="translated">git による書き込みアクセス</target>
        </trans-unit>
        <trans-unit id="935636e37a0f4339394c64f63b5cea6433c1f963" translate="yes" xml:space="preserve">
          <source>Write an entry, whose name is equivalent to the file name provided to disk. Optionally takes a second parameter, which is the full native path (including filename) the entry will be written to.</source>
          <target state="translated">ディスクに与えられたファイル名と同じ名前のエントリを書き込みます。オプションで、2 番目のパラメータとして、エントリの書き込まれるネイティブパス (ファイル名を含む)を指定します。</target>
        </trans-unit>
        <trans-unit id="21bcad44913246d2e6442e5351456a0465facb2b" translate="yes" xml:space="preserve">
          <source>Write an event to the console.</source>
          <target state="translated">コンソールにイベントを書き込みます。</target>
        </trans-unit>
        <trans-unit id="92e129f1755e34449f3a6e6df186f50990274c50" translate="yes" xml:space="preserve">
          <source>Write behind.</source>
          <target state="translated">後ろに書く。</target>
        </trans-unit>
        <trans-unit id="e9db66c000d241fa8edccdd62e10c6678d855f50" translate="yes" xml:space="preserve">
          <source>Write bytes to a file or file-like device. Returns a true value if the operation was successful. For failure, returns a false value and sets &lt;code&gt;fileLastError()&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt; for the reason for the failure.</source>
          <target state="translated">ファイルまたはファイルのようなデバイスにバイトを書き込みます。操作が成功した場合はtrue値を返します。失敗の場合、false値を返し、失敗の理由として &lt;code&gt;fileLastError()&lt;/code&gt; と &lt;code&gt;$^E&lt;/code&gt; を設定します。</target>
        </trans-unit>
        <trans-unit id="5769fe16b9b0cad42af9406c72e837bd0c18c816" translate="yes" xml:space="preserve">
          <source>Write bzip2 files/buffers</source>
          <target state="translated">bzip2 ファイル/バッファの書き込み</target>
        </trans-unit>
        <trans-unit id="33c705dea45d707aeb4260372b955bd490cdccc3" translate="yes" xml:space="preserve">
          <source>Write check compare operation.</source>
          <target state="translated">チェックコンペア動作を書き込みます。</target>
        </trans-unit>
        <trans-unit id="bafb7482744edca206da4c0baa12b4a11269c914" translate="yes" xml:space="preserve">
          <source>Write documentation in POD</source>
          <target state="translated">PODでドキュメントを書く</target>
        </trans-unit>
        <trans-unit id="01995de03181a3f8adb7e727e73e6dc5e4e106c7" translate="yes" xml:space="preserve">
          <source>Write files whose names are equivalent to any of the names in &lt;code&gt;@filenames&lt;/code&gt; to disk, creating subdirectories as necessary. This might not work too well under VMS. Under MacPerl, the file's modification time will be converted to the MacOS zero of time, and appropriate conversions will be done to the path. However, the length of each element of the path is not inspected to see whether it's longer than MacOS currently allows (32 characters).</source>
          <target state="translated">必要に応じて、 &lt;code&gt;@filenames&lt;/code&gt; いずれかの名前と同じ名前のファイルをディスクに書き込み、サブディレクトリを作成します。これはVMSではうまく機能しない可能性があります。MacPerlでは、ファイルの変更時刻はMacOSのゼロ時間に変換され、パスに対して適切な変換が行われます。ただし、パスの各要素の長さは、MacOSが現在許可している長さ（32文字）よりも長いかどうかを調べるために検査されません。</target>
        </trans-unit>
        <trans-unit id="cbcd4ec744f6a0cc7a8100b555d7a1173e6952f5" translate="yes" xml:space="preserve">
          <source>Write linker options files for dynamic extension</source>
          <target state="translated">動的拡張子用のリンカオプションファイルを書く</target>
        </trans-unit>
        <trans-unit id="a3530b843bc763ce23299f2f7a8c7169f29e11c4" translate="yes" xml:space="preserve">
          <source>Write simple routines to do simple things.</source>
          <target state="translated">簡単なことをするために簡単なルーチンを書きます。</target>
        </trans-unit>
        <trans-unit id="19494af103ef52570f65fb0c4441c4f5f25a19b7" translate="yes" xml:space="preserve">
          <source>Write some bytes to the scalar.</source>
          <target state="translated">スカラーに何バイトかを書き込む。</target>
        </trans-unit>
        <trans-unit id="391b1a9608423cb9c4d16a7886b9e07fab1acb00" translate="yes" xml:space="preserve">
          <source>Write tests</source>
          <target state="translated">テストを書く</target>
        </trans-unit>
        <trans-unit id="af9a89203723d4a9c54482e7a2f891829a872e2c" translate="yes" xml:space="preserve">
          <source>Write the</source>
          <target state="translated">を書いてください。</target>
        </trans-unit>
        <trans-unit id="f112fa7fb0b15b487e01a318607d918ca868eea9" translate="yes" xml:space="preserve">
          <source>Write the C code for miniperlmain.c and perlmain.c</source>
          <target state="translated">miniperlmain.c と perlmain.c の C コードを書きます。</target>
        </trans-unit>
        <trans-unit id="dc5fd755a4779cecce293a2a1e919899f32cdf21" translate="yes" xml:space="preserve">
          <source>Write the C code for perlmain.c</source>
          <target state="translated">perlmain.cのCコードを書く</target>
        </trans-unit>
        <trans-unit id="0a8eff4063a82696c6af1e9ea9cf555d97a3ea2c" translate="yes" xml:space="preserve">
          <source>Write the in-memory archive to disk. The first argument can either be the name of a file or a reference to an already open filehandle (a GLOB reference).</source>
          <target state="translated">インメモリ・アーカイブをディスクに書き込む。最初の引数には、ファイル名か、既に開いているファイルハンドルへの参照 (GLOB参照)のいずれかを指定します。</target>
        </trans-unit>
        <trans-unit id="af8f82dc202f24f05f3598bed445a87ed08771b7" translate="yes" xml:space="preserve">
          <source>Write the state to a file.</source>
          <target state="translated">状態をファイルに書き込む。</target>
        </trans-unit>
        <trans-unit id="03e89de5415aa73b6bf8d4ce2e95f915540a35da" translate="yes" xml:space="preserve">
          <source>Write the typemap to a file. Optionally takes a &lt;code&gt;file&lt;/code&gt; argument. If given, the typemap will be written to the specified file. If not, the typemap is written to the currently stored file name (see &lt;a href=&quot;#file&quot;&gt;&quot;file&quot;&lt;/a&gt; above, this defaults to the file it was read from if any).</source>
          <target state="translated">タイプマップをファイルに書き込みます。オプションで、 &lt;code&gt;file&lt;/code&gt; 引数を取ります。指定すると、タイプマップは指定されたファイルに書き込まれます。そうでない場合、タイプマップは現在保存されているファイル名に書き込まれます（上記の&lt;a href=&quot;#file&quot;&gt;「ファイル」を&lt;/a&gt;参照してください。デフォルトでは、読み取られたファイルが使用されます）。</target>
        </trans-unit>
        <trans-unit id="5ea3036e84ed65b742580afd08f2cf97f36ee5c9" translate="yes" xml:space="preserve">
          <source>Write to a file. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt; .</source>
          <target state="translated">ファイルに書き込みます。これは、 &lt;code&gt;POSIX::open&lt;/code&gt; 呼び出すことによって取得されるようなファイル記述子を使用します。</target>
        </trans-unit>
        <trans-unit id="1ddba3f84caaf1f7da5ab41258196ba4aa666d93" translate="yes" xml:space="preserve">
          <source>Write to a file. This uses file descriptors such as those obtained by calling &lt;code&gt;POSIX::open&lt;/code&gt;.</source>
          <target state="translated">ファイルに書き込みます。これは、 &lt;code&gt;POSIX::open&lt;/code&gt; 呼び出して取得したようなファイル記述子を使用します。</target>
        </trans-unit>
        <trans-unit id="fff8491fc63b40787a6bc354a1c28b21cd65c0f1" translate="yes" xml:space="preserve">
          <source>Write to modules@perl.org explaining what you did to contact the current maintainer. The PAUSE admins will also try to reach the maintainer.</source>
          <target state="translated">現在のメンテナと連絡を取るために何をしたかを modules@perl.org に書いてください。PAUSEの管理者もメンテナに連絡を取ろうとします。</target>
        </trans-unit>
        <trans-unit id="ec3b4c2700310731999e0d7e25df0c587f5a195d" translate="yes" xml:space="preserve">
          <source>Write zip files/buffers</source>
          <target state="translated">zipファイル/バッファの書き込み</target>
        </trans-unit>
        <trans-unit id="08d9173120127debf58115903083c7548d3871d3" translate="yes" xml:space="preserve">
          <source>Write-only access to the data in the file.</source>
          <target state="translated">ファイル内のデータへの書き込み専用アクセス。</target>
        </trans-unit>
        <trans-unit id="14518d4671890ab2fd2dc1aa9e641777a8f1afbc" translate="yes" xml:space="preserve">
          <source>WriteConstants ATTRIBUTE =&amp;gt; VALUE [, ...]</source>
          <target state="translated">WriteConstants ATTRIBUTE =&amp;gt; VALUE [, ...]</target>
        </trans-unit>
        <trans-unit id="94dee2fafe1d10d5ce6db659eb0c0fcb3d5842be" translate="yes" xml:space="preserve">
          <source>WriteFile</source>
          <target state="translated">WriteFile</target>
        </trans-unit>
        <trans-unit id="8a1db595bd4c07aab5da69c69b2b0b595010f3b7" translate="yes" xml:space="preserve">
          <source>WriteMakefile() now does some basic sanity checks on its parameters to protect against typos and malformatted values. This means some things which happened to work in the past will now throw warnings and possibly produce internal errors.</source>
          <target state="translated">WriteMakefile()は、タイプミスや不正フォーマットされた値から保護するために、 パラメータに対していくつかの基本的なサニティチェックを行うようになりました。これは、これまで動作していたものが警告を投げたり、内部エラーを発生させたりするようになったことを意味しています。</target>
        </trans-unit>
        <trans-unit id="97fe0c70bb91d9c9a985fa7a8dd506d2e586dde0" translate="yes" xml:space="preserve">
          <source>WriteMakefileSnippet</source>
          <target state="translated">WriteMakefileSnippet</target>
        </trans-unit>
        <trans-unit id="6e814e2d111b3599c2bf1ca192478a3ffbfc4053" translate="yes" xml:space="preserve">
          <source>WriteMakefileSnippet ATTRIBUTE =&amp;gt; VALUE [, ...]</source>
          <target state="translated">WriteMakefileSnippet ATTRIBUTE =&amp;gt; VALUE [、...]</target>
        </trans-unit>
        <trans-unit id="7bdbf771b888449a861406dd116d15dd91371055" translate="yes" xml:space="preserve">
          <source>Writes SIZE bytes from STRING to a memory segment at ADDR starting at position POS. If STRING is too long, only SIZE bytes are used; if STRING is too short, nulls are written to fill out SIZE bytes. Returns true if successful, or false if there is an error.</source>
          <target state="translated">STRINGからPOSから始まるADDRのメモリセグメントにSIZEバイトを書き込みます。STRINGが長すぎる場合はSIZEバイトのみが使用され、STRINGが短すぎる場合はSIZEバイトを埋めるためにnullsが書き込まれます。成功した場合はtrue、エラーの場合はfalseを返します。</target>
        </trans-unit>
        <trans-unit id="5d0ca93d68b5dc214818ef186a1bc3e2b3d7c8cd" translate="yes" xml:space="preserve">
          <source>Writes a file of C code and a file of XS code which you should &lt;code&gt;#include&lt;/code&gt; and &lt;code&gt;INCLUDE&lt;/code&gt; in the C and XS sections respectively of your module's XS code. You probably want to do this in your &lt;code&gt;Makefile.PL&lt;/code&gt; , so that you can easily edit the list of constants without touching the rest of your module. The attributes supported are</source>
          <target state="translated">モジュールのXSコードのCおよびXSセクシ​​ョンにそれぞれ &lt;code&gt;#include&lt;/code&gt; および &lt;code&gt;INCLUDE&lt;/code&gt; する必要があるCコードのファイルとXSコードのファイルを書き込みます。あなたはおそらくあなたにこれをやりたい &lt;code&gt;Makefile.PL&lt;/code&gt; 簡単にあなたのモジュールの残りの部分を触れることなく、定数のリストを編集することができますのでこと、。サポートされる属性は</target>
        </trans-unit>
        <trans-unit id="e0245702e3fa0201a8eb501ac9938357e48b7d01" translate="yes" xml:space="preserve">
          <source>Writes a file of C code and a file of XS code which you should &lt;code&gt;#include&lt;/code&gt; and &lt;code&gt;INCLUDE&lt;/code&gt; in the C and XS sections respectively of your module's XS code. You probably want to do this in your &lt;code&gt;Makefile.PL&lt;/code&gt;, so that you can easily edit the list of constants without touching the rest of your module. The attributes supported are</source>
          <target state="translated">モジュールのXSコードのCセクションとXSセクシ​​ョンにそれぞれ &lt;code&gt;#include&lt;/code&gt; および &lt;code&gt;INCLUDE&lt;/code&gt; する必要があるCコードのファイルとXSコードのファイルを書き込みます。モジュールの残りの部分に触れることなく定数のリストを簡単に編集できるように、 &lt;code&gt;Makefile.PL&lt;/code&gt; でこれを実行することをお勧めします。サポートされている属性は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e8e7628595fe05e976f01b228c1371b889b4fb1c" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;a href=&quot;#select-FILEHANDLE&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; function) may be set explicitly by assigning the name of the format to the &lt;a href=&quot;perlvar#%24~&quot;&gt;&lt;code&gt;$~&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">そのファイルに関連付けられたフォーマットを使用して、フォーマットされたレコード（場合によっては複数行）を指定されたFILEHANDLEに書き込みます。デフォルトでは、ファイルの形式はファイルハンドルと同じ名前の形式ですが、現在の出力チャネルの形式（&lt;a href=&quot;#select-FILEHANDLE&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt;関数を参照）は、形式の名前を&lt;a href=&quot;perlvar#%24~&quot;&gt; &lt;code&gt;$~&lt;/code&gt; &lt;/a&gt;変数に割り当てることで明示的に設定できます。</target>
        </trans-unit>
        <trans-unit id="68caf753088df284b27998c0bc22c79c995c9f8a" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function) may be set explicitly by assigning the name of the format to the &lt;code&gt;$~&lt;/code&gt; variable.</source>
          <target state="translated">指定されたFILEHANDLEに、そのファイルに関連付けられたフォーマットを使用して、フォーマットされたレコード（おそらく複数行）を書き込みます。デフォルトでは、ファイルの形式はファイルハンドルと同じ名前の形式ですが、現在の出力チャネル（ &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 関数を参照）の形式は、 &lt;code&gt;$~&lt;/code&gt; 変数に形式の名前を割り当てることで明示的に設定できます。</target>
        </trans-unit>
        <trans-unit id="3c8b534fc59790f52bbc323708c6a448e4336f1e" translate="yes" xml:space="preserve">
          <source>Writes a formatted record (possibly multi-line) to the specified FILEHANDLE, using the format associated with that file. By default the format for a file is the one having the same name as the filehandle, but the format for the current output channel (see the &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function) may be set explicitly by assigning the name of the format to the &lt;code&gt;$~&lt;/code&gt; variable.</source>
          <target state="translated">指定されたFILEHANDLEに、そのファイルに関連付けられたフォーマットを使用して、フォーマットされたレコード（おそらく複数行）を書き込みます。デフォルトでは、ファイルの形式はファイルハンドルと同じ名前の形式ですが、現在の出力チャネル（ &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 関数を参照）の形式は、 &lt;code&gt;$~&lt;/code&gt; 変数に形式の名前を割り当てることで明示的に設定できます。</target>
        </trans-unit>
        <trans-unit id="4e8961057173b914aa902d24e81d3c55d00dde52" translate="yes" xml:space="preserve">
          <source>Writes all files in and below the current directory to your</source>
          <target state="translated">カレントディレクトリ以下のすべてのファイルを</target>
        </trans-unit>
        <trans-unit id="1ff3060cc065fe5dcf829a42d2a8d401fd64f6d8" translate="yes" xml:space="preserve">
          <source>Writes an empty FORCE: target.</source>
          <target state="translated">空の FORCE:target を書き込みます。</target>
        </trans-unit>
        <trans-unit id="f5369d43b2f75bf65f1c9b2bf55177161b67ef85" translate="yes" xml:space="preserve">
          <source>Writes are permitted, i.e. opened as &quot;w&quot; or &quot;r+&quot; or &quot;a&quot;, etc.</source>
          <target state="translated">書き込みが許可されており、&quot;w &quot;や &quot;r+&quot;や &quot;a &quot;などのようにオープンされています。</target>
        </trans-unit>
        <trans-unit id="bc03658e3c61d9705d37afb50e35b60738df57d4" translate="yes" xml:space="preserve">
          <source>Writes the contents of &lt;code&gt;$buffer&lt;/code&gt; to the compressed file. Returns the number of bytes actually written, or 0 on error.</source>
          <target state="translated">&lt;code&gt;$buffer&lt;/code&gt; の内容を圧縮ファイルに書き込みます。実際に書き込まれたバイト数を返します。エラーの場合は0を返します。</target>
        </trans-unit>
        <trans-unit id="3b30b2d9d9b94819a1a73fa66ad9fdb3aaf93cb5" translate="yes" xml:space="preserve">
          <source>Writes the file META.yml (YAML encoded meta-data) and META.json (JSON encoded meta-data) about the module in the distdir. The format follows Module::Build's as closely as possible.</source>
          <target state="translated">モジュールに関する META.yml (YAML エンコードされたメタデータ)と META.json (JSON エンコードされたメタデータ)を distdir に書き込みます。書式は Module::Build のものにできるだけ忠実に従います。</target>
        </trans-unit>
        <trans-unit id="759cd7af683913d2e067b4f6ffe525a9a1d4a391" translate="yes" xml:space="preserve">
          <source>Writes the file SIGNATURE with &quot;cpansign -s&quot;.</source>
          <target state="translated">cpansign -s &quot;でsignatureファイルを書き込みます。</target>
        </trans-unit>
        <trans-unit id="284cf58439290385abdec38ca7c004471227b097" translate="yes" xml:space="preserve">
          <source>Writes the output of</source>
          <target state="translated">の出力を書き込みます。</target>
        </trans-unit>
        <trans-unit id="7576a6f2b013b505dded5e0784047fb79ad928e8" translate="yes" xml:space="preserve">
          <source>Writes to the &lt;code&gt;.c&lt;/code&gt; output file certain preprocessor directives and function headers needed in all such files.</source>
          <target state="translated">このようなすべてのファイルに必要な特定のプリプロセッサディレクティブと関数ヘッダーを &lt;code&gt;.c&lt;/code&gt; 出力ファイルに書き込みます。</target>
        </trans-unit>
        <trans-unit id="fdd8d478482d63bc406cd41436757960d17780fb" translate="yes" xml:space="preserve">
          <source>Writing Accessors</source>
          <target state="translated">ライティングアクセサ</target>
        </trans-unit>
        <trans-unit id="1986c44b3bdced950b196d1c43f6cf37a6963d63" translate="yes" xml:space="preserve">
          <source>Writing Constructors</source>
          <target state="translated">コンストラクタの記述</target>
        </trans-unit>
        <trans-unit id="2e43f89f29a3e136e02e547cac033fa128355bb0" translate="yes" xml:space="preserve">
          <source>Writing Perl on an EBCDIC platform is really no different than writing on an &lt;a href=&quot;#ASCII&quot;&gt;&quot;ASCII&quot;&lt;/a&gt; one, but with different underlying numbers, as we'll see shortly. You'll have to know something about those &lt;a href=&quot;#ASCII&quot;&gt;&quot;ASCII&quot;&lt;/a&gt; platforms because the documentation is biased and will frequently use example numbers that don't apply to EBCDIC. There are also very few CPAN modules that are written for EBCDIC and which don't work on ASCII; instead the vast majority of CPAN modules are written for ASCII, and some may happen to work on EBCDIC, while a few have been designed to portably work on both.</source>
          <target state="translated">EBCDICプラットフォームでPerlを作成することは、&lt;a href=&quot;#ASCII&quot;&gt;「ASCII」&lt;/a&gt;プラットフォームで作成することと実際には違いはありませんが、後で説明するように、基になる数値が異なります。ドキュメントには偏りがあり、EBCDICに適用されない例番号を頻繁に使用するため、これらの&lt;a href=&quot;#ASCII&quot;&gt;「ASCII」&lt;/a&gt;プラットフォームについて何かを知っておく必要があります。EBCDIC用に作成され、ASCIIでは機能しないCPANモジュールもほとんどありません。代わりに、CPANモジュールの大部分はASCII用に記述されており、EBCDICで動作するものもあれば、両方で移植可能に動作するように設計されているものもあります。</target>
        </trans-unit>
        <trans-unit id="ac0e44a3a37a4109877068f7584a4c6e490675d8" translate="yes" xml:space="preserve">
          <source>Writing Perl on an EBCDIC platform is really no different than writing on an &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; one, but with different underlying numbers, as we'll see shortly. You'll have to know something about those &lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt; platforms because the documentation is biased and will frequently use example numbers that don't apply to EBCDIC. There are also very few CPAN modules that are written for EBCDIC and which don't work on ASCII; instead the vast majority of CPAN modules are written for ASCII, and some may happen to work on EBCDIC, while a few have been designed to portably work on both.</source>
          <target state="translated">EBCDICプラットフォームでPerlを作成することは、&lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt;で作成することと実際に違いはありませんが、後で説明するように、基になる数値が異なります。ドキュメントには偏りがあり、EBCDICに適用されない例の数値を頻繁に使用するため、これらの&lt;a href=&quot;#ASCII&quot;&gt;ASCII&lt;/a&gt;プラットフォームについて何か知っておく必要があります。EBCDIC用に作成され、ASCIIで動作しないCPANモジュールもほとんどありません。代わりに、CPANモジュールの大部分はASCII用に書かれており、一部はEBCDICで動作する可能性がありますが、一部は両方で移植可能に動作するように設計されています。</target>
        </trans-unit>
        <trans-unit id="b3e7a0572dc689213dcccc6f0ad9b2cbd894a46a" translate="yes" xml:space="preserve">
          <source>Writing Plugins</source>
          <target state="translated">プラグインの書き方</target>
        </trans-unit>
        <trans-unit id="b23e7b02c4f050eb7a5f668109f71a414a28c33d" translate="yes" xml:space="preserve">
          <source>Writing Your Own Debugger</source>
          <target state="translated">独自のデバッガを書く</target>
        </trans-unit>
        <trans-unit id="12d7ef5d9c4d923fdecfc0a2ba03562ba21e7e82" translate="yes" xml:space="preserve">
          <source>Writing a Filter</source>
          <target state="translated">フィルタの書き方</target>
        </trans-unit>
        <trans-unit id="7f135a17864ace6ae98bf7a3b9d9b4e20dd72358" translate="yes" xml:space="preserve">
          <source>Writing a module with MakeMaker</source>
          <target state="translated">MakeMakerでモジュールを書く</target>
        </trans-unit>
        <trans-unit id="f103eaa4bfb0cd111ad63870dfe99daf1dbfeefb" translate="yes" xml:space="preserve">
          <source>Writing a source filter as a separate executable works fine, but a small performance penalty is incurred. For example, if you execute the small example above, a separate subprocess will be created to run the Unix &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; command. Each use of the filter requires its own subprocess. If creating subprocesses is expensive on your system, you might want to consider one of the other options for creating source filters.</source>
          <target state="translated">ソースフィルターを個別の実行可能ファイルとして書き込むと問題なく機能しますが、パフォーマンスが少し低下します。たとえば、上記の小さな例を実行すると、別のサブプロセスが作成され、Unix &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; コマンドを実行します。フィルターを使用するたびに、独自のサブプロセスが必要です。システムでサブプロセスの作成にコストがかかる場合は、ソースフィルターを作成するための他のオプションの1つを検討することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="42340678aabb28dd8e04eb2e84c897c77707c165" translate="yes" xml:space="preserve">
          <source>Writing a source filter as a separate executable works fine, but a small performance penalty is incurred. For example, if you execute the small example above, a separate subprocess will be created to run the Unix &lt;code&gt;tr&lt;/code&gt; command. Each use of the filter requires its own subprocess. If creating subprocesses is expensive on your system, you might want to consider one of the other options for creating source filters.</source>
          <target state="translated">ソースフィルターを個別の実行可能ファイルとして作成することは問題なく機能しますが、パフォーマンスがわずかに低下します。たとえば、上記の小さな例を実行すると、 &lt;code&gt;tr&lt;/code&gt; コマンドを実行するための別のサブプロセスが作成されます。フィルタを使用するたびに、独自のサブプロセスが必要です。システムでサブプロセスの作成にコストがかかる場合は、ソースフィルターを作成するための他のオプションの1つを検討することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="e224913e88be93885651c47ecb1638090afee7fe" translate="yes" xml:space="preserve">
          <source>Writing all these print statements rapidly gets tedious. Fortunately, there's &lt;a href=&quot;Test::Simple&quot;&gt;Test::Simple&lt;/a&gt;. It has one function, &lt;code&gt;ok()&lt;/code&gt;.</source>
          <target state="translated">これらすべてのprintステートメントを書くことは急速に退屈になります。幸い、&lt;a href=&quot;Test::Simple&quot;&gt;Test :: Simpleがあり&lt;/a&gt;ます。 &lt;code&gt;ok()&lt;/code&gt; という1つの関数があります。</target>
        </trans-unit>
        <trans-unit id="fc88b791ccf860fd9df472625687a215e4594f7f" translate="yes" xml:space="preserve">
          <source>Writing backticks in your program sends a clear message to the readers of your code that you wanted to collect the output of the command. Why send a clear message that isn't true?</source>
          <target state="translated">あなたのプログラムにバックティックを書くことは、あなたがコマンドの出力を収集したかったという明確なメッセージをコードの読者に送ります。なぜ真ではない明確なメッセージを送るのでしょうか?</target>
        </trans-unit>
        <trans-unit id="a44149bd1f420e38e67feec9febfbe47dcef5694" translate="yes" xml:space="preserve">
          <source>Writing good test scripts</source>
          <target state="translated">良いテストスクリプトを書く</target>
        </trans-unit>
        <trans-unit id="0d1216f3de5359a11d177bd450454690960a8410" translate="yes" xml:space="preserve">
          <source>Writing subroutines</source>
          <target state="translated">サブルーチンの書き方</target>
        </trans-unit>
        <trans-unit id="a553ca3bc37b04388da0cff3bc379f04cee8df42" translate="yes" xml:space="preserve">
          <source>Writing subroutines is easy:</source>
          <target state="translated">サブルーチンを書くのは簡単です。</target>
        </trans-unit>
        <trans-unit id="c828d0e28e2f569743446e2de56ca66e456c09b7" translate="yes" xml:space="preserve">
          <source>Writing the patch</source>
          <target state="translated">パッチを書く</target>
        </trans-unit>
        <trans-unit id="5c10b682e330dccc302170e80493f9eb65449a91" translate="yes" xml:space="preserve">
          <source>Writing the short option first is recommended because it's easier to read. The long option is long enough to draw the eye to it anyway and the short option can otherwise get lost in visual noise.</source>
          <target state="translated">短い方が読みやすいので、短い方を先に書くことをお勧めします。長いオプションはとにかく目を惹くのに十分な長さがあり、短いオプションはそうでなければ視覚的なノイズの中で迷子になってしまうことがあります。</target>
        </trans-unit>
        <trans-unit id="1b1d022be94ce5d1101d118c8c80cf3364019b48" translate="yes" xml:space="preserve">
          <source>Writing typemap Entries</source>
          <target state="translated">タイプマップの書き方 エントリー</target>
        </trans-unit>
        <trans-unit id="1292edaa487b14cb74f82d4343628858075e0756" translate="yes" xml:space="preserve">
          <source>Wrong: the Storable engine creates an empty one for you. If you know Eiffel, you can view &lt;code&gt;STORABLE_thaw&lt;/code&gt; as an alternate creation routine.</source>
          <target state="translated">誤り：Storableエンジンが空のエンジンを作成します。Eiffelを知っている場合は、 &lt;code&gt;STORABLE_thaw&lt;/code&gt; を別の作成ルーチンと見なすことができます。</target>
        </trans-unit>
        <trans-unit id="efb99bcd657604ed5888480f20557abaea6afd06" translate="yes" xml:space="preserve">
          <source>Wx</source>
          <target state="translated">Wx</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="af3f0530ce3709877b0c716af9417386f334acd7" translate="yes" xml:space="preserve">
          <source>X [vars]</source>
          <target state="translated">X [vars]</target>
        </trans-unit>
        <trans-unit id="75a98d9bf0f92217c5e8d8919ec41748402162fa" translate="yes" xml:space="preserve">
          <source>XCPT_CATCH</source>
          <target state="translated">XCPT_CATCH</target>
        </trans-unit>
        <trans-unit id="0bbce50dfafd43d2aea26e0a316ecb5bb2789444" translate="yes" xml:space="preserve">
          <source>XCPT_RETHROW</source>
          <target state="translated">XCPT_RETHROW</target>
        </trans-unit>
        <trans-unit id="1c8ec453fa062fcc4d8beb21dfeb7f00e0044e3e" translate="yes" xml:space="preserve">
          <source>XCPT_TRY_END</source>
          <target state="translated">XCPT_TRY_END</target>
        </trans-unit>
        <trans-unit id="62c03b6a034496de09dbf74c72c47fb4b194a801" translate="yes" xml:space="preserve">
          <source>XCPT_TRY_START</source>
          <target state="translated">XCPT_TRY_START</target>
        </trans-unit>
        <trans-unit id="42573a00146341106bb0f06ab931a0b8e20775e3" translate="yes" xml:space="preserve">
          <source>XEmacs</source>
          <target state="translated">XEmacs</target>
        </trans-unit>
        <trans-unit id="c0aa9ef764d832b80428d756a731a94251b0e3a1" translate="yes" xml:space="preserve">
          <source>XML</source>
          <target state="translated">XML</target>
        </trans-unit>
        <trans-unit id="494019465f27565c960f3085abca99be390bd01b" translate="yes" xml:space="preserve">
          <source>XML charref mode (</source>
          <target state="translated">XML charref モード (</target>
        </trans-unit>
        <trans-unit id="7a5fc108bfdd5d96d6f99a6eac89c9af874db7d8" translate="yes" xml:space="preserve">
          <source>XPG operability often implies the presence of an</source>
          <target state="translated">XPGの操作性は、しばしば</target>
        </trans-unit>
        <trans-unit id="0f082b9799dcb8475e7d6fcb04a5adfa774635d5" translate="yes" xml:space="preserve">
          <source>XPUSH args AND set RETVAL AND assign return value to array</source>
          <target state="translated">XPUSH argsとRETVALを設定し、配列に戻り値を代入します。</target>
        </trans-unit>
        <trans-unit id="6e96c8ba90434c3991abef6b482029bbb705d617" translate="yes" xml:space="preserve">
          <source>XPUSHi</source>
          <target state="translated">XPUSHi</target>
        </trans-unit>
        <trans-unit id="a45f993c8bc95467cd94eca181fdf46437f5427b" translate="yes" xml:space="preserve">
          <source>XPUSHmortal</source>
          <target state="translated">XPUSHmortal</target>
        </trans-unit>
        <trans-unit id="b231a036815021c5444d064b7fcc1c528ade03e8" translate="yes" xml:space="preserve">
          <source>XPUSHn</source>
          <target state="translated">XPUSHn</target>
        </trans-unit>
        <trans-unit id="f47cdabf2ef1edeef2bd1fb53b6f18747c332149" translate="yes" xml:space="preserve">
          <source>XPUSHp</source>
          <target state="translated">XPUSHp</target>
        </trans-unit>
        <trans-unit id="1dab76d5986d1df120c308434288452972f88fb7" translate="yes" xml:space="preserve">
          <source>XPUSHs</source>
          <target state="translated">XPUSHs</target>
        </trans-unit>
        <trans-unit id="f596fc77ff9e6f6918218a1843202b6b44412bbc" translate="yes" xml:space="preserve">
          <source>XPUSHu</source>
          <target state="translated">XPUSHu</target>
        </trans-unit>
        <trans-unit id="bdb1d0d2760db0ae33b02dff5258e945e708b990" translate="yes" xml:space="preserve">
          <source>XS</source>
          <target state="translated">XS</target>
        </trans-unit>
        <trans-unit id="92bd1887109d3a53eb97d00630c2016c2f9abe52" translate="yes" xml:space="preserve">
          <source>XS VERSION</source>
          <target state="translated">XSバージョン</target>
        </trans-unit>
        <trans-unit id="f150c9e4da4e74cdaf804a24288dd2d36c2aab56" translate="yes" xml:space="preserve">
          <source>XS code added by Greg Bacon &amp;lt;</source>
          <target state="translated">Greg Baconによって追加されたXSコード&amp;lt;</target>
        </trans-unit>
        <trans-unit id="1cf142c571c2183260c4664ac183845da5980944" translate="yes" xml:space="preserve">
          <source>XS code can usually be made to work with any platform, but dependent libraries, header files, etc., might not be readily available or portable, or the XS code itself might be platform-specific, just as Perl code might be. If the libraries and headers are portable, then it is normally reasonable to make sure the XS code is portable, too.</source>
          <target state="translated">XSのコードは通常、どのプラットフォームでも動作するようにすることができますが、依存するライブラリやヘッダファイルなどは、容易に入手できなかったり、移植性がなかったりすることがあります。ライブラリやヘッダが移植可能であれば、XSのコードも移植可能であることを確認するのが一般的です。</target>
        </trans-unit>
        <trans-unit id="292d659c22a7eedddefa474cf1aa726bcee0908b" translate="yes" xml:space="preserve">
          <source>XS code for using native C functions borrowed from &lt;code&gt;&lt;a href=&quot;Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt;, written by Marcus Harnisch &amp;lt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt; から借用したネイティブC関数を使用するためのXSコード、MarcusHarnischによって作成&amp;lt;</target>
        </trans-unit>
        <trans-unit id="7e8ccd1927a425f4cd71fc5858f4ce61be503a94" translate="yes" xml:space="preserve">
          <source>XS code for using native C functions borrowed from &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt;, written by Marcus Harnisch &amp;lt;</source>
          <target state="translated">Marcus Harnischによって作成された &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unix::Syslog&quot;&gt;Unix::Syslog&lt;/a&gt;&lt;/code&gt; から借用したネイティブC関数を使用するためのXSコード&amp;lt;</target>
        </trans-unit>
        <trans-unit id="fe30568ef2d4c300e100572dbcce63bef5e87790" translate="yes" xml:space="preserve">
          <source>XS code has full access to system calls including C library functions. It thus has the capability of interfering with things that the Perl core or other modules have set up, such as signal handlers or file handles. It could mess with the memory, or any number of harmful things. Don't.</source>
          <target state="translated">XS のコードは、C ライブラリの関数を含むシステムコールに完全にアクセスすることができます。そのため、シグナルハンドラやファイルハンドルなど、Perlコアや他のモジュールが設定したものを妨害する能力を持っています。メモリに干渉したり、有害なことをする可能性があります。しないでください。</target>
        </trans-unit>
        <trans-unit id="33d48b61f9e9a038a7aea1ef00483763c58f6eff" translate="yes" xml:space="preserve">
          <source>XS code is probably better using &quot;typemap&quot; if it expects FILE * arguments. The standard typemap will be adjusted to comprehend any changes in this area.</source>
          <target state="translated">XSのコードは、FILE *の引数を期待している場合は、&quot;typemap &quot;を使った方が良いかもしれません。標準のタイプマップは、この部分の変更を理解するように調整されます。</target>
        </trans-unit>
        <trans-unit id="89e8c193e223b649f3d44b4194d19ce56bb23e01" translate="yes" xml:space="preserve">
          <source>XS code is very sensitive to the module version number and will complain if the version number in your Perl module doesn't match. If you change your module's version # without rerunning Makefile.PL the old version number will remain in the Makefile, causing the XS code to be built with the wrong number.</source>
          <target state="translated">XSのコードはモジュールのバージョン番号に非常に敏感で、Perlモジュールのバージョン番号が一致しないと文句を言います。Makefile.PL を再実行せずにモジュールのバージョン番号を変更すると、古いバージョン番号が Makefile に残り、XS コードが間違った番号でビルドされてしまいます。</target>
        </trans-unit>
        <trans-unit id="9966dea2f0bef9d06ac3bd55d265441a4061b99f" translate="yes" xml:space="preserve">
          <source>XS code or C-language libraries called from it that use the system &lt;a href=&quot;setlocale(3)&quot;&gt;&lt;code&gt;setlocale(3)&lt;/code&gt;&lt;/a&gt; function (except on Windows) likely will not work from a multi-threaded application without changes. See &lt;a href=&quot;perlxs#Locale-aware-XS-code&quot;&gt;&quot;Locale-aware XS code&quot; in perlxs&lt;/a&gt;.</source>
          <target state="translated">システム&lt;a href=&quot;setlocale(3)&quot;&gt; &lt;code&gt;setlocale(3)&lt;/code&gt; &lt;/a&gt;関数（Windowsを除く）を使用するXSコードまたはそれから呼び出されるC言語ライブラリは、変更なしではマルチスレッドアプリケーションから機能しない可能性があります。&lt;a href=&quot;perlxs#Locale-aware-XS-code&quot;&gt;perlxsの「ロケール対応XSコード」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="def563b19b3d7a04b960dc4d401ac89d52a4e717" translate="yes" xml:space="preserve">
          <source>XS is an interface description file format used to create an extension interface between Perl and C code (or a C library) which one wishes to use with Perl. The XS interface is combined with the library to create a new library which can then be either dynamically loaded or statically linked into perl. The XS interface description is written in the XS language and is the core component of the Perl extension interface.</source>
          <target state="translated">XSは、PerlとCコード(またはCライブラリ)の間の拡張インターフェースを作成するために使用されるインターフェース記述ファイル形式です。XSインタフェースはライブラリと結合されて新しいライブラリを作成し、動的に読み込まれたり、Perlに静的にリンクされたりすることができます。XSインタフェースの説明はXS言語で書かれており、Perl拡張インタフェースのコアコンポーネントとなっています。</target>
        </trans-unit>
        <trans-unit id="c1322757203b80e7b2662642555746c59f625860" translate="yes" xml:space="preserve">
          <source>XS modules for all categories but &lt;code&gt;LC_NUMERIC&lt;/code&gt; get the underlying locale, and hence any C library functions they call will use that underlying locale. For more discussion, see &lt;a href=&quot;perlxs#CAVEATS&quot;&gt;&quot;CAVEATS&quot; in perlxs&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;LC_NUMERIC&lt;/code&gt; を除くすべてのカテゴリのXSモジュールは基になるロケールを取得するため、それらが呼び出すCライブラリ関数はすべてその基になるロケールを使用します。詳細については、&lt;a href=&quot;perlxs#CAVEATS&quot;&gt;perlxsの「CAVEATS」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c6e0da0571ab8b6cd13332fb1b92e13ef69723c3" translate="yes" xml:space="preserve">
          <source>XS modules for all categories but &lt;code&gt;LC_NUMERIC&lt;/code&gt; get the underlying locale, and hence any C library functions they call will use that underlying locale. For more discussion, see &lt;a href=&quot;perlxs#CAVEATS&quot;&gt;CAVEATS in perlxs&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;LC_NUMERIC&lt;/code&gt; を除くすべてのカテゴリのXSモジュールは基本となるロケールを取得するため、それらが呼び出すすべてのCライブラリ関数は基本となるロケールを使用します。詳細については、&lt;a href=&quot;perlxs#CAVEATS&quot;&gt;perlxsの警告を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cde8f9f4aa7dc1d35b0c98fee87c3ff3dfbc220c" translate="yes" xml:space="preserve">
          <source>XS-type modules do require re-linking the perl binary, because part of an XS module is written in &quot;C&quot;, and has to be linked together with the perl binary to be executed. This is required because perl under DJGPP is built with the &quot;static link&quot; option, due to the lack of &quot;dynamic linking&quot; in the DJGPP environment.</source>
          <target state="translated">XS型モジュールの一部は &quot;C &quot;で書かれており、実行するためにはPerlのバイナリと一緒にリンクする必要があるため、XS型モジュールはPerlのバイナリを再リンクする必要があります。これは、DJGPP環境では「動的リンク」がないため、DJGPP環境のperlは「静的リンク」オプションでビルドされているために必要となります。</target>
        </trans-unit>
        <trans-unit id="ec2988beaa8676362d1ed3ab16467d9b855facea" translate="yes" xml:space="preserve">
          <source>XS::APItest</source>
          <target state="translated">XS::APItest</target>
        </trans-unit>
        <trans-unit id="f864391a1885990bb3986e5bb9cdfe1529118689" translate="yes" xml:space="preserve">
          <source>XS::APItest - Test the perl C API</source>
          <target state="translated">XS::APItest-perl C API をテストする</target>
        </trans-unit>
        <trans-unit id="77965b88f2916dfa7ea799a1ecde83c5bade894f" translate="yes" xml:space="preserve">
          <source>XS::Typemap</source>
          <target state="translated">XS::Typemap</target>
        </trans-unit>
        <trans-unit id="1e9618266eb67d10623f9d27874dc8f7655ade73" translate="yes" xml:space="preserve">
          <source>XS::Typemap - module to test the XS typemaps distributed with perl</source>
          <target state="translated">XS::Typemap-perl で配布されている XS の型マップをテストするためのモジュール</target>
        </trans-unit>
        <trans-unit id="abb06f137479712fdf29157a9f339063d581a30d" translate="yes" xml:space="preserve">
          <source>XSBUILD</source>
          <target state="translated">XSBUILD</target>
        </trans-unit>
        <trans-unit id="69f57ba624b38c0aa8389aea0ffe9fd217df0165" translate="yes" xml:space="preserve">
          <source>XSLoader</source>
          <target state="translated">XSLoader</target>
        </trans-unit>
        <trans-unit id="afd8fa1c6f48c528375edb581b5cfae64284c5a7" translate="yes" xml:space="preserve">
          <source>XSLoader - Dynamically load C libraries into Perl code</source>
          <target state="translated">XSLoader-Perl コードに C ライブラリを動的にロードする</target>
        </trans-unit>
        <trans-unit id="beb5f03415996a22eb7162d79a1cf0e450db5ba8" translate="yes" xml:space="preserve">
          <source>XSMULTI</source>
          <target state="translated">XSMULTI</target>
        </trans-unit>
        <trans-unit id="0921a161e9b005cd558f520ad84c3711a9234802" translate="yes" xml:space="preserve">
          <source>XSOPT</source>
          <target state="translated">XSOPT</target>
        </trans-unit>
        <trans-unit id="92e8e6dd254dabeb8537af4197e956a328b3ea2d" translate="yes" xml:space="preserve">
          <source>XSPROTOARG</source>
          <target state="translated">XSPROTOARG</target>
        </trans-unit>
        <trans-unit id="870a57e9b71b2a4c7d8b5d7661446dadbdc3d78c" translate="yes" xml:space="preserve">
          <source>XSRETURN</source>
          <target state="translated">XSRETURN</target>
        </trans-unit>
        <trans-unit id="4412705ffd15db1cc81dd4e97115e4240eed7c02" translate="yes" xml:space="preserve">
          <source>XSRETURN_EMPTY</source>
          <target state="translated">XSRETURN_EMPTY</target>
        </trans-unit>
        <trans-unit id="7516ad5d6afe7eff2028827f9d3ce25b91d747e1" translate="yes" xml:space="preserve">
          <source>XSRETURN_IV</source>
          <target state="translated">XSRETURN_IV</target>
        </trans-unit>
        <trans-unit id="7e5a22d1a7883f884227641cdf52bde57c7c0cd5" translate="yes" xml:space="preserve">
          <source>XSRETURN_NO</source>
          <target state="translated">XSRETURN_NO</target>
        </trans-unit>
        <trans-unit id="a72df091bba7b8d6d0f9b76040485b4a1059b320" translate="yes" xml:space="preserve">
          <source>XSRETURN_NV</source>
          <target state="translated">XSRETURN_NV</target>
        </trans-unit>
        <trans-unit id="c9bd2b450336e9a3992bddc7c7b4a884bb908613" translate="yes" xml:space="preserve">
          <source>XSRETURN_PV</source>
          <target state="translated">XSRETURN_PV</target>
        </trans-unit>
        <trans-unit id="31bb0caf5acf67711f8b48a53013782fa24d0e5c" translate="yes" xml:space="preserve">
          <source>XSRETURN_UNDEF</source>
          <target state="translated">XSRETURN_UNDEF</target>
        </trans-unit>
        <trans-unit id="75dd44c03d403bbc60a246b9a6263dd12586d022" translate="yes" xml:space="preserve">
          <source>XSRETURN_UV</source>
          <target state="translated">XSRETURN_UV</target>
        </trans-unit>
        <trans-unit id="6940b196422b14c137e4603100533585c01d3873" translate="yes" xml:space="preserve">
          <source>XSRETURN_YES</source>
          <target state="translated">XSRETURN_YES</target>
        </trans-unit>
        <trans-unit id="0071e55f0de2d741b86408cbdd221e6b71588408" translate="yes" xml:space="preserve">
          <source>XST_mIV</source>
          <target state="translated">XST_mIV</target>
        </trans-unit>
        <trans-unit id="8746b00346bb95fd6d7203847b95eace0e227af2" translate="yes" xml:space="preserve">
          <source>XST_mNO</source>
          <target state="translated">XST_mNO</target>
        </trans-unit>
        <trans-unit id="18b7e60b2312b4cdf84185a38f3105ba024df44d" translate="yes" xml:space="preserve">
          <source>XST_mNV</source>
          <target state="translated">XST_mNV</target>
        </trans-unit>
        <trans-unit id="f5704ef0a40693c861b7a0f79e6acb2f0a79e526" translate="yes" xml:space="preserve">
          <source>XST_mPV</source>
          <target state="translated">XST_mPV</target>
        </trans-unit>
        <trans-unit id="b30947135a6d0dc9cd094f1f5c672b0d8df27a87" translate="yes" xml:space="preserve">
          <source>XST_mUNDEF</source>
          <target state="translated">XST_mUNDEF</target>
        </trans-unit>
        <trans-unit id="c4c00149e31a863f36a4eccec4b30bed628c9d7b" translate="yes" xml:space="preserve">
          <source>XST_mUV</source>
          <target state="translated">XST_mUV</target>
        </trans-unit>
        <trans-unit id="850783c2d3d2b8cee3448cdaf150b58812cdd570" translate="yes" xml:space="preserve">
          <source>XST_mYES</source>
          <target state="translated">XST_mYES</target>
        </trans-unit>
        <trans-unit id="ddfc93741501a0abefa88da99d97e36deaed4cbc" translate="yes" xml:space="preserve">
          <source>XSUB</source>
          <target state="translated">XSUB</target>
        </trans-unit>
        <trans-unit id="4579138c9695c3de09b5142af11ef81d8446e749" translate="yes" xml:space="preserve">
          <source>XSUB.h</source>
          <target state="translated">XSUB.h</target>
        </trans-unit>
        <trans-unit id="df024d96e0c6354fb4e32675dd41d60e15bc6f98" translate="yes" xml:space="preserve">
          <source>XSUBANY</source>
          <target state="translated">XSUBANY</target>
        </trans-unit>
        <trans-unit id="4df5cfe3d83127b158a7d5a161b5570785b675ad" translate="yes" xml:space="preserve">
          <source>XSUBs and the Argument Stack</source>
          <target state="translated">XSUBと引数スタック</target>
        </trans-unit>
        <trans-unit id="638efca4cf9c7b80e03f195d87e0ea4d39d29c81" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to avoid automatic conversion of Perl function arguments to C function arguments. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details. Some people prefer manual conversion by inspecting &lt;code&gt;ST(i)&lt;/code&gt; even in the cases when automatic conversion will do, arguing that this makes the logic of an XSUB call clearer. Compare with &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;&quot;Getting the fat out of XSUBs&quot;&lt;/a&gt; for a similar tradeoff of a complete separation of &quot;Perl glue&quot; and &quot;workhorse&quot; parts of an XSUB.</source>
          <target state="translated">XSUBは、Perl関数の引数からC関数の引数への自動変換を回避することもできます。詳細については、&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;を参照してください。一部の人々は、自動変換が行われる場合でも &lt;code&gt;ST(i)&lt;/code&gt; を検査することによる手動変換を好み、これによりXSUB呼び出しのロジックがより明確になると主張しています。&lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;XSUB&lt;/a&gt;の「Perl接着剤」と「主力」の部分を完全に分離するという同様のトレードオフについては、「XSUBから脂肪を取り除く」と比較してください。</target>
        </trans-unit>
        <trans-unit id="3b5999991ea7d60b38c8ca1802a3aa2e3198b825" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to avoid automatic conversion of Perl function arguments to C function arguments. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details. Some people prefer manual conversion by inspecting &lt;code&gt;ST(i)&lt;/code&gt; even in the cases when automatic conversion will do, arguing that this makes the logic of an XSUB call clearer. Compare with &lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;Getting the fat out of XSUBs&lt;/a&gt; for a similar tradeoff of a complete separation of &quot;Perl glue&quot; and &quot;workhorse&quot; parts of an XSUB.</source>
          <target state="translated">XSUBは、Perl関数引数からC関数引数への自動変換を回避することもできます。詳細については&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;を参照してください。一部の人々は、自動変換が行われる場合でも、 &lt;code&gt;ST(i)&lt;/code&gt; を検査することにより手動変換を好み、これによりXSUB呼び出しのロジックがより明確になると主張します。&lt;a href=&quot;#Getting-the-fat-out-of-XSUBs&quot;&gt;XSUB&lt;/a&gt;の「Perl接着剤」と「主力」の部分を完全に分離するという同様のトレードオフについては、XSUBから脂肪を取り除くことと比較してください。</target>
        </trans-unit>
        <trans-unit id="54080bcfea2adf5c913b064ead22f355c2ce0033" translate="yes" xml:space="preserve">
          <source>XSUBs are also allowed to return lists, not just scalars. This must be done by manipulating stack values ST(0), ST(1), etc, in a subtly different way. See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for details.</source>
          <target state="translated">XSUBは、スカラーだけでなくリストを返すこともできます。これは、スタック値ST（0）、ST（1）などを微妙に異なる方法で操作することによって実行する必要があります。詳細については&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="88b3157d6a7563b7eeae312db4f170271aab7d57" translate="yes" xml:space="preserve">
          <source>XSUBs can have variable-length parameter lists by specifying an ellipsis &lt;code&gt;(...)&lt;/code&gt; in the parameter list. This use of the ellipsis is similar to that found in ANSI C. The programmer is able to determine the number of arguments passed to the XSUB by examining the &lt;code&gt;items&lt;/code&gt; variable which the &lt;b&gt;xsubpp&lt;/b&gt; compiler supplies for all XSUBs. By using this mechanism one can create an XSUB which accepts a list of parameters of unknown length.</source>
          <target state="translated">XSUBは、パラメーターリストで省略記号 &lt;code&gt;(...)&lt;/code&gt; を指定することにより、可変長パラメーターリストを持つことができます。省略記号のこの使用法は、ANSI Cでの使用法に似ています。プログラマーは、&lt;b&gt;xsubpp&lt;/b&gt;コンパイラーがすべてのXSUBに提供する &lt;code&gt;items&lt;/code&gt; 変数を調べることにより、XSUBに渡される引数の数を判別できます。このメカニズムを使用することにより、長さが不明なパラメーターのリストを受け入れるXSUBを作成できます。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3be2c3082f6ee5ac4e24cba3fef031d150316f00" translate="yes" xml:space="preserve">
          <source>XSUBs do not have a &lt;code&gt;CvPADLIST&lt;/code&gt;. &lt;code&gt;dXSTARG&lt;/code&gt; fetches values from &lt;code&gt;PL_curpad&lt;/code&gt;, but that is really the callers pad (a slot of which is allocated by every entersub). Do not get or set &lt;code&gt;CvPADLIST&lt;/code&gt; if a CV is an XSUB (as determined by &lt;code&gt;CvISXSUB()&lt;/code&gt;), &lt;code&gt;CvPADLIST&lt;/code&gt; slot is reused for a different internal purpose in XSUBs.</source>
          <target state="translated">XSUBには &lt;code&gt;CvPADLIST&lt;/code&gt; がありません。 &lt;code&gt;dXSTARG&lt;/code&gt; はから値をフェッチ &lt;code&gt;PL_curpad&lt;/code&gt; 、それは実際に発信者のパッド（毎entersubによって割り当てされたスロット）です。取得または設定されていない &lt;code&gt;CvPADLIST&lt;/code&gt; CVがXSUBある場合（によって決定されるよう &lt;code&gt;CvISXSUB()&lt;/code&gt; ）、 &lt;code&gt;CvPADLIST&lt;/code&gt; のスロットなXSUBに異なる内部目的のために再利用されます。</target>
        </trans-unit>
        <trans-unit id="3f2e0ddc3d17d87460a2a8a983be1c97c83b73d1" translate="yes" xml:space="preserve">
          <source>XSUBs do not have a CvPADLIST. dXSTARG fetches values from PL_curpad, but that is really the callers pad (a slot of which is allocated by every entersub). Do not get or set CvPADLIST if a CV is an XSUB (as determined by &lt;code&gt;CvISXSUB()&lt;/code&gt; ), CvPADLIST slot is reused for a different internal purpose in XSUBs.</source>
          <target state="translated">XSUBにはCvPADLISTがありません。dXSTARGはPL_curpadから値をフェッチしますが、これは実際には発信者パッドです（そのスロットはすべてのentersubによって割り当てられます）。CVがXSUB（ &lt;code&gt;CvISXSUB()&lt;/code&gt; によって決定される）である場合、CvPADLISTを取得または設定しないでください。CvPADLISTスロットは、XSUBの別の内部目的で再利用されます。</target>
        </trans-unit>
        <trans-unit id="6daf3f5f97a3cf191b47d0b650ffb497515d3ee1" translate="yes" xml:space="preserve">
          <source>XSUBs refer to their stack arguments with the macro &lt;b&gt;ST(x)&lt;/b&gt;, where</source>
          <target state="translated">XSUBは、スタック引数をマクロ&lt;b&gt;ST（x）&lt;/b&gt;で参照します。</target>
        </trans-unit>
        <trans-unit id="b948898c3205f86da22df7bb2aa8e0fc31385f66" translate="yes" xml:space="preserve">
          <source>XS_APIVERSION_BOOTCHECK</source>
          <target state="translated">XS_APIVERSION_BOOTCHECK</target>
        </trans-unit>
        <trans-unit id="45e92c706e14fc42e8a65549cfb504f51b80720e" translate="yes" xml:space="preserve">
          <source>XS_DEFINE_VERSION: -D line to set the xs version when compiling.</source>
          <target state="translated">XS_DEFINE_VERSION:-D 行でコンパイル時に xs のバージョンを設定します。</target>
        </trans-unit>
        <trans-unit id="c079612ab9bf6b165676a675aeaa6f541c733506" translate="yes" xml:space="preserve">
          <source>XS_EXTERNAL</source>
          <target state="translated">XS_EXTERNAL</target>
        </trans-unit>
        <trans-unit id="b36c9e63716f92004705d5a5880b339795a114b1" translate="yes" xml:space="preserve">
          <source>XS_FH</source>
          <target state="translated">XS_FH</target>
        </trans-unit>
        <trans-unit id="0b91e170805a05f3fc3b4f1fe3e1c801a51a5cd9" translate="yes" xml:space="preserve">
          <source>XS_FILE</source>
          <target state="translated">XS_FILE</target>
        </trans-unit>
        <trans-unit id="5a72d7eb1d508bb628564c702b5adf9c962f07c6" translate="yes" xml:space="preserve">
          <source>XS_INTERNAL</source>
          <target state="translated">XS_INTERNAL</target>
        </trans-unit>
        <trans-unit id="c30e58ff83929eb55292bc3f56bfb117c5d6b82f" translate="yes" xml:space="preserve">
          <source>XS_SUBNAME</source>
          <target state="translated">XS_SUBNAME</target>
        </trans-unit>
        <trans-unit id="c3c54470969e9570024cbdc019515c6664650a72" translate="yes" xml:space="preserve">
          <source>XS_VERSION</source>
          <target state="translated">XS_VERSION</target>
        </trans-unit>
        <trans-unit id="f6c7bf9f42bb6c2a25e194ec60219f0a8150edce" translate="yes" xml:space="preserve">
          <source>XS_VERSION: version in your .xs file. Defaults to $(VERSION)</source>
          <target state="translated">XS_VERSION:.xs ファイルのバージョン。デフォルトは $(VERSION)です。</target>
        </trans-unit>
        <trans-unit id="849ccfe7e642de7c6c2afec3b38bc17a103cbe71" translate="yes" xml:space="preserve">
          <source>XS_VERSION_BOOTCHECK</source>
          <target state="translated">XS_VERSION_BOOTCHECK</target>
        </trans-unit>
        <trans-unit id="53fccca1190b204bd667ec9d6791fd3b9d14df6c" translate="yes" xml:space="preserve">
          <source>XS_VERSION_MACRO: which macro represents the XS version.</source>
          <target state="translated">XS_VERSION_MACRO:XS のバージョンを表すマクロ。</target>
        </trans-unit>
        <trans-unit id="c3b618e9ce8bc3b3691008b5df681815a883cb69" translate="yes" xml:space="preserve">
          <source>XS_constant PACKAGE, TYPES, XS_SUBNAME, C_SUBNAME</source>
          <target state="translated">XS_constant PACKAGE,TYPES,XS_SUBNAME,C_SUBNAME</target>
        </trans-unit>
        <trans-unit id="20026dc165c030fe3a5d9609a6e61ab26210cbc1" translate="yes" xml:space="preserve">
          <source>XX</source>
          <target state="translated">XX</target>
        </trans-unit>
        <trans-unit id="a9674b19f8c56f785c91a555d0a144522bb318e6" translate="yes" xml:space="preserve">
          <source>XXX</source>
          <target state="translated">XXX</target>
        </trans-unit>
        <trans-unit id="efc0ac66700effcf3b5c6d5cfb0d3ed1e5da5cc1" translate="yes" xml:space="preserve">
          <source>XXX DAPM it would make more sense to make the arg a PADOFFSET void SAVEPADSV(PADOFFSET po)</source>
          <target state="translated">XXX DAPMでは、引数をPADOFFSETにする方が理にかなっています。</target>
        </trans-unit>
        <trans-unit id="0a8c3822391bb958edc27b75e5a6c90f50363bce" translate="yes" xml:space="preserve">
          <source>XXX.</source>
          <target state="translated">XXX.</target>
        </trans-unit>
        <trans-unit id="759d5f762181a933d7c0ff7fd8096838ff6b5ec3" translate="yes" xml:space="preserve">
          <source>XXX: Needs more docs.</source>
          <target state="translated">XXX:もっとドキュメントが必要。</target>
        </trans-unit>
        <trans-unit id="e3a8809017dd76bd26557a5b923ab2ae16c0cdb3" translate="yes" xml:space="preserve">
          <source>XXXX</source>
          <target state="translated">XXXX</target>
        </trans-unit>
        <trans-unit id="034f1965ccdbdf9e642feeb9858da5096b6d1a9a" translate="yes" xml:space="preserve">
          <source>XY</source>
          <target state="translated">XY</target>
        </trans-unit>
        <trans-unit id="1ed31ab8e3d4874b1d94827212eca5617d49d812" translate="yes" xml:space="preserve">
          <source>XopDISABLE</source>
          <target state="translated">XopDISABLE</target>
        </trans-unit>
        <trans-unit id="fdee56cbf2dd3729d372ee9ddd71eeb3c584e3a0" translate="yes" xml:space="preserve">
          <source>XopENABLE</source>
          <target state="translated">XopENABLE</target>
        </trans-unit>
        <trans-unit id="d452a85c41b2e0aa7a38834ff3a3b101c7d4ac6f" translate="yes" xml:space="preserve">
          <source>XopENTRY</source>
          <target state="translated">XopENTRY</target>
        </trans-unit>
        <trans-unit id="12a6abfec4959cd21c68fcfdd5a310b6940a1038" translate="yes" xml:space="preserve">
          <source>XopENTRYCUSTOM</source>
          <target state="translated">XopENTRYCUSTOM</target>
        </trans-unit>
        <trans-unit id="f6bc06eec4d13090054285af25a6e8fdfa5cb801" translate="yes" xml:space="preserve">
          <source>XopENTRY_set</source>
          <target state="translated">XopENTRY_set</target>
        </trans-unit>
        <trans-unit id="b37b621154ed9fa599925b4a3aa2dcee68ee7486" translate="yes" xml:space="preserve">
          <source>XopFLAGS</source>
          <target state="translated">XopFLAGS</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="ffbcb202b09db426bae56cf2ffb88f18594f2258" translate="yes" xml:space="preserve">
          <source>YAML</source>
          <target state="translated">YAML</target>
        </trans-unit>
        <trans-unit id="50bc04e009ed4a61bc2c2e4c00258238b3cec732" translate="yes" xml:space="preserve">
          <source>YAML result token.</source>
          <target state="translated">YAMLの結果トークン。</target>
        </trans-unit>
        <trans-unit id="453e08045c54cb8be51989088de3dde3aad22542" translate="yes" xml:space="preserve">
          <source>YAML, &lt;a href=&quot;http://www.yaml.org/&quot;&gt;http://www.yaml.org/&lt;/a&gt;</source>
          <target state="translated">YAML、&lt;a href=&quot;http://www.yaml.org/&quot;&gt;http：&lt;/a&gt; //www.yaml.org/</target>
        </trans-unit>
        <trans-unit id="8fff039853f5c2bbb8a28d056b579c7dcb7d137f" translate="yes" xml:space="preserve">
          <source>YES</source>
          <target state="translated">YES</target>
        </trans-unit>
        <trans-unit id="bf4ca579becca81a75bf09eee1a917765b24f975" translate="yes" xml:space="preserve">
          <source>YMMV.</source>
          <target state="translated">YMMV.</target>
        </trans-unit>
        <trans-unit id="f4577d4c77ab9c132acbb835cae3c75d2c81ffab" translate="yes" xml:space="preserve">
          <source>YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!</source>
          <target state="translated">カーネルのSET-ID SCRIPTSはまだ無効化されていません。</target>
        </trans-unit>
        <trans-unit id="9a8fc610a3168e82e07390203ce40d7382c7da6f" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DDThh:mm:ss</source>
          <target state="translated">YYYY-MM-DDThh:mm:ss</target>
        </trans-unit>
        <trans-unit id="76ac22fb38468218ad6552d9043d5bb2c7920d48" translate="yes" xml:space="preserve">
          <source>Year Value Interpretation</source>
          <target state="translated">年値の解釈</target>
        </trans-unit>
        <trans-unit id="44f6289f7e3326b30824a187cdb204e4dc7264b2" translate="yes" xml:space="preserve">
          <source>Years greater than 999 are interpreted as being the actual year, rather than the offset from 1900. Thus, 1964 would indicate the year Martin Luther King won the Nobel prize, not the year 3864.</source>
          <target state="translated">999 より大きい年は、1900 年からのオフセットではなく、実際の年と解釈されます。したがって、1964年はマーティン・ルーサー・キングがノーベル賞を受賞した年であり、3864年ではないことを示しています。</target>
        </trans-unit>
        <trans-unit id="c9ec20e90ee8369d4a4738a1355fc718ca45a57e" translate="yes" xml:space="preserve">
          <source>Years in the range 0..99 are interpreted as shorthand for years in the rolling &quot;current century,&quot; defined as 50 years on either side of the current year. Thus, today, in 1999, 0 would refer to 2000, and 45 to 2045, but 55 would refer to 1955. Twenty years from now, 55 would instead refer to 2055. This is messy, but matches the way people currently think about two digit dates. Whenever possible, use an absolute four digit year instead.</source>
          <target state="translated">0~99の範囲の年は、現在の年の両側50年と定義されている「現在の世紀」の年の速記法として解釈されています。したがって、1999年の今日、0は2000年、45は2045年を意味しますが、55は1955年を意味します。20年後には、55年は2055年となります。これはややこしいですが、現在の人々の2桁の日付に対する考え方に合致しています。可能な限り、絶対4桁の年号を使用してください。</target>
        </trans-unit>
        <trans-unit id="862a9bbc8aa08db48d5ef905c8dc85be457e6ea8" translate="yes" xml:space="preserve">
          <source>Years in the range 100..999 are interpreted as offset from 1900, so that 112 indicates 2012. This rule also applies to years less than zero (but see note below regarding date range).</source>
          <target state="translated">100~999の範囲内の年は1900年からのオフセットとして解釈され、112は2012年を示します。この規則はゼロ未満の年にも適用されます(ただし、日付範囲については下記の注意事項を参照)。</target>
        </trans-unit>
        <trans-unit id="dfc439a506f8ca9ae872d5d02c2ad4c82b034c13" translate="yes" xml:space="preserve">
          <source>Yes it is, see previous answer. Since &lt;code&gt;Compress::Zlib&lt;/code&gt; and therefore &lt;code&gt;IO::Zlib&lt;/code&gt; doesn't support &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; on their filehandles, there is little choice but to read the archive into memory. This is ok if you want to do in-memory manipulation of the archive.</source>
          <target state="translated">はい、前の回答を参照してください。以来 &lt;code&gt;Compress::Zlib&lt;/code&gt; ため、 &lt;code&gt;IO::Zlib&lt;/code&gt; サポートしていません &lt;code&gt;&lt;a href=&quot;../functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 彼らのファイルハンドルの上に、選択の余地はなくメモリにアーカイブを読むことがあります。これは、アーカイブをメモリ内で操作したい場合には問題ありません。</target>
        </trans-unit>
        <trans-unit id="4a483b69465fec8d9ad0abf1cb110a3cd5a4d0a4" translate="yes" xml:space="preserve">
          <source>Yes it is, see previous answer. Since &lt;code&gt;Compress::Zlib&lt;/code&gt; and therefore &lt;code&gt;IO::Zlib&lt;/code&gt; doesn't support &lt;code&gt;seek&lt;/code&gt; on their filehandles, there is little choice but to read the archive into memory. This is ok if you want to do in-memory manipulation of the archive.</source>
          <target state="translated">はい、そうです。前の回答を参照してください。以来 &lt;code&gt;Compress::Zlib&lt;/code&gt; ため、 &lt;code&gt;IO::Zlib&lt;/code&gt; サポートしていません &lt;code&gt;seek&lt;/code&gt; 彼らのファイルハンドルの上に、選択の余地はなくメモリにアーカイブを読むことがあります。アーカイブのメモリ内操作を実行する場合は、これで問題ありません。</target>
        </trans-unit>
        <trans-unit id="acb5099459bfa43931dd4b78a628e1d113168a69" translate="yes" xml:space="preserve">
          <source>Yes it is. It's pure perl, so it's a lot slower then your &lt;code&gt;/bin/tar&lt;/code&gt; However, it's very portable. If speed is an issue, consider using &lt;code&gt;/bin/tar&lt;/code&gt; instead.</source>
          <target state="translated">はい、そうです。純粋なperlなので、 &lt;code&gt;/bin/tar&lt;/code&gt; よりもはるかに低速ですが、非常に移植性があります。速度が問題になる場合は、代わりに &lt;code&gt;/bin/tar&lt;/code&gt; の使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="bcbbf7da5377bd36deaae3d4c290fed0db7777c9" translate="yes" xml:space="preserve">
          <source>Yes, both the &lt;code&gt;IO-Compress-Zip&lt;/code&gt; and &lt;code&gt;IO-Uncompress-Unzip&lt;/code&gt; modules support the zip feature called</source>
          <target state="translated">はい、 &lt;code&gt;IO-Compress-Zip&lt;/code&gt; モジュールと &lt;code&gt;IO-Uncompress-Unzip&lt;/code&gt; モジュールの両方がと呼ばれるzip機能をサポートしています</target>
        </trans-unit>
        <trans-unit id="4107dbe8a030ec286ba38d4f763957128d667542" translate="yes" xml:space="preserve">
          <source>Yes, it does</source>
          <target state="translated">はい、そうですね</target>
        </trans-unit>
        <trans-unit id="3678471c058284ba4000bf6331c346c6bbd02a28" translate="yes" xml:space="preserve">
          <source>Yes, that's a lot of expansion.</source>
          <target state="translated">はい、それはそれで拡張性が高いですね。</target>
        </trans-unit>
        <trans-unit id="eb5a8cd62389870da5aba481f01f1a18a4a6e511" translate="yes" xml:space="preserve">
          <source>Yes, there's a lot of that :-) But more precisely, in UNIX systems there's a utility called &lt;code&gt;file&lt;/code&gt; , which recognizes data files based on their contents (usually their first few bytes). For this to work, a certain file called</source>
          <target state="translated">はい、たくさんあります:-)しかし、より正確には、UNIXシステムには、 &lt;code&gt;file&lt;/code&gt; （通常は最初の数バイト）に基づいてデータファイルを認識するfileと呼ばれるユーティリティがあります。これが機能するために、</target>
        </trans-unit>
        <trans-unit id="f71f9d886920a4f49da8093935995672de9199c3" translate="yes" xml:space="preserve">
          <source>Yes, there's a lot of that :-) But more precisely, in UNIX systems there's a utility called &lt;code&gt;file&lt;/code&gt;, which recognizes data files based on their contents (usually their first few bytes). For this to work, a certain file called</source>
          <target state="translated">はい、それはたくさんあります:-)しかし、より正確には、UNIXシステムには &lt;code&gt;file&lt;/code&gt; と呼ばれるユーティリティがあり、その内容（通常は最初の数バイト）に基づいてデータファイルを認識します。これが機能するために、と呼ばれる特定のファイル</target>
        </trans-unit>
        <trans-unit id="032ab970df677757a74b1c2b5fdbae010210746c" translate="yes" xml:space="preserve">
          <source>Yes, there's a mistake in the test suite. What! Me, contrived?</source>
          <target state="translated">はい、テストスイートに間違いがあります。何だと!</target>
        </trans-unit>
        <trans-unit id="dc1e472e45c46619f7f9549ce98213f0173da937" translate="yes" xml:space="preserve">
          <source>Yes, you can do this by either using the &lt;code&gt;-T&lt;/code&gt; option, or by invoking the program as &lt;code&gt;perlthanks&lt;/code&gt; . Thank-you notes are good. It makes people smile.</source>
          <target state="translated">はい、これを行うには、 &lt;code&gt;-T&lt;/code&gt; オプションを使用するか、プログラムを &lt;code&gt;perlthanks&lt;/code&gt; として呼び出します。ありがとうメモはいいです。それは人々を笑顔にします。</target>
        </trans-unit>
        <trans-unit id="8987958587b6289e3623984d6459696a8ad818f9" translate="yes" xml:space="preserve">
          <source>Yes, you can do this by either using the &lt;code&gt;-T&lt;/code&gt; option, or by invoking the program as &lt;code&gt;perlthanks&lt;/code&gt;. Thank-you notes are good. It makes people smile.</source>
          <target state="translated">はい、これを行うには、 &lt;code&gt;-T&lt;/code&gt; オプションを使用するか、 &lt;code&gt;perlthanks&lt;/code&gt; としてプログラムを呼び出します。ありがとうのメモは良いです。それは人々を笑顔にします。</target>
        </trans-unit>
        <trans-unit id="2c8d0f90fcceba5d3649946cef16ef6f0de57be0" translate="yes" xml:space="preserve">
          <source>Yes, you can! If your sources are UTF-8 encoded, you can indicate that with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma.</source>
          <target state="translated">はい、できます！ソースがUTF-8でエンコードされている &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; は、use utf8プラグマでそれを示すことができます。</target>
        </trans-unit>
        <trans-unit id="77a1a43bdaae65a00429084f6cd8a3dc8163734c" translate="yes" xml:space="preserve">
          <source>Yes, you can! If your sources are UTF-8 encoded, you can indicate that with the &lt;code&gt;use utf8&lt;/code&gt; pragma.</source>
          <target state="translated">はい、できます！ソースがUTF-8でエンコードされている &lt;code&gt;use utf8&lt;/code&gt; プラグマを使用してそのことを示すことができます。</target>
        </trans-unit>
        <trans-unit id="fd3c0b60626749e4fb04200f5ac37da9c3ba6f91" translate="yes" xml:space="preserve">
          <source>Yes, you could probably do the same thing with code like $token-&amp;gt;isa('Pod::Simple::PullParserEndToken'), but that's not so pretty as using just $token-&amp;gt;type, or even the following shortcuts:</source>
          <target state="translated">はい、おそらく$ token-&amp;gt; isa（ 'Pod :: Simple :: PullParserEndToken'）のようなコードで同じことを行うことができますが、これは$ token-&amp;gt; typeだけを使用したり、次のショートカットを使用したりするのと同じくらいきれいではありません。</target>
        </trans-unit>
        <trans-unit id="9ba10bd10462c10515a891999d5f144a0ef8db84" translate="yes" xml:space="preserve">
          <source>Yes. If you are building a web site with any level of interactivity (forms / users / databases), you will want to use a framework to make handling requests and responses easier.</source>
          <target state="translated">はい、もしあなたが任意のレベルのインタラクティブ性(フォーム/ユーザー/データベース)を持つWebサイトを構築しているのであれば、リクエストやレスポンスをより簡単に処理できるフレームワークを使用したいと思うでしょう。</target>
        </trans-unit>
        <trans-unit id="4131deed69500e1ce76a1aa4746c5be5d04540cb" translate="yes" xml:space="preserve">
          <source>Yes. Perl's garbage collection system takes care of this so everything works out right.</source>
          <target state="translated">そうですね。Perlのガベージコレクションシステムがこれを処理してくれるので、すべてが正しく動作します。</target>
        </trans-unit>
        <trans-unit id="3a7fae4176564291917eb6c0f952942b7ae63ec5" translate="yes" xml:space="preserve">
          <source>Yes. Read &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for more information. Some examples follow. (These assume standard Unix shell quoting rules.)</source>
          <target state="translated">はい。詳細&lt;a href=&quot;perlrun&quot;&gt;については&lt;/a&gt;、perlrunを参照してください。次にいくつかの例を示します。（これらは標準的なUnixシェルの引用ルールを想定しています。）</target>
        </trans-unit>
        <trans-unit id="64a64c9d49bc7ff568ef5c62aefe6945eee0a81a" translate="yes" xml:space="preserve">
          <source>Yes. Zip64 allows this. See previous question.</source>
          <target state="translated">そうですね。Zip64では可能です。前の質問を参照してください。</target>
        </trans-unit>
        <trans-unit id="85739d75a309637ea84dea150d48798fe5f385f6" translate="yes" xml:space="preserve">
          <source>Yet Another Compiler Compiler. A parser generator without which Perl probably would not have existed. See the file</source>
          <target state="translated">Yet Another Compiler コンパイラ。Perl が存在しなければ、おそらく Perl は存在しなかったであろうパーサジェネレータ。ファイルを参照してください。</target>
        </trans-unit>
        <trans-unit id="7fafe5e36aa3122413d32c6d4c8b4284bb245038" translate="yes" xml:space="preserve">
          <source>Yet another capturing group numbering technique (also as from Perl 5.10) deals with the problem of referring to groups within a set of alternatives. Consider a pattern for matching a time of the day, civil or military style:</source>
          <target state="translated">もう一つのグループ番号付けのテクニック(Perl 5.10 からのものもあります)は、選択肢のセットの中でグループを参照する問題に対処しています。一日の時間帯、市民や軍人のスタイルを一致させるためのパターンを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="a23e788a3e5975e13dc401fc7dc400a7d94469f5" translate="yes" xml:space="preserve">
          <source>Yet another framework for writing test scripts</source>
          <target state="translated">テストスクリプトを書くための別のフレームワーク</target>
        </trans-unit>
        <trans-unit id="1f545787fad8ec88f6418a5e7cfe487632178eef" translate="yes" xml:space="preserve">
          <source>Yet another pseudo-class that &lt;code&gt;NEXT&lt;/code&gt; provides is &lt;code&gt;EVERY&lt;/code&gt;. Its behaviour is considerably simpler than that of the &lt;code&gt;NEXT&lt;/code&gt; family. A call to:</source>
          <target state="translated">&lt;code&gt;NEXT&lt;/code&gt; が提供するさらに別の疑似クラスは &lt;code&gt;EVERY&lt;/code&gt; です。その動作は、 &lt;code&gt;NEXT&lt;/code&gt; ファミリの動作よりもかなり単純です。呼び出し先：</target>
        </trans-unit>
        <trans-unit id="50d7418e5885441f0de4ccbd54d601d8993cfb34" translate="yes" xml:space="preserve">
          <source>Yet another pseudo-class that NEXT.pm provides is &lt;code&gt;EVERY&lt;/code&gt; . Its behaviour is considerably simpler than that of the &lt;code&gt;NEXT&lt;/code&gt; family. A call to:</source>
          <target state="translated">NEXT.pmが提供するさらに別の疑似クラスは &lt;code&gt;EVERY&lt;/code&gt; です。その動作は、 &lt;code&gt;NEXT&lt;/code&gt; ファミリーの動作よりもかなり単純です。への呼び出し：</target>
        </trans-unit>
        <trans-unit id="807fa18eacfa8333a4615b7233d28577520ce46b" translate="yes" xml:space="preserve">
          <source>Yet another way is to assign to a &lt;code&gt;foreach&lt;/code&gt; loop</source>
          <target state="translated">さらに別の方法は、 &lt;code&gt;foreach&lt;/code&gt; ループに割り当てることです</target>
        </trans-unit>
        <trans-unit id="fb6a80ccd3cd48516fa10f2b5e43ec6135ec9451" translate="yes" xml:space="preserve">
          <source>Yet another way would be to use the Devel::Peek module:</source>
          <target state="translated">さらに別の方法としては、Devel::Peek モジュールを使用することです。</target>
        </trans-unit>
        <trans-unit id="8dd7850c540f0b2c7dd564faf5b435a82d533987" translate="yes" xml:space="preserve">
          <source>Yields the widest unsigned integer type on the platform, currently either &lt;code&gt;U32&lt;/code&gt; or &lt;code&gt;64&lt;/code&gt;. This can be used in declarations such as</source>
          <target state="translated">プラットフォーム上で最も幅の広い符号なし整数型（現在は &lt;code&gt;U32&lt;/code&gt; または &lt;code&gt;64&lt;/code&gt; )を生成します。これは、次のような宣言で使用できます。</target>
        </trans-unit>
        <trans-unit id="c970e3f1e790a2a4cd28b40401902501b9bc2d74" translate="yes" xml:space="preserve">
          <source>Yields:</source>
          <target state="translated">Yields:</target>
        </trans-unit>
        <trans-unit id="f551936e2c614f3a2dff9203d64b57c373086792" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;do not&lt;/b&gt; call &lt;code&gt;setlogsock&lt;/code&gt; .</source>
          <target state="translated">あなたは&lt;b&gt;していない&lt;/b&gt;呼び出し &lt;code&gt;setlogsock&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="c41e00d12c2bf30eb5c57363d593eb5f296a4201" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;do not&lt;/b&gt; call &lt;code&gt;setlogsock&lt;/code&gt;.</source>
          <target state="translated">あなたは&lt;b&gt;していない&lt;/b&gt;呼び出し &lt;code&gt;setlogsock&lt;/code&gt; を。</target>
        </trans-unit>
        <trans-unit id="b83525859b43ad2ba983b59bc741a630d369a604" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must not&lt;/b&gt; attempt to install by hand.</source>
          <target state="translated">あなたは&lt;b&gt;してはならない&lt;/b&gt;、手でインストールしようとします。</target>
        </trans-unit>
        <trans-unit id="adc6962b12f722ff929475c965699bd91420b623" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must&lt;/b&gt; convert characters to UVs using the above functions if you're ever in a situation where you have to match UTF-8 and non-UTF-8 characters. You may not skip over UTF-8 characters in this case. If you do this, you'll lose the ability to match hi-bit non-UTF-8 characters; for instance, if your UTF-8 string contains &lt;code&gt;v196.172&lt;/code&gt; , and you skip that character, you can never match a &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(200)&lt;/a&gt;&lt;/code&gt; in a non-UTF-8 string. So don't do that!</source>
          <target state="translated">UTF-8文字と非UTF-8文字を一致させる必要がある場合は、上記の関数を使用して文字をUVに変換する&lt;b&gt;必要&lt;/b&gt;があります。この場合、UTF-8文字をスキップすることはできません。これを行うと、ハイビットの非UTF-8文字に一致する機能が失われます。たとえば、UTF-8文字列に &lt;code&gt;v196.172&lt;/code&gt; が含まれている場合、その文字をスキップすると、UTF-8以外の文字列の &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(200)&lt;/a&gt;&lt;/code&gt; に一致することはできません。だから、それをしないでください！</target>
        </trans-unit>
        <trans-unit id="fa9dba3c584a1276adf1e71be9d8031a3210c272" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must&lt;/b&gt; convert characters to UVs using the above functions if you're ever in a situation where you have to match UTF-8 and non-UTF-8 characters. You may not skip over UTF-8 characters in this case. If you do this, you'll lose the ability to match hi-bit non-UTF-8 characters; for instance, if your UTF-8 string contains &lt;code&gt;v196.172&lt;/code&gt;, and you skip that character, you can never match a &lt;code&gt;chr(200)&lt;/code&gt; in a non-UTF-8 string. So don't do that!</source>
          <target state="translated">UTF-8文字と非UTF-8文字を一致させる必要がある場合は、上記の関数を使用して文字をUVに変換する&lt;b&gt;必要&lt;/b&gt;があります。この場合、UTF-8文字をスキップすることはできません。これを行うと、ハイビットの非UTF-8文字に一致する機能が失われます。たとえば、UTF-8文字列に &lt;code&gt;v196.172&lt;/code&gt; が含まれていて、その文字をスキップした場合、UTF-8以外の文字列の &lt;code&gt;chr(200)&lt;/code&gt; と一致させることはできません。だからそれをしないでください！</target>
        </trans-unit>
        <trans-unit id="84f6ab55499a431ab963225e1b323e598c043cac" translate="yes" xml:space="preserve">
          <source>You &lt;b&gt;must&lt;/b&gt; have the BFD (-lbfd) library installed, otherwise &lt;code&gt;perl&lt;/code&gt; will fail to link. The BFD is usually distributed as part of the GNU binutils.</source>
          <target state="translated">あなたは&lt;b&gt;しなければならない&lt;/b&gt;、BFD（-lbfd）ライブラリがインストールされているそれ以外の場合は &lt;code&gt;perl&lt;/code&gt; のリンクに失敗します。BFDは通常、GNU binutilsの一部として配布されます。</target>
        </trans-unit>
        <trans-unit id="b5fb57ccedc3fdf63890d16c6dbd3e60731ff70f" translate="yes" xml:space="preserve">
          <source>You CAN say</source>
          <target state="translated">あなたは言うことができます</target>
        </trans-unit>
        <trans-unit id="53a5cd5fed7f629c72dba4cfdfde9a745c8113d5" translate="yes" xml:space="preserve">
          <source>You MUST NOT pass context objects around</source>
          <target state="translated">コンテキストオブジェクトを</target>
        </trans-unit>
        <trans-unit id="9893e3bf74f00c1d618d88219ad526fbac0c0c29" translate="yes" xml:space="preserve">
          <source>You MUST NOT store or cache a context for later</source>
          <target state="translated">後で使うためにコンテキストを保存したりキャッシュしたりしてはいけません。</target>
        </trans-unit>
        <trans-unit id="a142a3f1e08b559ac377684a245517410ece7ce4" translate="yes" xml:space="preserve">
          <source>You MUST always release the context when done with it</source>
          <target state="translated">コンテキストの処理が終わったら、常にコンテキストを解放しなければなりません。</target>
        </trans-unit>
        <trans-unit id="f91a3f4c8d175f6cccdbd1ebd40641bce1aa24ca" translate="yes" xml:space="preserve">
          <source>You SHOULD obtain your context as soon as possible in a given tool</source>
          <target state="translated">与えられたツールでは、できるだけ早くコンテキストを取得すべきです[SHOULD]。</target>
        </trans-unit>
        <trans-unit id="f4ab9d853c38812e284656a7bf6f62a6214856cd" translate="yes" xml:space="preserve">
          <source>You already learned that a &lt;b&gt;method&lt;/b&gt; is a subroutine that operates on an object. You can think of a method as the things that an object can</source>
          <target state="translated">&lt;b&gt;メソッド&lt;/b&gt;はオブジェクトを操作するサブルーチンであることをすでに学びました。メソッドはオブジェクトができることと考えることができます</target>
        </trans-unit>
        <trans-unit id="9a0c2a8aac855d59d1e419df17c0d8362fab4ef6" translate="yes" xml:space="preserve">
          <source>You also cannot exit out of the sort block or subroutine using any of the loop control operators described in &lt;a href=&quot;../perlsyn&quot;&gt;perlsyn&lt;/a&gt; or with &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">また、&lt;a href=&quot;../perlsyn&quot;&gt;perlsyn&lt;/a&gt;または &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; で説明されているループ制御演算子のいずれかを使用して、ソートブロックまたはサブルーチンを終了することもできません。</target>
        </trans-unit>
        <trans-unit id="f67f30786418f2d13fcf93e360206e73fbe2ba5c" translate="yes" xml:space="preserve">
          <source>You also cannot exit out of the sort block or subroutine using any of the loop control operators described in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; or with &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">また、&lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;または&lt;a href=&quot;#goto-LABEL&quot;&gt; &lt;code&gt;goto&lt;/code&gt; で&lt;/a&gt;説明されているループ制御演算子を使用して、ソートブロックまたはサブルーチンを終了することもできません。</target>
        </trans-unit>
        <trans-unit id="cce8f481cd5c5e068e4367b0b286efd66e3e8b5e" translate="yes" xml:space="preserve">
          <source>You also cannot exit out of the sort block or subroutine using any of the loop control operators described in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; or with &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">また、&lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;または &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; で説明されているループ制御演算子のいずれかを使用して、ソートブロックまたはサブルーチンを終了することもできません。</target>
        </trans-unit>
        <trans-unit id="6462e3c6fa18441789982aade2cc057d4a5754fa" translate="yes" xml:space="preserve">
          <source>You also don't have to use push(). You could just make a direct assignment if you knew where you wanted to put it:</source>
          <target state="translated">また、push()を使う必要もありません。どこに置くかわかっていれば直接代入すればいいだけです。</target>
        </trans-unit>
        <trans-unit id="762d8de62e5184e1ddd3f7df62b51251838a45ad" translate="yes" xml:space="preserve">
          <source>You also have to be careful about context. You can assign an array to a scalar to get the number of elements in the array. This only works for arrays, though:</source>
          <target state="translated">また、コンテキストにも注意が必要です。配列をスカラに代入して、配列の要素数を取得することができます。ただし、これは配列に対してのみ機能します。</target>
        </trans-unit>
        <trans-unit id="c94e331eac1a6006813ffea35d4a89a5abaa1704" translate="yes" xml:space="preserve">
          <source>You also need dmake or gmake. See &lt;a href=&quot;#Make&quot;&gt;&quot;Make&quot;&lt;/a&gt; above on how to get it.</source>
          <target state="translated">dmakeまたはgmakeも必要です。入手方法については、上記の&lt;a href=&quot;#Make&quot;&gt;「作成」を&lt;/a&gt;ご覧ください。</target>
        </trans-unit>
        <trans-unit id="e9900e6006f63d330e774e6c340305cdfb9e9fa2" translate="yes" xml:space="preserve">
          <source>You also need dmake. See &lt;a href=&quot;#Make&quot;&gt;Make&lt;/a&gt; above on how to get it.</source>
          <target state="translated">dmakeも必要です。取得方法については、上記の&lt;a href=&quot;#Make&quot;&gt;Makeを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="bae77dd846c87a6c6a294ef10cab8c218809dda8" translate="yes" xml:space="preserve">
          <source>You also need to take care with modules that enable warnings for you. A common example being Moose. In this example, warnings for the 'smartmatch' feature are first turned on by the warnings pragma, off by the experimental pragma and back on again by the Moose module (fix is to switch the last two lines):</source>
          <target state="translated">また、あなたのために警告を有効にするモジュールに注意を払う必要があります。一般的な例は Moose です。この例では、'smartmatch' 機能の警告は warnings pragma によって最初にオンにされ、experimental pragma によってオフにされ、Moose モジュールによって再びオンにされます (修正は最後の 2 行を切り替えることです)。</target>
        </trans-unit>
        <trans-unit id="d4f9457dec1ff1c62632c87a4b529a8a11409acd" translate="yes" xml:space="preserve">
          <source>You are &lt;b&gt;strongly&lt;/b&gt; encouraged to use these subs in any new code which uses this module. It will almost certainly make your code's behavior less surprising.</source>
          <target state="translated">このモジュールを使用する新しいコードでは、これらのサブを使用することを&lt;b&gt;強くお&lt;/b&gt;勧めします。これにより、コードの動作が驚くほど少なくなることはほぼ間違いありません。</target>
        </trans-unit>
        <trans-unit id="ad4cae9e1d17ccae297619ff7a90fc58163adef4" translate="yes" xml:space="preserve">
          <source>You are allowed to use underscores (underbars) in numeric literals between digits for legibility (but not multiple underscores in a row: &lt;code&gt;23__500&lt;/code&gt; is not legal; &lt;code&gt;23_500&lt;/code&gt; is). You could, for example, group binary digits by threes (as for a Unix-style mode argument such as 0b110_100_100) or by fours (to represent nibbles, as in 0b1010_0110) or in other groups.</source>
          <target state="translated">数字の間の数値リテラルでは、読み &lt;code&gt;23__500&lt;/code&gt; するためにアンダースコア（アンダーバー）を使用できます（ただし、連続して複数のアンダースコアを使用することはできません。23__500は無効です &lt;code&gt;23_500&lt;/code&gt; は有効です）。たとえば、2桁の数字を3でグループ化したり（0b110_100_100などのUnixスタイルのモード引数の場合）、4でグループ化したり（0b1010_0110のようにニブルを表す）、他のグループにグループ化したりできます。</target>
        </trans-unit>
        <trans-unit id="e9086be8aa3acbf107ed69aa30ed1efd2e29806d" translate="yes" xml:space="preserve">
          <source>You are chdir()'d to &lt;code&gt;$File::Find::dir&lt;/code&gt; when the function is called, unless &lt;code&gt;no_chdir&lt;/code&gt; was specified. Note that when changing to directories is in effect the root directory (</source>
          <target state="translated">&lt;code&gt;no_chdir&lt;/code&gt; が指定されていない限り、関数が呼び出されると &lt;code&gt;$File::Find::dir&lt;/code&gt; にchdir（）されます。ディレクトリに変更すると、実際にはルートディレクトリ（</target>
        </trans-unit>
        <trans-unit id="3b7c887092493d390ff632279a2e09dfaf7f8868" translate="yes" xml:space="preserve">
          <source>You are chdir()'d to &lt;code&gt;$File::Find::dir&lt;/code&gt; when the function is called, unless &lt;code&gt;no_chdir&lt;/code&gt; was specified. Note that when changing to directories is in effect, the root directory (</source>
          <target state="translated">&lt;code&gt;no_chdir&lt;/code&gt; が指定されていない限り、関数が呼び出されると、 &lt;code&gt;$File::Find::dir&lt;/code&gt; にchdir（）されます。ディレクトリへの変更が有効な場合、ルートディレクトリ（</target>
        </trans-unit>
        <trans-unit id="765a24f0e7b225890131f993a03189d4db8249a5" translate="yes" xml:space="preserve">
          <source>You are either using a copy of zlib that is older than version 1.2.0 or you want your application code to be able to run with as many different versions of zlib as possible.</source>
          <target state="translated">バージョン1.2.0よりも古いzlibを使用しているか、アプリケーションコードをできるだけ多くの異なるバージョンのzlibで実行できるようにしたいと思っているかのどちらかです。</target>
        </trans-unit>
        <trans-unit id="a13d801950c0dc8ed9906d27d14a9952af5a263a" translate="yes" xml:space="preserve">
          <source>You are encouraged to participate in the discussion and advocate for your patch. Sometimes your patch may get lost in the shuffle. It's appropriate to send a reminder email to p5p if no action has been taken in a month. Please remember that the Perl 5 developers are all volunteers, and be polite.</source>
          <target state="translated">議論に参加し、あなたのパッチを擁護することをお勧めします。時々、あなたのパッチがシャッフルの中で迷子になるかもしれません。1ヶ月間何のアクションも取られていない場合は、p5pにリマインダーメールを送るのが適切です。Perl 5 の開発者はすべてボランティアであることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="719d41b23df4f3bd674c48a03b68b419d4539869" translate="yes" xml:space="preserve">
          <source>You are encouraged to use &lt;code&gt;is()&lt;/code&gt; and &lt;code&gt;isnt()&lt;/code&gt; over &lt;code&gt;ok()&lt;/code&gt; where possible, however do not be tempted to use them to find out if something is true or false!</source>
          <target state="translated">あなたが使用するように奨励されている &lt;code&gt;is()&lt;/code&gt; と &lt;code&gt;isnt()&lt;/code&gt; 上 &lt;code&gt;ok()&lt;/code&gt; 可能であれば、しかし、何かが真か偽であるかどうかを確認するためにそれらを使用するように誘惑することはありません！</target>
        </trans-unit>
        <trans-unit id="5f7051dcae7048dda5b89cea1569b5b5dced0666" translate="yes" xml:space="preserve">
          <source>You are encouraged to use the explicitly quoted form if you wish to use an empty line as the terminator of the here-document:</source>
          <target state="translated">空行をheere-documentの終端として使用したい場合は、明示的に引用した形式を使用することが推奨されます。</target>
        </trans-unit>
        <trans-unit id="7231b46f1cb348d100d3ac2d2fb73b6bf57d8066" translate="yes" xml:space="preserve">
          <source>You are guaranteed that &lt;code&gt;$dirs . $filename . $suffix&lt;/code&gt; will denote the same location as the original $path.</source>
          <target state="translated">&lt;code&gt;$dirs . $filename . $suffix&lt;/code&gt; が保証されます。$ filename。$ suffixは、元の$ pathと同じ場所を示します。</target>
        </trans-unit>
        <trans-unit id="845992c360c01c1fffb9e8ef6310e8cc47a34923" translate="yes" xml:space="preserve">
          <source>You are not supposed to modify arrays while they are being iterated over. For speed and efficiency reasons, Perl internally does not do full reference-counting of iterated items, hence deleting such an item in the middle of an iteration causes Perl to see a freed value.</source>
          <target state="translated">反復処理中に配列を変更することはできません。速度と効率性の理由から、Perl は内部的に反復された項目の完全な参照カウントを行わないため、反復の途中でそのような項目を削除すると Perl は解放された値を見ることになります。</target>
        </trans-unit>
        <trans-unit id="c4250931e7c7965b87b322df0e377d3c209e4074" translate="yes" xml:space="preserve">
          <source>You are recommended to change your code to set &lt;code&gt;$/&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; explicitly if you wish to slurp the file. In future versions of Perl assigning a reference to will throw a fatal error.</source>
          <target state="translated">ファイルを丸呑みしたい場合は、コードを変更して &lt;code&gt;$/&lt;/code&gt; を明示的に &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; に設定することをお勧めします。Perlの将来のバージョンでは、参照を割り当てると致命的なエラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="25b41e2d5bdfaa0dfc36f2b04421c00c9e912434" translate="yes" xml:space="preserve">
          <source>You are recommended to change your code to set &lt;code&gt;$/&lt;/code&gt; to &lt;code&gt;undef&lt;/code&gt; explicitly if you wish to slurp the file.</source>
          <target state="translated">ファイルを丸呑みしたい場合は、コードを変更して &lt;code&gt;$/&lt;/code&gt; を明示的に &lt;code&gt;undef&lt;/code&gt; に設定することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="5d012b1e71664ae83bcc78214d293fa6e2c91aff" translate="yes" xml:space="preserve">
          <source>You are recommended to change your code to set &lt;code&gt;$/&lt;/code&gt; to &lt;code&gt;undef&lt;/code&gt; explicitly if you wish to slurp the file. As of Perl 5.28 assigning &lt;code&gt;$/&lt;/code&gt; to a reference to an integer which isn't positive is a fatal error.</source>
          <target state="translated">ファイルを丸呑みしたい場合は、コードを変更して &lt;code&gt;$/&lt;/code&gt; を明示的に &lt;code&gt;undef&lt;/code&gt; に設定することをお勧めします。Perl 5.28以降、正ではない整数への参照に &lt;code&gt;$/&lt;/code&gt; を割り当てると、致命的なエラーになります。</target>
        </trans-unit>
        <trans-unit id="d65f3a3a78dc9835626ba2ec61976c50a4907da1" translate="yes" xml:space="preserve">
          <source>You are responsible for &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; on the return value if you plan to store it anywhere semi-permanently (otherwise it might be deleted out from under you the next time the cache is invalidated).</source>
          <target state="translated">あなたは責任があり &lt;code&gt;SvREFCNT_inc()&lt;/code&gt; あなたはどこにも半永久的に保管することを計画している場合、戻り値に（そうでない場合、それはあなたの下からキャッシュが無効化され、次回を削除される場合があります）。</target>
        </trans-unit>
        <trans-unit id="d2b17aed1d92752587b50f28c3736df1d3cdfde7" translate="yes" xml:space="preserve">
          <source>You are responsible for setting the decoding layers on &lt;code&gt;$handle&lt;/code&gt; if required.</source>
          <target state="translated">必要に応じて、 &lt;code&gt;$handle&lt;/code&gt; デコードレイヤーを設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="fda3d08b1d18c1ab40c3862a395af18d46e5f5cf" translate="yes" xml:space="preserve">
          <source>You are strongly discouraged from using this function directly. It is used by various core modules, like &lt;code&gt;Hash::Util&lt;/code&gt;, and the &lt;code&gt;constant&lt;/code&gt; pragma to implement higher-level behavior which should be used instead.</source>
          <target state="translated">この機能を直接使用することは強くお勧めしません。これは、 &lt;code&gt;Hash::Util&lt;/code&gt; などのさまざまなコアモジュールや、代わりに使用する必要がある高レベルの動作を実装するための &lt;code&gt;constant&lt;/code&gt; プラグマによって使用されます。</target>
        </trans-unit>
        <trans-unit id="37e416f1d8fe7e351baa8b0e70e6dc37f69f6f41" translate="yes" xml:space="preserve">
          <source>You are strongly encouraged to implement methods below, at least either encode() or decode().</source>
          <target state="translated">以下のメソッドは、少なくとも encode()か decode()のいずれかを実装することを強く推奨します。</target>
        </trans-unit>
        <trans-unit id="ff134e38e289cfa6f5f3d471d7e0e0fabcbe8c66" translate="yes" xml:space="preserve">
          <source>You are strongly encouraged to migrate any existing threaded code to the new model (i.e., use the &lt;code&gt;threads&lt;/code&gt; and &lt;code&gt;threads::shared&lt;/code&gt; modules) as soon as possible.</source>
          <target state="translated">できるだけ早く、既存のスレッドコードを新しいモデルに移行する（つまり、 &lt;code&gt;threads&lt;/code&gt; および &lt;code&gt;threads::shared&lt;/code&gt; モジュールを使用する）ことを強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="2a08b19fff728f8eb38fe62f343715380f316ef9" translate="yes" xml:space="preserve">
          <source>You aren't allowed to modify constants in this way, of course. If an argument were actually literal and you tried to change it, you'd take a (presumably fatal) exception. For example, this won't work:</source>
          <target state="translated">もちろん、この方法で定数を変更することはできません。もし引数が実際にはリテラルであり、それを変更しようとした場合、(おそらく致命的な)例外が発生します。例えば、これはうまくいきません。</target>
        </trans-unit>
        <trans-unit id="2ed4e9f522b1893c218a4950d5f8fc9530c317f7" translate="yes" xml:space="preserve">
          <source>You aren't limited to just a single &lt;code&gt;&quot;|&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;|&quot;&lt;/code&gt; は1つだけに限定されません 。</target>
        </trans-unit>
        <trans-unit id="6d1e1241acbf20a33264ba47e94319bd2c6bf6a8" translate="yes" xml:space="preserve">
          <source>You assigned a reference to a scalar to &lt;code&gt;$/&lt;/code&gt; where the referenced item is not a positive integer. In older perls this &lt;b&gt;appeared&lt;/b&gt; to work the same as setting it to &lt;code&gt;undef&lt;/code&gt; but was in fact internally different, less efficient and with very bad luck could have resulted in your file being split by a stringified form of the reference.</source>
          <target state="translated">スカラーへの参照を &lt;code&gt;$/&lt;/code&gt; に割り当てました。ここで、参照される項目は正の整数ではありません。古いperlsでは、これ&lt;b&gt;は&lt;/b&gt; &lt;code&gt;undef&lt;/code&gt; に設定するのと同じように機能するように&lt;b&gt;見え&lt;/b&gt;ましたが、実際には内部的に異なり、効率が低く、運が悪ければ、ファイルが文字列形式の参照によって分割される可能性がありました。</target>
        </trans-unit>
        <trans-unit id="1622820db3665cc19fb76f05a9e122011064bf68" translate="yes" xml:space="preserve">
          <source>You can &quot;make install&quot; already but you should test first.</source>
          <target state="translated">すでに「make install」はできますが、まずはテストをしてみましょう。</target>
        </trans-unit>
        <trans-unit id="441d296a1602f9e39d91a622912b032dea66e8b8" translate="yes" xml:space="preserve">
          <source>You can (and should) read more about references in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. Briefly, references are rather like pointers that know what they point to. (Objects are also a kind of reference, but we won't be needing them right away--if ever.) This means that when you have something which looks to you like an access to a two-or-more-dimensional array and/or hash, what's really going on is that the base type is merely a one-dimensional entity that contains references to the next level. It's just that you can</source>
          <target state="translated">&lt;a href=&quot;perlref&quot;&gt;perlrefで&lt;/a&gt;参照についての詳細を読むことができます（すべきです）。簡単に言えば、参照は、参照先を知っているポインタのようなものです。（オブジェクトも一種の参照ですが、すぐには必要ありません。これは、2次元以上の配列へのアクセスのように見えるものがあり、 /またはハッシュ、実際に起こっていることは、基本タイプが次のレベルへの参照を含む1次元のエンティティにすぎないということです。それはあなたができることだけです</target>
        </trans-unit>
        <trans-unit id="4c8d7d3437af9191b3b2ecdbf2e0cc22d58ff901" translate="yes" xml:space="preserve">
          <source>You can &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ize just one element of an aggregate. Usually this is done on dynamics:</source>
          <target state="translated">集約の1つの要素のみを &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; できます。通常、これはダイナミクスで行われます。</target>
        </trans-unit>
        <trans-unit id="8ef093b34210f5147b5553d815c011dc81eff7de" translate="yes" xml:space="preserve">
          <source>You can &lt;code&gt;local&lt;/code&gt;ize just one element of an aggregate. Usually this is done on dynamics:</source>
          <target state="translated">あなたはできる &lt;code&gt;local&lt;/code&gt; 集合体のただ一つの要素をIZE。通常、これはダイナミクスで行われます。</target>
        </trans-unit>
        <trans-unit id="3c3c57d183363a886eda26951cab8a3d873beb8e" translate="yes" xml:space="preserve">
          <source>You can access the first characters of a string with substr(). To get the first character, for example, start at position 0 and grab the string of length 1.</source>
          <target state="translated">文字列の最初の文字にアクセスするには substr()を使用します。最初の文字を取得するには、例えば 0 の位置から始めて、長さ 1 の文字列を取得します。</target>
        </trans-unit>
        <trans-unit id="4b6168183223c539ff65f81f73941c2c4a8e59c2" translate="yes" xml:space="preserve">
          <source>You can actually chomp anything that's an lvalue, including an assignment:</source>
          <target state="translated">実際には、代入を含めてlvalueであれば何でもチョンプすることができます。</target>
        </trans-unit>
        <trans-unit id="ab3659f896bba38cbe056eb37538d331f15d2fcc" translate="yes" xml:space="preserve">
          <source>You can actually chop anything that's an lvalue, including an assignment.</source>
          <target state="translated">実際には、代入を含め、lvalueであれば何でも切り刻むことができます。</target>
        </trans-unit>
        <trans-unit id="06e51b7968687b9d39d3fba6b7611216b01c17eb" translate="yes" xml:space="preserve">
          <source>You can actually put an array or hash anywhere in the list, but the first one in the list will soak up all the values, and anything after it will become undefined. This may be useful in a my() or local().</source>
          <target state="translated">実際にはリストのどこにでも配列やハッシュを置くことができますが、リストの最初のものはすべての値を吸収し、それ以降のものは未定義になります。これは my()や local()で便利です。</target>
        </trans-unit>
        <trans-unit id="532505c0e3919310f7105bcc98c9ca0331dbfd6d" translate="yes" xml:space="preserve">
          <source>You can actually take this one step further and test the manual itself. Have a look at &lt;a href=&quot;Test::Inline&quot;&gt;Test::Inline&lt;/a&gt; (formerly &lt;a href=&quot;Pod::Tests&quot;&gt;Pod::Tests&lt;/a&gt;).</source>
          <target state="translated">実際にこれをさらに一歩進めて、マニュアル自体をテストすることができます。見てい&lt;a href=&quot;Test::Inline&quot;&gt;テスト::インライン&lt;/a&gt;（旧&lt;a href=&quot;Pod::Tests&quot;&gt;ポッド::テストを&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9fcefecb0feb2b6d0223364636eebffcb896a89d" translate="yes" xml:space="preserve">
          <source>You can add customized aliases to standard (&lt;code&gt;:full&lt;/code&gt; ) Unicode naming conventions. The aliases override any standard definitions, so, if you're twisted enough, you can change &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A}&quot;&lt;/code&gt; to mean &lt;code&gt;&quot;B&quot;&lt;/code&gt; , etc.</source>
          <target state="translated">カスタマイズしたエイリアスを標準（ &lt;code&gt;:full&lt;/code&gt; ）Unicode命名規則に追加できます。エイリアスは標準の定義をオーバーライドするため、十分にねじれている場合は、 &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A}&quot;&lt;/code&gt; を &lt;code&gt;&quot;B&quot;&lt;/code&gt; などに変更できます。</target>
        </trans-unit>
        <trans-unit id="665e29e63421d2fd846f895a1a1e9676c964ad4a" translate="yes" xml:space="preserve">
          <source>You can add customized aliases to standard (&lt;code&gt;:full&lt;/code&gt;) Unicode naming conventions. The aliases override any standard definitions, so, if you're twisted enough, you can change &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A}&quot;&lt;/code&gt; to mean &lt;code&gt;&quot;B&quot;&lt;/code&gt;, etc.</source>
          <target state="translated">カスタマイズされたエイリアスを標準（ &lt;code&gt;:full&lt;/code&gt; ）のUnicode命名規則に追加できます。エイリアスは標準の定義を上書きするため、十分にねじれている場合は、 &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A}&quot;&lt;/code&gt; を &lt;code&gt;&quot;B&quot;&lt;/code&gt; などを意味するように変更できます。</target>
        </trans-unit>
        <trans-unit id="422d4c1954392600b653163b725624c46d77f3f0" translate="yes" xml:space="preserve">
          <source>You can adjust the counter by assigning to &lt;code&gt;$.&lt;/code&gt; , but this will not actually move the seek pointer.</source>
          <target state="translated">&lt;code&gt;$.&lt;/code&gt; 割り当てることで、カウンターを調整できます。、しかしこれは実際にはシークポインタを動かしません。</target>
        </trans-unit>
        <trans-unit id="1e12c1c150e8155af23e75fc04a29600af824216" translate="yes" xml:space="preserve">
          <source>You can adjust the counter by assigning to &lt;code&gt;$.&lt;/code&gt;, but this will not actually move the seek pointer.</source>
          <target state="translated">&lt;code&gt;$.&lt;/code&gt; 割り当てることで、カウンターを調整できます。、ただし、これは実際にはシークポインタを移動しません。</target>
        </trans-unit>
        <trans-unit id="add234c624f206426ee8290a3ddfc9b8ceedcb89" translate="yes" xml:space="preserve">
          <source>You can also alter the way the output and logic of &lt;code&gt;Carp&lt;/code&gt; works, by changing some global variables in the &lt;code&gt;Carp&lt;/code&gt; namespace. See the section on &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; below.</source>
          <target state="translated">&lt;code&gt;Carp&lt;/code&gt; 名前空間の一部のグローバル変数を変更することにより、 &lt;code&gt;Carp&lt;/code&gt; の出力とロジックの動作を変更することもできます。以下の &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="261bbd570ac37c0ad60f8d4ba64480f35ae30ac1" translate="yes" xml:space="preserve">
          <source>You can also call &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt; with a reference argument, and if this is trapped within an &lt;a href=&quot;#eval-EXPR&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; contains that reference. This permits more elaborate exception handling using objects that maintain arbitrary state about the exception. Such a scheme is sometimes preferable to matching particular string values of &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; with regular expressions.</source>
          <target state="translated">参照引数を使用して&lt;a href=&quot;#die-LIST&quot;&gt; &lt;code&gt;die&lt;/code&gt; &lt;/a&gt;を呼び出すこともできます。これが&lt;a href=&quot;#eval-EXPR&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;内にトラップされている場合、&lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt;はその参照が含まれます。これにより、例外に関する任意の状態を維持するオブジェクトを使用して、より複雑な例外処理が可能になります。このようなスキームは、&lt;a href=&quot;perlvar#%24%40&quot;&gt; &lt;code&gt;$@&lt;/code&gt; &lt;/a&gt;特定の文字列値を正規表現と照合するよりも望ましい場合があります。</target>
        </trans-unit>
        <trans-unit id="0d61dd797cd63f1042bbffa35621af46e71f5b31" translate="yes" xml:space="preserve">
          <source>You can also call &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with a reference argument, and if this is trapped within an &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;$@&lt;/code&gt; contains that reference. This permits more elaborate exception handling using objects that maintain arbitrary state about the exception. Such a scheme is sometimes preferable to matching particular string values of &lt;code&gt;$@&lt;/code&gt; with regular expressions. Because &lt;code&gt;$@&lt;/code&gt; is a global variable and &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; may be used within object implementations, be careful that analyzing the error object doesn't replace the reference in the global variable. It's easiest to make a local copy of the reference before any manipulations. Here's an example:</source>
          <target state="translated">参照引数を指定して &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; を呼び出すこともできます。これが &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 内にトラップされている場合、 &lt;code&gt;$@&lt;/code&gt; はその参照が含まれます。これにより、例外に関する任意の状態を維持するオブジェクトを使用して、より複雑な例外処理が可能になります。このようなスキームは、 &lt;code&gt;$@&lt;/code&gt; 特定の文字列値を正規表現と照合するよりも好ましい場合があります。ので &lt;code&gt;$@&lt;/code&gt; グローバル変数とある &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; はオブジェクト実装内で使用することができる、エラーオブジェクトの解析はグローバル変数の参照に置き換えられないように注意してください。操作を行う前に、参照のローカルコピーを作成するのが最も簡単です。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="151ae294544e5b15c198686df29c5202445b492a" translate="yes" xml:space="preserve">
          <source>You can also call &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; with a reference argument, and if this is trapped within an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;$@&lt;/code&gt; contains that reference. This permits more elaborate exception handling using objects that maintain arbitrary state about the exception. Such a scheme is sometimes preferable to matching particular string values of &lt;code&gt;$@&lt;/code&gt; with regular expressions. Because &lt;code&gt;$@&lt;/code&gt; is a global variable and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; may be used within object implementations, be careful that analyzing the error object doesn't replace the reference in the global variable. It's easiest to make a local copy of the reference before any manipulations. Here's an example:</source>
          <target state="translated">参照引数を指定して &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; を呼び出すこともできます。これが &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 内にトラップされている場合、 &lt;code&gt;$@&lt;/code&gt; はその参照が含まれます。これにより、例外に関する任意の状態を維持するオブジェクトを使用して、より複雑な例外処理が可能になります。このようなスキームは、 &lt;code&gt;$@&lt;/code&gt; 特定の文字列値を正規表現と照合するよりも好ましい場合があります。ので &lt;code&gt;$@&lt;/code&gt; グローバル変数とある &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; はオブジェクト実装内で使用することができる、エラーオブジェクトの解析はグローバル変数の参照に置き換えられないように注意してください。操作を行う前に、参照のローカルコピーを作成するのが最も簡単です。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="9cdb85fa1e67a62d3e70dba3d5bf1c75c04f7e09" translate="yes" xml:space="preserve">
          <source>You can also call parse_lines() to parse an array of lines or parse_string_document() to parse a document already in memory. As with parse_file(), parse_lines() and parse_string_document() default to sending their output to &lt;code&gt;STDOUT&lt;/code&gt; unless changed with the output_fh() method.</source>
          <target state="translated">parse_lines（）を呼び出して行の配列を解析したり、parse_string_document（）を呼び出してすでにメモリにあるドキュメントを解析したりすることもできます。parse_file（）と同様に、parse_lines（）およびparse_string_document（）は、output_fh（）メソッドで変更しない限り、デフォルトで出力を &lt;code&gt;STDOUT&lt;/code&gt; に送信します。</target>
        </trans-unit>
        <trans-unit id="792416647ce701349df829839ca082b8dd50a041" translate="yes" xml:space="preserve">
          <source>You can also call parse_lines() to parse an array of lines or parse_string_document() to parse a document already in memory. As with parse_file(), parse_lines() and parse_string_document() default to sending their output to &lt;code&gt;STDOUT&lt;/code&gt; unless changed with the output_fh() method. Be aware that parse_lines() and parse_string_document() both expect raw bytes, not decoded characters.</source>
          <target state="translated">parse_lines（）を呼び出して行の配列を解析したり、parse_string_document（）を呼び出してすでにメモリ内にあるドキュメントを解析したりすることもできます。parse_file（）と同様に、parse_lines（）およびparse_string_document（）は、output_fh（）メソッドで変更されない限り、デフォルトで出力を &lt;code&gt;STDOUT&lt;/code&gt; に送信します。parse_lines（）とparse_string_document（）はどちらも、デコードされた文字ではなく、生のバイトを想定していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="61cf53df274337143d282caf711ce10831abe85c" translate="yes" xml:space="preserve">
          <source>You can also chain the calls like this, this first makes a copy and then multiply it by 2:</source>
          <target state="translated">このように呼び出しをチェーン化することもできます。</target>
        </trans-unit>
        <trans-unit id="e57fcafa1ea35942e9edb2cd8f5d66578716838d" translate="yes" xml:space="preserve">
          <source>You can also chain the calls like this, this will make first a copy and then multiply it by 2:</source>
          <target state="translated">このように呼び出しをチェーン化することもできます。</target>
        </trans-unit>
        <trans-unit id="029fcbbc45bf12d25b834057d9395bba7ab192ae" translate="yes" xml:space="preserve">
          <source>You can also change the internal suspects list via &lt;code&gt;set_suspects&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;set_suspects&lt;/code&gt; メソッドを使用して、内部容疑者リストを変更することもできます。</target>
        </trans-unit>
        <trans-unit id="5c5a392365d6b99ba2358d8d79ba87643cdf832d" translate="yes" xml:space="preserve">
          <source>You can also cherry-pick commits from blead and another branch, by using the &lt;code&gt;git cherry-pick&lt;/code&gt; command. It is recommended to use the &lt;b&gt;-x&lt;/b&gt; option to &lt;code&gt;git cherry-pick&lt;/code&gt; in order to record the SHA1 of the original commit in the new commit message.</source>
          <target state="translated">&lt;code&gt;git cherry-pick&lt;/code&gt; コマンドを使用して、bleadおよび別のブランチからコミットをcherry-pickすることもできます。元のコミットのSHA1を新しいコミットメッセージに記録するために、&lt;b&gt;-x&lt;/b&gt;オプションを使用して &lt;code&gt;git cherry-pick&lt;/code&gt; をgitすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="d2a2e4e937f2dcf302981b9beceb35f4afd812bf" translate="yes" xml:space="preserve">
          <source>You can also choose to use rsync to get a copy of the current source tree for the bleadperl branch and all maintenance branches:</source>
          <target state="translated">bleadperl ブランチとすべてのメンテナンスブランチの現在のソースツリーのコピーを取得するために rsync を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="06fef7ffb01d2e70116beb4b064bd4adf57f2910" translate="yes" xml:space="preserve">
          <source>You can also construct an empty set of prereqs with:</source>
          <target state="translated">を使って空の前提条件のセットを構築することもできます。</target>
        </trans-unit>
        <trans-unit id="69913c0f24daf22d2c432ea27b2a49c000488188" translate="yes" xml:space="preserve">
          <source>You can also control the 'hushed' flag at run-time, using the built-in routine vmsish::hushed(). Without argument, it returns the hushed status. Since vmsish::hushed is built-in, you do not need to &quot;use vmsish&quot; to call it.</source>
          <target state="translated">また、組み込みルーチン vmsish::hushed()を使用して、実行時に ' hushed' フラグを制御することもできます。引数なしで、それは hushed 状態を返します。vmsish::hushed は組み込みなので、それを呼び出すために &quot;vmsish を使う&quot; 必要はありません。</target>
        </trans-unit>
        <trans-unit id="563cd6bbc176ecbc734b5b0b439a546964280899" translate="yes" xml:space="preserve">
          <source>You can also control the character encoding and entities. For example, if you're sure that the POD is properly encoded (using the &lt;code&gt;=encoding&lt;/code&gt; command), you can prevent high-bit characters from being encoded as HTML entities and declare the output character set as UTF-8 before parsing, like so:</source>
          <target state="translated">文字エンコーディングとエンティティを制御することもできます。たとえば、（ &lt;code&gt;=encoding&lt;/code&gt; コマンドを使用して）PODが適切にエンコードされていることが確実な場合は、ハイビット文字がHTMLエンティティとしてエンコードされないようにし、解析前に出力文字セットをUTF-8として宣言できます。 ：</target>
        </trans-unit>
        <trans-unit id="ce7cb29295e37cbd29b717e64482225d4d4ba414" translate="yes" xml:space="preserve">
          <source>You can also control the shell that perl uses to run system() and backtick commands via PERL5SHELL. See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">また、perlがsystem（）およびbacktickコマンドを実行するためにPERL5SHELLを介して使用するシェルを制御することもできます。&lt;a href=&quot;perlrun&quot;&gt;perlrunを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4b6274126a67429902f21b4ff102d4a5f157ec82" translate="yes" xml:space="preserve">
          <source>You can also create a circular reference with a single variable:</source>
          <target state="translated">1つの変数で循環参照を作成することもできます。</target>
        </trans-unit>
        <trans-unit id="fe319fa0895a7f47e55075d55fc2289e3b3f2bea" translate="yes" xml:space="preserve">
          <source>You can also do</source>
          <target state="translated">をすることもできます。</target>
        </trans-unit>
        <trans-unit id="9354065d75fb22856af80d6825be0de174fa14aa" translate="yes" xml:space="preserve">
          <source>You can also do the same things with the &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt;モジュールでも同じことができます。</target>
        </trans-unit>
        <trans-unit id="69a5ee6a0a8ad7101d445832b3faf4f8db8fd92c" translate="yes" xml:space="preserve">
          <source>You can also do the same things with the &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt;モジュールでも同じことができます。</target>
        </trans-unit>
        <trans-unit id="efdd9cfab2b6e73dabdc31999bde389ad6e9c40e" translate="yes" xml:space="preserve">
          <source>You can also do the wrapping explicitly by rad2rad(), deg2deg(), and grad2grad().</source>
          <target state="translated">rad2rad()、deg2deg()、grad2grad()で明示的にラッピングを行うこともできます。</target>
        </trans-unit>
        <trans-unit id="e971cca5e90229321a699ea5b197dee6a304b5cb" translate="yes" xml:space="preserve">
          <source>You can also do this directly in the match operator using the &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; sequences. The &lt;code&gt;\Q&lt;/code&gt; tells Perl where to start escaping special characters, and the &lt;code&gt;\E&lt;/code&gt; tells it where to stop (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details).</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; および &lt;code&gt;\E&lt;/code&gt; シーケンスを使用して、一致演算子で直接これを行うこともできます。 &lt;code&gt;\Q&lt;/code&gt; どこの特殊文字をエスケープ開始するPerlを伝え、 &lt;code&gt;\E&lt;/code&gt; （参照どこに停止するように指示&lt;a href=&quot;perlop&quot;&gt;はperlop&lt;/a&gt;詳細）。</target>
        </trans-unit>
        <trans-unit id="5646b0b75475a7d6e7784a71e7f3baa1d3885cbc" translate="yes" xml:space="preserve">
          <source>You can also do this for most systems using the &lt;a href=&quot;Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, which is easier to use and in theory more portable.</source>
          <target state="translated">CPANの&lt;a href=&quot;Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt;モジュールを使用して、ほとんどのシステムでこれを行うこともできます。これは、使いやすく、理論的にはより移植性があります。</target>
        </trans-unit>
        <trans-unit id="fe2d0afbbbfb95dc9ef1705dc46b6eb4a3e77627" translate="yes" xml:space="preserve">
          <source>You can also do this for most systems using the &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN, which is easier to use and in theory more portable.</source>
          <target state="translated">ほとんどのシステムでは、CPANの&lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt;モジュールを使用してこれを行うこともできます。これは、使いやすく、理論的には移植性が高くなります。</target>
        </trans-unit>
        <trans-unit id="f3337ad9bcb6d402cd92e0314d2032a9a8dc4c0a" translate="yes" xml:space="preserve">
          <source>You can also easily say to use all categories but one, by either, for example,</source>
          <target state="translated">また、例えばどちらか一方だけではなく、すべてのカテゴリを使用すると簡単に言うことができます。</target>
        </trans-unit>
        <trans-unit id="317bed7b561a99db6e7463d3bee761b35a18aa16" translate="yes" xml:space="preserve">
          <source>You can also embed newlines directly in your strings, i.e., they can end on a different line than they begin. This is nice, but if you forget your trailing quote, the error will not be reported until Perl finds another line containing the quote character, which may be much further on in the script. Variable substitution inside strings is limited to scalar variables, arrays, and array or hash slices. (In other words, names beginning with $ or @, followed by an optional bracketed expression as a subscript.) The following code segment prints out &quot;The price is $100.&quot;</source>
          <target state="translated">また、文字列の中に直接改行を埋め込むこともできます。これは良いことですが、もし末尾の引用符を忘れてしまった場合、Perl が引用符を含む別の行を見つけるまでエラーは報告されません。文字列内での変数の置換は、スカラ変数、配列、配列またはハッシュスライスに限定されています。(言い換えれば、$または@で始まる名前の後に、オプションで括弧付きの式を添え字として付けることができます)。次のコード・セグメントは、&quot;価格は 100 ドルです&quot; と出力します。</target>
        </trans-unit>
        <trans-unit id="6dc98b973b8e3861953362cf4137bf9098b40a23" translate="yes" xml:space="preserve">
          <source>You can also explicitly indicate that a single handler is meant to be used for all types of referents like so:</source>
          <target state="translated">また、単一のハンドラがすべてのタイプの参照に対して使用されることを明示的に指定することもできます。</target>
        </trans-unit>
        <trans-unit id="cc7d393dae203f89e29915d158bc84c0d091344a" translate="yes" xml:space="preserve">
          <source>You can also explicitly specify the argument number to use for the join string using something like &lt;code&gt;*2$v&lt;/code&gt;; for example:</source>
          <target state="translated">&lt;code&gt;*2$v&lt;/code&gt; ようなものを使用して、結合文字列に使用する引数番号を明示的に指定することもできます。例えば：</target>
        </trans-unit>
        <trans-unit id="3c69b8b0664f8688a90139832b96e7b725fab5ec" translate="yes" xml:space="preserve">
          <source>You can also gain some minuscule measure of efficiency by pre-extending an array that is going to get big. You can also extend an array by assigning to an element that is off the end of the array. You can truncate an array down to nothing by assigning the null list () to it. The following are equivalent:</source>
          <target state="translated">また、大きくなりそうな配列を事前に拡張しておくことで、効率化を図ることもできます。また、配列の端から外れた要素に代入することで配列を拡張することもできます。配列にヌルリスト()を代入することで、配列を何もない状態に切り詰めることができます。以下がこれに相当します。</target>
        </trans-unit>
        <trans-unit id="87f6d7508324248bf5fa6b6a6e4e9d73a898fe92" translate="yes" xml:space="preserve">
          <source>You can also get a pointer to the end of the string stored in the SV with the macro:</source>
          <target state="translated">また、SVに格納されている文字列の末尾へのポインタをマクロで取得することもできます。</target>
        </trans-unit>
        <trans-unit id="5c82629fae7a8fb986a942489f622aa4264ef7c4" translate="yes" xml:space="preserve">
          <source>You can also get differences with a subtraction, which returns a &lt;a href=&quot;Time::Seconds&quot;&gt;Time::Seconds&lt;/a&gt; object:</source>
          <target state="translated">&lt;a href=&quot;Time::Seconds&quot;&gt;Time :: Seconds&lt;/a&gt;オブジェクトを返す減算で差を取得することもできます。</target>
        </trans-unit>
        <trans-unit id="843f7af3e5947338619464418b011d78b7714032" translate="yes" xml:space="preserve">
          <source>You can also get differences with a subtraction, which returns a &lt;a href=&quot;time/seconds&quot;&gt;Time::Seconds&lt;/a&gt; object:</source>
          <target state="translated">&lt;a href=&quot;time/seconds&quot;&gt;Time :: Seconds&lt;/a&gt;オブジェクトを返す減算で差を取得することもできます。</target>
        </trans-unit>
        <trans-unit id="0da6f0ff3f9840990993a84402f300e13eb838e3" translate="yes" xml:space="preserve">
          <source>You can also get into subtle problems on those few operations in Perl that actually do care about the difference between a string and a number, such as the magical &lt;code&gt;++&lt;/code&gt; autoincrement operator or the syscall() function.</source>
          <target state="translated">また、魔法の &lt;code&gt;++&lt;/code&gt; 自動インクリメント演算子やsyscall（）関数など、文字列と数値の違いを実際に考慮しているPerlのいくつかの操作に関する微妙な問題に陥ることもあります。</target>
        </trans-unit>
        <trans-unit id="b13a71a702d5f9f57f9b335ced17d27c5c8c8136" translate="yes" xml:space="preserve">
          <source>You can also get the precision from the next argument using &lt;code&gt;.*&lt;/code&gt;, or from a specified argument (e.g., with &lt;code&gt;.*2$&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;.*&lt;/code&gt; を使用して次の引数から、または指定された引数から（たとえば、 &lt;code&gt;.*2$&lt;/code&gt; ）精度を取得することもできます。</target>
        </trans-unit>
        <trans-unit id="dd7d480332101e4bfe5db6a1d74af4d69d28cfca" translate="yes" xml:space="preserve">
          <source>You can also get the precision from the next argument using &lt;code&gt;.*&lt;/code&gt;:</source>
          <target state="translated">また、使用して次の引数から精度を得ることができます &lt;code&gt;.*&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="31317a51fe6916c8950fb1738da08a3f662e794a" translate="yes" xml:space="preserve">
          <source>You can also go through each element and skip the ones you've seen before. Use a hash to keep track. The first time the loop sees an element, that element has no key in &lt;code&gt;%Seen&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; statement creates the key and immediately uses its value, which is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, so the loop continues to the &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; and increments the value for that key. The next time the loop sees that same element, its key exists in the hash</source>
          <target state="translated">各要素を確認して、前に見た要素をスキップすることもできます。ハッシュを使用して追跡します。ループが初めて要素を検出したとき、その要素には &lt;code&gt;%Seen&lt;/code&gt; にキーがありません。 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; の文は、キーを作成してすぐにある、その値、使用 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ループが続くように、 &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; およびそのキーの値をインクリメントします。次にループが同じ要素を検出すると、そのキーはハッシュに存在します</target>
        </trans-unit>
        <trans-unit id="edcb0c6ef0708a661ee9e625297a07b8efd27958" translate="yes" xml:space="preserve">
          <source>You can also go through each element and skip the ones you've seen before. Use a hash to keep track. The first time the loop sees an element, that element has no key in &lt;code&gt;%Seen&lt;/code&gt;. The &lt;code&gt;next&lt;/code&gt; statement creates the key and immediately uses its value, which is &lt;code&gt;undef&lt;/code&gt;, so the loop continues to the &lt;code&gt;push&lt;/code&gt; and increments the value for that key. The next time the loop sees that same element, its key exists in the hash</source>
          <target state="translated">また、各要素を調べて、前に見た要素をスキップすることもできます。ハッシュを使用して追跡します。ループが最初に要素を検出したとき、その要素は &lt;code&gt;%Seen&lt;/code&gt; にキーを持っていません。 &lt;code&gt;next&lt;/code&gt; の文は、キーを作成してすぐにある、その値、使用 &lt;code&gt;undef&lt;/code&gt; ループが続くように、 &lt;code&gt;push&lt;/code&gt; およびそのキーの値をインクリメントします。次回ループが同じ要素を検出すると、そのキーはハッシュに存在します</target>
        </trans-unit>
        <trans-unit id="dac992fa47e7fcb08307c37ff877628a10c26073" translate="yes" xml:space="preserve">
          <source>You can also import the symbolic &lt;code&gt;S_I*&lt;/code&gt; constants from the &lt;a href=&quot;fcntl&quot;&gt;&lt;code&gt;Fcntl&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;fcntl&quot;&gt; &lt;code&gt;Fcntl&lt;/code&gt; &lt;/a&gt;モジュールからシンボリック &lt;code&gt;S_I*&lt;/code&gt; 定数をインポートすることもできます。</target>
        </trans-unit>
        <trans-unit id="7930ef83d4a331d3e89d11f276bc35572519ad08" translate="yes" xml:space="preserve">
          <source>You can also import the symbolic &lt;code&gt;S_I*&lt;/code&gt; constants from the &lt;code&gt;Fcntl&lt;/code&gt; module:</source>
          <target state="translated">&lt;code&gt;Fcntl&lt;/code&gt; モジュールからシンボリック &lt;code&gt;S_I*&lt;/code&gt; 定数をインポートすることもできます：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
