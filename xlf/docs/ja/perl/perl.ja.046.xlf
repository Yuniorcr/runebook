<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="1ee59fdf448204f1b7cf0a44d5a105acb3af778e" translate="yes" xml:space="preserve">
          <source>Now you can compile Perl. Type:</source>
          <target state="translated">これでPerlをコンパイルできるようになりました。タイプを使用するようになりました。</target>
        </trans-unit>
        <trans-unit id="dc97bf08f7c15142a6f3d523c401171e1e4e28c7" translate="yes" xml:space="preserve">
          <source>Now you can generate the binary distribution. This is done by running the test of the CPAN distribution &lt;code&gt;OS2::SoftInstaller&lt;/code&gt; . Tune up the file</source>
          <target state="translated">これで、バイナリ配布を生成できます。これは、CPANディストリビューション &lt;code&gt;OS2::SoftInstaller&lt;/code&gt; テストを実行することによって行われます。ファイルを調整する</target>
        </trans-unit>
        <trans-unit id="93e496fadabb1e64e6e7d67223c19456b5dbe7c9" translate="yes" xml:space="preserve">
          <source>Now you can generate the binary distribution. This is done by running the test of the CPAN distribution &lt;code&gt;OS2::SoftInstaller&lt;/code&gt;. Tune up the file</source>
          <target state="translated">これで、バイナリ分布を生成できます。これは、CPANディストリビューション &lt;code&gt;OS2::SoftInstaller&lt;/code&gt; テストを実行することによって行われます。ファイルを調整する</target>
        </trans-unit>
        <trans-unit id="b5488e33f64416e81673146fac575b55bb707541" translate="yes" xml:space="preserve">
          <source>Now you can rename the file</source>
          <target state="translated">これでファイル名を</target>
        </trans-unit>
        <trans-unit id="b4dfea4420493c8513c6f853fcbb48064d4dcaa8" translate="yes" xml:space="preserve">
          <source>Now you can start it with the following (SDF) command:</source>
          <target state="translated">これで、以下の(SDF)コマンドで起動できるようになりました。</target>
        </trans-unit>
        <trans-unit id="3fdb47077c25bbc7fd05ea6699ff777a03b6a0b4" translate="yes" xml:space="preserve">
          <source>Now you can switch back to blead locally:</source>
          <target state="translated">これで、ローカルでブリードに戻れるようになりました。</target>
        </trans-unit>
        <trans-unit id="e91ff17e6547bed1e530a38f7ea777276f8d4972" translate="yes" xml:space="preserve">
          <source>Now you can write</source>
          <target state="translated">これで書けるようになりました。</target>
        </trans-unit>
        <trans-unit id="6e8bd31d0e13ce896668841f465f0182170d2759" translate="yes" xml:space="preserve">
          <source>Now you can write to that filehandle using any of &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">これで、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; のいずれかを使用して、そのファイルハンドルに書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="dad49068c95ec062280fac9c3dcad77dc06ce94c" translate="yes" xml:space="preserve">
          <source>Now you can write to that filehandle using any of &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;say&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, or &lt;code&gt;syswrite&lt;/code&gt;.</source>
          <target state="translated">これで、 &lt;code&gt;print&lt;/code&gt; 、 &lt;code&gt;printf&lt;/code&gt; 、 &lt;code&gt;say&lt;/code&gt; 、 &lt;code&gt;write&lt;/code&gt; 、または &lt;code&gt;syswrite&lt;/code&gt; のいずれかを使用してそのファイルハンドルに書き込むことができます。</target>
        </trans-unit>
        <trans-unit id="bdb28492c5cef9c671966ba77fa7de09ce89c81d" translate="yes" xml:space="preserve">
          <source>Now you can.</source>
          <target state="translated">今ならできる</target>
        </trans-unit>
        <trans-unit id="1a87b9f63332f9de75bca22552a19ed7ae7967b2" translate="yes" xml:space="preserve">
          <source>Now you cannot alter &lt;code&gt;$PI&lt;/code&gt; , which is probably a good thing all in all. This isn't the same as a constant subroutine, which is subject to optimization at compile-time. A constant subroutine is one prototyped to take no arguments and to return a constant expression. See &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; for details on these. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; pragma is a convenient shorthand for these.</source>
          <target state="translated">&lt;code&gt;$PI&lt;/code&gt; 変更することはできません。これはおそらく全体としては良いことです。これは、コンパイル時に最適化される定数サブルーチンとは異なります。定数サブルーチンは、引数を取らず、定数式を返すようにプロトタイプ化されたものです。これらの詳細については&lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt;を参照してください。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant&lt;/code&gt; プラグマは、これらのための便利な省略形です。</target>
        </trans-unit>
        <trans-unit id="c97546944079cddc1746ac13882c5e6cfa5ab3f9" translate="yes" xml:space="preserve">
          <source>Now you cannot alter &lt;code&gt;$PI&lt;/code&gt;, which is probably a good thing all in all. This isn't the same as a constant subroutine, which is subject to optimization at compile-time. A constant subroutine is one prototyped to take no arguments and to return a constant expression. See &lt;a href=&quot;perlsub&quot;&gt;perlsub&lt;/a&gt; for details on these. The &lt;code&gt;use constant&lt;/code&gt; pragma is a convenient shorthand for these.</source>
          <target state="translated">これで、 &lt;code&gt;$PI&lt;/code&gt; 変更することはできません。これは、おそらく全体としては良いことです。これは、コンパイル時に最適化される定数サブルーチンと同じではありません。定数サブルーチンは、引数をとらず、定数式を返すようにプロトタイプ化されたサブルーチンです。参照&lt;a href=&quot;perlsub&quot;&gt;はperlsub&lt;/a&gt;これらの詳細については。 &lt;code&gt;use constant&lt;/code&gt; プラグマの使用は、これらの便利な省略形です。</target>
        </trans-unit>
        <trans-unit id="c321db61248ffe9e9cd3c5b03c9c5342de8be25b" translate="yes" xml:space="preserve">
          <source>Now you check whether $is_tiny_prime[$some_number].</source>
          <target state="translated">ここで、$is_tiny_prime[$some_number]かどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="83fe5a64ce5d7ca3309f06409d39b88da08832f7" translate="yes" xml:space="preserve">
          <source>Now you have all the necessary</source>
          <target state="translated">これで、必要なものはすべて揃ったことになります。</target>
        </trans-unit>
        <trans-unit id="8fc27d587ac3ae46eb6cab078485ce4e120d86fc" translate="yes" xml:space="preserve">
          <source>Now you have the entire POD document as one great big parse-tree. You can even use the &lt;b&gt;-expand_seq&lt;/b&gt; option to &lt;b&gt;parse_text&lt;/b&gt; to insert whole different kinds of objects. Just don't expect &lt;b&gt;Pod::Parser&lt;/b&gt; to know what to do with them after that. That will need to be in your code. Or, alternatively, you can insert any object you like so long as it conforms to the &lt;b&gt;Pod::ParseTree&lt;/b&gt; interface.</source>
          <target state="translated">これで、PODドキュメント全体が1つの大きな解析ツリーとして完成しました。あなたも使用することができます&lt;b&gt;-expand_seq&lt;/b&gt;にオプションを&lt;b&gt;parse_text&lt;/b&gt;オブジェクトの全体の異なる種類を挿入します。&lt;b&gt;Pod :: Parser&lt;/b&gt;がその後何をするかを知っていると期待しないでください。それはあなたのコードにある必要があります。または、&lt;b&gt;Pod :: ParseTree&lt;/b&gt;インターフェースに準拠している限り、任意のオブジェクトを挿入できます。</target>
        </trans-unit>
        <trans-unit id="eb427c950b9b31bacabe117fb02e576d6e7f4125" translate="yes" xml:space="preserve">
          <source>Now you may use functions like &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; on that handle. Probably the most common input function is the one that looks like an operator:</source>
          <target state="translated">これで、そのハンドルで &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/getc&quot;&gt;getc&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread&lt;/a&gt;&lt;/code&gt; などの関数を使用できます。おそらく最も一般的な入力関数は、演算子のように見える関数です：</target>
        </trans-unit>
        <trans-unit id="367c47e849864052497095e9f7fa487dd90eceb2" translate="yes" xml:space="preserve">
          <source>Now you may use functions like &lt;code&gt;readline&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;getc&lt;/code&gt;, and &lt;code&gt;sysread&lt;/code&gt; on that handle. Probably the most common input function is the one that looks like an operator:</source>
          <target state="translated">これで、そのハンドルで &lt;code&gt;readline&lt;/code&gt; 、 &lt;code&gt;read&lt;/code&gt; 、 &lt;code&gt;getc&lt;/code&gt; 、 &lt;code&gt;sysread&lt;/code&gt; などの関数を使用できます。おそらく最も一般的な入力関数は、演算子のように見える関数です。</target>
        </trans-unit>
        <trans-unit id="6e6caee9b93719c7443bbaefae78111aa87180e8" translate="yes" xml:space="preserve">
          <source>Now you should be very careful that the outer bracket type is a round one, that is, a parenthesis. That's because you're assigning to an @array, so you need parentheses. If you wanted there</source>
          <target state="translated">ここで注意しなければならないのは、外カッコの型が丸いもの、つまりカッコになっていることです。これは @array に代入しているので、括弧が必要だからです。もしそこに</target>
        </trans-unit>
        <trans-unit id="d66b8a1ad54810e72ec52858762c88f3380e16c6" translate="yes" xml:space="preserve">
          <source>Now you'll see:</source>
          <target state="translated">今にわかるでしょう。</target>
        </trans-unit>
        <trans-unit id="62389bcb5052013362af7bc38fbef11d7810e62d" translate="yes" xml:space="preserve">
          <source>Now you're ready to build:</source>
          <target state="translated">これで構築の準備が整いました。</target>
        </trans-unit>
        <trans-unit id="cb48a5248ec746855c13f0d7ab0feb804820903a" translate="yes" xml:space="preserve">
          <source>Now you're ready to run &lt;code&gt;make&lt;/code&gt; and &lt;code&gt;make test&lt;/code&gt;!</source>
          <target state="translated">今、あなたは実行する準備が整いました &lt;code&gt;make&lt;/code&gt; と &lt;code&gt;make test&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="3894685c626d75138daa573dc3cd4fad72278a40" translate="yes" xml:space="preserve">
          <source>Now your IO would be ASCII on ASCII partitions and EBCDIC on EBCDIC partitions. See the documentation of PerlIO (without &lt;code&gt;Encode::&lt;/code&gt; !) for further possibilities.</source>
          <target state="translated">これで、IOはASCIIパーティションではASCIIになり、EBCDICパーティションではEBCDICになります。さらなる可能性については、PerlIOのドキュメント（ &lt;code&gt;Encode::&lt;/code&gt; なし）を参照してください。</target>
        </trans-unit>
        <trans-unit id="7b95b8f4eb02584fba76319179b45221c640f17c" translate="yes" xml:space="preserve">
          <source>Now your IO would be ASCII on ASCII partitions and EBCDIC on EBCDIC partitions. See the documentation of PerlIO (without &lt;code&gt;Encode::&lt;/code&gt;!) for further possibilities.</source>
          <target state="translated">これで、IOはASCIIパーティションではASCIIになり、EBCDICパーティションではEBCDICになります。さらなる可能性については、PerlIOのドキュメント（ &lt;code&gt;Encode::&lt;/code&gt; なし::！）を参照してください。</target>
        </trans-unit>
        <trans-unit id="4c0c77aa49899b95cf7b7a3e733f8b2e46061080" translate="yes" xml:space="preserve">
          <source>Now!</source>
          <target state="translated">Now!</target>
        </trans-unit>
        <trans-unit id="09be148c7c1b618a5b7b7231898ec72cf009f060" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-h24&lt;/code&gt; will set the option &lt;code&gt;h&lt;/code&gt; to &lt;code&gt;24&lt;/code&gt; , but option bundles like &lt;code&gt;-vxa&lt;/code&gt; and &lt;code&gt;-h24w80&lt;/code&gt; are flagged as errors.</source>
          <target state="translated">ここで、 &lt;code&gt;-h24&lt;/code&gt; はオプション &lt;code&gt;h&lt;/code&gt; を &lt;code&gt;24&lt;/code&gt; に設定しますが、 &lt;code&gt;-vxa&lt;/code&gt; や &lt;code&gt;-h24w80&lt;/code&gt; などのオプションバンドルはエラーとしてフラグが立てられます。</target>
        </trans-unit>
        <trans-unit id="330db949eeb51ae2f426c6b4541a1ffbf72e90be" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-h24&lt;/code&gt; will set the option &lt;code&gt;h&lt;/code&gt; to &lt;code&gt;24&lt;/code&gt;, but option bundles like &lt;code&gt;-vxa&lt;/code&gt; and &lt;code&gt;-h24w80&lt;/code&gt; are flagged as errors.</source>
          <target state="translated">これで、 &lt;code&gt;-h24&lt;/code&gt; はオプション &lt;code&gt;h&lt;/code&gt; を &lt;code&gt;24&lt;/code&gt; に設定しますが、 &lt;code&gt;-vxa&lt;/code&gt; や &lt;code&gt;-h24w80&lt;/code&gt; などのオプションバンドルにはエラーのフラグが付けられます。</target>
        </trans-unit>
        <trans-unit id="7064702c1fdf6342dfeda7047d72edc982aef863" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-vax&lt;/code&gt; will set the option &lt;code&gt;vax&lt;/code&gt; .</source>
          <target state="translated">ここで、 &lt;code&gt;-vax&lt;/code&gt; はオプション &lt;code&gt;vax&lt;/code&gt; を設定します。</target>
        </trans-unit>
        <trans-unit id="3e294ef877a18e50d3cf43096be573f3ba73196e" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;-vax&lt;/code&gt; will set the option &lt;code&gt;vax&lt;/code&gt;.</source>
          <target state="translated">ここで、 &lt;code&gt;-vax&lt;/code&gt; はオプション &lt;code&gt;vax&lt;/code&gt; を設定します。</target>
        </trans-unit>
        <trans-unit id="02476416df4a3a9b63bb6cb2d8be8955b7c384a2" translate="yes" xml:space="preserve">
          <source>Now, as to what you may want to do with these handlers: Maybe you'd want to log what key failed for what class, and then die. Maybe you don't like &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; and instead you want to send the error message to STDOUT (or wherever) and then merely &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">さて、これらのハンドラーで何をしたいのかについては：たぶん、どのクラスでどのキーが失敗したかをログに記録し、それから終了させたいでしょう。たぶん、あなたは &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 好きではなく、代わりにエラーメッセージをSTDOUT（またはどこにでも）に送って、それから単に &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; したいでしょう。</target>
        </trans-unit>
        <trans-unit id="a8c9c99975917c3ed487322ad5c970c3faeddcbc" translate="yes" xml:space="preserve">
          <source>Now, as to what you may want to do with these handlers: Maybe you'd want to log what key failed for what class, and then die. Maybe you don't like &lt;code&gt;die&lt;/code&gt; and instead you want to send the error message to STDOUT (or wherever) and then merely &lt;code&gt;exit()&lt;/code&gt;.</source>
          <target state="translated">さて、これらのハンドラーで何をしたいかについて：たぶん、どのキーがどのクラスで失敗したかをログに記録して、その後死ぬことを望むでしょう。たぶん、あなたは &lt;code&gt;die&lt;/code&gt; 好きではなく、代わりにエラーメッセージをSTDOUT（またはどこでも）に送信してから単に &lt;code&gt;exit()&lt;/code&gt; したいと思うでしょう。</target>
        </trans-unit>
        <trans-unit id="dd735cb44e720407db2d25db6e1b3a8402f3fbeb" translate="yes" xml:space="preserve">
          <source>Now, because the top level contains only references, if you try to print out your array in with a simple print() function, you'll get something that doesn't look very nice, like this:</source>
          <target state="translated">トップレベルには参照しか含まれていないので、単純な print()関数で配列をプリントアウトしようとすると、以下のような見栄えの悪いものが出てきます。</target>
        </trans-unit>
        <trans-unit id="7f590569b440fce72262993e0bb83b771d091b6a" translate="yes" xml:space="preserve">
          <source>Now, consider this:</source>
          <target state="translated">さて、考えてみてください。</target>
        </trans-unit>
        <trans-unit id="d7ffbca375f24628b0da0f697f3844b6c5775889" translate="yes" xml:space="preserve">
          <source>Now, create a fork on GitHub to push your branch to, and add it as a remote if you haven't already, as described in the GitHub documentation at &lt;a href=&quot;https://help.github.com/en/articles/working-with-forks&quot;&gt;https://help.github.com/en/articles/working-with-forks&lt;/a&gt;:</source>
          <target state="translated">次に、GitHubにフォークを作成してブランチをプッシュし、まだ行っていない場合はリモートとして追加します。これについては、&lt;a href=&quot;https://help.github.com/en/articles/working-with-forks&quot;&gt;https：&lt;/a&gt; //help.github.com/en/articles/working-withのGitHubドキュメントで説明されています。 -フォーク：</target>
        </trans-unit>
        <trans-unit id="0caa48ba5eb7d274e599b06285edb5dacdee51ca" translate="yes" xml:space="preserve">
          <source>Now, even &lt;code&gt;[0-9]&lt;/code&gt; can be a bother to write multiple times, so in the interest of saving keystrokes and making regexps more readable, Perl has several abbreviations for common character classes, as shown below. Since the introduction of Unicode, unless the &lt;code&gt;//a&lt;/code&gt; modifier is in effect, these character classes match more than just a few characters in the ASCII range.</source>
          <target state="translated">さて、 &lt;code&gt;[0-9]&lt;/code&gt; でも何度も書くのは面倒なので、キーストロークを保存して正規表現を読みやすくするために、Perlには以下に示すように、一般的な文字クラスのいくつかの略語があります。Unicodeの導入以来、 &lt;code&gt;//a&lt;/code&gt; 修飾子が有効になっていない限り、これらの文字クラスはASCII範囲内のいくつかの文字以上のものと一致します。</target>
        </trans-unit>
        <trans-unit id="e2eacdfa4a021a03b4f7ed6c8878ca3eccdafc77" translate="yes" xml:space="preserve">
          <source>Now, even &lt;code&gt;[0-9]&lt;/code&gt; can be a bother to write multiple times, so in the interest of saving keystrokes and making regexps more readable, Perl has several abbreviations for common character classes, as shown below. Since the introduction of Unicode, unless the &lt;code&gt;/a&lt;/code&gt; modifier is in effect, these character classes match more than just a few characters in the ASCII range.</source>
          <target state="translated">さて、 &lt;code&gt;[0-9]&lt;/code&gt; でさえ何度も書くのが面倒になる可能性があるので、キーストロークを保存して正規表現を読みやすくするために、Perlには以下に示すように一般的な文字クラスのいくつかの略語があります。Unicodeの導入以降、 &lt;code&gt;/a&lt;/code&gt; 修飾子が有効になっていない限り、これらの文字クラスはASCII範囲の数文字以上に一致します。</target>
        </trans-unit>
        <trans-unit id="fd3c643f4f95c9c07182bc1371cc9ce99bbbace4" translate="yes" xml:space="preserve">
          <source>Now, if &lt;code&gt;junk&lt;/code&gt; is the same as the string we're trying to add, we can grab the string directly from the SV; &lt;code&gt;SvPVX&lt;/code&gt; is the address of the PV in the SV.</source>
          <target state="translated">これで、 &lt;code&gt;junk&lt;/code&gt; が追加しようとしている文字列と同じ場合、SVから直接文字列を取得できます。 &lt;code&gt;SvPVX&lt;/code&gt; は、SV内のPVのアドレスです。</target>
        </trans-unit>
        <trans-unit id="22a7c67c64c0df3c947439ef09bc7a1a5018552e" translate="yes" xml:space="preserve">
          <source>Now, imagine that we want to pack the data for a machine with a different byte-order. First, we'll have to figure out how big the data types on the target machine really are. Let's assume that the longs are 32 bits wide and the shorts are 16 bits wide. You can then rewrite the template as:</source>
          <target state="translated">さて、異なるバイトオーダーのマシン用のデータをパックしたいと想像してみましょう。まず、ターゲットマシンのデータタイプが実際にどのくらいの大きさなのかを把握する必要があります。ここでは、ロングが32ビット幅、ショートが16ビット幅だとします。そして、テンプレートを次のように書き換えます。</target>
        </trans-unit>
        <trans-unit id="5e966fc4eb896c9493f50919b32baf5ee748e75c" translate="yes" xml:space="preserve">
          <source>Now, inside of the &lt;code&gt;WriteMakeFile()&lt;/code&gt; function in your</source>
          <target state="translated">さて、あなたの &lt;code&gt;WriteMakeFile()&lt;/code&gt; 関数の内部</target>
        </trans-unit>
        <trans-unit id="c4997e53db961cf2c8c2533b9ab14d20123173fb" translate="yes" xml:space="preserve">
          <source>Now, let's extend the previous example to return both the sum of the parameters and the difference.</source>
          <target state="translated">では、先ほどの例を拡張して、パラメータの合計と差分の両方を返すようにしてみましょう。</target>
        </trans-unit>
        <trans-unit id="ac0e50de65e6792eafd44dfb3d472e96b20f9034" translate="yes" xml:space="preserve">
          <source>Now, quite a few people have the Acme Transmogrifier, and you've had to write something to talk the protocol from scratch - you'd almost certainly want to make that into a module. The level at which you pitch it is up to you: you might want protocol-level modules analogous to &lt;a href=&quot;Net::SMTP&quot;&gt;Net::SMTP&lt;/a&gt; which then talk to higher level modules analogous to &lt;a href=&quot;Mail::Send&quot;&gt;Mail::Send&lt;/a&gt;. The choice is yours, but you do want to get a module out for that server protocol.</source>
          <target state="translated">現在、かなりの数の人々がAcme Transmogrifierを持っており、プロトコルを最初から話すために何かを書かなければなりませんでした。ほぼ間違いなく、それをモジュールにしたいと思うでしょう。提案するレベルはあなた次第です。Net &lt;a href=&quot;Net::SMTP&quot;&gt;:: SMTPに&lt;/a&gt;類似したプロトコルレベルのモジュールが必要な場合があります。このモジュールは、&lt;a href=&quot;Mail::Send&quot;&gt;Mail :: Sendに&lt;/a&gt;類似したより高いレベルのモジュールと通信します。選択はあなた次第ですが、そのサーバープロトコル用のモジュールを入手したいのです。</target>
        </trans-unit>
        <trans-unit id="8f4d4098c9d3e30a9e536d0fed12c873a45201c2" translate="yes" xml:space="preserve">
          <source>Now, quite a few people have the Acme Transmogrifier, and you've had to write something to talk the protocol from scratch - you'd almost certainly want to make that into a module. The level at which you pitch it is up to you: you might want protocol-level modules analogous to &lt;a href=&quot;net/smtp&quot;&gt;Net::SMTP&lt;/a&gt; which then talk to higher level modules analogous to &lt;a href=&quot;http://search.cpan.org/perldoc/Mail::Send&quot;&gt;Mail::Send&lt;/a&gt;. The choice is yours, but you do want to get a module out for that server protocol.</source>
          <target state="translated">さて、かなりの数の人々がAcme Transmogrifierを持っていて、プロトコルを最初から話すために何かを書かなければなりませんでした-あなたはほぼ確実にそれをモジュールにしたいと思うでしょう。提案するレベルはあなた次第です。Net &lt;a href=&quot;net/smtp&quot;&gt;:: SMTPに&lt;/a&gt;類似したプロトコルレベルのモジュールが必要になる場合があり、次に&lt;a href=&quot;http://search.cpan.org/perldoc/Mail::Send&quot;&gt;Mail :: Sendに&lt;/a&gt;類似したより高いレベルのモジュールと通信します。選択はあなた次第ですが、そのサーバープロトコル用のモジュールを取得したいのです。</target>
        </trans-unit>
        <trans-unit id="f84215108517a61b97d5bb763774a7b31e4947af" translate="yes" xml:space="preserve">
          <source>Now, right after you've just written the above lines, you'd normally have to go open the file ThisProject/I18N/en.pm, and immediately add an entry:</source>
          <target state="translated">さて、上記の行を書いた直後に、通常はThisProject/I18N/en.pmというファイルを開いて、すぐにエントリを追加しなければなりません。</target>
        </trans-unit>
        <trans-unit id="1401c823810e265e57226845c8cc3ee51b8e87e5" translate="yes" xml:space="preserve">
          <source>Now, running make will produce output that looks something like this (some long lines have been shortened for clarity and some extraneous lines have been deleted):</source>
          <target state="translated">さて、make を実行すると、以下のような出力が得られます (長い行はわかりやすくするために短縮され、余計な行は削除されています)。</target>
        </trans-unit>
        <trans-unit id="6e07caa5beb0db9ce775e3579183bc779cf639f4" translate="yes" xml:space="preserve">
          <source>Now, say you want to search for the single character &lt;code&gt;/GX/&lt;/code&gt; . Perl doesn't know about Martian, so it'll find the two bytes &quot;GX&quot; in the &quot;I am CVSGXX!&quot; string, even though that character isn't there: it just looks like it is because &quot;SG&quot; is next to &quot;XX&quot;, but there's no real &quot;GX&quot;. This is a big problem.</source>
          <target state="translated">ここで、1文字 &lt;code&gt;/GX/&lt;/code&gt; を検索するとします。Perlは火星について知らないので、「I am CVSGXX！」で2バイトの「GX」を見つけます。文字列はありませんが、その文字はありません。 &quot;SG&quot;が &quot;XX&quot;の隣にあるために見えますが、実際の &quot;GX&quot;はありません。これは大きな問題です。</target>
        </trans-unit>
        <trans-unit id="3510dbe78a5971908a5d18e000554027edb2cb1f" translate="yes" xml:space="preserve">
          <source>Now, say you want to search for the single character &lt;code&gt;/GX/&lt;/code&gt;. Perl doesn't know about Martian, so it'll find the two bytes &quot;GX&quot; in the &quot;I am CVSGXX!&quot; string, even though that character isn't there: it just looks like it is because &quot;SG&quot; is next to &quot;XX&quot;, but there's no real &quot;GX&quot;. This is a big problem.</source>
          <target state="translated">ここで、単一の文字 &lt;code&gt;/GX/&lt;/code&gt; を検索するとします。 Perlは火星について知らないので、「私はCVSGXXです！」の2バイトの「GX」を見つけます。文字列、その文字はありませんが、「SG」が「XX」の隣にあるためと思われますが、実際の「GX」はありません。これは大きな問題です。</target>
        </trans-unit>
        <trans-unit id="8bf6d464fd8f7b3ee530f1f0a89b5dfa201b3c0c" translate="yes" xml:space="preserve">
          <source>Now, suppose you want to use perlio layers in your XS. We'll use the perlio &lt;code&gt;PerlIO_puts()&lt;/code&gt; function as an example.</source>
          <target state="translated">ここで、XSでperlioレイヤーを使用するとします。例としてperlio &lt;code&gt;PerlIO_puts()&lt;/code&gt; 関数を使用します。</target>
        </trans-unit>
        <trans-unit id="8e40eda745c5999056a9033823cfa2202510fb44" translate="yes" xml:space="preserve">
          <source>Now, that's our data parsed. I suppose what we might want to do now is total up our income and expenditure, and add another line to the end of our ledger - in the same format - saying how much we've brought in and how much we've spent:</source>
          <target state="translated">これでデータが解析されました。今、何をしたいかというと、収入と支出を合計して、元帳の最後に別の行を追加して、同じフォーマットで、いくら持ち込んだか、いくら使ったか、ということです。</target>
        </trans-unit>
        <trans-unit id="b6104104e2da85f59a70d3eb8135a126533dc183" translate="yes" xml:space="preserve">
          <source>Now, the Russian quant method here is responsible not only for implementing the strange logic necessary for figuring out how Russian number-phrases impose case and number on their noun-phrases, but also for inflecting the Russian word for &quot;directory&quot;. How that inflection is to be carried out is no small issue, and among the solutions I've seen, some (like variations on a simple lookup in a hash where all possible forms are provided for all necessary words) are straightforward but</source>
          <target state="translated">さて、ここでのロシア語のクオンツメソッドは、ロシア語の数詞がどのようにして名詞句に大文字と小文字を課すのかを解明するために必要な奇妙な論理を実装するだけでなく、ロシア語の「ディレクトリ」という単語を屈折させることにも責任を持っています。この屈折をどのように行うかは小さな問題ではなく、私が見てきた解決策の中には、(ハッシュ内の単純な検索のバリエーションのように、すべての必要な単語に対してすべての可能な形が提供されています)簡単ですが、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="fcbc9f96a1673b30ff5469c8a5fcf6cbd912ecbd" translate="yes" xml:space="preserve">
          <source>Now, the following calls to your function are all completely equivalent:</source>
          <target state="translated">さて、次の関数の呼び出しはすべて完全に等価です。</target>
        </trans-unit>
        <trans-unit id="cfc8866cddcad33148adff8ad6715f9f23dc807f" translate="yes" xml:space="preserve">
          <source>Now, there's no particularly obvious way to store anything but strings in a gettext lexicon; so it looks like we just have to start over and make something better, from scratch. I call my shot at a gettext-replacement system &quot;Maketext&quot;, or, in CPAN terms, Locale::Maketext.</source>
          <target state="translated">さて、gettext レキシコンに文字列以外のものを格納する明白な方法はありません。私は、gettext の置換システムを &quot;Maketext&quot;、CPAN の用語では Locale::Maketext と呼んでいます。</target>
        </trans-unit>
        <trans-unit id="54e7adec8d59750fec2768d3623709e37ef7d868" translate="yes" xml:space="preserve">
          <source>Now, using &lt;code&gt;--verbose&lt;/code&gt; on the command line will enable &lt;code&gt;$verbose&lt;/code&gt; , as expected. But it is also allowed to use &lt;code&gt;--noverbose&lt;/code&gt; , which will disable &lt;code&gt;$verbose&lt;/code&gt; by setting its value to &lt;code&gt;0&lt;/code&gt; . Using a suitable default value, the program can find out whether &lt;code&gt;$verbose&lt;/code&gt; is false by default, or disabled by using &lt;code&gt;--noverbose&lt;/code&gt; .</source>
          <target state="translated">コマンドラインで &lt;code&gt;--verbose&lt;/code&gt; を使用すると、期待どおりに &lt;code&gt;$verbose&lt;/code&gt; が有効になります。ただし、値を &lt;code&gt;0&lt;/code&gt; に設定して &lt;code&gt;$verbose&lt;/code&gt; を無効にする &lt;code&gt;--noverbose&lt;/code&gt; を使用することもできます。プログラムは、適切なデフォルト値を使用して、 &lt;code&gt;$verbose&lt;/code&gt; がデフォルトでfalseであるか、または &lt;code&gt;--noverbose&lt;/code&gt; を使用して無効であるかを確認できます。</target>
        </trans-unit>
        <trans-unit id="d0e3286afdf8a8f15ad325a81b0628c314540334" translate="yes" xml:space="preserve">
          <source>Now, using &lt;code&gt;--verbose&lt;/code&gt; on the command line will enable &lt;code&gt;$verbose&lt;/code&gt;, as expected. But it is also allowed to use &lt;code&gt;--noverbose&lt;/code&gt;, which will disable &lt;code&gt;$verbose&lt;/code&gt; by setting its value to &lt;code&gt;0&lt;/code&gt;. Using a suitable default value, the program can find out whether &lt;code&gt;$verbose&lt;/code&gt; is false by default, or disabled by using &lt;code&gt;--noverbose&lt;/code&gt;.</source>
          <target state="translated">これで、コマンドラインで &lt;code&gt;--verbose&lt;/code&gt; を使用すると、期待どおりに &lt;code&gt;$verbose&lt;/code&gt; が有効になります。ただし、 &lt;code&gt;--noverbose&lt;/code&gt; を使用することもできます。これにより、値を &lt;code&gt;0&lt;/code&gt; に設定して &lt;code&gt;$verbose&lt;/code&gt; を無効にします。プログラムは、適切なデフォルト値を使用して、 &lt;code&gt;$verbose&lt;/code&gt; がデフォルトでfalseであるか、 &lt;code&gt;--noverbose&lt;/code&gt; を使用して無効になっているかを確認できます。</target>
        </trans-unit>
        <trans-unit id="992feec99ff4aecbf2aadccfe96942e35ec305c6" translate="yes" xml:space="preserve">
          <source>Now, we know that in scalar context, &lt;code&gt;$time =~ /(\d\d):(\d\d):(\d\d)/&lt;/code&gt; returns a true or false value. In list context, however, it returns the list of matched values &lt;code&gt;($1,$2,$3)&lt;/code&gt; . So we could write the code more compactly as</source>
          <target state="translated">これで、スカラーコンテキストでは、 &lt;code&gt;$time =~ /(\d\d):(\d\d):(\d\d)/&lt;/code&gt; がtrueまたはfalseの値を返すことがわかりました。ただし、リストのコンテキストでは、一致した値のリスト &lt;code&gt;($1,$2,$3)&lt;/code&gt; 返します。したがって、次のようにコードをよりコンパクトに書くことができます。</target>
        </trans-unit>
        <trans-unit id="c881bffc946b525469a86f23ed507e231ad46769" translate="yes" xml:space="preserve">
          <source>Now, we know that in scalar context, &lt;code&gt;$time =~ /(\d\d):(\d\d):(\d\d)/&lt;/code&gt; returns a true or false value. In list context, however, it returns the list of matched values &lt;code&gt;($1,$2,$3)&lt;/code&gt;. So we could write the code more compactly as</source>
          <target state="translated">これで、スカラーコンテキストでは、 &lt;code&gt;$time =~ /(\d\d):(\d\d):(\d\d)/&lt;/code&gt; がtrueまたはfalseの値を返すことがわかりました。ただし、リストコンテキストでは、一致した値のリスト &lt;code&gt;($1,$2,$3)&lt;/code&gt; が返されます。したがって、コードをよりコンパクトに書くことができます。</target>
        </trans-unit>
        <trans-unit id="9cf36e6267baebdc3ed4fd5c4c6b178499170bce" translate="yes" xml:space="preserve">
          <source>Now, what if you don't want to capitalize that &quot;and&quot;? Just use &lt;a href=&quot;Text::Autoformat&quot;&gt;Text::Autoformat&lt;/a&gt; and get on with the next problem. :)</source>
          <target state="translated">では、その「and」を大文字にしたくない場合はどうでしょうか。&lt;a href=&quot;Text::Autoformat&quot;&gt;Text :: Autoformat&lt;/a&gt;を使用して、次の問題に取り掛かるだけです。:)</target>
        </trans-unit>
        <trans-unit id="4be0b7f8c6b8fc26bdc74884bb876598542c7964" translate="yes" xml:space="preserve">
          <source>Now, what if you don't want to capitalize that &quot;and&quot;? Just use &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text::Autoformat&lt;/a&gt; and get on with the next problem. :)</source>
          <target state="translated">では、「and」を大文字にしたくない場合はどうでしょうか。&lt;a href=&quot;http://search.cpan.org/perldoc/Text::Autoformat&quot;&gt;Text :: Autoformat&lt;/a&gt;を使用して、次の問題に取り掛かるだけです。:)</target>
        </trans-unit>
        <trans-unit id="8949eed359cb576e341a415acaa483f999c583a5" translate="yes" xml:space="preserve">
          <source>Now, what we've done here is to launch the built-in perl debugger on our script. It's stopped at the first line of executable code and is waiting for input.</source>
          <target state="translated">さて、ここで何をしたかというと、スクリプトに組み込まれたPerlデバッガを起動することです。これは実行コードの最初の行で停止し、入力を待っています。</target>
        </trans-unit>
        <trans-unit id="fe56adc9244a6c6d673f2a408e82ab0b02f6ba4d" translate="yes" xml:space="preserve">
          <source>Now, what's this about?</source>
          <target state="translated">さて、これは何のことでしょうか?</target>
        </trans-unit>
        <trans-unit id="c09652f2cdfd968ba019444826ddffee8c37ace4" translate="yes" xml:space="preserve">
          <source>Null AV pointer.</source>
          <target state="translated">ヌル AV ポインタ。</target>
        </trans-unit>
        <trans-unit id="449c4d119d699360473af11bb566b4e5b4167f76" translate="yes" xml:space="preserve">
          <source>Null CV pointer.</source>
          <target state="translated">CV ポインタは NULL です.</target>
        </trans-unit>
        <trans-unit id="91a48ce7cb8839ea533848a64134cf5805e52ca4" translate="yes" xml:space="preserve">
          <source>Null HV pointer.</source>
          <target state="translated">ヌル HV ポインタ。</target>
        </trans-unit>
        <trans-unit id="d7c8d520f057dea587bf4d58fd9c051240f622ed" translate="yes" xml:space="preserve">
          <source>Null SV pointer. (No longer available when &lt;code&gt;PERL_CORE&lt;/code&gt; is defined.)</source>
          <target state="translated">ヌルSVポインター。（ &lt;code&gt;PERL_CORE&lt;/code&gt; が定義されている場合は使用できなくなります。）</target>
        </trans-unit>
        <trans-unit id="ae2f5f2d47b6cb2ea376cf5cd766fe09fd6a57af" translate="yes" xml:space="preserve">
          <source>Null character pointer. (No longer available when &lt;code&gt;PERL_CORE&lt;/code&gt; is defined.)</source>
          <target state="translated">ヌル文字ポインター。（ &lt;code&gt;PERL_CORE&lt;/code&gt; が定義されている場合は使用できなくなります。）</target>
        </trans-unit>
        <trans-unit id="ebc5c9f306915d4135b8053056b0178c088e8651" translate="yes" xml:space="preserve">
          <source>Null picture in formline</source>
          <target state="translated">フォームラインのヌル画像</target>
        </trans-unit>
        <trans-unit id="fa4bd9c62d3ecb53b530fd1a90e4da66bcf3402d" translate="yes" xml:space="preserve">
          <source>Null realloc</source>
          <target state="translated">ヌル再割当</target>
        </trans-unit>
        <trans-unit id="1ebe00d5eb5dc6465abbd73f1052105fa12c1088" translate="yes" xml:space="preserve">
          <source>Nullav</source>
          <target state="translated">Nullav</target>
        </trans-unit>
        <trans-unit id="0f70fd3842939caf1b28e5e61343267fb7df7093" translate="yes" xml:space="preserve">
          <source>Nullch</source>
          <target state="translated">Nullch</target>
        </trans-unit>
        <trans-unit id="32ecb682e3f060838162e9bbbbf1d860a0d1dca5" translate="yes" xml:space="preserve">
          <source>Nullcv</source>
          <target state="translated">Nullcv</target>
        </trans-unit>
        <trans-unit id="e547450e00d976847c97a5b3855e227ed6ee122c" translate="yes" xml:space="preserve">
          <source>Nullhv</source>
          <target state="translated">Nullhv</target>
        </trans-unit>
        <trans-unit id="38b0ef271640da14cdf67cd20db21125619c6b53" translate="yes" xml:space="preserve">
          <source>Nullops appear as &lt;code&gt;ex-opname&lt;/code&gt; , where</source>
          <target state="translated">ヌロップは &lt;code&gt;ex-opname&lt;/code&gt; として表示されます。</target>
        </trans-unit>
        <trans-unit id="f59d50c5f13fde39f97b92afad489b0c203d91e4" translate="yes" xml:space="preserve">
          <source>Nullops appear as &lt;code&gt;ex-opname&lt;/code&gt;, where</source>
          <target state="translated">Nullopsは &lt;code&gt;ex-opname&lt;/code&gt; として表示されます。</target>
        </trans-unit>
        <trans-unit id="c35c3cf48b244deeb77cbf7fb2d31febc3616e04" translate="yes" xml:space="preserve">
          <source>Nullsv</source>
          <target state="translated">Nullsv</target>
        </trans-unit>
        <trans-unit id="c9d82135ee15642aa7ae8817dc570334ab80622b" translate="yes" xml:space="preserve">
          <source>Number of iterations run.</source>
          <target state="translated">実行された反復回数。</target>
        </trans-unit>
        <trans-unit id="78e655a3cb9b2e5174023b5b4b515e74ae0fcc89" translate="yes" xml:space="preserve">
          <source>Number of lines to save?</source>
          <target state="translated">保存する行数は?</target>
        </trans-unit>
        <trans-unit id="39678ab676a3f472a8537a68ada508040f950313" translate="yes" xml:space="preserve">
          <source>Number of significant digits. Leading zeros are not counted. A number may have an accuracy greater than the non-zero digits when there are zeros in it or trailing zeros. For example, 123.456 has A of 6, 10203 has 5, 123.0506 has 7, 123.45000 has 8 and 0.000123 has 3.</source>
          <target state="translated">有効桁数。先頭のゼロはカウントされません。数字の中にゼロが含まれている場合や、末尾にゼロが含まれている場合は、ゼロ以外の桁数よりも精度が高くなることがあります。例えば、123.456はAが6、10203は5、123.0506は7、123.45000は8、0.000123は3です。</target>
        </trans-unit>
        <trans-unit id="3230c13d5bd80dac7aacde117d72a74866ed2d4e" translate="yes" xml:space="preserve">
          <source>Number of significant digits. Leading zeros are not counted. A number may have an accuracy greater than the non-zero digits when there are zeros in it or trailing zeros. For example, 123.456 has A of 6, 10203 has 5, 123.0506 has 7, 123.450000 has 8 and 0.000123 has 3.</source>
          <target state="translated">有効桁数。先頭のゼロはカウントされません。数字の中にゼロが含まれている場合や、末尾にゼロが含まれている場合は、ゼロ以外の桁数よりも精度が高くなることがあります。例えば、123.456はAが6、10203は5、123.0506は7、123.450000は8、0.000123は3です。</target>
        </trans-unit>
        <trans-unit id="c5aadd077767ce8ba345b0317eb500c0c374d288" translate="yes" xml:space="preserve">
          <source>Number too long</source>
          <target state="translated">数字が長すぎる</target>
        </trans-unit>
        <trans-unit id="aaa074fe25a6265136343f6af71868d2eb3ffdf5" translate="yes" xml:space="preserve">
          <source>Number with no digits</source>
          <target state="translated">桁のない数字</target>
        </trans-unit>
        <trans-unit id="6588ae11e1dcdc853623ae99d37042a891fc6f6e" translate="yes" xml:space="preserve">
          <source>Number-of-uses is stored as a 16-bit unsigned integer, so can't exceed 65535.</source>
          <target state="translated">使用数は16ビットの符号なし整数として格納され、65535を超えることはできません。</target>
        </trans-unit>
        <trans-unit id="86074e1eaaba5bdf1182fbfd1a5e5a087cf06d78" translate="yes" xml:space="preserve">
          <source>Numbered capture callbacks</source>
          <target state="translated">番号付きキャプチャコールバック</target>
        </trans-unit>
        <trans-unit id="2f3ef08b1556d451a2f171bcd8cc5fa9d0a67578" translate="yes" xml:space="preserve">
          <source>Numbers containing a fractional or exponential part will always be represented as numeric (floating point) values, possibly at a loss of precision (in which case you might lose perfect roundtripping ability, but the JSON number will still be re-encoded as a JSON number).</source>
          <target state="translated">分数や指数の部分を含む数値は、常に数値 (浮動小数点)として表現されますが、精度を失う可能性があります (その場合、完全なラウンドトリップ機能は失われるかもしれませんが、JSON 番号は JSON 番号として再エンコードされます)。</target>
        </trans-unit>
        <trans-unit id="7a23d9255bf80cf55daa9a73c5c3503075a5fb9f" translate="yes" xml:space="preserve">
          <source>Numbers don't need quotes around them:</source>
          <target state="translated">数字の周りに引用符は必要ない</target>
        </trans-unit>
        <trans-unit id="93fc21b9cdd7d3eceb58c305ecfc300113f08a16" translate="yes" xml:space="preserve">
          <source>Numbers endianness and Width</source>
          <target state="translated">数字の端数と幅</target>
        </trans-unit>
        <trans-unit id="a356a38fbf19c9a7a85fc1034cb6b13b5959c015" translate="yes" xml:space="preserve">
          <source>Numbers in (parentheses) indicate the total number of Unicode code points matched by the property. For emphasis, those properties that match no code points at all are listed as well in a separate section following the table.</source>
          <target state="translated">内の数字 (カッコ内)は、 そのプ ロ パテ ィ に よ っ て一致す る Unicode コ ー ド ポ イ ン ト の総数を示 し ています。強調のため、 コ ー ド ポ イ ン ト が全く一致 し ないプ ロ パテ ィ も 表の後の別のセ ク シ ョ ンに挙げています。</target>
        </trans-unit>
        <trans-unit id="34ed490a2fac8e8118b8b1dcb98a2f46ca2806fc" translate="yes" xml:space="preserve">
          <source>Numbers in (parentheses) indicate the total number of Unicode code points matched by the property. For the entries that give the longest, most descriptive version of the property, the count is followed by a list of some of the code points matched by it. The list includes all the matched characters in the 0-255 range, enclosed in the familiar [brackets] the same as a regular expression bracketed character class. Following that, the next few higher matching ranges are also given. To avoid visual ambiguity, the SPACE character is represented as &lt;code&gt;\x20&lt;/code&gt;.</source>
          <target state="translated">（括弧内の）数字は、プロパティに一致するUnicodeコードポイントの総数を示します。プロパティの最も長く、最も説明的なバージョンを提供するエントリの場合、カウントの後に、それに一致するいくつかのコードポイントのリストが続きます。このリストには、0〜255の範囲で一致するすべての文字が含まれ、正規表現で囲まれた文字クラスと同じように、使い慣れた[括弧]で囲まれています。その後、次のいくつかのより高い一致範囲も示されます。視覚的なあいまいさを避けるために、スペース文字は &lt;code&gt;\x20&lt;/code&gt; として表されます。</target>
        </trans-unit>
        <trans-unit id="56e0145e1d23363006c456eb88791d281e2a1493" translate="yes" xml:space="preserve">
          <source>Numbers in the range 160-255 refer to Latin-1 characters (also defined there by Unicode, with the same meaning). Numbers above 255 should be understood to refer to Unicode characters.</source>
          <target state="translated">160 ~ 255 の範囲の数字は、 Latin-1 キ ャ ラ ク タ (Unicode で定義 さ れてお り 、 同じ意味を持ち ます)を参照 し ています。255 以上の数字は Unicode キ ャ ラ ク タ を参照 し てい る と 理解す る べ き です。</target>
        </trans-unit>
        <trans-unit id="bdfe233d649ccb45ebc573d4ee247d96a2053e8c" translate="yes" xml:space="preserve">
          <source>Numeric Fields</source>
          <target state="translated">数値フィールド</target>
        </trans-unit>
        <trans-unit id="8c7c98efa8c2ec06026f0650448ebfec04745d0d" translate="yes" xml:space="preserve">
          <source>Numeric comparison</source>
          <target state="translated">数値比較</target>
        </trans-unit>
        <trans-unit id="6101250ca1afcc59baf36ca28be6209c3291e540" translate="yes" xml:space="preserve">
          <source>Numeric conversion</source>
          <target state="translated">数値変換</target>
        </trans-unit>
        <trans-unit id="c721f5217c35d940494ce8935e78185eea92c32c" translate="yes" xml:space="preserve">
          <source>Numeric format result too large</source>
          <target state="translated">数値形式の結果が大きすぎる</target>
        </trans-unit>
        <trans-unit id="231f4ec720e19f9416599261f4322593a7b1d213" translate="yes" xml:space="preserve">
          <source>Numeric functions</source>
          <target state="translated">数値関数</target>
        </trans-unit>
        <trans-unit id="684a5952f400383c4099f6088a711c758da11a61" translate="yes" xml:space="preserve">
          <source>Numeric literals are specified in any of the following floating point or integer formats:</source>
          <target state="translated">数値リテラルは、以下の浮動小数点または整数形式のいずれかで指定されます。</target>
        </trans-unit>
        <trans-unit id="a4e50290598ea70f1c5580bbcbcb1b35364e36b2" translate="yes" xml:space="preserve">
          <source>Numeric operators and numeric conversions</source>
          <target state="translated">数値演算子と数値変換</target>
        </trans-unit>
        <trans-unit id="44e5694a92fbb0b839eb3d472cdd4e3a72b88c8c" translate="yes" xml:space="preserve">
          <source>Numeric variables with more than one digit may not start with '0'</source>
          <target state="translated">1 桁以上の数値変数は '0' で始まらない場合があります。</target>
        </trans-unit>
        <trans-unit id="d4d013232ca01b901c06ddf5aa9483529f278d91" translate="yes" xml:space="preserve">
          <source>Numeric_Value</source>
          <target state="translated">Numeric_Value</target>
        </trans-unit>
        <trans-unit id="0524b0c0ac8bde27b90181fe29d1e0ee87d85606" translate="yes" xml:space="preserve">
          <source>Numification</source>
          <target state="translated">Numification</target>
        </trans-unit>
        <trans-unit id="9070f7ffe825f6632ea9c8c8c4cb452e5ea710fb" translate="yes" xml:space="preserve">
          <source>Numify returns the number of bytes in the instance data.</source>
          <target state="translated">Numifyは、インスタンスデータのバイト数を返します。</target>
        </trans-unit>
        <trans-unit id="1930939e1cfe41540640ae63b0d1c9cd976b8003" translate="yes" xml:space="preserve">
          <source>NushuSources.txt</source>
          <target state="translated">NushuSources.txt</target>
        </trans-unit>
        <trans-unit id="785fb0c8fda67339daa5891e78532ef7046332eb" translate="yes" xml:space="preserve">
          <source>Nuts and bolts of testing.</source>
          <target state="translated">試験のナットとボルト。</target>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="54d43a5ef4e27b9c279536a9f91a0f278f1c11b7" translate="yes" xml:space="preserve">
          <source>O - Generic interface to Perl Compiler backends</source>
          <target state="translated">O-Perl Compiler バックエンドへの汎用インターフェース</target>
        </trans-unit>
        <trans-unit id="7f2e040017a2a32e5149e8541c71a3f6ab2be70d" translate="yes" xml:space="preserve">
          <source>OA_BASEOP</source>
          <target state="translated">OA_BASEOP</target>
        </trans-unit>
        <trans-unit id="a0232d9c77de9ad3ad30f960003fca0ebf21434a" translate="yes" xml:space="preserve">
          <source>OA_BINOP</source>
          <target state="translated">OA_BINOP</target>
        </trans-unit>
        <trans-unit id="dd4e2946f44fa938f47620909c47a03ec9907915" translate="yes" xml:space="preserve">
          <source>OA_COP</source>
          <target state="translated">OA_COP</target>
        </trans-unit>
        <trans-unit id="8bb6941ea27d2f4edcd36aa185a95c1934071dae" translate="yes" xml:space="preserve">
          <source>OA_LISTOP</source>
          <target state="translated">OA_LISTOP</target>
        </trans-unit>
        <trans-unit id="1f95f49a3cc0d9c9dce498b8fb55f7d434ffef98" translate="yes" xml:space="preserve">
          <source>OA_LOGOP</source>
          <target state="translated">OA_LOGOP</target>
        </trans-unit>
        <trans-unit id="080d4766c1c017ed91c21efdfd770542db5231ba" translate="yes" xml:space="preserve">
          <source>OA_LOOP</source>
          <target state="translated">OA_LOOP</target>
        </trans-unit>
        <trans-unit id="b82424ac68328551cd5b311d9b76afd01dc2b8ec" translate="yes" xml:space="preserve">
          <source>OA_PADOP</source>
          <target state="translated">OA_PADOP</target>
        </trans-unit>
        <trans-unit id="1c24597939e0dd807c389498cedbeb0fddd031c5" translate="yes" xml:space="preserve">
          <source>OA_PMOP</source>
          <target state="translated">OA_PMOP</target>
        </trans-unit>
        <trans-unit id="388be58f270e37e48cf5f4058c11eb99107d89f1" translate="yes" xml:space="preserve">
          <source>OA_PVOP_OR_SVOP</source>
          <target state="translated">OA_PVOP_OR_SVOP</target>
        </trans-unit>
        <trans-unit id="565cd3fb7a20fefb8a748b15fbc632d71f3b0236" translate="yes" xml:space="preserve">
          <source>OA_SVOP</source>
          <target state="translated">OA_SVOP</target>
        </trans-unit>
        <trans-unit id="6e405aaa77ee94bd8832317336e851e6173b598b" translate="yes" xml:space="preserve">
          <source>OA_UNOP</source>
          <target state="translated">OA_UNOP</target>
        </trans-unit>
        <trans-unit id="2f1e5004dfcf9dde92d5fd30ce523548742521cc" translate="yes" xml:space="preserve">
          <source>OBJ</source>
          <target state="translated">OBJ</target>
        </trans-unit>
        <trans-unit id="828f2a22520c1086f191a7adfcf910b96f4fe93b" translate="yes" xml:space="preserve">
          <source>OBJECT</source>
          <target state="translated">OBJECT</target>
        </trans-unit>
        <trans-unit id="886bca430376624f1fa6be07dffa149e06727c43" translate="yes" xml:space="preserve">
          <source>OBJECT METHODS</source>
          <target state="translated">オブジェクトメソッド</target>
        </trans-unit>
        <trans-unit id="bb24863eee0d4bd1920af16c1ccee60c7f9c3be6" translate="yes" xml:space="preserve">
          <source>OBJECT SERIALISATION</source>
          <target state="translated">オブジェクトシリアル化</target>
        </trans-unit>
        <trans-unit id="3d6faefbb52c9934839e9dcd31987ac3958fd8ae" translate="yes" xml:space="preserve">
          <source>OBJECT-ORIENTED FUNDAMENTALS</source>
          <target state="translated">オブジェクト指向型基盤</target>
        </trans-unit>
        <trans-unit id="edf9874a257ef8b1a94138e136d570010b98cb88" translate="yes" xml:space="preserve">
          <source>OBJECT-ORIENTED INTERFACE</source>
          <target state="translated">オブジェクト指向インターフェース</target>
        </trans-unit>
        <trans-unit id="83ccf14b6fc5001c270b87a25f6dbd0dd2dbdb90" translate="yes" xml:space="preserve">
          <source>OBJECTS</source>
          <target state="translated">OBJECTS</target>
        </trans-unit>
        <trans-unit id="74d964f379ca5f7a63963447b2e66da24098ac03" translate="yes" xml:space="preserve">
          <source>OCTETS</source>
          <target state="translated">OCTETS</target>
        </trans-unit>
        <trans-unit id="05862bdb9f65a88577df4e19fea889c438e90640" translate="yes" xml:space="preserve">
          <source>ODBM_File</source>
          <target state="translated">ODBM_File</target>
        </trans-unit>
        <trans-unit id="7e05f5ed4d1b9fde9620b516a5a0c77a7eb29821" translate="yes" xml:space="preserve">
          <source>ODBM_File - Tied access to odbm files</source>
          <target state="translated">ODBM_File-odbm ファイルに紐付けられたアクセス</target>
        </trans-unit>
        <trans-unit id="7cdefafa72aee75553cdc6a69cd8b93613e4f45c" translate="yes" xml:space="preserve">
          <source>OFFSETS</source>
          <target state="translated">OFFSETS</target>
        </trans-unit>
        <trans-unit id="90916aa5c9b7aec2f126aa735cbb92f018d5530c" translate="yes" xml:space="preserve">
          <source>OFFSETSDBG</source>
          <target state="translated">OFFSETSDBG</target>
        </trans-unit>
        <trans-unit id="9ce3bd4224c8c1780db56b4125ecf3f24bf748b7" translate="yes" xml:space="preserve">
          <source>OK</source>
          <target state="translated">OK</target>
        </trans-unit>
        <trans-unit id="20e099ce66f09623331e4f7ac57998439d896891" translate="yes" xml:space="preserve">
          <source>OK (say, this system-dependent module builds in a subdirectory of some other distribution, or is listed as a dependency in a CPAN::Bundle, but the functionality is supported by different means on the current architecture).</source>
          <target state="translated">OK (例えば、このシステム依存モジュールが他のディストリビューションのサブディレクトリにビルドされていたり、CPAN::Bundleの依存関係としてリストアップされているが、その機能は現在のアーキテクチャでは別の方法でサポートされているとします)。</target>
        </trans-unit>
        <trans-unit id="01ac8af6582beb05b51e97a2306cc05bed91ec81" translate="yes" xml:space="preserve">
          <source>OK, as opposed to</source>
          <target state="translated">OK,対照的に</target>
        </trans-unit>
        <trans-unit id="42c8e2f5d8fdbf542c870810fe22e5463fc2fa22" translate="yes" xml:space="preserve">
          <source>OK, it's a start, but what happened to the spaces? We put &lt;code&gt;x&lt;/code&gt; , didn't we? Shouldn't it skip forward? Let's look at what &lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt; says:</source>
          <target state="translated">OK、それは始まりですが、スペースはどうなりましたか？ &lt;code&gt;x&lt;/code&gt; を入れましたね。飛ばしてはいけませんか？&lt;a href=&quot;functions/pack&quot;&gt;パック&lt;/a&gt;の内容を見てみましょう：</target>
        </trans-unit>
        <trans-unit id="36f7ee24c9b6c25eb367d474e774055820afae57" translate="yes" xml:space="preserve">
          <source>OK, it's a start, but what happened to the spaces? We put &lt;code&gt;x&lt;/code&gt;, didn't we? Shouldn't it skip forward? Let's look at what &lt;a href=&quot;perlfunc#pack&quot;&gt;&quot;pack&quot; in perlfunc&lt;/a&gt; says:</source>
          <target state="translated">OK、それは始まりですが、スペースはどうなりましたか？ &lt;code&gt;x&lt;/code&gt; を入れましたね。スキップしてはいけませんか？&lt;a href=&quot;perlfunc#pack&quot;&gt;perlfuncの「パック」が&lt;/a&gt;何を言っているか見てみましょう：</target>
        </trans-unit>
        <trans-unit id="2244411f280d2b7d311acac7ca58215079a5a39f" translate="yes" xml:space="preserve">
          <source>OK, let's have a look at some of our data again; in fact, we'll include the headers, and a handy ruler so we can keep track of where we are.</source>
          <target state="translated">実際には、ヘッダと便利な定規を含めて、現在地を把握できるようにしておきましょう。</target>
        </trans-unit>
        <trans-unit id="02b9f4d433d48fd34c45be1068128628f753ca51" translate="yes" xml:space="preserve">
          <source>OK, so let's bite the bullet. Here's one way to get the alignment right by inserting template codes &lt;code&gt;x&lt;/code&gt; , which don't take a corresponding item from the list:</source>
          <target state="translated">よし、弾丸をかじろう。リストから対応する項目を取得しないテンプレートコード &lt;code&gt;x&lt;/code&gt; を挿入することにより、正しい配置を行う1つの方法を次に示します。</target>
        </trans-unit>
        <trans-unit id="5f004dfa733000f32dac52f2362a807ead5a0ec9" translate="yes" xml:space="preserve">
          <source>OK, so let's bite the bullet. Here's one way to get the alignment right by inserting template codes &lt;code&gt;x&lt;/code&gt;, which don't take a corresponding item from the list:</source>
          <target state="translated">では、弾丸をかみましょう。リストから対応するアイテムを取得しないテンプレートコード &lt;code&gt;x&lt;/code&gt; を挿入して、配置を正しく行う1つの方法を次に示します。</target>
        </trans-unit>
        <trans-unit id="55cced79fbf573273c9277ae4c911cbf530c88fb" translate="yes" xml:space="preserve">
          <source>OK, the last one was actually an Obfuscated Perl Contest entry. :-)</source>
          <target state="translated">最後のものは、実は難読化Perlコンテストのエントリーでした。)</target>
        </trans-unit>
        <trans-unit id="57ecc84fea778a647ea6d7f2310ef9bca45201e0" translate="yes" xml:space="preserve">
          <source>OK, what's next? Between the date and the description is a blank column; we want to skip over that. The &lt;code&gt;x&lt;/code&gt; template means &quot;skip forward&quot;, so we want one of those. Next, we have another batch of characters, from 12 to 38. That's 27 more characters, hence &lt;code&gt;A27&lt;/code&gt; . (Don't make the fencepost error - there are 27 characters between 12 and 38, not 26. Count 'em!)</source>
          <target state="translated">じゃあ次は？日付と説明の間には空白の列があります。それをスキップしたいです。 &lt;code&gt;x&lt;/code&gt; 、我々はそれらのいずれかをしたいので、テンプレートの手段は、「早送り」。次に、12から38までの別の文字のバッチがあります。これは、27文字多いため、 &lt;code&gt;A27&lt;/code&gt; です。（fencepostエラーを発生させないでください-26ではなく、12から38までの27文字です。カウントしてください！）</target>
        </trans-unit>
        <trans-unit id="05a96155067c83cf8e468762a0e54175339f79a8" translate="yes" xml:space="preserve">
          <source>OK, what's next? Between the date and the description is a blank column; we want to skip over that. The &lt;code&gt;x&lt;/code&gt; template means &quot;skip forward&quot;, so we want one of those. Next, we have another batch of characters, from 12 to 38. That's 27 more characters, hence &lt;code&gt;A27&lt;/code&gt;. (Don't make the fencepost error - there are 27 characters between 12 and 38, not 26. Count 'em!)</source>
          <target state="translated">OK、次は何？日付と説明の間には空白の列があります。それをスキップしたいと思います。 &lt;code&gt;x&lt;/code&gt; 、我々はそれらのいずれかをしたいので、テンプレートの手段は、「早送り」。次に、12から38までの別の文字のバッチがあります。これはさらに27文字、つまり &lt;code&gt;A27&lt;/code&gt; です。（フェンスポストエラーを起こさないでください。26ではなく12から38の間に27文字あります。数えてください！）</target>
        </trans-unit>
        <trans-unit id="8f26553401469ee2b31b15d3391338fc7e46d2bc" translate="yes" xml:space="preserve">
          <source>OK, you know the basics of regexps and you want to know more. If matching regular expressions is analogous to a walk in the woods, then the tools discussed in Part 1 are analogous to topo maps and a compass, basic tools we use all the time. Most of the tools in part 2 are analogous to flare guns and satellite phones. They aren't used too often on a hike, but when we are stuck, they can be invaluable.</source>
          <target state="translated">正規表現の基本を知って、もっと知りたくなりましたね。正規表現のマッチングが森の中を散歩することに似ているとしたら、パート1のツールはトポ地図とコンパスに似ています。パート2のツールのほとんどは、フレアガンや衛星電話に例えられます。彼らはハイキングであまりにも頻繁に使用されていませんが、我々は立ち往生したとき、彼らは非常に貴重なことができます。</target>
        </trans-unit>
        <trans-unit id="2171105911206b856b529e816e5973ea3d92c2e5" translate="yes" xml:space="preserve">
          <source>OK. That's the C part done. Now we must do two additional things before this patch is ready to go: we've changed the behaviour of Perl, and so we must document that change. We must also provide some more regression tests to make sure our patch works and doesn't create a bug somewhere else along the line.</source>
          <target state="translated">OKです。これで C の部分は完了です。それは、Perl の挙動を変更したので、その変更を文書化しなければならないということです。また、私たちのパッチが動作していて、どこか他の場所でバグを作らないことを確認するために、リグレッションテストをいくつか提供しなければなりません。</target>
        </trans-unit>
        <trans-unit id="52e443591494f06d89603d027dbcc15ec5f21ac5" translate="yes" xml:space="preserve">
          <source>OLD BUILD INSTRUCTIONS</source>
          <target state="translated">古い建物の説明書</target>
        </trans-unit>
        <trans-unit id="1b8244806f0fe85fbdfb28350aa4197cefa6d7d6" translate="yes" xml:space="preserve">
          <source>OLD PERL VERSIONS</source>
          <target state="translated">古いPERLバージョン</target>
        </trans-unit>
        <trans-unit id="b25c8ed636326794258081a0a80bab33a84b2f10" translate="yes" xml:space="preserve">
          <source>ONE STEP FORWARD</source>
          <target state="translated">ワンステップフォワード</target>
        </trans-unit>
        <trans-unit id="3265add34ef90b3d5d5f9d59898e2a3656834e0f" translate="yes" xml:space="preserve">
          <source>ONE STEP SIDEWAYS</source>
          <target state="translated">ワンステップサイドウェイズ</target>
        </trans-unit>
        <trans-unit id="65b7fafd1d758275b2afd66a14ad17bf21acd2fc" translate="yes" xml:space="preserve">
          <source>ONESIDED LEXICONS</source>
          <target state="translated">ワンサイドレキシコン</target>
        </trans-unit>
        <trans-unit id="3b12b54c6a3deda565624403d547e7ef70be9c7d" translate="yes" xml:space="preserve">
          <source>ONFAIL</source>
          <target state="translated">ONFAIL</target>
        </trans-unit>
        <trans-unit id="b144599df5b9973435563870d7ba296904ec1710" translate="yes" xml:space="preserve">
          <source>ONLY</source>
          <target state="translated">ONLY</target>
        </trans-unit>
        <trans-unit id="e3c4c3d0eba1879f6f92c682389bed6ffbf94f06" translate="yes" xml:space="preserve">
          <source>OO INTERFACE</source>
          <target state="translated">OOインターフェース</target>
        </trans-unit>
        <trans-unit id="1433bf1bd15078b056fe76d6547c4bb2a283c920" translate="yes" xml:space="preserve">
          <source>OO Interface</source>
          <target state="translated">OOインタフェース</target>
        </trans-unit>
        <trans-unit id="e9a2811eef61d81b9e5a20155aec53e34b502e28" translate="yes" xml:space="preserve">
          <source>OO Perl</source>
          <target state="translated">オーオーパール</target>
        </trans-unit>
        <trans-unit id="3615e232deb829e0d1569b8035de6913840b260b" translate="yes" xml:space="preserve">
          <source>OO Perl is relatively simple and is implemented using references which know what sort of object they are based on Perl's concept of packages. However, OO Perl is largely beyond the scope of this document. Read &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; and &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">OO Perlは比較的単純で、Perlのパッケージの概念に基づいて、オブジェクトの種類を知っている参照を使用して実装されます。ただし、OO Perlは主にこのドキュメントの範囲を超えています。&lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt;と&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;を読んでください。</target>
        </trans-unit>
        <trans-unit id="2141f42c40de947ddd0e477a1e88d39467ae8b5d" translate="yes" xml:space="preserve">
          <source>OO System Summary</source>
          <target state="translated">OOシステムの概要</target>
        </trans-unit>
        <trans-unit id="e22cbd43f54a4419ac3832ce3ab610e1f892e4aa" translate="yes" xml:space="preserve">
          <source>OO interface to the select system call</source>
          <target state="translated">セレクトシステムコールへのOOインターフェース</target>
        </trans-unit>
        <trans-unit id="50841444197610a772ed0bf8061ebbec3fb69d4e" translate="yes" xml:space="preserve">
          <source>OO interface to users netrc file</source>
          <target state="translated">ユーザーへの OO インターフェイス netrc ファイル</target>
        </trans-unit>
        <trans-unit id="e5646c2e78bf00bf2def681a7c47f39c5c233aee" translate="yes" xml:space="preserve">
          <source>OOP style</source>
          <target state="translated">オーオーピースタイル</target>
        </trans-unit>
        <trans-unit id="01de497f472a97643f711e0af439f57cbf98b7cc" translate="yes" xml:space="preserve">
          <source>OP TREES</source>
          <target state="translated">OP TREES</target>
        </trans-unit>
        <trans-unit id="d97b094405ac341f25845d574d3003452633970d" translate="yes" xml:space="preserve">
          <source>OP class abbreviations</source>
          <target state="translated">OPクラスの略語</target>
        </trans-unit>
        <trans-unit id="e5a964607f5e2d840aa946796053a87561ef64ff" translate="yes" xml:space="preserve">
          <source>OP flags abbreviations</source>
          <target state="translated">OPフラグの略語</target>
        </trans-unit>
        <trans-unit id="c0c894eca9e57589b7dd798f6fc13ef59d8fced2" translate="yes" xml:space="preserve">
          <source>OP flags are either public or private. The public flags alter the behavior of each opcode in consistent ways, and are represented by 0 or more single characters.</source>
          <target state="translated">OP フラグはパブリックまたはプライベートのいずれかです。パブリックフラグは、各オペコードの動作を一貫した方法で変更し、0以上の1文字で表されます。</target>
        </trans-unit>
        <trans-unit id="4e1c899139139b6a62148bc5314166d68c3c0058" translate="yes" xml:space="preserve">
          <source>OP op_private flag definitions</source>
          <target state="translated">OP op_privateフラグの定義</target>
        </trans-unit>
        <trans-unit id="4bddb20f13d7f760a35db0afa01405e65b1c65f3" translate="yes" xml:space="preserve">
          <source>OP-RELATED CLASSES</source>
          <target state="translated">OP関連クラス</target>
        </trans-unit>
        <trans-unit id="134d5bae173a0d828238edb09ac60f90d32a7d18" translate="yes" xml:space="preserve">
          <source>OPEN this, filename</source>
          <target state="translated">これを開く,ファイル名</target>
        </trans-unit>
        <trans-unit id="9931dad0f7eb6ff4da51ab9c192c2a065a7d0255" translate="yes" xml:space="preserve">
          <source>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with LOCK_NB. These constants are traditionally valued 1, 2, 8 and 4, but you can use the symbolic names if you import them from the &lt;a href=&quot;../fcntl&quot;&gt;Fcntl&lt;/a&gt; module, either individually, or as a group using the &lt;code&gt;:&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; tag. LOCK_SH requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN releases a previously requested lock. If LOCK_NB is bitwise-or'ed with LOCK_SH or LOCK_EX, then &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns immediately rather than blocking waiting for the lock; check the return status to see if you got it.</source>
          <target state="translated">OPERATIONは、LOCK_SH、LOCK_EX、またはLOCK_UNのいずれかであり、LOCK_NBと組み合わせられる可能性があります。これらの定数の値は伝統的に&lt;a href=&quot;../fcntl&quot;&gt;1、2、8、4&lt;/a&gt;ですが、Fcntlモジュールから個別に、または &lt;code&gt;:&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; タグを使用してグループとしてインポートする場合は、シンボリック名を使用できます。LOCK_SHは共有ロックを要求し、LOCK_EXは排他ロックを要求し、LOCK_UNは以前に要求されたロックを解放します。LOCK_NBがLOCK_SHまたはLOCK_EXとビット単位で論理和演算されている場合、 &lt;code&gt;&lt;a href=&quot;flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; はロックを待機してブロックするのではなく、すぐに戻ります。返品ステータスを確認して、受け取ったかどうかを確認してください。</target>
        </trans-unit>
        <trans-unit id="5806c98abb4bc38de2885393f139558efaa4744b" translate="yes" xml:space="preserve">
          <source>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with LOCK_NB. These constants are traditionally valued 1, 2, 8 and 4, but you can use the symbolic names if you import them from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module, either individually, or as a group using the &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; tag. LOCK_SH requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN releases a previously requested lock. If LOCK_NB is bitwise-or'ed with LOCK_SH or LOCK_EX, then &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns immediately rather than blocking waiting for the lock; check the return status to see if you got it.</source>
          <target state="translated">OPERATIONは、LOCK_SH、LOCK_EX、またはLOCK_UNのいずれかであり、LOCK_NBと組み合わせられる可能性があります。これらの定数の値は伝統的に&lt;a href=&quot;fcntl&quot;&gt;1、2、8、4&lt;/a&gt;ですが、Fcntlモジュールから個別に、または &lt;code&gt;:&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; タグを使用してグループとしてインポートする場合は、シンボリック名を使用できます。LOCK_SHは共有ロックを要求し、LOCK_EXは排他ロックを要求し、LOCK_UNは以前に要求されたロックを解放します。LOCK_NBがLOCK_SHまたはLOCK_EXとビット単位で論理和演算されている場合、 &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; はロックを待機してブロックするのではなく、すぐに戻ります。返品ステータスを確認して、受け取ったかどうかを確認してください。</target>
        </trans-unit>
        <trans-unit id="58928b6b598b49fbbad1c76c170db949cd86f725" translate="yes" xml:space="preserve">
          <source>OPERATION is one of LOCK_SH, LOCK_EX, or LOCK_UN, possibly combined with LOCK_NB. These constants are traditionally valued 1, 2, 8 and 4, but you can use the symbolic names if you import them from the &lt;a href=&quot;fcntl&quot;&gt;Fcntl&lt;/a&gt; module, either individually, or as a group using the &lt;code&gt;:flock&lt;/code&gt; tag. LOCK_SH requests a shared lock, LOCK_EX requests an exclusive lock, and LOCK_UN releases a previously requested lock. If LOCK_NB is bitwise-or'ed with LOCK_SH or LOCK_EX, then &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt; returns immediately rather than blocking waiting for the lock; check the return status to see if you got it.</source>
          <target state="translated">OPERATIONは、LOCK_SH、LOCK_EX、またはLOCK_UNのいずれかであり、おそらくLOCK_NBと組み合わされます。これらの定数は、従来は&lt;a href=&quot;fcntl&quot;&gt;1、2、8&lt;/a&gt;、および4の値でしたが、Fcntlモジュールから個別に、または &lt;code&gt;:flock&lt;/code&gt; タグを使用してグループとしてインポートする場合は、シンボリック名を使用できます。LOCK_SHは共有ロックを要求し、LOCK_EXは排他ロックを要求し、LOCK_UNは以前に要求されたロックを解放します。LOCK_NBがビットごとに-またはLOCK_SHまたはLOCK_EXで処理されている場合、&lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt; &lt;code&gt;flock&lt;/code&gt; &lt;/a&gt;はロックの待機をブロックするのではなく、すぐに戻ります。返品状況をチェックして、受け取ったかどうかを確認してください。</target>
        </trans-unit>
        <trans-unit id="277a5e5c068658adb7eeea0e8ac338b111cfff2f" translate="yes" xml:space="preserve">
          <source>OPERATIONS</source>
          <target state="translated">OPERATIONS</target>
        </trans-unit>
        <trans-unit id="ae6eaba46b51b460ad70f762d13737864d558ddb" translate="yes" xml:space="preserve">
          <source>OPERATOR DIFFERENCES</source>
          <target state="translated">操作方法の違い</target>
        </trans-unit>
        <trans-unit id="3b9833465b980fc8907d152fbd1be4ed82789a85" translate="yes" xml:space="preserve">
          <source>OPERATORS</source>
          <target state="translated">OPERATORS</target>
        </trans-unit>
        <trans-unit id="06c49349926c115048c467e62819168f88084bea" translate="yes" xml:space="preserve">
          <source>OPTIMISE</source>
          <target state="translated">OPTIMISE</target>
        </trans-unit>
        <trans-unit id="4f728fb4e19e018dc7c2672b0908d6be76bddf1f" translate="yes" xml:space="preserve">
          <source>OPTIMISEM</source>
          <target state="translated">OPTIMISEM</target>
        </trans-unit>
        <trans-unit id="02ce66c3b2f62920ab55a0e848d4ded3f5f982b7" translate="yes" xml:space="preserve">
          <source>OPTIMIZE</source>
          <target state="translated">OPTIMIZE</target>
        </trans-unit>
        <trans-unit id="8a61db568f56cdf729bb2bcffb35bc1a208ff62c" translate="yes" xml:space="preserve">
          <source>OPTIONAL FIELDS</source>
          <target state="translated">オプションフィールド</target>
        </trans-unit>
        <trans-unit id="463186385d27ae21b6cfb79380a5979894ad32c0" translate="yes" xml:space="preserve">
          <source>OPTIONAL PARAMETERS</source>
          <target state="translated">オプションパラメータ</target>
        </trans-unit>
        <trans-unit id="2d0b2762a37fa9b498b0ef0041758a02e1b217bd" translate="yes" xml:space="preserve">
          <source>OPTIONAL SUBROUTINE/METHOD OVERRIDES</source>
          <target state="translated">オプションのサブルーチン/メソッドがオーバーライドします。</target>
        </trans-unit>
        <trans-unit id="3c86eca6569badf198a635b289a628e0713ed7b0" translate="yes" xml:space="preserve">
          <source>OPTIONAL-INFO</source>
          <target state="translated">OPTIONAL-INFO</target>
        </trans-unit>
        <trans-unit id="39dd320e8c4e9f06b35e0be0b4942ac2022fb9c1" translate="yes" xml:space="preserve">
          <source>OPTIONS</source>
          <target state="translated">OPTIONS</target>
        </trans-unit>
        <trans-unit id="cfee3b3e47c3ccac4481ec3d455bf43de1a65fd1" translate="yes" xml:space="preserve">
          <source>OPTIONS AND ARGUMENTS</source>
          <target state="translated">選択肢と主張</target>
        </trans-unit>
        <trans-unit id="6409ae0433181a6f096278e81922ef91fcf094d5" translate="yes" xml:space="preserve">
          <source>OPTIONS/ARGUMENTS</source>
          <target state="translated">OPTIONS/ARGUMENTS</target>
        </trans-unit>
        <trans-unit id="d02651d637b66f91c995f98ff893920c6613a814" translate="yes" xml:space="preserve">
          <source>OPTS consists of any of the options that are available when creating the &lt;code&gt;$z&lt;/code&gt; object.</source>
          <target state="translated">OPTSは、 &lt;code&gt;$z&lt;/code&gt; オブジェクトの作成時に使用できるオプションのいずれかで構成されています。</target>
        </trans-unit>
        <trans-unit id="34e983dffbba74010d0b834918e8b9de427ff5bf" translate="yes" xml:space="preserve">
          <source>OPTS is a combination of the following options:</source>
          <target state="translated">OPTSは以下のオプションを組み合わせたものです。</target>
        </trans-unit>
        <trans-unit id="443cfbc1735fa88324f99c052a719f69f770de00" translate="yes" xml:space="preserve">
          <source>OP_CLASS</source>
          <target state="translated">OP_CLASS</target>
        </trans-unit>
        <trans-unit id="257329c9527baa8930f69f20f88bd1b9492d9148" translate="yes" xml:space="preserve">
          <source>OP_DESC</source>
          <target state="translated">OP_DESC</target>
        </trans-unit>
        <trans-unit id="95a97252650f52a0edc590efc17643d272eecd14" translate="yes" xml:space="preserve">
          <source>OP_NAME</source>
          <target state="translated">OP_NAME</target>
        </trans-unit>
        <trans-unit id="664b383a7365636329fa816c917a23ae28c5aba2" translate="yes" xml:space="preserve">
          <source>OP_TYPE_IS</source>
          <target state="translated">OP_TYPE_IS</target>
        </trans-unit>
        <trans-unit id="745e8a6c1fc90c064d4d4edecae8bb1c615be59a" translate="yes" xml:space="preserve">
          <source>OP_TYPE_IS_OR_WAS</source>
          <target state="translated">OP_TYPE_IS_OR_WAS</target>
        </trans-unit>
        <trans-unit id="bf9f9c661a64325d7940c6088a152e09a3273a85" translate="yes" xml:space="preserve">
          <source>ORDER OF APPLICATION</source>
          <target state="translated">申し込み順</target>
        </trans-unit>
        <trans-unit id="686fecd15046059a1461463f65cd5916d98af39b" translate="yes" xml:space="preserve">
          <source>ORIGMARK</source>
          <target state="translated">ORIGMARK</target>
        </trans-unit>
        <trans-unit id="6b6a53f5c91030f120c92b395563cf165ba2b731" translate="yes" xml:space="preserve">
          <source>ORcpt is also part of the SMTP DSN extension according to RFC3461. It is used to pass along the original recipient that the mail was first sent to. The machine that generates a DSN will use this address to inform the sender, because he can't know if recipients get rewritten by mail servers. It is expected to be in a format as required by RFC3461, xtext-encoded.</source>
          <target state="translated">ORcptはRFC3461によるSMTP DSN拡張の一部でもある。これは、メールが最初に送信された元の受信者を渡すために使用される。DSN を生成するマシンは、受信者がメールサーバによって書き換えられた場合、送信者に通知するためにこのアドレスを使用します。これはRFC3461で要求されているフォーマット、xtext-encodedであることが期待されている。</target>
        </trans-unit>
        <trans-unit id="3e55c8accb9b59a4e2e3860b73d18e283bd63d08" translate="yes" xml:space="preserve">
          <source>OS ISSUES</source>
          <target state="translated">OSの問題</target>
        </trans-unit>
        <trans-unit id="9954b5cb646af3e1d62f8936ee802e399e164efe" translate="yes" xml:space="preserve">
          <source>OS X</source>
          <target state="translated">オーエスエックス</target>
        </trans-unit>
        <trans-unit id="ca7db916096936ab02b469184b00a31ffb7e99f9" translate="yes" xml:space="preserve">
          <source>OS adjusted ExtUtils::MakeMaker subclass</source>
          <target state="translated">OS が調整した ExtUtils::MakeMaker サブクラス</target>
        </trans-unit>
        <trans-unit id="a507b0570eef10c513490b530ff7cffb662e9519" translate="yes" xml:space="preserve">
          <source>OS level</source>
          <target state="translated">OSレベル</target>
        </trans-unit>
        <trans-unit id="53b5eb00477f53acb0522cf8349b912973394461" translate="yes" xml:space="preserve">
          <source>OS-Related References</source>
          <target state="translated">OS関連のリファレンス</target>
        </trans-unit>
        <trans-unit id="49f5479219ce3d4b44c672d19081b527acbff3f8" translate="yes" xml:space="preserve">
          <source>OS/2</source>
          <target state="translated">OS/2</target>
        </trans-unit>
        <trans-unit id="9b1d79b903ce0b8766b4e5764e59485f0c5a70da" translate="yes" xml:space="preserve">
          <source>OS/2 .INF file</source>
          <target state="translated">OS/2のINFファイル</target>
        </trans-unit>
        <trans-unit id="c2ee378ae6f39b56008cc84e4ccbbff11e3e4428" translate="yes" xml:space="preserve">
          <source>OS/2 _.INF_ file</source>
          <target state="translated">OS/2 _.INF_ファイル</target>
        </trans-unit>
        <trans-unit id="8170ede7c45b17e28c246c077e40c6bb259a2169" translate="yes" xml:space="preserve">
          <source>OS/2 is OS/2</source>
          <target state="translated">OS/2はOS/2</target>
        </trans-unit>
        <trans-unit id="9f2b9449bdc8f69e4d1ebfaee7720b50c48e466a" translate="yes" xml:space="preserve">
          <source>OS/2 toolkit</source>
          <target state="translated">オーエスツーツールキット</target>
        </trans-unit>
        <trans-unit id="fd3c79c993342fdc4845e0000fd358e72448a4b9" translate="yes" xml:space="preserve">
          <source>OS/390 will support the &lt;code&gt;#!&lt;/code&gt; shebang trick in release 2.8 and beyond. Calls to &lt;a href=&quot;perlfunc#system-LIST&quot;&gt;&lt;code&gt;system&lt;/code&gt;&lt;/a&gt; and backticks can use POSIX shell syntax on all S/390 systems.</source>
          <target state="translated">OS / 390は &lt;code&gt;#!&lt;/code&gt; をサポートします！リリース2.8以降のシバントリック。&lt;a href=&quot;perlfunc#system-LIST&quot;&gt; &lt;code&gt;system&lt;/code&gt; &lt;/a&gt;およびバッククォートの呼び出しでは、すべてのS / 390システムでPOSIXシェル構文を使用できます。</target>
        </trans-unit>
        <trans-unit id="1adfaba1d7ff8cc9090d93cbfe1b050db4768533" translate="yes" xml:space="preserve">
          <source>OS/390 will support the &lt;code&gt;#!&lt;/code&gt; shebang trick in release 2.8 and beyond. Calls to &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; and backticks can use POSIX shell syntax on all S/390 systems.</source>
          <target state="translated">OS / 390は &lt;code&gt;#!&lt;/code&gt; をサポートします！リリース2.8以降のシバントリック。 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; とバッククォートの呼び出しは、すべてのS / 390システムでPOSIXシェル構文を使用できます。</target>
        </trans-unit>
        <trans-unit id="1d34b2e0115c599698c2eaf50db89fcc832b02bf" translate="yes" xml:space="preserve">
          <source>OS/390, z/OS</source>
          <target state="translated">OS/390、z/OS</target>
        </trans-unit>
        <trans-unit id="0a302d149142b54ba805c25c7803eba208bb0727" translate="yes" xml:space="preserve">
          <source>OS/400</source>
          <target state="translated">OS/400</target>
        </trans-unit>
        <trans-unit id="ce46010d8cbef8c9b0bbd999f8b39bd331eb9402" translate="yes" xml:space="preserve">
          <source>OS2::BootDrive()</source>
          <target state="translated">OS2::BootDrive()</target>
        </trans-unit>
        <trans-unit id="6b75ff49b64b08a5cbda19098841eaa70af4d838" translate="yes" xml:space="preserve">
          <source>OS2::SysInfo()</source>
          <target state="translated">OS2::SysInfo()</target>
        </trans-unit>
        <trans-unit id="aca5fea461e6f13c528c2c4f05a7be94b7faae70" translate="yes" xml:space="preserve">
          <source>OS2::get_control87()</source>
          <target state="translated">OS2::get_control87()</target>
        </trans-unit>
        <trans-unit id="7ffcc4aa191d7c21c744cd8b5d4c95af4f197345" translate="yes" xml:space="preserve">
          <source>OSPEED</source>
          <target state="translated">OSPEED</target>
        </trans-unit>
        <trans-unit id="957c024b38ce820878f03177ce3d2b83c26a82d0" translate="yes" xml:space="preserve">
          <source>OTHER</source>
          <target state="translated">OTHER</target>
        </trans-unit>
        <trans-unit id="cb338bafdad45c9e72ba4f2b86d7dc19e8efe3a0" translate="yes" xml:space="preserve">
          <source>OTHER API EXPORTS</source>
          <target state="translated">その他のAPI輸出</target>
        </trans-unit>
        <trans-unit id="7ea1e1d8de28e316e4bbdddc4c0f8d93bcafa453" translate="yes" xml:space="preserve">
          <source>OTHER API FUNCTIONS</source>
          <target state="translated">その他の API 関数</target>
        </trans-unit>
        <trans-unit id="5d6ab2bf42c29199bc2595a18bf166b2ca9d58db" translate="yes" xml:space="preserve">
          <source>OTHER COMPONENTS</source>
          <target state="translated">その他のコンポーネント</target>
        </trans-unit>
        <trans-unit id="f4819c79c3cf5d0855c9756e200236cb695ed79b" translate="yes" xml:space="preserve">
          <source>OTHER EXAMPLES</source>
          <target state="translated">その他の例</target>
        </trans-unit>
        <trans-unit id="f6c2b40e6c72a2bb0b41071005914975b421d2b3" translate="yes" xml:space="preserve">
          <source>OTHER FACILITIES</source>
          <target state="translated">その他の施設</target>
        </trans-unit>
        <trans-unit id="b9ed1fc6bda9c1de960a484858190276f8547802" translate="yes" xml:space="preserve">
          <source>OTHER FUNCTIONS</source>
          <target state="translated">その他の機能</target>
        </trans-unit>
        <trans-unit id="c89d68a8b80355c832f177abfb0d1dd9e08c42b5" translate="yes" xml:space="preserve">
          <source>OURSTASH</source>
          <target state="translated">OURSTASH</target>
        </trans-unit>
        <trans-unit id="cf1596fa6b124742caf502c819fa40b64395f706" translate="yes" xml:space="preserve">
          <source>OUTPUT TIPS</source>
          <target state="translated">出力のヒント</target>
        </trans-unit>
        <trans-unit id="cbbef8ce7e5bb98d49b97d0627758196498a036b" translate="yes" xml:space="preserve">
          <source>OUTSIDE</source>
          <target state="translated">OUTSIDE</target>
        </trans-unit>
        <trans-unit id="aed9198315d600f631cbfb4ab62949c42689f27b" translate="yes" xml:space="preserve">
          <source>OUTSIDE_SEQ</source>
          <target state="translated">OUTSIDE_SEQ</target>
        </trans-unit>
        <trans-unit id="a32824f28f79811519a5acdabe1d4b373c40ef62" translate="yes" xml:space="preserve">
          <source>OVERRIDDEN METHODS</source>
          <target state="translated">過剰な方法</target>
        </trans-unit>
        <trans-unit id="bf6107f87a0ec04cb2b618d76df7646acae50937" translate="yes" xml:space="preserve">
          <source>OVERRIDES</source>
          <target state="translated">OVERRIDES</target>
        </trans-unit>
        <trans-unit id="be5d4c45f4cd36cced53ba6c4c1d80a8493a95f3" translate="yes" xml:space="preserve">
          <source>OVERRIDING CORE FUNCTIONS</source>
          <target state="translated">オーバーライドコア機能</target>
        </trans-unit>
        <trans-unit id="f275fdb83760cf7f81c0389520bf2b7351b38004" translate="yes" xml:space="preserve">
          <source>OVERVIEW</source>
          <target state="translated">OVERVIEW</target>
        </trans-unit>
        <trans-unit id="fe6d13a6636d2e856ee66d1e674b0c568eee0ba0" translate="yes" xml:space="preserve">
          <source>OVERVIEW OF CLASSES</source>
          <target state="translated">クラスの概要</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="f0e2a5cc2614159a14f8d24f77aff8cedbb91395" translate="yes" xml:space="preserve">
          <source>Object Methods</source>
          <target state="translated">オブジェクトメソッド</target>
        </trans-unit>
        <trans-unit id="7a403b426b3138de1314edbedb502e24fe00906c" translate="yes" xml:space="preserve">
          <source>Object Orientation is not the best solution to every problem. In</source>
          <target state="translated">オブジェクト指向は、すべての問題に対して最適な解決策ではありません。このような問題を解決するためには</target>
        </trans-unit>
        <trans-unit id="0576faceb2bc930743ea41920355c65b4ff2f401" translate="yes" xml:space="preserve">
          <source>Object Oriented Encoder</source>
          <target state="translated">オブジェクト指向エンコーダ</target>
        </trans-unit>
        <trans-unit id="1328c7cddf5e1741e60ae0ea7e9cd25feb10a44d" translate="yes" xml:space="preserve">
          <source>Object Oriented time objects</source>
          <target state="translated">オブジェクト指向の時間オブジェクト</target>
        </trans-unit>
        <trans-unit id="8a9d1904669ae5189957085d3ad744889ffa188e" translate="yes" xml:space="preserve">
          <source>Object Oriented/Tied Handle Interface</source>
          <target state="translated">オブジェクト指向/紐付きハンドルインタフェース</target>
        </trans-unit>
        <trans-unit id="0c1a2199d628852802c93c71acfcb62c9006d4a9" translate="yes" xml:space="preserve">
          <source>Object interface</source>
          <target state="translated">オブジェクトインタフェース</target>
        </trans-unit>
        <trans-unit id="c2554e1cb290677a2fc70d0a43154bdf1c0148ab" translate="yes" xml:space="preserve">
          <source>Object interface for AF_INET domain sockets</source>
          <target state="translated">AF_INET ドメインソケット用オブジェクトインタフェース</target>
        </trans-unit>
        <trans-unit id="93e56d8e38067f0fd87b11c1619713b42509ffd1" translate="yes" xml:space="preserve">
          <source>Object interface for AF_UNIX domain sockets</source>
          <target state="translated">AF_UNIX ドメインソケット用オブジェクトインタフェース</target>
        </trans-unit>
        <trans-unit id="3d662b2d2b28e92fa294d9f80685e9709d96e1ab" translate="yes" xml:space="preserve">
          <source>Object interface to socket communications</source>
          <target state="translated">ソケット通信のためのオブジェクトインタフェース</target>
        </trans-unit>
        <trans-unit id="c9adffadbed4d834ac5b856b003595a5f887d57f" translate="yes" xml:space="preserve">
          <source>Object interface to system poll call</source>
          <target state="translated">システムポーリングコールへのオブジェクトインタフェース</target>
        </trans-unit>
        <trans-unit id="cc8d552e462d1eb5f26cd8f9fdf1f0a8654a0735" translate="yes" xml:space="preserve">
          <source>Object interface:</source>
          <target state="translated">オブジェクトのインターフェイスです。</target>
        </trans-unit>
        <trans-unit id="a4fd25b923092435b59d8ba7f9a4eeafbcc983ac" translate="yes" xml:space="preserve">
          <source>Object oriented interface</source>
          <target state="translated">オブジェクト指向インタフェース</target>
        </trans-unit>
        <trans-unit id="26b3504ec46d1edff4f4783df6ad8b24180e673c" translate="yes" xml:space="preserve">
          <source>Object property methods</source>
          <target state="translated">オブジェクトのプロパティメソッド</target>
        </trans-unit>
        <trans-unit id="e5fa350c821e5eff6e8a902ebb2f0731d1bbc634" translate="yes" xml:space="preserve">
          <source>Object registry is best done when the object is initialized for use with a class. That way, garbage collection and thread safety are established for every object and every field that is initialized.</source>
          <target state="translated">オブジェクトレジストリは、オブジェクトがクラスで使用するために初期化されたときに行うのが最適です。そうすることで、ガベージコレクションとスレッドの安全性が、すべてのオブジェクトと初期化されたすべてのフィールドに対して確立されます。</target>
        </trans-unit>
        <trans-unit id="00830e1926297b7c355fe1aa06dab72200595135" translate="yes" xml:space="preserve">
          <source>Object status (i.e., the class an object is blessed into) is also cloned.</source>
          <target state="translated">オブジェクトの状態(すなわち、オブジェクトが祝福されたクラス)もクローンされます。</target>
        </trans-unit>
        <trans-unit id="fe8c7731a828adbc9c6710de9659455410072a19" translate="yes" xml:space="preserve">
          <source>Object to manage a stack of &lt;a href=&quot;Test2::Hub&quot;&gt;Test2::Hub&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;Test2::Hub&quot;&gt;Test2 :: Hubの&lt;/a&gt;スタックを管理するオブジェクト</target>
        </trans-unit>
        <trans-unit id="ef528339319411e5d4f89f3a15d4db11ad2cbd90" translate="yes" xml:space="preserve">
          <source>Object to represent a testing context.</source>
          <target state="translated">テストのコンテキストを表すオブジェクト。</target>
        </trans-unit>
        <trans-unit id="6fbf11227dc99e33421481b03ca2f68bc9536a37" translate="yes" xml:space="preserve">
          <source>Object used by Test2::API under the hood</source>
          <target state="translated">Test2::APIがフードの下で使用するオブジェクト</target>
        </trans-unit>
        <trans-unit id="72a83add2c5ede877c10d23f302d3e17accbadab" translate="yes" xml:space="preserve">
          <source>Objects</source>
          <target state="translated">Objects</target>
        </trans-unit>
        <trans-unit id="88749641a0e24498fbd33e53d44467f3c2c5fba0" translate="yes" xml:space="preserve">
          <source>Objects Are Blessed; Variables Are Not</source>
          <target state="translated">オブジェクトは祝福されているが、変数は祝福されていない</target>
        </trans-unit>
        <trans-unit id="5bca7499b54d7016ce15937bcabd8353b693c22e" translate="yes" xml:space="preserve">
          <source>Objects based on the above</source>
          <target state="translated">上記に基づくオブジェクト</target>
        </trans-unit>
        <trans-unit id="e56ad09ee25c724ca5817035af9f32f714eaf7e7" translate="yes" xml:space="preserve">
          <source>Objects representing POD input paragraphs, commands, etc.</source>
          <target state="translated">PODの入力段落やコマンドなどを表すオブジェクト。</target>
        </trans-unit>
        <trans-unit id="1ad3969f34af62c08d92133f049673d28c2645d6" translate="yes" xml:space="preserve">
          <source>Obscure - set count of bytes in the buffer. Deprecated. Only usable if PerlIO_canset_cnt() returns true. Currently used in only doio.c to force count less than -1 to -1. Perhaps should be PerlIO_set_empty or similar. This call may actually do nothing if &quot;count&quot; is deduced from pointer and a &quot;limit&quot;. Do not use this - use PerlIO_set_ptrcnt().</source>
          <target state="translated">Obscure-バッファ内のバイト数を設定します。非推奨。PerlIO_canset_cnt()が真を返した場合のみ使用可能。現在は doio.c のみで使用されており、-1 未満のカウントを強制的に -1 にするために使用されています。PerlIO_set_empty または同様のものを使用すべきかもしれません。ポインタとリミットからカウントが推論された場合、この呼び出しは実際には何もしないかもしれません。これは使わないでください-PerlIO_set_ptrcnt()を使ってください。</target>
        </trans-unit>
        <trans-unit id="4e7d8c7849f1648c77052055f32051f9581d8bc7" translate="yes" xml:space="preserve">
          <source>Obsolete</source>
          <target state="translated">Obsolete</target>
        </trans-unit>
        <trans-unit id="e6bd238b055b51008fa691962e5504d6a4300b6b" translate="yes" xml:space="preserve">
          <source>Obsolete backwards compatibility functions</source>
          <target state="translated">廃止された下位互換機能</target>
        </trans-unit>
        <trans-unit id="242a752af236cef2e4f67eafc9e86420fe839b22" translate="yes" xml:space="preserve">
          <source>Obsolete, deprecated method. Not used since Version 5.21.</source>
          <target state="translated">廃止された、非推奨のメソッドです。バージョン 5.21 以降では使用されていません。</target>
        </trans-unit>
        <trans-unit id="ae05a67e6b1bdd3a5722aeecd922515ab6353aa5" translate="yes" xml:space="preserve">
          <source>Obsolete. All code points previously matched by this have been moved to &quot;Script=Common&quot;. Consider instead using &quot;Script_Extensions=Katakana&quot; or &quot;Script_Extensions=Hiragana&quot; (or both)</source>
          <target state="translated">廃止されました。これによって以前にマッチしていたすべてのコードポイントは「スクリプト=共通」に移動されました。代わりに「Script_Extensions=カタカナ」か「Script_Extensions=ひらがな」 (またはその両方)の使用を検討してください。</target>
        </trans-unit>
        <trans-unit id="a9002afd81f2bf4ce6e9b9a4e6ca0a84152afb47" translate="yes" xml:space="preserve">
          <source>Obsoleted as of Unicode 9.0, but previously provided a visual display of the standard variant sequences derived from</source>
          <target state="translated">Unicode 9.0 で廃止されましたが、以前は</target>
        </trans-unit>
        <trans-unit id="2fc29852a42ef2fda895989b8798adc19e9d7e6c" translate="yes" xml:space="preserve">
          <source>Obtain a response from the server. Upon success the most significant digit of the status code is returned. Upon failure, timeout etc.,</source>
          <target state="translated">サーバからの応答を取得します。成功した場合は、ステータスコードの最上位桁を返します。失敗した場合、タイムアウトなど</target>
        </trans-unit>
        <trans-unit id="c69d89c90bc0675bccad1c0dfa062843dd612b7a" translate="yes" xml:space="preserve">
          <source>Obtain information about all the active newsgroups. The results is a reference to a hash where the key is a group name and each value is a reference to an array. The elements in this array are:- the last article number in the group, the first article number in the group and any information flags about the group.</source>
          <target state="translated">アクティブなすべてのニュースグループの情報を取得します。結果はハッシュへの参照で、キーはグループ名、各値は配列への参照です。この配列の要素は、グループ内の最後の記事番号、 グループ内の最初の記事番号、グループに関する情報フラグです。</target>
        </trans-unit>
        <trans-unit id="51850565c0039917e1d7c30526e1aece9dd14aed" translate="yes" xml:space="preserve">
          <source>Obtain the attributes for &lt;code&gt;stdin&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; の属性を取得します。</target>
        </trans-unit>
        <trans-unit id="7789255329d3ffd1b99a0a2cd58f6fb55a93559e" translate="yes" xml:space="preserve">
          <source>Obtain the attributes for &lt;code&gt;stdin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; の属性を取得します。</target>
        </trans-unit>
        <trans-unit id="4897259e0b2ea144f76021c4fb5eb538871e32ce" translate="yes" xml:space="preserve">
          <source>Obtain the attributes for stdout.</source>
          <target state="translated">標準出力の属性を取得します。</target>
        </trans-unit>
        <trans-unit id="12526129b1b52b63050b51bbb32341d9a8cd1a04" translate="yes" xml:space="preserve">
          <source>Obtain the header field &lt;code&gt;HEADER&lt;/code&gt; for all the messages specified.</source>
          <target state="translated">指定されたすべてのメッセージのヘッダーフィールド &lt;code&gt;HEADER&lt;/code&gt; を取得します。</target>
        </trans-unit>
        <trans-unit id="ec15ee25f6bbd0b55463ebbf3ac8647c1d12711a" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt; , or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC867. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt; . The result will be an ASCII string or</source>
          <target state="translated">RFC867で定義されているプロトコルを使用して、 &lt;code&gt;HOST&lt;/code&gt; 、または &lt;code&gt;HOST&lt;/code&gt; が指定されていないか定義されていない場合はデフォルトのホストの時刻を取得します。オプションの引数 &lt;code&gt;PROTOCOL&lt;/code&gt; は、使用するプロトコル（ &lt;code&gt;tcp&lt;/code&gt; または &lt;code&gt;udp&lt;/code&gt; )を定義する必要があります。結果はASCII文字列または</target>
        </trans-unit>
        <trans-unit id="99f41f8f4a19b089d2fd1f49ca16ff7053ef6795" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt; , or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC868. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt; . The result will be a time value in the same units as returned by time() or</source>
          <target state="translated">RFC868で定義されているプロトコルを使用して、 &lt;code&gt;HOST&lt;/code&gt; 、または &lt;code&gt;HOST&lt;/code&gt; が指定されていないか定義されていない場合はデフォルトのホストの時刻を取得します。オプションの引数 &lt;code&gt;PROTOCOL&lt;/code&gt; は、使用するプロトコル（ &lt;code&gt;tcp&lt;/code&gt; または &lt;code&gt;udp&lt;/code&gt; )を定義する必要があります。結果は、time（）によって返されるのと同じ単位の時間値になります。</target>
        </trans-unit>
        <trans-unit id="795eb623dba4761a659c021e4b42f3958e340aa1" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt;, or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC867. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt;. The result will be an ASCII string or</source>
          <target state="translated">RFC867で定義されているプロトコルを使用して、 &lt;code&gt;HOST&lt;/code&gt; 、または &lt;code&gt;HOST&lt;/code&gt; が指定されていないか定義されていない場合はデフォルトのホストで時間を取得します。オプションの引数 &lt;code&gt;PROTOCOL&lt;/code&gt; は、使用するプロトコル（ &lt;code&gt;tcp&lt;/code&gt; または &lt;code&gt;udp&lt;/code&gt; )を定義する必要があります。結果はASCII文字列または</target>
        </trans-unit>
        <trans-unit id="e74c2d6b8c1d1a064d7e0d2a2f0c8de41a911ec1" translate="yes" xml:space="preserve">
          <source>Obtain the time on &lt;code&gt;HOST&lt;/code&gt;, or some default host if &lt;code&gt;HOST&lt;/code&gt; is not given or not defined, using the protocol as defined in RFC868. The optional argument &lt;code&gt;PROTOCOL&lt;/code&gt; should define the protocol to use, either &lt;code&gt;tcp&lt;/code&gt; or &lt;code&gt;udp&lt;/code&gt;. The result will be a time value in the same units as returned by time() or</source>
          <target state="translated">RFC868で定義されているプロトコルを使用して、 &lt;code&gt;HOST&lt;/code&gt; 、または &lt;code&gt;HOST&lt;/code&gt; が指定されていないか定義されていない場合はデフォルトのホストで時間を取得します。オプションの引数 &lt;code&gt;PROTOCOL&lt;/code&gt; は、使用するプロトコル（ &lt;code&gt;tcp&lt;/code&gt; または &lt;code&gt;udp&lt;/code&gt; )を定義する必要があります。結果は、time（）またはで返されるのと同じ単位の時間値になります。</target>
        </trans-unit>
        <trans-unit id="d66bf08929fd5d420bb4c2ec86a67bddae583922" translate="yes" xml:space="preserve">
          <source>Obtaining and installing libnet</source>
          <target state="translated">libnetの入手とインストール</target>
        </trans-unit>
        <trans-unit id="da382120051949707a0c7beb67aab96ce623a328" translate="yes" xml:space="preserve">
          <source>Obviously the first of these will fail to distinguish most ASCII platforms from either a CCSID 0037, a 1047, or a POSIX-BC EBCDIC platform since &lt;code&gt;&quot;\r&quot; &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(13)&lt;/code&gt; under all of those coded character sets. But note too that because &lt;code&gt;&quot;\n&quot;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(13)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&quot;\r&quot;&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(10)&lt;/a&gt;&lt;/code&gt; on old Macintosh (which is an ASCII platform) the second &lt;code&gt;$is_ascii&lt;/code&gt; test will lead to trouble there.</source>
          <target state="translated">これらのコード化文字セットのすべてで &lt;code&gt;&quot;\r&quot; &lt;a href=&quot;functions/eq&quot;&gt;eq&lt;/a&gt; &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(13)&lt;/code&gt; となっているため、これらの最初のものは、ほとんどのASCIIプラットフォームをCCSID 0037、1047、またはPOSIX-BC EBCDICプラットフォームから区別できません。ただし、古いMacintosh（ASCIIプラットフォーム） &lt;code&gt;&quot;\n&quot;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(13)&lt;/a&gt;&lt;/code&gt; であり、 &lt;code&gt;&quot;\r&quot;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(10)&lt;/a&gt;&lt;/code&gt; であるため、2番目の &lt;code&gt;$is_ascii&lt;/code&gt; テストで問題が発生することにも注意してください。</target>
        </trans-unit>
        <trans-unit id="1d78b76872c5b56931c9b5c0301dbd8a6a7bb448" translate="yes" xml:space="preserve">
          <source>Obviously the first of these will fail to distinguish most ASCII platforms from either a CCSID 0037, a 1047, or a POSIX-BC EBCDIC platform since &lt;code&gt;&quot;\r&quot; eq chr(13)&lt;/code&gt; under all of those coded character sets. But note too that because &lt;code&gt;&quot;\n&quot;&lt;/code&gt; is &lt;code&gt;chr(13)&lt;/code&gt; and &lt;code&gt;&quot;\r&quot;&lt;/code&gt; is &lt;code&gt;chr(10)&lt;/code&gt; on old Macintosh (which is an ASCII platform) the second &lt;code&gt;$is_ascii&lt;/code&gt; test will lead to trouble there.</source>
          <target state="translated">明らかに、これらの最初のものは、ほとんどのASCIIプラットフォームをCCSID 0037、1047、またはPOSIX-BC EBCDICプラットフォームと区別できません。これは、これらすべてのコード化文字セットで &lt;code&gt;&quot;\r&quot; eq chr(13)&lt;/code&gt; が使用されているためです。ただし、古いMacintosh（ASCIIプラットフォーム） &lt;code&gt;&quot;\n&quot;&lt;/code&gt; は &lt;code&gt;chr(13)&lt;/code&gt; であり、 &lt;code&gt;&quot;\r&quot;&lt;/code&gt; は &lt;code&gt;chr(10)&lt;/code&gt; であるため、2回目の &lt;code&gt;$is_ascii&lt;/code&gt; テストで問題が発生することにも注意してください。</target>
        </trans-unit>
        <trans-unit id="bfc9e42e3d47c901ceac3b16df8f05113274fcf2" translate="yes" xml:space="preserve">
          <source>Obviously this assumes that it is possible to typecast a pointer to an unsigned long and vice versa, which frequently works but should not be taken as a universal law. - Now that we have this pointer the next question is: How can we put it to good use? We need a call to some C function where a pointer is expected. The read(2) system call comes to mind:</source>
          <target state="translated">明らかに、これは、それが頻繁に動作しますが、普遍的な法則として取られるべきではありませんが、符号なしロングへのポインタをタイプキャストすることが可能であることを前提としていますし、その逆もまた然りです。-今、我々はこのポインタを持っていることを次の質問です:どのように我々は良い使用にそれを置くことができますか?ポインタが期待されるC言語の関数を呼び出す必要があります。読み込み(2)のシステムコールが思い浮かびます。</target>
        </trans-unit>
        <trans-unit id="8622bcf5480e2dcfc1e93eb63bd84e889a59eca8" translate="yes" xml:space="preserve">
          <source>Obviously, bugs which include patches are best. If you prefer, you can patch against bleed by via anonymous checkout of the latest version:</source>
          <target state="translated">明らかに、パッチを含むバグは最高です。お好みであれば、最新版の匿名チェックアウトを経由してブリードに対してパッチを当てることができます。</target>
        </trans-unit>
        <trans-unit id="8ad2def711f61d8bfaa27f7b29de908193ec9688" translate="yes" xml:space="preserve">
          <source>Obviously, in the situation of the last type of the signature of an OS/2 API, it is must more convenient for the users if the failure is indicated by die()ing: one does not need to check $^E to know that something went wrong. If, however, this solution is not desirable by some reason, the code in question should reset $^E to 0 before making this OS/2 API call, so that the caller of this Perl-accessible function has a chance to distinguish a success-but-0-return value from a failure. (One may return undef as an alternative way of reporting an error.)</source>
          <target state="translated">明らかに、OS/2 APIのシグネチャの最後の型の状況では、失敗がdie()ingで示された方がユーザにとって便利であるに違いありません。しかし、何らかの理由でこの解決策が望ましくない場合、問題のコードは、このOS/2 API呼び出しを行う前に$^Eを0にリセットしなければなりません。(エラーを報告する別の方法として undef を返すこともできます)。</target>
        </trans-unit>
        <trans-unit id="d64ac810883d44e27969b0774d70505e74b53a16" translate="yes" xml:space="preserve">
          <source>Obviously, the second call to &lt;code&gt;complicated&lt;/code&gt; is a waste of time, and storing its return value is a waste of space. Specifying &lt;code&gt;LIST_CACHE
=&amp;gt; MERGE&lt;/code&gt; will make &lt;code&gt;memoize&lt;/code&gt; use the same cache for scalar and list context return values, so that the second call uses the scalar cache that was populated by the first call. &lt;code&gt;complicated&lt;/code&gt; ends up being called only once, and both subsequent calls return &lt;code&gt;3&lt;/code&gt; from the cache, regardless of the calling context.</source>
          <target state="translated">明らかに、2番目の呼び出し &lt;code&gt;complicated&lt;/code&gt; 時間の無駄であり、その戻り値を格納するスペースの無駄です。 &lt;code&gt;LIST_CACHE =&amp;gt; MERGE&lt;/code&gt; を指定すると、 &lt;code&gt;memoize&lt;/code&gt; はスカラーおよびリストコンテキストの戻り値に同じキャッシュを使用するため、2番目の呼び出しは最初の呼び出しによって入力されたスカラーキャッシュを使用します。 &lt;code&gt;complicated&lt;/code&gt; は1回だけ呼び出され、その後の両方の呼び出しは、呼び出しコンテキストに関係なく、キャッシュから &lt;code&gt;3&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="a86730e802eb4eb4e4acf92e33bec8c9303fc96c" translate="yes" xml:space="preserve">
          <source>Occasionally it is important to pass a reference to the object being tied to the TIESCALAR, TIEHASH, etc. that ties it.</source>
          <target state="translated">時折、それを結びつけるTIESCALAR、TIEHASHなどのオブジェクトへの参照を渡すことが重要になります。</target>
        </trans-unit>
        <trans-unit id="5cb8a483e38416f865c96e1886ae8adceb1b5292" translate="yes" xml:space="preserve">
          <source>Occasionally the programmer will want to return simply &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; or an empty list if a function fails rather than a separate status value. The rpcb_gettime() function offers just this situation. If the function succeeds we would like to have it return the time and if it fails we would like to have undef returned. In the following Perl code the value of $timep will either be undef or it will be a valid time.</source>
          <target state="translated">プログラマは、関数が失敗した場合に、個別のステータス値ではなく、単に &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; または空のリストを返したいことがあります。rpcb_gettime（）関数は、まさにこの状況を提供します。関数が成功した場合は時間を返し、失敗した場合はundefを返します。次のPerlコードでは、$ timepの値はundefであるか、有効な時間になります。</target>
        </trans-unit>
        <trans-unit id="0ea7d0ab3870cda5bd5d012242ed94c158dde1fa" translate="yes" xml:space="preserve">
          <source>Occasionally the programmer will want to return simply &lt;code&gt;undef&lt;/code&gt; or an empty list if a function fails rather than a separate status value. The rpcb_gettime() function offers just this situation. If the function succeeds we would like to have it return the time and if it fails we would like to have undef returned. In the following Perl code the value of $timep will either be undef or it will be a valid time.</source>
          <target state="translated">関数が失敗した場合、プログラマーは、個別のステータス値ではなく、単に &lt;code&gt;undef&lt;/code&gt; または空のリストを返したい場合があります。rpcb_gettime（）関数は、まさにこの状況を提供します。関数が成功した場合は時刻を返し、失敗した場合はundefを返します。次のPerlコードでは、$ timepの値はundefであるか、有効な時間になります。</target>
        </trans-unit>
        <trans-unit id="fca6836d0056140d86bcc04d81edeb7b7f85d973" translate="yes" xml:space="preserve">
          <source>Occasionally the strenuous efforts Attribute::Handlers makes to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt; ) to a usable form before passing it to the handler get in the way.</source>
          <target state="translated">たまにAttribute :: Handlersがデータ引数（ &lt;code&gt;$_[4]&lt;/code&gt; ）を使用可能な形式に変換してから、ハンドラーに渡して邪魔になることはあります。</target>
        </trans-unit>
        <trans-unit id="f13c9786193661170bf181a99c76dd0d6705b9c3" translate="yes" xml:space="preserve">
          <source>Occasionally the strenuous efforts Attribute::Handlers makes to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt;) to a usable form before passing it to the handler get in the way.</source>
          <target state="translated">時折、Attribute :: Handlersは、データ引数（ &lt;code&gt;$_[4]&lt;/code&gt; ）をハンドラーに渡す前に、使用可能な形式に変換するために多大な労力を費やします。</target>
        </trans-unit>
        <trans-unit id="3a1a8a18cac1b8ec9d036c1e95c86caa06823297" translate="yes" xml:space="preserve">
          <source>Occasionally, you can't use just a &lt;code&gt;/g&lt;/code&gt; to get all the changes to occur that you might want. Here are two common cases:</source>
          <target state="translated">場合によっては、 &lt;code&gt;/g&lt;/code&gt; だけを使用して、必要なすべての変更を発生させることはできません。次に2つの一般的なケースを示します。</target>
        </trans-unit>
        <trans-unit id="3642950c84185b95fade3aa22cda9a0e1954ee82" translate="yes" xml:space="preserve">
          <source>Oceania</source>
          <target state="translated">Oceania</target>
        </trans-unit>
        <trans-unit id="b5befcf80da75ec699a5c983fc36244ec375a0c0" translate="yes" xml:space="preserve">
          <source>Octal escapes</source>
          <target state="translated">オクタルリーク</target>
        </trans-unit>
        <trans-unit id="db84424f081d663bc203c1af1117e2bdc42e8773" translate="yes" xml:space="preserve">
          <source>Octal escapes of the &lt;code&gt;\000&lt;/code&gt; form outside of bracketed character classes potentially clash with old-style backreferences (see &lt;a href=&quot;#Absolute-referencing&quot;&gt;&quot;Absolute referencing&quot;&lt;/a&gt; below). They both consist of a backslash followed by numbers. So Perl has to use heuristics to determine whether it is a backreference or an octal escape. Perl uses the following rules to disambiguate:</source>
          <target state="translated">括弧で囲まれた文字クラスの外側の &lt;code&gt;\000&lt;/code&gt; 形式の8進エスケープは、古いスタイルの後方参照と衝突する可能性があります（以下の&lt;a href=&quot;#Absolute-referencing&quot;&gt;「絶対参照」を&lt;/a&gt;参照）。どちらも円記号とそれに続く数字で構成されています。したがって、Perlはヒューリスティックを使用して、それが後方参照であるか8進エスケープであるかを判別する必要があります。Perlは、次のルールを使用して明確にします。</target>
        </trans-unit>
        <trans-unit id="6d3bc0d39ae545ee26be05b556b7a8cf4ddc990b" translate="yes" xml:space="preserve">
          <source>Octal escapes of the &lt;code&gt;\000&lt;/code&gt; form outside of bracketed character classes potentially clash with old-style backreferences (see &lt;a href=&quot;#Absolute-referencing&quot;&gt;Absolute referencing&lt;/a&gt; below). They both consist of a backslash followed by numbers. So Perl has to use heuristics to determine whether it is a backreference or an octal escape. Perl uses the following rules to disambiguate:</source>
          <target state="translated">括弧で囲まれた文字クラスの外側にある &lt;code&gt;\000&lt;/code&gt; 形式の8進エスケープは、古いスタイルの後方参照と衝突する可能性があります（下記の&lt;a href=&quot;#Absolute-referencing&quot;&gt;絶対参照を&lt;/a&gt;参照）。どちらもバックスラッシュとそれに続く数字で構成されています。そのため、Perlはヒューリスティックを使用して、後方参照か8進エスケープかを判断する必要があります。Perlは、次のルールを使用して明確化します。</target>
        </trans-unit>
        <trans-unit id="87a50fff0e8349cdbe12625e1077c3ebe0fdfa7d" translate="yes" xml:space="preserve">
          <source>Octal number &amp;gt; 037777777777 non-portable</source>
          <target state="translated">8進数&amp;gt; 037777777777ポータブルではありません</target>
        </trans-unit>
        <trans-unit id="0bb34d0b5eb49bdff2904bd7acc2fa7d27c59806" translate="yes" xml:space="preserve">
          <source>Octal numbers are typically prefixed by &quot;0&quot;, but since leading zeros are stripped, these methods can not automatically recognize octal numbers, so use the constructor from_oct() to interpret octal strings.</source>
          <target state="translated">八進数は通常 &quot;0&quot; がプレフィックスとなっていますが、 先頭のゼロが取り除かれているため、これらのメソッドは自動的に八進数を認識することができないので、 八進数文字列を解釈するにはコンストラクタ from_oct()を使用します。</target>
        </trans-unit>
        <trans-unit id="8af566741591251972e43e0d36356b0e06a29bb7" translate="yes" xml:space="preserve">
          <source>Odd name/value argument for subroutine '%s'</source>
          <target state="translated">サブルーチン '%s' の奇数名/値引数です。</target>
        </trans-unit>
        <trans-unit id="65bda02e37792920d152c41b584876b2e10eb3c5" translate="yes" xml:space="preserve">
          <source>Odd number of arguments for overload::constant</source>
          <target state="translated">オーバーロード::定数の奇数の引数</target>
        </trans-unit>
        <trans-unit id="399492c4df4e28b7b58d749dc69161eed60f95f9" translate="yes" xml:space="preserve">
          <source>Odd number of elements in anonymous hash</source>
          <target state="translated">匿名ハッシュの奇数要素</target>
        </trans-unit>
        <trans-unit id="065c34a675ace7837e8fdf7122c9899906bd6b6e" translate="yes" xml:space="preserve">
          <source>Odd number of elements in hash assignment</source>
          <target state="translated">ハッシュ代入の要素数が奇数</target>
        </trans-unit>
        <trans-unit id="e8cc17f1e22c5e8c8c6d8e8b50d3e2d9acf218c8" translate="yes" xml:space="preserve">
          <source>Of course &lt;a href=&quot;cgi&quot;&gt;CGI&lt;/a&gt; and &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; will tell you more.</source>
          <target state="translated">もちろん、&lt;a href=&quot;cgi&quot;&gt;CGI&lt;/a&gt;と&lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9で詳細&lt;/a&gt;がわかります。</target>
        </trans-unit>
        <trans-unit id="001ed8e6a266e94752602c2df86a674e88e19c2d" translate="yes" xml:space="preserve">
          <source>Of course &lt;a href=&quot;http://search.cpan.org/perldoc/CGI&quot;&gt;CGI&lt;/a&gt; and &lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt; will tell you more.</source>
          <target state="translated">もちろん、&lt;a href=&quot;http://search.cpan.org/perldoc/CGI&quot;&gt;CGI&lt;/a&gt;と&lt;a href=&quot;perlfaq9&quot;&gt;perlfaq9&lt;/a&gt;はもっと詳しく教えてくれます。</target>
        </trans-unit>
        <trans-unit id="814879db219b87492dd375dcf6f869266e936b99" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;Moose&lt;/code&gt; isn't perfect.</source>
          <target state="translated">もちろん、 &lt;code&gt;Moose&lt;/code&gt; は完璧ではありません。</target>
        </trans-unit>
        <trans-unit id="733d5b43433c0be3dd395c3e52526830c10b5e3c" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;vianame&lt;/code&gt; , &lt;code&gt;viacode&lt;/code&gt; , and &lt;code&gt;string_vianame&lt;/code&gt; would need to be overridden as well.</source>
          <target state="translated">もちろん、 &lt;code&gt;vianame&lt;/code&gt; 、 &lt;code&gt;viacode&lt;/code&gt; 、および &lt;code&gt;string_vianame&lt;/code&gt; もオーバーライドする必要があります。</target>
        </trans-unit>
        <trans-unit id="e69acfd1f99778b500da1a17ef29d78b995fb659" translate="yes" xml:space="preserve">
          <source>Of course, &lt;code&gt;vianame&lt;/code&gt;, &lt;code&gt;viacode&lt;/code&gt;, and &lt;code&gt;string_vianame&lt;/code&gt; would need to be overridden as well.</source>
          <target state="translated">もちろん、 &lt;code&gt;vianame&lt;/code&gt; 、 &lt;code&gt;viacode&lt;/code&gt; 、 &lt;code&gt;string_vianame&lt;/code&gt; もオーバーライドする必要があります。</target>
        </trans-unit>
        <trans-unit id="03c6e1d7d58bd1d130be768a05a694a94d3aba2b" translate="yes" xml:space="preserve">
          <source>Of course, here too, Filter::Simple has to know you're using Exporter before it applies the filter. That's almost never a problem, but if you're nervous about it, you can guarantee that things will work correctly by ensuring that your &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; base Exporter&lt;/code&gt; always precedes your &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; .</source>
          <target state="translated">もちろん、ここでもFilter :: Simpleは、フィルターを適用する前にエクスポーターを使用していることを認識している必要があります。これは、問題はほとんどないのですが、それについてあなたがしている神経質ならば、あなたは物事があなたのことを確実にすることにより、正常に動作することを保証することができ &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; base Exporter&lt;/code&gt; 常にあなたの前に &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Filter::Simple&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4302a9cf5fbe5aa02395c1781d6a9233de7d01db" translate="yes" xml:space="preserve">
          <source>Of course, here too, Filter::Simple has to know you're using Exporter before it applies the filter. That's almost never a problem, but if you're nervous about it, you can guarantee that things will work correctly by ensuring that your &lt;code&gt;use base Exporter&lt;/code&gt; always precedes your &lt;code&gt;use Filter::Simple&lt;/code&gt;.</source>
          <target state="translated">もちろん、ここでも、Filter :: Simpleは、フィルターを適用する前に、エクスポーターを使用していることを認識している必要があります。これが問題になることはほとんどありませんが、神経質な場合は、 &lt;code&gt;use base Exporter&lt;/code&gt; 常に &lt;code&gt;use Filter::Simple&lt;/code&gt; 前にあることを確認することで、問題が正しく機能することを保証できますFilter :: Simple。</target>
        </trans-unit>
        <trans-unit id="ab33e7ed924208df5f517b6f58635c94da06be71" translate="yes" xml:space="preserve">
          <source>Of course, if &lt;code&gt;@ISA&lt;/code&gt; contained only &lt;code&gt;DynaLoader&lt;/code&gt; , there is no need to have the &lt;code&gt;@ISA&lt;/code&gt; assignment at all; moreover, if instead of &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; one uses the more backward-compatible</source>
          <target state="translated">場合はもちろん、 &lt;code&gt;@ISA&lt;/code&gt; はのみ含ま &lt;code&gt;DynaLoader&lt;/code&gt; やを、持っている必要はありません &lt;code&gt;@ISA&lt;/code&gt; のすべての割り当ては、さらに、 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 代わりに、より下位互換性のある</target>
        </trans-unit>
        <trans-unit id="1eafec21d0ff2371b83827a03c0ee4872c0478b3" translate="yes" xml:space="preserve">
          <source>Of course, if &lt;code&gt;@ISA&lt;/code&gt; contained only &lt;code&gt;DynaLoader&lt;/code&gt;, there is no need to have the &lt;code&gt;@ISA&lt;/code&gt; assignment at all; moreover, if instead of &lt;code&gt;our&lt;/code&gt; one uses the more backward-compatible</source>
          <target state="translated">場合はもちろん、 &lt;code&gt;@ISA&lt;/code&gt; はのみ含ま &lt;code&gt;DynaLoader&lt;/code&gt; やを、持っている必要はありません &lt;code&gt;@ISA&lt;/code&gt; のすべての割り当ては、さらに、 &lt;code&gt;our&lt;/code&gt; 代わりに、より下位互換性のあるものを使用する場合</target>
        </trans-unit>
        <trans-unit id="5fe9b52519ed5e683419d8b8de5fb62a2cea4185" translate="yes" xml:space="preserve">
          <source>Of course, if the class name is in a scalar Perl will do the right thing as well:</source>
          <target state="translated">もちろん、クラス名がスカラーであれば、Perlも同様に正しいことをします。</target>
        </trans-unit>
        <trans-unit id="d886edfc3d346b2f618c821d88c4f77af2ec29fb" translate="yes" xml:space="preserve">
          <source>Of course, if you simply follow the guidelines in &lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;, you shouldn't need to reformat. The habit of formatting your code as you write it will help prevent bugs. Your editor can and should help you with this. The perl-mode or newer cperl-mode for emacs can provide remarkable amounts of help with most (but not all) code, and even less programmable editors can provide significant assistance. Tom Christiansen and many other VI users swear by the following settings in vi and its clones:</source>
          <target state="translated">もちろん、単に&lt;a href=&quot;perlstyle&quot;&gt;perlstyle&lt;/a&gt;のガイドラインに従うだけであれば、再フォーマットする必要はありません。コードを記述しながらフォーマットする習慣は、バグの防止に役立ちます。あなたの編集者はこれであなたを助けることができ、そうすべきです。 emacsのperl-modeまたはより新しいcperl-modeは、ほとんど（すべてではない）のコードで驚くほどの量のヘルプを提供でき、プログラムの少ないエディターでも大幅な支援を提供できます。トムクリスチャンセンと他の多くのVIユーザーは、viとそのクローンの次の設定を誓います。</target>
        </trans-unit>
        <trans-unit id="abb07ecb376ea8ffb38769be127701645f4d0359" translate="yes" xml:space="preserve">
          <source>Of course, in contexts like, for example, &lt;code&gt;$obj + 1&lt;/code&gt; , Perl will invoke &lt;code&gt;$obj&lt;/code&gt; 's implementation of &lt;code&gt;+&lt;/code&gt; rather than (in this example) converting &lt;code&gt;$obj&lt;/code&gt; to a number using the numify method &lt;code&gt;'0+'&lt;/code&gt; (an exception to this is when no method has been provided for &lt;code&gt;'+'&lt;/code&gt; and &lt;a href=&quot;#fallback&quot;&gt;fallback&lt;/a&gt; is set to TRUE).</source>
          <target state="translated">もちろん、のような状況において、例えば、 &lt;code&gt;$obj + 1&lt;/code&gt; 、Perlが起動します &lt;code&gt;$obj&lt;/code&gt; の実装 &lt;code&gt;+&lt;/code&gt; 変換（この例では）ではなく &lt;code&gt;$obj&lt;/code&gt; numify法を用い番号に &lt;code&gt;'0+'&lt;/code&gt; （例外にしますこれは、 &lt;code&gt;'+'&lt;/code&gt; メソッドが指定されておらず、&lt;a href=&quot;#fallback&quot;&gt;フォールバック&lt;/a&gt;がTRUEに設定されている場合です。</target>
        </trans-unit>
        <trans-unit id="e64305345caaad0c4dd212ba7ea682cb2c014fca" translate="yes" xml:space="preserve">
          <source>Of course, in contexts like, for example, &lt;code&gt;$obj + 1&lt;/code&gt;, Perl will invoke &lt;code&gt;$obj&lt;/code&gt;'s implementation of &lt;code&gt;+&lt;/code&gt; rather than (in this example) converting &lt;code&gt;$obj&lt;/code&gt; to a number using the numify method &lt;code&gt;'0+'&lt;/code&gt; (an exception to this is when no method has been provided for &lt;code&gt;'+'&lt;/code&gt; and &lt;a href=&quot;#fallback&quot;&gt;&quot;fallback&quot;&lt;/a&gt; is set to TRUE).</source>
          <target state="translated">もちろん、のような状況において、例えば、 &lt;code&gt;$obj + 1&lt;/code&gt; 、Perlが起動します &lt;code&gt;$obj&lt;/code&gt; の実装 &lt;code&gt;+&lt;/code&gt; 変換（この例では）ではなく &lt;code&gt;$obj&lt;/code&gt; numify法を用い番号に &lt;code&gt;'0+'&lt;/code&gt; （例外にしますこれは、 &lt;code&gt;'+'&lt;/code&gt; メソッドが提供されておらず、&lt;a href=&quot;#fallback&quot;&gt;「フォールバック」&lt;/a&gt;がTRUEに設定されている場合です。</target>
        </trans-unit>
        <trans-unit id="837c1a0c6d4394993c9260f47b27824bf6031d2f" translate="yes" xml:space="preserve">
          <source>Of course, in the case of a literal string, one could just as easily use the string comparison &lt;code&gt;$string eq 'bert'&lt;/code&gt; and it would be more efficient. The &lt;code&gt;^...$&lt;/code&gt; regexp really becomes useful when we add in the more powerful regexp tools below.</source>
          <target state="translated">もちろん、リテラル文字列の場合、文字列比較 &lt;code&gt;$string eq 'bert'&lt;/code&gt; と同じくらい簡単に使用でき、より効率的です。 &lt;code&gt;^...$&lt;/code&gt; 我々は、以下でより強力な正規表現ツールに追加したときに正規表現は本当に便利になります。</target>
        </trans-unit>
        <trans-unit id="27457c444325a83774ce245c93383c8862b5cc3d" translate="yes" xml:space="preserve">
          <source>Of course, in this module-author's humble opinion, I'd be more inclined to use the existing &lt;b&gt;Pod::ParseTree&lt;/b&gt; object than a simple array. That way everything in it, paragraphs and sequences, all respond to the same core interface for all parse-tree nodes. The result would look something like:</source>
          <target state="translated">もちろん、このモジュール作成者の控えめな意見では、単純な配列よりも既存の&lt;b&gt;Pod :: ParseTree&lt;/b&gt;オブジェクトを使用する傾向があります。そうすることで、その中のすべて、段落およびシーケンスは、すべての解析ツリーノードの同じコアインターフェースに応答します。結果は次のようになります。</target>
        </trans-unit>
        <trans-unit id="11fde9a92a2449ce2e35bf1f4b5fe24a02e9e7d2" translate="yes" xml:space="preserve">
          <source>Of course, it is important to choose the right separator string for each purpose.</source>
          <target state="translated">もちろん、目的に応じて適切な区切り文字列を選ぶことが大切です。</target>
        </trans-unit>
        <trans-unit id="dc54d65f65f6922d956316c79b1323c206e201c5" translate="yes" xml:space="preserve">
          <source>Of course, it's up to you to decide whether or not to ignore them.</source>
          <target state="translated">もちろん、無視するかどうかはあなた次第です。</target>
        </trans-unit>
        <trans-unit id="d78604b940d2c66d71607feff9316d4ae5a87f26" translate="yes" xml:space="preserve">
          <source>Of course, one could write such glue code directly in C. However, this would be a tedious task, especially if one needs to write glue for multiple C functions, and/or one is not familiar enough with the Perl stack discipline and other such arcana. XS comes to the rescue here: instead of writing this glue C code in long-hand, one can write a more concise short-hand</source>
          <target state="translated">もちろん、このようなグルーコードを直接C言語で書くこともできますが、特に複数のC言語の関数のためにグルーを書く必要があったり、Perlのスタック規律などの知識が不足していたりすると、面倒な作業になってしまいます。XSはここで助けてくれます:このようなC言語でのグルーコードを長文で書くのではなく、より簡潔な短文の</target>
        </trans-unit>
        <trans-unit id="77c72cea76e3d8ea1cda06ed844191d48368487d" translate="yes" xml:space="preserve">
          <source>Of course, test #1 is $tests[0], etc...</source>
          <target state="translated">もちろん、テスト#1は$tests[0]など。</target>
        </trans-unit>
        <trans-unit id="de9f73990ad276e504276095781c4201fd0583f9" translate="yes" xml:space="preserve">
          <source>Of course, the best way to save memory is to not do anything to waste it in the first place. Good programming practices can go a long way toward this:</source>
          <target state="translated">もちろん、メモリを節約する最善の方法は、そもそもメモリを無駄にするようなことをしないことです。良いプログラミングの実践は、これに向けて長い道のりを歩むことができます。</target>
        </trans-unit>
        <trans-unit id="b974b206a7b1862c93ebd148bc1b83add3324aa2" translate="yes" xml:space="preserve">
          <source>Of course, this</source>
          <target state="translated">もちろん、これは</target>
        </trans-unit>
        <trans-unit id="5788145c5ae3423e71b1d5b7f96f5fcb341edfab" translate="yes" xml:space="preserve">
          <source>Of course, this requires that the underlying call supports buffers. See the note on buffers above.</source>
          <target state="translated">もちろん、これは基礎となるコールがバッファをサポートしている必要があります。上記のバッファに関する注意事項を参照してください。</target>
        </trans-unit>
        <trans-unit id="357e4c4fc94af540a4f74537a6571078de606e56" translate="yes" xml:space="preserve">
          <source>Of course, typing in your own password to whoever asks you for it is unwise.</source>
          <target state="translated">もちろん、誰に聞かれても自分のパスワードを入力するのは賢明ではありません。</target>
        </trans-unit>
        <trans-unit id="aaa47fc8bd024bc87e7c8490eb46dddef3e8914d" translate="yes" xml:space="preserve">
          <source>Of course, unless you know the number of elements in the &lt;code&gt;sometype **&lt;/code&gt; C array, within your XSUB, the return value from &lt;code&gt;foo_t ** XS_unpack_foo_tPtrPtr(...)&lt;/code&gt; will be hard to decipher. Since the details are all up to the XS author (the typemap user), there are several solutions, none of which particularly elegant. The most commonly seen solution has been to allocate memory for N+1 pointers and assign &lt;code&gt;NULL&lt;/code&gt; to the (N+1)th to facilitate iteration.</source>
          <target state="translated">もちろん、XSUB内の &lt;code&gt;sometype **&lt;/code&gt; C配列の要素数がわからない限り、 &lt;code&gt;foo_t ** XS_unpack_foo_tPtrPtr(...)&lt;/code&gt; からの戻り値は解読が難しくなります。詳細はすべてXSの作成者（タイプマップユーザー）に委ねられているため、いくつかの解決策がありますが、どれも特にエレガントではありません。最も一般的に見られる解決策は、N + 1ポインタにメモリを割り当て、反復を容易にするためにN + 1番目に &lt;code&gt;NULL&lt;/code&gt; を割り当てることです。</target>
        </trans-unit>
        <trans-unit id="edd8408b88d74e19ec1265ebd83f3cd07501b352" translate="yes" xml:space="preserve">
          <source>Of course, unless your OS does not implement access(), in which case the pragma is simply ignored. Best not to use &lt;code&gt;_&lt;/code&gt; at all in a file where the filetest pragma is active!</source>
          <target state="translated">もちろん、OSがaccess（）を実装していない場合を除き、その場合、プラグマは単に無視されます。filetestプラグマがアクティブなファイルでは、 &lt;code&gt;_&lt;/code&gt; をまったく使用しないことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="abd96d1d300bf4e8daac5b50f895feff0cad5891" translate="yes" xml:space="preserve">
          <source>Of course, variables that are UTF-8 and are referred to in the string retain that:</source>
          <target state="translated">もちろん、UTF-8で、文字列の中で参照される変数はそれを保持します。</target>
        </trans-unit>
        <trans-unit id="ce5481b8a258de1ea18c7a9b1b7f4086fab8bc96" translate="yes" xml:space="preserve">
          <source>Of course, you can also choose to import specific functions by name, as usual.</source>
          <target state="translated">もちろん、いつものように特定の機能を名前でインポートすることもできます。</target>
        </trans-unit>
        <trans-unit id="f9a595714c023a195e48ee401212d01b31493781" translate="yes" xml:space="preserve">
          <source>Of course, you don't need the temporary array to have a name at all:</source>
          <target state="translated">もちろん、一時配列に名前をつける必要は全くありません。</target>
        </trans-unit>
        <trans-unit id="fb6f67a6165dc8bfd66e5ae946dbcf7584578eef" translate="yes" xml:space="preserve">
          <source>Of the conversions, only one of string, boolean or numeric is needed because each can be generated from either of the other two.</source>
          <target state="translated">変換のうち,文字列,ブール値,数値のいずれか1つだけが必要です。</target>
        </trans-unit>
        <trans-unit id="f521e0762b4294067b640a105aa4f9fd48ea8238" translate="yes" xml:space="preserve">
          <source>Of these properties, the two important ones are Pattern_Syntax and Pattern_White_Space. They have been set up by Unicode for exactly this purpose of deciding which characters in a regular expression pattern should be quoted. No character that can be in an identifier has these properties.</source>
          <target state="translated">これらのプロパティのうち、2つの重要なものはPattern_SyntaxとPattern_White_Spaceです。これらは、正規表現パターンの中のどの文字が引用されるべきかを決定するという、まさにこの目的のためにUnicodeによって設定されています。識別子の中にあるどの文字もこれらのプロパティを持っていません。</target>
        </trans-unit>
        <trans-unit id="c77879f95662f28e94653e74a629782adc3eeac4" translate="yes" xml:space="preserve">
          <source>Official home page for the ISO 3166 maintenance agency.</source>
          <target state="translated">ISO3166整備機関の公式ホームページ。</target>
        </trans-unit>
        <trans-unit id="967fc19002ed71d08a174f5ecc4259363a549385" translate="yes" xml:space="preserve">
          <source>Official source of the top-level domain names.</source>
          <target state="translated">トップレベルドメイン名の公式ソース。</target>
        </trans-unit>
        <trans-unit id="3c0ccf7d9a2c2c9e1eedbe4cef2e4d0413088708" translate="yes" xml:space="preserve">
          <source>Offline sources</source>
          <target state="translated">オフラインソース</target>
        </trans-unit>
        <trans-unit id="78b00389e2960ae2ee90ec24a50a5ce42fa29d6d" translate="yes" xml:space="preserve">
          <source>Offset outside string</source>
          <target state="translated">文字列外のオフセット</target>
        </trans-unit>
        <trans-unit id="20daff2f32d6074bbb2255376c7a89b965519ab3" translate="yes" xml:space="preserve">
          <source>Offsets</source>
          <target state="translated">Offsets</target>
        </trans-unit>
        <trans-unit id="6a7926e00c1d5044bed78664357be7137c40f3e0" translate="yes" xml:space="preserve">
          <source>Offsets holds a mapping of offset in the &lt;code&gt;program&lt;/code&gt; to offset in the &lt;code&gt;precomp&lt;/code&gt; string. This is only used by ActiveState's visual regex debugger.</source>
          <target state="translated">オフセットは、 &lt;code&gt;precomp&lt;/code&gt; 文字列のオフセットへの &lt;code&gt;program&lt;/code&gt; のオフセットのマッピングを保持します。これは、ActiveStateのビジュアルregexデバッガーでのみ使用されます。</target>
        </trans-unit>
        <trans-unit id="43d26f6f08e88e91bca4bafe94301f7c42d03d67" translate="yes" xml:space="preserve">
          <source>Often it is useful to allow comma-separated lists of values as well as multiple occurrences of the options. This is easy using Perl's split() and join() operators:</source>
          <target state="translated">コンマで区切られた値のリストや、オプションの複数回の出現を許可することが便利なことがよくあります。これはPerlのsplit()とjoin()演算子を使えば簡単です。</target>
        </trans-unit>
        <trans-unit id="632c3362322ab6672e961b19c05b72785cd26d84" translate="yes" xml:space="preserve">
          <source>Often it is user friendly to supply alternate mnemonic names for options. For example &lt;code&gt;--height&lt;/code&gt; could be an alternate name for &lt;code&gt;--&lt;a href=&quot;../functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; . Alternate names can be included in the option specification, separated by vertical bar &lt;code&gt;|&lt;/code&gt; characters. To implement the above example:</source>
          <target state="translated">多くの場合、オプションの代替ニーモニック名を指定するとユーザーフレンドリーになります。例えば &lt;code&gt;--height&lt;/code&gt; での代替名かもしれない &lt;code&gt;--&lt;a href=&quot;../functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; 。オプションの指定には、縦棒で区切って代替名を含めることができます &lt;code&gt;|&lt;/code&gt; 文字。上記の例を実装するには：</target>
        </trans-unit>
        <trans-unit id="7de86d17804fa632d98b8911860a7e7fb8a9bded" translate="yes" xml:space="preserve">
          <source>Often it is user friendly to supply alternate mnemonic names for options. For example &lt;code&gt;--height&lt;/code&gt; could be an alternate name for &lt;code&gt;--length&lt;/code&gt;. Alternate names can be included in the option specification, separated by vertical bar &lt;code&gt;|&lt;/code&gt; characters. To implement the above example:</source>
          <target state="translated">多くの場合、オプションに代替ニーモニック名を指定するとユーザーフレンドリーです。たとえば、 &lt;code&gt;--height&lt;/code&gt; は--lengthの代替名に &lt;code&gt;--length&lt;/code&gt; ます。代替名は、縦棒で区切ってオプション仕様に含めることができます &lt;code&gt;|&lt;/code&gt; 文字。上記の例を実装するには：</target>
        </trans-unit>
        <trans-unit id="413285a912f30dbf718e8f5cd58feece5f266f30" translate="yes" xml:space="preserve">
          <source>Often there will be another error message associated with the syntax error giving more information. (Sometimes it helps to turn on &lt;b&gt;-w&lt;/b&gt;.) The error message itself often tells you where it was in the line when it decided to give up. Sometimes the actual error is several tokens before this, because Perl is good at understanding random input. Occasionally the line number may be misleading, and once in a blue moon the only way to figure out what's triggering the error is to call &lt;code&gt;perl -c&lt;/code&gt; repeatedly, chopping away half the program each time to see if the error went away. Sort of the cybernetic version of 20 questions.</source>
          <target state="translated">多くの場合、より多くの情報を提供する構文エラーに関連する別のエラーメッセージが表示されます。（&lt;b&gt;-w&lt;/b&gt;をオンにすると役立つ場合があります。）エラーメッセージ自体は、多くの場合、あきらめることにしたときの行のどこにあるかを示します。Perlはランダム入力の理解に優れているため、実際のエラーはこれより前にいくつかのトークンになる場合があります。時折、行番号が誤解を招く可能性があります。ブルームーンに一度エラーを引き起こしている原因を特定する唯一の方法は、 &lt;code&gt;perl -c&lt;/code&gt; を繰り返し呼び出し、毎回プログラムの半分を切り取ってエラーが消えたかどうかを確認することです。20問のサイバネティックバージョンの並べ替え。</target>
        </trans-unit>
        <trans-unit id="fe51516899ec526908e4919457333ab9ef798f50" translate="yes" xml:space="preserve">
          <source>Often you want to manually set the $VERSION in the main module distribution because this is the version that everybody sees on CPAN and maybe you want to customize it a bit. But for all the other modules in your dist, $VERSION is really just bookkeeping and all that's important is it goes up every time the module is changed. Doing this by hand is a pain and you often forget.</source>
          <target state="translated">多くの場合、メインモジュールのディストリビューションで $VERSION を手動で設定したいことがあります。しかし、あなたの dist 内の他のすべてのモジュールについては、$VERSION は単なる簿記であり、重要なのはモジュールが変更されるたびに値が上がっていくことだけです。これを手作業で行うのは面倒で、忘れてしまうことが多いです。</target>
        </trans-unit>
        <trans-unit id="a8e3c059f398572879c5f613bbb88d9e476377a9" translate="yes" xml:space="preserve">
          <source>Oh, hmm. That didn't quite work. Let's see what happened:</source>
          <target state="translated">ああ、うーん。うまくいかなかったな どうなったか見てみよう。</target>
        </trans-unit>
        <trans-unit id="2c053114f243927de5bf7cd77c45af1c27a14806" translate="yes" xml:space="preserve">
          <source>Oh, one final bit of advice: take &lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt; with you. When you return we expect to see it well-thumbed.</source>
          <target state="translated">ああ、最後のアドバイス：&lt;a href=&quot;../perlguts&quot;&gt;perlguts&lt;/a&gt;をあなたと一緒に持ち歩こう。あなたが戻ったとき、私たちはそれがうまく利用されていることを期待しています。</target>
        </trans-unit>
        <trans-unit id="6e84377d7eb2428d1c7c2ce684cd3d38c4564c15" translate="yes" xml:space="preserve">
          <source>Oh, one final bit of advice: take &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; with you. When you return we expect to see it well-thumbed.</source>
          <target state="translated">ああ、最後のアドバイスです&lt;a href=&quot;perlguts&quot;&gt;。perlgutsを&lt;/a&gt;持っていきましょう。あなたが戻ったとき、私たちはそれがよく考えられているのを見ることを期待しています。</target>
        </trans-unit>
        <trans-unit id="306452191398ef5d817db7561b984ed6863ccdd5" translate="yes" xml:space="preserve">
          <source>Ok event type</source>
          <target state="translated">イベントタイプ</target>
        </trans-unit>
        <trans-unit id="f40dabdf47b8a6942bfc67e5bc1a841348e34c6a" translate="yes" xml:space="preserve">
          <source>Ok events are generated whenever you run a test that produces a result. Examples are &lt;code&gt;ok()&lt;/code&gt;, and &lt;code&gt;is()&lt;/code&gt;.</source>
          <target state="translated">結果を生成するテストを実行するたびに、OKイベントが生成されます。例としては、 &lt;code&gt;ok()&lt;/code&gt; 、 &lt;code&gt;is()&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="8773501dbe9f64eda9a34f3bd611a37f1791691b" translate="yes" xml:space="preserve">
          <source>Ok, but how about when you want to really see your data, what's in that dynamic variable, just before using it?</source>
          <target state="translated">しかし、実際にデータを見たい場合はどうでしょうか?動的変数の中に何が入っているのか、それを使う直前に?</target>
        </trans-unit>
        <trans-unit id="94213f220b40a7c6524e04580b008b30cdf470cf" translate="yes" xml:space="preserve">
          <source>Ok, so that's not very interesting, because it didn't find that particular document. But a long response wouldn't have fit on this page.</source>
          <target state="translated">OK、だからそれはあまり面白くありません、それはその特定の文書を見つけられなかったからです。しかし、長い回答はこのページには収まりませんでした。</target>
        </trans-unit>
        <trans-unit id="98a944759b5b6a428ccfa37e9a4506cd2b44afa1" translate="yes" xml:space="preserve">
          <source>Ok, so there can be more than one Test::Builder object and this is how you get it. You might use this instead of &lt;code&gt;new()&lt;/code&gt; if you're testing a Test::Builder based module, but otherwise you probably want &lt;code&gt;new&lt;/code&gt; .</source>
          <target state="translated">OK、それで複数のTest :: Builderオブジェクトが存在する可能性があり、これがあなたがそれを取得する方法です。Test :: Builderベースのモジュールをテストしている場合は &lt;code&gt;new()&lt;/code&gt; の代わりにこれを使用できますが、それ以外の場合はおそらく &lt;code&gt;new&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="eaf90bfe09c59916d02cd27cf9c5113342a8704b" translate="yes" xml:space="preserve">
          <source>Ok, so there can be more than one Test::Builder object and this is how you get it. You might use this instead of &lt;code&gt;new()&lt;/code&gt; if you're testing a Test::Builder based module, but otherwise you probably want &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">わかりました。複数のTest :: Builderオブジェクトが存在する可能性があり、これがその取得方法です。Test :: Builderベースのモジュールをテストしている場合は、 &lt;code&gt;new()&lt;/code&gt; の代わりにこれを使用できますが、それ以外の場合は、おそらく &lt;code&gt;new&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="6a981471d54adab918cf9e98c713f3fa8b6a31b7" translate="yes" xml:space="preserve">
          <source>Okay, concision isn't a buzzword. But it should be, so I decree that as a new buzzword, &quot;concision&quot; means that simple common things should be expressible in very few lines (or maybe even just a few characters) of code -- call it a special case of &quot;making simple things easy and hard things possible&quot;, and see also the role it played in the MIDI::Simple language, discussed elsewhere in this issue [TPJ#13].</source>
          <target state="translated">さて、コンシジョンは流行語ではありません。それを「簡単なことを簡単に、難しいことを可能にする」という特別なケースと呼んでください。また、この号[TPJ#13]の別の場所で議論されているMIDI::Simple言語での役割もご覧ください。</target>
        </trans-unit>
        <trans-unit id="f313a2347a7e1b7519ec6e24bd0468d6b0162bc3" translate="yes" xml:space="preserve">
          <source>Okay, if you insist: the &quot;internal format&quot; is utf8, not UTF-8. (When it's not some other encoding.)</source>
          <target state="translated">さて、もしあなたが主張するなら:&quot;内部フォーマット &quot;はUTF-8ではなくutf8です。(他のエンコーディングではない場合)</target>
        </trans-unit>
        <trans-unit id="c04bc9d828571306fd8ab607e050385638b7b499" translate="yes" xml:space="preserve">
          <source>Olaf Alders &amp;lt;olaf@wundersolutions.com&amp;gt;</source>
          <target state="translated">オラフアルダース&amp;lt;olaf@wundersolutions.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="a1f111382df51fd175ea0dd918cefd5d91a357cd" translate="yes" xml:space="preserve">
          <source>Old byte-oriented programs should magically start working on the new character-oriented data when appropriate.</source>
          <target state="translated">古いバイト指向のプログラムは、適切な場合には、新しい文字指向のデータで魔法のように作業を開始する必要があります。</target>
        </trans-unit>
        <trans-unit id="484e0a4f10a1f76d63b7cbe120323d7095b0f174" translate="yes" xml:space="preserve">
          <source>Old byte-oriented programs should not spontaneously break on the old byte-oriented data they used to work on.</source>
          <target state="translated">古いバイト系のプログラムは、それまで作業していた古いバイト系のデータで自発的に壊れてはいけません。</target>
        </trans-unit>
        <trans-unit id="cdcb679c21ad16ffb1a74358af64068b9c8c43d4" translate="yes" xml:space="preserve">
          <source>Old package separator used in string</source>
          <target state="translated">文字列で使用される古いパッケージセパレータ</target>
        </trans-unit>
        <trans-unit id="ae5d8d02aa4909a49747784b849d74c7097909f2" translate="yes" xml:space="preserve">
          <source>Old perl executable is started when a new executable is running has loaded an extension compiled for the old executable (ouph!). In this case the old executable will get a forwarder DLL instead of the old perl DLL, so would link with the new perl DLL. While not directly fatal, it will behave the same as new executable. This beats the whole purpose of explicitly starting an old executable.</source>
          <target state="translated">古いperlの実行ファイルは、新しい実行ファイルが実行されているときに、古い実行ファイル用にコンパイルされた拡張機能がロードされたときに起動されます(ouph!)この場合、古い実行ファイルは古いperl DLLの代わりにフォワーダーDLLを取得するので、新しいperl DLLとリンクします。直接的には致命的ではありませんが、新しい実行ファイルと同じように動作します。これは、古い実行ファイルを明示的に起動することの全目的を打ち負かしています。</target>
        </trans-unit>
        <trans-unit id="fc1b9547dcacdd8deb0b3a992300248da0a808c5" translate="yes" xml:space="preserve">
          <source>Old versions need to directly access Test::Builder singleton hash elements. The latest version on CPAN will still do this on old Test::Builder, but will defer to &lt;a href=&quot;Test2::IPC&quot;&gt;Test2::IPC&lt;/a&gt; on Test2.</source>
          <target state="translated">古いバージョンは、Test :: Builderシングルトンハッシュ要素に直接アクセスする必要があります。CPANの最新バージョンは、古いTest :: Builderでもこれを実行しますが、&lt;a href=&quot;Test2::IPC&quot;&gt;Test2ではTest2 :: IPC&lt;/a&gt;に従います。</target>
        </trans-unit>
        <trans-unit id="d5e1c2932ecab8fa2b7abd4c5ef42f132f0546a7" translate="yes" xml:space="preserve">
          <source>Old versions work fine, but have a minor test name behavior that breaks with Test2. Old versions will no longer install because of this. The latest version on CPAN will install just fine. Upgrading is not required, but is recommended.</source>
          <target state="translated">古いバージョンでは問題なく動作しますが、Test2ではテスト名の動作がおかしくなります。このため、古いバージョンはインストールできなくなります。CPAN上の最新バージョンでも問題なくインストールできます。アップグレードは必須ではありませんが、お勧めします。</target>
        </trans-unit>
        <trans-unit id="686b6b48ccfd93fda8d202b7ab00cb50bff77185" translate="yes" xml:space="preserve">
          <source>Old versions work fine, but would not install because &lt;a href=&quot;Test::Aggregate&quot;&gt;Test::Aggregate&lt;/a&gt; was in the dependency chain. An upgrade should not be needed.</source>
          <target state="translated">古いバージョンは正常に動作しますが、&lt;a href=&quot;Test::Aggregate&quot;&gt;Test :: Aggregate&lt;/a&gt;が依存関係チェーンに含まれていたため、インストールされませんでした。アップグレードは必要ありません。</target>
        </trans-unit>
        <trans-unit id="b4065d89a2f43100a5cf55aa7a52797bb4059e14" translate="yes" xml:space="preserve">
          <source>Old-style versus new-style block names</source>
          <target state="translated">旧式と新式のブロック名</target>
        </trans-unit>
        <trans-unit id="69d1a0ab771940cdc9cc69797ad23f167d7d2a58" translate="yes" xml:space="preserve">
          <source>Oldconfig.U</source>
          <target state="translated">Oldconfig.U</target>
        </trans-unit>
        <trans-unit id="0f656bb21c786456d378ff0e1756c02c791362d3" translate="yes" xml:space="preserve">
          <source>Older documentation (and some CPAN modules) encouraged this syntax, particularly for constructors, so you may still find it in the wild. However, we encourage you to avoid using it in new code.</source>
          <target state="translated">古いドキュメント (およびいくつかの CPAN モジュール)では、特にコンストラクタに対してこの構文を推奨しています。しかし、新しいコードではこの構文を使用しないことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="74bfa7b0d7fbfaf100a04613f263acdd445ac2c9" translate="yes" xml:space="preserve">
          <source>Older releases of VOS (prior to OpenVOS Release 17.0) limit file names to 32 or fewer characters, prohibit file names from starting with a &lt;code&gt;-&lt;/code&gt; character, and prohibit file names from containing  (space) or any character from the set &lt;code&gt;!#%&amp;amp;'()*;&amp;lt;=&amp;gt;?&lt;/code&gt;.</source>
          <target state="translated">VOSの古いリリース（OpenVOSリリース17.0より前）では、ファイル名が32文字以下に制限され、ファイル名が &lt;code&gt;-&lt;/code&gt; 文字で始まることを禁止し、ファイル名に（スペース）またはセットの任意の文字を含めることを禁止しています &lt;code&gt;!#%&amp;amp;'()*;&amp;lt;=&amp;gt;?&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="845ea4ddc5e221b527b9b5fd418aec5c3f3db57a" translate="yes" xml:space="preserve">
          <source>Older releases of VOS (prior to OpenVOS Release 17.0) limit file names to 32 or fewer characters, prohibit file names from starting with a &lt;code&gt;-&lt;/code&gt; character, and prohibit file names from containing any character matching &lt;code&gt;tr/ !#%&amp;amp;'()*;&amp;lt;=&amp;gt;?//&lt;/code&gt; .</source>
          <target state="translated">VOSの古いリリース（OpenVOSリリース17.0より前）では、ファイル名は32文字以下に制限され、ファイル名が &lt;code&gt;-&lt;/code&gt; 文字で始まることを禁止し、ファイル名に &lt;code&gt;tr/ !#%&amp;amp;'()*;&amp;lt;=&amp;gt;?//&lt;/code&gt; 一致する文字を含めることを禁止します。 &amp;lt;=&amp;gt;？//。</target>
        </trans-unit>
        <trans-unit id="b4148117b640e73f6a46898d2260720a46ef03ff" translate="yes" xml:space="preserve">
          <source>Older translators might add wording around an L&amp;lt;&amp;gt; link, so that &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; may become &quot;the Foo::Bar manpage&quot;, for example. So you shouldn't write things like &lt;code&gt;the L&amp;lt;foo&amp;gt;
documentation&lt;/code&gt;, if you want the translated document to read sensibly. Instead, write &lt;code&gt;the L&amp;lt;Foo::Bar|Foo::Bar&amp;gt; documentation&lt;/code&gt; or &lt;code&gt;L&amp;lt;the Foo::Bar documentation|Foo::Bar&amp;gt;&lt;/code&gt; , to control how the link comes out.</source>
          <target state="translated">古い翻訳者は、L &amp;lt;&amp;gt;リンクの周りに文言を追加する場合があるため、たとえば、 &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; が「Foo :: Barマンページ」になる場合があります。そのため、翻訳されたドキュメントを適切に読みたい場合 &lt;code&gt;the L&amp;lt;foo&amp;gt; documentation&lt;/code&gt; ようなものを記述しないでください。代わりに &lt;code&gt;the L&amp;lt;Foo::Bar|Foo::Bar&amp;gt; documentation&lt;/code&gt; または &lt;code&gt;L&amp;lt;the Foo::Bar documentation|Foo::Bar&amp;gt;&lt;/code&gt; 記述して、リンクの表示方法を制御します。</target>
        </trans-unit>
        <trans-unit id="14a3863272e849d79d3bd80306df053765edc2b6" translate="yes" xml:space="preserve">
          <source>Older translators might add wording around an L&amp;lt;&amp;gt; link, so that &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; may become &quot;the Foo::Bar manpage&quot;, for example. So you shouldn't write things like &lt;code&gt;the L&amp;lt;foo&amp;gt; documentation&lt;/code&gt;, if you want the translated document to read sensibly. Instead, write &lt;code&gt;the L&amp;lt;Foo::Bar|Foo::Bar&amp;gt; documentation&lt;/code&gt; or &lt;code&gt;L&amp;lt;the Foo::Bar documentation|Foo::Bar&amp;gt;&lt;/code&gt;, to control how the link comes out.</source>
          <target state="translated">古い翻訳者は、 &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; が「Foo :: Barマンページ」になるように、L &amp;lt;&amp;gt;リンクの周りに文言を追加する場合があります。したがって、翻訳されたドキュメントを適切に読みたい場合 &lt;code&gt;the L&amp;lt;foo&amp;gt; documentation&lt;/code&gt; ようなものを書くべきではありません。代わりに &lt;code&gt;the L&amp;lt;Foo::Bar|Foo::Bar&amp;gt; documentation&lt;/code&gt; または &lt;code&gt;L&amp;lt;the Foo::Bar documentation|Foo::Bar&amp;gt;&lt;/code&gt; 記述して、リンクの出力を制御します。</target>
        </trans-unit>
        <trans-unit id="74cfdc9feb194af111f83545c6d1330ca4e4400c" translate="yes" xml:space="preserve">
          <source>Older versions of CPAN.pm had the original root directory of all tarballs in the build directory. Now there are always random characters appended to these directory names. Why was this done?</source>
          <target state="translated">CPAN.pm の古いバージョンでは、すべての tarball の元のルートディレクトリがビルドディレクトリにありました。今では、これらのディレクトリ名には常にランダムな文字が付加されています。なぜこのようなことが行われたのでしょうか?</target>
        </trans-unit>
        <trans-unit id="0de4f0e8390c99f19bd133eee1f9e0b1e299d545" translate="yes" xml:space="preserve">
          <source>Older versions of perl may have security vulnerabilities, some of which are serious (see &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; and search &lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=Perl&quot;&gt;CVEs&lt;/a&gt; for more information).</source>
          <target state="translated">古いバージョンのperlにはセキュリティの脆弱性があり、その一部は深刻です（詳細については、&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;および検索&lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=Perl&quot;&gt;CVE&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="aa508d12280c1adaeb775241c86d759189c3c71c" translate="yes" xml:space="preserve">
          <source>Older versions of this document recommended to use &lt;code&gt;void&lt;/code&gt; return value in such cases. It was discovered that this could lead to segfaults in cases when XSUB was</source>
          <target state="translated">このドキュメントの古いバージョンでは、このような場合に &lt;code&gt;void&lt;/code&gt; 戻り値を使用することが推奨されていました。これは、XSUBが次のような場合にsegfaultにつながる可能性があることが発見されました</target>
        </trans-unit>
        <trans-unit id="7dc06c5173c26db9fe80a519eb5a6ebe90623816" translate="yes" xml:space="preserve">
          <source>Oldsyms.U</source>
          <target state="translated">Oldsyms.U</target>
        </trans-unit>
        <trans-unit id="c1039769adff260cb2734954cd648c56f4365afe" translate="yes" xml:space="preserve">
          <source>Olivier Mengu&amp;eacute; &amp;lt;dolmen@cpan.org&amp;gt;</source>
          <target state="translated">Olivier Mengu&amp;eacute; &amp;lt;dolmen@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9cf87efb8c04dd4dc674e0b0506f97a5eb0660ea" translate="yes" xml:space="preserve">
          <source>Olivier Mengue</source>
          <target state="translated">オリヴィエ・メンゲ</target>
        </trans-unit>
        <trans-unit id="0aa942a536d7cded5f6fc6f8772142dfcfdb221f" translate="yes" xml:space="preserve">
          <source>Olivier Mengue &amp;lt;dolmen@cpan.org&amp;gt;</source>
          <target state="translated">オリヴィエ・メング&amp;lt;dolmen@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f3ed24c21f5dd18b200f0c25095d7a6774573e1a" translate="yes" xml:space="preserve">
          <source>Omit &lt;code&gt;constant()&lt;/code&gt; from the .xs file and corresponding specialised &lt;code&gt;AUTOLOAD&lt;/code&gt; from the .pm file.</source>
          <target state="translated">.xsファイルから &lt;code&gt;constant()&lt;/code&gt; を省略し、.pmファイルから対応する特殊な &lt;code&gt;AUTOLOAD&lt;/code&gt; を省略します。</target>
        </trans-unit>
        <trans-unit id="9c4aa09aebc98ad6e647cac1f8fffb08291cde09" translate="yes" xml:space="preserve">
          <source>Omit all autoload facilities. This is the same as &lt;b&gt;-c&lt;/b&gt; but also removes the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader&lt;/code&gt; statement from the .pm file.</source>
          <target state="translated">すべてのオートロード機能を省略します。これは同じです&lt;b&gt;-c&lt;/b&gt;も削除され &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; AutoLoader&lt;/code&gt; の.pmファイルから文を。</target>
        </trans-unit>
        <trans-unit id="0e2601b286234df74dc051d8e9fbf4262affc4dd" translate="yes" xml:space="preserve">
          <source>Omit all autoload facilities. This is the same as &lt;b&gt;-c&lt;/b&gt; but also removes the &lt;code&gt;use AutoLoader&lt;/code&gt; statement from the .pm file.</source>
          <target state="translated">すべての自動ロード機能を省略します。これは&lt;b&gt;-c&lt;/b&gt;と同じですが、.pmファイルから &lt;code&gt;use AutoLoader&lt;/code&gt; ステートメントも削除されます。</target>
        </trans-unit>
        <trans-unit id="c89bf96a83d88777c4a53a3cada5e03b11bfab80" translate="yes" xml:space="preserve">
          <source>Omit redundant punctuation as long as clarity doesn't suffer.</source>
          <target state="translated">明瞭さが損なわれない限り、冗長な句読点は省略してください。</target>
        </trans-unit>
        <trans-unit id="5939f2980c3053a7b35d91579e70755fbf358beb" translate="yes" xml:space="preserve">
          <source>Omit the XS portion. Used to generate a skeleton pure Perl module. &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-f&lt;/code&gt; are implicitly enabled.</source>
          <target state="translated">XS部分を省略します。スケルトンの純粋なPerlモジュールを生成するために使用されます。 &lt;code&gt;-c&lt;/code&gt; および &lt;code&gt;-f&lt;/code&gt; は暗黙的に有効になります。</target>
        </trans-unit>
        <trans-unit id="ab66b48afb255f3fa8074752a39b329797b5aa56" translate="yes" xml:space="preserve">
          <source>Omit the autogenerated stub POD section.</source>
          <target state="translated">自動生成されたスタブのPODセクションを省略します。</target>
        </trans-unit>
        <trans-unit id="aef75bc39700a2d7f9ba2d4fcc4c938989654f2d" translate="yes" xml:space="preserve">
          <source>Omits creation of the</source>
          <target state="translated">の作成を省略しています。</target>
        </trans-unit>
        <trans-unit id="3b6794df4ab49e575f0969623fbbb9b4eead1f5f" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; section is equivalent to using an empty one, logically enough, so &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; goes directly back to check the condition at the top of the loop.</source>
          <target state="translated">論理的には、&lt;a href=&quot;#continue-BLOCK&quot;&gt; &lt;code&gt;continue&lt;/code&gt; &lt;/a&gt;セクションを省略することは空のセクションを使用することと同じであるため、&lt;a href=&quot;#next-LABEL&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;は直接戻って、ループの先頭の状態をチェックします。</target>
        </trans-unit>
        <trans-unit id="ce977cba7ea14f47b6252159a9ce77942da917fb" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; section is equivalent to using an empty one, logically enough, so &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; goes directly back to check the condition at the top of the loop.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; セクションを省略することは、論理的に十分な空のセクションを使用することと同じであるため、 &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; はループの先頭にある条件を直接チェックして戻ります。</target>
        </trans-unit>
        <trans-unit id="648601245d456cf14017862c18156a366b17d689" translate="yes" xml:space="preserve">
          <source>Omitting the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; section is equivalent to using an empty one, logically enough, so &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; goes directly back to check the condition at the top of the loop.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; セクションを省略することは、論理的に十分な空のセクションを使用することと同じであるため、 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; はループの先頭にある条件を直接チェックして戻ります。</target>
        </trans-unit>
        <trans-unit id="2170721cf53167c035658d5db7e3986d2f62f2d5" translate="yes" xml:space="preserve">
          <source>Omitting the first argument (input text) means process &lt;code&gt;$_&lt;/code&gt; instead. Omitting the second argument (delimiter brackets) indicates that only &lt;code&gt;'{'&lt;/code&gt; is to be used. Omitting the third argument (prefix argument) implies optional whitespace at the start. Omitting the fourth argument (outermost delimiter brackets) indicates that the value of the second argument is to be used for the outermost delimiters.</source>
          <target state="translated">最初の引数（入力テキスト）を省略すると、代わりに &lt;code&gt;$_&lt;/code&gt; 処理されます。2番目の引数（区切り括弧）を省略すると、 &lt;code&gt;'{'&lt;/code&gt; のみが使用されることを示します。3番目の引数（プレフィックス引数）を省略すると、最初にオプションの空白が含まれます。4番目の引数（最も外側の区切り括弧）を省略すると、2番目の引数の値が最も外側の区切り文字に使用されることを示します。</target>
        </trans-unit>
        <trans-unit id="650eb97953ce5c6e07ebcb4164c35bedbbc7ac72" translate="yes" xml:space="preserve">
          <source>On 64bit systems some data structures may exceed the 2G (i.e. I32_MAX) limit. On 32bit systems also strings between I32 and U32 (2G-4G). Since Storable 3.00 (not in perl5 core) we are able to store and retrieve these objects, even if perl5 itself is not able to handle them. These are strings longer then 4G, arrays with more then 2G elements and hashes with more then 2G elements. cperl forbids hashes with more than 2G elements, but this fail in cperl then. perl5 itself at least until 5.26 allows it, but cannot iterate over them. Note that creating those objects might cause out of memory exceptions by the operating system before perl has a chance to abort.</source>
          <target state="translated">64bit システムでは、いくつかのデータ構造は 2G (すなわち I32_MAX)の制限を超える可能性があります。32bitシステムでは、I32とU32の間の文字列(2G-4G)もあります。Storable 3.00以降(Perl5コアにはありません)では、Perl5自身が処理できなくても、これらのオブジェクトを保存したり取得したりできるようになりました。これらは4Gより長い文字列、2G以上の要素を持つ配列、2G以上の要素を持つハッシュです。 cperlは2G以上の要素を持つハッシュを禁止していますが、これはperlでは失敗します。これらのオブジェクトを作成すると、perlが中止する前にオペレーティングシステムによるメモリ切れの例外が発生する可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d19163591bedfb142adf27e96746ef3cf121a26f" translate="yes" xml:space="preserve">
          <source>On AIX 4.2 using xlC, we continue:</source>
          <target state="translated">xlCを使用したAIX 4.2では、続けます。</target>
        </trans-unit>
        <trans-unit id="b7bebcc7500e38fa33da9de2419b5d4507654e3f" translate="yes" xml:space="preserve">
          <source>On AIX 4.3 using vac, we continue:</source>
          <target state="translated">AIX 4.3 で vac を使用している場合は、続けます。</target>
        </trans-unit>
        <trans-unit id="eeac3c2c2feb8a620697ff4a8d972aa2a092d986" translate="yes" xml:space="preserve">
          <source>On AIX, is &lt;code&gt;.exp&lt;/code&gt;.</source>
          <target state="translated">AIXでは、 &lt;code&gt;.exp&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="85f8078cc0b8af6aad63b15eccc9063b75b69a03" translate="yes" xml:space="preserve">
          <source>On ASCII platforms, the resulting characters from the list above are the complete set of ASCII controls. This isn't the case on EBCDIC platforms; see &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;&quot;OPERATOR DIFFERENCES&quot; in perlebcdic&lt;/a&gt; for a full discussion of the differences between these for ASCII versus EBCDIC platforms.</source>
          <target state="translated">ASCIIプラットフォームでは、上記のリストから得られる文字は、ASCIIコントロールの完全なセットです。これは、EBCDICプラットフォームには当てはまりません。ASCIIプラットフォームとEBCDICプラットフォームの違いの詳細については、&lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;perlebcdicの「OPERATORDIFFERENCES」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="164f1a22c1ddad7a43b51fc0e97d9cc8c54ba4c2" translate="yes" xml:space="preserve">
          <source>On ASCII platforms, the resulting characters from the list above are the complete set of ASCII controls. This isn't the case on EBCDIC platforms; see &lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;OPERATOR DIFFERENCES in perlebcdic&lt;/a&gt; for a full discussion of the differences between these for ASCII versus EBCDIC platforms.</source>
          <target state="translated">ASCIIプラットフォームでは、上記のリストから得られる文字は、ASCIIコントロールの完全なセットです。これはEBCDICプラットフォームには当てはまりません。ASCIIプラットフォームとEBCDICプラットフォームの違いの詳細については、&lt;a href=&quot;perlebcdic#OPERATOR-DIFFERENCES&quot;&gt;perlebcdicのOPERATOR DIFFERENCESを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e4ce9df615081837a49ff8902adf19d0bea73069" translate="yes" xml:space="preserve">
          <source>On ASCII-encoded platforms it is possible to strip characters outside of the printable set using:</source>
          <target state="translated">ASCIIエンコードされたプラットフォームでは、以下のようにして印刷可能なセットの外の文字を取り除くことができます。</target>
        </trans-unit>
        <trans-unit id="f524bd580ae58f0c6ff9d83f9b34774b97e1a12f" translate="yes" xml:space="preserve">
          <source>On DOS-like platforms, if the program does not contain directory separators, it will first be searched for in the current directory before being searched for on the PATH. On Unix platforms, the program will be searched for strictly on the PATH.</source>
          <target state="translated">DOSライクなプラットフォームでは、プログラムがディレクトリセパレータを含まない場合、まずカレントディレクトリで検索されてからPATHで検索されます。Unix プラットフォームでは、プログラムは厳密に PATH で検索されます。</target>
        </trans-unit>
        <trans-unit id="2f93d8018989db4b239468fb46d0cdba5c2f0db5" translate="yes" xml:space="preserve">
          <source>On DOS/Windows like architectures where this layer is part of the defaults, it also acts like the &lt;code&gt;:perlio&lt;/code&gt; layer, and removing the CRLF translation (such as with &lt;code&gt;:raw&lt;/code&gt;) will only unset the CRLF translation flag. Since Perl 5.14, you can also apply another &lt;code&gt;:crlf&lt;/code&gt; layer later, such as when the CRLF translation must occur after an encoding layer. On other architectures, it is a mundane CRLF translation layer and can be added and removed normally.</source>
          <target state="translated">このレイヤーがデフォルトの一部であるDOS / Windowsのようなアーキテクチャでは、 &lt;code&gt;:perlio&lt;/code&gt; レイヤーのようにも機能し、CRLF変換を削除すると（ &lt;code&gt;:raw&lt;/code&gt; など）、CRLF変換フラグの設定が解除されるだけです。 Perl 5.14以降、エンコードレイヤーの後にCRLF変換を実行する必要がある場合など、後で別の &lt;code&gt;:crlf&lt;/code&gt; レイヤーを適用することもできます。他のアーキテクチャでは、これはありふれたCRLF変換レイヤーであり、通常どおりに追加および削除できます。</target>
        </trans-unit>
        <trans-unit id="1cac4dfb85f7858cf9af4b4f306e4164c94a071a" translate="yes" xml:space="preserve">
          <source>On DOSISH systems, backslash is a valid directory separator character. In this case, use of backslash as a quoting character (via GLOB_QUOTE) interferes with the use of backslash as a directory separator. The best (simplest, most portable) solution is to use forward slashes for directory separators, and backslashes for quoting. However, this does not match &quot;normal practice&quot; on these systems. As a concession to user expectation, therefore, backslashes (under GLOB_QUOTE) only quote the glob metacharacters '[', ']', '{', '}', '-', '~', and backslash itself. All other backslashes are passed through unchanged.</source>
          <target state="translated">DOSISH システムでは、バックスラッシュは有効なディレクトリ区切り文字です。この場合、バックスラッシュを (GLOB_QUOTE 経由で)クォート文字として使うと、ディレクトリセパレータとしてのバックスラッシュの使用に支障をきたす。最適な(最も単純で、最も移植性の高い)解決策は、ディレクトリ区切り文字にフォワード・スラッシュを使用し、クォート文字にはバックスラッシュを使用することである。しかし、これはこれらのシステムでの「通常の慣習」とは一致しません。したがって、ユーザーの期待に応えるために、バックスラッシュは(GLOB_QUOTE の下で)グローバル・メタキャラクタ '[',']'、'{','}','-','~',およびバックスラッシュ自身のみを引用することにしている。他のすべてのバックスラッシュは変更されずに通過します。</target>
        </trans-unit>
        <trans-unit id="bc353a101a732e619259516d5005fd73e9056d46" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms characters in the Latin 1 character set are treated as being part of a literal UTF-EBCDIC character.</source>
          <target state="translated">EBCDIC プ ラ ッ ト フ ォーム上では、 Latin 1 文字セ ッ ト 内のキ ャ ラ ク タ は、 リ テ ラ ル UTF-EBCDIC キ ャ ラ ク タ の一部 と し て扱われます。</target>
        </trans-unit>
        <trans-unit id="e55bcfcaea4d3f5091519d63553b94250f256406" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms starting in Perl v5.24, the Perl extension for representing extremely high code points kicks in at 0x3FFF_FFFF (2**30 -1), which is lower than on ASCII. Prior to that, code points 2**31 and higher were simply unrepresentable, and a different, incompatible method was used to represent code points between 2**30 and 2**31 - 1.</source>
          <target state="translated">Perl v5.24 以降の EBCDIC プラットフォームでは、非常に高いコードポイントを表現するための Perl 拡張機能が 0x3FFF_FFFF (2**30 -1)で起動します。それ以前は、2**31 以上のコードポイントは単純に表現できず、2**30 から 2**31 -1 までのコードポイントを表現するために、互換性のない別の方法が使用されていました。</target>
        </trans-unit>
        <trans-unit id="6112256ee63f46a5e15ec3716f73262824a70fb0" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, code points above 0x3FFF_FFFF have a different representation in Perl v5.24 than before, so any file containing these that was written before that version will require conversion before being readable by a later Perl.</source>
          <target state="translated">EBCDIC プラットフォームでは、0x3FFF_FFFF より上のコードポイントは、Perl v5.24 では以前とは異なる表現になっているため、そのバージョンより前に書かれたこれらのコードポイントを含むファイルは、それ以降の Perl で読めるようになる前に変換する必要があります。</target>
        </trans-unit>
        <trans-unit id="05835a5188ac319110e1d4a7bb82d82adb8499ed" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, prior to v5.22, using &lt;code&gt;\N{U+...}&lt;/code&gt; doesn't work properly.</source>
          <target state="translated">v5.22より前のEBCDICプラットフォームでは、 &lt;code&gt;\N{U+...}&lt;/code&gt; しても正しく機能しません。</target>
        </trans-unit>
        <trans-unit id="79296614d9a9f53308ccee5fcf367fe461dcdb98" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, the internal Unicode encoding form is UTF-EBCDIC instead of UTF-8. The difference is that as UTF-8 is &quot;ASCII-safe&quot; in that ASCII characters encode to UTF-8 as-is, while UTF-EBCDIC is &quot;EBCDIC-safe&quot;, in that all the basic characters (which includes all those that have ASCII equivalents (like &lt;code&gt;&quot;A&quot;&lt;/code&gt; , &lt;code&gt;&quot;0&quot;&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; ,</source>
          <target state="translated">EBCDICプラットフォームでは、内部Unicodeエンコード形式はUTF-8ではなくUTF-EBCDICです。違いは、ASCII文字がそのままUTF-8にエンコードされるという点でUTF-8は「ASCIIセーフ」であり、UTF-EBCDICは「EBCDICセーフ」であるという点です。 ASCIIの同等物（ &lt;code&gt;&quot;A&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;%&quot;&lt;/code&gt; など）</target>
        </trans-unit>
        <trans-unit id="69ff29e47116562e384d48eb5aae2111322261e8" translate="yes" xml:space="preserve">
          <source>On EBCDIC platforms, the internal Unicode encoding form is UTF-EBCDIC instead of UTF-8. The difference is that as UTF-8 is &quot;ASCII-safe&quot; in that ASCII characters encode to UTF-8 as-is, while UTF-EBCDIC is &quot;EBCDIC-safe&quot;, in that all the basic characters (which includes all those that have ASCII equivalents (like &lt;code&gt;&quot;A&quot;&lt;/code&gt;, &lt;code&gt;&quot;0&quot;&lt;/code&gt;, &lt;code&gt;&quot;%&quot;&lt;/code&gt;,</source>
          <target state="translated">EBCDICプラットフォームでは、内部Unicodeエンコード形式はUTF-8ではなくUTF-EBCDICです。違いは、UTF-8はASCII文字がそのままUTF-8にエンコードされるという点で「ASCIIセーフ」であるのに対し、UTF-EBCDICはすべての基本文字（すべての基本文字を含む）が「EBCDICセーフ」であるということです。 ASCIIに相当するもの（ &lt;code&gt;&quot;A&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;%&quot;&lt;/code&gt; など）があります。</target>
        </trans-unit>
        <trans-unit id="24eed6474921c436fc7017c3e9ee9fd9b18bd251" translate="yes" xml:space="preserve">
          <source>On Linux as of perl v5.14.0 the legacy process name will be set with &lt;code&gt;prctl(2)&lt;/code&gt; , in addition to altering the POSIX name via &lt;code&gt;argv[0]&lt;/code&gt; as perl has done since version 4.000. Now system utilities that read the legacy process name such as ps, top and killall will recognize the name you set when assigning to &lt;code&gt;$0&lt;/code&gt; . The string you supply will be cut off at 16 bytes, this is a limitation imposed by Linux.</source>
          <target state="translated">Linuxでは、perl v5.14.0 以降、perlがバージョン4.000以降に行ったように、 &lt;code&gt;argv[0]&lt;/code&gt; を介してPOSIX名を変更することに加えて、レガシープロセス名が &lt;code&gt;prctl(2)&lt;/code&gt; で設定されます。これで、ps、top、killallなどのレガシープロセス名を読み取るシステムユーティリティは、 &lt;code&gt;$0&lt;/code&gt; に割り当てるときに設定した名前を認識します。指定した文字列は16バイトで切り捨てられますが、これはLinuxによる制限です。</target>
        </trans-unit>
        <trans-unit id="971443928989b7bee0ac0a568694348131be6843" translate="yes" xml:space="preserve">
          <source>On Linux as of perl v5.14.0 the legacy process name will be set with &lt;code&gt;prctl(2)&lt;/code&gt;, in addition to altering the POSIX name via &lt;code&gt;argv[0]&lt;/code&gt; as perl has done since version 4.000. Now system utilities that read the legacy process name such as ps, top and killall will recognize the name you set when assigning to &lt;code&gt;$0&lt;/code&gt;. The string you supply will be cut off at 16 bytes, this is a limitation imposed by Linux.</source>
          <target state="translated">Linuxでは、perl v5.14.0以降、perlがバージョン4.000以降に行ったように、 &lt;code&gt;argv[0]&lt;/code&gt; を介してPOSIX名を変更することに加えて、レガシープロセス名が &lt;code&gt;prctl(2)&lt;/code&gt; で設定されます。これで、ps、top、killallなどのレガシープロセス名を読み取るシステムユーティリティは、 &lt;code&gt;$0&lt;/code&gt; に割り当てるときに設定した名前を認識します。指定した文字列は16バイトで切り捨てられます。これは、Linuxによって課せられる制限です。</target>
        </trans-unit>
        <trans-unit id="acdfac3cee0fd1507f95a5dcb4019d7d46aa51e5" translate="yes" xml:space="preserve">
          <source>On MSWin32, each thread maintains its own set of environment variables.</source>
          <target state="translated">MSWin32 では、各スレッドは独自の環境変数のセットを保持しています。</target>
        </trans-unit>
        <trans-unit id="07fed63ea1db8f306a3fcf956ae30aa0f5f797ab" translate="yes" xml:space="preserve">
          <source>On MSWin32, each thread maintains its own the current working directory setting.</source>
          <target state="translated">MSWin32では、各スレッドはカレントワーキングディレクトリの設定を保持しています。</target>
        </trans-unit>
        <trans-unit id="23b53b159dd238a66ca7c109ea8e5776a37bac8e" translate="yes" xml:space="preserve">
          <source>On Mac OS X the file system encoding is always UTF-8 while the locale can otherwise be set up as normal for POSIX systems.</source>
          <target state="translated">Mac OS X では、ファイルシステムのエンコーディングは常に UTF-8 になっていますが、それ以外の場合は POSIX システムでは通常通りにロケールを設定することができます。</target>
        </trans-unit>
        <trans-unit id="fc9baea2d4ac629b8f41cbaaf2320e912f58f4e6" translate="yes" xml:space="preserve">
          <source>On Mac OS, assumes that the last part of the path is a filename unless $no_file is true or a trailing separator &quot;:&quot; is present.</source>
          <target state="translated">Mac OS では、$no_file が真であるか、末尾に &quot;:&quot; がある場合を除き、パスの最後の部分がファイル名であると仮定します。</target>
        </trans-unit>
        <trans-unit id="2c8cbf9feb69a54cf112ddb280be3a352f96b397" translate="yes" xml:space="preserve">
          <source>On Mac OS, there's nothing to be done. Returns what it's given.</source>
          <target state="translated">Mac OSでは何もしない。与えられたものを返します。</target>
        </trans-unit>
        <trans-unit id="1110960c59d5ed71b666c1e4c9c495538ef1f179" translate="yes" xml:space="preserve">
          <source>On OS/390 or z/OS see the</source>
          <target state="translated">OS/390またはz/OSでは</target>
        </trans-unit>
        <trans-unit id="5637d80de5f3ae2f3a457607d81fcd5653f85175" translate="yes" xml:space="preserve">
          <source>On OS/390 or z/OS see the &lt;a href=&quot;http://man.he.net/man1/iconv&quot;&gt;iconv(1)&lt;/a&gt; manpage. One way to invoke the &lt;code&gt;iconv&lt;/code&gt; shell utility from within perl would be to:</source>
          <target state="translated">OS / 390またはz / OSでは、&lt;a href=&quot;http://man.he.net/man1/iconv&quot;&gt;iconv（1）の&lt;/a&gt;マンページを参照してください。Perl内から &lt;code&gt;iconv&lt;/code&gt; シェルユーティリティを呼び出す1つの方法は、次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d3d05f25204078cfb6759aed14497988db83abc4" translate="yes" xml:space="preserve">
          <source>On OSes where temp files are automatically removed when the temp file is closed, calling this function will have no effect other than to remove temporary directories (which may include temporary files).</source>
          <target state="translated">テンポラリファイルを閉じると自動的にテンポラリファイルが削除されるOSでは、この関数を呼び出してもテンポラリディレクトリ(テンポラリファイルを含む場合があります)を削除する以外には何の効果もありません。</target>
        </trans-unit>
        <trans-unit id="d375d4a0af7ab518303234b7c17d1169f40e9bcc" translate="yes" xml:space="preserve">
          <source>On PA-RISC you need a different compiler for 32-bit applications and for 64-bit applications. On PA-RISC, 32-bit objects and 64-bit objects do not mix. Period. There is no different behaviour for HP C-ANSI-C or GNU gcc. So if you require your perl binary to use 64-bit libraries, like Oracle-64bit, you MUST build a 64-bit perl.</source>
          <target state="translated">PA-RISCでは、32ビットアプリケーションと64ビットアプリケーションでは異なるコンパイラが必要です。PA-RISCでは、32ビットオブジェクトと64ビットオブジェクトは混在しません。それが普通です。HP C-ANSI-CやGNU gccでは異なる挙動はありません。ですから、Perl バイナリで Oracle-64bit のような 64bit ライブラリを使用する必要がある場合は、64bit の perl をビルドしなければなりません (MUST)。</target>
        </trans-unit>
        <trans-unit id="a9150346abbcb79f7b8cfc1b292f802424998448" translate="yes" xml:space="preserve">
          <source>On POSIX systems, that program will likely be GNU Make; on Microsoft Windows, it will be either Microsoft NMake, DMake or GNU Make. See the section on the &lt;a href=&quot;#MAKE&quot;&gt;&quot;MAKE&quot;&lt;/a&gt; parameter for details.</source>
          <target state="translated">POSIXシステムでは、そのプログラムはおそらくGNUMakeです。 Microsoft Windowsでは、Microsoft NMake、DMake、またはGNUMakeのいずれかになります。詳細については、&lt;a href=&quot;#MAKE&quot;&gt;「MAKE」&lt;/a&gt;パラメーターのセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="92d7a8c18ee051a4b37ffd21066565b5d3a9d46d" translate="yes" xml:space="preserve">
          <source>On POSIX systems, that program will likely be GNU Make; on Microsoft Windows, it will be either Microsoft NMake, DMake or GNU Make. See the section on the &lt;a href=&quot;#MAKE&quot;&gt;MAKE&lt;/a&gt; parameter for details.</source>
          <target state="translated">POSIXシステムでは、そのプログラムはおそらくGNU Makeです。Microsoft Windowsでは、Microsoft NMake、DMake、またはGNU Makeのいずれかになります。詳細については、&lt;a href=&quot;#MAKE&quot;&gt;MAKE&lt;/a&gt;パラメーターに関するセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="167592a5236c1f91d56ed9f91f8821eeb4df3832" translate="yes" xml:space="preserve">
          <source>On Perl 5.10 and above, using smart-match (&lt;code&gt;~~&lt;/code&gt;) with an &lt;code&gt;autodie::exception&lt;/code&gt; object will use &lt;code&gt;matches&lt;/code&gt; underneath. This module used to recommend using smart-match with the exception object on the left hand side, but in future Perls that is likely to stop working. The smart-match facility of this class should only be used with the exception object on the right hand side. Having the exception object on the right is both future-proof and portable to older Perls, back to 5.10. Beware that this facility can only be relied upon when it is certain that the exception object actually is an &lt;code&gt;autodie::exception&lt;/code&gt; object; it is no more capable than an explicit call to the &lt;code&gt;matches&lt;/code&gt; method.</source>
          <target state="translated">Perl 5.10以降では、 &lt;code&gt;autodie::exception&lt;/code&gt; オブジェクトでsmart-match（ &lt;code&gt;~~&lt;/code&gt; ）を使用すると、その下の &lt;code&gt;matches&lt;/code&gt; が使用されます。このモジュールは、左側の例外オブジェクトでスマートマッチを使用することを推奨していましたが、将来的には動作を停止する可能性のあるPerlです。このクラスのスマートマッチ機能は、右側の例外オブジェクトでのみ使用する必要があります。右側に例外オブジェクトがあることは、将来性があり、5.10に戻った古いPerlに移植可能です。この機能は、例外オブジェクトが実際に &lt;code&gt;autodie::exception&lt;/code&gt; オブジェクトであることが確実な場合にのみ信頼できることに注意してください。これは、 &lt;code&gt;matches&lt;/code&gt; メソッドを明示的に呼び出す以上の機能はありません。</target>
        </trans-unit>
        <trans-unit id="ec792d74700736cdfd9a5c7544b143a95c42354e" translate="yes" xml:space="preserve">
          <source>On Perl versions before 5.7, Unicode characters with a value over 255 (like lambda or emdash) can't be conveyed. This module does work under such early Perl versions, but in the place of each such character, you get a &quot;?&quot;. Latin-1 characters (characters 160-255) are unaffected.</source>
          <target state="translated">Perl のバージョン 5.7 より前のバージョンでは、値が 255 を超える Unicode 文字 (ラムダや emdash のような)は伝達できません。このモジュールはそのような初期の Perl バージョンでも動作しますが、そのような文字の代わりに &quot;?&quot; が表示されます。Latin-1 文字 (160-255 文字)は影響を受けません。</target>
        </trans-unit>
        <trans-unit id="1b4fd9509076b696b649edffe06b6748d3a6e8fc" translate="yes" xml:space="preserve">
          <source>On The Road</source>
          <target state="translated">オンザロード</target>
        </trans-unit>
        <trans-unit id="3f5f166131dd85ac983f4decac309eb76b2240b2" translate="yes" xml:space="preserve">
          <source>On Unix these calls probably have no effect whatsoever. Elsewhere they alter &quot;\n&quot; to CR,LF translation and possibly cause a special text &quot;end of file&quot; indicator to be written or honoured on read. The effect of making the call after doing any IO to the handle depends on the implementation. (It may be ignored, affect any data which is already buffered as well, or only apply to subsequent data.)</source>
          <target state="translated">Unixでは、これらの呼び出しはおそらく何の効果もありません。他の場所では、&quot;\n &quot;をCR,LF変換に変更し、おそらく、特別なテキスト &quot;ファイルの終了 &quot;インジケータが、読み込まれた時に書き込まれたり、名誉を与えられたりすることになる。ハンドルへの任意のIOを行った後に呼び出しを行うことの効果は、実装に依存します。(無視されたり、既にバッファリングされているデータに影響を与えたり、後続のデータにのみ適用されたりすることがある)。</target>
        </trans-unit>
        <trans-unit id="86c676209565e2d780081a941df86b84b21d9627" translate="yes" xml:space="preserve">
          <source>On Unix,</source>
          <target state="translated">Unixで。</target>
        </trans-unit>
        <trans-unit id="88e8f2f2ac45a9bfa4ec12f4ed8e00688059ccf6" translate="yes" xml:space="preserve">
          <source>On VMS by default, changes to the %ENV hash persist after perl exits. Subsequent invocations of perl in the same process can inadvertently inherit environment settings that were meant to be temporary.</source>
          <target state="translated">VMS では、デフォルトでは、%ENV ハッシュへの変更は perl が終了した後も持続します。同じプロセス内の perl の後続の呼び出しは、一時的なものであるはずの環境設定を誤って継承してしまう可能性があります。</target>
        </trans-unit>
        <trans-unit id="7a7f6210c11a8722ba30917e3753a6ae39f636f9" translate="yes" xml:space="preserve">
          <source>On VMS by default, changes to the &lt;a href=&quot;perlvar#%25ENV&quot;&gt;&lt;code&gt;%ENV&lt;/code&gt;&lt;/a&gt; hash persist after perl exits. Subsequent invocations of perl in the same process can inadvertently inherit environment settings that were meant to be temporary.</source>
          <target state="translated">デフォルトのVMSでは、&lt;a href=&quot;perlvar#%25ENV&quot;&gt; &lt;code&gt;%ENV&lt;/code&gt; &lt;/a&gt;ハッシュへの変更はperlの終了後も保持されます。同じプロセスでの後続のperlの呼び出しは、一時的であることが意図されていた環境設定を誤って継承する可能性があります。</target>
        </trans-unit>
        <trans-unit id="5a45916e3343efd4a31048a877153354c7f3a445" translate="yes" xml:space="preserve">
          <source>On VMS only, record reads bypass PerlIO layers and any associated buffering, so you must not mix record and non-record reads on the same filehandle. Record mode mixes with line mode only when the same buffering layer is in use for both modes.</source>
          <target state="translated">VMS のみでは、記録読み出しは PerlIO レイヤーと関連するバッファリングをバイパスするので、同じファイルハンドル上で記録読み出しと非記録読み出しを混在させてはいけません。レコードモードとラインモードが混在するのは、両方のモードで同じバッファリング層が使用されている場合のみです。</target>
        </trans-unit>
        <trans-unit id="9795304d9e947203c83b021d72efea5ba3031bdc" translate="yes" xml:space="preserve">
          <source>On VMS systems, arrays tied to environment variables are read-only. Attempting to change anything will cause a warning.</source>
          <target state="translated">VMS システムでは、環境変数に結び付けられた配列は読み取り専用です。何かを変更しようとすると警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="74564fe6ae7ff11070f358853ddf9ff8e6cf5db3" translate="yes" xml:space="preserve">
          <source>On VMS, perl determines the UTC offset from the &lt;code&gt;SYS$TIMEZONE_DIFFERENTIAL&lt;/code&gt; logical name. Although the VMS epoch began at 17-NOV-1858 00:00:00.00, calls to &lt;a href=&quot;perlfunc#localtime-EXPR&quot;&gt;&lt;code&gt;localtime&lt;/code&gt;&lt;/a&gt; are adjusted to count offsets from 01-JAN-1970 00:00:00.00, just like Unix.</source>
          <target state="translated">VMSでは、perlは &lt;code&gt;SYS$TIMEZONE_DIFFERENTIAL&lt;/code&gt; 論理名からUTCオフセットを決定します。VMSのエポックが17・11月- 1858年00時に始まったものの：00：00.00、への呼び出し&lt;a href=&quot;perlfunc#localtime-EXPR&quot;&gt; &lt;code&gt;localtime&lt;/code&gt; のは、&lt;/a&gt; 01-JAN-1970 00からのオフセットをカウントするように調整されている：00：00.00、ちょうどUnixのように。</target>
        </trans-unit>
        <trans-unit id="81ce16b2de32a17abe516725e03bc48e7d14b744" translate="yes" xml:space="preserve">
          <source>On VMS, perl determines the UTC offset from the &lt;code&gt;SYS$TIMEZONE_DIFFERENTIAL&lt;/code&gt; logical name. Although the VMS epoch began at 17-NOV-1858 00:00:00.00, calls to &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; are adjusted to count offsets from 01-JAN-1970 00:00:00.00, just like Unix.</source>
          <target state="translated">VMSでは、perlは &lt;code&gt;SYS$TIMEZONE_DIFFERENTIAL&lt;/code&gt; 論理名からUTCオフセットを決定します。VMSのエポックが17・11月- 1858年00時に始まったものの：00：00.00、への呼び出し &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; のは、 01-JAN-1970 00からのオフセットをカウントするように調整されている：00：00.00、ちょうどUnixのように。</target>
        </trans-unit>
        <trans-unit id="06a156290eaf8bb336152c15b3a6a3f335cfb709" translate="yes" xml:space="preserve">
          <source>On VMS, some entries in the &lt;a href=&quot;perlvar#%25ENV&quot;&gt;&lt;code&gt;%ENV&lt;/code&gt;&lt;/a&gt; hash are dynamically created when their key is used on a read if they did not previously exist. The values for &lt;code&gt;$ENV{HOME}&lt;/code&gt;, &lt;code&gt;$ENV{TERM}&lt;/code&gt;, &lt;code&gt;$ENV{PATH}&lt;/code&gt;, and &lt;code&gt;$ENV{USER}&lt;/code&gt;, are known to be dynamically generated. The specific names that are dynamically generated may vary with the version of the C library on VMS, and more may exist than are documented.</source>
          <target state="translated">VMSでは、&lt;a href=&quot;perlvar#%25ENV&quot;&gt; &lt;code&gt;%ENV&lt;/code&gt; &lt;/a&gt;ハッシュの一部のエントリは、キーが以前に存在していなかった場合に読み取りで使用されるときに動的に作成されます。値は &lt;code&gt;$ENV{HOME}&lt;/code&gt; 、 &lt;code&gt;$ENV{TERM}&lt;/code&gt; 、 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 、および &lt;code&gt;$ENV{USER}&lt;/code&gt; 、動的に生成されることが知られています。動的に生成される特定の名前は、VMS上のCライブラリのバージョンによって異なる場合があり、文書化されているよりも多く存在する場合があります。</target>
        </trans-unit>
        <trans-unit id="4640e9f8e338d51c98fb597af9efcb27c56ecf3e" translate="yes" xml:space="preserve">
          <source>On VMS, some entries in the &lt;code&gt;%ENV&lt;/code&gt; hash are dynamically created when their key is used on a read if they did not previously exist. The values for &lt;code&gt;$ENV{HOME}&lt;/code&gt; , &lt;code&gt;$ENV{TERM}&lt;/code&gt; , &lt;code&gt;$ENV{PATH}&lt;/code&gt; , and &lt;code&gt;$ENV{USER}&lt;/code&gt; , are known to be dynamically generated. The specific names that are dynamically generated may vary with the version of the C library on VMS, and more may exist than are documented.</source>
          <target state="translated">VMSでは、 &lt;code&gt;%ENV&lt;/code&gt; ハッシュの一部のエントリは、それらが以前に存在しなかった場合に、それらのキーが読み取りで使用されるときに動的に作成されます。値は &lt;code&gt;$ENV{HOME}&lt;/code&gt; 、 &lt;code&gt;$ENV{TERM}&lt;/code&gt; 、 &lt;code&gt;$ENV{PATH}&lt;/code&gt; 、および &lt;code&gt;$ENV{USER}&lt;/code&gt; 、動的に生成されることが知られています。動的に生成される特定の名前は、VMSのCライブラリのバージョンによって異なる場合があり、記載されているよりも多く存在する場合があります。</target>
        </trans-unit>
        <trans-unit id="00ea6af97bd8140ce5328dca64213948bcea1edc" translate="yes" xml:space="preserve">
          <source>On VMS, which has a volume concept, this field will be empty because VMS file specifications are converted to absolute UNIX format and the volume information is transparently included.</source>
          <target state="translated">ボリュームの概念を持つVMSでは、VMSのファイル仕様は絶対UNIX形式に変換され、ボリューム情報が透過的に含まれるため、このフィールドは空になります。</target>
        </trans-unit>
        <trans-unit id="7181afce3600b3de6f4aeeecdb2753ed0ec50123" translate="yes" xml:space="preserve">
          <source>On VOS, time values are 32-bit quantities.</source>
          <target state="translated">VOSでは、時間値は32ビットの量です。</target>
        </trans-unit>
        <trans-unit id="260fa2754bf084766a1e3d1258ce83d5b5d3b0dc" translate="yes" xml:space="preserve">
          <source>On Win32 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; needs to open the file to determine the link count and update attributes that may have been changed through hard links. Setting &lt;code&gt;${^WIN32_SLOPPY_STAT}&lt;/code&gt; to a true value speeds up &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; by not performing this operation. (Win32)</source>
          <target state="translated">Win32では、 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; はファイルを開いてリンク数を決定し、ハードリンクによって変更された可能性のある属性を更新する必要があります。 &lt;code&gt;${^WIN32_SLOPPY_STAT}&lt;/code&gt; をtrue値に設定すると、この操作を実行しないため、 &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; が高速化されます。（Win32）</target>
        </trans-unit>
        <trans-unit id="43527614576e6873bffe9e01120e3463ca7900ba" translate="yes" xml:space="preserve">
          <source>On Win32 platforms this</source>
          <target state="translated">Win32プラットフォームでは</target>
        </trans-unit>
        <trans-unit id="82880baf8efa4ec11213dbe5173474c89dad4fe5" translate="yes" xml:space="preserve">
          <source>On Win32 ports only, may be set to an alternative shell that Perl must use internally for executing &quot;backtick&quot; commands or system(). Default is &lt;code&gt;cmd.exe /x/d/c&lt;/code&gt; on WindowsNT and &lt;code&gt;command.com /c&lt;/code&gt; on Windows95. The value is considered space-separated. Precede any character that needs to be protected, like a space or backslash, with another backslash.</source>
          <target state="translated">Win32ポートでのみ、「バックティック」コマンドまたはsystem（）を実行するためにPerlが内部で使用する必要がある代替シェルに設定できます。デフォルトは、WindowsNTでは &lt;code&gt;cmd.exe /x/d/c&lt;/code&gt; &lt;code&gt;command.com /c&lt;/code&gt; 、Windows95ではcommand.com / cです。値はスペースで区切られていると見なされます。スペースやバックスラッシュなど、保護する必要のある文字の前に別のバックスラッシュを置きます。</target>
        </trans-unit>
        <trans-unit id="9e2fd429fcf5069c4431ad927b87b339316ae6b1" translate="yes" xml:space="preserve">
          <source>On Win32 the default in this release (5.14) is &quot;unix crlf&quot;. Win32's &quot;stdio&quot; has a number of bugs/mis-features for Perl IO which are somewhat depending on the version and vendor of the C compiler. Using our own &lt;code&gt;crlf&lt;/code&gt; layer as the buffer avoids those issues and makes things more uniform. The &lt;code&gt;crlf&lt;/code&gt; layer provides CRLF conversion as well as buffering.</source>
          <target state="translated">Win32では、このリリース（5.14）のデフォルトは「unix crlf」です。Win32の「stdio」には、Cコンパイラのバージョンとベンダーによって多少異なるが、Perl IOに関する多数のバグ/誤機能があります。バッファーとして独自の &lt;code&gt;crlf&lt;/code&gt; レイヤーを使用すると、これらの問題が回避され、物事がより均一になります。 &lt;code&gt;crlf&lt;/code&gt; 層は、CRLF変換並びにバッファリングを提供します。</target>
        </trans-unit>
        <trans-unit id="c5cad1f19297cc76fd2c0f0cbe96d6c8b8641a99" translate="yes" xml:space="preserve">
          <source>On Win32 the default in this release (5.30) is &quot;:unix:crlf&quot;. Win32's &quot;:stdio&quot; has a number of bugs/mis-features for Perl IO which are somewhat depending on the version and vendor of the C compiler. Using our own &lt;code&gt;:crlf&lt;/code&gt; layer as the buffer avoids those issues and makes things more uniform.</source>
          <target state="translated">Win32では、このリリース（5.30）のデフォルトは「：unix：crlf」です。Win32の「：stdio」には、Cコンパイラのバージョンとベンダーに多少依存するPerlIOのバグ/誤機能がいくつかあります。バッファとして独自の &lt;code&gt;:crlf&lt;/code&gt; レイヤーを使用すると、これらの問題が回避され、物事がより均一になります。</target>
        </trans-unit>
        <trans-unit id="6b57948ea68a275535d9745ad7c79b49f92a2345" translate="yes" xml:space="preserve">
          <source>On Win32, is &lt;code&gt;.def&lt;/code&gt;.</source>
          <target state="translated">Win32では、は &lt;code&gt;.def&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="c661dbe60c2c9116c9b6dd06327729491426c6d8" translate="yes" xml:space="preserve">
          <source>On WinNT &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; can change a file's user and group IDs. On Win9x &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; is a no-op, although this is appropriate since there is no security model.</source>
          <target state="translated">WinNTでは、 &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; はファイルのユーザーIDとグループIDを変更できます。Win9xでは、 &lt;code&gt;&lt;a href=&quot;functions/chown&quot;&gt;chown()&lt;/a&gt;&lt;/code&gt; は何もしませんが、セキュリティモデルがないため、これは適切です。</target>
        </trans-unit>
        <trans-unit id="67f45342ed2b9a9fadda985a145ee379fe5a5018" translate="yes" xml:space="preserve">
          <source>On WinNT &lt;code&gt;chown()&lt;/code&gt; can change a file's user and group IDs. On Win9x &lt;code&gt;chown()&lt;/code&gt; is a no-op, although this is appropriate since there is no security model.</source>
          <target state="translated">WinNTでは、 &lt;code&gt;chown()&lt;/code&gt; はファイルのユーザーIDとグループIDを変更できます。Win9xでは、 &lt;code&gt;chown()&lt;/code&gt; は何もしませんが、セキュリティモデルがないため、これは適切です。</target>
        </trans-unit>
        <trans-unit id="2723b9ca133f3aa539e50122b610714bafdb1670" translate="yes" xml:space="preserve">
          <source>On Windows NT 4 SP6 and later this function returns the following additional values: SPMAJOR, SPMINOR, SUITEMASK, PRODUCTTYPE.</source>
          <target state="translated">Windows NT 4 SP6 以降では、この関数は以下の追加値を返します。SPMAJOR、SPMINOR、SUITEMASK、PRODUCTTYPE。</target>
        </trans-unit>
        <trans-unit id="a917d2cc116f1698163f4d2d945df6a75555b19b" translate="yes" xml:space="preserve">
          <source>On Windows and DOS, this class will not modify any environment variables.</source>
          <target state="translated">WindowsやDOSでは、このクラスは環境変数を変更しません。</target>
        </trans-unit>
        <trans-unit id="691092ab9995db74d07e64291684fba5bdc303c2" translate="yes" xml:space="preserve">
          <source>On Windows this value may be empty if the uri is to a network share, in which case the 'share' property will be defined. Additionally, volume specifications that use '|' as ':' will be converted on read to use ':'.</source>
          <target state="translated">Windowsでは、URIがネットワーク共有の場合、この値は空になる可能性があります。さらに、'|' を ':' として使用するボリューム指定は、読み込み時に ':' を使用するように変換されます。</target>
        </trans-unit>
        <trans-unit id="98136ca8ec46fb8ca78cee1f5eedf07f7ec52018" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;Errno&lt;/code&gt; also defines and conditionally exports all the Winsock error constants defined in your system</source>
          <target state="translated">Windowsでは、 &lt;code&gt;Errno&lt;/code&gt; は、システムで定義されているすべてのWinsockエラー定数も定義して条件付きでエクスポートします。</target>
        </trans-unit>
        <trans-unit id="8d5fbf1c54f4cbef1a178b46ad87cba27e8e2dbd" translate="yes" xml:space="preserve">
          <source>On Windows, if &lt;code&gt;make_path&lt;/code&gt; gives you this warning, it may mean that you have exceeded your filesystem's maximum path length.</source>
          <target state="translated">Windowsでは、 &lt;code&gt;make_path&lt;/code&gt; でこの警告が表示された場合、ファイルシステムの最大パス長を超えている可能性があります。</target>
        </trans-unit>
        <trans-unit id="3c8b57e0402fd5a94f4f0f14b11ffcf0d1fe5e8c" translate="yes" xml:space="preserve">
          <source>On Windows, only the &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; indirect object syntax will reliably avoid using the shell; &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="translated">Windowsでは、 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 間接オブジェクト構文のみが確実にシェルの使用を回避します。 &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; は、複数の要素があっても、最初のスポーンが失敗するとシェルにフォールバックします。</target>
        </trans-unit>
        <trans-unit id="3489286293a7a904918509c734ebd323e4463d4f" translate="yes" xml:space="preserve">
          <source>On Windows, only the &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; indirect object syntax will reliably avoid using the shell; &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; , even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="translated">Windowsでは、 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; PROGRAM LIST&lt;/code&gt; 間接オブジェクト構文のみが確実にシェルの使用を回避します。 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; LIST&lt;/code&gt; は、複数の要素があっても、最初のスポーンが失敗するとシェルにフォールバックします。</target>
        </trans-unit>
        <trans-unit id="7e1ef63036ab0ac76882604ffa03e365a2cc3538" translate="yes" xml:space="preserve">
          <source>On Windows, only the &lt;code&gt;exec PROGRAM LIST&lt;/code&gt; indirect object syntax will reliably avoid using the shell; &lt;code&gt;exec LIST&lt;/code&gt;, even with more than one element, will fall back to the shell if the first spawn fails.</source>
          <target state="translated">Windowsでは、 &lt;code&gt;exec PROGRAM LIST&lt;/code&gt; 間接オブジェクト構文のみがシェルの使用を確実に回避します。 &lt;code&gt;exec LIST&lt;/code&gt; は、複数の要素がある場合でも、最初のスポーンが失敗するとシェルにフォールバックします。</target>
        </trans-unit>
        <trans-unit id="8aceed2ebeb2b1d6033e61b3459bb2d4bb7870fd" translate="yes" xml:space="preserve">
          <source>On Windows, you can use the &lt;a href=&quot;Win32::Console&quot;&gt;Win32::Console&lt;/a&gt; module. After creating an object for the output filehandle you want to affect, call the &lt;code&gt;Cls&lt;/code&gt; method:</source>
          <target state="translated">Windowsでは、&lt;a href=&quot;Win32::Console&quot;&gt;Win32 :: Console&lt;/a&gt;モジュールを使用できます。影響を与える出力ファイルハンドルのオブジェクトを作成した後、 &lt;code&gt;Cls&lt;/code&gt; メソッドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="1feb74b008066b7c35338a20235da8f4be77079d" translate="yes" xml:space="preserve">
          <source>On Windows, you can use the &lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32::Console&lt;/a&gt; module. After creating an object for the output filehandle you want to affect, call the &lt;code&gt;Cls&lt;/code&gt; method:</source>
          <target state="translated">Windowsでは、&lt;a href=&quot;http://search.cpan.org/perldoc/Win32::Console&quot;&gt;Win32 :: Console&lt;/a&gt;モジュールを使用できます。影響を与える出力ファイルハンドルのオブジェクトを作成した後、 &lt;code&gt;Cls&lt;/code&gt; メソッドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="868e4a545e3b36ea0e0005a952326d136f092bcb" translate="yes" xml:space="preserve">
          <source>On a 64-bit &lt;code&gt;perl&lt;/code&gt; , you can get even larger dates for those really long running projects:</source>
          <target state="translated">64ビット &lt;code&gt;perl&lt;/code&gt; では、非常に長時間実行されているプロジェクトの日付をさらに大きくすることができます。</target>
        </trans-unit>
        <trans-unit id="1241860881c4ad85f6cc345b32d854e56c75ec64" translate="yes" xml:space="preserve">
          <source>On a 64-bit &lt;code&gt;perl&lt;/code&gt;, you can get even larger dates for those really long running projects:</source>
          <target state="translated">64ビットの &lt;code&gt;perl&lt;/code&gt; では、非常に長時間実行されるプロジェクトの日付をさらに大きくすることができます。</target>
        </trans-unit>
        <trans-unit id="df92a12e7efed4b5a0ee3432bfa643483f4e66b5" translate="yes" xml:space="preserve">
          <source>On a Perl built without &lt;code&gt;-DDEBUGGING&lt;/code&gt;, or when the &lt;code&gt;-Di&lt;/code&gt; command-line switch is not specified, or under taint, PerlIO_debug() is a no-op.</source>
          <target state="translated">&lt;code&gt;-DDEBUGGING&lt;/code&gt; なしでビルドされたPerlの場合、 &lt;code&gt;-Di&lt;/code&gt; コマンドラインスイッチが指定されていない場合、または汚染されている場合、PerlIO_debug（）は何もしません。</target>
        </trans-unit>
        <trans-unit id="1c8e386d10b1658b7fab41743c4a6c61db5c0bb8" translate="yes" xml:space="preserve">
          <source>On a Unix-like system, these documentation files will usually also be available as manpages for use with the</source>
          <target state="translated">Unix 系のシステムでは、これらのドキュメントファイルは通常 man ページとしても利用できます。</target>
        </trans-unit>
        <trans-unit id="660953bc195f4695e40bafcb35d1864a5ea40fb9" translate="yes" xml:space="preserve">
          <source>On a binary string, you would do things like:</source>
          <target state="translated">バイナリ文字列では、次のようなことができます。</target>
        </trans-unit>
        <trans-unit id="c2fd3df54f8bb812f03e4f16967bb0e0784afad2" translate="yes" xml:space="preserve">
          <source>On a new install it is &quot;C:\Windows CE Tools&quot;. Goto &quot;C:\Windows CE Tools&quot; in a file manager and see if &quot;C:\Windows CE Tools\wce400\STANDARDSDK\Include\Armv4&quot; exists on your disk. If not the SDKROOT need to be changed to &quot;C:\Program Files\Windows CE Tools&quot;.</source>
          <target state="translated">On a new install it is &quot;C:It is &quot;C:It's &quot;C:It's &quot;C:It's &quot;C:It's &quot;C:It's &quot;C:It's &quot;C:It's &quot;C:It's &quot;C:It's &quot;C:It's &quot;C:It's &quot;C:It's &quot;C:It's &quot;C:It's If not the SDKROOT to be changed to the SDKROOT to be changed to &quot;C:\Program Files\Windows CE Tools &quot;に変更する必要がある。</target>
        </trans-unit>
        <trans-unit id="299062bf85cb6925da5e4883a42054b0da9f24d7" translate="yes" xml:space="preserve">
          <source>On a related note, if you do use &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;, then you're going to need a &lt;code&gt;dTARG&lt;/code&gt; in your variable declarations so that the &lt;code&gt;*PUSH*&lt;/code&gt; macros can make use of the local variable &lt;code&gt;TARG&lt;/code&gt; . See also &lt;code&gt;dTARGET&lt;/code&gt; and &lt;code&gt;dXSTARG&lt;/code&gt; .</source>
          <target state="translated">関連する注意として、 &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt; を使用する場合、 &lt;code&gt;*PUSH*&lt;/code&gt; マクロがローカル変数 &lt;code&gt;TARG&lt;/code&gt; を使用できるように、変数宣言に &lt;code&gt;dTARG&lt;/code&gt; が必要になります。 &lt;code&gt;dTARGET&lt;/code&gt; および &lt;code&gt;dXSTARG&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="75330f133f27aefde9a996a79a95540c06e5ca79" translate="yes" xml:space="preserve">
          <source>On a related note, if you do use &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt;, then you're going to need a &lt;code&gt;dTARG&lt;/code&gt; in your variable declarations so that the &lt;code&gt;*PUSH*&lt;/code&gt; macros can make use of the local variable &lt;code&gt;TARG&lt;/code&gt;. See also &lt;code&gt;dTARGET&lt;/code&gt; and &lt;code&gt;dXSTARG&lt;/code&gt;.</source>
          <target state="translated">関連する注記として、 &lt;code&gt;(X)PUSH[iunp]&lt;/code&gt; を使用する場合は、 &lt;code&gt;*PUSH*&lt;/code&gt; マクロがローカル変数 &lt;code&gt;TARG&lt;/code&gt; を使用できるように、変数宣言に &lt;code&gt;dTARG&lt;/code&gt; が必要になります。 &lt;code&gt;dTARGET&lt;/code&gt; および &lt;code&gt;dXSTARG&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="7d8ad329e5099ea252a3ca17c446006da287d9da" translate="yes" xml:space="preserve">
          <source>On a successful match, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to FALSE, and the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the last &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; pattern executed. See the explanation for the &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; verb below for more details.</source>
          <target state="translated">一致が成功すると、 &lt;code&gt;$REGERROR&lt;/code&gt; 変数はFALSEに設定され、 &lt;code&gt;$REGMARK&lt;/code&gt; 変数は最後に実行された &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; パターンの名前に設定されます。詳細については、以下の &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; 動詞の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="d381c7864f9bd0c496e832a74c2bc6e826af96f2" translate="yes" xml:space="preserve">
          <source>On a successful match, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to FALSE, and the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to the name of the last &lt;code&gt;(*MARK:NAME)&lt;/code&gt; pattern executed. See the explanation for the &lt;code&gt;(*MARK:NAME)&lt;/code&gt; verb below for more details.</source>
          <target state="translated">一致が成功すると、 &lt;code&gt;$REGERROR&lt;/code&gt; 変数はFALSEに設定され、 &lt;code&gt;$REGMARK&lt;/code&gt; 変数は最後に実行された &lt;code&gt;(*MARK:NAME)&lt;/code&gt; パターンの名前に設定されます。詳細については、以下の &lt;code&gt;(*MARK:NAME)&lt;/code&gt; 動詞の説明を参照してください。</target>
        </trans-unit>
        <trans-unit id="df6a4ca6e213ccefa4b99c6f895a6d3c5870376c" translate="yes" xml:space="preserve">
          <source>On a text string, you would do things like:</source>
          <target state="translated">テキスト文字列では、次のようなことができます。</target>
        </trans-unit>
        <trans-unit id="16575e035ca925e5fa5bb99a005281cd0246209f" translate="yes" xml:space="preserve">
          <source>On all platforms except MSWin32, the setting for the current working directory is shared among all threads such that changing it in one thread (e.g., using &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt;) will affect all the threads in the application.</source>
          <target state="translated">MSWin32を除くすべてのプラットフォームでは、現在の作業ディレクトリの設定はすべてのスレッド間で共有されるため、1つのスレッドで変更すると（たとえば、 &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir()&lt;/a&gt;&lt;/code&gt; を使用して）、アプリケーションのすべてのスレッドに影響します。</target>
        </trans-unit>
        <trans-unit id="ab64dc72a66da50a5cd3f10fe53225e1e0e96f58" translate="yes" xml:space="preserve">
          <source>On all platforms except MSWin32, the setting for the current working directory is shared among all threads such that changing it in one thread (e.g., using &lt;code&gt;chdir()&lt;/code&gt;) will affect all the threads in the application.</source>
          <target state="translated">MSWin32を除くすべてのプラットフォームで、現在の作業ディレクトリの設定はすべてのスレッド間で共有されるため、1つのスレッドで変更すると（たとえば、 &lt;code&gt;chdir()&lt;/code&gt; を使用）、アプリケーションのすべてのスレッドに影響します。</target>
        </trans-unit>
        <trans-unit id="986faea7525ededb053c5e26524df4fe094d07f8" translate="yes" xml:space="preserve">
          <source>On all the released versions of Solaris (8, 9 and 10) you need to make sure the following packages are installed (this info is extracted from the Solaris FAQ):</source>
          <target state="translated">リリースされたすべてのバージョンの Solaris (8,9,10)では、以下のパッケージがインストールされていることを確認する必要があります (この情報は Solaris FAQ から抜粋しています)。</target>
        </trans-unit>
        <trans-unit id="0adaab19e480042e586e12a800bf5b600ec97adc" translate="yes" xml:space="preserve">
          <source>On an exception during the execution of the request, the &lt;code&gt;status&lt;/code&gt; field will contain 599, and the &lt;code&gt;content&lt;/code&gt; field will contain the text of the exception.</source>
          <target state="translated">リクエストの実行中の例外では、 &lt;code&gt;status&lt;/code&gt; フィールドには599が含まれ、 &lt;code&gt;content&lt;/code&gt; フィールドには例外のテキストが含まれます。</target>
        </trans-unit>
        <trans-unit id="2d2b4cb070056fb4070c425608e71d9f9a08f8e3" translate="yes" xml:space="preserve">
          <source>On both platforms, ASCII and EBCDIC, &lt;code&gt;UTF8_GOT_PERL_EXTENDED&lt;/code&gt; is set if Perl extended UTF-8 is used.</source>
          <target state="translated">ASCIIとEBCDICの両方のプラットフォームで、Perl拡張UTF-8が使用されている場合、 &lt;code&gt;UTF8_GOT_PERL_EXTENDED&lt;/code&gt; が設定されます。</target>
        </trans-unit>
        <trans-unit id="7579bfbb9367171f6983e33cf0c36d410d39ce7e" translate="yes" xml:space="preserve">
          <source>On certain platforms like Win32, OS/2, VMS, and AIX, it is necessary to perform some actions before invoking the linker. The &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; module does this, writing files used by the linker during the creation of shared libraries for dynamic extensions. The names of any files written will be returned as a list.</source>
          <target state="translated">Win32、OS / 2、VMS、AIXなどの特定のプラットフォームでは、リンカーを呼び出す前にいくつかのアクションを実行する必要があります。 &lt;code&gt;ExtUtils::Mksymlists&lt;/code&gt; モジュールがこれを行い、動的な拡張のための共有ライブラリの作成時にリンカによって使用されるファイルを書き込みます。書き込まれたファイルの名前はリストとして返されます。</target>
        </trans-unit>
        <trans-unit id="68f10a6e0b39851d70a2411f9d6927ec33bc1d28" translate="yes" xml:space="preserve">
          <source>On certain platforms, for example Windows, not all the fields returned by stat() can be compared. For example, the &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;rdev&lt;/code&gt; fields seem to be different in Windows. Also, it seems that the size of the file returned by stat() does not always agree, with &lt;code&gt;stat(FH)&lt;/code&gt; being more accurate than &lt;code&gt;stat(filename)&lt;/code&gt;, presumably because of caching issues even when using autoflush (this is usually overcome by waiting a while after writing to the tempfile before attempting to &lt;code&gt;unlink0&lt;/code&gt; it).</source>
          <target state="translated">Windowsなどの特定のプラットフォームでは、stat（）によって返されるすべてのフィールドを比較できるわけではありません。たとえば、 &lt;code&gt;dev&lt;/code&gt; フィールドと &lt;code&gt;rdev&lt;/code&gt; フィールドはWindowsでは異なっているようです。また、stat（）によって返されるファイルのサイズが常に一致するとは限らないようです。おそらく、自動フラッシュを使用している場合でもキャッシュの問題が原因で、 &lt;code&gt;stat(FH)&lt;/code&gt; の方が &lt;code&gt;stat(filename)&lt;/code&gt; よりも正確です（これは通常、待機することで解決されます） &lt;code&gt;unlink0&lt;/code&gt; だ後、リンクを解除する前にしばらくの間）。</target>
        </trans-unit>
        <trans-unit id="48eee9c0d3be3641023bdfbc12b873ba074e7d8a" translate="yes" xml:space="preserve">
          <source>On certain platforms, for example Windows, not all the fields returned by stat() can be compared. For example, the C</source>
          <target state="translated">Windows のような特定のプラットフォームでは、stat()が返すすべてのフィールドを比較できるわけではありません。例えば、C</target>
        </trans-unit>
        <trans-unit id="0337022749da68904dc67bf7ba7a67afde209ea2" translate="yes" xml:space="preserve">
          <source>On creation of a new message queue &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">新しいメッセージキューの作成時に、許可を設定するために &lt;code&gt;FLAGS&lt;/code&gt; が使用されます。Sys V IPC実装で許可されていないフラグを設定しないように注意してください。一部のシステムでは、実行ビットを設定すると操作が失敗します。</target>
        </trans-unit>
        <trans-unit id="82a6576fe44e35482e50d08d072f3b166203f73f" translate="yes" xml:space="preserve">
          <source>On creation of a new semaphore set &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">新しいセマフォセットの作成時に、許可を設定するために &lt;code&gt;FLAGS&lt;/code&gt; が使用されます。Sys V IPC実装で許可されていないフラグを設定しないように注意してください。一部のシステムでは、実行ビットを設定すると操作が失敗します。</target>
        </trans-unit>
        <trans-unit id="2a590d182300640c7833d62b48486238fd75ebb4" translate="yes" xml:space="preserve">
          <source>On creation of a new shared memory segment &lt;code&gt;FLAGS&lt;/code&gt; is used to set the permissions. Be careful not to set any flags that the Sys V IPC implementation does not allow: in some systems setting execute bits makes the operations fail.</source>
          <target state="translated">新しい共有メモリセグメントの作成時に、許可を設定するために &lt;code&gt;FLAGS&lt;/code&gt; が使用されます。Sys V IPC実装で許可されていないフラグを設定しないように注意してください。一部のシステムでは、実行ビットを設定すると操作が失敗します。</target>
        </trans-unit>
        <trans-unit id="475139521c9cdabb77d7980af3eb2a8b5f2f65f2" translate="yes" xml:space="preserve">
          <source>On demand loader for PerlIO layers and root of PerlIO::* name space</source>
          <target state="translated">PerlIOレイヤとPerlIO::*ネームスペースのルート用のオンデマンド・ローダ</target>
        </trans-unit>
        <trans-unit id="f2bd0e6ad9c12f3371f3ea04fa2670eb6d77c58f" translate="yes" xml:space="preserve">
          <source>On each line are two expressions that do the same thing. The left-hand versions operate on the array &lt;code&gt;@a&lt;/code&gt; . The right-hand versions operate on the array that is referred to by &lt;code&gt;$aref&lt;/code&gt; . Once they find the array they're operating on, both versions do the same things to the arrays.</source>
          <target state="translated">各行には、同じことを行う2つの式があります。左側のバージョンは配列 &lt;code&gt;@a&lt;/code&gt; で動作します。右側のバージョンは、 &lt;code&gt;$aref&lt;/code&gt; によって参照される配列を操作します。動作しているアレイが見つかると、どちらのバージョンもアレイに対して同じことを行います。</target>
        </trans-unit>
        <trans-unit id="8897d9218b422eeafd07a396a29ac11d0861b3d9" translate="yes" xml:space="preserve">
          <source>On each line are two expressions that do the same thing. The left-hand versions operate on the array &lt;code&gt;@a&lt;/code&gt;. The right-hand versions operate on the array that is referred to by &lt;code&gt;$aref&lt;/code&gt;. Once they find the array they're operating on, both versions do the same things to the arrays.</source>
          <target state="translated">各行には、同じことを行う2つの式があります。左側のバージョンは配列 &lt;code&gt;@a&lt;/code&gt; で動作します。右側のバージョンは、 &lt;code&gt;$aref&lt;/code&gt; によって参照される配列で動作します。操作しているアレイが見つかると、どちらのバージョンもアレイに対して同じことを行います。</target>
        </trans-unit>
        <trans-unit id="9b2fc3f2e5f903dbf2df61622a774607772dffe7" translate="yes" xml:space="preserve">
          <source>On entry</source>
          <target state="translated">エントリー時</target>
        </trans-unit>
        <trans-unit id="5332f588a30c3ea7aadbd06e40cead0c170fd4cf" translate="yes" xml:space="preserve">
          <source>On entry &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;*len_p&lt;/code&gt; give the string to scan, &lt;code&gt;*flags&lt;/code&gt; gives conversion flags, and &lt;code&gt;result&lt;/code&gt; should be &lt;code&gt;NULL&lt;/code&gt; or a pointer to an NV. The scan stops at the end of the string, or at just before the first invalid character. Unless &lt;code&gt;PERL_SCAN_SILENT_ILLDIGIT&lt;/code&gt; is set in &lt;code&gt;*flags&lt;/code&gt;, encountering an invalid character (except NUL) will also trigger a warning. On return &lt;code&gt;*len_p&lt;/code&gt; is set to the length of the scanned string, and &lt;code&gt;*flags&lt;/code&gt; gives output flags.</source>
          <target state="translated">エントリの &lt;code&gt;start&lt;/code&gt; 、 &lt;code&gt;*len_p&lt;/code&gt; はスキャンする文字列を提供し、 &lt;code&gt;*flags&lt;/code&gt; は変換フラグを提供し、 &lt;code&gt;result&lt;/code&gt; は &lt;code&gt;NULL&lt;/code&gt; またはNVへのポインタである必要があります。スキャンは、文字列の最後、または最初の無効な文字の直前で停止します。 &lt;code&gt;*flags&lt;/code&gt; に &lt;code&gt;PERL_SCAN_SILENT_ILLDIGIT&lt;/code&gt; が設定されていない限り、無効な文字（NULを除く）が検出されると警告もトリガーされます。戻り時に、 &lt;code&gt;*len_p&lt;/code&gt; はスキャンされた文字列の長さに設定され、 &lt;code&gt;*flags&lt;/code&gt; は出力フラグを提供します。</target>
        </trans-unit>
        <trans-unit id="567461856d5e115d2b80a7fd737da1ad14817617" translate="yes" xml:space="preserve">
          <source>On entry, &lt;code&gt;pv&lt;/code&gt; points to the beginning of the string; &lt;code&gt;valptr&lt;/code&gt; points to a UV that will receive the converted value, if found; &lt;code&gt;endptr&lt;/code&gt; is either NULL or points to a variable that points to one byte beyond the point in &lt;code&gt;pv&lt;/code&gt; that this routine should examine. If &lt;code&gt;endptr&lt;/code&gt; is NULL, &lt;code&gt;pv&lt;/code&gt; is assumed to be NUL-terminated.</source>
          <target state="translated">入力時に、 &lt;code&gt;pv&lt;/code&gt; は文字列の先頭を指します。 &lt;code&gt;valptr&lt;/code&gt; は、見つかった場合、変換された値を受け取るUVを指します。 &lt;code&gt;endptr&lt;/code&gt; はNULLであるか、このルーチンが検査する必要がある &lt;code&gt;pv&lt;/code&gt; 内のポイントを1バイト超えた変数を指します。 &lt;code&gt;endptr&lt;/code&gt; がNULLの場合、 &lt;code&gt;pv&lt;/code&gt; はNULで終了したと見なされます。</target>
        </trans-unit>
        <trans-unit id="6bacb97a5d2d18dbb756caabc159aefdc9b27f2c" translate="yes" xml:space="preserve">
          <source>On error, &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; behaves just like &lt;a href=&quot;http://man.he.net/man2/select&quot;&gt;select(2)&lt;/a&gt;: it returns &lt;code&gt;-1&lt;/code&gt; and sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">エラーの場合、&lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt;は&lt;a href=&quot;http://man.he.net/man2/select&quot;&gt;select（2）と&lt;/a&gt;同じように動作します。 &lt;code&gt;-1&lt;/code&gt; を返し、&lt;a href=&quot;perlvar#%24%21&quot;&gt; &lt;code&gt;$!&lt;/code&gt; &lt;/a&gt;を設定します。。</target>
        </trans-unit>
        <trans-unit id="3a23d955ecebada1fa25792c21efad58d10123ee" translate="yes" xml:space="preserve">
          <source>On error, &lt;a href=&quot;#unlink-LIST&quot;&gt;&lt;code&gt;unlink&lt;/code&gt;&lt;/a&gt; will not tell you which files it could not remove. If you want to know which files you could not remove, try them one at a time:</source>
          <target state="translated">エラーの場合、&lt;a href=&quot;#unlink-LIST&quot;&gt; &lt;code&gt;unlink&lt;/code&gt; &lt;/a&gt;ても、削除できなかったファイルはわかりません。削除できなかったファイルを知りたい場合は、一度に1つずつ試してください。</target>
        </trans-unit>
        <trans-unit id="d373dfecfc1b40b4191bc53322c596729a91c216" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;$out&lt;/code&gt; will be</source>
          <target state="translated">エラーの場合、 &lt;code&gt;$out&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="6d9c828155c10075b78663a197d9675f7b0c4a6f" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; behaves just like select(2): it returns -1 and sets &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">エラーの場合、 &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; はselect（2）と同じように動作します。-1を返し、 &lt;code&gt;$!&lt;/code&gt; を設定します。。</target>
        </trans-unit>
        <trans-unit id="44a9825ad010a78ae9dfacedfc100780572dc5b3" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not tell you which files it could not remove. If you want to know which files you could not remove, try them one at a time:</source>
          <target state="translated">エラーの場合、 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; は、削除できなかったファイルは通知されません。削除できなかったファイルを知りたい場合は、一度に1つずつ試してください。</target>
        </trans-unit>
        <trans-unit id="819a867a035e72ad9106196135c7d9f4e3277f0c" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; behaves just like select(2): it returns -1 and sets &lt;code&gt;$!&lt;/code&gt; .</source>
          <target state="translated">エラーの場合、 &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; はselect（2）と同じように動作します。-1を返し、 &lt;code&gt;$!&lt;/code&gt; を設定します。。</target>
        </trans-unit>
        <trans-unit id="a02d8cd61d158290b01862aca1060c57ef007153" translate="yes" xml:space="preserve">
          <source>On error, &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; will not tell you which files it could not remove. If you want to know which files you could not remove, try them one at a time:</source>
          <target state="translated">エラーの場合、 &lt;code&gt;&lt;a href=&quot;unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; は、削除できなかったファイルは通知されません。削除できなかったファイルを知りたい場合は、一度に1つずつ試してください。</target>
        </trans-unit>
        <trans-unit id="45e73f10ec8215e1c14a06d24df3320696729415" translate="yes" xml:space="preserve">
          <source>On error, it returns a</source>
          <target state="translated">エラー時には</target>
        </trans-unit>
        <trans-unit id="18136bfa0b529aa75c0ac9c1c7bf6a9d9e72f925" translate="yes" xml:space="preserve">
          <source>On failure &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be returned and &lt;code&gt;$@&lt;/code&gt; will contain the reason for the failure.</source>
          <target state="translated">失敗すると &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返され、 &lt;code&gt;$@&lt;/code&gt; に失敗の理由が含まれます。</target>
        </trans-unit>
        <trans-unit id="50989ddb0a8dea38dc2bf4fcec10e5e4fe7a2870" translate="yes" xml:space="preserve">
          <source>On failure &lt;code&gt;undef&lt;/code&gt; will be returned and &lt;code&gt;$@&lt;/code&gt; will contain the reason for the failure.</source>
          <target state="translated">失敗すると &lt;code&gt;undef&lt;/code&gt; が返され、 &lt;code&gt;$@&lt;/code&gt; に失敗の理由が含まれます。</target>
        </trans-unit>
        <trans-unit id="42061a94fa2069016ce15d6e815f1341a1d2cabd" translate="yes" xml:space="preserve">
          <source>On failure, $decoder now contains an error message so the whole thing would be as follows;</source>
          <target state="translated">失敗した場合、$decoderにはエラーメッセージが含まれるようになったので、全体としては以下のようになります。</target>
        </trans-unit>
        <trans-unit id="e2a12adff03571a4d3b5aeaef29c5800c5825559" translate="yes" xml:space="preserve">
          <source>On failure, &lt;code&gt;$hObject&lt;/code&gt; gets set to a false value and &lt;code&gt;$^E&lt;/code&gt; and &lt;code&gt;fileLastError()&lt;/code&gt; are set to the reason for the failure. Otherwise, &lt;code&gt;$hObject&lt;/code&gt; gets set to a Win32 native file handle which is always a true value [returns &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; in the impossible(?) case of the handle having a value of &lt;code&gt;0&lt;/code&gt;].</source>
          <target state="translated">失敗すると、 &lt;code&gt;$hObject&lt;/code&gt; はfalse値に設定され、 &lt;code&gt;$^E&lt;/code&gt; と &lt;code&gt;fileLastError()&lt;/code&gt; は失敗の理由に設定されます。それ以外の場合、 &lt;code&gt;$hObject&lt;/code&gt; は常に真の値であるWin32ネイティブファイルハンドルに設定されます[値が &lt;code&gt;0&lt;/code&gt; のハンドルの不可能（？）の場合は &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 返します]。</target>
        </trans-unit>
        <trans-unit id="da0d12758631e756bc101c1b7dbd8f7f1bdeb657" translate="yes" xml:space="preserve">
          <source>On failure, &lt;code&gt;$hObject&lt;/code&gt; gets set to a false value and &lt;code&gt;regLastError()&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt; are set to the reason for the failure. Otherwise, &lt;code&gt;$hObject&lt;/code&gt; gets set to a Win32 native file handle which is always a true value [returns &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; in the impossible(?) case of the handle having a value of &lt;code&gt;0&lt;/code&gt;].</source>
          <target state="translated">失敗すると、 &lt;code&gt;$hObject&lt;/code&gt; はfalse値に設定され、 &lt;code&gt;regLastError()&lt;/code&gt; と &lt;code&gt;$^E&lt;/code&gt; が失敗の理由に設定されます。それ以外の場合、 &lt;code&gt;$hObject&lt;/code&gt; は常に真の値であるWin32ネイティブファイルハンドルに設定されます[値が &lt;code&gt;0&lt;/code&gt; のハンドルの不可能（？）の場合は &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 返します]。</target>
        </trans-unit>
        <trans-unit id="4946878f668a0186d10fe06797278b27abd1a3bc" translate="yes" xml:space="preserve">
          <source>On failure, all of these values (except the remaining text) are &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">失敗した場合、これらの値（残りのテキストを除く）はすべて &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="65448e86201e7fdba6e3baaecf1b7bd6e213136d" translate="yes" xml:space="preserve">
          <source>On failure, all of these values (except the remaining text) are &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">失敗すると、これらの値（残りのテキストを除く）はすべて &lt;code&gt;undef&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="ea1fcaac32326ffae83caa0ffe515456c5f51d0d" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the</source>
          <target state="translated">失敗すると、 &lt;code&gt;$REGERROR&lt;/code&gt; 変数はに設定されます</target>
        </trans-unit>
        <trans-unit id="e0a91a2a84ece7b39d4d347acdd9155aefa71bb9" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;$REGERROR&lt;/code&gt; variable will be set to the ARG value of the verb pattern, if the verb was involved in the failure of the match. If the ARG part of the pattern was omitted, then &lt;code&gt;$REGERROR&lt;/code&gt; will be set to the name of the last &lt;code&gt;(*MARK:NAME)&lt;/code&gt; pattern executed, or to TRUE if there was none. Also, the &lt;code&gt;$REGMARK&lt;/code&gt; variable will be set to FALSE.</source>
          <target state="translated">動詞が一致の失敗に関与した場合、失敗時に &lt;code&gt;$REGERROR&lt;/code&gt; 変数は動詞パターンのARG値に設定されます。パターンのARG部分が省略された場合、 &lt;code&gt;$REGERROR&lt;/code&gt; は最後に実行された &lt;code&gt;(*MARK:NAME)&lt;/code&gt; パターンの名前に設定されます。ない場合はTRUEに設定されます。また、 &lt;code&gt;$REGMARK&lt;/code&gt; 変数はFALSEに設定されます。</target>
        </trans-unit>
        <trans-unit id="5064a047349d10718c6c646e1984f32902ee6b9f" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call returns an undefined value and probably sets &lt;code&gt;$!&lt;/code&gt; to contain the reason the file could not be tied.</source>
          <target state="translated">失敗すると、 &lt;code&gt;&lt;a href=&quot;functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 呼び出しは未定義の値を返し、おそらく &lt;code&gt;$!&lt;/code&gt; ファイルを結合できなかった理由を含めるため。</target>
        </trans-unit>
        <trans-unit id="d91548debf2b08e67d7bcf23bbc8c0787287ca77" translate="yes" xml:space="preserve">
          <source>On failure, the &lt;code&gt;tie&lt;/code&gt; call returns an undefined value and probably sets &lt;code&gt;$!&lt;/code&gt; to contain the reason the file could not be tied.</source>
          <target state="translated">失敗すると、 &lt;code&gt;tie&lt;/code&gt; 呼び出しは未定義の値を返し、おそらく &lt;code&gt;$!&lt;/code&gt; 設定します！ファイルを結び付けることができなかった理由を含めるため。</target>
        </trans-unit>
        <trans-unit id="6499c88e3c2522e878e6f7bffd23feb1b280e5ce" translate="yes" xml:space="preserve">
          <source>On input, it converts the bytes expected to be in the specified character set and encoding to Perl string data (Unicode and Perl's internal Unicode encoding, UTF-8). On output, it converts Perl string data into the specified character set and encoding.</source>
          <target state="translated">入力時には、指定された文字セットとエンコーディングに含まれると予想されるバイトをPerlの文字列データ(UnicodeとPerlの内部UnicodeエンコーディングであるUTF-8)に変換します。出力時には、Perl の文字列データを指定された文字セットとエンコーディングに変換します。</target>
        </trans-unit>
        <trans-unit id="bbed2b20ba397a052877c8697b2b911fb1c6434c" translate="yes" xml:space="preserve">
          <source>On merging and rebasing</source>
          <target state="translated">マージとリベースについて</target>
        </trans-unit>
        <trans-unit id="31535bab82f01485bf978083451a0bfcdeb0cd1c" translate="yes" xml:space="preserve">
          <source>On modern Linux systems these are typically GDBM files, which are not portable across platforms.</source>
          <target state="translated">最近のLinuxシステムでは、これらのファイルは通常GDBMファイルであり、プラットフォーム間での移植性はありません。</target>
        </trans-unit>
        <trans-unit id="a604823a1a15074f7b145c1cca70f834c1350b88" translate="yes" xml:space="preserve">
          <source>On most Unix platforms, the &lt;code&gt;CHLD&lt;/code&gt; (sometimes also known as &lt;code&gt;CLD&lt;/code&gt; ) signal has special behavior with respect to a value of &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; . Setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; on such a platform has the effect of not creating zombie processes when the parent process fails to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; on its child processes (i.e., child processes are automatically reaped). Calling &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;$SIG{CHLD}&lt;/code&gt; set to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; usually returns &lt;code&gt;-1&lt;/code&gt; on such platforms.</source>
          <target state="translated">ほとんどのUnixプラットフォームでは、 &lt;code&gt;CHLD&lt;/code&gt; （ &lt;code&gt;CLD&lt;/code&gt; とも呼ばれる）信号は、 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; の値に関して特別な動作をします。このようなプラットフォームで &lt;code&gt;$SIG{CHLD}&lt;/code&gt; を &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; に設定すると、親プロセスが子プロセスで &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; に失敗したときにゾンビプロセスが作成されない（つまり、子プロセスが自動的に刈り取られる）効果があります。 &lt;code&gt;$SIG{CHLD}&lt;/code&gt; を &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; に設定して &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; を呼び出すと、通常、このようなプラットフォームでは &lt;code&gt;-1&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="42dd9a903659956c4b893b1487852dbdc8ae83fe" translate="yes" xml:space="preserve">
          <source>On most Unix platforms, the &lt;code&gt;CHLD&lt;/code&gt; (sometimes also known as &lt;code&gt;CLD&lt;/code&gt;) signal has special behavior with respect to a value of &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt;. Setting &lt;code&gt;$SIG{CHLD}&lt;/code&gt; to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; on such a platform has the effect of not creating zombie processes when the parent process fails to &lt;code&gt;wait()&lt;/code&gt; on its child processes (i.e., child processes are automatically reaped). Calling &lt;code&gt;wait()&lt;/code&gt; with &lt;code&gt;$SIG{CHLD}&lt;/code&gt; set to &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; usually returns &lt;code&gt;-1&lt;/code&gt; on such platforms.</source>
          <target state="translated">ほとんどのUnixプラットフォームでは、 &lt;code&gt;CHLD&lt;/code&gt; （ &lt;code&gt;CLD&lt;/code&gt; とも呼ばれる）信号は、 &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 値に関して特別な動作をします。このようなプラットフォームで &lt;code&gt;$SIG{CHLD}&lt;/code&gt; を &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; に設定すると、親プロセスが子プロセスで &lt;code&gt;wait()&lt;/code&gt; に失敗した場合（つまり、子プロセスが自動的に取得された場合）にゾンビプロセスが作成されないという効果があります。 &lt;code&gt;$SIG{CHLD}&lt;/code&gt; を &lt;code&gt;&quot;IGNORE&quot;&lt;/code&gt; 設定して &lt;code&gt;wait()&lt;/code&gt; を呼び出すと、通常、このようなプラットフォームでは &lt;code&gt;-1&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="42bca4f6aa51b9c47b8c54f57cf475cd9eb5d60c" translate="yes" xml:space="preserve">
          <source>On most operating systems, memory allocated to a program can never be returned to the system. That's why long-running programs sometimes re- exec themselves. Some operating systems (notably, systems that use mmap(2) for allocating large chunks of memory) can reclaim memory that is no longer used, but on such systems, perl must be configured and compiled to use the OS's malloc, not perl's.</source>
          <target state="translated">ほとんどのオペレーティングシステムでは、プログラムに割り当てられたメモリをシステムに戻すことはできません。これが、長時間実行されているプログラムが時々再実行される理由です。いくつかのオペレーティングシステム(特に、大きなメモリの塊を割り当てるために mmap(2)を使用するシステム)では、使用されなくなったメモリを取り戻すことができますが、そのようなシステムでは、perl は、perl のではなく、OS の malloc を使用するように設定してコンパイルしなければなりません。</target>
        </trans-unit>
        <trans-unit id="5ddf61a72a0a9ae32d8b7111f593a7bce6fa31c0" translate="yes" xml:space="preserve">
          <source>On most systems, frequent and continual creation and destruction of threads can lead to ever-increasing growth in the memory footprint of the Perl interpreter. While it is simple to just launch threads and then &lt;code&gt;-&amp;gt;join()&lt;/code&gt; or &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; them, for long-lived applications, it is better to maintain a pool of threads, and to reuse them for the work needed, using &lt;a href=&quot;Thread::Queue&quot;&gt;queues&lt;/a&gt; to notify threads of pending work. The CPAN distribution of this module contains a simple example (</source>
          <target state="translated">ほとんどのシステムでは、スレッドの頻繁かつ継続的な作成と破棄により、Perlインタープリターのメモリーフットプリントがますます増大する可能性があります。スレッドを起動してから &lt;code&gt;-&amp;gt;join()&lt;/code&gt; または &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; するのは簡単ですが、寿命の長いアプリケーションの場合は、スレッドのプールを維持し、&lt;a href=&quot;Thread::Queue&quot;&gt;キュー&lt;/a&gt;を使用して必要な作業にスレッドを再利用することをお勧めします。保留中の作業をスレッドに通知します。このモジュールのCPANディストリビューションには、簡単な例が含まれています（</target>
        </trans-unit>
        <trans-unit id="b3a71ab0d471330a25bbd4385691ed243516aede" translate="yes" xml:space="preserve">
          <source>On most systems, frequent and continual creation and destruction of threads can lead to ever-increasing growth in the memory footprint of the Perl interpreter. While it is simple to just launch threads and then &lt;code&gt;-&amp;gt;join()&lt;/code&gt; or &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; them, for long-lived applications, it is better to maintain a pool of threads, and to reuse them for the work needed, using &lt;a href=&quot;thread/queue&quot;&gt;queues&lt;/a&gt; to notify threads of pending work. The CPAN distribution of this module contains a simple example (</source>
          <target state="translated">ほとんどのシステムでは、スレッドが頻繁に継続的に作成および破棄されると、Perlインタープリターのメモリーフットプリントが増加し続ける可能性があります。スレッドを起動して &lt;code&gt;-&amp;gt;join()&lt;/code&gt; または &lt;code&gt;-&amp;gt;detach()&lt;/code&gt; するだけの簡単な方法ですが、長命のアプリケーションでは、スレッドのプールを維持し、&lt;a href=&quot;thread/queue&quot;&gt;キュー&lt;/a&gt;を使用して必要な作業に再利用する方が良いでしょう。保留中の作業をスレッドに通知します。このモジュールのCPANディストリビューションには、簡単な例（</target>
        </trans-unit>
        <trans-unit id="09b3ddc53760535691fb4b1738d8256a44f591bc" translate="yes" xml:space="preserve">
          <source>On most systems, you are not allowed to change the ownership of the file unless you're the superuser, although you should be able to change the group to any of your secondary groups. On insecure systems, these restrictions may be relaxed, but this is not a portable assumption. On POSIX systems, you can detect this condition this way:</source>
          <target state="translated">ほとんどのシステムでは、あなたがスーパーユーザでない限り、ファイルの所有権を変更することはできませんが、グループをセカンダリグループのいずれかに変更できるはずです。安全でないシステムでは、これらの制限は緩和されているかもしれませんが、これは移植可能な前提ではありません。POSIX システムでは、このようにしてこの状態を検出することができます。</target>
        </trans-unit>
        <trans-unit id="55db381aabae41a989aa28b8f5a435f2f353e7d6" translate="yes" xml:space="preserve">
          <source>On multi-threaded builds on systems that do have per-thread locale operations, this function converts the thread it is running in to use the global locale. This is for code that has not yet or cannot be updated to handle multi-threaded locale operation. As long as only a single thread is so-converted, everything works fine, as all the other threads continue to ignore the global one, so only this thread looks at it.</source>
          <target state="translated">スレッド単位のロケール操作が可能なシステム上でマルチスレッドビルドを行った場合、 この関数は実行中のスレッドをグローバルロケールに変換します。これは、まだマルチスレッドのロケール操作に対応していない、あるいは対応できないコードを対象としています。単一のスレッドだけが変換されている限り、他のすべてのスレッドはグローバルロケールを無視し続け、 このスレッドだけがグローバルロケールを見るようになるので、すべてが正常に動作します。</target>
        </trans-unit>
        <trans-unit id="2cfd993657bc1e027b5466df69e07a3c252bb4a5" translate="yes" xml:space="preserve">
          <source>On newer 64 bit versions of OpenVMS, a process setting now controls if the quoting is needed to preserve the case of command line arguments.</source>
          <target state="translated">OpenVMS の新しい 64 ビット版では、プロセス設定でコマンドライン引数の大文字小文字を区別するためにクォートが必要かどうかを制御するようになりました。</target>
        </trans-unit>
        <trans-unit id="d67a298149fc32636cbc2cf9ffd43cf9447cc565" translate="yes" xml:space="preserve">
          <source>On older versions of perl, negative epoch (&lt;code&gt;time_t&lt;/code&gt; ) values, which are not officially supported by the POSIX standards, are known not to work on some systems. These include MacOS (pre-OSX) and Win32.</source>
          <target state="translated">古いバージョンのperlでは、POSIX標準で公式にサポートされていない負のエポック（ &lt;code&gt;time_t&lt;/code&gt; ）値は、一部のシステムでは機能しないことがわかっています。これらには、MacOS（OSX以前）とWin32が含まれます。</target>
        </trans-unit>
        <trans-unit id="ddfc76c9171838788051ad1318da16d035f5b0fe" translate="yes" xml:space="preserve">
          <source>On older versions of perl, negative epoch (&lt;code&gt;time_t&lt;/code&gt;) values, which are not officially supported by the POSIX standards, are known not to work on some systems. These include MacOS (pre-OSX) and Win32.</source>
          <target state="translated">古いバージョンのperlでは、POSIX標準で公式にサポートされていない負のエポック（ &lt;code&gt;time_t&lt;/code&gt; ）値は、一部のシステムでは機能しないことがわかっています。これらには、MacOS（OSX以前）およびWin32が含まれます。</target>
        </trans-unit>
        <trans-unit id="b2a99aa4e31ced8b38922d7821d5fd751e2740ad" translate="yes" xml:space="preserve">
          <source>On operating systems with the concept of a volume the second element of a file:// is considered to the be volume specification for the file. Thus on Win32 this routine returns the volume, on other operating systems this returns nothing.</source>
          <target state="translated">ボリュームの概念を持つオペレーティングシステムでは、file://の2番目の要素がファイルのボリューム指定とみなされます。したがって、Win32ではこのルーチンはボリュームを返しますが、他のオペレーティングシステムでは何も返されません。</target>
        </trans-unit>
        <trans-unit id="4f2532376ddc057f764de9bec478db299bbe8f82" translate="yes" xml:space="preserve">
          <source>On perl version 5.12.0 and newer, negative epoch values are fully supported.</source>
          <target state="translated">perl バージョン 5.12.0 以降では、負のエポック値が完全にサポートされています。</target>
        </trans-unit>
        <trans-unit id="134a9f11ec0d2ae5a78490a1f61d61a762f1fd76" translate="yes" xml:space="preserve">
          <source>On perl versions older than 5.12.0, the range of dates that can be actually be handled depends on the size of &lt;code&gt;time_t&lt;/code&gt; (usually a signed integer) on the given platform. Currently, this is 32 bits for most systems, yielding an approximate range from Dec 1901 to Jan 2038.</source>
          <target state="translated">5.12.0より古いPerlバージョンでは、実際に処理できる日付の範囲は、指定されたプラットフォームの &lt;code&gt;time_t&lt;/code&gt; （通常は符号付き整数）のサイズによって異なります。現在、これはほとんどのシステムで32ビットであり、1901年12月から2038年1月までの範囲を示しています。</target>
        </trans-unit>
        <trans-unit id="6022d860b9d735662ef67778672104ce7f7a553c" translate="yes" xml:space="preserve">
          <source>On platforms where &lt;code&gt;need_prelink()&lt;/code&gt; returns true, &lt;code&gt;prelink()&lt;/code&gt; will be called automatically.</source>
          <target state="translated">&lt;code&gt;need_prelink()&lt;/code&gt; がtrueを返すプラットフォームでは、 &lt;code&gt;prelink()&lt;/code&gt; が自動的に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="d4f25eb75f8ca9d9043202ca7699535809aaaa12" translate="yes" xml:space="preserve">
          <source>On platforms where it matters, be sure to call &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; on the descriptors that you pass to Storable functions.</source>
          <target state="translated">重要なプラットフォームでは、Storable関数に渡す記述子で必ず &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; を呼び出してください。</target>
        </trans-unit>
        <trans-unit id="393fb98f717dd89ac6a03e530e4afbcbe5a39830" translate="yes" xml:space="preserve">
          <source>On platforms where it matters, be sure to call &lt;code&gt;binmode()&lt;/code&gt; on the descriptors that you pass to Storable functions.</source>
          <target state="translated">重要なプラットフォームでは、Storable関数に渡す記述子で &lt;code&gt;binmode()&lt;/code&gt; を必ず呼び出してください。</target>
        </trans-unit>
        <trans-unit id="741623a3d6fbed74253acab5fef8f32b395ea643" translate="yes" xml:space="preserve">
          <source>On pre-C99 compilers, &lt;code&gt;bool&lt;/code&gt; is defined as equivalent to &lt;code&gt;char&lt;/code&gt; . Consequently assignment of any larger type to a &lt;code&gt;bool&lt;/code&gt; is unsafe and may be truncated. The &lt;code&gt;cBOOL&lt;/code&gt; macro exists to cast it correctly.</source>
          <target state="translated">C99より前のコンパイラでは、 &lt;code&gt;bool&lt;/code&gt; は &lt;code&gt;char&lt;/code&gt; と同等に定義されています。その結果、より大きな型の &lt;code&gt;bool&lt;/code&gt; への割り当ては安全ではなく、切り捨てられる可能性があります。 &lt;code&gt;cBOOL&lt;/code&gt; のマクロが正しく、それをキャストするために存在します。</target>
        </trans-unit>
        <trans-unit id="96fc20ca3129c68549ac1ab95e6fa005be780a85" translate="yes" xml:space="preserve">
          <source>On pre-C99 compilers, &lt;code&gt;bool&lt;/code&gt; is defined as equivalent to &lt;code&gt;char&lt;/code&gt;. Consequently assignment of any larger type to a &lt;code&gt;bool&lt;/code&gt; is unsafe and may be truncated. The &lt;code&gt;cBOOL&lt;/code&gt; macro exists to cast it correctly; you may also find that using it is shorter and clearer than writing out the equivalent conditional expression longhand.</source>
          <target state="translated">C99より前のコンパイラでは、 &lt;code&gt;bool&lt;/code&gt; は &lt;code&gt;char&lt;/code&gt; と同等に定義されています。したがって、 &lt;code&gt;bool&lt;/code&gt; へのより大きな型の割り当ては安全ではなく、切り捨てられる可能性があります。 &lt;code&gt;cBOOL&lt;/code&gt; のマクロが正しく、それをキャストするために存在します。また、同等の条件式を手書きで書くよりも、それを使用する方が短くて明確であることに気付くかもしれません。</target>
        </trans-unit>
        <trans-unit id="2c58ed64b6e077e0a2ecc28338446ee744bcc90f" translate="yes" xml:space="preserve">
          <source>On rare occasion, such as a database read, you may be given encoded text you need to decode.</source>
          <target state="translated">まれに、データベースの読み取りのように、デコードする必要のあるエンコードされたテキストが与えられることがあります。</target>
        </trans-unit>
        <trans-unit id="b2d3547ac3050c26cb1992ceb42fa15fd067f32b" translate="yes" xml:space="preserve">
          <source>On return, the reference will overwrite the hash slot in the symbol table specified by the *some_hash typeglob. This is a somewhat tricky way of passing around references cheaply when you don't want to have to remember to dereference variables explicitly.</source>
          <target state="translated">戻り値として、参照は *some_hash typeglob で指定されたシンボルテーブルのハッシュスロットを上書きします。これは、変数を明示的に参照解除することを覚えておく必要がない場合に、参照を安く渡すためのややトリッキーな方法です。</target>
        </trans-unit>
        <trans-unit id="aca1e4ba9558a35891aca8fc5a87a5dbef0654bd" translate="yes" xml:space="preserve">
          <source>On simple groups, such as the pattern &lt;code&gt;(?&amp;gt; [^()]+ )&lt;/code&gt;, a comparable effect may be achieved by negative look-ahead, as in &lt;code&gt;[^()]+ (?! [^()] )&lt;/code&gt;. This was only 4 times slower on a string with 1000000 &lt;code&gt;a&lt;/code&gt; s.</source>
          <target state="translated">パターン &lt;code&gt;(?&amp;gt; [^()]+ )&lt;/code&gt; などの単純なグループでは、 &lt;code&gt;[^()]+ (?! [^()] )&lt;/code&gt; ように、否定的な先読みによって同等の効果が得られる場合があります。これは、1000000 &lt;code&gt;a&lt;/code&gt; sの文字列では4倍だけ遅くなりました。</target>
        </trans-unit>
        <trans-unit id="85475d75a07389a71a82f474a6904ca008087309" translate="yes" xml:space="preserve">
          <source>On simple groups, such as the pattern &lt;code&gt;(?&amp;gt; [^()]+ )&lt;/code&gt;, a comparable effect may be achieved by negative lookahead, as in &lt;code&gt;[^()]+ (?! [^()] )&lt;/code&gt;. This was only 4 times slower on a string with 1000000 &lt;code&gt;&quot;a&quot;&lt;/code&gt;s.</source>
          <target state="translated">パターン &lt;code&gt;(?&amp;gt; [^()]+ )&lt;/code&gt; などの単純なグループでは、 &lt;code&gt;[^()]+ (?! [^()] )&lt;/code&gt; ように、負の先読みによって同等の効果が得られる場合があります。これは、1000000 &lt;code&gt;&quot;a&quot;&lt;/code&gt; の文字列ではわずか4倍遅くなりました。</target>
        </trans-unit>
        <trans-unit id="85e1720394957ce5ba2b00bf5b14ca83e7b1f8cb" translate="yes" xml:space="preserve">
          <source>On some (but not all) operating systems assigning to &lt;code&gt;$0&lt;/code&gt; modifies the argument area that the &lt;code&gt;ps&lt;/code&gt; program sees. On some platforms you may have to use special &lt;code&gt;ps&lt;/code&gt; options or a different &lt;code&gt;ps&lt;/code&gt; to see the changes. Modifying the &lt;code&gt;$0&lt;/code&gt; is more useful as a way of indicating the current program state than it is for hiding the program you're running.</source>
          <target state="translated">一部の（すべてではない）オペレーティングシステムでは、 &lt;code&gt;$0&lt;/code&gt; 割り当てると、 &lt;code&gt;ps&lt;/code&gt; プログラムが認識する引数領域が変更されます。一部のプラットフォームでは、変更を表示するために特別な &lt;code&gt;ps&lt;/code&gt; オプションまたは別の &lt;code&gt;ps&lt;/code&gt; を使用する必要がある場合があります。 &lt;code&gt;$0&lt;/code&gt; 変更することは、実行中のプログラムを非表示にするよりも、現在のプログラムの状態を示す方法として役立ちます。</target>
        </trans-unit>
        <trans-unit id="84e7fe0a4e81ece19af2adc12a430c2ffe84e1ae" translate="yes" xml:space="preserve">
          <source>On some OS's where . has special meaning VERSION_SYM may be used in place of VERSION.</source>
          <target state="translated">.が特別な意味を持つOSでは、VERSION_SYMがVERSIONの代わりに使われることがあります。</target>
        </trans-unit>
        <trans-unit id="a3f9bf6c90ba9706d9e17b2321836d771bd8fd28" translate="yes" xml:space="preserve">
          <source>On some Unixes, &lt;a href=&quot;http://man.he.net/man2/select&quot;&gt;select(2)&lt;/a&gt; may report a socket file descriptor as &quot;ready for reading&quot; even when no data is available, and thus any subsequent &lt;a href=&quot;#read-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; would block. This can be avoided if you always use &lt;code&gt;O_NONBLOCK&lt;/code&gt; on the socket. See &lt;a href=&quot;http://man.he.net/man2/select&quot;&gt;select(2)&lt;/a&gt; and &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; for further details.</source>
          <target state="translated">一部のUnixでは、&lt;a href=&quot;http://man.he.net/man2/select&quot;&gt;select（2）&lt;/a&gt;は、データが利用できない場合でもソケットファイル記述子を「読み取り準備完了」として報告する場合があるため、以降の&lt;a href=&quot;#read-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;はブロックされます。ソケットで常に &lt;code&gt;O_NONBLOCK&lt;/code&gt; を使用する場合、これを回避できます。詳細については、&lt;a href=&quot;http://man.he.net/man2/select&quot;&gt;select（2）&lt;/a&gt;および&lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl（2）&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="eae6ee7e119fbc5f2aa2be859ce356e5505eb961" translate="yes" xml:space="preserve">
          <source>On some Unixes, select(2) may report a socket file descriptor as &quot;ready for reading&quot; even when no data is available, and thus any subsequent &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; would block. This can be avoided if you always use O_NONBLOCK on the socket. See select(2) and fcntl(2) for further details.</source>
          <target state="translated">一部のUnixでは、select（2）は、データが利用できない場合でもソケットファイル記述子を「ready for &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 」として報告する場合があり、それ以降の読み込みはブロックされます。これは、常にソケットでO_NONBLOCKを使用する場合に回避できます。詳細については、select（2）およびfcntl（2）を参照してください。</target>
        </trans-unit>
        <trans-unit id="c9de2fe586a63b0f77cf89fdbb109c06623eb1f4" translate="yes" xml:space="preserve">
          <source>On some Unixes, select(2) may report a socket file descriptor as &quot;ready for reading&quot; even when no data is available, and thus any subsequent &lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; would block. This can be avoided if you always use O_NONBLOCK on the socket. See select(2) and fcntl(2) for further details.</source>
          <target state="translated">一部のUnixでは、select（2）は、データが利用できない場合でもソケットファイル記述子を「ready for &lt;code&gt;&lt;a href=&quot;read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; 」として報告する場合があり、それ以降の読み込みはブロックされます。これは、常にソケットでO_NONBLOCKを使用する場合に回避できます。詳細については、select（2）およびfcntl（2）を参照してください。</target>
        </trans-unit>
        <trans-unit id="a5313472f5f477e89baab3e33db4f6dd3bf9c900" translate="yes" xml:space="preserve">
          <source>On some older low-end devices -- think early 2.2 era -- some tests, particularly</source>
          <target state="translated">いくつかの古いローエンドデバイス(初期の2.2時代と思われる)では、いくつかのテスト、特に</target>
        </trans-unit>
        <trans-unit id="5ae4b16cd5d25f3c3c80ae711072c40499b4bc55" translate="yes" xml:space="preserve">
          <source>On some older systems, it may sleep up to a full second less than what you requested, depending on how it counts seconds. Most modern systems always sleep the full amount. They may appear to sleep longer than that, however, because your process might not be scheduled right away in a busy multitasking system.</source>
          <target state="translated">いくつかの古いシステムでは、秒数のカウント方法によっては、要求されたものよりも1秒少なく、最大で1秒までスリープすることがあります。ほとんどの最新のシステムでは、常に要求された分だけスリープします。しかし、忙しいマルチタスクシステムでは、プロセスがすぐにスケジュールされない場合があるため、それよりも長くスリープしているように見えるかもしれません。</target>
        </trans-unit>
        <trans-unit id="558bd651fa8715821f75a4be7598cfc24234462e" translate="yes" xml:space="preserve">
          <source>On some operating systems certain signal handlers are supposed to &quot;do something&quot; before returning. One example can be CHLD or CLD, which indicates a child process has completed. On some operating systems the signal handler is expected to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; for the completed child process. On such systems the deferred signal scheme will not work for those signals: it does not do the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;. Again the failure will look like a loop as the operating system will reissue the signal because there are completed child processes that have not yet been &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt;ed for.</source>
          <target state="translated">一部のオペレーティングシステムでは、特定のシグナルハンドラが戻る前に「何かをする」ことが想定されています。たとえば、CHLDまたはCLDは、子プロセスが完了したことを示します。一部のオペレーティングシステムでは、シグナルハンドラーは、完了した子プロセスを &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 必要があります。このようなシステムでは、遅延シグナル方式はそれらのシグナルに対して機能しません。 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; は行われません。ここでも、まだ &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; されていない完了した子プロセスがあるため、オペレーティングシステムがシグナルを再発行するため、障害はループのように見えます。</target>
        </trans-unit>
        <trans-unit id="4baadfb850b3b420c9f511f27da50a1880c9c102" translate="yes" xml:space="preserve">
          <source>On some operating systems certain signal handlers are supposed to &quot;do something&quot; before returning. One example can be CHLD or CLD, which indicates a child process has completed. On some operating systems the signal handler is expected to &lt;code&gt;wait&lt;/code&gt; for the completed child process. On such systems the deferred signal scheme will not work for those signals: it does not do the &lt;code&gt;wait&lt;/code&gt;. Again the failure will look like a loop as the operating system will reissue the signal because there are completed child processes that have not yet been &lt;code&gt;wait&lt;/code&gt;ed for.</source>
          <target state="translated">一部のオペレーティングシステムでは、特定のシグナルハンドラが戻る前に「何かをする」ことになっています。 1つの例として、CHLDまたはCLDがあります。これは、子プロセスが完了したことを示します。一部のオペレーティングシステムでは、シグナルハンドラは子プロセスの完了を &lt;code&gt;wait&lt;/code&gt; することが期待されています。このようなシステムでは、遅延信号スキームはこれらの信号に対して機能しません。 &lt;code&gt;wait&lt;/code&gt; は行いません。この場合も、まだ &lt;code&gt;wait&lt;/code&gt; されていない完了した子プロセスがあるため、オペレーティングシステムがシグナルを再発行するため、障害はループのように見えます。</target>
        </trans-unit>
        <trans-unit id="b286c0e46361b954aaba8f772a4a53334de3bd4e" translate="yes" xml:space="preserve">
          <source>On some operating systems such as Win32 installation may not be possible until after a reboot has occurred. This can have varying consequences: removing an old DLL does not impact programs using the new one, but if a new DLL cannot be installed properly until reboot then anything depending on it must wait. The package variable</source>
          <target state="translated">Win32 のようないくつかのオペレーティングシステムでは、再起動が起こるまでインストールができないことがあります。これは様々な結果をもたらします:古い DLL を削除しても新しい DLL を使用しているプログラムには影響しませんが、新しい DLL が再起動するまで適切にインストールできない場合は、それに依存するものはすべて待機しなければなりません。パッケージ変数</target>
        </trans-unit>
        <trans-unit id="abbe82684e199993d30da7c411dda78b8ffa5204" translate="yes" xml:space="preserve">
          <source>On some operating systems, notably Solaris and Unixware, calling &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; from a child process will flush and close open filehandles in the parent, thereby corrupting the filehandles. On these systems, calling &lt;code&gt;_exit()&lt;/code&gt; is suggested instead. &lt;code&gt;_exit()&lt;/code&gt; is available in Perl through the &lt;code&gt;POSIX&lt;/code&gt; module. Please consult your system's manpages for more information on this.</source>
          <target state="translated">一部のオペレーティングシステム、特にSolarisとUnixwareでは、子プロセスから &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit()&lt;/a&gt;&lt;/code&gt; を呼び出すと、親の開いているファイルハンドルがフラッシュおよびクローズされ、ファイルハンドルが破損します。これらのシステムでは、代わりに &lt;code&gt;_exit()&lt;/code&gt; を呼び出すことをお勧めします。 &lt;code&gt;_exit()&lt;/code&gt; は、 &lt;code&gt;POSIX&lt;/code&gt; モジュールを通じてPerlで使用できます。詳細については、システムのマンページを参照してください。</target>
        </trans-unit>
        <trans-unit id="78cb1737975a62fce19002f1001d673ccd249508" translate="yes" xml:space="preserve">
          <source>On some operating systems, notably Solaris and Unixware, calling &lt;code&gt;exit()&lt;/code&gt; from a child process will flush and close open filehandles in the parent, thereby corrupting the filehandles. On these systems, calling &lt;code&gt;_exit()&lt;/code&gt; is suggested instead. &lt;code&gt;_exit()&lt;/code&gt; is available in Perl through the &lt;code&gt;POSIX&lt;/code&gt; module. Please consult your system's manpages for more information on this.</source>
          <target state="translated">一部のオペレーティングシステム、特にSolarisおよびUnixwareでは、子プロセスから &lt;code&gt;exit()&lt;/code&gt; を呼び出すと、親で開いているファイルハンドルがフラッシュされて閉じられるため、ファイルハンドルが破損します。これらのシステムでは、代わりに &lt;code&gt;_exit()&lt;/code&gt; を呼び出すことをお勧めします。 &lt;code&gt;_exit()&lt;/code&gt; は、 &lt;code&gt;POSIX&lt;/code&gt; モジュールを介してPerlで使用できます。詳細については、システムのマンページを参照してください。</target>
        </trans-unit>
        <trans-unit id="e360f8c5bbe5608f4331396810f247c8a100f0a1" translate="yes" xml:space="preserve">
          <source>On some platforms (notably DOS-like ones), the shell may not be capable of dealing with multiline commands, so putting newlines in the string may not get you what you want. You may be able to evaluate multiple commands in a single line by separating them with the command separator character, if your shell supports that (for example, &lt;code&gt;;&lt;/code&gt; on many Unix shells and &lt;code&gt;&amp;amp;&lt;/code&gt; on the Windows NT &lt;code&gt;cmd&lt;/code&gt; shell).</source>
          <target state="translated">一部のプラットフォーム（特にDOSライクなプラットフォーム）では、シェルが複数行のコマンドを処理できない場合があるため、文字列に改行を入れても期待どおりの結果が得られない場合があります。 （例えば、シェルのサポートしている場合は、コマンドの区切り文字で区切って、単一の行に複数のコマンドを評価することができるかもしれ &lt;code&gt;;&lt;/code&gt; 多くのUnixシェル上と &lt;code&gt;&amp;amp;&lt;/code&gt; Windows NT上で &lt;code&gt;cmd&lt;/code&gt; をシェル）。</target>
        </trans-unit>
        <trans-unit id="b7498bd2534b138ca9192ebcb30213ef70ed5c94" translate="yes" xml:space="preserve">
          <source>On some platforms Perl supports retrieving the C level backtrace (similar to what symbolic debuggers like gdb do).</source>
          <target state="translated">いくつかのプラットフォームでは、Perl は C レベルのバックトレースの取得をサポートしています (gdb のようなシンボリックデバッガが行うのと似ています)。</target>
        </trans-unit>
        <trans-unit id="f4483b458e9a6174b9a55320be46bd1995517e00" translate="yes" xml:space="preserve">
          <source>On some platforms inode numbers are of a type larger than perl knows how to handle as integer numerical values. If necessary, an inode number will be returned as a decimal string in order to preserve the entire value. If used in a numeric context, this will be converted to a floating-point numerical value, with rounding, a fate that is best avoided. Therefore, you should prefer to compare inode numbers using &lt;code&gt;eq&lt;/code&gt; rather than &lt;code&gt;==&lt;/code&gt;. &lt;code&gt;eq&lt;/code&gt; will work fine on inode numbers that are represented numerically, as well as those represented as strings.</source>
          <target state="translated">一部のプラットフォームでは、iノード番号はperlよりも大きいタイプであり、整数値として処理する方法を知っています。必要に応じて、値全体を保持するために、iノード番号が10進文字列として返されます。数値のコンテキストで使用される場合、これは浮動小数点の数値に変換され、丸められます。これは、回避するのが最善の運命です。したがって、 &lt;code&gt;==&lt;/code&gt; ではなく &lt;code&gt;eq&lt;/code&gt; を使用してiノード数を比較することをお勧めします。 &lt;code&gt;eq&lt;/code&gt; は、文字列として表されるものだけでなく、数値で表されるiノード番号でも正常に機能します。</target>
        </trans-unit>
        <trans-unit id="c255f8c4da0102268758efe747d09a122b8f3a63" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows where the &lt;a href=&quot;http://man.he.net/man2/fork&quot;&gt;fork(2)&lt;/a&gt; system call is not available, Perl can be built to emulate &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; at the interpreter level. This emulation has limitations related to kill that have to be considered, for code running on Windows and in code intended to be portable.</source>
          <target state="translated">&lt;a href=&quot;http://man.he.net/man2/fork&quot;&gt;fork（2）&lt;/a&gt;システムコールが利用できないWindowsなどの一部のプラットフォームでは、Perlをビルドして、インタープリターレベルで&lt;a href=&quot;#fork&quot;&gt; &lt;code&gt;fork&lt;/code&gt; &lt;/a&gt;をエミュレートできます。このエミュレーションには、Windowsで実行されているコードや移植を目的としたコードの場合、考慮しなければならないkillに関連する制限があります。</target>
        </trans-unit>
        <trans-unit id="a9e0966de849860f2089841e81ee24c757771be3" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows where the fork() system call is not available, Perl can be built to emulate fork() at the interpreter level. This emulation has limitations related to kill that have to be considered, for code running on Windows and in code intended to be portable.</source>
          <target state="translated">Windows のように fork()システムコールが利用できないプラットフォームでは、Perl はインタプリタレベルで fork()をエミュレートするように構築することができます。このエミュレーションには kill に関連した制限があり、Windows 上で実行されているコードや移植性を意図したコードでは考慮しなければなりません。</target>
        </trans-unit>
        <trans-unit id="4dca8272040520711e1d36a027c5a86ea7b32ae2" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows where the fork() system call is not available, Perl can be built to emulate fork() at the interpreter level. While the emulation is designed to be as compatible as possible with the real fork() at the level of the Perl program, there are certain important differences that stem from the fact that all the pseudo child &quot;processes&quot; created this way live in the same real process as far as the operating system is concerned.</source>
          <target state="translated">Windows のように fork()システムコールが利用できないプラットフォームでは、Perl はインタプリタレベルで fork()をエミュレートするように構築することができます。エミュレーションは Perl プログラムのレベルで実際の fork()と可能な限り互換性があるように設計されていますが、このようにして作成されたすべての疑似的な子「プロセス」が、オペレーティング・システムに関する限り、同じ実際のプロセス内に存在するという事実に起因する、ある種の重要な違いがあります。</target>
        </trans-unit>
        <trans-unit id="acf7877caa8abc5986e73b196ee16707d5ded84d" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows, where the &lt;a href=&quot;http://man.he.net/man2/fork&quot;&gt;fork(2)&lt;/a&gt; system call is not available, Perl can be built to emulate &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; in the Perl interpreter. The emulation is designed, at the level of the Perl program, to be as compatible as possible with the &quot;Unix&quot; &lt;a href=&quot;http://man.he.net/man2/fork&quot;&gt;fork(2)&lt;/a&gt;. However it has limitations that have to be considered in code intended to be portable. See &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;a href=&quot;http://man.he.net/man2/fork&quot;&gt;fork（2）&lt;/a&gt;システムコールが利用できないWindowsなどの一部のプラットフォームでは、Perlインタープリターで&lt;a href=&quot;#fork&quot;&gt; &lt;code&gt;fork&lt;/code&gt; &lt;/a&gt;をエミュレートするようにPerlを構築できます。エミュレーションは、Perlプログラムのレベルで、「Unix」&lt;a href=&quot;http://man.he.net/man2/fork&quot;&gt;fork（2）&lt;/a&gt;と可能な限り互換性があるように設計されています。ただし、移植を目的としたコードで考慮する必要のある制限があります。詳細については、&lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c6a78bf511c92cd39ee02c1151b5e571d5127a45" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows, where the fork() system call is not available, Perl can be built to emulate fork() in the Perl interpreter. The emulation is designed, at the level of the Perl program, to be as compatible as possible with the &quot;Unix&quot; fork(). However it has limitations that have to be considered in code intended to be portable. See &lt;a href=&quot;../perlfork&quot;&gt;perlfork&lt;/a&gt; for more details.</source>
          <target state="translated">fork（）システムコールが利用できないWindowsなどの一部のプラットフォームでは、Perlをビルドして、Perlインタープリターでfork（）をエミュレートできます。エミュレーションは、Perlプログラムのレベルで、「Unix」のfork（）と可能な限り互換性があるように設計されています。ただし、移植可能であることを意図したコードで考慮しなければならない制限があります。詳細については&lt;a href=&quot;../perlfork&quot;&gt;perlfork&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="27073e810409a02dd0f24c371c3bfbfa303200d5" translate="yes" xml:space="preserve">
          <source>On some platforms such as Windows, where the fork() system call is not available, Perl can be built to emulate fork() in the Perl interpreter. The emulation is designed, at the level of the Perl program, to be as compatible as possible with the &quot;Unix&quot; fork(). However it has limitations that have to be considered in code intended to be portable. See &lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt; for more details.</source>
          <target state="translated">fork（）システムコールが利用できないWindowsなどの一部のプラットフォームでは、Perlをビルドして、Perlインタープリターでfork（）をエミュレートできます。エミュレーションは、Perlプログラムのレベルで、「Unix」のfork（）と可能な限り互換性があるように設計されています。ただし、移植可能であることを意図したコードで考慮しなければならない制限があります。詳細については&lt;a href=&quot;perlfork&quot;&gt;perlfork&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8ed99749e4754bfa5b0b973c5aff98a5ab4786e4" translate="yes" xml:space="preserve">
          <source>On some platforms the thread-safe library interfaces may fail if the result buffer is too small (for example the user group databases may be rather large, and the reentrant interfaces may have to carry around a full snapshot of those databases). Perl will start with a small buffer, but keep retrying and growing the result buffer until the result fits. If this limitless growing sounds bad for security or memory consumption reasons you can recompile Perl with &lt;code&gt;PERL_REENTRANT_MAXSIZE&lt;/code&gt; defined to the maximum number of bytes you will allow.</source>
          <target state="translated">一部のプラットフォームでは、結果バッファーが小さすぎると、スレッドセーフライブラリインターフェイスが失敗する場合があります（たとえば、ユーザーグループデータベースがかなり大きく、リエントラントインターフェイスがそれらのデータベースの完全なスナップショットを持ち歩かなければならない場合があります）。Perlは小さなバッファーから開始しますが、結果が収まるまで、結果バッファーを再試行して拡大し続けます。この無制限に増大するサウンドがセキュリティまたはメモリ消費の理由で悪いと &lt;code&gt;PERL_REENTRANT_MAXSIZE&lt;/code&gt; れる場合は、許可する最大バイト数に定義されたPERL_REENTRANT_MAXSIZEを使用して Perlを再コンパイルできます。</target>
        </trans-unit>
        <trans-unit id="24484214c7713626df068fed1666abc55fb655de" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpv&quot;&gt;&quot;savesharedpv&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一部のプラットフォーム、たとえばWindowsでは、スレッドが所有するすべての割り当て済みメモリは、そのスレッドが終了すると割り当てが解除されます。したがって、それが起こらないようにする必要がある場合は、 &lt;code&gt;&lt;a href=&quot;#savesharedpv&quot;&gt;&quot;savesharedpv&quot;&lt;/a&gt;&lt;/code&gt; などの共有メモリ関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="79a433ae6e8abc1654ff92b55b4f90deb9b64777" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpv&quot;&gt;savesharedpv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一部のプラットフォーム（Windowsなど）では、スレッドが所有するすべての割り当て済みメモリは、そのスレッドが終了すると割り当て解除されます。したがって、それが起こらないようにする必要がある場合は、 &lt;code&gt;&lt;a href=&quot;#savesharedpv&quot;&gt;savesharedpv&lt;/a&gt;&lt;/code&gt; などの共有メモリ関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="0080de19b8b9cfd716de6770d48e6fe48699a889" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpvn&quot;&gt;&quot;savesharedpvn&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一部のプラットフォーム、たとえばWindowsでは、スレッドが所有するすべての割り当て済みメモリは、そのスレッドが終了すると割り当てが解除されます。したがって、それを起こさないようにする必要がある場合は、 &lt;code&gt;&lt;a href=&quot;#savesharedpvn&quot;&gt;&quot;savesharedpvn&quot;&lt;/a&gt;&lt;/code&gt; などの共有メモリ関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="5a5fee577d9d0e5cea7ff481ecfa7871d14cc642" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedpvn&quot;&gt;savesharedpvn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一部のプラットフォーム（Windowsなど）では、スレッドが所有するすべての割り当て済みメモリは、そのスレッドが終了すると割り当て解除されます。したがって、それが起こらないようにする必要がある場合は、 &lt;code&gt;&lt;a href=&quot;#savesharedpvn&quot;&gt;savesharedpvn&lt;/a&gt;&lt;/code&gt; などの共有メモリ関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="d4da91ee61a2307a1a8d5d2d26b5d850a91c43b4" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedsvpv&quot;&gt;&quot;savesharedsvpv&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一部のプラットフォーム、たとえばWindowsでは、スレッドが所有するすべての割り当て済みメモリは、そのスレッドが終了すると割り当てが解除されます。したがって、それが起こらないようにする必要がある場合は、 &lt;code&gt;&lt;a href=&quot;#savesharedsvpv&quot;&gt;&quot;savesharedsvpv&quot;&lt;/a&gt;&lt;/code&gt; などの共有メモリ関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="96135c965e974cf2dcbb35a5a0a72331dbb017cf" translate="yes" xml:space="preserve">
          <source>On some platforms, Windows for example, all allocated memory owned by a thread is deallocated when that thread ends. So if you need that not to happen, you need to use the shared memory functions, such as &lt;code&gt;&lt;a href=&quot;#savesharedsvpv&quot;&gt;savesharedsvpv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一部のプラットフォーム（Windowsなど）では、スレッドが所有するすべての割り当て済みメモリは、そのスレッドが終了すると割り当て解除されます。そのため、これを行わないようにする必要がある場合は、 &lt;code&gt;&lt;a href=&quot;#savesharedsvpv&quot;&gt;savesharedsvpv&lt;/a&gt;&lt;/code&gt; などの共有メモリ関数を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="a47d30d42c677c2e62622d2c25ff6400601837c5" translate="yes" xml:space="preserve">
          <source>On some platforms, for example Windows NT, it is not possible to unlink an open file (the file must be closed first). On those platforms, the actual unlinking is deferred until the program ends and good status is returned. A check is still performed to make sure that the filehandle and filename are pointing to the same thing (but not at the time the end block is executed since the deferred removal may not have access to the filehandle).</source>
          <target state="translated">Windows NT のようないくつかのプラットフォームでは、開いているファイルのリンクを解除することができません (ファイルは最初に閉じなければなりません)。そのようなプラットフォームでは、実際のリンク解除はプログラムが終了して良好な状態が返されるまで延期されます。ファイルハンドルとファイル名が同じものを指していることを確認するためのチェックはまだ行われています(ただし、終了ブロックが実行された時点では、延期された削除はファイルハンドルにアクセスできない可能性があるため、実行されていません)。</target>
        </trans-unit>
        <trans-unit id="9e21af4bec3442feba775d62193829f8b7a0c4e5" translate="yes" xml:space="preserve">
          <source>On some platforms, it might not be possible to destroy</source>
          <target state="translated">一部のプラットフォームでは</target>
        </trans-unit>
        <trans-unit id="5fad4eee060ffd46b78c54eef932b8d7ced75bff" translate="yes" xml:space="preserve">
          <source>On some platforms, this also makes Perl append suffixes to the filename while searching for it. For example, on Win32 platforms, the &quot;.bat&quot; and &quot;.cmd&quot; suffixes are appended if a lookup for the original name fails, and if the name does not already end in one of those suffixes. If your Perl was compiled with &lt;code&gt;DEBUGGING&lt;/code&gt; turned on, using the &lt;a href=&quot;#-Dletters&quot;&gt;-Dp&lt;/a&gt; switch to Perl shows how the search progresses.</source>
          <target state="translated">一部のプラットフォームでは、これにより、Perlはファイル名の検索中にファイル名にサフィックスを追加します。たとえば、Win32プラットフォームでは、元の名前の検索に失敗した場合、および名前がこれらのサフィックスのいずれかで終わっていない場合、「。bat」および「.cmd」サフィックスが追加されます。あなたのPerlをしてコンパイルされた場合は &lt;code&gt;DEBUGGING&lt;/code&gt; 使用して、オン&lt;a href=&quot;#-Dletters&quot;&gt;-Dp&lt;/a&gt; Perlのショーどのように検索進展への切り替えを。</target>
        </trans-unit>
        <trans-unit id="b340b3bd6640d116c671c5bca7f5a658b943c207" translate="yes" xml:space="preserve">
          <source>On some platforms, this also makes Perl append suffixes to the filename while searching for it. For example, on Win32 platforms, the &quot;.bat&quot; and &quot;.cmd&quot; suffixes are appended if a lookup for the original name fails, and if the name does not already end in one of those suffixes. If your Perl was compiled with &lt;code&gt;DEBUGGING&lt;/code&gt; turned on, using the &lt;b&gt;-Dp&lt;/b&gt; switch to Perl shows how the search progresses.</source>
          <target state="translated">一部のプラットフォームでは、これにより、Perlは検索時にファイル名に接尾辞を追加します。たとえば、Win32プラットフォームでは、元の名前の検索が失敗した場合、および名前の末尾がこれらのサフィックスのいずれかで終わっていない場合、「。bat」および「.cmd」のサフィックスが追加されます。お使いのPerlが &lt;code&gt;DEBUGGING&lt;/code&gt; をオンにしてコンパイルされている場合、&lt;b&gt;-Dp&lt;/b&gt;スイッチをPerlに使用すると、検索の進行状況が表示されます。</target>
        </trans-unit>
        <trans-unit id="680d4319c3ebb1bf0096b308bc1e22323b5e0529" translate="yes" xml:space="preserve">
          <source>On some systems (in general, DOS- and Windows-based systems) &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; is necessary when you're not working with a text file. For the sake of portability it is a good idea always to use it when appropriate, and never to use it when it isn't appropriate. Also, people can set their I/O to be by default UTF8-encoded Unicode, not bytes.</source>
          <target state="translated">一部のシステム（通常、DOSベースおよびWindowsベースのシステム）では、テキストファイルを操作していないときに&lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt;が必要です。移植性のために、適切な場合は常に使用し、適切でない場合は絶対に使用しないことをお勧めします。また、ユーザーはI / OをデフォルトでバイトではなくUTF8でエンコードされたUnicodeに設定できます。</target>
        </trans-unit>
        <trans-unit id="e74540fb7a91002e20c8eda026f9bf8b28624a25" translate="yes" xml:space="preserve">
          <source>On some systems (in general, DOS- and Windows-based systems) binmode() is necessary when you're not working with a text file. For the sake of portability it is a good idea always to use it when appropriate, and never to use it when it isn't appropriate. Also, people can set their I/O to be by default UTF8-encoded Unicode, not bytes.</source>
          <target state="translated">いくつかのシステム(一般的にはDOSやWindowsベースのシステム)では、テキストファイルを扱っていないときにbinmode()が必要になります。移植性のためには、常に適切なときに使用し、適切でないときには決して使用しないことをお勧めします。また、デフォルトではバイトではなくUTF8でエンコードされたUnicodeにI/Oを設定することができます。</target>
        </trans-unit>
        <trans-unit id="dfca44fbb2c1ebee7c90ad249ff37ac61a808901" translate="yes" xml:space="preserve">
          <source>On some systems, for an IO::Socket object created with &lt;code&gt;new_from_fd&lt;/code&gt;, or created with &lt;a href=&quot;IO::Socket#accept&quot;&gt;&quot;accept&quot; in IO::Socket&lt;/a&gt; from such an object, the &lt;a href=&quot;IO::Socket#protocol&quot;&gt;&quot;protocol&quot; in IO::Socket&lt;/a&gt;, &lt;a href=&quot;IO::Socket#sockdomain&quot;&gt;&quot;sockdomain&quot; in IO::Socket&lt;/a&gt; and &lt;a href=&quot;IO::Socket#socktype&quot;&gt;&quot;socktype&quot; in IO::Socket&lt;/a&gt; methods may return &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">で作成されたIO :: Socketオブジェクトのためのいくつかのシステムでは、 &lt;code&gt;new_from_fd&lt;/code&gt; で、または作成&lt;a href=&quot;IO::Socket#accept&quot;&gt;IO ::ソケットに「受け入れる」&lt;/a&gt;ような、物体側から&lt;a href=&quot;IO::Socket#protocol&quot;&gt;IO ::ソケットに「プロトコル」&lt;/a&gt;、&lt;a href=&quot;IO::Socket#sockdomain&quot;&gt;IO ::ソケットに「sockdomain」&lt;/a&gt;と&lt;a href=&quot;IO::Socket#socktype&quot;&gt;IO :: Socket&lt;/a&gt;メソッドの「socktype」は &lt;code&gt;undef&lt;/code&gt; を返す場合があります。</target>
        </trans-unit>
        <trans-unit id="bae1ed91e60744c25391f2c5a28e8865cb837e1c" translate="yes" xml:space="preserve">
          <source>On some systems, for an IO::Socket object created with new_from_fd(), or created with accept() from such an object, the protocol(), sockdomain() and socktype() methods may return undef.</source>
          <target state="translated">いくつかのシステムでは、new_from_fd()で作成された IO::Socket オブジェクト、またはそのようなオブジェクトから accept()で作成された IO::Socket オブジェクトに対して、protocol()、sockdomain()、および socktype()メソッドは undef を返すことがあります。</target>
        </trans-unit>
        <trans-unit id="5cb77e1072ab2963baa8f6d218988c1f72414bff" translate="yes" xml:space="preserve">
          <source>On some systems, the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module's &lt;code&gt;strftime()&lt;/code&gt; function has been extended in a non-standard way to use a &lt;code&gt;%C&lt;/code&gt; format, which they sometimes claim is the &quot;century&quot;. It isn't, because on most such systems, this is only the first two digits of the four-digit year, and thus cannot be used to determine reliably the current century or millennium.</source>
          <target state="translated">一部のシステムでは、&lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt;モジュールの &lt;code&gt;strftime()&lt;/code&gt; 関数が非標準的な方法で拡張され、 &lt;code&gt;%C&lt;/code&gt; 形式を使用するようになりました。そうではありません。ほとんどのそのようなシステムでは、これは4桁の年の最初の2桁に過ぎず、したがって現在の世紀または千年紀を確実に決定するために使用することはできません。</target>
        </trans-unit>
        <trans-unit id="9a2307b9852232321e1093b21cd83d1ba46b51a6" translate="yes" xml:space="preserve">
          <source>On some systems, there can be cooperative and preemptive threads running simultaneously. (Threads running with realtime priorities often behave cooperatively, for example, while threads running at normal priorities behave preemptively.)</source>
          <target state="translated">システムによっては、協調的なスレッドと先制的なスレッドが同時に実行されることがあります。(例えば、リアルタイムの優先度で実行されているスレッドは協調的に動作し、通常の優先度で実行されているスレッドは先制的に動作します)。</target>
        </trans-unit>
        <trans-unit id="14dcaed53f17e703b8cfce8077083c7079226d84" translate="yes" xml:space="preserve">
          <source>On some systems, you may have to change single-quotes to double ones, which you must</source>
          <target state="translated">システムによっては、シングルクォートをダブルクォートに変更しなければならない場合があります。</target>
        </trans-unit>
        <trans-unit id="a73b71b53a0ef6fd5b9c990fee1a5a53d7f99a60" translate="yes" xml:space="preserve">
          <source>On success in a list context, an array of 3 elements is returned. The elements are:</source>
          <target state="translated">リストコンテキストで成功すると、3 つの要素からなる配列が返されます。要素は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="104cbe85a4799563175bc8875552e7ec3d9444ff" translate="yes" xml:space="preserve">
          <source>On success in a list context, an array of 6 elements is returned. The elements are:</source>
          <target state="translated">リストコンテキストで成功すると、6 つの要素からなる配列が返されます。要素は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="f87025d22f7460aebebdbcf7b85259c2cc5a7d3a" translate="yes" xml:space="preserve">
          <source>On success, $decoder is an object that is documented in &lt;a href=&quot;Encode::Encoding&quot;&gt;Encode::Encoding&lt;/a&gt;. So you can now do this;</source>
          <target state="translated">成功すると、$ decoderは&lt;a href=&quot;Encode::Encoding&quot;&gt;Encode :: Encodingに&lt;/a&gt;記載されているオブジェクトになります。これで、これを実行できます。</target>
        </trans-unit>
        <trans-unit id="bb19677ff47ab7a0061dc31fa21208b0fdd0ce0e" translate="yes" xml:space="preserve">
          <source>On success, $decoder is an object that is documented in &lt;a href=&quot;encoding&quot;&gt;Encode::Encoding&lt;/a&gt;. So you can now do this;</source>
          <target state="translated">成功した場合、$ decoderは&lt;a href=&quot;encoding&quot;&gt;Encode :: Encodingに&lt;/a&gt;記載されているオブジェクトです。これで、これを実行できます。</target>
        </trans-unit>
        <trans-unit id="9ed1d2d6abe6133cffe9d52759b8403cf251f405" translate="yes" xml:space="preserve">
          <source>On success, the autodying form of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; returns the</source>
          <target state="translated">成功した場合、のautodyingフォーム &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; 返します</target>
        </trans-unit>
        <trans-unit id="1e391581d76d0c24968f00549dd5c8fda5e3d997" translate="yes" xml:space="preserve">
          <source>On success, the autodying form of &lt;code&gt;system&lt;/code&gt; returns the</source>
          <target state="translated">成功すると、自動染色形式の &lt;code&gt;system&lt;/code&gt; は</target>
        </trans-unit>
        <trans-unit id="555bab907001ef6e8e0bb6e66b34e7245218e3f9" translate="yes" xml:space="preserve">
          <source>On systems that do not support the HIGH or MEDIUM safety levels (for example Win NT or OS/2) any attempt to change the level will be ignored. The decision to ignore rather than raise an exception allows portable programs to be written with high security in mind for the systems that can support this without those programs failing on systems where the extra tests are irrelevant.</source>
          <target state="translated">HIGH や MEDIUM の安全レベルをサポートしていないシステム (Win NT や OS/2 など)では、安全レベルを変更しようとする試みは無視されます。例外を発生させるのではなく、無視するという決定により、追加テストが無関係なシステムでプログラムが失敗することなく、これをサポートできるシステムのために、高いセキュリティを念頭に置いてポータブルプログラムを書くことができます。</target>
        </trans-unit>
        <trans-unit id="0c0c64b8ddf70f7334be3908bef0a4e5be9026f3" translate="yes" xml:space="preserve">
          <source>On systems that don't have locales, this pragma will cause your operations to behave as if in the &quot;C&quot; locale; attempts to change the locale will fail.</source>
          <target state="translated">ロケールを持たないシステムでは、このプラグマを使用すると、あたかも &quot;C&quot; ロケールであるかのように操作が行われます。</target>
        </trans-unit>
        <trans-unit id="8a74a95b0c966e10aac8d77a4f0a3bf544781a21" translate="yes" xml:space="preserve">
          <source>On systems that have a grammar that indicates filenames, this ignores the $base filename. Otherwise all path components are assumed to be directories.</source>
          <target state="translated">ファイル名を示す文法を持つシステムでは、これは $base ファイル名を無視します。それ以外の場合は、すべてのパスコンポーネントがディレクトリであると仮定されます。</target>
        </trans-unit>
        <trans-unit id="1b51da93b22332f93d96c5b573c9ad75ab82f7bf" translate="yes" xml:space="preserve">
          <source>On systems that have a grammar that indicates filenames, this ignores the &lt;code&gt;$base&lt;/code&gt; filename as well. Otherwise all path components are assumed to be directories.</source>
          <target state="translated">ファイル名を示す文法があるシステムでは、これは &lt;code&gt;$base&lt;/code&gt; ファイル名も無視します。それ以外の場合、すべてのパスコンポーネントはディレクトリと見なされます。</target>
        </trans-unit>
        <trans-unit id="901b07c2e1b3c74e80e092e6a7bf36ca0bfb33ee" translate="yes" xml:space="preserve">
          <source>On systems that support &lt;a href=&quot;http://man.he.net/man2/fchdir&quot;&gt;fchdir(2)&lt;/a&gt;, you may pass a filehandle or directory handle as the argument. On systems that don't support &lt;a href=&quot;http://man.he.net/man2/fchdir&quot;&gt;fchdir(2)&lt;/a&gt;, passing handles raises an exception.</source>
          <target state="translated">&lt;a href=&quot;http://man.he.net/man2/fchdir&quot;&gt;fchdir（2）&lt;/a&gt;をサポートするシステムでは、引数としてファイルハンドルまたはディレクトリハンドルを渡すことができます。&lt;a href=&quot;http://man.he.net/man2/fchdir&quot;&gt;fchdir（2）を&lt;/a&gt;サポートしていないシステムでは、ハンドルを渡すと例外が発生します。</target>
        </trans-unit>
        <trans-unit id="04beca51e696b3f570d383d77ccd733902d428c1" translate="yes" xml:space="preserve">
          <source>On systems that support &lt;a href=&quot;http://man.he.net/man2/fchmod&quot;&gt;fchmod(2)&lt;/a&gt;, you may pass filehandles among the files. On systems that don't support &lt;a href=&quot;http://man.he.net/man2/fchmod&quot;&gt;fchmod(2)&lt;/a&gt;, passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">&lt;a href=&quot;http://man.he.net/man2/fchmod&quot;&gt;fchmod（2）&lt;/a&gt;をサポートするシステムでは、ファイル間でファイルハンドルを渡すことができます。&lt;a href=&quot;http://man.he.net/man2/fchmod&quot;&gt;fchmod（2）を&lt;/a&gt;サポートしていないシステムでは、ファイルハンドルを渡すと例外が発生します。ファイルハンドルは、認識されるためにグロブまたはグロブ参照として渡される必要があります。ベアワードはファイル名と見なされます。</target>
        </trans-unit>
        <trans-unit id="00ad9738faaa35969ac19d2d964d2e11949f987b" translate="yes" xml:space="preserve">
          <source>On systems that support &lt;a href=&quot;http://man.he.net/man2/fchown&quot;&gt;fchown(2)&lt;/a&gt;, you may pass filehandles among the files. On systems that don't support &lt;a href=&quot;http://man.he.net/man2/fchown&quot;&gt;fchown(2)&lt;/a&gt;, passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">&lt;a href=&quot;http://man.he.net/man2/fchown&quot;&gt;fchown（2）&lt;/a&gt;をサポートするシステムでは、ファイル間でファイルハンドルを渡すことができます。&lt;a href=&quot;http://man.he.net/man2/fchown&quot;&gt;fchown（2）を&lt;/a&gt;サポートしていないシステムでは、ファイルハンドルを渡すと例外が発生します。ファイルハンドルは、認識されるためにグロブまたはグロブ参照として渡される必要があります。ベアワードはファイル名と見なされます。</target>
        </trans-unit>
        <trans-unit id="af7ce7f23ab496e21c30f598c258278a01062849" translate="yes" xml:space="preserve">
          <source>On systems that support &lt;a href=&quot;http://man.he.net/man2/futimes&quot;&gt;futimes(2)&lt;/a&gt;, you may pass filehandles among the files. On systems that don't support &lt;a href=&quot;http://man.he.net/man2/futimes&quot;&gt;futimes(2)&lt;/a&gt;, passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">&lt;a href=&quot;http://man.he.net/man2/futimes&quot;&gt;futimes（2）&lt;/a&gt;をサポートするシステムでは、ファイル間でファイルハンドルを渡すことができます。&lt;a href=&quot;http://man.he.net/man2/futimes&quot;&gt;futimes（2）を&lt;/a&gt;サポートしていないシステムでは、ファイルハンドルを渡すと例外が発生します。ファイルハンドルは、認識されるためにグロブまたはグロブ参照として渡される必要があります。ベアワードはファイル名と見なされます。</target>
        </trans-unit>
        <trans-unit id="5d1d6ffed6769b46e37f0d82df8acb444f49f35b" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, that flag is set on all newly opened file descriptors whose &lt;a href=&quot;#fileno-FILEHANDLE&quot;&gt;&lt;code&gt;fileno&lt;/code&gt;&lt;/a&gt;s are</source>
          <target state="translated">ファイルでclose-on-execフラグをサポートするシステムでは、そのフラグは、&lt;a href=&quot;#fileno-FILEHANDLE&quot;&gt; &lt;code&gt;fileno&lt;/code&gt; &lt;/a&gt;がである新しく開かれたすべてのファイル記述子に設定されます。</target>
        </trans-unit>
        <trans-unit id="5314c4a5a0cc48c834a98edadeb967581bfc1cbf" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, that flag is set on all newly opened file descriptors whose &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt;s are</source>
          <target state="translated">ファイルの実行時クローズフラグをサポートするシステムでは、そのフラグは、 &lt;code&gt;&lt;a href=&quot;fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; が</target>
        </trans-unit>
        <trans-unit id="be056ae4f4d92fcc824ea5af426faa5948d961c7" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, that flag is set on all newly opened file descriptors whose &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt;s are</source>
          <target state="translated">ファイルの実行時クローズフラグをサポートするシステムでは、そのフラグは、 &lt;code&gt;&lt;a href=&quot;functions/fileno&quot;&gt;fileno&lt;/a&gt;&lt;/code&gt; が</target>
        </trans-unit>
        <trans-unit id="11350e333ae0f2472a99aa4945fb651bbd8808b9" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor as determined by the value of &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&lt;code&gt;$^F&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&quot;$^F&quot; in perlvar&lt;/a&gt;.</source>
          <target state="translated">ファイルでclose-on-execフラグをサポートするシステムでは、&lt;a href=&quot;perlvar#%24%5EF&quot;&gt; &lt;code&gt;$^F&lt;/code&gt; &lt;/a&gt;値によって決定されるように、新しく開かれたファイル記述子にフラグが設定されます。&lt;a href=&quot;perlvar#%24%5EF&quot;&gt;perlvarの「$ ^ F」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3fcf7eb3896f4c5961c6c4a30af97fd660da9d5d" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor as determined by the value of &lt;code&gt;$^F&lt;/code&gt; . See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">ファイルのclose-on-execフラグをサポートするシステムでは、フラグは &lt;code&gt;$^F&lt;/code&gt; 値によって決定される、新しく開かれたファイル記述子に設定されます。&lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;perlvarの$ ^ Fを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c665037f5c6992c82bd182869050b43d00b7e424" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor as determined by the value of &lt;code&gt;$^F&lt;/code&gt; . See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">ファイルのclose-on-execフラグをサポートするシステムでは、フラグは &lt;code&gt;$^F&lt;/code&gt; 値によって決定される、新しく開かれたファイル記述子に設定されます。&lt;a href=&quot;perlvar#%24%5eF&quot;&gt;perlvarの$ ^ Fを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a490a64d93357b4e803f1bde203444d3253ea771" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor, as determined by the value of $^F. See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">ファイルの実行時クローズフラグをサポートするシステムでは、フラグは$ ^ Fの値によって決定されるように、新しく開かれたファイル記述子に設定されます。&lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;perlvarの$ ^ Fを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="a8889b4502c97331fb6c0d71d79b94f89a2ce179" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor, as determined by the value of $^F. See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">ファイルの実行時クローズフラグをサポートするシステムでは、フラグは$ ^ Fの値によって決定されるように、新しく開かれたファイル記述子に設定されます。&lt;a href=&quot;perlvar#%24%5eF&quot;&gt;perlvarの$ ^ Fを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4a9abf94cd4611a410ac6fca9a398911a42fa5c0" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptor, as determined by the value of &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&lt;code&gt;$^F&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&quot;$^F&quot; in perlvar&lt;/a&gt;.</source>
          <target state="translated">ファイルでclose-on-execフラグをサポートするシステムでは、&lt;a href=&quot;perlvar#%24%5EF&quot;&gt; &lt;code&gt;$^F&lt;/code&gt; &lt;/a&gt;値によって決定されるように、新しく開かれたファイル記述子にフラグが設定されます。&lt;a href=&quot;perlvar#%24%5EF&quot;&gt;perlvarの「$ ^ F」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="901c01459d3ad6fdd533264983a881490e329c6b" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptors, as determined by the value of $^F. See &lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">ファイルの実行時クローズフラグをサポートするシステムでは、フラグは$ ^ Fの値によって決定されるように、新しく開かれたファイル記述子に設定されます。&lt;a href=&quot;../perlvar#%24%5eF&quot;&gt;perlvarの$ ^ Fを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b4b0eeffda71eae98ca0b23d4d9a435052a31c58" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptors, as determined by the value of $^F. See &lt;a href=&quot;perlvar#%24%5eF&quot;&gt;$^F in perlvar&lt;/a&gt;.</source>
          <target state="translated">ファイルの実行時クローズフラグをサポートするシステムでは、フラグは$ ^ Fの値によって決定されるように、新しく開かれたファイル記述子に設定されます。&lt;a href=&quot;perlvar#%24%5eF&quot;&gt;perlvarの$ ^ Fを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="fc9058ec5b96236598bf0d8742f7fe61dd91e63f" translate="yes" xml:space="preserve">
          <source>On systems that support a close-on-exec flag on files, the flag will be set for the newly opened file descriptors, as determined by the value of &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&lt;code&gt;$^F&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlvar#%24%5EF&quot;&gt;&quot;$^F&quot; in perlvar&lt;/a&gt;.</source>
          <target state="translated">ファイルでclose-on-execフラグをサポートするシステムでは、&lt;a href=&quot;perlvar#%24%5EF&quot;&gt; &lt;code&gt;$^F&lt;/code&gt; &lt;/a&gt;値によって決定されるように、新しく開かれたファイル記述子にフラグが設定されます。&lt;a href=&quot;perlvar#%24%5EF&quot;&gt;perlvarの「$ ^ F」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="80c803cb6cc476af479d34a3bc1112251dd81782" translate="yes" xml:space="preserve">
          <source>On systems that support a real &lt;a href=&quot;http://man.he.net/man2/flock&quot;&gt;flock(2)&lt;/a&gt;, locks are inherited across &lt;a href=&quot;#fork&quot;&gt;&lt;code&gt;fork&lt;/code&gt;&lt;/a&gt; calls, whereas those that must resort to the more capricious &lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl(2)&lt;/a&gt; function lose their locks, making it seriously harder to write servers.</source>
          <target state="translated">実際の&lt;a href=&quot;http://man.he.net/man2/flock&quot;&gt;flock（2）&lt;/a&gt;をサポートするシステムでは、ロックは&lt;a href=&quot;#fork&quot;&gt; &lt;code&gt;fork&lt;/code&gt; &lt;/a&gt;呼び出し全体で継承されますが、より気まぐれな&lt;a href=&quot;http://man.he.net/man2/fcntl&quot;&gt;fcntl（2）&lt;/a&gt;関数に頼らなければならないシステムはロックを失い、サーバーの作成が非常に困難になります。</target>
        </trans-unit>
        <trans-unit id="c0bcb70dd655374823428e8ecf318b875be23f0d" translate="yes" xml:space="preserve">
          <source>On systems that support a real flock(2), locks are inherited across fork() calls, whereas those that must resort to the more capricious fcntl(2) function lose their locks, making it seriously harder to write servers.</source>
          <target state="translated">実際の flock(2)をサポートするシステムでは、ロックは fork()の呼び出し全体に渡って継承されますが、より気まぐれな fcntl(2)関数に頼らなければならないシステムではロックが失われてしまい、サーバを書くのが非常に困難になってしまいます。</target>
        </trans-unit>
        <trans-unit id="92426fd5bb12f295ba78cf2e855950f52eab1f1b" translate="yes" xml:space="preserve">
          <source>On systems that support fchdir(2), you may pass a filehandle or directory handle as the argument. On systems that don't support fchdir(2), passing handles raises an exception.</source>
          <target state="translated">fchdir(2)をサポートしているシステムでは、引数にファイルハンドルやディレクトリハンドルを渡すことができます。fchdir(2)をサポートしていないシステムでは、ハンドルを渡すと例外が発生します。</target>
        </trans-unit>
        <trans-unit id="92172c92aed2c4eacbbf108b43a01fa41c1e7227" translate="yes" xml:space="preserve">
          <source>On systems that support fchmod(2), you may pass filehandles among the files. On systems that don't support fchmod(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">fchmod(2)をサポートしているシステムでは、ファイル間で filehandles を渡すことができます。fchmod(2)をサポートしていないシステムでは、ファイルハンドルを渡すと例外が発生します。ファイルハンドルは、認識されるためには、グロブまたはグロブ参照として渡されなければなりません。</target>
        </trans-unit>
        <trans-unit id="dc52e8f7e1c0866f647ccf5e1cd248ecabff8b5f" translate="yes" xml:space="preserve">
          <source>On systems that support fchown(2), you may pass filehandles among the files. On systems that don't support fchown(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">fchown(2)をサポートしているシステムでは、ファイル間で filehandles を渡すことができます。fchown(2)をサポートしていないシステムでは、ファイルハンドルを渡すと例外が発生します。ファイルハンドルは、認識されるためにはグロブまたはグロブ参照として渡さなければなりません。</target>
        </trans-unit>
        <trans-unit id="9d32f7bede11ac1c00998cc26b587f02c25e363b" translate="yes" xml:space="preserve">
          <source>On systems that support futimes(2), you may pass filehandles among the files. On systems that don't support futimes(2), passing filehandles raises an exception. Filehandles must be passed as globs or glob references to be recognized; barewords are considered filenames.</source>
          <target state="translated">futimes(2)をサポートしているシステムでは、ファイル間で filehandles を渡すことができます。futimes(2)をサポートしていないシステムでは、ファイルハンドルを渡すと例外が発生します。ファイルハンドルは、認識されるためにはグロブまたはグロブ参照として渡さなければなりません。</target>
        </trans-unit>
        <trans-unit id="c71329e94ef821ac647632fa2fb53326dd2a9466" translate="yes" xml:space="preserve">
          <source>On systems that supported it, older versions of Perl used the SA_RESTART flag when installing %SIG handlers. This meant that restartable system calls would continue rather than returning when a signal arrived. In order to deliver deferred signals promptly, Perl 5.8.0 and later do</source>
          <target state="translated">これをサポートするシステムでは、古いバージョンの Perl では、%SIG ハンドラをインストールするときに SA_RESTART フラグが使用されていました。これは、シグナルが到着したときに戻るのではなく、再起動可能なシステム・コールが継続されることを意味します。遅延したシグナルを迅速に配信するために、Perl 5.8.0 以降では、以下を実行します。</target>
        </trans-unit>
        <trans-unit id="6ba77bd32e9b25ffdeddd2abe71a6e9ea02320ab" translate="yes" xml:space="preserve">
          <source>On systems traditionally bereft of a usable &lt;b&gt;man&lt;/b&gt; command, the debugger invokes &lt;b&gt;perldoc&lt;/b&gt;. Occasionally this determination is incorrect due to recalcitrant vendors or rather more felicitously, to enterprising users. If you fall into either category, just manually set the $DB::doccmd variable to whatever viewer to view the Perl documentation on your system. This may be set in an rc file, or through direct assignment. We're still waiting for a working example of something along the lines of:</source>
          <target state="translated">伝統的に使用可能な&lt;b&gt;man&lt;/b&gt;コマンドが不足しているシステムでは、デバッガーは&lt;b&gt;perldocを&lt;/b&gt;呼び出します。時として、この決定は、ベンダーの反抗的であるか、またはより積極的に、企業ユーザーにとっては正しくない。どちらかのカテゴリに該当する場合は、$ DB :: doccmd変数を任意のビューアに手動で設定して、システムのPerlドキュメントを表示します。これは、rcファイルで設定するか、直接割り当てて設定できます。私たちは、次のような例の実用的な例をまだ待っています。</target>
        </trans-unit>
        <trans-unit id="495743307752ec1e7f711d11bd0bef034af0b675" translate="yes" xml:space="preserve">
          <source>On systems which do support negative epoch values, this module should be able to cope with dates before the start of the epoch, down the minimum value of time_t for the system.</source>
          <target state="translated">負のエポック値をサポートしているシステムでは、このモジュールはシステムのためのtime_tの最小値以下のエポック開始前の日付を扱うことができるはずです。</target>
        </trans-unit>
        <trans-unit id="46c423b9491070d51507de37df7f4e753a419998" translate="yes" xml:space="preserve">
          <source>On systems with restrictions on file name length, the file corresponding to a subroutine may have a shorter name that the routine itself. This can lead to conflicting file names. The</source>
          <target state="translated">ファイル名の長さに制限があるシステムでは、サブルーチンに対応するファイルの名前がルーチン自体よりも短い場合があります。これにより、ファイル名が競合する可能性があります。このような場合には</target>
        </trans-unit>
        <trans-unit id="fec43c22ce98f30270ab97bbbb4fe9d6075857b3" translate="yes" xml:space="preserve">
          <source>On systems with the concept of a network share (currently only Windows) returns the sharename from a &lt;a href=&quot;file://&quot;&gt;file:////&lt;/a&gt; url. On other operating systems returns empty.</source>
          <target state="translated">ネットワーク共有（現在はWindowsのみ）の概念を持つシステムでの共有名を返します&lt;a href=&quot;file://&quot;&gt;////：ファイル&lt;/a&gt;のURL。他のオペレーティングシステムでは空を返します。</target>
        </trans-unit>
        <trans-unit id="8a4f2ea2521e9d2bed452fc1750b2f44d1e70008" translate="yes" xml:space="preserve">
          <source>On systems with the concept of a network share (currently only Windows) returns the sharename from a file://// url. On other operating systems returns empty.</source>
          <target state="translated">ネットワーク共有の概念を持つシステム(現在はWindowsのみ)では、ファイル:////urlからsharenameを返します。その他のオペレーティングシステムでは空の値を返します。</target>
        </trans-unit>
        <trans-unit id="928cc7ef7cb478fdbb60e26c8543bd66bba1f884" translate="yes" xml:space="preserve">
          <source>On systems with the concept of volume, if &lt;code&gt;$path&lt;/code&gt; and &lt;code&gt;$base&lt;/code&gt; appear to be on two different volumes, we will not attempt to resolve the two paths, and we will instead simply return &lt;code&gt;$path&lt;/code&gt; . Note that previous versions of this module ignored the volume of &lt;code&gt;$base&lt;/code&gt; , which resulted in garbage results part of the time.</source>
          <target state="translated">ボリュームの概念を持つシステムでは、 &lt;code&gt;$path&lt;/code&gt; と &lt;code&gt;$base&lt;/code&gt; が2つの異なるボリューム上にあるように見える場合、2つのパスを解決しようとせず、代わりに &lt;code&gt;$path&lt;/code&gt; 返します。このモジュールの以前のバージョンでは &lt;code&gt;$base&lt;/code&gt; のボリュームが無視されていたため、一部の時間に不要な結果が生じていました。</target>
        </trans-unit>
        <trans-unit id="7d73de0a58277977e444ac1cca08eacb14a895ab" translate="yes" xml:space="preserve">
          <source>On systems with the concept of volume, if &lt;code&gt;$path&lt;/code&gt; and &lt;code&gt;$base&lt;/code&gt; appear to be on two different volumes, we will not attempt to resolve the two paths, and we will instead simply return &lt;code&gt;$path&lt;/code&gt;. Note that previous versions of this module ignored the volume of &lt;code&gt;$base&lt;/code&gt;, which resulted in garbage results part of the time.</source>
          <target state="translated">ボリュームの概念を持つシステムでは、 &lt;code&gt;$path&lt;/code&gt; と &lt;code&gt;$base&lt;/code&gt; が2つの異なるボリューム上にあるように見える場合、2つのパスを解決しようとはせず、代わりに &lt;code&gt;$path&lt;/code&gt; 返すだけです。このモジュールの以前のバージョンは &lt;code&gt;$base&lt;/code&gt; のボリュームを無視していたため、一部の時間でガベージ結果が発生したことに注意してください。</target>
        </trans-unit>
        <trans-unit id="3890814a89a9eb1b787653006ab22422f5ccc270" translate="yes" xml:space="preserve">
          <source>On systems without locale support, or on typical single-threaded builds, or on platforms that do not support per-thread locale operations, this function does nothing. On such systems that do have locale support, only a locale global to the whole program is available.</source>
          <target state="translated">ロケールをサポートしていないシステムや、一般的なシングルスレッドビルド、 スレッドごとのロケール操作をサポートしていないプラットフォームでは、 この関数は何もしません。ロケールをサポートしているシステムでは、プログラム全体に対してグローバルなロケールのみが利用可能です。</target>
        </trans-unit>
        <trans-unit id="04b62c831c8eef6cc7d4b1d7cdb6bf880f9b84f3" translate="yes" xml:space="preserve">
          <source>On text fields the caret enables a kind of fill mode. Instead of an arbitrary expression, the value supplied must be a scalar variable that contains a text string. Perl puts the next portion of the text into the field, and then chops off the front of the string so that the next time the variable is referenced, more of the text can be printed. (Yes, this means that the variable itself is altered during execution of the write() call, and is not restored.) The next portion of text is determined by a crude line-breaking algorithm. You may use the carriage return character (&lt;code&gt;\r&lt;/code&gt; ) to force a line break. You can change which characters are legal to break on by changing the variable &lt;code&gt;$:&lt;/code&gt; (that's $FORMAT_LINE_BREAK_CHARACTERS if you're using the English module) to a list of the desired characters.</source>
          <target state="translated">テキストフィールドでは、キャレットは一種の塗りつぶしモードを有効にします。任意の式の代わりに、提供される値はテキスト文字列を含むスカラー変数でなければなりません。Perlはテキストの次の部分をフィールドに入れ、次に変数が参照されたときにさらに多くのテキストを印刷できるように、文字列の前を切り落とします。（はい、これは、変数自体がwrite（）呼び出しの実行中に変更され、復元されないことを意味します。）テキストの次の部分は、大まかな改行アルゴリズムによって決定されます。改行を強制するために、復帰文字（ &lt;code&gt;\r&lt;/code&gt; ）を使用できます。変数 &lt;code&gt;$:&lt;/code&gt; を変更することにより、どの文字が壊れるかを変更できます。 （英語モジュールを使用している場合は、$ FORMAT_LINE_BREAK_CHARACTERSです）から、目的の文字のリストに変換します。</target>
        </trans-unit>
        <trans-unit id="c85b198c2a1ea3057ddf98fa6e2eafccce107220" translate="yes" xml:space="preserve">
          <source>On text fields the caret enables a kind of fill mode. Instead of an arbitrary expression, the value supplied must be a scalar variable that contains a text string. Perl puts the next portion of the text into the field, and then chops off the front of the string so that the next time the variable is referenced, more of the text can be printed. (Yes, this means that the variable itself is altered during execution of the write() call, and is not restored.) The next portion of text is determined by a crude line-breaking algorithm. You may use the carriage return character (&lt;code&gt;\r&lt;/code&gt;) to force a line break. You can change which characters are legal to break on by changing the variable &lt;code&gt;$:&lt;/code&gt; (that's $FORMAT_LINE_BREAK_CHARACTERS if you're using the English module) to a list of the desired characters.</source>
          <target state="translated">テキストフィールドでは、キャレットは一種の塗りつぶしモードを有効にします。指定する値は、任意の式ではなく、テキスト文字列を含むスカラー変数である必要があります。 Perlはテキストの次の部分をフィールドに配置し、次に変数が参照されるときにさらに多くのテキストを印刷できるように、文字列の先頭を切り取ります。 （はい、これは、変数自体がwrite（）呼び出しの実行中に変更され、復元されないことを意味します。）テキストの次の部分は、大まかな改行アルゴリズムによって決定されます。キャリッジリターン文字（ &lt;code&gt;\r&lt;/code&gt; ）を使用して、改行を強制することができます。変数 &lt;code&gt;$:&lt;/code&gt; 英語モジュールを使用している場合は$ FORMAT_LINE_BREAK_CHARACTERS）を目的の文字のリストに変更することで、どの文字を中断できるかを変更できます。</target>
        </trans-unit>
        <trans-unit id="c0193cc78fe98d1b4b454c6f69412908ead97760" translate="yes" xml:space="preserve">
          <source>On the AS/400, if PERL5 is in your library list, you may need to wrap your Perl scripts in a CL procedure to invoke them like so:</source>
          <target state="translated">AS/400では、PERL5がライブラリリストにある場合、以下のようにCLプロシージャでPerlスクリプトをラップして呼び出す必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="16a3b552e4784bd03ff647bc0e4cf0bd441e7074" translate="yes" xml:space="preserve">
          <source>On the DSM management page start the Control Panel.</source>
          <target state="translated">DSM管理ページでコントロールパネルを起動します。</target>
        </trans-unit>
        <trans-unit id="124c561154829ad2caaa2d7dfa3f126afe450312" translate="yes" xml:space="preserve">
          <source>On the flip side, don't be tempted to prematurely declare a test incorrect just because you're having trouble finding the bug. Invalidating a test isn't something to be taken lightly, and don't use it as a cop out to avoid work.</source>
          <target state="translated">逆に、バグの発見に苦労しているからといって、早々にテストの無効化を宣言したくならないようにしましょう。テストを無効にすることは軽視すべきことではありません。</target>
        </trans-unit>
        <trans-unit id="ea65f5f2a1cec2b70340514d27743f128cc959b6" translate="yes" xml:space="preserve">
          <source>On the given program identified by &lt;code&gt;program_name&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;program_name&lt;/code&gt; で識別される特定のプログラムについて。</target>
        </trans-unit>
        <trans-unit id="12dc585208a0e91c8b1cc0d400c475b21cd97b26" translate="yes" xml:space="preserve">
          <source>On the given program identified by &lt;code&gt;program_name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;program_name&lt;/code&gt; で識別される特定のプログラム。</target>
        </trans-unit>
        <trans-unit id="5c9fcecabc9c2ff5c185e1af9b86fe28cd4ccda1" translate="yes" xml:space="preserve">
          <source>On the mainframe Perl currently works under the &quot;Unix system services for OS/390&quot; (formerly known as OpenEdition), VM/ESA OpenEdition, or the BS200 POSIX-BC system (BS2000 is supported in Perl 5.6 and greater). See &lt;a href=&quot;perlos390&quot;&gt;perlos390&lt;/a&gt; for details. Note that for OS/400 there is also a port of Perl 5.8.1/5.10.0 or later to the PASE which is ASCII-based (as opposed to ILE which is EBCDIC-based), see &lt;a href=&quot;perlos400&quot;&gt;perlos400&lt;/a&gt;.</source>
          <target state="translated">メインフレーム上では、Perlは現在「OS / 390のUNIXシステムサービス」（旧称OpenEdition）、VM / ESA OpenEdition、またはBS200 POSIX-BCシステム（BS2000はPerl 5.6以降でサポートされています）で動作します。詳細については、&lt;a href=&quot;perlos390&quot;&gt;perlos390&lt;/a&gt;を参照してください。OS / 400の場合、（EBCDICベースのILEではなく）ASCIIベースのPASEにPerl 5.8.1 / 5.10.0以降のポートもあることに注意してください&lt;a href=&quot;perlos400&quot;&gt;。perlos400を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="580309d3af9907826e397d1c3342546e17a8ad3c" translate="yes" xml:space="preserve">
          <source>On the opposite end of the scale, a declaration like</source>
          <target state="translated">スケールの反対側では、次のような宣言があります。</target>
        </trans-unit>
        <trans-unit id="30429117a84b2dd407e0605edcb4b807f19cd366" translate="yes" xml:space="preserve">
          <source>On the other hand, if you want the other meaning, you can do this:</source>
          <target state="translated">逆に、もう一つの意味を求めるならば、このようにすることができます。</target>
        </trans-unit>
        <trans-unit id="fbae3feec67f27fa104cf2845f242f528c54850f" translate="yes" xml:space="preserve">
          <source>On the other hand, if you were actually hoping to treat the array element as a list, you need to look into how references work, because Perl will not magically convert between scalars and lists for you. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">一方、配列要素をリストとして扱うことを実際に望んでいた場合、Perlはスカラーとリストの間で魔法のように変換しないため、参照がどのように機能するかを調べる必要があります。&lt;a href=&quot;perlref&quot;&gt;perlrefを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ce76eb877363ead375654de95e60f5e7b6c574b5" translate="yes" xml:space="preserve">
          <source>On the other hand, if you were actually hoping to treat the hash element as a list, you need to look into how references work, because Perl will not magically convert between scalars and lists for you. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">一方、ハッシュ要素をリストとして扱うことを実際に望んでいた場合、Perlはスカラーとリストの間で魔法のように変換しないため、参照がどのように機能するかを調べる必要があります。&lt;a href=&quot;perlref&quot;&gt;perlrefを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="528cd15a9b0aff8a5cdc97823c4262e5cf5bb2ab" translate="yes" xml:space="preserve">
          <source>On the other hand, mixing various national standard encodings automagically works unless $data is too short to allow for guessing.</source>
          <target state="translated">一方で、$data が短すぎて推測ができない場合を除いて、様々な国家標準のエンコーディングを混ぜることは自動的に機能します。</target>
        </trans-unit>
        <trans-unit id="095e1a5231bfc256caf5b97c9e59036a8cd94e78" translate="yes" xml:space="preserve">
          <source>On the other hand, sometimes you want to clobber whatever might already be there. To empty out a file before you start writing to it, you can open it in write-only mode:</source>
          <target state="translated">その一方で、すでにあるかもしれないものは何でもいいから、何でもいいから、何でもいいから、何でもいいから、何でもいいから、何でもいいから、何でもいいから、何でもいいから、何でもいいから、何でもいいから、何でもいいから、何でもいいから、何でもいいから、何でもいいから、何でもいいから、何でもいいから、何でもいいから、何でもいいから、書き出す前に、ファイルを空にするには、書き込み専用モードで開くことができます。書き込みを始める前にファイルを空にするには、書き込み専用モードでファイルを開くことができます。</target>
        </trans-unit>
        <trans-unit id="94024e45d5031c319fa3ba71f3df1c69292913dd" translate="yes" xml:space="preserve">
          <source>On the other hand:</source>
          <target state="translated">その一方で</target>
        </trans-unit>
        <trans-unit id="f18fa46000a23ad2307a5bee120c399fc4cc324f" translate="yes" xml:space="preserve">
          <source>On the right side of a list operator, the comma has very low precedence, such that it controls all comma-separated expressions found there. The only operators with lower precedence are the logical operators &lt;code&gt;&quot;and&quot;&lt;/code&gt; , &lt;code&gt;&quot;or&quot;&lt;/code&gt; , and &lt;code&gt;&quot;not&quot;&lt;/code&gt; , which may be used to evaluate calls to list operators without the need for parentheses:</source>
          <target state="translated">リスト演算子の右側では、コンマの優先度が非常に低いため、コンマで区切られたすべての式を制御します。優先順位が低い唯一の演算子は、論理演算子 &lt;code&gt;&quot;and&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;or&quot;&lt;/code&gt; 、および &lt;code&gt;&quot;not&quot;&lt;/code&gt; であり、括弧を使用せずにリスト演算子の呼び出しを評価するために使用できます。</target>
        </trans-unit>
        <trans-unit id="dd64949dc6542722891696f1747da1386b28ed4e" translate="yes" xml:space="preserve">
          <source>On the right side of a list operator, the comma has very low precedence, such that it controls all comma-separated expressions found there. The only operators with lower precedence are the logical operators &lt;code&gt;&quot;and&quot;&lt;/code&gt;, &lt;code&gt;&quot;or&quot;&lt;/code&gt;, and &lt;code&gt;&quot;not&quot;&lt;/code&gt;, which may be used to evaluate calls to list operators without the need for parentheses:</source>
          <target state="translated">リスト演算子の右側では、コンマの優先順位が非常に低いため、そこで見つかったすべてのコンマ区切りの式を制御します。優先順位の低い演算子は、論理演算子 &lt;code&gt;&quot;and&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;or&quot;&lt;/code&gt; 、および &lt;code&gt;&quot;not&quot;&lt;/code&gt; 。これらは、括弧を使用せずにリスト演算子の呼び出しを評価するために使用できます。</target>
        </trans-unit>
        <trans-unit id="05c9d06262a8b8894dbad99cc8b7ff5cbcc3e919" translate="yes" xml:space="preserve">
          <source>On these platforms, bear in mind that the EBCDIC character set may have an effect on what happens with some Perl functions (such as &lt;a href=&quot;perlfunc#chr-NUMBER&quot;&gt;&lt;code&gt;chr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#print-FILEHANDLE-LIST&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#ord-EXPR&quot;&gt;&lt;code&gt;ord&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#sort-SUBNAME-LIST&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#sprintf-FORMAT%2C-LIST&quot;&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;), as well as bit-fiddling with ASCII constants using operators like &lt;a href=&quot;perlop#Bitwise-String-Operators&quot;&gt;&lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;&lt;/a&gt;, not to mention dealing with socket interfaces to ASCII computers (see &lt;a href=&quot;#Newlines&quot;&gt;&quot;Newlines&quot;&lt;/a&gt;).</source>
          <target state="translated">これらのプラットフォームでは、EBCDIC文字セットが一部のPerl関数（&lt;a href=&quot;perlfunc#chr-NUMBER&quot;&gt; &lt;code&gt;chr&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;perlfunc#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;perlfunc#print-FILEHANDLE-LIST&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;perlfunc#printf-FILEHANDLE-FORMAT%2C-LIST&quot;&gt; &lt;code&gt;printf&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;perlfunc#ord-EXPR&quot;&gt; &lt;code&gt;ord&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;perlfunc#sort-SUBNAME-LIST&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;perlfunc#sprintf-FORMAT%2C-LIST&quot;&gt; &lt;code&gt;sprintf&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;perlfunc#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; など&lt;/a&gt;）で発生することや、ビットをいじることに影響を与える可能性があることに注意してください。&lt;a href=&quot;perlop#Bitwise-String-Operators&quot;&gt; &lt;code&gt;^&lt;/code&gt; 、 &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; &lt;/a&gt;などの演算子を使用したASCII定数、ASCIIコンピュータへのソケットインターフェイスの取り扱いは言うまでもありません（&lt;a href=&quot;#Newlines&quot;&gt;「改行」を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="c0b2c5bcb8fba3a9644276ad63b66e732faef04f" translate="yes" xml:space="preserve">
          <source>On these platforms, bear in mind that the EBCDIC character set may have an effect on what happens with some Perl functions (such as &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;), as well as bit-fiddling with ASCII constants using operators like &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;, not to mention dealing with socket interfaces to ASCII computers (see &lt;a href=&quot;#Newlines&quot;&gt;Newlines&lt;/a&gt;).</source>
          <target state="translated">これらのプラットフォームでは、EBCDIC文字セットが一部のPerl関数（ &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; など）で何が起こるか、および &lt;code&gt;^&lt;/code&gt; 、 &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; などの演算子を使用したASCII定数、ASCIIコンピュータへのソケットインターフェイスの扱いは言うまでもありません（&lt;a href=&quot;#Newlines&quot;&gt;改行を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="bf1c918758fe737aef37e1c0ba64400f9f7705ae" translate="yes" xml:space="preserve">
          <source>On those platforms and compilers where &lt;code&gt;bool&lt;/code&gt; really is a boolean (C++, C99), it is easy to forget the cast. You can force &lt;code&gt;bool&lt;/code&gt; to be a &lt;code&gt;char&lt;/code&gt; by compiling with &lt;code&gt;-Accflags=-DPERL_BOOL_AS_CHAR&lt;/code&gt; . You may also wish to run &lt;code&gt;Configure&lt;/code&gt; with something like</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; がブール値（C ++、C99）であるプラットフォームやコンパイラでは、キャストを忘れがちです。 &lt;code&gt;-Accflags=-DPERL_BOOL_AS_CHAR&lt;/code&gt; を使用してコンパイルすることにより、 &lt;code&gt;bool&lt;/code&gt; を強制的に &lt;code&gt;char&lt;/code&gt; にすることができます。次のようなもので &lt;code&gt;Configure&lt;/code&gt; を実行することもできます</target>
        </trans-unit>
        <trans-unit id="ba599ad520fca93f96bd6d59495057f2e3221a03" translate="yes" xml:space="preserve">
          <source>On those platforms and compilers where &lt;code&gt;bool&lt;/code&gt; really is a boolean (C++, C99), it is easy to forget the cast. You can force &lt;code&gt;bool&lt;/code&gt; to be a &lt;code&gt;char&lt;/code&gt; by compiling with &lt;code&gt;-Accflags=-DPERL_BOOL_AS_CHAR&lt;/code&gt;. You may also wish to run &lt;code&gt;Configure&lt;/code&gt; with something like</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; が実際にブール値（C ++、C99）であるプラットフォームやコンパイラーでは、キャストを忘れがちです。 &lt;code&gt;-Accflags=-DPERL_BOOL_AS_CHAR&lt;/code&gt; を使用してコンパイルすることにより、 &lt;code&gt;bool&lt;/code&gt; を強制的に &lt;code&gt;char&lt;/code&gt; にすることができます。次のようなもので &lt;code&gt;Configure&lt;/code&gt; を実行することもできます</target>
        </trans-unit>
        <trans-unit id="750180603d4fade1f60619d413443d4388791bcb" translate="yes" xml:space="preserve">
          <source>On threaded builds a regexp may need to be duplicated so that the pattern can be used by multiple threads. This routine is expected to handle the duplication of any private data pointed to by the &lt;code&gt;pprivate&lt;/code&gt; member of the &lt;code&gt;regexp&lt;/code&gt; structure. It will be called with the preconstructed new &lt;code&gt;regexp&lt;/code&gt; structure as an argument, the &lt;code&gt;pprivate&lt;/code&gt; member will point at the &lt;b&gt;old&lt;/b&gt; private structure, and it is this routine's responsibility to construct a copy and return a pointer to it (which Perl will then use to overwrite the field as passed to this routine.)</source>
          <target state="translated">スレッド化されたビルドでは、パターンを複数のスレッドで使用できるように、正規表現を複製する必要がある場合があります。このルーチンは、 &lt;code&gt;regexp&lt;/code&gt; 構造体の &lt;code&gt;pprivate&lt;/code&gt; メンバーが指すプライベートデータの重複を処理することが期待されています。これは、事前に作成された新しい &lt;code&gt;regexp&lt;/code&gt; 構造体を引数として &lt;code&gt;pprivate&lt;/code&gt; 、pprivateメンバーは&lt;b&gt;古い&lt;/b&gt;プライベート構造体を指します。コピーを作成してそれへのポインタを返すのはこのルーチンの責任です（Perlはこれを上書きするために使用します）このルーチンに渡されるフィールド）&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="3f7d01cda50f9d06f5abacea7dcc3dcdce0e0aef" translate="yes" xml:space="preserve">
          <source>On threaded perls not operating with thread-safe functionality, this macro uses a mutex to force a critical section. Therefore the matching RESTORE should be close by, and guaranteed to be called.</source>
          <target state="translated">スレッドセーフ機能で動作していないスレッド付き perls では、このマクロはミューテックスを使用してクリティカルセクションを強制的に実行します。そのため、一致する RESTORE は近くにあり、必ず呼び出されることが保証されていなければなりません。</target>
        </trans-unit>
        <trans-unit id="4e92c3a98c94fccb8ba5784670e12e223f435cc2" translate="yes" xml:space="preserve">
          <source>On threaded perls not operating with thread-safe functionality, this macro uses a mutex to force a critical section. Therefore the matching RESTORE should be close by, and guaranteed to be called; see &lt;a href=&quot;#WITH_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;&quot;WITH_LC_NUMERIC_SET_TO_NEEDED&quot;&lt;/a&gt; for a more contained way to ensure that.</source>
          <target state="translated">スレッドセーフ機能で動作していないスレッド化されたperlでは、このマクロはミューテックスを使用してクリティカルセクションを強制します。したがって、一致するRESTOREが近くにあり、呼び出されることが保証されている必要があります。それを確実にするためのより封じ込められた方法については、&lt;a href=&quot;#WITH_LC_NUMERIC_SET_TO_NEEDED&quot;&gt;「WITH_LC_NUMERIC_SET_TO_NEEDED」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c8ce1f6dab9f2ca8a499735e7d64c50092c9a849" translate="yes" xml:space="preserve">
          <source>On unthreaded builds this field doesn't exist.</source>
          <target state="translated">スレッド化されていないビルドでは、このフィールドは存在しません。</target>
        </trans-unit>
        <trans-unit id="fb3efd91222592d2901cd1f317fee4fadb20e2bc" translate="yes" xml:space="preserve">
          <source>On versions of Perl before 5.26, activating taint mode will also remove the current directory (&quot;.&quot;) from the default value of &lt;code&gt;@INC&lt;/code&gt;. Since version 5.26, the current directory isn't included in &lt;code&gt;@INC&lt;/code&gt; by default.</source>
          <target state="translated">5.26より前のバージョンのPerlでは、汚染モードをアクティブにすると、現在のディレクトリ（ &quot;。&quot;）もデフォルト値の &lt;code&gt;@INC&lt;/code&gt; から削除されます。バージョン5.26以降、現在のディレクトリはデフォルトでは &lt;code&gt;@INC&lt;/code&gt; に含まれていません。</target>
        </trans-unit>
        <trans-unit id="baf07ba18b50ccd1689ea2941fb77a3117773a24" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_out&lt;/code&gt; or &lt;code&gt;test_err&lt;/code&gt; (or &lt;code&gt;test_fail&lt;/code&gt; or &lt;code&gt;test_diag&lt;/code&gt; ) have been called, all further output from &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; will be captured by &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt;. This means that you will not be able perform further tests to the normal output in the normal way until you call &lt;code&gt;test_test&lt;/code&gt; (well, unless you manually meddle with the output filehandles)</source>
          <target state="translated">一度 &lt;code&gt;test_out&lt;/code&gt; とか &lt;code&gt;test_err&lt;/code&gt; （または &lt;code&gt;test_fail&lt;/code&gt; または &lt;code&gt;test_diag&lt;/code&gt; ）からのすべての別の出力、呼び出された&lt;a href=&quot;../builder&quot;&gt;テスト:: Builderは&lt;/a&gt;によって捕獲される&lt;a href=&quot;tester&quot;&gt;テスト:: Builderの::テスター&lt;/a&gt;。これは、 &lt;code&gt;test_test&lt;/code&gt; を呼び出すまで、通常の方法で通常の出力に対してさらにテストを実行できないことを意味します（出力ファイルハンドルを手動で干渉しない限り）</target>
        </trans-unit>
        <trans-unit id="083880b888c49c9dba31b5a1a1d83eae3051aea8" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_out&lt;/code&gt; or &lt;code&gt;test_err&lt;/code&gt; (or &lt;code&gt;test_fail&lt;/code&gt; or &lt;code&gt;test_diag&lt;/code&gt;) have been called, all further output from &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; will be captured by &lt;a href=&quot;Test::Builder::Tester&quot;&gt;Test::Builder::Tester&lt;/a&gt;. This means that you will not be able perform further tests to the normal output in the normal way until you call &lt;code&gt;test_test&lt;/code&gt; (well, unless you manually meddle with the output filehandles)</source>
          <target state="translated">一度 &lt;code&gt;test_out&lt;/code&gt; とか &lt;code&gt;test_err&lt;/code&gt; （または &lt;code&gt;test_fail&lt;/code&gt; または &lt;code&gt;test_diag&lt;/code&gt; ）からのすべての別の出力、呼び出された&lt;a href=&quot;Test::Builder&quot;&gt;テスト:: Builderは&lt;/a&gt;によって捕獲される&lt;a href=&quot;Test::Builder::Tester&quot;&gt;テスト:: Builderの::テスター&lt;/a&gt;。これは、 &lt;code&gt;test_test&lt;/code&gt; を呼び出すまで、通常の方法で通常の出力に対してそれ以上のテストを実行できないことを意味します（出力ファイルハンドルを手動で操作しない限り）</target>
        </trans-unit>
        <trans-unit id="9443afa365a30ff5f37332fa968121f2dbb81425" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_test&lt;/code&gt; has been run test output will be redirected back to the original filehandles that &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; was connected to (probably STDOUT and STDERR,) meaning any further tests you run will function normally and cause success/errors for &lt;a href=&quot;../harness&quot;&gt;Test::Harness&lt;/a&gt;.</source>
          <target state="translated">一度 &lt;code&gt;test_test&lt;/code&gt; は、実行、テスト出力があることを元のファイルハンドルにリダイレクトされますされています&lt;a href=&quot;../builder&quot;&gt;テスト:: Builderのは&lt;/a&gt;、あなたが実行任意のさらなる試験が正常に機能しての原因の成功/エラーになる意味（おそらくSTDOUTおよびSTDERR）に接続された&lt;a href=&quot;../harness&quot;&gt;テスト::ハーネス&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6814624afd4c6e39f83bea80e53ce4d9099ae560" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;test_test&lt;/code&gt; has been run test output will be redirected back to the original filehandles that &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; was connected to (probably STDOUT and STDERR,) meaning any further tests you run will function normally and cause success/errors for &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt;.</source>
          <target state="translated">一度 &lt;code&gt;test_test&lt;/code&gt; は、実行、テスト出力があることを元のファイルハンドルにリダイレクトされますされています&lt;a href=&quot;Test::Builder&quot;&gt;テスト:: Builderのは&lt;/a&gt;、あなたが実行任意のさらなる試験が正常に機能しての原因の成功/エラーになる意味（おそらくSTDOUTおよびSTDERR）に接続された&lt;a href=&quot;Test::Harness&quot;&gt;テスト::ハーネス&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0908b28a0f268394a7964fa489d2fda27d507a0" translate="yes" xml:space="preserve">
          <source>Once EOF is detected (&lt;code&gt;$status&lt;/code&gt; is zero) the filter will insert an extra line into the source stream. When this extra line is executed it will print a count of the number of substitutions actually made. Note that &lt;code&gt;$status&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; in this case.</source>
          <target state="translated">EOFが検出されると（ &lt;code&gt;$status&lt;/code&gt; がゼロ）、フィルターはソースストリームに追加の行を挿入します。この追加の行が実行されると、実際に行われた置換の数のカウントが出力されます。この場合、 &lt;code&gt;$status&lt;/code&gt; は &lt;code&gt;1&lt;/code&gt; に設定されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="48f0ab6402e0ed10a074d92b2f594ddaae93f903" translate="yes" xml:space="preserve">
          <source>Once Perl sees that you need one of these variables anywhere in the program, it provides them on each and every pattern match. That means that on every pattern match the entire string will be copied, part of it to $`, part to $&amp;amp;, and part to $'. Thus the penalty is most severe with long strings and patterns that match often. Avoid $&amp;amp;, $', and $` if you can, but if you can't, once you've used them at all, use them at will because you've already paid the price. Remember that some algorithms really appreciate them. As of the 5.005 release, the $&amp;amp; variable is no longer &quot;expensive&quot; the way the other two are.</source>
          <target state="translated">Perlは、プログラム内のどこかにこれらの変数の1つが必要であることを検出すると、すべてのパターンマッチでそれらを提供します。つまり、すべてのパターンマッチで文字列全体がコピーされ、その一部が$ `、一部が$＆、一部が$ 'にコピーされます。したがって、ペナルティは長いストリングと頻繁に一致するパターンで最も深刻です。可能であれば$＆、$ '、$ `は避けますが、できなかった場合は、すでに料金を支払っているので、一度使用したら、自由に使用してください。いくつかのアルゴリズムは本当にそれらを高く評価していることを覚えておいてください。 5.005リリース以降、$＆変数は他の2つとは異なり、「高価」ではなくなりました。</target>
        </trans-unit>
        <trans-unit id="296ec9cb13f85c2f6eee6c3dfe23452785f51838" translate="yes" xml:space="preserve">
          <source>Once a feature, construct or module has been marked as deprecated, we may remove it from the Perl core. Unsurprisingly, we say we've &lt;b&gt;removed&lt;/b&gt; these things. When a module is removed, it will no longer ship with Perl, but will continue to be available on CPAN.</source>
          <target state="translated">機能、構成、またはモジュールが非推奨としてマークされたら、Perlコアから削除することができます。当然のことながら、これらの項目は&lt;b&gt;削除され&lt;/b&gt;ました。モジュールが削除されると、Perlに同梱されなくなりますが、CPANで引き続き使用できます。</target>
        </trans-unit>
        <trans-unit id="a0837f9cee9c8dc066f294cad80d931eedcddeed" translate="yes" xml:space="preserve">
          <source>Once a handle is open, its layers can be altered using &lt;code&gt;binmode&lt;/code&gt;.</source>
          <target state="translated">ハンドルが開いたら、 &lt;code&gt;binmode&lt;/code&gt; を使用してそのレイヤーを変更できます。</target>
        </trans-unit>
        <trans-unit id="7394cfde1fc1b93e93cb9b4f086c54f1b9ffd59b" translate="yes" xml:space="preserve">
          <source>Once a module has been included in the Perl core, however, everyone involved in maintaining Perl should be aware that the module is still the property of the original author unless the original author explicitly gives up their ownership of it. In particular:</source>
          <target state="translated">しかし、いったんモジュールが Perl のコアに含まれると、Perl のメンテナンスに関わるすべての人は、原著 者が明示的に所有権を放棄しない限り、そのモジュールは原著者の所有物であることを認識しなければなりません。特に。</target>
        </trans-unit>
        <trans-unit id="fb8472b689cb77838766fd3ad6c514d183c9cd46" translate="yes" xml:space="preserve">
          <source>Once a referent has been blessed, the &lt;code&gt;blessed&lt;/code&gt; function from the &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar::Util&lt;/a&gt; core module can tell us its class name. This subroutine returns an object's class when passed an object, and false otherwise.</source>
          <target state="translated">指示対象が祝福されると、&lt;a href=&quot;Scalar::Util&quot;&gt;Scalar :: Util&lt;/a&gt;コアモジュールの &lt;code&gt;blessed&lt;/code&gt; 関数がそのクラス名を教えてくれます。このサブルーチンは、オブジェクトが渡されるとオブジェクトのクラスを返し、それ以外の場合はfalseを返します。</target>
        </trans-unit>
        <trans-unit id="395a04379c153d488a5c8556f8b5ec9aaac6c9a5" translate="yes" xml:space="preserve">
          <source>Once a referent has been blessed, the &lt;code&gt;blessed&lt;/code&gt; function from the &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; core module can tell us its class name. This subroutine returns an object's class when passed an object, and false otherwise.</source>
          <target state="translated">指示対象が祝福されると、&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;コアモジュールの &lt;code&gt;blessed&lt;/code&gt; 関数がクラス名を教えてくれます。このサブルーチンは、オブジェクトが渡されるとオブジェクトのクラスを返し、そうでない場合はfalseを返します。</target>
        </trans-unit>
        <trans-unit id="591c19dc13259933f77d04158c9b97cb405eddcb" translate="yes" xml:space="preserve">
          <source>Once a thread is detached, it may not be joined, and any return data that it might have produced (if it was done and waiting for a join) is lost.</source>
          <target state="translated">一度スレッドが切り離されると、それは結合されないかもしれませんし、それが生成していたかもしれないリターンデータはすべて失われます(もしそれが実行されて結合を待っていたなら)。</target>
        </trans-unit>
        <trans-unit id="12df76345c558476956303e6bd354373a1af6336" translate="yes" xml:space="preserve">
          <source>Once a todo test starts succeeding, simply move it outside the block. When the block is empty, delete it.</source>
          <target state="translated">Todoテストが成功し始めたら、ブロックの外に移動させるだけです。ブロックが空になったら削除します。</target>
        </trans-unit>
        <trans-unit id="de1c57e84d4335aa8d593dcd913db4541c9be506" translate="yes" xml:space="preserve">
          <source>Once a variable is removed, its use triggers an error telling you the variable is unsupported.</source>
          <target state="translated">変数が削除されると、その変数がサポートされていないことを知らせるエラーが発生します。</target>
        </trans-unit>
        <trans-unit id="aeba7900e971ad3f9f9e894e67cc3b717aab109e" translate="yes" xml:space="preserve">
          <source>Once again, &lt;code&gt;module-starter&lt;/code&gt; or &lt;code&gt;h2xs&lt;/code&gt; has done all the work for you. They produce the standard &lt;code&gt;Makefile.PL&lt;/code&gt; you see when you download and install modules, and this produces a Makefile with a &lt;code&gt;dist&lt;/code&gt; target.</source>
          <target state="translated">もう一度、 &lt;code&gt;module-starter&lt;/code&gt; または &lt;code&gt;h2xs&lt;/code&gt; がすべての作業を行いました。これらは、モジュールをダウンロードしてインストールするときに表示される標準の &lt;code&gt;Makefile.PL&lt;/code&gt; を生成します。これにより、 &lt;code&gt;dist&lt;/code&gt; ターゲットを持つMakefileが生成されます。</target>
        </trans-unit>
        <trans-unit id="8b1aff24b00940dd82d1491dbe39c6cb52b648ed" translate="yes" xml:space="preserve">
          <source>Once approved, changes are merged into &lt;a href=&quot;https://github.com/tpf/perlfaq&quot;&gt;https://github.com/tpf/perlfaq&lt;/a&gt;, the repository which drives &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;, and they are distributed with the next Perl 5 release.</source>
          <target state="translated">承認されると、変更は&lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;を駆動するリポジトリである&lt;a href=&quot;https://github.com/tpf/perlfaq&quot;&gt;https://github.com/tpf/perlfaq&lt;/a&gt;にマージされ、次のPerl 5リリースで配布されます。</target>
        </trans-unit>
        <trans-unit id="2b54e888aa5f3b1e9daaa58b06235556e830e504" translate="yes" xml:space="preserve">
          <source>Once at the command line, type &lt;code&gt;h&lt;/code&gt; for one-page help screen; the rest should be self-explanatory.</source>
          <target state="translated">コマンドラインで &lt;code&gt;h&lt;/code&gt; と入力すると、1ページのヘルプ画面が表示されます。残りは自明です。</target>
        </trans-unit>
        <trans-unit id="480a6fac81e70daea3f924bcfe32eba60a95619a" translate="yes" xml:space="preserve">
          <source>Once called the FILE * should</source>
          <target state="translated">一度呼び出された後は、FILE *を呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="fadbaf9125427892864d707c6d22361430d22b8f" translate="yes" xml:space="preserve">
          <source>Once ended, no more items may be placed in the queue.</source>
          <target state="translated">終了すると、これ以上の項目はキューに入れないことがあります。</target>
        </trans-unit>
        <trans-unit id="6742558d45b013c0f52c3e462293464937a542ee" translate="yes" xml:space="preserve">
          <source>Once installed you may delete the temporary archive.</source>
          <target state="translated">インストールしたら、一時的なアーカイブを削除することができます。</target>
        </trans-unit>
        <trans-unit id="14db76a9667a7b9782c3a5e1dfcf95186773ac9a" translate="yes" xml:space="preserve">
          <source>Once it has created those helpers TAP::Harness starts running the tests. For each test it creates a new parser (TAP::Parser) which is responsible for running the test script and parsing its output.</source>
          <target state="translated">ヘルパーを作成すると、TAP::Harness はテストを実行し始めます。各テストに対して、テストスクリプトの実行と出力の解析を担当する新しいパーサー (TAP::Parser)を作成します。</target>
        </trans-unit>
        <trans-unit id="916fa7b57196ffe55f0094ed9d80bbb62daf5b2c" translate="yes" xml:space="preserve">
          <source>Once mapped, you can treat &lt;code&gt;$string&lt;/code&gt; as you would any other string. Since you don't necessarily have to load the data, mmap-ing can be very fast and may not increase your memory footprint.</source>
          <target state="translated">マップしたら、 &lt;code&gt;$string&lt;/code&gt; を他の文字列と同じように扱うことができます。データをロードする必要は必ずしもないため、mmap-ingは非常に高速になり、メモリフットプリントが増加しない場合があります。</target>
        </trans-unit>
        <trans-unit id="48df5812892e79e577960bece1b7fde5e79ea047" translate="yes" xml:space="preserve">
          <source>Once miniperl.exe creation is over, run nmake from the NetWare folder. This will build the Perl interpreter for NetWare as</source>
          <target state="translated">miniperl.exe の作成が終わったら、NetWare フォルダから nmake を実行します。これにより、NetWare 用の Perl インタプリタが</target>
        </trans-unit>
        <trans-unit id="b72bd7ffb13635f0115e40bb684ebf6013fb4223" translate="yes" xml:space="preserve">
          <source>Once perl is installed you can read this document in the following way</source>
          <target state="translated">perlがインストールされていれば、以下の方法でこのドキュメントを読むことができます。</target>
        </trans-unit>
        <trans-unit id="f6c4f57a7ab5a360e46162416f69b58e4d7acd9a" translate="yes" xml:space="preserve">
          <source>Once picked, it is important to stick to your version scheme, without reducing the number of digits. This is because &quot;downstream&quot; packagers, such as the FreeBSD ports system, interpret the version numbers in various ways. If you change the number of digits in your version scheme, you can confuse these systems so they get the versions of your module out of order, which is obviously bad.</source>
          <target state="translated">一度選んだら、数字の数を減らさずにバージョンスキームにこだわることが重要です。これは、FreeBSD の ports システムのような「下流の」パッカーは、 バージョン番号をさまざまな方法で解釈するからです。バージョンスキームの桁数を変更すると、これらのシステムを混乱させ、 モジュールのバージョンを順番に並べ替えてしまうことになりますが、 これは明らかに悪いことです。</target>
        </trans-unit>
        <trans-unit id="07633063ecd66c0146fe9d11656fc4703df1f61f" translate="yes" xml:space="preserve">
          <source>Once produced Makefiles for MacOS Classic</source>
          <target state="translated">MacOS Classic用のMakefilesを作成したら</target>
        </trans-unit>
        <trans-unit id="654d50c5d753e55a4e1dbf0b00907d7f4969d3a9" translate="yes" xml:space="preserve">
          <source>Once registered, there is no mechanism to switch these hooks off, so if that is necessary you will need to do this yourself. An entry in &lt;code&gt;%^H&lt;/code&gt; is probably the best way, so the effect is lexically scoped; however it is also possible to use the &lt;code&gt;BhkDISABLE&lt;/code&gt; and &lt;code&gt;BhkENABLE&lt;/code&gt; macros to temporarily switch entries on and off. You should also be aware that generally speaking at least one scope will have opened before your extension is loaded, so you will see some &lt;code&gt;pre/post_end&lt;/code&gt; pairs that didn't have a matching &lt;code&gt;start&lt;/code&gt; .</source>
          <target state="translated">いったん登録すると、これらのフックをオフにするメカニズムはありません。そのため、それが必要な場合は、自分で行う必要があります。 &lt;code&gt;%^H&lt;/code&gt; のエントリがおそらく最良の方法であるため、効果はレキシカルにスコープされます。ただし、 &lt;code&gt;BhkDISABLE&lt;/code&gt; および &lt;code&gt;BhkENABLE&lt;/code&gt; マクロを使用して、一時的にエントリのオンとオフを切り替えることもできます。また、一般的に言えば、拡張機能が読み込まれる前に少なくとも1つのスコープが開かれるため、一致する &lt;code&gt;start&lt;/code&gt; を持たない &lt;code&gt;pre/post_end&lt;/code&gt; ペアがいくつか表示されることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="6126376d608e0a08175eebdf21cea20073d31c49" translate="yes" xml:space="preserve">
          <source>Once registered, there is no mechanism to switch these hooks off, so if that is necessary you will need to do this yourself. An entry in &lt;code&gt;%^H&lt;/code&gt; is probably the best way, so the effect is lexically scoped; however it is also possible to use the &lt;code&gt;BhkDISABLE&lt;/code&gt; and &lt;code&gt;BhkENABLE&lt;/code&gt; macros to temporarily switch entries on and off. You should also be aware that generally speaking at least one scope will have opened before your extension is loaded, so you will see some &lt;code&gt;pre&lt;/code&gt;/&lt;code&gt;post_end&lt;/code&gt; pairs that didn't have a matching &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="translated">登録すると、これらのフックをオフにするメカニズムはないため、必要な場合は自分で行う必要があります。 &lt;code&gt;%^H&lt;/code&gt; のエントリがおそらく最良の方法であるため、効果は字句スコープになります。しかし、使用することも可能である &lt;code&gt;BhkDISABLE&lt;/code&gt; と &lt;code&gt;BhkENABLE&lt;/code&gt; 一時的にエントリとオフを切り替えるには、マクロを。また、一般的に言えば、拡張機能が読み込まれる前に少なくとも1つのスコープが開かれるため、 &lt;code&gt;start&lt;/code&gt; が一致しなかった &lt;code&gt;pre&lt;/code&gt; / &lt;code&gt;post_end&lt;/code&gt; ペアがいくつか表示されることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="bbf6b188e1d6cda2b1c31b9f2ea910f75bac5ce6" translate="yes" xml:space="preserve">
          <source>Once the 'aaab' at the start of the string has matched, and the &lt;code&gt;(*SKIP)&lt;/code&gt; executed, the next starting point will be where the cursor was when the &lt;code&gt;(*SKIP)&lt;/code&gt; was executed.</source>
          <target state="translated">文字列の先頭の 'aaab'が一致し、 &lt;code&gt;(*SKIP)&lt;/code&gt; が実行されると、次の開始点は、 &lt;code&gt;(*SKIP)&lt;/code&gt; が実行されたときにカーソルがあった場所になります。</target>
        </trans-unit>
        <trans-unit id="8672a62497c5f795c9c2acf9e29afcdfcf0e6269" translate="yes" xml:space="preserve">
          <source>Once the AV has been created, the following operations are possible on it:</source>
          <target state="translated">AVが作成されると、そのAVに対して以下の操作が可能になります。</target>
        </trans-unit>
        <trans-unit id="67df8d841097b17fc29c0a4ea72cc77f4ff9a4eb" translate="yes" xml:space="preserve">
          <source>Once the HV has been created, the following operations are possible on it:</source>
          <target state="translated">HV が作成されると、HV に対して以下の操作が可能になります。</target>
        </trans-unit>
        <trans-unit id="7b0782b5689e0608cbf6133cde75f1c5a3739fbd" translate="yes" xml:space="preserve">
          <source>Once the build is completed you need to create the DLL SIS file by</source>
          <target state="translated">ビルドが完了したら、以下の方法で DLL SIS ファイルを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="57df9a521b252465d2cd33284b38479df5df9b79" translate="yes" xml:space="preserve">
          <source>Once the filtering has been applied, the original strings, regexes, POD, etc. are re-inserted into the code, by replacing each placeholder with the corresponding original component (from &lt;code&gt;@components&lt;/code&gt; ). Note that this means that the &lt;code&gt;@components&lt;/code&gt; variable must be treated with extreme care within the filter. The &lt;code&gt;@components&lt;/code&gt; array stores the &quot;back- translations&quot; of each placeholder inserted into &lt;code&gt;$_&lt;/code&gt; , as well as the interstitial source code between placeholders. If the placeholder backtranslations are altered in &lt;code&gt;@components&lt;/code&gt; , they will be similarly changed when the placeholders are removed from &lt;code&gt;$_&lt;/code&gt; after the filter is complete.</source>
          <target state="translated">フィルタリングが適用されると、各プレースホルダーを対応する元のコンポーネント（ &lt;code&gt;@components&lt;/code&gt; から）に置き換えることにより、元の文字列、正規表現、PODなどがコードに再挿入されます。これは、 &lt;code&gt;@components&lt;/code&gt; 変数をフィルター内で細心の注意を払って処理する必要があることを意味することに注意してください。 &lt;code&gt;@components&lt;/code&gt; のアレイストアに挿入された各プレースホルダの「バック翻訳」 &lt;code&gt;$_&lt;/code&gt; 、ならびにプレースホルダ間の間隙ソースコード。プレースホルダーの逆翻訳が &lt;code&gt;@components&lt;/code&gt; で変更されている場合、フィルターの完了後にプレースホルダーが &lt;code&gt;$_&lt;/code&gt; から削除されると、同様に変更されます。</target>
        </trans-unit>
        <trans-unit id="cd6cbdddebea04b989e355c0ed247c28cfea9f3d" translate="yes" xml:space="preserve">
          <source>Once the filtering has been applied, the original strings, regexes, POD, etc. are re-inserted into the code, by replacing each placeholder with the corresponding original component (from &lt;code&gt;@components&lt;/code&gt;). Note that this means that the &lt;code&gt;@components&lt;/code&gt; variable must be treated with extreme care within the filter. The &lt;code&gt;@components&lt;/code&gt; array stores the &quot;back- translations&quot; of each placeholder inserted into &lt;code&gt;$_&lt;/code&gt;, as well as the interstitial source code between placeholders. If the placeholder backtranslations are altered in &lt;code&gt;@components&lt;/code&gt;, they will be similarly changed when the placeholders are removed from &lt;code&gt;$_&lt;/code&gt; after the filter is complete.</source>
          <target state="translated">フィルタリングが適用されると、各プレースホルダーを対応する元のコンポーネント（ &lt;code&gt;@components&lt;/code&gt; から）に置き換えることにより、元の文字列、正規表現、PODなどがコードに再挿入されます。これは、 &lt;code&gt;@components&lt;/code&gt; 変数をフィルター内で細心の注意を払って処理する必要があることを意味することに注意してください。 &lt;code&gt;@components&lt;/code&gt; のアレイストアに挿入された各プレースホルダの「バック翻訳」 &lt;code&gt;$_&lt;/code&gt; 、ならびにプレースホルダ間の間隙ソースコード。プレースホルダbacktranslationsがで変更された場合 &lt;code&gt;@components&lt;/code&gt; プレースホルダがから削除されたとき、彼らは同様に変更されます &lt;code&gt;$_&lt;/code&gt; フィルタが完了した後。</target>
        </trans-unit>
        <trans-unit id="4bda05c922f6c0e7108b9b6664cf70b280c74345" translate="yes" xml:space="preserve">
          <source>Once the first line has been processed, the flow will look like this:</source>
          <target state="translated">1行目の処理が終わると、次のような流れになります。</target>
        </trans-unit>
        <trans-unit id="2abcd9048b9f7de01dd766ea3b827a4a4ca6e4d7" translate="yes" xml:space="preserve">
          <source>Once the generic server socket has been created using the parameters listed above, the server then waits for a new client to connect to it. The server blocks in the &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt; method, which eventually accepts a bidirectional connection from the remote client. (Make sure to autoflush this handle to circumvent buffering.)</source>
          <target state="translated">上記のパラメーターを使用して汎用サーバーソケットが作成されると、サーバーは新しいクライアントが接続するのを待ちます。サーバーは &lt;code&gt;&lt;a href=&quot;functions/accept&quot;&gt;accept&lt;/a&gt;&lt;/code&gt; メソッドでブロックし、最終的にリモートクライアントからの双方向接続を受け入れます。（バッファリングを回避するために、このハンドルを必ず自動フラッシュしてください。）</target>
        </trans-unit>
        <trans-unit id="f10049f7656078a8b871ef2357d99fe6e6157f3d" translate="yes" xml:space="preserve">
          <source>Once the generic server socket has been created using the parameters listed above, the server then waits for a new client to connect to it. The server blocks in the &lt;code&gt;accept&lt;/code&gt; method, which eventually accepts a bidirectional connection from the remote client. (Make sure to autoflush this handle to circumvent buffering.)</source>
          <target state="translated">上記のパラメータを使用して汎用サーバーソケットが作成されると、サーバーは新しいクライアントがそれに接続するのを待ちます。サーバーは &lt;code&gt;accept&lt;/code&gt; メソッドでブロックし、最終的にリモートクライアントからの双方向接続を受け入れます。（バッファリングを回避するために、このハンドルを必ず自動フラッシュしてください。）</target>
        </trans-unit>
        <trans-unit id="47f78b2677c2893cae03c215c7f1cb2296b9c1aa" translate="yes" xml:space="preserve">
          <source>Once the headers have been installed, you can create a SIS for the PerlApp:</source>
          <target state="translated">ヘッダがインストールされたら、PerlApp用のSISを作成します。</target>
        </trans-unit>
        <trans-unit id="3ee769afc72db89229ffb2a909f356b2b29d26cc" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the exit status. If the parser ran an executable, it returns the exit status of the executable.</source>
          <target state="translated">パーサが終了すると、終了ステータスを返します。パーサが実行ファイルを実行した場合は、実行ファイルの終了ステータスを返します。</target>
        </trans-unit>
        <trans-unit id="4d1cfe61310d7995317dabd0218a153aefb9089c" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the version number for the parsed TAP. Version numbers were introduced with TAP version 13 so if no version number is found version 12 is assumed.</source>
          <target state="translated">パーサが完了すると、解析されたTAPのバージョン番号が返されます。バージョン番号はTAPバージョン13で導入されたので、バージョン番号が見つからない場合はバージョン12を想定しています。</target>
        </trans-unit>
        <trans-unit id="295310f03609b1e9bcb5a3f97bee3cf209b7fdc9" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the wait status. If the parser ran an executable, it returns the wait status of the executable. Otherwise, this merely returns the &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; status.</source>
          <target state="translated">パーサーが完了すると、待機ステータスが返されます。パーサーが実行可能ファイルを実行した場合、実行可能ファイルの待機ステータスを返します。それ以外の場合、これは単に &lt;code&gt;&lt;a href=&quot;../functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; ステータスを返します。</target>
        </trans-unit>
        <trans-unit id="58ee32eca6824b955eaf78744f8a028137e28ac5" translate="yes" xml:space="preserve">
          <source>Once the parser is done, this will return the wait status. If the parser ran an executable, it returns the wait status of the executable. Otherwise, this merely returns the &lt;code&gt;exit&lt;/code&gt; status.</source>
          <target state="translated">パーサーが完了すると、待機ステータスが返されます。パーサーが実行可能ファイルを実行した場合、実行可能ファイルの待機ステータスを返します。それ以外の場合、これは単に &lt;code&gt;exit&lt;/code&gt; ステータスを返します。</target>
        </trans-unit>
        <trans-unit id="e563448cf76902cc1f89b5320bc98d51a6a5d5a8" translate="yes" xml:space="preserve">
          <source>Once the prefix an dthe outermost opening delimiter bracket have been recognized, code blocks are extracted by stepping through the input text and trying the following alternatives in sequence:</source>
          <target state="translated">接頭辞とd番外の区切り括弧が認識されると、入力テキストをステップスルーして、以下の選択肢を順番に試すことでコードブロックが抽出されます。</target>
        </trans-unit>
        <trans-unit id="c16b3faffb99d8d54125fd9ac6e0e713e87e3953" translate="yes" xml:space="preserve">
          <source>Once the program is otherwise done, and once its localization for the first language works right (via the data and methods in Projname::L10N::en_us), you can get together the data for translation. If your first language lexicon isn't an _AUTO lexicon, then you already have all the messages explicitly in the lexicon (or else you'd be getting exceptions thrown when you call $lh-&amp;gt;maketext to get messages that aren't in there). But if you were (advisedly) lazy and are using an _AUTO lexicon, then you've got to make a list of all the phrases that you've so far been letting _AUTO generate for you. There are very many ways to assemble such a list. The most straightforward is to simply grep the source for every occurrence of &quot;maketext&quot; (or calls to wrappers around it, like the above &lt;code&gt;pmt&lt;/code&gt; function), and to log the following phrase.</source>
          <target state="translated">プログラムが別の方法で実行され、第1言語のローカリゼーションが正しく機能するようになると（Projname :: L10N :: en_usのデータとメソッドを介して）、データをまとめて翻訳することができます。最初の言語のレキシコンが_AUTOレキシコンではない場合、レキシコンにすべてのメッセージが明示的に存在します（または、$ lh-&amp;gt; maketextを呼び出してそこにないメッセージを取得すると例外がスローされます）。ただし、（推奨）怠惰で_AUTOレキシコンを使用している場合は、これまでに_AUTOで生成させているすべてのフレーズのリストを作成する必要があります。そのようなリストを組み立てる方法は非常にたくさんあります。最も簡単なのは、「maketext」が出現するたびにソースをgrepする（または、上記の &lt;code&gt;pmt&lt;/code&gt; のように、その周りのラッパーを呼び出す）ことです。 関数）、および次のフレーズをログに記録します。</target>
        </trans-unit>
        <trans-unit id="2748f5e91bdbaf9d65e1b144f8ee5e1cdc0ecbe6" translate="yes" xml:space="preserve">
          <source>Once the reference is stored in a variable like $aref or $href, you can copy it or store it just the same as any other scalar value:</source>
          <target state="translated">参照が $aref や $href のような変数に保存されると、他のスカラ値と同じようにコピーしたり保存したりすることができます。</target>
        </trans-unit>
        <trans-unit id="15fa63ef5d4644b5d99dc644eff10efe12c6233c" translate="yes" xml:space="preserve">
          <source>Once the size of the program has been determined, the pattern is parsed again, but this time for real. Now &lt;code&gt;SIZE_ONLY&lt;/code&gt; will be false, and the actual construction can occur.</source>
          <target state="translated">プログラムのサイズが決定されると、パターンが再度解析されますが、今回は実際に行われます。これで &lt;code&gt;SIZE_ONLY&lt;/code&gt; はfalseになり、実際の構築が行われる可能性があります。</target>
        </trans-unit>
        <trans-unit id="7c79022e55900699b84f2aa1eb3cdbe226323760" translate="yes" xml:space="preserve">
          <source>Once the socket has been connected to the peer, &lt;code&gt;connect&lt;/code&gt; will return true and the socket will now be ready to use.</source>
          <target state="translated">ソケットがピアに &lt;code&gt;connect&lt;/code&gt; されると、connectはtrueを返し、ソケットを使用できるようになります。</target>
        </trans-unit>
        <trans-unit id="7ba841c18d878724cf95fcf3049c21ef759f81a9" translate="yes" xml:space="preserve">
          <source>Once the source was patched, &lt;code&gt;./Configure&lt;/code&gt; and &lt;code&gt;make test_prep&lt;/code&gt; were called and completed successfully, enabling confirmation of the findings in RT #72414.</source>
          <target state="translated">ソースにパッチが適用されると、。 &lt;code&gt;./Configure&lt;/code&gt; と &lt;code&gt;make test_prep&lt;/code&gt; が呼び出されて正常に完了し、RT＃72414での結果の確認が可能になります。</target>
        </trans-unit>
        <trans-unit id="1ce09f4f2086e283549a294da4a8bb0ec70720b9" translate="yes" xml:space="preserve">
          <source>Once this is done, do the following to build any extension:</source>
          <target state="translated">これができたら、次のようにして任意の拡張機能を構築します。</target>
        </trans-unit>
        <trans-unit id="c86d1961dcc0430277520b8cb5786b3c716d4a7c" translate="yes" xml:space="preserve">
          <source>Once this process completes for a given function, it is defined, so future calls to the subroutine will bypass the AUTOLOAD mechanism.</source>
          <target state="translated">与えられた関数に対してこの処理が完了すると、それが定義されるので、今後のサブルーチンの呼び出しはAUTOLOADメカニズムをバイパスします。</target>
        </trans-unit>
        <trans-unit id="9bc6c924aca0f68365c3f48d14dbdebf3eb3856a" translate="yes" xml:space="preserve">
          <source>Once uploaded, it'll sit unnoticed in your author directory. If you want it connected to the rest of the CPAN, you'll need to go to &quot;Register Namespace&quot; on PAUSE. Once registered, your module will appear in the by-module and by-category listings on CPAN.</source>
          <target state="translated">一度アップロードしてしまえば、あなたのオーサディレクトリには気付かれないようになっています。CPANの残りの部分に接続したい場合は、PAUSEの &quot;Register Namespace &quot;に移動する必要があります。登録されると、あなたのモジュールはCPANのモジュール別とカテゴリ別のリストに表示されます。</target>
        </trans-unit>
        <trans-unit id="852b82c0a8fc155a5b67d823ae98f4fd4d342839" translate="yes" xml:space="preserve">
          <source>Once upon a time, C code compilable under both BSD and SysV. In general, code that can be easily converted to run on another &lt;b&gt;platform&lt;/b&gt;, where &amp;ldquo;easily&amp;rdquo; can be defined however you like, and usually is. Anything may be considered portable if you try hard enough, such as a mobile home or London Bridge.</source>
          <target state="translated">むかしむかし、CコードはBSDとSysVの両方でコンパイルできます。一般に、別の&lt;b&gt;プラットフォーム&lt;/b&gt;で実行するために簡単に変換できるコード。「簡単に」は好きなように定義でき、通常はそうです。モバイルホームやロンドンブリッジなど、十分に努力すれば、何でも持ち運び可能と見なされます。</target>
        </trans-unit>
        <trans-unit id="028479890974f67d52e50ca30dc71571debad796" translate="yes" xml:space="preserve">
          <source>Once upon a time, I wrote a program called pstruct. It was a perl program that tried to parse out C structures and display their member offsets for you. This was especially useful for people looking at binary dumps or poking around the kernel.</source>
          <target state="translated">昔々、私はpstructというプログラムを書きました。これは、C の構造体を解析して、そのメンバオフセットを表示しようとする perl プログラムでした。これは、バイナリダンプを見たり、カーネルを詮索したりする人には特に便利でした。</target>
        </trans-unit>
        <trans-unit id="5311fe73402702af14e5a56e844da83a8b07a8a6" translate="yes" xml:space="preserve">
          <source>Once upon a time, MakeMaker could produce an approximation of a correct Makefile on MacOS Classic (MacPerl). Due to a lack of maintainers, this fell out of sync with the rest of MakeMaker and hadn't worked in years. Since there's little chance of it being repaired, MacOS Classic is fading away, and the code was icky to begin with, the code has been deleted to make maintenance easier.</source>
          <target state="translated">昔々、MakeMaker は MacOS Classic (MacPerl)上で正しい Makefile の近似ファイルを作成することができました。メンテナ不足のため、これが他のMakeMakerと同期しなくなり、何年も動作していませんでした。修理の可能性が低く、MacOS Classic は衰退しつつあり、そもそもコードが不気味だったため、メンテナンスを容易にするためにコードを削除しました。</target>
        </trans-unit>
        <trans-unit id="f360544bd22369fcd1b6d32877524b0035f30449" translate="yes" xml:space="preserve">
          <source>Once upon a time, there was a library called</source>
          <target state="translated">むかしむかし、という図書館がありました。</target>
        </trans-unit>
        <trans-unit id="c419b35f29ce772e59b3d6f120a7bf0188bed72b" translate="yes" xml:space="preserve">
          <source>Once we've blessed the hash referred to by &lt;code&gt;$self&lt;/code&gt; we can start calling methods on it. This is useful if you want to put object initialization in its own separate method:</source>
          <target state="translated">&lt;code&gt;$self&lt;/code&gt; によって参照されるハッシュを祝福したら、そのメソッドを呼び出すことができます。これは、オブジェクトの初期化を独自の独立したメソッドに配置する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="6b240bbed00f45e13a77c757892ecbf1631c45c9" translate="yes" xml:space="preserve">
          <source>Once you can identify individual blocks, try allowing them to be nested. That isn't difficult either.</source>
          <target state="translated">個々のブロックを識別できるようになったら、それらを入れ子にできるようにしてみてください。これも難しいことではありません。</target>
        </trans-unit>
        <trans-unit id="383155a2b30e1482a3f900136a965760218a5249" translate="yes" xml:space="preserve">
          <source>Once you have a reference, you can use the following macro to dereference the reference:</source>
          <target state="translated">参照を取得したら、以下のマクロを使って参照を解除することができます。</target>
        </trans-unit>
        <trans-unit id="8475608c1eecbfff6034af7fbbf89552dc6e6321" translate="yes" xml:space="preserve">
          <source>Once you have changed into the repository directory, you can inspect it. After a clone the repository will contain a single local branch, which will be the current branch as well, as indicated by the asterisk.</source>
          <target state="translated">リポジトリディレクトリに変更したら、それを検査することができます。クローン後のリポジトリには、アスタリスクで示されているように、現在のブランチと同じようにローカルブランチが1つ含まれています。</target>
        </trans-unit>
        <trans-unit id="77ad49af6893225c730f233c983aba4b11bcf0d8" translate="yes" xml:space="preserve">
          <source>Once you have done that, you can access the Berkeley DB API functions as &lt;b&gt;DB_File&lt;/b&gt; methods directly like this:</source>
          <target state="translated">これが完了すると、Berkeley DB API関数に&lt;b&gt;DB_File&lt;/b&gt;メソッドとして次のように直接アクセスできます。</target>
        </trans-unit>
        <trans-unit id="9d9573b46c2994b393d22341f4e2899c15619352" translate="yes" xml:space="preserve">
          <source>Once you have it on, simply bring up a PASE shell and extract the tarball.</source>
          <target state="translated">装着したら、PASEシェルを持ち出してタールボールを抽出するだけです。</target>
        </trans-unit>
        <trans-unit id="2403323a2c0ab8ef6892066d26c525181d3596a2" translate="yes" xml:space="preserve">
          <source>Once you have the list of keys, you can process that list before you process the hash elements. For instance, you can sort the keys so you can process them in lexical order:</source>
          <target state="translated">鍵のリストを取得したら、ハッシュ要素を処理する前にそのリストを処理することができます。例えば、キーを並べ替えて、辞書順に処理できるようにすることができます。</target>
        </trans-unit>
        <trans-unit id="fba888926fbbe98be022401817b7a70ac357c498" translate="yes" xml:space="preserve">
          <source>Once you have the toolchain set up properly, the only remaining hurdle is actually locating where in the device it was installed in. For example, CCTools installs its toolchain in</source>
          <target state="translated">ツールチェインを適切にセットアップしたら、あとはデバイスのどこにインストールされているかを探すだけです。たとえば、CCToolsのツールチェーンは</target>
        </trans-unit>
        <trans-unit id="fa2bd757e5448bc96817cbaf4661aeb1b493b281" translate="yes" xml:space="preserve">
          <source>Once you have this code, slap it into the second argument of</source>
          <target state="translated">このコードを作成したら、それを</target>
        </trans-unit>
        <trans-unit id="1eb08c46cb14cd90ec6426a049fef10ebf7f995f" translate="yes" xml:space="preserve">
          <source>Once you have unpacked the distribution, run &quot;sh Configure&quot; (see INSTALL for a full discussion of the Configure options). There is a &quot;hints&quot; file for os390 that specifies the correct values for most things. Some things to watch out for include:</source>
          <target state="translated">ディストリビューションを解凍したら、&quot;sh Configure &quot;を実行してください。os390 用の &quot;hints&quot; ファイルがあり、ほとんどのものに正しい値を指定しています。注意すべき点としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="23c09803658da900e84c748f878a847903987255" translate="yes" xml:space="preserve">
          <source>Once you have write access, you will need to modify the URL for the origin remote to enable pushing. Edit</source>
          <target state="translated">書き込みアクセスが可能になったら、プッシュを有効にするためにオリジンリモートの URL を変更する必要があります。編集</target>
        </trans-unit>
        <trans-unit id="ae0a83fd366650f3f9c13c1a72ec5ce82cd02510" translate="yes" xml:space="preserve">
          <source>Once you have your binary file properly opened in the right mode, you can use all the same Perl I/O functions as you used on text files. However, you may wish to use the fixed-size &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; instead of the variable-sized &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; for your input.</source>
          <target state="translated">バイナリファイルを適切なモードで適切に開いたら、テキストファイルで使用したものと同じPerl I / O関数をすべて使用できます。ただし、入力に可変サイズの &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; ではなく固定サイズの &lt;code&gt;&lt;a href=&quot;functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="23e5339b1fa0074bcbf688df51973daa79c9a799" translate="yes" xml:space="preserve">
          <source>Once you have your binary file properly opened in the right mode, you can use all the same Perl I/O functions as you used on text files. However, you may wish to use the fixed-size &lt;code&gt;read&lt;/code&gt; instead of the variable-sized &lt;code&gt;readline&lt;/code&gt; for your input.</source>
          <target state="translated">バイナリファイルを適切なモードで適切に開くと、テキストファイルで使用したのと同じPerl I / O関数をすべて使用できます。ただし、入力に可変サイズの &lt;code&gt;readline&lt;/code&gt; ではなく固定サイズの &lt;code&gt;read&lt;/code&gt; を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="4a97180f59d4ebc49010b5f130f6497cfeb42c05" translate="yes" xml:space="preserve">
          <source>Once you have your hook functions, you need a &lt;code&gt;BHK&lt;/code&gt; structure to put them in. It's best to allocate it statically, since there is no way to free it once it's registered. The function pointers should be inserted into this structure using the &lt;code&gt;BhkENTRY_set&lt;/code&gt; macro, which will also set flags indicating which entries are valid. If you do need to allocate your &lt;code&gt;BHK&lt;/code&gt; dynamically for some reason, be sure to zero it before you start.</source>
          <target state="translated">フック関数を &lt;code&gt;BHK&lt;/code&gt; したら、それらを配置するためのBHK構造が必要です。いったん登録すると解放する方法がないため、静的に割り当てるのが最適です。関数ポインタは、 &lt;code&gt;BhkENTRY_set&lt;/code&gt; マクロを使用してこの構造に挿入する必要があります。これにより、有効なエントリを示すフラグも設定されます。何らかの理由で &lt;code&gt;BHK&lt;/code&gt; を動的に割り当てる必要がある場合は、開始する前に必ずゼロにしてください。</target>
        </trans-unit>
        <trans-unit id="e41f59d96ffbb22709bea4ad583772ec9921c59e" translate="yes" xml:space="preserve">
          <source>Once you know what the type of an object is, you then know what subclass it belongs to, and therefore what methods it supports.</source>
          <target state="translated">オブジェクトの型がわかれば、それがどのサブクラスに属しているのか、そしてどのメソッドをサポートしているのかを知ることができます。</target>
        </trans-unit>
        <trans-unit id="850880274fc323f37b6b25fc23ccf3a516cbf65a" translate="yes" xml:space="preserve">
          <source>Once you start accumulating users, they'll send you bug reports. If you're lucky, they'll even send you patches. Welcome to the joys of maintaining a software project...</source>
          <target state="translated">ユーザーを増やし始めると、バグレポートを送ってくれます。運が良ければ、パッチも送ってくれるでしょう。ソフトウェアプロジェクトを維持する喜びにようこそ...</target>
        </trans-unit>
        <trans-unit id="ba22e7b4a3b9d48110bef39d92876fccf1215f67" translate="yes" xml:space="preserve">
          <source>Once you're doing this, you may alter Concise output by adding new rendering styles, and by optionally adding callback routines which populate new variables, if such were referenced from those (just added) styles.</source>
          <target state="translated">これを実行したら、新しいレンダリングスタイルを追加したり、オプションで新しい変数を生成するコールバックルーチンを追加したりして、Concise の出力を変更することができます (追加されたスタイルから参照されている場合)。</target>
        </trans-unit>
        <trans-unit id="566e6d16d506c3974bf904eb0b48aa55735c513e" translate="yes" xml:space="preserve">
          <source>Once you're done here, check out &lt;a href=&quot;perlhacktips&quot;&gt;perlhacktips&lt;/a&gt; next.</source>
          <target state="translated">ここで完了したら、次に&lt;a href=&quot;perlhacktips&quot;&gt;perlhacktipsを&lt;/a&gt;チェックしてください。</target>
        </trans-unit>
        <trans-unit id="29ed2494b99283db9c4753c1220697c79a656d72" translate="yes" xml:space="preserve">
          <source>Once you've actually set any options you want (if any), you can go ahead and use the following methods to search for Pod files in particular ways.</source>
          <target state="translated">実際に任意のオプションを設定したら(もしあれば)、次の方法で特定の方法でPodファイルを検索することができます。</target>
        </trans-unit>
        <trans-unit id="23b007b44c67108f453a7c776499a8dd3ea3293f" translate="yes" xml:space="preserve">
          <source>Once you've done that, you can safely omit the encoding part of the open mode:</source>
          <target state="translated">それが終われば、オープンモードのエンコード部分を省略しても問題ありません。</target>
        </trans-unit>
        <trans-unit id="57d330172757358785b8cc8eade4d52dfcf7f16d" translate="yes" xml:space="preserve">
          <source>Once you've ensured that your module passes its own tests - always a good thing to make sure - you can &lt;code&gt;make dist&lt;/code&gt; , and the Makefile will hopefully produce you a nice tarball of your module, ready for upload.</source>
          <target state="translated">モジュールが独自のテストに合格することを確認したら（常に確認すること &lt;code&gt;make dist&lt;/code&gt; お勧めします）、distを作成できます。Makefileによって、モジュールの素敵なtarballが生成され、アップロードの準備が整います。</target>
        </trans-unit>
        <trans-unit id="43b912c28f1dbb1c2e7aca4c90fa70b6b6f3dc13" translate="yes" xml:space="preserve">
          <source>Once you've ensured that your module passes its own tests - always a good thing to make sure - you can &lt;code&gt;make distcheck&lt;/code&gt; to make sure everything looks OK, followed by &lt;code&gt;make dist&lt;/code&gt;, and the Makefile will hopefully produce you a nice tarball of your module, ready for upload.</source>
          <target state="translated">モジュールが独自のテストに合格していることを確認したら（常に確認するのは良いことです） &lt;code&gt;make distcheck&lt;/code&gt; を実行してすべてが正常に見えることを確認してから、 &lt;code&gt;make dist&lt;/code&gt; を実行すると、Makefileによってモジュールの素晴らしいtarballが生成されることを願っています。 、アップロードの準備ができました。</target>
        </trans-unit>
        <trans-unit id="d9742159929b90169a3b9a1d6ff201b11bb8fe7b" translate="yes" xml:space="preserve">
          <source>Once you've finished writing your commit message and exited your editor, git will write your change to disk and tell you something like this:</source>
          <target state="translated">コミットメッセージを書き終えてエディタを終了すると、git は変更内容をディスクに書き込み、このようなことを教えてくれます。</target>
        </trans-unit>
        <trans-unit id="f63abbf1c003f24ebc901d81ec59d8ecd65e101a" translate="yes" xml:space="preserve">
          <source>Once you've installed the NDK and set up your device, all that's left to do is setting up the device and the cross-compilation environment. Blackberry provides a script, &lt;code&gt;bbndk-env.sh&lt;/code&gt; (occasionally named something like &lt;code&gt;bbndk-env_10_1_0_4828.sh&lt;/code&gt; ) which can be used to do this. However, there's a bit of a snag that we have to work through: The script modifies PATH so that 'gcc' or 'ar' point to their cross-compilation equivalents, which screws over the build process.</source>
          <target state="translated">NDKをインストールしてデバイスをセットアップしたら、あとはデバイスとクロスコンパイル環境をセットアップするだけです。 Blackberryは、これを行うために使用できるスクリプト &lt;code&gt;bbndk-env.sh&lt;/code&gt; （時々 &lt;code&gt;bbndk-env_10_1_0_4828.sh&lt;/code&gt; のような名前が付けられています）を提供しています。ただし、対処が必要な問題が少しあります。スクリプトはPATHを変更して、「gcc」または「ar」が、クロスコンパイルの同等のものを指すようにし、ビルドプロセスをねじ込みます。</target>
        </trans-unit>
        <trans-unit id="0ecc1cbc4b8ed0cfb9b6e01c2a2f1591b2619c6e" translate="yes" xml:space="preserve">
          <source>Once you've installed the NDK and set up your device, all that's left to do is setting up the device and the cross-compilation environment. Blackberry provides a script, &lt;code&gt;bbndk-env.sh&lt;/code&gt; (occasionally named something like &lt;code&gt;bbndk-env_10_1_0_4828.sh&lt;/code&gt;) which can be used to do this. However, there's a bit of a snag that we have to work through: The script modifies PATH so that 'gcc' or 'ar' point to their cross-compilation equivalents, which screws over the build process.</source>
          <target state="translated">NDKをインストールしてデバイスをセットアップしたら、あとはデバイスとクロスコンパイル環境をセットアップするだけです。ブラックベリーは、スクリプト、提供 &lt;code&gt;bbndk-env.sh&lt;/code&gt; （時折のようなものという名前 &lt;code&gt;bbndk-env_10_1_0_4828.sh&lt;/code&gt; をこれを行うために使用することができます）。ただし、対処しなければならない問題が少しあります。スクリプトはPATHを変更して、「gcc」または「ar」がクロスコンパイルの同等物を指すようにします。これにより、ビルドプロセスが台無しになります。</target>
        </trans-unit>
        <trans-unit id="6dca0ad4315ae940ee938651b8e1193e8aa9a420" translate="yes" xml:space="preserve">
          <source>Once you've localized your program/site/etc. for all desired languages, be sure to show the result (whether live, or via screenshots) to the translators. Once they approve, make every effort to have it then checked by at least one other speaker of that language. This holds true even when (or especially when) the translation is done by one of your own programmers. Some kinds of systems may be harder to find testers for than others, depending on the amount of domain-specific jargon and concepts involved -- it's easier to find people who can tell you whether they approve of your translation for &quot;delete this message&quot; in an email-via-Web interface, than to find people who can give you an informed opinion on your translation for &quot;attribute value&quot; in an XML query tool's interface.</source>
          <target state="translated">希望するすべての言語にプログラム/サイト/などをローカライズしたら、その結果を(ライブでもスクリーンショットでも)翻訳者に必ず見せてください。彼らが承認したら、その言語の他の少なくとも1人のスピーカーにチェックしてもらうためにあらゆる努力をしてください。これは、翻訳が自分のプログラマーによって行われている場合でも(特に)当てはまります。システムの種類によっては、ドメイン固有の専門用語や概念の量にもよりますが、テスターを見つけるのが難しい場合もあります。電子メールとウェブのインターフェイスで「このメッセージを削除してください」の翻訳を承認するかどうかを教えてくれる人を見つけるのは簡単ですが、XMLクエリツールのインターフェイスで「属性値」の翻訳について情報に基づいた意見を言ってくれる人を見つけるのは簡単です。</target>
        </trans-unit>
        <trans-unit id="c53ec1e93f888bd372b8348217b36ca16ed6c602" translate="yes" xml:space="preserve">
          <source>Once you've understood those, embedding Perl in C is easy.</source>
          <target state="translated">これらを理解してしまえば、PerlをC言語に埋め込むのは簡単です。</target>
        </trans-unit>
        <trans-unit id="8154145e302b1a07e64a971e9a8a8af681b5891f" translate="yes" xml:space="preserve">
          <source>Once you've unpacked the distribution, run &quot;sh Configure&quot; (see INSTALL for a full discussion of the Configure options). There is a &quot;hints&quot; file for os390 that specifies the correct values for most things. Some things to watch out for include:</source>
          <target state="translated">ディストリビューションを解凍したら、&quot;sh Configure &quot;を実行してください。os390 用の &quot;hints&quot; ファイルがあり、ほとんどのものに正しい値を指定しています。注意すべき点としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="db5c3d0411160491df177efaf9a707107fc6ab38" translate="yes" xml:space="preserve">
          <source>Once your extension is complete and passes all its tests, installing it is quite simple: you simply run &quot;make install&quot;. You will either need to have write permission into the directories where Perl is installed, or ask your system administrator to run the make for you.</source>
          <target state="translated">拡張機能が完成し、すべてのテストに合格したら、インストールは非常に簡単です。Perl がインストールされているディレクトリへの書き込み権限を持つか、システム管理者に make を実行してもらう必要があります。</target>
        </trans-unit>
        <trans-unit id="4f49dbc375a0394fd3dd511b9f8226cfef74fa93" translate="yes" xml:space="preserve">
          <source>One additional translation is performed: instead of</source>
          <target state="translated">1つの追加翻訳が行われます。</target>
        </trans-unit>
        <trans-unit id="ec03014fcac8a461acd2bab0b3f3f4c4647a9956" translate="yes" xml:space="preserve">
          <source>One area where there has been conflict is in regards to C locales. (See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.) perl, with one exception and unless told otherwise, sets up the underlying locale the program is running in to the locale passed into it from the environment. This is an important difference from a generic C language program, where the underlying locale is the &quot;C&quot; locale unless the program changes it. As of v5.20, this underlying locale is completely hidden from pure Perl code outside the lexical scope of &lt;code&gt;use locale&lt;/code&gt; except for a couple of function calls in the POSIX module which of necessity use it. But the underlying locale, with that one exception is exposed to XS code, affecting all C library routines whose behavior is locale-dependent. Your XS code better not assume that the underlying locale is &quot;C&quot;. The exception is the &lt;a href=&quot;perllocale#Category-LC_NUMERIC%3A-Numeric-Formatting&quot;&gt;&lt;code&gt;LC_NUMERIC&lt;/code&gt;&lt;/a&gt; locale category, and the reason it is an exception is that experience has shown that it can be problematic for XS code, whereas we have not had reports of problems with the &lt;a href=&quot;perllocale#WHAT-IS-A-LOCALE&quot;&gt;other locale categories&lt;/a&gt;. And the reason for this one category being problematic is that the character used as a decimal point can vary. Many European languages use a comma, whereas English, and hence Perl are expecting a dot (U+002E: FULL STOP). Many modules can handle only the radix character being a dot, and so perl attempts to make it so. Up through Perl v5.20, the attempt was merely to set &lt;code&gt;LC_NUMERIC&lt;/code&gt; upon startup to the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale. Any &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt; otherwise would change it; this caused some failures. Therefore, starting in v5.22, perl tries to keep &lt;code&gt;LC_NUMERIC&lt;/code&gt; always set to &lt;code&gt;&quot;C&quot;&lt;/code&gt; for XS code.</source>
          <target state="translated">競合が発生した領域の1つは、Cロケールに関するものです。 （&lt;a href=&quot;perllocale&quot;&gt;perllocaleを&lt;/a&gt;参照してください。）perlは、1つの例外を除き、特に明記されていない限り、プログラムが実行されている基になるロケールを、環境から渡されたロケールに設定します。これは、プログラムが変更しない限り、基になるロケールが「C」ロケールである一般的なC言語プログラムとの重要な違いです。 v5.20以降、この基になるロケールは、 &lt;code&gt;use locale&lt;/code&gt; 字句スコープ外の純粋なPerlコードから完全に隠されています。必然的にそれを使用するPOSIXモジュールのいくつかの関数呼び出しを除いて。ただし、基になるロケールは、その1つの例外を除いて、XSコードに公開され、動作がロケールに依存するすべてのCライブラリルーチンに影響を与えます。 XSコードは、基礎となるロケールが「C」であると想定しない方がよいでしょう。例外は&lt;a href=&quot;perllocale#Category-LC_NUMERIC%3A-Numeric-Formatting&quot;&gt; &lt;code&gt;LC_NUMERIC&lt;/code&gt; &lt;/a&gt;ロケールカテゴリであり、例外である理由は、&lt;a href=&quot;perllocale#WHAT-IS-A-LOCALE&quot;&gt;他のロケールカテゴリ&lt;/a&gt;で問題が発生したという報告はないのに対し、XSコードでは問題が発生する可能性があることを経験が示しているためです。。そして、この1つのカテゴリが問題になる理由は、小数点として使用される文字が異なる可能性があるためです。多くのヨーロッパ言語はコンマを使用しますが、英語、したがってPerlはドットを期待しています（U + 002E：終止符）。多くのモジュールは、ドットである基数文字のみを処理できるため、perlはそれを実行しようとします。 Perl v5.20までは、起動時に &lt;code&gt;LC_NUMERIC&lt;/code&gt; を &lt;code&gt;&quot;C&quot;&lt;/code&gt; ロケールに設定するだけでした。任意&lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;のsetlocale（）&lt;/a&gt;それ以外の場合は、それを変更します。これはいくつかの失敗を引き起こしました。したがって、v5.22以降、perlはXSコードに対して &lt;code&gt;LC_NUMERIC&lt;/code&gt; を常に &lt;code&gt;&quot;C&quot;&lt;/code&gt; 設定したままにしようとします。</target>
        </trans-unit>
        <trans-unit id="a68ac543ed261e894527754904db5e74312dfaac" translate="yes" xml:space="preserve">
          <source>One area where there has been conflict is in regards to C locales. (See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.) perl, with one exception and unless told otherwise, sets up the underlying locale the program is running in to the locale passed into it from the environment. This is an important difference from a generic C language program, where the underlying locale is the &quot;C&quot; locale unless the program changes it. As of v5.20, this underlying locale is completely hidden from pure perl code outside the lexical scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; except for a couple of function calls in the POSIX module which of necessity use it. But the underlying locale, with that one exception is exposed to XS code, affecting all C library routines whose behavior is locale-dependent. Your XS code better not assume that the underlying locale is &quot;C&quot;. The exception is the &lt;a href=&quot;perllocale#Category-LC_NUMERIC%3a-Numeric-Formatting&quot;&gt;LC_NUMERIC &lt;/a&gt; locale category, and the reason it is an exception is that experience has shown that it can be problematic for XS code, whereas we have not had reports of problems with the &lt;a href=&quot;perllocale#WHAT-IS-A-LOCALE&quot;&gt;other locale categories&lt;/a&gt;. And the reason for this one category being problematic is that the character used as a decimal point can vary. Many European languages use a comma, whereas English, and hence Perl are expecting a dot (U+002E: FULL STOP). Many modules can handle only the radix character being a dot, and so perl attempts to make it so. Up through Perl v5.20, the attempt was merely to set &lt;code&gt;LC_NUMERIC&lt;/code&gt; upon startup to the &lt;code&gt;&quot;C&quot;&lt;/code&gt; locale. Any &lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;setlocale()&lt;/a&gt; otherwise would change it; this caused some failures. Therefore, starting in v5.22, perl tries to keep &lt;code&gt;LC_NUMERIC&lt;/code&gt; always set to &lt;code&gt;&quot;C&quot;&lt;/code&gt; for XS code.</source>
          <target state="translated">競合が発生した領域の1つは、Cロケールに関するものです。 （&lt;a href=&quot;perllocale&quot;&gt;perllocaleを&lt;/a&gt;参照してください。）perlは、1つの例外を除き、特に指示がない限り、プログラムが実行されている基本ロケールを、環境から渡されたロケールに設定します。これは、プログラムが変更しない限り、基になるロケールが「C」ロケールである一般的なC言語プログラムとの重要な違いです。 v5.20以降、この基礎となるロケールは、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ロケールの字句範囲外の純粋なperlコードから完全に隠されています。POSIXモジュール内で必要ないくつかの関数呼び出しを除いて。ただし、基になるロケールは、1つの例外がXSコードに公開されており、動作がロケールに依存するすべてのCライブラリルーチンに影響します。 XSコードは、基礎となるロケールが「C」であると想定しない方がよいでしょう。例外は&lt;a href=&quot;perllocale#Category-LC_NUMERIC%3a-Numeric-Formatting&quot;&gt;LC_NUMERIC&lt;/a&gt;ロケールカテゴリであり、それが例外である理由は、&lt;a href=&quot;perllocale#WHAT-IS-A-LOCALE&quot;&gt;他のロケールカテゴリ&lt;/a&gt;に関する問題の報告はありませんでしたが、経験からXSコードに問題がある可能性があることが示されているためです。この1つのカテゴリに問題があるのは、小数点として使用される文字が異なる可能性があるためです。多くのヨーロッパ言語はコンマを使用しますが、英語、したがってPerlはドット（U + 002E：FULL STOP）を期待しています。多くのモジュールはドットである基数文字のみを処理できるため、perlはそれを作成しようとします。 Perl v5.20までは、起動時に &lt;code&gt;LC_NUMERIC&lt;/code&gt; を &lt;code&gt;&quot;C&quot;&lt;/code&gt; ロケールに設定するだけでした。任意&lt;a href=&quot;perllocale#The-setlocale-function&quot;&gt;のsetlocale（）&lt;/a&gt;それ以外の場合は、それを変更します。これにより、いくつかの障害が発生しました。したがって、v5.22以降、perlは &lt;code&gt;LC_NUMERIC&lt;/code&gt; をXSコードの &lt;code&gt;&quot;C&quot;&lt;/code&gt; 常に設定したままにしようとします。</target>
        </trans-unit>
        <trans-unit id="6b3b34651f404f7056a8a03b94a1667665687e73" translate="yes" xml:space="preserve">
          <source>One big difference between ASCII-based character sets and EBCDIC ones are the relative positions of the characters when sorted in native order. Of most concern are the upper- and lowercase letters, the digits, and the underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt; ). On ASCII platforms the native sort order has the digits come before the uppercase letters which come before the underscore which comes before the lowercase letters. On EBCDIC, the underscore comes first, then the lowercase letters, then the uppercase ones, and the digits last. If sorted on an ASCII-based platform, the two-letter abbreviation for a physician comes before the two letter abbreviation for drive; that is:</source>
          <target state="translated">ASCIIベースの文字セットとEBCDICの文字セットの大きな違いの1つは、ネイティブの順序でソートした場合の文字の相対的な位置です。最も重要なのは、大文字と小文字、数字、およびアンダースコア（ &lt;code&gt;&quot;_&quot;&lt;/code&gt; ）です。ASCIIプラットフォームでは、ネイティブの並べ替え順序では、数字が小文字の前にあるアンダースコアの前にある大文字の前にあります。EBCDICでは、下線が最初に来て、次に小文字、次に大文字が続き、数字が最後になります。ASCIIベースのプラットフォームでソートした場合、医師の2文字の略語は、ドライブの2文字の略語の前に来ます。あれは：</target>
        </trans-unit>
        <trans-unit id="4d27487c78325597c40568b8011491df0ed50a95" translate="yes" xml:space="preserve">
          <source>One big difference between ASCII-based character sets and EBCDIC ones are the relative positions of the characters when sorted in native order. Of most concern are the upper- and lowercase letters, the digits, and the underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt;). On ASCII platforms the native sort order has the digits come before the uppercase letters which come before the underscore which comes before the lowercase letters. On EBCDIC, the underscore comes first, then the lowercase letters, then the uppercase ones, and the digits last. If sorted on an ASCII-based platform, the two-letter abbreviation for a physician comes before the two letter abbreviation for drive; that is:</source>
          <target state="translated">ASCIIベースの文字セットとEBCDIC文字セットの大きな違いの1つは、ネイティブの順序でソートされたときの文字の相対位置です。最も懸念されるのは、大文字と小文字、数字、およびアンダースコア（ &lt;code&gt;&quot;_&quot;&lt;/code&gt; ）です。ASCIIプラットフォームでは、ネイティブの並べ替え順序では、小文字の前にあるアンダースコアの前にある大文字の前に数字があります。EBCDICでは、アンダースコアが最初に来て、次に小文字、次に大文字、そして数字が最後になります。ASCIIベースのプラットフォームでソートする場合、医師の2文字の略語は、ドライブの2文字の略語の前になります。あれは：</target>
        </trans-unit>
        <trans-unit id="a63660a2be4a88226e8e69f57c474e97932c916a" translate="yes" xml:space="preserve">
          <source>One can also use &quot;short&quot; names:</source>
          <target state="translated">1つは「短い」名前を使うこともできます。</target>
        </trans-unit>
        <trans-unit id="577442f1eff045466125f84e1aef5d482722c146" translate="yes" xml:space="preserve">
          <source>One can always start</source>
          <target state="translated">始まってもおかしくない</target>
        </trans-unit>
        <trans-unit id="29c09e61bbeafec8533e6d27dfc8a923e0fca57d" translate="yes" xml:space="preserve">
          <source>One can build perl with thread support enabled by providing &lt;code&gt;-D usethreads&lt;/code&gt; option to</source>
          <target state="translated">&lt;code&gt;-D usethreads&lt;/code&gt; オプションを提供して、スレッドサポートを有効にしてperlを構築できます。</target>
        </trans-unit>
        <trans-unit id="359cf3d8d5555fb74ca7adc2fbcedf983680dde4" translate="yes" xml:space="preserve">
          <source>One can change the output file handle of the messages by setting $Getopt::Std::OUTPUT_HELP_VERSION. One can print the messages of &lt;code&gt;--help&lt;/code&gt; (without the &lt;code&gt;Usage:&lt;/code&gt; line) and &lt;code&gt;--version&lt;/code&gt; by calling functions help_mess() and version_mess() with the switches string as an argument.</source>
          <target state="translated">$ Getopt :: Std :: OUTPUT_HELP_VERSIONを設定することで、メッセージの出力ファイルハンドルを変更できます。スイッチの文字列を引数として関数help_mess（）およびversion_mess（）を呼び出すことにより、 &lt;code&gt;--help&lt;/code&gt; （ &lt;code&gt;Usage:&lt;/code&gt; 行なし）および &lt;code&gt;--version&lt;/code&gt; のメッセージを出力できます。</target>
        </trans-unit>
        <trans-unit id="d414d38c04c2c09cb11f7d028ae1e652935790fa" translate="yes" xml:space="preserve">
          <source>One can check whether the currently loaded ReadLine package supports these methods by checking for corresponding &lt;code&gt;Features&lt;/code&gt; .</source>
          <target state="translated">現在ロードされているReadLineパッケージがこれらのメソッドをサポートしているかどうかを確認するには、対応する &lt;code&gt;Features&lt;/code&gt; を確認します。</target>
        </trans-unit>
        <trans-unit id="0c393381162c37f504c3308b016602c8a38b83d3" translate="yes" xml:space="preserve">
          <source>One can check whether the currently loaded ReadLine package supports these methods by checking for corresponding &lt;code&gt;Features&lt;/code&gt;.</source>
          <target state="translated">対応する &lt;code&gt;Features&lt;/code&gt; をチェックすることで、現在ロードされているReadLineパッケージがこれらのメソッドをサポートしているかどうかをチェックできます。</target>
        </trans-unit>
        <trans-unit id="db862b22399f31abaed4d1d2c6d6ed9c25d9c230" translate="yes" xml:space="preserve">
          <source>One can circumnavigate both these problems in two ways. Either transfer and store numbers always in text format, instead of raw binary, or else consider using modules like &lt;a href=&quot;Data::Dumper&quot;&gt;&lt;code&gt;Data::Dumper&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;storable&quot;&gt;&lt;code&gt;Storable&lt;/code&gt;&lt;/a&gt; (included as of Perl 5.8). Keeping all data as text significantly simplifies matters.</source>
          <target state="translated">これらの問題は2つの方法で回避できます。数値を生のバイナリではなく常にテキスト形式で転送および保存するか、&lt;a href=&quot;Data::Dumper&quot;&gt; &lt;code&gt;Data::Dumper&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;storable&quot;&gt; &lt;code&gt;Storable&lt;/code&gt; &lt;/a&gt;やStorable（Perl 5.8以降に含まれている）などのモジュールの使用を検討してください。すべてのデータをテキストとして保持すると、問題が大幅に簡素化されます。</target>
        </trans-unit>
        <trans-unit id="c198d2cf41321cd565d4f52242fa64736d1a9f4a" translate="yes" xml:space="preserve">
          <source>One can circumnavigate both these problems in two ways. Either transfer and store numbers always in text format, instead of raw binary, or else consider using modules like &lt;code&gt;Data::Dumper&lt;/code&gt; and &lt;code&gt;Storable&lt;/code&gt; (included as of Perl 5.8). Keeping all data as text significantly simplifies matters.</source>
          <target state="translated">これらの問題を2つの方法で回避することができます。数値を未加工のバイナリではなく常にテキスト形式で転送して保存するか、 &lt;code&gt;Data::Dumper&lt;/code&gt; &lt;code&gt;Storable&lt;/code&gt; やStorable（Perl 5.8に含まれる）などのモジュールの使用を検討してください。すべてのデータをテキストとして保持すると、問題が大幅に簡素化されます。</target>
        </trans-unit>
        <trans-unit id="09119ba09b711474d1016a03da12b7c5aabeff6a" translate="yes" xml:space="preserve">
          <source>One can get RSX from, say</source>
          <target state="translated">からRSXを取得することができます。</target>
        </trans-unit>
        <trans-unit id="fc1d1f2f775a433521e449135abda7dc4b545354" translate="yes" xml:space="preserve">
          <source>One can get different parts of EMX from, say</source>
          <target state="translated">EMX の異なる部分は、例えば</target>
        </trans-unit>
        <trans-unit id="b1f6c95529bb8b413cce8749a9949bb156c89f7b" translate="yes" xml:space="preserve">
          <source>One can have Unicode in identifier names, but not in package/class or subroutine names. While some limited functionality towards this does exist as of Perl 5.8.0, that is more accidental than designed; use of Unicode for the said purposes is unsupported.</source>
          <target state="translated">識別子名には Unicode を持つことができますが、パッケージ/クラスやサブルーチン名には Unicode を持つことはできません。Perl 5.8.0 の時点では、これに対する限定的な機能は存在していますが、これは設計されたものというよりも偶然のものです。</target>
        </trans-unit>
        <trans-unit id="419250bbe62537b6d8975e14166ba62003b501d4" translate="yes" xml:space="preserve">
          <source>One can read this document in the following formats:</source>
          <target state="translated">この文書は以下の形式で読むことができます。</target>
        </trans-unit>
        <trans-unit id="6893de36816aebf716cd1fd72a1de7d9c51768bf" translate="yes" xml:space="preserve">
          <source>One can replace a numeric repeat count with a template letter enclosed in brackets to use the packed byte length of the bracketed template for the repeat count.</source>
          <target state="translated">数値のリピートカウントを括弧で囲まれたテンプレート文字に置き換えることで、括弧で囲まれたテンプレートのパックされたバイト長をリピートカウントに使用することができます。</target>
        </trans-unit>
        <trans-unit id="05782b074320e38eef954451f657efc4b11fa74a" translate="yes" xml:space="preserve">
          <source>One case that this does not handle is a gv without SvFAKE set. After</source>
          <target state="translated">これでは扱えないケースとして、SvFAKEが設定されていないgvがあります。の後に</target>
        </trans-unit>
        <trans-unit id="702f5c0458dfb1f9b9fa361a8264610e99c16724" translate="yes" xml:space="preserve">
          <source>One common debugging approach here, would be to liberally sprinkle a few print statements, to add a check just before we print out our data, and another just after:</source>
          <target state="translated">ここでの一般的なデバッグ方法は、いくつかのprint文を自由に散りばめて、データをプリントアウトする直前にチェックを加え、直後に別のチェックを加えることです。</target>
        </trans-unit>
        <trans-unit id="38e71844bc36e8f5a99e4a47f54b762cb30af6e8" translate="yes" xml:space="preserve">
          <source>One common mistake when using this port with a GUI library like &lt;code&gt;Tk&lt;/code&gt; is assuming that Perl's normal behavior of opening a command-line window will go away. This isn't the case. If you want to start a copy of &lt;code&gt;perl&lt;/code&gt; without opening a command-line window, use the &lt;code&gt;wperl&lt;/code&gt; executable built during the installation process. Usage is exactly the same as normal &lt;code&gt;perl&lt;/code&gt; on Windows, except that options like &lt;code&gt;-h&lt;/code&gt; don't work (since they need a command-line window to print to).</source>
          <target state="translated">&lt;code&gt;Tk&lt;/code&gt; のようなGUIライブラリでこのポートを使用する際の1つのよくある間違いは、コマンドラインウィンドウを開くPerlの通常の動作がなくなることを想定しています。これは事実ではありません。コマンドラインウィンドウを開かずに &lt;code&gt;perl&lt;/code&gt; のコピーを開始する場合は、インストールプロセス中にビルドされた &lt;code&gt;wperl&lt;/code&gt; 実行可能ファイルを使用します。使用法は、 &lt;code&gt;-h&lt;/code&gt; のようなオプションが機能しないことを除いて、Windowsの通常の &lt;code&gt;perl&lt;/code&gt; とまったく同じです（出力先にコマンドラインウィンドウが必要なため）。</target>
        </trans-unit>
        <trans-unit id="8a4117118bb75dbafb375915c27d62ebe634dd07" translate="yes" xml:space="preserve">
          <source>One conveys this info to &lt;b&gt;xsubpp&lt;/b&gt; by replacing &lt;code&gt;*&lt;/code&gt; before the argument by &lt;code&gt;&amp;amp;&lt;/code&gt; . &lt;code&gt;&amp;amp;&lt;/code&gt; means that the argument should be passed to a library function by its address. The above two function may be XSUB-ified as</source>
          <target state="translated">引数の前の &lt;code&gt;*&lt;/code&gt; を &lt;code&gt;&amp;amp;&lt;/code&gt; に置き換えることにより、この情報を&lt;b&gt;xsubppに&lt;/b&gt;伝えます。 &lt;code&gt;&amp;amp;&lt;/code&gt; は、引数がそのアドレスによってライブラリ関数に渡されることを意味します。上記の2つの関数は、次のようにXSUB化できます。</target>
        </trans-unit>
        <trans-unit id="fcbea60b30cb68b4498f395be71fe8caca1d66b2" translate="yes" xml:space="preserve">
          <source>One conveys this info to &lt;b&gt;xsubpp&lt;/b&gt; by replacing &lt;code&gt;*&lt;/code&gt; before the argument by &lt;code&gt;&amp;amp;&lt;/code&gt;. &lt;code&gt;&amp;amp;&lt;/code&gt; means that the argument should be passed to a library function by its address. The above two function may be XSUB-ified as</source>
          <target state="translated">引数の前の &lt;code&gt;*&lt;/code&gt; を &lt;code&gt;&amp;amp;&lt;/code&gt; に置き換えることで、この情報を&lt;b&gt;xsubppに&lt;/b&gt;伝えます。 &lt;code&gt;&amp;amp;&lt;/code&gt; は、引数をそのアドレスでライブラリ関数に渡す必要があることを意味します。上記の2つの関数は、次のようにXSUB化できます。</target>
        </trans-unit>
        <trans-unit id="d10907c81f2d55151091ac660924f2a1e254db78" translate="yes" xml:space="preserve">
          <source>One could use this to create subclasses of &lt;b&gt;Pod::Paragraphs&lt;/b&gt; and &lt;b&gt;Pod::InteriorSequences&lt;/b&gt; for specific commands (or to create your own custom node-types in the parse-tree) and add some kind of &lt;b&gt;emit()&lt;/b&gt; method to each custom node/subclass object in the tree. Then all you'd need to do is recursively walk the tree in the desired order, processing the children (most likely from left to right) by formatting them if they are text-strings, or by calling their &lt;b&gt;emit()&lt;/b&gt; method if they are objects/references.</source>
          <target state="translated">これを使用して、特定のコマンド用の&lt;b&gt;Pod :: Paragraphs&lt;/b&gt;および&lt;b&gt;Pod :: InteriorSequencesの&lt;/b&gt;サブクラスを作成する（または解析ツリーに独自のカスタムノードタイプを作成する&lt;b&gt;）&lt;/b&gt;ことができ、各カスタムノードに何らかの種類の&lt;b&gt;emit（）&lt;/b&gt;メソッドを追加します/ツリー内のサブクラスオブジェクト。次に、必要なことは、ツリーを目的の順序で再帰的にウォークし、テキスト文字列の場合はフォーマットして、（場合によっては左から右に）子を処理するか、子の場合は自分の&lt;b&gt;emit（）&lt;/b&gt;メソッドを呼び出すだけです。オブジェクト/参照。</target>
        </trans-unit>
        <trans-unit id="d5d134d4ce2691a8fd3e620efdc0c0a7dc96f2ab" translate="yes" xml:space="preserve">
          <source>One counterpart, in the column labelled &quot;ASCII-range Unicode&quot; in the table, matches only characters in the ASCII character set.</source>
          <target state="translated">表中の「ASCII-range Unicode」と書かれた列の中には、ASCII文字セット内の文字のみにマッチするものがあります。</target>
        </trans-unit>
        <trans-unit id="e759a7518c2a7615eb212a5b5c617930b5079aa4" translate="yes" xml:space="preserve">
          <source>One especially common bit of Perl code is opening a pipe to &lt;b&gt;sendmail&lt;/b&gt;:</source>
          <target state="translated">Perlコードの特に一般的なビットの1つは、&lt;b&gt;sendmail&lt;/b&gt;へのパイプを開くことです。</target>
        </trans-unit>
        <trans-unit id="42325abeeacce413a34de5a75512b4be08cb249a" translate="yes" xml:space="preserve">
          <source>One example module, &lt;a href=&quot;PerlIO::via::QuotedPrint&quot;&gt;PerlIO::via::QuotedPrint&lt;/a&gt;, is included with Perl 5.8.0, and more example modules are available from CPAN, such as &lt;a href=&quot;PerlIO::via::StripHTML&quot;&gt;PerlIO::via::StripHTML&lt;/a&gt; and &lt;a href=&quot;PerlIO::via::Base64&quot;&gt;PerlIO::via::Base64&lt;/a&gt;. The PerlIO::via::StripHTML module for instance, allows you to say:</source>
          <target state="translated">1つのサンプルモジュール&lt;a href=&quot;PerlIO::via::QuotedPrint&quot;&gt;PerlIO :: via :: QuotedPrint&lt;/a&gt;は、Perl 5.8.0に含まれており、&lt;a href=&quot;PerlIO::via::StripHTML&quot;&gt;PerlIO :: via :: StripHTML&lt;/a&gt;や&lt;a href=&quot;PerlIO::via::Base64&quot;&gt;PerlIO :: via :: Base64&lt;/a&gt;など、より多くのサンプルモジュールがCPANから入手できます。たとえば、PerlIO :: via :: StripHTMLモジュールでは、次のように言うことができます。</target>
        </trans-unit>
        <trans-unit id="6006eb32ad88f65a8e3a677b12b70bf0c21cd44a" translate="yes" xml:space="preserve">
          <source>One example module, &lt;a href=&quot;via/quotedprint&quot;&gt;PerlIO::via::QuotedPrint&lt;/a&gt;, is included with Perl 5.8.0, and more example modules are available from CPAN, such as &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::StripHTML&quot;&gt;PerlIO::via::StripHTML&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::Base64&quot;&gt;PerlIO::via::Base64&lt;/a&gt;. The PerlIO::via::StripHTML module for instance, allows you to say:</source>
          <target state="translated">1つのサンプルモジュール&lt;a href=&quot;via/quotedprint&quot;&gt;PerlIO :: via :: QuotedPrint&lt;/a&gt;がPerl 5.8.0に含まれており、&lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::StripHTML&quot;&gt;PerlIO :: via :: StripHTML&lt;/a&gt;や&lt;a href=&quot;http://search.cpan.org/perldoc/PerlIO::via::Base64&quot;&gt;PerlIO :: via :: Base64&lt;/a&gt;などのより多くのサンプルモジュールがCPANから入手できます。たとえば、PerlIO :: via :: StripHTMLモジュールを使用すると、次のように言うことができます。</target>
        </trans-unit>
        <trans-unit id="5ffc602a59cde7db4cddb26183a3140b07c9e1e7" translate="yes" xml:space="preserve">
          <source>One exception is the default scalar variable: starting with perl 5.14 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local($_)&lt;/a&gt;&lt;/code&gt; will always strip all magic from $_, to make it possible to safely reuse $_ in a subroutine.</source>
          <target state="translated">1つの例外はデフォルトのスカラー変数です。perl5.14 &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local($_)&lt;/a&gt;&lt;/code&gt; は、$ _からすべてのマジックが常に削除され、サブルーチンで$ _を安全に再利用できるようになります。</target>
        </trans-unit>
        <trans-unit id="dd6c9b4252819413fc14053d624bb7bb0e0b2769" translate="yes" xml:space="preserve">
          <source>One exception is the default scalar variable: starting with perl 5.14 &lt;code&gt;local($_)&lt;/code&gt; will always strip all magic from $_, to make it possible to safely reuse $_ in a subroutine.</source>
          <target state="translated">1つの例外は、デフォルトのスカラー変数です。perl5.14以降、 &lt;code&gt;local($_)&lt;/code&gt; は常に$ _からすべての魔法を取り除き、サブルーチンで$ _を安全に再利用できるようにします。</target>
        </trans-unit>
        <trans-unit id="08b4b3fb221020ddd9f00f023bbae8ca4cbaad9d" translate="yes" xml:space="preserve">
          <source>One facility, one priority.</source>
          <target state="translated">1つの施設、1つの優先順位。</target>
        </trans-unit>
        <trans-unit id="c1af03124d01c283a40e813bb6152573293c3a58" translate="yes" xml:space="preserve">
          <source>One final point -- obviously &lt;code&gt;InputLength&lt;/code&gt; can only be used whenever you know the length of the compressed data beforehand, like here with a zip file.</source>
          <target state="translated">最後のポイント-明らかに &lt;code&gt;InputLength&lt;/code&gt; は、ここでzipファイルを使用する場合のように、圧縮データの長さが事前にわかっている場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="8aecc974b0a5e7d4fdcb37dff6e7916eb87115e6" translate="yes" xml:space="preserve">
          <source>One form, available starting in Perl 5.14 looks like &lt;code&gt;\o{...}&lt;/code&gt; , where the dots represent one or more octal digits. It can be used for any Unicode character.</source>
          <target state="translated">Perl 5.14から利用できる1つの形式は &lt;code&gt;\o{...}&lt;/code&gt; になり、ドットは1つ以上の8進数を表します。任意のUnicode文字に使用できます。</target>
        </trans-unit>
        <trans-unit id="6706d7cc152004a9fcc100843796f293fa434aa5" translate="yes" xml:space="preserve">
          <source>One form, available starting in Perl 5.14 looks like &lt;code&gt;\o{...}&lt;/code&gt;, where the dots represent one or more octal digits. It can be used for any Unicode character.</source>
          <target state="translated">Perl 5.14以降で利用可能な1つの形式は、 &lt;code&gt;\o{...}&lt;/code&gt; になり、ドットは1つ以上の8進数を表します。任意のUnicode文字に使用できます。</target>
        </trans-unit>
        <trans-unit id="322c61ed78983eea548dac2ca0c0f3a32df9d886" translate="yes" xml:space="preserve">
          <source>One generally uses it like so:</source>
          <target state="translated">1つは、一般的にはこのように使用します。</target>
        </trans-unit>
        <trans-unit id="5328aa4f92833315a7e49e7973d7b5d5df515277" translate="yes" xml:space="preserve">
          <source>One good reason is when you already have an existing application written in another language that's all done (and done well), or you have an application language specifically designed for a certain task (e.g. prolog, make).</source>
          <target state="translated">1つの良い理由は、すでに他の言語で書かれた既存のアプリケーションがあって、それがすべて完了している場合(うまくいっている場合)や、特定のタスクのために特別に設計されたアプリケーション言語(例:prolog,make)を持っている場合です。</target>
        </trans-unit>
        <trans-unit id="5181341efe5d191b40c7bb4f79e039f1b83f3ecd" translate="yes" xml:space="preserve">
          <source>One last thing before we show you how to open files: opening files does not (usually) automatically lock them in Perl. See &lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt; for how to lock.</source>
          <target state="translated">ファイルを開く方法を説明する前に最後にもう1つ、ファイルを開いても（通常は）Perlで自動的にロックされません。ロックする方法については&lt;a href=&quot;perlfaq5&quot;&gt;perlfaq5&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b7d0dbf83cb5d86dbb1f5f3433c118dbdc75390f" translate="yes" xml:space="preserve">
          <source>One level of double-quote interpretation is done first, but you can't say &lt;code&gt;&amp;lt;$foo&amp;gt;&lt;/code&gt; because that's an indirect filehandle as explained in the previous paragraph. (In older versions of Perl, programmers would insert curly brackets to force interpretation as a filename glob: &lt;code&gt;&amp;lt;${foo}&amp;gt;&lt;/code&gt; . These days, it's considered cleaner to call the internal function directly as &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob($foo)&lt;/a&gt;&lt;/code&gt;, which is probably the right way to have done it in the first place.) For example:</source>
          <target state="translated">1つのレベルの二重引用符の解釈が最初に行われますが、 &lt;code&gt;&amp;lt;$foo&amp;gt;&lt;/code&gt; は前の段落で説明したように間接的なファイルハンドルであるため、言うことはできません。（Perlの古いバージョンでは、プログラマは、ファイル名のグロブとして力解釈に中括弧を挿入します： &lt;code&gt;&amp;lt;${foo}&amp;gt;&lt;/code&gt; 。これらの日、直接として内部関数を呼び出すためにクリーナーと考えられています &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob($foo)&lt;/a&gt;&lt;/code&gt; はおそらくです、そもそもそれを行う正しい方法です。）例：</target>
        </trans-unit>
        <trans-unit id="c5cfad95a16b5735e117bc2fe294d5a66682c4eb" translate="yes" xml:space="preserve">
          <source>One level of double-quote interpretation is done first, but you can't say &lt;code&gt;&amp;lt;$foo&amp;gt;&lt;/code&gt; because that's an indirect filehandle as explained in the previous paragraph. (In older versions of Perl, programmers would insert curly brackets to force interpretation as a filename glob: &lt;code&gt;&amp;lt;${foo}&amp;gt;&lt;/code&gt;. These days, it's considered cleaner to call the internal function directly as &lt;code&gt;glob($foo)&lt;/code&gt;, which is probably the right way to have done it in the first place.) For example:</source>
          <target state="translated">最初に1レベルの二重引用符の解釈が行われますが、前の段落で説明したように、これは間接ファイルハンドルであるため、 &lt;code&gt;&amp;lt;$foo&amp;gt;&lt;/code&gt; とは言えません。（Perlの古いバージョンでは、プログラマは、ファイル名のグロブとして力解釈に中括弧を挿入します： &lt;code&gt;&amp;lt;${foo}&amp;gt;&lt;/code&gt; 。これらの日、直接として内部関数を呼び出すためにクリーナーと考えられています &lt;code&gt;glob($foo)&lt;/code&gt; はおそらくです、そもそもそれを行う正しい方法です。）例：</target>
        </trans-unit>
        <trans-unit id="cb3729bf6ea691a9592670464973a67c30ec7dce" translate="yes" xml:space="preserve">
          <source>One line description of the module. Will be included in PPD file.</source>
          <target state="translated">モジュールの説明を一行で記述します。PPDファイルに含まれます。</target>
        </trans-unit>
        <trans-unit id="812bfff50b3cdd6b1a9ee7ea09cf72b33f18f12d" translate="yes" xml:space="preserve">
          <source>One log at a time.</source>
          <target state="translated">一度に一本のログ。</target>
        </trans-unit>
        <trans-unit id="283b267b63bd1be649ecf96f103c3d06603de13e" translate="yes" xml:space="preserve">
          <source>One macro controls the major Perl build flavor: MULTIPLICITY. The MULTIPLICITY build has a C structure that packages all the interpreter state. With multiplicity-enabled perls, PERL_IMPLICIT_CONTEXT is also normally defined, and enables the support for passing in a &quot;hidden&quot; first argument that represents all three data structures. MULTIPLICITY makes multi-threaded perls possible (with the ithreads threading model, related to the macro USE_ITHREADS.)</source>
          <target state="translated">1つのマクロでPerlの主要なビルドフレーバーを制御します。MULTIPLICITYです。MULTIPLICITY ビルドは、すべてのインタプリタの状態をパッケージ化する C 構造を持っています。マルチプライシティ対応のPerlでは、PERL_IMPLICIT_CONTEXTも通常定義されており、3つのデータ構造をすべて表す &quot;隠された &quot;第1引数を渡すサポートを可能にしています。MULTIPLICITYは、マルチスレッドperlsを可能にします(ITHREADS スレッドモデルを使用して、マクロUSE_ITHREADSに関連します)。</target>
        </trans-unit>
        <trans-unit id="d690e728f490966c2e852c98cb2c60fa0b1d2fcd" translate="yes" xml:space="preserve">
          <source>One may also use pod directives to quickly comment out a section of code.</source>
          <target state="translated">また、コードのセクションを素早くコメントアウトするために pod ディレクティブを使うこともできます。</target>
        </trans-unit>
        <trans-unit id="9dbb00f26b5f18e0abff366f4de58cbb31829dd9" translate="yes" xml:space="preserve">
          <source>One may wonder why we call the above calculator symbolic. The reason is that the actual calculation of the value of expression is postponed until the value is</source>
          <target state="translated">なぜ上記の計算機を記号的と呼ぶのか、不思議に思う人もいるかもしれません。それは、式の値を実際に計算するのは、その値が</target>
        </trans-unit>
        <trans-unit id="bf00ffa0a786e25adb9ef6ba76b09b1f7cf9677e" translate="yes" xml:space="preserve">
          <source>One might initially guess that Perl would find the &lt;code&gt;at&lt;/code&gt; in &lt;code&gt;cat&lt;/code&gt; and stop there, but that wouldn't give the longest possible string to the first quantifier &lt;code&gt;.*&lt;/code&gt;. Instead, the first quantifier &lt;code&gt;.*&lt;/code&gt; grabs as much of the string as possible while still having the regexp match. In this example, that means having the &lt;code&gt;at&lt;/code&gt; sequence with the final &lt;code&gt;at&lt;/code&gt; in the string. The other important principle illustrated here is that, when there are two or more elements in a regexp, the</source>
          <target state="translated">Perlが &lt;code&gt;at&lt;/code&gt; を &lt;code&gt;cat&lt;/code&gt; で見つけてそこで停止すると最初に推測するかもしれませんが、それでは最初の量指定子 &lt;code&gt;.*&lt;/code&gt; 可能な限り長い文字列は与えられません。代わりに、最初の量指定子 &lt;code&gt;.*&lt;/code&gt; は、正規表現の一致を維持しながら、できるだけ多くの文字列を取得します。この例では、それは文字列の最後に &lt;code&gt;at&lt;/code&gt; がある &lt;code&gt;at&lt;/code&gt; シーケンスを持つことを意味します。ここに示されている他の重要な原則は、正規表現に2つ以上の要素がある場合、</target>
        </trans-unit>
        <trans-unit id="3150bc5b7154ac86649428809493c4398ced1ef5" translate="yes" xml:space="preserve">
          <source>One might think that &lt;code&gt;\s&lt;/code&gt; is equivalent to &lt;code&gt;[\h\v]&lt;/code&gt; . This is indeed true starting in Perl v5.18, but prior to that, the sole difference was that the vertical tab (&lt;code&gt;&quot;\cK&quot;&lt;/code&gt; ) was not matched by &lt;code&gt;\s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; は &lt;code&gt;[\h\v]&lt;/code&gt; と同等だと考えるかもしれません。これは確かにPerl v5.18以降では真実ですが、それ以前は、垂直タブ（ &lt;code&gt;&quot;\cK&quot;&lt;/code&gt; ）が &lt;code&gt;\s&lt;/code&gt; と一致しないという唯一の違いがありました。</target>
        </trans-unit>
        <trans-unit id="032953fa379d00cbfc247f44c2a8260cf97dce47" translate="yes" xml:space="preserve">
          <source>One might think that &lt;code&gt;\s&lt;/code&gt; is equivalent to &lt;code&gt;[\h\v]&lt;/code&gt;. This is indeed true starting in Perl v5.18, but prior to that, the sole difference was that the vertical tab (&lt;code&gt;&quot;\cK&quot;&lt;/code&gt;) was not matched by &lt;code&gt;\s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; は &lt;code&gt;[\h\v]&lt;/code&gt; と同等であると考える人もいるかもしれません。これは、Perl v5.18以降では確かに当てはまりますが、それ以前の唯一の違いは、垂直タブ（ &lt;code&gt;&quot;\cK&quot;&lt;/code&gt; ）が &lt;code&gt;\s&lt;/code&gt; と一致しなかったことです。</target>
        </trans-unit>
        <trans-unit id="9432dfd3d2e52e33cd8be01a23869f988f439b1e" translate="yes" xml:space="preserve">
          <source>One more thing here. The arrow is optional</source>
          <target state="translated">ここでもう一つ。矢印は任意です</target>
        </trans-unit>
        <trans-unit id="a5eb562f91efde24f12f2e0986c6a04d104745fa" translate="yes" xml:space="preserve">
          <source>One must be careful with scalars and strings that are passed to print that contain ASCII encodings. One common place for this to occur is in the output of the MIME type header for CGI script writing. For example, many Perl programming guides recommend something similar to:</source>
          <target state="translated">ASCII エンコーディングを含むスカラや文字列が print に渡される場合は注意が必要です。これがよく起こる場所の一つは、CGI スクリプトを書くための MIME タイプヘッダの出力です。例えば、多くの Perl プログラミングガイドでは、次のようなことを推奨しています。</target>
        </trans-unit>
        <trans-unit id="8aa98e22038b28e02e918eedca3ae733d476de73" translate="yes" xml:space="preserve">
          <source>One name for a file. This name is listed in a &lt;b&gt;directory&lt;/b&gt;. You can use it in an &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; to tell the &lt;b&gt;operating system&lt;/b&gt; exactly which file you want to open, and associate the file with a &lt;b&gt;filehandle&lt;/b&gt;, which will carry the subsequent identity of that file in your program, until you close it.</source>
          <target state="translated">ファイルの1つの名前。この名前は&lt;b&gt;ディレクトリに&lt;/b&gt;リストされています。これを &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 使用して、&lt;b&gt;オペレーティングシステム&lt;/b&gt;にどのファイルを開きたいかを正確に伝え、ファイルを&lt;b&gt;filehandleに&lt;/b&gt;関連付けることができます。これにより、プログラム内でそのファイルの後続のIDが閉じられます。</target>
        </trans-unit>
        <trans-unit id="336da35cb3021da58e89132b50e38c873db1f14d" translate="yes" xml:space="preserve">
          <source>One name for a file. This name is listed in a &lt;b&gt;directory&lt;/b&gt;. You can use it in an &lt;code&gt;open&lt;/code&gt; to tell the &lt;b&gt;operating system&lt;/b&gt; exactly which file you want to open, and associate the file with a &lt;b&gt;filehandle&lt;/b&gt;, which will carry the subsequent identity of that file in your program, until you close it.</source>
          <target state="translated">ファイルの1つの名前。この名前は&lt;b&gt;ディレクトリに&lt;/b&gt;リストされています。これを &lt;code&gt;open&lt;/code&gt; 使用して、&lt;b&gt;オペレーティングシステム&lt;/b&gt;にどのファイルを開きたいかを正確に伝え、ファイルを&lt;b&gt;ファイルハンドルに&lt;/b&gt;関連付けることができます。ファイル&lt;b&gt;ハンドル&lt;/b&gt;は、ファイルを閉じるまで、プログラム内でそのファイルの後続のIDを保持します。</target>
        </trans-unit>
        <trans-unit id="f26a31e071285811042cc63d258cbdf20a705a7a" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;Moo&lt;/code&gt; 's most compelling features is its interoperability with &lt;code&gt;Moose&lt;/code&gt; . When someone tries to use &lt;code&gt;Moose&lt;/code&gt; 's introspection API on a &lt;code&gt;Moo&lt;/code&gt; class or role, it is transparently inflated into a &lt;code&gt;Moose&lt;/code&gt; class or role. This makes it easier to incorporate &lt;code&gt;Moo&lt;/code&gt; -using code into a &lt;code&gt;Moose&lt;/code&gt; code base and vice versa.</source>
          <target state="translated">&lt;code&gt;Moo&lt;/code&gt; の最も魅力的な機能の1つは、 &lt;code&gt;Moose&lt;/code&gt; との相互運用性です。誰かが &lt;code&gt;Moo&lt;/code&gt; クラスまたはロールで &lt;code&gt;Moose&lt;/code&gt; のイントロスペクションAPI を使用しようとすると、透過的に &lt;code&gt;Moose&lt;/code&gt; クラスまたはロールに拡張されます。これにより、 &lt;code&gt;Moo&lt;/code&gt; を使用するコードを &lt;code&gt;Moose&lt;/code&gt; コードベースに簡単に組み込むことができます。</target>
        </trans-unit>
        <trans-unit id="3e12d82a19550be538457962eb8c1b445867682c" translate="yes" xml:space="preserve">
          <source>One of &lt;code&gt;Moo&lt;/code&gt;'s most compelling features is its interoperability with &lt;code&gt;Moose&lt;/code&gt;. When someone tries to use &lt;code&gt;Moose&lt;/code&gt;'s introspection API on a &lt;code&gt;Moo&lt;/code&gt; class or role, it is transparently inflated into a &lt;code&gt;Moose&lt;/code&gt; class or role. This makes it easier to incorporate &lt;code&gt;Moo&lt;/code&gt;-using code into a &lt;code&gt;Moose&lt;/code&gt; code base and vice versa.</source>
          <target state="translated">&lt;code&gt;Moo&lt;/code&gt; の最も魅力的な機能の1つは、 &lt;code&gt;Moose&lt;/code&gt; との相互運用性です。誰かが &lt;code&gt;Moo&lt;/code&gt; クラスまたはロールで &lt;code&gt;Moose&lt;/code&gt; のイントロスペクションAPIを使用しようとすると、 &lt;code&gt;Moose&lt;/code&gt; クラスまたはロールに透過的に拡張されます。これにより、 &lt;code&gt;Moo&lt;/code&gt; を使用するコードを &lt;code&gt;Moose&lt;/code&gt; コードベースに簡単に組み込むことができ、その逆も可能です。</target>
        </trans-unit>
        <trans-unit id="5bf48b13931751973cecbe1ffc3a845b843b66dc" translate="yes" xml:space="preserve">
          <source>One of HP porting centres URL's is &lt;a href=&quot;http://hpux.connect.org.uk/&quot;&gt;http://hpux.connect.org.uk/&lt;/a&gt; The port currently available is built with GNU gcc.</source>
          <target state="translated">HPポーティングセンターのURLの1つは&lt;a href=&quot;http://hpux.connect.org.uk/&quot;&gt;http://hpux.connect.org.uk/&lt;/a&gt;です。現在利用可能なポートは、GNU gccで構築されています。</target>
        </trans-unit>
        <trans-unit id="886b780bbc161a993310017e62754b9a44143e58" translate="yes" xml:space="preserve">
          <source>One of HP porting centres URL's is &lt;a href=&quot;http://hpux.connect.org.uk/&quot;&gt;http://hpux.connect.org.uk/&lt;/a&gt; The port currently available is built with GNU gcc. As porting modern GNU gcc is extremely hard on HP-UX, they are stuck at version gcc-4.2.3.</source>
          <target state="translated">HPポーティングセンターのURLの1つは&lt;a href=&quot;http://hpux.connect.org.uk/&quot;&gt;http://hpux.connect.org.uk/&lt;/a&gt;です。現在利用可能なポートはGNUGccで構築されています。最新のGNUgccの移植はHP-UXで非常に難しいため、バージョンgcc-4.2.3でスタックしています。</target>
        </trans-unit>
        <trans-unit id="94bda56a061a9cf12b48d3cef39a83cda8c248d2" translate="yes" xml:space="preserve">
          <source>One of Perl's internal formats happens to be UTF-8. Unfortunately, Perl can't keep a secret, so everyone knows about this. That is the source of much confusion. It's better to pretend that the internal format is some unknown encoding, and that you always have to encode and decode explicitly.</source>
          <target state="translated">Perl の内部フォーマットの一つは UTF-8 です。残念ながら、Perl は秘密を守ることができないので、誰もがこのことを知っています。これが多くの混乱の原因となっています。内部フォーマットは未知のエンコーディングであり、常に明示的にエンコードとデコードをしなければならないということにしておいた方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="cc31f4f8c344159a9afe652428d4adbed5ef0111" translate="yes" xml:space="preserve">
          <source>One of the filters between the data and what you get as input or what you end up with as output.</source>
          <target state="translated">データと、入力として得られるものと、出力として得られるものとの間にあるフィルターの一つです。</target>
        </trans-unit>
        <trans-unit id="3850b3f9f916208f5af479bdf2a17050a569dd0c" translate="yes" xml:space="preserve">
          <source>One of the hacks is to disable floating point exceptions on Perl startup (as is the default with EMX). This helps only with compile-time-linked DLLs changing the flags before main() had a chance to be called.</source>
          <target state="translated">ハックの一つは、Perl の起動時に浮動小数点例外を無効にすることです (EMX のデフォルトのように)。これは、コンパイル時にリンクされた DLL が main()が呼ばれる前にフラグを変更した場合にのみ役立ちます。</target>
        </trans-unit>
        <trans-unit id="b9aab9b2588d728ddcd8fd3f3150c7ee7136503c" translate="yes" xml:space="preserve">
          <source>One of the major problems with ancient, antemillennial socket code in Perl was that it used hard-coded values for some of the constants, which severely hurt portability. If you ever see code that does anything like explicitly setting &lt;code&gt;$AF_INET = 2&lt;/code&gt; , you know you're in for big trouble. An immeasurably superior approach is to use the &lt;code&gt;Socket&lt;/code&gt; module, which more reliably grants access to the various constants and functions you'll need.</source>
          <target state="translated">Perlの古代の先駆的ソケットコードの主な問題の1つは、一部の定数にハードコードされた値を使用していたため、移植性が大幅に低下しました。 &lt;code&gt;$AF_INET = 2&lt;/code&gt; 明示的に設定するようなコードを目にしたことがあれば、大きな問題に直面していることになります。計り知れないほど優れたアプローチは、必要なさまざまな定数や関数へのアクセスをより確実に許可する &lt;code&gt;Socket&lt;/code&gt; モジュールを使用することです。</target>
        </trans-unit>
        <trans-unit id="3521b3f28c5fee40e9a650a969731031f1a61ee7" translate="yes" xml:space="preserve">
          <source>One of the major problems with ancient, antemillennial socket code in Perl was that it used hard-coded values for some of the constants, which severely hurt portability. If you ever see code that does anything like explicitly setting &lt;code&gt;$AF_INET = 2&lt;/code&gt;, you know you're in for big trouble. An immeasurably superior approach is to use the &lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt; module, which more reliably grants access to the various constants and functions you'll need.</source>
          <target state="translated">Perlの古くからの年に一度のソケットコードの主な問題の1つは、一部の定数にハードコードされた値を使用していたため、移植性が大幅に低下したことです。 &lt;code&gt;$AF_INET = 2&lt;/code&gt; 明示的に設定するようなコードを目にしたことがあれば、大きな問題に直面していることがわかります。計り知れないほど優れたアプローチは、&lt;a href=&quot;socket&quot;&gt;Socket&lt;/a&gt;モジュールを使用することです。これにより、必要なさまざまな定数や関数へのアクセスがより確実に許可されます。</target>
        </trans-unit>
        <trans-unit id="548d34337bf348093d461254c9e13628f931676b" translate="yes" xml:space="preserve">
          <source>One of the most important new features in Perl 5 was the capability to manage complicated data structures like multidimensional arrays and nested hashes. To enable these, Perl 5 introduced a feature called</source>
          <target state="translated">Perl 5 の最も重要な新機能の 1 つは、多次元配列や入れ子になったハッシュのような複雑なデータ構造を管理する機能でした。これらを可能にするために、Perl 5 は</target>
        </trans-unit>
        <trans-unit id="6c4fa2a95a0e37301600fc24249222e084bd9620" translate="yes" xml:space="preserve">
          <source>One of the most important new features in Perl 5 was the capability to manage complicated data structures like multidimensional arrays and nested hashes. To enable these, Perl 5 introduced a feature called 'references', and using references is the key to managing complicated, structured data in Perl. Unfortunately, there's a lot of funny syntax to learn, and the main manual page can be hard to follow. The manual is quite complete, and sometimes people find that a problem, because it can be hard to tell what is important and what isn't.</source>
          <target state="translated">Perl 5 の最も重要な新機能の 1 つは、多次元配列や入れ子になったハッシュのような複雑なデータ構造を管理する機能でした。これらを可能にするために、Perl 5では「参照」と呼ばれる機能が導入され、参照を使うことがPerlで複雑な構造化されたデータを管理するための鍵となっています。残念なことに、学ぶべき多くのおかしな構文があり、メインのマニュアルページに従うのは難しいかもしれません。マニュアルは非常に完全で、何が重要で何が重要でないのかを見分けるのが難しいので、時々それが問題になることがあります。</target>
        </trans-unit>
        <trans-unit id="41a97cc2346bbbbc5f26243bf51ad23f4ba0e8d3" translate="yes" xml:space="preserve">
          <source>One of the problems with a filter like:</source>
          <target state="translated">のようなフィルターの問題点の一つ。</target>
        </trans-unit>
        <trans-unit id="a626f07a30077e1f9ff80b843148b2bf2dc96ddf" translate="yes" xml:space="preserve">
          <source>One of the things that makes Perl really powerful is the fact that Perl hackers tend to want to share the solutions to problems they've faced, so you and I don't have to battle with the same problem again.</source>
          <target state="translated">Perl が本当に強力なのは、Perl ハッカーが直面した問題の解決策を共有したがる傾向があるからです。</target>
        </trans-unit>
        <trans-unit id="aa5b2755a479a90ca14fceb1d31618523426dc94" translate="yes" xml:space="preserve">
          <source>One of the two modules that is used by perlivp was not present in the installation. This is a serious error since it adversely affects perlivp's ability to function. You may be able to correct this by performing a proper perl installation.</source>
          <target state="translated">perlivpが使用している2つのモジュールのうちの1つがインストールされていませんでした。perlivpの機能に悪影響を及ぼすので、これは深刻なエラーです。perlを正しくインストールすることで、これを修正できるかもしれません。</target>
        </trans-unit>
        <trans-unit id="3cf9aca6d76537483035c3c858a1ba395bda4fb6" translate="yes" xml:space="preserve">
          <source>One of these is because that, contrary to the claims, Unicode is not completely locale insensitive. Turkish and some related languages have two types of &lt;code&gt;&quot;I&quot;&lt;/code&gt; characters. One is dotted in both upper- and lowercase, and the other is dotless in both cases. Unicode allows a locale to use either the Turkish rules, or the rules used in all other instances, where there is only one type of &lt;code&gt;&quot;I&quot;&lt;/code&gt;, which is dotless in the uppercase, and dotted in the lower. The perl core does not (yet) handle the Turkish case, and this message warns you of that. Instead, the &lt;a href=&quot;Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt; module allows you to mostly implement the Turkish casing rules.</source>
          <target state="translated">これらの1つは、主張に反して、Unicodeが完全にロケールに依存しないわけではないためです。トルコ語および一部の関連言語には、2種類の &lt;code&gt;&quot;I&quot;&lt;/code&gt; 文字があります。1つは大文字と小文字の両方で点線で示され、もう1つは両方の場合で点線がありません。Unicodeを使用すると、ロケールでトルコ語の規則、または大文字と小文字がドットなしの &lt;code&gt;&quot;I&quot;&lt;/code&gt; タイプが1つしかない他のすべてのインスタンスで使用される規則を使用できます。perlコアは（まだ）トルコのケースを処理していません、そしてこのメ​​ッセージはあなたにそれを警告します。代わりに、&lt;a href=&quot;Unicode::Casing&quot;&gt;Unicode :: Casing&lt;/a&gt;モジュールを使用すると、ほとんどの場合、トルコ語のケーシングルールを実装できます。</target>
        </trans-unit>
        <trans-unit id="d738b6e570cef7894a16f160998423dd24b30a2e" translate="yes" xml:space="preserve">
          <source>One or more embedded pattern-match modifiers, to be turned on (or turned off, if preceded by &lt;code&gt;-&lt;/code&gt; ) for the remainder of the pattern or the remainder of the enclosing pattern group (if any).</source>
          <target state="translated">残りのパターンまたは残りのパターングループ（存在する場合）の残りに対してオンにする（または &lt;code&gt;-&lt;/code&gt; が前にある場合はオフにする）1つ以上の埋め込みパターンマッチ修飾子。</target>
        </trans-unit>
        <trans-unit id="721d29636c1b919768ad8c3269b118c8775df092" translate="yes" xml:space="preserve">
          <source>One or more files turned up missing according to a run of &lt;code&gt;ExtUtils::Installed -&amp;gt; validate()&lt;/code&gt; over your installation. Correct by conducting a proper installation.</source>
          <target state="translated">&lt;code&gt;ExtUtils::Installed -&amp;gt; validate()&lt;/code&gt; でExtUtils :: Installed-&amp;gt; validate（）を実行した結果、1つ以上のファイルが見つからないことが判明しました。適切なインストールを行って修正してください。</target>
        </trans-unit>
        <trans-unit id="a650068eaca265c5b79bfe09b24d5cc755bb9020" translate="yes" xml:space="preserve">
          <source>One or more licenses that apply to some or all of the files in the distribution. If multiple licenses are listed, the distribution documentation should be consulted to clarify the interpretation of multiple licenses.</source>
          <target state="translated">ディストリビューション内のファイルの一部または全部に適用される1つ以上のライセンス。複数のライセンスがリストされている場合、複数のライセンスの解釈を明確にするために、ディストリビューションのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="88abd7d83fea4aa59fb220bc8cdda84165c2e0f9" translate="yes" xml:space="preserve">
          <source>One or more modifiers below may optionally follow certain letters in the TEMPLATE (the second column lists letters for which the modifier is valid):</source>
          <target state="translated">以下の1つ以上の修飾子は、任意でTEMPLATE内の特定の文字の後に続くことができます(第2列目には、修飾子が有効な文字のリストが表示されます)。</target>
        </trans-unit>
        <trans-unit id="3fcfdc5f9b9b3f122957e3a54f34893e2f61290e" translate="yes" xml:space="preserve">
          <source>One or more sections or subsections giving greater detail of available methods and routines and any other relevant information.</source>
          <target state="translated">利用可能な方法やルーチン、その他の関連情報のより詳細な情報を提供する1つ以上のセクションまたはサブセクション。</target>
        </trans-unit>
        <trans-unit id="c5eeb4b94f000feadb0a97d5609bef506c388a67" translate="yes" xml:space="preserve">
          <source>One other interesting thing that the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; flag allows is chaining substitutions:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; フラグが許可するもう1つの興味深いことは、置換の連鎖です。</target>
        </trans-unit>
        <trans-unit id="494e3ba4d63dc7d4d1f0f89cdfe24cd0f1c04a4f" translate="yes" xml:space="preserve">
          <source>One other interesting thing that the &lt;code&gt;s///r&lt;/code&gt; flag allows is chaining substitutions:</source>
          <target state="translated">&lt;code&gt;s///r&lt;/code&gt; フラグで許可されるもう1つの興味深い点は、置換の連鎖です。</target>
        </trans-unit>
        <trans-unit id="1f9412fcd9541135d5364daa53310c1798b61f41" translate="yes" xml:space="preserve">
          <source>One other thing to consider is that a CV may be merely undefined rather than freed, eg &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; . In this case, its refcount may not have reached zero, but we still delete its pad and its &lt;code&gt;CvROOT&lt;/code&gt; etc. Since various children may still have their &lt;code&gt;CvOUTSIDE&lt;/code&gt; pointing at this undefined CV, we keep its own &lt;code&gt;CvOUTSIDE&lt;/code&gt; for the time being, so that the chain of lexical scopes is unbroken. For example, the following should print 123:</source>
          <target state="translated">考慮すべきもう1つのことは、CVが解放されるのではなく、単に未定義になる可能性があることです（例： &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; &amp;amp;foo&lt;/code&gt; 。この場合、参照カウントはゼロに達していない可能性がありますが、そのパッドやその &lt;code&gt;CvROOT&lt;/code&gt; などを削除します。さまざまな子がまだこの &lt;code&gt;CvOUTSIDE&lt;/code&gt; をこの未定義のCVに向けている可能性があるため、当面は独自の &lt;code&gt;CvOUTSIDE&lt;/code&gt; を保持します。字句スコープのチェーンは壊れていません。たとえば、次の例では123と出力されます。</target>
        </trans-unit>
        <trans-unit id="014675b4f1afe81572052832b23ba392c4d8e3a4" translate="yes" xml:space="preserve">
          <source>One other thing to consider is that a CV may be merely undefined rather than freed, eg &lt;code&gt;undef &amp;amp;foo&lt;/code&gt;. In this case, its refcount may not have reached zero, but we still delete its pad and its &lt;code&gt;CvROOT&lt;/code&gt; etc. Since various children may still have their &lt;code&gt;CvOUTSIDE&lt;/code&gt; pointing at this undefined CV, we keep its own &lt;code&gt;CvOUTSIDE&lt;/code&gt; for the time being, so that the chain of lexical scopes is unbroken. For example, the following should print 123:</source>
          <target state="translated">考慮すべきもう1つのことは、CVが解放されるのではなく、単に未定義である可能性があることです（例： &lt;code&gt;undef &amp;amp;foo&lt;/code&gt; 。この場合、refcountはゼロに達していない可能性がありますが、パッドや &lt;code&gt;CvROOT&lt;/code&gt; などは削除されます。さまざまな子が &lt;code&gt;CvOUTSIDE&lt;/code&gt; をこの未定義のCVに向けている可能性があるため、当面は独自の &lt;code&gt;CvOUTSIDE&lt;/code&gt; を保持します。字句スコープのチェーンは壊れていません。たとえば、次のように123を出力する必要があります。</target>
        </trans-unit>
        <trans-unit id="2d2da08b06ed54d7d3369e11557c08e9b0920593" translate="yes" xml:space="preserve">
          <source>One particularly interesting aspect is that if the op has no kids (i.e., &lt;code&gt;readline()&lt;/code&gt; or &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) the op is freed and replaced with an entirely new one that references &lt;code&gt;*ARGV&lt;/code&gt; (lines 12-16).</source>
          <target state="translated">特に興味深い側面の1つは、opに子がない場合（つまり、 &lt;code&gt;readline()&lt;/code&gt; または &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ）、opが解放され、 &lt;code&gt;*ARGV&lt;/code&gt; を参照するまったく新しいものに置き換えられることです（12〜16行目）。</target>
        </trans-unit>
        <trans-unit id="54709e3c9ceaf35c18e13834b92c003e53cefa1d" translate="yes" xml:space="preserve">
          <source>One particularly pernicious problem with the 4NT command shell for Windows is that it (nearly) always treats a % character as indicating that environment variable expansion is needed. Under this shell, it is therefore important to always double any % characters which you want Perl to see (for example, for hash variables), even when they are quoted.</source>
          <target state="translated">Windows 用の 4NT コマンドシェルの特に悪質な問題は、環境変数の展開が必要であることを示すために、(ほぼ)常に % 文字を扱うことです。したがって、このシェルでは、引用符で囲まれている場合でも、Perl に表示させたい % 文字 (例えば、ハッシュ変数の場合)は常に二重にすることが重要です。</target>
        </trans-unit>
        <trans-unit id="3b85137385a802506b55867204695f7dbafde5be" translate="yes" xml:space="preserve">
          <source>One possibility is to treat any match against these code points as undefined. But since Perl doesn't have the concept of a match being undefined, it converts this to failing or &lt;code&gt;FALSE&lt;/code&gt; . This is almost, but not quite, what Perl did from v5.14 (when use of these code points became generally reliable) through v5.18. The difference is that Perl treated all &lt;code&gt;\p{}&lt;/code&gt; matches as failing, but all &lt;code&gt;\P{}&lt;/code&gt; matches as succeeding.</source>
          <target state="translated">1つの可能性は、これらのコードポイントに対する一致を未定義として扱うことです。しかし、Perlには一致が未定義であるという概念がないため、これを失敗または &lt;code&gt;FALSE&lt;/code&gt; に変換します。これは、Perlがv5.14（これらのコードポイントの使用が一般的に信頼できるようになったとき）からv5.18までに行ったこととほぼ同じですが、完全ではありません。違いは、Perlはすべての &lt;code&gt;\p{}&lt;/code&gt; 一致を失敗として扱いましたが、すべての &lt;code&gt;\P{}&lt;/code&gt; 一致を成功として扱いました。</target>
        </trans-unit>
        <trans-unit id="fbed2ea5d12cf5ca5a7dda7729be8ef0a1f5a584" translate="yes" xml:space="preserve">
          <source>One possibility is to treat any match against these code points as undefined. But since Perl doesn't have the concept of a match being undefined, it converts this to failing or &lt;code&gt;FALSE&lt;/code&gt;. This is almost, but not quite, what Perl did from v5.14 (when use of these code points became generally reliable) through v5.18. The difference is that Perl treated all &lt;code&gt;\p{}&lt;/code&gt; matches as failing, but all &lt;code&gt;\P{}&lt;/code&gt; matches as succeeding.</source>
          <target state="translated">1つの可能性は、これらのコードポイントに対する一致を未定義として扱うことです。しかし、Perlには一致が未定義であるという概念がないため、これを失敗または &lt;code&gt;FALSE&lt;/code&gt; に変換します。これは、Perlがv5.14（これらのコードポイントの使用が一般的に信頼できるようになったとき）からv5.18まで行ったこととほぼ同じですが、完全ではありません。違いは、Perlはすべての &lt;code&gt;\p{}&lt;/code&gt; 一致を失敗として扱いましたが、すべての &lt;code&gt;\P{}&lt;/code&gt; 一致を成功として扱ったことです。</target>
        </trans-unit>
        <trans-unit id="1709a410cf93d9bdbeb6df92828279b6d704a7e5" translate="yes" xml:space="preserve">
          <source>One possible cause for this is that you expected to have imported a constant to your name space with &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; while no such importing took place, it may for example be that your operating system does not support that particular constant. Hopefully you did use an explicit import list for the constants you expect to see; please see &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; and &lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;. While an explicit import list would probably have caught this error earlier it naturally does not remedy the fact that your operating system still does not support that constant. Maybe you have a typo in the constants of the symbol import list of &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; or in the constant name at the line where this error was triggered?</source>
          <target state="translated">考えられる原因の1つは、そのようなインポートが行われていないときに、&lt;b&gt;use&lt;/b&gt;または&lt;b&gt;import&lt;/b&gt;を&lt;b&gt;使用&lt;/b&gt;して定数を名前空間に&lt;b&gt;インポート&lt;/b&gt;したはずであったことです。たとえば、オペレーティングシステムがその特定の定数をサポートしていない可能性があります。うまくいけば、表示されるはずの定数に対して明示的なインポートリストを使用したことになります。&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;と&lt;a href=&quot;functions/import&quot;&gt;インポート&lt;/a&gt;をご覧ください。明示的なインポートリストはおそらくこのエラーを先に検出したはずですが、オペレーティングシステムがまだその定数をサポートしていないという事実は当然修正されません。たぶん、シンボルインポートの&lt;b&gt;使用&lt;/b&gt;または&lt;b&gt;インポートの&lt;/b&gt;リストの定数、またはこのエラーがトリガーされた行の定数名にタイプミスがありますか？</target>
        </trans-unit>
        <trans-unit id="039c34047140e161ac3c3f3d67a00d920ec9253f" translate="yes" xml:space="preserve">
          <source>One possible cause for this is that you expected to have imported a constant to your name space with &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; while no such importing took place, it may for example be that your operating system does not support that particular constant. Hopefully you did use an explicit import list for the constants you expect to see; please see &lt;a href=&quot;perlfunc#use&quot;&gt;&quot;use&quot; in perlfunc&lt;/a&gt; and &lt;a href=&quot;perlfunc#import&quot;&gt;&quot;import&quot; in perlfunc&lt;/a&gt;. While an explicit import list would probably have caught this error earlier it naturally does not remedy the fact that your operating system still does not support that constant. Maybe you have a typo in the constants of the symbol import list of &lt;b&gt;use&lt;/b&gt; or &lt;b&gt;import&lt;/b&gt; or in the constant name at the line where this error was triggered?</source>
          <target state="translated">これの考えられる原因の1つは、そのようなインポートが行われていないときに、&lt;b&gt;use&lt;/b&gt;または&lt;b&gt;import&lt;/b&gt;を&lt;b&gt;使用&lt;/b&gt;して名前空間に定数をインポートすると予想したことです。たとえば、オペレーティングシステムがその特定の定数をサポートしていない可能性があります。期待する定数に明示的なインポートリストを使用したことを願っています。参照してください。&lt;a href=&quot;perlfunc#use&quot;&gt;perlfuncの中に「使用」&lt;/a&gt;と&lt;a href=&quot;perlfunc#import&quot;&gt;perlfuncの中に「インポート」&lt;/a&gt;。明示的なインポートリストはおそらく以前にこのエラーを検出したはずですが、オペレーティングシステムがまだその定数をサポートしていないという事実を自然に修正することはできません。&lt;b&gt;使用&lt;/b&gt;または&lt;b&gt;インポートの&lt;/b&gt;シンボルインポートリストの定数にタイプミスがある可能性があります&lt;b&gt;&lt;/b&gt; または、このエラーがトリガーされた行の定数名にありますか？</target>
        </trans-unit>
        <trans-unit id="9b7cfe9d2aa74b9a194cf633078d5ffa3af4a9c3" translate="yes" xml:space="preserve">
          <source>One possible cause is that you set the UTF8 flag yourself for data that you thought to be in UTF-8 but it wasn't (it was for example legacy 8-bit data). To guard against this, you can use &lt;code&gt;Encode::decode('UTF-8', ...)&lt;/code&gt;.</source>
          <target state="translated">考えられる原因の1つは、UTF-8にあると思われるデータに対してUTF8フラグを自分で設定したが、そうではなかった（たとえば、レガシー8ビットデータであった）ことです。これを防ぐには、 &lt;code&gt;Encode::decode('UTF-8', ...)&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="07ffb8bf7d3f585bbcc39c2a43071e1fcedc7e55" translate="yes" xml:space="preserve">
          <source>One possible cause is that you set the UTF8 flag yourself for data that you thought to be in UTF-8 but it wasn't (it was for example legacy 8-bit data). To guard against this, you can use Encode::decode_utf8.</source>
          <target state="translated">考えられる原因としては、UTF-8だと思っていたデータがUTF-8ではなかった(レガシー8ビットデータなど)ために、自分でUTF8フラグを設定してしまったことが考えられます。これを防ぐには、Encode::decode_utf8 を使用することができます。</target>
        </trans-unit>
        <trans-unit id="2c03f254e4e39f57b8a0f0a972c88db9a731c9ed" translate="yes" xml:space="preserve">
          <source>One possibly useful value for the &quot;fail&quot; attribute is the method name &quot;failure_handler_auto&quot;. This is a method defined in the class Locale::Maketext itself. You set it with:</source>
          <target state="translated">fail &quot;属性の有用な値として、&quot;failure_handler_auto &quot;というメソッド名があります。これはLocale::Maketextクラス自体で定義されているメソッドです。で設定します。</target>
        </trans-unit>
        <trans-unit id="b269ab649a9c9d812d50cb6b126828e7c900c2dc" translate="yes" xml:space="preserve">
          <source>One problem that comes up all the time is needing a hash whose values are lists. Perl has hashes, of course, but the values have to be scalars; they can't be lists.</source>
          <target state="translated">いつも出てくる問題の一つに、値がリストであるハッシュが必要なことがあります。Perlにはもちろんハッシュがありますが、値はスカラーでなければなりません。</target>
        </trans-unit>
        <trans-unit id="b4ad2adff47d9f54cd5e7bc6c9a916046c09e993" translate="yes" xml:space="preserve">
          <source>One problem with creating a zip archive directly from STDIN can be demonstrated by looking at the contents of the zip file, output.zip, that we have just created.</source>
          <target state="translated">STDIN から直接 zip アーカイブを作成する場合の問題点は、先ほど作成した output.zip という zip ファイルの内容を見ればわかります。</target>
        </trans-unit>
        <trans-unit id="95b95f68790db1176c6962a262914d43124b34ed" translate="yes" xml:space="preserve">
          <source>One problem with this is that it leads to unexpected, and confusing results in some cases:</source>
          <target state="translated">問題点としては、予想外の結果につながり、場合によっては混乱を招くことがあります。</target>
        </trans-unit>
        <trans-unit id="da0157bdbeb61d81e4c036f5229eec00b96121c7" translate="yes" xml:space="preserve">
          <source>One problem with this is that it leads to unexpected, and confusting results in some cases:</source>
          <target state="translated">問題点としては、予想外の結果につながり、場合によっては戸惑うこともあるということです。</target>
        </trans-unit>
        <trans-unit id="28b64c8c7b545333b3723cd48a2c35dd515526c6" translate="yes" xml:space="preserve">
          <source>One reason of this unfinishedness is its (currently) inherent unportability: since both package names and subroutine names may need to be mapped to file and directory names, the Unicode capability of the filesystem becomes important-- and there unfortunately aren't portable answers.</source>
          <target state="translated">パッケージ名とサブルーチン名の両方をファイル名とディレクトリ名にマッピングする必要があるため、ファイルシステムの Unicode 機能が重要になります。</target>
        </trans-unit>
        <trans-unit id="ea120cdc114e86190ef9485fa0b67ab7b3ed56c2" translate="yes" xml:space="preserve">
          <source>One reason that Perl does not attempt to resolve the role of Unicode in these situations is that the answers are highly dependent on the operating system and the file system(s). For example, whether filenames can be in Unicode and in exactly what kind of encoding, is not exactly a portable concept. Similarly for &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;: how well will the &quot;command-line interface&quot; (and which of them?) handle Unicode?</source>
          <target state="translated">Perlがこれらの状況でUnicodeの役割を解決しようとしない理由の1つは、回答がオペレーティングシステムとファイルシステムに大きく依存していることです。たとえば、ファイル名をUnicodeにできるかどうか、正確にどのようなエンコーディングにするかは、移植性のある概念ではありません。同様に &lt;code&gt;&lt;a href=&quot;functions/qx&quot;&gt;qx&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; ：「コマンドラインインターフェイス」（およびそれらのどれですか）がUnicodeをどの程度適切に処理しますか？</target>
        </trans-unit>
        <trans-unit id="19ce00dd1106586a8ff2ee123627cfb803c2703c" translate="yes" xml:space="preserve">
          <source>One reason that Perl does not attempt to resolve the role of Unicode in these situations is that the answers are highly dependent on the operating system and the file system(s). For example, whether filenames can be in Unicode and in exactly what kind of encoding, is not exactly a portable concept. Similarly for &lt;code&gt;qx&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt;: how well will the &quot;command-line interface&quot; (and which of them?) handle Unicode?</source>
          <target state="translated">Perlがこれらの状況でUnicodeの役割を解決しようとしない理由の1つは、答えがオペレーティングシステムとファイルシステムに大きく依存していることです。たとえば、ファイル名をUnicodeで使用できるかどうか、および正確にどのような種類のエンコーディングで使用できるかは、厳密には移植可能な概念ではありません。同様に、 &lt;code&gt;qx&lt;/code&gt; と &lt;code&gt;system&lt;/code&gt; ：「コマンドラインインターフェイス」（およびそれらのどれ？）はUnicodeをどの程度うまく処理しますか？</target>
        </trans-unit>
        <trans-unit id="f8927d95df9fc41f4dc802a7941a3910e635adce" translate="yes" xml:space="preserve">
          <source>One reference count is stolen, so you may need to do &lt;code&gt;SvREFCNT_inc(func)&lt;/code&gt; .</source>
          <target state="translated">1つの参照カウントが盗まれるので、 &lt;code&gt;SvREFCNT_inc(func)&lt;/code&gt; を実行する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="670ea0271b09cb55acf778b559eb456bd6341e38" translate="yes" xml:space="preserve">
          <source>One reference count is stolen, so you may need to do &lt;code&gt;SvREFCNT_inc(func)&lt;/code&gt;.</source>
          <target state="translated">1つの参照カウントが盗まれたため、 &lt;code&gt;SvREFCNT_inc(func)&lt;/code&gt; を実行する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="c9dade105e4e2f60c0a165dad2f91b1cd7cbd6b9" translate="yes" xml:space="preserve">
          <source>One should write this:</source>
          <target state="translated">一人はこれを書くべきです。</target>
        </trans-unit>
        <trans-unit id="4267ef088e1112c0c8dad77c36351342e81e6a78" translate="yes" xml:space="preserve">
          <source>One simple way to check that things are in the right place is to print out the hard-coded &lt;code&gt;@INC&lt;/code&gt; that perl looks through for libraries:</source>
          <target state="translated">物事が正しい場所にあることを確認する簡単な方法の1つは、perlがライブラリを調べるハードコードされた &lt;code&gt;@INC&lt;/code&gt; を出力することです。</target>
        </trans-unit>
        <trans-unit id="40125cf7ac08509271fa2127b7fe01c46836ef0d" translate="yes" xml:space="preserve">
          <source>One solution for that could use &lt;code&gt;Number::Format&lt;/code&gt; like that:</source>
          <target state="translated">そのための1つの解決策は、次のような &lt;code&gt;Number::Format&lt;/code&gt; 使用できます。</target>
        </trans-unit>
        <trans-unit id="dc49c03d5b80e5ca3e1e2c3c5c594145d4d2cfdb" translate="yes" xml:space="preserve">
          <source>One solution to you problem might be autoupgrading|upgrading. See the pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; for an easy way to do this.</source>
          <target state="translated">問題の1つの解決策は、自動アップグレード|アップグレードです。これを行う簡単な方法については、&lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;、&lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt;、&lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt;プラグマを参照してください。</target>
        </trans-unit>
        <trans-unit id="2481b8adeee425ef556bd2bb817f713879888ab4" translate="yes" xml:space="preserve">
          <source>One solution to you problem might be autoupgrading|upgrading. See the pragmas &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; for an easy way to do this.</source>
          <target state="translated">問題の解決策の1つは、自動アップグレード|アップグレードです。これを行う簡単な方法については、プラグマ&lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;、&lt;a href=&quot;bigint&quot;&gt;bigint&lt;/a&gt;、&lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="43c39e037892e8d1c938d57ac2c0beb9ba304a9c" translate="yes" xml:space="preserve">
          <source>One subtest fails due to the uncommon structure of the Synology file system. The file</source>
          <target state="translated">Synology ファイルシステムの構造が一般的ではないため、サブテストが 1 回失敗する。ファイル</target>
        </trans-unit>
        <trans-unit id="02a95fea5b4501f9e97b845e1295326b4030d00a" translate="yes" xml:space="preserve">
          <source>One such concept is that of a</source>
          <target state="translated">そのような概念の一つに</target>
        </trans-unit>
        <trans-unit id="4c38cfb2cc0fa83015bbf2caee9f3438eaaff452" translate="yes" xml:space="preserve">
          <source>One such defect of standard &lt;code&gt;numf&lt;/code&gt; is to not be able to use a certain decimal precision. For example,</source>
          <target state="translated">標準 &lt;code&gt;numf&lt;/code&gt; のそのような欠点の1つは、特定の10進精度を使用できないことです。例えば、</target>
        </trans-unit>
        <trans-unit id="d757b7ae7bf4edf5a451dca67abbf950db74e0a2" translate="yes" xml:space="preserve">
          <source>One such sequence is &lt;code&gt;\b&lt;/code&gt;, which matches a boundary of some sort. &lt;code&gt;\b{wb}&lt;/code&gt; and a few others give specialized types of boundaries. (They are all described in detail starting at &lt;a href=&quot;perlrebackslash#%5Cb%7B%7D%2C-%5Cb%2C-%5CB%7B%7D%2C-%5CB&quot;&gt;&quot;\b{}, \b, \B{}, \B&quot; in perlrebackslash&lt;/a&gt;.) Note that these don't match characters, but the zero-width spaces between characters. They are an example of a &lt;a href=&quot;#Assertions&quot;&gt;zero-width assertion&lt;/a&gt;. Consider again,</source>
          <target state="translated">そのようなシーケンスの1つは &lt;code&gt;\b&lt;/code&gt; 、これはある種の境界に一致します。 &lt;code&gt;\b{wb}&lt;/code&gt; と他のいくつかは、特殊なタイプの境界を提供します。 （これらはすべて&lt;a href=&quot;perlrebackslash#%5Cb%7B%7D%2C-%5Cb%2C-%5CB%7B%7D%2C-%5CB&quot;&gt;、perlrebackslashの「\ b {}、\ b、\ B {}、\ B」&lt;/a&gt;から詳細に説明されています。）これらは文字と一致しませんが、文字間のゼロ幅スペースであることに注意してください。これらは、&lt;a href=&quot;#Assertions&quot;&gt;ゼロ幅アサーションの&lt;/a&gt;例です。もう一度考えてみてください</target>
        </trans-unit>
        <trans-unit id="9fa9079fbfabecb5820f55e5b80f8f3529f8caa0" translate="yes" xml:space="preserve">
          <source>One thing Perl porters should note is that</source>
          <target state="translated">Perl 移植者が注意すべきことの一つは</target>
        </trans-unit>
        <trans-unit id="46c4b185ea7870c493b95dc5795ba2145a16a509" translate="yes" xml:space="preserve">
          <source>One thing you may not want to rely on is the EBCDIC encoding of punctuation characters since these may differ from code page to code page (and once your module or script is rumoured to work with EBCDIC, folks will want it to work with all EBCDIC character sets).</source>
          <target state="translated">句読点文字のEBCDICエンコーディングは、コードページごとに異なる可能性があるので、頼りにしない方がいいかもしれません (あなたのモジュールやスクリプトがEBCDICで動作すると噂されると、人々はそれがすべてのEBCDIC文字セットで動作することを望むようになります)。</target>
        </trans-unit>
        <trans-unit id="47095331b77aa8c0bd7b8cd8bf856b6f81ef9c2e" translate="yes" xml:space="preserve">
          <source>One thing you'll notice about the Perl source is that it's full of macros. Some have called the pervasive use of macros the hardest thing to understand, others find it adds to clarity. Let's take an example, a stripped-down version the code which implements the addition operator:</source>
          <target state="translated">Perl のソースについて気づくことの一つは、マクロがたくさんあることです。マクロが広く使われていることを理解するのが最も難しいことだと言う人もいれば、わかりやすくするためにマクロを使うという人もいます。例として、足し算演算子を実装したコードを縮小したものを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="3339e6cb559916439f958aa73fa10717ebc88663" translate="yes" xml:space="preserve">
          <source>One thing you'll notice about the Perl source is that it's full of macros. Some have called the pervasive use of macros the hardest thing to understand, others find it adds to clarity. Let's take an example, the code which implements the addition operator:</source>
          <target state="translated">Perl のソースについて気づくことの一つは、マクロがたくさんあることです。マクロが広く使われていることを理解するのが最も難しいことだと言う人もいれば、わかりやすくするためにマクロを使うという人もいます。例として、加算演算子を実装したコードを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="3d7413c1ef4de3f560bf3b6da33dd42dda59d66b" translate="yes" xml:space="preserve">
          <source>One trick is to use &lt;a href=&quot;File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt;, which starts at the end of the file. That module provides an object that wraps the real filehandle to make it easy for you to move around the file. Once you get to the spot you need, you can get the actual filehandle and work with it as normal. In this case, you get the file position at the end of the last line you want to keep and truncate the file to that point:</source>
          <target state="translated">1つのトリックは、ファイルの最後から始まる&lt;a href=&quot;File::ReadBackwards&quot;&gt;File :: ReadBackwards&lt;/a&gt;を使用することです。このモジュールは、実際のファイルハンドルをラップするオブジェクトを提供して、ファイル内を簡単に移動できるようにします。必要な場所に到達したら、実際のファイルハンドルを取得して、通常どおりに操作できます。この場合、保持する最後の行の終わりにファイルの位置を取得し、そのポイントまでファイルを切り捨てます。</target>
        </trans-unit>
        <trans-unit id="6281791d1604f0f2ed2c5d9e3d66b1042f62e087" translate="yes" xml:space="preserve">
          <source>One trick is to use &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt;, which starts at the end of the file. That module provides an object that wraps the real filehandle to make it easy for you to move around the file. Once you get to the spot you need, you can get the actual filehandle and work with it as normal. In this case, you get the file position at the end of the last line you want to keep and truncate the file to that point:</source>
          <target state="translated">1つのトリックは、ファイルの最後から始まる&lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;File :: ReadBackwards&lt;/a&gt;を使用することです。そのモジュールは、実際のファイルハンドルをラップするオブジェクトを提供し、ファイル内を簡単に移動できるようにします。必要な場所に到達したら、実際のファイルハンドルを取得して、通常どおりに操作できます。この場合、保持したい最後の行の終わりのファイル位置を取得し、そのポイントまでファイルを切り捨てます。</target>
        </trans-unit>
        <trans-unit id="867c8b371a8323be6dd9b1df9a9ab1f91f9da2fc" translate="yes" xml:space="preserve">
          <source>One underline is allowed between any two digits, including hexadecimal and binary digits.</source>
          <target state="translated">16進数や2進数を含め、任意の2桁の間に1つのアンダーラインを入れることができます。</target>
        </trans-unit>
        <trans-unit id="cd71d85a3c1d14096e3d0dd58527e3bd9ae1e0f0" translate="yes" xml:space="preserve">
          <source>One underline is allowed between any two digits.</source>
          <target state="translated">任意の2桁の間に1つのアンダーラインを入れることができます。</target>
        </trans-unit>
        <trans-unit id="2f7425b7bd02b814bd9989aec894f5edbf698c87" translate="yes" xml:space="preserve">
          <source>One useful value for &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; is &lt;code&gt;less -+C -E&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;PERLDOC_PAGER&lt;/code&gt; の有用な値の1つは、 &lt;code&gt;less -+C -E&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16342fee4b1c5a929e46db4d5c80b063641a8ef3" translate="yes" xml:space="preserve">
          <source>One useful value for &lt;code&gt;PERLDOC_PAGER&lt;/code&gt; is &lt;code&gt;less -+C -E&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PERLDOC_PAGER&lt;/code&gt; の有用な値の1つは &lt;code&gt;less -+C -E&lt;/code&gt; E未満です。</target>
        </trans-unit>
        <trans-unit id="e54e615dc99abeb96e3dcca5dc954ca0886ad54d" translate="yes" xml:space="preserve">
          <source>One way I can do this involves the substitution operator and a double &lt;code&gt;/e&lt;/code&gt; flag. The first &lt;code&gt;/e&lt;/code&gt; evaluates &lt;code&gt;$1&lt;/code&gt; on the replacement side and turns it into &lt;code&gt;$foo&lt;/code&gt; . The second /e starts with &lt;code&gt;$foo&lt;/code&gt; and replaces it with its value. &lt;code&gt;$foo&lt;/code&gt; , then, turns into 'Fred', and that's finally what's left in the string:</source>
          <target state="translated">これを行う1つの方法には、置換演算子と二重の &lt;code&gt;/e&lt;/code&gt; フラグが含まれます。最初の &lt;code&gt;/e&lt;/code&gt; は置換側で &lt;code&gt;$1&lt;/code&gt; を評価し、それを &lt;code&gt;$foo&lt;/code&gt; に変換します。2番目の/ eは &lt;code&gt;$foo&lt;/code&gt; 始まり、その値で置き換えます。 &lt;code&gt;$foo&lt;/code&gt; は 'Fred'に変わり、文字列に残っているのはそれだけです。</target>
        </trans-unit>
        <trans-unit id="bec707f167a013990074f651461c1eabbee251f8" translate="yes" xml:space="preserve">
          <source>One way I can do this involves the substitution operator and a double &lt;code&gt;/e&lt;/code&gt; flag. The first &lt;code&gt;/e&lt;/code&gt; evaluates &lt;code&gt;$1&lt;/code&gt; on the replacement side and turns it into &lt;code&gt;$foo&lt;/code&gt;. The second /e starts with &lt;code&gt;$foo&lt;/code&gt; and replaces it with its value. &lt;code&gt;$foo&lt;/code&gt;, then, turns into 'Fred', and that's finally what's left in the string:</source>
          <target state="translated">これを行う1つの方法は、置換演算子と二重 &lt;code&gt;/e&lt;/code&gt; フラグを使用することです。最初の &lt;code&gt;/e&lt;/code&gt; は、置換側で &lt;code&gt;$1&lt;/code&gt; を評価し、それを &lt;code&gt;$foo&lt;/code&gt; に変換します。2番目の/ eは &lt;code&gt;$foo&lt;/code&gt; 始まり、その値に置き換えられます。次に、 &lt;code&gt;$foo&lt;/code&gt; は「Fred」に変わり、それが最終的に文字列に残るものになります。</target>
        </trans-unit>
        <trans-unit id="147fc583705f82dfe6c5d25a61550d429d726533" translate="yes" xml:space="preserve">
          <source>One way is to treat the return values as a list and index into it:</source>
          <target state="translated">1つの方法は、戻り値をリストとして扱い、それにインデックスを付けることです。</target>
        </trans-unit>
        <trans-unit id="f26562604a7b87b255854e546e57c428a05a7c6b" translate="yes" xml:space="preserve">
          <source>One way of peeking inside the internal encoding of Unicode characters is to use &lt;code&gt;unpack(&quot;C*&quot;, ...&lt;/code&gt; to get the bytes of whatever the string encoding happens to be, or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U0..&quot;, ...)&lt;/code&gt; to get the bytes of the UTF-8 encoding:</source>
          <target state="translated">Unicode文字の内部エンコーディングを調べる1つの方法は、 &lt;code&gt;unpack(&quot;C*&quot;, ...&lt;/code&gt; を使用して、文字列エンコーディングが発生するすべてのバイトを取得するか、 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;(&quot;U0..&quot;, ...)&lt;/code&gt; UTF-8エンコーディングのバイトを取得するには：</target>
        </trans-unit>
        <trans-unit id="77d927c43f13ed4bce0c8303d398089ab5954c32" translate="yes" xml:space="preserve">
          <source>One way of peeking inside the internal encoding of Unicode characters is to use &lt;code&gt;unpack(&quot;C*&quot;, ...&lt;/code&gt; to get the bytes of whatever the string encoding happens to be, or &lt;code&gt;unpack(&quot;U0..&quot;, ...)&lt;/code&gt; to get the bytes of the UTF-8 encoding:</source>
          <target state="translated">Unicode文字の内部エンコーディングを覗く1つの方法は、 &lt;code&gt;unpack(&quot;C*&quot;, ...&lt;/code&gt; を使用して、文字列エンコーディングが発生した場合のバイトを取得するか、 &lt;code&gt;unpack(&quot;U0..&quot;, ...)&lt;/code&gt; することです。 UTF-8エンコーディングのバイトを取得するには：</target>
        </trans-unit>
        <trans-unit id="aa5979d9afcdae3acb920da4d4cb51dd1f70406d" translate="yes" xml:space="preserve">
          <source>One way to avoid namespace collisions in this scenario is to translate the filename into a guaranteed-unique package name, and then compile the code into that package using &lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;. In the example below, each file will only be compiled once. Or, the application might choose to clean out the symbol table associated with the file after it's no longer needed. Using &lt;a href=&quot;perlapi#call_argv&quot;&gt;call_argv in perlapi&lt;/a&gt;, We'll call the subroutine &lt;code&gt;Embed::Persistent::eval_file&lt;/code&gt; which lives in the file &lt;code&gt;persistent.pl&lt;/code&gt; and pass the filename and boolean cleanup/cache flag as arguments.</source>
          <target state="translated">このシナリオで名前空間の衝突を回避する1つの方法は、ファイル名を保証された一意のパッケージ名に変換し、次に&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;を使用してコードをそのパッケージにコンパイルすることです。以下の例では、各ファイルは一度だけコンパイルされます。または、アプリケーションは、不要になったファイルに関連付けられたシンボルテーブルを消去することを選択する場合があります。&lt;a href=&quot;perlapi#call_argv&quot;&gt;perlapi&lt;/a&gt;でcall_argvを使用して、ファイル &lt;code&gt;persistent.pl&lt;/code&gt; にあるサブルーチン &lt;code&gt;Embed::Persistent::eval_file&lt;/code&gt; を呼び出し、ファイル名とブール値のクリーンアップ/キャッシュフラグを引数として渡します。</target>
        </trans-unit>
        <trans-unit id="dd0896a1b110e7eaa3676883c702b6cfbe8bca14" translate="yes" xml:space="preserve">
          <source>One way to avoid namespace collisions in this scenario is to translate the filename into a guaranteed-unique package name, and then compile the code into that package using &lt;a href=&quot;perlfunc#eval&quot;&gt;&quot;eval&quot; in perlfunc&lt;/a&gt;. In the example below, each file will only be compiled once. Or, the application might choose to clean out the symbol table associated with the file after it's no longer needed. Using &lt;a href=&quot;perlapi#call_argv&quot;&gt;&quot;call_argv&quot; in perlapi&lt;/a&gt;, We'll call the subroutine &lt;code&gt;Embed::Persistent::eval_file&lt;/code&gt; which lives in the file &lt;code&gt;persistent.pl&lt;/code&gt; and pass the filename and boolean cleanup/cache flag as arguments.</source>
          <target state="translated">このシナリオで名前空間の衝突を回避する1つの方法は、ファイル名を保証された一意のパッケージ名に変換してから&lt;a href=&quot;perlfunc#eval&quot;&gt;、perlfuncの「eval」&lt;/a&gt;を使用してコードをそのパッケージにコンパイルすることです。以下の例では、各ファイルは1回だけコンパイルされます。または、アプリケーションは、ファイルが不要になった後、ファイルに関連付けられているシンボルテーブルをクリーンアップすることを選択する場合があります。&lt;a href=&quot;perlapi#call_argv&quot;&gt;perlapi&lt;/a&gt;で「call_argv」を使用して、 &lt;code&gt;persistent.pl&lt;/code&gt; ファイルにあるサブルーチン &lt;code&gt;Embed::Persistent::eval_file&lt;/code&gt; を呼び出し、ファイル名とブール値のクリーンアップ/キャッシュフラグを引数として渡します。</target>
        </trans-unit>
        <trans-unit id="3bf742d4fed91595248e4e766bfc873dce09be23" translate="yes" xml:space="preserve">
          <source>One way to do this is to inject a rare call somewhere near what you're looking for. For example, you could add &lt;code&gt;&lt;a href=&quot;functions/study&quot;&gt;study&lt;/a&gt;&lt;/code&gt; before your method:</source>
          <target state="translated">これを行う1つの方法は、探しているものの近くのどこかにまれな呼び出しを挿入することです。たとえば、メソッドの前に &lt;code&gt;&lt;a href=&quot;functions/study&quot;&gt;study&lt;/a&gt;&lt;/code&gt; 追加できます。</target>
        </trans-unit>
        <trans-unit id="676f2533e9c53ebcfbdadc653fb856c314a5321b" translate="yes" xml:space="preserve">
          <source>One way to do this is to inject a rare call somewhere near what you're looking for. For example, you could add &lt;code&gt;study&lt;/code&gt; before your method:</source>
          <target state="translated">これを行う1つの方法は、探しているものの近くにまれな呼び出しを挿入することです。たとえば、メソッドの前に &lt;code&gt;study&lt;/code&gt; 追加できます。</target>
        </trans-unit>
        <trans-unit id="2f4920008fd4d756e499ea61ff8d38a964bd84a8" translate="yes" xml:space="preserve">
          <source>One way to find out how much memory is being used by Perl data structures is to install the Devel::Size module from CPAN: it gives you the minimum number of bytes required to store a particular data structure. Please be mindful of the difference between the size() and total_size().</source>
          <target state="translated">Perl のデータ構造体がどれだけのメモリを使用しているかを知る方法の一つとして、CPAN から Devel::Size モジュールをインストールすることがあります。size()と total_size()の違いに注意してください。</target>
        </trans-unit>
        <trans-unit id="00322fdac947c21ed0522e06d3fcf307d762cdd8" translate="yes" xml:space="preserve">
          <source>One way to get around this macro hell is to use the dumping functions in</source>
          <target state="translated">このマクロ地獄を回避する一つの方法は、次のようなダンプ関数を使うことです。</target>
        </trans-unit>
        <trans-unit id="eeda9b7821d8b2cc38107791f4013f43a6f0fb4b" translate="yes" xml:space="preserve">
          <source>One way you can contribute is to send test results for each module that you install. If you install the CPAN::Reporter module, you have the option to automatically generate and deliver test reports to CPAN Testers whenever you run tests on a CPAN package.</source>
          <target state="translated">貢献できる方法の1つは、インストールした各モジュールのテスト結果を送信することです。CPAN::Reporterモジュールをインストールした場合、CPANパッケージでテストを実行するたびに、テストレポートを自動的に生成してCPANテスターに配信するオプションがあります。</target>
        </trans-unit>
        <trans-unit id="31e7d725bdb8f49cf001861a4a5f8e1249780511" translate="yes" xml:space="preserve">
          <source>One work around is to apply encodings to STDOUT and STDERR as early as possible and before Test::More (or any other Test module) loads.</source>
          <target state="translated">回避策としては、できるだけ早く、Test::More(または他のテストモジュール)がロードされる前に、STDOUTとSTDERRにエンコーディングを適用することです。</target>
        </trans-unit>
        <trans-unit id="32a8b32d9a6fd88cc288ea2d28ee5e2eb22aa577" translate="yes" xml:space="preserve">
          <source>One would use either of these:</source>
          <target state="translated">どちらかを使うことになります。</target>
        </trans-unit>
        <trans-unit id="d2c29e5eed5921eb0c039672d0a71cd9e82eb212" translate="yes" xml:space="preserve">
          <source>One-Liner Command tips</source>
          <target state="translated">ワンライナーコマンドのコツ</target>
        </trans-unit>
        <trans-unit id="c123784569a1603a8fb4810445cb2d1918c306b4" translate="yes" xml:space="preserve">
          <source>One-argument system() (see &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;), exec() (see &lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;) with redirection or shell meta-characters;</source>
          <target state="translated">リダイレクトまたはシェルのメタ文字を使用する1つの引数のsystem（）（&lt;a href=&quot;functions/system&quot;&gt;systemを&lt;/a&gt;参照）、exec（）（&lt;a href=&quot;functions/exec&quot;&gt;execを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="ed7881b6406ffe431f1d2534257a9ed284c28da6" translate="yes" xml:space="preserve">
          <source>One-argument system() (see &lt;a href=&quot;perlfunc#system&quot;&gt;&quot;system&quot; in perlfunc&lt;/a&gt;), exec() (see &lt;a href=&quot;perlfunc#exec&quot;&gt;&quot;exec&quot; in perlfunc&lt;/a&gt;) with redirection or shell meta-characters;</source>
          <target state="translated">リダイレクトまたは&lt;a href=&quot;perlfunc#exec&quot;&gt;シェルメタ&lt;/a&gt;文字を使用した1つの引数system（）（&lt;a href=&quot;perlfunc#system&quot;&gt;perlfuncの「system」を参照&lt;/a&gt;）、exec（）（perlfuncの「exec」を参照）。</target>
        </trans-unit>
        <trans-unit id="486e0bed310a26c3d92d0d575fbba324cf28a58e" translate="yes" xml:space="preserve">
          <source>One-line BLOCK may be put on one line, including curlies.</source>
          <target state="translated">カーリーを含めて1本のラインに1ラインBLOCKを入れることができます。</target>
        </trans-unit>
        <trans-unit id="58784e03024491cc3bfab913b657f51ddfe4ea02" translate="yes" xml:space="preserve">
          <source>One-way visibility means these firewalls try to make themselves invisible to users inside the firewall. An FTP data connection is normally created by sending your IP address to the remote server and then listening for the return connection. But the remote server will not be able to connect to you because of the firewall. For these types of firewall, FTP connections need to be done in a passive mode.</source>
          <target state="translated">一方向可視性とは、これらのファイアウォールがファイアウォール内のユーザーからは見えないようにしようとすることを意味します。FTP データ接続は通常、リモートサーバにあなたの IP アドレスを送信して、リターン接続を待つことで作成されます。しかし、リモートサーバはファイアウォールのためにあなたに接続することができません。このようなタイプのファイアウォールでは、FTP接続はパッシブモードで行う必要があります。</target>
        </trans-unit>
        <trans-unit id="e8b6f242edd1b92d8a41abce051eb1d237af2a29" translate="yes" xml:space="preserve">
          <source>Only 'chunked' &lt;code&gt;Transfer-Encoding&lt;/code&gt; is supported.</source>
          <target state="translated">'チャンクされた' &lt;code&gt;Transfer-Encoding&lt;/code&gt; のみがサポートされます。</target>
        </trans-unit>
        <trans-unit id="c61018f75253ce1e2ca9788d8ce3f56d39e963aa" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;#define&lt;/code&gt; symbols get translated; you must still correctly pack up your own arguments to pass as args for locking functions, etc.</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; シンボルのみが変換されます。ロック関数などの引数として渡すには、独自の引数を正しくパックする必要があります。</target>
        </trans-unit>
        <trans-unit id="67da903cfa08873440f868f7f70e613649689d61" translate="yes" xml:space="preserve">
          <source>Only &lt;code&gt;my&lt;/code&gt;/&lt;code&gt;our&lt;/code&gt; variable slots get valid names. The rest are op targets/GVs/constants which are statically allocated or resolved at compile time. These don't have names by which they can be looked up from Perl code at run time through eval&quot;&quot; the way &lt;code&gt;my&lt;/code&gt;/&lt;code&gt;our&lt;/code&gt; variables can be. Since they can't be looked up by &quot;name&quot; but only by their index allocated at compile time (which is usually in &lt;code&gt;PL_op-&amp;gt;op_targ&lt;/code&gt;), wasting a name SV for them doesn't make sense.</source>
          <target state="translated">&lt;code&gt;my&lt;/code&gt; / &lt;code&gt;our&lt;/code&gt; 変数スロットだけが有効な名前を取得します。残りは、コンパイル時に静的に割り当てられるか解決されるopターゲット/ GV /定数です。これらは、彼らが道「」のevalによって、実行時にPerlコードから見上げすることが可能な名前がありません &lt;code&gt;my&lt;/code&gt; / &lt;code&gt;our&lt;/code&gt; 変数をすることができます。それらは「名前」では検索できず、コンパイル時に割り当てられたインデックス（通常は &lt;code&gt;PL_op-&amp;gt;op_targ&lt;/code&gt; にあります）でのみ検索できるため、名前SVを無駄にすることは意味がありません。</target>
        </trans-unit>
        <trans-unit id="54e17eb2662bd037dd06b791727211df88880e9a" translate="yes" xml:space="preserve">
          <source>Only Intel C++ Compiler v12.1 has been tested. Other versions probably will work. Using Intel C++ Compiler instead of Visual C has the benefit of C99 compatibility which is needed by some CPAN XS modules, while maintaining compatibility with Visual C object code and Visual C debugging infrastructure unlike GCC.</source>
          <target state="translated">インテル® C++コンパイラー v12.1 のみがテストされています。他のバージョンでも動作する可能性があります。Visual C の代わりにインテル® C++コンパイラーを使用すると、GCC とは異なり、Visual C オブジェクトコードと Visual C デバッグインフラストラクチャとの互換性を維持しながら、一部の CPAN XS モジュールで必要とされる C99 互換性が得られます。</target>
        </trans-unit>
        <trans-unit id="2928fa0640b76bf7cac1897ae55dedc071303baa" translate="yes" xml:space="preserve">
          <source>Only a few characters (all of them being ASCII punctuation characters) are metacharacters. The most commonly used one is a dot &lt;code&gt;&quot;.&quot;&lt;/code&gt;, which normally matches almost any character (including a dot itself).</source>
          <target state="translated">メタ文字はごくわずかな文字（すべてASCII句読文字）です。最も一般的に使用されるのはドット &lt;code&gt;&quot;.&quot;&lt;/code&gt; 、通常、ほとんどすべての文字（ドット自体を含む）に一致します。</target>
        </trans-unit>
        <trans-unit id="833cc9382a3040aac18b72415747288176c0756d" translate="yes" xml:space="preserve">
          <source>Only available in 5.9 and later.</source>
          <target state="translated">5.9以降でのみ利用可能です。</target>
        </trans-unit>
        <trans-unit id="30aa8b56cc2760e31377798957b93c84973ea0a2" translate="yes" xml:space="preserve">
          <source>Only certain operations (all originating outside Perl) should be affected, as follows:</source>
          <target state="translated">以下のように、特定の操作(すべてPerlの外部からの操作)のみが影響を受けるべきです。</target>
        </trans-unit>
        <trans-unit id="791c96ad0d89f4c2a397055a16ea908da3689beb" translate="yes" xml:space="preserve">
          <source>Only certain operations originating outside Perl should be affected, as follows:</source>
          <target state="translated">以下のように、Perl の外部から発生した特定の操作のみが影響を受けるべきです。</target>
        </trans-unit>
        <trans-unit id="be338b7ec52f196b66facaa0396ba0dea14b732e" translate="yes" xml:space="preserve">
          <source>Only gives you a reader, no &lt;code&gt;set_foo&lt;/code&gt; method is defined at all.</source>
          <target state="translated">リーダーを提供するだけで、 &lt;code&gt;set_foo&lt;/code&gt; メソッドはまったく定義されていません。</target>
        </trans-unit>
        <trans-unit id="8dc54816219df4139d06acf1bbc8f828314bd1c1" translate="yes" xml:space="preserve">
          <source>Only gives you a write (&lt;code&gt;set_foo&lt;/code&gt;), no &lt;code&gt;foo&lt;/code&gt; method is defined at all.</source>
          <target state="translated">書き込み（ &lt;code&gt;set_foo&lt;/code&gt; ）のみを提供し、 &lt;code&gt;foo&lt;/code&gt; メソッドはまったく定義されていません。</target>
        </trans-unit>
        <trans-unit id="332e2ea6f0f288093c9c025ee61a2877052c734b" translate="yes" xml:space="preserve">
          <source>Only good for changing &quot;owner&quot; and &quot;other&quot; read-write access. (RISC OS)</source>
          <target state="translated">オーナー」と「その他」の読み書きアクセスを変更するのにのみ有効です。(RISC OS)</target>
        </trans-unit>
        <trans-unit id="066c19c4ab7873f5036df4d41c91cf9966174fcb" translate="yes" xml:space="preserve">
          <source>Only good for changing &quot;owner&quot; read-write access, &quot;group&quot;, and &quot;other&quot; bits are meaningless. (Win32)</source>
          <target state="translated">所有者」の読み書きアクセス、「グループ」、「その他」のビットは意味がないので、変更するだけで良い。(Win32)</target>
        </trans-unit>
        <trans-unit id="e35c0d1762bd110103b5f686e3235899e75efbd0" translate="yes" xml:space="preserve">
          <source>Only hexadecimal digits are valid between the braces. If an invalid character is encountered, a warning will be issued and the invalid character and all subsequent characters (valid or invalid) within the braces will be discarded.</source>
          <target state="translated">中括弧の間には16進数の数字のみが有効です。無効な文字が検出された場合、警告が表示され、無効な文字と中括弧内の後続のすべての文字(有効か無効かを問わず)が破棄されます。</target>
        </trans-unit>
        <trans-unit id="575a185473fa8007dc4a01bd9786576149895549" translate="yes" xml:space="preserve">
          <source>Only hexadecimal digits are valid following &lt;code&gt;\x&lt;/code&gt; . When &lt;code&gt;\x&lt;/code&gt; is followed by fewer than two valid digits, any valid digits will be zero-padded. This means that &lt;code&gt;\x7&lt;/code&gt; will be interpreted as &lt;code&gt;\x07&lt;/code&gt; , and a lone &lt;code&gt;&quot;\x&quot;&lt;/code&gt; will be interpreted as &lt;code&gt;\x00&lt;/code&gt; . Except at the end of a string, having fewer than two valid digits will result in a warning. Note that although the warning says the illegal character is ignored, it is only ignored as part of the escape and will still be used as the subsequent character in the string. For example:</source>
          <target state="translated">&lt;code&gt;\x&lt;/code&gt; 後には16進数のみが有効です。とき &lt;code&gt;\x&lt;/code&gt; より少ない2つの有効数字が続き、任意の有効な桁はゼロ詰めになります。つまり、 &lt;code&gt;\x7&lt;/code&gt; は &lt;code&gt;\x07&lt;/code&gt; として解釈され、単一の &lt;code&gt;&quot;\x&quot;&lt;/code&gt; は &lt;code&gt;\x00&lt;/code&gt; として解釈されます。文字列の末尾を除いて、有効な数字が2桁未満の場合は警告が表示されます。警告は、不正な文字は無視されることを示していますが、エスケープの一部としてのみ無視され、文字列の後続の文字として引き続き使用されることに注意してください。例えば：</target>
        </trans-unit>
        <trans-unit id="2b0998a6fdfd5f4525206c6e0b3be59bf209f58a" translate="yes" xml:space="preserve">
          <source>Only hexadecimal digits are valid following &lt;code&gt;\x&lt;/code&gt;. When &lt;code&gt;\x&lt;/code&gt; is followed by fewer than two valid digits, any valid digits will be zero-padded. This means that &lt;code&gt;\x7&lt;/code&gt; will be interpreted as &lt;code&gt;\x07&lt;/code&gt;, and a lone &lt;code&gt;&quot;\x&quot;&lt;/code&gt; will be interpreted as &lt;code&gt;\x00&lt;/code&gt;. Except at the end of a string, having fewer than two valid digits will result in a warning. Note that although the warning says the illegal character is ignored, it is only ignored as part of the escape and will still be used as the subsequent character in the string. For example:</source>
          <target state="translated">&lt;code&gt;\x&lt;/code&gt; 後には16進数のみが有効です。とき &lt;code&gt;\x&lt;/code&gt; より少ない2つの有効数字が続き、任意の有効な桁はゼロ詰めになります。これは、 &lt;code&gt;\x7&lt;/code&gt; が &lt;code&gt;\x07&lt;/code&gt; として解釈され、単独の &lt;code&gt;&quot;\x&quot;&lt;/code&gt; が &lt;code&gt;\x00&lt;/code&gt; として解釈されることを意味します。文字列の末尾を除いて、有効な数字が2桁未満の場合は、警告が表示されます。警告には、不正な文字は無視されると記載されていますが、エスケープの一部としてのみ無視され、文字列の後続の文字として引き続き使用されることに注意してください。例えば：</target>
        </trans-unit>
        <trans-unit id="6fefd95a29f89da3d95e7f9f02daa15254f112a5" translate="yes" xml:space="preserve">
          <source>Only identifiers starting with letters (or underscore) are stored in a package's symbol table. All other symbols are kept in package &lt;code&gt;main&lt;/code&gt; , including all punctuation variables, like $_. In addition, when unqualified, the identifiers STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC, and SIG are forced to be in package &lt;code&gt;main&lt;/code&gt; , even when used for other purposes than their built-in ones. If you have a package called &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, then you can't use the qualified form of an identifier because it would be instead interpreted as a pattern match, a substitution, or a transliteration.</source>
          <target state="translated">文字（またはアンダースコア）で始まる識別子のみがパッケージのシンボルテーブルに格納されます。他のすべての記号は、$ _などのすべての句読点変数を含め、パッケージ &lt;code&gt;main&lt;/code&gt; に保持されます。さらに、修飾されていない場合、識別子STDIN、STDOUT、STDERR、ARGV、ARGVOUT、ENV、INC、およびSIGは、組み込みのもの以外の目的で使用されている場合でも、パッケージ &lt;code&gt;main&lt;/code&gt; に強制的に含まれます。 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; と呼ばれるパッケージがある場合、識別子の修飾形式は、パターンマッチ、置換、または音訳として解釈されるため、使用できません。</target>
        </trans-unit>
        <trans-unit id="5258552aeae790433b734336886e3f62b2ea5d9a" translate="yes" xml:space="preserve">
          <source>Only identifiers starting with letters (or underscore) are stored in a package's symbol table. All other symbols are kept in package &lt;code&gt;main&lt;/code&gt;, including all punctuation variables, like $_. In addition, when unqualified, the identifiers STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC, and SIG are forced to be in package &lt;code&gt;main&lt;/code&gt;, even when used for other purposes than their built-in ones. If you have a package called &lt;code&gt;m&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, or &lt;code&gt;y&lt;/code&gt;, then you can't use the qualified form of an identifier because it would be instead interpreted as a pattern match, a substitution, or a transliteration.</source>
          <target state="translated">パッケージのシンボルテーブルには、文字（またはアンダースコア）で始まる識別子のみが格納されます。$ _などのすべての句読点変数を含め、他のすべての記号はパッケージ &lt;code&gt;main&lt;/code&gt; に保持されます。さらに、修飾されていない場合、識別子STDIN、STDOUT、STDERR、ARGV、ARGVOUT、ENV、INC、およびSIGは、組み込み以外の目的で使用された場合でも、パッケージ &lt;code&gt;main&lt;/code&gt; に強制的に含まれます。 &lt;code&gt;m&lt;/code&gt; 、 &lt;code&gt;s&lt;/code&gt; 、または &lt;code&gt;y&lt;/code&gt; というパッケージがある場合、識別子の修飾形式は使用できません。代わりに、パターンマッチ、置換、または音訳として解釈されるためです。</target>
        </trans-unit>
        <trans-unit id="9758de0e100772430c6fab7d629b550064e3e906" translate="yes" xml:space="preserve">
          <source>Only implemented on sockets. (Win32, VMS)</source>
          <target state="translated">ソケットのみに実装されています。(Win32,VMS)</target>
        </trans-unit>
        <trans-unit id="59e3f78d233739ccaf48b169b4ca0ebaefa1c7ab" translate="yes" xml:space="preserve">
          <source>Only in very early releases; is a subset of</source>
          <target state="translated">非常に初期のリリースでのみ、以下のサブセットがあります。</target>
        </trans-unit>
        <trans-unit id="e3b46eafe2952d2a80f0f05636b70051fd116c6a" translate="yes" xml:space="preserve">
          <source>Only in very rare circumstances should code need to be dealing in Unicode (as opposed to native) code points. In those few cases, use &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">非常にまれな状況でのみ、コードは（ネイティブではなく）Unicodeコードポイントで処理する必要があります。これらのいくつかのケースでは、代わりに &lt;code&gt;&lt;a href=&quot;#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="b1d353340ff172b5c39b6a28e69782441add5fac" translate="yes" xml:space="preserve">
          <source>Only in very rare circumstances should code need to be dealing in Unicode (as opposed to native) code points. In those few cases, use &lt;code&gt;&lt;a href=&quot;perlapi#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; instead. If you are not absolutely sure this is one of those cases, then assume it isn't and use plain &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; instead.</source>
          <target state="translated">非常にまれな状況でのみ、コードは（ネイティブではなく）Unicodeコードポイントを処理する必要があります。これらのいくつかのケースでは、代わりに &lt;code&gt;&lt;a href=&quot;perlapi#utf8_to_uvchr_buf&quot;&gt;NATIVE_TO_UNI(utf8_to_uvchr_buf(...))&lt;/a&gt;&lt;/code&gt; を使用してください。これがそのようなケースの1つであるかどうかが完全にわからない場合は、そうではないと想定し、代わりにプレーンな &lt;code&gt;utf8_to_uvchr_buf&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="f7a2ea2fb860587376b8c211541f4f73f5bfc66a" translate="yes" xml:space="preserve">
          <source>Only log errors:</source>
          <target state="translated">エラーのログのみ。</target>
        </trans-unit>
        <trans-unit id="150ec79437779628315de700ea569bc7019ae33a" translate="yes" xml:space="preserve">
          <source>Only meaningful if PADNAMEt_OUTER is set.</source>
          <target state="translated">PADNAMEt_OUTERが設定されている場合にのみ意味を持ちます。</target>
        </trans-unit>
        <trans-unit id="b3938c3e89a8c33d91a1c3ac566ca87a5a31bade" translate="yes" xml:space="preserve">
          <source>Only my/our variable slots get valid names. The rest are op targets/GVs/constants which are statically allocated or resolved at compile time. These don't have names by which they can be looked up from Perl code at run time through eval&quot;&quot; the way my/our variables can be. Since they can't be looked up by &quot;name&quot; but only by their index allocated at compile time (which is usually in PL_op-&amp;gt;op_targ), wasting a name SV for them doesn't make sense.</source>
          <target state="translated">私/私たちの可変スロットのみが有効な名前を取得します。残りは、コンパイル時に静的に割り当てられるか解決されるopターゲット/ GV /定数です。これらには、私の変数ができるように、実行時にPerlコードからevalを介して検索できる名前はありません。それらは「名前」では検索できず、コンパイル時に割り当てられたインデックス（通常はPL_op-&amp;gt; op_targにある）でのみ検索できるため、名前SVを浪費しても意味がありません。</target>
        </trans-unit>
        <trans-unit id="1f33cd4a2033d06e1657cc72bf00ffb7bbc8903a" translate="yes" xml:space="preserve">
          <source>Only on VMS (where there is no ambiguity between the file and directory portions of a path) and AmigaOS (possibly due to an implementation quirk in this module) does &lt;code&gt;dirname()&lt;/code&gt; work like &lt;code&gt;fileparse($path)&lt;/code&gt; , returning just the $dirs.</source>
          <target state="translated">VMS（パスのファイル部分とディレクトリ部分のあいまいさがない場合）とAmigaOS（おそらくこのモジュールの実装の癖のため &lt;code&gt;fileparse($path)&lt;/code&gt; でのみ、 &lt;code&gt;dirname()&lt;/code&gt; はfileparse（$ path）のように機能し、$ dirsのみを返します。</target>
        </trans-unit>
        <trans-unit id="3f431144993e10d84cbfadd9a3e65deba1582a5e" translate="yes" xml:space="preserve">
          <source>Only on VMS (where there is no ambiguity between the file and directory portions of a path) and AmigaOS (possibly due to an implementation quirk in this module) does &lt;code&gt;dirname()&lt;/code&gt; work like &lt;code&gt;fileparse($path)&lt;/code&gt;, returning just the $dirs.</source>
          <target state="translated">VMS（パスのファイル部分とディレクトリ部分の間にあいまいさがない）とAmigaOS（おそらくこのモジュールの実装の癖のため &lt;code&gt;fileparse($path)&lt;/code&gt; でのみ、 &lt;code&gt;dirname()&lt;/code&gt; はfileparse（$ path）のように機能し、$ dirだけを返します。</target>
        </trans-unit>
        <trans-unit id="cb371934ef388875a4c4834fa50d202d61748f1c" translate="yes" xml:space="preserve">
          <source>Only one encoding is allowed. If you combine modules in a program that have different encodings, only one will be actually used.</source>
          <target state="translated">エンコーディングは1つだけ許可されています。異なるエンコーディングを持つモジュールをプログラム内で組み合わせた場合、実際には1つのエンコーディングのみが使用されます。</target>
        </trans-unit>
        <trans-unit id="99a4e5aa3778d9b7cf73bb7582fb4140a87cc1e7" translate="yes" xml:space="preserve">
          <source>Only one timer may be counting at once. Each call disables the previous timer, and an argument of &lt;code&gt;0&lt;/code&gt; may be supplied to cancel the previous timer without starting a new one. The returned value is the amount of time remaining on the previous timer.</source>
          <target state="translated">一度にカウントできるタイマーは1つだけです。各呼び出しは前のタイマーを無効にし、引数 &lt;code&gt;0&lt;/code&gt; を指定して、新しいタイマーを開始せずに前のタイマーをキャンセルできます。戻り値は、前のタイマーの残り時間です。</target>
        </trans-unit>
        <trans-unit id="f44c9ad6ed1548b5f164387565fa3e8cb708d77b" translate="yes" xml:space="preserve">
          <source>Only package variables (globals, even if localized) are visible to symbolic references. Lexical variables (declared with my()) aren't in a symbol table, and thus are invisible to this mechanism. For example:</source>
          <target state="translated">パッケージ変数 (ローカル化されていてもグローバル)のみがシンボリック参照に表示されます。字句変数 (my()で宣言されたもの)はシンボルテーブルにはないので、このメカニズムでは見えません。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="8a4fbadaeb2851f2ac1b0ed5194eefd55b4c5de6" translate="yes" xml:space="preserve">
          <source>Only read-accesses (via fetching the value or &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt;) result in calls to the functions; the modify-accesses are performed as on a normal hash.</source>
          <target state="translated">（値のフェッチまたは &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; を介した）読み取りアクセスのみが関数の呼び出しになります。変更アクセスは通常のハッシュのように実行されます。</target>
        </trans-unit>
        <trans-unit id="52379b3e8ed9b5889624849f89178e4a78f9060a" translate="yes" xml:space="preserve">
          <source>Only read-accesses (via fetching the value or &lt;code&gt;exists&lt;/code&gt;) result in calls to the functions; the modify-accesses are performed as on a normal hash.</source>
          <target state="translated">（値のフェッチまたは &lt;code&gt;exists&lt;/code&gt; を介した）読み取りアクセスのみが関数の呼び出しになります。変更アクセスは、通常のハッシュと同様に実行されます。</target>
        </trans-unit>
        <trans-unit id="b7947c4bc8660c246e83d1a75c7b2184fd12d7e5" translate="yes" xml:space="preserve">
          <source>Only reliable on sockets. (RISC OS)</source>
          <target state="translated">ソケットでのみ信頼性があります。(RISC OS)</target>
        </trans-unit>
        <trans-unit id="3d6a8b56f94127e52f27217f818b2868b3bb285a" translate="yes" xml:space="preserve">
          <source>Only some of these are used by the standard styles, the others are provided for you to delve into optree mechanics, should you wish to add a new style (see &lt;a href=&quot;#add_style&quot;&gt;&quot;add_style&quot;&lt;/a&gt; below) that uses them. You can also add new ones using &lt;a href=&quot;#add_callback&quot;&gt;&quot;add_callback&quot;&lt;/a&gt;.</source>
          <target state="translated">これらの一部のみが標準スタイルで使用され、その他は、それらを使用する新しいスタイル（以下の&lt;a href=&quot;#add_style&quot;&gt;「add_style」を&lt;/a&gt;参照）を追加したい場合に、オプツリーの仕組みを詳しく調べるために提供されています。&lt;a href=&quot;#add_callback&quot;&gt;「add_callback」&lt;/a&gt;を使用して新しいものを追加することもできます。</target>
        </trans-unit>
        <trans-unit id="fdb6f92993012f8b0d4ace849f814451bcfe4e88" translate="yes" xml:space="preserve">
          <source>Only some of these are used by the standard styles, the others are provided for you to delve into optree mechanics, should you wish to add a new style (see &lt;a href=&quot;#add_style&quot;&gt;add_style&lt;/a&gt; below) that uses them. You can also add new ones using &lt;a href=&quot;#add_callback&quot;&gt;add_callback&lt;/a&gt;.</source>
          <target state="translated">これらの一部だけが標準スタイルで使用され、その他は、それらを使用する新しいスタイル（以下の&lt;a href=&quot;#add_style&quot;&gt;add_styleを&lt;/a&gt;参照）を追加したい場合に、optreeメカニズムを掘り下げるために提供されています。&lt;a href=&quot;#add_callback&quot;&gt;add_callback&lt;/a&gt;を使用して新しいものを追加することもできます。</target>
        </trans-unit>
        <trans-unit id="e48dbe443fdc8ea64a9d98b0d46ac35972125215" translate="yes" xml:space="preserve">
          <source>Only supported if the &lt;code&gt;IO-Compress-Bzip2&lt;/code&gt; module is installed.</source>
          <target state="translated">&lt;code&gt;IO-Compress-Bzip2&lt;/code&gt; モジュールがインストールされている場合にのみサポートされます。</target>
        </trans-unit>
        <trans-unit id="b2aad383963ab78287aafa9360d0376650b94059" translate="yes" xml:space="preserve">
          <source>Only supported if the &lt;code&gt;IO-Compress-Lzma&lt;/code&gt; module is installed.</source>
          <target state="translated">&lt;code&gt;IO-Compress-Lzma&lt;/code&gt; モジュールがインストールされている場合にのみサポートされます。</target>
        </trans-unit>
        <trans-unit id="fe3b6a74b3cb931875055e55d8dd7ade28775580" translate="yes" xml:space="preserve">
          <source>Only text files containing at least one valid POD command are found.</source>
          <target state="translated">少なくとも1つの有効なPODコマンドを含むテキストファイルのみが検出されます。</target>
        </trans-unit>
        <trans-unit id="f768ea168f773a1d4344405cac8e79c05d1cb7bc" translate="yes" xml:space="preserve">
          <source>Only the &lt;code&gt;&quot;\&quot;&lt;/code&gt; is always a metacharacter. The others are metacharacters just sometimes. The following tables lists all of them, summarizes their use, and gives the contexts where they are metacharacters. Outside those contexts or if prefixed by a &lt;code&gt;&quot;\&quot;&lt;/code&gt;, they match their corresponding punctuation character. In some cases, their meaning varies depending on various pattern modifiers that alter the default behaviors. See &lt;a href=&quot;#Modifiers&quot;&gt;&quot;Modifiers&quot;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;\&quot;&lt;/code&gt; のみが常にメタ文字です。その他は時々メタ文字です。次の表に、それらすべてをリストし、それらの使用法を要約し、それらがメタ文字であるコンテキストを示します。これらのコンテキストの外側、または接頭辞 &lt;code&gt;&quot;\&quot;&lt;/code&gt; 付いている場合は、対応する句読文字と一致します。場合によっては、デフォルトの動作を変更するさまざまなパターン修飾子によって意味が異なります。&lt;a href=&quot;#Modifiers&quot;&gt;「修飾子」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d9f9d19343c8e9d3fc7cfa076da595c837a27fd3" translate="yes" xml:space="preserve">
          <source>Only the INPUT part of this is implemented (Perl to XSUB) and there are no known users in core or on CPAN.</source>
          <target state="translated">INPUT部分のみ実装されており(Perl to XSUB)、コアにもCPANにも既知のユーザはいません。</target>
        </trans-unit>
        <trans-unit id="71019c006a2a3164840206c64e5cdd82e48eb2b0" translate="yes" xml:space="preserve">
          <source>Only the best match for &lt;code&gt;&quot;S&quot;&lt;/code&gt; is considered. (This is important only if &lt;code&gt;&quot;S&quot;&lt;/code&gt; has capturing parentheses, and backreferences are used somewhere else in the whole regular expression.)</source>
          <target state="translated">&lt;code&gt;&quot;S&quot;&lt;/code&gt; 最適なもののみが考慮されます。（これは、 &lt;code&gt;&quot;S&quot;&lt;/code&gt; にキャプチャ括弧があり、正規表現全体のどこかで後方参照が使用されている場合にのみ重要です。）</target>
        </trans-unit>
        <trans-unit id="3e92fe265d981838f6731ee2a1313d924147a101" translate="yes" xml:space="preserve">
          <source>Only the best match for &lt;code&gt;S&lt;/code&gt; is considered. (This is important only if &lt;code&gt;S&lt;/code&gt; has capturing parentheses, and backreferences are used somewhere else in the whole regular expression.)</source>
          <target state="translated">&lt;code&gt;S&lt;/code&gt; の最適な一致のみが考慮されます。（これは、 &lt;code&gt;S&lt;/code&gt; にキャプチャ括弧があり、正規表現全体のどこかで後方参照が使用されている場合にのみ重要です。）</target>
        </trans-unit>
        <trans-unit id="8e81698472dd458b4e2c811d33c204c45a731d7f" translate="yes" xml:space="preserve">
          <source>Only the latest runtime is supported, currently &lt;code&gt;0.9d fix 03&lt;/code&gt;. Perl may run under earlier versions of EMX, but this is not tested.</source>
          <target state="translated">サポートされているのは最新のランタイムのみで、現在は &lt;code&gt;0.9d fix 03&lt;/code&gt; です。Perlは以前のバージョンのEMXで実行できますが、これはテストされていません。</target>
        </trans-unit>
        <trans-unit id="ffed3ab3981beea3a9602d82e26d788b9e9c1484" translate="yes" xml:space="preserve">
          <source>Only the modification time is updated. (VMS, RISC OS)</source>
          <target state="translated">修正時間のみ更新されます。(VMS,RISC OS)</target>
        </trans-unit>
        <trans-unit id="a5196d88a77f964c944cd0486d4d8632d3d224b8" translate="yes" xml:space="preserve">
          <source>Only the values for English are returned. &lt;code&gt;YESSTR&lt;/code&gt; and &lt;code&gt;NOSTR&lt;/code&gt; have been removed from POSIX 2008, and are retained here for backwards compatibility. Your platform's &lt;code&gt;nl_langinfo&lt;/code&gt; may not support them.</source>
          <target state="translated">英語の値のみが返されます。 &lt;code&gt;YESSTR&lt;/code&gt; と &lt;code&gt;NOSTR&lt;/code&gt; はPOSIX2008から削除され、下位互換性のためにここに保持されています。プラットフォームの &lt;code&gt;nl_langinfo&lt;/code&gt; がそれらをサポートしていない可能性があります。</target>
        </trans-unit>
        <trans-unit id="9aa8446a580db25edb8f05217d7fb57147e13abf" translate="yes" xml:space="preserve">
          <source>Only up to Perl 5.9.4</source>
          <target state="translated">Perl 5.9.4までのみ</target>
        </trans-unit>
        <trans-unit id="ac1ac5484f948b783774a56425a6df37a8f81a3b" translate="yes" xml:space="preserve">
          <source>Only valid on r-magic, returns the integer value of the REGEX stored in the MAGIC.</source>
          <target state="translated">r-magicでのみ有効で、MAGICに格納されているREGEXの整数値を返します。</target>
        </trans-unit>
        <trans-unit id="9f66fc81372c8ac766a246f4baea414733aad7cf" translate="yes" xml:space="preserve">
          <source>Only valid on r-magic, returns the string that generated the regexp.</source>
          <target state="translated">r-magicでのみ有効で、正規表現を生成した文字列を返します。</target>
        </trans-unit>
        <trans-unit id="b4b3937a0e7df666bbee5731bdcd7cfebd5a56b8" translate="yes" xml:space="preserve">
          <source>Only votes if $source is an array, or a scalar with newlines. Casts the following votes:</source>
          <target state="translated">source が配列、または改行のあるスカラの場合のみ投票します。以下の投票を行います。</target>
        </trans-unit>
        <trans-unit id="cc6f39472d96fc49b5d83aad7e124fec307fa8f3" translate="yes" xml:space="preserve">
          <source>Only votes if $source looks like a file. Casts the following votes:</source>
          <target state="translated">ソースがファイルのように見える場合にのみ投票します。以下の投票を行います。</target>
        </trans-unit>
        <trans-unit id="977cc058c727306e27dd1d2114879e4b0b58691f" translate="yes" xml:space="preserve">
          <source>Only votes if $source looks like a regular file. Casts the following votes:</source>
          <target state="translated">ソースが通常のファイルのように見える場合のみ投票します。以下の投票を行います。</target>
        </trans-unit>
        <trans-unit id="30aa9fef235074c84d54a1603c93e02bcc5a7db6" translate="yes" xml:space="preserve">
          <source>Only votes if $source looks like an executable file. Casts the following votes:</source>
          <target state="translated">ソースが実行ファイルのように見える場合にのみ投票します。以下の投票を行います。</target>
        </trans-unit>
        <trans-unit id="a61aeee0d09958da7f9004eaa2f24e389c377add" translate="yes" xml:space="preserve">
          <source>Only when perl was compiled with ithreads.</source>
          <target state="translated">perlがithreadsでコンパイルされていた場合のみ。</target>
        </trans-unit>
        <trans-unit id="cd0ef3273488ddac67311854e00313faa5aef30e" translate="yes" xml:space="preserve">
          <source>Oodles of very useful information in there - this seems to be the way forward.</source>
          <target state="translated">そこには非常に有益な情報がたくさんあります。</target>
        </trans-unit>
        <trans-unit id="95ff9f7a98d97e5bb7dd5d8797ddd23ecbc3a49a" translate="yes" xml:space="preserve">
          <source>Oops, we forgot one thing: what if there are spaces at the start of the pattern? &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;  U*&quot;, @stuff)&lt;/code&gt; will have &lt;code&gt;U&lt;/code&gt; as the first active character, even though it's not the first thing in the pattern. In this case, we have to advance &lt;code&gt;patcopy&lt;/code&gt; along with &lt;code&gt;pat&lt;/code&gt; when we see spaces:</source>
          <target state="translated">おっと、1つ忘れていました。パターンの先頭にスペースがある場合はどうなりますか？ &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot; U*&quot;, @stuff)&lt;/code&gt; は、パターンの最初のものではありませんが、最初のアクティブな文字として &lt;code&gt;U&lt;/code&gt; を持ちます。この場合、スペースが表示され &lt;code&gt;patcopy&lt;/code&gt; 、 &lt;code&gt;pat&lt;/code&gt; とともにpatcopyを進める必要があります。</target>
        </trans-unit>
        <trans-unit id="fe3ce4b3ad2d706be60b57c6678f0db7ee5828e3" translate="yes" xml:space="preserve">
          <source>Oops, we forgot one thing: what if there are spaces at the start of the pattern? &lt;code&gt;pack(&quot; U*&quot;, @stuff)&lt;/code&gt; will have &lt;code&gt;U&lt;/code&gt; as the first active character, even though it's not the first thing in the pattern. In this case, we have to advance &lt;code&gt;patcopy&lt;/code&gt; along with &lt;code&gt;pat&lt;/code&gt; when we see spaces:</source>
          <target state="translated">おっと、私たちは1つのことを忘れました：パターンの先頭にスペースがある場合はどうなりますか？ &lt;code&gt;pack(&quot; U*&quot;, @stuff)&lt;/code&gt; は、パターンの最初のものではありませんが、最初のアクティブな文字として &lt;code&gt;U&lt;/code&gt; を持ちます。この場合、スペースが表示され &lt;code&gt;patcopy&lt;/code&gt; 、 &lt;code&gt;pat&lt;/code&gt; と一緒にpatcopyを進める必要があります。</target>
        </trans-unit>
        <trans-unit id="ce63b9b9665fa74c8ca88979a5af8db7577060be" translate="yes" xml:space="preserve">
          <source>OpHAS_SIBLING</source>
          <target state="translated">OpHAS_SIBLING</target>
        </trans-unit>
        <trans-unit id="8df5fc95b743ffdf06c754aebef9648088f82a06" translate="yes" xml:space="preserve">
          <source>OpLASTSIB_set</source>
          <target state="translated">OpLASTSIB_set</target>
        </trans-unit>
        <trans-unit id="6a2ac06a5c16d049ff2c9de33162907d6eaa1974" translate="yes" xml:space="preserve">
          <source>OpMAYBESIB_set</source>
          <target state="translated">OpMAYBESIB_set</target>
        </trans-unit>
        <trans-unit id="95d54e30cf7a8a2ef55bbad2e9fb47bd84433509" translate="yes" xml:space="preserve">
          <source>OpMORESIB_set</source>
          <target state="translated">OpMORESIB_set</target>
        </trans-unit>
        <trans-unit id="ad6188b517e063a47318e5c2bad924c90d8e314e" translate="yes" xml:space="preserve">
          <source>OpSIBLING</source>
          <target state="translated">OpSIBLING</target>
        </trans-unit>
        <trans-unit id="74d23243f911dfb26f7142c0a3c3910d6d1436bc" translate="yes" xml:space="preserve">
          <source>Opcode</source>
          <target state="translated">Opcode</target>
        </trans-unit>
        <trans-unit id="d74efeac75c3ed1e29e1ef5d2a48fa327033703a" translate="yes" xml:space="preserve">
          <source>Opcode - Disable named opcodes when compiling perl code</source>
          <target state="translated">Opcode-perl コードをコンパイルする際に名前付きオペコードを無効にする</target>
        </trans-unit>
        <trans-unit id="f07e565d51e16d912b38ef0d870eb764e49b25e3" translate="yes" xml:space="preserve">
          <source>Opcode Functions</source>
          <target state="translated">オペコード機能</target>
        </trans-unit>
        <trans-unit id="cf9b77061f7b3126b49d50a6fa68f7ca8c26b7a3" translate="yes" xml:space="preserve">
          <source>Open</source>
          <target state="translated">Open</target>
        </trans-unit>
        <trans-unit id="96b61e5d9d0edd94f6948898f1398f5d478335a2" translate="yes" xml:space="preserve">
          <source>Open &quot;membername&quot; from the zip file for reading.</source>
          <target state="translated">zipファイルから「membername」を開いて読み込みます。</target>
        </trans-unit>
        <trans-unit id="55f7ee4c6a28ca478d6d447371d4c70238f47b16" translate="yes" xml:space="preserve">
          <source>Open /dev/tty and use the TIOCNOTTY ioctl on it. See</source>
          <target state="translated">dev/tty を開き、TIOCNOTTY ioctl を使用してください。を参照してください。</target>
        </trans-unit>
        <trans-unit id="bc45a01f475e91b2d1ed078654549eddc2aa2632" translate="yes" xml:space="preserve">
          <source>Open /dev/tty and use the TIOCNOTTY ioctl on it. See &lt;a href=&quot;http://man.he.net/man1/tty&quot;&gt;tty(1)&lt;/a&gt; for details. Or better yet, you can just use the &lt;code&gt;POSIX::setsid()&lt;/code&gt; function, so you don't have to worry about process groups.</source>
          <target state="translated">/ dev / ttyを開き、TIOCNOTTYioctlを使用します。詳細については、&lt;a href=&quot;http://man.he.net/man1/tty&quot;&gt;tty（1）&lt;/a&gt;を参照してください。さらに良いことに、 &lt;code&gt;POSIX::setsid()&lt;/code&gt; 関数を使用するだけなので、プロセスグループについて心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="bdb6e0b133b1b1b5b97afd41a0d0173daaa4add6" translate="yes" xml:space="preserve">
          <source>Open Edition (UNIX System Services) from V2R8 onward does support #!/path/to/perl script invocation. There is a PTF available from IBM for V2R7 that will allow shell/kernel support for #!. USS releases prior to V2R7 did not support the #! means of script invocation. If you are running V2R6 or earlier then see:</source>
          <target state="translated">V2R8以降のOpen Edition (UNIX System Services)では、#!/path/to/perlスクリプトの呼び出しをサポートしています。V2R7用にIBMから提供されているPTFを使用することで、#! V2R7以前のUSSリリースでは、スクリプト呼び出しの#! V2R6 またはそれ以前のバージョンをお使いの場合は、以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="adcf2a78c9cad4950930fad20f18fb46173fc5ee" translate="yes" xml:space="preserve">
          <source>Open Perl IDE</source>
          <target state="translated">オープンPerl IDE</target>
        </trans-unit>
        <trans-unit id="6a72f9cc67788da43d43bb9ed1f39ccdfc57b884" translate="yes" xml:space="preserve">
          <source>Open Perl IDE is an integrated development environment for writing and debugging Perl scripts with ActiveState's ActivePerl distribution under Windows 95/98/NT/2000.</source>
          <target state="translated">Open Perl IDEは、Windows 95/98/NT/2000でActiveState社のActivePerlディストリビューションを使用してPerlスクリプトを書いたりデバッグしたりするための統合開発環境です。</target>
        </trans-unit>
        <trans-unit id="23e95096990f8472afd6cb3709ce6af6451d33e6" translate="yes" xml:space="preserve">
          <source>Open a directory for reading.</source>
          <target state="translated">読み込み用のディレクトリを開きます。</target>
        </trans-unit>
        <trans-unit id="8ad49f69af5decd196c780b9f3d0aaa3e3816d7b" translate="yes" xml:space="preserve">
          <source>Open a file for read and write.</source>
          <target state="translated">読み書き用のファイルを開きます。</target>
        </trans-unit>
        <trans-unit id="1e59fee2b2d0c9f3865876e8e0e389d326d3f7c1" translate="yes" xml:space="preserve">
          <source>Open a file for reading for writing. This returns file descriptors, not Perl filehandles. Use &lt;code&gt;POSIX::close&lt;/code&gt; to close the file.</source>
          <target state="translated">書き込み用に読み取り用にファイルを開きます。これは、Perlファイルハンドルではなく、ファイル記述子を返します。 &lt;code&gt;POSIX::close&lt;/code&gt; を使用してファイルを閉じます。</target>
        </trans-unit>
        <trans-unit id="6c23e6c0a506e51b8807fe030bb649eaa2c7d5d5" translate="yes" xml:space="preserve">
          <source>Open a file for write, with truncation.</source>
          <target state="translated">書き込み用のファイルを切り捨てて開く。</target>
        </trans-unit>
        <trans-unit id="4308ff2808cb74655d1f6985fb86c3f779077365" translate="yes" xml:space="preserve">
          <source>Open a file read-only with mode 0666.</source>
          <target state="translated">モード0666で読み取り専用のファイルを開く。</target>
        </trans-unit>
        <trans-unit id="83b3247daf1ae38653a1c2f6dc56f1f4dd823340" translate="yes" xml:space="preserve">
          <source>Open a process for both reading and writing using open2()</source>
          <target state="translated">open2()を使って読み書き両方のプロセスを開く</target>
        </trans-unit>
        <trans-unit id="2f8a8512d160e2040075be8a77906336494c9074" translate="yes" xml:space="preserve">
          <source>Open a process for reading, writing, and error handling using open3()</source>
          <target state="translated">open3()を使って読み書きやエラー処理のためのプロセスを開く</target>
        </trans-unit>
        <trans-unit id="3de25d7ff3a7f69d51ceb431d7513e0facbf39f4" translate="yes" xml:space="preserve">
          <source>Open a shell on the Synology using ssh and become root.</source>
          <target state="translated">sshを使用してSynology上でシェルを開き、rootになります。</target>
        </trans-unit>
        <trans-unit id="46e426002e74b080358a024e5f7a561b3384b60d" translate="yes" xml:space="preserve">
          <source>Open directory handles</source>
          <target state="translated">オープンディレクトリの取り扱い</target>
        </trans-unit>
        <trans-unit id="f4a5a34e79d6531a1ea990bc264a097033a1025e" translate="yes" xml:space="preserve">
          <source>Open filehandles</source>
          <target state="translated">ファイルハンドルを開く</target>
        </trans-unit>
        <trans-unit id="92666893f36170e45fd93845fbf133686bc20a39" translate="yes" xml:space="preserve">
          <source>Open handles to files, directories and network sockets</source>
          <target state="translated">ファイル、ディレクトリ、ネットワークソケットへのオープンハンドル</target>
        </trans-unit>
        <trans-unit id="79ce744f7faf84a934a5966a77055041e905f34c" translate="yes" xml:space="preserve">
          <source>Open returns nonzero on success, the undefined value otherwise. If the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; involved a pipe, the return value happens to be the pid of the subprocess.</source>
          <target state="translated">Openは成功するとゼロ以外を返し、それ以外の場合は未定義の値を返します。 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; にパイプが含まれる場合、戻り値はたまたまサブプロセスのPIDです。</target>
        </trans-unit>
        <trans-unit id="78b623ce85a0de7052165209a2216ebe49f4e867" translate="yes" xml:space="preserve">
          <source>Open returns nonzero on success, the undefined value otherwise. If the &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; involved a pipe, the return value happens to be the pid of the subprocess.</source>
          <target state="translated">Openは成功するとゼロ以外を返し、それ以外の場合は未定義の値を返します。 &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; にパイプが含まれる場合、戻り値はたまたまサブプロセスのPIDです。</target>
        </trans-unit>
        <trans-unit id="f405ae83374967e27b5349888fde9a222df40df7" translate="yes" xml:space="preserve">
          <source>Open returns nonzero on success, the undefined value otherwise. If the &lt;code&gt;open&lt;/code&gt; involved a pipe, the return value happens to be the pid of the subprocess.</source>
          <target state="translated">Openは、成功するとゼロ以外を返し、それ以外の場合は未定義の値を返します。場合は &lt;code&gt;open&lt;/code&gt; パイプを関与、戻り値は、サブプロセスのpidとなります。</target>
        </trans-unit>
        <trans-unit id="47834b64146be82f867d9923797633975d9cd92f" translate="yes" xml:space="preserve">
          <source>Open should (perhaps indirectly) call &lt;code&gt;PerlIO_allocate()&lt;/code&gt; to allocate a slot in the table and associate it with the layers information for the opened file, by calling &lt;code&gt;PerlIO_push&lt;/code&gt; . The</source>
          <target state="translated">オープンは、（おそらく間接的に）呼び出す必要 &lt;code&gt;PerlIO_allocate()&lt;/code&gt; を呼び出すことによって、テーブル内のスロットを割り当てて、開かれたファイルのためのレイヤ情報と関連付けする &lt;code&gt;PerlIO_push&lt;/code&gt; を。の</target>
        </trans-unit>
        <trans-unit id="6ae8476e410284d0c0ba1054077caf01d110fd6a" translate="yes" xml:space="preserve">
          <source>Open should (perhaps indirectly) call &lt;code&gt;PerlIO_allocate()&lt;/code&gt; to allocate a slot in the table and associate it with the layers information for the opened file, by calling &lt;code&gt;PerlIO_push&lt;/code&gt;. The</source>
          <target state="translated">オープンは、（おそらく間接的に）呼び出す必要 &lt;code&gt;PerlIO_allocate()&lt;/code&gt; を呼び出すことによって、テーブル内のスロットを割り当てて、開かれたファイルのためのレイヤ情報と関連付けする &lt;code&gt;PerlIO_push&lt;/code&gt; を。ザ・</target>
        </trans-unit>
        <trans-unit id="0b90a08dc8612f90c1076481f4ad779beb7a5f7e" translate="yes" xml:space="preserve">
          <source>Open the scalar handle on a new scalar, pointed to by SCALARREF. If no SCALARREF is given, a &quot;private&quot; scalar is created to hold the file data.</source>
          <target state="translated">SCALARARREFによって指された新しいスカラのスカラハンドルを開く。SCALARARREFが与えられていない場合、ファイルデータを保持するための &quot;private &quot;スカラが作成される。</target>
        </trans-unit>
        <trans-unit id="fa04c7c6f525f721026d1ba438790f3fcc864164" translate="yes" xml:space="preserve">
          <source>Open the syslog with options &lt;code&gt;ndelay&lt;/code&gt; and &lt;code&gt;pid&lt;/code&gt; , and with facility &lt;code&gt;LOCAL0&lt;/code&gt; :</source>
          <target state="translated">オプション &lt;code&gt;ndelay&lt;/code&gt; と &lt;code&gt;pid&lt;/code&gt; 、および機能 &lt;code&gt;LOCAL0&lt;/code&gt; を使用してsyslogを開きます。</target>
        </trans-unit>
        <trans-unit id="8811a98a6a9653fddfc77b8259113c776713824a" translate="yes" xml:space="preserve">
          <source>Open the syslog with options &lt;code&gt;ndelay&lt;/code&gt; and &lt;code&gt;pid&lt;/code&gt;, and with facility &lt;code&gt;LOCAL0&lt;/code&gt;:</source>
          <target state="translated">オプション &lt;code&gt;ndelay&lt;/code&gt; と &lt;code&gt;pid&lt;/code&gt; を使用し、 &lt;code&gt;LOCAL0&lt;/code&gt; を使用してsyslogを開きます。</target>
        </trans-unit>
        <trans-unit id="db3951317261fd51cb4c1a3e01c4748b4896c421" translate="yes" xml:space="preserve">
          <source>OpenBSD</source>
          <target state="translated">OpenBSD</target>
        </trans-unit>
        <trans-unit id="49536a6420d53dc725b117e3d37bfc34dfb9bef1" translate="yes" xml:space="preserve">
          <source>OpenBSD core dumps from getprotobyname_r and getservbyname_r with ithreads</source>
          <target state="translated">OpenBSD のコアは、getprotobyname_r および getservbyname_r から ithreads でダンプしています。</target>
        </trans-unit>
        <trans-unit id="64310839a246c6fc794d722f4304cd08f25d7b05" translate="yes" xml:space="preserve">
          <source>OpenVMS</source>
          <target state="translated">OpenVMS</target>
        </trans-unit>
        <trans-unit id="d32dc42d00fa4f78f0a59f030ed60cd6a30b3295" translate="yes" xml:space="preserve">
          <source>OpenVMS Alpha v7.3-1 and later and all version of OpenVMS I64 support case sensitivity as a process setting (see &lt;code&gt;SET PROCESS
/CASE_LOOKUP=SENSITIVE&lt;/code&gt; ). Perl does not currently support case sensitivity on VMS, but it may in the future, so Perl programs should use the &lt;code&gt;File::Spec-&amp;gt;case_tolerant&lt;/code&gt; method to determine the state, and not the &lt;code&gt;$^O&lt;/code&gt; variable.</source>
          <target state="translated">OpenVMS Alpha v7.3-1以降およびすべてのバージョンのOpenVMS I64は、プロセス設定として大文字と小文字の区別をサポートしています（ &lt;code&gt;SET PROCESS /CASE_LOOKUP=SENSITIVE&lt;/code&gt; 参照）。Perlは現在VMSでの大文字と小文字の区別をサポートしていませんが、将来的にはサポートする可能性があるため、Perlプログラムは &lt;code&gt;$^O&lt;/code&gt; 変数ではなく &lt;code&gt;File::Spec-&amp;gt;case_tolerant&lt;/code&gt; メソッドを使用して状態を決定する必要があります。</target>
        </trans-unit>
        <trans-unit id="f9ff604a4dd28e6202581dca695c5bed829ec062" translate="yes" xml:space="preserve">
          <source>OpenVMS Alpha v7.3-1 and later and all version of OpenVMS I64 support case sensitivity as a process setting (see &lt;code&gt;SET PROCESS /CASE_LOOKUP=SENSITIVE&lt;/code&gt;). Perl does not currently support case sensitivity on VMS, but it may in the future, so Perl programs should use the &lt;code&gt;File::Spec-&amp;gt;case_tolerant&lt;/code&gt; method to determine the state, and not the &lt;code&gt;$^O&lt;/code&gt; variable.</source>
          <target state="translated">OpenVMS Alphav7.3-1以降およびOpenVMSI64のすべてのバージョンは、プロセス設定として大文字と小文字の区別をサポートしています（ &lt;code&gt;SET PROCESS /CASE_LOOKUP=SENSITIVE&lt;/code&gt; 参照）。Perlは現在VMSで大文字と小文字を区別することをサポートしていませんが、将来的にサポートする可能性があるため、Perlプログラムは &lt;code&gt;$^O&lt;/code&gt; 変数ではなく、 &lt;code&gt;File::Spec-&amp;gt;case_tolerant&lt;/code&gt; メソッドを使用して状態を判別する必要があります。</target>
        </trans-unit>
        <trans-unit id="580bd0fefd9022c163462e267d5f62605679e1bf" translate="yes" xml:space="preserve">
          <source>Opening Binary Files</source>
          <target state="translated">バイナリファイルを開く</target>
        </trans-unit>
        <trans-unit id="3b6c1a6dbd679781e98b430deca927902564168e" translate="yes" xml:space="preserve">
          <source>Opening Pipes</source>
          <target state="translated">パイプを開く</target>
        </trans-unit>
        <trans-unit id="97614657c24973c63e30d6aea12f0ee16c28cc0b" translate="yes" xml:space="preserve">
          <source>Opening Text Files</source>
          <target state="translated">テキストファイルを開く</target>
        </trans-unit>
        <trans-unit id="36680b4c4dae060cef49428930207438c7efaa37" translate="yes" xml:space="preserve">
          <source>Opening Text Files for Reading</source>
          <target state="translated">テキストファイルを開いて読む</target>
        </trans-unit>
        <trans-unit id="2a72037dbe3a876109b6617803140785c781433b" translate="yes" xml:space="preserve">
          <source>Opening Text Files for Writing</source>
          <target state="translated">書き込み用のテキストファイルを開く</target>
        </trans-unit>
        <trans-unit id="d41c1a93b08d5c6da84630f4e7549a5cfa0c9f29" translate="yes" xml:space="preserve">
          <source>Opening a Berkeley DB Database File</source>
          <target state="translated">バークレーDBデータベースファイルを開く</target>
        </trans-unit>
        <trans-unit id="03b0ff1f775aaa0c11a96201f8ff9e088550422d" translate="yes" xml:space="preserve">
          <source>Opening a filehandle into a command</source>
          <target state="translated">ファイルハンドルをコマンドで開く</target>
        </trans-unit>
        <trans-unit id="3af9988c3fefcdee028653737bea0a8e9c417094" translate="yes" xml:space="preserve">
          <source>Opening a filehandle into an in-memory scalar</source>
          <target state="translated">ファイルハンドルをメモリ内スカラーにオープンする</target>
        </trans-unit>
        <trans-unit id="821c0d97ab3d21f2ce24f411389616d6c9dc3c0d" translate="yes" xml:space="preserve">
          <source>Opening a pipe for reading</source>
          <target state="translated">読書のためのパイプを開く</target>
        </trans-unit>
        <trans-unit id="0c1420eefdd30517effef954306a645ff5d1c69e" translate="yes" xml:space="preserve">
          <source>Opening a pipe for writing</source>
          <target state="translated">書くためのパイプを開く</target>
        </trans-unit>
        <trans-unit id="c901450d25c1b4adffc158756d930772312effed" translate="yes" xml:space="preserve">
          <source>Opening a process does not automatically flush output handles on some platforms. (SunOS, Solaris, HP-UX)</source>
          <target state="translated">一部のプラットフォームでは、プロセスを開いても出力ハンドルが自動的にフラッシュされない。(SunOS、Solaris、HP-UX)</target>
        </trans-unit>
        <trans-unit id="b294c249cb9dd744fe8333a0cf9a3eaca337d759" translate="yes" xml:space="preserve">
          <source>Opening and setup functions</source>
          <target state="translated">オープニング機能とセットアップ機能</target>
        </trans-unit>
        <trans-unit id="9d1b0daa9340247fc5dd5775b7b3c96ab82ed183" translate="yes" xml:space="preserve">
          <source>Opening brace lines up with &quot;if&quot; when conditional spans multiple lines; should be at end-of-line otherwise</source>
          <target state="translated">条件が複数行にまたがる場合には、中括弧を &quot;if &quot;で囲む。</target>
        </trans-unit>
        <trans-unit id="4ac11216b92d2f325685b22de245cded12e40d13" translate="yes" xml:space="preserve">
          <source>Opening bracket for a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;&quot;LIGHTWEIGHT CALLBACKS&quot; in perlcall&lt;/a&gt;.</source>
          <target state="translated">軽量コールバック用の開き角かっこ。&lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;perlcallの「LIGHTWEIGHTCALLBACKS」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4a1d6b2927f0e3d3a000bd5c08d3176bb52e234e" translate="yes" xml:space="preserve">
          <source>Opening bracket for a lightweight callback. See &lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;LIGHTWEIGHT CALLBACKS in perlcall&lt;/a&gt;.</source>
          <target state="translated">軽量コールバックの開始ブラケット。&lt;a href=&quot;perlcall#LIGHTWEIGHT-CALLBACKS&quot;&gt;perlcallのLIGHTWEIGHT CALLBACKSを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="626f042395527b903c8db8f898fdb1f1cdc87f96" translate="yes" xml:space="preserve">
          <source>Opening bracket for arguments on a callback. See &lt;code&gt;&lt;a href=&quot;#PUTBACK&quot;&gt;&quot;PUTBACK&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">コールバックの引数の開き角かっこ。 &lt;code&gt;&lt;a href=&quot;#PUTBACK&quot;&gt;&quot;PUTBACK&quot;&lt;/a&gt;&lt;/code&gt; および&lt;a href=&quot;perlcall&quot;&gt;perlcallを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2922ae0d4b2356e8683f8338a16e139ec4c04e6a" translate="yes" xml:space="preserve">
          <source>Opening bracket for arguments on a callback. See &lt;code&gt;PUTBACK&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">コールバックの引数の開き括弧。 &lt;code&gt;PUTBACK&lt;/code&gt; および&lt;a href=&quot;perlcall&quot;&gt;perlcallを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="31ad94341ea4379f427305bb05c070cf8053b4ad" translate="yes" xml:space="preserve">
          <source>Opening bracket for temporaries on a callback. See &lt;code&gt;&lt;a href=&quot;#FREETMPS&quot;&gt;&quot;FREETMPS&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">コールバックの一時的なものの開き角かっこ。 &lt;code&gt;&lt;a href=&quot;#FREETMPS&quot;&gt;&quot;FREETMPS&quot;&lt;/a&gt;&lt;/code&gt; および&lt;a href=&quot;perlcall&quot;&gt;perlcallを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e0cd04a850fb6ef4b1c1ae0773c22c62016e5236" translate="yes" xml:space="preserve">
          <source>Opening bracket for temporaries on a callback. See &lt;code&gt;FREETMPS&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">コールバックでの一時的な開始ブラケット。 &lt;code&gt;FREETMPS&lt;/code&gt; および&lt;a href=&quot;perlcall&quot;&gt;perlcallを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9e132601e5a7953c8bcffa1c453157f71ea1d34e" translate="yes" xml:space="preserve">
          <source>Opening bracket on a callback. See &lt;code&gt;&lt;a href=&quot;#LEAVE&quot;&gt;&quot;LEAVE&quot;&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">コールバックの開き角かっこ。 &lt;code&gt;&lt;a href=&quot;#LEAVE&quot;&gt;&quot;LEAVE&quot;&lt;/a&gt;&lt;/code&gt; と&lt;a href=&quot;perlcall&quot;&gt;perlcallを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3379b419b90643ab2744dfbdcecf5edbb46257a1" translate="yes" xml:space="preserve">
          <source>Opening bracket on a callback. See &lt;code&gt;LEAVE&lt;/code&gt; and &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">コールバックの開始ブラケット。 &lt;code&gt;LEAVE&lt;/code&gt; および&lt;a href=&quot;perlcall&quot;&gt;perlcallを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="fcb5320c0f77aa06e6c4f3f19f91a0a627e401dd" translate="yes" xml:space="preserve">
          <source>Opening curly on same line as keyword, if possible, otherwise line up.</source>
          <target state="translated">可能であればキーワードと同じ行の上でカーリーを開く、そうでなければ並ぶ。</target>
        </trans-unit>
        <trans-unit id="702f344a10799adb9c373ae43617c29a1d640fe4" translate="yes" xml:space="preserve">
          <source>Opening files for read-write is currently not supported if they use stdio (normal perl file handles).</source>
          <target state="translated">stdio (通常の perl ファイルハンドル)を使用している場合、読み書き可能なファイルを開くことは現在のところサポートされていません。</target>
        </trans-unit>
        <trans-unit id="414a4a46ddb98d37ef4a18659fc5e836c58095fc" translate="yes" xml:space="preserve">
          <source>Opening in-memory files</source>
          <target state="translated">メモリ内ファイルを開く</target>
        </trans-unit>
        <trans-unit id="f85c9c937148eb202d62793f91340ba09b2f7a5e" translate="yes" xml:space="preserve">
          <source>Opening the data file in write-only or append mode is not supported.</source>
          <target state="translated">書き込み専用または追加モードでデータファイルを開くことはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="c745d61fd7e06451beaeff422ae86fd1baafa519" translate="yes" xml:space="preserve">
          <source>Opens &lt;code&gt;$output&lt;/code&gt; in append mode.</source>
          <target state="translated">追加モードで &lt;code&gt;$output&lt;/code&gt; を開きます。</target>
        </trans-unit>
        <trans-unit id="96c4834766ebccdcd74e84c8bb745c2565822fc0" translate="yes" xml:space="preserve">
          <source>Opens a Perl file handle based on an already open Win32 native file handle [much like C's &lt;code&gt;fdopen()&lt;/code&gt; does with a file descriptor]. Returns a true value if the open operation succeeded. For failure, returns a false value and sets &lt;code&gt;$!&lt;/code&gt; [and possibly &lt;code&gt;fileLastError()&lt;/code&gt; and &lt;code&gt;$^E&lt;/code&gt;] to the reason for the failure.</source>
          <target state="translated">すでに開いているWin32ネイティブファイルハンドルに基づいてPerlファイルハンドルを開きます[Cの &lt;code&gt;fdopen()&lt;/code&gt; がファイル記述子で行うのと同じように]。開く操作が成功した場合、真の値を返します。失敗した場合、false値を返し、 &lt;code&gt;$!&lt;/code&gt; を設定します！ [そしておそらく &lt;code&gt;fileLastError()&lt;/code&gt; と &lt;code&gt;$^E&lt;/code&gt; ]が失敗の理由になります。</target>
        </trans-unit>
        <trans-unit id="8372328aea71570194ef6ece0a3348d285cc61e1" translate="yes" xml:space="preserve">
          <source>Opens a directory named EXPR for processing by &lt;a href=&quot;#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#telldir-DIRHANDLE&quot;&gt;&lt;code&gt;telldir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#seekdir-DIRHANDLE%2CPOS&quot;&gt;&lt;code&gt;seekdir&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#rewinddir-DIRHANDLE&quot;&gt;&lt;code&gt;rewinddir&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#closedir-DIRHANDLE&quot;&gt;&lt;code&gt;closedir&lt;/code&gt;&lt;/a&gt;. Returns true if successful. DIRHANDLE may be an expression whose value can be used as an indirect dirhandle, usually the real dirhandle name. If DIRHANDLE is an undefined scalar variable (or array or hash element), the variable is assigned a reference to a new anonymous dirhandle; that is, it's autovivified. Dirhandles are the same objects as filehandles; an I/O object can only be open as one of these handle types at once.</source>
          <target state="translated">処理するためにEXPRという名前のディレクトリを開きます&lt;a href=&quot;#readdir-DIRHANDLE&quot;&gt; &lt;code&gt;readdir&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#telldir-DIRHANDLE&quot;&gt; &lt;code&gt;telldir&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#seekdir-DIRHANDLE%2CPOS&quot;&gt; &lt;code&gt;seekdir&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;#rewinddir-DIRHANDLE&quot;&gt; &lt;code&gt;rewinddir&lt;/code&gt; &lt;/a&gt;、および&lt;a href=&quot;#closedir-DIRHANDLE&quot;&gt; &lt;code&gt;closedir&lt;/code&gt; の&lt;/a&gt;。成功した場合はtrueを返します。 DIRHANDLEは、その値を間接的なdirhandle、通常は実際のdirhandle名として使用できる式である場合があります。 DIRHANDLEが未定義のスカラー変数（または配列またはハッシュ要素）である場合、変数には新しい匿名dirhandleへの参照が割り当てられます。つまり、自動化されます。 Dirhandlesはfilehandlesと同じオブジェクトです。 I / Oオブジェクトは、これらのハンドルタイプの1つとして一度にのみ開くことができます。</target>
        </trans-unit>
        <trans-unit id="83d174f108cd7d61c427811f31c1c3a17b3fd039" translate="yes" xml:space="preserve">
          <source>Opens a directory named EXPR for processing by &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt;. Returns true if successful. DIRHANDLE may be an expression whose value can be used as an indirect dirhandle, usually the real dirhandle name. If DIRHANDLE is an undefined scalar variable (or array or hash element), the variable is assigned a reference to a new anonymous dirhandle; that is, it's autovivified. DIRHANDLEs have their own namespace separate from FILEHANDLEs.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt; による処理のためにEXPRという名前のディレクトリを開きます。成功した場合はtrueを返します。 DIRHANDLEは、間接的なdirhandle、通常は実際のdirhandle名として値を使用できる式にすることができます。 DIRHANDLEが未定義のスカラー変数（または配列またはハッシュ要素）である場合、変数には新しい無名dirhandleへの参照が割り当てられます。つまり、自動化されます。 DIRHANDLEには、FILEHANDLEとは別の独自の名前空間があります。</target>
        </trans-unit>
        <trans-unit id="bde0bd94d408d74305c3ef236f8e210809c61889" translate="yes" xml:space="preserve">
          <source>Opens a directory named EXPR for processing by &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt;. Returns true if successful. DIRHANDLE may be an expression whose value can be used as an indirect dirhandle, usually the real dirhandle name. If DIRHANDLE is an undefined scalar variable (or array or hash element), the variable is assigned a reference to a new anonymous dirhandle; that is, it's autovivified. DIRHANDLEs have their own namespace separate from FILEHANDLEs.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;telldir&quot;&gt;telldir&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;seekdir&quot;&gt;seekdir&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;rewinddir&quot;&gt;rewinddir&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;closedir&quot;&gt;closedir&lt;/a&gt;&lt;/code&gt; による処理のためにEXPRという名前のディレクトリを開きます。成功した場合はtrueを返します。 DIRHANDLEは、間接的なdirhandle、通常は実際のdirhandle名として値を使用できる式にすることができます。 DIRHANDLEが未定義のスカラー変数（または配列またはハッシュ要素）である場合、変数には新しい無名dirhandleへの参照が割り当てられます。つまり、自動化されます。 DIRHANDLEには、FILEHANDLEとは別の独自の名前空間があります。</target>
        </trans-unit>
        <trans-unit id="249fc18914652625c802e629d561a8d541cf9f3e" translate="yes" xml:space="preserve">
          <source>Opens a file descriptor [&lt;code&gt;$ivFD&lt;/code&gt;] based on an already open Win32 native file handle, &lt;code&gt;$hNativeHandle&lt;/code&gt;. This just calls the Win32-specific C routine &lt;code&gt;_open_osfhandle()&lt;/code&gt; or Perl's &quot;improved&quot; version called &lt;code&gt;win32_open_osfhandle()&lt;/code&gt;. Prior to Perl5.005 and in Cygwin Perl, C's &lt;code&gt;_open_osfhandle()&lt;/code&gt; is called which will fail if &lt;code&gt;GetFileType($hNativeHandle)&lt;/code&gt; would return &lt;code&gt;FILE_TYPE_UNKNOWN&lt;/code&gt;. For Perl5.005 and later, &lt;code&gt;OsFHandleOpenFd&lt;/code&gt; calls &lt;code&gt;win32_open_osfhandle()&lt;/code&gt; from the Perl DLL which doesn't have this restriction.</source>
          <target state="translated">すでに開いているWin32ネイティブファイルハンドル &lt;code&gt;$hNativeHandle&lt;/code&gt; 基づいて、ファイル記述子[ &lt;code&gt;$ivFD&lt;/code&gt; ]を開きます。これは、Win32固有のCルーチン &lt;code&gt;_open_osfhandle()&lt;/code&gt; または &lt;code&gt;win32_open_osfhandle()&lt;/code&gt; と呼ばれるPerlの「改良された」バージョンを呼び出すだけです。 Perl5.005より前およびCygwinPerlでは、Cの &lt;code&gt;_open_osfhandle()&lt;/code&gt; が呼び出されますが、 &lt;code&gt;GetFileType($hNativeHandle)&lt;/code&gt; が &lt;code&gt;FILE_TYPE_UNKNOWN&lt;/code&gt; を返すと失敗します。 Perl5.005以降の場合、 &lt;code&gt;OsFHandleOpenFd&lt;/code&gt; は、この制限のないPerl DLLから &lt;code&gt;win32_open_osfhandle()&lt;/code&gt; を呼び出します。</target>
        </trans-unit>
        <trans-unit id="b2665f3d96f1b25c433ed44735df54d5716eb0ca" translate="yes" xml:space="preserve">
          <source>Opens a pair of connected pipes like the corresponding system call. Note that if you set up a loop of piped processes, deadlock can occur unless you are very careful. In addition, note that Perl's pipes use IO buffering, so you may need to set &lt;a href=&quot;perlvar#%24%7C&quot;&gt;&lt;code&gt;$|&lt;/code&gt;&lt;/a&gt; to flush your WRITEHANDLE after each command, depending on the application.</source>
          <target state="translated">対応するシステムコールのように、接続されたパイプのペアを開きます。パイプ処理されたプロセスのループを設定すると、十分に注意しないとデッドロックが発生する可能性があることに注意してください。さらに、PerlのパイプはIOバッファリングを使用するため、&lt;a href=&quot;perlvar#%24%7C&quot;&gt; &lt;code&gt;$|&lt;/code&gt; &lt;/a&gt;を設定する必要がある場合があることに注意してください。アプリケーションに応じて、各コマンドの後にWRITEHANDLEをフラッシュします。</target>
        </trans-unit>
        <trans-unit id="ef6eec3f73e02b66c5dbdd58e24c78d1b02394cb" translate="yes" xml:space="preserve">
          <source>Opens a pair of connected pipes like the corresponding system call. Note that if you set up a loop of piped processes, deadlock can occur unless you are very careful. In addition, note that Perl's pipes use IO buffering, so you may need to set &lt;code&gt;$|&lt;/code&gt; to flush your WRITEHANDLE after each command, depending on the application.</source>
          <target state="translated">対応するシステムコールのように、接続されたパイプのペアを開きます。パイプ処理されたプロセスのループを設定すると、細心の注意を払わないとデッドロックが発生する可能性があることに注意してください。さらに、PerlのパイプはIOバッファリングを使用するため、 &lt;code&gt;$|&lt;/code&gt; 設定が必要になる場合があることに注意してください。アプリケーションに応じて、各コマンドの後にWRITEHANDLEをフラッシュします。</target>
        </trans-unit>
        <trans-unit id="97d9deba78acd708222827724c50fc7000bf21a2" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and attaches it to filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are specified the same as for the syscall of the same name. You should &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; first to get the proper definitions imported. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">指定された種類のソケットを開き、それをファイルハンドルSOCKETにアタッチします。DOMAIN、TYPE、およびPROTOCOLは、同じ名前のsyscallと同じように指定されます。最初に &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; を&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;して、適切な定義をインポートする必要があります。「&lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;ソケット：perlipcのクライアント/サーバー通信&lt;/a&gt;」の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="1bf5e36d7b7be8ff46fbdc02b28950f2a5493007" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and attaches it to filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are specified the same as for the syscall of the same name. You should &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; first to get the proper definitions imported. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">指定された種類のソケットを開き、それをファイルハンドルSOCKETにアタッチします。DOMAIN、TYPE、およびPROTOCOLは、同じ名前のsyscallと同じように指定されます。最初に &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; Socket&lt;/code&gt; を&lt;a href=&quot;use&quot;&gt;使用&lt;/a&gt;して、適切な定義をインポートする必要があります。「&lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;ソケット：perlipcのクライアント/サーバー通信&lt;/a&gt;」の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="bd4febc0253215fa9b6c0a61a1123c275d66541f" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and attaches it to filehandle SOCKET. DOMAIN, TYPE, and PROTOCOL are specified the same as for the syscall of the same name. You should &lt;code&gt;use Socket&lt;/code&gt; first to get the proper definitions imported. See the examples in &lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;&quot;Sockets: Client/Server Communication&quot; in perlipc&lt;/a&gt;.</source>
          <target state="translated">指定された種類のソケットを開き、ファイルハンドルSOCKETに接続します。DOMAIN、TYPE、およびPROTOCOLは、同じ名前のsyscallの場合と同じように指定されます。適切な定義をインポートするには、最初に &lt;code&gt;use Socket&lt;/code&gt; を使用する必要があります。&lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;perlipcの「ソケット：クライアント/サーバー通信」&lt;/a&gt;の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="3b29b07c25945e487dbff4de1e81a446b3bf071a" translate="yes" xml:space="preserve">
          <source>Opens a socket of the specified kind and returns it. Domain, type, and protocol are specified the same as for the syscall of the same name.</source>
          <target state="translated">指定された種類のソケットをオープンして返す。ドメイン、型、プロトコルは同名のシステムコールと同じです。</target>
        </trans-unit>
        <trans-unit id="f043104d316702a10e0ee9e23884fe89eeee7102" translate="yes" xml:space="preserve">
          <source>Opens the file whose filename is given by EXPR, and associates it with FILEHANDLE.</source>
          <target state="translated">ファイル名がEXPRで与えられたファイルを開き、FILEHANDLEと関連付けます。</target>
        </trans-unit>
        <trans-unit id="f8d3156ec9740e3cf785b92426587c9913bf7a48" translate="yes" xml:space="preserve">
          <source>Opens the file whose filename is given by FILENAME, and associates it with FILEHANDLE. If FILEHANDLE is an expression, its value is used as the real filehandle wanted; an undefined scalar will be suitably autovivified. This function calls the underlying operating system's</source>
          <target state="translated">ファイル名がFILENAMEで与えられたファイルを開き、FILEHANDLEと関連付けます。FILEHANDLEが式の場合、その値が実際のファイルハンドルとして使用されます。この関数は、基礎となるオペレーティングシステムの</target>
        </trans-unit>
        <trans-unit id="4b9ccea513e25adc54a594c4a2c7b7e82197b4e8" translate="yes" xml:space="preserve">
          <source>Opens the file whose filename is given by FILENAME, and associates it with FILEHANDLE. If FILEHANDLE is an expression, its value is used as the real filehandle wanted; an undefined scalar will be suitably autovivified. This function calls the underlying operating system's &lt;a href=&quot;http://man.he.net/man2/open&quot;&gt;open(2)&lt;/a&gt; function with the parameters FILENAME, MODE, and PERMS.</source>
          <target state="translated">ファイル名がFILENAMEで指定されているファイルを開き、FILEHANDLEに関連付けます。 FILEHANDLEが式の場合、その値は実際のファイルハンドルとして使用されます。未定義のスカラーは適切に自動化されます。この関数は、パラメーターFILENAME、MODE、およびPERMSを使用して、基盤となるオペレーティングシステムの&lt;a href=&quot;http://man.he.net/man2/open&quot;&gt;open（2）&lt;/a&gt;関数を呼び出します。</target>
        </trans-unit>
        <trans-unit id="4d5a806f4d052ec496b3b922107438a0577f84fc" translate="yes" xml:space="preserve">
          <source>Opens the syslog. &lt;code&gt;$ident&lt;/code&gt; is prepended to every message. &lt;code&gt;$logopt&lt;/code&gt; contains zero or more of the options detailed below. &lt;code&gt;$facility&lt;/code&gt; specifies the part of the system to report about, for example &lt;code&gt;LOG_USER&lt;/code&gt; or &lt;code&gt;LOG_LOCAL0&lt;/code&gt; : see &lt;a href=&quot;#Facilities&quot;&gt;Facilities&lt;/a&gt; for a list of well-known facilities, and your &lt;code&gt;syslog(3)&lt;/code&gt; documentation for the facilities available in your system. Check &lt;a href=&quot;#SEE-ALSO&quot;&gt;SEE ALSO&lt;/a&gt; for useful links. Facility can be given as a string or a numeric macro.</source>
          <target state="translated">syslogを開きます。すべてのメッセージに &lt;code&gt;$ident&lt;/code&gt; が付加されます。 &lt;code&gt;$logopt&lt;/code&gt; には、以下で説明するオプションが0個以上含まれています。 &lt;code&gt;$facility&lt;/code&gt; は、報告するシステムの一部を指定します。たとえば、 &lt;code&gt;LOG_USER&lt;/code&gt; や &lt;code&gt;LOG_LOCAL0&lt;/code&gt; です。よく知られている機能のリストについては、&lt;a href=&quot;#Facilities&quot;&gt;機能&lt;/a&gt;を参照してください。システムで使用できる機能については、 &lt;code&gt;syslog(3)&lt;/code&gt; のドキュメントを参照してください。役立つリンクについては、&lt;a href=&quot;#SEE-ALSO&quot;&gt;こちらもご覧&lt;/a&gt;ください。ファシリティは文字列または数値マクロとして指定できます。</target>
        </trans-unit>
        <trans-unit id="d67ac2c393c850f9198943cd6ad27b36c7d7a81b" translate="yes" xml:space="preserve">
          <source>Opens the syslog. &lt;code&gt;$ident&lt;/code&gt; is prepended to every message. &lt;code&gt;$logopt&lt;/code&gt; contains zero or more of the options detailed below. &lt;code&gt;$facility&lt;/code&gt; specifies the part of the system to report about, for example &lt;code&gt;LOG_USER&lt;/code&gt; or &lt;code&gt;LOG_LOCAL0&lt;/code&gt;: see &lt;a href=&quot;#Facilities&quot;&gt;&quot;Facilities&quot;&lt;/a&gt; for a list of well-known facilities, and your &lt;code&gt;syslog(3)&lt;/code&gt; documentation for the facilities available in your system. Check &lt;a href=&quot;#SEE-ALSO&quot;&gt;&quot;SEE ALSO&quot;&lt;/a&gt; for useful links. Facility can be given as a string or a numeric macro.</source>
          <target state="translated">Syslogを開きます。 &lt;code&gt;$ident&lt;/code&gt; はすべてのメッセージの前に付加されます。 &lt;code&gt;$logopt&lt;/code&gt; には、以下に詳述するオプションが0個以上含まれています。 &lt;code&gt;$facility&lt;/code&gt; &lt;code&gt;LOG_USER&lt;/code&gt; 、レポートするシステムの部分を指定します。たとえば、LOG_USERや &lt;code&gt;LOG_LOCAL0&lt;/code&gt; です。よく知られている機能のリストについては&lt;a href=&quot;#Facilities&quot;&gt;「機能」&lt;/a&gt;を、システムで使用可能な機能については &lt;code&gt;syslog(3)&lt;/code&gt; のドキュメントを参照してください。役立つリンクについては、&lt;a href=&quot;#SEE-ALSO&quot;&gt;「関連項目」&lt;/a&gt;を確認してください。ファシリティは、文字列または数値マクロとして指定できます。</target>
        </trans-unit>
        <trans-unit id="1d7ead7f438c26f4d24f0c5553cfa1b2b48237a8" translate="yes" xml:space="preserve">
          <source>Operand with no preceding operator in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="translated">正規表現に先行演算子がないオペランド。&amp;lt;-ここにm /％s /でマーク</target>
        </trans-unit>
        <trans-unit id="d7befdfbc60eb47b3289957505fb12ce62daabea" translate="yes" xml:space="preserve">
          <source>Operating System Interfaces</source>
          <target state="translated">オペレーティングシステムインタフェース</target>
        </trans-unit>
        <trans-unit id="b9967a65c2c4c5007de8b77bf65865521f0d26c6" translate="yes" xml:space="preserve">
          <source>Operating on references to hashes.</source>
          <target state="translated">ハッシュへの参照を操作します。</target>
        </trans-unit>
        <trans-unit id="ac9fb6f30a90f215146103f81004effdabcea9ae" translate="yes" xml:space="preserve">
          <source>Operation &quot;%s&quot; returns its argument for UTF-16 surrogate U+%X</source>
          <target state="translated">操作 &quot;%s&quot; は、UTF-16 サロゲート U+%X の引数を返す。</target>
        </trans-unit>
        <trans-unit id="7b576c5bb0b11a4350e3bf4fdc21259831b2084c" translate="yes" xml:space="preserve">
          <source>Operation &quot;%s&quot; returns its argument for non-Unicode code point 0x%X</source>
          <target state="translated">操作 &quot;%s&quot; は、非 Unicode コードポイント 0x%X の引数を返します。</target>
        </trans-unit>
        <trans-unit id="d671b8f2f76102a15b0bf4d4a39249d6ad4b4ece" translate="yes" xml:space="preserve">
          <source>Operation &quot;%s&quot;: no method found, %s</source>
          <target state="translated">操作 &quot;%s&quot;:メソッドが見つかりませんでした。</target>
        </trans-unit>
        <trans-unit id="c28848b2a51553304abcd6de3ae0236ffb496efe" translate="yes" xml:space="preserve">
          <source>Operations with overloaded operators preserve the arguments which is exactly what you expect.</source>
          <target state="translated">オーバーロードされた演算子を使った操作は引数を保持します。</target>
        </trans-unit>
        <trans-unit id="d4e4327f6fb8077a49e03daa6c0ea206ecb5c16a" translate="yes" xml:space="preserve">
          <source>Operations with overloaded operators preserve the arguments, which is exactly what you expect.</source>
          <target state="translated">オーバーロードされた演算子を使用した操作は引数を保持します。</target>
        </trans-unit>
        <trans-unit id="f921f14a57cf5d524fbd5fad00e7ed999feb448d" translate="yes" xml:space="preserve">
          <source>Operator Names and Operator Lists</source>
          <target state="translated">オペレータ名とオペレータリスト</target>
        </trans-unit>
        <trans-unit id="f299c884a708c75ca75144e361f0c5cf282b235f" translate="yes" xml:space="preserve">
          <source>Operator Overloading</source>
          <target state="translated">オペレータのオーバーロード</target>
        </trans-unit>
        <trans-unit id="53d6250055dd8231245476710d174685174b7d89" translate="yes" xml:space="preserve">
          <source>Operator Precedence and Associativity</source>
          <target state="translated">オペレータの優先順位と連想性</target>
        </trans-unit>
        <trans-unit id="11c9953040dd3157f9326929003c9899b7cffb21" translate="yes" xml:space="preserve">
          <source>Operator associativity</source>
          <target state="translated">オペレータの連想性</target>
        </trans-unit>
        <trans-unit id="08ca8c19d61f0facd586cd4f482f39a253b12167" translate="yes" xml:space="preserve">
          <source>Operator implementations (the values) can be subroutines, references to subroutines, or anonymous subroutines - in other words, anything legal inside a &lt;code&gt;&amp;amp;{ ... }&lt;/code&gt; call. Values specified as strings are interpreted as method names. Thus</source>
          <target state="translated">演算子の実装（値）は、サブルーチン、サブルーチンへの参照、または無名サブルーチン（つまり、 &lt;code&gt;&amp;amp;{ ... }&lt;/code&gt; 呼び出し内で正当なもの）にすることができます。文字列として指定された値は、メソッド名として解釈されます。したがって</target>
        </trans-unit>
        <trans-unit id="4f99a8916efac564a63d50ce560cad0dd70e1540" translate="yes" xml:space="preserve">
          <source>Operator names are typically small lowercase words like enterloop, leaveloop, last, next, redo etc. Sometimes they are rather cryptic like gv2cv, i_ncmp and ftsvtx.</source>
          <target state="translated">演算子名は通常、Enterloop,leaveloop,last,next,redo などのような小さな小文字の単語です。gv2cv,i_ncmp,ftsvtx のように暗号的なものもあります。</target>
        </trans-unit>
        <trans-unit id="0bc65caf3b0a75a378aedfadf66730c78a4537cf" translate="yes" xml:space="preserve">
          <source>Operator or semicolon missing before %s</source>
          <target state="translated">s の前に演算子またはセミコロンがありません。</target>
        </trans-unit>
        <trans-unit id="685048571a4f4db99cb190b311def264fc71eb0e" translate="yes" xml:space="preserve">
          <source>Operator precedence</source>
          <target state="translated">オペレータの優先順位</target>
        </trans-unit>
        <trans-unit id="b559bbb40846a93d37a125fab7a9a1b57c0dd2f9" translate="yes" xml:space="preserve">
          <source>Operator precedence and associativity work in Perl more or less like they do in mathematics.</source>
          <target state="translated">Perlでは、演算子の優先順位や連想性は数学とほぼ同じように動作します。</target>
        </trans-unit>
        <trans-unit id="6852b1cd2bb1031ac4d81d694fd94535c3eb3d11" translate="yes" xml:space="preserve">
          <source>Operator tags can be used to refer to groups (or sets) of operators. Tag names always begin with a colon. The Opcode module defines several optags and the user can define others using the define_optag function.</source>
          <target state="translated">演算子タグは、演算子のグループ(またはセット)を参照するために使用できます。タグ名は常にコロンで始まります。Opcodeモジュールは、いくつかのオプタグを定義し、ユーザーはdefine_optag関数を使用して他のオプタグを定義することができます。</target>
        </trans-unit>
        <trans-unit id="093964ff1bd20f7f1bfa027cf984852f6646a0fc" translate="yes" xml:space="preserve">
          <source>Operator vs literal overloading</source>
          <target state="translated">演算子とリテラルのオーバーロード</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="63e0a2d0a1f37e46caa267d78be1feaf655b0cda" translate="yes" xml:space="preserve">
          <source>Operators dealing with filenames are examples.</source>
          <target state="translated">ファイル名を扱う演算子は例です。</target>
        </trans-unit>
        <trans-unit id="55ddd8565a51d103a65dc3c453ea6bce04b13905" translate="yes" xml:space="preserve">
          <source>Operators such as &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; force arguments to floating point format.</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/sin&quot;&gt;sin&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/exp&quot;&gt;exp&lt;/a&gt;&lt;/code&gt; などの演算子は、引数を強制的に浮動小数点形式にします。</target>
        </trans-unit>
        <trans-unit id="004496b42fcc360f8e82fa5c56c3b096a2155421" translate="yes" xml:space="preserve">
          <source>Operators such as &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt; and &lt;code&gt;exp&lt;/code&gt; force arguments to floating point format.</source>
          <target state="translated">&lt;code&gt;**&lt;/code&gt; 、 &lt;code&gt;sin&lt;/code&gt; 、 &lt;code&gt;exp&lt;/code&gt; などの演算子は、引数を浮動小数点形式に強制します。</target>
        </trans-unit>
        <trans-unit id="5c1c419f9c87704707f20d16f008ba41b567fa7e" translate="yes" xml:space="preserve">
          <source>Operators which expect a string</source>
          <target state="translated">文字列を期待する演算子</target>
        </trans-unit>
        <trans-unit id="192b9459597426145afa81f1d9a3ad900bb8bd5d" translate="yes" xml:space="preserve">
          <source>Operators which expect an integer</source>
          <target state="translated">整数を期待する演算子</target>
        </trans-unit>
        <trans-unit id="864704fd78dbf2c79b9e58c4ea43f3220669cded" translate="yes" xml:space="preserve">
          <source>Ops such as chdir obviously effect the process as a whole and not just the code in the compartment. Ops such as rand and srand have a similar but more subtle effect.</source>
          <target state="translated">chdir のような操作は明らかにプロセス全体に影響を与え、コンパートメント内のコードだけではありません。randやsrandのような操作は、同様の効果がありますが、より微妙な効果があります。</target>
        </trans-unit>
        <trans-unit id="977af567e0cb291a9f2082343e1b048e5433a7e1" translate="yes" xml:space="preserve">
          <source>Opsets may be manipulated using the perl bit vector operators &amp;amp; (and), | (or), ^ (xor) and ~ (negate/invert).</source>
          <target state="translated">opsetは、perlビットのベクトル演算子＆（および）、|を使用して操作できます。（または）、^（xor）および〜（否定/反転）。</target>
        </trans-unit>
        <trans-unit id="0b7b13995f2b05a4fbd9b6bef85fdd40cc461955" translate="yes" xml:space="preserve">
          <source>OptiPerl</source>
          <target state="translated">OptiPerl</target>
        </trans-unit>
        <trans-unit id="6221772a58b20793863ce371d773cbe75426798d" translate="yes" xml:space="preserve">
          <source>OptiPerl is a Windows IDE with simulated CGI environment, including debugger and syntax-highlighting editor.</source>
          <target state="translated">OptiPerl は、デバッガや構文強調エディタを含むシミュレートされた CGI 環境を持つ Windows IDE です。</target>
        </trans-unit>
        <trans-unit id="3aefe0ba1ba6e76e7b11557d066b96b14e2c986e" translate="yes" xml:space="preserve">
          <source>Optimisation data; subject to change.</source>
          <target state="translated">最適化データは変更される場合があります。</target>
        </trans-unit>
        <trans-unit id="6169946bff1ab1bb2fe62a2ebdb2dd4fa18f40fb" translate="yes" xml:space="preserve">
          <source>Optimisation flags; subject to change.</source>
          <target state="translated">最適化フラグ。</target>
        </trans-unit>
        <trans-unit id="fdf5e093149fa15365c797b12b39a00d5ec3a138" translate="yes" xml:space="preserve">
          <source>Optimization</source>
          <target state="translated">Optimization</target>
        </trans-unit>
        <trans-unit id="6bc76b02fc66f0ca691dc22aabcdcd333e409136" translate="yes" xml:space="preserve">
          <source>Optimization of regular expressions</source>
          <target state="translated">正規表現の最適化</target>
        </trans-unit>
        <trans-unit id="18a333060bee7f2ee65af71205072e100d62bacc" translate="yes" xml:space="preserve">
          <source>Optimized-away statements are rendered as '???'. This includes statements that have a compile-time side-effect, such as the obscure</source>
          <target state="translated">最適化されたアウェイ文は'? これには、コンパイル時に副作用があるステートメントが含まれます。</target>
        </trans-unit>
        <trans-unit id="40dbe8ccfe714d9a944d448d1c3b1b3c2bfff946" translate="yes" xml:space="preserve">
          <source>Optimizing</source>
          <target state="translated">Optimizing</target>
        </trans-unit>
        <trans-unit id="3e1ccc3d0caaae646e1ab71f59e1842b2b4f1166" translate="yes" xml:space="preserve">
          <source>Optimizing that any further is a job for &lt;code&gt;p5p&lt;/code&gt; .</source>
          <target state="translated">それ以上の最適化は &lt;code&gt;p5p&lt;/code&gt; の仕事です。</target>
        </trans-unit>
        <trans-unit id="7d18d459b985af7984ff90200899087216246ead" translate="yes" xml:space="preserve">
          <source>Optimizing that any further is a job for &lt;code&gt;p5p&lt;/code&gt;.</source>
          <target state="translated">それ以上の最適化は &lt;code&gt;p5p&lt;/code&gt; の仕事です。</target>
        </trans-unit>
        <trans-unit id="2b89db00fb49023ab4c0f78acb572909bcf10d35" translate="yes" xml:space="preserve">
          <source>Option Format</source>
          <target state="translated">オプション形式</target>
        </trans-unit>
        <trans-unit id="f506dd24a9e7c79211553ebe1422f91140092c4a" translate="yes" xml:space="preserve">
          <source>Option Stickiness</source>
          <target state="translated">オプションの粘着性</target>
        </trans-unit>
        <trans-unit id="8b0267bbb54c30709fbd963f611e8c9f6fcd1f57" translate="yes" xml:space="preserve">
          <source>Option words are separated by commas (not whitespace) and follow the usual conventions of compiler backend options.</source>
          <target state="translated">オプション語はカンマ(空白ではない)で区切られ、コンパイラのバックエンド・オプションの通常の規則に従います。</target>
        </trans-unit>
        <trans-unit id="bd62828c4813996c3de7a8b7f837c827369e6d5e" translate="yes" xml:space="preserve">
          <source>Option, Argument, Parameter, and Configuration File Processing</source>
          <target state="translated">オプション、引数、パラメータ、設定ファイルの処理</target>
        </trans-unit>
        <trans-unit id="16df76c37a27e75c2b404f915ffcff82e54620ed" translate="yes" xml:space="preserve">
          <source>Optional - called when the layer is about to be removed.</source>
          <target state="translated">オプション-レイヤーが削除されようとしているときに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="279393da5192f90d67ca2ac7c82f748509f343b9" translate="yes" xml:space="preserve">
          <source>Optional - if not present a lower layer does the open. If present, called after the layer is pushed for opens which pass a numeric file descriptor. This function is subject to change as there is no easy way to get a lower layer to do the open and then regain control.</source>
          <target state="translated">省略可能-存在しない場合は、下位レイヤーがオープンを行います。存在する場合は、数値ファイル記述子を渡すオープンのためにレイヤーがプッシュされた後に呼び出されます。下位レイヤにオープンをさせてから制御を回復させる簡単な方法がないため、この関数は変更される可能性があります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
