<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="23fce1430ee4d5e6ff2eda3c170c6c5f5f7f9889" translate="yes" xml:space="preserve">
          <source>The stability of these extensions varies widely. Some have been part of the core language for many years. Others are experimental and may change without warning or be completely removed. Check the documentation on an individual feature to verify its current status.</source>
          <target state="translated">これらの拡張機能の安定性は大きく異なります。あるものは何年も前からコア言語の一部となっています。その他のものは実験的なもので、警告なしに変更されたり、完全に削除されたりする可能性があります。現在の状態を確認するには、個々の機能のドキュメントをチェックしてください。</target>
        </trans-unit>
        <trans-unit id="1fd7c6e1c540b52e642a959640d5271791317f81" translate="yes" xml:space="preserve">
          <source>The stack arguments are accessible through the &lt;code&gt;ST(n)&lt;/code&gt; macro, which returns the &lt;code&gt;n&lt;/code&gt; 'th stack argument. Argument 0 is the first argument passed in the Perl subroutine call. These arguments are &lt;code&gt;SV*&lt;/code&gt; , and can be used anywhere an &lt;code&gt;SV*&lt;/code&gt; is used.</source>
          <target state="translated">スタック引数には、 &lt;code&gt;n&lt;/code&gt; 番目のスタック引数を返す &lt;code&gt;ST(n)&lt;/code&gt; マクロを介してアクセスできます。引数0は、Perlサブルーチン呼び出しで渡される最初の引数です。これらの引数は &lt;code&gt;SV*&lt;/code&gt; であり、 &lt;code&gt;SV*&lt;/code&gt; が使用される場所であればどこでも使用できます。</target>
        </trans-unit>
        <trans-unit id="607b1af778b28e37b1d81fc8b926b116b2fd196e" translate="yes" xml:space="preserve">
          <source>The stack arguments are accessible through the &lt;code&gt;ST(n)&lt;/code&gt; macro, which returns the &lt;code&gt;n&lt;/code&gt;'th stack argument. Argument 0 is the first argument passed in the Perl subroutine call. These arguments are &lt;code&gt;SV*&lt;/code&gt;, and can be used anywhere an &lt;code&gt;SV*&lt;/code&gt; is used.</source>
          <target state="translated">スタック引数には、 &lt;code&gt;n&lt;/code&gt; 番目のスタック引数を返す &lt;code&gt;ST(n)&lt;/code&gt; マクロを介してアクセスできます。引数0は、Perlサブルーチン呼び出しで渡される最初の引数です。これらの引数は &lt;code&gt;SV*&lt;/code&gt; であり、 &lt;code&gt;SV*&lt;/code&gt; が使用される場所であればどこでも使用できます。</target>
        </trans-unit>
        <trans-unit id="25a0b1ef2ef458b2d3cc833a6246a76631f78cfb" translate="yes" xml:space="preserve">
          <source>The stack size of currently extant threads cannot be changed, therefore, the following results in the above error:</source>
          <target state="translated">現在存在するスレッドのスタックサイズを変更することができないため、以下の結果、上記のエラーとなります。</target>
        </trans-unit>
        <trans-unit id="852fc28bbec79ad0af0406e767c0c9a99d1cbd8b" translate="yes" xml:space="preserve">
          <source>The standard &lt;a href=&quot;IO::Select&quot;&gt;&lt;code&gt;IO::Select&lt;/code&gt;&lt;/a&gt; module provides a user-friendlier interface to &lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="translated">標準の&lt;a href=&quot;IO::Select&quot;&gt; &lt;code&gt;IO::Select&lt;/code&gt; &lt;/a&gt;モジュールは、主にすべてのビットマスク作業を実行するため、&lt;a href=&quot;#select-RBITS%2CWBITS%2CEBITS%2CTIMEOUT&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt;するためのユーザーフレンドリーなインターフェイスを提供します。</target>
        </trans-unit>
        <trans-unit id="38654d44cc2a58273ab5b5792f4d5c5499881e36" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;&lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;Math::BigRat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; modules, along with the &lt;code&gt;bignum&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, and &lt;code&gt;bigrat&lt;/code&gt; pragmas, provide variable-precision arithmetic and overloaded operators, although they're currently pretty slow. At the cost of some space and considerable speed, they avoid the normal pitfalls associated with limited-precision representations.</source>
          <target state="translated">標準の &lt;code&gt;&lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;Math::BigRat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt; 、Math :: BigRat、および &lt;code&gt;&lt;a href=&quot;Math::BigFloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; モジュールは、 &lt;code&gt;bignum&lt;/code&gt; 、 &lt;code&gt;bigint&lt;/code&gt; 、および &lt;code&gt;bigrat&lt;/code&gt; プラグマとともに、可変精度の算術演算子とオーバーロード演算子を提供しますが、現在はかなり低速です。ある程度のスペースとかなりの速度を犠牲にして、精度が制限された表現に関連する通常の落とし穴を回避します。</target>
        </trans-unit>
        <trans-unit id="fc601a28bc12b4ada50e0942554017adba6dc50b" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;&lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;math/bigrat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;math/bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; modules, along with the &lt;code&gt;bignum&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; , and &lt;code&gt;bigrat&lt;/code&gt; pragmas, provide variable-precision arithmetic and overloaded operators, although they're currently pretty slow. At the cost of some space and considerable speed, they avoid the normal pitfalls associated with limited-precision representations.</source>
          <target state="translated">標準の &lt;code&gt;&lt;a href=&quot;math/bigint&quot;&gt;Math::BigInt&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;math/bigrat&quot;&gt;Math::BigRat&lt;/a&gt;&lt;/code&gt; 、Math :: BigRat、および &lt;code&gt;&lt;a href=&quot;math/bigfloat&quot;&gt;Math::BigFloat&lt;/a&gt;&lt;/code&gt; モジュールは、 &lt;code&gt;bignum&lt;/code&gt; 、 &lt;code&gt;bigint&lt;/code&gt; 、および &lt;code&gt;bigrat&lt;/code&gt; プラグマとともに、可変精度の算術演算子とオーバーロードされた演算子を提供しますが、現在はかなり低速です。ある程度のスペースとかなりの速度を犠牲にして、制限された精度の表現に関連する通常の落とし穴を回避します。</target>
        </trans-unit>
        <trans-unit id="ebb34ffe368cd7aab86ce86e94cbaf4a640b2d39" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;IO::Select&lt;/code&gt; module provides a user-friendlier interface to &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="translated">標準の &lt;code&gt;IO::Select&lt;/code&gt; モジュールは、ユーザーが使いやすいインターフェイスを &lt;code&gt;&lt;a href=&quot;functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 提供します。これは、ほとんどの場合、すべてのビットマスクが機能するためです。</target>
        </trans-unit>
        <trans-unit id="16315bade45df278e7f616f03ff95a3f0a8f22eb" translate="yes" xml:space="preserve">
          <source>The standard &lt;code&gt;IO::Select&lt;/code&gt; module provides a user-friendlier interface to &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt;, mostly because it does all the bit-mask work for you.</source>
          <target state="translated">標準の &lt;code&gt;IO::Select&lt;/code&gt; モジュールは、ユーザーが使いやすいインターフェイスを &lt;code&gt;&lt;a href=&quot;select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; 提供します。これは、ほとんどの場合、すべてのビットマスクが機能するためです。</target>
        </trans-unit>
        <trans-unit id="7c56d1d9eaa2950435f175be867488228983813f" translate="yes" xml:space="preserve">
          <source>The standard Perl 5 MRO would be (D, B, A, C). The result being that &lt;b&gt;A&lt;/b&gt; appears before &lt;b&gt;C&lt;/b&gt;, even though &lt;b&gt;C&lt;/b&gt; is the subclass of &lt;b&gt;A&lt;/b&gt;. The C3 MRO algorithm however, produces the following order: (D, B, C, A), which does not have this issue.</source>
          <target state="translated">標準のPerl 5 MROは（D、B、A、C）です。その結果、&lt;b&gt;C&lt;/b&gt;は&lt;b&gt;A&lt;/b&gt;のサブクラスであるにもかかわらず、&lt;b&gt;A&lt;/b&gt;が&lt;b&gt;Cの&lt;/b&gt;前に表示されます。ただし、C3 MROアルゴリズムは次の順序を生成します：（D、B、C、A）、これにはこの問題はありません。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="65db7a2a2e4a32185cf7e73efd313530e97c3f64" translate="yes" xml:space="preserve">
          <source>The standard Pod::Parser method parse_from_filehandle() takes up to two arguments, the first being the file handle to read POD from and the second being the file handle to write the formatted output to. The first defaults to STDIN if not given, and the second defaults to STDOUT. The method parse_from_file() is almost identical, except that its two arguments are the input and output disk files instead. See &lt;a href=&quot;parser&quot;&gt;Pod::Parser&lt;/a&gt; for the specific details.</source>
          <target state="translated">標準のPod :: Parserメソッドparse_from_filehandle（）は最大2つの引数を受け取ります。最初の引数はPODを読み取るファイルハンドルで、2番目の引数はフォーマットされた出力を書き込むファイルハンドルです。指定しない場合、1番目のデフォルトはSTDINになり、2番目のデフォルトはSTDOUTになります。parse_from_file（）メソッドは、2つの引数が代わりに入力および出力ディスクファイルであることを除いて、ほとんど同じです。参照してください&lt;a href=&quot;parser&quot;&gt;ポッド:: Parserの&lt;/a&gt;特定の詳細については。</target>
        </trans-unit>
        <trans-unit id="d459c791ef0819fa116e56f83671629a780f70ae" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_file() takes one argument naming the POD file to read from. By default, the output is sent to &lt;code&gt;STDOUT&lt;/code&gt; , but this can be changed with the output_fh() method.</source>
          <target state="translated">標準のPod :: Simpleメソッドparse_file（）は、読み取り元のPODファイルに名前を付ける引数を1つ取ります。デフォルトでは、出力は &lt;code&gt;STDOUT&lt;/code&gt; に送信されますが、これはoutput_fh（）メソッドで変更できます。</target>
        </trans-unit>
        <trans-unit id="3e6fd6624c64417efc3c147b58226ae1b1c796d2" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_file() takes one argument naming the POD file to read from. By default, the output is sent to &lt;code&gt;STDOUT&lt;/code&gt;, but this can be changed with the output_fh() method.</source>
          <target state="translated">標準のPod :: Simpleメソッドparse_file（）は、読み取るPODファイルに名前を付ける1つの引数を取ります。デフォルトでは、出力は &lt;code&gt;STDOUT&lt;/code&gt; に送信されますが、これはoutput_fh（）メソッドで変更できます。</target>
        </trans-unit>
        <trans-unit id="b669405b1331755a6517c831be989ebdf0920199" translate="yes" xml:space="preserve">
          <source>The standard Pod::Simple method parse_from_file() takes up to two arguments, the first being the input file to read POD from and the second being the file to write the formatted output to.</source>
          <target state="translated">標準のPod::Simpleメソッドparse_from_file()は最大2つの引数を取ります。</target>
        </trans-unit>
        <trans-unit id="c21871c0e5568494a7fbe46008b5f9b899656bd2" translate="yes" xml:space="preserve">
          <source>The standard Tie::RefHash module provides a convenient workaround to this.</source>
          <target state="translated">標準の Tie::RefHash モジュールは、これを回避する便利な方法を提供しています。</target>
        </trans-unit>
        <trans-unit id="baf8b1f6a3bcf32c285c5388e646857a3e93b793" translate="yes" xml:space="preserve">
          <source>The standard Unicode properties listed below are documented in &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;; Perl_Decimal_Digit is documented in &lt;a href=&quot;Unicode::UCD#prop_invmap%28%29&quot;&gt;&quot;prop_invmap()&quot; in Unicode::UCD&lt;/a&gt;. The other Perl extensions are in &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;&quot;Other Properties&quot; in perlunicode&lt;/a&gt;;</source>
          <target state="translated">以下にリストされている標準のUnicodeプロパティは、&lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http：//www.unicode.org/reports/tr44/に&lt;/a&gt;記載されています。Perl_Decimal_Digitは&lt;a href=&quot;Unicode::UCD#prop_invmap%28%29&quot;&gt;、Unicode :: UCDの「prop_invmap（）」に記載されています&lt;/a&gt;。その他のPerl拡張機能は&lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;、perlunicodeの「その他のプロパティ」にあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="66cc6332c8e3c57e5b8e7b4ce541f13735f1aa06" translate="yes" xml:space="preserve">
          <source>The standard Unicode properties listed below are documented in &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt;; Perl_Decimal_Digit is documented in &lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;prop_invmap() in Unicode::UCD&lt;/a&gt;. The other Perl extensions are in &lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;Other Properties in perlunicode&lt;/a&gt;;</source>
          <target state="translated">下記の標準Unicodeプロパティは、&lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http：//www.unicode.org/reports/tr44/に&lt;/a&gt;記載されています。Perl_Decimal_Digitは&lt;a href=&quot;unicode/ucd#prop_invmap()&quot;&gt;、Unicode :: UCDのprop_invmap（）に記載されています&lt;/a&gt;。その他のPerl拡張機能は&lt;a href=&quot;perlunicode#Other-Properties&quot;&gt;、perlunicodeのその他のプロパティにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="fdea898e7a6fa5187cc16e508d0249ddcaeda57c" translate="yes" xml:space="preserve">
          <source>The standard release of Perl (the one maintained by the Perl development team) is distributed only in source code form. You can find the latest releases at &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;.</source>
          <target state="translated">Perlの標準リリース（Perl開発チームによって保守されているもの）は、ソースコード形式でのみ配布されます。最新のリリースは&lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/にあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="026f8e314f5a0595f026a7356cc10536cfc51440" translate="yes" xml:space="preserve">
          <source>The standard sections of a manual page are:</source>
          <target state="translated">マニュアルページの標準的なセクションは</target>
        </trans-unit>
        <trans-unit id="da6ced5233b9d24371e1284e5b4cf92ab897f075" translate="yes" xml:space="preserve">
          <source>The standard tools that deal with module distribution (PAUSE, CPAN, etc.) form an identifier for each distribution by joining the 'name' and 'version' attributes with a dash (&lt;code&gt;-&lt;/code&gt;) character. Tools who are prepared to deal with distributions that have no version numbers generally omit the dash as well.</source>
          <target state="translated">モジュール配布を処理する標準ツール（PAUSE、CPANなど）は、「name」属性と「version」属性をダッシュ​​（ &lt;code&gt;-&lt;/code&gt; ）文字で結合することにより、各配布の識別子を形成します。バージョン番号のないディストリビューションを処理する準備ができているツールは、通常、ダッシュも省略します。</target>
        </trans-unit>
        <trans-unit id="ebe88b6db5cc5c12b5e1ae182a8ede9bae134d07" translate="yes" xml:space="preserve">
          <source>The standard typemap does not contain PerlIO * before perl 5.7, but it has the three stream variants. Using a PerlIO * directly is not backwards compatible unless you provide your own typemap.</source>
          <target state="translated">標準のタイプマップにはPerl5.7以前のPerlIO *は含まれていませんが、3つのストリームバリアントがあります。独自のタイプマップを提供しない限り、PerlIO *を直接使用することは下位互換性がありません。</target>
        </trans-unit>
        <trans-unit id="a4d40d48d96b939643d17277ad94dfc253906873" translate="yes" xml:space="preserve">
          <source>The standard typemap offers three variants of PerlIO *: &lt;code&gt;InputStream&lt;/code&gt; (T_IN), &lt;code&gt;InOutStream&lt;/code&gt; (T_INOUT) and &lt;code&gt;OutputStream&lt;/code&gt; (T_OUT). A bare &lt;code&gt;PerlIO *&lt;/code&gt; is considered a T_INOUT. If it matters in your code (see below for why it might) #define or typedef one of the specific names and use that as the argument or result type in your XS file.</source>
          <target state="translated">標準タイプマップは、PerlIO *の3つのバリアントを提供します： &lt;code&gt;InputStream&lt;/code&gt; （T_IN）、 &lt;code&gt;InOutStream&lt;/code&gt; （T_INOUT）、および &lt;code&gt;OutputStream&lt;/code&gt; （T_OUT）。裸の &lt;code&gt;PerlIO *&lt;/code&gt; はT_INOUTと見なされます。コードで重要な場合（理由については以下を参照）、特定の名前の1つを#defineまたはtypedefし、それをXSファイルの引数または結果の型として使用します。</target>
        </trans-unit>
        <trans-unit id="3718e2c8d6baf1715fb8924869dc7062354846f5" translate="yes" xml:space="preserve">
          <source>The standard/default list of directories in which dl_findfile() will search for libraries etc. Directories are searched in order: $dl_library_path[0], [1], ... etc</source>
          <target state="translated">dl_findfile()がライブラリ等を検索するデ ィ レ ク ト リ の標準/デ フォルト リ ス ト リ ス ト 。ディレクトリは順に検索されます。ディレクトリは、 $dl_library_path[0],[1],...などの順に検索されます。</target>
        </trans-unit>
        <trans-unit id="81b82092af810ac11d0e71f19aeda4997801a33d" translate="yes" xml:space="preserve">
          <source>The stash associated with a typed lexical. This returns the %Foo:: hash for &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Foo $bar&lt;/code&gt; .</source>
          <target state="translated">型付きレキシカルに関連付けられたスタッシュ。これは、 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt; Foo $bar&lt;/code&gt; の％Foo ::ハッシュを返します。</target>
        </trans-unit>
        <trans-unit id="b3fb6f3b4dcfdcba93815cd0cdb0c770846f5f5f" translate="yes" xml:space="preserve">
          <source>The stash associated with a typed lexical. This returns the &lt;code&gt;%Foo::&lt;/code&gt; hash for &lt;code&gt;my Foo $bar&lt;/code&gt;.</source>
          <target state="translated">型付き字句に関連付けられた隠し場所。これにより &lt;code&gt;my Foo $bar&lt;/code&gt; の &lt;code&gt;%Foo::&lt;/code&gt; ハッシュが返されます。</target>
        </trans-unit>
        <trans-unit id="d1de13e351b83e422c637b81ca7943274ca516a1" translate="yes" xml:space="preserve">
          <source>The stash for the package code will be compiled into.</source>
          <target state="translated">パッケージコードの隠し場所がコンパイルされます。</target>
        </trans-unit>
        <trans-unit id="cc4f30ab95381b1c15dfe4d97fa8f832c168bf1d" translate="yes" xml:space="preserve">
          <source>The stash in which this &quot;our&quot; variable was declared.</source>
          <target state="translated">この &quot;私たちの &quot;変数が宣言されていた隠し場所。</target>
        </trans-unit>
        <trans-unit id="869b087a95d93860c966339061a3c7eb5e7a6410" translate="yes" xml:space="preserve">
          <source>The stat preceding %s wasn't an lstat</source>
          <target state="translated">%sの前のstatはlstatではありませんでした。</target>
        </trans-unit>
        <trans-unit id="136e96ab03183ea4c3a7028af3545e7d9d5bc253" translate="yes" xml:space="preserve">
          <source>The stat() mode bits are probably right for most of the files and directories found on your system, because few people want to use the additional features offered by access(). But you may encounter surprises if your program runs on a system that uses ACLs, since the stat() information won't reflect the actual permissions.</source>
          <target state="translated">stat()モードのビットは、おそらくシステム上のほとんどのファイルやディレクトリに対しては正しいでしょう。しかし、あなたのプログラムが ACL を使用しているシステム上で実行されている場合、stat()の情報は実際のパーミッションを反映していないため、 驚くようなことに遭遇するかもしれません。</target>
        </trans-unit>
        <trans-unit id="e8e71255cf8fb3fde9520415463a7e71c11cd3c9" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;($gw_fh, 0, 1)&lt;/code&gt; doesn't change the current position, but it does clear the end-of-file condition on the handle, so that the next &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; makes Perl try again to read something.</source>
          <target state="translated">ステートメント &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;($gw_fh, 0, 1)&lt;/code&gt; は現在の位置を変更しませんが、ハンドルのファイルの終わり条件をクリアするため、次の &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; はPerlに何かを再度読み取らせます。</target>
        </trans-unit>
        <trans-unit id="29c5f769bcdc76ec76db73fb881f9e3de17be2e0" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;seek($gw_fh, 0, 1)&lt;/code&gt; doesn't change the current position, but it does clear the end-of-file condition on the handle, so that the next &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; makes Perl try again to read something.</source>
          <target state="translated">ステートメント &lt;code&gt;seek($gw_fh, 0, 1)&lt;/code&gt; は現在の位置を変更しませんが、ハンドルのファイルの終わりの状態をクリアするので、次の &lt;code&gt;&amp;lt;$gw_fh&amp;gt;&lt;/code&gt; はPerlに何かを読み取らせます。</target>
        </trans-unit>
        <trans-unit id="707171be35bdd3b79efa241046dd3631507040a6" translate="yes" xml:space="preserve">
          <source>The status 2 indicates that at least one of the specified files does not contain</source>
          <target state="translated">ステータス2は、指定されたファイルのうち少なくとも1つが</target>
        </trans-unit>
        <trans-unit id="9251e77389b34b5c344d864eb779d11058b888c5" translate="yes" xml:space="preserve">
          <source>The status code returned from &lt;code&gt;inflate&lt;/code&gt; will only trigger termination of the main processing loop if it isn't &lt;code&gt;Z_OK&lt;/code&gt; . When &lt;code&gt;LimitOutput&lt;/code&gt; has not been used the &lt;code&gt;Z_OK&lt;/code&gt; status means that the end of the compressed data stream has been reached or there has been an error in uncompression.</source>
          <target state="translated">&lt;code&gt;inflate&lt;/code&gt; から返されたステータスコードは、それが &lt;code&gt;Z_OK&lt;/code&gt; でない場合にのみ、メイン処理ループの終了をトリガーします。 &lt;code&gt;LimitOutput&lt;/code&gt; が使用されていない場合、 &lt;code&gt;Z_OK&lt;/code&gt; ステータスは、圧縮されたデータストリームの最後に到達したか、圧縮解除でエラーが発生したことを意味します。</target>
        </trans-unit>
        <trans-unit id="779e93e5e5c79de152e0d904d8c2cb9d0f5d9a7f" translate="yes" xml:space="preserve">
          <source>The status code returned from &lt;code&gt;inflate&lt;/code&gt; will only trigger termination of the main processing loop if it isn't &lt;code&gt;Z_OK&lt;/code&gt;. When &lt;code&gt;LimitOutput&lt;/code&gt; has not been used the &lt;code&gt;Z_OK&lt;/code&gt; status means that the end of the compressed data stream has been reached or there has been an error in uncompression.</source>
          <target state="translated">&lt;code&gt;inflate&lt;/code&gt; から返されるステータスコードは、 &lt;code&gt;Z_OK&lt;/code&gt; でない場合にのみ、メイン処理ループの終了をトリガーします。 &lt;code&gt;LimitOutput&lt;/code&gt; が使用されていない場合、 &lt;code&gt;Z_OK&lt;/code&gt; ステータスは、圧縮されたデータストリームの終わりに到達したか、圧縮解除でエラーが発生したことを意味します。</target>
        </trans-unit>
        <trans-unit id="2298239a448f47305c5dbab535dd02c58c7526e3" translate="yes" xml:space="preserve">
          <source>The status of the hushed flag also affects output of VMS error messages from compilation errors. Again, you still get the Perl error message (and the code in $STATUS)</source>
          <target state="translated">hushed フラグのステータスは、コンパイルエラーからの VMS エラーメッセージの出力にも影響します。ここでも、Perl のエラーメッセージ (と $STATUS のコード)が出力されます。</target>
        </trans-unit>
        <trans-unit id="4cb40ccf1b5efc1b553ba9f11bd2e4b83ffc7264" translate="yes" xml:space="preserve">
          <source>The status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt; ) command, successful call to &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt;, or from the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; operator. This is just the 16-bit status word returned by the traditional Unix &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; system call (or else is made up to look like it). Thus, the exit value of the subprocess is really (&lt;code&gt;$?&amp;gt;&amp;gt;
8&lt;/code&gt; ), and &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; gives which signal, if any, the process died from, and &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; reports whether there was a core dump.</source>
          <target state="translated">最後のパイプのクローズ、バックティック（ &lt;code&gt;``&lt;/code&gt; ）コマンド、 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid()&lt;/a&gt;&lt;/code&gt; への正常な呼び出し、または &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; オペレーターから返されたステータス。これは、従来のUnixの &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait()&lt;/a&gt;&lt;/code&gt; システムコールによって返される16ビットのステータスワードです（または、それと同じように構成されています）。したがって、サブプロセスの終了値は実際には（ &lt;code&gt;$?&amp;gt;&amp;gt; 8&lt;/code&gt; ）であり、 &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; は、プロセスが停止したシグナル（ある場合）と &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; は、コアダンプがあったかどうかを報告します。</target>
        </trans-unit>
        <trans-unit id="9f58cb3cab9b9d58145034f89f71fdaeeb21297a" translate="yes" xml:space="preserve">
          <source>The status returned by the last pipe close, backtick (&lt;code&gt;``&lt;/code&gt;) command, successful call to &lt;code&gt;wait()&lt;/code&gt; or &lt;code&gt;waitpid()&lt;/code&gt;, or from the &lt;code&gt;system()&lt;/code&gt; operator. This is just the 16-bit status word returned by the traditional Unix &lt;code&gt;wait()&lt;/code&gt; system call (or else is made up to look like it). Thus, the exit value of the subprocess is really (&lt;code&gt;$? &amp;gt;&amp;gt; 8&lt;/code&gt;), and &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; gives which signal, if any, the process died from, and &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; reports whether there was a core dump.</source>
          <target state="translated">最後のパイプクローズ、バッククォート（ &lt;code&gt;``&lt;/code&gt; ）コマンド、 &lt;code&gt;wait()&lt;/code&gt; または &lt;code&gt;waitpid()&lt;/code&gt; の正常な呼び出し、または &lt;code&gt;system()&lt;/code&gt; オペレーターから返されるステータス。これは、従来のUnixの &lt;code&gt;wait()&lt;/code&gt; システムコールによって返される16ビットのステータスワードです（または、そのように構成されています）。したがって、サブプロセスの終了値は実際には（ &lt;code&gt;$? &amp;gt;&amp;gt; 8&lt;/code&gt; ）であり、 &lt;code&gt;$? &amp;amp; 127&lt;/code&gt; は、プロセスが停止したシグナルがある場合はそれを示し、 &lt;code&gt;$? &amp;amp; 128&lt;/code&gt; は、コアダンプがあったかどうかを報告します。</target>
        </trans-unit>
        <trans-unit id="6450e7782a48b71f2dca0230b4493dd10ff37ce5" translate="yes" xml:space="preserve">
          <source>The status value that is returned by the user's &lt;code&gt;filter&lt;/code&gt; method or anonymous sub and the &lt;code&gt;filter_read&lt;/code&gt; and &lt;code&gt;read_exact&lt;/code&gt; functions take the same set of values, namely:</source>
          <target state="translated">ユーザーの &lt;code&gt;filter&lt;/code&gt; メソッドまたは無名サブルーチンによって返されるステータス値と、 &lt;code&gt;filter_read&lt;/code&gt; および &lt;code&gt;read_exact&lt;/code&gt; 関数は、同じ値のセットを取ります。</target>
        </trans-unit>
        <trans-unit id="2660ee0526b1b40a8d851a0826ec3b948b6dbdee" translate="yes" xml:space="preserve">
          <source>The stdio(3C) manpage notes that for LP32 applications, only 255 files may be opened using fopen(), and only file descriptors 0 through 255 can be used in a stream. Since perl calls open() and then fdopen(3C) with the resulting file descriptor, perl is limited to 255 simultaneous open files, even if sysopen() is used. If this proves to be an insurmountable problem, you can compile perl as a LP64 application, see &lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;&quot;Building an LP64 perl&quot;&lt;/a&gt; for details. Note also that the default resource limit for open file descriptors on Solaris is 255, so you will have to modify your ulimit or rctl (Solaris 9 onwards) appropriately.</source>
          <target state="translated">stdio（3C）のマンページでは、LP32アプリケーションの場合、fopen（）を使用して開くことができるのは255ファイルのみであり、ストリームで使用できるのはファイル記述子0〜255のみであると記載されています。perlはopen（）を呼び出し、次に結果のファイル記述子を使用してfdopen（3C）を呼び出すため、sysopen（）が使用されている場合でも、perlは255個の同時オープンファイルに制限されます。これが克服できない問題であることが判明した場合は、perlをLP64アプリケーションとしてコンパイルできます。詳細については、&lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;「LP64perlの構築」&lt;/a&gt;を参照してください。Solarisで開くファイル記述子のデフォルトのリソース制限は255であるため、ulimitまたはrctl（Solaris 9以降）を適切に変更する必要があることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="3b8220a76d45ce112350b70ee4dbd73fc8b8bc74" translate="yes" xml:space="preserve">
          <source>The stdio(3C) manpage notes that for LP32 applications, only 255 files may be opened using fopen(), and only file descriptors 0 through 255 can be used in a stream. Since perl calls open() and then fdopen(3C) with the resulting file descriptor, perl is limited to 255 simultaneous open files, even if sysopen() is used. If this proves to be an insurmountable problem, you can compile perl as a LP64 application, see &lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;Building an LP64 perl&lt;/a&gt; for details. Note also that the default resource limit for open file descriptors on Solaris is 255, so you will have to modify your ulimit or rctl (Solaris 9 onwards) appropriately.</source>
          <target state="translated">stdio（3C）のマンページでは、LP32アプリケーションの場合、fopen（）を使用して開くことができるファイルは255ファイルのみであり、ストリームで使用できるのはファイル記述子0〜255のみであると説明しています。 perlはopen（）を呼び出してからfdopen（3C）を呼び出し、結果のファイル記述子を使用するため、sysopen（）が使用されている場合でも、perlは255の同時オープンファイルに制限されます。これが解決できない問題であることが判明した場合は、perlをLP64アプリケーションとしてコンパイルできます。詳細については&lt;a href=&quot;#Building-an-LP64-perl&quot;&gt;、LP64 perlのビルド&lt;/a&gt;を参照してください。 Solarisでのオープンファイル記述子のデフォルトのリソース制限は255であるため、ulimitまたはrctl（Solaris 9以降）を適切に変更する必要があることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="5a65b444e930fbaa9c0e870b3e72484e3ba2cfa8" translate="yes" xml:space="preserve">
          <source>The steps above are in a very specific order, designed to be the reverse order of when the context was pushed. The first thing to do is to copy and/or protect any return arguments and free any temps in the current scope. Scope exits like an rvalue sub normally return a mortal copy of their return args (as opposed to lvalue subs). It is important to make this copy before the save stack is popped or variables are restored, or bad things like the following can happen:</source>
          <target state="translated">上記の手順は、コンテキストがプッシュされたときと逆の順序になるように設計されており、非常に具体的な順序で行われています。最初にすべきことは、戻り引数をコピーしたり保護したりして、現在のスコープ内のテンポを解放することです。rvalue サブのようなスコープの終了時には、通常はその戻り引数の致命的なコピーを返します (lvalue サブとは対照的です)。セーブスタックがポップされたり、変数がリストアされたりする前にこのコピーを作成することが重要です。</target>
        </trans-unit>
        <trans-unit id="00bff96ca21371570b04e3ba98b01671b01481ae" translate="yes" xml:space="preserve">
          <source>The store functions will &lt;code&gt;croak&lt;/code&gt; if they run into such references unless you set &lt;code&gt;$Storable::forgive_me&lt;/code&gt; to some &lt;code&gt;TRUE&lt;/code&gt; value. In that case, the fatal message is converted to a warning and some meaningless string is stored instead.</source>
          <target state="translated">店舗機能はします &lt;code&gt;croak&lt;/code&gt; し、彼らはあなたが設定されていない限り、このような言及に実行する場合、 &lt;code&gt;$Storable::forgive_me&lt;/code&gt; いくつかに &lt;code&gt;TRUE&lt;/code&gt; 値。その場合、致命的なメッセージは警告に変換され、代わりに意味のない文字列が保存されます。</target>
        </trans-unit>
        <trans-unit id="af1c1657bd0ce03b1ba6ae64acc2840b7f31bd40" translate="yes" xml:space="preserve">
          <source>The strend and patend pointers should point to the byte following the last character of each string.</source>
          <target state="translated">strend および patend ポインタは、各文字列の最後の文字に続くバイトを指すべきです。</target>
        </trans-unit>
        <trans-unit id="ccae9ac2ba65b56262ababed8ca5ba389eb0ed32" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt; . (Ths tells Perl to use the &lt;code&gt;NDBM_File&lt;/code&gt; package to perform the functions of the hash.)</source>
          <target state="translated">文字列 &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt; 。（これは、ハッシュの機能を実行するために &lt;code&gt;NDBM_File&lt;/code&gt; パッケージを使用するようにPerlに指示します。）</target>
        </trans-unit>
        <trans-unit id="0acc3252158ec09fb79d744584bd9ec310ab3fc7" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt;. (Ths tells Perl to use the &lt;code&gt;NDBM_File&lt;/code&gt; package to perform the functions of the hash.)</source>
          <target state="translated">文字列 &lt;code&gt;&quot;NDBM_File&quot;&lt;/code&gt; 。（これは、ハッシュの機能を実行するために &lt;code&gt;NDBM_File&lt;/code&gt; パッケージを使用するようにPerlに指示します。）</target>
        </trans-unit>
        <trans-unit id="7bebcac85b77891a0ebb57e146c479aea7f7cca3" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;&quot;ODBM_File&quot;&lt;/code&gt;. (Ths tells Perl to use the &lt;code&gt;ODBM_File&lt;/code&gt; package to perform the functions of the hash.)</source>
          <target state="translated">文字列 &lt;code&gt;&quot;ODBM_File&quot;&lt;/code&gt; 。（これは、ハッシュの機能を実行するために &lt;code&gt;ODBM_File&lt;/code&gt; パッケージを使用するようにPerlに指示します。）</target>
        </trans-unit>
        <trans-unit id="c5c77c76e1fc3205395047a2345f8ef41459d3bb" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;$vec&lt;/code&gt; only takes up as many bits as it needs. For instance, if you had 16 entries in &lt;code&gt;@ints&lt;/code&gt; , &lt;code&gt;$vec&lt;/code&gt; only needs two bytes to store them (not counting the scalar variable overhead).</source>
          <target state="translated">文字列 &lt;code&gt;$vec&lt;/code&gt; は、必要なビットだけを使用します。たとえば、 &lt;code&gt;@ints&lt;/code&gt; に16のエントリがある場合、 &lt;code&gt;$vec&lt;/code&gt; はそれらを格納するために2バイトしか必要としません（スカラー変数のオーバーヘッドはカウントしません）。</target>
        </trans-unit>
        <trans-unit id="dc49e0b476d0350280c159b76d14abbf494b1cf7" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;$vec&lt;/code&gt; only takes up as many bits as it needs. For instance, if you had 16 entries in &lt;code&gt;@ints&lt;/code&gt;, &lt;code&gt;$vec&lt;/code&gt; only needs two bytes to store them (not counting the scalar variable overhead).</source>
          <target state="translated">文字列 &lt;code&gt;$vec&lt;/code&gt; は、必要な数のビットのみを使用します。たとえば、 &lt;code&gt;@ints&lt;/code&gt; に16個のエントリがある場合、 &lt;code&gt;$vec&lt;/code&gt; はそれらを格納するために2バイトしか必要としません（スカラー変数のオーバーヘッドはカウントされません）。</target>
        </trans-unit>
        <trans-unit id="ace981c506425cb8cbcfe9d653a843e517d5bdac" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;br&amp;ucirc;l&amp;eacute;e&lt;/code&gt; has six graphemes but up to eight codepoints. This counts by grapheme, not by codepoint:</source>
          <target state="translated">文字列 &lt;code&gt;br&amp;ucirc;l&amp;eacute;e&lt;/code&gt; には6つの書記素がありますが、最大8つのコードポイントがあります。これは、コードポイントではなく書記素でカウントされます。</target>
        </trans-unit>
        <trans-unit id="c8568d09543e0ac94aa7c4682834b259e167d475" translate="yes" xml:space="preserve">
          <source>The string bitwise operators, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt;, treat their operands as strings of bytes. As such, values above 0xFF are nonsensical. Some instances of these have been deprecated since Perl 5.24, and were made fatal in 5.28, but it turns out that in cases where the wide characters did not affect the end result, no deprecation notice was raised, and so remain legal. Now, all occurrences either are fatal or raise a deprecation warning, so that the remaining legal occurrences became fatal in 5.32.</source>
          <target state="translated">文字列のビット演算子、 &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; 、 &lt;code&gt;^&lt;/code&gt; 、および &lt;code&gt;~&lt;/code&gt; 、それらのオペランドをバイトの文字列として扱います。そのため、0xFFを超える値は無意味です。これらの一部のインスタンスはPerl5.24以降非推奨になり、5.28で致命的になりましたが、ワイド文字が最終結果に影響を与えなかった場合、非推奨の通知は発生しなかったため、合法であることがわかりました。現在、すべての発生は致命的であるか、非推奨の警告を発するため、残りの法的な発生は5.32で致命的になりました。</target>
        </trans-unit>
        <trans-unit id="5487cb3c1b5dd51f93004e758fb4f77bc307a840" translate="yes" xml:space="preserve">
          <source>The string bitwise operators, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;~&lt;/code&gt;, treat their operands as strings of bytes. As such, values above 0xFF are nonsensical. Using such code points with these operators was deprecated in Perl 5.24, and is fatal as of Perl 5.28.</source>
          <target state="translated">文字列のビット演算子、 &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; 、 &lt;code&gt;^&lt;/code&gt; 、および &lt;code&gt;~&lt;/code&gt; 、それらのオペランドをバイトの文字列として扱います。そのため、0xFFを超える値は無意味です。これらの演算子でこのようなコードポイントを使用することは、Perl 5.24で非推奨になり、Perl5.28で致命的です。</target>
        </trans-unit>
        <trans-unit id="e842cb2ff66d209b19263b7c79265ed68c6571d7" translate="yes" xml:space="preserve">
          <source>The string following whatever was matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK). Example:</source>
          <target state="translated">最後に成功したパターンマッチで一致したものに続く文字列 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 現在のBLOCKで囲まれたBLOCKまたはeval（）内に隠された一致はカウントされません）。例：</target>
        </trans-unit>
        <trans-unit id="3ba0048f660cfcd3f32cbfe2f76535c5c8d897d2" translate="yes" xml:space="preserve">
          <source>The string following whatever was matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;eval()&lt;/code&gt; enclosed by the current BLOCK). Example:</source>
          <target state="translated">最後に成功したパターン一致によって一致したものに続く文字列 &lt;code&gt;eval()&lt;/code&gt; 現在のBLOCKで囲まれたBLOCKまたはeval（）内に隠された一致はカウントされません）。例：</target>
        </trans-unit>
        <trans-unit id="64817d2b5e56c060bf38149d53adb10efe254293" translate="yes" xml:space="preserve">
          <source>The string for Tuesday, December 12, 1995.</source>
          <target state="translated">1995年12月12日(火)の紐。</target>
        </trans-unit>
        <trans-unit id="f9abb06eb1806839c0e5b7b9bda35c81b35ae824" translate="yes" xml:space="preserve">
          <source>The string index to a &lt;b&gt;hash&lt;/b&gt;, used to look up the &lt;b&gt;value&lt;/b&gt; associated with that key.</source>
          <target state="translated">&lt;b&gt;ハッシュ&lt;/b&gt;への文字列インデックス。そのキーに関連付けられた&lt;b&gt;値&lt;/b&gt;を検索するために使用されます。</target>
        </trans-unit>
        <trans-unit id="b6885316bc4f379b0a1d01488371bab62a2d9d85" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt;&lt;code&gt;pack&lt;/code&gt;&lt;/a&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="translated">文字列は、TEMPLATEによって記述されたチャンクに分割されます。各チャンクは個別に値に変換されます。通常、文字列は&lt;a href=&quot;#pack-TEMPLATE%2CLIST&quot;&gt; &lt;code&gt;pack&lt;/code&gt; の&lt;/a&gt;結果であるか、文字列の文字が何らかのC構造を表します。</target>
        </trans-unit>
        <trans-unit id="cdaff357d54d31b09acea6f6d18fd623eddeb9f1" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="translated">文字列は、TEMPLATEによって記述されたチャンクに分割されます。各チャンクは個別に値に変換されます。通常、文字列は &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; の結果であるか、文字列の文字は何らかのC構造を表します。</target>
        </trans-unit>
        <trans-unit id="1c49e7731d3dc172a2f14e1ee383fed675a44e84" translate="yes" xml:space="preserve">
          <source>The string is broken into chunks described by the TEMPLATE. Each chunk is converted separately to a value. Typically, either the string is a result of &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;, or the characters of the string represent a C structure of some kind.</source>
          <target state="translated">文字列は、TEMPLATEによって記述されたチャンクに分割されます。各チャンクは個別に値に変換されます。通常、文字列は &lt;code&gt;&lt;a href=&quot;pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; の結果であるか、文字列の文字は何らかのC構造を表します。</target>
        </trans-unit>
        <trans-unit id="188acb1539bbcc7515d5af86f1bf3d6e3f0bd9c0" translate="yes" xml:space="preserve">
          <source>The string matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK).</source>
          <target state="translated">最後に成功したパターンマッチで一致した文字列 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; 現在のBLOCKで囲まれたBLOCKまたはeval（）内に隠されている一致はカウントされません）。</target>
        </trans-unit>
        <trans-unit id="e9cf9b6b7809255e19e6a3b715176fe34d8d904e" translate="yes" xml:space="preserve">
          <source>The string matched by the last successful pattern match (not counting any matches hidden within a BLOCK or &lt;code&gt;eval()&lt;/code&gt; enclosed by the current BLOCK).</source>
          <target state="translated">最後に成功したパターン一致によって一致した文字列 &lt;code&gt;eval()&lt;/code&gt; 現在のBLOCKで囲まれたBLOCKまたはeval（）内に隠された一致はカウントされません）。</target>
        </trans-unit>
        <trans-unit id="89c0c038ca187cf5160e57a2c61c41440d3e8e16" translate="yes" xml:space="preserve">
          <source>The string output (of floating point numbers) is padded with zeros:</source>
          <target state="translated">文字列出力(浮動小数点数の)は0でパディングされます。</target>
        </trans-unit>
        <trans-unit id="3d206cfe2e19b0f3779f91c6d76bdde7d7e22deb" translate="yes" xml:space="preserve">
          <source>The string output (of floating point numbers) will be padded with zeros:</source>
          <target state="translated">(浮動小数点数の)文字列出力はゼロでパディングされます。</target>
        </trans-unit>
        <trans-unit id="baf7cbc523832c454565f07354dbdc53faf7a98a" translate="yes" xml:space="preserve">
          <source>The string output will always have leading and trailing zeros stripped and drop a plus sign. &lt;code&gt;bstr()&lt;/code&gt; will give you always the form with a decimal point, while &lt;code&gt;bsstr()&lt;/code&gt; (s for scientific) gives you the scientific notation.</source>
          <target state="translated">文字列出力では、常に先行ゼロと後続ゼロが取り除かれ、プラス記号がドロップされます。 &lt;code&gt;bstr()&lt;/code&gt; は常に小数点のある形式を提供し、 &lt;code&gt;bsstr()&lt;/code&gt; （科学の場合はs）は科学表記を提供します。</target>
        </trans-unit>
        <trans-unit id="fe7b97aace0009c030b7f9cefcb2ca042c7263c6" translate="yes" xml:space="preserve">
          <source>The string preceding whatever was matched by the last successful pattern match, not counting any matches hidden within a BLOCK or &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; enclosed by the current BLOCK.</source>
          <target state="translated">最後に成功したパターンマッチで一致したものの前の文字列。現在のBLOCKで囲まれたBLOCKまたは &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 内に隠された一致はカウントされません。</target>
        </trans-unit>
        <trans-unit id="7f5e6eea58cb9fa29a6890f23f4c2850f3c5d5cc" translate="yes" xml:space="preserve">
          <source>The string preceding whatever was matched by the last successful pattern match, not counting any matches hidden within a BLOCK or &lt;code&gt;eval&lt;/code&gt; enclosed by the current BLOCK.</source>
          <target state="translated">最後に成功したパターン一致によって一致したものの前にある文字列。現在のBLOCKで囲まれたBLOCKまたは &lt;code&gt;eval&lt;/code&gt; 内に隠された一致はカウントされません。</target>
        </trans-unit>
        <trans-unit id="339432ba64926aa8fa758ffc110e1d9819cad770" translate="yes" xml:space="preserve">
          <source>The string result of any operation that uses locale information is tainted, as it is possible for a locale to be untrustworthy. See &lt;a href=&quot;#SECURITY&quot;&gt;&quot;SECURITY&quot;&lt;/a&gt;.</source>
          <target state="translated">ロケールが信頼できない可能性があるため、ロケール情報を使用する操作の文字列結果は汚染されます。&lt;a href=&quot;#SECURITY&quot;&gt;「セキュリティ」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="3d01fff15593695c94b4861cde9efd9b7494ec49" translate="yes" xml:space="preserve">
          <source>The string result of any operation that uses locale information is tainted, as it is possible for a locale to be untrustworthy. See &lt;a href=&quot;#SECURITY&quot;&gt;SECURITY&lt;/a&gt;.</source>
          <target state="translated">ロケールが信頼できない可能性があるため、ロケール情報を使用するすべての操作の文字列結果は汚染されます。&lt;a href=&quot;#SECURITY&quot;&gt;SECURITYを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="8fe36e2f9f506bb3c17ca908f63a229076cb522b" translate="yes" xml:space="preserve">
          <source>The string returned is not always in NFD/NFKD. Reordering may be required.</source>
          <target state="translated">返される文字列は、NFD/NFKDとは限りません。並び替えが必要な場合があります。</target>
        </trans-unit>
        <trans-unit id="2d311addc77468e8c33d61dc204474a00d32a5a2" translate="yes" xml:space="preserve">
          <source>The string that represents the C type that was not found in the typemap.</source>
          <target state="translated">タイプマップで見つからなかったC型を表す文字列です。</target>
        </trans-unit>
        <trans-unit id="0906d45502ea0bd7da882f8e89531d4e1f01bc75" translate="yes" xml:space="preserve">
          <source>The string that starts options. If a constant string is not sufficient, see &lt;code&gt;prefix_pattern&lt;/code&gt; .</source>
          <target state="translated">オプションを開始する文字列。定数文字列では不十分な場合は、 &lt;code&gt;prefix_pattern&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="efa5933751bfaa2a6c4eeedd57fd05169704edd2" translate="yes" xml:space="preserve">
          <source>The string that starts options. If a constant string is not sufficient, see &lt;code&gt;prefix_pattern&lt;/code&gt;.</source>
          <target state="translated">オプションを開始する文字列。定数文字列では不十分な場合は、 &lt;code&gt;prefix_pattern&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="fcff2e1cc42c11b32cad489cc398585a2adb0338" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by</source>
          <target state="translated">挿入される文字列は</target>
        </trans-unit>
        <trans-unit id="00f6f2add8143f7b5f6195521c58d01172830e33" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by &lt;code&gt;len&lt;/code&gt; octets starting at &lt;code&gt;pv&lt;/code&gt;. These octets are interpreted as either UTF-8 or Latin-1, according to whether the &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; flag is set in &lt;code&gt;flags&lt;/code&gt;. The characters are recoded for the lexer buffer, according to how the buffer is currently being interpreted (&lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt;). If a string to be inserted is available as a Perl scalar, the &lt;a href=&quot;#lex_stuff_sv&quot;&gt;&quot;lex_stuff_sv&quot;&lt;/a&gt; function is more convenient.</source>
          <target state="translated">挿入される文字列は、 &lt;code&gt;pv&lt;/code&gt; で始まる &lt;code&gt;len&lt;/code&gt; オクテットで表されます。これらのオクテットは、 &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; フラグが &lt;code&gt;flags&lt;/code&gt; に設定されているかどうかに応じて、UTF-8またはLatin-1のいずれかとして解釈されます。文字は、バッファが現在どのように解釈されているかに応じて、レクサーバッファ用に再コード化されます（&lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt;）。挿入する文字列がPerlスカラーとして使用できる場合は、&lt;a href=&quot;#lex_stuff_sv&quot;&gt;「lex_stuff_sv」&lt;/a&gt;関数の方が便利です。</target>
        </trans-unit>
        <trans-unit id="e41abf45c9431728dd7313f8c098905bb3fb1c5d" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by octets starting at</source>
          <target state="translated">挿入される文字列は</target>
        </trans-unit>
        <trans-unit id="c0c0bf345ccfdae0fb09cf9ab2d8e8d8ae4c0512" translate="yes" xml:space="preserve">
          <source>The string to be inserted is represented by octets starting at &lt;code&gt;pv&lt;/code&gt; and continuing to the first nul. These octets are interpreted as either UTF-8 or Latin-1, according to whether the &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; flag is set in &lt;code&gt;flags&lt;/code&gt;. The characters are recoded for the lexer buffer, according to how the buffer is currently being interpreted (&lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt;). If it is not convenient to nul-terminate a string to be inserted, the &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;&quot;lex_stuff_pvn&quot;&lt;/a&gt; function is more appropriate.</source>
          <target state="translated">挿入される文字列は、 &lt;code&gt;pv&lt;/code&gt; で始まり、最初のnulまで続くオクテットで表されます。これらのオクテットは、 &lt;code&gt;LEX_STUFF_UTF8&lt;/code&gt; フラグが &lt;code&gt;flags&lt;/code&gt; に設定されているかどうかに応じて、UTF-8またはLatin-1のいずれかとして解釈されます。文字は、バッファが現在どのように解釈されているかに応じて、レクサーバッファ用に再コード化されます（&lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt;）。挿入する文字列をヌル終了するのが&lt;a href=&quot;#lex_stuff_pvn&quot;&gt;不便&lt;/a&gt;な場合は、「lex_stuff_pvn」関数の方が適切です。</target>
        </trans-unit>
        <trans-unit id="afbb1230317b082fc0f64afe5f1a79c6e5661e9b" translate="yes" xml:space="preserve">
          <source>The string to be inserted is the string value of</source>
          <target state="translated">挿入する文字列は</target>
        </trans-unit>
        <trans-unit id="55208eb6676e3f7f6524a3ebd4f29e07cc0731fc" translate="yes" xml:space="preserve">
          <source>The string to be inserted is the string value of &lt;code&gt;sv&lt;/code&gt;. The characters are recoded for the lexer buffer, according to how the buffer is currently being interpreted (&lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt;). If a string to be inserted is not already a Perl scalar, the &lt;a href=&quot;#lex_stuff_pvn&quot;&gt;&quot;lex_stuff_pvn&quot;&lt;/a&gt; function avoids the need to construct a scalar.</source>
          <target state="translated">挿入する文字列は &lt;code&gt;sv&lt;/code&gt; の文字列値です。文字は、バッファが現在どのように解釈されているかに応じて、レクサーバッファ用に再コード化されます（&lt;a href=&quot;#lex_bufutf8&quot;&gt;&quot;lex_bufutf8&quot;&lt;/a&gt;）。挿入される文字列がまだPerlスカラーでない場合、&lt;a href=&quot;#lex_stuff_pvn&quot;&gt;「lex_stuff_pvn」&lt;/a&gt;関数はスカラーを作成する必要性を回避します。</target>
        </trans-unit>
        <trans-unit id="5a627ebdca058ca40f7afebaa0947770e3b19935" translate="yes" xml:space="preserve">
          <source>The string value of &lt;code&gt;$!&lt;/code&gt; is that returned by the CRTL's strerror() function, so it will include the VMS message for VMS-specific errors. The numeric value of &lt;code&gt;$!&lt;/code&gt; is the value of &lt;code&gt;errno&lt;/code&gt; , except if errno is EVMSERR, in which case &lt;code&gt;$!&lt;/code&gt; contains the value of vaxc$errno. Setting &lt;code&gt;$!&lt;/code&gt; always sets errno to the value specified. If this value is EVMSERR, it also sets vaxc$errno to 4 (NONAME-F-NOMSG), so that the string value of &lt;code&gt;$!&lt;/code&gt; won't reflect the VMS error message from before &lt;code&gt;$!&lt;/code&gt; was set.</source>
          <target state="translated">&lt;code&gt;$!&lt;/code&gt; の文字列値 これはCRTLのstrerror（）関数によって返されるものであるため、VMS固有のエラーのVMSメッセージが含まれます。 &lt;code&gt;$!&lt;/code&gt; の数値！ &lt;code&gt;errno&lt;/code&gt; の値です。ただし、errnoがEVMSERRの場合は例外 &lt;code&gt;$!&lt;/code&gt; この場合、$！vaxc $ errnoの値が含まれます。 &lt;code&gt;$!&lt;/code&gt; 設定しています！errnoを常に指定された値に設定します。この値がEVMSERRの場合、vaxc $ errnoも4（NONAME-F-NOMSG）に設定されるため、文字列値 &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;$!&lt;/code&gt; 前からのVM​​Sエラーメッセージは反映されません！設定されました。</target>
        </trans-unit>
        <trans-unit id="6bce1054a07cc28e1b64ace7f7b805802c74829f" translate="yes" xml:space="preserve">
          <source>The string value of &lt;code&gt;$!&lt;/code&gt; is that returned by the CRTL's strerror() function, so it will include the VMS message for VMS-specific errors. The numeric value of &lt;code&gt;$!&lt;/code&gt; is the value of &lt;code&gt;errno&lt;/code&gt;, except if errno is EVMSERR, in which case &lt;code&gt;$!&lt;/code&gt; contains the value of vaxc$errno. Setting &lt;code&gt;$!&lt;/code&gt; always sets errno to the value specified. If this value is EVMSERR, it also sets vaxc$errno to 4 (NONAME-F-NOMSG), so that the string value of &lt;code&gt;$!&lt;/code&gt; won't reflect the VMS error message from before &lt;code&gt;$!&lt;/code&gt; was set.</source>
          <target state="translated">&lt;code&gt;$!&lt;/code&gt; の文字列値これは、CRTLのstrerror（）関数によって返されるものであるため、VMS固有のエラーのVMSメッセージが含まれます。 &lt;code&gt;$!&lt;/code&gt; の数値は &lt;code&gt;errno&lt;/code&gt; の値です。ただし、errnoがEVMSERRの場合は、 &lt;code&gt;$!&lt;/code&gt; vaxc $ errnoの値が含まれます。 &lt;code&gt;$!&lt;/code&gt; 設定します！常にerrnoを指定された値に設定します。この値がEVMSERRの場合、vaxc $ errnoも4（NONAME-F-NOMSG）に設定されるため、文字列値は &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;$!&lt;/code&gt; より前のVMSエラーメッセージは反映されません！設定されました。</target>
        </trans-unit>
        <trans-unit id="ed1f52a4cdbc897685e0ae4db35f3139cd121ffc" translate="yes" xml:space="preserve">
          <source>The string value of the $data provided as argument is appended to the message we calculate the digest for. The return value is the $ctx object itself.</source>
          <target state="translated">引数として与えられた$dataの文字列の値が、ダイジェストを計算するメッセージに付加されます。戻り値は、$ctxオブジェクトそのものです。</target>
        </trans-unit>
        <trans-unit id="7a8e800596cb341c8f599d3168bdf4ec9c0dbea7" translate="yes" xml:space="preserve">
          <source>The strings returned may not be useful for 3-argument open().</source>
          <target state="translated">返される文字列は、3引数のopen()では役に立たないかもしれません。</target>
        </trans-unit>
        <trans-unit id="eb1b5858acfdd756a7774d6480e810b1c2f37266" translate="yes" xml:space="preserve">
          <source>The stroke ordering includes some characters that are not CJK Unified Ideographs and can't utilize &lt;code&gt;weightStroke()&lt;/code&gt; for collation. For them, use &lt;code&gt;entry&lt;/code&gt; instead.</source>
          <target state="translated">ストロークの順序には、CJK統合漢字ではなく、照合に &lt;code&gt;weightStroke()&lt;/code&gt; を使用できない文字が含まれています。それらについては、代わりに &lt;code&gt;entry&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="8d2353f63db6ded15b27f9ce53f46b40b4850e7c" translate="yes" xml:space="preserve">
          <source>The struct() function</source>
          <target state="translated">struct()関数</target>
        </trans-unit>
        <trans-unit id="2b18f7164a2da5acc0a078abefbfdb45f1b7ed1a" translate="yes" xml:space="preserve">
          <source>The structure of the tied() data is an array reference with elements</source>
          <target state="translated">tied()データの構造は、要素</target>
        </trans-unit>
        <trans-unit id="6772fe1a2535c049980c3763958a49b4c1d992f9" translate="yes" xml:space="preserve">
          <source>The stub package included with the perl distribution allows some additional methods:</source>
          <target state="translated">perl ディストリビューションに含まれるスタブパッケージでは、いくつかのメソッドを追加することができます。</target>
        </trans-unit>
        <trans-unit id="69dca73bafb51f0fe392c69e65938a9183f98a5b" translate="yes" xml:space="preserve">
          <source>The sub will receive exactly 1 argument, the type of thing being tagged 'context', 'hub', or 'event'. In the future additional things may be tagged, in which case new strings will be passed in. These are purely informative, you can (and usually should) ignore them.</source>
          <target state="translated">サブは正確には1つの引数を受け取ります。将来的には、追加のタグが付けられるかもしれませんが、その場合は新しい文字列が渡されます。これらは純粋に参考になるものですので、無視しても構いません(通常は無視すべきです)。</target>
        </trans-unit>
        <trans-unit id="7c28ea2e9a2d4863b1fc0e89e9b8c44c6fa89947" translate="yes" xml:space="preserve">
          <source>The sub you provide should always return a unique identifier. Most things will expect a proper UUID string, however nothing in Test2::API enforces this.</source>
          <target state="translated">あなたが提供するサブは常に一意の識別子を返すべきです。ほとんどのものは適切なUUID文字列を期待しますが、Test2::APIにはこれを強制するものはありません。</target>
        </trans-unit>
        <trans-unit id="6bfcc48f6a94ab4b3e39e57492b7c1d6d2ad759d" translate="yes" xml:space="preserve">
          <source>The submitter address in &lt;code&gt;AUTH&lt;/code&gt; option is expected to be in a format as required by RFC 2554, in an RFC2821-quoted form and xtext-encoded, or &amp;lt;&amp;gt; .</source>
          <target state="translated">&lt;code&gt;AUTH&lt;/code&gt; オプションの送信者アドレスは、RFC 2554で要求されている形式、RFC2821で引用された形式、xtext-encoded、または&amp;lt;&amp;gt;であることが期待されます。</target>
        </trans-unit>
        <trans-unit id="4ac8a2878ef2e11af070ab32ec1a2e0bca8078f0" translate="yes" xml:space="preserve">
          <source>The subroutine (including package) that threw the exception.</source>
          <target state="translated">例外を発生させたサブルーチン(パッケージを含む)。</target>
        </trans-unit>
        <trans-unit id="99602f0147c6aaadcc127e8f752211c7da8fb282" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'='&lt;/code&gt; does not overload the Perl assignment operator: it is used only to allow mutators to work as described here. (See &lt;a href=&quot;#Assignments&quot;&gt;&quot;Assignments&quot;&lt;/a&gt; above.)</source>
          <target state="translated">&lt;code&gt;'='&lt;/code&gt; のサブルーチンは、Perl代入演算子をオーバーロードしません。これは、ミューテーターがここで説明されているように機能できるようにするためにのみ使用されます。（上記の&lt;a href=&quot;#Assignments&quot;&gt;「割り当て」を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="4fb6dff8391b18be99fd9ebb7eb204cdfa56639a" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'='&lt;/code&gt; does not overload the Perl assignment operator: it is used only to allow mutators to work as described here. (See &lt;a href=&quot;#Assignments&quot;&gt;Assignments&lt;/a&gt; above.)</source>
          <target state="translated">&lt;code&gt;'='&lt;/code&gt; のサブルーチンは、Perlの代入演算子をオーバーロードしません。これは、ミューテーターがここで説明するように機能するためだけに使用されます。（上記の&lt;a href=&quot;#Assignments&quot;&gt;割り当てを&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="f6d2e2cf74b94dd2aff54191a4db818c472b013b" translate="yes" xml:space="preserve">
          <source>The subroutine for &lt;code&gt;'qr'&lt;/code&gt; is used wherever the object is interpolated into or used as a regexp, including when it appears on the RHS of a &lt;code&gt;=~&lt;/code&gt; or &lt;code&gt;!~&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;'qr'&lt;/code&gt; のサブルーチンは、オブジェクトが &lt;code&gt;=~&lt;/code&gt; または &lt;code&gt;!~&lt;/code&gt; 演算子のRHSに現れる場合を含め、オブジェクトが補間されるか正規表現として使用される場合に使用されます。</target>
        </trans-unit>
        <trans-unit id="64e556905a1003da7539606b5717985b47db5c9d" translate="yes" xml:space="preserve">
          <source>The subroutine for the assignment variant of an operator is required only to return the result of the operation. It is permitted to change the value of its operand (this is safe because Perl calls the copy constructor first), but this is optional since Perl assigns the returned value to the left-hand operand anyway.</source>
          <target state="translated">演算子の代入バリアントのサブルーチンは、演算結果を返すことだけが要求されます。オペランドの値を変更することは許されていますが(Perlは最初にコピーコンストラクタを呼び出すのでこれは安全です)、Perlはいずれにせよ返された値を左手のオペランドに代入するので、これはオプションです。</target>
        </trans-unit>
        <trans-unit id="ae06f7431af42fbc790df16df23af545b2646544" translate="yes" xml:space="preserve">
          <source>The subroutine interface has the advantage over the constants interface in that only two subroutines are exported into your namespace, versus thirty-eight in the constants interface, and aliases and true color attributes are supported. On the flip side, the constants interface has the advantage of better compile time error checking, since misspelled names of colors or attributes in calls to color() and colored() won't be caught until runtime whereas misspelled names of constants will be caught at compile time. So, pollute your namespace with almost two dozen subroutines that you may not even use that often, or risk a silly bug by mistyping an attribute. Your choice, TMTOWTDI after all.</source>
          <target state="translated">サブルーチンインターフェースは定数インターフェースに比べて、名前空間にエクスポートされるサブルーチンは2つだけですが、定数インターフェースでは38個です。その一方で、定数インタフェースにはコンパイル時のエラーチェックが容易になるという利点があります。そのため、それほど頻繁には使わないかもしれないサブルーチンで名前空間を汚したり、属性のスペルミスで愚かなバグを起こしたりする危険性があります。結局のところ、TMTOWTDIはあなたの選択です。</target>
        </trans-unit>
        <trans-unit id="bf76f7497b47b7fb391cbc985e75a2ec906b200f" translate="yes" xml:space="preserve">
          <source>The subroutine interface has the advantage over the constants interface in that only two subroutines are exported into your namespace, versus thirty-eight in the constants interface. On the flip side, the constants interface has the advantage of better compile time error checking, since misspelled names of colors or attributes in calls to color() and colored() won't be caught until runtime whereas misspelled names of constants will be caught at compile time. So, pollute your namespace with almost two dozen subroutines that you may not even use that often, or risk a silly bug by mistyping an attribute. Your choice, TMTOWTDI after all.</source>
          <target state="translated">サブルーチンインターフェースは定数インターフェースに比べて、名前空間にエクスポートされるサブルーチンが2つだけなのに対し、定数インターフェースでは38のサブルーチンがエクスポートされます。その一方で、定数インターフェイスにはコンパイル時のエラーチェックが容易になるという利点があります。そのため、それほど頻繁には使わないかもしれないサブルーチンで名前空間を汚したり、属性のスペルミスで愚かなバグを起こしたりする危険性があります。結局のところ、TMTOWTDIはあなたの選択です。</target>
        </trans-unit>
        <trans-unit id="914a52e2466ed981c0c31fa5a16b3a84e13235bf" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to five optional arguments:</source>
          <target state="translated">このサブルーチンは最大5つのオプションの引数を取ります。</target>
        </trans-unit>
        <trans-unit id="685ad04169c11394ad7ed60a2bfecf22cb675ffa" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to four optional arguments (the same set as &lt;code&gt;extract_tagged&lt;/code&gt; except for the string to be processed). It returns a reference to a subroutine which in turn takes a single argument (the text to be extracted from).</source>
          <target state="translated">サブルーチンは最大4つのオプションの引数を取ります（処理される文字列を除いて、 &lt;code&gt;extract_tagged&lt;/code&gt; と同じセット）。これはサブルーチンへの参照を返し、サブルーチンは単一の引数（テキストの抽出元）を受け取ります。</target>
        </trans-unit>
        <trans-unit id="8d893978d831c7b5b97d6abcf392307452f2c4dc" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to four optional arguments:</source>
          <target state="translated">このサブルーチンは最大4つのオプションの引数を取ります。</target>
        </trans-unit>
        <trans-unit id="7612ae6125d2980d42108a51846f43870c13a8ab" translate="yes" xml:space="preserve">
          <source>The subroutine takes up to two optional arguments:</source>
          <target state="translated">このサブルーチンは最大2つのオプションの引数を取ります。</target>
        </trans-unit>
        <trans-unit id="e4c12336d2e867ba9a727cf78cc335118965b26b" translate="yes" xml:space="preserve">
          <source>The subroutine that</source>
          <target state="translated">そのサブルーチンは</target>
        </trans-unit>
        <trans-unit id="2fc2edb73f368d2c8247ff6673cfa64dcc7b4601" translate="yes" xml:space="preserve">
          <source>The subroutine will have &lt;code&gt;CvFILE&lt;/code&gt; set according to &lt;code&gt;PL_curcop&lt;/code&gt;. Other aspects of the subroutine will be left in their default state. The caller is free to mutate the subroutine beyond its initial state after this function has returned.</source>
          <target state="translated">サブルーチンには、 &lt;code&gt;CvFILE&lt;/code&gt; に従ってCvFILEが設定され &lt;code&gt;PL_curcop&lt;/code&gt; 。サブルーチンの他の側面は、デフォルトの状態のままになります。呼び出し元は、この関数が戻った後、初期状態を超えてサブルーチンを自由に変更できます。</target>
        </trans-unit>
        <trans-unit id="265ef174cfb1c0102c91c9689e3bcac20840f609" translate="yes" xml:space="preserve">
          <source>The subroutine will have an empty prototype and will ignore any arguments when called. Its constant behaviour is determined by &lt;code&gt;sv&lt;/code&gt;. If &lt;code&gt;sv&lt;/code&gt; is null, the subroutine will yield an empty list. If &lt;code&gt;sv&lt;/code&gt; points to a scalar, the subroutine will always yield that scalar. If &lt;code&gt;sv&lt;/code&gt; points to an array, the subroutine will always yield a list of the elements of that array in list context, or the number of elements in the array in scalar context. This function takes ownership of one counted reference to the scalar or array, and will arrange for the object to live as long as the subroutine does. If &lt;code&gt;sv&lt;/code&gt; points to a scalar then the inlining assumes that the value of the scalar will never change, so the caller must ensure that the scalar is not subsequently written to. If &lt;code&gt;sv&lt;/code&gt; points to an array then no such assumption is made, so it is ostensibly safe to mutate the array or its elements, but whether this is really supported has not been determined.</source>
          <target state="translated">サブルーチンには空のプロトタイプがあり、呼び出されたときに引数を無視します。その一定の動作は &lt;code&gt;sv&lt;/code&gt; によって決定されます。場合 &lt;code&gt;sv&lt;/code&gt; nullの場合、サブルーチンは空のリストを生成します。 &lt;code&gt;sv&lt;/code&gt; がスカラーを指している場合、サブルーチンは常にそのスカラーを生成します。 &lt;code&gt;sv&lt;/code&gt; が配列を指している場合、サブルーチンは常にリストコンテキストでその配列の要素のリスト、またはスカラーコンテキストで配列内の要素の数を生成します。この関数は、スカラーまたは配列への1つのカウントされた参照の所有権を取得し、サブルーチンが存続する限りオブジェクトが存続するように調整します。 &lt;code&gt;sv&lt;/code&gt; の場合スカラーを指す場合、インライン化ではスカラーの値が変更されないと想定されるため、呼び出し元はスカラーが後で書き込まれないようにする必要があります。 &lt;code&gt;sv&lt;/code&gt; が配列を指している場合、そのような仮定は行われないため、配列またはその要素を変更することは表面上は安全ですが、これが実際にサポートされているかどうかは判断されていません。</target>
        </trans-unit>
        <trans-unit id="82f27fb61975933bf23afb22d7dcc89dbb6c6b52" translate="yes" xml:space="preserve">
          <source>The subroutine will have the entry point &lt;code&gt;subaddr&lt;/code&gt;. It will have the prototype specified by the nul-terminated string &lt;code&gt;proto&lt;/code&gt;, or no prototype if &lt;code&gt;proto&lt;/code&gt; is null. The prototype string is copied; the caller can mutate the supplied string afterwards. If &lt;code&gt;filename&lt;/code&gt; is non-null, it must be a nul-terminated filename, and the subroutine will have its &lt;code&gt;CvFILE&lt;/code&gt; set accordingly. By default &lt;code&gt;CvFILE&lt;/code&gt; is set to point directly to the supplied string, which must be static. If &lt;code&gt;flags&lt;/code&gt; has the &lt;code&gt;XS_DYNAMIC_FILENAME&lt;/code&gt; bit set, then a copy of the string will be taken instead.</source>
          <target state="translated">サブルーチンには、エントリポイント &lt;code&gt;subaddr&lt;/code&gt; があります。ヌル終了文字列 &lt;code&gt;proto&lt;/code&gt; で指定されたプロトタイプが含まれるか、 &lt;code&gt;proto&lt;/code&gt; がnullの場合はプロトタイプがありません。プロトタイプ文字列がコピーされます。呼び出し元は、指定された文字列を後で変更できます。 &lt;code&gt;filename&lt;/code&gt; がnull以外の場合は、nulで終了するファイル名である必要があり、サブルーチンではそれに応じて &lt;code&gt;CvFILE&lt;/code&gt; が設定されます。デフォルトでは、 &lt;code&gt;CvFILE&lt;/code&gt; は指定された文字列を直接指すように設定されており、静的である必要があります。 &lt;code&gt;flags&lt;/code&gt; に &lt;code&gt;XS_DYNAMIC_FILENAME&lt;/code&gt; ビットが設定されている場合は、代わりに文字列のコピーが取得されます。</target>
        </trans-unit>
        <trans-unit id="3a75faaa2a2f313dd76bd18e70bc1892ae4231d3" translate="yes" xml:space="preserve">
          <source>The subroutines for &lt;code&gt;'&quot;&quot;'&lt;/code&gt; , &lt;code&gt;'0+'&lt;/code&gt; , and &lt;code&gt;'bool'&lt;/code&gt; can return any arbitrary Perl value. If the corresponding operation for this value is overloaded too, the operation will be called again with this value.</source>
          <target state="translated">&lt;code&gt;'&quot;&quot;'&lt;/code&gt; 、 &lt;code&gt;'0+'&lt;/code&gt; 、および &lt;code&gt;'bool'&lt;/code&gt; のサブルーチンは、任意のPerl値を返すことができます。この値に対応する操作もオーバーロードされている場合、操作はこの値で再度呼び出されます。</target>
        </trans-unit>
        <trans-unit id="740359d4d5595e110911a4995def79d738d321f7" translate="yes" xml:space="preserve">
          <source>The subroutines for &lt;code&gt;'&quot;&quot;'&lt;/code&gt;, &lt;code&gt;'0+'&lt;/code&gt;, and &lt;code&gt;'bool'&lt;/code&gt; can return any arbitrary Perl value. If the corresponding operation for this value is overloaded too, the operation will be called again with this value.</source>
          <target state="translated">&lt;code&gt;'&quot;&quot;'&lt;/code&gt; 、 &lt;code&gt;'0+'&lt;/code&gt; 、および &lt;code&gt;'bool'&lt;/code&gt; のサブルーチンは、任意のPerl値を返すことができます。この値に対応する操作も過負荷になると、この値を使用して操作が再度呼び出されます。</target>
        </trans-unit>
        <trans-unit id="268a5bcbdfddf71f1babd661a5336aa5d10c3ae8" translate="yes" xml:space="preserve">
          <source>The subroutines must return a specially-formatted string, with one or more newline-separated lines. Each line must be one of the following:</source>
          <target state="translated">サブルーチンは、1行以上の改行で区切られた特殊な書式の文字列を返さなければなりません。各行は以下のいずれかでなければなりません。</target>
        </trans-unit>
        <trans-unit id="2ba07955562198fe0f02a6cf2bc902a4d38ec5bc" translate="yes" xml:space="preserve">
          <source>The subscript separator for multidimensional array emulation. If you refer to a hash element as</source>
          <target state="translated">多次元配列エミュレーションのための添え字区切り文字。ハッシュ要素を</target>
        </trans-unit>
        <trans-unit id="b5d318f376ec00a74018e4ca7dc7c929a2558708" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">置換演算子。&lt;a href=&quot;../perlop#Regexp-Quote-Like-Operators&quot;&gt;perlopのRegexp引用型演算子を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="96c15efd757813123cfb6bdf82217c841dbb4c27" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="translated">置換演算子。&lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlopの「RegexpQuote-LikeOperators」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cdda388fa507341e8fbaf2711ecce13a77670278" translate="yes" xml:space="preserve">
          <source>The substitution operator. See &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">置換演算子。&lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;perlopのRegexp引用型演算子を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="43eed4ac710279951c5f21e178623c718cf97122" translate="yes" xml:space="preserve">
          <source>The substring to be extracted must appear at the current &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; location of the string's variable (or at index zero, if no &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; position is defined). In other words, the &lt;code&gt;extract_...&lt;/code&gt; subroutines</source>
          <target state="translated">抽出される部分文字列は、文字列の変数の現在の &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 位置（または、 &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; 位置が定義されていない場合はインデックス0）に表示される必要があります。つまり、 &lt;code&gt;extract_...&lt;/code&gt; サブルーチン</target>
        </trans-unit>
        <trans-unit id="2d860483efae722d0cafa03a2a83e556d7c44ecb" translate="yes" xml:space="preserve">
          <source>The substring to be extracted must appear at the current &lt;code&gt;pos&lt;/code&gt; location of the string's variable (or at index zero, if no &lt;code&gt;pos&lt;/code&gt; position is defined). In other words, the &lt;code&gt;extract_...&lt;/code&gt; subroutines</source>
          <target state="translated">抽出される部分文字列は、文字列の変数の現在の &lt;code&gt;pos&lt;/code&gt; 位置（または、 &lt;code&gt;pos&lt;/code&gt; 位置が定義されていない場合はインデックス0）に表示される必要があります。言い換えれば、 &lt;code&gt;extract_...&lt;/code&gt; サブルーチン</target>
        </trans-unit>
        <trans-unit id="8c80d088e6c6c206a945e539d4bfb8f011c76009" translate="yes" xml:space="preserve">
          <source>The subtest event itself, with the first 2 events nested inside it as children.</source>
          <target state="translated">サブテストイベント自体、最初の2つのイベントがその中に子として入れ子になっています。</target>
        </trans-unit>
        <trans-unit id="631c84fac439176eea77875d9cd55aac6e34bef4" translate="yes" xml:space="preserve">
          <source>The subtle but sometimes brutal art of attempting to turn your possibly malformed program into a valid &lt;b&gt;syntax tree&lt;/b&gt;.</source>
          <target state="translated">おそらく不正な形式のプログラムを有効な&lt;b&gt;構文ツリー&lt;/b&gt;に変えようとする、微妙ですが時には残忍な技術。</target>
        </trans-unit>
        <trans-unit id="69b5462de54900759de9c61920b693e4e317aaf5" translate="yes" xml:space="preserve">
          <source>The subversion level of this package. The value of subversion comes from the</source>
          <target state="translated">このパッケージのサブバージョンレベル。subversion の値は</target>
        </trans-unit>
        <trans-unit id="270d4886cf1a538b0addd0c2b282f59bb7645fa0" translate="yes" xml:space="preserve">
          <source>The superuser (&lt;code&gt;UID&lt;/code&gt; == 0). Also the top-level directory of the filesystem.</source>
          <target state="translated">スーパーユーザー（ &lt;code&gt;UID&lt;/code&gt; == 0）。また、ファイルシステムの最上位ディレクトリ。</target>
        </trans-unit>
        <trans-unit id="bb4d5743fc0dd23109f98c367b228edac660d539" translate="yes" xml:space="preserve">
          <source>The support of Unicode is new starting from Perl version v5.6, and more fully implemented in versions v5.8 and later. See &lt;a href=&quot;perluniintro&quot;&gt;perluniintro&lt;/a&gt;.</source>
          <target state="translated">UnicodeのサポートはPerlバージョンv5.6から新しく追加され、バージョンv5.8以降ではより完全に実装されています。&lt;a href=&quot;perluniintro&quot;&gt;perluniintroを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6c60ded369392eed501121f572768a1d278a7c99" translate="yes" xml:space="preserve">
          <source>The supported features, documented further below, are:</source>
          <target state="translated">サポートされている機能は、以下の通りです。</target>
        </trans-unit>
        <trans-unit id="a84c55afdf9f74f3a1d06dd4132c903afc0559c7" translate="yes" xml:space="preserve">
          <source>The supported platforms are Linux, and OS X (some *BSD might work at least partly, but they have not yet been tested).</source>
          <target state="translated">サポートされているプラットフォームは Linux と OS X です (一部の *BSD は少なくとも部分的には動作するかもしれませんが、まだテストされていません)。</target>
        </trans-unit>
        <trans-unit id="c6fbcb6100de3c481ef36f607630c6994106ebd8" translate="yes" xml:space="preserve">
          <source>The surprising part is that &lt;code&gt;--a&lt;/code&gt; sets option &lt;code&gt;a&lt;/code&gt; (due to auto completion), not &lt;code&gt;all&lt;/code&gt; .</source>
          <target state="translated">驚くべきことは、-- &lt;code&gt;--a&lt;/code&gt; がオプション &lt;code&gt;a&lt;/code&gt; （自動補完のため）を設定することです。 &lt;code&gt;all&lt;/code&gt; ではありません。</target>
        </trans-unit>
        <trans-unit id="75d8922e6906461ffb1cdb138b9e2b992bbd28c0" translate="yes" xml:space="preserve">
          <source>The surprising part is that &lt;code&gt;--a&lt;/code&gt; sets option &lt;code&gt;a&lt;/code&gt; (due to auto completion), not &lt;code&gt;all&lt;/code&gt;.</source>
          <target state="translated">驚くべき部分は、 &lt;code&gt;--a&lt;/code&gt; が &lt;code&gt;all&lt;/code&gt; ではなくオプション &lt;code&gt;a&lt;/code&gt; を（オートコンプリートのために）設定することです。</target>
        </trans-unit>
        <trans-unit id="033617fd53c9330532a1c3d67c45fd0449d158c6" translate="yes" xml:space="preserve">
          <source>The surroundings or environment. The context given by the surrounding code determines what kind of data a particular &lt;b&gt;expression&lt;/b&gt; is expected to return. The three primary contexts are &lt;b&gt;list context&lt;/b&gt;, &lt;b&gt;scalar&lt;/b&gt;, and &lt;b&gt;void context&lt;/b&gt;. Scalar context is sometimes subdivided into &lt;b&gt;Boolean context&lt;/b&gt;, &lt;b&gt;numeric context&lt;/b&gt;, &lt;b&gt;string context&lt;/b&gt;, and &lt;b&gt;void context&lt;/b&gt;. There&amp;rsquo;s also a &amp;ldquo;don&amp;rsquo;t care&amp;rdquo; context (which is dealt with in Camel chapter 2, &amp;ldquo;Bits and Pieces&amp;rdquo;, if you care).</source>
          <target state="translated">周囲または環境。周囲のコードによって与えられるコンテキストは、特定の&lt;b&gt;式&lt;/b&gt;が返すと予想されるデータの種類を決定します。 3つの主要なコンテキストは、&lt;b&gt;リストコンテキスト&lt;/b&gt;、&lt;b&gt;スカラー&lt;/b&gt;、および&lt;b&gt;voidコンテキスト&lt;/b&gt;です。スカラーコンテキストは、&lt;b&gt;ブールコンテキスト&lt;/b&gt;、&lt;b&gt;数値コンテキスト&lt;/b&gt;、&lt;b&gt;文字列コンテキスト&lt;/b&gt;、および&lt;b&gt;ボイドコンテキストに&lt;/b&gt;細分される場合があり&lt;b&gt;ます&lt;/b&gt;。また、「気にしない」というコンテキストもあります（気になる場合は、Camelの第2章「ビットとピース」で扱います）。</target>
        </trans-unit>
        <trans-unit id="295e290eb0d08f2169eeef73696284f8eecaacb4" translate="yes" xml:space="preserve">
          <source>The sv_magic function uses &lt;code&gt;how&lt;/code&gt; to determine which, if any, predefined &quot;Magic Virtual Table&quot; should be assigned to the &lt;code&gt;mg_virtual&lt;/code&gt; field. See the &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;&quot;Magic Virtual Tables&quot;&lt;/a&gt; section below. The &lt;code&gt;how&lt;/code&gt; argument is also stored in the &lt;code&gt;mg_type&lt;/code&gt; field. The value of &lt;code&gt;how&lt;/code&gt; should be chosen from the set of macros &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; found in</source>
          <target state="translated">sv_magic関数は、事前定義された「マジック仮想テーブル」を &lt;code&gt;mg_virtual&lt;/code&gt; フィールドに割り当てる &lt;code&gt;how&lt;/code&gt; を決定する方法を使用します。以下の&lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;「マジック仮想テーブル」&lt;/a&gt;セクションを参照してください。 &lt;code&gt;how&lt;/code&gt; 引数もに保存されている &lt;code&gt;mg_type&lt;/code&gt; のフィールド。値が &lt;code&gt;how&lt;/code&gt; マクロのセットから選択する必要があります &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; がで見つかりました</target>
        </trans-unit>
        <trans-unit id="ed80b515b4081009a4556929c3f21adbe337dfc8" translate="yes" xml:space="preserve">
          <source>The sv_magic function uses &lt;code&gt;how&lt;/code&gt; to determine which, if any, predefined &quot;Magic Virtual Table&quot; should be assigned to the &lt;code&gt;mg_virtual&lt;/code&gt; field. See the &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; section below. The &lt;code&gt;how&lt;/code&gt; argument is also stored in the &lt;code&gt;mg_type&lt;/code&gt; field. The value of &lt;code&gt;how&lt;/code&gt; should be chosen from the set of macros &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; found in</source>
          <target state="translated">sv_magic関数は、 &lt;code&gt;mg_virtual&lt;/code&gt; フィールドに割り当てる必要がある事前定義された「マジック仮想テーブル」がある場合は、それを決定する &lt;code&gt;how&lt;/code&gt; を使用します。以下の&lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt;セクションを参照してください。 &lt;code&gt;how&lt;/code&gt; 引数もに保存されている &lt;code&gt;mg_type&lt;/code&gt; のフィールド。 &lt;code&gt;how&lt;/code&gt; の値は、 &lt;code&gt;PERL_MAGIC_foo&lt;/code&gt; 場所にあるマクロPERL_MAGIC_fooのセットから選択する必要があります</target>
        </trans-unit>
        <trans-unit id="6d632295f69a2e258303de734a1930d293a5d47a" translate="yes" xml:space="preserve">
          <source>The switch statement is called &lt;code&gt;given/when&lt;/code&gt; and only available in perl 5.10 or newer. See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;Switch Statements in perlsyn&lt;/a&gt;.</source>
          <target state="translated">switchステートメントは &lt;code&gt;given/when&lt;/code&gt; と呼ばれ、perl 5.10以降でのみ使用できます。&lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;perlsynのSwitchステートメントを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="51ab4452b7e8aefb4a20c0fd55e5ee11bfae3081" translate="yes" xml:space="preserve">
          <source>The switch statement is called &lt;code&gt;given&lt;/code&gt;/&lt;code&gt;when&lt;/code&gt; and only available in perl 5.10 or newer. See &lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;&quot;Switch Statements&quot; in perlsyn&lt;/a&gt;.</source>
          <target state="translated">switchステートメントは &lt;code&gt;given&lt;/code&gt; / &lt;code&gt;when&lt;/code&gt; と呼ばれ、perl5.10以降でのみ使用できます。&lt;a href=&quot;perlsyn#Switch-Statements&quot;&gt;perlsynの「Switchステートメント」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="9cc5a13c9ade0909b5ffefb1aee0a9413eb8d3b5" translate="yes" xml:space="preserve">
          <source>The switches above deserve explanation. &lt;code&gt;--no-ff&lt;/code&gt; indicates that even if all your work can be applied linearly against blead, a merge commit should still be prepared. This ensures that all your work will be shown as a side branch, with all its commits merged into the mainstream blead by the merge commit.</source>
          <target state="translated">上記のスイッチは説明に値します。 &lt;code&gt;--no-ff&lt;/code&gt; は、すべての作業をbleadに対して線形に適用できる場合でも、マージコミットを準備する必要があることを示します。これにより、すべての作業がサイドブランチとして表示され、すべてのコミットがマージコミットによってメインストリームのbleadにマージされます。</target>
        </trans-unit>
        <trans-unit id="9b8e93cb0b51582c675d9a8aa40dc2d0d3cfccab" translate="yes" xml:space="preserve">
          <source>The switches here are -r to recurse into any directories below 't' and -b which adds ./blib/lib and ./blib/arch to Perl's include path so that the tests can find the code they will be testing. If I'm testing a module of which an earlier version is already installed I need to be careful about the include path to make sure I'm not running my tests against the installed version rather than the new one that I'm working on.</source>
          <target state="translated">ここでのスイッチは、't'以下のディレクトリに再帰するための -r と、Perl のインクルードパスに ./blib/lib と ./blib/arch を追加し、テストするコードを見つけられるようにするための -b です。以前のバージョンが既にインストールされているモジュールをテストしている場合、私はインクルードパスに注意して、私が作業している新しいバージョンではなく、インストールされているバージョンに対してテストを実行していないことを確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="ea55b37c83e9242fca02717bc11a9fce7934d1e9" translate="yes" xml:space="preserve">
          <source>The symbol between angle brackets indicates the op's type, for example; &amp;lt;2&amp;gt; is a BINOP, &amp;lt;@&amp;gt; a LISTOP, and &amp;lt;#&amp;gt; is a PADOP, which is used in threaded perls. (see &lt;a href=&quot;#OP-class-abbreviations&quot;&gt;&quot;OP class abbreviations&quot;&lt;/a&gt;).</source>
          <target state="translated">山かっこで囲まれた記号は、たとえば、操作のタイプを示します。&amp;lt;2&amp;gt;はBINOP、&amp;lt;@&amp;gt;はLISTOP、&amp;lt;＃&amp;gt;はPADOPであり、スレッド化されたperlで使用されます。（&lt;a href=&quot;#OP-class-abbreviations&quot;&gt;「OPクラスの略語」を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="fd4512bd52c00d29ccebf2f597b2a43c4da8833a" translate="yes" xml:space="preserve">
          <source>The symbol between angle brackets indicates the op's type, for example; &amp;lt;2&amp;gt; is a BINOP, &amp;lt;@&amp;gt; a LISTOP, and &amp;lt;#&amp;gt; is a PADOP, which is used in threaded perls. (see &lt;a href=&quot;#OP-class-abbreviations&quot;&gt;OP class abbreviations&lt;/a&gt;).</source>
          <target state="translated">山カッコの間の記号は、たとえばopのタイプを示します。&amp;lt;2&amp;gt;はBINOP、&amp;lt;@&amp;gt;はLISTOP、&amp;lt;＃&amp;gt;はスレッド化されたperlで使用されるPADOPです。（&lt;a href=&quot;#OP-class-abbreviations&quot;&gt;OPクラスの省略形を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="2fa8c942f2b2a058230427b77fde679fbccbc45f" translate="yes" xml:space="preserve">
          <source>The symbol table for a package happens to be stored in the hash of that name with two colons appended. The main symbol table's name is thus &lt;code&gt;%main::&lt;/code&gt; , or &lt;code&gt;%::&lt;/code&gt; for short. Likewise the symbol table for the nested package mentioned earlier is named &lt;code&gt;%OUTER::INNER::&lt;/code&gt; .</source>
          <target state="translated">パッケージのシンボルテーブルは、たまたまその名前のハッシュに2つのコロンが追加されて格納されます。したがって、メインシンボルテーブルの名前は &lt;code&gt;%main::&lt;/code&gt; または &lt;code&gt;%::&lt;/code&gt; です。同様に、前述のネストされたパッケージのシンボルテーブルの名前は &lt;code&gt;%OUTER::INNER::&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="309a96ca92bbc8636f854ec2354e0659976f1abe" translate="yes" xml:space="preserve">
          <source>The symbol table for a package happens to be stored in the hash of that name with two colons appended. The main symbol table's name is thus &lt;code&gt;%main::&lt;/code&gt;, or &lt;code&gt;%::&lt;/code&gt; for short. Likewise the symbol table for the nested package mentioned earlier is named &lt;code&gt;%OUTER::INNER::&lt;/code&gt;.</source>
          <target state="translated">パッケージのシンボルテーブルは、たまたまその名前のハッシュに2つのコロンが追加されて格納されています。したがって、メインシンボルテーブルの名前は、 &lt;code&gt;%main::&lt;/code&gt; 、または略して &lt;code&gt;%::&lt;/code&gt; です。同様に、前述のネストされたパッケージのシンボルテーブルの名前は &lt;code&gt;%OUTER::INNER::&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="d4d8237c3f2b5d66316d69a0012fa0f4c23704f9" translate="yes" xml:space="preserve">
          <source>The symbol table is filled with names looking like line-noise.</source>
          <target state="translated">シンボルテーブルには、ラインノイズのような名前が並んでいます。</target>
        </trans-unit>
        <trans-unit id="9284dc458d23c8892508c2adfd2449416ee1df69" translate="yes" xml:space="preserve">
          <source>The symbolic constants for the mode argument are exported by VMS::Stdio by default, and are also exported by the Fcntl package.</source>
          <target state="translated">mode 引数のシンボリック定数はデフォルトで VMS::Stdio によってエクスポートされ、Fcntl パッケージによってもエクスポートされます。</target>
        </trans-unit>
        <trans-unit id="c5234fa33c4424920b3b6f455994e7727a2634e0" translate="yes" xml:space="preserve">
          <source>The symbols, ZIP_CM_STORE, ZIP_CM_DEFLATE, ZIP_CM_BZIP2 and ZIP_CM_LZMA are used to select the compression method.</source>
          <target state="translated">圧縮方式の選択には、ZIP_CM_STORE、ZIP_CM_DEFLATE、ZIP_CM_BZIP2、ZIP_CM_LZMAという記号を使用します。</target>
        </trans-unit>
        <trans-unit id="b89d5eb1a6608598259ad58b96f51e05f4c62a8d" translate="yes" xml:space="preserve">
          <source>The synonym Strtod() may be used instead.</source>
          <target state="translated">同義語の Strtod()を代わりに使用することができます。</target>
        </trans-unit>
        <trans-unit id="0e5ab20507b2337eca95f7b51820364382691825" translate="yes" xml:space="preserve">
          <source>The syntactic position falling between a method call and its arguments when using the indirect object invocation syntax. (The slot is distinguished by the absence of a comma between it and the next argument.) &lt;code&gt;STDERR&lt;/code&gt; is in the indirect object slot here:</source>
          <target state="translated">間接オブジェクト呼び出し構文を使用する場合、構文の位置はメソッド呼び出しとその引数の間にあります。（スロットは、次の引数との間にコンマがないことで区別されます。） &lt;code&gt;STDERR&lt;/code&gt; は、ここの間接オブジェクトスロットにあります。</target>
        </trans-unit>
        <trans-unit id="f8f8b505ce05315e1a17e36787d4eec3e6ea7c76" translate="yes" xml:space="preserve">
          <source>The syntax</source>
          <target state="translated">構文は</target>
        </trans-unit>
        <trans-unit id="98466f6b4c50ed9b1b9be5898a44ee0da163a090" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;(?[ ])&lt;/code&gt; in a regular expression yields a list of single code points, none can be a sequence.</source>
          <target state="translated">正規表現の構文 &lt;code&gt;(?[ ])&lt;/code&gt; は、単一のコードポイントのリストを生成しますが、シーケンスにすることはできません。</target>
        </trans-unit>
        <trans-unit id="ba4b4939723b8e356e5354c0a4613ac1ca8c7fbd" translate="yes" xml:space="preserve">
          <source>The syntax and behavior is similar to a &lt;code&gt;SKIP: BLOCK&lt;/code&gt; except the tests will be marked as failing but todo. &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret them as passing.</source>
          <target state="translated">構文と動作は &lt;code&gt;SKIP: BLOCK&lt;/code&gt; 似ていますが、テストは失敗としてマークされますが、やることがあります。&lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt;はそれらを合格と解釈します。</target>
        </trans-unit>
        <trans-unit id="b260d025f9cb3da5ac539f033e81a2ed933eaba6" translate="yes" xml:space="preserve">
          <source>The syntax and behavior is similar to a &lt;code&gt;SKIP: BLOCK&lt;/code&gt; except the tests will be marked as failing but todo. &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; will interpret them as passing.</source>
          <target state="translated">構文と動作は &lt;code&gt;SKIP: BLOCK&lt;/code&gt; と似ていますが、テストが失敗したがtodoとしてマークされる点が異なります。&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt;はそれらを合格と解釈します。</target>
        </trans-unit>
        <trans-unit id="47cc68a8f32c23223d1563cd08d4fd0cd4cd2e20" translate="yes" xml:space="preserve">
          <source>The syntax for &lt;code&gt;skip&lt;/code&gt; is about the only way it can be, but it's still quite confusing. Just start with the above examples and you'll be okay.</source>
          <target state="translated">&lt;code&gt;skip&lt;/code&gt; の構文は、それが可能な唯一の方法ですが、それでもかなり混乱します。上記の例から始めるだけで大​​丈夫です。</target>
        </trans-unit>
        <trans-unit id="ad53e9b382fc96ff2b2e55cab8f01b18f6934cd1" translate="yes" xml:space="preserve">
          <source>The syntax for an Input FileGlob is identical to &lt;code&gt;File::Glob&lt;/code&gt; , except for the following</source>
          <target state="translated">入力FileGlobの構文は、以下を除いて &lt;code&gt;File::Glob&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="91b339d4084c59a0f56840bad513aaf8cf0b9224" translate="yes" xml:space="preserve">
          <source>The syntax for an Input FileGlob is identical to &lt;code&gt;File::Glob&lt;/code&gt;, except for the following</source>
          <target state="translated">Input FileGlobの構文は、次の点を除いて &lt;code&gt;File::Glob&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="d238d90126a97e645c3d07a616c57a948aa56c49" translate="yes" xml:space="preserve">
          <source>The syntax for encoding text strings to binary strings is as simple as decoding:</source>
          <target state="translated">テキスト文字列をバイナリ文字列にエンコードする構文は、デコードと同じくらい簡単です。</target>
        </trans-unit>
        <trans-unit id="6de19f7b88c80bb9cdb41dbc1a8bdd69b98ff8b9" translate="yes" xml:space="preserve">
          <source>The syntax of patterns used in Perl pattern matching evolved from those supplied in the Bell Labs Research Unix 8th Edition (Version 8) regex routines. (The code is actually derived (distantly) from Henry Spencer's freely redistributable reimplementation of those V8 routines.)</source>
          <target state="translated">Perl のパターンマッチングで使用されるパターンの構文は、Bell Labs Research Unix 第 8 版 (バージョン 8)の正規表現ルーチンで提供されているものから発展したものです。(このコードは、Henry Spencer氏が自由に再配布可能なV8ルーチンの再実装から(遠く離れて)派生したものです)。</target>
        </trans-unit>
        <trans-unit id="0de2770d6e55eee81f76094997c8b0b61106fb04" translate="yes" xml:space="preserve">
          <source>The syntax:</source>
          <target state="translated">構文です。</target>
        </trans-unit>
        <trans-unit id="6e911200da76df16e0a83de577d8669f75cca2df" translate="yes" xml:space="preserve">
          <source>The sysread(), recv(), syswrite() and send() operators are deprecated on handles that have the &lt;code&gt;:utf8&lt;/code&gt; layer, either explicitly, or implicitly, eg., with the &lt;code&gt;:encoding(UTF-16LE)&lt;/code&gt; layer.</source>
          <target state="translated">sysread（）、recv（）、syswrite（）、およびsend（）演算子は、明示的または暗黙的に、たとえば &lt;code&gt;:encoding(UTF-16LE)&lt;/code&gt; レイヤーを使用して、 &lt;code&gt;:utf8&lt;/code&gt; レイヤーを持つハンドルでは非推奨になります。</target>
        </trans-unit>
        <trans-unit id="a6f851731919e85a8b6dbd2464120f7f6baa4b5b" translate="yes" xml:space="preserve">
          <source>The system being designed is large, or is likely to become large.</source>
          <target state="translated">設計されているシステムが大きい、または大きくなる可能性が高い。</target>
        </trans-unit>
        <trans-unit id="a8562e11d0057f4470ed7be8cd68c00d5386166f" translate="yes" xml:space="preserve">
          <source>The system copy routine may also be called directly under VMS and OS/2 as &lt;code&gt;File::Copy::syscopy&lt;/code&gt; (or under VMS as &lt;code&gt;File::Copy::rmscopy&lt;/code&gt; , which is the routine that does the actual work for syscopy).</source>
          <target state="translated">システムコピールーチンは、VMSおよびOS / 2で &lt;code&gt;File::Copy::syscopy&lt;/code&gt; （またはVMSで &lt;code&gt;File::Copy::rmscopy&lt;/code&gt; として直接呼び出すこともできます。これは、syscopyの実際の作業を行うルーチンです）。</target>
        </trans-unit>
        <trans-unit id="b94efe0827258f7a0df5937358145073b3689390" translate="yes" xml:space="preserve">
          <source>The system copy routine may also be called directly under VMS and OS/2 as &lt;code&gt;File::Copy::syscopy&lt;/code&gt; (or under VMS as &lt;code&gt;File::Copy::rmscopy&lt;/code&gt;, which is the routine that does the actual work for syscopy).</source>
          <target state="translated">システムのコピー・ルーチンとしてもVMSおよびOS / 2の下で直接呼び出すことも &lt;code&gt;File::Copy::syscopy&lt;/code&gt; （またはVMSの下など &lt;code&gt;File::Copy::rmscopy&lt;/code&gt; 、SYSCOPYのための実際の作業を行うルーチンです）。</target>
        </trans-unit>
        <trans-unit id="3b60dcb15de0e9f8fb8f2aec0c96f53a958b30c3" translate="yes" xml:space="preserve">
          <source>The system design is already object-oriented.</source>
          <target state="translated">システム設計はすでにオブジェクト指向です。</target>
        </trans-unit>
        <trans-unit id="252893c973435ea38255f9114e6c78b7c2f4935b" translate="yes" xml:space="preserve">
          <source>The system function it replaces can have its static return buffer trashed, not only by a subesequent call to that function, but by a &lt;code&gt;freelocale&lt;/code&gt;, &lt;code&gt;setlocale&lt;/code&gt;, or other locale change. The returned buffer of this function is not changed until the next call to it, so the buffer is never in a trashed state.</source>
          <target state="translated">置き換えるシステム関数は、その関数への後続の呼び出しだけでなく、 &lt;code&gt;freelocale&lt;/code&gt; 、 &lt;code&gt;setlocale&lt;/code&gt; 、またはその他のロケールの変更によって、静的リターンバッファーを破棄する可能性があります。この関数の返されるバッファは、次に呼び出されるまで変更されないため、バッファがゴミ箱に入れられることはありません。</target>
        </trans-unit>
        <trans-unit id="f2d2b02a34c5f3a2771d92387a8965fe957ed399" translate="yes" xml:space="preserve">
          <source>The system ignores the first line and feeds the program to</source>
          <target state="translated">システムは最初の行を無視して、プログラムを</target>
        </trans-unit>
        <trans-unit id="f1eb32227e059ade5c92f6015a4dd65ea3a6bc28" translate="yes" xml:space="preserve">
          <source>The system time is the amount of time the kernel itself spent executing routines, or system calls, on behalf of this process user.</source>
          <target state="translated">システム時間は、カーネル自身がこのプロセスユーザに代わってルーチンやシステムコールを実行するのに費やした時間です。</target>
        </trans-unit>
        <trans-unit id="831ee4615baf52dd07f0a014bffa561cd6b8234d" translate="yes" xml:space="preserve">
          <source>The system time of the null loop might be slightly more than the system time of the loop with the actual code and therefore the difference might end up being &amp;lt; 0.</source>
          <target state="translated">nullループのシステム時間は、実際のコードを使用したループのシステム時間よりもわずかに長くなる可能性があるため、その差は最終的に0未満になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="5880c4b2f3b12a5f35ec0374b9437ee3cf2ad712" translate="yes" xml:space="preserve">
          <source>The system's notion of time of day and calendar date is controlled in widely different ways. Don't assume the timezone is stored in &lt;code&gt;$ENV{TZ}&lt;/code&gt; , and even if it is, don't assume that you can control the timezone through that variable. Don't assume anything about the three-letter timezone abbreviations (for example that MST would be the Mountain Standard Time, it's been known to stand for Moscow Standard Time). If you need to use timezones, express them in some unambiguous format like the exact number of minutes offset from UTC, or the POSIX timezone format.</source>
          <target state="translated">システムの時刻とカレンダーの日付の概念は、さまざまな方法で制御されます。タイムゾーンが &lt;code&gt;$ENV{TZ}&lt;/code&gt; に格納されていると想定しないでください。そうであっても、その変数によってタイムゾーンを制御できると想定しないでください。 3文字のタイムゾーンの省略形については何も想定しないでください（たとえば、MSTは山岳部標準時であり、モスクワ標準時を表すことが知られています）。タイムゾーンを使用する必要がある場合は、UTCからの正確な分数オフセットやPOSIXタイムゾーン形式など、明確な形式でそれらを表現します。</target>
        </trans-unit>
        <trans-unit id="ed3226a2f2631da1a16aa62735723438d4e491ac" translate="yes" xml:space="preserve">
          <source>The system's notion of time of day and calendar date is controlled in widely different ways. Don't assume the timezone is stored in &lt;code&gt;$ENV{TZ}&lt;/code&gt;, and even if it is, don't assume that you can control the timezone through that variable. Don't assume anything about the three-letter timezone abbreviations (for example that MST would be the Mountain Standard Time, it's been known to stand for Moscow Standard Time). If you need to use timezones, express them in some unambiguous format like the exact number of minutes offset from UTC, or the POSIX timezone format.</source>
          <target state="translated">システムの時刻とカレンダーの日付の概念は、大きく異なる方法で制御されます。タイムゾーンが &lt;code&gt;$ENV{TZ}&lt;/code&gt; に格納されていると想定しないでください。格納されている場合でも、その変数を使用してタイムゾーンを制御できると想定しないでください。 3文字のタイムゾーンの略語については何も想定しないでください（たとえば、MSTは山岳部標準時であり、モスクワ標準時を表すことが知られています）。タイムゾーンを使用する必要がある場合は、UTCからオフセットされた正確な分数やPOSIXタイムゾーン形式など、明確な形式で表現してください。</target>
        </trans-unit>
        <trans-unit id="10bc5e79cfd3d40c28f5293903b887866aeb92ec" translate="yes" xml:space="preserve">
          <source>The table below has two columns. The left column contains the &lt;code&gt;\p{}&lt;/code&gt; constructs to look up, possibly preceded by the flags mentioned above; and the right column contains information about them, like a description, or synonyms. The table shows both the single and compound forms for each property that has them. If the left column is a short name for a property, the right column will give its longer, more descriptive name; and if the left column is the longest name, the right column will show any equivalent shortest name, in both single and compound forms if applicable.</source>
          <target state="translated">以下の表には2つの列があります。左側の列には、検索する &lt;code&gt;\p{}&lt;/code&gt; 構成が含まれています。前にフラグが付いている可能性があります。右側の列には、説明や同義語など、それらに関する情報が含まれています。次の表は、それらを持つ各プロパティの単一フォームと複合フォームの両方を示しています。左側の列がプロパティの短い名前である場合、右側の列には、より長く、よりわかりやすい名前が付けられます。左側の列が最も長い名前である場合、右側の列には、該当する場合、単一形式と複合形式の両方で、同等の最も短い名前が表示されます。</target>
        </trans-unit>
        <trans-unit id="1666e90a958abe062ff0c13eedc4273819f1aea6" translate="yes" xml:space="preserve">
          <source>The table file should locate in the</source>
          <target state="translated">テーブルファイルは</target>
        </trans-unit>
        <trans-unit id="0f20314df9f35b36eb10a691047b3cd3cf2ffd4f" translate="yes" xml:space="preserve">
          <source>The table in this section lists all the Perl API elements available, sorted by the version in which support starts. This includes all the elements that</source>
          <target state="translated">このセクションの表には、サポートが開始されたバージョン順に、利用可能なすべての Perl API 要素が一覧表示されます。これには</target>
        </trans-unit>
        <trans-unit id="b1154d069cc05928d8b59c50b5730e339b959183" translate="yes" xml:space="preserve">
          <source>The table of methods for all operations is cached in magic for the symbol table hash for the package. The cache is invalidated during processing of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; overload&lt;/code&gt; , new function definitions, and changes in @ISA.</source>
          <target state="translated">すべての操作のメソッドのテーブルは、パッケージのシンボルテーブルハッシュ用にマジックでキャッシュされます。キャッシュは、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; overload&lt;/code&gt; 、新しい関数定義、および@ISAでの変更の処理中に無効になります。</target>
        </trans-unit>
        <trans-unit id="2c1ebd6c35d6d5b09dedbf5b41acedd8ee971357" translate="yes" xml:space="preserve">
          <source>The table of methods for all operations is cached in magic for the symbol table hash for the package. The cache is invalidated during processing of &lt;code&gt;use overload&lt;/code&gt;, &lt;code&gt;no overload&lt;/code&gt;, new function definitions, and changes in @ISA.</source>
          <target state="translated">すべての操作のメソッドのテーブルは、パッケージのシンボルテーブルハッシュのマジックにキャッシュされます。キャッシュは、 &lt;code&gt;use overload&lt;/code&gt; 、 &lt;code&gt;no overload&lt;/code&gt; 、新しい関数定義、および@ISAの変更の処理中に無効になります。</target>
        </trans-unit>
        <trans-unit id="dcf2718afd051a8a2171808fbbd533fc26865cc1" translate="yes" xml:space="preserve">
          <source>The table of smartmatches in &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;&quot;Smartmatch Operator&quot; in perlop&lt;/a&gt; is not identical to that proposed by the Raku specification, mainly due to differences between Raku's and Perl 5's data models, but also because the Raku spec has changed since Perl 5 rushed into early adoption.</source>
          <target state="translated">perlopの&lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;「SmartmatchOperator」のスマート&lt;/a&gt;マッチの表は、主にRakuとPerl 5のデータモデルの違いのため、またPerl 5が早期に採用されてからRaku仕様が変更されたため、Raku仕様で提案されたものと同じではありません。</target>
        </trans-unit>
        <trans-unit id="b36cd501ad88aba2f3b3a0d1d67027c7a1e869d6" translate="yes" xml:space="preserve">
          <source>The table of smartmatches in &lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;Smartmatch Operator in perlop&lt;/a&gt; is not identical to that proposed by the Perl 6 specification, mainly due to differences between Perl 6's and Perl 5's data models, but also because the Perl 6 spec has changed since Perl 5 rushed into early adoption.</source>
          <target state="translated">&lt;a href=&quot;perlop#Smartmatch-Operator&quot;&gt;perlopのSmartmatch Operator&lt;/a&gt;のsmartmatchesのテーブルは、Perl 6の仕様によって提案されたものとは異なります。これは、主にPerl 6とPerl 5のデータモデルの違いによるものですが、Perl 5が早期に採用されてからPerl 6の仕様が変更されたためです。</target>
        </trans-unit>
        <trans-unit id="744a22264ceb5e3af0d89371d88c54fa44eb074f" translate="yes" xml:space="preserve">
          <source>The table structure:</source>
          <target state="translated">テーブルの構造です。</target>
        </trans-unit>
        <trans-unit id="94ad06074e14c7f30c5f734701604346041b5cbc" translate="yes" xml:space="preserve">
          <source>The tangent</source>
          <target state="translated">接線</target>
        </trans-unit>
        <trans-unit id="9125938896cf0c452742065869d161bf7df834a0" translate="yes" xml:space="preserve">
          <source>The tarball can be created as follows:</source>
          <target state="translated">タールボールは以下のように作成することができます。</target>
        </trans-unit>
        <trans-unit id="5f3864dd27cd34c2e98d0ec223d6fceecc7c957c" translate="yes" xml:space="preserve">
          <source>The target directory to store the spec files in can be set using &lt;code&gt;dir&lt;/code&gt; as in</source>
          <target state="translated">スペックファイルを保存するターゲットディレクトリは、次のように &lt;code&gt;dir&lt;/code&gt; を使用して設定できます。</target>
        </trans-unit>
        <trans-unit id="b87ef1c14b4fb669d5f4570a38dcf5e22aa3e1b3" translate="yes" xml:space="preserve">
          <source>The target is to make OS/2 one of the best supported platform for using/building/developing Perl and</source>
          <target state="translated">目標は、OS/2をPerlの使用/構築/開発のための最高のサポートプラットフォームにすることです。</target>
        </trans-unit>
        <trans-unit id="f704785556fc74856ecd269c550a540acda7d08d" translate="yes" xml:space="preserve">
          <source>The target of the OP, or nothing for a nulled OP.</source>
          <target state="translated">ヌルいOPにしてはOPの対象でも何でもない。</target>
        </trans-unit>
        <trans-unit id="d551cba509e623574e29a4be73bb109e3d69062b" translate="yes" xml:space="preserve">
          <source>The template can take a different set of rules per key that is used.</source>
          <target state="translated">テンプレートは、使用するキーごとに異なるルールのセットを取ることができます。</target>
        </trans-unit>
        <trans-unit id="7dd55749521ef7a1d8d1762bd0dfd93dc2ed7572" translate="yes" xml:space="preserve">
          <source>The template may be any filename with some number of X's appended to it, for example</source>
          <target state="translated">テンプレートは、任意のファイル名にいくつかの数のXを付加したものを使用することができます。</target>
        </trans-unit>
        <trans-unit id="56fadcfb4c1428b721edcda3a997763e93a92ef4" translate="yes" xml:space="preserve">
          <source>The template may be any filename with some number of X's appended to it, for example F. The trailing X's are replaced with unique alphanumeric combinations.</source>
          <target state="translated">テンプレートは、例えばFのようにいくつかの数個のXを付加した任意のファイル名にすることができます。</target>
        </trans-unit>
        <trans-unit id="d2a0774e46a5ddeb6abfa59a3643d774d174d289" translate="yes" xml:space="preserve">
          <source>The temporaries stack stores pointers to xVs whose reference counts will be decremented soon.</source>
          <target state="translated">temporaries スタックには、参照カウントが間もなく減少する xV へのポインタが格納されます。</target>
        </trans-unit>
        <trans-unit id="b658a51743ea23f5f90b8615b574c3089e0c4bce" translate="yes" xml:space="preserve">
          <source>The tenth and subsequent priorities are to look in directories named</source>
          <target state="translated">10番目以降の優先順位は、次のような名前のディレクトリを探すことです。</target>
        </trans-unit>
        <trans-unit id="527fc2a5f793bc1d57c90fcfdd90ce2b38cfafb9" translate="yes" xml:space="preserve">
          <source>The term &quot;native&quot; does not mean quite as much when we talk about native integers, as it does when native floating point numbers are involved. The only implication of the term &quot;native&quot; on integers is that the limits for the maximal and the minimal supported true integral quantities are close to powers of 2. However, &quot;native&quot; floats have a most fundamental restriction: they may represent only those numbers which have a relatively &quot;short&quot; representation when converted to a binary fraction. For example, 0.9 cannot be represented by a native float, since the binary fraction for 0.9 is infinite:</source>
          <target state="translated">ネイティブ」という言葉は、ネイティブな整数について話すときにはあまり意味がありませんが、ネイティブな浮動小数点数が関係しているときにはあまり意味がありません。整数に対する「ネイティブ」という言葉の意味は、サポートされる真の積分量の最大値と最小値の限界が2の累乗に近いということだけです。 しかし、「ネイティブ」フロートには最も基本的な制限があります。それは、2進数に変換されたときに比較的「短い」表現を持つ数だけを表現できるということです。例えば、0.9の2進数は無限大なので、0.9はネイティブフロートでは表現できません。</target>
        </trans-unit>
        <trans-unit id="60065770d703c59b1d8e19903d480a6c8c3d4ce7" translate="yes" xml:space="preserve">
          <source>The term &quot;railroad normal form&quot; is a bit esoteric, with &quot;syntax diagram/charts&quot;, or &quot;railroad diagram/charts&quot; being more common terms. Nevertheless it provides a useful mental image of a regex program: each node can be thought of as a unit of track, with a single entry and in most cases a single exit point (there are pieces of track that fork, but statistically not many), and the whole forms a layout with a single entry and single exit point. The matching process can be thought of as a car that moves along the track, with the particular route through the system being determined by the character read at each possible connector point. A car can fall off the track at any point but it may only proceed as long as it matches the track.</source>
          <target state="translated">鉄道の通常の形式」という用語は少し難解で、「構文図/チャート」や「鉄道の図/チャート」の方が一般的な用語です。各ノードは軌道の単位として考えることができ、ほとんどの場合、単一の入口と単一の出口を持ちます(分岐する軌道はありますが、統計的には多くはありません)。マッチングプロセスは、トラックに沿って移動する車両と考えることができ、システムを通る特定のルートは、各可能なコネクタポイントで読み取られた文字によって決定されます。車はどの時点でもトラックから落ちることができますが、トラックと一致している間だけ進むことができます。</target>
        </trans-unit>
        <trans-unit id="cb8cf5974b1ed2433ffc34db8b95199dcc132ecd" translate="yes" xml:space="preserve">
          <source>The term 'mathemagic' describes the overloaded implementation of mathematical operators. Mathemagical operations raise an issue. Consider the code:</source>
          <target state="translated">マテマジック」という用語は、数学演算子の過負荷な実装を説明しています。数学的演算子は問題を提起します。コードを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="eaeae7045f589906beb0ab8c4692ec54095f2a80" translate="yes" xml:space="preserve">
          <source>The term, &quot;Unicode bug&quot; has been applied to an inconsistency with the code points in the &lt;code&gt;Latin-1 Supplement&lt;/code&gt; block, that is, between 128 and 255. Without a locale specified, unlike all other characters or code points, these characters can have very different semantics depending on the rules in effect. (Characters whose code points are above 255 force Unicode rules; whereas the rules for ASCII characters are the same under both ASCII and Unicode rules.)</source>
          <target state="translated">「Unicodeバグ」という用語は、 &lt;code&gt;Latin-1 Supplement&lt;/code&gt; ブロックのコードポイントとの不一致、つまり128〜255に適用されています。他のすべての文字やコードポイントとは異なり、ロケールを指定しないと、これらの文字は有効な規則に応じて、非常に異なるセマンティクス。（コードポイントが255を超える文字はUnicodeルールを強制しますが、ASCII文字のルールはASCIIルールとUnicodeルールの両方で同じです。）</target>
        </trans-unit>
        <trans-unit id="694ad9d197b3bccc91651d679f02271b6dd9c6f8" translate="yes" xml:space="preserve">
          <source>The terminal output bit rate (often mistakenly called the baud rate) for this terminal - if not set a warning will be generated and it will be defaulted to 9600.</source>
          <target state="translated">このターミナルの出力ビットレート(ボーレートと誤って呼ばれることもあります)-設定されていない場合は警告が発生し、デフォルトは 9600 になります。</target>
        </trans-unit>
        <trans-unit id="45cdb3e3cad66807c8dfdf23c9cff4fc7bd36017" translate="yes" xml:space="preserve">
          <source>The terminal type whose termcap entry will be used - if not supplied it will default to $ENV{TERM}: if that is not set then &lt;b&gt;Tgetent&lt;/b&gt; will croak.</source>
          <target state="translated">termcapエントリが使用される端末タイプ-提供されない場合、デフォルトで$ ENV {TERM}になります。それが設定されていない場合、&lt;b&gt;Tgetent&lt;/b&gt;は&lt;b&gt;クロークし&lt;/b&gt;ます。</target>
        </trans-unit>
        <trans-unit id="a8d5f39cee7740c7c53d20d14cbf1ad8092c45e0" translate="yes" xml:space="preserve">
          <source>The terminating string may be either an identifier (a word), or some quoted text. An unquoted identifier works like double quotes. There may not be a space between the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and the identifier, unless the identifier is explicitly quoted. (If you put a space it will be treated as a null identifier, which is valid, and matches the first empty line.) The terminating string must appear by itself (unquoted and with no surrounding whitespace) on the terminating line.</source>
          <target state="translated">終了文字列は、識別子（単語）または引用テキストのいずれかです。引用符で囲まれていない識別子は、二重引用符のように機能します。識別子が明示的に引用されていない限り、 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; と識別子の間にスペースがない場合があります。（スペースを入れると、ヌルIDとして扱われます。これは有効であり、最初の空行と一致します。）終了ストリングは、終了行に単独で（引用符で囲まず、周囲に空白を入れずに）出現する必要があります。</target>
        </trans-unit>
        <trans-unit id="10b4a47dbe9b183e3332ce5dc657e06a6f7d67c1" translate="yes" xml:space="preserve">
          <source>The terminating string may be either an identifier (a word), or some quoted text. An unquoted identifier works like double quotes. There may not be a space between the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and the identifier, unless the identifier is explicitly quoted. The terminating string must appear by itself (unquoted and with no surrounding whitespace) on the terminating line.</source>
          <target state="translated">終了文字列は、識別子（単語）または引用符で囲まれたテキストのいずれかです。引用符で囲まれていない識別子は、二重引用符のように機能します。識別子が明示的に引用されていない限り、 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; と識別子の間にスペースがあってはなりません。終了文字列は、それ自体で（引用符で囲まれておらず、周囲に空白がない状態で）終了行に表示される必要があります。</target>
        </trans-unit>
        <trans-unit id="693f7bb103883c0a728e204ee6c0e2c1249be088" translate="yes" xml:space="preserve">
          <source>The terminator of runtime &lt;code&gt;(?{...})&lt;/code&gt; is found by temporarily switching control to the perl parser, which should stop at the point where the logically balancing terminating &lt;code&gt;}&lt;/code&gt; is found.</source>
          <target state="translated">ランタイムのターミネータ &lt;code&gt;(?{...})&lt;/code&gt; は、制御をperlパーサーに一時的に切り替えることで見つかります。これは、論理的にバランスをとる終端 &lt;code&gt;}&lt;/code&gt; が見つかった時点で停止します。</target>
        </trans-unit>
        <trans-unit id="45074fa74bab84b7b8642e2f2cccf8a44bd5974b" translate="yes" xml:space="preserve">
          <source>The test</source>
          <target state="translated">テスト</target>
        </trans-unit>
        <trans-unit id="404700fb40de228f041c8b476423971728a238e9" translate="yes" xml:space="preserve">
          <source>The test harness leaves much to be desired. Patches welcome.</source>
          <target state="translated">ハーネスのテストは 望ましくない パッチを歓迎する</target>
        </trans-unit>
        <trans-unit id="a5f877c1b13f5bd28ecef34f68e2dcb7eb31de7b" translate="yes" xml:space="preserve">
          <source>The test name extensions. Defaults to &lt;code&gt;.t&lt;/code&gt;.</source>
          <target state="translated">テスト名の拡張子。デフォルトは &lt;code&gt;.t&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6571e20ce9a71fb843fe89c152d8dbe08235f523" translate="yes" xml:space="preserve">
          <source>The test phase is when the distribution's automated test suite is run. Any library that is needed only for testing and not for subsequent use should be listed here.</source>
          <target state="translated">テストフェーズは、ディストリビューションの自動テストスイートを実行するときです。テストのためだけに必要で、その後の使用には必要ないライブラリはすべてここに記載してください。</target>
        </trans-unit>
        <trans-unit id="18b17a09a74e93fa5e780df81bc80e5b90469686" translate="yes" xml:space="preserve">
          <source>The test suite is much better, but always needs improvement.</source>
          <target state="translated">テストスイートははるかに良くなっていますが、常に改善が必要です。</target>
        </trans-unit>
        <trans-unit id="710c520b5e701804e8b8991b8c559c8c70f62fc8" translate="yes" xml:space="preserve">
          <source>The test will exit with 255.</source>
          <target state="translated">テストは255で終了します。</target>
        </trans-unit>
        <trans-unit id="adc50b89ec0ba50b71ee74cf410505fc2fa0bc3e" translate="yes" xml:space="preserve">
          <source>The testing system is designed to be used by performing a three step process for each test you wish to test. This process starts with using &lt;code&gt;test_out&lt;/code&gt; and &lt;code&gt;test_err&lt;/code&gt; in advance to declare what the testsuite you are testing will output with &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; to stdout and stderr.</source>
          <target state="translated">テストシステムは、テストする各テストに対して3つのステッププロセスを実行することによって使用されるように設計されています。このプロセスは、事前に &lt;code&gt;test_out&lt;/code&gt; および &lt;code&gt;test_err&lt;/code&gt; を使用して、テストしているテストスイートが&lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt;でstdoutおよびstderrに出力する内容を宣言することから始まります。</target>
        </trans-unit>
        <trans-unit id="7d184971a14375f569314d2fb6a264dcab98a443" translate="yes" xml:space="preserve">
          <source>The testing system is designed to be used by performing a three step process for each test you wish to test. This process starts with using &lt;code&gt;test_out&lt;/code&gt; and &lt;code&gt;test_err&lt;/code&gt; in advance to declare what the testsuite you are testing will output with &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; to stdout and stderr.</source>
          <target state="translated">テストシステムは、テストするテストごとに3つのステップのプロセスを実行することによって使用されるように設計されています。このプロセスは、事前に &lt;code&gt;test_out&lt;/code&gt; と &lt;code&gt;test_err&lt;/code&gt; を使用して、テストしているテストスイートが&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt;でstdoutとstderrに出力するものを宣言することから始まります。</target>
        </trans-unit>
        <trans-unit id="e7d3c8b5f530bcb2e21b05b385528e49c2684bd6" translate="yes" xml:space="preserve">
          <source>The tests</source>
          <target state="translated">テスト</target>
        </trans-unit>
        <trans-unit id="a22b8fe6a3e6e46d5dd177a5cb8828e7b0955e47" translate="yes" xml:space="preserve">
          <source>The tests &lt;code&gt;-b&lt;/code&gt; , &lt;code&gt;-B&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; , &lt;code&gt;-d&lt;/code&gt; , &lt;code&gt;-e&lt;/code&gt; , &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-M&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-S&lt;/code&gt; , &lt;code&gt;-t&lt;/code&gt; , &lt;code&gt;-T&lt;/code&gt; , and &lt;code&gt;-z&lt;/code&gt; work as advertised. The return values for &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; tell you whether you can actually access the file; this may not reflect the UIC-based file protections. Since real and effective UIC don't differ under VMS, &lt;code&gt;-O&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-W&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; are equivalent to &lt;code&gt;-o&lt;/code&gt; , &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-x&lt;/code&gt; . Similarly, several other tests, including &lt;code&gt;-A&lt;/code&gt; , &lt;code&gt;-g&lt;/code&gt; , &lt;code&gt;-k&lt;/code&gt; , &lt;code&gt;-l&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; , and &lt;code&gt;-u&lt;/code&gt; , aren't particularly meaningful under VMS, and the values returned by these tests reflect whatever your CRTL &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; routine does to the equivalent bits in the st_mode field. Finally, &lt;code&gt;-d&lt;/code&gt; returns true if passed a device specification without an explicit directory (e.g. &lt;code&gt;DUA1:&lt;/code&gt; ), as well as if passed a directory.</source>
          <target state="translated">テスト &lt;code&gt;-b&lt;/code&gt; 、 &lt;code&gt;-B&lt;/code&gt; 、 &lt;code&gt;-c&lt;/code&gt; 、 &lt;code&gt;-C&lt;/code&gt; 、 &lt;code&gt;-d&lt;/code&gt; 、 &lt;code&gt;-e&lt;/code&gt; 、 &lt;code&gt;-f&lt;/code&gt; 、 &lt;code&gt;-o&lt;/code&gt; 、 &lt;code&gt;-M&lt;/code&gt; 、 &lt;code&gt;-s&lt;/code&gt; 、 &lt;code&gt;-S&lt;/code&gt; 、 &lt;code&gt;-t&lt;/code&gt; 、 &lt;code&gt;-T&lt;/code&gt; 、および &lt;code&gt;-z&lt;/code&gt; は、宣伝どおりに機能します。 &lt;code&gt;-r&lt;/code&gt; 、 &lt;code&gt;-w&lt;/code&gt; 、および &lt;code&gt;-x&lt;/code&gt; の戻り値は、実際にファイルにアクセスできるかどうかを示します。これは、UICベースのファイル保護を反映していない場合があります。実際の効果的なUICはVMSでも同じなので、 &lt;code&gt;-O&lt;/code&gt; 、 &lt;code&gt;-R&lt;/code&gt; 、 &lt;code&gt;-W&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; は、 &lt;code&gt;-o&lt;/code&gt; 、 &lt;code&gt;-r&lt;/code&gt; 、 &lt;code&gt;-w&lt;/code&gt; 、および &lt;code&gt;-x&lt;/code&gt; と同等です。同様に、 &lt;code&gt;-A&lt;/code&gt; 、 &lt;code&gt;-g&lt;/code&gt; 、 &lt;code&gt;-k&lt;/code&gt; 、 &lt;code&gt;-l&lt;/code&gt; 、 &lt;code&gt;-p&lt;/code&gt; 、および &lt;code&gt;-u&lt;/code&gt; を含む他のいくつかのテストは、VMSでは特に意味がなく、これらのテストによって返される値は、CRTL &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat()&lt;/a&gt;&lt;/code&gt; ルーチンが行うことをすべて反映していますst_modeフィールドの同等のビットに。最後に、明示的なディレクトリ（例： &lt;code&gt;DUA1:&lt;/code&gt; )なしでデバイス仕様を渡した場合、およびディレクトリを渡した場合、 &lt;code&gt;-d&lt;/code&gt; はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="9c967d1ae062bd6388a4176bc92989ac103705dc" translate="yes" xml:space="preserve">
          <source>The tests &lt;code&gt;-b&lt;/code&gt;, &lt;code&gt;-B&lt;/code&gt;, &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt;, &lt;code&gt;-d&lt;/code&gt;, &lt;code&gt;-e&lt;/code&gt;, &lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-M&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, &lt;code&gt;-S&lt;/code&gt;, &lt;code&gt;-t&lt;/code&gt;, &lt;code&gt;-T&lt;/code&gt;, and &lt;code&gt;-z&lt;/code&gt; work as advertised. The return values for &lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, and &lt;code&gt;-x&lt;/code&gt; tell you whether you can actually access the file; this may not reflect the UIC-based file protections. Since real and effective UIC don't differ under VMS, &lt;code&gt;-O&lt;/code&gt;, &lt;code&gt;-R&lt;/code&gt;, &lt;code&gt;-W&lt;/code&gt;, and &lt;code&gt;-X&lt;/code&gt; are equivalent to &lt;code&gt;-o&lt;/code&gt;, &lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, and &lt;code&gt;-x&lt;/code&gt;. Similarly, several other tests, including &lt;code&gt;-A&lt;/code&gt;, &lt;code&gt;-g&lt;/code&gt;, &lt;code&gt;-k&lt;/code&gt;, &lt;code&gt;-l&lt;/code&gt;, &lt;code&gt;-p&lt;/code&gt;, and &lt;code&gt;-u&lt;/code&gt;, aren't particularly meaningful under VMS, and the values returned by these tests reflect whatever your CRTL &lt;code&gt;stat()&lt;/code&gt; routine does to the equivalent bits in the st_mode field. Finally, &lt;code&gt;-d&lt;/code&gt; returns true if passed a device specification without an explicit directory (e.g. &lt;code&gt;DUA1:&lt;/code&gt;), as well as if passed a directory.</source>
          <target state="translated">テスト &lt;code&gt;-b&lt;/code&gt; 、 &lt;code&gt;-B&lt;/code&gt; 、 &lt;code&gt;-c&lt;/code&gt; 、 &lt;code&gt;-C&lt;/code&gt; 、 &lt;code&gt;-d&lt;/code&gt; 、 &lt;code&gt;-e&lt;/code&gt; 、 &lt;code&gt;-f&lt;/code&gt; 、 &lt;code&gt;-o&lt;/code&gt; 、 &lt;code&gt;-M&lt;/code&gt; 、 &lt;code&gt;-s&lt;/code&gt; 、 &lt;code&gt;-S&lt;/code&gt; 、 &lt;code&gt;-t&lt;/code&gt; 、 &lt;code&gt;-T&lt;/code&gt; 、および &lt;code&gt;-z&lt;/code&gt; は、宣伝どおりに機能します。 &lt;code&gt;-r&lt;/code&gt; 、 &lt;code&gt;-w&lt;/code&gt; 、および &lt;code&gt;-x&lt;/code&gt; の戻り値は、実際にファイルにアクセスできるかどうかを示します。これは、UICベースのファイル保護を反映していない可能性があります。実際のUICと効果的なUICはVMSでも変わらないため、 &lt;code&gt;-O&lt;/code&gt; 、 &lt;code&gt;-R&lt;/code&gt; 、 &lt;code&gt;-W&lt;/code&gt; 、および &lt;code&gt;-X&lt;/code&gt; &lt;code&gt;-o&lt;/code&gt; 、 &lt;code&gt;-r&lt;/code&gt; 、 &lt;code&gt;-w&lt;/code&gt; 、および &lt;code&gt;-x&lt;/code&gt; と同等です。同様に、 &lt;code&gt;-A&lt;/code&gt; 、 &lt;code&gt;-g&lt;/code&gt; 、 &lt;code&gt;-k&lt;/code&gt; 、 &lt;code&gt;-l&lt;/code&gt; 、 &lt;code&gt;-p&lt;/code&gt; 、および &lt;code&gt;-u&lt;/code&gt; を含む他のいくつかのテストは、VMSでは特に意味がなく、これらのテストによって返される値は、CRTL &lt;code&gt;stat()&lt;/code&gt; ルーチンが行うことを反映しています。st_modeフィールドの同等のビットに。最後に、 &lt;code&gt;-d&lt;/code&gt; は、明示的なディレクトリなしでデバイス仕様（ &lt;code&gt;DUA1:&lt;/code&gt; ）が渡された場合、およびディレクトリが渡された場合にtrueを返します。</target>
        </trans-unit>
        <trans-unit id="cc12f2671ba906087d5eb6304768a3d9deaa9bcf" translate="yes" xml:space="preserve">
          <source>The tests are wholly and completely skipped. [10] This will work.</source>
          <target state="translated">テストは完全にサボっています。10]これでうまくいきます。</target>
        </trans-unit>
        <trans-unit id="d8be2ba8a0a786a9e0b622bcec19843e1f59daa7" translate="yes" xml:space="preserve">
          <source>The tests for this module directly access &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; hash keys. Most, if not all of these hash keys have public API methods that could be used instead to avoid the problem.</source>
          <target state="translated">このモジュールのテストは、&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt;ハッシュキーに直接アクセスします。これらのハッシュキーのすべてではないにしても、ほとんどの場合、問題を回避するために代わりに使用できるパブリックAPIメソッドがあります。</target>
        </trans-unit>
        <trans-unit id="4fe750878672d4fb196503a672d7f5b98d0e668b" translate="yes" xml:space="preserve">
          <source>The text &quot;Object Attributes&quot; comprises the heading there. The text in these heading commands can use formatting codes, as seen here:</source>
          <target state="translated">オブジェクトの属性」というテキストが見出しを構成しています。これらの見出しコマンドのテキストは、ここで見られるように、フォーマットコードを使用することができます。</target>
        </trans-unit>
        <trans-unit id="5d105df3ca2da40b603c19669d88379eb24889fa" translate="yes" xml:space="preserve">
          <source>The text content will have tabs already expanded.</source>
          <target state="translated">テキストコンテンツには既にタブが展開されています。</target>
        </trans-unit>
        <trans-unit id="6ca64065f1722f4560dea83450c678ea442c364d" translate="yes" xml:space="preserve">
          <source>The text in the above examples enclosed between the &lt;code&gt;&quot;/&quot;&lt;/code&gt; characters can be just about any regular expression. It is independent of the main pattern, so doesn't share any capturing groups,</source>
          <target state="translated">上記の例の &lt;code&gt;&quot;/&quot;&lt;/code&gt; 文字で囲まれたテキストは、ほぼすべての正規表現にすることができます。メインパターンから独立しているため、キャプチャグループを共有しません。</target>
        </trans-unit>
        <trans-unit id="5846d0e4adec8717ba9914b28f27a3deba7538bf" translate="yes" xml:space="preserve">
          <source>The text matched by the highest used capture group of the last successful search pattern. It is logically equivalent to the highest numbered capture variable (&lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, ...) which has a defined value.</source>
          <target state="translated">最後に成功した検索パターンの中で最も使用頻度の高いキャプチャグループと一致するテキスト。これは、定義された値を持つ最大番号のキャプチャ変数（ &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; 、...）と論理的に同等です。</target>
        </trans-unit>
        <trans-unit id="422420f7789cdb6ab09e238f60941fefea41ab12" translate="yes" xml:space="preserve">
          <source>The text matched by the last bracket of the last successful search pattern. This is useful if you don't know which one of a set of alternative patterns matched. For example:</source>
          <target state="translated">最後に成功した検索パターンの最後の括弧でマッチしたテキスト。これは、一連の代替パターンの中でどれがマッチしたかわからない場合に便利です。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="8d5e558c4e38b1badcb4cca2c007e3208f52adfb" translate="yes" xml:space="preserve">
          <source>The text matched by the used group most-recently closed (i.e. the group with the rightmost closing parenthesis) of the last successful search pattern.</source>
          <target state="translated">最後に成功した検索パターンの最も最近閉じられたグループ(つまり、右端の括弧が閉じられたグループ)が使用したグループでマッチしたテキスト。</target>
        </trans-unit>
        <trans-unit id="5e596703d1021b4590de3b141bfc6f8bfaf78ff0" translate="yes" xml:space="preserve">
          <source>The text matched by the used group most-recently closed (i.e. the group with the rightmost closing parenthesis) of the last successful search pattern. This is subtly different from &lt;code&gt;$+&lt;/code&gt;. For example in</source>
          <target state="translated">最後に成功した検索パターンの最後に閉じられた使用済みグループ（つまり、右端の閉じ括弧のあるグループ）と一致するテキスト。これは &lt;code&gt;$+&lt;/code&gt; とは微妙に異なります。たとえば</target>
        </trans-unit>
        <trans-unit id="c1c9727d8e424808f3451a4472d65a7ff102f563" translate="yes" xml:space="preserve">
          <source>The text of a message to print immediately prior to printing the program's usage message.</source>
          <target state="translated">プログラムの使用メッセージを印刷する直前に印刷するメッセージのテキスト。</target>
        </trans-unit>
        <trans-unit id="2808389282f74befb5070bb0b9545514e48a6905" translate="yes" xml:space="preserve">
          <source>The text of the Makefile is run through this method before writing to disk. It allows systems a chance to make portability fixes to the Makefile.</source>
          <target state="translated">Makefile のテキストは、ディスクに書き込む前にこの方法で実行されます。これにより、システムが Makefile に移植性のある修正を加えることができます。</target>
        </trans-unit>
        <trans-unit id="fe3785c2d13add392a07d1b360e255c73be9984b" translate="yes" xml:space="preserve">
          <source>The text of the message as a &lt;code&gt;SVpv&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SVpv&lt;/code&gt; としてのメッセージのテキスト。</target>
        </trans-unit>
        <trans-unit id="4abae05debe0661c57f27b361d90da4ccea7c4db" translate="yes" xml:space="preserve">
          <source>The text/binary issue is covered at length in the Cygwin documentation.</source>
          <target state="translated">テキスト/バイナリの問題は、Cygwinのドキュメントで詳しく説明されています。</target>
        </trans-unit>
        <trans-unit id="3155c02df4aea0a613a1c72b2a9ac5c7a7efff80" translate="yes" xml:space="preserve">
          <source>The thetas, phis, direction, and distance in the above are all in radians.</source>
          <target state="translated">上記のθ、Phis、方向、距離は全てラジアン単位である。</target>
        </trans-unit>
        <trans-unit id="b1d631fb3ea4c05afea84d61f3fa4b47ab2ddcf3" translate="yes" xml:space="preserve">
          <source>The thing you&amp;rsquo;re working on. Structures like &lt;code&gt;&lt;a href=&quot;functions/while&quot;&gt;while(&amp;lt;&amp;gt;)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;foreach&lt;/code&gt; , and &lt;code&gt;given&lt;/code&gt; set the topic for you by assigning to &lt;code&gt;$_&lt;/code&gt; , the default (</source>
          <target state="translated">あなたが取り組んでいること。 &lt;code&gt;&lt;a href=&quot;functions/while&quot;&gt;while(&amp;lt;&amp;gt;)&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;for&lt;/code&gt; 、 &lt;code&gt;foreach&lt;/code&gt; 、および &lt;code&gt;given&lt;/code&gt; set などの構造は、デフォルトの &lt;code&gt;$_&lt;/code&gt; に割り当てることでトピックを設定します（</target>
        </trans-unit>
        <trans-unit id="d349e0f7ce22448af1f85ae29fc321760bdcefb3" translate="yes" xml:space="preserve">
          <source>The thing you&amp;rsquo;re working on. Structures like &lt;code&gt;while(&amp;lt;&amp;gt;)&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;foreach&lt;/code&gt;, and &lt;code&gt;given&lt;/code&gt; set the topic for you by assigning to &lt;code&gt;$_&lt;/code&gt;, the default (</source>
          <target state="translated">あなたが取り組んでいること。 &lt;code&gt;while(&amp;lt;&amp;gt;)&lt;/code&gt; 、 &lt;code&gt;for&lt;/code&gt; 、 &lt;code&gt;foreach&lt;/code&gt; 、 &lt;code&gt;given&lt;/code&gt; などの構造体は、デフォルトの &lt;code&gt;$_&lt;/code&gt; に割り当てることで、トピックを設定します（</target>
        </trans-unit>
        <trans-unit id="9b3293c9c16b6eb4008c2299c5283501a14ee373" translate="yes" xml:space="preserve">
          <source>The third argument ($binmode) will select binary mode if passed as a TRUE value. In binary mode &quot;\n&quot; will be encoded in the same way as any other non-printable character. This ensures that a decoder will end up with exactly the same string whatever line ending sequence it uses. In general it is preferable to use the base64 encoding for binary data; see &lt;a href=&quot;MIME::Base64&quot;&gt;MIME::Base64&lt;/a&gt;.</source>
          <target state="translated">3番目の引数（$ binmode）は、TRUE値として渡された場合、バイナリモードを選択します。バイナリモードでは、「\ n」は他の印刷不可能な文字と同じ方法でエンコードされます。これにより、デコーダーは、使用する行末シーケンスに関係なく、まったく同じ文字列で終わることが保証されます。一般に、バイナリデータにはbase64エンコーディングを使用することをお勧めします。&lt;a href=&quot;MIME::Base64&quot;&gt;MIME :: Base64を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d7aa255f6bad43d19c5308997ee1af4d4b4ab78c" translate="yes" xml:space="preserve">
          <source>The third argument ($binmode) will select binary mode if passed as a TRUE value. In binary mode &quot;\n&quot; will be encoded in the same way as any other non-printable character. This ensures that a decoder will end up with exactly the same string whatever line ending sequence it uses. In general it is preferable to use the base64 encoding for binary data; see &lt;a href=&quot;base64&quot;&gt;MIME::Base64&lt;/a&gt;.</source>
          <target state="translated">3番目の引数（$ binmode）は、TRUE値として渡された場合にバイナリモードを選択します。バイナリモードでは、「\ n」は他の印刷できない文字と同じ方法でエンコードされます。これにより、デコーダーが使用する行末シーケンスに関係なく、まったく同じ文字列で終了することが保証されます。一般に、バイナリデータにはbase64エンコーディングを使用することをお勧めします。&lt;a href=&quot;base64&quot;&gt;MIME :: Base64を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="cf989e588a5ff932bae69e35a56b32b82b9fac73" translate="yes" xml:space="preserve">
          <source>The third argument &lt;code&gt;\@on_fail&lt;/code&gt;) is an optional set of diagnostics to be sent in the event of a test failure. Unlike with &lt;code&gt;fail()&lt;/code&gt; these diagnostics must be plain strings, data structures are not supported.</source>
          <target state="translated">3番目の引数 &lt;code&gt;\@on_fail&lt;/code&gt; ）は、テストが失敗した場合に送信される診断のオプションのセットです。 &lt;code&gt;fail()&lt;/code&gt; とは異なり、これらの診断はプレーンな文字列である必要があり、データ構造はサポートされていません。</target>
        </trans-unit>
        <trans-unit id="402137bf9c592f0ce8adeea3685dbc19201507dd" translate="yes" xml:space="preserve">
          <source>The third argument can be a hash reference with options. Note that all options are case-sensitive.</source>
          <target state="translated">3 番目の引数には、オプションを含むハッシュ参照を指定することができます。すべてのオプションは大文字と小文字を区別することに注意してください。</target>
        </trans-unit>
        <trans-unit id="d09df4868eb6859f97bcec11bc2fb80a75d17197" translate="yes" xml:space="preserve">
          <source>The third argument is an optional prefix. All files will be tucked away in the directory you specify as prefix. So if you have files 'a' and 'b' in your archive, and you specify 'foo' as prefix, they will be written to the archive as 'foo/a' and 'foo/b'.</source>
          <target state="translated">3番目の引数はオプションのprefixです。すべてのファイルは、プレフィックスとして指定したディレクトリに格納されます。つまり、アーカイブの中に 'a' と 'b' というファイルがあって、プレフィックスに 'foo' を指定した場合は、アーカイブには 'foo/a' と 'foo/b' という名前で書き込まれます。</target>
        </trans-unit>
        <trans-unit id="f4fe54f58bf6b8a68158e2a28b4c6c3ebee0bf58" translate="yes" xml:space="preserve">
          <source>The third argument is set to TRUE if (and only if) the two operands have been swapped. Perl may do this to ensure that the first argument (&lt;code&gt;$self&lt;/code&gt; ) is an object implementing the overloaded operation, in line with general object calling conventions. For example, if &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are &lt;code&gt;Number&lt;/code&gt; s:</source>
          <target state="translated">3番目の引数は、2つのオペランドが入れ替えられた場合（かつその場合のみ）にTRUEに設定されます。 Perlはこれを行って、最初の引数（ &lt;code&gt;$self&lt;/code&gt; ）が、一般的なオブジェクト呼び出し規約に従って、オーバーロードされた操作を実装するオブジェクトであることを確認します。たとえば、 &lt;code&gt;$x&lt;/code&gt; と &lt;code&gt;$y&lt;/code&gt; が &lt;code&gt;Number&lt;/code&gt; の場合：</target>
        </trans-unit>
        <trans-unit id="e0c4e0c0cbbd72e926793186b0870f3e51aaf16b" translate="yes" xml:space="preserve">
          <source>The third argument is set to TRUE if (and only if) the two operands have been swapped. Perl may do this to ensure that the first argument (&lt;code&gt;$self&lt;/code&gt;) is an object implementing the overloaded operation, in line with general object calling conventions. For example, if &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; are &lt;code&gt;Number&lt;/code&gt;s:</source>
          <target state="translated">3番目の引数は、2つのオペランドが交換された場合にのみ、TRUEに設定されます。 Perlは、一般的なオブジェクト呼び出し規約に従って、最初の引数（ &lt;code&gt;$self&lt;/code&gt; ）がオーバーロードされた操作を実装するオブジェクトであることを確認するためにこれを行う場合があります。たとえば、 &lt;code&gt;$x&lt;/code&gt; と &lt;code&gt;$y&lt;/code&gt; が &lt;code&gt;Number&lt;/code&gt; の場合：</target>
        </trans-unit>
        <trans-unit id="b6927ece55a1584561056753f900c2e3751385e3" translate="yes" xml:space="preserve">
          <source>The third form of character class you can use in Perl regular expressions is the bracketed character class. In its simplest form, it lists the characters that may be matched, surrounded by square brackets, like this: &lt;code&gt;[aeiou]&lt;/code&gt; . This matches one of &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;e&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;o&lt;/code&gt; or &lt;code&gt;u&lt;/code&gt; . Like the other character classes, exactly one character is matched.* To match a longer string consisting of characters mentioned in the character class, follow the character class with a &lt;a href=&quot;perlre#Quantifiers&quot;&gt;quantifier&lt;/a&gt;. For instance, &lt;code&gt;[aeiou]+&lt;/code&gt; matches one or more lowercase English vowels.</source>
          <target state="translated">Perl正規表現で使用できる文字クラスの3番目の形式は、括弧で囲まれた文字クラスです。最も単純な形式では、 &lt;code&gt;[aeiou]&lt;/code&gt; のように、角括弧で囲まれた、一致する可能性のある文字がリストされます。これは &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;e&lt;/code&gt; 、 &lt;code&gt;i&lt;/code&gt; 、 &lt;code&gt;o&lt;/code&gt; 、 &lt;code&gt;u&lt;/code&gt; のいずれかに一致します。他の文字クラスと同様に、正確に1文字が一致します。*文字クラスで言及されている文字で構成されるより長い文字列を一致させるには、文字クラスの後に&lt;a href=&quot;perlre#Quantifiers&quot;&gt;数量詞を&lt;/a&gt;続けます。たとえば、 &lt;code&gt;[aeiou]+&lt;/code&gt; は、 1つ以上の小文字の英語の母音に一致します。</target>
        </trans-unit>
        <trans-unit id="da916e8511a4663908a2df2d14a8fc11695fa70c" translate="yes" xml:space="preserve">
          <source>The third form of character class you can use in Perl regular expressions is the bracketed character class. In its simplest form, it lists the characters that may be matched, surrounded by square brackets, like this: &lt;code&gt;[aeiou]&lt;/code&gt;. This matches one of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;o&lt;/code&gt; or &lt;code&gt;u&lt;/code&gt;. Like the other character classes, exactly one character is matched.* To match a longer string consisting of characters mentioned in the character class, follow the character class with a &lt;a href=&quot;perlre#Quantifiers&quot;&gt;quantifier&lt;/a&gt;. For instance, &lt;code&gt;[aeiou]+&lt;/code&gt; matches one or more lowercase English vowels.</source>
          <target state="translated">Perl正規表現で使用できる文字クラスの3番目の形式は、括弧で囲まれた文字クラスです。最も単純な形式では、 &lt;code&gt;[aeiou]&lt;/code&gt; のように、一致する可能性のある文字が角かっこで囲まれて一覧表示されます。これは &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;e&lt;/code&gt; 、 &lt;code&gt;i&lt;/code&gt; 、 &lt;code&gt;o&lt;/code&gt; 、または &lt;code&gt;u&lt;/code&gt; のいずれかに一致します。他の文字クラスと同様に、正確に1つの文字が一致します。*文字クラスで言及されている文字で構成される長い文字列を一致させるには、文字クラスの後に&lt;a href=&quot;perlre#Quantifiers&quot;&gt;数量詞を付け&lt;/a&gt;ます。たとえば、 &lt;code&gt;[aeiou]+&lt;/code&gt; は1つ以上の小文字の英語の母音に一致します。</target>
        </trans-unit>
        <trans-unit id="98c965cda02550e370a5b37b87d94e4f8f16189d" translate="yes" xml:space="preserve">
          <source>The third option is to work around the problem by disabling the DB_File completely when build Perl by specifying -Ui_db to Configure, and then using the BerkeleyDB module from CPAN instead of DB_File. The BerkeleyDB works with Berkeley DB versions 2.* or greater.</source>
          <target state="translated">3つ目のオプションは、Perlのビルド時に-Ui_dbをConfigureに指定してDB_Fileを完全に無効にし、DB_Fileの代わりにCPANのBerkeleyDBモジュールを使用することで問題を回避する方法です。BerkeleyDBはBerkeley DBのバージョン2.*以上で動作します。</target>
        </trans-unit>
        <trans-unit id="06ac2659f5a86781c045ab0079857269ceabc456" translate="yes" xml:space="preserve">
          <source>The third parameter is an integer flag, which tells &lt;code&gt;rmscopy&lt;/code&gt; how to handle timestamps. If it is &amp;lt; 0, none of the input file's timestamps are propagated to the output file. If it is &amp;gt; 0, then it is interpreted as a bitmask: if bit 0 (the LSB) is set, then timestamps other than the revision date are propagated; if bit 1 is set, the revision date is propagated. If the third parameter to &lt;code&gt;rmscopy&lt;/code&gt; is 0, then it behaves much like the DCL COPY command: if the name or type of the output file was explicitly specified, then no timestamps are propagated, but if they were taken implicitly from the input filespec, then all timestamps other than the revision date are propagated. If this parameter is not supplied, it defaults to 0.</source>
          <target state="translated">3番目のパラメーターは整数フラグで、 &lt;code&gt;rmscopy&lt;/code&gt; にタイムスタンプの処理方法を指示します。 0未満の場合、入力ファイルのタイムスタンプは出力ファイルに伝播されません。 0より大きい場合、ビットマスクとして解釈されます。ビット0（LSB）が設定されている場合、改訂日以外のタイムスタンプが伝達されます。ビット1が設定されている場合、改訂日が伝搬されます。 &lt;code&gt;rmscopy&lt;/code&gt; の3番目のパラメーターが0の場合、DCL COPYコマンドのように動作します。出力ファイルの名前またはタイプが明示的に指定されている場合、タイムスタンプは伝達されませんが、入力ファイル仕様から暗黙的に取得された場合、改訂日以外のすべてのタイムスタンプが伝達されます。このパラメーターを指定しない場合、デフォルトで0になります。</target>
        </trans-unit>
        <trans-unit id="65eff2bc7c7605d4f858e4809838a551a55b2c9c" translate="yes" xml:space="preserve">
          <source>The third parameter of &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; determines whether AUTOLOAD lookup is performed if the given method is not present: non-zero means yes, look for AUTOLOAD; zero means no, don't look for AUTOLOAD. Calling &lt;code&gt;gv_fetchmethod&lt;/code&gt; is equivalent to calling &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; with a non-zero &lt;code&gt;autoload&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; の3番目のパラメーターは、指定されたメソッドが存在しない場合にAUTOLOADルックアップを実行するかどうかを決定します。ゼロ以外は、はい、AUTOLOADを探すことを意味します。ゼロは、いいえ、AUTOLOADを検索しないことを意味します。呼び出し &lt;code&gt;gv_fetchmethod&lt;/code&gt; は呼び出すことと同じです &lt;code&gt;gv_fetchmethod_autoload&lt;/code&gt; をゼロ以外で &lt;code&gt;autoload&lt;/code&gt; パラメータ。</target>
        </trans-unit>
        <trans-unit id="04bad251a051beab258a1b64e282a2e8539b9769" translate="yes" xml:space="preserve">
          <source>The third, even more efficient way is to ape how it is done within the Perl guts:</source>
          <target state="translated">3つ目の、さらに効率的な方法は、Perlのガッツの中でどのように行われているかを真似ることです。</target>
        </trans-unit>
        <trans-unit id="4baba8cca2cc8406f593d4d91d751f6705e4259a" translate="yes" xml:space="preserve">
          <source>The thread ID in which the event was generated.</source>
          <target state="translated">イベントが生成されたスレッドID。</target>
        </trans-unit>
        <trans-unit id="35817a67488b477301f26017a906bceb6698d6d8" translate="yes" xml:space="preserve">
          <source>The thread ID of the hub the event was sent to.</source>
          <target state="translated">イベントが送信されたハブのスレッドID。</target>
        </trans-unit>
        <trans-unit id="79c45ac3b3a9de2cee8656fb9dfb3aeb3d0a968d" translate="yes" xml:space="preserve">
          <source>The threaded Perl build works also on AIX 5.1 but the IBM Perl build (Perl v5.6.0) is not threaded on AIX 5.1.</source>
          <target state="translated">スレッドされたPerlビルドはAIX 5.1でも動作しますが、IBMのPerlビルド(Perl v5.6.0)はAIX 5.1ではスレッド化されていません。</target>
        </trans-unit>
        <trans-unit id="7cda8f2369f06b63a0604a363c17ca6dadb5ab34" translate="yes" xml:space="preserve">
          <source>The three alternative macros are for the most commonly needed validations; they are likely to run somewhat faster than this more general one, as they can be inlined into your code.</source>
          <target state="translated">3つの代替マクロは、最も一般的に必要とされるバリデーションのためのものです。</target>
        </trans-unit>
        <trans-unit id="5c1bbb696ed6ae965a0f7d9f707a450102369948" translate="yes" xml:space="preserve">
          <source>The three dotted bitwise assignment operators (&lt;code&gt;&amp;amp;.=&lt;/code&gt;&lt;code&gt;|.=&lt;/code&gt;&lt;code&gt;^.=&lt;/code&gt; ) are new in Perl 5.22 and experimental. See &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;.</source>
          <target state="translated">3つのドット付きビット単位の代入演算子（ &lt;code&gt;&amp;amp;.=&lt;/code&gt; &lt;code&gt;|.=&lt;/code&gt; &lt;code&gt;^.=&lt;/code&gt; ）は、Perl 5.22で新しく、実験的です。&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operatorsを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c23c9e704aad4fb3e2b155575140f095b0d8c904" translate="yes" xml:space="preserve">
          <source>The three dotted bitwise assignment operators (&lt;code&gt;&amp;amp;.=&lt;/code&gt;&lt;code&gt;|.=&lt;/code&gt;&lt;code&gt;^.=&lt;/code&gt;) are new in Perl 5.22. See &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot;&lt;/a&gt;.</source>
          <target state="translated">3つの点線のビット単位代入演算子（ &lt;code&gt;&amp;amp;.=&lt;/code&gt; &lt;code&gt;|.=&lt;/code&gt; &lt;code&gt;^.=&lt;/code&gt; ）は、Perl5.22の新機能です。&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;「ビット単位の文字列演算子」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="608f375aebf252abe9239c4f7b8a529aa2fe8363" translate="yes" xml:space="preserve">
          <source>The three features of key hashes,</source>
          <target state="translated">キーハッシュの3つの特徴</target>
        </trans-unit>
        <trans-unit id="062af9abb2e5d348e479446852d7c0c45c4b3f85" translate="yes" xml:space="preserve">
          <source>The three invocations of the subroutine all operate in sync. The semaphore, though, makes sure that only one thread is accessing the global variable at once.</source>
          <target state="translated">サブルーチンの3つの呼び出しはすべて同期して動作します。しかし、セマフォは1つのスレッドだけが一度にグローバル変数にアクセスするようにしています。</target>
        </trans-unit>
        <trans-unit id="c211076f27a370be0b7366cd2b652219b05d68b1" translate="yes" xml:space="preserve">
          <source>The three predefined variables $DB_HASH, $DB_BTREE and $DB_RECNO are usually adequate for most applications. If you do need to create extra instances of these objects, constructors are available for each file type.</source>
          <target state="translated">3 つの定義済み変数 $DB_HASH、$DB_BTREE および $DB_RECNO は、通常、ほとんどのアプリケーションでは十分です。これらのオブジェクトのインスタンスを追加で作成する必要がある場合は、ファイルタイプごとにコンストラクタが用意されています。</target>
        </trans-unit>
        <trans-unit id="e9c27515a2acd2e5fb4a7aba2f69ec1143808efd" translate="yes" xml:space="preserve">
          <source>The three principal virtues of a programmer are Laziness, Impatience, and Hubris. See the Camel Book for why.</source>
          <target state="translated">プログラマーの三大美徳は「怠惰」「焦り」「傲慢」です。その理由については、キャメルブックを参照してください。</target>
        </trans-unit>
        <trans-unit id="8d0972bf14f371a7ca1ef1bcaa261257cc368602" translate="yes" xml:space="preserve">
          <source>The three variables, api_revision, api_version, and api_subversion, specify the version of the oldest perl binary compatible with the present perl. In a full version string such as</source>
          <target state="translated">api_revision、api_version、api_subversionの3つの変数で、現在のperlと互換性のある最も古いperlバイナリのバージョンを指定します。のようなフルバージョン文字列では</target>
        </trans-unit>
        <trans-unit id="5f7adaa1232b94661eb586ac3b6e3dfed3cf89b3" translate="yes" xml:space="preserve">
          <source>The three warnings functions, &lt;code&gt;warnings::warn&lt;/code&gt; , &lt;code&gt;warnings::warnif&lt;/code&gt; and &lt;code&gt;warnings::enabled&lt;/code&gt; can optionally take an object reference in place of a category name. In this case the functions will use the class name of the object as the warnings category.</source>
          <target state="translated">3つの警告関数、 &lt;code&gt;warnings::warn&lt;/code&gt; 、 &lt;code&gt;warnings::warnif&lt;/code&gt; 、および &lt;code&gt;warnings::enabled&lt;/code&gt; では、オプションで、カテゴリ名の代わりにオブジェクト参照を使用できます。この場合、関数はオブジェクトのクラス名を警告カテゴリとして使用します。</target>
        </trans-unit>
        <trans-unit id="7318f95ef0833e84e87f8f8ccae92d5cf168ab78" translate="yes" xml:space="preserve">
          <source>The three warnings functions, &lt;code&gt;warnings::warn&lt;/code&gt;, &lt;code&gt;warnings::warnif&lt;/code&gt; and &lt;code&gt;warnings::enabled&lt;/code&gt; can optionally take an object reference in place of a category name. In this case the functions will use the class name of the object as the warnings category.</source>
          <target state="translated">3つの警告関数、 &lt;code&gt;warnings::warn&lt;/code&gt; 、 &lt;code&gt;warnings::warnif&lt;/code&gt; 、 &lt;code&gt;warnings::enabled&lt;/code&gt; は、オプションでカテゴリ名の代わりにオブジェクト参照を取得できます。この場合、関数はオブジェクトのクラス名を警告カテゴリとして使用します。</target>
        </trans-unit>
        <trans-unit id="330a38aeb545f580c0244d785039ed36ba36d545" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2fTicket%2fDisplay.html%3fid%3d121481&quot;&gt;[perl #121481]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2fTicket%2fDisplay.html%3fid%3d121481&quot;&gt;[perl＃121481]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="b68d73ad1b59ae384323f9df247206460ebd3566" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d116487&quot;&gt;[perl #116487]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d116487&quot;&gt;[perl＃116487]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="b8045076fdd60e6523f73b7c70511783c44a65e4" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119313&quot;&gt;[perl #119313]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119313&quot;&gt;[perl＃119313]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="1a16744b674df3a293c07c2c144ffeafe30d93a5" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119315&quot;&gt;[perl #119315]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119315&quot;&gt;[perl＃119315]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="ed1860908f3e196b681653f0d3c4015121aac114" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119317&quot;&gt;[perl #119317]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119317&quot;&gt;[perl＃119317]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="c89e9b1dbbb9968b38d0d3719212d5f4f930d48c" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119437&quot;&gt;[perl #119437]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119437&quot;&gt;[perl＃119437]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="4a1e967726ae4e6415ad56477887e8f2fd56977f" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119451&quot;&gt;[perl #119451]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119451&quot;&gt;[perl＃119451]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f14154eef095f6d5ad9ed12b7ee560090c8240df" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119453&quot;&gt;[perl #119453]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119453&quot;&gt;[perl＃119453]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="1140c9b87fc789061a9c67b7de5921f54ea0a0a7" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119455&quot;&gt;[perl #119455]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d119455&quot;&gt;[perl＃119455]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="f6f307da7b6aa442d7423ca357f21550160d4bb6" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d120085&quot;&gt;[perl #120085]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d120085&quot;&gt;[perl＃120085]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="2b73333a2d87bb4bdcdf8360f5d380f719aac7b6" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d122947&quot;&gt;[perl #122947]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d122947&quot;&gt;[perl＃122947]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="25b9d0a99bd226d2ae0ff1a2acdc8ae410a969ec" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123630&quot;&gt;[perl #123630]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123630&quot;&gt;[perl＃123630]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="0769a8451d93e389be7960f58724061e03726c33" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123707&quot;&gt;[perl #123707]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%2frt3%2fTicket%2fDisplay.html%3fid%3d123707&quot;&gt;[perl＃123707]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="4152408e418529cff3fa9a89a90fa02a4c71e407" translate="yes" xml:space="preserve">
          <source>The ticket for this feature is &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%3a443%2frt3%2fTicket%2fDisplay.html%3fid%3d120162&quot;&gt;[perl #120162]&lt;/a&gt;.</source>
          <target state="translated">この機能のチケットは&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2frt.perl.org%3a443%2frt3%2fTicket%2fDisplay.html%3fid%3d120162&quot;&gt;[perl＃120162]&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="896c7c2fe4064687353e3dfbb412d579a6d56aea" translate="yes" xml:space="preserve">
          <source>The tie() function binds a variable to a class (package) that will provide the implementation for access methods for that variable. Once this magic has been performed, accessing a tied variable automatically triggers method calls in the proper class. The complexity of the class is hidden behind magic methods calls. The method names are in ALL CAPS, which is a convention that Perl uses to indicate that they're called implicitly rather than explicitly--just like the BEGIN() and END() functions.</source>
          <target state="translated">tie()関数は、変数をクラス (パッケージ)にバインドし、その変数のアクセスメソッドの実装を提供します。このマジックが実行されると、結び付けられた変数にアクセスすると、自動的に適切なクラスのメソッド呼び出しがトリガーされます。クラスの複雑さは、魔法のメソッド呼び出しの背後に隠されています。これは Perl が明示的にではなく暗黙的に呼び出されることを示すために使用する慣習です。</target>
        </trans-unit>
        <trans-unit id="0cc71f8e2650c3f7dc36c81297b9a74bd871dbac" translate="yes" xml:space="preserve">
          <source>The tighter rules given above for the single form apply to everything to the right of the colon or equals; the looser rules still apply to everything to the left.</source>
          <target state="translated">上記の単数形の規則は、コロンやイコールの右にあるものはすべて適用されますが、左にあるものはすべて適用されます。</target>
        </trans-unit>
        <trans-unit id="2ae79bd4ddb1c94445f10f56348d3008d5501006" translate="yes" xml:space="preserve">
          <source>The time at which the program began running, in seconds since the epoch (beginning of 1970). The values returned by the &lt;b&gt;-M&lt;/b&gt;, &lt;b&gt;-A&lt;/b&gt;, and &lt;b&gt;-C&lt;/b&gt; filetests are based on this value.</source>
          <target state="translated">エポック（1970年の初め）からの秒単位でのプログラムの実行開始時刻。&lt;b&gt;-M&lt;/b&gt;、&lt;b&gt;-A&lt;/b&gt;、および&lt;b&gt;-C&lt;/b&gt;ファイルテストによって返される値は、この値に基づいています。</target>
        </trans-unit>
        <trans-unit id="850e579e5bd369cd341c43e0bd12ab77ec41d87f" translate="yes" xml:space="preserve">
          <source>The time has been cut in half, which is a respectable speed improvement by any standard. Naturally, it is important to check the output is consistent with the first program run, this is where the Unix system &lt;code&gt;cksum&lt;/code&gt; utility comes in.</source>
          <target state="translated">時間は半分に短縮されました。これは、どの基準でもかなりの速度向上です。当然、出力が最初のプログラム実行と一致していることを確認することが重要です。ここで、Unixシステムの &lt;code&gt;cksum&lt;/code&gt; ユーティリティが使用されます。</target>
        </trans-unit>
        <trans-unit id="b516aafa3dbd5e537bbd8654d3807aa023edea27" translate="yes" xml:space="preserve">
          <source>The time it takes varies depending on how fast your machine is and how large your encoding is. Unless you are working on something big like euc-tw, it won't take too long.</source>
          <target state="translated">それがかかる時間は、あなたのマシンの速度やエンコーディングの大きさによって異なります。euc-tw のような大きなものでない限り、それほど時間はかかりません。</target>
        </trans-unit>
        <trans-unit id="e4a773ca459be08fb127884cfab114e154432eff" translate="yes" xml:space="preserve">
          <source>The time of the null loop (a loop with the same number of rounds but empty loop body) is subtracted from the time of the real loop.</source>
          <target state="translated">ヌルループ(ラウンド数は同じだがループ本体が空のループ)の時間は、実際のループの時間から減算されます。</target>
        </trans-unit>
        <trans-unit id="b6a2ce725119cbf8ac82ed9014cf15ca7bd90e68" translate="yes" xml:space="preserve">
          <source>The time returned also includes the process times of the terminated child processes for which wait() has been executed. This value is somewhat like the second value returned by the times() of core Perl, but not necessarily identical. Note that due to backward compatibility limitations the returned value may wrap around at about 2147 seconds or at about 36 minutes.</source>
          <target state="translated">返される時間には、 wait()が実行された終了した子プロセスのプロセス時間も含まれます。この値は、コアPerlのtimes()によって返される2番目の値に多少似ていますが、必ずしも同じではありません。下位互換性の制限により、返される値は約2147秒または約36分で折り返される可能性があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0d1626bdb98ca3cc408f22b06c2161e7fe233ac0" translate="yes" xml:space="preserve">
          <source>The time when Perl is actually doing what your code says to do, as opposed to the earlier period of time when it was trying to figure out whether what you said made any sense whatsoever, which is &lt;b&gt;compile time&lt;/b&gt;.</source>
          <target state="translated">Perlが実際にコードが言うことを実行している&lt;b&gt;時間&lt;/b&gt;。これは、あなたが言ったことに意味があるかどうかを判断しようとした以前の期間、つまり&lt;b&gt;コンパイル時間&lt;/b&gt;とは対照的です。</target>
        </trans-unit>
        <trans-unit id="84f0e5475a9de884cf21f0b5087fb4edeef00da2" translate="yes" xml:space="preserve">
          <source>The time when Perl is trying to make sense of your code, as opposed to when it thinks it knows what your code means and is merely trying to do what it thinks your code says to do, which is &lt;b&gt;runtime&lt;/b&gt;.</source>
          <target state="translated">Perlがコードを理解しようとするとき。コードが何を意味するのかを理解していて、コードが言うことを実行しようとしているだけでなく、&lt;b&gt;実行時&lt;/b&gt;です。</target>
        </trans-unit>
        <trans-unit id="2e4f067abc3cb37a82d1ce3a350c4ed5ac55d47a" translate="yes" xml:space="preserve">
          <source>The timeout in the [PKG] can be specified as zero to effect a &quot;poll&quot;, but you shouldn't do that because a new IO::Select object will be created behind the scenes just to do the single poll. This is horrendously inefficient. Use rather true select() with a zero timeout on the handle, or non-blocking IO.</source>
          <target state="translated">PKG]のタイムアウトをゼロに指定すると「ポーリング」を効果的に行うことができますが、シングルポーリングを行うためだけに新しいIO::Selectオブジェクトが裏で作成されてしまうのでやめた方が良いでしょう。これは恐ろしく非効率的です。ハンドルのタイムアウトがゼロの真の select()を使うか、ノンブロッキング IO を使ってください。</target>
        </trans-unit>
        <trans-unit id="538790731acb7259f937f6ff4a2bbf78b24054c5" translate="yes" xml:space="preserve">
          <source>The timeout may be a number of seconds relative to the current time (e.g., 5 seconds from when the call is made), or may be an absolute timeout in</source>
          <target state="translated">タイムアウトは、現在の時刻からの相対的な秒数(例えば、通話が行われたときから5秒)であってもよいし、絶対的なタイムアウトであってもよい。</target>
        </trans-unit>
        <trans-unit id="ff980bdd72965b0a57183b47bf6c39d63a6adebb" translate="yes" xml:space="preserve">
          <source>The timeout value, in seconds, for this socket connection. How exactly this value is utilized is defined in the socket domain subclasses that make use of the value.</source>
          <target state="translated">このソケット接続のタイムアウト値を秒単位で指定します。この値を利用するソケットドメインのサブクラスでは、この値をどのように利用するかが定義されています。</target>
        </trans-unit>
        <trans-unit id="fd8fbd616a78a90070ef718270fee035f94b0bad" translate="yes" xml:space="preserve">
          <source>The timing is done using time(3) and times(3).</source>
          <target state="translated">時間(3)と時間(3)を使ってタイミングを取ります。</target>
        </trans-unit>
        <trans-unit id="bfc27e045cf8c436a59465851692c98d92afa4eb" translate="yes" xml:space="preserve">
          <source>The title of this section indicates the second problem you may run into sooner or later when you pack C structures. If the function you intend to call expects a, say, &lt;code&gt;void *&lt;/code&gt; value, you</source>
          <target state="translated">このセクションのタイトルは、C構造体をパックするときに遅かれ早かれ発生する可能性がある2番目の問題を示しています。呼び出す関数が、たとえば &lt;code&gt;void *&lt;/code&gt; 値を期待している場合、</target>
        </trans-unit>
        <trans-unit id="3aeea9af350571abf85e25c4751ee40203e9d46b" translate="yes" xml:space="preserve">
          <source>The top level documentation about Perl regular expressions is found in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;.</source>
          <target state="translated">Perl正規表現に関する最上位のドキュメントは&lt;a href=&quot;perlre&quot;&gt;perlreにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="3205e679e2f0bb1ae1342389bae87dd20bedcfd5" translate="yes" xml:space="preserve">
          <source>The top node in the tree is &lt;code&gt;[ 'Document', \%attributes,
&lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;</source>
          <target state="translated">ツリーの最上位ノードは &lt;code&gt;[ 'Document', \%attributes, &lt;i&gt;...subnodes...&lt;/i&gt; ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37995bec6dd9b8643c48818f0b81e11787b543cc" translate="yes" xml:space="preserve">
          <source>The total elapsed times the test took to run, in seconds from the epoch..</source>
          <target state="translated">テストが実行されるまでにかかった総経過時間を、エポックから秒単位で表示しています。</target>
        </trans-unit>
        <trans-unit id="1c62e4162c4c89e197d0fdd84f0911b0a91d8950" translate="yes" xml:space="preserve">
          <source>The total number of comparisons is equal to the sum of the squares of the number of entries in each bucket. For a random hash of &lt;code&gt;&amp;lt;n&lt;/code&gt; &amp;gt; keys into &lt;code&gt;&amp;lt;k&lt;/code&gt; &amp;gt; buckets, the expected value is:</source>
          <target state="translated">比較の総数は、各バケットのエントリ数の二乗の合計に等しくなります。 &lt;code&gt;&amp;lt;n&lt;/code&gt; &amp;gt;キーを &lt;code&gt;&amp;lt;k&lt;/code&gt; &amp;gt;バケットにランダムにハッシュする場合、期待される値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="dd7a1cc091879ad89ef24fb0639fcf0e894d70ac" translate="yes" xml:space="preserve">
          <source>The total number of comparisons is equal to the sum of the squares of the number of entries in each bucket. For a random hash of &lt;code&gt;&amp;lt;n&lt;/code&gt;&amp;gt; keys into &lt;code&gt;&amp;lt;k&lt;/code&gt;&amp;gt; buckets, the expected value is:</source>
          <target state="translated">比較の総数は、各バケットのエントリ数の2乗の合計に等しくなります。 &lt;code&gt;&amp;lt;n&lt;/code&gt; &amp;gt;キーを &lt;code&gt;&amp;lt;k&lt;/code&gt; &amp;gt;バケットにランダムにハッシュする場合、期待値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d4c2502de58f3e2d86d4adebf37cdce84d5b9f9b" translate="yes" xml:space="preserve">
          <source>The total time it took for the test to run, in seconds. If &lt;code&gt;Time::HiRes&lt;/code&gt; is available, it will have finer granularity.</source>
          <target state="translated">テストの実行にかかった合計時間（秒単位）。場合 &lt;code&gt;Time::HiRes&lt;/code&gt; 利用可能である、それはより細かい粒度を持つことになります。</target>
        </trans-unit>
        <trans-unit id="1b3a565887dd69be936761de4d497f57b4dfa910" translate="yes" xml:space="preserve">
          <source>The tradeoff is that one needs to calculate the number of return values in advance (though overextending the stack will not typically hurt anything but memory consumption).</source>
          <target state="translated">そのトレードオフは、あらかじめ戻り値の数を計算しておく必要があるということです(ただし、スタックを拡張しすぎても、通常はメモリ消費以外には何の問題もありません)。</target>
        </trans-unit>
        <trans-unit id="02dc2cb0935e5c48d56deb5ed1a283c1991198d6" translate="yes" xml:space="preserve">
          <source>The traditional &quot;0&quot;, &quot;1&quot;, and &quot;2&quot; MODEs are implemented with different numeric values on some systems. The flags exported by &lt;code&gt;Fcntl&lt;/code&gt; (O_RDONLY, O_WRONLY, O_RDWR) should work everywhere though. (Mac OS, OS/390)</source>
          <target state="translated">従来の「0」、「1」、および「2」モードは、一部のシステムでは異なる数値で実装されています。 &lt;code&gt;Fcntl&lt;/code&gt; によってエクスポートされたフラグ（O_RDONLY、O_WRONLY、O_RDWR）は、どこでも機能するはずです。（Mac OS、OS / 390）</target>
        </trans-unit>
        <trans-unit id="edec44b15608ad1c090140c537934ec3a77ab750" translate="yes" xml:space="preserve">
          <source>The traditional one has it followed by a name enclosed in braces, meaning the character (or sequence of characters) given by that name. Thus &lt;code&gt;\N{ASTERISK}&lt;/code&gt; is another way of writing &lt;code&gt;*&lt;/code&gt; , valid in both double-quoted strings and regular expression patterns. In patterns, it doesn't have the meaning an unescaped &lt;code&gt;*&lt;/code&gt; does.</source>
          <target state="translated">従来のものは、中括弧で囲まれた名前が続き、その名前で与えられた文字（または文字のシーケンス）を意味します。したがって、 &lt;code&gt;\N{ASTERISK}&lt;/code&gt; は &lt;code&gt;*&lt;/code&gt; を記述する別の方法であり、二重引用符で囲まれた文字列と正規表現パターンの両方で有効です。パターンでは、エスケープされていない &lt;code&gt;*&lt;/code&gt; のような意味はありません。</target>
        </trans-unit>
        <trans-unit id="aa46fd7f5efd6b7870b67ed7954394e54344b140" translate="yes" xml:space="preserve">
          <source>The traditional one has it followed by a name enclosed in braces, meaning the character (or sequence of characters) given by that name. Thus &lt;code&gt;\N{ASTERISK}&lt;/code&gt; is another way of writing &lt;code&gt;*&lt;/code&gt;, valid in both double-quoted strings and regular expression patterns. In patterns, it doesn't have the meaning an unescaped &lt;code&gt;*&lt;/code&gt; does.</source>
          <target state="translated">従来のものでは、中括弧で囲まれた名前が続きます。これは、その名前で指定された文字（または文字のシーケンス）を意味します。したがって、 &lt;code&gt;\N{ASTERISK}&lt;/code&gt; は &lt;code&gt;*&lt;/code&gt; の別の記述方法であり、二重引用符で囲まれた文字列と正規表現パターンの両方で有効です。パターンでは、エスケープされていない &lt;code&gt;*&lt;/code&gt; のような意味はありません。</target>
        </trans-unit>
        <trans-unit id="cf50a6157f8b6c5d609d11261410355088e7eb85" translate="yes" xml:space="preserve">
          <source>The transitional compilation environment is obtained with the following compiler and linker flags:</source>
          <target state="translated">移行時のコンパイル環境は、以下のコンパイラフラグとリンカフラグで得られます。</target>
        </trans-unit>
        <trans-unit id="5205d19a729f5413830c865ec36ec411e1524d36" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;a href=&quot;#tr%2F%2F%2F&quot;&gt;&lt;code&gt;tr///&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;&quot;Quote-Like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="translated">文字変換演算子。&lt;a href=&quot;#tr%2F%2F%2F&quot;&gt; &lt;code&gt;tr///&lt;/code&gt; &lt;/a&gt;同じ。&lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;perlopの「Quote-LikeOperators」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b9a818fdcd409263a5793457d26567f24ef801cf" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;a href=&quot;#y%2F%2F%2F&quot;&gt;&lt;code&gt;y///&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;&quot;Quote-Like Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="translated">文字変換演算子。&lt;a href=&quot;#y%2F%2F%2F&quot;&gt; &lt;code&gt;y///&lt;/code&gt; &lt;/a&gt;同じ。&lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;perlopの「Quote-LikeOperators」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7383cd567e6253ea6210a9db604e2fa9e5e4632a" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">文字変換演算子。 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 同じ。&lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;perlopのQuote-Like演算子を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e96d614d57d8ccc80741217a9adfc3a85457d070" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">文字変換演算子。 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 同じ。&lt;a href=&quot;perlop#Quote-Like-Operators&quot;&gt;perlopのQuote-Like演算子を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4178c59a00064af8220ead2c08c98e1676579390" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">文字変換演算子。 &lt;code&gt;&lt;a href=&quot;tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 同じ。&lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;perlopのQuote-Like演算子を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ea9a92782ae9df97b0632f112e4b5544a1a9028b" translate="yes" xml:space="preserve">
          <source>The transliteration operator. Same as &lt;code&gt;&lt;a href=&quot;y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;Quote-Like Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">文字変換演算子。 &lt;code&gt;&lt;a href=&quot;y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; 同じ。&lt;a href=&quot;../perlop#Quote-Like-Operators&quot;&gt;perlopのQuote-Like演算子を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="75ab4f7335b924ba00dcfa6684ad7ab9b56afe36" translate="yes" xml:space="preserve">
          <source>The trap and untrap methods are synonyms for deny and permit respectfully.</source>
          <target state="translated">トラップ法とアントラップ法は、敬意を持って否定し、許可することの同義語です。</target>
        </trans-unit>
        <trans-unit id="79edf12630cd230667f23adf7c1c02295b7aaf31" translate="yes" xml:space="preserve">
          <source>The treatment of more than one physical &lt;b&gt;line&lt;/b&gt; as a single logical line. &lt;b&gt;Makefile&lt;/b&gt; lines are continued by putting a backslash before the &lt;b&gt;newline&lt;/b&gt;. Mail headers, as defined by RFC 822, are continued by putting a space or tab</source>
          <target state="translated">複数の物理&lt;b&gt;回線&lt;/b&gt;を単一の論理回線として扱うこと。&lt;b&gt;Makefileの&lt;/b&gt;行は、&lt;b&gt;改行の&lt;/b&gt;前にバックスラッシュを置くことによって継続され&lt;b&gt;ます&lt;/b&gt;。RFC 822で定義されているメールヘッダーは、スペースまたはタブを挿入することで続きます。</target>
        </trans-unit>
        <trans-unit id="416e0656b5d6eca80f77db061d8df87eef2d675e" translate="yes" xml:space="preserve">
          <source>The tree is created by the compiler while</source>
          <target state="translated">ツリーは</target>
        </trans-unit>
        <trans-unit id="751a409fc8b6dd72130af7dcf107013d6a066c03" translate="yes" xml:space="preserve">
          <source>The trick in this task is to find the directory. Before your script does anything else (such as a &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;), you can get the current working directory with the &lt;code&gt;Cwd&lt;/code&gt; module, which comes with Perl:</source>
          <target state="translated">このタスクの秘訣は、ディレクトリを見つけることです。スクリプトが他のことを行う前に（ &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; など）、Perlに付属している &lt;code&gt;Cwd&lt;/code&gt; モジュールを使用して現在の作業ディレクトリを取得できます。</target>
        </trans-unit>
        <trans-unit id="37e82dc52d548373adee493d4ea5761e5091b906" translate="yes" xml:space="preserve">
          <source>The trick in this task is to find the directory. Before your script does anything else (such as a &lt;code&gt;chdir&lt;/code&gt;), you can get the current working directory with the &lt;code&gt;Cwd&lt;/code&gt; module, which comes with Perl:</source>
          <target state="translated">このタスクの秘訣は、ディレクトリを見つけることです。スクリプトが他のこと（ &lt;code&gt;chdir&lt;/code&gt; など）を実行する前に、Perlに付属している &lt;code&gt;Cwd&lt;/code&gt; モジュールを使用して現在の作業ディレクトリを取得できます。</target>
        </trans-unit>
        <trans-unit id="f5f4f31af96f44cb48b6403e792709ecc6d53b8e" translate="yes" xml:space="preserve">
          <source>The trick is that if you read a &lt;code&gt;BOM&lt;/code&gt; , you will know the byte order, since if it was written on a big-endian platform, you will read the bytes &lt;code&gt;0xFE 0xFF&lt;/code&gt;, but if it was written on a little-endian platform, you will read the bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt;. (And if the originating platform was writing in ASCII platform UTF-8, you will read the bytes &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt;.)</source>
          <target state="translated">トリックは、 &lt;code&gt;BOM&lt;/code&gt; を読み取ると、バイトオーダーがわかるということです。ビッグエンディアンプラットフォームで書き込まれた場合、バイト &lt;code&gt;0xFE 0xFF&lt;/code&gt; を読み取りますが、リトルエンディアンプラットフォームで書き込まれた場合、バイト &lt;code&gt;0xFF 0xFE&lt;/code&gt; を読み取ります。（そして、元のプラットフォームがASCIIプラットフォームUTF-8で書き込んでいた場合、バイト &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt; を読み取ります。）</target>
        </trans-unit>
        <trans-unit id="d8b1136600662502a87d3bbe9f24bb9e6d532704" translate="yes" xml:space="preserve">
          <source>The trick is that if you read a &lt;code&gt;BOM&lt;/code&gt;, you will know the byte order, since if it was written on a big-endian platform, you will read the bytes &lt;code&gt;0xFE 0xFF&lt;/code&gt;, but if it was written on a little-endian platform, you will read the bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt;. (And if the originating platform was writing in ASCII platform UTF-8, you will read the bytes &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt;.)</source>
          <target state="translated">秘訣は、 &lt;code&gt;BOM&lt;/code&gt; を読み取ると、バイト順序がわかるということです。これは、ビッグエンディアンプラットフォームで記述されている場合は、バイト &lt;code&gt;0xFE 0xFF&lt;/code&gt; を読み取るためですが、リトルエンディアンプラットフォームで記述されている場合は、バイト &lt;code&gt;0xFF 0xFE&lt;/code&gt; を読み取ります。（元のプラットフォームがASCIIプラットフォームUTF-8で書き込んでいた場合は、バイト &lt;code&gt;0xEF 0xBB 0xBF&lt;/code&gt; を読み取ります。）</target>
        </trans-unit>
        <trans-unit id="98f1375fe9d48b636ba837bd6c5d9b3f6fb48c48" translate="yes" xml:space="preserve">
          <source>The trick is to give a special parameter to the Configure shell script when running it on AIX:</source>
          <target state="translated">コツは、AIX上でConfigureシェルスクリプトを実行する際に、特別なパラメータを与えることです。</target>
        </trans-unit>
        <trans-unit id="0a8f7f70cdf2316a2ca5d5174affe77306a16af9" translate="yes" xml:space="preserve">
          <source>The trick to this problem is avoiding accidental autovivification. If you want to check three keys deep, you might na&amp;iuml;vely try this:</source>
          <target state="translated">この問題の秘訣は、偶発的な自動活性化を回避することです。3つのキーを深くチェックしたい場合は、単純にこれを試してみてください。</target>
        </trans-unit>
        <trans-unit id="8f023c48c1c4fd330a5e021a4a36ff097b3f2c34" translate="yes" xml:space="preserve">
          <source>The tricky thing to remember is that the first parameter is true if you want to</source>
          <target state="translated">覚えておくと厄介なのは、最初のパラメータが真であれば</target>
        </trans-unit>
        <trans-unit id="0358acd687c89e6aeedb15fd79329af2ac79f19b" translate="yes" xml:space="preserve">
          <source>The trigonometric constant &lt;b&gt;pi&lt;/b&gt; and some of handy multiples of it are also defined.</source>
          <target state="translated">三角定数&lt;b&gt;pi&lt;/b&gt;とその便利な倍数のいくつかも定義されています。</target>
        </trans-unit>
        <trans-unit id="46116b5afa30e36e5dfcca4ac124810d45929096" translate="yes" xml:space="preserve">
          <source>The trust in item 2 is transitive. If A trusts B, and B trusts C, then A trusts C. So if you do not override &lt;code&gt;@ISA&lt;/code&gt; with &lt;code&gt;@CARP_NOT&lt;/code&gt; , then this trust relationship is identical to, &quot;inherits from&quot;.</source>
          <target state="translated">項目2の信頼は推移的です。AがBを信頼し、BがCを信頼する場合、AはCを信頼します。 &lt;code&gt;@CARP_NOT&lt;/code&gt; で &lt;code&gt;@ISA&lt;/code&gt; をオーバーライドしない場合、この信頼関係は「継承元」と同じです。</target>
        </trans-unit>
        <trans-unit id="5a53c9a156d74f53aad5146b2193b6c99edc7b60" translate="yes" xml:space="preserve">
          <source>The trust in item 2 is transitive. If A trusts B, and B trusts C, then A trusts C. So if you do not override &lt;code&gt;@ISA&lt;/code&gt; with &lt;code&gt;@CARP_NOT&lt;/code&gt;, then this trust relationship is identical to, &quot;inherits from&quot;.</source>
          <target state="translated">項目2の信頼は推移的です。AがBを信頼し、あなたがオーバーライドしない場合はBはC、そして信託C.そうを信頼している場合 &lt;code&gt;@ISA&lt;/code&gt; をして &lt;code&gt;@CARP_NOT&lt;/code&gt; 、この信頼関係は、「から継承」に同じです。</target>
        </trans-unit>
        <trans-unit id="761c5f5b8a8444418e2d9bdc4d8cca16ccc65180" translate="yes" xml:space="preserve">
          <source>The truth of the matter is that perl's regular expressions these days are much more complex than this kind of structure, but visualising it this way can help when trying to get your bearings, and it matches the current implementation pretty closely.</source>
          <target state="translated">実際のところ、最近のperlの正規表現はこの種の構造よりもずっと複雑ですが、このように可視化することは、自分の位置を把握しようとするときに役立ちますし、現在の実装とかなり密接に一致しています。</target>
        </trans-unit>
        <trans-unit id="df6a9452c74fa01c8c98846cb474f3c173568489" translate="yes" xml:space="preserve">
          <source>The tty driver is put into raw mode and restored using an operating system specific command, in UNIX-like environments &lt;code&gt;stty&lt;/code&gt; .</source>
          <target state="translated">ttyドライバーはrawモードになり、オペレーティングシステム固有のコマンドを使用して、UNIXのような環境 &lt;code&gt;stty&lt;/code&gt; で復元されます。</target>
        </trans-unit>
        <trans-unit id="cdeef98c16938c38d93335b37db574e68be16a48" translate="yes" xml:space="preserve">
          <source>The tty driver is put into raw mode and restored using an operating system specific command, in UNIX-like environments &lt;code&gt;stty&lt;/code&gt;.</source>
          <target state="translated">ttyドライバは、rawモードに入れ、UNIXライクな環境の中で、オペレーティング・システム固有のコマンドを使用して復元される &lt;code&gt;stty&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99fb31ac14610942d5eec87bdc1a87d0b036e971" translate="yes" xml:space="preserve">
          <source>The tutorial started in the Llama continues in the Alpaca, which introduces the intermediate features of references, data structures, object-oriented programming, and modules:</source>
          <target state="translated">ラマで始まったチュートリアルはアルパカで続き、参照、データ構造、オブジェクト指向プログラミング、モジュールの中間的な機能を紹介しています。</target>
        </trans-unit>
        <trans-unit id="6ef070521ff5826ca5eb1f98285ab64a027e2793" translate="yes" xml:space="preserve">
          <source>The two additional lines request from perl to catch various common problems in your code. They check different things so you need both. A potential problem caught by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; will cause your code to stop immediately when it is encountered, while &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; will merely give a warning (like the command-line switch &lt;b&gt;-w&lt;/b&gt;) and let your code run. To read more about them check their respective manual pages at &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">追加の2行は、コード内のさまざまな一般的な問題をキャッチするためにperlに要求します。彼らは異なるものをチェックするので、両方が必要です。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict;&lt;/code&gt; によって検出される潜在的な問題。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings;&lt;/code&gt; を&lt;a href=&quot;functions/use&quot;&gt;使用している&lt;/a&gt;間、コードが検出されるとすぐに停止します。（コマンドラインスイッチ&lt;b&gt;-wの&lt;/b&gt;ような）警告を表示し、コードを実行させます。それらの詳細については、&lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt;および&lt;a href=&quot;warnings&quot;&gt;warningsにある&lt;/a&gt;それぞれのマニュアルページを確認してください。</target>
        </trans-unit>
        <trans-unit id="80da0e6781561e53bd7245c97926dc9ea61049b1" translate="yes" xml:space="preserve">
          <source>The two additional lines request from perl to catch various common problems in your code. They check different things so you need both. A potential problem caught by &lt;code&gt;use strict;&lt;/code&gt; will cause your code to stop immediately when it is encountered, while &lt;code&gt;use warnings;&lt;/code&gt; will merely give a warning (like the command-line switch &lt;b&gt;-w&lt;/b&gt;) and let your code run. To read more about them check their respective manual pages at &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">追加の2行は、コード内のさまざまな一般的な問題をキャッチするためにperlから要求します。彼らは異なることをチェックするので、両方が必要です。 &lt;code&gt;use strict;&lt;/code&gt; によって捕捉される潜在的な問題。 &lt;code&gt;use warnings;&lt;/code&gt; を使用している間、コードが検出されるとすぐに停止します。単に警告を出し（コマンドラインスイッチ&lt;b&gt;-wのように&lt;/b&gt;）、コードを実行させます。それらの詳細については、それぞれのマニュアルページの&lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt;および&lt;a href=&quot;warnings&quot;&gt;warningsを&lt;/a&gt;確認してください。</target>
        </trans-unit>
        <trans-unit id="ba2dc4945c85043455423fb1b5a39f8aa3d6b28f" translate="yes" xml:space="preserve">
          <source>The two argument form of add_bits() will add the first $nbits bits from $data. For the last potentially partial byte only the high order &lt;code&gt;$nbits % 8&lt;/code&gt; bits are used. If $nbits is greater than &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($data) * 8&lt;/code&gt; , then this method would do the same as &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt; .</source>
          <target state="translated">add_bits（）の2つの引数形式は、$ dataから最初の$ nbitsビットを追加します。最後の潜在的に部分的なバイトについては、上位 &lt;code&gt;$nbits % 8&lt;/code&gt; ビットのみが使用されます。$ nbitsが &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($data) * 8&lt;/code&gt; より大きい場合、このメソッドは &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt; と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="a487d05aa816a2a714594f695177da57d7a262a6" translate="yes" xml:space="preserve">
          <source>The two argument form of add_bits() will add the first $nbits bits from $data. For the last potentially partial byte only the high order &lt;code&gt;$nbits % 8&lt;/code&gt; bits are used. If $nbits is greater than &lt;code&gt;length($data) * 8&lt;/code&gt;, then this method would do the same as &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt;.</source>
          <target state="translated">add_bits（）の2つの引数形式は、$ dataから最初の$ nbitsビットを追加します。最後の潜在的に部分的なバイトには、上位 &lt;code&gt;$nbits % 8&lt;/code&gt; ビットのみが使用されます。$ nbitsが &lt;code&gt;length($data) * 8&lt;/code&gt; より大きい場合、このメソッドは &lt;code&gt;$ctx-&amp;gt;add($data)&lt;/code&gt; と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="edfc68f9b85a8c57ac6b419328c423790a72a43e" translate="yes" xml:space="preserve">
          <source>The two arrays &lt;code&gt;@ISA&lt;/code&gt; and &lt;code&gt;@EXPORT&lt;/code&gt; are very important. The &lt;code&gt;@ISA&lt;/code&gt; array contains a list of other packages in which to search for methods (or subroutines) that do not exist in the current package. This is usually only important for object-oriented extensions (which we will talk about much later), and so usually doesn't need to be modified.</source>
          <target state="translated">&lt;code&gt;@ISA&lt;/code&gt; と &lt;code&gt;@EXPORT&lt;/code&gt; の2つの配列は非常に重要です。 &lt;code&gt;@ISA&lt;/code&gt; の配列は、現在のパッケージには存在しないメソッド（またはサブルーチン）を検索するには他のパッケージのリストが含まれています。これは通常、オブジェクト指向拡張（後で説明します）でのみ重要であるため、通常は変更する必要はありません。</target>
        </trans-unit>
        <trans-unit id="1bc049a18027fa1202df37bcfed013d26326a12f" translate="yes" xml:space="preserve">
          <source>The two control characters ^D and ^Z, and the tokens __END__ and __DATA__ may be used to indicate the logical end of the script before the actual end of file. Any following text is ignored.</source>
          <target state="translated">2 つの制御文字 ^D と ^Z、そしてトークン __END__と _DATA__は、ファイルの実際の終了前にスクリプトの論理的な終了を示すために使用することができます。以下のテキストは無視されます。</target>
        </trans-unit>
        <trans-unit id="34dcc268df0f1b7f78c17ae23e0cef09454c6cdc" translate="yes" xml:space="preserve">
          <source>The two entry points are &lt;code&gt;re_intuit_start()&lt;/code&gt; and &lt;code&gt;pregexec()&lt;/code&gt; . These routines have a somewhat incestuous relationship with overlap between their functions, and &lt;code&gt;pregexec()&lt;/code&gt; may even call &lt;code&gt;re_intuit_start()&lt;/code&gt; on its own. Nevertheless other parts of the perl source code may call into either, or both.</source>
          <target state="translated">2つのエントリポイントは &lt;code&gt;re_intuit_start()&lt;/code&gt; と &lt;code&gt;pregexec()&lt;/code&gt; です。これらのルーチンは、関数間のオーバーラップといくらか近親相姦の関係にあり、 &lt;code&gt;pregexec()&lt;/code&gt; はそれ &lt;code&gt;re_intuit_start()&lt;/code&gt; を呼び出すことさえできます。それにもかかわらず、perlソースコードの他の部分は、どちらか、または両方を呼び出す可能性があります。</target>
        </trans-unit>
        <trans-unit id="18c4b8288d8734c5d96fe76caf7da0dc805d1f00" translate="yes" xml:space="preserve">
          <source>The two entry points are &lt;code&gt;re_intuit_start()&lt;/code&gt; and &lt;code&gt;pregexec()&lt;/code&gt;. These routines have a somewhat incestuous relationship with overlap between their functions, and &lt;code&gt;pregexec()&lt;/code&gt; may even call &lt;code&gt;re_intuit_start()&lt;/code&gt; on its own. Nevertheless other parts of the perl source code may call into either, or both.</source>
          <target state="translated">2つのエントリポイントは &lt;code&gt;re_intuit_start()&lt;/code&gt; と &lt;code&gt;pregexec()&lt;/code&gt; です。これらのルーチンは、関数間のオーバーラップとやや近親相姦の関係にあり、 &lt;code&gt;pregexec()&lt;/code&gt; はそれ &lt;code&gt;re_intuit_start()&lt;/code&gt; を呼び出すことさえあります。それにもかかわらず、perlソースコードの他の部分は、いずれか、または両方を呼び出す可能性があります。</target>
        </trans-unit>
        <trans-unit id="8d4c95b48b6a1668825ba4572ce44483ca77dc51" translate="yes" xml:space="preserve">
          <source>The two filenames can also be given separately in full as &lt;code&gt;$dirfile&lt;/code&gt; and &lt;code&gt;$pagfilename&lt;/code&gt; . This suits for two files without &quot;.dir&quot; and &quot;.pag&quot; extensions, perhaps for example two files from &lt;a href=&quot;file/temp&quot;&gt;File::Temp&lt;/a&gt;.</source>
          <target state="translated">2つのファイル名は、完全に &lt;code&gt;$dirfile&lt;/code&gt; および &lt;code&gt;$pagfilename&lt;/code&gt; として個別に指定することもできます。これは、 &quot;。dir&quot;および &quot;.pag&quot;拡張子のない2つのファイル、たとえば&lt;a href=&quot;file/temp&quot;&gt;File :: Tempの&lt;/a&gt; 2つのファイルに適しています。</target>
        </trans-unit>
        <trans-unit id="d779d1807753d79ce6e5b3476dc2ab8ca5a48661" translate="yes" xml:space="preserve">
          <source>The two filenames can also be given separately in full as &lt;code&gt;$dirfile&lt;/code&gt; and &lt;code&gt;$pagfilename&lt;/code&gt;. This suits for two files without &quot;.dir&quot; and &quot;.pag&quot; extensions, perhaps for example two files from &lt;a href=&quot;File::Temp&quot;&gt;File::Temp&lt;/a&gt;.</source>
          <target state="translated">2つのファイル名は、 &lt;code&gt;$dirfile&lt;/code&gt; および &lt;code&gt;$pagfilename&lt;/code&gt; として完全に別々に指定することもできます。これは、拡張子が「.dir」と「.pag」のない2つのファイル、たとえば&lt;a href=&quot;File::Temp&quot;&gt;File :: Tempの&lt;/a&gt;2つのファイルに適しています。</target>
        </trans-unit>
        <trans-unit id="2f1774e1f537dc56f588c1be426bca15556e7438" translate="yes" xml:space="preserve">
          <source>The two first forms are simply syntactic sugar which automatically load the right module on first use. The second form allow you to use algorithm names which contains letters which are not legal perl identifiers, e.g. &quot;SHA-1&quot;. If no implementation for the given algorithm can be found, then an exception is raised.</source>
          <target state="translated">最初の2つの形式は、最初の使用時に自動的に適切なモジュールをロードするための単純な構文上の糖質です。第二の形式では、例えば &quot;SHA-1&quot; のような、Perl の正当な識別子ではない文字を含むアルゴリズム名を使用することができます。与えられたアルゴリズムの実装が見つからない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="c95a4925ad583d0cdab2da763605ba8a5577a6cd" translate="yes" xml:space="preserve">
          <source>The two main uses for this are to switch back to using the package sub inside an inner scope:</source>
          <target state="translated">主な用途としては、インナースコープの中でパッケージサブを使うように切り替えることと、パッケージサブを使うように切り替えることの2つです。</target>
        </trans-unit>
        <trans-unit id="9fdb893929b74d583f916a04691865e61a0c8195" translate="yes" xml:space="preserve">
          <source>The two most common mistakes made in constructing something like an array of arrays is either accidentally counting the number of elements or else taking a reference to the same memory location repeatedly. Here's the case where you just get the count instead of a nested array:</source>
          <target state="translated">配列の配列のようなものを構築する際によくある2つの間違いは、誤って要素数をカウントしてしまうか、あるいは同じメモリ位置への参照を何度も取ってしまうことです。ここでは、入れ子になった配列の代わりにカウントを取得するだけの場合を示します。</target>
        </trans-unit>
        <trans-unit id="bd2d45d08dbd09dca740f5cf8bff110dce877246" translate="yes" xml:space="preserve">
          <source>The two primary use cases supported by &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; for plugins are</source>
          <target state="translated">プラグインの&lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: Harness&lt;/a&gt;でサポートされている2つの主なユースケースは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="9ef613531270a3be0f714b7b0c6603ad457c5c67" translate="yes" xml:space="preserve">
          <source>The two primary use cases supported by &lt;a href=&quot;harness&quot;&gt;TAP::Harness&lt;/a&gt; for plugins are</source>
          <target state="translated">プラグインの&lt;a href=&quot;harness&quot;&gt;TAP :: Harness&lt;/a&gt;でサポートされる2つの主な使用例は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="49899df9616cd2a3f123de74937bc969a55089e7" translate="yes" xml:space="preserve">
          <source>The two quickest fixes are either to render Perl silent about any locale inconsistencies or to run Perl under the default locale &quot;C&quot;.</source>
          <target state="translated">最も手っ取り早い修正方法は、ロケールの不整合についてPerlを沈黙させるか、デフォルトのロケール &quot;C &quot;でPerlを実行するかの2つです。</target>
        </trans-unit>
        <trans-unit id="1d29057aa8b200a921ab9b4c9f2a8fac7349c60a" translate="yes" xml:space="preserve">
          <source>The two sets of barcharts give stats and a visual indication of performance of the hash.</source>
          <target state="translated">2つのバーチャートのセットは、統計情報とハッシュのパフォーマンスを視覚的に表示します。</target>
        </trans-unit>
        <trans-unit id="ea356fe6678cb16635414403ae22dc70cf7c6eb2" translate="yes" xml:space="preserve">
          <source>The two statements:</source>
          <target state="translated">2つの発言。</target>
        </trans-unit>
        <trans-unit id="9d44f9be0143700229ab0017bf471dc2508dbc35" translate="yes" xml:space="preserve">
          <source>The two-sided ordering operators &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;cmp&quot;&lt;/code&gt;, and the smartmatch operator &lt;code&gt;&quot;~~&quot;&lt;/code&gt;, are non-associative with respect to each other and with respect to the equality operators of the same precedence.</source>
          <target state="translated">両側の順序付け演算子 &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; と &lt;code&gt;&quot;cmp&quot;&lt;/code&gt; 、およびスマートマッチ演算子 &lt;code&gt;&quot;~~&quot;&lt;/code&gt; 、相互に、および同じ優先順位の等式演算子に関して関連付けられていません。</target>
        </trans-unit>
        <trans-unit id="40f9fd98a080c00fe06d27a5abbbe001334533cf" translate="yes" xml:space="preserve">
          <source>The type of partition. See the &lt;code&gt;&quot;:PARTITION_&quot;&lt;/code&gt; export class for a list of known types. See also &lt;code&gt;IsRecognizedPartition&lt;/code&gt; and &lt;code&gt;IsContainerPartition&lt;/code&gt;.</source>
          <target state="translated">パーティションのタイプ。既知のタイプのリストについては、 &lt;code&gt;&quot;:PARTITION_&quot;&lt;/code&gt; エクスポートクラスを参照してください。 &lt;code&gt;IsRecognizedPartition&lt;/code&gt; および &lt;code&gt;IsContainerPartition&lt;/code&gt; も参照してください。</target>
        </trans-unit>
        <trans-unit id="2e850f7b70f56596c655ae357f7738793fa85127" translate="yes" xml:space="preserve">
          <source>The type of the constant (</source>
          <target state="translated">定数の型(</target>
        </trans-unit>
        <trans-unit id="207d3c0594c531831415850568f05351cc4335f1" translate="yes" xml:space="preserve">
          <source>The type of the third parameter is arbitrary as far as the typemap is concerned. It just has to be in line with the declared variable.</source>
          <target state="translated">3番目のパラメータの型は、タイプマップに関する限り任意です。宣言された変数と一致している必要があります。</target>
        </trans-unit>
        <trans-unit id="3a8fb2c5d9024ab64dd8a1b418b0785f1b45c2d4" translate="yes" xml:space="preserve">
          <source>The type-to-match is whitewashed (except for commas, which have no whitespace before them, and multiple &lt;code&gt;*&lt;/code&gt; which have no whitespace between them).</source>
          <target state="translated">type-to-matchはホワイトウォッシュされます（コンマの前に空白がない、および複数の &lt;code&gt;*&lt;/code&gt; の間に空白がない）を除きます。</target>
        </trans-unit>
        <trans-unit id="065bb709681867146d38619409b0c4858958cd7d" translate="yes" xml:space="preserve">
          <source>The typemap checks that a scalar reference is passed from perl to XS.</source>
          <target state="translated">タイプマップはスカラ参照がperlからXSに渡されているかどうかをチェックします。</target>
        </trans-unit>
        <trans-unit id="1aca61f72e9539e566a25a6f843796b117e0a616" translate="yes" xml:space="preserve">
          <source>The types are:</source>
          <target state="translated">タイプは</target>
        </trans-unit>
        <trans-unit id="b8218b5c6abbddadba7d9cdb24a7712b0e31ed41" translate="yes" xml:space="preserve">
          <source>The typical C compiler&amp;rsquo;s first pass, which processes lines beginning with &lt;code&gt;#&lt;/code&gt; for conditional compilation and macro definition, and does various manipulations of the program text based on the current definitions. Also known as</source>
          <target state="translated">条件付きコンパイルとマクロ定義のために &lt;code&gt;#&lt;/code&gt; で始まる行を処理し、現在の定義に基づいてプログラムテキストのさまざまな操作を行う、典型的なCコンパイラの最初のパス。としても知られている</target>
        </trans-unit>
        <trans-unit id="c3f6853138e86a46a65a1f12c8ebb77c9ad23c63" translate="yes" xml:space="preserve">
          <source>The typical approach uses the Perl debugger, described in the</source>
          <target state="translated">典型的なアプローチは</target>
        </trans-unit>
        <trans-unit id="4f5664b1824b0de67fa46d923ec8d9a2b184a8da" translate="yes" xml:space="preserve">
          <source>The typical approach uses the Perl debugger, described in the &lt;a href=&quot;http://man.he.net/man1/perldebug&quot;&gt;perldebug(1)&lt;/a&gt; manpage, on an &quot;empty&quot; program, like this:</source>
          <target state="translated">典型的なアプローチでは、&lt;a href=&quot;http://man.he.net/man1/perldebug&quot;&gt;perldebug（1）の&lt;/a&gt;マンページで説明されているPerlデバッガーを、次のような「空の」プログラムで使用します。</target>
        </trans-unit>
        <trans-unit id="8d039cb4fff50dcf102a20e5a834fd5dcb92db29" translate="yes" xml:space="preserve">
          <source>The typical input/output flow of a program is:</source>
          <target state="translated">プログラムの典型的な入出力の流れです。</target>
        </trans-unit>
        <trans-unit id="bb341dafe72dfd453b6e963169c19a0e3677ecc8" translate="yes" xml:space="preserve">
          <source>The typical interactions between pieces of data are best represented by operators.</source>
          <target state="translated">データの断片間の典型的な相互作用は、演算子で表現するのが最適です。</target>
        </trans-unit>
        <trans-unit id="37bcc82c39e22721104650473d90114a9246bb63" translate="yes" xml:space="preserve">
          <source>The typical usage case is for private modules or working copies of projects from remote repositories on the local disk.</source>
          <target state="translated">典型的な使用例は、プライベートモジュールやリモートリポジトリからローカルディスク上のプロジェクトの作業コピーです。</target>
        </trans-unit>
        <trans-unit id="a4e2f09da65ffeb5dd41665671b5f400f853e79b" translate="yes" xml:space="preserve">
          <source>The typical usage is from within a Makefile generated by &lt;a href=&quot;makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt;. So under normal circumstances you won't have to deal with this module directly.</source>
          <target state="translated">一般的な使用法は、&lt;a href=&quot;makemaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt;によって生成されたMakefile内からです。したがって、通常の状況では、このモジュールを直接処理する必要はありません。</target>
        </trans-unit>
        <trans-unit id="e5ea1d13fc13ac160da9f2f104ab7304934ae9cc" translate="yes" xml:space="preserve">
          <source>The typical usage is from within perl's own Makefile (to build</source>
          <target state="translated">典型的な使用法は、Perl自身のMakefileの中から(</target>
        </trans-unit>
        <trans-unit id="b839dd64fd51c7239737d976be2aaf701494cef3" translate="yes" xml:space="preserve">
          <source>The typical way to use an &lt;code&gt;EVERY&lt;/code&gt; call is to wrap it in another base method, that all classes inherit. For example, to ensure that every destructor an object inherits is actually called (as opposed to just the left-most-depth-first-est one):</source>
          <target state="translated">&lt;code&gt;EVERY&lt;/code&gt; 呼び出しを使用する一般的な方法は、すべてのクラスが継承する別の基本メソッドでそれをラップすることです。たとえば、オブジェクトが継承するすべてのデストラクタが実際に呼び出されることを保証するには（左端の深度が最初のデストラクタとは対照的に）：</target>
        </trans-unit>
        <trans-unit id="d078360c456578fa6c56aaca3475f63295e459b1" translate="yes" xml:space="preserve">
          <source>The uncolor() function and support for ANSI_COLORS_DISABLED were added in Term::ANSIColor 1.04, included in Perl 5.8.0.</source>
          <target state="translated">Perl 5.8.0 に含まれる Term::ANSIColor 1.04 で uncolor()関数と ANSI_COLORS_DISABLED のサポートが追加されました。</target>
        </trans-unit>
        <trans-unit id="d4305b00ed1c85486a9072f02e9b2ef3f0a22224" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;SetFilePointer&lt;/code&gt; returns &lt;code&gt;0xFFFFFFFF&lt;/code&gt; to indicate failure, but if &lt;code&gt;$ioivOffsetHigh&lt;/code&gt; is not &lt;code&gt;[]&lt;/code&gt;, you would also have to check &lt;code&gt;$^E&lt;/code&gt; to determine whether &lt;code&gt;0xFFFFFFFF&lt;/code&gt; indicates an error or not. &lt;code&gt;Win32API::File::SetFilePointer&lt;/code&gt; does this checking for you and returns a false value if and only if the underlying &lt;code&gt;SetFilePointer&lt;/code&gt; failed. For this reason, &lt;code&gt;$uNewPos&lt;/code&gt; is set to &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; if you set the file pointer to the beginning of the file [or any position with 0 for the low-order 4 bytes].</source>
          <target state="translated">基になる &lt;code&gt;SetFilePointer&lt;/code&gt; は失敗を示すために &lt;code&gt;0xFFFFFFFF&lt;/code&gt; を返しますが、 &lt;code&gt;$ioivOffsetHigh&lt;/code&gt; が &lt;code&gt;[]&lt;/code&gt; でない場合は、 &lt;code&gt;$^E&lt;/code&gt; をチェックして、 &lt;code&gt;0xFFFFFFFF&lt;/code&gt; がエラーを示しているかどうかを判断する必要もあります。 &lt;code&gt;Win32API::File::SetFilePointer&lt;/code&gt; はこのチェックを行い、基になる &lt;code&gt;SetFilePointer&lt;/code&gt; が失敗した場合にのみ、false値を返します。このため、ファイルポインタをファイルの先頭[または下位4バイトの場合は0の任意の位置]に設定すると、 &lt;code&gt;$uNewPos&lt;/code&gt; は &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; 0buttrue 」に設定されます。</target>
        </trans-unit>
        <trans-unit id="da2ba2ed494fcbfde7ff54569b0d33c7f011e269" translate="yes" xml:space="preserve">
          <source>The underlying behaviour of &lt;code&gt;%+&lt;/code&gt; is provided by the &lt;a href=&quot;Tie::Hash::NamedCapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; module.</source>
          <target state="translated">&lt;code&gt;%+&lt;/code&gt; の基本的な動作は、&lt;a href=&quot;Tie::Hash::NamedCapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt;モジュールによって提供されます。</target>
        </trans-unit>
        <trans-unit id="d2846292c4ece0df1cdbdb746e73838c0174b8ea" translate="yes" xml:space="preserve">
          <source>The underlying behaviour of &lt;code&gt;%+&lt;/code&gt; is provided by the &lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie::Hash::NamedCapture&lt;/a&gt; module.</source>
          <target state="translated">&lt;code&gt;%+&lt;/code&gt; の基本的な動作は、&lt;a href=&quot;tie/hash/namedcapture&quot;&gt;Tie :: Hash :: NamedCapture&lt;/a&gt;モジュールによって提供されます。</target>
        </trans-unit>
        <trans-unit id="cc10f153a716bc66afaf3456e02a5c9183a04515" translate="yes" xml:space="preserve">
          <source>The underlying parser object. This is useful if you need the full information for the test program.</source>
          <target state="translated">基礎となるパーサオブジェクトです。これは、テストプログラムの完全な情報が必要な場合に便利です。</target>
        </trans-unit>
        <trans-unit id="b7d8dde972f17bdda4b61ab86196bc96064679a1" translate="yes" xml:space="preserve">
          <source>The undump program was an ancient attempt to speed up Perl program by storing the already-compiled form to disk. This is no longer a viable option, as it only worked on a few architectures, and wasn't a good solution anyway.</source>
          <target state="translated">アンダンププログラムは、コンパイル済みのフォームをディスクに保存することで Perl プログラムを高速化しようとする昔からの試みでした。これは、いくつかのアーキテクチャでしか機能しなかったので、もはや実行可能なオプションではありませんし、いずれにしても良い解決策ではありませんでした。</target>
        </trans-unit>
        <trans-unit id="be8a46bbcbbd519aa2c58d3aea183c9d8f4c685d" translate="yes" xml:space="preserve">
          <source>The unfortunate similarity of this function's name to that of Perl's &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; operator is strictly coincidental. This function works from the left; &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; works from the right.</source>
          <target state="translated">この関数の名前とPerlの &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; 演算子の名前の不幸な類似点は、まったくの偶然です。この機能は左から機能します。 &lt;code&gt;&lt;a href=&quot;functions/chop&quot;&gt;chop&lt;/a&gt;&lt;/code&gt; は右から動作します。</target>
        </trans-unit>
        <trans-unit id="a30b1d50e05e4b08ed93704bd74f564e5fd07aba" translate="yes" xml:space="preserve">
          <source>The unfortunate similarity of this function's name to that of Perl's &lt;code&gt;chop&lt;/code&gt; operator is strictly coincidental. This function works from the left; &lt;code&gt;chop&lt;/code&gt; works from the right.</source>
          <target state="translated">この関数の名前がPerlの &lt;code&gt;chop&lt;/code&gt; 演算子の名前と不幸にも似ているのは、まったくの偶然です。この関数は左から機能します。 &lt;code&gt;chop&lt;/code&gt; は右から動作します。</target>
        </trans-unit>
        <trans-unit id="188f61d7ec87851548e9f8daeb9600a5a694a2e6" translate="yes" xml:space="preserve">
          <source>The union of two array refs</source>
          <target state="translated">2つの配列refの和</target>
        </trans-unit>
        <trans-unit id="ca3db9d0f0db6a082e0aea1f0a6be142ef87df51" translate="yes" xml:space="preserve">
          <source>The untie Gotcha</source>
          <target state="translated">The untie Gotcha</target>
        </trans-unit>
        <trans-unit id="12164923a1b041bdc762cdb62bbbc7fb759ea434" translate="yes" xml:space="preserve">
          <source>The untie() Gotcha</source>
          <target state="translated">untie()のガッチャ</target>
        </trans-unit>
        <trans-unit id="50d65961a427d2a64bc08d49e4d87b52f498e907" translate="yes" xml:space="preserve">
          <source>The uppercase variants (&lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , &lt;code&gt;\H&lt;/code&gt; , and &lt;code&gt;\V&lt;/code&gt; ) are character classes that match, respectively, any character that isn't a word character, digit, whitespace, horizontal whitespace, or vertical whitespace.</source>
          <target state="translated">大文字のバリアント（ &lt;code&gt;\W&lt;/code&gt; 、 &lt;code&gt;\D&lt;/code&gt; 、 &lt;code&gt;\S&lt;/code&gt; 、 &lt;code&gt;\H&lt;/code&gt; 、および &lt;code&gt;\V&lt;/code&gt; ）は、単語文字、数字、空白、水平空白、垂直空白以外の任意の文字にそれぞれ一致する文字クラスです。</target>
        </trans-unit>
        <trans-unit id="969149804a3c69f65ce9535464f4fe7c8cb52284" translate="yes" xml:space="preserve">
          <source>The uppercase variants (&lt;code&gt;\W&lt;/code&gt;, &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, &lt;code&gt;\H&lt;/code&gt;, and &lt;code&gt;\V&lt;/code&gt;) are character classes that match, respectively, any character that isn't a word character, digit, whitespace, horizontal whitespace, or vertical whitespace.</source>
          <target state="translated">大文字のバリアント（ &lt;code&gt;\W&lt;/code&gt; 、 &lt;code&gt;\D&lt;/code&gt; 、 &lt;code&gt;\S&lt;/code&gt; 、 &lt;code&gt;\H&lt;/code&gt; 、および &lt;code&gt;\V&lt;/code&gt; ）は、それぞれ、単語文字、数字、空白、水平方向の空白、または垂直方向の空白以外の任意の文字に一致する文字クラスです。</target>
        </trans-unit>
        <trans-unit id="6a360f037634db2d1e1b847c01d4ff39f2e82c73" translate="yes" xml:space="preserve">
          <source>The uri you passed to the constructor</source>
          <target state="translated">コンストラクタに渡したURI</target>
        </trans-unit>
        <trans-unit id="7175c322baef80b04d65002673bad08dde1a5590" translate="yes" xml:space="preserve">
          <source>The urllist parameter has CD-ROM support</source>
          <target state="translated">urllist パラメータは CD-ROM をサポートしています。</target>
        </trans-unit>
        <trans-unit id="0e71ac825c7f966ddb9142eb457a1ad27b050118" translate="yes" xml:space="preserve">
          <source>The usage is for a canned filter is:</source>
          <target state="translated">使い方は、缶詰フィルターの場合です。</target>
        </trans-unit>
        <trans-unit id="28d3b03a1f670128ac1940bc311030e5942649cb" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;*glob{FILEHANDLE}&lt;/code&gt; was deprecated in Perl 5.8. The intention was to use &lt;code&gt;*glob{IO}&lt;/code&gt; instead, for which &lt;code&gt;*glob{FILEHANDLE}&lt;/code&gt; is an alias.</source>
          <target state="translated">&lt;code&gt;*glob{FILEHANDLE}&lt;/code&gt; の使用はPerl5.8で非推奨になりました。代わりに &lt;code&gt;*glob{IO}&lt;/code&gt; を使用することを目的としていました。 &lt;code&gt;*glob{FILEHANDLE}&lt;/code&gt; はエイリアスです。</target>
        </trans-unit>
        <trans-unit id="826c70de8255c56bc69c42539c313e47e2f05832" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;//g&lt;/code&gt; is shown in the following example. Suppose we have a string that consists of words separated by spaces. If we know how many words there are in advance, we could extract the words using groupings:</source>
          <target state="translated">&lt;code&gt;//g&lt;/code&gt; の使用法を次の例に示します。スペースで区切られた単語で構成される文字列があるとします。単語の数が事前にわかっている場合は、グループ化を使用して単語を抽出できます。</target>
        </trans-unit>
        <trans-unit id="6a8f9ae899c24a9ba384007b7a56b302e1ecb384" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;/g&lt;/code&gt; is shown in the following example. Suppose we have a string that consists of words separated by spaces. If we know how many words there are in advance, we could extract the words using groupings:</source>
          <target state="translated">&lt;code&gt;/g&lt;/code&gt; の使用法を次の例に示します。スペースで区切られた単語で構成される文字列があるとします。事前に単語の数がわかっている場合は、グループ化を使用して単語を抽出できます。</target>
        </trans-unit>
        <trans-unit id="832a5d88d8f5443e11412058babdb54340f702ac" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;:void&lt;/code&gt; is discouraged, as it can result in exceptions not being thrown if you</source>
          <target state="translated">&lt;code&gt;:void&lt;/code&gt; の使用はお勧めしません。</target>
        </trans-unit>
        <trans-unit id="0ce5a82961769245d2e039e505d826cd3e904ef4" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;:void&lt;/code&gt; with Fatal is discouraged.</source>
          <target state="translated">Fatal で &lt;code&gt;:void&lt;/code&gt; を使用することはお勧めしません。</target>
        </trans-unit>
        <trans-unit id="dac4651068bc57e4e25c4b9a7bdd7a073791862a" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;=&amp;gt;&lt;/code&gt; above provides necessary quoting of &lt;code&gt;MODULE&lt;/code&gt; . If you don't use the fat comma (eg you don't have any ARGUMENTS), then you'll need to quote the MODULE.</source>
          <target state="translated">上記の &lt;code&gt;=&amp;gt;&lt;/code&gt; の使用は、 &lt;code&gt;MODULE&lt;/code&gt; の必要な引用を提供します。太いコンマを使用しない場合（たとえば、引数がない場合）、モジュールを引用する必要があります。</target>
        </trans-unit>
        <trans-unit id="3987152a02b0e8946670fa1ed3d0263b2379f73d" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;\K&lt;/code&gt; inside of another lookaround assertion is allowed, but the behaviour is currently not well defined.</source>
          <target state="translated">別のルックアラウンドアサーション内での &lt;code&gt;\K&lt;/code&gt; の使用は許可されていますが、動作は現在十分に定義されていません。</target>
        </trans-unit>
        <trans-unit id="9b512e8508712c1167d958e6e4ad448ccc7e030f" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;\Q&lt;/code&gt; causes the &amp;lt;.&amp;gt; in the regex to be treated as a regular character, so that &lt;code&gt;P.&lt;/code&gt; matches a &lt;code&gt;P&lt;/code&gt; followed by a dot.</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; を使用すると、正規表現の&amp;lt;。&amp;gt;が通常の文字として扱われるため、 &lt;code&gt;P.&lt;/code&gt; は &lt;code&gt;P&lt;/code&gt; の後にドットが続くように一致します。</target>
        </trans-unit>
        <trans-unit id="fc1eea836569752f037bcfe192ccf1fd3a1c9537" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;\Q&lt;/code&gt; causes the &lt;code&gt;.&lt;/code&gt; in the regex to be treated as a regular character, so that &lt;code&gt;P.&lt;/code&gt; matches a &lt;code&gt;P&lt;/code&gt; followed by a dot.</source>
          <target state="translated">&lt;code&gt;\Q&lt;/code&gt; を使用すると、が発生し &lt;code&gt;.&lt;/code&gt; 正規表現で通常の文字として扱われるため、 &lt;code&gt;P.&lt;/code&gt; は &lt;code&gt;P&lt;/code&gt; の後にドットが続きます。</target>
        </trans-unit>
        <trans-unit id="6a848a8f72097323f82bf0128df3ae2506a4c5d0" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;my()&lt;/code&gt; in a false conditional has been deprecated in Perl 5.10, and became a fatal error in Perl 5.30.</source>
          <target state="translated">false条件での &lt;code&gt;my()&lt;/code&gt; の使用は、 Perl 5.10で非推奨になり、Perl5.30で致命的なエラーになりました。</target>
        </trans-unit>
        <trans-unit id="514e40665c7756f02fb508e8f86f86167ddf537d" translate="yes" xml:space="preserve">
          <source>The use of a camel with the topic of Perl is a trademark of O'Reilly and Associates, Inc. Used with permission.</source>
          <target state="translated">Perlの話題のラクダの使用は、O'Reilly and Associates,Inc.の商標です。許可を得て使用しています。</target>
        </trans-unit>
        <trans-unit id="9cb45eca9a7939753b03a1360d763d098c0e7870" translate="yes" xml:space="preserve">
          <source>The use of all caps for constant names is merely a convention, although it is recommended in order to make constants stand out and to help avoid collisions with other barewords, keywords, and subroutine names. Constant names must begin with a letter or underscore. Names beginning with a double underscore are reserved. Some poor choices for names will generate warnings, if warnings are enabled at compile time.</source>
          <target state="translated">定数名にオールキャップを使用するのは単なる慣習に過ぎませんが、定数を目立たせ、他のベアワード、キーワード、サブルーチン名との衝突を避けるために推奨されています。定数名は文字かアンダースコアで始めなければなりません。ダブルアンダースコアで始まる名前は予約されています。コンパイル時に警告が有効になっている場合は、名前の選択に誤りがあると警告が発生します。</target>
        </trans-unit>
        <trans-unit id="58b862df75de13b5dcf2d9b0b606b5454f4112c1" translate="yes" xml:space="preserve">
          <source>The use of hash keys starting with a hyphen (&lt;code&gt;-name&lt;/code&gt; ) or entirely in upper case (&lt;code&gt;NAME&lt;/code&gt; ) is a relic of older versions of Perl in which ordinary lower case strings were not handled correctly by the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator. While some modules retain uppercase or hyphenated argument keys for historical reasons or as a matter of personal style, most new modules should use simple lower case keys. Whatever you choose, be consistent!</source>
          <target state="translated">ハイフン（ &lt;code&gt;-name&lt;/code&gt; ）で始まる、または完全に大文字（ &lt;code&gt;NAME&lt;/code&gt; ）で始まるハッシュキーの使用は、通常の小文字の文字列が &lt;code&gt;=&amp;gt;&lt;/code&gt; 演算子で正しく処理されなかった古いバージョンのPerlの遺物です。一部のモジュールは、歴史的な理由から、または個人的なスタイルの問題として、大文字またはハイフン付きの引数キーを保持しますが、ほとんどの新しいモジュールは、単純な小文字キーを使用する必要があります。何を選択しても、一貫性があります。</target>
        </trans-unit>
        <trans-unit id="42f05d562fbd6250c25a2395c7f661a4ca156a47" translate="yes" xml:space="preserve">
          <source>The use of hash keys starting with a hyphen (&lt;code&gt;-name&lt;/code&gt;) or entirely in upper case (&lt;code&gt;NAME&lt;/code&gt;) is a relic of older versions of Perl in which ordinary lower case strings were not handled correctly by the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator. While some modules retain uppercase or hyphenated argument keys for historical reasons or as a matter of personal style, most new modules should use simple lower case keys. Whatever you choose, be consistent!</source>
          <target state="translated">ハイフン（ &lt;code&gt;-name&lt;/code&gt; ）で始まるハッシュキーまたは完全に大文字（ &lt;code&gt;NAME&lt;/code&gt; ）で始まるハッシュキーの使用は、通常の小文字の文字列が &lt;code&gt;=&amp;gt;&lt;/code&gt; 演算子によって正しく処理されなかった古いバージョンのPerlの遺物です。一部のモジュールは、歴史的な理由または個人的なスタイルの問題として大文字またはハイフンでつながれた引数キーを保持しますが、ほとんどの新しいモジュールは単純な小文字のキーを使用する必要があります。何を選んでも、一貫性を保ってください！</target>
        </trans-unit>
        <trans-unit id="0181fb947fb2e09fe7658e112ec2fe9418c5503f" translate="yes" xml:space="preserve">
          <source>The use of interpreter-based threads in perl is officially &lt;a href=&quot;perlpolicy#discouraged&quot;&gt;discouraged&lt;/a&gt;.</source>
          <target state="translated">perlでインタプリタベースのスレッドを使用することは公式には&lt;a href=&quot;perlpolicy#discouraged&quot;&gt;推奨されていません&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="74fecb64d5ab9c5206223686d13a4c9238b9c4d9" translate="yes" xml:space="preserve">
          <source>The use of one-shot &lt;code&gt;gzip&lt;/code&gt; above just reads from &lt;code&gt;$r-&amp;gt;filename&lt;/code&gt; and writes the compressed data to standard output.</source>
          <target state="translated">上記のワンショット &lt;code&gt;gzip&lt;/code&gt; を使用すると、 &lt;code&gt;$r-&amp;gt;filename&lt;/code&gt; から読み取り、圧縮データを標準出力に書き込むだけです。</target>
        </trans-unit>
        <trans-unit id="aa4d1599ed2c314509e371c80e5511844a0d9d78" translate="yes" xml:space="preserve">
          <source>The use of out of range code points was deprecated in Perl 5.24, and became a fatal error in Perl 5.28.</source>
          <target state="translated">範囲外コードポイントの使用はPerl 5.24で非推奨となり、Perl 5.28では致命的なエラーとなりました。</target>
        </trans-unit>
        <trans-unit id="f9bd1a86a4853953267a9ded9b1645e890ed750a" translate="yes" xml:space="preserve">
          <source>The use of out of range code points was deprecated in Perl 5.24; as of Perl 5.28 using a code point exceeding &lt;code&gt;IV_MAX&lt;/code&gt; throws a fatal error.</source>
          <target state="translated">範囲外のコードポイントの使用は、Perl5.24で非推奨になりました。Perl 5.28以降、 &lt;code&gt;IV_MAX&lt;/code&gt; を超えるコードポイントを使用すると致命的なエラーがスローされます。</target>
        </trans-unit>
        <trans-unit id="af3aa24ab804ebe0a65aee4289caba48448e851d" translate="yes" xml:space="preserve">
          <source>The use of parentheses around a &lt;b&gt;subpattern&lt;/b&gt; in a &lt;b&gt;regular expression&lt;/b&gt; to store the matched &lt;b&gt;substring&lt;/b&gt; as a &lt;b&gt;backreference&lt;/b&gt;. (Captured strings are also returned as a list in &lt;b&gt;list context&lt;/b&gt;.) See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">一致した&lt;b&gt;部分文字列&lt;/b&gt;を&lt;b&gt;後方参照&lt;/b&gt;として保存するための、&lt;b&gt;正規表現での&lt;/b&gt;&lt;b&gt;サブパターン&lt;/b&gt;の括弧の使用。（キャプチャされた文字列は、&lt;b&gt;リストコンテキストの&lt;/b&gt;リストとしても返され&lt;b&gt;ます&lt;/b&gt;。）Camelの第5章「パターンマッチング」を参照してください。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ceb3a7a104da1d4a198b733387677a08ee3ca395" translate="yes" xml:space="preserve">
          <source>The use of parenthesis can be used to capture parts of the input filename.</source>
          <target state="translated">括弧の使用は、入力ファイル名の一部をキャプチャするために使用することができます。</target>
        </trans-unit>
        <trans-unit id="379fb1c054bbd3152f276aaca35f049867852f33" translate="yes" xml:space="preserve">
          <source>The use of the following functions is discouraged as they are not actually testing functions and produce no diagnostics to help figure out what went wrong. They were written before &lt;code&gt;is_deeply()&lt;/code&gt; existed because I couldn't figure out how to display a useful diff of two arbitrary data structures.</source>
          <target state="translated">以下の関数は実際には関数をテストしておらず、何が問題であるかを理解するのに役立つ診断を生成しないため、使用をお勧めしません。 &lt;code&gt;is_deeply()&lt;/code&gt; が存在する前に記述されたのは、2つの任意のデータ構造の有用なdiffを表示する方法を理解できなかったためです。</target>
        </trans-unit>
        <trans-unit id="5b392cf4598b7c92d87fc443e5bf63773c90811b" translate="yes" xml:space="preserve">
          <source>The usenm option</source>
          <target state="translated">usenmオプション</target>
        </trans-unit>
        <trans-unit id="977cdd9dc7908139553c49b2609de1c2c08baff9" translate="yes" xml:space="preserve">
          <source>The user id owning the file</source>
          <target state="translated">ファイルを所有するユーザーID</target>
        </trans-unit>
        <trans-unit id="5d40086458e1b194df3ff27c332046fe8de9903b" translate="yes" xml:space="preserve">
          <source>The user name that owns the file</source>
          <target state="translated">ファイルを所有するユーザー名</target>
        </trans-unit>
        <trans-unit id="9ab82377d9d8e711c9e229f8137ce74619a6f296" translate="yes" xml:space="preserve">
          <source>The user time is the amount of time the entire process spent on behalf of the user on this system executing this program.</source>
          <target state="translated">ユーザ時間とは、このシステム上でこのプログラムを実行しているユーザに代わってプロセス全体が費やした時間である。</target>
        </trans-unit>
        <trans-unit id="244da933c00a6b886bfc62a46ed8d2ddfb906e87" translate="yes" xml:space="preserve">
          <source>The user who wants the memoization cache to be expired according to your policy will say so by writing</source>
          <target state="translated">あなたのポリシーにしたがって、メモ化キャッシュを期限切れにしたいユーザーは、次のように書いて、その旨を伝えます。</target>
        </trans-unit>
        <trans-unit id="bb2fd16359343bc75d33118c9751a1ecbc3d3037" translate="yes" xml:space="preserve">
          <source>The usual arithmetic (+,-,+=,-=) is also available on the objects.</source>
          <target state="translated">通常の算術(+,-,+=,-=)は、オブジェクト上でも可能です。</target>
        </trans-unit>
        <trans-unit id="c7334043434491bfd6d25a23b05fb6d156604749" translate="yes" xml:space="preserve">
          <source>The usual calling signature is</source>
          <target state="translated">いつものコールサインは</target>
        </trans-unit>
        <trans-unit id="72046882a8fdaf30c0521d766b5cf67d3d264433" translate="yes" xml:space="preserve">
          <source>The usual idiom is:</source>
          <target state="translated">いつもの慣用句は</target>
        </trans-unit>
        <trans-unit id="7ac11eaf69a957a9aa5638ad8debab406436e005" translate="yes" xml:space="preserve">
          <source>The usual method for terminating a thread is to &lt;a href=&quot;functions/return&quot;&gt;return EXPR&lt;/a&gt; from the entry point function with the appropriate return value(s).</source>
          <target state="translated">スレッドを終了する通常の方法は、適切な戻り値でエントリーポイント関数から&lt;a href=&quot;functions/return&quot;&gt;EXPR&lt;/a&gt;を返すことです。</target>
        </trans-unit>
        <trans-unit id="9019b0c3813c3cf91527f6ac86d5eb12ae5c43b5" translate="yes" xml:space="preserve">
          <source>The usual method for terminating a thread is to &lt;a href=&quot;perlfunc#return-EXPR&quot;&gt;return()&lt;/a&gt; from the entry point function with the appropriate return value(s).</source>
          <target state="translated">スレッドを終了する通常の方法は、適切な戻り値を使用してエントリポイント関数から&lt;a href=&quot;perlfunc#return-EXPR&quot;&gt;return（）&lt;/a&gt;を実行することです。</target>
        </trans-unit>
        <trans-unit id="189fd1d4b573f9b0c1b1794439c343e0650165ef" translate="yes" xml:space="preserve">
          <source>The usual shell redirection symbols &lt;code&gt; | &lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; are recognized by the cpan shell &lt;b&gt;only when surrounded by whitespace&lt;/b&gt;. So piping to pager or redirecting output into a file works somewhat as in a normal shell, with the stipulation that you must type extra spaces.</source>
          <target state="translated">通常のシェルリダイレクトシンボル &lt;code&gt; | &lt;/code&gt; および &lt;code&gt;&amp;gt;&lt;/code&gt; は&lt;b&gt;、空白で囲まれている場合にのみ&lt;/b&gt; cpanシェルによって認識さ&lt;b&gt;れます&lt;/b&gt;。したがって、ページャーへのパイプやファイルへの出力のリダイレクトは、通常のシェルのようにいくらか機能しますが、余分なスペースを入力する必要があります。</target>
        </trans-unit>
        <trans-unit id="f5284fa656dfbed57ca832128b9046307b6a8989" translate="yes" xml:space="preserve">
          <source>The usual warnings if it can't read or write the files involved.</source>
          <target state="translated">関係するファイルを読み書きできない場合は、通常の警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="9c1efd4c7ee39f810e92b8d45a9ddf28889531e0" translate="yes" xml:space="preserve">
          <source>The usual warnings if it cannot read or write the files involved.</source>
          <target state="translated">関係するファイルを読み書きできない場合は、通常の警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="22c79ee036d08be39b9326c3b9dab69e6aa2a162" translate="yes" xml:space="preserve">
          <source>The usually available constants are</source>
          <target state="translated">通常利用可能な定数は</target>
        </trans-unit>
        <trans-unit id="59963cc04cd3e99323ab911f21a23f907334eab6" translate="yes" xml:space="preserve">
          <source>The usually available constants are as follows.</source>
          <target state="translated">通常利用可能な定数は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="2efc4102646dfcf9e84b807940c146f94356608b" translate="yes" xml:space="preserve">
          <source>The util.c:1716 is the source code file and line number.</source>
          <target state="translated">util.c:1716はソースコードファイルと行番号です。</target>
        </trans-unit>
        <trans-unit id="822e481a167310eec4961d968bbe1f00f0652d77" translate="yes" xml:space="preserve">
          <source>The utilities &lt;code&gt;c2ph&lt;/code&gt; and &lt;code&gt;pstruct&lt;/code&gt;</source>
          <target state="translated">ユーティリティ &lt;code&gt;c2ph&lt;/code&gt; および &lt;code&gt;pstruct&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70f118979bfd7ebb716612c147525a5086ff812a" translate="yes" xml:space="preserve">
          <source>The utilities c2ph and pstruct</source>
          <target state="translated">ユーティリティ c2ph と pstruct</target>
        </trans-unit>
        <trans-unit id="e3d163a1d052b62f7d060607d4bf6b7f91f9aa60" translate="yes" xml:space="preserve">
          <source>The v-strings are portable only up to v2147483647 (0x7FFF_FFFF), that's how far EBCDIC, or more precisely UTF-EBCDIC will go.</source>
          <target state="translated">v文字列はv2147483647 (0x7FFF_FFFF)までしか移植できませんが、これはEBCDIC、より正確にはUTF-EBCDICがどこまで行けるかということです。</target>
        </trans-unit>
        <trans-unit id="84e2770182dc038d9b47afe7e9b08eec9556b081" translate="yes" xml:space="preserve">
          <source>The v5.16 release also supports a &lt;code&gt;:loose&lt;/code&gt; import for loose matching of character names, which works just like loose matching of property names: that is, it disregards case, whitespace, and underscores:</source>
          <target state="translated">v5.16リリースでは、文字名の緩やかなマッチングのための &lt;code&gt;:loose&lt;/code&gt; インポートもサポートされています。これは、プロパティ名の緩やかなマッチングと同様に機能します。つまり、大文字と小文字、空白、アンダースコアは無視されます。</target>
        </trans-unit>
        <trans-unit id="b193f0ebc1769a16dcfcc639a8401c8c00cf9c0e" translate="yes" xml:space="preserve">
          <source>The valgrind tool can be used to find out both memory leaks and illegal heap memory accesses. As of version 3.3.0, Valgrind only supports Linux on x86, x86-64 and PowerPC and Darwin (OS X) on x86 and x86-64). The special &quot;test.valgrind&quot; target can be used to run the tests under valgrind. Found errors and memory leaks are logged in files named</source>
          <target state="translated">valgrindツールは、メモリリークと不正なヒープメモリアクセスの両方を見つけるために使用することができます。バージョン3.3.0現在、valgrindはx86,x86-64のLinuxとx86,x86-64のPowerPCとDarwin(OS X)のみをサポートしています)。特別な &quot;test.valgrind &quot;ターゲットを使用してvalgrindの下でテストを実行することができます。見つかったエラーとメモリリークは</target>
        </trans-unit>
        <trans-unit id="d0c464474306348983509bffccc9878d55f4fc97" translate="yes" xml:space="preserve">
          <source>The valgrind tool can be used to find out both memory leaks and illegal heap memory accesses. As of version 3.3.0, Valgrind only supports Linux on x86, x86-64 and PowerPC and Darwin (OS X) on x86 and x86-64. The special &quot;test.valgrind&quot; target can be used to run the tests under valgrind. Found errors and memory leaks are logged in files named</source>
          <target state="translated">valgrindツールは、メモリリークと不正なヒープメモリアクセスの両方を見つけるために使用することができます。バージョン3.3.0現在、valgrindはx86、x86-64上のLinuxと、x86、x86-64上のPowerPCとDarwin(OS X)のみをサポートしています。特別な &quot;test.valgrind &quot;ターゲットを使用して、valgrindの下でテストを実行することができます。見つかったエラーやメモリリークは</target>
        </trans-unit>
        <trans-unit id="aa3e07c88c6113557baab8df17b4983a954a8994" translate="yes" xml:space="preserve">
          <source>The value assigned to the key &lt;code&gt;'fallback'&lt;/code&gt; tells Perl how hard it should try to find an alternative way to implement a missing operator.</source>
          <target state="translated">キー &lt;code&gt;'fallback'&lt;/code&gt; 割り当てられた値は、欠落している演算子を実装する別の方法を見つけるのがどれほど難しいかをPerlに伝えます。</target>
        </trans-unit>
        <trans-unit id="6f766eba2f1a65e15d6582321bc30fe9d0e0e26a" translate="yes" xml:space="preserve">
          <source>The value associated with &lt;code&gt;env&lt;/code&gt; is itself a hashref that is matched against corresponding values in the &lt;code&gt;%ENV&lt;/code&gt; hash. Keys prefixed with &lt;code&gt;not_&lt;/code&gt; negates the corresponding match.</source>
          <target state="translated">&lt;code&gt;env&lt;/code&gt; に関連付けられた値自体は、 &lt;code&gt;%ENV&lt;/code&gt; ハッシュ内の対応する値と照合されるハッシュ参照です。 &lt;code&gt;not_&lt;/code&gt; で始まるキーは、対応する一致を否定します。</target>
        </trans-unit>
        <trans-unit id="aa731dffe1d7c5a02c15e427c4d55ad58928d794" translate="yes" xml:space="preserve">
          <source>The value associated with &lt;code&gt;perlconfig&lt;/code&gt; is itself a hashref that is matched against corresponding values in the &lt;code&gt;%Config::Config&lt;/code&gt; hash living in the &lt;code&gt;Config.pm&lt;/code&gt; module. Keys prefixed with &lt;code&gt;not_&lt;/code&gt; negates the corresponding match.</source>
          <target state="translated">&lt;code&gt;perlconfig&lt;/code&gt; に関連付けられている値自体は、 &lt;code&gt;Config.pm&lt;/code&gt; モジュールにある &lt;code&gt;%Config::Config&lt;/code&gt; ハッシュの対応する値と照合されるハッシュ参照です。 &lt;code&gt;not_&lt;/code&gt; で始まるキーは、対応する一致を否定します。</target>
        </trans-unit>
        <trans-unit id="86d758b44cf7d343d2636c283000a90f2b95ec68" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;$offset&lt;/code&gt; in Unix will be &lt;code&gt;0&lt;/code&gt; , but in Mac OS Classic will be some large number. &lt;code&gt;$offset&lt;/code&gt; can then be added to a Unix time value to get what should be the proper value on any system.</source>
          <target state="translated">Unixの &lt;code&gt;$offset&lt;/code&gt; の値は &lt;code&gt;0&lt;/code&gt; になりますが、Mac OS Classicの場合はかなり大きな値になります。次に、 &lt;code&gt;$offset&lt;/code&gt; をUnix時間値に追加して、システムで適切な値を取得できます。</target>
        </trans-unit>
        <trans-unit id="9f9c34760dc2837fd17b567df1f5e5a179a637d8" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;$offset&lt;/code&gt; in Unix will be &lt;code&gt;0&lt;/code&gt;, but in Mac OS Classic will be some large number. &lt;code&gt;$offset&lt;/code&gt; can then be added to a Unix time value to get what should be the proper value on any system.</source>
          <target state="translated">Unixでは &lt;code&gt;$offset&lt;/code&gt; の値は &lt;code&gt;0&lt;/code&gt; になりますが、Mac OSClassicではかなりの数になります。次に、 &lt;code&gt;$offset&lt;/code&gt; をUnix時間値に追加して、任意のシステムで適切な値を取得できます。</target>
        </trans-unit>
        <trans-unit id="6a050ff582b3cdf570af43e605e700a8d71acf02" translate="yes" xml:space="preserve">
          <source>The value in each entry of the hash is what you are referring to when you use the &lt;code&gt;*name&lt;/code&gt; typeglob notation.</source>
          <target state="translated">ハッシュの各エントリの値は、 &lt;code&gt;*name&lt;/code&gt; タイプグロブ表記を使用するときに参照しているものです。</target>
        </trans-unit>
        <trans-unit id="0f707479820ff9d25dbdd6e993639c9a31b93e20" translate="yes" xml:space="preserve">
          <source>The value is identical to &lt;code&gt;$Config{'osname'}&lt;/code&gt; . See also &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; and the &lt;b&gt;-V&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">値は &lt;code&gt;$Config{'osname'}&lt;/code&gt; と同じです。&lt;a href=&quot;perlrun&quot;&gt;perlrunに&lt;/a&gt;記載されている&lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;および&lt;b&gt;-V&lt;/b&gt;コマンドラインスイッチも参照してください。</target>
        </trans-unit>
        <trans-unit id="78983deb0ac0844027ede959bcbb4cd4a4216250" translate="yes" xml:space="preserve">
          <source>The value is identical to &lt;code&gt;$Config{'osname'}&lt;/code&gt;. See also &lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt; and the &lt;b&gt;-V&lt;/b&gt; command-line switch documented in &lt;a href=&quot;perlrun#-V&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">値は &lt;code&gt;$Config{'osname'}&lt;/code&gt; と同じです。&lt;a href=&quot;perlrun#-V&quot;&gt;perlrunに&lt;/a&gt;記載されている&lt;a href=&quot;config&quot;&gt;Config&lt;/a&gt;および&lt;b&gt;-V&lt;/b&gt;コマンドラインスイッチも参照してください。</target>
        </trans-unit>
        <trans-unit id="70b8122c0413fdd3eed692b348862e9493d569f3" translate="yes" xml:space="preserve">
          <source>The value of $side is</source>
          <target state="translated">サイドの値は</target>
        </trans-unit>
        <trans-unit id="31a20ded01fa49bc667d71f5d635d0f8fadc7fc6" translate="yes" xml:space="preserve">
          <source>The value of &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; on OpenVMS is &quot;VMS&quot;. To determine the architecture that you are running on refer to &lt;a href=&quot;config#archname&quot;&gt;&lt;code&gt;$Config{archname}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">OpenVMSでの&lt;a href=&quot;perlvar#%24%5EO&quot;&gt; &lt;code&gt;$^O&lt;/code&gt; &lt;/a&gt;の値は「VMS」です。実行しているアーキテクチャを確認するには、&lt;a href=&quot;config#archname&quot;&gt; &lt;code&gt;$Config{archname}&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="773190d7908d36ab9698d1cdc21dc993faf50e45" translate="yes" xml:space="preserve">
          <source>The value of &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; on VOS is &quot;vos&quot;. To determine the architecture that you are running on refer to &lt;a href=&quot;config#archname&quot;&gt;&lt;code&gt;$Config{archname}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">VOSでの&lt;a href=&quot;perlvar#%24%5EO&quot;&gt; &lt;code&gt;$^O&lt;/code&gt; &lt;/a&gt;の値は「vos」です。実行しているアーキテクチャを確認するには、&lt;a href=&quot;config#archname&quot;&gt; &lt;code&gt;$Config{archname}&lt;/code&gt; &lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="ed978648f213fc988aacb1860e0d05dc9fcc12a7" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$!&lt;/code&gt; at the time when the exception occurred.</source>
          <target state="translated">&lt;code&gt;$!&lt;/code&gt; の値！例外が発生したとき。</target>
        </trans-unit>
        <trans-unit id="495d3ee61dabdfbea0b627a5268ea9c708b5aa50" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$?&lt;/code&gt; when the context was created.</source>
          <target state="translated">&lt;code&gt;$?&lt;/code&gt; の値？コンテキストが作成されたとき。</target>
        </trans-unit>
        <trans-unit id="64ad0b97e1d614d4823576a0d2d5c3aedd5bf44c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$@&lt;/code&gt; when the context was created.</source>
          <target state="translated">コンテキストが作成されたときの &lt;code&gt;$@&lt;/code&gt; の値。</target>
        </trans-unit>
        <trans-unit id="9f3e350bc3160e2ef2f10c200798865cfdef3abe" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$Config{sitelib}&lt;/code&gt; is also determined in C code and not read from &lt;code&gt;Config.pm&lt;/code&gt; , which is not loaded.</source>
          <target state="translated">&lt;code&gt;$Config{sitelib}&lt;/code&gt; の値もCコードで決定され、ロードされていない &lt;code&gt;Config.pm&lt;/code&gt; から読み取られません。</target>
        </trans-unit>
        <trans-unit id="e9e93b8ce5897e26af26e26d476dcd12a339350a" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$Config{sitelib}&lt;/code&gt; is also determined in C code and not read from &lt;code&gt;Config.pm&lt;/code&gt;, which is not loaded.</source>
          <target state="translated">&lt;code&gt;$Config{sitelib}&lt;/code&gt; の値もCコードで決定され、ロードされていない &lt;code&gt;Config.pm&lt;/code&gt; からは読み取られません。</target>
        </trans-unit>
        <trans-unit id="5ec5b14ed87db6c409cf2d38c4b2eab23f206eae" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$^O&lt;/code&gt; on OpenVMS is &quot;VMS&quot;. To determine the architecture that you are running on refer to &lt;code&gt;$Config{'archname'}&lt;/code&gt; .</source>
          <target state="translated">OpenVMS での &lt;code&gt;$^O&lt;/code&gt; の値は &quot;VMS&quot;です。実行しているアーキテクチャーを判別するには、 &lt;code&gt;$Config{'archname'}&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="0a38163b3b1097c345c4ed53de76d7f29841da7e" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$^O&lt;/code&gt; on VOS is &quot;vos&quot;. To determine the architecture that you are running on without resorting to loading all of &lt;code&gt;%Config&lt;/code&gt; you can examine the content of the &lt;code&gt;@INC&lt;/code&gt; array like so:</source>
          <target state="translated">VOS での &lt;code&gt;$^O&lt;/code&gt; の値は &quot;vos&quot;です。すべての &lt;code&gt;%Config&lt;/code&gt; をロードせずに実行しているアーキテクチャを特定するには、 &lt;code&gt;@INC&lt;/code&gt; ように@INC配列の内容を調べます。</target>
        </trans-unit>
        <trans-unit id="0b11ba94deca518a1e2cfb4f0d2fd72a2e75493b" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$_&lt;/code&gt; when the sub returns will be stored in the filename header field.</source>
          <target state="translated">サブルーチンが戻るときの &lt;code&gt;$_&lt;/code&gt; の値は、ファイル名ヘッダーフィールドに格納されます。</target>
        </trans-unit>
        <trans-unit id="623588465c88b3488f6369fa12fbc193d14ce397" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;$_&lt;/code&gt; when the sub returns will be used as the</source>
          <target state="translated">サブが戻るときの &lt;code&gt;$_&lt;/code&gt; の値は、</target>
        </trans-unit>
        <trans-unit id="e887b08023c56383b67ea2dd8816e1569e2d83d2" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;flags&lt;/code&gt; determines the behavior when &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; does not point to a well-formed UTF-8 character. If &lt;code&gt;flags&lt;/code&gt; is 0, when a malformation is found, zero is returned and &lt;code&gt;*retlen&lt;/code&gt; is set so that (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ) is the next possible position in &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; that could begin a non-malformed character. Also, if UTF-8 warnings haven't been lexically disabled, a warning is raised.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; の値は、 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; が整形式のUTF-8文字を指していない場合の動作を決定します。場合は &lt;code&gt;flags&lt;/code&gt; 0である奇形が発見された場合、ゼロが返され、 &lt;code&gt;*retlen&lt;/code&gt; をするように設定されている（ &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ）の次の可能な位置で &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; 非不正な文字を始めることができます。また、UTF-8警告が字句的に無効にされていない場合、警告が発生します。</target>
        </trans-unit>
        <trans-unit id="2605ec2ff838d0693c21dd89f119bc12d32e8a67" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;flags&lt;/code&gt; determines the behavior when &lt;code&gt;s&lt;/code&gt; does not point to a well-formed UTF-8 character. If &lt;code&gt;flags&lt;/code&gt; is 0, encountering a malformation causes zero to be returned and &lt;code&gt;*retlen&lt;/code&gt; is set so that (&lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt;) is the next possible position in &lt;code&gt;s&lt;/code&gt; that could begin a non-malformed character. Also, if UTF-8 warnings haven't been lexically disabled, a warning is raised. Some UTF-8 input sequences may contain multiple malformations. This function tries to find every possible one in each call, so multiple warnings can be raised for the same sequence.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; の値は、 &lt;code&gt;s&lt;/code&gt; が整形式のUTF-8文字を指していない場合の動作を決定します。 &lt;code&gt;flags&lt;/code&gt; が0の場合、奇形が発生するとゼロが返され、 &lt;code&gt;*retlen&lt;/code&gt; が設定されて、（ &lt;code&gt;s&lt;/code&gt; + &lt;code&gt;*retlen&lt;/code&gt; ）が &lt;code&gt;s&lt;/code&gt; 内で奇形でない文字を開始する可能性のある次の位置になります。また、UTF-8警告が字句的に無効にされていない場合は、警告が発生します。一部のUTF-8入力シーケンスには、複数の奇形が含まれている場合があります。この関数は、各呼び出しで可能なすべてのものを見つけようとするため、同じシーケンスに対して複数の警告が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="6c4b4f2983d220858913f6137ac2e8d4d0fdf8f5" translate="yes" xml:space="preserve">
          <source>The value of a character (&lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;) is the corresponding Unicode code point.</source>
          <target state="translated">文字（ &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ）の値は、対応するUnicodeコードポイントです。</target>
        </trans-unit>
        <trans-unit id="77376c07ae757b89b1359df5120af7875474ea9a" translate="yes" xml:space="preserve">
          <source>The value of a character (&lt;code&gt;ord&lt;/code&gt;, &lt;code&gt;chr&lt;/code&gt;) is the corresponding Unicode code point.</source>
          <target state="translated">文字の値（ &lt;code&gt;ord&lt;/code&gt; 、 &lt;code&gt;chr&lt;/code&gt; ）は、対応するUnicodeコードポイントです。</target>
        </trans-unit>
        <trans-unit id="920c1e9d793047c1281d1ee5cb5fb337f4ae7f17" translate="yes" xml:space="preserve">
          <source>The value of an attribute may itself be another object. For example, instead of returning its last mod time as a number, the &lt;code&gt;File&lt;/code&gt; class could return a &lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt; object representing that value.</source>
          <target state="translated">属性の値自体が別のオブジェクトである可能性があります。たとえば、最後のmod時刻を数値として返す代わりに、 &lt;code&gt;File&lt;/code&gt; クラスはその値を表す&lt;a href=&quot;datetime&quot;&gt;DateTime&lt;/a&gt;オブジェクトを返すことができます。</target>
        </trans-unit>
        <trans-unit id="4e567ba2156b576b88f1e773ff7f64942df23743" translate="yes" xml:space="preserve">
          <source>The value of an attribute may itself be another object. For example, instead of returning its last mod time as a number, the &lt;code&gt;File&lt;/code&gt; class could return a &lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt; object representing that value.</source>
          <target state="translated">属性の値自体が別のオブジェクトである場合があります。たとえば、最後のmod時間を数値として返す代わりに、 &lt;code&gt;File&lt;/code&gt; クラスはその値を表す&lt;a href=&quot;http://search.cpan.org/perldoc/DateTime&quot;&gt;DateTime&lt;/a&gt;オブジェクトを返すことができます。</target>
        </trans-unit>
        <trans-unit id="b0e6c192bc663d6d0a358f12fd16e1e3c9bf344d" translate="yes" xml:space="preserve">
          <source>The value of any Unicode (not including Perl extensions) character property mentioned above for any single code point is available through &lt;a href=&quot;Unicode::UCD#charprop%28%29&quot;&gt;&quot;charprop()&quot; in Unicode::UCD&lt;/a&gt;. &lt;a href=&quot;Unicode::UCD#charprops_all%28%29&quot;&gt;&quot;charprops_all()&quot; in Unicode::UCD&lt;/a&gt; returns the values of all the Unicode properties for a given code point.</source>
          <target state="translated">上記のUnicode（Perl拡張機能を含まない）文字プロパティの値は&lt;a href=&quot;Unicode::UCD#charprop%28%29&quot;&gt;、Unicode :: UCDの「charprop（）」&lt;/a&gt;から入手できます。&lt;a href=&quot;Unicode::UCD#charprops_all%28%29&quot;&gt;Unicode :: UCDの「charprops_all（）」は&lt;/a&gt;、指定されたコードポイントのすべてのUnicodeプロパティの値を返します。</target>
        </trans-unit>
        <trans-unit id="4be98eb05f5630113ca4199a823f81cc002596a7" translate="yes" xml:space="preserve">
          <source>The value of any Unicode (not including Perl extensions) character property mentioned above for any single code point is available through &lt;a href=&quot;unicode/ucd#charprop()&quot;&gt;charprop() in Unicode::UCD&lt;/a&gt;. &lt;a href=&quot;unicode/ucd#charprops_all()&quot;&gt;charprops_all() in Unicode::UCD&lt;/a&gt; returns the values of all the Unicode properties for a given code point.</source>
          <target state="translated">単一のコードポイントに対する上記のUnicode（Perl拡張を含まない）文字プロパティの値は&lt;a href=&quot;unicode/ucd#charprop()&quot;&gt;、Unicode :: UCDのcharprop（）を&lt;/a&gt;介して利用できます。&lt;a href=&quot;unicode/ucd#charprops_all()&quot;&gt;Unicode :: UCDのcharprops_all（）は&lt;/a&gt;、指定されたコードポイントのすべてのUnicodeプロパティの値を返します。</target>
        </trans-unit>
        <trans-unit id="81fc623a108af3428235cbe74b6771e41c797430" translate="yes" xml:space="preserve">
          <source>The value of revision comes from the</source>
          <target state="translated">改訂の価値は</target>
        </trans-unit>
        <trans-unit id="c5c1cdba3a8acef681606512f4cdff2bb03f5d89" translate="yes" xml:space="preserve">
          <source>The value of the</source>
          <target state="translated">の値は、「1」と「2」の2種類があります。</target>
        </trans-unit>
        <trans-unit id="7754c871491afddea48233869a135f618ec6e6a4" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;...Host&lt;/code&gt; argument will be split to give both the hostname and port (or service name):</source>
          <target state="translated">&lt;code&gt;...Host&lt;/code&gt; 引数の値は、ホスト名とポート（またはサービス名）の両方を提供するために分割されます。</target>
        </trans-unit>
        <trans-unit id="96cb89717e8339762098eca6a52dfe1d75c52296" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;flags&lt;/code&gt; hint to getaddrinfo(), or the $flags parameter to getnameinfo() contains unrecognised flags.</source>
          <target state="translated">getaddrinfo（）への &lt;code&gt;flags&lt;/code&gt; ヒント、またはgetnameinfo（）への$ flagsパラメータの値には、認識されないフラグが含まれています。</target>
        </trans-unit>
        <trans-unit id="de2c00bdfe45ec53f217b88f118a8da5474d909d" translate="yes" xml:space="preserve">
          <source>The value of the ADLER32 field read must match the adler32 value of the uncompressed data actually contained in the file.</source>
          <target state="translated">読み込んだADLER32フィールドの値は、ファイルに実際に含まれている非圧縮データのADLER32値と一致しなければなりません。</target>
        </trans-unit>
        <trans-unit id="932cb4d9b33ea8ac456d8558a4c42d4644723cbc" translate="yes" xml:space="preserve">
          <source>The value of the CRC32 field read must match the crc32 value of the uncompressed data actually contained in the gzip file.</source>
          <target state="translated">読み込んだCRC32フィールドの値は、実際にgzipファイルに含まれる非圧縮データのcrc32値と一致しなければならない。</target>
        </trans-unit>
        <trans-unit id="7e9f5de9a38d28729524674757f04e1cb2068248" translate="yes" xml:space="preserve">
          <source>The value of the ISIZE fields read must match the length of the uncompressed data actually read from the file.</source>
          <target state="translated">読み込んだISIZEフィールドの値は、ファイルから実際に読み込んだ非圧縮データの長さと一致していなければなりません。</target>
        </trans-unit>
        <trans-unit id="6975eb5b4fde16e6c94a6652320983d4f157fb4c" translate="yes" xml:space="preserve">
          <source>The value of the OP's SV, if it has one, in a short human-readable format.</source>
          <target state="translated">OPのSVがあれば、その値を人間が読めるような短いフォーマットで表示しています。</target>
        </trans-unit>
        <trans-unit id="335bddece83d92e99066c5c702486489e5db8aca" translate="yes" xml:space="preserve">
          <source>The value of the function is not being passed back as the function's return value, but by changing the value of the variable that was passed into the function. You might have guessed that when you saw that the return value of round is of type &quot;void&quot;.</source>
          <target state="translated">関数の戻り値として渡されているのではなく、関数に渡された変数の値を変更することで、関数の値を返しているのです。roundの戻り値の型が「void」であることを見て察したかもしれません。</target>
        </trans-unit>
        <trans-unit id="332bfecdbc3324ed6709a244ef3af16edb8104ba" translate="yes" xml:space="preserve">
          <source>The value of the last evaluated expression of the &lt;code&gt;given&lt;/code&gt; block if no condition is true.</source>
          <target state="translated">条件が真でない場合に、 &lt;code&gt;given&lt;/code&gt; ブロックの最後に評価された式の値。</target>
        </trans-unit>
        <trans-unit id="77cf8495b50e92c33dbdf25b33ef15173c2d3541" translate="yes" xml:space="preserve">
          <source>The value of the last evaluated expression of the successful &lt;code&gt;when&lt;/code&gt; /&lt;code&gt;default&lt;/code&gt; clause, if there happens to be one.</source>
          <target state="translated">成功した &lt;code&gt;when&lt;/code&gt; / &lt;code&gt;default&lt;/code&gt; 句の最後に評価された式の値（存在する場合）。</target>
        </trans-unit>
        <trans-unit id="658f9d607f7e2f28f592626f4c387f2ebc102faa" translate="yes" xml:space="preserve">
          <source>The value of the last evaluated expression of the successful &lt;code&gt;when&lt;/code&gt;/&lt;code&gt;default&lt;/code&gt; clause, if there happens to be one.</source>
          <target state="translated">成功した &lt;code&gt;when&lt;/code&gt; / &lt;code&gt;default&lt;/code&gt; 句の最後に評価された式の値（存在する場合）。</target>
        </trans-unit>
        <trans-unit id="f55ec6306f776bf3aa6ec09d7496286d68bd8fba" translate="yes" xml:space="preserve">
          <source>The value of this expression will be TRUE if &lt;code&gt;$var&lt;/code&gt; contains that sequence of characters, and FALSE otherwise. The portion enclosed in &lt;code&gt;'/'&lt;/code&gt; characters denotes the characteristic we are looking for. We use the term</source>
          <target state="translated">この式の値は、 &lt;code&gt;$var&lt;/code&gt; にその文字シーケンスが含まれている場合はTRUEになり、含まれていない場合はFALSEになります。 &lt;code&gt;'/'&lt;/code&gt; 文字で囲まれた部分は、私たちが探している特性を示しています。私たちはこの用語を使用します</target>
        </trans-unit>
        <trans-unit id="e9dbf107286e577746464279a9f4d776045ba7e1" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; may be compared against the encrypted password from the UAF returned by the &lt;code&gt;getpw*&lt;/code&gt; functions, in order to authenticate users. If you're going to do this, remember that the encrypted password in the UAF was generated using uppercase username and password strings; you'll have to upcase the arguments to &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; to insure that you'll get the proper value:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; によって返される値は、ユーザーを認証するために、 &lt;code&gt;getpw*&lt;/code&gt; 関数によって返されるUAFからの暗号化されたパスワードと比較されます。これを行う場合、UAFの暗号化されたパスワードは、大文字のユーザー名とパスワードの文字列を使用して生成されたことに注意してください。適切な値が確実に得られるようにするには、 &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; の引数を大文字にする必要があります。</target>
        </trans-unit>
        <trans-unit id="750d57c2b28689ee366bb45cb08dd596ede16734" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; may be affected after the call, and the filehandle may be flushed. (Win32)</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; によって返された値は、呼び出し後に影響を受ける可能性があり、ファイルハンドルがフラッシュされる可能性があります。（Win32）</target>
        </trans-unit>
        <trans-unit id="b9eb02fecf7e78b1a88f2675d747749b95555376" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; is the offset in seconds from 01-JAN-1970 00:00:00 (just like the CRTL's times() routine), in order to make life easier for code coming in from the POSIX/Unix world.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; によって返される値は、01-JAN-1970 00:00:00（CRTLのtimes（）ルーチンと同様）からの秒単位のオフセットであり、POSIX / Unixの世界からのコードを簡単に処理できるようにします。</target>
        </trans-unit>
        <trans-unit id="d9cf508ed581e40b436f75a599821b5c9826f4e6" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;crypt&lt;/code&gt; may be compared against the encrypted password from the UAF returned by the &lt;code&gt;getpw*&lt;/code&gt; functions, in order to authenticate users. If you're going to do this, remember that the encrypted password in the UAF was generated using uppercase username and password strings; you'll have to upcase the arguments to &lt;code&gt;crypt&lt;/code&gt; to insure that you'll get the proper value:</source>
          <target state="translated">&lt;code&gt;crypt&lt;/code&gt; によって返される値は、ユーザーを認証するために、 &lt;code&gt;getpw*&lt;/code&gt; 関数によって返されるUAFからの暗号化されたパスワードと比較される場合があります。これを行う場合は、UAFの暗号化されたパスワードが、大文字のユーザー名とパスワードの文字列を使用して生成されたことを忘れないでください。適切な値を確実に取得するには、 &lt;code&gt;crypt&lt;/code&gt; の引数を大文字にする必要があります。</target>
        </trans-unit>
        <trans-unit id="50fe607f9117d605b4d45bd6d7204d58d2fef28d" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;time&lt;/code&gt; is the offset in seconds from 01-JAN-1970 00:00:00 (just like the CRTL's times() routine), in order to make life easier for code coming in from the POSIX/Unix world.</source>
          <target state="translated">&lt;code&gt;time&lt;/code&gt; によって返される値は、POSIX / Unixの世界から入ってくるコードの作業を楽にするために、01-JAN-1970 00:00:00からの秒単位のオフセットです（CRTLのtimes（）ルーチンと同じです）。</target>
        </trans-unit>
        <trans-unit id="dce33a69a270de7fcb08010c8a7a1e528d7b525f" translate="yes" xml:space="preserve">
          <source>The value returned by DELETE becomes the return value of the call to delete(). If you want to emulate the normal behavior of delete(), you should return whatever FETCH would have returned for this key. In this example, we have chosen instead to return a value which tells the caller whether the file was successfully deleted.</source>
          <target state="translated">DELETE で返された値が delete()の呼び出しの戻り値となります。delete()の通常の動作をエミュレートしたい場合は、このキーに対して FETCH が返すであろう値を返すべきです。この例では、ファイルが正常に削除されたかどうかをコール元に伝える値を返すことにしました。</target>
        </trans-unit>
        <trans-unit id="6bc17f7cca700d462e95542bbd03b318a3e0be44" translate="yes" xml:space="preserve">
          <source>The value returned by the</source>
          <target state="translated">が返す値は</target>
        </trans-unit>
        <trans-unit id="b1bca5853c9e5fa5adb4f19b1edc9ad3fc182540" translate="yes" xml:space="preserve">
          <source>The value returned from the</source>
          <target state="translated">から返される値は</target>
        </trans-unit>
        <trans-unit id="d7686ece8175813a2cb013172fefbbbe14b8eb04" translate="yes" xml:space="preserve">
          <source>The value returned is the new-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;&quot;Old-style versus new-style block names&quot;&lt;/a&gt;).</source>
          <target state="translated">返される値は新しいスタイルです（&lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;「古いスタイルと新しいスタイルのブロック名」を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="90d9e575a1b77ab1385aca4b943feac671ed7f01" translate="yes" xml:space="preserve">
          <source>The value returned is the new-style (see &lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;Old-style versus new-style block names&lt;/a&gt;).</source>
          <target state="translated">返される値は新しいスタイルです（&lt;a href=&quot;#Old-style-versus-new-style-block-names&quot;&gt;古いスタイルと新しいスタイルのブロック名を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="c04520f682b85fb43c817253d00adbc0066c3e0a" translate="yes" xml:space="preserve">
          <source>The value returned is the scalar itself, if the argument is a scalar, or a reference, if the argument is a hash, array or subroutine.</source>
          <target state="translated">返される値は、引数がスカラであればスカラそのもの、引数がハッシュ、配列、サブルーチンであれば参照です。</target>
        </trans-unit>
        <trans-unit id="942e5b04dedd3b9d9ca5012565213fea51195584" translate="yes" xml:space="preserve">
          <source>The value returned should correspond to the new text to use in its place If the empty string is returned or an undefined value is returned, then the given &lt;code&gt;$text&lt;/code&gt; is ignored (not processed).</source>
          <target state="translated">返される値は、その場所で使用する新しいテキストに対応する必要があります。空の文字列が返されるか、未定義の値が返される場合、指定された &lt;code&gt;$text&lt;/code&gt; は無視されます（処理されません）。</target>
        </trans-unit>
        <trans-unit id="8dccf8bfa93428dffce75a953ae318dc76ebcb1f" translate="yes" xml:space="preserve">
          <source>The value returned should correspond to the new text to use in its place. If the empty string or an undefined value is returned then no further processing will be performed for this line.</source>
          <target state="translated">返 さ れた値は、 その場所で使用す る 新 し いテ キ ス ト に対応 し てい る 必要があ り ます。空の文字列や未定義の値が返された場合は、この行に対してそれ以上の処理は行われません。</target>
        </trans-unit>
        <trans-unit id="55279d7373f25daebc72a715903f6a4795228bf8" translate="yes" xml:space="preserve">
          <source>The value returned will be true if the &lt;code&gt;$paragraph&lt;/code&gt; and the rest of the text in the same section as &lt;code&gt;$paragraph&lt;/code&gt; should be selected (included) for processing; otherwise a false value is returned.</source>
          <target state="translated">場合、戻り値はtrueになります &lt;code&gt;$paragraph&lt;/code&gt; と同じセクション内のテキストの残り &lt;code&gt;$paragraph&lt;/code&gt; 処理のために選択した（同梱）されなければなりません。それ以外の場合は、偽の値が返されます。</target>
        </trans-unit>
        <trans-unit id="10aaf64078984131d35f43803e32214eb7af6f36" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. It is invoked just before leaving the currently processed directory. It is called in void context with no arguments. The name of the current directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt; . This hook is handy for summarizing a directory, such as calculating its disk usage. When</source>
          <target state="translated">値はコード参照でなければなりません。現在処理されているディレクトリを離れる直前に呼び出されます。引数なしでvoidコンテキストで呼び出されます。現在のディレクトリの名前は &lt;code&gt;$File::Find::dir&lt;/code&gt; ます。このフックは、ディスク使用量の計算など、ディレクトリを要約するのに便利です。いつ</target>
        </trans-unit>
        <trans-unit id="704f4eb234b60fc2ba78db6c9fbae91192095f92" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. It is invoked just before leaving the currently processed directory. It is called in void context with no arguments. The name of the current directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt;. This hook is handy for summarizing a directory, such as calculating its disk usage. When</source>
          <target state="translated">値はコード参照である必要があります。現在処理されているディレクトリを離れる直前に呼び出されます。これは、引数なしでvoidコンテキストで呼び出されます。現在のディレクトリの名前は &lt;code&gt;$File::Find::dir&lt;/code&gt; ます。このフックは、ディスク使用量の計算など、ディレクトリを要約するのに便利です。いつ</target>
        </trans-unit>
        <trans-unit id="f1ae9d02429326a11943298c08065d301c422900" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;&quot;The wanted function&quot;&lt;/a&gt; below. The &lt;code&gt;&amp;amp;wanted&lt;/code&gt; subroutine is mandatory.</source>
          <target state="translated">値はコード参照である必要があります。このコードリファレンスについては、以下の&lt;a href=&quot;#The-wanted-function&quot;&gt;「必要な関数」で&lt;/a&gt;説明しています。 &lt;code&gt;&amp;amp;wanted&lt;/code&gt; サブルーチンは必須です。</target>
        </trans-unit>
        <trans-unit id="ddbdffc9717f2bba2ebf5303cd71401d0bf2a249" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is described in &lt;a href=&quot;#The-wanted-function&quot;&gt;The wanted function&lt;/a&gt; below. The &lt;code&gt;&amp;amp;wanted&lt;/code&gt; subroutine is mandatory.</source>
          <target state="translated">値はコード参照でなければなりません。このコード参照は、以下の&lt;a href=&quot;#The-wanted-function&quot;&gt;「必要な関数」で&lt;/a&gt;説明されています。 &lt;code&gt;&amp;amp;wanted&lt;/code&gt; サブルーチンは必須です。</target>
        </trans-unit>
        <trans-unit id="444cd91bd48610204aa4348a8cd314eec59c4347" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is used to preprocess the current directory. The name of the currently processed directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt; . Your preprocessing function is called after &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt;, but before the loop that calls the &lt;code&gt;wanted()&lt;/code&gt; function. It is called with a list of strings (actually file/directory names) and is expected to return a list of strings. The code can be used to sort the file/directory names alphabetically, numerically, or to filter out directory entries based on their name alone. When</source>
          <target state="translated">値はコード参照でなければなりません。このコード参照は、現在のディレクトリを前処理するために使用されます。現在処理されているディレクトリの名前は &lt;code&gt;$File::Find::dir&lt;/code&gt; ます。前処理関数は、 &lt;code&gt;&lt;a href=&quot;../functions/readdir&quot;&gt;readdir()&lt;/a&gt;&lt;/code&gt; の後で、 &lt;code&gt;wanted()&lt;/code&gt; 関数を呼び出すループの前に呼び出されます。文字列（実際にはファイル/ディレクトリ名）のリストで呼び出され、文字列のリストを返すことが期待されています。このコードを使用して、ファイル/ディレクトリ名をアルファベット順、数値順に並べ替えたり、名前だけに基づいてディレクトリエントリを除外したりできます。いつ</target>
        </trans-unit>
        <trans-unit id="f55a9d5538f4afdc7e60c610536ec48e43299b30" translate="yes" xml:space="preserve">
          <source>The value should be a code reference. This code reference is used to preprocess the current directory. The name of the currently processed directory is in &lt;code&gt;$File::Find::dir&lt;/code&gt;. Your preprocessing function is called after &lt;code&gt;readdir()&lt;/code&gt;, but before the loop that calls the &lt;code&gt;wanted()&lt;/code&gt; function. It is called with a list of strings (actually file/directory names) and is expected to return a list of strings. The code can be used to sort the file/directory names alphabetically, numerically, or to filter out directory entries based on their name alone. When</source>
          <target state="translated">値はコード参照である必要があります。このコード参照は、現在のディレクトリを前処理するために使用されます。現在処理されているディレクトリの名前は &lt;code&gt;$File::Find::dir&lt;/code&gt; ます。前処理関数は、 &lt;code&gt;readdir()&lt;/code&gt; の後、 &lt;code&gt;wanted()&lt;/code&gt; 関数を呼び出すループの前に呼び出されます。文字列（実際にはファイル/ディレクトリ名）のリストで呼び出され、文字列のリストを返すことが期待されています。このコードを使用して、ファイル/ディレクトリ名をアルファベット順、数値順に並べ替えたり、名前のみに基づいてディレクトリエントリを除外したりできます。いつ</target>
        </trans-unit>
        <trans-unit id="4b8d0d31a50d605febd9456f0c05a144d0e549cc" translate="yes" xml:space="preserve">
          <source>The value should be the complete TAP output.</source>
          <target state="translated">値は完全なTAP出力でなければなりません。</target>
        </trans-unit>
        <trans-unit id="1236d86898ff88a6ba5efcf381d222ec31979c55" translate="yes" xml:space="preserve">
          <source>The value stack stores individual perl scalar values as temporaries between expressions. Some perl expressions operate on entire lists; for that purpose we need to know where on the stack each list begins. This is the purpose of the mark stack.</source>
          <target state="translated">値スタックは、Perl のスカラ値を式の間の一時的なものとして保存します。perl の式の中にはリスト全体を操作するものがあります。そのためには、各リストがスタックのどこから始まるのかを知る必要があります。これがマークスタックの目的です。</target>
        </trans-unit>
        <trans-unit id="977d1c1fec14dab01803e1202ad5b70915c99932" translate="yes" xml:space="preserve">
          <source>The value supplied with &lt;code&gt;-Comment&lt;/code&gt; option can contain any character except NULL.</source>
          <target state="translated">&lt;code&gt;-Comment&lt;/code&gt; オプションで指定する値には、NULL以外の任意の文字を含めることができます。</target>
        </trans-unit>
        <trans-unit id="5a33beea90e0c4b3cd6d3aa1b159094d2037e800" translate="yes" xml:space="preserve">
          <source>The value supplied with &lt;code&gt;-Name&lt;/code&gt; option can contain any character except NULL.</source>
          <target state="translated">&lt;code&gt;-Name&lt;/code&gt; オプションで指定する値には、NULL以外の任意の文字を含めることができます。</target>
        </trans-unit>
        <trans-unit id="f1aeb63cc4cb0e101586c3105fecbdbf9caca8c2" translate="yes" xml:space="preserve">
          <source>The value supplied with the &lt;code&gt;Comment&lt;/code&gt; option can only contain ISO 8859-1 characters plus line-feed.</source>
          <target state="translated">&lt;code&gt;Comment&lt;/code&gt; オプションで提供される値には、ISO 8859-1文字と改行のみを含めることができます。</target>
        </trans-unit>
        <trans-unit id="56d224f65d33c0660d7f4661847cc1e8f860019d" translate="yes" xml:space="preserve">
          <source>The value supplied with the &lt;code&gt;Name&lt;/code&gt; option can only contain ISO 8859-1 characters.</source>
          <target state="translated">[ &lt;code&gt;Name&lt;/code&gt; ]オプションで提供される値には、ISO 8859-1文字のみを含めることができます。</target>
        </trans-unit>
        <trans-unit id="250b7ab858db3f7115ff282b675a91ac8e641be6" translate="yes" xml:space="preserve">
          <source>The value(s) returned by the failed subroutine. When the subroutine was called in a list context, this will always be a reference to an array containing the results. When the subroutine was called in a scalar context, this will be the actual scalar returned.</source>
          <target state="translated">失敗したサブルーチンが返した値。サブルーチンがリストコンテキストで呼び出された場合、これは常に結果を含む配列への参照となります。サブルーチンがスカラコンテキストで呼び出された場合、これは実際のスカラが返されます。</target>
        </trans-unit>
        <trans-unit id="5341e40485577e6df05a609244175f85c79fb195" translate="yes" xml:space="preserve">
          <source>The values are specified on the following format line in the same order as the picture fields. The expressions providing the values must be separated by commas. They are all evaluated in a list context before the line is processed, so a single list expression could produce multiple list elements. The expressions may be spread out to more than one line if enclosed in braces. If so, the opening brace must be the first token on the first line. If an expression evaluates to a number with a decimal part, and if the corresponding picture specifies that the decimal part should appear in the output (that is, any picture except multiple &quot;#&quot; characters &lt;b&gt;without&lt;/b&gt; an embedded &quot;.&quot;), the character used for the decimal point is determined by the current LC_NUMERIC locale if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect. This means that, if, for example, the run-time environment happens to specify a German locale, &quot;,&quot; will be used instead of the default &quot;.&quot;. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;#WARNINGS&quot;&gt;WARNINGS&lt;/a&gt; for more information.</source>
          <target state="translated">値は、画像フィールドと同じ順序で次のフォーマット行に指定されます。値を提供する式は、コンマで区切る必要があります。これらはすべて、行が処理される前にリストコンテキストで評価されるため、単一のリスト式で複数のリスト要素を生成できます。中括弧で囲まれている場合、式は複数行に広げることができます。その場合、左中括弧は最初の行の最初のトークンでなければなりません。式が小数部を含む数値に評価され、対応する画像が小数部を出力に表示するように指定している場合（つまり、「。」が埋め込まれてい&lt;b&gt;ない&lt;/b&gt;複数の「＃」文字&lt;b&gt;を&lt;/b&gt;除く画像）、使用されている文字小数点の場合 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ロケールを使用する場合、現在のLC_NUMERICロケールによって決定されます有効です。これは、たとえば、ランタイム環境がドイツ語のロケールを指定した場合、デフォルトの「。」の代わりに「、」が使用されることを意味します。詳細については、&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;と&lt;a href=&quot;#WARNINGS&quot;&gt;警告&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c72d7d9a1485bc34599e1ebeb09b10805e996267" translate="yes" xml:space="preserve">
          <source>The values are specified on the following format line in the same order as the picture fields. The expressions providing the values must be separated by commas. They are all evaluated in a list context before the line is processed, so a single list expression could produce multiple list elements. The expressions may be spread out to more than one line if enclosed in braces. If so, the opening brace must be the first token on the first line. If an expression evaluates to a number with a decimal part, and if the corresponding picture specifies that the decimal part should appear in the output (that is, any picture except multiple &quot;#&quot; characters &lt;b&gt;without&lt;/b&gt; an embedded &quot;.&quot;), the character used for the decimal point is determined by the current LC_NUMERIC locale if &lt;code&gt;use locale&lt;/code&gt; is in effect. This means that, if, for example, the run-time environment happens to specify a German locale, &quot;,&quot; will be used instead of the default &quot;.&quot;. See &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt; and &lt;a href=&quot;#WARNINGS&quot;&gt;&quot;WARNINGS&quot;&lt;/a&gt; for more information.</source>
          <target state="translated">値は、画像フィールドと同じ順序で次のフォーマット行に指定されます。値を提供する式は、コンマで区切る必要があります。これらはすべて、行が処理される前にリストコンテキストで評価されるため、単一のリスト式で複数のリスト要素を生成できます。中括弧で囲むと、式が複数行に広がる場合があります。その場合、開始中括弧は最初の行の最初のトークンである必要があります。式が小数部のある数値に評価され、対応する画像で小数部が出力に表示されるように指定されている場合（つまり、「。」が埋め込まれてい&lt;b&gt;ない&lt;/b&gt;複数の「＃」文字&lt;b&gt;を&lt;/b&gt;除くすべての画像）、使用される文字小数点を &lt;code&gt;use locale&lt;/code&gt; 場合は、現在のLC_NUMERICロケールによって決定されます。有効です。これは、たとえば、ランタイム環境でドイツ語ロケールが指定された場合、デフォルトの「。」の代わりに「、」が使用されることを意味します。詳細については、&lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;および&lt;a href=&quot;#WARNINGS&quot;&gt;「警告」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="dbf008b9072b1cecb517f8aeffecd9422e5c3c63" translate="yes" xml:space="preserve">
          <source>The values of &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; on some of these platforms include:</source>
          <target state="translated">これらのプラットフォームの一部での&lt;a href=&quot;perlvar#%24%5EO&quot;&gt; &lt;code&gt;$^O&lt;/code&gt; &lt;/a&gt;の値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="bcd5bfa6286ea39c4bd9487ae2b5176bb3be48be" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;$^O&lt;/code&gt; on some of these platforms includes:</source>
          <target state="translated">これらのプラットフォームの一部での &lt;code&gt;$^O&lt;/code&gt; の値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="540bf16e20569214e1b31e52cdcbc4ee480d311c" translate="yes" xml:space="preserve">
          <source>The values pushed onto the return stack of the XSUB are actually mortal SV's. They are made mortal so that once the values are copied by the calling program, the SV's that held the returned values can be deallocated. If they were not mortal, then they would continue to exist after the XSUB routine returned, but would not be accessible. This is a memory leak.</source>
          <target state="translated">XSUB のリターンスタックにプッシュされた値は、実際には致命的な SV です。呼び出し元のプログラムによって値がコピーされると、返された値を保持していた SV が解放されるように、これらの値は死すべき状態になっています。もしそれらが死滅していなければ、XSUB ルーチンが返された後も存在し続けますが、アクセスはできません。これはメモリリークです。</target>
        </trans-unit>
        <trans-unit id="e474878aa7db7e96c4629326d93b845326ef064e" translate="yes" xml:space="preserve">
          <source>The values stored in config.sh may be either single-quoted or double-quoted. Double-quoted strings are handy for those cases where you need to include escape sequences in the strings. To avoid runtime variable interpolation, any &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; characters are replaced by &lt;code&gt;\$&lt;/code&gt; and &lt;code&gt;\@&lt;/code&gt; , respectively. This isn't foolproof, of course, so don't embed &lt;code&gt;\$&lt;/code&gt; or &lt;code&gt;\@&lt;/code&gt; in double-quoted strings unless you're willing to deal with the consequences. (The slashes will end up escaped and the &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; will trigger variable interpolation)</source>
          <target state="translated">config.shに格納されている値は、単一引用符または二重引用符のどちらかです。二重引用符で囲まれた文字列は、文字列にエスケープシーケンスを含める必要がある場合に便利です。ランタイム変数の補間を回避するために、 &lt;code&gt;$&lt;/code&gt; および &lt;code&gt;@&lt;/code&gt; 文字はそれぞれ &lt;code&gt;\$&lt;/code&gt; および &lt;code&gt;\@&lt;/code&gt; に置き換えられます。もちろん、これは絶対に確実なことではないので、結果に対処する用意がない限り、二重引用符で囲まれた文字列に &lt;code&gt;\$&lt;/code&gt; または &lt;code&gt;\@&lt;/code&gt; 埋め込まないでください。 （スラッシュはエスケープされ、 &lt;code&gt;$&lt;/code&gt; または &lt;code&gt;@&lt;/code&gt; は変数補間をトリガーします）</target>
        </trans-unit>
        <trans-unit id="2fb3e0a0c43753411747016bb8289e7cafa37f14" translate="yes" xml:space="preserve">
          <source>The values stored in config.sh may be either single-quoted or double-quoted. Double-quoted strings are handy for those cases where you need to include escape sequences in the strings. To avoid runtime variable interpolation, any &lt;code&gt;$&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; characters are replaced by &lt;code&gt;\$&lt;/code&gt; and &lt;code&gt;\@&lt;/code&gt;, respectively. This isn't foolproof, of course, so don't embed &lt;code&gt;\$&lt;/code&gt; or &lt;code&gt;\@&lt;/code&gt; in double-quoted strings unless you're willing to deal with the consequences. (The slashes will end up escaped and the &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; will trigger variable interpolation)</source>
          <target state="translated">config.shに格納されている値は、一重引用符または二重引用符で囲むことができます。二重引用符で囲まれた文字列は、文字列にエスケープシーケンスを含める必要がある場合に便利です。ランタイム変数の補間を回避するために、 &lt;code&gt;$&lt;/code&gt; 文字と &lt;code&gt;@&lt;/code&gt; 文字はそれぞれ &lt;code&gt;\$&lt;/code&gt; と &lt;code&gt;\@&lt;/code&gt; に置き換えられます。もちろん、これは絶対確実ではないため、結果に対処する意思がない限り、二重引用符で囲まれた文字列に &lt;code&gt;\$&lt;/code&gt; または &lt;code&gt;\@&lt;/code&gt; 埋め込まないでください。 （スラッシュはエスケープされ、 &lt;code&gt;$&lt;/code&gt; または &lt;code&gt;@&lt;/code&gt; は変数補間をトリガーします）</target>
        </trans-unit>
        <trans-unit id="c23b5412a89e9982acfd046a606aac6df7b125a8" translate="yes" xml:space="preserve">
          <source>The values stored in the hashes above are mostly the direct equivalent of their C counterpart. Like their C counterparts, all are set to a default values - that means you don't have to set</source>
          <target state="translated">上記のハッシュに格納されている値は、ほとんどがC言語の対応するものと直接等価です。それらの C の対応するものと同様に、すべての値はデフォルト値に設定されています。</target>
        </trans-unit>
        <trans-unit id="9e6700989ab1dbf25d28d4fd1b763593cc3c720f" translate="yes" xml:space="preserve">
          <source>The values supplied with the &lt;code&gt;-Name&lt;/code&gt; and &lt;code&gt;-Comment&lt;/code&gt; options can contain multiple embedded nulls. The string written to the gzip header will consist of the characters up to, but not including, the first embedded NULL.</source>
          <target state="translated">&lt;code&gt;-Name&lt;/code&gt; および &lt;code&gt;-Comment&lt;/code&gt; オプションで提供される値には、複数の埋め込まれたnullを含めることができます。gzipヘッダーに書き込まれる文字列は、最初の埋め込まれたNULLまでの文字で構成されます。</target>
        </trans-unit>
        <trans-unit id="f4d39e5aa9ce36eff93868e0e7af4d9b6a02d8ec" translate="yes" xml:space="preserve">
          <source>The values supplied with the &lt;code&gt;-Name&lt;/code&gt; and &lt;code&gt;-Comment&lt;/code&gt; options cannot contain multiple embedded nulls.</source>
          <target state="translated">&lt;code&gt;-Name&lt;/code&gt; および &lt;code&gt;-Comment&lt;/code&gt; オプションで提供される値には、複数のヌルを埋め込むことはできません。</target>
        </trans-unit>
        <trans-unit id="6344a1b12727e711425a7cd0809233875bc47e54" translate="yes" xml:space="preserve">
          <source>The values to be compared are always passed by reference and should not be modified.</source>
          <target state="translated">比較される値は常に参照で渡され、変更されるべきではありません。</target>
        </trans-unit>
        <trans-unit id="0a3bdf6ba268c4d17126cd579eaa00987525d1a3" translate="yes" xml:space="preserve">
          <source>The variable $ref may have referred to the subroutine &lt;code&gt;fred&lt;/code&gt; whenever the call to &lt;code&gt;SaveSub1&lt;/code&gt; was made but by the time &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called it now holds the number &lt;code&gt;47&lt;/code&gt; . Because we saved only a pointer to the original SV in &lt;code&gt;SaveSub1&lt;/code&gt; , any changes to $ref will be tracked by the pointer &lt;code&gt;rememberSub&lt;/code&gt; . This means that whenever &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called, it will attempt to execute the code which is referenced by the SV* &lt;code&gt;rememberSub&lt;/code&gt; . In this case though, it now refers to the integer &lt;code&gt;47&lt;/code&gt; , so expect Perl to complain loudly.</source>
          <target state="translated">変数$ refは、 &lt;code&gt;SaveSub1&lt;/code&gt; への呼び出しが行われたときはいつでもサブルーチン &lt;code&gt;fred&lt;/code&gt; を参照している可能性がありますが、 &lt;code&gt;CallSavedSub1&lt;/code&gt; が呼び出されるときまでに、数値 &lt;code&gt;47&lt;/code&gt; を保持しています。 &lt;code&gt;SaveSub1&lt;/code&gt; で元のSVへのポインターのみを保存したため、$ refへの変更はすべて、ポインター &lt;code&gt;rememberSub&lt;/code&gt; によって追跡されます。これは、 &lt;code&gt;CallSavedSub1&lt;/code&gt; が呼び出されるたびに、SV * &lt;code&gt;rememberSub&lt;/code&gt; によって参照されるコードを実行しようとすることを意味します。ただし、この場合は整数 &lt;code&gt;47&lt;/code&gt; を参照するようになっているので、Perlが大きな不満を言うはずです。</target>
        </trans-unit>
        <trans-unit id="b062bdbf031860e708b29efdacf136fb5d1f0b68" translate="yes" xml:space="preserve">
          <source>The variable $ref may have referred to the subroutine &lt;code&gt;fred&lt;/code&gt; whenever the call to &lt;code&gt;SaveSub1&lt;/code&gt; was made but by the time &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called it now holds the number &lt;code&gt;47&lt;/code&gt;. Because we saved only a pointer to the original SV in &lt;code&gt;SaveSub1&lt;/code&gt;, any changes to $ref will be tracked by the pointer &lt;code&gt;rememberSub&lt;/code&gt;. This means that whenever &lt;code&gt;CallSavedSub1&lt;/code&gt; gets called, it will attempt to execute the code which is referenced by the SV* &lt;code&gt;rememberSub&lt;/code&gt;. In this case though, it now refers to the integer &lt;code&gt;47&lt;/code&gt;, so expect Perl to complain loudly.</source>
          <target state="translated">変数$ refは、 &lt;code&gt;SaveSub1&lt;/code&gt; が呼び出されるたびにサブルーチン &lt;code&gt;fred&lt;/code&gt; を参照していた可能性がありますが、 &lt;code&gt;CallSavedSub1&lt;/code&gt; が呼び出されるまでに、番号 &lt;code&gt;47&lt;/code&gt; が保持されます。 &lt;code&gt;SaveSub1&lt;/code&gt; には元のSVへのポインターのみを保存したため、$ refへの変更はポインター &lt;code&gt;rememberSub&lt;/code&gt; によって追跡されます。これは、 &lt;code&gt;CallSavedSub1&lt;/code&gt; が呼び出されるたびに、SV * &lt;code&gt;rememberSub&lt;/code&gt; によって参照されるコードを実行しようとすることを意味します。ただし、この場合は整数 &lt;code&gt;47&lt;/code&gt; を参照するようになったため、Perlが大声で文句を言うことを期待してください。</target>
        </trans-unit>
        <trans-unit id="ad1d8279ad869db1c2929300f40e329172cf94dc" translate="yes" xml:space="preserve">
          <source>The variable contains the symbols defined by the C compiler alone. The symbols defined by cpp or by cc when it calls cpp are not in this list, see cppsymbols and cppccsymbols. The list is a space-separated list of symbol=value tokens.</source>
          <target state="translated">この変数には、Cコンパイラだけで定義されたシンボルが含まれています。cpp または cc が cpp を呼び出したときに cpp によって定義されたシンボルはこのリストにはありません。このリストは、シンボル=値のトークンをスペースで区切ってリスト化したものです。</target>
        </trans-unit>
        <trans-unit id="501db733d2ef38c039a965292ca77f71bc56d687" translate="yes" xml:space="preserve">
          <source>The variable contains the symbols defined by the C compiler when it calls cpp. The symbols defined by the cc alone or cpp alone are not in this list, see ccsymbols and cppsymbols. The list is a space-separated list of symbol=value tokens.</source>
          <target state="translated">この変数には、Cコンパイラがcppを呼び出すときに定義されるシンボルが含まれています。cc単独またはcpp単独で定義されたシンボルはこのリストには含まれていません、ccsymbolsおよびcppsymbolsを参照してください。このリストは、シンボル=値のトークンをスペースで区切ってリスト化したものです。</target>
        </trans-unit>
        <trans-unit id="00b4b60fa439030036a66d7ff80e60844c78536a" translate="yes" xml:space="preserve">
          <source>The variable contains the symbols defined by the C preprocessor alone. The symbols defined by cc or by cc when it calls cpp are not in this list, see ccsymbols and cppccsymbols. The list is a space-separated list of symbol=value tokens.</source>
          <target state="translated">この変数には、Cプリプロセッサだけで定義されたシンボルが含まれています。cc または cc が cpp を呼び出すときに cc によって定義されたシンボルは、このリストには含まれていません。このリストは、シンボル=値のトークンをスペースで区切ってリスト化したものです。</target>
        </trans-unit>
        <trans-unit id="83d3f8e3698f4e666192e80e4c4c129382375649" translate="yes" xml:space="preserve">
          <source>The variables &lt;code&gt;$@&lt;/code&gt; , &lt;code&gt;$!&lt;/code&gt; , &lt;code&gt;$^E&lt;/code&gt; , and &lt;code&gt;$?&lt;/code&gt; contain information about different types of error conditions that may appear during execution of a Perl program. The variables are shown ordered by the &quot;distance&quot; between the subsystem which reported the error and the Perl process. They correspond to errors detected by the Perl interpreter, C library, operating system, or an external program, respectively.</source>
          <target state="translated">変数 &lt;code&gt;$@&lt;/code&gt; 、 &lt;code&gt;$!&lt;/code&gt; 、 &lt;code&gt;$^E&lt;/code&gt; 、および &lt;code&gt;$?&lt;/code&gt; Perlプログラムの実行中に発生する可能性のあるさまざまなタイプのエラー条件に関する情報が含まれています。変数は、エラーを報告したサブシステムとPerlプロセスの間の「距離」の順に表示されます。これらはそれぞれ、Perlインタープリター、Cライブラリ、オペレーティングシステム、または外部プログラムによって検出されたエラーに対応しています。</target>
        </trans-unit>
        <trans-unit id="b727dbcbaa890861d8b1f725dd2b28a4ab07c49e" translate="yes" xml:space="preserve">
          <source>The variables &lt;code&gt;$@&lt;/code&gt;, &lt;code&gt;$!&lt;/code&gt;, &lt;code&gt;$^E&lt;/code&gt;, and &lt;code&gt;$?&lt;/code&gt; contain information about different types of error conditions that may appear during execution of a Perl program. The variables are shown ordered by the &quot;distance&quot; between the subsystem which reported the error and the Perl process. They correspond to errors detected by the Perl interpreter, C library, operating system, or an external program, respectively.</source>
          <target state="translated">変数 &lt;code&gt;$@&lt;/code&gt; 、 &lt;code&gt;$!&lt;/code&gt; 、 &lt;code&gt;$^E&lt;/code&gt; 、および &lt;code&gt;$?&lt;/code&gt; Perlプログラムの実行中に表示される可能性のあるさまざまなタイプのエラー状態に関する情報が含まれています。変数は、エラーを報告したサブシステムとPerlプロセスの間の「距離」順に表示されます。これらは、Perlインタプリタ、Cライブラリ、オペレーティングシステム、または外部プログラムによってそれぞれ検出されたエラーに対応します。</target>
        </trans-unit>
        <trans-unit id="d61a4e2ec2fd6a9d823c4ff48f24791a3afc0a43" translate="yes" xml:space="preserve">
          <source>The variables are thousands of characters long and you know that they don't change, and you need to wring out the last little bit of speed by having Perl skip testing for that. (There is a maintenance penalty for doing this, as mentioning &lt;code&gt;/o&lt;/code&gt; constitutes a promise that you won't change the variables in the pattern. If you do change them, Perl won't even notice.)</source>
          <target state="translated">変数は数千文字の長さであり、それらは変更されないことがわかっています。Perlにテストをスキップさせることで、最後の少しの速度を絞る必要があります。（ &lt;code&gt;/o&lt;/code&gt; に言及することは、パターン内の変数を変更しないという約束を構成するため、これを行うと保守ペナルティがあります。それらを変更しても、Perlは気付かないでしょう。）</target>
        </trans-unit>
        <trans-unit id="11544c219d80b67a63dc9e0a8e442712e549045b" translate="yes" xml:space="preserve">
          <source>The variables&amp;mdash;such as &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; , and &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%&amp;ndash; &lt;/code&gt; &amp;mdash;that hold the text remembered in a pattern match. See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;$1&lt;/code&gt; と &lt;code&gt;$2&lt;/code&gt; 、 &lt;code&gt;%+&lt;/code&gt; と &lt;code&gt;%&amp;ndash; &lt;/code&gt; などの変数は、パターンマッチで記憶されたテキストを保持します。ラクダの第5章「パターンマッチング」を参照してください。</target>
        </trans-unit>
        <trans-unit id="d984e8b7b660f5c99b516a5829ac59bafa50592e" translate="yes" xml:space="preserve">
          <source>The variables&amp;mdash;such as &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt;, and &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%&amp;ndash; &lt;/code&gt;&amp;mdash;that hold the text remembered in a pattern match. See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">パターンマッチで記憶されたテキストを保持する変数（ &lt;code&gt;$1&lt;/code&gt; と &lt;code&gt;$2&lt;/code&gt; 、 &lt;code&gt;%+&lt;/code&gt; と &lt;code&gt;%&amp;ndash; &lt;/code&gt; など）。キャメルの第5章「パターンマッチング」を参照してください。</target>
        </trans-unit>
        <trans-unit id="01a6309a6878656688c2b0908ac3992f68dc7d19" translate="yes" xml:space="preserve">
          <source>The variant called by &lt;a href=&quot;#ack&quot;&gt;&quot;ack&quot;&lt;/a&gt; with the &quot;syn&quot; protocol and &lt;code&gt;$syn_forking&lt;/code&gt; enabled.</source>
          <target state="translated">「syn」プロトコルと &lt;code&gt;$syn_forking&lt;/code&gt; 有効になっている&lt;a href=&quot;#ack&quot;&gt;「ack」&lt;/a&gt;によって呼び出されるバリアント。</target>
        </trans-unit>
        <trans-unit id="50b54417d53e0d1cfe584f4211726c367ffae98a" translate="yes" xml:space="preserve">
          <source>The variant of OS2::_control87() with default values good for handling exception mask: if no &lt;code&gt;mask&lt;/code&gt; , uses exception mask part of &lt;code&gt;new&lt;/code&gt; only. If no &lt;code&gt;new&lt;/code&gt; , disables all the floating point exceptions.</source>
          <target state="translated">例外マスクを処理するためのデフォルト値の良いとOS2 :: _ control87（）の変種は：いいえ場合は &lt;code&gt;mask&lt;/code&gt; の例外マスク一部使用する &lt;code&gt;new&lt;/code&gt; だけを。 &lt;code&gt;new&lt;/code&gt; がない場合、すべての浮動小数点例外を無効にします。</target>
        </trans-unit>
        <trans-unit id="949da3d76c7f29272d20c982b210c531dcfc20d4" translate="yes" xml:space="preserve">
          <source>The variant of OS2::_control87() with default values good for handling exception mask: if no &lt;code&gt;mask&lt;/code&gt;, uses exception mask part of &lt;code&gt;new&lt;/code&gt; only. If no &lt;code&gt;new&lt;/code&gt;, disables all the floating point exceptions.</source>
          <target state="translated">例外マスクの処理に適したデフォルト値を持つOS2 :: _ control87（）のバリアント： &lt;code&gt;mask&lt;/code&gt; ない場合は、 &lt;code&gt;new&lt;/code&gt; の例外マスク部分のみを使用します。 &lt;code&gt;new&lt;/code&gt; がない場合は、すべての浮動小数点例外を無効にします。</target>
        </trans-unit>
        <trans-unit id="307e90e437dd1da42b4c1389ea6c9b26886479f7" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;extract_...&lt;/code&gt; subroutines may be used to extract a delimited substring, possibly after skipping a specified prefix string. By default, that prefix is optional whitespace (&lt;code&gt;/\s*/&lt;/code&gt; ), but you can change it to whatever you wish (see below).</source>
          <target state="translated">さまざまな &lt;code&gt;extract_...&lt;/code&gt; サブルーチンを使用して、区切られた部分文字列を抽出できます。指定されたプレフィックス文字列をスキップした後などです。デフォルトでは、そのプレフィックスはオプションの空白（ &lt;code&gt;/\s*/&lt;/code&gt; ）ですが、好きなように変更できます（以下を参照）。</target>
        </trans-unit>
        <trans-unit id="53ae99cb4c2e82006930873ef81a93aa0cb472f5" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;extract_...&lt;/code&gt; subroutines may be used to extract a delimited substring, possibly after skipping a specified prefix string. By default, that prefix is optional whitespace (&lt;code&gt;/\s*/&lt;/code&gt;), but you can change it to whatever you wish (see below).</source>
          <target state="translated">さまざまな &lt;code&gt;extract_...&lt;/code&gt; サブルーチンを使用して、指定されたプレフィックス文字列をスキップした後、区切られた部分文字列を抽出できます。デフォルトでは、そのプレフィックスはオプションの空白（ &lt;code&gt;/\s*/&lt;/code&gt; ）ですが、任意の名前に変更できます（以下を参照）。</target>
        </trans-unit>
        <trans-unit id="6c592ef06c081d09dc8157d9f5c4a05ab70da35e" translate="yes" xml:space="preserve">
          <source>The various MSWin32 Perl's can distinguish the OS they are running on via the value of the fifth element of the list returned from &lt;a href=&quot;win32#Win32%3A%3AGetOSVersion%28%29&quot;&gt;&lt;code&gt;Win32::GetOSVersion()&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">さまざまなMSWin32Perlは、&lt;a href=&quot;win32#Win32%3A%3AGetOSVersion%28%29&quot;&gt; &lt;code&gt;Win32::GetOSVersion()&lt;/code&gt; &lt;/a&gt;から返されるリストの5番目の要素の値を介して、実行中のOSを区別できます。例えば：</target>
        </trans-unit>
        <trans-unit id="fc16009f09e3803367ecc5c2f24dcc5baf8339c5" translate="yes" xml:space="preserve">
          <source>The various MSWin32 Perl's can distinguish the OS they are running on via the value of the fifth element of the list returned from &lt;code&gt;Win32::GetOSVersion()&lt;/code&gt; . For example:</source>
          <target state="translated">さまざまなMSWin32 Perlは、 &lt;code&gt;Win32::GetOSVersion()&lt;/code&gt; から返されたリストの5番目の要素の値によって、実行中のOSを区別できます。例えば：</target>
        </trans-unit>
        <trans-unit id="b5f8a6767121d40d53463b6246a6dc21454cdfba" translate="yes" xml:space="preserve">
          <source>The various named unary operators are treated as functions with one argument, with optional parentheses.</source>
          <target state="translated">様々な名前のついた単項演算子は、オプションの括弧をつけて、1つの引数を持つ関数として扱われます。</target>
        </trans-unit>
        <trans-unit id="8d7dece5f96deb4f2078174f4b6a63435a6090e8" translate="yes" xml:space="preserve">
          <source>The various options that can be specified are:</source>
          <target state="translated">指定できるオプションは様々です。</target>
        </trans-unit>
        <trans-unit id="d5834701f76b16947132d9ecda0666e7fbd30f61" translate="yes" xml:space="preserve">
          <source>The various stacks have different purposes, and operate in slightly different ways. Their differences are noted below.</source>
          <target state="translated">さまざまなスタックにはそれぞれ異なる目的があり、わずかに異なる方法で動作します。それらの違いを以下に示します。</target>
        </trans-unit>
        <trans-unit id="8f2d3209693f371a4dffdf7b8f3fc9b9432bc2c1" translate="yes" xml:space="preserve">
          <source>The various types of data aggregate form a natural hierarchy that facilitates the use of inheritance and polymorphism.</source>
          <target state="translated">様々なタイプのデータの集合体は、継承と多型の使用を容易にする自然な階層を形成しています。</target>
        </trans-unit>
        <trans-unit id="579f7176cc72efc4b3e6d5cd5bbca1f7407618f4" translate="yes" xml:space="preserve">
          <source>The vast majority of problems that are reported in this area boil down to the fact that C strings are NULL terminated, whilst Perl strings are not. See &lt;a href=&quot;#DBM-FILTERS&quot;&gt;&quot;DBM FILTERS&quot;&lt;/a&gt; for a generic way to work around this problem.</source>
          <target state="translated">この領域で報告されている問題の大部分は、C文字列がNULLで終了しているのに対し、Perl文字列はNULLで終了していないという事実に要約されます。この問題を回避する一般的な方法については、&lt;a href=&quot;#DBM-FILTERS&quot;&gt;「DBMFILTERS」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7dcabdd4901aed0767d31bd0d04d8aa2ce24975f" translate="yes" xml:space="preserve">
          <source>The vast majority of problems that are reported in this area boil down to the fact that C strings are NULL terminated, whilst Perl strings are not. See &lt;a href=&quot;#DBM-FILTERS&quot;&gt;DBM FILTERS&lt;/a&gt; for a generic way to work around this problem.</source>
          <target state="translated">この領域で報告されている問題の大部分は、C文字列がNULLで終了しているのに対し、Perl文字列はそうではないという事実に要約されます。この問題を回避する一般的な方法については、&lt;a href=&quot;#DBM-FILTERS&quot;&gt;DBMフィルター&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="6c55d44dd5a799dd5be32ea5b3f1cae585e95693" translate="yes" xml:space="preserve">
          <source>The vast majority of the code was written by Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; , Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafayette.edu&amp;gt;&lt;/code&gt; , Andreas K&amp;ouml;nig &lt;code&gt;&amp;lt;A.Koenig@franz.ww.TU-Berlin.DE&amp;gt;&lt;/code&gt; , Tim Bunce &lt;code&gt;&amp;lt;Tim.Bunce@ig.co.uk&amp;gt;&lt;/code&gt; . VMS support by Charles Bailey &lt;code&gt;&amp;lt;bailey@newman.upenn.edu&amp;gt;&lt;/code&gt; . OS/2 support by Ilya Zakharevich &lt;code&gt;&amp;lt;ilya@math.ohio-state.edu&amp;gt;&lt;/code&gt; . Mac support by Paul Schinder &lt;code&gt;&amp;lt;schinder@pobox.com&amp;gt;&lt;/code&gt; , and Thomas Wegner &lt;code&gt;&amp;lt;wegner_thomas@yahoo.com&amp;gt;&lt;/code&gt; . abs2rel() and rel2abs() written by Shigio Yamaguchi &lt;code&gt;&amp;lt;shigio@tamacom.com&amp;gt;&lt;/code&gt; , modified by Barrie Slaymaker &lt;code&gt;&amp;lt;barries@slaysys.com&amp;gt;&lt;/code&gt; . splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.</source>
          <target state="translated">コードの大部分は、Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; 、Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafayette.edu&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;A.Koenig@franz.ww.TU-Berlin.DE&amp;gt;&lt;/code&gt; 、Tim Bunce &lt;code&gt;&amp;lt;Tim.Bunce@ig.co.uk&amp;gt;&lt;/code&gt; 。 Charles Bailey &lt;code&gt;&amp;lt;bailey@newman.upenn.edu&amp;gt;&lt;/code&gt; によるVMSサポート。 Ilya Zakharevich &lt;code&gt;&amp;lt;ilya@math.ohio-state.edu&amp;gt;&lt;/code&gt; によるOS / 2サポート。 Paul Schinder &lt;code&gt;&amp;lt;schinder@pobox.com&amp;gt;&lt;/code&gt; とThomas Wegner &lt;code&gt;&amp;lt;wegner_thomas@yahoo.com&amp;gt;&lt;/code&gt; によるMacサポート。山口 &lt;code&gt;&amp;lt;shigio@tamacom.com&amp;gt;&lt;/code&gt; によって書かれたabs2rel（）とrel2abs（）、Barrie Slaymaker &lt;code&gt;&amp;lt;barries@slaysys.com&amp;gt;&lt;/code&gt; によって修正。Barrie Slaymakerによるsplitpath（）、splitdir（）、catpath（）およびcatdir（）。</target>
        </trans-unit>
        <trans-unit id="78e57f945db726a29f3a1812670cc08732e95ca3" translate="yes" xml:space="preserve">
          <source>The vast majority of the code was written by Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt;, Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafayette.edu&amp;gt;&lt;/code&gt;, Andreas K&amp;ouml;nig &lt;code&gt;&amp;lt;A.Koenig@franz.ww.TU-Berlin.DE&amp;gt;&lt;/code&gt;, Tim Bunce &lt;code&gt;&amp;lt;Tim.Bunce@ig.co.uk&amp;gt;&lt;/code&gt;. VMS support by Charles Bailey &lt;code&gt;&amp;lt;bailey@newman.upenn.edu&amp;gt;&lt;/code&gt;. OS/2 support by Ilya Zakharevich &lt;code&gt;&amp;lt;ilya@math.ohio-state.edu&amp;gt;&lt;/code&gt;. Mac support by Paul Schinder &lt;code&gt;&amp;lt;schinder@pobox.com&amp;gt;&lt;/code&gt;, and Thomas Wegner &lt;code&gt;&amp;lt;wegner_thomas@yahoo.com&amp;gt;&lt;/code&gt;. abs2rel() and rel2abs() written by Shigio Yamaguchi &lt;code&gt;&amp;lt;shigio@tamacom.com&amp;gt;&lt;/code&gt;, modified by Barrie Slaymaker &lt;code&gt;&amp;lt;barries@slaysys.com&amp;gt;&lt;/code&gt;. splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.</source>
          <target state="translated">コードの大部分は、Kenneth Albanowski &lt;code&gt;&amp;lt;kjahds@kjahds.com&amp;gt;&lt;/code&gt; 、Andy Dougherty &lt;code&gt;&amp;lt;doughera@lafayette.edu&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;A.Koenig@franz.ww.TU-Berlin.DE&amp;gt;&lt;/code&gt; 、Tim Bunce &lt;code&gt;&amp;lt;Tim.Bunce@ig.co.uk&amp;gt;&lt;/code&gt; 。 Charles Bailey &lt;code&gt;&amp;lt;bailey@newman.upenn.edu&amp;gt;&lt;/code&gt; によるVMSサポート。 Ilya Zakharevich &lt;code&gt;&amp;lt;ilya@math.ohio-state.edu&amp;gt;&lt;/code&gt; によるOS / 2のサポート。ポール・Schinderすることで、MACサポート &lt;code&gt;&amp;lt;schinder@pobox.com&amp;gt;&lt;/code&gt; 、およびトーマス・ウェグナー &lt;code&gt;&amp;lt;wegner_thomas@yahoo.com&amp;gt;&lt;/code&gt; 。山口 &lt;code&gt;&amp;lt;shigio@tamacom.com&amp;gt;&lt;/code&gt; によって書かれたabs2rel（）とrel2abs（）、Barrie Slaymaker &lt;code&gt;&amp;lt;barries@slaysys.com&amp;gt;&lt;/code&gt; によって変更された。Barrie Slaymakerによるsplitpath（）、splitdir（）、catpath（）、catdir（）。</target>
        </trans-unit>
        <trans-unit id="e1c837eb7150f7389b8a819378e52b179af4ab77" translate="yes" xml:space="preserve">
          <source>The vec() function may produce surprising results if used on strings containing characters with ordinal values above 255. In such a case, the results are consistent with the internal encoding of the characters, but not with much else. So don't do that, and starting in Perl 5.28, a deprecation message is issued if you do so, becoming illegal in Perl 5.32.</source>
          <target state="translated">vec()関数は、255 以上の序数値を持つ文字を含む文字列で使用すると、驚くような結果が得られるかもしれません。このような場合、結果は文字の内部エンコーディングと一致していますが、他の多くは一致していません。Perl 5.28 からは、そうすると非推奨のメッセージが発行され、Perl 5.32 では違法になります。</target>
        </trans-unit>
        <trans-unit id="d0a3f9b4fdc58bce9dc91ad1590ca608ffcca3cf" translate="yes" xml:space="preserve">
          <source>The veil of abstraction separating the &lt;b&gt;interface&lt;/b&gt; from the &lt;b&gt;implementation&lt;/b&gt; (whether enforced or not), which mandates that all access to an &lt;b&gt;object&lt;/b&gt;&amp;rsquo;s state be through &lt;b&gt;methods&lt;/b&gt; alone.</source>
          <target state="translated">&lt;b&gt;オブジェクト&lt;/b&gt;の状態へのすべてのアクセスは&lt;b&gt;メソッド&lt;/b&gt;のみを使用することを要求する、&lt;b&gt;実装&lt;/b&gt;から&lt;b&gt;インターフェース&lt;/b&gt;を分離する抽象化のベール。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9b9ecb3d60d103c7f5665f456eda4698f957144a" translate="yes" xml:space="preserve">
          <source>The verify method always returns true ?</source>
          <target state="translated">verify メソッドは常に true を返します。</target>
        </trans-unit>
        <trans-unit id="20efbe7543ae8d526c7c1a14310569f9dadb6162" translate="yes" xml:space="preserve">
          <source>The version identifier for an XS module. This is usually handled automatically by &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . See &lt;code&gt;XS_VERSION_BOOTCHECK&lt;/code&gt; .</source>
          <target state="translated">XSモジュールのバージョン識別子。これは通常、 &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; によって自動的に処理されます。 &lt;code&gt;XS_VERSION_BOOTCHECK&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="7557d13ad6548a59235452a6893c4504ed7e5952" translate="yes" xml:space="preserve">
          <source>The version identifier for an XS module. This is usually handled automatically by &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;#XS_VERSION_BOOTCHECK&quot;&gt;&quot;XS_VERSION_BOOTCHECK&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">XSモジュールのバージョン識別子。これは通常、 &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; によって自動的に処理されます。 &lt;code&gt;&lt;a href=&quot;#XS_VERSION_BOOTCHECK&quot;&gt;&quot;XS_VERSION_BOOTCHECK&quot;&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="e13051932ac793eddfcf7780ddfecbd50a22ea0e" translate="yes" xml:space="preserve">
          <source>The version is essentially an arbitrary string, but</source>
          <target state="translated">バージョンは基本的には任意の文字列ですが</target>
        </trans-unit>
        <trans-unit id="4ddac7f13e9a2dc240c79129edea2cf74e24b8cc" translate="yes" xml:space="preserve">
          <source>The version number of the installed module - this will be &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if the module had no (or unparsable) version number, or if the variable &lt;code&gt;$Module::Load::Conditional::FIND_VERSION&lt;/code&gt; was set to true. (See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section below for details)</source>
          <target state="translated">インストールされているモジュールのバージョン番号-モジュールにバージョン番号がない（または解析できない）場合、または変数 &lt;code&gt;$Module::Load::Conditional::FIND_VERSION&lt;/code&gt; がtrueに設定されている場合、これは &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; になります。（詳細については、以下の「 &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; セクションを参照してください）</target>
        </trans-unit>
        <trans-unit id="881eef9e03334c572492df3693b2b9db2367c722" translate="yes" xml:space="preserve">
          <source>The version number of the installed module - this will be &lt;code&gt;undef&lt;/code&gt; if the module had no (or unparsable) version number, or if the variable &lt;code&gt;$Module::Load::Conditional::FIND_VERSION&lt;/code&gt; was set to true. (See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section below for details)</source>
          <target state="translated">インストールされたモジュールのバージョン番号-モジュールにバージョン番号がない（または解析できない）場合、または変数 &lt;code&gt;$Module::Load::Conditional::FIND_VERSION&lt;/code&gt; がtrueに設定されている場合、これは &lt;code&gt;undef&lt;/code&gt; になります。（詳細については、以下の &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; セクションを参照してください）</target>
        </trans-unit>
        <trans-unit id="7df3b2ff1998ec5ce67afe0561e7a92741c1659e" translate="yes" xml:space="preserve">
          <source>The version numbers for Windows 2003 and Windows Home Server are identical; the SUITEMASK field must be used to differentiate between them.</source>
          <target state="translated">Windows 2003 と Windows Home Server のバージョン番号は同じですが、両者を区別するためには SUITEMASK フィールドを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e0209883e46d2f3d87480f57905626dfd8d2e876" translate="yes" xml:space="preserve">
          <source>The version numbers for Windows 7 and Windows Server 2008 R2 are identical; the PRODUCTTYPE field must be used to differentiate between them.</source>
          <target state="translated">Windows 7 と Windows Server 2008 R2 のバージョン番号は同じです。</target>
        </trans-unit>
        <trans-unit id="d3168417cf9b56ff32b762909d40ba25ab0407e1" translate="yes" xml:space="preserve">
          <source>The version numbers for Windows 8 and Windows Server 2012 are identical; the PRODUCTTYPE field must be used to differentiate between them.</source>
          <target state="translated">Windows 8 と Windows Server 2012 のバージョン番号は同じですが、それらを区別するためには PRODUCTTYPE フィールドを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="f7672ecea9c16e88589676b7a7fa4e019bcc4830" translate="yes" xml:space="preserve">
          <source>The version numbers for Windows Vista and Windows Server 2008 are identical; the PRODUCTTYPE field must be used to differentiate between them.</source>
          <target state="translated">Windows Vista と Windows Server 2008 のバージョン番号は同じですが、それらを区別するためには、PRODUCTTYPE フィールドを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="c7a46a8ab62276eba4b76cf2918d64eaf428fd45" translate="yes" xml:space="preserve">
          <source>The version of PA-RISC at the time of this document's last update is 2.0, which is also the last there will be. HP PA-RISC systems are usually referred to with model description &quot;HP 9000&quot;. The last CPU in this series is the PA-8900. Support for PA-RISC architectured machines officially ends as shown in the following table:</source>
          <target state="translated">本ドキュメントの最終更新時のPA-RISCのバージョンは2.0であり、これが最後の更新となります。HPのPA-RISCシステムは、通常、「HP 9000」というモデル表記で呼ばれています。このシリーズの最後のCPUはPA-8900です。PA-RISCアーキテクチャーマシンのサポートは、以下の表のように正式に終了します。</target>
        </trans-unit>
        <trans-unit id="d9cdcafc4749e48949c53b1e0f4aeffeae610286" translate="yes" xml:space="preserve">
          <source>The version of ext() which is executed under VMS differs from the Unix-OS/2 version in several respects:</source>
          <target state="translated">VMS で実行される ext()のバージョンは、いくつかの点で Unix-OS/2 のバージョンとは異なります。</target>
        </trans-unit>
        <trans-unit id="fa000c815a6c1f4aa9d1d3cce6270062ea44f5d2" translate="yes" xml:space="preserve">
          <source>The version of ext() which is executed under Win32 differs from the Unix-OS/2 version in several respects:</source>
          <target state="translated">Win32 で実行される ext()のバージョンは、いくつかの点で Unix-OS/2 のバージョンとは異なります。</target>
        </trans-unit>
        <trans-unit id="eea453196c9ecc4c3ad7040390519b5e41971ecc" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement Vstrings, to use &lt;a href=&quot;#isvstring&quot;&gt;&quot;isvstring&quot;&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="translated">使用しているperlのバージョンはVstringsを実装していません。&lt;a href=&quot;#isvstring&quot;&gt;「isvstring」&lt;/a&gt;を使用するには、perlの新しいリリースを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="04c1fecbb3d585e94f9621773c665e2e2cd3f97d" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement Vstrings, to use &lt;a href=&quot;#isvstring&quot;&gt;isvstring&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="translated">あなたが使用し、Vstringsを実装していない使用しているバージョンのPerl &lt;a href=&quot;#isvstring&quot;&gt;isvstring&lt;/a&gt;あなたはperlのの新しいリリースを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="decdd9bf0416592f2797901080148ed0ab06c7cc" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement weak references, to use &lt;a href=&quot;#isweak&quot;&gt;&quot;isweak&quot;&lt;/a&gt; or &lt;a href=&quot;#weaken&quot;&gt;&quot;weaken&quot;&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="translated">使用しているバージョンのperlは弱参照を実装していません。&lt;a href=&quot;#isweak&quot;&gt;「isweak」&lt;/a&gt;または&lt;a href=&quot;#weaken&quot;&gt;「&lt;/a&gt;weaken」を使用するには、新しいリリースのperlを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="f8f3dd17d141437206c98482882771da9fd578da" translate="yes" xml:space="preserve">
          <source>The version of perl that you are using does not implement weak references, to use &lt;a href=&quot;#isweak&quot;&gt;isweak&lt;/a&gt; or &lt;a href=&quot;#weaken&quot;&gt;weaken&lt;/a&gt; you will need to use a newer release of perl.</source>
          <target state="translated">あなたは弱い参照を実装していない使用していることのperlのバージョンは、使用する&lt;a href=&quot;#isweak&quot;&gt;isweak&lt;/a&gt;または&lt;a href=&quot;#weaken&quot;&gt;弱める&lt;/a&gt;あなたはperlのの新しいリリースを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="93c33ec188f162276af3a60f34074e13ed0b75fe" translate="yes" xml:space="preserve">
          <source>The version of the distribution to which the META.yml file refers.</source>
          <target state="translated">META.ymlファイルが参照しているディストリビューションのバージョン。</target>
        </trans-unit>
        <trans-unit id="d68f5af181947e373672838e7416d0d6d5457c72" translate="yes" xml:space="preserve">
          <source>The version of the distribution to which the META.yml file refers. This is a mandatory field.</source>
          <target state="translated">META.ymlファイルが参照するディストリビューションのバージョン。これは必須のフィールドです。</target>
        </trans-unit>
        <trans-unit id="64bb3d6c21bf2a657e7026f0eee7644697eafb33" translate="yes" xml:space="preserve">
          <source>The version of the module distributed with Perl should, whenever possible, be the latest version of the module as distributed by the author (the latest non-beta version in the case of public Perl releases), although the pumpkin holder may hold off on upgrading the version of the module distributed with Perl to the latest version until the latest version has had sufficient testing.</source>
          <target state="translated">Perl で配布されるモジュールのバージョンは、可能な限り、作者が配布したモジュールの最新バージョン (Perl の公開リリースの場合は、最新の非ベータバージョン)であるべきですが、パンプキンホルダーは、最新バージョンが十分にテストされるまで、Perl で配布されるモジュールのバージョンを最新バージョンにアップグレードするのを延期してもかまいません。</target>
        </trans-unit>
        <trans-unit id="b21f22d5179989f705ed9d6a2a79b769acbc417d" translate="yes" xml:space="preserve">
          <source>The version of the module in the Perl core should still be considered the work of the original author. All patches, bug reports, and so forth should be fed back to them. Their development directions should be respected whenever possible.</source>
          <target state="translated">Perl コアのモジュールのバージョンは、オリジナルの作者の作品とみなされるべきです。すべてのパッチやバグレポートなどは原著者にフィードバックされるべきです。可能な限り、彼らの開発の方向性を尊重してください。</target>
        </trans-unit>
        <trans-unit id="92d384762292f03ed396ad91a060564bf7d9627e" translate="yes" xml:space="preserve">
          <source>The version this module needs to be -- this is optional</source>
          <target state="translated">このモジュールが必要とするバージョン --これはオプションです。</target>
        </trans-unit>
        <trans-unit id="7c293dc4ef8b29552aa12216990ef31577ac2eeb" translate="yes" xml:space="preserve">
          <source>The versions of as and ld supplied with Solaris work fine for building perl. There is normally no need to install the GNU versions to compile perl.</source>
          <target state="translated">Solaris に付属している as と ld のバージョンは、perl のビルドには問題なく動作します。通常、perlをコンパイルするためにGNUのバージョンをインストールする必要はありません。</target>
        </trans-unit>
        <trans-unit id="991e6e65f67b3a36b7e485bd86d8f440ac42e72f" translate="yes" xml:space="preserve">
          <source>The very end of the document:</source>
          <target state="translated">文書の最後の最後まで。</target>
        </trans-unit>
        <trans-unit id="c59ec45ae7f53d6bfeaac3f5d1524ea40228db75" translate="yes" xml:space="preserve">
          <source>The very first thing you should do is look into getting the Term::ReadKey extension from CPAN. As we mentioned earlier, it now even has limited support for non-portable (read: not open systems, closed, proprietary, not POSIX, not Unix, etc.) systems.</source>
          <target state="translated">最初にやるべきことは、CPANからTerm::ReadKeyエクステンションを入手することです。先に述べたように、現在では、移植性のない(オープンシステムではない、クローズド、プロプライエタリ、POSIXではない、Unixではない、など)システムにも限定的に対応しています。</target>
        </trans-unit>
        <trans-unit id="a54a90d3a077b2809332364bbb3b822680082301" translate="yes" xml:space="preserve">
          <source>The volume portion is always returned with a trailing &quot;:&quot;. The directory portion is always returned with a leading (to denote a relative path) and a trailing &quot;:&quot; (to denote a directory). The file portion is always returned</source>
          <target state="translated">ボリュームの部分は常に最後の&quot;:&quot;で返されます。ディレクトリ部分は常に先頭に(相対パスを表すため)、末尾に「:」(ディレクトリを表すため)を付けて返されます。ファイル部分は常に</target>
        </trans-unit>
        <trans-unit id="1ec332efc336ec299c7acc49f0d1e2fc497986e3" translate="yes" xml:space="preserve">
          <source>The wanted function</source>
          <target state="translated">欲しい機能</target>
        </trans-unit>
        <trans-unit id="6125dd5f3b647dbf86db0b504a3821e5fb95de7e" translate="yes" xml:space="preserve">
          <source>The wanted function takes no arguments but rather does its work through a collection of variables.</source>
          <target state="translated">欲しい関数は引数を取りませんが、変数のコレクションを通して動作します。</target>
        </trans-unit>
        <trans-unit id="20d73a1883be618af881251a4f69445af19dc1a9" translate="yes" xml:space="preserve">
          <source>The warning category (or categories) packed into a &lt;code&gt;SVuv&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SVuv&lt;/code&gt; にパックされた警告カテゴリ（または複数のカテゴリ）。</target>
        </trans-unit>
        <trans-unit id="badd12b3cb878c5659d7f27917ce9ac00752a63d" translate="yes" xml:space="preserve">
          <source>The warning is considered severe enough not to be affected by the &lt;b&gt;-w&lt;/b&gt; switch (or its absence) because previously compiled invocations of the function will still be using the old value of the function. If you need to be able to redefine the subroutine, you need to ensure that it isn't inlined, either by dropping the &lt;code&gt;()&lt;/code&gt; prototype (which changes calling semantics, so beware) or by thwarting the inlining mechanism in some other way, e.g. by adding an explicit &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt;, as mentioned above:</source>
          <target state="translated">以前にコンパイルされた関数の呼び出しは引き続き関数の古い値を使用するため、警告は&lt;b&gt;-w&lt;/b&gt;スイッチ（またはその欠如）の影響を受けないほど深刻と見なされます。サブルーチンを再定義できるようにする必要がある場合は、 &lt;code&gt;()&lt;/code&gt; のプロトタイプ（呼び出しのセマンティクスを変更するので注意してください）を削除するか、他の方法でインライン化メカニズムを妨害することにより、インライン化されないようにする必要があります。上記のように、明示的な &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; を追加します。</target>
        </trans-unit>
        <trans-unit id="dad69db2f27b61d28a567c57b099e70158211293" translate="yes" xml:space="preserve">
          <source>The warning is considered severe enough not to be affected by the &lt;b&gt;-w&lt;/b&gt; switch (or its absence) because previously compiled invocations of the function will still be using the old value of the function. If you need to be able to redefine the subroutine, you need to ensure that it isn't inlined, either by dropping the &lt;code&gt;()&lt;/code&gt; prototype (which changes calling semantics, so beware) or by thwarting the inlining mechanism in some other way, e.g. by adding an explicit &lt;code&gt;return&lt;/code&gt;, as mentioned above:</source>
          <target state="translated">以前にコンパイルされた関数の呼び出しは引き続き関数の古い値を使用するため、警告は&lt;b&gt;-w&lt;/b&gt;スイッチ（またはその欠如）の影響を受けないほど重大であると見なされます。サブルーチンを再定義できるようにする必要がある場合は、 &lt;code&gt;()&lt;/code&gt; プロトタイプを削除するか（呼び出しセマンティクスを変更するので注意してください）、または他の方法でインライン化メカニズムを阻止することによって、サブルーチンがインライン化されないようにする必要があります。上記のように、明示的な &lt;code&gt;return&lt;/code&gt; 追加することによって：</target>
        </trans-unit>
        <trans-unit id="228748e063ab0367333a5d358a372ffaa2776b68" translate="yes" xml:space="preserve">
          <source>The way I see this being used is like basically this:</source>
          <target state="translated">私が見ている使い方は、基本的にはこんな感じです。</target>
        </trans-unit>
        <trans-unit id="bf8410bbe832531f3fd9213bd8f3ba1287e55dc6" translate="yes" xml:space="preserve">
          <source>The way Perl builds up these op trees in the parsing process can be unravelled by examining</source>
          <target state="translated">Perl が解析プロセスでこれらの op ツリーをどのように構築するかは</target>
        </trans-unit>
        <trans-unit id="b9a4e5fa4cbdb6cec50f6eac70c4ad531843cef7" translate="yes" xml:space="preserve">
          <source>The way Test::More handles this is with a named block. Basically, a block of tests which can be skipped over or made todo. It's best if I just show you...</source>
          <target state="translated">Test::Moreがこれを処理する方法は、名前付きブロックを使うことです。基本的には、テストをスキップしたり、Todoにしたりできるテストのブロックです。お見せするのが一番いいのですが...</target>
        </trans-unit>
        <trans-unit id="3a44ce079c4bba6650cbd971c39500928ccb7c22" translate="yes" xml:space="preserve">
          <source>The way a program responds to an error. The exception-handling mechanism in Perl is the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">プログラムがエラーに応答する方法。Perlの例外処理メカニズムは &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 演算子です。</target>
        </trans-unit>
        <trans-unit id="485d9ec05d9e7ee1509acc95cd728f99a6dde4db" translate="yes" xml:space="preserve">
          <source>The way a program responds to an error. The exception-handling mechanism in Perl is the &lt;code&gt;eval&lt;/code&gt; operator.</source>
          <target state="translated">プログラムがエラーに応答する方法。Perlの例外処理メカニズムは &lt;code&gt;eval&lt;/code&gt; 演算子です。</target>
        </trans-unit>
        <trans-unit id="39341ae7c243431172aa717f037dcb000913133f" translate="yes" xml:space="preserve">
          <source>The way it resolves which actual method to call is:</source>
          <target state="translated">実際にどのメソッドを呼び出すかを解決する方法です。</target>
        </trans-unit>
        <trans-unit id="2ecf3674cf5632aa049fa7e267f9fbd82a5b7877" translate="yes" xml:space="preserve">
          <source>The way it works is that when the &lt;code&gt;@{...}&lt;/code&gt; is seen in the double-quoted string, it's evaluated as a block. The block creates a reference to an anonymous array containing the results of the call to &lt;code&gt;mysub(1,2,3)&lt;/code&gt; . So the whole block returns a reference to an array, which is then dereferenced by &lt;code&gt;@{...}&lt;/code&gt; and stuck into the double-quoted string. This chicanery is also useful for arbitrary expressions:</source>
          <target state="translated">それが機能する方法は、 &lt;code&gt;@{...}&lt;/code&gt; が二重引用符で囲まれた文字列で見られるとき、それはブロックとして評価されるということです。ブロックは、 &lt;code&gt;mysub(1,2,3)&lt;/code&gt; への呼び出しの結果を含む無名配列への参照を作成します。そのため、ブロック全体が配列への参照を返し、配列は &lt;code&gt;@{...}&lt;/code&gt; によって逆参照され、二重引用符で囲まれた文字列にスタックされます。このシカナリーは、任意の式にも役立ちます。</target>
        </trans-unit>
        <trans-unit id="22373b22c059855720b294750ec63ef1e1b487f7" translate="yes" xml:space="preserve">
          <source>The way it works is that when the &lt;code&gt;@{...}&lt;/code&gt; is seen in the double-quoted string, it's evaluated as a block. The block creates a reference to an anonymous array containing the results of the call to &lt;code&gt;mysub(1,2,3)&lt;/code&gt;. So the whole block returns a reference to an array, which is then dereferenced by &lt;code&gt;@{...}&lt;/code&gt; and stuck into the double-quoted string. This chicanery is also useful for arbitrary expressions:</source>
          <target state="translated">それが機能する方法は、 &lt;code&gt;@{...}&lt;/code&gt; が二重引用符で囲まれた文字列に表示されると、ブロックとして評価されるというものです。このブロックは、 &lt;code&gt;mysub(1,2,3)&lt;/code&gt; の呼び出しの結果を含む匿名配列への参照を作成します。したがって、ブロック全体が配列への参照を返します。配列は &lt;code&gt;@{...}&lt;/code&gt; によって逆参照され、二重引用符で囲まれた文字列に固定されます。このchicaneryは、任意の表現にも役立ちます。</target>
        </trans-unit>
        <trans-unit id="464aa10ca9c1c0eb18ad0b5fbb41c9f2af8f5587" translate="yes" xml:space="preserve">
          <source>The way this trick works is that the character with the code point &lt;code&gt;U+FFFE&lt;/code&gt; is not supposed to be in input streams, so the sequence of bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt; is unambiguously &quot;&lt;code&gt;BOM&lt;/code&gt; , represented in little-endian format&quot; and cannot be &lt;code&gt;U+FFFE&lt;/code&gt; , represented in big-endian format&quot;.</source>
          <target state="translated">このトリックが機能する方法は、コードポイント &lt;code&gt;U+FFFE&lt;/code&gt; の文字が入力ストリームにあるとは想定されていないため、バイトのシーケンス &lt;code&gt;0xFF 0xFE&lt;/code&gt; は明確に「 &lt;code&gt;BOM&lt;/code&gt; 、リトルエンディアン形式で表される」であり、 &lt;code&gt;U+FFFE&lt;/code&gt; にすることはできません。、ビッグエンディアン形式で表されます。」</target>
        </trans-unit>
        <trans-unit id="03d93acd73703280d7e5deb9019540799404d722" translate="yes" xml:space="preserve">
          <source>The way this trick works is that the character with the code point &lt;code&gt;U+FFFE&lt;/code&gt; is not supposed to be in input streams, so the sequence of bytes &lt;code&gt;0xFF 0xFE&lt;/code&gt; is unambiguously &quot;&lt;code&gt;BOM&lt;/code&gt;, represented in little-endian format&quot; and cannot be &lt;code&gt;U+FFFE&lt;/code&gt;, represented in big-endian format&quot;.</source>
          <target state="translated">このトリックの仕組みは、コードポイント &lt;code&gt;U+FFFE&lt;/code&gt; の文字が入力ストリームに含まれることは想定されていないため、バイトシーケンス &lt;code&gt;0xFF 0xFE&lt;/code&gt; は明確に「 &lt;code&gt;BOM&lt;/code&gt; 、リトルエンディアン形式で表される」であり、 &lt;code&gt;U+FFFE&lt;/code&gt; にすることはできません。、ビッグエンディアン形式で表されます」。</target>
        </trans-unit>
        <trans-unit id="3f55c636a9c9c26eb587e152e4c24ce7d11dc1f3" translate="yes" xml:space="preserve">
          <source>The way this works under-the-hood is that every thread has a choice of using a locale specific to it (this is the Windows and POSIX 2008 functionality), or the global locale that is accessible to all threads (this is the functionality that has always been there). The implementations for Windows and POSIX are completely different. On Windows, the runtime can be set up so that the standard &lt;a href=&quot;setlocale(3)&quot;&gt;&lt;code&gt;setlocale(3)&lt;/code&gt;&lt;/a&gt; function either only knows about the global locale or the locale for this thread. On POSIX, &lt;code&gt;setlocale&lt;/code&gt; always deals with the global locale, and other functions have been created to handle per-thread locales. Perl makes this transparent to perl-space code. It continues to use &lt;code&gt;POSIX::setlocale()&lt;/code&gt;, and the interpreter translates that into the per-thread functions.</source>
          <target state="translated">これが内部で機能する方法は、すべてのスレッドがそれに固有のロケール（これはWindowsおよびPOSIX 2008の機能）を使用するか、すべてのスレッドがアクセスできるグローバルロケール（これは常にそこにいました）。 WindowsとPOSIXの実装は完全に異なります。 Windowsでは、標準の&lt;a href=&quot;setlocale(3)&quot;&gt; &lt;code&gt;setlocale(3)&lt;/code&gt; &lt;/a&gt;関数がグローバルロケールまたはこのスレッドのロケールのみを認識するようにランタイムを設定できます。 POSIXでは、 &lt;code&gt;setlocale&lt;/code&gt; は常にグローバルロケールを処理し、スレッドごとのロケールを処理するために他の関数が作成されています。 Perlは、これをperl-spaceコードに対して透過的にします。引き続き &lt;code&gt;POSIX::setlocale()&lt;/code&gt; を使用し、インタープリターはそれをスレッドごとの関数に変換します。</target>
        </trans-unit>
        <trans-unit id="5898f48e7b39c1a379ea1247c549323ccbb46061" translate="yes" xml:space="preserve">
          <source>The way to get around this problem is to use the Berkeley DB API method called &lt;code&gt;seq&lt;/code&gt; . This method allows sequential access to key/value pairs. See &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;THE API INTERFACE&lt;/a&gt; for details of both the &lt;code&gt;seq&lt;/code&gt; method and the API in general.</source>
          <target state="translated">この問題を回避する方法は、 &lt;code&gt;seq&lt;/code&gt; と呼ばれるBerkeley DB APIメソッドを使用することです。この方法では、キーと値のペアに順次アクセスできます。参照&lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;APIインタフェース&lt;/a&gt;の両方の詳細については &lt;code&gt;seq&lt;/code&gt; 方法および一般的なAPIを。</target>
        </trans-unit>
        <trans-unit id="365d9cd3356a85ac2e3ab542f36bc2743ee69357" translate="yes" xml:space="preserve">
          <source>The way to get around this problem is to use the Berkeley DB API method called &lt;code&gt;seq&lt;/code&gt;. This method allows sequential access to key/value pairs. See &lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;&quot;THE API INTERFACE&quot;&lt;/a&gt; for details of both the &lt;code&gt;seq&lt;/code&gt; method and the API in general.</source>
          <target state="translated">この問題を回避する方法は、 &lt;code&gt;seq&lt;/code&gt; と呼ばれるBerkeley DBAPIメソッドを使用することです。この方法では、キーと値のペアに順次アクセスできます。参照&lt;a href=&quot;#THE-API-INTERFACE&quot;&gt;「APIインタフェース」&lt;/a&gt;の両方の詳細については &lt;code&gt;seq&lt;/code&gt; 方法および一般的なAPI。</target>
        </trans-unit>
        <trans-unit id="cd500d8c20565e5f312bdd0b6574f8c8052649e9" translate="yes" xml:space="preserve">
          <source>The way to use this class is to make a new object of this class, set any options, and then call one of the search options (probably &lt;code&gt;survey&lt;/code&gt; or &lt;code&gt;find&lt;/code&gt; ). The sections below discuss the syntaxes for doing all that.</source>
          <target state="translated">このクラスを使用する方法は、このクラスの新しいオブジェクトを作成し、オプションを設定してから、検索オプションの1つを呼び出すことです（おそらく &lt;code&gt;survey&lt;/code&gt; または &lt;code&gt;find&lt;/code&gt; ）。以下のセクションでは、これらすべてを行うための構文について説明します。</target>
        </trans-unit>
        <trans-unit id="70dcc819697307fd63c00ab11c88076b157ec890" translate="yes" xml:space="preserve">
          <source>The way to use this class is to make a new object of this class, set any options, and then call one of the search options (probably &lt;code&gt;survey&lt;/code&gt; or &lt;code&gt;find&lt;/code&gt;). The sections below discuss the syntaxes for doing all that.</source>
          <target state="translated">このクラスを使用する方法は、このクラスの新しいオブジェクトを作成し、オプションを設定してから、検索オプションの1つを呼び出すことです（おそらく &lt;code&gt;survey&lt;/code&gt; または &lt;code&gt;find&lt;/code&gt; ）。以下のセクションでは、これらすべてを実行するための構文について説明します。</target>
        </trans-unit>
        <trans-unit id="5268c05807fff3d270f4531a0cd21a77634cf686" translate="yes" xml:space="preserve">
          <source>The web server handling the HTTP service is assumed to be at its standard port, number 80. If the server you're trying to connect to is at a different port, like 1080 or 8080, you should specify it as the named-parameter pair, &lt;code&gt;PeerPort =&amp;gt; 8080&lt;/code&gt; . The &lt;code&gt;autoflush&lt;/code&gt; method is used on the socket because otherwise the system would buffer up the output we sent it. (If you're on a prehistoric Mac, you'll also need to change every &lt;code&gt;&quot;\n&quot;&lt;/code&gt; in your code that sends data over the network to be a &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; instead.)</source>
          <target state="translated">HTTPサービスを処理するWebサーバーは、その標準ポート番号80であると想定されています。接続しようとしているサーバーが1080や8080などの別のポートにある場合は、名前付きパラメーターのペアとして指定する必要があります、 &lt;code&gt;PeerPort =&amp;gt; 8080&lt;/code&gt; 。 &lt;code&gt;autoflush&lt;/code&gt; そうでない場合は、システムが、我々はそれを送った出力をバッファリングしてしまうための方法は、ソケットで使用されています。（先史時代のMacを使用している場合は、ネットワーク経由でデータを送信するコード内のすべての &lt;code&gt;&quot;\n&quot;&lt;/code&gt; も &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; に変更する必要があります。）</target>
        </trans-unit>
        <trans-unit id="c2c0fa4dc9353a78eef2a13048e071f4e11d6efd" translate="yes" xml:space="preserve">
          <source>The web server handling the HTTP service is assumed to be at its standard port, number 80. If the server you're trying to connect to is at a different port, like 1080 or 8080, you should specify it as the named-parameter pair, &lt;code&gt;PeerPort =&amp;gt; 8080&lt;/code&gt;. The &lt;code&gt;autoflush&lt;/code&gt; method is used on the socket because otherwise the system would buffer up the output we sent it. (If you're on a prehistoric Mac, you'll also need to change every &lt;code&gt;&quot;\n&quot;&lt;/code&gt; in your code that sends data over the network to be a &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; instead.)</source>
          <target state="translated">HTTPサービスを処理するWebサーバーは、標準ポートの番号80にあると想定されます。接続しようとしているサーバーが1080や8080などの別のポートにある場合は、名前付きパラメーターのペアとして指定する必要があります。 、 &lt;code&gt;PeerPort =&amp;gt; 8080&lt;/code&gt; 。 &lt;code&gt;autoflush&lt;/code&gt; そうでない場合は、システムが、我々はそれを送った出力をバッファリングしてしまうための方法は、ソケットで使用されています。（先史時代のMacを使用している場合は、ネットワーク経由でデータを送信するコード内のすべての &lt;code&gt;&quot;\n&quot;&lt;/code&gt; を、代わりに &lt;code&gt;&quot;\015\012&quot;&lt;/code&gt; に変更する必要もあります。）</target>
        </trans-unit>
        <trans-unit id="b22573d6d6dbb31578b3c4fa9e8a17816a358dfc" translate="yes" xml:space="preserve">
          <source>The well known Unicode Byte Order Marks are as follows: if the file begins with the two literal byte values 0xFE 0xFF, this is the BOM for big-endian UTF-16. If the file begins with the two literal byte value 0xFF 0xFE, this is the BOM for little-endian UTF-16. On an ASCII platform, if the file begins with the three literal byte values 0xEF 0xBB 0xBF, this is the BOM for UTF-8. A mechanism portable to EBCDIC platforms is to:</source>
          <target state="translated">よく知られている Unicode バ イ ト 順序マークは以下の と お り です:フ ァ イ ルが 2 つの リ テ ラ ルバ イ ト 値 0xFE 0xFF で始ま る 場合、 こ れは ビ ッ グエンデ ィ ア ン UTF-16 の BOM です。フ ァ イ ルが 2 つの リ テ ラ ルバ イ ト 値 0xFF 0xFE で始ま る と き は、 こ れは リ ト ルエンデ ィ ア ン UTF-16 の BOM です。ASCII プ ラ ッ ト フ ォームでは、 フ ァ イ ルが 3 つの リ テ ラ ルバ イ ト 値 0xEF 0xBB 0xBF で始ま る と き は、 こ れが UTF-8 の BOM と な り ます。EBCDIC プ ラ ッ ト フ ォームへの移植可能な機構は以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="c25fe7dd72c3069b0e017baa01097278ab17f62e" translate="yes" xml:space="preserve">
          <source>The while loop from line 14 to line 26 grabs a scalar off the input queue and checks against the prime this thread is responsible for. Line 15 checks to see if there's a remainder when we divide the number to be checked by our prime. If there is one, the number must not be evenly divisible by our prime, so we need to either pass it on to the next thread if we've created one (line 17) or create a new thread if we haven't.</source>
          <target state="translated">14 行目から 26 行目までの while ループは、入力キューからスカラを取得し、このスレッドが担当する素数と照合します。15 行目は、チェックする数値を素数で割ったときに余剰があるかどうかをチェックしています。もし余っている場合は、その数値は素数で割り切れていないはずなので、次のスレッドを作った場合はそれを次のスレッドに渡す (17 行目)か、作っていない場合は新しいスレッドを作る必要があります。</target>
        </trans-unit>
        <trans-unit id="a997f7e1957d2b943d666798431c61228059e247" translate="yes" xml:space="preserve">
          <source>The whole Unicode standard &lt;a href=&quot;http://www.unicode.org/unicode/uni2book/u2.html&quot;&gt;http://www.unicode.org/unicode/uni2book/u2.html&lt;/a&gt;</source>
          <target state="translated">Unicode標準全体&lt;a href=&quot;http://www.unicode.org/unicode/uni2book/u2.html&quot;&gt;http://www.unicode.org/unicode/uni2book/u2.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52ed5e8abe2195d94e62a75cf32bf369a78b18af" translate="yes" xml:space="preserve">
          <source>The whole idea of the &quot;standard C API to start applications&quot; is that the forms &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;&quot;foo&quot;&lt;/code&gt; of program arguments are completely interchangeable.</source>
          <target state="translated">「アプリケーションを起動するための標準C API」の全体的な考え方は、プログラム引数の形式 &lt;code&gt;foo&lt;/code&gt; および &lt;code&gt;&quot;foo&quot;&lt;/code&gt; は完全に交換可能であるということです。</target>
        </trans-unit>
        <trans-unit id="0fe54c442e0898f0c65d2e7e96e6d557275adef9" translate="yes" xml:space="preserve">
          <source>The whole scheme for interpreting two-digit years can be considered a bug.</source>
          <target state="translated">2桁の年を解釈するスキーム全体がバグと考えられます。</target>
        </trans-unit>
        <trans-unit id="06823ddcb564d7e0125b4ed62adb0242c15ff840" translate="yes" xml:space="preserve">
          <source>The wide character is not used in the &lt;code&gt;&amp;amp;&lt;/code&gt; operation because the left operand is shorter. This now throws an exception.</source>
          <target state="translated">左のオペランドが短いため、 &lt;code&gt;&amp;amp;&lt;/code&gt; 操作ではワイド文字は使用されません。これで例外がスローされます。</target>
        </trans-unit>
        <trans-unit id="a5992a1d1d14f7a847e98f6f7210198b195d54e7" translate="yes" xml:space="preserve">
          <source>The wide-character-specific (Unicode) functions. Each of these is just the same as the version without the trailing &quot;W&quot; except that strings are expected in Unicode and some lengths are measured as number of &lt;code&gt;WCHAR&lt;/code&gt;s instead of number of bytes, as indicated below.</source>
          <target state="translated">ワイド文字固有（Unicode）関数。これらのそれぞれは、文字列がUnicodeで予期され、一部の長さがバイト数ではなく &lt;code&gt;WCHAR&lt;/code&gt; の数として測定されることを除いて、末尾に「W」がないバージョンとまったく同じです。</target>
        </trans-unit>
        <trans-unit id="d301a149055986dea057eaf7f10ce99a292fd767" translate="yes" xml:space="preserve">
          <source>The width of the left margin in spaces. Defaults to 0. This is the margin for all text, including headings, not the amount by which regular text is indented; for the latter, see &lt;b&gt;-i&lt;/b&gt; option.</source>
          <target state="translated">スペースの左マージンの幅。デフォルトは0です。これは、見出しを含むすべてのテキストのマージンであり、通常のテキストがインデントされる量ではありません。後者については、&lt;b&gt;-i&lt;/b&gt;オプションを参照してください。</target>
        </trans-unit>
        <trans-unit id="00b688a33a04cf250468fb3feaca19bab2ec26fc" translate="yes" xml:space="preserve">
          <source>The width of the left margin in spaces. Defaults to 0. This is the margin for all text, including headings, not the amount by which regular text is indented; for the latter, see the</source>
          <target state="translated">左マージンの幅をスペースで表します。デフォルトは0です。 これは見出しを含むすべてのテキストのマージンであり、通常のテキストがインデントされる量ではありません。</target>
        </trans-unit>
        <trans-unit id="9f8ba2c52e40b69413c01ffc592fe399547fc20f" translate="yes" xml:space="preserve">
          <source>The word returned by the &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; function when you apply it to a reference to a subroutine. See also &lt;b&gt;CV&lt;/b&gt;.</source>
          <target state="translated">サブルーチンへの参照に適用したときに &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; 関数によって返される単語。&lt;b&gt;CV&lt;/b&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="6d42ff99a16e8f67b82856c6d2b84806cf10fd36" translate="yes" xml:space="preserve">
          <source>The word returned by the &lt;code&gt;ref&lt;/code&gt; function when you apply it to a reference to a subroutine. See also &lt;b&gt;CV&lt;/b&gt;.</source>
          <target state="translated">サブルーチンへの参照に適用したときに &lt;code&gt;ref&lt;/code&gt; 関数によって返される単語。&lt;b&gt;CV&lt;/b&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="28be5b370df296bc57d076e1c2849a0ebee70013" translate="yes" xml:space="preserve">
          <source>The work isn't over until the paperwork is done, and you're going to need to put in some time writing some documentation for your module. &lt;code&gt;module-starter&lt;/code&gt; or &lt;code&gt;h2xs&lt;/code&gt; will provide a stub for you to fill in; if you're not sure about the format, look at &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; for an introduction. Provide a good synopsis of how your module is used in code, a description, and then notes on the syntax and function of the individual subroutines or methods. Use Perl comments for developer notes and POD for end-user notes.</source>
          <target state="translated">事務処理が完了するまで作業は終わりません。モジュールのドキュメントを書く必要があるでしょう。 &lt;code&gt;module-starter&lt;/code&gt; または &lt;code&gt;h2xs&lt;/code&gt; は、記入するスタブを提供します。形式がわからない場合は、&lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;で概要を確認してください。モジュールがコード内でどのように使用されているかの概要、説明、および個々のサブルーチンやメソッドの構文と機能についてのメモを提供します。開発者向けのメモにはPerlコメントを、エンドユーザー向けのメモにはPODを使用します。</target>
        </trans-unit>
        <trans-unit id="a31887edd2b89b26426a7d0c030500f19faef476" translate="yes" xml:space="preserve">
          <source>The work of the interpreter has two main stages: compiling the code into the internal representation, or bytecode, and then executing it. &lt;a href=&quot;perlguts#Compiled-code&quot;&gt;&quot;Compiled code&quot; in perlguts&lt;/a&gt; explains exactly how the compilation stage happens.</source>
          <target state="translated">インタープリターの作業には、コードを内部表現またはバイトコードにコンパイルしてから実行するという2つの主要な段階があります。&lt;a href=&quot;perlguts#Compiled-code&quot;&gt;perlgutsの「コンパイルされたコード」は&lt;/a&gt;、コンパイル段階がどのように行われるかを正確に説明しています。</target>
        </trans-unit>
        <trans-unit id="1436e107c02b49fba4e33d8aaae3115ec601983a" translate="yes" xml:space="preserve">
          <source>The work of the interpreter has two main stages: compiling the code into the internal representation, or bytecode, and then executing it. &lt;a href=&quot;perlguts#Compiled-code&quot;&gt;Compiled code in perlguts&lt;/a&gt; explains exactly how the compilation stage happens.</source>
          <target state="translated">インタープリターの作業には2つの主要な段階があります。コードを内部表現（バイトコード）にコンパイルしてから実行します。&lt;a href=&quot;perlguts#Compiled-code&quot;&gt;perlgutsのコンパイル済みコードは&lt;/a&gt;、コンパイル段階がどのように行われるかを正確に説明しています。</target>
        </trans-unit>
        <trans-unit id="8b1397bff51f75db954e0f3e3e1b665db01ca7e8" translate="yes" xml:space="preserve">
          <source>The world's languages are written in many different scripts. This sentence (unless you're reading it in translation) is written in Latin, while Russian is written in Cyrillic, and Greek is written in, well, Greek; Japanese mainly in Hiragana or Katakana. There are many more.</source>
          <target state="translated">世界の言語はいろいろな文字で書かれています。この文章(翻訳で読んでいるのでなければ)はラテン語で書かれていますし、ロシア語はキリル文字で書かれていますし、ギリシャ語は、まあ、ギリシャ語で書かれていますし、日本語は主にひらがなやカタカナで書かれています。他にもたくさんあります。</target>
        </trans-unit>
        <trans-unit id="85da59eaf7698f05d48c68376bdd4ba3b6dce3bd" translate="yes" xml:space="preserve">
          <source>The worst patches make use of system-specific features. It's highly unlikely that non-portable additions to the Perl language will be accepted.</source>
          <target state="translated">最悪のパッチはシステム固有の機能を利用しています。Perl 言語への移植性のない追加が受け入れられる可能性は非常に低いです。</target>
        </trans-unit>
        <trans-unit id="2affe5ea5db32cf7d355e39106992f04132aac2d" translate="yes" xml:space="preserve">
          <source>The write filehandle will have autoflush turned on.</source>
          <target state="translated">書き込みファイルハンドルはオートフラッシュがオンになります。</target>
        </trans-unit>
        <trans-unit id="f34726284c86402203e3588790fd3c449c8531b5" translate="yes" xml:space="preserve">
          <source>The yacc coming with BS2000 POSIX didn't work for us. So we had to use bison. We had to make a few changes to perl in order to use the pure (reentrant) parser of bison. We used version 1.25, but we had to add a few changes due to EBCDIC. See below for more details concerning yacc.</source>
          <target state="translated">BS2000 POSIXに付属しているYaccが使えませんでした。そこで、私たちは bison を使わなければなりませんでした。bisonの純粋な(リエントラントな)パーサを使うために、perlにいくつかの変更を加えなければなりませんでした。バージョン1.25を使用しましたが、EBCDICのためにいくつかの変更を加えなければなりませんでした。yaccに関する詳細は以下を参照してください。</target>
        </trans-unit>
        <trans-unit id="0aff817087165151aec8e0b6db814baaf554f377" translate="yes" xml:space="preserve">
          <source>The z/OS Unix Tools and Toys list may prove helpful and contains links to ports of much of the software helpful for building Perl. &lt;a href=&quot;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&quot;&gt;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&lt;/a&gt;</source>
          <target state="translated">z / OS Unixのツールとおもちゃのリストは役立つ場合があり、Perlの構築に役立つソフトウェアの多くのポートへのリンクが含まれています。&lt;a href=&quot;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&quot;&gt;http://www.ibm.com/servers/eserver/zseries/zos/unix/bpxa1toy.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="26c38255249743d87d50270df89b2a9ebd2b4fd7" translate="yes" xml:space="preserve">
          <source>The zhuyin ordering includes some characters that are not CJK Unified Ideographs and can't utilize &lt;code&gt;weightZhuyin()&lt;/code&gt; for collation. For them, use &lt;code&gt;entry&lt;/code&gt; instead.</source>
          <target state="translated">注音符号の順序には、CJK統合漢字ではなく、照合に &lt;code&gt;weightZhuyin()&lt;/code&gt; を使用できない文字が含まれています。それらについては、代わりに &lt;code&gt;entry&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="f215722614928e4a382d634f12d1b784a861305a" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;$reg&lt;/code&gt; can be used as a regexp:</source>
          <target state="translated">次に、 &lt;code&gt;$reg&lt;/code&gt; を正規表現として使用できます。</target>
        </trans-unit>
        <trans-unit id="de5ca28d4aa169910f5c4821c56dad5137cddc68" translate="yes" xml:space="preserve">
          <source>Then again, you could always use parentheses.</source>
          <target state="translated">それからまた、いつでも括弧を使うことができます。</target>
        </trans-unit>
        <trans-unit id="8f720f0ca68279a1e213df21b730afd59a9417d5" translate="yes" xml:space="preserve">
          <source>Then along comes Unicode which has room for over a million characters (and Perl allows for even more). This means that a character may require more than a single byte to represent it, and so the two terms are no longer equivalent. What matter are the characters as whole entities, and not usually the bytes that comprise them. That's what the term &quot;Character Semantics&quot; in the title of this section refers to.</source>
          <target state="translated">その後、100万文字以上の文字を扱えるUnicodeが登場します(Perlではさらに多くの文字を扱えるようになっています)。これは、文字を表現するためには1バイト以上の文字が必要になる可能性があることを意味し、2つの用語はもはや等価ではありません。重要なのは、全体としての文字であり、通常は文字を構成するバイトではありません。このセクションのタイトルにある「文字セマンティクス」という用語は、このことを指しています。</target>
        </trans-unit>
        <trans-unit id="48ff6c17f5c4132eb7b4e146224751484821d774" translate="yes" xml:space="preserve">
          <source>Then compile:</source>
          <target state="translated">そしてコンパイルします。</target>
        </trans-unit>
        <trans-unit id="894eab3b8839b7526298878f8b7e43bb55872aae" translate="yes" xml:space="preserve">
          <source>Then copy setargv.obj to %PlatformSDKDir%\lib</source>
          <target state="translated">次に setargv.obj を %PlatformSDKDir%にコピーします。</target>
        </trans-unit>
        <trans-unit id="939d22a5767f7f1b738027999de54521a98a4c28" translate="yes" xml:space="preserve">
          <source>Then delete every .bundle file found anywhere in the folders:</source>
          <target state="translated">次に、フォルダ内のどこかにある.bundleファイルをすべて削除します。</target>
        </trans-unit>
        <trans-unit id="072381135845bbd0f86b6799cfa84f6d7fbff38f" translate="yes" xml:space="preserve">
          <source>Then go on to declare and use your variables in functions without any qualifications. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; and the &lt;a href=&quot;perlmodlib&quot;&gt;perlmodlib&lt;/a&gt; for details on mechanics and style issues in module creation.</source>
          <target state="translated">次に、修飾なしで関数内で変数を宣言して使用します。参照してください&lt;a href=&quot;exporter&quot;&gt;輸出業者&lt;/a&gt;と&lt;a href=&quot;perlmodlib&quot;&gt;はperlmodlib&lt;/a&gt;モジュールの作成に関する仕組みやスタイルに関する詳細について。</target>
        </trans-unit>
        <trans-unit id="0260e987a9bcfe5e51c92652bad4a0b41e5cc334" translate="yes" xml:space="preserve">
          <source>Then increment any of the dotted-decimal components (v1.20.1 or v1.21.0).</source>
          <target state="translated">次に、ドット小数点以下のコンポーネント(v1.20.1またはv1.21.0)のいずれかをインクリメントします。</target>
        </trans-unit>
        <trans-unit id="27efe9215ba97f3d69be224566771bce0e52d95d" translate="yes" xml:space="preserve">
          <source>Then make your changes. For example, if Leon Brocard changes his name to Orange Brocard, we should change his name in the AUTHORS file:</source>
          <target state="translated">そして、変更を行います。例えば、Leon BrocardがOrange Brocardに名前を変えた場合、authorsファイルの中の彼の名前を変更する必要があります。</target>
        </trans-unit>
        <trans-unit id="5bcffa804562972342cabda61bf0a405b76b432e" translate="yes" xml:space="preserve">
          <source>Then move the files (probably just the</source>
          <target state="translated">それからファイルを移動します(おそらく</target>
        </trans-unit>
        <trans-unit id="16764d0cdf61fb44dac45d466795c94ebcc324fb" translate="yes" xml:space="preserve">
          <source>Then override the &lt;code&gt;start_for&lt;/code&gt; method in the subclass to check for when &quot;$flags-&amp;gt;{'target'}&quot; is equal to 'foo' and set a flag that marks that you're in a foo block (maybe &quot;$self-&amp;gt;{'in_foo'} = 1&quot;). Then override the &lt;code&gt;handle_text&lt;/code&gt; method to check for the flag, and pass $text to your custom subroutine to construct the HTML output for 'foo' elements, something like:</source>
          <target state="translated">次に、サブクラスの &lt;code&gt;start_for&lt;/code&gt; メソッドをオーバーライドして、「$ flags- &amp;gt; {'target'}」が「foo」に等しいかどうかを確認し、fooブロックにいることを示すフラグを設定します（「$ self-&amp;gt; {'in_foo'} = 1 &quot;）。次に、 &lt;code&gt;handle_text&lt;/code&gt; メソッドをオーバーライドしてフラグを確認し、$ textをカスタムサブルーチンに渡して、次のような 'foo'要素のHTML出力を作成します。</target>
        </trans-unit>
        <trans-unit id="5906927423d13fecbc7d429a1e04d7524ab55ae4" translate="yes" xml:space="preserve">
          <source>Then run the following script (or something like it):</source>
          <target state="translated">そして、以下のスクリプト(もしくはそのようなもの)を実行します。</target>
        </trans-unit>
        <trans-unit id="dc813daf18229cd1ceaa147ef073875823c78936" translate="yes" xml:space="preserve">
          <source>Then that text and all remaining text up through and including a line beginning with &lt;code&gt;=cut&lt;/code&gt; will be ignored. The format of the intervening text is described in &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;.</source>
          <target state="translated">次に、そのテキストと、 &lt;code&gt;=cut&lt;/code&gt; で始まる行までの残りのすべてのテキストは無視されます。介在するテキストのフォーマットは&lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;で説明されています。</target>
        </trans-unit>
        <trans-unit id="8606c2212e120ef5c1865576f0176c5b8ada5faa" translate="yes" xml:space="preserve">
          <source>Then the assignment with the indirection on the left-hand-side would use the existing reference that was already there:</source>
          <target state="translated">そうすると、左側のインダイレクトを使った代入は、すでにあった既存の参照を使うことになります。</target>
        </trans-unit>
        <trans-unit id="8207f190aea8ef5aad0fa43cccb20c94bdffd926" translate="yes" xml:space="preserve">
          <source>Then the handler makes absolutely no attempt to interpret the data it receives and simply passes it as a string:</source>
          <target state="translated">この場合、ハンドラは受信したデータを解釈しようとは一切せず、単に文字列として渡します。</target>
        </trans-unit>
        <trans-unit id="724e763cfec8edb999475aec0cbf98b0b938163f" translate="yes" xml:space="preserve">
          <source>Then the match is executed and the remaining lines describe the process:</source>
          <target state="translated">その後、マッチが実行され、残りの行で処理を説明します。</target>
        </trans-unit>
        <trans-unit id="41718c26f8da915843d6b183e2c76ef5e3a2e26d" translate="yes" xml:space="preserve">
          <source>Then to use it:</source>
          <target state="translated">そして、それを使うために。</target>
        </trans-unit>
        <trans-unit id="581e9b63d178af7824ad52db20f4431ce7a1a3ec" translate="yes" xml:space="preserve">
          <source>Then use any of those as you would a normal filehandle. Anywhere that Perl is expecting a filehandle, an indirect filehandle may be used instead. An indirect filehandle is just a scalar variable that contains a filehandle. Functions like &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, or the &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; diamond operator will accept either a named filehandle or a scalar variable containing one:</source>
          <target state="translated">次に、通常のファイルハンドルと同じようにそれらのいずれかを使用します。Perlがファイルハンドルを期待しているところならどこでも、代わりに間接ファイルハンドルを使用できます。間接ファイルハンドルは、ファイルハンドルを含む単なるスカラー変数です。 &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; 、または &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; ダイヤモンド演算子のような関数は、名前付きファイルハンドルまたはそれを含むスカラー変数のいずれかを受け入れます。</target>
        </trans-unit>
        <trans-unit id="1cf2cb2bbe0265bf12a87e03d2ba1a967297063a" translate="yes" xml:space="preserve">
          <source>Then use any of those as you would a normal filehandle. Anywhere that Perl is expecting a filehandle, an indirect filehandle may be used instead. An indirect filehandle is just a scalar variable that contains a filehandle. Functions like &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;seek&lt;/code&gt;, or the &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; diamond operator will accept either a named filehandle or a scalar variable containing one:</source>
          <target state="translated">次に、通常のファイルハンドルと同じようにそれらのいずれかを使用します。Perlがファイルハンドルを期待しているところならどこでも、代わりに間接ファイルハンドルを使用することができます。間接ファイルハンドルは、ファイルハンドルを含む単なるスカラー変数です。 &lt;code&gt;print&lt;/code&gt; 、 &lt;code&gt;open&lt;/code&gt; 、 &lt;code&gt;seek&lt;/code&gt; 、または &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; ダイヤモンド演算子などの関数は、名前付きファイルハンドルまたは1つを含むスカラー変数のいずれかを受け入れます。</target>
        </trans-unit>
        <trans-unit id="be01a69ef7dc497f6d53fec0422df0742cb41c46" translate="yes" xml:space="preserve">
          <source>Then use it like:</source>
          <target state="translated">ならば、このように使いましょう。</target>
        </trans-unit>
        <trans-unit id="ac583abd9dd0b62af4de435d7d5497c2d6ffcb6a" translate="yes" xml:space="preserve">
          <source>Then we have to give each character a unique ID so your computer can tell the difference between 'a' and 'A'. This itemized character repertoire is now a</source>
          <target state="translated">それから各キャラクターに固有のIDを与えてコンピュータが'a'と'A'の違いを見分けられるようにしなければなりません。この項目化された文字のレパートリーは</target>
        </trans-unit>
        <trans-unit id="3068081feb5a0d3d89b7875b7ddf972f866ffeca" translate="yes" xml:space="preserve">
          <source>Then when you call $lh-&amp;gt;maketext(</source>
          <target state="translated">次に、$ lh-&amp;gt; maketext（</target>
        </trans-unit>
        <trans-unit id="ef2df7391bceda4d0a67009f959c0d587bbf6bd2" translate="yes" xml:space="preserve">
          <source>Then you can merge it into master like this:</source>
          <target state="translated">そして、このようにマスターにマージすることができます。</target>
        </trans-unit>
        <trans-unit id="4174f8d83f029a8fa078cc1b0e4b602d5427b4d7" translate="yes" xml:space="preserve">
          <source>Then you can progress through any remaining notable Unicode characters in the range 0x2000-0x204D (consult the character tables at www.unicode.org), and whatever else strikes your fancy. For example, in</source>
          <target state="translated">それから、0x2000-0x204D の範囲にある残りの注目すべき Unicode キ ャ ラ ク タ (www.unicode.org の文字表を参照して く ださい)や、 他にも気になるものがあれば何で も 進んでいけます。例えば</target>
        </trans-unit>
        <trans-unit id="84a1243ca0e6b4d4a37040b980b310d461ab4076" translate="yes" xml:space="preserve">
          <source>Then you can use &lt;code&gt;FH&lt;/code&gt; as the filehandle, in &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; and &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; and so on. Note that it's a global variable, so this form is not recommended in new code.</source>
          <target state="translated">次に、 &lt;code&gt;FH&lt;/code&gt; をファイルハンドルとして使用し、 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; と &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; を&lt;a href=&quot;close&quot;&gt;閉じる&lt;/a&gt;ことができます。これはグローバル変数であるため、このコードは新しいコードでは推奨されていません。</target>
        </trans-unit>
        <trans-unit id="c81a39d78bb4e09ef8b273b017dac3466493479a" translate="yes" xml:space="preserve">
          <source>Then you can use &lt;code&gt;FH&lt;/code&gt; as the filehandle, in &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; and &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; and so on. Note that it's a global variable, so this form is not recommended in new code.</source>
          <target state="translated">次に、 &lt;code&gt;FH&lt;/code&gt; をファイルハンドルとして使用し、 &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt; FH&lt;/code&gt; と &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; を&lt;a href=&quot;functions/close&quot;&gt;閉じる&lt;/a&gt;ことができます。これはグローバル変数であるため、このコードは新しいコードでは推奨されていません。</target>
        </trans-unit>
        <trans-unit id="8845af43a427cd30379b447f56ac8ef63aa6a453" translate="yes" xml:space="preserve">
          <source>Then you can use &lt;code&gt;FH&lt;/code&gt; as the filehandle, in &lt;code&gt;close FH&lt;/code&gt; and &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; and so on. Note that it's a global variable, so this form is not recommended when dealing with filehandles other than Perl's built-in ones (e.g. STDOUT and STDIN).</source>
          <target state="translated">次に、 &lt;code&gt;FH&lt;/code&gt; をファイルハンドルとして使用したり、 &lt;code&gt;close FH&lt;/code&gt; や &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; を閉じたりすることができます。これはグローバル変数であるため、Perlの組み込みファイル以外のファイルハンドル（STDOUTやSTDINなど）を処理する場合は、この形式はお勧めしません。</target>
        </trans-unit>
        <trans-unit id="aceabb34e67cf540951bd4247eacd0dbbabee283" translate="yes" xml:space="preserve">
          <source>Then you'll need to know how to manipulate the Perl stack. That's described in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;.</source>
          <target state="translated">次に、Perlスタックを操作する方法を知る必要があります。これは&lt;a href=&quot;perlcall&quot;&gt;perlcallで&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="a9e623e714cffb21ba3a72f8e67c6ce57fe9270e" translate="yes" xml:space="preserve">
          <source>Then you'll need to pass the &lt;code&gt;nocase&lt;/code&gt; option in order to recognize &quot;Name&quot;:</source>
          <target state="translated">次に、「名前」を認識するために &lt;code&gt;nocase&lt;/code&gt; オプションを渡す必要があります。</target>
        </trans-unit>
        <trans-unit id="5eea4f63f47d5b222c66289e4dec5701bc66810a" translate="yes" xml:space="preserve">
          <source>Then you've just supplied an automatic &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; in front of their argument, which can be more than a bit surprising. The old &lt;code&gt;@foo&lt;/code&gt; which used to hold one thing doesn't get passed in. Instead, &lt;code&gt;func()&lt;/code&gt; now gets passed in a &lt;code&gt;1&lt;/code&gt; ; that is, the number of elements in &lt;code&gt;@foo&lt;/code&gt; . And the &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; gets called in scalar context so it starts scribbling on your &lt;code&gt;@_&lt;/code&gt; parameter list. Ouch!</source>
          <target state="translated">次に、それらの引数の前に自動 &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; を指定しましたが、これは少し驚くべきことです。1つのものを保持するために使用されていた古い &lt;code&gt;@foo&lt;/code&gt; は渡されません。代わりに、 &lt;code&gt;func()&lt;/code&gt; は &lt;code&gt;1&lt;/code&gt; に渡されます。つまり、 &lt;code&gt;@foo&lt;/code&gt; の要素数です。そして、 &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; はスカラーコンテキストで呼び出されるため、 &lt;code&gt;@_&lt;/code&gt; パラメーターリストで落書きが開始されます。痛い！</target>
        </trans-unit>
        <trans-unit id="b0ba92bfa9d677231987d2b57b0a01cd1852383d" translate="yes" xml:space="preserve">
          <source>Then you've just supplied an automatic &lt;code&gt;scalar&lt;/code&gt; in front of their argument, which can be more than a bit surprising. The old &lt;code&gt;@foo&lt;/code&gt; which used to hold one thing doesn't get passed in. Instead, &lt;code&gt;func()&lt;/code&gt; now gets passed in a &lt;code&gt;1&lt;/code&gt;; that is, the number of elements in &lt;code&gt;@foo&lt;/code&gt;. And the &lt;code&gt;m//g&lt;/code&gt; gets called in scalar context so instead of a list of words it returns a boolean result and advances &lt;code&gt;pos($text)&lt;/code&gt;. Ouch!</source>
          <target state="translated">次に、引数の前に自動 &lt;code&gt;scalar&lt;/code&gt; を指定しました。これは少し驚くべきことです。以前は1つのものを保持していた古い &lt;code&gt;@foo&lt;/code&gt; は渡されません。代わりに、 &lt;code&gt;func()&lt;/code&gt; は &lt;code&gt;1&lt;/code&gt; で渡されるようになりました。つまり、 &lt;code&gt;@foo&lt;/code&gt; の要素の数です。また、 &lt;code&gt;m//g&lt;/code&gt; はスカラーコンテキストで呼び出されるため、単語のリストの代わりにブール結果を返し、 &lt;code&gt;pos($text)&lt;/code&gt; を進めます。痛い！</target>
        </trans-unit>
        <trans-unit id="1d2223d4e367bda9f7a187be5ce1bdedd21df546" translate="yes" xml:space="preserve">
          <source>Then your Russian translator calls on the phone, to</source>
          <target state="translated">それからロシア語の翻訳者が電話をかけてきて</target>
        </trans-unit>
        <trans-unit id="ee85b5d75e24b7f6cf7782bfc085bcfc0c87d6f5" translate="yes" xml:space="preserve">
          <source>Then, it determines the class and method name of the context it was invoked from.</source>
          <target state="translated">そして、呼び出されたコンテキストのクラス名とメソッド名を決定します。</target>
        </trans-unit>
        <trans-unit id="6c23388be94a600da1203bed601e75b409a6b29f" translate="yes" xml:space="preserve">
          <source>Then, push your new branch to your fork.</source>
          <target state="translated">そして、新しいブランチをフォークに押してください。</target>
        </trans-unit>
        <trans-unit id="c5bc01ce529788e374ab9bf2dcdef9e77b7d91a8" translate="yes" xml:space="preserve">
          <source>There (probably) should be a semicolon at the end of the opening token</source>
          <target state="translated">冒頭のトークンの最後にはセミコロンがあるはずです。</target>
        </trans-unit>
        <trans-unit id="4d80e1f2d5ca1daef620a79f94100cd3a43dcad2" translate="yes" xml:space="preserve">
          <source>There appears to be a bug in the floating point implementation on BS2000 POSIX systems such that calling int() on the product of a number and a small magnitude number is not the same as calling int() on the quotient of that number and a large magnitude number. For example, in the following Perl code:</source>
          <target state="translated">BS2000 POSIX システムでの浮動小数点の実装にバグがあるようで、数値と小さい等級の数値の積で int()を呼び出すと、その数値の商と大きい等級の数値の商で int()を呼び出すのと同じではありません。例えば、以下のPerlのコードでは</target>
        </trans-unit>
        <trans-unit id="bb6e61aa6502fa98f73e845b088e443cab1a90e3" translate="yes" xml:space="preserve">
          <source>There appears to be a bug in the floating point implementation on S/390 systems such that calling int() on the product of a number and a small magnitude number is not the same as calling int() on the quotient of that number and a large magnitude number. For example, in the following Perl code:</source>
          <target state="translated">S/390 システムでの浮動小数点の実装にバグがあるようで、数値と小さい等級の数値の積で int()を呼び出すと、その数値の商と大きい等級の数値の商で int()を呼び出すのと同じではありません。例えば、以下のPerlのコードでは</target>
        </trans-unit>
        <trans-unit id="4eb2187ac5dc9a4b6af234beb08ab0fae2350bcf" translate="yes" xml:space="preserve">
          <source>There are 2 types of hooks, init hooks, and release hooks. As the names suggest, these hooks are triggered when contexts are created or released.</source>
          <target state="translated">フックには init フックと release フックの 2 種類があります。名前が示すように、これらのフックはコンテキストが作成されたり解放されたりしたときにトリガーされます。</target>
        </trans-unit>
        <trans-unit id="de1cfe28fcf075678633050ad3a49243fab1a122" translate="yes" xml:space="preserve">
          <source>There are 3 kinds of items that may be populated; special patterns, #vars, and literal text, which is copied verbatim. (Yes, it's a set of s///g steps.)</source>
          <target state="translated">ポップアップされる可能性のある項目は、特殊パターン、#vars、リテラルテキストの3種類で、これを逐語的にコピーしたものです。(そう、s///gのステップがセットになっているのです)。</target>
        </trans-unit>
        <trans-unit id="6e9231df83ad3f347c0bf53efa7fd0781ae7adef" translate="yes" xml:space="preserve">
          <source>There are &lt;code&gt;lint&lt;/code&gt; and &amp;lt;splint&amp;gt; targets in Makefile, but you may have to diddle with the flags (see above).</source>
          <target state="translated">Makefileには &lt;code&gt;lint&lt;/code&gt; ターゲットと&amp;lt;splint&amp;gt;ターゲットがありますが、フラグを上手く操作しなければならない場合があります（上記を参照）。</target>
        </trans-unit>
        <trans-unit id="fe9ce8188c03cc1c80382377cc03bbf3d1eefe6b" translate="yes" xml:space="preserve">
          <source>There are DECC feature logical names AND ODS-5 volume attributes that also control what values are returned for the date fields.</source>
          <target state="translated">DECC 機能の論理名と ODS-5 ボリューム属性があり、日付フィールドに返される値も制御します。</target>
        </trans-unit>
        <trans-unit id="153a01ed3dca851e07404e7b116e0f624fedd9d4" translate="yes" xml:space="preserve">
          <source>There are a couple of exceptions to the above rule. &lt;code&gt;\N{U+&lt;i&gt;hex number&lt;/i&gt;}&lt;/code&gt; is always interpreted as a Unicode code point, so that &lt;code&gt;\N{U+0050}&lt;/code&gt; is &lt;code&gt;&quot;P&quot;&lt;/code&gt; even on EBCDIC platforms. And if &lt;code&gt;&lt;a href=&quot;encoding&quot;&gt;use encoding&lt;/a&gt;&lt;/code&gt; is in effect, the number is considered to be in that encoding, and is translated from that into the platform's native encoding if there is a corresponding native character; otherwise to Unicode.</source>
          <target state="translated">上記の規則にはいくつかの例外があります。 &lt;code&gt;\N{U+&lt;i&gt;hex number&lt;/i&gt;}&lt;/code&gt; は常にUnicodeコードポイントとして解釈されるため、EBCDICプラットフォームでも &lt;code&gt;\N{U+0050}&lt;/code&gt; は &lt;code&gt;&quot;P&quot;&lt;/code&gt; なります。そして、 &lt;code&gt;&lt;a href=&quot;encoding&quot;&gt;use encoding&lt;/a&gt;&lt;/code&gt; が有効な場合、数値はそのエンコーディングにあると見なされ、対応するネイティブ文字がある場合は、そのエンコーディングからプラットフォームのネイティブエンコーディングに変換されます。それ以外の場合はUnicode。</target>
        </trans-unit>
        <trans-unit id="4e415da7b1ad793f82f6c66993b6dabfb03be0ae" translate="yes" xml:space="preserve">
          <source>There are a couple of macros to do very basic exception handling in XS modules. You have to define &lt;code&gt;NO_XSLOCKS&lt;/code&gt; before including</source>
          <target state="translated">XSモジュールで非常に基本的な例外処理を行うマクロがいくつかあります。 &lt;code&gt;NO_XSLOCKS&lt;/code&gt; 前にNO_XSLOCKSを定義する必要があります</target>
        </trans-unit>
        <trans-unit id="b559285d4827f1039158fa6a1c7be09bcea8695c" translate="yes" xml:space="preserve">
          <source>There are a couple of other symbols that you're likely to encounter that aren't really type specifiers:</source>
          <target state="translated">他にも、実際には型指定子ではない記号がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="cd28f27e3e26acb88f426d59ef73cb49b8748e10" translate="yes" xml:space="preserve">
          <source>There are a couple of special arrays too, such as &lt;code&gt;@ARGV&lt;/code&gt; (the command line arguments to your script) and &lt;code&gt;@_&lt;/code&gt; (the arguments passed to a subroutine). These are documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@ARGV&lt;/code&gt; （スクリプトへのコマンドライン引数）や &lt;code&gt;@_&lt;/code&gt; （サブルーチンに渡される引数）など、いくつかの特別な配列もあります。これらは&lt;a href=&quot;perlvar&quot;&gt;perlvarに&lt;/a&gt;文書化されています。</target>
        </trans-unit>
        <trans-unit id="d71c568688cddeb0974cf4c64aacf00c4a7ae0fc" translate="yes" xml:space="preserve">
          <source>There are a couple of things to note about this analysis. First, the third alternative in the second group 'de' also allows a match, but we stopped before we got to it - at a given character position, leftmost wins. Second, we were able to get a match at the first character position of the string 'a'. If there were no matches at the first position, Perl would move to the second character position 'b' and attempt the match all over again. Only when all possible paths at all possible character positions have been exhausted does Perl give up and declare &lt;code&gt;$string =~ /(abd|abc)(df|d|de)/;&lt;/code&gt; to be false.</source>
          <target state="translated">この分析について注意すべき点がいくつかあります。まず、2番目のグループ「de」の3番目の選択肢も一致を許可しますが、それに到達する前に停止しました-特定のキャラクターの位置で、左端が勝利します。次に、文字列「a」の最初の文字位置で一致を取得できました。最初の位置に一致するものがなかった場合、Perlは2番目の文字位置「b」に移動して、もう一度一致を試みます。すべての可能な文字位置ですべての可能なパスが使い果たされた場合にのみ、Perlは &lt;code&gt;$string =~ /(abd|abc)(df|d|de)/;&lt;/code&gt; をあきらめて宣言します。偽りである。</target>
        </trans-unit>
        <trans-unit id="deb5e7398add69ec1651990d98a23a3300e8eb2d" translate="yes" xml:space="preserve">
          <source>There are a couple of things to note about this analysis. First, the third alternative in the second group &lt;code&gt;'de'&lt;/code&gt; also allows a match, but we stopped before we got to it - at a given character position, leftmost wins. Second, we were able to get a match at the first character position of the string &lt;code&gt;'a'&lt;/code&gt;. If there were no matches at the first position, Perl would move to the second character position &lt;code&gt;'b'&lt;/code&gt; and attempt the match all over again. Only when all possible paths at all possible character positions have been exhausted does Perl give up and declare &lt;code&gt;$string =~ /(abd|abc)(df|d|de)/;&lt;/code&gt; to be false.</source>
          <target state="translated">この分析について注意すべき点がいくつかあります。まず、2番目のグループ &lt;code&gt;'de'&lt;/code&gt; の3番目の選択肢でも一致が許可されますが、それに到達する前に停止しました。特定の文字位置で、左端が勝ちます。次に、文字列 &lt;code&gt;'a'&lt;/code&gt; の最初の文字位置で一致を取得することができました。最初の位置に一致がなかった場合、Perlは2番目の文字位置 &lt;code&gt;'b'&lt;/code&gt; に移動し、もう一度一致を試みます。すべての可能な文字位置ですべての可能なパスが使い果たされた場合にのみ、Perlはあきらめて &lt;code&gt;$string =~ /(abd|abc)(df|d|de)/;&lt;/code&gt; を宣言します。偽りである。</target>
        </trans-unit>
        <trans-unit id="39aecaa3926975713f4a2a65afbfb40347095ccc" translate="yes" xml:space="preserve">
          <source>There are a couple of ways that you can process an entire hash. You can get a list of keys, then go through each key, or grab a one key-value pair at a time.</source>
          <target state="translated">ハッシュ全体を処理する方法はいくつかあります。キーのリストを取得して、それぞれのキーを通過させることもできますし、一度に一つのキーと値のペアを取得することもできます。</target>
        </trans-unit>
        <trans-unit id="af13ea056584d18f28105e6dfb4305dd6e1f93f8" translate="yes" xml:space="preserve">
          <source>There are a few basic principles which define object oriented Perl:</source>
          <target state="translated">オブジェクト指向Perlを定義するいくつかの基本的な原則があります。</target>
        </trans-unit>
        <trans-unit id="6ad0df8b5bb1240ec34f94939aa27ca4c87aa9d3" translate="yes" xml:space="preserve">
          <source>There are a few exceptions though: &lt;code&gt;x&lt;/code&gt; can be either string repetition or list repetition, depending on the type of the left operand, and &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; can be either string or numeric bit operations.</source>
          <target state="translated">：そこいくつかの例外はあるものの &lt;code&gt;x&lt;/code&gt; 、左のオペランドのタイプに応じて、いずれかの文字列の繰り返しやリスト反復することができ、そして &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; 、 &lt;code&gt;^&lt;/code&gt; および &lt;code&gt;~&lt;/code&gt; は、文字列または数値のビット演算のいずれかです。</target>
        </trans-unit>
        <trans-unit id="90c71cfbe20f7e4576d0df45674b3d041e6521fa" translate="yes" xml:space="preserve">
          <source>There are a few exceptions though: &lt;code&gt;x&lt;/code&gt; can be either string repetition or list repetition, depending on the type of the left operand, and &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; can be either string or numeric bit operations.</source>
          <target state="translated">ただし、いくつかの例外があります &lt;code&gt;x&lt;/code&gt; は、左側のオペランドのタイプに応じて、文字列の繰り返しまたはリストの繰り返しのいずれかになります。 &lt;code&gt;&amp;amp;&lt;/code&gt; 、 &lt;code&gt;|&lt;/code&gt; 、 &lt;code&gt;^&lt;/code&gt; および &lt;code&gt;~&lt;/code&gt; は、文字列または数値ビット演算のいずれかです。</target>
        </trans-unit>
        <trans-unit id="5a7bb479453f1e1c0fcfea035067e079420f6246" translate="yes" xml:space="preserve">
          <source>There are a few more things you might want to know about matching operators. The global modifier &lt;code&gt;//g&lt;/code&gt; allows the matching operator to match within a string as many times as possible. In scalar context, successive matches against a string will have &lt;code&gt;//g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; function. For example,</source>
          <target state="translated">一致する演算子について知りたいことがいくつかあります。グローバル修飾子 &lt;code&gt;//g&lt;/code&gt; を使用すると、一致演算子は文字列内で可能な限り多く一致できます。スカラーコンテキストでは、文字列に対して連続して一致すると、文字列内の位置を追跡しながら &lt;code&gt;//g&lt;/code&gt; が一致から一致にジャンプします。 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; 関数で位置を取得または設定できます。例えば、</target>
        </trans-unit>
        <trans-unit id="21076df5229fe033ea741a2399501b4983daa45a" translate="yes" xml:space="preserve">
          <source>There are a few more things you might want to know about matching operators. The global modifier &lt;code&gt;/g&lt;/code&gt; allows the matching operator to match within a string as many times as possible. In scalar context, successive matches against a string will have &lt;code&gt;/g&lt;/code&gt; jump from match to match, keeping track of position in the string as it goes along. You can get or set the position with the &lt;code&gt;pos()&lt;/code&gt; function. For example,</source>
          <target state="translated">マッチング演算子について知りたいことがいくつかあります。グローバル修飾子 &lt;code&gt;/g&lt;/code&gt; を使用すると、一致演算子を文字列内で可能な限り何度も一致させることができます。スカラーコンテキストでは、文字列に対する連続した一致では、 &lt;code&gt;/g&lt;/code&gt; が一致から一致にジャンプし、文字列内の位置を追跡します。 &lt;code&gt;pos()&lt;/code&gt; 関数を使用して位置を取得または設定できます。例えば、</target>
        </trans-unit>
        <trans-unit id="4300a240e517c8a51298a8d027c6fc76723dcec0" translate="yes" xml:space="preserve">
          <source>There are a few point to bear in mind if you want to change the ordering in a BTREE database:</source>
          <target state="translated">BTREEデータベースで順序を変更したい場合は、いくつかの注意点があります。</target>
        </trans-unit>
        <trans-unit id="7b1086e8333561d2682eac30f860ad2422dfc42d" translate="yes" xml:space="preserve">
          <source>There are a few things to bear in mind when creating your own &lt;code&gt;ResultFactory&lt;/code&gt; :</source>
          <target state="translated">独自の &lt;code&gt;ResultFactory&lt;/code&gt; を作成するときは、次の点に注意してください。</target>
        </trans-unit>
        <trans-unit id="de8a54b9295025b3c139573926386493cb554215" translate="yes" xml:space="preserve">
          <source>There are a few things to bear in mind when creating your own &lt;code&gt;ResultFactory&lt;/code&gt;:</source>
          <target state="translated">独自の &lt;code&gt;ResultFactory&lt;/code&gt; を作成する際に留意すべき点がいくつかあります。</target>
        </trans-unit>
        <trans-unit id="378f2e66966b2788636abfdbe2bc87b5abb48ea4" translate="yes" xml:space="preserve">
          <source>There are a few things you need to know, however:</source>
          <target state="translated">しかし、知っておいてほしいことがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="52b3f437a68cd4b70bf1c33277b0b324dc172b8a" translate="yes" xml:space="preserve">
          <source>There are a handful of cases where a tool author may want to create a new context by hand, which is why the &lt;code&gt;new&lt;/code&gt; method exists. Unless you really know what you are doing you should avoid this.</source>
          <target state="translated">ツールの作成者が新しいコンテキストを手動で作成したい場合がいくつかあります。そのため、 &lt;code&gt;new&lt;/code&gt; メソッドが存在します。自分が何をしているのかを本当に理解していない限り、これは避けるべきです。</target>
        </trans-unit>
        <trans-unit id="291c6f1e95cd386fbf1435fa808c577724438440" translate="yes" xml:space="preserve">
          <source>There are a lot of modules on CPAN, and it's easy to miss one that's similar to what you're planning on contributing. Have a good plough through &lt;a href=&quot;http://metacpan.org&quot;&gt;http://metacpan.org&lt;/a&gt; and make sure you're not the one reinventing the wheel!</source>
          <target state="translated">CPANにはたくさんのモジュールがあり、あなたが貢献しようとしているものに似たものを見逃しがちです。&lt;a href=&quot;http://metacpan.org&quot;&gt;http://metacpan.org&lt;/a&gt;をよく調べて、自分が車輪の再発明をしているのではないことを確認してください。</target>
        </trans-unit>
        <trans-unit id="9cbfb29c30b87800b111898e71e11f4933f270fc" translate="yes" xml:space="preserve">
          <source>There are a lot of modules on CPAN, and it's easy to miss one that's similar to what you're planning on contributing. Have a good plough through the &lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt; and make sure you're not the one reinventing the wheel!</source>
          <target state="translated">CPANには多くのモジュールがあり、コントリビューションを計画しているものに似ているものは見落としがちです。良い鋤を持って&lt;a href=&quot;http://search.cpan.org&quot;&gt;http://search.cpan.org&lt;/a&gt;し、あなたが車輪の再発明1じゃない作ります！</target>
        </trans-unit>
        <trans-unit id="8202fc94e9abdf77b0bbe8e0da596aca565bfbf9" translate="yes" xml:space="preserve">
          <source>There are a number of &quot;magic&quot; scalars with names that look like punctuation or line noise. These special variables are used for all kinds of purposes, and are documented in &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;. The only one you need to know about for now is &lt;code&gt;$_&lt;/code&gt; which is the &quot;default variable&quot;. It's used as the default argument to a number of functions in Perl, and it's set implicitly by certain looping constructs.</source>
          <target state="translated">句読点やラインノイズのような名前の「魔法の」スカラーがいくつかあります。これらの特殊変数はあらゆる目的で使用され、&lt;a href=&quot;perlvar&quot;&gt;perlvarに&lt;/a&gt;記載されています。今のところ知っておく必要があるのは、「デフォルトの変数」である &lt;code&gt;$_&lt;/code&gt; です。これは、Perlの多くの関数のデフォルト引数として使用され、特定のループ構造によって暗黙的に設定されます。</target>
        </trans-unit>
        <trans-unit id="bbba855a854345636dbf0d940dc495c0ac9b2bb4" translate="yes" xml:space="preserve">
          <source>There are a number of Unicode characters that match a sequence of multiple characters under &lt;code&gt;/i&lt;/code&gt;. For example, &lt;code&gt;LATIN SMALL LIGATURE FI&lt;/code&gt; should match the sequence &lt;code&gt;fi&lt;/code&gt;. Perl is not currently able to do this when the multiple characters are in the pattern and are split between groupings, or when one or more are quantified. Thus</source>
          <target state="translated">&lt;code&gt;/i&lt;/code&gt; の下の複数の文字のシーケンスに一致するUnicode文字がいくつかあります。たとえば、 &lt;code&gt;LATIN SMALL LIGATURE FI&lt;/code&gt; はシーケンス &lt;code&gt;fi&lt;/code&gt; と一致する必要があります。現在、Perlは、複数の文字がパターン内にあり、グループ間で分割されている場合、または1つ以上が定量化されている場合、これを行うことができません。したがって、</target>
        </trans-unit>
        <trans-unit id="6fc3a0395d03ea21a961b5ccde55199ca19344c6" translate="yes" xml:space="preserve">
          <source>There are a number of Unicode characters that match multiple characters under &lt;code&gt;/i&lt;/code&gt;. For example, &lt;code&gt;LATIN SMALL LIGATURE FI&lt;/code&gt; should match the sequence &lt;code&gt;fi&lt;/code&gt; . Perl is not currently able to do this when the multiple characters are in the pattern and are split between groupings, or when one or more are quantified. Thus</source>
          <target state="translated">&lt;code&gt;/i&lt;/code&gt; の下の複数の文字に一致するUnicode文字がいくつかあります。たとえば、 &lt;code&gt;LATIN SMALL LIGATURE FI&lt;/code&gt; はシーケンス &lt;code&gt;fi&lt;/code&gt; と一致する必要があります。Perlは現在、複数の文字がパターン内にあり、グループ間で分割されている場合、または1つ以上が数量化されている場合、これを行うことができません。したがって</target>
        </trans-unit>
        <trans-unit id="3dd2d0257d19015791fc17037d18a20e756ba477" translate="yes" xml:space="preserve">
          <source>There are a number of escape sequences and character classes that we haven't covered yet.</source>
          <target state="translated">まだ取り上げていないエスケープシーケンスやキャラクタークラスがたくさんあります。</target>
        </trans-unit>
        <trans-unit id="58e8ff088e1d138c7e62589f4caba0154e035619" translate="yes" xml:space="preserve">
          <source>There are a number of flags that can be found at the end of regular expression constructs that are</source>
          <target state="translated">正規表現の構築物の最後には、以下のようなフラグがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="9c8583e91f1bbf24b33308cfc971070d355cbca1" translate="yes" xml:space="preserve">
          <source>There are a number of issues with regard to case-insensitive matching in Unicode rules. See &lt;code&gt;&quot;i&quot;&lt;/code&gt; under &lt;a href=&quot;#Modifiers&quot;&gt;&quot;Modifiers&quot;&lt;/a&gt; above.</source>
          <target state="translated">Unicodeルールでは、大文字と小文字を区別しないマッチングに関して多くの問題があります。上記の&lt;a href=&quot;#Modifiers&quot;&gt;「修飾子&lt;/a&gt; &lt;code&gt;&quot;i&quot;&lt;/code&gt; 下の「i」を参照してください。</target>
        </trans-unit>
        <trans-unit id="9135b7f56d303db71c9d18be0e91860f32c7ff91" translate="yes" xml:space="preserve">
          <source>There are a number of issues with regard to case-insensitive matching in Unicode rules. See &lt;code&gt;i&lt;/code&gt; under &lt;a href=&quot;#Modifiers&quot;&gt;Modifiers&lt;/a&gt; above.</source>
          <target state="translated">Unicodeルールの大文字と小文字を区別しないマッチングに関しては、いくつかの問題があります。上記の&lt;a href=&quot;#Modifiers&quot;&gt;修飾子の&lt;/a&gt;下の &lt;code&gt;i&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="022096dd663fb452b1d41c016ae62776dae4f673" translate="yes" xml:space="preserve">
          <source>There are a number of limits on the size of the data that you can store in the NDBM file. The most important is that the length of a key, plus the length of its associated value, may not exceed 1008 bytes.</source>
          <target state="translated">NDBMファイルに格納できるデータのサイズにはいくつかの制限がある。最も重要なのは、キーの長さに関連する値の長さを加えた長さが1008バイトを超えてはならないということである。</target>
        </trans-unit>
        <trans-unit id="98194cdd08210646c306ab64213d7decc3e2f871" translate="yes" xml:space="preserve">
          <source>There are a number of limits on the size of the data that you can store in the ODBM file. The most important is that the length of a key, plus the length of its associated value, may not exceed 1008 bytes.</source>
          <target state="translated">ODBMファイルに格納できるデータのサイズにはいくつかの制限がある。最も重要なのは、キーの長さに関連する値の長さを加えた長さが1008バイトを超えてはならないということである。</target>
        </trans-unit>
        <trans-unit id="72d53d5198c98896d8e7795e9a89c4a433023428" translate="yes" xml:space="preserve">
          <source>There are a number of limits on the size of the data that you can store in the SDBM file. The most important is that the length of a key, plus the length of its associated value, may not exceed 1008 bytes.</source>
          <target state="translated">SDBMファイルに格納できるデータのサイズにはいくつかの制限がある。最も重要なのは、キーの長さに関連する値の長さを加えた長さが1008バイトを超えてはならないということである。</target>
        </trans-unit>
        <trans-unit id="52efe033e2beba5914060b25e959b1d5bcc3adec" translate="yes" xml:space="preserve">
          <source>There are a number of modules which let you write GUIs in Perl. Most GUI toolkits have a perl interface: an incomplete list follows.</source>
          <target state="translated">PerlでGUIを書くためのモジュールがいくつかあります。ほとんどの GUI ツールキットは perl インターフェースを持っています。</target>
        </trans-unit>
        <trans-unit id="7c6653dd731ed3a59a2ee9aba20887a251e28fb4" translate="yes" xml:space="preserve">
          <source>There are a number of new concepts introduced here, described below:</source>
          <target state="translated">ここで紹介する新しい概念は、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="5042e54e451264a1c914a632ba72877f3d1fb724" translate="yes" xml:space="preserve">
          <source>There are a number of other limitations with the &lt;code&gt;Merge&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;Merge&lt;/code&gt; オプションには、他にもいくつかの制限があります。</target>
        </trans-unit>
        <trans-unit id="7b02972f75c4a57c97baf269f0fc3720b5f2bc53" translate="yes" xml:space="preserve">
          <source>There are a number of reasons that you might prefer &lt;code&gt;Tie::File&lt;/code&gt; . A list is available at &lt;code&gt;&lt;a href=&quot;http://perl.plover.com/TieFile/why-not-DB_File&quot;&gt;http://perl.plover.com/TieFile/why-not-DB_File&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tie::File&lt;/code&gt; を選択する理由はいくつかあります。リストは &lt;code&gt;&lt;a href=&quot;http://perl.plover.com/TieFile/why-not-DB_File&quot;&gt;http://perl.plover.com/TieFile/why-not-DB_File&lt;/a&gt;&lt;/code&gt; で入手できます。</target>
        </trans-unit>
        <trans-unit id="13eb2afa7bef68b0d1a21f81cf96c931809f02f6" translate="yes" xml:space="preserve">
          <source>There are a number of reasons that you might prefer &lt;code&gt;Tie::File&lt;/code&gt;. A list is available at &lt;code&gt;&lt;a href=&quot;http://perl.plover.com/TieFile/why-not-DB_File&quot;&gt;http://perl.plover.com/TieFile/why-not-DB_File&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tie::File&lt;/code&gt; 好む理由はいくつかあります。リストは &lt;code&gt;&lt;a href=&quot;http://perl.plover.com/TieFile/why-not-DB_File&quot;&gt;http://perl.plover.com/TieFile/why-not-DB_File&lt;/a&gt;&lt;/code&gt; で入手できます。</target>
        </trans-unit>
        <trans-unit id="fc49fd5fe581b9df69b9289066f92c4c1dfec1b9" translate="yes" xml:space="preserve">
          <source>There are a number of security issues with the full Unicode list of word characters. See &lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36&lt;/a&gt;.</source>
          <target state="translated">単語の文字の完全なUnicodeリストには、多くのセキュリティ問題があります。&lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="34fde0bc8e68f7eb8a6a5b8c75bef1c718f91f74" translate="yes" xml:space="preserve">
          <source>There are a number of ways to handle this sort of problem. The best way is to always have all threads acquire locks in the exact same order. If, for example, you lock variables &lt;code&gt;$x&lt;/code&gt; , &lt;code&gt;$y&lt;/code&gt; , and &lt;code&gt;$z&lt;/code&gt; , always lock &lt;code&gt;$x&lt;/code&gt; before &lt;code&gt;$y&lt;/code&gt; , and &lt;code&gt;$y&lt;/code&gt; before &lt;code&gt;$z&lt;/code&gt; . It's also best to hold on to locks for as short a period of time to minimize the risks of deadlock.</source>
          <target state="translated">この種の問題を処理する方法はいくつかあります。最善の方法は、常にすべてのスレッドがまったく同じ順序でロックを取得するようにすることです。たとえば、あなたが変数ロック、場合 &lt;code&gt;$x&lt;/code&gt; 、 &lt;code&gt;$y&lt;/code&gt; 、および &lt;code&gt;$z&lt;/code&gt; 、常にロック &lt;code&gt;$x&lt;/code&gt; 前に、 &lt;code&gt;$y&lt;/code&gt; 、および &lt;code&gt;$y&lt;/code&gt; 前に &lt;code&gt;$z&lt;/code&gt; 。デッドロックのリスクを最小限に抑えるために、ロックを短時間保持することも最適です。</target>
        </trans-unit>
        <trans-unit id="cb7bd877fbaa099a03520b258b73c60485273da7" translate="yes" xml:space="preserve">
          <source>There are a number of ways to handle this sort of problem. The best way is to always have all threads acquire locks in the exact same order. If, for example, you lock variables &lt;code&gt;$x&lt;/code&gt;, &lt;code&gt;$y&lt;/code&gt;, and &lt;code&gt;$z&lt;/code&gt;, always lock &lt;code&gt;$x&lt;/code&gt; before &lt;code&gt;$y&lt;/code&gt;, and &lt;code&gt;$y&lt;/code&gt; before &lt;code&gt;$z&lt;/code&gt;. It's also best to hold on to locks for as short a period of time to minimize the risks of deadlock.</source>
          <target state="translated">この種の問題を処理する方法はいくつかあります。最善の方法は、常にすべてのスレッドにまったく同じ順序でロックを取得させることです。たとえば、あなたが変数ロック、場合 &lt;code&gt;$x&lt;/code&gt; 、 &lt;code&gt;$y&lt;/code&gt; 、および &lt;code&gt;$z&lt;/code&gt; 、常にロック &lt;code&gt;$x&lt;/code&gt; 前に、 &lt;code&gt;$y&lt;/code&gt; 、および &lt;code&gt;$y&lt;/code&gt; 前に &lt;code&gt;$z&lt;/code&gt; 。また、デッドロックのリスクを最小限に抑えるために、ロックを短時間保持することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="f32c15283e2f4c6b7705b70493695500588d21f8" translate="yes" xml:space="preserve">
          <source>There are a number of ways to hide the source to your Perl programs, with varying levels of &quot;security&quot;.</source>
          <target state="translated">Perl プログラムのソースを隠す方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="47ea19cfdb1d50b8922388e83c50c4e47a818ebc" translate="yes" xml:space="preserve">
          <source>There are a number of ways, with varying efficiency. If you want a count of a certain single character (X) within a string, you can use the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; function like so:</source>
          <target state="translated">効率はさまざまですが、いくつかの方法があります。文字列内の特定の1文字（X）の数が必要な場合は、次のように &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; 関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="b49ba886c3971e0e735660e0bc77176d9460c20e" translate="yes" xml:space="preserve">
          <source>There are a number of ways, with varying efficiency. If you want a count of a certain single character (X) within a string, you can use the &lt;code&gt;tr///&lt;/code&gt; function like so:</source>
          <target state="translated">効率はさまざまですが、いくつかの方法があります。文字列内の特定の単一文字（X）のカウントが必要な場合は、次のように &lt;code&gt;tr///&lt;/code&gt; 関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="7bba5f24a6f4653ec9fc5a0573f80d18dac8d06b" translate="yes" xml:space="preserve">
          <source>There are a set of utilities which help you in developing Perl programs, and in particular, extending Perl with C.</source>
          <target state="translated">Perlプログラムの開発、特にC言語でのPerlの拡張に役立つユーティリティのセットがあります。</target>
        </trans-unit>
        <trans-unit id="38b993b6e04cfcdc788f4b122babf509e8a292ac" translate="yes" xml:space="preserve">
          <source>There are a significant number of test failures in the CPAN modules shipped with Perl v5.22 and 5.24. These are only in modules not primarily maintained by Perl 5 porters. Some of these are failures in the tests only: they don't realize that it is proper to get different results on EBCDIC platforms. And some of the failures are real bugs. If you compile and do a &lt;code&gt;make test&lt;/code&gt; on Perl, all tests on the &lt;code&gt;/cpan&lt;/code&gt; directory are skipped.</source>
          <target state="translated">Perlv5.22および5.24に同梱されているCPANモジュールにはかなりの数のテスト失敗があります。これらは、主にPerl5ポーターによって保守されていないモジュールにのみ含まれています。これらのいくつかはテストのみの失敗です。EBCDICプラットフォームで異なる結果を得ることが適切であることに気づいていません。そして、失敗のいくつかは本当のバグです。Perlでコンパイルして &lt;code&gt;make test&lt;/code&gt; を実行すると、 &lt;code&gt;/cpan&lt;/code&gt; ディレクトリでのすべてのテストがスキップされます。</target>
        </trans-unit>
        <trans-unit id="6b1252989edb8e8176f3bcfc5773893823daccc4" translate="yes" xml:space="preserve">
          <source>There are a significant number of test failures in the CPAN modules shipped with Perl v5.22. These are only in modules not primarily maintained by Perl 5 porters. Some of these are failures in the tests only: they don't realize that it is proper to get different results on EBCDIC platforms. And some of the failures are real bugs. If you compile and do a &lt;code&gt;make test&lt;/code&gt; on Perl, all tests on the &lt;code&gt;/cpan&lt;/code&gt; directory are skipped.</source>
          <target state="translated">Perl v5.22に同梱されているCPANモジュールには、かなりの数のテストエラーがあります。これらは、主にPerl 5ポーターによって保守されていないモジュールにのみ存在します。これらの一部はテストのみの失敗です。EBCDICプラットフォームで異なる結果を得ることが適切であるとは認識していません。そして、失敗のいくつかは本当のバグです。Perlでコンパイルして &lt;code&gt;make test&lt;/code&gt; を行う場合、 &lt;code&gt;/cpan&lt;/code&gt; ディレクトリのすべてのテストはスキップされます。</target>
        </trans-unit>
        <trans-unit id="9a68ba03d821b0f9ca941d8a7348ffd6b9675672" translate="yes" xml:space="preserve">
          <source>There are a variety of ways of transforming data with an intra character set mapping that serve a variety of purposes. Sorting was discussed in the previous section and a few of the other more popular mapping techniques are discussed next.</source>
          <target state="translated">文字セット内マッピングを使用してデータを変換する方法には、さまざまな目的を果たすさまざまな方法があります。ソートについては前のセクションで説明し、他のより一般的なマッピング技術のいくつかについては次のセクションで説明します。</target>
        </trans-unit>
        <trans-unit id="263ac344d4080439af54082913373a451c912861" translate="yes" xml:space="preserve">
          <source>There are actually two distinct kinds of version objects:</source>
          <target state="translated">バージョンオブジェクトには、実際には2つの異なる種類があります。</target>
        </trans-unit>
        <trans-unit id="8c243ce02550d420fdebc8e85f18f50ac8e89a64" translate="yes" xml:space="preserve">
          <source>There are actually two varieties of null strings (sometimes referred to as &quot;empty&quot; strings), a defined one and an undefined one. The defined version is just a string of length zero, such as &lt;code&gt;&quot;&quot;&lt;/code&gt; . The undefined version is the value that indicates that there is no real value for something, such as when there was an error, or at end of file, or when you refer to an uninitialized variable or element of an array or hash. Although in early versions of Perl, an undefined scalar could become defined when first used in a place expecting a defined value, this no longer happens except for rare cases of autovivification as explained in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. You can use the defined() operator to determine whether a scalar value is defined (this has no meaning on arrays or hashes), and the undef() operator to produce an undefined value.</source>
          <target state="translated">実際には、ヌル文字列（「空の」文字列と呼ばれることもあります）には、定義されたものと未定義のものの2種類があります。定義されたバージョンは、 &lt;code&gt;&quot;&quot;&lt;/code&gt; など、長さがゼロの文字列です。未定義のバージョンは、エラーが発生したとき、ファイルの終わりにあるとき、または初期化されていない変数または配列やハッシュの要素を参照するときなど、何かに実際の値がないことを示す値です。 Perlの初期のバージョンでは、定義された値を期待する場所で最初に使用されたときに未定義のスカラーが定義される可能性がありましたが、&lt;a href=&quot;perlref&quot;&gt;perlrefで&lt;/a&gt;説明されているautovivificationのまれなケースを除いて、これは発生しなくなりました。defined（）演算子を使用してスカラー値が定義されているかどうかを判別できます（これは配列やハッシュでは意味がありません）。undef（）演算子を使用して未定義の値を生成できます。</target>
        </trans-unit>
        <trans-unit id="fe88dd9a713bfccf6064f23560d8e8bd2b27790f" translate="yes" xml:space="preserve">
          <source>There are actually two varieties of null strings (sometimes referred to as &quot;empty&quot; strings), a defined one and an undefined one. The defined version is just a string of length zero, such as &lt;code&gt;&quot;&quot;&lt;/code&gt;. The undefined version is the value that indicates that there is no real value for something, such as when there was an error, or at end of file, or when you refer to an uninitialized variable or element of an array or hash. Although in early versions of Perl, an undefined scalar could become defined when first used in a place expecting a defined value, this no longer happens except for rare cases of autovivification as explained in &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;. You can use the defined() operator to determine whether a scalar value is defined (this has no meaning on arrays or hashes), and the undef() operator to produce an undefined value.</source>
          <target state="translated">実際には、定義済みの文字列と未定義の文字列の2種類のnull文字列（「空の」文字列と呼ばれることもあります）があります。定義されたバージョンは、 &lt;code&gt;&quot;&quot;&lt;/code&gt; などの長さゼロの文字列です。未定義のバージョンは、エラーが発生したとき、ファイルの終わり、または配列やハッシュの初期化されていない変数や要素を参照したときなど、何かに実際の値がないことを示す値です。 Perlの初期のバージョンでは、定義された値を期待する場所で最初に使用されたときに未定義のスカラーが定義される可能性がありましたが、&lt;a href=&quot;perlref&quot;&gt;perlrefで&lt;/a&gt;説明されているまれな自動生存の場合を除いて、これは発生しなくなりました。defined（）演算子を使用してスカラー値が定義されているかどうかを判断し（これは配列やハッシュでは意味がありません）、undef（）演算子を使用して未定義の値を生成できます。</target>
        </trans-unit>
        <trans-unit id="547f74aebc059a529676c6646c9bed2946a0409e" translate="yes" xml:space="preserve">
          <source>There are additional macros whose values may be bitwise OR'ed with the &lt;code&gt;GV_ADD&lt;/code&gt; argument to enable certain extra features. Those bits are:</source>
          <target state="translated">特定の追加機能を有効にするために、値が &lt;code&gt;GV_ADD&lt;/code&gt; 引数とビット単位でORされる可能性がある追加のマクロがあります。これらのビットは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="7a746509c86dffe25d4594a4b2c6a264d173eb5e" translate="yes" xml:space="preserve">
          <source>There are additional methods for regular expression patterns</source>
          <target state="translated">正規表現パターンのためのメソッドが追加されています。</target>
        </trans-unit>
        <trans-unit id="51046d0ad7a7252d1ce87aabe4027ffe3663a57e" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;Win32::IsWinNT()&lt;/code&gt; and &lt;code&gt;Win32::IsWin95()&lt;/code&gt; ; try &lt;code&gt;perldoc Win32&lt;/code&gt; , and as of libwin32 0.19 (not part of the core Perl distribution) &lt;code&gt;Win32::GetOSName()&lt;/code&gt; . The very portable &lt;code&gt;POSIX::uname()&lt;/code&gt; will work too:</source>
          <target state="translated">あります &lt;code&gt;Win32::IsWinNT()&lt;/code&gt; と &lt;code&gt;Win32::IsWin95()&lt;/code&gt; ; してみてください &lt;code&gt;perldoc Win32&lt;/code&gt; 、とlibwin32 0.19（Perlのコアディストリビューションの一部ではない）のよう &lt;code&gt;Win32::GetOSName()&lt;/code&gt; 。移植性の高い &lt;code&gt;POSIX::uname()&lt;/code&gt; も機能します。</target>
        </trans-unit>
        <trans-unit id="a575561f3064d05553d9a3fbf390d2ed1e96d270" translate="yes" xml:space="preserve">
          <source>There are also &lt;code&gt;Win32::IsWinNT()|Win32/Win32::IsWinNT()&lt;/code&gt;, &lt;code&gt;Win32::IsWin95()|Win32/Win32::IsWin95()&lt;/code&gt;, and &lt;a href=&quot;win32#Win32%3A%3AGetOSName%28%29&quot;&gt;&lt;code&gt;Win32::GetOSName()&lt;/code&gt;&lt;/a&gt;; try &lt;a href=&quot;win32&quot;&gt;&lt;code&gt;perldoc Win32&lt;/code&gt;&lt;/a&gt;. The very portable &lt;a href=&quot;posix#uname&quot;&gt;&lt;code&gt;POSIX::uname()&lt;/code&gt;&lt;/a&gt; will work too:</source>
          <target state="translated">あります &lt;code&gt;Win32::IsWinNT()|Win32/Win32::IsWinNT()&lt;/code&gt; 、 &lt;code&gt;Win32::IsWin95()|Win32/Win32::IsWin95()&lt;/code&gt; 、および&lt;a href=&quot;win32#Win32%3A%3AGetOSName%28%29&quot;&gt; &lt;code&gt;Win32::GetOSName()&lt;/code&gt; &lt;/a&gt; ; &lt;a href=&quot;win32&quot;&gt; &lt;code&gt;perldoc Win32&lt;/code&gt; &lt;/a&gt;試してください。非常に移植性の高い&lt;a href=&quot;posix#uname&quot;&gt; &lt;code&gt;POSIX::uname()&lt;/code&gt; &lt;/a&gt;も機能します。</target>
        </trans-unit>
        <trans-unit id="8e848855fa991c061ba1b0f19b935d8e48a52c00" translate="yes" xml:space="preserve">
          <source>There are also a variety of other special-purpose macros which save particular types or values of interest. &lt;code&gt;SAVETMPS&lt;/code&gt; has already been mentioned above. Others include &lt;code&gt;SAVEFREEPV&lt;/code&gt; which arranges for a PV (i.e. a string buffer) to be freed, or &lt;code&gt;SAVEDESTRUCTOR&lt;/code&gt; which arranges for a given function pointer to be invoked on scope exit. A full list of such macros can be found in</source>
          <target state="translated">関心のある特定のタイプまたは値を保存する他のさまざまな特殊用途のマクロもあります。 &lt;code&gt;SAVETMPS&lt;/code&gt; はすでに上で言及されています。他のものとしては、 &lt;code&gt;SAVEFREEPV&lt;/code&gt; PV（すなわち、A文字列バッファ）を手配が解放される、または &lt;code&gt;SAVEDESTRUCTOR&lt;/code&gt; 所定の関数ポインタを手配スコープ終了時に呼び出されます。このようなマクロの完全なリストは、にあります。</target>
        </trans-unit>
        <trans-unit id="23127dab9bc88fbefc66139b670c575d072a34d4" translate="yes" xml:space="preserve">
          <source>There are also certain operations that are illegal. You can't nest &lt;code&gt;\p{...}&lt;/code&gt; and &lt;code&gt;\P{...}&lt;/code&gt; calls within a wildcard subpattern, and &lt;code&gt;\G&lt;/code&gt; doesn't make sense, so is also prohibited.</source>
          <target state="translated">違法な特定の操作もあります。ワイルドカードサブパターン内に &lt;code&gt;\p{...}&lt;/code&gt; および &lt;code&gt;\P{...}&lt;/code&gt; 呼び出しをネストすることはできません。また、 &lt;code&gt;\G&lt;/code&gt; は意味をなさないため、禁止されています。</target>
        </trans-unit>
        <trans-unit id="68cc104cb95d94223dc9fddad7fb75cbcb044f6c" translate="yes" xml:space="preserve">
          <source>There are also endless possibilities to use</source>
          <target state="translated">を使用する可能性も無限大です。</target>
        </trans-unit>
        <trans-unit id="d8a2e4b90dc5ccc934f88be56fb54a760d42a1e5" translate="yes" xml:space="preserve">
          <source>There are also layers which actually just set flags on lower layers, or layers that modify the current stack but don't persist on the stack themselves; these are referred to as pseudo-layers.</source>
          <target state="translated">また、実際には下位のレイヤーにフラグを設定するだけのレイヤーや、現在のスタックを修正するがスタック自体には残らないレイヤーもあります;これらを擬似レイヤーと呼びます。</target>
        </trans-unit>
        <trans-unit id="323189fd57b85b2e190ea90f3e9bb682b3b9f2e0" translate="yes" xml:space="preserve">
          <source>There are also plenty of Perl related newsgroups located under &lt;code&gt;comp.lang.perl.*&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;comp.lang.perl.*&lt;/code&gt; 下にあるPerl関連のニュースグループもたくさんあります。</target>
        </trans-unit>
        <trans-unit id="527d1ab1f5f5398fbabcd044390ef4e42b5f0b60" translate="yes" xml:space="preserve">
          <source>There are also some commercial products that may work for you, although you have to buy a license for them.</source>
          <target state="translated">また、市販品でもライセンスを購入する必要がありますが、効果がありそうなものもあります。</target>
        </trans-unit>
        <trans-unit id="8875c64205867a602cf00ce82127ede7aefa737d" translate="yes" xml:space="preserve">
          <source>There are also some commonly used modules for the task. &lt;a href=&quot;Scalar::Util&quot;&gt;Scalar::Util&lt;/a&gt; (distributed with 5.8) provides access to perl's internal function &lt;code&gt;looks_like_number&lt;/code&gt; for determining whether a variable looks like a number. &lt;a href=&quot;Data::Types&quot;&gt;Data::Types&lt;/a&gt; exports functions that validate data types using both the above and other regular expressions. Thirdly, there is &lt;a href=&quot;Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; which has regular expressions to match various types of numbers. Those three modules are available from the CPAN.</source>
          <target state="translated">タスクに一般的に使用されるモジュールもいくつかあります。&lt;a href=&quot;Scalar::Util&quot;&gt;Scalar :: Util&lt;/a&gt;（5.8で配布）は、変数が数値のように見えるかどうかを判断するためのperlの内部関数 &lt;code&gt;looks_like_number&lt;/code&gt; へのアクセスを提供します。&lt;a href=&quot;Data::Types&quot;&gt;Data :: Types&lt;/a&gt;は、上記の正規表現と他の正規表現の両方を使用してデータ型を検証する関数をエクスポートします。第三に、さまざまなタイプの数値に一致する正規表現を持つ&lt;a href=&quot;Regexp::Common&quot;&gt;Regexp :: Common&lt;/a&gt;があります。これらの3つのモジュールは、CPANから入手できます。</target>
        </trans-unit>
        <trans-unit id="54ce59232e232d36fa4b243d9439f11e909759d7" translate="yes" xml:space="preserve">
          <source>There are also some commonly used modules for the task. &lt;a href=&quot;scalar/util&quot;&gt;Scalar::Util&lt;/a&gt; (distributed with 5.8) provides access to perl's internal function &lt;code&gt;looks_like_number&lt;/code&gt; for determining whether a variable looks like a number. &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Types&quot;&gt;Data::Types&lt;/a&gt; exports functions that validate data types using both the above and other regular expressions. Thirdly, there is &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt; which has regular expressions to match various types of numbers. Those three modules are available from the CPAN.</source>
          <target state="translated">タスクに一般的に使用されるいくつかのモジュールもあります。&lt;a href=&quot;scalar/util&quot;&gt;Scalar :: Util&lt;/a&gt;（5.8で配布）は、変数が数値のように見えるかどうかを判断するためのperlの内部関数 &lt;code&gt;looks_like_number&lt;/code&gt; へのアクセスを提供します。&lt;a href=&quot;http://search.cpan.org/perldoc/Data::Types&quot;&gt;Data :: Types&lt;/a&gt;は、上記と他の正規表現の両方を使用してデータ型を検証する関数をエクスポートします。第三に、さまざまなタイプの数値に一致する正規表現を持つ&lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp :: Common&lt;/a&gt;があります。これら3つのモジュールはCPANから入手できます。</target>
        </trans-unit>
        <trans-unit id="b1ee19a63035c233ed5685ff1e3a13cd9e4a26d4" translate="yes" xml:space="preserve">
          <source>There are also some other op types: a &lt;code&gt;PMOP&lt;/code&gt; holds a regular expression, and has no children, and a &lt;code&gt;LOOP&lt;/code&gt; may or may not have children. If the &lt;code&gt;op_children&lt;/code&gt; field is non-zero, it behaves like a &lt;code&gt;LISTOP&lt;/code&gt; . To complicate matters, if a &lt;code&gt;UNOP&lt;/code&gt; is actually a &lt;code&gt;null&lt;/code&gt; op after optimization (see &lt;a href=&quot;#Compile-pass-2%3a-context-propagation&quot;&gt;Compile pass 2: context propagation&lt;/a&gt;) it will still have children in accordance with its former type.</source>
          <target state="translated">他のいくつかのオペの種類があります： &lt;code&gt;PMOP&lt;/code&gt; は、正規表現を保持し、子を持たない、と &lt;code&gt;LOOP&lt;/code&gt; はや子供を持っていない可能性があります。 &lt;code&gt;op_children&lt;/code&gt; フィールドがゼロ以外の場合は、LISTOPのように動作し &lt;code&gt;LISTOP&lt;/code&gt; 。さらに複雑なことに、 &lt;code&gt;UNOP&lt;/code&gt; が最適化後に実際に &lt;code&gt;null&lt;/code&gt; op である場合（「&lt;a href=&quot;#Compile-pass-2%3a-context-propagation&quot;&gt;コンパイルパス2：コンテキストの伝達&lt;/a&gt;」を参照）、元の型に従って子がまだ存在します。</target>
        </trans-unit>
        <trans-unit id="11f74fbe23dd4e59c95a6d0f147c6383a5a62308" translate="yes" xml:space="preserve">
          <source>There are also some other op types: a &lt;code&gt;PMOP&lt;/code&gt; holds a regular expression, and has no children, and a &lt;code&gt;LOOP&lt;/code&gt; may or may not have children. If the &lt;code&gt;op_children&lt;/code&gt; field is non-zero, it behaves like a &lt;code&gt;LISTOP&lt;/code&gt;. To complicate matters, if a &lt;code&gt;UNOP&lt;/code&gt; is actually a &lt;code&gt;null&lt;/code&gt; op after optimization (see &lt;a href=&quot;#Compile-pass-2%3A-context-propagation&quot;&gt;&quot;Compile pass 2: context propagation&quot;&lt;/a&gt;) it will still have children in accordance with its former type.</source>
          <target state="translated">他にもいくつかのopタイプがあります &lt;code&gt;PMOP&lt;/code&gt; は正規表現を保持し、子を持たず、 &lt;code&gt;LOOP&lt;/code&gt; には子がある場合とない場合があります。 &lt;code&gt;op_children&lt;/code&gt; フィールドがゼロ以外の場合、LISTOPのように動作し &lt;code&gt;LISTOP&lt;/code&gt; 。さらに複雑なことに、 &lt;code&gt;UNOP&lt;/code&gt; が最適化後に実際に &lt;code&gt;null&lt;/code&gt; opである場合（&lt;a href=&quot;#Compile-pass-2%3A-context-propagation&quot;&gt;「コンパイルパス2：コンテキスト伝播」を&lt;/a&gt;参照）、以前のタイプに従って子が残ります。</target>
        </trans-unit>
        <trans-unit id="d74afa3e57d8bf587dddccd05e8aa225e3034ba7" translate="yes" xml:space="preserve">
          <source>There are also some tricks that you can play with &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; and the accumulator variable &lt;code&gt;$^A&lt;/code&gt; , but you lose a lot of the value of formats since &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; won't handle paging and so on. You end up reimplementing formats when you use them.</source>
          <target state="translated">また、 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; とアキュムレータ変数 &lt;code&gt;$^A&lt;/code&gt; で遊ぶことができるいくつかのトリックがありますが、 &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; はページングなどを処理しないため、フォーマットの多くの価値を失います。フォーマットを使用すると、最終的に再実装することになります。</target>
        </trans-unit>
        <trans-unit id="4d45adb6b43e1a59ad871510a945d0116f3df08b" translate="yes" xml:space="preserve">
          <source>There are also some tricks that you can play with &lt;code&gt;formline&lt;/code&gt; and the accumulator variable &lt;code&gt;$^A&lt;/code&gt;, but you lose a lot of the value of formats since &lt;code&gt;formline&lt;/code&gt; won't handle paging and so on. You end up reimplementing formats when you use them.</source>
          <target state="translated">&lt;code&gt;formline&lt;/code&gt; とアキュムレータ変数 &lt;code&gt;$^A&lt;/code&gt; で遊ぶことができるいくつかのトリックもありますが、 &lt;code&gt;formline&lt;/code&gt; はページングなどを処理しないため、フォーマットの価値の多くを失います。それらを使用すると、フォーマットを再実装することになります。</target>
        </trans-unit>
        <trans-unit id="8a607b0a4fc3c7e1671b30a3b355e931c22fa4ed" translate="yes" xml:space="preserve">
          <source>There are also the two values &lt;code&gt;PL_sv_yes&lt;/code&gt; and &lt;code&gt;PL_sv_no&lt;/code&gt; , which contain boolean TRUE and FALSE values, respectively. Like &lt;code&gt;PL_sv_undef&lt;/code&gt; , their addresses can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed.</source>
          <target state="translated">&lt;code&gt;PL_sv_yes&lt;/code&gt; と &lt;code&gt;PL_sv_no&lt;/code&gt; の 2つの値もあり、それぞれブール値のTRUEとFALSEが含まれています。 &lt;code&gt;PL_sv_undef&lt;/code&gt; と同様に、 &lt;code&gt;SV*&lt;/code&gt; が必要なときはいつでもそれらのアドレスを使用できます。</target>
        </trans-unit>
        <trans-unit id="bada6ac2c7944b1149547067859a10dc227a309f" translate="yes" xml:space="preserve">
          <source>There are also the two values &lt;code&gt;PL_sv_yes&lt;/code&gt; and &lt;code&gt;PL_sv_no&lt;/code&gt;, which contain boolean TRUE and FALSE values, respectively. Like &lt;code&gt;PL_sv_undef&lt;/code&gt;, their addresses can be used whenever an &lt;code&gt;SV*&lt;/code&gt; is needed.</source>
          <target state="translated">&lt;code&gt;PL_sv_yes&lt;/code&gt; と &lt;code&gt;PL_sv_no&lt;/code&gt; の2つの値もあり、それぞれブール値のTRUE値とFALSE値が含まれています。 &lt;code&gt;PL_sv_undef&lt;/code&gt; と同様に、 &lt;code&gt;SV*&lt;/code&gt; が必要な場合はいつでもそれらのアドレスを使用できます。</target>
        </trans-unit>
        <trans-unit id="2a9975f54ba4b1444b192c3d8bfd7d71c13ebdbb" translate="yes" xml:space="preserve">
          <source>There are also versions of the functions with &quot;_hex&quot; or &quot;_base64&quot; appended to the name, which returns the digest in the indicated form.</source>
          <target state="translated">また、関数名に&quot;_hex &quot;や&quot;_base64 &quot;を付加したバージョンもあり、これは指定された形式でダイジェストを返す。</target>
        </trans-unit>
        <trans-unit id="a5a4f4a9450ec80ee122e2031504c8884d21e28d" translate="yes" xml:space="preserve">
          <source>There are at least two instance variables stored in a hash reference, {data} and {encoding}.</source>
          <target state="translated">ハッシュ参照には、{data}と{encoding}の少なくとも2つのインスタンス変数が格納されています。</target>
        </trans-unit>
        <trans-unit id="68682d3f996c5d0d4c5e2cf0ab83889b2edb3594" translate="yes" xml:space="preserve">
          <source>There are cases when you will not know beforehand how many tests your script is going to run. In this case, you can declare your tests at the end.</source>
          <target state="translated">スクリプトを実行するテストの数が事前にわからない場合もあるでしょう。この場合は、最後にテストを宣言することができます。</target>
        </trans-unit>
        <trans-unit id="13a4d162b9b64ac9d632dbabef83e1cc311a2290" translate="yes" xml:space="preserve">
          <source>There are certain application spaces which are already very, very well served by CPAN. One example is templating systems, another is date and time modules, and there are many more. While it is a rite of passage to write your own version of these things, please consider carefully whether the Perl world really needs you to publish it.</source>
          <target state="translated">CPANがすでに非常によく機能しているアプリケーション領域があります。一つの例はテンプレートシステムであり、もう一つは日付と時刻のモジュールであり、他にも多くのものがあります。これらのものの独自のバージョンを書くことは通過儀礼ですが、Perlの世界がそれを公開することを本当に必要としているかどうかを注意深く検討してください。</target>
        </trans-unit>
        <trans-unit id="6418df0a423a65fdef15c0f2ab1cbad9a1e3cda6" translate="yes" xml:space="preserve">
          <source>There are certain properties that wildcard subpatterns don't currently work with. These are:</source>
          <target state="translated">ワイルドカードのサブパターンには、現在のところ使えないプロパティがあります。それは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="f399d82ea760be3c44c0c12193de98d98ca6c0b6" translate="yes" xml:space="preserve">
          <source>There are corresponding one-letter commands &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; for each of the four categories and another, &lt;code&gt;i&lt;/code&gt; for any of the mentioned four. Each of the four entities is implemented as a class with slightly differing methods for displaying an object.</source>
          <target state="translated">4つのカテゴリのそれぞれに対応する1文字のコマンド &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; 、 &lt;code&gt;d&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m&lt;/a&gt;&lt;/code&gt; と、前述の4つのいずれかに別の &lt;code&gt;i&lt;/code&gt; のコマンドがあります。4つのエンティティはそれぞれ、オブジェクトを表示するためのメソッドがわずかに異なるクラスとして実装されます。</target>
        </trans-unit>
        <trans-unit id="61165542c376ce1515ee946fb54e0b62bf506b50" translate="yes" xml:space="preserve">
          <source>There are currently three implementations:</source>
          <target state="translated">現在、3つの実装があります。</target>
        </trans-unit>
        <trans-unit id="97e0702d9f24205eb392b550bdee3cc7f1886fbc" translate="yes" xml:space="preserve">
          <source>There are currently two implementations:</source>
          <target state="translated">現在、2つの実装があります。</target>
        </trans-unit>
        <trans-unit id="fb1fef3dafc65f2dd5f6f03815febb7cc02429e1" translate="yes" xml:space="preserve">
          <source>There are different classes in the &lt;a href=&quot;Email::Folder&quot;&gt;Email::Folder&lt;/a&gt; namespace for supporting various mailbox types. Note that these modules are generally rather limited and only support &lt;b&gt;reading&lt;/b&gt; rather than writing.</source>
          <target state="translated">&lt;a href=&quot;Email::Folder&quot;&gt;Email :: Folder&lt;/a&gt;名前空間には、さまざまなメールボックスタイプをサポートするためのさまざまなクラスがあります。これらのモジュールは一般的にかなり制限されており、書き込みではなく&lt;b&gt;読み取り&lt;/b&gt;のみをサポートしていることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7082baef78129948a9aee04418c7c10c1b4d4a87" translate="yes" xml:space="preserve">
          <source>There are different classes in the &lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email::Folder&lt;/a&gt; namespace for supporting various mailbox types. Note that these modules are generally rather limited and only support &lt;b&gt;reading&lt;/b&gt; rather than writing.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/Email::Folder&quot;&gt;Email :: Folder&lt;/a&gt;名前空間には、さまざまな種類のメールボックスをサポートするためのさまざまなクラスがあります。これらのモジュールは一般にかなり制限されており、書き込みではなく&lt;b&gt;読み取り&lt;/b&gt;のみをサポートする&lt;b&gt;ことに&lt;/b&gt;注意してください。</target>
        </trans-unit>
        <trans-unit id="7ffae46f4361bbc29cee623ab319bb8483adbbdb" translate="yes" xml:space="preserve">
          <source>There are exceptions to the above rules for dereference operations (which, if Step 1 fails, always fall back to the normal, built-in implementations - see Dereferencing), and for &lt;code&gt;~~&lt;/code&gt; (which has its own set of rules - see &lt;code&gt;Matching&lt;/code&gt; under &lt;a href=&quot;#Overloadable-Operations&quot;&gt;&quot;Overloadable Operations&quot;&lt;/a&gt; above).</source>
          <target state="translated">、およびのための-そこに間接参照操作のための上記のルールの例外（間接参照を参照してください。ステップ1が失敗した場合、常に正常に戻って落ち、組み込みの実装）です &lt;code&gt;~~&lt;/code&gt; ルールの独自のセットを持っています（ -を参照 &lt;code&gt;Matching&lt;/code&gt; の下に上記の&lt;a href=&quot;#Overloadable-Operations&quot;&gt;「オーバーロード可能な操作」&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ed85d6fa9e5690e5659a7fcf3cc7c90a6a9abc89" translate="yes" xml:space="preserve">
          <source>There are exceptions to the above rules for dereference operations (which, if Step 1 fails, always fall back to the normal, built-in implementations - see Dereferencing), and for &lt;code&gt;~~&lt;/code&gt; (which has its own set of rules - see &lt;code&gt;Matching&lt;/code&gt; under &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Overloadable Operations&lt;/a&gt; above).</source>
          <target state="translated">、およびのための-そこに間接参照操作のための上記のルールの例外（間接参照を参照してください。ステップ1が失敗した場合、常に正常に戻って落ち、組み込みの実装）です &lt;code&gt;~~&lt;/code&gt; ルールの独自のセットを持っています（ -を参照 &lt;code&gt;Matching&lt;/code&gt; の下に上記の&lt;a href=&quot;#Overloadable-Operations&quot;&gt;オーバーロード可能な操作&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="129afe5f5ce43c82f8dd2611661b6c6fae2152e8" translate="yes" xml:space="preserve">
          <source>There are exceptions to the simple scalar maps. Some properties have some elements in their map list that are themselves lists of scalars; and some special strings are returned that are not to be interpreted as-is. Element [2] (placed into &lt;code&gt;$format&lt;/code&gt; in the example above) of the returned four element list tells you if the map has any of these special elements or not, as follows:</source>
          <target state="translated">単純なスカラーマップには例外があります。一部のプロパティは、それら自体がスカラーのリストであるマップリストにいくつかの要素があります。そのまま解釈されない特別な文字列が返されます。次のように、返された4つの要素リストの要素[2]（上記の例では &lt;code&gt;$format&lt;/code&gt; に配置）は、マップにこれらの特別な要素があるかどうかを示します。</target>
        </trans-unit>
        <trans-unit id="03da32e2f08e4c55ca723ef0de464a8b0fc8a37a" translate="yes" xml:space="preserve">
          <source>There are five pattern matching operations other than a strict one-to-one match between the pattern and the source to be checked for a match.</source>
          <target state="translated">パターンの照合操作は、パターンと照合元の間で厳密な一対一の照合以外に、5つの操作があります。</target>
        </trans-unit>
        <trans-unit id="caaaee4619b1124c4cd083d4f94b5aeee43dd52b" translate="yes" xml:space="preserve">
          <source>There are four arguments:</source>
          <target state="translated">議論は4つあります。</target>
        </trans-unit>
        <trans-unit id="c30d8b75df6d6d560de84db459ba9ddeaac5bfd4" translate="yes" xml:space="preserve">
          <source>There are four methods associated with DBM Filters. All work identically, and each is used to install (or uninstall) a single DBM Filter. Each expects a single parameter, namely a reference to a sub. The only difference between them is the place that the filter is installed.</source>
          <target state="translated">DBM フィルタには 4 つの方法があります。どれも同じように動作し、それぞれが単一の DBM フィルタをインストール (またはアンインストール)するために使用されます。それぞれのメソッドは単一のパラメータ、すなわちサブへの参照を必要とします。両者の唯一の違いは、フィルタがインストールされる場所です。</target>
        </trans-unit>
        <trans-unit id="2b4786fe13177802911e40046450c4aa8a6b7442" translate="yes" xml:space="preserve">
          <source>There are four routines that can be used to call a Perl subroutine from within a C program. These four are:</source>
          <target state="translated">Cプログラムの中からPerlのサブルーチンを呼び出すのに使えるルーチンが4つあります。これらの4つは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="0b4c3b4907f361ea335c94a68bf5900b38774c4c" translate="yes" xml:space="preserve">
          <source>There are just two ways to make a reference, and just two ways to use it once you have it.</source>
          <target state="translated">参考にする方法と、一度手に入れたら使う方法の2つがあるだけです。</target>
        </trans-unit>
        <trans-unit id="451300c3402db478bc017d97504bbf1dc7589d4f" translate="yes" xml:space="preserve">
          <source>There are literally dozens of other OO-related modules on CPAN besides those covered here, and you're likely to run across one or more of them if you work with other people's code.</source>
          <target state="translated">CPANには、ここで取り上げた以外にも文字通り数十種類のOO関連モジュールがあり、他人のコードを使って作業をしていると、それらのうちの1つ以上に遭遇する可能性があります。</target>
        </trans-unit>
        <trans-unit id="6c77d5c24285fecf2b82ebf41d5dec81876d45b0" translate="yes" xml:space="preserve">
          <source>There are lots more commands and options, but the above will do it.</source>
          <target state="translated">他にもコマンドやオプションはたくさんありますが、上記のようにします。</target>
        </trans-unit>
        <trans-unit id="837d89ccfb96f196a244bf30256b711d40a975e1" translate="yes" xml:space="preserve">
          <source>There are many Perl &lt;a href=&quot;http://search.cpan.org/perldoc/lists.perl.org&quot;&gt;mailing lists&lt;/a&gt; for various topics, specifically the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2flists.perl.org%2flist%2fbeginners.html&quot;&gt;beginners list&lt;/a&gt; may be of use.</source>
          <target state="translated">さまざまなトピックについて多くのPerl &lt;a href=&quot;http://search.cpan.org/perldoc/lists.perl.org&quot;&gt;メーリングリスト&lt;/a&gt;があり、特に&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2flists.perl.org%2flist%2fbeginners.html&quot;&gt;初心者リスト&lt;/a&gt;が役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="c100a4e2353b8e1e3f993e428fe4246a2ed1c1dd" translate="yes" xml:space="preserve">
          <source>There are many Perl &lt;a href=&quot;lists.perl.org&quot;&gt;mailing lists&lt;/a&gt; for various topics, specifically the &lt;a href=&quot;http://lists.perl.org/list/beginners.html&quot;&gt;beginners list&lt;/a&gt; may be of use.</source>
          <target state="translated">さまざまなトピックのPerl&lt;a href=&quot;lists.perl.org&quot;&gt;メーリングリスト&lt;/a&gt;がたくさんあります。特に、&lt;a href=&quot;http://lists.perl.org/list/beginners.html&quot;&gt;初心者リスト&lt;/a&gt;が役立つ場合があります。</target>
        </trans-unit>
        <trans-unit id="9bec5519f33a4e7bdc4a53a2313d4e1bcfcd1067" translate="yes" xml:space="preserve">
          <source>There are many books on Perl and Perl-related. A few of these are good, some are OK, but many aren't worth your money. There is a list of these books, some with extensive reviews, at &lt;a href=&quot;http://books.perl.org/&quot;&gt;http://books.perl.org/&lt;/a&gt; . We list some of the books here, and while listing a book implies our endorsement, don't think that not including a book means anything.</source>
          <target state="translated">PerlとPerl関連の本はたくさんあります。これらのいくつかは良いです、いくつかは大丈夫ですが、多くはあなたのお金の価値がありません。これらの書籍のリストは、&lt;a href=&quot;http://books.perl.org/&quot;&gt;http：//books.perl.org/にあり&lt;/a&gt;ます。ここにいくつかの本をリストします。本をリストすることは私たちの推奨を意味しますが、本を含まないことは何の意味もないとは考えないでください。</target>
        </trans-unit>
        <trans-unit id="c4e51ecd675e07ca3b7be0664408ec108e37de71" translate="yes" xml:space="preserve">
          <source>There are many different ftp firewall products available. But unfortunately there is no standard for how to traverse a firewall. The list below shows the sequence of commands that Net::FTP will use</source>
          <target state="translated">ftp ファイアウォールには様々な製品があります。しかし、残念ながらファイアウォールを通過する方法の標準はありません。以下のリストは、Net::FTP が使用するコマンドの順序を示しています。</target>
        </trans-unit>
        <trans-unit id="ccca22cadfc5874b657dd6b896d963adc193de41" translate="yes" xml:space="preserve">
          <source>There are many good &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fbooks%2flibrary.html&quot;&gt;books on Perl&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.perl.org%2fbooks%2flibrary.html&quot;&gt;Perlに関する&lt;/a&gt;優れた本はたくさんあります。</target>
        </trans-unit>
        <trans-unit id="25f8cf87f8d0d010ba0c130a03c0c733508760a7" translate="yes" xml:space="preserve">
          <source>There are many good &lt;a href=&quot;http://www.perl.org/books/library.html&quot;&gt;books on Perl&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.perl.org/books/library.html&quot;&gt;Perlに関する&lt;/a&gt;良い本はたくさんあります。</target>
        </trans-unit>
        <trans-unit id="18c010c4c2e46af9e1a3df8426bb24c3742b96b7" translate="yes" xml:space="preserve">
          <source>There are many more properties than the very basic ones described here. A complete list is in &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;.</source>
          <target state="translated">ここで説明する非常に基本的なプロパティよりも多くのプロパティがあります。完全なリストは&lt;a href=&quot;perluniprops&quot;&gt;perlunipropsにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="9a8e433d3ac89e153ddbae16288b146a2a506dab" translate="yes" xml:space="preserve">
          <source>There are many other functions available since FileHandle is descended from IO::File, IO::Seekable, and IO::Handle. Please see those respective pages for documentation on more functions.</source>
          <target state="translated">FileHandle は IO::File,IO::Seekable,IO::Handle の子孫であるため、利用可能な他の多くの関数があります。より多くの関数のドキュメントについては、それぞれのページを参照してください。</target>
        </trans-unit>
        <trans-unit id="19b014b8d66d3b187e540a67f34591fd12721782" translate="yes" xml:space="preserve">
          <source>There are many reasons, but the major one is cross-platform compatibility.</source>
          <target state="translated">理由はいろいろありますが、大きなものはクロスプラットフォーム対応です。</target>
        </trans-unit>
        <trans-unit id="ec8353eb61918c8ea09b548fd2c7481452870299" translate="yes" xml:space="preserve">
          <source>There are many ways to ensure that values are what you expect or want to accept. Besides the specific examples that we cover in the perlfaq, you can also look at the modules with &quot;Assert&quot; and &quot;Validate&quot; in their names, along with other modules such as &lt;a href=&quot;Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt;.</source>
          <target state="translated">値が期待または受け入れたいものであることを確認する方法はたくさんあります。perlfaqで取り上げる特定の例に加えて、名前に「Assert」と「Validate」が含まれるモジュールや、&lt;a href=&quot;Regexp::Common&quot;&gt;Regexp :: Common&lt;/a&gt;などの他のモジュールを確認することもできます。</target>
        </trans-unit>
        <trans-unit id="4f22a618b10f083a38eaf97d7560bbf775ba04c7" translate="yes" xml:space="preserve">
          <source>There are many ways to ensure that values are what you expect or want to accept. Besides the specific examples that we cover in the perlfaq, you can also look at the modules with &quot;Assert&quot; and &quot;Validate&quot; in their names, along with other modules such as &lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp::Common&lt;/a&gt;.</source>
          <target state="translated">値が期待どおりまたは受け入れたいものであることを確認するには、多くの方法があります。perlfaqで取り上げている特定の例に加えて、名前に「Assert」と「Validate」が含まれているモジュール、および&lt;a href=&quot;http://search.cpan.org/perldoc/Regexp::Common&quot;&gt;Regexp :: Common&lt;/a&gt;などの他のモジュールも確認できます。</target>
        </trans-unit>
        <trans-unit id="c508352f954b14145337f34025470ea842ef7b40" translate="yes" xml:space="preserve">
          <source>There are many ways to get multiline data into a string. If you want it to happen automatically while reading input, you'll want to set $/ (probably to '' for paragraphs or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for the whole file) to allow you to read more than one line at a time.</source>
          <target state="translated">複数行のデータを文字列に変換する方法はたくさんあります。入力の読み取り中にそれを自動的に実行したい場合は、$ /を設定して（段落の場合は ''に、またはファイル全体の場合は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ）、一度に複数の行を読み取ることができるようにします。</target>
        </trans-unit>
        <trans-unit id="d0c13e2ae1a5d488cf21f540ff8605d82939bccd" translate="yes" xml:space="preserve">
          <source>There are many ways to get multiline data into a string. If you want it to happen automatically while reading input, you'll want to set $/ (probably to '' for paragraphs or &lt;code&gt;undef&lt;/code&gt; for the whole file) to allow you to read more than one line at a time.</source>
          <target state="translated">複数行のデータを文字列に変換する方法はたくさんあります。入力の読み取り中に自動的に発生するようにする場合は、一度に複数行を読み取れるように$ /（段落の場合は ''、ファイル全体の場合は &lt;code&gt;undef&lt;/code&gt; ）を設定する必要があります。</target>
        </trans-unit>
        <trans-unit id="3dc3f3b5eae147e801f5f43fb6a8fbac0ae189bf" translate="yes" xml:space="preserve">
          <source>There are many, many Unicode character properties. For the full list see &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;. Most of them have synonyms with shorter names, also listed there. Some synonyms are a single character. For these, you can drop the braces. For instance, &lt;code&gt;\pM&lt;/code&gt; is the same thing as &lt;code&gt;\p{Mark}&lt;/code&gt; , meaning things like accent marks.</source>
          <target state="translated">Unicode文字のプロパティは数多くあります。完全なリストについては、&lt;a href=&quot;perluniprops&quot;&gt;perlunipropsを&lt;/a&gt;参照してください。それらのほとんどには、短い名前の同義語があり、そこにもリストされています。一部の同義語は単一の文字です。これらの場合、ブレースをドロップできます。たとえば、 &lt;code&gt;\pM&lt;/code&gt; は &lt;code&gt;\p{Mark}&lt;/code&gt; と同じで、アクセント記号などを意味します。</target>
        </trans-unit>
        <trans-unit id="69da32a8fafef027c405b2092d6a66a08f07e5a2" translate="yes" xml:space="preserve">
          <source>There are many, many Unicode character properties. For the full list see &lt;a href=&quot;perluniprops&quot;&gt;perluniprops&lt;/a&gt;. Most of them have synonyms with shorter names, also listed there. Some synonyms are a single character. For these, you can drop the braces. For instance, &lt;code&gt;\pM&lt;/code&gt; is the same thing as &lt;code&gt;\p{Mark}&lt;/code&gt;, meaning things like accent marks.</source>
          <target state="translated">多くのUnicode文字プロパティがあります。完全なリストについては、&lt;a href=&quot;perluniprops&quot;&gt;perlunipropsを&lt;/a&gt;参照してください。それらのほとんどには、短い名前の同義語があり、そこにもリストされています。一部の同義語は単一の文字です。これらについては、中括弧を削除できます。たとえば、 &lt;code&gt;\pM&lt;/code&gt; は &lt;code&gt;\p{Mark}&lt;/code&gt; と同じで、アクセント記号のようなものを意味します。</target>
        </trans-unit>
        <trans-unit id="1a61fc5e0ce0e0ef09d3d9c85a06d1ddbe46e285" translate="yes" xml:space="preserve">
          <source>There are many, many code points, but computers work with bytes, and a byte has room for only 256 values. Unicode has many more characters than that, so you need a method to make these accessible.</source>
          <target state="translated">コードポイントはたくさん、たくさんありますが、コンピュータはバイトで動作し、1バイトには256個の値しか入る余地がありません。Unicodeにはそれよりも多くの文字がありますので、これらの文字にアクセスできるようにする方法が必要です。</target>
        </trans-unit>
        <trans-unit id="88acdd96ec6d6927c08fab60ea3227280069d628" translate="yes" xml:space="preserve">
          <source>There are many, many sources for Solaris information. A few of the important ones for perl:</source>
          <target state="translated">Solaris の情報源はたくさんあります。perlにとって重要なものをいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="83467e96db886b15aa3db22c9e9e4b034057eea3" translate="yes" xml:space="preserve">
          <source>There are modules to help you through the process of writing a module: &lt;a href=&quot;ExtUtils::ModuleMaker&quot;&gt;ExtUtils::ModuleMaker&lt;/a&gt;, &lt;a href=&quot;Module::Starter&quot;&gt;Module::Starter&lt;/a&gt;, &lt;a href=&quot;Minilla::Tutorial&quot;&gt;Minilla::Tutorial&lt;/a&gt;, &lt;a href=&quot;Dist::Milla::Tutorial&quot;&gt;Dist::Milla::Tutorial&lt;/a&gt;, &lt;a href=&quot;Dist::Zilla::Starter&quot;&gt;Dist::Zilla::Starter&lt;/a&gt;</source>
          <target state="translated">モジュールを作成するプロセスを支援するモジュールがあります：&lt;a href=&quot;ExtUtils::ModuleMaker&quot;&gt;ExtUtils :: ModuleMaker&lt;/a&gt;、&lt;a href=&quot;Module::Starter&quot;&gt;Module :: Starter&lt;/a&gt;、Minilla &lt;a href=&quot;Minilla::Tutorial&quot;&gt;:: Tutorial&lt;/a&gt;、&lt;a href=&quot;Dist::Milla::Tutorial&quot;&gt;Dist :: Milla :: Tutorial&lt;/a&gt;、&lt;a href=&quot;Dist::Zilla::Starter&quot;&gt;Dist :: Zilla :: Starter&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c8f4eee710987379a0f55c604a3354e69d7b2875" translate="yes" xml:space="preserve">
          <source>There are modules to help you through the process of writing a module: &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::ModuleMaker&quot;&gt;ExtUtils::ModuleMaker&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Module::Install&quot;&gt;Module::Install&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR&lt;/a&gt;</source>
          <target state="translated">モジュールの作成プロセスを支援するモジュールがあります：&lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::ModuleMaker&quot;&gt;ExtUtils :: ModuleMaker&lt;/a&gt;、&lt;a href=&quot;http://search.cpan.org/perldoc/Module::Install&quot;&gt;Module :: Install&lt;/a&gt;、&lt;a href=&quot;http://search.cpan.org/perldoc/PAR&quot;&gt;PAR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da29172199b45020f43775089b9830c405a497fb" translate="yes" xml:space="preserve">
          <source>There are no deprecations or fatalizations scheduled for Perl 5.34.</source>
          <target state="translated">Perl 5.34 で予定されている deprecation や fatalizations はありません。</target>
        </trans-unit>
        <trans-unit id="61d4491371efc2ca44fd016e5d9139fc5fa773fa" translate="yes" xml:space="preserve">
          <source>There are no loops of references.</source>
          <target state="translated">参照のループはありません。</target>
        </trans-unit>
        <trans-unit id="476c776008d55428fe7585fbd0c3dce927c522c4" translate="yes" xml:space="preserve">
          <source>There are no unique methods for unknown results.</source>
          <target state="translated">未知の結果に対して、独自の方法はありません。</target>
        </trans-unit>
        <trans-unit id="b571d2027807fc8b9e77b0de9129097419041bc0" translate="yes" xml:space="preserve">
          <source>There are non-obvious Unicode rules under &lt;code&gt;/i&lt;/code&gt; that can match variably, but which you might not think could. For example, the substring &lt;code&gt;&quot;ss&quot;&lt;/code&gt; can match the single character LATIN SMALL LETTER SHARP S. There are other sequences of ASCII characters that can match single ligature characters, such as LATIN SMALL LIGATURE FFI matching &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/ffi/i&lt;/a&gt;&lt;/code&gt;. Starting in Perl v5.16, if you only care about ASCII matches, adding the &lt;code&gt;/aa&lt;/code&gt; modifier to the regex will exclude all these non-obvious matches, thus getting rid of this message. You can also say &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re qw(/aa)&lt;/code&gt; to apply &lt;code&gt;/aa&lt;/code&gt; to all regular expressions compiled within its scope. See &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;/i&lt;/code&gt; の下には、さまざまな形で一致する可能性があるが、そうではないと思われる可能性がある明白でないUnicode規則があります。たとえば、部分文字列 &lt;code&gt;&quot;ss&quot;&lt;/code&gt; は、単一文字のラテン小文字LのSに一致します &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/ffi/i&lt;/a&gt;&lt;/code&gt; 一致するラテン小文字LFIのように、単一の合字文字に一致するASCII文字のシーケンスがあります。 Perl v5.16以降では、ASCIIの一致のみを考慮する場合、 &lt;code&gt;/aa&lt;/code&gt; 修飾子を正規表現に追加すると、これらの明白でない一致がすべて除外されるため、このメッセージが表示されなくなります。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re qw(/aa)&lt;/code&gt; と言って、スコープ内でコンパイルされたすべての正規表現に &lt;code&gt;/aa&lt;/code&gt; を適用することもできます。&lt;a href=&quot;re&quot;&gt;reを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="e5ad264a4513834556a80639fe98434e6bc7fc63" translate="yes" xml:space="preserve">
          <source>There are now two nested loops in the code: the outer loop for reading the compressed data from STDIN, as before; and the inner loop to carry out the uncompression.</source>
          <target state="translated">コードには、以前と同様に STDIN から圧縮されたデータを読み込むための外側のループと、圧縮を解除するための内側のループの 2 つの入れ子になったループがあります。</target>
        </trans-unit>
        <trans-unit id="30d7f3a596ae687e7d1a74baf88a83df7d754b06" translate="yes" xml:space="preserve">
          <source>There are only a few attributes currently handled by Perl itself (or directly by this module, depending on how you look at it.) However, package-specific attributes are allowed by an extension mechanism. (See &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;&quot;Package-specific Attribute Handling&quot;&lt;/a&gt; below.)</source>
          <target state="translated">現在Perl自体によって（または、見方によってはこのモジュールによって直接）処理されている属性はごくわずかです。ただし、パッケージ固有の属性は拡張メカニズムによって許可されています。（以下の&lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;「パッケージ固有の属性処理」を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="a69e0c87595733580f5c73f14c1fdeb5543877d6" translate="yes" xml:space="preserve">
          <source>There are only a few attributes currently handled by Perl itself (or directly by this module, depending on how you look at it.) However, package-specific attributes are allowed by an extension mechanism. (See &lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;Package-specific Attribute Handling&lt;/a&gt; below.)</source>
          <target state="translated">現在、Perl自体によって（または、見方によっては、このモジュールによって直接）処理される属性はわずかです。ただし、パッケージ固有の属性は、拡張メカニズムによって許可されます。（以下の&lt;a href=&quot;#Package-specific-Attribute-Handling&quot;&gt;パッケージ固有の属性処理を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="108ccf06b73794e0f286d42a6259562039de6c36" translate="yes" xml:space="preserve">
          <source>There are other documents which might contain the information that you're looking for:</source>
          <target state="translated">他にも、探している情報が入っているかもしれない書類があります。</target>
        </trans-unit>
        <trans-unit id="ffadbd86efea8ed0c7e9318ac1bd6a93e63feaa1" translate="yes" xml:space="preserve">
          <source>There are other minor differences, particularly regarding &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt;, but in general, the correspondence is extremely close.</source>
          <target state="translated">特に &lt;code&gt;&lt;a href=&quot;../functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;../functions/delete&quot;&gt;delete&lt;/a&gt;&lt;/code&gt; に関しては、他にも小さな違いがありますが、一般に、対応は非常に密接です。</target>
        </trans-unit>
        <trans-unit id="496c73a8b66b8bb32b2aaf26def98246996ff9e4" translate="yes" xml:space="preserve">
          <source>There are other minor differences, particularly regarding &lt;code&gt;exists&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, but in general, the correspondence is extremely close.</source>
          <target state="translated">特に &lt;code&gt;exists&lt;/code&gt; と &lt;code&gt;delete&lt;/code&gt; に関しては、他にも小さな違いがありますが、一般的には非常に密接に対応しています。</target>
        </trans-unit>
        <trans-unit id="e7bb3958077e624c5300c166b4aa5d1f00cfb6ff" translate="yes" xml:space="preserve">
          <source>There are other runtime options as well. You can use &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">他の実行時オプションもあります。 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; を使用できます：</target>
        </trans-unit>
        <trans-unit id="1c3cf0f599cf582932d460a014aeed655f3e2812" translate="yes" xml:space="preserve">
          <source>There are other runtime options as well. You can use &lt;code&gt;pack()&lt;/code&gt;:</source>
          <target state="translated">他のランタイムオプションもあります。 &lt;code&gt;pack()&lt;/code&gt; を使用できます：</target>
        </trans-unit>
        <trans-unit id="fae6e762f25c5a7d9726dbb80f1e49251722d367" translate="yes" xml:space="preserve">
          <source>There are platforms where longs are 64 bits, and platforms where ints are 64 bits, and while we are out to shock you, even platforms where shorts are 64 bits. This is all legal according to the C standard. (In other words, &quot;long long&quot; is not a portable way to specify 64 bits, and &quot;long long&quot; is not even guaranteed to be any wider than &quot;long&quot;.)</source>
          <target state="translated">ロングが64ビットのプラットフォームと イントが64ビットのプラットフォームがあります あなたにショックを与えようとしている間に ショートが64ビットのプラットフォームさえあります これはC規格によれば、すべて合法です。(言い換えれば、&quot;long long &quot;は64ビットを指定するためのポータブルな方法ではないし、&quot;long long &quot;は &quot;long &quot;よりも幅が広くなることすら保証されていない)。</target>
        </trans-unit>
        <trans-unit id="a1d48b6e5e54bf5c7c0f9c8f92bbb4b843c99efe" translate="yes" xml:space="preserve">
          <source>There are probably many more bugs on non-ASCII platforms (EBCDIC).</source>
          <target state="translated">非ASCIIプラットフォーム(EBCDIC)では、おそらくもっと多くのバグがあると思われます。</target>
        </trans-unit>
        <trans-unit id="6034cbb411ab9fcf9d496b60426633cf7c795bb5" translate="yes" xml:space="preserve">
          <source>There are quite a few systems out there that do worse!</source>
          <target state="translated">もっと悪いことをするシステムはかなりの数があります。</target>
        </trans-unit>
        <trans-unit id="1d2d754395a1d1b23e17d21c745bf8aafd6b351f" translate="yes" xml:space="preserve">
          <source>There are rare cases where this package-based resolution can be a problem. If you copy a subroutine from one package to another, &lt;code&gt;SUPER&lt;/code&gt; resolution will be done based on the original package.</source>
          <target state="translated">このパッケージベースの解決が問題になることがあるまれなケースがあります。あるパッケージから別のパッケージにサブルーチンをコピーすると、元のパッケージに基づいて &lt;code&gt;SUPER&lt;/code&gt; 解決が行われます。</target>
        </trans-unit>
        <trans-unit id="af62a9f4883bfebec9e4b48e9587f48259af1d0b" translate="yes" xml:space="preserve">
          <source>There are really two tracks of perl development: a maintenance version and an experimental version. The maintenance versions are stable, and have an even number as the minor release (i.e. perl5.18.x, where 18 is the minor release). The experimental versions may include features that don't make it into the stable versions, and have an odd number as the minor release (i.e. perl5.19.x, where 19 is the minor release).</source>
          <target state="translated">perlの開発には、保守版と実験版の2つのトラックがあります。保守版は安定版で、マイナーリリースとして偶数の番号が付けられています (例:perl5.18.x、18はマイナーリリースです)。実験的なバージョンは安定版にはない機能が含まれている可能性があり、マイナーリリースとして奇数の番号が付けられています (例:perl5.19.x,ここでは19がマイナーリリースです)。</target>
        </trans-unit>
        <trans-unit id="f3f1aa2e43835efb5ebefe1c81df4f88e92a3e7e" translate="yes" xml:space="preserve">
          <source>There are really two tracks of perl development: a maintenance version and an experimental version. The maintenance versions are stable, and have an even number as the minor release (i.e. perl5.24.x, where 24 is the minor release). The experimental versions may include features that don't make it into the stable versions, and have an odd number as the minor release (i.e. perl5.25.x, where 25 is the minor release).</source>
          <target state="translated">perlの開発には、保守版と実験版の2つのトラックがあります。保守版は安定版で、マイナーリリースとして偶数の番号が付けられています(例:perl5.24.x、24はマイナーリリースです)。実験的なバージョンは安定版にはない機能が含まれている可能性があり、マイナーリリースとして奇数の番号が付けられています (例:perl5.25.x,ここでは25がマイナーリリースです)。</target>
        </trans-unit>
        <trans-unit id="b1bf8726c4584d2c3d7eed2a3217ca6397579941" translate="yes" xml:space="preserve">
          <source>There are several I/O operators you should know about.</source>
          <target state="translated">知っておくべきI/Oオペレータがいくつかあります。</target>
        </trans-unit>
        <trans-unit id="2fda79a606c9c0725617e5e789142491b7fdc787" translate="yes" xml:space="preserve">
          <source>There are several ambiguous cases where a conversion routine cannot determine whether an input filename is in Unix format or in VMS format, since now both VMS and Unix file specifications may have characters in them that could be mistaken for syntax delimiters of the other type. So some pathnames simply cannot be used in a mode that allows either type of pathname to be present. Perl will tend to assume that an ambiguous filename is in Unix format.</source>
          <target state="translated">変換ルーチンが入力ファイル名がUnix形式かVMS形式かを判断できない曖昧なケースがいくつかあります。そのため、パス名の中には、どちらかのタイプのパス名が存在することを許すモードでは使えないものもあります。Perl は曖昧なファイル名が Unix フォーマットであると仮定する傾向があります。</target>
        </trans-unit>
        <trans-unit id="83b566d12c94cc6ef80e2c552897da25fbcd52af" translate="yes" xml:space="preserve">
          <source>There are several components in CPAN.pm that use environment variables. The build tools, &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; and &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; use some, while others matter to the levels above them. Some of these are specified by the Perl Toolchain Gang:</source>
          <target state="translated">CPAN.pmには、環境変数を使用するコンポーネントがいくつかあります。ビルドツールである&lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt;と&lt;a href=&quot;Module::Build&quot;&gt;Module :: Build&lt;/a&gt;はいくつかを使用しますが、他のツールはそれらより上のレベルに関係します。これらのいくつかは、Perl ToolchainGangによって指定されています。</target>
        </trans-unit>
        <trans-unit id="dc2d6ce8616f44441a994dbb2d806ba6e4997805" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying countries. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">国を識別するために使用できるコードセットはいくつかあります。コードセットは名前か、このモジュールによって自動的にエクスポートされる定数を使って指定することができます。</target>
        </trans-unit>
        <trans-unit id="74b369e9ecdad508287761106812f2205698bcfc" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying currencies. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">通貨を識別するために使用できるコードセットはいくつかあります。コードセットを指定するには、名前を指定するか、このモジュールで自動的にエクスポートされる定数を使用します。</target>
        </trans-unit>
        <trans-unit id="c5df10a209c7b9d0bd6df6a76c15e47c845b73fd" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying languages. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">言語を識別するために使用できるコードセットはいくつかあります。コードセットは名前か、このモジュールによって自動的にエクスポートされる定数を使って指定することができます。</target>
        </trans-unit>
        <trans-unit id="357e0be22039446c2158a4027e1ee33566fa847b" translate="yes" xml:space="preserve">
          <source>There are several different code sets you can use for identifying scripts. A code set may be specified using either a name, or a constant that is automatically exported by this module.</source>
          <target state="translated">スクリプトを識別するために使用できるコードセットはいくつかあります。コードセットは名前か、このモジュールによって自動的にエクスポートされる定数を使って指定することができます。</target>
        </trans-unit>
        <trans-unit id="c871d77268a0e9a3faf86ba66c7adbf672f7193a" translate="yes" xml:space="preserve">
          <source>There are several escape sequences that convert characters or strings between upper and lower case, and they are also available within patterns. &lt;code&gt;\l&lt;/code&gt; and &lt;code&gt;\u&lt;/code&gt; convert the next character to lower or upper case, respectively:</source>
          <target state="translated">文字または文字列を大文字と小文字の間で変換するエスケープシーケンスがいくつかあり、それらはパターン内でも使用できます。 &lt;code&gt;\l&lt;/code&gt; および &lt;code&gt;\u&lt;/code&gt; は、次の文字をそれぞれ小文字または大文字に変換します。</target>
        </trans-unit>
        <trans-unit id="8dd1b15a1dbfd18df05cd02be13096a5a0b828cf" translate="yes" xml:space="preserve">
          <source>There are several functions available to specify characters and code points portably in tests. The always-preloaded functions &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; and its inverse &lt;code&gt;utf8::native_to_unicode()&lt;/code&gt; take code points and translate appropriately. The file</source>
          <target state="translated">テストで移植性のある文字とコードポイントを指定するために使用できるいくつかの関数があります。常にプリロードされている関数 &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; とその逆の &lt;code&gt;utf8::native_to_unicode()&lt;/code&gt; はコードポイントを取り、適切に変換します。ファイル</target>
        </trans-unit>
        <trans-unit id="324d2fa183413ecef672812d1ff51b1b76337a11" translate="yes" xml:space="preserve">
          <source>There are several great resources for locating workshops: the &lt;a href=&quot;#Websites&quot;&gt;websites&lt;/a&gt; mentioned above, the &lt;a href=&quot;#Calendar-of-Perl-Events&quot;&gt;calendar&lt;/a&gt; mentioned below, and the YAPC Europe website, &lt;a href=&quot;http://www.yapceurope.org/&quot;&gt;http://www.yapceurope.org/&lt;/a&gt;, which is probably the best resource for European Perl events.</source>
          <target state="translated">ワークショップを探すための優れたリソースがいくつかあります。上記の&lt;a href=&quot;#Websites&quot;&gt;Webサイト&lt;/a&gt;、下記の&lt;a href=&quot;#Calendar-of-Perl-Events&quot;&gt;カレンダー&lt;/a&gt;、およびYAPCヨーロッパのWebサイト&lt;a href=&quot;http://www.yapceurope.org/&quot;&gt;http://www.yapceurope.org/です&lt;/a&gt;。これは、おそらくヨーロッパのPerlイベントに最適なリソースです。</target>
        </trans-unit>
        <trans-unit id="832a8879ea071712935214efe0cfd19085976c3b" translate="yes" xml:space="preserve">
          <source>There are several of these, which are equivalents, using the &lt;code&gt;\p{}&lt;/code&gt; notation, for Posix classes and are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">これらはいくつかあり、Posixクラスには &lt;code&gt;\p{}&lt;/code&gt; 表記を使用したものと同等であり、&lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclassの「POSIX文字クラス」で&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="70817f22a3f6a9efb5f508894682105db2aa6387" translate="yes" xml:space="preserve">
          <source>There are several of these, which are equivalents, using the &lt;code&gt;\p{}&lt;/code&gt; notation, for Posix classes and are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">これらのいくつかは、Posixクラスの &lt;code&gt;\p{}&lt;/code&gt; 表記を使用して同等であり、&lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclassのPOSIX文字クラスで&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="f33ad2d3a2c17446bc61c87b03a2741b5207b2ef" translate="yes" xml:space="preserve">
          <source>There are several of these, which are the standard Posix classes extended to the full Unicode range. They are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;&quot;POSIX Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">これらのいくつかがあり、Unicodeの全範囲に拡張された標準のPosixクラスです。それらは&lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;、perlrecharclassの「POSIX文字クラス」で&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="1f83d1183ceda85cce3fcdc239963f72e745557e" translate="yes" xml:space="preserve">
          <source>There are several of these, which are the standard Posix classes extended to the full Unicode range. They are described in &lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;POSIX Character Classes in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">これらのいくつかは、Unicodeの全範囲に拡張された標準のPosixクラスです。それらは&lt;a href=&quot;perlrecharclass#POSIX-Character-Classes&quot;&gt;perlrecharclassのPOSIX文字クラスで&lt;/a&gt;説明されています。</target>
        </trans-unit>
        <trans-unit id="ff60b9f3f7c3df35d25431cc4664ba95f5cce4d6" translate="yes" xml:space="preserve">
          <source>There are several types of character class tests that Perl implements. The only ones described here are those that directly correspond to C library functions that operate on 8-bit characters, but there are equivalents that operate on wide characters, and UTF-8 encoded strings. All are more fully described in &lt;a href=&quot;perlapi#Character-classification&quot;&gt;&quot;Character classification&quot; in perlapi&lt;/a&gt; and &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;&quot;Character case changing&quot; in perlapi&lt;/a&gt;.</source>
          <target state="translated">Perlが実装する文字クラステストにはいくつかの種類があります。ここで説明するのは、8ビット文字を操作するCライブラリ関数に直接対応するものだけですが、ワイド文字とUTF-8でエンコードされた文字列を操作する同等のものがあります。すべては&lt;a href=&quot;perlapi#Character-classification&quot;&gt;、perlapiの「文字分類」&lt;/a&gt;およびperlapiの&lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;「文字大文字小文字の変更」で&lt;/a&gt;より完全に説明されています。</target>
        </trans-unit>
        <trans-unit id="e3db56f779a367ad8451b62021cf957e6240bc01" translate="yes" xml:space="preserve">
          <source>There are several types of character class tests that Perl implements. The only ones described here are those that directly correspond to C library functions that operate on 8-bit characters, but there are equivalents that operate on wide characters, and UTF-8 encoded strings. All are more fully described in &lt;a href=&quot;perlapi#Character-classification&quot;&gt;Character classification in perlapi&lt;/a&gt; and &lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;Character case changing in perlapi&lt;/a&gt;.</source>
          <target state="translated">Perlが実装する文字クラステストにはいくつかのタイプがあります。ここで説明するものは、8ビット文字を操作するCライブラリ関数に直接対応するものだけですが、ワイド文字とUTF-8エンコード文字列を操作する同等のものがあります。すべてについては&lt;a href=&quot;perlapi#Character-classification&quot;&gt;、ペルラピ&lt;/a&gt;での文字分類とペルラピでの&lt;a href=&quot;perlapi#Character-case-changing&quot;&gt;文字の大文字小文字の変更で&lt;/a&gt;詳しく説明しています。</target>
        </trans-unit>
        <trans-unit id="f2e0a93aaf35e3ad5cd5182c4904a3f139cb368f" translate="yes" xml:space="preserve">
          <source>There are several ways to call the debugger:</source>
          <target state="translated">デバッガを呼び出す方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="e8db18a3a166163bfb23804a9a1202e4ece1bc54" translate="yes" xml:space="preserve">
          <source>There are several ways to wrap your Perl scripts in DCL</source>
          <target state="translated">Perl スクリプトを DCL でラップする方法はいくつかあります。</target>
        </trans-unit>
        <trans-unit id="9d4463c6ded942fe4cd0ec81ef54653fbdb5493c" translate="yes" xml:space="preserve">
          <source>There are some bugs in the &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&quot;U0&quot;&lt;/code&gt; template</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&quot;U0&quot;&lt;/code&gt; テンプレートにいくつかのバグがあります</target>
        </trans-unit>
        <trans-unit id="5363960c51ded4425aac0c5e8d1bf8c47e9bafcf" translate="yes" xml:space="preserve">
          <source>There are some cases where Perl can't immediately tell the difference between an expression and a statement. For instance, the syntax for a block and an anonymous hash reference constructor look the same unless there's something in the braces to give Perl a hint. The ellipsis is a syntax error if Perl doesn't guess that the &lt;code&gt;{ ... }&lt;/code&gt; is a block. In that case, it doesn't think the &lt;code&gt;...&lt;/code&gt; is an ellipsis because it's expecting an expression instead of a statement:</source>
          <target state="translated">Perlが式とステートメントの違いをすぐに判断できない場合があります。たとえば、ブロックと匿名ハッシュ参照コンストラクタの構文は、Perlにヒントを与えるための括弧がない場合を除いて、同じように見えます。 Perlが &lt;code&gt;{ ... }&lt;/code&gt; がブロックであると推測しない場合、省略記号は構文エラーです。その場合、ステートメントではなく式を想定しているため、 &lt;code&gt;...&lt;/code&gt; は省略記号であるとは見なされません。</target>
        </trans-unit>
        <trans-unit id="56b7755399d4ee6979402a39fa3144930c83cfee" translate="yes" xml:space="preserve">
          <source>There are some cases where Perl can't immediately tell the difference between an expression and a statement. For instance, the syntax for a block and an anonymous hash reference constructor look the same unless there's something in the braces to give Perl a hint. The ellipsis is a syntax error if Perl doesn't guess that the &lt;code&gt;{ ... }&lt;/code&gt; is a block. Inside your block, you can use a &lt;code&gt;;&lt;/code&gt; before the ellipsis to denote that the &lt;code&gt;{ ... }&lt;/code&gt; is a block and not a hash reference constructor.</source>
          <target state="translated">Perlが式とステートメントの違いをすぐに見分けられない場合があります。たとえば、ブロックと匿名ハッシュ参照コンストラクターの構文は、Perlにヒントを与える中括弧内に何かがない限り、同じように見えます。 Perlが &lt;code&gt;{ ... }&lt;/code&gt; がブロックであると推測しない場合、省略記号は構文エラーです。ブロック内では、 &lt;code&gt;;&lt;/code&gt; を使用できます。省略記号の前に、 &lt;code&gt;{ ... }&lt;/code&gt; がブロックであり、ハッシュ参照コンストラクターではないことを示します。</target>
        </trans-unit>
        <trans-unit id="83d390e2b6c3127ccfec700a0a95db3ede4e9652" translate="yes" xml:space="preserve">
          <source>There are some caveats with the use of runtime statements like &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter&lt;/code&gt; and the assignment to package variables, which can be very subtle for the unaware programmer. This may happen for instance with mutually recursive modules, which are affected by the time the relevant constructions are executed.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter&lt;/code&gt; やパッケージ変数への割り当てなどのランタイムステートメントの使用にはいくつかの注意点があります。これは、知らないプログラマにとっては非常に微妙です。これは、たとえば、相互に再帰的なモジュールで発生する可能性があり、関連する構造が実行される時間によって影響を受けます。</target>
        </trans-unit>
        <trans-unit id="4f5521a0adc9e1424f0db1d5eef9bf6747b3a1ab" translate="yes" xml:space="preserve">
          <source>There are some caveats with the use of runtime statements like &lt;code&gt;require Exporter&lt;/code&gt; and the assignment to package variables, which can be very subtle for the unaware programmer. This may happen for instance with mutually recursive modules, which are affected by the time the relevant constructions are executed.</source>
          <target state="translated">&lt;code&gt;require Exporter&lt;/code&gt; やパッケージ変数への割り当てなどのランタイムステートメントの使用にはいくつかの注意点がありますが、これは知らないプログラマーにとっては非常に微妙な場合があります。これは、たとえば、関連する構造が実行される時間の影響を受ける相互再帰モジュールで発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="344f93501dc28c704b9a2e67faf75c375217d583" translate="yes" xml:space="preserve">
          <source>There are some complications that are ignored in the examples above:</source>
          <target state="translated">上記の例では無視されるような合併症があります。</target>
        </trans-unit>
        <trans-unit id="9d05d692911a48f923ff823586f7db33a368c559" translate="yes" xml:space="preserve">
          <source>There are some convenience functions available that can help with the destruction of xVs. These functions introduce the concept of &quot;mortality&quot;. An xV that is mortal has had its reference count marked to be decremented, but not actually decremented, until &quot;a short time later&quot;. Generally the term &quot;short time later&quot; means a single Perl statement, such as a call to an XSUB function. The actual determinant for when mortal xVs have their reference count decremented depends on two macros, SAVETMPS and FREETMPS. See &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; and &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for more details on these macros.</source>
          <target state="translated">xVの破棄に役立つ便利な関数がいくつかあります。これらの関数は、「死亡率」の概念を導入します。致命的であるxVの参照カウントは減らされるようにマークされていますが、実際には減らされていませんが、「しばらくしてから」になります。一般に、「短時間後」という用語は、XSUB関数の呼び出しなどの単一のPerlステートメントを意味します。致命的なxVの参照カウントが減らされる実際の決定要因は、SAVETMPSとFREETMPSの2つのマクロに依存します。参照&lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt;と&lt;a href=&quot;perlxs&quot;&gt;perlxsを&lt;/a&gt;これらのマクロの詳細については。</target>
        </trans-unit>
        <trans-unit id="0d7095e4177705611245878da2c1cd341f565d3b" translate="yes" xml:space="preserve">
          <source>There are some convenience functions available that can help with the destruction of xVs. These functions introduce the concept of &quot;mortality&quot;. Much documentation speaks of an xV itself being mortal, but this is misleading. It is really</source>
          <target state="translated">xVの破壊に役立つ便利な機能がいくつか用意されています。これらの関数は &quot;死亡 &quot;という概念を導入しています。多くのドキュメントでは xV 自体が死を免れないとされていますが、これは誤解を招くようなものです。実際には</target>
        </trans-unit>
        <trans-unit id="0aad51f0e11a34d98334dfd8a5325d2defc4e5c1" translate="yes" xml:space="preserve">
          <source>There are some different considerations for each form:</source>
          <target state="translated">それぞれの形には、いくつかの配慮があります。</target>
        </trans-unit>
        <trans-unit id="34b9699f0d3b28a88deb2c4c365035a0647ae160" translate="yes" xml:space="preserve">
          <source>There are some difficulties in using the tied hash interface if you want to manipulate a BTREE database with duplicate keys. Consider this code:</source>
          <target state="translated">重複したキーを持つ BTREE データベースを操作したい場合には、タイドハッシュインターフェイスを使用することにはいくつかの困難があります。以下のコードを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="c09cd4cd0008c42a9eb3710539a1c18a01958eae" translate="yes" xml:space="preserve">
          <source>There are some downsides here: the size economy will not stand at runtime after this &lt;code&gt;init()&lt;/code&gt; runs. But it should not be that critical, since if you don't have space for that, you won't have space for any other language besides the main one as well. You could do that too with ties, expanding the value at lookup time which should be more time expensive as an option.</source>
          <target state="translated">ここにはいくつかの欠点があります。この &lt;code&gt;init()&lt;/code&gt; の実行後、サイズエコノミーは実行時に機能しません。ただし、そのためのスペースがない場合は、メイン言語以外の言語のためのスペースもないため、それほど重要ではありません。ネクタイを使用してこれを行うこともできます。ルックアップ時に値を拡張します。これは、オプションとしてより時間がかかるはずです。</target>
        </trans-unit>
        <trans-unit id="c652dbfd06883d908b23bc1bfea111a0463399a9" translate="yes" xml:space="preserve">
          <source>There are some drawbacks to this approach. One is that any extension which calls any file-manipulating C function will need to be recompiled (just follow the usual &quot;perl Makefile.PL; make; make test; make install&quot; procedure).</source>
          <target state="translated">この方法にはいくつかの欠点があります。一つは、ファイルを操作する C 関数を呼び出す拡張モジュールは、再コンパイルが必要になることです (通常の &quot;perl Makefile.PL;make;make;make test;make install&quot; の手順に従ってください)。</target>
        </trans-unit>
        <trans-unit id="9cd4d89394373d1a964c062cbd37f2a471efcbee" translate="yes" xml:space="preserve">
          <source>There are some locale-related library calls that still aren't thread-safe because they return data in a buffer global to all threads. In the past, these didn't matter as locales weren't thread-safe at all. But now you have to be aware of them in case your module is called in a multi-threaded application. The known ones are</source>
          <target state="translated">ロケール関連のライブラリコールの中には、スレッドセーフではないものもあります。過去には、ロケールはスレッドセーフではなかったので、これらは問題になりませんでした。しかし今では、マルチスレッドアプリケーションでモジュールが呼び出された場合に備えて、これらに注意しなければなりません。既知のものは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="0b359481d6fbdc6a6a4b31621c42bd37e3d7940e" translate="yes" xml:space="preserve">
          <source>There are some obvious disadvantages with this technique.</source>
          <target state="translated">この手法には明らかなデメリットがあります。</target>
        </trans-unit>
        <trans-unit id="5ca89f8811d4cbda81105708f26c4da2bc407dd8" translate="yes" xml:space="preserve">
          <source>There are some optional options you can pass to &lt;code&gt;memoize&lt;/code&gt; to change the way it behaves a little. To supply options, invoke &lt;code&gt;memoize&lt;/code&gt; like this:</source>
          <target state="translated">少し動作を変更するために &lt;code&gt;memoize&lt;/code&gt; するために渡すことができるオプションのオプションがいくつかあります。オプションを提供するには、 &lt;code&gt;memoize&lt;/code&gt; ようにmemoizeを呼び出します。</target>
        </trans-unit>
        <trans-unit id="94c539cef62e9aa25e310b57bc5c00ca12ad3ddb" translate="yes" xml:space="preserve">
          <source>There are some shortcuts for oneliners; see &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;-C in perlrun&lt;/a&gt;.</source>
          <target state="translated">ワンライナーにはいくつかの近道があります。&lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;perlrunの-Cを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="362784bb7e407303367ae06c7f4d21b101719adc" translate="yes" xml:space="preserve">
          <source>There are some shortcuts for oneliners; see &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C&lt;/a&gt; in &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;.</source>
          <target state="translated">ワンライナーにはいくつかのショートカットがあります。&lt;a href=&quot;perlrun&quot;&gt;perlrunの&lt;/a&gt;&lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="242b6f00a4806779b2651b44eef8a2d396dd9333" translate="yes" xml:space="preserve">
          <source>There are some special instructions for building Perl with Sun Studio on Linux. Following the normal &lt;code&gt;Configure&lt;/code&gt;, you have to run make as follows:</source>
          <target state="translated">Linux上のSunStudioでPerlを構築するための特別な手順がいくつかあります。通常の &lt;code&gt;Configure&lt;/code&gt; に従って、次のようにmakeを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="eb6709b6148bb02040a39a95e98f282835dfc33f" translate="yes" xml:space="preserve">
          <source>There are some warnings with respect to malformed hyperlinks:</source>
          <target state="translated">不正なハイパーリンクに関していくつかの警告があります。</target>
        </trans-unit>
        <trans-unit id="ce8df6ad608907441859c0c720df59bd6834bb9d" translate="yes" xml:space="preserve">
          <source>There are still many places where Unicode (in some encoding or another) could be given as arguments or received as results, or both in Perl, but it is not, in spite of Perl having extensive ways to input and output in Unicode, and a few other &quot;entry points&quot; like the &lt;code&gt;@ARGV&lt;/code&gt; array (which can sometimes be interpreted as UTF-8).</source>
          <target state="translated">Unicodeを引数として与えたり、結果として受け取ったり、Perlで受け取ることができる場所はまだたくさんありますが、PerlがUnicodeで入出力するための広範な方法を持っているにもかかわらず、そうではありません。 &lt;code&gt;@ARGV&lt;/code&gt; 配列（UTF-8として解釈される場合がある）のような他のいくつかの「エントリポイント」。</target>
        </trans-unit>
        <trans-unit id="59db2905dffb1315acaf3a1dc211ceadeec4d5cb" translate="yes" xml:space="preserve">
          <source>There are three Command Line flags that can be used to control when warnings are (or aren't) produced:</source>
          <target state="translated">3 つのコマンドラインフラグがあり、警告を出す (または出さない)タイミングを制御するために使用できます。</target>
        </trans-unit>
        <trans-unit id="10489a4543147a152f672e9c6f67f2c24de29afb" translate="yes" xml:space="preserve">
          <source>There are three basic ways of running external commands:</source>
          <target state="translated">外部コマンドの基本的な実行方法は3つあります。</target>
        </trans-unit>
        <trans-unit id="ee1484d5257f2915d554120f4ce6bfb497ce1d27" translate="yes" xml:space="preserve">
          <source>There are three basic ways that you can structure a threaded program. Which model you choose depends on what you need your program to do. For many non-trivial threaded programs, you'll need to choose different models for different pieces of your program.</source>
          <target state="translated">スレッド型プログラムを構成するには、3つの基本的な方法があります。どのモデルを選択するかは、プログラムが何をする必要があるかによって異なります。多くの非自明なスレッド型プログラムでは、プログラムのピースごとに異なるモデルを選択する必要があります。</target>
        </trans-unit>
        <trans-unit id="7fc3fd61896b5d12698d6fdcfdceea06c9dc86a3" translate="yes" xml:space="preserve">
          <source>There are three distinct concepts of &quot;next&quot; in the regex engine, and it is important to keep them clear.</source>
          <target state="translated">正規表現エンジンには、&quot;next &quot;という3つの明確な概念があり、それらを明確にしておくことが重要です。</target>
        </trans-unit>
        <trans-unit id="95aff53d816fd931550c2a4895fd2449f30b17c2" translate="yes" xml:space="preserve">
          <source>There are three popular ways to avoid this overhead. One solution involves running the Apache HTTP server (available from &lt;a href=&quot;http://www.apache.org/&quot;&gt;http://www.apache.org/&lt;/a&gt; ) with either of the mod_perl or mod_fastcgi plugin modules.</source>
          <target state="translated">このオーバーヘッドを回避するには、3つの一般的な方法があります。1つの解決策は、mod_perlまたはmod_fastcgiプラグインモジュールのいずれかでApache HTTPサーバー（&lt;a href=&quot;http://www.apache.org/&quot;&gt;http://www.apache.org/&lt;/a&gt;から入手可能）を実行することです。</target>
        </trans-unit>
        <trans-unit id="99df9d7a05fef99c9f9af3d138353a09ea2aa37e" translate="yes" xml:space="preserve">
          <source>There are three types of character classes in Perl regular expressions: the dot, backslash sequences, and the form enclosed in square brackets. Keep in mind, though, that often the term &quot;character class&quot; is used to mean just the bracketed form. Certainly, most Perl documentation does that.</source>
          <target state="translated">Perl の正規表現には、ドット、バックスラッシュ、角括弧で囲まれた形の 3 種類の文字クラスがあります。しかし、しばしば「文字クラス」という用語は、括弧で囲まれた形だけを意味するために使われることがあることに注意してください。確かに、ほとんどのPerlのドキュメントではそのようになっています。</target>
        </trans-unit>
        <trans-unit id="a78a1c3edbdc828e2c5469275355a4d4c1a4e525" translate="yes" xml:space="preserve">
          <source>There are three ways to do this. First, the easy but inefficient way, which is also the default, in order to maintain source compatibility with extensions: whenever</source>
          <target state="translated">これには3つの方法があります。まず、簡単ではありますが非効率的な方法で、これはデフォルトでもあります。</target>
        </trans-unit>
        <trans-unit id="95c05fa69dfba88648a1ac130ade8afd3e3bcc34" translate="yes" xml:space="preserve">
          <source>There are three ways to write a test in the core: &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;,</source>
          <target state="translated">コアでテストを作成するには、次の3つの方法があります&lt;a href=&quot;Test::More&quot;&gt;。Test:: More&lt;/a&gt;、</target>
        </trans-unit>
        <trans-unit id="7d88ffa178365fa0703151483456030669a9d8af" translate="yes" xml:space="preserve">
          <source>There are three ways to write a test in the core: &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt;,</source>
          <target state="translated">コアでテストを書く方法は3つあります：&lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt;、</target>
        </trans-unit>
        <trans-unit id="1233ca5594cc5aa5bc69145748e72c13824fb763" translate="yes" xml:space="preserve">
          <source>There are three ways to write your own source filter. You can write it in C, use an external program as a filter, or write the filter in Perl. I won't cover the first two in any great detail, so I'll get them out of the way first. Writing the filter in Perl is most convenient, so I'll devote the most space to it.</source>
          <target state="translated">自作のソースフィルタを書くには3つの方法があります。C で書く方法、外部プログラムをフィルタとして使う方法、Perl で書く方法です。前者の二つについては詳しくは触れませんので、先に説明しておきます。Perl で書くのが一番便利なので、ここでは割愛します。</target>
        </trans-unit>
        <trans-unit id="4d1ca307ab6382d572650b48515269fd5ebc805c" translate="yes" xml:space="preserve">
          <source>There are times when you may find it useful to have a thread explicitly give up the CPU to another thread. You may be doing something processor-intensive and want to make sure that the user-interface thread gets called frequently. Regardless, there are times that you might want a thread to give up the processor.</source>
          <target state="translated">スレッドが明示的に他のスレッドにCPUを譲ることが便利な場合もあるでしょう。例えば、プロセッサ集約的な処理を行っていて、ユーザーインターフェースのスレッドが頻繁に呼び出されるようにしたい場合などです。いずれにしても、スレッドがプロセッサを放棄したい場合もあるでしょう。</target>
        </trans-unit>
        <trans-unit id="aabf4548dd9ce503cb7793127ff7d0d6ca4a9258" translate="yes" xml:space="preserve">
          <source>There are two basic modes of operation (plus turning if off):</source>
          <target state="translated">基本的な動作モードは2つあります(プラスオフの場合はターン)。</target>
        </trans-unit>
        <trans-unit id="a13ac870bbe694381404312541ad897bb1c7bfff" translate="yes" xml:space="preserve">
          <source>There are two callbacks, &lt;code&gt;named_buff&lt;/code&gt; is called in all the cases the FETCH, STORE, DELETE, CLEAR, EXISTS and SCALAR &lt;a href=&quot;Tie::Hash&quot;&gt;Tie::Hash&lt;/a&gt; callbacks would be on changes to &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; and &lt;code&gt;named_buff_iter&lt;/code&gt; in the same cases as FIRSTKEY and NEXTKEY.</source>
          <target state="translated">2つのコールバック、あります &lt;code&gt;named_buff&lt;/code&gt; は、FETCHすべてのケースで呼び出され、STORE、DELETE、CLEAR、EXISTSとSCALAR&lt;a href=&quot;Tie::Hash&quot;&gt;ネクタイ::ハッシュ&lt;/a&gt;コールバックはへ変更になり &lt;code&gt;%+&lt;/code&gt; および &lt;code&gt;%-&lt;/code&gt; と &lt;code&gt;named_buff_iter&lt;/code&gt; FIRSTKEYとNEXTKEYと同じ例インチ</target>
        </trans-unit>
        <trans-unit id="53b9f0a36cbfc725453b6b4804987d2d7a53bc2c" translate="yes" xml:space="preserve">
          <source>There are two callbacks, &lt;code&gt;named_buff&lt;/code&gt; is called in all the cases the FETCH, STORE, DELETE, CLEAR, EXISTS and SCALAR &lt;a href=&quot;tie/hash&quot;&gt;Tie::Hash&lt;/a&gt; callbacks would be on changes to &lt;code&gt;%+&lt;/code&gt; and &lt;code&gt;%-&lt;/code&gt; and &lt;code&gt;named_buff_iter&lt;/code&gt; in the same cases as FIRSTKEY and NEXTKEY.</source>
          <target state="translated">2つのコールバックがあります &lt;code&gt;named_buff&lt;/code&gt; は、FETCH、STORE、DELETE、CLEAR、EXISTSおよびSCALAR &lt;a href=&quot;tie/hash&quot;&gt;Tie :: Hash&lt;/a&gt;コールバックがFIRSTKEYおよびNEXTKEYと同じケースで &lt;code&gt;%+&lt;/code&gt; および &lt;code&gt;%-&lt;/code&gt; と &lt;code&gt;named_buff_iter&lt;/code&gt; に変更されるすべての場合に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="85a26ce9bc0772a2a092df698289266d1f10ecae" translate="yes" xml:space="preserve">
          <source>There are two cases, multi-byte and single-byte locales. First multi-byte:</source>
          <target state="translated">ロケールには、マルチバイトとシングルバイトの2つのケースがあります。まずマルチバイト。</target>
        </trans-unit>
        <trans-unit id="3f6e50ca71fb9ef8a58634080d592b643d6be431" translate="yes" xml:space="preserve">
          <source>There are two cases:</source>
          <target state="translated">2つのケースがあります。</target>
        </trans-unit>
        <trans-unit id="c07255028b3b5bd9a90385fc5c125ed8062cb54e" translate="yes" xml:space="preserve">
          <source>There are two commonly used techniques of profiling executables:</source>
          <target state="translated">実行ファイルのプロファイリングには、一般的に使用されている2つのテクニックがあります。</target>
        </trans-unit>
        <trans-unit id="ca79bf7ca29122cb03591230567965097d73b502" translate="yes" xml:space="preserve">
          <source>There are two different types of version objects, corresponding to the two different styles of versions in use:</source>
          <target state="translated">バージョンオブジェクトには2つの異なるタイプがあり、使用されている2つの異なるスタイルのバージョンに対応しています。</target>
        </trans-unit>
        <trans-unit id="4918f14b7918995ede690de784e45ce5b334a99c" translate="yes" xml:space="preserve">
          <source>There are two distinctive features of the dyna-linking model of OS/2: first, all the references to external functions are resolved at the compile time; second, there is no runtime fixup of the DLLs after they are loaded into memory. The first feature is an enormous advantage over other models: it avoids conflicts when several DLLs used by an application export entries with the same name. In such cases &quot;other&quot; models of dyna-linking just choose between these two entry points using some random criterion - with predictable disasters as results. But it is the second feature which requires the build of</source>
          <target state="translated">第一に、外部関数への参照がすべてコンパイル時に解決されること、第二に、メモリにロードされた後のDLLの実行時の修正がないことです。最初の機能は、他のモデルに比べて非常に大きな利点があります:アプリケーションが使用するいくつかのDLLが同じ名前のエントリをエクスポートするときの競合を回避します。このような場合、ダイナリンクの「他の」モデルは、ランダムな基準を使用して、これら2つのエントリーポイントの間で選択するだけです。しかし、これは</target>
        </trans-unit>
        <trans-unit id="b851bdf3c81b8784e2dddc6e20b8e6c18978a571" translate="yes" xml:space="preserve">
          <source>There are two exit points from the inner uncompression loop.</source>
          <target state="translated">内側の非圧縮ループからの出口は2箇所あります。</target>
        </trans-unit>
        <trans-unit id="108b59b47c97316f062b5266aff655788506a06e" translate="yes" xml:space="preserve">
          <source>There are two forms of octal escapes. Each is used to specify a character by its code point specified in octal notation.</source>
          <target state="translated">八進数エスケープには2つの形式があります。それぞれ、8進数表記で指定されたコードポイントで文字を指定するために使用されます。</target>
        </trans-unit>
        <trans-unit id="172fa4a9b4de533e56c4707adea17699b11d4a1b" translate="yes" xml:space="preserve">
          <source>There are two important points to remember:</source>
          <target state="translated">重要なポイントは2つあります。</target>
        </trans-unit>
        <trans-unit id="ef6d3355d6294c0400eecec7ab06563e8c2ddc8b" translate="yes" xml:space="preserve">
          <source>There are two keys with a special meaning in the hash: &quot;read&quot; and &quot;write&quot;. These contain packlist files. After the copying is done, install() will write the list of target files to $from_to{write}. If $from_to{read} is given the contents of this file will be merged into the written file. The read and the written file may be identical, but on AFS it is quite likely that people are installing to a different directory than the one where the files later appear.</source>
          <target state="translated">ハッシュには特別な意味を持つ2つのキーがあります。&quot;read&quot; と &quot;write&quot; です。これらにはパックリストファイルが含まれています。コピーが行われた後、install()は対象のファイルのリストを $from_to{write}に書き込みます。from_to{read}を指定すると、このファイルの内容が書き込まれたファイルにマージされます。読み込んだファイルと書き込んだファイルは同じかもしれませんが、AFS では、後にファイルが表示されるディレクトリとは別のディレクトリにインストールしている可能性が高いでしょう。</target>
        </trans-unit>
        <trans-unit id="127794821c87aa3c1561f9022c74d909b021fad3" translate="yes" xml:space="preserve">
          <source>There are two main ways that contexts are popped. During normal execution as scopes are exited, functions like &lt;code&gt;pp_leave&lt;/code&gt;, &lt;code&gt;pp_leaveloop&lt;/code&gt; and &lt;code&gt;pp_leavesub&lt;/code&gt; process and pop just one context using &lt;code&gt;cx_popfoo&lt;/code&gt; and &lt;code&gt;cx_popblock&lt;/code&gt;. On the other hand, things like &lt;code&gt;pp_return&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; may have to pop back several scopes until a sub or loop context is found, and exceptions (such as &lt;code&gt;die&lt;/code&gt;) need to pop back contexts until an eval context is found. Both of these are accomplished by &lt;code&gt;dounwind()&lt;/code&gt;, which is capable of processing and popping all contexts above the target one.</source>
          <target state="translated">コンテキストがポップされる主な方法は2つあります。スコープとして通常の実行時には、終了しているような関数 &lt;code&gt;pp_leave&lt;/code&gt; 、 &lt;code&gt;pp_leaveloop&lt;/code&gt; と &lt;code&gt;pp_leavesub&lt;/code&gt; のプロセスと使用してちょうど1コンテキストをポップ &lt;code&gt;cx_popfoo&lt;/code&gt; と &lt;code&gt;cx_popblock&lt;/code&gt; を。一方、 &lt;code&gt;pp_return&lt;/code&gt; や &lt;code&gt;next&lt;/code&gt; のようなものは、サブまたはループコンテキストが見つかるまでいくつかのスコープをポップバックする必要があり、例外（ &lt;code&gt;die&lt;/code&gt; など）はevalコンテキストが見つかるまでコンテキストをポップバックする必要があります。これらは両方とも &lt;code&gt;dounwind()&lt;/code&gt; によって実現されます。これは、ターゲットのコンテキストより上のすべてのコンテキストを処理およびポップすることができます。</target>
        </trans-unit>
        <trans-unit id="f06480546f8f7593dd6ae9d9e44d7bf0995b966a" translate="yes" xml:space="preserve">
          <source>There are two new display parameters.</source>
          <target state="translated">新たに2つの表示パラメータが追加されました。</target>
        </trans-unit>
        <trans-unit id="3c86f1c0ffd1daa198d3368c1af9e850c8735019" translate="yes" xml:space="preserve">
          <source>There are two operands, but no operator giving how you want to combine them.</source>
          <target state="translated">2つのオペランドがありますが、それらをどのように組み合わせるかを指定する演算子はありません。</target>
        </trans-unit>
        <trans-unit id="24dc61084886e44e27660b4a97166077845b5c95" translate="yes" xml:space="preserve">
          <source>There are two package separators in Perl: A double colon (&lt;code&gt;::&lt;/code&gt; ) and a single quote (&lt;code&gt;'&lt;/code&gt;). Normal identifiers can start or end with a double colon, and can contain several parts delimited by double colons. Single quotes have similar rules, but with the exception that they are not legal at the end of an identifier: That is, &lt;code&gt;$'foo&lt;/code&gt; and &lt;code&gt;$foo'bar&lt;/code&gt; are legal, but &lt;code&gt;$foo'bar'&lt;/code&gt; is not.</source>
          <target state="translated">Perlには2つのパッケージ区切り文字があります。二重コロン（ &lt;code&gt;::&lt;/code&gt; :）と単一引用符（ &lt;code&gt;'&lt;/code&gt; ）です。通常の識別子は、ダブルコロンで開始または終了でき、ダブルコロンで区切られたいくつかの部分を含むことができます。単一引用符も同様のルールを持っていますが、識別子の末尾では無効であるという例外があります。つまり、 &lt;code&gt;$'foo&lt;/code&gt; と &lt;code&gt;$foo'bar&lt;/code&gt; は有効ですが、 &lt;code&gt;$foo'bar'&lt;/code&gt; は無効です。</target>
        </trans-unit>
        <trans-unit id="281389919696086dbd7adfd1393b788681ca075b" translate="yes" xml:space="preserve">
          <source>There are two package separators in Perl: A double colon (&lt;code&gt;::&lt;/code&gt;) and a single quote (&lt;code&gt;'&lt;/code&gt;). Normal identifiers can start or end with a double colon, and can contain several parts delimited by double colons. Single quotes have similar rules, but with the exception that they are not legal at the end of an identifier: That is, &lt;code&gt;$'foo&lt;/code&gt; and &lt;code&gt;$foo'bar&lt;/code&gt; are legal, but &lt;code&gt;$foo'bar'&lt;/code&gt; is not.</source>
          <target state="translated">Perlには、二重コロン（ &lt;code&gt;::&lt;/code&gt; :）と一重引用符（ &lt;code&gt;'&lt;/code&gt; ）の2つのパッケージ区切り文字があります。通常の識別子は、二重コロンで開始または終了でき、二重コロンで区切られた複数の部分を含めることができます。一重引用符にも同様のルールがありますが、識別子の末尾が &lt;code&gt;$foo'bar&lt;/code&gt; が異なります。つまり、 &lt;code&gt;$'foo&lt;/code&gt; と$ foo' barは有効ですが、 &lt;code&gt;$foo'bar'&lt;/code&gt; は無効です。</target>
        </trans-unit>
        <trans-unit id="75895a5372bf6c78e51cf652a3ae78bb3d9b2367" translate="yes" xml:space="preserve">
          <source>There are two principal conventions (it is useful to call them &lt;code&gt;Dos*&lt;/code&gt; and &lt;code&gt;Win*&lt;/code&gt; - though this part of the function signature is not always determined by the name of the API) of reporting the error conditions of OS/2 API. Most of &lt;code&gt;Dos*&lt;/code&gt; APIs report the error code as the result of the call (so 0 means success, and there are many types of errors). Most of &lt;code&gt;Win*&lt;/code&gt; API report success/fail via the result being &lt;code&gt;TRUE&lt;/code&gt; /&lt;code&gt;FALSE&lt;/code&gt; ; to find the reason for the failure one should call WinGetLastError() API.</source>
          <target state="translated">OS / 2 APIのエラー状態を報告するには、2つの主要な規則があります（ &lt;code&gt;Dos*&lt;/code&gt; や &lt;code&gt;Win*&lt;/code&gt; *と呼ぶと便利です。ただし、関数シグネチャのこの部分は常にAPIの名前で決まるわけではありません）。ほとんどの &lt;code&gt;Dos*&lt;/code&gt; APIは、呼び出しの結果としてエラーコードを報告します（したがって0は成功を意味し、多くの種類のエラーがあります）。 &lt;code&gt;Win*&lt;/code&gt; APIのほとんどは、結果が &lt;code&gt;TRUE&lt;/code&gt; / &lt;code&gt;FALSE&lt;/code&gt; であることを介して成功/失敗を報告します。失敗の理由を見つけるには、WinGetLastError（）APIを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="2eaa4513f3f865ba65175af81cc35fc35f264abc" translate="yes" xml:space="preserve">
          <source>There are two principal conventions (it is useful to call them &lt;code&gt;Dos*&lt;/code&gt; and &lt;code&gt;Win*&lt;/code&gt; - though this part of the function signature is not always determined by the name of the API) of reporting the error conditions of OS/2 API. Most of &lt;code&gt;Dos*&lt;/code&gt; APIs report the error code as the result of the call (so 0 means success, and there are many types of errors). Most of &lt;code&gt;Win*&lt;/code&gt; API report success/fail via the result being &lt;code&gt;TRUE&lt;/code&gt;/&lt;code&gt;FALSE&lt;/code&gt;; to find the reason for the failure one should call WinGetLastError() API.</source>
          <target state="translated">OS / 2 APIのエラー状態を報告する2つの主要な規則があります（ &lt;code&gt;Dos*&lt;/code&gt; と &lt;code&gt;Win*&lt;/code&gt; *と呼ぶと便利ですが、関数シグネチャのこの部分は必ずしもAPIの名前によって決定されるわけではありません）。ほとんどの &lt;code&gt;Dos*&lt;/code&gt; APIは、呼び出しの結果としてエラーコードを報告します（したがって、0は成功を意味し、多くの種類のエラーがあります）。 &lt;code&gt;Win*&lt;/code&gt; APIのほとんどは、結果が &lt;code&gt;TRUE&lt;/code&gt; / &lt;code&gt;FALSE&lt;/code&gt; であることを介して成功/失敗を報告します。失敗の理由を見つけるには、WinGetLastError（）APIを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="87b7ddfa19fa0f3f3b716199a0f4db35df4687cb" translate="yes" xml:space="preserve">
          <source>There are two steps to running the test suite:</source>
          <target state="translated">テストスイートを実行するには、2つのステップがあります。</target>
        </trans-unit>
        <trans-unit id="5595b4165f441d44d1cb7724594811d46925edfc" translate="yes" xml:space="preserve">
          <source>There are two structures used to store a compiled regular expression. One, the &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is populated by the engine currently being. used and some of its fields read by perl to implement things such as the stringification of &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">コンパイルされた正規表現を格納するために使用される2つの構造があります。1つは、&lt;a href=&quot;perlreapi&quot;&gt;perlreapiに&lt;/a&gt;記述されている &lt;code&gt;regexp&lt;/code&gt; 構造が、現在存在しているエンジンによって入力されます。 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 文字列化などを実装するためにperlが使用するフィールドとその一部が読み込まれます。</target>
        </trans-unit>
        <trans-unit id="5100abedaa25e172d048855813a77ed10197f346" translate="yes" xml:space="preserve">
          <source>There are two structures used to store a compiled regular expression. One, the &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is populated by the engine currently being. used and some of its fields read by perl to implement things such as the stringification of &lt;code&gt;qr//&lt;/code&gt;.</source>
          <target state="translated">コンパイルされた正規表現を格納するために使用される2つの構造があります。1つは、&lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt;で説明されている &lt;code&gt;regexp&lt;/code&gt; 構造に現在存在するエンジンが組み込まれていることです。 &lt;code&gt;qr//&lt;/code&gt; 文字列化などを実装するために使用され、そのフィールドの一部がperlによって読み取られます。</target>
        </trans-unit>
        <trans-unit id="fc2fe23c780ba1b117d60c962e46037021ac3aa2" translate="yes" xml:space="preserve">
          <source>There are two syntaxes for formatting codes:</source>
          <target state="translated">コードの書式設定には2つの構文があります。</target>
        </trans-unit>
        <trans-unit id="7371ec3e37b63adab8d04f7c4222af55c486c054" translate="yes" xml:space="preserve">
          <source>There are two that I can think off.</source>
          <target state="translated">思い当たることが2つあります。</target>
        </trans-unit>
        <trans-unit id="6d886c39930696ad6e408c59f68366994aaac004" translate="yes" xml:space="preserve">
          <source>There are two ways to build persistent private variables in Perl 5.10. First, you can simply use the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; feature. Or, you can use closures, if you want to stay compatible with releases older than 5.10.</source>
          <target state="translated">Perl 5.10で永続的なプライベート変数を構築する方法は2つあります。まず、単純に &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; 機能を使用できます。または、5.10より前のリリースとの互換性を維持したい場合は、クロージャーを使用できます。</target>
        </trans-unit>
        <trans-unit id="61e69f88599a859bbb0f9c52d49cc582b32af203" translate="yes" xml:space="preserve">
          <source>There are two ways to build persistent private variables in Perl 5.10. First, you can simply use the &lt;code&gt;state&lt;/code&gt; feature. Or, you can use closures, if you want to stay compatible with releases older than 5.10.</source>
          <target state="translated">Perl5.10で永続的なプライベート変数を作成する方法は2つあります。まず、 &lt;code&gt;state&lt;/code&gt; 機能を使用するだけです。または、5.10より前のリリースとの互換性を維持したい場合は、クロージャを使用できます。</target>
        </trans-unit>
        <trans-unit id="6c7079fb330c8f6fcf4a67d7d60f1f7e8ba9c961" translate="yes" xml:space="preserve">
          <source>There are two ways to create and load an AV. The first method creates an empty AV:</source>
          <target state="translated">AV を作成して読み込むには 2 つの方法があります。1つ目の方法は空のAVを作成します。</target>
        </trans-unit>
        <trans-unit id="48bc33b0558cf40893cd4b6a9aee4a0aeea211f9" translate="yes" xml:space="preserve">
          <source>There are two ways to enable debugging output for regular expressions.</source>
          <target state="translated">正規表現のデバッグ出力を有効にするには2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="0ef643530975df52bad47239ca43b62c4abb64aa" translate="yes" xml:space="preserve">
          <source>There are two ways to enter v-strings: a bare number with two or more decimal points, or a bare number with one or more decimal points and a leading 'v' character (also bare). For example:</source>
          <target state="translated">v文字列を入力するには、2つの方法があります:2つ以上の小数点を持つ裸の数字、または1つ以上の小数点を持つ裸の数字と先頭の'v'文字(これも裸)です。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="ad6ac5b22382be34f18ee4c2a153755024871b3a" translate="yes" xml:space="preserve">
          <source>There are two ways to load the &lt;code&gt;feature&lt;/code&gt; pragma implicitly:</source>
          <target state="translated">&lt;code&gt;feature&lt;/code&gt; プラグマを暗黙的にロードするには、2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="af911c100c71eb3b76adfb1d6d843d034d346f08" translate="yes" xml:space="preserve">
          <source>There are two ways to specify the selection. Either a string (scalar) representing a selection regexp for sections to be printed when -verbose is set to 99, e.g.</source>
          <target state="translated">選択範囲を指定するには2つの方法があります。verbose が 99 に設定されているときに印刷されるセクションの選択範囲の正規表現を表す文字列 (スカラ)。</target>
        </trans-unit>
        <trans-unit id="f214eee3e697782835e9e4f8a448217e9a53a985" translate="yes" xml:space="preserve">
          <source>There are two ways to use Cocoa from Perl. Apple's PerlObjCBridge module, included with Mac OS X, can be used by standalone scripts to access Foundation (i.e. non-GUI) classes and objects.</source>
          <target state="translated">Perl から Cocoa を使用するには、2 つの方法があります。Mac OS X に含まれる Apple の PerlObjCBridge モジュールは、スタンドアロンスクリプトで Foundation (すなわち非 GUI)クラスやオブジェクトにアクセスするために使用することができます。</target>
        </trans-unit>
        <trans-unit id="767f59a65489b12a4b5161b27a3a60165cdfb67b" translate="yes" xml:space="preserve">
          <source>There are two ways to use a DBM Filter.</source>
          <target state="translated">DBMフィルターを使うには2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="409a8226f327930f82376970d0a5dd5d41e49fa0" translate="yes" xml:space="preserve">
          <source>There are undoubtedly serious bugs lurking somewhere in code this funky :-) Bug reports and other feedback are most welcome.</source>
          <target state="translated">このファンキーなコードのどこかに深刻なバグが潜んでいることは間違いありません。)バグ報告やその他のフィードバックは大歓迎です。</target>
        </trans-unit>
        <trans-unit id="85be9b959b2e4ac88632b966dc97bb4a96c09ffb" translate="yes" xml:space="preserve">
          <source>There are undoubtedly serious bugs lurking somewhere in this code, if only because parts of it give the impression of understanding a great deal more about Perl than they really do.</source>
          <target state="translated">このコードのどこかに深刻なバグが潜んでいるのは間違いありません。</target>
        </trans-unit>
        <trans-unit id="04b3f04345fdb786670dce0b2cea7b0b8304663e" translate="yes" xml:space="preserve">
          <source>There are useful variations on this theme. The sense of the match can be reversed by using the &lt;code&gt;!~&lt;/code&gt; operator:</source>
          <target state="translated">このテーマには便利なバリエーションがあります。 &lt;code&gt;!~&lt;/code&gt; 演算子を使用して、一致の意味を逆にすることができます。</target>
        </trans-unit>
        <trans-unit id="ccb3b88b50c8aa38b3bc60c7b4f5ddbf691da924" translate="yes" xml:space="preserve">
          <source>There are usually several synonyms for each possible value. Use &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; to access those.</source>
          <target state="translated">通常、可能な値ごとにいくつかの同義語があります。それらにアクセスするには、&lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;「prop_value_aliases（）」&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="ae9efcf4d71ac56a124108c21d7833f5bea0582a" translate="yes" xml:space="preserve">
          <source>There are usually several synonyms for each possible value. Use &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; to access those.</source>
          <target state="translated">通常、可能な値ごとにいくつかの同義語があります。それらにアクセスするには、&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="defaf951c93d8c59c8e8c2838dbcdfdd9abafeeb" translate="yes" xml:space="preserve">
          <source>There are usually three or four interval timers (signals) available: the &lt;code&gt;$which&lt;/code&gt; can be &lt;code&gt;ITIMER_REAL&lt;/code&gt; , &lt;code&gt;ITIMER_VIRTUAL&lt;/code&gt; , &lt;code&gt;ITIMER_PROF&lt;/code&gt; , or &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; . Note that which ones are available depends: true UNIX platforms usually have the first three, but only Solaris seems to have &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; (which is used to profile multithreaded programs). Win32 unfortunately does not have interval timers.</source>
          <target state="translated">：使用可能な3つのまたは4つのインターバルタイマー（信号）は通常あります &lt;code&gt;$which&lt;/code&gt; することができ &lt;code&gt;ITIMER_REAL&lt;/code&gt; を、 &lt;code&gt;ITIMER_VIRTUAL&lt;/code&gt; 、 &lt;code&gt;ITIMER_PROF&lt;/code&gt; 、または &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; が。どちらが利用可能であるかに注意してください。真のUNIXプラットフォームには通常最初の3つがありますが、Solarisだけが &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; （マルチスレッドプログラムのプロファイルに使用される）を持っているようです。Win32には残念ながらインターバルタイマーがありません。</target>
        </trans-unit>
        <trans-unit id="ed047ca7fa087626bb96ec97a8dcb6e6e48edfcd" translate="yes" xml:space="preserve">
          <source>There are usually three or four interval timers (signals) available: the &lt;code&gt;$which&lt;/code&gt; can be &lt;code&gt;ITIMER_REAL&lt;/code&gt;, &lt;code&gt;ITIMER_VIRTUAL&lt;/code&gt;, &lt;code&gt;ITIMER_PROF&lt;/code&gt;, or &lt;code&gt;ITIMER_REALPROF&lt;/code&gt;. Note that which ones are available depends: true UNIX platforms usually have the first three, but only Solaris seems to have &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; (which is used to profile multithreaded programs). Win32 unfortunately does not have interval timers.</source>
          <target state="translated">：使用可能な3つのまたは4つのインターバルタイマー（信号）は通常あります &lt;code&gt;$which&lt;/code&gt; することができ &lt;code&gt;ITIMER_REAL&lt;/code&gt; を、 &lt;code&gt;ITIMER_VIRTUAL&lt;/code&gt; 、 &lt;code&gt;ITIMER_PROF&lt;/code&gt; 、または &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; が。使用できるものはどれかによって異なります。通常、真のUNIXプラットフォームには最初の3つがありますが、Solarisのみが &lt;code&gt;ITIMER_REALPROF&lt;/code&gt; （マルチスレッドプログラムのプロファイルに使用される）を持っているようです。残念ながら、Win32にはインターバルタイマーがありません。</target>
        </trans-unit>
        <trans-unit id="0d22a105cc916ea14dd34be71dc22f4c1bb3fd7e" translate="yes" xml:space="preserve">
          <source>There are various aspects of the pattern that can be used to facilitate optimisations along these lines:</source>
          <target state="translated">パターンには、これらのラインに沿った最適化を容易にするために使用できる様々な側面があります。</target>
        </trans-unit>
        <trans-unit id="e3cedfe60646d2e7422ff8b2a7a07f8c037537db" translate="yes" xml:space="preserve">
          <source>There are various other failures, that as of SunOS 4.1.4 and gcc 3.2.2 look a lot like gcc bugs. Many of the failures happen in the Encode tests, where for example when the test expects &quot;0&quot; you get &quot;&amp;amp;#48;&quot; which should after a little squinting look very odd indeed. Another example is earlier in</source>
          <target state="translated">他にもさまざまな障害があり、SunOS 4.1.4およびgcc 3.2.2からはgccのバグによく似ています。失敗の多くは、エンコードテストで発生します。たとえば、テストで「0」が予期される場合、「＆＃48;」が返されます。少し目を細めると、非常に奇妙に見えるはずです。別の例は、</target>
        </trans-unit>
        <trans-unit id="e93c51ec114e78593d3350d4739a1d10d41d678a" translate="yes" xml:space="preserve">
          <source>There are various other synonyms that can be used besides the names listed in the table. For example, &lt;code&gt;\p{PosixAlpha}&lt;/code&gt; can be written as &lt;code&gt;\p{Alpha}&lt;/code&gt; . All are listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;.</source>
          <target state="translated">表にリストされている名前以外にも、使用できる同義語はさまざまです。たとえば、 &lt;code&gt;\p{PosixAlpha}&lt;/code&gt; は &lt;code&gt;\p{Alpha}&lt;/code&gt; と書くことができます。すべては&lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;、perlunipropsの\ p {}および\ P {}を介してアクセス可能なプロパティに&lt;/a&gt;リストされています。</target>
        </trans-unit>
        <trans-unit id="bc8fcc00bcaa69a62d8c2fd3f050d67f5a95dbce" translate="yes" xml:space="preserve">
          <source>There are various other synonyms that can be used besides the names listed in the table. For example, &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; can be written as &lt;code&gt;\p{Alpha}&lt;/code&gt;. All are listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;&quot;Properties accessible through \p{} and \P{}&quot; in perluniprops&lt;/a&gt;.</source>
          <target state="translated">表にリストされている名前以外にも、使用できるさまざまな同義語があります。たとえば、 &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; は &lt;code&gt;\p{Alpha}&lt;/code&gt; と書くことができます。すべては&lt;a href=&quot;perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;、perlunipropsの「\ p {}および\ P {}を介してアクセス可能なプロパティ」に&lt;/a&gt;リストされています。</target>
        </trans-unit>
        <trans-unit id="20fb423bc3be57a7bce8d37147a935d047431e3f" translate="yes" xml:space="preserve">
          <source>There are various special make targets that can be used to test Perl slightly differently than the standard &quot;test&quot; target. Not all them are expected to give a 100% success rate. Many of them have several aliases, and many of them are not available on certain operating systems.</source>
          <target state="translated">標準の &quot;test &quot;ターゲットとは少し違った方法で Perl をテストするための様々な特別な make ターゲットがあります。すべてのターゲットが 100% の成功率を期待できるわけではありません。これらのターゲットの多くは複数のエイリアスを持っており、特定のオペレーティングシステムでは利用できないものもあります。</target>
        </trans-unit>
        <trans-unit id="7a37b656849e5abe23739ebb1083bad00e7235fc" translate="yes" xml:space="preserve">
          <source>There are various syntaxes, listed below. In the syntaxes given, &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; , and &lt;code&gt;section&lt;/code&gt; cannot contain the characters '/' and '|'; and any '&amp;lt;' or '&amp;gt;' should be matched.</source>
          <target state="translated">以下に示すように、さまざまな構文があります。指定された構文では、 &lt;code&gt;text&lt;/code&gt; 、 &lt;code&gt;name&lt;/code&gt; 、および &lt;code&gt;section&lt;/code&gt; に文字「/」および「|」を含めることはできません。また、「&amp;lt;」または「&amp;gt;」はすべて一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="154dae7c2bfb8ff3e2e9f53b8d516d9eec568a2c" translate="yes" xml:space="preserve">
          <source>There are various syntaxes, listed below. In the syntaxes given, &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, and &lt;code&gt;section&lt;/code&gt; cannot contain the characters '/' and '|'; and any '&amp;lt;' or '&amp;gt;' should be matched.</source>
          <target state="translated">以下にリストされているさまざまな構文があります。指定された構文では、 &lt;code&gt;text&lt;/code&gt; 、 &lt;code&gt;name&lt;/code&gt; 、および &lt;code&gt;section&lt;/code&gt; に文字「/」および「|」を含めることはできません。'&amp;lt;'または '&amp;gt;'は一致する必要があります。</target>
        </trans-unit>
        <trans-unit id="d37ed54ad4b4e800cd45604ce3c3818f96427db4" translate="yes" xml:space="preserve">
          <source>There are various things to note:</source>
          <target state="translated">注意すべき点はいろいろあります。</target>
        </trans-unit>
        <trans-unit id="b76fc3582c89676c08603c7aa65b9cc5c9b6bcec" translate="yes" xml:space="preserve">
          <source>There are various ways in which the private and public flags may differ. For example, in perl 5.16 and earlier a tied SV may have a valid underlying value in the IV slot (so SvIOKp is true), but the data should be accessed via the FETCH routine rather than directly, so SvIOK is false. (In perl 5.18 onwards, tied scalars use the flags the same way as untied scalars.) Another is when numeric conversion has occurred and precision has been lost: only the private flag is set on 'lossy' values. So when an NV is converted to an IV with loss, SvIOKp, SvNOKp and SvNOK will be set, while SvIOK wont be.</source>
          <target state="translated">プライベートフラグとパブリックフラグの違いには様々な方法があります。例えば、Perl 5.16以前のバージョンでは、紐付けられたSVはIVスロットに有効な値を持っているかもしれませんが(SvIOKpは真です)、そのデータは直接ではなくFETCHルーチンを介してアクセスされなければならないので、SvIOKは偽になります。(Perl 5.18以降では、紐付きスカラは紐なしスカラと同じようにフラグを使用します)。もう一つは、数値変換が行われて精度が失われた場合です。つまり,NVが損失を伴うIVに変換された場合,SvIOKp,SvNOKp,SvNOKが設定されますが,SvIOKは設定されません.</target>
        </trans-unit>
        <trans-unit id="bf9b799d87e5a86957d5b5b84b03a08b714f7c53" translate="yes" xml:space="preserve">
          <source>There are web archives of the mailing list at:</source>
          <target state="translated">メーリングリストのウェブアーカイブがあります。</target>
        </trans-unit>
        <trans-unit id="491c71a7d655138bb171154df9a2d69cb67f8248" translate="yes" xml:space="preserve">
          <source>There are, at first glance, three kinds of L links: URL, man, and pod.</source>
          <target state="translated">Lリンクには、一見すると3種類あります。URL、man、podです。</target>
        </trans-unit>
        <trans-unit id="35625b0405457bfbc71b97ae568ca975b4ffb8db" translate="yes" xml:space="preserve">
          <source>There aren't currently any real UTF-8 locales, even though some locale names contain the string &quot;UTF-8&quot;.</source>
          <target state="translated">ロケール名の中には &quot;UTF-8&quot; という文字列が含まれているものもありますが、実際の UTF-8 ロケールは現在のところ存在しません。</target>
        </trans-unit>
        <trans-unit id="f18bc503764d637966b24fa60ca1825eff55d27b" translate="yes" xml:space="preserve">
          <source>There can (and in some cases, must) be whitespace between the operator and the quoting characters, except when &lt;code&gt;#&lt;/code&gt; is being used as the quoting character. &lt;code&gt;q#foo#&lt;/code&gt; is parsed as the string &lt;code&gt;foo&lt;/code&gt;, while &lt;code&gt;q #foo#&lt;/code&gt; is the operator &lt;code&gt;q&lt;/code&gt; followed by a comment. Its argument will be taken from the next line. This allows you to write:</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; が引用文字として使用されている場合を除いて、演算子と引用文字の間に空白を含めることができます（場合によっては必須です）。 &lt;code&gt;q#foo#&lt;/code&gt; は文字列 &lt;code&gt;foo&lt;/code&gt; として解析されますが、 &lt;code&gt;q #foo#&lt;/code&gt; は演算子 &lt;code&gt;q&lt;/code&gt; の後にコメントが続きます。その議論は次の行から取られます。これにより、次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="afc581d54ed5726e14da03dd8d1af5cdf478d3d5" translate="yes" xml:space="preserve">
          <source>There can be whitespace between the operator and the quoting characters, except when &lt;code&gt;#&lt;/code&gt; is being used as the quoting character. &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q#foo#&lt;/a&gt;&lt;/code&gt; is parsed as the string &lt;code&gt;foo&lt;/code&gt; , while &lt;code&gt;q #foo#&lt;/code&gt; is the operator &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; followed by a comment. Its argument will be taken from the next line. This allows you to write:</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; が引用文字として使用されている場合を除いて、演算子と引用文字の間に空白があってもかまいません。 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q#foo#&lt;/a&gt;&lt;/code&gt; は文字列 &lt;code&gt;foo&lt;/code&gt; として解析されますが、 &lt;code&gt;q #foo#&lt;/code&gt; は演算子 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q&lt;/a&gt;&lt;/code&gt; の後にコメントが続きます。その引数は次の行から取得されます。これはあなたが書くことを可能にします：</target>
        </trans-unit>
        <trans-unit id="7f8e18aa50aec43fc98b47477339b319d9bf73e8" translate="yes" xml:space="preserve">
          <source>There does not need to be whitespace at the start of the &quot;&lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; input&lt;/code&gt; &quot; line, but it is useful for improving readability. Placing a semi-colon at the end of that line is also optional. Any amount and kind of whitespace may be placed between the &quot;&lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;&quot; and &quot;&lt;code&gt;input&lt;/code&gt; &quot;.</source>
          <target state="translated">「 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt; input&lt;/code&gt; 」行の先頭に空白を置く必要はありませんが、読みやすさを向上させるのに役立ちます。その行の最後にセミコロンを配置することもオプションです。「 &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 」と「 &lt;code&gt;input&lt;/code&gt; 」の間には、任意の量および種類の空白を配置できます。</target>
        </trans-unit>
        <trans-unit id="0ed8a4a87dc8b9885199d341701749c4f7ba168d" translate="yes" xml:space="preserve">
          <source>There does not need to be whitespace at the start of the &quot;&lt;code&gt;int input&lt;/code&gt;&quot; line, but it is useful for improving readability. Placing a semi-colon at the end of that line is also optional. Any amount and kind of whitespace may be placed between the &quot;&lt;code&gt;int&lt;/code&gt;&quot; and &quot;&lt;code&gt;input&lt;/code&gt;&quot;.</source>
          <target state="translated">「 &lt;code&gt;int input&lt;/code&gt; 」行の先頭に空白を付ける必要はありませんが、読みやすさを向上させるのに役立ちます。その行の終わりにセミコロンを配置することもオプションです。「 &lt;code&gt;int&lt;/code&gt; 」と「 &lt;code&gt;input&lt;/code&gt; 」の間には、任意の量と種類の空白を配置できます。</target>
        </trans-unit>
        <trans-unit id="674ce7b791aca3a84e36e5ed443e53056266d194" translate="yes" xml:space="preserve">
          <source>There exists a port of Perl to the ILE environment. This port, however, is based quite an old release of Perl, Perl 5.00502 (August 1998). (As of July 2002 the latest release of Perl is 5.8.0, and even 5.6.1 has been out since April 2001.) If you need to run Perl on ILE, though, you may need this older port: &lt;a href=&quot;http://www.cpan.org/ports/#os400&quot;&gt;http://www.cpan.org/ports/#os400&lt;/a&gt; Note that any Perl release later than 5.00502 has not been ported to ILE.</source>
          <target state="translated">PerlのILE環境への移植が存在します。ただし、この移植は、Perlのかなり古いリリースであるPerl 5.00502（1998年8月）に基づいています。（2002年7月の時点で、Perlの最新リリースは5.8.0で、2001年4月以降は5.6.1もリリースされています。）ただし、ILEでPerlを実行する必要がある場合は、この古いポートが必要になる場合があります：&lt;a href=&quot;http://www.cpan.org/ports/#os400&quot;&gt;http：// www.cpan.org/ports/#os400 5.00502&lt;/a&gt;以降のPerlリリースはILEに移植されていないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="0d9d302333913269ef8b0575b5cd9f95eaae918e" translate="yes" xml:space="preserve">
          <source>There has been a long-standing bug in Perl that causes a lexical variable not to be cleared at scope exit when its declaration includes a false conditional. Some people have exploited this bug to achieve a kind of static variable. To allow us to fix this bug, people should not be relying on this behavior.</source>
          <target state="translated">Perl には長年のバグがあり、字句変数の宣言に false 条件が含まれている場合、スコープの終了時にクリアされないことがあります。このバグを利用して、ある種の静的変数を実現している人もいます。このバグを修正するためには、この動作に頼るべきではありません。</target>
        </trans-unit>
        <trans-unit id="5e08bda06a78f17f34330ccdc939ea82e2b5bf49" translate="yes" xml:space="preserve">
          <source>There is Coverity setup for the perl5 project: &lt;a href=&quot;https://scan.coverity.com/projects/perl5&quot;&gt;https://scan.coverity.com/projects/perl5&lt;/a&gt;</source>
          <target state="translated">perl5プロジェクトのCoverityセットアップがあります：&lt;a href=&quot;https://scan.coverity.com/projects/perl5&quot;&gt;https&lt;/a&gt;：//scan.coverity.com/projects/perl5</target>
        </trans-unit>
        <trans-unit id="10164fd98639a8c3044721a3ed9b1556ef825187" translate="yes" xml:space="preserve">
          <source>There is a &quot;hints&quot; file for BS2000 called hints.posix-bc (because posix-bc is the OS name given by `uname`) that specifies the correct values for most things. The major problem is (of course) the EBCDIC character set. We have german EBCDIC version.</source>
          <target state="translated">BS2000用の「ヒント」ファイルとしてhints.posix-BCというファイルがあります(posix-BCは`uname`で与えられたOS名なので)。大きな問題は (もちろん)EBCDIC 文字セットです。ドイツ語のEBCDIC版があります。</target>
        </trans-unit>
        <trans-unit id="5374f2f6990509e72c419ef45603ab27e3bc80da" translate="yes" xml:space="preserve">
          <source>There is a $diagnostics::DEBUG variable you may set if you're desperately curious what sorts of things are being intercepted.</source>
          <target state="translated">どのような種類のものが傍受されているのか必死に興味がある場合に設定することができる $diagnostics::DEBUG 変数があります。</target>
        </trans-unit>
        <trans-unit id="4e2dabede0ae332ec4295f1f32bf75c6726b72c4" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;lint&lt;/code&gt; target in Makefile, but you may have to diddle with the flags (see above).</source>
          <target state="translated">Makefileには &lt;code&gt;lint&lt;/code&gt; ターゲットがありますが、フラグをいじる必要があるかもしれません（上記を参照）。</target>
        </trans-unit>
        <trans-unit id="85b8779e0a6e284066d3e0c5dc63c7524691a431" translate="yes" xml:space="preserve">
          <source>There is a CPAN module, &lt;code&gt;&lt;a href=&quot;Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt;&lt;/code&gt;, which allows you to define your own mappings to be used in &lt;code&gt;lc()&lt;/code&gt;, &lt;code&gt;lcfirst()&lt;/code&gt;, &lt;code&gt;uc()&lt;/code&gt;, &lt;code&gt;ucfirst()&lt;/code&gt;, and &lt;code&gt;fc&lt;/code&gt; (or their double-quoted string inlined versions such as &lt;code&gt;\U&lt;/code&gt;). (Prior to Perl 5.16, this functionality was partially provided in the Perl core, but suffered from a number of insurmountable drawbacks, so the CPAN module was written instead.)</source>
          <target state="translated">CPANモジュール &lt;code&gt;&lt;a href=&quot;Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt;&lt;/code&gt; があります。これを使用すると、 &lt;code&gt;lc()&lt;/code&gt; 、 &lt;code&gt;lcfirst()&lt;/code&gt; 、 &lt;code&gt;uc()&lt;/code&gt; 、 &lt;code&gt;ucfirst()&lt;/code&gt; 、および &lt;code&gt;fc&lt;/code&gt; （またはそれらの二重引用符で囲まれた文字列インラインバージョン）で使用する独自のマッピングを定義できます。 &lt;code&gt;\U&lt;/code&gt; など）。（Perl 5.16より前は、この機能はPerlコアで部分的に提供されていましたが、克服できない多くの欠点があったため、代わりにCPANモジュールが作成されました。）</target>
        </trans-unit>
        <trans-unit id="6a13bc3171b7f184b15ada467454c70823010717" translate="yes" xml:space="preserve">
          <source>There is a CPAN module, &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt;&lt;/code&gt;, which allows you to define your own mappings to be used in &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; (or their double-quoted string inlined versions such as &lt;code&gt;\U&lt;/code&gt; ). (Prior to Perl 5.16, this functionality was partially provided in the Perl core, but suffered from a number of insurmountable drawbacks, so the CPAN module was written instead.)</source>
          <target state="translated">CPANモジュール、 &lt;code&gt;&lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Casing&quot;&gt;Unicode::Casing&lt;/a&gt;&lt;/code&gt; があります。これにより、 &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; （または二重引用符で囲まれた文字列のインラインバージョン）で使用する独自のマッピングを定義できます &lt;code&gt;\U&lt;/code&gt; など）。（Perl 5.16以前は、この機能はPerlコアで部分的に提供されていましたが、いくつかの克服できない欠点があったため、代わりにCPANモジュールが作成されました。）</target>
        </trans-unit>
        <trans-unit id="c5d3a875427fdf261fbe25e4b0c804d418f70748" translate="yes" xml:space="preserve">
          <source>There is a Clone module available on CPAN which implements deep cloning natively, i.e. without freezing to memory and thawing the result. It is aimed to replace Storable's dclone() some day. However, it does not currently support Storable hooks to redefine the way deep cloning is performed.</source>
          <target state="translated">CPAN上で利用可能なCloneモジュールがあります。これはディープクローニングをネイティブに実装しています。これはStorableのdclone()をいつか置き換えることを目指しています。しかし、現在のところ、ディープクローニングの実行方法を再定義するための Storable フックはサポートしていません。</target>
        </trans-unit>
        <trans-unit id="d1abe7c402c9589925c2fd5cdd3fc7738d6e503b" translate="yes" xml:space="preserve">
          <source>There is a Perl interface to TrollTech's Qt toolkit, but it does not appear to be maintained.</source>
          <target state="translated">TrollTechのQtツールキットへのPerlインターフェイスがありますが、メンテナンスされていないようです。</target>
        </trans-unit>
        <trans-unit id="2368d7b8dd55271d773f21a14ae9eb87cfb16560" translate="yes" xml:space="preserve">
          <source>There is a bug in perl5.6.0 with UV's that are &amp;gt;= 1&amp;lt;&amp;lt;31. This will show up as tests 8 and 9 of dualvar.t failing</source>
          <target state="translated">&amp;gt; = 1 &amp;lt;&amp;lt; 31のUVを持つperl5.6.0にはバグがあります。これは、dualvar.tのテスト8および9が失敗すると表示されます。</target>
        </trans-unit>
        <trans-unit id="74ad132a2446bd3d40e9bf990b8f1b1aa2a313b3" translate="yes" xml:space="preserve">
          <source>There is a central directory for the Perl community: &lt;a href=&quot;http://perl.org&quot;&gt;http://perl.org&lt;/a&gt; maintained by the Perl Foundation (&lt;a href=&quot;http://www.perlfoundation.org/&quot;&gt;http://www.perlfoundation.org/&lt;/a&gt;), which tracks and provides services for a variety of other community sites.</source>
          <target state="translated">Perlコミュニティの中央ディレクトリがあり&lt;a href=&quot;http://www.perlfoundation.org/&quot;&gt;ます。http&lt;/a&gt;：&lt;a href=&quot;http://perl.org&quot;&gt;//perl.org&lt;/a&gt;はPerl Foundationによって管理されており（http://www.perlfoundation.org/）、他のさまざまなコミュニティサイトのサービスを追跡および提供します。</target>
        </trans-unit>
        <trans-unit id="b14e35e5c9ac344a8ff5825a4050f6c40c0d0c03" translate="yes" xml:space="preserve">
          <source>There is a class method in &lt;code&gt;PerlIO::Layer&lt;/code&gt;&lt;code&gt;find&lt;/code&gt; which is implemented as XS code. It is called by &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to validate the layers:</source>
          <target state="translated">&lt;code&gt;PerlIO::Layer&lt;/code&gt; &lt;code&gt;find&lt;/code&gt; には、XSコードとして実装されるクラスメソッドがあります。レイヤーを検証するために &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="ba9884f209caf6d0506a39ac341c0ea3ddd78c13" translate="yes" xml:space="preserve">
          <source>There is a class method in &lt;code&gt;PerlIO::Layer&lt;/code&gt;&lt;code&gt;find&lt;/code&gt; which is implemented as XS code. It is called by &lt;code&gt;import&lt;/code&gt; to validate the layers:</source>
          <target state="translated">&lt;code&gt;PerlIO::Layer&lt;/code&gt; &lt;code&gt;find&lt;/code&gt; には、XSコードとして実装されているクラスメソッドがあります。レイヤーを検証するために &lt;code&gt;import&lt;/code&gt; によって呼び出されます。</target>
        </trans-unit>
        <trans-unit id="130b2ceadd9a5f49d4085944a7e2f2612f7d6b00" translate="yes" xml:space="preserve">
          <source>There is a facility called &quot;file extension associations&quot;. This can be manipulated via the two commands &quot;assoc&quot; and &quot;ftype&quot; that come standard with Windows. Type &quot;ftype /?&quot; for a complete example of how to set this up for perl scripts (Say what? You thought Windows wasn't perl-ready? :).</source>
          <target state="translated">ファイル拡張子の関連付け」という機能があります。これは、Windowsに標準装備されている &quot;assoc &quot;と &quot;ftype &quot;という2つのコマンドで操作することができます。これをperlスクリプトに設定する方法の完全な例は、&quot;ftype /? &quot;と入力してください(Windowsがperlに対応していないと思っていたのか?)</target>
        </trans-unit>
        <trans-unit id="56c8b0f7b0876f90abc844b5aa213cd2600b5f4e" translate="yes" xml:space="preserve">
          <source>There is a fairly obvious gotcha included with the line directive: Debuggers and profilers will only show the last source line to appear at a particular line number in a given file. Care should be taken not to cause line number collisions in code you'd like to debug later.</source>
          <target state="translated">line ディレクティブには、かなり明白な誤魔化しがあります。デバッガやプロファイラは、与えられたファイルの特定の行番号に現れる最後のソース行のみを表示します。後でデバッグしたいコードで行番号の衝突を起こさないように注意する必要があります。</target>
        </trans-unit>
        <trans-unit id="bb9de8709414ce3be99387c65eb446322517dbc7" translate="yes" xml:space="preserve">
          <source>There is a full version history in the Changes file, and the Test::More versions included as core can be found using &lt;a href=&quot;../module/corelist&quot;&gt;Module::CoreList&lt;/a&gt;:</source>
          <target state="translated">変更ファイルには完全なバージョン履歴があり、コアとして含まれているTest :: Moreバージョンは&lt;a href=&quot;../module/corelist&quot;&gt;Module :: CoreList&lt;/a&gt;を使用して見つけることができます。</target>
        </trans-unit>
        <trans-unit id="fc72621c4f74524103b116a2301e947655e4bfff" translate="yes" xml:space="preserve">
          <source>There is a full version history in the Changes file, and the Test::More versions included as core can be found using &lt;a href=&quot;Module::CoreList&quot;&gt;Module::CoreList&lt;/a&gt;:</source>
          <target state="translated">変更ファイルには完全なバージョン履歴があり、コアとして含まれているTest :: Moreバージョンは、&lt;a href=&quot;Module::CoreList&quot;&gt;Module :: CoreList&lt;/a&gt;：を使用して見つけることができます。</target>
        </trans-unit>
        <trans-unit id="8d8d363093d476f461ae875eb02ff5a19f7dc579" translate="yes" xml:space="preserve">
          <source>There is a functional programming API available for programmers to query information.</source>
          <target state="translated">プログラマが情報を照会するために利用できる機能的なプログラミングAPIがあります。</target>
        </trans-unit>
        <trans-unit id="a15e4bcad41aa0b597b5c043d274e21e152196d8" translate="yes" xml:space="preserve">
          <source>There is a further complication with non-closure anonymous subs (i.e. those that do not refer to any lexicals outside that sub). In this case, the anonymous prototype is shared rather than being cloned. This has the consequence that the parent may be freed while there are still active children,</source>
          <target state="translated">非閉鎖匿名サブ(すなわち、そのサブの外のいかなる語彙をも参照しないサブ)には、さらに複雑な問題があります。この場合、匿名プロトタイプはクローンされるのではなく共有されます。これは、アクティブな子がまだ存在する間に親が解放される可能性があるという結果をもたらします。</target>
        </trans-unit>
        <trans-unit id="2afd310e60a2687221eb36caee1877ab18ed5e49" translate="yes" xml:space="preserve">
          <source>There is a further complication with non-closure anonymous subs (i.e. those that do not refer to any lexicals outside that sub). In this case, the anonymous prototype is shared rather than being cloned. This has the consequence that the parent may be freed while there are still active children, eg</source>
          <target state="translated">非閉鎖匿名サブ(すなわち、そのサブの外のいかなる語彙をも参照しないサブ)には、さらに複雑な問題があります。この場合、匿名プロトタイプはクローンされるのではなく共有されます。これは、アクティブな子がまだ存在する間に親が解放される可能性があるという結果をもたらします。</target>
        </trans-unit>
        <trans-unit id="6e38f9a6f0524cb60060c7ab66b100df8645a3df" translate="yes" xml:space="preserve">
          <source>There is a given/when statement in Perl, but it is experimental and likely to change in future. See &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt; for more details.</source>
          <target state="translated">Perlにはgiven / whenステートメントがありますが、これは実験的なものであり、将来変更される可能性があります。詳細については、&lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="4bfd060d0feb488ff6b3d46ad13ea7e46b879b0f" translate="yes" xml:space="preserve">
          <source>There is a known bug in the</source>
          <target state="translated">には既知のバグがあります。</target>
        </trans-unit>
        <trans-unit id="f36a7b0d4fbbd5ecb9f7c10c28ff43dbc8a0e2c1" translate="yes" xml:space="preserve">
          <source>There is a large collection of locale definitions at:</source>
          <target state="translated">ロケール定義の大規模なコレクションがあります。</target>
        </trans-unit>
        <trans-unit id="164a3c40b19ffea76d12a9ba083e8f9f3b80b6e7" translate="yes" xml:space="preserve">
          <source>There is a large memory overhead for each record offset and for each cache entry: about 310 bytes per cached data record, and about 21 bytes per offset table entry.</source>
          <target state="translated">各レコードオフセットと各キャッシュエントリのために大きなメモリオーバーヘッドがあり、キャッシュされたデータレコードあたり約310バイト、オフセットテーブルエントリあたり約21バイトです。</target>
        </trans-unit>
        <trans-unit id="6d613e26c7817a472a293f57a0848d067f1f9f1e" translate="yes" xml:space="preserve">
          <source>There is a lint variant called &lt;code&gt;splint&lt;/code&gt; (Secure Programming Lint) available from &lt;a href=&quot;http://www.splint.org/&quot;&gt;http://www.splint.org/&lt;/a&gt; that should compile on any Unix-like platform.</source>
          <target state="translated">Unixライクなプラットフォームでコンパイルできる、&lt;a href=&quot;http://www.splint.org/&quot;&gt;http：//www.splint.org/&lt;/a&gt;から入手可能な &lt;code&gt;splint&lt;/code&gt; （Secure Programming Lint）と呼ばれるlintバリアントがあります。</target>
        </trans-unit>
        <trans-unit id="50d5366c81be8e75e037c5167a3d288dd1f93227" translate="yes" xml:space="preserve">
          <source>There is a list &lt;code&gt;=item&lt;/code&gt; right above the flagged line that has no text contents. You probably want to delete empty items.</source>
          <target state="translated">フラグの付いた行のすぐ上に、テキストの内容がないリスト &lt;code&gt;=item&lt;/code&gt; があります。おそらく空のアイテムを削除したいでしょう。</target>
        </trans-unit>
        <trans-unit id="9491003a2d6e2370bad105f107b81a379a482390" translate="yes" xml:space="preserve">
          <source>There is a list &lt;code&gt;=item&lt;/code&gt; that has no text contents. You probably want to delete empty items.</source>
          <target state="translated">テキストの内容がないlist &lt;code&gt;=item&lt;/code&gt; があります。空のアイテムを削除することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a1f99dfe0ca2905f67ecab8086230b0fc7ddbaec" translate="yes" xml:space="preserve">
          <source>There is a mailing list available for users of this distribution, &lt;a href=&quot;mailto:datetime@perl.org&quot;&gt;mailto:datetime@perl.org&lt;/a&gt;.</source>
          <target state="translated">このディストリビューションのユーザーが利用できるメーリングリスト&lt;a href=&quot;mailto:datetime@perl.org&quot;&gt;mailto：datetime@perl.orgがあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="e52de09f7d095fa1c4329ee2a9ca8823bc2d60ff" translate="yes" xml:space="preserve">
          <source>There is a partial workaround (which can be made complete with newer OS/2 kernels): create a forwarder DLL with the same name as the DLL of the older version of Perl, which forwards the entry points to the newer Perl's DLL. Make this DLL accessible on (say) the &lt;code&gt;BEGINLIBPATH&lt;/code&gt; of the new Perl executable. When the new executable accesses old Perl's extension DLLs, they would request the old Perl's DLL by name, get the forwarder instead, so effectively will link with the currently running (new) Perl DLL.</source>
          <target state="translated">部分的な回避策があります（新しいOS / 2カーネルで完全にすることができます）：古いバージョンのPerlのDLLと同じ名前でフォワーダーDLLを作成し、エントリーポイントを新しいPerlのDLLに転送します。（たとえば）新しいPerl実行可能ファイルの &lt;code&gt;BEGINLIBPATH&lt;/code&gt; でこのDLLにアクセスできるようにします。新しい実行可能ファイルが古いPerlの拡張DLLにアクセスすると、古いPerlのDLLを名前で要求し、代わりにフォワーダーを取得するため、現在実行中の（新しい）Perl DLLと効果的にリンクします。</target>
        </trans-unit>
        <trans-unit id="d1126a23763c29c3a1bec0b9bdcdb94247472fba" translate="yes" xml:space="preserve">
          <source>There is a potential syntactic ambiguity between signatures and prototypes (see &lt;a href=&quot;#Prototypes&quot;&gt;&quot;Prototypes&quot;&lt;/a&gt;), because both start with an opening parenthesis and both can appear in some of the same places, such as just after the name in a subroutine declaration. For historical reasons, when signatures are not enabled, any opening parenthesis in such a context will trigger very forgiving prototype parsing. Most signatures will be interpreted as prototypes in those circumstances, but won't be valid prototypes. (A valid prototype cannot contain any alphabetic character.) This will lead to somewhat confusing error messages.</source>
          <target state="translated">シグニチャとプロトタイプの間には潜在的な構文のあいまいさがあります（&lt;a href=&quot;#Prototypes&quot;&gt;「プロトタイプ」を&lt;/a&gt;参照）。どちらも開始括弧で始まり、サブルーチン宣言の名前の直後など、同じ場所の一部に表示される可能性があるためです。歴史的な理由から、署名が有効になっていない場合、そのようなコンテキストで開き括弧を使用すると、非常に寛容なプロトタイプの解析がトリガーされます。ほとんどの署名は、そのような状況ではプロトタイプとして解釈されますが、有効なプロトタイプではありません。 （有効なプロトタイプに英字を含めることはできません。）これにより、多少混乱するエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="57ca9ff3bac6a75872d6256fe67ed0855ac24ebb" translate="yes" xml:space="preserve">
          <source>There is a potential syntactic ambiguity between signatures and prototypes (see &lt;a href=&quot;#Prototypes&quot;&gt;Prototypes&lt;/a&gt;), because both start with an opening parenthesis and both can appear in some of the same places, such as just after the name in a subroutine declaration. For historical reasons, when signatures are not enabled, any opening parenthesis in such a context will trigger very forgiving prototype parsing. Most signatures will be interpreted as prototypes in those circumstances, but won't be valid prototypes. (A valid prototype cannot contain any alphabetic character.) This will lead to somewhat confusing error messages.</source>
          <target state="translated">シグネチャとプロトタイプ（&lt;a href=&quot;#Prototypes&quot;&gt;プロトタイプを&lt;/a&gt;参照）の間には、構文のあいまいさがある可能性があります。これは、どちらも開き括弧で始まり、サブルーチン宣言の名前の直後など、同じ場所のいくつかに現れる可能性があるためです。歴史的な理由から、署名が有効になっていない場合、そのようなコンテキストでの左括弧は、非常に寛容なプロトタイプ解析をトリガーします。これらの状況では、ほとんどの署名がプロトタイプとして解釈されますが、有効なプロトタイプにはなりません。 （有効なプロトタイプにアルファベット文字を含めることはできません。）これにより、やや紛らわしいエラーメッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="d27354b37f9e6840bfd23c6a2efc0450a836df2f" translate="yes" xml:space="preserve">
          <source>There is a relationship between roles and classes, as each class implies the existence of a role of the same name. There is also a relationship between inheritance and roles, in that a subclass that inherits from an ancestor class implicitly performs any roles its parent performs. Thus you can use &lt;code&gt;DOES&lt;/code&gt; in place of &lt;code&gt;isa&lt;/code&gt; safely, as it will return true in all places where &lt;code&gt;isa&lt;/code&gt; will return true (provided that any overridden &lt;code&gt;DOES&lt;/code&gt;</source>
          <target state="translated">各クラスは同じ名前のロールの存在を暗示するため、ロールとクラスの間には関係があります。祖先クラスから継承するサブクラスが、親が実行するすべてのロールを暗黙的に実行するという点で、継承とロールの間にも関係があります。したがって、 &lt;code&gt;isa&lt;/code&gt; がtrueを返すすべての場所でtrueを返すため、 &lt;code&gt;isa&lt;/code&gt; の代わりに &lt;code&gt;DOES&lt;/code&gt; を安全に使用できます（オーバーライドされた &lt;code&gt;DOES&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d92cff32e2893123d7b11efd15dfbc88dd3973f8" translate="yes" xml:space="preserve">
          <source>There is a rich ecosystem of &lt;code&gt;Moose&lt;/code&gt; extensions on CPAN under the &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2fsearch%3fquery%3dMooseX%26mode%3ddist&quot;&gt;MooseX&lt;/a&gt; namespace. In addition, many modules on CPAN already use &lt;code&gt;Moose&lt;/code&gt; , providing you with lots of examples to learn from.</source>
          <target state="translated">&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fsearch.cpan.org%2fsearch%3fquery%3dMooseX%26mode%3ddist&quot;&gt;MooseX&lt;/a&gt;名前空間の下のCPANには、 &lt;code&gt;Moose&lt;/code&gt; 拡張機能の豊富なエコシステムがあります。さらに、CPANの多くのモジュールはすでに &lt;code&gt;Moose&lt;/code&gt; を使用しており、学ぶべき多くの例を提供しています。</target>
        </trans-unit>
        <trans-unit id="63c6a415ec649ec3fee18b8a757da8ffbc58b528" translate="yes" xml:space="preserve">
          <source>There is a rich ecosystem of &lt;code&gt;Moose&lt;/code&gt; extensions on CPAN under the &lt;a href=&quot;https://metacpan.org/search?q=MooseX&quot;&gt;MooseX&lt;/a&gt; namespace. In addition, many modules on CPAN already use &lt;code&gt;Moose&lt;/code&gt;, providing you with lots of examples to learn from.</source>
          <target state="translated">&lt;a href=&quot;https://metacpan.org/search?q=MooseX&quot;&gt;MooseX&lt;/a&gt;名前空間の下のCPANには &lt;code&gt;Moose&lt;/code&gt; 拡張機能の豊富なエコシステムがあります。さらに、CPANの多くのモジュールはすでに &lt;code&gt;Moose&lt;/code&gt; を使用しており、学ぶべき多くの例を提供しています。</target>
        </trans-unit>
        <trans-unit id="0db652ab14c5e9efe4a7bcfa81f503ee955d3fa8" translate="yes" xml:space="preserve">
          <source>There is a section detected in the page name of L&amp;lt;...&amp;gt;, e.g. &lt;code&gt;L&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; . POD hyperlinks may point to POD documents only. Please write &lt;code&gt;C&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; instead. Some formatters are able to expand this to appropriate code. For links to (builtin) functions, please say &lt;code&gt;L&amp;lt;perlfunc/mkdir&amp;gt;&lt;/code&gt; , without ().</source>
          <target state="translated">L &amp;lt;...&amp;gt;のページ名にセクションが検出されました &lt;code&gt;L&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; 例：L &amp;lt;passwd（2）&amp;gt;）。 PODハイパーリンクは、PODドキュメントのみを指す場合があります。代わりに &lt;code&gt;C&amp;lt;passwd(2)&amp;gt;&lt;/code&gt; 記述してください。一部のフォーマッタは、これを適切なコードに拡張できます。 （組み込み）関数へのリンクについては、（）なしで &lt;code&gt;L&amp;lt;perlfunc/mkdir&amp;gt;&lt;/code&gt; と言ってください。</target>
        </trans-unit>
        <trans-unit id="00c1ae760ee79d8ac4a3185792db70643cfa006e" translate="yes" xml:space="preserve">
          <source>There is a single stash called &lt;code&gt;PL_defstash&lt;/code&gt; that holds the items that exist in the &lt;code&gt;main&lt;/code&gt; package. To get at the items in other packages, append the string &quot;::&quot; to the package name. The items in the &lt;code&gt;Foo&lt;/code&gt; package are in the stash &lt;code&gt;Foo::&lt;/code&gt; in PL_defstash. The items in the &lt;code&gt;Bar::Baz&lt;/code&gt; package are in the stash &lt;code&gt;Baz::&lt;/code&gt; in &lt;code&gt;Bar::&lt;/code&gt; 's stash.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; パッケージに存在するアイテムを保持する &lt;code&gt;PL_defstash&lt;/code&gt; と呼ばれる単一のスタッシュがあります。他のパッケージのアイテムを取得するには、文字列 &quot;::&quot;をパッケージ名に追加します。 &lt;code&gt;Foo&lt;/code&gt; パッケージのアイテムは、PL_defstashのstash &lt;code&gt;Foo::&lt;/code&gt; にあります。中項目 &lt;code&gt;Bar::Baz&lt;/code&gt; パッケージはスタッシュにある &lt;code&gt;Baz::&lt;/code&gt; に &lt;code&gt;Bar::&lt;/code&gt; さんスタッシュ。</target>
        </trans-unit>
        <trans-unit id="da12b97e4f2d1305f926ea3b6d55a42d5c8e4baf" translate="yes" xml:space="preserve">
          <source>There is a single stash called &lt;code&gt;PL_defstash&lt;/code&gt; that holds the items that exist in the &lt;code&gt;main&lt;/code&gt; package. To get at the items in other packages, append the string &quot;::&quot; to the package name. The items in the &lt;code&gt;Foo&lt;/code&gt; package are in the stash &lt;code&gt;Foo::&lt;/code&gt; in PL_defstash. The items in the &lt;code&gt;Bar::Baz&lt;/code&gt; package are in the stash &lt;code&gt;Baz::&lt;/code&gt; in &lt;code&gt;Bar::&lt;/code&gt;'s stash.</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; パッケージに存在するアイテムを保持する &lt;code&gt;PL_defstash&lt;/code&gt; と呼ばれる単一のスタッシュがあります。他のパッケージのアイテムを取得するには、パッケージ名に文字列「::」を追加します。 &lt;code&gt;Foo&lt;/code&gt; パッケージのアイテムは、PL_defstashのstash &lt;code&gt;Foo::&lt;/code&gt; にあります。 &lt;code&gt;Bar::Baz&lt;/code&gt; パッケージのアイテムは &lt;code&gt;Baz::&lt;/code&gt; in &lt;code&gt;Bar::&lt;/code&gt; 'sstashにあります。</target>
        </trans-unit>
        <trans-unit id="410d21275559c0b069f15cf1ae78b078a451978c" translate="yes" xml:space="preserve">
          <source>There is a special form of this construct, called &lt;code&gt;\K&lt;/code&gt; (available since Perl 5.10.0), which causes the regex engine to &quot;keep&quot; everything it had matched prior to the &lt;code&gt;\K&lt;/code&gt; and not include it in &lt;code&gt;$&amp;amp;&lt;/code&gt; . This effectively provides variable-length look-behind. The use of &lt;code&gt;\K&lt;/code&gt; inside of another look-around assertion is allowed, but the behaviour is currently not well defined.</source>
          <target state="translated">この構成体には、 &lt;code&gt;\K&lt;/code&gt; （Perl 5.10.0以降で使用可能）と呼ばれる特別な形式があります。これにより、正規表現エンジンは &lt;code&gt;\K&lt;/code&gt; より前に一致したすべてのものを「保持」し、 &lt;code&gt;$&amp;amp;&lt;/code&gt; に含めません。これは事実上、可変長の後読みを提供します。別のルックアラウンドアサーション内での &lt;code&gt;\K&lt;/code&gt; の使用は許可されていますが、動作は現在明確に定義されていません。</target>
        </trans-unit>
        <trans-unit id="132434df2410147d359e3620818bc1c35f77d26b" translate="yes" xml:space="preserve">
          <source>There is a special form of this construct, called &lt;code&gt;\K&lt;/code&gt; (available since Perl 5.10.0), which causes the regex engine to &quot;keep&quot; everything it had matched prior to the &lt;code&gt;\K&lt;/code&gt; and not include it in &lt;code&gt;$&amp;amp;&lt;/code&gt;. This effectively provides non-experimental variable-length lookbehind of any length.</source>
          <target state="translated">&lt;code&gt;\K&lt;/code&gt; （Perl 5.10.0以降で使用可能）と呼ばれるこの構造の特別な形式があります。これにより、正規表現エンジンは &lt;code&gt;\K&lt;/code&gt; より前に一致したすべてのものを「保持」し、 &lt;code&gt;$&amp;amp;&lt;/code&gt; に含めません。これにより、任意の長さの非実験的な可変長ルックビハインドが効果的に提供されます。</target>
        </trans-unit>
        <trans-unit id="0599747d66099e132ad6b9e84b12be8636f0ae4e" translate="yes" xml:space="preserve">
          <source>There is a syntax error in the /usr/include/sys/socket.h header file that IBM supplies with USS V2R7, V2R8, and possibly V2R9. The problem with the header file is that near the definition of the SO_REUSEPORT constant there is a spurious extra '/' character outside of a comment like so:</source>
          <target state="translated">IBMがUSS V2R7、V2R8、場合によってはV2R9と一緒に提供している/usr/include/sys/socket.hヘッダファイルに構文エラーがあります。このヘッダーファイルの問題は、SO_REUSEPORT定数の定義の近くに、次のようなコメントの外側に不正な余分な'/'文字があることです。</target>
        </trans-unit>
        <trans-unit id="4f5af7c338789d7b91669b50869dfdd492384f9b" translate="yes" xml:space="preserve">
          <source>There is a technique that can be used to handle variable length lookbehinds on earlier releases, and longer than 255 characters. It is described in &lt;a href=&quot;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&quot;&gt;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&lt;/a&gt;.</source>
          <target state="translated">以前のリリースでは、255文字を超える可変長のルックビハインドを処理するために使用できる手法があります。&lt;a href=&quot;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&quot;&gt;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&lt;/a&gt;で説明されています。</target>
        </trans-unit>
        <trans-unit id="b527eadae01dab13ed85ec63c9837bc3c0c67bda" translate="yes" xml:space="preserve">
          <source>There is a tradeoff between taking full advantage of one particular type of computer and taking advantage of a full range of them. Naturally, as you broaden your range and become more diverse, the common factors drop, and you are left with an increasingly smaller area of common ground in which you can operate to accomplish a particular task. Thus, when you begin attacking a problem, it is important to consider under which part of the tradeoff curve you want to operate. Specifically, you must decide whether it is important that the task that you are coding has the full generality of being portable, or whether to just get the job done right now. This is the hardest choice to be made. The rest is easy, because Perl provides many choices, whichever way you want to approach your problem.</source>
          <target state="translated">1つの特定のタイプのコンピュータをフルに活用することと、それらのコンピュータをフルに活用することの間には、トレードオフがあります。当然のことながら、範囲を広げて多様化すればするほど、共通の要素は減少し、特定のタスクを達成するために操作できる共通の領域はますます狭くなります。したがって、問題に取り組み始める際には、トレードオフ曲線のどの部分で活動したいかを検討することが重要です。具体的には、コーディングしているタスクがポータブルであるという完全な汎用性を持っていることが重要なのか、それとも今すぐにでも仕事を終わらせることが重要なのかを判断しなければなりません。これが一番難しい選択です。Perl は多くの選択肢を提供しているので、あとは簡単です。</target>
        </trans-unit>
        <trans-unit id="8ea25b9abfe4373f567bc9679e7275e7fb164486" translate="yes" xml:space="preserve">
          <source>There is a utility called &lt;a href=&quot;../corelist&quot;&gt;corelist&lt;/a&gt; provided with this module which is a convenient way of querying from the command-line.</source>
          <target state="translated">このモジュールには&lt;a href=&quot;../corelist&quot;&gt;コアリスト&lt;/a&gt;と呼ばれるユーティリティがあり、コマンドラインからクエリを実行するのに便利です。</target>
        </trans-unit>
        <trans-unit id="26e6ac611235e43f07c357cfef8c6952cf104cdd" translate="yes" xml:space="preserve">
          <source>There is a utility called &lt;a href=&quot;corelist&quot;&gt;corelist&lt;/a&gt; provided with this module which is a convenient way of querying from the command-line.</source>
          <target state="translated">このモジュールには、コマンドラインからクエリを実行するのに便利な&lt;a href=&quot;corelist&quot;&gt;コアリスト&lt;/a&gt;と呼ばれるユーティリティがあります。</target>
        </trans-unit>
        <trans-unit id="82aef8cfd5e32e2a307fc10353cb3d2e49f98a7d" translate="yes" xml:space="preserve">
          <source>There is a variable &lt;code&gt;$File::Find::fullname&lt;/code&gt; which holds the absolute pathname of the file with all symbolic links resolved. If the link is a dangling symbolic link, then fullname will be set to &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">すべてのシンボリックリンクが解決されたファイルの絶対パス名を保持する変数 &lt;code&gt;$File::Find::fullname&lt;/code&gt; あります。リンクがぶら下がっているシンボリックリンクの場合、fullnameは &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="973df2b639c4d3b005a76e2b6bc5345ee00adfab" translate="yes" xml:space="preserve">
          <source>There is a variable &lt;code&gt;$File::Find::fullname&lt;/code&gt; which holds the absolute pathname of the file with all symbolic links resolved. If the link is a dangling symbolic link, then fullname will be set to &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">すべてのシンボリックリンクが解決されたファイルの絶対パス名を保持する変数 &lt;code&gt;$File::Find::fullname&lt;/code&gt; あります。リンクがぶら下がっているシンボリックリンクの場合、フルネームは &lt;code&gt;undef&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="3b9ea31c4237da29f14d09c3e17b0abf6058f6c2" translate="yes" xml:space="preserve">
          <source>There is a way to achieve a similar task from C via Perl API: create a</source>
          <target state="translated">Perl APIを使ってC言語から同様のタスクを実現する方法があります。</target>
        </trans-unit>
        <trans-unit id="186d9ac4ec1df84f73c4528af239edb0b67d87e7" translate="yes" xml:space="preserve">
          <source>There is a way to completely hide any modifiable globals (they are all moved to heap), the compilation setting &lt;code&gt;-DPERL_GLOBAL_STRUCT_PRIVATE&lt;/code&gt; . It is not normally used, but can be used for testing, read more about it in &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;Background and PERL_IMPLICIT_CONTEXT in perlguts&lt;/a&gt;.</source>
          <target state="translated">変更可能なグローバル（それらはすべてヒープに移動されます）を完全に非表示にする方法があります。コンパイル設定 &lt;code&gt;-DPERL_GLOBAL_STRUCT_PRIVATE&lt;/code&gt; です。通常は使用されませんが、テストに使用できます。詳細については、&lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;バックグラウンドで、PERL_IMPLICIT_CONTEXTはperlgutsでご覧ください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f6e88f7ecf4798ea1155b449543fac9f0b354b61" translate="yes" xml:space="preserve">
          <source>There is a way to completely hide any modifiable globals (they are all moved to heap), the compilation setting &lt;code&gt;-DPERL_GLOBAL_STRUCT_PRIVATE&lt;/code&gt;. It is not normally used, but can be used for testing, read more about it in &lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;&quot;Background and PERL_IMPLICIT_CONTEXT&quot; in perlguts&lt;/a&gt;.</source>
          <target state="translated">変更可能なグローバルを完全に非表示にする方法があり（それらはすべてヒープに移動されます）、コンパイル設定 &lt;code&gt;-DPERL_GLOBAL_STRUCT_PRIVATE&lt;/code&gt; です。通常は使用されませんが、テストに使用できます。詳細について&lt;a href=&quot;perlguts#Background-and-PERL_IMPLICIT_CONTEXT&quot;&gt;は、perlgutsの「BackgroundandPERL_IMPLICIT_CONTEXT」を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="887ba5df14249dda0cf87b4c4aa3777b9fca5f36" translate="yes" xml:space="preserve">
          <source>There is a way to tell perl to do complete cleanup: set the environment variable PERL_DESTRUCT_LEVEL to a non-zero value. The t/TEST wrapper does set this to 2, and this is what you need to do too, if you don't want to see the &quot;global leaks&quot;: For example, for running under valgrind</source>
          <target state="translated">環境変数PERL_DESTRUCT_LEVELに0以外の値を設定してください。t/TEST ラッパーはこれを 2 に設定していますが、&quot;グローバルリーク &quot;を見たくないのであれば、これも必要なことです。例えば、valgrindで実行する場合</target>
        </trans-unit>
        <trans-unit id="691cdea86f4db4ba9a2ac59e7fc6b55f031421ad" translate="yes" xml:space="preserve">
          <source>There is absolutely no excuse for not documenting your extension. Documentation belongs in the .pm file. This file will be fed to pod2man, and the embedded documentation will be converted to the manpage format, then placed in the blib directory. It will be copied to Perl's manpage directory when the extension is installed.</source>
          <target state="translated">あなたの拡張子を文書化しないことには絶対に言い訳はできません。ドキュメントは .pm ファイルにあります。このファイルは pod2man に送られ、埋め込まれたドキュメントは manpage 形式に変換されて blib ディレクトリに置かれます。このファイルは、拡張機能がインストールされたときに Perl の manpage ディレクトリにコピーされます。</target>
        </trans-unit>
        <trans-unit id="d8cca778f6ffeefe438e516146882fedcff922a7" translate="yes" xml:space="preserve">
          <source>There is also &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigrat;&lt;/code&gt; which gives you big rationals:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigrat;&lt;/code&gt; もあります。これはあなたに大きな合理性を与えます：</target>
        </trans-unit>
        <trans-unit id="9cf519c73fbae0fe8c0d4ffe79764b81487dc294" translate="yes" xml:space="preserve">
          <source>There is also &lt;code&gt;use bigrat;&lt;/code&gt; which gives you big rationals:</source>
          <target state="translated">&lt;code&gt;use bigrat;&lt;/code&gt; もあります。それはあなたに大きな論理的根拠を与えます：</target>
        </trans-unit>
        <trans-unit id="43bcf99a2a57a573a071e20e50556250aa32095b" translate="yes" xml:space="preserve">
          <source>There is also a function to add magic to an &lt;code&gt;HV&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;HV&lt;/code&gt; に魔法を追加する機能もあります：</target>
        </trans-unit>
        <trans-unit id="5e09c6821154895943bc8dd098914ffb05015157" translate="yes" xml:space="preserve">
          <source>There is also a function to add magic to an &lt;code&gt;HV&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;HV&lt;/code&gt; に魔法を加える機能もあります：</target>
        </trans-unit>
        <trans-unit id="8f310316f81fc52692e5ac947e6e74f350603233" translate="yes" xml:space="preserve">
          <source>There is also a larger form of a char class structure used to represent POSIX char classes under &lt;code&gt;/l&lt;/code&gt; matching, called &lt;code&gt;regnode_charclass_posixl&lt;/code&gt; which has an additional 32-bit bitmap indicating which POSIX char classes have been included.</source>
          <target state="translated">&lt;code&gt;/l&lt;/code&gt; マッチングでPOSIX charクラスを表すために使用されるcharクラス構造のより大きな形式もあります。これは、どのPOSIX charクラスが含まれているかを示す追加の32ビットビットマップを持つ &lt;code&gt;regnode_charclass_posixl&lt;/code&gt; と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="76c5f483367def15ac8c922d54c4856b499dee91" translate="yes" xml:space="preserve">
          <source>There is also a mailing list available for users of this distribution, at &lt;a href=&quot;http://lists.perl.org/list/cpan-workers.html&quot;&gt;http://lists.perl.org/list/cpan-workers.html&lt;/a&gt;.</source>
          <target state="translated">このディストリビューションのユーザーが利用できるメーリングリストも&lt;a href=&quot;http://lists.perl.org/list/cpan-workers.html&quot;&gt;http://lists.perl.org/list/cpan-workers.htmlにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="8c1a33cdb5c1f767d6b5b045c29afd70795ca96e" translate="yes" xml:space="preserve">
          <source>There is also a toyedit Text widget based editor written in Perl that is distributed with the Tk module on CPAN. The ptkdb ( &lt;a href=&quot;http://ptkdb.sourceforge.net/&quot;&gt;http://ptkdb.sourceforge.net/&lt;/a&gt; ) is a Perl/Tk-based debugger that acts as a development environment of sorts. Perl Composer ( &lt;a href=&quot;http://perlcomposer.sourceforge.net/&quot;&gt;http://perlcomposer.sourceforge.net/&lt;/a&gt; ) is an IDE for Perl/Tk GUI creation.</source>
          <target state="translated">CPANのTkモジュールで配布されるPerlで書かれたtoyedit Textウィジェットベースのエディターもあります。ptkdb（&lt;a href=&quot;http://ptkdb.sourceforge.net/&quot;&gt;http://ptkdb.sourceforge.net/&lt;/a&gt;）は、一種の開発環境として機能するPerl / Tkベースのデバッガーです。Perl Composer（&lt;a href=&quot;http://perlcomposer.sourceforge.net/&quot;&gt;http://perlcomposer.sourceforge.net/&lt;/a&gt;）は、Perl / Tk GUIを作成するためのIDEです。</target>
        </trans-unit>
        <trans-unit id="d6fbaba8f9d7c369b3de63f57e236ae1dbe1ef42" translate="yes" xml:space="preserve">
          <source>There is also an irc channel available for users of this distribution, at &lt;a href=&quot;irc://irc.perl.org/#toolchain&quot;&gt;&lt;code&gt;#toolchain&lt;/code&gt; on &lt;code&gt;irc.perl.org&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">このディストリビューションのユーザーが利用できるircチャネルも、&lt;a href=&quot;irc://irc.perl.org/#toolchain&quot;&gt; &lt;code&gt;irc.perl.org&lt;/code&gt; の&lt;/a&gt; &lt;code&gt;#toolchain&lt;/code&gt; にあります。</target>
        </trans-unit>
        <trans-unit id="d533bbf93c93c54738d070099b6cc38c79c4b031" translate="yes" xml:space="preserve">
          <source>There is an active user community that provides many software packages for the Synology DSM systems; at the time of writing this document they provide Perl version 5.24.1.</source>
          <target state="translated">Synology DSM システム用に多くのソフトウェアパッケージを提供しているアクティブなユーザーコミュニティがあり、この文書の執筆時点では Perl バージョン 5.24.1 を提供しています。</target>
        </trans-unit>
        <trans-unit id="ace8b22bc48d6e6e8b62fe08966c97467280b304" translate="yes" xml:space="preserve">
          <source>There is an edge case when using &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; from within a subroutine which was created in a different module than the one it is called from. It sounds complicated, but it really isn't. Here is an example which will not work correctly:</source>
          <target state="translated">呼び出されたモジュールとは異なるモジュールで作成されたサブルーチン内から &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; を使用する場合は、例外的なケースがあります。複雑に聞こえますが、実際はそうではありません。以下は、正しく機能しない例です。</target>
        </trans-unit>
        <trans-unit id="689977e776e24b93188512fdd38744344797e09f" translate="yes" xml:space="preserve">
          <source>There is an edge case when using &lt;code&gt;next::method&lt;/code&gt; from within a subroutine which was created in a different module than the one it is called from. It sounds complicated, but it really isn't. Here is an example which will not work correctly:</source>
          <target state="translated">呼び出されたモジュールとは異なるモジュールで作成されたサブルーチン内から &lt;code&gt;next::method&lt;/code&gt; を使用する場合、エッジケースがあります。複雑に聞こえますが、実際はそうではありません。正しく機能しない例を次に示します。</target>
        </trans-unit>
        <trans-unit id="407ad0e2a6f54d3dcabda775887575e4b7a50908" translate="yes" xml:space="preserve">
          <source>There is another directory ($CPAN::Config-&amp;gt;{keep_source_where}) where the original distribution files are kept. This directory is not covered by the cache manager and must be controlled by the user. If you choose to have the same directory as build_dir and as keep_source_where directory, then your sources will be deleted with the same fifo mechanism.</source>
          <target state="translated">元の配布ファイルが保持される別のディレクトリ（$ CPAN :: Config-&amp;gt; {keep_source_where}）があります。このディレクトリはキャッシュマネージャーの対象ではないため、ユーザーが制御する必要があります。build_dirおよびkeep_source_whereディレクトリと同じディレクトリを選択した場合、ソースは同じfifoメカニズムで削除されます。</target>
        </trans-unit>
        <trans-unit id="58cdb83a1e784fb0e74fd64a5af55da9c7c710fa" translate="yes" xml:space="preserve">
          <source>There is another method which can be used, namely letting Perl do it for you automatically whenever it regains control after the callback has terminated. This is done by simply not using the</source>
          <target state="translated">もう一つの方法として、コールバックが終了した後に Perl が制御を回復したときに、自動的に Perl にそれを行わせる方法があります。これは</target>
        </trans-unit>
        <trans-unit id="259d1525b7b40afbda3635dfb60885ec2065cd0c" translate="yes" xml:space="preserve">
          <source>There is another way to trade clarity for compactness: INPUT sections allow declaration of C variables which do not appear in the parameter list of a subroutine. Thus the above code for mutate() can be rewritten as</source>
          <target state="translated">明快さとコンパクトさを両立させるもう一つの方法があります。INPUTセクションでは、サブルーチンのパラメータリストに現れないC変数を宣言することができます。したがって、上記のmutate()のコードは次のように書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="69c800bd073688bcd19d75ca494a0e096bef464f" translate="yes" xml:space="preserve">
          <source>There is currently no method for going the other way; but I can probably provide one upon request.</source>
          <target state="translated">現在のところ、その逆の方法はありませんが、ご要望があれば、おそらくご用意できると思います。</target>
        </trans-unit>
        <trans-unit id="6993af1c1a90a2fde20c8f99658cf4ef71df4e8c" translate="yes" xml:space="preserve">
          <source>There is currently no way to turn off the guesswork that tries to format unmarked text appropriately, and sometimes it isn't wanted (particularly when using POD to document something other than Perl). Most of the work toward fixing this has now been done, however, and all that's still needed is a user interface.</source>
          <target state="translated">現在のところ、無印のテキストを適切にフォーマットしようとする推測作業をオフにする方法はありませんし、時にはそれが望まれていないこともあります(特にPODを使ってPerl以外のものを文書化する場合)。しかし、これを修正するための作業のほとんどは現在行われており、まだ必要なのはユーザインタフェースだけです。</target>
        </trans-unit>
        <trans-unit id="658a8d7bbc3f0f0bd3eee360c95b181c02d32e56" translate="yes" xml:space="preserve">
          <source>There is lots more to bracketed character classes; full details are in &lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;&quot;Bracketed Character Classes&quot; in perlrecharclass&lt;/a&gt;.</source>
          <target state="translated">括弧で囲まれた文字クラスには、さらに多くのことがあります。詳細については&lt;a href=&quot;perlrecharclass#Bracketed-Character-Classes&quot;&gt;、perlrecharclassの「BracketedCharacterClasses」を参照してください&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="923e1f4510dc236d985b28a823797fd535b1836b" translate="yes" xml:space="preserve">
          <source>There is no</source>
          <target state="translated">はありません。</target>
        </trans-unit>
        <trans-unit id="4ac6b5cad845dedcdb84c876c16dd65a46ac7fff" translate="yes" xml:space="preserve">
          <source>There is no 2GB limit on process size.</source>
          <target state="translated">プロセスサイズに2GBの制限はありません。</target>
        </trans-unit>
        <trans-unit id="4389ed97cd408884e879872fd75e0815bd058c0d" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;*.bs&lt;/code&gt; file supplied with the extension. Instead, there may be a &lt;code&gt;*_BS&lt;/code&gt; file which has code for the special cases, like posix for berkeley db on the NeXT.</source>
          <target state="translated">拡張子が付いた &lt;code&gt;*.bs&lt;/code&gt; ファイルはありません。代わりに、NeXTのberkeley dbのposixなど、特別な場合のコードを含む &lt;code&gt;*_BS&lt;/code&gt; ファイルがある場合があります。</target>
        </trans-unit>
        <trans-unit id="f9908fb44bd4986c8ec4678f0acbb2e49a902c07" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;systell&lt;/code&gt; function. Use &lt;a href=&quot;#sysseek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;sysseek($fh, 0, 1)&lt;/code&gt;&lt;/a&gt; for that.</source>
          <target state="translated">&lt;code&gt;systell&lt;/code&gt; 機能はありません。そのために&lt;a href=&quot;#sysseek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt; &lt;code&gt;sysseek($fh, 0, 1)&lt;/code&gt; &lt;/a&gt;を使用します。</target>
        </trans-unit>
        <trans-unit id="e0b489252bb15e6f1ecbef798ed7f66f86847082" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;systell&lt;/code&gt; function. Use &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; for that.</source>
          <target state="translated">&lt;code&gt;systell&lt;/code&gt; 機能はありません。そのために &lt;code&gt;&lt;a href=&quot;functions/sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="6ea7c815b6a5bfae1bac221a98896771b7bb3184" translate="yes" xml:space="preserve">
          <source>There is no &lt;code&gt;systell&lt;/code&gt; function. Use &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; for that.</source>
          <target state="translated">&lt;code&gt;systell&lt;/code&gt; 機能はありません。そのために &lt;code&gt;&lt;a href=&quot;sysseek&quot;&gt;sysseek&lt;/a&gt;(FH, 0, 1)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="76a2f2ea0128a2c9f814d14705cbf22fee6bb330" translate="yes" xml:space="preserve">
          <source>There is no BNF, but you can paw your way through the yacc grammar in perly.y in the source distribution if you're particularly brave. The grammar relies on very smart tokenizing code, so be prepared to venture into toke.c as well.</source>
          <target state="translated">BNF はありませんが、特に勇気があれば、ソース・ディストリビューションの perly.y の yacc 文法をこつこつと読み進めていくことができます。文法は非常にスマートなトークン化コードに依存しているので、toke.c にも冒険する準備をしておいてください。</target>
        </trans-unit>
        <trans-unit id="32ad1aee364e105dad5b41374df7e156cb6a43e2" translate="yes" xml:space="preserve">
          <source>There is no advantage to putting subroutines which will _always_ be called after the &lt;code&gt;__DATA__&lt;/code&gt; token.</source>
          <target state="translated">&lt;code&gt;__DATA__&lt;/code&gt; トークンの後に常に呼び出されるサブルーチンを配置する利点はありません。</target>
        </trans-unit>
        <trans-unit id="a280984dba8147f4930e83be6fff5dcdd90c3af1" translate="yes" xml:space="preserve">
          <source>There is no builtin &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; function. It is just an ordinary method (subroutine) defined (or inherited) by modules that wish to export names to another module. The &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; function calls the &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method for the package used. See also &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">組み込みの&lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;機能はありません。これは、名前を別のモジュールにエクスポートしたいモジュールによって定義（または継承）される通常のメソッド（サブルーチン）です。&lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt;関数は、呼び出しを&lt;a href=&quot;#import-LIST&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt;使用されるパッケージのための方法を。&lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt; &lt;code&gt;use&lt;/code&gt; &lt;/a&gt;、&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;、および&lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="e91dc6d303227194ff188b9dc751fb889211ca0d" translate="yes" xml:space="preserve">
          <source>There is no builtin &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function. It is just an ordinary method (subroutine) defined (or inherited) by modules that wish to export names to another module. The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; function calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method for the package used. See also &lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">組み込みの &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 機能はありません。これは、名前を別のモジュールにエクスポートしたいモジュールによって定義（または継承）された通常のメソッド（サブルーチン）です。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 関数は、呼び出しを &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 使用されるパッケージのための方法を。&lt;a href=&quot;#use&quot;&gt;use&lt;/a&gt;、&lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt;、および&lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="fe76bcf1a7a27510fd944eef657a41eda4d72a44" translate="yes" xml:space="preserve">
          <source>There is no builtin &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function. It is just an ordinary method (subroutine) defined (or inherited) by modules that wish to export names to another module. The &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; function calls the &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method for the package used. See also &lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;, and &lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt;.</source>
          <target state="translated">組み込みの &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 機能はありません。これは、名前を別のモジュールにエクスポートしたいモジュールによって定義（または継承）された通常のメソッド（サブルーチン）です。 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 関数は、呼び出しを &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; 使用されるパッケージのための方法を。&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;、&lt;a href=&quot;../perlmod&quot;&gt;perlmod&lt;/a&gt;、および&lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="05fb5ccde6fe684391b3c4f8ff40b801e9c52e40" translate="yes" xml:space="preserve">
          <source>There is no builtin way to say &quot;float this to the right hand side of the page, however wide it is.&quot; You have to specify where it goes. The truly desperate can generate their own format on the fly, based on the current number of columns, and then eval() it:</source>
          <target state="translated">これをページの右側にフロートさせる」という組み込みの方法はありません。どこに配置するかを指定しなければなりません。本当に必死な人は、現在のカラム数に基づいて独自のフォーマットをその場で生成し、それを eval()することができます。</target>
        </trans-unit>
        <trans-unit id="5ec86a2b5c6a22a41774d9be82dd0c618a3c5c45" translate="yes" xml:space="preserve">
          <source>There is no check to assert that the filehandle passed from Perl to C was created with the right &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; mode.</source>
          <target state="translated">PerlからCに渡されるファイルハンドルが適切な &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; モードで作成されたことを確認するチェックはありません。</target>
        </trans-unit>
        <trans-unit id="218dbdb05fa2faf351feae2d57dfa67d5a01ea2a" translate="yes" xml:space="preserve">
          <source>There is no check to assert that the filehandle passed from Perl to C was created with the right &lt;code&gt;open()&lt;/code&gt; mode.</source>
          <target state="translated">PerlからCに渡されたファイルハンドルが正しい &lt;code&gt;open()&lt;/code&gt; モードで作成されたことを主張するチェックはありません。</target>
        </trans-unit>
        <trans-unit id="4297cc5a425f7dacf2e1ca88cce095827acd4bc7" translate="yes" xml:space="preserve">
          <source>There is no data immediately after the compressed data stream.</source>
          <target state="translated">圧縮されたデータストリームの直後にはデータがありません。</target>
        </trans-unit>
        <trans-unit id="784e961111d5a1435645faa2fd65cc0510bda63f" translate="yes" xml:space="preserve">
          <source>There is no decrypt function. This function isn't all that useful for cryptography (for that, look for</source>
          <target state="translated">復号化機能はありません。この関数は暗号化にはそれほど有用ではありません (それについては</target>
        </trans-unit>
        <trans-unit id="7d50acdbf96ea291176f3a2d7e886b2944e1f2b9" translate="yes" xml:space="preserve">
          <source>There is no description given for most non-Perl defined properties (See &lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http://www.unicode.org/reports/tr44/&lt;/a&gt; for that).</source>
          <target state="translated">Perlで定義されていないほとんどのプロパティの説明はありません（その詳細については、&lt;a href=&quot;http://www.unicode.org/reports/tr44/&quot;&gt;http：//www.unicode.org/reports/tr44/&lt;/a&gt;を参照してください）。</target>
        </trans-unit>
        <trans-unit id="efbf1382c6e11055de15bc7597f5ea124690d870" translate="yes" xml:space="preserve">
          <source>There is no double interpolation in Perl, so the &lt;code&gt;$100&lt;/code&gt; is left as is.</source>
          <target state="translated">Perlには二重補間がないため、 &lt;code&gt;$100&lt;/code&gt; はそのままです。</target>
        </trans-unit>
        <trans-unit id="455b851bfe4dcf94993aa6ab9485d19207a20655" translate="yes" xml:space="preserve">
          <source>There is no easy way to provide this functionality in &lt;code&gt;Archive::Tar&lt;/code&gt; , because a tarball can contain many files, and each of which could be encoded in a different way.</source>
          <target state="translated">&lt;code&gt;Archive::Tar&lt;/code&gt; でこの機能を提供する簡単な方法はありません。tarballには多くのファイルが含まれている可能性があり、それぞれが異なる方法でエンコードされている可能性があるためです。</target>
        </trans-unit>
        <trans-unit id="5f678f49ea0f0b1f3db41874eff418b0f56e6c16" translate="yes" xml:space="preserve">
          <source>There is no easy way to provide this functionality in &lt;code&gt;Archive::Tar&lt;/code&gt;, because a tarball can contain many files, and each of which could be encoded in a different way.</source>
          <target state="translated">&lt;code&gt;Archive::Tar&lt;/code&gt; でこの機能を提供する簡単な方法はありません。これは、tarballには多くのファイルが含まれている可能性があり、それぞれが異なる方法でエンコードされる可能性があるためです。</target>
        </trans-unit>
        <trans-unit id="27f49800696d7a52910d2aa32267a02c4e742caa" translate="yes" xml:space="preserve">
          <source>There is no equivalent operator to force an expression to be interpolated in list context because in practice, this is never needed. If you really wanted to do so, however, you could use the construction &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt; , but usually a simple &lt;code&gt;(some expression)&lt;/code&gt; suffices.</source>
          <target state="translated">リストコンテキストで式を強制的に補間するための同等の演算子はありません。これは、実際には必要ないためです。ただし、本当にそうしたい場合は、構造 &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt; 使用できますが、通常は単純な &lt;code&gt;(some expression)&lt;/code&gt; で十分です。</target>
        </trans-unit>
        <trans-unit id="7cb80803d06b14ddbd06119d95cbdefe4be98fc5" translate="yes" xml:space="preserve">
          <source>There is no equivalent operator to force an expression to be interpolated in list context because in practice, this is never needed. If you really wanted to do so, however, you could use the construction &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt;, but usually a simple &lt;code&gt;(some expression)&lt;/code&gt; suffices.</source>
          <target state="translated">実際にはこれが必要になることはないため、リストコンテキストで式を強制的に補間する同等の演算子はありません。ただし、本当にそうしたい場合は、構文 &lt;code&gt;@{[ (some expression) ]}&lt;/code&gt; 使用できますが、通常は単純な &lt;code&gt;(some expression)&lt;/code&gt; で十分です。</target>
        </trans-unit>
        <trans-unit id="6da385daea49ac6d957f9692c325e916978ed205" translate="yes" xml:space="preserve">
          <source>There is no equivalent to &lt;code&gt;fgets&lt;/code&gt; ; one should use &lt;code&gt;sv_gets&lt;/code&gt; instead:</source>
          <target state="translated">&lt;code&gt;fgets&lt;/code&gt; に相当するものはありません。代わりに &lt;code&gt;sv_gets&lt;/code&gt; を使用する必要があります：</target>
        </trans-unit>
        <trans-unit id="9c4f353571f4abb0cafbf257cbbb852b1668ac0d" translate="yes" xml:space="preserve">
          <source>There is no equivalent to &lt;code&gt;fgets&lt;/code&gt;; one should use &lt;code&gt;sv_gets&lt;/code&gt; instead:</source>
          <target state="translated">&lt;code&gt;fgets&lt;/code&gt; に相当するものはありません。代わりに &lt;code&gt;sv_gets&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="56b2b22bb272d9529f5a7b2eeb648640b188c1f1" translate="yes" xml:space="preserve">
          <source>There is no firewall</source>
          <target state="translated">ファイアウォールがない</target>
        </trans-unit>
        <trans-unit id="121835ac892ea37b942952f42c3ffe4014099c6d" translate="yes" xml:space="preserve">
          <source>There is no general solution to all of this. It is a mess.</source>
          <target state="translated">このすべてに一般的な解決策はありません。混乱しているのです。</target>
        </trans-unit>
        <trans-unit id="87f0999d25c4eb3604c738b2e0116726668320dd" translate="yes" xml:space="preserve">
          <source>There is no general solution to all of this. It's just a mess.</source>
          <target state="translated">このすべてに一般的な解決策はありません。ごちゃごちゃしているだけです。</target>
        </trans-unit>
        <trans-unit id="b2b55e890caeb51d36e6b91d2ac8fcb1b35de4f5" translate="yes" xml:space="preserve">
          <source>There is no interface to request alternative CHECK behavior as for decode_argv(). If you need that you need to call encode/decode yourself. For example:</source>
          <target state="translated">decode_argv()のように代替の CHECK 動作を要求するインタフェースはありません。もしそれが必要ならば、自分自身で encode/decode を呼び出す必要があります。例えば</target>
        </trans-unit>
        <trans-unit id="e2b8fcbb171cbccbd111cd2bd311ab6e6fcd1a58" translate="yes" xml:space="preserve">
          <source>There is no low precedence operator for defined-OR.</source>
          <target state="translated">defined-ORには優先順位の低い演算子はありません。</target>
        </trans-unit>
        <trans-unit id="a8da251185c2a49373fb6cf76b3c29c18692d780" translate="yes" xml:space="preserve">
          <source>There is no need to inherit from the &lt;b&gt;SelfLoader&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;SelfLoader&lt;/b&gt;から継承する必要はありません。</target>
        </trans-unit>
        <trans-unit id="6e895b74ce6094374e60e95c58a0d18a65714b5a" translate="yes" xml:space="preserve">
          <source>There is no need to upgrade if you already have it installed.</source>
          <target state="translated">すでにインストールされている場合はアップグレードの必要はありません。</target>
        </trans-unit>
        <trans-unit id="6f9d8d1ae5518832290b8aa40a4082b8960c7be8" translate="yes" xml:space="preserve">
          <source>There is no one DBM module available on all platforms. &lt;a href=&quot;sdbm_file&quot;&gt;&lt;code&gt;SDBM_File&lt;/code&gt;&lt;/a&gt; and the others are generally available on all Unix and DOSish ports, but not in MacPerl, where only &lt;a href=&quot;ndbm_file&quot;&gt;&lt;code&gt;NDBM_File&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;db_file&quot;&gt;&lt;code&gt;DB_File&lt;/code&gt;&lt;/a&gt; are available.</source>
          <target state="translated">すべてのプラットフォームで使用できるDBMモジュールは1つではありません。&lt;a href=&quot;sdbm_file&quot;&gt; &lt;code&gt;SDBM_File&lt;/code&gt; &lt;/a&gt;およびその他は、通常、すべてのUnixおよびDOSishポートで使用できますが、&lt;a href=&quot;ndbm_file&quot;&gt; &lt;code&gt;NDBM_File&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;db_file&quot;&gt; &lt;code&gt;DB_File&lt;/code&gt; &lt;/a&gt;のみが使用できるMacPerlでは使用できません。</target>
        </trans-unit>
        <trans-unit id="0d3cd63858e09b2c6b6ec38df40d5828e10651d9" translate="yes" xml:space="preserve">
          <source>There is no one DBM module available on all platforms. &lt;code&gt;SDBM_File&lt;/code&gt; and the others are generally available on all Unix and DOSish ports, but not in MacPerl, where only &lt;code&gt;NDBM_File&lt;/code&gt; and &lt;code&gt;DB_File&lt;/code&gt; are available.</source>
          <target state="translated">すべてのプラットフォームで使用できるDBMモジュールは1つではありません。 &lt;code&gt;SDBM_File&lt;/code&gt; などは、すべてのUnixおよびDOSishポートで一般的に使用できますが、 &lt;code&gt;NDBM_File&lt;/code&gt; および &lt;code&gt;DB_File&lt;/code&gt; のみが使用可能なMacPerlでは使用できません。</target>
        </trans-unit>
        <trans-unit id="dc935adca7e5bcb15422e7a69e6858c66da25299" translate="yes" xml:space="preserve">
          <source>There is no provision for delaying a request body using an &lt;code&gt;Expect&lt;/code&gt; header. Unexpected &lt;code&gt;1XX&lt;/code&gt; responses are silently ignored as per the specification.</source>
          <target state="translated">&lt;code&gt;Expect&lt;/code&gt; ヘッダーを使用してリクエスト本文を遅延させるための規定はありません。予期しない &lt;code&gt;1XX&lt;/code&gt; 応答は、仕様に従って黙って無視されます。</target>
        </trans-unit>
        <trans-unit id="f93f05645168f7a6ce32010423ff327f27468e22" translate="yes" xml:space="preserve">
          <source>There is no public API for popping individual values or items from the save stack. Instead, via the scope stack, the &lt;code&gt;ENTER&lt;/code&gt; and &lt;code&gt;LEAVE&lt;/code&gt; pair form a way to start and stop nested scopes. Leaving a nested scope via &lt;code&gt;LEAVE&lt;/code&gt; will restore all of the saved values that had been pushed since the most recent &lt;code&gt;ENTER&lt;/code&gt;.</source>
          <target state="translated">保存スタックから個々の値またはアイテムをポップするためのパブリックAPIはありません。代わりに、スコープスタックを介して、 &lt;code&gt;ENTER&lt;/code&gt; と &lt;code&gt;LEAVE&lt;/code&gt; のペアが、ネストされたスコープを開始および停止する方法を形成します。 &lt;code&gt;LEAVE&lt;/code&gt; を介してネストされたスコープを離れると、最後の &lt;code&gt;ENTER&lt;/code&gt; 以降にプッシュされたすべての保存された値が復元されます。</target>
        </trans-unit>
        <trans-unit id="e7d4d5447e705702a110e831b9f5c50697a0ccfe" translate="yes" xml:space="preserve">
          <source>There is no public API to directly push items to the temporaries stack. Instead, the API function &lt;code&gt;sv_2mortal()&lt;/code&gt; is used to mortalize an xV, adding its address to the temporaries stack.</source>
          <target state="translated">アイテムを一時スタックに直接プッシュするためのパブリックAPIはありません。代わりに、API関数 &lt;code&gt;sv_2mortal()&lt;/code&gt; を使用してxVをモータル化し、そのアドレスを一時スタックに追加します。</target>
        </trans-unit>
        <trans-unit id="fb47afbc2311aee90586d3371f78c62b2ed90edb" translate="yes" xml:space="preserve">
          <source>There is no quantifier &lt;code&gt;{,n}&lt;/code&gt; . That's interpreted as a literal string.</source>
          <target state="translated">数量詞 &lt;code&gt;{,n}&lt;/code&gt; はありません。それはリテラル文字列として解釈されます。</target>
        </trans-unit>
        <trans-unit id="4e5e1c10d207641a72418018f1f75f1613935380" translate="yes" xml:space="preserve">
          <source>There is no quantifier &lt;code&gt;{,n}&lt;/code&gt;. That's currently illegal.</source>
          <target state="translated">数量詞 &lt;code&gt;{,n}&lt;/code&gt; はありません。それは現在違法です。</target>
        </trans-unit>
        <trans-unit id="b61924ba7fcca566e3d46f3a27c41097477fd32e" translate="yes" xml:space="preserve">
          <source>There is no reason to directly use this package. This package is documented for completeness. This package can change, or go away completely at any time. Directly using, or monkeypatching this package is not supported in any way shape or form.</source>
          <target state="translated">このパッケージを直接使用する理由はありません。本パッケージは完全性を保つために文書化されています。本パッケージはいつでも変更されたり、完全に消滅したりする可能性があります。このパッケージを直接使用したり、モンキーパッチを当てたりすることは、 いかなる形であれサポートされていません。</target>
        </trans-unit>
        <trans-unit id="378d1a5bc456220dab02d99326a34c6e9f3d48c2" translate="yes" xml:space="preserve">
          <source>There is no reason you should not use Perl as a language to glue Unix tools together, or to prototype a Macintosh application, or to manage the Windows registry. If it makes no sense to aim for portability for one reason or another in a given program, then don't bother.</source>
          <target state="translated">Unixのツールを接着したり、Macintoshのアプリケーションをプロトタイプ化したり、Windowsのレジストリを管理したりするための言語としてPerlを使わない理由はありません。与えられたプログラムの中で、何らかの理由で移植性を目指すことに意味がないのであれば、気にする必要はありません。</target>
        </trans-unit>
        <trans-unit id="860dd139f43df25bd42c1af5b8706f2806229649" translate="yes" xml:space="preserve">
          <source>There is no requirement to convert anything.</source>
          <target state="translated">何も変換する必要はありません。</target>
        </trans-unit>
        <trans-unit id="5d190eab008c4161478c644351172b878f4f965a" translate="yes" xml:space="preserve">
          <source>There is no set_layers(), nor does get_layers() return a tied array mirroring the stack, or anything fancy like that. This is not accidental or unintentional. The PerlIO layer stack is a bit more complicated than just a stack (see for example the behaviour of &lt;code&gt;:raw&lt;/code&gt; ). You are supposed to use open() and binmode() to manipulate the stack.</source>
          <target state="translated">set_layers（）はなく、get_layers（）はスタックをミラーリングした結合配列やそのような特別なものを返しません。これは偶発的または意図的ではありません。PerlIO層スタックは、単なるスタックよりも少し複雑です（たとえば、 &lt;code&gt;:raw&lt;/code&gt; の動作を参照）。スタックを操作するには、open（）およびbinmode（）を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="382f006c5b68a9b9a43fcd623fca8e14332f9212" translate="yes" xml:space="preserve">
          <source>There is no set_layers(), nor does get_layers() return a tied array mirroring the stack, or anything fancy like that. This is not accidental or unintentional. The PerlIO layer stack is a bit more complicated than just a stack (see for example the behaviour of &lt;code&gt;:raw&lt;/code&gt;). You are supposed to use open() and binmode() to manipulate the stack.</source>
          <target state="translated">set_layers（）はなく、get_layers（）は、スタックをミラーリングする結合配列、またはそのような特別なものを返しません。これは偶発的または意図的ではありません。 PerlIOレイヤースタックは、単なるスタックよりも少し複雑です（たとえば、 &lt;code&gt;:raw&lt;/code&gt; の動作を参照してください）。 open（）とbinmode（）を使用してスタックを操作することになっています。</target>
        </trans-unit>
        <trans-unit id="fcb140242be9c5687c6a498b3df2879f2625b5b6" translate="yes" xml:space="preserve">
          <source>There is no shell to process metacharacters, and the native standard is to pass a command line terminated by &quot;\n&quot; &quot;\r&quot; or &quot;\0&quot; to the spawned program. Redirection such as &lt;code&gt;&amp;gt; foo&lt;/code&gt; is performed (if at all) by the run time library of the spawned program. &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">メタ文字を処理するシェルはなく、ネイティブ標準は、「\ n」、「\ r」、または「\ 0」で終了するコマンドラインを生成されたプログラムに渡すことです。 &lt;code&gt;&amp;gt; foo&lt;/code&gt; などのリダイレクトは、生成されたプログラムのランタイムライブラリによって（もしあれば）実行されます。 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="deba5b88e82775e19650d3712106c375f59f7e30" translate="yes" xml:space="preserve">
          <source>There is no significant speed gain between compile time and run time class creation, there is just a new, more standard order of events.</source>
          <target state="translated">コンパイル時間とランタイムのクラス作成の間に大きな速度の向上はなく、単に新しい、より標準的なイベントの順序があるだけです。</target>
        </trans-unit>
        <trans-unit id="6b7801d1cfdd5c48abee3f679e368ab10b3ad8dc" translate="yes" xml:space="preserve">
          <source>There is no simple answer to this question. Perl frameworks can run everything from basic file servers and small scale intranets to massive multinational multilingual websites that are the core to international businesses.</source>
          <target state="translated">この質問に対する単純な答えはありません。Perlフレームワークは、基本的なファイルサーバと小規模のイントラネットから、国際的なビジネスの中心である大規模な多国籍多言語ウェブサイトまで、すべてを実行することができます。</target>
        </trans-unit>
        <trans-unit id="300fa34c66267d66af5fbbb27ef916d4adcee2ea" translate="yes" xml:space="preserve">
          <source>There is no simple replacement possible since a qualifier and all its subqualifiers must be considered together, so we use our own utility routine for the replacement.</source>
          <target state="translated">予選子とその下位の全てを一緒に考えなければならないので、簡単な置換はありませんので、独自のユーティリティルーチンを使って置換しています。</target>
        </trans-unit>
        <trans-unit id="557d02393de130217c50453e6a017ae2fadcbc8e" translate="yes" xml:space="preserve">
          <source>There is no simple solution to this because of printf()'s limited intelligence, but for many types the right format is available as with either 'f' or '_f' suffix, for example:</source>
          <target state="translated">printf()の知能が限られているため、これに対する単純な解決策はありませんが、多くの型では、例えば 'f' や '_f' のような接尾辞をつけることで正しいフォーマットが利用できます。</target>
        </trans-unit>
        <trans-unit id="5540c0e13568fd5e0e7ecd528ea43dc498771d2a" translate="yes" xml:space="preserve">
          <source>There is no simple way to access WPS objects. The only way I know is via &lt;code&gt;OS2::REXX&lt;/code&gt; and &lt;code&gt;SOM&lt;/code&gt; extensions (see &lt;a href=&quot;OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;, &lt;a href=&quot;som&quot;&gt;SOM&lt;/a&gt;). However, we do not have access to convenience methods of Object-REXX. (Is it possible at all? I know of no Object-REXX API.) The &lt;code&gt;SOM&lt;/code&gt; extension (currently in alpha-text) may eventually remove this shortcoming; however, due to the fact that DII is not supported by the &lt;code&gt;SOM&lt;/code&gt; module, using &lt;code&gt;SOM&lt;/code&gt; is not as convenient as one would like it.</source>
          <target state="translated">WPSオブジェクトにアクセスする簡単な方法はありません。私が知っている唯一の方法は、 &lt;code&gt;OS2::REXX&lt;/code&gt; および &lt;code&gt;SOM&lt;/code&gt; 拡張機能を使用することです（&lt;a href=&quot;OS2::REXX&quot;&gt;OS2 :: REXX&lt;/a&gt;、&lt;a href=&quot;som&quot;&gt;SOMを&lt;/a&gt;参照）。ただし、Object-REXXの便利なメソッドにはアクセスできません。 （それはまったく可能ですか？私はObject-REXX APIを知りません。） &lt;code&gt;SOM&lt;/code&gt; 拡張（現在アルファテキスト）は最終的にこの欠点を取り除くかもしれません。しかし、DIIはでサポートされていないという事実による &lt;code&gt;SOM&lt;/code&gt; の使用、モジュール &lt;code&gt;SOM&lt;/code&gt; は1がそれを希望ほど便利ではありません。</target>
        </trans-unit>
        <trans-unit id="8ceb0317aba48e3a3b6cabda91010f77ae7a54b9" translate="yes" xml:space="preserve">
          <source>There is no simple way to access WPS objects. The only way I know is via &lt;code&gt;OS2::REXX&lt;/code&gt; and &lt;code&gt;SOM&lt;/code&gt; extensions (see &lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2::REXX&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/SOM&quot;&gt;SOM&lt;/a&gt;). However, we do not have access to convenience methods of Object-REXX. (Is it possible at all? I know of no Object-REXX API.) The &lt;code&gt;SOM&lt;/code&gt; extension (currently in alpha-text) may eventually remove this shortcoming; however, due to the fact that DII is not supported by the &lt;code&gt;SOM&lt;/code&gt; module, using &lt;code&gt;SOM&lt;/code&gt; is not as convenient as one would like it.</source>
          <target state="translated">WPSオブジェクトにアクセスする簡単な方法はありません。私が知っている唯一の方法は、 &lt;code&gt;OS2::REXX&lt;/code&gt; および &lt;code&gt;SOM&lt;/code&gt; 拡張機能を使用することです（&lt;a href=&quot;http://search.cpan.org/perldoc/OS2::REXX&quot;&gt;OS2 :: REXX&lt;/a&gt;、&lt;a href=&quot;http://search.cpan.org/perldoc/SOM&quot;&gt;SOMを&lt;/a&gt;参照）。ただし、Object-REXXの便利なメソッドにはアクセスできません。 （それはまったく可能ですか？Object-REXX APIがないことを知っています。） &lt;code&gt;SOM&lt;/code&gt; 拡張（現在はアルファテキスト）は、最終的にこの欠点を取り除く可能性があります。しかし、DIIはでサポートされていないという事実による &lt;code&gt;SOM&lt;/code&gt; の使用、モジュール &lt;code&gt;SOM&lt;/code&gt; は 1がそれを希望ほど便利ではありません。</target>
        </trans-unit>
        <trans-unit id="06843bf4e2da3a9df3bd916b78c90fe1d32c0462" translate="yes" xml:space="preserve">
          <source>There is no special class syntax in Perl, but a package may act as a class if it provides subroutines to act as methods. Such a package may also derive some of its methods from another class (package) by listing the other package name(s) in its global @ISA array (which must be a package global, not a lexical).</source>
          <target state="translated">Perlには特別なクラス構文はありませんが、メソッドとして動作するサブルーチンを提供している場合、パッケージはクラスとして動作することができます。そのようなパッケージは、他のクラス(パッケージ)からメソッドの一部を派生させることもできますが、他のパッケージ名をグローバルな@ISA配列(辞書的なものではなく、パッケージのグローバルなものでなければなりません)に列挙することで、そのメソッドを派生させることができます。</target>
        </trans-unit>
        <trans-unit id="f83d3f75f9b7673dc85f27f3287a09a764999d4c" translate="yes" xml:space="preserve">
          <source>There is no specific mailing list for Perl on VOS. You can contact the Stratus Technologies Customer Assistance Center (CAC) for your region, or you can use the contact information located in the distribution files on the Stratus Anonymous FTP site.</source>
          <target state="translated">VOS 上には、Perl 用の特定のメーリングリストはありません。お住まいの地域の Stratus Technologies Customer Assistance Center (CAC)に連絡するか、Stratus Anonymous FTP サイトの配布ファイルにある連絡先情報を利用することができます。</target>
        </trans-unit>
        <trans-unit id="100c2da519836111bd839e12cb2fd3dec223d870" translate="yes" xml:space="preserve">
          <source>There is no specification of the formatter after the &lt;code&gt;=for&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;=for&lt;/code&gt; コマンドの後のフォーマッターの指定はありません。</target>
        </trans-unit>
        <trans-unit id="670b965fe2aed5c0a5a49c42acbad90f9fc925e9" translate="yes" xml:space="preserve">
          <source>There is no such thing as a network representation for reals, so if you want to send your real numbers across computer boundaries, you'd better stick to text representation, possibly using the hexadecimal float format (avoiding the decimal conversion loss), unless you're absolutely sure what's on the other end of the line. For the even more adventuresome, you can use the byte-order modifiers from the previous section also on floating point codes.</source>
          <target state="translated">実数のネットワーク表現は存在しませんので、コンピュータの境界線を越えて実数を送信したい場合は、テキスト表現にこだわる方が良いでしょう。さらに冒険的な方には、浮動小数点コードの前のセクションで紹介したバイト順の修飾子を使用することができます。</target>
        </trans-unit>
        <trans-unit id="485f9819a36f9757672adb9a54833a7d985d4ad2" translate="yes" xml:space="preserve">
          <source>There is no support at present for tied @ISA. There is a potential conflict between magic entries needed to notice setting of @ISA, and those needed to implement 'tie'.</source>
          <target state="translated">現在のところ、@ISAの紐付けには対応していません。ISAの設定を通知するために必要なマジックエントリと、'tie'を実装するために必要なマジックエントリとの間には、競合が発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="8ce7f675d43b056af9ee6718421eba4a7f2bb579" translate="yes" xml:space="preserve">
          <source>There is no support for a Request-URI of '*' for the 'OPTIONS' request.</source>
          <target state="translated">OPTIONS」リクエストのための'*'のRequest-URIはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="f0d4e44dc9af068a1f923f5eebfb3439b41ed99d" translate="yes" xml:space="preserve">
          <source>There is no support for dynamically linked libraries in QNX4.</source>
          <target state="translated">QNX4 では、動的にリンクされたライブラリはサポートされていません。</target>
        </trans-unit>
        <trans-unit id="ddb797616f9cbf4b2f8a2cb06d0ccee2c08c8ad1" translate="yes" xml:space="preserve">
          <source>There is no syseof() function, which is ok, since &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; doesn't work well on device files (like ttys) anyway. Use &lt;a href=&quot;#sysread-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt;&lt;code&gt;sysread&lt;/code&gt;&lt;/a&gt; and check for a return value of 0 to decide whether you're done.</source>
          <target state="translated">とにかく&lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof&lt;/code&gt; &lt;/a&gt;はデバイスファイル（ttysなど）ではうまく機能しないため、syseof（）関数はありません。使用&lt;a href=&quot;#sysread-FILEHANDLE%2CSCALAR%2CLENGTH%2COFFSET&quot;&gt; &lt;code&gt;sysread&lt;/code&gt; &lt;/a&gt; 0の戻り値のチェックは、あなたが行われているかどうかを決定します。</target>
        </trans-unit>
        <trans-unit id="73a30aae9994d5aba957137545368eea0ce0f5eb" translate="yes" xml:space="preserve">
          <source>There is no syseof() function, which is ok, since eof() doesn't work well on device files (like ttys) anyway. Use sysread() and check for a return value for 0 to decide whether you're done.</source>
          <target state="translated">syseof()関数はありませんが、eof()はいずれにせよデバイスファイル (tys のような)ではうまく動作しないので、これは問題ありません。sysread()を使用して、0 の戻り値をチェックして終了かどうかを判断してください。</target>
        </trans-unit>
        <trans-unit id="8fc13de7d6614c5dd033dd321c9bbd82b325da63" translate="yes" xml:space="preserve">
          <source>There is no technical reason why a Berkeley DB database cannot be shared by both a Perl and a C application.</source>
          <target state="translated">バークレーDBデータベースがPerlとCアプリケーションの両方で共有できない技術的な理由はありません。</target>
        </trans-unit>
        <trans-unit id="79f7328788708da5a0cdbfe8c102e73defe278fc" translate="yes" xml:space="preserve">
          <source>There is no way to reliably detect the encoding automatically, so if people keep sending you data without charset indication, you may have to educate them.</source>
          <target state="translated">自動的にエンコードを確実に検出する方法はないので、文字コード表示なしでデータを送り続ける人がいたら、教育しないといけないかもしれません。</target>
        </trans-unit>
        <trans-unit id="20ec9f83105615b23b9fac938fd715b5bc923fe1" translate="yes" xml:space="preserve">
          <source>There is no way to turn it back on.</source>
          <target state="translated">元に戻す方法はありません。</target>
        </trans-unit>
        <trans-unit id="9d4ba678fc087cfe3ed3657d1daba5422cdd5616" translate="yes" xml:space="preserve">
          <source>There is nothing special about Memoize::Expire. It is just an example. If you don't like the policy that it implements, you are free to write your own expiration policy module that implements whatever policy you desire. Here is how to do that. Let us suppose that your module will be named MyExpirePolicy.</source>
          <target state="translated">Memoize::Expireについては特に何もありません。ただの一例に過ぎません。もしそれが実装しているポリシーが気に入らないのであれば、好きなポリシーを実装した独自の期限切れポリシーモジュールを書くのは自由です。ここではその方法を説明します。あなたのモジュールがMyExpirePolicyという名前になるとしましょう。</target>
        </trans-unit>
        <trans-unit id="6fcd6f426861d4a9d172b0ea1e309235434fe63e" translate="yes" xml:space="preserve">
          <source>There is now a &lt;code&gt;bsstr()&lt;/code&gt; method to get the string in scientific notation aka &lt;code&gt;1e+2&lt;/code&gt; instead of &lt;code&gt;100&lt;/code&gt; . Be advised that overloaded 'eq' always uses bstr() for comparison, but Perl will represent some numbers as 100 and others as 1e+308. If in doubt, convert both arguments to Math::BigInt before comparing them as strings:</source>
          <target state="translated">&lt;code&gt;100&lt;/code&gt; の代わりに &lt;code&gt;1e+2&lt;/code&gt; とも呼ばれる科学表記で文字列を取得する &lt;code&gt;bsstr()&lt;/code&gt; メソッドが追加されました。オーバーロードされた 'eq'は常に比較のためにbstr（）を使用しますが、Perlはいくつかの数値を100として表し、他の数値を1e + 308として表すことに注意してください。疑問がある場合は、両方の引数を文字列として比較する前に、Math :: BigIntに変換します。</target>
        </trans-unit>
        <trans-unit id="5ae720bb4190ab9bd815350aa7eadedcf7d8ced5" translate="yes" xml:space="preserve">
          <source>There is now a &lt;code&gt;bsstr()&lt;/code&gt; method to get the string in scientific notation aka &lt;code&gt;1e+2&lt;/code&gt; instead of &lt;code&gt;100&lt;/code&gt;. Be advised that overloaded 'eq' always uses bstr() for comparison, but Perl represents some numbers as 100 and others as 1e+308. If in doubt, convert both arguments to Math::BigInt before comparing them as strings:</source>
          <target state="translated">&lt;code&gt;100&lt;/code&gt; ではなく &lt;code&gt;1e+2&lt;/code&gt; として &lt;code&gt;bsstr()&lt;/code&gt; れる科学的記数法で文字列を取得するbsstr（）メソッドがあります。オーバーロードされた 'eq'は常に比較のためにbstr（）を使用しますが、Perlはいくつかの数値を100として表し、他の数値を1e +308として表すことに注意してください。疑わしい場合は、文字列として比較する前に、両方の引数をMath :: BigIntに変換してください。</target>
        </trans-unit>
        <trans-unit id="22f759aa48f981bff2eecdd8034d0137dd1c154a" translate="yes" xml:space="preserve">
          <source>There is of course lots more to find out about, this has just scratched the surface. The best way to learn more is to use perldoc to find out more about the language, to read the on-line help (&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; is probably the next place to go), and of course, experiment.</source>
          <target state="translated">もちろん、調べるべきことは他にもたくさんありますが、これは表面をなぞっただけです。さらに学ぶための最良の方法は、perldocを使用して言語の詳細を調べ、オンラインヘルプを読んで（&lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt;はおそらく次に進むべき場所です）、そしてもちろん実験することです。</target>
        </trans-unit>
        <trans-unit id="4c5dc52000b85d6cc8d7d71cfdf7a1cf6d094cbc" translate="yes" xml:space="preserve">
          <source>There is often a matter of opinion and taste, and there isn't any one answer that fits everyone. In general, you want to use either the current stable release, or the stable release immediately prior to that one.</source>
          <target state="translated">多くの場合、意見や好みの問題があり、すべての人に当てはまる答えがあるわけではありません。一般的には、現在の安定版リリースか、その直前の安定版リリースのどちらかを使いたいと思います。</target>
        </trans-unit>
        <trans-unit id="2f1fdaa6644f76210c716aac51df03a67575812a" translate="yes" xml:space="preserve">
          <source>There is often a matter of opinion and taste, and there isn't any one answer that fits everyone. In general, you want to use either the current stable release, or the stable release immediately prior to that one. Currently, those are perl5.18.x and perl5.16.x, respectively.</source>
          <target state="translated">多くの場合、意見や好みの問題があり、すべての人に当てはまる答えがあるわけではありません。一般的には、現在の安定版リリースか、その直前の安定版リリースのどちらかを使いたいと思います。現在は、それぞれ perl5.18.x と perl5.16.x です。</target>
        </trans-unit>
        <trans-unit id="6fddc6aff8f6804eafbdecf55f8d9d2197b85b37" translate="yes" xml:space="preserve">
          <source>There is one caveat with INSTALL_BASE, though, since it acts differently from the PREFIX and LIB settings that older versions of &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; advocated. INSTALL_BASE does not support installing modules for multiple versions of Perl or different architectures under the same directory. You should consider whether you really want that and, if you do, use the older PREFIX and LIB settings. See the &lt;a href=&quot;ExtUtils::Makemaker&quot;&gt;ExtUtils::Makemaker&lt;/a&gt; documentation for more details.</source>
          <target state="translated">ただし、INSTALL_BASEには、古いバージョンの&lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils :: MakeMakerが推奨&lt;/a&gt;していたPREFIXおよびLIB設定とは動作が異なるため、注意点が1つあります。INSTALL_BASEは、Perlの複数のバージョンまたは同じディレクトリ内の異なるアーキテクチャ用のモジュールのインストールをサポートしていません。本当に必要かどうかを検討する必要があります。必要な場合は、古いPREFIXおよびLIB設定を使用してください。詳細については、&lt;a href=&quot;ExtUtils::Makemaker&quot;&gt;ExtUtils :: Makemakerの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="5e0ec9ff71273582227d757a4501aa81fcc373f2" translate="yes" xml:space="preserve">
          <source>There is one caveat with INSTALL_BASE, though, since it acts differently from the PREFIX and LIB settings that older versions of &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; advocated. INSTALL_BASE does not support installing modules for multiple versions of Perl or different architectures under the same directory. You should consider whether you really want that and, if you do, use the older PREFIX and LIB settings. See the &lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Makemaker&quot;&gt;ExtUtils::Makemaker&lt;/a&gt; documentation for more details.</source>
          <target state="translated">ただし、INSTALL_BASEには注意が1つあります。これは、&lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMakerの&lt;/a&gt;古いバージョンが推奨していたPREFIXおよびLIBの設定とは異なる動作をするためです。 INSTALL_BASEは、Perlの複数のバージョンまたは異なるアーキテクチャのモジュールを同じディレクトリにインストールすることをサポートしていません。それが本当に必要かどうかを検討し、必要な場合は古いPREFIXおよびLIB設定を使用してください。詳細については、&lt;a href=&quot;http://search.cpan.org/perldoc/ExtUtils::Makemaker&quot;&gt;ExtUtils :: Makemakerの&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="14196e0aaa427146743d8121cb1facbe4cf5fb5c" translate="yes" xml:space="preserve">
          <source>There is one crucial restriction: the prereqs of an optional feature &lt;b&gt;must not&lt;/b&gt; include &lt;code&gt;configure&lt;/code&gt; phase prereqs.</source>
          <target state="translated">重要な制限が1つあり &lt;code&gt;configure&lt;/code&gt; 。オプション機能の前提条件に構成フェーズの前提条件を含めては&lt;b&gt;なりません&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="97b4745ddf35dec712ea27023babefb7e0f47466" translate="yes" xml:space="preserve">
          <source>There is one exception to all this. &lt;code&gt;\p{All}&lt;/code&gt; looks like a Unicode property, but it is a Perl extension that is defined to be true for all possible code points, Unicode or not, so no warning is ever generated when matching this against a non-Unicode code point. (Prior to v5.20, it was an exact synonym for &lt;code&gt;\p{Any}&lt;/code&gt; , matching code points &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;0x10FFFF&lt;/code&gt; .)</source>
          <target state="translated">これには1つの例外があります。 &lt;code&gt;\p{All}&lt;/code&gt; はUnicodeプロパティのように見えますが、Unicodeであるかどうかにかかわらず、すべての可能なコードポイントに対してtrueと定義されているPerlの拡張であるため、これを非Unicodeコードポイントと照合しても警告は生成されません。（V5.20の前に、それはのための正確な同義語た &lt;code&gt;\p{Any}&lt;/code&gt; 、一致するコードポイント &lt;code&gt;0&lt;/code&gt; を介し &lt;code&gt;0x10FFFF&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a280fffe45cedb42744a2a95530fed2f40145dd0" translate="yes" xml:space="preserve">
          <source>There is one exception to all this. &lt;code&gt;\p{All}&lt;/code&gt; looks like a Unicode property, but it is a Perl extension that is defined to be true for all possible code points, Unicode or not, so no warning is ever generated when matching this against a non-Unicode code point. (Prior to v5.20, it was an exact synonym for &lt;code&gt;\p{Any}&lt;/code&gt;, matching code points &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;0x10FFFF&lt;/code&gt;.)</source>
          <target state="translated">これには1つの例外があります。 &lt;code&gt;\p{All}&lt;/code&gt; はUnicodeプロパティのように見えますが、Unicodeであるかどうかに関係なく、すべての可能なコードポイントに対してtrueと定義されているPerl拡張であるため、これを非Unicodeコードポイントと照合しても警告は生成されません。（v5.20より前は、 &lt;code&gt;\p{Any}&lt;/code&gt; 正確な同義語であり、コードポイント &lt;code&gt;0&lt;/code&gt; から &lt;code&gt;0x10FFFF&lt;/code&gt; に一致していました。）</target>
        </trans-unit>
        <trans-unit id="74416e05e81083925dbb5ceee8b9f9eabc0d1420" translate="yes" xml:space="preserve">
          <source>There is one exception to this rule:</source>
          <target state="translated">このルールには一つの例外があります。</target>
        </trans-unit>
        <trans-unit id="aa93104b268b1c94a90858506e09be1c5b4335fe" translate="yes" xml:space="preserve">
          <source>There is one exception, and that is base 2 with negative $x:</source>
          <target state="translated">1つの例外があり、それは負の$xを持つベース2です。</target>
        </trans-unit>
        <trans-unit id="8cbb7256d41af14511a3636bc506131a71d8c56d" translate="yes" xml:space="preserve">
          <source>There is one exception. If you use an alphanumeric character as the delimiter of your pattern (which you probably shouldn't do for readability reasons), you have to escape the delimiter if you want to match it. Perl won't warn then. See also &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;&quot;Gory details of parsing quoted constructs&quot; in perlop&lt;/a&gt;.</source>
          <target state="translated">例外が1つあります。パターンの区切り文字として英数字を使用する場合（読みやすさの理由からおそらく使用すべきではありません）、区切り文字と一致させるには、区切り文字をエスケープする必要があります。その場合、Perlは警告しません。&lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;perlopの「引用された構成の解析のGoryの詳細」&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="cfa0a4472a2d7ed2b714a912f015cd1d6e2a650e" translate="yes" xml:space="preserve">
          <source>There is one exception. If you use an alphanumeric character as the delimiter of your pattern (which you probably shouldn't do for readability reasons), you have to escape the delimiter if you want to match it. Perl won't warn then. See also &lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;Gory details of parsing quoted constructs in perlop&lt;/a&gt;.</source>
          <target state="translated">例外が1つあります。英数字をパターンの区切り文字として使用する場合（読みやすさの理由でこれを行うべきではありません）、区切り文字を一致させるには、エスケープする必要があります。Perlは警告しません。&lt;a href=&quot;perlop#Gory-details-of-parsing-quoted-constructs&quot;&gt;perlopで引用された構文の解析に関するGoryの詳細&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="6afd3e4f300e1185505b80a57213e90e8f05b7f4" translate="yes" xml:space="preserve">
          <source>There is one minor difference: if variables are declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; in the initialization section of the &lt;code&gt;for&lt;/code&gt; , the lexical scope of those variables is exactly the &lt;code&gt;for&lt;/code&gt; loop (the body of the loop and the control sections).</source>
          <target state="translated">小さな違いが1つあります。変数が &lt;code&gt;for&lt;/code&gt; の初期化セクションで &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; で宣言されている場合、それらの変数の字句スコープは、まさに &lt;code&gt;for&lt;/code&gt; ループ（ループの本体と制御セクション）です。</target>
        </trans-unit>
        <trans-unit id="9813dc853a6a86bf5a99b935f981b5a1ed789ab3" translate="yes" xml:space="preserve">
          <source>There is one minor difference: if variables are declared with &lt;code&gt;my&lt;/code&gt; in the initialization section of the &lt;code&gt;for&lt;/code&gt;, the lexical scope of those variables is exactly the &lt;code&gt;for&lt;/code&gt; loop (the body of the loop and the control sections).</source>
          <target state="translated">1つのマイナーな差があります：変数はして宣言されている場合は &lt;code&gt;my&lt;/code&gt; の初期化セクションで &lt;code&gt;for&lt;/code&gt; 、これらの変数のレキシカルスコープは、正確である &lt;code&gt;for&lt;/code&gt; ループ（ループ本体と制御部）。</target>
        </trans-unit>
        <trans-unit id="83ea2627da96768f4457b4c193dca3613fbaa7aa" translate="yes" xml:space="preserve">
          <source>There is one small difference between &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; : the former will not affect assignments to variables and the return value of some functions. &lt;code&gt;bigint&lt;/code&gt; truncates these results to integer too:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bigint&lt;/code&gt; の間には小さな違いが1つあります。前者は変数への割り当てや一部の関数の戻り値には影響しません。 &lt;code&gt;bigint&lt;/code&gt; もこれらの結果を整数に切り捨てます。</target>
        </trans-unit>
        <trans-unit id="b8649e02d1e449cfaae6e608c7b04929643e83c2" translate="yes" xml:space="preserve">
          <source>There is one small difference between &lt;code&gt;use integer&lt;/code&gt; and &lt;code&gt;use bigint&lt;/code&gt;: the former will not affect assignments to variables and the return value of some functions. &lt;code&gt;bigint&lt;/code&gt; truncates these results to integer too:</source>
          <target state="translated">間に1つの小さな違いがあり &lt;code&gt;use integer&lt;/code&gt; と &lt;code&gt;use bigint&lt;/code&gt; ：前者は変数といくつかの関数の戻り値に割り当てには影響しません。 &lt;code&gt;bigint&lt;/code&gt; は、これらの結果も整数に切り捨てます。</target>
        </trans-unit>
        <trans-unit id="b84dd6a42f4605e651baa6c6eefa2a08f75e64c2" translate="yes" xml:space="preserve">
          <source>There is one subtle difference between the following statements:</source>
          <target state="translated">次の発言には微妙な違いがあります。</target>
        </trans-unit>
        <trans-unit id="577b4723acc7dc122f5a6c392fd693ead8ac6f77" translate="yes" xml:space="preserve">
          <source>There is one unary operator:</source>
          <target state="translated">単項演算子が1つあります。</target>
        </trans-unit>
        <trans-unit id="d67d211508568f3ee020a0acfadaaf645e5efa24" translate="yes" xml:space="preserve">
          <source>There is only a single &lt;code&gt;%^H&lt;/code&gt; , but arbitrarily many modules that want to use its scoping semantics. To avoid stepping on each other's toes, they need to be sure to use different keys in the hash. It is therefore conventional for a module to use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. After this module-identifying prefix, the rest of the key is entirely up to the module: it may include any characters whatsoever. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; and &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt; . Modules following this convention all play nicely with each other.</source>
          <target state="translated">&lt;code&gt;%^H&lt;/code&gt; は1つしかありませんが、スコープセマンティクスを使用する必要のある多くのモジュールがあります。お互いのつま先を踏まないようにするには、ハッシュで異なるキーを使用する必要があります。したがって、モジュールでは、モジュールの名前（メインパッケージの名前）と「/」文字で始まるキーのみを使用するのが一般的です。このモジュールを識別する接頭辞の後、キーの残りの部分は完全にモジュールに依存します。任意の文字を含めることができます。たとえば、モジュール &lt;code&gt;Foo::Bar&lt;/code&gt; は &lt;code&gt;Foo::Bar/baz&lt;/code&gt; や &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt; などのキーを使用する必要があります。。この規則に従うモジュールはすべて、互いにうまく連携します。</target>
        </trans-unit>
        <trans-unit id="3740e3b8de22c29d0f5b6e37bf6c582521c6e016" translate="yes" xml:space="preserve">
          <source>There is only a single &lt;code&gt;%^H&lt;/code&gt;, but arbitrarily many modules that want to use its scoping semantics. To avoid stepping on each other's toes, they need to be sure to use different keys in the hash. It is therefore conventional for a module to use only keys that begin with the module's name (the name of its main package) and a &quot;/&quot; character. After this module-identifying prefix, the rest of the key is entirely up to the module: it may include any characters whatsoever. For example, a module &lt;code&gt;Foo::Bar&lt;/code&gt; should use keys such as &lt;code&gt;Foo::Bar/baz&lt;/code&gt; and &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt;. Modules following this convention all play nicely with each other.</source>
          <target state="translated">&lt;code&gt;%^H&lt;/code&gt; は1つだけですが、そのスコープセマンティクスを使用するモジュールは任意に多数あります。お互いのつま先を踏まないようにするには、ハッシュで異なるキーを使用する必要があります。したがって、モジュールでは、モジュールの名前（メインパッケージの名前）と「/」文字で始まるキーのみを使用するのが一般的です。このモジュール識別プレフィックスの後、キーの残りの部分は完全にモジュール次第です。任意の文字を含めることができます。たとえば、モジュール &lt;code&gt;Foo::Bar&lt;/code&gt; は、 &lt;code&gt;Foo::Bar/baz&lt;/code&gt; や &lt;code&gt;Foo::Bar/$%/_!&lt;/code&gt; などのキーを使用する必要があります。。この規則に従ったモジュールはすべて、互いにうまく機能します。</target>
        </trans-unit>
        <trans-unit id="22c0c34478d863fe370e8b15b9734da447a63b38" translate="yes" xml:space="preserve">
          <source>There is outline support for co-existence of PerlIO with stdio. Obviously if PerlIO is implemented in terms of stdio there is no problem. However in other cases then mechanisms must exist to create a FILE * which can be passed to library code which is going to use stdio calls.</source>
          <target state="translated">PerlIOとstdioの共存については、概要のサポートがあります。PerlIOがstdioの観点から実装されている場合は問題ありません。しかし、それ以外の場合には、stdio 呼び出しを使用するライブラリコードに渡すことができる FILE*を作成するメカニズムが存在しなければなりません。</target>
        </trans-unit>
        <trans-unit id="a0392addc7a656cb8a34b007fdd104d3df93294e" translate="yes" xml:space="preserve">
          <source>There is some debate as to whether to say &quot;regexp&quot; or &quot;regex&quot;. In this document we will use the term &quot;regex&quot; unless there is a special reason not to, in which case we will explain why.</source>
          <target state="translated">regexp &quot;と言うべきか &quot;regex &quot;と言うべきかについては、いくつかの議論があります。このドキュメントでは、特別な理由がない限り &quot;regex&quot; という用語を使います。</target>
        </trans-unit>
        <trans-unit id="6f838e3edb2d3e6da973960ec694558ee6ce5470" translate="yes" xml:space="preserve">
          <source>There is some problem with the way &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;f&lt;/code&gt; works under threaded Perl, perhaps because of the lexical scoping of &lt;code&gt;@_&lt;/code&gt; . This is a bug in Perl, and until it is resolved, memoized functions will see a slightly different &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; and will perform a little more slowly on threaded perls than unthreaded perls.</source>
          <target state="translated">&lt;code&gt;@_&lt;/code&gt; の字句スコープが原因で、スレッド化されたPerlで &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;f&lt;/code&gt; 機能する方法に問題があります。これはPerlのバグであり、解決されるまで、メモ化された関数はわずかに異なる &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; を参照し、スレッド化されたperlでスレッド化されていないperlよりも少しゆっくり実行します。</target>
        </trans-unit>
        <trans-unit id="2bcd1c67f3d88bee674b646d4ad741c0978c442b" translate="yes" xml:space="preserve">
          <source>There is some problem with the way &lt;code&gt;goto &amp;amp;f&lt;/code&gt; works under threaded Perl, perhaps because of the lexical scoping of &lt;code&gt;@_&lt;/code&gt;. This is a bug in Perl, and until it is resolved, memoized functions will see a slightly different &lt;code&gt;caller()&lt;/code&gt; and will perform a little more slowly on threaded perls than unthreaded perls.</source>
          <target state="translated">スレッド化されたPerlでの &lt;code&gt;goto &amp;amp;f&lt;/code&gt; 動作には、おそらく &lt;code&gt;@_&lt;/code&gt; の字句スコープが原因で問題があります。これはPerlのバグであり、解決されるまで、メモ化された関数はわずかに異なる &lt;code&gt;caller()&lt;/code&gt; を認識し、スレッド化されたperlではスレッド化されていないperlよりも実行速度が少し遅くなります。</target>
        </trans-unit>
        <trans-unit id="25c4c8715915dd906a17ab857892228134a49607" translate="yes" xml:space="preserve">
          <source>There is some whitespace on a seemingly empty line. POD is very sensitive to such things, so this is flagged. &lt;b&gt;vi&lt;/b&gt; users switch on the &lt;b&gt;list&lt;/b&gt; option to avoid this problem.</source>
          <target state="translated">空のように見える行に空白があります。PODはそのようなことに非常に敏感であるため、フラグが立てられています。&lt;b&gt;vi&lt;/b&gt;ユーザーは、この問題を回避するために&lt;b&gt;リスト&lt;/b&gt;オプションをオンにします。</target>
        </trans-unit>
        <trans-unit id="c71483f882bf4da31c0c8d8f1949a4bc637c87a4" translate="yes" xml:space="preserve">
          <source>There is still a big part of the API not supported by</source>
          <target state="translated">がサポートしていない API の大きな部分がまだ存在します。</target>
        </trans-unit>
        <trans-unit id="808a7cbe8640b29d30d1f97308938be9ff6d1171" translate="yes" xml:space="preserve">
          <source>There is still a small theoretical chance that a signal will interrupt the system-level &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; operation before completion. There is also a possibility that some STDIO implementations may call multiple system level &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt;s even if the buffer was empty to start. There may be some systems where this probability is reduced to zero, and this is not a concern when using &lt;code&gt;:perlio&lt;/code&gt; instead of your system's STDIO.</source>
          <target state="translated">信号が完了前にシステムレベルの &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; 操作を中断する可能性は、まだわずかな理論上の可能性があります。また、一部のSTDIO実装は、開始するためにバッファーが空であったとしても、複数のシステムレベルの &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; を呼び出す可能性があります。この確率がゼロになるシステムもあるかもしれませんが、システムのSTDIOの代わりに &lt;code&gt;:perlio&lt;/code&gt; を使用する場合、これは問題ではありません。</target>
        </trans-unit>
        <trans-unit id="0c9adb8b47f26bb800c4b672d40c4761b57cb21d" translate="yes" xml:space="preserve">
          <source>There is still a small theoretical chance that a signal will interrupt the system-level &lt;code&gt;write()&lt;/code&gt; operation before completion. There is also a possibility that some STDIO implementations may call multiple system level &lt;code&gt;write()&lt;/code&gt;s even if the buffer was empty to start. There may be some systems where this probability is reduced to zero, and this is not a concern when using &lt;code&gt;:perlio&lt;/code&gt; instead of your system's STDIO.</source>
          <target state="translated">シグナルが完了する前にシステムレベルの &lt;code&gt;write()&lt;/code&gt; 操作を中断するという理論上の可能性はまだわずかです。一部のSTDIO実装では、開始時にバッファが空であっても、複数のシステムレベルの &lt;code&gt;write()&lt;/code&gt; を呼び出す可能性もあります。この確率がゼロに減少するシステムがいくつかある可能性があります。これは、システムのSTDIOの代わりに &lt;code&gt;:perlio&lt;/code&gt; を使用する場合は問題になりません。</target>
        </trans-unit>
        <trans-unit id="96312d6625c318df54bef83c86f5b35fb95ca06e" translate="yes" xml:space="preserve">
          <source>There is the &quot;next regnode&quot; from a given regnode, a value which is rarely useful except that sometimes it matches up in terms of value with one of the others, and that sometimes the code assumes this to always be so.</source>
          <target state="translated">与えられたノードからの &quot;次のノード &quot;があります。この値は、値の面で他のノードと一致することがあり、コードが常にそうであると仮定していることがありますが、ほとんど有用ではありません。</target>
        </trans-unit>
        <trans-unit id="7b46535959966668b5c0eb95890256b8fd5dc3c4" translate="yes" xml:space="preserve">
          <source>There is the &quot;next regop&quot; from a given regop/regnode. This is the regop physically located after the current one, as determined by the size of the current regop. This is often useful, such as when dumping the structure we use this order to traverse. Sometimes the code assumes that the &quot;next regnode&quot; is the same as the &quot;next regop&quot;, or in other words assumes that the sizeof a given regop type is always going to be one regnode large.</source>
          <target state="translated">与えられたレゴップ/レゴノードから「次のレゴップ」があります。これは、現在のregopのサイズによって決定されるように、物理的に現在のregopの後に位置するregopです。これは、この順序を使ってトラバースする構造体をダンプするときなどに便利です。時々、コードは &quot;次のregnode &quot;が &quot;次のregop &quot;と同じであると仮定していたり、言い換えれば、与えられたregopタイプのサイズが常に1つのregnode大きくなると仮定しています。</target>
        </trans-unit>
        <trans-unit id="e671500d0c7786e7f8681f40410ba60c12dae4fc" translate="yes" xml:space="preserve">
          <source>There is the &quot;regnext&quot; from a given regop. This is the regop which is reached by jumping forward by the value of &lt;code&gt;NEXT_OFF()&lt;/code&gt; , or in a few cases for longer jumps by the &lt;code&gt;arg1&lt;/code&gt; field of the &lt;code&gt;regnode_1&lt;/code&gt; structure. The subroutine &lt;code&gt;regnext()&lt;/code&gt; handles this transparently. This is the logical successor of the node, which in some cases, like that of the &lt;code&gt;BRANCH&lt;/code&gt; regop, has special meaning.</source>
          <target state="translated">特定のレゴップからの「regnext」があります。これは、NEXT_OFF &lt;code&gt;NEXT_OFF()&lt;/code&gt; 値によって前方にジャンプすることで到達する &lt;code&gt;regnode_1&lt;/code&gt; です。まれに、regnode_1構造体の &lt;code&gt;arg1&lt;/code&gt; フィールドによってジャンプが長くなる場合もあります。サブルーチン &lt;code&gt;regnext()&lt;/code&gt; はこれを透過的に処理します。これはノードの論理的な後続ノードであり、 &lt;code&gt;BRANCH&lt;/code&gt; regop のノードのように、特別な意味を持つ場合があります。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
