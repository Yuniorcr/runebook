<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="fb785a40ce237466b61cf74c58f19b12f7daa54a" translate="yes" xml:space="preserve">
          <source>Also note that there's no value for UNITCHECK-blocks. That's because those are run for each compilation unit individually, and therefore is not a global interpreter phase.</source>
          <target state="translated">また、UNITCHECK-blockには値がないことにも注意してください。これは、各コンパイルユニットごとに個別に実行されるため、グローバルインタプリタフェーズではないからです。</target>
        </trans-unit>
        <trans-unit id="8af529a7344d9be72e889a1f3967799ba9dc98d6" translate="yes" xml:space="preserve">
          <source>Also note that these instructions are tailored for installing the module into your system's repository of Perl modules, but you can install modules into any directory you wish. For instance, where I say &lt;code&gt;perl Makefile.PL&lt;/code&gt; , you can substitute &lt;code&gt;perl Makefile.PL
PREFIX=/my/perl_directory&lt;/code&gt; to install the modules into</source>
          <target state="translated">また、これらの手順は、Perlモジュールのシステムのリポジトリにモジュールをインストールするために調整されていますが、モジュールは任意のディレクトリにインストールできます。例えば、私が言うところ &lt;code&gt;perl Makefile.PL&lt;/code&gt; 、あなたは置き換えることができる &lt;code&gt;perl Makefile.PL PREFIX=/my/perl_directory&lt;/code&gt; にモジュールをインストールします</target>
        </trans-unit>
        <trans-unit id="981eced70a1fd7e3f9ca6ea4e94af48969947ff9" translate="yes" xml:space="preserve">
          <source>Also note that these instructions are tailored for installing the module into your system's repository of Perl modules, but you can install modules into any directory you wish. For instance, where I say &lt;code&gt;perl Makefile.PL&lt;/code&gt;, you can substitute &lt;code&gt;perl Makefile.PL PREFIX=/my/perl_directory&lt;/code&gt; to install the modules into</source>
          <target state="translated">また、これらの手順は、モジュールをシステムのPerlモジュールのリポジトリにインストールするように調整されていますが、モジュールは任意のディレクトリにインストールできます。例えば、私が言うところ &lt;code&gt;perl Makefile.PL&lt;/code&gt; 、あなたは置き換えることができる &lt;code&gt;perl Makefile.PL PREFIX=/my/perl_directory&lt;/code&gt; にモジュールをインストールします</target>
        </trans-unit>
        <trans-unit id="736913cda9c361fafb5f7987b822471b70893809" translate="yes" xml:space="preserve">
          <source>Also note that this does not (yet) work with all configurations, it is known to fail with 64-bit versions of GCC.</source>
          <target state="translated">また、これは(まだ)すべての設定では動作しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="1ab79db4a65e3d1bcd26f59f38af2eeb810bbb25" translate="yes" xml:space="preserve">
          <source>Also note that under the current implementation, shared variables use a little more memory and are a little slower than ordinary variables.</source>
          <target state="translated">また、現在の実装では、共有変数は少し多くのメモリを使用し、通常の変数よりも少し遅いことにも注意してください。</target>
        </trans-unit>
        <trans-unit id="df7301891c8738a820a79c945053b0568b895b92" translate="yes" xml:space="preserve">
          <source>Also note that whether enums are implicitly morphable to ints varies between compilers, you might need to (int).</source>
          <target state="translated">また、列挙型が暗黙的にintにモーフィング可能かどうかはコンパイラによって異なるので、(int)が必要になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="3fe91d0953fd134d385ab62185c6773cb118c04f" translate="yes" xml:space="preserve">
          <source>Also note that while the order of the hash elements might be randomized, this &quot;pseudo-ordering&quot; should &lt;b&gt;not&lt;/b&gt; be used for applications like shuffling a list randomly (use &lt;code&gt;List::Util::shuffle()&lt;/code&gt; for that, see &lt;a href=&quot;List::Util&quot;&gt;List::Util&lt;/a&gt;, a standard core module since Perl 5.8.0; or the CPAN module &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt;), or for generating permutations (use e.g. the CPAN modules &lt;code&gt;Algorithm::Permute&lt;/code&gt; or &lt;code&gt;Algorithm::FastPermute&lt;/code&gt;), or for any cryptographic applications.</source>
          <target state="translated">また、ハッシュ要素の順序はランダム化される可能性がありますが、この「疑似順序付け」は、リストをランダムにシャッフルするようなアプリケーションには使用し&lt;b&gt;ない&lt;/b&gt;でください &lt;code&gt;List::Util::shuffle()&lt;/code&gt; そのためには、List :: Util :: shuffle（）を使用してください&lt;a href=&quot;List::Util&quot;&gt;。List:: Utilを&lt;/a&gt;参照してください）。、Perl5.8.0以降の標準コアモジュール;またはCPANモジュール &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt; ）、または順列の生成（たとえば、CPANモジュール &lt;code&gt;Algorithm::Permute&lt;/code&gt; または &lt;code&gt;Algorithm::FastPermute&lt;/code&gt; ）、または任意の暗号化アプリケーション用。</target>
        </trans-unit>
        <trans-unit id="971b7944044758dad02956ec65121b0bd485f6a2" translate="yes" xml:space="preserve">
          <source>Also note that while the order of the hash elements might be randomized, this &quot;pseudo-ordering&quot; should &lt;b&gt;not&lt;/b&gt; be used for applications like shuffling a list randomly (use &lt;code&gt;List::Util::shuffle()&lt;/code&gt; for that, see &lt;a href=&quot;list/util&quot;&gt;List::Util&lt;/a&gt;, a standard core module since Perl 5.8.0; or the CPAN module &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt; ), or for generating permutations (use e.g. the CPAN modules &lt;code&gt;Algorithm::Permute&lt;/code&gt; or &lt;code&gt;Algorithm::FastPermute&lt;/code&gt; ), or for any cryptographic applications.</source>
          <target state="translated">また、ハッシュ要素の順序はランダム化される可能性がありますが、この「疑似順序付け」は、リストをランダムにシャッフルするようなアプリケーションには使用し&lt;b&gt;ない&lt;/b&gt;でください（ &lt;code&gt;List::Util::shuffle()&lt;/code&gt; を使用してください&lt;a href=&quot;list/util&quot;&gt;。List:: Utilを&lt;/a&gt;参照）、Perl 5.8.0以降の標準コアモジュール、またはCPANモジュール &lt;code&gt;Algorithm::Numerical::Shuffle&lt;/code&gt; ）、または順列の生成（CPANモジュール &lt;code&gt;Algorithm::Permute&lt;/code&gt; または &lt;code&gt;Algorithm::FastPermute&lt;/code&gt; ）、または任意の暗号アプリケーション。</target>
        </trans-unit>
        <trans-unit id="1cc898b24b5934f9ecf52c4f2514750c1a887e03" translate="yes" xml:space="preserve">
          <source>Also note that you should set the &lt;code&gt;Efs&lt;/code&gt; option to true if you are working with UTF8 filenames.</source>
          <target state="translated">また、UTF8ファイル名で作業している場合は、 &lt;code&gt;Efs&lt;/code&gt; オプションをtrueに設定する必要があることにも注意してください。</target>
        </trans-unit>
        <trans-unit id="4516f893f396703a765e286979d300545dd3cb43" translate="yes" xml:space="preserve">
          <source>Also note that, for the superuser on the local filesystems, the &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-W&lt;/code&gt; tests always return 1, and &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; return 1 if any execute bit is set in the mode. Scripts run by the superuser may thus need to do a stat() to determine the actual mode of the file, or temporarily set their effective uid to something else.</source>
          <target state="translated">また、ローカルファイルシステムのスーパーユーザーの場合、モードに実行ビットが設定されている場合、 &lt;code&gt;-r&lt;/code&gt; 、 &lt;code&gt;-R&lt;/code&gt; 、 &lt;code&gt;-w&lt;/code&gt; 、および &lt;code&gt;-W&lt;/code&gt; テストは常に1を返し、 &lt;code&gt;-x&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; テストは1を返します。したがって、スーパーユーザーが実行するスクリプトは、stat（）を実行してファイルの実際のモードを判別したり、一時的に有効なuidを別のものに設定したりする必要があります。</target>
        </trans-unit>
        <trans-unit id="63277c7c7b95830e3556168d50e815433213b167" translate="yes" xml:space="preserve">
          <source>Also note that, for the superuser on the local filesystems, the &lt;code&gt;-r&lt;/code&gt; , &lt;code&gt;-R&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , and &lt;code&gt;-W&lt;/code&gt; tests always return 1, and &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; return 1 if any execute bit is set in the mode. Scripts run by the superuser may thus need to do a stat() to determine the actual mode of the file, or temporarily set their effective uid to something else.</source>
          <target state="translated">また、ローカルファイルシステムのスーパーユーザーの場合、モードに実行ビットが設定されている場合、 &lt;code&gt;-r&lt;/code&gt; 、 &lt;code&gt;-R&lt;/code&gt; 、 &lt;code&gt;-w&lt;/code&gt; 、および &lt;code&gt;-W&lt;/code&gt; テストは常に1を返し、 &lt;code&gt;-x&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; テストは1を返します。したがって、スーパーユーザーが実行するスクリプトは、stat（）を実行してファイルの実際のモードを判別したり、一時的に有効なuidを別のものに設定したりする必要があります。</target>
        </trans-unit>
        <trans-unit id="4c12857d50953ae8911fef9be5deb3cb6261b630" translate="yes" xml:space="preserve">
          <source>Also note that, for the superuser on the local filesystems, the &lt;code&gt;-r&lt;/code&gt;, &lt;code&gt;-R&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, and &lt;code&gt;-W&lt;/code&gt; tests always return 1, and &lt;code&gt;-x&lt;/code&gt; and &lt;code&gt;-X&lt;/code&gt; return 1 if any execute bit is set in the mode. Scripts run by the superuser may thus need to do a &lt;a href=&quot;#stat-FILEHANDLE&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; to determine the actual mode of the file, or temporarily set their effective uid to something else.</source>
          <target state="translated">また、ローカルファイルシステムのスーパーユーザーの場合、モードで実行ビットが設定されている場合、 &lt;code&gt;-r&lt;/code&gt; 、 &lt;code&gt;-R&lt;/code&gt; 、 &lt;code&gt;-w&lt;/code&gt; 、および &lt;code&gt;-W&lt;/code&gt; テストは常に1を返し、 &lt;code&gt;-x&lt;/code&gt; および &lt;code&gt;-X&lt;/code&gt; は1を返すことに注意してください。したがって、スーパーユーザーによって実行されるスクリプトは、ファイルの実際のモードを判別するために&lt;a href=&quot;#stat-FILEHANDLE&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;を実行するか、一時的に有効なuidを別のものに設定する必要がある場合があります。</target>
        </trans-unit>
        <trans-unit id="0d0223c3f3274398a55ed8725b06675a40efd8ef" translate="yes" xml:space="preserve">
          <source>Also note that:</source>
          <target state="translated">また、そのことにも注意してください。</target>
        </trans-unit>
        <trans-unit id="87da44cc851ca2f3b8c127c8f7ddc08e6bd458e4" translate="yes" xml:space="preserve">
          <source>Also note, that because all ASCII characters are UTF-8 invariant (meaning they have the exact same representation (always a single byte) whether encoded in UTF-8 or not), &lt;code&gt;isASCII&lt;/code&gt; will give the correct results when called with any byte in any string encoded or not in UTF-8. And similarly &lt;code&gt;isASCII_utf8&lt;/code&gt; will work properly on any string encoded or not in UTF-8.</source>
          <target state="translated">また、すべてのASCII文字はUTF-8不変（UTF-8でエンコードされているかどうかにかかわらず、まったく同じ表現（常に1バイト）であることを意味する）であるため、 &lt;code&gt;isASCII&lt;/code&gt; は、任意のバイトで呼び出されたときに正しい結果を提供しますUTF-8でエンコードされた、またはエンコードされていない文字列。そして、同様に &lt;code&gt;isASCII_utf8&lt;/code&gt; は UTF-8でエンコードされたかどうか、任意の文字列に正しく動作します。</target>
        </trans-unit>
        <trans-unit id="523b244d1d9de0ba3f1938d9267c5634264d7182" translate="yes" xml:space="preserve">
          <source>Also notice that no matter what arguments you pass to perl_parse(), PERL_SYS_INIT3() must be invoked on the C main() argc, argv and env and only once.</source>
          <target state="translated">また、perl_parse()にどんな引数を渡しても、PERL_SYS_INIT3()はCのmain()argc,argv,envで一度だけ呼び出されなければならないことにも注意してください。</target>
        </trans-unit>
        <trans-unit id="84e807ea22d37e9fcac5bf336f329420c5d937c0" translate="yes" xml:space="preserve">
          <source>Also of use is &lt;a href=&quot;File::Basename&quot;&gt;&lt;code&gt;File::Basename&lt;/code&gt;&lt;/a&gt; from the standard distribution, which splits a pathname into pieces (base filename, full path to directory, and file suffix).</source>
          <target state="translated">また、標準ディストリビューションの&lt;a href=&quot;File::Basename&quot;&gt; &lt;code&gt;File::Basename&lt;/code&gt; &lt;/a&gt;も使用できます。これは、パス名を断片（ベースファイル名、ディレクトリへのフルパス、およびファイルサフィックス）に分割します。</target>
        </trans-unit>
        <trans-unit id="e0b1e0d1886e4ff75f5ec5ef85846c4c02e181e1" translate="yes" xml:space="preserve">
          <source>Also of use is &lt;code&gt;File::Basename&lt;/code&gt; from the standard distribution, which splits a pathname into pieces (base filename, full path to directory, and file suffix).</source>
          <target state="translated">また、標準配布の &lt;code&gt;File::Basename&lt;/code&gt; も使用されます。これは、パス名を分割します（ベースファイル名、ディレクトリへのフルパス、およびファイルサフィックス）。</target>
        </trans-unit>
        <trans-unit id="5f72eee36e825db36f597f9decf9236b17c32472" translate="yes" xml:space="preserve">
          <source>Also parsed as terms are the &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; constructs, as well as subroutine and method calls, and the anonymous constructors &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt; .</source>
          <target state="translated">また、用語として解析されるのは、 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 構成、サブルーチンとメソッドの呼び出し、および匿名コンストラクタ &lt;code&gt;[]&lt;/code&gt; と &lt;code&gt;{}&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="76e4187069aa3cdfe5b15fb66a75e8d762b8a3c7" translate="yes" xml:space="preserve">
          <source>Also parsed as terms are the &lt;code&gt;do {}&lt;/code&gt; and &lt;code&gt;eval {}&lt;/code&gt; constructs, as well as subroutine and method calls, and the anonymous constructors &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt;.</source>
          <target state="translated">また、用語として解析されるのは、 &lt;code&gt;do {}&lt;/code&gt; および &lt;code&gt;eval {}&lt;/code&gt; 構文、サブルーチンおよびメソッド呼び出し、匿名コンストラクター &lt;code&gt;[]&lt;/code&gt; および &lt;code&gt;{}&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4ab49029f03642de1877e97fc5e4ccdaa8f4d8b8" translate="yes" xml:space="preserve">
          <source>Also read the &lt;a href=&quot;#DESCRIPTION&quot;&gt;&quot;DESCRIPTION&quot;&lt;/a&gt; section above, about how &lt;code&gt;Carp&lt;/code&gt; decides where the error is reported from.</source>
          <target state="translated">エラーの報告元を &lt;code&gt;Carp&lt;/code&gt; がどのように決定するかについては、上記の&lt;a href=&quot;#DESCRIPTION&quot;&gt;「説明」&lt;/a&gt;セクションもお読みください。</target>
        </trans-unit>
        <trans-unit id="a2bae6f7ee0c691e590b07608d4c9653431dd798" translate="yes" xml:space="preserve">
          <source>Also read the &lt;a href=&quot;#DESCRIPTION&quot;&gt;DESCRIPTION&lt;/a&gt; section above, about how &lt;code&gt;Carp&lt;/code&gt; decides where the error is reported from.</source>
          <target state="translated">&lt;code&gt;Carp&lt;/code&gt; がエラーの報告元を決定する方法については、上記の&lt;a href=&quot;#DESCRIPTION&quot;&gt;説明&lt;/a&gt;セクションも参照してください。</target>
        </trans-unit>
        <trans-unit id="6e8426be1042a9c74b01dabfc6cf09d489acf3c6" translate="yes" xml:space="preserve">
          <source>Also referred to as &quot;Dotted-Integer&quot;, these contains more than one decimal point and may have an optional embedded underscore, see &lt;a href=&quot;#Dotted-Decimal-Versions&quot;&gt;&quot;Dotted-Decimal Versions&quot;&lt;/a&gt;. This is what is commonly used in most open source software as the &quot;external&quot; version (the one used as part of the tag or tarfile name). A leading 'v' character is now required and will warn if it missing.</source>
          <target state="translated">「ドット付き整数」とも呼ばれ、これらには複数の小数点が含まれ、オプションの埋め込みアンダースコアが含まれる場合があります。&lt;a href=&quot;#Dotted-Decimal-Versions&quot;&gt;「ドット付き10進バージョン」を&lt;/a&gt;参照してください。これは、ほとんどのオープンソースソフトウェアで「外部」バージョン（タグまたはtarfile名の一部として使用されるバージョン）として一般的に使用されているものです。先頭の「v」文字が必要になり、欠落している場合は警告が表示されます。</target>
        </trans-unit>
        <trans-unit id="8e594eb3334af2971f8b461e9ae7e0b95244811c" translate="yes" xml:space="preserve">
          <source>Also remember that &quot;|&quot; is interpreted as a literal within square brackets, so if you write &lt;code&gt;[fee|fie|foe]&lt;/code&gt; you're really only matching &lt;code&gt;[feio|]&lt;/code&gt; .</source>
          <target state="translated">また、 &quot;|&quot; は角括弧内のリテラルとして解釈されるため、 &lt;code&gt;[fee|fie|foe]&lt;/code&gt; と記述した場合は、実際には &lt;code&gt;[feio|]&lt;/code&gt; のみ一致します。</target>
        </trans-unit>
        <trans-unit id="2d930463c65b067a74fc5ff7d23d0ccb6261af74" translate="yes" xml:space="preserve">
          <source>Also remember that C doesn't allow you to safely say &lt;code&gt;foo(SvPV(s, len),
len);&lt;/code&gt;. It might work with your compiler, but it won't work for everyone. Break this sort of statement up into separate assignments:</source>
          <target state="translated">また、Cでは &lt;code&gt;foo(SvPV(s, len), len);&lt;/code&gt; と安全に言うことができないことも覚えておいてください。。それはあなたのコンパイラで動作するかもしれませんが、誰にとっても動作するとは限りません。この種類のステートメントを個別の割り当てに分割します。</target>
        </trans-unit>
        <trans-unit id="f44fcd946ba2f23c70977904fbf45aba4b6fafca" translate="yes" xml:space="preserve">
          <source>Also remember that the &lt;code&gt;%p&lt;/code&gt; format really does require a void pointer:</source>
          <target state="translated">また、 &lt;code&gt;%p&lt;/code&gt; 形式にはvoidポインターが実際に必要であることも覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="d484e6b6d31da17dc2ff01d2d2dda31cda9e2d99" translate="yes" xml:space="preserve">
          <source>Also remember: If the META file contains a provides field, you shouldn't be indexing anything in the first place - just use that.</source>
          <target state="translated">また、METAファイルにprovidesフィールドが含まれている場合は、そもそも何もインデックスを作成すべきではありません。</target>
        </trans-unit>
        <trans-unit id="058a190dd3d11e3f9bf93212c115f6265d98bac0" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; or &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;または&lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="f380eae13c59641be526fa28a59640fd146bd59e" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;perlfunc#binmode&quot;&gt;&quot;binmode&quot; in perlfunc&lt;/a&gt; or &lt;a href=&quot;perlopentut&quot;&gt;perlopentut&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;perlfunc#binmode&quot;&gt;perlfunc&lt;/a&gt;または&lt;a href=&quot;perlopentut&quot;&gt;perlopentutの&lt;/a&gt;「binmode」も参照してください。</target>
        </trans-unit>
        <trans-unit id="b821601b2c44fa646b454cc4c61309ada267db9f" translate="yes" xml:space="preserve">
          <source>Also see the &lt;b&gt;--lquote&lt;/b&gt; and &lt;b&gt;--rquote&lt;/b&gt; options, which can be used to set the left and right quotes independently. If both &lt;b&gt;--quotes&lt;/b&gt; and one of the other options is set, &lt;b&gt;--lquote&lt;/b&gt; or &lt;b&gt;--rquote&lt;/b&gt; overrides &lt;b&gt;--quotes&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;--lquote&lt;/b&gt;および&lt;b&gt;--rquote&lt;/b&gt;オプションも参照してください。これらは、左右の引用符を個別に設定するために使用できます。両方の場合&lt;b&gt;--quotes&lt;/b&gt;およびその他のオプションのいずれかが、設定されている&lt;b&gt;--lquote&lt;/b&gt;または&lt;b&gt;--rquote&lt;/b&gt;オーバーライド&lt;b&gt;--quotes&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="124ca3ad4251372cd630b0c4f1d026a6e1bb631a" translate="yes" xml:space="preserve">
          <source>Also see the &lt;b&gt;--quotes&lt;/b&gt; option, which can be used to set both quotes at once. If both &lt;b&gt;--quotes&lt;/b&gt; and one of the other options is set, &lt;b&gt;--lquote&lt;/b&gt; or &lt;b&gt;--rquote&lt;/b&gt; overrides &lt;b&gt;--quotes&lt;/b&gt;.</source>
          <target state="translated">両方の引用符を一度に設定するために使用できる&lt;b&gt;--quotes&lt;/b&gt;オプションも参照してください。両方の場合&lt;b&gt;--quotes&lt;/b&gt;およびその他のオプションのいずれかが、設定されている&lt;b&gt;--lquote&lt;/b&gt;または&lt;b&gt;--rquote&lt;/b&gt;オーバーライド&lt;b&gt;--quotes&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="14f14f1236967cfa8b858394733973952439e548" translate="yes" xml:space="preserve">
          <source>Also see the &lt;code&gt;lquote&lt;/code&gt; and &lt;code&gt;rquote&lt;/code&gt; options, which can be used to set the left and right quotes independently. If both &lt;code&gt;quotes&lt;/code&gt; and one of the other options is set, &lt;code&gt;lquote&lt;/code&gt; or &lt;code&gt;rquote&lt;/code&gt; overrides &lt;code&gt;quotes&lt;/code&gt;.</source>
          <target state="translated">左右の引用符を個別に設定するために使用できる &lt;code&gt;lquote&lt;/code&gt; および &lt;code&gt;rquote&lt;/code&gt; オプションも参照してください。両方の場合は &lt;code&gt;quotes&lt;/code&gt; や他のいずれかのオプションが設定されている、 &lt;code&gt;lquote&lt;/code&gt; または &lt;code&gt;rquote&lt;/code&gt; オーバーライドの &lt;code&gt;quotes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b43f69db8fdd0609b53e771f0c648e36f1cca6c0" translate="yes" xml:space="preserve">
          <source>Also see the &lt;code&gt;quotes&lt;/code&gt; option, which can be used to set both quotes at once. If both &lt;code&gt;quotes&lt;/code&gt; and one of the other options is set, &lt;code&gt;lquote&lt;/code&gt; or &lt;code&gt;rquote&lt;/code&gt; overrides &lt;code&gt;quotes&lt;/code&gt;.</source>
          <target state="translated">両方の見積もりを一度に設定するために使用できる &lt;code&gt;quotes&lt;/code&gt; オプションも参照してください。両方の場合は &lt;code&gt;quotes&lt;/code&gt; や他のいずれかのオプションが設定されている、 &lt;code&gt;lquote&lt;/code&gt; または &lt;code&gt;rquote&lt;/code&gt; オーバーライドの &lt;code&gt;quotes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa855f9ba4cde9a2842bd3fc97af3045ad2e00c0" translate="yes" xml:space="preserve">
          <source>Also see:</source>
          <target state="translated">も参照してください。</target>
        </trans-unit>
        <trans-unit id="e8ab5cecbe34d47a3838306a541fd22a09e183f0" translate="yes" xml:space="preserve">
          <source>Also starting in v5.8.1, the &lt;code&gt;DATA&lt;/code&gt; pseudo-filehandle is translated from the encoding into UTF-8.</source>
          <target state="translated">また、v5.8.1から、 &lt;code&gt;DATA&lt;/code&gt; 疑似ファイルハンドルはエンコーディングからUTF-8に変換されます。</target>
        </trans-unit>
        <trans-unit id="ab76f7fb0dafb2fd9b645c8d2859052a429122ce" translate="yes" xml:space="preserve">
          <source>Also study &lt;a href=&quot;perlport&quot;&gt;perlport&lt;/a&gt; carefully to avoid any bad assumptions about the operating system, filesystems, character set, and so forth.</source>
          <target state="translated">また、オペレーティングシステム、ファイルシステム、文字セットなどに関する&lt;a href=&quot;perlport&quot;&gt;誤った&lt;/a&gt;想定を避けるために、perlportを注意深く調べてください。</target>
        </trans-unit>
        <trans-unit id="2e87f20f7d97b568a4954fba96e48f292ed18abb" translate="yes" xml:space="preserve">
          <source>Also unchanged is the quoting of non-UTF-8 strings when outside the scope of a &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;use feature 'unicode_strings'&lt;/code&gt;&lt;/a&gt;, which is to quote all characters in the upper Latin1 range. This provides complete backwards compatibility for old programs which do not use Unicode. (Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically enabled within the scope of a &lt;code&gt;use v5.12&lt;/code&gt; or greater.)</source>
          <target state="translated">また、&lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt; &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; &lt;/a&gt;の範囲外の場合の非UTF-8文字列の引用も変更されていません。これは、Latin1の上位範囲のすべての文字を引用することです。これにより、Unicodeを使用しない古いプログラムに完全な下位互換性が提供されます。（ &lt;code&gt;unicode_strings&lt;/code&gt; は、 &lt;code&gt;use v5.12&lt;/code&gt; 以降の使用範囲内で自動的に有効になることに注意してください。）</target>
        </trans-unit>
        <trans-unit id="330eeffd40ec44ea764cda155371e57d6de9d850" translate="yes" xml:space="preserve">
          <source>Also unchanged is the quoting of non-UTF-8 strings when outside the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; , which is to quote all characters in the upper Latin1 range. This provides complete backwards compatibility for old programs which do not use Unicode. (Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically enabled within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; or greater.)</source>
          <target state="translated">また、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; の範囲外の場合、UTF-8以外の文字列の引用は変更されません。これは、Latin1の上位範囲のすべての文字を引用することです。これにより、Unicodeを使用しない古いプログラムに完全な下位互換性が提供されます。（ &lt;code&gt;unicode_strings&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; 以降の&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;の範囲内で自動的に有効になることに注意してください。）</target>
        </trans-unit>
        <trans-unit id="d897a47e8affb873fdb6ab1911f0d831b446c551" translate="yes" xml:space="preserve">
          <source>Also unchanged is the quoting of non-UTF-8 strings when outside the scope of a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; , which is to quote all characters in the upper Latin1 range. This provides complete backwards compatibility for old programs which do not use Unicode. (Note that &lt;code&gt;unicode_strings&lt;/code&gt; is automatically enabled within the scope of a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; or greater.)</source>
          <target state="translated">また、 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; の範囲外の場合、UTF-8以外の文字列の引用は変更されません。これは、Latin1の上位範囲のすべての文字を引用することです。これにより、Unicodeを使用しない古いプログラムに完全な下位互換性が提供されます。（ &lt;code&gt;unicode_strings&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; v5.12&lt;/code&gt; 以降の&lt;a href=&quot;use&quot;&gt;使用&lt;/a&gt;の範囲内で自動的に有効になることに注意してください。）</target>
        </trans-unit>
        <trans-unit id="77e4638580e542bd7efbc6ad1037c219e33a2a27" translate="yes" xml:space="preserve">
          <source>Also unlike &lt;code&gt;fileparse()&lt;/code&gt; , &lt;code&gt;dirname()&lt;/code&gt; does not include a trailing slash on its returned path.</source>
          <target state="translated">また、 &lt;code&gt;fileparse()&lt;/code&gt; とは異なり、 &lt;code&gt;dirname()&lt;/code&gt; は返されたパスに末尾のスラッシュを含めません。</target>
        </trans-unit>
        <trans-unit id="26303c82ac6b3a7fa556573e39f86a09e33051c1" translate="yes" xml:space="preserve">
          <source>Also unlike &lt;code&gt;fileparse()&lt;/code&gt;, &lt;code&gt;dirname()&lt;/code&gt; does not include a trailing slash on its returned path.</source>
          <target state="translated">また、 &lt;code&gt;fileparse()&lt;/code&gt; とは異なり、 &lt;code&gt;dirname()&lt;/code&gt; は、返されたパスに末尾のスラッシュを含めません。</target>
        </trans-unit>
        <trans-unit id="3cf4e79f0d2cc479a41a6179c877f4a73d453199" translate="yes" xml:space="preserve">
          <source>Also when working on Perl programs on VMS, if you need a syntax in a specific operating system format, then you need either to check the appropriate DECC$ feature logical, or call a conversion routine to force it to that format.</source>
          <target state="translated">また、VMS上のPerlプログラムで作業する際に、特定のオペレーティングシステム形式の構文が必要な場合は、適切なDECC$機能論理をチェックするか、その形式に強制的に変換するための変換ルーチンを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="5fc47794ba1a865aaaa0f149000e05b513e4f015" translate="yes" xml:space="preserve">
          <source>Also you have to be careful when using &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a value in AVs or HVs (see &lt;a href=&quot;#AVs%2C-HVs-and-undefined-values&quot;&gt;&quot;AVs, HVs and undefined values&quot;&lt;/a&gt;).</source>
          <target state="translated">また、 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; をAVまたはHVの値として使用する場合は注意が必要です（&lt;a href=&quot;#AVs%2C-HVs-and-undefined-values&quot;&gt;「AV、HV、および未定義の値」を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="b4a91fa72735b293f0702212cc8b8ff7dd3fc1bc" translate="yes" xml:space="preserve">
          <source>Also you have to be careful when using &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; as a value in AVs or HVs (see &lt;a href=&quot;#AVs%2c-HVs-and-undefined-values&quot;&gt;AVs, HVs and undefined values&lt;/a&gt;).</source>
          <target state="translated">また、 &lt;code&gt;&amp;amp;PL_sv_undef&lt;/code&gt; をAVまたはHVの値として使用する場合は注意が必要です（&lt;a href=&quot;#AVs%2c-HVs-and-undefined-values&quot;&gt;AV、HV、および未定義の値を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="88b9515cdbcd45bb30a5ed0507a9f79663403c03" translate="yes" xml:space="preserve">
          <source>Also, &lt;b&gt;in Perl 5.8.x and earlier&lt;/b&gt;, this pragma uses pseudo-hashes, the effect being that you can have objects with named fields which are as compact and as fast arrays to access, as long as the objects are accessed through properly typed variables.</source>
          <target state="translated">また、&lt;b&gt;Perl 5.8.x以前では&lt;/b&gt;、このプラグマは疑似ハッシュを使用しており、オブジェクトが適切に型指定された変数を通じてアクセスされる限り、コンパクトで高速な配列である名前付きフィールドを持つオブジェクトにアクセスできます。 。</target>
        </trans-unit>
        <trans-unit id="67b0ddab77dcdca452f298cae2c04c86ed3d38be" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; yields &lt;code&gt; chr(28) . &quot;&lt;i&gt;X&lt;/i&gt;&quot;&lt;/code&gt; for any</source>
          <target state="translated">また、 &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; は &lt;code&gt; chr(28) . &quot;&lt;i&gt;X&lt;/i&gt;&quot;&lt;/code&gt; 生成します。「&lt;i&gt;X&lt;/i&gt;」いずれかのために</target>
        </trans-unit>
        <trans-unit id="d7b7987422ffa4fcf0f2ef8eb8b0440e2263954b" translate="yes" xml:space="preserve">
          <source>Also, Case_Folding is accessible through the &lt;code&gt;/i&lt;/code&gt; modifier in regular expressions, the &lt;code&gt;\F&lt;/code&gt; transliteration escape, and the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">また、Case_Foldingには、正規表現の &lt;code&gt;/i&lt;/code&gt; 修飾子、 &lt;code&gt;\F&lt;/code&gt; 文字変換エスケープ、および &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 演算子を使用してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="d028de5400e80b7bddfc22d550144658f5c96f35" translate="yes" xml:space="preserve">
          <source>Also, Case_Folding is accessible through the &lt;code&gt;/i&lt;/code&gt; modifier in regular expressions, the &lt;code&gt;\F&lt;/code&gt; transliteration escape, and the &lt;code&gt;&lt;a href=&quot;perlfunc#fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; operator.</source>
          <target state="translated">また、Case_Foldingには、正規表現の &lt;code&gt;/i&lt;/code&gt; 修飾子、 &lt;code&gt;\F&lt;/code&gt; 音訳エスケープ、および &lt;code&gt;&lt;a href=&quot;perlfunc#fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 演算子を使用してアクセスできます。</target>
        </trans-unit>
        <trans-unit id="329290910e0fbb3b491e01928584618de2f21b4e" translate="yes" xml:space="preserve">
          <source>Also, Configure might abort with</source>
          <target state="translated">また、Configure は</target>
        </trans-unit>
        <trans-unit id="dbf6f9732bd6d02a3c14e683c3aa4b4c3c151f41" translate="yes" xml:space="preserve">
          <source>Also, a &lt;code&gt;&quot;r&quot;&lt;/code&gt; and/or &lt;code&gt;&quot;w&quot;&lt;/code&gt; in &lt;code&gt;$sMode&lt;/code&gt; is used to decide how the file descriptor is converted into a Perl file handle, even though this doesn't appear to make a difference. One of the following is used:</source>
          <target state="translated">また、 &lt;code&gt;$sMode&lt;/code&gt; &lt;code&gt;&quot;r&quot;&lt;/code&gt; や &lt;code&gt;&quot;w&quot;&lt;/code&gt; は、ファイル記述子をPerlファイルハンドルに変換する方法を決定するために使用されますが、これは違いがないように見えます。次のいずれかが使用されます。</target>
        </trans-unit>
        <trans-unit id="1e804a10723cc82e329f560a2f2a4e122d8ad225" translate="yes" xml:space="preserve">
          <source>Also, a backslash followed by two or three octal digits is considered an octal number.</source>
          <target state="translated">また、バックスラッシュの後に8進数の2桁または3桁が続くものは、8進数とみなされます。</target>
        </trans-unit>
        <trans-unit id="931d2aa4d5ca7dba171a5dba8982f8a76fb7815e" translate="yes" xml:space="preserve">
          <source>Also, as of Perl 5.30, delimiters which are unassigned code points but that may someday become assigned are prohibited. Otherwise, code that works today would fail to compile if the currently unassigned delimiter ends up being something that isn't a stand-alone grapheme. Because Unicode is never going to assign &lt;a href=&quot;perlunicode#Noncharacter-code-points&quot;&gt;non-character code points&lt;/a&gt;, nor &lt;a href=&quot;perlunicode#Beyond-Unicode-code-points&quot;&gt;code points that are above the legal Unicode maximum&lt;/a&gt;, those can be delimiters.</source>
          <target state="translated">また、Perl 5.30以降、割り当てられていないコードポイントであるが、いつか割り当てられる可能性のある区切り文字は禁止されています。そうしないと、現在割り当てられていない区切り文字がスタンドアロンの書記素ではないものになってしまうと、今日機能するコードはコンパイルに失敗します。 Unicodeは、&lt;a href=&quot;perlunicode#Noncharacter-code-points&quot;&gt;文字以外のコードポイント&lt;/a&gt;も&lt;a href=&quot;perlunicode#Beyond-Unicode-code-points&quot;&gt;、Unicodeの有効な最大値を超えるコードポイント&lt;/a&gt;も割り当てないため、区切り文字にすることができます。</target>
        </trans-unit>
        <trans-unit id="6cc421c7386da7b14eefaf275d4a113f5c542cb3" translate="yes" xml:space="preserve">
          <source>Also, both these methods currently allow only single characters to be named. To name a sequence of characters, use a &lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;custom translator&lt;/a&gt; (described below).</source>
          <target state="translated">また、これらの両方の方法では現在、単一の文字のみに名前を付けることができます。一連の文字に名前を付けるには、&lt;a href=&quot;#CUSTOM-TRANSLATORS&quot;&gt;カスタムトランスレータ&lt;/a&gt;（以下で説明）を使用します。</target>
        </trans-unit>
        <trans-unit id="0b19a92a5a63a3defc0247ff7123f75e1b423945" translate="yes" xml:space="preserve">
          <source>Also, calling &amp;amp;$coderef($lh, ...parameters...) can throw any sort of exception (if, say, code in that sub tries to divide by zero). But a very common exception occurs when you have Bracket Notation text that says to call a method &quot;foo&quot;, but there is no such method. (E.g., &quot;You have [qua&lt;b&gt;tn&lt;/b&gt;,_1,ball].&quot; will throw an exception on trying to call $lh-&amp;gt;qua&lt;b&gt;tn&lt;/b&gt;($_[1],'ball') -- you presumably meant &quot;quant&quot;.) &lt;code&gt;maketext&lt;/code&gt; catches these exceptions, but only to make the error message more readable, at which point it rethrows the exception.</source>
          <target state="translated">また、＆$ coderef（$ lh、... parameters ...）を呼び出すと、あらゆる種類の例外がスローされる可能性があります（たとえば、そのサブのコードがゼロで除算しようとした場合）。ただし、メソッド「foo」を呼び出すように指示するブラケット表記テキストがある場合に、非常に一般的な例外が発生しますが、そのようなメソッドはありません。 （たとえば、「あなたは[qua &lt;b&gt;tn&lt;/b&gt;、_1、ball]を持っています。」は$ lh-&amp;gt; qua &lt;b&gt;tn&lt;/b&gt;（$ _ [1]、 'ball'）を呼び出そうとすると例外をスローします-おそらく「量」を意味していました。 ） &lt;code&gt;maketext&lt;/code&gt; はこれらの例外をキャッチしますが、エラーメッセージを読みやすくするためだけです。その時点で例外が再スローされます。</target>
        </trans-unit>
        <trans-unit id="bd6593efc170267903ffe758130a7c9bc58d5233" translate="yes" xml:space="preserve">
          <source>Also, entries like</source>
          <target state="translated">また、以下のようなエントリーもあります。</target>
        </trans-unit>
        <trans-unit id="74a420b208a6c382bb28f75840a5f1acef599188" translate="yes" xml:space="preserve">
          <source>Also, every C program that uses Perl must link in the</source>
          <target state="translated">また、Perl を使用するすべての C プログラムは</target>
        </trans-unit>
        <trans-unit id="34500a88731ba3291ee1333607a6b7ca5f090a54" translate="yes" xml:space="preserve">
          <source>Also, feel free to play with experimental features. Run</source>
          <target state="translated">また、実験的な機能で気軽に遊んでみてください。走らせる</target>
        </trans-unit>
        <trans-unit id="efa6c1b4904cf64e5362ea949feda8f167d890cd" translate="yes" xml:space="preserve">
          <source>Also, for a somewhat finer-grained set of characters that are in programming language identifiers beyond the ASCII range, you may wish to instead use the more customized &lt;a href=&quot;#Unicode-Properties&quot;&gt;&quot;Unicode Properties&quot;&lt;/a&gt;, &lt;code&gt;\p{ID_Start}&lt;/code&gt;, &lt;code&gt;\p{ID_Continue}&lt;/code&gt;, &lt;code&gt;\p{XID_Start}&lt;/code&gt;, and &lt;code&gt;\p{XID_Continue}&lt;/code&gt;. See &lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31&lt;/a&gt;.</source>
          <target state="translated">また、ASCII範囲を超えるプログラミング言語識別子に含まれる、ややきめ細かい文字セットの場合は、代わりに、よりカスタマイズされた&lt;a href=&quot;#Unicode-Properties&quot;&gt;「Unicodeプロパティ」&lt;/a&gt;、 &lt;code&gt;\p{ID_Start}&lt;/code&gt; 、 &lt;code&gt;\p{ID_Continue}&lt;/code&gt; 、 &lt;code&gt;\p{XID_Start}&lt;/code&gt; 使用することをお勧めします。{XID_Start}、および &lt;code&gt;\p{XID_Continue}&lt;/code&gt; 。&lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7b8f99a26ea97ae4edab854723c19d8a2e3a7a2e" translate="yes" xml:space="preserve">
          <source>Also, for a somewhat finer-grained set of characters that are in programming language identifiers beyond the ASCII range, you may wish to instead use the more customized &lt;a href=&quot;#Unicode-Properties&quot;&gt;Unicode Properties&lt;/a&gt;, &lt;code&gt;\p{ID_Start}&lt;/code&gt; , &lt;code&gt;\p{ID_Continue}&lt;/code&gt; , &lt;code&gt;\p{XID_Start}&lt;/code&gt; , and &lt;code&gt;\p{XID_Continue}&lt;/code&gt; . See &lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31&lt;/a&gt;.</source>
          <target state="translated">また、ASCIIの範囲を超えてプログラミング言語識別子に含まれるやや細かい文字のセットの場合は、代わりに、よりカスタマイズされた&lt;a href=&quot;#Unicode-Properties&quot;&gt;Unicodeプロパティ&lt;/a&gt;、 &lt;code&gt;\p{ID_Start}&lt;/code&gt; 、 &lt;code&gt;\p{ID_Continue}&lt;/code&gt; 、 &lt;code&gt;\p{XID_Start}&lt;/code&gt; 、および &lt;code&gt;\p{XID_Continue}&lt;/code&gt; 。&lt;a href=&quot;http://unicode.org/reports/tr31&quot;&gt;http://unicode.org/reports/tr31を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ccef320717b4d17e6eccfe71944895dfdb94c8a6" translate="yes" xml:space="preserve">
          <source>Also, having valid values as keys becomes very useful if you set up an _AUTO lexicon. _AUTO lexicons are discussed in a later section.</source>
          <target state="translated">また、_AUTOレキシコンを設定した場合、有効な値をキーとして持つことが非常に便利になります。AUTO レキシコンについては後述します。</target>
        </trans-unit>
        <trans-unit id="57c4e07e0cc219d38dd06e6e1bcf0b1ea8e52540" translate="yes" xml:space="preserve">
          <source>Also, if the SV passed to &lt;code&gt;mg_find&lt;/code&gt; or &lt;code&gt;mg_findext&lt;/code&gt; is not of type SVt_PVMG, Perl may core dump.</source>
          <target state="translated">また、 &lt;code&gt;mg_find&lt;/code&gt; または &lt;code&gt;mg_findext&lt;/code&gt; に渡されたSV のタイプがSVt_PVMGでない場合、Perlがコアダンプすることがあります。</target>
        </trans-unit>
        <trans-unit id="a715fbfabba33c1ab0f07edc90c111741da66e2f" translate="yes" xml:space="preserve">
          <source>Also, in binary properties, 'Yes', 'T', and 'True' are all synonyms for 'Y'. And 'No', 'F', and 'False' are all synonyms for 'N'. The table shows 'Y*' and 'N*' to indicate this, and doesn't have separate entries for the other possibilities. Note that not all properties which have values 'Yes' and 'No' are binary, and they have all their values spelled out without using this wild card, and a &lt;code&gt;NOT&lt;/code&gt; clause in their description that highlights their not being binary. These also require the compound form to match them, whereas true binary properties have both single and compound forms available.</source>
          <target state="translated">また、バイナリプロパティでは、「Yes」、「T」、および「True」はすべて「Y」の同義語です。また、「いいえ」、「F」、および「False」はすべて「N」の同義語です。この表は、これを示すために「Y *」と「N *」を示しており、他の可能性の個別のエントリはありません。 「はい」と「いいえ」の値を持つすべてのプロパティがバイナリであるとは限らず、このワイルドカードを使用せずにすべての値がスペルアウトされ、バイナリではないことを強調する説明に &lt;code&gt;NOT&lt;/code&gt; 句があることに注意してください。また、これらは一致する複合フォームを必要としますが、真のバイナリプロパティは単一フォームと複合フォームの両方を利用できます。</target>
        </trans-unit>
        <trans-unit id="a00a976f777c7c9555d5a4f1c975df6f1666beb4" translate="yes" xml:space="preserve">
          <source>Also, in the context of &lt;b&gt;Unicode&lt;/b&gt;, a writing system for a particular language or group of languages, such as Greek, Bengali, or Tengwar.</source>
          <target state="translated">また、&lt;b&gt;Unicode&lt;/b&gt;のコンテキストでは、ギリシャ語、ベンガル語、またはTengwarなどの特定の言語または言語のグループ用の書記体系。</target>
        </trans-unit>
        <trans-unit id="d74824efd3c4979bad6a6f8c4e477bf4cb023fd4" translate="yes" xml:space="preserve">
          <source>Also, it's worth noting that patterns defined this way probably will not be as efficient, as the optimizer is not very clever about handling them.</source>
          <target state="translated">また、このように定義されたパターンは、オプティマイザがそれらを扱うことについてあまり賢くないので、おそらく効率的ではないだろうということにも注目しておきましょう。</target>
        </trans-unit>
        <trans-unit id="487cc7057b2c00a1fbc251ce9c403787bcbb592b" translate="yes" xml:space="preserve">
          <source>Also, lines should not be split within &lt;code&gt;CRLF&lt;/code&gt; (i.e. there is no empty line between &lt;code&gt;\r&lt;/code&gt; and &lt;code&gt;\n&lt;/code&gt; ). For &lt;code&gt;CRLF&lt;/code&gt; , try the &lt;code&gt;:crlf&lt;/code&gt; layer (see &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;).</source>
          <target state="translated">また、行は &lt;code&gt;CRLF&lt;/code&gt; 内で分割しないでください（つまり、 &lt;code&gt;\r&lt;/code&gt; と &lt;code&gt;\n&lt;/code&gt; 間に空の行はありません）。 &lt;code&gt;CRLF&lt;/code&gt; については、 &lt;code&gt;:crlf&lt;/code&gt; レイヤーを試してください（&lt;a href=&quot;perlio&quot;&gt;PerlIOを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="f3992030bd7e3a922eb5df07ea510b7432d80298" translate="yes" xml:space="preserve">
          <source>Also, lines should not be split within &lt;code&gt;CRLF&lt;/code&gt; (i.e. there is no empty line between &lt;code&gt;\r&lt;/code&gt; and &lt;code&gt;\n&lt;/code&gt;). For &lt;code&gt;CRLF&lt;/code&gt;, try the &lt;code&gt;:crlf&lt;/code&gt; layer (see &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;).</source>
          <target state="translated">また、 &lt;code&gt;CRLF&lt;/code&gt; 内で行を分割しないでください（つまり、 &lt;code&gt;\r&lt;/code&gt; と &lt;code&gt;\n&lt;/code&gt; 間に空の行はありません）。 &lt;code&gt;CRLF&lt;/code&gt; 、試してください &lt;code&gt;:crlf&lt;/code&gt; 層（参照&lt;a href=&quot;perlio&quot;&gt;PerlIOをします&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="63323aa4e4ec3045e43bf822a9f6601fadcf053b" translate="yes" xml:space="preserve">
          <source>Also, negative signal values don't do anything special under VMS; they're just converted to the corresponding positive value.</source>
          <target state="translated">また、負の信号値はVMSの下では特別なことをするわけではなく、対応する正の値に変換されるだけです。</target>
        </trans-unit>
        <trans-unit id="6a350d1c09fc9665a8e389e53064c822190440b0" translate="yes" xml:space="preserve">
          <source>Also, note that using the file tests for security purposes is a lost cause from the start: there is a window open for race conditions (who is to say that the permissions will not change between the test and the real operation?). Therefore if you are serious about security, just try the real operation and test for its success - think in terms of atomic operations. Filetests are more useful for filesystem administrative tasks, when you have no need for the content of the elements on disk.</source>
          <target state="translated">また、セキュリティ目的でファイルテストを使うことは、最初から原因を見失っていることに注意してください。ですから、セキュリティを真剣に考えているのであれば、実際の操作を試してみて、その成功をテストしてみてください-アトミック操作の観点から考えてください。ファイルテストは、ディスク上の要素の内容を必要としない場合には、ファイルシステムの管理タスクのために、より有用です。</target>
        </trans-unit>
        <trans-unit id="d574d865815009daf05f1054bf415b0bf6943266" translate="yes" xml:space="preserve">
          <source>Also, note the following:</source>
          <target state="translated">また、以下の点にも注意してください。</target>
        </trans-unit>
        <trans-unit id="48ddb81f1627e1f3a6389ef3f6f1aa66ba367e47" translate="yes" xml:space="preserve">
          <source>Also, once a project is otherwise complete and you start to localize it, you can scrape together all the various keys you use, and pass it to a translator; and then the translator's work will go faster if what he's presented is this:</source>
          <target state="translated">また、プロジェクトが完成してローカリゼーションを始めたら、使用している様々なキーをまとめて翻訳者に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="25de230710079ae2e7ac75bdcf59f8719d1c3ed7" translate="yes" xml:space="preserve">
          <source>Also, perl can be recompiled to operate on an earlier version of the Unicode standard. Further information is at &lt;code&gt;$Config{privlib}&lt;/code&gt; /</source>
          <target state="translated">また、以前のバージョンのUnicode標準で動作するようにperlを再コンパイルすることもできます。詳細は &lt;code&gt;$Config{privlib}&lt;/code&gt; /にあります</target>
        </trans-unit>
        <trans-unit id="b542e84834d4e9866d33acb374e33e8f660c85fa" translate="yes" xml:space="preserve">
          <source>Also, perl can be recompiled to operate on an earlier version of the Unicode standard. Further information is at &lt;code&gt;$Config{privlib}&lt;/code&gt;/</source>
          <target state="translated">また、perlを再コンパイルして、以前のバージョンのUnicode標準で動作するようにすることもできます。詳細については、 &lt;code&gt;$Config{privlib}&lt;/code&gt; /をご覧ください。</target>
        </trans-unit>
        <trans-unit id="76997e16af65c741ca3a61aadd72db51de092e73" translate="yes" xml:space="preserve">
          <source>Also, since &lt;code&gt;$x&lt;/code&gt; is lexical, it can't be reached or modified by any Perl code outside.</source>
          <target state="translated">また、 &lt;code&gt;$x&lt;/code&gt; はレキシカルであるため、外部のPerlコードから到達または変更することはできません。</target>
        </trans-unit>
        <trans-unit id="38f33518e3f4f0a218000c4a9eb29242c2ff03c6" translate="yes" xml:space="preserve">
          <source>Also, since the number of opcodes in your current version of perl might not be an exact multiple of eight, there may be unused bits in the last byte of an upset. This should not cause any problems (Opcode functions ignore those extra bits) but it does mean that using the ~ operator will typically not produce the same 'physical' opset 'string' as the invert_opset function.</source>
          <target state="translated">また、現在のバージョンの perl のオペコード数は 8 の正確な倍数ではないかもしれないので、アップセットの最後のバイトに未使用のビットがあるかもしれません。これは問題にならないはずですが (オプコード関数はこれらの余分なビットを無視します)、 ~ 演算子を使用しても通常は invert_opset 関数と同じ「物理的な」オプセットの「文字列」が生成されないことを意味しています。</target>
        </trans-unit>
        <trans-unit id="3ed7ac3c49479a3dd530e1364bfdfcfdef42d4e9" translate="yes" xml:space="preserve">
          <source>Also, some common socket &quot;newline&quot; constants are provided: the constants &lt;code&gt;CR&lt;/code&gt; , &lt;code&gt;LF&lt;/code&gt; , and &lt;code&gt;CRLF&lt;/code&gt; , as well as &lt;code&gt;$CR&lt;/code&gt; , &lt;code&gt;$LF&lt;/code&gt; , and &lt;code&gt;$CRLF&lt;/code&gt; , which map to &lt;code&gt;\015&lt;/code&gt; , &lt;code&gt;\012&lt;/code&gt; , and &lt;code&gt;\015\012&lt;/code&gt; . If you do not want to use the literal characters in your programs, then use the constants provided here. They are not exported by default, but can be imported individually, and with the &lt;code&gt;:crlf&lt;/code&gt; export tag:</source>
          <target state="translated">また、いくつかの一般的なソケット「改行」定数が提供されています。定数 &lt;code&gt;CR&lt;/code&gt; 、 &lt;code&gt;LF&lt;/code&gt; 、および &lt;code&gt;CRLF&lt;/code&gt; と、 &lt;code&gt;$CR&lt;/code&gt; 、 &lt;code&gt;$LF&lt;/code&gt; 、および &lt;code&gt;$CRLF&lt;/code&gt; 、 &lt;code&gt;\015&lt;/code&gt; 、 &lt;code&gt;\012&lt;/code&gt; 、および &lt;code&gt;\015\012&lt;/code&gt; マップされます。プログラムでリテラル文字を使用したくない場合は、ここで提供されている定数を使用してください。これらはデフォルトではエクスポートされませんが、個別にインポートすることができ、 &lt;code&gt;:crlf&lt;/code&gt; エクスポートタグを使用します。</target>
        </trans-unit>
        <trans-unit id="09c79652fdab8435dc64bf1d503eb44817957310" translate="yes" xml:space="preserve">
          <source>Also, some common socket &quot;newline&quot; constants are provided: the constants &lt;code&gt;CR&lt;/code&gt;, &lt;code&gt;LF&lt;/code&gt;, and &lt;code&gt;CRLF&lt;/code&gt;, as well as &lt;code&gt;$CR&lt;/code&gt;, &lt;code&gt;$LF&lt;/code&gt;, and &lt;code&gt;$CRLF&lt;/code&gt;, which map to &lt;code&gt;\015&lt;/code&gt;, &lt;code&gt;\012&lt;/code&gt;, and &lt;code&gt;\015\012&lt;/code&gt;. If you do not want to use the literal characters in your programs, then use the constants provided here. They are not exported by default, but can be imported individually, and with the &lt;code&gt;:crlf&lt;/code&gt; export tag:</source>
          <target state="translated">また、いくつかの一般的なソケットの「改行」定数が提供されています。定数 &lt;code&gt;CR&lt;/code&gt; 、 &lt;code&gt;LF&lt;/code&gt; 、および &lt;code&gt;CRLF&lt;/code&gt; と、 &lt;code&gt;\015&lt;/code&gt; 、 &lt;code&gt;\012&lt;/code&gt; 、および &lt;code&gt;\015\012&lt;/code&gt; マップされる &lt;code&gt;$CR&lt;/code&gt; 、 &lt;code&gt;$LF&lt;/code&gt; 、および &lt;code&gt;$CRLF&lt;/code&gt; です。プログラムでリテラル文字を使用したくない場合は、ここに記載されている定数を使用してください。これらはデフォルトではエクスポートされませんが、個別にインポートでき、 &lt;code&gt;:crlf&lt;/code&gt; exportタグを使用して：</target>
        </trans-unit>
        <trans-unit id="13c4a82fda1ed827381af159c98e8fcbdf05900b" translate="yes" xml:space="preserve">
          <source>Also, some special instructions for building Perl with Sun Studio on Linux. Following the normal &lt;code&gt;Configure&lt;/code&gt; , you have to run make as follows:</source>
          <target state="translated">また、Linux上のSun StudioでPerlを構築するためのいくつかの特別な指示。通常の &lt;code&gt;Configure&lt;/code&gt; に続いて、次のようにmakeを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="430b83395a22758023df144cbbf527affef6a44c" translate="yes" xml:space="preserve">
          <source>Also, subroutines could be declared with the &lt;code&gt;:locked&lt;/code&gt; attribute which would serialize access to the subroutine, but allowed different threads non-simultaneous access.</source>
          <target state="translated">また、サブルーチンは、サブルーチンへのアクセスをシリアル化する &lt;code&gt;:locked&lt;/code&gt; 属性を使用して宣言できますが、異なるスレッドに非同時アクセスを許可しました。</target>
        </trans-unit>
        <trans-unit id="f700fce01f8bef830aa30a8774e7a762bfbaf65f" translate="yes" xml:space="preserve">
          <source>Also, the internal representation of Time::Piece-&amp;gt;strftime deviates from the standard POSIX implementation in that is uses the epoch (instead of separate year, month, day parts). This change was added in version 1.30. If you must have a more traditional strftime (which will normally never calculate day light saving times correctly), you can pass the date parts from Time::Piece into the strftime function provided by the POSIX module (see strftime in &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; ).</source>
          <target state="translated">また、Time :: Piece-&amp;gt; strftimeの内部表現は、（個別の年、月、日の部分ではなく）エポックを使用するという点で標準のPOSIX実装から逸脱しています。この変更はバージョン1.30で追加されました。より伝統的なstrftime（通常は夏時間を正しく計算することはありません）が必要な場合は、Time :: PieceからPOSIXモジュールによって提供されるstrftime関数に日付部分を渡すことができます（&lt;a href=&quot;posix&quot;&gt;POSIXの&lt;/a&gt;strftimeを参照）。</target>
        </trans-unit>
        <trans-unit id="e7201d576462a40ab9a535c50ec57d12c94dd4c2" translate="yes" xml:space="preserve">
          <source>Also, the object is configured such that it stringifies to the name of the temporary file and so can be compared to a filename directly. It numifies to the &lt;code&gt;refaddr&lt;/code&gt; the same as other handles and so can be compared to other handles with &lt;code&gt;==&lt;/code&gt;.</source>
          <target state="translated">また、オブジェクトは、一時ファイルの名前に文字列化されるように構成されているため、ファイル名と直接比較できます。他のハンドルと同じように &lt;code&gt;refaddr&lt;/code&gt; に番号を付けるため、 &lt;code&gt;==&lt;/code&gt; を使用して他のハンドルと比較できます。</target>
        </trans-unit>
        <trans-unit id="cdb14deb83dae5ba493a96acfadaf1236cbdc5ea" translate="yes" xml:space="preserve">
          <source>Also, the object is configured such that it stringifies to the name of the temporary file and so can be compared to a filename directly. It numifies to the C</source>
          <target state="translated">また、オブジェクトは一時ファイルの名前を文字列化し、直接ファイル名と比較できるように設定されています。また、オブジェクトは、一時ファイルの名前を文字列化して</target>
        </trans-unit>
        <trans-unit id="913c9e19c71d84db5eb4e7b9fa93a06fccc33227" translate="yes" xml:space="preserve">
          <source>Also, the range 'A' - 'Z' in ASCII is an unbroken sequence of 26 upper case alphabetic characters. That is not true in EBCDIC. Nor for 'a' to 'z'. But '0' - '9' is an unbroken range in both systems. Don't assume anything about other ranges. (Note that special handling of ranges in regular expression patterns and transliterations makes it appear to Perl code that the aforementioned ranges are all unbroken.)</source>
          <target state="translated">また、ASCIIの'A'~'Z'の範囲は、アルファベットの大文字26文字が途切れずに並んでいます。EBCDICではそうではありません。a' から 'z' もそうです。しかし、'0'-'9' はどちらのシステムでも途切れない範囲です。他の範囲については何も仮定しないでください。(正規表現パターンや音訳の中での範囲の特別な処理により、前述の範囲がすべて途切れていないようにPerlのコードに見えることに注意してください)</target>
        </trans-unit>
        <trans-unit id="ad7807da341a2e1187eef533ebec80cd0117d203" translate="yes" xml:space="preserve">
          <source>Also, the range 'A' - 'Z' in ASCII is an unbroken sequence of 26 upper case alphabetic characters. That is not true in EBCDIC. Nor for 'a' to 'z'. But '0' - '9' is an unbroken range in both systems. Don't assume anything about other ranges. (Note that special handling of ranges in regular expression patterns makes it appear to Perl code that the aforementioned ranges are all unbroken.)</source>
          <target state="translated">また、ASCIIの'A'~'Z'の範囲は、アルファベットの大文字26文字の切れ目のない連続した文字列です。EBCDICではそうではありません。a' から 'z' もそうです。しかし、'0'-'9' はどちらのシステムでも途切れない範囲です。他の範囲については何も仮定しないでください。(正規表現パターンでの範囲の特別な処理により、Perl のコードでは前述の範囲がすべて途切れていないように見えることに注意してください)。</target>
        </trans-unit>
        <trans-unit id="ed48bbc731848457db80d2fadad2fe9e698169b3" translate="yes" xml:space="preserve">
          <source>Also, the use of Unicode may present security issues that aren't obvious, see &lt;a href=&quot;#Security-Implications-of-Unicode&quot;&gt;&quot;Security Implications of Unicode&quot;&lt;/a&gt; below.</source>
          <target state="translated">また、Unicodeを使用すると、明らかではないセキュリティの問題が発生する可能性があります。以下の&lt;a href=&quot;#Security-Implications-of-Unicode&quot;&gt;「Unicodeのセキュリティへの影響」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="11e213d7b8a81bd451ffb3f3ae8fa862e904a6c3" translate="yes" xml:space="preserve">
          <source>Also, the use of Unicode may present security issues that aren't obvious. Read &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;Unicode Security Considerations&lt;/a&gt;.</source>
          <target state="translated">また、Unicodeを使用すると、明らかではないセキュリティの問題が発生する可能性があります。&lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.unicode.org%2freports%2ftr36&quot;&gt;Unicodeのセキュリティに関する考慮事項&lt;/a&gt;をお読みください。</target>
        </trans-unit>
        <trans-unit id="5a6ddd5f6cea51490776d1ee7aa46674933e080d" translate="yes" xml:space="preserve">
          <source>Also, under this modifier, case-insensitive matching works on the full set of Unicode characters. The &lt;code&gt;KELVIN SIGN&lt;/code&gt; , for example matches the letters &quot;k&quot; and &quot;K&quot;; and &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; matches the sequence &quot;ff&quot;, which, if you're not prepared, might make it look like a hexadecimal constant, presenting another potential security issue. See &lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http://unicode.org/reports/tr36&lt;/a&gt; for a detailed discussion of Unicode security issues.</source>
          <target state="translated">また、この修飾子では、大文字と小文字を区別しないマッチングは、Unicode文字の完全なセットで機能します。 &lt;code&gt;KELVIN SIGN&lt;/code&gt; 、例えば文字「K」と「K」と一致します。そして &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; は、あなたが準備していない場合、それは別の潜在的なセキュリティ問題を提示し、進定数のように見えるように可能性があるシーケンス「FF」を、一致します。Unicodeのセキュリティ問題の詳細については、&lt;a href=&quot;http://unicode.org/reports/tr36&quot;&gt;http：//unicode.org/reports/tr36&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="082c639d640961ab2741dc8437aea7d26245da44" translate="yes" xml:space="preserve">
          <source>Also, under this modifier, case-insensitive matching works on the full set of Unicode characters. The &lt;code&gt;KELVIN SIGN&lt;/code&gt;, for example matches the letters &quot;k&quot; and &quot;K&quot;; and &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; matches the sequence &quot;ff&quot;, which, if you're not prepared, might make it look like a hexadecimal constant, presenting another potential security issue. See &lt;a href=&quot;https://unicode.org/reports/tr36&quot;&gt;https://unicode.org/reports/tr36&lt;/a&gt; for a detailed discussion of Unicode security issues.</source>
          <target state="translated">また、この修飾子では、大文字と小文字を区別しないマッチングがUnicode文字のフルセットで機能します。 &lt;code&gt;KELVIN SIGN&lt;/code&gt; 、例えば文字「K」と「K」と一致します。そして &lt;code&gt;LATIN SMALL LIGATURE FF&lt;/code&gt; は、あなたが準備していない場合、それは別の潜在的なセキュリティ問題を提示し、進定数のように見えるように可能性があるシーケンス「FF」を、一致します。Unicodeセキュリティの問題の詳細については、&lt;a href=&quot;https://unicode.org/reports/tr36&quot;&gt;https：//unicode.org/reports/tr36&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7d458ad7a020a232313ae8d56db7bcab0ded5305" translate="yes" xml:space="preserve">
          <source>Also, various synonyms like &lt;code&gt;\p{Alpha}&lt;/code&gt; for &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; ; all listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;Properties accessible through \p{} and \P{} in perluniprops&lt;/a&gt;</source>
          <target state="translated">また、のような様々な同義語 &lt;code&gt;\p{Alpha}&lt;/code&gt; ため &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; 。&lt;a href=&quot;perluniprops#Properties-accessible-through-%5cp%7b%7d-and-%5cP%7b%7d&quot;&gt;perlunipropsの\ p {}および\ P {}を介してアクセス可能なプロパティに&lt;/a&gt;リストされているすべて</target>
        </trans-unit>
        <trans-unit id="185cbf92e7b7051aa2f9930ee2ca151063ceb454" translate="yes" xml:space="preserve">
          <source>Also, various synonyms like &lt;code&gt;\p{Alpha}&lt;/code&gt; for &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt;; all listed in &lt;a href=&quot;perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;&quot;Properties accessible through \p{} and \P{}&quot; in perluniprops&lt;/a&gt;</source>
          <target state="translated">また、のような様々な同義語 &lt;code&gt;\p{Alpha}&lt;/code&gt; ため &lt;code&gt;\p{XPosixAlpha}&lt;/code&gt; 。&lt;a href=&quot;perluniprops#Properties-accessible-through-%5Cp%7B%7D-and-%5CP%7B%7D&quot;&gt;perlunipropsの「\ p {}および\ P {}からアクセス可能なプロパティ」に&lt;/a&gt;すべてリストされています</target>
        </trans-unit>
        <trans-unit id="3fd51e4e1d10037d178287b3c2e52d39f31c50f2" translate="yes" xml:space="preserve">
          <source>Also, when your</source>
          <target state="translated">また、あなたの</target>
        </trans-unit>
        <trans-unit id="94df63c3696c6e9f216a0b26ed643a62ffdfe44b" translate="yes" xml:space="preserve">
          <source>Also, white space, hyphens, and underscores are normally ignored everywhere between the {braces}, and hence can be freely added or removed even if the &lt;code&gt;/x&lt;/code&gt; modifier hasn't been specified on the regular expression. But in the table below a '&lt;b&gt;T&lt;/b&gt;' at the beginning of an entry means that tighter (stricter) rules are used for that entry:</source>
          <target state="translated">また、空白、ハイフン、およびアンダースコアは通常、{中かっ​​こ}の間のすべての場所で無視されるため、正規表現で &lt;code&gt;/x&lt;/code&gt; 修飾子が指定されていなくても、自由に追加または削除できます。ただし、以下の表で、エントリの先頭にある「&lt;b&gt;T&lt;/b&gt;」は、そのエントリに対してより厳しい（より厳しい）ルールが使用されていることを意味します。</target>
        </trans-unit>
        <trans-unit id="87ea7db4a430030d90185495584807fc225cd906" translate="yes" xml:space="preserve">
          <source>Also:</source>
          <target state="translated">Also:</target>
        </trans-unit>
        <trans-unit id="554a943cef6b1565f2a13a13d21f280b671c0db6" translate="yes" xml:space="preserve">
          <source>Alter regular expression behaviour</source>
          <target state="translated">正規表現の動作を変更する</target>
        </trans-unit>
        <trans-unit id="4b26f888988c3f23411577d380346f5e87008e97" translate="yes" xml:space="preserve">
          <source>Alternate Stack Manipulation</source>
          <target state="translated">代替スタック操作</target>
        </trans-unit>
        <trans-unit id="baff84fe31ffd586fd0cbbd5cab56329f0775d04" translate="yes" xml:space="preserve">
          <source>Alternate form of specifying the local address to &lt;code&gt;bind()&lt;/code&gt; to. This should be an array of the form returned by &lt;code&gt;Socket::getaddrinfo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bind()&lt;/code&gt; 先のローカルアドレスを指定する別の形式。これは、 &lt;code&gt;Socket::getaddrinfo&lt;/code&gt; によって返される形式の配列である必要があります。</target>
        </trans-unit>
        <trans-unit id="0db36f7208c555076a29994a086e6ad6fe2b6c88" translate="yes" xml:space="preserve">
          <source>Alternate form of specifying the peer to &lt;code&gt;connect()&lt;/code&gt; to. This should be an array of the form returned by &lt;code&gt;Socket::getaddrinfo&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;connect()&lt;/code&gt; 先のピアを指定する別の形式。これは、 &lt;code&gt;Socket::getaddrinfo&lt;/code&gt; によって返される形式の配列である必要があります。</target>
        </trans-unit>
        <trans-unit id="4495ae5a9f0394b58820a885d0978ae962fd139c" translate="yes" xml:space="preserve">
          <source>Alternately I can pass an open filehandle as source and have the parser read from that rather than attempting to run a test script:</source>
          <target state="translated">また、テストスクリプトを実行するのではなく、オープンなファイルハンドルをソースとして渡して、パーサにそこから読み込ませることもできます。</target>
        </trans-unit>
        <trans-unit id="bb5fc16ac82340f31ba65517d29fc05e91506541" translate="yes" xml:space="preserve">
          <source>Alternately I can supply the names of my substitute classes to the TAP::Harness constructor:</source>
          <target state="translated">あるいは、TAP::Harness のコンストラクタに代用クラスの名前を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="9227d0ca3877e84e35d83f9ac364f43162e4ef9e" translate="yes" xml:space="preserve">
          <source>Alternately, if the language used to write my tests allows a shebang line I can use that to specify the interpreter. Here's a test written in PHP:</source>
          <target state="translated">あるいは、テストを書くのに使われている言語が shebang 行を許可している場合は、それを使ってインタープリタを指定することもできます。これは PHP で書かれたテストです。</target>
        </trans-unit>
        <trans-unit id="fd038ee8b646edddd400b75f62f9db870f503cd5" translate="yes" xml:space="preserve">
          <source>Alternately, if you have an SV that is a blessed reference, you can find out the stash pointer by using:</source>
          <target state="translated">あるいは、祝福された参照先であるSVがある場合は、スタッシュポインタを利用して調べることができます。</target>
        </trans-unit>
        <trans-unit id="6589e5a8ee283a61027f2499ac81f9bd22f55b5a" translate="yes" xml:space="preserve">
          <source>Alternately, if you import &lt;code&gt;:constants&lt;/code&gt; , you can use the following constants directly:</source>
          <target state="translated">または、 &lt;code&gt;:constants&lt;/code&gt; をインポートする場合、次の定数を直接使用できます。</target>
        </trans-unit>
        <trans-unit id="8a245817c61d1ffafbf0a5d7c18cd6a72b400a7e" translate="yes" xml:space="preserve">
          <source>Alternately, if you import &lt;code&gt;:constants&lt;/code&gt;, you can use the following constants directly:</source>
          <target state="translated">または、 &lt;code&gt;:constants&lt;/code&gt; をインポートする場合は、次の定数を直接使用できます。</target>
        </trans-unit>
        <trans-unit id="3835ce5fac7a47f4550c37daaf24821ea36a9658" translate="yes" xml:space="preserve">
          <source>Alternately, if you use OS/2-ish shell, like CMD or 4os2, put the following at the start of your perl script:</source>
          <target state="translated">あるいは、CMDや4os2のようなOS/2っぽいシェルを使っている場合は、perlスクリプトの先頭に以下のように記述してください。</target>
        </trans-unit>
        <trans-unit id="3c02b30c04d1bd2e064bba714a6c966f7e7001cc" translate="yes" xml:space="preserve">
          <source>Alternately, try running pod2text on</source>
          <target state="translated">別の方法として、pod2textを</target>
        </trans-unit>
        <trans-unit id="c6586bf995507ef47c1e8462c0b96f9bda48432b" translate="yes" xml:space="preserve">
          <source>Alternately, you can change to binary mode on an existing handle this way:</source>
          <target state="translated">別の方法として、この方法で既存のハンドルをバイナリモードに変更することもできます。</target>
        </trans-unit>
        <trans-unit id="436c604fc9e91f4036987513f30ceb0b117df526" translate="yes" xml:space="preserve">
          <source>Alternately, you can set the global variable &lt;code&gt;$Carp::Verbose&lt;/code&gt; to true. See the &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; section below.</source>
          <target state="translated">または、グローバル変数 &lt;code&gt;$Carp::Verbose&lt;/code&gt; をtrueに設定できます。以下の「 &lt;code&gt;GLOBAL VARIABLES&lt;/code&gt; セクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="15f2c59a8b9b5baf596fabaf5af782241acbedb6" translate="yes" xml:space="preserve">
          <source>Alternately, you can specify the exact directory to place the extension's files by placing a &quot;PREFIX=/destination/directory&quot; after the make install (or in between the make and install if you have a brain-dead version of make). This can be very useful if you are building an extension that will eventually be distributed to multiple systems. You can then just archive the files in the destination directory and distribute them to your destination systems.</source>
          <target state="translated">あるいは、make install の後に &quot;PREFIX=/destination/directory&quot; を指定して、拡張機能のファイルを置くディレクトリを正確に指定することもできます (あるいは、頭の悪いバージョンの make を使っている場合は make と install の間に指定してください)。これは、最終的に複数のシステムに配布されるような拡張機能を構築している場合に非常に便利です。インストール先ディレクトリにあるファイルをアーカイブして、インストール先のシステムに配布すればいいのです。</target>
        </trans-unit>
        <trans-unit id="e00c3a1ce8b9e2b0c7ee0051f3ec0d7cf8bcbdb9" translate="yes" xml:space="preserve">
          <source>Alternately, you can try to get a replacement for the system's &lt;b&gt;Execute&lt;/b&gt; command that honors the #!/usr/bin/perl syntax in scripts and set the s-Bit of your scripts. Then you can invoke your scripts like under UNIX with</source>
          <target state="translated">または、スクリプトの＃！/ usr / bin / perl構文を尊重し、スクリプトのsビットを設定するシステムの&lt;b&gt;実行&lt;/b&gt;コマンドの代わりを取得することもできます。次に、UNIXのようにスクリプトを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="70b8f05f7796eca9b3373c7ecd058a653ad0409c" translate="yes" xml:space="preserve">
          <source>Alternately, you can use &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;, the regular expression quote operator (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details). It quotes and perhaps compiles the pattern, and you can apply regular expression flags to the pattern.</source>
          <target state="translated">または、正規表現の引用演算子である &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; を使用できます（詳細については、&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;を参照してください）。パターンを引用し、おそらくコンパイルします。正規表現フラグをパターンに適用できます。</target>
        </trans-unit>
        <trans-unit id="7d48931e8ff9955945645810ae372a2695434121" translate="yes" xml:space="preserve">
          <source>Alternately, you can use &lt;code&gt;qr//&lt;/code&gt;, the regular expression quote operator (see &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; for more details). It quotes and perhaps compiles the pattern, and you can apply regular expression flags to the pattern.</source>
          <target state="translated">または、正規表現の引用演算子である &lt;code&gt;qr//&lt;/code&gt; を使用することもできます（詳細については、&lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;を参照してください）。パターンを引用してコンパイルし、正規表現フラグをパターンに適用できます。</target>
        </trans-unit>
        <trans-unit id="5b04c7a5831dedb851aed975f051c1cac400682e" translate="yes" xml:space="preserve">
          <source>Alternation</source>
          <target state="translated">Alternation</target>
        </trans-unit>
        <trans-unit id="be9a6aa6691045b50a599c27892a7efaa458c7af" translate="yes" xml:space="preserve">
          <source>Alternation allows a regexp to choose among alternatives, but by itself it is unsatisfying. The reason is that each alternative is a whole regexp, but sometime we want alternatives for just part of a regexp. For instance, suppose we want to search for housecats or housekeepers. The regexp &lt;code&gt;housecat|housekeeper&lt;/code&gt; fits the bill, but is inefficient because we had to type &lt;code&gt;house&lt;/code&gt; twice. It would be nice to have parts of the regexp be constant, like &lt;code&gt;house&lt;/code&gt; , and some parts have alternatives, like &lt;code&gt;cat|keeper&lt;/code&gt; .</source>
          <target state="translated">代替は正規表現が選択肢の中から選択することを可能にしますが、それだけでは満足できません。その理由は、各代替案が完全な正規表現であるからですが、正規表現の一部だけの代替案が必要になる場合があります。たとえば、家猫や家政婦を検索したいとします。正規表現の &lt;code&gt;housecat|housekeeper&lt;/code&gt; は法案に適合しますが、 &lt;code&gt;house&lt;/code&gt; 2回入力する必要があったため、非効率的です。 &lt;code&gt;house&lt;/code&gt; のように正規表現の一部を定数にして、 &lt;code&gt;cat|keeper&lt;/code&gt; ように別の部分を持たせるとよいでしょう。</target>
        </trans-unit>
        <trans-unit id="2748d57020b2771f7481af94280b0d7745a90798" translate="yes" xml:space="preserve">
          <source>Alternation allows a regexp to choose among alternatives, but by itself it is unsatisfying. The reason is that each alternative is a whole regexp, but sometime we want alternatives for just part of a regexp. For instance, suppose we want to search for housecats or housekeepers. The regexp &lt;code&gt;housecat|housekeeper&lt;/code&gt; fits the bill, but is inefficient because we had to type &lt;code&gt;house&lt;/code&gt; twice. It would be nice to have parts of the regexp be constant, like &lt;code&gt;house&lt;/code&gt;, and some parts have alternatives, like &lt;code&gt;cat|keeper&lt;/code&gt;.</source>
          <target state="translated">代替は、正規表現が代替の中から選択することを可能にしますが、それ自体では満足のいくものではありません。その理由は、各代替が正規表現全体であるためですが、正規表現の一部にのみ代替が必要な場合があります。たとえば、ハウスキャットやハウスキーパーを検索するとします。正規表現 &lt;code&gt;housecat|housekeeper&lt;/code&gt; は法案に適合しますが、 &lt;code&gt;house&lt;/code&gt; 2回入力する必要があるため非効率的です。 &lt;code&gt;house&lt;/code&gt; のように正規表現の一部を一定にし、 &lt;code&gt;cat|keeper&lt;/code&gt; ように一部の部分に代替を含めると便利です。</target>
        </trans-unit>
        <trans-unit id="1cf43ccde7eeaee521a4a189652a63c1baacf5e0" translate="yes" xml:space="preserve">
          <source>Alternations behave the same way in groups as out of them: at a given string position, the leftmost alternative that allows the regexp to match is taken. So in the last example at the first string position, &lt;code&gt;&quot;20&quot;&lt;/code&gt; matches the second alternative, but there is nothing left over to match the next two digits &lt;code&gt;\d\d&lt;/code&gt; . So Perl moves on to the next alternative, which is the null alternative and that works, since &lt;code&gt;&quot;20&quot;&lt;/code&gt; is two digits.</source>
          <target state="translated">代替はグループ内でもグループ外でも同じように動作します。指定された文字列の位置で、正規表現の一致を可能にする左端の代替が採用されます。したがって、最初の文字列位置の最後の例では、 &lt;code&gt;&quot;20&quot;&lt;/code&gt; は2番目の選択肢と一致しますが、次の2桁の &lt;code&gt;\d\d&lt;/code&gt; と一致するものはありません。したがって、 &lt;code&gt;&quot;20&quot;&lt;/code&gt; は2桁なので、Perlは次の選択肢に進みます。これはnullの選択肢であり、機能します。</target>
        </trans-unit>
        <trans-unit id="ef0bb58311a4cc103103ca6beeb54a0245223e8c" translate="yes" xml:space="preserve">
          <source>Alternations behave the same way in groups as out of them: at a given string position, the leftmost alternative that allows the regexp to match is taken. So in the last example at the first string position, &lt;code&gt;&quot;20&quot;&lt;/code&gt; matches the second alternative, but there is nothing left over to match the next two digits &lt;code&gt;\d\d&lt;/code&gt;. So Perl moves on to the next alternative, which is the null alternative and that works, since &lt;code&gt;&quot;20&quot;&lt;/code&gt; is two digits.</source>
          <target state="translated">交替は、グループ内でもグループ外でも同じように動作します。特定の文字列位置で、正規表現を一致させるための左端の代替が使用されます。したがって、最初の文字列位置の最後の例では、 &lt;code&gt;&quot;20&quot;&lt;/code&gt; は2番目の選択肢に一致しますが、次の2桁の &lt;code&gt;\d\d&lt;/code&gt; に一致するものは何も残っていません。したがって、Perlは次の選択肢に進みます。これはnullの選択肢であり、 &lt;code&gt;&quot;20&quot;&lt;/code&gt; は2桁であるため、機能します。</target>
        </trans-unit>
        <trans-unit id="d45912dbd856f0ddf337c48eab0e2b6ac8ae702c" translate="yes" xml:space="preserve">
          <source>Alternative Hash Functions</source>
          <target state="translated">代替ハッシュ関数</target>
        </trans-unit>
        <trans-unit id="92135acee6fb42da0402ddedc5b8263e8afa69de" translate="yes" xml:space="preserve">
          <source>Alternative capture group numbering</source>
          <target state="translated">代替キャプチャグループのナンバリング</target>
        </trans-unit>
        <trans-unit id="ef523340b1a308a5c82202213f6749b6e6b1eda0" translate="yes" xml:space="preserve">
          <source>Alternative libraries &lt;a href=&quot;Math::BigInt::Calc&quot;&gt;Math::BigInt::Calc&lt;/a&gt;, &lt;a href=&quot;Math::BigInt::GMP&quot;&gt;Math::BigInt::GMP&lt;/a&gt;, and &lt;a href=&quot;Math::BigInt::Pari&quot;&gt;Math::BigInt::Pari&lt;/a&gt;.</source>
          <target state="translated">代替ライブラリ&lt;a href=&quot;Math::BigInt::Calc&quot;&gt;Math :: BigInt :: Calc&lt;/a&gt;、&lt;a href=&quot;Math::BigInt::GMP&quot;&gt;Math :: BigInt :: GMP&lt;/a&gt;、および&lt;a href=&quot;Math::BigInt::Pari&quot;&gt;Math :: BigInt :: Pari&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="701e87ca0ad0ba8cd11eda21d6ba26ee826bdec9" translate="yes" xml:space="preserve">
          <source>Alternative libraries &lt;a href=&quot;Math::BigInt::FastCalc&quot;&gt;Math::BigInt::FastCalc&lt;/a&gt;, &lt;a href=&quot;Math::BigInt::GMP&quot;&gt;Math::BigInt::GMP&lt;/a&gt;, and &lt;a href=&quot;Math::BigInt::Pari&quot;&gt;Math::BigInt::Pari&lt;/a&gt;.</source>
          <target state="translated">代替ライブラリ&lt;a href=&quot;Math::BigInt::FastCalc&quot;&gt;Math :: BigInt :: FastCalc&lt;/a&gt;、&lt;a href=&quot;Math::BigInt::GMP&quot;&gt;Math &lt;/a&gt;:: BigInt :: GMP、および&lt;a href=&quot;Math::BigInt::Pari&quot;&gt;Math :: BigInt :: Pari&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="79c07200d4699b036f2138680fade3c9689f7058" translate="yes" xml:space="preserve">
          <source>Alternative math libraries</source>
          <target state="translated">代替の数学ライブラリ</target>
        </trans-unit>
        <trans-unit id="6aa5c766a08c26061e42a91b28e7696a27f14067" translate="yes" xml:space="preserve">
          <source>Alternative option starters</source>
          <target state="translated">代替オプションのスターター</target>
        </trans-unit>
        <trans-unit id="443fe46b83982a5185e410eceac3b7185f7ae257" translate="yes" xml:space="preserve">
          <source>Alternative to Test::More::use_ok</source>
          <target state="translated">Test::More::use_ok に代わるもの</target>
        </trans-unit>
        <trans-unit id="c7461a3c1c3204afbbfd69dbbccd1e2b59471f99" translate="yes" xml:space="preserve">
          <source>Alternative warn and die for modules</source>
          <target state="translated">モジュールのための代替的な警告とダイ</target>
        </trans-unit>
        <trans-unit id="12e5972b55b252c3c9bc2d82985850d79c96249e" translate="yes" xml:space="preserve">
          <source>Alternatively edit the init file interactively via: 3rd mouse button -&amp;gt; New Display -&amp;gt; Edit Menu</source>
          <target state="translated">または、次の方法で対話的に初期化ファイルを編集します。3番目のマウスボタン-&amp;gt; [新しいディスプレイ]-&amp;gt; [編集]メニュー</target>
        </trans-unit>
        <trans-unit id="44c86b27ab468eef89d417477ce09eb4480abfb2" translate="yes" xml:space="preserve">
          <source>Alternatively look here: &lt;a href=&quot;http://www.unix.com/man-page/FreeBSD/3/strftime/&quot;&gt;http://www.unix.com/man-page/FreeBSD/3/strftime/&lt;/a&gt;</source>
          <target state="translated">または、こちらを&lt;a href=&quot;http://www.unix.com/man-page/FreeBSD/3/strftime/&quot;&gt;ご覧ください&lt;/a&gt;：http : //www.unix.com/man-page/FreeBSD/3/strftime/</target>
        </trans-unit>
        <trans-unit id="e35a7c6545b16241ad2de0b09b446ca8d6a30265" translate="yes" xml:space="preserve">
          <source>Alternatively one can use the</source>
          <target state="translated">別の方法として</target>
        </trans-unit>
        <trans-unit id="5d17661d2312f06dcd6c1a5156f20af2512c469b" translate="yes" xml:space="preserve">
          <source>Alternatively the list of subfields can by supplied as a scalar, thus</source>
          <target state="translated">また、サブフィールドのリストをスカラ値として提供することもできます。</target>
        </trans-unit>
        <trans-unit id="2d8ede1527fb5e6a736864b76d2f172c35af4997" translate="yes" xml:space="preserve">
          <source>Alternatively you can use the</source>
          <target state="translated">代わりに</target>
        </trans-unit>
        <trans-unit id="094a83381a58e4403aca1b491639e03749297bf0" translate="yes" xml:space="preserve">
          <source>Alternatively you can use the XPUSHs() macro, which combines a &lt;code&gt;EXTEND(SP, 1)&lt;/code&gt; and &lt;code&gt;PUSHs()&lt;/code&gt;. This is less efficient if you're pushing multiple values.</source>
          <target state="translated">または、 &lt;code&gt;EXTEND(SP, 1)&lt;/code&gt; と &lt;code&gt;PUSHs()&lt;/code&gt; を組み合わせたXPUSHs（）マクロを使用することもできます。複数の値をプッシュする場合、これは効率が低下します。</target>
        </trans-unit>
        <trans-unit id="0e3d4d311210785c85520063de48eeff7de6af69" translate="yes" xml:space="preserve">
          <source>Alternatively you can use the compiler directive our() to bring a dynamic variable into the current lexical scope.</source>
          <target state="translated">あるいは、コンパイラディレクティブ our()を使用して動的変数を現在の辞書スコープに入れることもできます。</target>
        </trans-unit>
        <trans-unit id="2cec5cf8bbfadcf33f7e5849e13d536e2c1766e0" translate="yes" xml:space="preserve">
          <source>Alternatively you can use:</source>
          <target state="translated">または、使用することができます。</target>
        </trans-unit>
        <trans-unit id="43f0cea439a0fe2f49f0e9b79ff517dcdbec8d84" translate="yes" xml:space="preserve">
          <source>Alternatively you may be able to get these docs prebuilt from &lt;code&gt;CPAN&lt;/code&gt; .</source>
          <target state="translated">または、 &lt;code&gt;CPAN&lt;/code&gt; から事前に作成されたこれらのドキュメントを入手できる場合があります。</target>
        </trans-unit>
        <trans-unit id="f7f7013a74aa2034d027da86e6edefa6ad1f3b65" translate="yes" xml:space="preserve">
          <source>Alternatively you may be able to get these docs prebuilt from CPAN.</source>
          <target state="translated">あるいは、これらのドキュメントをCPANから事前に作成してもらうこともできます。</target>
        </trans-unit>
        <trans-unit id="06dab9dc9469b67b9f013b1f7d978b8fd09b7e74" translate="yes" xml:space="preserve">
          <source>Alternatively, Berkeley DB version 1 is available at your nearest CPAN archive in</source>
          <target state="translated">また、Berkeley DB バージョン 1 は、お近くの CPAN アーカイブで入手できます。</target>
        </trans-unit>
        <trans-unit id="4613df2f546fec79f85cfae70e64069cb1648bc9" translate="yes" xml:space="preserve">
          <source>Alternatively, a version range &lt;b&gt;may&lt;/b&gt; use the operators &amp;lt; (less than), &amp;lt;= (less than or equal), &amp;gt; (greater than), &amp;gt;= (greater than or equal), == (equal), and != (not equal). For example, the specification &lt;code&gt;&amp;lt; 2.0&lt;/code&gt; means that any version of the prerequisite less than 2.0 is suitable.</source>
          <target state="translated">あるいは、バージョン範囲が&lt;b&gt;よい&lt;/b&gt;ではない（=！&amp;lt;（未満）、&amp;lt;=（以下）、&amp;gt;（より大きい）、&amp;gt; =（以上）、==（等しい）演算子を使用し、そして等しい）。たとえば、仕様 &lt;code&gt;&amp;lt; 2.0&lt;/code&gt; は、2.0未満の前提条件の任意のバージョンが適切であることを意味します。</target>
        </trans-unit>
        <trans-unit id="18aa5e8fea6653b702c48738f98b3e8db633fcaf" translate="yes" xml:space="preserve">
          <source>Alternatively, an array reference of section specifications can be used:</source>
          <target state="translated">あるいは、セクション仕様の配列参照を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="89c6743b65649f02ac7d006f9c75c999b8c0f7a0" translate="yes" xml:space="preserve">
          <source>Alternatively, as of version 2.24, the configuration options may be passed together with the &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement:</source>
          <target state="translated">または、バージョン2.24以降では、構成オプションを &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ステートメントと一緒に渡すことができます。</target>
        </trans-unit>
        <trans-unit id="865e46b39731975715e5505f357dc99fc1bb9e96" translate="yes" xml:space="preserve">
          <source>Alternatively, as of version 2.24, the configuration options may be passed together with the &lt;code&gt;use&lt;/code&gt; statement:</source>
          <target state="translated">または、バージョン2.24以降、構成オプションを &lt;code&gt;use&lt;/code&gt; ステートメントと一緒に渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="fb6383e28e6083bea50110ff705c0169c065025b" translate="yes" xml:space="preserve">
          <source>Alternatively, if &lt;code&gt;decode_pod&lt;/code&gt; is set, it will decode the collected pod sections according to the &lt;code&gt;=encoding&lt;/code&gt; declaration.</source>
          <target state="translated">または、 &lt;code&gt;decode_pod&lt;/code&gt; が設定されている場合は、 &lt;code&gt;=encoding&lt;/code&gt; 宣言に従って収集されたポッドセクションをデコードします。</target>
        </trans-unit>
        <trans-unit id="c0f72336ff028f49493e1034a2d5aa23e62a23ff" translate="yes" xml:space="preserve">
          <source>Alternatively, if the &lt;code&gt;string&lt;/code&gt; parameter is given, the supplied string will be parsed instead of a file.</source>
          <target state="translated">または、 &lt;code&gt;string&lt;/code&gt; パラメーターを指定すると、ファイルではなく、指定された文字列が解析されます。</target>
        </trans-unit>
        <trans-unit id="e9aa6c54c04158a408f2c0b76a7a51f158187ce5" translate="yes" xml:space="preserve">
          <source>Alternatively, if you don't need perlglob.exe and don't need to enable the USE_SETARGV option then you can safely just remove all mention of $(GLOBEXE) from win32/Makefile and setargv.obj won't be required anyway.</source>
          <target state="translated">あるいは、perlglob.exeが不要で、USE_SETARGVオプションを有効にする必要がない場合は、win32/Makefileから$(GLOBEXE)の言及をすべて削除するだけで安全に、setargv.objはいずれにせよ必要ありません。</target>
        </trans-unit>
        <trans-unit id="068fceff1e33e5da627a6b110b456936f6082b0c" translate="yes" xml:space="preserve">
          <source>Alternatively, if you have the &lt;code&gt;gunzip&lt;/code&gt; program available, you can use this to read compressed files</source>
          <target state="translated">または、 &lt;code&gt;gunzip&lt;/code&gt; プログラムを使用できる場合は、これを使用して圧縮ファイルを読み取ることができます</target>
        </trans-unit>
        <trans-unit id="4d16466752d2c087e599f1526f5793b26a5e2b0a" translate="yes" xml:space="preserve">
          <source>Alternatively, if you want to read the &lt;code&gt;&quot;data1&quot;&lt;/code&gt; member into memory, use a scalar reference for the &lt;code&gt;output&lt;/code&gt; parameter.</source>
          <target state="translated">または、 &lt;code&gt;&quot;data1&quot;&lt;/code&gt; メンバーをメモリに読み込む場合は、 &lt;code&gt;output&lt;/code&gt; パラメーターにスカラー参照を使用します。</target>
        </trans-unit>
        <trans-unit id="067a937688c2a4c5c986d21853b255fbc5aefe6e" translate="yes" xml:space="preserve">
          <source>Alternatively, one can round the results explicitly using one of &lt;a href=&quot;#round%28%29&quot;&gt;&quot;round()&quot;&lt;/a&gt;, &lt;a href=&quot;#bround%28%29&quot;&gt;&quot;bround()&quot;&lt;/a&gt; or &lt;a href=&quot;#bfround%28%29&quot;&gt;&quot;bfround()&quot;&lt;/a&gt; or by passing the desired accuracy to the method as an additional parameter:</source>
          <target state="translated">または、&lt;a href=&quot;#round%28%29&quot;&gt;「round（）」&lt;/a&gt;、&lt;a href=&quot;#bround%28%29&quot;&gt;「bround（）」&lt;/a&gt;、&lt;a href=&quot;#bfround%28%29&quot;&gt;「bfround（）」の&lt;/a&gt;いずれかを使用するか、追加のパラメーターとしてメソッドに必要な精度を渡すことにより、結果を明示的に丸めることができます。</target>
        </trans-unit>
        <trans-unit id="742c3c00178ebe72a9bfad0e3ef29810b62b04e9" translate="yes" xml:space="preserve">
          <source>Alternatively, put this as the first line of your script:</source>
          <target state="translated">あるいは、これをスクリプトの最初の行として記述することもできます。</target>
        </trans-unit>
        <trans-unit id="daefa0329439a8224d52050e5214c48286284b22" translate="yes" xml:space="preserve">
          <source>Alternatively, rather than having to explicitly name each of the files that you want to compress, you could use a fileglob to select all the &lt;code&gt;txt&lt;/code&gt; files in the current directory, as follows</source>
          <target state="translated">または、圧縮する各ファイルに明示的に名前を付ける必要はなく、fileglobを使用して、次のように現在のディレクトリ内のすべての &lt;code&gt;txt&lt;/code&gt; ファイルを選択できます。</target>
        </trans-unit>
        <trans-unit id="eefa7323e5eca7f13253bb419c7f371832614e4a" translate="yes" xml:space="preserve">
          <source>Alternatively, simply use &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; for comparisons, this always gets it right. There is not yet a way to get a number automatically represented as a string that matches exactly the way Perl represents it.</source>
          <target state="translated">または、単に &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; を使用して比較します。これにより、常に正しくなります。Perlが表す方法と完全に一致する文字列として自動的に表される数値を取得する方法はまだありません。</target>
        </trans-unit>
        <trans-unit id="c44b1aed9efe7eda393df0bd7f553f139ab03a17" translate="yes" xml:space="preserve">
          <source>Alternatively, simply use &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; for comparisons, this will get it always right. There is not yet a way to get a number automatically represented as a string that matches exactly the way Perl represents it.</source>
          <target state="translated">または、比較に &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; を使用するだけで、常に正しい結果が得られます。Perlが表す方法と完全に一致する文字列として自動的に表される数値を取得する方法はまだありません。</target>
        </trans-unit>
        <trans-unit id="055ca33d620827ab022a97400794bf3fb8a2807b" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;a href=&quot;Text::ParseWords&quot;&gt;Text::ParseWords&lt;/a&gt; module (part of the standard Perl distribution) lets you say:</source>
          <target state="translated">あるいは、&lt;a href=&quot;Text::ParseWords&quot;&gt;Text :: ParseWords&lt;/a&gt;モジュール（標準のPerlディストリビューションの一部）では、次のように言うことができます。</target>
        </trans-unit>
        <trans-unit id="8ad4e77e5423588b083e2af8975456f597a84a91" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;a href=&quot;text/parsewords&quot;&gt;Text::ParseWords&lt;/a&gt; module (part of the standard Perl distribution) lets you say:</source>
          <target state="translated">あるいは、&lt;a href=&quot;text/parsewords&quot;&gt;Text :: ParseWords&lt;/a&gt;モジュール（標準のPerlディストリビューションの一部）では、次のように言うことができます。</target>
        </trans-unit>
        <trans-unit id="e3f5b7f0771697b931c8ecd89602848a9590421e" translate="yes" xml:space="preserve">
          <source>Alternatively, the crypt libraries in GNU libc have been ported to Cygwin.</source>
          <target state="translated">あるいは、GNU libc の crypt ライブラリは Cygwin に移植されています。</target>
        </trans-unit>
        <trans-unit id="43ccb7ccf6de944158b57bdf33cf5e43082dfbc3" translate="yes" xml:space="preserve">
          <source>Alternatively, use the macro &lt;a href=&quot;#CopLABEL_len_flags&quot;&gt;&quot;&lt;code&gt;CopLABEL_len_flags&lt;/code&gt;&quot;&lt;/a&gt;; or if you don't need to know if the label is UTF-8 or not, the macro &lt;a href=&quot;#CopLABEL_len&quot;&gt;&quot;&lt;code&gt;CopLABEL_len&lt;/code&gt;&quot;&lt;/a&gt;; or if you additionally dont need to know the length, &lt;a href=&quot;#CopLABEL&quot;&gt;&quot;&lt;code&gt;CopLABEL&lt;/code&gt;&quot;&lt;/a&gt;.</source>
          <target state="translated">または、マクロ&lt;a href=&quot;#CopLABEL_len_flags&quot;&gt;「 &lt;code&gt;CopLABEL_len_flags&lt;/code&gt; 」を&lt;/a&gt;使用します。または、ラベルがUTF-8であるかどうかを知る必要がない場合は、マクロ&lt;a href=&quot;#CopLABEL_len&quot;&gt;&quot; &lt;code&gt;CopLABEL_len&lt;/code&gt; &quot;&lt;/a&gt; ; または、さらに長さを知る必要がない場合は、&lt;a href=&quot;#CopLABEL&quot;&gt;「 &lt;code&gt;CopLABEL&lt;/code&gt; 」&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="996763dc438b824d04ceb178a7d6d2de1f4e3617" translate="yes" xml:space="preserve">
          <source>Alternatively, using a customized typemap for your purposes in the first place is probably preferable.</source>
          <target state="translated">あるいは、そもそもの目的に合わせてカスタマイズされたタイプマップを使用することが望ましいでしょう。</target>
        </trans-unit>
        <trans-unit id="818d3daf2781969164beb46d939858b0992b14b8" translate="yes" xml:space="preserve">
          <source>Alternatively, we could have used &lt;code&gt;C&lt;/code&gt; to unpack the individually accessible byte registers FL, FH, AL, AH, etc.:</source>
          <target state="translated">あるいは、 &lt;code&gt;C&lt;/code&gt; を使用して、個別にアクセス可能なバイトレジスタFL、FH、AL、AHなどをアンパックすることもできます。</target>
        </trans-unit>
        <trans-unit id="87ca4d1f50f588b444c138934de28912a7c4fa3d" translate="yes" xml:space="preserve">
          <source>Alternatively, we might be able to use a command line option such as -R</source>
          <target state="translated">あるいは、-R のようなコマンドラインオプションを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="16c917006b223001c63f85b3d40138b38f9bf9a9" translate="yes" xml:space="preserve">
          <source>Alternatively, you can achieve a similar static effect by declaring the variable in a separate block outside the function, e.g.,</source>
          <target state="translated">あるいは、関数の外側の別のブロックで変数を宣言することで、同様の静的効果を得ることができます。</target>
        </trans-unit>
        <trans-unit id="973c34c798c56bb32a7153f1be5f39dd390df9c7" translate="yes" xml:space="preserve">
          <source>Alternatively, you can fiddle with the stack directly: &lt;code&gt;SP&lt;/code&gt; gives you the first element in your portion of the stack, and &lt;code&gt;TOP*&lt;/code&gt; gives you the top SV/IV/NV/etc. on the stack. So, for instance, to do unary negation of an integer:</source>
          <target state="translated">または、スタックを直接いじることもできます &lt;code&gt;SP&lt;/code&gt; はスタックの一部の最初の要素を提供し、 &lt;code&gt;TOP*&lt;/code&gt; は上位のSV / IV / NV /などを提供します。スタック上。したがって、たとえば、整数の単項否定を行うには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="4486c955e53dc63730c2501b04fe03ec6d1fb66c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can quote the class name:</source>
          <target state="translated">あるいは、クラス名を引用することもできます。</target>
        </trans-unit>
        <trans-unit id="3dc4c1bc0515a5f540589d100b6ce1224a32ad91" translate="yes" xml:space="preserve">
          <source>Alternatively, you can specify that the option can have multiple values by adding a &quot;@&quot;, and pass a reference to a scalar as the destination:</source>
          <target state="translated">あるいは、オプションに &quot;@&quot; を追加して複数の値を指定し、スカラへの参照を宛先として渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="9393a15204a23768f5fb6e120d832da535fff827" translate="yes" xml:space="preserve">
          <source>Alternatively, you can specify that the option can have multiple values by adding a &quot;@&quot;, and pass a scalar reference as the destination:</source>
          <target state="translated">あるいは、オプションに&quot;@&quot;を追加して複数の値を持つことができるように指定し、スカラ参照を宛先として渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="86794ed15412a1fa79e33d4ba8f3e04841c9eebc" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the &lt;code&gt;plan()&lt;/code&gt; function. Useful for when you have to calculate the number of tests.</source>
          <target state="translated">または、 &lt;code&gt;plan()&lt;/code&gt; 関数を使用することもできます。テストの数を計算する必要がある場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="bd695ed1549655fbf2b6a69e34efa112b5887ecd" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the GCC_EXEC_PREFIX environment variable to ensure that Sun's as and ld are used. Consult your gcc documentation for further information on the -B option and the GCC_EXEC_PREFIX variable.</source>
          <target state="translated">あるいは、GCC_EXEC_PREFIX 環境変数を使用して、Sun の as と ld が確実に使用されるようにすることもできます。BオプションとGCC_EXEC_PREFIX変数の詳細については、gccのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="ee23e1f9045483d4017c29efb93306a8f81a02a3" translate="yes" xml:space="preserve">
          <source>Alternatively, you may inspect the value of &lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt;&lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;posix#WIFEXITED&quot;&gt;&lt;code&gt;W*()&lt;/code&gt;&lt;/a&gt; calls from the &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module.</source>
          <target state="translated">別の方法として、次の値検査することができる&lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt; &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; &lt;/a&gt;との&lt;a href=&quot;posix#WIFEXITED&quot;&gt; &lt;code&gt;W*()&lt;/code&gt; &lt;/a&gt;からの呼び出し&lt;a href=&quot;posix&quot;&gt;のPOSIX&lt;/a&gt;モジュールを。</target>
        </trans-unit>
        <trans-unit id="5e3eb7cca34a1ce6ec3422f81caa582587938fc9" translate="yes" xml:space="preserve">
          <source>Alternatively, you may inspect the value of &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; with the &lt;code&gt;W*()&lt;/code&gt; calls from the POSIX module.</source>
          <target state="translated">別の方法として、次の値検査することができる &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; との &lt;code&gt;W*()&lt;/code&gt; POSIXモジュールからの呼び出しを。</target>
        </trans-unit>
        <trans-unit id="273eb19a8880a15607895e1cd30f571a681e7c99" translate="yes" xml:space="preserve">
          <source>Alternatively, you may pass a single &lt;code&gt;ExtUtils::Typemaps::InputMap&lt;/code&gt; object.</source>
          <target state="translated">または、単一の &lt;code&gt;ExtUtils::Typemaps::InputMap&lt;/code&gt; オブジェクトを渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="98574b24c9752f26b07d4e571e873801f591432e" translate="yes" xml:space="preserve">
          <source>Alternatively, you may pass a single &lt;code&gt;ExtUtils::Typemaps::OutputMap&lt;/code&gt; object.</source>
          <target state="translated">または、単一の &lt;code&gt;ExtUtils::Typemaps::OutputMap&lt;/code&gt; オブジェクトを渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="3baaa9fdf5df5a376581f707e9bd2202f9c63495" translate="yes" xml:space="preserve">
          <source>Alternatively, you may pass a single &lt;code&gt;ExtUtils::Typemaps::Type&lt;/code&gt; object.</source>
          <target state="translated">または、単一の &lt;code&gt;ExtUtils::Typemaps::Type&lt;/code&gt; オブジェクトを渡すこともできます。</target>
        </trans-unit>
        <trans-unit id="efc46e4aa2514a5747d9e66b804729fd4f6f91eb" translate="yes" xml:space="preserve">
          <source>Alternatives are tried from left to right, so the first alternative found for which the entire expression matches, is the one that is chosen. This means that alternatives are not necessarily greedy. For example: when matching &lt;code&gt;foo|foot&lt;/code&gt; against &quot;barefoot&quot;, only the &quot;foo&quot; part will match, as that is the first alternative tried, and it successfully matches the target string. (This might not seem important, but it is important when you are capturing matched text using parentheses.)</source>
          <target state="translated">選択肢は左から右に試行されるため、式全体が一致する最初に見つかった選択肢が選択されます。これは、選択肢が必ずしも貪欲ではないことを意味します。例： &lt;code&gt;foo|foot&lt;/code&gt; を &quot;barefoot&quot;と照合する場合、 &quot;foo&quot;の部分のみが一致します。これは、最初に試行された代替であり、ターゲット文字列と正常に一致するためです。（これは重要ではないように見えるかもしれませんが、括弧を使用して一致したテキストをキャプチャする場合は重要です。）</target>
        </trans-unit>
        <trans-unit id="c8af2aafd15c21262760094a19550be8139535e2" translate="yes" xml:space="preserve">
          <source>Alternatives are tried from left to right, so the first alternative found for which the entire expression matches, is the one that is chosen. This means that alternatives are not necessarily greedy. For example: when matching &lt;code&gt;foo|foot&lt;/code&gt; against &lt;code&gt;&quot;barefoot&quot;&lt;/code&gt;, only the &lt;code&gt;&quot;foo&quot;&lt;/code&gt; part will match, as that is the first alternative tried, and it successfully matches the target string. (This might not seem important, but it is important when you are capturing matched text using parentheses.)</source>
          <target state="translated">代替案は左から右に試行されるため、式全体が一致する最初の代替案が選択されます。これは、代替案が必ずしも貪欲ではないことを意味します。例： &lt;code&gt;foo|foot&lt;/code&gt; を &lt;code&gt;&quot;barefoot&quot;&lt;/code&gt; と照合する場合、 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 部分のみが照合されます。これは、最初に試行された選択肢であり、ターゲット文字列と正常に照合されます。（これは重要ではないように思われるかもしれませんが、括弧を使用して一致したテキストをキャプチャする場合は重要です。）</target>
        </trans-unit>
        <trans-unit id="178ef3c8a39076052130de80299d367dd5e6090f" translate="yes" xml:space="preserve">
          <source>Alternatives to raw</source>
          <target state="translated">生の代替品</target>
        </trans-unit>
        <trans-unit id="52a09d99c8be7488acf8d5679596a3a7ebeeb466" translate="yes" xml:space="preserve">
          <source>Alternatives: &lt;a href=&quot;Test2::AsyncSubtest&quot;&gt;Test2::AsyncSubtest&lt;/a&gt; and &lt;a href=&quot;Test2::Workflow&quot;&gt;Test2::Workflow&lt;/a&gt; (not stable).</source>
          <target state="translated">代替案：&lt;a href=&quot;Test2::AsyncSubtest&quot;&gt;Test2 :: AsyncSubtest&lt;/a&gt;および&lt;a href=&quot;Test2::Workflow&quot;&gt;Test2 :: Workflow&lt;/a&gt;（安定していません）。</target>
        </trans-unit>
        <trans-unit id="dcc6e5f9721668e6a6d8a7cd85c26663fa384cb4" translate="yes" xml:space="preserve">
          <source>Alternativly look at &lt;a href=&quot;Plack::Middleware::Auth::Basic&quot;&gt;Plack::Middleware::Auth::Basic&lt;/a&gt;, or one of the other &lt;a href=&quot;https://metacpan.org/search?q=plack+auth&quot;&gt;Plack authentication&lt;/a&gt; options.</source>
          <target state="translated">または、&lt;a href=&quot;Plack::Middleware::Auth::Basic&quot;&gt;Plack :: Middleware :: Auth :: Basic&lt;/a&gt;、または他の&lt;a href=&quot;https://metacpan.org/search?q=plack+auth&quot;&gt;Plack認証&lt;/a&gt;オプションの1つを確認してください。</target>
        </trans-unit>
        <trans-unit id="895965b31db8e4bfa4de954e884b587830b4927d" translate="yes" xml:space="preserve">
          <source>Alternativly look at &lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Auth::Basic&quot;&gt;Plack::Middleware::Auth::Basic&lt;/a&gt;, or one of the other &lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%2bauth&quot;&gt;Plack authentication&lt;/a&gt; options.</source>
          <target state="translated">代わりに、&lt;a href=&quot;http://search.cpan.org/perldoc/Plack::Middleware::Auth::Basic&quot;&gt;Plack :: Middleware :: Auth :: Basic&lt;/a&gt;または他の&lt;a href=&quot;http://search.cpan.org/perldoc/https:#%2fmetacpan.org%2fsearch%3fq%3dplack%2bauth&quot;&gt;Plack認証&lt;/a&gt;オプションの1つを確認してください。</target>
        </trans-unit>
        <trans-unit id="083655cd712cf57272ed2f0a7a5805f36d9802f0" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; cannot do this directly, there is a module which can layer transparently over &lt;b&gt;DB_File&lt;/b&gt; to accomplish this feat.</source>
          <target state="translated">けれども&lt;b&gt;はDB_Fileは&lt;/b&gt;直接これを行うことはできません、上に透過層ができモジュールがあり&lt;b&gt;DB_Fileで&lt;/b&gt;この偉業を達成します。</target>
        </trans-unit>
        <trans-unit id="3768f14455445c5980f80214d4ffa65dc7a14002" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; is covered by the Perl license, the library it makes use of, namely Berkeley DB, is not. Berkeley DB has its own copyright and its own license. Please take the time to read it.</source>
          <target state="translated">けれども&lt;b&gt;のDB_Fileは、&lt;/b&gt; Perlのライセンスでカバーされ、ライブラリーは、それは、つまりBerkeley DBは、を利用していません。Berkeley DBには、独自の著作権と独自のライセンスがあります。時間をかけて読んでください。</target>
        </trans-unit>
        <trans-unit id="73b1840016122f68e05350fe0f1ab0303bd2fd8b" translate="yes" xml:space="preserve">
          <source>Although &lt;b&gt;DB_File&lt;/b&gt; is intended to be used with Berkeley DB version 1, it can also be used with version 2, 3 or 4. In this case the interface is limited to the functionality provided by Berkeley DB 1.x. Anywhere the version 2 or greater interface differs, &lt;b&gt;DB_File&lt;/b&gt; arranges for it to work like version 1. This feature allows &lt;b&gt;DB_File&lt;/b&gt; scripts that were built with version 1 to be migrated to version 2 or greater without any changes.</source>
          <target state="translated">けれども&lt;b&gt;はDB_Fileを&lt;/b&gt; Berkeley DBバージョン1を使用することを意図され、それはこの場合にも、バージョン2、3または4で使用することができるインタフェースはバークレイDB 1.xのによって提供される機能に制限され バージョン2以降のインターフェースが異なる場合、&lt;b&gt;DB_File&lt;/b&gt;はバージョン1のように動作するように&lt;b&gt;調整し&lt;/b&gt;ます。この機能により、バージョン1でビルドされた&lt;b&gt;DB_File&lt;/b&gt;スクリプトを変更せずにバージョン2以降に移行できます。</target>
        </trans-unit>
        <trans-unit id="a4ee4e9c8be6f9bb865a03f9dd6635b3149d28d3" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;$_&lt;/code&gt; doesn't actually appear explicitly in the sample filters above, it is implicitly used in a number of places.</source>
          <target state="translated">が &lt;code&gt;$_&lt;/code&gt; 実際に上記のサンプルフィルタで明示的に表示されません、それは暗黙のうちに多くの場所で使用されています。</target>
        </trans-unit>
        <trans-unit id="80dfb6d994a40fa49e44520920eac36d9fa1f16f" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; is false on a plain not-yet-used hash, it becomes true in several non-obvious circumstances, including iterators, weak references, stash names, even remaining true after &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; . These things make &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; fairly useless in practice, so it now generates a fatal error.</source>
          <target state="translated">が &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; 、プレーン未使用されるハッシュに偽で、それも後に真の残り、イテレータ、弱い参照、隠し名を含む、いくつかの非自明な状況で真となり &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt; %hash&lt;/code&gt; 。これらのことは、 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; %hash&lt;/code&gt; を実際にはかなり役に立たないようにするため、致命的なエラーを生成します。</target>
        </trans-unit>
        <trans-unit id="7ff687f6589d5bc55ea5b6cd3b7acf0a8989e998" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;Compress::Zlib&lt;/code&gt; has a pair of functions called &lt;code&gt;compress&lt;/code&gt; and &lt;code&gt;uncompress&lt;/code&gt;, they are</source>
          <target state="translated">が &lt;code&gt;Compress::Zlib&lt;/code&gt; 呼び出される関数のペアがある &lt;code&gt;compress&lt;/code&gt; と &lt;code&gt;uncompress&lt;/code&gt; 、彼らがあります</target>
        </trans-unit>
        <trans-unit id="df1f79335b5e25baa8b910d3ca247a13fd7eda4e" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;cmp_ok()&lt;/code&gt; was introduced in 0.40, 0.86 fixed an important bug to make it safe for overloaded objects; the fixed first shipped with Perl in 5.10.1 as part of Test::More 0.92.</source>
          <target state="translated">けれども &lt;code&gt;cmp_ok()&lt;/code&gt; が 0.40で導入された、0.86は、オーバーロードされたオブジェクトのためにそれを安全にするために重要なバグを修正しました。この修正は、Test :: More 0.92の一部として5.10.1でPerlとともに最初に出荷されました。</target>
        </trans-unit>
        <trans-unit id="a46f1c081d434cfa72b0670296268695a927ef72" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;defined %hash&lt;/code&gt; is false on a plain not-yet-used hash, it becomes true in several non-obvious circumstances, including iterators, weak references, stash names, even remaining true after &lt;code&gt;undef %hash&lt;/code&gt;. These things make &lt;code&gt;defined %hash&lt;/code&gt; fairly useless in practice, so it now generates a fatal error.</source>
          <target state="translated">が &lt;code&gt;defined %hash&lt;/code&gt; 、プレーン未使用されるハッシュに偽で、それも後に真の残り、イテレータ、弱い参照、隠し名を含む、いくつかの非自明な状況で真となり &lt;code&gt;undef %hash&lt;/code&gt; 。これらのことにより、 &lt;code&gt;defined %hash&lt;/code&gt; は実際にはかなり役に立たなくなるため、致命的なエラーが生成されるようになりました。</target>
        </trans-unit>
        <trans-unit id="1c4fc726a9484b19113d6eedd6d8805f1968eb73" translate="yes" xml:space="preserve">
          <source>Although FileCache can be used with piped opens ('-|' or '|-') doing so is strongly discouraged. If FileCache finds it necessary to close and then reopen a pipe, the command at the far end of the pipe will be reexecuted - the results of performing IO on FileCache'd pipes is unlikely to be what you expect. The ability to use FileCache on pipes may be removed in a future release.</source>
          <target state="translated">FileCache はパイプオープン ('-|' または '|-')と共に使用することができますが、これは強くお勧めしません。FileCache がパイプを閉じて再度開く必要があると判断した場合、パイプの最後尾にあるコマンドが再実行されます-FileCache'd パイプで IO を実行した結果は期待したものではありません。パイプ上で FileCache を使用する機能は、将来のリリースで削除される可能性があります。</target>
        </trans-unit>
        <trans-unit id="077804ce34db1c72deaf81a9a83f1e62f8a114a7" translate="yes" xml:space="preserve">
          <source>Although I have made use of only the &lt;code&gt;POP*&lt;/code&gt; macros to access values returned from Perl subroutines, it is also possible to bypass these macros and read the stack using the &lt;code&gt;ST&lt;/code&gt; macro (See &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; for a full description of the &lt;code&gt;ST&lt;/code&gt; macro).</source>
          <target state="translated">私は唯一の利用作ってきたが &lt;code&gt;POP*&lt;/code&gt; Perlのサブルーチンから返されたアクセス値にマクロを、それがこれらのマクロバイパスすることも可能であるし、使用してスタックを読ん &lt;code&gt;ST&lt;/code&gt; のマクロを（参照&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt;の完全な説明のための &lt;code&gt;ST&lt;/code&gt; のマクロを）。</target>
        </trans-unit>
        <trans-unit id="ebf0c3d2a317483257bd5985b5509d45e615f5a4" translate="yes" xml:space="preserve">
          <source>Although PA-RISC binaries can run on Itanium systems, you should not attempt to use a PA-RISC version of Perl on an Itanium system. This is because shared libraries created on an Itanium system cannot be loaded while running a PA-RISC executable.</source>
          <target state="translated">PA-RISCバイナリはItaniumシステム上でも動作しますが、Itaniumシステム上でPA-RISC版のPerlを使用しようとするべきではありません。これは、Itaniumシステム上で作成された共有ライブラリは、PA-RISC実行ファイルを実行している間はロードできないからです。</target>
        </trans-unit>
        <trans-unit id="2b071251c66f97d7a5a833d31d9bbb833fc948ef" translate="yes" xml:space="preserve">
          <source>Although Perl will automatically grow strings for you, if you need to force Perl to allocate more memory for your SV, you can use the macro</source>
          <target state="translated">Perl は自動的に文字列を成長させてくれますが、Perl が SV にもっと多くのメモリを割り当てる必要がある場合は、マクロを使用します。</target>
        </trans-unit>
        <trans-unit id="3fece6ab5bd6d283eb840842e215942103cb610e" translate="yes" xml:space="preserve">
          <source>Although Plan 9 Perl currently only provides static loading, it is built with a number of useful extensions. These include Opcode, FileHandle, Fcntl, and POSIX. Expect to see others (and DynaLoading!) in the future.</source>
          <target state="translated">Plan 9 Perl は現在、スタティック・ローディングのみを提供していますが、多くの便利な拡張機能で構築されています。これらには、Opcode、FileHandle、Fcntl、POSIX が含まれます。将来的には、他の拡張機能(とDynaLoadingも!)に期待してください。</target>
        </trans-unit>
        <trans-unit id="e4e6f6df84571e93788f39ee96ef2a5f0752bec2" translate="yes" xml:space="preserve">
          <source>Although Test::More has been a core module in versions of Perl since 5.6.2, Test::More has evolved since then, and not all of the features you're used to will be present in the shipped version of Test::More. If you are writing a module, don't forget to indicate in your package metadata the minimum version of Test::More that you require. For instance, if you want to use &lt;code&gt;done_testing()&lt;/code&gt; but want your test script to run on Perl 5.10.0, you will need to explicitly require Test::More &amp;gt; 0.88.</source>
          <target state="translated">Test :: Moreは5.6.2以降のバージョンのPerlのコアモジュールですが、Test :: Moreはそれ以降進化しており、使い慣れたすべての機能が出荷されたバージョンのTest ::に存在するわけではありません。もっと。モジュールを作成する場合は、パッケージメタデータで、必要なTest :: Moreの最小バージョンを示すことを忘れないでください。たとえば、 &lt;code&gt;done_testing()&lt;/code&gt; を使用したいが、テストスクリプトをPerl 5.10.0で実行したい場合は、Test :: More&amp;gt; 0.88を明示的に要求する必要があります。</target>
        </trans-unit>
        <trans-unit id="4b6eb7d4608b6bb5e2737f99ed626a9c3d3fdff3" translate="yes" xml:space="preserve">
          <source>Although all mathematical operations on version objects are forbidden by default, it is possible to retrieve a number which corresponds to the version object through the use of the $obj-&amp;gt;numify method. For formatting purposes, when displaying a number which corresponds a version object, all sub versions are assumed to have three decimal places. So for example:</source>
          <target state="translated">バージョンオブジェクトに対するすべての数学演算はデフォルトで禁止されていますが、$ obj-&amp;gt; numifyメソッドを使用して、バージョンオブジェクトに対応する数値を取得することができます。フォーマットの目的で、バージョンオブジェクトに対応する数値を表示する場合、すべてのサブバージョンは小数点以下3桁であると見なされます。したがって、たとえば：</target>
        </trans-unit>
        <trans-unit id="a0cac5f469f6b90c62f4e56ab4bfa747637957a2" translate="yes" xml:space="preserve">
          <source>Although as of 5.14, that can be also be accomplished this way:</source>
          <target state="translated">5.14の時点では、このようにすることも可能です。</target>
        </trans-unit>
        <trans-unit id="06dbd031cbe601d39502de2a4b463b8de205125c" translate="yes" xml:space="preserve">
          <source>Although at first sight there seems to be quite a lot going on in &lt;code&gt;Apache::GZip&lt;/code&gt;, you could sum up what the code was doing as follows -- read the contents of the file in &lt;code&gt;$r-&amp;gt;filename&lt;/code&gt;, compress it and write the compressed data to standard output. That's all.</source>
          <target state="translated">一見、 &lt;code&gt;Apache::GZip&lt;/code&gt; でかなり多くのことが行われているように見えますが、コードが何をしていたかを次のように要約できます。 &lt;code&gt;$r-&amp;gt;filename&lt;/code&gt; でファイルの内容を読み取り、圧縮して、データを標準出力に圧縮します。それで全部です。</target>
        </trans-unit>
        <trans-unit id="b446ed3017bd4a5c94fd715dbc357d36cd8b9eae" translate="yes" xml:space="preserve">
          <source>Although if your manager accused you of seeking job security (or rapid insecurity) through inscrutable code, it would be hard to argue. :-) If I were you, I'd put that in a function:</source>
          <target state="translated">もしあなたの上司が、不可解なコードを使って仕事の安全性(または急速な不安)を求めていると非難したとしたら、反論するのは難しいでしょうが。私があなただったら、それを関数に入れますね。</target>
        </trans-unit>
        <trans-unit id="4a4e26bb6dd1017566ef68d6d6d4ea499d6e917f" translate="yes" xml:space="preserve">
          <source>Although it has no direct equivalent in C, Perl's &lt;code&gt;//&lt;/code&gt; operator is related to its C-style &quot;or&quot;. In fact, it's exactly the same as &lt;code&gt;||&lt;/code&gt;, except that it tests the left hand side's definedness instead of its truth. Thus, &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; returns the value of &lt;code&gt;EXPR1&lt;/code&gt; if it's defined, otherwise, the value of &lt;code&gt;EXPR2&lt;/code&gt; is returned. (&lt;code&gt;EXPR1&lt;/code&gt; is evaluated in scalar context, &lt;code&gt;EXPR2&lt;/code&gt; in the context of &lt;code&gt;//&lt;/code&gt; itself). Usually, this is the same result as &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; (except that the ternary-operator form can be used as a lvalue, while &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; cannot). This is very useful for providing default values for variables. If you actually want to test if at least one of &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; is defined, use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;($x // $y)&lt;/code&gt; .</source>
          <target state="translated">Cには直接同等のものはありませんが、Perlの &lt;code&gt;//&lt;/code&gt; 演算子はCスタイルの「or」に関連しています。実際、 &lt;code&gt;||&lt;/code&gt; とまったく同じです。、それはその真実の代わりに左側の定義をテストすることを除いて。したがって、 &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; は、定義されている場合は &lt;code&gt;EXPR1&lt;/code&gt; の値を返し、定義されていない場合は &lt;code&gt;EXPR2&lt;/code&gt; の値を返します。 （ &lt;code&gt;EXPR1&lt;/code&gt; はスカラーコンテキストで評価され、 &lt;code&gt;EXPR2&lt;/code&gt; は &lt;code&gt;//&lt;/code&gt; 自体のコンテキストで評価されます）。通常、これは &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; たものと同じ結果です（EXPR1）？ EXPR1：EXPR2（三項演算子形式を左辺値として使用できることを除いて、 &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; できません）。これは、変数のデフォルト値を提供するのに非常に役立ちます。 &lt;code&gt;$x&lt;/code&gt; と &lt;code&gt;$y&lt;/code&gt; 少なくとも1つが定義されているかどうかを実際にテストする場合は、 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;($x // $y)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="7fb2cc3c9a7a9c586fba874bcd544c7350b090af" translate="yes" xml:space="preserve">
          <source>Although it has no direct equivalent in C, Perl's &lt;code&gt;//&lt;/code&gt; operator is related to its C-style &quot;or&quot;. In fact, it's exactly the same as &lt;code&gt;||&lt;/code&gt;, except that it tests the left hand side's definedness instead of its truth. Thus, &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; returns the value of &lt;code&gt;EXPR1&lt;/code&gt; if it's defined, otherwise, the value of &lt;code&gt;EXPR2&lt;/code&gt; is returned. (&lt;code&gt;EXPR1&lt;/code&gt; is evaluated in scalar context, &lt;code&gt;EXPR2&lt;/code&gt; in the context of &lt;code&gt;//&lt;/code&gt; itself). Usually, this is the same result as &lt;code&gt;defined(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; (except that the ternary-operator form can be used as a lvalue, while &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; cannot). This is very useful for providing default values for variables. If you actually want to test if at least one of &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt; is defined, use &lt;code&gt;defined($x // $y)&lt;/code&gt;.</source>
          <target state="translated">Cには直接同等のものはありませんが、Perlの &lt;code&gt;//&lt;/code&gt; 演算子はCスタイルの「または」に関連しています。実際、それは &lt;code&gt;||&lt;/code&gt; とまったく同じです。、ただし、真実ではなく左側の定義をテストします。したがって、 &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; は、定義されている場合は &lt;code&gt;EXPR1&lt;/code&gt; の値を返し、そうでない場合は &lt;code&gt;EXPR2&lt;/code&gt; の値を返します。 （ &lt;code&gt;EXPR1&lt;/code&gt; はスカラーコンテキストで評価され、 &lt;code&gt;EXPR2&lt;/code&gt; は &lt;code&gt;//&lt;/code&gt; 自体のコンテキストで評価されます）。通常、これは &lt;code&gt;defined(EXPR1) ? EXPR1 : EXPR2&lt;/code&gt; と同じ結果ですか？ EXPR1：EXPR2（ただし、三項演算子形式は左辺値として使用できますが、 &lt;code&gt;EXPR1 // EXPR2&lt;/code&gt; できません）。これは、変数のデフォルト値を提供するのに非常に役立ちます。 &lt;code&gt;$x&lt;/code&gt; と &lt;code&gt;$y&lt;/code&gt; 少なくとも1つが定義されているかどうかを実際にテストする場合は、 &lt;code&gt;defined($x // $y)&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="3d57a21b7f19f0f3f2ceca275a472340c6e4e3a5" translate="yes" xml:space="preserve">
          <source>Although it has the same precedence as in C, Perl's &lt;code&gt;?:&lt;/code&gt; operator produces an lvalue. This assigns $x to either $if_true or $if_false, depending on the trueness of $maybe:</source>
          <target state="translated">Cと同じ優先順位 &lt;code&gt;?:&lt;/code&gt; 、Perlの？：演算子は左辺値を生成します。これは、$ maybeの真実性に応じて、$ xを$ if_trueまたは$ if_falseに割り当てます。</target>
        </trans-unit>
        <trans-unit id="5ee0b4360c14601bcb250b62e156bc4ae2010689" translate="yes" xml:space="preserve">
          <source>Although it is a bit confusing and some people object to the terminology, it is worth taking a look at a comment that has been in</source>
          <target state="translated">少し混乱していて、用語に反対する人もいるようですが、以下のようなコメントを見てみる価値はあります。</target>
        </trans-unit>
        <trans-unit id="da1e430c6e0d63cde26c5c8c71827f0d44bf6196" translate="yes" xml:space="preserve">
          <source>Although it is not illegal, the use of &lt;code&gt;MultiHomed&lt;/code&gt; on a socket which is in non-blocking mode is of little use. This is because the first connect will never fail with a timeout as the connect call will not block.</source>
          <target state="translated">違法ではありませんが、非ブロッキングモードのソケットで &lt;code&gt;MultiHomed&lt;/code&gt; を使用してもほとんど役に立ちません。これは、接続呼び出しがブロックされないため、最初の接続がタイムアウトで失敗することはないためです。</target>
        </trans-unit>
        <trans-unit id="e93362b29f52a34d35cc322a788d526233d087a7" translate="yes" xml:space="preserve">
          <source>Although it is possible (with some effort on your part) to use this module to access .zip files, there are other perl modules available that will do all the hard work for you. Check out &lt;code&gt;Archive::Zip&lt;/code&gt; , &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; , &lt;code&gt;IO::Compress::Zip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt; .</source>
          <target state="translated">このモジュールを使用して.zipファイルにアクセスすることは（ある程度の努力を払って）可能ですが、他のperlモジュールを使用して、すべてのハードワークを行うことができます。 &lt;code&gt;Archive::Zip&lt;/code&gt; 、 &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; 、 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; および &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt; 確認してください。</target>
        </trans-unit>
        <trans-unit id="7c711291979b77793d98593cadd4dda9f5e5ad0f" translate="yes" xml:space="preserve">
          <source>Although it is possible (with some effort on your part) to use this module to access .zip files, there are other perl modules available that will do all the hard work for you. Check out &lt;code&gt;Archive::Zip&lt;/code&gt;, &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt;, &lt;code&gt;IO::Compress::Zip&lt;/code&gt; and &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt;.</source>
          <target state="translated">このモジュールを使用して.zipファイルにアクセスすることは（あなたの側でいくらかの努力を払って）可能ですが、あなたのためにすべての大変な仕事をする他のperlモジュールが利用可能です。 &lt;code&gt;Archive::Zip&lt;/code&gt; 、 &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; 、 &lt;code&gt;IO::Compress::Zip&lt;/code&gt; 、 &lt;code&gt;IO::Uncompress::Unzip&lt;/code&gt; 確認してください。</target>
        </trans-unit>
        <trans-unit id="7a135fdb236629c700a0674370bcc8d9bb97bd72" translate="yes" xml:space="preserve">
          <source>Although it may be considered internal, the class hierarchy does matter for both users and programmer. CPAN.pm deals with the four classes mentioned above, and those classes all share a set of methods. Classical single polymorphism is in effect. A metaclass object registers all objects of all kinds and indexes them with a string. The strings referencing objects have a separated namespace (well, not completely separated):</source>
          <target state="translated">内部的なものと思われるかもしれませんが、クラスの階層はユーザとプログラマの両方にとって重要です。CPAN.pmは上記の4つのクラスを扱い、それらのクラスはすべてメソッドのセットを共有しています。古典的な単一多相性が有効です。メタクラスオブジェクトは、あらゆる種類のオブジェクトを登録し、文字列でインデックスを付けます。オブジェクトを参照する文字列は分離された名前空間を持っています(まあ、完全に分離されているわけではありませんが)。</target>
        </trans-unit>
        <trans-unit id="c770d25bc14389e491ccd1785ab555be61626cb8" translate="yes" xml:space="preserve">
          <source>Although it may not be immediately obvious from the code above, the associative array interface can be used to write values with duplicate keys, but it cannot be used to read them back from the database.</source>
          <target state="translated">上のコードではすぐにはわからないかもしれませんが、連想配列のインターフェイスは キーが重複している値を書き込むのには使えますが、データベースから読み出すのには使えません。</target>
        </trans-unit>
        <trans-unit id="180ef42cd3ef3f7ed108e6700423675760cce278" translate="yes" xml:space="preserve">
          <source>Although it might seem like a real pain, it is really worth the effort of having a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; in all your scripts.</source>
          <target state="translated">それは本当の痛みのように思えるかもしれませんが、すべてのスクリプトで &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict&lt;/code&gt; を使用する努力をする価値はあります。</target>
        </trans-unit>
        <trans-unit id="566dc93bd22756361b44728a27034002b97a3383" translate="yes" xml:space="preserve">
          <source>Although it might seem like a real pain, it is really worth the effort of having a &lt;code&gt;use strict&lt;/code&gt; in all your scripts.</source>
          <target state="translated">本当に苦痛に思えるかもしれませんが、すべてのスクリプトで &lt;code&gt;use strict&lt;/code&gt; に使用することは本当に価値があります。</target>
        </trans-unit>
        <trans-unit id="1bf682b28167943a367ab8e4c8b1a462063a4d50" translate="yes" xml:space="preserve">
          <source>Although it's less convenient in some ways than the tied hash interface, you can also call methods directly to manipulate individual symbols. In some cases, this allows you finer control than using a tied hash aggregate. The following methods are supported:</source>
          <target state="translated">紐付きハッシュインターフェースよりも便利な点もありますが、個々のシンボルを操作するために直接メソッドを呼び出すこともできます。場合によっては、タイドハッシュの集合体を使用するよりも細かい制御が可能になります。以下のメソッドがサポートされています。</target>
        </trans-unit>
        <trans-unit id="7eddb5fd279be6b295018b9f9f42e02ddccfda46" translate="yes" xml:space="preserve">
          <source>Although memory overhead of bigger buckets is kept inside the bucket, for smaller buckets, it is kept in separate areas. This field gives the total size of these areas.</source>
          <target state="translated">大きなバケットのメモリオーバーヘッドはバケット内に保持されますが、小さなバケットの場合は別の領域に保持されます。このフィールドは、これらの領域の合計サイズを与えます。</target>
        </trans-unit>
        <trans-unit id="89dede28bef0b8e7f141797013c579678fb08474" translate="yes" xml:space="preserve">
          <source>Although no warning is currently raised, the results are not well defined when these operations are performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot;&lt;/a&gt;).</source>
          <target state="translated">現在警告は出されていませんが、これらの演算が数値（&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;「整数演算」を&lt;/a&gt;参照）でも&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;ビット文字列&lt;/a&gt;（「ビット単位の文字列演算子」を参照）でもないオペランドで実行された場合、結果は明確に定義されません。</target>
        </trans-unit>
        <trans-unit id="5fe78f913ab3f5713143fe4461404c36ff017beb" translate="yes" xml:space="preserve">
          <source>Although no warning is currently raised, the results are not well defined when these operations are performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;).</source>
          <target state="translated">現在警告は出されていませんが、数値（&lt;a href=&quot;#Integer-Arithmetic&quot;&gt;整数演算を&lt;/a&gt;参照）または&lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;ビット文字列&lt;/a&gt;（ビットごとの文字列演算子を参照）ではないオペランドに対してこれらの演算を実行すると、結果は明確に定義されません。</target>
        </trans-unit>
        <trans-unit id="c94501363b8d49d883be5ef00569dcb0d5283b0f" translate="yes" xml:space="preserve">
          <source>Although not for the faint of heart, Perl does support a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; statement. There are three forms: &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-LABEL, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-EXPR, and &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-&amp;amp;NAME. A loop's LABEL is not actually a valid target for a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;; it's just the name of the loop.</source>
          <target state="translated">気弱な人には向いていませんが、Perlは &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; ステートメントをサポートしています。 ：三つの形式があり &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -label、 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -EXPR、そして &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; - ＆NAMEは。ループのLABELは実際には &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; の有効なターゲットではありません。それは単にループの名前です。</target>
        </trans-unit>
        <trans-unit id="1069922d0daa5d3be0e9150c826b5a6eaf7851b6" translate="yes" xml:space="preserve">
          <source>Although not for the faint of heart, Perl does support a &lt;code&gt;goto&lt;/code&gt; statement. There are three forms: &lt;code&gt;goto&lt;/code&gt;-LABEL, &lt;code&gt;goto&lt;/code&gt;-EXPR, and &lt;code&gt;goto&lt;/code&gt;-&amp;amp;NAME. A loop's LABEL is not actually a valid target for a &lt;code&gt;goto&lt;/code&gt;; it's just the name of the loop.</source>
          <target state="translated">気弱な人向けではありませんが、Perlは &lt;code&gt;goto&lt;/code&gt; ステートメントをサポートしています。：三つの形式があり &lt;code&gt;goto&lt;/code&gt; -label、 &lt;code&gt;goto&lt;/code&gt; -EXPR、そして &lt;code&gt;goto&lt;/code&gt; - ＆NAMEは。ループのLABELは、実際には &lt;code&gt;goto&lt;/code&gt; の有効なターゲットではありません。ループの名前です。</target>
        </trans-unit>
        <trans-unit id="c556c081516373f750515951f1b9a5217dc9bdfc" translate="yes" xml:space="preserve">
          <source>Although one can already do quite a lot with the literal string regexps above, we've only scratched the surface of regular expression technology. In this and subsequent sections we will introduce regexp concepts (and associated metacharacter notations) that will allow a regexp to represent not just a single character sequence, but a</source>
          <target state="translated">上述のリテラル文字列正規表現ではすでに多くのことができますが、正規表現技術の表面にはまだ触れていません。このセクションとそれ以降のセクションでは、正規表現の概念(とそれに関連するメタ文字表記)を紹介します。</target>
        </trans-unit>
        <trans-unit id="2365e59fbff407c44bacc5b415419bc0925eb6e4" translate="yes" xml:space="preserve">
          <source>Although one does not have to follow this convention, be aware that the convention for UNIX man pages for commands is for the man page title to be in all-uppercase, even if the command isn't.</source>
          <target state="translated">この規則に従う必要はありませんが、UNIX のコマンド用 man ページの規則では、たとえコマンドがなくても man ページのタイトルはすべて大文字であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="18a0eac57e1c4484372ccab28955e18fb02ea640" translate="yes" xml:space="preserve">
          <source>Although one would expect the quantities $y and $z to be the same and equal to 100000 they will differ and instead will be 0 and 100000 respectively.</source>
          <target state="translated">人は $y と $z が同じで 100000 に等しい量であることを期待しますが、それらは異なり、その代わりにそれぞれ 0 と 100000 になります。</target>
        </trans-unit>
        <trans-unit id="5829c5fcc8ce3b64df01881896b3b15fd774741a" translate="yes" xml:space="preserve">
          <source>Although only a single value was expected to be returned from</source>
          <target state="translated">からは単一の値しか返ってこないと予想されていましたが</target>
        </trans-unit>
        <trans-unit id="2a2b97db7310124d07426632d32011d83ef42107" translate="yes" xml:space="preserve">
          <source>Although primarily designed for use with multi-threaded Perl, the macros have been designed so that they will work with non-threaded Perl as well.</source>
          <target state="translated">主にマルチスレッドPerlで使用するために設計されていますが、マクロは非スレッドPerlでも動作するように設計されています。</target>
        </trans-unit>
        <trans-unit id="797e69b4382557ebf9cc947a771d199448156185" translate="yes" xml:space="preserve">
          <source>Although similar, file path specifications differ between Unix, Windows, Mac OS, OS/2, VMS, VOS, RISC OS, and probably others. Unix, for example, is one of the few OSes that has the elegant idea of a single root directory.</source>
          <target state="translated">似ていますが、ファイルパスの仕様は、Unix、Windows、Mac OS、OS/2、VMS、VOS、RISC OS、そしておそらく他のOSの間で異なります。例えば、Unix は、単一のルートディレクトリというエレガントなアイデアを持つ数少ない OS の一つです。</target>
        </trans-unit>
        <trans-unit id="d6190ff15955860c6c9fdd297f5be90390874780" translate="yes" xml:space="preserve">
          <source>Although test failures should be enough, extra diagnostics can be triggered at the end of a test run. &lt;code&gt;onfail&lt;/code&gt; is passed an array ref of hash refs that describe each test failure. Each hash will contain at least the following fields: &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;repetition&lt;/code&gt; , and &lt;code&gt;result&lt;/code&gt; . (You shouldn't rely on any other fields being present.) If the test had an expected value or a diagnostic (or &quot;note&quot;) string, these will also be included.</source>
          <target state="translated">テストの失敗で十分なはずですが、テスト実行の最後に追加の診断をトリガーできます。 &lt;code&gt;onfail&lt;/code&gt; には、各テストの失敗を説明するハッシュ参照の配列参照が渡されます。各ハッシュには、少なくとも次のフィールドが含まれます： &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;repetition&lt;/code&gt; 、 &lt;code&gt;result&lt;/code&gt; 。（存在する他のフィールドに依存することはできません。）テストに期待値または診断（または「ノート」）文字列があった場合、これらも含まれます。</target>
        </trans-unit>
        <trans-unit id="cb955315f15c5e807d16b61b980d5ee47a32430b" translate="yes" xml:space="preserve">
          <source>Although test failures should be enough, extra diagnostics can be triggered at the end of a test run. &lt;code&gt;onfail&lt;/code&gt; is passed an array ref of hash refs that describe each test failure. Each hash will contain at least the following fields: &lt;code&gt;package&lt;/code&gt;, &lt;code&gt;repetition&lt;/code&gt;, and &lt;code&gt;result&lt;/code&gt;. (You shouldn't rely on any other fields being present.) If the test had an expected value or a diagnostic (or &quot;note&quot;) string, these will also be included.</source>
          <target state="translated">テストの失敗で十分なはずですが、テストの実行の最後に追加の診断をトリガーできます。 &lt;code&gt;onfail&lt;/code&gt; には、各テストの失敗を説明するハッシュ参照の配列参照が渡されます。各ハッシュには、少なくとも次のフィールドが含まれます： &lt;code&gt;package&lt;/code&gt; 、 &lt;code&gt;repetition&lt;/code&gt; 、および &lt;code&gt;result&lt;/code&gt; 。 （存在する他のフィールドに依存しないでください。）テストに期待値または診断（または「メモ」）文字列が含まれている場合は、これらも含まれます。</target>
        </trans-unit>
        <trans-unit id="224e863badf25248ea988718d8bd34cef72cce5a" translate="yes" xml:space="preserve">
          <source>Although that form may run into trouble in network transit (due to the presence of 8 bit characters) or on non ISO-Latin character sets. But it does allow &lt;code&gt;Is_c1&lt;/code&gt; to be rewritten so it works on Perls that don't have &lt;code&gt;'unicode_strings'&lt;/code&gt; (earlier than v5.14):</source>
          <target state="translated">ただし、この形式では、ネットワーク転送（8ビット文字が存在するため）またはISO-Latin以外の文字セットで問題が発生する可能性があります。しかし、 &lt;code&gt;Is_c1&lt;/code&gt; を書き換えることができるので、 &lt;code&gt;'unicode_strings'&lt;/code&gt; がない（v5.14より前の）Perlで動作します。</target>
        </trans-unit>
        <trans-unit id="99123ea723cf2a29473e47c091f28928ebbdafd8" translate="yes" xml:space="preserve">
          <source>Although the &lt;code&gt;%&lt;/code&gt; code is documented as returning a &quot;checksum&quot;: don't put your trust in such values! Even when applied to a small number of bytes, they won't guarantee a noticeable Hamming distance.</source>
          <target state="translated">けれども &lt;code&gt;%&lt;/code&gt; のコードは「チェックサム」を返すと文書化されています。このような値にあなたの信頼を置かないでください！少数のバイトに適用した場合でも、顕著なハミング距離は保証されません。</target>
        </trans-unit>
        <trans-unit id="6834c0c595f466c17dc9377b6377ec111fa7e11c" translate="yes" xml:space="preserve">
          <source>Although the above may seem a bit confusing at first, it generally does &quot;the right thing&quot; in most situations. This determination of the default values to use is based upon the following typical Unix conventions:</source>
          <target state="translated">最初は少し混乱するかもしれませんが、一般的にはほとんどの状況で「正しいこと」をしています。使用するデフォルト値の決定は、以下の典型的な Unix の規約に基づいています。</target>
        </trans-unit>
        <trans-unit id="a0b752b8fd0002195999a4940b4a67ff51de0cf2" translate="yes" xml:space="preserve">
          <source>Although the error message above refers to the second tie() statement in the script, the source of the problem is really with the untie() statement that precedes it.</source>
          <target state="translated">上のエラーメッセージはスクリプト内の 2 番目の tie()文を指していますが、問題の原因はその前の untie()文にあります。</target>
        </trans-unit>
        <trans-unit id="050771d84c3ebf7bfb6e4438000d2961a2adc2a7" translate="yes" xml:space="preserve">
          <source>Although the functionality provided by this flag may seem straightforward, it should be used only if there is a good reason to do so. The reason for being cautious is that, even if you have specified the G_NOARGS flag, it is still possible for the Perl subroutine that has been called to think that you have passed it parameters.</source>
          <target state="translated">このフラグによって提供される機能は簡単なように見えるかもしれませんが、それを行う正当な理由がある場合にのみ使用すべきです。慎重になる理由は、G_NOARGSフラグを指定していても、呼び出されたPerlのサブルーチンにパラメータを渡したと勘違いされる可能性があるからです。</target>
        </trans-unit>
        <trans-unit id="0019a6a5066bef3137d87deda446668085e7063b" translate="yes" xml:space="preserve">
          <source>Although the ignored argument doesn't go into a variable, it is still mandatory for the caller to pass it.</source>
          <target state="translated">無視された引数が変数に入ることはありませんが、それでも呼び出し元に渡すことは必須です。</target>
        </trans-unit>
        <trans-unit id="35ed9f698c7272524026c7a45834a834a74d7bb0" translate="yes" xml:space="preserve">
          <source>Although the main discussion of Perl security issues can be found in &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;, a discussion of Perl's locale handling would be incomplete if it did not draw your attention to locale-dependent security issues. Locales--particularly on systems that allow unprivileged users to build their own locales--are untrustworthy. A malicious (or just plain broken) locale can make a locale-aware application give unexpected results. Here are a few possibilities:</source>
          <target state="translated">Perlのセキュリティ問題に関する主な議論は&lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt;にありますが、Perlのロケール処理に関する議論は、ロケールに依存するセキュリティ問題に注意を向けなければ不完全です。ロケール（特に特権のないユーザーが自分のロケールを作成できるシステム）は信頼できません。悪意のある（または単純に壊れた）ロケールは、ロケール対応アプリケーションが予期しない結果をもたらす可能性があります。いくつかの可能性があります：</target>
        </trans-unit>
        <trans-unit id="6ad8f5d884e3bfe99068d75f61c2b91c556f88ba" translate="yes" xml:space="preserve">
          <source>Although the most deeply nested array or hash element will not spring into existence just because its existence was tested, any intervening ones will. Thus &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; and &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; will spring into existence due to the existence test for the $key element above. This happens anywhere the arrow operator is used, including even here:</source>
          <target state="translated">最も深くネストされた配列またはハッシュ要素は、その存在がテストされたという理由だけでは存在しませんが、介在するものは存在します。したがって、上記の$ key要素の存在テストにより、 &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; と$ ref-&amp;gt; {&quot;A&quot;}-&amp;gt; {&quot;B&quot;}が存在するようになります。これは、以下を含め、矢印演算子が使用されるすべての場所で発生します。</target>
        </trans-unit>
        <trans-unit id="d1b22581bc0b80baeffbb205fa759bdb0ff242e5" translate="yes" xml:space="preserve">
          <source>Although the most deeply nested array or hash element will not spring into existence just because its existence was tested, any intervening ones will. Thus &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; and &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; will spring into existence due to the existence test for the &lt;code&gt;$key&lt;/code&gt; element above. This happens anywhere the arrow operator is used, including even here:</source>
          <target state="translated">最も深くネストされた配列またはハッシュ要素は、その存在がテストされたという理由だけで存在することはありませんが、介在するものは存在します。したがって、上記の &lt;code&gt;$key&lt;/code&gt; 要素の存在テストにより、 &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}-&amp;gt;{&quot;B&quot;}&lt;/code&gt; &lt;code&gt;$ref-&amp;gt;{&quot;A&quot;}&lt;/code&gt; および$ ref-&amp;gt; {&quot;A&quot;}-&amp;gt; {&quot;B&quot;}が発生します。これは、ここを含め、矢印演算子が使用されているすべての場所で発生します。</target>
        </trans-unit>
        <trans-unit id="ece6731e40fd98f25883ef891976cdd74d8b5353" translate="yes" xml:space="preserve">
          <source>Although the optree is read-only, there is an overlay facility that allows you to override what values the various B::*OP methods return for a particular op. &lt;code&gt;$B::overlay&lt;/code&gt; should be set to reference a two-deep hash: indexed by OP address, then method name. Whenever a an op method is called, the value in the hash is returned if it exists. This facility is used by B::Deparse to &quot;undo&quot; some optimisations. For example:</source>
          <target state="translated">optreeは読み取り専用ですが、特定のopに対してさまざまなB :: * OPメソッドが返す値をオーバーライドできるオーバーレイ機能があります。 &lt;code&gt;$B::overlay&lt;/code&gt; は、2つのディープハッシュを参照するように設定する必要があります。OPアドレス、次にメソッド名でインデックスを作成します。opメソッドが呼び出されると、ハッシュの値が存在する場合は、その値が返されます。この機能は、いくつかの最適化を「元に戻す」ためにB :: Deparseによって使用されます。例えば：</target>
        </trans-unit>
        <trans-unit id="4006666c099c71fba2fd95778e8d769cab92e521" translate="yes" xml:space="preserve">
          <source>Although the primary purpose for the existence of &lt;code&gt;Compress::Raw::Bzip2&lt;/code&gt; is for use by the &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; and &lt;code&gt;IO::Compress::Bunzip2&lt;/code&gt; modules, it can be used on its own for simple compression/uncompression tasks.</source>
          <target state="translated">&lt;code&gt;Compress::Raw::Bzip2&lt;/code&gt; の存在の主な目的は &lt;code&gt;IO::Compress::Bzip2&lt;/code&gt; および &lt;code&gt;IO::Compress::Bunzip2&lt;/code&gt; モジュールで使用することですが、単純な圧縮/解凍タスクにそれ自体で使用できます。</target>
        </trans-unit>
        <trans-unit id="73cce3599d213093393a3d6545498d75ae280481" translate="yes" xml:space="preserve">
          <source>Although the techniques described here are applicable when embedding Perl in a C program, this is not the primary goal of this document. There are other details that must be considered and are specific to embedding Perl. For details on embedding Perl in C refer to &lt;a href=&quot;perlembed&quot;&gt;perlembed&lt;/a&gt;.</source>
          <target state="translated">ここで説明する手法は、PerlをCプログラムに埋め込むときに適用できますが、これはこのドキュメントの主な目的ではありません。考慮する必要があり、Perlの組み込みに固有のその他の詳細があります。PerlのCへの埋め込みの詳細については、&lt;a href=&quot;perlembed&quot;&gt;perlembedを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="14e1e99a665303302472280aa271e6e7551860a9" translate="yes" xml:space="preserve">
          <source>Although there can be any number of source streams in existence at any given time, only one will be active.</source>
          <target state="translated">任意の時間にいくつものソースストリームが存在することができますが、アクティブになるのは1つだけです。</target>
        </trans-unit>
        <trans-unit id="837688ce8fc062bca9030ce8b90ed396865f417d" translate="yes" xml:space="preserve">
          <source>Although these are grouped by family, they all have the precedence of assignment. These combined assignment operators can only operate on scalars, whereas the ordinary assignment operator can assign to arrays, hashes, lists and even references. (See &lt;a href=&quot;perldata#Context&quot;&gt;&quot;Context&quot;&lt;/a&gt; and &lt;a href=&quot;perldata#List-value-constructors&quot;&gt;&quot;List value constructors&quot; in perldata&lt;/a&gt;, and &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;&quot;Assigning to References&quot; in perlref&lt;/a&gt;.)</source>
          <target state="translated">これらは家族ごとにグループ化されていますが、すべて割り当ての優先順位があります。これらの結合された代入演算子はスカラーでのみ操作できますが、通常の代入演算子は配列、ハッシュ、リスト、さらには参照にさえ割り当てることができます。（&lt;a href=&quot;perldata#List-value-constructors&quot;&gt;perldataの&lt;/a&gt;&lt;a href=&quot;perldata#Context&quot;&gt;「Context」&lt;/a&gt;と「Listvalueコンストラクター」、およびperlrefの&lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;「AssigningtoReferences」を参照してください&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="c84534656a685169f0194cbbe1e16531f562b033" translate="yes" xml:space="preserve">
          <source>Although these are grouped by family, they all have the precedence of assignment. These combined assignment operators can only operate on scalars, whereas the ordinary assignment operator can assign to arrays, hashes, lists and even references. (See &lt;a href=&quot;perldata#Context&quot;&gt;Context&lt;/a&gt; and &lt;a href=&quot;perldata#List-value-constructors&quot;&gt;List value constructors in perldata&lt;/a&gt;, and &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Assigning to References in perlref&lt;/a&gt;.)</source>
          <target state="translated">これらは家族によってグループ化されていますが、すべて割り当ての優先順位があります。これらの組み合わされた代入演算子はスカラーでのみ動作できますが、通常の代入演算子は配列、ハッシュ、リスト、さらには参照に代入できます。（&lt;a href=&quot;perldata#List-value-constructors&quot;&gt;perldataの&lt;/a&gt;&lt;a href=&quot;perldata#Context&quot;&gt;コンテキスト&lt;/a&gt;およびリスト値コンストラクター、および&lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;perlrefの参照への割り当てを参照してください&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="1f0ef7687de397f14de7592d67f915d2f79f2a4c" translate="yes" xml:space="preserve">
          <source>Although this function returns its values on the perl argument stack, it doesn't take any parameters from that stack (and thus in particular there's no need to do a &lt;code&gt;PUSHMARK&lt;/code&gt; before calling it, unlike &lt;a href=&quot;#call_pv&quot;&gt;&quot;call_pv&quot;&lt;/a&gt; for example).</source>
          <target state="translated">この関数はperl引数スタックでその値を返しますが、そのスタックからパラメーターを取りません（したがって、特に&lt;a href=&quot;#call_pv&quot;&gt;「call_pv」&lt;/a&gt;とは異なり、呼び出す前に &lt;code&gt;PUSHMARK&lt;/code&gt; を実行する必要はありません）。</target>
        </trans-unit>
        <trans-unit id="459be48ccfdeb87ea73fbd1fbec51d1410292106" translate="yes" xml:space="preserve">
          <source>Although this function returns its values on the perl argument stack, it doesn't take any parameters from that stack (and thus in particular there's no need to do a PUSHMARK before calling it, unlike &lt;a href=&quot;#call_pv&quot;&gt;call_pv&lt;/a&gt; for example).</source>
          <target state="translated">この関数は、perl引数スタックで値を返しますが、そのスタックからパラメーターを取得しません（したがって、たとえば、&lt;a href=&quot;#call_pv&quot;&gt;call_pvの&lt;/a&gt;ように、呼び出す前にPUSHMARKを実行する必要はありません）。</target>
        </trans-unit>
        <trans-unit id="9ecb9099e922e4493577adbe3649de5e0005a135" translate="yes" xml:space="preserve">
          <source>Although this keyword is optional and in some cases provides redundant information it should always be used. This keyword will ensure that the XSUBs appear in the desired package.</source>
          <target state="translated">このキーワードはオプションであり、場合によっては冗長な情報を提供しますが、常に使用すべきです。このキーワードは、XSUB が目的のパッケージに確実に表示されるようにします。</target>
        </trans-unit>
        <trans-unit id="66fb31ad783a8264f17dab51f3aa1ad011017a08" translate="yes" xml:space="preserve">
          <source>Although this option can be used with the OO interface, it is of most use with the one-shot interface. For example, the code below shows how &lt;code&gt;FilterName&lt;/code&gt; can be used to remove the path component from a series of filenames before they are stored in &lt;code&gt;$zipfile&lt;/code&gt; .</source>
          <target state="translated">このオプションはOOインターフェースで使用できますが、ほとんどの場合、ワンショットインターフェースで使用します。たとえば、以下のコードは、 &lt;code&gt;FilterName&lt;/code&gt; を使用して、一連のファイル名からパスコンポーネントを削除してから、 &lt;code&gt;$zipfile&lt;/code&gt; 保存する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="e7045e0d3148f2b5800c2c6d6d41c5d9e7c09642" translate="yes" xml:space="preserve">
          <source>Although this option can be used with the OO interface, it is of most use with the one-shot interface. For example, the code below shows how &lt;code&gt;FilterName&lt;/code&gt; can be used to remove the path component from a series of filenames before they are stored in &lt;code&gt;$zipfile&lt;/code&gt;.</source>
          <target state="translated">このオプションはOOインターフェイスで使用できますが、ワンショットインターフェイスで最も使用されます。たとえば、次のコードは、 &lt;code&gt;FilterName&lt;/code&gt; を使用して、パスコンポーネントを &lt;code&gt;$zipfile&lt;/code&gt; 格納する前に一連のファイル名から削除する方法を示しています。</target>
        </trans-unit>
        <trans-unit id="2398658140451226b4cd3f1886215ebf8c65091f" translate="yes" xml:space="preserve">
          <source>Although this stuff is easier to explain using examples, you first need be aware of a few important definitions.</source>
          <target state="translated">このようなものは例を使って説明する方が簡単ですが、まずはいくつかの重要な定義を知っておく必要があります。</target>
        </trans-unit>
        <trans-unit id="5d6b9d5e42d7a86677e3f471c1e47e328daf1dc8" translate="yes" xml:space="preserve">
          <source>Although very useful, the big problem with using &lt;b&gt;-w&lt;/b&gt; on the command line to enable warnings is that it is all or nothing. Take the typical scenario when you are writing a Perl program. Parts of the code you will write yourself, but it's very likely that you will make use of pre-written Perl modules. If you use the &lt;b&gt;-w&lt;/b&gt; flag in this case, you end up enabling warnings in pieces of code that you haven't written.</source>
          <target state="translated">非常に便利ですが、警告を有効にするためにコマンドラインで&lt;b&gt;-w&lt;/b&gt;を使用することの大きな問題は、それがすべてかゼロかということです。Perlプログラムを作成するときは、一般的なシナリオを考えてください。自分で作成するコードの一部ですが、事前に作成されたPerlモジュールを利用する可能性が非常に高くなります。この場合に&lt;b&gt;-w&lt;/b&gt;フラグを使用すると、作成していないコードで警告が有効になってしまいます。</target>
        </trans-unit>
        <trans-unit id="560edbbb945d8ba093edcea345708feb744a0493" translate="yes" xml:space="preserve">
          <source>Although we do suggest that you always build your own Perl from the source code, both for maximal configurability and for security, in case you are in a hurry you can check &lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.html&lt;/a&gt; for binary distributions.</source>
          <target state="translated">私たちは、いつでもソースコードから独自のPerlを構築することを示唆しているんが、最大限のコンフィギュラ用とセキュリティの両方、場合にあなたがチェックすることができます急いでいる&lt;a href=&quot;http://www.cpan.org/ports/index.html&quot;&gt;http://www.cpan.org/ports/index.htmlを&lt;/a&gt;するためにバイナリ分布。</target>
        </trans-unit>
        <trans-unit id="cd023125cfeba9eec78f15bbf69240c8b819181b" translate="yes" xml:space="preserve">
          <source>Although we wish to free any temps at the same time, we have to be careful not to free any temps which are keeping return args alive; nor to free the temps we have just created while mortal copying return args. Fortunately, &lt;code&gt;leave_adjust_stacks()&lt;/code&gt; is capable of making mortal copies of return args, shifting args down the stack, and only processing those entries on the temps stack that are safe to do so.</source>
          <target state="translated">同時にすべての一時を解放したいのですが、戻り引数を存続させている一時を解放しないように注意する必要があります。また、致命的なコピーが引数を返すときに作成した一時を解放することもできません。幸い、 &lt;code&gt;leave_adjust_stacks()&lt;/code&gt; は、戻り引数の致命的なコピーを作成し、引数をスタックの下にシフトし、安全に実行できる一時スタック上のエントリのみを処理することができます。</target>
        </trans-unit>
        <trans-unit id="46ce08a44dd2ba4f6ce9e91fa3d420e93dff144d" translate="yes" xml:space="preserve">
          <source>Although write can work with lexical or package variables, whatever variables you use have to scope in the format. That most likely means you'll want to localize some package variables:</source>
          <target state="translated">write は辞書変数やパッケージ変数を扱うことができますが、 使用する変数はすべてスコープ形式でなければなりません。つまり、いくつかのパッケージ変数をローカライズしたいということになります。</target>
        </trans-unit>
        <trans-unit id="e5edf100e2a7db4baae600915e4757f07b6f80de" translate="yes" xml:space="preserve">
          <source>Although, for historical reasons, the &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; distribution takes its name from this module it now exists only to provide &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; with an interface that is somewhat backwards compatible with &lt;a href=&quot;Test::Harness&quot;&gt;Test::Harness&lt;/a&gt; 2.xx. If you're writing new code consider using &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; directly instead.</source>
          <target state="translated">歴史的な理由から、&lt;a href=&quot;Test::Harness&quot;&gt;Test :: Harness&lt;/a&gt;ディストリビューションはこのモジュールにちなんで名付けられましたが、現在は&lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: Harnessに&lt;/a&gt;&lt;a href=&quot;Test::Harness&quot;&gt;Test ::&lt;/a&gt; Harness2.xxとの下位互換性のあるインターフェイスを提供するためにのみ存在しています。新しいコードを作成する場合は、代わりに&lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: Harnessを&lt;/a&gt;直接使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="e1e9346790d51b0db2514b5ac70a5da4526349c7" translate="yes" xml:space="preserve">
          <source>Although, for historical reasons, the &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; distribution takes its name from this module it now exists only to provide &lt;a href=&quot;../tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; with an interface that is somewhat backwards compatible with &lt;a href=&quot;harness&quot;&gt;Test::Harness&lt;/a&gt; 2.xx. If you're writing new code consider using &lt;a href=&quot;../tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; directly instead.</source>
          <target state="translated">歴史的な理由により、&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt;ディストリビューションの名前はこのモジュールから取られていますが、&lt;a href=&quot;harness&quot;&gt;Test :: Harness&lt;/a&gt; 2.xx と多少後方互換性のあるインターフェースを持つ&lt;a href=&quot;../tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt;を提供するためにのみ存在しています。新しいコードを書いている場合は、代わりに&lt;a href=&quot;../tap/harness&quot;&gt;TAP :: Harnessを&lt;/a&gt;直接使用することを検討してください。</target>
        </trans-unit>
        <trans-unit id="31fcae02d3e65b92831cdd124f189410606de910" translate="yes" xml:space="preserve">
          <source>Alvestrand, Harald Tveit. 1995.</source>
          <target state="translated">アルヴェストランド、ハラルド・トゥヴェイト 1995.</target>
        </trans-unit>
        <trans-unit id="f966b3ea336af8830bc18236a5389bd937c78b7c" translate="yes" xml:space="preserve">
          <source>Always be civil.</source>
          <target state="translated">常に礼儀正しく。</target>
        </trans-unit>
        <trans-unit id="c369c01b27ace1a743bc3e37d378c5dbbf093f50" translate="yes" xml:space="preserve">
          <source>Always check the return codes of system calls. Good error messages should go to &lt;code&gt;STDERR&lt;/code&gt; , include which program caused the problem, what the failed system call and arguments were, and (VERY IMPORTANT) should contain the standard system error message for what went wrong. Here's a simple but sufficient example:</source>
          <target state="translated">常にシステムコールのリターンコードを確認してください。適切なエラーメッセージは &lt;code&gt;STDERR&lt;/code&gt; に送信され、どのプログラムが問題を引き起こしたか、失敗したシステムコールと引数は何か、そして（非常に重要）何が問題だったかに関する標準のシステムエラーメッセージが含まれます。簡単ですが十分な例を次に示します。</target>
        </trans-unit>
        <trans-unit id="c9f2011c5ea88ecfcfb89f58ad78e623f2ab76d8" translate="yes" xml:space="preserve">
          <source>Always check the return codes of system calls. Good error messages should go to &lt;code&gt;STDERR&lt;/code&gt;, include which program caused the problem, what the failed system call and arguments were, and (VERY IMPORTANT) should contain the standard system error message for what went wrong. Here's a simple but sufficient example:</source>
          <target state="translated">システムコールの戻りコードを常に確認してください。適切なエラーメッセージは &lt;code&gt;STDERR&lt;/code&gt; に送信され、問題の原因となったプログラム、失敗したシステムコールと引数が含まれ、（非常に重要）問題の原因に関する標準のシステムエラーメッセージが含まれている必要があります。簡単ですが十分な例を次に示します。</target>
        </trans-unit>
        <trans-unit id="5844f1a31b652c47f84d0aaae5c714b741011321" translate="yes" xml:space="preserve">
          <source>Always commit changes to config variables to disk?</source>
          <target state="translated">設定変数の変更を常にディスクにコミットするか?</target>
        </trans-unit>
        <trans-unit id="c9994fb26151727507038319136d7dd61608906c" translate="yes" xml:space="preserve">
          <source>Always comparing to a version object will help avoid surprises:</source>
          <target state="translated">常にバージョンオブジェクトと比較することで、驚きを避けることができます。</target>
        </trans-unit>
        <trans-unit id="cd2fdc72c972de55363038192e944aae07f2f5ef" translate="yes" xml:space="preserve">
          <source>Always decompose on the way in, then recompose on the way out.</source>
          <target state="translated">入るときは必ず分解して、出るときは再分解する。</target>
        </trans-unit>
        <trans-unit id="a981ab84adf96ff26a362806abc6776217d3e6df" translate="yes" xml:space="preserve">
          <source>Always evaluates to &lt;code&gt;%X&lt;/code&gt;, the locale's appropriate time representation.</source>
          <target state="translated">ロケールの適切な時間表現である &lt;code&gt;%X&lt;/code&gt; に常に評価されます。</target>
        </trans-unit>
        <trans-unit id="36ade828ef985c357a4f590a718feea06b8ef69f" translate="yes" xml:space="preserve">
          <source>Always evaluates to &lt;code&gt;%c&lt;/code&gt;, the locale's appropriate date and time representation.</source>
          <target state="translated">ロケールの適切な日付と時刻の表現である &lt;code&gt;%c&lt;/code&gt; に常に評価されます。</target>
        </trans-unit>
        <trans-unit id="500eaed1bf2ab70574a92f0ee3e10b9af4499072" translate="yes" xml:space="preserve">
          <source>Always evaluates to &lt;code&gt;%x&lt;/code&gt;, the locale's appropriate date representation.</source>
          <target state="translated">ロケールの適切な日付表現である &lt;code&gt;%x&lt;/code&gt; に常に評価されます。</target>
        </trans-unit>
        <trans-unit id="8c61fff2e0b1e2b49630e69bc2a2e99ec24ecff3" translate="yes" xml:space="preserve">
          <source>Always explicitly and immediately call close() on the writable end of any pipe, unless that process is actually writing to it. Even if you don't explicitly call close(), Perl will still close() all filehandles during global destruction. As previously discussed, if those filehandles have been opened with Safe Pipe Open, this will result in calling waitpid(), which may again deadlock.</source>
          <target state="translated">どのようなパイプでも、そのプロセスが実際に書き込みを行っている場合を除いて、書き込み可能な端では常に明示的かつ即座に close()をコールするようにしてください。明示的に close()を呼び出さなくても、Perl はグローバル破壊の際にすべてのファイルハンドルを close()します。前に説明したように、それらのファイルハンドルが Safe Pipe Open でオープンされている場合、これは waitpid()を呼び出す結果となり、再びデッドロックする可能性があります。</target>
        </trans-unit>
        <trans-unit id="242eddbfa115df236054209d0570301b5af3c68e" translate="yes" xml:space="preserve">
          <source>Always place the START_MY_CXT macro directly after the declaration of &lt;code&gt;my_cxt_t&lt;/code&gt; .</source>
          <target state="translated">START_MY_CXTマクロは、常に &lt;code&gt;my_cxt_t&lt;/code&gt; の宣言の直後に配置してください。</target>
        </trans-unit>
        <trans-unit id="2a1f78b377f3f4dbcc2f8cd296fbf35bd7322707" translate="yes" xml:space="preserve">
          <source>Always place the START_MY_CXT macro directly after the declaration of &lt;code&gt;my_cxt_t&lt;/code&gt;.</source>
          <target state="translated">START_MY_CXTマクロは、常に &lt;code&gt;my_cxt_t&lt;/code&gt; の宣言の直後に配置してください。</target>
        </trans-unit>
        <trans-unit id="891f99ab9e41224456357d41b700c51457def43d" translate="yes" xml:space="preserve">
          <source>Always quote the version</source>
          <target state="translated">常にバージョンを引用する</target>
        </trans-unit>
        <trans-unit id="33f26e154493acc9e3d45671d863271e7464d39e" translate="yes" xml:space="preserve">
          <source>Always strive to remain compatible with previous released versions. Otherwise try to add a mechanism to revert to the old behavior if people rely on it. Document incompatible changes.</source>
          <target state="translated">常に以前にリリースされたバージョンとの互換性を保つように努力してください。そうでなければ、人々がそれに依存している場合には、古い動作に戻すメカニズムを追加するようにしてください。互換性のない変更を文書化する。</target>
        </trans-unit>
        <trans-unit id="1c41f11cd18971bbdb3e2ef9969d459e5296677c" translate="yes" xml:space="preserve">
          <source>Always try to check and verify signatures if a SIGNATURE file is in the package and Module::Signature is installed (yes/no)?</source>
          <target state="translated">パッケージ内に SIGNATURE ファイルがあり、Module::Signature がインストールされている場合は、常に署名の確認と検証を試みます (yes/no)?</target>
        </trans-unit>
        <trans-unit id="24f1e77216b2edc00da08bfb70769a17a94800b4" translate="yes" xml:space="preserve">
          <source>Always try to show upload date with 'd' and 'm' command (yes/no)?</source>
          <target state="translated">常に'd'と'm'コマンドでアップロードの日付を表示しようとすると(はい/いいえ)?</target>
        </trans-unit>
        <trans-unit id="ab3692e008452cea5b34a3fe52ad03c81207161c" translate="yes" xml:space="preserve">
          <source>Always use &lt;b&gt;-w&lt;/b&gt;.</source>
          <target state="translated">常に&lt;b&gt;-wを&lt;/b&gt;使用してください。</target>
        </trans-unit>
        <trans-unit id="f5dc9ef4a983f2881df95298081703042e4c314a" translate="yes" xml:space="preserve">
          <source>Always use a dotted-decimal with (at least) three components</source>
          <target state="translated">常に(少なくとも)3つの要素を持つドット十進数を使用します。</target>
        </trans-unit>
        <trans-unit id="1af0291b70c5a30fa81736f480600ed39cabe174" translate="yes" xml:space="preserve">
          <source>Always use a leading-v</source>
          <target state="translated">常にリーディングV</target>
        </trans-unit>
        <trans-unit id="8367b54257a55d960e03d572f3ffce6e4f988276" translate="yes" xml:space="preserve">
          <source>Always use with a subtag. Notable forms: {sgn-gb} British Sign Language (BSL); {sgn-ie} Irish Sign Language (ESL); {sgn-ni} Nicaraguan Sign Language (ISN); {sgn-us} American Sign Language (ASL).</source>
          <target state="translated">必ずサブタグと一緒に使用してください。注目すべき形式。{sgn-gb}。ブリティッシュ手話(BSL);{sgn-ie}。アイルランド手話(ESL);{sgn-ni}。ニカラグア手話(ISN);{sgn-us}。アメリカ手話(ASL)。</target>
        </trans-unit>
        <trans-unit id="d7fc26ae93e0cf00af5e88a1fe69971068f3bf0a" translate="yes" xml:space="preserve">
          <source>Ambiguous Local Times (DST)</source>
          <target state="translated">曖昧な現地時間(DST)</target>
        </trans-unit>
        <trans-unit id="60b78dd3bc38b79497387b8798a6af56908b3286" translate="yes" xml:space="preserve">
          <source>Ambiguous call resolved as CORE::%s(), qualify as such or use &amp;amp;</source>
          <target state="translated">あいまいな呼び出しはCORE ::％s（）として解決され、そのように認定されるか、＆を使用します</target>
        </trans-unit>
        <trans-unit id="81d6325a5322b24a8cad3df61889fcccc37da082" translate="yes" xml:space="preserve">
          <source>Ambiguous range in transliteration operator</source>
          <target state="translated">訳語の曖昧な範囲</target>
        </trans-unit>
        <trans-unit id="edda76ce0ef49493fbd99f6a03d679fce823d7ca" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %c resolved as operator %c</source>
          <target state="translated">演算子 %c として解決された %c の曖昧な使用。</target>
        </trans-unit>
        <trans-unit id="97f919429ce49eab88ebaca27d4b763e67507277" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %c{%s[...]} resolved to %c%s[...]</source>
          <target state="translated">曖昧な %c{%s[....]}の使用は %c%s[....]に解決されました。</target>
        </trans-unit>
        <trans-unit id="3c963134cf7d24b861988abb82e92519a22caf5a" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %c{%s{...}} resolved to %c%s{...}</source>
          <target state="translated">曖昧な %c{%s{...}}の使用は %c%s{...}に解決されました。</target>
        </trans-unit>
        <trans-unit id="57d7860a6ad7ad4f88f893704243eeb8b4377d90" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %c{%s} resolved to %c%s</source>
          <target state="translated">曖昧な %c{%s}の使用は %c%s に解決されます。</target>
        </trans-unit>
        <trans-unit id="d67f229db4a4d1b5f2225b9846f84a14f01ccc8d" translate="yes" xml:space="preserve">
          <source>Ambiguous use of %s resolved as %s</source>
          <target state="translated">曖昧な %s の使用は %s として解決されます。</target>
        </trans-unit>
        <trans-unit id="59caacddbf40a7be1f1b173255e30458a45962f9" translate="yes" xml:space="preserve">
          <source>Ambiguous use of -%s resolved as -&amp;amp;%s()</source>
          <target state="translated">-％sのあいまいな使用は-＆％s（）として解決されます</target>
        </trans-unit>
        <trans-unit id="b61e588022eb4910c7d278a411480210f9347590" translate="yes" xml:space="preserve">
          <source>Ambulation.pm</source>
          <target state="translated">Ambulation.pm</target>
        </trans-unit>
        <trans-unit id="7dec8f79f324daec9e2bc3cec19154d9b44d20cf" translate="yes" xml:space="preserve">
          <source>Amiga Developers Environment</source>
          <target state="translated">Amiga 開発者環境</target>
        </trans-unit>
        <trans-unit id="e2b08dd8d56c6933a46584a5b28aac8a3ed2befa" translate="yes" xml:space="preserve">
          <source>Amiga Specific Modules</source>
          <target state="translated">Amiga専用モジュール</target>
        </trans-unit>
        <trans-unit id="7eb77f842d900a2dedf7fde5ab4f77cd221a01f3" translate="yes" xml:space="preserve">
          <source>Amiga,</source>
          <target state="translated">Amiga,</target>
        </trans-unit>
        <trans-unit id="e6b810bb50ff4aa9149ad36bef5c0f4e23da0b22" translate="yes" xml:space="preserve">
          <source>Amiga::ARexx</source>
          <target state="translated">Amiga::ARexx</target>
        </trans-unit>
        <trans-unit id="01a8977a9be8d612968643e3bf495cf6b7267806" translate="yes" xml:space="preserve">
          <source>Amiga::ARexx - Perl extension for ARexx support</source>
          <target state="translated">Amiga::ARexx-ARexx サポートのための Perl エクステンション</target>
        </trans-unit>
        <trans-unit id="8adf028f8c6d2a6a1f2e1490947a8c498843d956" translate="yes" xml:space="preserve">
          <source>Amiga::ARexx METHODS</source>
          <target state="translated">Amiga::ARexx METHODS</target>
        </trans-unit>
        <trans-unit id="b06d09541ec208da13b7be9ff5bbfee7e66e27b2" translate="yes" xml:space="preserve">
          <source>Amiga::ARexx::Msg METHODS</source>
          <target state="translated">Amiga::ARexx::Msg METHODS</target>
        </trans-unit>
        <trans-unit id="4c7974d6ce506c1fbe8763064a655033977f865b" translate="yes" xml:space="preserve">
          <source>Amiga::Exec</source>
          <target state="translated">Amiga::Exec</target>
        </trans-unit>
        <trans-unit id="d165b945227b32b2aec4eb213a7b6887056e595f" translate="yes" xml:space="preserve">
          <source>Amiga::Exec - Perl extension for low level amiga support</source>
          <target state="translated">Amiga::Exec-低レベルの amiga をサポートするための Perl エクステンション</target>
        </trans-unit>
        <trans-unit id="6763cfad1bb35aed134ab02bf5d64d5a57ca8187" translate="yes" xml:space="preserve">
          <source>Amnesty will prevent a failed assertion from causing the overall test to fail. In other words it marks a failure as expected and allowed.</source>
          <target state="translated">アムネスティは、失敗したアサーションがテスト全体の失敗を招くことを防ぎます。言い換えれば、それは予想通りの失敗であり、許可されたものであるとマークします。</target>
        </trans-unit>
        <trans-unit id="3c76575f93cf9b6439e5c8c228d14871841f2be6" translate="yes" xml:space="preserve">
          <source>Among IBM EBCDIC character code sets there are 13 characters that are often mapped to different integer values. Those characters are known as the 13 &quot;variant&quot; characters and are:</source>
          <target state="translated">IBM EBCDIC 文字コードセットの中には、異なる整数値にマップされることが多い 13 の文字があります。これらの文字は、13 の「バリアント」文字として知られており、以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="dc547e0c079def6202bb164de4204e6fef69df9c" translate="yes" xml:space="preserve">
          <source>Amongst the changes made for OS/2 are...</source>
          <target state="translated">OS/2のために行われた変更点の中には、以下のものがあります。</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="a57b3b45aeac822e093194b4bfd981f0e59fb655" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing no &quot;=item&quot; paragraphs at all, and containing only some number of ordinary/verbatim paragraphs, and possibly also some nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions. Such an itemless &quot;=over&quot; ... &quot;=back&quot; region in Pod is equivalent in meaning to a &quot;&amp;lt;blockquote&amp;gt;...&amp;lt;/blockquote&amp;gt;&quot; element in HTML.</source>
          <target state="translated">&quot;= over&quot; ... &quot;= back&quot;領域。 &quot;= item&quot;段落はまったく含まれず、通常の/逐語的段落がいくつかだけ含まれ、ネストされた &quot;= over&quot; ... &quot;= back&quot;も含まれる可能性がありますリージョン、「= for ...」段落、および「= begin」...「= end」リージョン。ポッドのこのようなアイテムのない「= over」...「= back」領域は、HTMLの「&amp;lt;blockquote&amp;gt; ... &amp;lt;/ blockquote&amp;gt;」要素と同じ意味です。</target>
        </trans-unit>
        <trans-unit id="a1fa998f4d85fe0a03c929b0df6c0b9a9c55bdd0" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &quot;=item *&quot; commands, each followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions.</source>
          <target state="translated">オーバー&quot; ...&quot;back &quot;領域は、&quot;=item *&quot;コマンドのみを含み、それぞれにいくつかの通常/逐語的な段落が続き、他の入れ子になった&quot;=over&quot; ...&quot;back &quot;領域、&quot;=for...&quot;パラグラフ、および&quot;=begin&quot;...&quot;=end &quot;領域。</target>
        </trans-unit>
        <trans-unit id="f7c11a0a43a54d0c5011769a3613a3b8e32e4b7f" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &quot;=item [text]&quot; commands, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, or &quot;=for...&quot; paragraphs, and &quot;=begin&quot;...&quot;=end&quot; regions.</source>
          <target state="translated">オーバー&quot; ...&quot;back &quot;領域は、&quot;=item [text]&quot;コマンドのみを含み、それぞれのコマンド(またはそれらのグループ)の後には、いくつかの通常の/逐語的な段落が続き、他のネストした&quot;=over&quot; ...&quot;back &quot;領域、または&quot;=for...&quot;段落、そして&quot;=begin&quot;...&quot;=end &quot;領域。</target>
        </trans-unit>
        <trans-unit id="bf06369b3eb3e5c957377be368c2f7244136f0a8" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; paragraphs, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and/or &quot;=begin&quot;...&quot;=end&quot; codes. Note that the numbers must start at 1 in each section, and must proceed in order and without skipping numbers.</source>
          <target state="translated">&quot;= over&quot; ... &quot;= back&quot;領域には、 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/a&gt;&lt;/code&gt; 段落のみが含まれ、各段落（またはそれらの各グループ）の後にいくつかの段落が続きます通常の/逐語的な段落、その他のネストされた「= over」...「= back」領域、「= for ...」段落、および/または「= begin」...「= end」コード。番号は各セクションで1から始まり、番号をスキップせずに順番に進む必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="927c2fc26d9fdc3522cb89e03e51cb9a3f52db71" translate="yes" xml:space="preserve">
          <source>An &quot;=over&quot; ... &quot;=back&quot; region containing only &lt;code&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/code&gt; paragraphs, each one (or each group of them) followed by some number of ordinary/verbatim paragraphs, other nested &quot;=over&quot; ... &quot;=back&quot; regions, &quot;=for...&quot; paragraphs, and/or &quot;=begin&quot;...&quot;=end&quot; codes. Note that the numbers must start at 1 in each section, and must proceed in order and without skipping numbers.</source>
          <target state="translated">&lt;code&gt;m/\A=item\s+\d+\.?\s*\z/&lt;/code&gt; 段落のみを含み、各段落（またはそれらの各グループ）の後にいくつかの段落が続く「= over」...「= back」領域通常/逐語的な段落、他のネストされた &quot;= over&quot; ... &quot;= back&quot;領域、 &quot;= for ...&quot;段落、および/または &quot;= begin&quot; ... &quot;= end&quot;コード。番号は各セクションで1から始まり、番号をスキップせずに順番に進む必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9c821406e2ce644bf837234397ad75d8f26b35cf" translate="yes" xml:space="preserve">
          <source>An &quot;independent&quot; subexpression, one which matches the substring that a</source>
          <target state="translated">独立した」部分式。</target>
        </trans-unit>
        <trans-unit id="16be1ac4526418524ec7dfd0204b1847a01b249e" translate="yes" xml:space="preserve">
          <source>An &quot;independent&quot; subexpression, one which matches the substring that a standalone</source>
          <target state="translated">独立した」subexpressionで、スタンドアロンの</target>
        </trans-unit>
        <trans-unit id="3a02e2541679357b758fec91e5c00ccb84d49cd8" translate="yes" xml:space="preserve">
          <source>An &quot;internal&quot; derivative of &quot;perlio&quot; which can be used to provide Unread() function for layers which have no buffer or cannot be bothered. (Basically this layer's &lt;code&gt;Fill()&lt;/code&gt; pops itself off the stack and so resumes reading from layer below.)</source>
          <target state="translated">「perlio」の「内部」派生物であり、バッファーを持たないか、または気にすることができないレイヤーにUnread（）関数を提供するために使用できます。（基本的に、このレイヤーの &lt;code&gt;Fill()&lt;/code&gt; はスタックからポップするため、下のレイヤーから読み取りを再開します。）</target>
        </trans-unit>
        <trans-unit id="94f93318c67b8e306fa7a939182b6dc1a8d99788" translate="yes" xml:space="preserve">
          <source>An &quot;internal&quot; method, subject to change, currently called to allow an overriding class to cache information that will then be passed into all the &lt;code&gt;*param*&lt;/code&gt; calls. (Yes, having to read the source to make sense of this is considered a known bug).</source>
          <target state="translated">変更される可能性のある「内部」メソッド。現在オーバーライドされているクラスがすべての &lt;code&gt;*param*&lt;/code&gt; 呼び出しに渡される情報をキャッシュできるようにするために現在呼び出されています。（はい、これを理解するためにソースを読む必要があることは既知のバグと見なされます）。</target>
        </trans-unit>
        <trans-unit id="c723dc089a4e0462d0565d4c223eb6a79ebcd3aa" translate="yes" xml:space="preserve">
          <source>An $eol of &quot;&quot; (the empty string) is special. In this case, no &quot;soft line breaks&quot; are introduced and binary mode is effectively enabled so that any &quot;\n&quot; in the original data is encoded as well.</source>
          <target state="translated">eol の &quot; &quot; (空文字列)は特殊です。この場合、&quot;soft line breaks &quot;は導入されず、バイナリモードが効果的に有効になり、元のデータの&quot;\n &quot;も同様にエンコードされます。</target>
        </trans-unit>
        <trans-unit id="5a6a13a346ab7340f151e0f470997f73ed378c5a" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; without an argument uses the last file read. Using &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof()&lt;/code&gt;&lt;/a&gt; with empty parentheses is different. It refers to the pseudo file formed from the files listed on the command line and accessed via the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. Since &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; isn't explicitly opened, as a normal filehandle is, an &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof()&lt;/code&gt;&lt;/a&gt; before &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has been used will cause &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt; to be examined to determine if input is available. Similarly, an &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof()&lt;/code&gt;&lt;/a&gt; after &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has returned end-of-file will assume you are processing another &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt; list, and if you haven't set &lt;a href=&quot;perlvar#%40ARGV&quot;&gt;&lt;code&gt;@ARGV&lt;/code&gt;&lt;/a&gt;, will read input from &lt;code&gt;STDIN&lt;/code&gt;; see &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof&lt;/code&gt; &lt;/a&gt;引数なしでは、最後のファイルの読み込みを使用しています。空の括弧で&lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof()&lt;/code&gt; &lt;/a&gt;を使用することは異なります。これは、コマンドラインにリストされ、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 演算子を介してアクセスされるファイルから形成された疑似ファイルを指します。 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; は明示的に開かれていないため、通常のファイルハンドルのように、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; が使用される前の&lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof()&lt;/code&gt; &lt;/a&gt;により、&lt;a href=&quot;perlvar#%40ARGV&quot;&gt; &lt;code&gt;@ARGV&lt;/code&gt; &lt;/a&gt;が調べられ、入力が使用可能かどうかが判断されます。同様に、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; がファイルの終わりを返した後の&lt;a href=&quot;#eof-FILEHANDLE&quot;&gt; &lt;code&gt;eof()&lt;/code&gt; は&lt;/a&gt;、別の&lt;a href=&quot;perlvar#%40ARGV&quot;&gt; &lt;code&gt;@ARGV&lt;/code&gt; &lt;/a&gt;リストを処理していると想定し、&lt;a href=&quot;perlvar#%40ARGV&quot;&gt; &lt;code&gt;@ARGV&lt;/code&gt; &lt;/a&gt;設定していない場合は、 &lt;code&gt;STDIN&lt;/code&gt; からの入力を読み取ります。; &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;perlopの「I / O演算子」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="1711b8c03a9928dbbe638d8c791d95aa2c85763c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#our-VARLIST&quot;&gt;&lt;code&gt;our&lt;/code&gt;&lt;/a&gt; declaration declares an alias for a package variable that will be visible across its entire lexical scope, even across package boundaries. The package in which the variable is entered is determined at the point of the declaration, not at the point of use. This means the following behavior holds:</source>
          <target state="translated">&lt;a href=&quot;#our-VARLIST&quot;&gt; &lt;code&gt;our&lt;/code&gt; &lt;/a&gt;宣言はしても、パッケージ境界を越えて、その全体のレキシカルスコープ全体に表示されますパッケージ変数のエイリアスを宣言します。変数が入力されるパッケージは、使用時点ではなく、宣言時点で決定されます。これは、次の動作が成り立つことを意味します。</target>
        </trans-unit>
        <trans-unit id="b91de5a24da27e5fce41ca7887051c5441493c51" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#our-VARLIST&quot;&gt;&lt;code&gt;our&lt;/code&gt;&lt;/a&gt; declaration may also have a list of attributes associated with it.</source>
          <target state="translated">&lt;a href=&quot;#our-VARLIST&quot;&gt; &lt;code&gt;our&lt;/code&gt; &lt;/a&gt;宣言はまた、それに関連する属性のリストを有することができます。</target>
        </trans-unit>
        <trans-unit id="7efa71e97154f5e1c53935b4d4b0410d3433b623" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;XSUB&lt;/b&gt; forms the basic unit of the XS interface. After compilation by the &lt;b&gt;xsubpp&lt;/b&gt; compiler, each XSUB amounts to a C function definition which will provide the glue between Perl calling conventions and C calling conventions.</source>
          <target state="translated">アン&lt;b&gt;XSUBは&lt;/b&gt; XSインターフェースの基本的な単位を形成しています。&lt;b&gt;xsubpp&lt;/b&gt;コンパイラによるコンパイル後、各XSUBは、Perl呼び出し規約とC呼び出し規約との間の接着剤を提供するC関数定義になります。</target>
        </trans-unit>
        <trans-unit id="09718e49ee8b20061f562ba9e5c34673e940b8ad" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;anonymous&lt;/b&gt; subroutine that, when a reference to it is generated at runtime, keeps track of the identities of externally visible &lt;b&gt;lexical variables&lt;/b&gt;, even after those lexical variables have supposedly gone out of &lt;b&gt;scope&lt;/b&gt;. They&amp;rsquo;re called &amp;ldquo;closures&amp;rdquo; because this sort of behavior gives mathematicians a sense of closure.</source>
          <target state="translated">実行時に参照が生成されたときに、外部から見える&lt;b&gt;レキシカル変数の&lt;/b&gt; IDを追跡する&lt;b&gt;匿名&lt;/b&gt;サブルーチン。これらのレキシカル変数が&lt;b&gt;スコープ&lt;/b&gt;から外れたと考えられる場合でも。このような行動は数学者に閉鎖感を与えるため、「閉鎖」と呼ばれます。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9e2f49be17e25fca915fffd9825b7a69527fa78a" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;argument&lt;/b&gt;-passing mechanism in which the &lt;b&gt;formal arguments&lt;/b&gt; refer directly to the &lt;b&gt;actual arguments&lt;/b&gt;, and the &lt;b&gt;subroutine&lt;/b&gt; can change the actual arguments by changing the formal arguments. That is, the formal argument is an &lt;b&gt;alias&lt;/b&gt; for the actual argument. See also &lt;b&gt;call by value&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;引数&lt;/b&gt; -passingメカニズムとは、&lt;b&gt;仮引数を&lt;/b&gt;直接参照する&lt;b&gt;実引数&lt;/b&gt;、および&lt;b&gt;サブルーチンは、&lt;/b&gt;仮引数を変更することで、実引数を変更することができます。つまり、仮引数は実引数の&lt;b&gt;エイリアス&lt;/b&gt;です。&lt;b&gt;値による呼び出し&lt;/b&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="4e9ca74e5eb3ceca0031d5a290a9926f188e9f44" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;argument&lt;/b&gt;-passing mechanism in which the &lt;b&gt;formal arguments&lt;/b&gt; refer to a copy of the &lt;b&gt;actual arguments&lt;/b&gt;, and the &lt;b&gt;subroutine&lt;/b&gt; cannot change the actual arguments by changing the formal arguments. See also &lt;b&gt;call by reference&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;引数&lt;/b&gt; -passingメカニズムとは、&lt;b&gt;仮引数は、&lt;/b&gt;のコピーを参照して&lt;b&gt;実引数&lt;/b&gt;、および&lt;b&gt;サブルーチンは、&lt;/b&gt;仮引数を変更することで、実引数を変更することはできません。参照&lt;b&gt;による呼び出し&lt;/b&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="3ae7537da81b89a37f1fba19db52f45ea5a64265" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that peeks at the string to the left of the current match location.</source>
          <target state="translated">&lt;b&gt;アサーション&lt;/b&gt;現在のマッチ位置の左にある文字列でのぞき見ています。</target>
        </trans-unit>
        <trans-unit id="9186a718ac3c2fd4c0066859c2036b1188f86bf7" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that peeks at the string to the right of the current match location.</source>
          <target state="translated">&lt;b&gt;アサーション&lt;/b&gt;現在のマッチ位置の右にある文字列でのぞき見ています。</target>
        </trans-unit>
        <trans-unit id="fccd6c0eca3ee2fd48a0479b2f7467ef677a981b" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;assertion&lt;/b&gt; that states something exists and perhaps describes what it&amp;rsquo;s like, without giving any commitment as to how or where you&amp;rsquo;ll use it. A declaration is like the part of your recipe that says, &amp;ldquo;two cups flour, one large egg, four or five tadpoles&amp;hellip;&amp;rdquo; See &lt;b&gt;statement&lt;/b&gt; for its opposite. Note that some declarations also function as statements. Subroutine declarations also act as definitions if a body is supplied.</source>
          <target state="translated">&lt;b&gt;アサーション&lt;/b&gt;何かを述べている方法や場所、あなたがそれを使用しますについてどのようなコミットメントを与えることなく、存在し、おそらくそれはどのようなものかを説明します。宣言は、レシピの「小麦粉2カップ、大きな卵1個、オタマジャクシ4つまたは5つ&amp;hellip;」のようなものです。その反対の&lt;b&gt;説明&lt;/b&gt;を参照してください。一部の宣言はステートメントとしても機能することに注意してください。本体が提供されている場合、サブルーチン宣言も定義として機能します。</target>
        </trans-unit>
        <trans-unit id="a79df62ffe9655f3bb9b573a11129a38c97d9727" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;attribute&lt;/b&gt; of an &lt;b&gt;object&lt;/b&gt;; data stored with the particular object rather than with the class as a whole.</source>
          <target state="translated">&lt;b&gt;属性&lt;/b&gt;の&lt;b&gt;オブジェクト&lt;/b&gt;。クラス全体ではなく、特定のオブジェクトで保存されたデータ。</target>
        </trans-unit>
        <trans-unit id="6b5c38c6212536b2650f8fd4b5e6e9c46fa7ac78" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;expression&lt;/b&gt; that evaluates to something that can be used as a &lt;b&gt;filehandle&lt;/b&gt;: a &lt;b&gt;string&lt;/b&gt; (filehandle name), a &lt;b&gt;typeglob&lt;/b&gt;, a typeglob &lt;b&gt;reference&lt;/b&gt;, or a low-level &lt;b&gt;IO&lt;/b&gt; object.</source>
          <target state="translated">&lt;b&gt;表現&lt;/b&gt;として使用することができるものと評価され、その&lt;b&gt;ファイルハンドル&lt;/b&gt;：&lt;b&gt;文字列&lt;/b&gt;（ファイルハンドル名）、&lt;b&gt;型グロブ&lt;/b&gt;、型グロブの&lt;b&gt;リファレンス&lt;/b&gt;、または低レベル&lt;b&gt;のIO&lt;/b&gt;オブジェクト。</target>
        </trans-unit>
        <trans-unit id="a9ea33da0846dba2dfc2c719e640a6b936943a76" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;expression&lt;/b&gt; that yields a &lt;b&gt;value&lt;/b&gt; that an &lt;b&gt;operator&lt;/b&gt; operates on. See also &lt;b&gt;precedence&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;表現&lt;/b&gt;生み出す&lt;b&gt;価値&lt;/b&gt;ことを&lt;b&gt;オペレータが&lt;/b&gt;上で動作します。&lt;b&gt;precedence&lt;/b&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="cc6a827ebadd37467385c749c36afe5cfe5a720e" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;increment&lt;/b&gt; operator that knows how to bump up ASCII alphabetics as well as numbers.</source>
          <target state="translated">&lt;b&gt;インクリメント&lt;/b&gt; ASCIIのアルファベットだけでなく、数字をつり上げる方法を知っているオペレータ。</target>
        </trans-unit>
        <trans-unit id="6e6a46de7223236ab22a0ae8657b922fe424257e" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;instance&lt;/b&gt; of a &lt;b&gt;class&lt;/b&gt;. Something that &amp;ldquo;knows&amp;rdquo; what user-defined type (class) it is, and what it can do because of what class it is. Your program can request an object to do things, but the object gets to decide whether it wants to do them or not. Some objects are more accommodating than others.</source>
          <target state="translated">&lt;b&gt;インスタンス&lt;/b&gt;の&lt;b&gt;クラス&lt;/b&gt;。ユーザー定義型（クラス）とは何か、それがクラスであるために何ができるかを「知っている」何か。プログラムはオブジェクトに処理を要求できますが、オブジェクトは処理を実行するかどうかを決定します。一部のオブジェクトは他のオブジェクトよりも融通が利きます。</target>
        </trans-unit>
        <trans-unit id="193974eee4df69740e47a6c9868c573734e793d8" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;object&lt;/b&gt; is a data structure that bundles together data and subroutines which operate on that data. An object's data is called &lt;b&gt;attributes&lt;/b&gt;, and its subroutines are called &lt;b&gt;methods&lt;/b&gt;. An object can be thought of as a noun (a person, a web service, a computer).</source>
          <target state="translated">&lt;b&gt;オブジェクトは、&lt;/b&gt;一緒にそのデータを操作データとサブルーチンをバンドルデータ構造です。オブジェクトのデータは&lt;b&gt;属性&lt;/b&gt;と呼ばれ、そのサブルーチンは&lt;b&gt;メソッド&lt;/b&gt;と呼ばれ&lt;b&gt;ます&lt;/b&gt;。オブジェクトは名詞（人、Webサービス、コンピューター）と考えることができます。</target>
        </trans-unit>
        <trans-unit id="9f3264403f458576129fd753f7da0132d1126157" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; X&lt;code&gt;that looks something like a &lt;b&gt;literal&lt;/b&gt;,
such as the output-grabbing operator, &amp;lt;literal
moreinfo=&quot;none&quot;&lt;/code&gt;`&amp;gt;</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt; X &lt;code&gt;that looks something like a &lt;b&gt;literal&lt;/b&gt;, such as the output-grabbing operator, &amp;lt;literal moreinfo=&quot;none&quot;&lt;/code&gt; `&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e3876b6031a7c1f940174f56c5f7362a7f615429" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; taking three &lt;b&gt;operands&lt;/b&gt;. Sometimes pronounced &lt;b&gt;trinary&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt; 3つの服用&lt;b&gt;オペランドを&lt;/b&gt;。時には顕著&lt;b&gt;トライナリ&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="209f1fbbc9e85cade5ad6da705d3c26984c35559" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that comes in between its &lt;b&gt;operands&lt;/b&gt;, such as multiplication in &lt;code&gt;24 * 7&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt;の間に来る&lt;b&gt;オペランド&lt;/b&gt;などで乗算など、 &lt;code&gt;24 * 7&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7f71291b7c0cc8bd6ef4195e1d392449e6f1d53" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that comes in between its &lt;b&gt;operands&lt;/b&gt;, such as multiplication in &lt;code&gt;24 * 7&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt;の間に来る&lt;b&gt;オペランド&lt;/b&gt;などで乗算など、 &lt;code&gt;24 * 7&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="463ba99d535672eaf8355ca19021da8d2cf33452" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that does something with a list of values, such as &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt;. Usually used for named built-in operators (such as &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt;) that do not require parentheses around their &lt;b&gt;argument&lt;/b&gt; list.</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt;値のリストで何かをする、などの &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; の。通常、&lt;b&gt;引数&lt;/b&gt;リストを括弧で囲む必要のない、名前付きの組み込み演算子（ &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/unlink&quot;&gt;unlink&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; など）に使用されます。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="74d9d7e2bcff5578ed582b2be81c1fd95c4fc9ac" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that does something with a list of values, such as &lt;code&gt;join&lt;/code&gt; or &lt;code&gt;grep&lt;/code&gt;. Usually used for named built-in operators (such as &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;unlink&lt;/code&gt;, and &lt;code&gt;system&lt;/code&gt;) that do not require parentheses around their &lt;b&gt;argument&lt;/b&gt; list.</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt;値のリストで何かをする、などの &lt;code&gt;join&lt;/code&gt; や &lt;code&gt;grep&lt;/code&gt; の。通常、&lt;b&gt;引数&lt;/b&gt;リストを括弧で囲む必要のない名前付きの組み込み演算子（ &lt;code&gt;print&lt;/code&gt; 、 &lt;code&gt;unlink&lt;/code&gt; 、 &lt;code&gt;system&lt;/code&gt; など）に使用されます。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="de2a4670adc782be015d0bb2ea5ffee02ea42397" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that follows its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;$x++&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt;にその次の&lt;b&gt;オペランドを&lt;/b&gt;のように、 &lt;code&gt;$x++&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2a91b007dceec65feca65e72cf86b169ecd0ff6" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that follows its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;$x++&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt;にその次の&lt;b&gt;オペランドを&lt;/b&gt;のように、 &lt;code&gt;$x++&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f7f1151c5c90e6fb1284f5e0bc779ad8ed2e33c" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that precedes its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;++$x&lt;/code&gt; .</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt;の前にある&lt;b&gt;オペランドを&lt;/b&gt;のように、 &lt;code&gt;++$x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a25f284ffc65045a6c69870223421c5797a335e9" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that precedes its &lt;b&gt;operand&lt;/b&gt;, as in &lt;code&gt;++$x&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt;の前にある&lt;b&gt;オペランドを&lt;/b&gt;のように、 &lt;code&gt;++$x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dabe188f0a1b9c27289c477dd8047df3b523cb5a" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that says whether a particular ordering relationship is &lt;b&gt;true&lt;/b&gt; about a pair of &lt;b&gt;operands&lt;/b&gt;. Perl has both numeric and string relational operators. See &lt;b&gt;collating sequence&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt;特定の順序関係があるかどうかと言う&lt;b&gt;真&lt;/b&gt;のペアに関する&lt;b&gt;オペランド&lt;/b&gt;。Perlには、数値と文字列の両方の関係演算子があります。&lt;b&gt;照合順序を&lt;/b&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="717a4af81f7132fc96e1d23c981f1ff3401e5290" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that surrounds its &lt;b&gt;operand&lt;/b&gt;, like the angle operator, or parentheses, or a hug.</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt;その包囲&lt;b&gt;オペランドを&lt;/b&gt;角度演算など、または括弧、または抱擁。</target>
        </trans-unit>
        <trans-unit id="355f7096b65520d72731600341dac924b0bb6aad" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; that takes two &lt;b&gt;operands&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt; 2つの取る&lt;b&gt;オペランドを&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="b7885e2c7085b9ecc7bc4fd21946e64edd22e910" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;operator&lt;/b&gt; whose assigned mission in life is to change the value of a &lt;b&gt;variable&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;オペレータ&lt;/b&gt;その割り当てられた使命生活の中での値を変更することで&lt;b&gt;、変数を&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="7b3959ebca99af56cd591ab2c731b4edab6ffa5f" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;ordinary paragraph&lt;/b&gt;. A paragraph is an ordinary paragraph if its first line matches neither &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; nor &lt;code&gt;m/\A[ \t]/&lt;/code&gt; ,</source>
          <target state="translated">&lt;b&gt;普通の段落&lt;/b&gt;。最初の行が &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m/\A=[a-zA-Z]/&lt;/a&gt;&lt;/code&gt; も &lt;code&gt;m/\A[ \t]/&lt;/code&gt; にも一致しない場合、段落は通常の段落です。</target>
        </trans-unit>
        <trans-unit id="8dd7686cbc9fa2ea98c8a7eb1004bca8a6b2e068" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;ordinary paragraph&lt;/b&gt;. A paragraph is an ordinary paragraph if its first line matches neither &lt;code&gt;m/\A=[a-zA-Z]/&lt;/code&gt; nor &lt;code&gt;m/\A[ \t]/&lt;/code&gt;,</source>
          <target state="translated">&lt;b&gt;普通の段落&lt;/b&gt;。最初の行が &lt;code&gt;m/\A=[a-zA-Z]/&lt;/code&gt; も &lt;code&gt;m/\A[ \t]/&lt;/code&gt; にも一致しない場合、段落は通常の段落です。</target>
        </trans-unit>
        <trans-unit id="d98f8de412a14cfe117cc1f33fdf08a188a327cd" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without an argument uses the last file read. Using &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; with empty parentheses is different. It refers to the pseudo file formed from the files listed on the command line and accessed via the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. Since &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; isn't explicitly opened, as a normal filehandle is, an &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; before &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has been used will cause &lt;code&gt;@ARGV&lt;/code&gt; to be examined to determine if input is available. Similarly, an &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; after &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has returned end-of-file will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from &lt;code&gt;STDIN&lt;/code&gt; ; see &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">引数なしの &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; は、最後に読み込まれたファイルを使用します。空の括弧で &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; を使用することは異なります。コマンドラインにリストされ、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 演算子を介してアクセスされるファイルから形成された疑似ファイルを参照します。 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; は明示的に開かれていないため、通常のファイルハンドルと同様に、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; が使用される前に &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; を使用すると、 &lt;code&gt;@ARGV&lt;/code&gt; が検査され、入力が利用可能かどうかが判断されます。同様に、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; がファイルの終わりを返した後の &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; は、別の &lt;code&gt;@ARGV&lt;/code&gt; リストを処理していると想定し、 &lt;code&gt;@ARGV&lt;/code&gt; 設定していない場合は、 &lt;code&gt;STDIN&lt;/code&gt; から入力を読み取ります; &lt;a href=&quot;../perlop#I%2fO-Operators&quot;&gt;perlopのI / O演算子を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="b538c9784366b2a5b380fc1646cd6d2c36676cbb" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; executed within a subroutine defined in the &lt;code&gt;DB&lt;/code&gt; package doesn't see the usual surrounding lexical scope, but rather the scope of the first non-DB piece of code that called it. You don't normally need to worry about this unless you are writing a Perl debugger.</source>
          <target state="translated">&lt;code&gt;DB&lt;/code&gt; パッケージで定義されたサブルーチン内で実行された &lt;code&gt;&lt;a href=&quot;eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; は、通常の周囲の字句スコープを認識しませんが、それを呼び出した最初のDB以外のコードのスコープを認識します。Perlデバッガーを作成しているのでない限り、通常はこのことを心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="9638cc264773db141fdbff9966aa75b61a42b264" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; without an argument uses the last file read. Using &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; with empty parentheses is different. It refers to the pseudo file formed from the files listed on the command line and accessed via the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator. Since &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; isn't explicitly opened, as a normal filehandle is, an &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; before &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has been used will cause &lt;code&gt;@ARGV&lt;/code&gt; to be examined to determine if input is available. Similarly, an &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; after &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; has returned end-of-file will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from &lt;code&gt;STDIN&lt;/code&gt; ; see &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">引数なしの &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; は、最後に読み込まれたファイルを使用します。空の括弧で &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; を使用することは異なります。コマンドラインにリストされ、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 演算子を介してアクセスされるファイルから形成された疑似ファイルを参照します。 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; は明示的に開かれていないため、通常のファイルハンドルと同様に、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; が使用される前に &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; を使用すると、 &lt;code&gt;@ARGV&lt;/code&gt; が検査され、入力が利用可能かどうかが判断されます。同様に、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; がファイルの終わりを返した後の &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof()&lt;/a&gt;&lt;/code&gt; は、別の &lt;code&gt;@ARGV&lt;/code&gt; リストを処理していると想定し、 &lt;code&gt;@ARGV&lt;/code&gt; 設定していない場合は、 &lt;code&gt;STDIN&lt;/code&gt; から入力を読み取ります; &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;perlopのI / O演算子を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="f39d8054296556b4b922794a4d5a34f617f1fc94" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt;, however, can see lexical variables of the scope it is being evaluated in, so long as the names aren't hidden by declarations within the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; itself. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; は、しかし、そう長い名前が内の宣言によって隠されていないとして、それが中に評価されているスコープのレキシカル変数を見ることができる &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; そのもの。&lt;a href=&quot;perlref&quot;&gt;perlrefを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6342bae4fda60017077e5c45e326240a9752de8d" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; executed within a subroutine defined in the &lt;code&gt;DB&lt;/code&gt; package doesn't see the usual surrounding lexical scope, but rather the scope of the first non-DB piece of code that called it. You don't normally need to worry about this unless you are writing a Perl debugger.</source>
          <target state="translated">&lt;code&gt;DB&lt;/code&gt; パッケージで定義されたサブルーチン内で実行された &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; ''&lt;/code&gt; は、通常の周囲の字句スコープを認識しませんが、それを呼び出した最初のDB以外のコードのスコープを認識します。Perlデバッガーを作成しているのでない限り、通常はこのことを心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="e98b3b90e3045dc3b637b5a6dd09b73503e89407" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration declares an alias for a package variable that will be visible across its entire lexical scope, even across package boundaries. The package in which the variable is entered is determined at the point of the declaration, not at the point of use. This means the following behavior holds:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 宣言はしても、パッケージ境界を越えて、その全体のレキシカルスコープ全体に表示されますパッケージ変数のエイリアスを宣言します。変数が入力されるパッケージは、使用の時点ではなく、宣言の時点で決定されます。つまり、次の動作が保持されます。</target>
        </trans-unit>
        <trans-unit id="b85b4821ea02e10c76868c61d73ce67c03c3c58f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration may also have a list of attributes associated with it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 宣言はまた、それに関連する属性のリストを有することができます。</target>
        </trans-unit>
        <trans-unit id="0e6a38b5837351a0fa7ad12169129c95c04803d4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration declares an alias for a package variable that will be visible across its entire lexical scope, even across package boundaries. The package in which the variable is entered is determined at the point of the declaration, not at the point of use. This means the following behavior holds:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 宣言はしても、パッケージ境界を越えて、その全体のレキシカルスコープ全体に表示されますパッケージ変数のエイリアスを宣言します。変数が入力されるパッケージは、使用の時点ではなく、宣言の時点で決定されます。つまり、次の動作が保持されます。</target>
        </trans-unit>
        <trans-unit id="ff67756e1b83b8c246879fd06b2405feac998276" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaration may also have a list of attributes associated with it.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 宣言はまた、それに関連する属性のリストを有することができます。</target>
        </trans-unit>
        <trans-unit id="09f284e34c7193100513bdbf0c748168a131c400" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;=item&lt;/code&gt; or &lt;code&gt;=back&lt;/code&gt; command has been found outside a &lt;code&gt;=over&lt;/code&gt; /&lt;code&gt;=back&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;=item&lt;/code&gt; または &lt;code&gt;=back&lt;/code&gt; コマンドは、外部発見された &lt;code&gt;=over&lt;/code&gt; / &lt;code&gt;=back&lt;/code&gt; ブロック。</target>
        </trans-unit>
        <trans-unit id="74ddbf837617e690734ce4e331574925980ad4cf" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;=item&lt;/code&gt; or &lt;code&gt;=back&lt;/code&gt; command has been found outside a &lt;code&gt;=over&lt;/code&gt;/&lt;code&gt;=back&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;=item&lt;/code&gt; または &lt;code&gt;=back&lt;/code&gt; コマンドは、外部発見された &lt;code&gt;=over&lt;/code&gt; / &lt;code&gt;=back&lt;/code&gt; ブロック。</target>
        </trans-unit>
        <trans-unit id="66cb1e02933a96ffc4b888e742e11e5e2a0810c8" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;END&lt;/code&gt; code block is executed as late as possible, that is, after perl has finished running the program and just before the interpreter is being exited, even if it is exiting as a result of a die() function. (But not if it's morphing into another program via &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, or being blown out of the water by a signal--you have to trap that yourself (if you can).) You may have multiple &lt;code&gt;END&lt;/code&gt; blocks within a file--they will execute in reverse order of definition; that is: last in, first out (LIFO). &lt;code&gt;END&lt;/code&gt; blocks are not executed when you run perl with the &lt;code&gt;-c&lt;/code&gt; switch, or if compilation fails.</source>
          <target state="translated">&lt;code&gt;END&lt;/code&gt; のコードブロックは、それがダイ（）関数の結果として出た場合であっても、Perlはプログラムを実行して終了し、インタプリタが終了される直前後に、すなわち、できるだけ遅くとして実行されます。 （ただし、 &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; を介して別のプログラムにモーフィングしている場合や、信号によって水から吹き飛ばされている場合は-自分でトラップする必要があります（可能であれば）。）ファイル内に複数の &lt;code&gt;END&lt;/code&gt; ブロックがある場合があります-それらは定義の逆の順序で実行します。つまり、後入れ先出し（LIFO）です。 &lt;code&gt;-c&lt;/code&gt; スイッチを指定してperlを実行した場合、またはコンパイルが失敗した場合、 &lt;code&gt;END&lt;/code&gt; ブロックは実行されません。</target>
        </trans-unit>
        <trans-unit id="e942cc0968d145d9b00a1b1c78467e33e46acc43" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;END&lt;/code&gt; code block is executed as late as possible, that is, after perl has finished running the program and just before the interpreter is being exited, even if it is exiting as a result of a die() function. (But not if it's morphing into another program via &lt;code&gt;exec&lt;/code&gt;, or being blown out of the water by a signal--you have to trap that yourself (if you can).) You may have multiple &lt;code&gt;END&lt;/code&gt; blocks within a file--they will execute in reverse order of definition; that is: last in, first out (LIFO). &lt;code&gt;END&lt;/code&gt; blocks are not executed when you run perl with the &lt;code&gt;-c&lt;/code&gt; switch, or if compilation fails.</source>
          <target state="translated">&lt;code&gt;END&lt;/code&gt; のコードブロックは、それがダイ（）関数の結果として出た場合であっても、Perlはプログラムを実行して終了し、インタプリタが終了される直前後に、すなわち、できるだけ遅くとして実行されます。（ただし、 &lt;code&gt;exec&lt;/code&gt; を介して別のプログラムにモーフィングしている場合や、シグナルによって水から吹き飛ばされている場合は、そうではありません。（可能であれば）自分でトラップする必要があります。）ファイル内に複数の &lt;code&gt;END&lt;/code&gt; ブロックがある場合があります。定義の逆の順序で実行します。つまり、後入れ先出し（LIFO）です。 &lt;code&gt;-c&lt;/code&gt; スイッチを指定してperlを実行した場合、またはコンパイルが失敗した場合、 &lt;code&gt;END&lt;/code&gt; ブロックは実行されません。</target>
        </trans-unit>
        <trans-unit id="2e32fa7ec52528fa53daf789a891351a0047191f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ExtUtils::Typemaps&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;ExtUtils::Typemaps&lt;/code&gt; オブジェクト。</target>
        </trans-unit>
        <trans-unit id="2106dcfb583dc95f2d7d0a7530b5308a6cea8ccd" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;IO::Handle&lt;/code&gt; object is a reference to a symbol/GLOB reference (see the &lt;code&gt;Symbol&lt;/code&gt; package). Some modules that inherit from &lt;code&gt;IO::Handle&lt;/code&gt; may want to keep object related variables in the hash table part of the GLOB. In an attempt to prevent modules trampling on each other I propose the that any such module should prefix its variables with its own name separated by _'s. For example the IO::Socket module keeps a &lt;code&gt;timeout&lt;/code&gt; variable in 'io_socket_timeout'.</source>
          <target state="translated">AN &lt;code&gt;IO::Handle&lt;/code&gt; オブジェクトは、シンボル/ GLOB参照への参照（参照ある &lt;code&gt;Symbol&lt;/code&gt; パッケージ）。 &lt;code&gt;IO::Handle&lt;/code&gt; から継承する一部のモジュールは、オブジェクトに関連する変数をGLOBのハッシュテーブル部分に保持したい場合があります。モジュールが互いに踏みつぶさないようにするために、そのようなモジュールは、変数の前に_で区切られた独自の名前を付けることをお勧めします。たとえば、IO :: Socketモジュールは &lt;code&gt;timeout&lt;/code&gt; 変数を「io_socket_timeout」に保持します。</target>
        </trans-unit>
        <trans-unit id="ddbf17a10e023000ccc30961ca5b0d4cd79dd73a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;eval ''&lt;/code&gt; executed within a subroutine defined in the &lt;code&gt;DB&lt;/code&gt; package doesn't see the usual surrounding lexical scope, but rather the scope of the first non-DB piece of code that called it. You don't normally need to worry about this unless you are writing a Perl debugger.</source>
          <target state="translated">&lt;code&gt;DB&lt;/code&gt; パッケージで定義されたサブルーチン内で実行された &lt;code&gt;eval ''&lt;/code&gt; は、通常の周囲の字句スコープではなく、それを呼び出した最初の非DBコードのスコープを認識します。Perlデバッガーを作成していない限り、通常はこれについて心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="daf77a66a50c9398b1fd7246b531ff3583302d3a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;eval()&lt;/code&gt;, however, can see lexical variables of the scope it is being evaluated in, so long as the names aren't hidden by declarations within the &lt;code&gt;eval()&lt;/code&gt; itself. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;eval()&lt;/code&gt; は、しかし、そう長い名前が内の宣言によって隠されていないとして、それが中に評価されているスコープのレキシカル変数を見ることができる &lt;code&gt;eval()&lt;/code&gt; そのもの。&lt;a href=&quot;perlref&quot;&gt;perlrefを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="4327b0847cdc34977cdbdda7e68546f97fba6ace" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;https&lt;/code&gt; connection may be made via an &lt;code&gt;http&lt;/code&gt; proxy that supports the CONNECT command (i.e. RFC 2817). You may not proxy &lt;code&gt;https&lt;/code&gt; via a proxy that itself requires &lt;code&gt;https&lt;/code&gt; to communicate.</source>
          <target state="translated">&lt;code&gt;https&lt;/code&gt; 接続を経由して行うことができる &lt;code&gt;http&lt;/code&gt; CONNECTコマンド（つまり、RFC 2817）をサポートし、プロキシ。それ自体が通信に &lt;code&gt;https&lt;/code&gt; を必要とするプロキシを介して &lt;code&gt;https&lt;/code&gt; をプロキシすることはできません。</target>
        </trans-unit>
        <trans-unit id="bb7b8e2c63742b11c42dcae1ac500eab80f3ab56" translate="yes" xml:space="preserve">
          <source>An Array Reference</source>
          <target state="translated">配列リファレンス</target>
        </trans-unit>
        <trans-unit id="8d4bdf476b3365f09a887c13f6c40076ebfaf6c1" translate="yes" xml:space="preserve">
          <source>An Aside About Smarter and Safer Code</source>
          <target state="translated">よりスマートで安全なコードについての余談</target>
        </trans-unit>
        <trans-unit id="3b01e7833f6ef8368a6a19aec43504160373e004" translate="yes" xml:space="preserve">
          <source>An E&amp;lt;...&amp;gt; surrounding strange content</source>
          <target state="translated">奇妙なコンテンツを取り巻くE &amp;lt;...&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e626c65821f55eedc24b3d056f760901055b33ab" translate="yes" xml:space="preserve">
          <source>An Error Handler</source>
          <target state="translated">エラーハンドラ</target>
        </trans-unit>
        <trans-unit id="d96ae95b9e6d2684c36b739e4e16b84332bd4be3" translate="yes" xml:space="preserve">
          <source>An Event-Driven Program</source>
          <target state="translated">イベント駆動型プログラム</target>
        </trans-unit>
        <trans-unit id="dcd29613666219a97f2491f0610be4945ceed298" translate="yes" xml:space="preserve">
          <source>An Example</source>
          <target state="translated">一例</target>
        </trans-unit>
        <trans-unit id="f8c1ce33e34656d389a163577db68ecf2ef0ded0" translate="yes" xml:space="preserve">
          <source>An Example -- the NULL termination problem.</source>
          <target state="translated">例 --NULL終端問題。</target>
        </trans-unit>
        <trans-unit id="b0338e71cce0b4ccb879ecd4b7099e83ebe3be92" translate="yes" xml:space="preserve">
          <source>An Example: the NULL termination problem.</source>
          <target state="translated">例:NULL終了問題。</target>
        </trans-unit>
        <trans-unit id="8c00947f1047eee3af23c94728ed5ad710d9cb2f" translate="yes" xml:space="preserve">
          <source>An INSTALL file should be included, and should contain simple installation instructions. When using ExtUtils::MakeMaker this will usually be:</source>
          <target state="translated">INSTALL ファイルが含まれており、簡単なインストール手順が含まれている必要があります。ExtUtils::MakeMaker を使用する場合、通常はこれになります。</target>
        </trans-unit>
        <trans-unit id="506b7c2a6739d4b086313431ab2d8807d26d26ea" translate="yes" xml:space="preserve">
          <source>An Input FileGlob string</source>
          <target state="translated">入力 FileGlob 文字列</target>
        </trans-unit>
        <trans-unit id="c6d4eb0ecab7adc479ea3b6eef3a6aca32ccbec3" translate="yes" xml:space="preserve">
          <source>An OFFSET may be specified to place the read data at some place in the string other than the beginning. A negative OFFSET specifies placement at that many characters counting backwards from the end of the string. A positive OFFSET greater than the length of SCALAR results in the string being padded to the required size with &lt;code&gt;&quot;\0&quot;&lt;/code&gt; bytes before the result of the read is appended.</source>
          <target state="translated">オフセットを指定して、読み取ったデータを文字列の先頭以外の場所に配置できます。負のOFFSETは、文字列の末尾から逆方向に数える多くの文字の配置を指定します。 SCALARの長さより大きい正のOFFSET は、読み取りの結果が追加される前に、文字列が &lt;code&gt;&quot;\0&quot;&lt;/code&gt; バイトで必要なサイズになるように埋め込まれます。</target>
        </trans-unit>
        <trans-unit id="0dc3cbd84029f4f613840045b9422510efa87d84" translate="yes" xml:space="preserve">
          <source>An OFFSET may be specified to write the data from some part of the string other than the beginning. A negative OFFSET specifies writing that many characters counting backwards from the end of the string. If SCALAR is of length zero, you can only use an OFFSET of 0.</source>
          <target state="translated">OFFSETを指定すると、文字列の先頭以外の部分からデータを書き込むことができます。負のOFFSETを指定すると、文字列の末尾から逆算してその数だけの文字を書き込むことができます。SCALARが長さ0の場合、0のOFFSETしか使用できません。</target>
        </trans-unit>
        <trans-unit id="bd9383fdee820dfd7a79259db8339a2ec8fb85d9" translate="yes" xml:space="preserve">
          <source>An Object is Simply a Data Structure</source>
          <target state="translated">オブジェクトは単なるデータ構造</target>
        </trans-unit>
        <trans-unit id="a75b7e5900f9f9a5e2336a6194fd54179bb27c7e" translate="yes" xml:space="preserve">
          <source>An Output FileGlob</source>
          <target state="translated">出力FileGlob</target>
        </trans-unit>
        <trans-unit id="813d4e6c344e0e779c908b93f3b8922ba5b51b2f" translate="yes" xml:space="preserve">
          <source>An RDF vocabulary to describe software projects. &lt;a href=&quot;http://usefulinc.com/doap&quot;&gt;http://usefulinc.com/doap&lt;/a&gt;.</source>
          <target state="translated">ソフトウェアプロジェクトを説明するためのRDF語彙。&lt;a href=&quot;http://usefulinc.com/doap&quot;&gt;http://usefulinc.com/doap&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2be5f7e627a6ada01e5f83f900c749a12504c5b" translate="yes" xml:space="preserve">
          <source>An RPN expression can also be interpreted in another way, as a sequence of operations on a stack, one operation per token. A literal or variable token pushes a value onto the stack. A binary operator pulls two items off the stack, performs a calculation with them, and pushes the result back onto the stack. The stack starts out empty, and at the end of the expression there must be exactly one value left on the stack.</source>
          <target state="translated">また、RPN式は別の方法で、スタック上の一連の操作として解釈することもできます。リテラルまたは変数トークンは、値をスタックにプッシュします。バイナリ演算子は、スタックから 2 つの項目を取り出して計算を行い、その結果をスタックに戻します。スタックは最初は空で、式の最後にはスタック上に正確に1つの値が残っていなければなりません。</target>
        </trans-unit>
        <trans-unit id="451423395ae3ecccc772428a72078e3af59aea77" translate="yes" xml:space="preserve">
          <source>An RPN expression may be any of:</source>
          <target state="translated">RPN発現は、以下のいずれかであってもよい。</target>
        </trans-unit>
        <trans-unit id="e69ceb552111cae999e0e9d8f79c888a4e18b2ab" translate="yes" xml:space="preserve">
          <source>An SV (or AV, HV, etc.) is allocated in two parts: the head (struct sv, av, hv...) contains type and reference count information, and for many types, a pointer to the body (struct xrv, xpv, xpviv...), which contains fields specific to each type. Some types store all they need in the head, so don't have a body.</source>
          <target state="translated">SV (または AV、HV など)は 2 つの部分に分かれて割り当てられます。ヘッド (構造体 sv,av,hv...)には型と参照カウントの情報が格納され、多くの型ではボディ (構造体 xrv,xpv,xpviv...)へのポインタが格納されます。型の中には、必要な情報をすべてヘッドに格納しているものもあり、ボディを持たないものもあります。</target>
        </trans-unit>
        <trans-unit id="0db48295b7cb634bd39479ea9baf6751db33420c" translate="yes" xml:space="preserve">
          <source>An SV can be created and loaded with one command. There are five types of values that can be loaded: an integer value (IV), an unsigned integer value (UV), a double (NV), a string (PV), and another scalar (SV). (&quot;PV&quot; stands for &quot;Pointer Value&quot;. You might think that it is misnamed because it is described as pointing only to strings. However, it is possible to have it point to other things. For example, it could point to an array of UVs. But, using it for non-strings requires care, as the underlying assumption of much of the internals is that PVs are just for strings. Often, for example, a trailing &lt;code&gt;NUL&lt;/code&gt; is tacked on automatically. The non-string use is documented only in this paragraph.)</source>
          <target state="translated">SVは1つのコマンドで作成およびロードできます。ロードできる値には、整数値（IV）、符号なし整数値（UV）、倍精度浮動小数点数（NV）、文字列（PV）、および別のスカラー（SV）の5つのタイプがあります。（ &quot;PV&quot;は &quot;ポインタ値&quot;を表します。文字列のみを指すものとして説明されているため、誤った名前になっていると思うかもしれません。ただし、他のものを指すようにすることもできます。たとえば、配列を指すことができます。 UVの使用。ただし、PVは文字列専用であるという内部構造の多くの根本的な前提として、非文字列に使用する場合は注意が必要です。たとえば、多くの場合、末尾の &lt;code&gt;NUL&lt;/code&gt; は自動的に追加されます。非文字列の使用はこの段落でのみ文書化されています。）</target>
        </trans-unit>
        <trans-unit id="e49daf61f2f4bab338dc0435e2098c4740ae32f6" translate="yes" xml:space="preserve">
          <source>An SV may be passed as a second argument. If so, the name will be assigned to it and it will be returned. Otherwise the returned SV will be a new mortal.</source>
          <target state="translated">第二引数に SV を渡すことができます。その場合、名前が割り当てられて返されます。そうでなければ、返された SV は新しい人間になります。</target>
        </trans-unit>
        <trans-unit id="7e60a0da99f77ec00184644cb08929c2fbb88e98" translate="yes" xml:space="preserve">
          <source>An URL for a bug tracker (e.g. Bugzilla or RT queue) for this project.</source>
          <target state="translated">このプロジェクトのためのバグトラッカー (Bugzilla や RT キューなど)の URL。</target>
        </trans-unit>
        <trans-unit id="5cb53ac6b527ff22855aa21b588aeb5e456de693" translate="yes" xml:space="preserve">
          <source>An URL for an official statement of this distribution's license.</source>
          <target state="translated">このディストリビューションのライセンスの公式声明のURL。</target>
        </trans-unit>
        <trans-unit id="c8d6fdbeeb22295aa04aac68ad9fd7f77cf9046a" translate="yes" xml:space="preserve">
          <source>An XS module that is locale-dependent could have been written under the assumption that it will never be called in a multi-threaded environment, and so uses other non-locale constructs that aren't multi-thread-safe. See &lt;a href=&quot;perlxs#Thread-aware-system-interfaces&quot;&gt;&quot;Thread-aware system interfaces&quot; in perlxs&lt;/a&gt;.</source>
          <target state="translated">ロケールに依存するXSモジュールは、マルチスレッド環境では呼び出されないという前提で記述されている可能性があるため、マルチスレッドセーフではない他の非ロケール構造を使用します。&lt;a href=&quot;perlxs#Thread-aware-system-interfaces&quot;&gt;perlxsの「スレッド対応システムインターフェイス」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="35a93457850bdbb33ca102c024544fcdc99dd999" translate="yes" xml:space="preserve">
          <source>An XSUB section continues until another section-start keyword is found.</source>
          <target state="translated">XSUBセクションは、別のセクション開始キーワードが見つかるまで継続します。</target>
        </trans-unit>
        <trans-unit id="db98408a971f988d838aae97c21a88cbfeff498b" translate="yes" xml:space="preserve">
          <source>An abstract character&amp;rsquo;s integer value. Same thing as &lt;b&gt;codepoint&lt;/b&gt;.</source>
          <target state="translated">抽象文字の整数値。&lt;b&gt;コードポイントと&lt;/b&gt;同じです。</target>
        </trans-unit>
        <trans-unit id="bd8526c4f7f2f82dc46961c40bfa270781cafa7e" translate="yes" xml:space="preserve">
          <source>An accessor function can be redefined in order to provide additional checking of values, etc. Here, we want the &lt;code&gt;count&lt;/code&gt; element always to be nonnegative, so we redefine the &lt;code&gt;count&lt;/code&gt; accessor accordingly.</source>
          <target state="translated">値の追加チェックなどを提供するために、アクセサー関数を再定義できます。ここでは、 &lt;code&gt;count&lt;/code&gt; 要素を常に非負にしたいので、それに応じて &lt;code&gt;count&lt;/code&gt; アクセサーを再定義します。</target>
        </trans-unit>
        <trans-unit id="76864d299088548272113a8d31dd2510d163d674" translate="yes" xml:space="preserve">
          <source>An accessor lets you add additional code around attribute access. For example, you could apply a default to an attribute that wasn't set in the constructor, or you could validate that a new value for the attribute is acceptable.</source>
          <target state="translated">アクセサを使用すると、属性へのアクセスに関するコードを追加することができます。例えば、コンストラクタで設定されていない属性にデフォルトを適用したり、属性の新しい値が許容されるかどうかを検証したりすることができます。</target>
        </trans-unit>
        <trans-unit id="7f7dfcb0e79b76d6607a032d4c42004b6d846b72" translate="yes" xml:space="preserve">
          <source>An action that terminates a process will terminate</source>
          <target state="translated">プロセスを終了させるアクションは、次のように終了します。</target>
        </trans-unit>
        <trans-unit id="3d55486b7ae618b0c9e5822b88065546dbd8b09b" translate="yes" xml:space="preserve">
          <source>An actual piece of data, in contrast to all the variables, references, keys, indices, operators, and whatnot that you need to access the value.</source>
          <target state="translated">変数、参照、キー、インデックス、演算子、および値にアクセスするために必要なすべてのものとは対照的に、実際のデータの一部。</target>
        </trans-unit>
        <trans-unit id="1e18a14c7435e1ad99b33d06cb67211ccd6f13ff" translate="yes" xml:space="preserve">
          <source>An adjectival pseudofunction that warps the meaning of an &lt;b&gt;lvalue&lt;/b&gt; in some declarative fashion. Currently there are three lvalue modifiers: &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">ある宣言的な方法で&lt;b&gt;左辺値&lt;/b&gt;の意味をゆがめる形容詞の疑似関数。現在、3つの左辺値修飾子があります： &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="147929b2af4f7b23dfdf17e155cb639bdee82ce1" translate="yes" xml:space="preserve">
          <source>An adjectival pseudofunction that warps the meaning of an &lt;b&gt;lvalue&lt;/b&gt; in some declarative fashion. Currently there are three lvalue modifiers: &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt;, and &lt;code&gt;local&lt;/code&gt;.</source>
          <target state="translated">ある宣言的な方法で&lt;b&gt;左辺値&lt;/b&gt;の意味を歪める形容詞の疑似関数。現在、3つの左辺値修飾子があります： &lt;code&gt;my&lt;/code&gt; 、 &lt;code&gt;our&lt;/code&gt; 、および &lt;code&gt;local&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="450e105909f5464a91b8d711013a548cdad0ecea" translate="yes" xml:space="preserve">
          <source>An algorithm to map a character set to a byte sequence. You don't have to be able to tell which character set a given byte sequence belongs. 7-bit ISO-2022 is a CES but it cannot be a CCS. EUC is an example of being both a CCS and CES.</source>
          <target state="translated">文字セットをバイト列にマッピングするアルゴリズム。与えられたバイト列がどの文字セットに属するかを識別する必要はない。7ビットISO-2022はCESですが、CCSにはなりません。EUCはCCSとCESの両方を兼ねている例です。</target>
        </trans-unit>
        <trans-unit id="1ddce428631d662b65df938a0ab59dc6d26df5c3" translate="yes" xml:space="preserve">
          <source>An alias can map to either an official Unicode character name (not a loose matched name) or to a numeric code point (ordinal). The latter is useful for assigning names to code points in Unicode private use areas such as U+E800 through U+F8FF. A numeric code point must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; , it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="translated">エイリアスは、正式なUnicode文字名（完全に一致しない名前ではない）または数値コードポイント（序数）のいずれかにマップできます。後者は、U + E800からU + F8FFなどのUnicodeプライベート使用領域のコードポイントに名前を割り当てる場合に便利です。数値コードポイントは、負でない整数、または &lt;code&gt;&quot;U+&quot;&lt;/code&gt; または &lt;code&gt;&quot;0x&quot;&lt;/code&gt; で始まり、残りが16進整数と見なされる文字列である必要があります。リテラル数値定数は符号なしでなければなりません。先頭に0が付いているか、10進数以外の16進数が含まれている場合、16進数として解釈されます。それ以外の場合は、10進数として解釈されます。 &lt;code&gt;&quot;U+&quot;&lt;/code&gt; で始まる場合は、Unicodeコードポイントとして解釈されます。それ以外の場合は、ネイティブとして解釈されます。 （256未満のコードポイントのみがUnicodeとネイティブの間で異なる可能性があります。）したがって &lt;code&gt;U+41&lt;/code&gt; は常にラテン文字「A」です。ただし、EBCDICプラットフォームでは &lt;code&gt;0x41&lt;/code&gt; を「NO-BREAK SPACE」にすることができます。</target>
        </trans-unit>
        <trans-unit id="307b5df586934d78ce8b5dabe9ab9b8c2f875563" translate="yes" xml:space="preserve">
          <source>An alias can map to either an official Unicode character name (not a loose matched name) or to a numeric code point (ordinal). The latter is useful for assigning names to code points in Unicode private use areas such as U+E800 through U+F8FF. A numeric code point must be a non-negative integer, or a string beginning with &lt;code&gt;&quot;U+&quot;&lt;/code&gt; or &lt;code&gt;&quot;0x&quot;&lt;/code&gt; with the remainder considered to be a hexadecimal integer. A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal. If it begins with &lt;code&gt;&quot;U+&quot;&lt;/code&gt;, it is interpreted as the Unicode code point; otherwise it is interpreted as native. (Only code points below 256 can differ between Unicode and native.) Thus &lt;code&gt;U+41&lt;/code&gt; is always the Latin letter &quot;A&quot;; but &lt;code&gt;0x41&lt;/code&gt; can be &quot;NO-BREAK SPACE&quot; on EBCDIC platforms.</source>
          <target state="translated">エイリアスは、公式のUnicode文字名（厳密に一致する名前ではない）または数値コードポイント（序数）のいずれかにマップできます。後者は、U + E800からU + F8FFなどのUnicode私用領域のコードポイントに名前を割り当てるのに役立ちます。数値コードポイントは、負でない整数、または &lt;code&gt;&quot;U+&quot;&lt;/code&gt; または &lt;code&gt;&quot;0x&quot;&lt;/code&gt; で始まり、余りが16進整数と見なされる文字列である必要があります。リテラル数値定数は符号なしでなければなりません。先行ゼロがある場合、または10進数以外の16進数が含まれている場合は、16進数として解釈されます。それ以外の場合は、10進数として解釈されます。 &lt;code&gt;&quot;U+&quot;&lt;/code&gt; で始まる場合は、Unicodeコードポイントとして解釈されます。それ以外の場合は、ネイティブとして解釈されます。 （Unicodeとネイティブの間で異なるのは256未満のコードポイントのみです。）したがって、 &lt;code&gt;U+41&lt;/code&gt; は常にラテン文字の「A」です。ただし、EBCDICプラットフォームでは、 &lt;code&gt;0x41&lt;/code&gt; を「ノーブレークスペース」にすることができます。</target>
        </trans-unit>
        <trans-unit id="2346eaad655197a010139149e8271c64c649a891" translate="yes" xml:space="preserve">
          <source>An alias for fullname</source>
          <target state="translated">フルネームの別名</target>
        </trans-unit>
        <trans-unit id="7fe1e0c1ce121b1e661962490b3a8d17f0df008e" translate="yes" xml:space="preserve">
          <source>An alias for hostfqdn ().</source>
          <target state="translated">hostfqdn ()のエイリアス。</target>
        </trans-unit>
        <trans-unit id="0f9c5134c84e70c19466ac6665667bdc11f335df" translate="yes" xml:space="preserve">
          <source>An alphanumeric name preceded by dollar sign refers to a Perl scalar variable. Only variables declared with &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;state&lt;/code&gt; are supported. If the variable's value is not a native integer, it will be converted to an integer, by Perl's usual mechanisms, at the time it is evaluated.</source>
          <target state="translated">ドル記号が前に付いた英数字の名前は、Perlスカラー変数を指します。 &lt;code&gt;my&lt;/code&gt; または &lt;code&gt;state&lt;/code&gt; で宣言された変数のみがサポートされます。変数の値がネイティブ整数でない場合は、評価時にPerlの通常のメカニズムによって整数に変換されます。</target>
        </trans-unit>
        <trans-unit id="fa449dd40ff0246bd3a833083086ff6fe9ea989c" translate="yes" xml:space="preserve">
          <source>An alternate (and possibly simpler) method to pushing values on the stack is to use the macro:</source>
          <target state="translated">スタックに値をプッシュする別の (おそらくもっとシンプルな)方法としては、マクロを使用する方法があります。</target>
        </trans-unit>
        <trans-unit id="1921a2093ccc86489ce0ad3cb2bb5dbbb1b5fcf0" translate="yes" xml:space="preserve">
          <source>An alternate delimiter may be specified using &lt;a href=&quot;#-Fpattern&quot;&gt;-F&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#-Fpattern&quot;&gt;-F&lt;/a&gt;を使用して、代替の区切り文字を指定できます。</target>
        </trans-unit>
        <trans-unit id="490e5f218f41d502acc0f80b9b4c03244664bdb6" translate="yes" xml:space="preserve">
          <source>An alternate delimiter may be specified using &lt;b&gt;-F&lt;/b&gt;.</source>
          <target state="translated">代替の区切り文字は、&lt;b&gt;-F&lt;/b&gt;を使用して指定できます。</target>
        </trans-unit>
        <trans-unit id="a3cee96423e82840fff05ec16e3bc4bd5558bd28" translate="yes" xml:space="preserve">
          <source>An alternate filename that points to the real &lt;b&gt;filename&lt;/b&gt;, which in turn points to the real &lt;b&gt;file&lt;/b&gt;. Whenever the &lt;b&gt;operating system&lt;/b&gt; is trying to parse a &lt;b&gt;pathname&lt;/b&gt; containing a symbolic link, it merely substitutes the new name and continues parsing.</source>
          <target state="translated">実際の&lt;b&gt;ファイル&lt;/b&gt;名を指す代替ファイル名。実際の&lt;b&gt;ファイル名&lt;/b&gt;は、実際の&lt;b&gt;ファイルを&lt;/b&gt;指し&lt;b&gt;ます&lt;/b&gt;。&lt;b&gt;オペレーティングシステム&lt;/b&gt;がシンボリックリンクを含む&lt;b&gt;パス名&lt;/b&gt;を解析しようとするときはいつでも、単に新しい名前に置き換えて解析を続行します。</target>
        </trans-unit>
        <trans-unit id="567849086db2a3773d0ebaa265c330619cbbb371" translate="yes" xml:space="preserve">
          <source>An alternate interface to Filter::Util::Call is now available. See &lt;a href=&quot;../simple&quot;&gt;Filter::Simple&lt;/a&gt; for more details.</source>
          <target state="translated">Filter :: Util :: Callの代替インターフェースが利用可能になりました。詳細は&lt;a href=&quot;../simple&quot;&gt;Filter :: Simple&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="309e6a9857cb37095aa6e70561b74ca78f25b7d4" translate="yes" xml:space="preserve">
          <source>An alternate interface to Filter::Util::Call is now available. See &lt;a href=&quot;Filter::Simple&quot;&gt;Filter::Simple&lt;/a&gt; for more details.</source>
          <target state="translated">Filter :: Util :: Callの代替インターフェースが利用可能になりました。詳細については、&lt;a href=&quot;Filter::Simple&quot;&gt;Filter :: Simple&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="c1c89b199090d1d97e837c8f064d662931bf60c5" translate="yes" xml:space="preserve">
          <source>An alternate way to create a new version object is through the exported qv() sub. This is not strictly like other q? operators (like qq, qw), in that the only delimiters supported are parentheses (or spaces). It is the best way to initialize a short version without triggering the floating point interpretation. For example:</source>
          <target state="translated">新しいバージョンオブジェクトを作成する別の方法として、エクスポートされた qv()サブを使用する方法があります。これは他の q?演算子 (qq や qw など)とは厳密には異なりますが、サポートされる区切り文字は括弧 (またはスペース)のみです。これは、浮動小数点解釈をトリガせずに短いバージョンを初期化する最良の方法です。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="675501f93d17028172930c214a15945683c8e504" translate="yes" xml:space="preserve">
          <source>An alternative approach to cache flushing is to use the &lt;code&gt;HASH&lt;/code&gt; option (see above) to request that &lt;code&gt;Memoize&lt;/code&gt; use a particular hash variable as its cache. Then you can examine or modify the hash at any time in any way you desire. You may flush the cache by using &lt;code&gt;%hash = ()&lt;/code&gt; .</source>
          <target state="translated">キャッシュをフラッシュする別の方法は、 &lt;code&gt;HASH&lt;/code&gt; オプション（上記を参照）を使用して、 &lt;code&gt;Memoize&lt;/code&gt; が特定のハッシュ変数をキャッシュとして使用することを要求することです。その後、いつでも好きな方法でハッシュを検査または変更できます。 &lt;code&gt;%hash = ()&lt;/code&gt; を使用してキャッシュをフラッシュできます。</target>
        </trans-unit>
        <trans-unit id="e8b6136f62918ff1ea1ed138ea0c96c6d31fc586" translate="yes" xml:space="preserve">
          <source>An alternative approach to cache flushing is to use the &lt;code&gt;HASH&lt;/code&gt; option (see above) to request that &lt;code&gt;Memoize&lt;/code&gt; use a particular hash variable as its cache. Then you can examine or modify the hash at any time in any way you desire. You may flush the cache by using &lt;code&gt;%hash = ()&lt;/code&gt;.</source>
          <target state="translated">キャッシュフラッシュの代替アプローチは、 &lt;code&gt;HASH&lt;/code&gt; オプション（上記を参照）を使用して、 &lt;code&gt;Memoize&lt;/code&gt; 化で特定のハッシュ変数をキャッシュとして使用するように要求することです。その後、いつでも好きな方法でハッシュを調べたり変更したりできます。 &lt;code&gt;%hash = ()&lt;/code&gt; を使用してキャッシュをフラッシュできます。</target>
        </trans-unit>
        <trans-unit id="b2fe156c5b22968eab0fbdde266b1268db8760ef" translate="yes" xml:space="preserve">
          <source>An alternative is CamelBones, a framework that allows access to both Foundation and AppKit classes and objects, so that full GUI applications can be built in Perl. CamelBones can be found on SourceForge, at &lt;a href=&quot;http://www.sourceforge.net/projects/camelbones/&quot;&gt;http://www.sourceforge.net/projects/camelbones/&lt;/a&gt;.</source>
          <target state="translated">別の方法としては、CamelBonesがあります。これは、FoundationとAppKitの両方のクラスとオブジェクトにアクセスできるフレームワークであり、完全なGUIアプリケーションをPerlで構築できます。CamelBonesはSourceForgeの&lt;a href=&quot;http://www.sourceforge.net/projects/camelbones/&quot;&gt;http://www.sourceforge.net/projects/camelbones/にあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5b9956d0c6aedc296243c0a951b58bd48cc08ba5" translate="yes" xml:space="preserve">
          <source>An alternative is CamelBones, a framework that allows access to both Foundation and AppKit classes and objects, so that full GUI applications can be built in Perl. CamelBones can be found on SourceForge, at &lt;a href=&quot;https://www.sourceforge.net/projects/camelbones/&quot;&gt;https://www.sourceforge.net/projects/camelbones/&lt;/a&gt;.</source>
          <target state="translated">別の方法は、FoundationとAppKitの両方のクラスとオブジェクトへのアクセスを可能にするフレームワークであるCamelBonesです。これにより、完全なGUIアプリケーションをPerlで構築できます。CamelBonesは、SourceForgeの&lt;a href=&quot;https://www.sourceforge.net/projects/camelbones/&quot;&gt;https://www.sourceforge.net/projects/camelbones/にあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="adf70c06c68960fa2b5ce48b474675e096b9430d" translate="yes" xml:space="preserve">
          <source>An alternative method of debugging regexps is to embed &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; statements within the regexp. This provides a blow-by-blow account of the backtracking in an alternation:</source>
          <target state="translated">正規表現をデバッグする別の方法は、正規表現内に &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; ステートメントを埋め込むことです。これにより、交互にバックトラックする方法が次々に説明されます。</target>
        </trans-unit>
        <trans-unit id="d38adacc9748189f199af8dc89eab5c14ea53178" translate="yes" xml:space="preserve">
          <source>An alternative method of debugging regexps is to embed &lt;code&gt;print&lt;/code&gt; statements within the regexp. This provides a blow-by-blow account of the backtracking in an alternation:</source>
          <target state="translated">正規表現をデバッグする別の方法は、正規表現内に &lt;code&gt;print&lt;/code&gt; ステートメントを埋め込むことです。これは、交互のバックトラックのブローバイブローアカウントを提供します。</target>
        </trans-unit>
        <trans-unit id="797f91185d7afbacb2d3c5eed6df4adbd22d2a7d" translate="yes" xml:space="preserve">
          <source>An alternative reference is the Info-Zip appnote. This is available from &lt;a href=&quot;ftp://ftp.info-zip.org/pub/infozip/doc/&quot;&gt;ftp://ftp.info-zip.org/pub/infozip/doc/&lt;/a&gt;</source>
          <target state="translated">別のリファレンスは、Info-Zipappnoteです。これは&lt;a href=&quot;ftp://ftp.info-zip.org/pub/infozip/doc/&quot;&gt;ftp://ftp.info-zip.org/pub/infozip/doc/&lt;/a&gt;から入手できます。</target>
        </trans-unit>
        <trans-unit id="577bb949a7cbee63183e379cdce8743144bb2e97" translate="yes" xml:space="preserve">
          <source>An alternative to using &lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt;&lt;code&gt;substr&lt;/code&gt;&lt;/a&gt; as an lvalue is to specify the replacement string as the 4th argument. This allows you to replace parts of the EXPR and return what was there before in one operation, just as you can with &lt;a href=&quot;#splice-ARRAY%2COFFSET%2CLENGTH%2CLIST&quot;&gt;&lt;code&gt;splice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#substr-EXPR%2COFFSET%2CLENGTH%2CREPLACEMENT&quot;&gt; &lt;code&gt;substr&lt;/code&gt; &lt;/a&gt;を左辺値として使用する代わりに、置換文字列を4番目の引数として指定することもできます。これにより、&lt;a href=&quot;#splice-ARRAY%2COFFSET%2CLENGTH%2CLIST&quot;&gt; &lt;code&gt;splice&lt;/code&gt; の&lt;/a&gt;場合と同じように、EXPRの一部を交換して、以前にあったものを1回の操作で戻すことができます。</target>
        </trans-unit>
        <trans-unit id="bf78a032596f44477dfca0392a1f37e462bfc42f" translate="yes" xml:space="preserve">
          <source>An alternative to using substr() as an lvalue is to specify the replacement string as the 4th argument. This allows you to replace parts of the EXPR and return what was there before in one operation, just as you can with splice().</source>
          <target state="translated">substr()を lvalue として使用する代わりに、第四引数に置換文字列を指定することができます。これにより、 splice()でできるように EXPR の一部を置換して、一度の操作で前にあったものを返すことができます。</target>
        </trans-unit>
        <trans-unit id="25b5286961be13762e984cfd1189ea7a9bb06d7a" translate="yes" xml:space="preserve">
          <source>An alternative to writing the filter in C is to create a separate executable in the language of your choice. The separate executable reads from standard input, does whatever processing is necessary, and writes the filtered data to standard output. &lt;code&gt;Filter::cpp&lt;/code&gt; is an example of a source filter implemented as a separate executable - the executable is the C preprocessor bundled with your C compiler.</source>
          <target state="translated">Cでフィルターを作成する代わりに、選択した言語で別の実行可能ファイルを作成することもできます。個別の実行可能ファイルは標準入力から読み取り、必要な処理をすべて行い、フィルタリングされたデータを標準出力に書き込みます。 &lt;code&gt;Filter::cpp&lt;/code&gt; は、個別の実行可能ファイルとして実装されたソースフィルターの例です。実行可能ファイルは、CコンパイラにバンドルされているCプリプロセッサです。</target>
        </trans-unit>
        <trans-unit id="9216315bb2214d5ed94f6db6fec42532477a8283" translate="yes" xml:space="preserve">
          <source>An alternative way of writing something more easily; a shortcut.</source>
          <target state="translated">より簡単に何かを書くための代替方法。</target>
        </trans-unit>
        <trans-unit id="d69bfaa7d98ebed8954a924a638458e2ecf0b867" translate="yes" xml:space="preserve">
          <source>An alternative way to achieve this can be seen in &lt;a href=&quot;Gtk2::CodeGen&quot;&gt;Gtk2::CodeGen&lt;/a&gt; and &lt;a href=&quot;Glib::CodeGen&quot;&gt;Glib::CodeGen&lt;/a&gt;.</source>
          <target state="translated">これを実現する別の方法は、&lt;a href=&quot;Gtk2::CodeGen&quot;&gt;Gtk2 :: CodeGen&lt;/a&gt;と&lt;a href=&quot;Glib::CodeGen&quot;&gt;Glib :: CodeGenに&lt;/a&gt;あります。</target>
        </trans-unit>
        <trans-unit id="3719242868ba601b24b2c4019225372b6d1ba5a6" translate="yes" xml:space="preserve">
          <source>An alternatively is the Info-Zip appnote. This is available from &lt;a href=&quot;ftp://ftp.info-zip.org/pub/infozip/doc/&quot;&gt;ftp://ftp.info-zip.org/pub/infozip/doc/&lt;/a&gt;</source>
          <target state="translated">別の方法として、Info-Zipappnoteがあります。これは&lt;a href=&quot;ftp://ftp.info-zip.org/pub/infozip/doc/&quot;&gt;ftp://ftp.info-zip.org/pub/infozip/doc/&lt;/a&gt;から入手できます。</target>
        </trans-unit>
        <trans-unit id="f6ef70866e892e0391f54f3f0e595fde0691ccb0" translate="yes" xml:space="preserve">
          <source>An anchor useful in basic regexps is the</source>
          <target state="translated">基本的な正規表現で便利なアンカーは</target>
        </trans-unit>
        <trans-unit id="a941741e26d01bf48e71deca7cfe67d745df0d18" translate="yes" xml:space="preserve">
          <source>An anonymous array of alternative library specifications to be searched for (in order) until at least one library is found. E.g.</source>
          <target state="translated">少なくとも1つのライブラリが見つかるまで(順番に)検索される代替ライブラリ仕様の匿名配列。例えば</target>
        </trans-unit>
        <trans-unit id="c253698bf9e4f75c2b5d0a18558b851f2d3f6b5e" translate="yes" xml:space="preserve">
          <source>An application that takes the trouble to use information in &lt;code&gt;LC_MONETARY&lt;/code&gt; may format debits as if they were credits and vice versa if that locale has been subverted. Or it might make payments in US dollars instead of Hong Kong dollars.</source>
          <target state="translated">面倒な &lt;code&gt;LC_MONETARY&lt;/code&gt; の情報を使用するアプリケーションは、借方をクレジットであるかのようにフォーマットし、そのロケールが破壊されている場合はその逆の場合があります。または、香港ドルではなく米ドルで支払いを行う場合もあります。</target>
        </trans-unit>
        <trans-unit id="01ac9da7b76fdd816e4e95bf07e705af326d0f2c" translate="yes" xml:space="preserve">
          <source>An application using Module can say something like:</source>
          <target state="translated">モジュールを使用したアプリケーションは、次のようなことを言うことができます。</target>
        </trans-unit>
        <trans-unit id="a335ab967a8e1f5c521e6fbf8a762d039a0699ab" translate="yes" xml:space="preserve">
          <source>An archaic expression for what is more correctly referred to as &lt;b&gt;list context&lt;/b&gt;.</source>
          <target state="translated">より正確に&lt;b&gt;リストコンテキスト&lt;/b&gt;と呼ばれるものの古風な表現。</target>
        </trans-unit>
        <trans-unit id="7dd0ff3c6abfb69f462a62c5017ae088c797d806" translate="yes" xml:space="preserve">
          <source>An argument can be ignored by omitting the main part of the name from a parameter declaration, leaving just a bare &lt;code&gt;$&lt;/code&gt; sigil. For example,</source>
          <target state="translated">パラメータ宣言から名前の主要部分を省略して、単なる &lt;code&gt;$&lt;/code&gt; シギルを残すことで、引数を無視できます。例えば、</target>
        </trans-unit>
        <trans-unit id="3f5cfd48537bc41203499ec678c7f8d1ffcc4184" translate="yes" xml:space="preserve">
          <source>An argument line supplying values to plug into the previous picture line.</source>
          <target state="translated">前の画像行に差し込むための値を与える引数行。</target>
        </trans-unit>
        <trans-unit id="e1318b0f2b2dd2f7e8a55cad33c819c262a23ea1" translate="yes" xml:space="preserve">
          <source>An array can also change its length:</source>
          <target state="translated">配列は、その長さを変更することもできます。</target>
        </trans-unit>
        <trans-unit id="a7633012ecb371a2113d013c22d2c030bb2a3192" translate="yes" xml:space="preserve">
          <source>An array can be accessed one scalar at a time by specifying a dollar sign (&lt;code&gt;$&lt;/code&gt; ), then the name of the array (without the leading &lt;code&gt;@&lt;/code&gt; ), then the subscript inside square brackets. For example:</source>
          <target state="translated">配列は、ドル記号（ &lt;code&gt;$&lt;/code&gt; ）、配列の名前（先頭の &lt;code&gt;@&lt;/code&gt; なし）、角かっこで囲まれた添え字を指定することで、一度に1つのスカラーにアクセスできます。例えば：</target>
        </trans-unit>
        <trans-unit id="540cdd79efe573437a7605791a2eb1616100de60" translate="yes" xml:space="preserve">
          <source>An array can be accessed one scalar at a time by specifying a dollar sign (&lt;code&gt;$&lt;/code&gt;), then the name of the array (without the leading &lt;code&gt;@&lt;/code&gt;), then the subscript inside square brackets. For example:</source>
          <target state="translated">配列には、ドル記号（ &lt;code&gt;$&lt;/code&gt; ）、配列の名前（先頭の &lt;code&gt;@&lt;/code&gt; なし）、角括弧内の添え字を指定することにより、一度に1つのスカラーにアクセスできます。例えば：</target>
        </trans-unit>
        <trans-unit id="015711954685a7b3ea99a44f6e657f520fa53416" translate="yes" xml:space="preserve">
          <source>An array of an array is just a regular old array @AoA that you can get at with two subscripts, like &lt;code&gt;$AoA[3][2]&lt;/code&gt; . Here's a declaration of the array:</source>
          <target state="translated">配列の配列は、 &lt;code&gt;$AoA[3][2]&lt;/code&gt; ように、2つの添え字で取得できる通常の古い配列@AoAです。これが配列の宣言です：</target>
        </trans-unit>
        <trans-unit id="11613ff6241b5d0054882bce3b479c51b671807c" translate="yes" xml:space="preserve">
          <source>An array of an array is just a regular old array @AoA that you can get at with two subscripts, like &lt;code&gt;$AoA[3][2]&lt;/code&gt;. Here's a declaration of the array:</source>
          <target state="translated">配列の配列は、 &lt;code&gt;$AoA[3][2]&lt;/code&gt; ように、2つの添え字で取得できる通常の古い配列@AoAです。配列の宣言は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="ae61cf59e4cd9db6ee9b5a175cc315be8ef10741" translate="yes" xml:space="preserve">
          <source>An array of constants' names, either scalars containing names, or hashrefs as detailed in &lt;a href=&quot;#C_constant&quot;&gt;&quot;C_constant&quot;&lt;/a&gt;.</source>
          <target state="translated">定数の名前の配列。名前を含むスカラー、または&lt;a href=&quot;#C_constant&quot;&gt;「C_constant」で&lt;/a&gt;詳しく説明されているハッシュ参照。</target>
        </trans-unit>
        <trans-unit id="9aee3421650400587ce5406d39d397928a2add0e" translate="yes" xml:space="preserve">
          <source>An array of constants' names, either scalars containing names, or hashrefs as detailed in &lt;a href=&quot;#C_constant&quot;&gt;C_constant&lt;/a&gt;.</source>
          <target state="translated">定数の名前の配列。名前を含むスカラー、またはC_constantで詳しく説明されている&lt;a href=&quot;#C_constant&quot;&gt;ハッシュ参照&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4dbdb6c0876baa594d12d6a72f40a78381bda16" translate="yes" xml:space="preserve">
          <source>An array of file names for the shared objects that were loaded.</source>
          <target state="translated">読み込まれた共有オブジェクトのファイル名の配列。</target>
        </trans-unit>
        <trans-unit id="26930aebfa1fee021fd440dae3cf343080566995" translate="yes" xml:space="preserve">
          <source>An array of module (package) names that have been bootstrap'ed.</source>
          <target state="translated">ブートストラップされたモジュール (パッケージ)名の配列。</target>
        </trans-unit>
        <trans-unit id="e8f1da37492eab7b118aed0b3744e018cc0392dd" translate="yes" xml:space="preserve">
          <source>An array of non-negative integers that is used for comparison purposes with other version objects.</source>
          <target state="translated">他のバージョンオブジェクトとの比較に使用される非負の整数の配列。</target>
        </trans-unit>
        <trans-unit id="792d37106ab796a9da516b2cfe4619175268f4f1" translate="yes" xml:space="preserve">
          <source>An array of patches on CPAN or on the local disk to be applied in order via an external patch program. If the value for the &lt;code&gt;-p&lt;/code&gt; parameter is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; is determined by reading the patch beforehand. The path to each patch is either an absolute path on the local filesystem or relative to a patch directory specified in the &lt;code&gt;patches_dir&lt;/code&gt; configuration variable or in the format of a canonical distro name. For examples please consult the distroprefs/ directory in the CPAN.pm distribution (these examples are not installed by default).</source>
          <target state="translated">外部パッチプログラムを介して順番に適用されるCPANまたはローカルディスク上のパッチの配列。値場合 &lt;code&gt;-p&lt;/code&gt; パラメータが &lt;code&gt;0&lt;/code&gt; または &lt;code&gt;1&lt;/code&gt; が予めパッチを読み取ることによって決定されます。各パッチへのパスは、ローカルファイルシステムの絶対パスか、 &lt;code&gt;patches_dir&lt;/code&gt; 構成変数または正規のディストリビューション名の形式で指定されたパッチディレクトリへの相対パスです。例については、CPAN.pmディストリビューションのdistroprefs /ディレクトリを参照してください（これらの例はデフォルトではインストールされません）。</target>
        </trans-unit>
        <trans-unit id="b89f1be8b64b665e2888aa36341ca67f3fc8a573" translate="yes" xml:space="preserve">
          <source>An array of the handles returned by successful calls to dl_load_file(), made by bootstrap, in the order in which they were loaded. Can be used with dl_find_symbol() to look for a symbol in any of the loaded files.</source>
          <target state="translated">ブートストラップによる dl_load_file()の呼び出しが成功したときに返されたハンドルを、読み込まれた順に配列化したもの。dl_find_symbol()と一緒に使用して、ロードされたファイルの中からシンボルを探すことができます。</target>
        </trans-unit>
        <trans-unit id="c823d47a703f9ce8bdd6c6bd99c53c578f964658" translate="yes" xml:space="preserve">
          <source>An array reference</source>
          <target state="translated">配列の参照</target>
        </trans-unit>
        <trans-unit id="2042400b9cf51420ca0bb02f4a95651f7d9e0fc1" translate="yes" xml:space="preserve">
          <source>An array represents a list of values:</source>
          <target state="translated">配列は、値のリストを表します。</target>
        </trans-unit>
        <trans-unit id="7ce42eb4fb16bbef377321c32853b8f06079f21c" translate="yes" xml:space="preserve">
          <source>An array which exposes the contents of the capture buffers, if any, of the last successful pattern match, not counting patterns matched in nested blocks that have been exited already.</source>
          <target state="translated">最後に成功したパターンマッチのキャプチャバッファがあれば、その内容を公開する配列。</target>
        </trans-unit>
        <trans-unit id="d58bf09473fcb443f32238cd3f343fe1cb52e884" translate="yes" xml:space="preserve">
          <source>An array with multiple subscripts for finding a single element. Perl implements these using &lt;b&gt;references&lt;/b&gt;&amp;mdash;see Camel chapter 9, &amp;ldquo;Data Structures&amp;rdquo;.</source>
          <target state="translated">単一の要素を見つけるための複数の添え字を持つ配列。Perlは&lt;b&gt;参照&lt;/b&gt;を使用してこれらを実装し&lt;b&gt;ます&amp;mdash;&lt;/b&gt; Camelの第9章「データ構造」を&lt;b&gt;参照&lt;/b&gt;して&lt;b&gt;ください&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="e730b7563caa7a9a3615b79242bd88575f2b5d2f" translate="yes" xml:space="preserve">
          <source>An attempt to &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require $module&quot;&lt;/code&gt; failed, even though the list of extensions indicated that it should succeed. Correct by conducting a proper installation.</source>
          <target state="translated">試み &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; &quot;require $module&quot;&lt;/code&gt; 拡張子のリストは、それが成功する必要があることを示していても、失敗しました。正しく設置して修正してください。</target>
        </trans-unit>
        <trans-unit id="f00d85ec569efd3d0ba1b09d16f4a00196ee0d74" translate="yes" xml:space="preserve">
          <source>An attempt to &lt;code&gt;eval &quot;require $module&quot;&lt;/code&gt; failed, even though the list of extensions indicated that it should succeed. Correct by conducting a proper installation.</source>
          <target state="translated">拡張機能のリストが成功するはずであると示していたにもかかわらず、 &lt;code&gt;eval &quot;require $module&quot;&lt;/code&gt; を評価する試みは失敗しました。適切なインストールを行って修正してください。</target>
        </trans-unit>
        <trans-unit id="8668d93103d45211068cbb7aa1991bd63b959bd9" translate="yes" xml:space="preserve">
          <source>An attempt to allocate memory failed.</source>
          <target state="translated">メモリの割り当てに失敗しました。</target>
        </trans-unit>
        <trans-unit id="4965e597a6abdfe2d520970b55b8363275b2a451" translate="yes" xml:space="preserve">
          <source>An attempt to set an unrecognized attribute is a fatal error. (The error is trappable, but it still stops the compilation within that &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;.) Setting an attribute with a name that's all lowercase letters that's not a built-in attribute (such as &quot;foo&quot;) will result in a warning with &lt;b&gt;-w&lt;/b&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'reserved'&lt;/code&gt; .</source>
          <target state="translated">認識されない属性を設定しようとすると、致命的なエラーになります。（エラーはトラップできますが、それでもその &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 内でのコンパイルは停止します。）組み込みの属性ではないすべて小文字の名前で属性を設定すると（ &quot;foo&quot;など）、- &lt;b&gt;w&lt;/b&gt;または &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings 'reserved'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用し&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="a24018dbac9a81adda03170beee4acf228798de6" translate="yes" xml:space="preserve">
          <source>An attempt to set an unrecognized attribute is a fatal error. (The error is trappable, but it still stops the compilation within that &lt;code&gt;eval&lt;/code&gt;.) Setting an attribute with a name that's all lowercase letters that's not a built-in attribute (such as &quot;foo&quot;) will result in a warning with &lt;b&gt;-w&lt;/b&gt; or &lt;code&gt;use warnings 'reserved'&lt;/code&gt;.</source>
          <target state="translated">認識されない属性を設定しようとすると、致命的なエラーになります。（エラーはトラップ可能ですが、それでもその &lt;code&gt;eval&lt;/code&gt; 内のコンパイルは停止します。）組み込み属性ではないすべて小文字の名前で属性を設定すると（「foo」など）、- &lt;b&gt;w&lt;/b&gt;または &lt;code&gt;use warnings 'reserved'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93c1784b7ddee55af5b75a4bf233031106bc926c" translate="yes" xml:space="preserve">
          <source>An attribute handler was specified with an &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt;, but the type of referent it was defined to handle wasn't one of the five permitted: &lt;code&gt;SCALAR&lt;/code&gt; , &lt;code&gt;ARRAY&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; , &lt;code&gt;CODE&lt;/code&gt; , or &lt;code&gt;ANY&lt;/code&gt; .</source>
          <target state="translated">属性ハンドラが &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt; で指定されましたが、それが処理するように定義された参照先のタイプは、 &lt;code&gt;SCALAR&lt;/code&gt; 、 &lt;code&gt;ARRAY&lt;/code&gt; 、 &lt;code&gt;HASH&lt;/code&gt; 、 &lt;code&gt;CODE&lt;/code&gt; 、または &lt;code&gt;ANY&lt;/code&gt; の5つの​​許可のいずれでもありませんでした。</target>
        </trans-unit>
        <trans-unit id="be2ec17006c02c47726210c596c995f951690163" translate="yes" xml:space="preserve">
          <source>An attribute handler was specified with an &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt;, but the type of referent it was defined to handle wasn't one of the five permitted: &lt;code&gt;SCALAR&lt;/code&gt;, &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;HASH&lt;/code&gt;, &lt;code&gt;CODE&lt;/code&gt;, or &lt;code&gt;ANY&lt;/code&gt;.</source>
          <target state="translated">属性ハンドラーは &lt;code&gt;:ATTR(&lt;i&gt;ref_type&lt;/i&gt;)&lt;/code&gt; で指定されましたが、処理するように定義された指示対象のタイプは、許可された5つのタイプ（ &lt;code&gt;SCALAR&lt;/code&gt; 、 &lt;code&gt;ARRAY&lt;/code&gt; 、 &lt;code&gt;HASH&lt;/code&gt; 、 &lt;code&gt;CODE&lt;/code&gt; 、または &lt;code&gt;ANY&lt;/code&gt; )のいずれでもありませんでした。</target>
        </trans-unit>
        <trans-unit id="9ed24a1addfea7e1a18f9560990ecafe644b6003" translate="yes" xml:space="preserve">
          <source>An attribute is a piece of data belonging to a particular object. Unlike most object-oriented languages, Perl provides no special syntax or support for declaring and manipulating attributes.</source>
          <target state="translated">属性とは、特定のオブジェクトに属するデータの一部です。ほとんどのオブジェクト指向言語とは異なり、Perl は属性を宣言したり操作したりするための特別な構文やサポートを提供しません。</target>
        </trans-unit>
        <trans-unit id="4774fb20b25b2c00d90761710a32f25902ad2435" translate="yes" xml:space="preserve">
          <source>An attribute list is a sequence of attribute specifications, separated by whitespace or a colon (with optional whitespace). Each attribute specification is a simple name, optionally followed by a parenthesised parameter list. If such a parameter list is present, it is scanned past as for the rules for the &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; operator. (See &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;Quote and Quote-like Operators in perlop&lt;/a&gt;.) The parameter list is passed as it was found, however, and not as per &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">属性リストは、空白またはコロン（オプションの空白あり）で区切られた一連の属性指定です。各属性の指定は単純な名前で、オプションで括弧で囲まれたパラメーターリストが後に続きます。そのようなパラメータリストが存在する場合、 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; 演算子のルールと同様にスキャンされます。 （&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;perlopのQuoteおよびQuote-like演算子を&lt;/a&gt;参照してください。）ただし、パラメーターリストは、 &lt;code&gt;&lt;a href=&quot;functions/q&quot;&gt;q()&lt;/a&gt;&lt;/code&gt; ではなく、見つかったとおりに渡されます。</target>
        </trans-unit>
        <trans-unit id="cc6c334100243f2c62d45354cd17461eb4374199" translate="yes" xml:space="preserve">
          <source>An attribute list is a sequence of attribute specifications, separated by whitespace or a colon (with optional whitespace). Each attribute specification is a simple name, optionally followed by a parenthesised parameter list. If such a parameter list is present, it is scanned past as for the rules for the &lt;code&gt;q()&lt;/code&gt; operator. (See &lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;&quot;Quote and Quote-like Operators&quot; in perlop&lt;/a&gt;.) The parameter list is passed as it was found, however, and not as per &lt;code&gt;q()&lt;/code&gt;.</source>
          <target state="translated">属性リストは、空白またはコロン（オプションの空白を含む）で区切られた一連の属性指定です。各属性指定は単純な名前であり、オプションで括弧で囲まれたパラメーターリストが続きます。そのようなパラメータリストが存在する場合、 &lt;code&gt;q()&lt;/code&gt; 演算子のルールと同様に過去にスキャンされます。 （&lt;a href=&quot;perlop#Quote-and-Quote-like-Operators&quot;&gt;perlopの「引用符および引用符のような演算子」を&lt;/a&gt;参照してください。）ただし、パラメーターリストは、 &lt;code&gt;q()&lt;/code&gt; に従ってではなく、検出されたとおりに渡されます。</target>
        </trans-unit>
        <trans-unit id="f9a21fa1e7844543aacf6b214485b949a7b1705b" translate="yes" xml:space="preserve">
          <source>An early change, in fact the change that made Test2 an idea, was a change to the indentation of the subtest note. It was decided it would be more readable to outdent the subtest note instead of having it inline with the subtest:</source>
          <target state="translated">初期の変更点、実際、Test2をアイデアにした変更点は、サブテストノートのインデントの変更でした。下位テストのノートを下位テストとインラインにするのではなく、下位テストのノートをアウトデントした方が読みやすいと判断されました。</target>
        </trans-unit>
        <trans-unit id="6356b19b83a0de734fd036ef3412ad9e0499e73b" translate="yes" xml:space="preserve">
          <source>An effect similar to &lt;code&gt;(?&amp;gt;&lt;i&gt;pattern&lt;/i&gt;)&lt;/code&gt; may be achieved by writing &lt;code&gt;(?=(&lt;i&gt;pattern&lt;/i&gt;))\g{-1}&lt;/code&gt;. This matches the same substring as a standalone &lt;code&gt;a+&lt;/code&gt;, and the following &lt;code&gt;\g{-1}&lt;/code&gt; eats the matched string; it therefore makes a zero-length assertion into an analogue of &lt;code&gt;(?&amp;gt;...)&lt;/code&gt;. (The difference between these two constructs is that the second one uses a capturing group, thus shifting ordinals of backreferences in the rest of a regular expression.)</source>
          <target state="translated">&lt;code&gt;(?&amp;gt;&lt;i&gt;pattern&lt;/i&gt;)&lt;/code&gt; と同様の効果は、 &lt;code&gt;(?=(&lt;i&gt;pattern&lt;/i&gt;))\g{-1}&lt;/code&gt; 書くことで実現できます。これはスタンドアロンの &lt;code&gt;a+&lt;/code&gt; と同じ部分文字列に一致し、次の &lt;code&gt;\g{-1}&lt;/code&gt; は一致した文字列を食べます。したがって、長さゼロのアサーションを &lt;code&gt;(?&amp;gt;...)&lt;/code&gt; の類似物にします。（これら2つの構成の違いは、2番目の構成はキャプチャグループを使用するため、正規表現の残りの部分で後方参照の序数がシフトすることです。）</target>
        </trans-unit>
        <trans-unit id="b6ff4a009f82a7cfb00247fff66222df5571297d" translate="yes" xml:space="preserve">
          <source>An effect similar to &lt;code&gt;(?&amp;gt;pattern)&lt;/code&gt; may be achieved by writing &lt;code&gt;(?=(pattern))\g{-1}&lt;/code&gt; . This matches the same substring as a standalone &lt;code&gt;a+&lt;/code&gt; , and the following &lt;code&gt;\g{-1}&lt;/code&gt; eats the matched string; it therefore makes a zero-length assertion into an analogue of &lt;code&gt;(?&amp;gt;...)&lt;/code&gt;. (The difference between these two constructs is that the second one uses a capturing group, thus shifting ordinals of backreferences in the rest of a regular expression.)</source>
          <target state="translated">&lt;code&gt;(?&amp;gt;pattern)&lt;/code&gt; と同様の効果は、 &lt;code&gt;(?=(pattern))\g{-1}&lt;/code&gt; 書くことで実現できます。これは、スタンドアロン &lt;code&gt;a+&lt;/code&gt; と同じ部分文字列に一致し、次の &lt;code&gt;\g{-1}&lt;/code&gt; は一致した文字列を食べます。したがって、長さゼロのアサーションを &lt;code&gt;(?&amp;gt;...)&lt;/code&gt; の類似物にします。（これらの2つの構成の違いは、2番目の構成ではキャプチャグループを使用するため、正規表現の残りの部分で後方参照の序数がシフトすることです。）</target>
        </trans-unit>
        <trans-unit id="c5d792d65a737f380eae7ddca70051ed5bf418d1" translate="yes" xml:space="preserve">
          <source>An embedded perl needs to be started up while the global locale is in effect. See &lt;a href=&quot;perlembed#Using-embedded-Perl-with-POSIX-locales&quot;&gt;&quot;Using embedded Perl with POSIX locales&quot; in perlembed&lt;/a&gt;.</source>
          <target state="translated">グローバルロケールが有効な間に、埋め込みperlを起動する必要があります。&lt;a href=&quot;perlembed#Using-embedded-Perl-with-POSIX-locales&quot;&gt;perlembedの「POSIXロケールでの埋め込みPerlの使用」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="65503b1bc3cc6e29b56e0751024a1c32f6babaa5" translate="yes" xml:space="preserve">
          <source>An empty &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">空の &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="830fe5530bf8a388dd3b4e1cd4354d40bf489efb" translate="yes" xml:space="preserve">
          <source>An empty E&amp;lt;&amp;gt;</source>
          <target state="translated">空のE &amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1de720044af3435092cdfe83370a7cafc924ed83" translate="yes" xml:space="preserve">
          <source>An empty X&amp;lt;&amp;gt;</source>
          <target state="translated">空のX &amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e5eb41f6f24dfa906c0da1eda1f150cd75892a06" translate="yes" xml:space="preserve">
          <source>An empty leading field is produced when there is a positive-width match at the beginning of EXPR. For instance:</source>
          <target state="translated">EXPRの先頭に正の幅の一致がある場合、空の先頭フィールドが生成されます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="7c1d0be8e8ca70fd2b14e62fb21989504ef1df2a" translate="yes" xml:space="preserve">
          <source>An empty list as soon as an explicit &lt;code&gt;break&lt;/code&gt; is encountered.</source>
          <target state="translated">明示的な &lt;code&gt;break&lt;/code&gt; が発生するとすぐに空のリスト。</target>
        </trans-unit>
        <trans-unit id="39e866d4dec47e8ffded31535bf330825a29cb83" translate="yes" xml:space="preserve">
          <source>An empty list, in list context</source>
          <target state="translated">空のリスト。</target>
        </trans-unit>
        <trans-unit id="afbf0f80f22fc5d795da7f111754a1b9ed2a4fe4" translate="yes" xml:space="preserve">
          <source>An empty trailing field, on the other hand, is produced when there is a match at the end of EXPR, regardless of the length of the match (of course, unless a non-zero LIMIT is given explicitly, such fields are removed, as in the last example). Thus:</source>
          <target state="translated">一方、空の末尾フィールドは、EXPRの最後に一致があった場合、一致の長さに関係なく生成されます(もちろん、明示的に0以外のLIMITが与えられない限り、最後の例のように、そのようなフィールドは削除されます)。したがって、次のようになります。</target>
        </trans-unit>
        <trans-unit id="cd562f569c7a192c547c6c2160f193f3f97949c6" translate="yes" xml:space="preserve">
          <source>An enchantment, illusion, phantasm, or jugglery. Said when Perl&amp;rsquo;s magical &lt;b&gt;dwimmer&lt;/b&gt; effects don&amp;rsquo;t do what you expect, but rather seem to be the product of arcane</source>
          <target state="translated">エンチャント、幻想、幻想、手品。Perlの不思議な&lt;b&gt;ちらつき&lt;/b&gt;効果が期待どおりに動作せず、難解な製品のように見える場合に&lt;b&gt;発言&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5a1e64f9893fb69df07a9e0956194fcfd71ca286" translate="yes" xml:space="preserve">
          <source>An endpoint for network communication among multiple &lt;b&gt;processes&lt;/b&gt; that works much like a telephone or a post office box. The most important thing about a socket is its &lt;b&gt;network address&lt;/b&gt; (like a phone number). Different kinds of sockets have different kinds of addresses&amp;mdash;some look like filenames, and some don&amp;rsquo;t.</source>
          <target state="translated">電話や私書箱のように機能する複数の&lt;b&gt;プロセス&lt;/b&gt;間のネットワーク通信のエンドポイント。ソケットについて最も重要なことは、その&lt;b&gt;ネットワークアドレス&lt;/b&gt;（電話番号など）です。ソケットの種類によって、アドレスの種類が異なります。ファイル名のように見えるものと、そうでないものがあります。</target>
        </trans-unit>
        <trans-unit id="84340afb233fc1ed2c36b5178d0bb87bc821d3fd" translate="yes" xml:space="preserve">
          <source>An entire computer program crammed into one line of text.</source>
          <target state="translated">コンピュータプログラム全体を一行のテキストに詰め込んだもの。</target>
        </trans-unit>
        <trans-unit id="0b89a9a0affedc51570a8afe57fcceb747dbf5fe" translate="yes" xml:space="preserve">
          <source>An entity specified by number (dec, hex, oct) is out of range (1-255).</source>
          <target state="translated">数字(dec,hex,oct)で指定されたエンティティが範囲外(1-255)です。</target>
        </trans-unit>
        <trans-unit id="e4a99f74cee987dba72920fbff7e10dc623de69d" translate="yes" xml:space="preserve">
          <source>An entry of the form &lt;code&gt;-La:\foo&lt;/code&gt; specifies the &lt;code&gt;a:\foo&lt;/code&gt; directory to look for the libraries that follow.</source>
          <target state="translated">&lt;code&gt;-La:\foo&lt;/code&gt; という形式のエントリは、後に続くライブラリを探すために &lt;code&gt;a:\foo&lt;/code&gt; ディレクトリを指定します。</target>
        </trans-unit>
        <trans-unit id="e872c91a08d6535bc529f64f8ec25e1266b0facd" translate="yes" xml:space="preserve">
          <source>An entry of the form &lt;code&gt;-lfoo&lt;/code&gt; specifies the library &lt;code&gt;foo&lt;/code&gt; , which may be spelled differently depending on what kind of compiler you are using. If you are using GCC, it gets translated to &lt;code&gt;libfoo.a&lt;/code&gt; , but for other win32 compilers, it becomes &lt;code&gt;foo.lib&lt;/code&gt; . If no files are found by those translated names, one more attempt is made to find them using either &lt;code&gt;foo.a&lt;/code&gt; or &lt;code&gt;libfoo.lib&lt;/code&gt; , depending on whether GCC or some other win32 compiler is being used, respectively.</source>
          <target state="translated">&lt;code&gt;-lfoo&lt;/code&gt; 形式のエントリは、ライブラリ &lt;code&gt;foo&lt;/code&gt; を指定します。これは、使用しているコンパイラの種類に応じてスペルが異なる場合があります。GCCを使用している場合は &lt;code&gt;libfoo.a&lt;/code&gt; に変換されますが、他のwin32コンパイラの場合は &lt;code&gt;foo.lib&lt;/code&gt; になります。これらの翻訳された名前でファイルが見つからない場合は、それぞれGCCまたは他のwin32コンパイラーが使用されているかどうかに応じて、それぞれ &lt;code&gt;foo.a&lt;/code&gt; または &lt;code&gt;libfoo.lib&lt;/code&gt; を使用してファイルを検索しようとします。</target>
        </trans-unit>
        <trans-unit id="b955ec169e3cf404a025241c85cc35d91ed6e518" translate="yes" xml:space="preserve">
          <source>An entry of the form &lt;code&gt;-lfoo&lt;/code&gt; specifies the library &lt;code&gt;foo&lt;/code&gt;, which may be spelled differently depending on what kind of compiler you are using. If you are using GCC, it gets translated to &lt;code&gt;libfoo.a&lt;/code&gt;, but for other win32 compilers, it becomes &lt;code&gt;foo.lib&lt;/code&gt;. If no files are found by those translated names, one more attempt is made to find them using either &lt;code&gt;foo.a&lt;/code&gt; or &lt;code&gt;libfoo.lib&lt;/code&gt;, depending on whether GCC or some other win32 compiler is being used, respectively.</source>
          <target state="translated">&lt;code&gt;-lfoo&lt;/code&gt; の形式のエントリは、ライブラリ &lt;code&gt;foo&lt;/code&gt; を指定します。これは、使用しているコンパイラの種類によってスペルが異なる場合があります。 GCCを使用している場合は、 &lt;code&gt;libfoo.a&lt;/code&gt; に変換されますが、他のwin32コンパイラーの場合は、 &lt;code&gt;foo.lib&lt;/code&gt; になります。これらの変換された名前でファイルが見つからない場合は、GCCまたは他のwin32コンパイラがそれぞれ使用されているかどうかに応じて、 &lt;code&gt;foo.a&lt;/code&gt; または &lt;code&gt;libfoo.lib&lt;/code&gt; のいずれかを使用してファイルを見つける試みがもう一度行われます。</target>
        </trans-unit>
        <trans-unit id="542b3550714b3908eea8d8c13ea7256018c9e930" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:nodefault/i&lt;/code&gt; disables the appending of default libraries found in &lt;code&gt;$Config{perllibs}&lt;/code&gt; (this should be only needed very rarely).</source>
          <target state="translated">&lt;code&gt;/:nodefault/i&lt;/code&gt; に一致するエントリは、 &lt;code&gt;$Config{perllibs}&lt;/code&gt; あるデフォルトライブラリの追加を無効にします（これが必要になることは非常にまれです）。</target>
        </trans-unit>
        <trans-unit id="54596c2d41917bea50cab186303f4d27d58e3783" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:nosearch/i&lt;/code&gt; disables all searching for the libraries specified after it. Translation of &lt;code&gt;-Lfoo&lt;/code&gt; and &lt;code&gt;-lfoo&lt;/code&gt; still happens as appropriate (depending on compiler being used, as reflected by &lt;code&gt;$Config{cc}&lt;/code&gt; ), but the entries are not verified to be valid files or directories.</source>
          <target state="translated">&lt;code&gt;/:nosearch/i&lt;/code&gt; に一致するエントリは、その後に指定されたライブラリの検索をすべて無効にします。 &lt;code&gt;-Lfoo&lt;/code&gt; と &lt;code&gt;-lfoo&lt;/code&gt; の変換は引き続き適切に行われます（使用されるコンパイラーに応じて、 &lt;code&gt;$Config{cc}&lt;/code&gt; によって反映されます）が、エントリーが有効なファイルまたはディレクトリーであることは検証されません。</target>
        </trans-unit>
        <trans-unit id="0f36c83e40eae68ee067d041dd5eaac816d400ba" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:nosearch/i&lt;/code&gt; disables all searching for the libraries specified after it. Translation of &lt;code&gt;-Lfoo&lt;/code&gt; and &lt;code&gt;-lfoo&lt;/code&gt; still happens as appropriate (depending on compiler being used, as reflected by &lt;code&gt;$Config{cc}&lt;/code&gt;), but the entries are not verified to be valid files or directories.</source>
          <target state="translated">&lt;code&gt;/:nosearch/i&lt;/code&gt; に一致するエントリは、その後に指定されたライブラリのすべての検索を無効にします。 &lt;code&gt;-Lfoo&lt;/code&gt; と &lt;code&gt;-lfoo&lt;/code&gt; の変換は、引き続き適切に行われます（ &lt;code&gt;$Config{cc}&lt;/code&gt; 反映されるように、使用されているコンパイラによって異なります）が、エントリが有効なファイルまたはディレクトリであるかどうかは検証されません。</target>
        </trans-unit>
        <trans-unit id="341641ec8dfdfc884739074e9d2b0f226cf6a1e7" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:search/i&lt;/code&gt; reenables searching for the libraries specified after it. You can put it at the end to enable searching for default libraries specified by &lt;code&gt;$Config{perllibs}&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;/:search/i&lt;/code&gt; に一致するエントリは、その後に指定されたライブラリの検索を再度有効にします。これを最後に置くと、 &lt;code&gt;$Config{perllibs}&lt;/code&gt; 指定されたデフォルトのライブラリを検索できるようになります。</target>
        </trans-unit>
        <trans-unit id="58b3df12b9c4c1391c5d6a764ee07751d9f03ea6" translate="yes" xml:space="preserve">
          <source>An entry that matches &lt;code&gt;/:search/i&lt;/code&gt; reenables searching for the libraries specified after it. You can put it at the end to enable searching for default libraries specified by &lt;code&gt;$Config{perllibs}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;/:search/i&lt;/code&gt; に一致するエントリは、その後に指定されたライブラリの検索を再度有効にします。これを最後に配置して、 &lt;code&gt;$Config{perllibs}&lt;/code&gt; 指定されたデフォルトライブラリの検索を有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="764e7bd0665e9fa3ca103f1f3c69a2b0a336ccc2" translate="yes" xml:space="preserve">
          <source>An enum of flags for Perl types. These are found in the file</source>
          <target state="translated">Perl の型のフラグの列挙。これらは</target>
        </trans-unit>
        <trans-unit id="eac77ebce5cb434a4347aeb52157baf13e86e68f" translate="yes" xml:space="preserve">
          <source>An enum of flags for Perl types. These are found in the file &lt;b&gt;sv.h&lt;/b&gt; in the &lt;code&gt;svtype&lt;/code&gt; enum. Test these flags with the &lt;code&gt;SvTYPE&lt;/code&gt; macro.</source>
          <target state="translated">Perlタイプのフラグの列挙。これらは、ファイルの中に発見され&lt;b&gt;sv.h&lt;/b&gt;で &lt;code&gt;svtype&lt;/code&gt; の列挙。 &lt;code&gt;SvTYPE&lt;/code&gt; マクロでこれらのフラグをテストします。</target>
        </trans-unit>
        <trans-unit id="a352e1f402bd0b0688137a6b2ecc0dfb6c13f18b" translate="yes" xml:space="preserve">
          <source>An enum value. Used to transfer an enum component from C. There is no reason to pass an enum value to C since it is stored as an IV inside perl.</source>
          <target state="translated">enum値です。Cからenumコンポーネントを転送するために使用されます。</target>
        </trans-unit>
        <trans-unit id="22fd110d7c238cdd41592c0a602172ada41cc36a" translate="yes" xml:space="preserve">
          <source>An environment variable is used, rather than parallel make itself, because &lt;a href=&quot;TAP::Harness&quot;&gt;TAP::Harness&lt;/a&gt; needs to be able to schedule individual non-conflicting test scripts itself, and there is no standard interface to &lt;code&gt;make&lt;/code&gt; utilities to interact with their job schedulers.</source>
          <target state="translated">&lt;a href=&quot;TAP::Harness&quot;&gt;TAP :: Harness&lt;/a&gt;は、競合しない個々のテストスクリプト自体をスケジュールできる必要があり、ユーティリティがジョブスケジューラと対話する &lt;code&gt;make&lt;/code&gt; の標準インターフェイスがないため、並列make自体ではなく環境変数が使用されます。</target>
        </trans-unit>
        <trans-unit id="85b348ed9fe24e3e5ab044fd0ea208d3866c0f50" translate="yes" xml:space="preserve">
          <source>An environment variable is used, rather than parallel make itself, because &lt;a href=&quot;tap/harness&quot;&gt;TAP::Harness&lt;/a&gt; needs to be able to schedule individual non-conflicting test scripts itself, and there is no standard interface to &lt;code&gt;make&lt;/code&gt; utilities to interact with their job schedulers.</source>
          <target state="translated">&lt;a href=&quot;tap/harness&quot;&gt;TAP :: Harness&lt;/a&gt;は、競合しない個々のテストスクリプト自体をスケジュールできる必要があり、ユーティリティがジョブスケジューラと対話する &lt;code&gt;make&lt;/code&gt; の標準インターフェイスがないため、並列make自体ではなく環境変数が使用されます。</target>
        </trans-unit>
        <trans-unit id="066862fe86f40b5704d122b8bfa39f1462669702" translate="yes" xml:space="preserve">
          <source>An error has occurred (for &lt;code&gt;PerlIO_error()&lt;/code&gt; ).</source>
          <target state="translated">エラーが発生しました（ &lt;code&gt;PerlIO_error()&lt;/code&gt; の場合）。</target>
        </trans-unit>
        <trans-unit id="3d508ac8c71c775f43142d23e442e2000fbf79e9" translate="yes" xml:space="preserve">
          <source>An error has occurred (for &lt;code&gt;PerlIO_error()&lt;/code&gt;).</source>
          <target state="translated">エラーが発生しました（ &lt;code&gt;PerlIO_error()&lt;/code&gt; の場合）。</target>
        </trans-unit>
        <trans-unit id="bf25473c20a4c33f096f0b4023a99e2a049e0b27" translate="yes" xml:space="preserve">
          <source>An essential part of any good development process is appropriate error handling with appropriately informative messages, however there exists a school of thought which suggests that log files should be</source>
          <target state="translated">いかなる良い開発プロセスにおいても、適切なエラー処理と適切な有益なメッセージが不可欠ですが、ログファイルは</target>
        </trans-unit>
        <trans-unit id="66bdaa16d0763f3a76de0b4a13d35f1b3d80f29a" translate="yes" xml:space="preserve">
          <source>An even stranger template code is &lt;code&gt;%&lt;/code&gt; &amp;lt;</source>
          <target state="translated">さらに奇妙なテンプレートコードは &lt;code&gt;%&lt;/code&gt; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c948915c37e1832c4cdb4ea5562b06199c7d0645" translate="yes" xml:space="preserve">
          <source>An even stranger template code is &lt;code&gt;%&lt;/code&gt;&amp;lt;</source>
          <target state="translated">さらに奇妙なテンプレートコードは &lt;code&gt;%&lt;/code&gt; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="8a5463243357a8ee13bfd32810dc057038bf9e07" translate="yes" xml:space="preserve">
          <source>An event that causes a &lt;b&gt;handler&lt;/b&gt; to be run.</source>
          <target state="translated">&lt;b&gt;ハンドラー&lt;/b&gt;を実行させるイベント。</target>
        </trans-unit>
        <trans-unit id="aa855332f899b198338c3e15641312b3dfa643e8" translate="yes" xml:space="preserve">
          <source>An example conversion function for a typemapped struct &lt;code&gt;foo_t *&lt;/code&gt; might be:</source>
          <target state="translated">タイプマップされたstruct &lt;code&gt;foo_t *&lt;/code&gt; の変換関数の例は次のようになります。</target>
        </trans-unit>
        <trans-unit id="ec7aaa34ffb73c97f6ed68693695810184b33f37" translate="yes" xml:space="preserve">
          <source>An example disabling Nagle's algorithm on a socket:</source>
          <target state="translated">ソケット上でNagleのアルゴリズムを無効にする例。</target>
        </trans-unit>
        <trans-unit id="370a61094a87b707b90886b80eccf424717c5430" translate="yes" xml:space="preserve">
          <source>An example for Russian and some languages using the Cyrillic script:</source>
          <target state="translated">ロシア語およびキリル文字を使用したいくつかの言語の例。</target>
        </trans-unit>
        <trans-unit id="62a8d925afd0ed802ddeaf7e7056d235e6263d4e" translate="yes" xml:space="preserve">
          <source>An example may make this clearer:</source>
          <target state="translated">例を挙げれば、より明確になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="562686eabf6589e6760dcb870fbc2918a4b18229" translate="yes" xml:space="preserve">
          <source>An example of all of the phases Perl code can see:</source>
          <target state="translated">Perlのコードが見ることができるすべてのフェーズの例。</target>
        </trans-unit>
        <trans-unit id="b3f8fac7e809f312cdc7e6d944996bb2ded1f5bf" translate="yes" xml:space="preserve">
          <source>An example of how this is used is the &lt;a href=&quot;Test2::Formatter::TAP&quot;&gt;Test2::Formatter::TAP&lt;/a&gt; formatter. For unbuffered subtests the events are rendered as they are generated. At the end of the subtest, the final subtest event is rendered, but the &lt;code&gt;subevents&lt;/code&gt; attribute is ignored. For buffered subtests the opposite occurs, the events are NOT rendered as they are generated, instead the &lt;code&gt;subevents&lt;/code&gt; attribute is used to render them all at once. This is useful when running subtests tests in parallel, since without it the output from subtests would be interleaved together.</source>
          <target state="translated">これがどのように使用されるかの例は、&lt;a href=&quot;Test2::Formatter::TAP&quot;&gt;Test2 :: Formatter :: TAP&lt;/a&gt;フォーマッターです。バッファリングされていないサブテストの場合、イベントは生成時にレンダリングされます。サブテストの最後に、最後のサブテストイベントがレンダリングされますが、 &lt;code&gt;subevents&lt;/code&gt; 属性は無視されます。バッファリングされたサブテストの場合、逆のことが発生し、イベントは生成時にレンダリングされません。代わりに、 &lt;code&gt;subevents&lt;/code&gt; 属性を使用してすべてを一度にレンダリングします。これがないと、サブテストからの出力がインターリーブされるため、サブテストテストを並行して実行する場合に便利です。</target>
        </trans-unit>
        <trans-unit id="5242beac10407637f4a4b464517825d71718f4a4" translate="yes" xml:space="preserve">
          <source>An example of how this might be used is as follows:</source>
          <target state="translated">これをどのように使うかの例としては、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="5a34b3fb3e9dbd7f514687e325a9fcbdaa8609fe" translate="yes" xml:space="preserve">
          <source>An example of this is</source>
          <target state="translated">その例として、以下のようなものがあります。</target>
        </trans-unit>
        <trans-unit id="af46ea4947cfe8e14d48ae32223fb001ec7bc498" translate="yes" xml:space="preserve">
          <source>An example of using Name property wildcards is</source>
          <target state="translated">Nameプロパティのワイルドカードの使用例は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="ab9dc32ca31441503bc05feea6fc9cf1b0dfb98e" translate="yes" xml:space="preserve">
          <source>An example output might be:</source>
          <target state="translated">出力例は次のようになります。</target>
        </trans-unit>
        <trans-unit id="d132f664732cae183fc32adf49e25fe3aca9db69" translate="yes" xml:space="preserve">
          <source>An example taken from an article posted to comp.lang.perl.misc</source>
          <target state="translated">comp.lang.perl.miscに投稿された記事からの例です。</target>
        </trans-unit>
        <trans-unit id="516a8fafa09adceb915093c484c5d89d031db306" translate="yes" xml:space="preserve">
          <source>An example usage looks like:</source>
          <target state="translated">使用例は次のようになります。</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">一例です。</target>
        </trans-unit>
        <trans-unit id="b3e01d95d4f7169aa36a737a1211243d324cf5ef" translate="yes" xml:space="preserve">
          <source>An exception</source>
          <target state="translated">例外</target>
        </trans-unit>
        <trans-unit id="af317c13cfaee4d2548fba4cee59592a6612afcd" translate="yes" xml:space="preserve">
          <source>An exception event will display to STDERR, and will prevent the overall test file from passing.</source>
          <target state="translated">例外イベントがSTDERRに表示され、テストファイル全体が通過しないようになります。</target>
        </trans-unit>
        <trans-unit id="66ab19b971476be687f1585d2d4d367fb367ec27" translate="yes" xml:space="preserve">
          <source>An exception is considered to match a string if:</source>
          <target state="translated">例外は、文字列にマッチしているとみなされます。</target>
        </trans-unit>
        <trans-unit id="441facb85290f4d6c3e35bab01158ccc81039064" translate="yes" xml:space="preserve">
          <source>An exception to the above rule is that &lt;code&gt;\N{U+&lt;i&gt;hex number&lt;/i&gt;}&lt;/code&gt; is always interpreted as a Unicode code point, so that &lt;code&gt;\N{U+0050}&lt;/code&gt; is &lt;code&gt;&quot;P&quot;&lt;/code&gt; even on EBCDIC platforms.</source>
          <target state="translated">上記の規則の例外は、 &lt;code&gt;\N{U+&lt;i&gt;hex number&lt;/i&gt;}&lt;/code&gt; が常にUnicodeコードポイントとして解釈されるため、EBCDICプラットフォームでも &lt;code&gt;\N{U+0050}&lt;/code&gt; が &lt;code&gt;&quot;P&quot;&lt;/code&gt; ことです。</target>
        </trans-unit>
        <trans-unit id="eb08b0a2e1d46bb5d472e490ea7b28d5dd9e956d" translate="yes" xml:space="preserve">
          <source>An exception to this is that you may assign to &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in a list. This is useful for throwing away some of the return values of a function:</source>
          <target state="translated">これの例外は、リストで &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; に割り当てることができることです。これは、関数の戻り値の一部を破棄するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="b907b876869fb91f8d35b06170f79ee9f948ffa2" translate="yes" xml:space="preserve">
          <source>An exception to this is that you may assign to &lt;code&gt;undef&lt;/code&gt; in a list. This is useful for throwing away some of the return values of a function:</source>
          <target state="translated">これの例外は、リストで &lt;code&gt;undef&lt;/code&gt; に割り当てることができることです。これは、関数の戻り値の一部を破棄するのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="6d1bf7c1ca3df304818b1a482b2ae19817ae3aee" translate="yes" xml:space="preserve">
          <source>An exception will be raised if &lt;code&gt;verify_SSL&lt;/code&gt; is true and no CA certificate file is available.</source>
          <target state="translated">&lt;code&gt;verify_SSL&lt;/code&gt; がtrueで、使用可能なCA証明書ファイルがない場合、例外が発生します。</target>
        </trans-unit>
        <trans-unit id="0fc1d98cce4c241de46d33d676c33734f841fc89" translate="yes" xml:space="preserve">
          <source>An executable compiled on a PA-RISC 2.0 platform will not execute on a PA-RISC 1.1 platform, even if they are running the same version of HP-UX. If you are building Perl on a PA-RISC 2.0 platform and want that Perl to also run on a PA-RISC 1.1, the compiler flags +DAportable and +DS32 should be used.</source>
          <target state="translated">PA-RISC 2.0プラットフォーム上でコンパイルされた実行ファイルは、同じバージョンのHP-UXであってもPA-RISC 1.1プラットフォーム上では実行されません。PA-RISC 2.0プラットフォーム上でPerlをビルドしていて、そのPerlをPA-RISC 1.1上でも実行させたい場合は、コンパイラフラグ+DAportableと+DS32を使用してください。</target>
        </trans-unit>
        <trans-unit id="089b36ce65cddba1918a51ae6a46d8831ee39956" translate="yes" xml:space="preserve">
          <source>An exit status of 0 implies &quot;success&quot;. For example, &lt;b&gt;diff(1)&lt;/b&gt; exits with a status of 0 if the two files have the same contents.</source>
          <target state="translated">終了ステータス0は「成功」を意味します。たとえば、2つのファイルの内容が同じ場合、&lt;b&gt;diff（1）&lt;/b&gt;はステータス0で終了します。</target>
        </trans-unit>
        <trans-unit id="bbd4429d08a5ebe605cc6bfbbfa2eaacec53a0f9" translate="yes" xml:space="preserve">
          <source>An exit status of 1 implies possibly abnormal, but non-defective, program termination. For example, &lt;b&gt;grep(1)&lt;/b&gt; exits with a status of 1 if it did</source>
          <target state="translated">終了ステータスが1の場合は、プログラムが異常終了している可能性がありますが、正常に終了しています。たとえば、&lt;b&gt;grep（1）&lt;/b&gt;が終了すると、ステータス1で終了します。</target>
        </trans-unit>
        <trans-unit id="e246081e6327d64a230056100ee6a6d47e29ef00" translate="yes" xml:space="preserve">
          <source>An exit status of 2 or more implies a fatal error. For example, &lt;b&gt;ls(1)&lt;/b&gt; exits with a status of 2 if you specify an illegal (unknown) option on the command line.</source>
          <target state="translated">2以上の終了ステータスは、致命的なエラーを意味します。たとえば、コマンドラインで不正な（不明な）オプションを指定すると、&lt;b&gt;ls（1）&lt;/b&gt;はステータス2で終了します。</target>
        </trans-unit>
        <trans-unit id="1ff1cef51589fc8dbb6faba666f12b831fe6b899" translate="yes" xml:space="preserve">
          <source>An experimental pseudolayer that removes the topmost layer. Use with the same care as is reserved for nitroglycerine.</source>
          <target state="translated">最上層を除去する実験的な擬似層。ニトログリセリンと同様の注意を払って使用してください。</target>
        </trans-unit>
        <trans-unit id="846db25d0ecc19ed2c5fd44070c00f6f8a9c0772" translate="yes" xml:space="preserve">
          <source>An explanation of VMS file specs can be found at &lt;a href=&quot;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&quot;&gt;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&lt;/a&gt;.</source>
          <target state="translated">VMSファイル仕様の説明は、&lt;a href=&quot;http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files&quot;&gt;http：//h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_filesにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b85172cf7a158b615a4c1e4c610cfa79b7fa2c51" translate="yes" xml:space="preserve">
          <source>An explicit format parameter index, such as &lt;code&gt;2$&lt;/code&gt;. By default sprintf will format the next unused argument in the list, but this allows you to take the arguments out of order:</source>
          <target state="translated">&lt;code&gt;2$&lt;/code&gt; などの明示的なフォーマットパラメータインデックス。デフォルトでは、sprintfはリスト内の次の未使用の引数をフォーマットしますが、これにより、引数を順不同にすることができます。</target>
        </trans-unit>
        <trans-unit id="52691b6df07cdbefee8cb7a498d3dc93b2c8dd90" translate="yes" xml:space="preserve">
          <source>An exploration of some of the issues facing Perl programmers on EBCDIC based computers.</source>
          <target state="translated">EBCDICベースのコンピュータ上でPerlプログラマが直面している問題のいくつかを探ります。</target>
        </trans-unit>
        <trans-unit id="372a1e4ea54335151ba75e3cd2ea53899b760f24" translate="yes" xml:space="preserve">
          <source>An expression which, when its value changes, causes a breakpoint in the Perl debugger.</source>
          <target state="translated">値が変更されると、Perl デバッガでブレークポイントを発生させる式。</target>
        </trans-unit>
        <trans-unit id="d16dfa398c1840b695b36040deeba3088ca6a02a" translate="yes" xml:space="preserve">
          <source>An extension is a way of calling compiled C code from Perl. Reading &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; is a good place to learn more about extensions.</source>
          <target state="translated">拡張機能は、PerlからコンパイルされたCコードを呼び出す方法です。拡張機能の詳細を学ぶには、&lt;a href=&quot;perlxstut&quot;&gt;perlxstutを&lt;/a&gt;読むのがよいでしょう。</target>
        </trans-unit>
        <trans-unit id="9164cae08d37bdf18edf58e540f0e6c559fb27cc" translate="yes" xml:space="preserve">
          <source>An extension that is built with the above steps is ready to use on systems supporting dynamic loading. On systems that do not support dynamic loading, any newly created extension has to be linked together with the available resources. MakeMaker supports the linking process by creating appropriate targets in the Makefile whenever an extension is built. You can invoke the corresponding section of the makefile with</source>
          <target state="translated">上記の手順で構築された拡張機能は、動的読み込みをサポートしているシステムで使用する準備ができています。ダイナミックローディングをサポートしていないシステムでは、新しく作成した拡張機能は利用可能なリソースとリンクする必要があります。MakeMaker は、拡張機能がビルドされるたびに Makefile に適切なターゲットを作成することで、リンク処理をサポートします。makefile の対応するセクションを</target>
        </trans-unit>
        <trans-unit id="62fe96c831d4e5434f2a2484c5da0d22ce2c69d7" translate="yes" xml:space="preserve">
          <source>An external &lt;b&gt;subroutine&lt;/b&gt; defined in &lt;b&gt;XS&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;XSで&lt;/b&gt;定義された外部&lt;b&gt;サブルーチン&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7422ed8b7617c92670f322946ad1f9ad0f35ee57" translate="yes" xml:space="preserve">
          <source>An extra field consists of zero or more subfields. Each subfield consists of a two byte header followed by the subfield data.</source>
          <target state="translated">エクストラフィールドは、ゼロ以上のサブフィールドで構成されます。各サブフィールドは、2バイトのヘッダとサブフィールドデータの後に続く2バイトのヘッダで構成されています。</target>
        </trans-unit>
        <trans-unit id="18c0e84026650565acf5b36d62e6093af36330f9" translate="yes" xml:space="preserve">
          <source>An extraordinarily exported, expeditiously excellent, expressly eXternal Subroutine, executed in existing C or C++ or in an exciting extension language called (exasperatingly) XS.</source>
          <target state="translated">既存のCやC++、またはXSと呼ばれるエキサイティングな拡張言語で実行される、非常に迅速にエクスポートされた優れた、明示的にeXternalサブルーチンです。</target>
        </trans-unit>
        <trans-unit id="5ae0ec1c420230a4b9a6f6f5a35cd2c66a33eeb2" translate="yes" xml:space="preserve">
          <source>An extremely lightweight &lt;b&gt;DB_File&lt;/b&gt; wrapper that simply flocks a lockfile before tie-ing the database and drops the lock after the untie. Allows one to use the same lockfile for multiple databases to avoid deadlock problems, if desired. Use for databases where updates are reads are quick and simple flock locking semantics are enough.</source>
          <target state="translated">データベースを結合する前にロックファイルをフロックし、結合解除後にロックをドロップする、非常に軽量な&lt;b&gt;DB_File&lt;/b&gt;ラッパー。必要に応じて、複数のデータベースに同じロックファイルを使用してデッドロックの問題を回避できます。更新が読み込まれるデータベースに使用すると、迅速かつ単純なフロックロックのセマンティクスで十分です。</target>
        </trans-unit>
        <trans-unit id="6c7aaf1b9af23250eb8ede6f4c91ca5fbe3ad083" translate="yes" xml:space="preserve">
          <source>An identifier (not necessarily related to the real name of a file) that represents a particular instance of opening a file, until you close it. If you&amp;rsquo;re going to open and close several different files in succession, it&amp;rsquo;s fine to open each of them with the same filehandle, so you don&amp;rsquo;t have to write out separate code to process each file.</source>
          <target state="translated">ファイルを閉じるまで、ファイルを開く特定のインスタンスを表す識別子（必ずしもファイルの実際の名前に関連している必要はありません）。複数の異なるファイルを連続して開いたり閉じたりする場合は、同じファイルハンドルでそれぞれのファイルを開いても問題ないため、各ファイルを処理するために個別のコードを記述する必要はありません。</target>
        </trans-unit>
        <trans-unit id="2ca4f6f5a018c6a780d2f920105ee21e87c135e6" translate="yes" xml:space="preserve">
          <source>An immediate filter allows you to specify the filter code to be used at the point where the filter is applied to a dbm. In this mode the Filter_*_Push methods expects to receive exactly two parameters.</source>
          <target state="translated">即時フィルタは、フィルタが dbm に適用された時点で使用するフィルタコードを指定することができます。このモードでは、Filter_*_Pushメソッドは2つのパラメータを正確に受け取ることを期待しています。</target>
        </trans-unit>
        <trans-unit id="854d43de9440512807e67ff18407c545a932b325" translate="yes" xml:space="preserve">
          <source>An imperfect standard</source>
          <target state="translated">不完全な基準</target>
        </trans-unit>
        <trans-unit id="20af74febdbf871248a6b2f4c417ca9aaffe6f3f" translate="yes" xml:space="preserve">
          <source>An important property of the digest algorithms is that the digest is</source>
          <target state="translated">ダイジェストアルゴリズムの重要な特性は、ダイジェストが</target>
        </trans-unit>
        <trans-unit id="5358f4c4e85e881620623ef0fa458c651c57bf92" translate="yes" xml:space="preserve">
          <source>An incremental option is specified with a plus &lt;code&gt;+&lt;/code&gt; after the option name:</source>
          <target state="translated">インクリメンタルオプションは、オプション名の後にプラス &lt;code&gt;+&lt;/code&gt; を付けて指定します。</target>
        </trans-unit>
        <trans-unit id="eff14445a69700081714d1ed9ff369fb4f2bc735" translate="yes" xml:space="preserve">
          <source>An index of character names is available on-line from the Unicode Consortium, &lt;a href=&quot;http://www.unicode.org/charts/charindex.html&quot;&gt;http://www.unicode.org/charts/charindex.html&lt;/a&gt;; explanatory material with links to other resources at &lt;a href=&quot;http://www.unicode.org/standard/where&quot;&gt;http://www.unicode.org/standard/where&lt;/a&gt;.</source>
          <target state="translated">キャラクター名のインデックスは、Unicodeコンソーシアム&lt;a href=&quot;http://www.unicode.org/charts/charindex.html&quot;&gt;http://www.unicode.org/charts/charindex.html&lt;/a&gt;からオンラインで入手できます。&lt;a href=&quot;http://www.unicode.org/standard/where&quot;&gt;http://www.unicode.org/standard/where&lt;/a&gt;にある他のリソースへのリンクを含む説明資料。</target>
        </trans-unit>
        <trans-unit id="00b6943f411e2de4ec124878b41ea6334f76e3b4" translate="yes" xml:space="preserve">
          <source>An index of character names is available on-line from the Unicode Consortium, &lt;a href=&quot;https://www.unicode.org/charts/charindex.html&quot;&gt;https://www.unicode.org/charts/charindex.html&lt;/a&gt;; explanatory material with links to other resources at &lt;a href=&quot;https://www.unicode.org/standard/where&quot;&gt;https://www.unicode.org/standard/where&lt;/a&gt;.</source>
          <target state="translated">文字名のインデックスは、Unicodeコンソーシアム（&lt;a href=&quot;https://www.unicode.org/charts/charindex.html&quot;&gt;https://www.unicode.org/charts/charindex.html）&lt;/a&gt;からオンラインで入手できます。&lt;a href=&quot;https://www.unicode.org/standard/where&quot;&gt;https://www.unicode.org/standard/where&lt;/a&gt;にある他のリソースへのリンクを含む説明資料。</target>
        </trans-unit>
        <trans-unit id="ef770a25a15f3c0ce63ccdcd24649733fd026bd0" translate="yes" xml:space="preserve">
          <source>An indirect filehandle is the use of something other than a symbol in a place that a filehandle is expected. Here are ways to get indirect filehandles:</source>
          <target state="translated">間接ファイルハンドルとは、ファイルハンドルが期待される場所でシンボル以外の何かを使用することです。間接ファイルハンドルを取得する方法を以下に示します。</target>
        </trans-unit>
        <trans-unit id="858451a2efc846133fcc1f6e934e6a48b50f2e8c" translate="yes" xml:space="preserve">
          <source>An informative hash, accessible via &lt;code&gt;details()&lt;/code&gt; , is stored for each test you perform. So memory usage will scale linearly with each test run. Although this is not a problem for most test suites, it can become an issue if you do large (hundred thousands to million) combinatorics tests in the same run.</source>
          <target state="translated">&lt;code&gt;details()&lt;/code&gt; からアクセスできる有益なハッシュは、実行するテストごとに保存されます。そのため、メモリ使用量はテストの実行ごとに線形にスケーリングされます。これはほとんどのテストスイートにとって問題ではありませんが、大規模な（数十万から数百万）組み合わせテストを同じ実行で行う場合、問題になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="701384a60361f136947eccd77eb6f91598d0f6e9" translate="yes" xml:space="preserve">
          <source>An informative hash, accessible via &lt;code&gt;details()&lt;/code&gt;, is stored for each test you perform. So memory usage will scale linearly with each test run. Although this is not a problem for most test suites, it can become an issue if you do large (hundred thousands to million) combinatorics tests in the same run.</source>
          <target state="translated">&lt;code&gt;details()&lt;/code&gt; を介してアクセスできる有益なハッシュは、実行するテストごとに保存されます。したがって、メモリ使用量はテストの実行ごとに直線的に増加します。これはほとんどのテストスイートでは問題になりませんが、同じ実行で大規模な（数十万から数百万の）組み合わせ論テストを行うと問題になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="a9e6a3af85651e42bfa391fe495fc3734c02ae8b" translate="yes" xml:space="preserve">
          <source>An input file that uses source filtering probably won't be deparsed into runnable code, because it will still include the &lt;b&gt;use&lt;/b&gt; declaration for the source filtering module, even though the code that is produced is already ordinary Perl which shouldn't be filtered again.</source>
          <target state="translated">ソースフィルタリングを使用する入力ファイルは、実行可能なコードに分解されない可能性があります。生成されたコードが既に通常のPerlであるため、再度フィルタリングする必要はありませんが、ソースフィルタリングモジュールの&lt;b&gt;使用&lt;/b&gt;宣言が含まれている&lt;b&gt;ため&lt;/b&gt;です。</target>
        </trans-unit>
        <trans-unit id="aa16b38820f7deb5595d1bc31e5c4264a804f15b" translate="yes" xml:space="preserve">
          <source>An installation can choose to allow any of these to be matched by downloading the Unicode database from &lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt; to &lt;code&gt;$Config{privlib}&lt;/code&gt; /</source>
          <target state="translated">インストールでは、&lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http：//www.unicode.org/Public/&lt;/a&gt;から &lt;code&gt;$Config{privlib}&lt;/code&gt; /にUnicodeデータベースをダウンロードすることにより、これらのいずれかを一致させることができます。</target>
        </trans-unit>
        <trans-unit id="41c8e8c55ba26c070500d10138a4327fcb1ea456" translate="yes" xml:space="preserve">
          <source>An installation can choose to allow any of these to be matched by downloading the Unicode database from &lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt; to &lt;code&gt;$Config{privlib}&lt;/code&gt;/</source>
          <target state="translated">インストールでは、Unicodeデータベースを&lt;a href=&quot;http://www.unicode.org/Public/&quot;&gt;http://www.unicode.org/Public/&lt;/a&gt;から &lt;code&gt;$Config{privlib}&lt;/code&gt; /にダウンロードすることにより、これらのいずれかを一致させることを選択できます。</target>
        </trans-unit>
        <trans-unit id="a014f84e1453ef226d46effcd0a9cbfe569a9f81" translate="yes" xml:space="preserve">
          <source>An instance of a running program. Under multitasking systems like Unix, two or more separate processes could be running the same program independently at the same time&amp;mdash;in fact, the &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; function is designed to bring about this happy state of affairs. Under other operating systems, processes are sometimes called &amp;ldquo;threads&amp;rdquo;, &amp;ldquo;tasks&amp;rdquo;, or &amp;ldquo;jobs&amp;rdquo;, often with slight nuances in meaning.</source>
          <target state="translated">実行中のプログラムのインスタンス。Unixのようなマルチタスクシステムでは、2つ以上の別々のプロセスが同時に同じプログラムを独立して実行している可能性があります。実際、 &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; 機能はこの幸せな状態をもたらすように設計されています。他のオペレーティングシステムでは、プロセスは「スレッド」、「タスク」、または「ジョブ」と呼ばれることがあり、意味に微妙なニュアンスを伴うことがよくあります。</target>
        </trans-unit>
        <trans-unit id="d7bfae97a3fa7902fae2c04baaa1f1c2a7428aa8" translate="yes" xml:space="preserve">
          <source>An instance of a running program. Under multitasking systems like Unix, two or more separate processes could be running the same program independently at the same time&amp;mdash;in fact, the &lt;code&gt;fork&lt;/code&gt; function is designed to bring about this happy state of affairs. Under other operating systems, processes are sometimes called &amp;ldquo;threads&amp;rdquo;, &amp;ldquo;tasks&amp;rdquo;, or &amp;ldquo;jobs&amp;rdquo;, often with slight nuances in meaning.</source>
          <target state="translated">実行中のプログラムのインスタンス。 Unixのようなマルチタスクシステムでは、2つ以上の別々のプロセスが同じプログラムを同時に独立して実行する可能性があります。実際、 &lt;code&gt;fork&lt;/code&gt; 関数はこの幸せな状態をもたらすように設計されています。他のオペレーティングシステムでは、プロセスは「スレッド」、「タスク」、または「ジョブ」と呼ばれることもあり、意味にわずかなニュアンスがあります。</target>
        </trans-unit>
        <trans-unit id="0214de560f2556559c172656f6d4683531a40229" translate="yes" xml:space="preserve">
          <source>An integer divisor when you&amp;rsquo;re interested in the remainder instead of the quotient.</source>
          <target state="translated">商ではなく剰余に関心がある場合の整数除数。</target>
        </trans-unit>
        <trans-unit id="ef97a772df2ab33140914238f0dfa09aa1f2481c" translate="yes" xml:space="preserve">
          <source>An integer in the range from 0 to 1, inclusive. The smallest possible unit of information storage. An eighth of a &lt;b&gt;byte&lt;/b&gt; or of a dollar. (The term &amp;ldquo;Pieces of Eight&amp;rdquo; comes from being able to split the old Spanish dollar into 8 bits, each of which still counted for money. That&amp;rsquo;s why a 25- cent piece today is still &amp;ldquo;two bits&amp;rdquo;.)</source>
          <target state="translated">0から1までの範囲の整数。情報ストレージの可能な最小単位。&lt;b&gt;バイト&lt;/b&gt;またはドルの8分の1。（「Pieces of Eight」という用語は、古いスペインドルを8ビットに分割できることに由来します。それぞれ8ビットは、まだお金に数えられます。そのため、今日の25セントのピースは、まだ「2ビット」です。）</target>
        </trans-unit>
        <trans-unit id="487c5ee86805465c96baeca407a9f1d4e496a654" translate="yes" xml:space="preserve">
          <source>An interesting property of the 32 C0 control characters in the ASCII table is that they can &quot;literally&quot; be constructed as control characters in Perl, e.g. &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt; )&amp;gt; &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt; )&amp;gt;, and so on. Perl on EBCDIC platforms has been ported to take &lt;code&gt;\c@&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;\cA&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt;, etc. as well, but the characters that result depend on which code page you are using. The table below uses the standard acronyms for the controls. The POSIX-BC and 1047 sets are identical throughout this range and differ from the 0037 set at only one spot (21 decimal). Note that the line terminator character may be generated by &lt;code&gt;\cJ&lt;/code&gt; on ASCII platforms but by &lt;code&gt;\cU&lt;/code&gt; on 1047 or POSIX-BC platforms and cannot be generated as a &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; control character on 0037 platforms. Note also that &lt;code&gt;\c\&lt;/code&gt; cannot be the final element in a string or regex, as it will absorb the terminator. But &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; is a &lt;code&gt;FILE
SEPARATOR&lt;/code&gt; concatenated with</source>
          <target state="translated">ASCIIテーブルの32個のC0制御文字の興味深い特性は、文字どおりにPerlで制御文字として構築できることです。たとえば、 &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt; ）&amp;gt; &lt;code&gt;(&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt; ）&amp;gt; 、 等々。 EBCDICプラットフォーム上のPerlは、 &lt;code&gt;\c@&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(0)&lt;/a&gt;&lt;/code&gt; に、 &lt;code&gt;\cA&lt;/code&gt; を &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr(1)&lt;/a&gt;&lt;/code&gt; に取得するように移植されています。なども含まれますが、結果として得られる文字は、使用しているコードページによって異なります。以下の表では、コントロールに標準の頭字語を使用しています。 POSIX-BCと1047のセットは、この範囲全体で同一であり、0037セットとは1つの点（10進数21）のみが異なります。行終端文字がによって生成されてもよいことに注意してください &lt;code&gt;\cJ&lt;/code&gt; ASCIIプラットフォーム上ではなくで &lt;code&gt;\cU&lt;/code&gt; 1047またはPOSIX-BCプラットフォーム上ととして生成することができない &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; 0037プラットフォームの制御文字。また、 &lt;code&gt;\c\&lt;/code&gt; はターミネーターを吸収するため、文字列または正規表現の最後の要素にはなれません。ただし、 &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; は &lt;code&gt;FILE SEPARATOR&lt;/code&gt; 連結されています</target>
        </trans-unit>
        <trans-unit id="5ec5858c69c508303478b5682163ba9de4ba1b6f" translate="yes" xml:space="preserve">
          <source>An interesting property of the 32 C0 control characters in the ASCII table is that they can &quot;literally&quot; be constructed as control characters in Perl, e.g. &lt;code&gt;(chr(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt;)&amp;gt; &lt;code&gt;(chr(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt;)&amp;gt;, and so on. Perl on EBCDIC platforms has been ported to take &lt;code&gt;\c@&lt;/code&gt; to &lt;code&gt;chr(0)&lt;/code&gt; and &lt;code&gt;\cA&lt;/code&gt; to &lt;code&gt;chr(1)&lt;/code&gt;, etc. as well, but the characters that result depend on which code page you are using. The table below uses the standard acronyms for the controls. The POSIX-BC and 1047 sets are identical throughout this range and differ from the 0037 set at only one spot (21 decimal). Note that the line terminator character may be generated by &lt;code&gt;\cJ&lt;/code&gt; on ASCII platforms but by &lt;code&gt;\cU&lt;/code&gt; on 1047 or POSIX-BC platforms and cannot be generated as a &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; control character on 0037 platforms. Note also that &lt;code&gt;\c\&lt;/code&gt; cannot be the final element in a string or regex, as it will absorb the terminator. But &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; is a &lt;code&gt;FILE SEPARATOR&lt;/code&gt; concatenated with</source>
          <target state="translated">ASCIIテーブルの32個のC0制御文字の興味深い特性は、Perlの制御文字として「文字通り」構築できることです。例： &lt;code&gt;(chr(0)&lt;/code&gt; eq &lt;code&gt;\c@&lt;/code&gt; ）&amp;gt; &lt;code&gt;(chr(1)&lt;/code&gt; eq &lt;code&gt;\cA&lt;/code&gt; ）&amp;gt; 、 等々。 EBCDICプラットフォーム上のPerlは、 &lt;code&gt;\c@&lt;/code&gt; を &lt;code&gt;chr(0)&lt;/code&gt; に、 &lt;code&gt;\cA&lt;/code&gt; を &lt;code&gt;chr(1)&lt;/code&gt; に変換するように移植されていますが、結果の文字は、使用しているコードページによって異なります。次の表では、コントロールの標準的な頭字語を使用しています。 POSIX-BCおよび1047セットは、この範囲全体で同一であり、1つのスポット（10進数で21）のみが0037セットと異なります。ラインターミネータ文字は &lt;code&gt;\cJ&lt;/code&gt; によって生成される場合があることに注意してくださいASCIIプラットフォームではなく、することにより &lt;code&gt;\cU&lt;/code&gt; 1047またはPOSIX-BCプラットフォーム上ととして生成することができない &lt;code&gt;&quot;\c.letter.&quot;&lt;/code&gt; 0037プラットフォームの制御文字。 &lt;code&gt;\c\&lt;/code&gt; はターミネータを吸収するため、文字列または正規表現の最後の要素にすることはできないことにも注意してください。ただし、 &lt;code&gt;\c\&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; は、と連結された &lt;code&gt;FILE SEPARATOR&lt;/code&gt; 文字です。</target>
        </trans-unit>
        <trans-unit id="aef88cb460d98eb7a1821664038bd8e659735536" translate="yes" xml:space="preserve">
          <source>An internal &amp;ldquo;glob value&amp;rdquo; typedef, holding a &lt;b&gt;typeglob&lt;/b&gt;. The &lt;code&gt;GV&lt;/code&gt; type is a subclass of &lt;b&gt;SV&lt;/b&gt;.</source>
          <target state="translated">内部の「グロブ値」のtypedefは、保持&lt;b&gt;型グロブを&lt;/b&gt;。 &lt;code&gt;GV&lt;/code&gt; のタイプはのサブクラスである&lt;b&gt;SV&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="365d20928561014537aae861944e88c7698c35b5" translate="yes" xml:space="preserve">
          <source>An internal I/O object. Can also mean &lt;b&gt;indirect object&lt;/b&gt;.</source>
          <target state="translated">内部I / Oオブジェクト。&lt;b&gt;間接オブジェクトを&lt;/b&gt;意味することもあり&lt;b&gt;ます&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="56ae7164116e23d92fc781838b142ca53874c36a" translate="yes" xml:space="preserve">
          <source>An internal function to generate the embedded perl code that will regenerate the constant subroutines.</source>
          <target state="translated">定数サブルーチンを再生成する埋め込みperlコードを生成するための内部関数です。</target>
        </trans-unit>
        <trans-unit id="7baaf8aedf397c98d596c2159887aa7f484b6db4" translate="yes" xml:space="preserve">
          <source>An internal function to generate the embedded perl code that will regenerate the constant subroutines. Parameters are the same as for C_constant.</source>
          <target state="translated">定数サブルーチンを再生成する埋め込みperlコードを生成するための内部関数です。パラメータはC_constantと同じです。</target>
        </trans-unit>
        <trans-unit id="85667dd393cb7f2981dedf066accff60dc1411e5" translate="yes" xml:space="preserve">
          <source>An internal method to generate a suitable &lt;code&gt;switch&lt;/code&gt; clause, called by &lt;code&gt;C_constant&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;C_constant&lt;/code&gt; によって呼び出される適切な &lt;code&gt;switch&lt;/code&gt; 句を生成する内部メソッド</target>
        </trans-unit>
        <trans-unit id="69e28cd04a2779fc9d5742eab6b3a6ded1892dd3" translate="yes" xml:space="preserve">
          <source>An internal representation of your program wherein lower-level &lt;b&gt;constructs&lt;/b&gt; dangle off the higher-level constructs enclosing them.</source>
          <target state="translated">プログラムの内部表現で、下位レベルの&lt;b&gt;構成要素&lt;/b&gt;がそれを囲む上位レベルの&lt;b&gt;構成要素を&lt;/b&gt;ぶら下げます。</target>
        </trans-unit>
        <trans-unit id="ce42a8cc64b6b6a7bf11b4b312683fee15a303f0" translate="yes" xml:space="preserve">
          <source>An internal shorthand for a &amp;ldquo;push- pop&amp;rdquo; code; that is, C code implementing Perl&amp;rsquo;s stack machine.</source>
          <target state="translated">「プッシュポップ」コードの内部短縮形。つまり、Perlのスタックマシンを実装するCコードです。</target>
        </trans-unit>
        <trans-unit id="2be767144e56c8e338304ff9f530373044c5bc8a" translate="yes" xml:space="preserve">
          <source>An internal variable used by &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;. A string in two parts, separated by a &lt;code&gt;\0&lt;/code&gt; byte, the first part describes the input layers, the second part describes the output layers.</source>
          <target state="translated">&lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt;によって使用される内部変数。 &lt;code&gt;\0&lt;/code&gt; バイトで区切られた2つの部分の文字列。最初の部分は入力層を記述し、2番目の部分は出力層を記述します。</target>
        </trans-unit>
        <trans-unit id="07d1d6d772129317410071c249632c5b5382b664" translate="yes" xml:space="preserve">
          <source>An internal variable used by PerlIO. A string in two parts, separated by a &lt;code&gt;\0&lt;/code&gt; byte, the first part describes the input layers, the second part describes the output layers.</source>
          <target state="translated">PerlIOによって使用される内部変数。 &lt;code&gt;\0&lt;/code&gt; バイトで区切られた2つの部分の文字列。最初の部分は入力レイヤーを説明し、2番目の部分は出力レイヤーを説明します。</target>
        </trans-unit>
        <trans-unit id="30d4f93cd3d13081a21910a8e9e9a9f2e19354af" translate="yes" xml:space="preserve">
          <source>An invalid POD command has been found. Valid are &lt;code&gt;=head1&lt;/code&gt; , &lt;code&gt;=head2&lt;/code&gt; , &lt;code&gt;=head3&lt;/code&gt; , &lt;code&gt;=head4&lt;/code&gt; , &lt;code&gt;=over&lt;/code&gt; , &lt;code&gt;=item&lt;/code&gt; , &lt;code&gt;=back&lt;/code&gt; , &lt;code&gt;=begin&lt;/code&gt; , &lt;code&gt;=end&lt;/code&gt; , &lt;code&gt;=for&lt;/code&gt; , &lt;code&gt;=pod&lt;/code&gt; , &lt;code&gt;=cut&lt;/code&gt;</source>
          <target state="translated">無効なPODコマンドが見つかりました。有効なのは &lt;code&gt;=head1&lt;/code&gt; 、 &lt;code&gt;=head2&lt;/code&gt; 、 &lt;code&gt;=head3&lt;/code&gt; 、 &lt;code&gt;=head4&lt;/code&gt; 、 &lt;code&gt;=over&lt;/code&gt; 、 &lt;code&gt;=item&lt;/code&gt; 、 &lt;code&gt;=back&lt;/code&gt; 、 &lt;code&gt;=begin&lt;/code&gt; 、 &lt;code&gt;=end&lt;/code&gt; 、 &lt;code&gt;=for&lt;/code&gt; 、 &lt;code&gt;=pod&lt;/code&gt; 、 &lt;code&gt;=cut&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="680a8cfcc47d942c4c76eb14d38af7a01657dc85" translate="yes" xml:space="preserve">
          <source>An invalid POD command has been found. Valid are &lt;code&gt;=head1&lt;/code&gt;, &lt;code&gt;=head2&lt;/code&gt;, &lt;code&gt;=head3&lt;/code&gt;, &lt;code&gt;=head4&lt;/code&gt;, &lt;code&gt;=over&lt;/code&gt;, &lt;code&gt;=item&lt;/code&gt;, &lt;code&gt;=back&lt;/code&gt;, &lt;code&gt;=begin&lt;/code&gt;, &lt;code&gt;=end&lt;/code&gt;, &lt;code&gt;=for&lt;/code&gt;, &lt;code&gt;=pod&lt;/code&gt;, &lt;code&gt;=cut&lt;/code&gt;</source>
          <target state="translated">無効なPODコマンドが見つかりました。有効なのは &lt;code&gt;=head1&lt;/code&gt; 、 &lt;code&gt;=head2&lt;/code&gt; 、 &lt;code&gt;=head3&lt;/code&gt; 、 &lt;code&gt;=head4&lt;/code&gt; 、 &lt;code&gt;=over&lt;/code&gt; 、 &lt;code&gt;=item&lt;/code&gt; 、 &lt;code&gt;=back&lt;/code&gt; 、 &lt;code&gt;=begin&lt;/code&gt; 、 &lt;code&gt;=end&lt;/code&gt; 、 &lt;code&gt;=for&lt;/code&gt; 、 &lt;code&gt;=pod&lt;/code&gt; 、 &lt;code&gt;=cut&lt;/code&gt; です</target>
        </trans-unit>
        <trans-unit id="8cf1c0648159d8ce5ec8b307b5ed4c7e4b2df3c9" translate="yes" xml:space="preserve">
          <source>An invalid markup command has been encountered. Valid are: &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">無効なマークアップコマンドが検出されました。有効なのは、 &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab0cc889ac8e69a2e34e2105510c7875248e79d9" translate="yes" xml:space="preserve">
          <source>An invalid markup command has been encountered. Valid are: &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">無効なマークアップコマンドが検出されました。有効なもの： &lt;code&gt;B&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;C&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;E&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;F&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;I&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;L&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;S&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;X&amp;lt;&amp;gt;&lt;/code&gt; 、 &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee1262d5508556d2b36a24c42f3e9a2dee57cb72" translate="yes" xml:space="preserve">
          <source>An item &quot;_*&quot; is interpreted to mean &quot;all of @_ except $_[0]&quot;. I.e., &lt;code&gt;@_[1..$#_]&lt;/code&gt; . Note that this is an empty list in the case of calls like $lh-&amp;gt;maketext(</source>
          <target state="translated">アイテム「_ *」は「$ _ [0]を除くすべての@_」を意味すると解釈されます。つまり、 &lt;code&gt;@_[1..$#_]&lt;/code&gt; です。$ lh-&amp;gt; maketext（のような呼び出しの場合、これは空のリストであることに注意してください</target>
        </trans-unit>
        <trans-unit id="c7832bda7130f94045f7bfb60ec1dccf55e7e697" translate="yes" xml:space="preserve">
          <source>An item &quot;_*&quot; is interpreted to mean &quot;all of @_ except $_[0]&quot;. I.e., &lt;code&gt;@_[1..$#_]&lt;/code&gt;. Note that this is an empty list in the case of calls like $lh-&amp;gt;maketext(</source>
          <target state="translated">アイテム「_ *」は、「$ _ [0]を除くすべての@_」を意味すると解釈されます。つまり、 &lt;code&gt;@_[1..$#_]&lt;/code&gt; 。$ lh-&amp;gt; maketext（のような呼び出しの場合、これは空のリストであることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9af9ff7e003c973fa83a18c634e0daee75f8051b" translate="yes" xml:space="preserve">
          <source>An item that is &quot;_</source>
          <target state="translated">となっているアイテム。</target>
        </trans-unit>
        <trans-unit id="7b5f2c15e59a54bf0587db95d2a9b094a2521830" translate="yes" xml:space="preserve">
          <source>An number specifying the maximum number of fields to return. If this argument is omitted (or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), split continues as long as possible.</source>
          <target state="translated">返すフィールドの最大数を指定する数値。この引数を省略した場合（または &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; の場合）、splitは可能な限り継続されます。</target>
        </trans-unit>
        <trans-unit id="da38298cadbae3dcfcb616625cc2268ee1079670" translate="yes" xml:space="preserve">
          <source>An number specifying the maximum number of fields to return. If this argument is omitted (or &lt;code&gt;undef&lt;/code&gt;), split continues as long as possible.</source>
          <target state="translated">返すフィールドの最大数を指定する数値。この引数を省略（または &lt;code&gt;undef&lt;/code&gt; ）すると、分割は可能な限り続行されます。</target>
        </trans-unit>
        <trans-unit id="eabc404e0d4e219ccc6748ea24d333aab485d543" translate="yes" xml:space="preserve">
          <source>An object belonging to a language class is called a &quot;language handle&quot;; it's typically a flyweight object.</source>
          <target state="translated">言語クラスに属するオブジェクトは「言語ハンドル」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="49f2fe3106e7ff8ff917e823e3eefb2822882e64" translate="yes" xml:space="preserve">
          <source>An object corresponding to a paragraph of POD input text. It may be a plain paragraph, a verbatim paragraph, or a command paragraph (see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;).</source>
          <target state="translated">POD入力テキストの段落に対応するオブジェクト。プレーンパラグラフ、逐語的パラグラフ、またはコマンドパラグラフ（&lt;a href=&quot;../perlpod&quot;&gt;perlpodを&lt;/a&gt;参照）のいずれかです。</target>
        </trans-unit>
        <trans-unit id="8c3786be4e01790b87960925526e572088af640f" translate="yes" xml:space="preserve">
          <source>An object corresponding to a tree of parsed POD text. Each &quot;node&quot; in a parse-tree (or</source>
          <target state="translated">解析されたPODテキストのツリーに対応するオブジェクト。パースツリー(または</target>
        </trans-unit>
        <trans-unit id="7e0998ddd63a38891699bf9ec1b0ac44c576baee" translate="yes" xml:space="preserve">
          <source>An object corresponding to an interior sequence command from the POD input text (see &lt;a href=&quot;../perlpod&quot;&gt;perlpod&lt;/a&gt;).</source>
          <target state="translated">POD入力テキストからの内部シーケンスコマンドに対応するオブジェクト（&lt;a href=&quot;../perlpod&quot;&gt;perlpodを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="9a21e67f15a49134056700786cd13ad755082aac" translate="yes" xml:space="preserve">
          <source>An object is simply a data structure that knows to which class it belongs.</source>
          <target state="translated">オブジェクトは、それがどのクラスに属しているかを知っているデータ構造体に過ぎません。</target>
        </trans-unit>
        <trans-unit id="a359cbcceea3057766a3859aec9166b89f1082b5" translate="yes" xml:space="preserve">
          <source>An object method that initializes the first and last name to its two arguments. If called as a class method, &lt;code&gt;init()&lt;/code&gt; creates an object in the given class and initializes that.</source>
          <target state="translated">姓と名を2つの引数に初期化するオブジェクトメソッド。クラスメソッドとして呼び出された場合、 &lt;code&gt;init()&lt;/code&gt; は指定されたクラスにオブジェクトを作成し、それを初期化します。</target>
        </trans-unit>
        <trans-unit id="2624824193fa16111d4b98614c9c89fd43601093" translate="yes" xml:space="preserve">
          <source>An object of a class created by the first and third forms is based on an array, whereas an object of a class created by the second form is based on a hash. The array-based forms will be somewhat faster and smaller; the hash-based forms are more flexible.</source>
          <target state="translated">第一形態と第三形態によって作成されたクラスのオブジェクトは配列に基づいていますが、第二形態によって作成されたクラスのオブジェクトはハッシュに基づいています。配列ベースのフォームは多少高速で小さくなりますが、ハッシュベースのフォームはより柔軟性があります。</target>
        </trans-unit>
        <trans-unit id="439e33121717fb8b3802d4a57550afd4a17f81f5" translate="yes" xml:space="preserve">
          <source>An object of class Archive::Tar represents a .tar(.gz) archive full of files and things.</source>
          <target state="translated">Archive::Tar クラスのオブジェクトは、ファイルや物が詰まった .tar(.gz)アーカイブを表します。</target>
        </trans-unit>
        <trans-unit id="fcd5621c0c225a91e3f7d06ac2a91fa4ab613367" translate="yes" xml:space="preserve">
          <source>An object representing a POD interior sequence command. It has the following methods/attributes:</source>
          <target state="translated">POD 内部シーケンスコマンドを表すオブジェクト。以下のメソッド/属性を持ちます。</target>
        </trans-unit>
        <trans-unit id="c24cc2e914ce53bfd778879fef27948d64904b08" translate="yes" xml:space="preserve">
          <source>An object representing a paragraph of POD input text. It has the following methods/attributes:</source>
          <target state="translated">POD入力テキストの段落を表すオブジェクト。以下のメソッド/属性を持つ。</target>
        </trans-unit>
        <trans-unit id="6fdb094e1018942aa0eb673bb8c92b50838eeb01" translate="yes" xml:space="preserve">
          <source>An object represents a single discrete thing. For example, an object might represent a file. The attributes for a file object might include its path, content, and last modification time. If we created an object to represent</source>
          <target state="translated">オブジェクトは、単一の離散的なものを表します。例えば、オブジェクトはファイルを表します。ファイルオブジェクトの属性には、パス、内容、最終更新時刻などが含まれます。を表すオブジェクトを作成したとします。</target>
        </trans-unit>
        <trans-unit id="ca7e61e203c4b11d26a8c4d45f16575384df7da5" translate="yes" xml:space="preserve">
          <source>An object that overloads an assignment operator does so only in respect of assignments to that object. In other words, Perl never calls the corresponding methods with the third argument (the &quot;swap&quot; argument) set to TRUE. For example, the operation</source>
          <target state="translated">代入演算子をオーバーロードするオブジェクトは、そのオブジェクトへの代入に関してのみオーバーロードします。言い換えれば、Perl は第三引数 (swap 引数)を TRUE に設定して対応するメソッドを呼び出すことはありません。例えば</target>
        </trans-unit>
        <trans-unit id="5dcc2b27aa012d9c72429af38062f2b4f54986c2" translate="yes" xml:space="preserve">
          <source>An object's members cannot be made accessible as variables. The closest Perl equivalent to &lt;code&gt;with(object) { method() }&lt;/code&gt; is &lt;code&gt;for&lt;/code&gt; , which can alias &lt;code&gt;$_&lt;/code&gt; to the object:</source>
          <target state="translated">オブジェクトのメンバーを変数としてアクセス可能にすることはできません。 &lt;code&gt;with(object) { method() }&lt;/code&gt; する最も近いPerl は &lt;code&gt;for&lt;/code&gt; であり、 &lt;code&gt;$_&lt;/code&gt; をオブジェクトにエイリアスできます。</target>
        </trans-unit>
        <trans-unit id="667eaf5552288796413270dd142cf8898197f884" translate="yes" xml:space="preserve">
          <source>An object's members cannot be made accessible as variables. The closest Perl equivalent to &lt;code&gt;with(object) { method() }&lt;/code&gt; is &lt;code&gt;for&lt;/code&gt;, which can alias &lt;code&gt;$_&lt;/code&gt; to the object:</source>
          <target state="translated">オブジェクトのメンバーを変数としてアクセス可能にすることはできません。 &lt;code&gt;with(object) { method() }&lt;/code&gt; 相当する最も近いPerlは &lt;code&gt;for&lt;/code&gt; であり、 &lt;code&gt;$_&lt;/code&gt; をオブジェクトにエイリアスできます。</target>
        </trans-unit>
        <trans-unit id="b940725a20a5223e137a3da755a048d1310c8a3b" translate="yes" xml:space="preserve">
          <source>An object, however, is a reference to blessed data, so if &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are objects then the assignment &lt;code&gt;$a = $b&lt;/code&gt; copies only the reference, leaving &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; referring to the same object data. One might therefore expect the operation &lt;code&gt;--$a&lt;/code&gt; to decrement &lt;code&gt;$b&lt;/code&gt; as well as &lt;code&gt;$a&lt;/code&gt; . However, this would not be consistent with how we expect the mathematical operators to work.</source>
          <target state="translated">ただし、オブジェクトは祝福されたデータへの参照であるため、 &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; がオブジェクトの場合、割り当て &lt;code&gt;$a = $b&lt;/code&gt; は参照のみをコピー &lt;code&gt;$a&lt;/code&gt; 、 &lt;code&gt;$b&lt;/code&gt; と$ bは同じオブジェクトデータを参照します。一つは、そのための操作を期待するかもしれない &lt;code&gt;--$a&lt;/code&gt; デクリメントする &lt;code&gt;$b&lt;/code&gt; だけでなく、 &lt;code&gt;$a&lt;/code&gt; 。ただし、これは、数学演算子が機能することを期待する方法とは一致しません。</target>
        </trans-unit>
        <trans-unit id="25fb12e7db9c947b1012ab13c08ddc21606a22cc" translate="yes" xml:space="preserve">
          <source>An object, however, is a reference to blessed data, so if &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; are objects then the assignment &lt;code&gt;$a = $b&lt;/code&gt; copies only the reference, leaving &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; referring to the same object data. One might therefore expect the operation &lt;code&gt;--$a&lt;/code&gt; to decrement &lt;code&gt;$b&lt;/code&gt; as well as &lt;code&gt;$a&lt;/code&gt;. However, this would not be consistent with how we expect the mathematical operators to work.</source>
          <target state="translated">ただし、オブジェクトは祝福されたデータへの参照であるため、 &lt;code&gt;$a&lt;/code&gt; と &lt;code&gt;$b&lt;/code&gt; がオブジェクトの場合、割り当て &lt;code&gt;$a = $b&lt;/code&gt; は参照のみをコピー &lt;code&gt;$a&lt;/code&gt; 、 &lt;code&gt;$b&lt;/code&gt; と$ bは同じオブジェクトデータを参照します。一つは、そのための操作を期待するかもしれない &lt;code&gt;--$a&lt;/code&gt; デクリメントする &lt;code&gt;$b&lt;/code&gt; だけでなく、 &lt;code&gt;$a&lt;/code&gt; 。ただし、これは、数学演算子がどのように機能するかとは一致しません。</target>
        </trans-unit>
        <trans-unit id="cee679c1ad7f71a88f44d59f19712e4063863e7e" translate="yes" xml:space="preserve">
          <source>An older style is to use a bareword as the filehandle, as</source>
          <target state="translated">古いスタイルでは、ファイルハンドルとして bareword を使用します。</target>
        </trans-unit>
        <trans-unit id="60dc562d58d05afda178b352ef3aa2e15f8841ff" translate="yes" xml:space="preserve">
          <source>An op is a fundamental operation that Perl can perform: all the built-in functions and operators are ops, and there are a series of ops which deal with concepts the interpreter needs internally - entering and leaving a block, ending a statement, fetching a variable, and so on.</source>
          <target state="translated">opはPerlが実行できる基本的な操作です。組み込みの関数や演算子はすべてopであり、インタープリタが内部的に必要とする概念を扱う一連のopがあります。</target>
        </trans-unit>
        <trans-unit id="7d7b9e438ab0eb414e5789ea7e5ffe93395e4dff" translate="yes" xml:space="preserve">
          <source>An operator with only one &lt;b&gt;operand&lt;/b&gt;, like &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;. Unary operators are usually prefix operators; that is, they precede their operand. The &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; operators can be either prefix or postfix. (Their position</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; のように、&lt;b&gt;オペランドが&lt;/b&gt; 1つだけの演算子 または &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; 。単項演算子は通常、前置演算子です。つまり、オペランドの前に置かれます。 &lt;code&gt;++&lt;/code&gt; と &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; 演算子は接頭辞または接尾辞のいずれかになります。（彼らの位置</target>
        </trans-unit>
        <trans-unit id="2af9fb33db84bf30fe452d6a36fe8b4e335e0649" translate="yes" xml:space="preserve">
          <source>An operator with only one &lt;b&gt;operand&lt;/b&gt;, like &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;chdir&lt;/code&gt;. Unary operators are usually prefix operators; that is, they precede their operand. The &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; operators can be either prefix or postfix. (Their position</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; のように、&lt;b&gt;オペランドが&lt;/b&gt;1つしかない演算子。または &lt;code&gt;chdir&lt;/code&gt; 。単項演算子は通常、接頭演算子です。つまり、オペランドの前にあります。 &lt;code&gt;++&lt;/code&gt; と &lt;code&gt;&amp;ndash;&amp;ndash;&lt;/code&gt; 演算子は接頭辞または接尾辞のいずれかになります。 （彼らの立場</target>
        </trans-unit>
        <trans-unit id="9f9db1e29b16d48958d935e90ad14b3aea77dc3c" translate="yes" xml:space="preserve">
          <source>An opname or optag can be prefixed with an exclamation mark, e.g., !mkdir. Negating an opname or optag means remove the corresponding ops from the accumulated set of ops at that point.</source>
          <target state="translated">opname や optag の前には感嘆符を付けることができます。opname または optag を否定することは、その時点で蓄積された ops のセットから対応する ops を削除することを意味します。</target>
        </trans-unit>
        <trans-unit id="dd9db1bae968b2ebc8590123585766603b6be162" translate="yes" xml:space="preserve">
          <source>An option on a pattern or substitution, such as &lt;code&gt;/i&lt;/code&gt; to render the pattern case- insensitive.</source>
          <target state="translated">パターンの大文字と小文字を区別しない &lt;code&gt;/i&lt;/code&gt; などのパターンまたは置換のオプション。</target>
        </trans-unit>
        <trans-unit id="1a49163e236ca9288cd8e7003ee1066226da4567" translate="yes" xml:space="preserve">
          <source>An option you give on a command line to influence the way your program works, usually introduced with a minus sign. The word is also used as a nickname for a &lt;b&gt;switch statement&lt;/b&gt;.</source>
          <target state="translated">プログラムの動作に影響を与えるためにコマンドラインで指定するオプション。通常はマイナス記号で始まります。この単語は、&lt;b&gt;switchステートメントの&lt;/b&gt;ニックネームとしても使用されます。</target>
        </trans-unit>
        <trans-unit id="eab6379d02e7da9bfe1cac71088e9311f2348060" translate="yes" xml:space="preserve">
          <source>An optional array of other socket options to apply after the three listed above. The value is an ARRAY containing 2- or 3-element ARRAYrefs. Each inner array relates to a single option, giving the level and option name, and an optional value. If the value element is missing, it will be given the value of a platform-sized integer 1 constant (i.e. suitable to enable most of the common boolean options).</source>
          <target state="translated">上記の3つのソケットオプションの後に適用する他のソケットオプションのオプション配列。値は、2 要素または 3 要素の ARRAYrefs を含む ARRAY である。各内部配列は 1 つのオプションに関連しており、レベルとオプション名、オプションの値を与えます。value 要素が欠落している場合、プラットフォームサイズの整数 1 定数の値が与えられます (つまり、一般的なブール値オプションのほとんどを有効にするのに適しています)。</target>
        </trans-unit>
        <trans-unit id="e2561efefd0f2b6e16416b85a2d7a359b74ad024" translate="yes" xml:space="preserve">
          <source>An optional feature provided by a CPAN distribution</source>
          <target state="translated">CPAN ディストリビューションで提供されるオプション機能</target>
        </trans-unit>
        <trans-unit id="9645245b8e6172ce42528bd667596edb4e44c226" translate="yes" xml:space="preserve">
          <source>An optional filehandle (or IO::Handle ) that output will be printed to.</source>
          <target state="translated">出力が出力されるオプションのファイルハンドル(または IO::Handle )。</target>
        </trans-unit>
        <trans-unit id="bcc5a81df3ac1dbb29e0b23ff110e8ac5f546061" translate="yes" xml:space="preserve">
          <source>An optional filehandle (or IO::Handle ) to which the output string will be printed.</source>
          <target state="translated">出力文字列が出力されるファイルハンドル(または IO::Handle)。</target>
        </trans-unit>
        <trans-unit id="2f9901f0f16239239419edd137f25118d48c58b4" translate="yes" xml:space="preserve">
          <source>An optional parameter can be nameless just like a mandatory parameter. For example,</source>
          <target state="translated">オプションのパラメータは、必須のパラメータと同じように無名にすることができます。例えば</target>
        </trans-unit>
        <trans-unit id="c0d6b2a0df46d7d7fb341e1412dc44bcca1bf51c" translate="yes" xml:space="preserve">
          <source>An optional part of a &lt;b&gt;subroutine&lt;/b&gt; declaration telling the Perl compiler how many and what flavor of arguments may be passed as &lt;b&gt;actual arguments&lt;/b&gt;, so you can write subroutine calls that parse much like built-in functions. (Or don&amp;rsquo;t parse, as the case may be.)</source>
          <target state="translated">&lt;b&gt;サブルーチン&lt;/b&gt;宣言のオプションの部分は、Perlコンパイラーに&lt;b&gt;実際の引数&lt;/b&gt;として渡すことができる引数の数と種類を伝えるため、組み込み関数のように解析するサブルーチン呼び出しを記述できます。（または、場合によっては解析しないでください。）</target>
        </trans-unit>
        <trans-unit id="a21eb72be8656b34c88984249eec6f0bab32e544" translate="yes" xml:space="preserve">
          <source>An optional third parameter can be used to specify the buffer size used for copying. This is the number of bytes from the first file, that will be held in memory at any given time, before being written to the second file. The default buffer size depends upon the file, but will generally be the whole file (up to 2MB), or 1k for filehandles that do not reference files (eg. sockets).</source>
          <target state="translated">オプションの 3 番目のパラメータを使用して、コピーに使用するバッファサイズを指定することができます。これは、2 番目のファイルに書き込まれる前に、1 番目のファイルからメモリに保持されるバイト数です。デフォルトのバッファサイズはファイルに依存しますが、一般的にはファイル全体(2MBまで)、ファイルを参照しないファイルハンドル(ソケットなど)の場合は1kになります。</target>
        </trans-unit>
        <trans-unit id="0ba928fdaea76c696564501e58ec48f20c5c9dc1" translate="yes" xml:space="preserve">
          <source>An ordered sequence of &lt;b&gt;values&lt;/b&gt;, stored such that you can easily access any of the values using an</source>
          <target state="translated">順序付けられたシーケンス&lt;b&gt;値は&lt;/b&gt;、あなたが簡単に値のいずれかを使用してアクセスできるように保存されました</target>
        </trans-unit>
        <trans-unit id="2b793fb04f1842403dcb9eae8e630daf85625e60" translate="yes" xml:space="preserve">
          <source>An ordered set of scalar values.</source>
          <target state="translated">スカラー値の順序付き集合。</target>
        </trans-unit>
        <trans-unit id="5c49a2821f5a5074f3f77a39e2cb0f3e615a425e" translate="yes" xml:space="preserve">
          <source>An ordinary disk file.</source>
          <target state="translated">普通のディスクファイル。</target>
        </trans-unit>
        <trans-unit id="a77cc50988bf220f630f8fad5e50fc8b8f153295" translate="yes" xml:space="preserve">
          <source>An ordinary hard disk partition.</source>
          <target state="translated">普通のハードディスクのパーティション。</target>
        </trans-unit>
        <trans-unit id="93d009c1cdb4335605c0d3fe2975d2046a8496a5" translate="yes" xml:space="preserve">
          <source>An overview of the Perl interpreter source code and some details on how Perl does what it does.</source>
          <target state="translated">Perl インタプリタのソースコードの概要と、Perl がどのように動作するかの詳細。</target>
        </trans-unit>
        <trans-unit id="bfd206b59d07c02456cd04b8e043a98488117f17" translate="yes" xml:space="preserve">
          <source>An overview of the Perl source tree. This will help you find the files you're looking for.</source>
          <target state="translated">Perl のソースツリーの概要です。これは、探しているファイルを見つけるのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="a982a39a2d5d6b9f37342b5e83c23e1f0856fa85" translate="yes" xml:space="preserve">
          <source>An uncaught &lt;b&gt;exception&lt;/b&gt;, which causes termination of the &lt;b&gt;process&lt;/b&gt; after printing a message on your &lt;b&gt;standard error&lt;/b&gt; stream. Errors that happen inside an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; are not fatal. Instead, the &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; terminates after placing the exception message in the &lt;code&gt;$@&lt;/code&gt; (&lt;code&gt;$EVAL_ERROR&lt;/code&gt; ) variable. You can try to provoke a fatal error with the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; operator (known as throwing or raising an exception), but this may be caught by a dynamically enclosing &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;. If not caught, the &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; becomes a fatal error.</source>
          <target state="translated">キャッチされない&lt;b&gt;例外&lt;/b&gt;。これは、&lt;b&gt;標準エラー&lt;/b&gt;ストリームにメッセージを出力した後に&lt;b&gt;プロセス&lt;/b&gt;を終了させます。 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 内部で発生するエラーは致命的ではありません。代わりに、例外メッセージを &lt;code&gt;$@&lt;/code&gt; （ &lt;code&gt;$EVAL_ERROR&lt;/code&gt; ）変数に配置した後、 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; は終了します。 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; オペレーターを使用して致命的なエラー（スローの発生または例外の発生と呼ばれる）を引き起こそうとすることができますが、これは動的に囲まれた &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; によってキャッチされる場合があります。キャッチされない場合、 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; は致命的なエラーになります。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f1a5d434a9faff9684c6af59ceb8c569c1859cc2" translate="yes" xml:space="preserve">
          <source>An uncaught &lt;b&gt;exception&lt;/b&gt;, which causes termination of the &lt;b&gt;process&lt;/b&gt; after printing a message on your &lt;b&gt;standard error&lt;/b&gt; stream. Errors that happen inside an &lt;code&gt;eval&lt;/code&gt; are not fatal. Instead, the &lt;code&gt;eval&lt;/code&gt; terminates after placing the exception message in the &lt;code&gt;$@&lt;/code&gt; (&lt;code&gt;$EVAL_ERROR&lt;/code&gt;) variable. You can try to provoke a fatal error with the &lt;code&gt;die&lt;/code&gt; operator (known as throwing or raising an exception), but this may be caught by a dynamically enclosing &lt;code&gt;eval&lt;/code&gt;. If not caught, the &lt;code&gt;die&lt;/code&gt; becomes a fatal error.</source>
          <target state="translated">キャッチされない&lt;b&gt;例外&lt;/b&gt;。これにより、&lt;b&gt;標準エラー&lt;/b&gt;ストリームにメッセージを出力した後に&lt;b&gt;プロセス&lt;/b&gt;が終了します。 &lt;code&gt;eval&lt;/code&gt; 内で発生するエラーは致命的ではありません。代わりに、 &lt;code&gt;$@&lt;/code&gt; （ &lt;code&gt;$EVAL_ERROR&lt;/code&gt; ）変数に例外メッセージを配置した後、 &lt;code&gt;eval&lt;/code&gt; は終了します。 &lt;code&gt;die&lt;/code&gt; 演算子を使用して致命的なエラー（例外のスローまたは発生と呼ばれる）を引き起こそうとすることができますが、これは動的に囲む &lt;code&gt;eval&lt;/code&gt; によってキャッチされる可能性があります。キャッチされない場合、 &lt;code&gt;die&lt;/code&gt; は致命的なエラーになります。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fe98c7b5bde8acca47b9d777c6042909674e86b2" translate="yes" xml:space="preserve">
          <source>An unclosed formatting code</source>
          <target state="translated">閉じられていないフォーマットコード</target>
        </trans-unit>
        <trans-unit id="96b48446507c5be16337d09d4b16f13d55933f7d" translate="yes" xml:space="preserve">
          <source>An undefined $port argument is taken as zero; an undefined $ip6_address is considered a fatal error.</source>
          <target state="translated">未定義の $port 引数はゼロとして扱われ、未定義の $ip6_address は致命的なエラーとみなされます。</target>
        </trans-unit>
        <trans-unit id="3f9293e352420d9fd32f5883ba4908461fd77eae" translate="yes" xml:space="preserve">
          <source>An undefined $port argument is taken as zero; an undefined $ip_address is considered a fatal error.</source>
          <target state="translated">未定義の $port 引数はゼロとして扱われ、未定義の $ip_address は致命的なエラーとみなされます。</target>
        </trans-unit>
        <trans-unit id="54365bc1044b88eb77fbf7f1b4c0664f5bcb036c" translate="yes" xml:space="preserve">
          <source>An undefined value is not permitted as a record separator. Perl's special &quot;paragraph mode&quot; semantics (&amp;agrave; la &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt; ) are not emulated.</source>
          <target state="translated">未定義の値は、レコードセパレータとして使用できません。Perlの特別な「段落モード」セマンティクス（&amp;agrave; &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt; ）はエミュレートされません。</target>
        </trans-unit>
        <trans-unit id="0407455390a08706db99e80a71be456dbdff3c3e" translate="yes" xml:space="preserve">
          <source>An undefined value is not permitted as a record separator. Perl's special &quot;paragraph mode&quot; semantics (&amp;agrave; la &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt;) are not emulated.</source>
          <target state="translated">未定義の値は、レコード区切り文字として使用できません。Perlの特別な「段落モード」セマンティクス（&amp;agrave;la &lt;code&gt;$/ = &quot;&quot;&lt;/code&gt; ）はエミュレートされません。</target>
        </trans-unit>
        <trans-unit id="b64166e760d6e4e08cfb550598a86717021fc931" translate="yes" xml:space="preserve">
          <source>An unnamed list of temporary scalar values that may be passed around within a program from any list-generating function to any function or construct that provides a &lt;b&gt;list context&lt;/b&gt;.</source>
          <target state="translated">プログラム内でリスト生成関数から&lt;b&gt;リストコンテキスト&lt;/b&gt;を提供する関数または構造体に渡される一時的なスカラー値の名前のないリスト。</target>
        </trans-unit>
        <trans-unit id="b7a4ac1dececd2f0138b0d9e87eae14a3bf0f323" translate="yes" xml:space="preserve">
          <source>An unordered association of &lt;b&gt;key&lt;/b&gt;/&lt;b&gt;value&lt;/b&gt; pairs, stored such that you can easily use a string &lt;b&gt;key&lt;/b&gt; to look up its associated data &lt;b&gt;value&lt;/b&gt;. This glossary is like a hash, where the word to be defined is the key and the definition is the value. A hash is also sometimes septisyllabically called an &amp;ldquo;associative array&amp;rdquo;, which is a pretty good reason for simply calling it a &amp;ldquo;hash&amp;rdquo; instead.</source>
          <target state="translated">順不同関連&lt;b&gt;のキー&lt;/b&gt; / &lt;b&gt;値&lt;/b&gt;ペア、あなたは簡単に文字列を使用できるように保存された&lt;b&gt;キーを&lt;/b&gt;その関連データのルックアップするために&lt;b&gt;値を&lt;/b&gt;。この用語集はハッシュのようなもので、定義する単語がキーで、定義が値です。ハッシュは、「連想配列」と呼ばれることもあります。これは、単に「ハッシュ」と呼ぶのに十分な理由です。</target>
        </trans-unit>
        <trans-unit id="b718389bf63428a7f7a0b8e8cfc5e0574b25619d" translate="yes" xml:space="preserve">
          <source>An unset or empty PERLIO is equivalent to the default set of layers for your platform; for example, &lt;code&gt;:unix:perlio&lt;/code&gt; on Unix-like systems and &lt;code&gt;:unix:crlf&lt;/code&gt; on Windows and other DOS-like systems.</source>
          <target state="translated">未設定または空のPERLIOは、プラットフォームのデフォルトのレイヤーセットと同等です。たとえば、 &lt;code&gt;:unix:perlio&lt;/code&gt; 上のシステムとUnixライクな &lt;code&gt;:unix:crlf&lt;/code&gt; Windowsやその他のDOSのようなシステムでは。</target>
        </trans-unit>
        <trans-unit id="1b2099e63b3baac079849a311cb94bc9726d2b6a" translate="yes" xml:space="preserve">
          <source>An unsigned byte.</source>
          <target state="translated">符号なしバイト。</target>
        </trans-unit>
        <trans-unit id="17f8abaddabc70c518443c4340875b6f3d1f87f6" translate="yes" xml:space="preserve">
          <source>An unsigned integer.</source>
          <target state="translated">符号なし整数。</target>
        </trans-unit>
        <trans-unit id="6dc9fd633e86a9f8c5100a5a45701b6dac466c39" translate="yes" xml:space="preserve">
          <source>An upgrade to the PA-RISC design, it shipped for many years in many different system.</source>
          <target state="translated">PA-RISCデザインへのアップグレードで、多くの異なるシステムで何年もの間出荷されました。</target>
        </trans-unit>
        <trans-unit id="05468cfd5e27b4298d95a71824d624b7c4dbc8a7" translate="yes" xml:space="preserve">
          <source>An xV that is visible at the Perl level should not become unreferenced and thus be destroyed. Normally, an object will only become unreferenced when it is no longer visible, often by the same means that makes it invisible. For example, a Perl reference value (RV) owns a reference to its referent, so if the RV is overwritten that reference gets destroyed, and the no-longer-reachable referent may be destroyed as a result.</source>
          <target state="translated">Perl レベルで可視化されている xV は参照されなくなり、破棄されるべきではありません。通常、オブジェクトが参照されなくなるのは、オブジェクトが見えなくなったときだけで、多くの場合、それを見えなくするのと同じ手段で参照されなくなります。例えば、Perl の参照値 (RV)はその参照先への参照を所有しているので、RV が上書きされた場合、その参照は破棄され、その結果、もはや到達不可能な参照先は破棄されるかもしれません。</target>
        </trans-unit>
        <trans-unit id="abd7bedc3ca5ffad7ed1a2379448571632c9a196" translate="yes" xml:space="preserve">
          <source>Analogously to &lt;code&gt;pTHX&lt;/code&gt; , there are equivalent forms for when the macro is the first or last in multiple arguments, where an underscore represents a comma, i.e. &lt;code&gt;_aMY_CXT&lt;/code&gt; , &lt;code&gt;aMY_CXT_&lt;/code&gt; , &lt;code&gt;_pMY_CXT&lt;/code&gt; and &lt;code&gt;pMY_CXT_&lt;/code&gt; .</source>
          <target state="translated">同様に &lt;code&gt;pTHX&lt;/code&gt; 、マクロは、最初または最後の複数の引数で、下線がカンマを表し、すなわちである場合の等価形態がある &lt;code&gt;_aMY_CXT&lt;/code&gt; 、 &lt;code&gt;aMY_CXT_&lt;/code&gt; 、 &lt;code&gt;_pMY_CXT&lt;/code&gt; と &lt;code&gt;pMY_CXT_&lt;/code&gt; は。</target>
        </trans-unit>
        <trans-unit id="39d947054eb91fd720a6dfc1c92ebab2af540974" translate="yes" xml:space="preserve">
          <source>Analogously to &lt;code&gt;pTHX&lt;/code&gt;, there are equivalent forms for when the macro is the first or last in multiple arguments, where an underscore represents a comma, i.e. &lt;code&gt;_aMY_CXT&lt;/code&gt;, &lt;code&gt;aMY_CXT_&lt;/code&gt;, &lt;code&gt;_pMY_CXT&lt;/code&gt; and &lt;code&gt;pMY_CXT_&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pTHX&lt;/code&gt; と同様に、マクロが複数の引数の最初または最後である場合と同等の形式があります。アンダースコアはコンマを表します。つまり、 &lt;code&gt;aMY_CXT_&lt;/code&gt; 、 &lt;code&gt;_pMY_CXT&lt;/code&gt; &lt;code&gt;_aMY_CXT&lt;/code&gt; 、_ pMY_CXT、および &lt;code&gt;pMY_CXT_&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="edf45b9159d8cf5fded0f359396c02baabcce4fe" translate="yes" xml:space="preserve">
          <source>Analyses the string in order to make fast searches on it using fbm_instr() -- the Boyer-Moore algorithm.</source>
          <target state="translated">fbm_instr()--Boyer-Moore アルゴリズムを使用して高速に検索するために文字列を解析します。</target>
        </trans-unit>
        <trans-unit id="69b405aab620184a43024659654fa4b84c6160c1" translate="yes" xml:space="preserve">
          <source>Analyzes the string in order to make fast searches on it using &lt;code&gt;fbm_instr()&lt;/code&gt; -- the Boyer-Moore algorithm.</source>
          <target state="translated">ボイヤームーアアルゴリズムである &lt;code&gt;fbm_instr()&lt;/code&gt; を使用して文字列を高速検索するために、文字列を分析します。</target>
        </trans-unit>
        <trans-unit id="b23a158b83cb28ac3361aeaadb0ea701f833add8" translate="yes" xml:space="preserve">
          <source>Anantha Kesari H Y (hyanantha@novell.com) Aditya C (caditya@novell.com)</source>
          <target state="translated">Anantha Kesari H Y (hyanantha@novell.com)Aditya C (caditya@novell.com)</target>
        </trans-unit>
        <trans-unit id="e7694709c56de3564de85fb7f6b62bf3f9d5a2dd" translate="yes" xml:space="preserve">
          <source>Anatomy of .xs file</source>
          <target state="translated">.xsファイルの解剖学</target>
        </trans-unit>
        <trans-unit id="c371090fde9f09dd68fd0c025b019139f11c3b43" translate="yes" xml:space="preserve">
          <source>Anatomy of a typemap</source>
          <target state="translated">タイプマップの構造</target>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="126b187e44894c18f8676c982d3d84ada9d1092e" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; supports odd bit counts:</source>
          <target state="translated">また、&lt;a href=&quot;Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt;は奇数ビットカウントをサポートしています：</target>
        </trans-unit>
        <trans-unit id="56126a3ba8ff8d615bfc883458ff2ad74c4445f8" translate="yes" xml:space="preserve">
          <source>And &lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit::Vector&lt;/a&gt; supports odd bit counts:</source>
          <target state="translated">また、&lt;a href=&quot;http://search.cpan.org/perldoc/Bit::Vector&quot;&gt;Bit :: Vector&lt;/a&gt;は奇数のビット数をサポートしています。</target>
        </trans-unit>
        <trans-unit id="0fdb46cc394058268f8370b027acd6f7507ad5af" translate="yes" xml:space="preserve">
          <source>And a print to show what values we're currently using:</source>
          <target state="translated">そして、現在使用している値を示すプリント。</target>
        </trans-unit>
        <trans-unit id="3e6cfdab3639e924ccc0236d51702eea17278fbe" translate="yes" xml:space="preserve">
          <source>And add the following code to Mytest.t, while incrementing the &quot;11&quot; tests to &quot;13&quot;:</source>
          <target state="translated">そして、「11」のテストを「13」にインクリメントしながら、以下のコードをMytest.tに追加します。</target>
        </trans-unit>
        <trans-unit id="7e934152fc5094b95aee4b1e3cfca4dfe3b716a5" translate="yes" xml:space="preserve">
          <source>And also add the following function definition to the end of the .xs file:</source>
          <target state="translated">また、.xsファイルの最後に以下の関数定義を追加します。</target>
        </trans-unit>
        <trans-unit id="e095a5f2bc9f3ebef8eb601baecde5aacc183619" translate="yes" xml:space="preserve">
          <source>And an even parity bit can be determined like this:</source>
          <target state="translated">そして、偶数パリティビットは、このように決定することができます。</target>
        </trans-unit>
        <trans-unit id="fa65fe1d258f3efe5fa4b14f6a4bdf869e0bca12" translate="yes" xml:space="preserve">
          <source>And don't forget, all commands but &lt;code&gt;=encoding&lt;/code&gt; last up until the end of its</source>
          <target state="translated">そして忘れないでください、 &lt;code&gt;=encoding&lt;/code&gt; を除くすべてのコマンドは、その最後まで続きます</target>
        </trans-unit>
        <trans-unit id="d49f8a3fb63a02de3bc96673eb479046741fcd21" translate="yes" xml:space="preserve">
          <source>And elsewhere:</source>
          <target state="translated">他の場所でも</target>
        </trans-unit>
        <trans-unit id="81cb3b2a1b531c9a6c9a5580cd54769bc7cdb329" translate="yes" xml:space="preserve">
          <source>And especially its subject 8.</source>
          <target state="translated">そして、特にその主題8。</target>
        </trans-unit>
        <trans-unit id="0d86ebfaa42125fcbf7621caf9b51d0d516488b0" translate="yes" xml:space="preserve">
          <source>And even if you take all the above into account, ANSI still lets this:</source>
          <target state="translated">そして、あなたが上記のすべてを考慮に入れても、ANSIはまだこれを許可します。</target>
        </trans-unit>
        <trans-unit id="7a24c6f39dbf571ec01b5431e8552ecca7394253" translate="yes" xml:space="preserve">
          <source>And finally create a file Makefile.PL that looks like this:</source>
          <target state="translated">そして最後にこのようなMakefile.PLというファイルを作成します。</target>
        </trans-unit>
        <trans-unit id="ae77b129ec8a4042483f52a6f594546db002727e" translate="yes" xml:space="preserve">
          <source>And finally we'll test that we don't make Unicode strings if &lt;code&gt;U&lt;/code&gt; is &lt;b&gt;not&lt;/b&gt; the first active format:</source>
          <target state="translated">最後に、 &lt;code&gt;U&lt;/code&gt; が最初のアクティブな形式で&lt;b&gt;ない&lt;/b&gt;場合は、Unicode文字列を作成しないことをテストします。</target>
        </trans-unit>
        <trans-unit id="a3e1249d44e165c645bd656a34581eba0f8a1e5b" translate="yes" xml:space="preserve">
          <source>And finally, END OF CHARMAP ends the section.</source>
          <target state="translated">そして最後にEND OF CHARMAPでセクションが終了します。</target>
        </trans-unit>
        <trans-unit id="2d457e986a9ae5a62a56559cd5a194f65f8d8696" translate="yes" xml:space="preserve">
          <source>And finally, in list context, it will try to extract as many objects from the stream as it can find and return them, or the empty list otherwise. For this to work, there must be no separators (other than whitespace) between the JSON objects or arrays, instead they must be concatenated back-to-back. If an error occurs, an exception will be raised as in the scalar context case. Note that in this case, any previously-parsed JSON texts will be lost.</source>
          <target state="translated">そして最後に、リストコンテキストでは、ストリームから見つけられるだけ多くのオブジェクトを抽出してそれを返すか、そうでなければ空のリストを返します。これが動作するためには、JSON オブジェクトや配列の間には (空白以外の)セパレータを入れてはいけません。エラーが発生した場合は、スカラコンテキストの場合と同様に例外が発生します。この場合、以前にパースされた JSON テキストはすべて失われることに注意してください。</target>
        </trans-unit>
        <trans-unit id="0fa08a28d9fbfd1e04544d3cbe387157894102ef" translate="yes" xml:space="preserve">
          <source>And finally, the &lt;code&gt;//&lt;/code&gt; default delimiters for a match can be changed to arbitrary delimiters by putting an &lt;code&gt;'m'&lt;/code&gt; out front:</source>
          <target state="translated">そして最後に、 &lt;code&gt;//&lt;/code&gt; マッチのデフォルトの区切り文字は、 &lt;code&gt;'m'&lt;/code&gt; を前に置くことで任意の区切り文字に変更できます。</target>
        </trans-unit>
        <trans-unit id="8bfb479933b19ce9cc3cdcd7ea52e1ab56622323" translate="yes" xml:space="preserve">
          <source>And finally, the flag UNICODE_WARN_ILLEGAL_INTERCHANGE selects all four of the above WARN flags; and UNICODE_DISALLOW_ILLEGAL_INTERCHANGE selects all four DISALLOW flags.</source>
          <target state="translated">そして最後に、UNICODE_WARN_ILLEGAL_INTERCHANGEフラグは、上記のWARNフラグの4つすべてを選択し、UNICODE_DISALLOW_ILLEGAL_INTERCHANGEフラグは、4つのDISALLOWフラグのすべてを選択する。</target>
        </trans-unit>
        <trans-unit id="805a895ac4ae294cb6372936f60badec42431ba0" translate="yes" xml:space="preserve">
          <source>And get the correct results.</source>
          <target state="translated">そして、正しい結果を得る。</target>
        </trans-unit>
        <trans-unit id="e2f2205f3663f3c210b60bce452eee7ce9387b44" translate="yes" xml:space="preserve">
          <source>And have a look at the return value:</source>
          <target state="translated">そして、戻り値を見てみてください。</target>
        </trans-unit>
        <trans-unit id="fbc4c3241647a832011ec07f9650e675a0c500ca" translate="yes" xml:space="preserve">
          <source>And here are some alternative portable ways to write them:</source>
          <target state="translated">そして、ここでは、それらを書くための代替のポータブルな方法をいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="dd7d82addca3d88c7a2654bf3c9e6dcef14475a8" translate="yes" xml:space="preserve">
          <source>And here is an example of</source>
          <target state="translated">そして、ここではその一例として</target>
        </trans-unit>
        <trans-unit id="d607f0d907db7da1691c33f97b8d6b2f2769c71d" translate="yes" xml:space="preserve">
          <source>And here is some Perl to test it.</source>
          <target state="translated">そして、それをテストするためのPerlがここにあります。</target>
        </trans-unit>
        <trans-unit id="eae54ac5b1d17fae865a39da8414bc4e94611b48" translate="yes" xml:space="preserve">
          <source>And here is the function from</source>
          <target state="translated">そして、ここからの関数は</target>
        </trans-unit>
        <trans-unit id="97a015e04d33b93191e1790b436d13c5a1d0ec08" translate="yes" xml:space="preserve">
          <source>And here is the previous example modified to use the &lt;code&gt;comment&lt;/code&gt; method (which requires the tied object):</source>
          <target state="translated">そして、これは、 &lt;code&gt;comment&lt;/code&gt; メソッドを使用するように変更された前の例です（tieオブジェクトが必要です）。</target>
        </trans-unit>
        <trans-unit id="949c884471ed5b1d107f6efb48c3d4a2b28f9c98" translate="yes" xml:space="preserve">
          <source>And here it is as a subroutine, modeled after the above:</source>
          <target state="translated">そして、ここでは、上記をモデルにしたサブルーチンです。</target>
        </trans-unit>
        <trans-unit id="33110031311636694f867a410fcd13fa8bb80c0c" translate="yes" xml:space="preserve">
          <source>And here's a corresponding server to go along with it. We'll leave the address as &lt;code&gt;INADDR_ANY&lt;/code&gt; so that the kernel can choose the appropriate interface on multihomed hosts. If you want sit on a particular interface (like the external side of a gateway or firewall machine), fill this in with your real address instead.</source>
          <target state="translated">そして、それに対応する対応するサーバーがあります。カーネルがマルチホームホスト上の適切なインターフェイスを選択できるように、アドレスを &lt;code&gt;INADDR_ANY&lt;/code&gt; のままにします。特定のインターフェース（ゲートウェイやファイアウォールマシンの外部側など）を使用する場合は、代わりに実際のアドレスを入力します。</target>
        </trans-unit>
        <trans-unit id="dbd6a4af2108db6ae982ecf10d7522ed7e526a16" translate="yes" xml:space="preserve">
          <source>And here's a corresponding server. You don't have to worry about silly network terminators here because Unix domain sockets are guaranteed to be on the localhost, and thus everything works right.</source>
          <target state="translated">そして、これが対応するサーバです。Unix ドメインソケットはローカルホスト上にあることが保証されているので、 ここでは愚かなネットワークターミネータを心配する必要はありません。</target>
        </trans-unit>
        <trans-unit id="944b5652f25ab675361c7efd6d5681a5765fc752" translate="yes" xml:space="preserve">
          <source>And here's a multitasking version. It's multitasked in that like most typical servers, it spawns (fork()s) a slave server to handle the client request so that the master server can quickly go back to service a new client.</source>
          <target state="translated">そして、これはマルチタスク版です。これはマルチタスク版で、ほとんどの典型的なサーバと同様に、クライアントのリクエストを処理するためにスレーブサーバを生成 (fork()します)して、マスターサーバがすぐに新しいクライアントにサービスを提供できるようにします。</target>
        </trans-unit>
        <trans-unit id="412d21e904b4a5d9be299f9e46dd7d8fb8650015" translate="yes" xml:space="preserve">
          <source>And here's a reimplementation of the Perl &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; operator:</source>
          <target state="translated">そして、Perl &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; オペレーターの再実装を以下に示します。</target>
        </trans-unit>
        <trans-unit id="328ddc059366c7b26584066902e71a55942bcb50" translate="yes" xml:space="preserve">
          <source>And here's a reimplementation of the Perl &lt;code&gt;grep&lt;/code&gt; operator:</source>
          <target state="translated">そして、これが &lt;code&gt;grep&lt;/code&gt; 演算子の再実装です。</target>
        </trans-unit>
        <trans-unit id="a39e0321aadc55f074a271968aaa41d7162f8c6f" translate="yes" xml:space="preserve">
          <source>And here's a safe pipe open for writing:</source>
          <target state="translated">そして、ここには書き込み用の安全なパイプが開いています。</target>
        </trans-unit>
        <trans-unit id="e0737e576532a52571f2f02f804f1b9fffb668de" translate="yes" xml:space="preserve">
          <source>And here's how it could be (ab)used:</source>
          <target state="translated">そして、このような使い方ができます。</target>
        </trans-unit>
        <trans-unit id="9d8d64c2d75cb873a59d78e68255422a53fcc02a" translate="yes" xml:space="preserve">
          <source>And here's how to start up a child process you intend to read from:</source>
          <target state="translated">そして、ここから読み解くつもりの子プロセスの立ち上げ方。</target>
        </trans-unit>
        <trans-unit id="4c941c96c3f11d53f1f07f2e00498b7a8046f1f0" translate="yes" xml:space="preserve">
          <source>And here's the &lt;code&gt;HotKey&lt;/code&gt; module, which hides the somewhat mystifying calls to manipulate the POSIX termios structures.</source>
          <target state="translated">そして、ここには &lt;code&gt;HotKey&lt;/code&gt; モジュールがあり、POSIX termios構造を操作するためのやや不可解な呼び出しを隠しています。</target>
        </trans-unit>
        <trans-unit id="c1de37a9a564348e268bb7765797260079df1212" translate="yes" xml:space="preserve">
          <source>And if it's an integer</source>
          <target state="translated">そして、整数であれば</target>
        </trans-unit>
        <trans-unit id="1e83d880ce4037fe2787ac7496582407c6b33838" translate="yes" xml:space="preserve">
          <source>And if the protocol you're using supports a way of letting the recipient know which character encoding you used, please help the receiving end by using that feature! For example, E-mail and HTTP support MIME headers, so you can use the &lt;code&gt;Content-Type&lt;/code&gt; header. They can also have &lt;code&gt;Content-Length&lt;/code&gt; to indicate the number of</source>
          <target state="translated">また、使用しているプロトコルが、使用した文字エンコードを受信者に知らせる方法をサポートしている場合は、その機能を使用して受信側を支援してください！たとえば、電子メールとHTTPはMIMEヘッダーをサポートしているため、 &lt;code&gt;Content-Type&lt;/code&gt; ヘッダーを使用できます。また、 &lt;code&gt;Content-Length&lt;/code&gt; を使用して、</target>
        </trans-unit>
        <trans-unit id="c041e6b2053eeffc72c3a76864ceba40caffea7d" translate="yes" xml:space="preserve">
          <source>And if you used &lt;code&gt;&quot;*&quot;&lt;/code&gt;'s in the internal groups instead of limiting them to 0 through 5 matches, then it would take forever--or until you ran out of stack space. Moreover, these internal optimizations are not always applicable. For example, if you put &lt;code&gt;{0,5}&lt;/code&gt; instead of &lt;code&gt;&quot;*&quot;&lt;/code&gt; on the external group, no current optimization is applicable, and the match takes a long time to finish.</source>
          <target state="translated">また、内部グループで &lt;code&gt;&quot;*&quot;&lt;/code&gt; を0から5の一致に制限するのではなく使用した場合、それは永遠に、またはスタックスペースが不足するまでかかります。さらに、これらの内部最適化は常に適用できるとは限りません。たとえば、外部グループに &lt;code&gt;&quot;*&quot;&lt;/code&gt; 代わりに &lt;code&gt;{0,5}&lt;/code&gt; を指定した場合、現在の最適化は適用されず、一致が完了するまでに長い時間がかかります。</target>
        </trans-unit>
        <trans-unit id="530bb41f401dd9a37c76bab8cac0844cf9ab82e0" translate="yes" xml:space="preserve">
          <source>And if you used &lt;code&gt;*&lt;/code&gt; 's in the internal groups instead of limiting them to 0 through 5 matches, then it would take forever--or until you ran out of stack space. Moreover, these internal optimizations are not always applicable. For example, if you put &lt;code&gt;{0,5}&lt;/code&gt; instead of &lt;code&gt;*&lt;/code&gt; on the external group, no current optimization is applicable, and the match takes a long time to finish.</source>
          <target state="translated">また、内部グループで &lt;code&gt;*&lt;/code&gt; を使用してそれらを0から5の一致に制限するのではなく、永久に、またはスタックスペースがなくなるまで使用します。さらに、これらの内部最適化は常に適用できるとは限りません。たとえば、外部グループに &lt;code&gt;*&lt;/code&gt; の代わりに &lt;code&gt;{0,5}&lt;/code&gt; を指定すると、現在の最適化は適用されず、一致が完了するまでに長い時間がかかります。</target>
        </trans-unit>
        <trans-unit id="85fb030d5b378f589d8d5a1abf4a0effa17a51ec" translate="yes" xml:space="preserve">
          <source>And if you want to repeat any previous command, use the exclamation: '&lt;b&gt;!&lt;/b&gt;':</source>
          <target state="translated">また、前のコマンドを繰り返す場合は、感嘆符を使用します&lt;b&gt;。&lt;/b&gt;'：</target>
        </trans-unit>
        <trans-unit id="e2e9c56949878c68d60537e13a0fee819e61a651" translate="yes" xml:space="preserve">
          <source>And if you want to update your remote-tracking branches for all defined remotes simultaneously you can do</source>
          <target state="translated">また、定義されているすべてのリモートのリモートトラッキングブランチを同時に更新したい場合は、以下のようにします。</target>
        </trans-unit>
        <trans-unit id="81ee0ae161979dc9986599ac47ae17f4297a5e95" translate="yes" xml:space="preserve">
          <source>And if you wanted to list line 5 again, type 'l 5', (note the space):</source>
          <target state="translated">そして、5行目をもう一度リストアップしたい場合は、'l 5'と入力します(スペースに注意)。</target>
        </trans-unit>
        <trans-unit id="749d2869c6a2cd1160d264bfc5684c9df865e407" translate="yes" xml:space="preserve">
          <source>And if you're not writing a formatter class, but are instead just writing a program that does something simple with a Pod::PullParser object (and not an object of a subclass), then there's no reason to bother subclassing to add a &lt;code&gt;run&lt;/code&gt; method.</source>
          <target state="translated">また、フォーマッタークラスではなく、Pod :: PullParserオブジェクト（サブクラスのオブジェクトではない）を使用して単純な処理を行うプログラムを作成している場合、 &lt;code&gt;run&lt;/code&gt; を追加するためにサブクラス化を行う必要はありません。方法。</target>
        </trans-unit>
        <trans-unit id="a90e884faa57a601f440de65c751d0540510d763" translate="yes" xml:space="preserve">
          <source>And in gdb do:</source>
          <target state="translated">そして、gdbでは。</target>
        </trans-unit>
        <trans-unit id="81cf331b9c5b31a88becd7901f7891213a4ee929" translate="yes" xml:space="preserve">
          <source>And in gdb:</source>
          <target state="translated">そしてgdbで。</target>
        </trans-unit>
        <trans-unit id="46441ba6d0d6e8d0a7cff3ad4e65de9157fcaa3a" translate="yes" xml:space="preserve">
          <source>And in the special case of Unix value 1 the encoding is:</source>
          <target state="translated">そして、Unix の値 1 の特殊なケースでは、エンコーディングは次のようになります。</target>
        </trans-unit>
        <trans-unit id="c703bcbb84cf0b00ade16c5fcf17098b7ecf2788" translate="yes" xml:space="preserve">
          <source>And it worked; nowadays, those legacy standards are rarely used. Most everyone uses Unicode.</source>
          <target state="translated">それが功を奏して、現在では、これらのレガシーな標準はほとんど使われていません。ほとんどの人がユニコードを使っています。</target>
        </trans-unit>
        <trans-unit id="54037314563b22510a39098497cd62d4a291d5ca" translate="yes" xml:space="preserve">
          <source>And it'll be faster, too, since we can begin processing the program's stdout immediately, rather than waiting for the program to finish.</source>
          <target state="translated">そして、プログラムの終了を待つよりも、すぐにプログラムの標準出力の処理を始めることができるので、こちらも早くなります。</target>
        </trans-unit>
        <trans-unit id="05b8d44f52c6cb1137bdef7406a03b86305390f3" translate="yes" xml:space="preserve">
          <source>And just before we start the loop, we'll set &lt;code&gt;patcopy&lt;/code&gt; to be the start of &lt;code&gt;pat&lt;/code&gt; :</source>
          <target state="translated">そして、ループを開始する直前に、 &lt;code&gt;patcopy&lt;/code&gt; を &lt;code&gt;pat&lt;/code&gt; の開始に設定します。</target>
        </trans-unit>
        <trans-unit id="1283b8c922466a3c7b07d1feee37151a4dce3090" translate="yes" xml:space="preserve">
          <source>And just before we start the loop, we'll set &lt;code&gt;patcopy&lt;/code&gt; to be the start of &lt;code&gt;pat&lt;/code&gt;:</source>
          <target state="translated">そして、ループを開始する直前に、 &lt;code&gt;patcopy&lt;/code&gt; を &lt;code&gt;pat&lt;/code&gt; の開始として設定します。</target>
        </trans-unit>
        <trans-unit id="5d9997bbf1b12f8dbc675ed04e53a7e01c218a79" translate="yes" xml:space="preserve">
          <source>And just use a multilevel hash to start with.</source>
          <target state="translated">そもそもマルチレベルハッシュを使えばいいんだよ</target>
        </trans-unit>
        <trans-unit id="6f762806ee86000a08af1e9120bb69dbd27df3b8" translate="yes" xml:space="preserve">
          <source>And let's have a look at it:</source>
          <target state="translated">そして、それを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="2fcd80e8aae7192e91938fbeb5e4135bca3cc513" translate="yes" xml:space="preserve">
          <source>And likewise, the &lt;code&gt;UNICODE_WARN_SUPER&lt;/code&gt; and &lt;code&gt;UNICODE_DISALLOW_SUPER&lt;/code&gt; flags affect the handling of code points that are above the Unicode maximum of 0x10FFFF. Languages other than Perl may not be able to accept files that contain these.</source>
          <target state="translated">同様に、 &lt;code&gt;UNICODE_WARN_SUPER&lt;/code&gt; フラグと &lt;code&gt;UNICODE_DISALLOW_SUPER&lt;/code&gt; フラグは、Unicodeの最大値である0x10FFFFを超えるコードポイントの処理に影響を与えます。Perl以外の言語は、これらを含むファイルを受け入れることができない場合があります。</target>
        </trans-unit>
        <trans-unit id="3304a768e2182435437e989432d9119802e93fc2" translate="yes" xml:space="preserve">
          <source>And locally for months:</source>
          <target state="translated">そして地元では数ヶ月間。</target>
        </trans-unit>
        <trans-unit id="a3a5e5aaccae80b6482e3c73484c3e27d16e3695" translate="yes" xml:space="preserve">
          <source>And make sure the '|1' or '|3' entry FOLLOWS the '|0' entry.</source>
          <target state="translated">また、'|1'または'|3'の項目が'|0'の項目に続いていることを確認してください。</target>
        </trans-unit>
        <trans-unit id="13b0bb554f54abc8fbffc8c8994d2d663c4a335c" translate="yes" xml:space="preserve">
          <source>And make the &lt;code&gt;SHELL&lt;/code&gt; environment variable point to this</source>
          <target state="translated">そして、 &lt;code&gt;SHELL&lt;/code&gt; 環境変数がこれを指すようにします</target>
        </trans-unit>
        <trans-unit id="be7020a4d943fe59e561bee80058c6fdc65ab9a2" translate="yes" xml:space="preserve">
          <source>And more miscellaneous functions:</source>
          <target state="translated">さらに雑多な機能も。</target>
        </trans-unit>
        <trans-unit id="a60081f8386184766dad1be5fdc437aa5eeeb0e1" translate="yes" xml:space="preserve">
          <source>And note that unlike the first example, this will permanently set &lt;code&gt;$^W&lt;/code&gt; since it cannot both run during compile-time and be localized to a run-time block.</source>
          <target state="translated">また、最初の例とは異なり、コンパイル時に実行することも、実行時ブロックにローカライズすることもできないため、これは永続的に &lt;code&gt;$^W&lt;/code&gt; 設定することに注意してください。</target>
        </trans-unit>
        <trans-unit id="804a1ae29f0ee92582bcfc8bf24a3ed82f77d6d1" translate="yes" xml:space="preserve">
          <source>And note, that some items returned by &lt;code&gt;Localeconv&lt;/code&gt; are available through &lt;a href=&quot;perlapi#Perl_langinfo&quot;&gt;&quot;Perl_langinfo&quot; in perlapi&lt;/a&gt;.</source>
          <target state="translated">また、 &lt;code&gt;Localeconv&lt;/code&gt; によって返される一部のアイテムは&lt;a href=&quot;perlapi#Perl_langinfo&quot;&gt;、perlapiの「Perl_langinfo」&lt;/a&gt;から入手できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="d2abac4d1c06c7d4176cadc5fbb88490348f44bd" translate="yes" xml:space="preserve">
          <source>And now some examples as a list operator:</source>
          <target state="translated">そして、リスト演算子としての例をいくつか挙げてみました。</target>
        </trans-unit>
        <trans-unit id="325f253298d4946260db0eee17abb5d004c58cf0" translate="yes" xml:space="preserve">
          <source>And now the Perl program calling &lt;code&gt;tzname&lt;/code&gt; , the two values will be assigned as in:</source>
          <target state="translated">そして今、Perlプログラムが &lt;code&gt;tzname&lt;/code&gt; を呼び出すと、2つの値が次のように割り当てられます。</target>
        </trans-unit>
        <trans-unit id="f59e966510e8c065dbf5dc3f3cc9146205ad5af4" translate="yes" xml:space="preserve">
          <source>And now the Perl program calling &lt;code&gt;tzname&lt;/code&gt;, the two values will be assigned as in:</source>
          <target state="translated">そして、 &lt;code&gt;tzname&lt;/code&gt; を呼び出すPerlプログラムでは、2つの値が次のように割り当てられます。</target>
        </trans-unit>
        <trans-unit id="22d6d0f0cc9d0f09a7a155f9b933e949a3d93b8d" translate="yes" xml:space="preserve">
          <source>And now when we run it, we get &quot;\n&quot; still, but at least we know why. Just getting this script to compile has exposed the '$varl' (with the letter 'l') variable, and simply changing $varl to $var1 solves the problem.</source>
          <target state="translated">そして、実行すると、まだ &quot;\n&quot; が出てきますが、少なくとも理由はわかっています。このスクリプトをコンパイルするだけで、変数 '$varl'('l' の文字が入っている)が公開されてしまい、$varl を $var1 に変更するだけで問題が解決します。</target>
        </trans-unit>
        <trans-unit id="5ed144a58c9fd20df52c8636158ebb39098e1299" translate="yes" xml:space="preserve">
          <source>And now whenever either of those variables is accessed, its current system priority is retrieved and returned. If those variables are set, then the process's priority is changed!</source>
          <target state="translated">そして、これらの変数のいずれかがアクセスされたときはいつでも、その現在のシステムの優先度が取得されて返されます。これらの変数が設定されている場合、プロセスの優先度が変更されます!</target>
        </trans-unit>
        <trans-unit id="f9560789fd59b77ec60e56d7ede2c768c8b84e1a" translate="yes" xml:space="preserve">
          <source>And now you will only have duplicates when the keys themselves are truly the same. (note: in versions of the db library prior to about November 1996, such duplicate keys were retained so it was possible to recover the original keys in sets of keys that compared as equal).</source>
          <target state="translated">これで、キー自体が本当に同じである場合にのみ、複製を作成することができるようになりました。(注:1996年11月以前のバージョンのdbライブラリでは、このような重複したキーは保持されていたので、同じように比較されたキーのセットで元のキーを復元することが可能でした。)</target>
        </trans-unit>
        <trans-unit id="5a5750ab899553015c34706ef7f35d79aa761c9c" translate="yes" xml:space="preserve">
          <source>And of course a very basic test:</source>
          <target state="translated">もちろん基礎的なテストも</target>
        </trans-unit>
        <trans-unit id="892ba36b3022eacc3edbb4c21af99c36c593d715" translate="yes" xml:space="preserve">
          <source>And on the off chance you need a literal tilde in a bracket expression, you get it with &quot;~~&quot;.</source>
          <target state="translated">また、大括弧表現の中でリテラルチルダが必要な場合は、&quot;~~&quot;を使用します。</target>
        </trans-unit>
        <trans-unit id="7c31eaf7ebf6ce5c72185594ad0e1b74e04b6fe1" translate="yes" xml:space="preserve">
          <source>And only on Solaris 8 you also need:</source>
          <target state="translated">また、Solaris 8 でのみ必要となります。</target>
        </trans-unit>
        <trans-unit id="15fba9c4eb39007661b94becfb32901d56aa6cd3" translate="yes" xml:space="preserve">
          <source>And only the last two of these match:</source>
          <target state="translated">そして、この中で最後の2つだけがマッチしています。</target>
        </trans-unit>
        <trans-unit id="96df95971f3fa6b1c473a349d8884984b667322b" translate="yes" xml:space="preserve">
          <source>And other assignment variations are analogous to &lt;code&gt;'+='&lt;/code&gt; and &lt;code&gt;'-='&lt;/code&gt; (and similar to &lt;code&gt;'.='&lt;/code&gt; and &lt;code&gt;'x='&lt;/code&gt; above):</source>
          <target state="translated">その他の割り当てのバリエーションは、 &lt;code&gt;'+='&lt;/code&gt; および &lt;code&gt;'-='&lt;/code&gt; 類似しています（上記の &lt;code&gt;'.='&lt;/code&gt; および &lt;code&gt;'x='&lt;/code&gt; 類似しています）。</target>
        </trans-unit>
        <trans-unit id="efa161d50be827f153878be8fe5d6eeddd3f9aab" translate="yes" xml:space="preserve">
          <source>And perhaps most importantly, keep the items consistent: either use &quot;=item *&quot; for all of them, to produce bullets; or use &quot;=item 1.&quot;, &quot;=item 2.&quot;, etc., to produce numbered lists; or use &quot;=item foo&quot;, &quot;=item bar&quot;, etc.--namely, things that look nothing like bullets or numbers.</source>
          <target state="translated">そしておそらく最も重要なことは、項目を一貫性のあるものに保つことです:弾丸を生成するために、それらのすべてに&quot;=item *&quot;を使用するか、または番号付きリストを生成するために&quot;=item 1.&quot;,&quot;=item 2.&quot;,などを使用します。</target>
        </trans-unit>
        <trans-unit id="ac0a1fd097b0dfd986a143395713cf6857292218" translate="yes" xml:space="preserve">
          <source>And perhaps most importantly, keep the items consistent: either use &quot;=item *&quot; for all of them, to produce bullets; or use &quot;=item 1.&quot;, &quot;=item 2.&quot;, etc., to produce numbered lists; or use &quot;=item foo&quot;, &quot;=item bar&quot;, etc.--namely, things that look nothing like bullets or numbers. (If you have a list that contains both: 1) things that don't look like bullets nor numbers, plus 2) things that do, you should preface the bullet- or number-like items with &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt;. See &lt;a href=&quot;#Z%3C%3E-a-null-%28zero-effect%29-formatting-code&quot;&gt;Z&amp;lt;&amp;gt;&lt;/a&gt; below for an example.)</source>
          <target state="translated">そしておそらく最も重要なことは、アイテムの一貫性を保つことです。すべてのアイテムに「= item *」を使用して、弾丸を作成します。または、「= item 1。」、「= item 2.」などを使用して、番号付きリストを作成します。または、「= item foo」、「= item bar」などを使用します。つまり、箇条書きや数字のように見えないものを使用します。 （次の両方を含むリストがある場合：1）弾丸や数字のように見えないもの、および2）あるものの場合、弾丸または数字のようなアイテムの前に &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; を付ける必要があります。例については、以下の&lt;a href=&quot;#Z%3C%3E-a-null-%28zero-effect%29-formatting-code&quot;&gt;Z &amp;lt;&amp;gt;を&lt;/a&gt;参照してください。）</target>
        </trans-unit>
        <trans-unit id="b837400890ba807a5f5e88629d11f36f624c30a2" translate="yes" xml:space="preserve">
          <source>And pull new changes from the repository, and update your local repository (must be clean first)</source>
          <target state="translated">そして、リポジトリから新しい変更を引っ張ってきて、ローカルリポジトリを更新します(最初にクリーンでなければなりません)</target>
        </trans-unit>
        <trans-unit id="3abab37034be7516f5a858adebbbb45b8ced8395" translate="yes" xml:space="preserve">
          <source>And push the branch to your fork:</source>
          <target state="translated">そして、枝をフォークに押し付ける。</target>
        </trans-unit>
        <trans-unit id="f91e4f8b7302927647ddce5513c00f7d31bca99b" translate="yes" xml:space="preserve">
          <source>And since we're on that subject ...</source>
          <target state="translated">そして、私たちは、その話題をしているので...</target>
        </trans-unit>
        <trans-unit id="787438686ae95a1032fa3a9e1aa177c6c4fd8565" translate="yes" xml:space="preserve">
          <source>And so do these:</source>
          <target state="translated">これもそうだ</target>
        </trans-unit>
        <trans-unit id="d57613d3e5e04fb527cb785d3cbc34d0addd45d8" translate="yes" xml:space="preserve">
          <source>And some of the entries are marked as &quot;undocumented&quot;. This means that they aren't necessarily considered stable, and could be changed or removed in some future release without warning. It is therefore a bad idea to use them without further checking. It could be that these are considered to be for perl core use only; or it could be, though, that &lt;code&gt;Devel::PPPort&lt;/code&gt; doesn't know where to find their documentation, or that it's just an oversight that they haven't been documented. If you want to use one, and potentially have it backported, first send mail to &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;mailto:perl5-porters@perl.org&lt;/a&gt;.</source>
          <target state="translated">また、一部のエントリは「文書化されていない」とマークされています。これは、必ずしも安定しているとは見なされず、将来のリリースで警告なしに変更または削除される可能性があることを意味します。したがって、これ以上チェックせずに使用することはお勧めできません。これらはperlコアでの使用のみを目的としていると考えられている可能性があります。または、 &lt;code&gt;Devel::PPPort&lt;/code&gt; がドキュメントの場所を知らないか、ドキュメント化されていないのは単なる見落としである可能性があります。使用したい場合で、バックポートされる可能性がある場合は、最初に&lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;mailto：perl5-porters@perl.orgに&lt;/a&gt;メールを送信してください。</target>
        </trans-unit>
        <trans-unit id="58a765d6600ae95d5f3b4bad120d6d7aba62ac6d" translate="yes" xml:space="preserve">
          <source>And success is always the value 0 in all behaviors.</source>
          <target state="translated">そして、成功はすべての行動において常に値0である。</target>
        </trans-unit>
        <trans-unit id="438bed71f720bad1480f9f02fbee09a0688495fa" translate="yes" xml:space="preserve">
          <source>And suppose then that you answer client requests for language $wanted by just looking up $greetings{$wanted}.</source>
          <target state="translated">そして、$wanted言語に対するクライアントからのリクエストに、 $greetings{$wanted}を検索するだけで答えられるとします。</target>
        </trans-unit>
        <trans-unit id="2669b5893403010caa914594080405bbbce0ff5c" translate="yes" xml:space="preserve">
          <source>And suppose you write a program that reads that file and then runs as a daemon, answering client requests that specify a language tag and then expect the string that says how to greet in that language. So an interaction looks like:</source>
          <target state="translated">そして、そのファイルを読み込んでデーモンとして実行するプログラムを書いたとしましょう。言語タグを指定したクライアントからのリクエストに答え、その言語での挨拶の仕方を示す文字列を期待します。インタラクションは次のようになります。</target>
        </trans-unit>
        <trans-unit id="2df99fba715f8ad036f73439b0d1c572a25bb0d8" translate="yes" xml:space="preserve">
          <source>And that does the Right Thing.</source>
          <target state="translated">それが正しいことだ</target>
        </trans-unit>
        <trans-unit id="f185ef04d67f1d1642dde1d5aaeb827268181df4" translate="yes" xml:space="preserve">
          <source>And that's where the first quirk strikes: &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; templates have to be stuffed with &lt;code&gt;x&lt;/code&gt; codes to get those extra fill bytes.</source>
          <target state="translated">そして、それが最初の奇妙なところです： &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; テンプレートは、それらの余分なフィルバイトを取得するために &lt;code&gt;x&lt;/code&gt; コードを詰め込む必要があります。</target>
        </trans-unit>
        <trans-unit id="faa61c2d15a96573c75e47bc47738ee4332bd44e" translate="yes" xml:space="preserve">
          <source>And that's where the first quirk strikes: &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; templates have to be stuffed with &lt;code&gt;x&lt;/code&gt; codes to get those extra fill bytes.</source>
          <target state="translated">そして、それが最初の癖が発生する場所です。これらの余分なフィルバイトを取得するには、テンプレートの &lt;code&gt;pack&lt;/code&gt; と &lt;code&gt;unpack&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; コードを詰める必要があります。</target>
        </trans-unit>
        <trans-unit id="1c2e146487dcd6b006ca0fe732ee06c5f66c58a6" translate="yes" xml:space="preserve">
          <source>And the &lt;code&gt;*&lt;/code&gt; quantifier (or its equivalent &lt;code&gt;(0,}&lt;/code&gt;) is illegal.</source>
          <target state="translated">また、 &lt;code&gt;*&lt;/code&gt; 数量詞（またはそれに相当する &lt;code&gt;(0,}&lt;/code&gt; ）は不正です。</target>
        </trans-unit>
        <trans-unit id="69c7d2fddd9456e1d45eb87fbe318da0c23d0419" translate="yes" xml:space="preserve">
          <source>And the removal of:</source>
          <target state="translated">撤去も</target>
        </trans-unit>
        <trans-unit id="6321b918eecf63aae95252ec27d4a4007661cbea" translate="yes" xml:space="preserve">
          <source>And then at least you can use the values(), which will be real refs, instead of the keys(), which won't.</source>
          <target state="translated">そうすれば、少なくとも実際の参照となる values()を使うことができるようになります。</target>
        </trans-unit>
        <trans-unit id="4c721f20845157aa106a3ca5329f5d50475f12f2" translate="yes" xml:space="preserve">
          <source>And then hard-code it, leaving porting as an exercise to your successor.</source>
          <target state="translated">そして、ハードコード化して、移植は後継者に任せる。</target>
        </trans-unit>
        <trans-unit id="47e6e2e5fec5f13213aa3c81c38b973ca1f59e41" translate="yes" xml:space="preserve">
          <source>And then instead of storing the compiled value in the lexicon hash it will store it in $lh-&amp;gt;{'_external_lex_cache'}</source>
          <target state="translated">そして、コンパイルされた値をレキシコンハッシュに保存する代わりに、$ lh-&amp;gt; {'_ external_lex_cache'}に保存します</target>
        </trans-unit>
        <trans-unit id="4ddb0364527af5ee5b5762f819c0ea16f6ac0a17" translate="yes" xml:space="preserve">
          <source>And then open as before, choosing &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; , or &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; as needed:</source>
          <target state="translated">次に、以前と同様に開き、必要に応じて &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 、または &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; を選択します。</target>
        </trans-unit>
        <trans-unit id="c1e2199a985f69bef0e671090e4f82d7d27c974b" translate="yes" xml:space="preserve">
          <source>And then open as before, choosing &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt;, &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt;, or &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; as needed:</source>
          <target state="translated">次に、前と同じように開き、必要に応じて &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; 、または &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; を選択します。</target>
        </trans-unit>
        <trans-unit id="733e92d2677896a5105fc9334a5547dcbabc4286" translate="yes" xml:space="preserve">
          <source>And then provide a typemap entry &lt;code&gt;T_PTROBJ_SPECIAL&lt;/code&gt; that maps underscores to double-colons (::), and declare &lt;code&gt;Net_Config&lt;/code&gt; to be of that type:</source>
          <target state="translated">次に、アンダースコアをダブルコロン（：:)にマップする &lt;code&gt;T_PTROBJ_SPECIAL&lt;/code&gt; マップエントリT_PTROBJ_SPECIALを提供し、 &lt;code&gt;Net_Config&lt;/code&gt; をそのタイプであると宣言します。</target>
        </trans-unit>
        <trans-unit id="0b78c6f57eb325a818fb40b5bb64b41ae51db883" translate="yes" xml:space="preserve">
          <source>And then replace the hash name with the reference:</source>
          <target state="translated">そして、ハッシュ名を参照先に置き換えます。</target>
        </trans-unit>
        <trans-unit id="1482b41f1c8c23a1b6f51e392e8562858f488f4e" translate="yes" xml:space="preserve">
          <source>And then set PERL5LIB to</source>
          <target state="translated">そして、PERL5LIB を</target>
        </trans-unit>
        <trans-unit id="e66399c5da24330a870822849d8e76cf4cddfe41" translate="yes" xml:space="preserve">
          <source>And then step until you hit what you're looking for. This works well in a loop if you want to only break at certain iterations:</source>
          <target state="translated">そして、あなたが探しているものを見つけるまでステップします。これは、特定の反復でのみブレークしたい場合には、ループの中でうまく機能します。</target>
        </trans-unit>
        <trans-unit id="4fa5c1cdc4927fc4a1301e4902474775669ad62e" translate="yes" xml:space="preserve">
          <source>And these conditions hold</source>
          <target state="translated">そして、これらの条件は</target>
        </trans-unit>
        <trans-unit id="d5d9b0ee41acfcea7375d0a36877f181aee3c098" translate="yes" xml:space="preserve">
          <source>And they all mean exactly the same as this:</source>
          <target state="translated">そして、どれもこれと全く同じ意味になります。</target>
        </trans-unit>
        <trans-unit id="8536c300c45ef5952d0313ea8b714a35911f6d2e" translate="yes" xml:space="preserve">
          <source>And this example uses anonymous subroutines to create separate counters:</source>
          <target state="translated">そして、この例では匿名のサブルーチンを使用して個別のカウンタを作成しています。</target>
        </trans-unit>
        <trans-unit id="2e09b2a3ab0575b70e3e084aed68993db1ebce78" translate="yes" xml:space="preserve">
          <source>And this is the XS code:</source>
          <target state="translated">そして、これがXSのコードです。</target>
        </trans-unit>
        <trans-unit id="0991be3e57b74fce439099710428de62b394a4a0" translate="yes" xml:space="preserve">
          <source>And this is the reason that many of the C library string handling functions should not be used. They don't cope with the full generality of Perl strings. It may be that your test cases don't have embedded &lt;code&gt;NUL&lt;/code&gt;s, and so the tests pass, whereas there may well eventually arise real-world cases where they fail. A lesson here is to include &lt;code&gt;NUL&lt;/code&gt;s in your tests. Now it's fairly rare in most real world cases to get &lt;code&gt;NUL&lt;/code&gt;s, so your code may seem to work, until one day a &lt;code&gt;NUL&lt;/code&gt; comes along.</source>
          <target state="translated">そしてこれが、Cライブラリの文字列処理関数の多くを使用すべきではない理由です。それらはPerl文字列の完全な一般性に対応していません。テストケースに &lt;code&gt;NUL&lt;/code&gt; が埋め込まれていないため、テストに合格する可能性がありますが、最終的には失敗する実際のケースが発生する可能性があります。ここでの教訓は、テストに &lt;code&gt;NUL&lt;/code&gt; を含めることです。現在、ほとんどの現実のケースで &lt;code&gt;NUL&lt;/code&gt; を取得することはかなりまれであるため、ある日 &lt;code&gt;NUL&lt;/code&gt; が登場するまで、コードは機能しているように見える場合があります。</target>
        </trans-unit>
        <trans-unit id="1e0a495178fdf07510ea88975dd8d193311ceae6" translate="yes" xml:space="preserve">
          <source>And this is what the script above will print:</source>
          <target state="translated">そして、上のスクリプトで印刷されるのはこれです。</target>
        </trans-unit>
        <trans-unit id="f3108d27ee1408a1d7ae19ba3de728a5ab7ca78b" translate="yes" xml:space="preserve">
          <source>And this isn't the whole story. Starting in Perl v5.12, strings that aren't encoded in UTF-8 may also be treated as Unicode under various conditions (see &lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;&quot;ASCII Rules versus Unicode Rules&quot; in perlunicode&lt;/a&gt;). This is only really a problem for characters whose ordinals are between 128 and 255, and their behavior varies under ASCII versus Unicode rules in ways that your code cares about (see &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;). There is no published API for dealing with this, as it is subject to change, but you can look at the code for &lt;code&gt;pp_lc&lt;/code&gt; in</source>
          <target state="translated">そして、これがすべてではありません。Perl v5.12以降、UTF-8でエンコードされていない文字列も、さまざまな条件下でUnicodeとして扱われる可能性があります（&lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;perlunicodeの「ASCIIルールとUnicodeルール」を参照&lt;/a&gt;）。これは、序数が128〜255の文字でのみ実際に問題になり、ASCIIとUnicodeのルールでは、コードが気にする方法で動作が異なります（&lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicodeの「Unicodeバグ」を参照&lt;/a&gt;）。変更される可能性があるため、これに対処するための公開APIはありませんが、 &lt;code&gt;pp_lc&lt;/code&gt; のコードは次の場所で確認できます。</target>
        </trans-unit>
        <trans-unit id="35194f4922bc124f887493e5a4a0600918a32f35" translate="yes" xml:space="preserve">
          <source>And this isn't the whole story. Starting in Perl v5.12, strings that aren't encoded in UTF-8 may also be treated as Unicode under various conditions (see &lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII Rules versus Unicode Rules in perlunicode&lt;/a&gt;). This is only really a problem for characters whose ordinals are between 128 and 255, and their behavior varies under ASCII versus Unicode rules in ways that your code cares about (see &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug in perlunicode&lt;/a&gt;). There is no published API for dealing with this, as it is subject to change, but you can look at the code for &lt;code&gt;pp_lc&lt;/code&gt; in</source>
          <target state="translated">そして、これはすべての話ではありません。Perl v5.12以降では、UTF-8でエンコードされていない文字列も、さまざまな条件下でUnicodeとして扱われる可能性があります（&lt;a href=&quot;perlunicode#ASCII-Rules-versus-Unicode-Rules&quot;&gt;perlunicodeのASCII規則とUnicode規則を参照&lt;/a&gt;）。これは実際には、序数が128から255の文字にのみ問題であり、ASCIIルールとUnicodeルールでは、コード&lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;が考慮&lt;/a&gt;している方法で動作が異なります（perlunicodeのUnicodeバグを参照）。これは変更される可能性があるため、これを処理するための公開されたAPIはありませんが、 &lt;code&gt;pp_lc&lt;/code&gt; のコードは</target>
        </trans-unit>
        <trans-unit id="04dc4562232363a5a2cdcef5ad0c57a632cc4d72" translate="yes" xml:space="preserve">
          <source>And this one reads from the child:</source>
          <target state="translated">そしてこちらは子供からの読み聞かせ。</target>
        </trans-unit>
        <trans-unit id="22fab1b1ab24735dd2f54767a6ec2977de574611" translate="yes" xml:space="preserve">
          <source>And this too is valid:</source>
          <target state="translated">そして、これも有効です。</target>
        </trans-unit>
        <trans-unit id="ca100b799213c6d95d191edf790bdf80dab3cf7a" translate="yes" xml:space="preserve">
          <source>And this:</source>
          <target state="translated">そして、これ。</target>
        </trans-unit>
        <trans-unit id="ca54ab72a0f62623ded9fadca0c4ae598b7f81fe" translate="yes" xml:space="preserve">
          <source>And to check the sequence in which the library directories are searched by perl, run</source>
          <target state="translated">また、ライブラリディレクトリがPerlによって検索される順序を確認するには、次のように実行します。</target>
        </trans-unit>
        <trans-unit id="362fec7b951a6425bfa81311e580eeb12dfb603d" translate="yes" xml:space="preserve">
          <source>And to desurrogate;</source>
          <target state="translated">そして、代位継承権を放棄する。</target>
        </trans-unit>
        <trans-unit id="2615ff8743f40d3114fe04e3d5a96ce87c8f4c9d" translate="yes" xml:space="preserve">
          <source>And try again:</source>
          <target state="translated">そして、もう一度やってみてください。</target>
        </trans-unit>
        <trans-unit id="92794ee0d6f5c6f795ca92dffa6111092171b2bc" translate="yes" xml:space="preserve">
          <source>And we end up with the program:</source>
          <target state="translated">そして、最後はプログラムで終わります。</target>
        </trans-unit>
        <trans-unit id="fea4a67d42b69d2a6859a380b25f39bb4220097d" translate="yes" xml:space="preserve">
          <source>And whitespace may be used between the &lt;code&gt;~&lt;/code&gt; and quoted delimiters:</source>
          <target state="translated">また、 &lt;code&gt;~&lt;/code&gt; と引用符で囲まれた区切り文字の間に空白を使用できます。</target>
        </trans-unit>
        <trans-unit id="397d92a7cd41c0dad432b26c8f27299cae1c6b41" translate="yes" xml:space="preserve">
          <source>And with &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding &quot;euc-jp&quot;&lt;/code&gt; in effect, it is the same thing as that code in UTF-8:</source>
          <target state="translated">そして、実際には &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding &quot;euc-jp&quot;&lt;/code&gt; で、それはUTF-8でのそのコードと同じものです：</target>
        </trans-unit>
        <trans-unit id="5057821b43bf3328e6eb98ddc5e990c468614ce5" translate="yes" xml:space="preserve">
          <source>And with &lt;code&gt;use encoding &quot;euc-jp&quot;&lt;/code&gt; in effect, it is the same thing as that code in UTF-8:</source>
          <target state="translated">そして、実際には &lt;code&gt;use encoding &quot;euc-jp&quot;&lt;/code&gt; して使用すると、UTF-8のコードと同じになります。</target>
        </trans-unit>
        <trans-unit id="b354e965b809ff14ff904fafbdc0b4de89c4bc4e" translate="yes" xml:space="preserve">
          <source>And with boolean methods</source>
          <target state="translated">また、ブーリアンメソッドで</target>
        </trans-unit>
        <trans-unit id="dd73bf27445a15ee33df36a7d8cf60d584177c03" translate="yes" xml:space="preserve">
          <source>And you can see the changes:</source>
          <target state="translated">そして、その変化を見ることができます。</target>
        </trans-unit>
        <trans-unit id="3a140f07fc1f24b5deb3f2211fd3e22212c7dcd8" translate="yes" xml:space="preserve">
          <source>And you may also sense that you do not want to bother your translators with having to write Perl code -- you'd much rather that they spend their</source>
          <target state="translated">また、翻訳者にPerlのコードを書かせたくないと感じているかもしれません。</target>
        </trans-unit>
        <trans-unit id="72514ebfb8885208b2209c125f8bbac4bdc3aa69" translate="yes" xml:space="preserve">
          <source>And you write:</source>
          <target state="translated">そして、あなたが書く。</target>
        </trans-unit>
        <trans-unit id="e0cc2408ca05432d5f7face5b62924a44acb8f84" translate="yes" xml:space="preserve">
          <source>And your caller module would be something like this:</source>
          <target state="translated">呼び出し元のモジュールは以下のようになります。</target>
        </trans-unit>
        <trans-unit id="f429519c2ad8f6db43559b6df0122aa7e92ef582" translate="yes" xml:space="preserve">
          <source>And, as you'll have noticed from the previous example, if you override &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob operator is overridden as well.</source>
          <target state="translated">また、前の例で気付いたように、 &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; をオーバーライドすると、 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob演算子もオーバーライドされます。</target>
        </trans-unit>
        <trans-unit id="09ddb5c3e778ae1b6a95dadacffb550e09674ca1" translate="yes" xml:space="preserve">
          <source>And, as you'll have noticed from the previous example, if you override &lt;code&gt;glob&lt;/code&gt;, the &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob operator is overridden as well.</source>
          <target state="translated">また、前の例でお気づきのように、 &lt;code&gt;glob&lt;/code&gt; をオーバーライドすると、 &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; glob演算子もオーバーライドされます。</target>
        </trans-unit>
        <trans-unit id="f027b49b77d3cee2d1bd5a0ad1af1a5214bdb5ba" translate="yes" xml:space="preserve">
          <source>And, most importantly, there's all the practical details of how to actually go about deriving from Maketext so you can use it for your interfaces, and the various tools and conventions for starting out and maintaining individual language modules.</source>
          <target state="translated">そして、最も重要なことは、実際にどのようにして Maketext から派生してインターフェイスに使えるようにするのか、そして、個々の言語モジュールを使い始めて維持するための様々なツールや規約など、実用的な詳細があることです。</target>
        </trans-unit>
        <trans-unit id="0872d4a5d2061a3d40ffa31b9853ff607e66e0c5" translate="yes" xml:space="preserve">
          <source>And, the Name and Name_Aliases properties are accessible through the &lt;code&gt;\N{}&lt;/code&gt; interpolation in double-quoted strings and regular expressions; and functions &lt;code&gt;charnames::viacode()&lt;/code&gt; , &lt;code&gt;charnames::vianame()&lt;/code&gt; , and &lt;code&gt;charnames::string_vianame()&lt;/code&gt; (which require a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames ();&lt;/code&gt; to be specified.</source>
          <target state="translated">また、NameプロパティとName_Aliasesプロパティには、二重引用符で囲まれた文字列と正規表現の &lt;code&gt;\N{}&lt;/code&gt; 補間を通じてアクセスできます。および関数 &lt;code&gt;charnames::viacode()&lt;/code&gt; 、 &lt;code&gt;charnames::vianame()&lt;/code&gt; 、および &lt;code&gt;charnames::string_vianame()&lt;/code&gt; （これには、指定する &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; charnames ();&lt;/code&gt; が必要です）。</target>
        </trans-unit>
        <trans-unit id="a3d4a9b48a0e71abc1829b589dc1a4bb4344372b" translate="yes" xml:space="preserve">
          <source>And, there is a technique that can be used to handle variable length lookbehinds on earlier releases, and longer than 255 characters. It is described in &lt;a href=&quot;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&quot;&gt;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&lt;/a&gt;.</source>
          <target state="translated">また、以前のリリースでは、255文字を超える可変長のルックビハインドを処理するために使用できる手法があります。&lt;a href=&quot;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&quot;&gt;http://www.drregex.com/2019/02/variable-length-lookbehinds-actually.html&lt;/a&gt;で説明されています。</target>
        </trans-unit>
        <trans-unit id="b49cf0754660175d0a77b4c857d087e651cbf367" translate="yes" xml:space="preserve">
          <source>And, with Perl 5.10 and later, you don't have to check for an inheritance to see if the object can handle a role. For that, you can use &lt;code&gt;DOES&lt;/code&gt; , which comes from &lt;code&gt;UNIVERSAL&lt;/code&gt; :</source>
          <target state="translated">また、Perl 5.10以降では、オブジェクトがロールを処理できるかどうかを確認するために継承を確認する必要はありません。そのためには、 &lt;code&gt;UNIVERSAL&lt;/code&gt; の &lt;code&gt;DOES&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="df1177936aa7e7d352017983c64995f489a2f05c" translate="yes" xml:space="preserve">
          <source>And, with Perl 5.10 and later, you don't have to check for an inheritance to see if the object can handle a role. For that, you can use &lt;code&gt;DOES&lt;/code&gt;, which comes from &lt;code&gt;UNIVERSAL&lt;/code&gt;:</source>
          <target state="translated">また、Perl 5.10以降では、オブジェクトがロールを処理できるかどうかを確認するために継承をチェックする必要はありません。そのために、 &lt;code&gt;UNIVERSAL&lt;/code&gt; からの &lt;code&gt;DOES&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="973c0aeb4f70654b3b70d2e3c1f5c993e73805e5" translate="yes" xml:space="preserve">
          <source>Andreas J. Koenig</source>
          <target state="translated">アンドレアス・J・ケーニッヒ</target>
        </trans-unit>
        <trans-unit id="84c4d01ab2b12800c7bf2f6468b98b449d53a99b" translate="yes" xml:space="preserve">
          <source>Andreas Koenig &amp;lt;andk@cpan.org&amp;gt;, Branislav Zahradnik &amp;lt;barney@cpan.org&amp;gt;</source>
          <target state="translated">Andreas Koenig &amp;lt;andk@cpan.org&amp;gt;, Branislav Zahradnik &amp;lt;barney@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5b41c9a4e6f27e4cb868723e388d3e3baf23ec77" translate="yes" xml:space="preserve">
          <source>Andreas Koenig &lt;code&gt;&amp;lt;andk@cpan.org&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Andreas Koenig &lt;code&gt;&amp;lt;andk@cpan.org&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17721a7a6efc10cf2782e06109ae542e5e371c5d" translate="yes" xml:space="preserve">
          <source>Andreas Koenig &lt;code&gt;andreas.koenig@anima.de&lt;/code&gt;</source>
          <target state="translated">Andreas Koenig &lt;code&gt;andreas.koenig@anima.de&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1928f95c598b9e69462fcb512625cf8e28923044" translate="yes" xml:space="preserve">
          <source>Android</source>
          <target state="translated">Android</target>
        </trans-unit>
        <trans-unit id="f2f8905b2465e6f0ad9cfd91b9febf4156adfa14" translate="yes" xml:space="preserve">
          <source>Andy Armstong &amp;lt;andy@hexten.net&amp;gt;</source>
          <target state="translated">Andy Armstong &amp;lt;andy@hexten.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d272317e48a940ed9b68adfad919572635019ce3" translate="yes" xml:space="preserve">
          <source>Andy Armstrong &lt;code&gt;&amp;lt;andy@hexten.net&amp;gt;&lt;/code&gt;</source>
          <target state="translated">アンディアームストロング &lt;code&gt;&amp;lt;andy@hexten.net&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b85b5eb312e6917fec0aa730c7d70660252958f" translate="yes" xml:space="preserve">
          <source>Andy Armstrong, &amp;lt;andy@hexten.net&amp;gt;</source>
          <target state="translated">Andy Armstrong、&amp;lt;andy@hexten.net&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9084574cd986898323dbe20b46abf1751fbbf849" translate="yes" xml:space="preserve">
          <source>Andy Broad &amp;lt;andy@broad.ology.org.uk&amp;gt;</source>
          <target state="translated">アンディブロード&amp;lt;andy@broad.ology.org.uk&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8e9ef1486d01c7ad977376f692dc981d906e478c" translate="yes" xml:space="preserve">
          <source>Andy Dougherty &lt;code&gt;doughera@lafayette.edu&lt;/code&gt; , Andreas K&amp;ouml;nig &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt; , Tim Bunce &lt;code&gt;timb@cpan.org&lt;/code&gt; . VMS support by Charles Bailey &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt; . OS/2 support by Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; .</source>
          <target state="translated">アンディ・ドハティの &lt;code&gt;doughera@lafayette.edu&lt;/code&gt; 、アンドレアス・ケーニッヒは &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt; 、ティムバンス &lt;code&gt;timb@cpan.org&lt;/code&gt; 。Charles Bailey &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt; によるVMSサポート。Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; によるOS / 2サポート。</target>
        </trans-unit>
        <trans-unit id="54b2fb7511cb7a7c3493b4e0650ca3d85102f114" translate="yes" xml:space="preserve">
          <source>Andy Dougherty &lt;code&gt;doughera@lafayette.edu&lt;/code&gt;, Andreas K&amp;ouml;nig &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt;, Tim Bunce &lt;code&gt;timb@cpan.org&lt;/code&gt;. VMS support by Charles Bailey &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt;. OS/2 support by Ilya Zakharevich &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt;.</source>
          <target state="translated">アンディ・ドハティの &lt;code&gt;doughera@lafayette.edu&lt;/code&gt; 、アンドレアス・ケーニッヒは &lt;code&gt;andreas.koenig@mind.de&lt;/code&gt; 、ティムバンス &lt;code&gt;timb@cpan.org&lt;/code&gt; 。Charles &lt;code&gt;bailey@newman.upenn.edu&lt;/code&gt; よるVMSサポート。Ilya Zakharevichilya@math.ohio-state.eduに &lt;code&gt;ilya@math.ohio-state.edu&lt;/code&gt; OS / 2のサポート。</target>
        </trans-unit>
        <trans-unit id="adb884ee85ba557bf7e891804c953fd2fabe3f95" translate="yes" xml:space="preserve">
          <source>Andy Glew,</source>
          <target state="translated">アンディ・グリュー</target>
        </trans-unit>
        <trans-unit id="9371666f1dc2fa002dd7c688c18705bc84f8f9d0" translate="yes" xml:space="preserve">
          <source>Andy Lester</source>
          <target state="translated">アンディ・レスター</target>
        </trans-unit>
        <trans-unit id="f309e7ea03de47735dc8e5cfc8cc01f796755634" translate="yes" xml:space="preserve">
          <source>Anecdotal estimates of source-to-compiled code bloat suggest an eightfold increase. This means that the compiled form of reasonable (normally commented, properly indented etc.) code will take about eight times more space in memory than the code took on disk.</source>
          <target state="translated">ソースからコンパイルされたコードの肥大化についての逸話的な見積もりによると、8倍にもなることが示唆されています。これは、合理的な (普通にコメントされた、適切にインデントされたなど)コードのコンパイルされた形式のコードは、ディスク上のコードの約 8 倍のメモリ容量を必要とすることを意味しています。</target>
        </trans-unit>
        <trans-unit id="dd5ff38fa4ac27c93c3c6622ac77c49ca0b0e6b7" translate="yes" xml:space="preserve">
          <source>Angle brackets not written as &lt;code&gt;&amp;lt;lt&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;gt&amp;gt;&lt;/code&gt; can potentially cause errors as they could be misinterpreted as markup commands. This is only printed when the -warnings level is greater than 1.</source>
          <target state="translated">&lt;code&gt;&amp;lt;lt&amp;gt;&lt;/code&gt; および &lt;code&gt;&amp;lt;gt&amp;gt;&lt;/code&gt; として記述されていない山括弧は、マークアップコマンドとして誤って解釈される可能性があるため、エラーを引き起こす可能性があります。-warningsレベルが1より大きい場合にのみ出力されます。</target>
        </trans-unit>
        <trans-unit id="4a0daf5f778b84f7d47324f4951f69110d4d48b4" translate="yes" xml:space="preserve">
          <source>Anno Siegel (ANNO) wrote the xs code and the changes in perl proper Jerry Hedden (JDHEDDEN) made it faster</source>
          <target state="translated">Anno Siegel (ANNO)は xs のコードを書き、Jerry Hedden (JDHEDDEN)は perl の適切な変更により高速化しました。</target>
        </trans-unit>
        <trans-unit id="602afe4dcabe1b2fe81bdeaea0130200ac9160dc" translate="yes" xml:space="preserve">
          <source>AnnoCPAN: Annotated CPAN documentation</source>
          <target state="translated">AnnoCPAN:注釈付きCPAN文書</target>
        </trans-unit>
        <trans-unit id="4fa7bfd58b194e39ca2dde6c48f032e168048d8e" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt;: &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;threads&quot;&gt;スレッドの&lt;/a&gt;注釈付きPOD ：&lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;http&lt;/a&gt; : //annocpan.org/? mode=search&amp;amp;field=Module&amp;amp;name= threads</target>
        </trans-unit>
        <trans-unit id="7858242352e2796cb227df6cabe7747dcc9c11c4" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt;: &lt;a href=&quot;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;threads&quot;&gt;スレッドの&lt;/a&gt;注釈付きPOD ：&lt;a href=&quot;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads&quot;&gt;https&lt;/a&gt;：//web.archive.org/web/20171028020148/http：//annocpan.org/？ mode = search ＆ field = Module ＆name = threads</target>
        </trans-unit>
        <trans-unit id="ba63b983b01c370d674ecdc009b4d7bcd13f4f33" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;: &lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;threads/shared&quot;&gt;スレッドの&lt;/a&gt;注釈付きPOD :: shared：&lt;a href=&quot;http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;http&lt;/a&gt; : //annocpan.org/? mode=search&amp;amp;field=Module&amp;amp;name= threads %3A% 3Ashared</target>
        </trans-unit>
        <trans-unit id="7ff3b3d306ae85d31c9461b66532ebdda6c7e205" translate="yes" xml:space="preserve">
          <source>Annotated POD for &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt;: &lt;a href=&quot;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;threads::shared&quot;&gt;スレッドの&lt;/a&gt;注釈付きPOD :: shared：&lt;a href=&quot;https://web.archive.org/web/20171028020148/http://annocpan.org/?mode=search&amp;amp;field=Module&amp;amp;name=threads%3A%3Ashared&quot;&gt;https&lt;/a&gt;：//web.archive.org/web/20171028020148/http：//annocpan.org/？mode = search＆field = Module＆name = threads％3A％3Ashared</target>
        </trans-unit>
        <trans-unit id="4d0700dd0d246c337cd6fa922a92caa253e25b21" translate="yes" xml:space="preserve">
          <source>Annotated list of characters</source>
          <target state="translated">文字の注釈付きリスト</target>
        </trans-unit>
        <trans-unit id="c10f845c88bdb301cd3ade696bdf99cccd4ed1f0" translate="yes" xml:space="preserve">
          <source>Annotated tags in the canonical perl.git repository will never be deleted or modified. Think long and hard about whether you want to push a local tag to perl.git before doing so. (Pushing simple tags is not allowed.)</source>
          <target state="translated">canonical perl.git リポジトリ内の注釈付きタグが削除されたり変更されたりすることはありません。ローカルのタグを perl.git にプッシュするかどうかは、よく考えてからにしましょう。(単純なタグをプッシュすることは許可されていません)。</target>
        </trans-unit>
        <trans-unit id="d5154e030234862764507248749c6a7c751b8bc6" translate="yes" xml:space="preserve">
          <source>Anonymous Subroutines</source>
          <target state="translated">匿名サブルーチン</target>
        </trans-unit>
        <trans-unit id="911169a23e106a872e476c8d2fa5935672c571c0" translate="yes" xml:space="preserve">
          <source>Anonymous hash and array composers like these can be intermixed freely to produce as complicated a structure as you want. The multidimensional syntax described below works for these too. The values above are literals, but variables and expressions would work just as well, because assignment operators in Perl (even within local() or my()) are executable statements, not compile-time declarations.</source>
          <target state="translated">これらのような匿名ハッシュと配列のコンポーザは自由に混ぜ合わせて、好きなだけ複雑な構造を作ることができます。以下に説明する多次元構文は、これらにも対応しています。上記の値はリテラルですが、Perl の代入演算子(local()やmy()の中でも)は実行可能なステートメントであり、コンパイル時の宣言ではないので、変数や式も同様に動作します。</target>
        </trans-unit>
        <trans-unit id="ddd265fb1f3b46963f4185e092c2f56d761a6e96" translate="yes" xml:space="preserve">
          <source>Anonymous subroutines act as closures with respect to my() variables, that is, variables lexically visible within the current scope. Closure is a notion out of the Lisp world that says if you define an anonymous function in a particular lexical context, it pretends to run in that context even when it's called outside the context.</source>
          <target state="translated">匿名サブルーチンはmy()変数、つまり現在のスコープ内で語彙的に見える変数に対してクロージャとして動作します。クロージャとはLispの世界にある概念で、特定の語彙的コンテキストで匿名関数を定義すると、コンテキスト外で呼び出されてもそのコンテキストで実行されているかのように振る舞うというものです。</target>
        </trans-unit>
        <trans-unit id="3eb95879a615d5ea34c741b40bf67030c1977968" translate="yes" xml:space="preserve">
          <source>Anonymous subroutines get to capture each time you execute the &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; operator, as they are created on the fly. If you are accustomed to using nested subroutines in other programming languages with their own private variables, you'll have to work at it a bit in Perl. The intuitive coding of this type of thing incurs mysterious warnings about &quot;will not stay shared&quot; due to the reasons explained above. For example, this won't work:</source>
          <target state="translated">匿名のサブルーチンは、その場で作成されるため、 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt;&lt;/code&gt; 演算子を実行するたびにキャプチャされます。独自のプライベート変数を持つ他のプログラミング言語でネストされたサブルーチンを使用することに慣れている場合は、Perlで少し作業する必要があります。この種のことを直感的にコーディングすると、上記で説明した理由により、「共有されない」という不可解な警告が発生します。たとえば、これは機能しません：</target>
        </trans-unit>
        <trans-unit id="484e8735a38d0b2c3316b6b4767502150b9246c0" translate="yes" xml:space="preserve">
          <source>Anonymous subroutines get to capture each time you execute the &lt;code&gt;sub&lt;/code&gt; operator, as they are created on the fly. If you are accustomed to using nested subroutines in other programming languages with their own private variables, you'll have to work at it a bit in Perl. The intuitive coding of this type of thing incurs mysterious warnings about &quot;will not stay shared&quot; due to the reasons explained above. For example, this won't work:</source>
          <target state="translated">匿名サブルーチンは、その場で作成されるため、 &lt;code&gt;sub&lt;/code&gt; 演算子を実行するたびにキャプチャされます。独自のプライベート変数を使用して他のプログラミング言語でネストされたサブルーチンを使用することに慣れている場合は、Perlで少し作業する必要があります。この種のものを直感的にコーディングすると、上記の理由により、「共有されたままにならない」という不思議な警告が発生します。たとえば、これは機能しません。</target>
        </trans-unit>
        <trans-unit id="c0878cc2f5c4c23ed0c52c0dfcedfeb6916f96a7" translate="yes" xml:space="preserve">
          <source>Another Example</source>
          <target state="translated">別の例</target>
        </trans-unit>
        <trans-unit id="58127100a894b61eeb7ff5e87057e807d55c8b96" translate="yes" xml:space="preserve">
          <source>Another Example -- Key is a C int.</source>
          <target state="translated">別の例 --キーは C の int です。</target>
        </trans-unit>
        <trans-unit id="60d38257f9d2129e1058114b1893e74a3db974bb" translate="yes" xml:space="preserve">
          <source>Another Example: Key is a C int.</source>
          <target state="translated">別の例。キーはCの整数です。</target>
        </trans-unit>
        <trans-unit id="c610761bff33dc8f8934a509a66662b8c1def3f8" translate="yes" xml:space="preserve">
          <source>Another P5P contributor recommended installation and use of Devel::PatchPerl for this situation, first to determine the version of perl at the commit in question, then to patch the source code at that point to facilitate a build.</source>
          <target state="translated">別の P5P のコントリビューターは、このような状況のために Devel::PatchPerl をインストールして使用することを推奨しています。</target>
        </trans-unit>
        <trans-unit id="be5842d0c6f0b2a32d5a2aac4ce0ec4bcd453989" translate="yes" xml:space="preserve">
          <source>Another Portable Binary Encoding</source>
          <target state="translated">別のポータブルバイナリエンコーディング</target>
        </trans-unit>
        <trans-unit id="a3a811e6345c52a72030025da749e7378837c8a7" translate="yes" xml:space="preserve">
          <source>Another brief debugger, slightly more useful, can be created with only the line:</source>
          <target state="translated">もう一つ、少しだけ便利な短いデバッガを一行だけで作成することができます。</target>
        </trans-unit>
        <trans-unit id="723c39858f051ddac15e8257e9c5bc5481712afe" translate="yes" xml:space="preserve">
          <source>Another common error is to use ordinary parentheses to construct a list reference when you should be using square or curly brackets, for example, if you say</source>
          <target state="translated">もう一つよくある間違いは、通常の括弧を使用してリスト参照を構築することです。</target>
        </trans-unit>
        <trans-unit id="989f6c267d1aa6631d47641c01947fa297495517" translate="yes" xml:space="preserve">
          <source>Another common use for this construct is when you need to execute something without the shell's interference. With system(), it's straightforward, but you can't use a pipe open or backticks safely. That's because there's no way to stop the shell from getting its hands on your arguments. Instead, use lower-level control to call exec() directly.</source>
          <target state="translated">このコンストラクトのもう一つの一般的な使用法は、シェルの干渉を受けずに何かを実行する必要がある場合です。system()を使えば簡単ですが、パイプオープンやバックティックを安全に使うことはできません。シェルが引数に手を出すのを止める方法がないからです。代わりに、下位レベルの制御を使って exec()を直接呼び出すようにしましょう。</target>
        </trans-unit>
        <trans-unit id="948bec86ec25e1c793c75848e3f095908f00b9e7" translate="yes" xml:space="preserve">
          <source>Another complication is that the representation used for the program differs if it needs to store Unicode, but it's not always possible to know for sure whether it does until midway through parsing. The Unicode representation for the program is larger, and cannot be matched as efficiently. (See &lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;&quot;Unicode and Localisation Support&quot;&lt;/a&gt; below for more details as to why.) If the pattern contains literal Unicode, it's obvious that the program needs to store Unicode. Otherwise, the parser optimistically assumes that the more efficient representation can be used, and starts sizing on this basis. However, if it then encounters something in the pattern which must be stored as Unicode, such as an &lt;code&gt;\x{...}&lt;/code&gt; escape sequence representing a character literal, then this means that all previously calculated sizes need to be redone, using values appropriate for the Unicode representation. This is another instance where the parsing needs to be restarted, and it can and is done immediately. The function returns failure, and sets the flag &lt;code&gt;RESTART_UTF8&lt;/code&gt; (encapsulated by using the macro &lt;code&gt;REQUIRE_UTF8&lt;/code&gt;). This restart request is propagated up the call chain in a similar fashion, until it is &quot;caught&quot; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt;, which marks the pattern as containing Unicode, and restarts the sizing pass. It is also possible for constructions within run-time code blocks to turn out to need Unicode representation., which is signalled by &lt;code&gt;S_compile_runtime_code()&lt;/code&gt; returning false to &lt;code&gt;Perl_re_op_compile()&lt;/code&gt;.</source>
          <target state="translated">もう1つの厄介な問題は、Unicodeを格納する必要がある場合、プログラムに使用される表現が異なることですが、解析の途中まで格納されるかどうかを常に確実に知ることができるとは限りません。プログラムのUnicode表現は大きく、効率的に一致させることはできません。 （理由の詳細については、以下の&lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;「Unicodeとローカリゼーションのサポート」を&lt;/a&gt;参照してください。）パターンにリテラルUnicodeが含まれている場合、プログラムがUnicodeを格納する必要があることは明らかです。それ以外の場合、パーサーは、より効率的な表現を使用できると楽観的に想定し、これに基づいてサイズ設定を開始します。ただし、 &lt;code&gt;\x{...}&lt;/code&gt; など、Unicodeとして保存する必要のあるパターンで何かが発生した場合文字リテラルを表すエスケープシーケンスの場合、これは、Unicode表現に適した値を使用して、以前に計算されたすべてのサイズをやり直す必要があることを意味します。これは、解析を再開する必要があるもう1つのインスタンスであり、すぐに実行できます。この関数は失敗を返し、フラグ &lt;code&gt;RESTART_UTF8&lt;/code&gt; （マクロ &lt;code&gt;REQUIRE_UTF8&lt;/code&gt; を使用してカプセル化）を設定します。この再起動要求は、パターンをUnicodeを含むものとしてマークし、サイジングパスを再開する &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; で「キャッチ」されるまで、同様の方法でコールチェーンに伝播されます。ランタイムコードブロック内の構造がUnicode表現を必要とすることが判明する可能性もあります。これは &lt;code&gt;S_compile_runtime_code()&lt;/code&gt; によって通知されます。 &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; にfalseを返します。</target>
        </trans-unit>
        <trans-unit id="9e79a0e3805beb03c075ab9c59ea2fd3f85cbbe5" translate="yes" xml:space="preserve">
          <source>Another complication is that the representation used for the program differs if it needs to store Unicode, but it's not always possible to know for sure whether it does until midway through parsing. The Unicode representation for the program is larger, and cannot be matched as efficiently. (See &lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;Unicode and Localisation Support&lt;/a&gt; below for more details as to why.) If the pattern contains literal Unicode, it's obvious that the program needs to store Unicode. Otherwise, the parser optimistically assumes that the more efficient representation can be used, and starts sizing on this basis. However, if it then encounters something in the pattern which must be stored as Unicode, such as an &lt;code&gt;\x{...}&lt;/code&gt; escape sequence representing a character literal, then this means that all previously calculated sizes need to be redone, using values appropriate for the Unicode representation. Currently, all regular expression constructions which can trigger this are parsed by code in &lt;code&gt;regatom()&lt;/code&gt; .</source>
          <target state="translated">もう1つの問題は、Unicodeを格納する必要がある場合、プログラムで使用される表現が異なることですが、解析の途中まで実行するかどうかを常に確実に知ることはできません。プログラムのUnicode表現は大きく、効率的に一致させることができません。 （理由の詳細については、以下の&lt;a href=&quot;#Unicode-and-Localisation-Support&quot;&gt;Unicodeおよびローカリゼーションのサポートを&lt;/a&gt;参照してください。）パターンにリテラルUnicodeが含まれている場合、プログラムがUnicodeを格納する必要があることは明らかです。そうでない場合、パーサーはより効率的な表現を使用できると楽観的に想定し、これに基づいてサイジングを開始します。ただし、パターンで &lt;code&gt;\x{...}&lt;/code&gt; などのUnicodeとして保存する必要がある何かに遭遇した場合文字リテラルを表すエスケープシーケンス。これは、以前に計算されたすべてのサイズを、Unicode表現に適した値を使用してやり直す必要があることを意味します。現在、これをトリガーする可能性のあるすべての正規表現構造は、 &lt;code&gt;regatom()&lt;/code&gt; のコードによって解析されます。</target>
        </trans-unit>
        <trans-unit id="8b313efb71a57a4464cb94a659a9e8b90c24250e" translate="yes" xml:space="preserve">
          <source>Another confusion with both these properties is that the definition is not that the code point has been</source>
          <target state="translated">これらの両方のプロパティとのもう一つの混乱は、定義がコードポイントが</target>
        </trans-unit>
        <trans-unit id="8de6445149b9f420296053261c9997adf2340600" translate="yes" xml:space="preserve">
          <source>Another consequence of using &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; (on some systems) is that special end-of-file markers will be seen as part of the data stream. For systems from the Microsoft family this means that, if your binary data contain &lt;code&gt;\cZ&lt;/code&gt;, the I/O subsystem will regard it as the end of the file, unless you use &lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">（一部のシステムで）&lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt;を使用する別の結果は、特別なファイルの終わりマーカーがデータストリームの一部として表示されることです。Microsoftファミリのシステムの場合、これは、バイナリデータに &lt;code&gt;\cZ&lt;/code&gt; が含まれている場合、&lt;a href=&quot;#binmode-FILEHANDLE%2C-LAYER&quot;&gt; &lt;code&gt;binmode&lt;/code&gt; &lt;/a&gt;を使用しない限り、I / Oサブシステムはそれをファイルの終わりと見なすことを意味します。</target>
        </trans-unit>
        <trans-unit id="a7643f36484ae100d2da2d3c144ef9dbeaed949e" translate="yes" xml:space="preserve">
          <source>Another consequence of using binmode() (on some systems) is that special end-of-file markers will be seen as part of the data stream. For systems from the Microsoft family this means that, if your binary data contain &lt;code&gt;\cZ&lt;/code&gt; , the I/O subsystem will regard it as the end of the file, unless you use binmode().</source>
          <target state="translated">（一部のシステムで）binmode（）を使用することのもう1つの結果は、特別なファイル終了マーカーがデータストリームの一部として表示されることです。Microsoftファミリーのシステムの場合、これは、バイナリデータに &lt;code&gt;\cZ&lt;/code&gt; が含まれている場合、binmode（）を使用しない限り、I / Oサブシステムはそれをファイルの終わりと見なすことを意味します。</target>
        </trans-unit>
        <trans-unit id="3cc44056a9f339f4466b010a8b6a440f514bb627" translate="yes" xml:space="preserve">
          <source>Another construct to be wary of is the inappropriate use of hex (unless you use &lt;code&gt;\N{U+...}&lt;/code&gt; ) or octal constants in regular expressions. Consider the following set of subs:</source>
          <target state="translated">注意すべきもう1つの構成は、正規表現での16進数（ &lt;code&gt;\N{U+...}&lt;/code&gt; を使用しない限り）または8進定数の不適切な使用です。次のサブセットを検討してください。</target>
        </trans-unit>
        <trans-unit id="4bdabce8c57375ff87d8b683a0b4feedd678dfa2" translate="yes" xml:space="preserve">
          <source>Another construct to be wary of is the inappropriate use of hex (unless you use &lt;code&gt;\N{U+...}&lt;/code&gt;) or octal constants in regular expressions. Consider the following set of subs:</source>
          <target state="translated">注意すべきもう1つの構成は、正規表現での16進定数（ &lt;code&gt;\N{U+...}&lt;/code&gt; を使用しない限り）または8進定数の不適切な使用です。次の一連の潜水艦を検討してください。</target>
        </trans-unit>
        <trans-unit id="dd580d9d1c12fa08ea2d8378d289e2825dd48a0c" translate="yes" xml:space="preserve">
          <source>Another description starts with notions of &quot;better&quot;/&quot;worse&quot;. All the substrings which may be matched by the given regular expression can be sorted from the &quot;best&quot; match to the &quot;worst&quot; match, and it is the &quot;best&quot; match which is chosen. This substitutes the question of &quot;what is chosen?&quot; by the question of &quot;which matches are better, and which are worse?&quot;.</source>
          <target state="translated">もう一つの記述は、&quot;より良い&quot;/&quot;より悪い &quot;の概念から始まります。与えられた正規表現によってマッチする可能性のあるすべての部分文字列は、&quot;最高 &quot;のマッチから &quot;最悪 &quot;のマッチまで並べ替えることができ、&quot;最高 &quot;のマッチが選択される。これは、&quot;何が選ばれるのか?&quot;という質問を、&quot;どのマッチがより良く、どのマッチがより悪いのか?&quot;という質問に置き換えます。</target>
        </trans-unit>
        <trans-unit id="856a6f6c8652259321cab00a9ad8f033dc81e6f4" translate="yes" xml:space="preserve">
          <source>Another drawback is only valid for Perl versions before 5.6.0. This drawback is that the seek and tell functions (both the builtin version and POSIX module version) will not perform correctly.</source>
          <target state="translated">もう一つの欠点は、Perl のバージョンが 5.6.0 より前の場合にのみ有効です。この欠点は、シークとテル関数(ビルトイン版とPOSIXモジュール版の両方)が正しく動作しないことです。</target>
        </trans-unit>
        <trans-unit id="d8eeb28f49e1f9d89b4e036aaf71838ed7700dd9" translate="yes" xml:space="preserve">
          <source>Another dummy layer. When pushed it pops itself and sets the &lt;code&gt;PERLIO_F_UTF8&lt;/code&gt; flag on the layer which was (and now is once more) the top of the stack.</source>
          <target state="translated">別のダミー層。プッシュされると、それ自体がポップされ、スタックの最上部であった（現在はもう一度）レイヤーに &lt;code&gt;PERLIO_F_UTF8&lt;/code&gt; フラグが設定されます。</target>
        </trans-unit>
        <trans-unit id="d9e8985e4a56d117b356dcbeb0c42c3cbcba847b" translate="yes" xml:space="preserve">
          <source>Another example of a data paragraph:</source>
          <target state="translated">データパラグラフの別の例。</target>
        </trans-unit>
        <trans-unit id="b5c62d28b9310748f7a00e0cde763766b0ceff47" translate="yes" xml:space="preserve">
          <source>Another example switched the first &quot;latin1&quot; encoding it finds to &quot;utf8&quot; in a pod file:</source>
          <target state="translated">別の例では、ポッドファイルの最初の &quot;latin1 &quot;エンコーディングを &quot;utf8 &quot;に切り替えています。</target>
        </trans-unit>
        <trans-unit id="50f1426af11ad7a924141e38d176e901ed8b9c69" translate="yes" xml:space="preserve">
          <source>Another example that shows that within &lt;code&gt;\p{...}&lt;/code&gt;, &lt;code&gt;/x&lt;/code&gt; isn't needed to have spaces:</source>
          <target state="translated">&lt;code&gt;\p{...}&lt;/code&gt; 内では、 &lt;code&gt;/x&lt;/code&gt; にスペースを含める必要がないことを示す別の例：</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">別の例です。</target>
        </trans-unit>
        <trans-unit id="ece934d7c44856dd3f545147d03b2aa737a1de6d" translate="yes" xml:space="preserve">
          <source>Another form of code expression is the</source>
          <target state="translated">コード表現の別の形式は</target>
        </trans-unit>
        <trans-unit id="48b78ab1e531e9b3794c2d43c0589ca792ae0b42" translate="yes" xml:space="preserve">
          <source>Another form of optimisation that can occur is the post-parse &quot;peep-hole&quot; optimisation, where inefficient constructs are replaced by more efficient constructs. The &lt;code&gt;TAIL&lt;/code&gt; regops which are used during parsing to mark the end of branches and the end of groups are examples of this. These regops are used as place-holders during construction and &quot;always match&quot; so they can be &quot;optimised away&quot; by making the things that point to the &lt;code&gt;TAIL&lt;/code&gt; point to the thing that &lt;code&gt;TAIL&lt;/code&gt; points to, thus &quot;skipping&quot; the node.</source>
          <target state="translated">発生する可能性のある最適化の別の形式は、解析後の「のぞき穴」最適化です。この場合、非効率的な構成がより効率的な構成に置き換えられます。 &lt;code&gt;TAIL&lt;/code&gt; の分岐の終わりをマークするために解析中に使用されregopsおよびグループの端部がその例です。これらのregopsは、構築中にプレースホルダーとして使用され、「常に一致」するため、 &lt;code&gt;TAIL&lt;/code&gt; を指すものを &lt;code&gt;TAIL&lt;/code&gt; が指すものにポイントし、ノードを「スキップ」することで、「最適化」できます。</target>
        </trans-unit>
        <trans-unit id="6a81857ae4b443a44f359782c057cbbbeb457048" translate="yes" xml:space="preserve">
          <source>Another good reason in addition to readability and maintainability for using relative backreferences is illustrated by the following example, where a simple pattern for matching peculiar strings is used:</source>
          <target state="translated">相対後方参照を使う理由としては、読みやすさや保守性のほかに、以下の例では、特殊な文字列をマッチングさせるための簡単なパターンが使われています。</target>
        </trans-unit>
        <trans-unit id="bfac64b9584bc828981db16d0cc4e6658be646cc" translate="yes" xml:space="preserve">
          <source>Another interesting approach to IPC is making your single program go multiprocess and communicate between--or even amongst--yourselves. The open() function will accept a file argument of either &lt;code&gt;&quot;-|&quot;&lt;/code&gt; or &lt;code&gt;&quot;|-&quot;&lt;/code&gt; to do a very interesting thing: it forks a child connected to the filehandle you've opened. The child is running the same program as the parent. This is useful for safely opening a file when running under an assumed UID or GID, for example. If you open a pipe</source>
          <target state="translated">IPCへのもう1つの興味深いアプローチは、単一のプログラムをマルチプロセスにして、自分自身の間、または自分自身の間でさえ通信することです。open（）関数は、 &lt;code&gt;&quot;-|&quot;&lt;/code&gt; のいずれかのファイル引数を受け入れます または &lt;code&gt;&quot;|-&quot;&lt;/code&gt; は、非常に興味深いことを行います。開いたファイルハンドルに接続された子をフォークします。子は親と同じプログラムを実行しています。これは、たとえば、想定されたUIDまたはGIDで実行しているときにファイルを安全に開くのに役立ちます。パイプを開けると</target>
        </trans-unit>
        <trans-unit id="4522d51a25407d48caa1899497ae3f892458c192" translate="yes" xml:space="preserve">
          <source>Another interesting approach to IPC is making your single program go multiprocess and communicate between--or even amongst--yourselves. The two-argument form of the open() function will accept a file argument of either &lt;code&gt;&quot;-|&quot;&lt;/code&gt; or &lt;code&gt;&quot;|-&quot;&lt;/code&gt; to do a very interesting thing: it forks a child connected to the filehandle you've opened. The child is running the same program as the parent. This is useful for safely opening a file when running under an assumed UID or GID, for example. If you open a pipe</source>
          <target state="translated">IPCへのもう1つの興味深いアプローチは、単一のプログラムをマルチプロセスにして、自分たちの間で、あるいは自分たちの間でさえ通信することです。open（）関数の2つの引数形式は、 &lt;code&gt;&quot;-|&quot;&lt;/code&gt; いずれかのファイル引数を受け入れます。または &lt;code&gt;&quot;|-&quot;&lt;/code&gt; は非常に興味深いことをします：それはあなたが開いたファイルハンドルに接続された子をフォークします。子は親と同じプログラムを実行しています。これは、たとえば、想定されるUIDまたはGIDで実行しているときに、ファイルを安全に開くのに役立ちます。パイプを開けたら</target>
        </trans-unit>
        <trans-unit id="075cc903bac6f7e2aa6bd64ab5e44c58b488750c" translate="yes" xml:space="preserve">
          <source>Another interesting signal to send is signal number zero. This doesn't actually affect a child process, but instead checks whether it's alive or has changed its UIDs.</source>
          <target state="translated">もう一つの興味深いシグナルとして、シグナル番号ゼロがあります。これは実際には子プロセスには影響を与えませんが、その代わりに子プロセスが生きているか、UIDが変更されたかをチェックします。</target>
        </trans-unit>
        <trans-unit id="5625c9da79ea74fa11d7487b4856a60b8a448f5c" translate="yes" xml:space="preserve">
          <source>Another interface for querying locale-dependent information is the &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; function, available at least in Unix-like systems and VMS.</source>
          <target state="translated">ロケール依存情報を照会するためのもう1つのインターフェースは、 &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; 関数です。これは、少なくともUnixライクなシステムとVMSで使用できます。</target>
        </trans-unit>
        <trans-unit id="b2c6ea999a64bd42bd0c393eb0d4d13d68bfe00e" translate="yes" xml:space="preserve">
          <source>Another interface for querying locale-dependent information is the &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; function.</source>
          <target state="translated">ロケールに依存する情報を照会するためのもう1つのインターフェースは、 &lt;code&gt;I18N::Langinfo::langinfo()&lt;/code&gt; 関数です。</target>
        </trans-unit>
        <trans-unit id="7e0169360cab902c54c29d1ed679e73f96ea0a5a" translate="yes" xml:space="preserve">
          <source>Another is</source>
          <target state="translated">もう一つは</target>
        </trans-unit>
        <trans-unit id="7cdba3e1788bc415b19d9a9a11cdf704cabf535e" translate="yes" xml:space="preserve">
          <source>Another kind of client-server setup is one that uses not connections, but messages. UDP communications involve much lower overhead but also provide less reliability, as there are no promises that messages will arrive at all, let alone in order and unmangled. Still, UDP offers some advantages over TCP, including being able to &quot;broadcast&quot; or &quot;multicast&quot; to a whole bunch of destination hosts at once (usually on your local subnet). If you find yourself overly concerned about reliability and start building checks into your message system, then you probably should use just TCP to start with.</source>
          <target state="translated">もう一つの種類のクライアント・サーバのセットアップは、接続ではなくメッセージを使用するものです。UDP通信では、オーバーヘッドがはるかに低くなりますが、メッセージが順番通りに到着するという約束がないため、信頼性も低くなります。しかし、UDPはTCPよりもいくつかの利点があり、一度にたくさんの宛先ホスト(通常はローカルサブネット上)に「ブロードキャスト」や「マルチキャスト」ができるなどの利点があります。信頼性を過度に気にして、メッセージシステムにチェック機能を組み込むようになった場合は、最初からTCPだけを使うべきでしょう。</target>
        </trans-unit>
        <trans-unit id="15bc936b8bd7810df3b41eba0889fe66dfa9061e" translate="yes" xml:space="preserve">
          <source>Another memory limiting item to check is your MAXASSIZE parameter in your 'SYS1.PARMLIB(BPXPRMxx)' data set (note too that as of V2R8 address space limits can be set on a per user ID basis in the USS segment of a RACF profile). People have reported successful builds of Perl with MAXASSIZE parameters as small as 503316480 (and it may be possible to build Perl with a MAXASSIZE smaller than that).</source>
          <target state="translated">チェックすべきもう一つのメモリ制限項目は、'SYS1.PARMLIB(BPXPRMxx)' データセットの MAXASSIZE パラメータです(V2R8 では、RACF プロファイルの USS セグメントでユーザ ID ごとにアドレス空間の制限を設定できることにも注意してください)。人々は、MAXASSIZEパラメータが503316480と小さいPerlのビルドに成功したと報告しています(そして、それより小さいMAXASSIZEでPerlをビルドすることが可能かもしれません)。</target>
        </trans-unit>
        <trans-unit id="7f12c23dd22baed9e55a21bc829f2cdbb2990e89" translate="yes" xml:space="preserve">
          <source>Another mnemonic for this modifier is &quot;Depends&quot;, as the rules actually used depend on various things, and as a result you can get unexpected results. See &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;. The Unicode Bug has become rather infamous, leading to yet another (without swearing) name for this modifier, &quot;Dodgy&quot;.</source>
          <target state="translated">この修飾子のもう1つのニーモニックは、「依存」です。実際に使用されるルールはさまざまなものに依存するため、結果として予期しない結果が生じる可能性があります。&lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicodeの「「Unicodeバグ」」を&lt;/a&gt;参照してください。Unicodeバグはかなり悪名高くなり、この修飾子のさらに別の（罵倒することなく）名前「Dodgy」につながりました。</target>
        </trans-unit>
        <trans-unit id="ce05ce9dfc0d776de0b8b42183a9011dbca61f46" translate="yes" xml:space="preserve">
          <source>Another mnemonic for this modifier is &quot;Depends&quot;, as the rules actually used depend on various things, and as a result you can get unexpected results. See &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;The Unicode Bug in perlunicode&lt;/a&gt;. The Unicode Bug has become rather infamous, leading to yet another (printable) name for this modifier, &quot;Dodgy&quot;.</source>
          <target state="translated">この修飾子のもう1つのニーモニックは「依存」です。実際に使用されるルールはさまざまなものに依存し、その結果、予期しない結果が生じる可能性があるためです。&lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;perlunicodeのUnicodeバグを&lt;/a&gt;参照してください。 Unicodeバグはかなり悪名高いものになり、この修飾子の「印刷可能な」名前が「Dodgy」に変わりました。</target>
        </trans-unit>
        <trans-unit id="df7cbfe3fb975c17e692f6a855e0332ef03824f0" translate="yes" xml:space="preserve">
          <source>Another nonstandard extension to the JSON syntax, enabled with the &lt;code&gt;allow_tags&lt;/code&gt; setting, are tagged values. In this implementation, the</source>
          <target state="translated">&lt;code&gt;allow_tags&lt;/code&gt; 設定で有効にされるJSON構文のもう1つの非標準拡張は、タグ付きの値です。この実装では、</target>
        </trans-unit>
        <trans-unit id="3cfb16782780267975128af9b462f0c7f8f09971" translate="yes" xml:space="preserve">
          <source>Another odd-man-out in the template alphabet is &lt;code&gt;u&lt;/code&gt; , which packs a &quot;uuencoded string&quot;. (&quot;uu&quot; is short for Unix-to-Unix.) Chances are that you won't ever need this encoding technique which was invented to overcome the shortcomings of old-fashioned transmission mediums that do not support other than simple ASCII data. The essential recipe is simple: Take three bytes, or 24 bits. Split them into 4 six-packs, adding a space (0x20) to each. Repeat until all of the data is blended. Fold groups of 4 bytes into lines no longer than 60 and garnish them in front with the original byte count (incremented by 0x20) and a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at the end. - The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; chef will prepare this for you, a la minute, when you select pack code &lt;code&gt;u&lt;/code&gt; on the menu:</source>
          <target state="translated">テンプレートアルファベットのもう1つの奇妙な例は &lt;code&gt;u&lt;/code&gt; で、これは「uuencoded文字列」をパックします。 （「uu」はUnix-to-Unixの略です。）単純なASCIIデータ以外をサポートしていない旧式の伝送媒体の欠点を克服するために発明されたこのエンコード手法は、おそらく必要ないでしょう。基本的なレシピは簡単です。3バイト、つまり24ビットを使用します。それらを4つの6パックに分割し、それぞれにスペース（0x20）を追加します。すべてのデータがブレンドされるまで繰り返します。 4バイトのグループを60行以下に折りたたみ、元のバイトカウント（0x20ずつ増加）と最後に &lt;code&gt;&quot;\n&quot;&lt;/code&gt; を前に付けます。 - メニューでパックコード &lt;code&gt;u&lt;/code&gt; を選択すると、 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; シェフがすぐに準備します。</target>
        </trans-unit>
        <trans-unit id="0815afa133e3357f3c224c29010f1fab6f9eb77d" translate="yes" xml:space="preserve">
          <source>Another odd-man-out in the template alphabet is &lt;code&gt;u&lt;/code&gt;, which packs a &quot;uuencoded string&quot;. (&quot;uu&quot; is short for Unix-to-Unix.) Chances are that you won't ever need this encoding technique which was invented to overcome the shortcomings of old-fashioned transmission mediums that do not support other than simple ASCII data. The essential recipe is simple: Take three bytes, or 24 bits. Split them into 4 six-packs, adding a space (0x20) to each. Repeat until all of the data is blended. Fold groups of 4 bytes into lines no longer than 60 and garnish them in front with the original byte count (incremented by 0x20) and a &lt;code&gt;&quot;\n&quot;&lt;/code&gt; at the end. - The &lt;code&gt;pack&lt;/code&gt; chef will prepare this for you, a la minute, when you select pack code &lt;code&gt;u&lt;/code&gt; on the menu:</source>
          <target state="translated">テンプレートアルファベットのもう1つの奇妙な点は、「uuencodeされた文字列」をパックする &lt;code&gt;u&lt;/code&gt; です。 （「uu」はUnix-to-Unixの略です。）単純なASCIIデータ以外をサポートしない昔ながらの伝送媒体の欠点を克服するために発明されたこのエンコード技術は必要ない可能性があります。基本的なレシピは単純です。3バイトまたは24ビットを使用します。それらを4つの6パックに分割し、それぞれにスペース（0x20）を追加します。すべてのデータがブレンドされるまで繰り返します。 4バイトのグループを60以下の行に折り、前に元のバイト数（0x20ずつ増加）と最後に &lt;code&gt;&quot;\n&quot;&lt;/code&gt; を付けます。 -メニューでパックコード &lt;code&gt;u&lt;/code&gt; を選択すると、 &lt;code&gt;pack&lt;/code&gt; シェフがこれを準備します。</target>
        </trans-unit>
        <trans-unit id="f3b90d55edc9bd711b381039fe4df0f81ca8e910" translate="yes" xml:space="preserve">
          <source>Another operator with surprising precedence is exponentiation. It binds more tightly even than unary minus, making &lt;code&gt;-2**2&lt;/code&gt; produce a negative four and not a positive one. It is also right-associating, meaning that &lt;code&gt;2**3**2&lt;/code&gt; is two raised to the ninth power, not eight squared.</source>
          <target state="translated">驚くべき優先順位を持つもう1つの演算子は指数です。単項マイナスよりも強く結合し、 &lt;code&gt;-2**2&lt;/code&gt; は正の1ではなく負の4を生成します。また、右に関連しています。つまり、 &lt;code&gt;2**3**2&lt;/code&gt; は、8の2乗ではなく、2の9乗です。</target>
        </trans-unit>
        <trans-unit id="0a8ead7308fc061719df6bc244f6348d6cfaf232" translate="yes" xml:space="preserve">
          <source>Another optimisation that can occur is that of &quot;&lt;code&gt;EXACT&lt;/code&gt; merging&quot; which is where two consecutive &lt;code&gt;EXACT&lt;/code&gt; nodes are merged into a single regop. An even more aggressive form of this is that a branch sequence of the form &lt;code&gt;EXACT BRANCH ... EXACT&lt;/code&gt; can be converted into a &lt;code&gt;TRIE-EXACT&lt;/code&gt; regop.</source>
          <target state="translated">発生する可能性のある別の最適化は、2つの連続する &lt;code&gt;EXACT&lt;/code&gt; ノードが1つのレゴップにマージされる「 &lt;code&gt;EXACT&lt;/code&gt; merging 」の最適化です。これのさらに強力な形式は、 &lt;code&gt;EXACT BRANCH ... EXACT&lt;/code&gt; という形式の分岐シーケンスをTRIE &lt;code&gt;TRIE-EXACT&lt;/code&gt; regopに変換できることです。</target>
        </trans-unit>
        <trans-unit id="bd2c2ceaa1b82e7064a95fc5a1daa0bbc069a63f" translate="yes" xml:space="preserve">
          <source>Another option for Perls starting with 5.16, if you only care about ASCII matches, is to add the &lt;code&gt;/aa&lt;/code&gt; modifier to the regex. This will exclude all these non-obvious matches, thus getting rid of this message. You can also say</source>
          <target state="translated">ASCII一致のみを気にする場合、5.16以降のPerlの別のオプションは、正規表現に &lt;code&gt;/aa&lt;/code&gt; 修飾子を追加することです。これにより、これらの非自明な一致がすべて除外されるため、このメッセージは削除されます。あなたも言うことができます</target>
        </trans-unit>
        <trans-unit id="6aabd99f333ab712e259e5fbe14c5365c3fb3eb5" translate="yes" xml:space="preserve">
          <source>Another option is to use the &lt;code&gt;iter&lt;/code&gt; class method to iterate over the files in the tarball without reading them all in memory at once.</source>
          <target state="translated">別のオプションは、 &lt;code&gt;iter&lt;/code&gt; クラスメソッドを使用して、メモリ内のファイルを一度にすべて読み取ることなく、tarball内のファイルを反復処理することです。</target>
        </trans-unit>
        <trans-unit id="82d37f84faabd12d777cc2ff160de45bc66b098d" translate="yes" xml:space="preserve">
          <source>Another option is to use the make written in Perl, available from CPAN.</source>
          <target state="translated">もう一つの選択肢は、CPANから入手できるPerlで書かれたmakeを使用することです。</target>
        </trans-unit>
        <trans-unit id="655a86d88b6839dd2179128ff91b78ce22ba6c96" translate="yes" xml:space="preserve">
          <source>Another peculiarity of urllist is that the site that we could successfully fetch the last file from automatically gets a preference token and is tried as the first site for the next request. So if you add a new site at runtime it may happen that the previously preferred site will be tried another time. This means that if you want to disallow a site for the next transfer, it must be explicitly removed from urllist.</source>
          <target state="translated">urllist のもう一つの特徴は、最後のファイルの取得に成功したサイトが自動的にプリファレンストークンを取得し、次のリクエストの最初のサイトとして試行されることです。そのため、実行時に新しいサイトを追加した場合、以前に優先されていたサイトが再度試行される可能性があります。つまり、次の転送でサイトを許可しないようにしたい場合は、明示的に urllist から削除しなければなりません。</target>
        </trans-unit>
        <trans-unit id="ce6cb12c61e008cd3f2b006405f6306cfa9808f3" translate="yes" xml:space="preserve">
          <source>Another point worth noting is that in the first series of examples I have made use of only the</source>
          <target state="translated">もう一つの注目すべき点は、最初の一連の例で、私が使用したのは</target>
        </trans-unit>
        <trans-unit id="4398365ad3174110f099b9553fe6a9ab1f982409" translate="yes" xml:space="preserve">
          <source>Another popular use for &lt;code&gt;recompile&lt;/code&gt; is to act as a rescue in case your perl breaks binary compatibility. If one of the modules that CPAN uses is in turn depending on binary compatibility (so you cannot run CPAN commands), then you should try the CPAN::Nox module for recovery.</source>
          <target state="translated">&lt;code&gt;recompile&lt;/code&gt; もう1つの一般的な用途は、perlがバイナリ互換性を破った場合の救済として機能することです。CPANが使用するモジュールの1つがバイナリ互換性に依存している（CPANコマンドを実行できない）場合は、CPAN :: Noxモジュールを使用して回復を試みる必要があります。</target>
        </trans-unit>
        <trans-unit id="9d8cd00450b93b9762fe1f4860bcee6a18ea20de" translate="yes" xml:space="preserve">
          <source>Another possibility is that you forgot a backslash. Perl isn't smart enough to figure out what you really meant.</source>
          <target state="translated">もう一つの可能性としては、バックスラッシュを忘れたということが考えられます。Perlはあなたが本当に言いたいことを理解するほど賢くはありません。</target>
        </trans-unit>
        <trans-unit id="385e095c764654e0fb183ec8deedb8c0e3232a76" translate="yes" xml:space="preserve">
          <source>Another possible reason for problems is that you've used the indirect object syntax (eg, &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt; ) on a class name before Perl has seen that such a package exists. It's wisest to make sure your packages are all defined before you start using them, which will be taken care of if you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement instead of &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;. If not, make sure to use arrow notation (eg., &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt; ) instead. Object notation is explained in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">問題のもう1つの考えられる理由は、Perlがそのようなパッケージの存在を確認する前に、クラス名で間接オブジェクト構文（たとえば、 &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt; ）を使用したことです。パッケージの使用を開始する前に、パッケージがすべて定義されていることを確認するのが最も賢明です。requireの代わりに &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; ステートメントを使用すると、パッケージが処理され &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 。そうでない場合は、代わりに矢印表記を使用してください（例： &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt; ）。オブジェクトの表記法は&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;で説明されています。</target>
        </trans-unit>
        <trans-unit id="fb10e4ab85598fb1febe5de364db832f8ae6b33d" translate="yes" xml:space="preserve">
          <source>Another possible reason for problems is that you've used the indirect object syntax (eg, &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt;) on a class name before Perl has seen that such a package exists. It's wisest to make sure your packages are all defined before you start using them, which will be taken care of if you use the &lt;code&gt;use&lt;/code&gt; statement instead of &lt;code&gt;require&lt;/code&gt;. If not, make sure to use arrow notation (eg., &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt;) instead. Object notation is explained in &lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;.</source>
          <target state="translated">問題のもう1つの考えられる理由は、Perlがそのようなパッケージが存在することを認識する前に、クラス名に間接目的語構文を使用したことです（たとえば、 &lt;code&gt;find Guru &quot;Samy&quot;&lt;/code&gt; ）。パッケージを使用する前に、パッケージがすべて定義されていることを確認するのが最も賢明 &lt;code&gt;require&lt;/code&gt; 。これは、requireの代わりに &lt;code&gt;use&lt;/code&gt; ステートメントを使用する場合に処理されます。そうでない場合は、代わりに矢印表記（ &lt;code&gt;Guru-&amp;gt;find(&quot;Samy&quot;)&lt;/code&gt; など）を使用してください。オブジェクト表記は&lt;a href=&quot;perlobj&quot;&gt;perlobj&lt;/a&gt;で説明されています。</target>
        </trans-unit>
        <trans-unit id="c972997167e011df9a56046ecd4a5023cc5037ca" translate="yes" xml:space="preserve">
          <source>Another problem that occurs with inside-out classes is serialization. Since the object data is not in its usual place, standard routines like &lt;code&gt;Storable::freeze()&lt;/code&gt; , &lt;code&gt;Storable::thaw()&lt;/code&gt; and &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; can't deal with it on their own. Both &lt;code&gt;Data::Dumper&lt;/code&gt; and &lt;code&gt;Storable&lt;/code&gt; provide the necessary hooks to make things work, but the functions or methods used by the hooks must be provided by each inside-out class.</source>
          <target state="translated">裏返しのクラスで発生する別の問題は、シリアル化です。オブジェクトデータは通常の場所にないため、 &lt;code&gt;Storable::freeze()&lt;/code&gt; 、 &lt;code&gt;Storable::thaw()&lt;/code&gt; 、 &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; Dumper :: Dumper （）などの標準ルーチンは、それ自体では処理できません。 &lt;code&gt;Data::Dumper&lt;/code&gt; &lt;code&gt;Storable&lt;/code&gt; とStorableはどちらも、物事を機能させるために必要なフックを提供しますが、フックによって使用される関数またはメソッドは、各インサイドアウトクラスによって提供される必要があります。</target>
        </trans-unit>
        <trans-unit id="0ea375285a64fb396aba7ed50ea3def9a1613d41" translate="yes" xml:space="preserve">
          <source>Another problem that occurs with inside-out classes is serialization. Since the object data is not in its usual place, standard routines like &lt;code&gt;Storable::freeze()&lt;/code&gt;, &lt;code&gt;Storable::thaw()&lt;/code&gt; and &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; can't deal with it on their own. Both &lt;code&gt;Data::Dumper&lt;/code&gt; and &lt;code&gt;Storable&lt;/code&gt; provide the necessary hooks to make things work, but the functions or methods used by the hooks must be provided by each inside-out class.</source>
          <target state="translated">インサイドアウトクラスで発生するもう1つの問題は、シリアル化です。オブジェクトデータは通常の場所にないため、 &lt;code&gt;Storable::freeze()&lt;/code&gt; 、 &lt;code&gt;Storable::thaw()&lt;/code&gt; 、 &lt;code&gt;Data::Dumper::Dumper()&lt;/code&gt; Dumper :: Dumper （）などの標準ルーチンはそれ自体を処理できません。 &lt;code&gt;Data::Dumper&lt;/code&gt; &lt;code&gt;Storable&lt;/code&gt; とStorableはどちらも、物事を機能させるために必要なフックを提供しますが、フックによって使用される関数またはメソッドは、各裏返しのクラスによって提供される必要があります。</target>
        </trans-unit>
        <trans-unit id="4838334963e3cee1c557a4f6afcd664375d054be" translate="yes" xml:space="preserve">
          <source>Another problem with this approach is that operations that cross the single byte/multiple byte boundary are not well-defined, and so are disallowed. (This boundary is between the codepoints at 255/256.) For example, lower casing LATIN CAPITAL LETTER Y WITH DIAERESIS (U+0178) should return LATIN SMALL LETTER Y WITH DIAERESIS (U+00FF). But in the Greek locale, for example, there is no character at 0xFF, and Perl has no way of knowing what the character at 0xFF is really supposed to represent. Thus it disallows the operation. In this mode, the lowercase of U+0178 is itself.</source>
          <target state="translated">このアプローチのもう一つの問題点は、シングルバイト/マルチバイトの境界を越える操作は十分に定義されていないため、許可されないということです(この境界は255/256のコードポイントの間にあります)。(この境界は255/256のコードポイントの間にあります。)例えば、小文字のLATIN CAPITAL LETTER Y WITH DIAERESIS (U+0178)は、LATIN SMALL LETTER Y WITH DIAERESIS (U+00FF)を返すべきです。しかし、例えばギリシャ語ロケールでは、0xFFには文字がなく、Perlは0xFFの文字が実際に何を表しているのかを知る方法がありません。そのため、Perl はこの操作を無効にします。このモードでは、U+0178の小文字はそれ自体です。</target>
        </trans-unit>
        <trans-unit id="e3482e337a3d87721af4bdffd6d9b7cb27fdfc8f" translate="yes" xml:space="preserve">
          <source>Another reason it isn't completely a drop-in replacement is that it is declared to return &lt;code&gt;const char *&lt;/code&gt;, whereas the system setlocale omits the &lt;code&gt;const&lt;/code&gt; (presumably because its API was specified long ago, and can't be updated; it is illegal to change the information &lt;code&gt;setlocale&lt;/code&gt; returns; doing so leads to segfaults.)</source>
          <target state="translated">完全にドロップイン置換ではないもう1つの理由は、 &lt;code&gt;const char *&lt;/code&gt; を返すように宣言されているのに対し、システムsetlocaleは &lt;code&gt;const&lt;/code&gt; を省略しているためです（おそらく、APIがずっと前に指定されていて、更新できないため、違法です。 &lt;code&gt;setlocale&lt;/code&gt; が返す情報を変更するには、そうするとセグメンテーション違反が発生します。）</target>
        </trans-unit>
        <trans-unit id="1d25e58d1b57cecb55c387a5dd5c52709e7a7cf9" translate="yes" xml:space="preserve">
          <source>Another reason that folks sometimes think they want a variable to contain the name of a variable is that they don't know how to build proper data structures using hashes. For example, let's say they wanted two hashes in their program: %fred and %barney, and that they wanted to use another scalar variable to refer to those by name.</source>
          <target state="translated">変数に変数名を入れたいと考えるもう一つの理由は、ハッシュを使って適切なデータ構造を構築する方法を知らないということです。例えば、プログラムの中で 2 つのハッシュが必要だったとします。fred と %barney で、これらを名前で参照するために別のスカラ変数を使用したいとします。</target>
        </trans-unit>
        <trans-unit id="0421a2fa7b166fbdb782231a9f8dbd1fd87115e8" translate="yes" xml:space="preserve">
          <source>Another reason to use &lt;code&gt;HASH&lt;/code&gt; is to provide your own hash variable. You can then inspect or modify the contents of the hash to gain finer control over the cache management.</source>
          <target state="translated">&lt;code&gt;HASH&lt;/code&gt; を使用するもう1つの理由は、独自のハッシュ変数を提供することです。その後、ハッシュの内容を検査または変更して、キャッシュ管理をより細かく制御できます。</target>
        </trans-unit>
        <trans-unit id="1d033aa9337856f2221026f5c7e24c794df0edbb" translate="yes" xml:space="preserve">
          <source>Another sample module, &lt;a href=&quot;Memoize::Saves&quot;&gt;Memoize::Saves&lt;/a&gt;, is available in a separate distribution on CPAN. It implements a policy that allows you to specify that certain function values would always be looked up afresh. See the documentation for details.</source>
          <target state="translated">別のサンプルモジュールである&lt;a href=&quot;Memoize::Saves&quot;&gt;Memoize :: Savesは&lt;/a&gt;、CPANの別のディストリビューションで入手できます。これは、特定の関数値が常に新たに検索されるように指定できるポリシーを実装しています。詳細については、ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="8b8bed8e10e25cfa736414741ddf1e9e2d2b9072" translate="yes" xml:space="preserve">
          <source>Another sample module, &lt;a href=&quot;http://search.cpan.org/perldoc/Memoize::Saves&quot;&gt;Memoize::Saves&lt;/a&gt;, is available in a separate distribution on CPAN. It implements a policy that allows you to specify that certain function values would always be looked up afresh. See the documentation for details.</source>
          <target state="translated">別のサンプルモジュール&lt;a href=&quot;http://search.cpan.org/perldoc/Memoize::Saves&quot;&gt;Memoize :: Savesは&lt;/a&gt;、CPANの別のディストリビューションで入手できます。特定の関数値が常に新しく検索されるように指定できるポリシーを実装しています。詳細については、ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="5d1b15340e7ecbdf1f65260c165ba0bcb3105f71" translate="yes" xml:space="preserve">
          <source>Another subtle error that can occur in resolving prerequisites comes from the way that modules in prerequisites are indexed to distribution files on CPAN. When a module is deleted from a distribution, prerequisites calling for that module could indicate an older distribution should be installed, potentially overwriting files from a newer distribution.</source>
          <target state="translated">前提条件の解決で発生する可能性のあるもう1つの微妙なエラーは、前提条件のモジュールがCPANのディストリビューションファイルにインデックス付けされる方法にあります。モジュールがディストリビューションから削除された場合、そのモジュールを呼び出す前提条件は、古いディストリビューションをインストールする必要があることを示し、新しいディストリビューションのファイルを上書きする可能性があります。</target>
        </trans-unit>
        <trans-unit id="f67a475c6b156df5eac51c84854028a80181079b" translate="yes" xml:space="preserve">
          <source>Another thing to try is learning whether your Perl was compiled with the system malloc or with Perl's builtin malloc. Whichever one it is, try using the other one and see whether this makes a difference. Information about malloc is in the</source>
          <target state="translated">もう一つは、Perl がシステムの malloc でコンパイルされたのか、Perl の組み込み malloc でコンパイルされたのかを知ることです。どちらか一方を使ってみて、違いがあるかどうかを確認してください。malloc に関する情報は</target>
        </trans-unit>
        <trans-unit id="a1cb48749447600d090febf98d3e4d0e00ee484e" translate="yes" xml:space="preserve">
          <source>Another thing you should bear in mind is that the UNINST parameter can be dangerous when you are installing into a private area because you might accidentally remove modules that other people depend on that are not using the private area.</source>
          <target state="translated">もう一つ覚えておいてほしいのは、プライベートエリアにインストールする際に UNINST パラメータが危険な場合があるということです。</target>
        </trans-unit>
        <trans-unit id="254082198376f41ade29efc6ce1df2a3ebdfd235" translate="yes" xml:space="preserve">
          <source>Another thorough remedy to that runtime vs. compile-time trap is to use &lt;a href=&quot;Exporter::Easy&quot;&gt;Exporter::Easy&lt;/a&gt;, which is a wrapper of Exporter that allows all boilerplate code at a single gulp in the use statement.</source>
          <target state="translated">そのランタイムとコンパイル時のトラップに対するもう1つの徹底的な解決策は、&lt;a href=&quot;Exporter::Easy&quot;&gt;Exporter :: Easyを&lt;/a&gt;使用することです。これは、useステートメントですべての定型コードを一気に許可するExporterのラッパーです。</target>
        </trans-unit>
        <trans-unit id="fc7600b26c92e308f5a7b9737781947f5e033b05" translate="yes" xml:space="preserve">
          <source>Another thorough remedy to that runtime vs. compile-time trap is to use &lt;a href=&quot;http://search.cpan.org/perldoc/Exporter::Easy&quot;&gt;Exporter::Easy&lt;/a&gt;, which is a wrapper of Exporter that allows all boilerplate code at a single gulp in the use statement.</source>
          <target state="translated">ランタイムトラップとコンパイル時のトラップに対するもう1つの完全な救済策は、&lt;a href=&quot;http://search.cpan.org/perldoc/Exporter::Easy&quot;&gt;Exporter :: Easy&lt;/a&gt;を使用することです。これは、すべてのボイラープレートコードをuseステートメントの単一のgrupで許可するExporterのラッパーです。</target>
        </trans-unit>
        <trans-unit id="8f128db16727c4206b263e3f2e5e2f91028aada1" translate="yes" xml:space="preserve">
          <source>Another typical use of redispatch would be in &lt;code&gt;AUTOLOAD&lt;/code&gt; 'ed methods. If such a method determined that it was not able to handle a particular call, it might choose to redispatch that call, in the hope that some other &lt;code&gt;AUTOLOAD&lt;/code&gt; (above it, or to its left) might do better.</source>
          <target state="translated">再ディスパッチのもう1つの一般的な使用法は、 &lt;code&gt;AUTOLOAD&lt;/code&gt; されたメソッドでの使用です。そのようなメソッドが特定の呼び出しを処理できなかったと判断した場合、他の &lt;code&gt;AUTOLOAD&lt;/code&gt; （その上またはその左側）の方がうまくいくと期待して、その呼び出しを再ディスパッチすることを選択する場合があります。</target>
        </trans-unit>
        <trans-unit id="c4228b8c62bb634355292e1e3ac8e4544658301e" translate="yes" xml:space="preserve">
          <source>Another typical use of redispatch would be in &lt;code&gt;AUTOLOAD&lt;/code&gt;'ed methods. If such a method determined that it was not able to handle a particular call, it might choose to redispatch that call, in the hope that some other &lt;code&gt;AUTOLOAD&lt;/code&gt; (above it, or to its left) might do better.</source>
          <target state="translated">再ディスパッチのもう1つの典型的な使用法は、 &lt;code&gt;AUTOLOAD&lt;/code&gt; のメソッドです。そのようなメソッドが特定の呼び出しを処理できなかったと判断した場合、他の &lt;code&gt;AUTOLOAD&lt;/code&gt; （その上または左）がより適切に機能することを期待して、その呼び出しを再ディスパッチすることを選択する場合があります。</target>
        </trans-unit>
        <trans-unit id="28f35e8d306941d11adce5505a92ca2044351acf" translate="yes" xml:space="preserve">
          <source>Another unofficial source of data. Currently, it is not used to get data, but the notes and explanatory material were very useful for understanding discrepancies between the sources.</source>
          <target state="translated">もう一つの非公式なデータソース。現在はデータ取得には使われていませんが、ノートや解説資料はソース間の齟齬を把握するのに非常に役立ちました。</target>
        </trans-unit>
        <trans-unit id="a159ba74ceaa166e4b6d8831134290b3cd8265be" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;MERGE&lt;/code&gt; is when you want both kinds of return values stored in the same disk file; this saves you from having to deal with two disk files instead of one. You can use a normalizer function to keep the two sets of return values separate. For example:</source>
          <target state="translated">&lt;code&gt;MERGE&lt;/code&gt; のもう1つの用途は、両方の種類の戻り値を同じディスクファイルに格納する場合です。これにより、1つではなく2つのディスクファイルを処理する必要がなくなります。ノーマライザ関数を使用して、2つのセットの戻り値を分離することができます。例えば：</target>
        </trans-unit>
        <trans-unit id="3dd7e16e7ef3fb6df50c7af26f6bc9d68c338053" translate="yes" xml:space="preserve">
          <source>Another use for a closure is to make a variable</source>
          <target state="translated">クロージャのもう一つの用途は、変数を</target>
        </trans-unit>
        <trans-unit id="5cec4425942c518509d1fda3df7b77a63ebbfefa" translate="yes" xml:space="preserve">
          <source>Another use for escape sequences is to specify characters that cannot (or which you prefer not to) be written literally. These are described in detail in &lt;a href=&quot;perlrebackslash#Character-Escapes&quot;&gt;&quot;Character Escapes&quot; in perlrebackslash&lt;/a&gt;, but the next three paragraphs briefly describe some of them.</source>
          <target state="translated">エスケープシーケンスのもう1つの用途は、文字通りに記述できない（または記述したくない）文字を指定することです。これらは&lt;a href=&quot;perlrebackslash#Character-Escapes&quot;&gt;、perlrebackslashの「CharacterEscapes」&lt;/a&gt;で詳細に説明されていますが、次の3つの段落ではそれらのいくつかについて簡単に説明しています。</target>
        </trans-unit>
        <trans-unit id="a46f51ca5d9afdb7291b96d0559a5eecba4e7c63" translate="yes" xml:space="preserve">
          <source>Another use for normalizers is when the function depends on data other than those in its arguments. Suppose you have a function which returns a value which depends on the current hour of the day:</source>
          <target state="translated">ノーマライザのもう一つの用途は、関数が引数以外のデータに依存している場合です。一日の現在の時間に依存した値を返す関数があるとしましょう。</target>
        </trans-unit>
        <trans-unit id="62444c7bc781846313fe8302369f08d7688eae95" translate="yes" xml:space="preserve">
          <source>Another use for the INIT: section is to check for preconditions before making a call to the C function:</source>
          <target state="translated">INIT:セクションのもう一つの用途は、C関数を呼び出す前に前提条件をチェックすることです。</target>
        </trans-unit>
        <trans-unit id="3a9f1ae19985a41ad9db3a10b2882d84afcc8d3c" translate="yes" xml:space="preserve">
          <source>Another use for typeglobs is to pass filehandles into a function or to create new filehandles. If you need to use a typeglob to save away a filehandle, do it this way:</source>
          <target state="translated">タイプグローブのもう一つの用途は、ファイルハンドルを関数に渡したり、新しいファイルハンドルを作成したりすることです。ファイルハンドルを保存するためにタイプグローブを使用する必要がある場合は、このようにしてください。</target>
        </trans-unit>
        <trans-unit id="bd85fb00e79bd02a66b771e2ae402c322124bc55" translate="yes" xml:space="preserve">
          <source>Another use is to indicate that</source>
          <target state="translated">という使い方もあります。</target>
        </trans-unit>
        <trans-unit id="385eea7f2546356b9012fe969f08ace72fffebdd" translate="yes" xml:space="preserve">
          <source>Another use of symbol tables is for making &quot;constant&quot; scalars.</source>
          <target state="translated">シンボルテーブルのもう一つの用途は、「定数」のスカラーを作るためのものです。</target>
        </trans-unit>
        <trans-unit id="7e444bc856c81853904c1c90381dc826b2163cfa" translate="yes" xml:space="preserve">
          <source>Another use of the generic object would be as a template. It is a convenient place to store class-specific defaults for various fields to be used in actual object initialization.</source>
          <target state="translated">ジェネリック・オブジェクトのもう一つの用途は、テンプレートとしての利用でしょう。これは、実際のオブジェクトの初期化で使用される様々なフィールドのクラス固有のデフォルトを格納するのに便利な場所です。</target>
        </trans-unit>
        <trans-unit id="03d707d0fcf79e0d7b50ca27287f1758fef3a3d9" translate="yes" xml:space="preserve">
          <source>Another useful shortcut is that, if you use a literal array or hash as the argument to &lt;code&gt;given&lt;/code&gt; , it is turned into a reference. So &lt;code&gt;given(@foo)&lt;/code&gt; is the same as &lt;code&gt;given(\@foo)&lt;/code&gt; , for example.</source>
          <target state="translated">別の便利なショートカットは、リテラル配列またはハッシュを &lt;code&gt;given&lt;/code&gt; の引数として使用すると、それが参照に変わることです。したがって、 &lt;code&gt;given(@foo)&lt;/code&gt; は &lt;code&gt;given(\@foo)&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="cc6a78b5df54e2e6affa44db83d9141a9a6580a8" translate="yes" xml:space="preserve">
          <source>Another useful shortcut is that, if you use a literal array or hash as the argument to &lt;code&gt;given&lt;/code&gt;, it is turned into a reference. So &lt;code&gt;given(@foo)&lt;/code&gt; is the same as &lt;code&gt;given(\@foo)&lt;/code&gt;, for example.</source>
          <target state="translated">もう1つの便利なショートカットは、 &lt;code&gt;given&lt;/code&gt; への引数としてリテラル配列またはハッシュを使用すると、それが参照に変換されることです。したがって、 &lt;code&gt;given(@foo)&lt;/code&gt; は &lt;code&gt;given(\@foo)&lt;/code&gt; と同じです。</target>
        </trans-unit>
        <trans-unit id="4a05112cda91b50dc34bb4913074b7fa53fabce3" translate="yes" xml:space="preserve">
          <source>Another variation on a theme. This time we will modify the &lt;code&gt;Subst&lt;/code&gt; filter to allow a starting and stopping pattern to be specified as well as the</source>
          <target state="translated">テーマの別のバリエーション。今回は、 &lt;code&gt;Subst&lt;/code&gt; フィルターを変更して、開始パターンと停止パターン、および</target>
        </trans-unit>
        <trans-unit id="95d0ad8589b46d03f061e120707df66c84d9cbde" translate="yes" xml:space="preserve">
          <source>Another version uses a global match in list context, then assigns the result to a scalar, producing a count of the number of matches.</source>
          <target state="translated">別のバージョンでは、リストコンテキストでグローバルマッチを使用し、その結果をスカラに代入してマッチ数をカウントします。</target>
        </trans-unit>
        <trans-unit id="a0589db0a4f4f29bef401c1107ff7696f0cffdbb" translate="yes" xml:space="preserve">
          <source>Another way is to assign to a substr() that's off the end of the string.</source>
          <target state="translated">もう一つの方法は、文字列の末尾から外れた部分をsubstr()に代入することです。</target>
        </trans-unit>
        <trans-unit id="d77d43e614a814160a75653eb86a2b6f1db8267e" translate="yes" xml:space="preserve">
          <source>Another way is to use the &lt;a href=&quot;Tie::File&quot;&gt;Tie::File&lt;/a&gt; module, which treats the entire file as an array. Simply access a random array element.</source>
          <target state="translated">もう1つの方法は、ファイル全体を配列として扱う&lt;a href=&quot;Tie::File&quot;&gt;Tie :: File&lt;/a&gt;モジュールを使用することです。ランダムな配列要素にアクセスするだけです。</target>
        </trans-unit>
        <trans-unit id="3c83abcaae94dfa04aa0d7e9c83f8b2a9880cd1b" translate="yes" xml:space="preserve">
          <source>Another way is to use the &lt;a href=&quot;tie/file&quot;&gt;Tie::File&lt;/a&gt; module, which treats the entire file as an array. Simply access a random array element.</source>
          <target state="translated">別の方法は、ファイル全体を配列として扱う&lt;a href=&quot;tie/file&quot;&gt;Tie :: File&lt;/a&gt;モジュールを使用することです。ランダムな配列要素にアクセスするだけです。</target>
        </trans-unit>
        <trans-unit id="360771e8bfe1eade19d5dbc8ea8baae5f8a955ef" translate="yes" xml:space="preserve">
          <source>Another way is to use undef as an element on the left-hand-side:</source>
          <target state="translated">もう一つの方法は、左側の要素として undef を使用することです。</target>
        </trans-unit>
        <trans-unit id="b6dde2905ab30997325ea52458484ff80b17847e" translate="yes" xml:space="preserve">
          <source>Another way of describing the operation is this: If &lt;code&gt;/c&lt;/code&gt; is specified, the</source>
          <target state="translated">操作を説明する別の方法は次のとおりです &lt;code&gt;/c&lt;/code&gt; が指定されている場合、</target>
        </trans-unit>
        <trans-unit id="8b74b30f842e3a2fe422587280e297e6a0fb34e2" translate="yes" xml:space="preserve">
          <source>Another way of thinking about this function is finding a needle in a haystack. &lt;code&gt;big&lt;/code&gt; points to the first byte in the haystack. &lt;code&gt;big_end&lt;/code&gt; points to one byte beyond the final byte in the haystack. &lt;code&gt;little&lt;/code&gt; points to the first byte in the needle. &lt;code&gt;little_end&lt;/code&gt; points to one byte beyond the final byte in the needle. All the parameters must be non-&lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">この機能についての別の考え方は、干し草の山から針を見つけることです。干し草の山の最初のバイトを指す &lt;code&gt;big&lt;/code&gt; ポイント。 &lt;code&gt;big_end&lt;/code&gt; は、干し草の山の最後のバイトを1バイト超えたところを指します。針の最初のバイトを &lt;code&gt;little&lt;/code&gt; 指します。 &lt;code&gt;little_end&lt;/code&gt; は、針の最後のバイトを1バイト超えたところを指します。すべてのパラメーターは &lt;code&gt;NULL&lt;/code&gt; 以外でなければなりません。</target>
        </trans-unit>
        <trans-unit id="f81299a8407385b954919f2cec05019d576de6e8" translate="yes" xml:space="preserve">
          <source>Another way to create anonymous filehandles is with the Symbol module or with the IO::Handle module and its ilk. These modules have the advantage of not hiding different types of the same name during the local(). See the bottom of &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt; for an example.</source>
          <target state="translated">匿名のファイルハンドルを作成する別の方法は、SymbolモジュールまたはIO :: Handleモジュールとそのilkを使用することです。これらのモジュールには、local（）中に同じ名前の異なるタイプを隠さないという利点があります。例については、&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;の下部を参照してください。</target>
        </trans-unit>
        <trans-unit id="6660859ea71d8fc8ba79b6222c7cabca290a534d" translate="yes" xml:space="preserve">
          <source>Another way to create anonymous filehandles is with the Symbol module or with the IO::Handle module and its ilk. These modules have the advantage of not hiding different types of the same name during the local(). See the bottom of &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt; for an example.</source>
          <target state="translated">匿名ファイルハンドルを作成する別の方法は、SymbolモジュールまたはIO :: Handleモジュールとその同類を使用することです。これらのモジュールには、local（）中に同じ名前の異なるタイプを非表示にしないという利点があります。例については&lt;a href=&quot;perlfunc#open&quot;&gt;、perlfuncの「open」の&lt;/a&gt;下部を参照してください。</target>
        </trans-unit>
        <trans-unit id="e614c6db5b38b002f45562db1a27e62289c42947" translate="yes" xml:space="preserve">
          <source>Another way to debug compile-time code is to start the debugger, set a breakpoint on the</source>
          <target state="translated">コンパイル時のコードをデバッグするもう一つの方法は、デバッガを起動して</target>
        </trans-unit>
        <trans-unit id="9901f72c76524abdcc53f059c75aff5db9ab2a29" translate="yes" xml:space="preserve">
          <source>Another way to declare &lt;code&gt;host&lt;/code&gt; is to use a C block in the CODE: section:</source>
          <target state="translated">&lt;code&gt;host&lt;/code&gt; を宣言する別の方法は、CODE：セクションでCブロックを使用することです。</target>
        </trans-unit>
        <trans-unit id="205baf27defe296be93a335acebfa113cc8193c2" translate="yes" xml:space="preserve">
          <source>Another way to disable the safe signal behavior locally is to use the &lt;code&gt;Perl::Unsafe::Signals&lt;/code&gt; module from CPAN, which affects all signals.</source>
          <target state="translated">安全な信号の動作をローカルで無効にするもう1つの方法は、CPANの &lt;code&gt;Perl::Unsafe::Signals&lt;/code&gt; モジュールを使用することです。これは、すべての信号に影響します。</target>
        </trans-unit>
        <trans-unit id="11569e74dec6446efa52dec2c7a4e093532b6648" translate="yes" xml:space="preserve">
          <source>Another way to examine the tree is to use a compiler back-end module, such as &lt;a href=&quot;B::Concise&quot;&gt;B::Concise&lt;/a&gt;.</source>
          <target state="translated">ツリーを調べる別の方法は、&lt;a href=&quot;B::Concise&quot;&gt;B :: Concise&lt;/a&gt;などのコンパイラバックエンドモジュールを使用することです。</target>
        </trans-unit>
        <trans-unit id="68459b39b80a3326501665280a8d6df2de3c0dc3" translate="yes" xml:space="preserve">
          <source>Another way to examine the tree is to use a compiler back-end module, such as &lt;a href=&quot;b/concise&quot;&gt;B::Concise&lt;/a&gt;.</source>
          <target state="translated">ツリーを調べるもう1つの方法は、&lt;a href=&quot;b/concise&quot;&gt;B :: Concise&lt;/a&gt;などのコンパイラバックエンドモジュールを使用することです。</target>
        </trans-unit>
        <trans-unit id="1475dee12421b2759f280ec12406b6a9a8686bb7" translate="yes" xml:space="preserve">
          <source>Another way to lay hands on a reference to the underlying object is to use the tied() function, so they might alternately have set clobber using:</source>
          <target state="translated">基底オブジェクトへの参照に手を置くもう一つの方法は tied()関数を使用することで、彼らは交互に clobber をセットしているかもしれません。</target>
        </trans-unit>
        <trans-unit id="00149c3d1137c9330feb23e2fe36062f95ccc0ba" translate="yes" xml:space="preserve">
          <source>Another way to look at it is via bits:</source>
          <target state="translated">別の見方としては、ビットを経由したものがあります。</target>
        </trans-unit>
        <trans-unit id="87cb792899401773acea6f65b31b31644b7caaf0" translate="yes" xml:space="preserve">
          <source>Another way to modify &lt;code&gt;@INC&lt;/code&gt; without modifying the program, is to use the &lt;code&gt;lib&lt;/code&gt; pragma, e.g.:</source>
          <target state="translated">プログラムを変更せずに &lt;code&gt;@INC&lt;/code&gt; を変更する別の方法は、 &lt;code&gt;lib&lt;/code&gt; プラグマを使用することです。例：</target>
        </trans-unit>
        <trans-unit id="53f5ac93c7a0f074f16d88622079abd1a07b9541" translate="yes" xml:space="preserve">
          <source>Another way to see the output of a PM program is to run it as</source>
          <target state="translated">PMプログラムの出力を見るもう一つの方法は、次のように実行することです。</target>
        </trans-unit>
        <trans-unit id="60d4191bfc5b5a27fe1df7d104bb0fb301db392c" translate="yes" xml:space="preserve">
          <source>Another way to skip over characters in a UTF-8 string is to use &lt;code&gt;utf8_hop&lt;/code&gt; , which takes a string and a number of characters to skip over. You're on your own about bounds checking, though, so don't use it lightly.</source>
          <target state="translated">UTF-8文字列の文字をスキップする別の方法は、スキップする文字列と &lt;code&gt;utf8_hop&lt;/code&gt; を使用することです。ただし、境界チェックについては自分で決めるので、軽く使用しないでください。</target>
        </trans-unit>
        <trans-unit id="bdbeba721ab6028c2b3830fe28f0b278956ef2ae" translate="yes" xml:space="preserve">
          <source>Another way to skip over characters in a UTF-8 string is to use &lt;code&gt;utf8_hop&lt;/code&gt;, which takes a string and a number of characters to skip over. You're on your own about bounds checking, though, so don't use it lightly.</source>
          <target state="translated">UTF-8文字列の文字をスキップする別の方法は、 &lt;code&gt;utf8_hop&lt;/code&gt; を使用することです。これは、スキップする文字列と文字数を取ります。ただし、境界チェックについては自分で行っているので、軽く使用しないでください。</target>
        </trans-unit>
        <trans-unit id="ebbeb1bfc20bbb2eabb0051011fd1f94e30bfced" translate="yes" xml:space="preserve">
          <source>Another way to specify many INSTALL directories with a single parameter is LIB.</source>
          <target state="translated">1つのパラメータで多くのinstallディレクトリを指定するもう一つの方法はLIBです。</target>
        </trans-unit>
        <trans-unit id="ab320674027c2ae8c6c6ac4c9c8202490be618cd" translate="yes" xml:space="preserve">
          <source>Another way to write &lt;code&gt;Is_latin_1()&lt;/code&gt; would be to use the characters in the range explicitly:</source>
          <target state="translated">&lt;code&gt;Is_latin_1()&lt;/code&gt; を記述するもう1つの方法は、範囲内の文字を明示的に使用することです。</target>
        </trans-unit>
        <trans-unit id="7b86cf4ed2b3d4be5d67a5a0ca22b08970c9b1b4" translate="yes" xml:space="preserve">
          <source>Ansgar Burchardt &amp;lt;ansgar@cpan.org&amp;gt;</source>
          <target state="translated">Ansgar Burchardt &amp;lt;ansgar@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="fcb531954bffd941479549648f2841c2d77a7164" translate="yes" xml:space="preserve">
          <source>Anton Tagunov doubts its usefulness.</source>
          <target state="translated">アントン・タグノフはその有用性を疑っている。</target>
        </trans-unit>
        <trans-unit id="697b561300a9259946d1254bc1d65f626fe87539" translate="yes" xml:space="preserve">
          <source>Any $(FOO) used in the examples are make variables, not Perl.</source>
          <target state="translated">例で使用されている $(FOO)はすべて make 変数であり、Perl ではありません。</target>
        </trans-unit>
        <trans-unit id="bea7ca75aae1ff5f6e730010d46af50a09d7d1c8" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;user-defined property&lt;/a&gt; used must be already defined by the time the regular expression is compiled (but note that this construct can be used instead of such properties).</source>
          <target state="translated">使用する&lt;a href=&quot;perlunicode#User-Defined-Character-Properties&quot;&gt;ユーザー定義のプロパティ&lt;/a&gt;は、正規表現がコンパイルされる時点ですでに定義されている必要があります（ただし、この構成はこのようなプロパティの代わりに使用できることに注意してください）。</target>
        </trans-unit>
        <trans-unit id="31e755c53eda86352ddd4b11acb45031c2d27960" translate="yes" xml:space="preserve">
          <source>Any &lt;b&gt;class method&lt;/b&gt;, &lt;b&gt;instance&lt;/b&gt;, or &lt;b&gt;subroutine&lt;/b&gt; that composes, initializes, blesses, and returns an &lt;b&gt;object&lt;/b&gt;. Sometimes we use the term loosely to mean a &lt;b&gt;composer&lt;/b&gt;.</source>
          <target state="translated">任意の&lt;b&gt;クラスメソッド&lt;/b&gt;、&lt;b&gt;インスタンス&lt;/b&gt;、または&lt;b&gt;サブルーチン&lt;/b&gt;構成、初期化、祝福、戻るその&lt;b&gt;オブジェクト&lt;/b&gt;。時々、&lt;b&gt;作曲家&lt;/b&gt;を意味するために大まかにこの用語を使用します。</target>
        </trans-unit>
        <trans-unit id="ebc443723afa597f0f46ae7e71ea2b268b18eec2" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;\&lt;/code&gt; (backslashes) are converted to &lt;code&gt;/&lt;/code&gt; (forward slashes), and then File::Spec::Unix canonpath() is called on the result.</source>
          <target state="translated">どれ &lt;code&gt;\&lt;/code&gt; （バックスラッシュ）に変換されます &lt;code&gt;/&lt;/code&gt; （スラッシュ）、[ファイル::スペックは:: Unixのcanonpath（）結果に呼ばれています。</target>
        </trans-unit>
        <trans-unit id="0297ad87a59e1b9acfbd34804e1d88eb60665363" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;make&lt;/code&gt; or &lt;code&gt;test&lt;/code&gt; is run unconditionally. An</source>
          <target state="translated">どれ &lt;code&gt;make&lt;/code&gt; や &lt;code&gt;test&lt;/code&gt; 無条件に実行されます。あ</target>
        </trans-unit>
        <trans-unit id="bf7362a2fe12e03fc4b84c1c886bc1d5ed325938" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;use utf8&lt;/code&gt; or &lt;code&gt;no utf8&lt;/code&gt; declarations within the string have no effect, and source filters are forbidden. (&lt;code&gt;unicode_strings&lt;/code&gt;, however, can appear within the string.) See also the &lt;a href=&quot;#evalbytes-EXPR&quot;&gt;&lt;code&gt;evalbytes&lt;/code&gt;&lt;/a&gt; operator, which works properly with source filters.</source>
          <target state="translated">どれでも &lt;code&gt;use utf8&lt;/code&gt; または &lt;code&gt;no utf8&lt;/code&gt; 文字列内の宣言は何の効果もありませんし、ソースフィルタが禁止されています。（ただし、 &lt;code&gt;unicode_strings&lt;/code&gt; は文字列内に表示できます。）ソースフィルターで適切に機能する&lt;a href=&quot;#evalbytes-EXPR&quot;&gt; &lt;code&gt;evalbytes&lt;/code&gt; &lt;/a&gt;演算子も参照してください。</target>
        </trans-unit>
        <trans-unit id="3cd3503f8d612240a0cdcfcf3958cd4b47fd1bc1" translate="yes" xml:space="preserve">
          <source>Any SV may be magical, that is, it has special features that a normal SV does not have. These features are stored in the SV structure in a linked list of &lt;code&gt;struct magic&lt;/code&gt; 's, typedef'ed to &lt;code&gt;MAGIC&lt;/code&gt; .</source>
          <target state="translated">どのSVも魔法のようです。つまり、通常のSVにはない特別な機能があります。これらの機能は、 &lt;code&gt;MAGIC&lt;/code&gt; にtypedefされた &lt;code&gt;struct magic&lt;/code&gt; のリンクリストのSV構造に格納されます。</target>
        </trans-unit>
        <trans-unit id="33b69c22f5834c109ce23cffa5c65513da0e84fe" translate="yes" xml:space="preserve">
          <source>Any SV may be magical, that is, it has special features that a normal SV does not have. These features are stored in the SV structure in a linked list of &lt;code&gt;struct magic&lt;/code&gt;'s, typedef'ed to &lt;code&gt;MAGIC&lt;/code&gt;.</source>
          <target state="translated">どのSVも魔法のようです。つまり、通常のSVにはない特別な機能があります。これらの機能は、 &lt;code&gt;struct magic&lt;/code&gt; のリンクリストのSV構造に格納され、 &lt;code&gt;MAGIC&lt;/code&gt; にtypedefされます。</target>
        </trans-unit>
        <trans-unit id="3990dd07c484552abc78d056ff16c2e2a8e23114" translate="yes" xml:space="preserve">
          <source>Any additional arguments are expected to be names of modules to generate code for.</source>
          <target state="translated">追加の引数には、コードを生成するモジュールの名前を指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="33e9e1331c3f51ebe91a9bc05248aec433c1afce" translate="yes" xml:space="preserve">
          <source>Any additional arguments found before the &lt;b&gt;--&lt;/b&gt; token are expected to be names of modules to generate code for.</source>
          <target state="translated">&lt;b&gt;-&lt;/b&gt;トークンの前にある追加の引数は、コードを生成するモジュールの名前であると想定されます。</target>
        </trans-unit>
        <trans-unit id="c6e53a3422c150f8910984634fe5fc4926bb37bc" translate="yes" xml:space="preserve">
          <source>Any additional flags you wish to pass to the linker.</source>
          <target state="translated">リンカに渡したい追加のフラグ。</target>
        </trans-unit>
        <trans-unit id="76af9e90cc2fb275b94658ee19c44c077d496116" translate="yes" xml:space="preserve">
          <source>Any argument provided is passed as CHECK to underlying Encode::decode() call. Pass the value &lt;code&gt;Encode::FB_CROAK&lt;/code&gt; to have the decoding croak if not all the command line arguments can be decoded. See &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;&quot;Handling Malformed Data&quot; in Encode&lt;/a&gt; for details on other options for CHECK.</source>
          <target state="translated">提供された引数はすべて、基礎となるEncode :: decode（）呼び出しにCHECKとして渡されます。すべてのコマンドライン引数をデコードできない場合は、値 &lt;code&gt;Encode::FB_CROAK&lt;/code&gt; を渡して、デコードが鳴ります。参照してください。&lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;エンコードに「不正なデータの処理」を&lt;/a&gt;CHECKの他のオプションの詳細については。</target>
        </trans-unit>
        <trans-unit id="28fc9753c4799266fbd1d9873fa8ed5292bbf609" translate="yes" xml:space="preserve">
          <source>Any argument which looks like a signal name (that is, &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt; ) indicates that &lt;b&gt;sigtrap&lt;/b&gt; should install a handler for that name.</source>
          <target state="translated">シグナル名のように見える引数（つまり、 &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt; ）は、&lt;b&gt;sigtrap&lt;/b&gt;がその名前のハンドラーをインストールする必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="f26e937185e1c5cd97a379a8dabb810b138157bc" translate="yes" xml:space="preserve">
          <source>Any argument which looks like a signal name (that is, &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt;) indicates that &lt;b&gt;sigtrap&lt;/b&gt; should install a handler for that name.</source>
          <target state="translated">シグナル名のように見える引数（つまり、 &lt;code&gt;/^[A-Z][A-Z0-9]*$/&lt;/code&gt; ）は、&lt;b&gt;sigtrap&lt;/b&gt;がその名前のハンドラーをインストールする必要があることを示します。</target>
        </trans-unit>
        <trans-unit id="669f46fd59266a6910f9368caa3825ce94a0d579" translate="yes" xml:space="preserve">
          <source>Any arguments after the second '--' token are additional linker arguments that will be examined for potential conflict. If there is no conflict, the additional arguments will be part of the output.</source>
          <target state="translated">2 番目の '--' トークンの後の引数は、競合の可能性があるかどうか検査される追加のリンカ引数です。競合がなければ、追加の引数は出力の一部となります。</target>
        </trans-unit>
        <trans-unit id="b8ba7c975cc3879d276e04e3e9eb8ad2f669d5cb" translate="yes" xml:space="preserve">
          <source>Any arguments passed in show up in the array &lt;code&gt;@_&lt;/code&gt; . (They may also show up in lexical variables introduced by a signature; see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt; below.) Therefore, if you called a function with two arguments, those would be stored in &lt;code&gt;$_[0]&lt;/code&gt; and &lt;code&gt;$_[1]&lt;/code&gt; . The array &lt;code&gt;@_&lt;/code&gt; is a local array, but its elements are aliases for the actual scalar parameters. In particular, if an element &lt;code&gt;$_[0]&lt;/code&gt; is updated, the corresponding argument is updated (or an error occurs if it is not updatable). If an argument is an array or hash element which did not exist when the function was called, that element is created only when (and if) it is modified or a reference to it is taken. (Some earlier versions of Perl created the element whether or not the element was assigned to.) Assigning to the whole array &lt;code&gt;@_&lt;/code&gt; removes that aliasing, and does not update any arguments.</source>
          <target state="translated">渡された引数は、配列 &lt;code&gt;@_&lt;/code&gt; に表示されます。（シグネチャによって導入されたレキシカル変数にも表示される場合があります。以下の「&lt;a href=&quot;#Signatures&quot;&gt;シグネチャ&lt;/a&gt;」を参照してください。）したがって、2つの引数を指定して関数を呼び出すと、それらは &lt;code&gt;$_[0]&lt;/code&gt; および &lt;code&gt;$_[1]&lt;/code&gt; に格納されます。配列 &lt;code&gt;@_&lt;/code&gt; はローカル配列ですが、その要素は実際のスカラーパラメーターのエイリアスです。特に、要素 &lt;code&gt;$_[0]&lt;/code&gt; が更新されると、対応する引数が更新されます（更新できない場合はエラーが発生します）。引数が、関数が呼び出されたときに存在しなかった配列またはハッシュ要素である場合、その要素は、それが変更されたとき、またはそれへの参照が行われたとき（およびその場合）にのみ作成されます。 （一部の以前のバージョンのPerlは、要素が割り当てられているかどうかにかかわらず、要素を作成していました。）配列全体 &lt;code&gt;@_&lt;/code&gt; に割り当てると、そのエイリアスが削除され、引数は更新されません。</target>
        </trans-unit>
        <trans-unit id="f35f240798e3c5e460d473d423be038d4c72e7d0" translate="yes" xml:space="preserve">
          <source>Any arguments passed in show up in the array &lt;code&gt;@_&lt;/code&gt;. (They may also show up in lexical variables introduced by a signature; see &lt;a href=&quot;#Signatures&quot;&gt;&quot;Signatures&quot;&lt;/a&gt; below.) Therefore, if you called a function with two arguments, those would be stored in &lt;code&gt;$_[0]&lt;/code&gt; and &lt;code&gt;$_[1]&lt;/code&gt;. The array &lt;code&gt;@_&lt;/code&gt; is a local array, but its elements are aliases for the actual scalar parameters. In particular, if an element &lt;code&gt;$_[0]&lt;/code&gt; is updated, the corresponding argument is updated (or an error occurs if it is not updatable). If an argument is an array or hash element which did not exist when the function was called, that element is created only when (and if) it is modified or a reference to it is taken. (Some earlier versions of Perl created the element whether or not the element was assigned to.) Assigning to the whole array &lt;code&gt;@_&lt;/code&gt; removes that aliasing, and does not update any arguments.</source>
          <target state="translated">渡された引数はすべて配列 &lt;code&gt;@_&lt;/code&gt; に表示されます。 （これらは、署名によって導入された字句変数にも表示される場合があります。以下の&lt;a href=&quot;#Signatures&quot;&gt;「署名」を&lt;/a&gt;参照してください。）したがって、2つの引数を使用して関数を呼び出すと、それらは &lt;code&gt;$_[0]&lt;/code&gt; と &lt;code&gt;$_[1]&lt;/code&gt; に格納されます。配列 &lt;code&gt;@_&lt;/code&gt; はローカル配列ですが、その要素は実際のスカラーパラメーターのエイリアスです。特に、要素 &lt;code&gt;$_[0]&lt;/code&gt; が更新されると、対応する引数が更新されます（または、更新できない場合はエラーが発生します）。引数が関数が呼び出されたときに存在しなかった配列またはハッシュ要素である場合、その要素は、それが変更されたとき（およびその場合）にのみ作成されるか、その要素への参照が取得されます。 （以前のバージョンのPerlの中には、要素が割り当てられているかどうかに関係なく要素を作成したものがあります。）配列全体に &lt;code&gt;@_&lt;/code&gt; を割り当てると、そのエイリアスが削除され、引数は更新されません。</target>
        </trans-unit>
        <trans-unit id="ff6247c19341895e60632e62b6ff63ef2ca7a1ee" translate="yes" xml:space="preserve">
          <source>Any attempt by the code in STRING to use an operator which is not permitted by the compartment will cause an error (at run-time of the main program but at compile-time for the code in STRING). The error is of the form &quot;'%s' trapped by operation mask...&quot;.</source>
          <target state="translated">STRING内のコードがコンパートメントで許可されていない演算子を使用しようとすると、エラーが発生します(メイン・プログラムの実行時にはエラーが発生しますが、STRING内のコードのコンパイル時にはエラーが発生します)。このエラーは &quot;'%s' trapped by operation mask...&quot; という形式のものです。</target>
        </trans-unit>
        <trans-unit id="813cebd9a54eacff09b02a5f15b34a12df0ec8d1" translate="yes" xml:space="preserve">
          <source>Any backslashed prototype character represents an actual argument that must start with that character (optionally preceded by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;), with the exception of &lt;code&gt;$&lt;/code&gt; , which will accept any scalar lvalue expression, such as &lt;code&gt;$foo = 7&lt;/code&gt; or &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt; . The value passed as part of &lt;code&gt;@_&lt;/code&gt; will be a reference to the actual argument given in the subroutine call, obtained by applying &lt;code&gt;\&lt;/code&gt; to that argument.</source>
          <target state="translated">バックスラッシュ付きのプロトタイプ文字は、その文字で始まる必要がある実際の引数を表します（オプションで、 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; が前に付きます）。ただし、 &lt;code&gt;$&lt;/code&gt; は例外で、 &lt;code&gt;$foo = 7&lt;/code&gt; や &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt; などのスカラーlvalue式を受け入れます&amp;gt; [0]。 &lt;code&gt;@_&lt;/code&gt; の一部として渡される値は、その引数に &lt;code&gt;\&lt;/code&gt; を適用することによって取得される、サブルーチン呼び出しで指定された実際の引数への参照になります。</target>
        </trans-unit>
        <trans-unit id="ffa3112ef74eec5708dbce1d67d94690c63f3116" translate="yes" xml:space="preserve">
          <source>Any backslashed prototype character represents an actual argument that must start with that character (optionally preceded by &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt; or &lt;code&gt;local&lt;/code&gt;), with the exception of &lt;code&gt;$&lt;/code&gt;, which will accept any scalar lvalue expression, such as &lt;code&gt;$foo = 7&lt;/code&gt; or &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt;. The value passed as part of &lt;code&gt;@_&lt;/code&gt; will be a reference to the actual argument given in the subroutine call, obtained by applying &lt;code&gt;\&lt;/code&gt; to that argument.</source>
          <target state="translated">バックスラッシュされたプロトタイプ文字は、 &lt;code&gt;$foo = 7&lt;/code&gt; や &lt;code&gt;my_function()-&amp;gt;[0]&lt;/code&gt; などのスカラー左辺値式を受け入れる &lt;code&gt;$&lt;/code&gt; を除い &lt;code&gt;my&lt;/code&gt; 、その文字で開始する必要がある実際の引数を表します（オプションでmy、 &lt;code&gt;our&lt;/code&gt; 、または &lt;code&gt;local&lt;/code&gt; が前に付きます）。 &amp;gt; [0]。 &lt;code&gt;@_&lt;/code&gt; の一部として渡される値は、サブルーチン呼び出しで指定された実際の引数への参照であり、その引数に &lt;code&gt;\&lt;/code&gt; を適用することによって取得されます。</target>
        </trans-unit>
        <trans-unit id="e8738a2a75fb40cb2ee10b2d9e2137a995a5cab3" translate="yes" xml:space="preserve">
          <source>Any call from a package to itself is safe.</source>
          <target state="translated">パッケージからそれ自身への呼び出しは安全です。</target>
        </trans-unit>
        <trans-unit id="4b72ee9b0cb5399c6a83f5d4a70d821be8027231" translate="yes" xml:space="preserve">
          <source>Any call from an internal Perl module is safe. (Nothing keeps user modules from marking themselves as internal to Perl, but this practice is discouraged.)</source>
          <target state="translated">内部Perlモジュールからの呼び出しは安全です。(ユーザモジュールが自分自身をPerlの内部であるとマークしないようにするものはありませんが、これは推奨されていません)</target>
        </trans-unit>
        <trans-unit id="32561ad60b0d62ef81eb27f4c0654f92745f16b5" translate="yes" xml:space="preserve">
          <source>Any call to Perl's warning system (eg Carp itself) is safe. (This rule is what keeps it from reporting the error at the point where you call &lt;code&gt;carp&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt; .)</source>
          <target state="translated">Perlの警告システム（たとえば、Carp自体）への呼び出しはすべて安全です。（このルールにより、 &lt;code&gt;carp&lt;/code&gt; または &lt;code&gt;croak&lt;/code&gt; を呼び出した時点でエラーが報告されなくなります。）</target>
        </trans-unit>
        <trans-unit id="3b252f8b26d454c8056df1a78fc7a97e6d22f01f" translate="yes" xml:space="preserve">
          <source>Any call to Perl's warning system (eg Carp itself) is safe. (This rule is what keeps it from reporting the error at the point where you call &lt;code&gt;carp&lt;/code&gt; or &lt;code&gt;croak&lt;/code&gt;.)</source>
          <target state="translated">Perlの警告システム（Carp自体など）への呼び出しはすべて安全です。（このルールは、 &lt;code&gt;carp&lt;/code&gt; または &lt;code&gt;croak&lt;/code&gt; を呼び出した時点でエラーが報告されないようにするものです。）</target>
        </trans-unit>
        <trans-unit id="6be54b4dca13888b86e758e818195dea970243c9" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\d&lt;/code&gt; is matched by &lt;code&gt;\D&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; と一致しない文字はすべて &lt;code&gt;\D&lt;/code&gt; と一致します。</target>
        </trans-unit>
        <trans-unit id="a92f497a3debf42be69af7cf310d253bf9089f09" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\d&lt;/code&gt; is matched by &lt;code&gt;\D&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; と一致しない文字は、 &lt;code&gt;\D&lt;/code&gt; と一致します。</target>
        </trans-unit>
        <trans-unit id="072286fccc69e711078f97acb3c710b733c38c10" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\s&lt;/code&gt; is matched by &lt;code&gt;\S&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; と一致しない文字はすべて &lt;code&gt;\S&lt;/code&gt; と一致します。</target>
        </trans-unit>
        <trans-unit id="6f9b47e6ac747d8625677192454745261e50c9f3" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\s&lt;/code&gt; is matched by &lt;code&gt;\S&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; 一致しない文字は、 &lt;code&gt;\S&lt;/code&gt; 一致します。</target>
        </trans-unit>
        <trans-unit id="edd14be74c570e6d8f1d353ef998bd9cdb853857" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\w&lt;/code&gt; is matched by &lt;code&gt;\W&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; と一致しない文字はすべて &lt;code&gt;\W&lt;/code&gt; と一致します。</target>
        </trans-unit>
        <trans-unit id="ca92dc8b5b50382eccc8de66976a91add27a47ad" translate="yes" xml:space="preserve">
          <source>Any character not matched by &lt;code&gt;\w&lt;/code&gt; is matched by &lt;code&gt;\W&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; 一致しない文字は、 &lt;code&gt;\W&lt;/code&gt; 一致します。</target>
        </trans-unit>
        <trans-unit id="e45bb18b3ba9ff92c60226f6eef9c2b785d393ac" translate="yes" xml:space="preserve">
          <source>Any character not part of the 65-character base64 subset is silently ignored. Characters occurring after a '=' padding character are never decoded.</source>
          <target state="translated">65文字のbase64サブセットに含まれない文字は、静かに無視されます。パディング文字「=」の後にある文字は、決してデコードされません。</target>
        </trans-unit>
        <trans-unit id="fdc4fb7a943f332e78ce7564ebae9fbe7a142c7e" translate="yes" xml:space="preserve">
          <source>Any character that is</source>
          <target state="translated">どんなキャラクターでも</target>
        </trans-unit>
        <trans-unit id="d1ae992eb64cfaf05e3391f63560921ed6515ef6" translate="yes" xml:space="preserve">
          <source>Any character with the General Category of Combining Mark (&lt;code&gt;\p{GC=M}&lt;/code&gt; ), which may be spacing or nonspacing. Some are even invisible. A sequence of combining characters following a grapheme base character together make up a single user-visible character called a &lt;b&gt;grapheme&lt;/b&gt;. Most but not all diacritics are combining characters, and vice versa.</source>
          <target state="translated">結合マークの一般的なカテゴリ（ &lt;code&gt;\p{GC=M}&lt;/code&gt; ）を持つ任意の文字。これは、間隔があってもなくてもかまいません。見えないものもあります。書記素の基本文字に続く文字を組み合わせたシーケンスは、&lt;b&gt;書記素&lt;/b&gt;と呼ばれる単一のユーザー表示文字を構成します。すべてではありませんが、ほとんどの発音区別符号は文字を組み合わせており、その逆も同様です。</target>
        </trans-unit>
        <trans-unit id="f7f37ee9ffee4805d8681593ea741f6cb413f361" translate="yes" xml:space="preserve">
          <source>Any character with the General Category of Combining Mark (&lt;code&gt;\p{GC=M}&lt;/code&gt;), which may be spacing or nonspacing. Some are even invisible. A sequence of combining characters following a grapheme base character together make up a single user-visible character called a &lt;b&gt;grapheme&lt;/b&gt;. Most but not all diacritics are combining characters, and vice versa.</source>
          <target state="translated">結合マークの一般カテゴリ（ &lt;code&gt;\p{GC=M}&lt;/code&gt; ）を持つ任意の文字。間隔がある場合とない場合があります。目に見えないものさえあります。書記素の基本文字に続く文字を組み合わせたシーケンスは、&lt;b&gt;書記素&lt;/b&gt;と呼ばれる単一のユーザーに表示される文字を構成します。すべてではありませんがほとんどの発音区別符号は文字を組み合わせています。逆もまた同様です。</target>
        </trans-unit>
        <trans-unit id="f47500f097947cd7ef6b655a33fe0adeaed93c8c" translate="yes" xml:space="preserve">
          <source>Any class derived from an overloaded class is also overloaded and inherits its operator implementations. If the same operator is overloaded in more than one ancestor then the implementation is determined by the usual inheritance rules.</source>
          <target state="translated">オーバーロードされたクラスから派生したクラスもオーバーロードされ、その演算子の実装を継承します。同じ演算子が複数の祖先でオーバーロードされている場合は、通常の継承ルールによって実装が決定されます。</target>
        </trans-unit>
        <trans-unit id="82762c13b8c241690349f9ba71914d3aafcada68" translate="yes" xml:space="preserve">
          <source>Any class for which this function returns true is &quot;universal&quot; in the sense that all classes potentially inherit methods from it.</source>
          <target state="translated">この関数が真を返すクラスは、すべてのクラスがメソッドを継承する可能性があるという意味で「普遍的」です。</target>
        </trans-unit>
        <trans-unit id="4c366c83fbe5661336d1ed5dad628d12372f6675" translate="yes" xml:space="preserve">
          <source>Any class may define hooks that will be called during the serialization and deserialization process on objects that are instances of that class. Those hooks can redefine the way serialization is performed (and therefore, how the symmetrical deserialization should be conducted).</source>
          <target state="translated">どのクラスでも、そのクラスのインスタンスであるオブジェクトのシリアライズとデシリアライズの処理中に呼び出されるフックを定義することができます。これらのフックはシリアライズの実行方法を再定義することができます(したがって、対称的なデシリアライズがどのように行われるべきか)。</target>
        </trans-unit>
        <trans-unit id="6e6281f412687ca7280049212c9dd37d5f605837" translate="yes" xml:space="preserve">
          <source>Any command not recognized by the debugger is directly executed (&lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;'d) as Perl code in the current package. (The debugger uses the DB package for keeping its own state information.)</source>
          <target state="translated">デバッガーで認識されないコマンドは、現在のパッケージのPerlコードとして直接実行（ &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 'd）されます。（デバッガーは、独自の状態情報を保持するためにDBパッケージを使用します。）</target>
        </trans-unit>
        <trans-unit id="78f7d4f4e5eb056442905f4be332daa2d7078212" translate="yes" xml:space="preserve">
          <source>Any command not recognized by the debugger is directly executed (&lt;code&gt;eval&lt;/code&gt;'d) as Perl code in the current package. (The debugger uses the DB package for keeping its own state information.)</source>
          <target state="translated">デバッガーによって認識されないコマンドは、現在のパッケージのPerlコードとして直接実行されます（ &lt;code&gt;eval&lt;/code&gt; 'd）。（デバッガーは、独自の状態情報を保持するためにDBパッケージを使用します。）</target>
        </trans-unit>
        <trans-unit id="e1fcc44228bcb7043c7f8789e115cc416dabfd31" translate="yes" xml:space="preserve">
          <source>Any committer may cherry-pick any commit from blead to a maint branch by first adding an entry to the relevant voting file in the maint-votes branch announcing the commit as a candidate for back-porting, and then waiting for at least two other committers to add their votes in support of this (i.e. a total of at least three votes is required before a commit may be back-ported).</source>
          <target state="translated">コミット者は、まず maint-votes ブランチの関連する投票ファイルに、そのコミットがバックポートの候補であることを告げるエントリを追加し、他のコミット者が少なくとも二人の投票を追加するのを待つことで、 blead から maint ブランチへのコミットをチェリーピックすることができます (つまり、バックポートするには最低でも三票の投票が必要になります)。</target>
        </trans-unit>
        <trans-unit id="a8dc7e3add242376e935c5e7dec68c1bf0f28dae" translate="yes" xml:space="preserve">
          <source>Any committer may cherry-pick any commit from blead to a maint branch if they send mail to perl5-porters announcing their intent to cherry-pick a specific commit along with a rationale for doing so and at least two other committers respond to the list giving their assent. (This policy applies to current and former pumpkings, as well as other committers.)</source>
          <target state="translated">コミット者は誰でも、特定のコミットをチェリーピックする意図とその理由を明記したメールを perl5-porters に送り、少なくとも 2 人の他のコミット者がその旨を返信してくれれば、 blead から maint ブランチへのコミットをチェリーピックすることができます。(このポリシーは、現在のコミット者、以前のコミット者、他のコミット者にも適用されます)。</target>
        </trans-unit>
        <trans-unit id="b95f0a7c9cbc43fb72281273ec465950ff501fea" translate="yes" xml:space="preserve">
          <source>Any contained POSIX character classes, including things like &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\D&lt;/code&gt; respect the &lt;code&gt;/a&lt;/code&gt; (and &lt;code&gt;/aa&lt;/code&gt; ) modifiers.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; や &lt;code&gt;\D&lt;/code&gt; などの含まれるPOSIX文字クラスは、 &lt;code&gt;/a&lt;/code&gt; （および &lt;code&gt;/aa&lt;/code&gt; ）修飾子を尊重します。</target>
        </trans-unit>
        <trans-unit id="ed912b6d995f34c695ed9e38e5b4d742feccc889" translate="yes" xml:space="preserve">
          <source>Any contained POSIX character classes, including things like &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\D&lt;/code&gt; respect the &lt;code&gt;/a&lt;/code&gt; (and &lt;code&gt;/aa&lt;/code&gt;) modifiers.</source>
          <target state="translated">&lt;code&gt;\w&lt;/code&gt; や &lt;code&gt;\D&lt;/code&gt; などの含まれているPOSIX文字クラスは、 &lt;code&gt;/a&lt;/code&gt; （および &lt;code&gt;/aa&lt;/code&gt; ）修飾子を尊重します。</target>
        </trans-unit>
        <trans-unit id="5db2df3ee56bd2a814ccc5209f324c5b3591842c" translate="yes" xml:space="preserve">
          <source>Any data types supported by &lt;a href=&quot;../threads/shared&quot;&gt;threads::shared&lt;/a&gt; can be passed via queues:</source>
          <target state="translated">&lt;a href=&quot;../threads/shared&quot;&gt;threads :: sharedで&lt;/a&gt;サポートされているすべてのデータ型は、キューを介して渡すことができます。</target>
        </trans-unit>
        <trans-unit id="4e0656683c3bae7fc0640dbcbac9a2b39fa2d301" translate="yes" xml:space="preserve">
          <source>Any data types supported by &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt; can be passed via queues:</source>
          <target state="translated">&lt;a href=&quot;threads::shared&quot;&gt;thread :: sharedで&lt;/a&gt;サポートされているすべてのデータ型は、キューを介して渡すことができます。</target>
        </trans-unit>
        <trans-unit id="e796dc658263f7829a0c740b0d175dbd881579ef" translate="yes" xml:space="preserve">
          <source>Any diagnostics that were output for the test. This only includes diagnostics output &lt;b&gt;after&lt;/b&gt; the test result is declared.</source>
          <target state="translated">テスト用に出力された診断。これには、テスト結果が宣言された&lt;b&gt;後&lt;/b&gt;の診断出力のみが含まれます。</target>
        </trans-unit>
        <trans-unit id="500c84c6a69d3cbc0070a804d35fd877c67e676d" translate="yes" xml:space="preserve">
          <source>Any directory to prefix to the extraction path, if any</source>
          <target state="translated">抽出パスに接頭辞を付けたいディレクトリがあれば、それを指定します。</target>
        </trans-unit>
        <trans-unit id="fe63280e6a478a3a4b2a298d74baf468659f885a" translate="yes" xml:space="preserve">
          <source>Any existing</source>
          <target state="translated">既存の</target>
        </trans-unit>
        <trans-unit id="910f15fcdac4d39c624eb5925c6aedfca05cbd8f" translate="yes" xml:space="preserve">
          <source>Any extension to Perl, including those containing XSUBs, should have a Perl module to serve as the bootstrap which pulls the extension into Perl. This module will export the extension's functions and variables to the Perl program and will cause the extension's XSUBs to be linked into Perl. The following module will be used for most of the examples in this document and should be used from Perl with the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; command as shown earlier. Perl modules are explained in more detail later in this document.</source>
          <target state="translated">XSUBを含むものを含む、Perlへの拡張には、Perlに拡張をプルするブートストラップとして機能するPerlモジュールが必要です。このモジュールは、拡張の関数と変数をPerlプログラムにエクスポートし、拡張のXSUBをPerlにリンクさせます。次のモジュールは、このドキュメントのほとんどの例で &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; され、前述のように、useコマンドを使用してPerlから使用する必要があります。Perlモジュールについては、このドキュメントの後半で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="4138f336ca25f7058dac8592c9829407df50fe3e" translate="yes" xml:space="preserve">
          <source>Any extension to Perl, including those containing XSUBs, should have a Perl module to serve as the bootstrap which pulls the extension into Perl. This module will export the extension's functions and variables to the Perl program and will cause the extension's XSUBs to be linked into Perl. The following module will be used for most of the examples in this document and should be used from Perl with the &lt;code&gt;use&lt;/code&gt; command as shown earlier. Perl modules are explained in more detail later in this document.</source>
          <target state="translated">XSUBを含むものを含むPerlの拡張機能には、拡張機能をPerlにプルするブートストラップとして機能するPerlモジュールが必要です。このモジュールは、拡張機能の関数と変数をPerlプログラムにエクスポートし、拡張機能のXSUBをPerlにリンクさせます。次のモジュールは、このドキュメントのほとんどの例で &lt;code&gt;use&lt;/code&gt; され、前述のようにuseコマンドを使用してPerlから使用する必要があります。Perlモジュールについては、このドキュメントの後半で詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="25a23450424903dcd5fa1cc3d1a014ad157de4c5" translate="yes" xml:space="preserve">
          <source>Any extra arguments which shouldn't be passed on to &lt;code&gt;plan()&lt;/code&gt; should be stripped off by this method.</source>
          <target state="translated">&lt;code&gt;plan()&lt;/code&gt; に渡してはいけない余分な引数は、このメソッドで取り除く必要があります。</target>
        </trans-unit>
        <trans-unit id="479572afcef4faf54a80923b02d6ecab023cba50" translate="yes" xml:space="preserve">
          <source>Any extra arguments you want passed into the subtest code.</source>
          <target state="translated">サブテストコードに渡したい追加の引数。</target>
        </trans-unit>
        <trans-unit id="e812c3c14740bd790df37fd5ab976ff0e033c047" translate="yes" xml:space="preserve">
          <source>Any filehandles open at the time of the fork() will be dup()-ed. Thus, the files can be closed independently in the parent and child, but beware that the dup()-ed handles will still share the same seek pointer. Changing the seek position in the parent will change it in the child and vice-versa. One can avoid this by opening files that need distinct seek pointers separately in the child.</source>
          <target state="translated">fork()の時点で開いているファイルハンドルはすべて dup()-ed となります。このようにして、親と子でそれぞれ独立してファイルを閉じることができますが、 dup()されたハンドルは同じシークポインタを共有していることに注意してください。親側でシーク位置を変更すると、子側でもシーク位置が変更され、逆に子側でもシーク位置が変更されます。これを回避するには、別々のシークポインタを必要とするファイルを子プロセスで別々に開くようにします。</target>
        </trans-unit>
        <trans-unit id="187558535ccb5da9eca3826ba8e4d8b30ca76bc1" translate="yes" xml:space="preserve">
          <source>Any function in the list below may be used either with or without parentheses around its arguments. (The syntax descriptions omit the parentheses.) If you use parentheses, the simple but occasionally surprising rule is this: It</source>
          <target state="translated">以下のリストにある関数は、引数の周りに括弧を付けても付けなくても使用できます。(構文の説明では括弧は省略されています。)括弧を使用する場合、単純ですが時折驚くようなルールがあります。それは</target>
        </trans-unit>
        <trans-unit id="9f6c837fd47f5e061c1ecbb824c94df3994dcde5" translate="yes" xml:space="preserve">
          <source>Any good book on software engineering</source>
          <target state="translated">ソフトウェア工学の任意の良い本</target>
        </trans-unit>
        <trans-unit id="24c8f5e2946c066d9a62168dcf66b92198c6784a" translate="yes" xml:space="preserve">
          <source>Any keys for which the value is &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be ignored.</source>
          <target state="translated">値が &lt;code&gt;&lt;a href=&quot;../../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; であるキーはすべて無視されます。</target>
        </trans-unit>
        <trans-unit id="0c7f27e33616c341daf05c0b6c508f0fa8fdbd74" translate="yes" xml:space="preserve">
          <source>Any keys for which the value is &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; will be ignored.</source>
          <target state="translated">値が &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; であるキーはすべて無視されます。</target>
        </trans-unit>
        <trans-unit id="b98397e3061065c914af3247fdcc89fdfd6a02c2" translate="yes" xml:space="preserve">
          <source>Any keys for which the value is &lt;code&gt;undef&lt;/code&gt; will be ignored.</source>
          <target state="translated">値が &lt;code&gt;undef&lt;/code&gt; であるキーはすべて無視されます。</target>
        </trans-unit>
        <trans-unit id="568e69d3500c9fb9cde3152f15ae5ed8fcf84af4" translate="yes" xml:space="preserve">
          <source>Any keys not described in this specification document (whether top-level or within compound data structures described herein) are considered</source>
          <target state="translated">本明細書に記載されていないキー(トップレベルであるか、本明細書に記載されている複合データ構造内であるかにかかわらず)は、すべて考慮される。</target>
        </trans-unit>
        <trans-unit id="204edb5197689fcdc449ffc64469cd176c221d73" translate="yes" xml:space="preserve">
          <source>Any large IRC network (Dalnet, EFnet) is also likely to have a #perl channel, with varying activity levels.</source>
          <target state="translated">大規模な IRC ネットワーク (Dalnet,EFnet)は、アクティビティレベルが変化する #perl チャネルを持っている可能性があります。</target>
        </trans-unit>
        <trans-unit id="9ec17e0cbd0b3e2eebd6b6cf6a596cebb4cfc33d" translate="yes" xml:space="preserve">
          <source>Any letters between &lt;code&gt;&quot;?&quot;&lt;/code&gt; and &lt;code&gt;&quot;:&quot;&lt;/code&gt; act as flags modifiers as with &lt;code&gt;(?adluimnsx-imnsx)&lt;/code&gt;. For example,</source>
          <target state="translated">&lt;code&gt;&quot;?&quot;&lt;/code&gt; 間の文字 および &lt;code&gt;&quot;:&quot;&lt;/code&gt; は、 &lt;code&gt;(?adluimnsx-imnsx)&lt;/code&gt; と同様にフラグ修飾子として機能します。例えば、</target>
        </trans-unit>
        <trans-unit id="44271c2c405bf35e52ab0041e6847e60ca1ca0c2" translate="yes" xml:space="preserve">
          <source>Any letters between &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt; act as flags modifiers as with &lt;code&gt;(?adluimsx-imsx)&lt;/code&gt; . For example,</source>
          <target state="translated">間の任意の文字 &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;:&lt;/code&gt; ( &lt;code&gt;(?adluimsx-imsx)&lt;/code&gt; ようにフラグ修飾子として機能します。例えば、</target>
        </trans-unit>
        <trans-unit id="5618684dee489724ebf8f57ba00718b3f30e3494" translate="yes" xml:space="preserve">
          <source>Any method calls on an object created with &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; will be dispatched to the package as a normal object.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; 作成されたオブジェクトに対するメソッド呼び出しは、通常のオブジェクトとしてパッケージにディスパッチされます。</target>
        </trans-unit>
        <trans-unit id="26b68c72e2b484267b2f658de2349d6444e86420" translate="yes" xml:space="preserve">
          <source>Any method calls on an object created with &lt;code&gt;qr//&lt;/code&gt; will be dispatched to the package as a normal object.</source>
          <target state="translated">&lt;code&gt;qr//&lt;/code&gt; 作成されたオブジェクトに対するメソッド呼び出しはすべて、通常のオブジェクトとしてパッケージにディスパッチされます。</target>
        </trans-unit>
        <trans-unit id="125ade77b67e2c4cd7a637af74e96e943bde8b70" translate="yes" xml:space="preserve">
          <source>Any methods marked</source>
          <target state="translated">マークのついたメソッド</target>
        </trans-unit>
        <trans-unit id="c1aa612608eba8166ce338b4b530d56d4e20399c" translate="yes" xml:space="preserve">
          <source>Any methods not listed here are derived from Math::BigFloat (or Math::BigInt), so make sure you check these two modules for further information.</source>
          <target state="translated">ここに記載されていないメソッドはすべて Math::BigFloat (または Math::BigInt)から派生しているので、詳細についてはこの 2 つのモジュールを確認するようにしてください。</target>
        </trans-unit>
        <trans-unit id="9782a834fd90fe5d5545a24d61a39706e25bf926" translate="yes" xml:space="preserve">
          <source>Any mixture is possible. For example, the most frequently used options could be stored in variables while all other options get stored in the hash:</source>
          <target state="translated">どのような混合物も可能です。例えば、最もよく使われるオプションは変数に格納され、他のオプションはハッシュに格納されます。</target>
        </trans-unit>
        <trans-unit id="d9afc9d2e9f12a7ae747d6b9bda2062ad21b9fd2" translate="yes" xml:space="preserve">
          <source>Any names which are not tags are added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; unchanged but will trigger a warning (with &lt;code&gt;-w&lt;/code&gt; ) to avoid misspelt tags names being silently added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; . Future versions may make this a fatal error.</source>
          <target state="translated">タグではない名前は変更されずに &lt;code&gt;@EXPORT&lt;/code&gt; または &lt;code&gt;@EXPORT_OK&lt;/code&gt; に追加されますが、警告がトリガーされ（ &lt;code&gt;-w&lt;/code&gt; を使用）、ミススペルのタグ名が &lt;code&gt;@EXPORT&lt;/code&gt; または &lt;code&gt;@EXPORT_OK&lt;/code&gt; に暗黙的に追加されないようにします。将来のバージョンでは、これは致命的なエラーになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="f1edfb250e37d4b9a7863e1b2498e2a280885f23" translate="yes" xml:space="preserve">
          <source>Any names which are not tags are added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt; unchanged but will trigger a warning (with &lt;code&gt;-w&lt;/code&gt;) to avoid misspelt tags names being silently added to &lt;code&gt;@EXPORT&lt;/code&gt; or &lt;code&gt;@EXPORT_OK&lt;/code&gt;. Future versions may make this a fatal error.</source>
          <target state="translated">タグではない名前は変更されずに &lt;code&gt;@EXPORT&lt;/code&gt; または &lt;code&gt;@EXPORT_OK&lt;/code&gt; に追加されますが、スペルミスのタグ名が &lt;code&gt;@EXPORT&lt;/code&gt; または &lt;code&gt;@EXPORT_OK&lt;/code&gt; にサイレントに追加されるのを防ぐために、警告（ &lt;code&gt;-w&lt;/code&gt; を使用）がトリガーされます。将来のバージョンでは、これが致命的なエラーになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="485a3dceff3fe3343086f55cd7ded47422eb7429" translate="yes" xml:space="preserve">
          <source>Any newlines in $perl_code will be escaped. Leading and trailing newlines will be stripped. Makes this idiom much easier:</source>
          <target state="translated">perl_code内のすべての改行はエスケープされます。先頭と末尾の改行は除去されます。このイディオムをより簡単にします。</target>
        </trans-unit>
        <trans-unit id="85505e3e03d4cfb2c5d76c353aad39b235819057" translate="yes" xml:space="preserve">
          <source>Any non-whitespace delimiter may replace the slashes. Add space after the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; when using a character allowed in identifiers. If single quotes are used, no interpretation is done on the replacement string (the &lt;code&gt;/e&lt;/code&gt; modifier overrides this, however). Note that Perl treats backticks as normal delimiters; the replacement text is not evaluated as a command. If the</source>
          <target state="translated">空白以外の区切り文字はスラッシュを置き換えることができます。識別子で使用できる文字を使用する場合は、 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; の後にスペースを追加します。単一引用符が使用されている場合、置換文字列は解釈されません（ただし、 &lt;code&gt;/e&lt;/code&gt; 修飾子はこれをオーバーライドします）。Perlはバックティックを通常の区切り文字として扱うことに注意してください。置換テキストはコマンドとして評価されません。もし</target>
        </trans-unit>
        <trans-unit id="48ec8f1e8af52f4ed4957bdfee1ffd49c84a8c6f" translate="yes" xml:space="preserve">
          <source>Any non-whitespace delimiter may replace the slashes. Add space after the &lt;code&gt;s&lt;/code&gt; when using a character allowed in identifiers. If single quotes are used, no interpretation is done on the replacement string (the &lt;code&gt;/e&lt;/code&gt; modifier overrides this, however). Note that Perl treats backticks as normal delimiters; the replacement text is not evaluated as a command. If the</source>
          <target state="translated">空白以外の区切り文字でスラッシュを置き換えることができます。識別子で許可されている文字を使用する場合は、 &lt;code&gt;s&lt;/code&gt; の後にスペースを追加してください。一重引用符が使用されている場合、置換文字列の解釈は行われません（ただし、 &lt;code&gt;/e&lt;/code&gt; 修飾子はこれをオーバーライドします）。 Perlはバックティックを通常の区切り文字として扱うことに注意してください。置換テキストはコマンドとして評価されません。の場合</target>
        </trans-unit>
        <trans-unit id="21321c35f59a007bf7dcddd13bebabd646dd3b58" translate="yes" xml:space="preserve">
          <source>Any number of &lt;code&gt;(*PRUNE)&lt;/code&gt; assertions may be used in a pattern.</source>
          <target state="translated">任意の数の &lt;code&gt;(*PRUNE)&lt;/code&gt; アサーションをパターンで使用できます。</target>
        </trans-unit>
        <trans-unit id="8bc2478d6a5974c2f338a393e6f6ea8ec88b251c" translate="yes" xml:space="preserve">
          <source>Any number of arguments can occur in the list before the array but the input and output arrays must be the last elements in the list.</source>
          <target state="translated">配列の前には任意の数の引数をリストに入れることができますが、入力配列と出力配列はリストの最後の要素でなければなりません。</target>
        </trans-unit>
        <trans-unit id="637eecabf535d7591a4a05a68e784539a4cbb56d" translate="yes" xml:space="preserve">
          <source>Any number of tildes and surrounding whitespace will be collapsed to a single space.</source>
          <target state="translated">任意の数のチルダとその周囲のホワイトスペースは、1つのスペースに折りたたまれます。</target>
        </trans-unit>
        <trans-unit id="6743acd9891044d5d8bdbb4fb2163336b42729f9" translate="yes" xml:space="preserve">
          <source>Any numerical value returned which is less than SVt_PVAV will be a scalar of some form.</source>
          <target state="translated">SVt_PVAV 未満の数値が返された場合は、何らかの形式のスカラとなります。</target>
        </trans-unit>
        <trans-unit id="c027e1a6e6b64e23c560209fac7288c23f0070f0" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;IO::Socket#CONSTRUCTOR-ARGUMENTS&quot;&gt;&quot;CONSTRUCTOR ARGUMENTS&quot; in IO::Socket&lt;/a&gt; may be passed to the constructor, but if any arguments are provided, then one of them must be the &lt;a href=&quot;IO::Socket#Domain&quot;&gt;&quot;Domain&quot; in IO::Socket&lt;/a&gt; argument. The &lt;a href=&quot;IO::Socket#Domain&quot;&gt;&quot;Domain&quot; in IO::Socket&lt;/a&gt; argument can, by default, be either &lt;code&gt;AF_INET&lt;/code&gt; or &lt;code&gt;AF_UNIX&lt;/code&gt;. Other domains can be used if a proper subclass for the domain family is registered. All other arguments will be passed to the &lt;code&gt;configuration&lt;/code&gt; method of the package for that domain.</source>
          <target state="translated">&lt;a href=&quot;IO::Socket#CONSTRUCTOR-ARGUMENTS&quot;&gt;IO :: Socket&lt;/a&gt;の「CONSTRUCTORARGUMENTS」のいずれかをコンストラクターに渡すことができますが、引数が指定されている場合は、そのうちの1つが&lt;a href=&quot;IO::Socket#Domain&quot;&gt;IO :: Socket&lt;/a&gt;引数の「Domain」である必要があります。&lt;a href=&quot;IO::Socket#Domain&quot;&gt;IO :: Socket&lt;/a&gt;引数の「ドメイン」は、デフォルトで &lt;code&gt;AF_INET&lt;/code&gt; または &lt;code&gt;AF_UNIX&lt;/code&gt; のいずれかになります。ドメインファミリの適切なサブクラスが登録されている場合は、他のドメインを使用できます。他のすべての引数は、そのドメインのパッケージの &lt;code&gt;configuration&lt;/code&gt; メソッドに渡されます。</target>
        </trans-unit>
        <trans-unit id="d9c5d3662ce5a04f9a5a84a78523f9d65e2d1542" translate="yes" xml:space="preserve">
          <source>Any of the bit masks can also be &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;. The timeout, if specified, is in seconds, which may be fractional. Note: not all implementations are capable of returning the &lt;code&gt;$timeleft&lt;/code&gt;. If not, they always return &lt;code&gt;$timeleft&lt;/code&gt; equal to the supplied &lt;code&gt;$timeout&lt;/code&gt;.</source>
          <target state="translated">どのビットマスクも&lt;a href=&quot;#undef-EXPR&quot;&gt; &lt;code&gt;undef&lt;/code&gt; に&lt;/a&gt;することができます。指定されている場合、タイムアウトは秒単位であり、小数になる場合があります。注：すべての実装が &lt;code&gt;$timeleft&lt;/code&gt; を返すことができるわけではありません。そうでない場合は、常に、指定された &lt;code&gt;$timeout&lt;/code&gt; 等しい &lt;code&gt;$timeleft&lt;/code&gt; 返します。</target>
        </trans-unit>
        <trans-unit id="799d3a594ea06ab8f69431e4521092706a0ca250" translate="yes" xml:space="preserve">
          <source>Any of the bit masks can also be undef. The timeout, if specified, is in seconds, which may be fractional. Note: not all implementations are capable of returning the $timeleft. If not, they always return $timeleft equal to the supplied $timeout.</source>
          <target state="translated">ビットマスクのいずれかを undef にすることもできます。タイムアウトが指定されている場合は、秒単位で指定します。注意:すべての実装が $timeleft を返すことができるわけではありません。そうでない場合は、常に与えられた $timeout と等しい $timeleft を返します。</target>
        </trans-unit>
        <trans-unit id="96dac77ef4a45d1d47b4f15ad920f1efda518fb4" translate="yes" xml:space="preserve">
          <source>Any of these modifiers can be set to apply globally to all regular expressions compiled within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; . See &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;'/flags' mode in re&lt;/a&gt;.</source>
          <target state="translated">これらの修飾子は、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re&lt;/code&gt; のスコープ内でコンパイルされたすべての正規表現にグローバルに適用されるように設定できます。&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;reの「/ flags」モードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="511eb3ecca55bf6890b46608108a95afce5c385f" translate="yes" xml:space="preserve">
          <source>Any of these modifiers can be set to apply globally to all regular expressions compiled within the scope of a &lt;code&gt;use re&lt;/code&gt;. See &lt;a href=&quot;re#%27%2Fflags%27-mode&quot;&gt;&quot;'/flags' mode&quot; in re&lt;/a&gt;.</source>
          <target state="translated">これらの修飾子のいずれかがの範囲内でコンパイルされ、すべての正規表現にグローバルに適用するように設定することができ &lt;code&gt;use re&lt;/code&gt; 。&lt;a href=&quot;re#%27%2Fflags%27-mode&quot;&gt;reの「/ flags」モードを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="d72e7a2b4416a01397ed95a3d69723c275ceb3de" translate="yes" xml:space="preserve">
          <source>Any of these statements are nice replacements for &lt;code&gt;BEGIN { &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter; @ISA = qw(Exporter); }&lt;/code&gt; with the same compile-time effect. The basic difference is that &lt;code&gt;base&lt;/code&gt; code interacts with declared &lt;code&gt;fields&lt;/code&gt; while &lt;code&gt;parent&lt;/code&gt; is a streamlined version of the older &lt;code&gt;base&lt;/code&gt; code to just establish the IS-A relationship.</source>
          <target state="translated">これらのステートメントはいずれも、 &lt;code&gt;BEGIN { &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; Exporter; @ISA = qw(Exporter); }&lt;/code&gt; 代わりに使用できます。 @ISA = qw（エクスポーター）; }同じコンパイル時の効果を有します。基本的な違いは、ある &lt;code&gt;base&lt;/code&gt; 宣言とコードの相互作用 &lt;code&gt;fields&lt;/code&gt; 間、 &lt;code&gt;parent&lt;/code&gt; 古いの合理化バージョンである &lt;code&gt;base&lt;/code&gt; だけでIS-A関係を確立するコードが。</target>
        </trans-unit>
        <trans-unit id="a58afbeb2eaab93b0832f3d91597b76dd426bf94" translate="yes" xml:space="preserve">
          <source>Any of these statements are nice replacements for &lt;code&gt;BEGIN { require Exporter; @ISA = qw(Exporter); }&lt;/code&gt; with the same compile-time effect. The basic difference is that &lt;code&gt;base&lt;/code&gt; code interacts with declared &lt;code&gt;fields&lt;/code&gt; while &lt;code&gt;parent&lt;/code&gt; is a streamlined version of the older &lt;code&gt;base&lt;/code&gt; code to just establish the IS-A relationship.</source>
          <target state="translated">これらのステートメントはいずれも、 &lt;code&gt;BEGIN { require Exporter; @ISA = qw(Exporter); }&lt;/code&gt; 優れた代替品です。@ISA = qw（Exporter）; }同じコンパイル時の効果があります。基本的な違いは、 &lt;code&gt;base&lt;/code&gt; コードが宣言された &lt;code&gt;fields&lt;/code&gt; と相互作用するのに対し、 &lt;code&gt;parent&lt;/code&gt; はIS-A関係を確立するための古い &lt;code&gt;base&lt;/code&gt; コードの合理化されたバージョンであるということです。</target>
        </trans-unit>
        <trans-unit id="54d3e07363608f1d20995e0548f7b8658feed7f4" translate="yes" xml:space="preserve">
          <source>Any omitted or empty regular expressions will default to &quot;.*&quot;. Please note that each regular expression given is implicitly anchored by adding &quot;^&quot; and &quot;$&quot; to the beginning and end. Also, if a given regular expression starts with a &quot;!&quot; character, then the expression is</source>
          <target state="translated">省略された正規表現や空の正規表現はデフォルトで &quot;.*&quot; となります。与えられた各正規表現は、最初と最後に&quot;^&quot;と&quot;$&quot;を追加することで、暗黙のうちにアンカーされていることに注意してください。また、与えられた正規表現が&quot;!&quot;文字で始まる場合、その正規表現は</target>
        </trans-unit>
        <trans-unit id="0f87f06eba2caf7b827d1f8e16065d83ac575560" translate="yes" xml:space="preserve">
          <source>Any other character it taken literally.</source>
          <target state="translated">他のキャラクターは、それが文字通り取られています。</target>
        </trans-unit>
        <trans-unit id="3effb550cd8c77527aa9de81743828a3b7722f93" translate="yes" xml:space="preserve">
          <source>Any other parameters specific to the method</source>
          <target state="translated">メソッドに固有のその他のパラメータ</target>
        </trans-unit>
        <trans-unit id="c9c0186423c77aa8d8e97bed87ca7acf745a240d" translate="yes" xml:space="preserve">
          <source>Any other return code means that a flush point was not found. If more data is available, &lt;code&gt;inflateSync&lt;/code&gt; can be called repeatedly with more compressed data until the flush point is found.</source>
          <target state="translated">その他の戻りコードは、フラッシュポイントが見つからなかったことを意味します。より多くのデータが利用可能な場合、フラッシュポイントが見つかるまで、より多くの圧縮データを使用して &lt;code&gt;inflateSync&lt;/code&gt; を繰り返し呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="f1dc9b8d3bdcecba91d97097df903ce52027fe14" translate="yes" xml:space="preserve">
          <source>Any other string</source>
          <target state="translated">その他の文字列</target>
        </trans-unit>
        <trans-unit id="26c9cefe7b574f70d77490b40ef9d059faa47f0c" translate="yes" xml:space="preserve">
          <source>Any parameters to be pushed onto the stack should be bracketed by the &lt;code&gt;PUSHMARK&lt;/code&gt; and &lt;code&gt;PUTBACK&lt;/code&gt; macros. The purpose of these two macros, in this context, is to count the number of parameters you are pushing automatically. Then whenever Perl is creating the &lt;code&gt;@_&lt;/code&gt; array for the subroutine, it knows how big to make it.</source>
          <target state="translated">スタックにプッシュされるパラメーターは、 &lt;code&gt;PUTBACK&lt;/code&gt; マクロとPUTBACKマクロで &lt;code&gt;PUSHMARK&lt;/code&gt; 必要があります。この2つのマクロの目的は、このコンテキストでは、自動的にプッシュするパラメーターの数をカウントすることです。そうすれば、Perlがサブルーチン用の &lt;code&gt;@_&lt;/code&gt; 配列を作成するときはいつでも、その大きさを知っています。</target>
        </trans-unit>
        <trans-unit id="393576095a8de6bc0086f7597df6e48f941f115a" translate="yes" xml:space="preserve">
          <source>Any pattern containing a special backtracking verb that allows an argument has the special behaviour that when executed it sets the current package's &lt;code&gt;$REGERROR&lt;/code&gt; and &lt;code&gt;$REGMARK&lt;/code&gt; variables. When doing so the following rules apply:</source>
          <target state="translated">引数を許可する特別なバックトラッキング動詞を含むパターンには、実行時に現在のパッケージの &lt;code&gt;$REGERROR&lt;/code&gt; および &lt;code&gt;$REGMARK&lt;/code&gt; 変数を設定するという特別な動作があります。その際、次のルールが適用されます。</target>
        </trans-unit>
        <trans-unit id="0f7c0d8ab3a57bbfaec5da2f59e5489aaf2f7ee1" translate="yes" xml:space="preserve">
          <source>Any references that are the same as one of those passed in will be named &lt;code&gt;$VAR&lt;/code&gt;</source>
          <target state="translated">渡されたものと同じ参照はすべて &lt;code&gt;$VAR&lt;/code&gt; という名前になります</target>
        </trans-unit>
        <trans-unit id="d0947cd6471d04a9e9e7aba2d6ed254ce36b6a65" translate="yes" xml:space="preserve">
          <source>Any regular expression special characters in &lt;code&gt;$regex&lt;/code&gt; are still special, and the pattern still has to be valid or Perl will complain. For instance, in this pattern there is an unpaired parenthesis.</source>
          <target state="translated">&lt;code&gt;$regex&lt;/code&gt; 表現の特殊文字は依然として特殊であり、パターンはまだ有効である必要があります。そうしないと、Perlから不満が出ます。たとえば、このパターンでは、対になっていない括弧があります。</target>
        </trans-unit>
        <trans-unit id="fe7f6f318181e1a9721562694a44d98bb9f0d89c" translate="yes" xml:space="preserve">
          <source>Any scalar value that doesn&amp;rsquo;t evaluate to 0 or &lt;code&gt;&quot;&quot;&lt;/code&gt; .</source>
          <target state="translated">0または &lt;code&gt;&quot;&quot;&lt;/code&gt; に評価されないスカラー値。</target>
        </trans-unit>
        <trans-unit id="bc814185c98806f976443ba7f707c9de190e5102" translate="yes" xml:space="preserve">
          <source>Any scalar value that doesn&amp;rsquo;t evaluate to 0 or &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">0または &lt;code&gt;&quot;&quot;&lt;/code&gt; に評価されないスカラー値。</target>
        </trans-unit>
        <trans-unit id="1aef8e8c0d886239b79a86d40fbcb9638ca8176a" translate="yes" xml:space="preserve">
          <source>Any scalar variable may carry &lt;code&gt;PERL_MAGIC_collxfrm&lt;/code&gt; magic that contains the scalar data of the variable, but transformed to such a format that a normal memory comparison can be used to compare the data according to the locale settings.</source>
          <target state="translated">どのスカラー変数も、変数のスカラーデータを含む &lt;code&gt;PERL_MAGIC_collxfrm&lt;/code&gt; マジックを実行できますが、通常のメモリ比較を使用してロケール設定に従ってデータを比較できるような形式に変換されます。</target>
        </trans-unit>
        <trans-unit id="b9848f5389028c0e6f897c58baee24bbe4b4452b" translate="yes" xml:space="preserve">
          <source>Any scalar variable may carry PERL_MAGIC_collxfrm magic that contains the scalar data of the variable, but transformed to such a format that a normal memory comparison can be used to compare the data according to the locale settings.</source>
          <target state="translated">任意のスカラ変数は、その変数のスカラデータを含むPERL_MAGIC_collxfrmマジックを運ぶことができますが、通常のメモリ比較がロケール設定に従ってデータを比較するために使用できるような形式に変換されています。</target>
        </trans-unit>
        <trans-unit id="38fbec488780a53c892b68c97c1898064ef5cf3c" translate="yes" xml:space="preserve">
          <source>Any simple statement may optionally be followed by a</source>
          <target state="translated">任意の単純な文の後には、オプションで</target>
        </trans-unit>
        <trans-unit id="6edad6532b87dcd9565ed8ca948fd8e9febfc827" translate="yes" xml:space="preserve">
          <source>Any single character in a pattern matches that same character in the target string, unless the character is a</source>
          <target state="translated">パターン内の単一の文字は、ターゲット文字列内の同じ文字にマッチします。</target>
        </trans-unit>
        <trans-unit id="d57ad08ad6b4b977666be8da12ed7e9b3597a3e6" translate="yes" xml:space="preserve">
          <source>Any single character matches itself, unless it is a</source>
          <target state="translated">1つの文字がそれ自体にマッチするものは、それが</target>
        </trans-unit>
        <trans-unit id="f581a0aac4749093894a9605cfac9a184c97919e" translate="yes" xml:space="preserve">
          <source>Any special flags that might need to be passed to ld to create a shared library suitable for dynamic loading. It is up to the makefile to use it. (See &lt;a href=&quot;../config#lddlflags&quot;&gt;lddlflags in Config&lt;/a&gt;)</source>
          <target state="translated">動的ロードに適した共有ライブラリを作成するためにldに渡す必要がある特別なフラグ。それを使用するのはメイクファイル次第です。（&lt;a href=&quot;../config#lddlflags&quot;&gt;構成のlddlflagsを&lt;/a&gt;参照）</target>
        </trans-unit>
        <trans-unit id="bea6827ac537eb7924457a4cf759d617d88c98bb" translate="yes" xml:space="preserve">
          <source>Any special flags that might need to be passed to ld to create a shared library suitable for dynamic loading. It is up to the makefile to use it. (See &lt;a href=&quot;config#lddlflags&quot;&gt;&quot;lddlflags&quot; in Config&lt;/a&gt;)</source>
          <target state="translated">動的ロードに適した共有ライブラリを作成するためにldに渡す必要がある可能性のある特別なフラグ。それを使用するのはmakefile次第です。（&lt;a href=&quot;config#lddlflags&quot;&gt;Configの「lddlflags」を&lt;/a&gt;参照してください）</target>
        </trans-unit>
        <trans-unit id="cae1c49f6637fcf58ae140f395f043a2e193fb5a" translate="yes" xml:space="preserve">
          <source>Any statement within the body of a loop that can make a loop prematurely stop looping or skip an &lt;b&gt;iteration&lt;/b&gt;. Generally, you shouldn&amp;rsquo;t try this on roller coasters.</source>
          <target state="translated">ループが途中でループを停止したり、&lt;b&gt;反復を&lt;/b&gt;スキップしたりする可能性がある、ループの本体内のステートメント。一般的に、ジェットコースターではこれを試してはいけません。</target>
        </trans-unit>
        <trans-unit id="a7b963c94b597f0a356b5a56744621822590c340" translate="yes" xml:space="preserve">
          <source>Any string eval which is executed by code executing in a compartment, or by code called from code executing in a compartment, will be eval'd in the namespace of the compartment. This is potentially a serious problem.</source>
          <target state="translated">コンパートメント内で実行されたコードや、コンパートメント内で実行されたコードから呼び出されたコードによって実行された文字列evalは、コンパートメントの名前空間でevalされます。これは潜在的に深刻な問題です。</target>
        </trans-unit>
        <trans-unit id="8a7a9db7b2a7d9c3bc4a0371b24f090bb005ce01" translate="yes" xml:space="preserve">
          <source>Any switches in the &lt;code&gt;PERLDOC&lt;/code&gt; environment variable will be used before the command line arguments.</source>
          <target state="translated">&lt;code&gt;PERLDOC&lt;/code&gt; 環境変数内のスイッチは、コマンドライン引数の前に使用されます。</target>
        </trans-unit>
        <trans-unit id="7c3b8e236160fc72cba179bfa08e7e8fcf86e97c" translate="yes" xml:space="preserve">
          <source>Any test which does not match a rule will be run in sequence at the end of the run.</source>
          <target state="translated">ルールにマッチしないテストは、実行の最後に順番に実行されます。</target>
        </trans-unit>
        <trans-unit id="c697d8a2e427d5d56c9e1028dbc399fcc4b347e2" translate="yes" xml:space="preserve">
          <source>Any time after Perl starts running your main program. See also &lt;b&gt;compile phase&lt;/b&gt;. Run phase is mostly spent in &lt;b&gt;runtime&lt;/b&gt; but may also be spent in &lt;b&gt;compile time&lt;/b&gt; when &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Perlがメインプログラムの実行を開始した後。&lt;b&gt;コンパイルフェーズ&lt;/b&gt;も参照してください。実行フェーズは、ほとんどに費やされている&lt;b&gt;ランタイム&lt;/b&gt;もで過ごしたことがあり&lt;b&gt;、コンパイル時&lt;/b&gt;際に &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2c3d3bd0813c99a89a071ee04615c19b004d52d" translate="yes" xml:space="preserve">
          <source>Any time after Perl starts running your main program. See also &lt;b&gt;compile phase&lt;/b&gt;. Run phase is mostly spent in &lt;b&gt;runtime&lt;/b&gt; but may also be spent in &lt;b&gt;compile time&lt;/b&gt; when &lt;code&gt;require&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;</source>
          <target state="translated">Perlがメインプログラムの実行を開始した後はいつでも。&lt;b&gt;コンパイルフェーズ&lt;/b&gt;も参照してください。実行フェーズは主に&lt;b&gt;実行時に&lt;/b&gt;費やされ&lt;b&gt;ます&lt;/b&gt;が、 &lt;code&gt;require&lt;/code&gt; に&lt;b&gt;応じてコンパイル時間&lt;/b&gt;にも費やされる場合があり &lt;code&gt;do&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00807e0e44bec9e684bd05f5d6ca841ffb6f513c" translate="yes" xml:space="preserve">
          <source>Any time before Perl starts running your main program. See also &lt;b&gt;run phase&lt;/b&gt;. Compile phase is mostly spent in &lt;b&gt;compile time&lt;/b&gt;, but may also be spent in &lt;b&gt;runtime&lt;/b&gt; when &lt;code&gt;BEGIN&lt;/code&gt; blocks, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; declarations, or constant subexpressions are being evaluated. The startup and import code of any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; declaration is also run during compile phase.</source>
          <target state="translated">Perlがメインプログラムの実行を開始する前。&lt;b&gt;実行フェーズ&lt;/b&gt;も参照してください。コンパイルフェーズは主に&lt;b&gt;コンパイル時&lt;/b&gt;に費やされ&lt;b&gt;ますが&lt;/b&gt;、 &lt;code&gt;BEGIN&lt;/code&gt; ブロック、宣言の &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; または宣言 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt;&lt;/code&gt; 、または定数の部分式が評価されるときに、&lt;b&gt;ランタイム&lt;/b&gt;にも費やされ&lt;b&gt;ます&lt;/b&gt;。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; 宣言の起動コードとインポートコードもコンパイルフェーズで実行されます。</target>
        </trans-unit>
        <trans-unit id="89bbb32771fb02c8c9a2b7c9c816ca4c3b49cddb" translate="yes" xml:space="preserve">
          <source>Any time before Perl starts running your main program. See also &lt;b&gt;run phase&lt;/b&gt;. Compile phase is mostly spent in &lt;b&gt;compile time&lt;/b&gt;, but may also be spent in &lt;b&gt;runtime&lt;/b&gt; when &lt;code&gt;BEGIN&lt;/code&gt; blocks, &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;no&lt;/code&gt; declarations, or constant subexpressions are being evaluated. The startup and import code of any &lt;code&gt;use&lt;/code&gt; declaration is also run during compile phase.</source>
          <target state="translated">Perlがメインプログラムの実行を開始する前であればいつでも。&lt;b&gt;実行フェーズ&lt;/b&gt;も参照してください。コンパイルフェーズは主に&lt;b&gt;コンパイル時間&lt;/b&gt;に費やされ&lt;b&gt;ますが&lt;/b&gt;、 &lt;code&gt;BEGIN&lt;/code&gt; ブロック、宣言の &lt;code&gt;use&lt;/code&gt; または &lt;code&gt;no&lt;/code&gt; 使用、または定数部分式が評価されている&lt;b&gt;実行時&lt;/b&gt;にも費やされる場合があります。 &lt;code&gt;use&lt;/code&gt; 宣言の起動コードとインポートコードも、コンパイルフェーズで実行されます。</target>
        </trans-unit>
        <trans-unit id="08963a941982a994fe2895ea2c775da89cda3e41" translate="yes" xml:space="preserve">
          <source>Any time you're doing a &quot;this equals that&quot; sort of test, use &lt;code&gt;is()&lt;/code&gt;. It even works on arrays. The test is always in scalar context, so you can test how many elements are in an array this way. [5]</source>
          <target state="translated">「これはそれに等しい」種類のテストを実行するときはいつでも、 &lt;code&gt;is()&lt;/code&gt; を使用してください。配列でも機能します。テストは常にスカラーコンテキストで行われるため、この方法で配列に含まれる要素の数をテストできます。[5]</target>
        </trans-unit>
        <trans-unit id="aa83fb5c769020023303529abde854eefeaa0d66" translate="yes" xml:space="preserve">
          <source>Any version between 1.00 and 1.82 inclusive would be acceptable, except for 1.75.</source>
          <target state="translated">1.00から1.82までの間であれば、1.75を除いてどのバージョンでも構いません。</target>
        </trans-unit>
        <trans-unit id="c34097998161c40da19bcb944501b160cf796dc7" translate="yes" xml:space="preserve">
          <source>Any version from version 1.2 onward, except version 1.5, that also precedes version 2.0.</source>
          <target state="translated">バージョン1.5を除き、バージョン1.2以降のすべてのバージョンで、バージョン2.0に先行するもの。</target>
        </trans-unit>
        <trans-unit id="db5515dadcc88944ac0dd16b3a430dc89d34c3d0" translate="yes" xml:space="preserve">
          <source>Any version which &quot;looks like a number&quot;, see &lt;a href=&quot;#Decimal-Versions&quot;&gt;&quot;Decimal Versions&quot;&lt;/a&gt;. This also includes versions with a single decimal point and a single embedded underscore, see &lt;a href=&quot;#Alpha-Versions&quot;&gt;&quot;Alpha Versions&quot;&lt;/a&gt;, even though these must be quoted to preserve the underscore formatting.</source>
          <target state="translated">「数字のように見える&lt;a href=&quot;#Decimal-Versions&quot;&gt;」バージョン&lt;/a&gt;については、「10進バージョン」を参照してください。これには、小数点が1つ、アンダースコアが埋め込まれているバージョンも含まれます。アンダースコアの形式を維持するために引用符で囲む必要がありますが、&lt;a href=&quot;#Alpha-Versions&quot;&gt;「アルファバージョン」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="7bc6b65d5c451906eff3dea5dd5120214b2325bd" translate="yes" xml:space="preserve">
          <source>Any/all fields and accessors are autovivified into existence. There is no way to know what metadata may be added, so any is allowed.</source>
          <target state="translated">任意の/すべてのフィールドとアクセサは自動的に存在するようになっています。どのようなメタデータが追加されるかを知る方法はありませんので、どのようなものでも許されます。</target>
        </trans-unit>
        <trans-unit id="5bea195cc0120bd58a5f6ddfad70e861a932bba8" translate="yes" xml:space="preserve">
          <source>AnyDBM_File</source>
          <target state="translated">AnyDBM_File</target>
        </trans-unit>
        <trans-unit id="abf989fc06a7a8552843b93b1474a012067198d8" translate="yes" xml:space="preserve">
          <source>AnyDBM_File - provide framework for multiple DBMs</source>
          <target state="translated">AnyDBM_File-複数のDBM用のフレームワークを提供します。</target>
        </trans-unit>
        <trans-unit id="29c9b5ccd4a8843ac06d93de6db98a168d9747a5" translate="yes" xml:space="preserve">
          <source>Anyone interested in resurrecting this file should pull the old version from the MakeMaker CVS repository and contact makemaker@perl.org.</source>
          <target state="translated">このファイルの復活に興味がある人は、MakeMaker CVS リポジトリから古いバージョンを引っ張ってきて、makemaker@perl.org に連絡してください。</target>
        </trans-unit>
        <trans-unit id="f1313a33b13e0ad302add61f009e5344735237ef" translate="yes" xml:space="preserve">
          <source>Anything after this line is the description of XSUB functions. These descriptions are translated by &lt;b&gt;xsubpp&lt;/b&gt; into C code which implements these functions using Perl calling conventions, and which makes these functions visible from Perl interpreter.</source>
          <target state="translated">この行の後は、XSUB関数の説明です。これらの記述は、&lt;b&gt;xsubppによって&lt;/b&gt;、Perl呼び出し規約を使用してこれらの関数を実装し、Perlインタープリターからこれらの関数を見えるようにするCコードに変換されます。</target>
        </trans-unit>
        <trans-unit id="7767ddde79c4e54f955f8a8770af897489800878" translate="yes" xml:space="preserve">
          <source>Anything before this line is plain C code which describes which headers to include, and defines some convenience functions. No translations are performed on this part, apart from having embedded POD documentation skipped over (see &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;) it goes into the generated output C file as is.</source>
          <target state="translated">この行の前は、インクルードするヘッダーを記述し、いくつかの便利な関数を定義するプレーンなCコードです。埋め込まれたPODドキュメントがスキップされる（&lt;a href=&quot;perlpod&quot;&gt;perlpodを&lt;/a&gt;参照）ことを除いて、この部分では変換は行われず、生成された出力Cファイルにそのまま送られます。</target>
        </trans-unit>
        <trans-unit id="9e010e0ae6e0590e5e1834d00dd2ae5e4328a555" translate="yes" xml:space="preserve">
          <source>Anything between white space and an end of line within a &lt;code&gt;MANIFEST&lt;/code&gt; file is considered to be a comment. Any line beginning with # is also a comment. Beginning with ExtUtils::Manifest 1.52, a filename may contain whitespace characters if it is enclosed in single quotes; single quotes or backslashes in that filename must be backslash-escaped.</source>
          <target state="translated">空白と &lt;code&gt;MANIFEST&lt;/code&gt; ファイル内の行の終わりの間のすべてはコメントと見なされます。＃で始まる行もコメントです。ExtUtils :: Manifest 1.52以降、ファイル名が一重引用符で囲まれている場合、ファイル名に空白文字が含まれる可能性があります。そのファイル名の単一引用符またはバックスラッシュは、バックスラッシュでエスケープする必要があります。</target>
        </trans-unit>
        <trans-unit id="d23663e502213da0e6ba19093e62429d22e02845" translate="yes" xml:space="preserve">
          <source>Anything else is a Perl-specific convenience abbreviation. Specify one or more scripts by names if you want short names that are script-specific.</source>
          <target state="translated">それ以外のものは Perl 固有の便宜上の略語です。スクリプト固有の短い名前を付けたい場合は、1つ以上のスクリプトを名前で指定します。</target>
        </trans-unit>
        <trans-unit id="7d749de0de5c93aeb0a7eeebe5226cb0dd35304d" translate="yes" xml:space="preserve">
          <source>Anything in EXPR that matches PATTERN is taken to be a separator that separates the EXPR into substrings (called &quot;</source>
          <target state="translated">EXPRの中でPATTERNにマッチするものは、EXPRを部分文字列に分離するセパレータとして扱われます(これを&quot;</target>
        </trans-unit>
        <trans-unit id="beac50162375e06d01167c42cce2dc5426c4e092" translate="yes" xml:space="preserve">
          <source>Anything marked as BE is Big Endian (or network byte order) and LE is Little Endian (aka VAX byte order). For anything not marked either BE or LE, a character called Byte Order Mark (BOM) indicating the endianness is prepended to the string.</source>
          <target state="translated">BE とマークされているものはすべてビッグエンディアン(またはネットワークバイトオーダー)であり、LE はリトルエンディアン(別名 VAX バイトオーダー)です。BE または LE のいずれかにマークされていないものについては、エンディアンを示すバイト・オーダー・マーク (BOM)と呼ばれる文字が文字列の前に付加されます。</target>
        </trans-unit>
        <trans-unit id="09e186b65803161a334d1142c77aae1e01d4460e" translate="yes" xml:space="preserve">
          <source>Anything not listed here is not part of the public API, and should not be used by extension writers at all. For these reasons, blindly using functions listed in proto.h is to be avoided when writing extensions.</source>
          <target state="translated">ここにリストされていないものはすべて公開APIの一部ではないので、拡張機能を書く人が使うべきではありません。これらの理由から、proto.h に記載されている関数を盲目的に使うことは、拡張機能を書く際には避けた方がよいでしょう。</target>
        </trans-unit>
        <trans-unit id="43c6485292ca5760fa287d9f9ae8c3f36373f766" translate="yes" xml:space="preserve">
          <source>Anything put here will be passed to &lt;a href=&quot;ExtUtils::MM_Any#postamble-%28o%29&quot;&gt;MY::postamble()&lt;/a&gt; if you have one.</source>
          <target state="translated">ここに入力されたものはすべて&lt;a href=&quot;ExtUtils::MM_Any#postamble-%28o%29&quot;&gt;MY :: postamble（）に&lt;/a&gt;渡されます（ある場合）。</target>
        </trans-unit>
        <trans-unit id="595fc50992e17250599953061722960b35607014" translate="yes" xml:space="preserve">
          <source>Anything put here will be passed to MY::postamble() if you have one.</source>
          <target state="translated">ここに書かれたものは、もしあれば MY::postamble()に渡されます。</target>
        </trans-unit>
        <trans-unit id="eb489bfffc02c3f32a21cb7909eae48c47e3d9b4" translate="yes" xml:space="preserve">
          <source>Anything that follows &lt;code&gt;#&lt;/code&gt; is treated as a comment.</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; に続くものはすべてコメントとして扱われます。</target>
        </trans-unit>
        <trans-unit id="aaea73d52ae0a47a220342d260ea4c54a027d322" translate="yes" xml:space="preserve">
          <source>Anything you can legally say in a spot where a &lt;b&gt;value&lt;/b&gt; is required. Typically composed of &lt;b&gt;literals&lt;/b&gt;, &lt;b&gt;variables&lt;/b&gt;, &lt;b&gt;operators&lt;/b&gt;, &lt;b&gt;functions&lt;/b&gt;, and &lt;b&gt;subroutine&lt;/b&gt; calls, not necessarily in that order.</source>
          <target state="translated">&lt;b&gt;値&lt;/b&gt;が必要な場所で合法的に言えること。通常、&lt;b&gt;リテラル&lt;/b&gt;、&lt;b&gt;変数&lt;/b&gt;、&lt;b&gt;演算子&lt;/b&gt;、&lt;b&gt;関数&lt;/b&gt;、および&lt;b&gt;サブルーチン&lt;/b&gt;呼び出しで構成され&lt;b&gt;ますが&lt;/b&gt;、必ずしもこの順序である必要はありません。</target>
        </trans-unit>
        <trans-unit id="90ac4d3777dbcf43ec0f981e70e6cb4230e6e6f9" translate="yes" xml:space="preserve">
          <source>Anyway, here it is. Should run on perl v4 or greater. Maybe less.</source>
          <target state="translated">とにかく、これです。perl v4以上で動作するはずです。それ以下かもしれません。</target>
        </trans-unit>
        <trans-unit id="2e755b3358691db1161de932e3c7e74daf5374dd" translate="yes" xml:space="preserve">
          <source>Anyway, this is what you can do if you can't help yourself.</source>
          <target state="translated">とにかく、どうしようもない時には、これでいいのです。</target>
        </trans-unit>
        <trans-unit id="61fbeb450419f819d1d3fb527e61bbd77f1f245b" translate="yes" xml:space="preserve">
          <source>Anywhere you'd put an identifier (or chain of identifiers) as part of a variable or subroutine name, you can replace the identifier with a BLOCK returning a reference of the correct type. In other words, the previous examples could be written like this:</source>
          <target state="translated">変数名やサブルーチン名の一部として識別子(または識別子の連鎖)を置く場合はどこでも、識別子を正しい型の参照を返すブロックに置き換えることができます。言い換えれば、先ほどの例は次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="c4897c70becad60eb583b067e9239c22c138553c" translate="yes" xml:space="preserve">
          <source>Anywhere you'd put an identifier (or chain of identifiers) as part of a variable or subroutine name, you can replace the identifier with a simple scalar variable containing a reference of the correct type:</source>
          <target state="translated">変数名やサブルーチン名の一部として識別子(または識別子の連鎖)を置く場合はどこでも、その識別子を正しい型の参照を含む単純なスカラー変数に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="1152548ba48e279bc989a0c42814e21456001922" translate="yes" xml:space="preserve">
          <source>Apache::GZip Revisited</source>
          <target state="translated">Apache::GZip の再訪</target>
        </trans-unit>
        <trans-unit id="eef8ccdc1b5028a7590e9e7eb6807d9775169439" translate="yes" xml:space="preserve">
          <source>Apart from being non-portable to some operating systems, this made it difficult to use &lt;code&gt;gzopen&lt;/code&gt; in situations where you wanted to extract/create a gzip data stream that is embedded in a larger file, without having to resort to opening and closing the file multiple times.</source>
          <target state="translated">一部のオペレーティングシステムに移植できないことは別として、これにより、ファイルを複数回開いたり閉じたりすることなく、大きなファイルに埋め込まれているgzipデータストリームを抽出/作成したい状況で &lt;code&gt;gzopen&lt;/code&gt; を使用することが困難になりました。回。</target>
        </trans-unit>
        <trans-unit id="4e3144b6ad1fe422c840b3431e9e995cf1a334a3" translate="yes" xml:space="preserve">
          <source>Apart from discussing the C interface provided by Perl for writing callbacks the document uses a series of examples to show how the interface actually works in practice. In addition some techniques for coding callbacks are covered.</source>
          <target state="translated">このドキュメントでは、Perl が提供するコールバックを書くための C インターフェースの説明の他に、実際にどのように動作するかを示すために、一連の例を使用しています。さらに、コールバックをコーディングするためのテクニックも紹介しています。</target>
        </trans-unit>
        <trans-unit id="6c594049f559b0aa030aaa7fc2712868c419ba1f" translate="yes" xml:space="preserve">
          <source>Apart from now being a boolean, the &lt;code&gt;$^W&lt;/code&gt; variable operates in exactly the same horrible uncontrolled global way, except that it cannot disable/enable default warnings.</source>
          <target state="translated">現在はブール値であることを除けば、 &lt;code&gt;$^W&lt;/code&gt; 変数は、デフォルトの警告を無効/有効にできないことを除いて、まったく同じように制御できないグローバルな方法で動作します。</target>
        </trans-unit>
        <trans-unit id="03dfbadf395083cbac3ebe537f5fd26158769beb" translate="yes" xml:space="preserve">
          <source>Apart from resetting the iterator, &lt;code&gt;values @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt;. (We recommend that you use void context &lt;code&gt;keys @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;values @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">イテレータをリセットすることを除けば、リストコンテキストの &lt;code&gt;values @array&lt;/code&gt; はプレーンな &lt;code&gt;@array&lt;/code&gt; と同じです。（これにはvoidコンテキスト &lt;code&gt;keys @array&lt;/code&gt; を使用することをお勧めしますが、 &lt;code&gt;values @array&lt;/code&gt; するには、そのままにしておくよりも多くのドキュメントが必要になると考えられます。）</target>
        </trans-unit>
        <trans-unit id="177ebac14cb8719946f6e7935d5609a89f70ecb3" translate="yes" xml:space="preserve">
          <source>Apart from the behavior described above, Perl does not expand multiple levels of interpolation. In particular, contrary to the expectations of shell programmers, back-quotes do</source>
          <target state="translated">上記の動作とは別に、Perl は複数レベルの補間を展開しません。特に、シェルプログラマの期待に反して、バッククォートは</target>
        </trans-unit>
        <trans-unit id="5e5b5fcfebfb49c5cb95c4adedad19fe315234ce" translate="yes" xml:space="preserve">
          <source>Apart from the first parameter, import can accept an optional list of parameters. These can be used to pass parameters to the filter. For example:</source>
          <target state="translated">最初のパラメータとは別に、 import はオプションでパラメータのリストを受け取ることができます。これらを使ってフィルタにパラメータを渡すことができます。たとえば次のようになります。</target>
        </trans-unit>
        <trans-unit id="ea290b2592c04a29efbf4275fbffd4e15c783ad7" translate="yes" xml:space="preserve">
          <source>Apart from the overstrike, it in all ways functions like Pod::Text. See &lt;a href=&quot;../text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="translated">重ね打ちは別として、あらゆる点でPod :: Textのように機能します。参照&lt;a href=&quot;../text&quot;&gt;ポッド::テキスト&lt;/a&gt;詳細と利用可能なオプションのために。</target>
        </trans-unit>
        <trans-unit id="da695cf6105edcb1a8b40d8d706c52df71f42750" translate="yes" xml:space="preserve">
          <source>Apart from the overstrike, it in all ways functions like Pod::Text. See &lt;a href=&quot;Pod::Text&quot;&gt;Pod::Text&lt;/a&gt; for details and available options.</source>
          <target state="translated">オーバーストライクは別として、それはあらゆる点でPod :: Textのように機能します。参照&lt;a href=&quot;Pod::Text&quot;&gt;ポッド::テキスト&lt;/a&gt;詳細と利用可能なオプションのために。</target>
        </trans-unit>
        <trans-unit id="9828a7d2d366fc4b8702a1f03e94b53802450369" translate="yes" xml:space="preserve">
          <source>Apollo Domain/OS</source>
          <target state="translated">アポロドメイン/OS</target>
        </trans-unit>
        <trans-unit id="29f771942800f2d67122e33798021164ef80e3a2" translate="yes" xml:space="preserve">
          <source>App::Cpan</source>
          <target state="translated">App::Cpan</target>
        </trans-unit>
        <trans-unit id="5d59978967734805e51a9980657b59fbf6558d9e" translate="yes" xml:space="preserve">
          <source>App::Cpan - easily interact with CPAN from the command line</source>
          <target state="translated">App::Cpan-コマンドラインから簡単に CPAN を操作できます。</target>
        </trans-unit>
        <trans-unit id="59fd50fcdac085cfabfc65f7db775038f8cecc31" translate="yes" xml:space="preserve">
          <source>App::Prove</source>
          <target state="translated">App::Prove</target>
        </trans-unit>
        <trans-unit id="3a1656ea85b06be3923d0763368c6414c09514c6" translate="yes" xml:space="preserve">
          <source>App::Prove - Implements the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">App :: Prove- &lt;code&gt;prove&lt;/code&gt; コマンドを実装します。</target>
        </trans-unit>
        <trans-unit id="7174791288d36e70929f8c68ba39037f796046e4" translate="yes" xml:space="preserve">
          <source>App::Prove::State</source>
          <target state="translated">App::Prove::State</target>
        </trans-unit>
        <trans-unit id="39ce25b85982de5bdaced90b86fd5469adc9a51a" translate="yes" xml:space="preserve">
          <source>App::Prove::State - State storage for the &lt;code&gt;prove&lt;/code&gt; command.</source>
          <target state="translated">App :: Prove :: State- &lt;code&gt;prove&lt;/code&gt; コマンドの状態ストレージ。</target>
        </trans-unit>
        <trans-unit id="96f79883bf2f299a489c18241a0f9c3ce22137d2" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result</source>
          <target state="translated">App::Prove::State::Result</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
