<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="065d987b91e5e5831e84ee6eb6792bbd1900fe0e" translate="yes" xml:space="preserve">
          <source>The old behaviour of immediate croaking can be re-instated by setting &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; to some &lt;code&gt;FALSE&lt;/code&gt; value.</source>
          <target state="translated">即時クローキングの古い動作は、 &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; を &lt;code&gt;FALSE&lt;/code&gt; 値に設定することで元に戻すことができます。</target>
        </trans-unit>
        <trans-unit id="5b386f850ac3d208fd4890f0e6e16aecfa5e9221" translate="yes" xml:space="preserve">
          <source>The old display format style, which can have values &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; or &lt;code&gt;&quot;polar&quot;&lt;/code&gt; , can be changed using the &lt;code&gt;&quot;style&quot;&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; または &lt;code&gt;&quot;polar&quot;&lt;/code&gt; の値を持つことができる古い表示形式スタイルは、 &lt;code&gt;&quot;style&quot;&lt;/code&gt; パラメータを使用して変更できます。</target>
        </trans-unit>
        <trans-unit id="e9569a2edc0d7e856dea14bff6ac690edcc52042" translate="yes" xml:space="preserve">
          <source>The old display format style, which can have values &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; or &lt;code&gt;&quot;polar&quot;&lt;/code&gt;, can be changed using the &lt;code&gt;&quot;style&quot;&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; または &lt;code&gt;&quot;polar&quot;&lt;/code&gt; 値を持つことができる古い表示形式のスタイルは、 &lt;code&gt;&quot;style&quot;&lt;/code&gt; パラメーターを使用して変更できます。</target>
        </trans-unit>
        <trans-unit id="4ffd1da07401f04d08ba15b9c723b21da5d25d24" translate="yes" xml:space="preserve">
          <source>The old form of &lt;code&gt;gv_init_pvn()&lt;/code&gt;. It does not work with UTF-8 strings, as it has no flags parameter. If the &lt;code&gt;multi&lt;/code&gt; parameter is set, the &lt;code&gt;GV_ADDMULTI&lt;/code&gt; flag will be passed to &lt;code&gt;gv_init_pvn()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gv_init_pvn()&lt;/code&gt; の古い形式。フラグパラメータがないため、UTF-8文字列では機能しません。場合 &lt;code&gt;multi&lt;/code&gt; パラメータが設定されている、 &lt;code&gt;GV_ADDMULTI&lt;/code&gt; のフラグに渡される &lt;code&gt;gv_init_pvn()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3404a80aca7096e4f7cc6df65a56468be124f24" translate="yes" xml:space="preserve">
          <source>The old form of gv_init_pvn(). It does not work with UTF8 strings, as it has no flags parameter. If the &lt;code&gt;multi&lt;/code&gt; parameter is set, the GV_ADDMULTI flag will be passed to gv_init_pvn().</source>
          <target state="translated">gv_init_pvn（）の古い形式。flagsパラメータがないため、UTF8文字列では機能しません。場合 &lt;code&gt;multi&lt;/code&gt; パラメータが設定されている、GV_ADDMULTIフラグ）（gv_init_pvnに渡されます。</target>
        </trans-unit>
        <trans-unit id="79188e84f37b880e4a772b5ff3206627de3b874e" translate="yes" xml:space="preserve">
          <source>The old home for the module tests, you shouldn't put anything new in here. There are still some bits and pieces hanging around in here that need to be moved. Perhaps you could move them? Thanks!</source>
          <target state="translated">モジュールテストのための古い家、あなたはここに新しいものを置くべきではありません。ここにはまだ移動させる必要のある断片が ぶら下がっています。おそらく、あなたはそれらを移動することができますか?ありがとう!</target>
        </trans-unit>
        <trans-unit id="37d530fbe2e5d190496e0bd800701dfa6c514e1c" translate="yes" xml:space="preserve">
          <source>The old package delimiter was a single quote, but double colon is now the preferred delimiter, in part because it's more readable to humans, and in part because it's more readable to &lt;b&gt;emacs&lt;/b&gt; macros. It also makes C++ programmers feel like they know what's going on--as opposed to using the single quote as separator, which was there to make Ada programmers feel like they knew what was going on. Because the old-fashioned syntax is still supported for backwards compatibility, if you try to use a string like &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; , you'll be accessing &lt;code&gt;$owner::s&lt;/code&gt; ; that is, the $s variable in package &lt;code&gt;owner&lt;/code&gt; , which is probably not what you meant. Use braces to disambiguate, as in &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; .</source>
          <target state="translated">以前のパッケージ区切り文字は一重引用符でしたが、一部は人間が読みやすく、もう1つは&lt;b&gt;emacs&lt;/b&gt;マクロが読みやすいため、現在は二重コロンが優先区切り文字になっています。また、単一引用符を区切り文字として使用するのではなく、C ++プログラマーは何が起こっているのかを理解しているように感じさせます。旧式の構文は下位互換性のために引き続きサポートされているため、 &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; などの文字列を使用しようとすると、 &lt;code&gt;$owner::s&lt;/code&gt; アクセスします。つまり、パッケージ &lt;code&gt;owner&lt;/code&gt; $ s変数です。これは、おそらく意図したものではありません。 &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; ように、中括弧を使用して曖昧さをなくします。</target>
        </trans-unit>
        <trans-unit id="511ae26f8725e1c7736ec75894aed8905e42064b" translate="yes" xml:space="preserve">
          <source>The old package delimiter was a single quote, but double colon is now the preferred delimiter, in part because it's more readable to humans, and in part because it's more readable to &lt;b&gt;emacs&lt;/b&gt; macros. It also makes C++ programmers feel like they know what's going on--as opposed to using the single quote as separator, which was there to make Ada programmers feel like they knew what was going on. Because the old-fashioned syntax is still supported for backwards compatibility, if you try to use a string like &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt;, you'll be accessing &lt;code&gt;$owner::s&lt;/code&gt;; that is, the $s variable in package &lt;code&gt;owner&lt;/code&gt;, which is probably not what you meant. Use braces to disambiguate, as in &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt;.</source>
          <target state="translated">古いパッケージ区切り文字は一重引用符でしたが、人間が読みやすいことと、&lt;b&gt;emacs&lt;/b&gt;マクロが読みやすいことから、現在では二重コロンが推奨される区切り文字になっています。また、C ++プログラマーは、Adaプログラマーに何が起こっているのかを知っているように感じさせるために存在した一重引用符を区切り文字として使用するのとは対照的に、何が起こっているのかを知っているように感じさせます。下位互換性のために旧式の構文が引き続きサポートされているため、 &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; ような文字列を使用しようとすると、 &lt;code&gt;$owner::s&lt;/code&gt; アクセスすることになります。つまり、パッケージ &lt;code&gt;owner&lt;/code&gt; $ s変数ですが、これはおそらくあなたが意図したものではありません。 &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; ように、中かっこを使用して明確にします。</target>
        </trans-unit>
        <trans-unit id="d9379928fc066063abf44caaff061ee5071ad9c7" translate="yes" xml:space="preserve">
          <source>The old style indented the note:</source>
          <target state="translated">旧態依然としたスタイルでノートをインデントしています。</target>
        </trans-unit>
        <trans-unit id="3d9dec9262d361c18938bccf6c6a18acfa10894f" translate="yes" xml:space="preserve">
          <source>The older (and possibly obsolete) libraries &lt;a href=&quot;Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;</source>
          <target state="translated">古い（そしておそらく時代遅れの）ライブラリ&lt;a href=&quot;Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt;、&lt;a href=&quot;Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e6c9fb581904d8c9128af585c935239bf8557de2" translate="yes" xml:space="preserve">
          <source>The older (and possibly obsolete) libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;</source>
          <target state="translated">古い（おそらく廃止された）ライブラリ&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt;、&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf3a69ba409143423723e457fea838a29577af44" translate="yes" xml:space="preserve">
          <source>The older libraries &lt;a href=&quot;Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;, &lt;a href=&quot;Pod::SAX&quot;&gt;Pod::SAX&lt;/a&gt;</source>
          <target state="translated">古いライブラリ&lt;a href=&quot;Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt;、&lt;a href=&quot;Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;、&lt;a href=&quot;Pod::SAX&quot;&gt;Pod :: SAX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da753c735f79a0349646d5159490ba674b8d624f" translate="yes" xml:space="preserve">
          <source>The older libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod::SAX&lt;/a&gt;</source>
          <target state="translated">古いライブラリ&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt;、&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;、&lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod :: SAX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="995ae7aa276ffe30824f52880be0efab53f1e92d" translate="yes" xml:space="preserve">
          <source>The one argument form of add_bits() takes a $bitstring of &quot;1&quot; and &quot;0&quot; chars as argument. It's a shorthand for &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;,
$bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; .</source>
          <target state="translated">add_bits（）の1つの引数形式は、引数として「1」と「0」の文字の$ bitstringを取ります。これは、 &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;, $bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; 省略形です。</target>
        </trans-unit>
        <trans-unit id="1b86570e54f795ca97d5fe14e7650da16943e0a5" translate="yes" xml:space="preserve">
          <source>The one argument form of add_bits() takes a $bitstring of &quot;1&quot; and &quot;0&quot; chars as argument. It's a shorthand for &lt;code&gt;$ctx-&amp;gt;add_bits(pack(&quot;B*&quot;, $bitstring), length($bitstring))&lt;/code&gt;.</source>
          <target state="translated">add_bits（）の1つの引数形式は、引数として「1」および「0」文字の$ bitstringを取ります。 &lt;code&gt;$ctx-&amp;gt;add_bits(pack(&quot;B*&quot;, $bitstring), length($bitstring))&lt;/code&gt; 省略形です。</target>
        </trans-unit>
        <trans-unit id="7fb0ed6067910ab4f7c54b4b88cf43df00178824" translate="yes" xml:space="preserve">
          <source>The one parameter calling convention also still works.</source>
          <target state="translated">1つのパラメータの呼び出し規則もまだ機能しています。</target>
        </trans-unit>
        <trans-unit id="80912f94b4001d6702c4a5ac8c13128730d9bdf7" translate="yes" xml:space="preserve">
          <source>The one user (apart from the superuser) who has absolute control over a &lt;b&gt;file&lt;/b&gt;. A file may also have a &lt;b&gt;group&lt;/b&gt; of users who may exercise joint ownership if the real owner permits it. See &lt;b&gt;permission bits&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;ファイルを&lt;/b&gt;完全に制御する1人のユーザー（スーパーユーザーを除く）。ファイルには、実際の所有者が許可した場合に共同所有権を行使できるユーザーの&lt;b&gt;グループ&lt;/b&gt;が含まれる場合もあります。&lt;b&gt;許可ビットを&lt;/b&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="ecb6da0a473e0cefde4e91abce89bab9a6e1b78a" translate="yes" xml:space="preserve">
          <source>The one-shot interface allows you to force the creation of a zip64 zip file by including the &lt;code&gt;Zip64&lt;/code&gt; option.</source>
          <target state="translated">ワンショットインターフェイスでは、 &lt;code&gt;Zip64&lt;/code&gt; オプションを含めることで、zip64zipファイルを強制的に作成できます。</target>
        </trans-unit>
        <trans-unit id="bf794f433c5b5ee5b62cabad4f9e0efe662e76bb" translate="yes" xml:space="preserve">
          <source>The only absolutely mandatory method. Called when the layer is pushed onto the stack. The &lt;code&gt;mode&lt;/code&gt; argument may be NULL if this occurs post-open. The &lt;code&gt;arg&lt;/code&gt; will be non-&lt;code&gt;NULL&lt;/code&gt; if an argument string was passed. In most cases this should call &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; to convert &lt;code&gt;mode&lt;/code&gt; into the appropriate &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; flags in addition to any actions the layer itself takes. If a layer is not expecting an argument it need neither save the one passed to it, nor provide &lt;code&gt;Getarg()&lt;/code&gt; (it could perhaps &lt;code&gt;Perl_warn&lt;/code&gt; that the argument was un-expected).</source>
          <target state="translated">唯一必須の方法です。レイヤーがスタックにプッシュされたときに呼び出されます。 &lt;code&gt;mode&lt;/code&gt; このポスト開い発生した場合、引数がNULLかもしれません。 &lt;code&gt;arg&lt;/code&gt; は非なり &lt;code&gt;NULL&lt;/code&gt; 引数の文字列が渡された場合。ほとんどの場合、これは &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; を呼び出して、レイヤー自体が実行するアクションに加えて、 &lt;code&gt;mode&lt;/code&gt; を適切な &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; フラグに変換する必要があります。層が引数を期待していない場合は、それに渡されたものを保存する必要も、 &lt;code&gt;Getarg()&lt;/code&gt; を提供する必要もありません（引数が &lt;code&gt;Perl_warn&lt;/code&gt; しないことをPerl_warnする可能性があります）。</target>
        </trans-unit>
        <trans-unit id="90a79e3c54ca5ed09d00dcfacad6096dece33202" translate="yes" xml:space="preserve">
          <source>The only characters this accepts are the decimal digits '0'..'9'.</source>
          <target state="translated">受け入れられるのは10進数の'0'...9'のみです。</target>
        </trans-unit>
        <trans-unit id="8efd8a42e658c0f7e91c83e2d2d53f100f4033a8" translate="yes" xml:space="preserve">
          <source>The only differences are due to the fact that &lt;code&gt;string_vianame&lt;/code&gt; is run-time and &lt;code&gt;\N{}&lt;/code&gt; is compile time. You can't interpolate inside a &lt;code&gt;\N{}&lt;/code&gt; , (so &lt;code&gt;\N{$variable}&lt;/code&gt; doesn't work); and if the input name is unknown, &lt;code&gt;string_vianame&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; instead of it being a syntax error.</source>
          <target state="translated">唯一の違いは、 &lt;code&gt;string_vianame&lt;/code&gt; が実行時であり、 &lt;code&gt;\N{}&lt;/code&gt; がコンパイル時であるという事実によるものです。 &lt;code&gt;\N{}&lt;/code&gt; 内部を補間することはできません（したがって、 &lt;code&gt;\N{$variable}&lt;/code&gt; は機能しません）。入力名が不明の場合、 &lt;code&gt;string_vianame&lt;/code&gt; は構文エラーではなく、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="77845b478b84dee4e594bd5bbec241147d4e6e80" translate="yes" xml:space="preserve">
          <source>The only differences are due to the fact that &lt;code&gt;string_vianame&lt;/code&gt; is run-time and &lt;code&gt;\N{}&lt;/code&gt; is compile time. You can't interpolate inside a &lt;code&gt;\N{}&lt;/code&gt;, (so &lt;code&gt;\N{$variable}&lt;/code&gt; doesn't work); and if the input name is unknown, &lt;code&gt;string_vianame&lt;/code&gt; returns &lt;code&gt;undef&lt;/code&gt; instead of it being a syntax error.</source>
          <target state="translated">唯一の違いは、 &lt;code&gt;string_vianame&lt;/code&gt; が実行時であり、 &lt;code&gt;\N{}&lt;/code&gt; がコンパイル時であるという事実によるものです。 &lt;code&gt;\N{}&lt;/code&gt; 内を補間することはできません（したがって、 &lt;code&gt;\N{$variable}&lt;/code&gt; は機能しません）。入力名が不明な場合、 &lt;code&gt;string_vianame&lt;/code&gt; は構文エラーではなく &lt;code&gt;undef&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="341b8df1dab5c18fe08d27199395d7d12fe5908e" translate="yes" xml:space="preserve">
          <source>The only flag specified this time was G_SCALAR. That means that the &lt;code&gt;@_&lt;/code&gt; array will be created and that the value returned by</source>
          <target state="translated">今回指定された唯一のフラグはG_SCALARでした。つまり、 &lt;code&gt;@_&lt;/code&gt; 配列が作成され、返される値は</target>
        </trans-unit>
        <trans-unit id="1be9c07fcdeba873e922d933912b59d6dffd7f9b" translate="yes" xml:space="preserve">
          <source>The only interpolation is removal of &lt;code&gt;\&lt;/code&gt; from pairs of &lt;code&gt;\\&lt;/code&gt; . Therefore &lt;code&gt;&quot;-&quot;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; is treated literally as a hyphen and no character range is available. &lt;code&gt;\1&lt;/code&gt; in the replacement of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; does not work as &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">唯一の補間は、 &lt;code&gt;\\&lt;/code&gt; のペアから &lt;code&gt;\&lt;/code&gt; を削除することです。したがって、 &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; と &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&quot;-&quot;&lt;/code&gt; は文字どおりハイフンとして扱われ、使用できる文字範囲はありません。 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; 置き換えにおける &lt;code&gt;\1&lt;/code&gt; は &lt;code&gt;$1&lt;/code&gt; として機能しません。</target>
        </trans-unit>
        <trans-unit id="02eece87de941c6c62eda48e906abba6c3ece7c9" translate="yes" xml:space="preserve">
          <source>The only interpolation is removal of &lt;code&gt;\&lt;/code&gt; from pairs of &lt;code&gt;\\&lt;/code&gt;. Therefore &lt;code&gt;&quot;-&quot;&lt;/code&gt; in &lt;code&gt;tr'''&lt;/code&gt; and &lt;code&gt;y'''&lt;/code&gt; is treated literally as a hyphen and no character range is available. &lt;code&gt;\1&lt;/code&gt; in the replacement of &lt;code&gt;s'''&lt;/code&gt; does not work as &lt;code&gt;$1&lt;/code&gt;.</source>
          <target state="translated">唯一の補間は、 &lt;code&gt;\\&lt;/code&gt; のペアから &lt;code&gt;\&lt;/code&gt; を削除することです。したがって、 &lt;code&gt;tr'''&lt;/code&gt; および &lt;code&gt;y'''&lt;/code&gt; &lt;code&gt;&quot;-&quot;&lt;/code&gt; は文字通りハイフンとして扱われ、文字範囲は使用できません。 &lt;code&gt;s'''&lt;/code&gt; 代わりの &lt;code&gt;\1&lt;/code&gt; は &lt;code&gt;$1&lt;/code&gt; として機能しません。</target>
        </trans-unit>
        <trans-unit id="12717cd3a47ff8f730f2ca2276f3a722ee0a85b7" translate="yes" xml:space="preserve">
          <source>The only issue left is to how to bootstrap</source>
          <target state="translated">唯一の問題は、どのようにブートストラップを行うかということです。</target>
        </trans-unit>
        <trans-unit id="77cda32153e2808e7ed17b43ef801a42c30a29bd" translate="yes" xml:space="preserve">
          <source>The only kind of simple statement is an expression evaluated for its side-effects. Every simple statement must be terminated with a semicolon, unless it is the final statement in a block, in which case the semicolon is optional. But put the semicolon in anyway if the block takes up more than one line, because you may eventually add another line. Note that there are operators like &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; that</source>
          <target state="translated">唯一の種類の単純なステートメントは、副作用について評価される式です。ブロックの最後のステートメントである場合を除いて、すべての単純なステートメントはセミコロンで終了する必要があります。この場合、セミコロンはオプションです。ただし、ブロックが複数行を占める場合は、とにかくセミコロンを入れてください。最終的に別の行を追加する場合があるためです。 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; のような演算子があり、 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; ことに注意してください</target>
        </trans-unit>
        <trans-unit id="f705477ccbb186a38ab86005af82f68dd900e475" translate="yes" xml:space="preserve">
          <source>The only kind of simple statement is an expression evaluated for its side-effects. Every simple statement must be terminated with a semicolon, unless it is the final statement in a block, in which case the semicolon is optional. But put the semicolon in anyway if the block takes up more than one line, because you may eventually add another line. Note that there are operators like &lt;code&gt;eval {}&lt;/code&gt;, &lt;code&gt;sub {}&lt;/code&gt;, and &lt;code&gt;do {}&lt;/code&gt; that</source>
          <target state="translated">単純なステートメントの唯一の種類は、その副作用について評価された式です。ブロック内の最後のステートメントである場合を除き、すべての単純なステートメントはセミコロンで終了する必要があります。セミコロンはオプションです。ただし、ブロックが複数の行を占める場合は、最終的に別の行を追加する可能性があるため、セミコロンを入れてください。そこのような演算子であるなお、 &lt;code&gt;eval {}&lt;/code&gt; 、 &lt;code&gt;sub {}&lt;/code&gt; 、および &lt;code&gt;do {}&lt;/code&gt; こと</target>
        </trans-unit>
        <trans-unit id="e309b7f80a25c25de4d7facad82c2d1078752823" translate="yes" xml:space="preserve">
          <source>The only legitimate use of this pragma is almost certainly just one per file, near the top, with file scope, as the file is likely going to only be written in one encoding. Further restrictions apply in Perls before v5.22 (see &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;&quot;Prior to Perl v5.22&quot;&lt;/a&gt;).</source>
          <target state="translated">このプラグマの唯一の正当な使用法は、ファイルが1つのエンコーディングでのみ書き込まれる可能性が高いため、ほぼ確実に、ファイルスコープを使用してファイルごとに1つだけです。v5.22&lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;より前のPerlに&lt;/a&gt;は、さらに制限が適用されます（「 Perlv5.22より前」を参照）。</target>
        </trans-unit>
        <trans-unit id="3f747c4ca5428591254eb88eeb68548667575b4e" translate="yes" xml:space="preserve">
          <source>The only legitimate use of this pragma is almost certainly just one per file, near the top, with file scope, as the file is likely going to only be written in one encoding. Further restrictions apply in Perls before v5.22 (see &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;Prior to Perl v5.22&lt;/a&gt;).</source>
          <target state="translated">このプラグマの唯一の合法的な使用法は、ファイルが1つのエンコーディングでのみ書き込まれる可能性が高いため、ほぼ確実に、ファイルスコープを持つ、ファイルごとに1つだけです。v5.22 &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;より前のPerlに&lt;/a&gt;は、さらに制限が適用されます（Perl以前のPerl v5.22を参照）。</target>
        </trans-unit>
        <trans-unit id="34c58516de1f8035b02dd5ba10465691170b3177" translate="yes" xml:space="preserve">
          <source>The only multi-byte (or wide character) locale that Perl is ever likely to support is UTF-8. This is due to the difficulty of implementation, the fact that high quality UTF-8 locales are now published for every area of the world (&lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt;), and that failing all that you can use the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module to translate to/from your locale. So, you'll have to do one of those things if you're using one of these locales, such as Big5 or Shift JIS. For UTF-8 locales, in Perls (pre v5.20) that don't have full UTF-8 locale support, they may work reasonably well (depending on your C library implementation) simply because both they and Perl store characters that take up multiple bytes the same way. However, some, if not most, C library implementations may not process the characters in the upper half of the Latin-1 range (128 - 255) properly under &lt;code&gt;LC_CTYPE&lt;/code&gt; . To see if a character is a particular type under a locale, Perl uses the functions like &lt;code&gt;isalnum()&lt;/code&gt; . Your C library may not work for UTF-8 locales with those functions, instead only working under the newer wide library functions like &lt;code&gt;iswalnum()&lt;/code&gt; , which Perl does not use. These multi-byte locales are treated like single-byte locales, and will have the restrictions described below. Starting in Perl v5.22 a warning message is raised when Perl detects a multi-byte locale that it doesn't fully support.</source>
          <target state="translated">Perlがサポートする可能性が高い唯一のマルチバイト（またはワイド文字）ロケールはUTF-8です。これは、実装の難しさ、高品質のUTF-8ロケールが世界中のすべての地域（&lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt;）に公開されていること、そして、&lt;a href=&quot;encode&quot;&gt;エンコード&lt;/a&gt;を使用できますロケールとの間で変換するモジュール。したがって、Big5やShift JISなど、これらのロケールのいずれかを使用している場合は、これらのいずれかを行う必要があります。 UTF-8ロケールの場合、完全なUTF-8ロケールをサポートしていないPerl（v5.20より前）では、CとPerlの両方が使用する文字を格納するため、（Cライブラリの実装によっては）十分に機能する可能性があります。同じ方法で複数バイト。ただし、ほとんどではないにしても、一部のCライブラリ実装では、 &lt;code&gt;LC_CTYPE&lt;/code&gt; の下でLatin-1範囲（128〜255）の上半分の文字を適切に処理しない場合があります。ロケールで文字が特定のタイプかどうかを確認するために、Perlは &lt;code&gt;isalnum()&lt;/code&gt; のような関数を使用します。 Cライブラリは、これらの関数を含むUTF-8ロケールでは機能しない可能性があります。代わりに、次のような新しい広いライブラリ関数の下でのみ動作します &lt;code&gt;iswalnum()&lt;/code&gt; 、Perlは使用しません。これらのマルチバイトロケールはシ​​ングルバイトロケールのように扱われ、以下に説明する制限があります。Perl v5.22以降では、Perlが完全にはサポートしていないマルチバイトロケールを検出すると、警告メッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="18871d07c0f1be22042f9cbee3498004b8a18ce9" translate="yes" xml:space="preserve">
          <source>The only multi-byte (or wide character) locale that Perl is ever likely to support is UTF-8. This is due to the difficulty of implementation, the fact that high quality UTF-8 locales are now published for every area of the world (&lt;a href=&quot;https://unicode.org/Public/cldr/2.0.1/&quot;&gt;https://unicode.org/Public/cldr/2.0.1/&lt;/a&gt; for ones that are already set-up, but from an earlier version; &lt;a href=&quot;https://unicode.org/Public/cldr/latest/&quot;&gt;https://unicode.org/Public/cldr/latest/&lt;/a&gt; for the most up-to-date, but you have to extract the POSIX information yourself), and that failing all that you can use the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module to translate to/from your locale. So, you'll have to do one of those things if you're using one of these locales, such as Big5 or Shift JIS. For UTF-8 locales, in Perls (pre v5.20) that don't have full UTF-8 locale support, they may work reasonably well (depending on your C library implementation) simply because both they and Perl store characters that take up multiple bytes the same way. However, some, if not most, C library implementations may not process the characters in the upper half of the Latin-1 range (128 - 255) properly under &lt;code&gt;LC_CTYPE&lt;/code&gt;. To see if a character is a particular type under a locale, Perl uses the functions like &lt;code&gt;isalnum()&lt;/code&gt;. Your C library may not work for UTF-8 locales with those functions, instead only working under the newer wide library functions like &lt;code&gt;iswalnum()&lt;/code&gt;, which Perl does not use. These multi-byte locales are treated like single-byte locales, and will have the restrictions described below. Starting in Perl v5.22 a warning message is raised when Perl detects a multi-byte locale that it doesn't fully support.</source>
          <target state="translated">Perlがサポートする可能性が高い唯一のマルチバイト（またはワイド文字）ロケールはUTF-8です。これは、実装の難しさ、高品質のUTF-8ロケールが現在世界のすべての地域で公開されているという事実によるものです（すでに設定されているロケールについては&lt;a href=&quot;https://unicode.org/Public/cldr/2.0.1/&quot;&gt;https://unicode.org/Public/cldr/2.0.1/&lt;/a&gt; -アップ、ただし以前のバージョンから。最新の場合は&lt;a href=&quot;https://unicode.org/Public/cldr/latest/&quot;&gt;https://unicode.org/Public/cldr/latest/&lt;/a&gt;、ただしPOSIX情報を自分で抽出する必要があります）。&lt;a href=&quot;encode&quot;&gt;エンコードを&lt;/a&gt;使用するロケールとの間で変換するモジュール。したがって、Big5やShift JISなど、これらのロケールのいずれかを使用している場合は、これらのいずれかを実行する必要があります。 UTF-8ロケールの場合、UTF-8ロケールを完全にサポートしていないPerl（v5.20より前）では、それらとPerlの両方が文字を使用するため、（Cライブラリの実装に応じて）かなりうまく機能する可能性があります。同じ方法で複数バイト。ただし、ほとんどではないにしても、一部のCライブラリの実装では、 &lt;code&gt;LC_CTYPE&lt;/code&gt; の下でLatin-1の範囲（128〜255）の上半分の文字が適切に処理されない場合があります。文字がロケールの下で特定のタイプであるかどうかを確認するために、Perlは &lt;code&gt;isalnum()&lt;/code&gt; のような関数を使用します。 Cライブラリは、これらの関数を使用するUTF-8ロケールでは機能しない可能性があります。代わりに、次のような新しいワイドライブラリ関数でのみ機能します。 &lt;code&gt;iswalnum()&lt;/code&gt; 、Perlは使用しません。これらのマルチバイトロケールはシ​​ングルバイトロケールのように扱われ、以下に説明する制限があります。Perl v5.22以降、Perlが完全にサポートしていないマルチバイトロケールを検出すると、警告メッセージが表示されます。</target>
        </trans-unit>
        <trans-unit id="5c17b3d145791de4c679a21722f34ee793cec0ff" translate="yes" xml:space="preserve">
          <source>The only non-character property that Perl currently supports is Named Sequences, in which a sequence of code points is given a name and generally treated as a single entity. (Perl supports these via the &lt;code&gt;\N{...}&lt;/code&gt; double-quotish construct, &lt;a href=&quot;charnames#charnames%3A%3Astring_vianame%28name%29&quot;&gt;&quot;charnames::string_vianame(name)&quot; in charnames&lt;/a&gt;, and &lt;a href=&quot;Unicode::UCD#namedseq%28%29&quot;&gt;&quot;namedseq()&quot; in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Perlが現在サポートしている文字以外のプロパティは、名前付きシーケンスのみです。このプロパティでは、コードポイントのシーケンスに名前が付けられ、通常は単一のエンティティとして扱われます。（Perlは、 &lt;code&gt;\N{...}&lt;/code&gt; 二重引用符構造、&lt;a href=&quot;charnames#charnames%3A%3Astring_vianame%28name%29&quot;&gt;charnamesの「charnames :: string_vianame（name）」&lt;/a&gt;、および&lt;a href=&quot;Unicode::UCD#namedseq%28%29&quot;&gt;Unicode :: UCDの「namedseq（）」を&lt;/a&gt;介してこれらをサポートします。</target>
        </trans-unit>
        <trans-unit id="81ecbc2496d990405244fb5517f23afeb52e9228" translate="yes" xml:space="preserve">
          <source>The only non-character property that Perl currently supports is Named Sequences, in which a sequence of code points is given a name and generally treated as a single entity. (Perl supports these via the &lt;code&gt;\N{...}&lt;/code&gt; double-quotish construct, &lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames::string_vianame(name) in charnames&lt;/a&gt;, and &lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;namedseq() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Perlが現在サポートしている唯一の非文字プロパティは名前付きシーケンスです。この場合、コードポイントのシーケンスに名前が付けられ、通常は単一のエンティティとして扱われます。（Perlは、これらを &lt;code&gt;\N{...}&lt;/code&gt; 二重引用符構成、&lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames :: string_vianame（name）をcharnames&lt;/a&gt;で、&lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;namedseq（）をUnicode :: UCDでサポートします&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4392ba6f21132243d1d665e363dbf9f2d5cd7f44" translate="yes" xml:space="preserve">
          <source>The only non-single-byte locale Perl supports is (starting in v5.20) UTF-8. This means that code points above 255 are treated as Unicode no matter what locale is in effect (since UTF-8 implies Unicode).</source>
          <target state="translated">Perl がサポートしているシングルバイト以外のロケールは、(v5.20 以降では)UTF-8 のみです。つまり、255 以上のコードポイントは、どのロケールであっても Unicode として扱われます (UTF-8 は Unicode を意味するので)。</target>
        </trans-unit>
        <trans-unit id="9a67bc69297226e55a92fe7a2acd416579cf6146" translate="yes" xml:space="preserve">
          <source>The only objective benefit to using &lt;code&gt;DirHandle&lt;/code&gt; is that it avoids namespace pollution by creating globs to hold directory handles.</source>
          <target state="translated">&lt;code&gt;DirHandle&lt;/code&gt; を使用する唯一の客観的な利点は、ディレクトリハンドルを保持するグロブを作成することにより、ネームスペースの汚染を回避することです。</target>
        </trans-unit>
        <trans-unit id="29b92533d26d29124ecd17a1f17bcca141dd3115" translate="yes" xml:space="preserve">
          <source>The only other constraint is you must pre-declare how many tests you plan to run. This is in case something goes horribly wrong during the test and your test program aborts, or skips a test or whatever. You do this like so:</source>
          <target state="translated">他の唯一の制約は、実行する予定のテストの数を事前に宣言しなければならないことです。これは、テスト中に何かがひどくおかしくなり、テストプログラムが中断したり、テストをスキップしたりした場合に備えてのことです。このようにします。</target>
        </trans-unit>
        <trans-unit id="c629e4aca342ff5d679b1354d5badb624d786fd5" translate="yes" xml:space="preserve">
          <source>The only place where the warning is not raised when it might ought to have been is if optimizations cause the whole pattern match to not even be attempted. For example, Perl may figure out that for a string to match a certain regular expression pattern, the string has to contain the substring &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; . Before attempting the match, Perl may look for that substring, and if not found, immediately fail the match without actually trying it; so no warning gets generated even if the string contains an above-Unicode code point.</source>
          <target state="translated">本来あるべきときに警告が出されない唯一の場所は、最適化によりパターン全体のマッチングが試みられない場合です。たとえば、Perlは、文字列が特定の正規表現パターンに一致するためには、文字列に &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; というサブ文字列が含まれている必要があることを理解する場合があります。一致を試みる前に、Perlはその部分文字列を探し、見つからない場合は、実際に試行せずにすぐに一致に失敗します。そのため、文字列にUnicodeを超えるコードポイントが含まれていても、警告は生成されません。</target>
        </trans-unit>
        <trans-unit id="2a1424cb465056db403b0376b90df7285a39a496" translate="yes" xml:space="preserve">
          <source>The only place where the warning is not raised when it might ought to have been is if optimizations cause the whole pattern match to not even be attempted. For example, Perl may figure out that for a string to match a certain regular expression pattern, the string has to contain the substring &lt;code&gt;&quot;foobar&quot;&lt;/code&gt;. Before attempting the match, Perl may look for that substring, and if not found, immediately fail the match without actually trying it; so no warning gets generated even if the string contains an above-Unicode code point.</source>
          <target state="translated">警告が発生するはずのときに警告が表示されない唯一の場所は、最適化によってパターン全体の一致が試行されない場合です。たとえば、Perlは、文字列が特定の正規表現パターンに一致するためには、文字列に部分文字列 &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; が含まれている必要があると判断する場合があります。一致を試みる前に、Perlはその部分文字列を探す場合があり、見つからない場合は、実際に試行せずにすぐに一致に失敗します。したがって、文字列にUnicodeを超えるコードポイントが含まれていても、警告は生成されません。</target>
        </trans-unit>
        <trans-unit id="3f03961d151195642787106427ad37fb0df08a21" translate="yes" xml:space="preserve">
          <source>The only pragmas to be completely supported are: &lt;code&gt;use warnings&lt;/code&gt;, &lt;code&gt;use strict&lt;/code&gt;, &lt;code&gt;use bytes&lt;/code&gt;, &lt;code&gt;use integer&lt;/code&gt; and &lt;code&gt;use feature&lt;/code&gt;.</source>
          <target state="translated">完全にサポートされる唯一のプラグマは、次のとおり &lt;code&gt;use warnings&lt;/code&gt; 、 &lt;code&gt;use strict&lt;/code&gt; 、 &lt;code&gt;use bytes&lt;/code&gt; 、 &lt;code&gt;use integer&lt;/code&gt; と &lt;code&gt;use feature&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7dc3eb2b3b66b20134df38443b06998c7b78e71" translate="yes" xml:space="preserve">
          <source>The only purpose of this step is to create the needed directories, and let you know the names of these directories. From the output you can see that the directory for the extension is</source>
          <target state="translated">このステップの唯一の目的は、必要なディレクトリを作成し、これらのディレクトリの名前を知らせることです。出力を見ると、拡張モジュールのディレクトリは</target>
        </trans-unit>
        <trans-unit id="e4350c2629055827ad3a8b68cc619a2e785707ba" translate="yes" xml:space="preserve">
          <source>The only required argument is &lt;a href=&quot;IO::Socket#Domain&quot;&gt;&quot;Domain&quot; in IO::Socket&lt;/a&gt;.</source>
          <target state="translated">必要な引数は&lt;a href=&quot;IO::Socket#Domain&quot;&gt;、IO :: Socketの「ドメイン」&lt;/a&gt;のみです。</target>
        </trans-unit>
        <trans-unit id="8b743cce5d7490a9e24b6e3b1af9c9095cbf1cfd" translate="yes" xml:space="preserve">
          <source>The only required part is the first field, the name of a module (e.g. Foo::Bar, i.e.</source>
          <target state="translated">必須なのは最初のフィールド、モジュールの名前(例:Foo::Bar。</target>
        </trans-unit>
        <trans-unit id="18bf9d2d31226fde65cb844d15b4e9ac5dd2e6d9" translate="yes" xml:space="preserve">
          <source>The only significant values for &lt;code&gt;flags&lt;/code&gt; are &lt;code&gt;GV_SUPER&lt;/code&gt; and &lt;code&gt;SVf_UTF8&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 重要な値は、 &lt;code&gt;GV_SUPER&lt;/code&gt; と &lt;code&gt;SVf_UTF8&lt;/code&gt; のみです。</target>
        </trans-unit>
        <trans-unit id="a47d064470efbb85a4c64c4b51a76380fc85cda0" translate="yes" xml:space="preserve">
          <source>The only significant values for &lt;code&gt;flags&lt;/code&gt; are GV_SUPER and SVf_UTF8.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; の唯一の重要な値は、GV_SUPERとSVf_UTF8です。</target>
        </trans-unit>
        <trans-unit id="27c03514e890f7e1e455be24f92d8de38867990a" translate="yes" xml:space="preserve">
          <source>The only thing to note is that, in both the static and virtual methods, the method name is not passed via the stack--it is used as the first parameter to</source>
          <target state="translated">注意すべき点は、静的メソッドと仮想メソッドの両方において、メソッド名はスタック経由では渡されないということです。</target>
        </trans-unit>
        <trans-unit id="9a6d4c47eb4eb3548f61bca4b08d9e197f6e1287" translate="yes" xml:space="preserve">
          <source>The only thing you have to remember is that the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine</source>
          <target state="translated">覚えておく必要があるのは、 &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; サブルーチン</target>
        </trans-unit>
        <trans-unit id="3a8286223f476561d867d00238ced07bc0080bf9" translate="yes" xml:space="preserve">
          <source>The only thing you have to remember is that the &lt;code&gt;import&lt;/code&gt; subroutine</source>
          <target state="translated">覚えておく必要があるのは、 &lt;code&gt;import&lt;/code&gt; サブルーチンだけです。</target>
        </trans-unit>
        <trans-unit id="befc7f9200d677e41e635df70642f3120f18f3ee" translate="yes" xml:space="preserve">
          <source>The only things you need to declare in Perl are report formats and subroutines (and sometimes not even subroutines). A scalar variable holds the undefined value (&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) until it has been assigned a defined value, which is anything other than &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. When used as a number, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is treated as &lt;code&gt;0&lt;/code&gt; ; when used as a string, it is treated as the empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt; ; and when used as a reference that isn't being assigned to, it is treated as an error. If you enable warnings, you'll be notified of an uninitialized value whenever you treat &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as a string or a number. Well, usually. Boolean contexts, such as:</source>
          <target state="translated">Perlで宣言する必要があるのは、レポートのフォーマットとサブルーチン（場合によってはサブルーチンではない）だけです。スカラー変数は、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 以外の定義済みの値が割り当てられるまで、未定義の値（undef）を保持し &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。数値として使用すると、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; は &lt;code&gt;0&lt;/code&gt; として扱われます。文字列として使用すると、空の文字列 &lt;code&gt;&quot;&quot;&lt;/code&gt; として扱われます。割り当てられていない参照として使用すると、エラーとして扱われます。警告を有効にすると、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を文字列または数値として扱うときに、初期化されていない値が通知されます。まあ、通常。次のようなブールコンテキスト</target>
        </trans-unit>
        <trans-unit id="8063526283668c78bfe80f0053d75f81f3e00c7f" translate="yes" xml:space="preserve">
          <source>The only things you need to declare in Perl are report formats and subroutines (and sometimes not even subroutines). A scalar variable holds the undefined value (&lt;code&gt;undef&lt;/code&gt;) until it has been assigned a defined value, which is anything other than &lt;code&gt;undef&lt;/code&gt;. When used as a number, &lt;code&gt;undef&lt;/code&gt; is treated as &lt;code&gt;0&lt;/code&gt;; when used as a string, it is treated as the empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt;; and when used as a reference that isn't being assigned to, it is treated as an error. If you enable warnings, you'll be notified of an uninitialized value whenever you treat &lt;code&gt;undef&lt;/code&gt; as a string or a number. Well, usually. Boolean contexts, such as:</source>
          <target state="translated">Perlで宣言する必要があるのは、レポート形式とサブルーチンだけです（場合によってはサブルーチンでさえありません）。スカラー変数は、 &lt;code&gt;undef&lt;/code&gt; 以外の定義済みの値が割り当てられるまで、未定義の値（undef）を保持し &lt;code&gt;undef&lt;/code&gt; 。数値として使用する場合、 &lt;code&gt;undef&lt;/code&gt; は &lt;code&gt;0&lt;/code&gt; として扱われます。文字列として使用すると、空の文字列 &lt;code&gt;&quot;&quot;&lt;/code&gt; として扱われます。また、割り当てられていない参照として使用された場合は、エラーとして扱われます。警告を有効にすると、 &lt;code&gt;undef&lt;/code&gt; を文字列または数値として扱うたびに、初期化されていない値が通知されます。まあ、通常。次のようなブールコンテキスト：</target>
        </trans-unit>
        <trans-unit id="31db2a79cbb61c12ae686554ebaa8cf24c12eba8" translate="yes" xml:space="preserve">
          <source>The only times that you absolutely</source>
          <target state="translated">あなたが絶対に必要なのは</target>
        </trans-unit>
        <trans-unit id="cdb480d4e9cef712b05b3e3ca053bd2714b2800c" translate="yes" xml:space="preserve">
          <source>The only way to change this is to provide your own subroutine for &lt;code&gt;'|'&lt;/code&gt; .</source>
          <target state="translated">これを変更する唯一の方法は、 &lt;code&gt;'|'&lt;/code&gt; に独自のサブルーチンを提供することです 。</target>
        </trans-unit>
        <trans-unit id="cc6185c346e8349db594c7e55f3c51f34e33f48b" translate="yes" xml:space="preserve">
          <source>The only way to change this is to provide your own subroutine for &lt;code&gt;'|'&lt;/code&gt;.</source>
          <target state="translated">これを変更する唯一の方法は、 &lt;code&gt;'|'&lt;/code&gt; 独自のサブルーチンを提供することです。。</target>
        </trans-unit>
        <trans-unit id="c65da34730ca57e068ebb9d99972660fe1a63a25" translate="yes" xml:space="preserve">
          <source>The only way to override a lexical warnings setting is with the &lt;b&gt;-W&lt;/b&gt; or &lt;b&gt;-X&lt;/b&gt; command line flags.</source>
          <target state="translated">字句警告設定を上書きする唯一の方法は、&lt;b&gt;-W&lt;/b&gt;または&lt;b&gt;-X&lt;/b&gt;コマンドラインフラグを使用することです。</target>
        </trans-unit>
        <trans-unit id="7ea2eaf8e5a3a274ae0f1dbb910613954b91ee9b" translate="yes" xml:space="preserve">
          <source>The only way you will ever be allowed to rebase or modify the history of a pushed branch is to delete it and push it as a new branch under the same name. Please think carefully about doing this. It may be better to sequentially rename your branches so that it is easier for others working with you to cherry-pick their local changes onto the new version. (XXX: needs explanation).</source>
          <target state="translated">pushされたブランチの履歴をリベースしたり変更したりすることが許されるようになるのは、そのブランチを削除して、同じ名前の新しいブランチとしてpushするしかありません。これを行うには慎重に考えてください。ブランチの名前を順次変更していくことで、あなたと一緒に作業している他の人が新しいバージョンに変更を加えることが容易になるかもしれません。(XXX:説明が必要です)。</target>
        </trans-unit>
        <trans-unit id="cbd9c5131dd8145825db3c00e95fdf65545c95f3" translate="yes" xml:space="preserve">
          <source>The op tree is connected in two ways: you can imagine that there are two &quot;routes&quot; through it, two orders in which you can traverse the tree. First, parse order reflects how the parser understood the code, and secondly, execution order tells perl what order to perform the operations in.</source>
          <target state="translated">op ツリーは 2 つの方法で接続されています。第一に、解析順はパーサがどのようにコードを理解したかを反映し、第二に、実行順はどの順番で操作を実行するかをperlに伝えます。</target>
        </trans-unit>
        <trans-unit id="87587f650625db0a4ecb1818a87bdf007aa521f9" translate="yes" xml:space="preserve">
          <source>The op tree representing the code block is returned. This is always a real op, never a null pointer. It will normally be a &lt;code&gt;lineseq&lt;/code&gt; list, including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops. No ops to construct any kind of runtime scope are included by virtue of it being a block.</source>
          <target state="translated">コードブロックを表すopツリーが返されます。これは常に実際の操作であり、nullポインターではありません。これは通常、 &lt;code&gt;nextstate&lt;/code&gt; または同等の操作を含む &lt;code&gt;lineseq&lt;/code&gt; リストです。あらゆる種類のランタイムスコープを構築するための操作は、ブロックであるため含まれていません。</target>
        </trans-unit>
        <trans-unit id="0ada1b492ff1e32feecd23ad2e48d8b585f13df5" translate="yes" xml:space="preserve">
          <source>The op tree representing the expression is returned. If an optional expression is absent, a null pointer is returned, otherwise the pointer will be non-null.</source>
          <target state="translated">式を表すオペツリーが返されます。オプションの式が存在しない場合は null ポインタが返され、そうでない場合はポインタは non-null となります。</target>
        </trans-unit>
        <trans-unit id="e036bcd0d780fe688c97dce4eafd340bcf362abb" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be ops directly implementing the statement, suitable to pass to &lt;a href=&quot;#newSTATEOP&quot;&gt;&quot;newSTATEOP&quot;&lt;/a&gt;. It will not normally include a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op (except for those embedded in a scope contained entirely within the statement).</source>
          <target state="translated">ステートメントを表すopツリーが返されます。ステートメントがnullの場合、たとえば、実際にはサブルーチン定義（コンパイル時の副作用がある）の場合、これはnullポインターである可能性があります。nullでない場合は、ステートメントを直接実装するopsであり、&lt;a href=&quot;#newSTATEOP&quot;&gt;「newSTATEOP」&lt;/a&gt;に渡すのに適しています。通常、 &lt;code&gt;nextstate&lt;/code&gt; または同等のopは含まれません（ステートメント内に完全に含まれるスコープに埋め込まれているものを除く）。</target>
        </trans-unit>
        <trans-unit id="b8ec717bc605b587bc78dee46e74bc74f77b59be" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be ops directly implementing the statement, suitable to pass to &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;. It will not normally include a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op (except for those embedded in a scope contained entirely within the statement).</source>
          <target state="translated">ステートメントを表すopツリーが返されます。ステートメントがnullの場合、たとえば実際にはサブルーチン定義（コンパイル時の副作用がある）の場合、これはnullポインターになる可能性があります。nullでない場合、ステートメントを直接実装するopsとなり、&lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;に渡すのに適しています。通常、 &lt;code&gt;nextstate&lt;/code&gt; または同等のop は含まれません（ステートメント内に完全に含まれるスコープに埋め込まれているものを除く）。</target>
        </trans-unit>
        <trans-unit id="2254139a8dcdd28ca766e4d41d0739d872c7e21b" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be the result of a &lt;a href=&quot;#newSTATEOP&quot;&gt;&quot;newSTATEOP&quot;&lt;/a&gt; call, normally including a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op.</source>
          <target state="translated">ステートメントを表すopツリーが返されます。ステートメントがnullの場合、たとえば、実際にはサブルーチン定義（コンパイル時の副作用がある）の場合、これはnullポインターである可能性があります。nullでない場合は、&lt;a href=&quot;#newSTATEOP&quot;&gt;「newSTATEOP」&lt;/a&gt;呼び出しの結果であり、通常は &lt;code&gt;nextstate&lt;/code&gt; または同等のopが含まれます。</target>
        </trans-unit>
        <trans-unit id="55a48ae410aca9d3fe9a16a19fa26233018ca671" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be the result of a &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt; call, normally including a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op.</source>
          <target state="translated">ステートメントを表すopツリーが返されます。ステートメントがnullの場合、たとえば実際にはサブルーチン定義（コンパイル時の副作用がある）の場合、これはnullポインターになる可能性があります。nullでない場合は、通常、 &lt;code&gt;nextstate&lt;/code&gt; または同等のop を含む&lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;呼び出しの結果になります。</target>
        </trans-unit>
        <trans-unit id="80258368ca90132ffffe94b685646de5d3e0a9ff" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement sequence is returned. This may be a null pointer if the statements were all null, for example if there were no statements or if there were only subroutine definitions (which have compile-time side effects). If not null, it will be a &lt;code&gt;lineseq&lt;/code&gt; list, normally including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops.</source>
          <target state="translated">ステートメントシーケンスを表すopツリーが返されます。ステートメントがすべてnullの場合、たとえばステートメントがない場合、またはサブルーチンの定義（コンパイル時の副作用がある）のみが存在する場合、これはnullポインターになる可能性があります。nullでない場合、通常は &lt;code&gt;nextstate&lt;/code&gt; または同等の操作を含む &lt;code&gt;lineseq&lt;/code&gt; リストになります。</target>
        </trans-unit>
        <trans-unit id="535ccca6a54b74bb28aa7a40bc1a8b66e55f76db" translate="yes" xml:space="preserve">
          <source>The op tree to unpack the arguments from the stack at runtime is returned. This op tree should appear at the beginning of the compiled function. The caller may wish to use &lt;a href=&quot;#op_append_list&quot;&gt;&quot;op_append_list&quot;&lt;/a&gt; to build their function body after it, or splice it together with the body before calling &lt;a href=&quot;#newATTRSUB&quot;&gt;&quot;newATTRSUB&quot;&lt;/a&gt;.</source>
          <target state="translated">実行時にスタックから引数をアンパックするopツリーが返されます。このopツリーは、コンパイルされた関数の先頭に表示されます。呼び出し元は、&lt;a href=&quot;#op_append_list&quot;&gt;「op_append_list」&lt;/a&gt;を使用して関数本体を作成したり、&lt;a href=&quot;#newATTRSUB&quot;&gt;「newATTRSUB」を&lt;/a&gt;呼び出す前に本体と接続したりすることができます。</target>
        </trans-unit>
        <trans-unit id="c35c6433e7899b6be9854e9907788616c4dfa0ff" translate="yes" xml:space="preserve">
          <source>The op-flags (ex &lt;b&gt;'sK/2'&lt;/b&gt;) are described in (&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;&quot;OP flags abbreviations&quot;&lt;/a&gt;).</source>
          <target state="translated">op-flags（&lt;b&gt;ex'sK / 2 '&lt;/b&gt;）は（&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;&quot;OP flagsの略語&quot;&lt;/a&gt;）で説明されています。</target>
        </trans-unit>
        <trans-unit id="ee004e116194c04a5a9d3789b699d566539ba78d" translate="yes" xml:space="preserve">
          <source>The op-flags (ex &lt;b&gt;'sK/2'&lt;/b&gt;) are described in (&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;OP flags abbreviations&lt;/a&gt;).</source>
          <target state="translated">op-flags（ex &lt;b&gt;'sK / 2'&lt;/b&gt;）は（&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;OP flags abbreviations&lt;/a&gt;）で説明されています。</target>
        </trans-unit>
        <trans-unit id="8eec999d2cf9d026309d4e24a85ebd9a75290847" translate="yes" xml:space="preserve">
          <source>The open source license that Larry Wall created for Perl, maximizing Perl&amp;rsquo;s usefulness, availability, and modifiability. The current version is 2. (&lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt;).</source>
          <target state="translated">Larry WallがPerl用に作成したオープンソースライセンス。Perlの有用性、可用性、および変更可能性を最大化します。現在のバージョンは2です（&lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d076872f9624d7a17cf4c11c33523c71a8396f8e" translate="yes" xml:space="preserve">
          <source>The open2() function runs the given $cmd and connects $chld_out for reading and $chld_in for writing. It's what you think should work when you try</source>
          <target state="translated">open2()関数は与えられた$cmdを実行して、読み込みには$chld_out、書き込みには$chld_inを接続しています。を実行したときに動作するはずのものです。</target>
        </trans-unit>
        <trans-unit id="2904189d67cdca2709e7a78ebf9563187c0c5785" translate="yes" xml:space="preserve">
          <source>The open2() function runs the given command and connects $chld_out for reading and $chld_in for writing. It's what you think should work when you try</source>
          <target state="translated">open2()関数は与えられたコマンドを実行して、読み込みに$chld_out、書き込みに$chld_inを接続しています。試してみると、これが動作するはずです。</target>
        </trans-unit>
        <trans-unit id="793bd01a6b2dc5e14b8e95bd14b22d7c8c213b3b" translate="yes" xml:space="preserve">
          <source>The operand of some types of regop is a literal string; for others, it is a regop leading into a sub-program. In particular, the operand of a &lt;code&gt;BRANCH&lt;/code&gt; node is the first regop of the branch.</source>
          <target state="translated">一部のタイプのregopのオペランドはリテラル文字列です。他の人にとっては、それはサブプログラムにつながるレゴです。特に、 &lt;code&gt;BRANCH&lt;/code&gt; ノードのオペランドは、ブランチの最初のレゴップです。</target>
        </trans-unit>
        <trans-unit id="cf8df21203ce7e715434391039cee96dd7ffc65d" translate="yes" xml:space="preserve">
          <source>The operating system, device drivers, C libraries, and Perl run-time system all conspire to let the programmer treat a single character (&lt;code&gt;\n&lt;/code&gt; ) as the line terminator, irrespective of external representation. On many operating systems, the native text file representation matches the internal representation, but on some platforms the external representation of &lt;code&gt;\n&lt;/code&gt; is made up of more than one character.</source>
          <target state="translated">オペレーティングシステム、デバイスドライバー、Cライブラリ、およびPerlランタイムシステムはすべて、外部の表現に関係なく、プログラマーに単一の文字（ &lt;code&gt;\n&lt;/code&gt; ）を行末記号として処理させることを目的としています。多くのオペレーティングシステムでは、ネイティブテキストファイル表現は内部表現と一致しますが、一部のプラットフォームでは、 &lt;code&gt;\n&lt;/code&gt; 外部表現は複数の文字で構成されます。</target>
        </trans-unit>
        <trans-unit id="3f9b4af2476a3677a8d756957b80eb4422b5ccdb" translate="yes" xml:space="preserve">
          <source>The operating system, device drivers, C libraries, and Perl run-time system all conspire to let the programmer treat a single character (&lt;code&gt;\n&lt;/code&gt;) as the line terminator, irrespective of external representation. On many operating systems, the native text file representation matches the internal representation, but on some platforms the external representation of &lt;code&gt;\n&lt;/code&gt; is made up of more than one character.</source>
          <target state="translated">オペレーティングシステム、デバイスドライバー、Cライブラリ、およびPerlランタイムシステムはすべて、外部表現に関係なく、プログラマーが1文字（ &lt;code&gt;\n&lt;/code&gt; ）を行末記号として扱わせるように共謀しています。多くのオペレーティングシステムでは、ネイティブテキストファイル表現は内部表現と一致しますが、一部のプラットフォームでは、 &lt;code&gt;\n&lt;/code&gt; 外部表現は複数の文字で構成されています。</target>
        </trans-unit>
        <trans-unit id="8c6975d92732aba7cc117877a890c8662a217abc" translate="yes" xml:space="preserve">
          <source>The operation of the &lt;code&gt;%ENV&lt;/code&gt; array depends on the translation of the logical name</source>
          <target state="translated">&lt;code&gt;%ENV&lt;/code&gt; 配列の操作は、論理名の変換に依存します</target>
        </trans-unit>
        <trans-unit id="1fcdc1a8281a2698369d4d0c5ac8331125832af5" translate="yes" xml:space="preserve">
          <source>The operation of the bval option warrants some discussion. Here is the definition of bval from the Berkeley DB 1.85 recno manual page:</source>
          <target state="translated">bval オプションの操作については、いくつかの議論が必要です。以下は、Berkeley DB 1.85 recno マニュアルページの bval の定義です。</target>
        </trans-unit>
        <trans-unit id="f8261c0231b653877a248b54abf80f0b93e9f204" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;archlibexp&lt;/code&gt; , &lt;code&gt;cccdlflags&lt;/code&gt; , &lt;code&gt;ccflags&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; , and &lt;code&gt;cc&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">このメソッドの操作は、 &lt;code&gt;Config.pm&lt;/code&gt; の &lt;code&gt;archlibexp&lt;/code&gt; 、 &lt;code&gt;cccdlflags&lt;/code&gt; 、 &lt;code&gt;ccflags&lt;/code&gt; 、 &lt;code&gt;optimize&lt;/code&gt; 、および &lt;code&gt;cc&lt;/code&gt; のエントリにも影響されます。</target>
        </trans-unit>
        <trans-unit id="ebf43357cdf326de3a784f122cc30174e4d696c9" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;archlibexp&lt;/code&gt;, &lt;code&gt;cccdlflags&lt;/code&gt;, &lt;code&gt;ccflags&lt;/code&gt;, &lt;code&gt;optimize&lt;/code&gt;, and &lt;code&gt;cc&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt;.</source>
          <target state="translated">このメソッドの操作は、 &lt;code&gt;Config.pm&lt;/code&gt; の &lt;code&gt;archlibexp&lt;/code&gt; 、 &lt;code&gt;cccdlflags&lt;/code&gt; 、 &lt;code&gt;ccflags&lt;/code&gt; 、 &lt;code&gt;optimize&lt;/code&gt; 、および &lt;code&gt;cc&lt;/code&gt; エントリの影響も受けます。</target>
        </trans-unit>
        <trans-unit id="1ea94336b097e013eb83f32bbba38514d8eaa887" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;lddlflags&lt;/code&gt; , &lt;code&gt;shrpenv&lt;/code&gt; , and &lt;code&gt;ld&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">このメソッドの操作は、 &lt;code&gt;Config.pm&lt;/code&gt; の &lt;code&gt;lddlflags&lt;/code&gt; 、 &lt;code&gt;shrpenv&lt;/code&gt; 、および &lt;code&gt;ld&lt;/code&gt; エントリにも影響されます。</target>
        </trans-unit>
        <trans-unit id="9af43d4cfed7d96567a247c3d560f72f4c234173" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;lddlflags&lt;/code&gt;, &lt;code&gt;shrpenv&lt;/code&gt;, and &lt;code&gt;ld&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt;.</source>
          <target state="translated">このメソッドの操作は、 &lt;code&gt;Config.pm&lt;/code&gt; の &lt;code&gt;lddlflags&lt;/code&gt; 、 &lt;code&gt;shrpenv&lt;/code&gt; 、および &lt;code&gt;ld&lt;/code&gt; エントリの影響も受けます。</target>
        </trans-unit>
        <trans-unit id="1cf8b3d14dd93250118a75dcead35353084d8d3c" translate="yes" xml:space="preserve">
          <source>The operations that are affected by locale are:</source>
          <target state="translated">ロケールの影響を受ける操作は</target>
        </trans-unit>
        <trans-unit id="4ea8be07a0890d457a63bbbdc0361b2f2a0630bf" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;not&lt;/code&gt; is not a valid key for &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; . However, if the operator &lt;code&gt;!&lt;/code&gt; is overloaded then the same implementation will be used for &lt;code&gt;not&lt;/code&gt; (since the two operators differ only in precedence).</source>
          <target state="translated">演算子 &lt;code&gt;not&lt;/code&gt; は、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; を&lt;a href=&quot;functions/use&quot;&gt;使用する&lt;/a&gt;ための有効なキーではありません。ただし、演​​算子なら &lt;code&gt;!&lt;/code&gt; オーバーロードされている場合、同じ実装が使用され &lt;code&gt;not&lt;/code&gt; （2つの演算子は優先順位が異なるだけなので）。</target>
        </trans-unit>
        <trans-unit id="e62d966af3836010344e801b17dfde35cf80a445" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;not&lt;/code&gt; is not a valid key for &lt;code&gt;use overload&lt;/code&gt;. However, if the operator &lt;code&gt;!&lt;/code&gt; is overloaded then the same implementation will be used for &lt;code&gt;not&lt;/code&gt; (since the two operators differ only in precedence).</source>
          <target state="translated">演算子 &lt;code&gt;not&lt;/code&gt; は、 &lt;code&gt;use overload&lt;/code&gt; を使用するための有効なキーではありません。ただし、演​​算子 &lt;code&gt;!&lt;/code&gt; がオーバーロードされると、同じ実装が使用され &lt;code&gt;not&lt;/code&gt; （2つの演算子の優先順位のみが異なるため）。</target>
        </trans-unit>
        <trans-unit id="78cd830e88c435efad5c7c64c9421f0a7b44115d" translate="yes" xml:space="preserve">
          <source>The operator may be assigned to if both the 2nd and 3rd arguments are legal lvalues (meaning that you can assign to them):</source>
          <target state="translated">演算子は、第2引数と第3引数の両方が正規のl値であれば(代入できることを意味します)代入することができます。</target>
        </trans-unit>
        <trans-unit id="5904b513e41f7f0a3948a698bdf838835b48e7f3" translate="yes" xml:space="preserve">
          <source>The opname, as in &lt;b&gt;'add[t1]'&lt;/b&gt;, may be followed by op-specific information in parentheses or brackets (ex &lt;b&gt;'[t1]'&lt;/b&gt;).</source>
          <target state="translated">&lt;b&gt;'add [t1]'&lt;/b&gt;のようなopnameの後には、括弧または角括弧でop固有の情報が続く場合があります（例：&lt;b&gt;'[t1]'&lt;/b&gt;）。</target>
        </trans-unit>
        <trans-unit id="4a764821c24945c6b9d29fb8f23336e4895936b8" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir&quot;&gt;&quot;catdir&quot;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#catdir&quot;&gt;「catdir」&lt;/a&gt;の反対。</target>
        </trans-unit>
        <trans-unit id="18a01865affffe01d68458832d996fae1c28b752" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt;の反対。</target>
        </trans-unit>
        <trans-unit id="da407a5a37cdd431c49815120665c0495df714be" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir%28%29&quot;&gt;&quot;catdir()&quot;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#catdir%28%29&quot;&gt;「catdir（）」&lt;/a&gt;の反対。</target>
        </trans-unit>
        <trans-unit id="e8b12f229c6486073ad774a1dc49a9e1e9fe1afd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir()&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#catdir()&quot;&gt;catdir（）&lt;/a&gt;の反対です。</target>
        </trans-unit>
        <trans-unit id="cd5ab607bfc9b28a62d0ee095cfa34da1a0a1edd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;../spec#catdir&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../spec#catdir&quot;&gt;catdir（）&lt;/a&gt;の反対です。</target>
        </trans-unit>
        <trans-unit id="72e60997864c75a6b42c630a5cd3b7d0d96cb145" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;File::Spec#catdir&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;File::Spec#catdir&quot;&gt;catdir（）&lt;/a&gt;の反対。</target>
        </trans-unit>
        <trans-unit id="1ebefb2669972c85d8b9e00b79503067268d1b9d" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;catdir()&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;catdir()&lt;/code&gt; の反対です。</target>
        </trans-unit>
        <trans-unit id="ce2ff0fee10bb0851a17501763837139e03ed67c" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;catdir()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;catdir()&lt;/code&gt; の反対。</target>
        </trans-unit>
        <trans-unit id="9a36830f45796b87c226ab6318291313f5d62c75" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;encode&lt;/code&gt;: expects a JSON text and tries to parse it, returning the resulting simple scalar or reference. Croaks on error.</source>
          <target state="translated">&lt;code&gt;encode&lt;/code&gt; の反対：JSONテキストを期待して解析を試み、結果の単純なスカラーまたは参照を返します。エラー時の鳴き声。</target>
        </trans-unit>
        <trans-unit id="f81bb459c3e1d2a0353a3947d9d6ef14ef3f4c25" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;encode_json&lt;/code&gt;: expects an UTF-8 (binary) string and tries to parse that as an UTF-8 encoded JSON text, returning the resulting reference. Croaks on error.</source>
          <target state="translated">&lt;code&gt;encode_json&lt;/code&gt; の反対：UTF-8（バイナリ）文字列を期待し、それをUTF-8でエンコードされたJSONテキストとして解析しようとし、結果の参照を返します。エラー時の鳴き声。</target>
        </trans-unit>
        <trans-unit id="9058f904dc63789872dd9542a7b1316b89449f40" translate="yes" xml:space="preserve">
          <source>The opset and opset_to_ops functions can be used to convert from a list of operators to an opset and</source>
          <target state="translated">opset および opset_to_ops 関数を使用して、演算子のリストから opset および opset_to_ops に変換することができます。</target>
        </trans-unit>
        <trans-unit id="e0e7014b5567d7771bd0933f5acd1310aac22e0f" translate="yes" xml:space="preserve">
          <source>The optag name used must not be defined already (define_optag will croak if it is already defined). Optag names are global to the perl process and optag definitions cannot be altered or deleted once defined.</source>
          <target state="translated">使用するオプタグ名は、すでに定義されていてはいけません(define_optagはすでに定義されている場合には動作しません)。optag名はPerlプロセスのグローバルなものであり、一度定義されたoptagの定義を変更したり削除したりすることはできません。</target>
        </trans-unit>
        <trans-unit id="16ae99f8eb8c5eb6cf77bcb07b90faddacb6b646" translate="yes" xml:space="preserve">
          <source>The optimizer-specific information is used to avoid entering (a slow) regex engine on strings that will not definitely match. If the &lt;code&gt;isall&lt;/code&gt; flag is set, a call to the regex engine may be avoided even when the optimizer found an appropriate place for the match.</source>
          <target state="translated">オプティマイザ固有の情報は、完全に一致しない文字列で（低速の）正規表現エンジンに入らないようにするために使用されます。場合 &lt;code&gt;isall&lt;/code&gt; のフラグが設定されているオプティマイザは試合のために適切な場所を見つけた場合でも、正規表現エンジンへの呼び出しを回避することができます。</target>
        </trans-unit>
        <trans-unit id="c2bcebf69d65f38d819f2ef47d3870130b4b4a34" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and may be negated by prefixing it with &quot;no&quot; or &quot;no-&quot;. E.g. &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; will allow &lt;code&gt;--foo&lt;/code&gt; (a value of 1 will be assigned) as well as &lt;code&gt;--nofoo&lt;/code&gt; and &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; (a value of 0 will be assigned). If the option has aliases, this applies to the aliases as well.</source>
          <target state="translated">このオプションは引数を取らず、 &quot;no&quot;または &quot;no-&quot;を前に付けることで無効にすることができます。例： &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; 可能にする &lt;code&gt;--foo&lt;/code&gt; （1の値が割り当てられる）ならびに &lt;code&gt;--nofoo&lt;/code&gt; と &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; （0の値が割り当てられます）。オプションにエイリアスがある場合、これはエイリアスにも適用されます。</target>
        </trans-unit>
        <trans-unit id="d9db329442e437205bd55b086c5b9e99baf5686d" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and may be negated by prefixing it with &quot;no&quot; or &quot;no-&quot;. E.g. &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; will allow &lt;code&gt;--foo&lt;/code&gt; (a value of 1 will be assigned) as well as &lt;code&gt;--nofoo&lt;/code&gt; and &lt;code&gt;--no-foo&lt;/code&gt; (a value of 0 will be assigned). If the option has aliases, this applies to the aliases as well.</source>
          <target state="translated">このオプションは引数をとらず、「no」または「no-」を前に付けることで無効にすることができます。例： &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; &lt;code&gt;--foo&lt;/code&gt; （値1が割り当てられます）、および &lt;code&gt;--nofoo&lt;/code&gt; と &lt;code&gt;--no-foo&lt;/code&gt; （値0が割り当てられます）を許可します。オプションにエイリアスがある場合、これはエイリアスにも適用されます。</target>
        </trans-unit>
        <trans-unit id="05bc04ade0e6f0bfb276419b00c5f9d55f933117" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and will be incremented by 1 every time it appears on the command line. E.g. &lt;code&gt;&quot;more+&quot;&lt;/code&gt; , when used with &lt;code&gt;--more --more --more&lt;/code&gt;, will increment the value three times, resulting in a value of 3 (provided it was 0 or undefined at first).</source>
          <target state="translated">オプションは引数をとらず、コマンドラインに表示されるたびに1ずつ増加します。たとえば、 &lt;code&gt;&quot;more+&quot;&lt;/code&gt; を &lt;code&gt;--more --more --more&lt;/code&gt; と一緒に使用すると、値が3回インクリメントされ、値3になります（最初は0または未定義であった場合）。</target>
        </trans-unit>
        <trans-unit id="d8e253e20697ea76ff418e0292092a5b47f9f4f6" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and will be incremented by 1 every time it appears on the command line. E.g. &lt;code&gt;&quot;more+&quot;&lt;/code&gt;, when used with &lt;code&gt;--more --more --more&lt;/code&gt;, will increment the value three times, resulting in a value of 3 (provided it was 0 or undefined at first).</source>
          <target state="translated">このオプションは引数をとらず、コマンドラインに表示されるたびに1ずつ増加します。たとえば、 &lt;code&gt;&quot;more+&quot;&lt;/code&gt; を &lt;code&gt;--more --more --more&lt;/code&gt; と一緒に使用すると、値が3回インクリメントされ、値は3になります（最初は0または未定義の場合）。</target>
        </trans-unit>
        <trans-unit id="e6c73626524fd7b39cf23cb6ceb0594624a4560f" translate="yes" xml:space="preserve">
          <source>The option name as specified to the GetOptions() function is called the option</source>
          <target state="translated">GetOptions()関数に指定されたオプション名は、オプション</target>
        </trans-unit>
        <trans-unit id="28e883d6a03c91177fe93b06a907181312e7662a" translate="yes" xml:space="preserve">
          <source>The option names defined below are case insensitive and can be optionally prefixed by a '-'. So all of the following are valid</source>
          <target state="translated">以下に定義されているオプション名は大文字小文字を区別せず、オプションで '-' を接頭辞として付けることができます。したがって、以下のすべてが有効です。</target>
        </trans-unit>
        <trans-unit id="24d6abd722573e6cae42881df7cf4d56ac582b1b" translate="yes" xml:space="preserve">
          <source>The option requires an argument of the given type. Supported types are:</source>
          <target state="translated">このオプションは、指定された型の引数を必要とします。サポートされる型は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">オプションの</target>
        </trans-unit>
        <trans-unit id="3cb07c5a1f900e41d71b7af9007db9793c77a65e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;rules&lt;/code&gt; attribute provides direction on which tests should be run in parallel and which should be run sequentially. If no rule data structure is provided, a default data structure is used which makes every test eligible to be run in parallel:</source>
          <target state="translated">オプションの &lt;code&gt;rules&lt;/code&gt; 属性は、並行して実行するテストと順次実行するテストの方向を提供します。ルールのデータ構造が提供されていない場合、デフォルトのデータ構造が使用され、すべてのテストを並行して実行できるようになります。</target>
        </trans-unit>
        <trans-unit id="0a173dcd400a0274b32b98f040a162b1b1782227" translate="yes" xml:space="preserve">
          <source>The optional arguments are considered as literal strings unless they start with &lt;code&gt;~&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt; , in which case they are interpreted as regular expressions (possibly negated).</source>
          <target state="translated">オプションの引数は、 &lt;code&gt;~&lt;/code&gt; または &lt;code&gt;!&lt;/code&gt; で始まらない限り、リテラル文字列と見なされます。、その場合、それらは正規表現として解釈されます（おそらく否定されます）。</target>
        </trans-unit>
        <trans-unit id="cf1d2e0ff9c2439cc3ca174e85a170cee0c435c9" translate="yes" xml:space="preserve">
          <source>The optional arguments are considered as literal strings unless they start with &lt;code&gt;~&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt;, in which case they are interpreted as regular expressions (possibly negated).</source>
          <target state="translated">オプションの引数は、 &lt;code&gt;~&lt;/code&gt; または &lt;code&gt;!&lt;/code&gt; で始まらない限り、リテラル文字列と見なされます。、その場合、それらは正規表現として解釈されます（おそらく否定されます）。</target>
        </trans-unit>
        <trans-unit id="2a457723dc3fc51f575186932ad8e9bfa084daea" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;anyinflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">ワンショット関数 &lt;code&gt;anyinflate&lt;/code&gt; のオプションのパラメーターは、（ほとんどの場合）&lt;a href=&quot;#Constructor-Options&quot;&gt;「コンストラクターオプション」&lt;/a&gt;セクションで定義されているOOインターフェイスで使用されるパラメーターと同じです。例外は以下のとおりです</target>
        </trans-unit>
        <trans-unit id="caed88218bf3ae5d8b6dcab0958f36fc2927ec02" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;anyuncompress&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">ワンショット関数 &lt;code&gt;anyuncompress&lt;/code&gt; のオプションのパラメーターは、（ほとんどの場合）&lt;a href=&quot;#Constructor-Options&quot;&gt;「コンストラクターオプション」&lt;/a&gt;セクションで定義されているOOインターフェイスで使用されるパラメーターと同じです。例外は以下のとおりです</target>
        </trans-unit>
        <trans-unit id="131098ff902c48e8458d96c59269d22ab860e8b2" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;bunzip2&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">ワンショット関数 &lt;code&gt;bunzip2&lt;/code&gt; のオプションのパラメーターは、（ほとんどの場合）&lt;a href=&quot;#Constructor-Options&quot;&gt;「コンストラクターオプション」&lt;/a&gt;セクションで定義されているOOインターフェイスで使用されるパラメーターと同じです。例外は以下のとおりです</target>
        </trans-unit>
        <trans-unit id="6198111cc9801f305996de3eeaa06e0db91b4218" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;bzip2&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">ワンショット関数 &lt;code&gt;bzip2&lt;/code&gt; のオプションのパラメーターは、（ほとんどの場合）&lt;a href=&quot;#Constructor-Options&quot;&gt;「コンストラクターオプション」&lt;/a&gt;セクションで定義されているOOインターフェイスで使用されるパラメーターと同じです。例外は以下のとおりです</target>
        </trans-unit>
        <trans-unit id="38c4c457d99260789b76c08eab24f06adc17d2c1" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;deflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">ワンショット関数 &lt;code&gt;deflate&lt;/code&gt; のオプションのパラメーターは、（ほとんどの場合）&lt;a href=&quot;#Constructor-Options&quot;&gt;「コンストラクターオプション」&lt;/a&gt;セクションで定義されているOOインターフェースで使用されるパラメーターと同じです。例外は以下のとおりです</target>
        </trans-unit>
        <trans-unit id="aa1a96727af7ce5f83a4cb5ede379486da415347" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;gunzip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">ワンショット関数 &lt;code&gt;gunzip&lt;/code&gt; のオプションのパラメーターは、（ほとんどの場合）&lt;a href=&quot;#Constructor-Options&quot;&gt;「コンストラクターオプション」&lt;/a&gt;セクションで定義されているOOインターフェイスで使用されるパラメーターと同じです。例外は以下のとおりです</target>
        </trans-unit>
        <trans-unit id="32a1759e80fa595487da188a1ae20babdbb62651" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;gzip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">ワンショット関数 &lt;code&gt;gzip&lt;/code&gt; のオプションのパラメーターは、（ほとんどの場合）&lt;a href=&quot;#Constructor-Options&quot;&gt;「コンストラクターオプション」&lt;/a&gt;セクションで定義されているOOインターフェースで使用されるパラメーターと同じです。例外は以下のとおりです</target>
        </trans-unit>
        <trans-unit id="81f90f77041e19f7f96b84e59406c9ba0fcd6ff0" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;inflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">ワンショット関数イン &lt;code&gt;inflate&lt;/code&gt; のオプションのパラメーターは、（ほとんどの場合）&lt;a href=&quot;#Constructor-Options&quot;&gt;「コンストラクターオプション」&lt;/a&gt;セクションで定義されているOOインターフェイスで使用されるパラメーターと同じです。例外は以下のとおりです</target>
        </trans-unit>
        <trans-unit id="d34c4bd457be8b3eca1d1b50327dc8555ebf3e0c" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;rawdeflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">ワンショット関数 &lt;code&gt;rawdeflate&lt;/code&gt; のオプションのパラメーターは、（ほとんどの場合）&lt;a href=&quot;#Constructor-Options&quot;&gt;「コンストラクターオプション」&lt;/a&gt;セクションで定義されているOOインターフェイスで使用されるパラメーターと同じです。例外は以下のとおりです</target>
        </trans-unit>
        <trans-unit id="da3088b2b3f74fb962460f08bf6c521a6489c8dc" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;rawinflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">ワンショット関数 &lt;code&gt;rawinflate&lt;/code&gt; のオプションのパラメーターは、（ほとんどの場合）&lt;a href=&quot;#Constructor-Options&quot;&gt;「コンストラクターオプション」&lt;/a&gt;セクションで定義されているOOインターフェイスで使用されるパラメーターと同じです。例外は以下のとおりです</target>
        </trans-unit>
        <trans-unit id="564a4703e441e1aa249188b7a46aeee40f3cb3e0" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;unzip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">ワンショット関数 &lt;code&gt;unzip&lt;/code&gt; のオプションのパラメーターは、（ほとんどの場合）&lt;a href=&quot;#Constructor-Options&quot;&gt;「コンストラクターオプション」&lt;/a&gt;セクションで定義されているOOインターフェイスで使用されるパラメーターと同じです。例外は以下のとおりです</target>
        </trans-unit>
        <trans-unit id="e1bd6c00e2144ea2637c42a56845ca5419370d66" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;zip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="translated">ワンショット関数 &lt;code&gt;zip&lt;/code&gt; のオプションのパラメーターは、（ほとんどの場合）&lt;a href=&quot;#Constructor-Options&quot;&gt;「コンストラクターオプション」&lt;/a&gt;セクションで定義されているOOインターフェイスで使用されるパラメーターと同じです。例外は以下のとおりです</target>
        </trans-unit>
        <trans-unit id="b6ca67d9f48cf9586e57f2ed1e1217218181099d" translate="yes" xml:space="preserve">
          <source>The optional second parameter is ignored if it is larger than the actual length of the first parameter string.</source>
          <target state="translated">オプションの 2 番目のパラメータは、1 番目のパラメータ文字列の実際の長さよりも大きい場合は無視されます。</target>
        </trans-unit>
        <trans-unit id="a213bd4ecadb16ed12c21fa427d78bb53fa09a37" translate="yes" xml:space="preserve">
          <source>The options listed above customize parts of the default header, but setting &lt;code&gt;html_header&lt;/code&gt; or &lt;code&gt;html_footer&lt;/code&gt; completely overrides the built-in header or footer. These may be useful if you want to use template tags instead of literal HTML headers and footers or are integrating converted POD pages in a larger website.</source>
          <target state="translated">上記のオプションはデフォルトのヘッダーの一部をカスタマイズしますが、 &lt;code&gt;html_header&lt;/code&gt; または &lt;code&gt;html_footer&lt;/code&gt; を設定すると、組み込みのヘッダーまたはフッターが完全に上書きされます。これらは、リテラルHTMLヘッダーおよびフッターの代わりにテンプレートタグを使用する場合、または変換されたPODページをより大きなWebサイトに統合する場合に役立ちます。</target>
        </trans-unit>
        <trans-unit id="01a4d13b9aa02b31aa3157b7bf6c6d232ea80269" translate="yes" xml:space="preserve">
          <source>The options listed in this section control how the</source>
          <target state="translated">このセクションに記載されているオプションは</target>
        </trans-unit>
        <trans-unit id="73d081dbc5fcc08b3b44f6576034c6838b070bec" translate="yes" xml:space="preserve">
          <source>The options to this argument is a list of either directories that are searched recursively, or files. (Usually you wouldn't specify files, but just dirs.) Or you can just specify an empty-list, as in $name2path; with the &lt;code&gt;inc&lt;/code&gt; option on, as it is by default.</source>
          <target state="translated">この引数のオプションは、再帰的に検索されるディレクトリまたはファイルのリストです。（通常、ファイルは指定せず、dirsのみを指定します。）または、$ name2pathのように、空のリストを指定することもできます。 &lt;code&gt;inc&lt;/code&gt; オプションで、それがデフォルトであるとして。</target>
        </trans-unit>
        <trans-unit id="f0865be52cedbd9c729cf95a5b09eba31832648b" translate="yes" xml:space="preserve">
          <source>The optree is shared between threads. This means there is a possibility that the optree will outlive the particular thread (and therefore the interpreter instance) that created it, so true Perl scalars cannot be stored in the optree. Instead a compact form is used, which can only store values that are integers (signed and unsigned), strings or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; - references and floating point values are stringified. If you need to store multiple values or complex structures, you should serialise them, for example with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;. The deletion of a hash key from &lt;code&gt;%^H&lt;/code&gt; is recorded, and as ever can be distinguished from the existence of a key with value &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">optreeはスレッド間で共有されます。これは、optreeがそれを作成した特定のスレッド（したがってインタープリターインスタンス）よりも長く存続する可能性があるため、真のPerlスカラーをoptreeに格納できないことを意味します。代わりに、整数（符号付きおよび符号なし）、文字列、または &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; の値のみを格納できるコンパクトな形式が使用されます -参照と浮動小数点値は文字列化されます。複数の値または複雑な構造を格納する必要がある場合は、たとえば &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; を使用してそれらをシリアル化する必要があります。ハッシュキーの削除 &lt;code&gt;%^H&lt;/code&gt; 記録され、これまでのように値を持つキーの存在を区別することができる &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を持つ &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="758267caaf6c4060844acf8b5ceecd9fefe29a51" translate="yes" xml:space="preserve">
          <source>The optree is shared between threads. This means there is a possibility that the optree will outlive the particular thread (and therefore the interpreter instance) that created it, so true Perl scalars cannot be stored in the optree. Instead a compact form is used, which can only store values that are integers (signed and unsigned), strings or &lt;code&gt;undef&lt;/code&gt; - references and floating point values are stringified. If you need to store multiple values or complex structures, you should serialise them, for example with &lt;code&gt;pack&lt;/code&gt;. The deletion of a hash key from &lt;code&gt;%^H&lt;/code&gt; is recorded, and as ever can be distinguished from the existence of a key with value &lt;code&gt;undef&lt;/code&gt; with &lt;code&gt;exists&lt;/code&gt;.</source>
          <target state="translated">optreeはスレッド間で共有されます。これは、optreeがそれを作成した特定のスレッド（したがってインタープリターインスタンス）よりも長生きする可能性があることを意味します。そのため、真のPerlスカラーをoptreeに格納することはできません。代わりに、整数（符号付きおよび符号なし）、文字列、または &lt;code&gt;undef&lt;/code&gt; の値のみを格納できるコンパクトな形式が使用されます。参照と浮動小数点値は文字列化されます。複数の値または複雑な構造を格納する必要がある場合は、たとえば &lt;code&gt;pack&lt;/code&gt; を使用してそれらをシリアル化する必要があります。 &lt;code&gt;%^H&lt;/code&gt; からのハッシュキーの削除が記録され、これまでどおり、値が &lt;code&gt;undef&lt;/code&gt; で &lt;code&gt;exists&lt;/code&gt; キーの存在と区別できます。</target>
        </trans-unit>
        <trans-unit id="96c80c62d3615e8dcdce9b967100a640447d19ae" translate="yes" xml:space="preserve">
          <source>The order in which objects are destroyed during the global destruction before the program exits is unpredictable. This means that any objects contained by your object may already have been destroyed. You should check that a contained object is defined before calling a method on it:</source>
          <target state="translated">プログラムが終了する前のグローバル破壊の間にオブジェクトが破壊される順序は予測できません。つまり、あなたのオブジェクトに含まれるオブジェクトはすでに破壊されている可能性があります。含まれているオブジェクトが定義されているかどうかは、そのオブジェクトに対してメソッドを呼び出す前に確認する必要があります。</target>
        </trans-unit>
        <trans-unit id="1362f44821baf70a0c53e26c223d4e933d506d90" translate="yes" xml:space="preserve">
          <source>The order in which this test was run for the given test suite result.</source>
          <target state="translated">与えられたテストスイートの結果に対して、このテストが実行された順番。</target>
        </trans-unit>
        <trans-unit id="49bfec1872d74cc3aa3b51bdca30781b5d81ee87" translate="yes" xml:space="preserve">
          <source>The order into which &lt;b&gt;characters&lt;/b&gt; sort. This is used by &lt;b&gt;string&lt;/b&gt; comparison routines to decide, for example, where in this glossary to put &amp;ldquo;collating sequence&amp;rdquo;.</source>
          <target state="translated">&lt;b&gt;文字が&lt;/b&gt;ソートされる順序。これは、たとえば、この用語集のどこに「照合順序」を置くかを決定するために&lt;b&gt;文字列&lt;/b&gt;比較ルーチンによって使用され&lt;b&gt;ます&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="90461643a4b9bcbbb16f181372c5e7705b398666" translate="yes" xml:space="preserve">
          <source>The order of any groups including scripts is not changed.</source>
          <target state="translated">スクリプトを含む任意のグループの順序は変更されません。</target>
        </trans-unit>
        <trans-unit id="717cecbd54045d9533e4eb5b41c7c271d10ce913" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open2().</source>
          <target state="translated">引数の順番は open2()とは異なります。</target>
        </trans-unit>
        <trans-unit id="1338c98402171198f17cc3c818e89af7db3bfea3" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open3().</source>
          <target state="translated">引数の順番は open3()とは異なります。</target>
        </trans-unit>
        <trans-unit id="c7058991786845d90ace9e46987253e3ce531354" translate="yes" xml:space="preserve">
          <source>The ordering is the same as for the regular expression which is the result of</source>
          <target state="translated">の結果である正規表現と同じです。</target>
        </trans-unit>
        <trans-unit id="e57a83be29caa0cba0eac2c66aec01c8ecc059c8" translate="yes" xml:space="preserve">
          <source>The ordering is the same as for the regular expression which is the result of EXPR, or the pattern contained by capture group</source>
          <target state="translated">順番は、EXPRの結果である正規表現や、キャプチャグループに含まれるパターンと同じです。</target>
        </trans-unit>
        <trans-unit id="0f9c7f78b473deec8b2b7b3c5ae964aaebd4ae76" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;MD5&lt;/code&gt; interface was written by Neil Winton (&lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; ).</source>
          <target state="translated">オリジナルの &lt;code&gt;MD5&lt;/code&gt; インターフェースはNeil Winton（ &lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; ）によって書かれました。</target>
        </trans-unit>
        <trans-unit id="a967938ebcc10e8da7bfe2a06eaff58eb4186ec0" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;MD5&lt;/code&gt; interface was written by Neil Winton (&lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt;).</source>
          <target state="translated">元の &lt;code&gt;MD5&lt;/code&gt; インターフェイスは、Neil Winton（ &lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; ）によって作成されました。</target>
        </trans-unit>
        <trans-unit id="7eb97de2fdb41a38605a8a09e6520652a52c56e7" translate="yes" xml:space="preserve">
          <source>The original Dylan paper</source>
          <target state="translated">ディランの原紙</target>
        </trans-unit>
        <trans-unit id="50fea78ce2537fb78816d81a4d2374f6c7eff868" translate="yes" xml:space="preserve">
          <source>The original Pod::Text contained code to do formatting via termcap sequences, although it wasn't turned on by default and it was problematic to get it to work at all. This rewrite doesn't even try to do that, but a subclass of it does. Look for &lt;a href=&quot;Pod::Text::Termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">元のPod :: Textには、termcapシーケンスを介してフォーマットを行うコードが含まれていましたが、デフォルトではオンになっておらず、まったく機能させるのに問題がありました。この書き直しはそれを行おうとさえしませんが、そのサブクラスはそうします。&lt;a href=&quot;Pod::Text::Termcap&quot;&gt;Pod :: Text :: Termcapを&lt;/a&gt;探します。</target>
        </trans-unit>
        <trans-unit id="af612d63faee2dc3856c86fd5cc671079598e557" translate="yes" xml:space="preserve">
          <source>The original Pod::Text contained code to do formatting via termcap sequences, although it wasn't turned on by default and it was problematic to get it to work at all. This rewrite doesn't even try to do that, but a subclass of it does. Look for &lt;a href=&quot;text/termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">元のPod :: Textには、termcapシーケンスを介してフォーマットを行うコードが含まれていましたが、デフォルトではオンになっておらず、まったく機能させるのに問題がありました。この書き直しはそれを実行しようとさえしませんが、そのサブクラスはそうしようとします。&lt;a href=&quot;text/termcap&quot;&gt;Pod :: Text :: Termcapを&lt;/a&gt;探します。</target>
        </trans-unit>
        <trans-unit id="07dd5b1a0e82d303f2b0b28746eab063467b6ba7" translate="yes" xml:space="preserve">
          <source>The original UTF-8 specification allowed up to 6 bytes, to allow encoding of numbers up to &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; . Perl continues to allow those, and has extended that up to 13 bytes to encode code points up to what can fit in a 64-bit word. However, Perl will warn if you output any of these as being non-portable; and under strict UTF-8 input protocols, they are forbidden.</source>
          <target state="translated">元のUTF-8仕様では最大6バイトが許可され、最大 &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; の数値のエンコードが可能でした。Perlはそれらを引き続き許可し、コードポイントを64ビットワードに収まる範囲までエンコードするように最大13バイトまで拡張しました。ただし、これらのいずれかを移植できないものとして出力すると、Perlは警告します。厳密なUTF-8入力プロトコルでは、これらは禁止されています。</target>
        </trans-unit>
        <trans-unit id="00b0e9de1cd640deb40f9e9ac2ea76a7fdd363f8" translate="yes" xml:space="preserve">
          <source>The original UTF-8 specification allowed up to 6 bytes, to allow encoding of numbers up to &lt;code&gt;0x7FFF_FFFF&lt;/code&gt;. Perl continues to allow those, and has extended that up to 13 bytes to encode code points up to what can fit in a 64-bit word. However, Perl will warn if you output any of these as being non-portable; and under strict UTF-8 input protocols, they are forbidden. In addition, it is now illegal to use a code point larger than what a signed integer variable on your system can hold. On 32-bit ASCII systems, this means &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; is the legal maximum (much higher on 64-bit systems).</source>
          <target state="translated">元のUTF-8仕様では、最大6バイトが許可され、最大 &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; の数値をエンコードできました。 Perlは引き続きそれらを許可し、64ビットワードに収まるコードポイントをエンコードするために最大13バイトまで拡張しました。ただし、これらのいずれかを移植性がないものとして出力すると、Perlは警告を発します。厳密なUTF-8入力プロトコルでは、それらは禁止されています。さらに、システム上の符号付き整数変数が保持できるコードポイントよりも大きいコードポイントを使用することは現在違法です。 32ビットASCIIシステムでは、これは &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; が有効な最大値であることを意味します（64ビットシステムでははるかに高くなります）。</target>
        </trans-unit>
        <trans-unit id="a0e54c9386e1df6efdb32bc51b43d382c1fa2bb3" translate="yes" xml:space="preserve">
          <source>The original culture of the pre-populist Internet and the deeply-held beliefs of Perl's author, Larry Wall, gave rise to the free and open distribution policy of Perl. Perl is supported by its users. The core, the standard Perl library, the optional modules, and the documentation you're reading now were all written by volunteers.</source>
          <target state="translated">ポピュリスト以前のインターネットの独自の文化と、Perlの作者であるラリー・ウォールの深い信念が、Perlの自由でオープンな配布ポリシーを生み出しました。Perlはユーザによってサポートされています。コア、標準のPerlライブラリ、オプションのモジュール、そして今読んでいるドキュメントはすべてボランティアによって書かれたものです。</target>
        </trans-unit>
        <trans-unit id="12a169f5e5252000915162d740c1f7fb51701fdf" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_get_call_checker_flags&quot;&gt;&quot;cv_get_call_checker_flags&quot;&lt;/a&gt;, which does not return checker flags. When using a checker function returned by this function, it is only safe to call it with a genuine GV as its &lt;code&gt;namegv&lt;/code&gt; argument.</source>
          <target state="translated">チェッカーフラグを返さない&lt;a href=&quot;#cv_get_call_checker_flags&quot;&gt;「cv_get_call_checker_flags」&lt;/a&gt;の元の形式。この関数によって返されるチェッカー関数を使用する場合、 &lt;code&gt;namegv&lt;/code&gt; 引数として正規のGVを使用して呼び出すことのみが安全です。</target>
        </trans-unit>
        <trans-unit id="eb0e3050b313150315f2790edd37f73f93a916ca" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;&quot;cv_set_call_checker_flags&quot;&lt;/a&gt;, which passes it the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; flag for backward-compatibility. The effect of that flag setting is that the check function is guaranteed to get a genuine GV as its &lt;code&gt;namegv&lt;/code&gt; argument.</source>
          <target state="translated">下位互換性のために &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; フラグを渡す&lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;「cv_set_call_checker_flags」&lt;/a&gt;の元の形式。そのフラグ設定の効果は、チェック関数がその &lt;code&gt;namegv&lt;/code&gt; 引数として本物のGVを取得することが保証されることです。</target>
        </trans-unit>
        <trans-unit id="124cee86525fe9ae3fd7e1b40184ae6b8c5be548" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt;, which passes it the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; flag for backward-compatibility.</source>
          <target state="translated">下位互換性のために &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; フラグを渡す&lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt;の元の形式。</target>
        </trans-unit>
        <trans-unit id="03b164c5369f7a3512c3a8ff6e7ba584a97c85cb" translate="yes" xml:space="preserve">
          <source>The original format of CPAN Meta files was &lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML&lt;/a&gt; and the corresponding file was called</source>
          <target state="translated">CPANメタファイルの元の形式は&lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML&lt;/a&gt;で、対応するファイルが呼び出されました</target>
        </trans-unit>
        <trans-unit id="12304d794d559e0c5fe4691017042f08f8d52e43" translate="yes" xml:space="preserve">
          <source>The original format of CPAN Meta files was &lt;a href=&quot;yaml&quot;&gt;YAML&lt;/a&gt; and the corresponding file was called</source>
          <target state="translated">CPANメタファイルの元の形式は&lt;a href=&quot;yaml&quot;&gt;YAMLで&lt;/a&gt;あり、対応するファイルは呼び出されました</target>
        </trans-unit>
        <trans-unit id="cc0efcec67bc372bca64df41283c31757275dca6" translate="yes" xml:space="preserve">
          <source>The original impetus for &lt;code&gt;Perl_langinfo()&lt;/code&gt; was so that code that needs to find out the current currency symbol, floating point radix character, or digit grouping separator can use, on all systems, the simpler and more thread-friendly &lt;code&gt;nl_langinfo&lt;/code&gt; API instead of &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/localeconv&quot;&gt;localeconv(3)&lt;/a&gt;&lt;/code&gt; which is a pain to make thread-friendly. For other fields returned by &lt;code&gt;localeconv&lt;/code&gt;, it is better to use the methods given in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; to call &lt;a href=&quot;posix#localeconv&quot;&gt;&lt;code&gt;POSIX::localeconv()&lt;/code&gt;&lt;/a&gt;, which is thread-friendly.</source>
          <target state="translated">&lt;code&gt;Perl_langinfo()&lt;/code&gt; の元々の推進力は、現在の通貨記号、浮動小数点の基数文字、または数字のグループ化区切り文字を見つける必要があるコードが、すべてのシステムで、 &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/localeconv&quot;&gt;localeconv(3)&lt;/a&gt;&lt;/code&gt; 代わりに、より単純でスレッドフレンドリーな &lt;code&gt;nl_langinfo&lt;/code&gt; APIを使用できるようにすることでした。3）これはスレッドフレンドリーにするのが面倒です。 &lt;code&gt;localeconv&lt;/code&gt; によって返される他のフィールドについては、&lt;a href=&quot;perlcall&quot;&gt;perlcallで&lt;/a&gt;指定されたメソッドを使用して、スレッドに適した&lt;a href=&quot;posix#localeconv&quot;&gt; &lt;code&gt;POSIX::localeconv()&lt;/code&gt; &lt;/a&gt;を呼び出すことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="3411d71283c2f07e45c5a35c0fcbe60c51f6b9bb" translate="yes" xml:space="preserve">
          <source>The original purpose of source filters was to let you encrypt your program source to prevent casual piracy. This isn't all they can do, as you'll soon learn. But first, the basics.</source>
          <target state="translated">ソースフィルタの本来の目的は、プログラムのソースを暗号化して海賊版を防ぐことでした。すぐにわかるように、これだけではありません。しかし、まず基本的なことを説明します。</target>
        </trans-unit>
        <trans-unit id="af210dcaae99ceb3aa829035af3557a9ff65ef3a" translate="yes" xml:space="preserve">
          <source>The original stack mark for the XSUB. See &lt;code&gt;&lt;a href=&quot;#dORIGMARK&quot;&gt;&quot;dORIGMARK&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">XSUBの元のスタックマーク。 &lt;code&gt;&lt;a href=&quot;#dORIGMARK&quot;&gt;&quot;dORIGMARK&quot;&lt;/a&gt;&lt;/code&gt; 参照してください。</target>
        </trans-unit>
        <trans-unit id="a310ea971545c067e472063428469fc1fad9aa30" translate="yes" xml:space="preserve">
          <source>The original stack mark for the XSUB. See &lt;code&gt;dORIGMARK&lt;/code&gt; .</source>
          <target state="translated">XSUBの元のスタックマーク。 &lt;code&gt;dORIGMARK&lt;/code&gt; を参照してください。</target>
        </trans-unit>
        <trans-unit id="d9fdbd5653ee6341eabe4730cc34935e3db7a992" translate="yes" xml:space="preserve">
          <source>The original style uses blanks and hyphens in the block names (except for &lt;code&gt;No_Block&lt;/code&gt; ), like so:</source>
          <target state="translated">元のスタイルでは、次のように、ブロック名に空白とハイフンを使用しています（ &lt;code&gt;No_Block&lt;/code&gt; を除く）。</target>
        </trans-unit>
        <trans-unit id="5c736b5ceaedaf0c5b862acefcb315ae2bd5b9ab" translate="yes" xml:space="preserve">
          <source>The original style uses blanks and hyphens in the block names (except for &lt;code&gt;No_Block&lt;/code&gt;), like so:</source>
          <target state="translated">元のスタイルでは、次のように、ブロック名（ &lt;code&gt;No_Block&lt;/code&gt; を除く）に空白とハイフンが使用されます。</target>
        </trans-unit>
        <trans-unit id="8dcbc33a95cd67473b45a522488fc8cc805a4f47" translate="yes" xml:space="preserve">
          <source>The original title was</source>
          <target state="translated">元のタイトルは</target>
        </trans-unit>
        <trans-unit id="07db5f54ef4c59c897a817d5ccebc37f60d9a5b6" translate="yes" xml:space="preserve">
          <source>The original true/false value of whatever was passed into the event (but reduced down to 1 or 0).</source>
          <target state="translated">イベントに渡されたものの元の真/偽の値(ただし、1または0に縮小されています)。</target>
        </trans-unit>
        <trans-unit id="9e60244f8f199981b052b42233461b69e602ecf3" translate="yes" xml:space="preserve">
          <source>The original usage can be accomplished by explicit (rather than this pragma's implicit) encoding using the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module:</source>
          <target state="translated">元の使用法は、&lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;モジュールを使用した（このプラグマの暗黙的ではなく）明示的なエンコードによって実現できます。</target>
        </trans-unit>
        <trans-unit id="7ea4b9a6cd75e55515170d81fe9ec6a923c1c00a" translate="yes" xml:space="preserve">
          <source>The original version of B::Terse was written by Malcolm Beattie, &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;. This wrapper was written by Stephen McCamant, &amp;lt;smcc@MIT.EDU&amp;gt;.</source>
          <target state="translated">B :: Terseのオリジナルバージョンは、Malcolm Beattie &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;によって作成されました。このラッパーは、Stephen McCamant &amp;lt;smcc@MIT.EDU&amp;gt;によって書かれました。</target>
        </trans-unit>
        <trans-unit id="ba66fcf36669927e93622e0a65ee5e2d5c9bffdb" translate="yes" xml:space="preserve">
          <source>The original version of PA-RISC, HP no longer sells any system with this chip.</source>
          <target state="translated">PA-RISCのオリジナル版、HPはこのチップを搭載したシステムを販売しなくなりました。</target>
        </trans-unit>
        <trans-unit id="0705420ac769cdd445f5fb673329007ec7bccb68" translate="yes" xml:space="preserve">
          <source>The original version of this article originally appeared in The Perl Journal #10, and is copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and The Perl Journal. This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">この記事の原版は The Perl Journal #10 に掲載されたもので、著作権は 1998 The Perl Journal にあります。Jon Orwant と The Perl Journal の提供によるものです。この文書は Perl 自体と同じ条件で配布することができます。</target>
        </trans-unit>
        <trans-unit id="9009e0d18f1d5f332e2819aa4a5b08efaa84ba15" translate="yes" xml:space="preserve">
          <source>The original was written by Andy Dougherty</source>
          <target state="translated">原作はアンディ・ドハティ</target>
        </trans-unit>
        <trans-unit id="ac8cde9199e82022f2799533159dbf659a64016b" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;OA_*&lt;/code&gt; constants should not be used.</source>
          <target state="translated">その他の &lt;code&gt;OA_*&lt;/code&gt; 定数は使用しないでください。</target>
        </trans-unit>
        <trans-unit id="e99c9d2a05f195a52a6e3dccd804ac6a0edaa601" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; methods are meant to be called only once per &lt;code&gt;$parser&lt;/code&gt; object; but &lt;code&gt;parse_lines&lt;/code&gt; can be called as many times per &lt;code&gt;$parser&lt;/code&gt; object as you want, as long as the last call (and only the last call) ends with an &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">他の &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; 方法をごとに一度だけ呼ばれるように意図されている &lt;code&gt;$parser&lt;/code&gt; オブジェクト。ただし、最後の呼び出し（および最後の呼び出しのみ）が &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 値で終了している限り、 &lt;code&gt;parse_lines&lt;/code&gt; は、 &lt;code&gt;$parser&lt;/code&gt; オブジェクトごとに何度でも呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="6c95c0f77be936d4feacc6aa823fe8dfa8595f61" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; methods are meant to be called only once per &lt;code&gt;$parser&lt;/code&gt; object; but &lt;code&gt;parse_lines&lt;/code&gt; can be called as many times per &lt;code&gt;$parser&lt;/code&gt; object as you want, as long as the last call (and only the last call) ends with an &lt;code&gt;undef&lt;/code&gt; value.</source>
          <target state="translated">他の &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; 方法をごとに一度だけ呼ばれるように意図されている &lt;code&gt;$parser&lt;/code&gt; オブジェクト。ただし、最後の呼び出し（および最後の呼び出しのみ）が &lt;code&gt;undef&lt;/code&gt; 値で終了する限り、 &lt;code&gt;parse_lines&lt;/code&gt; は &lt;code&gt;$parser&lt;/code&gt; オブジェクトごとに何度でも呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="f0806e4bd09cd5bd6dbaceaf9c0baff74d032490" translate="yes" xml:space="preserve">
          <source>The other arguments should look familiar if you know &lt;code&gt;STORABLE_freeze&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;STORABLE_freeze&lt;/code&gt; を知っている場合、他の引数はおなじみのはずです。</target>
        </trans-unit>
        <trans-unit id="6d6b16332403f12890e319d0cef347a3dc9b9bef" translate="yes" xml:space="preserve">
          <source>The other arguments should look familiar if you know &lt;code&gt;STORABLE_freeze&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;STORABLE_freeze&lt;/code&gt; を知っていれば、他の引数は見覚えがあるはずです。</target>
        </trans-unit>
        <trans-unit id="407b63c5d1d6303ca3afdf08c491fa75e0221db1" translate="yes" xml:space="preserve">
          <source>The other big problem with &lt;code&gt;$^W&lt;/code&gt; is the way you can inadvertently change the warning setting in unexpected places in your code. For example, when the code below is run (without the &lt;b&gt;-w&lt;/b&gt; flag), the second call to &lt;code&gt;doit&lt;/code&gt; will trip a &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; warning, whereas the first will not.</source>
          <target state="translated">&lt;code&gt;$^W&lt;/code&gt; つの大きな問題は、コードの予期しない場所で警告設定を誤って変更してしまう方法です。たとえば、次のコードが実行されると（&lt;b&gt;-w&lt;/b&gt;フラグなしで）、 &lt;code&gt;doit&lt;/code&gt; への2番目の呼び出しは、 &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; 警告をトリップしますが、最初の呼び出しはトリップしません。</target>
        </trans-unit>
        <trans-unit id="fc649a384c23c44b5ba2efe0b85df4a20e6ec321" translate="yes" xml:space="preserve">
          <source>The other cases require a little bit more convoluted procedures. Below I suppose that the current version of Perl is &lt;code&gt;5.8.2&lt;/code&gt; , so the executables are named accordingly.</source>
          <target state="translated">他のケースでは、もう少し複雑な手順が必要です。以下では、Perlの現在のバージョンが &lt;code&gt;5.8.2&lt;/code&gt; であるため、実行可能ファイルにはそれに応じた名前を付けます。</target>
        </trans-unit>
        <trans-unit id="427a9edc8baf371e22d2821e2812db4f5b95659f" translate="yes" xml:space="preserve">
          <source>The other cases require a little bit more convoluted procedures. Below I suppose that the current version of Perl is &lt;code&gt;5.8.2&lt;/code&gt;, so the executables are named accordingly.</source>
          <target state="translated">他のケースでは、もう少し複雑な手順が必要です。以下では、Perlの現在のバージョンが &lt;code&gt;5.8.2&lt;/code&gt; であると想定しているため、実行可能ファイルにはそれに応じた名前が付けられています。</target>
        </trans-unit>
        <trans-unit id="97290d4117a272682128f8d28555111afe13c240" translate="yes" xml:space="preserve">
          <source>The other common cause is for the characters</source>
          <target state="translated">他にもよくある原因としては、キャラクターの</target>
        </trans-unit>
        <trans-unit id="c457b75f143400140761950573f5b842848c756c" translate="yes" xml:space="preserve">
          <source>The other counterpart, in the column labelled &quot;Full-range Unicode&quot;, matches any appropriate characters in the full Unicode character set. For example, &lt;code&gt;\p{Alpha}&lt;/code&gt; matches not just the ASCII alphabetic characters, but any character in the entire Unicode character set considered alphabetic. An entry in the column labelled &quot;backslash sequence&quot; is a (short) equivalent.</source>
          <target state="translated">「フルレンジUnicode」というラベルの付いた列にあるもう一方は、完全なUnicode文字セットの適切な文字と一致します。たとえば、 &lt;code&gt;\p{Alpha}&lt;/code&gt; は、ASCIIアルファベット文字だけでなく、アルファベット文字と見なされるUnicode文字セット全体の任意の文字に一致します。「バックスラッシュシーケンス」というラベルの付いた列のエントリは、（短い）同等のものです。</target>
        </trans-unit>
        <trans-unit id="f185e517dca4682b63e353adac3daa559be38725" translate="yes" xml:space="preserve">
          <source>The other form is called &quot;block eval&quot;. It is less general than string eval, but the code within the BLOCK is parsed only once (at the same time the code surrounding the &lt;code&gt;eval&lt;/code&gt; itself was parsed) and executed within the context of the current Perl program. This form is typically used to trap exceptions more efficiently than the first, while also providing the benefit of checking the code within BLOCK at compile time. BLOCK is parsed and compiled just once. Since errors are trapped, it often is used to check if a given feature is available.</source>
          <target state="translated">もう1つの形式は「ブロック評価」と呼ばれます。文字列evalほど一般的ではありませんが、BLOCK内のコードは1回だけ解析され（ &lt;code&gt;eval&lt;/code&gt; 自体を囲むコードが解析されると同時に）、現在のPerlプログラムのコンテキスト内で実行されます。この形式は通常、最初の形式よりも効率的に例外をトラップするために使用されますが、コンパイル時にBLOCK内のコードをチェックするという利点もあります。 BLOCKは、一度だけ解析およびコンパイルされます。エラーはトラップされるため、特定の機能が使用可能かどうかを確認するためによく使用されます。</target>
        </trans-unit>
        <trans-unit id="ece66aa413156fc84b73d204d2d9bbbf0fe1c18a" translate="yes" xml:space="preserve">
          <source>The other hack is to restore FP flags after a call to dlopen(). This helps against similar damage done by DLLs _DLLInitTerm() at runtime. Currently no way to switch these hacks off is provided.</source>
          <target state="translated">もう一つのハックは、dlopen()の呼び出し後にFPフラグを復元することです。これは DLL の _DLLInitTerm()が実行時に行う同様のダメージを防ぐのに役立ちます。現在のところ、これらのハックを無効にする方法は提供されていません。</target>
        </trans-unit>
        <trans-unit id="9303fbfd8a21fb685b416cbb44c3a447eed84853" translate="yes" xml:space="preserve">
          <source>The other is to install the module in a temporary location.</source>
          <target state="translated">もう一つは、モジュールを一時的に設置することです。</target>
        </trans-unit>
        <trans-unit id="7370aa653e76af4b47e0ca0cfb340c944499961e" translate="yes" xml:space="preserve">
          <source>The other modification made is that</source>
          <target state="translated">その他の修正点としては</target>
        </trans-unit>
        <trans-unit id="5eaa26235f36f66db1f5d49d6f66d3b1d7e346a6" translate="yes" xml:space="preserve">
          <source>The other one is &quot;Common&quot;. This consists of mostly punctuation, emoji, and characters used in mathematics and music, the ASCII digits &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;9&lt;/code&gt;, and full-width forms of these digits. These characters can appear intermixed in text in many of the world's scripts. These also don't cause a script run to not match. But like other scripts, all digits in a run must come from the same set of 10.</source>
          <target state="translated">もう1つは「共通」です。これは主に、数学や音楽で使用される句読点、絵文字、文字、ASCII数字の &lt;code&gt;0&lt;/code&gt; から &lt;code&gt;9&lt;/code&gt; 、およびこれらの数字の全幅形式で構成されています。これらの文字は、世界中の多くのスクリプトでテキストに混在して表示される可能性があります。これらはまた、スクリプトの実行が一致しない原因にはなりません。ただし、他のスクリプトと同様に、実行のすべての数字は同じ10のセットからのものである必要があります。</target>
        </trans-unit>
        <trans-unit id="52e0e078ed7f59ceb7388f298d1ea1da0c3bdb08" translate="yes" xml:space="preserve">
          <source>The other reason why using a variable to hold the name of another variable is a bad idea is that the question often stems from a lack of understanding of Perl data structures, particularly hashes. By using symbolic references, you are just using the package's symbol-table hash (like &lt;code&gt;%main::&lt;/code&gt; ) instead of a user-defined hash. The solution is to use your own hash or a real reference instead.</source>
          <target state="translated">変数を使用して別の変数の名前を保持するのが悪い考えであるもう1つの理由は、問題がPerlデータ構造、特にハッシュの理解の欠如から生じることが多いためです。シンボリック参照を使用することで、ユーザー定義のハッシュの代わりに、パッケージのシンボルテーブルハッシュ（ &lt;code&gt;%main::&lt;/code&gt; ）を使用しているだけです。解決策は、代わりに独自のハッシュまたは実際の参照を使用することです。</target>
        </trans-unit>
        <trans-unit id="14e65562914f1eda6c3850757c3e36b8e4c292d5" translate="yes" xml:space="preserve">
          <source>The other reason why using a variable to hold the name of another variable is a bad idea is that the question often stems from a lack of understanding of Perl data structures, particularly hashes. By using symbolic references, you are just using the package's symbol-table hash (like &lt;code&gt;%main::&lt;/code&gt;) instead of a user-defined hash. The solution is to use your own hash or a real reference instead.</source>
          <target state="translated">変数を使用して別の変数の名前を保持することが悪い考えであるもう1つの理由は、問題がPerlデータ構造、特にハッシュの理解の欠如から生じることが多いためです。シンボリック参照を使用すると、ユーザー定義のハッシュの代わりに、パッケージのシンボルテーブルハッシュ（ &lt;code&gt;%main::&lt;/code&gt; ）を使用するだけです。解決策は、代わりに独自のハッシュまたは実際の参照を使用することです。</target>
        </trans-unit>
        <trans-unit id="d23447e512ad32c2037041f02596c75ecf1a5899" translate="yes" xml:space="preserve">
          <source>The other scalar-returning list reduction functions are all specialisations of this generic idea.</source>
          <target state="translated">他のスカラーを返すリスト削減関数は,すべてこの一般的な考え方の特殊化です.</target>
        </trans-unit>
        <trans-unit id="5743b7f731fc10e9d1778f5bba7c58560baf6a5c" translate="yes" xml:space="preserve">
          <source>The other structure is pointed to by the &lt;code&gt;regexp&lt;/code&gt; struct's &lt;code&gt;pprivate&lt;/code&gt; and is in addition to &lt;code&gt;intflags&lt;/code&gt; in the same struct considered to be the property of the regex engine which compiled the regular expression;</source>
          <target state="translated">もう1つの構造は、 &lt;code&gt;regexp&lt;/code&gt; 構造体の &lt;code&gt;pprivate&lt;/code&gt; によって &lt;code&gt;intflags&lt;/code&gt; れ、同じ構造体のintflagsに加えて、正規表現をコンパイルしたregexエンジンのプロパティと見なされます。</target>
        </trans-unit>
        <trans-unit id="5b612d86c256526a7120d0f540436c62b7f8f79b" translate="yes" xml:space="preserve">
          <source>The other synchronization primitives described below can suffer from similar problems.</source>
          <target state="translated">以下に説明する他の同期化プリミティブは、同様の問題に苦しむことがある。</target>
        </trans-unit>
        <trans-unit id="375bee995645e81f309660da902b757d6a8e656a" translate="yes" xml:space="preserve">
          <source>The other way works too, especially if you are sure that all your data are under the same encoding, or if compatibility with older versions of Perl is desired.</source>
          <target state="translated">特に、すべてのデータが同じエンコーディングであることを確認している場合や、古いバージョンの Perl との互換性が必要な場合には、他の方法も有効です。</target>
        </trans-unit>
        <trans-unit id="46a4f63ad2418ff7f127884608b4d5e8c00d7b27" translate="yes" xml:space="preserve">
          <source>The others shouldn't be used in a threaded application.</source>
          <target state="translated">他の人は、スレッドアプリケーションで使うべきではありません。</target>
        </trans-unit>
        <trans-unit id="a811a8ea9dab8327d772322e2e441ab82ca0e86f" translate="yes" xml:space="preserve">
          <source>The output field separator for the print operator. If defined, this value is printed between each of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">印刷オペレーターの出力フィールド区切り記号。定義されている場合、この値は各printの引数の間に出力されます。デフォルトは &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="fdf1adf4fd2953bb9b8993988459b89f053c2344" translate="yes" xml:space="preserve">
          <source>The output field separator for the print operator. If defined, this value is printed between each of print's arguments. Default is &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">印刷演算子の出力フィールドセパレータ。定義されている場合、この値は各printの引数の間に出力されます。デフォルトは &lt;code&gt;undef&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4e6a9347f20222b252ad3782a91c8dbdeaeb1ab5" translate="yes" xml:space="preserve">
          <source>The output file to print to. If the special names &quot;-&quot; or &quot;&amp;gt;&amp;amp;1&quot; or &quot;&amp;gt;&amp;amp;STDOUT&quot; are used then standard output is used. If &quot;&amp;gt;&amp;amp;2&quot; or &quot;&amp;gt;&amp;amp;STDERR&quot; is used then standard error is used.</source>
          <target state="translated">印刷先の出力ファイル。特殊名「-」、「&amp;gt;＆1」、「&amp;gt;＆STDOUT」を使用すると、標準出力が使用されます。&quot;&amp;gt;＆2&quot;または &quot;&amp;gt;＆STDERR&quot;を使用すると、標準エラーが使用されます。</target>
        </trans-unit>
        <trans-unit id="cf7f158841e06623182985de04b67d3455d986ee" translate="yes" xml:space="preserve">
          <source>The output files are placed in the hierarchy rooted at Perl's architecture dependent library directory. You can specify a different hierarchy with a &lt;b&gt;-d&lt;/b&gt; switch.</source>
          <target state="translated">出力ファイルは、Perlのアーキテクチャ依存ライブラリディレクトリをルートとする階層に配置されます。&lt;b&gt;-d&lt;/b&gt;スイッチで別の階層を指定できます。</target>
        </trans-unit>
        <trans-unit id="c27fbec04d459297ba3b8649872110c7c0d3d15a" translate="yes" xml:space="preserve">
          <source>The output format is governed by multiple options described under &lt;a href=&quot;#Configurable-Options&quot;&gt;&quot;Configurable Options&quot;&lt;/a&gt;.</source>
          <target state="translated">出力フォーマットは、&lt;a href=&quot;#Configurable-Options&quot;&gt;「設定可能なオプション」で&lt;/a&gt;説明されている複数のオプションによって管理されます。</target>
        </trans-unit>
        <trans-unit id="5d7376e07f79489cad7f31d1cda9c5ba04d798cb" translate="yes" xml:space="preserve">
          <source>The output format is governed by multiple options described under &lt;a href=&quot;#Configurable-Options&quot;&gt;Configurable Options&lt;/a&gt;.</source>
          <target state="translated">出力形式は、「&lt;a href=&quot;#Configurable-Options&quot;&gt;構成可能なオプション」で&lt;/a&gt;説明されている複数のオプションによって管理されます。</target>
        </trans-unit>
        <trans-unit id="99376109c851932f74197e279ea101a89b6befe6" translate="yes" xml:space="preserve">
          <source>The output format of a &lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt; is determined by an earlier format declaration (&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;), so whether or not the output is affected by locale is determined by if the &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; is within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , not whether the &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; is.</source>
          <target state="translated">&lt;a href=&quot;functions/write&quot;&gt;書き込み&lt;/a&gt;の出力形式は、以前の形式宣言（&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;）によって決定されるため、出力がロケールの影響を受けるかどうかは、 &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; かどうかではなく、 &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; が &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; 範囲内にあるかどうかによって決定されます。です。</target>
        </trans-unit>
        <trans-unit id="c1530099f7317e5e8334f8069b6bb6b27df102d4" translate="yes" xml:space="preserve">
          <source>The output format of a &lt;a href=&quot;perlfunc#write&quot;&gt;write()&lt;/a&gt; is determined by an earlier format declaration (&lt;a href=&quot;perlfunc#format&quot;&gt;&quot;format&quot; in perlfunc&lt;/a&gt;), so whether or not the output is affected by locale is determined by if the &lt;code&gt;format()&lt;/code&gt; is within the scope of a &lt;code&gt;use locale&lt;/code&gt;, not whether the &lt;code&gt;write()&lt;/code&gt; is.</source>
          <target state="translated">&lt;a href=&quot;perlfunc#write&quot;&gt;write（）&lt;/a&gt;の出力形式は、以前の形式宣言（&lt;a href=&quot;perlfunc#format&quot;&gt;perlfuncの &quot;format&quot;&lt;/a&gt;）によって決定されるため、出力がロケールの影響を受けるかどうかは、 &lt;code&gt;format()&lt;/code&gt; が &lt;code&gt;use locale&lt;/code&gt; 範囲内にあるかどうかによって決まります。 &lt;code&gt;write()&lt;/code&gt; がそうであるかどうかではありません。</target>
        </trans-unit>
        <trans-unit id="821335e2d4cef7b064fd271a1052ad49bb811014" translate="yes" xml:space="preserve">
          <source>The output from an XSUB which uses something like the T_PTRREF map, which doesn't bless the object, might look something like this:</source>
          <target state="translated">オブジェクトを祝福しないT_PTRREFマップのようなものを使うXSUBからの出力は、次のようになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="0f57dea9a1d29f634f6f112b3d23937584062d88" translate="yes" xml:space="preserve">
          <source>The output from that will be</source>
          <target state="translated">そこからの出力は</target>
        </trans-unit>
        <trans-unit id="489ef92ce8f286ef5d6d82e8d178af124ae1bd61" translate="yes" xml:space="preserve">
          <source>The output is untainted. If you don't know what tainting is, don't worry about it.</source>
          <target state="translated">汚れていない状態で出力されます。染色がわからない方は気にしないでください。</target>
        </trans-unit>
        <trans-unit id="74b4c8cfc7182db2977001aba6ce4cd0c9c3eff4" translate="yes" xml:space="preserve">
          <source>The output line can be used as a template in a &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; call:</source>
          <target state="translated">出力行は、 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; 呼び出しのテンプレートとして使用できます。</target>
        </trans-unit>
        <trans-unit id="ff265796f887227add453069160ce81043ae2ad9" translate="yes" xml:space="preserve">
          <source>The output line can be used as a template in a &lt;code&gt;pack&lt;/code&gt; or &lt;code&gt;unpack&lt;/code&gt; call:</source>
          <target state="translated">出力行は、 &lt;code&gt;pack&lt;/code&gt; または &lt;code&gt;unpack&lt;/code&gt; 呼び出しのテンプレートとして使用できます。</target>
        </trans-unit>
        <trans-unit id="628776c99f7feeea9f3047213f9a74832f55bae9" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;uname -a&lt;/code&gt; if available, otherwise the hostname. The whole thing is then lower-cased and slashes and single quotes are removed.</source>
          <target state="translated">使用可能な場合は &lt;code&gt;uname -a&lt;/code&gt; の出力、それ以外の場合はホスト名。次に、全体が小文字になり、スラッシュと単一引用符が削除されます。</target>
        </trans-unit>
        <trans-unit id="b50cc56cf670c43f6be20602b16c39970c70b1a0" translate="yes" xml:space="preserve">
          <source>The output record separator for the print operator. If defined, this value is printed after the last of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">印刷オペレーターの出力レコード分離文字。定義されている場合、この値は、printの最後の引数の後に印刷されます。デフォルトは &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="bed1b55192d15d86c0d4204e8c0dbb14dedd4354" translate="yes" xml:space="preserve">
          <source>The output record separator for the print operator. If defined, this value is printed after the last of print's arguments. Default is &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">印刷演算子の出力レコード区切り文字。定義されている場合、この値は最後のprintの引数の後に出力されます。デフォルトは &lt;code&gt;undef&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="8366e38dbe1255a05a31be8b8ca8cff24bae31ce" translate="yes" xml:space="preserve">
          <source>The output shows all of the groups. The outermost matches show up first and the nested matches show up later:</source>
          <target state="translated">出力はすべてのグループを表示します。一番外側のマッチが最初に表示され、入れ子になったマッチが後に表示されます。</target>
        </trans-unit>
        <trans-unit id="61a2ac718a159127bd64e67ec39c4e8e007d9514" translate="yes" xml:space="preserve">
          <source>The output shows that Perl found the two major groups:</source>
          <target state="translated">出力は、Perlが2つの主要なグループを見つけたことを示しています。</target>
        </trans-unit>
        <trans-unit id="eb272330b66e99a860c17d412be21e54b237263f" translate="yes" xml:space="preserve">
          <source>The output shows that while in the &lt;code&gt;OUTER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$outer&lt;/code&gt; . Inside the &lt;code&gt;INNER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$inner&lt;/code&gt; , but only until the end of the block (i.e. the dynamic scope). After the &lt;code&gt;INNER&lt;/code&gt; block completes, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; return to the values for the match against &lt;code&gt;$outer&lt;/code&gt; even though we have not made another match:</source>
          <target state="translated">出力は、 &lt;code&gt;OUTER&lt;/code&gt; ブロック内で &lt;code&gt;$1&lt;/code&gt; と &lt;code&gt;$2&lt;/code&gt; 値が &lt;code&gt;$outer&lt;/code&gt; 一致からのものであることを示しています。 &lt;code&gt;INNER&lt;/code&gt; ブロック内では、 &lt;code&gt;$1&lt;/code&gt; と &lt;code&gt;$2&lt;/code&gt; の値は$ &lt;code&gt;$inner&lt;/code&gt; との一致からのものですが、ブロックの終わり（つまり、動的スコープ）までしかありません。後 &lt;code&gt;INNER&lt;/code&gt; ブロック完了、の値が &lt;code&gt;$1&lt;/code&gt; と &lt;code&gt;$2&lt;/code&gt; 戦の値への復帰 &lt;code&gt;$outer&lt;/code&gt; 私たちは別の試合を行っていないにもかかわらず：</target>
        </trans-unit>
        <trans-unit id="3aeb115218152011de3493e1c2fea22949664e64" translate="yes" xml:space="preserve">
          <source>The output shows that while in the &lt;code&gt;OUTER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$outer&lt;/code&gt;. Inside the &lt;code&gt;INNER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$inner&lt;/code&gt;, but only until the end of the block (i.e. the dynamic scope). After the &lt;code&gt;INNER&lt;/code&gt; block completes, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; return to the values for the match against &lt;code&gt;$outer&lt;/code&gt; even though we have not made another match:</source>
          <target state="translated">出力は、 &lt;code&gt;OUTER&lt;/code&gt; ブロックにある間、 &lt;code&gt;$1&lt;/code&gt; と &lt;code&gt;$2&lt;/code&gt; 値が &lt;code&gt;$outer&lt;/code&gt; 一致からのものであることを示しています。 &lt;code&gt;INNER&lt;/code&gt; ブロック内では、 &lt;code&gt;$1&lt;/code&gt; と &lt;code&gt;$2&lt;/code&gt; の値は、 &lt;code&gt;$inner&lt;/code&gt; との一致からのものですが、ブロックの終わり（つまり動的スコープ）までのみです。後 &lt;code&gt;INNER&lt;/code&gt; ブロック完了、の値が &lt;code&gt;$1&lt;/code&gt; と &lt;code&gt;$2&lt;/code&gt; 戦の値への復帰 &lt;code&gt;$outer&lt;/code&gt; 私たちは別の試合を行っていないにもかかわらず：</target>
        </trans-unit>
        <trans-unit id="43b62e463d3539b36d5bc54872fb60071ea829c7" translate="yes" xml:space="preserve">
          <source>The output shows the constant() subroutine we're testing being replaced with the value of the &lt;code&gt;DEBUG&lt;/code&gt; constant: zero. The line to be tested has been completely optimized away, and you can't get much more efficient than that.</source>
          <target state="translated">出力は、テストしているconstant（）サブルーチンが &lt;code&gt;DEBUG&lt;/code&gt; 定数の値であるゼロに置き換えられていることを示しています。テスト対象のラインは完全に最適化されており、それ以上の効率は得られません。</target>
        </trans-unit>
        <trans-unit id="223632d9e65a77def5c7f3d1e26472458213d8c9" translate="yes" xml:space="preserve">
          <source>The output string will be returned.</source>
          <target state="translated">出力文字列が返されます。</target>
        </trans-unit>
        <trans-unit id="5b1aa869d1f21ede1a6455013df56f91d9ec5d9c" translate="yes" xml:space="preserve">
          <source>The output strings for &lt;b&gt;Tputs&lt;/b&gt; are cached for counts of 1 for performance. &lt;b&gt;Tgoto&lt;/b&gt; and &lt;b&gt;Tpad&lt;/b&gt; do not cache. &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; is the raw termcap data and &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; is the cached version.</source>
          <target state="translated">&lt;b&gt;Tputs&lt;/b&gt;の出力文字列は、パフォーマンスのためにカウント1でキャッシュされます。&lt;b&gt;Tgoto&lt;/b&gt;と&lt;b&gt;Tpad&lt;/b&gt;はキャッシュしません。 &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; は生のtermcapデータで、 &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; self- &amp;gt; {xx}はキャッシュされたバージョンです。</target>
        </trans-unit>
        <trans-unit id="5e7202107b643ac3d564aacb4d094eef76b947a2" translate="yes" xml:space="preserve">
          <source>The output value, with its sign, must either be a positive value in the range 1,2,...,OBJ2-1 or the same value subtracted OBJ2. For instance, if the input arguments are objects representing the numbers 7 and 5, the method must either return an object representing the number 3 and a &quot;+&quot; sign, since (3*7) % 5 = 1 % 5, or an object representing the number 2 and &quot;-&quot; sign, since (-2*7) % 5 = 1 % 5.</source>
          <target state="translated">出力値は、1,2,...,OBJ2-1 の範囲内の正の値か、OBJ2 を差し引いた値のいずれかでなければなりません。例えば、入力引数が 7 と 5 を表すオブジェクトである場合、このメソッドは、(3*7)% 5=1 % 5 のため、数字 3 と &quot;+&quot; 記号を表すオブジェクトを返すか、(-2*7)% 5=1 % 5 のため、数字 2 と &quot;-&quot; 記号を表すオブジェクトを返すかのいずれかを返さなければなりません。</target>
        </trans-unit>
        <trans-unit id="3b69a10a3a50934e50dc62235290b18744d8011f" translate="yes" xml:space="preserve">
          <source>The output value, with its sign, must either be a positive value in the range 1,2,...,OBJ2-1 or the same value subtracted OBJ2. For instance, if the input arguments are objects representing the numbers 7 and 5, the method must either return an object representing the number 3 and a &quot;+&quot; sign, since (3*7) % 5 = 1 % 5, or an object representing the number 2 and a &quot;-&quot; sign, since (-2*7) % 5 = 1 % 5.</source>
          <target state="translated">出力値は、1,2,...,OBJ2-1 の範囲内の正の値か、OBJ2 を差し引いた値のいずれかでなければなりません。例えば、入力引数が 7 と 5 を表すオブジェクトである場合、このメソッドは、(3*7)% 5=1 % 5 なので、数 3 と &quot;+&quot; 記号を表すオブジェクトを返すか、数 2 と &quot;-&quot; 記号を表すオブジェクトを返すか、(-2*7)% 5=1 % 5 なので、どちらかを返さなければなりません。</target>
        </trans-unit>
        <trans-unit id="1eef73c78f4ba8f7baa5a469f4fff0d89cabb26a" translate="yes" xml:space="preserve">
          <source>The output you'll get when the script is executed:</source>
          <target state="translated">スクリプトが実行されたときに得られる出力。</target>
        </trans-unit>
        <trans-unit id="df416751e8a2d229d8b98d6297b404967b69b568" translate="yes" xml:space="preserve">
          <source>The output:</source>
          <target state="translated">アウトプットです。</target>
        </trans-unit>
        <trans-unit id="0dc65b45e14d95f10af2c76613db8f6869035f53" translate="yes" xml:space="preserve">
          <source>The overall, or wallclock, time between when &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; was called, and when it terminates. The elapsed time includes both user and system times, and time spent waiting for other users and processes on the system. Inevitably, this is the most approximate of the measurements given.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; が呼び出されてから終了するまでの全体的な時間、つまり壁時計の時間。経過時間には、ユーザー時間とシステム時間の両方、およびシステム上の他のユーザーとプロセスの待機に費やされた時間が含まれます。必然的に、これは与えられた測定値の最も近似的なものです。</target>
        </trans-unit>
        <trans-unit id="9571b6fa38431ae0c0fee13dd1186fe4dbf0046f" translate="yes" xml:space="preserve">
          <source>The overall, or wallclock, time between when &lt;code&gt;time&lt;/code&gt; was called, and when it terminates. The elapsed time includes both user and system times, and time spent waiting for other users and processes on the system. Inevitably, this is the most approximate of the measurements given.</source>
          <target state="translated">&lt;code&gt;time&lt;/code&gt; が呼び出されてから終了するまでの全体的な時間、つまり実時間。経過時間には、ユーザー時間とシステム時間の両方、およびシステム上の他のユーザーとプロセスの待機に費やされた時間が含まれます。必然的に、これは与えられた測定値の最も近似的なものです。</target>
        </trans-unit>
        <trans-unit id="5407cf16873f519751b5a5a5e241e60dd7a6b88b" translate="yes" xml:space="preserve">
          <source>The pTHX_ symbol in the definition is a macro used by Perl under threading to provide an extra argument to the routine holding a pointer back to the interpreter that is executing the regexp. So under threading all routines get an extra argument.</source>
          <target state="translated">定義にある pTHX_シンボルは、Perl がスレッド処理中に使用するマクロで、正規表現を実行しているインタープリタへのポインタを保持しているルーチンに余分な引数を提供するためのものです。つまり、スレッディング中のすべてのルーチンは、余分な引数を取得します。</target>
        </trans-unit>
        <trans-unit id="f3fe23968698971d8ab162ac70a7f7b71df42802" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;A*&lt;/code&gt; gobbles up all remaining bytes, and &lt;code&gt;$prio&lt;/code&gt; remains undefined! Before we let disappointment dampen the morale: Perl's got the trump card to make this trick too, just a little further up the sleeve. Watch this:</source>
          <target state="translated">パックコード &lt;code&gt;A*&lt;/code&gt; 残りのバイトをすべて消費し、 &lt;code&gt;$prio&lt;/code&gt; は未定義のままです！私たちが失望する前に士気を落とす前に：Perlはこのトリックを作るための切り札も持っています。これを見て：</target>
        </trans-unit>
        <trans-unit id="7933b3c7848d20de1a22817261c68e6d7c53c8c0" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;w&lt;/code&gt; has been added to support a portable binary data encoding scheme that goes way beyond simple integers. (Details can be found at &lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt;, the Scarab project.) A BER (Binary Encoded Representation) compressed unsigned integer stores base 128 digits, most significant digit first, with as few digits as possible. Bit eight (the high bit) is set on each byte except the last. There is no size limit to BER encoding, but Perl won't go to extremes.</source>
          <target state="translated">パックコード &lt;code&gt;w&lt;/code&gt; は、単純な整数をはるかに超える移植可能なバイナリデータエンコード方式をサポートするために追加されました。 （詳細は&lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt;のScarabプロジェクトにあります。）BER（Binary Encoded Representation）圧縮された符号なし整数は、128桁のベースで、最上位桁が最初に、できるだけ少ない桁数で格納されます。最後を除いて、各バイトにビット8（上位ビット）が設定されます。 BERエンコードにサイズの制限はありませんが、Perlは極端には行きません。</target>
        </trans-unit>
        <trans-unit id="b79ab5606b336d2e61cfa7238de19673ec485cc8" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;w&lt;/code&gt; has been added to support a portable binary data encoding scheme that goes way beyond simple integers. (Details can be found at &lt;a href=&quot;https://github.com/mworks-project/mw_scarab/blob/master/Scarab-0.1.00d19/doc/binary-serialization.txt&quot;&gt;https://github.com/mworks-project/mw_scarab/blob/master/Scarab-0.1.00d19/doc/binary-serialization.txt&lt;/a&gt;, the Scarab project.) A BER (Binary Encoded Representation) compressed unsigned integer stores base 128 digits, most significant digit first, with as few digits as possible. Bit eight (the high bit) is set on each byte except the last. There is no size limit to BER encoding, but Perl won't go to extremes.</source>
          <target state="translated">パックコード &lt;code&gt;w&lt;/code&gt; は、単純な整数をはるかに超えるポータブルなバイナリデータエンコーディングスキームをサポートするために追加されました。（詳細は&lt;a href=&quot;https://github.com/mworks-project/mw_scarab/blob/master/Scarab-0.1.00d19/doc/binary-serialization.txt&quot;&gt;https://github.com/mworks-project/mw_scarab/blob/master/Scarab-0.1.00d19/doc/binary-serialization.txt、Scarab&lt;/a&gt;プロジェクトにあります。）BER（バイナリエンコード表現）圧縮された符号なし整数は、基数128桁を格納し、最上位桁を最初に、可能な限り少ない桁数で格納します。ビット8（上位ビット）は、最後を除く各バイトに設定されます。BERエンコーディングにサイズ制限はありませんが、Perlは極端にはなりません。</target>
        </trans-unit>
        <trans-unit id="1cf9569df81623b7e7940e6c5aeacc511770e43a" translate="yes" xml:space="preserve">
          <source>The pack code for big-endian (high order byte at the lowest address) is &lt;code&gt;n&lt;/code&gt; for 16 bit and &lt;code&gt;N&lt;/code&gt; for 32 bit integers. You use these codes if you know that your data comes from a compliant architecture, but, surprisingly enough, you should also use these pack codes if you exchange binary data, across the network, with some system that you know next to nothing about. The simple reason is that this order has been chosen as the</source>
          <target state="translated">ビッグエンディアン（最下位アドレスの上位バイト）のパックコードは、16ビットの &lt;code&gt;n&lt;/code&gt; はn、32ビット整数の場合は &lt;code&gt;N&lt;/code&gt; です。これらのコードは、データが準拠アーキテクチャからのものであることがわかっている場合に使用しますが、驚くべきことに、ネットワークを介してバイナリデータを交換する場合は、これらのパックコードを使用する必要があります。単純な理由は、この順序が</target>
        </trans-unit>
        <trans-unit id="57fad0d4b36d335f1fb095e9863848e373754e9c" translate="yes" xml:space="preserve">
          <source>The pack code preceding &lt;code&gt;/&lt;/code&gt; may be anything that's fit to represent a number: All the numeric binary pack codes, and even text codes such as &lt;code&gt;A4&lt;/code&gt; or &lt;code&gt;Z*&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; の前のパックコードは、数値を表すのに適しているものであれば何でもかまいません。すべての数値バイナリパックコード、さらには &lt;code&gt;A4&lt;/code&gt; や &lt;code&gt;Z*&lt;/code&gt; などのテキストコードです。</target>
        </trans-unit>
        <trans-unit id="65094bdd21f0a1919cd6838b37b6c0d3bbee3405" translate="yes" xml:space="preserve">
          <source>The pack code preceding &lt;code&gt;/&lt;/code&gt; may be anything that's fit to represent a number: All the numeric binary pack codes, and even text codes such as &lt;code&gt;A4&lt;/code&gt; or &lt;code&gt;Z*&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;/&lt;/code&gt; の前のパックコードは、数値を表すのに適したものであれば何でもかまいません。すべての数値のバイナリパックコード、さらには &lt;code&gt;A4&lt;/code&gt; や &lt;code&gt;Z*&lt;/code&gt; などのテキストコードです。</target>
        </trans-unit>
        <trans-unit id="7172e02890f0d23e60cb06f72d229c969bc3f33e" translate="yes" xml:space="preserve">
          <source>The pack format &lt;code&gt;A&lt;/code&gt; means &quot;any character&quot;; if you're &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;ing and you've run out of things to pack, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; will fill the rest up with spaces.</source>
          <target state="translated">パック形式 &lt;code&gt;A&lt;/code&gt; は「任意の文字」を意味します。あなたがいる場合は &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; INGとあなたがパックするものがなくなってきた、 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; スペースで残りを埋めます。</target>
        </trans-unit>
        <trans-unit id="44495eb674e0583287f2264fa02ffed62c8c4074" translate="yes" xml:space="preserve">
          <source>The pack format &lt;code&gt;A&lt;/code&gt; means &quot;any character&quot;; if you're &lt;code&gt;pack&lt;/code&gt;ing and you've run out of things to pack, &lt;code&gt;pack&lt;/code&gt; will fill the rest up with spaces.</source>
          <target state="translated">パック形式 &lt;code&gt;A&lt;/code&gt; は「任意の文字」を意味します。あなたがいる場合は &lt;code&gt;pack&lt;/code&gt; INGとあなたがパックするものがなくなってきた、 &lt;code&gt;pack&lt;/code&gt; スペースで残りを埋めます。</target>
        </trans-unit>
        <trans-unit id="9582d05d51afa98d043db268f238bb511bec0a17" translate="yes" xml:space="preserve">
          <source>The package contains a session manager and a cache manager. The session manager keeps track of what has been fetched, built, and installed in the current session. The cache manager keeps track of the disk space occupied by the make processes and deletes excess space using a simple FIFO mechanism.</source>
          <target state="translated">本パッケージにはセッションマネージャとキャッシュマネージャが含まれます。セッションマネージャは、現在のセッションで何がフェッチされ、ビルドされ、インストールされたかを追跡します。キャッシュマネージャは make プロセスが占有するディスク領域を追跡し、シンプルな FIFO 機構を使って余分な領域を削除します。</target>
        </trans-unit>
        <trans-unit id="f2c3c65c0d45b6b1fe4dfd7fdaf1376fd647a40b" translate="yes" xml:space="preserve">
          <source>The package from which the exceptional subroutine was called.</source>
          <target state="translated">例外的なサブルーチンが呼び出されたパッケージ。</target>
        </trans-unit>
        <trans-unit id="fdc4d85fb172b2eb58f10fb1bda38f21c477922a" translate="yes" xml:space="preserve">
          <source>The package name argument will typically be the name of the class into which the subroutine was declared, but it may also be the name of a derived class (since handlers are inherited).</source>
          <target state="translated">パッケージ名の引数には通常、サブルーチンが宣言されたクラスの名前を指定しますが、派生クラスの名前を指定することもできます(ハンドラは継承されるので)。</target>
        </trans-unit>
        <trans-unit id="91efffdbf8c7db0b4f5430206e2d6e6cd3563e8f" translate="yes" xml:space="preserve">
          <source>The package name uses the &lt;code&gt;DBM_Filter::&lt;/code&gt; prefix.</source>
          <target state="translated">パッケージ名は &lt;code&gt;DBM_Filter::&lt;/code&gt; プレフィックスを使用します。</target>
        </trans-unit>
        <trans-unit id="61ad7bd19c49da733338e6250d6950f088f8b981" translate="yes" xml:space="preserve">
          <source>The package representing the distribution. For example, &lt;code&gt;Test::More&lt;/code&gt; or &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . It will be used to derive information about the distribution such as the &lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt;, installation locations within the Perl library and where XS files will be looked for by default (see &lt;a href=&quot;#XS&quot;&gt;XS&lt;/a&gt;).</source>
          <target state="translated">ディストリビューションを表すパッケージ。たとえば、 &lt;code&gt;Test::More&lt;/code&gt; または &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; です。これは、&lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt;、Perlライブラリ内のインストール場所、デフォルトでXSファイルが検索される場所など、ディストリビューションに関する情報を取得するために使用されます（&lt;a href=&quot;#XS&quot;&gt;XSを&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="cf847620b5ea5a28241ef80f16dce588c1976c67" translate="yes" xml:space="preserve">
          <source>The package representing the distribution. For example, &lt;code&gt;Test::More&lt;/code&gt; or &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt;. It will be used to derive information about the distribution such as the &lt;a href=&quot;#DISTNAME&quot;&gt;&quot;DISTNAME&quot;&lt;/a&gt;, installation locations within the Perl library and where XS files will be looked for by default (see &lt;a href=&quot;#XS&quot;&gt;&quot;XS&quot;&lt;/a&gt;).</source>
          <target state="translated">ディストリビューションを表すパッケージ。たとえば、 &lt;code&gt;Test::More&lt;/code&gt; または &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; です。これは、&lt;a href=&quot;#DISTNAME&quot;&gt;「DISTNAME」&lt;/a&gt;、Perlライブラリ内のインストール場所、デフォルトでXSファイルが検索される場所などのディストリビューションに関する情報を取得するために使用されます（&lt;a href=&quot;#XS&quot;&gt;「XS」を&lt;/a&gt;参照）。</target>
        </trans-unit>
        <trans-unit id="4576d414ced67927c5747f7cd9e683dea9105380" translate="yes" xml:space="preserve">
          <source>The package the qr// magic object is blessed into (as seen by &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;
qr//&lt;/code&gt; ). It is recommended that engines change this to their package name for identification regardless of if they implement methods on the object.</source>
          <target state="translated">qr //マジックオブジェクトがblessされたパッケージ（ &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; qr//&lt;/code&gt; 見られる）。エンジンは、オブジェクトにメソッドを実装しているかどうかに関係なく、識別のためにパッケージ名に変更することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="3eb8be4161caf31aed9851aac09981f2dc091cb7" translate="yes" xml:space="preserve">
          <source>The package the qr// magic object is blessed into (as seen by &lt;code&gt;ref qr//&lt;/code&gt;). It is recommended that engines change this to their package name for identification regardless of if they implement methods on the object.</source>
          <target state="translated">qr //マジックオブジェクトが祝福されているパッケージ（ &lt;code&gt;ref qr//&lt;/code&gt; 見られるように）。エンジンがオブジェクトにメソッドを実装しているかどうかに関係なく、識別のためにこれをパッケージ名に変更することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="73079d10e9cd577552c5b87cfb22afa1b7851691" translate="yes" xml:space="preserve">
          <source>The package this method returns should also have the internal &lt;code&gt;Regexp&lt;/code&gt; package in its &lt;code&gt;@ISA&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; should always be true regardless of what engine is being used.</source>
          <target state="translated">このメソッドが返すパッケージには、 &lt;code&gt;@ISA&lt;/code&gt; &lt;code&gt;Regexp&lt;/code&gt; に内部Regexpパッケージも含まれている必要があります。 &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; は、使用されているエンジンに関係なく、常にtrueである必要があります。</target>
        </trans-unit>
        <trans-unit id="890f0468ce1dfbaa3a848480f6a3e9f003f8a19f" translate="yes" xml:space="preserve">
          <source>The package this method returns should also have the internal &lt;code&gt;Regexp&lt;/code&gt; package in its &lt;code&gt;@ISA&lt;/code&gt;. &lt;code&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/code&gt; should always be true regardless of what engine is being used.</source>
          <target state="translated">このメソッドが返すパッケージには、 &lt;code&gt;@ISA&lt;/code&gt; &lt;code&gt;Regexp&lt;/code&gt; に内部正規表現パッケージも含まれている必要があります。 &lt;code&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/code&gt; は、使用されているエンジンに関係なく、常にtrueである必要があります。</target>
        </trans-unit>
        <trans-unit id="7b32ac926fcc794f5f7982e502e4686af4c595bf" translate="yes" xml:space="preserve">
          <source>The package variable &lt;code&gt;@EXPORT&lt;/code&gt; will determine which symbols will get exported when the caller simply says &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; - you will hardly ever want to put anything in there. &lt;code&gt;@EXPORT_OK&lt;/code&gt; , on the other hand, specifies which symbols you're willing to export. If you do want to export a bunch of symbols, use the &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; and define a standard export set - look at &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for more details.</source>
          <target state="translated">パッケージ変数 &lt;code&gt;@EXPORT&lt;/code&gt; は、呼び出し元が &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; 単に言うときにエクスポートされるシンボルを決定します。一方、 &lt;code&gt;@EXPORT_OK&lt;/code&gt; は、エクスポートするシンボルを指定します。 &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; シンボルをエクスポートする場合は、％EXPORT_TAGSを使用して標準のエクスポートセットを定義します。詳細については、&lt;a href=&quot;exporter&quot;&gt;エクスポーター&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9d8ef2409327fe0b3b34e7e40584004dedfbd9fc" translate="yes" xml:space="preserve">
          <source>The package variable &lt;code&gt;@EXPORT&lt;/code&gt; will determine which symbols will get exported when the caller simply says &lt;code&gt;use Net::Acme&lt;/code&gt; - you will hardly ever want to put anything in there. &lt;code&gt;@EXPORT_OK&lt;/code&gt;, on the other hand, specifies which symbols you're willing to export. If you do want to export a bunch of symbols, use the &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; and define a standard export set - look at &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for more details.</source>
          <target state="translated">パッケージ変数 &lt;code&gt;@EXPORT&lt;/code&gt; は、呼び出し元が単に &lt;code&gt;use Net::Acme&lt;/code&gt; と言ったときにエクスポートされるシンボルを決定します。そこに何も入れたくないでしょう。一方、 &lt;code&gt;@EXPORT_OK&lt;/code&gt; 、エクスポートするシンボルを指定します。 &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; シンボルをエクスポートする場合は、％EXPORT_TAGSを使用して、標準のエクスポートセットを定義します。詳細については、&lt;a href=&quot;exporter&quot;&gt;エクスポーター&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="650111e5202c538679780ce9ea893a905f97b0fc" translate="yes" xml:space="preserve">
          <source>The packages relating to various DBM-related implementations (</source>
          <target state="translated">DBM関連の各種実装に関連するパッケージ(</target>
        </trans-unit>
        <trans-unit id="02ef2277604c9b31476ae26defa7602571798335" translate="yes" xml:space="preserve">
          <source>The pad names in the PADNAMELIST have their PV holding the name of the variable. The &lt;code&gt;COP_SEQ_RANGE_LOW&lt;/code&gt; and &lt;code&gt;_HIGH&lt;/code&gt; fields form a range (low+1..high inclusive) of cop_seq numbers for which the name is valid. During compilation, these fields may hold the special value PERL_PADSEQ_INTRO to indicate various stages:</source>
          <target state="translated">PADNAMELISTのパッド名には、変数の名前を保持するPVがあります。 &lt;code&gt;COP_SEQ_RANGE_LOW&lt;/code&gt; と &lt;code&gt;_HIGH&lt;/code&gt; フィールドは、名前が有効であるcop_seq番号の範囲（低+ 1..high込み）を形成します。コンパイル中、これらのフィールドは、さまざまな段階を示すために特別な値PERL_PADSEQ_INTROを保持する場合があります。</target>
        </trans-unit>
        <trans-unit id="c94813a5310ff08ec4ccbc37cd40783e0084e83e" translate="yes" xml:space="preserve">
          <source>The pad names in the PADNAMELIST have their PV holding the name of the variable. The COP_SEQ_RANGE_LOW and _HIGH fields form a range (low+1..high inclusive) of cop_seq numbers for which the name is valid. During compilation, these fields may hold the special value PERL_PADSEQ_INTRO to indicate various stages:</source>
          <target state="translated">PADNAMELIST のパッド名は、その変数の名前を保持する PV を持つ。COP_SEQ_RANGE_LOWフィールドと_HIGHフィールドは、名前が有効なCOP_SEQ番号の範囲(LOW+1~HIGHを含む)を形成します。コンパイル中、これらのフィールドは、様々な段階を示すために特別な値PERL_PADSEQ_INTROを保持することがあります。</target>
        </trans-unit>
        <trans-unit id="ad69ddb72e9f5b5565c26efc4eeac2130e2ed028" translate="yes" xml:space="preserve">
          <source>The padded $string is returned.</source>
          <target state="translated">パディングされた$stringが返されます。</target>
        </trans-unit>
        <trans-unit id="d3a360c727f09061a32c58fb443bedffc200fc64" translate="yes" xml:space="preserve">
          <source>The paper &quot;How to Break MD5 and Other Hash Functions&quot; by Xiaoyun Wang and Hongbo Yu.</source>
          <target state="translated">Xiaoyun Wang氏とHongbo Yu氏による論文「How to Break MD5 and Other Hash Functions」が掲載されています。</target>
        </trans-unit>
        <trans-unit id="9446a617fdf40553874ee589e7fc235690a0bb87" translate="yes" xml:space="preserve">
          <source>The paragraphs you give to &lt;a href=&quot;Text::Wrap&quot;&gt;Text::Wrap&lt;/a&gt; should not contain embedded newlines. &lt;a href=&quot;Text::Wrap&quot;&gt;Text::Wrap&lt;/a&gt; doesn't justify the lines (flush-right).</source>
          <target state="translated">&lt;a href=&quot;Text::Wrap&quot;&gt;Text :: Wrapに指定&lt;/a&gt;する段落には、改行を埋め込んではいけません。&lt;a href=&quot;Text::Wrap&quot;&gt;Text :: Wrapは行を&lt;/a&gt;正当化しません（フラッシュ右）。</target>
        </trans-unit>
        <trans-unit id="6bcc7e86c6ab48d9801f437d7ce277bb0ef436bb" translate="yes" xml:space="preserve">
          <source>The paragraphs you give to &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; should not contain embedded newlines. &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; doesn't justify the lines (flush-right).</source>
          <target state="translated">&lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrapに&lt;/a&gt;与える段落には、改行が埋め込まれていてはいけません。&lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrapは行を揃え&lt;/a&gt;ません（右揃え）。</target>
        </trans-unit>
        <trans-unit id="0d3c20158693e8f7ad6ce14151f5e71a493b3128" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the compressed data. This parameter can take one of these forms.</source>
          <target state="translated">パラメータ &lt;code&gt;$output_filename_or_reference&lt;/code&gt; は、圧縮データの宛先を制御するために使用されます。このパラメーターは、次のいずれかの形式を取ることができます。</target>
        </trans-unit>
        <trans-unit id="2a2ee58982c19a9868c4499e7bd1b9d1531f2904" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the uncompressed data. This parameter can take one of these forms.</source>
          <target state="translated">パラメータ &lt;code&gt;$output_filename_or_reference&lt;/code&gt; は、非圧縮データの宛先を制御するために使用されます。このパラメーターは、次のいずれかの形式を取ることができます。</target>
        </trans-unit>
        <trans-unit id="4380851c25da81befd83447bad55f6f9f369b966" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$text&lt;/code&gt; is a string or block of text to be parsed for interior sequences; and the parameter &lt;code&gt;$line_num&lt;/code&gt; is the line number corresponding to the beginning of &lt;code&gt;$text&lt;/code&gt; .</source>
          <target state="translated">パラメータ &lt;code&gt;$text&lt;/code&gt; は、内部シーケンスについて解析される文字列またはテキストのブロックです。パラメータ &lt;code&gt;$line_num&lt;/code&gt; は、 &lt;code&gt;$text&lt;/code&gt; 先頭に対応する行番号です。</target>
        </trans-unit>
        <trans-unit id="175733e4967510eadb5d4ab18e962461101eaed6" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;extra_libs&lt;/code&gt; can be used to specify &lt;b&gt;additional&lt;/b&gt; paths to search for installed modules. For instance</source>
          <target state="translated">パラメータ &lt;code&gt;extra_libs&lt;/code&gt; を使用して、インストールされているモジュールを検索するための&lt;b&gt;追加の&lt;/b&gt;パスを指定できます。例えば</target>
        </trans-unit>
        <trans-unit id="76679b1c7056137b35154fa4603dcc56a2e17eed" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;type&lt;/code&gt; is an enumeration which specifies which of the 3 interface methods (DB_HASH, DB_BTREE or DB_RECNO) is to be used. Depending on which of these is actually chosen, the final parameter,</source>
          <target state="translated">パラメータ &lt;code&gt;type&lt;/code&gt; は、3つのインターフェースメソッド（DB_HASH、DB_BTREE、またはDB_RECNO）のどれを使用するかを指定する列挙型です。これらのどれが実際に選択されるかに応じて、最後のパラメーターは、</target>
        </trans-unit>
        <trans-unit id="6df79d8edafef2b8d47fc8b433ceb1dac071556d" translate="yes" xml:space="preserve">
          <source>The parameter list to my() may be assigned to if desired, which allows you to initialize your variables. (If no initializer is given for a particular variable, it is created with the undefined value.) Commonly this is used to name input parameters to a subroutine. Examples:</source>
          <target state="translated">my()へのパラメータリストは、必要に応じて代入することができ、変数を初期化することができます。(特定の変数にイニシャライザが与えられていない場合は、未定義の値で作成されます)。一般的には、これはサブルーチンへの入力パラメータに名前を付けるために使用されます。例を示します。</target>
        </trans-unit>
        <trans-unit id="42306ba107d404a6932eda2f03148007a2382a8a" translate="yes" xml:space="preserve">
          <source>The parameter's default value will still be evaluated if the corresponding argument isn't supplied, even though the value won't be stored anywhere. This is in case evaluating it has important side effects. However, it will be evaluated in void context, so if it doesn't have side effects and is not trivial it will generate a warning if the &quot;void&quot; warning category is enabled. If a nameless optional parameter's default value is not important, it may be omitted just as the parameter's name was:</source>
          <target state="translated">パラメータのデフォルト値は、対応する引数が与えられていない場合には、値がどこにも保存されないにもかかわらず評価されます。これは、パラメータを評価することで重要な副作用がある場合のためです。しかし、これは void コンテキストで評価されるので、副作用がなく、些細なことではない場合は、&quot;void&quot; 警告カテゴリが有効になっている場合に警告が発生します。名前のないオプションパラメータのデフォルト値が重要でない場合は、パラメータの名前があったように省略されることがあります。</target>
        </trans-unit>
        <trans-unit id="59f23da7798f0b234972a256a92c78bcfb8c2aa3" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the compressed data.</source>
          <target state="translated">パラメータ &lt;code&gt;$input_filename_or_reference&lt;/code&gt; は、圧縮データのソースを定義するために使用されます。</target>
        </trans-unit>
        <trans-unit id="ed835ab2fa9d34eac4fd3a603940891a0a5eef62" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the uncompressed data.</source>
          <target state="translated">パラメータ &lt;code&gt;$input_filename_or_reference&lt;/code&gt; は、非圧縮データのソースを定義するために使用されます。</target>
        </trans-unit>
        <trans-unit id="4cb5c66abe58beef181f4c5d5c5b7b8d0a8b5206" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt;, is used to define the source of the compressed data.</source>
          <target state="translated">パラメータ &lt;code&gt;$input_filename_or_reference&lt;/code&gt; は、圧縮データのソースを定義するために使用されます。</target>
        </trans-unit>
        <trans-unit id="c7a676729b0be9ab28de0e8dc42a59d230912658" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt;, is used to define the source of the uncompressed data.</source>
          <target state="translated">パラメータ &lt;code&gt;$input_filename_or_reference&lt;/code&gt; は、非圧縮データのソースを定義するために使用されます。</target>
        </trans-unit>
        <trans-unit id="2e0cab04bcd8cbbda8dd4d2c9ce2cf18535f80ac" translate="yes" xml:space="preserve">
          <source>The parameters it accepts are:</source>
          <target state="translated">それが受け入れるパラメータは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="a830abc7b9d4b876164e2805f5f239e46c825485" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; are added to the start of the perl search path. Saying</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; を&lt;a href=&quot;functions/use&quot;&gt;使用するため&lt;/a&gt;のパラメーターがperl検索パスの先頭に追加されます。言っている</target>
        </trans-unit>
        <trans-unit id="735cc433a3b6580bd3067e26aea227e52cc434e6" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;use lib&lt;/code&gt; are added to the start of the perl search path. Saying</source>
          <target state="translated">&lt;code&gt;use lib&lt;/code&gt; を使用するためのパラメーターは、perl検索パスの先頭に追加されます。ことわざ</target>
        </trans-unit>
        <trans-unit id="ea253e51dc3b40387e985b7980c9898cef5a3467" translate="yes" xml:space="preserve">
          <source>The parentheses about &lt;code&gt;XSLoader::load()&lt;/code&gt; arguments are needed since we replaced &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, so the compiler does not know that a function &lt;code&gt;XSLoader::load()&lt;/code&gt; is present.</source>
          <target state="translated">およそ括弧 &lt;code&gt;XSLoader::load()&lt;/code&gt; 私たちは置き換えので、引数が必要な &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; によって &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; コンパイラが関数のことを知らないので、 &lt;code&gt;XSLoader::load()&lt;/code&gt; 存在しています。</target>
        </trans-unit>
        <trans-unit id="0d68003766a6505369e854c0eee6d10a747bd253" translate="yes" xml:space="preserve">
          <source>The parentheses about &lt;code&gt;XSLoader::load()&lt;/code&gt; arguments are needed since we replaced &lt;code&gt;use XSLoader&lt;/code&gt; by &lt;code&gt;require&lt;/code&gt;, so the compiler does not know that a function &lt;code&gt;XSLoader::load()&lt;/code&gt; is present.</source>
          <target state="translated">およそ括弧 &lt;code&gt;XSLoader::load()&lt;/code&gt; 私たちは置き換えので、引数が必要な &lt;code&gt;use XSLoader&lt;/code&gt; によって &lt;code&gt;require&lt;/code&gt; コンパイラが関数のことを知らないので、 &lt;code&gt;XSLoader::load()&lt;/code&gt; 存在しています。</target>
        </trans-unit>
        <trans-unit id="f992098d3a5a843dac6b8ae9c7b69d4a2fac46e8" translate="yes" xml:space="preserve">
          <source>The parse proceeds pretty much exactly as it does during the construction phase, except that most routines are short-circuited to change the size field &lt;code&gt;RExC_size&lt;/code&gt; and not do anything else.</source>
          <target state="translated">構文解析は、ほとんどのルーチンがサイズフィールド &lt;code&gt;RExC_size&lt;/code&gt; を変更するために短絡され、他には何もしないことを除いて、構築フェーズ中とほぼ同じように進行します。</target>
        </trans-unit>
        <trans-unit id="ce842c5dcf2b13fb8c9e8394fe72be9c8b2663ca" translate="yes" xml:space="preserve">
          <source>The parser is heavily inspired from the one in &lt;a href=&quot;ExtUtils::ParseXS&quot;&gt;ExtUtils::ParseXS&lt;/a&gt;.</source>
          <target state="translated">パーサーは、&lt;a href=&quot;ExtUtils::ParseXS&quot;&gt;ExtUtils :: ParseXSの&lt;/a&gt;ものから大きく影響を受けています。</target>
        </trans-unit>
        <trans-unit id="93ac900e49339cc6ef6dea21ed4478644c93af89" translate="yes" xml:space="preserve">
          <source>The parser is nobly assisted by the lexer, which chunks up your input into tokens, and decides what type of thing each token is: a variable name, an operator, a bareword, a subroutine, a core function, and so on. The main point of entry to the lexer is &lt;code&gt;yylex&lt;/code&gt; , and that and its associated routines can be found in</source>
          <target state="translated">パーサーは、入力をトークンに分割し、各トークンのタイプを決定するレクサーによって、変数名、演算子、ベアワード、サブルーチン、コア関数などを支援します。レクサーへの入り口の主なポイントは &lt;code&gt;yylex&lt;/code&gt; で、それとそれに関連するルーチンは次の場所にあります。</target>
        </trans-unit>
        <trans-unit id="22cd9c89b1bd366e42455f5006c44969bcb5bdee" translate="yes" xml:space="preserve">
          <source>The parser is nobly assisted by the lexer, which chunks up your input into tokens, and decides what type of thing each token is: a variable name, an operator, a bareword, a subroutine, a core function, and so on. The main point of entry to the lexer is &lt;code&gt;yylex&lt;/code&gt;, and that and its associated routines can be found in</source>
          <target state="translated">パーサーは、入力をトークンにチャンクし、各トークンがどのタイプのものであるか（変数名、演算子、ベアワード、サブルーチン、コア関数など）を決定するレクサーによって気高く支援されます。レクサーへの主要なエントリポイントは &lt;code&gt;yylex&lt;/code&gt; であり、それとそれに関連するルーチンは次の場所にあります。</target>
        </trans-unit>
        <trans-unit id="c291c44225b529aa63eb30ed6a4d6cbe06294dcd" translate="yes" xml:space="preserve">
          <source>The parser then sees the following code:</source>
          <target state="translated">すると、パーサーは次のようなコードを表示します。</target>
        </trans-unit>
        <trans-unit id="d30f0f58beb42ee5cf5d76db1412cac91e934bb2" translate="yes" xml:space="preserve">
          <source>The part of an Email address which follows the @ is not necessarily a hostname, it is a mail domain. To find the name of a host to connect for a mail domain you need to do a DNS MX lookup</source>
          <target state="translated">メールアドレスの@に続く部分は必ずしもホスト名ではなく、メールドメインです。メールドメインに接続するホスト名を見つけるには、DNS MX検索を行う必要があります。</target>
        </trans-unit>
        <trans-unit id="09f50fcb4a70f717d3ac7b5f391fbd97a01ce899" translate="yes" xml:space="preserve">
          <source>The part of the address of a TCP or UDP socket that directs packets to the correct process after finding the right machine, something like the phone extension you give when you reach the company operator. Also the result of converting code to run on a different platform than originally intended, or the verb denoting this conversion.</source>
          <target state="translated">TCPまたはUDPソケットのアドレスの一部で、適切なマシンを見つけた後に正しいプロセスにパケットを送るためのものです。また、本来意図したものとは異なるプラットフォームで動作するようにコードを変換した結果、またはこの変換を表す動詞のこと。</target>
        </trans-unit>
        <trans-unit id="ae986ba9c61f4a263f7b3033ed66b7a9c47ca2ea" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use does not support the specified signal being used in a &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; call.</source>
          <target state="translated">使用しようとしているPerlの特定のコピーは、 &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; 呼び出しで使用されている指定されたシグナルをサポートしていません。</target>
        </trans-unit>
        <trans-unit id="24e4beb9cede37117dbc38642ef9d4cdf73ef0f4" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use was not built using the &lt;code&gt;useithreads&lt;/code&gt; configuration option.</source>
          <target state="translated">使用しようとしているPerlの特定のコピーは、 &lt;code&gt;useithreads&lt;/code&gt; 構成オプションを使用してビルドされていません。</target>
        </trans-unit>
        <trans-unit id="e133c3129f1a418b83b69fbe9affe042d494a52e" translate="yes" xml:space="preserve">
          <source>The particular macro you must use depends on which &lt;code&gt;sv_set*v&lt;/code&gt; routine you called first. This is because every &lt;code&gt;sv_set*v&lt;/code&gt; routine turns on only the bit for the particular type of data being set, and turns off all the rest.</source>
          <target state="translated">使用する必要がある特定のマクロは、最初に &lt;code&gt;sv_set*v&lt;/code&gt; ルーチンによって異なります。これは、すべての &lt;code&gt;sv_set*v&lt;/code&gt; ルーチンが、設定される特定のタイプのデータのビットのみをオンにし、残りのすべてをオフにするためです。</target>
        </trans-unit>
        <trans-unit id="9a1356c02587b997ee27ddf50eebcf831988fbcb" translate="yes" xml:space="preserve">
          <source>The passed-in property may be specified as any of the synonyms returned by &lt;a href=&quot;#prop_aliases%28%29&quot;&gt;&quot;prop_aliases()&quot;&lt;/a&gt;.</source>
          <target state="translated">渡されたプロパティは、&lt;a href=&quot;#prop_aliases%28%29&quot;&gt;「prop_aliases（）」&lt;/a&gt;によって返される同義語のいずれかとして指定できます。</target>
        </trans-unit>
        <trans-unit id="1c24d584fffb94c2e195393379212bd0e772bba9" translate="yes" xml:space="preserve">
          <source>The passed-in property may be specified as any of the synonyms returned by &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases()&lt;/a&gt;.</source>
          <target state="translated">渡されたプロパティは、&lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases（）&lt;/a&gt;によって返される同義語のいずれかとして指定できます。</target>
        </trans-unit>
        <trans-unit id="515ad1971581ebeed29e0dfbff2e2ca6f9f34b5c" translate="yes" xml:space="preserve">
          <source>The patchlevel level of this package. The value of patchlevel comes from the</source>
          <target state="translated">このパッケージのパッチレベル。patchlevel の値は</target>
        </trans-unit>
        <trans-unit id="6c9c1991e5426882e512831205056ad8d0cb53e5" translate="yes" xml:space="preserve">
          <source>The path Perl takes through &lt;code&gt;@INC&lt;/code&gt; . By default, this is a double depth first search, once looking for defined methods and once for &lt;code&gt;AUTOLOAD&lt;/code&gt; . However, Perl lets you configure this with &lt;code&gt;mro&lt;/code&gt; .</source>
          <target state="translated">Perlが &lt;code&gt;@INC&lt;/code&gt; を通過するパス。デフォルトでは、これは2度の深さ優先検索であり、1回は定義されたメソッドを探し、もう1回は &lt;code&gt;AUTOLOAD&lt;/code&gt; を探します。ただし、Perlではこれを &lt;code&gt;mro&lt;/code&gt; で構成できます。</target>
        </trans-unit>
        <trans-unit id="bfd87cb3c63ce818c0482394b6803650584202ed" translate="yes" xml:space="preserve">
          <source>The path Perl takes through &lt;code&gt;@INC&lt;/code&gt;. By default, this is a double depth first search, once looking for defined methods and once for &lt;code&gt;AUTOLOAD&lt;/code&gt;. However, Perl lets you configure this with &lt;code&gt;mro&lt;/code&gt;.</source>
          <target state="translated">Perlが &lt;code&gt;@INC&lt;/code&gt; を通過するパス。デフォルトでは、これは2倍の深さ優先探索であり、1回は定義済みのメソッドを検索し、もう1回は &lt;code&gt;AUTOLOAD&lt;/code&gt; を検索します。ただし、Perlでは &lt;code&gt;mro&lt;/code&gt; を使用してこれを構成できます。</target>
        </trans-unit>
        <trans-unit id="97b7ffc6783961615c324915aaa3803b45441d58" translate="yes" xml:space="preserve">
          <source>The path from the uri, will be at least a single '/'.</source>
          <target state="translated">uriからのパスは、少なくとも1つの'/'になります。</target>
        </trans-unit>
        <trans-unit id="935a26d686af6b04ea7fea8358669d0caebc7249" translate="yes" xml:space="preserve">
          <source>The path of the file from which the history (assuming a usable Term::ReadLine backend) will be read on the debugger's startup, and to which it will be saved on shutdown (for persistence across sessions). Similar in concept to Bash's &lt;code&gt;.bash_history&lt;/code&gt; file.</source>
          <target state="translated">デバッガーの起動時に履歴（使用可能なTerm :: ReadLineバックエンドを想定）が読み込まれ、シャットダウン時に保存される（セッション間での永続化のため）ファイルのパス。概念はBashの &lt;code&gt;.bash_history&lt;/code&gt; ファイルに似ています。</target>
        </trans-unit>
        <trans-unit id="b7867a311910479846a23412feb4307a4674c491" translate="yes" xml:space="preserve">
          <source>The path to the &lt;code&gt;git&lt;/code&gt; binary to use for the Git features. The default is &lt;code&gt;/usr/local/bin/git&lt;/code&gt;.</source>
          <target state="translated">Git機能に使用する &lt;code&gt;git&lt;/code&gt; バイナリへのパス。デフォルトは &lt;code&gt;/usr/local/bin/git&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="3f73d1d0634237caab821e6e9c8fad9914a18a73" translate="yes" xml:space="preserve">
          <source>The path to the file is automatically converted to a Unix like equivalent for use in the archive, and, if on MacOS, the file's modification time is converted from the MacOS epoch to the Unix epoch. So tar archives created on MacOS with &lt;b&gt;Archive::Tar&lt;/b&gt; can be read both with</source>
          <target state="translated">ファイルへのパスは、アーカイブで使用するための同等のUnixに自動的に変換されます。MacOSの場合、ファイルの変更時刻はMacOSエポックからUnixエポックに変換されます。したがって、MacOSで&lt;b&gt;Archive :: Tarを&lt;/b&gt;使用して作成されたtarアーカイブは、</target>
        </trans-unit>
        <trans-unit id="2ab24d7b050cb5882eec74eec0cbc6ea2a2768dd" translate="yes" xml:space="preserve">
          <source>The pathname of a POD file to syntax-check (defaults to standard input).</source>
          <target state="translated">構文チェックを行うPODファイルのパス名(デフォルトは標準入力)。</target>
        </trans-unit>
        <trans-unit id="3091661abc10e8b933048a63287800c8286b8cec" translate="yes" xml:space="preserve">
          <source>The pathname of a file containing pod documentation to be output in usage message format (defaults to standard input).</source>
          <target state="translated">使用法メッセージ形式で出力されるポッドドキュメントを含むファイルのパス名(デフォルトは標準入力)。</target>
        </trans-unit>
        <trans-unit id="5506a685c5fca482706d4108f11645e50bb17fd9" translate="yes" xml:space="preserve">
          <source>The pathname of a file from which to select sections of pod documentation (defaults to standard input).</source>
          <target state="translated">ポッド文書のセクションを選択するためのファイルのパス名(デフォルトは標準入力)。</target>
        </trans-unit>
        <trans-unit id="64067e36292a9c79bf92f0c4d392216daafe926d" translate="yes" xml:space="preserve">
          <source>The pattern begins with a class matching a subset of letters. Whenever this matches, a statement like &lt;code&gt;$count{'a'}++;&lt;/code&gt; is executed, incrementing the letter's counter. Then &lt;code&gt;(*FAIL)&lt;/code&gt; does what it says, and the regexp engine proceeds according to the book: as long as the end of the string hasn't been reached, the position is advanced before looking for another vowel. Thus, match or no match makes no difference, and the regexp engine proceeds until the entire string has been inspected. (It's remarkable that an alternative solution using something like</source>
          <target state="translated">パターンは、文字のサブセットに一致するクラスで始まります。これが一致するときはいつでも、 &lt;code&gt;$count{'a'}++;&lt;/code&gt; ようなステートメント。文字のカウンターをインクリメントして実行されます。次に &lt;code&gt;(*FAIL)&lt;/code&gt; はそれが言うことを実行し、正規表現エンジンは本に従って進みます。文字列の終わりに達していない限り、別の母音を探す前に位置が進められます。したがって、一致するか一致しないかの違いはありません。正規表現エンジンは、文字列全体が検査されるまで続行します。 （のようなものを使用した代替ソリューションが注目に値する</target>
        </trans-unit>
        <trans-unit id="a027102deb051cbffb2428b7b7a47e74a500b189" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;a href=&quot;#defined-EXPR&quot;&gt;&lt;code&gt;defined&lt;/code&gt;&lt;/a&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">「何も」一致しなかったものの、パターン一致は成功し、 &lt;code&gt;$1&lt;/code&gt; が定義されます。それは実際には何にも一致しませんでした。むしろ、たまたまゼロ文字の長さだったものと一致していました。これはすべて非常に上層部で正直です。関数が未定義の値を返す場合、それはあなたに正直な答えを与えることができなかったことを認めています。したがって、&lt;a href=&quot;#defined-EXPR&quot;&gt; &lt;code&gt;defined&lt;/code&gt; &lt;/a&gt;を使用するのは、実行しようとしていることの整合性を疑問視する場合のみにしてください。それ以外の場合は、 &lt;code&gt;0&lt;/code&gt; または &lt;code&gt;&quot;&quot;&lt;/code&gt; との単純な比較が必要です。</target>
        </trans-unit>
        <trans-unit id="194b10f85ac928e670426276285fc77367b6bf3e" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">パターンマッチングは成功し、 &lt;code&gt;$1&lt;/code&gt; が定義されていますが、「何も」にはマッチしませんでした。何にもマッチしなかったわけではありません。むしろ、たまたまゼロ文字である何かと一致しました。これはすべて非常に上で正直です。関数が未定義の値を返すとき、それはあなたに正直な答えを与えることができなかったことを認めています。したがって、あなたがしようとしていることの完全性を問う場合にのみ、 &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; を使用する必要があります。それ以外の場合は、 &lt;code&gt;0&lt;/code&gt; または &lt;code&gt;&quot;&quot;&lt;/code&gt; との単純な比較で十分です。</target>
        </trans-unit>
        <trans-unit id="6ccde9606e998bb56b83482fdb0ce2d1cd2b87e5" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">パターンマッチングは成功し、 &lt;code&gt;$1&lt;/code&gt; が定義されていますが、「何も」にはマッチしませんでした。何にもマッチしなかったわけではありません。むしろ、たまたまゼロ文字である何かと一致しました。これはすべて非常に上で正直です。関数が未定義の値を返すとき、それはあなたに正直な答えを与えることができなかったことを認めています。したがって、あなたがしようとしていることの完全性を問う場合にのみ、 &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; を使用する必要があります。それ以外の場合は、 &lt;code&gt;0&lt;/code&gt; または &lt;code&gt;&quot;&quot;&lt;/code&gt; との単純な比較で十分です。</target>
        </trans-unit>
        <trans-unit id="00e74cbb0f8570bc720cdf9f1dc73c5533c198b5" translate="yes" xml:space="preserve">
          <source>The pattern matching metacharacters &quot;(&quot;, &quot;)&quot;, and &quot;|&quot; do not have backslashes in front.</source>
          <target state="translated">パターンに一致するメタキャラクタ「(&quot;,,&quot;)」「|」は、前にバックスラッシュがありません。</target>
        </trans-unit>
        <trans-unit id="8647f015f186197cabe9c1508a8d5b1dddf875e9" translate="yes" xml:space="preserve">
          <source>The pattern matching operations &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) when used without an &lt;code&gt;=~&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;=~&lt;/code&gt; 演算子なしで使用した場合のパターンマッチング操作 &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; および &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; （別名 &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="86784bd21e39089878c5197cae9b26fe435b4866" translate="yes" xml:space="preserve">
          <source>The pattern matching operations &lt;code&gt;m//&lt;/code&gt;, &lt;code&gt;s///&lt;/code&gt; and &lt;code&gt;tr///&lt;/code&gt; (aka &lt;code&gt;y///&lt;/code&gt;) when used without an &lt;code&gt;=~&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;=~&lt;/code&gt; 演算子なしで使用した場合のパターンマッチング操作 &lt;code&gt;m//&lt;/code&gt; 、 &lt;code&gt;s///&lt;/code&gt; および &lt;code&gt;tr///&lt;/code&gt; （別名 &lt;code&gt;y///&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="216352b3a9f025091614aa329a166fdb30a18a8e" translate="yes" xml:space="preserve">
          <source>The pattern modifiers:</source>
          <target state="translated">パターン修飾子です。</target>
        </trans-unit>
        <trans-unit id="a2c1a780666383b49402abd005e8fafffcab62b8" translate="yes" xml:space="preserve">
          <source>The pattern of macro calls is like this:</source>
          <target state="translated">マクロを呼び出すパターンはこんな感じです。</target>
        </trans-unit>
        <trans-unit id="3569af6a782c9884f9c5e89ba969f12fe42cf2da" translate="yes" xml:space="preserve">
          <source>The pattern really,</source>
          <target state="translated">本当にこのパターン。</target>
        </trans-unit>
        <trans-unit id="f373f7a0e4daf869b86fcbb5c4b5b4f2ee465c22" translate="yes" xml:space="preserve">
          <source>The pattern will be used as a Perl regular expression (as opposed to a simple grep regex).</source>
          <target state="translated">このパターンは Perl の正規表現として使用されます (単純な grep 正規表現とは異なります)。</target>
        </trans-unit>
        <trans-unit id="8a46001019582eae5c4e5728c4a3fb31cd3dbf38" translate="yes" xml:space="preserve">
          <source>The patterns used in Perl pattern matching evolved from those supplied in the Version 8 regex routines. (The routines are derived (distantly) from Henry Spencer's freely redistributable reimplementation of the V8 routines.) See &lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt;Version 8 Regular Expressions&lt;/a&gt; for details.</source>
          <target state="translated">Perlパターンマッチングで使用されるパターンは、バージョン8のregexルーチンで提供されるパターンから発展したものです。（これらのルーチンは、V8ルーチンのHenry Spencerの自由に再配布可能な再実装から（離れて）派生しています。）詳細については、&lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt;バージョン8の正規表現&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e790c64d043de1336b86cfb89ee718b54cb057cd" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3A-peephole-optimization&quot;&gt;&quot;Compile pass 3: peephole optimization&quot; in perlguts&lt;/a&gt;. If the new code wishes to operate on ops throughout the subroutine's structure, rather than just at the top level, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_rpeepp&quot;&gt;&quot;PL_rpeepp&quot;&lt;/a&gt; hook.</source>
          <target state="translated">のぞき穴オプティマイザーを完全に交換しないでください。むしろ、既存のオプティマイザーをラップしてコードを追加します。これを行う基本的な方法は&lt;a href=&quot;perlguts#Compile-pass-3%3A-peephole-optimization&quot;&gt;、perlgutsの「Compilepass 3：peepholeoptimization」にあり&lt;/a&gt;ます。新しいコードが、最上位レベルだけでなく、サブルーチンの構造全体でopsを操作したい場合は、&lt;a href=&quot;#PL_rpeepp&quot;&gt;「PL_rpeepp」&lt;/a&gt;フックをラップする方が便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="8569c5379da2f4cde343faebf02e081c76fc9c06" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3A-peephole-optimization&quot;&gt;&quot;Compile pass 3: peephole optimization&quot; in perlguts&lt;/a&gt;. If the new code wishes to operate only on ops at a subroutine's top level, rather than throughout the structure, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_peepp&quot;&gt;&quot;PL_peepp&quot;&lt;/a&gt; hook.</source>
          <target state="translated">のぞき穴オプティマイザーを完全に交換しないでください。むしろ、既存のオプティマイザーをラップしてコードを追加します。これを行う基本的な方法は&lt;a href=&quot;perlguts#Compile-pass-3%3A-peephole-optimization&quot;&gt;、perlgutsの「Compilepass 3：peepholeoptimization」にあり&lt;/a&gt;ます。新しいコードが、構造全体ではなく、サブルーチンのトップレベルのopsでのみ動作することを望む場合は、&lt;a href=&quot;#PL_peepp&quot;&gt;「PL_peepp」&lt;/a&gt;フックをラップする方が便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="dac0ad9b1d3df00129661ed1e95ffc2c13f0c968" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate on ops throughout the subroutine's structure, rather than just at the top level, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_rpeepp&quot;&gt;PL_rpeepp&lt;/a&gt; hook.</source>
          <target state="translated">のぞき穴オプティマイザを完全に置き換えることはできません。むしろ、既存のオプティマイザをラップしてコードを追加します。これを行う基本的な方法は、「&lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;コンパイルパス3：perlgutsでののぞき穴の最適化」にあり&lt;/a&gt;ます。新しいコードが、最上位だけでなく、サブルーチンの構造全体でopsを操作する場合は、&lt;a href=&quot;#PL_rpeepp&quot;&gt;PL_rpeepp&lt;/a&gt;フックをラップする方が便利です。</target>
        </trans-unit>
        <trans-unit id="db43041726026c591925cfc25e5688f00dc4bbac" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate only on ops at a subroutine's top level, rather than throughout the structure, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_peepp&quot;&gt;PL_peepp&lt;/a&gt; hook.</source>
          <target state="translated">のぞき穴オプティマイザを完全に置き換えることはできません。むしろ、既存のオプティマイザをラップしてコードを追加します。これを行う基本的な方法は、「&lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;コンパイルパス3：perlgutsでののぞき穴の最適化」にあり&lt;/a&gt;ます。新しいコードで、構造全体ではなく、サブルーチンの最上位レベルのopsのみを操作する場合は、&lt;a href=&quot;#PL_peepp&quot;&gt;PL_peepp&lt;/a&gt;フックをラップする方が便利です。</target>
        </trans-unit>
        <trans-unit id="ace3f1e6483238aa81eb601036e5dcd7d2b38b3a" translate="yes" xml:space="preserve">
          <source>The per-instance data are held in memory beyond the basic PerlIOl struct, by making a PerlIOl the first member of the layer's struct thus:</source>
          <target state="translated">このように、PerlIOlをレイヤの構造体の最初のメンバにすることで、基本的なPerlIOl構造体を超えてインスタンスあたりのデータがメモリに保持されます。</target>
        </trans-unit>
        <trans-unit id="467fb902a44226db21d27e75dc641b031d86cd72" translate="yes" xml:space="preserve">
          <source>The per-instance data for a particular handle.</source>
          <target state="translated">特定のハンドルのインスタンスごとのデータ。</target>
        </trans-unit>
        <trans-unit id="85e58f1f52dd9a0e84852e44b90f48bbed040fce" translate="yes" xml:space="preserve">
          <source>The per-record overhead will limit the maximum number of records you can access per file. Note that</source>
          <target state="translated">レコードごとのオーバーヘッドにより、ファイルごとにアクセスできるレコードの最大数が制限されます。以下のことに注意してください。</target>
        </trans-unit>
        <trans-unit id="874d7f7aa12fc5ea3bd61b16d41289fe642a630c" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot;</source>
          <target state="translated">ピリオド'.'は、&quot;\n &quot;以外の文字にマッチします。</target>
        </trans-unit>
        <trans-unit id="e038fd297e6c1d463ecc98d5fcaacd0e4180bccd" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot; (unless the modifier &lt;code&gt;//s&lt;/code&gt; is in effect, as explained below).</source>
          <target state="translated">期間 '。' 「\ n」以外の任意の文字に一致します（以下で説明するように、修飾子 &lt;code&gt;//s&lt;/code&gt; が有効でない限り）。</target>
        </trans-unit>
        <trans-unit id="bc11993ee6fae379fe2dbc40f494f74a38651177" translate="yes" xml:space="preserve">
          <source>The period &lt;code&gt;'.'&lt;/code&gt; matches any character but &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (unless the modifier &lt;code&gt;/s&lt;/code&gt; is in effect, as explained below).</source>
          <target state="translated">ピリオド &lt;code&gt;'.'&lt;/code&gt; &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 以外の任意の文字に一致します（以下で説明するように、修飾子 &lt;code&gt;/s&lt;/code&gt; が有効になっていない場合）。</target>
        </trans-unit>
        <trans-unit id="50625043a5bdab5548c251e25233bc0e03a34159" translate="yes" xml:space="preserve">
          <source>The perl code in PerlIO.pm then attempts to locate a layer by doing</source>
          <target state="translated">PerlIO.pm の perl コードは、次のようにしてレイヤーを見つけようとします。</target>
        </trans-unit>
        <trans-unit id="634e60cc8e248b9b7ce51ac444bfec05dc82ef31" translate="yes" xml:space="preserve">
          <source>The perl command to use is determined by &lt;a href=&quot;#get_perl&quot;&gt;&quot;get_perl&quot;&lt;/a&gt;. The command generated is guaranteed to preserve:</source>
          <target state="translated">使用するperlコマンドは、&lt;a href=&quot;#get_perl&quot;&gt;「get_perl」&lt;/a&gt;によって決定されます。生成されたコマンドは、以下を保持することが保証されています。</target>
        </trans-unit>
        <trans-unit id="16b7e5af7739f86fd0e9e79d11ca97ac5649e9b1" translate="yes" xml:space="preserve">
          <source>The perl core wraps &lt;code&gt;setjmp()&lt;/code&gt; etc in the macros &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and &lt;code&gt;JMPENV_JUMP&lt;/code&gt; . The basic rule of perl exceptions is that &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (in the absence of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;) perform a &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; , while &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; within &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; .</source>
          <target state="translated">perlコアはマクロ &lt;code&gt;JMPENV_PUSH&lt;/code&gt; および &lt;code&gt;JMPENV_JUMP&lt;/code&gt; で &lt;code&gt;setjmp()&lt;/code&gt; などをラップします。Perlの例外の基本的なルールは、であり &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; 、及び &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; （の非存在下で &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ）を行う &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; が、 &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; 内の &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; はない &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6c71858536e734e97d2970ba2f758d971d8a580" translate="yes" xml:space="preserve">
          <source>The perl core wraps &lt;code&gt;setjmp()&lt;/code&gt; etc in the macros &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and &lt;code&gt;JMPENV_JUMP&lt;/code&gt;. The basic rule of perl exceptions is that &lt;code&gt;exit&lt;/code&gt;, and &lt;code&gt;die&lt;/code&gt; (in the absence of &lt;code&gt;eval&lt;/code&gt;) perform a &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt;, while &lt;code&gt;die&lt;/code&gt; within &lt;code&gt;eval&lt;/code&gt; does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt;.</source>
          <target state="translated">perlコアは、マクロ &lt;code&gt;JMPENV_PUSH&lt;/code&gt; および &lt;code&gt;JMPENV_JUMP&lt;/code&gt; で &lt;code&gt;setjmp()&lt;/code&gt; などをラップします。Perlの例外の基本的なルールは、であり &lt;code&gt;exit&lt;/code&gt; 、及び &lt;code&gt;die&lt;/code&gt; （の非存在下で &lt;code&gt;eval&lt;/code&gt; ）を行う &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; が、 &lt;code&gt;die&lt;/code&gt; 内の &lt;code&gt;eval&lt;/code&gt; はない &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fdbc7e5dc74277662b153d8f95c93e631321b8b" translate="yes" xml:space="preserve">
          <source>The perl equivalent is &lt;code&gt;$sv = undef;&lt;/code&gt;. Note that it doesn't free any string buffer, unlike &lt;code&gt;undef $sv&lt;/code&gt;.</source>
          <target state="translated">同等のperlは &lt;code&gt;$sv = undef;&lt;/code&gt; 。 &lt;code&gt;undef $sv&lt;/code&gt; とは異なり、文字列バッファを解放しないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="6c474186075797ee40452934f04a51f573b827bb" translate="yes" xml:space="preserve">
          <source>The perl executable is obtained by linking</source>
          <target state="translated">perl実行ファイルは</target>
        </trans-unit>
        <trans-unit id="1d8ff0cddfb59dc7ae9ad6feb4a5e65da142f6d6" translate="yes" xml:space="preserve">
          <source>The perl history contains one mistake which was not caught in the conversion: a merge was recorded in the history between blead and maint-5.10 where no merge actually occurred. Due to the nature of git, this is now impossible to fix in the public repository. You can remove this mis-merge locally by adding the following line to your &lt;code&gt;.git/info/grafts&lt;/code&gt; file:</source>
          <target state="translated">Perlの履歴には、変換で検出されなかった1つの間違いが含まれています。マージは、実際にはマージが発生しなかったbleadとmaint-5.10の間の履歴に記録されました。 gitの性質上、これをパブリックリポジトリで修正することは現在不可能です。この誤ったマージは、 &lt;code&gt;.git/info/grafts&lt;/code&gt; ファイルに次の行を追加することでローカルで削除できます。</target>
        </trans-unit>
        <trans-unit id="06ded168a76972d517d9136275d2690412f2929f" translate="yes" xml:space="preserve">
          <source>The perl message comes out with &quot;Perl&quot; in front. The &lt;code&gt;BEGIN&lt;/code&gt; block works at compile time so all of the compilation errors and warnings get the &quot;Perl:&quot; prefix too.</source>
          <target state="translated">perlメッセージの前に「Perl」が付いています。 &lt;code&gt;BEGIN&lt;/code&gt; コンパイルエラーと警告のすべてを取得するので、コンパイル時にブロックの動作を「Perlを：」プレフィックスを過ぎます。</target>
        </trans-unit>
        <trans-unit id="b63df2b573a7b7008051f6d3411e1d7de7dd31b6" translate="yes" xml:space="preserve">
          <source>The perl source is in a git repository. You can clone the repository with the following command:</source>
          <target state="translated">perlのソースはgitリポジトリにあります。以下のコマンドでリポジトリをクローンすることができます。</target>
        </trans-unit>
        <trans-unit id="c5f10541bc3ed7ff03899b584c515233e642fba7" translate="yes" xml:space="preserve">
          <source>The perl tie function associates a variable with an object that implements the various GET, SET, etc methods. To perform the equivalent of the perl tie function from an XSUB, you must mimic this behaviour. The code below carries out the necessary steps -- firstly it creates a new hash, and then creates a second hash which it blesses into the class which will implement the tie methods. Lastly it ties the two hashes together, and returns a reference to the new tied hash. Note that the code below does NOT call the TIEHASH method in the MyTie class - see &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;&quot;Calling Perl Routines from within C Programs&quot;&lt;/a&gt; for details on how to do this.</source>
          <target state="translated">perl tie関数は、さまざまなGET、SETなどのメソッドを実装するオブジェクトに変数を関連付けます。XSUBからperltie関数と同等の機能を実行するには、この動作を模倣する必要があります。以下のコードは、必要な手順を実行します。最初に新しいハッシュを作成し、次にtieメソッドを実装するクラスに祝福する2番目のハッシュを作成します。最後に、2つのハッシュを結び付け、新しい結び付けられたハッシュへの参照を返します。以下のコードは、MyTieクラスのTIEHASHメソッドを呼び出さないことに注意してください。これを行う方法の詳細については、&lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;「Cプログラム内からのPerlルーチンの呼び出し」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="327d340c9d37adf78ea3fa44d3b1c6e9e8b77c71" translate="yes" xml:space="preserve">
          <source>The perl tie function associates a variable with an object that implements the various GET, SET, etc methods. To perform the equivalent of the perl tie function from an XSUB, you must mimic this behaviour. The code below carries out the necessary steps -- firstly it creates a new hash, and then creates a second hash which it blesses into the class which will implement the tie methods. Lastly it ties the two hashes together, and returns a reference to the new tied hash. Note that the code below does NOT call the TIEHASH method in the MyTie class - see &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;Calling Perl Routines from within C Programs&lt;/a&gt; for details on how to do this.</source>
          <target state="translated">perl tie関数は、さまざまなGET、SETなどのメソッドを実装するオブジェクトに変数を関連付けます。XSUBから同等のperl tie関数を実行するには、この動作を模倣する必要があります。以下のコードは必要なステップを実行します。最初に新しいハッシュを作成し、次に、tieメソッドを実装するクラスにblessする2番目のハッシュを作成します。最後に、2つのハッシュを結合し、結合された新しいハッシュへの参照を返します。以下のコードはMyTieクラスのTIEHASHメソッドを呼び出さないことに注意してください。これを行う方法の詳細については、&lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;Cプログラム内からのPerlルーチンの呼び出し&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="123c31a7a632081aa07f5ab58c14ca27dc4643f2" translate="yes" xml:space="preserve">
          <source>The perl visible name of the XS subroutine generated which will return the constants. The default is &lt;code&gt;constant&lt;/code&gt; .</source>
          <target state="translated">定数を返す、生成されたXSサブルーチンのperl表示名。デフォルトは &lt;code&gt;constant&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="be6633f7068d6499b516b1dff2ff6cfb89ba5f0c" translate="yes" xml:space="preserve">
          <source>The perl visible name of the XS subroutine generated which will return the constants. The default is &lt;code&gt;constant&lt;/code&gt;.</source>
          <target state="translated">定数を返す、生成されたXSサブルーチンのperl可視名。デフォルトは &lt;code&gt;constant&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="87baa838c319b67b0a259076dbfb27270de34c58" translate="yes" xml:space="preserve">
          <source>The perl-mvs@perl.org list is for discussion of porting issues as well as general usage issues for all EBCDIC Perls. Send a message body of &quot;subscribe perl-mvs&quot; to majordomo@perl.org.</source>
          <target state="translated">perl-mvs@perl.org リストは、すべての EBCDIC Perls の移植問題や一般的な使用法の問題について議論するためのものです。subscribe perl-mvs&quot; のメッセージ本文を majordomo@perl.org に送ってください。</target>
        </trans-unit>
        <trans-unit id="5ba3dea55a126a532be4f9eaeca0422de96d0827" translate="yes" xml:space="preserve">
          <source>The perl5-changes mailing list receives a copy of each patch that gets submitted to the maintenance and development branches of the perl repository. See &lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;http://lists.perl.org/list/perl5-changes.html&lt;/a&gt; for subscription and archive information.</source>
          <target state="translated">perl5-changesメーリングリストは、perlリポジトリのメンテナンスおよび開発ブランチに送信される各パッチのコピーを受け取ります。サブスクリプションおよびアーカイブ情報については、&lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;http：//lists.perl.org/list/perl5-changes.html&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="7ba06e1bf85435dc89a1bc7a3e1228003027ef95" translate="yes" xml:space="preserve">
          <source>The perl5-changes mailing list receives a copy of each patch that gets submitted to the maintenance and development branches of the perl repository. See &lt;a href=&quot;https://lists.perl.org/list/perl5-changes.html&quot;&gt;https://lists.perl.org/list/perl5-changes.html&lt;/a&gt; for subscription and archive information.</source>
          <target state="translated">perl5-changesメーリングリストは、perlリポジトリの保守および開発ブランチに送信される各パッチのコピーを受け取ります。サブスクリプションおよびアーカイブ情報については、&lt;a href=&quot;https://lists.perl.org/list/perl5-changes.html&quot;&gt;https：//lists.perl.org/list/perl5-changes.html&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="9c029dc7e52d0d0d6369cc3ff0e62686a113c165" translate="yes" xml:space="preserve">
          <source>The perl5-porters (p5p) mailing list is where the Perl standard distribution is maintained and developed. The people who maintain Perl are also referred to as the &quot;Perl 5 Porters&quot;, &quot;p5p&quot; or just the &quot;porters&quot;.</source>
          <target state="translated">perl5-porters (p5p)メーリングリストは、Perl標準配布物のメンテナンスと開発を行っています。Perlを管理している人たちは、&quot;Perl 5 Porters&quot;、&quot;p5p&quot;、または単に &quot;porters &quot;とも呼ばれています。</target>
        </trans-unit>
        <trans-unit id="3a8b72ced5fe1018b53d36c163e0f112a1621d18" translate="yes" xml:space="preserve">
          <source>The perlXYZ.sis includes only the Perl DLL: to create an additional SIS file which includes some of the standard (pure) Perl libraries, issue the command</source>
          <target state="translated">perlXYZ.sisにはPerl DLLのみが含まれています。標準の(純粋な)Perlライブラリを含む追加のSISファイルを作成するには、以下のコマンドを実行してください。</target>
        </trans-unit>
        <trans-unit id="8239507ba48e88fe2cac6b5f08faa6b68602a3e2" translate="yes" xml:space="preserve">
          <source>The perlapp.sis (11 kB -&amp;gt; 16 kB) will be built in the symbian subdirectory, but a copy will also be made to the main directory.</source>
          <target state="translated">perlapp.sis（11 kB-&amp;gt; 16 kB）はsymbianサブディレクトリに作成されますが、メインディレクトリにもコピーが作成されます。</target>
        </trans-unit>
        <trans-unit id="55339a112f571a65cc173aaae9b60118d4926fb7" translate="yes" xml:space="preserve">
          <source>The perlbug program will ask you a few questions about your email address and the patch you're submitting. Once you've answered them it will submit your patch via email.</source>
          <target state="translated">perlbug プログラムは、あなたのメールアドレスと提出するパッチについていくつかの質問をします。これらの質問に答えると、メールでパッチを提出します。</target>
        </trans-unit>
        <trans-unit id="a319a07f2540ad16252f1fe55565bcf46c56c4bb" translate="yes" xml:space="preserve">
          <source>The perldoc for utime also has an example that has the same effect as touch(1) on files that</source>
          <target state="translated">utime 用の perldoc にも、touch(1)と同じ効果を持つ例があります。</target>
        </trans-unit>
        <trans-unit id="ed575d398752b423e73c91acec2e13e6122dc7e1" translate="yes" xml:space="preserve">
          <source>The perlfaq comprises several documents that answer the most commonly asked questions about Perl and Perl programming. It's divided by topic into nine major sections outlined in this document.</source>
          <target state="translated">perlfaqは、PerlとPerlプログラミングに関する最も一般的な質問に答えるいくつかのドキュメントで構成されています。このドキュメントでは、トピックごとに9つの主要なセクションに分けられています。</target>
        </trans-unit>
        <trans-unit id="bf571460e6819407bba20acb1eb1771f32d393cd" translate="yes" xml:space="preserve">
          <source>The perlfaq is an evolving document. Read the latest version at &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;. It is also included in the standard Perl distribution.</source>
          <target state="translated">perlfaqは進化するドキュメントです。&lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/で&lt;/a&gt;最新バージョンをお読みください。また、標準のPerlディストリビューションにも含まれています。</target>
        </trans-unit>
        <trans-unit id="d8ba3c9bbcf37ca492d8ac656f9c49509454f36e" translate="yes" xml:space="preserve">
          <source>The perlpod spec for a Verbatim paragraph is &quot;It should be reproduced exactly...&quot;, which means that the whitespace you've used to indent your verbatim blocks will be preserved in the output. This can be annoying for outputs such as HTML, where that whitespace will remain in front of every line. It's an unfortunate case where syntax is turned into semantics.</source>
          <target state="translated">Verbatim段落のperlpodの仕様は「正確に再現されるべきである...」というもので、これは、Verbatimブロックのインデントに使用した空白が出力に保存されることを意味します。これは、HTML のような出力では、ホワイトスペースがすべての行の前に残ってしまうので、イライラすることがあります。これは、構文が意味論になってしまう不幸なケースです。</target>
        </trans-unit>
        <trans-unit id="d320cdc510ba6fe180a797e4852d051df0ce9e8c" translate="yes" xml:space="preserve">
          <source>The perlstyle manual supplied with Perl has many helpful points.</source>
          <target state="translated">Perlに付属のperlstyleのマニュアルには参考になる点がたくさんあります。</target>
        </trans-unit>
        <trans-unit id="f61630dfa6a2b75f5a9ee952e22583e2bdae4aef" translate="yes" xml:space="preserve">
          <source>The person whom the &lt;b&gt;operating system&lt;/b&gt; will let do almost anything. Typically your system administrator or someone pretending to be your system administrator. On Unix systems, the &lt;b&gt;root&lt;/b&gt; user. On Windows systems, usually the Administrator user.</source>
          <target state="translated">人&lt;b&gt;のオペレーティングシステムは、&lt;/b&gt;ほとんど何でもできるようになります。通常、システム管理者またはシステム管理者になりすました人物。Unixシステムでは、&lt;b&gt;root&lt;/b&gt;ユーザー。Windowsシステムでは、通常は管理者ユーザー。</target>
        </trans-unit>
        <trans-unit id="4a687dacf6873e351f87d30c48226233e28a0761" translate="yes" xml:space="preserve">
          <source>The pinyin ordering includes some characters that are not CJK Unified Ideographs and can't utilize &lt;code&gt;weightPinyin()&lt;/code&gt; for collation. For them, use &lt;code&gt;entry&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;weightPinyin()&lt;/code&gt; 順序には、CJK統合漢字ではなく、照合にweightPinyin（）を使用できない文字が含まれています。それらについては、代わりに &lt;code&gt;entry&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="674e8f557a9263711bdd1bff3bb098f69b9e9b84" translate="yes" xml:space="preserve">
          <source>The pipeline model divides up a task into a series of steps, and passes the results of one step on to the thread processing the next. Each thread does one thing to each piece of data and passes the results to the next thread in line.</source>
          <target state="translated">パイプラインモデルは、タスクを一連のステップに分割し、1つのステップの結果を次の処理を行うスレッドに渡します。各スレッドはそれぞれのデータに対して一つの処理を行い、その結果を次のスレッドに渡します。</target>
        </trans-unit>
        <trans-unit id="e5963c8e8de82f4449d7ed9e1e51afdf5f459ee1" translate="yes" xml:space="preserve">
          <source>The pl2pm utility will get you started.</source>
          <target state="translated">pl2pmユーティリティを使えば、すぐに始められます。</target>
        </trans-unit>
        <trans-unit id="1d36c8a340c756f47102c1832b54cb16f13c0c7c" translate="yes" xml:space="preserve">
          <source>The plan (for example, '1..5'), must only come at the beginning or end of the TAP output.</source>
          <target state="translated">プラン(例えば、'1..5')は、TAP出力の最初か最後にのみ来なければなりません。</target>
        </trans-unit>
        <trans-unit id="b8f929ee511ca422d9eb63d2f4f5d86c27217779" translate="yes" xml:space="preserve">
          <source>The plan event for the subtest</source>
          <target state="translated">サブテストのプランイベント</target>
        </trans-unit>
        <trans-unit id="4326b3bc4ca816f9708e08eacb7250e5b64a4e86" translate="yes" xml:space="preserve">
          <source>The plugin system in the CPAN shell was introduced in version 2.07 and is still considered experimental.</source>
          <target state="translated">CPANシェルのプラグインシステムはバージョン2.07で導入され、まだ実験的なものと考えられています。</target>
        </trans-unit>
        <trans-unit id="b09a69221209bb270cc3034edeb1fb83d92c2242" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; function so that &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;a href=&quot;#srand-EXPR&quot;&gt;&lt;code&gt;srand&lt;/code&gt;&lt;/a&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">この関数のポイントは、&lt;a href=&quot;#rand-EXPR&quot;&gt; &lt;code&gt;rand&lt;/code&gt; &lt;/a&gt;関数を「シード」して、プログラムを実行するたびに&lt;a href=&quot;#rand-EXPR&quot;&gt; &lt;code&gt;rand&lt;/code&gt; &lt;/a&gt;が異なるシーケンスを生成できるようにすることです。パラメータを指定して呼び出されると、&lt;a href=&quot;#srand-EXPR&quot;&gt; &lt;code&gt;srand&lt;/code&gt; &lt;/a&gt;はそれをシードに使用します。それ以外の場合は、（半）ランダムにシードを選択します。いずれの場合も、Perl 5.14以降、シードを返します。コードが機能することを通知するには</target>
        </trans-unit>
        <trans-unit id="4fc2d017a3ab4b5deac17556464426823c475059" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">この関数のポイントは、 &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 関数を「シード」して、プログラムを実行するたびに &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; が異なるシーケンスを生成できるようにすることです。 &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; はパラメーターを指定して呼び出されると、それをシードに使用します。それ以外の場合は、（半）ランダムにシードを選択します。どちらの場合も、Perl 5.14以降、シードを返します。コードが機能することを通知するには</target>
        </trans-unit>
        <trans-unit id="2e1f3e31ba6a1b36a8c681657ab8caf017949b14" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">この関数のポイントは、 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; 関数を「シード」して、プログラムを実行するたびに &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; が異なるシーケンスを生成できるようにすることです。 &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; はパラメーターを指定して呼び出されると、それをシードに使用します。それ以外の場合は、（半）ランダムにシードを選択します。どちらの場合も、Perl 5.14以降、シードを返します。コードが機能することを通知するには</target>
        </trans-unit>
        <trans-unit id="d8e49cca1375307d0cbb7648d543980bc0807cf4" translate="yes" xml:space="preserve">
          <source>The pointer is blessed into a class that is derived from the name of type of the pointer but with all '*' in the name replaced with 'Ptr'.</source>
          <target state="translated">ポインタは、ポインタの型名から派生したクラスに祝福されますが、名前の中のすべての'*'が'Ptr'に置き換えられています。</target>
        </trans-unit>
        <trans-unit id="549bcd1d7ae81c0474487c42c591f283db8f5fed" translate="yes" xml:space="preserve">
          <source>The pointer to the PV of the &lt;code&gt;dsv&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;dsv&lt;/code&gt; のPVへのポインターが返されます。</target>
        </trans-unit>
        <trans-unit id="7ab31953e34eba90fc36ab51df0189b64f65aae0" translate="yes" xml:space="preserve">
          <source>The points to note are</source>
          <target state="translated">注意点は</target>
        </trans-unit>
        <trans-unit id="c1fdc510fd28f743532d0f8810f2c036e2bf9b84" translate="yes" xml:space="preserve">
          <source>The polar notation (also known as the trigonometric representation) is much more handy for performing multiplications and divisions of complex numbers, whilst the cartesian notation is better suited for additions and subtractions. Real numbers are on the</source>
          <target state="translated">極表記(三角法表現としても知られています)は複素数の乗算や除算を行うのに便利ですが、直交表記は足し算や引き算に適しています。実数は</target>
        </trans-unit>
        <trans-unit id="b5ec1158a1165100647b29065f9f5443b0e8eb69" translate="yes" xml:space="preserve">
          <source>The polar style attempts to emphasize arguments like</source>
          <target state="translated">のような主張を強調しようとするのが極流です。</target>
        </trans-unit>
        <trans-unit id="69fec36a5f0f42b7b7ddc49268b5d8cea58e3639" translate="yes" xml:space="preserve">
          <source>The popular tool &lt;code&gt;sudo&lt;/code&gt; provides a controlled way for users to be able to run programs as other users. It sanitises the execution environment to some extent, and will avoid the &lt;a href=&quot;#Shebang-Race-Condition&quot;&gt;shebang race condition&lt;/a&gt;. If you don't have the safe version of set-id scripts, then &lt;code&gt;sudo&lt;/code&gt; may be a more convenient way of executing a script as another user than writing a C wrapper would be.</source>
          <target state="translated">人気のあるツール &lt;code&gt;sudo&lt;/code&gt; は、ユーザーが他のユーザーとしてプログラムを実行できるようにするための制御された方法を提供します。実行環境をある程度サニタイズし、&lt;a href=&quot;#Shebang-Race-Condition&quot;&gt;シェバンの競合状態&lt;/a&gt;を回避します。安全なバージョンのset-idスクリプトがない場合は、Cラッパーを作成するよりも、別のユーザーとしてスクリプトを実行する方が &lt;code&gt;sudo&lt;/code&gt; の方が便利な場合があります。</target>
        </trans-unit>
        <trans-unit id="9c2c870c4a68cedcedbfdb919f7afe57be993942" translate="yes" xml:space="preserve">
          <source>The port for Win32 was used as a reference.</source>
          <target state="translated">Win32用のポートを参考にしました。</target>
        </trans-unit>
        <trans-unit id="e9a7460e24d0700d3e12dc5c76ead4d814126aa5" translate="yes" xml:space="preserve">
          <source>The port of Perl to Mac OS was officially removed as of Perl 5.12, though the last official production release of MacPerl corresponded to Perl 5.6. While Perl 5.10 included the port to Mac OS, ExtUtils::MakeMaker, a core part of Perl's module installation infrastructure officially dropped support for Mac OS in April 2004.</source>
          <target state="translated">Perl の Mac OS への移植は Perl 5.12 の時点で公式に削除されましたが、MacPerl の最後の公式なプロダクションリリースは Perl 5.6 に対応していました。Perl 5.10 には Mac OS への移植が含まれていましたが、Perl のモジュールインストールインフラストラクチャのコア部分である ExtUtils::MakeMaker は 2004 年 4 月に公式に Mac OS へのサポートを終了しました。</target>
        </trans-unit>
        <trans-unit id="9181a3290f36ca81b3bb6720fe9893dc45df567f" translate="yes" xml:space="preserve">
          <source>The port of Perl to to Mac OS was officially removed as of Perl 5.12, though the last official production release of MacPerl corresponded to Perl 5.6. While Perl 5.10 included the port to Mac OS, ExtUtils::MakeMaker, a core part of Perl's module installation infrastructure officially dropped support for Mac OS in April 2004.</source>
          <target state="translated">Perl の Mac OS への移植は Perl 5.12 の時点で公式に削除されましたが、MacPerl の最後の公式なプロダクションリリースは Perl 5.6 に対応していました。Perl 5.10 には Mac OS への移植が含まれていましたが、Perl のモジュールインストールインフラストラクチャのコア部分である ExtUtils::MakeMaker は 2004 年 4 月に公式に Mac OS へのサポートを終了しました。</target>
        </trans-unit>
        <trans-unit id="f4180538d74696f5817f3f6feca9a1c65e2c02f2" translate="yes" xml:space="preserve">
          <source>The porters appreciate the time you spent helping to make Perl better. Thank you!</source>
          <target state="translated">移植者は、Perlをより良くするためにあなたが時間を割いてくれたことに感謝しています。ありがとうございます。</target>
        </trans-unit>
        <trans-unit id="54bd391c46a02c41cb9ecadecb266d6444c3a53a" translate="yes" xml:space="preserve">
          <source>The portion of the extension provided by the XS code may be connected to the rest of Perl in either of two ways. In the &lt;b&gt;static&lt;/b&gt; configuration, the object code for the extension is linked directly into</source>
          <target state="translated">XSコードによって提供される拡張機能の部分は、2つの方法のいずれかで残りのPerlに接続できます。で&lt;b&gt;静的&lt;/b&gt;構成、拡張のためのオブジェクト・コードは、に直接連結されています</target>
        </trans-unit>
        <trans-unit id="2605e3cd341c048b0037bbd123fa8ea2ca949be7" translate="yes" xml:space="preserve">
          <source>The position in the file of FILEHANDLE is left unchanged. You may want to call &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;seek&lt;/a&gt; before writing to the file.</source>
          <target state="translated">FILEHANDLEのファイル内の位置は変更されません。ファイルに書き込む前に&lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;seek&lt;/a&gt;を呼び出すことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="4c71fa06187e2cb76d45cf6769bdd2d2cbe65fe5" translate="yes" xml:space="preserve">
          <source>The position in the file of FILEHANDLE is left unchanged. You may want to call &lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;seek&lt;/a&gt; before writing to the file.</source>
          <target state="translated">FILEHANDLEのファイル内の位置は変更されません。ファイルに書き込む前に&lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;seek&lt;/a&gt;を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="efdfff91986b015ed9943f5eed1ac7ffd6711ca2" translate="yes" xml:space="preserve">
          <source>The possessive forms (new in Perl 5.10) prevent backtracking: what gets matched by a pattern with a possessive quantifier will not be backtracked into, even if that causes the whole match to fail.</source>
          <target state="translated">所有形 (Perl 5.10 の新機能)はバックトラッキングを防止します。所有形量詞を持つパターンにマッチしたものは、たとえマッチ全体が失敗したとしてもバックトラッキングされません。</target>
        </trans-unit>
        <trans-unit id="5eab19b8b748f65afb0049c25c884441fbae1bc8" translate="yes" xml:space="preserve">
          <source>The possible categories are: &lt;code&gt;:collate&lt;/code&gt; , &lt;code&gt;:ctype&lt;/code&gt; , &lt;code&gt;:messages&lt;/code&gt; , &lt;code&gt;:monetary&lt;/code&gt; , &lt;code&gt;:numeric&lt;/code&gt; , &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; , and the pseudo category &lt;code&gt;:characters&lt;/code&gt; (described below).</source>
          <target state="translated">可能なカテゴリは次のとおりです &lt;code&gt;:collate&lt;/code&gt; 、 &lt;code&gt;:ctype&lt;/code&gt; 、 &lt;code&gt;:messages&lt;/code&gt; 、 &lt;code&gt;:monetary&lt;/code&gt; 、 &lt;code&gt;:numeric&lt;/code&gt; 、 &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 、および擬似カテゴリ &lt;code&gt;:characters&lt;/code&gt; （後述）。</target>
        </trans-unit>
        <trans-unit id="b9cec0c735ea3bb0489e4ea0d12dfd9112e5e476" translate="yes" xml:space="preserve">
          <source>The possible categories are: &lt;code&gt;:collate&lt;/code&gt;, &lt;code&gt;:ctype&lt;/code&gt;, &lt;code&gt;:messages&lt;/code&gt;, &lt;code&gt;:monetary&lt;/code&gt;, &lt;code&gt;:numeric&lt;/code&gt;, &lt;code&gt;:time&lt;/code&gt;, and the pseudo category &lt;code&gt;:characters&lt;/code&gt; (described below).</source>
          <target state="translated">可能なカテゴリは、 &lt;code&gt;:collate&lt;/code&gt; 、 &lt;code&gt;:ctype&lt;/code&gt; 、 &lt;code&gt;:messages&lt;/code&gt; 、 &lt;code&gt;:monetary&lt;/code&gt; 、 &lt;code&gt;:numeric&lt;/code&gt; 、 &lt;code&gt;:time&lt;/code&gt; 、および疑似カテゴリ &lt;code&gt;:characters&lt;/code&gt; （以下で説明）です。</target>
        </trans-unit>
        <trans-unit id="00fdb180b333447352b78de9f2313423642a41c9" translate="yes" xml:space="preserve">
          <source>The possible values and flag bits of the MODE parameter are system-dependent; they are available via the standard module &lt;a href=&quot;fcntl&quot;&gt;&lt;code&gt;Fcntl&lt;/code&gt;&lt;/a&gt;. See the documentation of your operating system's &lt;a href=&quot;http://man.he.net/man2/open&quot;&gt;open(2)&lt;/a&gt; syscall to see which values and flag bits are available. You may combine several flags using the &lt;code&gt;|&lt;/code&gt;-operator.</source>
          <target state="translated">MODEパラメータの可能な値とフラグビットはシステムに依存します。これらは、標準モジュール&lt;a href=&quot;fcntl&quot;&gt; &lt;code&gt;Fcntl&lt;/code&gt; &lt;/a&gt;を介して利用できます。オペレーティングシステムの&lt;a href=&quot;http://man.he.net/man2/open&quot;&gt;open（2）&lt;/a&gt; syscallのドキュメントを参照して、使用可能な値とフラグビットを確認してください。 &lt;code&gt;|&lt;/code&gt; を使用して複数のフラグを組み合わせることができます。-オペレーター。</target>
        </trans-unit>
        <trans-unit id="d6655e8efe41a46d2438d144ed4d6129c437e80b" translate="yes" xml:space="preserve">
          <source>The possible values and flag bits of the MODE parameter are system-dependent; they are available via the standard module &lt;code&gt;Fcntl&lt;/code&gt; . See the documentation of your operating system's</source>
          <target state="translated">MODEパラメータの可能な値とフラグビットはシステムに依存します。これらは、標準モジュール &lt;code&gt;Fcntl&lt;/code&gt; を介して使用できます。オペレーティングシステムのドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="f5b739ecc638266d58487c7c88c27f4bcc3311ca" translate="yes" xml:space="preserve">
          <source>The possibly inferred link-text; i.e., if there was no real link text, then this is the text that we'll infer in its place. (E.g., for &quot;L&amp;lt;Getopt::Std&amp;gt;&quot;, the inferred link text is &quot;Getopt::Std&quot;.)</source>
          <target state="translated">推定される可能性のあるリンクテキスト。つまり、実際のリンクテキストがない場合、これは、その場所で推測するテキストです。（たとえば、「L &amp;lt;Getopt :: Std&amp;gt;」の場合、推測されるリンクテキストは「Getopt :: Std」です。）</target>
        </trans-unit>
        <trans-unit id="4e5ec7c69ae0bd18f551874e75cc4c912902b3a0" translate="yes" xml:space="preserve">
          <source>The practice of saying, &amp;ldquo;If I had to do it all over, I&amp;rsquo;d do it differently,&amp;rdquo; and then actually going back and doing it all over differently. Mathematically speaking, it&amp;rsquo;s returning from an unsuccessful recursion on a tree of possibilities. Perl backtracks when it attempts to match patterns with a &lt;b&gt;regular expression&lt;/b&gt;, and its earlier attempts don&amp;rsquo;t pan out. See the section &amp;ldquo;The Little Engine That /Couldn(n&amp;rsquo;t)&amp;rdquo; in Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">「すべてをやり直さなければならない場合は、別の方法でやる」と言って、実際に戻って、すべてを別の方法で行う習慣。数学的に言えば、それは可能性のツリーでの失敗した再帰から戻ってきています。Perlは、&lt;b&gt;正規表現を使用&lt;/b&gt;してパターンに一致させようとするとバックトラックし、以前の試みではうまくいきません。ラクダの第5章「パターンマッチング」の「The Little Engine That / Couldn（n't）」のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="03599d25f97c0e2d0192955c405d8519204aa81e" translate="yes" xml:space="preserve">
          <source>The practice of shifting an alphabet one or more characters for encipherment dates back thousands of years and was explicitly detailed by Gaius Julius Caesar in his &lt;b&gt;Gallic Wars&lt;/b&gt; text. A single alphabet shift is sometimes referred to as a rotation and the shift amount is given as a number $n after the string 'rot' or &quot;rot$n&quot;. Rot0 and rot26 would designate identity maps on the 26-letter English version of the Latin alphabet. Rot13 has the interesting property that alternate subsequent invocations are identity maps (thus rot13 is its own non-trivial inverse in the group of 26 alphabet rotations). Hence the following is a rot13 encoder and decoder that will work on ASCII and EBCDIC platforms:</source>
          <target state="translated">暗号化のために1文字以上のアルファベットをシフトする慣行は数千年前に遡り、Gaius Julius Caesarの&lt;b&gt;Gallic Warsの&lt;/b&gt;テキストで詳細に説明されています。 1つのアルファベットシフトはローテーションと呼ばれることもあり、シフト量は文字列 'rot'または &quot;rot $ n&quot;の後に数値$ nとして与えられます。 Rot0とrot26は、ラテン文字の26文字の英語版のアイデンティティマップを指定します。 Rot13には、後続の代替呼び出しがアイデンティティマップであるという興味深い特性があります（したがって、rot13は、26のアルファベット回転のグループでは、それ自体が自明ではありません）。したがって、以下は、ASCIIおよびEBCDICプラットフォームで動作するrot13エンコーダーおよびデコーダーです。</target>
        </trans-unit>
        <trans-unit id="a4931fe0eefec05b185de502969d863746246773" translate="yes" xml:space="preserve">
          <source>The pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status instead of the default emulation of POSIX status described above. This pragma also disables the conversion of non-zero values to SS$_ABORT when setting &lt;code&gt;$?&lt;/code&gt; in an END block (but zero will still be converted to SS$_NORMAL).</source>
          <target state="translated">プラグマ &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; を使用して &lt;code&gt;$?&lt;/code&gt; 上記のPOSIXステータスのデフォルトのエミュレーションではなく、実際のVMS終了ステータスを反映します。このプラグマは、 &lt;code&gt;$?&lt;/code&gt; の設定時にゼロ以外の値のSS $ _ABORTへの変換も無効にします。ENDブロック内（ただし、ゼロは引き続きSS $ _NORMALに変換されます）。</target>
        </trans-unit>
        <trans-unit id="91d3ea3fbae8cd7072d27f773df4ade3db8e3a56" translate="yes" xml:space="preserve">
          <source>The pragma &lt;code&gt;use vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status instead of the default emulation of POSIX status described above. This pragma also disables the conversion of non-zero values to SS$_ABORT when setting &lt;code&gt;$?&lt;/code&gt; in an END block (but zero will still be converted to SS$_NORMAL).</source>
          <target state="translated">プラグマ &lt;code&gt;use vmsish 'status'&lt;/code&gt; は &lt;code&gt;$?&lt;/code&gt; 上記のPOSIXステータスのデフォルトのエミュレーションではなく、実際のVMS終了ステータスを反映します。このプラグマは、 &lt;code&gt;$?&lt;/code&gt; を設定するときに、ゼロ以外の値からSS $ _ABORTへの変換も無効にします。ENDブロック内（ただし、ゼロは引き続きSS $ _NORMALに変換されます）。</target>
        </trans-unit>
        <trans-unit id="36ba59d998f30d35a2800e28be03d01cb711ce6c" translate="yes" xml:space="preserve">
          <source>The pragma was a per script, not a per block lexical. Only the last &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; mattered, and it affected &lt;b&gt;the whole script&lt;/b&gt;. However, the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; pragma was supported and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; could appear as many times as you want in a given script (though only the last was effective).</source>
          <target state="translated">プラグマはスクリプトごとであり、ブロックごとの語彙ではありませんでした。重要なのは、最後に &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; のみか &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; &lt;b&gt;、スクリプト全体&lt;/b&gt;に影響を与えまし&lt;b&gt;た&lt;/b&gt;。ただし、 &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; プラグマはサポートされており、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; は特定のスクリプトで必要な回数だけ表示できます（ただし、最後のスクリプトのみが有効でした）。</target>
        </trans-unit>
        <trans-unit id="9e7b1da1b87c8f47d3de1bab74d0b204e260e393" translate="yes" xml:space="preserve">
          <source>The pragma was a per script, not a per block lexical. Only the last &lt;code&gt;use encoding&lt;/code&gt; or &lt;code&gt;no encoding&lt;/code&gt; mattered, and it affected &lt;b&gt;the whole script&lt;/b&gt;. However, the &lt;code&gt;no encoding&lt;/code&gt; pragma was supported and &lt;code&gt;use encoding&lt;/code&gt; could appear as many times as you want in a given script (though only the last was effective).</source>
          <target state="translated">プラグマはスクリプトごとであり、ブロックごとの字句ではありませんでした。最後に &lt;code&gt;use encoding&lt;/code&gt; のみ、または &lt;code&gt;no encoding&lt;/code&gt; 重要ではなく&lt;b&gt;、スクリプト全体&lt;/b&gt;に影響しまし&lt;b&gt;た&lt;/b&gt;。ただし、 &lt;code&gt;no encoding&lt;/code&gt; プラグマはサポートされており &lt;code&gt;use encoding&lt;/code&gt; は、特定のスクリプトで必要な回数だけ表示される可能性があります（ただし、最後のプラグマのみが有効でした）。</target>
        </trans-unit>
        <trans-unit id="f8b4d970b42fbff322fe3d169272f393cc128f89" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; also might be of interest because they solve the autoupgrading/downgrading issue, at least partly.</source>
          <target state="translated">プラグマ&lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;、&lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt;、および&lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt;も、少なくとも部分的に自動アップグレード/ダウングレードの問題を解決するため、興味深いかもしれません。</target>
        </trans-unit>
        <trans-unit id="76569ddba56c9f99056592d21ac1b2ff490f26ec" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; also might be of interest because they solve the autoupgrading/downgrading issue, at least partly.</source>
          <target state="translated">プラグマ&lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;、&lt;a href=&quot;bigint&quot;&gt;bigint&lt;/a&gt;、&lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt;も、少なくとも部分的に自動アップグレード/ダウングレードの問題を解決するため、興味深いものになる可能性があります。</target>
        </trans-unit>
        <trans-unit id="984c1d7b1bad11977f9a25ba621b51c787c8e6c4" translate="yes" xml:space="preserve">
          <source>The preamble added to each output file is rather verbose, and most of it is only necessary in the presence of non-ASCII characters. It would ideally be nice if all of those definitions were only output if needed, perhaps on the fly as the characters are used.</source>
          <target state="translated">各出力ファイルに追加されたプリアンブルはどちらかというと冗長で、そのほとんどは非ASCII文字の存在下でのみ必要とされるものです。理想的には、これらの定義のすべてが必要なときだけ出力され、おそらく文字が使われているときにその場で出力されるのがいいでしょう。</target>
        </trans-unit>
        <trans-unit id="45357f49e477501b84ee9e2077b2244c8a2bb54d" translate="yes" xml:space="preserve">
          <source>The preamble code for the class is as follows:</source>
          <target state="translated">クラスのプリアンブルコードは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="b4c4542a57f99c1f10f3ac073718f1821e067ea0" translate="yes" xml:space="preserve">
          <source>The preference of the &lt;b&gt;regular expression&lt;/b&gt; engine to match the leftmost occurrence of a &lt;b&gt;pattern&lt;/b&gt;, then given a position at which a match will occur, the preference for the longest match (presuming the use of a &lt;b&gt;greedy&lt;/b&gt; quantifier). See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo; for</source>
          <target state="translated">嗜好の&lt;b&gt;正規表現&lt;/b&gt;の左端の発生と一致するようにエンジン&lt;b&gt;のパターンは&lt;/b&gt;、次に、一致が発生する位置、最長一致（の使用推定する嗜好所与&lt;b&gt;貪欲&lt;/b&gt;数量詞を）。ラクダの第5章「パターンマッチング」を参照してください。</target>
        </trans-unit>
        <trans-unit id="fb28a274f1049ea39bf5f7992f63f38b064b26ab" translate="yes" xml:space="preserve">
          <source>The preferred way to do this is to declare a plan when you &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; .</source>
          <target state="translated">これを行うための好ましい方法は、 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; を&lt;a href=&quot;../functions/use&quot;&gt;使用する&lt;/a&gt;ときにプランを宣言することです。</target>
        </trans-unit>
        <trans-unit id="5006ab06a26ab8e5eca93c03d0291151f3f3136d" translate="yes" xml:space="preserve">
          <source>The preferred way to do this is to declare a plan when you &lt;code&gt;use Test::More&lt;/code&gt;.</source>
          <target state="translated">これを行うための推奨される方法は、 &lt;code&gt;use Test::More&lt;/code&gt; を使用するときにプランを宣言することです。</target>
        </trans-unit>
        <trans-unit id="a070b02ec3ff7789ebf48e13bc147cc73129be84" translate="yes" xml:space="preserve">
          <source>The prefix specified by &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; will be used with a numeric suffix if the name for a value is undefined.</source>
          <target state="translated">&lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; 指定されたプレフィックスは、値の名前が未定義の場合、数値のサフィックスとともに使用されます。</target>
        </trans-unit>
        <trans-unit id="47b994ba12e424b0e632ed96c89a1498fbc470f8" translate="yes" xml:space="preserve">
          <source>The presence of the word &quot;FATAL&quot; in the category list will escalate warnings in those categories into fatal errors in that lexical scope.</source>
          <target state="translated">カテゴリリストに &quot;FATAL &quot;という単語があると、それらのカテゴリの警告は、その語彙範囲の致命的なエラーにエスカレートします。</target>
        </trans-unit>
        <trans-unit id="7069f5b0b1dc1568e108cd084477a400c3f8668e" translate="yes" xml:space="preserve">
          <source>The previous assignments are exactly equivalent to</source>
          <target state="translated">これまでの課題は、まさに</target>
        </trans-unit>
        <trans-unit id="131e26e34a6a280e8d155fa06c2fe106438c82bd" translate="yes" xml:space="preserve">
          <source>The previous behavior of putting the errors (converted to POSIX-style &lt;code&gt;E*&lt;/code&gt; error codes since Perl 5.20.0) into &lt;code&gt;$!&lt;/code&gt; was buggy due to the non-equivalence of like-named Winsock and POSIX error constants, a relationship between which has unfortunately been established in one way or another since Perl 5.8.0.</source>
          <target state="translated">エラー（Perl5.20.0以降POSIXスタイルの &lt;code&gt;E*&lt;/code&gt; エラーコードに変換）を &lt;code&gt;$!&lt;/code&gt; に入れる以前の動作！同じ名前のWinsockとPOSIXのエラー定数が同等ではないため、バグがありました。これらの関係は、残念ながらPerl5.8.0以降何らかの方法で確立されています。</target>
        </trans-unit>
        <trans-unit id="8d4bba88bb17e91a3967206974b895243970981e" translate="yes" xml:space="preserve">
          <source>The previous example was not particularly useful. To make it more general purpose we will make use of the context data and allow any arbitrary</source>
          <target state="translated">前の例は特に有用ではありませんでした。これをより一般的なものにするために、コンテキストデータを利用し、任意の</target>
        </trans-unit>
        <trans-unit id="e9b3a0712244fd40d4ef0fb4f6b05e3de06f443f" translate="yes" xml:space="preserve">
          <source>The previous paragraph is applicable verbatim to tied hash access using the &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; functions as well.</source>
          <target state="translated">前の段落は、 &lt;code&gt;hv_store_ent&lt;/code&gt; 関数とhv_store_ent関数を使用した &lt;code&gt;hv_store&lt;/code&gt; ハッシュアクセスにそのまま適用できます。</target>
        </trans-unit>
        <trans-unit id="dd2b650563ddd2d2b6e29ef9f64d0b20b2f5e086" translate="yes" xml:space="preserve">
          <source>The previous section (introduced by a &lt;code&gt;=head&lt;/code&gt; command) does not contain any text. This usually indicates that something is missing. Note: A &lt;code&gt;=head1&lt;/code&gt; followed immediately by &lt;code&gt;=head2&lt;/code&gt; does not trigger this warning.</source>
          <target state="translated">前のセクション（ &lt;code&gt;=head&lt;/code&gt; コマンドで導入）にはテキストが含まれていません。これは通常、何かが欠落していることを示します。注： &lt;code&gt;=head1&lt;/code&gt; の直後に &lt;code&gt;=head2&lt;/code&gt; が続いても、この警告はトリガーされません。</target>
        </trans-unit>
        <trans-unit id="b2d4d760a41ac2c4684274cd24041bdb5438342a" translate="yes" xml:space="preserve">
          <source>The previous section (introduced by a &lt;code&gt;=head&lt;/code&gt; command) does not contain any valid content. This usually indicates that something is missing. Note: A &lt;code&gt;=head1&lt;/code&gt; followed immediately by &lt;code&gt;=head2&lt;/code&gt; does not trigger this warning.</source>
          <target state="translated">前のセクション（ &lt;code&gt;=head&lt;/code&gt; コマンドで紹介）には、有効なコンテンツが含まれていません。これは通常、何かが不足していることを示しています。注： &lt;code&gt;=head1&lt;/code&gt; の直後に &lt;code&gt;=head2&lt;/code&gt; が続く場合、この警告はトリガーされません。</target>
        </trans-unit>
        <trans-unit id="186c5466a670230e882670fbcd9b5aa0c0353eb4" translate="yes" xml:space="preserve">
          <source>The previous step created</source>
          <target state="translated">前のステップで作成した</target>
        </trans-unit>
        <trans-unit id="d900c388659851ed663901ca396af85f982c5cba" translate="yes" xml:space="preserve">
          <source>The primary cause of the 'dlopen: stub interception failed' message is that the LD_LIBRARY_PATH environment variable includes a directory which is a symlink to /usr/lib (such as /lib). See &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;&quot;LD_LIBRARY_PATH&quot;&lt;/a&gt; above.</source>
          <target state="translated">「dlopen：スタブインターセプトに失敗しました」メッセージの主な原因は、LD_LIBRARY_PATH環境変数に/ usr / libへのシンボリックリンクであるディレクトリ（/ libなど）が含まれていることです。上記の&lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;「LD_LIBRARY_PATH」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="340b1d36d10dcf0bc3c98148a5a96864b33866c8" translate="yes" xml:space="preserve">
          <source>The primary cause of the 'dlopen: stub interception failed' message is that the LD_LIBRARY_PATH environment variable includes a directory which is a symlink to /usr/lib (such as /lib). See &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATH&lt;/a&gt; above.</source>
          <target state="translated">「dlopen：stub interception failed」メッセージの主な原因は、LD_LIBRARY_PATH環境変数に/ usr / lib（/ libなど）へのシンボリックリンクであるディレクトリが含まれていることです。上記の&lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATHを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6b0f3d276de0b395d904df1ee65d02fbb91e800c" translate="yes" xml:space="preserve">
          <source>The primary purpose of this module is to provide streaming write access to zip files and buffers. It is not a general-purpose file archiver. If that is what you want, check out &lt;code&gt;Archive::Zip&lt;/code&gt; .</source>
          <target state="translated">このモジュールの主な目的は、zipファイルとバッファへのストリーミング書き込みアクセスを提供することです。汎用のファイルアーカイバではありません。それが必要な場合は、 &lt;code&gt;Archive::Zip&lt;/code&gt; チェックしてください。</target>
        </trans-unit>
        <trans-unit id="7109b8aae18759607febf6d98f672f7929c0c0ad" translate="yes" xml:space="preserve">
          <source>The primary purpose of this module is to provide streaming write access to zip files and buffers. It is not a general-purpose file archiver. If that is what you want, check out &lt;code&gt;Archive::Zip&lt;/code&gt; or &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt;.</source>
          <target state="translated">このモジュールの主な目的は、zipファイルとバッファーへのストリーミング書き込みアクセスを提供することです。汎用のファイルアーカイバではありません。それが必要な場合は、 &lt;code&gt;Archive::Zip&lt;/code&gt; または &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt; 確認してください。</target>
        </trans-unit>
        <trans-unit id="3562a709266ee6938735493658a732dcdd3f50d6" translate="yes" xml:space="preserve">
          <source>The primary reference for Zip files is the &quot;appnote&quot; document available at &lt;a href=&quot;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt;.</source>
          <target state="translated">Zipファイルの主なリファレンスは、&lt;a href=&quot;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http：&lt;/a&gt; //www.pkware.com/documents/casestudies/APPNOTE.TXTで入手できる「appnote」ドキュメントです。</target>
        </trans-unit>
        <trans-unit id="adaddbe76e40b85855bdb3acd3e478586223f423" translate="yes" xml:space="preserve">
          <source>The primary reference for gzip files is RFC 1952 &lt;a href=&quot;http://www.faqs.org/rfcs/rfc1952.html&quot;&gt;http://www.faqs.org/rfcs/rfc1952.html&lt;/a&gt;</source>
          <target state="translated">gzipファイルの主なリファレンスはRFC1952http：//www.faqs.org/rfcs/rfc1952.htmlです&lt;a href=&quot;http://www.faqs.org/rfcs/rfc1952.html&quot;&gt;。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bc24d550b4fe8851d0897e687949d42067e8b5a9" translate="yes" xml:space="preserve">
          <source>The primary reference for zip files is the &quot;appnote&quot; document available at &lt;a href=&quot;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt;</source>
          <target state="translated">zipファイルの主なリファレンスは、&lt;a href=&quot;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http：&lt;/a&gt; //www.pkware.com/documents/casestudies/APPNOTE.TXTで入手できる「appnote」ドキュメントです。</target>
        </trans-unit>
        <trans-unit id="1bcb3725358ae123bceedddb8d71ef7119024583" translate="yes" xml:space="preserve">
          <source>The primary site for bzip2 is &lt;a href=&quot;http://www.bzip.org&quot;&gt;http://www.bzip.org&lt;/a&gt;.</source>
          <target state="translated">bzip2のプライマリサイトは&lt;a href=&quot;http://www.bzip.org&quot;&gt;http://www.bzip.org&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="0d840d1ff084fc0827d16e21e7b3094c84c9a7a3" translate="yes" xml:space="preserve">
          <source>The primary site for gzip is</source>
          <target state="translated">gzipの主要なサイトは</target>
        </trans-unit>
        <trans-unit id="e859dd2ba7bc9bbaa39a1807494221205b0a4770" translate="yes" xml:space="preserve">
          <source>The primary site for gzip is &lt;a href=&quot;http://www.gzip.org&quot;&gt;http://www.gzip.org&lt;/a&gt;.</source>
          <target state="translated">gzipのプライマリサイトは&lt;a href=&quot;http://www.gzip.org&quot;&gt;http://www.gzip.org&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="76b9d6c85592a8675b44ceb172e5fcc460f2a10f" translate="yes" xml:space="preserve">
          <source>The primary site for the</source>
          <target state="translated">の主要なサイトです。</target>
        </trans-unit>
        <trans-unit id="dff39311adfb064fbb523d321b7e4b3dbea2499f" translate="yes" xml:space="preserve">
          <source>The primary site for the bzip2 program is</source>
          <target state="translated">bzip2 プログラムの主要なサイトは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="6d5111f3cd60b1576c60bc8b7e186e70a9cf368f" translate="yes" xml:space="preserve">
          <source>The primary site for the bzip2 program is &lt;a href=&quot;https://sourceware.org/bzip2/&quot;&gt;https://sourceware.org/bzip2/&lt;/a&gt;.</source>
          <target state="translated">bzip2プログラムのプライマリサイトは&lt;a href=&quot;https://sourceware.org/bzip2/&quot;&gt;https://sourceware.org/bzip2/&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="20a7ebabe8aa28f193ee803e7dabf5b8ae97c28d" translate="yes" xml:space="preserve">
          <source>The principal value of the arc tangent of y/x</source>
          <target state="translated">y/xの円弧正接の主値</target>
        </trans-unit>
        <trans-unit id="c3a6a975854cac68d0d2fce1f652f0011a15276f" translate="yes" xml:space="preserve">
          <source>The principle is that the number of objects found influences how an item is displayed. If the search finds one item, the result is displayed with the rather verbose method &lt;code&gt;as_string&lt;/code&gt; , but if more than one is found, each object is displayed with the terse method &lt;code&gt;as_glimpse&lt;/code&gt; .</source>
          <target state="translated">原則は、検出されたオブジェクトの数がアイテムの表示方法に影響するということです。検索で1つのアイテムが見つかった場合、結果はかなり詳細なメソッド &lt;code&gt;as_string&lt;/code&gt; で表示されますが、複数のアイテムが見つかった場合、各オブジェクトは簡潔なメソッド &lt;code&gt;as_glimpse&lt;/code&gt; で表示されます。</target>
        </trans-unit>
        <trans-unit id="febd9a2b7b0ebfb667a62ab220755a864d89456a" translate="yes" xml:space="preserve">
          <source>The print() statement does not add field and record separators unless you set &lt;code&gt;$,&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt; . You can set $OFS and $ORS if you're using the English module.</source>
          <target state="translated">&lt;code&gt;$,&lt;/code&gt; と &lt;code&gt;$\&lt;/code&gt; を設定しない限り、print（）ステートメントはフィールドとレコードのセパレータを追加しません。英語モジュールを使用している場合は、$ OFSと$ ORSを設定できます。</target>
        </trans-unit>
        <trans-unit id="2da7e391c9fd1ea8ee0cde415f9757d6cf29bace" translate="yes" xml:space="preserve">
          <source>The print() statement does not add field and record separators unless you set &lt;code&gt;$,&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt;. You can set $OFS and $ORS if you're using the English module.</source>
          <target state="translated">&lt;code&gt;$,&lt;/code&gt; と &lt;code&gt;$\&lt;/code&gt; を設定しない限り、print（）ステートメントはフィールドとレコードの区切り文字を追加しません。英語モジュールを使用している場合は、$ OFSと$ ORSを設定できます。</target>
        </trans-unit>
        <trans-unit id="e38b92f2492beff5f39d922c93e2a6ed6bba00e9" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;_installed_file_for_module&lt;/code&gt; method may be replaced with other methods for locating a module in &lt;code&gt;@INC&lt;/code&gt;.</source>
          <target state="translated">プライベート &lt;code&gt;_installed_file_for_module&lt;/code&gt; メソッドは、 &lt;code&gt;@INC&lt;/code&gt; モジュールを見つけるための他のメソッドに置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="39cbd438adc424d857eb231b91cd98738e10a91c" translate="yes" xml:space="preserve">
          <source>The private data cache will take ownership of a reference to private_sv, much the same way that &lt;code&gt;hv_store()&lt;/code&gt; takes ownership of a reference to the value that you pass it.</source>
          <target state="translated">プライベートデータキャッシュは、 &lt;code&gt;hv_store()&lt;/code&gt; が渡す値への参照の所有権を取得するのとほぼ同じ方法で、private_sv への参照の所有権を取得します。</target>
        </trans-unit>
        <trans-unit id="7c29fbafe2b5b36ada501a03eca4a2fd699c674d" translate="yes" xml:space="preserve">
          <source>The private object hash keys like &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; may not be changed, but additional keys can be added, like &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; ようなプライベートオブジェクトハッシュキーは変更できませんが、 &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; ような追加のキーを追加できます。</target>
        </trans-unit>
        <trans-unit id="22731711df90de28382d892b4f249e651429dc6f" translate="yes" xml:space="preserve">
          <source>The private object hash keys like &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; may not be changed, but additional keys can be added, like &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; ようなプライベートオブジェクトハッシュキーは変更できませんが、 &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; ように追加のキーを追加できます。</target>
        </trans-unit>
        <trans-unit id="660e221c9f99f43f8d3110d11068349758eb697d" translate="yes" xml:space="preserve">
          <source>The private variable is used to save the current locale state, so that the requisite matching call to &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;&quot;RESTORE_LC_NUMERIC&quot;&lt;/a&gt; can restore it.</source>
          <target state="translated">プライベート変数は、現在のロケール状態を保存するために使用されるため、&lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;「RESTORE_LC_NUMERIC」&lt;/a&gt;への必要な一致呼び出しでそれを復元できます。</target>
        </trans-unit>
        <trans-unit id="9da35a7db7a9991be43f0a35bab375b2fa2f7661" translate="yes" xml:space="preserve">
          <source>The private variable is used to save the current locale state, so that the requisite matching call to &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt; can restore it.</source>
          <target state="translated">プライベート変数は、現在のロケールの状態を保存するために使用されます。これにより、&lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt;への一致する必要な呼び出しで復元できます。</target>
        </trans-unit>
        <trans-unit id="2ca51914e8f8318dafeffce74323b676d587ba34" translate="yes" xml:space="preserve">
          <source>The private_use feature is experimental</source>
          <target state="translated">private_use 機能は実験的なものです。</target>
        </trans-unit>
        <trans-unit id="5290ff0dba8c2d4696fae469f418160732641247" translate="yes" xml:space="preserve">
          <source>The problem can be further examined in a roughly equivalent C program:</source>
          <target state="translated">この問題は、大まかにはC言語のプログラムでさらに検討することができます。</target>
        </trans-unit>
        <trans-unit id="13328591f6760dcc09259e6c0b9735e71fa4da38" translate="yes" xml:space="preserve">
          <source>The problem comes in when you take your numbers from something that Perl thinks is a string, such as a command line argument in &lt;code&gt;@ARGV&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;@ARGV&lt;/code&gt; のコマンドライン引数など、Perlが文字列であると考えるものから数値を取得すると、問題が発生します。</target>
        </trans-unit>
        <trans-unit id="2c1b07cc8bfa77fdc4b2aa2cb8ca8cba9947e03f" translate="yes" xml:space="preserve">
          <source>The problem comes in when you take your numbers from something that Perl thinks is a string, such as a command line argument in &lt;code&gt;@ARGV&lt;/code&gt;:</source>
          <target state="translated">問題は、@ &lt;code&gt;@ARGV&lt;/code&gt; コマンドライン引数など、Perlが文字列であると見なすものから数値を取得するときに発生します。</target>
        </trans-unit>
        <trans-unit id="cd8bb5622c99567256e6a98501e22410a2a7900d" translate="yes" xml:space="preserve">
          <source>The problem comes when you have, for instance, a string that isn't flagged as UTF-8, and contains a byte sequence that could be UTF-8 -- especially when combining non-UTF-8 and UTF-8 strings.</source>
          <target state="translated">問題は、例えば、UTF-8としてフラグが設定されていない文字列があり、UTF-8である可能性のあるバイト列を含んでいる場合に発生します --特に非UTF-8とUTF-8の文字列を組み合わせる場合。</target>
        </trans-unit>
        <trans-unit id="e918e6ad2cf12f5152c6540799f1ea5ccc7d457e" translate="yes" xml:space="preserve">
          <source>The problem exists because the anonymous subroutine being assigned to the &lt;code&gt;*Foo::foo&lt;/code&gt; glob will show up in the call stack as being called &lt;code&gt;__ANON__&lt;/code&gt; and not &lt;code&gt;foo&lt;/code&gt; as you might expect. Since &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; to find the name of the method it was called in, it will fail in this case.</source>
          <target state="translated">&lt;code&gt;*Foo::foo&lt;/code&gt; グロブに割り当てられている無名サブルーチンが、コールスタックに、期待どおり &lt;code&gt;foo&lt;/code&gt; ではなく &lt;code&gt;__ANON__&lt;/code&gt; として呼び出されるため、問題が発生します。ので &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; 使用する &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; 、それがで呼び出されたメソッドの名前を見つけるために、それはこの場合には失敗します。</target>
        </trans-unit>
        <trans-unit id="f6e3278fa9663415debfd4e39d0b068a1659902a" translate="yes" xml:space="preserve">
          <source>The problem exists because the anonymous subroutine being assigned to the &lt;code&gt;*Foo::foo&lt;/code&gt; glob will show up in the call stack as being called &lt;code&gt;__ANON__&lt;/code&gt; and not &lt;code&gt;foo&lt;/code&gt; as you might expect. Since &lt;code&gt;next::method&lt;/code&gt; uses &lt;code&gt;caller&lt;/code&gt; to find the name of the method it was called in, it will fail in this case.</source>
          <target state="translated">&lt;code&gt;*Foo::foo&lt;/code&gt; globに割り当てられている匿名サブルーチンは、予想どおり &lt;code&gt;foo&lt;/code&gt; ではなく &lt;code&gt;__ANON__&lt;/code&gt; と呼ばれるものとして呼び出しスタックに表示されるため、問題が発生します。ので &lt;code&gt;next::method&lt;/code&gt; 使用する &lt;code&gt;caller&lt;/code&gt; 、それがで呼び出されたメソッドの名前を見つけるために、それはこの場合には失敗します。</target>
        </trans-unit>
        <trans-unit id="aea1a84a6e43b26958b1598b1f93e9a632b83a16" translate="yes" xml:space="preserve">
          <source>The problem here is that Uid_t might be not only not &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;-wide but it might also be unsigned, in which case large uids would be printed as negative values.</source>
          <target state="translated">ここでの問題は、Uid_tが &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; 全体だけでなく、署名されていない可能性があることです。この場合、大きなuidは負の値として出力されます。</target>
        </trans-unit>
        <trans-unit id="27a99efdaf6b6471f2df947f1f817dd0e909810c" translate="yes" xml:space="preserve">
          <source>The problem here is that Uid_t might be not only not &lt;code&gt;int&lt;/code&gt;-wide but it might also be unsigned, in which case large uids would be printed as negative values.</source>
          <target state="translated">ここでの問題は、Uid_tが &lt;code&gt;int&lt;/code&gt; 全体であるだけでなく、符号なしである可能性があることです。その場合、大きなuidが負の値として出力されます。</target>
        </trans-unit>
        <trans-unit id="56bc12834cd035d1009997925f3d7abe998a9788" translate="yes" xml:space="preserve">
          <source>The problem here is that both the group named &lt;code&gt;a&lt;/code&gt; and the group named &lt;code&gt;b&lt;/code&gt; are aliases for the group belonging to &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">ここでの問題は、という名前のグループの両方の点であるとという名前のグループ &lt;code&gt;b&lt;/code&gt; に属しているグループのエイリアスである &lt;code&gt;$1&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b18408c3bf47516e5c9af25c6047a1bd86154733" translate="yes" xml:space="preserve">
          <source>The problem here is that both the group named &lt;code&gt;a&lt;/code&gt; and the group named &lt;code&gt;b&lt;/code&gt; are aliases for the group belonging to &lt;code&gt;$1&lt;/code&gt;.</source>
          <target state="translated">ここでの問題は、という名前のグループの両方の点であるとという名前のグループ &lt;code&gt;b&lt;/code&gt; に属しているグループのエイリアスである &lt;code&gt;$1&lt;/code&gt; 。 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dda9a4d26fe1b0eb3aeffd7cffb748b622bb8f5f" translate="yes" xml:space="preserve">
          <source>The problem is that Perl has both compile-time and run-time warnings. To disable compile-time warnings you need to rewrite the code like this:</source>
          <target state="translated">問題は、Perlにはコンパイル時の警告と実行時の警告の両方があることです。コンパイル時の警告を無効にするには、次のようにコードを書き換える必要があります。</target>
        </trans-unit>
        <trans-unit id="000d776ae8231195ffb025ac77c4f425f1c2ff6f" translate="yes" xml:space="preserve">
          <source>The problem is that both &lt;code&gt;rp&lt;/code&gt; and &lt;code&gt;dp&lt;/code&gt; are pointers to the same location in memory! In C, you'd have to remember to malloc() yourself some new memory. In Perl, you'll want to use the array constructor &lt;code&gt;[]&lt;/code&gt; or the hash constructor &lt;code&gt;{}&lt;/code&gt; instead. Here's the right way to do the preceding broken code fragments:</source>
          <target state="translated">問題は、 &lt;code&gt;rp&lt;/code&gt; と &lt;code&gt;dp&lt;/code&gt; の両方がメモリ内の同じ場所へのポインターであることです。 Cでは、新しいメモリを自分でmalloc（）することを覚えておく必要があります。 Perlでは、代わりに配列コンストラクター &lt;code&gt;[]&lt;/code&gt; またはハッシュコンストラクター &lt;code&gt;{}&lt;/code&gt; を使用します。上記の壊れたコードフラグメントを実行する正しい方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="44e0ee462b8e8a33d77de1117d49fdbd0c841da5" translate="yes" xml:space="preserve">
          <source>The problem is that grep builds a return list, regardless of the context. This means you're making Perl go to the trouble of building a list that you then just throw away. If the list is large, you waste both time and space. If your intent is to iterate over the list, then use a for loop for this purpose.</source>
          <target state="translated">問題は、grepはコンテキストに関係なくリターンリストを構築することです。これは、Perlにわざわざリストを構築して捨ててしまうことを意味します。リストが大きい場合は、時間とスペースの両方を無駄にしてしまいます。リストを反復処理することを目的としているのであれば、この目的のために for ループを使用してください。</target>
        </trans-unit>
        <trans-unit id="6df859dc8cac16c31baff14e80c7d840e1cb3153" translate="yes" xml:space="preserve">
          <source>The problem is that none of these examples are reliable: they depend on the command interpreter. Under Unix, the first two often work. Under DOS, it's entirely possible that neither works. If 4DOS was the command shell, you'd probably have better luck like this:</source>
          <target state="translated">問題は、これらの例はどれも信頼できるものではないということです。Unix では、最初の二つはよく動作します。DOS では、どちらも動作しない可能性があります。もし 4DOS がコマンドシェルだったら、このようにうまくいくかもしれません。</target>
        </trans-unit>
        <trans-unit id="95485cb814321ef14b952e45ddf9a35301af1a5e" translate="yes" xml:space="preserve">
          <source>The problem is that none of this is reliable: it depends on the command and it is entirely possible neither works. If</source>
          <target state="translated">問題は、これがどれも信頼できるものではないということです:これはコマンドに依存しており、どちらも動作しないことが完全にあり得ます。もし</target>
        </trans-unit>
        <trans-unit id="88377fbeaf8b4fab35329a7e374ea24a4795a7c5" translate="yes" xml:space="preserve">
          <source>The problem is that this code will always be parsed and executed, even when the debug level set in the logging configuration file is zero. Once the debug() subroutine has been entered, and the internal &lt;code&gt;$debug&lt;/code&gt; variable confirmed to be zero, for example, the message which has been sent in will be discarded and the program will continue. In the example given though, the &lt;code&gt;\%INC&lt;/code&gt; hash will already have been dumped, and the message string constructed, all of which work could be bypassed by a debug variable at the statement level, like this:</source>
          <target state="translated">問題は、ロギング構成ファイルで設定されたデバッグレベルがゼロの場合でも、このコードが常に解析および実行されることです。たとえば、debug（）サブルーチンが開始され、内部の &lt;code&gt;$debug&lt;/code&gt; 変数がゼロであることを確認すると、送信されたメッセージは破棄され、プログラムは続行します。ただし、指定された例では、 &lt;code&gt;\%INC&lt;/code&gt; ハッシュはすでにダンプされており、メッセージ文字列が構築されています。これらの作業はすべて、次のようにステートメントレベルのデバッグ変数によってバイパスできます。</target>
        </trans-unit>
        <trans-unit id="73cae6ed898e3261e96216aa07490bc469dc51e8" translate="yes" xml:space="preserve">
          <source>The problem is that this code would</source>
          <target state="translated">問題は、このコードが</target>
        </trans-unit>
        <trans-unit id="e6af2011607132108daf874aceb7c74f8abf4357" translate="yes" xml:space="preserve">
          <source>The problem is that those double-quotes force stringification--coercing numbers and references into strings--even when you don't want them to be strings. Think of it this way: double-quote expansion is used to produce new strings. If you already have a string, why do you need more?</source>
          <target state="translated">問題は、それらの二重引用符は、文字列化を強制するということです。このように考えてみてください:二重引用符の展開は新しい文字列を生成するために使われます。すでに文字列を持っているなら、なぜそれ以上の文字列が必要なのでしょうか?</target>
        </trans-unit>
        <trans-unit id="d0f76e9ccc888898fb7c8d297bdf6217c3b3b765" translate="yes" xml:space="preserve">
          <source>The problem is that various structures visible via procfs use off_t, and if you compile with largefile support these change from 32 bits to 64 bits. Thus what you get back from procfs doesn't match up with the structures in perl, resulting in garbage. See proc(4) for further discussion.</source>
          <target state="translated">問題は、procfs を通じて表示される様々な構造体が off_t を使用していることで、ラージファイルをサポートしてコンパイルした場合、これらの構造体は 32 ビットから 64 ビットに変更されてしまいます。そのため、procfs から得られるものは perl の構造体とは一致せず、結果としてゴミとなってしまいます。さらなる議論は proc(4)を参照してください。</target>
        </trans-unit>
        <trans-unit id="36b3f29973dcb4084c4233c180d15ad0f5ad2090" translate="yes" xml:space="preserve">
          <source>The problem is the nested indeterminate quantifiers. There are many different ways of partitioning a string of length n between the &lt;code&gt;'+'&lt;/code&gt; and &lt;code&gt;'*'&lt;/code&gt;: one repetition with &lt;code&gt;b+&lt;/code&gt; of length n, two repetitions with the first &lt;code&gt;b+&lt;/code&gt; length k and the second with length n-k, m repetitions whose bits add up to length n,</source>
          <target state="translated">問題は、ネストされた不確定な数量詞です。長さnの文字列を &lt;code&gt;'+'&lt;/code&gt; と &lt;code&gt;'*'&lt;/code&gt; 間で分割する方法はたくさんあります。長さnの &lt;code&gt;b+&lt;/code&gt; で1回の繰り返し、最初の &lt;code&gt;b+&lt;/code&gt; 長さkで2回の繰り返し、長さnkで2回目の繰り返し、ビットが追加されるm回の繰り返し長さnまで、</target>
        </trans-unit>
        <trans-unit id="fc4b1a9098877c5f0dfd053c053f3947a9421580" translate="yes" xml:space="preserve">
          <source>The problem is the nested indeterminate quantifiers. There are many different ways of partitioning a string of length n between the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; : one repetition with &lt;code&gt;b+&lt;/code&gt; of length n, two repetitions with the first &lt;code&gt;b+&lt;/code&gt; length k and the second with length n-k, m repetitions whose bits add up to length n, etc. In fact there are an exponential number of ways to partition a string as a function of its length. A regexp may get lucky and match early in the process, but if there is no match, Perl will try</source>
          <target state="translated">問題は、入れ子になった不定数量詞です。 &lt;code&gt;+&lt;/code&gt; と &lt;code&gt;*&lt;/code&gt; の間で長さnの文字列を分割する方法は数多くあります。長さnの &lt;code&gt;b+&lt;/code&gt; で1回繰り返し、最初の &lt;code&gt;b+&lt;/code&gt; 長さk で2回繰り返し、長さnkで2回繰り返し、ビットが長さnになるm回の繰り返しなど。実際には、文字列をその長さの関数として分割する方法は指数関数的に多数あります。正規表現はラッキーになり、プロセスの早い段階で一致する可能性がありますが、一致しない場合、Perlは</target>
        </trans-unit>
        <trans-unit id="57ef8306dabb66b8a3dd5849936f56c155cd391f" translate="yes" xml:space="preserve">
          <source>The problem is usually that the command interpreters on those systems have rather different ideas about quoting than the Unix shells under which the one-liners were created. On some systems, you may have to change single-quotes to double ones, which you must</source>
          <target state="translated">問題は通常、これらのシステムのコマンドインタプリタが、ワンライナーが作成されたUnixシェルとは、引用符についての考え方がかなり異なっていることです。システムによっては、シングルクォートをダブルクォートに変更しなければならない場合があります。</target>
        </trans-unit>
        <trans-unit id="814a82003c2ef63857b1187789261eb0a14ef57b" translate="yes" xml:space="preserve">
          <source>The problem with this is that buffering is really going to ruin your day. Even though your &lt;code&gt;$writer&lt;/code&gt; filehandle is auto-flushed so the process on the other end gets your data in a timely manner, you can't usually do anything to force that process to give its data to you in a similarly quick fashion. In this special case, we could actually so, because we gave</source>
          <target state="translated">これに伴う問題は、バッファリングが本当にあなたの一日を台無しにするだろうということです。あなたにもかかわらず &lt;code&gt;$writer&lt;/code&gt; もう一方の端のプロセスがタイムリーにあなたのデータを取得するように、ファイルハンドルを自動フラッシュされ、あなたは通常、同様に迅速な方法であなたにそのデータを提供するために、そのプロセスを強制的に何もすることはできません。この特別な場合、私たちは実際にそうすることができました。</target>
        </trans-unit>
        <trans-unit id="5ee9f00b1299262770f29ccbf33382cfb01278a2" translate="yes" xml:space="preserve">
          <source>The problem with this is that buffering is really going to ruin your day. Even though your &lt;code&gt;Writer&lt;/code&gt; filehandle is auto-flushed so the process on the other end gets your data in a timely manner, you can't usually do anything to force that process to give its data to you in a similarly quick fashion. In this special case, we could actually so, because we gave</source>
          <target state="translated">これの問題は、バッファリングが本当にあなたの一日を台無しにしてしまうことです。あなたにもかかわらず &lt;code&gt;Writer&lt;/code&gt; もう一方の端のプロセスがタイムリーにあなたのデータを取得するように、ファイルハンドルを自動フラッシュされ、あなたは通常、同様に迅速な方法であなたにそのデータを提供するために、そのプロセスを強制的に何もすることはできません。この特別なケースでは、</target>
        </trans-unit>
        <trans-unit id="f6f3b81b70ac61e4574d6ebcd3e976b1d72049f0" translate="yes" xml:space="preserve">
          <source>The problems of garbage collection and thread safety are both addressed by the function &lt;code&gt;register()&lt;/code&gt; . It registers an object together with any number of hashes. Registry means that when the object dies, an entry in any of the hashes under the reference address of this object will be deleted. This guarantees garbage collection in these hashes. It also means that on thread cloning the object's entries in registered hashes will be replaced with updated entries whose key is the cloned object's reference address. Thus the object-data association becomes thread-safe.</source>
          <target state="translated">ガベージコレクションとスレッドセーフの問題は、どちらも関数 &lt;code&gt;register()&lt;/code&gt; によって対処されます。オブジェクトを任意の数のハッシュと一緒に登録します。レジストリとは、オブジェクトが死ぬと、このオブジェクトの参照アドレスの下にあるハッシュのエントリが削除されることを意味します。これにより、これらのハッシュでのガベージコレクションが保証されます。また、スレッドの複製時に、登録されたハッシュのオブジェクトのエントリが、複製されたオブジェクトの参照アドレスをキーとする更新されたエントリに置き換えられることを意味します。したがって、オブジェクトとデータの関連付けはスレッドセーフになります。</target>
        </trans-unit>
        <trans-unit id="d49a5cf6f714984f5d4aa1ae27ae4adaa45ad30d" translate="yes" xml:space="preserve">
          <source>The problems of garbage collection and thread safety are both addressed by the function &lt;code&gt;register()&lt;/code&gt;. It registers an object together with any number of hashes. Registry means that when the object dies, an entry in any of the hashes under the reference address of this object will be deleted. This guarantees garbage collection in these hashes. It also means that on thread cloning the object's entries in registered hashes will be replaced with updated entries whose key is the cloned object's reference address. Thus the object-data association becomes thread-safe.</source>
          <target state="translated">ガベージコレクションとスレッドセーフの問題は両方とも関数 &lt;code&gt;register()&lt;/code&gt; によって対処されます。オブジェクトを任意の数のハッシュと一緒に登録します。レジストリとは、オブジェクトが停止すると、このオブジェクトの参照アドレスの下にあるハッシュのエントリが削除されることを意味します。これにより、これらのハッシュでのガベージコレクションが保証されます。また、スレッドの複製時に、登録されたハッシュ内のオブジェクトのエントリが、複製されたオブジェクトの参照アドレスをキーとする更新されたエントリに置き換えられることも意味します。したがって、オブジェクトとデータの関連付けはスレッドセーフになります。</target>
        </trans-unit>
        <trans-unit id="4aef2d934929be669275ad225ef041e450d29108" translate="yes" xml:space="preserve">
          <source>The procedure for doing this is roughly as follows (using the example of tonyc's smoke-me branch called win32stat):</source>
          <target state="translated">その手順は大体次のようになります(win32statというtonycのsmoke-meブランチを例にしています)。</target>
        </trans-unit>
        <trans-unit id="9452ac7ff4d68965b2304a021a3f491d59cd9f05" translate="yes" xml:space="preserve">
          <source>The process ID in which the event was generated.</source>
          <target state="translated">イベントが生成されたプロセスID。</target>
        </trans-unit>
        <trans-unit id="95e6fb31b348934a4b1c0d293aa560867eaa2c02" translate="yes" xml:space="preserve">
          <source>The process number of the Perl running this script. Though you</source>
          <target state="translated">このスクリプトを実行しているPerlのプロセス番号。このスクリプトを実行しているPerlのプロセス番号です。</target>
        </trans-unit>
        <trans-unit id="b93ffa0ee1718038fedc8009038c2d7f70371455" translate="yes" xml:space="preserve">
          <source>The process of converting a string to one of the four Unicode &lt;b&gt;casemaps&lt;/b&gt;; in Perl, it is implemented with the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">文字列を4つのUnicode &lt;b&gt;ケースマップの&lt;/b&gt; 1つに変換するプロセス。 Perlでは、これは &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; 関数で実装されます。</target>
        </trans-unit>
        <trans-unit id="7b3ce77cc42e100f56e2fb73208b06058b72b962" translate="yes" xml:space="preserve">
          <source>The process of converting a string to one of the four Unicode &lt;b&gt;casemaps&lt;/b&gt;; in Perl, it is implemented with the &lt;code&gt;fc&lt;/code&gt;, &lt;code&gt;lc&lt;/code&gt;, &lt;code&gt;ucfirst&lt;/code&gt;, and &lt;code&gt;uc&lt;/code&gt; functions.</source>
          <target state="translated">文字列を4つのUnicode&lt;b&gt;ケースマップの&lt;/b&gt;1つに変換するプロセス。 Perlでは、 &lt;code&gt;fc&lt;/code&gt; 、 &lt;code&gt;lc&lt;/code&gt; 、 &lt;code&gt;ucfirst&lt;/code&gt; 、および &lt;code&gt;uc&lt;/code&gt; 関数を使用して実装されます。</target>
        </trans-unit>
        <trans-unit id="2cf36cd26c284e1c84d9c66a1a4b1fbb69c4ead2" translate="yes" xml:space="preserve">
          <source>The process of determining what method should be used is called &lt;b&gt;method resolution&lt;/b&gt;. What Perl does is look at the object's class first (&lt;code&gt;File::MP3&lt;/code&gt; in this case). If that class defines the method, then that class's version of the method is called. If not, Perl looks at each parent class in turn. For &lt;code&gt;File::MP3&lt;/code&gt; , its only parent is &lt;code&gt;File&lt;/code&gt; . If &lt;code&gt;File::MP3&lt;/code&gt; does not define the method, but &lt;code&gt;File&lt;/code&gt; does, then Perl calls the method in &lt;code&gt;File&lt;/code&gt; .</source>
          <target state="translated">使用するメソッドを決定するプロセスは、&lt;b&gt;メソッド解決&lt;/b&gt;と呼ばれ&lt;b&gt;ます&lt;/b&gt;。Perlが行うことは、最初にオブジェクトのクラス（この場合は &lt;code&gt;File::MP3&lt;/code&gt; ）を調べることです。そのクラスがメソッドを定義している場合、そのクラスのメソッドのバージョンが呼び出されます。そうでない場合、Perlは各親クラスを順番に調べます。以下のために &lt;code&gt;File::MP3&lt;/code&gt; 、その唯一の親がある &lt;code&gt;File&lt;/code&gt; 。場合は &lt;code&gt;File::MP3&lt;/code&gt; メソッドを定義していませんが、 &lt;code&gt;File&lt;/code&gt; ない場合、Perlはでメソッドを呼び出し &lt;code&gt;File&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d45b13e98be85d3a3cff56a4de1619efcb5c0e5" translate="yes" xml:space="preserve">
          <source>The process of determining what method should be used is called &lt;b&gt;method resolution&lt;/b&gt;. What Perl does is look at the object's class first (&lt;code&gt;File::MP3&lt;/code&gt; in this case). If that class defines the method, then that class's version of the method is called. If not, Perl looks at each parent class in turn. For &lt;code&gt;File::MP3&lt;/code&gt;, its only parent is &lt;code&gt;File&lt;/code&gt;. If &lt;code&gt;File::MP3&lt;/code&gt; does not define the method, but &lt;code&gt;File&lt;/code&gt; does, then Perl calls the method in &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="translated">どのメソッドを使用するかを決定するプロセスは、&lt;b&gt;メソッド解決&lt;/b&gt;と呼ばれ&lt;b&gt;ます&lt;/b&gt;。Perlが行うことは、最初にオブジェクトのクラス（この場合は &lt;code&gt;File::MP3&lt;/code&gt; ）を調べることです。そのクラスがメソッドを定義している場合、そのクラスのバージョンのメソッドが呼び出されます。そうでない場合、Perlは各親クラスを順番に調べます。以下のために &lt;code&gt;File::MP3&lt;/code&gt; 、その唯一の親がある &lt;code&gt;File&lt;/code&gt; 。場合は &lt;code&gt;File::MP3&lt;/code&gt; メソッドを定義していませんが、 &lt;code&gt;File&lt;/code&gt; ない場合、Perlはでメソッドを呼び出し &lt;code&gt;File&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="080ae8ae51ff51ae8e5ac989879f84eb0a78985b" translate="yes" xml:space="preserve">
          <source>The process of gluing one cat&amp;rsquo;s nose to another cat&amp;rsquo;s tail. Also a similar operation on two &lt;b&gt;strings&lt;/b&gt;.</source>
          <target state="translated">1つの猫の鼻を別の猫の尻尾に接着するプロセス。2つの&lt;b&gt;文字列&lt;/b&gt;に対する同様の操作。</target>
        </trans-unit>
        <trans-unit id="908f91e0beaa0a05d55f4dc47581a39df63d9d61" translate="yes" xml:space="preserve">
          <source>The process of producing a &lt;b&gt;string&lt;/b&gt; representation of an abstract object.</source>
          <target state="translated">抽象オブジェクトの&lt;b&gt;文字列&lt;/b&gt;表現を生成するプロセス。</target>
        </trans-unit>
        <trans-unit id="3e1e79f73acf8d324572f017b3dffb010974336f" translate="yes" xml:space="preserve">
          <source>The process of trying one alternative, seeing if it matches, and moving on to the next alternative, while going back in the string from where the previous alternative was tried, if it doesn't, is called</source>
          <target state="translated">一つの代替案を試してみて、それが一致するかどうかを確認して、次の代替案に移って、もし一致しなければ、前の代替案を試したところから文字列をさかのぼりながら、次の代替案に移っていくというプロセスを</target>
        </trans-unit>
        <trans-unit id="74fa9d2e4258275e6ce9c275f9e0e82d2661aeb2" translate="yes" xml:space="preserve">
          <source>The process of turning source code into a machine-usable form. See &lt;b&gt;compile phase&lt;/b&gt;.</source>
          <target state="translated">ソースコードをマシンで使用可能な形式に変換するプロセス。&lt;b&gt;コンパイルフェーズを&lt;/b&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2c86388b6b25502da94ef398d94ba381de4e7acd" translate="yes" xml:space="preserve">
          <source>The program assumes prior understanding of the internal structure of a Zip file. You should have a copy of the Zip APPNOTE file at hand to help understand the output from this program (&lt;a href=&quot;#SEE-ALSO&quot;&gt;&quot;SEE ALSO&quot;&lt;/a&gt; for details).</source>
          <target state="translated">プログラムは、Zipファイルの内部構造を事前に理解していることを前提としています。このプログラムからの出力を理解しやすくするために、Zip APPNOTEファイルのコピーを手元に用意しておく必要があります（詳細は&lt;a href=&quot;#SEE-ALSO&quot;&gt;「関連&lt;/a&gt;項目」）。</target>
        </trans-unit>
        <trans-unit id="cc5a52491b0f391cb1ad331e975b3decd008b51b" translate="yes" xml:space="preserve">
          <source>The program can be made to run by &quot;laundering&quot; the tainted value through a regular expression: the second example--which still ignores locale information--runs, creating the file named on its command line if it can.</source>
          <target state="translated">プログラムは、正規表現を使って汚染された値を &quot;ロンダリング &quot;することで実行させることができます。 2 番目の例では、ロケール情報を無視していますが、可能であればコマンドライン上に名前のついたファイルを作成して実行します。</target>
        </trans-unit>
        <trans-unit id="71e8e6b13bea2c8688fa8edfd4a4d7df9ffed609" translate="yes" xml:space="preserve">
          <source>The program crashes, &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;s, calls &lt;code&gt;closelog&lt;/code&gt; , the log is over.</source>
          <target state="translated">プログラムがクラッシュし、 &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; sが、呼び出す &lt;code&gt;closelog&lt;/code&gt; ログは終わりました、。</target>
        </trans-unit>
        <trans-unit id="acb249bf3e58472d9c05a98a3d9fd3a22a634ed9" translate="yes" xml:space="preserve">
          <source>The program crashes, &lt;code&gt;die&lt;/code&gt;s, calls &lt;code&gt;closelog&lt;/code&gt;, the log is over.</source>
          <target state="translated">プログラムがクラッシュし、 &lt;code&gt;die&lt;/code&gt; sが、呼び出す &lt;code&gt;closelog&lt;/code&gt; ログは終わりました、。</target>
        </trans-unit>
        <trans-unit id="9f6e033c5ffe643ac5235dd0c4de96e8993b109b" translate="yes" xml:space="preserve">
          <source>The program h2xs is the starting point for creating extensions. In later examples we'll see how we can use h2xs to read header files and generate templates to connect to C routines.</source>
          <target state="translated">プログラム h2xs は,拡張機能を作成するための出発点となるものです.後の例では,ヘッダファイルを読み込んだり,Cルーチンに接続するためのテンプレートを生成したりするためにh2xsをどのように使うかを見ていきましょう.</target>
        </trans-unit>
        <trans-unit id="6480e775a128a11d00bdb33611f7cc04c69a6a31" translate="yes" xml:space="preserve">
          <source>The program has two pieces: Lines 2--7 read the input and build a data structure, and lines 8-13 analyze the data and print out the report. We're going to have a hash, &lt;code&gt;%table&lt;/code&gt; , whose keys are country names, and whose values are references to arrays of city names. The data structure will look like this:</source>
          <target state="translated">プログラムには2つの部分があります。2行目から7行目は入力を読み取ってデータ構造を構築し、8行目から13行目はデータを分析してレポートを印刷します。ハッシュ &lt;code&gt;%table&lt;/code&gt; を作成します。そのキーは国名で、その値は都市名の配列への参照です。データ構造は次のようになります。</target>
        </trans-unit>
        <trans-unit id="467c57531a345de9ffd810bfeb5971919e96c865" translate="yes" xml:space="preserve">
          <source>The program has two pieces: Lines 2-7 read the input and build a data structure, and lines 8-13 analyze the data and print out the report. We're going to have a hash, &lt;code&gt;%table&lt;/code&gt;, whose keys are country names, and whose values are references to arrays of city names. The data structure will look like this:</source>
          <target state="translated">プログラムには2つの部分があります。2〜7行目は入力を読み取ってデータ構造を構築し、8〜13行目はデータを分析してレポートを印刷します。キーが国名で、値が都市名の配列への参照であるハッシュ &lt;code&gt;%table&lt;/code&gt; を作成します。データ構造は次のようになります。</target>
        </trans-unit>
        <trans-unit id="d46a6e0b6bbf3d5823709dce22271813109f1ce6" translate="yes" xml:space="preserve">
          <source>The program is represented by an array of &lt;code&gt;regnode&lt;/code&gt; structures, one or more of which represent a single regop of the program. Struct &lt;code&gt;regnode&lt;/code&gt; is the smallest struct needed, and has a field structure which is shared with all the other larger structures.</source>
          <target state="translated">プログラムは、 &lt;code&gt;regnode&lt;/code&gt; 構造体の配列で表されます。その1つ以上がプログラムの単一のレゴップを表します。構造体 &lt;code&gt;regnode&lt;/code&gt; は必要な最小の構造体であり、他のすべての大きな構造体と共有されるフィールド構造を持っています。</target>
        </trans-unit>
        <trans-unit id="3ea55b0618cf1b22588d3366ef69169df7ae378e" translate="yes" xml:space="preserve">
          <source>The program is represented by an array of &lt;code&gt;regnode&lt;/code&gt; structures, one or more of which represent a single regop of the program. Struct &lt;code&gt;regnode&lt;/code&gt; is the smallest struct needed, and has a field structure which is shared with all the other larger structures. (Outside this document, the term &quot;regnode&quot; is sometimes used to mean &quot;regop&quot;, which could be confusing.)</source>
          <target state="translated">プログラムは、 &lt;code&gt;regnode&lt;/code&gt; 構造の配列で表され、そのうちの1つ以上がプログラムの単一のregopを表します。構造体 &lt;code&gt;regnode&lt;/code&gt; は必要な最小の構造体であり、他のすべての大きな構造体と共有されるフィールド構造体を持っています。（このドキュメント以外では、「regnode」という用語は「regop」を意味するために使用されることがあり、混乱を招く可能性があります。）</target>
        </trans-unit>
        <trans-unit id="135fe1206adbfe007b6735c772853b1eaf66848e" translate="yes" xml:space="preserve">
          <source>The program must take care to ensure that this takes place</source>
          <target state="translated">プログラムは、これが確実に行われるように注意しなければなりません。</target>
        </trans-unit>
        <trans-unit id="c1da64105b623d7426e31c12654e36ae7053e949" translate="yes" xml:space="preserve">
          <source>The program took just over 17 wallclock seconds to run. Note the different values &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; outputs, it's important to always use the same one, and to not confuse what each one means.</source>
          <target state="translated">プログラムの実行には17壁時計秒かかりました。異なる値の &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; 出力に注意してください。常に同じ値を使用し、それぞれの意味を混同しないようにすることが重要です。</target>
        </trans-unit>
        <trans-unit id="453564270c1c0cd5131ab07331c35f9b9398730b" translate="yes" xml:space="preserve">
          <source>The program took just over 17 wallclock seconds to run. Note the different values &lt;code&gt;time&lt;/code&gt; outputs, it's important to always use the same one, and to not confuse what each one means.</source>
          <target state="translated">プログラムの実行には、17秒強かかりました。 &lt;code&gt;time&lt;/code&gt; 出力の値が異なることに注意してください。常に同じ値を使用し、それぞれの意味を混同しないことが重要です。</target>
        </trans-unit>
        <trans-unit id="8912a00ba87d6cbf5df35a3207c6a72bfeb3c965" translate="yes" xml:space="preserve">
          <source>The program will halt</source>
          <target state="translated">プログラムは停止します</target>
        </trans-unit>
        <trans-unit id="267c6b23ea1ed3936b0ecbfc44abd9e2d8aa3502" translate="yes" xml:space="preserve">
          <source>The programming interface is easy to use: it's the same one found in CPAN's &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; module. So, if your applications currently use &lt;a href=&quot;md5&quot;&gt;Digest::MD5&lt;/a&gt; and you'd prefer the stronger security of SHA, it's a simple matter to convert them.</source>
          <target state="translated">プログラミングインターフェイスは使いやすく、CPANの&lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt;モジュールにあるものと同じです。したがって、アプリケーションで現在&lt;a href=&quot;md5&quot;&gt;Digest :: MD5&lt;/a&gt;を使用していて、SHAのより強力なセキュリティを希望する場合は、変換するのは簡単です。</target>
        </trans-unit>
        <trans-unit id="7b1493356cb4a3eba009f1a11b50de871f482665" translate="yes" xml:space="preserve">
          <source>The programming interface is easy to use: it's the same one found in CPAN's &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt; module. So, if your applications currently use &lt;a href=&quot;Digest::MD5&quot;&gt;Digest::MD5&lt;/a&gt; and you'd prefer the stronger security of SHA, it's a simple matter to convert them.</source>
          <target state="translated">プログラミングインターフェイスは使いやすく、CPANの&lt;a href=&quot;digest&quot;&gt;ダイジェスト&lt;/a&gt;モジュールにあるものと同じです。したがって、アプリケーションが現在&lt;a href=&quot;Digest::MD5&quot;&gt;Digest :: MD5&lt;/a&gt;を使用していて、SHAのより強力なセキュリティを希望する場合は、それらを変換するのは簡単です。</target>
        </trans-unit>
        <trans-unit id="d0f12348b1996ab0ae0eb3467409b46f3ff517e5" translate="yes" xml:space="preserve">
          <source>The programs and documentation in this dist are distributed in the hope that they will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</source>
          <target state="translated">この dist に含まれるプログラムとドキュメントは、それらが有用であることを願って配布されていますが、いかなる保証もなく、商品性や特定の目的への適合性についての暗黙の保証もありません。</target>
        </trans-unit>
        <trans-unit id="3b63891b0a81b9b51c173bac879417506124032c" translate="yes" xml:space="preserve">
          <source>The prompt of the cpan shell can contain the current command number for easier tracking of the session or be a plain string.</source>
          <target state="translated">cpan シェルのプロンプトには、セッションの追跡を容易にするために、現在のコマンド番号を含むこともできますし、プレーンな文字列にすることもできます。</target>
        </trans-unit>
        <trans-unit id="a9cf8b59c024e83e18267b0f8a6518d4ffcc35fc" translate="yes" xml:space="preserve">
          <source>The property of lowercase before uppercase letters in EBCDIC is even carried to the Latin 1 EBCDIC pages such as 0037 and 1047. An example would be that &quot;&amp;Euml;&quot; (&lt;code&gt;E WITH DIAERESIS&lt;/code&gt; , 203) comes before &quot;&amp;euml;&quot; (&lt;code&gt;e WITH DIAERESIS&lt;/code&gt; , 235) on an ASCII platform, but the latter (83) comes before the former (115) on an EBCDIC platform. (Astute readers will note that the uppercase version of &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; is simply &quot;SS&quot; and that the upper case versions of &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt; ) are not in the 0..255 range but are in Unicode, in a Unicode enabled Perl).</source>
          <target state="translated">EBCDICの大文字の前の小文字のプロパティは、0037や1047などのLatin 1 EBCDICページにも適用されます。たとえば、「&amp;Euml;」（ &lt;code&gt;E WITH DIAERESIS&lt;/code&gt; 、203）が「&amp;euml;」（ &lt;code&gt;e WITH DIAERESIS&lt;/code&gt; 、235 ）ASCIIプラットフォームでは、後者（83）はEBCDICプラットフォームでは前者（115）より前に来ます。（賢明な読者は、大文字のバージョンの &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; は単に &quot;SS&quot;であり、大文字のバージョンの &quot;&amp;yuml;&quot;（ &lt;code&gt;y WITH DIAERESIS&lt;/code&gt; ）と &quot;&amp;micro;&quot;（ &lt;code&gt;MICRO SIGN&lt;/code&gt; 記号）は、 0..255の範囲ですが、Unicodeです（Unicode対応のPerl）。</target>
        </trans-unit>
        <trans-unit id="d068c61e1d2738a4b949032692f164ea749e79a4" translate="yes" xml:space="preserve">
          <source>The property of lowercase before uppercase letters in EBCDIC is even carried to the Latin 1 EBCDIC pages such as 0037 and 1047. An example would be that &quot;&amp;Euml;&quot; (&lt;code&gt;E WITH DIAERESIS&lt;/code&gt;, 203) comes before &quot;&amp;euml;&quot; (&lt;code&gt;e WITH DIAERESIS&lt;/code&gt;, 235) on an ASCII platform, but the latter (83) comes before the former (115) on an EBCDIC platform. (Astute readers will note that the uppercase version of &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; is simply &quot;SS&quot; and that the upper case versions of &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt;) are not in the 0..255 range but are in Unicode, in a Unicode enabled Perl).</source>
          <target state="translated">EBCDICの大文字の前の小文字のプロパティは、0037や1047などのラテン語1 EBCDICページにも適用されます。例として、「&amp;Euml;」（ &lt;code&gt;E WITH DIAERESIS&lt;/code&gt; 、203）が「&amp;euml;」（ &lt;code&gt;e WITH DIAERESIS&lt;/code&gt; 、235 ）の前に来る場合があります。）ASCIIプラットフォームでは、後者（83）はEBCDICプラットフォームでは前者（115）の前にあります。（賢明な読者は、「&amp;szlig;」の大文字バージョンの &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; は単に「SS」であり、「&amp;yuml;」（小さい &lt;code&gt;y WITH DIAERESIS&lt;/code&gt; ）と「&amp;micro;」（ &lt;code&gt;MICRO SIGN&lt;/code&gt; ）の大文字バージョンは含まれていないことに気付くでしょう。 0..255の範囲ですが、Unicodeであり、Unicode対応のPerlです）。</target>
        </trans-unit>
        <trans-unit id="09b7c3443c95713bb7f5c3a34ea900a666d3209c" translate="yes" xml:space="preserve">
          <source>The protocol (e.g. &lt;code&gt;IPPROTO_TCP&lt;/code&gt; )</source>
          <target state="translated">プロトコル（例： &lt;code&gt;IPPROTO_TCP&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="1d688930b159b0de8e063999fc12f1fc3e668a59" translate="yes" xml:space="preserve">
          <source>The protocol (e.g. &lt;code&gt;IPPROTO_TCP&lt;/code&gt;)</source>
          <target state="translated">プロトコル（例： &lt;code&gt;IPPROTO_TCP&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="16c98cd2a0bd15be4f172d1ada9a2ed6c4ba31c3" translate="yes" xml:space="preserve">
          <source>The protocol also defines several standard &lt;b&gt;translations&lt;/b&gt; which the file can undergo during transfer. These are ASCII, EBCDIC, binary, and byte. ASCII is the default type, and indicates that the sender of files will translate the ends of lines to a standard representation which the receiver will then translate back into their local representation. EBCDIC indicates the file being transferred is in EBCDIC format. Binary (also known as image) format sends the data as a contiguous bit stream. Byte format transfers the data as bytes, the values of which remain the same regardless of differences in byte size between the two machines (in theory - in practice you should only use this if you really know what you're doing). This class does not support the EBCDIC or byte formats, and will default to binary instead if they are attempted.</source>
          <target state="translated">プロトコルはいくつかの標準&lt;b&gt;翻訳&lt;/b&gt;も定義しています&lt;b&gt;&lt;/b&gt;転送中にファイルが受ける可能性のあるもの。これらは、ASCII、EBCDIC、バイナリ、およびバイトです。 ASCIIはデフォルトのタイプであり、ファイルの送信者が行の終わりを標準表現に変換し、受信者が標準表現に変換してローカル表現に戻すことを示します。 EBCDICは、転送されるファイルがEBCDIC形式であることを示します。バイナリ（イメージとも呼ばれる）形式は、データを連続したビットストリームとして送信します。バイト形式は、データをバイトとして転送します。その値は、2つのマシン間のバイトサイズの違いに関係なく同じままです（理論的には、実際には、何をしているのか本当にわかっている場合にのみ使用してください）。このクラスはEBCDICまたはバイト形式をサポートしていません。試みられた場合、代わりにデフォルトでバイナリに設定されます。</target>
        </trans-unit>
        <trans-unit id="3e54303b3641a865f35ca39d2a398386ca07567a" translate="yes" xml:space="preserve">
          <source>The prototype CV for a 'my' sub.</source>
          <target state="translated">俺の」サブのプロトタイプCV。</target>
        </trans-unit>
        <trans-unit id="11a1d81ab8f0f4c68c1c261efa58242791ed97cf" translate="yes" xml:space="preserve">
          <source>The prototype attribute, and any other attributes, come after the signature.</source>
          <target state="translated">プロトタイプ属性やその他の属性は、シグネチャの後に来ます。</target>
        </trans-unit>
        <trans-unit id="571effb91670d02136e12104ead995a6cc16a1c2" translate="yes" xml:space="preserve">
          <source>The prototype attribute, and any other attributes, must come before the signature. The signature always immediately precedes the block of the subroutine's body.</source>
          <target state="translated">prototype属性やその他の属性は、シグネチャの前に来なければなりません。シグネチャは常にサブルーチン本体のブロックの直前にあります。</target>
        </trans-unit>
        <trans-unit id="420268bbe69f10bd1b6ed7fa6d80a149e32d8a64" translate="yes" xml:space="preserve">
          <source>The prototype from the attribute is assigned to the sub immediately after the prototype from the sub, which means that if both are declared at the same time, the traditionally defined prototype is ignored. In other words, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; is indistinguishable from &lt;code&gt;sub foo(@){}&lt;/code&gt; .</source>
          <target state="translated">属性のプロトタイプは、サブのプロトタイプの直後にサブに割り当てられます。つまり、両方が同時に宣言された場合、従来定義されていたプロトタイプは無視されます。つまり、 &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; は &lt;code&gt;sub foo(@){}&lt;/code&gt; と区別できません。</target>
        </trans-unit>
        <trans-unit id="a9e026f2d40529605b03137d9a9ed6ef4bb374c7" translate="yes" xml:space="preserve">
          <source>The prototype from the attribute is assigned to the sub immediately after the prototype from the sub, which means that if both are declared at the same time, the traditionally defined prototype is ignored. In other words, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; is indistinguishable from &lt;code&gt;sub foo(@){}&lt;/code&gt;.</source>
          <target state="translated">属性からのプロトタイプは、サブからのプロトタイプの直後にサブに割り当てられます。つまり、両方が同時に宣言された場合、従来定義されていたプロトタイプは無視されます。つまり、 &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; は &lt;code&gt;sub foo(@){}&lt;/code&gt; と区別できません。</target>
        </trans-unit>
        <trans-unit id="d6eb998a9749fabedff565e15bacf235434a61b2" translate="yes" xml:space="preserve">
          <source>The provided argument MUST be equal to the string for the validation to pass.</source>
          <target state="translated">与えられた引数は、通過するバリデーションのための文字列と等しくなければなりません(MUST)。</target>
        </trans-unit>
        <trans-unit id="113c257205a6110f9be3ea8173531d90a26a925b" translate="yes" xml:space="preserve">
          <source>The provided argument MUST equal one of the elements of the array ref for the validation to pass. An array ref can hold all the above values.</source>
          <target state="translated">与えられた引数は、検証を通過させるために配列 ref の要素のうちの 1 つと等しくなければなりません(MUST)。配列 ref は上記のすべての値を保持することができます。</target>
        </trans-unit>
        <trans-unit id="f0175fe813dc359c6d5d92da9a9b07e142152ec0" translate="yes" xml:space="preserve">
          <source>The provided argument MUST match the regular expression for the validation to pass.</source>
          <target state="translated">指定された引数は、通過するバリデーションの正規表現と一致しなければなりません(MUST)。</target>
        </trans-unit>
        <trans-unit id="7028c08ff6edd9122ed07f747d04ab21bb6b6da9" translate="yes" xml:space="preserve">
          <source>The provided subroutine MUST return true in order for the validation to pass and the argument accepted.</source>
          <target state="translated">提供されるサブルーチンは、検証が通過し、引数が受け入れられるようにするためには、trueを返さなければなりません(MUST)。</target>
        </trans-unit>
        <trans-unit id="93c41fbabb74d3c7cddc4b5e78899f8faa1b1f17" translate="yes" xml:space="preserve">
          <source>The pseudo-hash feature was an experimental feature introduced in earlier versions of Perl and removed in 5.10.0. A pseudo-hash is an array reference which can be accessed using named keys like a hash. You may run in to some code in the wild which uses it. See the &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma for more information.</source>
          <target state="translated">疑似ハッシュ機能は、以前のバージョンのPerlで導入された実験的な機能であり、5.10.0で削除されました。疑似ハッシュは、ハッシュのような名前付きキーを使用してアクセスできる配列参照です。あなたはそれを使う野生のコードに出くわすかもしれません。詳細については、&lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt;プラグマを参照してください。</target>
        </trans-unit>
        <trans-unit id="2c3bf5ebc790603d27cda992131fe6f16a627371" translate="yes" xml:space="preserve">
          <source>The public API must remain consistent, i.e. if a sub-class is overloading addition, the sub-class must use the same name, in this case badd(). The reason for this is that Math::BigInt is optimized to call the object methods directly.</source>
          <target state="translated">つまり、サブクラスが加算をオーバーロードしている場合、サブクラスは同じ名前、この場合は badd()を使用しなければなりません。これは Math::BigInt がオブジェクトメソッドを直接呼び出すように最適化されているためです。</target>
        </trans-unit>
        <trans-unit id="dc2995512c58b9b2e35d09bc546dc5a7fbc84663" translate="yes" xml:space="preserve">
          <source>The purpose of the macro &lt;code&gt;SPAGAIN&lt;/code&gt; is to refresh the local copy of the stack pointer. This is necessary because it is possible that the memory allocated to the Perl stack has been reallocated during the</source>
          <target state="translated">マクロ &lt;code&gt;SPAGAIN&lt;/code&gt; の目的は、スタックポインターのローカルコピーを更新することです。これは、Perlスタックに割り当てられたメモリが、</target>
        </trans-unit>
        <trans-unit id="211ca4f47d195354704ae118cbe1d64c1c871ea0" translate="yes" xml:space="preserve">
          <source>The purpose of the pragma is to alert users to the status of such a module by issuing a warning that encourages them to install the module from CPAN, so that a future upgrade to a perl which omits the module will not break their code.</source>
          <target state="translated">pragmaの目的は、CPANからモジュールをインストールするように促す警告を発行して、そのようなモジュールの状態をユーザに警告することで、将来、モジュールを省略したperlにアップグレードしてもコードを壊さないようにすることです。</target>
        </trans-unit>
        <trans-unit id="b29cd6102fd964c85b9f311d0c28db3fab69123d" translate="yes" xml:space="preserve">
          <source>The purpose of the testing is twofold: one, to help developers fix any problems in their code that crop up because of lack of testing on other platforms; two, to provide users with information about whether a given module works on a given platform.</source>
          <target state="translated">1つは、他のプラットフォームでのテストが不足しているために発生したコードの問題を開発者が修正できるようにすること、もう1つは、特定のモジュールが特定のプラットフォームで動作するかどうかについての情報をユーザに提供することです。</target>
        </trans-unit>
        <trans-unit id="a5dd5b4e9fced711b08542f3e0ab81c18273f9bd" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to document what has been deprecated in Perl, and by which version the deprecated feature will disappear, or, for already removed features, when it was removed.</source>
          <target state="translated">この文書の目的は、Perl で非推奨になったものを文書化することであり、非推奨になった機能はどのバージョンまでに消滅するのか、あるいは既に削除された機能については、いつ削除されたのかを文書化することです。</target>
        </trans-unit>
        <trans-unit id="843821edac19011f1a6d1c830e78298f0013f7a5" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to show you how to call Perl subroutines directly from C, i.e., how to write</source>
          <target state="translated">このドキュメントの目的は、PerlのサブルーチンをCから直接呼び出す方法、つまり</target>
        </trans-unit>
        <trans-unit id="414e7fd5b34fea33393baf5db076f7ff8658e79f" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to provide a wide range of testing utilities. Various ways to say &quot;ok&quot; with better diagnostics, facilities to skip tests, test future features and compare complicated data structures. While you can do almost anything with a simple &lt;code&gt;ok()&lt;/code&gt; function, it doesn't provide good diagnostic output.</source>
          <target state="translated">このモジュールの目的は、幅広いテストユーティリティを提供することです。優れた診断機能、テストをスキップする機能、将来の機能をテストする機能、複雑なデータ構造を比較する機能で「大丈夫」と言うさまざまな方法。単純な &lt;code&gt;ok()&lt;/code&gt; 関数でほとんど何でも実行できますが、優れた診断出力は提供されません。</target>
        </trans-unit>
        <trans-unit id="9bfc8ef428f97c3f3e1176a68cf8e1112929bebf" translate="yes" xml:space="preserve">
          <source>The purpose, scope and target applications of your module</source>
          <target state="translated">モジュールの目的、範囲、ターゲットアプリケーション</target>
        </trans-unit>
        <trans-unit id="cb81c6a18976d12ebe998a0a0b9af8a1bf213151" translate="yes" xml:space="preserve">
          <source>The pyramids.</source>
          <target state="translated">ピラミッドだ</target>
        </trans-unit>
        <trans-unit id="ddc9dd67da090624c445edfafa6830e5bccd4e64" translate="yes" xml:space="preserve">
          <source>The quality that makes you go to great effort to reduce overall energy expenditure. It makes you write labor-saving programs that other people will find useful, and then document what you wrote so you don&amp;rsquo;t have to answer so many questions about it. Hence, the first great virtue of a programmer. Also hence, this book. See also &lt;b&gt;impatience&lt;/b&gt; and &lt;b&gt;hubris&lt;/b&gt;.</source>
          <target state="translated">全体的なエネルギー消費を削減するために多大な努力を払わせる品質。他の人が役に立つと思う省力プログラムを書いて、それからあなたが書いたものを文書化するので、それに関する多くの質問に答える必要はありません。したがって、プログラマーの最初の大きな美徳。また、したがって、この本。&lt;b&gt;焦り&lt;/b&gt;や&lt;b&gt;傲慢&lt;/b&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="52d7089e85ac35a7092bc58942f32bee7ca90b8d" translate="yes" xml:space="preserve">
          <source>The question of string equivalence turns somewhat complicated in Unicode: what do you mean by &quot;equal&quot;?</source>
          <target state="translated">文字列の等価性の問題は、ユニコードではやや複雑になります:「等価」とは何を意味するのでしょうか?</target>
        </trans-unit>
        <trans-unit id="f2a24b3b2648553142b8c5a0c4598996a73f792a" translate="yes" xml:space="preserve">
          <source>The question remains on when the SVs which are</source>
          <target state="translated">疑問が残るのは、いつになったら</target>
        </trans-unit>
        <trans-unit id="099c0ce39a19f948a86d0ea40fc49e8ea2b14385" translate="yes" xml:space="preserve">
          <source>The question, of course, is why would you do something like this? Why create a semaphore with a starting count that's not one, or why decrement or increment it by more than one? The answer is resource availability. Many resources that you want to manage access for can be safely used by more than one thread at once.</source>
          <target state="translated">もちろん問題は、なぜこのようなことをするのかということです。なぜ開始カウントが1ではないセマフォを作るのか、なぜそれを1以上デクリメントしたりインクリメントしたりするのか?答えはリソースの可用性です。アクセスを管理したいリソースの多くは、一度に複数のスレッドで安全に使用することができます。</target>
        </trans-unit>
        <trans-unit id="7e4709a385e818a7adc04721b36836ff38439abe" translate="yes" xml:space="preserve">
          <source>The quick answer is because they are easy to implement yourself. The long answer is that to write these in such a way that multiple platforms are supported correctly would just require too much code. Below are some examples how you can implement these yourself.</source>
          <target state="translated">手っ取り早い答えは、自分で実装するのが簡単だからです。長い答えは、複数のプラットフォームが正しくサポートされるようにこれらを書くには、あまりにも多くのコードが必要になるということです。以下に、これらを自分で実装する方法の例をいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="551d1aa8a1248eaf53c1cd9d606d72ab7488cd21" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty method only works well when you don't plan to leave the commented code in the source. If a Pod parser comes along, your multiline comment is going to show up in the Pod translation. A better way hides it from Pod parsers as well.</source>
          <target state="translated">この方法がうまく機能するのは、コメント付きのコードをソースに残す予定がない場合だけです。Podパーサーが現れた場合、あなたの複数行コメントがPod翻訳に表示されてしまいます。より良い方法は、Podパーサーからも隠すことができます。</target>
        </trans-unit>
        <trans-unit id="a41d7294035834639b17968992ffda16ae85e9a1" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty way to comment out more than one line of Perl is to surround those lines with Pod directives. You have to put these directives at the beginning of the line and somewhere where Perl expects a new statement (so not in the middle of statements like the &lt;code&gt;#&lt;/code&gt; comments). You end the comment with &lt;code&gt;=cut&lt;/code&gt; , ending the Pod section:</source>
          <target state="translated">Perlの複数の行をコメントアウトする簡単な方法は、それらの行をPodディレクティブで囲むことです。これらのディレクティブは、行の先頭と、Perlが新しいステートメントを予期する場所（つまり、 &lt;code&gt;#&lt;/code&gt; コメントなどのステートメントの途中ではない場所）に配置する必要があります。コメントは &lt;code&gt;=cut&lt;/code&gt; で終了し、ポッドセクションを終了します。</target>
        </trans-unit>
        <trans-unit id="d90a105b257205ce48226d803e75858a07587fa6" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty way to comment out more than one line of Perl is to surround those lines with Pod directives. You have to put these directives at the beginning of the line and somewhere where Perl expects a new statement (so not in the middle of statements like the &lt;code&gt;#&lt;/code&gt; comments). You end the comment with &lt;code&gt;=cut&lt;/code&gt;, ending the Pod section:</source>
          <target state="translated">Perlの複数の行をコメントアウトするための手っ取り早い方法は、それらの行をPodディレクティブで囲むことです。これらのディレクティブは、行の先頭と、Perlが新しいステートメントを期待する場所に配置する必要があります（したがって、 &lt;code&gt;#&lt;/code&gt; コメントのようなステートメントの途中ではありません）。コメントを &lt;code&gt;=cut&lt;/code&gt; で終了し、ポッドセクションを終了します。</target>
        </trans-unit>
        <trans-unit id="0c2f3594848e5558e5b1bcd7932b24c116883439" translate="yes" xml:space="preserve">
          <source>The quotient is always the greatest integer less than or equal to the real-valued quotient of the two operands, and the remainder (when it is non-zero) always has the same sign as the second operand; so, for example,</source>
          <target state="translated">商は常に2つのオペランドの実数商以下の最大の整数であり、余剰(それが0でない場合)は常に2番目のオペランドと同じ符号を持ちます。</target>
        </trans-unit>
        <trans-unit id="04db20aec07e3c7b83de9b23243f0bb2ef9f279e" translate="yes" xml:space="preserve">
          <source>The random characters are provided by File::Temp and ensure that each module's individual build directory is unique. This makes running CPAN.pm in concurrent processes simultaneously safe.</source>
          <target state="translated">ランダムな文字は File::Temp によって提供され、各モジュールの個別のビルドディレクトリが一意であることを保証します。これにより、CPAN.pm を同時並行プロセスで同時に実行することが安全になります。</target>
        </trans-unit>
        <trans-unit id="054e3d7058644b114207f253c83eb2c8a141a8e1" translate="yes" xml:space="preserve">
          <source>The range operator (in list context) makes use of the magical auto-increment algorithm if the operands are strings. You can say</source>
          <target state="translated">range演算子(リストコンテキスト)は、オペランドが文字列である場合、魔法のオートインクリメントアルゴリズムを使用します。以下のように言うことができます。</target>
        </trans-unit>
        <trans-unit id="4828534433b64aecd95537d37d705a006ad5851e" translate="yes" xml:space="preserve">
          <source>The range operator &lt;code&gt;..&lt;/code&gt; cannot be overloaded.</source>
          <target state="translated">範囲演算子 &lt;code&gt;..&lt;/code&gt; はオーバーロードできません。</target>
        </trans-unit>
        <trans-unit id="bc508fe7a659eeced29e856ebc7b8d62470c6bbb" translate="yes" xml:space="preserve">
          <source>The range operator also works on strings, using the magical auto-increment, see below.</source>
          <target state="translated">範囲演算子は文字列に対しても動作します。</target>
        </trans-unit>
        <trans-unit id="31d3e334c25d2382911ee65d3fae61de81e23584" translate="yes" xml:space="preserve">
          <source>The range operator in list context can make use of the magical auto-increment algorithm if both operands are strings, subject to the following rules:</source>
          <target state="translated">リストコンテキストのrange演算子は、両方のオペランドが文字列である場合、以下のルールに従って、魔法のオートインクリメントアルゴリズムを使用することができます。</target>
        </trans-unit>
        <trans-unit id="e7f8ca3eb25d07981f64e697003d81f247478aa9" translate="yes" xml:space="preserve">
          <source>The range operator is &quot;..&quot;, not comma. The comma operator works as in C.</source>
          <target state="translated">範囲演算子はカンマではなく「...」です。カンマ演算子はC言語と同じように動作します。</target>
        </trans-unit>
        <trans-unit id="6b43593ef7e3f96c529ec6f6490c77d15e8ee949" translate="yes" xml:space="preserve">
          <source>The range operator is &lt;code&gt;...&lt;/code&gt; , rather than comma.</source>
          <target state="translated">範囲演算子は、コンマではなく &lt;code&gt;...&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="6702b09bbe69f958fa5f9869c6ae81b0c789760d" translate="yes" xml:space="preserve">
          <source>The range operator is &lt;code&gt;...&lt;/code&gt;, rather than comma.</source>
          <target state="translated">範囲演算子は、コンマではなく &lt;code&gt;...&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="41fb6d64bc39d2dbbf811ff985ded944bd6951e6" translate="yes" xml:space="preserve">
          <source>The rationale for inclusion in this module is that the function performs some work for which an XS implementation is essential because it cannot be implemented in Pure Perl, and which is sufficiently-widely used across CPAN that its popularity warrants inclusion in a core module, which this is.</source>
          <target state="translated">このモジュールに含める理由は、この関数は、Pure Perlでは実装できないためXSの実装が必要不可欠な作業を行い、CPAN全体で十分に広く利用されているため、コアモジュールに含める必要があるからです。</target>
        </trans-unit>
        <trans-unit id="272be5d09f375bcf2f8787674ae6b79aa38f8abf" translate="yes" xml:space="preserve">
          <source>The rationale for requiring this is to not break older programs that rely on the way things worked before Unicode came along. Those older programs knew only about the ASCII character set, and so may not work properly for additional characters. When a string is encoded in UTF-8, Perl assumes that the program is prepared to deal with Unicode, but when the string isn't, Perl assumes that only ASCII is wanted, and so those characters that are not ASCII characters aren't recognized as to what they would be in Unicode. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; tells Perl to treat all characters as Unicode, whether the string is encoded in UTF-8 or not, thus avoiding the problem.</source>
          <target state="translated">これを要求する根拠は、Unicodeが登場する前に物事が機能する方法に依存する古いプログラムを壊さないことです。これらの古いプログラムはASCII文字セットのみを認識していたため、追加の文字に対しては正しく機能しない可能性があります。文字列がUTF-8でエンコードされている場合、PerlはプログラムがUnicodeを処理する準備ができていると想定しますが、文字列がエンコードされていない場合、PerlはASCIIのみが必要であると想定し、ASCII文字以外の文字は不要ですそれらがユニコードで何になるかについて認識されました。 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;すると、文字列がUTF-8でエンコードされているかどうかに関係なく、すべての文字をUnicodeとして扱うようにPerlに指示し、問題を回避します。</target>
        </trans-unit>
        <trans-unit id="cd600fcbf1a6b70419da39d25dfcf62c3af89b3f" translate="yes" xml:space="preserve">
          <source>The rationale for requiring this is to not break older programs that rely on the way things worked before Unicode came along. Those older programs knew only about the ASCII character set, and so may not work properly for additional characters. When a string is encoded in UTF-8, Perl assumes that the program is prepared to deal with Unicode, but when the string isn't, Perl assumes that only ASCII is wanted, and so those characters that are not ASCII characters aren't recognized as to what they would be in Unicode. &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; tells Perl to treat all characters as Unicode, whether the string is encoded in UTF-8 or not, thus avoiding the problem.</source>
          <target state="translated">これを要求する理由は、Unicodeが登場する前の動作方法に依存する古いプログラムを壊さないことです。これらの古いプログラムはASCII文字セットしか知らなかったため、追加の文字では正しく機能しない可能性があります。文字列がUTF-8でエンコードされている場合、PerlはプログラムがUnicodeを処理する準備ができていると見なしますが、文字列がそうでない場合、PerlはASCIIのみが必要であると見なします。したがって、ASCII文字ではない文字は必要ありません。それらがUnicodeでどうなるかについて認識されました。 &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; は、文字列がUTF-8でエンコードされているかどうかに関係なく、すべての文字をUnicodeとして扱うようにPerlに指示するため、問題を回避できます。</target>
        </trans-unit>
        <trans-unit id="062d7f6e6f9ffa42523f91b3b98af5b6e21dddc1" translate="yes" xml:space="preserve">
          <source>The raw floppy disk. Doesn't work under Windows 95. This allows you to read or write raw sectors of the floppy disk and to use &lt;code&gt;DeviceIoControl&lt;/code&gt; to perform miscellaneous queries and operations to the floppy disk or drive.</source>
          <target state="translated">生のフロッピーディスク。Windows 95では機能しません。これにより、フロッピーディスクのrawセクターの読み取りまたは書き込みが可能になり、 &lt;code&gt;DeviceIoControl&lt;/code&gt; を使用してフロッピーディスクまたはドライブに対してさまざまなクエリや操作を実行できます。</target>
        </trans-unit>
        <trans-unit id="62a00a9112198d60e9e6e148f4efbf8b5c8bde2f" translate="yes" xml:space="preserve">
          <source>The raw original L&amp;lt;...&amp;gt; content, before text is split on &quot;|&quot;, &quot;/&quot;, etc, and before E&amp;lt;...&amp;gt; codes are expanded.</source>
          <target state="translated">テキストが「|」、「/」などで分割される前、およびE &amp;lt;...&amp;gt;コードが展開される前の元の元のL &amp;lt;...&amp;gt;コンテンツ。</target>
        </trans-unit>
        <trans-unit id="16f6921cb27bb9d796f9843804daa8d9f88db314" translate="yes" xml:space="preserve">
          <source>The read-only magic variable &lt;code&gt;${^UNICODE}&lt;/code&gt; reflects the numeric value of this setting. This variable is set during Perl startup and is thereafter read-only. If you want runtime effects, use the three-arg open() (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;), the two-arg binmode() (see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;), and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;).</source>
          <target state="translated">読み取り専用のマジック変数 &lt;code&gt;${^UNICODE}&lt;/code&gt; は、この設定の数値を反映しています。この変数はPerlの起動時に設定され、その後は読み取り専用になります。ランタイム効果が必要な場合は、3つの引数のopen（）（&lt;a href=&quot;functions/open&quot;&gt;openを&lt;/a&gt;参照）、2つの引数のbinmode（）（&lt;a href=&quot;functions/binmode&quot;&gt;binmodeを&lt;/a&gt;参照）、および &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; プラグマ（&lt;a href=&quot;open&quot;&gt;openを&lt;/a&gt;参照）を使用してください。</target>
        </trans-unit>
        <trans-unit id="7133d99787afc8bed88333155f330e0814f3badc" translate="yes" xml:space="preserve">
          <source>The read-only magic variable &lt;code&gt;${^UNICODE}&lt;/code&gt; reflects the numeric value of this setting. This variable is set during Perl startup and is thereafter read-only. If you want runtime effects, use the three-arg open() (see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;), the two-arg binmode() (see &lt;a href=&quot;perlfunc#binmode&quot;&gt;&quot;binmode&quot; in perlfunc&lt;/a&gt;), and the &lt;code&gt;open&lt;/code&gt; pragma (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;).</source>
          <target state="translated">読み取り専用の魔法の変数 &lt;code&gt;${^UNICODE}&lt;/code&gt; は、この設定の数値を反映しています。この変数はPerlの起動時に設定され、その後は読み取り専用になります。ランタイム効果が必要な場合は、3引数のopen（）（&lt;a href=&quot;perlfunc#open&quot;&gt;perlfuncの「open」を参照&lt;/a&gt;）、2引数のbinmode（）（&lt;a href=&quot;perlfunc#binmode&quot;&gt;perlfuncの「binmode」を参照&lt;/a&gt;）、および &lt;code&gt;open&lt;/code&gt; プラグマ（&lt;a href=&quot;open&quot;&gt;openを&lt;/a&gt;参照）を使用します。</target>
        </trans-unit>
        <trans-unit id="8ac185b6e70958a0bc2daae47b4a77ca571d1fad" translate="yes" xml:space="preserve">
          <source>The real gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getgid()&lt;/code&gt; , and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt; , one of which may be the same as the first number.</source>
          <target state="translated">このプロセスの本当のgid。あなたは、同時に複数のグループでのサポートメンバーシップは、スペースを与えることをマシン上にある場合は、あなたがしているグループのリストを区切ります。最初の数はで返さ一つです &lt;code&gt;getgid()&lt;/code&gt; によると、それに続くもの &lt;code&gt;getgroups()&lt;/code&gt; 、5月の1最初の番号と同じである。</target>
        </trans-unit>
        <trans-unit id="1b0d46bf2b89fe3b91282dbaf19dbfd7a631baf9" translate="yes" xml:space="preserve">
          <source>The real gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getgid()&lt;/code&gt;, and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt;, one of which may be the same as the first number.</source>
          <target state="translated">このプロセスの本当のギッド。あなたは、同時に複数のグループでのサポートメンバーシップは、スペースを与えることをマシン上にある場合は、あなたがしているグループのリストを区切ります。最初の数はで返さ一つです &lt;code&gt;getgid()&lt;/code&gt; によると、それに続くもの &lt;code&gt;getgroups()&lt;/code&gt; 、5月の1最初の番号と同じである必要があります。</target>
        </trans-unit>
        <trans-unit id="c41410f8fa129356669d6ff84f5e22cd64e4d0cb" translate="yes" xml:space="preserve">
          <source>The real sequence number of the OP, as a regular number and not adjusted to be relative to the start of the real program. (This will generally be a fairly large number because all of &lt;b&gt;B::Concise&lt;/b&gt; is compiled before your program is).</source>
          <target state="translated">OPの実際のシーケンス番号。通常の番号であり、実際のプログラムの開始に関連するように調整されていません。（&lt;b&gt;B :: Conciseの&lt;/b&gt;すべてがプログラムの前にコンパイルされるため、これは一般にかなり大きな数になります）。</target>
        </trans-unit>
        <trans-unit id="520aa3cfc6d3d06d2079bcf3cd80538cdc94136b" translate="yes" xml:space="preserve">
          <source>The real time timing is done using time(2) and the granularity is therefore only one second.</source>
          <target state="translated">リアルタイムのタイミングはtime(2)を使用して行われるため、粒度は1秒しかありません。</target>
        </trans-unit>
        <trans-unit id="000f9aa1d39e9791c956bd280884dcab10bddcf9" translate="yes" xml:space="preserve">
          <source>The real uid of this process. You can change both the real uid and the effective uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt; . Since changes to &lt;code&gt;$&amp;lt;&lt;/code&gt; require a system call, check &lt;code&gt;$!&lt;/code&gt; after a change attempt to detect any possible errors.</source>
          <target state="translated">このプロセスの実際のuid。 &lt;code&gt;POSIX::setuid()&lt;/code&gt; を使用すると、実際のuidと有効なuidの両方を同時に変更できます。 &lt;code&gt;$&amp;lt;&lt;/code&gt; 変更にはシステムコールが必要なので、 &lt;code&gt;$!&lt;/code&gt; を確認してください。変更後、考えられるエラーを検出しようとしました。</target>
        </trans-unit>
        <trans-unit id="2ac048e62e66a7879f9411bea5e557339bb43fff" translate="yes" xml:space="preserve">
          <source>The real uid of this process. You can change both the real uid and the effective uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt;. Since changes to &lt;code&gt;$&amp;lt;&lt;/code&gt; require a system call, check &lt;code&gt;$!&lt;/code&gt; after a change attempt to detect any possible errors.</source>
          <target state="translated">このプロセスの実際のuid。 &lt;code&gt;POSIX::setuid()&lt;/code&gt; を使用して、実際のuidと有効なuidの両方を同時に変更できます。 &lt;code&gt;$&amp;lt;&lt;/code&gt; への変更にはシステムコールが必要なので、$を確認してください &lt;code&gt;$!&lt;/code&gt; 変更後、考えられるエラーを検出しようとします。</target>
        </trans-unit>
        <trans-unit id="226998a781d1d6550060a07be6fe5dd8d2b4b4b4" translate="yes" xml:space="preserve">
          <source>The real work is done in the standard typemap.</source>
          <target state="translated">実際の作業は標準のタイプマップで行います。</target>
        </trans-unit>
        <trans-unit id="c08e193bbc2bcd92c562519697a3487f212bcddb" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;encode_language_tag&lt;/code&gt; exists is because different language tags may represent the same language; this is normally treatable with &lt;code&gt;same_language_tag&lt;/code&gt; , but consider this situation:</source>
          <target state="translated">&lt;code&gt;encode_language_tag&lt;/code&gt; が存在する理由は、異なる言語タグが同じ言語を表す可能性があるためです。これは通常、 &lt;code&gt;same_language_tag&lt;/code&gt; で処理できますが、次の状況を考慮してください。</target>
        </trans-unit>
        <trans-unit id="3ce46cd4af70310d3ca26a396ea6fdf7fb3672f3" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;encode_language_tag&lt;/code&gt; exists is because different language tags may represent the same language; this is normally treatable with &lt;code&gt;same_language_tag&lt;/code&gt;, but consider this situation:</source>
          <target state="translated">&lt;code&gt;encode_language_tag&lt;/code&gt; が存在する理由は、異なる言語タグが同じ言語を表す可能性があるためです。これは通常 &lt;code&gt;same_language_tag&lt;/code&gt; で処理できますが、次の状況を考慮してください。</target>
        </trans-unit>
        <trans-unit id="ca772eb153fd56cb7e89f09b86319ec24565520e" translate="yes" xml:space="preserve">
          <source>The reason I said &quot;in this instance&quot; is because that</source>
          <target state="translated">今回は」と言ったのは、それが</target>
        </trans-unit>
        <trans-unit id="739ee83789116c83fd6d7b4456cdd5e4f5143663" translate="yes" xml:space="preserve">
          <source>The reason for not checking the return value from print() is because of pipe buffering; physical writes are delayed. That won't blow up until the close, and it will blow up with a SIGPIPE. To catch it, you could use this:</source>
          <target state="translated">print()からの戻り値をチェックしない理由は、パイプバッファリングのためで、物理的な書き込みは遅延します。これではcloseまで吹っ飛ばされず、sigpipeで吹っ飛んでしまいます。それをキャッチするには、これを使うといいでしょう。</target>
        </trans-unit>
        <trans-unit id="5243164bf937a2da41254af85f8953f57eda8b63" translate="yes" xml:space="preserve">
          <source>The reason for the bailout.</source>
          <target state="translated">救済の理由。</target>
        </trans-unit>
        <trans-unit id="ff2ad92ed56d2b83c1783a3daf037c2fcef9e124" translate="yes" xml:space="preserve">
          <source>The reason for the exception.</source>
          <target state="translated">例外の理由。</target>
        </trans-unit>
        <trans-unit id="58e74d3011543f0cacc6e865a92179ab3feabba8" translate="yes" xml:space="preserve">
          <source>The reason for the skip, todo etc. See &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; for more details.</source>
          <target state="translated">スキップ、todoなどの理由。詳細については、&lt;a href=&quot;Test::Builder&quot;&gt;Test :: Builder&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b3e75d2f4213b8c35d2937b292cccac3d8a1e38d" translate="yes" xml:space="preserve">
          <source>The reason for this is that CPAN does not know the dependencies of all modules when it starts out. To decide about the additional items to install, it just uses data found in the META.yml file or the generated Makefile. An undetected missing piece breaks the process. But it may well be that your Bundle installs some prerequisite later than some depending item and thus your second try is able to resolve everything. Please note, CPAN.pm does not know the dependency tree in advance and cannot sort the queue of things to install in a topologically correct order. It resolves perfectly well &lt;b&gt;if&lt;/b&gt; all modules declare the prerequisites correctly with the PREREQ_PM attribute to MakeMaker or the &lt;code&gt;requires&lt;/code&gt; stanza of Module::Build. For bundles which fail and you need to install often, it is recommended to sort the Bundle definition file manually.</source>
          <target state="translated">これは、CPANが起動時にすべてのモジュールの依存関係を認識していないためです。インストールする追加のアイテムを決定するために、META.ymlファイルまたは生成されたMakefileにあるデータを使用します。検出されなかった欠落片はプロセスを中断します。しかし、バンドルがいくつかの前提条件アイテムよりも後にいくつかの前提条件をインストールするため、2回目の試行ですべてを解決できる可能性があります。 CPAN.pmは事前に依存関係ツリーを認識していないため、インストールするもののキューをトポロジ的に正しい順序で並べ替えることはできません。すべてのモジュールが、PREREQ_PM属性をMakeMakerまたは要件に使用して前提条件を正しく宣言している&lt;b&gt;場合、問題&lt;/b&gt;は完全に解決され &lt;code&gt;requires&lt;/code&gt; Module :: Buildのスタンザ。失敗し、頻繁にインストールする必要があるバンドルの場合、バンドル定義ファイルを手動でソートすることをお勧めします。</target>
        </trans-unit>
        <trans-unit id="9dfe6b3d7e7af99fa8c5c069ac28ca23f9e16764" translate="yes" xml:space="preserve">
          <source>The reason for this is that the &lt;a href=&quot;version#numify%28%29&quot;&gt;numify()&lt;/a&gt; operator will turn &quot;v1.0&quot; into the equivalent string &quot;1.000000&quot;. Forcing the outer version object to &lt;a href=&quot;version#normal%28%29&quot;&gt;normal()&lt;/a&gt; form will display the mathematically equivalent &quot;v1.0.0&quot;.</source>
          <target state="translated">これは、&lt;a href=&quot;version#numify%28%29&quot;&gt;numify（）&lt;/a&gt;演算子が「v1.0」を同等の文字列「1.000000」に変換するためです。外部バージョンオブジェクトを&lt;a href=&quot;version#normal%28%29&quot;&gt;normal（）&lt;/a&gt;形式に強制すると、数学的に同等の「v1.0.0」が表示されます。</target>
        </trans-unit>
        <trans-unit id="5fa379384b7d494ede930080ac4d01947c2521a8" translate="yes" xml:space="preserve">
          <source>The reason for this unusability is that a fundamental assumption of Perl is that the characters it cares about for parsing and lexical analysis are the same whether or not the text is in UTF-8. For example, Perl expects the character &lt;code&gt;&quot;[&quot;&lt;/code&gt; to have the same representation, no matter if the string containing it (or program text) is UTF-8 encoded or not. To ensure this, Perl adapts UTF-EBCDIC to the particular code page so that all characters it expects to be UTF-8 invariant are in fact UTF-8 invariant. This means that text generated on a computer running one version of Perl's UTF-EBCDIC has to be translated to be intelligible to a computer running another.</source>
          <target state="translated">この使用不能の理由は、Perlの基本的な仮定が、テキストがUTF-8であるかどうかに関係なく、Persが解析と字句解析に使用する文字が同じであることです。たとえば、Perlでは、文字 &lt;code&gt;&quot;[&quot;&lt;/code&gt; は、それを含む文字列（またはプログラムテキスト）がUTF-8でエンコードされているかどうかに関係なく、同じ表現であると想定しています。これを確実にするために、PerlはUTF-EBCDICを特定のコードページに適合させ、UTF-8不変であると期待されるすべての文字が実際にはUTF-8不変であるようにします。つまり、あるバージョンのPerlのUTF-EBCDICを実行しているコンピューターで生成されたテキストは、別のバージョンを実行しているコンピューターが理解できるように翻訳する必要があります。</target>
        </trans-unit>
        <trans-unit id="148e8f8b4033e043ed0349ade3e3972ed042dff2" translate="yes" xml:space="preserve">
          <source>The reason is that Encode::Guess guesses encoding by trial and error. It first splits $data into lines and tries to decode the line for each suspect. It keeps it going until all but one encoding is eliminated out of suspects list. ISO-8859 series is just too successful for most cases (because it fills almost all code points in \x00-\xff).</source>
          <target state="translated">その理由は、Encode::Guessが試行錯誤しながらエンコードを推測するからです。最初に $data を行に分割し、各容疑者についてその行をデコードしようとします。これを、1つのエンコーディングを除いたすべてのエンコーディングが容疑者リストから除外されるまで続けます。ISO-8859シリーズは、ほとんどの場合で成功しすぎている。</target>
        </trans-unit>
        <trans-unit id="94742df1b378e1ee0c32933e905c9b3866f15f37" translate="yes" xml:space="preserve">
          <source>The reason is that variable interpolation and code expressions together pose a security risk. The combination is dangerous because many programmers who write search engines often take user input and plug it directly into a regexp:</source>
          <target state="translated">変数補間とコード式を一緒にするとセキュリティ上のリスクがあるからです。検索エンジンを書くプログラマーの多くが、ユーザーの入力を取って直接正規表現に差し込むことが多いので、この組み合わせは危険です。</target>
        </trans-unit>
        <trans-unit id="c8fa70ef72504bbb3f7d6986506b4705b0ceb70a" translate="yes" xml:space="preserve">
          <source>The reason is that vendor encoding is usually a superset of national standard so it becomes too ambiguous for most cases.</source>
          <target state="translated">その理由は、ベンダエンコーディングは通常、国家標準のスーパーセットなので、ほとんどの場合、あまりにも曖昧になってしまうからです。</target>
        </trans-unit>
        <trans-unit id="76e332a13c138bbbc50c17d9967b9928970c16a2" translate="yes" xml:space="preserve">
          <source>The reason it isn't quite a drop-in replacement is actually an advantage. The only difference is that it returns &lt;code&gt;const char *&lt;/code&gt;, whereas plain &lt;code&gt;nl_langinfo()&lt;/code&gt; returns &lt;code&gt;char *&lt;/code&gt;, but you are (only by documentation) forbidden to write into the buffer. By declaring this &lt;code&gt;const&lt;/code&gt;, the compiler enforces this restriction, so if it is violated, you know at compilation time, rather than getting segfaults at runtime.</source>
          <target state="translated">ドロップインの代替品ではない理由は、実際には利点です。唯一の違いは、 &lt;code&gt;const char *&lt;/code&gt; を返すのに対し、プレーン &lt;code&gt;nl_langinfo()&lt;/code&gt; は &lt;code&gt;char *&lt;/code&gt; を返すことですが、（ドキュメントによってのみ）バッファへの書き込みは禁止されています。この &lt;code&gt;const&lt;/code&gt; を宣言することにより、コンパイラはこの制限を適用します。したがって、違反した場合、実行時にsegfaultを取得するのではなく、コンパイル時にわかります。</target>
        </trans-unit>
        <trans-unit id="2e0f1d70e28ee48bb2440f0dfad9e2b39b29922f" translate="yes" xml:space="preserve">
          <source>The reason that &lt;code&gt;host $failed_ack_host&lt;/code&gt; did not receive a valid ACK. Useful to find out why when &lt;code&gt;ack($fail_ack_host)&lt;/code&gt; returns a false value.</source>
          <target state="translated">&lt;code&gt;host $failed_ack_host&lt;/code&gt; が有効なACKを受信しなかった理由。 &lt;code&gt;ack($fail_ack_host)&lt;/code&gt; がfalse値を返す理由を見つけるのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="fedf7056008fbc98297422a200d9b784c0b8db45" translate="yes" xml:space="preserve">
          <source>The reason that doesn't do what you want is because assigning a named array like that to a scalar is taking an array in scalar context, which means just counts the number of elements in @tmp.</source>
          <target state="translated">なぜそれが思うようにいかないかというと、このような名前付き配列をスカラに代入すると、スカラコンテキストで配列を取ることになり、@tmpの要素数をカウントしているだけになってしまうからです。</target>
        </trans-unit>
        <trans-unit id="550ff1bc08b0298c35cdd00d235a478cadb820d7" translate="yes" xml:space="preserve">
          <source>The reason that host $failed_ack_host did not receive a valid ACK. Useful to find out why when ack( $fail_ack_host ) returns a false value.</source>
          <target state="translated">ホスト $failed_ack_host が有効な ACK を受信しなかった理由。ack($fail_ack_host)が偽の値を返したときの理由を調べるのに便利です。</target>
        </trans-unit>
        <trans-unit id="761e66631890fba3f96026c5ab632825150c6b23" translate="yes" xml:space="preserve">
          <source>The reason that using gettext runs into walls (as in the above second-person horror story) is that you're trying to use a string (or worse, a choice among a bunch of strings) to do what you really need a function for -- which is futile. Preforming (s)printf interpolation on the strings which you get back from gettext does allow you to do</source>
          <target state="translated">gettext を使うと壁にぶつかるのは (上記の二人称視点のホラーストーリーのように)、本当に関数が必要なことをするために文字列 (もっと悪いことに、文字列の束からの選択)を使おうとしているからです --無駄なことです。gettext から取得した文字列に (s)printf 補間を行うことで、以下のようなことが可能になります。</target>
        </trans-unit>
        <trans-unit id="251bb3c15e15e0ec21516300833b60efe1125c75" translate="yes" xml:space="preserve">
          <source>The reason this function has &quot;_strictly&quot; in its name is that when you're processing an Accept-Language list according to the RFCs, if you interpret the RFCs quite strictly, then you would use implicate_supers_strictly, but for normal use (i.e., common-sense use, as far as I'm concerned) you'd use implicate_supers.</source>
          <target state="translated">この関数の名前に&quot;_strictly &quot;が入っているのは、RFCに従ってAccept-Languageリストを処理しているときに、 RFCをかなり厳密に解釈すれば、implicate_supers_strictlyを使うことになりますが、 通常の使用(つまり、私の知る限りでは常識的な使用)ではimplicate_supersを使うことになるからです。</target>
        </trans-unit>
        <trans-unit id="00e0d83a9d5edf83f32ea0d0701c8b2f4b38f236" translate="yes" xml:space="preserve">
          <source>The reason this is considered to be only partially implemented is that Perl has &lt;a href=&quot;perlrebackslash#%5Cb%7Blb%7D&quot;&gt;&lt;code&gt;qr/\b{lb}/&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;Unicode::LineBreak&quot;&gt;Unicode::LineBreak&lt;/a&gt;&lt;/code&gt; that are conformant with &lt;a href=&quot;https://www.unicode.org/reports/tr14&quot;&gt;UAX#14 &quot;Unicode Line Breaking Algorithm&quot;&lt;/a&gt;. The regular expression construct provides default behavior, while the heavier-weight module provides customizable line breaking.</source>
          <target state="translated">これが部分的にしか実装されていないと見なされる理由は、Perlに&lt;a href=&quot;https://www.unicode.org/reports/tr14&quot;&gt;UAX＃14「UnicodeLineBreakingAlgorithm」に&lt;/a&gt;準拠した&lt;a href=&quot;perlrebackslash#%5Cb%7Blb%7D&quot;&gt; &lt;code&gt;qr/\b{lb}/&lt;/code&gt; &lt;/a&gt;と &lt;code&gt;&lt;a href=&quot;Unicode::LineBreak&quot;&gt;Unicode::LineBreak&lt;/a&gt;&lt;/code&gt; があるためです。正規表現構造はデフォルトの動作を提供し、より重いモジュールはカスタマイズ可能な改行を提供します。</target>
        </trans-unit>
        <trans-unit id="e1005d9c83a9fa9fcbc88e4d2084838b8de52293" translate="yes" xml:space="preserve">
          <source>The reason this is necessary is that the area of the Perl stack which held them will very likely have been overwritten by something else by the time control returns from</source>
          <target state="translated">これが必要な理由は、それらを保持していた Perl スタックの領域が</target>
        </trans-unit>
        <trans-unit id="7f8610d66bd9a8ef9ccb75cedd8c737641eb770d" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because RFC 1951 content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">これがデフォルトの動作ではない理由は、RFC 1951 のコンテンツは解凍を試みることでしか検出できないからです。この処理はエラーが発生しやすく、誤検出の原因となります。</target>
        </trans-unit>
        <trans-unit id="19bd78bd51bc1c56b13d7881beac1baa5b73fb31" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because lzma_alone content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">これがデフォルトの動作ではない理由は、lzma_alone コンテンツは解凍を試みることでしか検出できないからです。この処理はエラーが発生しやすく、誤検出を引き起こす可能性があります。</target>
        </trans-unit>
        <trans-unit id="28f02f8a8e5a76ee5006992d613d3802d772737a" translate="yes" xml:space="preserve">
          <source>The reason this is wrong is that, by the time you come to use the pointer &lt;code&gt;rememberSub&lt;/code&gt; in &lt;code&gt;CallSavedSub1&lt;/code&gt; , it may or may not still refer to the Perl subroutine that was recorded in &lt;code&gt;SaveSub1&lt;/code&gt; . This is particularly true for these cases:</source>
          <target state="translated">これが間違っている理由は、 &lt;code&gt;CallSavedSub1&lt;/code&gt; でポインタ &lt;code&gt;rememberSub&lt;/code&gt; を使用するときまでに、 &lt;code&gt;SaveSub1&lt;/code&gt; に記録されたPerlサブルーチンをまだ参照している、または参照していない可能性があるためです。これは特に次の場合に当てはまります。</target>
        </trans-unit>
        <trans-unit id="e2bf2d952027d4fe995c4250ed0910c8a499fa98" translate="yes" xml:space="preserve">
          <source>The reason this is wrong is that, by the time you come to use the pointer &lt;code&gt;rememberSub&lt;/code&gt; in &lt;code&gt;CallSavedSub1&lt;/code&gt;, it may or may not still refer to the Perl subroutine that was recorded in &lt;code&gt;SaveSub1&lt;/code&gt;. This is particularly true for these cases:</source>
          <target state="translated">これが間違っている理由は、 &lt;code&gt;CallSavedSub1&lt;/code&gt; でポインタ &lt;code&gt;rememberSub&lt;/code&gt; を使用するようになるまでに、SaveSub1に記録されたPerlサブルーチンを参照する場合としない場合があるため &lt;code&gt;SaveSub1&lt;/code&gt; 。これは特に次の場合に当てはまります。</target>
        </trans-unit>
        <trans-unit id="1fc61e22be627df80a7651746e52decec2ded90a" translate="yes" xml:space="preserve">
          <source>The reasons for most important skipped tests are:</source>
          <target state="translated">最も重要なサボりの理由は</target>
        </trans-unit>
        <trans-unit id="cc1622b786a9a5b8c43f01f8734a1a12e356f528" translate="yes" xml:space="preserve">
          <source>The recognized bright background color attributes (colors 8 to 15) are:</source>
          <target state="translated">認識されている明るい背景色の属性(色8〜15)は</target>
        </trans-unit>
        <trans-unit id="6c5d4a5f4c9a09fda354809420b2cbe2f30c42f0" translate="yes" xml:space="preserve">
          <source>The recognized normal background color attributes (colors 0 to 7) are:</source>
          <target state="translated">認識される通常の背景色属性(色0~7)は、以下の通りです。</target>
        </trans-unit>
        <trans-unit id="4a93814d53d2a583e73a218be86053c6699847f6" translate="yes" xml:space="preserve">
          <source>The recognized normal foreground color attributes (colors 0 to 7) are:</source>
          <target state="translated">認識される通常の前景色属性(色 0 から 7)は、以下のとおりです。</target>
        </trans-unit>
        <trans-unit id="c8d8fb33b8f8ad299c896b38af940448a2194ca3" translate="yes" xml:space="preserve">
          <source>The recognized options to new() are as follows. All options take a single argument.</source>
          <target state="translated">new()で認識されるオプションは以下の通りです。すべてのオプションは単一の引数を取ります。</target>
        </trans-unit>
        <trans-unit id="1e562f76f9cdb0ef2aab453d2c38556cc6a6334d" translate="yes" xml:space="preserve">
          <source>The recommended compiler to use in Tru64 is the native C compiler. The native compiler produces much faster code (the speed difference is noticeable: several dozen percentages) and also more correct code: if you are considering using the GNU C compiler you should use at the very least the release of 2.95.3 since all older gcc releases are known to produce broken code when compiling Perl. One manifestation of this brokenness is the lib/sdbm test dumping core; another is many of the op/regexp and op/pat, or ext/Storable tests dumping core (the exact pattern of failures depending on the GCC release and optimization flags).</source>
          <target state="translated">Tru64 で使用することを推奨するコンパイラは、ネイティブ C コンパイラです。GNU C コンパイラの使用を検討している場合は、少なくとも 2.95.3 のリリースを使用する必要があります。この問題の一つの現れは lib/sdbm テストダンプコアです。もう一つは op/regexp や op/pat、ext/Storable テストダンプコアです (失敗の正確なパターンは GCC リリースと最適化フラグに依存します)。</target>
        </trans-unit>
        <trans-unit id="a954751580ed0f6e74f6ae52a458e3decc2b6782" translate="yes" xml:space="preserve">
          <source>The recommended order of sections in Perl module documentation is:</source>
          <target state="translated">Perl モジュールのドキュメントのセクションの推奨順序は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="da2bd70489cefb603292ce8b5cfe4c6cae04aaf7" translate="yes" xml:space="preserve">
          <source>The recommended way to build Perl for the OS/400 PASE is to build the Perl 5 source code (release 5.8.1 or later) under AIX.</source>
          <target state="translated">OS/400 PASE用のPerlをビルドする推奨の方法は、Perl 5のソースコード(リリース5.8.1以降)をAIXの下でビルドすることです。</target>
        </trans-unit>
        <trans-unit id="e06b04ad5d41fce493c0b00ecf1ca37dfa5afcff" translate="yes" xml:space="preserve">
          <source>The red() and green() functions would be similar. To create these, we'll assign a closure to a typeglob of the name of the function we're trying to build.</source>
          <target state="translated">red()関数とgreen()関数も似たようなものでしょう。これらを作成するために、構築しようとしている関数の名前のタイプグローブにクロージャを代入します。</target>
        </trans-unit>
        <trans-unit id="f9a173256f222e6807faedf390f953793a1d344d" translate="yes" xml:space="preserve">
          <source>The refcount of &lt;code&gt;sv&lt;/code&gt; will be decremented at the end of</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; のrefcountは、の終わりにデクリメントされます。</target>
        </trans-unit>
        <trans-unit id="1d461f380b420e2f92a59ecbfaa16c7256f214ff" translate="yes" xml:space="preserve">
          <source>The refcount of &lt;code&gt;sv&lt;/code&gt; would be decremented at the end of</source>
          <target state="translated">&lt;code&gt;sv&lt;/code&gt; のrefcountは、終了時に減少します</target>
        </trans-unit>
        <trans-unit id="aa0554de1d883a744516c47aa9649afa91c2844b" translate="yes" xml:space="preserve">
          <source>The reference count for each specified &lt;code&gt;SV*&lt;/code&gt; parameter is decremented.</source>
          <target state="translated">指定された各 &lt;code&gt;SV*&lt;/code&gt; パラメーターの参照カウントは減分されます。</target>
        </trans-unit>
        <trans-unit id="2beb795bee8f23385c682524158dfa3883714ef0" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name list.</source>
          <target state="translated">パッド名リストの参照カウント。</target>
        </trans-unit>
        <trans-unit id="ed87a4c5aaea6eeced4317ed59578fe0847b6b0f" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name.</source>
          <target state="translated">パッド名の参照カウント。</target>
        </trans-unit>
        <trans-unit id="0f3b4f395e70b832ec180500f62bfe30abfdf04c" translate="yes" xml:space="preserve">
          <source>The reference count of the padlist. Currently this is always 1.</source>
          <target state="translated">パッドリストの参照カウント。現在は常に1です。</target>
        </trans-unit>
        <trans-unit id="b9e9c4a001467c1b7e5e43bb821f471e292d9d31" translate="yes" xml:space="preserve">
          <source>The reference from &lt;code&gt;$foo&lt;/code&gt; to &lt;code&gt;$bar&lt;/code&gt; has been weakened. When the &lt;code&gt;$bar&lt;/code&gt; variable goes out of scope, it will be garbage-collected. The next time you look at the value of the &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; key, it will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$foo&lt;/code&gt; から &lt;code&gt;$bar&lt;/code&gt; への参照が弱められました。場合は &lt;code&gt;$bar&lt;/code&gt; 変数がスコープ外になる、それがガベージコレクトされます。次に &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; キーの値を見ると、 &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="a1de879124c2751ad3ecd4b63c57cecfe27d3f64" translate="yes" xml:space="preserve">
          <source>The reference from &lt;code&gt;$foo&lt;/code&gt; to &lt;code&gt;$bar&lt;/code&gt; has been weakened. When the &lt;code&gt;$bar&lt;/code&gt; variable goes out of scope, it will be garbage-collected. The next time you look at the value of the &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; key, it will be &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$foo&lt;/code&gt; から &lt;code&gt;$bar&lt;/code&gt; への参照が弱められました。場合は &lt;code&gt;$bar&lt;/code&gt; 変数がスコープ外になる、それがガベージコレクトされます。次に &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; キーの値を見ると、 &lt;code&gt;undef&lt;/code&gt; になります。</target>
        </trans-unit>
        <trans-unit id="3fc857a94806f2c57cbbf2e2dd2d2b88b08c2fe6" translate="yes" xml:space="preserve">
          <source>The reference is truly dumped and we can finally see what we're dealing with. Our quoting was perfectly valid but wrong for our purposes, with 'and jerry' being treated as 2 separate words rather than a phrase, thus throwing the evenly paired hash structure out of alignment.</source>
          <target state="translated">参照は本当に捨てられ、我々は最終的に何を扱っているのかを見ることができます。私たちの引用は完全に有効でしたが、私たちの目的のためには間違っていました。'and jerry'はフレーズではなく2つの別々の単語として扱われていたため、均等にペアになっていたハッシュ構造がずれてしまいました。</target>
        </trans-unit>
        <trans-unit id="4adfd6b1f7abb309b66c9315a05ff37197f3a0fe" translate="yes" xml:space="preserve">
          <source>The references you get from rule 2 are the same kind of references that you get from rule 1:</source>
          <target state="translated">ルール2で取得した参照は、ルール1で取得した参照と同じ種類のものです。</target>
        </trans-unit>
        <trans-unit id="4f2739050aee8d49851e25b790d128e1ca19fbde" translate="yes" xml:space="preserve">
          <source>The regex_sets feature is experimental</source>
          <target state="translated">regex_sets 機能は実験的なものです。</target>
        </trans-unit>
        <trans-unit id="4c14a48971a0368f8bbf545f9e2905f7ac019ed5" translate="yes" xml:space="preserve">
          <source>The regexp has a single grouping which considers 4-letter combinations, then 3-letter combinations,</source>
          <target state="translated">正規表現は、4文字の組み合わせを考慮し、次に3文字の組み合わせを考慮した1つのグループ化を持っています。</target>
        </trans-unit>
        <trans-unit id="168bedf74d17b291ff7d2c437f9134d9006e0ffe" translate="yes" xml:space="preserve">
          <source>The regexp has a single grouping which considers 4-letter combinations, then 3-letter combinations, etc., and uses &lt;code&gt;\g1&lt;/code&gt; to look for a repeat. Although &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;\g1&lt;/code&gt; represent the same thing, care should be taken to use matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... only</source>
          <target state="translated">正規表現には、4文字の組み合わせ、3文字の組み合わせなどを考慮した単一のグループがあり、 &lt;code&gt;\g1&lt;/code&gt; を使用して繰り返しを探します。が &lt;code&gt;$1&lt;/code&gt; と &lt;code&gt;\g1&lt;/code&gt; 同じものを表し、介護が一致した変数を使用するために取られるべきである &lt;code&gt;$1&lt;/code&gt; 、 &lt;code&gt;$2&lt;/code&gt; 、...のみ</target>
        </trans-unit>
        <trans-unit id="d1eb9cbcdcc85f0afd97e3812b595b9e1f6b3fd8" translate="yes" xml:space="preserve">
          <source>The regexp matches an open parenthesis, one or more copies of an alternation, and a close parenthesis. The alternation is two-way, with the first alternative &lt;code&gt;[^()]+&lt;/code&gt; matching a substring with no parentheses and the second alternative &lt;code&gt;\([^()]*\)&lt;/code&gt; matching a substring delimited by parentheses. The problem with this regexp is that it is pathological: it has nested indeterminate quantifiers of the form &lt;code&gt;(a+|b)+&lt;/code&gt;. We discussed in Part 1 how nested quantifiers like this could take an exponentially long time to execute if there was no match possible. To prevent the exponential blowup, we need to prevent useless backtracking at some point. This can be done by enclosing the inner quantifier as an independent subexpression:</source>
          <target state="translated">正規表現は、左括弧、代替の1つ以上のコピー、および右括弧と一致します。代替は双方向です。最初の選択肢 &lt;code&gt;[^()]+&lt;/code&gt; は括弧のない部分文字列に一致し、2番目の選択肢 &lt;code&gt;\([^()]*\)&lt;/code&gt; は括弧で区切られた部分文字列に一致します。この正規表現の問題は、それが病理学的であることです： &lt;code&gt;(a+|b)+&lt;/code&gt; 形式の不定量化子がネストされています。パート1では、このようなネストされた量指定子が、一致するものがなかった場合、実行に指数関数的に長い時間がかかる可能性があることについて説明しました。指数関数的な爆発を防ぐには、ある時点で無用なバックトラックを防ぐ必要があります。これは、内部の数量詞を独立した部分式として囲むことで実行できます。</target>
        </trans-unit>
        <trans-unit id="368bf455728e0cc079751b44e9fea4161849b273" translate="yes" xml:space="preserve">
          <source>The regexp structure contains all the data that perl needs to be aware of to properly work with the regular expression. It includes data about optimisations that perl can use to determine if the regex engine should really be used, and various other control info that is needed to properly execute patterns in various contexts such as is the pattern anchored in some way, or what flags were used during the compile, or whether the program contains special constructs that perl needs to be aware of.</source>
          <target state="translated">regexp構造体には、正規表現を適切に動作させるためにPerlが意識しなければならないすべてのデータが含まれています。これには、正規表現エンジンが本当に使用されるべきかどうかを判断するためにperlが使用できる最適化に関するデータや、パターンが何らかの方法で固定されているか、コンパイル時にどのようなフラグが使用されているか、プログラムにperlが注意しなければならない特別な構造が含まれているかなど、様々な文脈でパターンを適切に実行するために必要な様々な制御情報が含まれています。</target>
        </trans-unit>
        <trans-unit id="c3c54f92228f6f05bcc0bda8517b5a88720264e3" translate="yes" xml:space="preserve">
          <source>The regexp without the &lt;code&gt;//x&lt;/code&gt; modifier is</source>
          <target state="translated">&lt;code&gt;//x&lt;/code&gt; 修飾子のない正規表現は</target>
        </trans-unit>
        <trans-unit id="cd0504e6dcc01ce1582fd08d19ab6d72b18efd43" translate="yes" xml:space="preserve">
          <source>The regops are defined in</source>
          <target state="translated">レゴップスは</target>
        </trans-unit>
        <trans-unit id="398b15f4cf9df5e68a324633c771b534053133cc" translate="yes" xml:space="preserve">
          <source>The regression tests for each operator live in</source>
          <target state="translated">各オペレータの回帰テストは</target>
        </trans-unit>
        <trans-unit id="1185c36b91985e4291f68ed8a08b57d301b0c6f7" translate="yes" xml:space="preserve">
          <source>The regular expression engine can be a weighty tool to wield. On long strings and complex patterns it can end up having to do a lot of work to find a match, and even more to decide that no match is possible. Consider a situation like the following pattern.</source>
          <target state="translated">正規表現エンジンは、重量感のあるツールになります。長い文字列や複雑なパターンでは、一致するものを見つけるために多くの作業をしなければならず、一致するものがないと判断するにはさらに多くの作業をしなければならないことがあります。次のパターンのような状況を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="550e74d9d02bffd01cf3b652c4e172b2d8cb3f39" translate="yes" xml:space="preserve">
          <source>The regular expression to execute.</source>
          <target state="translated">実行する正規表現。</target>
        </trans-unit>
        <trans-unit id="8c3b3408d3eb9771532acb10a043be225a8f7a49" translate="yes" xml:space="preserve">
          <source>The regular expression to match the balanced text uses two new (to Perl 5.10) regular expression features. These are covered in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and this example is a modified version of one in that documentation.</source>
          <target state="translated">バランスの取れたテキストに一致する正規表現は、2つの新しい（Perl 5.10への）正規表現機能を使用します。これらは&lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;でカバーされており、この例はそのドキュメントの1つの修正バージョンです。</target>
        </trans-unit>
        <trans-unit id="7b89c7165c60ab0797d1970f7d1380e29eaa0008" translate="yes" xml:space="preserve">
          <source>The related &lt;code&gt;base&lt;/code&gt; pragma will combine fields from base classes and any fields declared using the &lt;code&gt;fields&lt;/code&gt; pragma. This enables field inheritance to work properly. Inherited fields can be overridden but will generate a warning if warnings are enabled.</source>
          <target state="translated">関連する &lt;code&gt;base&lt;/code&gt; プラグマは、基本クラスのフィールドと、 &lt;code&gt;fields&lt;/code&gt; プラグマを使用して宣言されたフィールドを結合します。これにより、フィールドの継承が適切に機能します。継承されたフィールドはオーバーライドできますが、警告が有効になっている場合は警告が生成されます。</target>
        </trans-unit>
        <trans-unit id="31c9eb432cfde9dbb8b6575337f7f66a6d53cbda" translate="yes" xml:space="preserve">
          <source>The relevant snippet from &lt;code&gt;Perl_pp_regcomp&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;Perl_pp_regcomp&lt;/code&gt; からの関連スニペット：</target>
        </trans-unit>
        <trans-unit id="86d45b748524cf3c3ed19b4942d99f6682b785f8" translate="yes" xml:space="preserve">
          <source>The relevant snippet from &lt;code&gt;Perl_pp_regcomp&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Perl_pp_regcomp&lt;/code&gt; からの関連スニペット：</target>
        </trans-unit>
        <trans-unit id="99cbb925914614f38c9cb5913b1dca990337342e" translate="yes" xml:space="preserve">
          <source>The remainder of the input string (i.e. the characters after the extracted string). On failure, the entire string is returned.</source>
          <target state="translated">入力文字列の残り(すなわち、抽出された文字列の後の文字)。失敗した場合は、文字列全体が返されます。</target>
        </trans-unit>
        <trans-unit id="efbd63ef88d15920cb0b989c9bf11dcb1d2eacf4" translate="yes" xml:space="preserve">
          <source>The remaining arguments list the files to be included in the tar file. These files must all exist. Any files which don't exist or can't be read are silently ignored.</source>
          <target state="translated">残りの引数は、tar ファイルに含めるファイルのリストです。これらのファイルはすべて存在しなければなりません。存在しないファイルや読み込めないファイルは無視されます。</target>
        </trans-unit>
        <trans-unit id="f73744579f886d96e9ed158f08b1414dc3c821e4" translate="yes" xml:space="preserve">
          <source>The remaining fields specify the starting and ending cylinder and head of the range of tracks to be formatted.</source>
          <target state="translated">残りのフィールドは、フォーマットされるトラックの範囲の始点と終点のシリンダーとヘッドを指定します。</target>
        </trans-unit>
        <trans-unit id="1833f6078478dddd497b7e7b088899346fc9339d" translate="yes" xml:space="preserve">
          <source>The remaining list-reduction functions are all specialisations of this generic idea.</source>
          <target state="translated">残りのリスト削減関数は、すべてこの一般的な考え方の特殊化です。</target>
        </trans-unit>
        <trans-unit id="5790bf8249cfb740e1105f12c204270f7d624a65" translate="yes" xml:space="preserve">
          <source>The remaining locale categories are not currently used by Perl itself. But again note that things Perl interacts with may use these, including extensions outside the standard Perl distribution, and by the operating system and its utilities. Note especially that the string value of &lt;code&gt;$!&lt;/code&gt; and the error messages given by external utilities may be changed by &lt;code&gt;LC_MESSAGES&lt;/code&gt; . If you want to have portable error codes, use &lt;code&gt;%!&lt;/code&gt; . See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;.</source>
          <target state="translated">残りのロケールカテゴリは、現在Perl自体では使用されていません。ただし、Perlと対話するものは、標準のPerlディストリビューション外の拡張機能や、オペレーティングシステムとそのユーティリティによってこれらを使用する可能性があることに注意してください。特に &lt;code&gt;$!&lt;/code&gt; の文字列値に注意してください。そして、外部ユーティリティによって与えられるエラーメッセージは &lt;code&gt;LC_MESSAGES&lt;/code&gt; によって変更されるかもしれません。移植可能なエラーコードが必要な場合は、 &lt;code&gt;%!&lt;/code&gt; を使用してください。。&lt;a href=&quot;errno&quot;&gt;Errnoを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="c93d95569d58cc954c309a9c37710dcae16b378b" translate="yes" xml:space="preserve">
          <source>The remaining locale categories are not currently used by Perl itself. But again note that things Perl interacts with may use these, including extensions outside the standard Perl distribution, and by the operating system and its utilities. Note especially that the string value of &lt;code&gt;$!&lt;/code&gt; and the error messages given by external utilities may be changed by &lt;code&gt;LC_MESSAGES&lt;/code&gt;. If you want to have portable error codes, use &lt;code&gt;%!&lt;/code&gt;. See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;.</source>
          <target state="translated">残りのロケールカテゴリは現在、Perl自体では使用されていません。ただし、Perlが対話するものは、標準のPerlディストリビューション外の拡張機能や、オペレーティングシステムとそのユーティリティによって、これらを使用する場合があることに注意してください。 &lt;code&gt;$!&lt;/code&gt; の文字列値に特に注意してください。また、外部ユーティリティによって表示されるエラーメッセージは、 &lt;code&gt;LC_MESSAGES&lt;/code&gt; によって変更される場合があります。ポータブルなエラーコードが必要な場合は、 &lt;code&gt;%!&lt;/code&gt; を使用してください。。&lt;a href=&quot;errno&quot;&gt;Errnoを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="6f593d82b22de04a34fb6b00553893736966b088" translate="yes" xml:space="preserve">
          <source>The remaining three arguments to &lt;code&gt;autosplit&lt;/code&gt; govern other options to the autosplitter.</source>
          <target state="translated">残りの三つの引数 &lt;code&gt;autosplit&lt;/code&gt; autosplitterに他のオプションを管理します。</target>
        </trans-unit>
        <trans-unit id="359f225886acbac14791dc5bc2f8daf71a950d7f" translate="yes" xml:space="preserve">
          <source>The remaining transformations (e.g. hex -&amp;gt; oct, bin -&amp;gt; hex, etc.) are left as an exercise to the inclined reader.</source>
          <target state="translated">残りの変換（例：hex-&amp;gt; oct、bin-&amp;gt; hexなど）は、傾斜した読者への課題として残されています。</target>
        </trans-unit>
        <trans-unit id="24d565f51a3155e5d1586b0499680351e5378dc6" translate="yes" xml:space="preserve">
          <source>The repeat count for &lt;code&gt;u&lt;/code&gt; is interpreted as the maximal number of bytes to encode per line of output, with 0, 1 and 2 replaced by 45. The repeat count should not be more than 65.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; の繰り返し数は、出力の1行あたりにエンコードする最大バイト数として解釈され、0、1、2は45に置き換えられます。繰り返し数は65以下にする必要があります。</target>
        </trans-unit>
        <trans-unit id="f593cdc0477b84a5d137272da930d89fe6995081" translate="yes" xml:space="preserve">
          <source>The repertoire of characters that Perl can represent is a superset of those defined by the Unicode Consortium. On most platforms the ordinal values of a character as returned by &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; is the</source>
          <target state="translated">Perlが表現できる文字のレパートリーは、Unicodeコンソーシアムによって定義された文字のスーパーセットです。ほとんどのプラットフォームで返される文字の序数値に &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; であります</target>
        </trans-unit>
        <trans-unit id="b4becab04b9eae1dfa2922434e872f92f0ca7ffd" translate="yes" xml:space="preserve">
          <source>The replacement UNIVERSAL::VERSION, when used as a function, like this:</source>
          <target state="translated">このように関数として使用する場合は、UNIVERSAL::VERSIONを置き換えます。</target>
        </trans-unit>
        <trans-unit id="2b90d7584bfb12af61e5f1ab0554e525a346ffd6" translate="yes" xml:space="preserve">
          <source>The report generated is in the following format:</source>
          <target state="translated">生成されたレポートは以下の形式です。</target>
        </trans-unit>
        <trans-unit id="c18cb003bcf6566604f8240405fff42c4ea43f6c" translate="yes" xml:space="preserve">
          <source>The report is then grouped by the &lt;b&gt;Package&lt;/b&gt; of each variable, subroutine or format with the special case &quot;(lexicals)&quot; meaning lexical variables. Each &lt;b&gt;object&lt;/b&gt; name (implicitly qualified by its containing &lt;b&gt;Package&lt;/b&gt;) includes its type character(s) at the beginning where possible. Lexical variables are easier to track and even included dereferencing information where possible.</source>
          <target state="translated">次に、レポートは、各変数、サブルーチン、またはフォーマットの&lt;b&gt;パッケージ&lt;/b&gt;ごとにグループ化され、レキシカル変数を意味する特殊なケース「（lexicals）」が付けられます。各&lt;b&gt;オブジェクト&lt;/b&gt;名（含まれている&lt;b&gt;Package&lt;/b&gt;によって暗黙的に修飾されている）には、可能な場合、先頭にタイプ文字が含まれています。字句変数は追跡が容易で、可能な場合は逆参照情報も含まれます。</target>
        </trans-unit>
        <trans-unit id="a2f4b71d3df1e22731185a4eb5f4e73af9bf14da" translate="yes" xml:space="preserve">
          <source>The report with</source>
          <target state="translated">とのレポートを掲載しています。</target>
        </trans-unit>
        <trans-unit id="32baff471ed8eb8f5ceead8f0fa06a41ab81b875" translate="yes" xml:space="preserve">
          <source>The request was judged to be small, so the possibility to trap it depends on the way perl was compiled. By default it is not trappable. However, if compiled for this, Perl may use the contents of &lt;code&gt;$^M&lt;/code&gt; as an emergency pool after die()ing with this message. In this case the error is trappable</source>
          <target state="translated">リクエストは小さいと判断されたため、それがトラップされる可能性はperlのコンパイル方法によって異なります。デフォルトではトラップできません。ただし、このためにコンパイルされた場合、Perlは、このメッセージでdie（）した後、 &lt;code&gt;$^M&lt;/code&gt; 内容を緊急プールとして使用する場合があります。この場合、エラーはトラップ可能です</target>
        </trans-unit>
        <trans-unit id="e06f7be9330cffa7a55aee96bfbe8c1e1072f6a9" translate="yes" xml:space="preserve">
          <source>The requests do not necessarily go always all the way down to the operating system: that's where PerlIO buffering comes into play.</source>
          <target state="translated">リクエストは常にオペレーティングシステムにまで届くわけではありません。</target>
        </trans-unit>
        <trans-unit id="c2923a29c348a827f2ff3da1221b43b0a603bfa9" translate="yes" xml:space="preserve">
          <source>The require function will actually look for the</source>
          <target state="translated">require関数は実際に</target>
        </trans-unit>
        <trans-unit id="d362ada26ee954875bdcbdb4ef3110ff77e350ef" translate="yes" xml:space="preserve">
          <source>The require function will actually look for the &quot;</source>
          <target state="translated">require関数は実際に&quot;</target>
        </trans-unit>
        <trans-unit id="437fdd0ce3dd49b0cb6d8dbfa1617238f6bfc689" translate="yes" xml:space="preserve">
          <source>The require function will look for the</source>
          <target state="translated">require関数は</target>
        </trans-unit>
        <trans-unit id="7925470de731575e163d706573142112baceaaab" translate="yes" xml:space="preserve">
          <source>The require function will look for the &quot;</source>
          <target state="translated">require関数は、&quot;</target>
        </trans-unit>
        <trans-unit id="a4dd4536ee0a716833e52164851f465f831c0d1d" translate="yes" xml:space="preserve">
          <source>The required arguments during &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; are the hash, the package, and the reference to the &lt;code&gt;FETCH&lt;/code&gt; ing function. The optional arguments are an arbitrary scalar $data, the reference to the &lt;code&gt;EXISTS&lt;/code&gt; function, and initial values of the hash and of the existence cache.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; 中に必要な引数は、ハッシュ、パッケージ、および &lt;code&gt;FETCH&lt;/code&gt; ing関数への参照です。オプションの引数は、任意のスカラー$ data、 &lt;code&gt;EXISTS&lt;/code&gt; 関数への参照、およびハッシュと存在キャッシュの初期値です。</target>
        </trans-unit>
        <trans-unit id="72b681659bb57f7021407ce5fd3ac4d104c48565" translate="yes" xml:space="preserve">
          <source>The required arguments during &lt;code&gt;tie&lt;/code&gt; are the hash, the package, and the reference to the &lt;code&gt;FETCH&lt;/code&gt;ing function. The optional arguments are an arbitrary scalar $data, the reference to the &lt;code&gt;EXISTS&lt;/code&gt; function, and initial values of the hash and of the existence cache.</source>
          <target state="translated">&lt;code&gt;tie&lt;/code&gt; 中に必要な引数は、ハッシュ、パッケージ、および &lt;code&gt;FETCH&lt;/code&gt; ing関数への参照です。オプションの引数は、任意のスカラー$ data、 &lt;code&gt;EXISTS&lt;/code&gt; 関数への参照、およびハッシュと存在キャッシュの初期値です。</target>
        </trans-unit>
        <trans-unit id="37cc4a6beddbd481d62d1aa4fb0c7078c9745a11" translate="yes" xml:space="preserve">
          <source>The requires and build_requires dependency declarations</source>
          <target state="translated">require および build_requires 依存関係宣言</target>
        </trans-unit>
        <trans-unit id="68eca29cf3cefa1ee83b5c875c176fa92ac4b217" translate="yes" xml:space="preserve">
          <source>The rest is duplicate code from MM_Unix. Should move the linker code to its own method.</source>
          <target state="translated">残りはMM_Unixからの重複コードです。リンカのコードを独自のメソッドに移動する必要があります。</target>
        </trans-unit>
        <trans-unit id="5f0ee77d23f152cd1591836db1cbf485219544f6" translate="yes" xml:space="preserve">
          <source>The rest is for internal usage of this package. In particular, if TIEHASH is overwritten, it should call SUPER::TIEHASH.</source>
          <target state="translated">あとはこのパッケージの内部的な使い方です。特に、TIEHASHが上書きされた場合は、SUPER::TIEHASHを呼び出す必要があります。</target>
        </trans-unit>
        <trans-unit id="fe2906e8b2561874cbab3bd035dddc47777e922a" translate="yes" xml:space="preserve">
          <source>The rest of the</source>
          <target state="translated">の残りの部分</target>
        </trans-unit>
        <trans-unit id="bf6a19c74f24c99c3610c0c4323af3d860d85c2f" translate="yes" xml:space="preserve">
          <source>The rest of the .pm file contains sample code for providing documentation for the extension.</source>
          <target state="translated">.pm ファイルの残りの部分には、拡張子のドキュメントを提供するためのサンプルコードが含まれています。</target>
        </trans-unit>
        <trans-unit id="7c74ae28959473b4a69a8f31fe847650cadce3cf" translate="yes" xml:space="preserve">
          <source>The rest of the META.yml file is one big YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;mapping&lt;/a&gt;, whose keys are described here.</source>
          <target state="translated">META.ymlファイルの残りの部分は1つの大きなYAML&lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;マッピング&lt;/a&gt;であり、そのキーについてはここで説明します。</target>
        </trans-unit>
        <trans-unit id="6a0a96f4412d084abe1abbbb705cc005b4d7612f" translate="yes" xml:space="preserve">
          <source>The rest of the function description may be indented or left-adjusted. The following example shows a function with its body left-adjusted. Most examples in this document will indent the body for better readability.</source>
          <target state="translated">関数の説明の残りの部分は、インデントされていてもよいし、左寄せされていてもよい。以下の例は、ボディを左寄せにした関数を示しています。このドキュメントのほとんどの例では、読みやすくするためにボディをインデントしています。</target>
        </trans-unit>
        <trans-unit id="4748c8c8a6af67adc5b974371e823f12ce953a5d" translate="yes" xml:space="preserve">
          <source>The rest of this section may need updating, but we don't know what it should say. Please email comments to &lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;perlbug@perl.org&lt;/a&gt;.</source>
          <target state="translated">このセクションの残りの部分は更新が必要な場合がありますが、それが何を言うべきかわかりません。コメントは&lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;perlbug@perl.org&lt;/a&gt;までメールでお送りください。</target>
        </trans-unit>
        <trans-unit id="b6c6c6a28aca9f64e81536b5041a7bd3a852dd99" translate="yes" xml:space="preserve">
          <source>The rest of this section may need updating, but we don't know what it should say. Please submit comments to &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="translated">このセクションの残りの部分は更新が必要な場合がありますが、何を言うべきかわかりません。&lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issuesに&lt;/a&gt;コメントを送信してください。</target>
        </trans-unit>
        <trans-unit id="fd5215ed25fc6b559f1f45b7ad436f4f9831272e" translate="yes" xml:space="preserve">
          <source>The rest which are already available are based upon the vendor mappings at &lt;a href=&quot;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&quot;&gt;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&lt;/a&gt; .</source>
          <target state="translated">すでに利用可能な残りの部分は、&lt;a href=&quot;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&quot;&gt;http：//www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/の&lt;/a&gt;ベンダーマッピングに基づいています。</target>
        </trans-unit>
        <trans-unit id="a3cb44cf97eef964df25c82472ad386e80122021" translate="yes" xml:space="preserve">
          <source>The restart was previously implemented using a &lt;code&gt;longjmp&lt;/code&gt; in &lt;code&gt;regatom()&lt;/code&gt; back to a &lt;code&gt;setjmp&lt;/code&gt; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , but this proved to be problematic as the latter is a large function containing many automatic variables, which interact badly with the emergent control flow of &lt;code&gt;setjmp&lt;/code&gt; .</source>
          <target state="translated">再起動は、以前に使用して実装した &lt;code&gt;longjmp&lt;/code&gt; の中 &lt;code&gt;regatom()&lt;/code&gt; へ戻る &lt;code&gt;setjmp&lt;/code&gt; 関数で &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; 、後者は多くの自動変数を含む大きな機能であるので、これは問題であることが証明された相互作用ひどくの緊急制御フローと &lt;code&gt;setjmp&lt;/code&gt; 関数。</target>
        </trans-unit>
        <trans-unit id="0cb3a75ceb2d2ee1d3bf90c88d2151a6541e047d" translate="yes" xml:space="preserve">
          <source>The restart was previously implemented using a &lt;code&gt;longjmp&lt;/code&gt; in &lt;code&gt;regatom()&lt;/code&gt; back to a &lt;code&gt;setjmp&lt;/code&gt; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt;, but this proved to be problematic as the latter is a large function containing many automatic variables, which interact badly with the emergent control flow of &lt;code&gt;setjmp&lt;/code&gt;.</source>
          <target state="translated">再起動は、以前に使用して実装した &lt;code&gt;longjmp&lt;/code&gt; の中 &lt;code&gt;regatom()&lt;/code&gt; へ戻る &lt;code&gt;setjmp&lt;/code&gt; 関数で &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; 、後者は多くの自動変数を含む大きな機能であるので、これは問題であることが証明された相互作用ひどくの緊急制御フローと &lt;code&gt;setjmp&lt;/code&gt; 関数。</target>
        </trans-unit>
        <trans-unit id="5e8310b48c79e713f14decd4088c7da40b8f8d5f" translate="yes" xml:space="preserve">
          <source>The restriction for the comparison operation is that even if, for example, &lt;code&gt;cmp&lt;/code&gt; should return a blessed reference, the autogenerated &lt;code&gt;lt&lt;/code&gt; function will produce only a standard logical value based on the numerical value of the result of &lt;code&gt;cmp&lt;/code&gt; . In particular, a working numeric conversion is needed in this case (possibly expressed in terms of other conversions).</source>
          <target state="translated">比較演算の制限は、たとえば、 &lt;code&gt;cmp&lt;/code&gt; がblessされた参照を返す必要がある場合でも、自動生成された &lt;code&gt;lt&lt;/code&gt; 関数は、 &lt;code&gt;cmp&lt;/code&gt; の結果の数値に基づく標準の論理値のみを生成するということです。特に、この場合、有効な数値変換が必要です（他の変換で表現されている可能性があります）。</target>
        </trans-unit>
        <trans-unit id="f937ca260b1eebc06f72a3641b2c030503e4317b" translate="yes" xml:space="preserve">
          <source>The restriction for the comparison operation is that even if, for example, &lt;code&gt;cmp&lt;/code&gt; should return a blessed reference, the autogenerated &lt;code&gt;lt&lt;/code&gt; function will produce only a standard logical value based on the numerical value of the result of &lt;code&gt;cmp&lt;/code&gt;. In particular, a working numeric conversion is needed in this case (possibly expressed in terms of other conversions).</source>
          <target state="translated">比較演算の制限は、たとえば &lt;code&gt;cmp&lt;/code&gt; が祝福された参照を返す必要がある場合でも、自動生成された &lt;code&gt;lt&lt;/code&gt; 関数は &lt;code&gt;cmp&lt;/code&gt; の結果の数値に基づいて標準の論理値のみを生成することです。特に、この場合、実用的な数値変換が必要です（おそらく他の変換で表されます）。</target>
        </trans-unit>
        <trans-unit id="17095fb32ad5dc43587aca28eee99cc6fee8a6b5" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;$^R&lt;/code&gt; is automatically localized, so that it will behave properly in the presence of backtracking.</source>
          <target state="translated">結果の &lt;code&gt;$^R&lt;/code&gt; は自動的にローカライズされるため、バックトラックが存在する場合でも適切に動作します。</target>
        </trans-unit>
        <trans-unit id="917b4b2d464d47448ca46f205a594a1f2094a00d" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">結果 &lt;code&gt;Regexp&lt;/code&gt; は、引数が &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; から得られる正規表現であることを示しています。</target>
        </trans-unit>
        <trans-unit id="1beec82c5ad986daa3005ca6feae967035c22b78" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">結果 &lt;code&gt;Regexp&lt;/code&gt; は、引数が &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; から得られる正規表現であることを示しています。</target>
        </trans-unit>
        <trans-unit id="fa60f0453236256bf9eae460e1101cb5ebaf3da0" translate="yes" xml:space="preserve">
          <source>The result has a dual nature: it is a NaN, but it also carries the integer inside it. The integer can be retrieved with &lt;a href=&quot;#getpayload&quot;&gt;&quot;getpayload&quot;&lt;/a&gt;. Note, though, that the payload is not propagated, not even on copies, and definitely not in arithmetic operations.</source>
          <target state="translated">結果には二重の性質があります。それはNaNですが、その中に整数も含まれています。整数は&lt;a href=&quot;#getpayload&quot;&gt;「getpayload」で&lt;/a&gt;取得できます。ただし、ペイロードは、コピーであっても、算術演算では伝播されないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="413c5704399ec4e320c4b4de62416c60414146e3" translate="yes" xml:space="preserve">
          <source>The result is returned as two arguments. If the modular multiplicative inverse does not exist, both arguments are undefined. Otherwise, the arguments are a number (object) and its sign (&quot;+&quot; or &quot;-&quot;).</source>
          <target state="translated">結果は2つの引数として返されます。モジュラー乗算逆数が存在しない場合、両方の引数は未定義です。そうでなければ、引数は数(オブジェクト)とその符号(&quot;+&quot;または&quot;-&quot;)です。</target>
        </trans-unit>
        <trans-unit id="e2176289afdf7f655c62c369888f79d214a9f024" translate="yes" xml:space="preserve">
          <source>The result is that the contents of line 17 of the file will be replaced with &quot;Cherry pie&quot;; a newline character will separate line 17 from line 18. This means that this code will do nothing:</source>
          <target state="translated">その結果、ファイルの17行目の内容が「チェリーパイ」に置き換わり、改行文字が17行目と18行目を区切ることになります。つまり、このコードは何もしないということです。</target>
        </trans-unit>
        <trans-unit id="f863b8e99992f5c2a779d9ed98aecf9cef5b7a84" translate="yes" xml:space="preserve">
          <source>The result is the Unicode character or character sequence given by</source>
          <target state="translated">で与えられた Unicode 文字または文字列が結果となります。</target>
        </trans-unit>
        <trans-unit id="f066226510a6a63558092d6e0a75383b46653b7b" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number between the braces. See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="translated">結果は、中括弧の間の16進数で指定された文字です。参照してください&lt;a href=&quot;#%5B8%5D&quot;&gt;「[8]」&lt;/a&gt;文字の詳細については、以下の。</target>
        </trans-unit>
        <trans-unit id="17faf27e0d190c0297fec9a5baff8ccb279e91a8" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">結果は、中括弧内の16進数で指定された文字です。参照&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]を&lt;/a&gt;文字の詳細については下記。</target>
        </trans-unit>
        <trans-unit id="7238c8e2e1333323c2dd62857b981306a7706e6a" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number in the range 0x00 to 0xFF. See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="translated">結果は、0x00から0xFFの範囲の16進数で指定された文字です。参照してください&lt;a href=&quot;#%5B8%5D&quot;&gt;「[8]」&lt;/a&gt;文字の詳細については、以下の。</target>
        </trans-unit>
        <trans-unit id="1743ff5152c2110b7544e70901f154f3b6b46b92" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number in the range 0x00 to 0xFF. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">結果は、0x00から0xFFの範囲の16進数で指定された文字です。参照&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]を&lt;/a&gt;文字の詳細については下記。</target>
        </trans-unit>
        <trans-unit id="d86f6bbcc0ec2a19c70956057e4d3cc4063fc333" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the octal number between the braces. See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="translated">結果は、中括弧の間の8進数で指定された文字です。参照してください&lt;a href=&quot;#%5B8%5D&quot;&gt;「[8]」&lt;/a&gt;文字の詳細については、以下の。</target>
        </trans-unit>
        <trans-unit id="6bbe820fb63fd799e4d92d37fd1768342fc0ad13" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the octal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">結果は、中括弧内の8進数で指定された文字です。参照&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]を&lt;/a&gt;文字の詳細については下記。</target>
        </trans-unit>
        <trans-unit id="2ca77b886ca2262e5c2630425a0b7e07037d32d3" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the three-digit octal number in the range 000 to 777 (but best to not use above 077, see next paragraph). See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="translated">結果は、000から777の範囲の3桁の8進数で指定された文字です（ただし、077を超えて使用しないことをお勧めします。次の段落を参照してください）。参照してください&lt;a href=&quot;#%5B8%5D&quot;&gt;「[8]」&lt;/a&gt;文字の詳細については、以下の。</target>
        </trans-unit>
        <trans-unit id="b5d07b8bddc1c5dd823f98677754aff0c68b0c00" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the three-digit octal number in the range 000 to 777 (but best to not use above 077, see next paragraph). See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">結果は、000から777の範囲の3桁の8進数で指定された文字です（ただし、077を超えて使用しないことをお勧めします。次の段落を参照）。参照&lt;a href=&quot;#%5b8%5d&quot;&gt;[8]を&lt;/a&gt;文字の詳細については下記。</target>
        </trans-unit>
        <trans-unit id="4d2ac189a7b892d497c3a957f821832172806b14" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;code&gt;xhdr&lt;/code&gt; except the is will be restricted to headers where the text of the header matches &lt;code&gt;PATTERN&lt;/code&gt;</source>
          <target state="translated">結果は &lt;code&gt;xhdr&lt;/code&gt; と同じですが、ヘッダーのテキストが &lt;code&gt;PATTERN&lt;/code&gt; に一致するヘッダーに制限されます。</target>
        </trans-unit>
        <trans-unit id="37186ac3e81998654b9034f359d33c97b138b201" translate="yes" xml:space="preserve">
          <source>The result may be used as a subpattern in a match:</source>
          <target state="translated">結果は、マッチのサブパターンとして使用することができます。</target>
        </trans-unit>
        <trans-unit id="aea5a1ac74300d067b63729d12ad0881314aa59c" translate="yes" xml:space="preserve">
          <source>The result of each test is captured in a hash. These hashes are the same as the hashes returned by Test::Builder-&amp;gt;details but with a couple of extra fields.</source>
          <target state="translated">各テストの結果はハッシュにキャプチャされます。これらのハッシュは、Test :: Builder-&amp;gt; detailsによって返されるハッシュと同じですが、いくつかの追加フィールドがあります。</target>
        </trans-unit>
        <trans-unit id="30a38c7996159062562ab2957a6c23713b7a1d86" translate="yes" xml:space="preserve">
          <source>The result of evaluation of the last successful &lt;code&gt;(?{ code })&lt;/code&gt; regular expression assertion (see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;). May be written to.</source>
          <target state="translated">最後に成功した &lt;code&gt;(?{ code })&lt;/code&gt; 正規表現アサーションの評価結果（&lt;a href=&quot;perlre&quot;&gt;perlreを&lt;/a&gt;参照）。書いてもよい。</target>
        </trans-unit>
        <trans-unit id="66611e861a602cfa60591a93b737577becd37f08" translate="yes" xml:space="preserve">
          <source>The result of great_circle_direction is in radians, zero indicating straight north, pi or -pi straight south, pi/2 straight west, and -pi/2 straight east.</source>
          <target state="translated">great_circle_directionの結果はラジアン単位で、0は北にまっすぐ、πまたは-πは南にまっすぐ、π/2は西にまっすぐ、-π/2は東にまっすぐであることを示します。</target>
        </trans-unit>
        <trans-unit id="f6846ed84b71cca2d8b5fb5477773187fbddddb3" translate="yes" xml:space="preserve">
          <source>The result of md5(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) will be exactly the same as the result of md5(&quot;abc&quot;).</source>
          <target state="translated">md5(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)の結果は、md5(&quot;abc&quot;)の結果と全く同じになります。</target>
        </trans-unit>
        <trans-unit id="641d055cafe1e1ee3cae38ce56b7935f5d3bc2b3" translate="yes" xml:space="preserve">
          <source>The result of overflowing the range of the integers is undefined because it is undefined also in C. In other words, using 32-bit integers, &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; is undefined. Shifting by a negative number of bits is also undefined.</source>
          <target state="translated">整数の範囲をオーバーフローした結果は、Cでも定義されていないため、定義されていません。つまり、32ビット整数を使用すると、 &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; は定義されません。負のビット数によるシフトも定義されていません。</target>
        </trans-unit>
        <trans-unit id="00de3247a1fa0dbaa5340672e75fce7f76fa569f" translate="yes" xml:space="preserve">
          <source>The result of this scenario is at best a database that doesn't contain what you expect. At worst the database will corrupt.</source>
          <target state="translated">このシナリオの結果は、良くても期待したものが含まれていないデータベースになってしまいます。最悪の場合、データベースは破損します。</target>
        </trans-unit>
        <trans-unit id="f6de57c3d8ec6b1611fc0077d370dda9fed1574d" translate="yes" xml:space="preserve">
          <source>The result returned will be one of the following:</source>
          <target state="translated">返される結果は以下のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="0b8a9a1357d52322f675cb2cb87488ac744f63b6" translate="yes" xml:space="preserve">
          <source>The result string containing interpolated material is tainted if a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect.</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; を含む &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; の&lt;a href=&quot;functions/use&quot;&gt;使用&lt;/a&gt;フォームが有効な場合、補間された素材を含む結果文字列が汚染されます。</target>
        </trans-unit>
        <trans-unit id="dc181363eb40ff0bd863bde77567e9656e7a29d5" translate="yes" xml:space="preserve">
          <source>The result string containing interpolated material is tainted if a &lt;code&gt;use locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect.</source>
          <target state="translated">&lt;code&gt;LC_CTYPE&lt;/code&gt; を含む &lt;code&gt;use locale&lt;/code&gt; 形式の使用が有効な場合、補間されたマテリアルを含む結果文字列が汚染されます。</target>
        </trans-unit>
        <trans-unit id="51fb17ca190a73d84710650cb1a592da2c670185" translate="yes" xml:space="preserve">
          <source>The result will be an array of 3 elements, each a reference to an array which will hold the handles that are ready for reading, writing and have exceptions respectively. Upon error an empty list is returned.</source>
          <target state="translated">結果は 3 つの要素からなる配列となり、それぞれが読み込み、書き込み、例外処理が可能なハンドルを保持する配列への参照となります。エラーが発生した場合は空のリストが返されます。</target>
        </trans-unit>
        <trans-unit id="a68ddca584ffd166b11e615f1b961f7dd364600e" translate="yes" xml:space="preserve">
          <source>The result will be up to be three times the number of layers: the first element will be a name, the second element the arguments (unspecified arguments will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), the third element the flags, the fourth element a name again, and so forth.</source>
          <target state="translated">結果は最大でレイヤー数の3倍になります。最初の要素は名前、2番目の要素は引数（未指定の引数は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; になります）、3番目の要素はフラグ、4番目の要素は名前、というようになります。前方へ。</target>
        </trans-unit>
        <trans-unit id="3e9d88696af53de04206c2554e1cd6a14550e72c" translate="yes" xml:space="preserve">
          <source>The result will be up to be three times the number of layers: the first element will be a name, the second element the arguments (unspecified arguments will be &lt;code&gt;undef&lt;/code&gt;), the third element the flags, the fourth element a name again, and so forth.</source>
          <target state="translated">結果は、レイヤー数の最大3倍になります。最初の要素は名前、2番目の要素は引数（未指定の引数は &lt;code&gt;undef&lt;/code&gt; ）、3番目の要素はフラグ、4番目の要素は再び名前になります。前方へ。</target>
        </trans-unit>
        <trans-unit id="e6e0c7dba94f1684aba5f4cd6501d599a99358de" translate="yes" xml:space="preserve">
          <source>The resulting $subdir_cmd has no leading tab nor trailing newline. This makes it easier to embed in a make string. For example.</source>
          <target state="translated">結果として得られる $subdir_cmd には、先頭のタブも末尾の改行もありません。これにより、make文字列への埋め込みが容易になります。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="5f6fcb4f54789b9c880bc0144fb1cf2ebd3b3159" translate="yes" xml:space="preserve">
          <source>The resulting byte sequence is most convenient for checking the checksum. Don't slow your program down with a for loop adding the &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; values of this string's bytes - the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; code &lt;code&gt;%&lt;/code&gt; is the thing to use for computing the 8-bit sum of all bytes, which must be equal to zero:</source>
          <target state="translated">結果のバイトシーケンスは、チェックサムのチェックに最も便利です。この文字列のバイトの &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; 値を追加するforループでプログラムの速度を落とさないでください。 &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; コード &lt;code&gt;%&lt;/code&gt; は、すべてのバイトの8ビットの合計を計算するために使用するもので、ゼロに等しくなければなりません。</target>
        </trans-unit>
        <trans-unit id="7e685873aa2576bcd6d048591b67cf99d300730d" translate="yes" xml:space="preserve">
          <source>The resulting byte sequence is most convenient for checking the checksum. Don't slow your program down with a for loop adding the &lt;code&gt;ord&lt;/code&gt; values of this string's bytes - the &lt;code&gt;unpack&lt;/code&gt; code &lt;code&gt;%&lt;/code&gt; is the thing to use for computing the 8-bit sum of all bytes, which must be equal to zero:</source>
          <target state="translated">結果のバイトシーケンスは、チェックサムをチェックするのに最も便利です。この文字列のバイトの &lt;code&gt;ord&lt;/code&gt; 値を追加するforループでプログラムの速度を落とさないでください- &lt;code&gt;unpack&lt;/code&gt; コード &lt;code&gt;%&lt;/code&gt; は、すべてのバイトの8ビット合計を計算するために使用するものです。これはゼロに等しくなければなりません。</target>
        </trans-unit>
        <trans-unit id="421b5462923e8d16da2f8509620d57a56b898133" translate="yes" xml:space="preserve">
          <source>The resulting path is relative by default, i.e. the resulting path will have a leading colon.</source>
          <target state="translated">結果のパスはデフォルトでは相対パスになります。</target>
        </trans-unit>
        <trans-unit id="d4b19b5c805ca56f431cfbcdeba1af9f3a6200a3" translate="yes" xml:space="preserve">
          <source>The resulting program then looks like:</source>
          <target state="translated">そして、結果として得られるプログラムは次のようになります。</target>
        </trans-unit>
        <trans-unit id="e4aa8c76073812eb40b9e292fb100c683926c76e" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath&quot;&gt;&quot;catpath&quot;&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">結果を&lt;a href=&quot;#catpath&quot;&gt;「catpath」&lt;/a&gt;に渡して、元のパスと同等の（通常は同一の）パスを取得できます。</target>
        </trans-unit>
        <trans-unit id="bd638c59c5752a7ccfc83a3bf825d1784299cda6" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath&quot;&gt;catpath&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">結果を&lt;a href=&quot;#catpath&quot;&gt;catpath&lt;/a&gt;に渡して、元のパスと同等の（通常は同じ）パスを取得できます。</target>
        </trans-unit>
        <trans-unit id="156c1084cc95fa3e7b597345b8d09fde064a081b" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath%28%29&quot;&gt;&quot;catpath()&quot;&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">結果を&lt;a href=&quot;#catpath%28%29&quot;&gt;「catpath（）」&lt;/a&gt;に渡して、元のパスと同等の（通常は同一の）パスを取得できます。</target>
        </trans-unit>
        <trans-unit id="fbae74b52e9e1a2f4034868dc967236dfb097109" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath()&quot;&gt;catpath()&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">結果を&lt;a href=&quot;#catpath()&quot;&gt;catpath（）&lt;/a&gt;に渡して、元のパスと同等の（通常は同じ）パスを取得できます。</target>
        </trans-unit>
        <trans-unit id="9fd6f04fef4668c0fb9b5436580855adbbe256e9" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;code&gt;catpath()&lt;/code&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">結果を &lt;code&gt;catpath()&lt;/code&gt; に渡して、元のパスと同等の（通常は同じ）パスを取得できます。</target>
        </trans-unit>
        <trans-unit id="7b48baa73a171c70124bb46d586398a253fc305f" translate="yes" xml:space="preserve">
          <source>The results follow ASCII rules. Only the characters &lt;code&gt;A-Z&lt;/code&gt; change, to &lt;code&gt;a-z&lt;/code&gt; respectively.</source>
          <target state="translated">結果はASCII規則に従います。文字 &lt;code&gt;A-Z&lt;/code&gt; だけがそれぞれ &lt;code&gt;a-z&lt;/code&gt; 変わります。</target>
        </trans-unit>
        <trans-unit id="e6e1386230ca5a3e137558786aef0b9ef4ab7b59" translate="yes" xml:space="preserve">
          <source>The results of creating new symbol table entries directly or modifying any entries that are not already typeglobs are undefined and subject to change between releases of perl.</source>
          <target state="translated">新しいシンボルテーブルのエントリを直接作成したり、既にタイプグローブではないエントリを修正したりした結果は未定義であり、perlのリリース間で変更される可能性があります。</target>
        </trans-unit>
        <trans-unit id="7c1728e8e43393222dde9f78fe3123aaa1846fe7" translate="yes" xml:space="preserve">
          <source>The return from &lt;code&gt;VERSION&lt;/code&gt; will actually be the stringified version object using the package &lt;code&gt;$VERSION&lt;/code&gt; scalar, which is guaranteed to be equivalent but may not be precisely the contents of the &lt;code&gt;$VERSION&lt;/code&gt; scalar. If you want the actual contents of &lt;code&gt;$VERSION&lt;/code&gt; , use &lt;code&gt;$CLASS::VERSION&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;VERSION&lt;/code&gt; からの戻りは、実際には、パッケージ &lt;code&gt;$VERSION&lt;/code&gt; スカラーを使用した文字列化されたバージョンオブジェクトになります。これは、同等であることが保証されていますが、正確には &lt;code&gt;$VERSION&lt;/code&gt; スカラーの内容ではない場合があります。あなたは、実際の中身たい場合は &lt;code&gt;$VERSION&lt;/code&gt; 、使用 &lt;code&gt;$CLASS::VERSION&lt;/code&gt; 代わりに。</target>
        </trans-unit>
        <trans-unit id="95e455ea284fe76f90c5b0d39ee105831c2e5eaa" translate="yes" xml:space="preserve">
          <source>The return from &lt;code&gt;VERSION&lt;/code&gt; will actually be the stringified version object using the package &lt;code&gt;$VERSION&lt;/code&gt; scalar, which is guaranteed to be equivalent but may not be precisely the contents of the &lt;code&gt;$VERSION&lt;/code&gt; scalar. If you want the actual contents of &lt;code&gt;$VERSION&lt;/code&gt;, use &lt;code&gt;$CLASS::VERSION&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;VERSION&lt;/code&gt; からの戻り値は、実際にはパッケージ &lt;code&gt;$VERSION&lt;/code&gt; スカラーを使用した文字列化されたバージョンオブジェクトになります。これは同等であることが保証されていますが、 &lt;code&gt;$VERSION&lt;/code&gt; スカラーの内容と正確に一致しない場合があります。あなたは、実際の中身たい場合は &lt;code&gt;$VERSION&lt;/code&gt; 、使用 &lt;code&gt;$CLASS::VERSION&lt;/code&gt; 代わりに。</target>
        </trans-unit>
        <trans-unit id="94b2a16af23a66e19e44621474dc0fa990710d75" translate="yes" xml:space="preserve">
          <source>The return list of the generated Perl function consists of the C return value from the function (unless the XSUB is of &lt;code&gt;void&lt;/code&gt; return type or &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; was used) followed by all the &lt;code&gt;OUTLIST&lt;/code&gt; and &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters (in the order of appearance). On the return from the XSUB the &lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; Perl parameter will be modified to have the values written by the C function.</source>
          <target state="translated">生成されたPerl関数の戻りリストは、関数からのC戻り値（XSUBが &lt;code&gt;void&lt;/code&gt; 戻り型であるか &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; が使用された場合を除く）と、その後に続くすべての &lt;code&gt;OUTLIST&lt;/code&gt; および &lt;code&gt;IN_OUTLIST&lt;/code&gt; パラメーター（出現順に）で構成されます。XSUBからの戻り時に、 &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; Perlパラメータは、C関数によって書き込まれた値を持つように変更されます。</target>
        </trans-unit>
        <trans-unit id="44655e68104aa5b50fd85988b88ae70262129b43" translate="yes" xml:space="preserve">
          <source>The return list of the generated Perl function consists of the C return value from the function (unless the XSUB is of &lt;code&gt;void&lt;/code&gt; return type or &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; was used) followed by all the &lt;code&gt;OUTLIST&lt;/code&gt; and &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters (in the order of appearance). On the return from the XSUB the &lt;code&gt;IN_OUT&lt;/code&gt;/&lt;code&gt;OUT&lt;/code&gt; Perl parameter will be modified to have the values written by the C function.</source>
          <target state="translated">生成されたPerl関数の戻りリストは、関数からのC戻り値（XSUBが &lt;code&gt;void&lt;/code&gt; 戻り型であるか &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; が使用された場合を除く）と、それに続くすべての &lt;code&gt;OUTLIST&lt;/code&gt; および &lt;code&gt;IN_OUTLIST&lt;/code&gt; パラメーター（出現順に）で構成されます。XSUBから戻ると、 &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; Perlパラメーターが変更され、C関数によって値が書き込まれるようになります。</target>
        </trans-unit>
        <trans-unit id="d71452936695d00a40f619faefe33e6d1a6ac20b" translate="yes" xml:space="preserve">
          <source>The return may be incorrect for those rare locales where the currency symbol replaces the radix character. Send email to &lt;a href=&quot;mailto:perlbug@perl.org&quot;&gt;mailto:perlbug@perl.org&lt;/a&gt; if you have examples of it needing to work differently.</source>
          <target state="translated">通貨記号が基数文字に置き換わるまれなロケールでは、戻り値が正しくない場合があります。別の方法で動作する必要がある例がある場合は、&lt;a href=&quot;mailto:perlbug@perl.org&quot;&gt;mailto：perlbug@perl.orgに&lt;/a&gt;電子メールを送信してください。</target>
        </trans-unit>
        <trans-unit id="0420f753fa3324f9eec48f35a50efc8cee6a049e" translate="yes" xml:space="preserve">
          <source>The return points to a per-thread static buffer, which is overwritten the next time &lt;code&gt;Perl_setlocale&lt;/code&gt; is called from the same thread.</source>
          <target state="translated">戻り値は、スレッドごとの静的バッファーを &lt;code&gt;Perl_setlocale&lt;/code&gt; ます。このバッファーは、次に同じスレッドからPerl_setlocaleが呼び出されたときに上書きされます。</target>
        </trans-unit>
        <trans-unit id="a21da59cc5c1c0e700b109e9dda17411cbacb1df" translate="yes" xml:space="preserve">
          <source>The return true when the argument satisfies the condition. &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; , &lt;code&gt;-inf&lt;/code&gt; are not integers and are neither odd nor even.</source>
          <target state="translated">引数が条件を満たす場合、trueを返します。 &lt;code&gt;NaN&lt;/code&gt; 、 &lt;code&gt;+inf&lt;/code&gt; 、 &lt;code&gt;-inf&lt;/code&gt; は整数ではなく、奇数でも偶数でもありません。</target>
        </trans-unit>
        <trans-unit id="b8bfaca788fa3c0ddbe45ea5ad9f0da16e79efb8" translate="yes" xml:space="preserve">
          <source>The return value (if defined) is a Perl object, of class &lt;code&gt;PerlIO::Layer&lt;/code&gt; which is created by the C code in</source>
          <target state="translated">戻り値（定義されている場合）は、Perlオブジェクトです：クラス &lt;code&gt;PerlIO::Layer&lt;/code&gt; で、Cコードによって作成されます。</target>
        </trans-unit>
        <trans-unit id="45642a1469744a5e7107d7873a8272d52cfce5d2" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">戻り値 &lt;code&gt;LVALUE&lt;/code&gt; は、変数ではない左辺値への参照を示します。これは、 &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; などの関数呼び出しの参照から取得します。参照が&lt;a href=&quot;perldata#Version-Strings&quot;&gt;バージョン文字列を&lt;/a&gt;指している場合、 &lt;code&gt;VSTRING&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="68a59800451bff6b585d75aa0febce039f889432" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;../perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">戻り値 &lt;code&gt;LVALUE&lt;/code&gt; は、変数ではない左辺値への参照を示します。これは、 &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; などの関数呼び出しの参照から取得します。参照が&lt;a href=&quot;../perldata#Version-Strings&quot;&gt;バージョン文字列を&lt;/a&gt;指している場合、 &lt;code&gt;VSTRING&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="d1b1a3b59d37e5fda7fca51bd6d7cc822e1098fc" translate="yes" xml:space="preserve">
          <source>The return value can be &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed to get back an identical copy of the original reference structure. (Please do consider the security implications of eval'ing code from untrusted sources!)</source>
          <target state="translated">戻り値を &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 、元の参照構造の同一のコピーを取得できます。（信頼できないソースからの評価コードのセキュリティへの影響を考慮してください！）</target>
        </trans-unit>
        <trans-unit id="341077e987e38231c6848bd510801f6ac305a364" translate="yes" xml:space="preserve">
          <source>The return value can be &lt;code&gt;eval&lt;/code&gt;ed to get back an identical copy of the original reference structure. (Please do consider the security implications of eval'ing code from untrusted sources!)</source>
          <target state="translated">戻り値を &lt;code&gt;eval&lt;/code&gt; 、元の参照構造の同一のコピーを取得できます。（信頼できないソースからのコードを評価することのセキュリティへの影響を考慮してください！）</target>
        </trans-unit>
        <trans-unit id="5ce36c299811e6d9af00c0cefc9c75e073456ac7" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; の戻り値は実装定義です。詳細については、atan2（3）のマンページを参照してください。</target>
        </trans-unit>
        <trans-unit id="769d902022de1a90d1cd24370f703e7b45d5dad4" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; の戻り値は実装定義です。詳細については、atan2（3）のマンページを参照してください。</target>
        </trans-unit>
        <trans-unit id="3f7e47c80e390cbc99d4bd2d52e4ac31f1eae4a5" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;atan2(0,0)&lt;/code&gt; is implementation-defined; consult your &lt;a href=&quot;http://man.he.net/man3/atan2&quot;&gt;atan2(3)&lt;/a&gt; manpage for more information.</source>
          <target state="translated">&lt;code&gt;atan2(0,0)&lt;/code&gt; の戻り値は、実装によって定義されます。詳細については、&lt;a href=&quot;http://man.he.net/man3/atan2&quot;&gt;atan2（3）の&lt;/a&gt;マンページを参照してください。</target>
        </trans-unit>
        <trans-unit id="7fa7da95c4b58e8bb23e135f8795df5f9ac97aa0" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;true&lt;/code&gt; if this is a valid prototype, and &lt;code&gt;false&lt;/code&gt; if it is not, regardless of whether &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; was &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">戻り値は &lt;code&gt;true&lt;/code&gt; これは有効なプロトタイプであれば、そして &lt;code&gt;false&lt;/code&gt; それは関係なく、かどうかにされていない場合 &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; した &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c3cd7efde35a3e831a5bdd29d0ed5265715cc55" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;true&lt;/code&gt; if this is a valid prototype, and &lt;code&gt;false&lt;/code&gt; if it is not, regardless of whether &lt;code&gt;warn&lt;/code&gt; was &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">戻り値は &lt;code&gt;true&lt;/code&gt; これは有効なプロトタイプであれば、そして &lt;code&gt;false&lt;/code&gt; それは関係なく、かどうかにされていない場合 &lt;code&gt;warn&lt;/code&gt; した &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd97a8975a72082d0544ff1e498721e427862ae3" translate="yes" xml:space="preserve">
          <source>The return value is POSIX-like (shifted up by 8 bits), which only allows room for a made-up value derived from the severity bits of the native 32-bit condition code (unless overridden by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; ). If the native condition code is one that has a POSIX value encoded, the POSIX value will be decoded to extract the expected exit value. For more details see &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? in perlvms&lt;/a&gt;. (VMS)</source>
          <target state="translated">戻り値はPOSIXに似ており（8ビット上にシフトアップ）、ネイティブの32ビット条件コードの重大度ビットから派生した値を &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; （vmsish 'status'を&lt;a href=&quot;functions/use&quot;&gt;使用して&lt;/a&gt;オーバーライドしない限り）。ネイティブの条件コードがPOSIX値がエンコードされているコードである場合、POSIX値はデコードされ、予期される終了値が抽出されます。詳細は&lt;a href=&quot;perlvms#%24%3f&quot;&gt;$？を&lt;/a&gt;ご覧ください。perlvmsで。（VMS）</target>
        </trans-unit>
        <trans-unit id="38f16262d38a09b1b50bf9932e5e395bae210a67" translate="yes" xml:space="preserve">
          <source>The return value is a boolean: TRUE if the global locale at the time of call was in effect; and FALSE if a per-thread locale was in effect. This can be used by the caller that needs to restore things as-they-were to decide whether or not to call &lt;a href=&quot;perlapi#switch_to_global_locale&quot;&gt;&lt;code&gt;Perl_switch_to_global_locale&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">戻り値はブール値です。呼び出し時のグローバルロケールが有効だった場合はTRUE。スレッドごとのロケールが有効な場合はFALSE。これは、&lt;a href=&quot;perlapi#switch_to_global_locale&quot;&gt; &lt;code&gt;Perl_switch_to_global_locale&lt;/code&gt; &lt;/a&gt;を呼び出すかどうかを決定するために、物事を復元する必要がある呼び出し元が使用できます。</target>
        </trans-unit>
        <trans-unit id="f7f3af5a62c5a74bbd990f1648eb2762ff5d0f59" translate="yes" xml:space="preserve">
          <source>The return value is always a scalar, either a string or a number. For properties where there are synonyms for the values, the synonym returned by this function is the longest, most descriptive form, the one returned by &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; when called in a scalar context. Of course, you can call &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; on the result to get other synonyms.</source>
          <target state="translated">戻り値は常に文字列または数値のいずれかのスカラーです。値のシノニムがあるプロパティの場合、この関数によって返されるシノニムは、スカラーコンテキストで呼び出されたときに&lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;「prop_value_aliases（）」&lt;/a&gt;によって返される、最も長く、最も説明的な形式です。もちろん、結果に対して&lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;「prop_value_aliases（）」&lt;/a&gt;を呼び出して、他の同義語を取得することもできます。</target>
        </trans-unit>
        <trans-unit id="43901da674d6737b62ebf11f4c04c938005307af" translate="yes" xml:space="preserve">
          <source>The return value is always a scalar, either a string or a number. For properties where there are synonyms for the values, the synonym returned by this function is the longest, most descriptive form, the one returned by &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; when called in a scalar context. Of course, you can call &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; on the result to get other synonyms.</source>
          <target state="translated">戻り値は常に文字列または数値のスカラーです。値の同義語があるプロパティの場合、この関数によって返される同義語は、最も長くて最も記述的な形式であり、スカラーコンテキストで呼び出されたときに&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;によって返される形式です。もちろん、結果に対して&lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases（）&lt;/a&gt;を呼び出して、他の同義語を取得できます。</target>
        </trans-unit>
        <trans-unit id="897578330f8509b5163b4447af0b4daff044a33c" translate="yes" xml:space="preserve">
          <source>The return value is formatted according to OLE conventions, as groups of hex digits with surrounding braces. For example:</source>
          <target state="translated">戻り値は、OLEの規約に従って、16進数のグループとそれを囲む中括弧でフォーマットされます。例えば、以下のようになります。</target>
        </trans-unit>
        <trans-unit id="01e2753bab1a4f25f52114a02dccb7b840c45d95" translate="yes" xml:space="preserve">
          <source>The return value is the $ctx object itself.</source>
          <target state="translated">戻り値は$ctxオブジェクトそのものです。</target>
        </trans-unit>
        <trans-unit id="437a2be9f2de32d0576eb59aa85a5731812472a7" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt;. This is</source>
          <target state="translated">戻り値は、&lt;a href=&quot;#wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;呼び出しによって返されるプログラムの終了ステータスです。実際の終了値を取得するには、右に8シフトします（以下を参照）。&lt;a href=&quot;#exec-LIST&quot;&gt; &lt;code&gt;exec&lt;/code&gt; &lt;/a&gt;も参照してください。これは</target>
        </trans-unit>
        <trans-unit id="52ee5d406f163544969cdcc538ef722336dcb763" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">戻り値は、 &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 呼び出しによって返されるプログラムの終了ステータスです。実際の終了値を取得するには、右に8シフトします（以下を参照）。&lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt;も参照してください。これは</target>
        </trans-unit>
        <trans-unit id="aadd087b1069c48b3ff2e37ed0925a6bb732b05e" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">戻り値は、 &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; 呼び出しによって返されるプログラムの終了ステータスです。実際の終了値を取得するには、右に8シフトします（以下を参照）。&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;も参照してください。これは</target>
        </trans-unit>
        <trans-unit id="28ff84250f55ab2bea98fda52eb0b62db0c2d4bd" translate="yes" xml:space="preserve">
          <source>The return value is the total length &lt;code&gt;src&lt;/code&gt; would be if the copy completely succeeded. If it is larger than &lt;code&gt;size&lt;/code&gt;, the excess was not copied.</source>
          <target state="translated">戻り値は、コピーが完全に成功した場合の &lt;code&gt;src&lt;/code&gt; の全長です。 &lt;code&gt;size&lt;/code&gt; より大きい場合、超過分はコピーされませんでした。</target>
        </trans-unit>
        <trans-unit id="db618f76ec023ae4b98dae939007dd3399a79764" translate="yes" xml:space="preserve">
          <source>The return value is the total length that &lt;code&gt;dst&lt;/code&gt; would have if &lt;code&gt;size&lt;/code&gt; is sufficiently large. Thus it is the initial length of &lt;code&gt;dst&lt;/code&gt; plus the length of &lt;code&gt;src&lt;/code&gt;. If &lt;code&gt;size&lt;/code&gt; is smaller than the return, the excess was not appended.</source>
          <target state="translated">戻り値は、 &lt;code&gt;size&lt;/code&gt; が十分に大きい場合に &lt;code&gt;dst&lt;/code&gt; が持つ全長です。したがって、これは &lt;code&gt;dst&lt;/code&gt; の初期長に &lt;code&gt;src&lt;/code&gt; の長さを加えたものです。 &lt;code&gt;size&lt;/code&gt; が返品よりも小さい場合、超過分は追加されませんでした。</target>
        </trans-unit>
        <trans-unit id="857262cdace40b471947bb6d3b761ee596eafe64" translate="yes" xml:space="preserve">
          <source>The return value is the updated object itself.</source>
          <target state="translated">戻り値は更新されたオブジェクトそのものです。</target>
        </trans-unit>
        <trans-unit id="7f93f7b8be78580a6fdb8b5153d679ad923050d6" translate="yes" xml:space="preserve">
          <source>The return value may be a list containing zero or more of an arrayref, an integer, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">戻り値は、ゼロ以上のarrayref、整数、または &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を含むリストです。</target>
        </trans-unit>
        <trans-unit id="3f37d26524cdd675f6f08be05c61f9223fd0378a" translate="yes" xml:space="preserve">
          <source>The return value may be a list containing zero or more of an arrayref, an integer, or &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="translated">戻り値は、0個以上のarrayref、整数、または &lt;code&gt;undef&lt;/code&gt; を含むリストです。</target>
        </trans-unit>
        <trans-unit id="36fd088c56b8f88cc2d2e8985a8fda08a71a63d3" translate="yes" xml:space="preserve">
          <source>The return value may be an arrayref of 1st to 4th weights as shown above. The return value may be an integer as the primary weight as shown below. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned, the default derived collation element will be used.</source>
          <target state="translated">上記のように、戻り値は、1番目から4番目の重みのarrayrefになります。戻り値は、以下に示すように、主要な重みとして整数にすることができます。場合 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 返され、デフォルト派生照合要素が使用されます。</target>
        </trans-unit>
        <trans-unit id="68d7e0ec957990f452acfaa57c18c8410bd4dda3" translate="yes" xml:space="preserve">
          <source>The return value may be an arrayref of 1st to 4th weights as shown above. The return value may be an integer as the primary weight as shown below. If &lt;code&gt;undef&lt;/code&gt; is returned, the default derived collation element will be used.</source>
          <target state="translated">戻り値は、上記のように1番目から4番目の重みのarrayrefです。戻り値は、以下に示すように、プライマリウェイトとして整数にすることができます。場合 &lt;code&gt;undef&lt;/code&gt; 返され、デフォルト派生照合要素が使用されます。</target>
        </trans-unit>
        <trans-unit id="222fe952afa9c24172c89b0f769d4878a2ea7ad7" translate="yes" xml:space="preserve">
          <source>The return value of &lt;a href=&quot;#ioctl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;ioctl&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;#fcntl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;fcntl&lt;/code&gt;&lt;/a&gt;) is as follows:</source>
          <target state="translated">&lt;a href=&quot;#ioctl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt; &lt;code&gt;ioctl&lt;/code&gt; &lt;/a&gt;（および&lt;a href=&quot;#fcntl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt; &lt;code&gt;fcntl&lt;/code&gt; &lt;/a&gt;）の戻り値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="a717c20899094357a3bea685885351b6040d8de0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; for the standard streams like the STDIN depends on the operating system: it may return -1 or something else. &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; on pipes, fifos, and sockets usually returns -1.</source>
          <target state="translated">STDINのような標準ストリームの&lt;a href=&quot;#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt;の戻り値は、オペレーティングシステムによって異なります。-1などを返す場合があります。&lt;a href=&quot;#tell-FILEHANDLE&quot;&gt; &lt;code&gt;tell&lt;/code&gt; &lt;/a&gt;パイプ、FIFO、そしてソケットで、通常は-1を返します。</target>
        </trans-unit>
        <trans-unit id="9d5675dc8f958bc8634e0a1b5851a8577fc5c3bc" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; （および &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ）の戻り値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="03abb254ae6958b0d4d3e3d838f5570ae93832e6" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; （および &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ）の戻り値は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="16085bf8175ff49a2dcc989db1bc66f5346f4ab0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;INLINED&lt;/code&gt; in this example will always be 54321, regardless of later modifications to $x. You can also put any arbitrary code inside the sub, at it will be executed immediately and its return value captured the same way.</source>
          <target state="translated">この例の &lt;code&gt;INLINED&lt;/code&gt; の戻り値は、後の$ xの変更に関係なく、常に54321になります。サブルーチン内に任意のコードを置くこともできます。サブコードはすぐに実行され、戻り値も同じ方法でキャプチャされます。</target>
        </trans-unit>
        <trans-unit id="f23542316437f18c2dc0de0ad16ae0deb404671a" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;survey&lt;/code&gt; is two hashes:</source>
          <target state="translated">&lt;code&gt;survey&lt;/code&gt; の戻り値は2つのハッシュです。</target>
        </trans-unit>
        <trans-unit id="6c7d2d6bce6775764986b9434f93f3fd3d99f22b" translate="yes" xml:space="preserve">
          <source>The return value of Pod::Perldoc::GetOptsOO::getopts is true if no errors, otherwise it's false.</source>
          <target state="translated">Pod::Perldoc::GetOptsOO::getoptsの戻り値は、エラーがなければtrue、そうでなければfalseです。</target>
        </trans-unit>
        <trans-unit id="57cb77ff2698d7727be628530d185f8aa579f00d" translate="yes" xml:space="preserve">
          <source>The return value of tell() for the standard streams like the STDIN depends on the operating system: it may return -1 or something else. tell() on pipes, fifos, and sockets usually returns -1.</source>
          <target state="translated">STDIN のような標準ストリームの tell()の戻り値はオペレーティングシステムに依存します。</target>
        </trans-unit>
        <trans-unit id="d4713d5655dc6e9b8c7a80e55df87e6a297b0b32" translate="yes" xml:space="preserve">
          <source>The return value will be &lt;code&gt;NULL&lt;/code&gt; if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise it can be dereferenced to get the original &lt;code&gt;SV*&lt;/code&gt;. Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned &lt;code&gt;NULL&lt;/code&gt;. Effectively a successful &lt;code&gt;hv_store&lt;/code&gt; takes ownership of one reference to &lt;code&gt;val&lt;/code&gt;. This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, &lt;code&gt;hv_store&lt;/code&gt; will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. &lt;code&gt;hv_store&lt;/code&gt; is not implemented as a call to &lt;code&gt;hv_store_ent&lt;/code&gt;, and does not create a temporary SV for the key, so if your key data is not already in SV form then use &lt;code&gt;hv_store&lt;/code&gt; in preference to &lt;code&gt;hv_store_ent&lt;/code&gt;.</source>
          <target state="translated">操作が失敗した場合、または値を実際にハッシュ内に格納する必要がなかった場合（タイハッシュの場合のように）、戻り値は &lt;code&gt;NULL&lt;/code&gt; になります。それ以外の場合は、逆参照して元の &lt;code&gt;SV*&lt;/code&gt; を取得できます。呼び出し元は、呼び出しの前に &lt;code&gt;val&lt;/code&gt; の参照カウントを適切にインクリメントし、関数が &lt;code&gt;NULL&lt;/code&gt; を返した場合はそれをデクリメントする責任があることに注意してください。事実上、成功した &lt;code&gt;hv_store&lt;/code&gt; は、 &lt;code&gt;val&lt;/code&gt; への1つの参照の所有権を取得します。これは通常あなたが望むものです。新しく作成されたSVの参照カウントは1であるため、コードでSVを作成するだけの場合は、ハッシュ &lt;code&gt;hv_store&lt;/code&gt; に保存します。新しいSVへの唯一の参照を所有し、コードを整理するためにこれ以上何もする必要はありません。 &lt;code&gt;hv_store&lt;/code&gt; はへの呼び出しとして実装されていません &lt;code&gt;hv_store_ent&lt;/code&gt; 、そしてあなたの鍵データは、その後使用SVの形になっていないそうだとすれば、キーのための一時的なSVを作成しません &lt;code&gt;hv_store&lt;/code&gt; のに優先して &lt;code&gt;hv_store_ent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="972da9f747345510c81b2dc820fd0994a9799509" translate="yes" xml:space="preserve">
          <source>The return value will be NULL if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise it can be dereferenced to get the original &lt;code&gt;SV*&lt;/code&gt; . Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL. Effectively a successful hv_store takes ownership of one reference to &lt;code&gt;val&lt;/code&gt; . This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, hv_store will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. hv_store is not implemented as a call to hv_store_ent, and does not create a temporary SV for the key, so if your key data is not already in SV form then use hv_store in preference to hv_store_ent.</source>
          <target state="translated">操作が失敗した場合、または値が実際にハッシュ内に格納される必要がなかった場合（結合ハッシュの場合など）、戻り値はNULLになります。それ以外の場合は、逆参照して元の &lt;code&gt;SV*&lt;/code&gt; を取得できます。呼び出し元は、呼び出しの前に &lt;code&gt;val&lt;/code&gt; の参照カウントを適切にインクリメントし、関数がNULLを返した場合はそれをデクリメントする責任があることに注意してください。効果的にhv_storeが成功すると、 &lt;code&gt;val&lt;/code&gt; への1つの参照の所有権が取得されます。通常、これが必要です。新しく作成されたSVの参照カウントは1であるため、すべてのコードがSVを作成してハッシュに格納する場合、hv_storeは新しいSVへの唯一の参照を所有し、コードはこれ以上何もする必要がありません。片付ける。 hv_storeはhv_store_entの呼び出しとして実装されておらず、キーの一時SVを作成しないため、キーデータがまだSV形式でない場合は、hv_store_entよりもhv_storeを使用してください。</target>
        </trans-unit>
        <trans-unit id="9bfc61e3c5920efd0c58d16c1ed44649d2d5bb7c" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error condition, followed by the hostname and service name.</source>
          <target state="translated">返り値はリストで、最初の値はエラー状態、ホスト名とサービス名が続きます。</target>
        </trans-unit>
        <trans-unit id="080fb2b25b92c9701522bdcbe08ea5301edb65d9" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error indication, followed by a list of address structures (if no error occurred).</source>
          <target state="translated">返り値はリストになります。最初の値はエラー表示で、その後にアドレス構造のリストが続きます(エラーが発生しなかった場合)。</target>
        </trans-unit>
        <trans-unit id="e58ba0106a37355ff008e5789a74611883b7e6cc" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains a reference to an array which contains the overview fields for that message.</source>
          <target state="translated">戻り値はハッシュへの参照となり、キーはメッセージ番号で、各値にはそのメッセージの概要フィールドを含む配列への参照が含まれます。</target>
        </trans-unit>
        <trans-unit id="c8d88b4235e896d1cdf2637f38fe289f36609de1" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains the text of the requested header for that message.</source>
          <target state="translated">戻り値はハッシュへの参照となり、キーはメッセージ番号で、各値にはそのメッセージの要求されたヘッダのテキストが含まれます。</target>
        </trans-unit>
        <trans-unit id="7ff5356b785d18cf62379ed63c212e5a8a9ffb9a" translate="yes" xml:space="preserve">
          <source>The return values are more &quot;cooked&quot; than the &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt; ones. For example, the &lt;code&gt;&quot;uc&quot;&lt;/code&gt; property value is the actual string containing the full uppercase mapping of the input code point. You have to go to extra trouble with &lt;code&gt;charinfo&lt;/code&gt; to get this value from its &lt;code&gt;upper&lt;/code&gt; hash element when the full mapping differs from the simple one.</source>
          <target state="translated">戻り値は、&lt;a href=&quot;#charinfo%28%29&quot;&gt;「charinfo（）」の&lt;/a&gt;ものよりも「調理済み」です。たとえば、 &lt;code&gt;&quot;uc&quot;&lt;/code&gt; プロパティ値は、入力コードポイントの完全な大文字マッピングを含む実際の文字列です。完全なマッピングが単純なマッピングと異なる場合、 &lt;code&gt;upper&lt;/code&gt; ハッシュ要素からこの値を取得するには、 &lt;code&gt;charinfo&lt;/code&gt; でさらに問題が発生する必要があります。</target>
        </trans-unit>
        <trans-unit id="17d18fcb9f371a15bbc60a7727df47264e8d90a5" translate="yes" xml:space="preserve">
          <source>The return values are more &quot;cooked&quot; than the &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; ones. For example, the &lt;code&gt;&quot;uc&quot;&lt;/code&gt; property value is the actual string containing the full uppercase mapping of the input code point. You have to go to extra trouble with &lt;code&gt;charinfo&lt;/code&gt; to get this value from its &lt;code&gt;upper&lt;/code&gt; hash element when the full mapping differs from the simple one.</source>
          <target state="translated">戻り値は、&lt;a href=&quot;#charinfo()&quot;&gt;charinfo（）&lt;/a&gt;の戻り値よりも「クック」されています。たとえば、 &lt;code&gt;&quot;uc&quot;&lt;/code&gt; プロパティ値は、入力コードポイントの完全な大文字のマッピングを含む実際の文字列です。完全なマッピングが単純なマッピングと異なる場合は、 &lt;code&gt;charinfo&lt;/code&gt; を使用して余分な問題を解決し、 &lt;code&gt;upper&lt;/code&gt; ハッシュ要素からこの値を取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="a0c27b1b52fce6c8f2f090cdffac0089b776c9ec" translate="yes" xml:space="preserve">
          <source>The returned NaN is always a</source>
          <target state="translated">返されるNaNは常に</target>
        </trans-unit>
        <trans-unit id="e761cd70527853f3676a64d7d2be637d80127b77" translate="yes" xml:space="preserve">
          <source>The returned hash consists of 4 parts:</source>
          <target state="translated">返されるハッシュは4つの部分で構成されています。</target>
        </trans-unit>
        <trans-unit id="ac925fdbc70f038b7d79d3f22cbbb8542015b931" translate="yes" xml:space="preserve">
          <source>The returned list will begin with the initial value for &lt;code&gt;$a&lt;/code&gt;, followed by each return value from the block in order. The final value of the result will be identical to what the &lt;code&gt;reduce&lt;/code&gt; function would have returned given the same block and list.</source>
          <target state="translated">返されるリストは、 &lt;code&gt;$a&lt;/code&gt; 初期値で始まり、ブロックからの各戻り値が順番に続きます。結果の最終値は、同じブロックとリストが与えられた場合に &lt;code&gt;reduce&lt;/code&gt; 関数が返す値と同じになります。</target>
        </trans-unit>
        <trans-unit id="3df12c311a5affa1878c7637ef497a0992643ca1" translate="yes" xml:space="preserve">
          <source>The returned object will only be valid as long as the underlying OPs and SVs continue to exist. Do not attempt to use the object after the underlying structures are freed.</source>
          <target state="translated">返されたオブジェクトは、基礎となる OP と SV が存在し続ける限り有効です。基礎となる構造体が解放された後にオブジェクトを使用しようとしないでください。</target>
        </trans-unit>
        <trans-unit id="27c81be6b30926294699f4659627b6ffa79304d4" translate="yes" xml:space="preserve">
          <source>The returned script will be &lt;code&gt;SCX_Inherited&lt;/code&gt; iff all the code points in it are from the Inherited script.</source>
          <target state="translated">返されるスクリプトは、その中のすべてのコードポイントが継承されたスクリプトからのものである場合、 &lt;code&gt;SCX_Inherited&lt;/code&gt; されます。</target>
        </trans-unit>
        <trans-unit id="2c9c36a9cfb66d7244d884d86187f93dbed4c9d0" translate="yes" xml:space="preserve">
          <source>The returned value will have the characters that can't be decoded replaced by &quot;\x{FFFD}&quot;, the Unicode replacement character.</source>
          <target state="translated">返された値は、デコードできない文字をUnicode置換文字である「\x{FFFD}」に置き換えたものになります。</target>
        </trans-unit>
        <trans-unit id="afb88fca63fb7d940d0f8f78e07d1c80fa709c01" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;#values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">戻り値はハッシュ内の元のキーのコピーであるため、それらを変更しても元のハッシュには影響しません。&lt;a href=&quot;#values&quot;&gt;値を&lt;/a&gt;比較します。</target>
        </trans-unit>
        <trans-unit id="a3aac40383199a850fb451c54d0b1c983a804515" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">戻り値はハッシュ内の元のキーのコピーであるため、それらを変更しても元のハッシュには影響しません。&lt;a href=&quot;#values-HASH&quot;&gt; &lt;code&gt;values&lt;/code&gt; &lt;/a&gt;比較します。</target>
        </trans-unit>
        <trans-unit id="9d53dad6b674af04a6d84ac0aee48048c271fdde" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">戻り値はハッシュ内の元のキーのコピーであるため、それらを変更しても元のハッシュには影響しません。&lt;a href=&quot;values&quot;&gt;値を&lt;/a&gt;比較します。</target>
        </trans-unit>
        <trans-unit id="21a00c167788624d4ca90d4b617125a344dae47a" translate="yes" xml:space="preserve">
          <source>The returned values for the Perl extension properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;Greek&lt;/code&gt; are somewhat misleading. The values are either &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot;. All Unicode properties are bipartite, so you can actually use the &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot; in a Perl regular rexpression for these, like &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt;. But the Perl extensions aren't specified this way, only like &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ,</source>
          <target state="translated">&lt;code&gt;Any&lt;/code&gt; や &lt;code&gt;Greek&lt;/code&gt; などのPerl拡張プロパティの戻り値は、誤解を招く可能性があります。値は &lt;code&gt;&quot;Y&quot;&lt;/code&gt; または &lt;code&gt;&quot;N&lt;/code&gt; 」のいずれかです。すべてのUnicodeプロパティは2つの部分からなるため、 &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; や &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt; ように、これらのPerl正規表現で実際に &lt;code&gt;&quot;Y&quot;&lt;/code&gt; または &lt;code&gt;&quot;N&lt;/code&gt; 」を使用できます。しかし、Perl拡張機能はこの方法では指定されず、 &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ようにのみ、</target>
        </trans-unit>
        <trans-unit id="0b00496e0ac48606a2b2f5ade4900470b3e5cc37" translate="yes" xml:space="preserve">
          <source>The returned values for the Perl extension properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;Greek&lt;/code&gt; are somewhat misleading. The values are either &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt;&quot;. All Unicode properties are bipartite, so you can actually use the &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt;&quot; in a Perl regular expression for these, like &lt;code&gt;qr/\p{ID_Start=Y/}&lt;/code&gt; or &lt;code&gt;qr/\p{Upper=N/}&lt;/code&gt;. But the Perl extensions aren't specified this way, only like &lt;code&gt;/qr/\p{Any}&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;Any&lt;/code&gt; や &lt;code&gt;Greek&lt;/code&gt; などのPerl拡張プロパティの戻り値は多少誤解を招く可能性があります。値は &lt;code&gt;&quot;Y&quot;&lt;/code&gt; または &lt;code&gt;&quot;N&lt;/code&gt; 」のいずれかです。すべてのUnicodeプロパティは2部構成であるため、 &lt;code&gt;qr/\p{ID_Start=Y/}&lt;/code&gt; や &lt;code&gt;qr/\p{Upper=N/}&lt;/code&gt; ように、Perl正規表現で実際に &lt;code&gt;&quot;Y&quot;&lt;/code&gt; または &lt;code&gt;&quot;N&lt;/code&gt; 」を使用できます。ただし、Perl拡張機能はこのように指定されておらず、 &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ようにのみ指定されています。</target>
        </trans-unit>
        <trans-unit id="f5eea968d1f523529d28fcd024fbb7e15c83c048" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; object.</source>
          <target state="translated">Perl オブジェクトの&lt;a href=&quot;version&quot;&gt;バージョン&lt;/a&gt;、バージョン、サブバージョン。バージョンオブジェクトとして表されます。</target>
        </trans-unit>
        <trans-unit id="85e9edc5bb272a0ee91c10e7c6d3172fdb763afd" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a decimal of the form 5.XXXYYY, where XXX is the version / 1e3 and YYY is the subversion / 1e6. For example, Perl v5.10.1 would be &quot;5.010001&quot;.</source>
          <target state="translated">Perl インタプリタのリビジョン、バージョン、サブバージョンは、5.XXXXXYYYという形式の10進数で表され、XXXはバージョン/1e3、YYYはサブバージョン/1e6を表します。例えば、Perl v5.10.1は「5.010001」となります。</target>
        </trans-unit>
        <trans-unit id="66e488be2f8483df95b9f037ffeda3de74384599" translate="yes" xml:space="preserve">
          <source>The rewritten version of this module (vs. v0.01) is slower on certain operations, like &lt;code&gt;new()&lt;/code&gt; , &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;numify()&lt;/code&gt; . The reason are that it does now more work and handles much more cases. The time spent in these operations is usually gained in the other math operations so that code on the average should get (much) faster. If they don't, please contact the author.</source>
          <target state="translated">このモジュール（対v0.01）の書き換えバージョンは次のように、特定の操作上の遅い &lt;code&gt;new()&lt;/code&gt; 、 &lt;code&gt;bstr()&lt;/code&gt; と &lt;code&gt;numify()&lt;/code&gt; 。その理由は、より多くの作業を行い、より多くのケースを処理するためです。これらの演算に費やされる時間は通常、他の数学演算で得られるため、平均してコードが（はるかに）速くなります。そうでない場合は、作者に連絡してください。</target>
        </trans-unit>
        <trans-unit id="d648a5385a086d97fdf940828d9fd6d003974ab0" translate="yes" xml:space="preserve">
          <source>The rewritten version of this module (vs. v0.01) is slower on certain operations, like &lt;code&gt;new()&lt;/code&gt;, &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;numify()&lt;/code&gt;. The reason are that it does now more work and handles much more cases. The time spent in these operations is usually gained in the other math operations so that code on the average should get (much) faster. If they don't, please contact the author.</source>
          <target state="translated">このモジュール（対v0.01）の書き換えバージョンは次のように、特定の操作上の遅い &lt;code&gt;new()&lt;/code&gt; 、 &lt;code&gt;bstr()&lt;/code&gt; と &lt;code&gt;numify()&lt;/code&gt; 。その理由は、より多くの作業を実行し、より多くのケースを処理するためです。これらの操作に費やされる時間は通常、他の数学操作で得られるため、平均してコードが（はるかに）速くなるはずです。そうでない場合は、作者に連絡してください。</target>
        </trans-unit>
        <trans-unit id="23622f986ab9be80262d33005c6066bc0cc050da" translate="yes" xml:space="preserve">
          <source>The right column will also caution you if a property means something different than what might normally be expected.</source>
          <target state="translated">右側の列は、プロパティが通常想定されているものとは異なる意味を持つ場合にも注意を促します。</target>
        </trans-unit>
        <trans-unit id="ae21a75ed2b2f6ef4dbb92843a55ab639a296c6c" translate="yes" xml:space="preserve">
          <source>The right hand side, starting at line 5 is similar to what we've just seen: we have the &lt;code&gt;add&lt;/code&gt; op (&lt;code&gt;pp_add&lt;/code&gt; also in</source>
          <target state="translated">右側には、5行目から始まることは私達がちょうど見てきたものと似ています。我々は &lt;code&gt;add&lt;/code&gt; オペアンプ（ &lt;code&gt;pp_add&lt;/code&gt; でもします</target>
        </trans-unit>
        <trans-unit id="a97b5a9d26a8152b03235a227c2f7630aad78c10" translate="yes" xml:space="preserve">
          <source>The right hand side, starting at line 5 is similar to what we've just seen: we have the &lt;code&gt;add&lt;/code&gt; op (&lt;code&gt;pp_add&lt;/code&gt;, also in</source>
          <target state="translated">右側には、5行目から始まることは私達がちょうど見てきたものと似ています。我々は &lt;code&gt;add&lt;/code&gt; オペアンプ（ &lt;code&gt;pp_add&lt;/code&gt; も中を、</target>
        </trans-unit>
        <trans-unit id="88e3fe5f1905fd5d0642f37b1a353b457c2b5b66" translate="yes" xml:space="preserve">
          <source>The right operand is not evaluated while the operator is in the &quot;false&quot; state, and the left operand is not evaluated while the operator is in the &quot;true&quot; state. The precedence is a little lower than || and &amp;amp;&amp;amp;. The value returned is either the empty string for false, or a sequence number (beginning with 1) for true. The sequence number is reset for each range encountered. The final sequence number in a range has the string &lt;code&gt;&quot;E0&quot;&lt;/code&gt; appended to it, which doesn't affect its numeric value, but gives you something to search for if you want to exclude the endpoint. You can exclude the beginning point by waiting for the sequence number to be greater than 1.</source>
          <target state="translated">演算子が「偽」の状態にある間、右側のオペランドは評価されません。演算子が「真」の状態にある間、左側のオペランドは評価されません。優先順位は||より少し低くなっています および&amp;amp;&amp;amp;。返される値は、falseの場合は空の文字列、trueの場合はシーケンス番号（1から始まる）のいずれかです。シーケンス番号は、検出された範囲ごとにリセットされます。範囲の最後のシーケンス番号には、文字列 &lt;code&gt;&quot;E0&quot;&lt;/code&gt; 追加されます。これは、その数値には影響しませんが、エンドポイントを除外する場合に検索するものを提供します。シーケンス番号が1より大きくなるのを待つことで、開始点を除外できます。</target>
        </trans-unit>
        <trans-unit id="712b7dd783ec62d03111b67512c4c71fb70fa066" translate="yes" xml:space="preserve">
          <source>The rightmost delimiter beginning the argument text to the interior sequence (should be &quot;&amp;gt;&quot;).</source>
          <target state="translated">引数のテキストを開始して内部シーケンスへの右端の区切り文字（ &quot;&amp;gt;&quot;にする必要があります）。</target>
        </trans-unit>
        <trans-unit id="f1b13ab5c99b5028d035c2e34026b78f830a5ce1" translate="yes" xml:space="preserve">
          <source>The rmtree() function provide the legacy interface of remove_tree() with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to remove_tree().</source>
          <target state="translated">rmtree()関数は、渡された引数の解釈を変えてremove_tree()のレガシーインターフェースを提供する。この関数の動作と戻り値は、それ以外はremove_tree()と同じです。</target>
        </trans-unit>
        <trans-unit id="97d9690fe48f5ed9ac8be9b70513653d3ab42339" translate="yes" xml:space="preserve">
          <source>The rot13 example was a trivial example. Here's another demonstration that shows off a few more features.</source>
          <target state="translated">rot13の例は些細な例でした。ここでは、さらにいくつかの機能を示す別のデモを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="4a28f646da84403da9a05e371721d016d1168285" translate="yes" xml:space="preserve">
          <source>The rough perl equivalent is &lt;code&gt;$myarray[$idx]&lt;/code&gt; .</source>
          <target state="translated">おおまかなperlの同等物は &lt;code&gt;$myarray[$idx]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="4b4a8606a49a46444c3a9ed277908732090e4141" translate="yes" xml:space="preserve">
          <source>The rough perl equivalent is &lt;code&gt;$myarray[$key]&lt;/code&gt;.</source>
          <target state="translated">大まかなperlの同等物は &lt;code&gt;$myarray[$key]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="07cb0ce6d373861ed9384fe1d2dba7e82ae7d7eb" translate="yes" xml:space="preserve">
          <source>The routine &lt;code&gt;regtail()&lt;/code&gt; is called by both &lt;code&gt;reg()&lt;/code&gt; and &lt;code&gt;regbranch()&lt;/code&gt; in order to &quot;set the tail pointer&quot; correctly. When executing and we get to the end of a branch, we need to go to the node following the grouping parens. When parsing, however, we don't know where the end will be until we get there, so when we do we must go back and update the offsets as appropriate. &lt;code&gt;regtail&lt;/code&gt; is used to make this easier.</source>
          <target state="translated">ルーチン &lt;code&gt;regtail()&lt;/code&gt; は、「テールポインタを正しく設定する」ために、 &lt;code&gt;reg()&lt;/code&gt; と &lt;code&gt;regbranch()&lt;/code&gt; の両方によって呼び出されます。実行してブランチの終わりに到達したら、グループ化括弧の次のノードに移動する必要があります。ただし、解析するときは、そこに到達するまではどこにあるのかわからないので、そうする場合は、戻ってオフセットを適切に更新する必要があります。 &lt;code&gt;regtail&lt;/code&gt; は、これを簡単にするために使用されます。</target>
        </trans-unit>
        <trans-unit id="96fb8a6192d6d2137dae358308fab281f2803684" translate="yes" xml:space="preserve">
          <source>The routine indicated by &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is called when a fatal exception is about to be thrown. The error message is passed as the first argument. When a &lt;code&gt;__DIE__&lt;/code&gt; hook routine returns, the exception processing continues as it would have in the absence of the hook, unless the hook routine itself exits via a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; , a loop exit, or a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;__DIE__&lt;/code&gt; handler is explicitly disabled during the call, so that you can die from a &lt;code&gt;__DIE__&lt;/code&gt; handler. Similarly for &lt;code&gt;__WARN__&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 示されるルーチンは、致命的な例外がスローされようとしているときに呼び出されます。エラーメッセージは最初の引数として渡されます。場合 &lt;code&gt;__DIE__&lt;/code&gt; のフックはリターンフックルーチン自体を介して終了しない限り、それは、フックの非存在下でなければならないように、例外処理が継続 &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; 、ループ終了、または &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;__DIE__&lt;/code&gt; のハンドラは、明示的に死ぬことができるように、通話中に無効になっている &lt;code&gt;__DIE__&lt;/code&gt; のハンドラ。同様に &lt;code&gt;__WARN__&lt;/code&gt; の場合。</target>
        </trans-unit>
        <trans-unit id="a3747082bcec8b320b157ca0f6db8a2c2a773d76" translate="yes" xml:space="preserve">
          <source>The routine indicated by &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is called when a fatal exception is about to be thrown. The error message is passed as the first argument. When a &lt;code&gt;__DIE__&lt;/code&gt; hook routine returns, the exception processing continues as it would have in the absence of the hook, unless the hook routine itself exits via a &lt;code&gt;goto &amp;amp;sub&lt;/code&gt;, a loop exit, or a &lt;code&gt;die()&lt;/code&gt;. The &lt;code&gt;__DIE__&lt;/code&gt; handler is explicitly disabled during the call, so that you can die from a &lt;code&gt;__DIE__&lt;/code&gt; handler. Similarly for &lt;code&gt;__WARN__&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$SIG{__DIE__}&lt;/code&gt; 示されるルーチンは、致命的な例外がスローされようとしているときに呼び出されます。エラーメッセージは最初の引数として渡されます。場合 &lt;code&gt;__DIE__&lt;/code&gt; のフックはリターンフックルーチン自体を介して終了しない限り、それは、フックの非存在下でなければならないように、例外処理が継続 &lt;code&gt;goto &amp;amp;sub&lt;/code&gt; 、ループ終了、または &lt;code&gt;die()&lt;/code&gt; 。 &lt;code&gt;__DIE__&lt;/code&gt; のハンドラは、明示的に死ぬことができるように、通話中に無効になっている &lt;code&gt;__DIE__&lt;/code&gt; のハンドラ。 &lt;code&gt;__WARN__&lt;/code&gt; についても同様です。</target>
        </trans-unit>
        <trans-unit id="c23e498d9e0f7b9916602bb81bb457e05dc15d28" translate="yes" xml:space="preserve">
          <source>The routine most often used is &lt;code&gt;call_sv&lt;/code&gt; . The &lt;code&gt;SV*&lt;/code&gt; argument contains either the name of the Perl subroutine to be called, or a reference to the subroutine. The second argument consists of flags that control the context in which the subroutine is called, whether or not the subroutine is being passed arguments, how errors should be trapped, and how to treat return values.</source>
          <target state="translated">最もよく使用されるルーチンは &lt;code&gt;call_sv&lt;/code&gt; です。 &lt;code&gt;SV*&lt;/code&gt; 引数は呼び出されるPerlサブルーチンの名前、またはサブルーチンへのリファレンスが含まれています。2番目の引数は、サブルーチンが呼び出されるコンテキスト、サブルーチンに引数が渡されているかどうか、エラーをトラップする方法、および戻り値の処理方法を制御するフラグで構成されています。</target>
        </trans-unit>
        <trans-unit id="8b9d3fc2ab950a51903275842538b6aa8532b735" translate="yes" xml:space="preserve">
          <source>The routine most often used is &lt;code&gt;call_sv&lt;/code&gt;. The &lt;code&gt;SV*&lt;/code&gt; argument contains either the name of the Perl subroutine to be called, or a reference to the subroutine. The second argument consists of flags that control the context in which the subroutine is called, whether or not the subroutine is being passed arguments, how errors should be trapped, and how to treat return values.</source>
          <target state="translated">最も頻繁に使用されるルーチンは &lt;code&gt;call_sv&lt;/code&gt; です。 &lt;code&gt;SV*&lt;/code&gt; 引数は呼び出されるPerlサブルーチンの名前、またはサブルーチンへのリファレンスが含まれています。2番目の引数は、サブルーチンが呼び出されるコンテキスト、サブルーチンに引数が渡されるかどうか、エラーをトラップする方法、および戻り値を処理する方法を制御するフラグで構成されます。</target>
        </trans-unit>
        <trans-unit id="02aa17c916dde6540e50fc69118a82269239b3fa" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;b&gt;false&lt;/b&gt; otherwise.</source>
          <target state="translated">それ以外の場合、ルーチンは&lt;b&gt;falseを&lt;/b&gt;返し&lt;b&gt;ます&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2a6f415596eaaeb6ae6674de29690a406129631d" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for I/O problems or other internal error, a true value otherwise. Serious errors are propagated as a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; exception.</source>
          <target state="translated">ルーチンは、I / Oの問題やその他の内部エラーの場合は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; を返し、それ以外の場合は真の値を返します。重大なエラーは次のように伝播され &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; の例外。</target>
        </trans-unit>
        <trans-unit id="274062f280eff9b69a72565df5a686a0a630e507" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;code&gt;undef&lt;/code&gt; for I/O problems or other internal error, a true value otherwise. Serious errors are propagated as a &lt;code&gt;die&lt;/code&gt; exception.</source>
          <target state="translated">ルーチンは、I / O問題またはその他の内部エラーの場合は &lt;code&gt;undef&lt;/code&gt; を返し、それ以外の場合はtrue値を返します。重大なエラーは、 &lt;code&gt;die&lt;/code&gt; 例外として伝播されます。</target>
        </trans-unit>
        <trans-unit id="30cd5a5724b0cdff1db0ded8bf4cad313b5d3163" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;reftype&lt;/code&gt; are exportable.</source>
          <target state="translated">ルーチン &lt;code&gt;get&lt;/code&gt; および &lt;code&gt;reftype&lt;/code&gt; はエクスポート可能です。</target>
        </trans-unit>
        <trans-unit id="7978092db3768ef7e6d213d57a05b4b46c4c1d11" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; exported by default. You must specify which ones you want to use.</source>
          <target state="translated">&lt;code&gt;make_path&lt;/code&gt; および &lt;code&gt;remove_tree&lt;/code&gt; ルーチンは、デフォルトで&lt;b&gt;は&lt;/b&gt;エクスポートされ&lt;b&gt;ません&lt;/b&gt;。使用するものを指定する必要があります。</target>
        </trans-unit>
        <trans-unit id="5f252df425e68241a153a06fc0e9c8513b5f1aa7" translate="yes" xml:space="preserve">
          <source>The routines are called in string comparison order of KEY.</source>
          <target state="translated">ルーチンはKEYの文字列比較の順番で呼び出されます。</target>
        </trans-unit>
        <trans-unit id="74358fa70816b0be14690b88380765bc85d1b11f" translate="yes" xml:space="preserve">
          <source>The routines provided are:</source>
          <target state="translated">提供されるルーチンは</target>
        </trans-unit>
        <trans-unit id="258695837b0d342f488ae3724d49cf11d73778d9" translate="yes" xml:space="preserve">
          <source>The rule by which Digest::SHA handles a Unicode string is easy to state, but potentially confusing to grasp: the string is interpreted as a sequence of byte values, where each byte value is equal to the ordinal value (viz. code point) of its corresponding Unicode character. That way, the Unicode string 'abc' has exactly the same digest value as the ordinary string 'abc'.</source>
          <target state="translated">ダイジェスト::SHAがUnicode文字列を処理するルールは、述べるのは簡単ですが、把握するのは混乱を招く可能性があります。文字列はバイト値のシーケンスとして解釈され、各バイト値は対応するUnicode文字の序数値(コードポイント)と等しくなります。このようにして、Unicode 文字列 'abc' は、通常の文字列 'abc' と全く同じダイジェスト値を持っています。</target>
        </trans-unit>
        <trans-unit id="6b4e5af62f9d03a0b5c8d39854ce10f47d56d0b1" translate="yes" xml:space="preserve">
          <source>The rule must only have one top level key: either 'par' for &quot;parallel&quot; or 'seq' for &quot;sequence&quot;.</source>
          <target state="translated">ルールには、トップレベルのキーを1つだけ持っていなければなりません。</target>
        </trans-unit>
        <trans-unit id="2858e68dbb1d52d413ae8f5dae1d589d672ac788" translate="yes" xml:space="preserve">
          <source>The rule of thumb for portable code is: Do it all in portable Perl, or use a module (that may internally implement it with platform-specific code, but exposes a common interface).</source>
          <target state="translated">移植可能なコードの経験則は以下の通りです。移植可能な Perl ですべてを行うか、モジュール (内部的にはプラットフォーム固有のコードで実装されているかもしれませんが、共通のインターフェイスを公開しています)を使用してください。</target>
        </trans-unit>
        <trans-unit id="242ca7a8186e9298403d04b4bfd265a295183ebf" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;UTF-8&lt;/code&gt; unless you know what you're doing and unless you really benefit from using &lt;code&gt;UTF-16&lt;/code&gt;.</source>
          <target state="translated">経験則では、自分が何をしているのかを理解していない限り、また &lt;code&gt;UTF-16&lt;/code&gt; を使用することで本当にメリットが得られない限り、 &lt;code&gt;UTF-8&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="d771186d9f060b8e39d56f4b8de80fe1694de984" translate="yes" xml:space="preserve">
          <source>The rules data structure is documented more in the next section.</source>
          <target state="translated">ルールのデータ構造については、次のセクションで詳しく説明します。</target>
        </trans-unit>
        <trans-unit id="b2b47541d9fe53d041ea0cd594a357e270362960" translate="yes" xml:space="preserve">
          <source>The rules determining what it is are quite simple: if the character following the backslash is an ASCII punctuation (non-word) character (that is, anything that is not a letter, digit, or underscore), then the backslash just takes away any special meaning of the character following it.</source>
          <target state="translated">バックスラッシュの後に続く文字がASCIIの句読点(非単語)文字(つまり、文字、数字、アンダースコアではないもの)である場合、バックスラッシュはそれに続く文字の特別な意味を奪うだけです。</target>
        </trans-unit>
        <trans-unit id="f747d6278f9a09b6ca106424547e7e55bc600835" translate="yes" xml:space="preserve">
          <source>The rules of conduct that, in the absence of other guidance, determine what should happen first. For example, in the absence of parentheses, you always do multiplication before addition.</source>
          <target state="translated">他の指針がない場合に、最初に何をすべきかを決める行動規則。例えば、カッコがない場合は、必ず足し算の前に掛け算をします。</target>
        </trans-unit>
        <trans-unit id="ba784b5f42a3cdb9214cd0e95e0cb55e8afe477c" translate="yes" xml:space="preserve">
          <source>The rules used by &lt;a href=&quot;re#%27strict%27-mode&quot;&gt;&lt;code&gt;use re 'strict&lt;/code&gt;&lt;/a&gt; apply to this construct.</source>
          <target state="translated">&lt;a href=&quot;re#%27strict%27-mode&quot;&gt; &lt;code&gt;use re 'strict&lt;/code&gt; &lt;/a&gt; re'strictで使用されるルールは、この構成に適用されます。</target>
        </trans-unit>
        <trans-unit id="903df1a17859e1fa3a6b96e5e64488aec405db63" translate="yes" xml:space="preserve">
          <source>The rules used for matching decimal digits are slightly stricter. Many scripts have their own sets of digits equivalent to the Western &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;9&lt;/code&gt; ones. A few, such as Arabic, have more than one set. For a string to be considered a script run, all digits in it must come from the same set of ten, as determined by the first digit encountered. As an example,</source>
          <target state="translated">10進数の照合に使用される規則は、少し厳密です。多くのスクリプトには、西部の &lt;code&gt;0&lt;/code&gt; から &lt;code&gt;9&lt;/code&gt; までの数字に相当する独自の数字のセットがあります。アラビア語など、いくつかのセットには複数のセットがあります。文字列がスクリプト実行と見なされるには、最初に検出された数字によって決定されるように、文字列内のすべての数字が同じ10のセットからのものである必要があります。例として、</target>
        </trans-unit>
        <trans-unit id="4ac2685482eb75c8db66c436a646aa6e3d97f9ed" translate="yes" xml:space="preserve">
          <source>The runtime component should have the name</source>
          <target state="translated">ランタイムコンポーネントの名前は</target>
        </trans-unit>
        <trans-unit id="9ac33bbce70d7ec48c4fcab9365b96ff1ebc5597" translate="yes" xml:space="preserve">
          <source>The runtime phase refers not only to when the distribution's contents are installed, but also to its continued use. Any library that is a prerequisite for regular use of this distribution should be indicated here.</source>
          <target state="translated">ランタイムフェーズとは、ディストリビューションの内容がインストールされたときだけでなく、継続して使用することを指します。このディストリビューションを定期的に使用するための前提条件となるライブラリはすべてここに示されるべきです。</target>
        </trans-unit>
        <trans-unit id="763ace778385d85ae756e3844782d5cfee6e0e05" translate="yes" xml:space="preserve">
          <source>The same approach as a command line:</source>
          <target state="translated">コマンドラインと同じアプローチです。</target>
        </trans-unit>
        <trans-unit id="9976b6a81a6abb21b7cab5b632b4ad690c05665b" translate="yes" xml:space="preserve">
          <source>The same as for &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, but if a missing operator cannot be autogenerated then, instead of issuing an error message, Perl is allowed to revert to what it would have done for that operator if there had been no &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; の場合と同じですが、欠落している演算子を自動生成できない場合、エラーメッセージを発行する代わりに、Perlは、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; ディレクティブがなかった場合に、その演算子に対して行っていた動作に戻すことができます。</target>
        </trans-unit>
        <trans-unit id="aff3ca408715d6ed9bbfe43d93b70be580afe993" translate="yes" xml:space="preserve">
          <source>The same as for &lt;code&gt;undef&lt;/code&gt;, but if a missing operator cannot be autogenerated then, instead of issuing an error message, Perl is allowed to revert to what it would have done for that operator if there had been no &lt;code&gt;use overload&lt;/code&gt; directive.</source>
          <target state="translated">以下の場合と同じ &lt;code&gt;undef&lt;/code&gt; を、しかし欠けているオペレータは、その後、自動生成の代わりに、エラーメッセージを発行することができない場合は、Perlのは、まったく存在しなかった場合、それはその演算子のために行われていたものに戻るように許可されている &lt;code&gt;use overload&lt;/code&gt; ディレクティブ。</target>
        </trans-unit>
        <trans-unit id="4c7d5583bb4c7bf75d630d65c93bc37b198d69e0" translate="yes" xml:space="preserve">
          <source>The same caveats as the previous form apply: The non-graphic characters are no longer allowed with &quot;use utf8&quot;, it is unwise to use this form at all, and utf8ness makes a big difference.</source>
          <target state="translated">前のフォームと同じ注意点が適用されます。use utf8 &quot;では、非図形文字はもはや許されない、この形式を使うのは賢明ではない、そしてutf8であることが大きな違いとなる。</target>
        </trans-unit>
        <trans-unit id="286499ca118e6aee1159ad012e0d0c293bc05679" translate="yes" xml:space="preserve">
          <source>The same checksum can also be calculated in OO style:</source>
          <target state="translated">同じチェックサムをOOスタイルで計算することもできます。</target>
        </trans-unit>
        <trans-unit id="e7121397996c97368f3bf5006e5d7cf5183183f6" translate="yes" xml:space="preserve">
          <source>The same effect as the example above in a different way. The coderef takes the alias name as an argument and returns a canonical name on success or undef if not. Note the second argument is ignored if provided. Use this with even more caution than the regex version.</source>
          <target state="translated">上の例と同じ効果を別の方法で実現しています。coderef はエイリアス名を引数に取り、成功した場合は正規の名前を返し、そうでない場合は undef を返します。第二引数が与えられた場合は無視されることに注意してください。これは正規表現版よりもさらに注意して使用してください。</target>
        </trans-unit>
        <trans-unit id="e43451146d37e633afabe95e907553562bae7cb9" translate="yes" xml:space="preserve">
          <source>The same holds for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">サブルーチンを含む、または現在実行中の評価された文字列についても同様です。 &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; 文字列の$ filenameは &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; のようになります。</target>
        </trans-unit>
        <trans-unit id="6bfd670d25b13b1b3ec948c8f09f21523b3aecf7" translate="yes" xml:space="preserve">
          <source>The same holds for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;eval&lt;/code&gt;ed strings looks like &lt;code&gt;(eval 34)&lt;/code&gt;.</source>
          <target state="translated">サブルーチンを含む、または現在実行中の評価済み文字列についても同じことが言えます。 &lt;code&gt;eval&lt;/code&gt; 文字列の$ filenameは &lt;code&gt;(eval 34)&lt;/code&gt; のようになります。</target>
        </trans-unit>
        <trans-unit id="a048bf53e27173e747513cb4000a6c6bd711ca9e" translate="yes" xml:space="preserve">
          <source>The same information is displayed at the end of the output from the command</source>
          <target state="translated">コマンドの出力の最後に同じ情報が表示されます。</target>
        </trans-unit>
        <trans-unit id="fe72bff5d187e52fa5d199f09887af6af2e32815" translate="yes" xml:space="preserve">
          <source>The same is not true of implementations of &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; : these are expected to modify their operand. An appropriate implementation of &lt;code&gt;--&lt;/code&gt; might look like</source>
          <target state="translated">同じことは &lt;code&gt;++&lt;/code&gt; と &lt;code&gt;--&lt;/code&gt; 実装には当てはまりません。これらはオペランドを変更することが期待されています。適切な実装 &lt;code&gt;--&lt;/code&gt; のようになります。</target>
        </trans-unit>
        <trans-unit id="07cb6e84563964c1b3fb8a6ff37a2b4286b6b128" translate="yes" xml:space="preserve">
          <source>The same is not true of implementations of &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;: these are expected to modify their operand. An appropriate implementation of &lt;code&gt;--&lt;/code&gt; might look like</source>
          <target state="translated">同じことは &lt;code&gt;++&lt;/code&gt; と &lt;code&gt;--&lt;/code&gt; 実装には当てはまりません：これらはオペランドを変更することが期待されています。 &lt;code&gt;--&lt;/code&gt; の適切な実装は次のようになります</target>
        </trans-unit>
        <trans-unit id="b9889316caadba38254c295ba1f667d08e692e37" translate="yes" xml:space="preserve">
          <source>The same might happen to AIX 5.1 or other OS levels. As a side note, Perl cannot be built without bos.adt.syscalls and bos.adt.libm installed</source>
          <target state="translated">AIX 5.1や他のOSレベルでも同じことが起こるかもしれません。余談ですが、bos.adt.syscalls と bos.adt.libm がインストールされていないと Perl はビルドできません。</target>
        </trans-unit>
        <trans-unit id="2d3beec233d4767fecd283497936fe00947a8d1a" translate="yes" xml:space="preserve">
          <source>The same package name can be used more than once, allowing for non-contiguous code. This is useful if you have a stronger ordering principle than package names.</source>
          <target state="translated">同じパッケージ名を複数回使用することができ、連続しないコードも可能になります。これは、パッケージ名よりも強い順序原則を持っている場合に便利です。</target>
        </trans-unit>
        <trans-unit id="adf0ce12f9a7b11a4e4d148adc2353bc6022f25b" translate="yes" xml:space="preserve">
          <source>The same problems ensue if you enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; on non-ISO8859-1, non-UTF-8 locales (by using either the &lt;b&gt;-C&lt;/b&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable; see &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;). Things are read in as UTF-8, which would normally imply a Unicode interpretation, but the presence of a locale causes them to be interpreted in that locale instead. For example, a 0xD7 code point in the Unicode input, which should mean the multiplication sign, won't be interpreted by Perl that way under the Greek locale. This is not a problem</source>
          <target state="translated">標準ファイルハンドル、デフォルトの &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; レイヤー、および非ISO8859-1以外の &lt;code&gt;@ARGV&lt;/code&gt; の自動UTF-8化を有効にすると（&lt;b&gt;-C&lt;/b&gt;コマンドラインを使用して）、同じ問題が発生します。スイッチまたは &lt;code&gt;PERL_UNICODE&lt;/code&gt; の環境変数;参照&lt;a href=&quot;perlrun&quot;&gt;perlrunを&lt;/a&gt;）。物はUTF-8として読み込まれますが、これは通常Unicode解釈を意味しますが、ロケールが存在すると、代わりにそのロケールで解釈されます。たとえば、Unicode入力の0xD7コードポイントは、乗算記号を意味するはずですが、ギリシャ語ロケールではPerlによってそのように解釈されません。これは問題ありません</target>
        </trans-unit>
        <trans-unit id="44e618a0d24868bdeb405a4592271ed0ce58faad" translate="yes" xml:space="preserve">
          <source>The same problems ensue if you enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;open()&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; on non-ISO8859-1, non-UTF-8 locales (by using either the &lt;b&gt;-C&lt;/b&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable; see &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;perlrun&lt;/a&gt;). Things are read in as UTF-8, which would normally imply a Unicode interpretation, but the presence of a locale causes them to be interpreted in that locale instead. For example, a 0xD7 code point in the Unicode input, which should mean the multiplication sign, won't be interpreted by Perl that way under the Greek locale. This is not a problem</source>
          <target state="translated">ISO8859-1以外、UTF-8以外のロケールで（&lt;b&gt;-C&lt;/b&gt;コマンドラインを使用して &lt;code&gt;open()&lt;/code&gt; 標準ファイルハンドル、デフォルトのopen（）レイヤー、および &lt;code&gt;@ARGV&lt;/code&gt; の自動UTF-8化を有効にすると、同じ問題が発生します。スイッチまたは &lt;code&gt;PERL_UNICODE&lt;/code&gt; 環境変数。perlrunを参照して&lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;ください&lt;/a&gt;）。物事はUTF-8として読み込まれます。これは通常、Unicodeの解釈を意味しますが、ロケールが存在すると、代わりにそのロケールで解釈されます。たとえば、Unicode入力の0xD7コードポイントは、乗算記号を意味するはずですが、ギリシャ語ロケールでは、Perlによってそのように解釈されません。これは問題ではありません&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8104fdf41371cefa43c656a17bffde6b62386dd0" translate="yes" xml:space="preserve">
          <source>The same problems occur if you pass them Math::BigInt-&amp;gt;binf() objects. Since overloading these routines is not possible, this cannot be fixed from BigInt.</source>
          <target state="translated">Math :: BigInt-&amp;gt; binf（）オブジェクトを渡すと、同じ問題が発生します。これらのルーチンのオーバーロードは不可能であるため、BigIntからこれを修正することはできません。</target>
        </trans-unit>
        <trans-unit id="7dc30b04b9083d2f8edd85ddb5597b7e64cf1167" translate="yes" xml:space="preserve">
          <source>The same problems occur if you pass them Math::BigInt-&amp;gt;binf() objects. Since overloading these routines is not possible, this cannot be fixed from Math::BigInt.</source>
          <target state="translated">それらにMath :: BigInt-&amp;gt; binf（）オブジェクトを渡すと、同じ問題が発生します。これらのルーチンをオーバーロードすることはできないため、Math :: BigIntから修正することはできません。</target>
        </trans-unit>
        <trans-unit id="fd308e84d4bbc13d1645c341d0f0d15e57ef77b4" translate="yes" xml:space="preserve">
          <source>The same template may generally also be used in &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">通常、同じテンプレートを&lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt; &lt;code&gt;unpack&lt;/code&gt; &lt;/a&gt;に使用することもできます。</target>
        </trans-unit>
        <trans-unit id="70e999fed9c0e326d353539553d4a7555374fd82" translate="yes" xml:space="preserve">
          <source>The same template may generally also be used in unpack().</source>
          <target state="translated">一般的には、同じテンプレートを unpack()で使用することもできます。</target>
        </trans-unit>
        <trans-unit id="6b6c7f4b6ab698dbba6b63d74e5bcb57fa5d9973" translate="yes" xml:space="preserve">
          <source>The same tests are run both times, but more information is provided when running as &lt;code&gt;./perl harness&lt;/code&gt;.</source>
          <target state="translated">同じテストが両方の時間に実行されますが、. &lt;code&gt;./perl harness&lt;/code&gt; として実行すると、より多くの情報が提供されます。</target>
        </trans-unit>
        <trans-unit id="1f4add58be52aaba625e5f7ff33a20f204714d58" translate="yes" xml:space="preserve">
          <source>The sample program:</source>
          <target state="translated">サンプルプログラムです。</target>
        </trans-unit>
        <trans-unit id="81ca6bed72a326bbf775e3304829aa324851950b" translate="yes" xml:space="preserve">
          <source>The save stack is used by perl to implement the &lt;code&gt;local&lt;/code&gt; keyword and other similar behaviours; any cleanup operations that need to be performed when leaving the current scope. Items pushed to this stack generally capture the current value of some internal variable or state, which will be restored when the scope is unwound due to leaving, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;die&lt;/code&gt;, &lt;code&gt;goto&lt;/code&gt; or other reasons.</source>
          <target state="translated">保存スタックは、 &lt;code&gt;local&lt;/code&gt; キーワードおよび他の同様の動作を実装するためにperlによって使用されます。現在のスコープを離れるときに実行する必要のあるクリーンアップ操作。このスタックにプッシュされたアイテムは、通常、内部変数または状態の現在の値をキャプチャします。これは、離れる、 &lt;code&gt;return&lt;/code&gt; 、 &lt;code&gt;die&lt;/code&gt; 、 &lt;code&gt;goto&lt;/code&gt; 、またはその他の理由でスコープが巻き戻されたときに復元されます。</target>
        </trans-unit>
        <trans-unit id="f745bb5cbca08197cbed6d6403139abf437a8fa9" translate="yes" xml:space="preserve">
          <source>The scalar &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value is stored in an SV instance called &lt;code&gt;PL_sv_undef&lt;/code&gt; .</source>
          <target state="translated">スカラー &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 値は、 &lt;code&gt;PL_sv_undef&lt;/code&gt; と呼ばれるSVインスタンスに格納されます。</target>
        </trans-unit>
        <trans-unit id="7d200dc97f6deaa66b9415179bc13a97fa0cc3da" translate="yes" xml:space="preserve">
          <source>The scalar &lt;code&gt;undef&lt;/code&gt; value is stored in an SV instance called &lt;code&gt;PL_sv_undef&lt;/code&gt;.</source>
          <target state="translated">スカラー &lt;code&gt;undef&lt;/code&gt; 値は、 &lt;code&gt;PL_sv_undef&lt;/code&gt; と呼ばれるSVインスタンスに格納されます。</target>
        </trans-unit>
        <trans-unit id="6e858b562140c68ce32ea23e2b6e666b2e82798f" translate="yes" xml:space="preserve">
          <source>The scalar/list context for the subroutine and for the right-hand side of assignment is determined as if the subroutine call is replaced by a scalar. For example, consider:</source>
          <target state="translated">サブルーチンの呼び出しと代入の右辺のスカラ/リストコンテキストは、サブルーチンの呼び出しがスカラに置き換えられたかのように決定されます。例えば、次のように考えてみてください。</target>
        </trans-unit>
        <trans-unit id="6c0b56c4841154473a184d3770a4651387051abe" translate="yes" xml:space="preserve">
          <source>The scalars for in-memory files are treated as octet strings: unless the file is being opened with truncation the scalar may not contain any code points over 0xFF.</source>
          <target state="translated">メモリ内ファイルのスカラはオクテット文字列として扱われます。 ファイルが切り捨てで開かれていない限り、スカラは0xFFを超えるコードポイントを含んではいけません。</target>
        </trans-unit>
        <trans-unit id="8a59c0bcb531b15ec7601a5c46eda41a994dbd08" translate="yes" xml:space="preserve">
          <source>The scheme above allows interpretation of a wide range of dates, particularly if 4-digit years are used.</source>
          <target state="translated">上記のスキームでは、特に4桁の年号を使用している場合には、幅広い日付の解釈が可能です。</target>
        </trans-unit>
        <trans-unit id="3fc0ce48ddfa00a9f249dd98501d09516efb57c0" translate="yes" xml:space="preserve">
          <source>The scheme from the uri (like 'file', 'http', etc)</source>
          <target state="translated">uriからのスキーム('file'、'http'など</target>
        </trans-unit>
        <trans-unit id="73f8b37079fc67e2d535d7e2f263c71e4f89003f" translate="yes" xml:space="preserve">
          <source>The scope of the &lt;code&gt;package&lt;/code&gt; declaration is from the declaration itself through the end of the enclosing block, &lt;code&gt;eval&lt;/code&gt;, or file, whichever comes first (the same scope as the my(), our(), state(), and local() operators, and also the effect of the experimental &quot;reference aliasing,&quot; which may change), or until the next &lt;code&gt;package&lt;/code&gt; declaration. Unqualified dynamic identifiers will be in this namespace, except for those few identifiers that, if unqualified, default to the main package instead of the current one as described below. A &lt;code&gt;package&lt;/code&gt; statement affects only dynamic global symbols, including subroutine names, and variables you've used local() on, but</source>
          <target state="translated">&lt;code&gt;package&lt;/code&gt; 宣言のスコープは、宣言自体から、それを囲むブロック、 &lt;code&gt;eval&lt;/code&gt; 、またはファイルのいずれか早い方までです（my（）、our（）、state（）、およびlocal（）演算子と同じスコープ）。 、および実験的な「参照エイリアシング」の影響（変更される可能性があります）、または次の &lt;code&gt;package&lt;/code&gt; 宣言まで。修飾されていない動的識別子は、この名前空間に含まれます。ただし、修飾されていない場合、以下で説明するように、現在のパッケージではなくメインパッケージがデフォルトになります。 &lt;code&gt;package&lt;/code&gt; 文は）（ローカル使用してきたサブルーチン名、変数など、動的グローバルシンボルを、影響を与えるのが、</target>
        </trans-unit>
        <trans-unit id="49277474cf2c3fa04e4e431396fc13bca0311697" translate="yes" xml:space="preserve">
          <source>The scope where &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; is used has escalated the &lt;code&gt;void&lt;/code&gt; warnings category into a fatal error, so the program terminates immediately when it encounters the warning.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; が使用されているスコープにより、 &lt;code&gt;void&lt;/code&gt; 警告カテゴリが致命的なエラーにエスカレートされたため、プログラムは警告に遭遇するとすぐに終了します。</target>
        </trans-unit>
        <trans-unit id="3dbfebc1570cc3ef48ec03f51a2706061f280881" translate="yes" xml:space="preserve">
          <source>The scope where &lt;code&gt;length&lt;/code&gt; is used has escalated the &lt;code&gt;void&lt;/code&gt; warnings category into a fatal error, so the program terminates immediately when it encounters the warning.</source>
          <target state="translated">&lt;code&gt;length&lt;/code&gt; が使用されるスコープにより、 &lt;code&gt;void&lt;/code&gt; 警告カテゴリが致命的なエラーにエスカレートされたため、プログラムは警告が発生するとすぐに終了します。</target>
        </trans-unit>
        <trans-unit id="62f56ab0ebe6cfd894b851115a602d7f9f59ed1f" translate="yes" xml:space="preserve">
          <source>The script exits with zero if it thinks that everything worked, or a positive number if it thinks that something failed. Note, however, that in some cases it has to divine a failure by the output of things it does not control. For now, the exit codes are vague:</source>
          <target state="translated">スクリプトは、すべてがうまくいったと判断した場合はゼロで終了し、何かが失敗したと判断した場合は正の数で終了します。しかし、場合によっては、制御できないものの出力から失敗を判断しなければならないことに注意してください。今のところ、終了コードは曖昧です。</target>
        </trans-unit>
        <trans-unit id="05dbbff48c1e514e522b4520f47f1f9d051aaac1" translate="yes" xml:space="preserve">
          <source>The script first verifies the function of the &lt;code&gt;Name&lt;/code&gt; class.</source>
          <target state="translated">スクリプトは最初に &lt;code&gt;Name&lt;/code&gt; クラスの機能を確認します。</target>
        </trans-unit>
        <trans-unit id="bab70c074a8060d72a4a917d75cb758f3fdbebe9" translate="yes" xml:space="preserve">
          <source>The script is available from &lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;https://gist.github.com/eqhmcow/5389877&lt;/a&gt;</source>
          <target state="translated">スクリプトは&lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;https://gist.github.com/eqhmcow/5389877&lt;/a&gt;から入手できます。</target>
        </trans-unit>
        <trans-unit id="63775c5f58b6e8ca06f6c938a637be34887e3ffd" translate="yes" xml:space="preserve">
          <source>The script of a character is determined by the &lt;code&gt;Script_Extensions&lt;/code&gt; property as modified by UTS 39 (&lt;a href=&quot;https://unicode.org/reports/tr39/&quot;&gt;https://unicode.org/reports/tr39/&lt;/a&gt;), as described above.</source>
          <target state="translated">文字のスクリプトは、上記のように、UTS 39（&lt;a href=&quot;https://unicode.org/reports/tr39/&quot;&gt;https://unicode.org/reports/tr39/&lt;/a&gt;）によって変更された &lt;code&gt;Script_Extensions&lt;/code&gt; プロパティによって決定されます。</target>
        </trans-unit>
        <trans-unit id="496da3e22e1e3340caf097640e4353358048134f" translate="yes" xml:space="preserve">
          <source>The sdbm file format was designed for speed and convenience, not for portability or security. A maliciously crafted file might cause perl to crash or even expose a security vulnerability.</source>
          <target state="translated">sdbm ファイル形式は、速度と利便性を目的として設計されたものであり、移植性やセキュリティを目的としたものではありません。悪意を持って細工されたファイルは、perlをクラッシュさせたり、セキュリティ上の脆弱性を暴露したりする可能性があります。</target>
        </trans-unit>
        <trans-unit id="bc3001b62b3120b5e625f2291ab08a912ad78b79" translate="yes" xml:space="preserve">
          <source>The search engine will initially match &lt;code&gt;\D*&lt;/code&gt; with &quot;ABC&quot;. Then it will try to match &lt;code&gt;(?!123)&lt;/code&gt; with &quot;123&quot;, which fails. But because a quantifier (&lt;code&gt;\D*&lt;/code&gt; ) has been used in the regular expression, the search engine can backtrack and retry the match differently in the hope of matching the complete regular expression.</source>
          <target state="translated">検索エンジンは最初に &lt;code&gt;\D*&lt;/code&gt; を &quot;ABC&quot;と照合します。次に、 &lt;code&gt;(?!123)&lt;/code&gt; を &quot;123&quot;と一致させようとしますが、失敗します。ただし、正規表現で数量詞（ &lt;code&gt;\D*&lt;/code&gt; ）が使用されているため、完全な正規表現と一致することを期待して、検索エンジンはバックトラックして別の方法で照合を再試行できます。</target>
        </trans-unit>
        <trans-unit id="2dd6a24dc0c40439966d70dfb7faeebd4df837f5" translate="yes" xml:space="preserve">
          <source>The search engine will initially match &lt;code&gt;\D*&lt;/code&gt; with &quot;ABC&quot;. Then it will try to match &lt;code&gt;(?!123)&lt;/code&gt; with &quot;123&quot;, which fails. But because a quantifier (&lt;code&gt;\D*&lt;/code&gt;) has been used in the regular expression, the search engine can backtrack and retry the match differently in the hope of matching the complete regular expression.</source>
          <target state="translated">検索エンジンは、最初は &lt;code&gt;\D*&lt;/code&gt; を「ABC」と照合します。次に、 &lt;code&gt;(?!123)&lt;/code&gt; を「123」と一致させようとしますが、失敗します。ただし、正規表現で数量詞（ &lt;code&gt;\D*&lt;/code&gt; ）が使用されているため、検索エンジンは、完全な正規表現に一致することを期待して、別の方法で一致をバックトラックして再試行できます。</target>
        </trans-unit>
        <trans-unit id="4989338d675235ed7afc62322345e940a111f8d8" translate="yes" xml:space="preserve">
          <source>The second advantage is that embedded modifiers (except &lt;code&gt;//p&lt;/code&gt; , which modifies the entire regexp) only affect the regexp inside the group the embedded modifier is contained in. So grouping can be used to localize the modifier's effects:</source>
          <target state="translated">2番目の利点は、埋め込まれた修飾子（正規表現全体を変更する &lt;code&gt;//p&lt;/code&gt; を除く）は、埋め込まれた修飾子が含まれるグループ内の正規表現にのみ影響するということです。したがって、グループ化を使用して修飾子の効果をローカライズできます。</target>
        </trans-unit>
        <trans-unit id="344654afee619df186bd5aa49c470902771a22f7" translate="yes" xml:space="preserve">
          <source>The second advantage is that embedded modifiers (except &lt;code&gt;/p&lt;/code&gt;, which modifies the entire regexp) only affect the regexp inside the group the embedded modifier is contained in. So grouping can be used to localize the modifier's effects:</source>
          <target state="translated">2番目の利点は、埋め込み修飾子（regexp全体を変更する &lt;code&gt;/p&lt;/code&gt; を除く）が、埋め込み修飾子が含まれるグループ内のregexpにのみ影響することです。したがって、グループ化を使用して、修飾子の効果をローカライズできます。</target>
        </trans-unit>
        <trans-unit id="e6b19a99a58715509197b4fd3bb055452f4e6bb8" translate="yes" xml:space="preserve">
          <source>The second and third arguments &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; specify how many of the specified type of data structure should be allocated. The argument &lt;code&gt;type&lt;/code&gt; is passed to &lt;code&gt;sizeof&lt;/code&gt; . The final argument to &lt;code&gt;Newxc&lt;/code&gt; , &lt;code&gt;cast&lt;/code&gt; , should be used if the &lt;code&gt;pointer&lt;/code&gt; argument is different from the &lt;code&gt;type&lt;/code&gt; argument.</source>
          <target state="translated">2番目と3番目の引数の &lt;code&gt;number&lt;/code&gt; と &lt;code&gt;type&lt;/code&gt; は、指定されたタイプのデータ構造のいくつを割り当てる必要があるかを指定します。引数の &lt;code&gt;type&lt;/code&gt; は &lt;code&gt;sizeof&lt;/code&gt; に渡されます。 &lt;code&gt;Newxc&lt;/code&gt; の最後の引数である &lt;code&gt;cast&lt;/code&gt; は、 &lt;code&gt;pointer&lt;/code&gt; 引数が &lt;code&gt;type&lt;/code&gt; 引数と異なる場合に使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="fea027e954f4ec8636256c0b94ce6f7f44ab6c0c" translate="yes" xml:space="preserve">
          <source>The second and third arguments &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; specify how many of the specified type of data structure should be allocated. The argument &lt;code&gt;type&lt;/code&gt; is passed to &lt;code&gt;sizeof&lt;/code&gt;. The final argument to &lt;code&gt;Newxc&lt;/code&gt;, &lt;code&gt;cast&lt;/code&gt;, should be used if the &lt;code&gt;pointer&lt;/code&gt; argument is different from the &lt;code&gt;type&lt;/code&gt; argument.</source>
          <target state="translated">2番目と3番目の引数の &lt;code&gt;number&lt;/code&gt; と &lt;code&gt;type&lt;/code&gt; は、指定されたタイプのデータ構造をいくつ割り当てるかを指定します。引数の &lt;code&gt;type&lt;/code&gt; は &lt;code&gt;sizeof&lt;/code&gt; に渡されます。最後の引数 &lt;code&gt;Newxc&lt;/code&gt; 、 &lt;code&gt;cast&lt;/code&gt; あれば、使用されるべき &lt;code&gt;pointer&lt;/code&gt; 引数が異なる &lt;code&gt;type&lt;/code&gt; の引数。</target>
        </trans-unit>
        <trans-unit id="1b7128198e8ffe79d47674dc971b588a148d07fe" translate="yes" xml:space="preserve">
          <source>The second and third highest priorities are to look in the parent of the current directory and a directory called</source>
          <target state="translated">2番目と3番目の優先順位は、カレントディレクトリの親ディレクトリと</target>
        </trans-unit>
        <trans-unit id="9372cc26ce11f225b78cb9001dded71987be37ab" translate="yes" xml:space="preserve">
          <source>The second argument ($eol) is the line-ending sequence to use. It is optional and defaults to &quot;\n&quot;. Every occurrence of &quot;\n&quot; is replaced with this string, and it is also used for additional &quot;soft line breaks&quot; to ensure that no line end up longer than 76 characters. Pass it as &quot;\015\012&quot; to produce data suitable for external consumption. The string &quot;\r\n&quot; produces the same result on many platforms, but not all.</source>
          <target state="translated">第二引数 ($eol)は、使用する改行シーケンスです。これはオプションで、デフォルトは &quot;\n&quot; です。&quot;\n&quot; のすべての出現はこの文字列に置き換えられ、76文字より長い行がないことを保証するための追加の &quot;ソフト改行&quot; にも使用されます。&quot;\015012 &quot;として渡して、外部消費に適したデータを生成する。文字列&quot;\rn &quot;は、多くのプラットフォームで同じ結果を生成するが、すべてではない。</target>
        </trans-unit>
        <trans-unit id="691db7e7ba5b2eef57391203c3fd8b3455b42a9c" translate="yes" xml:space="preserve">
          <source>The second argument can be a hash reference with options, which are identical to the arguments passed to &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">2番目の引数は、 &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; に渡される引数と同じであるオプション付きのハッシュ参照にすることができます。</target>
        </trans-unit>
        <trans-unit id="d9356e806771df85496c708eb7a467795a26a60f" translate="yes" xml:space="preserve">
          <source>The second argument can be a hash reference with options, which are identical to the arguments passed to &lt;code&gt;read()&lt;/code&gt;.</source>
          <target state="translated">2番目の引数は、 &lt;code&gt;read()&lt;/code&gt; に渡される引数と同じオプションを持つハッシュ参照にすることができます。</target>
        </trans-unit>
        <trans-unit id="36e7dec2e6aed1723cd212b39460017f8772c38b" translate="yes" xml:space="preserve">
          <source>The second argument is a regular expression. It may be given as a regex reference (i.e. &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;) or (for better compatibility with older perls) as a string that looks like a regex (alternative delimiters are currently not supported):</source>
          <target state="translated">2番目の引数は正規表現です。正規表現の参照（つまり &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; ）または（古いperlとの互換性を高めるため）正規表現のような文字列として指定できます（代替の区切り文字は現在サポートされていません）。</target>
        </trans-unit>
        <trans-unit id="851ff1e7afee5d9f26155a298af3215064fbafc8" translate="yes" xml:space="preserve">
          <source>The second argument is a regular expression. It may be given as a regex reference (i.e. &lt;code&gt;qr//&lt;/code&gt;) or (for better compatibility with older perls) as a string that looks like a regex (alternative delimiters are currently not supported):</source>
          <target state="translated">2番目の引数は正規表現です。これは、正規表現参照（つまり、 &lt;code&gt;qr//&lt;/code&gt; ）として、または（古いperlとの互換性を高めるために）正規表現のように見える文字列として指定できます（代替区切り文字は現在サポートされていません）。</target>
        </trans-unit>
        <trans-unit id="e9cd8da657568e7bbba17b34028b2178bd5abb57" translate="yes" xml:space="preserve">
          <source>The second argument is considered a regex if it is either a regex object or a string that looks like a regex. Regex objects are constructed with the qr// operator in recent versions of perl. A string is considered to look like a regex if its first and last characters are &quot;/&quot;, or if the first character is &quot;m&quot; and its second and last characters are both the same non-alphanumeric non-whitespace character. These regexp</source>
          <target state="translated">第二引数は、正規表現オブジェクトか正規表現のように見える文字列のいずれかであれば、正規表現とみなされます。正規表現オブジェクトは、perlの最近のバージョンではqr//演算子を使って構築されます。文字列は、最初と最後の文字が&quot;/&quot;であるか、最初の文字が &quot;m &quot;で、2番目と最後の文字が両方とも同じ英数字以外の非空白文字である場合、正規表現のように見えるとみなされます。これらの正規表現</target>
        </trans-unit>
        <trans-unit id="ffe3c605f37afcab4c8601d801b588d13a566637" translate="yes" xml:space="preserve">
          <source>The second argument is the other operand, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in the case of a unary operator.</source>
          <target state="translated">2番目の引数はもう一方のオペランド、または単項演算子の場合は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="e4f1fa234686b49496c4cac025cf1d9ea03f5c52" translate="yes" xml:space="preserve">
          <source>The second argument is the other operand, or &lt;code&gt;undef&lt;/code&gt; in the case of a unary operator.</source>
          <target state="translated">2番目の引数は、もう一方のオペランド、または単項演算子の場合は &lt;code&gt;undef&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="a8f0c3f0ec389d3780a678c2cc02cdb14b452933" translate="yes" xml:space="preserve">
          <source>The second argument is used to indicate compression. You can compress using &lt;code&gt;gzip&lt;/code&gt;, &lt;code&gt;bzip2&lt;/code&gt; or &lt;code&gt;xz&lt;/code&gt;. If you pass a digit, it's assumed to be the &lt;code&gt;gzip&lt;/code&gt; compression level (between 1 and 9), but the use of constants is preferred:</source>
          <target state="translated">2番目の引数は、圧縮を示すために使用されます。 &lt;code&gt;gzip&lt;/code&gt; 、 &lt;code&gt;bzip2&lt;/code&gt; 、または &lt;code&gt;xz&lt;/code&gt; を使用して圧縮できます。数字を渡す場合、それは &lt;code&gt;gzip&lt;/code&gt; 圧縮レベル（1から9の間）であると見なされますが、定数の使用が推奨されます。</target>
        </trans-unit>
        <trans-unit id="e99835175d57940dd272e3dc71fc2882ef5b0d66" translate="yes" xml:space="preserve">
          <source>The second argument is used to indicate compression. You can either compress using &lt;code&gt;gzip&lt;/code&gt; or &lt;code&gt;bzip2&lt;/code&gt; . If you pass a digit, it's assumed to be the &lt;code&gt;gzip&lt;/code&gt; compression level (between 1 and 9), but the use of constants is preferred:</source>
          <target state="translated">2番目の引数は、圧縮を示すために使用されます。 &lt;code&gt;gzip&lt;/code&gt; または &lt;code&gt;bzip2&lt;/code&gt; を使用して圧縮できます。数字を渡すと、 &lt;code&gt;gzip&lt;/code&gt; 圧縮レベル（1〜9）であると見なされますが、定数を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a0c730e612ef3dd802df3a15f52c50f234217ccd" translate="yes" xml:space="preserve">
          <source>The second argument may be considered optional, but remains for backwards compatibility. Archive::Tar now looks at the file magic to determine what class should be used to open the file and will transparently Do The Right Thing.</source>
          <target state="translated">2 番目の引数はオプションとみなされるかもしれませんが、下位互換性のために残っています。Archive::Tar は、ファイルを開くためにどのクラスを使うべきかを決定するためにファイルマジックを見て、透過的に Do The Right Thing を実行するようになりました。</target>
        </trans-unit>
        <trans-unit id="fc50752077e3b12e3cd10f78b06bb8c9b8f956b4" translate="yes" xml:space="preserve">
          <source>The second argument points to an array containing &lt;code&gt;num&lt;/code&gt;&lt;code&gt;SV*&lt;/code&gt; 's. Once the AV has been created, the SVs can be destroyed, if so desired.</source>
          <target state="translated">2番目の引数は、 &lt;code&gt;num&lt;/code&gt; 個の &lt;code&gt;SV*&lt;/code&gt; を含む配列を指します。AVが作成されたら、必要に応じてSVを破棄できます。</target>
        </trans-unit>
        <trans-unit id="51ba89f615646daa0a3b0a56db80558ec7c78c30" translate="yes" xml:space="preserve">
          <source>The second argument points to an array containing &lt;code&gt;num&lt;/code&gt;&lt;code&gt;SV*&lt;/code&gt;'s. Once the AV has been created, the SVs can be destroyed, if so desired.</source>
          <target state="translated">2番目の引数は、 &lt;code&gt;num&lt;/code&gt; 個の &lt;code&gt;SV*&lt;/code&gt; を含む配列を指します。AVが作成されると、必要に応じてSVを破棄できます。</target>
        </trans-unit>
        <trans-unit id="ae8c79378da8449512fbe01727cd6ac969d7ae7c" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;&quot;-|&quot;&lt;/code&gt;, makes it a read-pipe into a separate program, rather than an ordinary filehandle into a file.</source>
          <target state="translated">2番目の引数 &lt;code&gt;open&lt;/code&gt; 、 &lt;code&gt;&quot;-|&quot;&lt;/code&gt; 、ファイルへの通常のファイルハンドルではなく、別のプログラムへの読み取りパイプにします。</target>
        </trans-unit>
        <trans-unit id="241df4a30fc4febc2cd9ef098abdb1cdbc871750" translate="yes" xml:space="preserve">
          <source>The second call to hex() will warn about a non-portable constant.</source>
          <target state="translated">hex()の二回目の呼び出しは、移植性のない定数について警告します。</target>
        </trans-unit>
        <trans-unit id="52f5fb6e434df4bf3ba2648b67634f2b93cdc1b5" translate="yes" xml:space="preserve">
          <source>The second call-back is optional if the call back is registered prior to the call to $term-&amp;gt;readline.</source>
          <target state="translated">$ term-&amp;gt; readlineを呼び出す前にコールバックが登録されている場合、2番目のコールバックはオプションです。</target>
        </trans-unit>
        <trans-unit id="104d457b0581ca75e5a33a6cc382aa3d75495d54" translate="yes" xml:space="preserve">
          <source>The second call-back registered is the call back for registration. The input filehandle (often STDIN, but not necessarily) will be passed in.</source>
          <target state="translated">2番目に登録されたコールバックは、登録のためのコールバックです。入力されたファイルハンドル(多くの場合はSTDINですが、必ずしもそうとは限りません)が渡されます。</target>
        </trans-unit>
        <trans-unit id="8a9a833fe2a8c9894ba16f1673e04b6df3b8c78c" translate="yes" xml:space="preserve">
          <source>The second case often turns out to have identical results to the first case, albeit only by accident.</source>
          <target state="translated">2つ目のケースでは、偶然とはいえ、1つ目のケースと同じ結果になることがよくあります。</target>
        </trans-unit>
        <trans-unit id="9a2db73bb8959c9504bedfb024b1f19ea96655cb" translate="yes" xml:space="preserve">
          <source>The second class of portable ranges is invoked when one or both of the range's end points are expressed as &lt;code&gt;\N{...}&lt;/code&gt;</source>
          <target state="translated">ポータブル範囲の2番目のクラスは、範囲のエンドポイントの一方または両方が &lt;code&gt;\N{...}&lt;/code&gt; として表されるときに呼び出されます。</target>
        </trans-unit>
        <trans-unit id="0d9c1d1eb4a7fe50e319b8d6cb4e544cda2638c9" translate="yes" xml:space="preserve">
          <source>The second column is the return type, the third column the name. Columns after that are the arguments. The first column is a set of flags:</source>
          <target state="translated">2番目のカラムは戻り値の種類、3番目のカラムは名前です。それ以降の列は引数です。最初のカラムはフラグのセットです。</target>
        </trans-unit>
        <trans-unit id="833ac465c5bc76260e3533a8f5293c1a6cc4e353" translate="yes" xml:space="preserve">
          <source>The second example in the synopsis does something equivalent to this:</source>
          <target state="translated">シノプシスの2つ目の例は、これに相当することをしています。</target>
        </trans-unit>
        <trans-unit id="f7f8f6797190b2ee94971db1ba0f6aeb4ac8dc06" translate="yes" xml:space="preserve">
          <source>The second example prints entries with names &lt;code&gt;foo&lt;/code&gt; , and also entries with names which ends on &lt;code&gt;bar&lt;/code&gt; , or are shorter than 5 chars.</source>
          <target state="translated">2番目の例では、名前が &lt;code&gt;foo&lt;/code&gt; のエントリと、名前が &lt;code&gt;bar&lt;/code&gt; で終わるか、5文字より短いエントリも出力されます。</target>
        </trans-unit>
        <trans-unit id="ff08cd3ad532db8c5d5dd8a872abb6c4f322ba5e" translate="yes" xml:space="preserve">
          <source>The second example prints entries with names &lt;code&gt;foo&lt;/code&gt;, and also entries with names which ends on &lt;code&gt;bar&lt;/code&gt;, or are shorter than 5 chars.</source>
          <target state="translated">2番目の例では、名前が &lt;code&gt;foo&lt;/code&gt; のエントリと、 &lt;code&gt;bar&lt;/code&gt; で終わる、または5文字より短い名前のエントリを出力します。</target>
        </trans-unit>
        <trans-unit id="6b7ec951497cf0073403b17626a675e036c31257" translate="yes" xml:space="preserve">
          <source>The second exit point tests if there is any data left in the input buffer, &lt;code&gt;$input&lt;/code&gt; - remember that the &lt;code&gt;ConsumeInput&lt;/code&gt; option is automatically enabled when &lt;code&gt;LimitOutput&lt;/code&gt; is used. When the input buffer has been exhausted, the outer loop can run again and overwrite a now empty &lt;code&gt;$input&lt;/code&gt; .</source>
          <target state="translated">2番目の出口点は、入力バッファー &lt;code&gt;$input&lt;/code&gt; データが残っているかどうかをテストします &lt;code&gt;LimitOutput&lt;/code&gt; を使用すると、 &lt;code&gt;ConsumeInput&lt;/code&gt; オプションが自動的に有効になることに注意してください。入力バッファが使い果たされると、外側のループが再度実行され、空になった &lt;code&gt;$input&lt;/code&gt; を上書きできます。</target>
        </trans-unit>
        <trans-unit id="7cea8aa29f5d1b03f7b0a4cb746f125b76bdff01" translate="yes" xml:space="preserve">
          <source>The second exit point tests if there is any data left in the input buffer, &lt;code&gt;$input&lt;/code&gt; - remember that the &lt;code&gt;ConsumeInput&lt;/code&gt; option is automatically enabled when &lt;code&gt;LimitOutput&lt;/code&gt; is used. When the input buffer has been exhausted, the outer loop can run again and overwrite a now empty &lt;code&gt;$input&lt;/code&gt;.</source>
          <target state="translated">2番目の出口点は、入力バッファー &lt;code&gt;$input&lt;/code&gt; データが残っているかどうかをテストします &lt;code&gt;LimitOutput&lt;/code&gt; を使用すると、 &lt;code&gt;ConsumeInput&lt;/code&gt; オプションが自動的に有効になることに注意してください。入力バッファが使い果たされると、外側のループが再び実行され、空になった &lt;code&gt;$input&lt;/code&gt; 上書きされます。</target>
        </trans-unit>
        <trans-unit id="1dba4d9ed358b9b1b26a10b82c95880d18ef1ec5" translate="yes" xml:space="preserve">
          <source>The second form allows the filter to hold state information using a closure, thus:</source>
          <target state="translated">第2の実施形態によれば、フィルタは、クロージャを用いて状態情報を保持することができるので、このようにして、状態情報を保持することができる。</target>
        </trans-unit>
        <trans-unit id="204d9fcc358796976a40cb62f3873844790ea690" translate="yes" xml:space="preserve">
          <source>The second form is strongly discouraged, because it breaks the ability of a subclass to reuse the parent's constructor, but you may still run across it in existing code.</source>
          <target state="translated">2 番目の形式は、サブクラスが親のコンストラクタを再利用する能力を壊すので、強くお勧めしません。</target>
        </trans-unit>
        <trans-unit id="0819d819ae212b8e1bcdb9b5bc6d671458a8958e" translate="yes" xml:space="preserve">
          <source>The second form limits or expands the output with shell globbing as in the following examples:</source>
          <target state="translated">2 番目の形式では、以下の例のようにシェル・グロビングを使用して出力を制限または拡張します。</target>
        </trans-unit>
        <trans-unit id="c407c89499b72c27a5a072472ddedf2b307bb4f0" translate="yes" xml:space="preserve">
          <source>The second form takes an ASCII string of &quot;0&quot; and &quot;1&quot; characters as its argument. It's equivalent to</source>
          <target state="translated">2番目の形式は、&quot;0 &quot;と &quot;1 &quot;のASCII文字列を引数にとります。これは次のようなものです。</target>
        </trans-unit>
        <trans-unit id="653b770c920437547bfd253af4e36f98e0dbfce5" translate="yes" xml:space="preserve">
          <source>The second form, for convenience, simply calls the &lt;code&gt;new&lt;/code&gt; method on its arguments before dumping the object immediately.</source>
          <target state="translated">2番目の形式は、便宜上、オブジェクトをすぐにダンプする前に、引数で &lt;code&gt;new&lt;/code&gt; メソッドを呼び出すだけです。</target>
        </trans-unit>
        <trans-unit id="dc711c3d286876153bcbf61db541b42c9a9350fc" translate="yes" xml:space="preserve">
          <source>The second gives data on how many keys are at each depth in the chain, and gives an idea of how much work a fetch *hit* will take. The performance for an update or delete of an item in the hash is equivalent to this case.</source>
          <target state="translated">2つ目は、チェーンの各深さにどれだけのキーがあるかのデータを提供し、フェッチ*hit*にどれだけの作業が必要かのアイデアを提供します。ハッシュ内のアイテムの更新や削除のパフォーマンスは、この場合と同等です。</target>
        </trans-unit>
        <trans-unit id="5995436678b8ce31e572994a72a1c15e94c7f93e" translate="yes" xml:space="preserve">
          <source>The second is</source>
          <target state="translated">2つ目は</target>
        </trans-unit>
        <trans-unit id="3d4dc00d964c0b0076b393752a2dfc8106f40760" translate="yes" xml:space="preserve">
          <source>The second is a question mark &lt;code&gt;?&lt;/code&gt; to match any single character. The third specifies a specific set of characters.</source>
          <target state="translated">2つ目は疑問符 &lt;code&gt;?&lt;/code&gt; 任意の1文字に一致します。3番目は、特定の文字セットを指定します。</target>
        </trans-unit>
        <trans-unit id="86badbc4e990f49a4a0e0309ce3e34af3acb8215" translate="yes" xml:space="preserve">
          <source>The second is, in short, more readable. In particular, it's obvious that the number of parameters you're feeding to that phrase (two) is the number of parameters that it</source>
          <target state="translated">2つ目は、要するに、より読みやすくなっています。特に、そのフレーズに与えているパラメータの数(2)は明らかに</target>
        </trans-unit>
        <trans-unit id="7d7dcadbcc9256c73e53e45ca4167a8f00171936" translate="yes" xml:space="preserve">
          <source>The second method both creates the AV and initially populates it with SVs:</source>
          <target state="translated">2つ目の方法は、両方ともAVを作成し、最初にSVを入れます。</target>
        </trans-unit>
        <trans-unit id="5a04571edd1042cba183eaac5eb081daffd5163c" translate="yes" xml:space="preserve">
          <source>The second method divides up the generated code into</source>
          <target state="translated">2 番目のメソッドは、生成されたコードを次のように分割します。</target>
        </trans-unit>
        <trans-unit id="30b5717864fa144252bae28ce0e68e9e2886c509" translate="yes" xml:space="preserve">
          <source>The second new display parameter is &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; , which can be set to true or false, the default being true. See the previous section for what this means.</source>
          <target state="translated">2番目の新しい表示パラメーターは &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; で、trueまたはfalseに設定できます。デフォルトはtrueです。これの意味については、前のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="a8d5bb3a74ae14b7cc834ba7cb47fc90749857de" translate="yes" xml:space="preserve">
          <source>The second new display parameter is &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt;, which can be set to true or false, the default being true. See the previous section for what this means.</source>
          <target state="translated">2番目の新しい表示パラメーターは &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; 。これはtrueまたはfalseに設定でき、デフォルトはtrueです。これが何を意味するかについては、前のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="105094491ac9a931737afcae5ec00cc67ecea83f" translate="yes" xml:space="preserve">
          <source>The second option is to explicitly instruct Configure to detect the newer Berkeley DB installation, by supplying the right directories with &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; and &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt;&lt;b&gt;and&lt;/b&gt; before running &quot;make test&quot; setting your LD_LIBRARY_PATH to</source>
          <target state="translated">2番目のオプションは、正しいディレクトリに &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; および &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt; &lt;b&gt;を指定し&lt;/b&gt;、LD_LIBRARY_PATHを &quot;make test&quot;に設定する前に、Configureに新しいBerkeley DBインストールを検出するように明示的に指示することです。</target>
        </trans-unit>
        <trans-unit id="b104d0289f2a63192d73ded4515b99bcffef5da9" translate="yes" xml:space="preserve">
          <source>The second parameter, &lt;code&gt;$mode&lt;/code&gt; , is used to specify whether the file is opened for reading or writing and to optionally specify a compression level and compression strategy when writing. The format of the &lt;code&gt;$mode&lt;/code&gt; parameter is similar to the mode parameter to the 'C' function &lt;code&gt;fopen&lt;/code&gt; , so &quot;rb&quot; is used to open for reading, &quot;wb&quot; for writing and &quot;ab&quot; for appending (writing at the end of the file).</source>
          <target state="translated">2番目のパラメーター &lt;code&gt;$mode&lt;/code&gt; を使用して、ファイルを読み取り用または書き込み用のどちらで開くかを指定し、オプションで書き込み時の圧縮レベルと圧縮方法を指定します。 &lt;code&gt;$mode&lt;/code&gt; パラメーターの形式は、'C'関数 &lt;code&gt;fopen&lt;/code&gt; のモードパラメーターに似ているため、「rb」を使用して読み取り用に開き、「wb」を書き込み用に、「ab」を追加して（末尾の書き込み）ファイル）。</target>
        </trans-unit>
        <trans-unit id="40f3477c6f4b0d20844832da1b4bf48b8115879e" translate="yes" xml:space="preserve">
          <source>The second parameter, &lt;code&gt;$mode&lt;/code&gt;, is used to specify whether the file is opened for reading or writing and to optionally specify a compression level and compression strategy when writing. The format of the &lt;code&gt;$mode&lt;/code&gt; parameter is similar to the mode parameter to the 'C' function &lt;code&gt;fopen&lt;/code&gt;, so &quot;rb&quot; is used to open for reading, &quot;wb&quot; for writing and &quot;ab&quot; for appending (writing at the end of the file).</source>
          <target state="translated">2番目のパラメーター &lt;code&gt;$mode&lt;/code&gt; は、ファイルを読み取り用に開くか書き込み用に開くかを指定し、オプションで書き込み時の圧縮レベルと圧縮戦略を指定するために使用されます。 &lt;code&gt;$mode&lt;/code&gt; パラメーターの形式は、「C」関数 &lt;code&gt;fopen&lt;/code&gt; のmodeパラメーターに似ているため、「rb」は読み取り用に開き、「wb」は書き込み用、「ab」は追加（最後に書き込み）に使用されます。ファイル）。</target>
        </trans-unit>
        <trans-unit id="3411b2ade45037b8736308e07cf74ad1d92df3ee" translate="yes" xml:space="preserve">
          <source>The second regexp doesn't match because &lt;code&gt;'^'&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the beginning of the string, but &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; has keeper starting in the middle. The third regexp does match, since the &lt;code&gt;'$'&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the end of the string.</source>
          <target state="translated">&lt;code&gt;'^'&lt;/code&gt; は &lt;code&gt;keeper&lt;/code&gt; を文字列の先頭でのみ一致するように制約するため、2番目の正規表現は一致しませんが、 &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; ではキーパーが中央から始まります。 &lt;code&gt;'$'&lt;/code&gt; は &lt;code&gt;keeper&lt;/code&gt; を文字列の最後でのみ一致するように制約するため、3番目の正規表現は一致します。</target>
        </trans-unit>
        <trans-unit id="9eae2bfeb40a7aaf7114e7fd8256ee81caccdbd3" translate="yes" xml:space="preserve">
          <source>The second regexp doesn't match because &lt;code&gt;^&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the beginning of the string, but &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; has keeper starting in the middle. The third regexp does match, since the &lt;code&gt;$&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the end of the string.</source>
          <target state="translated">2番目の正規表現は一致しません。 &lt;code&gt;^&lt;/code&gt; により、 &lt;code&gt;keeper&lt;/code&gt; は文字列の先頭でのみ一致するように制約されますが、 &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; は途中でキーパーを開始します。 &lt;code&gt;$&lt;/code&gt; は &lt;code&gt;keeper&lt;/code&gt; が文字列の最後でのみ一致するように制約するため、3番目の正規表現は一致します。</target>
        </trans-unit>
        <trans-unit id="733da91fc44d8ab5e75ced78a6cc48a582c7d7b0" translate="yes" xml:space="preserve">
          <source>The second returned item and &lt;code&gt;$!&lt;/code&gt; can be used to check for valid input:</source>
          <target state="translated">2番目の返品アイテムと &lt;code&gt;$!&lt;/code&gt; 有効な入力を確認するために使用できます。</target>
        </trans-unit>
        <trans-unit id="2c1496bf9c5a01143ce96b1f9c010fe32e40f772" translate="yes" xml:space="preserve">
          <source>The second sentence is wrong. In actual fact bval will only default to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; when the openinfo parameter in dbopen is NULL. If a non-NULL openinfo parameter is used at all, the value that happens to be in bval will be used. That means you always have to specify bval when making use of any of the options in the openinfo parameter. This documentation error will be fixed in the next release of Berkeley DB.</source>
          <target state="translated">2番目の文は間違っています。実際には、bopenのデフォルトは、dbopenのopeninfoパラメータがNULLの場合にのみ &lt;code&gt;&quot;\n&quot;&lt;/code&gt; になります。 NULL以外のopeninfoパラメータが使用された場合、偶然bvalにある値が使用されます。つまり、openinfoパラメータのオプションを使用するときは、常にbvalを指定する必要があります。このドキュメントエラーは、Berkeley DBの次のリリースで修正される予定です。</target>
        </trans-unit>
        <trans-unit id="aaad1f57fe700f2a9b2dd58ec708684feaf8128f" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a lexical subroutine that has gone out of scope, for example,</source>
          <target state="translated">2つ目の状況は、例えば範囲外になってしまった語彙サブルーチンに eval がアクセスすることで発生します。</target>
        </trans-unit>
        <trans-unit id="9ade278ee614d31e9547b1781d35dc6ff90a8980" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a variable that has gone out of scope, for example,</source>
          <target state="translated">2つ目の状況は、evalがスコープ外になった変数にアクセスしている場合などに発生します。</target>
        </trans-unit>
        <trans-unit id="b47d8c8a23f4e0d763e99999d69c0c5eb0cb3a92" translate="yes" xml:space="preserve">
          <source>The second style of bundling lifts this restriction. It can be enabled with:</source>
          <target state="translated">2 番目のスタイルのバンドルは、この制限を解除します。で有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="ab8073e684e0f88cfe3fd5f9716b9c696bbef27e" translate="yes" xml:space="preserve">
          <source>The second value to be substituted in the output string (usually the row in cursor addressing capabilities)</source>
          <target state="translated">出力文字列で置換される2番目の値(通常はカーソルアドレッシング機能の行)</target>
        </trans-unit>
        <trans-unit id="72ec171fc6e9d8dd4e1917d8ba0d47a2f390d23d" translate="yes" xml:space="preserve">
          <source>The second, more efficient way is to use the following template for your Foo.xs:</source>
          <target state="translated">2つ目のより効率的な方法は、以下のテンプレートをFoo.xsに使用することです。</target>
        </trans-unit>
        <trans-unit id="ea8fa202ee5b9df3dfb7272625ecae21681f7d7d" translate="yes" xml:space="preserve">
          <source>The section (AKA &quot;item&quot; in older perlpods), or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if none. E.g., in &quot;L&amp;lt;Getopt::Std/DESCRIPTION&amp;gt;&quot;, &quot;DESCRIPTION&quot; is the section. (Note that this is not the same as a manpage section like the &quot;5&quot; in &quot;man 5 crontab&quot;. &quot;Section Foo&quot; in the Pod sense means the part of the text that's introduced by the heading or item whose text is &quot;Foo&quot;.)</source>
          <target state="translated">セクション（古いperlpodでは「アイテム」とも呼ばれます）、または存在しない場合は &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; 。たとえば、「L &amp;lt;Getopt :: Std / DESCRIPTION&amp;gt;」では、「DESCRIPTION」がセクションです。 （これは、「man 5 crontab」の「5」のようなマンページセクションと同じではないことに注意してください。ポッドの意味での「セクションFoo」は、「Foo」という見出しまたは項目によって導入されたテキストの部分を意味します」</target>
        </trans-unit>
        <trans-unit id="cd89b9d74f7d870dca4a759e8ab8f51f0dc1f9b2" translate="yes" xml:space="preserve">
          <source>The section (AKA &quot;item&quot; in older perlpods), or &lt;code&gt;undef&lt;/code&gt; if none. E.g., in &quot;L&amp;lt;Getopt::Std/DESCRIPTION&amp;gt;&quot;, &quot;DESCRIPTION&quot; is the section. (Note that this is not the same as a manpage section like the &quot;5&quot; in &quot;man 5 crontab&quot;. &quot;Section Foo&quot; in the Pod sense means the part of the text that's introduced by the heading or item whose text is &quot;Foo&quot;.)</source>
          <target state="translated">セクション（古いperlpodの別名「アイテム」）、または存在しない場合は &lt;code&gt;undef&lt;/code&gt; 。たとえば、「L &amp;lt;Getopt :: Std / DESCRIPTION&amp;gt;」では、「DESCRIPTION」がセクションです。 （これは、「man5crontab」の「5」のようなマンページセクションと同じではないことに注意してください。ポッドの意味での「SectionFoo」は、テキストが「Foo」である見出しまたはアイテムによって導入されるテキストの部分を意味します。 &quot;。）</target>
        </trans-unit>
        <trans-unit id="592a5f44132e9a3aa5e9a10cfa07afacf196746b" translate="yes" xml:space="preserve">
          <source>The security aspect of temporary file creation is emphasized such that a filehandle and filename are returned together. This helps guarantee that a race condition can not occur where the temporary file is created by another process between checking for the existence of the file and its opening. Additional security levels are provided to check, for example, that the sticky bit is set on world writable directories. See &lt;a href=&quot;#safe_level&quot;&gt;&quot;safe_level&quot;&lt;/a&gt; for more information.</source>
          <target state="translated">一時ファイル作成のセキュリティ面は、ファイルハンドルとファイル名が一緒に返されるように強調されています。これにより、ファイルの存在を確認してから開くまでの間に、別のプロセスによって一時ファイルが作成された場合に競合状態が発生しないことが保証されます。スティッキービットが誰でも書き込み可能なディレクトリに設定されていることを確認するために、追加のセキュリティレベルが提供されています。詳細については、&lt;a href=&quot;#safe_level&quot;&gt;「safe_level」&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="8d5faf936bbea0ef6b4af3b53c6607ced9b3cdea" translate="yes" xml:space="preserve">
          <source>The security aspect of temporary file creation is emphasized such that a filehandle and filename are returned together. This helps guarantee that a race condition can not occur where the temporary file is created by another process between checking for the existence of the file and its opening. Additional security levels are provided to check, for example, that the sticky bit is set on world writable directories. See &lt;a href=&quot;#safe_level&quot;&gt;safe_level&lt;/a&gt; for more information.</source>
          <target state="translated">一時ファイル作成のセキュリティ面は、ファイルハンドルとファイル名が一緒に返されるように強調されています。これにより、ファイルの存在を確認してからファイルを開くまでの間に別のプロセスによって一時ファイルが作成された場合に、競合状態が発生しないことが保証されます。たとえば、スティッキービットが誰でも書き込み可能なディレクトリに設定されていることを確認するために、追加のセキュリティレベルが提供されます。詳細については、&lt;a href=&quot;#safe_level&quot;&gt;safe_level&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="02ef1170c6c4276366f2c9602e48f300db3d9145" translate="yes" xml:space="preserve">
          <source>The seemingly equivalent construct in Perl, &lt;code&gt;$$aref[$i]&lt;/code&gt; first does the deref of $aref, making it take $aref as a reference to an array, and then dereference that, and finally tell you the</source>
          <target state="translated">Perlで一見同等の構成体である &lt;code&gt;$$aref[$i]&lt;/code&gt; は、最初に$ arefのderefを実行し、$ arefを配列への参照として取得し、次にそれを逆参照し、最後に</target>
        </trans-unit>
        <trans-unit id="5ae490ef8bae426993ed6639b51d33e36f67a5f8" translate="yes" xml:space="preserve">
          <source>The semantics of interval timers for multithreaded programs are system-specific, and some systems may support additional interval timers. For example, it is unspecified which thread gets the signals. See your &lt;a href=&quot;setitimer(2)&quot;&gt;&lt;code&gt;setitimer(2)&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">マルチスレッドプログラムのインターバルタイマーのセマンティクスはシステム固有であり、一部のシステムは追加のインターバルタイマーをサポートする場合があります。たとえば、どのスレッドがシグナルを取得するかは指定されていません。&lt;a href=&quot;setitimer(2)&quot;&gt; &lt;code&gt;setitimer(2)&lt;/code&gt; の&lt;/a&gt;ドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="5d3a7adddb69f2204deb61bd662439aeebd384d4" translate="yes" xml:space="preserve">
          <source>The semantics of interval timers for multithreaded programs are system-specific, and some systems may support additional interval timers. For example, it is unspecified which thread gets the signals. See your &lt;code&gt;setitimer()&lt;/code&gt; documentation.</source>
          <target state="translated">マルチスレッドプログラムのインターバルタイマーのセマンティクスはシステム固有であり、システムによっては追加のインターバルタイマーをサポートする場合があります。たとえば、どのスレッドがシグナルを受け取るかは不定です。 &lt;code&gt;setitimer()&lt;/code&gt; のドキュメントを参照してください。</target>
        </trans-unit>
        <trans-unit id="65ef3e0624e679879b7ce02cec7d6809073f165d" translate="yes" xml:space="preserve">
          <source>The sense of the match can be reversed by using &lt;code&gt;!~&lt;/code&gt; operator:</source>
          <target state="translated">&lt;code&gt;!~&lt;/code&gt; 演算子を使用して、一致の意味を逆にすることができます。</target>
        </trans-unit>
        <trans-unit id="571f2b8a003669439aca5df927f2bc3b59493e17" translate="yes" xml:space="preserve">
          <source>The sequence &lt;code&gt;\b&lt;/code&gt; is special inside a bracketed character class. While outside the character class, &lt;code&gt;\b&lt;/code&gt; is an assertion indicating a point that does not have either two word characters or two non-word characters on either side, inside a bracketed character class, &lt;code&gt;\b&lt;/code&gt; matches a backspace character.</source>
          <target state="translated">シーケンス &lt;code&gt;\b&lt;/code&gt; は、括弧で囲まれた文字クラス内では特別です。文字クラスの外側にある &lt;code&gt;\b&lt;/code&gt; は、両側に2つの単語文字または2つの非単語文字がないポイントを示すアサーションであり、角括弧で囲まれた文字クラスの内側では、 &lt;code&gt;\b&lt;/code&gt; はバックスペース文字と一致します。</target>
        </trans-unit>
        <trans-unit id="2e682f0e9f09d4fac48ccdb6cb912af9bfeddf7f" translate="yes" xml:space="preserve">
          <source>The sequence can also be extended to negative index n using the re-arranged recurrence relation</source>
          <target state="translated">また、配列は、再配列された再帰関係を用いて、負の指数nまで拡張することができます。</target>
        </trans-unit>
        <trans-unit id="6b263532d25e62f98e230387976bd3e1a8c5cb59" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP's next OP.</source>
          <target state="translated">次のOPのシークエンスナンバーです。</target>
        </trans-unit>
        <trans-unit id="b45bacc53a5ed1f0afceaa4ff3006834edab117c" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP, or a hyphen if it doesn't have one.</source>
          <target state="translated">OPのシーケンス番号、またはハイフンがない場合はハイフン。</target>
        </trans-unit>
        <trans-unit id="4f0a83d5889e74bacf92e475321b6ad01721beb5" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP. Note that this is a sequence number generated by B::Concise.</source>
          <target state="translated">OPのシーケンス番号。これはB::Conciseによって生成されたシーケンス番号であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="a1e46d38c7dda11bf03f174aca8ec057ac38a288" translate="yes" xml:space="preserve">
          <source>The sequence number of this partition. Partitions are numbered starting as &lt;code&gt;1&lt;/code&gt; [with &quot;partition 0&quot; meaning the entire disk]. Sometimes this field may be &lt;code&gt;0&lt;/code&gt; and you'll have to infer the partition sequence number from how many partitions precede it on the disk.</source>
          <target state="translated">このパーティションのシーケンス番号。パーティションには &lt;code&gt;1&lt;/code&gt; から始まる番号が付けられます[「パーティション0」はディスク全体を意味します]。このフィールドが &lt;code&gt;0&lt;/code&gt; の場合があり、ディスク上でその前にあるパーティションの数からパーティションシーケンス番号を推測する必要があります。</target>
        </trans-unit>
        <trans-unit id="c10dc949f49eb3d32cdb0534e93e9f1fddb641e8" translate="yes" xml:space="preserve">
          <source>The sequences &lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\c&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; , and &lt;code&gt;\x&lt;/code&gt; are also special and have the same meanings as they do outside a bracketed character class.</source>
          <target state="translated">シーケンス &lt;code&gt;\a&lt;/code&gt; 、 &lt;code&gt;\c&lt;/code&gt; 、 &lt;code&gt;\e&lt;/code&gt; 、 &lt;code&gt;\f&lt;/code&gt; 、 &lt;code&gt;\n&lt;/code&gt; 、 &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; 、 &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt; 、 &lt;code&gt;\r&lt;/code&gt; 、 &lt;code&gt;\t&lt;/code&gt; 、および &lt;code&gt;\x&lt;/code&gt; も特殊であり、それらと同じ意味です大括弧で囲まれた文字クラスの外側で行います。</target>
        </trans-unit>
        <trans-unit id="90a0a5f9a35ae3ea0a297068e4b1bab795815fcf" translate="yes" xml:space="preserve">
          <source>The sequences &lt;code&gt;\a&lt;/code&gt;, &lt;code&gt;\c&lt;/code&gt;, &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, and &lt;code&gt;\x&lt;/code&gt; are also special and have the same meanings as they do outside a bracketed character class.</source>
          <target state="translated">シーケンス &lt;code&gt;\a&lt;/code&gt; 、 &lt;code&gt;\c&lt;/code&gt; 、 &lt;code&gt;\e&lt;/code&gt; 、 &lt;code&gt;\f&lt;/code&gt; 、 &lt;code&gt;\n&lt;/code&gt; 、 &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; 、 &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt; 、 &lt;code&gt;\r&lt;/code&gt; 、 &lt;code&gt;\t&lt;/code&gt; 、および &lt;code&gt;\x&lt;/code&gt; も特殊であり、それらと同じ意味を持ちます。括弧で囲まれた文字クラスの外側で実行します。</target>
        </trans-unit>
        <trans-unit id="899a56478deaf614d4bf9d04537d9557616e32cf" translate="yes" xml:space="preserve">
          <source>The serialized structure will include a &lt;code&gt;x_serialization_backend&lt;/code&gt; entry giving the package and version used to serialize. Any existing key in the given &lt;code&gt;$meta&lt;/code&gt; object will be clobbered.</source>
          <target state="translated">シリアル化された構造には、 &lt;code&gt;x_serialization_backend&lt;/code&gt; 使用されるパッケージとバージョンを示すx_serialization_backendエントリが含まれます。指定された &lt;code&gt;$meta&lt;/code&gt; オブジェクトの既存のキーはすべて破棄されます。</target>
        </trans-unit>
        <trans-unit id="0d53186f69243fe4e7fc81db07bccfc51f977e9e" translate="yes" xml:space="preserve">
          <source>The serializing hook, called on the object during serialization. It can be inherited, or defined in the class itself, like any other method.</source>
          <target state="translated">シリアライズ中にオブジェクト上で呼び出されるシリアライズフック。他のメソッドのように継承することもできますし、クラス自体で定義することもできます。</target>
        </trans-unit>
        <trans-unit id="4e9ebcecc7a860f145ea8f9108514a4fa8316dfb" translate="yes" xml:space="preserve">
          <source>The service name supplied to getaddrinfo() is not available for the socket type given in the $hints.</source>
          <target state="translated">getaddrinfo()に与えられたサービス名は、$hints で指定されたソケットタイプでは利用できません。</target>
        </trans-unit>
        <trans-unit id="ba23ccf9d34101355ab34a3727e24a0a0f7b250a" translate="yes" xml:space="preserve">
          <source>The services a piece of code promises to provide forever, in contrast to its &lt;b&gt;implementation&lt;/b&gt;, which it should feel free to change whenever it likes.</source>
          <target state="translated">コードの一部が永久に提供することを約束しているサービスは、その&lt;b&gt;実装&lt;/b&gt;とは対照的に、好きなときにいつでも自由に変更できるはずです。</target>
        </trans-unit>
        <trans-unit id="32c78a4d560dbf4474d5f3b5cef5e0e631bdf4c5" translate="yes" xml:space="preserve">
          <source>The set is specified as a list of characters, or as a range of characters where the beginning and end of the range are separated by a minus (or dash) character, or as any combination of lists and ranges. The dash can also be included in the set as a character it if is the beginning or end of the set. This set is enclosed in square brackets. The close square bracket &lt;code&gt;]&lt;/code&gt; may be used in a set if it is the first character in the set.</source>
          <target state="translated">セットは、文字のリスト、または範囲の先頭と末尾がマイナス（またはダッシュ）文字で区切られている文字の範囲、またはリストと範囲の任意の組み合わせとして指定されます。ダッシュは、セットの先頭または末尾の場合、文字itとしてセットに含めることもできます。このセットは角括弧で囲まれています。角かっこ &lt;code&gt;]&lt;/code&gt; がセットの最初の文字である場合は、セットで使用できます。</target>
        </trans-unit>
        <trans-unit id="271c11282a628a982454242ec29109ed2ea23f1d" translate="yes" xml:space="preserve">
          <source>The set of characters that are deemed whitespace are those that Unicode calls &quot;Pattern White Space&quot;, namely:</source>
          <target state="translated">ホワイトスペースとみなされる文字のセットは、ユニコードが「パターン・ホワイトスペース」と呼んでいる文字、すなわちホワイトスペースです。</target>
        </trans-unit>
        <trans-unit id="5e7d4549f7a90817f3e92cc9271f629864ca580a" translate="yes" xml:space="preserve">
          <source>The setlocale function</source>
          <target state="translated">setlocale関数</target>
        </trans-unit>
        <trans-unit id="6cd53441a7a72535c4ff8e055f31a3a3fc042379" translate="yes" xml:space="preserve">
          <source>The setting of subroutine attributes happens at compile time. Variable attributes in &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declarations are also applied at compile time. However, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables get their attributes applied at run-time. This means that you have to</source>
          <target state="translated">サブルーチン属性の設定はコンパイル時に行われます。変数属性は &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; 宣言はまた、コンパイル時に適用されます。ただし、 &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; 変数は実行時に属性が適用されます。これはあなたがしなければならないことを意味します</target>
        </trans-unit>
        <trans-unit id="229ecae54cd846eee20b1cbee543175ec9cd197e" translate="yes" xml:space="preserve">
          <source>The setting of subroutine attributes happens at compile time. Variable attributes in &lt;code&gt;our&lt;/code&gt; declarations are also applied at compile time. However, &lt;code&gt;my&lt;/code&gt; variables get their attributes applied at run-time. This means that you have to</source>
          <target state="translated">サブルーチン属性の設定は、コンパイル時に行われます。変数属性は &lt;code&gt;our&lt;/code&gt; 宣言はまた、コンパイル時に適用されます。ただし、 &lt;code&gt;my&lt;/code&gt; 変数は実行時に属性が適用されます。これはあなたがしなければならないことを意味します</target>
        </trans-unit>
        <trans-unit id="ab1edc3ed4db36281da6290a4a02b6bb1d2f2a9a" translate="yes" xml:space="preserve">
          <source>The seven routines are:</source>
          <target state="translated">7つのルーティンがあります。</target>
        </trans-unit>
        <trans-unit id="7db711982141cfb12b9e3602192ccba86ac4d921" translate="yes" xml:space="preserve">
          <source>The sheet</source>
          <target state="translated">シート</target>
        </trans-unit>
        <trans-unit id="67100f7fba2fe91ac3115331e86988966a0f9ad9" translate="yes" xml:space="preserve">
          <source>The shell offers to run in</source>
          <target state="translated">シェルは</target>
        </trans-unit>
        <trans-unit id="d2a4c575dba49342e824220d900f0c783780f4b9" translate="yes" xml:space="preserve">
          <source>The shell's &lt;code&gt;test&lt;/code&gt; uses &quot;=&quot;, &quot;!=&quot;, &quot;&amp;lt;&quot; etc for string comparisons and &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot; etc for numeric comparisons. This is the reverse of Perl, which uses &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; for string comparisons, and &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; etc for numeric comparisons.</source>
          <target state="translated">シェルの &lt;code&gt;test&lt;/code&gt; は、文字列比較に「=」、「！=」、「&amp;lt;」などを使用し、数値比較に「-eq」、「-ne」、「-lt」などを使用します。これはPerlの逆で、文字列比較には &lt;code&gt;eq&lt;/code&gt; 、 &lt;code&gt;ne&lt;/code&gt; 、 &lt;code&gt;lt&lt;/code&gt; 、数値比較には &lt;code&gt;==&lt;/code&gt; 、 &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; などを使用します。</target>
        </trans-unit>
        <trans-unit id="a4421a2ab5bd2e622c5d0a683eecbd4f08bbe24b" translate="yes" xml:space="preserve">
          <source>The shell's &lt;code&gt;test&lt;/code&gt; uses &quot;=&quot;, &quot;!=&quot;, &quot;&amp;lt;&quot; etc for string comparisons and &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot; etc for numeric comparisons. This is the reverse of Perl, which uses &lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt; for string comparisons, and &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; etc for numeric comparisons.</source>
          <target state="translated">シェルの &lt;code&gt;test&lt;/code&gt; は、文字列の比較に「=」、「！=」、「&amp;lt;」などを使用し、数値の比較に「-eq」、「-ne」、「-lt」などを使用します。これはPerlの逆であり、文字列の比較に &lt;code&gt;eq&lt;/code&gt; 、 &lt;code&gt;ne&lt;/code&gt; 、 &lt;code&gt;lt&lt;/code&gt; を使用し、数値の比較に &lt;code&gt;==&lt;/code&gt; 、 &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; などを使用します。</target>
        </trans-unit>
        <trans-unit id="fe36cec28443e99377776c6efc56682531e56f06" translate="yes" xml:space="preserve">
          <source>The short answer is that by default Perl compares equivalence (&lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; ) based only on code points of the characters. In the above case, the answer is no (because 0x00C1 != 0x0041). But sometimes, any CAPITAL LETTER A's should be considered equal, or even A's of any case.</source>
          <target state="translated">短い答えは、デフォルトではPerl は文字のコードポイントのみに基づいて等価（ &lt;code&gt;eq&lt;/code&gt; 、 &lt;code&gt;ne&lt;/code&gt; ）を比較するということです。上記の場合、答えはノーです（0x00C1！= 0x0041のため）。しかし、時々、大文字のAは等しいと見なされるべきです。</target>
        </trans-unit>
        <trans-unit id="84602cf60297d60acdefd80efdd1c60462b73b9b" translate="yes" xml:space="preserve">
          <source>The short answer is that by default Perl compares equivalence (&lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt;) based only on code points of the characters. In the above case, the answer is no (because 0x00C1 != 0x0041). But sometimes, any CAPITAL LETTER A's should be considered equal, or even A's of any case.</source>
          <target state="translated">簡単な答えは、デフォルトでは、Perlは文字のコードポイントのみに基づいて同等性（ &lt;code&gt;eq&lt;/code&gt; 、 &lt;code&gt;ne&lt;/code&gt; ）を比較するということです。上記の場合、答えはノーです（0x00C1！= 0x0041のため）。ただし、大文字のAは等しいと見なされる場合があり、場合によってはAと見なされることもあります。</target>
        </trans-unit>
        <trans-unit id="b57501930c25501b20f82b569d1ea16761a497e6" translate="yes" xml:space="preserve">
          <source>The short answer is that by default, Perl compares strings (&lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; ) based only on the code points of the characters. In the above case, the answer is &quot;after&quot;, since &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; .</source>
          <target state="translated">短い答えは、デフォルトでは、Perl は文字のコードポイントのみに基づいて文字列（ &lt;code&gt;lt&lt;/code&gt; 、 &lt;code&gt;le&lt;/code&gt; 、 &lt;code&gt;cmp&lt;/code&gt; 、 &lt;code&gt;ge&lt;/code&gt; 、 &lt;code&gt;gt&lt;/code&gt; ）を比較するということです。上記の場合、 &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; なので、答えは「後」です。</target>
        </trans-unit>
        <trans-unit id="d67ccb6666f81cda59931fcf7ad032ead024bc41" translate="yes" xml:space="preserve">
          <source>The short answer is that by default, Perl compares strings (&lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt;, &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;ge&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;) based only on the code points of the characters. In the above case, the answer is &quot;after&quot;, since &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt;.</source>
          <target state="translated">簡単に言うと、Perlはデフォルトで、文字のコードポイントのみに基づいて文字列（ &lt;code&gt;lt&lt;/code&gt; 、 &lt;code&gt;le&lt;/code&gt; 、 &lt;code&gt;cmp&lt;/code&gt; 、 &lt;code&gt;ge&lt;/code&gt; 、 &lt;code&gt;gt&lt;/code&gt; ）を比較します。上記の場合、 &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; であるため、答えは「後」です。</target>
        </trans-unit>
        <trans-unit id="ace0e0cec639bb708cb2cf532e982971dd3748da" translate="yes" xml:space="preserve">
          <source>The short name of the general category of</source>
          <target state="translated">の一般的なカテゴリーの略称です。</target>
        </trans-unit>
        <trans-unit id="02c6ec10d109a1b719286e329258adf56d502cef" translate="yes" xml:space="preserve">
          <source>The short story</source>
          <target state="translated">短編小説</target>
        </trans-unit>
        <trans-unit id="eb4d2d85d25fb4d71e2225f2e7a3eb6515112128" translate="yes" xml:space="preserve">
          <source>The short story is that you should probably only use defined on scalars or functions, not on aggregates (arrays and hashes). See &lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; in the 5.004 release or later of Perl for more detail.</source>
          <target state="translated">要するに、おそらくスカラーまたは関数で定義されたもののみを使用し、集計（配列およびハッシュ）では使用しないでください。詳細については、Perlの5.004以降のリリースで&lt;a href=&quot;functions/defined&quot;&gt;定義さ&lt;/a&gt;れているを参照してください。</target>
        </trans-unit>
        <trans-unit id="53f5dab7a291daa9043df504d583260ae569f535" translate="yes" xml:space="preserve">
          <source>The short story is that you should probably only use defined on scalars or functions, not on aggregates (arrays and hashes). See &lt;a href=&quot;perlfunc#defined&quot;&gt;&quot;defined&quot; in perlfunc&lt;/a&gt; in the 5.004 release or later of Perl for more detail.</source>
          <target state="translated">簡単に言うと、集約（配列とハッシュ）ではなく、スカラーまたは関数で定義されたもののみを使用する必要があるということです。詳細については、Perlの5.004リリース以降の&lt;a href=&quot;perlfunc#defined&quot;&gt;perlfuncの「定義済み」を&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="be047f864fccecb4801e21c3ca26d33faa969dbf" translate="yes" xml:space="preserve">
          <source>The sign &lt;code&gt;/^[+-]$/&lt;/code&gt; is stored separately. The string 'NaN' is used to represent the result when input arguments are not numbers, as well as the result of dividing by zero.</source>
          <target state="translated">記号 &lt;code&gt;/^[+-]$/&lt;/code&gt; は個別に保存されます。文字列 'NaN'は、入力引数が数値ではない場合の結果と、ゼロで除算した結果を表すために使用されます。</target>
        </trans-unit>
        <trans-unit id="5d535efa9748a7b51984807c3b0e47062fc14e19" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf' and stored separately. You can access it with the sign() method.</source>
          <target state="translated">符号は '+'、'-'、'NaN'、'+inf'、'-inf' のいずれかで、別々に格納されます。sign()メソッドでアクセスできます。</target>
        </trans-unit>
        <trans-unit id="be8bba598ba0bfbad37b038eb92c99bbb5b687ac" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'.</source>
          <target state="translated">符号は、'+'、'-'、'NaN'、'+inf'または'-inf'のいずれかである。</target>
        </trans-unit>
        <trans-unit id="32ee9fc8e75a1189426734a34b70183ae0bf5e08" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'. You can access it with the sign() method.</source>
          <target state="translated">符号は '+'、'-'、'NaN'、'+inf' または '-inf' のいずれかです。sign()メソッドでアクセスできます。</target>
        </trans-unit>
        <trans-unit id="11646904ceab245420048654e9bde4a41bb7ec59" translate="yes" xml:space="preserve">
          <source>The signal Exec signal mask</source>
          <target state="translated">信号 Exec 信号マスク</target>
        </trans-unit>
        <trans-unit id="104ebb4db613ce634a3b75383995774c2e797f04" translate="yes" xml:space="preserve">
          <source>The signature declares lexical variables that are in scope for the block. When the subroutine is called, the signature takes control first. It populates the signature variables from the list of arguments that were passed. If the argument list doesn't meet the requirements of the signature, then it will throw an exception. When the signature processing is complete, control passes to the block.</source>
          <target state="translated">シグネチャは、ブロックのスコープ内にある語彙変数を宣言します。サブルーチンが呼び出されると、シグネチャが最初に制御を行います。それは、渡された引数のリストからシグネチャ変数を生成します。引数リストがシグネチャの要件を満たさない場合は、例外をスローします。シグネチャの処理が完了すると、制御はブロックに渡されます。</target>
        </trans-unit>
        <trans-unit id="1d781ab42c79199084a9c305d1ab2ed6d80e787b" translate="yes" xml:space="preserve">
          <source>The signature is part of a subroutine's body. Normally the body of a subroutine is simply a braced block of code, but when using a signature, the signature is a parenthesised list that goes immediately before the block, after any name or attributes.</source>
          <target state="translated">シグネチャはサブルーチンのボディの一部です。通常、サブルーチンのボディは単に中括弧で囲まれたコードブロックですが、シグネチャを使用する場合、シグネチャはブロックの直前、名前や属性の後に括弧で囲まれたリストになります。</target>
        </trans-unit>
        <trans-unit id="d68142e064ec1d6e704c7c13d44f8b02e77345ce" translate="yes" xml:space="preserve">
          <source>The signature is part of a subroutine's body. Normally the body of a subroutine is simply a braced block of code. When using a signature, the signature is a parenthesised list that goes immediately after the subroutine name. The signature declares lexical variables that are in scope for the block. When the subroutine is called, the signature takes control first. It populates the signature variables from the list of arguments that were passed. If the argument list doesn't meet the requirements of the signature, then it will throw an exception. When the signature processing is complete, control passes to the block.</source>
          <target state="translated">シグネチャはサブルーチンのボディの一部です。通常、サブルーチンの本文は単に中括弧で囲まれたコードブロックです。シグネチャを使用する場合、シグネチャはサブルーチン名の直後に括弧で囲まれたリストになります。シグネチャはブロックのスコープ内にある語彙変数を宣言します。サブルーチンが呼び出されると、シグネチャが最初に制御を行います。それは渡された引数のリストからシグネチャ変数を生成します。引数リストがシグネチャの要件を満たさない場合は、例外をスローします。シグネチャの処理が完了すると、制御はブロックに渡されます。</target>
        </trans-unit>
        <trans-unit id="8bf79dd34df166da1a0a362d8a7c14bc52139481" translate="yes" xml:space="preserve">
          <source>The signatures feature is experimental</source>
          <target state="translated">シグネチャーの特徴は実験的</target>
        </trans-unit>
        <trans-unit id="ebf9d6090863be01051258238bf3ef2c8b46c7c9" translate="yes" xml:space="preserve">
          <source>The significance of each of these will be explained in the rest of the tutorial, but for now, it is important only to know that a metacharacter can be matched as-is by putting a backslash before it:</source>
          <target state="translated">これらのそれぞれの意味はチュートリアルの残りの部分で説明しますが、今のところ、メタ文字の前にバックスラッシュを付けることで、メタ文字をそのままマッチさせることができるということだけは知っておくことが重要です。</target>
        </trans-unit>
        <trans-unit id="2444d6c2a6baf7e1580c4abcb9b61735a0532f35" translate="yes" xml:space="preserve">
          <source>The significance of each of these will be explained in the rest of the tutorial, but for now, it is important only to know that a metacharacter can be matched by putting a backslash before it:</source>
          <target state="translated">それぞれの意味はチュートリアルの残りの部分で説明しますが、今のところ、メタ文字の前にバックスラッシュを付けることでメタ文字を一致させることができるということだけは知っておくことが重要です。</target>
        </trans-unit>
        <trans-unit id="d05188639d7fd13d368b039de9eab91f22380450" translate="yes" xml:space="preserve">
          <source>The similarly named property, &lt;code&gt;\p{Punct}&lt;/code&gt; , matches a somewhat different set in the ASCII range, namely &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; . That is, it is missing the nine characters &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; . This is because Unicode splits what POSIX considers to be punctuation into two categories, Punctuation and Symbols.</source>
          <target state="translated">同様に名前が付けられたプロパティ &lt;code&gt;\p{Punct}&lt;/code&gt; は、ASCII範囲のやや異なるセット、つまり &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; に一致します。つまり、9文字の &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; が欠落しているのは、POSIXが句読点と見なすものをUnicodeが2つのカテゴリ、句読点と記号に分割しているためです。</target>
        </trans-unit>
        <trans-unit id="8cd091ac264b3ba5cf264f4cd380086afff2aabf" translate="yes" xml:space="preserve">
          <source>The similarly named property, &lt;code&gt;\p{Punct}&lt;/code&gt;, matches a somewhat different set in the ASCII range, namely &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt;. That is, it is missing the nine characters &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt;. This is because Unicode splits what POSIX considers to be punctuation into two categories, Punctuation and Symbols.</source>
          <target state="translated">同様の名前のプロパティ &lt;code&gt;\p{Punct}&lt;/code&gt; は、ASCII範囲の多少異なるセット、つまり &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; と一致します。つまり、9文字 &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; が欠落しています。これは、UnicodeがPOSIXが句読点と見なすものを句読点と記号の2つのカテゴリに分割するためです。</target>
        </trans-unit>
        <trans-unit id="a851643ae5a58ccc6f3ce68bfdab3a7ef68d1794" translate="yes" xml:space="preserve">
          <source>The simple rule is: Inheritance will not work when autoloading non-methods. The simple fix for old code is: In any module that used to depend on inheriting &lt;code&gt;AUTOLOAD&lt;/code&gt; for non-methods from a base class named &lt;code&gt;BaseClass&lt;/code&gt; , execute &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; during startup.</source>
          <target state="translated">単純なルールは次のとおりです。非メソッドをオートロードする場合、継承は機能しません。古いコードの簡単な修正は次のとおりです &lt;code&gt;BaseClass&lt;/code&gt; という名前の基本クラスからの非メソッドの &lt;code&gt;AUTOLOAD&lt;/code&gt; の継承に依存していたモジュールでは、起動時に &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; 実行します。</target>
        </trans-unit>
        <trans-unit id="145065cb1f22a69e2ed6682015cb7947554b75d7" translate="yes" xml:space="preserve">
          <source>The simple rule is: Inheritance will not work when autoloading non-methods. The simple fix for old code is: In any module that used to depend on inheriting &lt;code&gt;AUTOLOAD&lt;/code&gt; for non-methods from a base class named &lt;code&gt;BaseClass&lt;/code&gt;, execute &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; during startup.</source>
          <target state="translated">単純なルールは次のとおりです。非メソッドを自動ロードする場合、継承は機能しません。古いコードの簡単な修正は次のとおりです &lt;code&gt;BaseClass&lt;/code&gt; という名前の基本クラスから非メソッドの &lt;code&gt;AUTOLOAD&lt;/code&gt; を継承することに依存していたモジュールでは、起動時に &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; 実行します。</target>
        </trans-unit>
        <trans-unit id="f5af89b6d15a00a979315dfddae0b5f323e4af12" translate="yes" xml:space="preserve">
          <source>The simple rule to remember, if you want to match a literal &lt;code&gt;{&lt;/code&gt; character (U+007B &lt;code&gt;LEFT CURLY BRACKET&lt;/code&gt;) in a regular expression pattern, is to escape each literal instance of it in some way. Generally easiest is to precede it with a backslash, like &lt;code&gt;\{&lt;/code&gt; or enclose it in square brackets (&lt;code&gt;[{]&lt;/code&gt;). If the pattern delimiters are also braces, any matching right brace (&lt;code&gt;}&lt;/code&gt;) should also be escaped to avoid confusing the parser, for example,</source>
          <target state="translated">正規表現パターンでリテラル &lt;code&gt;{&lt;/code&gt; 文字（U + 007B &lt;code&gt;LEFT CURLY BRACKET&lt;/code&gt; ）を照合する場合、覚えておくべき簡単なルールは、その各リテラルインスタンスを何らかの方法でエスケープすることです。一般的に最も簡単なのは、 &lt;code&gt;\{&lt;/code&gt; ように円記号を前に付けるか、角かっこ（ &lt;code&gt;[{]&lt;/code&gt; ）で囲むことです。パターン区切り文字も中括弧である場合、パーサーを混乱させないように、一致する右中括弧（ &lt;code&gt;}&lt;/code&gt; ）もエスケープする必要があります。</target>
        </trans-unit>
        <trans-unit id="41d909120b343bfa9af89dc978321448d395292c" translate="yes" xml:space="preserve">
          <source>The simple stdio implementation creates the files</source>
          <target state="translated">シンプルなstdioの実装では</target>
        </trans-unit>
        <trans-unit id="f2a9e9b7a3c97685eea0b1595b9417bb605f6809" translate="yes" xml:space="preserve">
          <source>The simplest XSUBs consist of 3 parts: a description of the return value, the name of the XSUB routine and the names of its arguments, and a description of types or formats of the arguments.</source>
          <target state="translated">最も単純なXSUBは3つの部分から構成されています:戻り値の説明、XSUBルーチンの名前とその引数の名前、引数の型や形式の説明です。</target>
        </trans-unit>
        <trans-unit id="5cfe5e43e01ddc5838feef9195e0126bb74ada96" translate="yes" xml:space="preserve">
          <source>The simplest case is integers. These consist of a sequence of digits, with an optional sign in front. The digits we can represent with &lt;code&gt;\d+&lt;/code&gt; and the sign can be matched with &lt;code&gt;[+-]&lt;/code&gt; . Thus the integer regexp is</source>
          <target state="translated">最も単純なケースは整数です。これらは一連の数字で構成され、前にオプションの記号が付いています。 &lt;code&gt;\d+&lt;/code&gt; 表すことができる数字と符号は &lt;code&gt;[+-]&lt;/code&gt; と一致させることができます。したがって、整数正規表現は</target>
        </trans-unit>
        <trans-unit id="16ed7663dd31b0d719b95952e4dbcc002ac1e075" translate="yes" xml:space="preserve">
          <source>The simplest case is integers. These consist of a sequence of digits, with an optional sign in front. The digits we can represent with &lt;code&gt;\d+&lt;/code&gt; and the sign can be matched with &lt;code&gt;[+-]&lt;/code&gt;. Thus the integer regexp is</source>
          <target state="translated">最も単純なケースは整数です。これらは一連の数字で構成され、前にオプションの記号が付いています。 &lt;code&gt;\d+&lt;/code&gt; 表すことができる数字と、 &lt;code&gt;[+-]&lt;/code&gt; で符号を一致させることができます。したがって、整数の正規表現は</target>
        </trans-unit>
        <trans-unit id="f5ce4a00629ba2eb87550ae04e313683cd18e39d" translate="yes" xml:space="preserve">
          <source>The simplest format for a Version Range is just the version number itself, e.g. &lt;code&gt;2.4&lt;/code&gt;. This means that &lt;b&gt;at least&lt;/b&gt; version 2.4 must be present. To indicate that &lt;b&gt;any&lt;/b&gt; version of a prerequisite is okay, even if the prerequisite doesn't define a version at all, use the version &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">バージョン範囲の最も単純な形式は、バージョン番号自体です（例： &lt;code&gt;2.4&lt;/code&gt; )。これは、&lt;b&gt;少なくとも&lt;/b&gt;バージョン2.4が存在する必要があること&lt;b&gt;を&lt;/b&gt;意味します。前提条件の&lt;b&gt;どの&lt;/b&gt;バージョンでも問題がないことを示すには、前提条件でバージョンがまったく定義されていない場合でも、バージョン &lt;code&gt;0&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="205579583087d3f83514fed292a979acc1fd2056" translate="yes" xml:space="preserve">
          <source>The simplest format for a version specification is just the version number itself, e.g. &lt;code&gt;2.4&lt;/code&gt;. This means that &lt;b&gt;at least&lt;/b&gt; version 2.4 must be present. To indicate that &lt;b&gt;any&lt;/b&gt; version of a prerequisite is okay, even if the prerequisite doesn't define a version at all, use the version &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">バージョン仕様の最も単純な形式は、バージョン番号自体です（例： &lt;code&gt;2.4&lt;/code&gt; )。これは、&lt;b&gt;少なくとも&lt;/b&gt;バージョン2.4が存在する必要があること&lt;b&gt;を&lt;/b&gt;意味します。前提条件の&lt;b&gt;どの&lt;/b&gt;バージョンでも問題がないことを示すには、前提条件でバージョンがまったく定義されていない場合でも、バージョン &lt;code&gt;0&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="90f647a57152f0376dead3744742f9e10945d73a" translate="yes" xml:space="preserve">
          <source>The simplest method uses the &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. It can pad on the left or right with blanks and on the left with zeroes and it will not truncate the result. The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function can only pad strings on the right with blanks and it will truncate the result to a maximum length of &lt;code&gt;$pad_len&lt;/code&gt; .</source>
          <target state="translated">最も簡単な方法は、 &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; 関数を使用することです。左側または右側をブランクで埋め、左側をゼロで埋めることができ、結果を切り捨てません。 &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; 機能は、パッドの右側にブランクが文字列と、それは、最大長に結果が切り捨てられますすることができます &lt;code&gt;$pad_len&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60ef9faadf39e8b6092ce866661076ad7721c8c1" translate="yes" xml:space="preserve">
          <source>The simplest method uses the &lt;code&gt;sprintf&lt;/code&gt; function. It can pad on the left or right with blanks and on the left with zeroes and it will not truncate the result. The &lt;code&gt;pack&lt;/code&gt; function can only pad strings on the right with blanks and it will truncate the result to a maximum length of &lt;code&gt;$pad_len&lt;/code&gt;.</source>
          <target state="translated">最も簡単な方法は、 &lt;code&gt;sprintf&lt;/code&gt; 関数を使用します。左側または右側を空白で埋め、左側をゼロで埋めることができ、結果が切り捨てられることはありません。 &lt;code&gt;pack&lt;/code&gt; 機能は、パッドの右側にブランクが文字列と、それは、最大長に結果が切り捨てられますすることができます &lt;code&gt;$pad_len&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc3e208a9819c2ed872df1040ec4eed39730cc50" translate="yes" xml:space="preserve">
          <source>The simplest regex is simply a word, or more generally, a string of characters. A regex consisting of a word matches any string that contains that word:</source>
          <target state="translated">最も単純な正規表現は、単に単語、またはより一般的には文字列です。単語からなる正規表現は、その単語を含む文字列にマッチします。</target>
        </trans-unit>
        <trans-unit id="e7349953e0f225a36578668e9ad5be25a2093d5b" translate="yes" xml:space="preserve">
          <source>The simplest regexp is simply a word, or more generally, a string of characters. A regexp consisting of a word matches any string that contains that word:</source>
          <target state="translated">最も単純な正規表現は、単に単語、あるいはより一般的には文字列です。単語からなる正規表現は、その単語を含む文字列にマッチします。</target>
        </trans-unit>
        <trans-unit id="0eaf5ad324e3121e2a83d8b08987e28055dbf879" translate="yes" xml:space="preserve">
          <source>The simplest regexp is simply a word, or more generally, a string of characters. A regexp consisting of just a word matches any string that contains that word:</source>
          <target state="translated">最も単純な正規表現は、単に単語、より一般的には文字列です。単語だけで構成される正規表現は、その単語を含む文字列にマッチします。</target>
        </trans-unit>
        <trans-unit id="f93ecdae42936826d9c1b25b5229a95d439104b0" translate="yes" xml:space="preserve">
          <source>The simplest style of bundling can be enabled with:</source>
          <target state="translated">最もシンプルなスタイルのバンドルを有効にすることができます。</target>
        </trans-unit>
        <trans-unit id="7cd479644d912e323fa369ec3403c930944ff04b" translate="yes" xml:space="preserve">
          <source>The simplest two-level data structure to build in Perl is an array of arrays, sometimes casually called a list of lists. It's reasonably easy to understand, and almost everything that applies here will also be applicable later on with the fancier data structures.</source>
          <target state="translated">Perlで構築する最も単純な2レベルのデータ構造は、配列の配列であり、時にはリストのリストと呼ばれることもあります。理解するのは比較的簡単で、ここで適用されるほとんどすべてのことは、後になってより高度なデータ構造にも適用されるようになります。</target>
        </trans-unit>
        <trans-unit id="6e9b91e3cec9f10bb3ce35088b75f0be6c8e9b0d" translate="yes" xml:space="preserve">
          <source>The simplest type of op structure is &lt;code&gt;OP&lt;/code&gt; : this has no children. Unary operators, &lt;code&gt;UNOP&lt;/code&gt; s, have one child, and this is pointed to by the &lt;code&gt;op_first&lt;/code&gt; field. Binary operators (&lt;code&gt;BINOP&lt;/code&gt; s) have not only an &lt;code&gt;op_first&lt;/code&gt; field but also an &lt;code&gt;op_last&lt;/code&gt; field. The most complex type of op is a &lt;code&gt;LISTOP&lt;/code&gt; , which has any number of children. In this case, the first child is pointed to by &lt;code&gt;op_first&lt;/code&gt; and the last child by &lt;code&gt;op_last&lt;/code&gt; . The children in between can be found by iteratively following the &lt;code&gt;OpSIBLING&lt;/code&gt; pointer from the first child to the last (but see below).</source>
          <target state="translated">op構造の最も単純なタイプは &lt;code&gt;OP&lt;/code&gt; です。これには子がありません。単項演算子 &lt;code&gt;UNOP&lt;/code&gt; には1つの子があり、これは &lt;code&gt;op_first&lt;/code&gt; フィールドによってポイントされます。バイナリ演算子（ &lt;code&gt;BINOP&lt;/code&gt; S）だけでなく、持っている &lt;code&gt;op_first&lt;/code&gt; フィールドだけでなく、 &lt;code&gt;op_last&lt;/code&gt; フィールドを。最も複雑なタイプのopは &lt;code&gt;LISTOP&lt;/code&gt; であり、任意の数の子を持ちます。この場合、最初の子は &lt;code&gt;op_first&lt;/code&gt; によってポイントされ、最後の子は &lt;code&gt;op_last&lt;/code&gt; によってポイントされます。中間の子は、最初の子から最後の子まで &lt;code&gt;OpSIBLING&lt;/code&gt; ポインターを反復的にたどることによって見つけることができます（ただし、以下を参照）。</target>
        </trans-unit>
        <trans-unit id="ffb373ae1dc958f6e57c2a91fb253380e617f734" translate="yes" xml:space="preserve">
          <source>The simplest type of op structure is &lt;code&gt;OP&lt;/code&gt;: this has no children. Unary operators, &lt;code&gt;UNOP&lt;/code&gt;s, have one child, and this is pointed to by the &lt;code&gt;op_first&lt;/code&gt; field. Binary operators (&lt;code&gt;BINOP&lt;/code&gt;s) have not only an &lt;code&gt;op_first&lt;/code&gt; field but also an &lt;code&gt;op_last&lt;/code&gt; field. The most complex type of op is a &lt;code&gt;LISTOP&lt;/code&gt;, which has any number of children. In this case, the first child is pointed to by &lt;code&gt;op_first&lt;/code&gt; and the last child by &lt;code&gt;op_last&lt;/code&gt;. The children in between can be found by iteratively following the &lt;code&gt;OpSIBLING&lt;/code&gt; pointer from the first child to the last (but see below).</source>
          <target state="translated">最も単純なタイプのop構造は &lt;code&gt;OP&lt;/code&gt; です。これには子がありません。単項演算子 &lt;code&gt;UNOP&lt;/code&gt; には子が1つあり、これは &lt;code&gt;op_first&lt;/code&gt; フィールドによって示されます。バイナリ演算子（ &lt;code&gt;BINOP&lt;/code&gt; S）だけでなく、持っている &lt;code&gt;op_first&lt;/code&gt; フィールドだけでなく、 &lt;code&gt;op_last&lt;/code&gt; フィールドを。最も複雑なタイプのopは &lt;code&gt;LISTOP&lt;/code&gt; であり、これには任意の数の子があります。この場合、最初の子は &lt;code&gt;op_first&lt;/code&gt; によってポイントされ、最後の子は &lt;code&gt;op_last&lt;/code&gt; によってポイントされます。間にある子は、最初の子から最後の子まで &lt;code&gt;OpSIBLING&lt;/code&gt; ポインターを繰り返したどることで見つけることができます（ただし、以下を参照）。</target>
        </trans-unit>
        <trans-unit id="48570eadf16f561f7ed2c5fd05e1b77f1b97a0a9" translate="yes" xml:space="preserve">
          <source>The simplest way to build up a decent testing suite is to just test what the manual says it does. [3] Let's pull something out of the &lt;a href=&quot;Date::ICal#SYNOPSIS&quot;&gt;&quot;SYNOPSIS&quot; in Date::ICal&lt;/a&gt; and test that all its bits work.</source>
          <target state="translated">まともなテストスイートを構築する最も簡単な方法は、マニュアルに書かれていることをテストすることです。[3] &lt;a href=&quot;Date::ICal#SYNOPSIS&quot;&gt;Date :: ICalの「SYNOPSIS」&lt;/a&gt;から何かを引き出して、そのすべてのビットが機能することをテストしてみましょう。</target>
        </trans-unit>
        <trans-unit id="2054b09e7b3505e051c925e118baa9402ac5d4ec" translate="yes" xml:space="preserve">
          <source>The simplest way to do this is:</source>
          <target state="translated">一番簡単な方法は</target>
        </trans-unit>
        <trans-unit id="388dab005124e81f16d269b4ee944aa3b8003908" translate="yes" xml:space="preserve">
          <source>The simplest way to use this library is to import the md5_hex() function (or one of its cousins):</source>
          <target state="translated">このライブラリを使用する最も単純な方法は、md5_hex()関数 (またはそのいとこ)をインポートすることです。</target>
        </trans-unit>
        <trans-unit id="5ecd63cfa076538859f9d50a754ce0ea42b734ec" translate="yes" xml:space="preserve">
          <source>The simplest, most straightforward way to create a thread is with &lt;code&gt;create()&lt;/code&gt; :</source>
          <target state="translated">スレッドを作成する最も簡単で最も簡単な方法は、 &lt;code&gt;create()&lt;/code&gt; を使用することです。</target>
        </trans-unit>
        <trans-unit id="aedaa034bc02c59e2080c491aee6d14703ba3b58" translate="yes" xml:space="preserve">
          <source>The simplest, most straightforward way to create a thread is with &lt;code&gt;create()&lt;/code&gt;:</source>
          <target state="translated">スレッドを作成する最も簡単で簡単な方法は、 &lt;code&gt;create()&lt;/code&gt; を使用することです。</target>
        </trans-unit>
        <trans-unit id="142891f6dfc36054413e16ddc5cd0b102274ac48" translate="yes" xml:space="preserve">
          <source>The single parameter &lt;code&gt;cb1&lt;/code&gt; is a pointer to a function, so you must have defined &lt;code&gt;cb1&lt;/code&gt; in your code, say something like this</source>
          <target state="translated">単一のパラメータ &lt;code&gt;cb1&lt;/code&gt; は関数へのポインタなので、コードで &lt;code&gt;cb1&lt;/code&gt; を定義している必要があります。</target>
        </trans-unit>
        <trans-unit id="c390613e0b451f9ebc65ddd44ea3f2cbf88c23f5" translate="yes" xml:space="preserve">
          <source>The situation in which an &lt;b&gt;expression&lt;/b&gt; is expected by its surroundings (the code calling it) to return a list of values rather than a single value. Functions that want a</source>
          <target state="translated">&lt;b&gt;式&lt;/b&gt;がその周囲（それを呼び出すコード）によって単一の値ではなく値のリストを返すことが期待される状況。を必要とする関数</target>
        </trans-unit>
        <trans-unit id="d86701b02acab027c0d49bd429316b14b358d71d" translate="yes" xml:space="preserve">
          <source>The situation in which an &lt;b&gt;expression&lt;/b&gt; is expected by its surroundings (the code calling it) to return a single &lt;b&gt;value&lt;/b&gt; rather than a &lt;b&gt;list&lt;/b&gt; of values. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;list context&lt;/b&gt;. A scalar context sometimes imposes additional constraints on the return value&amp;mdash;see &lt;b&gt;string context&lt;/b&gt; and &lt;b&gt;numeric context&lt;/b&gt;. Sometimes we talk about a &lt;b&gt;Boolean context&lt;/b&gt; inside conditionals, but this imposes no additional constraints, since any scalar value, whether numeric or &lt;b&gt;string&lt;/b&gt;, is already true or false.</source>
          <target state="translated">&lt;b&gt;式&lt;/b&gt;がその周囲（それを呼び出すコード）によって値の&lt;b&gt;リスト&lt;/b&gt;ではなく単一の&lt;b&gt;値&lt;/b&gt;を返すことが期待される状況。&lt;b&gt;context&lt;/b&gt;および&lt;b&gt;list context&lt;/b&gt;も参照してください。スカラーコンテキストは、戻り値に追加の制約を課すことがあり&lt;b&gt;ます&lt;/b&gt;。&lt;b&gt;文字列コンテキスト&lt;/b&gt;と&lt;b&gt;数値コンテキストを&lt;/b&gt;参照してください。時々、条件&lt;b&gt;文内のブールコンテキスト&lt;/b&gt;について話しますが、数値または&lt;b&gt;文字列の&lt;/b&gt;いずれのスカラー値もすでにtrueまたはfalseであるため、追加の制約はありません。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="5bf519df1d56695e3fe7b5f2cac71014a6a10291" translate="yes" xml:space="preserve">
          <source>The situation in which an expression is expected by its surroundings (the code calling it) to return a &lt;b&gt;string&lt;/b&gt;. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;numeric context&lt;/b&gt;.</source>
          <target state="translated">式がその周囲（それを呼び出すコード）によって&lt;b&gt;文字列&lt;/b&gt;を返すことが期待される状況。&lt;b&gt;context&lt;/b&gt;と&lt;b&gt;numeric context&lt;/b&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="d5278b812a3307d0ee6951ce2678ae1eab81add9" translate="yes" xml:space="preserve">
          <source>The situation in which an expression is expected by its surroundings (the code calling it) to return a number. See also &lt;b&gt;context&lt;/b&gt; and &lt;b&gt;string context&lt;/b&gt;.</source>
          <target state="translated">式がその周囲（それを呼び出すコード）によって数値を返すことが期待される状況。&lt;b&gt;context&lt;/b&gt;および&lt;b&gt;string context&lt;/b&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="1778a01cc57bbb1bfba8f72e778c79445c3a36bf" translate="yes" xml:space="preserve">
          <source>The situation is even less clear for tools such as MakeMaker that can be used to install additional modules into non-standard places. For example, if a user intends to install a module into a private directory (perhaps by setting &lt;code&gt;PREFIX&lt;/code&gt; on the</source>
          <target state="translated">追加のモジュールを標準以外の場所にインストールするために使用できるMakeMakerなどのツールについては、状況はさらに不明確です。たとえば、ユーザーが設定することで、おそらく（プライベートディレクトリにモジュールをインストールしようとする場合 &lt;code&gt;PREFIX&lt;/code&gt; を上</target>
        </trans-unit>
        <trans-unit id="9a9c38132104cf7801e22419b38670f4a24614fb" translate="yes" xml:space="preserve">
          <source>The situation where this is necessary, is presumably quite rare.</source>
          <target state="translated">これが必要とされる状況は、推定的にはかなり稀です。</target>
        </trans-unit>
        <trans-unit id="5a9a5af0a6298739507c5ced21852b79711a0a57" translate="yes" xml:space="preserve">
          <source>The situation with matching Unicode properties in regular expressions, the &lt;code&gt;\p{}&lt;/code&gt; and &lt;code&gt;\P{}&lt;/code&gt; constructs, against these code points is not as clear cut, and how these are handled has changed as we've gained experience.</source>
          <target state="translated">これらのコードポイントに対する正規表現の &lt;code&gt;\p{}&lt;/code&gt; および &lt;code&gt;\P{}&lt;/code&gt; 構成体でのUnicodeプロパティの一致の状況はそれほど明確ではなく、これらがどのように処理されるかは、経験に応じて変更されました。</target>
        </trans-unit>
        <trans-unit id="88e6088a9ab77ba2f6a1ec54ad364f7fffa87f43" translate="yes" xml:space="preserve">
          <source>The size of the file will be determined, and sent to the server automatically for normal files so that this method need only be called if you are transferring data from a socket, named pipe, or other stream not associated with a normal file.</source>
          <target state="translated">このメソッドは、通常のファイルに関連付けられていないソケット、名前付きパイプ、またはその他のストリームからデータを転送する場合にのみ呼び出される必要があるように、ファイルのサイズが決定され、通常のファイルの場合には自動的にサーバに送信されます。</target>
        </trans-unit>
        <trans-unit id="87d9309a72cdac9a52fd9593050f47fe997d18b5" translate="yes" xml:space="preserve">
          <source>The size of the per-instance data structure, e.g.:</source>
          <target state="translated">インスタンス単位のデータ構造のサイズ、例えば</target>
        </trans-unit>
        <trans-unit id="52d0fd0e1a020955cbd4dc92e53211189e24cb93" translate="yes" xml:space="preserve">
          <source>The size of the perlXYZ.SIS is about 370 kB but once it is in the device it is about one 750 kB (according to the application manager).</source>
          <target state="translated">perlXYZ.SISのサイズは約370kBですが、デバイスに入ると約1つ750kBになります(アプリケーションマネージャによると)。</target>
        </trans-unit>
        <trans-unit id="5877446a070972ed92cd79aed206f27b2111d714" translate="yes" xml:space="preserve">
          <source>The size of the pieces you&amp;rsquo;re dealing with, mentally speaking.</source>
          <target state="translated">精神的に言えば、あなたが扱っているピースのサイズ。</target>
        </trans-unit>
        <trans-unit id="1656b4f2fdda6835a902c9679ea0caaf9c6c13e1" translate="yes" xml:space="preserve">
          <source>The size specifier &lt;code&gt;V&lt;/code&gt; has no effect for Perl code, but is supported for compatibility with XS code. It means &quot;use the standard size for a Perl integer or floating-point number&quot;, which is the default.</source>
          <target state="translated">サイズ指定子 &lt;code&gt;V&lt;/code&gt; はPerlコードには影響しませんが、XSコードとの互換性のためにサポートされています。これは、デフォルトの「Perl整数または浮動小数点数の標準サイズを使用する」ことを意味します。</target>
        </trans-unit>
        <trans-unit id="0b86c8f6fcdbd6b3e5e7fca2359cdc4a25ce8c43" translate="yes" xml:space="preserve">
          <source>The skipped prefix (i.e. the characters before the extracted string). On failure, &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">スキップされたプレフィックス（つまり、抽出された文字列の前の文字）。失敗すると、 &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="954e32bdd5f83008c8f605b9e8dd386da5c77fb4" translate="yes" xml:space="preserve">
          <source>The skipped prefix (i.e. the characters before the extracted string). On failure, &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="translated">スキップされたプレフィックス（つまり、抽出された文字列の前の文字）。失敗すると、 &lt;code&gt;undef&lt;/code&gt; が返されます。</target>
        </trans-unit>
        <trans-unit id="20ee3229175e42949ed9e43940ba571b504d8485" translate="yes" xml:space="preserve">
          <source>The slab allocator puts the ops at the end of the slab first. This will tend to allocate the leaves of the op tree first, and the layout will therefore hopefully be cache-friendly. In addition, this means that there's no need to store the size of the slab (see below on why slabs vary in size), because Perl can follow pointers to find the last op.</source>
          <target state="translated">slab アロケータは、op を最初に slab の最後に配置します。これは op ツリーの葉を最初に割り当てる傾向があり、したがってレイアウトはうまくいけばキャッシュに優しいものになります。さらに、これはスラブのサイズを保存する必要がないことを意味します(スラブのサイズが異なる理由については後述します)。</target>
        </trans-unit>
        <trans-unit id="cca8448b9d4d7f08ec6d38447f60e1a5ccb09b43" translate="yes" xml:space="preserve">
          <source>The slower but superior fixes are when you may be able to yourself fix the misconfiguration of your own environment variables. The mis(sing)configuration of the whole system's locales usually requires the help of your friendly system administrator.</source>
          <target state="translated">遅いが優れた修正は、あなた自身があなた自身の環境変数の誤設定を修正することができるかもしれないときです。システム全体のロケールの誤設定は、通常、親しみやすいシステム管理者の助けを必要とします。</target>
        </trans-unit>
        <trans-unit id="0fbe962e06d42462e7c0e18bd04f3db25354c94a" translate="yes" xml:space="preserve">
          <source>The smaller and more localized the change, the better. Similarly, a series of small patches is greatly preferred over a single large patch.</source>
          <target state="translated">変化はより小さく、より局所的であればあるほどよい。同様に、単一の大きなパッチよりも、一連の小さなパッチの方が非常に好まれます。</target>
        </trans-unit>
        <trans-unit id="f4b9fc3a5444ff6c99460c86f0eae40188849994" translate="yes" xml:space="preserve">
          <source>The smallest individual element of a string. Computers store characters as integers, but Perl lets you operate on them as text. The integer used to represent a particular character is called that character&amp;rsquo;s &lt;b&gt;codepoint&lt;/b&gt;.</source>
          <target state="translated">文字列の最小の個々の要素。コンピュータは文字を整数として保存しますが、Perlではそれらをテキストとして操作できます。特定の文字を表すために使用される整数は、その文字の&lt;b&gt;コードポイント&lt;/b&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="743692cb1b17807cb7e732ecae2c349fdebd6008" translate="yes" xml:space="preserve">
          <source>The smart match stops when it finds a match, so it doesn't have to try every expression.</source>
          <target state="translated">スマートマッチは一致するものが見つかった時点で停止するので、すべての式を試す必要はありません。</target>
        </trans-unit>
        <trans-unit id="936144db8d649469afd4d348dac4550c6a90cbd0" translate="yes" xml:space="preserve">
          <source>The smartmatch implicitly dereferences any non-blessed hash or array reference, so the &lt;code&gt;&lt;i&gt;HASH&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;&lt;i&gt;ARRAY&lt;/i&gt;&lt;/code&gt; entries apply in those cases. For blessed references, the &lt;code&gt;&lt;i&gt;Object&lt;/i&gt;&lt;/code&gt; entries apply. Smartmatches involving hashes only consider hash keys, never hash values.</source>
          <target state="translated">スマートマッチは、blessされていないハッシュまたは配列参照を暗黙的に逆参照するため、 &lt;code&gt;&lt;i&gt;HASH&lt;/i&gt;&lt;/code&gt; および &lt;code&gt;&lt;i&gt;ARRAY&lt;/i&gt;&lt;/code&gt; エントリはそれらの場合に適用されます。祝福された参照には、 &lt;code&gt;&lt;i&gt;Object&lt;/i&gt;&lt;/code&gt; エントリが適用されます。ハッシュを含むスマートマッチはハッシュキーのみを考慮し、ハッシュ値は考慮しません。</target>
        </trans-unit>
        <trans-unit id="d02f6728ba4dcd43d024dc500f10ccfe28692eeb" translate="yes" xml:space="preserve">
          <source>The smartmatch operator is most often used as the implicit operator of a &lt;code&gt;when&lt;/code&gt; clause. See the section on &quot;Switch Statements&quot; in &lt;a href=&quot;perlsyn&quot;&gt;perlsyn&lt;/a&gt;.</source>
          <target state="translated">smartmatch演算子は、 &lt;code&gt;when&lt;/code&gt; 句の暗黙的な演算子として最もよく使用されます。&lt;a href=&quot;perlsyn&quot;&gt;perlsynの&lt;/a&gt;「Switchステートメント」のセクションを参照してください。</target>
        </trans-unit>
        <trans-unit id="1dbe6ac71d39b0bf15f7bc2e7a951d76ec82915a" translate="yes" xml:space="preserve">
          <source>The socket domain will define which subclass of &lt;code&gt;IO::Socket&lt;/code&gt; to use. The two options available along with this distribution are &lt;code&gt;AF_INET&lt;/code&gt; and &lt;code&gt;AF_UNIX&lt;/code&gt;.</source>
          <target state="translated">ソケットドメインは、使用する &lt;code&gt;IO::Socket&lt;/code&gt; サブクラスを定義します。このディストリビューションで使用できる2つのオプションは、 &lt;code&gt;AF_INET&lt;/code&gt; と &lt;code&gt;AF_UNIX&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="538eac64870e76a04cefadec7560ac9099d4a644" translate="yes" xml:space="preserve">
          <source>The socket tests may fail if the network is not configured. You have to make &quot;/hurd/pfinet&quot; the translator for &quot;/servers/socket/2&quot;, giving it the right arguments. Try &quot;/hurd/pfinet --help&quot; for more information.</source>
          <target state="translated">ネットワークが設定されていない場合、ソケットテストは失敗する可能性があります。hurd/pfinet &quot;を&quot;/servers/socket/2 &quot;のトランスレータにして、正しい引数を与えなければなりません。詳細は&quot;/hurd/pfinet --help &quot;を試してみてください。</target>
        </trans-unit>
        <trans-unit id="127dbba60bbfba8c121a95d45a5b1267637cec67" translate="yes" xml:space="preserve">
          <source>The socket type (e.g. &lt;code&gt;SOCK_STREAM&lt;/code&gt; )</source>
          <target state="translated">ソケットタイプ（例： &lt;code&gt;SOCK_STREAM&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="efab1ba183171d21de2ceaf72d5458d5f4bc8140" translate="yes" xml:space="preserve">
          <source>The socket type (e.g. &lt;code&gt;SOCK_STREAM&lt;/code&gt;)</source>
          <target state="translated">ソケットタイプ（例： &lt;code&gt;SOCK_STREAM&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="da232edd2d10d943e919b3b650a030d3ad1934c2" translate="yes" xml:space="preserve">
          <source>The socket type that will be used. These are usually &lt;code&gt;SOCK_STREAM&lt;/code&gt;, &lt;code&gt;SOCK_DGRAM&lt;/code&gt;, or &lt;code&gt;SOCK_RAW&lt;/code&gt;. If this argument is left undefined an attempt will be made to infer the type from the service name.</source>
          <target state="translated">使用するソケットタイプ。これらは通常、 &lt;code&gt;SOCK_STREAM&lt;/code&gt; 、 &lt;code&gt;SOCK_DGRAM&lt;/code&gt; 、または &lt;code&gt;SOCK_RAW&lt;/code&gt; です。この引数を未定義のままにすると、サービス名からタイプを推測しようとします。</target>
        </trans-unit>
        <trans-unit id="5ab88d47102ad5dc69b949fcce35b1a58247bf52" translate="yes" xml:space="preserve">
          <source>The socket type to pass to &lt;code&gt;getaddrinfo&lt;/code&gt; (e.g. &lt;code&gt;SOCK_STREAM&lt;/code&gt;, &lt;code&gt;SOCK_DGRAM&lt;/code&gt;). Normally defined by the caller; if left undefined &lt;code&gt;getaddrinfo&lt;/code&gt; may attempt to infer the type from the service name.</source>
          <target state="translated">&lt;code&gt;getaddrinfo&lt;/code&gt; に渡すソケットタイプ（例： &lt;code&gt;SOCK_STREAM&lt;/code&gt; 、 &lt;code&gt;SOCK_DGRAM&lt;/code&gt; ）。通常、呼び出し元によって定義されます。未定義のままに &lt;code&gt;getaddrinfo&lt;/code&gt; と、getaddrinfoはサービス名からタイプを推測しようとする場合があります。</target>
        </trans-unit>
        <trans-unit id="d10c516fba6283faccc420f0f1f0ddca597fd882" translate="yes" xml:space="preserve">
          <source>The sole purpose of this module is to enable colour highlighting from the command line.</source>
          <target state="translated">このモジュールの唯一の目的は、コマンドラインからカラーハイライトを有効にすることです。</target>
        </trans-unit>
        <trans-unit id="165006648b6cdcfa730ff63bd97b9430605a3ca6" translate="yes" xml:space="preserve">
          <source>The solution is to &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; out of the child directory to a place outside the directory tree to be removed.</source>
          <target state="translated">解決策は、削除する子ツリーからディレクトリツリーの外の場所に &lt;code&gt;&lt;a href=&quot;../functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; することです。</target>
        </trans-unit>
        <trans-unit id="25857c787c988fd69fb48ac1af38665d7f387a1d" translate="yes" xml:space="preserve">
          <source>The solution is to &lt;code&gt;chdir&lt;/code&gt; out of the child directory to a place outside the directory tree to be removed.</source>
          <target state="translated">解決策は、子ディレクトリから削除するディレクトリツリーの外側の場所に &lt;code&gt;chdir&lt;/code&gt; することです。</target>
        </trans-unit>
        <trans-unit id="f7391f9903f693d17725f8ae77b7a179797082b4" translate="yes" xml:space="preserve">
          <source>The solution is to use &lt;a href=&quot;perlfunc#__SUB__&quot;&gt;&lt;code&gt;__SUB__&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">解決策は&lt;a href=&quot;perlfunc#__SUB__&quot;&gt; &lt;code&gt;__SUB__&lt;/code&gt; &lt;/a&gt;を使用することです：</target>
        </trans-unit>
        <trans-unit id="8bd1e61d4eb0bbe0f75b3581782eef3e8dfaf4b4" translate="yes" xml:space="preserve">
          <source>The sort of characters we put into words. In Unicode, this is all letters including all ideographs and certain diacritics, letter numbers like Roman numerals, and various combining marks.</source>
          <target state="translated">私たちが言葉に入れる文字の種類。Unicodeでは、すべての表意文字や特定の記号、ローマ数字のような文字番号、さまざまな組み合わせ記号を含むすべての文字を指します。</target>
        </trans-unit>
        <trans-unit id="a1d44ffc9ae032aff54b02af9e8455f31b34d012" translate="yes" xml:space="preserve">
          <source>The sort order will cause differences between results obtained on ASCII platforms versus EBCDIC platforms. What follows are some suggestions on how to deal with these differences.</source>
          <target state="translated">ソート順によって、ASCIIプラットフォームとEBCDICプラットフォームで得られた結果に違いが生じます。以下に、これらの違いに対処するためのいくつかの提案を示します。</target>
        </trans-unit>
        <trans-unit id="89da5c4101906ac148b9121db995bfdaa11ef39f" translate="yes" xml:space="preserve">
          <source>The source buffer can either be a scalar or a scalar reference.</source>
          <target state="translated">ソースバッファはスカラかスカラ参照のどちらかになります。</target>
        </trans-unit>
        <trans-unit id="67687b08f8914b53b7f3846fac38e3b4363d7a5e" translate="yes" xml:space="preserve">
          <source>The source buffer, &lt;code&gt;$source&lt;/code&gt; , can either be a scalar or a scalar reference.</source>
          <target state="translated">ソースバッファー &lt;code&gt;$source&lt;/code&gt; は、スカラーまたはスカラー参照のいずれかです。</target>
        </trans-unit>
        <trans-unit id="8ca49df053b6c5ef6b6ff31bd8c0aacb4709988b" translate="yes" xml:space="preserve">
          <source>The source buffer, &lt;code&gt;$source&lt;/code&gt;, can either be a scalar or a scalar reference.</source>
          <target state="translated">ソースバッファ &lt;code&gt;$source&lt;/code&gt; は、スカラーまたはスカラー参照のいずれかです。</target>
        </trans-unit>
        <trans-unit id="1b7e9fa2ae5c5f428ffd5cfef77286b08b69792f" translate="yes" xml:space="preserve">
          <source>The source code for an extension usually resides in its own directory. At least three files are generally provided:</source>
          <target state="translated">通常、拡張機能のソースコードはそれ自身のディレクトリにあります。少なくとも3つのファイルが用意されているのが一般的です。</target>
        </trans-unit>
        <trans-unit id="1e4ee98da0c8794c248be818bce3b87507488dbe" translate="yes" xml:space="preserve">
          <source>The source code includes multiple hash algorithms to choose from. While we believe that the default perl hash is robust to attack, we have included the hash function Siphash as a fall-back option. At the time of release of Perl 5.18.0 Siphash is believed to be of cryptographic strength. This is not the default as it is much slower than the default hash.</source>
          <target state="translated">ソースコードには複数のハッシュアルゴリズムが含まれています。Perl のデフォルトのハッシュは攻撃に強いと信じていますが、フォールバックオプションとして Siphash というハッシュ関数が含まれています。Perl 5.18.0のリリース時点では、Siphashは暗号化の強度があると考えられています。デフォルトのハッシュよりもはるかに遅いので、これはデフォルトではありません。</target>
        </trans-unit>
        <trans-unit id="7a62a8b0275fb02e9e7293cb89d71dd692b01164" translate="yes" xml:space="preserve">
          <source>The source code is available on Git Hub: &lt;a href=&quot;https://github.com/maddingue/Sys-Syslog/&quot;&gt;https://github.com/maddingue/Sys-Syslog/&lt;/a&gt;</source>
          <target state="translated">ソースコードはGitHubで入手できます：&lt;a href=&quot;https://github.com/maddingue/Sys-Syslog/&quot;&gt;https&lt;/a&gt;：//github.com/maddingue/Sys-Syslog/</target>
        </trans-unit>
        <trans-unit id="d0caf29be420bbd199849ea512093a83580509aa" translate="yes" xml:space="preserve">
          <source>The source code locations are supported &lt;b&gt;only&lt;/b&gt; if you have the Developer Tools installed. (BFD is &lt;b&gt;not&lt;/b&gt; needed.)</source>
          <target state="translated">ソースコードの場所は、開発者ツールがインストールされている場合に&lt;b&gt;のみ&lt;/b&gt;サポートされます。（BFDは必要あり&lt;b&gt;ません&lt;/b&gt;。）</target>
        </trans-unit>
        <trans-unit id="077f75395915a901ad7c5804374f7d2b053abae0" translate="yes" xml:space="preserve">
          <source>The source code repository for HashBase can be found at</source>
          <target state="translated">HashBase のソースコードリポジトリは以下にあります。</target>
        </trans-unit>
        <trans-unit id="88b90b5da908771ba4301d860153882353d321fc" translate="yes" xml:space="preserve">
          <source>The source code repository for Test2 can be found at</source>
          <target state="translated">Test2 のソースコードリポジトリは次の場所にあります。</target>
        </trans-unit>
        <trans-unit id="edb2a3de91b362ca2b61febe5041a5a32501556d" translate="yes" xml:space="preserve">
          <source>The source code repository for Test::More can be found at</source>
          <target state="translated">Test::More のソースコードリポジトリは以下にあります。</target>
        </trans-unit>
        <trans-unit id="cf7f81d91f75175f1d8405190d2d3c385759d791" translate="yes" xml:space="preserve">
          <source>The source code repository for Time-Local can be found at &lt;a href=&quot;https://github.com/houseabsolute/Time-Local&quot;&gt;https://github.com/houseabsolute/Time-Local&lt;/a&gt;.</source>
          <target state="translated">Time-Localのソースコードリポジトリは&lt;a href=&quot;https://github.com/houseabsolute/Time-Local&quot;&gt;https://github.com/houseabsolute/Time-Localにあります&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="449ffcdb319b9addd8fd6dc6fc9226340b95b72f" translate="yes" xml:space="preserve">
          <source>The source filter distribution includes two modules that simplify this task: &lt;code&gt;Filter::exec&lt;/code&gt; and &lt;code&gt;Filter::sh&lt;/code&gt; . Both allow you to run any external executable. Both use a coprocess to control the flow of data into and out of the external executable. (For details on coprocesses, see Stephens, W.R., &quot;Advanced Programming in the UNIX Environment.&quot; Addison-Wesley, ISBN 0-210-56317-7, pages 441-445.) The difference between them is that &lt;code&gt;Filter::exec&lt;/code&gt; spawns the external command directly, while &lt;code&gt;Filter::sh&lt;/code&gt; spawns a shell to execute the external command. (Unix uses the Bourne shell; NT uses the cmd shell.) Spawning a shell allows you to make use of the shell metacharacters and redirection facilities.</source>
          <target state="translated">ソースフィルターの配布には、このタスクを簡略化する2つのモジュール &lt;code&gt;Filter::exec&lt;/code&gt; および &lt;code&gt;Filter::sh&lt;/code&gt; ます。どちらでも、外部の実行可能ファイルを実行できます。どちらもコプロセスを使用して、外部実行可能ファイルへのデータの流れを制御します。 （コプロセスの詳細については、Stephens、WR、「UNIX環境での高度なプログラミング」を参照してください。Addison-Wesley、ISBN 0-210-56317-7、ページ441-445。）これらの違いは、 &lt;code&gt;Filter::exec&lt;/code&gt; が生成することです。 &lt;code&gt;Filter::sh&lt;/code&gt; は外部コマンドを直接実行し、外部コマンドを実行するためにシェルを生成します。 （UnixはBourneシェルを使用し、NTはcmdシェルを使用します。）シェルを生成すると、シェルのメタキャラクターとリダイレクト機能を利用できます。</target>
        </trans-unit>
        <trans-unit id="806a2d069e5b8127ce418989da98faab2d6211ce" translate="yes" xml:space="preserve">
          <source>The source filter distribution includes two modules that simplify this task: &lt;code&gt;Filter::exec&lt;/code&gt; and &lt;code&gt;Filter::sh&lt;/code&gt;. Both allow you to run any external executable. Both use a coprocess to control the flow of data into and out of the external executable. (For details on coprocesses, see Stephens, W.R., &quot;Advanced Programming in the UNIX Environment.&quot; Addison-Wesley, ISBN 0-210-56317-7, pages 441-445.) The difference between them is that &lt;code&gt;Filter::exec&lt;/code&gt; spawns the external command directly, while &lt;code&gt;Filter::sh&lt;/code&gt; spawns a shell to execute the external command. (Unix uses the Bourne shell; NT uses the cmd shell.) Spawning a shell allows you to make use of the shell metacharacters and redirection facilities.</source>
          <target state="translated">ソースフィルター配布には、このタスクを簡素化する2つのモジュール &lt;code&gt;Filter::exec&lt;/code&gt; と &lt;code&gt;Filter::sh&lt;/code&gt; ます。どちらも、外部の実行可能ファイルを実行できます。どちらもコプロセスを使用して、外部実行可能ファイルに出入りするデータのフローを制御します。 （コプロセスの詳細については、Stephens、WR、 &quot;Advanced Programming in the UNIX Environment。&quot; Addison-Wesley、ISBN 0-210-56317-7、pages 441-445を参照してください。）これらの違いは、 &lt;code&gt;Filter::exec&lt;/code&gt; が生成されることです。 &lt;code&gt;Filter::sh&lt;/code&gt; がシェルを生成して外部コマンドを実行している間、外部コマンドを直接実行します。 （UnixはBourneシェルを使用し、NTはcmdシェルを使用します。）シェルを生成すると、シェルのメタ文字とリダイレクト機能を利用できます。</target>
        </trans-unit>
        <trans-unit id="ea0efb50a1d96794619b6be6780ccfe01a3a3f70" translate="yes" xml:space="preserve">
          <source>The source has to be set before you can parse anything. The lowest-level way is to call &lt;code&gt;set_source&lt;/code&gt; :</source>
          <target state="translated">何かを解析する前に、ソースを設定する必要があります。最低レベルの方法は &lt;code&gt;set_source&lt;/code&gt; を呼び出すことです：</target>
        </trans-unit>
        <trans-unit id="25772fbca2fac712b2b730121903ca4af8245b2c" translate="yes" xml:space="preserve">
          <source>The source has to be set before you can parse anything. The lowest-level way is to call &lt;code&gt;set_source&lt;/code&gt;:</source>
          <target state="translated">何かを解析する前に、ソースを設定する必要があります。最も低いレベルの方法は、 &lt;code&gt;set_source&lt;/code&gt; を呼び出すことです。</target>
        </trans-unit>
        <trans-unit id="30a7a830852a264986b70187999506a317874b7f" translate="yes" xml:space="preserve">
          <source>The source of ISO 3166-1 two-letter codes used by this module.</source>
          <target state="translated">このモジュールで使用されるISO 3166-1の2文字コードのソース。</target>
        </trans-unit>
        <trans-unit id="26888526042c45b79818c80cb5da539324a9402b" translate="yes" xml:space="preserve">
          <source>The source of the official ISO 3166-1 three-letter codes and three-digit codes.</source>
          <target state="translated">公式のISO3166-1の3文字コードと3桁コードのソースです。</target>
        </trans-unit>
        <trans-unit id="047e8113455a3b20776511dcfa749213b66f27f0" translate="yes" xml:space="preserve">
          <source>The source used to be tracked separately in another GitHub repo, but the canonical source is now in the above repo.</source>
          <target state="translated">以前は別のGitHubレポで別々に追跡されていましたが、正式なソースは上記のレポにあります。</target>
        </trans-unit>
        <trans-unit id="454a907e32531c807293e3735238b43baf267920" translate="yes" xml:space="preserve">
          <source>The special argument of &lt;code&gt;h h&lt;/code&gt; produces the entire help page, which is quite long.</source>
          <target state="translated">&lt;code&gt;h h&lt;/code&gt; の特別な引数は、非常に長いヘルプページ全体を生成します。</target>
        </trans-unit>
        <trans-unit id="c6f65c11625ca6f6efd4fce69ae54247f9d5fb65" translate="yes" xml:space="preserve">
          <source>The special bookkeeping Perl does to track the flow of external data through your program and disallow their use in system commands.</source>
          <target state="translated">Perl が行う特別なブックキーピングは、プログラムを介した外部データの流れを追跡し、システムコマンドでの使用を禁止するためのものです。</target>
        </trans-unit>
        <trans-unit id="fbeef28b2f2c3763e9cdd6d44783f63733b4347f" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that a contiguous set of characters can be written as a range. With ranges, the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt; . Some examples are</source>
          <target state="translated">特殊文字 &lt;code&gt;'-'&lt;/code&gt; は文字クラス内の範囲演算子として機能するため、連続した文字のセットを範囲として書き込むことができます。範囲を指定すると、扱いにくい &lt;code&gt;[0123456789]&lt;/code&gt; と &lt;code&gt;[abc...xyz]&lt;/code&gt; が厳密な &lt;code&gt;[0-9]&lt;/code&gt; と &lt;code&gt;[a-z]&lt;/code&gt; ます。いくつかの例は</target>
        </trans-unit>
        <trans-unit id="51484dcb28cfa30c1085fd011a68713265cc9b21" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that a contiguous set of characters can be written as a range. With ranges, the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt;. Some examples are</source>
          <target state="translated">特殊文字 &lt;code&gt;'-'&lt;/code&gt; は、文字クラス内で範囲演算子として機能するため、連続する文字セットを範囲として書き込むことができます。範囲を指定すると、扱いにくい &lt;code&gt;[0123456789]&lt;/code&gt; と &lt;code&gt;[abc...xyz]&lt;/code&gt; が滑らかな &lt;code&gt;[0-9]&lt;/code&gt; と &lt;code&gt;[a-z]&lt;/code&gt; ます。いくつかの例は</target>
        </trans-unit>
        <trans-unit id="3a71b165b4e188832e186d5361505b47059b1afc" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt; :</source>
          <target state="translated">特殊文字 &lt;code&gt;'-'&lt;/code&gt; は文字クラス内で範囲演算子として機能するため、扱いにくい &lt;code&gt;[0123456789]&lt;/code&gt; と &lt;code&gt;[abc...xyz]&lt;/code&gt; は厳密な &lt;code&gt;[0-9]&lt;/code&gt; と &lt;code&gt;[a-z]&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="283724a0a196c8e1912b746979d3d1ad3654c817" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'-'&lt;/code&gt; acts as a range operator within character classes, so that the unwieldy &lt;code&gt;[0123456789]&lt;/code&gt; and &lt;code&gt;[abc...xyz]&lt;/code&gt; become the svelte &lt;code&gt;[0-9]&lt;/code&gt; and &lt;code&gt;[a-z]&lt;/code&gt;:</source>
          <target state="translated">特殊文字 &lt;code&gt;'-'&lt;/code&gt; は文字クラス内で範囲演算子として機能するため、扱いにくい &lt;code&gt;[0123456789]&lt;/code&gt; と &lt;code&gt;[abc...xyz]&lt;/code&gt; は洗練された &lt;code&gt;[0-9]&lt;/code&gt; と &lt;code&gt;[a-z]&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="9e3d6c0c10b1c629e2125d262c610ffe5039c3e0" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;'^'&lt;/code&gt; in the first position of a character class denotes a</source>
          <target state="translated">文字クラスの最初の位置にある特殊文字 &lt;code&gt;'^'&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="c1d9d9306fb9aa515c3bd892587a0587d3baf9f6" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;^&lt;/code&gt; in the first position of a character class denotes a</source>
          <target state="translated">文字クラスの最初の位置にある特殊文字 &lt;code&gt;^&lt;/code&gt; は、</target>
        </trans-unit>
        <trans-unit id="8afc59f37c7b54c4d8a636841474cf58beb13e84" translate="yes" xml:space="preserve">
          <source>The special character &lt;code&gt;^&lt;/code&gt; in the first position of a character class denotes a &lt;b&gt;negated character class&lt;/b&gt;, which matches any character but those in the brackets. Both &lt;code&gt;[...]&lt;/code&gt; and &lt;code&gt;[^...]&lt;/code&gt; must match a character, or the match fails. Then</source>
          <target state="translated">文字クラスの最初の位置にある特殊文字 &lt;code&gt;^&lt;/code&gt; は、&lt;b&gt;否定され&lt;/b&gt;た文字クラスを示します。これは、括弧内の文字以外のすべての文字と一致します。 &lt;code&gt;[...]&lt;/code&gt; と &lt;code&gt;[^...]&lt;/code&gt; 両方が文字と一致する必要があります。一致しない場合、一致は失敗します。その後</target>
        </trans-unit>
        <trans-unit id="94d7fdb99f703e5dc3a7ffcb7bb005616b504881" translate="yes" xml:space="preserve">
          <source>The special filehandle that iterates over command-line filenames in &lt;code&gt;@ARGV&lt;/code&gt; . Usually written as the null filehandle in the angle operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . Note that currently &lt;code&gt;ARGV&lt;/code&gt; only has its magical effect within the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator; elsewhere it is just a plain filehandle corresponding to the last file opened by &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; . In particular, passing &lt;code&gt;\*ARGV&lt;/code&gt; as a parameter to a function that expects a filehandle may not cause your function to automatically read the contents of all the files in &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">&lt;code&gt;@ARGV&lt;/code&gt; のコマンドラインファイル名を反復処理する特別なファイルハンドル。通常、角度演算子 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; の nullファイルハンドルとして書き込まれます。現在 &lt;code&gt;ARGV&lt;/code&gt; は、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 演算子内でのみ魔法の効果を持っていることに注意してください。他の場所では、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; によって開かれた最後のファイルに対応する単なるファイルハンドルです。特に、 &lt;code&gt;\*ARGV&lt;/code&gt; をパラメーターとしてファイルハンドルを必要とする関数に &lt;code&gt;@ARGV&lt;/code&gt; と、関数が@ARGV内のすべてのファイルの内容を自動的に読み取ることができない場合があります。</target>
        </trans-unit>
        <trans-unit id="ac1da88fc9d1c37eca9b801363ceb623fe61bad6" translate="yes" xml:space="preserve">
          <source>The special filehandle that iterates over command-line filenames in &lt;code&gt;@ARGV&lt;/code&gt;. Usually written as the null filehandle in the angle operator &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. Note that currently &lt;code&gt;ARGV&lt;/code&gt; only has its magical effect within the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator; elsewhere it is just a plain filehandle corresponding to the last file opened by &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;. In particular, passing &lt;code&gt;\*ARGV&lt;/code&gt; as a parameter to a function that expects a filehandle may not cause your function to automatically read the contents of all the files in &lt;code&gt;@ARGV&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@ARGV&lt;/code&gt; のコマンドラインファイル名を反復処理する特別なファイルハンドル。通常、角度演算子 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ではnullファイルハンドルとして記述されます。現在、 &lt;code&gt;ARGV&lt;/code&gt; は &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 演算子内でのみ魔法の効果があることに注意してください。他の場所では、 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; によって開かれた最後のファイルに対応する単なるファイルハンドルです。特に、 &lt;code&gt;\*ARGV&lt;/code&gt; をパラメーターとしてファイルハンドルを期待する関数に &lt;code&gt;@ARGV&lt;/code&gt; と、関数が@ARGV内のすべてのファイルの内容を自動的に読み取らない場合があります。</target>
        </trans-unit>
        <trans-unit id="f805e5a7fa6e6a7379f92a69ce80440a9d42a7c7" translate="yes" xml:space="preserve">
          <source>The special filehandle that points to the currently open output file when doing edit-in-place processing with &lt;b&gt;-i&lt;/b&gt;. Useful when you have to do a lot of inserting and don't want to keep modifying &lt;code&gt;$_&lt;/code&gt; . See &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; for the &lt;b&gt;-i&lt;/b&gt; switch.</source>
          <target state="translated">&lt;b&gt;-iを使用&lt;/b&gt;してインプレース編集処理を行うときに現在開いている出力ファイルを指す特別なファイルハンドル。多くの挿入を行う必要があり、 &lt;code&gt;$_&lt;/code&gt; 変更し続けたくない場合に役立ちます。&lt;b&gt;-i&lt;/b&gt;スイッチについては&lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;を参照してください。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b0f0f7c3f4bb49e8602e83db9899cb43d8c4eab1" translate="yes" xml:space="preserve">
          <source>The special filehandle that points to the currently open output file when doing edit-in-place processing with &lt;b&gt;-i&lt;/b&gt;. Useful when you have to do a lot of inserting and don't want to keep modifying &lt;code&gt;$_&lt;/code&gt;. See &lt;a href=&quot;perlrun#-i%5Bextension%5D&quot;&gt;perlrun&lt;/a&gt; for the &lt;b&gt;-i&lt;/b&gt; switch.</source>
          <target state="translated">&lt;b&gt;-iを使用&lt;/b&gt;してインプレース編集処理を実行するときに、現在開いている出力ファイルを指す特別なファイルハンドル。多くの挿入を行う必要があり、 &lt;code&gt;$_&lt;/code&gt; 変更し続けたくない場合に便利です。&lt;b&gt;-i&lt;/b&gt;スイッチについては、&lt;a href=&quot;perlrun#-i%5Bextension%5D&quot;&gt;perlrun&lt;/a&gt;を参照してください。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1c54707234ac101d1520e7aec3c57187de852952" translate="yes" xml:space="preserve">
          <source>The special filename &quot;-&quot; can be used as a standin for both &lt;code&gt;\*STDIN&lt;/code&gt; and &lt;code&gt;\*STDOUT&lt;/code&gt;, so the above can be rewritten as</source>
          <target state="translated">特別なファイル名「-」は、 &lt;code&gt;\*STDIN&lt;/code&gt; と &lt;code&gt;\*STDOUT&lt;/code&gt; の両方の代用として使用できるため、上記は次のように書き換えることができます。</target>
        </trans-unit>
        <trans-unit id="25d2e9e8733979d7b1492fbdd9a7cb623d57628f" translate="yes" xml:space="preserve">
          <source>The special literals __FILE__, __LINE__, and __PACKAGE__ represent the current filename, line number, and package name at that point in your program. __SUB__ gives a reference to the current subroutine. They may be used only as separate tokens; they will not be interpolated into strings. If there is no current package (due to an empty &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; directive), __PACKAGE__ is the undefined value. (But the empty &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; is no longer supported, as of version 5.10.) Outside of a subroutine, __SUB__ is the undefined value. __SUB__ is only available in 5.16 or higher, and only with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature &quot;current_sub&quot;&lt;/code&gt; declaration.</source>
          <target state="translated">特別なリテラル__FILE __、__ LINE__、および__PACKAGE__は、プログラムのその時点での現在のファイル名、行番号、およびパッケージ名を表します。 __SUB__は、現在のサブルーチンへの参照を提供します。それらは別個のトークンとしてのみ使用できます。それらは文字列に補間されません。現在のパッケージがない場合（空の &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; ディレクティブにより）、__ PACKAGE__は未定義の値です。 （ただし、空の &lt;code&gt;&lt;a href=&quot;functions/package&quot;&gt;package;&lt;/a&gt;&lt;/code&gt; バージョン5.10以降、サポートされなくなりました。）サブルーチンの外では、__ SUB__は未定義の値です。 __SUB__は、5.16以降でのみ使用でき、 &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.16&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature &quot;current_sub&quot;&lt;/code&gt; 宣言でのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="320950a977dc3e4b6b51f0cd126847e374ebbae7" translate="yes" xml:space="preserve">
          <source>The special literals __FILE__, __LINE__, and __PACKAGE__ represent the current filename, line number, and package name at that point in your program. __SUB__ gives a reference to the current subroutine. They may be used only as separate tokens; they will not be interpolated into strings. If there is no current package (due to an empty &lt;code&gt;package;&lt;/code&gt; directive), __PACKAGE__ is the undefined value. (But the empty &lt;code&gt;package;&lt;/code&gt; is no longer supported, as of version 5.10.) Outside of a subroutine, __SUB__ is the undefined value. __SUB__ is only available in 5.16 or higher, and only with a &lt;code&gt;use v5.16&lt;/code&gt; or &lt;code&gt;use feature &quot;current_sub&quot;&lt;/code&gt; declaration.</source>
          <target state="translated">特別なリテラル__FILE __、__ LINE__、および__PACKAGE__は、プログラムのその時点での現在のファイル名、行番号、およびパッケージ名を表します。 __SUB__は、現在のサブルーチンへの参照を提供します。これらは個別のトークンとしてのみ使用できます。それらは文字列に補間されません。現在のパッケージがない場合（空の &lt;code&gt;package;&lt;/code&gt; ディレクティブのため）、__ PACKAGE__は未定義の値です。 （ただし、空の &lt;code&gt;package;&lt;/code&gt; バージョン5.10以降、サポートされなくなりました。）サブルーチン以外では、__ SUB__は未定義の値です。 __SUB__は、5.16以降でのみ使用可能であり、 &lt;code&gt;use v5.16&lt;/code&gt; &lt;code&gt;use feature &quot;current_sub&quot;&lt;/code&gt; か、機能「current_sub」宣言を使用する場合にのみ使用できます。</target>
        </trans-unit>
        <trans-unit id="6af0b63b67806c6dfb7b9ddb2d398096248ddab4" translate="yes" xml:space="preserve">
          <source>The special mark that tells the operating system it can run this program. There are actually three execute bits under Unix, and which bit gets used depends on whether you own the file singularly, collectively, or not at all.</source>
          <target state="translated">このプログラムを実行できることをオペレーティングシステムに伝える特別なマークです。Unix では実際には 3 つの実行ビットがあり、どのビットが使用されるかは、そのファイルを単独で所有しているのか、まとめて所有しているのか、あるいは全く所有していないのかによって異なります。</target>
        </trans-unit>
        <trans-unit id="6429c59caa249ed4d6719a4eab753f28d6cfd25d" translate="yes" xml:space="preserve">
          <source>The special methods &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::can&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;maybe::next::method&lt;/code&gt; are not available until this &lt;code&gt;mro&lt;/code&gt; module has been loaded via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">特別なメソッド &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; 、 &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::can&lt;/a&gt;&lt;/code&gt; 、および &lt;code&gt;maybe::next::method&lt;/code&gt; は、この &lt;code&gt;mro&lt;/code&gt; モジュールが &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; または &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; によってロードされるまで使用できません。</target>
        </trans-unit>
        <trans-unit id="cc7c3c8f9444854b13225185a30e005803243a24" translate="yes" xml:space="preserve">
          <source>The special methods &lt;code&gt;next::method&lt;/code&gt;, &lt;code&gt;next::can&lt;/code&gt;, and &lt;code&gt;maybe::next::method&lt;/code&gt; are not available until this &lt;code&gt;mro&lt;/code&gt; module has been loaded via &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;.</source>
          <target state="translated">特別なメソッド &lt;code&gt;next::method&lt;/code&gt; 、 &lt;code&gt;next::can&lt;/code&gt; 、および &lt;code&gt;maybe::next::method&lt;/code&gt; は、この &lt;code&gt;mro&lt;/code&gt; モジュールが &lt;code&gt;use&lt;/code&gt; または &lt;code&gt;require&lt;/code&gt; によってロードされるまで使用できません。</target>
        </trans-unit>
        <trans-unit id="c41f3d15a857df9bc04fff7f6a7434b18442c584" translate="yes" xml:space="preserve">
          <source>The special quoting behavior ignores precedence, and hence may apply to</source>
          <target state="translated">特別な引用の動作は優先順位を無視します。</target>
        </trans-unit>
        <trans-unit id="6bd162b2c252e6c76a44c9033fc601bb11a084ee" translate="yes" xml:space="preserve">
          <source>The special string &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; is exempt from &lt;a href=&quot;perldiag#Argument-%22%25s%22-isn%27t-numeric%25s&quot;&gt;&lt;code&gt;Argument &quot;...&quot; isn't numeric&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt; on improper numeric conversions.</source>
          <target state="translated">特別な文字列 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; は&lt;a href=&quot;perldiag#Argument-%22%25s%22-isn%27t-numeric%25s&quot;&gt; &lt;code&gt;Argument &quot;...&quot; isn't numeric&lt;/code&gt; &lt;/a&gt;から除外され&lt;a href=&quot;warnings&quot;&gt;ますが&lt;/a&gt;、不適切な数値変換に関する数値警告ではありません。</target>
        </trans-unit>
        <trans-unit id="79a2544429fe460799a8292535fcaefc5e4c6c60" translate="yes" xml:space="preserve">
          <source>The special string &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; is exempt from &lt;b&gt;-w&lt;/b&gt; complaints about improper numeric conversions.</source>
          <target state="translated">特別な文字列 &lt;code&gt;&quot;0 but true&quot;&lt;/code&gt; は、不適切な数値変換に関する&lt;b&gt;-w&lt;/b&gt;クレームから免除されます。</target>
        </trans-unit>
        <trans-unit id="026f6dfd3d9c99c5a9bfd6afe8ee0f79daedf36d" translate="yes" xml:space="preserve">
          <source>The special symbol &lt;code&gt;__PACKAGE__&lt;/code&gt; contains the current package, but cannot (easily) be used to construct variable names.</source>
          <target state="translated">特別なシンボル &lt;code&gt;__PACKAGE__&lt;/code&gt; には現在のパッケージが含まれていますが、変数名の作成には（簡単に）使用できません。</target>
        </trans-unit>
        <trans-unit id="ec16f658ce9778430c3bc19ca22d2cf08596e063" translate="yes" xml:space="preserve">
          <source>The special symbol &lt;code&gt;__PACKAGE__&lt;/code&gt; contains the current package, but cannot (easily) be used to construct variable names. After &lt;code&gt;my($foo)&lt;/code&gt; has hidden package variable &lt;code&gt;$foo&lt;/code&gt;, it can still be accessed, without knowing what package you are in, as &lt;code&gt;${__PACKAGE__.'::foo'}&lt;/code&gt;.</source>
          <target state="translated">特別なシンボル &lt;code&gt;__PACKAGE__&lt;/code&gt; には現在のパッケージが含まれていますが、変数名の作成に（簡単に）使用することはできません。 &lt;code&gt;my($foo)&lt;/code&gt; がパッケージ変数 &lt;code&gt;$foo&lt;/code&gt; 非表示にした後でも、 &lt;code&gt;${__PACKAGE__.'::foo'}&lt;/code&gt; ように、どのパッケージに入っているかを知らなくてもアクセスできます。</target>
        </trans-unit>
        <trans-unit id="8f36c55aa844c8a0dac4156e30712cffbcd8a9f0" translate="yes" xml:space="preserve">
          <source>The special two-argument form of Perl's open() function ignores trailing blanks in filenames and infers the mode from certain leading characters (or a trailing &quot;|&quot;). In older versions of Perl this was the only version of open() and so it is prevalent in old code and books.</source>
          <target state="translated">Perl の open()関数の特別な 2 引数形式は、ファイル名の末尾の空白を無視し、特定の先頭文字 (または末尾の &quot;|&quot; からモードを推測します)からモードを推測します。古いバージョンの Perl ではこれが唯一の open()のバージョンだったため、古いコードや書籍ではこれが普及しています。</target>
        </trans-unit>
        <trans-unit id="161a5a9075bb6b7595615ee16fc183085e48d829" translate="yes" xml:space="preserve">
          <source>The special value 00 will cause Perl to slurp files in paragraph mode. Any value 0400 or above will cause Perl to slurp files whole, but by convention the value 0777 is the one normally used for this purpose.</source>
          <target state="translated">特別な値 00 は、Perl が段落モードでファイルをスラスパ処理します。0400以上の値を指定すると、Perlはファイル全体をスラスパ処理しますが、慣習上、この目的のために通常使用されるのは値0777です。</target>
        </trans-unit>
        <trans-unit id="510ff7ba673af9c07da4bdf1546cce9f48d4aa9d" translate="yes" xml:space="preserve">
          <source>The special variable &lt;code&gt;$#array&lt;/code&gt; tells you the index of the last element of an array:</source>
          <target state="translated">特殊変数 &lt;code&gt;$#array&lt;/code&gt; は、配列の最後の要素のインデックスを示します。</target>
        </trans-unit>
        <trans-unit id="7bf5f587af4320b4f6a337ef8e71a1acc59dbd84" translate="yes" xml:space="preserve">
          <source>The special variable &lt;code&gt;${^ENCODING}&lt;/code&gt; was used to implement the &lt;code&gt;encoding&lt;/code&gt; pragma. Setting this variable to anything other than &lt;code&gt;undef&lt;/code&gt; was deprecated in Perl 5.22. Full deprecation of the variable happened in Perl 5.25.3.</source>
          <target state="translated">特別な変数 &lt;code&gt;${^ENCODING}&lt;/code&gt; は、 &lt;code&gt;encoding&lt;/code&gt; プラグマを実装するために使用されました。この変数を &lt;code&gt;undef&lt;/code&gt; 以外に設定することは、Perl5.22で非推奨になりました。変数の完全な非推奨はPerl5.25.3で起こりました。</target>
        </trans-unit>
        <trans-unit id="848d9f1e6794b744b742b40d6e30625dbd74dd9d" translate="yes" xml:space="preserve">
          <source>The special variables for formats are a subset of those for filehandles. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for more information about Perl's formats.</source>
          <target state="translated">フォーマットの特殊変数は、ファイルハンドルの特殊変数のサブセットです。Perlのフォーマットの詳細については、&lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="d50e7fd9df415ed27a91da10839b57126db4d317" translate="yes" xml:space="preserve">
          <source>The special verbosity level 99 requires to also specify the -sections parameter; then these sections are extracted and printed.</source>
          <target state="translated">特殊冗長度レベル99では、-sectionsパラメータも指定する必要があり、これらのセクションが抽出されて印刷されます。</target>
        </trans-unit>
        <trans-unit id="79d7da7f02ba1ece997a8e1f533d9c05c192eb59" translate="yes" xml:space="preserve">
          <source>The specific task here is to sort the 286,525 lines of this file by Response Code, Query, Browser, Referring Url, and lastly Date. One solution might be to use the following code, which iterates over the files given on the command-line.</source>
          <target state="translated">ここでの具体的なタスクは、このファイルの286,525行をレスポンスコード、クエリ、ブラウザ、参照先URL、そして最後に日付でソートすることです。一つの解決策は、コマンドラインで与えられたファイルを繰り返し処理する以下のコードを使用することかもしれません。</target>
        </trans-unit>
        <trans-unit id="ec45d65d2602c92bff90edfa34bc341572780991" translate="yes" xml:space="preserve">
          <source>The specification of ISO-2022 is available from the link above.</source>
          <target state="translated">ISO-2022の仕様については、上記リンクよりご確認いただけます。</target>
        </trans-unit>
        <trans-unit id="61bf1ad08824c740b76048cd4f454fa0d05ebcf4" translate="yes" xml:space="preserve">
          <source>The specification which tar derives from; &lt;code&gt; &lt;a href=&quot;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&quot;&gt;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">tarの派生元の仕様。 &lt;code&gt; &lt;a href=&quot;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&quot;&gt;http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6cea1ce6b94b1cce0327c439743891bfb6f47d86" translate="yes" xml:space="preserve">
          <source>The specification which tar derives from; &lt;code&gt; http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&lt;/code&gt;</source>
          <target state="translated">tarが由来する仕様。 &lt;code&gt; http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="040046de0f6316ea231530079dbf44ad18b9f542" translate="yes" xml:space="preserve">
          <source>The specifications are returned in increasing order of arguments starting at 0 (e.g. ';$') or 1 (e.g. '$@'). Note that if the prototype is &quot;slurpy&quot; (e.g. ends with a &quot;@&quot;), the number of arguments for the last specification is a &quot;minimum&quot; number rather than an exact number. This can be detected by the last member of the last specification matching m/[@#]_/.</source>
          <target state="translated">仕様は0(例:';$')または1(例:'$@')から始まる引数の多い順に返されます。プロトタイプが &quot;slurpy &quot;である場合(例えば&quot;@&quot;で終わる場合)、最後の仕様の引数の数は正確な数ではなく &quot;最小 &quot;の数であることに注意してください。これは、最後の仕様の最後のメンバがm/[@#]_/にマッチすることで検出することができます。</target>
        </trans-unit>
        <trans-unit id="5249ead0cea582438ce306dee2ff065c9121394e" translate="yes" xml:space="preserve">
          <source>The specified</source>
          <target state="translated">指定された</target>
        </trans-unit>
        <trans-unit id="0bbf6ce071adc9bbc621e13b2eb0c9adb5ed909d" translate="yes" xml:space="preserve">
          <source>The specified filtering subroutine is called every time a &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG&lt;/code&gt; is encountered, and passed all the source code following that call, up to either the next &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; (or whatever terminator you've set) or the end of the source file, whichever occurs first. By default, any &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;
BANG;&lt;/code&gt; call must appear by itself on a separate line, or it is ignored.</source>
          <target state="translated">指定されたフィルタリングサブルーチンは、 &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; BANG&lt;/code&gt; が検出されるたびに呼び出され、その呼び出しに続くすべてのソースコードを次 &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; まですべて渡します。（または設定したターミネータ）またはソースファイルの最後のいずれか最初に発生した方。デフォルトでは &lt;code&gt;&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt; BANG;&lt;/code&gt; はありません。呼び出しは単独で別の行に表示する必要があります。そうしないと無視されます。</target>
        </trans-unit>
        <trans-unit id="4c32a119deb019c17dccde9cf5e6d747da8ced23" translate="yes" xml:space="preserve">
          <source>The specified filtering subroutine is called every time a &lt;code&gt;use BANG&lt;/code&gt; is encountered, and passed all the source code following that call, up to either the next &lt;code&gt;no BANG;&lt;/code&gt; (or whatever terminator you've set) or the end of the source file, whichever occurs first. By default, any &lt;code&gt;no BANG;&lt;/code&gt; call must appear by itself on a separate line, or it is ignored.</source>
          <target state="translated">指定されたフィルタリングサブルーチンは、 &lt;code&gt;use BANG&lt;/code&gt; が検出されるたびに呼び出され、その呼び出しに続いて、次 &lt;code&gt;no BANG;&lt;/code&gt; までのすべてのソースコードを渡します。（または設定したターミネータ）またはソースファイルの終わりのいずれか早い方。デフォルトでは &lt;code&gt;no BANG;&lt;/code&gt; はありません。呼び出しは、それ自体で別の行に表示される必要があります。そうでない場合、無視されます。</target>
        </trans-unit>
        <trans-unit id="888fda8ce1b72f373cbaac5341a6655b0d4c64f9" translate="yes" xml:space="preserve">
          <source>The splain Program</source>
          <target state="translated">スプレンプログラム</target>
        </trans-unit>
        <trans-unit id="c52324d25d30fa15232ecb990b5648a4dcfeb28a" translate="yes" xml:space="preserve">
          <source>The split function</source>
          <target state="translated">スプリット機能</target>
        </trans-unit>
        <trans-unit id="ddfcdc05a5251df7fbf9a8a775f1e8025aac3f91" translate="yes" xml:space="preserve">
          <source>The split operator</source>
          <target state="translated">分割演算子</target>
        </trans-unit>
        <trans-unit id="62b2eb8876cf935a6917a946dbc16da0fe289ddf" translate="yes" xml:space="preserve">
          <source>The square brackets explicitly turn a list value into a scalar value, while parentheses do not. So when a parenthesized list is evaluated in a scalar context, the comma is treated like C's comma operator, which throws away the left argument, which is not what you want. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; for more on this.</source>
          <target state="translated">角括弧は明示的にリスト値をスカラー値に変換しますが、括弧は変換しません。したがって、括弧で囲まれたリストがスカラーコンテキストで評価される場合、コンマはCのコンマ演算子のように扱われ、左引数を破棄しますが、これは必要なことではありません。詳しくは&lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="daa1d51a4ab5d5dc2b248180c01a452f38c9d08d" translate="yes" xml:space="preserve">
          <source>The square brackets make a reference to a new array with a</source>
          <target state="translated">角括弧は、新しい配列への参照として</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
